{
  "metadata": {
    "timestamp": 1736554965693,
    "page": 30,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jlevy/the-art-of-command-line",
      "stars": 154306,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01,
          "content": ".gitignore\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 34.54,
          "content": "# Authors\n\nThis work is the result of the effort of many people around the world.\nContributors are listed in alphabetical order by GitHub login.\n\nSome contributors are also assigned roles as maintainers.\nThey have kindly agreed to review and help update future contributions for the translation or section they own.\n\n\n\n*Maintainers*\n\n* [Ahmad Zafrullah (23Pstars)](https://github.com/23Pstars) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=23Pstars)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3A23Pstars) — _translation maintainer (id)_\n* [Anna Damtsa (anna-d)](https://github.com/anna-d) — [24+](https://github.com/jlevy/the-art-of-command-line/commits?author=anna-d)/[7+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aanna-d) — _translation maintainer (el)_\n* [Carlos Mantilla (ceoaliongroo)](https://github.com/ceoaliongroo) — [29+](https://github.com/jlevy/the-art-of-command-line/commits?author=ceoaliongroo)/[16+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aceoaliongroo) — _translation maintainer (es)_\n* [Dmytro Kovalov (uk: Дмитро Ковальов) (dmytro)](https://github.com/dmytro) — [6+](https://github.com/jlevy/the-art-of-command-line/commits?author=dmytro)/[4+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Admytro) — _translation maintainer (uk)_\n* [Hayato Matsuura (doublemarket)](https://github.com/doublemarket) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=doublemarket)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adoublemarket) — _translation maintainer (ja)_\n* [Diomidis Spinellis (dspinellis)](https://github.com/dspinellis) — [15+](https://github.com/jlevy/the-art-of-command-line/commits?author=dspinellis)/[11+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adspinellis) — _section maintainer (Windows)_\n* [Éric Guirbal (ericguirbal)](https://github.com/ericguirbal) — [31+](https://github.com/jlevy/the-art-of-command-line/commits?author=ericguirbal)/[14+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aericguirbal) — _translation maintainer (fr)_\n* [Francesco Malatesta (francescomalatesta)](https://github.com/francescomalatesta) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=francescomalatesta)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Afrancescomalatesta) — _translation maintainer (it)_\n* [Joshua Levy (jlevy)](https://github.com/jlevy) — [162+](https://github.com/jlevy/the-art-of-command-line/commits?author=jlevy)/[59+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajlevy) — _original author and project maintainer_\n* [kevingo (kevingo)](https://github.com/kevingo) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=kevingo)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akevingo) — _translation maintainer (zh-Hant)_\n* [lsrom](https://github.com/lsrom) — [14+](https://github.com/jlevy/the-art-of-command-line/commits?author=lsrom)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Alsrom) — _translation maintainer (cs)_\n* [Mihai Maruseac (mihaimaruseac)](https://github.com/mihaimaruseac) — [10+](https://github.com/jlevy/the-art-of-command-line/commits?author=mihaimaruseac)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amihaimaruseac) — _translation maintainer (ro)_\n* [Nilton Vasques (niltonvasques)](https://github.com/niltonvasques) — [24+](https://github.com/jlevy/the-art-of-command-line/commits?author=niltonvasques)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aniltonvasques) — _translation maintainer (pt)_\n* [Oleg Berman (olegberman)](https://github.com/olegberman) — [15+](https://github.com/jlevy/the-art-of-command-line/commits?author=olegberman)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aolegberman) — _translation maintainer (ru)_\n* [Peter Kokot (petk)](https://github.com/petk) — [54+](https://github.com/jlevy/the-art-of-command-line/commits?author=petk)/[39+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Apetk) — _translation maintainer (sl)_\n* [Chujie Zeng (Psycho7)](https://github.com/Psycho7) — [25+](https://github.com/jlevy/the-art-of-command-line/commits?author=Psycho7)/[9+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3APsycho7) — _translation maintainer (zh)_\n* [Martin Folkers (S1SYPHOS)](https://github.com/S1SYPHOS) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=S1SYPHOS)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AS1SYPHOS) — _translation maintainer (de)_\n* [Stepan Babala (stepan0904)](https://github.com/stepan0904) — [37+](https://github.com/jlevy/the-art-of-command-line/commits?author=stepan0904)/[6+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Astepan0904) — _translation (uk)_\n* [Ungsik Yun (Ungsik-Yun)](https://github.com/Ungsik-Yun) — [15+](https://github.com/jlevy/the-art-of-command-line/commits?author=Ungsik-Yun)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AUngsik-Yun) — _translation maintainer (ko)_\n\n*Translators*\n\n* [Antonio Ossa (aaossa)](https://github.com/aaossa) — [5+](https://github.com/jlevy/the-art-of-command-line/commits?author=aaossa)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aaaossa) — _translator (es)_\n* [Chong Guo (Armour)](https://github.com/Armour) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=Armour)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AArmour) — _translator (zh)_\n* [Bogdan Luput (bgdnlp)](https://github.com/bgdnlp) — _translator (ro)_\n* [Alex Vergara Gil (BishopWolf)](https://github.com/BishopWolf) — [4+](https://github.com/jlevy/the-art-of-command-line/commits?author=BishopWolf)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ABishopWolf) — _translator (es)_\n* [Gernot Pointner (gernd)](https://github.com/gernd) — [6+](https://github.com/jlevy/the-art-of-command-line/commits?author=gernd)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agernd) — _translator (de)_\n* [githubashto](https://github.com/githubashto) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=githubashto)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agithubashto) — _translator (ru)_\n* [Grigory Rechistov (grigory-rechistov)](https://github.com/grigory-rechistov) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=grigory-rechistov)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agrigory-rechistov) — _translator (ru)_\n* [Sung Kim (hunkim)](https://github.com/hunkim) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=hunkim)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ahunkim) — _translator (ko)_\n* [kstn (kastian)](https://github.com/kastian) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=kastian)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akastian) — _translator (ru)_\n* [Kohei Takada (koh7)](https://github.com/koh7) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=koh7)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akoh7) — _translator (ja)_\n* [osmero](https://github.com/osmero) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=osmero)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aosmero) — _translator (ru)_\n* [Remi Verchere (rverchere)](https://github.com/rverchere) — _translator (fr)_\n* [Snowcat8436 (Snowcat8436)](https://github.com/Snowcat8436) — [4+](https://github.com/jlevy/the-art-of-command-line/commits?author=Snowcat8436)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ASnowcat8436) — _translator (ko)_\n* [spmbt (spmbt)](https://github.com/spmbt) — [13+](https://github.com/jlevy/the-art-of-command-line/commits?author=spmbt)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aspmbt) — _translator (ru)_\n* [Steven Liu (stevenlordiam)](https://github.com/stevenlordiam) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=stevenlordiam)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Astevenlordiam) — _translator (zh)_\n* [Thomas Sungjin Kang (ujuc)](https://github.com/ujuc) — [6+](https://github.com/jlevy/the-art-of-command-line/commits?author=ujuc)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aujuc) — _translator (ko)_\n* [Valeria de Paiva (vcvpaiva)](https://github.com/vcvpaiva) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=vcvpaiva)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Avcvpaiva) — _translator (pt)_\n* [Xu Chunyang (xuchunyang)](https://github.com/xuchunyang) — [13+](https://github.com/jlevy/the-art-of-command-line/commits?author=xuchunyang)/[7+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Axuchunyang) — _translator (zh)_\n\n*Contributors*\n\n* [0xCD](https://github.com/0xCD) — [4+](https://github.com/jlevy/the-art-of-command-line/commits?author=0xCD)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3A0xCD)\n* [0xmohit](https://github.com/0xmohit) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=0xmohit)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3A0xmohit)\n* [Jiang Guoxi (374632897)](https://github.com/374632897) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=374632897)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3A374632897)\n* [Andrii (aaabramov)](https://github.com/aaabramov) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=aaabramov)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aaaabramov)\n* [Ahmet Alp Balkan (ahmetb)](https://github.com/ahmetb) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=ahmetb)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aahmetb)\n* [Alexander Bodin (AlexanderBodin)](https://github.com/AlexanderBodin) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=AlexanderBodin)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AAlexanderBodin)\n* [Semir Patel (analogue)](https://github.com/analogue) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=analogue)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aanalogue)\n* [Andreas Hofmann (andreas-hofmann)](https://github.com/andreas-hofmann) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=andreas-hofmann)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aandreas-hofmann)\n* [Desmond Stonie (aneasystone)](https://github.com/aneasystone) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=aneasystone)/[8+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aaneasystone)\n* [anna-4](https://github.com/anna-4) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=anna-4)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aanna-4)\n* [Brad Beyenhof (augmentedfourth)](https://github.com/augmentedfourth) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=augmentedfourth)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aaugmentedfourth)\n* [b-jazz (b-jazz)](https://github.com/b-jazz) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=b-jazz)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ab-jazz)\n* [bafoed](https://github.com/bafoed) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=bafoed)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Abafoed)\n* [Colas BROUX (brouxco)](https://github.com/brouxco) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=brouxco)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Abrouxco)\n* [Alex Cabrera (cabreraalex)](https://github.com/cabreraalex) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=cabreraalex)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Acabreraalex)\n* [Chris Kuehl (chriskuehl)](https://github.com/chriskuehl) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=chriskuehl)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Achriskuehl)\n* [Christopher Biscardi (ChristopherBiscardi)](https://github.com/ChristopherBiscardi) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=ChristopherBiscardi)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AChristopherBiscardi)\n* [Sihan Li (ClumsyLee)](https://github.com/ClumsyLee) — [12+](https://github.com/jlevy/the-art-of-command-line/commits?author=ClumsyLee)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AClumsyLee)\n* [Corey Richardson (cmr)](https://github.com/cmr) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=cmr)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Acmr)\n* [CodinCat (CodinCat)](https://github.com/CodinCat) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=CodinCat)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ACodinCat)\n* [Colin Wang (colinwjd)](https://github.com/colinwjd) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=colinwjd)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Acolinwjd)\n* [Chris Rhodes (crr0004)](https://github.com/crr0004) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=crr0004)/[4+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Acrr0004)\n* [Daniel t. (danasmera)](https://github.com/danasmera) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=danasmera)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adanasmera)\n* [Dmytro Danylevskyi (danylevskyi)](https://github.com/danylevskyi) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=danylevskyi)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adanylevskyi)\n* [Dave Loyall (daveloyall)](https://github.com/daveloyall) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=daveloyall)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adaveloyall)\n* [Kirill (DDyst)](https://github.com/DDyst) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=DDyst)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ADDyst)\n* [Deborah Gertrude Digges (Deborah-Digges)](https://github.com/Deborah-Digges) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=Deborah-Digges)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ADeborah-Digges)\n* [Jamie Luck (delucks)](https://github.com/delucks) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=delucks)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adelucks)\n* [Dillon Flamand (dflamand)](https://github.com/dflamand) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=dflamand)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adflamand)\n* [Michael Diamond (dimo414)](https://github.com/dimo414) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=dimo414)/[4+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Adimo414)\n* [Vincent Wong (EaterOA)](https://github.com/EaterOA) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=EaterOA)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AEaterOA)\n* [Veck Hsiao (fbukevin)](https://github.com/fbukevin) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=fbukevin)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Afbukevin)\n* [Fernando Almeida (fernandoalmeida)](https://github.com/fernandoalmeida) — [8+](https://github.com/jlevy/the-art-of-command-line/commits?author=fernandoalmeida)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Afernandoalmeida)\n* [Sami (fnzv)](https://github.com/fnzv) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=fnzv)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Afnzv)\n* [Gaga Pan (gaga5lala)](https://github.com/gaga5lala) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=gaga5lala)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agaga5lala)\n* [Massimiliano Arione (garak)](https://github.com/garak) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=garak)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agarak)\n* [XinYu Zheng (gayu-mike)](https://github.com/gayu-mike) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=gayu-mike)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agayu-mike)\n* [Konstantin Gribov (grossws)](https://github.com/grossws) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=grossws)/[6+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Agrossws)\n* [Ashhar Hasan (hashhar)](https://github.com/hashhar) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=hashhar)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ahashhar)\n* [Beau Hastings (hastinbe)](https://github.com/hastinbe) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=hastinbe)/[4+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ahastinbe)\n* [Iliana Panagopoulou (hpanago)](https://github.com/hpanago) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=hpanago)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ahpanago)\n* [Space exploration enthusiast (Hunter-Github)](https://github.com/Hunter-Github) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=Hunter-Github)/[5+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AHunter-Github)\n* [Hyojin Kwak (hyojin)](https://github.com/hyojin) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=hyojin)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ahyojin)\n* [Ihor Dvoretskyi (idvoretskyi)](https://github.com/idvoretskyi) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=idvoretskyi)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aidvoretskyi)\n* [Kevin Morales (iKenshu)](https://github.com/iKenshu) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=iKenshu)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AiKenshu)\n* [Ilja Krauchanka (ikrauchanka)](https://github.com/ikrauchanka) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=ikrauchanka)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aikrauchanka)\n* [Sergey Isaev (isvforall)](https://github.com/isvforall) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=isvforall)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aisvforall)\n* [Igor Veksler (iveksl2)](https://github.com/iveksl2) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=iveksl2)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aiveksl2)\n* [J Alan Brogan (jalanb)](https://github.com/jalanb) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=jalanb)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajalanb)\n* [James Kolce (jameskolce)](https://github.com/jameskolce) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=jameskolce)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajameskolce)\n* [Dotan J. Nahum (jondot)](https://github.com/jondot) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=jondot)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajondot)\n* [Jesse Sightler (jsight)](https://github.com/jsight) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=jsight)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajsight)\n* [Konstantin Mikhailov (jtraub)](https://github.com/jtraub) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=jtraub)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajtraub)\n* [Jakub Wilk (jwilk)](https://github.com/jwilk) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=jwilk)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ajwilk)\n* [Wael Nasreddine (kalbasit)](https://github.com/kalbasit) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=kalbasit)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akalbasit)\n* [Colin Chan (kalgynirae)](https://github.com/kalgynirae) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=kalgynirae)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akalgynirae)\n* [Michalis Kargakis (kargakis)](https://github.com/kargakis) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=kargakis)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akargakis)\n* [Kesu J (kesu)](https://github.com/kesu) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=kesu)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akesu)\n* [Takuma Yamaguchi (kumon)](https://github.com/kumon) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=kumon)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Akumon)\n* [Dmytro Prokhorenkov (l13t)](https://github.com/l13t) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=l13t)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Al13t)\n* [Mikhail Letunovskiy (l3xx)](https://github.com/l3xx) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=l3xx)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Al3xx)\n* [Lakshmipathi (Lakshmipathi)](https://github.com/Lakshmipathi) — [10+](https://github.com/jlevy/the-art-of-command-line/commits?author=Lakshmipathi)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ALakshmipathi)\n* [Pavel Zhukov (landgraf)](https://github.com/landgraf) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=landgraf)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Alandgraf)\n* [lcmtwn](https://github.com/lcmtwn) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=lcmtwn)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Alcmtwn)\n* [Lampros Mountrakis (lmount)](https://github.com/lmount) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=lmount)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Almount)\n* [Luke Yeager (lukeyeager)](https://github.com/lukeyeager) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=lukeyeager)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Alukeyeager)\n* [TAKAGI Masahiro (m-takagi)](https://github.com/m-takagi) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=m-takagi)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Am-takagi)\n* [Who? Me?! (mark-i-m)](https://github.com/mark-i-m) — [5+](https://github.com/jlevy/the-art-of-command-line/commits?author=mark-i-m)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amark-i-m)\n* [marocchino](https://github.com/marocchino) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=marocchino)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amarocchino)\n* [Matjaž Lipuš (matjaz)](https://github.com/matjaz) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=matjaz)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amatjaz)\n* [Mayra Cabrera (mayra-cabrera)](https://github.com/mayra-cabrera) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=mayra-cabrera)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amayra-cabrera)\n* [Michael Barlow (michaelbarlow7)](https://github.com/michaelbarlow7) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=michaelbarlow7)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amichaelbarlow7)\n* [Jinhui-Lin (mintisan)](https://github.com/mintisan) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=mintisan)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amintisan)\n* [Crisoforo Gaspar Hernández (mitogh)](https://github.com/mitogh) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=mitogh)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amitogh)\n* [miuc (miuc)](https://github.com/miuc) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=miuc)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amiuc)\n* [Michael Kwardakov (mkwardakov)](https://github.com/mkwardakov) — [7+](https://github.com/jlevy/the-art-of-command-line/commits?author=mkwardakov)/[14+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amkwardakov)\n* [Harry Moreno (morenoh149)](https://github.com/morenoh149) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=morenoh149)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amorenoh149)\n* [Dongliang Mu (mudongliang)](https://github.com/mudongliang) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=mudongliang)/[10+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Amudongliang)\n* [Lilian Besson (Naereen)](https://github.com/Naereen) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=Naereen)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ANaereen)\n* [Namgoo Lee (nglee)](https://github.com/nglee) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=nglee)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Anglee)\n* [Serg Petrov (p12se)](https://github.com/p12se) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=p12se)/[0+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ap12se)\n* [王霄池(wangxiaochi) (picasso250)](https://github.com/picasso250) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=picasso250)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Apicasso250)\n* [pravdomil (pravdomil)](https://github.com/pravdomil) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=pravdomil)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Apravdomil)\n* [Rahul Kavale (rahulkavale)](https://github.com/rahulkavale) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=rahulkavale)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Arahulkavale)\n* [Rasmus Wriedt Larsen (RasmusWL)](https://github.com/RasmusWL) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=RasmusWL)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ARasmusWL)\n* [Riley Shaw (rileyjshaw)](https://github.com/rileyjshaw) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=rileyjshaw)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Arileyjshaw)\n* [Ryan Delaney (rpdelaney)](https://github.com/rpdelaney) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=rpdelaney)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Arpdelaney)\n* [Haoxuan Li (Sagir1)](https://github.com/Sagir1) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=Sagir1)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ASagir1)\n* [Saksham Sharma (sakshamsharma)](https://github.com/sakshamsharma) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=sakshamsharma)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Asakshamsharma)\n* [Semen Martynov (SemenMartynov)](https://github.com/SemenMartynov) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=SemenMartynov)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ASemenMartynov)\n* [Kit Chan (shukitchan)](https://github.com/shukitchan) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=shukitchan)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ashukitchan)\n* [Simarpreet Singh (simar7)](https://github.com/simar7) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=simar7)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Asimar7)\n* [snowme34 (snowme34)](https://github.com/snowme34) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=snowme34)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Asnowme34)\n* [Soham Chakraborty (SohamChakraborty)](https://github.com/SohamChakraborty) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=SohamChakraborty)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3ASohamChakraborty)\n* [Fabien Dubosson (StreakyCobra)](https://github.com/StreakyCobra) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=StreakyCobra)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3AStreakyCobra)\n* [Chengcheng Tang (tangchengcheng)](https://github.com/tangchengcheng) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=tangchengcheng)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Atangchengcheng)\n* [taxusyew](https://github.com/taxusyew) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=taxusyew)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ataxusyew)\n* [Timur (tim-teufel)](https://github.com/tim-teufel) — [4+](https://github.com/jlevy/the-art-of-command-line/commits?author=tim-teufel)/[3+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Atim-teufel)\n* [Timotei Dolean (timotei)](https://github.com/timotei) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=timotei)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Atimotei)\n* [Haoyu Qiu (timothyqiu)](https://github.com/timothyqiu) — [4+](https://github.com/jlevy/the-art-of-command-line/commits?author=timothyqiu)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Atimothyqiu)\n* [René Ribaud (uggla)](https://github.com/uggla) — [5+](https://github.com/jlevy/the-art-of-command-line/commits?author=uggla)/[10+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Auggla)\n* [Joe Block (unixorn)](https://github.com/unixorn) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=unixorn)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aunixorn)\n* [vitzli](https://github.com/vitzli) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=vitzli)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Avitzli)\n* [Eduardo Rolim (vndmtrx)](https://github.com/vndmtrx) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=vndmtrx)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Avndmtrx)\n* [senhtry (w169q169)](https://github.com/w169q169) — [3+](https://github.com/jlevy/the-art-of-command-line/commits?author=w169q169)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Aw169q169)\n* [Evan Wong (wyf88)](https://github.com/wyf88) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=wyf88)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Awyf88)\n* [Okunev Yu Dmitry (xaionaro)](https://github.com/xaionaro) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=xaionaro)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Axaionaro)\n* [yasuhiroki (yasuhiroki)](https://github.com/yasuhiroki) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=yasuhiroki)/[2+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ayasuhiroki)\n* [Alex F. (youmee)](https://github.com/youmee) — [1+](https://github.com/jlevy/the-art-of-command-line/commits?author=youmee)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ayoumee)\n* [Youngwoo Kim (youngwookim)](https://github.com/youngwookim) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=youngwookim)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ayoungwookim)\n* [yssmcl](https://github.com/yssmcl) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=yssmcl)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Ayssmcl)\n* [Zack Piper (zackp30)](https://github.com/zackp30) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=zackp30)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Azackp30)\n* [Aleksandr Zhuravlev (zelark)](https://github.com/zelark) — [2+](https://github.com/jlevy/the-art-of-command-line/commits?author=zelark)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Azelark)\n* [Xudong Zhang (zxdvd)](https://github.com/zxdvd) — [0+](https://github.com/jlevy/the-art-of-command-line/commits?author=zxdvd)/[1+](https://github.com/jlevy/the-art-of-command-line/issues?q=author%3Azxdvd)\n\nNumbers link to commits/issues.\nFor simplicity, this file is maintained only in English.\n\nIf your name does not appear as you would like it above, verify your name on your GitHub profile.\nAlso confirm that your commits are using the correct e-mail to it is linked to your profile.\n\nIf you see inaccuracies or omissions, please file an issue, or edit the authors-info.yml file, regenerate, and file a PR.\n\n\n\n(This file was auto-generated by [ghizmo assemble-authors](https://github.com/jlevy/ghizmo).)"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.65,
          "content": "## Contributing to The Art of Command Line\n\nThis guide is a [collaborative effort](AUTHORS.md), based on the generous work of many contributors.\n\n## Questions\n\n[![Ask a Question](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\nThe simplest thing you can do to help is [**submit any questions you might have**](https://airtable.com/shrzMhx00YiIVAWJg).\nThe more the better. Questions help identify where the guide needs to be improved.\n\n\n## Contributions\n\nContributions of all kinds, including corrections, additions, improvements, and translations, are welcome!\n\nWe hope you'll join and help, in small ways or large.\nHere are few notes before you jump in.\n\n### Style\n\n- Stay close to the existing style of the document when possible.\n- Remember to focus on **brevity**, **specificity**, and **utility**.\n- Avoid long explanations and instead prefer links to resources.\n\n### Using issues and PRs\n\n- Please **create and comment on issues freely** to discuss. A lot of the difficulty in accepting PRs is around style and format, and whether changes should be made at all, so rationale or explanations for the change are useful.\n- Please **review open issues and pull requests** before submitting a new one, to help reduce duplication.\n- To the extent possible, **break up changes into multiple PRs** so they can be approved separately. Large contributions are also welcome, but are harder and slower to approve, as they tend to require discussion or rewriting.\n\n\n## Translations\n\nThe guide is now available in many languages. Here is the process for maintaining translations:\n\n- This original version and content of the guide is maintained in English.\n- *Translations follow the content of the original.* Note this means contributors to a translation must be able to read some English, so that translations do not diverge (unless it is only fixing a typo).\n- Each translation has a maintainer to update the translation as the original evolves and to review others' changes. This doesn't require a lot of time, but review by the maintainer is important to maintain quality.\n- See the [AUTHORS.md](AUTHORS.md) file for current maintainers. (This file is generated from the [authors-info.yml](admin/authors-info.yml) file.)\n\n### Changes to translations\n\n- Changes to content should be made to the English version first, and then translated to each other language.\n- Changes that improve translations should be made directly on the file for that language. PRs should only modify one language at a time.\n- Submit a PR with changes to the file in that language. Each language has a maintainer, who reviews changes in that language. Then the primary maintainer @jlevy merges it in.\n- Prefix PRs and issues with language codes if they are for that translation only, e.g. \"es: Improve grammar\", so maintainers can find them easily.\n\n### Adding a translation to a new language\n\nTranslations to new languages are always welcome! Keep in mind a transation must be maintained, so it's needed to have one person maintain each translation.\n\n- Check existing issues to see if a translation is in progress or stalled. If so, offer to help.\n- Do you have time to be a maintainer for the new language? Please say so so we know we can count on you in the future.\n- If it is not in progress, file an issue for your language so people know you are working on it and we can arrange. Confirm you are native level in the language and are willing to maintain the translation, so it's not orphaned.\n- To get it started, fork the repo, then submit a PR with the single file README-xx.md added, where xx is the language code. Use standard [IETF language tags](https://www.w3.org/International/articles/language-tags/), i.e. the same as is used by Wikipedia, *not* the code for a single country. These are usually just the two-letter lowercase code, for example, `fr` for French and `uk` for Ukrainian (not `ua`, which is for the country). For languages that have variations, use the shortest tag, such as `zh-Hant`.\n- *Invite friends to review* if possible. Tranlsations are difficult and usually have erros others need to find. If desired, feel free to invite them to help your original translation by letting them fork your repo, then merging their PRs.\n- Add links to your translation at the top of every README*.md file. (For consistency, the link should be added in alphabetical order by ISO code, and the anchor text should be in the native language.)\n- When done, indicate on the PR that it's ready to be merged into the main repo.\n\n### Further questions\n\nUnsure of the process?\nOr do you have skills and inclination to help in a more substantial way?\nFile an issue or e-mail the original author [@jlevy](https://github.com/jlevy).\n"
        },
        {
          "name": "README-cs.md",
          "type": "blob",
          "size": 35.04,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# Umění příkazové řádky\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [Meta](#meta)\n- [Základy](#zaklady)\n- [Každodenní použití](#kazdodenni-pouziti)\n- [Zpracování souborů a dat](#zpracovani-souboru-a-dat)\n- [Ladění systému](#ladeni-systemu)\n- [Jednořádkové příkazy](#jednoradkove-prikazy)\n- [Neobvyklé ale užitečné](#neobvykle-ale-uzitecne)\n- [Pouze pro OS X](#pouze-pro-os-x)\n- [Další zdroje](#dalsi-zdroje)\n- [Zřeknutí se odpovědnosti](#zreknuti-se-odpovednosti)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nPlynulost práce na příkazové řádce je umění často opomíjené nebo považované za překonané, ale zlepšuje vaši flexibilitu a produktivitu jako inženýr jak očividně tak nenápadně. Toto je výběr poznámek a tipů pro použití příkazové řádky které shledáváme užitečnými při práci na Linuxu. Některé tipy jsou základní a některé jsou velmi specifické, komplikované či nejasné. Tato stránka není dlouhá, ale pokud dokážete použít a vybavit si všechny věci zde zmíněné, máte dostatečně rozsáhlé vědomosti.\n\nTato práce je výsledkem [mnoha autorů a překladatelů](AUTHORS.md).\nMnoho se\n[původně](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[objevilo](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nna webu [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nale s ohledem na zájem, který tam panoval, se zdálo vhodné použít GitHub, kde lidé více talentovaní než původní autor mohli okamžitě navrhovat zlepšení. Pokud najdete chybu či něco, co by mohlo být vylepšeno, prosím vytvořte issue nebo pull request! (Samozřejmě nejdříve zkontrolujte meta sekci a existující pull requesty a issues.)\n\n\n## Meta\n\nRozsah:\n\n- Tento průvodce je pro začátečníky i pro pokročilé. Cílem je *široký záběr* (vše důležité), *specifičnost* (poskytnout konkrétní příklady nejčastějšího použití) a *stručnost* (vyhnout se věcem, které nejsou nezbytné nebo podobným tématům, které lze vyhledat jinde). Každý tip je v některých případech nenahraditelný nebo značně šetří čas oproti alternativám.\n- Tento dokument je napsán pro Linux s vyjímkou sekcí označených jako \"[Pouze pro OS X](#os-x-only)\". Mnoho ostatních položek lze použít nebo je lze nainstalovat na jiných Unixových systémech nebo MacOS (dokonce i na Cygwin).\n- Zaměření dokumentu je na inteaktivní Bash ačkoli mnoho tipů lze aplikovat na jiné shelly a obecné bashové scriptování.\n. Jsou zahrnuty jak \"standardní\" Unixové příkazy tak příkazy vyžadující instalaci extra balíčků -- pokud jsou dost důležité aby zasloužily zmínku.\n\nPoznámky:\n\n- Pro udržení délky textu na jednu stranu, obsah je implicitně obsažen v odkazech. Jste dostatečně inteligentní aby jste si vyhledali více detailů z jiných zdrojů jakmile znáte příkaz či myšlenku na Googlu. Použijte `apt-get`, `yum`, `dnf`, `pacman`, `pip` nebo `brew` podle distribuce k instalaci nových progamů.\n- Použijte [Explainshell](http://explainshell.com/) pro užitečné vysvětlení co příkazy, možnosti, roury a jiné dělají.\n\n\n## Základy\n\n- Naučte se základy Bashe. Vlastně, napište `man bash` a alespoň si to proleťte; je to celkem jednoduché a ne tak dlouhé. Jiné shelly mohou být dobré, ale Bash je mocný a vždy dostupný (znalost *pouze* zsh, fish a jiných ačkoli lákavá na vlastním notebooku omezuje v mnoha situacích, jako například při použití existujících serverů).\n\n- Poznejte alespoň jeden textový editor dobře. Nejlépe Vim (`vi`) jelikož opravdu nemá pro občasné úpravy v terminálu nemá konkurenci (ani pokud většinu času používáte Emacs, velké IDE nebo moderní okenní editor).\n\n- Naučte se číst dokumentaci pomocí `man` (pro zvědavce, `man man` vypíše čísla sekcí, například 1 jsou \"obvyklé\" příkazy, 5 jsou soubory/konvence a 8 je administrace). Hledejte manuálové stránky pomocí `apropos`. Vězte, že některé příkazy nejsou spustitelné programy, ale funkce zabudované v Bashi a nápovědu k nim můžete zobrazit příkazem `help` a `help-d`.\n\n- Naučte se přesměrování výstupu a vstupu pomocí `>` a `<` a roury pomocí `|`. Pamatujte, že `>` přepíše obsah výstupního souboru a `>>` přidá na jeho konec. Nezapomeňte na stdout (stndardní výstup) a stderr (standardní chybový výstup).\n\n- Poznejte souborovou hromadnou expanzi za pomoci `*` (případně `?` a `[`...`]`) a úvozovkách a rozdílu mezi dvojitými uvozovkami `\"` a jednoduchými `'`. (Více na expanzi proměných níže.)\n\n- Seznamte se se správou činností v Bashi: `&`, **ctrl-z**, ctrl-c**, `jobs`, `fg`, `bg`, `kill`, atd.\n\n- Seznamte se s `ssh` a základy bezheslové autentizace pomocí `ssh-agent`, `ssh-add`, atd.\n\n- Základní správa souborů: `ls` a `ls -l` (zejména co který sloupec v `ls -l` znamená), `less`, `head`, `tail` a `tail -f` (nebo ještě lépe `less +F`), `ln` a `ln -s` (pochopte rozdíly a výhody pevného odkazu a symoblického odkazu), `chown`, `chmod`, `du` (pro krátký souhrn využití disku: `du -hs *`). Pro správu souborového systému, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Pochopte co je inode (`ls -i` nebo `df -i`).\n\n- základní správa síťí: `ip` nebo `ifconfig`, `dig`.\n\n- Dobře se naučte regulárních výrazů a rozličné příznaky pro `grep`/`egrep`. Přepínače `-i`, `-o`, `-v`, `-A`, `-B` a `-C` je také vhodné znát.\n\n- Naučte se používat `apt-get`, `yum`, `dnf` nebo `pacman` (podle vaší distribuce) k hledání a instalaci balíků. A ujistěte se, že máte `pip` k instalace Pythonových terminálových nástrojů (některé je nejjednodušší nainstalovat pomocí `pip`).\n\n\n## Každodenní použití\n\n- V Bashi používejte **Tab** k dokončení argumentů nebo vylistování všech dostupných příkazů a **ctrl-r** k vyhledávání v historii příkazů (po stisknutí pište pro hledání a poté mačkejte opakovaně **ctrl-r** k procházení více shod, **Enter** k provedení nalezeného příkazu nebo šipku vpravo pro vložení výsledku hledání do terminálu a následnou editaci).\n\n- V Bashi používejte **ctrl-w** pro smazní posledního slova a **ctrl-u** pro smazání všeho od současné pozice kurzoru až po začátek řádku. Používejte **alt-b** a **alt-f** k procházení řádku po slovech, **ctrl-a** pro skok na začátek řádku, **ctrl-e** pro skok kurzoru na konec řádku, **ctrl-k** pro smazání všeho od současné pozice až ke konci řádku, **ctrl-l** pro vyčištění obrazovky. Prohlédněte si `man readline` pro všechny defaultní klávesové zkratky v Bashi. Je jich hodně. Například **alt-.** projíždí předchozí argumenty a **alt-*** rozšíří řetězec.\n\n- Pokud milujete klávesové zkratky ve stylu *vi*, použijte `set -o vi` (a `set -o emacs` pro návrat ke standardnímu rozložení).\n\n- Pro úpravu dlouhých příkazů, po nastavení vašeho editoru (například `export EDITOR=vim`), **ctrl-x** **ctrl-e** v něm otevře stávající příkaz pro víceřádkovou úpravu. Nebo ve *vi* stylu, **escape-v**.\n\n- Zobrazení nedávných příkazů se provádí pomocí `history`. Existuje spousta zkratek jako `!$` (poslední argument) a `!!` (poslední příkaz), ale tyto jsou jednoduše nahraditelné pomocí **ctrl-r** a **alt-.**.\n\n- Pro přechod do předchozího pracovního adresáře: `cd -`.\n\n- Pokud máte zpola napsaný příkaz, ale rozmyslíte si to, stiskněte **alt-#** pro přidání `#` na začátek řádku a vložte ho jako komentář (nebo použijte **ctrl-a**, **#**, **enter**). Takto se k němu můžete později vrátit v historii příkazů.\n\n- Používejte  `xargs` (nebo `parallel`). Jde o mocný příkaz. Nezapomeňte, že můžete ovládat kolik položek se má vykonat na řádku (`-L`) stejně jako paralelismus (`-P`). Pokud si nejste jisti zda to udělá co má, zkuste nejdříve `xargs echo`. Hodí se také `-I{}`.\nPříklady:\n```bash\n      find . -name '*.py' | xargs grep nejaka_funkce\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` je užitečné zobrazení stromu procesů.\n\n- Používejte `pgrep` a `pkill` k hledání nebo posílání signálů procesům podle jména. (`-f` je také užitečné).\n\n- Pamatujte si rozličné signály, které lze posílat procesům. Například, k pozastavení procesu, použijte `kill -STOP [pid]`. Celý seznam signálů v `man 7 signal`.\n\n- Používejte `nohup` nebo `disown` pokud chcete, aby proces na pozadí běžel navždy.\n\n- Kontrolujte, které procesy naslouchají pomocí `netstat -lntp` nebo `ss -plat` (pro TCP; přidejte `-u` pro UDP).\n\n- Podívejte se také na `lsof` pro otevřené sockety a soubory.\n\n- Jak dlouho systém běží poznáte díky `uptime` nebo `w`.\n\n- Pomocí `alias` si nastavte zkratky pro často používané příkazy. Například `alias ll='ls -latr'` vytvoří novou zkratku `ll`.\n\n- V Bashových scriptech používejte `set -x` (nebo jeho variantu `set -v`, která zaznamenává nezpracovaný vstup včetně nečekaných proměnných a komentářů) pro ladící výstup. Používejte striktní módy pokud nemáte dobrý důvod proč to tak nedělat: Příkazem `set -e` nastavíte přerušení při chybě (nenulový návratový kód). Použijte `set -u` pro zjištění použití neinicializovaných proměnných. Zvažte také `set -o pipefail` pro chyby v rourách (přečtěte si na tohle téma více pokud tuto možnost využijete, jelikož jde o citlivé téma). Pro více zapojených scriptů použijte `trap` na EXIT nebo ERR. Dobrým zvykem bývá začínat scripty takto, což zachytí a ukončí běh na běžných chybách a vypíše zprávu:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script selhal: neuspesny prikaz vyse'\" ERR\n```\n\n- V Bash scriptech jsou subshelly (psané s kulatými závorkami) vhodným způsobem shlukování příkazů. Běžným příkladem budiž dočasný přesun do jiného pracovního adresáře, například:\n```bash\n      # udelej neco v soucasnem pracovnim adresari\n      (cd /nejaky/jiny/adresar && jiny-prikaz)\n      # pokracuj v puvodnim adresari\n```\n\n- Nezapomeňte, že v Bashi je mnoho druhů expanze proměnných. KOntrola, že proměnná existuje `${jmeno:?chybova hlaska}`. například, pokud script vyžaduje jediný argument, napište `vstupni_soubor=${1:?pouziti: $0 vstupni_soubor}`. Aritmetická expanze: `i=$(( (i + 1) % 5 ))`. Sekvence: `{1..10}`. Ořezání (trimming) řetězců: `${var%suffix}` a `${var#prefix}`. Pokud například `var=foo.pdf`, pak `echo ${var%.pdf}.txt` zobrazí `foo.txt`.\n\n- Expanze složených závorek použitím `{`...`}` může snížit potřebu přepisovat podobné texty a zautomatizovat kombinaci položek. Toto může být užitečné například v `mv foo.{txt,pdf} nejaky-adresar` (což přesune oba soubory), `cp nejakysoubor{,.bak}` (což se rozšíří do `cp nejakysoubor nejakysoubor.bak`) nebo `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (což se rozšíří do všech možných kombinací a vytvoří příslušný adresářový strom).\n\n- S výstupem některých příkazů lze zacházet jako se souborem pomocí `<(nejaky prikaz)`. Například porovnání lokálního `/etc/hosts` se vzdáleným:\n```sh\n      diff /etc/hosts <(ssh nejakyhost cat /etc/hosts)\n```\n\n- Poznejte \"zdejší dokumenty\" v Bashi, míněno `cat <<EOF ...`.\n\n- -Přesměrujte jak standardní výstup tak standardní chybový výstup v Bashi pomocí: `nejaky-prikaz > logsoubor 2>&1` nebo `nejaky-prikaz &>logsoubor`. Častokrát, k zajištění, že příkaz nezanechá otevřený souborový držák (handle), navázání ho na terminál ve kterém jste, je dobrá praktika také přidat `</dev/null`.\n\n- Používejte `man ascii` pro dobrou ASCII tabulku se šestnáctkovými i dekadickými hodnotami. Pro obecné kódovací informace jsou užitečné `man unicode`, `man utf-8` a `man latin1`.\n\n- Používejte `screen` nebo [`tmux`](https://tmux.github.io/) k rozšíření obrazovky, což je užitečné zejména na vzdálených ssh připojeních a k odpojení a znovu-připojení k sezení. `byobu` dokáže vylepšit obrazovku nebo tmux a poskytovat více informací a jednodušší správu. Více minimalistická varianta pouze pro přetrvání sezení je `dtach`.\n\n- v ssh je důležité vědět, jak tunelovat porty s pomocí `-L` nebo `-D` (a příležitostně `-R`) například k přístupu na webovou stránku ze vzdáleného serveru.\n\n- Může být užitečné udělat trochu optimalizačních úprav vašeho ssh připojení; například v `~/.ssh/config` je nastavení pro vyhýbání se odhozeným spojením v jistých sítích, používá kompresi (což je užitečné se scp přeš síť s malou šířkou pásma připojení) a multiplexové kanály ke stejnému serveru v lokálním souboru.\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Některé další možnosti vstahující se k ssh jsou bezpečnostně citlivé a měli by být povoleny s opatrností, například pro jednotlivé podsítě nebo hosty v důvěryhodných sítích: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Zvažte [`mosh`](https://mosh.org/) jako alternativu k ssh, která používá UDP, vyhýbá se padlým spojením a přidává pohodlí na cestách (vyžaduje nastavení na serveru).\n\n- K získání oprávnění k souboru v osmičkové formě, což je užitečné pro systémovou konfiguraci, ale nedostupné v `ls` a lehko zpackatelné, použijte něco jako\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Pro interaktivní výběr hodnot ze vstupu jiného příkazu použijte [`percol`](https://github.com/mooz/percol) nebo [`fzf`](https://github.com/junegunn/fzf).\n\n- Pro interakci se soubory v závislosti na vstupu jiného příkazu (třeba `git`), použijte `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Po zpřístupnění jednoduchého webového serveru pro všechny soubory v současném adresáři (a podadresářích), přístupného každému na vaší síti použijte:\n`python -m SimpleHTTPServer 7777` (pro port 7777 a Python 2) a `python -m http.server 7777` (pro port 7777 a Python 3).\n\n- Pro spuštění příkazu s právy použijte `sudo` (pro roota) nebo `sudo -u` (pro jiného uživatele). Používejte `su` nebo `sudo bash` pokud chcete aby shell běžel skutečně pod daným uživatelem. Použitím `su -` simulujte čerstvé přihlášení jako root nebo jiný uživatel.\n\n\n## Zpracovaní souboru a dat\n\n- K nalezení souboru podle jména v pracovním adresáři: `find . -iname '*something*'` (nebo podobně). K nalezení souboru podle jména kdekoliv na disku, použijte `locate jmeno` (pamatujte, že `updatedb` nemuselo nutně zaindexovat nedávno vytvořené soubory).\n\n- Pro obecné prohledávání zdrojů nebo datových souborů (více sofistikované než `grep -r`), použijte [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Převeďte HTML na text pomocí `lynx -dump -stdin`.\n\n- Vyzkoušejte [`pandoc`](http://pandoc.org/) pro Markdown, HTML a všechny druhy převodu dokumentů.\n\n- Pokud musíte pracovat s XML `xmlstarlet` je starý, ale dobrý.\n\n- Pro JSON použijte [`jq`](http://stedolan.github.io/jq/).\n\n- Pro YAML, použijte [`shyaml`](https://github.com/0k/shyaml).\n\n- Pro Excel nebo CSV suobory, [csvkit](https://github.com/onyxfish/csvkit) poskytuje `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, atd.\n\n- Pro Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) je pohodlnější a  [`s4cmd`](https://github.com/bloomreach/s4cmd) je rychlejší. [`aws`](https://github.com/aws/aws-cli) od Amazonu a vylepšený [`saws`](https://github.com/donnemartin/saws) jsou nezbytné pro ostatní AWS úkoly.\n\n- Mějte přehled o `sort` a `uniq`, včetně přepínače `-u` pro `uniq` a `-d` -- shlédněte jednořádkové příklady níže. A také `comm`.\n\n- Mějte přehled také o `cut`, `paste` a `join` pro manipulaci s textovými soubory. Mnoho lidí používá `cut`, ale zapomínají na `join`.\n\n- Udržujte přehled také o `wc` na počítání nových řádků (`-l`), znaků (`-m`), slov (`-w`) a bytů (`-c`).\n\n- A přehled je dobré mít také o `tee` pro kopírování ze stdin do souboru a na stdout, podobně jako za použití `ls -la | tee soubor.txt`.\n\n- Mějte na paměti, že nastavení lokalizace ovlivňuje mnoho příkazů v shellu mnoha způsoby včetně pořadí při třídění a výkonu. Většina Linuxových instalací nastaví `LANG` nebo jinou lokalizační proměnnou na lokální nastavení jako americká angličtina. Nezapomínejte však, že vaše třídění se změní změníte-li lokalizaci. A myslete na to, že i18n rutiny mohou způsobit, že třídění nebo jiné příkazy mohou běžet **mnohokrát** pomaleji. V některých situacích (při nastavování nebo testu unikátnost jako níže) lze bezpečně ignorovat pomalé i18n rutiny úplně a použít tradiční bytový pořádek pří třídění s `export LC_ALL=C`.\n\n- Měli byste znát základní `awk` a `sed` pro jednoduché operace s daty. Například sčítání všech čísel ve třetím sloupci textového souboru: `awk '{ x += $3 } END { print x }'`. Tento příkaz je pravděpodobně 3x rychlejší a obsahuje 3x méně kódu než jeho ekvivalent v Pythonu.\n\n- K nahrazení všech výskytů řetězce v jedno místě nebo ve více souborech:\n```sh\n      perl -pi.bak -e 's/stary-retezec/novy-retezec/g' moje-soubory-*.txt\n```\n\n- K přejmenování více souborů a/nebo vyhledávání a nahrazení uvnitř těchto souborů zkuste [`repren`](https://github.com/jlevy/repren). (V některých případech příkazech `rename` také dovoluje vícenásobné přejmenování, ale buďte opatrní neboť není stejný na všech Linuxových distribucích).\n```sh\n      # Plne jméno souboru, adresaru a obsahu foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Obnov zalozni soubory cokoliv.bak -> cokoli:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Stejne jako vyse za pouziti jmena pokud mozne:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Jak říká manuálová stránka, `rsync` je skutečně rychlý a neobyčejně univerzální nástroj na kopírování souborů. Je znám pro synchronizaci mezi stroji, ale je stejně užitečný lokálně. Jde také o jednu z [nejrychlejších cest](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) k odstranění velkého množství souborů:\n```sh\n      mkdir prazdny && rsync -r --delete prazdny/ nejaky-adr && rmdir nejaky-adr\n```\n\n- Použijte `shuf` k zamíchání nebo vybrání náhodných řádek ze souboru.\n\n- Mějte přehled v `sort` možnostech. Pro čísla, použijte `-n` nebo `-h` pro práci s lidsky čitelnými čísly (například z `du -h`). Pochopte jak fungují klíče (`-t` a `-k`). Zejména mějte na paměti, že musíte psát `-k,1` pro třídění za použití pouze prvního pole; `-k1` znamená třídění podle celého řádku. Stabilní třídění (`sort -s`) může být užitečné. Například k setřídění primárně podle druhého pole a sekundárně podle druhého pole můžete použít `sort -k1,1 | sort -s -k2,2`.\n\n- Pokud někdy potřebujete zapsat znak tabulátor do příkazové řádky v Bashi (například pro -t argument pro třídění), stiskněte press **ctrl-v** **[Tab]** nebo napište $'\\t'` (druhá možnost je lepší, protože výsledek můžete zkopírovat/vložit).\n\n- Standardní nástroje pro porovnávání zdrojového kódu jsou `diff` a `patch`. Za zmínku stojí také `diffstat` zobrazující statistiky z diffu a `sdiff` pro rozdíly bok po boku. Nezapomeňte, že `diff -r` funguje pro celé adresáře. Použijte `diff -r strom1 strom2 | diffstat` pro shrnutí změn. A `vimdiff` pro porovnání a úpravu souborů.\n\n- Pro binární soubory použijte `hd`, `hexdump` nebo `xxd` pro jednoduché hex dumpy a `bvi` nebo `biew` pro editaci binárek.\n\n- Pro binární soubory můžete také použít `strings` (například spolu s `grep`, atd), což je nástroj pro hledání částí textu.\n\n- Pro binární rozdíly (delta komprese) použijte `xdelta3`.\n\n- Pro konverzi testových kódování zkuste `iconv`. Nebo `uconv` pro pokročilejší použití; podporuje některé pokročilé Unicode věci. Například tento příkaz mění text na malé znaky a odstraňuje akcenty (jejich rozvinutím a zahozením):\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Na rozdělení souborů do částí zkuste `split` (na rozdělení podle velikosti) a `csplit` (na rozdělení podle řetězce).\n\n- K manipulaci s datem a časem použijte `dateadd`, `datediff`, `strptime` atd. z [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Použijte `zless`, `zmore`, `zcat`, a `zgrep` k operacím s komprimovanými soubory.\n\n\n## Ladění systému\n\n- Pro webové ladění jsou vhodné `curl` a `curl /I` nebo jejich `wget` ekvivalenty nebo více moderní [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Pro zjištění současného procesorového/diskového stavu, klasické nástroje jako `top` (nebo lépe `htop`). Použijte `iostat -mxz 15` pro základní CPU a detailní diskové stavy pro každý diskový oddíl a výkonostní statistiky.\n\n- Pro detaily ohledně síťové konektivity použijte `netstat` a `ss`.\n\n- Rychlý přehled co se děje v systému získáte pomocí užitečného `dstat`. Pro širší přehled s detaily použijte [`glances`](https://github.com/nicolargo/glances).\n\n- Na zjištění stavu paměti spusťte `free` a `vmstat` a pokuste se porozumět jejich výstupům. Zejména dbejte na \"cached\" hodnotu což je paměť držená Linuxovým kernelem jako souborová cache, tudíž se počítá do \"volné\" paměťi.\n\n- Ladění Javy je odlišný šálek čaje, ale jednoduchý trik na Javu od Oraclu a některé jiné JVM je, že stále můžete použít `kill -3 <pid>` a výpis zásobníku a haldy (včetně obecnějších detailů z **garbage collectoru**, které mohou být nesmírně informativní) bude zapsán do stderr/logs. Nástroje JDK jako `jps`, `jstat`, `jstack` a `jmap` jsou také užitečné, avšak [SJK tools](https://github.com/aragozin/jvm-tools)  jsou více pokročilé.\n\n- Použijte [`mtr`](http://www.bitwizard.nl/mtr/) jako lepší `traceroute` pro identifikování potíží se sítí.\n\n- Při zjištování proč je disk plný, [`ncdu`](https://dev.yorhel.nl/ncdu) šetří čas oproti obvyklým příkazům jako `du /sh *`.\n\n- Ke zjištění, který socket nebo proces zahlcuje pásmo, zkuste [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) nebo [`nethogs`](https://github.com/raboof/nethogs).\n\n- Nástroj `ab` (přibalený k Apachi) je užitečný pro rychlé a hrubé zkontrolování výkonosti webového serveru. Komplexnější měření umožňuje `siege`.\n\n- Pro důslednější síťové ladění, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) nebo [`ngrep`](http://ngrep.sourceforge.net/) jsou to pravé.\n\n- Nezapomínejte na `strace` a `ltrace`. Mohou být nápomocné zejména pokud některý program selhává, zasekává se nebo padá a nevíte proč nebo pokud chcete mít obecnou představu o výkonu. Myslete na přepínač profilingu (`-c`) a schopnost připnout se k běžícímu procesu (`-p`).\n\n- Dynamické knihovny vám umožní zkontrolovat `ldd`.\n\n- Je důležité umět se připojit k běžícímu procesu za pomoci `gdb` a získat výpis jeho chodu.\n\n- Používejte `/proc`. Je úžasně nápomocný v okamžicích, kdy ladíte živé problémy. Příklady: /proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (kde `xxx` je id nebo pid procesu.).\n\n- Když zjišťujete proč se něco v minulosti pokazilo, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) může být nedocenitelný. Ukazuje historické statistiky CPU, paměti, sítě, atd.\n\n- Pro hlubší systémovou a výkonostní analýzu se podívejte na `stap`([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux)), a [`sysdig`](https://github.com/draios/sysdig).\n\n- Zkontrolujte na jakém jste OS za pomoci `uname` nebo `uname -a` (obecné Unix/kernel informace) nebo `lsb_release -a` (v Linuxových distribucích).\n\n- Použijte `dmesg` kdykoli se něco chová neočekávaně (může jít o hardwarový nebo driverový problém).\n\n\n## Jednořádkové příkazy\n\nPár příkladů na spojování příkazů:\n\n- Někdy je pozoruhodně užitečné dělat průnik, sjednocení a rozdíl textových souborů pomocí `sort`/`uniq`. Předpokládejte, že `a` a `b` jsou unikátní textové soubory. Toto je rychlé a funguje na souborech libovolné velikosti až do mnoha gigabytů. (Třídění pomocí `sort` není omezené pamětí, ale je možné, že budete muset použít `-T` přepínač, pokud se `/tmp` nachází na malém diskovém oddílu). Podívejte se také na poznámku o LC_ALL výše a přepínač `sortu` `-u` (vynechaný pro přehlednost).\n```sh\n      cat a b | sort | uniq > c   # c je sjednocení b\n      cat a b | sort | uniq -d > c   # c je průnik b\n      cat a b b | sort | uniq -u > c   # c je rozdíl a - b\n```\n\n- Použijte `grep .*` pro rychlé prošetření obsahu všech souborů v adresáři (každý soubor je spojen s názvem souboru) nebo `head -100 *` (aby každý soubor měl záhlaví). Může být užitečné pro adresáře s konfiguračními soubory jako jsou například `/sys`, `/proc` a `/etc`.\n\n- Součet všech čísel ve třetím sloupci textového souboru (pravděpodobně 3x rychlejší a 3x méně kódu než ekvivalentní funkce v Pythonu):\n```sh\n      awk '{ x += $3 } END { print x }' mujsoubor\n```\n\n- Pokud chcete zobrazit velikosti/datumy na souborovém stromu, následující příkaz je jako rekurzivní `ls -l`, ale jedodušší na čtení než `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Řekněme, že máte textový soubor, jako log webového serveru, a jisté hodnoty, které se objevují na některých řádcích, jako například `acct_id` parametr, který se vyskytuje v URL. Pokud chcete záznam kolik požadavků pro každý `acct_id`:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- K průběžnému monitorování změn použijte `watch`, například změn souborů v adresáři pomocí `watch -d -n 2 'ls -rth | tail'` nebo síťových nastavení při řešení potíží nastavení wifi: `watch -d -n 2 ifconfig`.\n\n- Spusťte tuto funkci k získání náhodného tipu z tohoto dokumentu (parsuje Markdown a vyextrahuje jednu položku):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## Neobvyklé ale užitečné\n\n- `expr`: provede aritmetické nebo logické operace nebo vyhodnotí regulární výrazy\n\n- `m4`: jednoduchý procesor maker\n\n- `yes`: tiskne řetězec vícekrát\n\n- `cal`: hezký kalendář\n\n- `env`: provede příkaz (užitečné ve scriptech)\n\n- `printenv`: vypíše proměnné prostředí (užitečné při ladění a ve scriptech)\n\n- `look`: najde anglická slova (nebo řádky v souboru) začínající řetězcem\n\n- `cut`, `paste` a `join`: manipulace s daty\n\n- `fmt`: formátuje text do odstavců\n\n- `pr`: formátuje text do stránek/sloupců\n\n- `fold`: zalamuje řádky textu\n\n- `column`: formátuje textová pole do zarovnaných sloupců nebo tabulek s danou šířkou\n\n- `expand` a `unexpand`: převádí tabulátory a mezery\n\n- `nl`: přidá čísla řádků\n\n- `seq`: tiskne čísla\n\n- `bc`: kalkulačka\n\n- `factor`: provádí faktorizaci celých čísel (15 = 5 a 3)\n\n- [`gpg`](https://gnupg.org/): šifruje a podepisuje soubory\n\n- `toe`: tabulka informací o dostupných terminálech\n\n- `nc`: síťové ladění a přenos dat\n\n- `socat`: socketové relé a tcp port přesměrování (podobné `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): visualizace síťového provozu\n\n- `dd`: přesun dat mezi soubory nebo zařízeními\n\n- `file`: identifikuje typ souboru\n\n- `tree`: zobrazí adresáře a podadresáře jako vnořený strom; podobně jako `ls` ale rekurzivně\n\n- `stat`: informace o souboru\n\n- `time`: provede a načasuje příkaz\n\n- `timeout`: provádí příkaz po specifikovanou dobu a zastaví proces když daná doba uplyne\n\n- `lockfile`: vytvoří semaforový soubor, který lze odstranit pouze pomocí `rm -f`\n\n- `logrotate`: rotuje, komprimuje a posílá logy emailem\n\n- `watch`: spouští opakovaně příkaz a zobrazuje výsledky a/nebo zvýrazňuje změny\n\n- `tac`: tiskne soubory pozpátku (po řádcích)\n\n- `shuf`: náhodně vybere řádky ze souboru\n\n- `comm`: porovná seřazení soubory řádek po řádku\n\n- `pv`: monitoruje postup dat skrz rouru\n\n- `hd`, `hexdump`, `xxd`, `biew` a `bvi`: vypíše nebo edituje binární soubory\n\n- `strings`: vypreparuje textové řetězce z binárních souborů\n\n- `tr`: překládá znaky nebo s nimi manipuluje\n\n- `iconv` nebo `uconv`: převod pro kódování textu\n\n- `split` a `csplit`: dělí soubory\n\n- `sponge`: čte všechen vstup před tím než ho zapíše, užitečné pro čtení a následný zápis do téhož souboru, např. `grep -v neco nejaky-soubor | sponge nejaky-soubor`\n\n- `units`: převody jednotek a výpočty; převádí jednotky mezi sebou, (viz. `/usr/share/units/definitions.units`)\n\n- `apg`: generuje náhodná hesla\n\n- `7z`: vysoko-poměrová datová komprese\n\n- `ldd`: informace o dynamických knihovnách\n\n- `nm`: vypíše symboly z objektových souborů\n\n- `ab`: zátěžové testy webserverů\n\n- `strace`: ladění systému\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): vylepšení traceroute pro síťové ladění\n\n- `cssh`: vizuální souběžný shell\n\n- `rsync`: synchronizuje soubory a adresáře přes SSH nebo v lokálním systému souborů\n\n- [`wireshark`](https://wireshark.org/) a [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): zachytávání packetů a síťové ladění\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep pro síťovou vrstvu\n\n- `host` a `dig`: DNS vyhledávání\n\n- `lsof`: zpracovává souborové popisovače (descriptory) a informace o socketech\n\n- `dstat`: užitečné systémové informace\n\n- [`glances`](https://github.com/nicolargo/glances): vysoko úrovňový, multi-systémový přehled\n\n- `iostat`: statistiky využití disku\n\n- `mpstat`: statistiky využití CPU\n\n- `vmstat`: statistiky využití paměti\n\n- `htop`: vylepšená verze top (správa procesů)\n\n- `last`: historie přihlášení\n\n- `w`: kdo je přihlášen\n\n- `id`: informace o identitě uživatele/skupiny\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): historické systémové statistiky\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) nebo [`nethogs`](https://github.com/raboof/nethogs): využití sítě pro proces nebo socket\n\n- `ss`: statistika socketů\n\n- `dmesg`: bootovací a systémové chybové zprávy\n\n- `sysctl`: zobrazení a konfigurace parametrů Linuxového kernelu za běhu\n\n- `hdparm`: SATA/ATA disková manipulace/výkon\n\n- `lsblk`: seznam blokových zařízení: stromové zobrazení disků a diskových oddílů\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informace o hardwaru zahrnující CPU, BIOS, RAID, grafiku, zařízení, atd.\n\n- `lsmod` a `modinfo`: seznam a detaily kernelových modulů\n\n- `fortune`, `ddate`, a `sl`: hm, no, záleží jestli považujete parní lokomotivy a Zippyho citáty za \"užitečné\"\n\n\n## Pouze pro OS X\n\nTyto věci jsou relevantní pouze pro macOS.\n\n- Balíčky spravované pomocí `brew` (Homebrew) a/nebo `port` (MacPorts). Mohou být použity k instalaci mnoha předešlých příkazů na macOS.\n\n- Kopírujte výstup jakéhokoli příkazu do desktopové aplikace pomocí `pbcopy` a vložte vstup z nějaké pomocí `pbpaste`.\n\n- K povolení klávesy Option v Terminálu Mac OS jako klávesu Alt (pro použití v příkazech jako **alt-b**, **alt-f**, atd.), otevřete Předvolby -> Profily -> Klávesnice a zvolte \"Použít Option jako Meta klávesu\".\n\n- K otevření souboru za pomoci desktopové aplikace použijte `open` nebo `open -a /Aplikace/Cokoli.app`.\n\n- Spotlight: Prohledávejte soubory s `mdfind` a vypište metadata (například EXIF informace fotografie) pomocí `mdls`.\n\n- Nezapomínejte, že macOS je založen na BSD Unixu a mnoho příkazů (například `ps`, `ls`, `tail`, `awk`, `sed`) mají spoustu jemných odlišností od Linuxu, což je z velké části ovlivněno System V (System Five) stylem Unixu a GNU nástroji. Mnohokrát mmůžete rozdíl poznat podle manuálové stránky mající v nadpise \"BSD General Commands Manual\". V některých případech mohou být GNU verze instalovány také (třeba `gawk` a `gsed` pro GNU awk a sed). Pokud píšete multi-platformní Bashové scripty, vyhýbejte se takovým příkazům (například, zvažte Python či `perl`) nebo pečlivě testujte.\n\n- K získání informací o verzi vydání macOS použijte `sw_vers`.\n\n\n## Další zdroje\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Organizovaný seznam shellových nástrojů a zdrojů.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Průvodce Mac OS příkazovou řádkou více do hloubky.\n- [Striktní mód](http://redsymbol.net/articles/unofficial-bash-strict-mode/) pro psaní lepších shellových scriptů.\n- [shellcheck](https://github.com/koalaman/shellcheck): Nástroj pro statickou analýzu shellových scriptů. V podstatě lint pro bash/sh/zsh.\n- [Souborové názvy a cesty v shellu](http://www.dwheeler.com/essays/filenames-in-shell.html): Bohužel velmi komplexní drobnosti o korektní práci se souborovými jmény v shellových scriptech.\n\n\n## Zřeknutí se odpovědnosti\n\nS vyjímkou velmi malých úkolů je kód psán tak, aby ho ostatní mohli přečíst. S mocí přichází zodpovědnost. Skutečnost, že něco *můžete* v Bashi udělat nemusí nutně znamenat, že byste měli! ;)\n\n\n## License\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nTato práce je licencována pod [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-de.md",
          "type": "blob",
          "size": 43.24,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# The Art of Command Line\n\n[![Ask a Question](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Kurzbeschreibung](#kurzbeschreibung)\n- [Grundlagen](#grundlagen)\n- [Täglicher Gebrauch](#täglicher-gebrauch)\n- [Umgang mit Dateien und Daten](#umgang-mit-dateien-und-daten)\n- [Fehlerbehebung auf Systemebene](#fehlerbehebung-auf-systemebene)\n- [Einzeiler](#einzeiler)\n- [Eigenartig aber hilfreich](#eigenartig-aber-hilfreich)\n- [Nur MacOS X](#nur-macos-x)\n- [Nur Windows](#nur-windows)\n- [Weitere Quellen](#weitere-quellen)\n- [Haftungsausschluss](#haftungsausschluss)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nDer flüssige Umgang mit der Befehlszeile (auch Kommandozeile, engl. \"command line\") ist eine oft vernachlässigte oder als undurchsichtig empfundene Fähigkeit, steigert jedoch Flexibilität und Produktivität eines Informatikers auf offensichtliche als auch subtile Weise. Was folgt, ist eine Auswahl an Notizen und Tipps im Umgang mit der Befehlszeile, welche ich beim Arbeiten mit Linux zu schätzen gelernt habe. Manche dieser Hinweise beinhalten Grundwissen, andere sind sehr spezifisch, fortgeschritten oder auch eigenartig. Die Seite ist nicht lang, aber wenn du alle Punkte verstanden hast und anwenden kannst, weißt du eine ganze Menge.\n\nVieles davon\n[erschien](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n[ursprünglich](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\nauf [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\naber angesichts des Interesses scheint es vielversprechend, Github zu nutzen, wo talentiertere Menschen als ich es bin kontinuierlich Verbesserungen vorschlagen können. Wenn du einen Fehler entdeckst oder etwas, das man besser machen könnte, erstelle ein Issue oder einen PR! (Lies aber bitte zuerst die Kurzbeschreibung und überprüfe bereits vorhandene Issues/PRs.)\n\n\n## Kurzbeschreibung\n\nUmfang:\n\n- Diese Anleitung richtet sich an Anfänger und Fortgeschrittene. Die Ziele sind *Breite* (alles ist wichtig), *Genauigkeit* (konkrete Beispiele für die gebräuchlichsten Anwendungsfälle) und *Knappheit* (Dinge, die nicht wesentlich sind oder leicht anderswo nachgeschlagen werden können, sollen vermieden werden). Jeder Tipp ist in einer bestimmten Situation wesentlich oder deutlich zeitsparend gegenüber bestehenden Alternativen.\n- Sie ist für Linux geschrieben, mit der Ausnahme der Abschnitte \"[Nur MacOS X](#nur-macos-x)\" und \"[Nur Windows](#nur-windows)\". Viele der anderen Punkte lassen sich nutzen oder sind installierbar auf anderen Unices oder MacOS (oder sogar Cygwin).\n- Der Fokus liegt auf interaktiver Bash, allerdings gelten viele Tipps auch auf anderen Shells sowie für allgemeines Bash-Skripting.\n- Sie beinhaltet sowohl \"normale\" Unix-Befehle als auch solche, die bestimmte installierte Pakete voaussetzen -- sofern sie wichtig genug sind, dass sie die Aufnahme in diese Anleitung verdienen.\n\nHinweise:\n\n- Um eine Seite nicht zu sprengen, ist ihr Inhalt durchgängig anhand von Verweisen aufgelistet. du bist schlau genug, anderswo zusätzliche Informationen nachzuschlagen, sobald du die Idee bzw. den Befehl dahinter kennst. Verwende `apt-get`, `yum`, `dnf`, `pacman`, `pip` oder `brew`, um ggf. neue Programme zu installieren.\n- Verwende [Explainshell](http://explainshell.com/), um einen hilfreichen Einblick zu erhalten, was es mit Befehlen, Optionen, Pipes etc. auf sich hat.\n\n\n## Grundlagen\n\n- Lerne Bash-Grundlagen. Tatsächlich, gib `man bash` ein und überfliege das Ganze zumindest; es ist leicht zu verstehen und nicht allzu lang. Alternative Shells sind nett, aber Bash ist mächtig und immer verfügbar (*nur* zsh, fish, etc. zu lernen ist auf dem eigenen Laptop vielleicht reizvoll, beschränkt jedoch deine Möglichkeiten in vielerlei Hinsicht, etwa beim Arbeiten mit bestehenden Servern).\n\n- Lerne mindestens einen Text-basierten Editor zu benutzen. Idealerweise Vim (`vi`), da es letztlich keinen vergleichbaren Mitbewerber für gelegentliche Einsätze in einem Terminal gibt (selbst dann, wenn man eine große Entwicklungsumgebung wie Emacs oder die meiste Zeit einen modernen Hipster-Editor benutzt).\n\n- Wisse, wie man Dokumentationen mit `man` liest (für Neugierige, `man man` listet Abschnittsnummern, bspw. stehen unter 1 \"reguläre\" Befehle, 5 beinhaltet Dateien/Konventionen und unter 8 solche zur Rechnerverwaltung). Finde `man`-Seiten (\"man pages\") mit `apropos`. Wisse, dass manche Befehle keine ausführbaren Dateien, sondern Bash-Builtins sind, und dass du Hilfe zu diesen mit `help` und `help -d` erhälst.\n\n- Lerne etwas über die Umleitung von Ein- und Ausgaben per `>` und `<` sowie `|` für Pipes. Wisse, dass `>` die Ausgabedatei überschreibt und `>>` etwas anhängt. Lerne etwas über stdout und stderr.\n\n- Lerne etwas über die Dateinamenerweiterung mittels `*` (und eventuell `?` und `[`...`]`) sowie Anführungszeichen, etwa den Unterschied zwischen doppelten `\"` und einfachen `'`. (Mehr zur Variablenerweiterung findest du unten.)\n\n- Mach dich vertraut mit Bash-Jobmanagement: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Kenne `ssh` und die Grundlagen passwortloser Authentifizierung mittels `ssh-agent`, `ssh-add`, etc.\n\n- Grundlegende Dateiverwaltung: `ls` and `ls -l` (und spezieller, lerne die Funktion jeder einzelnen Spalte von `ls -l` kennen), `less`, `head`, `tail` und `tail -f` (oder noch besser, `less +F`), `ln` und `ln -s` (lerne die Unterschiede und Vorteile von Hard- und Softlinks), `chown`, `chmod`, `du` (für eine Kurzzusammenfassung der Festplattenbelegung: `du -hs *`). Für Dateisystemmanagement `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Lerne, was ein Inode (engl. index node) ist (`ls -i` oder `df -i`).\n\n- Grundlagen der Netzwerkverwaltung: `ip` oder `ifconfig`, `dig`.\n\n- Lerne etwas über Versionskontrolle und benutze ein entsprechendes System, wie etwa `git`.\n\n- Kenne reguläre Ausdrücke gut, und die verschiedenen Statusindikatoren zu `grep`/`egrep`. Die Optionen `-i`, `-o`, `-v`, `-A`, `-B`, und `-C` sind gut zu wissen.\n\n- Lerne den Umgang mit `apt-get`, `yum`, `dnf` oder `pacman` (je nach Linux-Distribution), um Pakete zu finden bzw. zu installieren. Und stell sicher, dass du `pip` hast, um Python-basierte Befehlszeilen-Werkzeuge nutzen zu können (einige der untenstehenden werden am einfachsten über `pip` installiert).\n\n\n## Täglicher Gebrauch\n\n- In Bash kannst du mit **Tab** Parameter vervollständigen sowie alle verfügbaren Befehle anzeigen lassen und mit **ctrl-r** bereits benutzte Befehle durchsuchen (drück die Kombination, gib dann deinen Suchtext ein und springe anschließend durch wiederholtes Drücken von **ctrl-r** durch die Suchergebnisse, mit **Enter** kannst du den gefundenen Befehl ausführen sowie mit der rechten Pfeiltaste in die aktuelle Zeile einfügen, um ihn zu bearbeiten).\n\n- In Bash kannst du mit **ctrl-w** das letzte Wort löschen und mit **ctrl-u** alles bis zum Anfang einer Zeile. Verwende **alt-b** und **alt-f**, um dich Wort für Wort fortzubewegen, springe mit **ctrl-a** zum Beginn einer Zeile,  mit **ctrl-e** zum Ende einer Zeile, lösche mit **ctrl-k** alles bis zum Ende einer Zeile und bereinige mit **ctrl-l** den Bildschirm. Siehe `man readline` für alle voreingestellten Tastenbelegungen in Bash. Davon gibt's viele. Zum Beispiel **alt-.** wechselt durch vorherige Parameter und **alt-*** erweitert ein Suchmuster.\n\n- Alternativ, falls du vi-artige Tastenbelegungen magst, verwende `set -o vi` (und `set -o emacs`, um es wiederzuholen).\n\n- Um kürzlich genutzte Befehle zu sehen, `history`. Es gibt außerdem viele Abkürzungen wie etwa `!$` (letzter Parameter) und `!!` (letzter Befehl), wenngleich diese oft einfach ersetzt werden durch **ctrl-r** und **alt-.**.\n\n- Um lange Befehle zu bearbeiten, kannst du sie (nachdem du deinen Editor angegeben hast, etwa mit `export EDITOR=vim`) mit **ctrl-x** **ctrl-e** im Editor öffnen, um mehrere Zeilen bearbeiten zu können. Oder vi-Style, **escape-v**.\n\n- Um kürzlich verwendete Befehle anzuzeigen, benutze `history`. Anschließend `!n` (wobei `n` die Nummer des Befehls ist), um es erneut auszuführen. Es gibt zudem zahlreiche Abkürzungen, die man verwenden kann, die nützlichste ist wahrscheinlich `!$` für den letzten Parameter und `!!` für den letzten Befehl (siehe \"HISTORY EXPANSION\" in der `man`-Seite). Diese werden allerdings oft einfach ersetzt durch **ctrl-r** und **alt-.**.\n\n- In dein Benutzerverzeichnis gelangst du mit `cd`. Auf Dateien relativ zu diesem kannst du mit dem Präfix `~` zugreifen (etwa so `~/.bashrc`). In `sh`-Skripts heißt das Benutzerverzeichnis `$HOME`.\n\n- Um ins vorangegangene Arbeitsverzeichnis zu gelangen: `cd -`\n\n- Wenn du einen Befehl eingibst und es dir auf halbem Wege anders überlegst, drücke **alt-#**, um am Zeilenanfang ein `#` einzufügen und ihn damit als Kommentar auszuweisen (oder benutze **ctrl-a**, **#**, **enter**). du kannst später über die Befehlsgeschichte zurückgelangen.\n\n- Verwende `xargs` (oder `parallel`). Es ist sehr mächtig. Beachte, wie du viele Dinge pro Zeile (`-L`) als auch parallel (`-P`) ausführen kannst. Wenn du dir nicht sicher bist, ob das Richtige dabei herauskommt, verwende zunächst `xargs echo`. Außerdem ist`-I{}` nützlich. Beispiele:\n```bash\n    find . -name '*.py' | xargs grep irgendeine_funktion\n    cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` liefert eine hilfreiche Anzeige des Prozessbaums.\n\n- Verwende `pgrep` und `pkill`, um Prozesse anhand eines Namens zu finden oder festzustellen (`-f` ist hilfreich).\n\n- Kenne die verschiedenen Signale, welche du Prozessen senden kannst. Um einen Prozess etwa zu unterbrechen, verwende `kill -STOP [pid]`. Für die vollständige Liste, siehe `man 7 signal`\n\n- Verwende `nohup` oder `disown`, wenn du einen Hintergrundprozess für immer laufen lassen willst.\n\n- Überprüfe mithörende Prozesse mit `netstat -lntp` oder `ss -plat` (für TCP; füge `-u` für UDP hinzu).\n\n- Siehe zudem `lsof` für offene Sockets und Dateien.\n\n- Siehe `uptime` oder `w`, um die laufende Betriebszeit des Systems zu erfahren,\n\n- Verwende `alias`, um Verknüpfungen für gebräuchliche Befehle zu erstellen. So erstellt etwa `alias ll='ls -latr'` den neuen Alias `ll`.\n\n- Speichere diese Alternativnamen (\"aliases\"), Shell-Einstellungen und häufig benutzte Funktionen in `~/.bashrc` und [stelle sie anderen Login-Shells zur Verfügung](http://superuser.com/a/183980/7106). So hast du auf dein Setup auch in allen anderen Shell-Sessions Zugriff.\n\n- Platziere Einstellungen von Umgebungsvariablen sowie Befehle, welche nach einer Anmeldung ausgeführt werden sollen, in `~/.bash_profile`. Eine separate Konfiguration ist notwendig für Shells, welche du von einer grafischen Benutzeroberfläche startest sowie für `cron`-Jobs.\n\n- Synchronisiere deine Konfigurationsdateien (etwa `.bashrc` und `.bash_profile`) zwischen mehreren Computern mit Git.\n\n- Verstehe, dass Vorsicht geboten ist, wenn Variablen und Dateinamen Leerzeichen enthalten. Setze deine Bashvariablen daher mit Anführungszeichen: `\"$FOO\"`. Bevorzuge die Optionen `-0` oder `-print0`, um ungültige Schriftzeichen zu aktivieren und so Dateinamen zu begrenzen, bspw. `locate -0 pattern | xargs -0 ls -al` oder `find / -print0 -type d | xargs -0 ls -al`. Um in einem \"for loop\" Dateinamen durchzugehen, die Leerzeichen enthalten, sorge mit `IFS=$'\\n'` dafür, dass dein IFS immer auf einer neuen Zeile steht.\n\n- Benutze in Bash-Skripts `set -x` (oder die Abwandlung `set -v`, welche unverarbeiteten Input akzeptiert, einschließlich Kommentare und unexpandierte Variablen) zum Output der Fehlerbehebung. Benutze \"strict modes\", es sei denn, gute Gründe sprechen dagegen: Benutze `set -e`, um bei Fehlern abzubrechen (\"nonzero exit code\"). Benutze `set -u`, um die Verwendung nicht gesetzer Variablen aufzuspüren. Erwäge auch `set -o pipefail` für Fehler in Pipes (lies jedoch mehr zu diesem Thema, wenn du es vorhast, denn es ist ein wenig heikel). Benutze bei komplizierteren Skripts auch `trap` bei EXIT oder ERR. Es ist eine nützliche Angewohnheit, ein Skript folgendermaßen zu beginnen, um Fehler zu erkennen und sie ggf. mit einer entsprechenden Fehlermeldung abzubrechen:\n```bash\n    set -euo pipefail\n    trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- In Bash-Skripts stellen Subshells (geschrieben in runden Klammern) einen praktischen Weg dar, Befehle zusammenzufassen. Ein gebräuchliches Beispiel ist die vorübergehende Arbeit in einem anderen Arbeitsverzeichnis:\n```bash\n    # erledige etwas im aktuellen Verzeichnis\n    (cd /irgendein/anderes/verzeichnis && anderer-befehl)\n    # fahre fort im aktuellen Verzeichnis\n```\n\n- Beachte, dass es in Bash viele Möglichkeiten gibt, Variablen zu erweitern. Überprüfen, ob eine Variable existiert: `${name:?error message}`.Wenn bspw. ein Bash-Skript nur einen einzelnen Parameter benötigt, schreibe einfach `input_file=${1:?usage: $0 input_file}`. Arithmetische Erweiterung: `i=$(( (i + 1) % 5 ))`. Sequenzen: `{1..10}`. Zeichenkette kürzen: `${var%suffix}` und `${var#prefix}`. Wenn bspw. `var=foo.pdf`, dann gibt `echo ${var%.pdf}.txt` die Ausgabe `foo.txt` aus.\n\n- Klammererweiterung mittels `{`...`}` kann dafür sorgen, ähnlichen Text seltener wiederholen zu müssen und ermöglicht die Kombination von Objekten. Das ist etwa in Fällen nützlich wie `mv foo.{txt,pdf} zielverzeichnis` (verschiebt beide Dateien), `cp datei{,.bak}` (erweitert den Ausdruck um `cp datei datei.bak`) oder `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (erweitert alle denkbaren Kombinationen und erstellt einen Verzeichnisbaum).\n\n- Die Ausgabe eines Befehls kann wie eine Datei behandelt werden mit `<(befehl)`. Das Vergleichen der lokalen `/etc/hosts` mit einer entfernten:\n```sh\n    diff /etc/hosts <(ssh andererhost cat /etc/hosts)\n```\n\n- Beim Schreiben von Skripts wirst du deinen Code womöglich in geschweifte Klammern setzen wollen. Falls die schließende Klammer fehlt, wird dein Skript aufgrund eines Syntaxfehlers nicht ausgeführt. Das ist etwa dann sinnvoll, wenn es im Internet verfügbar ist, da ein unvollständig heruntergeladenes Skript so an der Ausführung gehindert wird:\n```bash\n{\n    # Hier koennte dein Code stehen!\n}\n```\n\n- Kenne \"here documents\" in Bash, wie etwa in `cat <<EOF ...`.\n\n- In Bash, leite sowohl den standard output als auch den standard error um mit: `irgendein-befehl >logfile 2>&1`. Oftmals ist es gute Praxis, einen Befehl an das verwendete Terminal zu binden, um keinen offenen Dateizugriff im standard input zu erzeugen, also `</dev/null` hinzuzufügen.\n\n- Verwende `man ascii` für eine gute ASCII-Tabelle, Mit Dezimal- und Hexadezimalwerten. Für allgemeine Informationen zu Kodierung sind `man unicode`, `man utf-8` und `man latin1` hilfreich.\n\n- Verwende `screen` oder [`tmux`](https://tmux.github.io/), um einen Bildschirm zu multiplexen, besonders hilfreich ist dies für Fernzugriffe per `ssh` und zur Trennung und Neuverbindung mit einer Session. Eine minimalistische Alternative allein zur Aufrechterhaltung einer Session ist `dtach`.\n\n- Bei SSH ist es hilfreich zu wissen, wie man einen Porttunnel mit `-L` oder `-D` (gelegentlich auch `-R`) einrichtet, etwa beim Zugriff auf Webseiten von einem Remote-Server.\n\n- Es kann nützlich sein, ein paar Verbesserungen an den SSH-Einstellungen vorzunehmen; so enthält bspw. diese `~/.ssh/config` Einstellungen, um das Abreißen der Verbindung in bestimmten Netzwerkumgebungen zu vermeiden, verwendet Kompression (was hilfreich ist bei SCP über Verbindungen mit niedriger Bandbreite) und Multiplex-Kanäle zu demselben Server mithilfe einer lokalen Kontrolldatei:\n```\n    TCPKeepAlive=yes\n    ServerAliveInterval=15\n    ServerAliveCountMax=6\n    Compression=yes\n    ControlMaster auto\n    ControlPath /tmp/%r@%h:%p\n    ControlPersist yes\n```\n\n- Einige andere Optionen im Zusammenhang mit SSH sind sicherheitsrelevant und sollten nur mit Bedacht aktiviert werden, etwa Zugriff per Subnet oder Host sowie in vertrauenswürdigen Netzwerken: `StrictHostKeyChecking=no`, `ForwardAgent=yes`.\n\n- Erwäge [`mosh`](https://mosh.org/) als Alternative zu `ssh`, die UDP benutzt, um so abgebrochene Verbindungen zu vermeiden, was ja in gewisser Hinsicht auch komfortabel ist (benötigt Server-seitiges Setup).\n\n- Um Zugriff auf eine Datei in Oktalform zu erhalten, was zur Systemkonfiguration zwar nützlich, jedoch über `ls` nicht verfügbar und leicht zu vermasseln ist, verwende etwas wie\n```sh\n    stat -c '%A %a %n' /etc/timezone\n```\n\n- Verwende zur interaktiven Auswahl von Werten aus dem Output eines anderen Befehls [`percol`](https://github.com/mooz/percol) oder [`fzf`](https://github.com/junegunn/fzf).\n\n- Verwende `fpp` ([PathPicker](https://github.com/facebook/PathPicker)) zur Interaktion mit Dateien als Output eines anderen Befehls (wie etwa `git`).\n\n- Verwende für einen einfachen Webserver für alle Dateien im aktuellen Verzeichnis (sowie Unterverzeichnisse), der für alle in deinem Netzwerk abrufbar ist: `python -m SimpleHTTPServer 7777` (für Port 7777 und Python 2) sowie `python -m http.server 7777` (für Port 7777 und Python 3).\n\n- Benutze `sudo`, um einen Befehl als ein anderer Benutzer auszuführen. Standardmäßig ist dies die Ausführung als root; benutze `-u` zur Angabe eines anderen benutzers sowie `-i`, um dich als dieser anzumelden (du wirst nach _deinem_ Passwort gefragt).\n\n- Benutze `su benutzername` oder `su - benutzername`, um mit der Shell zu einem anderen Benutzer zu wechseln. Füge `-` hinzu, um eine Umgebung zu erhalten, als hättest du dich gerade mit diesem Benutzer angemeldet. Das Weglassen des Benutzernamens führt zur Anmeldung als root. du wirst gefragt nach dem Passwort _des Benutzers, als der du dich anmelden willst_.\n\n- Kenne das [128K-Limit](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) der Befehlszeile. Der \"Argument list too long\"-Fehler erscheint häufig, wenn auf sehr viele Dateien über [Wildcards](https://de.wikipedia.org/wiki/Wildcard_(Informatik)) zugegriffen wird (wenn das passiert, können Alternativen wie `find` und `xargs` helfen).\n\n- Benutze den `python`-Interpreter als einfachen Taschenrechner (und natürlich für den Zugriff auf Python im Allgemeinen). Beispiel:\n```\n    >>> 2+3\n    5\n```\n\n\n## Umgang mit Dateien und Daten\n\n- Um eine Datei im aktuellen Verzeichnis anhand des Namens zu finden, `find . -iname '*irgendwas*'`. Um eine Datei unabhängig vom Verzeichnis anhand des Namens zu finden, verwende `locate irgendwas` (bedenke jedoch, dass `updatedb` kürzlich erstellte Datein möglicherweise noch nicht indexiert hat).\n\n- Für das allgemeine durchsuchen von (Quell-)Dateien (fortgeschrttener als `grep -r`), verwende [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Um HTML in Text zu konvertieren: `lynx -dump -stdin`\n\n- Für Markdown, HTML und alle möglichen Arten von Dokumentkonvertierung, versuch's mit [`pandoc`](http://pandoc.org/).\n\n- Wenn du mit XML arbeiten musst, `xmlstarlet` ist alt, aber gut.\n\n- Für JSON, verwende [`jq`](http://stedolan.github.io/jq/).\n\n- Für YAML gibt's [`shyaml`](https://github.com/0k/shyaml).\n\n- Für Excel- bzw. CSV-Dateien hält [csvkit](https://github.com/onyxfish/csvkit) `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc bereit.\n\n- Für Amazon S3 ist [`s3cmd`](https://github.com/s3tools/s3cmd) praktisch und [`s4cmd`](https://github.com/bloomreach/s4cmd) schneller. Amazons [`aws`](https://github.com/aws/aws-cli) sowie das verbesserte [`saws`](https://github.com/donnemartin/saws) sind essentiell für andere AWS-bezogene Aufgaben.\n\n- Kenne `sort` und `uniq`, letzteres einschließlich der Optionen `-u` und `-d` -- siehe die Einzeiler unten. Siehe auch `comm`.\n\n- Kenne `cut`, `paste` und `join` zur Arbeit mit Textdateien. Viele Leute nutzen `cut`, vergessen aber `join`.\n\n- Kenne `wc`, um neue Zeilen (`-l`), Zeichen (`-m`), Wörter (`-w`) und Bytes (`-c`) zu zählen.\n\n- Kenne `tee`, um von stdin in eine Datei und sogar nach stdout zu kopieren, wie etwa mit `ls -al | tee datei.txt`.\n\n- Bei komplexeren Berechnungen, einschließlich Gruppieren, Tauschen von Feldern und statistische Berechnungen, könnte [`datamash`](https://www.gnu.org/software/datamash/) passend sein.\n\n- Sei dir bewusst, dass die regionale Spracheinstellung (\"locale\") viele Befehlszeilen-Werkzeuge auf subtile Art und Weise beeinflusst, inklusive der Sortierreihenfolge und ihrer Performance. Die meisten Linux Installation setzen `LANG` oder andere lokale Variablen auf eine lokale Einstellung wie z.B. \"US English\". Aber sei dir bewusst, dass sich das Sortierverhalten ändern wird, falls du die \"locale\" änderst. Und wisse, dass \"i18n\"-Routinen `sort` und andere Befehle *stark* verlangsamen können. In manchen Situationen (wie den Mengen oder Identitätsfunktionen unterhalb) kann man ruhigen Gewissens langsame \"i18n\"-Routinen ignorieren und traditionelle byte-basierte Sortierreihenfolge nutzen, indem man `export LC_ALL=C` setzt.\n\n- Du kannst einem bestimmten Befehl eine Umgebung zuteilen, indem seinem Aufruf die Einstellung der Umgebungsvariable vorangestellt wird, wie hier: `TZ=Pacific/Fiji date`.\n\n- Kenne Grundlagen von`awk` und `sed` für einfache Datenverarbeitung. Um z.B. alle Zahlen in der dritten Spalte einer Textdatei aufzusummieren: `awk '{ x += $3 } END { print x }'`. Das ist wahrscheinlich 3X schneller und 3X kürzer als das Python Äquivalent.\n\n- Um mehrere Dateien umzubenennen sowie innerhalb von Dateien zu suchen/ersetzen, probier [`repren`](https://github.com/jlevy/repren) aus (gelegentlich kann man auch mit `rename` mehrere Dateien umbenennen, aber sei vorsichtig, da dessen Funktionsweise je nach Linux-Distribution abweicht).\n```sh\n    # Vollständige Umbenennung von Dateinamen, Ordnern und Inhalten - foo -> bar:\n    repren --full --preserve-case --from foo --to bar .\n    # Backupdateien wiederherstellen - whatever.bak -> whatever:\n    repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n    # Wie oben, aber mit rename, sofern verfügbar:\n    rename 's/\\.bak$//' *.bak\n```\n\n- Wie die `man`-Seite richtig sagt, ist `rsync` ein schnelles und vielseitiges Werkzeug zum Kopieren von Dateien. Es ist bekannt für das Synchronisieren zwischen Rechnern, ist lokal aber ebenso nützlich. Wenn es die Sicherheitsbestimmungen zulassen, erlaubt `rsync` im Gegensatz zu `scp` die Wiederaufnahme einer Übertragung, ohne nochmal von vorn beginnen zu müssen. Es ist zudem einer der [schnellsten Wege](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html), um große Mengen an Dateien zu löschen:\n```sh\nmkdir leeres-verzeichnis && rsync -r --delete leeres-verzeichnis/ verzeichnis && rmdir verzeichnis\n```\n\n- Benutze `shuf` zum Mischen oder um zufällige Zeilen aus einer Datei auszuwählen.\n\n- Kenne die Optionen von `sort`. Benutze `-n` für Zahlen, oder `-h` um mit menschenlesbaren Zahlen umzugehen (wie z.B. von `du -h`). Sei dir bewusst, wie Schlüssel funktionieren (`-t` und `-k`). Sei dir insbesondere bewusst, dass du `-k1,1` verwenden musst, um bezüglich des ersten Felds zu sortieren;`-k1` bedeutet, sortiere anhand der ganzen Zeile. Stabiles Suchen (`sort -s`) kann ebenfalls nützlich sein. Um bspw. primär nach Feld 2 und sekundär nach Feld 1 zu sortieren, kannst du `sort -k1,1 | sort -s -k2,2` benutzen.\n\n- Falls du jemals ein Tabulator Literal in eine Befehlszeile in Bash schreiben musst (etwa den Parameter `-t` für `sort`), drücke **ctrl-v** **[Tab]** oder schreibe `$'\\t'` (letzteres ist besser, da man es Kopieren/Einfügen kann).\n\n- Die Standardwerkzeuge für das Patchen von Quellcode sind `diff` und `patch`. Siehe auch `diffstat`, um zusammenfassende Statistiken eines diffs zu erhalten. Beachte, dass `diff -r` für komplette Verzeichnisse funktioniert. Nutze `diff -r tree1 tree2 | diffstat`, um eine Übersicht aller Änderungen zu bekommen. Benutze `vimdiff`, um Dateien zu vergleichen und zu bearbeiten.\n\n- Benutze für Binärdateien `hd`, `hexdump` or `xxd` zur Erstellung einfacher [Hexdumps](https://de.wikipedia.org/wiki/Dump#Hexdump) und `bvi` oder `biew` zur binären Bearbeitung.\n\n- Ebenfalls für Binärdateien kann `strings` (und `grep`, etc.) benutzt werden, um Textpassagen zu finden.\n\n- Um Diffs für Binärdateien zu erstellen (Delta Kompression), nutze `xdelta3`.\n\n- Um zwischen Textkodierungen zu konvertieren, solltest du `iconv` probieren, oder aber `uconv` für fortgeschrittene Anwendungsfälle; es unterstüzt einige fortgeschrittene Unicode-Dinge. Dieser Befehl bspw. wandelt alle Buchstaben in Kleinbuchstaben um und entfernt alle Akzente (indem sie erweitert und verworfen werden):\n```sh\n    uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Um Dateien aufzuteilen, siehe `split` (Teilung anhand einer bestimmten Größe) und `csplit` (Teilung anhand eines bestimmten Musters).\n\n- Benutze  `zless`, `zmore`, `zcat`, und `zgrep` um mit komprimierten Dateien zu arbeiten.\n\n- Dateieigenschaften können mit `chattr` gesetzt werden und stellen eine niederschwelligere Alternative zu Dateiberechtungen dar. So kann man etwa, um das versehentliche Löschen einer Datei zu verhindern, eine entsprechende Flag (\"immutable flag\") setzen: `sudo chattr +i /wichtiges/verzeichnis/oder/datei`\n\n- Benutze `getfacl` und `setfacl`, um Dateiberechtigungen zu speichern und wiederherzustellen. Beispiel:\n```sh\n   getfacl -R /irgendein/pfad > berechtigungen.txt\n   setfacl --restore=berechtigungen.txt\n```\n\n\n## Fehlerbehebung auf Systemebene\n\n- Zur Fehlersuche bei Webanwendungen sind `curl` und `curl -I` hilfreich, ebenso wie ihre `wget` Äquivalente oder das modernere [`httpie`](https://github.com/jakubroztocil/httpie).\n\n- Um den aktuellen CPU-/Festplattenstatus zu erfahren, sind die Klassiker `top` (oder das bessere `htop`), `iostat` und `iotop`. Benutze `iostat -mxz 15` for basic CPU and detailed per-partition disk stats and performance insight.\n\n- Benutze für Informationen zu Netzwerkverbindungen `netstat` und `ss`.\n\n- Für eine schnelle Übersicht, was sich auf einem System abspielt, ist `dstat` sehr nützlich. Für einen guten Gesamtüberblick bietet sich zudem [`glances`](https://github.com/nicolargo/glances) an.\n\n- Um den Zustand des Speichers zu erfahren, führst du am besten `free` und `vmstat` aus und verstehst deren Ausgabe. Sei dir insbesondere bewusst, dass der \"cached\"-Wert jener Wert ist, der vom Linux-Kernel als Dateicache genutzt wird, da dieser effektiv als zum \"free\"-Wert addiert werden kann.\n\n- Fehlerbehebung (\"debugging\") auf Java-Systemen ist ein anderes Paar Schuhe, aber ein simpler Trick für die Oracle JVM (der teilweise auch für andere JVMs funktioniert) ist `kill -3 <pid>`, sodass ein vollständiger Strack trace und Heap Informationen (inklusive Garbage Collection Details, die sehr informativ sein können) nach stderr/logs ausgegeben werden. Die JDK-Befehle `jps`, `jstat`, `jstack`, `jmap` sind ebenfalls nützlich. [SJK-Werkzeuge](https://github.com/aragozin/jvm-tools) sind noch weiter fortgeschritten.\n\n- Benutze [`mtr`](http://www.bitwizard.nl/mtr/) als ein besseres traceroute, um Netzwerkprobleme zu identifizieren.\n\n- Willst du wissen, warum eine Festplatte voll ist, dann spart [`ncdu`](https://dev.yorhel.nl/ncdu) Zeit gegenüber den üblichen Befehlen wie `du -sh *`.\n\n- Um herauszufunden, welcher Socket oder Prozess Bandbreite verbraucht, kannst du [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) oder [`nethogs`](https://github.com/raboof/nethogs) verwenden.\n\n- Das `ab`-Werkzeug (ein Teil vom Apache) ist hilfreich, um schnell und pragmatisch die Performance eines Webservers zu messen. Für komplexere Messungen kannst du `siege` ausprobieren.\n\n- Für eine tiefergehende Netzwerk Problemsuche, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), oder [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Kenne `strace` und `ltrace`. Diese können hilfreich sein, falls ein Programm fehlschlägt, hängt oder abstürzt und du weißt nicht warum, oder um einen generellen Eindruck von der Performance zu bekommen. Beachte die Profiling-Option (`-c`) und die Fähigkeit, sich mit laufenden Prozessen zu verbinden (`-p`).\n\n- Kenne `ldd`, um \"shared libraries\" zu überprüfen.\n\n- Sei in der Lage, dich mittels `gdb` mit einem laufenden Prozess zu verbinden und dessen \"stack traces\" zu holen.\n\n- Benutze `/proc`. Es ist manchmal unglaublich hilfreich, um Probleme in Echtzeit zu debuggen. Beispiele: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (wobei `xxx` die Prozess-ID / pid ist).\n\n- Bei der Frage, warum in der Vergangenheit etwas schief gelaufen ist, kann [`sar`](http://sebastien.godard.pagesperso-orange.fr/) sehr hilfreich sein. Es zeigt historische Statistiken über CPU, Speicher, Netzwerk, etc.\n\n- Für eine genauere System und Performanceanalyse, solltest du dir `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](http://en.wikipedia.org/wiki/Perf_(Linux)), und [`sysdig`](https://github.com/draios/sysdig) ansehen.\n\n- Finde heraus, welches Betriebssystem du nutzt mittels `uname` oder `uname -a` (allgemeine Unix-/Kernelinformationen) oder `lsb_release -a` (Informationen zur verwendeten Linux-Distribution)\n\n- Benutze `dmesg` wenn sich etwas merkdwürdig verhält (es könnte ein Hardware oder Treiber Problem sein)\n\n- Wenn du eine Datei löschst, jedoch laut `du` nicht der erwartete Festplattenspeicher frei wird, dann überprüfe, ob die Datei von einem Prozess verwendet wird: `lsof | grep deleted | grep \"dateiname\"`\n\n\n## Einzeiler\n\nEin paar Beispiele, wie man Befehle zusammen benutzen kann:\n\n- Manchmal ist es unglaublich hilfreich, dass man die Schnittmenge, Vereinigung und den Unterschied zwischen Textdateien via `sort`/`uniq` bilden kann. Angenommen, a und b sind Textdateien, die bereits \"unique\" sind. Diese Herangehensweise ist schnell und funktioniert mit Dateien beliebiger Größe, bis zu mehreren Gigabytes (`sort` ist nicht durch Speicher beschränkt, obwohl man eventuell die `-T`-Option nutzen muss, falls `/tmp` auf einer kleinen Root-Partition liegt). Siehe auch die Bemerkung über `LC_ALL` weiter oben und die `-u`-Option von `sort` (wurde oben aus Gründen der Übersichtlichkeit ausgelassen).\n```sh\n    cat a b | sort | uniq > c   # c ist a vereint mit b\n    cat a b | sort | uniq -d > c   # c ist a geschnitten b\n    cat a b b | sort | uniq -u > c   # c ist die Menge mit unterschiedlichen Elementen  a - b\n```\n\n- Eine schnelle Überprüfung der Inhalte aller Dateien in einem Verzeichnis erreichst du mit `grep . *` (damit enthält jede Zeile den Dateinamen) oder `head -100 *` (damit erhält jede Datei eine Überschrift). Dies kann nützlich sein für Verzeichnisse, die Konfigurationsdateien enthalten wie jene in `/sys`, `/proc` und `/etc`.\n\n- Alle Zahlen in der dritten Spalte einer Textdatei aufsummieren (dieser Ansatz ist wahrscheinlich dreimal schneller und enthält dreimal weniger Code als dessen Entsprechung in Python):\n```sh\n    awk '{ x += $3 } END { print x }' meinedatei\n```\n\n- Falls man die Größen/Datumsangaben von einem Dateibaum wissen möchte, funktioniert das Folgende wie ein rekursives `ls -l`, aber ist leichter zu lesen als `ls -lR`:\n```sh\n    find . -type f -ls\n```\n\n- Um Größen/Datumsangaben in einem Verzeichnisbaum zu sehen, wirkt dies wie ein umgedrehtes `ls -l`, ist aber einfacher zu lesen als `ls -lR`:\n```sh\n    find . -type f -ls\n```\n\n- Angenommen innerhalb einer Textdatei, so wie ein server web log, tauch ein gewisser Wert in manchen Zeilen auf, wie z.B. ein `acct_id` Parameter in der URL. Falls eine Aufzählung gewünscht ist, wie viele Anfragen es jeweils für eine `acct_id` gibt:\n```sh\n    cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Um durchgehend Änderungen zu überwachen, solltest du \"watch\" benutzen; z.B. Dateiänderungen in einem Verzeichnis können mittels `watch -d -n 2 'ls -rtlh | tail'` überwacht werden, während du Deine Wifi Einstellungen mittels `watch -d -n 2 ifconfig` auf Fehler überprüfen kannst.\n\n- Führe diese Funktion aus, um einen zufälligen Tip aus diesem Dokument zu erhalten(parst das Markdown Dokument und extrahiert ein Element)\n```sh\n    function taocl() {\n      curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-de.md |\n        pandoc -f markdown -t html |\n        xmlstarlet fo --html --dropdtd |\n        xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n        xmlstarlet unesc | fmt -80\n    }\n```\n\n\n## Eigenartig aber hilfreich\n\n- `expr`: Führe arithmetische oder bool'sche Operationen aus oder werte reguläre Ausdrücke aus\n\n- `m4`: Simpler Macro-Auswerter\n\n- `yes`: Gib eine Zeichenkette sehr oft aus\n\n- `cal`: Netter Kalender\n\n- `env`: Führe einen Befehl aus (nützlich für Skripte)\n\n- `printenv`: Gebe Umgebungsvariablen aus (nützlich zum Debuggen und für Skripte)\n\n- `look`: Finde englische Worte (oder Zeilen in einer Datei), die mit einer bestimmten Zeichenkette anfangen\n\n- `cut`, `paste` und `join`: Datenmanipulation\n\n- `fmt`: Formatiere Textabsätze\n\n- `pr`: Formatiere Text als Seiten/Spalten\n\n- `fold`: Breche Textzeilen um\n\n- `column`: Formatiere Textfelder als bündige Spalten oder Tabellen mit fester Größe\n\n- `expand` und `unexpand`: Konvertiere zwischen Tabs und Spaces\n\n- `nl`: Füge Zeilennummern hinzu\n\n- `seq`: Gib Zahlen aus\n\n- `bc`: Taschenrechner\n\n- `factor`: Faktorisiere Ganzzahlen\n\n- [`gpg`](https://gnupg.org/): Verschlüsseln und Signieren von Dateien\n\n- `toe`: Tabelle von `terminfo`-Einträgen\n\n- `nc`: Netzwerk-Debugging und Datentransfer\n\n- `socat`: Socket- und TCP-Port-Weiterleitung (ähnlich wie `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): Visulaisierung des Netzwerkverkehrs (\"traffic\")\n\n- `dd`: Daten zwischen Dateien und Geräten bewegen\n\n- `file`: Identifiziere den Typ einer Datei\n\n- `tree`: Zeige Verzeichnisse und Unterverzeichnisse als verschachtelten Baum; wie `ls` aber rekursiv\n\n- `stat`: Datei Infomationen\n\n- `time`: Führe einen Befehl aus und messe die Zeit\n\n- `timeout`: Führe einen Befehl für eine bestimmte Zeit aus und beende ihn anschließend wieder\n\n- `lockfile`: Erstelle eine Semaphordatei, die nur gelöscht werden kann mit `rm -f`\n\n- `logrotate`: Rotiert, komprimiert und mailt System-Log-Dateien\n\n- `watch`: Führe einen Befehl wiederholt aus, wobei die Ergebnisse angezeigt und/oder Änderungen hervorgehoben werden\n\n- `tac`: Gebe Dateien in umgekehrter Reihenfolge aus\n\n- `shuf`: Zufällige Auswahl von Zeilen von einer Datei\n\n- `comm`: Vergleiche sortierte Dateien Zeile für Zeile\n\n- `pv`: Überwache den Fortschritt von Daten durch eine Pipe\n\n- `hd`, `hexdump`, `xxd`, `biew` und `bvi`: Ausgabe und Editieren von Binärdateien\n\n- `strings`: Text aus Binärdateien extrahieren\n\n- `tr`: Buchstabenübersetzung und -manipulation\n\n- `iconv` oder `uconv`: Konvertierung von Zeichensätzen\n\n- `split` und `csplit`: Dateien aufteilen\n\n- `sponge`: Liest die gesamte Eingabe, bevor sie wieder ausgegeben wird. Nützlich, um aus derselben Datei zu lesen und in diese zu schreiben, bspw. `grep -v irgendwas irgendeine-datei | sponge irgendeine-datei`\n\n- `units`: Einheiten Konvertierungen und Berechnungen; konvertiert Furlong(Achtelmeile)/Fortnights(2 Wochen) zu twips/blink (siehe `/usr/share/units/definitions.units`)\n\n- `apg`: Generiert zufällige Passwörter\n\n- `xz`: Hochgradige Dateikompression\n\n- `ldd`: Informationen zu dynamisch gelinkten Bibliotheken\n\n- `nm`: Symbole aus Objektdateien anzeigen\n\n- `ab`: Webserver benchmarken\n\n- `strace`: Debugging von Syscalls\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): Ein besseres \"traceroute\" zum Netzwerk-Debugging\n\n- `cssh`: Visuelle, nebenläufige Shell\n\n- `rsync`: Synchronisiere Dateien und Ordner über SSH oder im lokalen Dateisystem\n\n- [`wireshark`](https://wireshark.org/) and [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): Pakete aufzeichnen und Netzwerk-Debugging\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep für die Netzwerkschicht\n\n- `host` und `dig`: DNS-Auflösung\n\n- `lsof`: Prozess Datei Deskriptor und Socket Informationen\n\n- `dstat`: Nützliche Systemstatistiken\n\n- [`glances`](https://github.com/nicolargo/glances): Grobe Übersicht über zahlreiche Subsysteme\n\n- `iostat`: Fesplatten-Nutzungsstatistiken\n\n- `mpstat`: CPU-Nutzungstatistiken\n\n- `vmstat`: Speicher-Nutzungsstatistiken\n\n- `htop`: Verbesserte Version von `top`\n\n- `last`: Loginverlauf\n\n- `who`: Wer gerade angemeldet ist\n\n- `id`: Identitätsinformationen zu Benutzern/Gruppen\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): Historische Systemstatistiken\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) or [`nethogs`](https://github.com/raboof/nethogs): Netzwerknutzung durch Sockets oder Prozesse\n\n- `ss`: Socket-Statistiken\n\n- `dmesg`: Bootvorgang und System-Fehlermeldungen\n\n- `sysctl`: Anzeige und Konfiguration von Linux Kernel Parametern zur Laufzeit\n\n- `hdparm`: SATA/ATA-Festplattenmanipulation/-performanceinformationen\n\n- `lsblk`: Auflisten von block devices: eine Baumansicht deiner Festplatten und Partitionen\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: Hardware-Informationen, inklusive CPU, BIOS, RAID, Grafikkarten, Geräte, etc.\n\n- `lsmod` und `modinfo`: Auflisten und Details anzeigen von Kernelmodulen\n\n- `fortune`, `ddate`, und `sl`: Ähm ja, kommt darauf an, ob man Dampflokomotiven und flotte Zitate \"nützlich\" findet\n\n\n## Nur MacOS X\n\nDiese Hinweise sind *nur* für MacOS relevant.\n\n- Paketverwaltung mit `brew` (Homebrew) und/oder `port` (MacPorts). Mit diesen Werkzeugen kann man viele der obrigen Programme für MacOs installieren.\n\n- Kopiere die Ausgabe eines beliebigen Befehls an eine Desktop App mit `pbcopy` und füge die Eingabe von einer solchen ein mit `pbpaste`.\n\n- Um die Option Taste als alt-Taste in einer Mac OS Konsole zu nutzen (so wie in den obrigen Befehle wie **alt-b**, **alt-f**, etc.), öffne Einstellungen -> Profile -> Tastatur und aktiviere \"Benutze Option Taste als Meta Taste\"\n\n- Um eine Datei mit einer Desktopanwendung zu öffnen, kann man `open` oder `open -a /Applications/Whatever.app` benutzen.\n\n- Spotlight: Dateisuche mit `mdfind` und Ausgabe von Metadaten (wie z.B. photo EXIF info) mit `mdls`.\n\n- Man sollte sich bewusst sein, dass MacOS auf BSD Unix basiert und sich viele Befehle (wie z.B. `ps`, `ls`, `tail`, `awk`, `sed`) bezüglich subtiler Kleinigkeiten von Linux, das stark von System V-style Unix und GNU tools beeinflusst ist, unterscheiden. Oft kann man den Unterschied daran erkennen, dass eine `man`-Seite die Überschrift  \"BSD General Commands Manual\" trägt. In manchen Fällen kann auch die GNU-Version installiert werden (wie z.B. bei `gawk` und `gsed` für GNU awk und sed). Falls manplattformübergreifende Bash-Skripte schreiben möchte, sollte man solche Befehle vermeiden (und z.B. Python oder `perl` in Betracht ziehen) oder sorgfätig testen.\n\n- Benutze `sw_vers` für OS X Systeminformationen.\n\n\n## Nur Windows\n\nDiese Hinweise sind *nur* für Windows relevant.\n\n### Möglichkeiten, Unix-Tools unter Windows zu erhalten\n\n- Zugriff auf die Macht der Unix-Shell erhälst du unter Microsoft Windows durch die Installation von  [Cygwin](https://cygwin.com/). Die meisten hier beschriebenen Dinge funktionieren damit ohne weiteren Aufwand.\n\n- Mit Windows 10 kannst du [Bash on Ubuntu on Windows](https://msdn.microsoft.com/commandline/wsl/about) benutzen, das eine vertraute Bash-Umgebung mit Unix-Befehlszeilen-Werkzeugen. Dies erlaubt einerseits die Nutzung von Linux-Programmen auf Windows, unterstützt andererseits jedoch nicht die Ausführung von Windows-Programmen von der Bash-Konsole.\n\n- Eine weitere Option, GNU-Entwicklerwerkzeuge (etwa GCC) auf Windows zu nutzen, besteht darin, [MinGW](http://www.mingw.org/) und dessen Paket [MSYS](http://www.mingw.org/wiki/msys), das Hilfsprogramme wie bash, gawk, make and grep beinhaltet, zu installieren. MSYS bringt allerdings nicht so viele Features mit wie etwa Cygwin. MinGW ist besonders nützlich für die Erstellung nativer Windows-Ports von Unix-Werkzeugen.\n\n- Eine andere Möglichkeit, ein wenig Unix auf dein Windows-System zu bringen, bietet [Cash](https://github.com/dthree/cash). Beachte allerdings, dass nur sehr wenige Unix-Befehle und Befehlszeilen-Optionen in dieser Umgebung zur Verfügung stehen.\n\n### Nützliche Windows Befehlszeilen-Werkzeugen\n\n- Du kannst die meisten Aufgaben der Windows-Systemverwaltung von der Befehlszeile ausführen und skripten, indem du den Umgang mit `wmic` lernst.\n\n- Native Windows Befehlszeilen Netzwerk Werkzeugen, die du nützlich finden kannst, gehören `ping`,` ipconfig`, `traceroute` und `netstat`.\n\n- Du kannst [viele nützliche Windows-Aufgaben] (http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) durch Aufrufen des Befehls `Rundll32` ausführen.\n\n### Cygwin Tipps und Tricks\n\n- Installiere zusätzliche Unix-Programme mit Cygwins Paketmanager.\n\n- Benutze `mintty` als dein Befehlszeilenfenster.\n\n- Greife mit `/dev/clipboard` auf die Zwischenablage von Windows zu.\n\n- Öffne beliebige Dateien über `cygstart` mit deren Standardprogramm.\n\n- Greife mit `regtool` auf die Windows-Registry zu.\n\n- Beachte, dass der Windows-Pfad `C:\\` unter Cygwin zu `/cygdrive/c` wird und dass Cygwins `/` unter Windows als `C:\\cygwin` verfügbar ist. Für die Umwandlung zwischen Cygwin- und Windows-Pfaden steht `cygpath` zur Verfügung. Dies ist inbesondere für Skripte nützlich, welche Windows-Programme ausführen.\n\n\n## Weitere Quellen\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Eine hilfreiche Liste von Shell-Werkzeugen und Quellen.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Eine ausführliche Anleitung für die Befehlszeile unter OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/), um bessere Shell-Skripte zu schreiben.\n- [shellcheck](https://github.com/koalaman/shellcheck): Ein statisches Analysetool für Shell-Skripte. Im Grunde lint für bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Entmutigend komplexe Einzelheiten darüber, wie Dateinamen in Shell-Skripts richtig eingesetzt werden.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Mehr Befehle und Werkzeuge, die für [\"data science\"](https://de.wikipedia.org/wiki/Data_Science) hilfreich sind, aus dem gleichnamigen Buch.\n\n\n## Haftungsausschluss\n\nMit der Ausnahme einiger sehr kleiner Aufgaben ist der Code so geschrieben, dass andere ihn lesen können. Mit Macht kommt Verantwortung. Die Tatsache etwas in Bash tun zu *können*, heißt nicht zwangsläufig, dass du es tun solltest!\n\n\n## Lizenz\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nDieses Werk ist lizensiert gemäß der [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-el.md",
          "type": "blob",
          "size": 76.3,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# Η Τέχνη της Γραμμής Εντολών\n+[![Ρωτήστε μία ερώτηση](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Ελάτε στη συζήτηση στο https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [Meta](#meta)\n- [Τα βασικά](#basics)\n- [Καθημερινή χρήση](#everyday-use)\n- [Επεξεργασία αρχείων και δεδομένων](#processing-files-and-data)\n- [Αποσφαλμάτωση συστήματος](#system-debugging)\n- [Εντολές σε μία γραμμή](#one-liners)\n- [Ασυνήθιστες αλλά χρήσιμες](#ασυνήθιστες-αλλά-χρήσιμες)\n- [Μόνο για OS X](#os-x-only)\n- [Μόνο για Windows](#windows-only)\n- [Περισσότερες πηγές](#more-resources)\n- [Αποποίηση ευθύνης](#disclaimer)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nΗ ευχέρεια στη χρήση της γραμμής εντολών είναι μία δεξιότητα συχνά παραμελημένη ή που θεωρείται ότι είναι για τους λίγους.\nΌμως η ευχέρια αυτή βελτιώνει την ευελιξία και την παραγωγικότητά σας ως μηχανικός τόσο με προφανείς όσο και με λιγότερο ευδιάκριτους τρόπους. Αυτή είναι μία συλλογή από σημειώσεις και συμβουλές που αφορούν τη χρήση της γραμμής εντολών και τις οποίες βρήκαμε χρήσιμες, ενώ εργαζόμασταν σε Linux. Κάποιες συμβουλές είναι εισαγωγικές και μερικές πιο συγκρεκριμένες, εξειδικευμένες ή εις βάθος. Αυτή η σελίδα δεν είναι μεγάλη, αλλά αν μπορείτε να τα θυμάστε όλα, τότε γνωρίζετε πολλά.\n\n\nΑυτή η εργασία είναι αποτέλεσμα [πολλών συγγραφέων και μεταφραστών](AUTHORS.md).\nΜέρος της\n[αρχικά](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[δημοσιεύτηκε](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nστο [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nαλλά έπειτα μετακινήθηκε στο GitHub, όπου άνθρωποι πιο ταλαντούχοι από τον αρχικό συγγραφέα έχουν κάνει πολυάριθμες βελτιώσεις.\n[**Παρακαλώ υποβάλετε μία ερώτηση**](https://airtable.com/shrzMhx00YiIVAWJg), αν έχετε μία ερώτηση σχετική με τη γραμμή εντολών. [**Παρακαλώ συνεισφέρετε**](/CONTRIBUTING.md), αν δείτε ένα λάθος ή κάτι που μπορεί να βελτιωθεί!\n\n## Meta\n\nΑντικείμενο:\n\n- Αυτός ο οδηγός απευθύνεται τόσο σε αρχάριους όσο και σε έμπειρους. Οι στόχοι είναι το *εύρος* (ό,τι είναι σημαντικό), η *ακρίβεια* (να δοθούν συγκεκριμένα παραδείγματα για τις συνηθέστερες περιπτώσεις)και η *συντομία* (να αποφευχθούν πράγματα που δεν είναι αναγκαία ή παρεκβάσεις που μπορεί κανείς εύκολα να αναζητήσει αλλού). Κάθε συμβουλή είναι απαραίτητη σε κάποια περίπτωση ή εξοικονομεί χρόνο σε σημαντικό βαθμό σε σύγκριση με εναλλακτικές.\n- Το παρόν είναι γραμμένο για Linux, με εξαίρεση των τμημάτων «[Μόνο για OS X](#os-x-only)» και «[Μόνο για Windows](#windows-only)». Πολλά από τα υπόλοιπα κομμάτια ισχύουν ή μπορούν να εγκατασταθούν σε άλλα Unices ή OS X (ή ακόμη και Cygwin).\n- Εστιάζεται στον διαδραστικό φλοιό Bash, αν και πολλές συμβουλές ισχύουν και για άλλους φλοιούς και γενικότερα στη συγγραφή σεναρίων (scripts) για Bash.\n- Περιλαμβάνει τόσο τις «τυπικές» εντολές Unix καθώς και άλλες που απαιτούν την εγκατάσταση ειδικών πακέτων λογισμικού -- αρκεί να είναι αρκετά σημαντικές ώστε να αξίζει να περιληφθούν.\n\nΣημειώσεις:\n\n- Για να κρατηθεί το παρόν σε μία σελίδα, υπάρχει περιεχόμενο που περιλαμβάνεται έμμεσα κάνοντας αναφορά σε αυτό. Είστε αρκετά έξυπνοι ώστε να αναζητήσετε περαιτέρω λεπτομέρειες αλλού, μόλις καταλάβετε την ιδέα ή την εντολή που χρειάζεται να αναζητήσετε στο Google. Χρησιμοποιήστε `apt-get`, `yum`, `dnf`, `pacman`, `pip` ή `brew` (ανάλογα με την περίπτωση) για να εγκαταστήσετε νέα προγράμματα.\n- Χρησιμοποιήστε [Explainshell](http://explainshell.com/) για να έχετε μια χρήσιμη ανάλυση του τι κάνουν κάνουν εντολές, επιλογές, σωληνώσεις κλπ.\n\n## Τα βασικά\n\n- Μάθετε τα βασικά του φλοιού Bash. Πράγματι, πληκτρολογήστε `man bash` και τουλάχιστον ρίξτε μια ματιά σε αυτό που εμφανίζεται· είναι αρκετά εύκολο να το ακολουθήσετε κι όχι και τόσο μεγάλο. Άλλοι φλοιοί μπορεί να είναι μια χαρά, αλλά ο φλοιός Bash έχει πολλές δυνατότητες και είναι πάντα διαθέσιμος (το να μάθετε *μόνο* zsh, fish κλπ., αν και δελεαστικό όσο δουλεύετε στο δικό σας laptop, σας περιορίζει σε πολλές περιπτώσεις, όπως στην περίπτωση servers που ήδη υπάρχουν).\n\n- Μάθετε τουλάχιστον έναν text-based επεξεργαστή κειμένου καλά. Ο επεξεργαστής κειμένου `nano` είναι από τους από τους απλούστερους για βασική επεξεργασία (άνοιγμα, επεξεργασία, αποθήκευση, αναζήτηση). Όμως, για τον έμπειρο χρήστη σε ένα τερματικό κειμένου, δεν υπάρχει υποκατάστατο για τον Vim (`vi`), τον δύσκολο να τον μάθει κάνεις αλλά αξιόλογο, γρήγορο και ολοκληρωμένο επεξεργαστή κειμένου. Πολλοί χρησιμοποιούν ακόμη τον κλασικό Emacs, ιδιαίτερα για μεγαλύτερες εργασίες που αφορούν επεξεργασία κειμένου. (Βέβαια, κάθε σύγχρονος προγραμματιστής που εργάζεται σε ένα μεγάλο έργο είναι απίθανο να χρησιμοποιεί μόνο έναν απλό text-based επεξεργαστή κειμένου και θα πρέπει να είναι επίσης εξοικειωμένος με σύγχρονα και με γραφικό περιβάλλον IDEs και εργαλεία.)\n\n- Να γνωρίζετε πώς να διαβάζετε τεκμηρίωση με την εντολή `man` (για τον περίεργο, η εντολή `man man` εμφανίζει σε λίστα τους αριθμούς των ενοτήτων, π.χ. η 1 περιέχει τις εντολές του φλοιού, η 5 αρχεία/συμβάσεις και  η 8 είναι για διαχείριση). Αναζητήστε σελίδες man με την εντολή `apropos`. Να γνωρίζετε ότι μερικές εντολές δεν είναι εκτελέσιμα προγράμματα αλλά ενσωματωμένες στον φλοιό και μπορείτε να ζητήσετε βοήθεια σχετικά με αυτές με `help` και `help -d`. Μπορείτε να βρείτε αν μια εντολή είναι εκτελέσιμο πρόγραμμα, ή ενσωματωμένη στον φλοιό ή ένα ακόμη όνομα (συντόμευση) που έχει αντιστοιχηθεί στην εντολή αυτή χρησιμοποιώντας την εντολή `type command`.\n\n- Μάθετε για την ανακατεύθυνση της εξόδου και της εισόδου με χρήση των τελεστών `>` και `<` και για τις σωληνώσεις εντολών με χρήση του `|`. Να γνωρίζετε ότι ο τελεστής `>` αντικαθιστά το αρχείο εξόδου και ο `>>` προσθέτει στο τέλος του αρχείου. Μάθετε για τα stdout και stderr.\n\n- Μάθετε για την επέκταση αρχείων μπαλαντέρ (glob) με `*` (και ίσως του `?` και `[`...`]`) και τη χρήση εισαγωγικών και τη διαφορά ανάμεσα στα διπλά `\"` και τα μονά `'` εισαγωγικά. (Δείτε περισσότερα για την επέκταση μεταβλητών παρακάτω.)\n\n- Εξοικειωθείτε με τη διαχείριση εργασιών στον Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill` κλπ.\n\n- Να γνωρίζετε την εντολή `ssh` και τα βασικά της αυθεντικοποίησης χωρίς κωδικό με χρήση των `ssh-agent`, `ssh-add` κλπ.\n\n- Βασική διαχείριση αρχείων: `ls` και `ls -l` (συγκεκριμένα, μάθετε τι σημαίνει κάθε στήλη που εμφανίζει η `ls -l`), `less`, `head`, `tail` και `tail -f` (ή ακόμη καλύτερα, `less +F`), `ln` και `ln -s` (μάθετε τις διαφορές και τα πλεονεκτήματα των κανονικών συνδέσμων σε σύγκριση με τους συμβολικούς), `chown`, `chmod`, `du` (για μία γρήγορη περίληψη της χρήσης του δίσκου: `du -hs *`). Για διαχείριση του συστήματος αρχείων, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Μάθετε τι είναι inode (`ls -i` ή `df -i`).\n\n- Βασική διαχείριση δικτύου: `ip` ή `ifconfig`, `dig`, `traceroute`, `route`.\n\n- Μάθετε και χρησιμοποιήστε ένα σύστημα διαχείρισης και ελέγχου εκδόσεων, όπως το `git`.\n\n- Να γνωρίζετε καλά κανονικές εκφράσεις και τις διάφορες επιλογές (flags) για τις `grep`/`egrep`. Τις επιλογές `-i`, `-o`, `-v`, `-A`, `-B`και `-C` αξίζει να τις γνωρίζετε.\n\n- Μάθετε να χρησιμοποιείτε τις εντολές `apt-get`, `yum`, `dnf` ή `pacman` (ανάλογα με τη διανομή του λειτουργικού σας συστήματος) για να βρίσκετε και να εγκαθιστάτε πακέτα λογισμικού. Και βεβαιωθείτε ότι έχετε την `pip` για να εγκαθιστάτε εργαλεία της γραμμής εντολών που βασίζονται σε Python (μερικά από τα παρακάτω είναι πιο εύκολο να εγκατασταθούν με `pip`).\n\n## Καθημερινή χρήση\n\n- Στον Bash, χρησιμοποιήστε **Tab** για να ολοκληρώσετε ορίσματα ή να εμφανίσετε σε λίστα όλες τις διαθέσιμες εντολές, **ctrl-r** για να αναζητήσετε στο ιστορικό των εντολών (αφού πατήσετε, πληκτρολογήστε για να αναζητήσετε, πατήστε **ctrl-r** επαναλαμβανόμενα για να περιηγηθείτε σε περισσότερα αποτελέσματα αναζήτησης, πατήστε **Enter** για να εκτελέσετε την εντολή που βρήκατε ή πατήστε το δεξί βέλος για να μεταφέρετε το αποτέλεσμα στην τρέχουσα γραμμή ώστε να μπορείτε να το επεξεργαστείτε).\n\n- Στον Bash, χρησιμοποιήστε **ctrl-w** για να διαγράψετε την τελευταία λέξη και **ctrl-u** για να διαγράψετε το περιεχόμενο από την τρέχουσα θέση του δρομέα μέχρι την αρχή της γραμμής. Χρησιμοποιήστε **alt-b** και **alt-f** για να μετακινηθείτε κατά μια λέξη, **ctrl-a** για να μετακινήσετε τον δρομέα στην αρχή της γραμμής, **ctrl-e** για να μετακινήσετε τον δρομέα στο τέλος της γραμμής, **ctrl-k** για να διαγράψετε ως το τέλος της γραμμής, **ctrl-l** για να καθαρίσετε την οθόνη. Δείτε τη `man readline` για όλες τις συντομεύσεις πληκτρολογίου στον Bash. Υπάρχουν πολλές. Για παράδειγμα, η **alt-.** επαναλαμβάνει κυκλικά τα προηγούμενα ορίσματα και η **alt-** αναπτύσσει ένα μπαλαντέρ (glob).\n\n- Εναλλακτικά, αν σας αρέσουν οι συντομεύσεις τύπου vi, χρησιμοποιήστε `set -o vi` (και `set -o emacs` για να επαναφέρετε).\n\n- Για την επεξεργασία μεγάλων εντολών, αφού ορίσετε τις ρυθμίσεις του επεξεργαστή κειμένου σας (για παράδειγμα `export EDITOR=vim`), με **ctrl-x** **ctrl-e** θα ανοίξει η τρέχουσα εντολή σε έναν επεξεργαστή κειμένου για επεξεργασία πολλών γραμμών. Ή αν έχετε ορίσει συντομεύσεις τύπου vi, **escape-v**.\n\n- Για να δείτε πρόσφατες εντολές χρησιμοποιήστε την εντολή `history`. Ακολουθήστε την με την εντολή  `!n` (όπου `n` είναι ο αριθμός της εντολής) για να την εκτελέσετε ξανά. Υπάρχουν πάρα πολλές συντομεύσεις που μπορείτε να χρησιμοποιήσετε. Από αυτές οι πιο χρήσιμες μάλλον είναι η `!$` για την τελευταία παράμετρο και η `!!` για την τελευταία εντολή (δείτε το \"HISTORY EXPANSION\" στην τεκμηρίωση του φλοιού). Όμως, αυτές συχνά εύκολα αντικαθίστανται από **ctrl-r** και **alt-.**.\n\n- Πηγαίνετε στον προσωπικό σας κατάλογο (home) με `cd`. Αποκτήστε πρόσβαση σε αρχεία που βρίσκονται σε σχετική θέση με τον προσωπικό κατάλογό σας με το πρόθεμα `~` (π.χ. `~/.bashrc`). Σε σενάριο `sh` μπορείτε να αναφέρεστε στον προσωπικό σας κατάλογο ως `$HOME`.\n\n- Για να πάτε στον προηγούμενο κατάλογο όπου εργαζόσαστε: `cd -`.\n\n- Αν έχετε γράψει μέχρι τη μέση μία εντολή, αλλά αλλάξατε γνώμη, πατήστε **alt-#** για να προσθέσετε ένα`#` στην αρχή και να την προσθέσετε ως ένα σχόλιο (ή χρησιμοποιήστε **ctrl-a**, **#**, **enter**). Μπορείτε να επιστρέψετε σε αυτή αργότερα με το ιστορικό εντολών.\n\n- Χρησιμοποιήστε `xargs` (ή `parallel`). Έχει πολλές δυνατότητες. Σημειώστε ότι μπορείτε να ελέγξετε πόσα στοιχεία θα εκτελέσετε ανά γραμμή (`-L`) καθώς και παράλληλη εκτέλεση εντολών (`-P`). Αν δεν είστε σίγουρος ότι θα κάνει το σωστό, χρησιμοποιήστε πρώτα `xargs echo`. Επίσης, η επιλογή `-I{}` είναι χρήσιμη. Παραδείγματα:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` είναι μία χρήσιμη εμφάνιση του δέντρου διεργασιών.\n\n- Χρησιμοποιήστε `pgrep` και `pkill` για να αναζητήσετε ή να στείλετε σήμα σε διεργασίες με βάση το όνομά τους (η επιλογή `-f` είναι χρήσιμη).\n\n- Να γνωρίζετε τα διάφορα σήματα που μπορείτε να στείλετε σε διεργασίες. Για παράδειγμα, για να αναστείλετε μία διεργασία χρησιμοποιήστε `kill -STOP [pid]`. Για ολόκληρη τη λίστα, δείτε `man 7 signal`\n\n- Χρησιμοποιήστε `nohup` ή `disown`, αν θέλετε μία διεργασία παρασκηνίου να συνεχίσει να εκτελείται για πάντα.\n\n- Ελέγξτε ποιες διεργασίες είναι σε αναμονή για κλήση listen με `netstat -lntp` ή `ss -plat` (για TCP· προσθέστε `-u` για UDP) ή `lsof -iTCP -sTCP:LISTEN -P -n` (που δουλεύει επίσης σε OS X).\n\n- Δείτε επίσης `lsof` και `fuser` για ανοιχτές συνδέσεις δικτύου (sockets) και αρχεία.\n\n- Δείτε `uptime` ή `w` για να δείτε για πόσο το σύστημα βρίσκεται σε λειτουργία.\n\n- Χρησιμοποιήστε `alias` για να δημιουργήσετε συντομεύσεις για συχνά χρησιμοποιούμενες εντολές. Για παράδειγμα, η `alias ll='ls -latr'` δημιουργεί μία νέα συντόμευση `ll`.\n\n- Αποθηκεύστε συντομεύσεις, ρυθμίσεις φλοιού και μεθόδους που χρησιμοποιείτε συχνά στο `~/.bashrc`και [προβλέψτε ώστε οι login φλοιοί να τα διαβάζουν](http://superuser.com/a/183980/7106). Αυτό θα κάνει τις ρυθμίσεις σας διαθέσιμες κάθε φορά που χρησιμοποιείτε τον φλοιό.\n\n- Βάλτε τις ρυθμίσεις των μεταβλητών περιβάλλοντος καθώς και τις εντολές που χρειάζεται να εκτελεστούν με την είσοδό σας στο `~/.bash_profile`. Ξεχωριστές ρυθμίσεις θα χρειαστούν για τους φλοιούς που εκτελούνται από είσοδο από γραφικό περιβάλλον και εργασίες `cron`.\n\n- Συγχρονίστε τα αρχεία με τις ρυθμίσεις σας (π.χ. `.bashrc` και `.bash_profile`) μεταξύ διαφορετικών υπολογιστών χρησιμοποιώντας Git.\n\n- Κατανοήστε ότι χρειάζεται προσοχή, όταν μεταβλητές και ονόματα αρχείων περιέχουν κενούς (whitespace) χαρακτήρες. Περικλείετε τις μεταβλητές του Bash σε εισαγωγικά, π.χ. `\"$FOO\"`. Προτιμήστε τις επιλογές `-0` ή `-print0` για να επιτρέψετε σε κενούς χαρακτήρες να διαχωρίζουν ονόματα αρχείων, π.χ. `locate -0 pattern | xargs -0 ls -al` ή `find / -print0 -type d | xargs -0 ls -al`. Για να περάσετε ένα προς ένα από όλα τα αρχεία που περιέχουν κενούς χαρακτήρες σε έναν βρόχο επανάληψης `for`, ορίστε τη μεταβλητή IFS να είναι ο χαρακτήρας νέας γραμμής χρησιμοποιώντας `IFS=$'\\n'`.\n\n- Σε σενάρια για Bash, χρησιμοποιήστε `set -x` (ή την παραλλαγή `set -v`, που γράφει τα πρωτογενή στοιχεία, όπως σχόλια και μεταβλητές πριν αντικατασταθούν) για να τα αποσφαλματώσετε. Χρησιμοποιείτε αυστηρές λειτουργίες (strict modes) εκτός κι αν έχετε σημαντικό λόγο να μην το κάνετε: Χρησιμοποιήστε `set -e` για να εγκαταλείψετε την εκτέλεση σε περίπτωση σφάλματος (μη μηδενικός κωδικός εξόδου). Χρησιμοποιήστε `set -u` για να ανιχνεύσετε τη χρήση μεταβλητών χωρίς τιμή. Έχετε υπόψη σας και την εντολή `set -o pipefail`, για να εμφανίσετε τα σφάλματα που προκύπτουν στο ενδιάμεσο σωληνώσεων εντολών (αλλά διαβάστε περισσότερο για αυτή, αν τη χρησιμοποιήσετε καθώς αυτό το θέμα είναι ιδιαίτερα λεπτό). Για πιο πολύπλοκα σενάρια, χρησιμοποιήστε επίσης την εντολή `trap` για κωδικούς εξόδου EXIT ή ERR. Μια χρήσιμη συνήθεια είναι να ξεκινάτε ένα σενάριο έτσι, κάνοντάς το να ανιχνεύει και να τερματίζει σε συνήθη σφάλματα και να τυπώνει ένα μήνυμα:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- Σε σενάρια για Bash, οι υποφλοιοί (γραμμένοι μέσα σε παρενθέσεις) είναι βολικοί τρόποι ομαδοποίησης εντολών. Ένα συνηθισμένο παράδειγμα είναι η προσωρινή μετακίνηση σε διαφορετικό τρέχοντα κατάλογο, π.χ.\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- Στον Bash, σημειώστε ότι υπάρχουν πολλοί τρόποι επέκτασης μίας μεταβλητής. Έλεγχος του αν μία μεταβλητή υπάρχει: `${name:?error message}`. Για παράδειγμα, αν ένα σενάριο Bash παίρνει ένα μόνο όρισμα, απλά γράψτε `input_file=${1:?usage: $0 input_file}`. Χρήση μίας προεπιλεγμένης τιμής αν μία μεταβλητή είναι κενή: `${name:-default}`. Αν θέλετε να προσθέσετε μία επιπλέον (προαιρετική) παράμετρο στο προηγούμενο παράδειγμα, μπορείτε να χρησιμοποιήσετε κάτι όπως: `output_file=${2:-logfile}`. Αν η `$2` παραλείπεται και άρα είναι κενή, η τιμή της `output_file` θα είναι `logfile`. Αριθμητική επέκταση: `i=$(( (i + 1) % 5 ))`. Ακολουθίες: `{1..10}`. Περικοπή αλφαριθμητικών: `${var%suffix}` και `${var#prefix}`. Για παράδειγμα, αν `var=foo.pdf`, τότε η `echo ${var%.pdf}.txt` τυπώνει `foo.txt`.\n\n- Η επέκταση με αγκύλες χρησιμοποιώντας `{`...`}` μπορεί να μειώσει τις φορές που χρειάζεται να πληκτρολογήσετε ξανά παρόμοιο κείμενο και να αυτοματοποιήσει συνδυασμούς στοιχείων. Αυτό είναι χρήσιμο σε παραδείγματα όπως `mv foo.{txt,pdf} some-dir` (που μετακινεί και τα δύο αρχεία), `cp somefile{,.bak}` (που επεκτείνεται σε `cp somefile somefile.bak`) ή `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (που επεκτείνεται σε όλους τους πιθανούς συνδυασμούς και δημιουργεί ένα δέντρο καταλόγων). Η επέκταση με αγκύλες πραγματοποιείται πριν από οποιαδήποτε άλλη επέκταση.\n\n- Η σειρά των επεκτάσεων είναι: επέκταση με αγκύλες· επέκταση περισπωμένης, επέκταση παραμέτρων και μεταβλητών, αριθμητική επέκταση και αντικατάσταση εντολής (γίνεται από τα αριστερά προς τα δεξιά)· χωρισμός λέξεων· και επέκταση ονομάτων αρχείων. Για παράδειγμα, ένα εύρος τιμών όπως `{1..20}` δεν μπορεί να εκφραστεί με μεταβλητές χρησιμοποιώντας `{$a..$b}`. Χρησιμοποιήστε αντί μεταβλητών την εντολή `seq` ή μία δομή επανάληψης `for`, π.χ. `seq $a $b` ή `for((i=a; i<=b; i++)); do ... ; done`.)\n\n- Μπορείτε να χειριστείτε την έξοδο μίας εντολής ως αρχείο `<(some command)` (είναι γνωστό ως αντικατάσταση διεργασίας). Για παράδειγμα, συγκρίνετε το τοπικό `/etc/hosts` με ένα απομακρυσμένο:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Όταν γράφετε σενάρια, ίσως θέλετε να βάλετε όλον σας τον κώδικα μέσα σε άγκριστρα. Αν το δεξί άγκιστρο λείπει, το σενάριό σας δε θα εκτελεστεί λόγω συντακτικού σφάλματος. Αυτό είναι σκόπιμο, όταν το σενάριό σας πρόκειται να μεταφορτωθεί από το διαδίκτυο, αφού έτσι εμποδίζεται η εκτέλεση σεναρίων που έχουν μερικώς ληφθεί:\n```bash\n{\n      # Your code here\n}\n```\n\n- Να γνωρίζετε για το «here documents» στον Bash, όπως στην `cat <<EOF ...`.\n\n- Στον Bash, ανακατευθύνετε τόσο την έξοδο όσο και την έξοδο σφαλμάτων ως εξής: `some-command >logfile 2>&1` ή `some-command &>logfile`. Συχνά για να βεβαιωθείτε ότι μία εντολή δεν αφήνει μια σύνδεση αρχείου ανοιχτή στην είσοδο, δεσμεύοντας τον στο τερματικό που βρίσκεστε, είναι μία καλή πρακτική να προσθέτετε `</dev/null`.\n\n- Χρησιμοποιήστε `man ascii` για έναν καλό πίνακα ASCII, με δεξαεξαδικές και δεκαδικές τιμές. Για γενικές πληροφορίες που αφορούν την κωδικοποίηση, οι `man unicode`, `man utf-8` και `man latin1`είναι χρήσιμες.\n\n- Χρησιμοποιήστε `screen` ή [`tmux`](https://tmux.github.io/) για να ενεργοποιήσετε την πολυπλεξία της οθόνης. Αυτό είναι ιδιαίτερα χρήσιμο σε απομακρυσμένες συνεδρίες ssh και για να διακόψετε ή να επαναφέρετε μια συνεδρία. H εντολή `byobu` ή `tmux` μπορεί να βελτιώσει την οθόνη παρέχοντας περισσότερες πληροφορίες και πιο εύκολη διαχείριση. Μία πιο απλή εναλλακτική μόνο για τη διατήρηση συνεδριών είναι η [`dtach`](https://github.com/bogner/dtach).\n\n- Με ssh, το να γνωρίζετε πώς να προωθήσετε μία θύρα με τις επιλογές `-L` ή `-D` (και καμιά φορά με την `-R`) είναι χρήσιμο, π.χ. για να έχετε πρόσβαση σε ιστοσελίδες από έναν απομακρυσμένο server.\n\n- Μπορεί να είναι χρήσιμο να κάνετε μερικές βελτιστοποιήσεις στις ssh ρυθμίσεις σας· για παράδειγμα, αυτό `~/.ssh/config` περιέχει ρυθμίσεις για να αποφεύγετε τις συνδέσεις που διακόπτονται σε ορισμένα περιβάλλοντα δικτύου, χρησιμοποιεί συμπίεση (που είναι χρήσιμη με scp σε συνδέσεις με περιορισμένο εύρος ζώνης) και πολύπλεξη καναλιών στον ίδιο server με τοπικό αρχείο έλέγχου:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Μερικές άλλες επιλογές σχετικές με την ssh είναι ευαίσθητες όσον αφορά την ασφάλεια και θα πρέπει να ενεργοποιούνται με προσοχή, π.χ. ανά υποδίκτυο ή host ή σε έμπιστα δίκτυα: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- ´Εχετε υπόψη σας την εντολή [`mosh`](https://mosh.org/) ως μία εναλλακτική της ssh που χρησιμοποιεί UDP, αποφεύγοντας τις συνδέσεις που διακόπτονται και διευκολύνοντας τη διαδικασία (απαιτεί ρύθμιση στον server).\n\n- Για να πάρετε τα δικαιώματα ενός αρχείου σε οκταδική μορφή, πράγμα που είναι χρήσιμο για την παραμετροποίηση του συστήματος, αλλά δεν είναι διαθέσιμο με την `ls` και είναι εύκολο να γίνει άτσαλα, χρησιμοποιήστε κάτι όπως\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Για διαδραστική επιλογή τιμών από την έξοδο μίας άλλης εντολής, χρησιμοποιήστε [`percol`](https://github.com/mooz/percol) ή [`fzf`](https://github.com/junegunn/fzf).\n\n- Για επιλογή αρχείων με βάση την έξοδο μιας άλλη εντολής (όπως της `git`), χρησιμοποιήστε `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Για έναν απλό web server και για όλα τα αρχεία στον τρέχοντα κατάλογο (και υποκαταλόγους) διαθέσιμα σε οποιονδήποτε στο δίκτυο, χρησιμοποιήστε:\n`python -m SimpleHTTPServer 7777` (για τη θύρα 7777 και Python 2) και `python -m http.server 7777` (για τη θύρα 7777 και Python 3).\n\n- Για την εκτέλεση μίας εντολής ως άλλος χρήστης, χρησιμοποιήστε `sudo`. Από προεπιλογή εκτελείται ως `root`· χρησιμοποιήστε `-u` για να ορίσετε άλλον χρήστη. Χρησιμοποιήστε `-i` για να συνδεθείτε ως αυτός ο χρήστης. (Μπορεί να σας ζητηθεί το συνθηματικό σας.)\n\n- Για να αλλάξετε τον φλοιό σε άλλον χρήστη, χρησιμοποιήστε `su username` ή `su - username`. Το τελευταίο με \"-\" φορτώνει το περιβάλλον με τον ίδιο τρόπο όπως αν μόλις συνδεόταν ένας άλλος χρήστης. Παραλείποντας το username χρησιμοποιείτε την προεπιλογή `root`.  Αν δεν είστε `root`, θα σας ζητηθεί το συνθηματικό.\n\n- Έχετε υπόψη σας τον [περιορισμό των 128K](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) για τις γραμμές εντολών. Το σφάλμα «Η λίστα των ορισμάτων είναι πολύ μεγάλη» είναι κοινό, όταν γίνεται ταίριασμα με χαρακτήρα wildcard ενάντι μεγάλου αριθμού αρχείων. (Όταν συμβαίνει αυτό, εναλλακτικές όπως οι `find` και `xargs` μπορεί να βοηθήσουν.)\n\n- Για να κάνετε μια απλή πράξη αριθμητικής (και βέβαια γενικά για πρόσβαση σε Python), χρησιμοποιήστε τον διερμηνευτή `python`. Για παράδειγμα,\n```python\n>>> 2+3\n5\n```\n\n## Επεξεργασία αρχείων και δεδομένων\n\n- Για να εντοπίσετε ένα αρχείο με βάση το όνομά του στον τρέχοντα κατάλογο, `find . -iname '*something*'` (ή με παρόμοιο τρόπο). Για να βρείτε ένα αρχείο με το όνομά του οπουδήποτε, χρησιμοποιήστε `locate something` (αλλά να έχετε στον νου σας ότι η `updatedb` μπορεί να μην έχει δημιουργήσει ευρετήριο για αρχεία που δημιουργήθηκαν πρόσφατα).\n\n- Για γενική αναζήτηση σε αρχεία πηγαίου κώδικα ή αρχεία δεδομένων, υπάρχουν αρκετές επιλογές πιο προχωρημένες ή γρήγορες από την `grep -r`, συμπεριλαμβανομένων (και κατά προσέγγιση ταξινομημένων από την πιο παλιά στη νεότερη) των [`ack`](https://github.com/beyondgrep/ack2), [`ag`](https://github.com/ggreer/the_silver_searcher) (\"the silver searcher\"), και [`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep).\n\n- Για να μετατρέψετε HTML σε κείμενο: `lynx -dump -stdin`\n\n- Για Markdown, HTML και άλλου είδους μετατροπές κειμένου, δοκιμάστε [`pandoc`](http://pandoc.org/).\n\n- Αν χρειάζεται να χειριστείτε XML, η `xmlstarlet` είναι παλιά αλλά καλή.\n\n- Για JSON, χρησιμοποιήστε [`jq`](http://stedolan.github.io/jq/). Για διαδραστική χρήση, δείτε επίσης [`jid`](https://github.com/simeji/jid) και [`jiq`](https://github.com/fiatjaf/jiq).\n\n- Για YAML, χρησιμοποιήστε [`shyaml`](https://github.com/0k/shyaml).\n\n- Για αρχεία Excel ή CSV, το πακέτο [csvkit](https://github.com/onyxfish/csvkit) παρέχει τις `in2csv`, `csvcut`, `csvjoin`, `csvgrep` κλπ.\n\n- Για Amazon S3, η [`s3cmd`](https://github.com/s3tools/s3cmd) είναι βολική και η [`s4cmd`](https://github.com/bloomreach/s4cmd) είναι γρηγορότερη. Η [`aws`](https://github.com/aws/aws-cli) της Amazon και η βελτιωμένη [`saws`](https://github.com/donnemartin/saws) είναι απαραίτητες για εργασίες που σχετίζονται με AWS.\n\n- Να γνωρίζετε για τις `sort` και `uniq`, συμπεριλαμβανομένων των επιλογών `-u` και `-d` της uniq -- παρακάτω δείτε το κομμάτι που αφορά τις εντολές σε μία γραμμή. Δείτε επίσης την `comm`.\n\n- Να γνωρίζετε για τις `cut`, `paste` και `join` για να χειρίζεστε αρχεία κειμένου. Πολλοί χρησιμοποιούν την `cut`, αλλά ξεχνούν την `join`.\n\n- Να γνωρίζετε για τη `wc` για να μετράτε νέες γραμμές (`-l`), χαρακτήρες (`-m`), λέξεις (`-w`) και bytes (`-c`).\n\n- Να γνωρίζετε για την `tee` για να αντιγράφετε από το stdin σε ένα αρχείο κι επίσης στο stdout, όπως στην `ls -al | tee file.txt`.\n\n- Για πιο πολύπλοκους υπολογισμούς, όπως ομαδοποίηση, αναστροφή πεδίων και στατιστικούς υπολογισμούς, έχετε υπόψη σας την εντολή [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Να γνωρίζετε ότι η τοπική διαμόρφωση του συστήματος (locale, π.χ. ελληνικό) επηρεάζει πολλά εργαλεία γραμμής εντολών με λιγότερο προφανείς τρόπους, συμπεριλαμβανομένων της σειράς ταξινόμησης (collation) και της απόδοσης. Οι περισσότερες εγκαταστάσεις Linux θα έχουν αναθέσει στη μεταβλητή `LANG` ή σε άλλες σχετικές με locale μεταβλητές τιμή μιας τοπική ρύθμισης όπως η Αγγλική ΗΠΑ. Αλλά να έχετε υπόψη ότι η ταξινόμηση μπορεί να αλλάξει, αν θέσετε άλλο locale. Και να γνωρίζετε ότι οι διεθνοποιημένες ρουτίνες μπορούν να κάνουν την ταξινόμηση ή άλλες εντολές να εκτελούνται *πολλές φορές* πιο αργά. Σε μερικές περιπτώσεις (όπως στον ορισμό διεργασιών ή της μοναδικότητας διεργασιών παρακάτω) μπορείτε με ασφάλεια να αγνοήσετε εντελώς αργές διεθνοποιημένες ρουτίνες και να χρησιμοποιήσετε παραδοσιακή ταξινόμηση με βάση bytes, χρησιμοποιώντας `export LC_ALL=C`.\n\n- Μπορείτε να ορίσετε ένα συγκεκριμένο περιβάλλον για μία εντολή προσθέτοντάς της ως πρόθεμα τις ρυθμίσεις της μεταβλητής περιβάλλοντος, όπως στην `TZ=Pacific/Fiji date`.\n\n- Να γνωρίζετε τα βασικά για τις `awk` και `sed` για απλή επεξεργασία δεδομένων. Δείτε [Εντολές σε μία γραμμή](#one-liners) για παραδείγματα.\n\n- Για να αντικαταστήσετε επί τόπου όλες τις εμφανίσεις ενός αλφαριθμητικού σε ένα ή περισσότερα αρχεία:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Για να μετονομάσετε πολλά και/ή να αναζητήσετε και να αντικαταστήσετε σε αρχεία, δοκιμάστε την [`repren`](https://github.com/jlevy/repren). (Σε ορισμένες περιπτώσεις η εντολή `rename` επιτρέπει επίσης πολλαπλές μετονομασίες, αλλά να είστε προσεχτικοί καθώς δε συμπεριφέρεται με τον ίδιο τρόπο σε όλες τις διανομές Linux.)\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Όπως λέει η σελίδα man, η `rsync` είναι πράγματι ένα γρήγορο και εξαιρετικά ευέλικτο εργαλείο αντιγραφής αρχείων. Είναι γνωστή για τον συγχρονισμό μεταξύ υπολογιστών, αλλά είναι εξίσου χρήσιμη και τοπικά. Όταν οι περιορισμοί ασφάλειας το επιτρέπουν, η χρήση της `rsync` αντί της `scp` επιτρέπει τη συνέχιση μιας μεταφοράς χωρίς να ξεκινήσει από την αρχή. Επίσης, είναι ανάμεσα στους [πιο γρήγορους τρόπους](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) να διαγράψει κανείς μεγάλο αριθμό αρχείων:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Για να παρακολουθείτε την πρόοδο όταν αντιγράφετε αρχεία, χρησιμοποιήστε τις `pv`, [`pycp`](https://github.com/dmerejkowsky/pycp), [`progress`](https://github.com/Xfennec/progress), `rsync --progress`, ή για αντιγραφή σε επίπεδο μπλοκ την `dd status=progress`.\n\n- Χρησιμοποιήστε την `shuf` για να ανακατέψετε ή να επιλέξετε τυχαίες γραμμές από ένα αρχείο.\n\n- Να γνωρίζετε τις επιλογές της `sort`. Για αριθμούς χρησιμοποιήστε τις `-n`, ή `-h` για χειρισμό αριθμών που είναι εύκολο να διαβαστούν από άνθρωπο (π.χ. από `du -h`). Να γνωρίζετε πώς λειτουργούν τα ορίσματα (`-t` και `-k`). Συγκεκριμένα, προσέξτε ότι χρειάζεται να γράψετε `-k1,1` για να ταξινομήσετε με βάση μόνο το πρώτο πεδίο· `-k1` σημαίνει ταξινόμηση με βάση όλη τη γραμμή. Η σταθερή ταξινόμηση (`sort -s`) μπορεί να είναι χρήσιμη. Για παράδειγμα, για να ταξινομήσετε πρώτα με βάση το πεδίο 2 και δευτερευόντως με βάση το πεδίο 1, μπορείτε να χρησιμοποιήσετε `sort -k1,1 | sort -s -k2,2`.\n\n- Αν πότε χρειαστεί να γράψετε έναν χαρακτήρα στηλοθέτη (tab) στη γραμμή εντολών στον Bash (π.χ. για να ταξινομήσετε με βάση το όρισμα της επιλογής -t), πιέστε **ctrl-v** **[Tab]** ή γράψτε `$'\\t'` (το τελευταίο είναι καλύτερο, γιατί μπορείτε να το αντιγράψετε/επικολλήσετε).\n\n- Τα συνήθη εργαλεία αυτοματοποιημένης επεξεργασίας αλλαγών (patch) πηγαίου κώδικα είναι οι εντολές `diff` (εμφάνιση διαφορών) και `patch` (εφαρμογή διαφορών σε άλλο αρχείο). Επίσης, δείτε την `diffstat` για περίληψη στατιστικών στοιχείων της εντολής diff και `sdiff` για εμφάνιση διαφορών πλάι-πλάι. Σημειώστε ότι η  `diff -r` λειτουργεί για ολόκληρους καταλόγους. Χρησιμοποιήστε την `diff -r tree1 tree2 | diffstat` για μια περίληψη αλλαγών. Χρησιμοποιήστε την `vimdiff` για να συγκρίνετε και να επεξεργαστείτε αρχεία μέσω της διεπαφής του vim.\n\n- Για δυαδικά αρχεία, χρησιμοποιήστε τις `hd`, `hexdump` ή την `xxd` για απλά δεκαεξαδικά dumps και τις `bvi`, `hexedit` ή `biew` για επεξεργασία σε δυαδική μορφή.\n\n- Επίσης, για δυαδικά αρχεία η `strings` (και η `grep` κλπ.) σας δίνει τη δυνατότητα να βρείτε κομματάκια κειμένου που κρύβονται σ' αυτά.\n\n- Για δυαδικές διαφορές (συμπίεση δέλτα), χρησιμοποιήστε `xdelta3`.\n\n- Για να μετατρέψετε κωδικοποίηση κειμένου, δοκιμάστε την `iconv`. Ή `uconv` για πιο προχωρημένη χρήση· υποστηρίζει πιο προχωρημένα στοιχεία του προτύπου Unicode. Για παράδειγμα:\n :\n```sh\n      # Εμφανίζει τους δεκαεξαδικούς κωδικούς ή πραγματικά ονόματα χαρακτήρων (χρήσιμο για αποσφαλμάτωση):\n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < input.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < input.txt\n      # Mετατρέπει σε πεζούς χαρακτήρες και απαλείφει τους τόνους (επεκτείνοντας και απορρίπτοντάς τους):\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Για να σπάσετε αρχεία σε κομμάτια, δείτε τη `split` (για να σπάσετε με βάση το μέγεθος) και τη `csplit` (για να σπάσετε με βάση πρότυπο).\n\n- Ημερομηνία και ώρα: Για να πάρετε την τρέχουσα ημερομηνία και ώρα στη χρήσιμη μορφή [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), χρησιμοποιήστε `date -u +\"%Y-%m-%dT%H:%M:%SZ\"` (άλλες επιλογές [είναι](https://stackoverflow.com/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [προβληματικές](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option)). Για να χειριστείτε εκφράσεις ημερομηνίας και χρόνου, χρησιμοποιήστε τις εντολές `dateadd`, `datediff`, `strptime` κλπ. από το πακέτο [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Χρησιμοποιήστε `zless`, `zmore`, `zcat`και `zgrep` για να χειριστείτε συμπιεσμένα αρχεία.\n\n- Ιδιότητες αρχείων μπορούν να οριστούν με την `chattr` και προσφέρει μία εναλλακτική για τα δικαιώματα των αρχείων σε χαμηλό επίπεδο. Για παράδειγμα, για να προστατευτείτε από κατά λάθος διαγραφή αρχείου χρησιμοποιήστε την επιλογή immutable:  `sudo chattr +i /critical/directory/or/file`\n\n- Χρησιμοποιήστε τις `getfacl` και `setfacl` για να αποθηκεύσετε και να επαναφέρετε δικαιώματα αρχείων. Για παράδειγμα:\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- Για να δημιουργήσετε άδεια αρχεία γρήγορα, χρηρσιμοποιήστε την `truncate` (δημιουργεί [αραιό αρχείο](https://en.wikipedia.org/wiki/Sparse_file)), τη `fallocate` (ext4, xfs, btrfs και ocfs2 συστήματα αρχείων), την `xfs_mkfile` (σχεδόν για κάθε σύστημα αρχείων, περιλαμβάνεται στο πακέτο xfsprogs), τη `mkfile` (για συστήματα τύπου Unix όπως Solaris, Mac OS).\n\n## Αποσφαλμάτωση συστήματος\n\n- Για web αποσφαλμάτωση, οι εντολές `curl` και `curl -I` είναι χρήσιμες, ή οι ισοδύναμες `wget`, ή η πιο καινούρια [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Για να γνωρίζετε την τρέχουσα κατάσταση του επεξεργαστή και των δίσκων, τα κλασικά εργαλεία είναι η `top` (ή η καλύτερη `htop`), η `iostat`και η `iotop`. Χρησιμοποιήστε την `iostat -mxz 15` για βασικά στατιστικά που αφορούν τον επεξεργαστή ή για λεπτομερή στατιστικά των δίσκων ανά διαμέρισμα και για να έχετε μια εικόνα της απόδοσης.\n\n- Για λεπτομέρειες που αφορούν τη σύνδεση δικτύου, χρησιμοποιήστε τη `netstat` και την `ss`.\n\n- Για μια γρήγορη επισκόπηση του τι συμβαίνει σε ένα σύστημα, η `dstat` είναι ιδιαίτερα χρήσιμη. Για καλύτερη επισκόπηση με λεπτομέρειες, χρησιμοποιήστε [`glances`](https://github.com/nicolargo/glances).\n\n- Για να γνωρίζετε την κατάσταση της μνήμης, εκτελέστε και κατανοήστε την έξοδο των `free` και `vmstat`. Συγκεκριμένα, να έχετε υπόψη ότι η «cached» τιμή είναι μνήμη που δεσμεύει ο πυρήνας του Linux ως προσωρινά αποθηκευμένο αρχείο, ώστε στην ουσία προσμετράται ως «free» τιμή.\n\n- Η αποσφαλμάτωση συστημάτων Java είναι άλλη ιστορία, αλλά ένα απλό κόλπο για το JVM της Oracle και άλλων είναι να τρέξετε την εντολή `kill -3 <pid>` και ένα πλήρες ίχνος στοίβας  και περίληψη σωρού  (συμπεριλαμβανομένων και λεπτομερειών που αφορούν τη συλλογή απορριμάτων σε γενιές, που μπορεί να είναι πολύ κατατοπιστικές) θα εμφανιστούν στο stderr/logs. Οι εντολές του JDK `jps`, `jstat`, `jstack`, `jmap` είναι χρήσιμες. [Τα εργαλεία SJK](https://github.com/aragozin/jvm-tools) είναι για πιο προχωρημένους.\n\n- Χρησιμοποιήστε την [`mtr`](http://www.bitwizard.nl/mtr/) ως μια βελτίωση της traceroute για να ανιχνεύετε ζητήματα του δικτύου.\n\n- Για να δείτε γιατί ένας δίσκος είναι γεμάτος, η [`ncdu`](https://dev.yorhel.nl/ncdu) εξοικονομεί χρόνο σε σύγκριση με τις συνήθεις εντολές όπως `du -sh *`.\n\n- Για να βρείτε ποια δικτυακή σύνδεση ή διεργασία χρησιμοποιεί εύρος ζώνης, δοκιμάστε [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ή [`nethogs`](https://github.com/raboof/nethogs).\n\n- Το εργαλείο `ab` (έρχεται μαζί με Apache) βοηθά στον πρόχειρο έλεγχο της απόδοσης web server. Για πιο σύνθετο έλεγχο φόρτου, δοκιμάστε `siege`.\n\n- Για πιο σοβαρή αποσφαλμάτωση δικτύου, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), ή [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Να γνωρίζετε για τις `strace` και `ltrace`. Αυτές μπορεί να φανούν χρήσιμες, όταν ένα πρόγραμμα αποτυγχάνει, παγώνει ή καταρρέει και δε γνωρίζετε γιατί ή αν θέλετε να έχετε μία γενική ιδέα της απόδοσης. Σημειώστε την επιλογή μέτρησης (`-c`) και τη δυνατότητα να συνδέσετε σε μία διεργασία που εκτελείται (`-p`). Χρησιμοποιήστε την επιλογή για να παρακολουθείτε τις διεργασίες παιδιά (`-f`) για να μη χάνετε σημαντικές κλήσεις.\n\n- Να γνωρίζετε για την `ldd` ώστε να ελέγχετε διαμοιραζόμενες βιβλιοθήκες κλπ. — αλλά [ποτέ να μην την εκτελείτε σε αρχεία που δεν εμπιστεύεστε](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/).\n\n- Να γνωρίζετε πώς να συνδέεστε σε μία διεργασία που εκτελείται με `gdb` και να παίρνετε τα ίχνη της στοίβας της.\n\n- Χρησιμοποιήστε τον κατάλογο `/proc`. Είναι εκπληκτικά χρήσιμος ορισμένες φορές, όταν αποσφαλματώνετε ζωντανά προβλήματα. Παραδείγματα: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (όπου `xxx` είναι το id της διεργασίας ή pid).\n\n- Όταν αποσφαλματώνετε κάτι που ήταν λάθος στο παρελθόν, η [`sar`](http://sebastien.godard.pagesperso-orange.fr/) μπορεί να είναι πολύ χρήσιμη. Δείχνει ιστορικά στατιστικά για επεξεργαστή, μνήμη, δίκτυο κλπ.\n\n- Για πιο εις βάθος ανάλυση συστήματος και απόδοσης, δείτε τις `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_%28Linux%29) και [`sysdig`](https://github.com/draios/sysdig).\n\n- Ελέγξτε ποιο είναι το λειτουργικό σύστημά σας με `uname` ή `uname -a` (γενικές πληροφορίες Unix/πυρήνα) ή `lsb_release -a` (πληροφορίες διανομής Linux).\n\n- Χρησιμοποιήστε την `dmesg`, όποτε κάτι συμπεριφέρεται πραγματικά παράξενα (μπορεί να έχει να κάνει με υλικό ή με οδηγούς).\n\n- Αν διαγράψετε ένα αρχείο και δεν απελευθερωθεί ο σύμφωνα με την `du` αναμενομένος χώρος στον δίσκο, ελέξτε αν το αρχείο χρησιμοποιείται από κάποια διεργασία:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## Εντολές σε μία γραμμή\n\nΜερικά παραδείγματα σωλήνωσης εντολών:\n\n- Είναι εξαιρετικά βοηθητικό ορισμένες φορές το γεγονός ότι μπορείτε να εφαρμόσετε τις πράξεις της τομής, της ένωσης και της διαφοράς σε αρχεία κειμένου με τις εντολές `sort`/`comm`. Έστω ότι `a` και `b` είναι ταξινομημένα αρχεία κειμένου. Αυτό είναι γρήγορο και δουλεύει σε αρχεία οποιουδήποτε μεγέθους έως πολλά gigabytes. (H εντολή `sort` δεν περιορίζεται από τη μνήμη, αν και ίσως χρειαστεί να χρησιμοποιήσετε την επιλογή `-T`, αν ο `/tmp` βρίσκεται σε μικρή κατάτμηση (partition). Επίσης, δείτε την παρατήρηση παραπάνω για τη μεταβλητή `LC_ALL` και την επιλογή `-u` της εντολής `sort` (παραλείπεται παρακάτω ώστε να είναι πιο ξεκάθαρο το παράδειγμα).\n```sh\n      sort -mu a b > c # το c είναι a ένωση b\n      comm -12 a b > c # c είναι a τομή b\n      comm -23 a b > c # το c είναι η διαφορά του a από το b\n```\n\n- Χρησιμοποιήστε `grep . *` για να εξετάσετε γρήγορα το περιεχόμενο όλων των αρχείων ενός καταλόγου (έτσι κάθε γραμμή αρχείου εμφανίζεται σε ζεύγος με το όνομα του αρχείου), ή `head -100 *` (έτσι κάθε αρχείο έχει μια κεφαλίδα). Αυτό μπορεί να είναι χρήσιμο για καταλόγους γεμάτους με αρχεία ρυθμίσεων όπως αυτά στους καταλόγους `/sys`, `/proc`, `/etc`.\n\n\n- Η άθροιση όλων των αριθμών στην τρίτη στήλη ενός αρχείου κειμένου (αυτό είναι μάλλον 3X γρηγορότερο και απαιτεί 3X λιγότερο κώδικα από την αντίστοιχη υλοποίηση σε Python):\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Για να δείτε μεγέθη/ημερομηνίες σε ένα δέντρο αρχείων, η παρακάτω είναι σα μια αναδρομική `ls -l`, αλλά είναι πιο ευανάγνωστη από `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Έστω ότι έχετε ένα αρχείο κειμένου, όπως το αρχείο καταγραφής (log)/υπ ενός web server και μία συγκεκριμένη τιμή που εμφανίζεται σε μερικές γραμμές, όπως μία παράμετρος `acct_id` που εμφανίζεται στο URL. Αν θέλετε μια καταμέτρηση του πόσα αιτήματα έγιναν για κάθε `acct_id`:\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Για να παρακολουθείτε συνεχώς αλλαγές, χρησιμοποιήστε `watch`, π.χ. ελέγξτε αλλαγές σε αρχεία ενός καταλόγου με `watch -d -n 2 'ls -rtlh | tail'` ή σε ρυθμίσεις δικτύου ενώ επιδιορθώνετε τις ρυθμίσεις wifi με `watch -d -n 2 ifconfig`.\n\n- Εκτελέστε αυτή τη μέθοδο για να πάρετε μια τυχαία συμβουλή από αυτό το έγγραφο (αναλύει Markdown και εξάγει ένα στοιχείο):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          sed '/cowsay[.]png/d' |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80 | iconv -t US\n      }\n```\n\n## Ασυνήθιστες αλλά χρήσιμες\n\n- `expr`: εκτελέστε αριθμητικές και λογικές πράξεις ή εφαρμόζετε κανονικές εκφράσεις\n\n- `m4`: απλός μακροεπεξεργαστής\n\n- `yes`: τυπώστε ένα αλφαριθμητικό πολλές φορές\n\n- `cal`: όμορφο ημερολόγιο\n\n- `env`: εκτελέστε μία εντολή (χρήσιμο σε σενάρια)\n\n- `printenv`: τυπώστε μεταβλητές περιβάλλοντος (χρήσιμο στην αποσφαλμάτωση και σε σενάρια)\n\n- `look`: βρείτε αγγλικές λέξεις (ή γραμμές σε ένα αρχείο) αρχίζοντας με ένα αλφαριθμητικό\n\n- `cut`, `paste` και `join`: επεξεργασία δεδομένων\n\n- `fmt`: μορφοποίηση παραγράφων\n\n- `pr`: μορφοποίηση κειμένου σε σελίδες/στήλες\n\n- `fold`: τύλιγμα γραμμών κειμένου\n\n- `column`: μορφοποίηση πεδίων κειμένου σε στοιχισμένες, σταθερού πλάτους στήλες ή πίνακες\n\n- `tree`: εμφανίστε καταλόγους και υποκαταλόγους σε φωλιασμένο δένδρο, όπως η `ls` αλλά αναδρομική\n\n- `stat`: πληροφορίες αρχείου\n\n- `time`: εκτελέστε και χρονομετρήστε μία εντολή\n\n- `timeout`: εκτελέστε μια εντολή για συγκεκριμένο χρονικό διάστημα και σταμάτησε τη διεργασία, όταν ολοκληρωθεί το χρονικό διάστημα αυτό\n\n- `lockfile`: δημιουργήστε αρχεία σημαφόρους που μπορούν να διαγραφούν μόνο με `rm -f`\n\n- `logrotate`: περιστρέψτε, συμπιέστε και στείλτε με ηλ-ταχ αρχεία καταγραφής (logs).\n\n- `watch`: εκτελέστε μία εντολή επαναλαμβανόμενα εμφανίζοντας αποτελέσματα ή/και επισημαίνοντας αλλαγές\n\n- [`when-changed`](https://github.com/joh/when-changed): εκτελεί όποια εντολή ορίσετε, όποτε βλέπει ότι ένα αρχείο άλλαξε. Δείτε ακόμη τις `inotifywait` και `entr`.\n\n- `tac`: τυπώστε αρχεία ανεστραμμένα\n\n- `comm`: συγκρίνετε ταξινομημένα αρχεία γραμμή προς γραμμή\n\n- `strings`: εξάγετε κείμενο από δυαδικά αρχεία\n\n- `tr`: μετάφραση χαρακτήρων ή επεξεργασία\n\n- `iconv` ή `uconv`: μετατροπή κωδικοποίησης κειμένου\n\n- `split` και `csplit`: χώρισμα αρχείων\n\n- `sponge`: διαβάστε όλη την είσοδο πριν γράψετε σε αυτή, χρήσιμο όταν πρόκειται να διαβάσετε από ένα αρχείο και μετά να γράψετε σε αυτό, π.χ., `grep -v something some-file | sponge some-file`\n\n- `units`: μετατροπές μονάδων και υπολογισμοί· κάνει ό,τι μετατροπές μπορείτε να σκεφτείτε (δείτε επίσης `/usr/share/units/definitions.units`)\n\n- `apg`: δημιουργεί τυχαίους κωδικούς\n\n- `xz`: υψηλής αναλογίας συμπίεση αρχείων\n\n- `ldd`: πληροφορίες για δυναμικές βιβλιοθήκες\n\n- `nm`: σύμβολα από αντικειμενικά αρχεία\n\n- `ab` ή [`wrk`](https://github.com/wg/wrk): συγκριτική αξιολόγηση web servers\n\n- `strace`: αποσφαλμάτωση κλήσης συστήματος\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): καλύτερο εργαλείο traceroute για αποσφαλμάτωση δικτύου\n\n- `cssh`: visual concurrent shell\n\n- `rsync`: συγχρονισμός αρχείων και καταλόγων μέσω SSH ή σε τοπικό σύστημα αρχείων\n\n- [`wireshark`](https://wireshark.org/) και [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): συλλογή πακέτων και αποσφαλμάτωση δικτύου\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep για το επίπεδο δικτύου\n\n- `host` και `dig`: αναζητήσεις DNS\n\n- `lsof`: εμφανίστε περιγραφείς αρχείου και πληροφορίες δικτυακών συνδέσεων\n\n- `dstat`: χρήσιμα στατιστικά συστήματος\n\n- [`glances`](https://github.com/nicolargo/glances): υψηλού επιπέδου επισκόπηση πολλαπλών υποσυστημάτων\n\n- `iostat`: στατιστικά χρήσης δίσκου\n\n- `mpstat`: στατιστικά χρήσης επεξεργαστή\n\n- `vmstat`: στατιστικά χρήσης μνήμης\n\n- `htop`: βελτιωμένη έκδοση της top\n\n- `last`: ιστορικό σύνδεσης (login)\n\n- `w`: ποιος συνδέθηκε\n\n- `id`:  πληροφορίες ταυτότητας χρήστη/ομάδας\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): ιστορικά στατιστικά συστήματος\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ή [`nethogs`](https://github.com/raboof/nethogs): χρήση δικτύου ανά δικτυακή σύνδεση ή διεργασία\n\n- `ss`: στατιστικά ανά δικτυακή σύνδεση\n\n- `dmesg`:  μηνύματα για σφάλματα κατά την εκκίνηση ή σφάλματα συστήματος\n\n- `sysctl`: δείτε και ρυθμίστε τις παραμέτρους του πυρήνα Linux, ενώ εκτελείται\n\n- `hdparm`: διαχείριση/απόδοση δίσκου SATA/ATA\n\n- `lsblk`: εμφανίστε σε λίστα συσκευές αποθήκευσης: μία προβολή σε δέντρο των δίσκων σας και των διαμερισμάτων τους\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: πληροφορίες υλικού, συμπεριλαμβανομένων επεξεργαστή, BIOS, RAID, γραφικών, συσκευών κλπ.\n\n- `lsmod` και `modinfo`: εμφανίστε σε λίστα και προβάλλετε λεπτομέρειες για λειτουργικές μονάδες του πυρήνα\n\n- `fortune`, `ddate`και `sl`: ε, λοιπόν, εξαρτάται από το αν θεωρείτε τα τρένα με ατμομηχανή και τις ρήσεις του Zippy «χρήσιμα»\n\n## Μόνο για OS X\n\nΤα παρακάτω σημεία σχετίζονται *μόνο* με OS X.\n\n- Διαχείριση πακέτων λογισμικού με `brew` (Homebrew) και/ή `port` (MacPorts). Μπορούν να χρησιμοποιηθούν για εγκατάσταση σε OS X πολλών από τις παραπάνω εντολές.\n\n- Αντιγράψτε την έξοδο οποιασδήποτε εντολής σε μια desktop εφαρμογή με `pbcopy` και επικολλήστε στην είσοδο με `pbpaste`.\n\n- Για να ενεργοποιήσετε το πλήκτρο Option σε τερματικό OS X ως πλήκτρο alt (όπως χρησιμοποιείται στις παραπάνω εντολές όπως **alt-b**, **alt-f** κλπ.), ανοίξτε Προτιμήσεις -> Προφίλ -> Πληκτρολόγιο και επιλέξτε «Χρήση Option ως μετα-πλήκτρου».\n\n- Για να ανοίξετε ένα αρχείο με μια desktop εφαρμογή χρησιμοποιήστε `open` ή `open -a /Applications/Whatever.app`.\n\n- Spotlight: Αναζητήστε αρχεία με `mdfind` και εμφανίστε σε λίστα μεταδεδομένα (όπως τις πληροφορίες EXIF μιας φωτογραφίας) με `mdls`.\n\n- Έχετε υπόψη σας ότι το OS X βασίζεται σε BSD Unix και πολλές εντολές (για παράδειγμα `ps`, `ls`, `tail`, `awk`, `sed`) έχουν μικρές διαφορές από το Linux, που έχει ευρέως επηρεαστεί από το System V-style Unix και τα εργαλεία GNU. Συνήθως μπορείτε να βρίσκετε τη διαφορά επισημαίνοντας ότι μια man σελίδα έχει την επικεφαλίδα «Εγχειρίδιο γενικών εντολών BSD». Σε ορισμένες περιπτώσεις μπορούν επίσης να εγκατασταθούν εκδόσεις GNU, (όπως οι `gawk` και `gsed` για τις GNU awk και sed). Αν γράφετε σενάρια Bash που στοχεύετε να εκτελούνται σε διάφορες πλατφόρμες, αποφύγετε τέτοιες εντολές (για παράδειγμα, έχετε υπόψη σας την Python ή `perl`) ή ελέγξτε προσεχτικά.\n\n- Για να πάρετε πληροφορίες για την έκδοση OS X χρησιμοποιήστε `sw_vers`.\n\n## Μόνο για Windows\n\nΤα παρακάτω σημεία σχετίζονται *μόνο* με Windows.\n\n### Πρόσβαση στα εργαλεία του Unix από Windows\n\n- Αποκτήστε πρόσβαση στη δύναμη του φλοιού του Unix σε περιβάλλον Microsoft Windows εγκαθιστώντας το [Cygwin](https://cygwin.com/). Τα περισσότερα από αυτά που περιγράφονται σε αυτό το έγγραφο θα λειτουργήσουν μεμιάς.\n\n- Σε Windows 10, μπορείτε να χρησιμοποιήσετε το [Bash σε Ubuntu για Windows](https://msdn.microsoft.com/commandline/wsl/about), το οποίο παρέχει ένα περιβάλλον παρόμοιο με του Bash με εργαλεία γραμμής εντολών Unix. Έχει το πλεονέκτημα ότι επιτρέπει σε προγράμματα Linux να εκτελεστούν σε Windows. Από την άλλη πλευρά, σε αντίθεση με το περιβάλλον Cygwin, δεν επιτρέπει την εκτέλεση προγραμμάτων Windows από τη γραμμή εντολών του Bash.\n\n- Αν σας ενδιαφέρει κυρίως η χρήση των εργαλείων ανάπτυξης GNU (όπως ο μεταγλωττιστής GCC) σε Windows, σκεφτείτε τη χρήση των [MinGW](http://www.mingw.org/) και [MSYS](http://www.mingw.org/wiki/msys), τα οποία παρέχουν εργαλεία όπως bash, gawk, make και grep. Το MSYS δεν υποστηρίζει όμως όλες τις δυνατότητες του Cygwin. Το MinGW είναι κυρίως χρήσιμο για να δημιουργήσετε εγγενείς εκδόσεις Windows εργαλείων του Unix.\n\n- Μια άλλη επιλογή για να έχετε εντολές Unix κάτω από Windows είναι το σύστημα [Cash](https://github.com/dthree/cash). Αυτό όμως υποστηρίζει πολύ λίγες εντολές και επιλογές του Unix.\n\n### Χρήσιμα εργαλεία της γραμμής εντολών Windows\n\n- Μπορείτε να εκτελέσετε και να γράψετε scripts για τις περισσότερες εργασίες διαχείρισης συστήματος των Windows από τη γραμμή εντολών μαθαίνοντας και χρησιμοποιώντας την `wmic`.\n\n- Χρήσιμα εγγενή εργαλεία της γραμμής εντολών των Windows για διαχείριση και αποσφαλμάτωση του δικτύου είναι τα `ping`,` ipconfig`, `traceroute` και `netstat`.\n\n- Πολλές [χρήσιμες λειτουργίες των Windows] (http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) μπορούν να εκτελεστούν μέσω της εντολής `Rundll32`.\n\n### Συμβουλές για αποδοτική χρήση του Cygwin\n\n- Εγκαταστήστε πρόσθετα προγράμματα Unix με τον διαχειριστή πακέτων του Cygwin.\n\n- Χρησιμοποιήστε το `mintty` ως το παράθυρο γραμμής εντολών σας.\n\n- Αποκτήστε πρόσβαση στο πρόχειρο (clipboard) των Windows μέσω του `/dev/clipboard`.\n\n- Εκτελέστε τη `cygstart` για να ανοίξετε ένα οποιοδήποτε αρχείο με την εφαρμογή που είναι ορισμένη να χρησιμοποιείται για το άνοιγμά του.\n\n- Αποκτήστε πρόσβαση στο μητρώο των Windows με `regtool`.\n\n- Σημειώστε ότι η διαδρομή `C:\\` των Windows γίνεται `/cygdrive/c` στο Cygwin και ότι το `/` του  Cygwin εμφανίζεται ως `C:\\cygwin` στα Windows. Μετατρέψετε διαδρομές αρχείων από τη μορφή που χρησιμοποιεί το Cygwin σε αυτή που χρησιμοποιούν τα Windows και αντίστροφα με `cygpath`. Αυτό είναι πολύ χρήσιμο σε σενάρια που καλούν προγράμματα Windows.\n\n- Μπορείτε να εκτελέσετε και να γράψετε σενάρια για τις περισσότερες εργασίες διαχείρισης συστήματος των Windows από τη γραμμή εντολών μαθαίνοντας και χρησιμοποιώντας την `wmic`.\n\n- Μία άλλη επιλογή για να έχετε την εμφάνιση και την εμπειρία χρήσης Unix σε Windows είναι το [Cash](https://github.com/dthree/cash). Σημειώστε ότι μόνο πολύ λίγες εντολές Unix και επιλογές γραμμής εντολών είναι διαθέσιμες σε αυτό το περιβάλλον.\n\n## Περισσότερες πηγές\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Μία προσεγμένη λίστα με εργαλεία και πηγές σχετικές με τον φλοιό .\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Ένας περισσότερο εις βάθος οδηγός της γραμμής εντολών του OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) για να γράφετε καλύτερα σενάρια φλοιού.\n- [shellcheck](https://github.com/koalaman/shellcheck): Ένα εργαλείο στατικής ανάλυσης για σενάρια για φλοιό. Στην ουσία, lint για bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Οι δυστυχώς περίπλοκες μικρολεπτομέρειες του πώς να διαχειριστεί κανείς σωστά ονόματα αρχείων σε σενάρια για φλοιό.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Περισσότερες εντολές και εργαλεία χρήσιμα για την άσκηση της επιστήμης δεδομένων, από το βιβλίο με το ίδιο όνομα.\n\n## Αποποίηση ευθύνης\n\nΜε την εξαίρεση πολύ μικρών εργασιών, ο κώδικας πρέπει να γράφεται ώστε να μπορούν οι άλλοι να τον διαβάζουν. Η δύναμη συνεπάγεται ευθύνη. Το γεγονός ότι *μπορείτε* να κάνετε κάτι με Bash δε σημαίνει απαραίτητα ότι θα έπρεπε! ;)\n\n## Άδεια χρήσης\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nΗ εργασία αυτή έχει αδειοδοτηθεί με [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)."
        },
        {
          "name": "README-es.md",
          "type": "blob",
          "size": 37.13,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# El Arte del Terminal\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [Meta](#meta)\n- [Fundamentos](#fundamentos)\n- [Uso diario](#de-uso-diario)\n- [Procesamiento archivos y datos](#procesamiento-de-archivos-y-datos)\n- [Depuración del sistema](#depuración-del-sistema)\n- [One-liners](#one-liners)\n- [Obscuro pero útil](#osbcuro-pero-útil)\n- [Solo para OS X](#solo-para-os-x)\n- [Solo para Windows](#solo-windows)\n- [Más recursos](#más-recursos)\n- [Advertencia](#advertencia)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nLa fluidez en el terminal es una destreza a menudo abandonada y considerada arcaica, pero ésta mejora tu flexibilidad y productividad como ingeniero de formas obvias y sutiles. Esta es una selección de notas y consejos para usar el terminal que encontramos útiles al trabajar en Linux. Algunos consejos son elementales y algunos bastante específicos, sofisticados u oscuros. Esta página no es larga, pero si puedes usar y recordar todos los puntos aquí mostrados, sabrás un montón.\n\nEste trabajo es el resultado de [muchos autores y traductores](AUTHORS.md).\nParte de esta:\n[originalmente](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[apareció](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nen [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\npero se ha movido desde entonces a Github, donde personas más talentosas que el autor han hecho numerosas mejoras.\n[**Por favor contribuye**](/CONTRIBUTING.md) Si ves un error o algo que podría ser mejor!\n\n\n## Meta\n\nAlcance:\n\n- Esta guía es tanto para principiantes como para experimentados. Los objetivos son *diversidad* (todo importa), *especificidad* (dar ejemplos concretos del caso más común), y *concisión* (evitar cosas que no son esenciales o insignificantes que puedas buscar fácilmente en otro lugar). Cada consejo es esencial en alguna situación o significativamente puede ahorrar tiempo comparado con otras alternativas.\n- Está escrita para Linux, con excepción de la secciones \"[Solo para OS X](#os-x-only)\" y \"[Solo para Windows](#solo-windows)\". Muchos de los otros puntos aplican o pueden ser instalados en otros Unices o OS X (o incluso Cygwin).\n- Se centra en Bash interactivo, aunque muchos de los consejos aplican para otros shells y al Bash scripting por lo general.\n- Incluye tanto comandos \"estándar\" Unix así como los que requieren instalaciones de paquetes especiales -- siempre que sean lo suficientemente importantes para merecer su inclusión.\n\nNotas:\n\n- Para mantener esto en una página, el contenido está incluido implícitamente por referencia. Eres lo suficientemente inteligente para consultar más detalles en otros lugares buscando en Google una vez conoces la idea o el comando. Usa `apt-get`, `yum`, `dnf`, `pacman`, `pip` o `brew` (según proceda) para instalar los nuevos programas.\n- Usa [Explainshell](http://explainshell.com/) para obtener detalles de ayuda sobre que hacen los comandos, las opciones, las pipes, etc.\n\n\n## Fundamentos\n\n- Aprende conocimientos básicos de Bash, de hecho, escribe `man bash` y al menos échale un vistazo a todo el asunto. Es bastante fácil de seguir y no es tan largo. Alternar entre shells puede ser agradable, pero Bash es poderoso y siempre está disponible (conocer *solo* zsh, fish, etc., aunque resulte tentador en tu propia laptop, Te restringe en muchas situaciones, tales como el uso de servidores existentes).\n\n- Aprende bien al menos un editor de texto, idealmente Vim (`vi`), como no hay realmente una competencia para la edición aleatoria en un terminal (incluso si usa Emacs, un gran IDE, o un editor alternativo (hipster) moderno la mayor parte del tiempo).\n\n- Conoce como leer la documentación con `man` (Para curiosos, `man man` lista las secciones enumeradas, ej. 1 es comandos \"regulares\", 5 son archivos/convenciones, y 8 para administración). Encuentra las páginas de man `apropos`. Sepa que alguno de los comandos no son ejecutables, pero son Bash builtins, y que puedes obtener ayuda sobre ellos con `help` y `help -d`.\n\n- Aprende sobre redirección de salida `>`, entrada `<` y pipes utilizando `|`. Conozca que `>` sobrescribe el archivo de salida y `>>` añade. Aprende sobre stdout y stderr.\n\n- Aprende sobre expansión de archivos glob con `*` (y tal vez `?` y `[`...`]`) y quoting y la diferencia entre comillas dobles `\"` y simples `'`. (Ver más en expansión de variables más abajo.)\n\n- Familiarízate con la administración de trabajo en Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Conoce `ssh` y lo básico de autenticación sin contraseña, vía `ssh-agent`, `ssh-add`, etc.\n\n- Administración de archivos básica: `ls` y `ls -l` (en particular, aprende el significado de cada columna en `ls -l`), `less`, `head`, `tail` y `tail -f` (o incluso mejor, `less +F`), `ln` y `ln -s` (aprende las diferencias y ventajas entre enlaces hard y soft), `chown`, `chmod`, `du` (para un resumen rápido del uso del disco: `du -hs *`). Para administración de archivos de sistema, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Aprenda que un inode es `ls -i` or `df -i`).\n\n- Administración básica de redes: `ip` o `ifconfig`, `dig`.\n\n- Aprende y usa un sistema de control de versiones, por ejemplo `git`.\n\n- Conoce bien las expresiones regulares y varias opciones (flags) para `grep`/`egrep`. Las opciones `-i`, `-o`, `-v`, `-A`, `-B` y `-C` son dignas de ser recordadas.\n\n- Aprende el uso de `apt-get`, `yum`, `dnf` o `pacman` (dependiendo de la distribución \"distro\") para buscar e instalar paquetes. Y asegúrate que tienes `pip` para instalar la herramienta de línea de comando basada en Python (un poco más abajo esta explicado como instalar vía `pip`).\n\n\n## De uso diario\n\n- En Bash, se usa **Tab** para completar los argumentos o lista todos los comandos disponibles y **ctrl-r** para buscar a través del historial de comandos (despues de presionar, escribe la búsqueda, presiona **ctrl-r** repetidamente para hacer un ciclo a través de más coincidencias, presiona **Enter** para ejecurar el comando encontrado, o presiona la flecha derecha para poner el resultado en la línea actual y editar).\n\n- En Bash, se usa **ctrl-w** para borrar la última palabra, y **ctrl-u** para borrar todo hacia atrás hasta el inicio de la línea. Se usa **alt-b** y **alt-f** para moverse entre palabras, **ctrl-a** para mover el cursor al principio de la línea,  **ctrl-e** para mover el cursor al final de la línea,  **ctrl-k** para eliminar hasta el final de la línea, **ctrl-l** para limpiar la pantalla. Ver `man readline` para todos los atajos de teclado por defecto en Bash. Son una gran cantidad. Por ejemplo **alt-.** realiza un ciclo a través de los comandos previos, y **alt-*** expande un glob.\n\n- Alternativamente, si amas los atajos de teclado vi-style, usa `set -o vi`. (y `set -o emacs` para regresar a la anterior).\n\n- Para editar largos comandos, después de configurar to editor (por ejemplo `export EDITOR=vim`), **ctrl-x** **ctrl-e** se abrirá el comando actual en un editor para editar multiples líneas. O en estilo vi, **escape-v**.\n\n- Para ver los últimos comandos, `history`. También existen abreviaciones, tales como, `!$` (último argumento) y `!!` último comando, aunque son fácilmente remplazados con **ctrl-r** y **alt-.**.\n\n- Para volver al directorio principal con `cd`. Accede a los archivos relativos a tu directorio principal con el prefijo `~` (ej. `~/.bashrc`). En scripts `h`refierete al directorio principal con `$HOME`.\n\n- Para volver al directorio de trabajo previo: `cd -`.\n\n- Si estás a medio camino al escribir un comando pero cambias de opinión, presiona **alt-#** para agregar un `#` al principio y lo agrega como comentario (o usa **ctrl-a**, **#**, **enter**). Luego puedes regresar a este vía comando `history`.\n\n- Usa `xargs` (o `parallel`). Es muy poderoso. Ten en cuenta que puedes controlar cuántos elementos son ejecutados por línea (`-L`), así como el paralelismo (`-P`). Si no estas seguro de que este haga la cosa correcta, usa `xargs echo` primero. También, `-I{}` es útil. Ejemplos:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` es útil para mostrar el árbol de procesos.\n\n- Usa `pgrep` y `pkill` para encontrar o señalar procesos por su nombre (`-f` es de mucha ayuda).\n\n- Conoce las señales que puedes enviar a los procesos. Por ejemplo, para suspender un proceso usa `kill -STOP [pid]`. Con `man 7 signal` puedes ver la lista completa\n\n- Usa `nohup` o `disown` si quieres que un proceso de fondo se mantenga corriendo para siempre.\n\n- Verifica que procesos están escuchando vía `netstat -lntp` o `ss -plat` (para TCP; agrega `-u` para UDP).\n\n- Consulta también `lsof` para abrir sockets y archivos.\n\n- Consulta `uptime` o `w` para conocer cuánto tiempo el sistema ha estado corriendo.\n\n- Usa `alias` para crear atajos para comandos comúnmente usados. Por ejemplo, `alias ll=\"las -latr\"` crea el alias `ll`\n\n- En Bash scripts, usa `set -x` (o su variantes `set -v`, que registra las entradas sin procesar, incluyendo variables sin expander y comantarios) para depurar la salida. Usa el modo estricto al menos que tengas una buena razón para no hacerlo: Usa `set -e` para abortar en caso de errores (códigos de salida distintos a cero). Usa `set -u` para detectar uso de variables no definidas. Considera `set -o pipefail` también, para los errores con pipes, también (estudiar mas sobre este como un tema delicado). Para scripts más complejos, usa también `trap`. en EXIT o ERR. Un hábito útil es para comenzar un script como este, el cual detectará y abortará con errores comunes e imprimirá un mensaje:\n```bash\n    set -euo pipefail\n    trap \"echo 'error: Falló del Script: ver arriba comando que falló'\" ERR\n```\n\n- En Bash scripts, subshells (escritos con paréntesis) son maneras convenientes para agrupar los comandos. Un ejemplo común es temporalmente moverse hacia un directorio de trabajo diferente, Ej.\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- En Bash, considera que hay muchas formas de expansión de variables. Verificar la existencia de una variable: `${name:?error message}`. Por ejemplo, si un script Bash requiere un único argumento, solo escribe `input_file=${1:?usage: $0 input_file}`. Expansión aritmética: `i=$(( (i + 1) % 5 ))`. Secuencias: `{1..10}`. Reducción de cadenas de texto: `${var%suffix}` y `${var#prefix}`. Por ejemplo si `var=foo.pdf`, entonces `echo ${var%.pdf}.txt` imprime `foo.txt`.\n\n- Utilizando la expansión de corchetes `{`...`}` puede reducir el tener que retipear un texto similar y automatizar conbinaciones de elementos. Esto es útil en ejemplos como `mv foo.{txt,pdf} some-dir` (el cual mueve ambos archivos), `cp somefile{,.bak}` (el cual se expandirá a `cp somefile somefile.bak`) o `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (el cual se expandirá en todas las posibles conbinaciones y creará un árbol de directorios).\n\n- La salida de un comando puede ser tratado como un archivo por medio de `<(some command)`. Por ejemplo, comparar el `/etc/hosts` local con uno remoto:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Conocer acerca de \"here documents\" en Bash, como también de `cat <<EOF ...`.\n\n- En Bash, redirecciona ambas la salida estándar y el error estándar, mediante: `some-command >logfile 2>&1` o `some-command &>logfile`. Frecuentemente, para garantizar que un comando no haya dejado abierto un archivo para controlar la entrada estándar vinculada al terminal en el que te encuentras y también como buena práctica puedes agregar `</dev/null`.\n\n- Usa `man ascii` para una buena tabla ASCII con valores hexadecimal y decimales. Para información de codificación general, `man unicode`, `man utf-8`, y `man latin1` son de utilidad.\n\n- Usa `screen` o [`tmux`](https://tmux.github.io/) para multiplexar la pantalla, especialmente útil en sesiones ssh remotas y para desconectar y reconectar a una sesión. `byobu` puede mejorar la pantalla o tmux proporcionando mayor información y gestión ás sencilla. Una alternativa más minimalista para persistencia de la sesión solo sería `dtach`.\n\n- En ssh, saber cómo hacer un port tunnel con `-L` o `-D` (y de vez en cuando `-R`) es útil, Ej. para acceder a sitios web desde un servidor remoto.\n\n- Puede ser útil hacer algunas optimizaciones a su configuración ssh; por ejemplo, `~/.ssh/config`, contiene la configuración para evitar desconexiones en ciertos entornos de red, utiliza compresión (cual es útil con scp sobre conexiones con un bajo ancho de banda), y la multiplexión de canales para el mismo servidor con un archivo de control local:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Algunas otras opciones relevantes a ssh son sensibles en cuanto a seguridad y deben ser usadas con cuidado, Ej. por subnet, host o en redes confiables: `StrictHostKeyChecking=no`, `ForwardAgent=yes`.\n\n- Considera [`mosh`](https://mosh.org/) una alternativa para ssh que utiliza UDP, evitando conexiones caidas y agregando conveniencia en el camino. (require configuración del lado del servidor).\n\n- Para obtener permiso sobre un archivo en forma octal, el cual es útil para la configuración del sistema pero no está disponible con `ls` y fácil de estropear, usa algo como\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Para selección interactiva de valores desde la salida de otro comando, use [`percol`](https://github.com/mooz/percol) o [`fzf`](https://github.com/junegunn/fzf).\n\n- Para la interacción con archivos basados en la salida de otro comando (como `git`), use `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Para un servidor web sencillo para todos los archivos en el directorio actual (y subdirectorios), disponible para cualquiera en tu red, usa:\n`python -m SimpleHTTPServer 7777` (para el puerto 7777 y Python 2) y `python -m http.server 7777` (para 7777 y Python 3).\n\n- Para ejecutar un comando con privilegios, usando `sudo` (para root) o `sudo -u` (para otro usuario). Usa `su` o `sudo bash` para realmente ejecutar un shell como este usuario. Usa `su -` para simular un login fresco como root u otro usuario.\n\n\n## Procesamiento de archivos y datos\n\n- Para localizar un archivo por nombre en el directorio actual, `find . -iname '*algo*'` (o similar). Para encontrar un archivo en cualquier lado por nombre, usa `locate something` (pero tenga en mente que `updatedb` quizás no haya indexado recientemente los archivos creados).\n\n- Para búsqueda general a través de archivos fuente o de datos (más avanzado que `grep -r`), usa [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Para convertir HTML a texto: `lynx -dump -stdin`\n\n- Para Markdown, HTML, y todos los tipos de conversión de documentos, prueba [`pandoc`](http://pandoc.org/).\n\n- Si debe manipular XML, `xmlstarlet` es viejo pero bueno.\n\n- Para JSON usa [`jq`](http://stedolan.github.io/jq/).\n\n- Para YAML, usa [`shyaml`](https://github.com/0k/shyaml).\n\n- Para archivos Excel o CSV, [csvkit](https://github.com/onyxfish/csvkit) proporciona `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.\n\n- Para Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) es conveniente y [`s4cmd`](https://github.com/bloomreach/s4cmd) es el mas rápido. [`aws`](https://github.com/aws/aws-cli) de Amazon y el mejorado [`saws`](https://github.com/donnemartin/saws) son esenciales para otras tareas relacionadas al AWS.\n\n- Conoce acerca de `sort` y `uniq`, incluyendo las opciones de uniq `-u` y `-d` -- ver [one-liners](https://github.com/jlevy/the-art-of-command-line/blob/master/README-es.md#one-liners) más abajo. Ver también `comm`\n\n- Conoce acerca de `cut`, `paste` y `join` para manipular archivos de texto. Muchas personas usan `cut` pero se olvidan acerca de `join`.\n\n- Conoce acerca de `wc` para contar saltos de línea (`-l`), caracteres (`-m`), palabras (`-w`) y bytes (`-c`).\n\n- Conoce acerca de `tee` para copiar desde el stdin hacia un archivo y también hacia el stdout, al igual que en `ls -al | tee file.txt`.\n\n- Conoce que la localización afecta muchas herramientas de línea de comando en forma delicada, incluyendo el ordenamiento (compaginación) y rendimiento. La mayoría de las instalaciones de Linux configuran `LANG` u otras variables de localización para la configuración local como US English. Pero ten en mente que el ordenamiento puede cambiar si cambia la localización. Y también las rutinas i18n pueden hacer que `sort` u otros comandos se ejecuten más lentamente. En algunas situaciones (tales como la realización de operaciones u operaciones singulares descritas más abajo) puedes ignorar las rutinas i18n por completo y utilizar el sort tradicional basado en bytes, usando `export LC_ALL=C`.\n\n- Conoce los aspectos básicos de `awk` y `sed` para manejo de datos. Por ejemplo, sumar todos lo números en la tercera columna de un archivo de texto: `awk '{ x += $3 } END { print x }'`. Esto es probablemente 3 veces más rápido y 3 veces más corto que su equivalente en Python.\n\n- Para reemplazar todas las ocurrencias de un string en su lugar, en uno o más archivos:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Para renombrar multiples y/o buscar y remplazar dentro de archivos, intenta [`repren`](https://github.com/jlevy/repren). (En algunos casos el comando `rename` también permite multiples renombramientos, pero sea cuidadoso ya que esta funcionalidad no es igual en todas las distribuciones de Linux.)\n```sh\n      # Renombramiento completo de archivos, carpetas y contenidos foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recuperar archivos de respaldo cualquier.bak -> cualquier:\n      repren --renames --from '.*)\\.bak' --to '\\1' *.bak\n      # Igual que arriba, utilizando rename, si esta disponible:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Como dice la página de man, `rsync` es una muy rápida y extraordinariamente versatil herramienta de copiado. Esta se conoce por la sincronización entre máquinas pero es igualmente útil localmente. Esta también se encuentra entre las [formas más rápidas](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) para borrar un gran número de archivos:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Usa `shuf` para mezclar o seleccionar líneas aleatorias de un archivo.\n\n- Conoce las opciones de `sort`. Para números, usa `-n`, o `-h` para manipulación de números humanamente leíbles (Ej. desde `du -h`). Conoce el trabajo principal de (`-t` y `-k`). En particular, esta atento que lo necesitas  escribir`-k1,1` para ordenar por solo el primer campo; `-k1` significa ordenar de acuerdo a toda la línea. Orden estable (`sort -s`) puede ser útil. Por ejemplo, para organizar el primer por el campo 2, entonces secundariamente hacerlo por el campo 1, Puedes usar `sort -k1,1 | sort -s -k2,2`.\n\n- Si alguna vez necesitas escribir un tab literal en una línea de comandos en Bash (Ej. para el argumento -t de ordenar), presiona **ctrl-v** **[Tab]** o escribe `$'\\t'` (El último es mejor porque puedes copiarlo/pegarlo).\n\n- Las herramientas estándar para reparar el código fuente son `diff` y `patch`. Consulta también `diffstat` para resumen estadístico de una diff y `sdiff` para un diff puesto lado a lado. Considera `diff -r` trabaja con directorios por completo. Usa `diff -r tree1 tree2 | diffstat` para el resumen de cambios. Urilizá `vimdiff` para comparar y editar archivos.\n\n- Para archivos binarios, usa `hd`, `hexdeump` or `xxd` para volcados hexdecimales simples y `bvi` o `biew` para edición de binario.\n\n- También para archivos binarios, `strings` (además de `grep`, etc.) permite encontrar fragmentos de texto.\n\n- Para diffs binaria (compresión delta), usa `xdelta3`.\n\n- Para convertir la codificación del texto, probar `iconv`. O `uconv` para uso más avanzado; este soporta algunos elementos Unicode avanzados. Por ejemplo, este comando coloca en minúsculas y remueve todas los acentos (por su expansión y colocándolos):\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Para dividir archivos en múltiples partes, consulta `split` (para dividir por tamaño) y `csplit` (para dividir por un patrón).\n\n- Para manipular expresiones de fecha y tiempo, usa `dateadd`, `datediff`, `strptime` etc. de [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Usa `zless`, `zmore`, `zcat`, y `zgrep` para operar sobre archivos comprimidos.\n\n\n## Depuración del sistema\n\n- Para depuración web, `curl` y `curl -I` son prácticos, o como sus equivalentes `wget`, o el más moderno [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Para conocer el estado del cpu/disco, las clásicas herramientas son `top` (o mejor `htop`), `iostat`, y `iotop`. Usa `iostat -mxz 15` para CPU básicas y estadísticas detalladas y visión de rendimiento por partición del disco.\n\n- Para detalles de la conexión de red, usa `netstat` y `ss`.\n\n- Para una rápida visión general de que esta pasando en un sistema, `dstat` es especialmente útil. Para una visión general más amplia con detalles usa [`glances`](https://github.com/nicolargo/glances).\n\n- Para conocer el estado de la memoria, ejecuta y entiende la salida de `free` y `vmstat`. En particular, ten en cuenta que el valor \"cached\" es mantenido en memoria por el kernel de Linux como un archivo de cache, por lo que efectivamente cuenta como valor para \"free\".\n\n- El sistema de depuración de Java es harina de otro costal, pero un truco simple en las JSM de Oracle y otros consta en que puedes ejecutar `kill -3 <pid>` y una traza completa y un resumen del montículo \"heap summary\" (incluyendo del detalle de la colección de basura generacional, la cual puede ser altamente informativa) serán descargados al stderr/logs. Las herramientas `jps`, `jstat`, `jstack`, `jmap` del JDK son útiles. [SJK tools](https://github.com/aragozin/jvm-tools) son más avanzadas.\n\n- Usa [`mtr`](http://www.bitwizard.nl/mtr/) como un mejor traceroute para identificar los problemas en la red.\n\n- Para examinar por qué el disco está lleno, [`ncdu`](https://dev.yorhel.nl/ncdu) ahorra tiempo en comparación con los comandos usuales como `du -sh *`.\n\n- Para encontrar cual socket o proceso está utilizando el ancho de banda, prueba [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) o [`nethogs`](https://github.com/raboof/nethogs).\n\n- La herramienta `ab` (viene con Apache) es útil para una verificación rápida del rendimiento de un servidor web. Para pruebas de carga más complejas prueba `siege`.\n\n- Para una depuración mas seria de redes, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), o [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Conoce acerca de `strace` y `ltrace`. Estas puede ser de utilidad si un programa está fallando, suspendido, o colgado, y no sabe por qué, o si quieres tener una idea general del rendimiento. Considera la opción de elaboración de perfiles (`-c`), y la habilidad de adjuntar a un proceso en ejecución (`-p`).\n\n- Conoce acerca `ldd` para verificar librerías compartidas etc.\n\n- Conoce como conectarse a un proceso en ejecución con `gdb` y obtener su traza de pilas.\n\n- Usa `/proc`. Es extraordinariamente útil algunas veces cuando se depuran problemas en vivo. Ejemplos: `/proc/cpuinfo`, `/proc/xxx/cwd`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (donde `xxx` es el id o pid del proceso).\n\n- Cuando se depura porque algo salió mal en el pasado, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) puede ser muy útil. Este muestra la estadística histórica en CPU, memoria, red, etc.\n\n- Para sistemas y análisis de rendimiento de mayor profundidad, examina `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux)), y [`sysdig`](https://github.com/draios/sysdig).\n\n- Comprueba en que OS se encuentra con `uname` o `uname -a` (información general en Unix/kernel) o `lsb_release -a` (información en Linux distro).\n\n- Usa `dmesg` siempre que algo actúe raro (esto podría ser problemas con el hardware o driver).\n\n\n## One-liners\n\nAlgunos ejemplos de comandos reunidos:\n\n- Es notablemente útil en ocasiones que pueda realizar intersección, unión, y diferencia de conjuntos de archivos de texto vía `sort`/`uniq`. Suponga que `a` y `b` como archivos de texto que son únicos. Esto es rápido, y trabaja con archivos de tamaño arbitrario, hasta varios gigabytes. (Sort no está limitado por la memoria, aunque quizás necesite utilizar la opción `-T` si `/tmp` está en una pequeña partición de raíz.) Consulta también la nota acerca de `LC_ALL` y las opciones de `sort`, `-u` (dejado de lado para clarificar más abajo).\n```sh\n      cat a b | sort | uniq > c   # c es a unido con b\n      cat a b | sort | uniq -d > c   # c es a intersectado con b\n      cat a b b | sort | uniq -u > c   # c es el conjunto diferencia a - b\n```\n\n- Usa `grep . *` para rápidamente examinar el contenido de todos los archivos de un directorio (para que cada línea este emparejada con  con el nombre de archivo), o `head -100 *` (para que cada archivo tenga un encabezado). Esto puede se útil para directorios llenos con ajustes de configuración como aquellos en `/sys`, `/proc`, `/etc`.\n\n\n- Sumar todos los números en la tercera columna de un archivo de texto (esto es probablemente 3 veces más rápido y 3 veces menos código que el equivalente en Python):\n```sh\n      awk '{ x += $3 } END { print x }' miarchivo\n```\n\n- Consultar tamaños/fechas en un árbol de archivos, esto es como un `ls -l` recursivo pero es más fácil de leer que `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Digamos que tiene un archivo de texto, como un log de un servidor web, y un cierto valor comienza a aparecer en algunas líneas, tales como un parámetro `acct_id` que está presente en la URL. Si quieres un recuento de cuantas peticiones por cada `acct_id`:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Para monitorear continuamente los cambios, usa `watch`, Ej. verificar los cambios de archivos en un directorio con `watch -d -n 2 'ls -rt1h | tail'` o para configuraciones de red mientras solucionas problemas con la configuración wifi `watch -d -n 2 ifconfig`.\n\n- Ejecuta esta función para obtener un consejo aleatorio desde este documento (analiza el Markdown y extrae un elemento):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Obscuro, pero útil\n\n- `expr`: ejecuta operaciones aritméticas o booleanas o evalúa expresiones regulares\n\n- `m4`: procesador de macro sencillo\n\n- `yes`: imprime un string sin fin\n\n- `cal`: lindo calendario\n\n- `env`: ejecuta un comando (útil en scripts)\n\n- `printenv`: imprime las variables del entorno (útil en depuración y scripts)\n\n- `look`: buscar palabras en inglés (o líneas en un archivo) comenzando con un string\n\n- `cut`, `paste` y `join`: manipulación de datos\n\n- `fmt`: formatea los párrafos de texto\n\n- `pr`: formatea el texto en páginas/columnas\n\n- `fold`: ajusta de líneas de texto\n\n- `column`: formatea campos de texto alineados, en columnas de ancho fijo o tablas\n\n- `expand` y `unexpand`: conversión entre tabuladores y espacios\n\n- `nl`: agrega números de línea\n\n- `seq`: imprime números\n\n- `bc`: calculadora\n\n- `factor`: factorización de enteros\n\n- [`gpg`](https://gnupg.org/): encripta y firma archivos\n\n- `toe`: tabla de información de términos\n\n- `nc`: depuración de la red y transferencia de datos\n\n- `socat`: socket relay y redireccionador de puerto tcp (similar a `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): visualización del tráfico de red\n\n- `dd`: moviliza datos entre archivos o dispositivos\n\n- `file`: identifica el tipo de archivo\n\n- `tree`: muestra directorios y subdirectorios como un árbol anidado; parecido a `ls` pero recursivo\n\n- `stat`: información del archivo\n\n- `time`: ejecuta y calcula el tiempo de ejecución de un comando\n\n- `timeout`: ejecuta un comando especificando una cantidad de tiempo y deteniendo el proceso cuando la cantidad de tiempo especificado se completa.\n\n- `lockfile`: crea un archivo semáforo que puedes solo ser removido con `rm -f`\n\n- `logrotate`: rota, comprime y registra correos electrónicos.\n\n- `watch`: ejecuta un comando repetidamente, mostrando resultados y/o resaltando cambios\n\n- `tac`: imprime archivos en forma inversa\n\n- `shuf`: selección aleatoria de líneas de un archivo\n\n- `comm`: compara archivos ordenados línea por línea\n\n- `pv`: monitorea el progreso de datos a través de un tubo\n\n- `hd`, `hexdump`, `xxd`, `bview` y `bvi`: descarga o edita archivos binarios\n\n- `strings`: extrae texto desde archivos binarios\n\n- `tr`: traducción o manipulación de caracteres\n\n- `iconv` o `uconv`: conversión de codificaciones de texto\n\n- `split` y `csplit`: división de archivos\n\n- `sponge`: lee todas las entradas antes de escribirlo, útil para vista previa y posterior escritura sobre el mismo archivo, Ej., `grep -v something some-file | sponge some-file`\n\n- `units`: unidades de conversión y cálculos; convierte furlongs por fortnight a twips por blink (ver también `/usr/share/units/definitions.units`)\n\n- `apg`: genera contraseñas aleatorias.\n\n- `7z`: compresión de archivos de alto nivel\n\n- `ldd`: información de librería dinámica\n\n- `nm`: símbolos de archvios objeto\n\n- `ab`: benchmarking de servidores web\n\n- `strace`: depuración de llamadas del sistema\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): mejor traceroute para la depuración de la red\n\n- `cssh`: shell concurrente visual\n\n- `rsync`: sincronización de archivos y carpetas sobre SSH o en sistema de archivos locales\n\n- [`wireshark`](https://wireshark.org/) y [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): captura de paquetes y depuración de la red\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep para la capa de la red\n\n- `host` y `dig`: consultas DNS\n\n- `lsof`: descriptor de archivo de procesos e información de socket\n\n- `dstat`: sistema de estadísticas útil\n\n- [`glances`](https://github.com/nicolargo/glances): visión general de multi-subsistemas, de alto nivel\n\n- `iostat`: estadísticas del uso del disco duro\n\n- `mpstat`: estadísticas del uso del CPU\n\n- `vmstat`: estadísticas del uso de la memoria\n\n- `htop`: versión mejorada de top\n\n- `last`: historial de login\n\n- `w`: quién está autenticado\n\n- `id`: información de identidad de usuario/grupo\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): estadísticas históricas del sistema\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) o [`nethogs`](https://github.com/raboof/nethogs): utilización de la red por un socket o proceso\n\n- `ss`: estadísticas de socket\n\n- `dmesg`: mensajes de error del arranque y del sistema\n\n- `sysctl`: examina y configura los parámetros de kernel de Linux en tiempo de ejecución\n\n- `hdparm`: manipulación/rendimiento de discos SATA/ATA\n\n- `lsblk`: lista de dispositivos de bloque: una vista tipo arbol de sus discos y particiones de disco\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: información de hardware, incluyendo CPU, BIOS, RAID, gráficos, dispositivos, etc\n\n- `lsmod` y `modinfo`: lista y muestra detalles de los módulos del kernel\n\n- `fortune`, `ddate`, y `sl`: um, bien, depende de si considera las locomotoras de vapor y citas Zippy \"útiles\"\n\n\n## Solo para OS X\n\nEstos son puntos relevantes *únicamente* para OS X.\n\n- Administración de paquetes con `brew` (Homebrew) y/o `port` (MacPorts). Estos pueden ser utilizados para instalar en OS X muchos de los comandos de arriba.\n\n- Copie la salida de cualquier comando en una aplicación de escritorio con `pbcopy` y pegue una entrada con `pbpaste`.\n\n- Para activar la tecla Option en un OS X Terminal como una tecla alt (tal como se usan en los comandos más arriba como  **alt-b**, **alt-f**, etc.), abre Preferencias -> Perfiles -> Teclado y selecciona \"Usa Option como tecla Meta\".\n\n- Para abrir un archivo con una aplicación de escritorio, use `open` o `open -a /Applications/Whatever.app`.\n\n- Spotlight: Busque archivos con `mdfind` y liste metadata (tal como información de foto EXIF) con `mdls`.\n\n- Ten en cuenta que OS X está basado en BSD Unix, y muchos comandos (por ejemplo `ps`, `ls`, `tail`, `awk`, `sed`) tiene sutiles variaciones en comparación con Linux, que está en gran parte influenciado por el sistema Unix V-style y herramientas GNU. Comunmente se puede diferenciar al notar que una página man tienen el encabezado \"BSD General Commands Manual.\" En algunos casos versiones GNU pueden ser instaladas también (tales como `gawk` y `gsed` para GNU awk y sed). Si escribe Bash scripts multiplataforma, evite tales comandos (por ejemplo, considere Python o `perl`) o prueba cuidadosamente.\n\n- Para obtener la información de la versión del OS X, usa `sw_vers`.\n\n## Solo para Windows\n\nEstos son puntos relevantes *únicamente* para Windows.\n\n-En Windows 10, puedes usar [Bash de Ubuntu en Windows](https://msdn.microsoft.com/commandline/wsl/about) que proporciona un entorno familiar con la línea de comandos en Unix. Su lado positivo, este permite a los programas de Linux ejecutarse en Windows. Por otro lado este no soporta ejecutar de programas de Windows desde la línea de comandos Bash.\n- Accede al poder del shell de Unix en Microsoft Windows instalando [Cygwin](https://cygwin.com/). La mayoría de las cosas descritas en este documento funcionaran en su configuración por defecto.\n\n- Instala programas adicionales de Unix con el gestor de paquetes de Cygwin\n\n- Usa `mintty` como tu línea de comando.\n\n- Accede al portapapeles de Windows a través de `/dev/clipboard`.\n\n- Ejecuta `cygstart` para abrir un archivo arbitrario a través de su aplicación registrada.\n\n- Accede al registro de Windows con `regtool`.\n\n- Ten en cuenta que la ruta `C:\\` del disco Windows se transforma en `/cygdrive/c` en Cygwin, y que Cygwin `/` aparece en `C:\\cygwin` en Windows. Convierte entre Cygwin y rutas de archivos estilo Windows con `cygpath`. Este es el más útil de los scripts que invocan programas de Windows.\n\n- Puedes ejecutar y hacer scripts de la mayoría de las tareas administrativas del sistema de Windows desde la línea de comandos aprendiendo y usando `wmic`.\n\n- Otra opción para obtener la apariencia y sensación de Unix en Windows es [Cash](ttps://github.com/dthree/cash). Ten en cuenta que muy pocos comandos de Unix y opciones de la línea de comandos están disponibles en este entorno.\n\n- Una opción alternativa para tener herramientas de desarrollo GNU (algo como GCC) en windows es [MinGW](http://www.mingw.org/) y [MSYS](http://www.mingw.org/wiki/msys) su paquete, que proporciona utilidades tales como bash, gawk, make y grep. MSYS no tiene todas las características al compararse con Cygwin. MinGW es particularmente útil para crear ejecutables nativos de Windows de las herramientas Unix.\n\n\n## Más recursos\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Una lista curada de herramientas shell y recursos.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Una guía más detallada para la línea de comandos del OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) para escribir mejores script shell.\n- [shellcheck](https://github.com/koalaman/shellcheck): Una herramienta de análisis estadístico del script shell. Esencialmente, lint para bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Las menudencias tristemente complejas sobre cómo manejar nombres de archivos correctamente en shell scripts.\n\n\n## Advertencia\n\nCon la excepción de tareas muy pequeñas, el código está escrito para que otros puedan leerlo. Con el poder llega la responsabilidad. El hecho de que *puedes* hacer algo en Bash no necesariamente significa que deba hacerlo! ;)\n\n\n## Licencia\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nEste trabajo está licenciado bajo [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-fr.md",
          "type": "blob",
          "size": 49.32,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# L'art de la ligne de commande\n\n*Note : Je prévois de réviser le document et suis à la recherche d'un nouveau co-auteur pour en faire un guide plus complet.\nBien que très populaire, il pourrait être plus étendu et un peu plus approfondi.\nSi vous aimer écrire, n'êtes pas loin d'être un expert du sujet et êtes disposé à contribuer, veuillez me laisser un message à josh (0x40) holloway.com. –[jlevy](https://github.com/jlevy), [Holloway](https://www.holloway.com). Merci !*\n\n- [Méta](#méta)\n- [Notions de base](#notions-de-base)\n- [Utilisation quotidienne](#utilisation-quotidienne)\n- [Traitement des fichiers et des données](#traitement-des-fichiers-et-des-données)\n- [Débogage du système](#débogage-du-système)\n- [Unilignes](#unilignes)\n- [Obscures mais utiles](#obscures-mais-utiles)\n- [Uniquement macOS](#uniquement-macos)\n- [Uniquement Windows](#uniquement-windows)\n- [Autres ressources](#autres-ressources)\n- [Avertissement](#avertissement)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nLa maîtrise de la ligne de commande est une compétence souvent négligée ou considérée ésotérique, pourtant elle améliore de façon évidente et subtile votre habilité et votre productivité en tant qu'ingénieur.\nCeci est une sélection de notes et d'astuces sur l'utilisation de la ligne de commande que nous avons trouvées utiles en travaillant avec Linux.\nCertaines sont élémentaires, d'autres sont assez spécifiques, complexes ou obscures.\nCette page n'est pas bien longue, mais si vous pouvez retenir et vous servir de tout ce qui s'y trouve, alors vous saurez beaucoup de choses.\n\nCe document est le fruit du travail de [nombreux auteurs et traducteurs](AUTHORS.md).\nUne partie de celui-ci a été [initialement](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands) [publiée](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix) sur [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know), mais il se trouve maintenant sur GitHub, où des personnes plus compétentes que l'auteur originel ont apporté de nombreuses améliorations.\n[**N'hésitez pas à poser des questions**](https://airtable.com/shrzMhx00YiIVAWJg) sur la ligne de commande.\n[**Merci de contribuer**](/CONTRIBUTING.md) si vous voyez une erreur ou quelque chose qui pourrait être amélioré !\n\n\n## Méta\n\nContexte :\n\n- Ce guide est destiné aux débutants et aux utilisateurs chevronnés.\nLes objectifs sont l'*envergure* (tout est important), la *spécificité* (donner des exemples concrets des cas les plus courants) et la *concision* (éviter tout ce qui n'est pas essentiel et les digressions disponibles facilement ailleurs).\nChaque astuce est indispensable dans certaines situations ou fait gagner beaucoup de temps par rapport aux solutions alternatives.\n- Il est écrit pour Linux, à l'exception des sections « [Uniquement macOS](#uniquement-macos) » et « [Uniquement Windows](#uniquement-windows) ».\nBeaucoup d'items s'appliquent ou peuvent être installés sur d'autres Unices ou macOS (ou même Cygwin).\n- L'accent est mis sur l'utilisation interactive de Bash, bien que de nombreuses astuces s'appliquent aux autres shells et à l'écriture de scripts en Bash.\n- Il inclut les commandes « standard » d'Unix aussi bien que celles qui nécessitent l'installation de paquets spéciaux &mdash; tant qu'ils sont suffisamment importants pour mériter d'être mentionnés.\n\nRemarques :\n\n- Afin que le guide tienne sur une seule page, du contenu est implicitement inclus par référence.\nVous êtes suffisamment intelligents pour rechercher des renseignements ailleurs une fois que vous avez l'idée ou la commande à googler.\nUtilisez `apt`, `yum`, `dnf`, `pacman`, `pip` ou `brew` (selon votre distribution ou OS) pour installer de nouveaux programmes.\n- Allez sur [Explainshell](http://explainshell.com) pour obtenir de l'aide à propos des commandes, options, tubes, etc.\n\n\n## Notions de base\n\n- Apprenez les bases de Bash.\nEn fait, tapez `man bash` et parcourez toute la page&#8239;; elle est relativement facile à suivre et pas si longue.\nLes shells alternatifs peuvent être intéressants, mais Bash est puissant et disponible partout (apprendre *seulement* zsh, fish, etc., bien que cela soit tentant sur votre ordinateur portable, vous limite dans bien des situations, comme par exemple lors de l'utilisation de vrais serveurs).\n\n- Apprenez à bien utiliser au moins un éditeur en mode texte.\nL'éditeur `nano` est l'un des plus simples pour de l'édition simple (ouvrir, modifier, sauvegarder, rechercher).\nCependant pour un usage avancé dans un terminal, rien ne remplace le vénérable Vim (`vi`), éditeur difficile à prendre en main, mais rapide et très complet.\nDe nombreuses personnes utilisent également le classique Emacs, surtout pour d'importantes tâches d'édition (bien sûr, tout développeur moderne de logiciels travaillant sur un vaste projet n'utilise probablement pas un simple éditeur en mode texte et devrait donc aussi se familiariser avec des outils et des EDI graphiques modernes).\n\n- Trouver de la documentation :\n  - Sachez comment lire une documentation avec `man` (pour les curieux, `man man` liste les sections avec leur numéro, par exemple 1 pour les commandes «&nbsp;normales&nbsp;» , 5 pour les formats des fichiers et les conventions, et 8 pour tout ce qui concerne l'administration système).\n  Trouvez les pages de manuel avec `apropos`.\n  - Sachez que certaines commandes ne sont pas des exécutables, mais des commandes internes de Bash et que vous pouvez obtenir de l'aide à leur sujet avec `help` et `help -d`.\n  Utilisez `type command` pour déterminer si une commande est un exécutable, une commande interne du shell ou un alias.\n  - `curl cheat.sh/commande` fournit une *cheatsheet* concise comprenant des exemples courants d'utilisation d'une commande shell.\n\n- Apprenez à rediriger les entrées et sorties au moyen de `>` et `<`, et à créer des tubes avec `|`.\nSachez que `>` écrase le fichier de sortie et `>>` sert à ajouter.\nRenseignez-vous sur stdout et stderr.\n\n- Apprenez au sujet de l'expansion des noms de fichiers avec `*` (et peut-être `?` et `[`...`]`), des mécanismes de citation, et de la différence entre les guillemets `\"` et les apostrophes `'` (voir ci-dessous).\n\n- Familiarisez-vous avec la gestion des processus avec Bash&nbsp;: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Apprenez `ssh` et les principes de l'authentification sans mot de passe à l'aide de `ssh-agent`, `ssh-add`, etc.\n\n- Les bases de la gestion des fichiers&nbsp;: `ls` et `ls -l` (en particulier, apprenez la signification de chacune des colonnes de `ls -l`), `less`, `head`, `tail` et `tail -f` (ou mieux, `less +F`), `ln` et `ln -s` (apprenez les différences et les avantages des liens durs par rapport aux liens symboliques), `chown`, `chmod`, `du` (pour un rapide résumé de l'espace disque occupé&nbsp;: `du -hs *`).\nPour la gestion du système de fichiers&nbsp;: `df`, `mount`, `fdisk`, `mkfs`, `lsblk`.\nApprenez ce qu'est un inode (`ls -i` ou `df -i`).\n\n- Les bases de l'administration réseau&nbsp;: `ip`, `ifconfig`, `dig`, `traceroute` et `route`.\n\n- Apprenez à vous servir d'un logiciel de gestion de versions tel que `git`, et utilisez-le.\n\n- Apprenez les expressions régulières et les différents drapeaux de `grep` et `egrep`.\nLes options `-i`, `-o`, `-v`, `-A`, `-B` et `-C` sont bonnes à connaître.\n\n- Apprenez à utiliser `apt-get`, `yum`, `dnf` ou `pacman` (selon la distribution) pour trouver et installer des paquets.\nAssurez-vous d'avoir `pip` pour installer des outils en ligne de commande écrits en Python (quelques-uns ci-dessous sont plus faciles à installer avec `pip`).\n\n\n## Utilisation quotidienne\n\n- En Bash, utilisez **Tab** pour compléter les arguments ou lister toutes les commandes disponibles, et **ctrl-r** pour rechercher dans l'historique des commandes (tapez pour rechercher, appuyez sur **ctrl-r** plusieurs fois pour parcourir les différentes correspondances, appuyez sur **Enter** pour exécuter la commande trouvée ou sur la flèche droite pour l'éditer).\n\n- En Bash, utilisez **ctrl-w** pour effacer le mot précédent et **ctrl-u** pour effacer tout ce qui précède le curseur.\nUtilisez **alt-b** et **alt-f** pour se déplacer mot par mot, **ctrl-a** pour déplacer le curseur au début de la ligne, **ctrl-e** pour déplacer le curseur à la fin de la ligne, **ctrl-k** pour effacer depuis le curseur jusqu'à la fin de la ligne, **ctrl-l** pour effacer l'écran.\nVoir `man readline` pour la liste des raccourcis clavier par défault de Bash.\nIl y en a beaucoup.\nPar exemple **alt-.** fait défiler les arguments précédents et **alt-*** développe un glob.\n\n- Sinon, si vous adorez les combinaisons de touches dans le style vi, utilisez `set -o vi` (`set -o emacs` pour revenir en arrière).\n\n- Pour éditer de longues commandes, après avoir configuré votre éditeur (par exemple `export EDITOR=vim`), **ctrl-x** **ctrl-e** (**escape-v** dans le style vi) ouvre l'éditeur pour éditer la commande courante.\n\n- Consultez les commandes récentes avec `history`.\nFaites `!n` pour rappeler la commande numéro `n`.\nIl y a aussi beaucoup d'autres abréviations, les plus utiles étant probalement `!$` pour le dernier argument et `!!` pour la dernière commande (voir la section « HISTORY EXPANSION » de la page de manuel).\nCependant, celles-ci peuvent être aisément remplacées par **ctrl-r** et **alt-.**.\n\n- Placez-vous dans votre répertoire personnel avec `cd`.\nAccédez aux fichiers à partir de leurs chemins relatifs par rapport à votre répertoire personnel en préfixant ceux-ci avec `~` (p.&nbsp;ex. `~/.bashrc`).\nDans les scripts shell, désignez le répertoire personnel par `$HOME`.\n\n- Pour revenir au répertoire de travail précédent&nbsp;: `cd -`.\n\n- Si vous êtes au milieu de la saisie d'une commande mais que vous changez d'avis, tapez **alt-#** pour ajouter `#` au début de la ligne et l'entrer comme un commentaire (ou utilisez **ctrl-a**, **#**, **enter**).\nVous pouvez alors y revenir plus tard à l'aide de la commande history.\n\n- Utilisez `xargs` (ou `parallel`).\nC'est très puissant.\nRemarquez que vous pouvez contrôler le nombre d'items à exécuter par ligne (`-L`) ainsi que la parallélisation (`-P`).\nSi vous n'êtes pas sûr d'avoir fait ce qu'il faut, utilisez d'abord `xargs echo`.\nL'option `-I{}` est également pratique.\nExemples&nbsp;:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` fournit un affichage utile des processus sous la forme d'un arbre.\n\n- `pgrep` et `pkill` pour rechercher ou envoyer un signal à des processus en fonction de leur nom (`-f` est utile).\n\n- Connaissez les différents signaux que vous pouvez envoyer aux processus.\nPar exemple, pour suspendre l'exécution d'un processus, utilisez `kill -STOP [pid]`.\nPour la liste complète, consultez `man 7 signal`.\n\n- Utilisez `nohup` ou `disown` pour qu'un processus en arrière-plan reste actif indéfiniment.\n\n- Vérifiez quels sont les processus qui écoutent à l'aide de `netstat -lntp`, `ss -plat` (pour TCP; ajoutez `-u` pour UDP) ou `lsof -iTCP -sTCP:LISTEN -P -n` (qui fonctionne aussi sur macOS). \n\n- Voyez également `lsof` et `fuser` pour la liste des *sockets* et fichiers ouverts.\n\n- Voyez `uptime` ou `w` pour savoir depuis combien de temps le système fonctionne.\n\n- Utilisez `alias` pour créer des raccourcis vers les commandes fréquemment utilisées.\nPar exemple, `alias ll='ls -latr'` crée un nouvel alias `ll`.\n\n- Conservez les alias, les paramètres du shell et les fonctions fréquemment utilisées dans le fichier `~/.bashrc`, et [arrangez-vous pour qu'il soit chargé par le shell de connexion](http://superuser.com/a/183980/7106).\nAinsi, votre configuration s'appliquera à toutes vos sessions shell.\n\n- Placez dans `~/.bash_profile` la configuration de vos variables d'environnement ainsi que les commandes à exécuter lorsque vous vous connectez.\nUne configuration séparée est nécessaire lorsque vous vous connectez depuis un gestionnaire de connexion graphique et pour les tâches planifiées par `cron`.\n\n- Synchronisez vos fichiers de configuration (p.&nbsp;ex. `.bashrc` et `.bash_profile`) entre plusieurs ordinateurs avec Git.\n\n- Comprennez qu'il convient d'être prudent lorsque des variables et des noms de fichiers contiennent des espaces.\nMettez vos variables entre guillemets, par exemple `\"$FOO\"`.\nPréférez les options `-0` ou `-print0` qui permettent de délimiter les noms des fichiers avec le caractère nul, par exemple `locate -0 pattern | xargs -0 ls -al` ou `find / -print0 -type d | xargs -0 ls -al`.\nPour itérer sur des noms de fichiers contenant des espaces dans une boucle for, positionnez la variable IFS avec le caractère de retour à la ligne à l'aide de `IFS=$'\\n'`.\n\n- Dans les scripts Bash, utilisez `set -x` (ou la variante `set -v` qui enregistre les entrées brutes, y compris les variables non référencées et les commentaires) pour l'affichage d'informations de débogage.\nUtilisez les modes stricts à moins que vous ayez une bonne raison de ne pas le faire&nbsp;: utilisez `set -e` pour interrompre le script en cas d'erreur (code de sortie non nul).\nUtilisez `set -u` pour détecter l'utilisation d'une variable non initialisée.\nEnvisagez aussi `set -o pipefail` pour détecter les erreurs dans les tubes (cependant lisez-en plus si vous l'utilisez car ce sujet est un peu délicat).\nPour des scripts plus compliqués, servez-vous également de `trap` pour intercepter EXIT ou ERR.\nUne bonne habitude est de commencer un script comme cela, ce qui lui permettra de détecter les erreurs courantes, de s'interrompre et d'afficher un message&nbsp;:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- Dans les scripts en Bash, les sous-shells (placés entre parenthèses) sont commodes pour grouper des commandes.\nUn exemple classique consiste à se déplacer temporairement dans un autre répertoire de travail&nbsp;:\n```bash\n      # faire quelque chose dans le répertoire courant\n      (cd /some/other/dir && other-command)\n      # continue dans le répertoire original\n```\n\n- Notez qu'en Bash, il existe de nombreux types d'expansions de variables. Pour vérifier l'existence d'une variable&nbsp;: `${name:?error message}`.\nPar exemple, si un script en Bash exige un unique argument, il suffit d'écrire `input_file=${1:?usage: $0 input_file}`.\nPour utiliser une valeur par défaut si une variable est vide&nbsp;: `${name:-default}`.\nSi vous souhaitez ajouter un paramètre supplémentaire facultatif dans l'exemple précédent, vous pouvez écrire quelque chose comme `output_file=${2:-logfile}`.\nSi `$2` est omis et donc vide, `output_file` prendra la valeur `logfile`.\nL'évaluation arithmétique&nbsp;: `i=$(( (i+1) % 5)`.\nLes listes d'entiers&nbsp;: `{1..10}`\nSuppression de préfixes et de suffixes&nbsp;: `${var%suffix}` et `${var#prefix}`.\nPar exemple, si `var=foo.pdf`, alors `echo ${var%.pdf}.txt` affiche `foo.txt`.\n\n- L'expansion des accolades avec `{`...`}` évite de retaper des textes similaires et automatise les combinaisons d'éléments de listes.\nC'est utile dans des exemples comme  `mv foo.{txt,pdf} some-dir` (qui déplace les deux fichiers), `cp somefile{,.bak}` (équivalent à `cp somefile somefile.bak`) ou `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (qui engendre toutes les combinaisons possibles et crée une arborescence de répertoires).\nL'expansion des accolades est effectuée avant toutes les autres expansions.\n\n- Les expansions sont exécutées dans l'ordre suivant&nbsp;: expansion des accolades, développement du tilde, remplacement des paramètres et des variables, évaluation arithmétique, substitution de commande (de la gauche vers la droite), découpage en mots, puis développement des chemins. \nPar exemple, une liste telle que `{1..20}` ne peut s'exprimer avec des variables en utilisant `{$a..$b}`.\nÀ la place, utilisez `seq` ou une boucle `for`&nbsp;; par exemple, `seq $a $b` ou `for((i=a; i<=b; i++)); do ...; done`.\n\n- La sortie d'une commande peut être traitée comme un fichier à l'aide de `<(some command)` (substitution de processus).\nPar exemple, pour comparer le fichier local `/etc/hosts` avec un fichier distant&nbsp;:\n```sh\n      diff /etc/hosts/ <(ssh somehost cat /etc/hosts)\n```\n\n- Lorsque vous écrivez des scripts, vous pourriez avoir envie de placer votre code entre accolades.\nS'il manque l'accolade fermante, les scripts ne pourront s'exécuter à cause d'une erreur de syntaxe.\nC'est particulièrement utile pour des scripts mis à disposition sur le web, afin de prévenir leur exécution lorsqu'ils sont partiellement téléchargés.\n```bash\n{\n    # Votre code ici\n}\n```\n\n- Un «&nbsp;document intégré&nbsp;» permet de [rediriger plusieurs lignes en entrée](https://abs.traduc.org/abs-fr/ch19.html) comme si elles provenaient d'un fichier&nbsp;:\n```\ncat <<EOF\nentrée sur\nplusieurs lignes\nEOF\n```\n\n- En Bash, redirigez à la fois la sortie standard et la sortie des erreurs à l'aide de `some-command > logfile 2>&1` ou `some-command &>logfile`.\nSouvent, pour s'assurer qu'une commande ne laisse pas un descripteur de fichier ouvert sur l'entrée standard, l'attachant au terminal dans lequel vous vous trouvez, une bonne pratique consiste à ajouter `</dev/null`.\n\n- Utilisez `man ascii` pour une bonne table ASCII avec les valeurs décimales et hexadécimales.\nPour des informations générales sur l'encodage, `man unicode`, `man utf-8` et `man latin1` sont utiles.\n\n- Utilisez `screen` ou [`tmux`](https://tmux.github.io/) pour multiplexer une fenêtre de terminal, particulièrement utile pour des sessions SSH distantes, et pour détacher et rattacher une session.\n`byobu` peut améliorer screen ou tmux en fournissant plus d'informations et une gestion plus facile.\nUne alternative plus légère pour la persistance des sessions seulement est [`dtach`](https://github.com/bogner/dtach/).\n\n- Il est utile de savoir comment créer un tunnel SSH avec `-L` ou `-D` (et occasionnellement `-R`), par exemple pour accéder à des sites web à partir d'un serveur distant.\n\n- Il peut être intéressant d'effectuer quelques optimisations à votre configuration de ssh&#8239;; par exemple, le fichier `~/.ssh/config` contient des paramètres pour éviter les pertes de connexion dans certains environnements réseaux, pour utiliser la compression (ce qui est utile avec scp sur des connexions à faible bande passante), et pour le multiplexage de canaux vers le même serveur avec un fichier de contrôle local&nbsp;:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Quelques autres options relatives à ssh sont sensibles pour la sécurité et ne devraient être activées qu'avec la plus grande prudence. Par exemple, sur des sous-réseaux, des hôtes ou des réseaux sûrs&nbsp;: `StrictHostKeyChecking=no`, `ForwardAgent=yes`.\n\n- Envisagez [`mosh`](https://mosh.org/) comme une alternative à ssh qui utilise UDP, évitant ainsi les pertes de connexion et ajoutant du confort en situation de mobilité (exige une installation côté serveur).\n\n- Pour obtenir les permissions d'un fichier en octal, utile pour configurer le système mais non fournit par `ls`, utilisez quelque chose comme\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Pour une sélection interactive de valeurs issues de la sortie d'une commande, utilisez [`percol`](https://github.com/mooz/percol) ou [`fzf`](https://github.com/junegunn/fzf).\n\n- Pour interagir avec les fichiers provenant de la sortie d'une commande (p.&nbsp;ex. `git`), utilisez `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n\n- Créez un simple serveur web pour partager les fichiers du répertoire courant (et ses sous-répertoires) avec `python -m SimpleHTTPServer 7777` (port 7777 et Python 2)  et `python -m http.server 7777` (port 7777 et Python 3).\n\n- Pour exécuter une commande avec les privilèges d'un autre utilisateur, utilisez `sudo`.\nPar défaut, cet autre utilisateur est *root*&#8239;; utilisez `-u` pour spécifier un autre utilisateur.\nUtilisez `-i` pour ouvrir une session en tant que cet autre utilisateur (on vous demandera *votre* mot de passe).\n\n- Pour basculer le shell sous un autre utilisateur, utilisez `su username` ou `su - username`.\nIncluez `-` pour obtenir le même environnement que lorsque cet utilisateur se connecte.\nLe nom d'utilisateur par défaut est *root*.\nLe système vous demandera le mot de passe *de l'utilisateur cible*.\n\n- Sachez que l'argument de la ligne de commande a une [taille limite de 128 Kio](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong). L'erreur « Argument list too long » est fréquente avec les jokers qui reconnaissent un grand nombre de fichiers (quand cela se produit des alternatives comme `find` et `xargs` peuvent aider).\n\n- Pour une calculatrice basique (et bien sûr accéder à Python en général), utilisez l'interpréteur `python`.\nPar exemple,\n```\n>>> 2+3\n5\n```\n\n## Traitement des fichiers et des données\n\n- Pour localiser un fichier par son nom dans le répertoire courant, `find . -iname '*something*'` (ou autres).\nPour trouver un fichier n'importe où par son nom, utilisez `locate something` (mais n'oubliez pas que `updatedb` peut ne pas avoir indexé les fichiers récemment créés).\n\n- Pour effectuer une recherche parmi des fichiers sources ou des fichiers de données, il existe des alternatives plus avancées ou plus rapides que `grep -r`, parmi lesquels (en gros du plus ancien au plus récent) [`ack`](https://github.com/beyondgrep/ack2), [`ag`](https://github.com/ggreer/the_silver_searcher) (« *the silver searcher* ») et [`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep).\n\n- Pour convertir du HTML en texte brut : `lynx -dump -stdin`.\n\n- Pour convertir du Markdown, du HTML et toutes sortes de formats texte, essayez [`pandoc`](http://pandoc.org).\nPar exemple, pour convertir un document Markdown au format Word : `pandoc README.md --from markdown --to docx -o temp.docx`\n\n- Si vous devez manipuler du XML, l'ancien `xmlstarlet` marche bien.\n\n- Pour le JSON, utilisez [`jq`](http://stedolan.github.io/jq/).\nVoir également [`jid`](https://github.com/simeji/jid) and [`jiq`](https://github.com/fiatjaf/jiq) pour une utilisation interactive.\n\n- Pour le YAML, utilisez [`shyaml`](https://github.com/0k/shyaml).\n\n- Pour les fichiers Excel ou CSV, [csvkit](https://github.com/onyxfish/csvkit) fournit `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.\n\n- Pour Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) est pratique et [`s4cmd`](https://github.com/bloomreach/s4cmd) est plus rapide.\nL'outil d'Amazon [`aws`](https://github.com/aws/aws-cli) et la version améliorée [`saws`](https://github.com/donnemartin/saws) sont indispensables pour les autres tâches liées à AWS.\n\n- Connaissez `sort` et `uniq`, y compris les options `-u` et `-d` de `uniq` (voir les unilignes plus bas). Voir aussi `comm`.\n\n- Sachez utiliser `cut`, `paste` et `join` pour manipuler les fichiers texte.\nBeaucoup de personnes utilisent `cut` mais oublient `join`.\n\n- Connaissez `wc` pour compter les lignes (`-l`), les caractères (`-m`), les mots (`-w`) et les octets (`-c`).\n\n- Connaissez `tee` pour copier depuis stdin vers un fichier ou vers stdout, comme dans `ls -al | tee file.txt`.\n\n- Pour des calculs plus complexes, incluant les regroupements, les inversions de champs et des calculs statistiques, considérez [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Sachez que la locale affecte de nombreux outils en ligne de commande de manière subtile, comme l'ordre pour les tris (collation) et les performances.\nLa plupart des installateurs Linux définissent la variable `LANG` ou d'autres variables locales d'environnement pour configurer une locale telle que US English.\nMais ayez à l'esprit que le tri sera modifié si vous changez la locale.\nEt sachez que les routines i18n peuvent rendre les opérations de tri et d'autres commandes *beaucoup* plus lentes.\nDans certains cas (tels que les opérations concernant les ensembles et l'unicité abordées ci-dessous) vous pouvez, sans risque, ignorer complètement les lentes routines i18n et utiliser l'ordre de tri classique fondé sur les valeurs des octets à l'aide de `export LC_ALL=C`.\n\n- Vous pouvez modifier l'environnement d'une commande particulière en préfixant son invocation par l'affectation de variables, comme dans `TZ=Pacific/Fiji date`.\n\n- Apprenez `awk` et `sed` pour de l'analyse de données élémentaire.\nVoir la section [Unilignes](#unilignes) pour des exemples.\n\nPar exemple, pour effectuer la somme de tous les nombres de la troisième colonne d'un fichier texte&nbsp;: `awk '{ x += $3 } END { print x}'`.\nC'est probablement trois fois plus rapide et trois fois plus petit que son équivalent en Python.\n\n- Pour remplacer toutes les occurences d'une chaîne de caractères dans un ou plusieurs fichiers&nbsp;:\n```sh\n    perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Pour renommer de multiples fichiers ou effectuer des recherches et des remplacements dans des fichiers, essayez [`repren`](https://github.com/jlevy/repren) (dans certains cas la commande `rename` permet aussi de renommer de multiples fichiers, mais soyez prudent car ses fonctionnalités ne sont pas les mêmes sur toutes les distributions Linux).\n```sh\n    # Renomme les répertoires, les fichiers et leurs contenus à l'aide\n    # de la substitution foo -> bar :\n    repren --full --preserve-case --from foo --to bar .\n    # Restaure des fichiers de sauvegarde à l'aide de la\n    # substitution whatever.bak -> whatever :\n    # Même chose que ci-dessus avec rename s'il est disponible :\n    rename 's/\\.bak$//' *.bak\n```\n\n- Selon sa page de manuel, `rsync` est un outil de duplication de fichiers vraiment rapide et incroyablement polyvalent.\nIl est connu pour faire de la synchronisation entre machines, mais est également utile pour un usage local.\nLorsque les mesures de sécurité l'autorisent, utiliser `rsync` au lieu de `scp` permet de reprendre un transfert interrompu sans devoir le recommencer zéro.\nIl est aussi l'un des outils [les plus rapides](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) pour effacer un grand nombre de fichiers&nbsp;:\n```sh\n    mkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Pour surveiller l'état d'avancement d'une copie de fichiers, utilisez [`pv`](http://www.ivarch.com/programs/pv.shtml), [`pycp`](https://github.com/dmerejkowsky/pycp), [`pmonitor`](https://github.com/dspinellis/pmonitor), [`progress`](https://github.com/Xfennec/progress), `rsync --progress`, ou `dd status=progress` dans le cas d'une copie par blocs.\n\n- Utilisez `shuf` pour mélanger ou sélectionner aléatoirement des lignes d'un fichier.\n\n- Sachez les options de `sort`.\nPour les nombres, utilisez `-n`, ou `-h` s'ils sont dans un format lisible par un humain (p.&nbsp;ex. issus de `du -h`).\nComprenez le fonctionnement des clés (`-t` et `-k`).\nEn particulier, faites attention à bien écrire `-k1,1` pour trier seulement selon le premier champ&nbsp;: `-k1` signifie que l'on trie selon la ligne entière.\nLe tri stable (`sort -s`) peut s'avérer utile.\nPar exemple, pour trier d'abord selon le champ 2, puis selon le champ 1, vous pouvez utiliser `sort -k1,1 | sort -s -k2,2`.\n\n- Si jamais vous avez besoin d'écrire un caractère de tabulation dans une ligne de commande en Bash (p.&nbsp;ex pour le paramètre de l'option de tri `-t`), entrez **ctrl-v** **[Tab]** ou écrivez `$'\\t'` (préférable car vous pouvez le copier-coller).\n\n- Les outils habituels pour *patcher* un code source sont `diff` et `patch`.\nVoir aussi `diffstat` pour un relevé statistique d'un diff et `sdiff` pour un affichage côte à côte d'un diff.\nRemarquez que `diff -r` marche avec des répertoires entiers.\nUtilisez `diff -r tree1 tree2 | diffstat` pour obtenir un résumé des changements.\nUtilisez `vimdiff` pour comparer et éditer des fichiers.\n\n- Pour les fichiers binaires, utilisez `hd`, `hexdump` ou `xxd` pour un affichage simple en hexadécimal et `bvi`, `biew` pour éditer des fichiers binaires.\n\n- Également pour les fichiers binaires, `strings` (ainsi que `grep`, etc) vous permet d'y trouver des bouts de texte.\n\n- Pour effectuer des différences entre des fichiers binaires (compression différentielle), utilisez `xdelta3`.\n\n- Pour changer l'encodage d'un texte, essayer `iconv`, ou `uconv` pour un usage plus avancée&nbsp;: il permet quelques trucs avancés avec l'Unicode.\nPar exemple&nbsp;:\n```sh\n      # Affiche les codes hexadécimaux et les noms des caractères (utile pour déboguer) : \n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < input.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < input.txt\n      # Convertit en minuscule et supprime les accents :\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; \n      ::Any-NFC;' < input.txt > output.txt\n```\n\n- Pour découper des fichiers en morceaux, regardez `split` pour un découpage en morceaux de taille donnée et `csplit` pour un découpage en morceaux délimités par un motif.\n\n- Date et heure&nbsp;: pour obtenir la date et l'heure courantes au format [ISO 8601](https://fr.wikipedia.org/wiki/ISO_8601), utilisez `date -u +\"%Y-%m-%dT%H:%M:%SZ\"` (d'autres options [sont](https://stackoverflow.cmm/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [problématiques](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option)).\nPour manipuler des dates et des heures, utilisez `dateadd`, `datediff`, `strptime`, etc. fournis par [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Utilisez `zless`, `zmore`, `zcat` et `zgrep` pour travailler sur des fichiers compressés.\n\n- Les attributs d'un fichier peuvent être modifiés avec `chattr` et proposent une alternative de plus bas niveau aux permissions d'accès aux fichiers.\nPar exemple, l'attribut *immutable* protège un fichier contre toute suppression accidentelle: `sudo chattr +i /critical/directory/or/file`.\n\n- Utilisez `getfacl` et `setfacl` pour sauvegarder et restorer les permissions. Par exemple:\n```sh\n    getfacl -R /some/path > permissions.txt\n    setfacl --restore=permissions.txt\n```\n\n- Pour créer rapidement un fichier vide, utilisez `truncate` (crée un [fichier creux](https://en.wikipedia.org/wiki/Sparse_file)), `fallocate` (systèmes de fichiers ext4, XFS, Btrfs et OCFS2), `xfs_mkfile` (pour presque tous les systèmes de fichiers, disponible dans le paquet xfsprogs) ou `mkfile` (pour les systèmes de type Unix comme Solaris ou Mac OS X).\n\n## Débogage du système\n\n- Pour du débogage web, `curl` et `curl -I` sont pratiques, de même que leurs\néquivalents avec `wget`  ou le plus moderne [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Pour connaître l'état courant du CPU ou du disque, les outils conventionnels sont `top` (ou `htop` meilleur), `iostat` et `iotop`.\nUtilisez `iostat -mxz 15` pour des statistiques de base concernant le CPU, des statistiques détaillées pour les disques et un aperçu des performances.\n\n- Pour des informations sur les connexions réseaux, utilisez `netstat` et `ss`.\n\n- Pour un rapide aperçu de ce qui se passe dans le système, `dstat` est particulièrement utile.\nPour un aperçu plus étendu et détaillé, utilisez [`glances`](https://github.com/nicolargo/glances).\n\n- Pour connaître l'état de la mémoire, exécutez `free` et `vmstat` et comprenez leurs sorties.\nEn particulier, ayez à l'esprit que la valeur du « cache » est la mémoire utilisée par le noyau Linux comme cache de fichiers, donc compte comme de la mémoire « libre ».\n\n- Le système de débogage de Java est une autre paire de manche, cependant un truc simple sur la JVM d'Oracle et quelques autres JVMs consiste à exécuter `kill -3 <pid>` pour obtenir une trace complète des appels et une empreinte de la mémoire (y compris des détails sur le ramasse-miettes qui peuvent être hautement instructifs) dans stderr ou des fichiers journaux.\nLes commandes `jps`, `jstat`, `jstack` et `jmap` de la JDK sont utiles. L'[outil SJK](https://github.com/aragozin/jvm-tools) est plus avancé.\n\n- Utilisez [`mtr`](http://www.bitwizard.nl/mtr/) comme un `traceroute` amélioré pour identifier les problèmes de réseau.\n\n- Pour déterminer les raisons pour lesquelles un disque est plein, [`ncdu`](https://dev.yorhel.nl/ncdu) permet de gagner du temps par rapport aux commandes habituelles telles que `du -sh *`.\n\n- Pour trouver quel socket ou processus utilise la bande passante, essayez [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ou [`nethogs`](https://github.com/raboof/nethogs).\n\n- L'outil `ab` (fourni avec Apache) est utile pour une vérification rapide et grossière des performances d'un serveur web.\nPour des tests de charge plus complexes, essayez `siege`.\n\n- Pour du débogage réseau plus sérieux : [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) ou [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Sachez utiliser `strace` et `ltrace`.\nCes commandes peuvent être utiles si un programme fonctionne mal ou plante et que vous n'en connaissez pas la raison, ou si vous voulez vous faire une idée de ses performances.\nRemarquez l'option de profilage (`-c`) et la possibilité de s'attacher à un processus en cours d'exécution (`-p`).\nUtilisez l'option `-f` pour ne pas manquer les appels des processus enfants.\n\n- Connaissez `ldd` pour afficher les bibliothèques partagées, mais [ne l'utilisez jamais sur des fichiers qui ne sont pas dignes de confiance](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/).\n\n- Sachez comment vous connecter à un processus en cours d'exécution avec `gdb` et récupérer la trace des appels.\n\n- Utilisez `/proc`. C'est parfois incroyablement utile pour résoudre des problèmes en live.\nExemples&nbsp;: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd`, `/proc/xxx/smaps` (où `xxx` est l'identifiant du processus ou pid).\n\n- Pour comprendre pourquoi quelque chose a mal tourné antérieurement, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) peut-être très utile.\nIl fournit un historique concernant l'usage du CPU, de la mémoire, du réseau, etc.\n\n- Pour une analyse plus approfondie du système et de ses performances, regardez `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_%28Linux%29) et [`sysdig`](https://github.com/draios/sysdig).\n\n- Vérifiez quel OS vous utilisez avec `uname` ou `uname -a` (information générale sur la version d'Unix et du noyau) ou `lsb_release -a` (informations sur la distribution Linux).\n\n- Utilisez `dmesg` à chaque fois que quelque chose de bizarre se produit (pour des problèmes liés au matériel ou aux drivers).\n\n- Si vous effacez un fichier et que `du` indique que l'espace occupé n'a pas été libéré, alors vérifiez si le fichier n'est pas utilisé par un processus:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## Unilignes\n\nQuelques exemples d'assemblages de commandes&nbsp;:\n\n- Il est quelques fois extrèmement utile de pouvoir faire une intersection, union ou différence ensemblistes de fichiers texte à l'aide de `sort` et `uniq`.\nSupposez que `a` et `b` soient des fichiers texte ne contenant pas de lignes répétées.\nC'est rapide et fonctionne sur des fichiers de taille quelconque jusqu'à plusieurs gigaoctets (le tri n'est pas limité par la capacité mémoire bien que vous puissiez avoir besoin d'utiliser l'option `-T` si `/tmp` est sur une petite partition racine).\nVoyez aussi la remarque à propos de `LC_ALL` ci-dessus et l'option `-u` de `sort` (omise ci-dessous pour plus de clarté).\n```sh\n    sort a b | uniq > c   # c is a union b\n    sort a b | uniq -d > c   # c is a intersect b\n    sort a b b | uniq -u > c   # c is set difference a - b\n```\n\n- Embellissez les différences de deux fichiers JSON en normalisant leur syntaxe, en colorant et en paginant le résultat :\n```\n      diff <(jq --sort-keys . < file1.json) <(jq --sort-keys . < file2.json) | colordiff | less -R\n```\n\n- Utilisez `grep . *` pour inspecter rapidement les contenus des fichiers d'un repértoire (chaque ligne est précédé du nom du fichier) ou `head -100 *` (chaque fichier a un titre).\nCela peut être utile pour des répertoires remplis de fichiers de configuration comme ceux de `/sys`, `/proc`, `/etc`.\n\n- Pour ajouter les nombres de la troisième colonne d'un fichier texte (c'est probablement trois fois plus rapide et trois fois plus petit que son équivalent en Python)&nbsp;:\n```sh\n    awk '{ x += $3 } END { print x }' myfile\n```\n\n- Pour visualiser les tailles et les dates des fichiers d'une arborescence, une sorte de `ls -l` récursive, mais plus facile à lire que `ls -lR`&nbsp;:\n```sh\n    find . -type f -ls\n```\n\n- Supposons que vous ayez un fichier texte comme un fichier journal de serveur web et qu'une certaine valeur, comme un paramètre `acct_id` présent dans l'URL, figure à certaines lignes.\nSi vous voulez un décompte du nombre de requêtes pour chaque valeur de `acct_id`&nbsp;:\n```sh\n    egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Pour surveiller en permanence tout changement, utilisez `watch`, par exemple vérifiez les modifications dans les fichiers d'un répertoire avec `watch -d -n 2 'ls -rtlh | tail'` ou surveillez les paramètres de votre réseau tout en dépannant la configuration de votre wifi avec `watch -d -n 2 ifconfig`.\n\n- Exécutez cette fonction pour afficher aléatoirement une astuce de ce guide (analyse le code en Markdown et en extrait un élément d'une des listes)&nbsp;:\n```sh\n     function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          sed '/cowsay[.]png/d' |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80 | iconv -t US\n      }\n```\n\n\n## Obscures mais utiles\n\n- `expr` : effectue des operations arithmétiques et booléenne, et évalue des expressions régulières.\n\n- `m4` : simple macro processeur.\n\n- `yes` : affiche une chaîne de caractères indéfiniment.\n\n- `cal` : un calendrier sympathique.\n\n- `env` : exécute une commande (utile dans les scripts).\n\n- `printenv` : imprime les variables d'environnement (utile pour le débogage et dans les scripts).\n\n- `look` : trouve les mots anglais (ou les lignes d'un fichier) commençant par une chaîne donnée.\n\n- `cut`, `paste` and `join` : manipulation des données.\n\n- `fmt` : formate du texte.\n\n- `pr` : formate un texte en pages ou en colonnes.\n\n- `fold` : coupe des lignes de texte.\n\n- `column` : formate un texte en colonnes alignées, de largeurs fixes ou en tables.\n\n- `expand` et `unexpand` : convertit les tabulations en espaces et vice-versa.\n\n- `nl` : numérote les lignes d'un fichier.\n\n- `seq` : affiche une suite de nombres.\n\n- `bc` : une calculatrice.\n\n- `factor` : factorise des nombres entiers.\n\n- [`gpg`](https://gnupg.org/) : chiffre et signe les fichiers.\n\n- `toe` : table des entrées terminfo.\n\n- `nc` : débogage réseau et transfert de données.\n\n- `socat` : relai et réacheminement de port TCP (semblable à `netcat`).\n\n- [`slurm`](https://github.com/mattthias/slurm) : visualisation du trafic réseau.\n\n- `dd` : déplacer les données entre les fichiers ou les périphériques.\n\n- `file` : détermine le type d'un fichier\n\n- `tree` : affiche les répertoires et sous-répertoires sous la forme d'un arbre (comme `ls` mais récursivement).\n\n- `stat` : affiche des informations sur un fichier.\n\n- `time`: exécute et chronomètre une commande.\n\n- `timeout`: exécute une commande avec une limite de temps et stoppe le processus après la durée indiquée.\n\n- `lockfile` : crée un fichier sémaphore qui ne peut être supprimé que par `rm -f`\n\n- `logrotate` : permet la rotation, la compression et l'envoi des fichiers journaux par courrier électronique.\n\n- `watch` : exécute une commande périodiquement, affiche le résultat et surligne les différences entre les résultats.\n\n- [`when-changed`](https://github.com/joh/when-changed) : exécute n'importe quelle commande donnée à chaque fois qu'un fichier est modifié. Voir également `inotifywait` et `entr`. \n\n- `tac` : affiche des fichiers à l'envers.\n\n- `comm` : compare ligne à ligne deux fichiers triés.\n\n- `strings` : extrait du texte de fichiers binaires.\n\n- `tr` : conversion et manipulation de caractères.\n\n- `iconv` ou `uconv` : conversion entre différents encodages de caractères.\n\n- `split` et `csplit` : découpage de fichiers.\n\n- `sponge` : lit entièrement un flux d'entrée avant de l'écrire. Utile pour lire depuis un fichier puis écrire dans le même fichier, par exemple&nbsp;: `grep -v something some-file | sponge some-file`\n\n- `units` : conversions d'unités et calculs. Convertit des furlongs par fortnight en twips par blink (voir aussi `/usr/share/units/deifinitions.units`).\n\n- `apg` : génère des mots de passe aléatoires.\n\n- `xz` : compresse des fichiers avec un taux de compression élevé.\n\n- `ldd` : affiche des informations sur les bibliothèques partagées.\n\n- `nm` : affiche les symboles des fichiers objets.\n\n- `ab` ou [`wrk`](https://github.com/wg/wrk) : mesure les performances de serveurs web.\n\n- `strace`: trace les appels système.\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): un traceroute amélioré pour débugguer un réseau.\n\n- `cssh` : visual concurrent shell\n\n- `rsync` : synchronise des fichiers et des dossiers via SSH ou localement.\n\n- [`wireshark`](https://wireshark.org/) et [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): capture de paquets et dépannage réseau.\n\n- [`ngrep`](http://ngrep.sourceforge.net/) : grep pour les couches réseaux.\n\n- `host` et `dig`: interroge les serveurs DNS.\n\n- `lsof` : process file descriptor and socket info.\n\n- `dstat` : statistiques sur les ressources système.\n\n- [`glances`](https://github.com/nicolargo/glances): aperçu de haut niveau et multi-systèmes.\n\n- `iostat` : statistiques sur l'usage du disque.\n\n- `mpstat` : statistiques sur l'usage du CPU.\n\n- `vmstat` : statistiques sur l'usage de la mémoire.\n\n- `htop` : version améliorée de top.\n\n- `last` : historique des connexions.\n\n- `w` : montre qui est connecté.\n\n- `id` : affiche les informations sur un utilisateur et ses groupes.\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/) : statistiques sur l'activité du système\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ou [`nethogs`](https://github.com/raboof/nethogs) : utilisation du réseau par un socket ou un processus.\n\n- `ss` : statistiques relatives aux sockets.\n\n- `dmesg` : messages lors du démarrage et erreurs système.\n\n- `sysctl` : visualise et configure les paramètres du noyau Linux à chaud.\n\n- `hdparm` : manipulation et performances d'un disque SATA ou ATA.\n\n- `lsblk` : affiche les périphériques blocs (une arborescence de vos disques et de leurs partitions).\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode` : informations sur le matériel, comprenant le CPU, le BIOS, le RAID, la carte graphique, les périphériques, etc.\n\n- `lsmod` et `modinfo` : liste les modules du noyau et donne des informations sur un module.\n\n- `fortune`, `ddate` et `sl` : euh, bon, seulement si vous estimez que les locomotives à vapeur et les citations de Jean-Claude Van Damme sont « utiles ».\n\n\n## Uniquement macOS\n\nCe qui suit ne s'applique *qu'*à macOS.\n\n- Gestion des paquets avec `brew` (Homebrew) ou `port` (MacPorts).\nCeux-ci peuvent être utilisés pour installer sur macOS la plupart des commandes mentionnées ci-dessus.\n\n- Copier la sortie de n'importe quelle commande dans une application de bureau avec `pbcopy` et coller l'entrée d'une commande avec `pbpaste`.\n\n- Pour permettre à la touche Option de fonctionner comme la touche Alt dans le terminal de macOS (comme dans les commandes **alt-b**, **alt-f**, etc), allez dans Préférences -> Profils -> Clavier et sélectionner « Choisir la touche Option comme touche virtuelle ».\n\n- Pour ouvrir un fichier avec une application de bureau, utilisez `open` ou `open -a /Applications/Whatever.app`.\n\n- Spotlight&nbsp;: recherche de fichiers avec `mdfind` et affichage des métadonnées (telles que les informations EXIF d'une photo) avec `mdls`.\n\n- Ayez à l'esprit que macOS dérive du système Unix BSD et que beaucoup de commandes (par exemple `ps`, `ls`, `tail`, `awk`, `sed`) présentent de légères différences avec leurs versions pour Linux, qui lui est largement influencé par System V et les outils GNU.\nVous pouvez souvent faire la distinction grâce à l'en-tête « BSD General Commands Manual » dans les pages de manuel.\nDans certains cas, les versions GNU peuvent également être installées (telles que `gawk` et `gsed` pour GNU awk et GNU sed).\nPour écrire des scripts Bash multi-plateformes évitez d'utiliser de telles commandes (par exemple, envisagez d'utiliser Python ou Perl) ou alors testez-les soigneusement.\n\n- Pour obtenir des informations sur la version de macOS, utilisez `sw_vers`.\n\n\n## Uniquement Windows\n\nCe qui suit ne concerne que Windows.\n\n### Différentes manières d'obtenir les outils Unix sous Windows\n\n- Installez [Cygwin](http://cygwin.com) pour bénéficier de la puissance du shell Unix sous Microsoft Windows.\nLa majorité de ce qui est décrit dans ce document fonctionnera *out of the box*.\n\n- Sous Windows 10, [Windows Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about) fournit un environnement Bash avec les utilitaires en ligne de commandes d'Unix.\n\n- Si vous êtes surtout intéressés par les outils de developpement GNU (comme GCC) sur Windows, jetez un œil à [MinGW](http://www.mingw.org/) et à son package [MSYS](http://www.mingw.org/wiki/msys) qui fournit des utilitaires tels que bash, gawk, make et grep.\nMSYS ne dispose pas de toutes les fonctionnalités de Cygwin.\nMinGW est particulièrement utile pour porter sous Windows des outils Unix.\n\n- Une autre manière d'obtenir le *look and feel* d'Unix sous Windows est d'utiliser [Cash](https://github.com/dthree/cash).\nNotez que très peu de commandes Unix et d'options de ligne de commande sont disponibles dans cet environnement.\n\n### Outils en ligne de commande utiles pour Windows\n\n- Vous pouvez accomplir et scripter la plupart des tâches d'administration système de Windows depuis la ligne de commande à l'aide de `wmic`.\n\n- Parmi les outils réseaux en ligne de commande nativement disponibles sous windows que vous devriez trouver utiles, on trouve `ping`, `ipconfig`, `tracert` et `netstat`.\n\n- Vous pouvez effectuer [de nombreuses tâches sous Windows](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) en invoquant la commande `Rundll32`.\n\n### Trucs et astuces à propos de Cygwin\n\n- Installez des programmes Unix supplémentaires à l'aide du gestionnaire de paquets de Cygwin.\n\n- Utilisez `mintty` comme fenêtre de ligne de commande.\n\n- Accédez au presse-papier de Windows par `/dev/clipboard`.\n\n- Exécutez `cygstart` pour ouvrir un fichier quelconque avec l'application associée.\n\n- Accédez à la base de registres de Windows avec `regtool`.\n\n- Sachez qu'on accède au lecteur `C:\\` depuis Cygwin via `/cygdrive/c` et que le chemin Cygwin `\\` devient `C:\\cygwin` sous Windows.\nEffectuez des conversions entre les deux types de chemin avec l'utilitaire `cygpath`.\nC'est particulièrement utile pour invoquer des programmes Windows dans les scripts.\n\n## Autres ressources\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell)&nbsp;: une liste organisée d'outils et de ressources pour le shell.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)&nbsp;: un guide plus approfondi sur la ligne de commande pour macOS.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)&nbsp;: pour écrire de meilleurs scripts shell.\n- [shellcheck](https://github.com/koalaman/shellcheck)&nbsp;: un outil d'analyse statique des scripts shell. L'équivalent de lint pour bash, sh et zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)&nbsp;: les points de détail, malheureusement compliqués, sur la manière de manipuler correctement les noms de fichiers dans les scripts shell.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools)&nbsp;: d'autres outils en ligne de commande, utiles en science des données et discutés dans le livre du même nom.\n\n## Avertissement\n\nÀ l'exception des très petites tâches, le code est écrit de sorte que d'autres personnes puissent le lire.\nIl n'y a pas de pouvoir sans responsabilité : le fait que vous *puissiez* faire quelque chose en Bash ne signifie pas nécessairement que vous devriez le faire ! ;)\n\n\n## Licence\n\n[![Licence Creative Commons](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nCe document est mis à disposition selon les termes de la [Licence Creative Commons Attribution - Partage dans les mêmes conditions 4.0 International](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-id.md",
          "type": "blob",
          "size": 41.24,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# Seni dalam Baris Perintah\n\n[![Ajukan pertanyaan](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Bergabung dengan obrolan di https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Meta](#meta)\n- [Dasar-dasar](#dasar-dasar)\n- [Penggunaan sehari-hari](#penggunaan-sehari-hari)\n- [Mengolah berkas dan data](#mengolah-berkas-dan-data)\n- [Analisa Sistem](#analisa-sistem)\n- [Perintah satu baris](#perintah-satu-baris)\n- [Tidak penting tapi bermanfaat](#tidak-penting-tapi-bermanfaat)\n- [Khusus OS X](#khusus-os-x)\n- [Khusus Windows](#khusus-windows)\n- [Bacaan lebih lanjut](#bacaan-lebih-lanjut)\n- [Penyangkalan](#penyangkalan)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nMahir dalam baris perintah merupakan keahlian yang sering diabaikan atau masih dianggap misteri, tapi hal tersebut dapat meningkatkan fleksibilitas dan produktivitas sebagai seorang teknisi secara jelas. Halaman ini merupakan kumpulan catatan dan tips dalam menggunakan baris perintah sebagaimana yang kita ketahui sangat berguna ketika bekerja pada sistem Linux. Beberapa merupakan tips dasar, dan beberapa cukup spesifik, terkini, atau yang jarang digunakan. Halaman ini tidak panjang, tetapi jika anda dapat menggunakan dan mengingat semua perintah yang ada pada halaman ini, berarti anda memiliki pengetahuan yang cukup luas.\n\nProyek ini merupakan hasil dari banyak [penulis dan penerjemah](AUTHORS.md).\nBeberapa diantaranya [pertama kali](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[muncul](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\ndi [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nnamun kemudian dialihkan ke GitHub, dimana banyak orang-orang yang lebih berbakat dari penulis awal telah membuat banyak penyempurnaan.\n[**Silakan ajukan pertanyaan**](https://airtable.com/shrzMhx00YiIVAWJg) jika anda memiliki pertanyaan seputar perintah baris. [**Silakan berkontribusi**](/CONTRIBUTING.md) jika anda melihat ada kesalahan atau memiliki suatu ide yang lebih baik!\n\n## Meta\n\nBatasan masalah:\n\n- Panduan ini ditujukan bagi pemula dan yang telah berpengalaman. Tujuan utamanya cukup *luas* (segala hal adalah penting), *spesifik* (memberikan contoh kongkrit dari kasus yang umum terjadi), dan *ringkas* (hindari hal yang tidak penting atau menyimpang yang dapat ditemukan). Setiap tip adalah penting dalam beberapa kondisi atau dapat menjadi pilihan alternatif.\n- Ditulis untuk Linux, dengan pengecualian dari bagian \"[Khusus OS X](#os-x-only)\" and \"[Khusus Windows](#windows-only)\". Banyak yang menggunakan atau memasangnya dalam varian UNIX atau OS X lainnya (bahkan menggunakan Cygwin).\n- Berfokus pada Bash interaktif, meskipun banyak tip yang dapat digunakan pada terminal lainnya dan skrip Bash secara umum.\n- Mengandung perintah UNIX \"standar\" sebagaimana yang telah diketahui bahwa membutuhkan instalasi paket spesial -- selama dirasa cukup penting untuk diikut sertakan.\n\nCatatan:\n\n- Untuk menjaga tetap memungkinkan dalam satu halaman, materi tidak disertakan dengan referensi secara langsung. Anda cukup paham untuk mengetahui lebih detil mengenai penjelasan setiap perintah, misalnya menggunakan Google. Gunakan `apt-get`, `yum`, `dnf`, `pacman`, `pip` atau `brew` (seperlunya) untuk memasang program baru.\n- Gunakan [Explainshell](http://explainshell.com/) untuk bantuan mengenai perintah, opsi, saluran, dan lain sebagainya.\n\n\n## Dasar-dasar\n\n- Pelajari dasar Bash. Sebenarnya dengan mengetikkan `man bash` anda bisa mengetahui semuanya; sangat mudah untuk dilakukan dan cukup singkat. Sebagai alternatif terminal dapat menjadi menyenangkan, tapi Bash lebih baik dan selalu tersedia (hanya mempelajari *only* zsh, fish, etc., ketika menggunakan laptop pribadi anda, membatasi anda dalam banyak situasi, seperti menggunakan server yang sudah ada).\n\n- Pelajari setidaknya satu pengolah teks dengan baik. Secara ideal Vim (`vi`), yang mana merupakan pengolah teks berbasis terminal terbaik saat ini (meskipun anda menggunakan Emacs, sebuah IDE yang besar, atau pengolah teks modern yang unik sepanjang masa).\n\n- Ketahui cara membaca dokumentasi dengan `man` (sebagai informasi tambahan, `man man` menampilkan daftar bagian dalam bentuk nomor, misalnya 1 adalah perintah-perintah \"reguler\", 5 adalah berkas-berkas atau aturan-aturan, dan 8 adalah untuk administrasi). Temukan halaman `man` dengan `apropos`. Ketahui bahwa beberapa perintah tidak dapat dijalankan secara langsung, kecuali bawaan dari Bash, dan anda dapat mencari bantuan mengenai hal tersebut dengan `help` dan `help -d`. Anda dapat mencari tahu apakah suatu perintah dapat dijalankan langsung, perintah bawaan atau sebuah alias dapat diketahui dengan `type perintah`.\n\n- Pelajari tentang pengalihan hasil keluaran dan masukan menggunakan `>` dan `<` dan saluran menggunakan `|`. Ketahui bahwa `>` menimpa hasil keluaran dari sebuah berkas sedangkan `>>` menambahkan keluaran dibagian akhir dari berkas. Pelajari tentang `stdout` dan `stderr`.\n\n- Pelajari tentang penyebaran berkas dengan `*` (dan mungkin `?` dan `[`...`]`) dan tanda petik dan perbedaan antara petik dua `\"` dan petik sati `'`. (Penjelasan lebih lanjut pada penyebaran variabel dibawah.)\n\n- Biasakan diri dengan pengelolaan tugas pada Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, dan lain sebagainya.\n\n- Ketahui tentang `ssh`, dan dasar autentikasi tanpa kata kunci, melalui `ssh-agent`, `ssh-add`, dan lain sebagainya.\n\n- Dasar pengelolaan berkas: `ls` dan `ls -l` (pelajari juga maksud setiap kolom pada `ls -l`), `less`, `head`, `tail` dan `tail -f` (atau yang lebih baik, `less +F`), `ln` dan `ln -s` (pelajari perbedaan dan keuntungan menggunakan hard dan soft link), `chown`, `chmod`, `du` (untuk penjelasan singkat penggunaan disk: `du -hs *`). Untuk pengelolaan berkas sistem, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Pelajari apa itu inode (`ls -i` atau `df -i`).\n\n- Dasar pengelolaan jaringan: `ip` atau `ifconfig`, `dig`.\n\n- Pelejari dan gunakan sistem pengelolaan kontrol versi, seperti `git`.\n\n- Ketahui regular expression (regex) dengan baik, dan beberapa flags untuk `grep`/`egrep`. Flag `-i`, `-o`, `-v`, `-A`, `-B`, dan `-C` bermanfaat untuk dipelajari.\n\n- Pelajari cara menggunakan `apt-get`, `yum`, `dnf` atau `pacman` (tergantung distro yang digunakan) untuk melakukan instalasi paket. Dan pastikan anda mempunyai `pip` untuk menginstall alat baris perintah berbasis Python (dibawah ini beberapa lebih mudah diinstall menggunakan `pip`).\n\n\n## Penggunaan sehari-hari\n\n- Dalam Bash, gunakan **Tab** untuk melengkapi secara otomatis suatu perintah atau daftar perintah yang tersedia dan **ctrl-r** untuk mencari riwayat perintah (setelah ditekan, ketikan kata kunci yang ingin dicari, tekan **ctrl-r** untuk berpindah antara perintah-perintah yang sesuai, tekan **Enter** untuk menjalankan perintah, atau menekan tanda panah kanan di keyboard).\n\n- Dalam Bash, gunakan **ctrl-w** untuk untuk menghapus kata terakhir, dan **ctrl-u** untuk menghapus semua kata mulai dari baris pertama. Gunakan **alt-b** dan **alt-f** untuk memindahkan kata, **ctrl-a** untuk memindahkan kursor kebaris paling depan, **ctrl-e** untuk memindahkan kursor kebaris paling akhir, **ctrl-k** untuk menghentikan bagian akhir dari baris, **ctrl-l** untuk membersihkan layar tampilan. Lihat `man readline` untuk menampilkan semua kombinasi tombol yang ada dalam Bash. Ada cukup bnyak kombinasi. Contohnya **alt-.** berpindah melalui perintah sebelumnya, dan **alt-*** melebarkan glob.  \n\n- Sebagai alternatif, jika anda lebih sendang menggunakan gaya kombinasi `vi`, gunakan `set -o vi` (dan `set -o emacs` untuk mengembalikan kepengaturan awal).\n\n- Untuk mengelola perintah yang panjang, setelah melakukan pengaturan pengolah teks (sebagai contoh `export EDITOR=vim`), menekan kombinasi **ctrl-x** **ctrl-e** akan membuka perintah saat ini pada pengolah teks untuk melakukan pengelolaah secara langsung. Atau dalam gaya `vi`, **escape-v**.\n\n- Untuk melihat perintah terakhir yang digunakan, `history`. Tambahkan `!n` dibagian akhir (dimana `n` merupakan jumlah perintah) untuk dijalankan kembali. Terdapat beberapa penyingkatan yang dapat digunakan, diantaranya yang paling sering digunakan `!$` untuk parameter terakhir dan `!!` untuk perintah terakhir (baca \"HISTORY EXPANSION\" pada halaman manual `man`). Bagaimanapun, sering digantikan dengan kombinasi **ctrl-r** dan **alt-.**.\n\n- Pindah ke direktori home dengan `cd`. Akses berkas yang berada dibawah direktori home dengan awalan `~` (misalnya `~/.bashrc`). Dalam skrip `sh` direktori home dinyatakan dalam `$HOME`.\n\n- Untuk kembali ke direktori sebelumnya: `cd -`.\n\n- Jika dalam menulis perintah anda berubah fikiran, tekan **alt-#** untuk menambahkan `#` pada awal perintah untuk menjadikannya sebuah komentar (atau **ctrl-a**, **#**, **enter**). Selanjutnya anda dapat mengakses perintah tersebuh dikemudian dengan menggunakan `history`.\n\n- Gunakan `xargs` (atau `parallel`). Sangat bagus. Anda dapat mengontrol berapa banyak item yang dapat dijalankan per-baris (`-L`) atau menjalankannya secara bersamaan (`-P`). Jika anda tidak yakin hal tersebut akan berjalan dengan baik, gunakan `xargs echo` terlebih dahulu. Atau `I{}` juga sangat bermanfaat. Contohnya:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` dapat membantu menampilkan daftar proses yang sedang berjalan.\n\n- Gunakan `pgrep` dan `pkill` untuk mencari proses sinyal berdasarkan nama (`-f` juga cukup membantu).\n\n- Pelajari jenis sinyal yang dapat dikirimkan ke proses. Contoh, untuk menunda sebuah proses, gunakan `kill -STOP [pid]`. Untuk daftar semua sinyal, lihat `man 7 signal`.\n\n- Gunakan `nohup` atau `disown` untuk membuat proses tetap berjalan selamanya.\n\n- Lihat kemana sebuah proses terhubung (listening) melalui `netstat -lntp` atau `ss -plat` (untuk TCP, gunakan `-u` untuk UDP).\n\n- Lihat juga `lsoft` untuk membuka socket dan berkas.\n\n- Lihat `uptime` atau `w` untuk mengetahui berapa sistem sudah berjalan (aktif).\n\n- Gunakan `alias` untuk membuat jalan pintas untuk perintah-perintah yang sering digunakan. Misalnya, `alias ll='ls -latr'` akan menghasilkan alias `ll`.\n\n- Menyimpan alias, pengaturan shell, dan fungsi yang sering digunakan di `~/.bashrc`, dan [atur shell untuk dibaca ketika login](http://superuser.com/a/183980/7106). Hal tersebut akan membuat pengaturan dapat berjalan disemua sesi.\n\n- Letakkan pengaturan dari variabel sebagai perintah yang akan dijalankan ketika login di `~/.bash_profile`. Pisahkan konfigurasi yang dibutuhkan untuk menjalankan grafik login dan tugas-tugas `cron`.\n\n- Singkronkan berkas konfigurasi (seperti `.bashrc` dan `.bash_profile`) pada banyak komputer dengan Git.\n\n- Pahami bahwa dibutuhkan perhatian lebih ketika variabel dan nama berkas mengandung spasi. Batasi variabel Bash dengan tanda petik, misalnya `\"$FOO\"`. Sebaiknya gunakan opsi `-0` atau `-print0` untuk membuat karakter null dalam membatasi nama berkas, misalnya `locate -0 pattern | xargs -0 ls -al` atau `find / -print0 -type d | xargs -0 ls -al`.  Untuk membuat perulangan nama berkas yang mengandung spasi dalam `for`, atur IFS sebagai baris baru dengan `IFS=$'\\n'` .\n\n- Dalam skrip Bash, gunakan `set -x` (atau lainnya `set -v`, yang mana akan menamilkan raw masukan dalam log, termasuk variabel dan komentar) untuk keperluan debugging. Gunakan mode `strict` kecuali ada alasan lebih baik untuk tidak menggunakan `set -e` untuk membatalkan perintah ketika terjadi kesalahan (kode exit tidak 0). Gunakan `set -u` untuk mendeteksi variabel yang belum ditentukan tapi sudah digunakan. Pertimbangkan `set -o pipefail` juga, untuk kesalahan didalam saluran. Untuk skrip terkait, gunakan `trap` pada EXIT atau ERR. Disarankan untuk memulai dari skrip berikut, dimana akan mendeteksi dan membatalkan perintah ketika terjadi kesalahan tertentu kemudian menampilkannya dalam pesan:\n```bash\n      set -euo pipefail\n      trap \"echo 'Kesalahan: Skrip gagal: harap periksa kembali perintah yang anda masukkan'\" ERR\n```\n\n- Dalam skrip Bash, bagian dalam shell (ditulis didalam tanda kurung) merupakan cara terbaik untuk menggabungkan perintah. Sebuah contoh yang sering digunakan adalah berpindah ke direktori kerja yang lain, contohnya:\n```bash\n      # melakukan sesuatu dalam direktori kerja saat ini\n      (cd /direktori/kerja/lainnya && suatu-perintah)\n      # melanjutkan pekerjaan dalam direktori yang sebenarnya\n```\n\n- Dalam Bash, ada banyak jenis dari pengembangan variabel. Memeriksa ketersediaan variabel: `$(nama_variabel:?pesan kesalahan)`. Sebagai contoh, jika skrip membutuhkan sebuah parameter, cukup menulis `berkas_masukan=$(1:?penggunaan: $0 berkas_masukan)`. Contoh dalam aritmatika: `i=$(( (i + 1) % 5 ))`. Urutan: `{1..10}`. Pemangkasan string: `${var%akhiran}` dan `${var#awalan}`. Sebagai contoh jika `var=foo.pdf`, maka `echo ${var%.pdf}.txt` akan menghasilkan `foo.txt`.\n\n- Kurung kurawal `{`...`}` dapat mengurangi kesalahan dama mengetik teks yang sama dan membuat kombinasi dari banyak item secara otomatis. Ini sangat membantu misalnya dalam perintah `mv foo.{txt,pdf} suatu-direktori` (memindahkan kedua berkas sekaligus), `cp suatuberkas{,.bak}` (memiliki makna sama dengan `cp suatuberkas suatuberkas.bak`) atau `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (memiliki makna membuat semua kemungkinan kombinasi untuk struktur direktori).\n\n- Keluaran dari perintah dapat diperlakukan sebagai sebuah berkas dengan `<(suatu perintah)`. Misalnya, membandingkan `/etc/hosts` yang ada pada lokal dengan server:\n```sh\n      diff /etc/hosts <(ssh suatuserver cat /etc/hosts)\n```\n\n- Ketika menulis skrip disarankan untuk membatasi semua kode dalam kurung kurawal. Jika penutuh kurung kurawal tidak ditemukan, skrip tidak dapat dijalankan karena terjadi kesalahan. Hal ini biasanya terjadi ketika mengunduh skrip dari web, kemungkinan beberapa bagian dari skrip yang telah diunduh sengaja ditulis untuk menghindari eksekusi:\n```bash\n{\n      # Kode disini\n}\n```\n\n- Ketahui tentang \"here documents\" dalam Bash dengan `cat <<EOF...`.\n\n- Dalam Bash, arahkan keluaran standar dan kesalahan melalui: `suatu-perintah > berkaslog 2>&1` atau `suatu-perintah &>berkaslog`. Biasanya, untuk memastikan suatu perintah tidak meninggalkan berkas tetap terbuka setelah menerima masukan, coba pada terminal anda saat ini, merupakan hal baik untuk menambahkan `</dev/null`.\n\n- Gunakan `man ascii` untuk melihan tabel ASCII, dengan nilai hex dan decimal. Untuk informasi umum mengenai unicode, `man unicode`, `man utf-8`, dan `man latin1` juga sangat berguna.\n\n- Gunakan `screen` atau [`tmux`](https://tmux.github.io/) untuk tampilan multi layar, terutama sangat bermanfaat dalam sesi ssh, melepas dan menyambung kembali sebuah sesi. `byobu`\n- Use `screen` or [`tmux`](https://tmux.github.io/) to multiplex the screen, especially useful on remote ssh sessions and to detach and re-attach to a session. `byobu` can enhance screen or tmux providing more information and easier management. A more minimal alternative for session persistence only is [`dtach`](https://github.com/bogner/dtach).\n\n- Dalam ssh, mengetahui bagaimana cara menggunaakn saluran (port tunnel) dengan `-L` atau `-D` (dan terkadang `-R`) juga berguna. Misalnya untuk mengakses situs web dari kendali server jarak jauh.\n\n- Akan sangat bermanfaat untuk melakukan optimisasi pada konfigurasi ssh; misalnya, `~/.ssh/config` mengandung pengaturan untuk menghindari putusnya koneksi antar jaringan, menggunakan kompresi (bermanfaat bagi yang memiliki bandwidth rendah), dan terhubung dengan banyak saluran pada suatu server dengan kontrol lokal:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Beberapa opsi lain untuk SSH terkait sensitifitas keamanan dan sebaiknya diaktifkan dengan hati-hati, misalnya pada subnet atau host atau pada jaringan yang terpercaya: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Pertimbangkan [`mosh`](https://mosh.org/) sebagai alternatif untuk SSH yang mana menggunakan UDP, dapat menjaga terputusnya koneksi dan lebih nyaman untuk digunakan (perlu konfigurasi disisi server).\n\n- Untuk mendapatkan hak akses pada sebuah berkas, yang mana berguna untuk konfigurasi sistem tapi tidak tersedia pada `ls`, gunakan perintah perikut\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Untuk memilih nilai keluaran dari perintah lain secara interaktif, gunakan [`percol`](https://github.com/mooz/percol) or [`fzf`](https://github.com/junegunn/fzf).\n\n- For interaction with files based on the output of another command (like `git`), use `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- For a simple web server for all files in the current directory (and subdirs), available to anyone on your network, use:\n`python -m SimpleHTTPServer 7777` (for port 7777 and Python 2) and `python -m http.server 7777` (for port 7777 and Python 3).\n\n- For running a command with privileges, use `sudo` (for root) or `sudo -u` (for another user). Use `su` or `sudo bash` to actually run a shell as that user. Use `su -` to simulate a fresh login as root or another user.\n\n- Untuk berganti ke pengguna Shell lain, gunakan `su username` atau `su - username`. Sertakan `-` untuk mendapatkan lingkungan jika pengguna telah login. Hindari menggunakan username menjadi root. Anda akan dimintai password _untuk pengguna yang ingin diganti_.\n\n- Ketahui [batasan 128k](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) pada sebuah perintah. Kesalahan \"Argument list too long\" sering terjadi ketika karakter (wildcard) mewakili berkas yang sangat banyak. (Saat ini terjadi dapat menggunakan `find` dan `xargs` sebagai bantuan.)\n\n- Untuk sebuah perhitungan dasar (secara umum akses Python), gunakan interpreter `python`. Contohnya,\n```\n>>> 2+3\n5\n```\n\n## Mengolah berkas dan data\n\n- Untuk menemukan berkas berdasarkan nama dalam direktori saat ini, `find . -iname '*sesuatu*'` (atau yang mirip). Untuk mencari berkas dibanyak tempat berdasarkan nama, gunakan `locate sesuatu` (tapi ingat `updatedb` mungkin belum menyimpan berkas terbaru yang dibuat).\n\n- Untuk pencarian umum berdasarkan isi berkas (lebih dalam dibandingkan dengan `grep -r`), gunakan [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Untuk mengkonversi HTML menjadi teks: `lynx -dump -stdin`\n\n- Untuk Markdown, HTML, dan semua jenis konversi dokumen, coba [`pandoc`](http://pandoc.org/).\n\n- Jika anda mengelola XML, `xmlstarlet` adalah pilihan yang paling tua namun terbaik.\n\n- Untuk JSON, gunakan [`jq`](http://stedolan.github.io/jq/).\n\n- Untuk YAML, gunakan [`shyaml`](https://github.com/0k/shyaml).\n\n- Untuk Excel atau berkas CSV, [csvkit](https://github.com/onyxfish/csvkit) menyediakan `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, dan lain sebagainya.\n\n- Untuk Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) lebih nyaman digunakan dan [`s4cmd`](https://github.com/bloomreach/s4cmd) lebih cepat. Amazon [`aws`](https://github.com/aws/aws-cli) dan yang telah dikembangkan [`saws`](https://github.com/donnemartin/saws) tetap penting untuk pekerjaan yang berhubungan dengan AWS lainnya.\n\n- Ketahui tentang `sort` dan `uniq`, termasuk opsi `-u` dan `-d` -- lihat Perintah satu baris dibawah. Lihat juga `comm`.\n\n- Ketahui tentang `cut`, `paste`, dan `join` dalam memanipulasi teks pada berkas. Banyak orang menggunakan `cut` tapi melupakan tentang `join`.\n\n- Ketahui tentang `wc` untuk menghitung jumlah baris (`-l`), karakter (`-m`), kata (`-w`) dan byte (`-c`).\n\n- Ketahui tentang `tee` untuk menyalin dari stdin sebuah berkas ke stdout, seperti dalam `ls -al | tee file.txt`.\n\n- Untuk kalkulasi yang cukup kompleks, termasuk pengelompokan, konversi nilai, dan statistik, pertimbangkan untuk menggunakan [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Ketahui bahwa locale cukup berdampak pada banyak perintah, termasuk pengurutan (pemeriksaan) dan dan kinerja. Kebanyakan distribusi Linux akan menggunakan `LANG` atau variabel locale lainnya untuk melakukan pengaturan bahasa seperti ID Indonesia. Tapi waspada karena pengurutan akan berubah jika locale juga telah dirubah. Dan ketahui aktifitas i18n dapat membuat banyak perintah *seringkali* menjadi lambat. Dalam kondisi tertentu (seperti beberapa perintah operasi dibawah) anda dapat menghindari i18n dan menggunakan pengurutan tradisional, gunakan `export LC_ALL=C`.\n\n- Anda dapat menentukan perintah tertentu dengan memberikan awalan saat pemanggilan dengan variabel pengaturan, seperti `TZ=Pacific/Fiji date`.\n\n- Ketahui mengenai dasar `awk` dan `sed` untuk manipulasi data. Sebagai contoh, menjumlahkan semua nomor yang ada pada kolom ketiga dari sebuah berkas: `awk '{ x += $3 } END { print x }'`. Ini memungkinkan komputasi 3x lebih cepat dan 3x lebih singkat dibandingkan dengan persamaan Python.\n\n- Untuk mengganti semua string yang cocok, dalam satu atau lebih dari satu berkas:\n```sh\n      perl -pi.bak -e 's/string-lama/string-baru/g' my-files-*.txt\n```\n\n- Untuk mengganti nama banyak berkas atau mencari dan/atau mengganti dalam berkas, coba [`repren`](https://github.com/jlevy/repren). (Dalam beberapa kasus perintah `rename` memungkinkan untuk mengganti banyak nama sekaligus, namun perlu berhati-hati karena fungsionalitas mungkin tidak akan sama pada distribusi Linux lainnya.)\n```sh\n      # Mengganti nama berkas, direktori, dan isi berkas secara penuh dari foo --> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Mengembalikan backup berkas whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Sama seperti diatas, menggunakan rename, jika ada yang cocok:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Sesuai dengan yang ada pada halaman manual, `rsync`  adalah perintah untuk menyalin berkas yang cukup cepat dan memiliki banyak fitur. Mampu melakukan singkronisasi antar host yang mana sangat berguna untuk host lokal. Jika keamanan tidak diutamakan, gunakan `rsync` daripada `scp` untuk pemulihan tanpa harus mengulang dari awal. Perintah tersebut merupakan [cara tercepat](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) untuk menghapus banyak berkas sekaligus:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Gunakan `shuf` untuk mengacak atau memilih baris secara acak dalam sebuah berkas.\n\n- Ketahui perintah `sort`. Untuk angka, funakan opsi `-n`, atau `-h` untuk menampilkan angka yang mudah dibaca manusia (contoh `du -h`). Ketahui bagaimana cara kerja kunci (`-t` dan `-k`).  Terkadang membutuhkan `k1,1` untuk mengurutkan kolom pertama saja; `k1` berarti mengurutkan semua barus.  Pengurutan yang stabil (`sort -s`) juga cukup berguna. FContoh, untuk mengurutkan yang pertama berdasarkan kolom 2, yang kedua berdasarkan kolom 1, akan menjadi `soft -k1,1 | sort -s -k2m2`.  \n\n- Jika perlu untuk membuat tab pada terminal dalam Bash (misalnya argumen `-t` untuk mengurutkan), tekan **ctrl-v** **[Tab]** atau dengan menulis `$'\\t'` (menulis langsung lebih baik dari copy/paste).\n\n- Alat yang umum digunakan untuk menambal sumber kode adalah `diff` dan `patch`. Lihat juga `diffstat` untuk hasil berupa statistik dari `diff` dan `sdiff`. Ingat bahwa `diff -r` berlaku pada semua direktori. Gunakan `diff -r tree1 tree2 | diffstat` untuk ringkasan perubahan. Gunakan `vimdiff` untuk membandingkan dan memperbarui berkas.\n\n- Untuk berkas binari, gunakan `hd`, `hexdump` atau `xxd` untuk menampilkan kode hex yang sederhana dan `bvi` atau `blew` untuk memperbarui berkas biner.\n\n- Alat lainnya untuk berkas biner, `strings` (dikombinasikan dengan `grep`, dan lainnya) memungkinkan pencarian teks berdasarkan bit-bit.\n\n- Untuk membandingkan berkas biner (kompresi delta), gunakan `xdelta3`.\n\n- Untuk mengkonversi sandi penulisan teks, coba `iconv`. Atau `uconv` untuk penggunaan lebih lanjut; telah mendukung hal yang berkaitan dengan Unicode. Sebagai contoh, perintah berikut membuat tulisan kecil dan menghapus semua aksen (dengan mengembangkan atau menghapusnya).\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n- Untuk memecah berkas menjadi beberapa bagian, lihat `split` (memisahkan berdasarkan ukuran) dan `csplit` (memisahkan berdasarkan pola).\n\n- Untuk memanipulasi tanggal dan waktu, gunakan `dateadd`, `datediff`, `strptime` etc. dari [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Gunakan `zless`, `zmore`, `zcat`, dan `zgrep` untuk digunakan pada berkas yang terkompres.\n\n- Atribut dari sebuah berkas dapat diset melalui `chattr` dan disediakan alternatif untuk level terendah pada hak akses berkas. Sebagai contoh, untuk melindungi ketidak sengajaan pada penghapusan berkas gunakan flag kebal: `sudo chattr +i /direktori/berkas/penting`\n\n- Gunakan `getfacl` dan `setfacl` untuk menyimpan dan mengembalikan hak akses pada suatu berkas. Contohnya:\n```sh\n   getfacl -R /suatu/path > hakakses.txt\n   setfacl --restore=hakakses.txt\n```\n\n## Analisa sistem\n\n- Untuk analisa web, `curl` dan `curl -I` cukup berguna, atau yang sama lainnya seperti `wget`, atau yang lebih modern [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Untuk mengetahui status CPU/penyimpanan, perintah klasik `top` (lebih baik lagi `htop`), `iostat`, dan `iotop`. Gunakan `iostat -mxz 15` untuk melihat detil CPU tiap bagian (partition) penyimpanan dan pengetahuan tentang kinerja.\n\n- Untuk detail koneksi jaringan, gunakan `netstat` dan `ss`.\n\n- Untuk melihat sekilas yang terjadi pada sistem, `dstat` cukup berguna. Untuk detil secara menyeluruh, gunakan [`glances`](https://github.com/nicolargo/glances).\n\n- Untuk status memory, jalankan dan perhatikan keluaran dari `free` dan `vmstat`. Dalam kondisi tertentu, hati-hati terhadap \"cached\" yang dihasilkann oleh kernel Linux, jadi perhatikan sebaik mungkin keluaran dari `free`.\n\n- Analisa sistem Java sedikit berbeda, tapi ada trik sederhana untuk JVM dari Oracle dan yang lainnya yakni dapat dijalankan perintah `kill -3 <pid>` dan penelusuran (full stack trace) dan beberapa ringkasan utama (termasuk informasi pembangkitan sampah sistem, informasi yang sangat berguna) akan dikeluarkan melalui stderr/logs. JDK seperti `jps`, `jstat`, jstack`, `jmap` cukup berguna. [Perlengkapan SJK](https://github.com/aragozin/jvm-tools) untuk penggunaan lebih lanjut.\n\n- Gunakan [`mtr`](http://www.bitwizard.nl/mtr/) sebagai pilihan terbaik `traceroute`, untuk menelusuri masalah jaringan.\n\n- Untuk mengungkapkan kenapa penyimpanan penuh, perintah [`ncdu`](https://dev.yorhel.nl/ncdu) lebih menghemat waktu dibangdingkan `du -sh *`.\n\n- Untuk mencari socket atau process yang sedang menggunakan bandwidth, coba [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) atau [`nethogs`](https://github.com/raboof/nethogs).\n\n- Perintah `ab` (paket dari Apache) sangat berguna untuk melihat kinerja dari server web. Untuk test lebih lanjut, gunakan `siege`.\n\n- Untuk analisa jaringan yang lebih serius, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), atau [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Ketahui tentang `strace` dan `ltrace`. Perintah tersebut membantu ketika sebuah program gagal, hang, atau crash secara tiba-tiba, atau jika ingin mengetahui kinerja aplikasi secara umum. Catatan gunakan opsi profiling (`-c`), dan kemampuan untuk menertakan proses yang sedang berjalan (`-p`).\n\n- Ketahui tentang `ldd` untuk memeriksa pustaka berbagi dan sebagainya.\n\n- Ketahui bagaimana cara terhubung dengan proses yang sedang berjalan dengan `gdb` dan periksa alur stack-nya.\n\n- Gunakan `/proc` untuk melakukan analisis permasalahan secara live. Contohnya: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (dimana `xxx` adalah ID proses id atau pid).\n\n- Untuk mengetahui kesalahan yang terjadi pada proses analisa sebelumnya, gunakan [`sar`](http://sebastien.godard.pagesperso-orange.fr/). Perintah tersebut dapat menampilkan riwayat statistik pada CPU, memory, jaringan, dan lain sebagainya.\n\n- Untuk analisa kinerja sistem lebih mendalam, periksa `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux)), dan [`sysdig`](https://github.com/draios/sysdig).\n\n- Periksa Sistem Operasi yang digunakan dengan `uname` atau `uname -a` (Unix/kernel pada umumnya) atau `lsb_release -a` (distro linux).\n\n- Gunakan `dmesg` ketika terjadi sesuatu yang tidak disangka (mungkin masalah perangkat kerasa atau driver).\n\n- Jika anda menghapus sebuah berkas dan tidak dapat meningkatkan kapasitas media penyimpanan sebagaimana hasil pengecekan `du`, periksa kemungkinan berkas tersebut sedang digunakan oleh suatu proses:\n`lsof | grep deleted | grep \"berkas-yang-sangat-besar\"`\n\n\n## Perintah satu baris\n\nBeberapa contoh untuk menggabungkan perintah sekaligus:\n\n- Terkadang cukup membantu ketika ingin mencari kesamaan, kesatuan, dan perbedaan dari beberapa berkas melalui `sort`/`uniq`. Misalkan `a` dan `b` adalah berkas yang berbeda. Perintah ini cukup cepat, dan dapat bekerja pada berkas dengan ukuran sampai gigabyte. (Pengurutan tidak dibatasi oleh memory, tapi diperlukan opsi `-T` jika `/tmp` berada dalam partisi root yang kecil.) Lihat juga catatan tentang `LC_ALL` diatas dan opsi yang terdapat pada `sort` (penjelasan lebih jelas dibawah berikut).\n```sh\n      cat a b | sort | uniq > c   # c berisi kesatuan antara a dan b\n      cat a b | sort | uniq -d > c   # c berisi persamaan antara a dan b\n      cat a b b | sort | uniq -u > c   # c berisi perbedaan antara a dan b\n```\n\n- Gunakan `grep . *` untuk menguji isi dari semua berkas dalam sebuah direktori (hasil tiap berisnya berkaitan dengan nama berkas), atau `head -180 *` (setiap berkas memiliki informasi kepala). Hal ini sangat bermanfaat untuk direktori yang berisi berkas konfigurasi seperti `/sys`, `/proc`, `/etc`.\n\n- Untuk menjumlahkan semua nomor pada kolom ketiga dari sebuah berkas (memungkinkan proses 3x lebih cepat dan skrip 3x lebih pendek dari Python):\n```sh\n      awk '{ x += $3 } END { print x }' suatuberkas\n```\n\n- Untuk melihat ukuran atau tanggal berkas dalam bentuk struktur pohon, mirip dengan rekursif `ls -l` namun lebih mudah untuk dibaca dari `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Ketika terdapat sebuah berkas teks seperti log web server, dan nilai tertentu muncul pada beberapa baris, misalnya parameter `acct_id` yang terdapat pada URL. Jika ingin mengetahui berapa banyak akses `acct_id`:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Untuk memantau perubahan secara terus menerus, gunakan `watch`, misalnya perubahan berkas pada sebuah direktori, gunakan `watch -d -n 2 'ls -rtlh | tail` atau pada pengaturan jaringan wifi ketika melakukan perbaikan dengan `watch -d -n 2 ifconfig`.\n\n- Jalankan fungsi berikut untuk mendapatkan sesuatu yang acak dari dokumen ini (mengolah Markdown dan mengeluarkan sebuah item):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## Tidak penting tapi bermanfaat\n\n- `expr` : melakukan perhitungan aritmatika atau mengevaluasi regular expression (regex)\n\n- `m4` : pemroses macro yang sederhana\n\n- `yes` : menampilkan cukup banyak string\n\n- `cal` : menampilkan kalender\n\n- `env` : menjalankan sebuah perintah (berguna dalam skrip)\n\n- `printenv` : menampilkan variabel environment (berguna dalam analisa dan skrip)\n\n- `look` : mencari kata dalam bahasa English (atau baris dalam sebuah berkas) diawali dengan sebuah string\n\n- `cut`, `paste` dan `join`: manipulasi data\n\n- `fmt`: teks dengan format paragraf\n\n- `pr`: teks dengan format halaman/kolom\n\n- `fold`: membatasi baris dari teks\n\n- `column`: membuat format teks jadi rata, lebar kolom tertentu atau bentuk tabel\n\n- `expand` dan `unexpand`: konversi antara tab dan spasi\n\n- `nl`: menambahkan baris baru\n\n- `seq`: menampilkan angka\n\n- `bc`: kalkulator\n\n- `factor`: angka faktorial\n\n- [`gpg`](https://gnupg.org/): mengenkripsi dan menandatangani berkas\n\n- `toe`: isi dari tabel terminfo\n\n- `nc`: analisa jaringan dan aktifitas datanya\n\n- `socat`: jalur tunda dan penerus jalur tcp (mirip dengan `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): visualisasi aktifitas jaringan\n\n- `dd`: memindahkan data antar berkas atau perangkat\n\n- `file`: identifikasi jenis dari berkas\n\n- `tree`: menampilkan struktur pohon dari direktori dan subdirektori secara bersarang; mirip `ls` namun dapat rekursif\n\n- `stat`: informasi berkas\n\n- `time`: menjadwalkan dan menjalankan sebuah perintah\n\n- `timeout`: menjalankan sebuah perintah dalam waktu yang telah ditentukan dan melanjutkan kembali dalam waktu yang telah ditentukan pula.\n\n- `lockfile`: membuat berkas dengan tanda hanya dapat dihapus oleh `rm -f`\n\n- `logrotate`: menggulirkan, mengkompres serta mengirimkan via email berkas logs\n\n- `watch`: menjalankan program secara berulang, menampilkan hasil dan/atau memfokuskan pada perubahan\n\n- `tac`: menmapilkan kebalikan dari berkas\n\n- `shuf`: memilih baris secara acak dari sebuah berkas\n\n- `comm`: membandingkan berkas yang terurut berdasarkan baris\n\n- `pv`: memantau perkembangan data yang melalui sebuah saluran\n\n- `hd`, `hexdump`, `xxd`, `biew` dan `bvi`: menampilkan atau memperbaiki berkas dalam biner\n\n- `strings`: mengeluarkan teks dari berkas biner\n\n- `tr`: konversi atau menipulasi sebuah karakter\n\n- `iconv` atau `uconv`: konversi kode teks\n\n- `split` dan `csplit`: membagi berkas\n\n- `sponge`: membaca semua masukan sebelum menuliskannya, berguna untuk membaca dan menulis pada berkas yang sama, misalnya `grep -v sesuatu nama-berkas | sponge nama-berkas`\n\n- `units`: konversi dan kalkulasi unit; mengkonversi jarak mil per dua minggu (lihat juga `/usr/share/units/definitions.units`)\n\n- `apg`: membangkitkan kata kunci acak\n\n- `xz`: kompresi berkas dengan rasio yang tinggi\n\n- `ldd`: informasi dynamic library\n\n- `nm`: simbil dari objek berkas\n\n- `ab`: patokan untuk web server\n\n- `strace`: analisa sistem pemanggilan\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): traceroute yang lebih baik untuk analisa jaringan\n\n- `cssh`: visual shell dalam jumlah banyak secara bersamaan\n\n- `rsync`: singkronisasi berkas dan direktori melalui SSH atau berkas sistem dalam satu mesin\n\n- [`wireshark`](https://wireshark.org/) dan [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): penangkap paket dan analisa jaringan\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep untuk jaringan\n\n- `host` dan `dig`: pencarian DNS\n\n- `lsof`: deskripsi berkas process dan informasi socket\n\n- `dstat`: berguna untuk statistik sistem\n\n- [`glances`](https://github.com/nicolargo/glances): tingkat tinggi, informasi singkat banyak subsistem\n\n- `iostat`: statistik penggunaan penyimpanan\n\n- `mpstat`: statistik penggunaan CPU\n\n- `vmstat`: statistik penggunaan memory\n\n- `htop`: versi terbaru dari top\n\n- `last`: riwayat login\n\n- `w`: melihat siapa yang sedang login\n\n- `id`: informasi identitas pengguna atau grup\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): riwayat statistik sistem\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) or [`nethogs`](https://github.com/raboof/nethogs): penggunaan jaringan berdasarkan socket atau process\n\n- `ss`: statistik socket\n\n- `dmesg`: pesan ketika boot dan sistem error\n\n- `sysctl`: melihat dan mengkonfigurasi parameter kernel Linux saat sedang berjalan\n\n- `hdparm`: manipulasi atau melihat kinerja media SATA/ATA\n\n- `lsblk`: daftar blok perangkat: berbentuk struktur pohon yang berisi media penyimpanan beserta partisinya\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informasi perangkat keras, termasuk CPU, BIOS, RAID, grafis, dan lain sebagainya.\n\n- `lsmod` and `modinfo`: menampilkan daftar dan detil modul kernel\n\n- `fortune`, `ddate`, dan `sl`: tergantung bagaimana anda menyebutnya \"bermanfaat\"\n\n\n## Khusus OS X\n\nBerikut ini *hanya* berlaku pada OS X.\n\n- Manajemen paket menggunakan `brew` (homebrew) dan/atau `port` (MacPorts). Dapat digunakan untuk memasang banyak aplikasi OS X untuk menggunakan perintah-perintah diatas.\n\n- Salin keluaran dari perintah ke aplikasi desktop menggunakan `pbcopy` dan tempel menggunakan `pbpaste`.\n\n- Untuk mengaktifkan tombol Option pada aplikasi Terminal OS X sebagai tombol alt (seperti menggunakan perintah diatas **alt-b**, **alt-f**, dan lain sebagainya), buka Preferences -> Profiles -> Keyboard dan pilih \"Use Option as Meta key\".\n\n- Untuk membuka berkas pada aplikasi desktop, gunakan `open` atau `open -a /Applications/namaaplikasi.app`.\n\n- Spotlight: Mencari berkas dengan `mdfind` dan menampilkan metadata (seperti info EXIF foto) dengan `mdls`.\n\n- Berhati-hati karena OS X berbasis pada BSD Unix, dan banyak perintah (seperti `ps`, `ls`, `tail`, `awk`, `sed`) beberapa memiliki varian yang berbeda dengan Linux, yang mana akan berdampak besar pada System V-style Unix dan peralatan GNU lainnya. Perbedaannya dapat diketahui dengan mencari pada halaman manual \"BSD General Command Manual\". Pada beberapa kasus versi GNU dapat dipasang juga (seperti `gawk` dan `gsed` untuk GNU awk dan sed). Ketika menulis skrip Bash lintas platform, hundari beberapa perintah (seperti mempertimbangkan Python atau `perl`) atau coba kembali dengan hati-hati.\n\n- Untuk mendapatkan informasi rilis OS X, gunakan `sw_vers`.\n\n## Hanya Windows\n\nBerikut ini *hanya* berlaku pada Windows.\n\n- Pada Windows 10, anda dapat menggunakan [Bash di Ubuntu pada Windows](https://msdn.microsoft.com/commandline/wsl/about), dimana menyediakan lingkungan Bash yang mirip dengan perintah baris pada lingkungan Unix. Sebagai tambahan, memungkinkan program Linux untuk berjalan pada Windows. Namun disisi lain tidak memungkinkan untuk menjalankan aplikasi windows melalui jendela Bash.\n\n- Akses fasilitas dari Shell Unix pada Microsoft Windows dengan memasang [Cygwin](https://cygwin.com/). Banyak hal telah dijelaskan pada dokumen ini akan bekerja secara normal.\n\n- Pasang program Unix tambahan dengan paket manajer Cygwin.\n\n- Gunakan `mintty` sebagai aplikasi perintah baris.\n\n- Akses clipboard pada Windows pada `/dev/clipboard`.\n\n- Gunakan `cygstart` untuk membuka berkas melalui aplikasi yang telah terdaftar.\n\n- Akses registry pada Windows dengan `regtool`.\n\n- Ingat bahwa `C:\\` Windows akan menjadi `/cygdrive/c` pada Cygwin, dan `/` pada Cygwin akan berada di `C:\\cygwin` pada Windows. Konversi antara Cygwin dan gaya Windows file path dengan `cygpath`. Hal ini berguna dalam skrip yang menjalankan program Windows.\n\n- Anda dapat menjalankan skrip sistem administrasi pada Windows dari perintah baris dengan mempelajari dan menggunakan `wmic`.\n\n- Pilihan lainnya untuk membuat mendapatkan Unix pada Windows adalah [Cash](https://github.com/dthree/cash). Sebagai catatan bahwa hanya tersedia beberapa fasilitas perintah baris Unix yang tersedia dalam lingkungan ini.\n\n- Sebagai pilihan alternatif untuk mendapatkan alat pengembangan dalam GNU (seperti GCC) pada Windows adalah [MinGW](http://www.mingw.org/) dan paketnya [MSYS](http://www.mingw.org/wiki/msys), dimana menyediakan beberapa fasilitas seperti bash, gawk, make dan grep. MSYS tidak sepenuhnya memiliki semua fasilitas jika dibandingkan dengan Cygwin. Cygwin biasanya berguna untuk membuat port Windows dari Unix.\n\n## Bacaan lebih lanjut\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Daftar alat dan sumber Shell lainnya.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Penjelasan lebih dalam perintah baris pada OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) untuk  menulis skrip Shell yang lebih baik.\n- [shellcheck](https://github.com/koalaman/shellcheck): Analisis Shell skrip. Pada dasarnya, lint untuk bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Cara menangani nama berkas yang baik dan benar pada skrip Shell.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Perintah dan alat yang berguna untuk mengolah data sains, dari buku dengan nama yang sama.\n\n## Penyangkalan\n\nDengan pengecualian dari tugas yang sangat kecil, kode ditulis sehingga orang lain dapat membacanya. Dengan kekuatan datang tanggung jawab. Bahkan Anda * dapat * melakukan sesuatu di Bash tidak berarti Anda harus! ;)\nDengan beberapa pengecualian, sebuah kode ditulis sehingga orang lain dapat membacanya. Dengan adanya kekuatan datang pula tanggung jawab. Faktanya anda *dapat* melakukan hal yang tidak seharusnya dalam Bash! ;)\n\n\n## Lisensi\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nHasil kerja ini memiliki lisensi dibatah [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-it.md",
          "type": "blob",
          "size": 34.27,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# The Art of Command Line (Traduzione Italiana)\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [Meta](#meta)\n- [Le Basi](#le-basi)\n- [Uso quotidiano](#uso-quotidiano)\n- [Processare file e dati](#processare-file-e-dati)\n- [Debug sistema](#debug-sistema)\n- [One-liner](#one-liner)\n- [Oscuri ma utili](#oscuri-ma-utili)\n- [OS X](#os-x)\n- [Ulteriori risorse](#ulteriori-risorse)\n- [Disclaimer](#disclaimer)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nSaper usare con una certa facilità la linea di comando è spesso visto come una sorta di \"sapere arcano\". Anche se può sembrare, in realtà non è decisamente così: può migliorare la tua produttività e la tua flessibilità in modi che neanche immagini. Questa che stai per leggere è una selezione di trucchi e di consigli che riguardano la linea di comando, che abbiamo trovato utili lavorando con Linux. Alcune di queste nozioni sono elementari, altre molto specifiche, se non sofisticate e, a volte, oscure.\n\nNon c'è da preoccuparsi, comunque: la pagina che stai scorrendo non è molto lunga e non ti ruberà molto tempo. Prenderci dimestichezza, saperla usare quando necessario, te ne renderà ancora di più.\n\nQuesto lavoro è il risultato degli sforzi di [svariati autori e traduttori](AUTHORS.md).\n\nUna buona parte di ciò che leggi è [apparsa](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands), [originariamente](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix), su [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know). Tuttavia, visto l'interesse, mi è sembrato logico usare Github per raccogliere il tutto e creare un qualcosa a cui chiunque avrebbe potuto contribuire, anche con un piccolo suggerimento. Non abbiamo la pretesa di aver creato qualcosa di perfetto: se trovi qualche errore faccelo sapere, magari aprendo una Pull Request!\n\n\n## Meta\n\nObiettivi:\n\n- Questa guida è adatta sia a principianti che ad utenti con più conoscenze. Ci proponiamo di seguire tre principi fondamentali: *ampiezza* (cerchiamo di includere tutto quello che serve), *specificità* (dando degli esempi concreti) e *brevità* (evitando tutto il futile e il superfluo). Ogni consiglio viene dato con l'obiettivo di salvare del tempo prezioso.\n- Questa guida è stata scritta per Linux, con alcune eccezioni per che abbiamo riportato nella sezione \"[OS X](#os-x-only)\". In ogni caso, molti dei consigli che vedrai si applicano tranquillamente ad altri sistemi operativi Unix e a MacOS.\n- Il focus principale sarà su interactive Bash, nonostante non sia esclusivamente così.\n- Verranno inclusi comandi \"base\" Unix, ma anche altri che necessiteranno di installazioni separate.\n\nNote:\n\n- Per tenere tutto su una sola pagina, il contenuto è stato incluso tramite reference. Crediamo che tu sia abbastanza intelligente da cercare i dettagli su qualcosa di specifico, o su un comando, usando Google. Usa `apt-get`, `yum`, `dnf`, `pacman`, `pip` o `brew` (in base alla situazione) per installare i nuovi programmi.\n- Se vuoi, usa [Explainshell](http://explainshell.com/) per avere uno spaccato più completo su cosa fanno comandi, pipe, opzioni e così via.\n\n\n## Le Basi\n\n- Impara le basi di Bash. Usa `man bash` e cerca almeno di scorrere velocemente l'intero scritto. Non è troppo lungo e neanche difficile da seguire. Altre shell possono andare bene, ma Bash è molto potente e sempre disponibile (impararne una sola tra zsh, fish e così via, per quanto ti possa tentare, ti darà problemi a lungo termine, lavorando su altre piattaforme).\n\n- Impara ad usare bene almeno un editor di testo. Idealmente, potresti usare Vim (`vi`), con il quale non c'è praticamente competizione per questo genere di cose (sì, anche se volessi usare Emacs, oppure un altro di quei grossi IDE, o magari l'ennesimo ultimo editor ultramoderno ed hipster).\n\n- Impara a leggere la documentazione usando `man` (per i più curiosi, `man man` elenca le varie sezioni. Ad esempio, 1 indica i comandi \"regolari\", 5 per file/convenzioni, 8 per l'amministrazione). Trova le pagine tramite `apropos`. Ricorda inoltre che alcuni comandi non sono degli eseguibili, ma dei \"builtin\" di Bash. Usa `help -d` in caso di necessità.\n\n- Impara tutto sul reindirizzamento dell'output e dell'input, usando `>`, `<` ed il pipe `|`. Impara anche che `>` sovrascrive il file output, mentre `>>` aggiunge del contenuto alla fine. Impara tutto riguardo stdout e stderr.\n\n- Impara anche qualcosa sul file glob, l'uso di `*` (e magari anche di `?` e `[`...`]`), oltre alla differenza tra i doppi `\"` e singoli `'` apici. Guarda più in giù per quanto riguarda l'espansione delle variabili.\n\n- Acquisisci familiarità con la gestione dei job con Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, e così via.\n\n- Impara ad usare `ssh` e le basi della passwordless authentication, tramite `ssh-agent`, `ssh-add`, e così via.\n\n- Gestione base dei file: `ls` e `ls -l` (nello specifico, impara cosa indica ognuna delle colonne che escono fuori da `ls -l`), `less`, `head`, `tail` e `tail -f` (o, anche meglio, `less +F`), `ln` e `ln -s` (impara le differenze ed i vantaggi nell'uso di hard link o soft link), `chown`, `chmod`, `du` (per una panoramica veloce, usa: `du -hs *`). Per la gestione del filesystem, guardati `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Impara anche cos'è un inode (`ls -i` or `df -i`).\n\n- Gestione base delle reti: `ip` or `ifconfig`, `dig`.\n\n- Impara ad usare per bene le espressioni regolari, e le varie flag per `grep`/`egrep`. Nello specifico, varrebbe la pena anche vedersi le opzioni `-i`, `-o`, `-v`, `-A`, `-B`, e `-C`.\n\n- Impara ad usare `apt-get`, `yum`, `dnf` o `pacman` (in base alla distro che usi) per trovare ed installare nuovi package. E assicurati anche di aver installato `pip`, in modo tale da installare agevolmente i vari tool da linea di comando basati sul linguaggio Python. Alcuni di quelli che vedrai in seguito sono più semplici da installare se usi `pip`.\n\n\n## Uso quotidiano\n\n- In Bash, usa **Tab** per completare i vari parametri dei comandi, oppure elencarli. Usa **ctrl-r** per effettuare una ricerca nella cronologia dei comandi inseriti (premi *ctrl-r*, quindi effettua la ricerca. Per vedere più risultati premi ripetutamente *ctrl-r*). Premi quindi **Invio** per eseguire il comando trovato, oppure premi su **freccia destra** per mettere il comando sulla linea attuale, in modo tale da poterlo modificare.\n\n- In Bash, usa **ctrl-w** per cancellare l'ultima parola, **ctrl-u** per cancellare tutto fino all'inizio della riga. Usa **alt-b** ed **alt-f** per muoverti di parola in parola. **ctrl-a** ti permette di tornare all'inizio della riga attuale senza cancellare nulla, mentre con **ctrl-e** puoi spostarti direttamente alla fine. **ctrl-k** cancella tutto quello che c'è dal punto attualmente scelto fino alla fine della riga. Inoltre, **ctrl-l** pulisce lo schermo. Per vedere una lista completa di tutte le varie scorciatoie presenti (ce ne sono molte) in bash, usa `man readline`. Ad esempio, **alt-.** serve a ciclare attraverso gli argomenti precedenti.\n\n- In alternativa se ti piacciono le scorciatoie in stile vi, usa `set -o vi` (e `set -o emacs` per tornare indietro se dovessi cambiare idea).\n\n- Per modificare dei comandi lunghi può essere utile impostare un editor di tua scelta (esempio: `export EDITOR=vim`). Premendo **ctrl-x** **ctrl-e** aprirai l'attuale comando in un editor multi-line per una modifica più agevole. Oppure, se stai lavorando con uno stile vi, **escape-v**.\n\n- Per vedere i comandi più recenti, usa `history`. Ci sono anche altre abbreviazioni da usare per lo stesso scopo, come `!$` (per l'ultimo) e `!!`, nonostante questi vengano spesso rimpiazzati da **ctrl-r** e **alt-.**.\n\n- Per tornare alla directory precedente: `cd -`\n\n- Se stai digitando un comando, sei a metà e cambi idea, usa **alt-#** per aggiungere un `#` all'inizio della linea, rendendola di fatto un commento (oppure usa la sequenza **ctrl-a**, **#**, **invio**). Puoi quindi ritornarci dopo, tramite la cronologia.\n\n- Usa `xargs` (o `parallel`). Si tratta di un tool molto potente, che ti permette di eseguire un certo comando tante volte quanti sono gli elementi restituiti da un altro comando. Quando non sei sicuro di quello che stai facendo, usa `xargs echo` per schiarirti le idee. Inoltre, `-I{}` è abbastanza utile. Ecco un esempio:\n\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` è un ottimo tool che ti mostra l'albero dei processi.\n\n- Usa `pgrep` e `pkill` per trovare dei processi ed inviare loro un segnale specifico (`-f` è utile a riguardo).\n\n- Impara a conoscere i vari segnali che puoi inviare ai processi. Ad esempio, per sospendere un processo puoi usare `kill -STOP [pid]`. Per una lista completa, esegui `man 7 signal`.\n\n- Usa `nohup` o `disown` se vuoi fare in modo che un certo processo vada avanti indefinitamente.\n\n- Controlla quali processi sono in ascolto tramite `netstat -lntp` oppure `ss -plat` (per TCP; aggiungere invece `-u` per UDP).\n\n- Dai uno sguardo a `lsof` per un elenco di socket e file aperti.\n\n- Usa `uptime` o `w` per sapere da quanto tempo il sistema è stato avviato.\n\n- Usa `alias` per creare delle scorciatoie personalizzate. Ad esempio, puoi usare `alias ll='ls -latr'`, che creerà un nuovo alias `ll` per il comando `ls -latr`.\n\n- Negli script Bash, usa `set -x` (o la variante `set -v`, che effettua un log dell'input, includendo variabili e commenti) per un migliore debug dell'output. Comunque, cerca di usare la modalità strict a meno che tu non abbia bisogno del contrario. Una buona norma suggerisce di usare lo strict mode tranne nel caso in cui tu non possa usare `set -e` per annullare un comando in caso di errore (nonzero exit code). Considera anche l'uso di `set -o pipefail`, Puoi inoltre usare `trap` su EXIT o ERR. Un'abitudine piuttosto utile è quella di iniziare uno script così, facendo in modo che annulli la propria esecuzione in caso vengano rilevati degli errori.\n\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- Negli script Bash, le subshell (scritte tra parentesi) sono un ottimo modo di raggruppare dei comandi. Un esempio piuttosto comune è il muoversi temporaneamente verso una directory differente, per poi tornare a lavorare in quella attuale.\n\n```bash\n      # faccio qualcosa nella directory attuale\n      (cd /some/other/dir && other-command)\n      # continuo nella directory attuale\n```\n\n- In Bash esistono svariati tipi di espansione di variabile. Come controllare se una variabile esiste: `${name:?error message}`. Ad esempio, se uno script richiede un singolo parametro, scrivi `input_file=${1:?usage: $0 input_file}`. Espansione aritmetica: `i=$(( (i + 1) % 5 ))`. Sequenze: `{1..10}`. Trim di stringhe: `${var%suffix}` and `${var#prefix}`. Ad esempio, se `var=foo.pdf`, allora `echo ${var%.pdf}.txt` restituisce `foo.txt`.\n\n- Usare la brace expansion tramite `{`...`}` può essere molto comodo in caso di necessità di automazione di alcuni task simili. Un esempio è `mv foo.{txt,pdf} some-dir` (che con un solo comando muoverà due file, il pdf ed il txt), `cp somefile{,.bak}` (che si espande a `cp somefile somefile.bak`) o `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (che espande tutte le possibili combinazioni, creando un albero di directory).\n\n- L'output di un comando può essere trattato come un file tramite `<(some command)`. Ad esempio, per comparare il file `/etc/hosts` locale con uno in remoto:\n\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Impara qualcosa sugli \"here documents\" in Bash, come `cat <<EOF ...`.\n\n- In bash, redireziona gli errori standard (input ed output) usando: `some-command >logfile 2>&1` oppure `some-command &>logfile`. Spesso, per assicurarti che un certo comando non lasci un handle aperto \"legandoti al terminale attuale\" potrebbe essere una buona idea aggiungere `</dev/null`.\n\n- Usa `man ascii` per ottenere una buona tabella ASCII, con valori decimali ed esadecimali. Per altre informazioni generali sulle codifiche, usa `man unicode`, `man utf-8`, e `man latin1`.\n\n- Usa `screen` o [`tmux`](https://tmux.github.io/) per effettuare il multiplex della schermata, cosa particolarmente utile in caso di sessioni ssh in remoto, ad esempio. `byobu` può inoltre migliorare screen e tmux, fornendo più informazioni e una gestione semplificata. Un'altra alternativa, minimalista, per la persistenza di sessione è `dtach`.\n\n- In ssh, sapere come effettuare il port tunneling con `-L` o `-D` (ed occasionalmente `-R`) è molto utile, ad esempio per accedere a siti web da un server remoto.\n\n- Può essere utile effettuare alcune ottimizzazioni alla configurazione ssh; ad esempio, questo file `~/.ssh/config` contiene delle impostazioni utili ad evitare connessioni interrotte in specifiche reti ed ambienti, fa uso di compressione (utile in caso di connessioni lente), e multiplexing dei canali verso lo stesso server con un control file locale:\n\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Altre opzioni sempre interessanti riguardo ssh sono sensibili in termini di sicurezza e dovrebbero essere gestite con cura: alcuni esempi sono `StrictHostKeyChecking=no` e `ForwardAgent=yes`;\n\n- Considera l'uso di [`mosh`](https://mosh.org/), un'alternativa ad ssh che usa UDP, in modo tale da evitare connessioni interrotte.\n\n- Per ottenere i permessi relativi ad un certo file in forma ottale, utile alla configurazione ma non disponibile in `ls` usa qualcosa come\n\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Per una selezione interattiva di valori dall'output di un altro comando, valuta l'uso di [`percol`](https://github.com/mooz/percol) o [`fzf`](https://github.com/junegunn/fzf).\n\n- Per interagire con dei file in base all'output di un certo comando (come `git`), usa `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Se vuoi creare al volo un webserver semplice, per i file nella directory attuale (sottocartelle incluse), disponibile a tutti sulla tua rete, usa:\n`python -m SimpleHTTPServer 7777` (per la porta 7777 e Python 2) e `python -m http.server 7777` (per la porta 7777 e Python 3).\n\n- Per eseguire un comando con i privilegi di un altro utente, usa `sudo` (per l'utente root) o `sudo -u` (per un altro utente). Usa `su` o `sudo bash` per eseguire la shell come tale utente. Usa `su -` per simulare un nuovo login con un altro utente.\n\n\n## Processare file e dati\n\n- Per trovare un file partendo dal suo nome nella directory attuale, usa `find . -iname '*qualcosa*'`. Per trovare un file in generale nel sistema, usa `locate qualcosa` (ma tieni a mente che `updatedb` potrebbe non ancora aver messo nell'indice i file creati da poco).\n\n- Per una ricerca più generale, all'interno di codice sorgente o file di dati (o comunque qualcosa di più avanzato di `grep -r`), usa [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Per converire del codice HTML in un testo: `lynx -dump -stdin`\n\n- Per Markdown, HTML ed ogni tipo di conversione di documenti, prova [`pandoc`](http://pandoc.org/).\n\n- Se devi lavorare con l'XML ricorda: `xmlstarlet` è old but gold.\n\n- Per il JSON, usa [`jq`](http://stedolan.github.io/jq/).\n\n- Per YAML, usa [`shyaml`](https://github.com/0k/shyaml).\n\n- Per Excel o file CSV, [csvkit](https://github.com/onyxfish/csvkit) fornisce `in2csv`, `csvcut`, `csvjoin`, `csvgrep` e così via.\n\n- Per Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) è un ottimo tool e [`s4cmd`](https://github.com/bloomreach/s4cmd) è invece molto più veloce. Amazon [`aws`](https://github.com/aws/aws-cli) e la sua versione migliorata, [`saws`](https://github.com/donnemartin/saws) sono qualcosa di fondamentale per ogni tipo di task legato ad AWS.\n\n- Impara di più riguardo `sort` ed `uniq`, incluso `-u` e `-d` di `uniq`. Guardati anche `comm`.\n\n- Impara a conoscere meglio anche `cut`, `paste` e `join` per manipolare file di testo. Molte persone spesso usano `cut` ma si scordano dell'esistenza di `join`.\n\n- Impara ad usare `wc` per contare i ritorni a capo (`-l`), caratteri (`-m`), parole (`-w`) e byte (`-c`).\n\n- Impara qualcosa di più riguardo `tee` per copiare da stdin ad un file ed anche verso stdout. Esempio: `ls -al | tee file.txt`.\n\n- Ricorda che le impostazioni riguardo la localizzazione influiscono un sacco su alcuni tool da linea di comando, in molti modi. Ad esempio sugli ordinamenti (collation) e performance. Molte installazioni Linux impostano `LANG` ed altre variabili correlate automaticamente su US English (inglese americano). Se decidi di cambiare lingua, non è detto quindi che le cose rimangano così come sono. Alcuni comandi, addirittura, potrebbero diventare immediatamente molto più lenti.\n\n- Impara le basi di `awk` e `sed` per manipolare dati. Ad esempio, per sommare tutti i numeri nella terza colonna di un file di testo, usa `awk '{ x += $3 } END { print x }'`. Probabilmente tre volte più veloce e tre volte più corto del suo equivalente in Python.\n\n- Per rimpiazzare tutte le occorrenze di una stringa, in uno o più file:\n\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Per rinominare dei file in massa e per effettuare cerca/sostituisci al loro interno, prova anche [`repren`](https://github.com/jlevy/repren). (In alcuni casi il comando `rename` permette operazioni multiple, ma fai attenzione al risultato visto che la funzionalità non è sempre identica sulle varie distro;\n\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Come la pagina del manuale spiega, `rsync` è un ottimo tool per copiare file, versatile e velocissimo. Si, è conosciuto per sincronizzare file da una macchina all'altra, ma è ugualmente utile se viene usato localmente. Viene anche riconosciuto come [uno dei modi più veloci](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) di cancellare un grande numero di file tutti insieme:\n\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Usa `shuf` per selezionare una serie di linee da un file, in ordine casuale.\n\n- Impara a conoscere le opzioni di `sort`. Per i numeri, usa `-n`, oppure `-h` per gestire numeri leggibili dal'uomo (`du -h`). Impara a capire come funzionano le varie chiavi (`-t` e `-k`). In particolare, fai attenzione a quando scrivi `-k1,1` per ordinare solo per il valore del primo campo, visto che `-k1` significa ordinare secondo l'intera riga. Lo stable sort (`sort -s`) può esserti utile. Immagina ad esempio di voler ordinare secondo il valore del secondo campo, e secondariamente del primo. Userai `sort -k1,1 | sort -s -k2,2`.\n\n- Se dovessi aver bisogno di scrivere, letteralmente, un tab in Bash, premi **ctrl-v** **[Tab]** o scrivi `$'\\t'`.\n\n- I tool standard per il patching del codice sono `diff` e `patch`. Guarda anche Guarda anche `diffstat` per saperne di più su una  diff e `sdiff` per una side-by-side diff. Nota bene che `diff -r` lavora con intere directory. Usa `diff -r tree1 tree2 | diffstat` per una panoramica dei cambiamenti. Usa `vimdiff` per comparare e modificare file.\n\n- Per file binari, usa `hd`, `hexdump` o `xxd` per semplici hex dump, e `bvi` o `biew` per editing binario.\n\n- Inoltre, sempre per file binari, usa `strings` (insieme `grep`, e così via) per trovare sezioni di testo al loro interno;\n\n- Per diff binarie (delta compression), usa `xdelta3`.\n\n- Per convertire un testo da una codifica ad un'altra, prova `iconv`. Oppure `uconv` in caso di necessità più avanzate; supporta svariate opzioni avanzate inerenti Unicode. Ad esempio, questo comando rimuove tutti gli accenti e trasforma le stringhe in lettere tutte minuscole:\n\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Per dividere un file in altri file più piccoli, guarda `split` (per dividere in base alla dimensione) e `csplit` (per dividere in base ad un pattern).\n\n- Se devi manipolare date ed orari, usa `dateadd`, `datediff`, `strptime` e così via, di [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Usa `zless`, `zmore`, `zcat` e `zgrep` per lavorare su file compressi.\n\n\n## Debug sistema\n\n- Per il web debugging, `curl` e `curl -I` sono decisamente utili. La stessa cosa vale anche per l'equivalente `wget`, o ancora per il più recente [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Per avere più informazioni sullo stato attuale del sistema, dalla cpu ai dischi, il tool classico più usato è `top` (o la sua versione migliorata `htop`), `iostat` e `iotop`. Usa `iostat -mxz 15` per avere informazioni base sulla CPU ed informazioni dettagliate, per partizione, sui dischi e sulle loro performance.\n\n- Per avere più dettagli sulle connessioni di rete, usa `netstat` e `ss`.\n\n- Per una panoramica veloce di cosa sta succedendo nel sistema, `dstat` è ottimo. Per avere invece molte più informazioni e scendere nel dettaglio, usa [`glances`](https://github.com/nicolargo/glances).\n\n- Per saperne di più sullo stato della memoria, esegui ed impara a capire il significato dei comandi `free` e `vmstat`. In particolare, sii consapevole del fatto che la memoria \"cached\" è quella mantenuta dal kernel Linux come file cache, che a tutti gli effetti poi conta come memoria libera.\n\n- Il system debugging con Java è tutta un'altra cosa. Uno dei trucchi più semplici sulla JVM Oracle (ed anche altre) è che all'esecuzione di `kill -3 <pid>` verrà messo in log un trace full stack (inclusi molti dettagli sulla garbage collection). Anche `jps`, `jstat`, `jstack` e `jmap` del JDK sono molto utili. Ci sono poi i vari [SJK tools](https://github.com/aragozin/jvm-tools), più avanzati.\n\n- Usa [`mtr`](http://www.bitwizard.nl/mtr/) per rilevare problemi di rete. Molto meglio di traceroute.\n\n- Per capire perché un disco viene visto pieno, [`ncdu`](https://dev.yorhel.nl/ncdu) ti evita perdite di tempo rispetto al più comune `du -sh *`.\n\n- Per capire quale socket o processo sta usando troppa banda prova [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) o [`nethogs`](https://github.com/raboof/nethogs).\n\n- `ab` (incluso in Apache) è ottimo per un test di carico veloce di un webserver. Per test di carico più avanzati, prova anche `siege`.\n\n- Per un debug di rete più avanzato, dai uno sguardo a [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) o [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Impara qualcosa di più su `strace` e `ltrace`. Possono essere molto utili quando un programma crasha, o magari rimane in blocco e tu non capisci perché. Degne di nota le opzioni di profiling (`-c`), e la possibilità di agganciare un processo in esecuzione (`-p`).\n\n- Impara qualcosa di più riguardo `ldd` per controllare le librerie condivise.\n\n- Impara a connetterti ad un processo in esecuzione con `gdb` e recuperare il suo stack trace.\n\n- Usa `/proc`. Fantastico quando devi fare un live debug in caso di problemi. Esempi: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (dove `xxx` è il nome del processo o il suo pid).\n\n- Quando vuoi debuggare qualcosa che è andato storto in passato, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) può essere molto utile. Permette di controllare uno storico delle statistiche di CPU, memoria, rete e così via.\n\n- Usa `stap` per un'analisi più approfondita del sistema in termini di performance ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux)), e [`sysdig`](https://github.com/draios/sysdig).\n\n- Controlla quale OS stai usando con `uname` oppure `uname -a` (informazioni generali sul kernel) o `lsb_release -a` (informazioni sulla distro Linux).\n\n- Usa `dmesg` quando il sistema si comporta in modo davvero strano (problemi hardware o legati ai driver, insomma).\n\n\n## One-liner\n\nQualche esempio di combinazione di più comandi comandi:\n\n- Decisamente è utile è sapere che puoi effettuare intersesione, unione e differenza di file di testo tramite `sort`/`uniq`. Immagina di avere `a` e `b`, due file di testo. Il metodo in questione è veloce e tra l'altro supporta anche file di svariati gigabyte. Guarda anche la nota riguardo `LC_ALL` e l'opzione `-u` di `sort`.\n\n```sh\n      cat a b | sort | uniq > c   # c is a union b\n      cat a b | sort | uniq -d > c   # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n\n- Usa `grep . *` per esaminare velocemente i contenuti di tutti i file in una certa directory (in modo che ogni linea venga abbinata al nome del file), oppure `head -100 *`. Può essere molto utile per quelle directory piene file di configurazione, come `/sys`, `/proc`, `/etc`.\n\n\n- Sommare tutti i numeri sulla terza colonna di un file di testo (probabilmente 3 volte più veloce e corto della controparte in Python):\n\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Nel caso in cui tu voglia vedere dimensioni e date per un certo \"albero\" di file (un po' come `ls -l`, ma ricorsivo):\n\n```sh\n      find . -type f -ls\n```\n\n- Immagina di avere un file di testo, come un log di un server, like a web server log, ed un certo valore appare di tanto in tanto tra le righe, come ad esempio un parametro `acct_id` in un URL.. Ecco come contare le richieste effettuate che contengono tale parametro `acct_id`:\n\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Per monitorare costantemente i cambiamenti ai file, usa `watch`. Ad esempio, per controllare i cambiamneti in una certa directory usa `watch -d -n 2 'ls -rtlh | tail'` oppure, se stai monitorando un file di configurazione inerente il WiFi, `watch -d -n 2 ifconfig`.\n\n- Esegui questa funzione per ottenere un consiglio a caso da questo documento:\n\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Oscuri ma utili\n\n- `expr`: esegue operazioni aritmetiche o booleane, oltre a valutare espressioni regolari.\n\n- `m4`: un semplice macro processor.\n\n- `yes`: stampa una stringa per un numero indefinito di volte.\n\n- `cal`: un calendario.\n\n- `env`: esegue un comando (utile negli script).\n\n- `printenv`: stampa le variabili di ambiente (utile per il debug e negli script).\n\n- `look`: trova parole inglesi (o linee in un file) partendo da una stringa.\n\n- `cut`, `paste` e `join`: manipolazione di dati.\n\n- `fmt`: formatta paragrafi di testo.\n\n- `pr`: formatta del testo in pagine/colonne.\n\n- `fold`: sistema delle linee di testo.\n\n- `column`: formatta del testo in colonne o tabelle dalla larghezza fissa.\n\n- `expand` ed `unexpand`: converte spazi in tab, e viceversa.\n\n- `nl`: aggiunge il conteggio delle righe.\n\n- `seq`: stampa dei numeri.\n\n- `bc`: calcolatrice.\n\n- `factor`: scompone un numero in fattori.\n\n- [`gpg`](https://gnupg.org/): cripta e firma i file.\n\n- `toe`: tabella di tutti i terminali disponbili.\n\n- `nc`: per il network debugging e trasferimento dati.\n\n- `socat`: socket relay e tcp port forwarder (simile a `netcat`).\n\n- [`slurm`](https://github.com/mattthias/slurm): visualizzazione del traffico di rete.\n\n- `dd`: spostamento dati tra file e dispositivi.\n\n- `file`: identifica il tipo di un certo file.\n\n- `tree`: mostra le sottodirectory con una struttura ad albero. A differenza di `ls`, è ricorsivo.\n\n- `stat`: informazioni su un file.\n\n- `time`: esegue un comando e tiene traccia del tempo di esecuzione.\n\n- `timeout`: avvia un comando definendo anche un certo ammontare di tempo oltre il quale non si può andare. Se tale ammontare di tempo viene raggiunto, il comando viene annullato.\n\n- `lockfile`: crea un file che può essere rimosso solo tramite `rm -f`.\n\n- `logrotate`: gestie i log, la loro rotazione, compressione ed invio via mail.\n\n- `watch`: esegue un comando più volte, mostrando i risultati ed evidenziando le differenze tra tali risultati.\n\n- `tac`: stampa un file al contrario.\n\n- `shuf`: sceglie casualmente delle righe da un file.\n\n- `comm`: compara dei file ordinati riga per riga.\n\n- `pv`: monitora i progressi dei dati attraverso un pipe.\n\n- `hd`, `hexdump`, `xxd`, `biew` e `bvi`: dump o modifica di file binari.\n\n- `strings`: estrae del testo da file binari.\n\n- `tr`: manipolazione e trasformazione dei caratteri.\n\n- `iconv` o `uconv`: conversione di testi in altre codifiche.\n\n- `split` e `csplit`: divisione di un file in altri file più piccoli.\n\n- `sponge`: legge tutto l'input prima di riscriverlo, utile in caso di lettura e scrittura sullo stesso file. Ad esempio: `grep -v something some-file | sponge some-file`.\n\n- `units`: conversione da e verso altre unità di misura (guarda anche `/usr/share/units/definitions.units`).\n\n- `apg`: genera password casuali.\n\n- `7z`: compressione di file ad alta ratio.\n\n- `ldd`: informazioni su una libreria dinamica.\n\n- `nm`: elenca i vari simboli presenti un object file.\n\n- `ab`: benchmark di webserver.\n\n- `strace`: debug delle chiamate di sistema.\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): un traceroute migliore per il debug di rete.\n\n- `cssh`: shell visuale concorrente.\n\n- `rsync`: sincronizza file e cartelle tramite SSH oppure in locale.\n\n- [`wireshark`](https://wireshark.org/) e [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): packet capturing e debug di rete.\n\n- [`ngrep`](http://ngrep.sourceforge.net/): come grep... ma per il traffico di rete.\n\n- `host` e `dig`: DNS lookup.\n\n- `lsof`: descrittore dei processi ed informazioni su socket.\n\n- `dstat`: statistiche di sistema.\n\n- [`glances`](https://github.com/nicolargo/glances): overview di sistemi multipli ad alto livello.\n\n- `iostat`: statistiche sull'uso dei dischi.\n\n- `mpstat`: statistiche sull'uso della CPU.\n\n- `vmstat`: statistiche sull'uso della memoria.\n\n- `htop`: versione migliorata di top.\n\n- `last`: cronologia dei login.\n\n- `w`: mostra chi è autenticato.\n\n- `id`: user/group identity info.\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): cronologia di alcune statistiche del sistema.\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) o [`nethogs`](https://github.com/raboof/nethogs): uso della rete da parte di socket e processi.\n\n- `ss`: statistiche sui socket.\n\n- `dmesg`: messaggi di errore di avvio e di sistema in generale.\n\n- `sysctl`: visualizza e configura i parametri del kernel a run time.\n\n- `hdparm`: tool di gestione dischi SATA/ATA.\n\n- `lsblk`: visualizzazione ad albero dei dischi e relative partizioni.\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informazioni sull'hardware, tra cui CPU, BIOS, RAID, scheda grafica e dispositivi di ogni tipo.\n\n- `lsmod` e `modinfo`: elenco e dettaglio dei vari moduli del kernel.\n\n- `fortune`, `ddate`, e `sl`: mmmh, beh, dipende molto da quanto consideri le locomotive a vapore e le citazioni di Zippy \"utili\".\n\n\n## OS X\n\nConsiera questa sezione come un'esclusiva MacOS.\n\n- I package vengono gestiti con `brew` (Homebrew) e/o `port` (MacPorts). Possono essere usati su MacOS per installare molti dei comandi visti in questo articolo.\n\n- Copia l'output di un qualsiasi comando tramite `pbcopy` ed incollalo, invece, con `pbpaste`.\n\n- Per abilitare l'Option key sul terminale Mac OS come un'alt key (per riprodurre comandi quali **alt-b**, **alt-f**, e così via), apri Preferenze -> Profili -> Tastiera e scegli \"Usa Option come meta key\".\n\n- Per aprire un file con un'applicazione desktop, usa `open` oppure `open -a /Applications/LaTuaApplicazione.app`.\n\n- Cerca i file con `mdfind` ed elenca i vari metadati (come gli EXIF per le foto) con `mdls`.\n\n- Sii consapevole del fatto che MacOS è basato su BSD Unix, e molti dei suoi comandi (ad esempio `ps`, `ls`, `tail`, `awk`, `sed`) presentano alcune variazioni rispetto alla loro controparte Linux. Per controllare tali differenze devi vedere se la pagina del manuale ha come titolo \"BSD General Commands Manual\". Come logica conseguenza, quindi, ricorda di non usare tali comandi se hai intenzione di scrivere degli script cross-platform.\n\n- Per avere più informazioni sulla tua release di MacOS, usa `sw_vers`.\n\n\n## Ulteriori risorse\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Una curatissima lista di tool e risorse\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Una guida approfondita sulla linea di comando in Mac OSX\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) per scrivere script migliori\n- [shellcheck](https://github.com/koalaman/shellcheck): Un tool di analisi per script shell. Praticamente lint per bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Un compendio sul come gestire nomi dei file e path nella shell\n\n\n## Disclaimer\n\nCon l'eccezione di pochi piccoli task, il codice è stato scritto per permettere agli altri di leggerlo agevolmente. Da grandi poteri derivano grandi responsabilità. Ricorda: il fatto che tu possa *fare* qualcosa in Bash non implica comunque che tu debba per forza! ;)\n\n\n## License\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nA questo lavoro è attribuita la [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-ja.md",
          "type": "blob",
          "size": 47.23,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# The Art of Command Line\n\n[![質問してみよう](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![https://gitter.im/jlevy/the-art-of-command-lineでチャットに参加しよう](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [メタ情報](#メタ情報)\n- [基本](#基本)\n- [日常的に使うもの](#日常的に使うもの)\n- [ファイルとデータの処理](#ファイルとデータの処理)\n- [システムのデバッグ](#システムのデバッグ)\n- [ワンライナー](#ワンライナー)\n- [目立たないが便利なもの](#目立たないが便利なもの)\n- [OS X用のもの](#os-x用のもの)\n- [Windows専用](#windows専用)\n- [さらなるリソース](#さらなるリソース)\n- [免責事項](#免責事項)\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nコマンドラインで流れるように操作ができるということは、軽く見られたり他人から理解されないスキルだとみなされることもあるだろう。しかしそのスキルは、明らかにかすぐ分かるようかは問わず、エンジニアとしてのあなたの柔軟性や生産性を改善してくれるものだ。ここでは、Linuxでコマンドラインを使う上で便利だと思ったメモやTipsの数々を挙げてみる。あるものは基礎的だが、非常に詳しいもの、洗練されたもの、曖昧なものもある。このページはそんなに長いものではないが、ここに書いてあることの全てを使ったり思い出すことができれば、かなり詳しくなれるだろう。\n\nこのドキュメントは[多くの執筆者と翻訳者](AUTHORS.md)による成果である。\nここに書いてあることの多くは、[元々](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)[Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know)に[書かれて](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)いたものが多いが、より優れた人たちがすぐに改善案を出すことができるGitHubに置くのがよいのではと思った。\nコマンドラインについて疑問があるなら[**質問してみよう**](https://airtable.com/shrzMhx00YiIVAWJg) エラーや改善点を見つけたら[**貢献してみよう**](/CONTRIBUTING.md)!\n\n## メタ情報\n\n対象 :\n\n- このガイドは、初心者向けでも経験者向きでもある。幅広く(書いてあることは全て重要)、かつ明確で(多くのケースに対して具体的な例を付ける)、そして簡潔(他の場所で見つけられるような重要でないことや脱線したことは省く)であることをゴールにしている。各項目は、多くの場面において必須であるか、他の方法に比べて劇的に時間を節約してくれるだろう。\n- [OS X用のもの](#os-x-only)を除き、Linux向けの内容となっており、その多くは各種LinuxおよびMacOS(あるいはCygwin)でも使えるだろう。\n- インタラクティブなBashを使うことを想定しているが、多くの項目は他のシェルやBashのスクリプトでも使えるだろう。\n- (このリポジトリへ)組み込むメリットがあるのであれば、標準Unixコマンドやパッケージインストールコマンドも含める。\n\n注意 :\n\n- 1ページ内に収めるために、内容には暗黙的に書かれていることがある。ここで取りかかりを知ったりコマンドが分かれば、詳細をどこかで調べたりするくらいはできるだろう。新しいプログラムをインストールするには、`apt-get`、`yum`、`dnf`、`pacman`、`pip`、`brew`(どれか適したもの)を使おう。\n- コマンドやオプション、パイプを分解して理解する手助けに、[Explainshell](http://explainshell.com/)を使おう。\n\n## 基本\n\n- 基本的なBashを学ぼう。実際のところ、`man bash`は結構簡単に理解できるしそんなに長くないので、これで一通りのことは分かる。それ以外のシェルもよいが、Bashは強力だし、常に使用可能であるという利点もある(自分のPCに入れてしまったと言ってzshやfishなど*だけ*を学んでしまうと、既存のサーバを触らなくてはならない時などに制約が出てしまう)。\n\n- テキストエディタのどれか最低1つに習熟しよう。`nano`エディタは編集の基本操作(開く、修正する、保存する、検索する)を学ぶ最もシンプルな方法のひとつだ。ターミナル内で適当にものを書くにあたって他に全く代替品がないという点で、理想的にはVim(`vi`)がよいだろう(通常はEmacsや高機能なIDEや最新のかっこいいエディタをメインに使っていたとしても)。\n\n- `man`でのドキュメントの読み方を知ろう(知りたがりのために書くと、`man man`でセクション番号が分かる。例えば1は「一般的な」コマンド、5はファイルやそのお作法、8は管理についてといった具合)。`apropos`でmanページを探そう。コマンドによっては実行可能ファイルではなくBashのビルトインコマンドであることを理解し、`help`や`help -d`でヘルプが見られることを知ろう。\n\n- `>`や`<`、`|`を使ったパイプによる入出力のリダイレクションを学ぼう。`>`は出力ファイルを上書き、`>>`は追記となる。stdout(標準出力)とstderr(標準エラー出力)を学ぼう。\n\n- `*`(または`?`や`[`...`]`)を使ったファイルグロブ展開、クォーテーション、ダブルクォート`\"`とシングルクォート`'`の違いを学ぼう(詳しくはこの後の変数展開の項を参照)。\n\n- `&`、**ctrl-z**、**ctrl-c**、`jobs`、`fg`、`bg`、`kill`など、Bashのジョブ管理について詳しくなろう。\n\n- `ssh`について知るとともに、`ssh-agent`や`ssh-add`を使ったパスワードなしの認証の基本について理解しよう。\n\n- ファイル管理について。`ls`や`ls -l`(特に、`ls -l`の各列が何を意味するか理解)、`less`、`head`、`tail`、`tail -f`(または`less +F`)、`ln`と`ln -s`(ハードリンクとソフトリンクの違いとそれぞれの利点の理解)、`chown`と`chmod`、`du`(ディスク使用量まとめを簡単に見るなら`du -hs *`)。ファイルシステム管理については、`df`、`mount`、`fdisk`、`mkfs`、`lsblk`。inodeについては、`ls -i`(または `df -i`)。\n\n- 基本的なネットワーク管理について。`ip`あるいは`ifconfig`、`dig`、`traceroute`、 `route`。\n\n-  `git`のようなバージョン管理システムを学んで使ってみよう。\n\n- 正規表現について詳しく知ろう。`grep`や`egrep`の色々なフラグも合わせて。`-i`、`-o`、`-v`、`-A`、`-B`、`-C`といったオプションは知っておいて損はない。\n\n- `apt-get`、`yum`、`dnf`、`pacman`(ディストリビューションによって違う)といったコマンドでパッケージを探したりインストールする方法を学ぼう。Pythonベースのコマンドラインツールをインストールするのに、`pip`も必要だ(後に出てくるいくつかのコマンドは`pip`でインストールするのが一番簡単)。\n\n\n## 日常的に使うもの\n\n- Bashでは、引数を補完、または利用可能なコマンドを列挙するのに**タブ**を使い、コマンド履歴から検索するのに**ctrl-r**を使う。(検索キーを入力した後、**ctrl-r**を繰り返し入力することで次から次へと検索結果を送ることができる。**Enter**で見つかったコマンドの実行となり、**Enter**ではなく右カーソルキーを押した場合は見つかったコマンドが入力された状態になる。)\n\n- Bashでは、最後の単語を削除するのには**ctrl-w**、行頭まで全て削除するには**ctrl-u**を使う。単語ごとに移動するには**alt-b**または**alt-f**、行頭に移動するには**ctrl-a**、行末に移動するには**ctrl-e**、行末まで削除するには**ctrl-k**、画面のクリアは**ctrl-l**である。Bashにおけるデフォルトのキー割り当てを全て見るには`man readline`を参照。たくさん出てくる。例えば、**alt-.**は前の引数を順番に表示し、**alt-***はグロブを展開する。\n\n- vi風のキー割り当てが好きなら、`set -o vi`を実行しよう。(元に戻したいときは`set -o emacs`)\n\n- 長いコマンドを編集するときに、エディタを設定した後で(例えば`export EDITOR=vim`)、**ctrl-x** **ctrl-e**によって編集中のコマンドが複数行の編集のために指定したエディタで開かれる。vi風の場合は、**escape-v**。\n\n- 最近実行したコマンドを確認するなら`history`。`!n`と続けることで(nはコマンド横に表示される数字)再度実行できる。**ctrl-r**や**alt-.**で用は足りるだろうが、`!$`(直前の引数)や`!!`(直前のコマンド)といった省略形もたくさんある。\n\n- `cd`でホームディレクトリへの移動。ホームディレクトリに関連するファイルにアクセスする場合はプレフィックス`~`をつける(例: `~/.bashrc`)。`sh`スクリプトの中では`$HOME`でホームディレクトリを表すことができる。\n\n- 前のワーキングディレクトリに戻るなら`cd -`\n\n- 途中までコマンドを入力したけれど心変わりした時は、**alt-#**を打つと行頭に`#`が挿入され、コメントとして入力される(**ctrl-a**、**#**、**enter**でも同じ)。これは後でコマンド履歴から検索できる。\n\n- `xargs`(または`parallel`)を使おう。非常に強力。行ごとにいくつのアイテムを実行するか(`-L`)や、並列度(`-P`)も制御できる。正しく実行されるか定かでないなら、まず`xargs echo`してみればよい。`-I{}`も便利。例えば以下の通り。\n\n ```bash\n    find . -name '*.py' | xargs grep some_function\n    cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p`はプロセスツリーを表示するのに便利。\n\n- `pgrep`や`pkill`で、プロセス名で検索したりシグナルを送れる(`-f`も便利)。\n\n- プロセスに送れる色々なシグナルを知っておこう。例えば、プロセスをサスペンドするには`kill -STOP [pid]`を使う。全種類見るなら、`man 7 signal`。\n\n- バックグラウンドプロセスをずっと実行し続けたいなら`nohup`あるいは`disown`を使おう。\n\n- `netstat -lntp`や`ss -plat`で、どんなプロセスがリッスンしているか確認しよう(UDPなら`-u`を付ける)。\n\n- 開かれているソケットやファイルを見るには`lsof`も参照。\n\n- `uptime`や`w`によってシステムの稼働時間を調べられる。\n\n- `alias`によってよく利用するコマンドのエイリアス(ショートカット)を作成できる。例えば、`alias ll='ls -latr'`では新しいエイリアスである`ll`が作成される.\n\n- よく使うエイリアス、シェル設定、機能を`~/.bashrc`に保存し、[ログインシェルに反映しよう](http://superuser.com/a/183980/7106)。これで全てのセッションであなたの設定が利用できる。\n\n- ログイン時に実行されてほしいコマンド、環境変数を`~/.bash_profile`に記載する。画面からのログインや`cron`ジョブで起動されるシェルには別の設定が必要だ。\n\n- Gitで様々なマシンの設定ファイル(例:`.bashrc`や`.bash_profile`)を同期させよう。\n\n- 空白を含む変数やファイル名には注意が必要だ。Bash変数にはクオートをつけよう、こんな風に`\"$FOO\"`。\nファイル名の区切りとしてヌル文字を指定する場合には`-0`や`-print0`オプションを付与しよう。例:  `locate -0 pattern | xargs -0 ls -al` or `find / -print0 -type d | xargs -0 ls -al`。空白を含んだファイル名を繰り返し実行するためには、IFS=$'\\n'`を使ってIFSを改行のみにしよう。\n\n- Bashスクリプトでは、`set -x`でデバッグ出力を出せる(`set -v`は、実行されるコマンドや変数名やコメントなどをそのまま出力する)。特別な理由がない限り厳格モード(strict mode)を使い、`set -e`でエラー時(0以外の終了コード時)に強制終了するように。`set -u`によって未定義の変数の利用を検知、パイプのエラーも厳格に扱うために`set -o pipefail`も使おう(これはちょっと微妙かも)。より複雑なスクリプトなら、EXITまたはERRシグナルに対して`trap`も使おう。使う場面としては以下の場合のようにエラーを検知してメッセージを出力するとき:\n\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- Bashスクリプトでは、コマンドのグループを作るのにサブシェル(丸括弧で囲まれた部分)が便利。一時的にワーキングディレクトリを移動するというよくある例。\n\n```bash\n      # カレントディレクトリで何か実行\n      (cd /some/other/dir && other-command)\n      # 元のディレクトリで作業続行\n```\n\n- Bashでは、たくさんの変数展開の種類があることを覚えておこう。変数が存在するかチェックするなら、`${name:?error message}`。例えば、Bashスクリプトが1つの引数を取る必要があるなら、`input_file=${1:?usage: $0 input_file}`とだけ書けばよい。算術式の展開は、`i=$(( (i + 1) % 5 ))`。シーケンスは`{1..10}`。文字列のトリミングは`${var%suffix}`と`${var#prefix}`。例えば`var=foo.pdf`の時、`echo ${var%.pdf}.txt`とすると`foo.txt`が出力に。\n\n- `{`...`}`を使った中括弧展開によって、似たようなコマンドを複数回入力しなくて済む。例えば、 `mv foo.{txt,pdf} some-dir` (両方のファイルを移動させる), `cp somefile{,.bak}` (`cp somefile somefile.bak` と展開される)、`mkdir -p test-{a,b,c}/subtest-{1,2,3}` (すべての可能な組み合わせでディレクトリが作られる).\n\n- 展開の順序は括弧→チルダ、パラメータや変数、計算機号、コマンド置換(左から右)→文字の分割→ファイル名の順だ。(例えば、{1..20}のような範囲は{$a..$b}というようには表現できない。`seq`や`for`ループを使ってこんな風に表すことができる。`seq $a $b or for((i=a; i<=b; i++)); do ... ; done`)\n\n- コマンドの出力を`<(some command)`のようにしてファイルのように扱える。例えば、ローカルとリモートのの`/etc/hosts`を比較するなら以下のようになる。\n\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- スクリプトを書く時は全てのコードを中括弧で囲まなくてはいけない。もし閉じ括弧が欠けていたらシンタックスエラーで実行が妨げられる。これはあなたがスクリプトをダウンロードしたときに判明する。（不完全なスクリプトの）実行によって部分的にwebからダウンロードしてしまうのを防ぐためだ。\n```bash\n{\n      # Your code here\n}\n```\n\n- 「ヒアドキュメント」によって、ファイルからの[複数行のリダイレクト](https://www.tldp.org/LDP/abs/html/here-docs.html)のように振る舞うことができる。\n```\ncat <<EOF\ninput\non multiple lines\nEOF\n```\n\n- Bashでは、`some-command >logfile 2>&1`または`some-command &>logfile`で標準出力と標準エラー出力の両方をリダイレクトできる。コマンドが標準入力に対してファイルハンドルを開きっぱなしにせず、ログインしているターミナルにひもづけておくため、`</dev/null`するのもよい習慣。\n\n- 16進と10進のASCIIテーブルを見るのに`man ascii`を使おう。一般的なエンコードに関する情報は、`man unicode`や`man utf-8`、`man latin1`が便利。\n\n- スクリーンの分割に`screen`や[`tmux`](https://tmux.github.io/)を使おう。特に、リモートのSSHセッションをデタッチしたりアタッチし直したりするのに有効。`byobu`はscreenやtmuxの情報をより多く提供してくれ、管理が容易になる。セッション永続化だけの簡単なものなら`dtach`。\n\n- SSHで`-L`あるいは`-D`(まれに`-R`)を使ったポートトンネルのやり方を覚えておくと便利。例えばリモートのサーバからウェブサイトにアクセスする時など。\n\n- SSHの設定を少しでも最適化しておくと便利。例えば以下の`~/.ssh/config`の設定だと、ネットワーク環境による接続断を回避し、圧縮を使用し(帯域の細い回線を使ったscpなどで便利)、ローカルの制御ファイルを指定して同一サーバとのチャネルを多重化する。\n\n```\n       TCPKeepAlive=yes\n       ServerAliveInterval=15\n       ServerAliveCountMax=6\n       Compression=yes\n       ControlMaster auto\n       ControlPath /tmp/%r@%h:%p\n       ControlPersist yes\n```\n\n- これ以外のSSHオプションはセキュリティ上の問題がある可能性があるため、有効にするには、サブネットごとやホストごとに指定したり、信頼できるネットワーク内でのみ使用するなど注意が必要。`StrictHostKeyChecking=no`、`ForwardAgent=yes`など。\n\n- [`mosh`](https://mosh.org/)はUDPを使ったsshの代替で、(サーバー側での設定は必要であるが) 断続的な接続時に便利。\n\n- 8進数表現のファイルパーミッションは、システム設定の際に便利だが`ls`の結果にも出てこず、間違いやすい。以下のようにして取得できる。\n\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 何らかのコマンドの出力から、インタラクティブに値を選択したい場合は、 [`percol`](https://github.com/mooz/percol) または [`fzf`](https://github.com/junegunn/fzf)を使おう。\n\n- (gitを使うなど)何らかのコマンドの出力からファイルに関するやり取りをする場合は、`fpp` ([PathPicker](https://github.com/facebook/PathPicker))を使おう。\n\n- カレントディレクトリ(とサブディレクトリ)全体を、ネットワーク内に公開されたWebサーバにするなら、`python -m SimpleHTTPServer 7777` (ポート7777で公開。Python 2の場合)あるいは`python -m http.server 7777` (Python 3の場合)。\n\n- 特権レベルでコマンドを実行するとき、rootでの実行には`sudo`、他のユーザの場合は`sudo -u`を利用。`su` または `sudo bash`で、シェルがそのユーザで起動する。`su -`でrootまたは他のユーザで新たにログインした状態がシミュレートされる。\n\n- 異なるユーザーのシェルに移りたいと時は`su username`や`su - username`を使おう。\"-\"を用いることでまるで他のユーザーがログインしたかのように環境を得ることができる。スイッチ先のユーザーのパスワードを求められる。\n\n- コマンドラインの[128K 制限](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)について知ろう。この\"Argument list too long\"エラーはワイルドカードに大量のファイルがマッチしてしまったときに出る一般的なものだ。(もしこれが起きたら`find` や `xargs`が代替として助けになるだろう。)\n\n- 基本的な計算(もちろんPythonの利用が一般的だ)には`python` interpreterを使おう。例えばこんな風に。\n```\n>>> 2+3\n5\n```\n\n## ファイルとデータの処理\n\n- カレントディレクトリ以下のファイルをファイル名で探したいなら、`find . -iname '*something*'`。場所を指定せずにファイル名で検索したいなら、`locate something`をつかおう(ただし`updatedb`は最近作られたファイルはインデックスしていないであろうことに注意)。\n\n- ソースやデータファイルの(`grep -r`よりも高度な)一般的な検索には、[`ack`](https://github.com/beyondgrep/ack2)、[`ag`](https://github.com/ggreer/the_silver_searcher) (\"the silver searcher\")、そして[`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep)を使おう。\n\n- HTMLをテキストに変換するなら、`lynx -dump -stdin`。\n\n- MarkdownやHTMLなど様々な種類のドキュメントの変換には、[`pandoc`](http://pandoc.org/)を試してみるとよい。\n\n- XMLを扱わなくてはならないなら、`xmlstartlet`は古いがいいツールだ。\n\n- JSONには[`jq`](http://stedolan.github.io/jq/)を使おう。\n\n- YAMLには[`shyaml`](https://github.com/0k/shyaml)を。\n\n- ExcelやCSVファイルには、[csvkit](https://github.com/onyxfish/csvkit)で`in2csv`、`csvcut`、`csvjoin`、`csvgrep`などが使えるようになる。\n\n- Amazon S3には、[`s3cmd`](https://github.com/s3tools/s3cmd)が便利で、[`s4cmd`](https://github.com/bloomreach/s4cmd)はさらに高速。AWS関連の処理にはAmazon公式の[`aws`](https://github.com/aws/aws-cli)と改善版の[`saws`](https://github.com/donnemartin/saws)が欠かせない。\n\n- `sort`や`uniq`、さらにuniqの`-u`や`-d`オプションを知っておこう。後に出てくるワンライナーも参照。`comm`も確認しておこう。\n\n- 複数のテキストファイルを操作するのには、`cut`と`paste`、`join`は知っておこう。`cut`はみんな使っているが、`join`は忘れられている。\n\n- `wc`を理解し、改行(`-l`)、文字(`-m`)、単語(`-w`)、バイト(`-c`)それぞれの数え方も知っておこう。\n\n- 標準入力をファイルと標準出力の両方に出す`tee`を理解しよう。`ls -al | tee file.txt`のように使う。\n\n- グルーピング、フィールドを入れ替える、統計的な計算といったもっと複雑な作業は[`datamash`](https://www.gnu.org/software/datamash/)の利用を検討しよう。\n\n- ロケールは、ソートの順序(照合順序)やパフォーマンスなど、たくさんのコマンドラインツールに微妙なところで影響することを覚えておこう。多くのLinuxディストリビューションでは、`LANG`や他のロケール変数はUS Englishのようなローカルな設定になっている。ロケールを変更するとソート順序が変わることに注意しよう。また、国際化(i18n)対応のルーチンはソートやその他の処理を*何倍も*遅く実行するようになる点も知っておこう。場合(設定の処理や一意性を見つける処理など)によっては、`export LC_ALL=C`としてしまい遅いi18n対応の処理を完全に無視してしまうことも可能だ。\n\n- `TZ=Pacific/Fiji date`のように起動時に変数を前につけることで、特定のコマンドの環境変数をセットすることができる。\n\n- 単純なデータ加工のために`awk`と`sed`の基礎を身につけよう。[ワンライナー](#ワンライナー)を参照。\n\n- 1つあるいは複数のファイル内の文字列を直接置き換えてしまうには、\n\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 複数のファイル名の変更やファイル内の検索や置換には、[`repren`](https://github.com/jlevy/repren)を使ってみよう。(場合によっては`rename`コマンドでも複数のファイル名変更ができるが、すべてのLinuxディストリビューションで挙動が同じであるわけではないので注意が必要。)\n\n```sh\n      # foo -> barへとファイル名、ディレクトリ名、ファイルの中身を変更する:\n      repren --full --preserve-case --from foo --to bar .\n      # バックアップファイルを元に戻す whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # 上記と同じものをrenameを使って:\n      rename 's/\\.bak$//' *.bak\n```\n\n- マニュアルページにあるように `rsync` は非常に高速で万能なファイルコピーの道具である。マシーン間のファイルを同期させることでよく知られているが、ローカルの場合でも同様に有用である。また、大量のファイルを削除する[高速な方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)としても利用できる:\n\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- 実行ファイルの進捗を監視したい場合、[`pv`](http://www.ivarch.com/programs/pv.shtml)、[`pycp`](https://github.com/dmerejkowsky/pycp)、 [`pmonitor`](https://github.com/dspinellis/pmonitor)、[`progress`](https://github.com/Xfennec/progress)や`rsync --progress`を使おう。ブロックレベルバックアップは`dd status=progress`だ。\n\n- ファイルからランダムな行を抜き出すには`shuf`\n\n- `sort`のオプションを理解しよう。数値に対しては`-n`を使い、人間にとって読みやすい形式の数値の場合(例えば、`du -h`の出力)は`-h`を使おう。キーがどのように処理されるのか(`-t`や`-k`)を知ろう。特に、最初の列だけでソートするには`-k1,1`と書く必要があり、`-k1`だと全行を見てソートされるという点に注意。\n\n- stableな(安定した)ソート(`sort -s`)は便利。例えば、始めに1列目でソートし、それから2列目でソートするなら、`sort -k1,1 | sort -s -k2,2`とすればよい。\n\n- Bashのコマンドライン上でタブを表現する必要がある場合、**ctrl-v** **[Tab]**を入力するか`$'\\t'` (コピペするなら後者の方がいいかも)。\n\n- ソースコードにパッチを当てる基本のツールは`diff`と`patch`。`diff`や横並びの`sdiff`の統計情報を見るなら`diffstat`も参照しよう。`diff -r`だと、ディレクトリ全体に対して実行される。変更点の概要を見るなら`diff -r tree1 tree2 | diffstat`。`vimdiff`ではファイルの比較と編集が可能。\n\n- バイナリファイルなら、単純な16進ダンプを見るのに`hd`、バイナリエディタには`bvi`。\n\n- 同じくバイナリファイルに関して、テキストを抽出したいなら`strings`(と`grep`などの組み合わせ)。\n\n- バイナリのdiff(デルタ圧縮)なら、`xdelta3`。\n\n- テキストエンコーディングの変換は`iconv`を使おう。あるいはより高度なツールとして`uconv`もあり、こちらはUnicodeの高度な処理が可能。例えば以下のコマンドでは小文字に変換しアクセント記号を取り除く(展開してから削除)。\n\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- ファイルを分割するなら`split`(サイズで分割)と`csplit`(パターンで分割)。\n\n- 日時について。現在日時を取得するには[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)が助けになる。`date -u +\"%Y-%m-%dT%H:%M:%SZ\"` を使おう。(他のオプションは[こちら](https://stackoverflow.com/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [problematic](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option))。日付や時間の表現を扱うには、[`dateutils`](http://www.fresse.org/dateutils/)にあるように、`dateadd`、 `datediff`、 `strptime` などを使いましょう。\n\n- 圧縮ファイルの操作は`zless`、`zmore`、`zcat`、`zgrep`。\n\n- `chattr`でファイル権限に代わる低階層のファイル属性情報をセットできる。例えば、意図しないファイル削除を防ぐフラグはこうやって立てる。`sudo chattr +i /critical/directory/or/file`\n\n- ファイルの権限を保存、リストアするには`getfacl`と`setfacl`を使おう。例は\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n- 空ファイルを素早く作るには`truncate`([sparse file](https://en.wikipedia.org/wiki/Sparse_file)を作成)、`fallocate`(ext4, xfs, btrfs とocfs2ファイルシステム)、`xfs_mkfile`(xfsprogs packageにあるほぼ全てのファイルシステム)、`mkfile` (Solaris、Mac OSといったUnix関連システム)\n\n## システムのデバッグ\n\n- Webのデバッグなら`curl`や`curl -l`が便利で、`wget`も同様、よりモダンなのは[`httpie`](https://github.com/jkbrzt/httpie)。\n\n- CPUやディスクのステータスを知るには、標準的なツールは`top` (または、より良い`htop`)、 `iostat`、 `iotop`。`iostat -mxz 15`を使って、基本的なCPUの情報やパーティッション単位でのディスクの詳細情報やパフォーマンスについて調べましょう。\n\n- ネットワークの状態の監視には、`netstat`や`ss`。\n\n- 手早くシステムで何が起きているのかを調べるには、`dstat`が便利。より詳しく見るには、[`glances`](https://github.com/nicolargo/glances)。\n\n- メモリのステータスを知るには、`free`あるいは`vmstat`を実行し、その出力の意味を理解しよう。特に、\"cached\"の値はLinuxカーネルにファイルキャッシュとして保持されているメモリ量であり、\"free\"の値を見る際に考慮すべきであることに注意しよう。\n\n- Javaのシステムのデバッグはまた違う困ったところがあるが、Oracleあるいは他のJVMにも共通しているシンプルなトリックは、`kill -3 <pid>`でフルスタックトレースとヒープの概要が標準出力あるいはログにダンプされる(世代別GCの詳細も参考程度だが含まれている)。JDKの `jps`、 `jstat`、 `jstack`、 `jmap` も便利で、[SJK tools](https://github.com/aragozin/jvm-tools)はより高度なツールである。\n\n- 改良版tracerouteとして[`mtr`](http://www.bitwizard.nl/mtr/)を使ってネットワークの問題を調査しよう。\n\n- ディスクがいっぱいになっている理由を調べるには、[`ncdu`](https://dev.yorhel.nl/ncdu)を使うと`du -sh *`より時間が節約できる。\n\n- 帯域を使っているのがどのソケットやプロセスなのかを見つけるには、[`iftop`](http://www.ex-parrot.com/~pdw/iftop/)あるいは[`nethogs`](https://github.com/raboof/nethogs)を試そう。\n\n- `ab`(Apacheに付属)は、Webサーバのパフォーマンスをざっくりチェックするのに便利。より複雑なテストには`siege`を試そう。\n\n- より確実なネットワークのデバッグは[`wireshark`](https://wireshark.org/)、[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)、[`ngrep`](http://ngrep.sourceforge.net/)。\n\n- `strace`と`ltrace`について知っておこう。プログラムの実行に失敗したりハングしたりクラッシュしたりして、その理由が分からない、あるいはパフォーマンスに関する一般的情報を知りたいなら、このツールが役立つはずだ。プロファイリングのオプション(`-c`)や起動中のプロセスにアタッチする機能(`-p`)も覚えておこう。\n\n- 共有ライブラリをチェックするなら`ldd`を覚えておこう。でも[怪しいファイルを指定して実行しないように](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)\n\n- 起動中のプロセスに`gdb`で接続し、そのスタックトレースを取る方法を知ろう。\n\n- `/proc`以下のファイルを使おう。今起こっている問題をデバッグするのには素晴らしく便利だ。例えば、`/proc/cpuinfo`、`/proc/meminfo`、`/proc/cmdline`、`/proc/xxx/cwd`、`/proc/xxx/ece`、`/proc/xxx/fd/`、`/proc/xxx/smaps` (ここで、`xxx`はプロセスIDまたはPIDを意味する)。\n\n- 過去に何か問題が起きたことの原因を探るなら、[`sar`](http://sebastien.godard.pagesperso-orange.fr/)がとても便利。CPUやメモリ、ネットワークなどの過去の統計情報を見られる。\n\n- さらに深いシステムとパフォーマンスの分析には、`stap` ([SystemTap](https://sourceware.org/systemtap/wiki))、[`perf`](https://en.wikipedia.org/wiki/Perf_(Linux))、\n[`sysdig`](https://github.com/draios/sysdig)。\n\n- どのOSを利用しているかを`uname`や`uname -a` (Unixカーネル情報)で確認しよう。どのディストリビューションを使っているかは`lsb_release -a` (ディストリビューション情報)。\n\n- 何かいつもと違うおかしなこと(大抵ハードウェアかドライバ関連の問題だ)が起きていたら、`dmesg`を実行しよう。\n\n- `du`で表示されたディスクースペースがファイルを消しても空かなかった場合、そのファイルがプロセスに使われているかどうかこうやって確認しよう。`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n## ワンライナー\n\nコマンドをまとめて使う例をいくつか。\n\n- `sort`や`uniq`を使ってテキストファイルの共通部分、結合、差異を求める時に特に便利なのが以下のやり方。`a`と`b`はそれぞれ内容に重複のないテキストファイルとする。この方法は高速で、数GB程度までの任意のファイルサイズで動作する(`/tmp`が小さなルートパーティションにある場合は`-T`オプションをつける必要があるが、ソートはメモリ内で行われるとは限らない)。上述の`LC_ALL`と`sort`の`-u`オプションも参照のこと。\n\n```sh\n      cat a b | sort | uniq > c   # cはaとbの和集合\n      cat a b | sort | uniq -d > c   # cはaとbの共通部分\n      cat a b b | sort | uniq -u > c   # cはaとbの差異\n```\n\n- `grep . *`(各行にファイル名が付く)や、`head -100 *` (ファイル毎にヘッダーが付く)を使って手軽にディレクトリ内の全てのファイルの中身を確認できる。設定ファイルが含まれるような`/sys`や`/proc`や`/etc/`に対して非常に便利である。\n\n- テキストファイルの3列目を全て足し合わせるには以下で(Pythonで同じことをやるに比べて3倍速く3分の1の長さで書ける)。\n\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- ファイルツリーのサイズやデータを確認したいなら、以下は再帰的な`ls -l`と同じだが`ls -lR`より見やすい。\n\n```sh\n      find . -type f -ls\n```\n\n- Webサーバのログのようなテキストファイルがあり、各行には例えばURLの中に出てくる`acct_id`のような特定の値が現れるとしよう。`acct_id`が何回リクエストされているかを集計するには、\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 継続的に変更を監視する場合 `watch`を使う。例えば、ディレクトリのファイルの変更を確認するには `watch -d -n 2 'ls -rtlh | tail'` となり、wifi設定などのネットワーク設定関係のトラブルシューティングでは `watch -d -n 2 ifconfig`。\n\n- このドキュメントからランダムに項目を抜き出すには以下の関数を実行しよう(Markdownをパースし、アイテムを抽出する)。\n\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## 目立たないが便利なもの\n\n- `expr`: 算術演算、論理演算、または正規表現の評価を実行\n\n- `m4`: シンプルなマクロプロセッサ\n\n- `yes`: 文字列をたくさん表示\n\n- `cal`: いい感じのカレンダー\n\n- `env`: コマンドを実行(スクリプト内で重宝する)\n\n- `printenv`: 環境変数を表示する(デバッグやスクリプト内での使用に便利)\n\n- `look`: 文字列で始まる英単語(またはファイル内の行)を見つける\n\n- `cut `、 `paste`、`join`: データの操作\n\n- `fmt`: テキストの段落をフォーマットする\n\n- `pr`: テキストをページとカラムにフォーマットする\n\n- `fold`: テキストの行を分割\n\n- `column`: テキストをカラムあるいはテーブルにフォーマット\n\n- `expand` と `unexpand`: タブとスペースの相互変換\n\n- `nl`: 行数を表示\n\n- `seq`: 数字を表示\n\n- `bc`: 計算機\n\n- `factor`: 整数を因数分解\n\n- [`gpg`](https://gnupg.org/): ファイルの暗号化と署名\n\n- `toe`: terminfoのエントリのテーブルを表示\n\n- `nc`: ネットワークのデバッグとデータ転送\n\n- `socat`: ソケットリレーとTCPポートのフォワーダ(`netcat`と同等)\n\n- [`slurm`](https://github.com/mattthias/slurm): ネットワークトラフィックの可視化\n\n- `dd`: データをファイルあるいはデバイス間で移動\n\n- `file`: ファイルの種類を特定\n\n- `tree`: ディレクトリとサブディレクトリをツリーで表示。`ls`に似ているが再帰的に動く\n\n- `stat`: ファイルの情報\n\n- `time`: コマンドを実行して処理時間を計測\n\n- `timeout`: コマンドを実行し、指定時間経過後にプロセスを停止する\n\n- `lockfile`: セマフォファイルを生成する。これは`rm -f`のみで削除可能。\n\n- `logrotate`: ログをローテート、圧縮、メール送信\n\n- `watch`: コマンドを繰り返し実行する。変更部分の強調表示もできる。\n\n- `tac`: ファイルを逆から表示\n\n- `shuf`: ファイルからランダムに選んだ行を表示\n\n- `comm`: ソート済みファイルの行を比較\n\n- `pv`: パイプ経由でデータの進行状況をモニタリング\n\n- `sponge`: 書き込み前に全ての入力を読み込む。例えば、`grep -v something some-file | sponge some-file` のように、入力と同じファイルに書き込む際に便利。\n\n- `hd`、`hexdump`、`xxd`、`biew`、`bvi`: バイナリファイルのダンプと編集\n\n- `strings`: バイナリファイルからテキストを抽出\n\n- `tr`: 文字の置き換えと操作\n\n- `iconv` あるいは `uconv`: 文字エンコーディングの変換\n\n- `split` と `csplit`: ファイルを分割\n\n- `units`: 単位の変換と計算。2週間あたりのハロン(訳注 : 長さの単位)からまばたきごとのトゥウィップまで( `/usr/share/units/definitions.units`も参照のこと)\n\n- `apg`: ランダムなパスワードを生成\n\n- `7z`: 圧縮率の高いファイル圧縮\n\n- `ldd`: 動的ライブラリの情報\n\n- `nm`: オブジェクトファイルからシンボルを表示\n\n- `ab`: Webサーバのベンチーマーク\n\n- `strace`: システムコールのデバッグ\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): ネットワークデバッグのためのより高機能なtraceroute\n\n- `cssh`: ビジュアルな並列シェル\n\n- `rsync`: ファイルやフォルダをSSH経由またはローカルファイルシステム内で同期\n\n- [`wireshark`](https://wireshark.org/) と [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): パケットキャプチャとネットワークデバッギング\n\n- [`ngrep`](http://ngrep.sourceforge.net/): ネットワーク層のgrep\n\n- `host` と `dig`: DNS名前解決\n\n- `lsof`:プロセスのファイルディスクリプタとソケット情報\n\n- `dstat`: 便利なシステム情報\n\n- [`glances`](https://github.com/nicolargo/glances): 高レベルに複数のサブシステムの概要を把握\n\n- `iostat`: ディスクの使用状況\n\n- `mpstat`: CPUの使用状況\n\n- `vmstat`: メモリの使用状況\n\n- `htop`: topの改良版\n\n- `last`: ログイン履歴\n\n- `w`: 誰がログインしているか\n\n- `id`: ユーザやグループの情報\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): システム統計情報の履歴\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) または [`nethogs`](https://github.com/raboof/nethogs): ソケットあるいはプロセスごとのネットワーク使用量\n\n- `ss`: ソケットの統計情報\n\n- `dmesg`: 起動時とシステムのエラーメッセージ\n\n- `sysctl`: Linuxカーネルパラメータの確認および設定\n\n- `hdparm`: SATA/ATAディスクの操作やパフォーマンス確認\n\n- `lsblk`: ブロックデバイスの一覧。ディスクとディスクパーティションのツリービュー\n\n- `lshw`、`lscpu`、`lspci`、`lsusb`、`dmidecode`: CPUやBIOS、RAID、グラフィック、その他デバイスなどのハードウェア情報\n\n- `lsmod`、`modinfo`: カーネルのモジュールリストとモジュール情報\n\n- `fortune`、 `ddate`、`sl`: んー、あー、これは蒸気機関車やZippyの引用句が「便利」だと思うかどうかによる\n\n## OS X用のもの\n\nこれらは*MacOS用*の項目です。\n\n- パッケージ管理は`brew` (Homebrew)や`port` (MacPorts)を使う。上記の多くのコマンドをMacOSにインストールできる。\n\n- コマンドの出力をクリップボードにコピーする`pbcopy`とクリップボードから出力する`pbpaste`。\n\n- OptionキーをaltキーとしてMac OSのターミナルで使う(上述の**alt-b**、**alt-f**などを使う場合)には、環境設定 -> 設定 -> キーボード で、\"メタキーとしてoptionキーを使用\"を選択。\n\n- デスクトップアプリケーションでファイルを開くには、`open`、`open -a /Applications/Whatever.app`。\n\n- Spotlight: `mdfind`でファイルを検索し、メタデータ(画像ファイルのEXIFの情報など)を`mdls`で表示。\n\n- Mac OSはBSD Unixベースであるため、多くのコマンド(例えば、`ps`、`ls`、`tail`、`awk`、`sed`)では、Unix System VとGNUツールの違いに影響されて、Linuxのものと比べて微妙な違いが多く含まれている。違いがあるかについては、マニュアルページのタイトルに\"BSD General Commands Manual\"と書かれているかどうかで判断できる。場合によっては、GNUバージョンをインストール可能である(例えば、`gawk`や`gsed`で、GNUのawkとsedに対応)。クロスプラットフォームのbashスクリプトを書く場合には、そのようなコマンドは避ける(Pythonや`perl`の利用を検討)か十分なテストが必要である。\n\n- Mac OSのリリース情報を取得するには、`sw_vers`。\n\n## Windows専用\n\nこれらは*Windows用*の項目です。\n\n### Windows下でUnixツールを手に入れる方法\n\n- [Cygwin](https://cygwin.com/)をMicrosoft WindowsでインストールしてUnixシェルの力を手にしよう。このドキュメントで説明されている大部分はびっくり箱みたいに独創的だ。\n\n- Windows10であれば[Windows Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about)を使える。Unixコマンドラインや親しみのあるBashを提供してくれる。\n\n- windows上で、主にGNUデベロッパーツール(GCCなど)を使いたい場合、[MinGW](http://www.mingw.org/)や[MSYS](http://www.mingw.org/wiki/msys)を検討しよう。bash、gawk、make、grepを提供してくれる。MSYSはCygwinと比べると全ての機能を持っているわけではない。MinGWはUnixツールのネイティブWindowsポートを作成するのに特に有効だ。\n\n- Windows配下でUnixの見た目と操作感を得るもう一つの方法は[Cash](https://github.com/dthree/cash)だ。本当に限られたUnixコマンドやコマンドラインオプションしかこの環境では利用できないので注意が必要だ。\n\n### 使えるWindowsコマンドラインツール\n- `wmic`を使って学ぶことで、Windowsシステム管理者タスクの大部分をコマンドラインで記述、実行することができる。\n\n- `ping`、`ipconfig`、`tracert`、`netstat`などのWindows固有のコマンドラインも便利だと思えるはずだ。\n\n- `Rundll32`を実行することによって[便利なWindowsタスク](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows)を利用することができる。\n\n### Cygwinの秘訣とコツ\n\n- Cygwinのパッケージマネージャーで追加のUnixプログラムをインストールしよう。\n\n- `mintty`をコマンドラインウィンドウとして使おう\n\n- `/dev/clipboard`でWindowsのクリップボードにアクセスしてみよう。\n\n- 登録されたアプリケーションで任意のファイルを開くためには`cygstart`を起動しよう。\n\n- `regtool`でWindowsレジストリにアクセスしよう。\n\n- `C:\\`WindowsドライブのパスはCygwin下では`/cygdrive/c`なので注意が必要だ。また、Cygwinの`/`はWindowsの`C:\\cygwin`だ。`cygpath`を使ってCygwinスタイルとWindowsスタイルのパスを切り替えられる。これはWindowsプログラムを実行するスクリプトでとても有効だ。\n\n## さらなるリソース\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): シェルのツールやリソースのまとめ\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): より詳しいMac OSのコマンドラインガイド\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/): よりよいシェルスクリプトを書くために\n- [shellcheck](https://github.com/koalaman/shellcheck): シェルスクリプト(本来、bash/sh/zsh用)の静的解析ツール\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): シェルスクリプトでファイル名を正しく扱うために\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): 同タイトルの書籍から引用されているデータサイエンスで役に立つコマンドやツール\n\n## 免責事項\n\nごく一部の例外はありますが、コードは誰でも読めるように書かれている。力には責任が伴う。Bashで*できる*からといって、そうすべき必要があるという意味ではない！ ;)\n\n## ライセンス\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nこのドキュメントは[Creative Commons Attribution-ShareAlike 4.0 International Licene](http://creativecommons.org/licenses/by-sa/4.0/)でライセンスされる。\n"
        },
        {
          "name": "README-ko.md",
          "type": "blob",
          "size": 48.87,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# The Art of Command Line\n\n[![Ask a Question](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Meta](#meta)\n- [Basics](#basics)\n- [Everyday use](#everyday-use)\n- [Processing files and data](#processing-files-and-data)\n- [System debugging](#system-debugging)\n- [One-liners](#one-liners)\n- [Obscure but useful](#obscure-but-useful)\n- [macOS only](#macos-only)\n- [Windows only](#windows-only)\n- [More resources](#more-resources)\n- [Disclaimer](#disclaimer)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\n커맨드 라인을 능숙하게 다루는 기술은 종종 도외시되거나 신비스럽게 여겨집니다. 하지만 커맨드 라인은 명백하고도 미묘한 방법으로 엔지니어가 하는 작업의 유연성과 생산성을 향상시킵니다. 이 문서는 리눅스에서 커맨드 라인을 사용할 때 유용하게 활용할 수 있는 노트와 팁들의 모음입니다. 몇몇은 기초적인 것들이지만 몇몇은 상당히 구체적이고 세련되며 잘 알려지지 않은 것들입니다. 이 문서는 그리 길지 않지만 여기 있는 모든 것을 사용할 수 있고 기억해낼 수 있다면 당신은 많은 것을 알고 있다고 할 수 있습니다.\n\n이 문서에는 [많은 저자와 번역가](AUTHORS.md)가 참여했습니다.\n여기 중 일부 내용은\n[원래](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[Quora에](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n[올라온](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know) 것이지만\n후에 GitHub으로 옮겨졌고, 이 곳에서 원 저자들보다 더 재능있는 사람들이 무수히 많은 개선작업을 진행하였습니다.\n커맨드 라인에 관해 궁금한 것이 있으면 [**질문해 주세요**.](https://airtable.com/shrzMhx00YiIVAWJg) 오류가 있거나 더 나아질 수 있는 내용이 보인다면 [**기여해 주세요**!](/CONTRIBUTING.md)\n\n## Meta\n\n범위:\n\n- 이 가이드는 초보자와 경험자 모두를 위한 것 입니다. 이 가이드의 목표는 _폭넓은 지식을 제공하는 것_(전부 다 중요합니다), _구체적으로 제공하는 것_(가장 일반적인 사례에 대한 구체적인 예제를 제공합니다), 그리고 _간결하게 제공하는 것_(중요하지 않거나 다른 문서에서 쉽게 찾아볼 수 있는 지엽적인 것들을 피합니다)입니다. 모든 팁은 특정 상황에서 매우 중요하거나 여러 다른 대안들보다 시간을 확연하게 절약합니다.\n- 이 문서는 리눅스를 위해 쓰였습니다. \"[macOS only](#macos-only)\", \"[Windows only](#windows-only)\" 섹션을 제외하고 말이죠. 그 밖의 대부분은 유닉스, macOS(심지어 Cygwin)에서도 적용하거나 설치할 수 있습니다.\n- 인터랙티브 Bash에 초점이 맞추어져있습니다만, 대부분의 팁은 다른 쉘이나, general Bash 스크립트에서도 동작합니다.\n- 이 문서는 \"표준\" 유닉스 커맨드와 특정 패키지 설치를 필요로 하는 것 둘 다 포함하고 있습니다 -- 여기서 다룰만큼 충분히 중요하다면요.\n\n노트:\n\n- 이 문서를 하나의 파일로 유지하기 위해서 콘텐츠들은 암시적인 레퍼런스 형태로 포함되어있습니다. 한 개념이나 명령어에 대해 알게 된 후에, 구글에서 그에 대한 좀 더 자세한 정보를 찾아보세요. `apt-get`, `yum`, `dnf`, `pacman`, `pip`, `brew` (혹은 적절한 다른 것)를 이용해 새 프로그램을 설치하세요.\n- [Explainshell](http://explainshell.com/)을 이용해서 커맨드, 옵션, 파이프, 기타 등등이 어떤 기능을 하는지 분석하는데 도움을 받으세요.\n\n\n## Basics\n\n- Bash의 기초를 배우세요. 말하자면, `man bash`를 실행하고 최소한 전부 훑어보기라도 하세요. 매뉴얼의 내용은 따라가기 쉬우며 그리 길지 않습니다. 다른 쉘들 또한 좋습니다만, Bash는 강력하고 언제나 사용 가능합니다(zsh, fish, 혹은 그 외의 쉘*만* 배운다면 개인 노트북에서는 좋겠지만 많은 경우 제한이 생길 것입니다. 이미 존재하는 서버를 사용하는 것등의 일에서 말이죠).\n\n- 텍스트 기반 에디터를 최소한 하나 정도는 잘 다룰 수 있게 배우세요. `nano` 에디터는 기본적인 편집기능(열기, 수정하기, 저장하기, 찾기)을 제공하는 가장 단순한 에디터 중 하나입니다. 그러나 텍스트 터미널을 이용하는 고급 이용자라면 Vim(`Vi`)을 대체할 수 있는 것은 없습니다. Vim은 사용법을 배우기는 어렵지만 믿음직하고 빠르며 풍부한 기능을 가졌습니다. 또한 고전적인 Emacs도 많이 사용됩니다. 특히 규모가 좀 더 큰 편집 작업에서요. (물론 요즘 같은 시대에 대형 프로젝트를 진행하고 있는 소프트웨어 개발자라면 순수한 텍스트 기반 에디터만 사용하지는 않을 것이고 최신의 그래픽 기반 IDE와 도구들에도 익숙해져야 합니다.)\n\n- `man`을 이용해서 문서를 읽는 법을 배우세요(호기심 많은 사람을 위해서 하는 얘기입니다만, `man man`은 섹션 번호들의 목록을 표시합니다. 예를 들어 1은 \"regular\" 커맨드, 5는 files/conventions, 그리고 8은 administration이죠). `apropos`를 이용해서 man 페이지를 찾으세요. 몇몇 커맨드는 실행파일이 아니라 Bash 빌트인 명령어임을 알아두세요. Bash 빌트인 명령어들에 대한 도움을 받으려면 `help`와 `help -d`를 이용하세요. 어떤 커맨드가 실행파일, 쉘 빌트인 명령어인지, 아니면 별칭인지는 `type command`를 통해 확인할 수 있습니다.\n\n- `>`와 `<`, `|`를 이용한 파이프를 사용해서 입력과 출력의 리다이렉션을 배우세요. `>`는 출력 파일을 덮어 씌우고, `>>`는 출력 파일 끝에 내용을 덧붙인다는 걸 알아두세요. stdout(역주: 표준 출력)과 stderr(역주: 표준 에러 출력)에 대해서 배우세요.\n\n- `*`(그리고 아마도 `?`와 `[`...`]`)을 이용하는 파일 글롭(glob) 확장을 배우세요. 그리고 쌍따옴표`\"`와 홑따옴표`'`의 차이를 배우세요. (변수 확장에 대해서 더 보려면 아래를 참조하세요)\n\n- Bash 작업 관리에 익숙해지세요. `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill` 등등.\n\n- `ssh`를 배우고, `ssh-agent`, `ssh-add`를 통해서 비밀번호 없는 인증 방식의 기본을 배우세요.\n\n- 기본 파일 관리: `ls`와 `ls -l`(특별히, `ls -l`에서 각각의 열이 무슨 의미인지 배우세요), `less`, `head`, `tail` 그리고 `tail -f`(또는 더 좋은 `less +F`), `ln`과 `ln -s`(하드 링크와 소프트 링크의 차이와 각각의 장단점을 배우세요), `chown`, `chmod`, `du`( 디스크 사용량의 빠른 요약을 보려면 `du -hs *`). 파일 시스템 관리를 위해서는 `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. inode가 무엇인지 배우세요(`ls -i` 또는 `df -i`).\n\n- 기본 네트워크 관리: `ip` 또는 `ifconfig`, `dig`, `traceroute`, `route`.\n\n- `git` 같은 버전 관리 시스템을 배우고 사용하세요.\n\n- 정규 표현식(regular expression)을 잘 알아두세요. 그리고 `grep`/`egrep`의 다양한 플래그도 알아두세요. `-i`, `-o`, `-v`,`-A`, `-B`와 `-C` 옵션은 알아둘 가치가 있습니다.\n\n- `apt-get`, `yum`, `dnf` 또는 `pacman`(배포판마다 다릅니다)을 이용하여 패키지를 찾고 설치하는 법을 배우세요. 그리고 `pip`가 설치되어 있는지 확인해서 파이선 기반의 커맨드 라인 도구를 설치할 수 있도록 하세요(밑에 설명된 것 중 몇 가지는 `pip`를 이용해 설치하는 게 제일 쉽습니다).\n\n\n## Everyday use\n\n- Bash 에서 **Tab**을 쓰면 argument를 완성하고, **ctrl-r**을 쓰면 커맨드 히스토리에서 검색합니다(누른 다음, 검색할 것을 입력하고, **ctrl-r**를 계속 눌러 좀 더 맞는 것을 찾을 수 있습니다. **Enter**를 눌러 찾은 커맨드를 실행하고 오른쪽 화살표 키를 눌러 결과를 현재 라인에 복사해 수정할 수 있습니다).\n\n- Bash에서 **ctrl-w**는 마지막 단어를 지웁니다. **ctrl-u**는 라인의 처음까지 전부다 지웁니다. **alt-b**와 **alt-f**를 이용해서 단어 단위로 이동할 수 있습니다. **ctrl-a**로 라인의 시작점으로 이동할 수 있고 **ctrl-e**로 라인의 끝으로 이동할 수 있습니다. **ctrl-k**는 커서 위치부터 라인의 끝까지 지웁니다. **ctrl-l**은 화면을 깨끗하게 합니다. `man readline`을 이용해서 Bash의 기본 키 조합을 살펴보세요. 많은 것이 있습니다. 예를 들면 **alt-.**같은 경우, 이건 argument를 돌아가면서 나타내고 **alt-***는 글롭을 확장합니다.\n\n\n- vi 스타일의 키  조합을 사랑한다면, `set -o vi`를 사용할 수도 있습니다(`set -o emacs`로 되돌릴 수 있습니다).\n\n- 긴 명령을 수정하려면 에디터를 설정한 다음(예를 들면, `export EDITOR=vim`) **ctrl-x** **ctrl-e**를 눌러 현재 명령을 에디터에서 열어 여러줄 편집을 할 수 있습니다. vi 스타일에서는 **escape-v**를 사용합니다.\n\n- 최근 사용한 커맨드를 보려면 `history`를 입력하세요. 그 후 `!n`으로(여기서 `n`은 커맨드 번호를 뜻합니다) 다시 실행할 수 있습니다. `!$`(마지막 argument), `!!`(마지막 커맨드)와 같은 약어들이 매우 많습니다. 비록 이런 것들이 **ctrl-r**이나 **alt-.**명령어로 자주 대체되기 쉽지만요.\n\n- `cd`로 홈 디렉터리로 갈 수 있습니다. 홈 디렉터리에서 상대적으로 파일을 접근하려면 `~` 접두사를 사용합니다(예: `~/.bashrc`). `sh` 스크립트에서는 `$HOME`로 홈 디렉터리를 참조합니다.\n\n- 이전에 작업하던 디렉터리로 돌아가려면 `cd -`를 사용하세요.\n\n- 커맨드를 타이핑하던 도중에 마음이 바뀌었다면, **alt-#**을 쳐서 시작점에 `#`을 삽입하고, 엔터를 쳐서 코멘트로 여겨지게 하세요(또는 **ctrl-a**, **#**, **enter**).  나중에 커맨드 히스토리에서 찾아서 타이핑 중이었던 커맨드로 돌아올 수 있습니다.\n\n- `xargs`(혹은 `parallel`)를 사용하세요. 매우 강력합니다. 라인당 몇 개의 아이템이 실행되게 할 것인지(`-L`) 그걸 병렬로 할 것인지(`-P`)를 제어할 수 있다는 걸 기억하세요.  제대로 하고 있는지 확신할 수 없다면 `xargs echo`를 먼저 실행해보세요. 또 `-I{}`도 편리합니다. 예시:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p`는 프로세스 트리를 표시하는데 도움이 됩니다.\n\n- `pgrep`과 `pkill`을 사용해서 프로세스를 찾거나 시그널을 보내세요(`-f`가 유용합니다).\n\n- 프로세스에 보낼 수 있는 다양한 시그널을 알아두세요. 예를 들어, 프로세스를 일시 중지 할 때는 `kill -STOP [pid]`를 사용합니다. 전체 목록은 `man 7 signal`에서 볼 수 있습니다.\n\n- 백그라운드 프로세스를 영원히 돌아가게 만들고 싶다면, `nohup`이나 `disown`을 사용하세요.\n\n- 어떤 프로세스가 리스닝(역주: 특정 포트로 들어오는 패킷 리스닝)을 하고 있는지 알려면 `netstat -lntp`나 `ss -plat`을 사용해서 알 수 있습니다(TCP 일 경우입니다. UDP의 경우 `-u`옵션을 추가하세요).\n\n- `lsof`를 이용해서 열려있는 소켓과 파일을 볼 수 있습니다.\n\n- `uptime`이나 `w`를 이용해서 시스템이 얼마나 오래 실행 중인지 알 수 있습니다.\n\n- 자주 사용되는 커맨드에 대해서 `alias`를 이용해서 숏컷을 만드세요. 예를들어, `alias ll='ls -latr'`은 새 단축 명령 `ll`을 만듭니다.\n\n- 자주 사용하는 단축, 설정, 함수는 `~/.bashrc`에 저장하고, [그것을 참조하는 로그인 셸을 고쳐보세요](http://superuser.com/a/183980/7106). 이렇게 하면 설정을 모든 셸 세션에서 사용할 수 있습니다.\n\n- 환경 변수 설정이나 로그인할 때 실행해야 할 명령은 `~/.bash_profile`에 넣으세요. 그래픽 환경의 로그인의 셸과 `cron` 잡의 셸을 분리하기 위해 설정을 분리할 필요가 있습니다.\n\n- Git으로 여러 컴퓨터에서 같은 설정 파일을 사용하세요(예 `.bashrc`, `.bash_profile`).\n\n- 공백이 들어간 변수명이나 파일명은 주의할 필요가 있습니다. Bash 변수를 따옴표로 감싸세요(예: `\"$FOO\"`). 파일 이름의 경계에 공백 문자를 허용하려면 `-0`이나 `-print0` 옵션을 사용하세요. 예를 들면, `locate -0 pattern | xargs -0 ls -al`, `find / -print0 -type d | xargs -0 ls -al`. for 문에서 공백문자가 포함된 파일 이름을 반복하려면, `IFS=$'\\n'`로 IFS를 개행 문자만으로 설정하시면 됩니다.\n\n- Bash 스크립트에서 `set -x`를 사용하면 디버깅용 출력을 사용하게 됩니다(아니면 다른 옵션  `set -v`가 있습니다. 확장되지 않은 변수와 주석을 포함한 로우 입력을 로깅합니다). 스트릭트 모드(strict mode)가 가능할 때면 사용하세요. `set -e`를 사용하면 에러가 났을 때 중단시키게 됩니다. `set -u`을 사용하면 설정되지 않은 변수를 찾아 줍니다. `set -o pipefail`을 사용하면 에러에 대해서 강경한 기준을 적용합니다(이 주제가 조금 미묘하지만 말이죠). 더 복잡한 스크립트의 경우 EXIT나 ERR에 `trap`도 사용합니다. 이렇게 스크립트를 시작하는 습관은 유용합니다. 이렇게 하면, 일반적인 에러를 찾고 중단하고, 메시지를 출력해 줍니다.\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- Bash 스크립트에서 (괄호로 둘러싸여 작성된) 서브 셸은 커맨드를 그룹으로 묶는 편리한 방법입니다. 일반적인 예로, 임시로 다른 디렉터리로 이동하여 작업하는 것이 있습니다.\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- Bash 에는 다양한 변수 확장이 있다는 것을 알아두세요. 변수가 존재하는지 확인하려면 `${name:?error message}`를 사용하세요. 예를 들어 Bash 스크립트가 하나의 argument를 요구한다면, `input_file=${1:?usage: $0 input_file}`를 사용하세요. 변수가 비어있을 때를 대비해 기본 값을 사용하세요. `${name:-default}` 이전 예제에 선택적인 파라미터를 추가하길 원한다면 `output_file=${2:-logfile}`로 할 수 있습니다. $2가 생략되어 비어있다면, `output_file`은 `logfile`로 설정됩니다. 산술 확장은 `i=$(( (i + 1) % 5 ))` 처럼 사용합니다. 순열은 `{1...10}`처럼 사용합니다. 문자열 트리밍(trimmin)은 `${var%suffix}`이나 `${var#prefix}`처럼 사용할 수 있습니다. 예를 들어 `var=foo.pdf`라면, `echo ${var$.pdf}.txt`는 `foo.txt`를 출력합니다.\n\n- `{`...`}`를 사용한 괄호 확장은 비슷한 텍스트의 재입력을 줄이고, 아이템의 조합을 자동화할 수 있습니다. `mv foo.{txt,pdf} some-dir` (양쪽 파일들을 옮김), `cp somefile{,.bak}` (`cp somefile somefile.bak`로 확장), `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (모든 가능한 조합으로 확장해 디렉터리 트리를 생성) 같은 예제들은 유용합니다.\n\n- 커맨드의 실행 결과 출력물은 `<(some command)`처럼 이용해서 파일처럼 다뤄질 수 있습니다. 예를 들어 로컬의 `/etc/hosts`를 리모트의 것과 비교하려면 다음처럼 하면 됩니다.\n```bash\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- 스크립트를 적을 때 모든 코드를 대괄호 안에 넣을 수 있습니다. 닫는 괄호가 없으면 스크립트는 구문 에러가 되어 실행이 방지됩니다. 이는 스크립트가 웹으로부터 다운로드할 예정이라 할 때 도중까지만 다운로드된 파일이 실행 되는 걸 예방해 줍니다.\n```sh\n{\n      # 여기에 코드를 넣으세요\n}\n```\n\n- `cat << EOF...`같은 \"here documents\"에 대해서 알아두세요.\n\n- Bash에서 표준 출력(standard output)과 표준 에러(standard error) 둘 다 `some-command > logfile 2>&1`같은 명령어로 리다이렉트할 수 있습니다. 종종, 커맨드가 열린 파일 핸들을 남기지 않는 것을 확실히 하기 위해, 현재 작업 중인 터미널에서 명령어에 `</dev/null`을 덧붙이는 것은 좋은 습관입니다.\n\n- `man ascii`를 사용해서 헥스 값과 10진 값이 같이 있는 훌륭한 ASCII 테이블을 볼 수 있습니다. 일반적인 인코딩 정보를 보려면 `man unicode`, `man utf-8` 그리고 `man latin1`을 이용할 수 있습니다.\n\n- `screen`을 이용하거나  [`tmux`](https://tmux.github.io/)를 이용해서 화면을 다중 분할할 수 있습니다. 특히 리모트 ssh 세션을 떼어내고(detach) 다시 붙이는데(re-attach) 유용합니다. `byobu`은 스크린이나 tmux보다 더 많은 정보를 제공하며, 관리를 편합니다. 세션을 영구히 유지하는 최소한의 대안은 오직 [`dtach`](https://github.com/bogner/dtach)밖에 없습니다.\n\n- ssh에서 `-L`이나 `-D`(가끔 `-R`)를 이용해서 포트 터널링 하는 것을 알아두시면 유용합니다. 예를 들어 리모트 서버를 경유해서 웹사이트에 접속한다거나 할 때 말이죠.\n\n- 몇 가지 ssh 설정을 최적화하는 것은 유용할 수 있습니다. 예를 들어 `~/.ssh/config`는 특정 네트워크 환경에서 연결이 끊기는 것을 회피하기 위해 압축을 사용하는 설정들을 담고 있습니다(특히 scp 명령어를 낮은 대역폭 연결에서 사용하는 경우에 도움이 됩니다. 그리고  로컬 제어 파일에서 같은 서버로 연결하는 채널을 다중화할 수 있습니다.\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n-  ssh의 몇 가지 옵션들은 보안에 민감한 옵션이며 주의를 가지고 사용되어야 합니다. 예를 들어 서브넷, 호스트 또는 신뢰되는 네트워크에서 `StrictHostKeyChecking=no`, `ForwardAgent=yes`을 사용하는 것 등입니다.\n\n- UDP을 사용하는 ssh의 대안으로 [`mosh`](https://mosh.org/)를 고려해 보세요. 연결이 끊기는 것을 방지하고 길에 편리함이 더해집니다.(서버 사이드 설정 필요)\n\n- 시스템 설정에 유용하지만 `ls`로 얻을 수 없고 쉽게 엉망이 되기 쉬운 파일의 권한을 8진법 형태로 얻으려면, 다음과 같은 커맨드를 사용하세요.\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 다른 커맨드의 출력과 상호작용하면서 값을 선택하려면  [`percol`](https://github.com/mooz/percol)이나 [`fzf`](https://github.com/junegunn/fzf)를 사용하세요.\n\n- 다른 커맨드(예를 들면 `git`)의 출력으로 파일과 상호작용하려면, `fpp` ([PathPicker](https://github.com/facebook/PathPicker))를 사용하세요.\n\n- 현재 네트워크에 있는 사용자들에게 현재 디렉터리에 있는 모든 파일(과 하위 디렉터리)를 위한 단순한 웹서버를 원한다면 다음을 사용하세요:\n`python -m SimpleHTTPServer 7777` (7777포트, Python 2) 그리고 `python -m http.server 7777` (7777포트, Python 3).\n\n- 권한을 가지고 커맨드를 실행하려면, `sudo`를 사용하세요. 기본값은 root 실행하며 `sudo -u`로 다른 유저를 지정할 수 있습니다. `-i`를 이용해 다른 사람으로 로그인 할 수 있습니다.(_당신의_ 패스워드를 물어볼 것입니다)\n\n- 셸을 다른 유저로 전환하려면 `su username`나 `su - username`를 사용하세요. `-`를 넣으면 그 유저가 방금 로그인한 것 같은 환경을 얻을 수 있습니다. 유저 이름을 생략하면 기본값은 root가 됩니다. _당신이 전환하려하는 유저의_ 비밀번호를 물어볼 것입니다.\n\n- 커맨드 라인의 [128K 제한](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)을 알아 두세요. \"Argument list too long\" 에러는 많은 파일을 와일드카드 매칭할 때 일반적으로 일어납니다. (이런 일이 일어났을 때에는 `find`, `xargs`같은 것이 도움 됩니다.)\n\n- 단순한 계산에는(물론 일반적으로는 Python에 접근하기 위해) `python` 인터프리터를 사용하세요. 예를 들어 이렇게 사용할 수 있습니다.\n```\n>>> 2+3\n5\n```\n\n\n## Processing files and data\n\n- 현재 디렉터리에서 파일을 이름으로 찾으려면 `find . -iname '*something*'` (또는 비슷하게)를 사용하면 됩니다. 어느 곳에 있든 파일을 이름으로 찾으려면 `locate something`을 사용하세요(하지만 인내를 가져야 합니다. `updatedb`가 최근에 생성된 파일을 인덱싱하지 않았을 수 있습니다).\n\n- 소스나 데이터 파일들에서 일반적인 검색을 할 때는(`grep -r`보다 더 복잡할 때), [`ag`](https://github.com/ggreer/the_silver_searcher)를 사용하세요.\n\n- HTML을 텍스트로 변환할 때는 `lynx -dump -stdin`를 사용하세요.\n\n- 마크다운, HTML, 그리고 모든 종류의 문서 변환에는 [`pandoc`](http://pandoc.org/)을 시도해보세요.\n\n- XML을 반드시 다뤄야한다면, `xmlstarlet`을 사용하세요. 오래되었지만 좋습니다.\n\n- JSON에는 [`jq`](http://stedolan.github.io/jq/)를 사용하세요.\n\n- YAML에는 [`shyaml`](https://github.com/0k/shyaml)를 사용하세요.\n\n- Excel이나 CSV파일에는 [csvkit](https://github.com/onyxfish/csvkit)가 `in2csv`, `csvcut`, `csvjoin`, `csvgrep`외 다른 도구들을 제공합니다.\n\n- Amazon S3를 다룰 때는 [`s3cmd`](https://github.com/s3tools/s3cmd)가 편리합니다. 그리고 [`s4cmd`](https://github.com/bloomreach/s4cmd)는 빠릅니다. Amazon의  [`aws`](https://github.com/aws/aws-cli)는 다른 AWS 관련 작업에 핵심적인 도구입니다.\n\n- `sort`와 `uniq`에 대해서 알아두세요. uniq의 `-u`, `-d`옵션을 포함해서 말이죠. 하단의 one-liner를 보세요. 그리고 `comm`도 보세요.\n\n- 텍스트 파일들을 다루는 `cut`, `paste` 그리고 `join`에 대해서 알아두세요. 많은 사람들이 `cut`을 사용하지만 `join`에 대해서는 잊고 있습니다.\n\n- `wc`를 이용해서 행(`-l`), 캐릭터(`-m`), 단어(`-w`) 그리고 바이트(`-c`)를 세는 것을 알아두세요.\n\n- `tee`를 이용해서 `ls -al | tee file.txt`처럼, 표준 입력(stdin)에서 복사해서 파일로 보내거나, 표준 출력(stdout)으로 보내는 것을 알아두세요.\n\n- 그룹, 필드 뒤집기, 통계적인 계산 같은 좀 더 복잡한 계산은 [`datamash`](https://www.gnu.org/software/datamash/)를 고려해보세요.\n\n- 로케일이 커맨드 라인 도구에 정렬 순서(collation)와 퍼포먼스를 포함해서 미묘하게 영향을 끼치는 것을 알아두세요. 대부분의 리눅스 설치는 `LANG`이나 다른 로케일 변수를 US English와 같은 로컬 세팅으로 설정합니다. 하지만 로케일을 바꿀 경우 정렬도 바뀔 것이라는 것에 주의하세요. 그리고 i18n 루틴들도 정렬이나 다른 커맨드들을 *몇 배* 느리게 할 수 있습니다. `export LC_ALL=C`를 사용하여, 어떤 상황에서는( 밑에 있는 집합(set) 작업이나, 유일성 작업등) i18n의 느린 루틴들을 통째로 안전하게 무시할 수 있습니다. 그리고 전통적인 바이트 기반의 정렬 순서를 사용할 수 있습니다.\n\n- `TZ=Pacific/Fiji date`처럼 특정 명령의 환경 변수를 실행 앞에 붙여 설정할 수 있습니다.\n\n- 간단한 데이터 조작을 할 때 `awk`와 `sed`를 이용하는 것을 알아두세요. 예를 들어 텍스트 파일의 세 번째 열의 숫자들의 모든 값을 더하는 것은 이렇게 합니다: `awk '{ x += $3 } END { print x }'`. 이 방법은 같은 일을 하는 파이썬 코드보다 3배 정도 빠르고, 1/3 정도의 길이밖에 안됩니다.\n\n- 여러 파일 안의 문자열을 바꾸려면 다음과 같이 하세요.\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 여러 파일의 이름을 바꾸거나 검색하거나 문자열을 바꿀 때에는 [`repren`](https://github.com/jlevy/repren)를 써보세요. (어떤 경우에는 `rename` 명령을 사용해서 여러 파일의 이름을 바꿀 수도 있습니다. 하지만, 모든 리눅스 배포판에서 같은 동작을 하지 않는 것에 주의하세요.)\n```sh\n      # 파일 이름, 디렉터, 컨텐츠 모두 foo에서 bar로 변경\n      repren --full --preserve-case --from foo --to bar .\n      # 백업 파일을 whatever.bak에서 whatever로 복원\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # 가능하다면 rename으로 위와 같은 일을 할 수 있음\n      rename 's/\\.bak$//' *.bak\n```\n\n- man 페이지가 이야기하듯, `rsync`는 정말 빠르고 다재다능한 파일 복사 도구입니다. 기기 간의 동기화에 사용하는 것으로 알려져 있지만, 로컬에서도 충분히 유용합니다. 보안 규정이 허용한다면, `scp` 대신 `rsync`를 사용하면 처음부터 전송하는 대신 중단된 지점부터 재전송할 수 있습니다. 또 많은 수의 파일을 삭제하는 [가장 빠른 방법](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)이기도 합니다.\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- `shuf`를 사용해서 파일 안의 임의의 행을 선택하거나, 섞을 수 있습니다.\n\n- `sort`의 옵션을 알아두세요. `-n`은 숫자를 정렬할 때, `-h`는 사람이 읽을 수 있게 작성한 숫자의 경우(`du -h`와 같은 형태). 키가 어떻게 작동하는지 알아두세요(`-t`와 `-k`). 특별히, 첫 번째 필드로만 정렬해야 한다면 `-k1,1`을 적어야 한다는 걸 주의하세요. `-k1`은 모든 행에 대해서 정렬하라는 뜻입니다.  안정적인 정렬(`sort -s`)도 유용합니다. 예를 들어, 먼저 2번 필드로 정렬하고, 그다음에 1번 필드로 정렬할 경우, `sort -k1,1 | sort -s -k2,2`처럼 할 수 있습니다.\n\n- 만약 탭(tab)문자를 Bash 커맨드 라인에 사용해야 할 필요가 생길 경우(예를 들면 -t argument를 이용해 정렬 할 때), **ctrl-v** **[Tab]**키를 누르거나, `$'\\t'`를 쓰세요(문자쪽이 복사나 붙여넣기를 할 수 있어 더 낫습니다.).\n\n- 소스 코드를 패치하는 기본 도구는 `diff`와 `patch`입니다. diff와 `sdiff`(새로 diff)의 통계 요약을 보려면 `diffstat`를 보세요. `diff -r`은 모든 디렉터리에 대해 작업을 수행하는 걸 알아두세요. `diff -r tree1 tree2 | diffstat`으로 변경 내역의 요약을 볼 수 있습니다.\n\n- 바이너리 파일을 간단하게 hex 덤프를 뜨고 싶을 때는 `hd`, `hexdump`, `xxd`를 쓰세요. 바이너리 파일을 수정할 때는 `bvi`, `biew`를 사용하세요.\n\n- `strings` (그리고 `grep`, 등) 을 사용해서 바이너리 파일 안에서 문자열 비트를 찾을 수 있습니다.\n\n- 바이너리 파일을 diff하려면(델타 압축), `xdelta3`를 사용하세요.\n\n- 텍스트 파일 인코딩을 변경하려면 `iconv`를 시도해보세요. 또는 `uconv`는 더 복잡한 목적에 사용할 수 있습니다. `uconv`는 몇 가지 복잡한 유니코드를 지원합니다. 예를 들어, 소문자화하고 모든 악센트를 제거하는(확장하고, 떨어트리는 것을 이용해서) 커맨드는 다음과 같습니다.\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- 파일을 여러 조각으로 나누려면 `split`(파일을 사이즈로 나눔)이나 `csplit`(파일을 패턴으로 나눔)을 보세요.\n\n- 날짜 시간 표현식을 제어하려면 [`dateutils`](http://www.fresse.org/dateutils/)의 `dateadd`, `datediff`, `strptime`등을 사용하세요.\n\n- `zless`, `zmore`, `zcat` 그리고`zgrep`을 이용해서 압축된 파일에 대해 작업하세요.\n\n- 파일 속성은 `chattr`로 설정할 수 있습니다. 이는 파일 권한에 대한 저레벨 대안입니다. 예를 들어 `sudo chattr +i /critical/directory/or/file`로 불변 플래그를 붙여 실수로 파일을 지우는 것을 방지할 수 있습니다.\n\n- `getfacl`, `setfacl`를 사용해 파일 권한을 저장하고 복원할 수 있습니다. 예를 들어,\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n## System debugging\n\n- 웹 디버깅을 위해서는 `curl` 와 `curl -I` 가 도움이 되고, `wget`도 꽤 도움이 됩니다. 그 외에 보다 현대적인 방식으로는 [`httpie`](https://github.com/jakubroztocil/httpie)이 있습니다.\n\n- cpu/디스크의 상태를 알기 위해서는 `top` (혹은 더 나은 명령어인 `htop`), `iostat`, `iotop`을 사용하세요. `iostat -mxz 15`를 사용해 기본 CPU와 파티션 디스크별 정보와 성능 정보를 알 수 있습니다.\n\n- 네트워크 상태를 자세히 알려면 `netstat`, `ss`를 사용하세요.\n\n- 시스템에 어떤 일이 일어났는지 보려면 `dstat`가 특히 유용합니다. 보다 시스템의 심층적인 면들을 보려면 [`glances`](https://github.com/nicolargo/glances)를 사용해보세요.\n\n- 메모리의 상태를 알아보려면 `free` 와 `vmstat`를 실행하고 그 결과를 해석해보세요. 특히, \"cached\" 값은 Linux kernel에 의해 file cache로 잡혀있는 메모리 라는 것을 알고 있어야 하고 그래서 \"free\"값에 대해서 보다 효율적으로 계산할 수 있습니다.\n\n- Java 시스템의 디버깅은 조금 다른 상황입니다. 하지만 Oracle과 그 외의 회사에서 만든 다른 JVM들에서는 `kill -3 <pid>`를 실행하면 전체 stack trace 정보와 heap의 정보(시기별로 가비지 컬렉터의 세부적인 내용 같은 매우 유용한 정보)를 요약하여 stderr나 로그로 출력해주므로 간단하게 정보를 얻어올 수 있습니다. JDK의 `jps`, `jstat`, `jstack`, `jmap` 명령은 유용합니다. [SJK tools](https://github.com/aragozin/jvm-tools)은 더 고급 정보를 다룰 수 있습니다.\n\n- 네트워크 이슈들을 알아보기 위해서는 traceroute를 사용할 수도 있지만 더 좋은 [`mtr`](http://www.bitwizard.nl/mtr/)를 사용하세요.\n\n- 디스크가 왜 가득 찼는지 알아보기 위해서 [`ncdu`](https://dev.yorhel.nl/ncdu)를 사용해보세요.  일반적으로 사용하는 `du -sh *`와 같은 커맨드를 사용하는 것보다는 시간을 줄일 수 있습니다.\n\n- 어떠한 소켓이나 프로세스가 사용하는 대역폭(bandwidth)를 찾아보려면 [`iftop`](http://www.ex-parrot.com/~pdw/iftop/)나 [`nethogs`](https://github.com/raboof/nethogs)를 사용하세요.\n\n- `ab`라는 툴(Apache에 딸려있는)은 신속하고 간단하게(quick-and-dirty) 웹서버의 성능을 체크하는데 유용합니다. 보다 복잡한 부하 테스트를 할 때는 `siege`를 사용해보세요.\n\n- 보다 심각한 경우의 네트워크 디버깅을 위해서는 [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), [`ngrep`](http://ngrep.sourceforge.net/)를 사용하세요.\n\n- `strace` 와 `ltrace`에 대해서 알아보세요. 이 커맨드들은 만일 어떤 프로그램에서 failing, hanging 혹은 crashing이 일어나거나 그 외에 여러분이 무슨 이유인지 알지 못하는 상황이나 성능에 대한 대략적인 내용을 얻고자 할 때 유용할 것입니다. 특히 프로파일링을 위한 옵션(`-c`)과 현재 실행 중인 프로세스에 붙이기 위한 옵션(`-p`)을 기억하세요.\n\n- 공유 라이브러리(shared libraries) 등을 체크하기 위해서는 `ldd`에 대해 알아보세요.\n\n- `gdb`를 가지고 현재 실행 중인 프로세스에 연결하고 그 프로세스의 stack trace들을 얻는 방법을 알아보세요.\n\n- `/proc`를 사용하세요. 이것은 현재 발생하고 있는 문제를 디버깅할 때 종종 놀랍도록 큰 도움이 될 것입니다. 예시:`/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (`xxx`는 프로세스 id나 pid입니다).\n\n- 과거에 왜 무엇인가가 잘못되었는지를 디버깅할 때에는 [`sar`](http://sebastien.godard.pagesperso-orange.fr/)가 매우 유용할 것입니다. 이 커맨드는 CPU, memory, network 등의 통계 내역을 보여줍니다.\n\n- 시스템의 보다 깊은 곳을 보거나 퍼포먼스를 분석하기 위해서는, `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](http://en.wikipedia.org/wiki/Perf_(Linux)), [`sysdig`](https://github.com/draios/sysdig)를 사용해보세요.\n\n- 여러분이 사용하는 Linux의 배포판이 무엇인지 확인(대부분의 배포판에서 작동합니다)하려면 `uname`이나 `uname -a` 또는 `lsb_release -a`를 사용하세요.\n\n- 언제든지 무언가가 정말로 재미있는 반응을 보인다면 `dmesg`를 사용해보세요(아마도 하드웨어나 드라이버의 문제일 것입니다).\n\n- 파일을 삭제했는데 `du`로 확인해 예상한 디스크 공간을 확보하지 못했다면, 파일이 프로세스에 의해 사용 중인지 확인해보세요.\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## One-liners\n\n커맨드들을 한데 묶어서 사용하는 예제들\n\n- `sort`/`uniq`를 사용하여 텍스트 파일의 교차점, 조합, 차이점을 확인이 필요할 때 상당한 도움이 될 겁니다. 가령 `a`와 `b`가 유일한 값들만을 가진 텍스트 파일이라 합시다. 이것이 임의의 크기인 파일을(그게 기가바이트라고 해도) 빠르게 작업할 수 있습니다. (Sort는 메모리 제한에 걸리지 않습니다만, 만약 루트 파티션이 작은 경우, `/tmp`를 사용하기 위해 `-T`옵션을 사용하면 됩니다.) 위의 `LC_ALL`에대한 내용은 `sort`의 `-u`옵션을 확인하십시오. (아래 예제에 집중하기 위해서 생략)\n```sh\n      cat a b | sort | uniq > c   # c is a union b\n      cat a b | sort | uniq -d > c   # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n\n- `grep . *`을 사용해서 디렉터리 안의 모든 파일을 비주얼하게 살펴볼 수 있습니다.(r각 줄은 파일 이름과 같이 나옵니다) 아니면 `head -100 *`를 이용할 수도 있습니다.(각 파일의 해더만 볼 수 있습니다.) 이는 `/sys`, `/proc`, `/etc` 같이 설정값들로 가득한 디렉터리에서 유용합니다.\n\n\n- 텍스트 파일의 세 번째 열의 숫자들의 모든 값을 더하는 것은 이렇게 합니다. 이 방법은 같은 일을 하는 파이썬 코드보다 3배 정도 빠르고, 1/3 정도의 길이밖에 안됩니다.\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- 파일 트리에서 크기와 날짜를 보려면 이렇게 하세요. 이 명령어는 `ls -l`을 재귀적으로 수행하는 것과 같지만, `ls -lR`보다 더 읽기 쉽습니다.\n```sh\n      find . -type f -ls\n```\n\n- 웹서버 로그 같은 텍스트 파일이 있다고 합시다. 그리고 URL 파라미터에 나타나는 `acct_id`같은 특정 값이 몇몇 행에 나타난다고 해보죠. 각각의 `acct_id`에 대해 얼마나 많은 요청이 있었는지 알고 싶다면 다음처럼 할 수 있습니다.\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 변경을 계속 모니터링하려면 `watch`를 이용하세요. 예를 들어 `watch -d -n 2 'ls -rtlh | tail'`로 한 디렉터리 내의 파일 변경을 확인하거나, `watch -d -n 2 ifconfig`로 와이파이 설정을 고칠 때 네트워크 설정 변경을 확인할 수 있습니다.\n\n- 다음 함수를 실행하면 이 문서에 있는 팁 중 임의의 것을 얻을 수 있습니다(마크다운을 파싱하고 항목을 추출합니다).\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Obscure but useful\n\n- `expr`: 산술적이거나 논리적인 작업을 수행하거나 정규표현식을 검증할때 사용합니다\n\n- `m4`: 간단한 메크로 수행기를 실행합니다\n\n- `yes`: 어떠한 한 문장을 매우 많이 출력합니다\n\n- `cal`: 간단한 달력을 보여줍니다\n\n- `env`: 어떤 한 커맨드를 실행합니다(스크립트를 만들때 유용합니다)\n\n- `printenv`: 환경 변수들을 출력합니다(디버깅을 할때나 스크립트를 만들때 유용합니다)\n\n- `look`: 어떤 문자열로 시작하는 영단어(혹은 파일의 어떤 한 줄)을 찾습니다\n\n- `cut `, `paste`, `join`: 데이터를 수정할때 사용합니다\n\n- `fmt`: 문단의 서식을 지정합니다\n\n- `pr`: 문서의 페이지나 컬럼 서식을 지정합니다\n\n- `fold`: 문서의 각 라인들을 특정한 길이에 맞게 수정합니다\n\n- `column`: 문서의 컬럼이나 테이블의 서식을 지정합니다\n\n- `expand`, `unexpand`: 탭을 공백으로 바꾸어주거나 공백을 탭으로 바꾸어줍니다\n\n- `nl`: 줄 번호를 추가해줍니다\n\n- `seq`: 숫자들을 출력하는데 사용합니다\n\n- `bc`: 간단한 계산기를 실행합니다\n\n- `factor`: 정수들을 인수분해하는데 사용합니다\n\n- [`gpg`](https://gnupg.org/): 파일들을 암호화하고 서명하는데 사용합니다\n\n- `toe`: terminfo 엔트리들의 테이블(table of terminfo entries)\n\n- `nc`: 네트워크를 디버깅하거나 데이터를 전송할 때 사용합니다\n\n- `socat`: 소켓 릴레이나 TCP 포트로 내용을 전달할 때 사용합니다(`netcat`과 비슷합니다)\n\n- [`slurm`](https://github.com/mattthias/slurm): 네트워크 상황을 시각화하여 보여줍니다\n\n- `dd`: 파일들이나 디바이스들 간에 데이터를 옮길때 사용합니다\n\n- `file`: 파일의 종류를 알아내는데 사용합니다\n\n- `tree`: 디렉터리들과 그 하위 디렉터리를 마치 ls를 반복적으로 입력한 것처럼 트리의 형태로 보여줍니다\n\n- `stat`: 파일의 정보를 보여줍니다\n\n- `time`: 명령을 실행하고 시간을 잽니다\n\n- `timeout`: 특정 시간만큼 명령을 실행하고 시간이 끝나면 프로세스를 종료합니다.\n\n- `lockfile`: `rm -f`로만 지울 수 있는 세마포어 파일을 생성합니다\n\n- `logrotate`: 로그를 로테이트, 압축, 메일로 보냅니다\n\n- `watch`: 명령을 반복적으로 실행해 결과를 보여주거나 변경을 하일라이트합니다\n\n- `tac`: 파일의 내용을 역순으로 출력합니다\n\n- `shuf`: 파일의 각 줄들을 임의의 순서로 출력합니다\n\n- `comm`: 정렬된 파일들을 각 라인별로 비교합니다\n\n- `pv`: 파이프를 통해서 프로세스의 정보를 모니터링하는데 사용합니다\n\n- `hd` and `bvi`: 바이너리 파일을 수정하거나 덤프를 얻어오는데 사용합니다\n\n- `strings`: 바이너리 파일들에서 특정 문장을 추출하는데 사용합니다\n\n- `tr`: 문자를 변환하거나 조작하는데 사용합니다\n\n- `iconv` or `uconv`: 문서의 인코딩방식을 변환하는데 사용합니다\n\n- `split `and `csplit`: 파일들을 쪼개는데 사용합니다\n\n- `sponge`: 쓰기 전에 모든 입력을 읽습니다. 같은 파일에서 읽은 후에 쓰기에 유용합니다. 예를 들면 `grep -v something some-file | sponge some-file`처럼 사용할 수 있습니다.\n\n- `units`: 단위를 변환하거나 계산하는데 사용합니다 예를들어 furlongs/fortnight 단위를 twips/blink로 변환합니다 (`/usr/share/units/definitions.units`를 참고하세요)\n\n- `apg`: 렌덤 패스워드를 생성합니다\n\n- `xz`: 고효율의 파일 압축프로그램입니다\n\n- `ldd`: 동적 라이브러리들의 정보를 보여줍니다\n\n- `nm`: 오브젝트 파일들에 포함된 심볼정보를 얻어옵니다\n\n- `ab`: 웹 서버를 벤치 마킹하는데 사용합니다\n\n- `strace`: 시스템 콜을 디버깅할때 사용합니다\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): 네트워크 디버깅시에 traceroute보다 더 낫습니다\n\n- `cssh`: 쉘을 동시에 여러개 사용할때 사용합니다\n\n- `rsync`: SSH를 이용해 원격 파일 시스템이나, 로컬 파일시스템의 파일과 폴더들을 동기화 할때 사용합니다\n\n- [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): 패킷정보를 가져오며 네트워킹을 디버깅하는데 사용합니다\n\n- [`ngrep`](http://ngrep.sourceforge.net/): 네트워크 환경에서 grep과 같은 역할을 합니다\n\n- `host`, `dig`: DNS 정보를 보여줍니다\n\n- `lsof`: 프로세스 파일 디스크립터와 소켓의 정보를 보여줍니다\n\n- `dstat`: 유용한 시스템 정보를 보여줍니다\n\n- [`glances`](https://github.com/nicolargo/glances): 보다 고차원의 여러 서브시스템들의 정보를 한번에 보여줍니다\n\n- `iostat`: 디스크의 사용량 정보를 보여줍니다\n\n- `mpstat`: CPU 사용량 정보를 보여줍니다.\n\n- `vmstat`: 메모리 사용량 정보를 보여줍니다.\n\n- `htop`: 보다 개선된 형태의 top을 보여줍니다\n\n- `last`: 로그인 했던 정보들을 보여줍니다\n\n- `w`: 현재 누가 로그인했는지 보여줍니다\n\n- `id`: 현재 유저나 그룹에 대한 식별 정보를 보여줍니다\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): 시스템 상태에 대한 정보를 보여줍니다\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/), [`nethogs`](https://github.com/raboof/nethogs): 소켓 또는 프로세스를 이용하여 네트워크를 정보를 보여줍니다\n\n- `ss`: 소켓에 관한 통계자료들을 보여줍니다\n\n- `dmesg`: 부팅 메시지와 시스템 에러 메시지들을 보여줍니다\n\n- `sysctl`: 실행 시에 리눅스 커널 파라미터를 보여주거나 설정합니다\n\n- `hdparm`: SATA/ATA disk들의 정보를 수정하거나 그것들이 작동하도록 합니다\n\n- `lsblk`: 블록 디바이스들의 목록을 보여줍니다 : 여러분의 디스크들이나 디스크파티션들을 트리의 형태로 보여줍니다\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: CPU, BIOS, RAID, graphics, devices 등의 하드웨어 정보를 보여줍니다\n\n- `lsmod`, `modifno`: 커널 모듈의 상세정보를 목록으로 보여줍니다.\n\n- `fortune`, `ddate`, `sl`: 에... 증기기관차를 생각하고있고 그것을 인용하고 싶다면 이것은 \"유용\"합니다\n\n\n## macOS only\n\n*OS X에서만* 해당되는 항목입니다.\n\n- `brew` (Homebrew)나 `port` (MacPorts)를 패키지 매니저로 사용합니다. 위의 많은 명령어를 OS X에 설치하여 사용할 수 있습니다.\n\n- `pbcopy`를 이용하여 데스크톱 애플리케이션에 명령어 출력물을 복사하거나 `pbpaste`를 이용해 붙여넣기를 할 수 있습니다.\n\n- OS X 터미널에서 옵션 키를 알트 키(**alt-b**, **alt-f** 같은 위에 나온 명령)로 사용하려면 Preferences -> Profiles -> Keyboard를 열어 \"Use Option as Meta key\"를 선택하세요.\n\n- 데스크톱 애플리케이션에서 파일을 열기위해, `open` 또는 `open -a /Applications/Whatever.app`을 사용하면 됩니다.\n\n- Spotlight: `mdfind`를 이용해 파일을 찾고, `mdls`를 이용해 메타데이타 (사진 EXIF 정보와 같은) 목록을 볼 수 있습니다.\n\n- OS X는 BSD Unix 기반이며 많은 명령어들을 (예로 `ps`, `ls`, `tail`, `awk`, `sed`) 사용할 수 있으며, 이것들은 Linux 버전들과 미묘한 차이가 있습니다. 그리고 크게는 System V-style Unix와 GNU 도구들에 많은 영향을 받았습니다. 이런 내용들을 man 페이지 상단의 \"BSD General Commands Manual.\" 라는 문구를 통해 알 수 있습니다. 가끔은 GNU 버전이 설치되기도 합니다. (예로, GNU awk와 sed인 `gawk`와 `gsed`에서). 만약 이종 플랫폼 간 Bash 스크립트를 작성하려면, 동일한 명령어 (예로, 파이썬이나 `perl`과 같은)나 테스트시 주의해야 합니다.\n\n- OS X 릴리스 정보를 얻으시려면, `sw_vers`를 사용하세요.\n\n## Windows only\n\nWindows*에서만* 해당되는 항목입니다.\n\n- Windows 10에서는 [Bash on Ubuntu on Windows](https://msdn.microsoft.com/commandline/wsl/about)를 사용할 수 있습니다. 이는 유닉스 커맨드 라인 도구와 함께 친숙한 Bash 환경을 제공합니다. 좋은 점은, 리눅스 프로그램을 Windows에서 사용할 수있게 합니다. 하지만 Bash에서 Windows 프로그램을 사용할 수는 없습니다.\n\n- [Cygwin](https://cygwin.com/)를 설치해 Microsoft Windows에서 유닉스 셸을 사용할 수 있습니다. 이 문서에 기술된 대부분의 것들은 그대로 동작할 것입니다.\n\n- Cygwin의 패키지 매니저로 유닉스 프로그램을 더 설치할 수 있습니다.\n\n- 커맨드 라인 창으로 `mintty`를 사용하세요.\n\n- Windows의 클립보드를 `/dev/clipboard`로 접근할 수 있습니다.\n\n- `cygstart`을 실행해 등록된 애플리케이션을 사용해 임의의 파일을 열 수 있습니다.\n\n- Windows 레지스트리는 `regtool`로 접근할 수 있습니다.\n\n- `C:\\\\` Windows 드라이브 경로는 Cygwin에서는 `/cygdrive/c`가 되고, Cygwin의 `/` Windows에서 `C:\\cygwin`가 되는것을 알아 두세요. Cygwin과 Windows 스타일의 파일 패스는 `cygpath`로 변환할 수 있습니다. 이는 Windows 프로그램을 실행하는 프로그램에서 유용하게 사용됩니다.\n\n- You can perform and script most Windows system administration tasks from the command line by learning and using `wmic`.\n\n- Windows에서 유닉스 룩엔필을 얻는 다른 대안은 [Cash](https://github.com/dthree/cash)입니다. 이 환경에는 매우 적은 유닉스 명령과 커맨드 라인 옵션만 사용가능하니 주의하세요.\n\n- Windows에서 GNU 개발자 툴(GCC같은)을 얻는 다른 대안으로 [MinGW](http://www.mingw.org/)와 거기에 포함된 [MSYS](http://www.mingw.org/wiki/msys) 패키지가 있습니다. 여기에는 bash, gawk, make, grep같은 도구가 포함됩니다. MSYS는 Cygwin에 비교하면 모든 기능은 없습니다. MinGW는 유닉스 툴을 네이티브 Windows로 포팅할 때 부분적으로 유용합니다.\n\n## More resources\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): 셸에 대한 툴과 리소스들이 잘 정리되어 있는 리스트입니다.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): OS X 커맨드 라인에 관해 더 깊이 알수 있는 가이드 입니다.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/): 보다 나은 셸 스크립트를 작성하기 위한 정보글입니다.\n- [shellcheck](https://github.com/koalaman/shellcheck): 셸 스크립트 정적 분석 도구 입니다. 특히, bash/sh/zsh에 대한 린트입니다.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): 셸 스크립트에서 파일 이름을 처리하는 법을 다루는 슬프도록 복잡한 미니츄어입니다.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): 같은 이름의 책에서 나온, 데이터 사이언스를 위한 더 나은 명령과 도구들 입니다.\n\n\n## Disclaimer\n\n매우 작은 작업을 제외한 코드들은 다른 사람이 읽을 수 있도록 작성됩니다. 큰 힘에는 책임이 따릅니다. Bash에서 뭔가를 *할 수 있다는* 것은 Bash로 해야 된다는 의미가 아닙니다! ;)\n\n\n## License\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\n이 저작물은 [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)에 따라 이용할 수 있습니다.\n"
        },
        {
          "name": "README-pl.md",
          "type": "blob",
          "size": 49.4,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# Sztuka używania wiersza poleceń\n\n*Uwaga: Poszukuję nowego (i potencjalnie odpłatnego) głównego autora, który pomoże rozszerzyć ten materiał do formy bardziej wszechstronnego Przewodnika. Chociaż jest on bardzo popularny, mógłby być zarówno obszerniejszy jak i bardziej pomocny. Jeśli lubisz pisać, jesteś niemalże ekspertem w tej dziedzinie i chcesz pomóc, daj mi znać na josh (0x40) holloway.com. –[jlevy](https://github.com/jlevy), [Holloway](https://www.holloway.com)*\n\n- [Meta](#meta)\n- [Podstawy](#Podstawy)\n- [Codzienny użytek](#Codzienny-użytek)\n- [Przetwarzanie plików i danych](#Przetwarzanie-plików-i-danych)\n- [Debugowanie systemu](#Debugowanie-systemu)\n- [Jednolinijkowce](#Jednolinijkowce)\n- [Mniej znane, ale użyteczne](#Mniej-znane-ale-użyteczne)\n- [Tylko dla macOS](#Tylko-dla-macOS)\n- [Tylko dla Windows](#Tylko-dla-Windows)\n- [Inne źródła wiedzy](#Inne-źródła-wiedzy)\n- [Zastrzeżenie](#Zastrzeżenie)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nBiegła obsługa wiersza poleceń często jest umiejętnością zaniedbywaną lub uważaną za \"wiedzę tajemną\", ale poprawiającą elastyczność i produktywność inżynierów w sposób oczywisty jak i bardziej subtelny. Oto zbiór informacji i wskazówek na temat użycia wiersza poleceń, które uznaliśmy za przydatne w pracy z systemami Linux. Niektóre wskazówki dotyczą podstaw, inne zaś są całkiem specyficzne dla danego zagadnienia, wyszukane lub niezbyt powszechne. Ta strona nie jest obszerna, lecz znając i pamiętając sposób użycia wszystkiego, co zostało tutaj opisane - wiesz już dużo.\n\nNiniejszy tekst jest efektem pracy zbiorowej [wielu autorów i tłumaczy](AUTHORS.md).\nNiektóre z zagadnień\n[początkowo](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[pojawiły się](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nna [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nale od tamtego czasu zostały przeniesione na GitHub, gdzie ludzie zdolniejsi od autora oryginalnego posta dokonali licznych poprawek.\n[**Zadaj pytanie,**](https://airtable.com/shrzMhx00YiIVAWJg) jeśli jest ono związane z użyciem wiersza poleceń. [**Dodaj coś od siebie,**](/CONTRIBUTING.md) jeśli widzisz błąd lub uważasz, że coś można poprawić!\n\n## Meta\n\nZakres:\n\n- Ten przewodnik przeznaczony jest zarówno dla początkujących jak i doświadczonych. Jego cele uwzględniają *szerokość zakresu* (wszystko jest ważne), *konkretność* (podawane są konkretne przykłady dla najczęstszych przypadków użycia) oraz *zwięzłość* (unika się rzeczy nieistotnych lub dygresji dostępnych gdzie indziej). Każda wskazówka jest kluczowa dla danej sytuacji lub znacznie skraca czas w stosunku do użycia innego rozwiązania.\n- Dokument ten napisany został dla systemów Linux (z wyjątkiem sekcji \"[Tylko dla macOS](#Tylko-dla-macOS)\" oraz \"[Tylko dla Windows](#Tylko-dla-Windows)\"). Wiele pozostałych poleceń ma zastosowanie lub może być zainstalowanych w innych systemach Unix lub macOS (lub nawet w Cygwinie).\n- Główny nacisk położony jest na interaktywną pracę z Bashem, aczkolwiek wiele wskazówek odnosi się do innych powłok systemowych oraz do pisania skryptów w Bashu ogólnie.\n- Zawarte są tutaj zarówno \"standardowe\" polecenia systemów Unix jak i te wymagające instalacji dodatkowych pakietów oprogramowania -- o ile polecenia te były wystarczająco ważne, by je uwzględnić.\n\nUwagi:\n\n- Dla zachowania formy pojedynczej strony, treść dołączana jest domyślnie przez odniesienia. Dysponujesz wystarczającą inteligencją, żeby poszukać dodatkowych szczegółów danego polecenia w Google. Używaj `apt`, `yum`, `dnf`, `pacman`, `pip` lub `brew` (odpowiednio), aby zainstalować nowe programy.\n- Używaj [Explainshell](http://explainshell.com/) żeby \"rozłożyć na czynniki pierwsze\" polecenia, opcje, potoki, itp.\n\n\n## Podstawy\n\n- Naucz się podstaw Basha. Właściwie, wpisz `man bash` i przynajmniej przejrzyj całość - jest całkiem łatwa w zrozumieniu i niezbyt długa. Inne powłoki mogą być fajne, ale Bash jest potężny i obecny praktycznie wszędzie (o ile nauczenie się *wyłącznie* powłoki zsh, fish, itp. na swoim własnym laptopie jest kuszące, będzie Cię ograniczać w wielu sytuacjach, takich jak użycie istniejących serwerów).\n\n- Naucz się dobrze co najmniej jednego edytora tekstowego. Edytor `nano` jest jednym z najłatwiejszych do opanowania w podstawowych operacjach (otwieranie, edycja, zapisywanie, przeszukiwanie). Jednakże zaawansowanym użytkownikom terminala nic nie zastąpi Vima (`vi`) - trudnego do nauczenia, ale zacnego, szybkiego i w pełni wyposażonego edytora. Wielu używa też klasycznego Emacsa, zwłaszcza do większych zadań. (Rzecz jasna żaden współczesny twórca oprogramowania, pracujący nad dużym projektem, raczej nie będzie używał wyłącznie edytora w trybie tekstowym i powinien znać również nowoczesne IDE i narzędzia dla trybu graficznego.)\n\n- Znajdywanie dokumentacji:\n  - Dowiedz się jak czytać oficjalną dokumentację za pomocą `man` (dla dociekliwych `man man` podaję numerację sekcji, np. 1 jest dla \"zwykłych\" poleceń, 5 jest dla plików/składni, a 8 dla administracji systemem). Odszukuj odpowiednie strony podręczników używając `apropos`.\n  - Wiedz, że niektóre komendy nie są plikami wykonywalnymi, lecz wbudowanymi poleceniami powłoki Bash. Pomoc dla nich można uzyskać za pomocą `help` i `help -d`. Możesz się zorientować, czy dana komenda jest plikiem wykonywalnym, poleceniem wbudowanym, czy aliasem przy użyciu `type komenda`.\n  - `curl cheat.sh/polecenie` pokaże krótką \"ściągawkę\" z najczęstszymi przykładami użycia polecenia.\n\n- Przyswój wiedzę o przekierowywaniu strumieni wyjścia i wejścia za pomocą operatorów `>` i `<` oraz o potokach tworzonych przy użyciu `|`. Wiedz, że `>` nadpisuje plik wyjściowy, a `>>` dodaje treść. Dowiedz się o strumieniach: standardowego wyjścia (stdout) i standardowego błędu (stderr).\n\n- Naucz się rozwijania nazw plików przy użyciu wzorców globalnych, zawierających `*` (może też `?` i `[`...`]`) oraz zastosowania i różnic między podwójnym `\"` i pojedynczym `'` znakiem cudzysłowu. (Zobacz także poniżej - o rozwijaniu nazw zmiennych.)\n\n- Zapoznaj się ze sposobami zarządzania zadaniami Basha: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, itp.\n\n- Poznaj `ssh` i podstawy uwierzytelniania bez haseł przy użyciu `ssh-agent`, `ssh-add`, itp.\n\n- Podstawy zarządzania plikami: `ls` i `ls -l` (w szczególności dowiedz się co reprezentuje każda kolumna wyświetlana z `ls -l`), `less`, `head`, `tail` oraz `tail -f` (a nawet lepiej, `less +F`), `ln` i `ln -s` (poznaj różnice i przewagi \"dowiązania twardego\" nad \"dowiązaniem miękkim/symbolicznym\"), `chown`, `chmod`, `du` (szybkie podsumowanie użycia przestrzeni dyskowej: `du -hs *`). Do zarządzania systemami plików: `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Dowiedz się, czym jest \"i-węzeł\" (`ls -i` lub `df -i`).\n\n- Podstawy zarządzania połączeniami sieciowymi: `ip` lub `ifconfig`, `dig`, `traceroute`, `route`.\n\n- Naucz się i korzystaj z systemu zarządzania kontrolą wersji, takiego jak `git`.\n\n- Dobrze poznaj wyrażenia regularne oraz różne przełączniki dla poleceń `grep`/`egrep`. Warto znać opcje `-i`, `-o`, `-v`, `-A`, `-B`, and `-C`.\n\n- Naucz się używać `apt-get`, `yum`, `dnf` lub `pacman` (w zależności od dystrybucji) do odnajdywania i instalacji pakietów oprogramowania. Upewnij się także, że masz `pip`, aby móc instalować narzędzia wiersza poleceń oparte o język Python (kilka omówionych poniżej najłatwiej jest zainstalować używając `pip`).\n\n\n## Codzienny użytek\n\n- W Bashu używaj klawisza **Tab** do uzupełniania listy argumentów lub wyświetlania listy dostępnych poleceń, a kombinacji **ctrl-r** do przeszukiwania historii wydanych poleceń (po wciśnięciu tej kombinacji wpisz kolejne litery polecenia do odnalezienia, powtórz **ctrl-r**, aby przełączać się pomiędzy kolejnymi pasującymi wpisami, wciśnij **Enter**, żeby wykonać znalezione polecenie lub strzałkę w prawo, by móc zmodyfikować bieżącą linię z poleceniem).\n\n- W Bashu, używaj kombinacji **ctrl-w** do usunięcia ostatniego wyrazu oraz **ctrl-u** do usunięcia zawartości od bieżącej pozycji kursora do początku linii. Używaj kombinacji **alt-b** i **alt-f**, żeby przeskakiwać \"słowo po słowie\", **ctrl-a** do umieszczenia kursora na początku linii, **ctrl-e** do umieszczania kursora na końcu linii, **ctrl-k**, żeby wymazać zawartość od bieżącej pozycji kursora do końca linii, **ctrl-l** do wyczyszczenia zawartości całego ekranu. Sprawdź `man readline`, by poznać wszystkie kombinacje w Bashu. Jest ich bardzo dużo. Dla przykładu **alt-.** skacze po wszystkich argumentach poprzednich poleceń, a **alt-*** rozwija wzorzec globalny.\n\n\n- Alternatywnie, jeśli kochasz skróty klawiaturowe w stylu vi, użyj `set -o vi` (i `set -o emacs`, aby powrócić do poprzednich ustawień).\n\n- Do edycji długich poleceń, po ustawieniu edytora (na przykład `export EDITOR=vim`), **ctrl-x** **ctrl-e** otworzy bieżące polecenie w edytorze z możliwością edycji wieloliniowej. W trybie vi to samo zrobi **escape-v**.\n\n- Żeby zobaczyć ostatnio wydane polecenia, użyj `history`. Następnie `!n` (gdzie `n` jest numerem polecenia), żeby wykonać polecenie ponownie. Możesz także użyć wielu skrótów, z których najbardziej przydatne są prawdopodobnie `!$` dla ostatniego argumentu i `!!` dla ostatniego polecenia (sprawdź \"HISTORY EXPANSION\" w podręczniku). Jednakże, często skróty te zastępowane są przy użyciu **ctrl-r** i **alt-.**.\n\n- Przejdź do swojego katalogu domowego za pomocą `cd`. Używaj prefiksu `~`, aby dostać się do zawartości plików w ścieżkach podanych względem twojego katalogu domowego (np. `~/.bashrc`). W skryptach powłoki `sh` odwołuj się do katalogu domowego przy użyciu `$HOME`.\n\n- Cofnij się do poprzedniego katalogu roboczego przy użyciu: `cd -`.\n\n- Jeśli zmienisz zdanie będąc już w połowie pisanego polecenia, użyj kombinacji **alt-#**, żeby dodać znak `#` na początku i zamienić tę linię w komentarz (lub użyj **ctrl-a**, **#**, **enter**). Możesz później wrócić do tego polecenia za pośrednictwem historii.\n\n- Używaj `xargs` (lub `parallel`). To potężne narzędzie. Zwróć uwagę, że możesz kontrolować zarówno liczbę elementów obsłużonych w jednej linii (`-L`) jak i stopień zrównoleglenia (`-P`). Jeśli nie masz pewności co do poprawności wyników operacji, najpierw użyj `xargs echo`. Ponadto, `-I{}` jest przydatne. Przykłady:\n```bash\n      find . -name '*.py' | xargs grep jakas_funkcja\n      cat serwery | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` to pomocna prezentacja działających procesów - w postaci drzewa.\n\n- Używaj `pgrep` i `pkill` by znaleźć proces lub wysłać do niego sygnał, odwołując się po nazwie (`-f` jest pomocne).\n\n- Poznaj różne sygnały, które można wysyłać do procesów. Przykładowo, aby wstrzymać proces, użyj `kill -STOP [pid]`. Zobacz pełną listę w `man 7 signal`\n\n- Używaj `nohup` lub `disown` jeśli chcesz, żeby proces uruchomiony w tle działał w nieskończoność.\n\n- Sprawdź, które procesy nasłuchują połączeń, przy pomocy `netstat -lntp` lub `ss -plat` (dla TCP; dodaj `-u` dla UDP) lub `lsof -iTCP -sTCP:LISTEN -P -n` (które działa również w macOS).\n\n- Zobacz także `lsof` i `fuser` dla otwartych gniazd i plików.\n\n- Zobacz `uptime` lub `w`, aby dowiedzieć się jak długo system jest uruchomiony.\n\n- Używaj `alias` do tworzenia skrótów dla często używanych poleceń. Na przykład, `alias ll='ls -latr'` utworzy nowy skrót `ll`.\n\n- Zachowuj często używane skróty, ustawienia powłoki oraz funkcje w `~/.bashrc`, a także [upewnij się, że powłoka logowania odczytuje je przy starcie](http://superuser.com/a/183980/7106). To sprawi, że wszystkie Twoje ustawienia będą dostępne we wszystkich Twoich sesjach powłoki.\n\n- Umieść ustawienia zmiennych środowiskowych oraz polecenia, które powinny być uruchomione przy logowaniu w `~/.bash_profile`. Osobna konfiguracja będzie wymagana dla powłok uruchamianych ze środowiska graficznego i zadań polecenia `cron`.\n\n- Synchronizuj swoje pliki konfiguracyjne (np. `.bashrc` i `.bash_profile`) na różnych komputerach - używając Git.\n\n- Wiedz, że zmienne i nazwy plików zwierające \"znaki białe\" należy traktować z dozą ostrożności. Umieszczaj zmienne Basha w cudzysłowach, np. `\"$FOO\"`. Kładź nacisk na opcje `-0` lub `-print0` pozwalające oddzielać nazwy plików \"znakiem pustym\", np. `locate -0 wzorzec | xargs -0 ls -al` lub `find / -print0 -type d | xargs -0 ls -al`. W celu iteracji wewnątrz pętli \"for\" po nazwach plików zawierających \"znaki białe\", ustaw zmienną IFS tak, aby zawierała tylko \"znak nowej linii\" - przy pomocy `IFS=$'\\n'`.\n\n- W skryptach Basha używaj `set -x` (lub wariantu `set -v`, który przechwytuje strumień wejścia w formie \"surowej\", włącznie z nierozwiniętymi nazwami zmiennych i komentarzami) do debugowania strumienia wyjścia. Używaj trybów ścisłych, chyba że masz dobry powód by tego nie robić: użycie `set -e` przerywa wykonanie w przypadku wystąpienia błędów (niezerowych kodów zakończenia). Użycie `set -u` wykrywa próby skorzystania z niezainicjowanych zmiennych. Rozważ także użycie `set -o pipefail`, które przerywa wykonanie w przypadku wystąpienia błędów w potokach (aczkolwiek poczytaj o tym więcej, jako że jest to nieco delikatny temat). W przypadku bardziej zaangażowanych skryptów, używaj także pułapek `trap` na sygnały EXIT lub ERR. Przydatnym nawykiem jest rozpoczynanie skryptów jak poniżej, co pozwala wykryć najczęstsze błędy i przerwać wykonanie wyświetlając komunikat:\n```bash\n      set -euo pipefail\n      trap \"echo 'wystąpił błąd: Skrypt przestał działać poprawnie: zobacz polecenie powyżej'\" ERR\n```\n\n- W skryptach Basha, powłoki potomne (komendy zapisane w nawiasach okrągłych) są wygodnym sposobem grupowania poleceń. Częstym przykładem użycia jest chwilowa zmiana bieżącego katalogu, np.\n```bash\n      # wykonaj coś w bieżącym katalogu\n      (cd /jakis/inny/katalog && inne-polecenie)\n      # kontynuuj w oryginalnej lokalizacji\n```\n\n- Zwróć uwagę, że w Bashu jest wiele różnych rodzajów rozwijania nazw zmiennych. Sprawdzenie, czy zmienna istnieje: `${nazwa_zmiennej:?komunikat błędu}`. Przykładowo, jeśli skrypt Basha wymaga podania jednego argumentu, po prostu napisz `plik_wejsciowy=${1:?Sposób użycia: $0 plik_wejsciowy}`. Użycie wartości domyślnej, gdy zmienna jest pusta: `${nazwa_zmiennej:-wartosc_domyslna}`. Aby mieć dodatkowy (opcjonalny) parametr do poprzedniego przykładu, możesz użyć czegoś takiego `plik_wyjsciowy=${2:-logfile}`. Jeśli argument `$2` zostanie pominięty i tym samym będzie on pusty, wartość zmiennej `plik_wyjsciowy` zostanie ustawiona na `logfile`. Rozwinięcie arytmetyczne: `i=$(( (i + 1) % 5 ))`. Sekwencje: `{1..10}`. Skracanie łańcuchów znakowych: `${nazwa_zmiennej%przyrostek}` oraz `${nazwa_zmiennej#przedrostek}`. Na przykład, jeśli `plik=foo.pdf`, wtedy `echo ${plik%.pdf}.txt` wyświetli `foo.txt`.\n\n- Rozwijanie nawiasów klamrowych `{`...`}` pozwala ograniczyć konieczność przepisywania powtarzalnego tekstu i zautomatyzować kombinacje elementów. Jest to pomocne w przypadkach, takich jak `mv foo.{txt,pdf} jakis-katalog` (które przeniesie oba pliki), `cp jakisplik{,.bak}` (które zostanie rozwinięte do `cp jakisplik jakisplik.bak`) lub `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (które rozwinie wszystkie możliwe kombinacje i utworzy strukturę katalogów). Rozwinięcie nawiasów klamrowych ma pierwszeństwo przed jakimikolwiek innymi rozwinięciami.\n\n- Kolejność wykonywania rozwinięć jest następująca: rozwijanie nawiasów klamrowych; rozwijanie znaku tylda, rozwijanie parametrów i nazw zmiennych, rozwinięcia arytmetyczne oraz podstawianie poleceń (wykonywane \"od lewej do prawej\"); dzielenie wyrazów; rozwijanie nazw plików. (Przykładowo: zakresu `{1..20}` nie można wyrazić za pomocą zmiennych `{$a..$b}`. Zamiast tego użyj `seq` lub pętli `for`, np. `seq $a $b` lub `for((i=a; i<=b; i++)); do ... ; done`.)\n\n- Strumień wyjścia z polecenia może zostać potraktowany jak plik przy użyciu `<(jakies polecenie)` (mechanizm znany jako podstawienie procesu). Na przykład, porównanie lokalnego pliku `/etc/hosts` z plikiem na maszynie zdalnej:\n```sh\n      diff /etc/hosts <(ssh jakisserwer cat /etc/hosts)\n```\n\n- Pisząc skrypty, możesz zechcieć umieszczać cały kod pomiędzy nawiasami klamrowymi. Jeśli zabraknie nawiasu zamykającego, Twój skrypt nie zostanie wykonany z powodu błędu składniowego. Ma to sens wtedy, kiedy Twój skrypt ma być pobierany ze strony w sieci, ponieważ zapobiegnie to wykonaniu skryptów pobranych tylko częściowo:\n```bash\n{\n      # Tutaj jest Twój kod\n}\n```\n\n- \"Dokument lokalny\" pozwala na [przekierowanie kilku linii strumienia wejścia](https://www.tldp.org/LDP/abs/html/here-docs.html) tak, jakby były wczytywane z pliku:\n```\ncat <<EOF\nwejście\nw kilku liniach\nEOF\n```\n\n- W Bashu, jednoczesne przekierowanie strumieni standardowego wyjścia i standardowego błędu można uzyskać za pomocą: `jakies-polecenie >plik_logu 2>&1` lub `jakies-polecenie &>plik_logu`. Często, aby upewnić się, że polecenie nie zostawi otwartego uchwytu do pliku strumienia standardowego wejścia, wiążącego go z obecnie używanym terminalem, jako dobrą praktykę stosuje się dodanie do polecenia `</dev/null`.\n\n- Używaj `man ascii`, aby uzyskać dobrą tabelę kodów ASCII, zawierającą wartości szesnastkowe i dziesiętne. Do uzyskania ogólnych informacji o kodowaniu znaków, pomocne są polecenia `man unicode`, `man utf-8` i `man latin1`.\n\n- Używaj polecenia `screen` lub [`tmux`](https://tmux.github.io/) do zwielokrotnienia ekranu, szczególnie przydatnego w sesjach ssh do maszyn zdalnych, aby odłączać się i ponownie podłączać do sesji. `byobu` rozszerza możliwości screena lub tmuxa dostarczając więcej informacji i ułatwiając zarządzanie. Minimalistyczną alternatywą jedynie do celów utrzymania ciągłości sesji jest [`dtach`](https://github.com/bogner/dtach).\n\n- W używaniu ssh, wiedza na temat tunelowania portów z użyciem `-L` lub `-D` (i czasami `-R`) jest przydatna, np. do przeglądania stron w sieci z maszyny zdalnej.\n\n- Wprowadzenie kilku usprawnień do konfiguracji Twojego ssh może być przydatne; na przykład, poniższy `~/.ssh/config` zawiera ustawienia pozwalające uniknąć zrywania połączeń w pewnych środowiskach sieciowych, używa kompresji (co może być pomocne w użyciu scp na łączach o niskiej przepustowości), zwielokrotnia kanały dostępowe do tego samego serwera przy użyciu lokalnego pliku kontrolnego:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Kilka innych opcji, istotnych dla ssh, jest związanych z bezpieczeństwem i powinno być stosowanych z rozwagą, np. w odniesieniu do konkretnej podsieci lub serwera lub w zaufanych sieciach: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Uznaj [`mosh`](https://mosh.org/) za alternatywę dla ssh używającą UDP, unikającą przerywania połączeń i zwiększającą wygodę (wymaga konfiguracji po stronie serwera).\n\n- Aby zobaczyć uprawnienia do pliku w postaci ósemkowej, co jest przydatne w konfiguracji systemu, ale niedostępne w `ls` i łatwe do rozwalenia, użyj czegoś takiego\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Aby móc interaktywnie wybierać wartości z wyjścia innego polecenia, używaj [`percol`](https://github.com/mooz/percol) lub [`fzf`](https://github.com/junegunn/fzf).\n\n- Do interaktywnej pracy z plikami, bazującej na wyjściu z innego polecenia (takiego jak `git`), używaj `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Jako prostego serwera stron, serwującego wszystkie pliki z bieżącego katalogu (i podkatalogów), dostępnego dla każdego w Twojej sieci, użyj:\n`python -m SimpleHTTPServer 7777` (dla użycia portu 7777 w wersji Python 2) oraz `python -m http.server 7777` (dla użycia portu 7777 w wersji Python 3).\n\n- Żeby wykonać polecenie jako inny użytkownik, używaj `sudo`. Jako domyślne konto docelowe używane jest konto root; użyj `-u`, aby określić konto innego użytkownika. Użyj `-i`, żeby zalogować się jako docelowy użytkownik (zostaniesz poproszony o podanie _Twojego_ hasła).\n\n- Aby w bieżącej powłoce przełączyć się na konto innego użytkownika, używaj `su uzytkownik` lub `su - uzytkownik`. To drugie z \"-\" zapewnia takie ustawienia środowiska, jak zaraz po zalogowaniu docelowego użytkownika. Pominięcie nazwy użytkownika skutkuje przełączeniem się na konto root. Zostaniesz poproszony o podanie hasła _do konta użytkownika, na którego się przełączasz_.\n\n- Wiedz o ograniczeniu do [128K znaków](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) dla długości pojedynczego polecenia. Błąd mówiący \"Argument list too long\" występuje często, gdy wzorzec globalny dla nazw pasuje do dużej liczby plików. (Gdy tak się zdarzy, zamienniki takie jak `find` i `xargs` mogą pomóc.)\n\n- Jako podstawowego kalkulatora (i oczywiście, żeby ogólnie móc korzystać z Pythona), używaj interpretera `python`. Przykładowo:\n```\n>>> 2+3\n5\n```\n\n\n## Przetwarzanie plików i danych\n\n- Aby zlokalizować plik po nazwie w bieżącym katalogu, `find . -iname '*jakasnazwa*'` (lub podobnie). Aby zlokalizować znajdujący się gdziekolwiek plik po nazwie, użyj `locate jakasnazwa` (ale miej na uwadze, że `updatedb` mógł jeszcze nie zindeksować plików utworzonych niedawno).\n\n- Do przeszukiwania zawartości plików z kodem źródłowym lub danymi, istnieje kilka opcji bardziej zaawansowanych lub szybszych niż `grep -r`, wliczając w to (z grubsza od najstarszego do najnowszego) [`ack`](https://github.com/beyondgrep/ack2), [`ag`](https://github.com/ggreer/the_silver_searcher) (\"srebrny szukacz\") oraz [`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep).\n\n- Żeby skonwertować kod HTML do postaci tekstowej: `lynx -dump -stdin`\n\n- Do konwersji Markdown, HTML i różnych innych formatów dokumentów, wypróbuj [`pandoc`](http://pandoc.org/). Na przykład, aby skonwertować dokument Markdown do formatu Word: `pandoc README.md --from markdown --to docx -o tymczasowy.docx`\n\n- Jeśli musisz zająć się danymi w formacie XML, `xmlstarlet` - jest wiekowy, ale przydatny.\n\n- Do danych w formacie JSON używaj [`jq`](http://stedolan.github.io/jq/). Do pracy interaktywnej sprawdź także [`jid`](https://github.com/simeji/jid) oraz [`jiq`](https://github.com/fiatjaf/jiq).\n\n- Do danych w formacie YAML używaj [`shyaml`](https://github.com/0k/shyaml).\n\n- Do pracy z plikami w formacie Excel lub CSV, [csvkit](https://github.com/onyxfish/csvkit) dostarcza `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, itp.\n\n- Do obsługi Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) jest wygodny, a [`s4cmd`](https://github.com/bloomreach/s4cmd) jest szybszy. [`aws`](https://github.com/aws/aws-cli) i ulepszony [`saws`](https://github.com/donnemartin/saws) od Amazona są kluczowe dla innych zadań związanych z usługami AWS.\n\n- Poznaj `sort` i `uniq`, włącznie z opcjami `-u` i `-d` dla uniq -- sprawdź jednolinijkowce poniżej. Sprawdź także `comm`.\n\n- Poznaj `cut`, `paste` i `join` do manipulacji zawartością plików tekstowych. Wiele osób używa `cut`, ale zapominają o `join`.\n\n- Poznaj `wc` do liczenia znaków nowej linii (`-l`), wszystkich znaków (`-m`), słów (`-w`) i bajtów (`-c`).\n\n- Poznaj `tee` do równoczesnego kopiowania zawartości z stdin do pliku i stdout, np. `ls -al | tee file.txt`.\n\n- Do bardziej złożonych operacji obliczeniowych, uwzględniających grupowanie, odwracanie kolejności pól i obliczenia statystyczne, rozważ użycie [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Wiedz, że ustawienia regionalne mają subtelny wpływ na wiele narzędzi wiersza poleceń, wliczając w to kolejność sortowania (porównywanie) i wydajność. Większość systemów Linux przy instalacji ustawia `LANG` lub inne zmienne dla ustawień regionalnych na lokalną wartość, taką jak np. US English. Miej świadomość tego, że kolejność sortowania zmieni się, jeśli zmienisz ustawienia regionalne. I wiedz, że reguły i18n mogą spowodować, że sort lub inne polecenia będą działać *wielokrotnie* wolniej. W niektórych przypadkach (takich, jak ustawianie zmiennych lub stwierdzanie unikatowości opisane poniżej) można bezpiecznie w całości zignorować powolne reguły i18n i używać tradycyjnego, opartego na wartości bajtowej porządku sortowania, przy użyciu `export LC_ALL=C`.\n\n- Możesz zmodyfikować środowisko danego polecenia, poprzedzając jego wywołanie ustawieniem zmiennej środowiskowej, np. `TZ=Pacific/Fiji date`.\n\n- Poznaj podstawy `awk` i `sed` do prostej obróbki danych. Zobacz przykłady w sekcji [Jednolinijkowce](#Jednolinijkowce).\n\n- Aby zastąpić \"w miejscu\" wszystkie wystąpienia danego łańcucha znaków, w jednym lub wielu plikach na raz:\n```sh\n      perl -pi.bak -e 's/stary-łańcuch/nowy-łańcuch/g' moje-pliki-*.txt\n```\n\n- Do zmiany nazw wielu plików i/lub wyszukania i zastąpienia łańcuchów wewnątrz plików, wypróbuj [`repren`](https://github.com/jlevy/repren). (W niektórych przypadkach, polecenie `rename` również umożliwi zmianę nazw wielu plików, ale ostrożnie, gdyż jego funkcjonalność różni się w zależności od dystrybucji Linuksa.)\n```sh\n      # Pełna zmiana nazw plików, katalogów i zawartości foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Odzyskiwanie plików z kopii bezpieczeństwa cokolwiek.bak -> cokolwiek:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Tak jak wyżej, przy użyciu rename, jeśli jest dostępne:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Jak głosi strona podręcznika, `rsync` jest naprawdę szybkim i niezwykle wszechstronnym narzędziem do kopiowania plików. Znany jest z synchronizacji zawartości między maszynami, ale jest równie użyteczny lokalnie. Jeśli pozwalają na to ustawienia bezpieczeństwa, użycie `rsync` zamiast `scp` umożliwia wznowienie transferu bez cofania się do początku. Jest on także wśród [najszybszych sposobów](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) na usuwanie dużych liczb plików:\n```sh\nmkdir pusty && rsync -r --delete pusty/ jakis-katalog && rmdir jakis-katalog\n```\n\n- Do śledzenia postępu przetwarzania plików używaj [`pv`](http://www.ivarch.com/programs/pv.shtml), [`pycp`](https://github.com/dmerejkowsky/pycp), [`pmonitor`](https://github.com/dspinellis/pmonitor), [`progress`](https://github.com/Xfennec/progress), `rsync --progress` lub w kopiowaniu na poziomie blokowym - `dd status=progress`.\n\n- Używaj `shuf` do \"przetasowania\" lub wyboru losowych linii z pliku.\n\n- Poznaj opcje polecenia `sort`.  Do pracy z liczbami używaj `-n` lub `-h`, żeby obsłużyć liczby w formacie czytelnym dla człowieka (np. wyjście z `du -h`). Dowiedz się, jak działają \"klucze\" (`-t` i `-k`). Zwróć szczególną uwagę na to, że musisz napisać `-k1,1`, żeby posortować pod względem zawartości tylko pierwszego pola; `-k1` oznacza sortowanie względem zawartości całej linii. Sortowanie stabilne (`sort -s`) może być przydatne. Przykładowo, żeby najpierw posortować po polu numer 2, a następnie po polu numer 1, możesz użyć `sort -k1,1 | sort -s -k2,2`.\n\n- Jeśli kiedykolwiek w wierszu poleceń Basha zajdzie potrzeba umieszczenia znaku tabulacji, dosłownie (np. jako argumentu dla opcji -t do sortowania), wciśnij **ctrl-v** **[Tab]** lub wpisz `$'\\t'` (to drugie rozwiązanie jest lepsze, bo możesz je skopiować i wkleić).\n\n- Standardowymi narzędziami do \"łatania\" plików z kodem źródłowym są `diff` i `patch`. Sprawdź także `diffstat` dla uzyskania podsumowania z diff oraz `sdiff` dla porównywania zawartości obok siebie. Zwróć uwagę, że `diff -r` zadziała dla całych katalogów. Użyj `diff -r drzewo1 drzewo2 | diffstat`, żeby uzyskać podsumowanie różnic. Używaj `vimdiff` do porównywania i edycji plików.\n\n- W pracy z plikami binarnymi używaj `hd`, `hexdump` lub `xxd` do uzyskania prostych zrzutów zawartości w formie liczb szesnastkowych, a `bvi`, `hexedit` lub `biew` do binarnej edycji.\n\n- Także w odniesieniu do plików binarnych, `strings` (oraz `grep`, itp.) pozwoli Ci znaleźć kawałki tekstu.\n\n- Do obsługi plików różnic binarnych (kompresja delta), używaj `xdelta3`.\n\n- Do zmiany kodowania znaków w tekście wypróbuj `iconv`. Możesz także użyć `uconv` do bardziej zaawansowanych operacji; obsługuje on bardziej zaawansowane rzeczy, związane z Unicode. Przykładowo:\n```sh\n      # Wyświetla szesnastkowe kody lub faktyczne nazwy znaków (przydatne do debugowania):\n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < dane_wejsciowe.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < dane_wejsciowe.txt\n      # Konwertuje teskt na małe litery i usuwa wszystkie znaki akcentu (rozwijając i pozbywając się ich):\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC;' < dane_wejsciowe.txt > dane_przetworzone.txt\n```\n\n- Aby podzielić plik na mniejsze kawałki, sprawdź jak użyć `split` (do podziału na podstawie zadanego rozmiaru) i `csplit` (do podziału na podstawie zadanego wzorca).\n\n- Data i czas: aby uzyskać aktualną datę i czas w przydatnym formacie [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), użyj `date -u +\"%Y-%m-%dT%H:%M:%SZ\"` (inne opcje [są](https://stackoverflow.com/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [kłopotliwe](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option)). Do manipulacji wyrażeniami zawierającymi datę i czas, używaj `dateadd`, `datediff`, `strptime` itp. z pakietu [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Używaj `zless`, `zmore`, `zcat` oraz `zgrep` do pracy ze skompresowanymi plikami.\n\n- Atrybuty plików da się ustawiać przy użyciu `chattr` i oferują one niskopoziomową alternatywę dla uprawnień do plików. Na przykład, aby uchronić plik przed przypadkowym usunięciem, ustaw mu flagę niezmienności (immutable):  `sudo chattr +i /wazny/katalog/lub/plik`\n\n- Używaj `getfacl` i `setfacl`, aby zachować i przywrócić uprawnienia do plików (ACL). Przykładowo:\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- Do szybkiego tworzenia pustych plików, użyj `truncate` (tworzy [plik z rezerwacją miejsca](https://en.wikipedia.org/wiki/Sparse_file)), `fallocate` (dla systemów plikowych ext4, xfs, btrfs oraz ocfs2), `xfs_mkfile` (prawie dla każdego systemu plików, zawarty w pakiecie xfsprogs), `mkfile` (dla systemów uniksowych, takich jak Solaris, Mac OS).\n\n## Debugowanie systemu\n\n- Do debugowania stron w sieci przydane są `curl` i `curl -I` lub ich odpowiedniki z użyciem `wget`, albo bardziej nowoczesny [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Żeby poznać aktualny stan cpu/dysku, klasycznymi narzędziami są `top` (lub lepszy `htop`), `iostat` i `iotop`. Użyj `iostat -mxz 15` dla uzyskania podstawowych informacji o użyciu CPU i szczegółowych statystyk użycia każdej partycji dyskowej oraz wglądu w ich wydajność.\n\n- Aby uzyskać szczegóły połączeń sieciowych, używaj `netstat` i `ss`.\n\n- Dla szybkiego podglądu tego, co dzieje się w systemie, `dstat` jest wybitnie przydatny. Aby uzyskać najszerszy obraz sytuacji wraz ze szczegółami, użyj [`glances`](https://github.com/nicolargo/glances).\n\n- Żeby poznać stan pamięci, uruchom i zrozum dane wyjściowe poleceń `free` i `vmstat`. W szczególności pamiętaj, że pamięć \"podręczna (cached)\" to zarezerwowana przez jądro Linuksa pamięć podręczna dla plików, więc skutecznie jej wartość zalicza się do wartości pamięci \"wolnej (free)\".\n\n- Debugowanie podsystemu Java to inna para kaloszy, ale prostą sztuczką w systemach Oracle i niektórych innych JVMach może być uruchomienie `kill -3 <pid>`, aby uzyskać pełny zrzut zawartości stosu i podsumowanie zawartości sterty (włącznie ze szczegółami nt. 'zbierania śmieci', które mogą dać wiele informacji) do strumienia standardowego błędu/logów. Z narzędzi JDK przydatne są `jps`, `jstat`, `jstack`, `jmap`. [Narzędzia SJK](https://github.com/aragozin/jvm-tools) są bardziej zaawansowane.\n\n- Używaj [`mtr`](http://www.bitwizard.nl/mtr/) jako lepszego narzędzia traceroute do identyfikowania problemów z siecią.\n\n- Sprawdzenie przyczyny zapełnienia dysku przy użyciu [`ncdu`](https://dev.yorhel.nl/ncdu) oszczędza czas w porównaniu z użyciem \"zwyczajnych\" poleceń, takich jak `du -sh *`.\n\n- Żeby odszukać gniazdo lub proces, które zużywają przepustowość połączenia sieciowego, wypróbuj [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) lub [`nethogs`](https://github.com/raboof/nethogs).\n\n- Narzędzie `ab` (dostarczane w pakiecie z Apache) pomaga w szybkim sprawdzeniu wydajności serwera stron. Do bardziej złożonych testów obciążenia, wypróbuj `siege`.\n\n- Do poważniejszego debugowania sieci, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) lub [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Poznaj `strace` oraz `ltrace`. Mogą one pomóc w znalezieniu przyczyny, gdy program nie działa poprawnie, zawiesza się lub całkowicie \"rozsypuje\" lub gdy chcesz poznać jego ogólną wydajność. Zwróć uwagę na opcję profilowania (`-c`) oraz możliwość wpięcia się w działający proces (`-p`). Używaj opcji śledzenia procesów potomnych (`-f`), żeby nie przeoczyć ważnych wywołań systemowych.\n\n- Poznaj `ldd` do sprawdzania współdzielonych bibliotek, itp. — ale [nigdy nie uruchamiaj go z niezaufanymi plikami](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/).\n\n- Dowiedz się, jak można się wpiąć w działający proces przy pomocy `gdb` i prześledzić jego użycie stosu.\n\n- Używaj `/proc`. Czasami jest niezwykle pomocny w rozwiązywaniu trwających problemów. Przykłady: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (gdzie `xxx` jest nazwą procesu lub jego numerem pid).\n\n- Kiedy sprawdzasz, dlaczego w przeszłości coś poszło źle, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) może być bardzo pomocny. Pokazuje on historyczne statystyki użycia CPU, pamięci, sieci, itp.\n\n- Do głębszych analiz systemów i wydajności, rzuć okiem na `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_%28Linux%29) oraz [`sysdig`](https://github.com/draios/sysdig).\n\n- Sprawdź w jakim jesteś systemie operacyjnym, używając `uname` lub `uname -a` (ogólne informacje na temat Uniksa/jądra systemu) albo `lsb_release -a` (informacje na temat dystrybucji Linuksa).\n\n- Używaj `dmesg` zawsze, gdy coś się \"dziwnie zachowuje\" (to może oznaczać problemy ze sprzętem lub sterownikami).\n\n- Jeśli usuwasz plik, ale nie zwalnia to oczekiwanej ilości miejsca jak np. wskazywanej przez `du`, sprawdź czy plik ten nie jest używany przez jakiś proces:\n`lsof | grep deleted | grep \"nazwa-pliku-zajmujacego-miejsce\"`\n\n\n## Jednolinijkowce\n\nKilka przykładów składania poleceń:\n\n- Czasem niesłychanie pomocna okazuje się możliwość uzyskania z plików tekstowych tylko części wspólnej, sumy i różnicy zbiorów danych przy użyciu `sort`/`uniq`. Przypuśćmy, że `a` i `b` są plikami tekstowymi, niezawierającymi żadnych powtórzeń. Taka operacja jest szybka i działa na plikach o dowolnym rozmiarze, do kilku gigabajtów. (Sortowanie nie jest ograniczone rozmiarem pamięci, aczkolwiek może wymagać użycia opcji `-T`, jeśli `/tmp` znajduje się na partycji głównej o małym rozmiarze.) Zobacz także uwagi na temat `LC_ALL` powyżej oraz opcję `-u` dla polecenia `sort` (pominiętą poniżej dla zachowania przejrzystości).\n```sh\n      sort a b | uniq > c   # c jest sumą a i b\n      sort a b | uniq -d > c   # c jest częścią wspólną a i b\n      sort a b b | uniq -u > c   # c jest różnicą zbiorów a - b\n```\n\n-  Wyświetl dwa pliki w formacie JSON, normalizując ich składnię, a następnie kolorując i dzieląc na strony wynik operacji:\n```\n      diff <(jq --sort-keys . < plik1.json) <(jq --sort-keys . < plik2.json) | colordiff | less -R\n```\n\n- Używaj `grep . *`, aby szybko przeanalizować zawartość wszystkich plików w katalogu (tak, by każda linia była powiązana z nazwą pliku) lub `head -100 *` (tak, by każdy plik miał nagłówek). To może być użyteczne dla katalogów zawierających ustawienia konfiguracyjne, jak w `/sys`, `/proc`, `/etc`.\n\n\n- Sumowanie wszystkich liczb zawartych w trzeciej kolumnie pliku tekstowego (to rozwiązanie jest prawdopodobnie 3X szybsze i zawarte w 3X mniejszej ilości kodu, niż odpowiednik w Pythonie):\n```sh\n      awk '{ x += $3 } END { print x }' mojplik\n```\n\n- Żeby zobaczyć rozmiary/daty w drzewie plików, poniższe rozwiązanie jest podobne do rekurencyjnego `ls -l`, ale czytelniejsze niż `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Powiedzmy, że masz plik tekstowy, np. log z serwera stron, zawierający pewne wartości w niektórych liniach, takie jak wartość parametru `acct_id` obecnego w adresach URL. Jeśli chcesz otrzymać zestawienie liczby zapytań dla każdego `acct_id`:\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- By śledzić zmiany w sposób ciągły, użyj `watch`, np. sprawdzanie zmian plików w katalogu `watch -d -n 2 'ls -rtlh | tail'` lub zmian ustawień sieciowych podczas naprawy ustawień Twojego połączenia wifi `watch -d -n 2 ifconfig`.\n\n- Uruchom tę funkcję, aby otrzymać losowo wybraną wskazówkę z tego dokumentu (przetwarza Markdown i wyodrębnia jeden element):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-pl.md |\n          sed '/cowsay[.]png/d' |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80 | iconv -t US\n      }\n```\n\n\n## Mniej znane, ale użyteczne\n\n- `expr`: wykonaj działania arytmetyczne lub logiczne albo oceniaj wyrażenia regularne\n\n- `m4`: prosty edytor makr\n\n- `yes`: wyświetl łańcuch znaków wiele razy\n\n- `cal`: wygodny kalendarz\n\n- `env`: wykonaj polecenie (przydatny w skryptach)\n\n- `printenv`: wyświetl zmienne środowiskowe (przydatny w debugowaniu i skryptach)\n\n- `look`: znajdź angielskie słowa (lub linie w pliku) zaczynające się od łańcucha znaków\n\n- `cut`, `paste` i `join`: manipulacja zawartością plików\n\n- `fmt`: sformatuj linie tekstu\n\n- `pr`: sformatuj tekst na stronach/w kolumnach\n\n- `fold`: zwiń linie tekstu\n\n- `column`: sformatuj pola tekstowe do postaci wyrównanych kolumn lub tabel o stałej szerokości\n\n- `expand` i `unexpand`: zamień znaki tabulacji na spacje i odwrotnie\n\n- `nl`: dodaj numerację linii\n\n- `seq`: wyświetl ciąg liczb\n\n- `bc`: kalkulator\n\n- `factor`: rozłóż liczby całkowite na czynniki\n\n- [`gpg`](https://gnupg.org/): zaszyfruj i podpisz pliki\n\n- `toe`: tabela wpisów terminfo\n\n- `nc`: debugowanie połączeń sieciowych i przesyłanie danych\n\n- `socat`: przekazywanie połączeń i przekierowanie portów TCP (podobny do `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): obrazowanie ruchu sieciowego\n\n- `dd`: przenoszenie danych między plikami lub urządzeniami\n\n- `file`: zidentyfikuj typ pliku\n\n- `tree`: wyświetl katalogi i podkatalogi w postaci zagnieżdżonego drzewa; jak `ls`, ale rekurencyjny\n\n- `stat`: informacje o pliku\n\n- `time`: wykonaj polecenie i zmierz czas jego działania\n\n- `timeout`: wykonaj polecenie przez określony czas i zatrzymaj jego działanie, gdy ten czas upłynie.\n\n- `lockfile`: utwórz plik semaforowy, który można usunąć tylko przy użyciu `rm -f`\n\n- `logrotate`: wykonaj rotację, skompresuj i wyślij pocztą logi.\n\n- `watch`: powtarzaj wykonanie polecenia, pokazując wyniki i/lub podkreślając zmiany\n\n- [`when-changed`](https://github.com/joh/when-changed): wykonuje dowolne zadane polecenie, gdy tylko zauważy zmianę w pliku. Zobacz też `inotifywait` oraz `entr`.\n\n- `tac`: wyświetl zawartość pliku w odwrotnej kolejności\n\n- `comm`: porównaj posortowane zawartości plików, linia po linii\n\n- `strings`: wyodrębnij tekst z plików binarnych\n\n- `tr`: zamiana lub edycja znaków\n\n- `iconv` lub `uconv`: zmiana kodowania znaków w tekstach\n\n- `split` i `csplit`: dzielenie plików na części\n\n- `sponge`: odczytaj pełną zawartość strumienia danych wejściowych przed ich wypisaniem, przydatne przy odczycie i zapisie do tego samego pliku, np. `grep -v cośtam jakis-plik | sponge jakis-plik`\n\n- `units`: obliczenia i zamiana jednostek miar; zamienia furlongi/dwa-tygodnie na twipy/mrugnięcie (zobacz także `/usr/share/units/definitions.units`)\n\n- `apg`: generuje hasła, dobierając ich znaki losowo\n\n- `xz`: wysokowydajna kompresja plików\n\n- `ldd`: informacje o bibliotekach dołączanych dynamicznie\n\n- `nm`: uzyskaj symbole z plików obiektowych\n\n- `ab` lub [`wrk`](https://github.com/wg/wrk): badanie wydajności serwerów stron\n\n- `strace`: debugowanie wywołań systemowych\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): lepszy traceroute do debugowania połączeń sieciowych\n\n- `cssh`: powłoka równoległa w trybie graficznym\n\n- `rsync`: zsynchronizuj pliki i katalogi przez SSH lub na lokalnym systemie plików\n\n- [`wireshark`](https://wireshark.org/) i [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): przechwytywanie pakietów danych i debugowanie sieci\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep dla warstwy sieciowej\n\n- `host` i `dig`: sprawdzanie DNSów\n\n- `lsof`: informacje o deskryptorach plików i gniazdach używanych przez proces\n\n- `dstat`: przydatne statystyki systemowe\n\n- [`glances`](https://github.com/nicolargo/glances): wysokopoziomowy podgląd użycia wielu podsystemów\n\n- `iostat`: statystyki użycia dysku\n\n- `mpstat`: statystyki użycia CPU\n\n- `vmstat`: statystyki użycia pamięci\n\n- `htop`: ulepszona wersja polecenia top\n\n- `last`: historia logowania użytkowników\n\n- `w`: sprawdzanie, kto jest zalogowany\n\n- `id`: informacje o tożsamości użytkownika/grupy\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): historyczne statystyki systemowe\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) or [`nethogs`](https://github.com/raboof/nethogs): podgląd użycia połączeń sieciowych przez gniazdo lub proces\n\n- `ss`: statystyki użycia gniazda\n\n- `dmesg`: komunikaty błędów systemu i jego uruchomienia\n\n- `sysctl`: podejrzyj i skonfiguruj parametry jądra Linux w trakcie działania\n\n- `hdparm`: zmiana ustawień i badanie wydajności dysków SATA/ATA\n\n- `lsblk`: wyświetl urządzenia blokowe: podgląd listy dysków i partycji w postaci drzewa\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informacje o sprzęcie, wliczając w to CPU, BIOS, RAID, podsystem grafiki, urządzenia, itd.\n\n- `lsmod` i `modinfo`: wyświetl listę i szczegóły dotyczące modułów jądra.\n\n- `fortune`, `ddate` oraz `sl`: hm, no cóż, wszystko zależy od tego, czy lokomotywy parowe i dymki z komiksów uważasz za \"użyteczne\"\n\n\n## Tylko dla macOS\n\nPoniższe wpisy mają znaczenie *tylko* dla systemów macOS.\n\n- Zarządzanie pakietami oprogramowania za pomocą `brew` (Homebrew) i/lub `port` (MacPorts). Można ich użyć do instalacji na macOS wielu z powyższych poleceń.\n\n- Skopiujesz dane wyjściowe dowolnego polecenia do aplikacji pulpitowej za pomocą `pbcopy`, a dane wejściowe do polecenia wkleisz używając `pbpaste`.\n\n- Żeby użyć klawisza Option w Terminalu macOS jako klawisza alt (do użycia np. jak w powyższych kombinacjach **alt-b**, **alt-f**, itp.), otwórz Preferences -> Profiles -> Keyboard i wybierz \"Use Option as Meta key\".\n\n- Do otwarcia pliku w aplikacji pulpitowej, użyj poleceń `open` lub `open -a /Applications/Whatever.app`.\n\n- Spotlight: szukaj plików używając `mdfind` i wyświetl metadane (takie jak informacje EXIF ze zdjęcia) przy pomocy `mdls`.\n\n- Bądź świadom tego, że macOS oparty jest na systemie BSD Unix i wiele poleceń (np. `ps`, `ls`, `tail`, `awk`, `sed`) trochę się różni od tych samych poleceń w systemach Linux, na które to systemy w główny wpływ miały Uniksy podobne do System V i narzędzia GNU. Różnice można często zauważyć, przyglądając się nagłówkom podręczników, mówiącym \"BSD General Commands Manual.\" W niektórych przypadkach, zainstalowane mogą być również wersje GNU (takie polecenia, jak `gawk` i `gsed` jako awk i sed z pakietu narzędzi GNU). Jeżeli piszesz wieloplatformowe skrypty Bash, unikaj takich poleceń (rozważ na przykład użycie Pythona lub `perl`a) albo przetestuj je dokładnie.\n\n- Aby uzyskać informacje o wersji macOS, użyj `sw_vers`.\n\n## Tylko dla Windows\n\nPoniższe wpisy mają znaczenie *tylko* dla systemów Windows.\n\n### Sposoby pozyskania narzędzi Unix w systemach Windows\n\n- Okiełznaj moc powłoki systemów Unix w systemach Microsoft Windows instalując [Cygwin](https://cygwin.com/). Większość rzeczy opisanych w tym dokumencie będzie działać od razu.\n\n- W Windows 10 możesz użyć [Windows Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about), który zapewnia znajome środowisko Basha z narzędziami wiersza poleceń Unix.\n\n- Jeśli chcesz używać głównie narzędzi programistycznych GNU (takich jak GCC) w systemach Windows, rozważ użycie [MinGW](http://www.mingw.org/) i jego pakietu [MSYS](http://www.mingw.org/wiki/msys), który zapewnia takie narzędzia, jak bash, gawk, make i grep. MSYS nie spełnia wszystkich funkcji w porównaniu z Cygwinem. MinGW jest szczególnie przydatny do tworzenia odpowiedników narzędzi systemu Unix, działających natywnie w systemach Windows.\n\n- Kolejną opcją zapoznania się z systemami Unix z poziomu systemu Windows jest [Cash](https://github.com/dthree/cash). Miej na uwadze, że tylko nieliczne uniksowe polecenia i ich opcje są dostępne w tym środowisku.\n\n### Przydatne narzędzia wiersza poleceń Windows\n\n- Możesz wykonać i oskryptować większość zadań administracyjnych Windows z poziomu wiersza poleceń, znając i używając `wmic`.\n\n- Natywne narzędzia wiersza poleceń Windows do zarządzania siecią, które mogą się okazać użyteczne, to między innymi `ping`, `ipconfig`, `tracert` i `netstat`.\n\n- Możesz wykonać [wiele przydatnych zadań w Windows](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows), używając polecenia `Rundll32`.\n\n### Porady i wskazówki dotyczące Cygwina\n\n- Instaluj dodatkowe programy Unix, używając zarządcy pakietów oprogramowania Cygwina.\n\n- Używaj `mintty` jako Twojego programu do obsługi wiersza poleceń.\n\n- Uzyskaj dostęp do zawartości schowka Windows przez `/dev/clipboard`.\n\n- Uruchom `cygstart`, aby otworzyć dowolny plik przy użyciu zarejestrowanej aplikacji.\n\n- Uzyskaj dostęp do rejestru systemowego Windows używając `regtool`.\n\n- Zauważ, że Windowsowa ścieżka do dysku `C:\\` w Cygwinie staje się ścieżką `/cygdrive/c` oraz, że katalog `/` Cygwina pojawia się w lokalizacji `C:\\cygwin` systemu Windows. Zmieniaj sposób zapisu ścieżek między Cygwinem a Windows używając `cygpath`. To najbardziej przydatne w skryptach, które uruchamiają programy systemu Windows.\n\n## Inne źródła wiedzy\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Wyselekcjonowana lista narzędzi powłoki i innych zasobów.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Bardziej szczegółowy przewodnik po wierszu poleceń systemu macOS.\n- [Tryb ścisły](http://redsymbol.net/articles/unofficial-bash-strict-mode/) środkiem do tworzenia lepszych skryptów powłoki.\n- [shellcheck](https://github.com/koalaman/shellcheck): Narzędzie do analizy statycznej skryptów powłoki. Zasadniczo, taki \"odśmiecacz\" dla powłok bash/sh/zsh.\n- [Nazwy plików i ścieżki w powłoce](http://www.dwheeler.com/essays/filenames-in-shell.html): Niestety skomplikowany zestaw uwag na temat prawidłowej obsługi nazw plików w skryptach powłoki.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Więcej poleceń i narzędzi przydatnych do obróbki danych, zaczerpniętych z książki pod tym samym tytułem.\n\n## Zastrzeżenie\n\nZ wyjątkiem opisów drobnych zadań, kod napisany jest tak, aby był czytelny dla innych. Z mocą przychodzi odpowiedzialność. To, że coś *możesz* zrobić w Bashu, niekoniecznie oznacza, że powinieneś/powinnaś to zrobić! ;)\n\n\n## Licencja\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nTa praca została udostępniona na licencji [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-pt.md",
          "type": "blob",
          "size": 27.88,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# A arte da linha de comando\n\n- [Meta](#meta)\n- [Básico](#básico)\n- [Uso diário](#uso-diário)\n- [Processamento de arquivos e dados](#processamento-de-arquivos-e-dados)\n- [Debugando o sistema](#debugs-do-sistema)\n- [One-liners](#one-liners)\n- [Obscuros mas úteis](#obscuros-mas-úteis)\n- [Mais conteúdo](#mais-conteúdo)\n- [Aviso](#aviso)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nFluência na linha de comando é uma habilidade muitas vezes negligenciada ou considerada obsoleta, porém ela aumenta sua flexibilidade e produtividade como *desenvolvedor* de diversas maneiras, sutis ou não. Este texto descreve uma seleção de notas e dicas de uso da linha de comando que me parecem muito uteis, quando usando o Linux. Algumas dicas são elementares, e outras são mais específicas, sofisticadas ou obscuras. Esta página é curta, mas se você souber usar e lembrar todos os items que estão aqui, então você está mandando bem.\n\nMuito do que está aqui [originalmente](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[apareceu](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nno [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nmas dado o interesse por lá, me pareceu importante usar o Github, onde pessoas mais talentosas do que eu, poderiam sugerir melhorias facilmente. Se você descobrir um erro ou algo que poderia ser melhorado, por favor abra um issue ou um PR! (E claro, por favor veja as `meta sections' e PRs/issues existentes, primeiro.)\n\n## Meta\n\nEscopo:\n\n- Este guia é destinado tanto aos iniciantes quanto aos usuários mais experientes. Os objetivos são *abrangência* (tudo que é importante), *especificidade* (dar exemplos concretos dos casos de usos mais comuns), e *concisão* (evitar coisas que não são tão essenciais ou digressões que você pode facilmente encontrar pela Internet). Todas as dicas são essenciais em alguma situação ou trazem uma economia notável de tempo em relação a outras alternativas.\n- Este guia é escrito para o Linux. Muitos, mas não todos os items, se aplicam igualmente para o MacOS (ou mesmo o Cygwin).\n- O foco está na interatividade com Bash, embora muitas dicas aqui sejam aplicáveis a outras `shells' e também a scripts em Bash, em geral.\n- Incluímos tanto comandos no Unix \"padrão\", quanto comandos que requeiram instalação de pacotes adicionais -- desde que estes sejam importantes o suficiente para merecerem sua inclusão nessa lista.\n\nNotas:\n\n- Para manter este guia em uma única página, o conteúdo implícito será incluído por referência. Você é competente o suficiente para verificar mais detalhes em outros lugares, desde que você já tenha entendido a ideia ou saiba o que procurar no Google. Use `apt-get`, `yum`, `dnf`, `pacman`, `pip` ou `brew` (quando adequado) para instalar novos programas.\n- Use [Explainshell](http://explainshell.com/) para encontrar informações úteis sobre o que fazem os comandos, as opções, pipes, etc.\n\n\n## Básico\n\n- Aprenda o básico sobre Bash. Na verdade, digite `man bash` e pelo menos entenda superficialmente o seu funcionamento; é bastante simples de ler e nem é tão grande assim. Shells alternativas podem ser legais, mas Bash é a mais poderosa e sempre está disponível (aprender *somente* zsh, fish, etc, é tentador quando você usa o seu próprio notebook, mas restringe você em muitas situações, por exemplo quando você quer  usar servidores de outros).\n\n- Aprenda bem pelo menos um editor de texto tradicional. Idealmente o Vim (`vi`), já que nenhum outro funciona tão bem nos   terminais aleatórios que a gente encontra por aí (mesmo que você prefira usar o Emacs, um IDE, ou um editor hipster a maior parte  do tempo).\n\n- Saiba como ler a documentação com o `man` (para os curiosos, `man man` lista os números das seções, por exemplo, 1 se refere aos comandos \"regulares\", 5 é sobre arquivos/convenções, e 8 diz respeito a administração). Procure outros documentos do manual com o `apropos`. Saiba que alguns dos comandos não são executáveis, mas sim built-ins (embutidos) no bash, pra esses você poderá conseguir ajuda com `help` e `help -d`.\n\n- Aprenda como fazer redirecionamento de saída e entrada usando `>` e `<` e pipes usando `|`. Aprenda sobre o stdout e stdin.\n\n- Aprenda sobre a expansão de arquivos glob com `*` ( e talvez `?` e `{`...`}`) e entenda as diferenças entre aspas duplas `\"` e aspas simples `'`. (Veja mais em variáveis de expansão abaixo.)\n\n- Se familiarize com o gerenciamento de jobs em Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Aprenda `ssh`, e o básico de autenticação sem senha, através do `ssh-agent`, `ssh-add`, etc.\n\n- Gerenciamento básico de arquivos: `ls` e `ls -l` (em particular, aprenda o que cada coluna no `ls -l` significa), `less`, `head`, `tail` e `tail -f` (ou melhor ainda, `less +F`), `ln` e `ln -s`(aprenda as diferenças e vantagens de soft links comparados a hard links), `chown`, `chmod`, `du` (para um rápido resumo do uso do disco: `du -sk *`). Para gerenciamento do sistema de arquivos, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`.\n\n- Gerenciamento básico da rede: `ip` ou `ifconfig`, `dig`.\n\n- Saiba bem como usar expressões regulares, e as várias flags para `grep`/`egrep`. As `-i`, `-o`, `-A`, e `-B` são opções que é importante conhecer.\n\n- Aprenda a usar `apt-get`, `yum`, `dnf` ou `pacman` (dependendo da distribuição) para procurar e instalar pacotes. E garanta que você possui o `pip` para instalar ferramentas baseadas em Python (algumas das abaixo são mais fáceis de instalar através do `pip`).\n\n\n## Uso diário\n\n- Usando Bash, use **Tab** para completar argumentos e **ctrl-r** para pesquisar através a história dos comandos.\n\n- Em Bash, utilize **ctrl-w** para deletar a última palavra, e **ctrl-u** para deletar tudo e voltar para o início da linha. Use **alt-b** e **alt-f** para se mover por palavras, **ctrl-k** para apagar até o final da linha, **ctrl-l** para limpar a tela. Consulte `man readline` para todos os keybindings padrões do Bash. Existem muitos. Por exemplo **alt-.** circula através dos argumentos anteriores, e **alt-*** expande um glob.\n\n- Alternativamente, se você adora os keybinds do vi, use `set -o vi`.\n\n- Para ver os comandos recentes, `history`. Existem também muitas abreviações como `!$` (último argumento) e `!!` último comando, embora estes sejam muitas vezes facilmente substituídos por **ctrl-r** e **alt-.**.\n\n- Pra voltar para o diretório anterior de trabalho: `cd -`.\n\n- Se você está na metade do caminho ao digitar um comando, mas mudou de ideia, tecle **alt-#** para adicionar um `#` ao início da linha e definir esta como um comentário (ou use **ctrl-a**. **#**. **enter**). Mais tarde você poderá recuperar o comando através da `history`.\n\n- Use `xargs` (ou `parallel`). Estes são muito poderosos. Note que você pode controlar como os vários items são executados por linha (`-L`) assim como o paralelismo (`-P`). Se você não tem certeza se isto é a coisa certa a se fazer, use `xargs echo` primeiro. O `-I{}` também é muito útil. Exemplos:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` é um modo de visualização muito útil da árvore de processos.\n\n- Use `pgrep` e `pkill` para procurar ou sinalizar os processo pelo seu nome (`-f` é muito útil).\n\n- Saiba os vários sinais que você pode enviar para um processo. Por exemplo, para suspender um processo, use `kill -STOP [pid]`. Para saber a lista completas dos sinais, veja `man 7 signal`.\n\n- Use `nohup` ou `disown` se você deseja por o processo no background, executando para sempre.\n\n- Verifique quais processos estão escutando através de `netstat -lntp` ou `ss -plat` (para TCP; adicione `-u` para UDP).\n\n- Veja também `lsof` para abrir sockets e arquivos.\n\n- Em scripts Bash, use `set -x` para debugar a saída. Utilize modos estritos sempre que for possível. Use `set -e` para abortar em caso de erros. Use `set -o pipefail` para também ser restrito a respeito dos erros (embora este tópico seja um pouco sútil). Para scripts mais desenvolvidos, use também `trap`.\n\n- Em Bash scripts, subshells (escrito com parênteses) são formas convenientes de agrupar comandos. Um exemplo comum é temporariamente se mover para um diretório de trabalho diferente, e.g.\n```bash\n      # faz algo no diretório corrente\n      (cd /some/other/dir && other-command)\n      # continua no diretório atual\n```\n\n- No Bash, note que existem muitos tipos de variáveis de expansão. Verificando a existência de uma variável: `${name:?error_messages}`. Por exemplo, se um script Bash requer um único argumento, apenas escreva `input_file=${1:?usage: $0 input_file}`. Expansões aritméticas: `i=$(( (i + 1) % 5 ))`. Sequências: `{1..10}`. Aparando as strings: `${var%suffix}` e `${var#prefix}`. Por exemplo, se `var=foo.pdf`, então `echo ${var%.pdf}.txt` imprime `foo.txt`.\n\n- A saída de um comando pode ser tratada como um arquivo através `<(algum comando)`. Por exemplo, comparar um arquivo local `/etc/hosts` com um remoto:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Saiba sobre \"documentos aqui\" no Bash, como em `cat <<EOF ...`.\n\n- No Bash, redirecionar a saída padrão (stdout) e a saída de erro padrão (stderr) através de: `algum-comando >logfile 2> $1`. Muitas vezes, para garantir que um comando não deixa um arquivo aberto para manipular a entrada padrão, digitando isso no terminal que você está, é uma boa prática adicionar um `</dev/null`.\n\n- Use `man ascii` para visualizar a tabela ASCII, com valores hexadecimais e decimais. Para informações gerais sobre codificações, `man unicode`, `man utf-8`, e `man latin1` são úteis.\n\n- Use `screen` ou [`tmux`](https://tmux.github.io/) para multiplexar as telas, especialmente útil em sessões ssh remotas e para desplugar e replugar a uma sessão. Uma alternativa mais simples para a persistência de uma sessão é `dtach`.\n\n- No ssh, saber como realizar um túnel de portas com `-L` ou `-D` (e ocasionalmente `-R`) é útil, para por exemplo acessar sites webs de um servidor remoto.\n\n- Pode ser útil realizar algumas otimizações em suas configurações do ssh; por exemplo, o arquivo `~/.ssh/config` contém configurações para evitar que conexões sejam dropadas em certos ambientes de rede, use compressão (muito útil quando se está usando o scp através de uma conexão lenta), e multiplexação de canais do mesmo servidor com um arquivo de controle local:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Algumas outras opções relevantes para o ssh tem problemas de segurança e devem ser habilitadas com muito cuidado, por exemplo somente para subrede ou host ou em redes confiaveis (de confiança): `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Para conseguir as permissões em arquivo em forma octal, o que é útil para a configuraçao do sistema mas não disponível no `ls` e fácil de se confundir, use algo como:\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Para seleção interativas de valores da saída de outro comando, use [`percol`](https://github.com/mooz/percol).\n\n- Para interação com arquivos baseados na saída de outro comando (like `git`), use `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Para um simples servidor web para todos os arquivos do diretório atual (e subdiretórios), disponível para alguém na sua rede, use:\n`python -m SimpleHTTPServer 7777` (para a porta 7777 e Python 2) e `python -m http.server 7777` (para a porta 7777 e Python 3).\n\n\n## Processamento de arquivos e dados\n\n- Para localizar um arquivo pelo nome no diretório atual, `find . -iname '*something*'` (ou similar). Para procurar um arquivo em qualquer lugar pelo nome, use `locate something` (mas tenha em mente que o `updatedb` pode não ter indexado arquivos criados recentemente).\n\n- Para uma busca mais geral através de arquivos de dados ou de códigos (mais avançado do que `grep -r`), use [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Para converter HTML para texto: `lynx -dump -stdin`.\n\n- Para Markdown, HTML, e todos os demais tipos de conversão de documentos, tente [`pandoc`](http://pandoc.org/).\n\n- Se você precisa manipular XML, `xmlstarlet` é antigo mas é bom.\n\n- Para JSON, `jq`.\n\n- Para Excel ou arquivos CSV, [csvkit](https://github.com/onyxfish/csvkit) que provê `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.\n\n- Para a Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) é uma forma conveniente e [`s4cmd`](https://github.com/bloomreach/s4cmd) é mais rápido. O [`aws`](https://github.com/aws/aws-cli) da amazon é essencial para outras tarefas relacionadas.\n\n- Aprenda a respeito do `sort` e `uniq`, incluindo as opções do `-u` e `-d` do `uniq` -- veja os one-liners abaixo. Veja também `comm`.\n\n- Aprenda a respeito do `cut`, `paste`, e `join` para manipular arquivos de texto. Muitas pessoas usam `cut` mas esquecem do `join`.\n\n- Aprenda a respeito do `wc` para contar novas linhas (`-l`), caracteres (`-m`), palavras (`-m`) e bytes (`-c`).\n\n- Aprenda a respeito do `tee` para copiar da entrada padrão (stdin) para um arquivo e também para a saída padrão (stdout), como no `ls -al | tee file.txt`.\n\n- Aprenda que as configurações de localização afetam várias ferramentas da linha de comando em formas sutis, incluindo a ordem da ordenação e performance. A maioria das instalações do Linux irá definir `LANG` ou outras variáveis de localização para o ingles dos USA. Mas esteja ciente de que a ordem da ordenação irá mudar, caso você altere a localização. E saiba que as rotinas do i18n podem fazer o `sort` ou outros comandos executarem *muitas vezes* mais devagar. Em algumas situações (como o conjunto de operações ou as operações únicas abaixo) você pode seguramente eliminar a lentidão das rotinas do i18n inteiramente e usar a ordem baseada nos bytes, usando `export LC_ALL=C`.\n\n- Aprenda o básico sobre `awk` e `sed` para obtenção de informações simples de dados. Por exemplo, somar todos os números na terceira coluna de um arquivo de texto: `awk '{ x += $3 } END { print x }'`. Isto é provavelmente 3X mais rápido e 3X mais curto do que o equivalente em Python.\n\n- Para substituir todas as ocorrências de uma string em um lugar, em um ou mais arquivos:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Para renomear muitos arquivos de uma vez, de acordo com um padrão, use `rename`. Para renomeações mais complexas, [`repren`](https://github.com/jlevy/repren) pode ajudar.\n```sh\n      # Recuperar arquivos de backup foo.bak -> foo:\n      rename 's/\\.bak$//' *.bak\n      # Renomea completamente o nome dos arquivos, diretórios, e outros conteúdos foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n```\n\n- Utilize o `shuf` para embaralhar ou selecionar linhas randoms de um arquivo.\n\n- Para as opções do `sort`. Aprenda com as chaves (`-t` e `-k`). Em particular, saiba que precisa escrever `-k1,1` para ordenar somente o primeiro campo; `-k1` significa ordenar de acordo com a linha inteira.\n\n- Ordenação estável (`sort -s`) pode ser útil. Por exemplo, para ordenar primeiramente pelo campo 2, então secundariamente pelo campo 1, você pode usar `sort -k1,1 | sort -s -k2,2`.\n\n- Se você precisa escrever literalmente um tab na linha de comando no Bash (por exemplo, para o argumento -t do `sort`), pressione **ctrl-v** **[Tab]** ou escreva `$'\\t'` (o último é melhor pois você pode copiar e colar ele).\n\n- As ferramentas padrão para extrair patches de códigos fonte são `diff`e `patch`. Veja também `diffstat` para um resumo de estatísticas de um diff. Note que `diff -r` funciona para diretórios inteiros. Use `diff -r tree1 tree2 | diffstat`  para um resumo das alterações.\n\n- Para arquivos binários, use `hd` para um simples dump hexadecimal e `bvi` para edição binária.\n\n- Também para arquivos binários, `strings` (mais `grep`, etc.) deixa você encontrar pedaços de texto.\n\n- Para diffs binários (compressão delta), use `xdelta3.`\n\n- Para converter a codificação de textos, tente `iconv`. Ou `uconv` para uso mais avançado; Este suporta algumas funcionalidades avançadas do Unicode. Por exemplo, este comando transforma o texto para minúsculo e remove todos os acentos (expandindo e removendo eles):\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Para dividir um arquivo em pedaços, veja `split` (para dividir por tamanho) e `csplit` (para dividir por um padrão).\n\nUse `zsless`, `zmore`, `zcat`, and `zgrep` para manipular arquivos comprimidos.\n\n\n## Debugando o sistema\n\n- Para web debug, `curl` e `curl -I` são úteis, ou os equivalentes `wget`, or uma alternativa mais moderna [`httpie`](https://github.com/jakubroztocil/httpie).\n\n- Para saber o status do disco/cpu/rede, use `iostat`, `netstat`, `top` (ou o `htop` como alternativa melhor), e (especialmente) `dstat`. Bom para obter uma ideia rápida do que está acontecendo em um sistema.\n\n- Para um resumo mais aprofundado do sistema, use [`glances`](https://github.com/nicolargo/glances). Este lhe apresenta vários níveis de estatísticas do sistema em uma janela do terminal. Muito útil para uma rápida verificação em vários subsistemas.\n\n- Para saber o status da memória, execute e entenda a saída do `free` `vmstat`. Em particular, esteja ciente de que o valor \"cached\", é mantido pelo kernel Linux como um arquivo de cache, então este efetivamente conta como um valor de memória disponível.\n\n- Debugar um sistema java é uma outra historia, mas um simples truque nas máquinas virtuais Oracle ou algum outro tipo de JVM é que você pode executar `kill -3 <pid>` e um completo rastreamento da pilha(stack trace) e resumo do heap (incluindo detalhes geracionais do garbage collector, os quais podem ser altamente informativos) serão vazados para stderr/logs.\n\n- Use [`mtr`](http://www.bitwizard.nl/mtr/) como uma melhor alternativa ao traceroute, para identificar problemas na rede.\n\n- Para verificar o porque de um disco estar cheio, [`ncdu`](https://dev.yorhel.nl/ncdu) economiza bastante tempo em comparação aos comandos usuais como `du -sh *`.\n\n- Para procurar qual socket ou processo está utilizando a banda de rede, tente [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ou [`nethogs`](https://github.com/raboof/nethogs).\n\n- A ferramenta `ab` (que vem com o Apache) é muito útil para verificação rápida da performance do servidor web. Para mais complexos testes de carga, tente `siege`.\n\n- Para debugs mais sérios da rede, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), ou [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Aprenda a respeito do `strace`e `ltrace`. Estes podem ser úteis se um programa está falhando, travado, ou quebrando, e você não sabe o por que, ou se você quer obter uma ideia geral da performance. Note que a opção de perfil (`-c`), e a habilidade de se plugar a um processo em execução (`-p`).\n\n- Aprenda a respeito do `ldd` para verificar bibliotecas compartilhadas, e etc.\n\n- Aprenda sobre como se conectar a um processo em execução com o `gdb` e obter informações sobre a stack trace.\n\n- Utilize `/proc`. Este é incrivelmente útil em algumas vezes quando se deseja debugar problemas ao vivo. Exemplos: `/proc/cpuinfo`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps`.\n\n- Quando estiver debugando o porque de algo ter dado errado no passado, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) pode ser de muita utilidade. Ele exibe as estatísticas históricas da CPU, memória, rede e etc.\n\n- Para análises de performance mais profundas do sistema, dê uma olhada em `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](http://en.wikipedia.org/wiki/Perf_(Linux)), e [`sysdig`](https://github.com/draios/sysdig).\n\n- Confirme qual a sua distribuição do Linux usando (funciona na maioria das distros): `lsb_release -a`.\n\n- Use `dmesg` sempre que algo estiver agindo de maneira estranha (isto pode ser um problema de hardware ou problema de driver).\n\n\n## One-liners\n\nAlguns exemplos de como reunir os comandos.\n\n- O seguinte é notavelmente e frequentemente útil: muitas vezes você quer obter a interseção, união e a diferença de arquivos de texto através de `sort`/`uniq`. Suponha que `a` e `b` são arquivos de texto que são \"uniqued\" únicos. Esse modo é rápido, e funciona em arquivos de tamanhos arbitrários, podem até possuírem gigabytes. (Sorting não é limitado por memória, embora você possa precisar usar a opção `-T` se `/tmp` está em uma partição pequena.) Veja também a nota sobre `LC_ALL` acima e as opções `-u` do `sort`(vamos deixar isso claro abaixo).\n```sh\n      cat a b | sort | uniq > c   # c is a union b\n      cat a b | sort | uniq -d > c   # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n\n- Use `grep . *` para visualmente examinar todo o conteúdo de todos os arquivos de um diretório, por exemplo, para diretórios com arquivos de configurações, como `/sys`, `/proc`, `/etc`.\n\n\n- Somar todos os números em uma terceira coluna de um arquivo de texto (isto é provavelmente 3X mais rápido e 3X menos linhas de código do que o equivalente em Python).\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Se você quer visualizar tamanhos/datas em uma árvore de arquivos, isto é como um `ls -l` recursivo, mas é mais fácil de ler do que `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Utilize `xargs` ou `parallel` sempre que você puder. Note que você pode controlar quantos item é executado por linha (`-L`) assim como o paralelismo (`-P`). Se você não tem certeza de que esta é a coisa certa a se fazer, utilize `xargs echo` primeiro.\n```sh\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- Digamos que você tenha um arquivo de texto, como um log do servidor web, e um certo valor que aparece em algumas linhas, como por exemplo o parâmetro `acct_id` que está presente na URL. Se você quer um cálculo de quantas requisições para este `acct_id`.\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Execute esta função para obter uma dica random deste documento (analisa a sintaxe Markdown e extrai um item)\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-pt.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Obscuros mas úteis\n\n- `expr`: executa operações boleanas ou aritméticas ou avalia expressões regulares.\n\n- `m4`: simples processador de macros.\n\n- `yes`: imprime uma string muitas vezes.\n\n- `cal`: calendário legal.\n\n- `env`: executa um comando (útil em scripts).\n\n- `printenv`: imprime as variáveis de ambiente (útil em debug e scripts).\n\n- `look`: procura palavras inglesas (ou linhas em um arquivo) começando com uma string.\n\n- `cut ` e `paste` e `join`: manipulação de dados.\n\n- `fmt`: formata parágrafos de texto.\n\n- `pr`: formata textos em páginas/colunas.\n\n- `fold`: envolve linhas de texto.\n\n- `column`: formata texto em colunas ou tabelas.\n\n- `expand` e `unexpand`: converte entre tabs e espaços.\n\n- `nl`: adiciona números as linhas.\n\n- `seq`: imprime números.\n\n- `bc`: calculadora.\n\n- `factor`: fatora inteiros.\n\n- `gpg`: criptografa e assina arquivos.\n\n- `toe`: tabela de entradas dos tipos de terminais.\n\n- `nc`: ferramenta de debug de rede e transferência de dados.\n\n- `socat`: socket relay e encaminhamento de portas tcp (similar ao `netcat`)\n\n- `slurm`: visualização do tráfego da rede.\n\n- `dd`: move os dados entre arquivos ou dispositivos.\n\n- `file`: identifica o tipo do arquivo.\n\n- `tree`: mostra os diretórios e subdiretórios como um árvore de dependências; como `ls` mas recursivo.\n\n- `stat`: informações do arquivo.\n\n- `tac`: imprime arquivos na ordem reversa.\n\n- `shuf`: seleção random de linhas de um arquivo.\n\n- `comm`: compara uma lista de arquivos ordenadas linha por linha.\n\n- `pv`: monitora o progresso dos dados através de um pipe.\n\n- `hd` e `bvi`: dump ou edita arquivos binários.\n\n- `strings`: extrai texto de arquivos binários.\n\n- `tr`: tradução e manipulação de caracteres.\n\n- `iconv` ou `uconv`: conversor de codificações de texto.\n\n- `split ` e `csplit`: divisão de arquivos.\n\n- `units`: conversor de unidades e cálculos; converte furlongs por quinzena para twips per blink (veja também `/usr/share/units/definitions.units`)\n\n- `7z`: Compressor de arquivos de alto desempenho.\n\n- `ldd`: informações dinâmicas das bibliotecas.\n\n- `nm`: símbolos de arquivos objetos.\n\n- `ab`: benchmarking para web servers.\n\n- `strace`: Debug para chamadas de sistema.\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): melhor traceroute para debugar a rede.\n\n- `cssh`: Visualização concorrente da shell.\n\n- `rsync`: Sincroniza arquivos e pastas através do SSH.\n\n- [`wireshark`](https://wireshark.org/) e [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): captura de pacotes e debug de rede.\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep para a camada de rede.\n\n- `host` e `dig`: Consultas DNS.\n\n- `lsof`: Arquivo de descritores dos processos e informações dos sockets.\n\n- `dstat`: Estatísticas úteis do sistema.\n\n- [`glances`](https://github.com/nicolargo/glances): Resumo de alto nível, de multi subsistemas.\n\n- `iostat`: Estatísticas de uso do CPU e do disco.\n\n- `htop`: Versão do top melhorada.\n\n- `last`: histórico de logins.\n\n- `w`: quem está logado.\n\n- `id`: Informações sobre a identidade do user/group.\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): histórico dos estados do sistema.\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ou [`nethogs`](https://github.com/raboof/nethogs): Utilização da rede por sockets ou processos.\n\n- `ss`: Estatísticas dos sockets.\n\n- `dmesg`: Mensagens de erro do sistema e do boot.\n\n- `hdparm`: Manipulação/performance de discos SATA/ATA.\n\n- `lsblk`: Lista os blocos dos dispositivos: uma visualização em forma de árvore dos seus discos e partições do disco.\n\n- `lshw` e `lspci`: informações do hardware, incluindo RAID, gráficos, etc.\n\n- `fortune`, `ddate`, e `sl`: um, bem, isto depende de você considerar locomotivas a vapor e citações Zippy \"úteis\".\n\n## Mais conteúdo\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Uma lista refinada de ferramentas da shell e outros recursos.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) para escrever shell scripts melhores.\n\n## Aviso\n\nCom a exceção de tarefas muito pequenas,  código é normalmente escrito para que outros possam ler. Junto com o poder vem a responsabilidade. O fato de você *poder* fazer algo usando Bash não significa necessariamente  que você deve! ;)\n\n\n## Licença\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nEste trabalho está licenciado com uma [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-ro.md",
          "type": "blob",
          "size": 40.93,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# Arta liniei de comandă\n\n[![Pune o întrebare](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Alătură-te discuției https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Meta](#meta)\n- [Bazele](#bazele)\n- [Folosire zilnică](#folosire-zilnică)\n- [Procesarea fișierelor și a datelor](#procesarea-fișierelor-și-a-datelor)\n- [Depanarea sistemului](#depanarea-sistemului)\n- [Comenzi de o linie](#comenzi-de-o-linie)\n- [Obscure dar utile](#obscure-dar-utile)\n- [Doar pentru OS X](#doar-pentru-os-x)\n- [Doar pentru Windows](#doar-pentru-windows)\n- [Mai multe resurse](#mai-multe-resurse)\n- [Anunț legal](#anunț-legal)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nA folosi linia de comandă în mod eficient este o abilitate ignorată și/sau considerată obscură, dar ajută la creșterea flexibilității și productivității ca inginer. Acest ghid reprezintă o selecție de note și sfaturi pe care le-am găsit utile lucrului în Linux. Unele sfaturi sunt elementare, altele sunt foarte specifice, sofisticate sau obscure. Pagina nu este foarte lungă, dar dacă memorați și folosiți lucrurile de aici atunci știți o cantitate semnificativă de informație.\n\nAceastă muncă este rezultatul eforturilor [multor autori și translatori](AUTHORS.md).\nMulte dintre aceste sfaturi\n[au apărut](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[original](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\npe [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nși au fost mutate pe GitHub ulterior, unde oameni mai talentați au produs numeroase îmbunătățiri.\n[**Vă rugăm întrebați**](https://airtable.com/shrzMhx00YiIVAWJg) dacă aveți nelămuriri legate de linia de comandă. [**Contribuiți**](/CONTRIBUTING.md) dacă identificați o eroare sau ceva ce ar putea fi îmbunătățit!\n\n## Meta\n\nScop:\n\n- Acest ghid este atât pentru începători cât și pentru avansați. Scopurile sunt *acoperire* (tot ce este important), *specificitate* (oferirea exemplelor concrete pentru cazurilor comune) și *brevitate* (neincluderea lucrurilor neesențiale sau a digresiunilor ce pot fi găsite ușor în alte părți). Fiecare sfat este esențial în câteva situații sau reduce semnificativ timpul necesar efectuării unei cerințe comparativ cu celelalte alternative.\n- Ghidul este scris pentru Linux, cu excepția secțiunilor \"[Doar pentru OS X](#doar-pentru-os-x)\" și \"[Doar pentru Windows](#doar-pentru-windows)\". Majoritatea sfaturilor din celelalte secțiuni se aplică/pot fi instalate pe alte sisteme Unix sau OS X (chiar și în Cygwin).\n- Se pune accent pe Bash interactiv, chiar dacă unele sfaturi sunt aplicabile și altor shell-uri sau pentru Bash-scripting în general.\n- Atât comenzile Unix \"standard\" cât și cele care necesită instalarea de pachete speciale sunt incluse -- cât timp sfaturile sunt destul de importante cât să merite incluziunea.\n\nNote:\n\n- Pentru a păstra totul într-o singură pagină, conținutul este inclus implicit doar prin referințe. Suntem siguri că puteți căuta mai multe detalii după ce aveți ideea/comanda după care să căutați. Folosiți `apt-get`, `yum`, `dnf`, `pacman`, `pip` sau `brew` (după caz) pentru a instala programe noi.\n- Folosiți [Explainshell](http://explainshell.com/) pentru a obține explicații utile despre ce fac anumite comenzi, opțiuni, etc.\n\n\n## Bazele\n\n- Învățați folosirea de bază a Bash. De fapt, tastați `man bash` și treceți măcar pe diagonală prin tot conținutul; este ușor de citit și nu este prea lung. Shell-uri alternative pot fi mai interesante, dar Bash este puternic și disponibil mereu (a învăța *doar* zsh, etc., chiar dacă e tentant pe laptopul propriu, vă restricționează în anumite situații, cum ar fi în folosirea unor servere existente).\n\n- Învățați cel puțin un editor de text. Ideal Vim (`vi`), cum nu există un competitor real pentru editarea în terminal (chiar dacă folosiți Emacs, sau un editor modern în majoritatea timpului).\n\n- Învățați să citiți documentație cu `man` (pentru curioși, `man man` listează secțiunile, de exemplu 1 este pentru comenzi \"uzuale\", 5 este pentru fișiere/convenții și 8 pentru administrare). Găsiți pagini de manual cu `apropos`. Rețineți că anumite comenzi nu sunt programe executabile ci comenzi interne în Bash și că puteți obține ajutor despre ele cu `help` sau `help -d`. Puteți vedea dacă o comandă este internă, executabilă sau doar un alias prin folosirea `type command`.\n\n- Învățați despre redirecționarea intrării și ieșirii folosind `>` și `<` și pipe-uri cu `|`. Rețineți că `>` suprascrie fișierul și `>>` adaugă la final. Învățați despre ieșirea standard și ieșirea de eroare standard.\n\n- Învățați despre expandarea numelor de fișiere cu `*` (și poate `?` și `[`...`]`) și despre folosirea și diferențele dintre `\"` și `'`. (Vedeți mai multe în secțiunea despre expandarea variabilelor mai jos).\n\n- Familiarizați-vă cu managementul job-urilor în Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Învățați `ssh`, și bazele autentificării fără parolă, via `ssh-agent`, `ssh-add`, etc.\n\n- Managementul de bază al fișierelor: `ls` și `ls -l` (în special, învățați ce reprezintă fiecare coloană din `ls -l`), `less`, `head`, `tail` și `tail -f` (sau, mai bine, `less +F`), `ln` și `ln -s` (aprofundați diferențele și avantajele între link-urile hard și cele soft), `chown`, `chmod`, `du` (scurt sumar de folosire: `du -hs *`). Pentru managementul sistemului de fișiere: `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Învățați ce este un inode (`ls -i` sau `df -i`).\n\n- Concepte de bază de rețea: `ip` sau `ifconfig`, `dig`.\n\n- Învățați și folosiți un sistem de versionare, precum `git`.\n\n- Învățați expresii regulare foarte bine, precum și diversele opțiuni pentru `grep`/`egrep`. Relevante sunt `-i`, `-o`, `-v`, `-A`, `-B`, și `-C`.\n\n- Învățați să folosiți `apt-get`, `yum`, `dnf` sau `pacman` (în funcție de distribuție) pentru a găsi și instala pachete. Fiți siguri că aveți `pip` pentru a instala comenzile bazate pe Python (câteva din utilitarele de mai jos sunt mai ușor de instalat cu `pip`).\n\n\n## Folosire zilnică\n\n- În Bash, folosiți **Tab** pentru a completa argumente sau a lista comenzile disponibile și **ctrl-r** pentru a căuta în istoricul comenzilor (după apăsare, tastați ce căutați și apăsați repetat **ctrl-r** pentru a cicla prin lista de potriviri, apăsați **Enter** pentru a executa comanda găsită sau săgeată dreapta pentru a putea edita linia curentă).\n\n- În Bash, folosiți **ctrl-w** pentru a șterge ultimul cuvânt și **ctrl-u** pentru a șterge până la începutul liniei. Folosiți **alt-b** și **alt-f** pentru a naviga cuvânt-cu-cuvânt, **ctrl-a**  pentru a muta cursorul la începutul liniei,  **ctrl-e** pentru a-l muta la final, **ctrl-k** pentru a șterge până la finalul liniei, **ctrl-l** pentru a curăța tot ecranul. Vizualizați `man readline` pentru a vedea toate tastele implicite din Bash. Sunt o mulțime. De exemplu, **alt-.** ciclează prin toate argumentele anterioare și **alt-*** expandează un glob pattern.\n\n\n- Alternativ, dacă doriți să folosiți tastele ca în vi, folosiți `set -o vi` (și `set -o emacs` pentru a vă întoarce).\n\n- Pentru a edita comenzi lungi, după setarea editorului (de exemplu `export EDITOR=vim`), **ctrl-x** **ctrl-e** va deschide un editor cu comanda curentă pentru editare. În stilul vi puteți folosi **escape-v**.\n\n- Comenzile recente le găsiți folosind `history`. Dacă folosiți `!n` (unde `n` este numărul comenzii) atunci o veți executa din nou. Sunt mai multe scurtături pe care le puteți folosi, foarte utile fiind `!$` pentru ultimul argument și `!!` pentru ultima comandă (vedeți \"HISTORY EXPANSION\" în manual). Acestea pot fi înlocuite ușor cu **ctrl-r** și **alt-.**.\n\n- Navigați către directorul personal cu `cd`. Accesați fișiere relative la acest director cu prefixul `~` (e.g. `~/.bashrc`). În scripturile `sh`, referiți-vă la directorul personal cu `$HOME`.\n\n- Pentru a ajunge înapoi în directorul anterior: `cd -`.\n\n- Dacă sunteți în mijlocul editării unei comenzi dar vreți să renunțați, folosiți **alt-#** pentru a adăuga un `#` la început și a o introduce ca un comentariu (alternativ, **ctrl-a**, **#**, **enter**). Vă puteți întoarce la comandă mai târziu, folosind istoria comenzilor.\n\n- Folosiți `xargs` (sau `parallel`). Este foarte puternic. Puteți controla câte comenzi execută pe o linie (`-L`) și paralelismul (`-L`). Dacă nu sunteți siguri că ați dat comanda corectă, folosiți întâi `xargs echo`. De asemenea, `-I{}` este foarte ultil. Exemple:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` este o modalitate ușoară de a afișa lista de procese\n\n- Folosiți `pgrep` și `pkill` pentru a găsi și semnala procesele după nume (`-f` poate fi util).\n\n- Învățați ce semnale pot fi trimise proceselor. De exemplu, pentru a suspenda un proces puteți folosi `kill -STOP [pid]`. Pentru a obține lista completă, vedeți `man 7 signal`.\n\n- Folosiți `nohup` sau `disown` dacă doriți să trimiteți un proces în fundal sau să-l mențineți rulând permanent.\n\n- Verificați ce procese ascultă pe rețea folosind `netstat -lntp` sau `ss -plat` (pentru TCP; adăugați `-u` pentru UDP).\n\n- Vedeți `lsof` pentru fișiere și socket-uri deschise.\n\n- Vedeți `uptime` sau `w` pentru a afla cât timp sistemul a fost funcțional.\n\n- Folosiți `alias` pentru a crea scurtături pentru comenzile folosie des. De exemplu, `alias ll='ls -latr'` creează un nou alias `ll`.\n\n- Salvați alias-uri, setări shell, și funcții folosite frecvent în `~/.bashrc`, și [instruiți shell-ul de login să-l citească](http://superuser.com/a/183980/7106). Asftel, veți avea aceleași setări în toate terminalele.\n\n- Salvați setările variabilelor de mediu și comenzile care ar trebui executate la login în `~/.bash_profile`. Configurări separate sunt necesare pentru shell-uri lansate prin logarea în mediul grafic sau din task-uri `cron`.\n\n- Sincronizați fișierele de configurare (e.g. `.bashrc` and `.bash_profile`) între mai multe calculatoare folosind Git.\n\n- Tratați cu atenție cazurile când variabilele și fișierele conțin spații. Folosiți ghilimele în acest caz, de exemplu `\"$FOO\"`. Preferați să folosiți opțiunile `-0` sau `-print0` pentru a folosi caracterul null pentru a delimita fișierele, de exemplu `locate -0 pattern | xargs -0 ls -al` sau `find / -print0 -type d | xargs -0 ls -al`. Pentru a parcurge o listă de fișiere conținând spații într-o buclă for, setați variabile IFS la terminatorul de linie, `IFS=$'\\n'`.\n\n- În scripturile Bash, folosiți `set -x` (sau varianta `set -v`, care produce informație neprocesată, inclusiv variabile neexpandate și comentarii) pentru a depana outputul. Folosiți modurile strice exceptând când aveți un motiv foarte bun împotrivă: folosiți `set -e` pentru a termina execuția în caz de eroare (cod de ieșire nenul). Folosiți `set -u` pentru a detecta variabile nesetate. Considerați folosirea `set -o pipefail` pentru erorile cauzate de folosirea eronată a pipe-urilor. Pentru scripturi mai complicate, folosiți `trap` pentru EXIT sau ERR. Un obicei util este să începeți scriptul într-o modalitate care va permite detecția facilă a erorilor și terminarea execuției cu un mesaj:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- În scripturile Bash, subshell-urile (delimitate de paranteze) sunt un mod convenabil pentru a grupa comenzi. De exemplu, va puteți muta într-un alt director:\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- În Bash, există mai multe variante de expandare a variabilelor. Verifacți dacă o variabilă există: `${name:?error message}`. De exemplu, dacă un script necesită un argument unic, folosiți `input_file=${1:?usage: $0 input_file}`. Folosți o valoare implicită pentru cazul când o variabilă este goală: `${name:-default}`. Pentru parametri opționali în exemplul anterior, folosiți `output_file=${2:-logfile}`. Dacă `$2` este omis (gol), `output_file` va fi setat la `logfile`. Expandare aritmetică: `i=$(( (i + 1) % 5 ))`. Secvențe: `{1..10}`. Tăierea unor secvențe din șiruri: `${var%suffix}` și `${var#prefix}`. De exemplu, dacă `var=foo.pdf`, atunci `echo ${var%.pdf}.txt` va scrie `foo.txt`.\n\n- Expandarea parantezelor folosind `{`...`}` previne re-tastarea textelor similare, automatizând combinațiile de elemente. Este util în exemple precum `mv foo.{txt,pdf} some-dir` (care mută ambele fișiere), `cp somefile{,.bak}` (care se expandează la `cp somefile somefile.bak`) sau `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (care expandează toate combinațiile posibile și creează arborele de directoare).\n\n- Outputul unei comenzi poate fi tratat ca un fișier cu `<(some command)`. De exemplu, pentru a compara fișierul `/etc/hosts` local cu unul la distanță:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Când scrieți cod, puteți prefera să încadrați tot codul în acolade. Dacă acolada de final lipsește, scriptul nu va rula. Este un lucru util, în special pentru scripturile de pe web pentru că previne execuția scripturilor parțial descărcate:\n```bash\n{\n      # Your code here\n}\n```\n\n- Folosiți \"here documents\", de exemplu `cat <<EOF ...`.\n\n- În Bash, redirecționați ieșirea standard și eroarea standard cu `some-command >logfile 2>&1` sau `some-command &>logfile`. De regulă, pentru a vă asigura că o comandă nu lasă un fișier deschis, fiind legată de terminalul curent, este o practică bună să adăugați `</dev/null`.\n\n- Folosiți `man ascii` pentru o tabelă ASCII foarte bună, cu valori în hex și decimal. Pentru informatii generale de codificare,  `man unicode`, `man utf-8`, și `man latin1` sunt utile.\n\n- Folosiți `screen` sau [`tmux`](https://tmux.github.io/) pentru a multiplexa terminalul, în special în cazul sesiunilor ssh. `byobu` poate îmbunătăți screen sau tmux fiind mai ușor de folosit. O interfață minimală pentru persistența sesiunilor este [`dtach`](https://github.com/bogner/dtach).\n\n- În ssh, este util să știți cum să creați un tunel cu `-L` sau `-D` (și ocazional `-R`), e.g. pentru a accesa site-urile de pe un server aflat la distanță.\n\n- Este foarte util să optimizați configurațiile ssh, de exemplu, setarea următoare din `~/.ssh/config` permite prevenirea sesiunilor eșuate în anumite condiții de rețea, folosește compresia (utilă pentru `scp` sau conexiuni peste rețele cu lățime de bandă redusă) și multiplexează canale către același server folosind un fișier de control local:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Un număr de alte opțiuni sunt relevante pentru securitate și trebuiesc tratate cu atenție, de exemplu, setări pe rețea sau mașină: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Considerați folosirea [`mosh`](https://mosh.org/) ca o alternativă la ssh care folosește UDP, prevenind conexiunile eșuate (necesită setări pe partea de server).\n\n- Pentru a obține permisiunile unui fișier în forma octală, lucru util pentru configurarea sistemului, dar nedisponibil în `ls`, folosiți ceva precum:\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Pentru selecția interactivă a valorilor dintr-o altă comandă, folosiți [`percol`](https://github.com/mooz/percol) sau [`fzf`](https://github.com/junegunn/fzf).\n\n- Pentru interacțiunea cu fișiere rezultate din outputul unei alte comenzi (like `git`), folosiți `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Un simplu server web pentru fișierele din directorul curent și subdirectoare, disponibil pentru toți din rețeaua dumneavoastră, folosiți\n`python -m SimpleHTTPServer 7777` (pentru port 7777 și Python 2) și `python -m http.server 7777` (pentru port 7777 și Python 3).\n\n- Puteți rula o comandă ca un alt utilizator folosind `sudo`. Implicit se va rula ca root, folosiți `-u` pentru a specifica utilizatorul. Folosiți `-i` pentru a vă loga ca acel utilizator, folosind parola _voastră_.\n\n- Pentru a schimba tot shellul către alt utilizator, folosiți `su utilizator` sau `su - utilizator`. Versiunea cu `-` obține și mediul, ca si cum utilizatorul tocmai s-a logat. Username-ul implicit este root. Veți fi întrebat parola _utilizatorului către care faceți schimbarea_.\n\n- Amintiți-vă că orice linie de comandă are o limită de [128K](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong). Eroarea \"Argument list too long\" (listă de argumente prea lungă) este comună dacă un număr mare de fișiere se potrivesc unui șablon. (În acest caz, alternative precum `find` și `xargs` ajută.)\n\n- Un calculator simplu poate fi accesat utilizând `python`. De exemplu:\n```\n>>> 2+3\n5\n```\n\n\n## Procesarea fișierelor și a datelor\n\n- Pentru a localiza un fișier după nume, în directorul curent, `find . -iname '*something*'` (sau similar). Pentru a găsi un fișier oriunde, `locate something` (dar țineți cont de faptul că `updatedb` s-ar putea să nu fi indexat fișierele recente).\n\n- Pentru a căuta în interiorul fișierelor (mai avansat decât `grep -r`), folosiți [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Pentru a converti HTML la text: `lynx -dump -stdin`\n\n- Pentru Markdown, HTML, și alte conversii de documente, folosiți [`pandoc`](http://pandoc.org/).\n\n- Dacă trebuie să folosiți XML, `xmlstarlet` e vechi dar util.\n\n- Pentru JSON, folosiți [`jq`](http://stedolan.github.io/jq/).\n\n- Pentru YAML, folosiți [`shyaml`](https://github.com/0k/shyaml).\n\n- Pentru Excel sau CSV files, [csvkit](https://github.com/onyxfish/csvkit) oferă `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.\n\n- Pentru Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) este ușor de folosit și [`s4cmd`](https://github.com/bloomreach/s4cmd) este mai rapid. [`aws`](https://github.com/aws/aws-cli) de la Amazon și varianta îmbunătățită [`saws`](https://github.com/donnemartin/saws) sunt esențiale pentru alte task-uri legate de AWS.\n\n- Învățați `sort` și `uniq`, inclusiv opțiunile `-u` și `-d` pentru `uniq` -- mai multe exemple în secțiunea de comenzi de o linie, mai jos. Vedeți și `comm`.\n\n- Aflați despre `cut`, `paste`, și `join` pentru a manipula fișiere text. Mulți oameni folosesc `cut` dar uită de `join`.\n\n- Informați-vă despre `wc` pentru a număra liniile (`-l`), caracterele (`-m`), cuvintele (`-w`) și octeții (`-c`) dintr-un fișier.\n\n- Folosți `tee` pentru a copia de la intrarea standard (stdin) într-un fișier și la ieșirea standard (stdout) simultan, ca în `ls -al | tee file.txt`.\n\n- Pentru operații mai complexe, inclusiv grupare, inversare de câmpuri și statistică, considerați folosirea [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Țineți minte că localizarea (`locale`) influențează foarte multe comenzi în moduri subtile, inclusiv sortare sau performanță. Majoritatea instalărilor Linux setează `LANG` și alte variabile de localizare la o setare precum US English. Sortarea se va schimba dacă schimbați localizare. De asemenea, rutinele de internaționalizare (i18n) pot face comenzile să se execute *mult, mult* mai încet. În unele situații (precum operațiile pe mulțimi de mai jos), puteți ignora rutinele încete de la i18n și folosi sortarea bazată pe octeți, folosind `export LC_ALL=C`.\n\n- Puteți seta localizarea specifică unei comenzi prin prefixarea acesteia cu variabila de mediu corespunzătoare, ca în `TZ=Pacific/Fiji date`.\n\n- Pentru procesare de bază a textelor, folosiți `awk` și `sed`. De exemplu, pentru a aduna suma numerelor din coloana a treia a unui fișier `awk '{ x += $3 } END { print x }'` este de 3 ori mai rapid și mai scurt decât codul echivalent în Python.\n\n- Pentru a înlocui toate aparițiile unui șir, în cel puțin un fișier:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Pentru a redenumi fișiere multiple și/sau căuta în fișiere încercați [`repren`](https://github.com/jlevy/repren). (În  unele cazuri, comanda `rename` permite redenumiri multiple, dar țineți cont că funcționalitatea ei nu este aceeași în toate distribuțiile Linux)\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- După cum zice și pagina de manual, `rsync` este un utilitar foarte rapid, eficient și versatil de a copia fișiere. Este cunoscut pentru sincronizarea între calculatoare dar poate fi folosit și local. Dacă setările de securitate permit, folosirea `rsync` în loc de `scp` permite continuarea unui transfer eșuat fără a-l reporni. Este și una dintre cele [mai rapide metode](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) de a șterge un număr masiv de fișiere:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Folosiți `shuf` pentru a permuta sau selecta linii aleatoare dintr-un fișier.\n\n- Învățați opțiunile lui `sort`. Pentru numere folosiți `-n`, sau `-h` pentru numere în format human-readable (de exemplu numere produse de `du -h`). Învățați cum funcționează cheile de sortare (`-t` și `-k`). În special, țineți cont că trebuie să scrieți `-k1,1` pentru a sorta doar prima coloană, `-k1` înseamnă sortare după toată linia. Sortarea stabilă (`sort -s`) poate fi utilă. De exemplu, pentru a sorta după câmpul 2 și apoi după 1: `sort -k1,1 | sort -s -k2,2`.\n\n- Dacă sunteți nevoiți să scrieți un caracter tab în terminal (de exemplu pentru argumentul `-t` al `sort`) apăsați **ctrl-v** **[Tab]** sau scrieți `$'\\t'` (ultima versiune e mai bună pentru că permite și copy/paste).\n\n- Utilitarele standard pentru patch-uirea codului sunt `diff` și `patch`. De asemenea `diffstat` poate fi folosit pentru sumarizarea unui diff și `sdiff` pentru un diff side-by-side. Țineți cont că `diff -r` operează pe directoare întregi. Folosiți `diff -r tree1 tree2 | diffstat` pentru un sumar al modificărilor. Folosiți `vimdiff` pentru a compara și edita fișiere.\n\n- Pentru fișiere binare, folosiți `hd`, `hexdump` sau `xxd` pentru operații simple și `bvi` sau `biew` pentru editare binară\n\n- Tot pentru fișiere binare, `strings` (plus `grep`, etc.) permite găsirea bucăților de text.\n\n- Pentru diff-uri binare (compresie delta), folosiți `xdelta3`.\n\n- Pentru a converti codificarea textului, folosiți `iconv` sau `uconv` pentru utilizări mai avansate. Ambele suportă același set de Unicode. De exemplu, comanda următoare transformă în minuscule și elimină accentele (prin expandare sau coborâre):\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Pentru a împărți un text în fragmente, folosiți `split` (după dimensiune) și `csplit` (după un șablon).\n\n- Folosiți `dateadd`, `datediff`, `strptime` etc. din [`dateutils`](http://www.fresse.org/dateutils/) pentru a manipula expresii legate de timp, dată și oră.\n\n- Pentru a opera pe fișiere comprimate: `zless`, `zmore`, `zcat`, and `zgrep`\n\n- Atributele fișierelor pot fi stabilite cu `chattr` și oferă o alternativă de nivel scăzut la permisiunile unui fișier. De exemplu, pentru a vă proteja împotriva ștergerii accidentale puteți folosi flag-ul immutable: `sudo chattr +i /critical/directory/or/file`\n\n- Folosiți `getfacl` și `setfacl` pentru a salva și restaura permisiunile unui fișier. De exemplu:\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n## Depanarea sistemului\n\n- Pentru depanarea problemelor legate de internet/web, `curl` și `curl -I` sunt foarte utile, la fel și echivalentele bazate pe `wget` sau pe modernul [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Pentru a vedea starea curentă a CPU-ului sau discului, instrumentele clasice sunt `top` (mai bine `htop`), `iostat`, și `iotop`. Folosiți `iostat -mxz 15` pentru informații de bază despre CPU și detaliate depsre partițiile fiecărui disc, împreună cu sfaturi pentru îmbunătățirea performanței.\n\n- Pentru detalii legate de conexiunile la rețea, folosiți `netstat` și `ss`.\n\n- O vedere de ansamblu a sistemului poate fi obținută folosind `dstat`. Pentru detalii, folosiți [`glances`](https://github.com/nicolargo/glances).\n\n- Pentru a vedea starea curentă a memoriei, folosiți și analizați rezultatele `free` și `vmstat`. În particular, țineți cont că valoarea \"cached\" este memorie reținută de Linux ca un spațiu cache pentru fișiere, deci este efectiv spațiu \"liber\".\n\n- Depanarea sistemului Java este deosebită dar un truc simplu pe anumite JVM-uri (inclusiv Oracle) este că puteți rula `kill -3 <pid>` și veți obține un stack trace complet și informații despre memoria heap, inclusiv detalii despre garbage collector. Utilitarele `jps`, `jstat`, `jstack`, `jmap` din JDK pot fi utile. [Utilitarele SJK](https://github.com/aragozin/jvm-tools) sunt mai avansate.\n\n- Folosiți [`mtr`](http://www.bitwizard.nl/mtr/) ca un `traceroute` mai bun pentru a identifica problemele de rețea.\n\n- Pentru a identifica de ce un disc este plin, [`ncdu`](https://dev.yorhel.nl/ncdu) salvează timp comparativ cu folosirea comenzilor uzuale precum `du -sh *`.\n\n- Pentru a identifica socket-ul sau procesul care consumă cea mai mare bandă din rețea folosiți [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) sau [`nethogs`](https://github.com/raboof/nethogs).\n\n- Utilitarul `ab` (vine cu Apache) este util pentru a testa rapid performanța serverului web. Pentru testare mai complexă folosiți `siege`.\n\n- Pentru depanarea și mai serioasă a rețelei folosiți [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), sau [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Învățați despre `strace` și `ltrace`. Aceste utilitare sunt utile dacă un program eșuează, se blochează sau crapă și nu știți de ce, sau dacă vreți să obțineți detalii generale despre performanță. Evidențiem opțiunea de profiling (`-c`), și abilitatea de atașare la un proces care rulează (`-p`).\n\n- Folosiți `ldd` pentru a verifica bibliotecile dinamice, etc.\n\n- Folosiți `gdb` pentru a vă conecta la un proces care rulează și a obține un stack trace.\n\n- Folosiți `/proc`. Este foarte util în depanarea problemelor pe viu. Exemple: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (unde `xxx` este id-ul procesului - PID-ul lui).\n\n- Pentru a depana ceva ce a fost greșit în trecut, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) poate fi foarte util. Arată statistici istorice despre CPU, memorie, rețea, etc.\n\n- Pentru analize de detaliu pentru performanța sistemului, folosiți `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_(Linux)), și [`sysdig`](https://github.com/draios/sysdig).\n\n- Verificați ce sistem de operare folosiți cu `uname` sau `uname -a` (detalii generale despre nucleu) sau `lsb_release -a` (Linux distro).\n\n- Folosiți `dmesg` oricând ceva funcționează total aiurea (probabil din cauza hardware-ului sau a dispozitivelor fizice).\n\n- Dacă ștergeți un fișier și nu se eliberează cantitatea de spațiu de pe disc la care vă așteptați (conform `du`), verificați să nu cumva aveți fișierul folosit de un proces:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## Comenzi de o linie\n\nCâteva exemple de a construi comenzi complicate din comenzi simple:\n\n- Este foarte util uneori că puteți trata fișierele ca mulțimi de rânduri și puteți implementa operațiile pe mulțimi -- intersecție, reuniune și diferență -- folosind `sort`/`uniq`. Presupunând că `a` și `b` sunt fișiere text fără linii duplicate, următoarele comenzi sunt foarte rapide și procesează fișiere de dimensiuni gigantice (`sort` nu este limitat de memorie dar este preferabil să folosiți `-T` dacă `/tmp` este pe o partiție mică). De asemenea, nu uitați de nota despre `LC_ALL` (localizare) de mai sus și de opțiunea `-u` (eliminată mai jos pentru claritate):\n```sh\n      cat a b | sort | uniq > c   # c is a union b\n      cat a b | sort | uniq -d > c   # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n\n- Folosiți `grep . *` pentru a examina rapid conținutul fișierelor din director (fiecare linie este împerecheată cu fișierul din care provine) sau `head -100 *` (fiecare fișier are un header). Este un sfat util pentru directoare conținând setări precum `/sys`, `/proc`, `/etc`.\n\n\n- Suma tuturor numerelor din a 3-a coloană a unui fișier (probabil de 3 ori mai rapid și de 3 ori mai puțin cod decât codul Python echivalent):\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Pentru a vedea dimensiunile și data fiecărui fișier dintr-un arbore, metoda următoare este ca un `ls -l` recursiv dar cu un output mai clar decât `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Presupunând că aveți un fișier text, de exemplu un jurnal al unui server web, și o anumită valoare apare pe câteva linii, precum o valoare pentru parametrul `acct_id` prezent în URL, dacă doriți un sumar pentru fiecare valoare a lui `acct_id`:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Pentru a monitoriza schimbările folosiți `watch`. De exemplu, verificați schimbările dintr-un director cu `watch -d -n 2 'ls -rtlh | tail'` sau setările de rețea în timp ce depanați probleme cu conexiunea wireless: `watch -d -n 2 ifconfig`.\n\n- Folosiți această funcție pentru a obține un sfat aleator din acest document (parsează formatul Markdown și extrage un item):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Obscure dar utile\n\n- `expr`: execută operații aritmetice sau logice și expandează expresii regulate\n\n- `m4`: procesor simplu de macro-uri\n\n- `yes`: afișează un șir de un număr infinit de ori\n\n- `cal`: calendar\n\n- `env`: execută o comandă (util în scripturi)\n\n- `printenv`: afișează variabilele de mediu (util pentru depanare și scripturi)\n\n- `look`: idenfică cuvinte în engleză (sau linii de fișier) care încep cu un șir\n\n- `cut`, `paste` and `join`: manipulează date\n\n- `fmt`: formatează paragrafe de text\n\n- `pr`: formatează textul în paragrafe și coloane\n\n- `fold`: înfășoară liniile unui text\n\n- `column`: formatează textul în coloane de lungime fixă, în tabele\n\n- `expand` și `unexpand`: convertește între tab-uri și spații\n\n- `nl`: adaugă numere liniilor\n\n- `seq`: afișează numere\n\n- `bc`: calculator\n\n- `factor`: factorizează întregi\n\n- [`gpg`](https://gnupg.org/): criptează și semnează fișiere\n\n- `toe`: tabel de informații despre terminal\n\n- `nc`: depanare rețea și transfer de date\n\n- `socat`: socket relay și forwarder pentru porturi tcp (similar cu `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): vizualizează traficul de rețea\n\n- `dd`: mută datele între fișiere și device-uri\n\n- `file`: identifică tipul unui fișier\n\n- `tree`: arată un arbore de directoare și subdirectoare, ca `ls` dar recursiv\n\n- `stat`: informații despre fișier\n\n- `time`: execută și cronometrează o comandă\n\n- `timeout`: execută o comandă până la expirarea unui timp definit, omorând procesul la finalul timpului alocat\n\n- `lockfile`: creează un fișier semafor care nu poate fi șters decât cu `rm -f`\n\n- `logrotate`: rotește, comprimă și trimite jurnalele pe mail\n\n- `watch`: execută o comandă în mod repetat, arătând rezultatele și/sau evidențiind diferențele\n\n- `tac`: afișează conținutul fișierelor în ordine inversă\n\n- `shuf`: selectează linii in mod aleator din fișier\n\n- `comm`: compară fișiere sortate, linie cu linie\n\n- `pv`: monitorizează progresul datelor într-un pipe\n\n- `hd`, `hexdump`, `xxd`, `biew` și `bvi`: afișează sau editează fișiere binare\n\n- `strings`: extrage șiruri din fișiere\n\n- `tr`: translatează și manipulează caractere\n\n- `iconv` sau `uconv`: conversie între codificările posibile ale unui text\n\n- `split` și `csplit`: sparge fișiere în componente\n\n- `sponge`: citește tot inputul înainte de a-l afișa, util pentru a citi și apoi a scrie în același fișier: `grep -v something some-file | sponge some-file`\n\n- `units`: conversii între unități de măsură (vedeți și `/usr/share/units/definitions.units`)\n\n- `apg`: generateză parole aleatoare\n\n- `xz`: compresor de fișiere foarte eficient\n\n- `ldd`: informații despre bibliotecile dinamice\n\n- `nm`: simboluri din fișierele obiect\n\n- `ab`: benchmarking pentru servere web\n\n- `strace`: depanare apeluri de sistem\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): alternativă mai bună pentru `traceroute` pentru depanarea rețelei\n\n- `cssh`: shell vizual, concurent\n\n- `rsync`: sincronizează fișiere peste SSH sau local\n\n- [`wireshark`](https://wireshark.org/) și [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): capturează trafic de rețea și depanează rețeaua\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep pentru rețea\n\n- `host` și `dig`: interogări DNS\n\n- `lsof`: informații despre descriptorii de fișiere și sockeți\n\n- `dstat`: statistici utile despre sistem\n\n- [`glances`](https://github.com/nicolargo/glances): statistici utile despre sistem, la nivel înalt\n\n- `iostat`: statistici despre folosirea discului\n\n- `mpstat`: statistici despre folosirea CPU\n\n- `vmstat`: statistici despre folosirea memoriei\n\n- `htop`: versiune îmbunătățită a `top`\n\n- `last`: istoria login-urilor\n\n- `w`: cine este logged-in\n\n- `id`: informații despre utilizatori/grupuri\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): istoria statisticilor despre sistem\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) sau [`nethogs`](https://github.com/raboof/nethogs): utilizarea rețelei de fiecare socket sau proces\n\n- `ss`: statistici socket\n\n- `dmesg`: erori de sistem sau de pornirea sistemului\n\n- `sysctl`: vizualizează și configurează parametrii nucleului Linux\n\n- `hdparm`: manipulare/performanță pentru discuri SATA/ATA\n\n- `lsblk`: afișează dispozitivele block: discuri și partiții\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informații hardware, incluzând CPU, BIOs, RAID, plăci grafice, dispozitive, etc.\n\n- `lsmod` și `modinfo`: afișează module de kernel\n\n- `fortune`, `ddate`, și `sl`: depinde dacă considerați locomotive și citate \"utile\" (utilitare distractive)\n\n\n## Doar pentru OS X\n\nAceste sfaturi sunt relevante *doar* pentru OS X.\n\n- Managementul pachetelor cu `brew` (Homebrew) și/sau `port` (MacPorts). Aceste comenzi pot fi folosite pentru a instala multe din comenzile de mai sus pe un Mac.\n\n- Copiați outputul unei comenzi către aplicații desktop cu `pbcopy` și lipiți conținutul de la una cu `pbpaste`.\n\n- Pentru a mapa tasta Option în OS X Terminal ca o tastă Alt (pentru comenzile de mai sus precum **alt-b**, **alt-f**, etc.), deschideți Preferences -> Profiles -> Keyboard și selectați \"Use Option as Meta key\" (\"Folosește Option ca tastă Meta\").\n\n- Pentru a deschide un fișier cu o aplicație desktop folosiți`open` sau `open -a /Applications/Whatever.app`.\n\n- Spotlight: Găsiți fișiere cu `mdfind` și listați meta-date (de exemplu informații EXIF din fotografii) cu `mdls`.\n\n- Țineți minte că OS X este la bază un BSD Unix, și multe comenzi (de exemplu `ps`, `ls`, `tail`, `awk`, `sed`) au un număr de variațiuni subtile comparativ cu Linux, un fapt influențat de diferențele între System V-style Unix și utilitarele GNU. Puteți vedea diferențele observând dacă pagina de manual are antetul \"BSD General Commands Manual\" (\"Manual de comenzi generale BSD\").  În unele cazuri, versiunile GNU pot fi instalate în paralel (precum `gawk` și `gsed` pentru GNU awk și sed). În scrierea de aplicații independente de platformă, evitați aceste comenzi (de exemplu folosiți Python sau `perl`) sau testați cu atenție.\n\n- Informații despre versiunea OS X se pot obține cu `sw_vers`.\n\n## Doar pentru Windows\n\nAceste sfaturi sunt relevante *doar* pentru Windows.\n\n- În Windows 10, puteți folosi [Bash în Ubuntu în Windows](https://msdn.microsoft.com/commandline/wsl/about), pentru a obține mediul Bash familiar cu comenzile și utilitățile Unix descrise anterior. Ca bonus, acest lucru permite ca programele Linux să ruleze pe Windows. Pe de altă parte, nu puteți rula programe Windows din prompt-ul Bash.\n\n- Puteți accesa shell-ul Unix sub Windows prin instalarea [Cygwin](https://cygwin.com/). Multe din lucrurile descrise aici vor funcționa implicit.\n\n- Programele Unix adiționale se vor instala cu managerul de pachete al lui Cygwin.\n\n- Folosiți `mintty` ca fereastra de comenzi.\n\n- Accesați clipboard-ul Windows prin intermediul `dev/clipboard`.\n\n- Folosiți `cygstart` pentru a deschide un fișier arbitrar cu aplicația corespunzătoare\n\n- Accesați registrele Windows cu `regtool`.\n\n- Observați că o cale de tip `C:\\` în Windows devine `/cygdrive/c` sub Cygwin, și că root-ul Cygwin, `/`, apare ca `C:\\cygwin` pe Windows. Convertiți între căile Cygwin și Windows cu `cygpath`. Acest lucru este util în scripturile care apelează programe Windows.\n\n- Puteți executa majoritatea task-urilor de administrare a sistemului Windows din linia de comandă prin învățarea și folosirea `wmic`.\n\n- O altă opțiune de a obține un sistem similar Unix sub Windows este [Cash](https://github.com/dthree/cash). Țineți cont că doar câte utilitare Unix sunt în prezent disponibile în acest mediu.\n\n- O altă opțiune alternativă este să obțineți instrumentele de dezvoltare GNU (precum GCC) cu [MinGW](http://www.mingw.org/) și pachetul [MSYS](http://www.mingw.org/wiki/msys). Astfel veți obtine utilitare precum `bash`, `gawk`, `make` și `grep`. MSYS nu are toate beneficiile Cygwin dar este util în particular pentru a crea versiuni de Windows pentru instrumentele Unix.\n\n## Mai multe resurse\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): O listă detaliată a instrumentelor și resurselor pentru shell.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Un ghid mai detaliat pentru folosirea liniei de comandă sub OS X\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) pentru a scrie scripturi mai bune..\n- [shellcheck](https://github.com/koalaman/shellcheck): Un utilitar pentru analiza statică a scripturilor. În esență, `lint` pentru bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Detalii complete despre situația tristă în folosirea căilor către fișiere corect în scripturi independente de platformă\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Mai multe comenzi și utilitare disponibile pentru analiza datelor, după cartea cu același nume.\n\n## Anunț legal\n\nCu excepția unor task-uri foarte mici, codul scris aici este pentru ca alții să-l poate citi. Cu putere vine și responsabilitate. Faptul că *puteți* face ceva în Bash nu înseamnă neapărat că și trebuie să-l faceți ;)\n\n\n## Licență\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nAceastă muncă este licențiată sub [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-ru.md",
          "type": "blob",
          "size": 59.74,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# Искусство командной строки\n\n[![Вступайте в англоязычный чат проекта https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [Описание](#Описание)\n- [Основы](#Основы)\n- [Ежедневное использование](#Ежедневное-использование)\n- [Обработка файлов и информации](#Обработка-файлов-и-информации)\n- [Отладка системы](#Отладка-системы)\n- [В одну строчку](#В-одну-строчку)\n- [Сложно, но полезно](#Сложно-но-полезно)\n- [OS X only](#os-x-only)\n- [Windows only](#windows-only)\n- [Больше информации по теме](#Больше-информации-по-теме)\n- [Дисклеймер](#Дисклеймер)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nПродвинутому использованию командной строки зачастую не уделяют достаточного внимания. О терминале говорят как о чем-то мистическом. На самом же деле, это умение очевидно (и не очевидно) увеличивает Вашу продуктивность в работе. Данный документ является подборкой заметок и советов, которые я нашел для себя полезными, работая с командной строкой в Linux. Некоторые из них – простые и очевидные, но некоторые - довольно сложные. И предназначены для решения конкретных задач. Это небольшая публикация, но если Вы уже знаете обо всем, что тут написано, и можете вспомнить, как это все использовать – вы много знаете!\n\nЭтот гайд является результатом работы [большого числа авторов и переводчиков](AUTHORS.md)\nМногое из того, что тут написано,\n[изначально](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[появилось](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nна [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nначав идею там, похоже, что стоит развить ее на Github, где обитают люди, которые талантливее меня и могут предлагать улучшения данной подборки. Если Вы заметили ошибки (во всех вариантах перевода), пожалуйста\n[**оставьте тикет или добавьте пулл-реквест**](CONTRIBUTING.md) (заранее изучив описание и посмотрев на уже созданнные тикеты и пулл-реквесты).\n\n## Описание\n\nОсновное:\n\n- Данная публикация предназначена как для новичков, так и для опытных людей. Цели: *объемность* (собрать все важные аспекты использования командной строки), *практичность* (давать конкретные примеры для самых частых юзкейсов) и *краткость* (не стоит углубляться в неочевидные вещи, о которых можно почитать в другом месте).\n- Этот документ написан для пользователей Linux, за исключеним секций \"[OS X only](#os-x-only)\" и \"[Windows only](#windows-only)\". Все остальное подходит и может быть установлено под все UNIX/OS X системы (и даже Cygwin).\n- Фокусируемся на интерактивном Баше, но многие вещи также могут быть использованы с другими шеллами; и в общем применимы к Баш-скриптингу.\n- Эта инструкция включает в себя стандартные Unix команды и те, для которых нужно устанавливать сторонние пакеты. Они настолько полезны, что стоят того, чтобы их установили.\n\nЗаметки:\n\n- Для того, чтобы руководство оставалось одностраничным, вся информация вставлена прямо сюда. Вы достаточно умные для того, чтобы самостоятельно изучить вопрос более детально в другом месте. Используйте `apt-get`, `yum`, `dnf`, `pacman`, `pip` или `brew` (в зависимости от вашей системы управления пакетами) для установки новых программ.\n- На [Explainshell](http://explainshell.com/) можно найти простое и подробное объяснение того, что такое команды, флаги, пайпы и т.д.\n\n\n## Основы\n\n- Выучите основы Баша. Просто возьмите и напечатайте `man bash` в терминале и хотя бы просмотрите его; он довольно просто читается и он не очень большой. Другие шеллы тоже могут быть хороши, но Баш – мощная программа, и Баш всегда под рукой (использование *исключительно* zsh, fish и т.д., которые наверняка круто выглядят на Вашем ноутбуке, во многом Вас ограничивает, например, Вы не сможете использовать возможности этих шеллов на уже существующем сервере).\n\n- Выучите как использовать хотя бы один консольный редактор текста. Идеально Vim (`vi`), ведь у него нет конкурентов, когда вам нужно быстренько что-то подправить (даже если Вы постоянно сидите на Emacs/какой-нибудь тяжелой IDE или на каком-нибудь модном хипстерском редакторе).\n\n- Знайте как читать документацию через `man` (для любознательных – `man man`; `man` по углам документа в скобках добавляет номер, например: 1 – для обычных команд, 5 – для файлов, конвенций, 8 – для административных команд). Ищите мануалы через `apropos`, и помните, что некоторые команды – не бинарники, а встроенные команды Баша, и помощь по ним можно получить через `help` и `help -d`. С помощью `type command` можно определить, чем является команда - исполняемым файлом, алиасом или встроенной командой шелла.\n\n- Узнайте о том, как перенаправлять ввод и вывод через `>` и `<` и пайпы `|`. Помните, что `>` переписывает выходной файл, а `>>` дописывает в конец. Узнайте побольше про stdout и stderr.\n\n- Узнайте побольше про раскрытие file glob элементов `*` (а также `?` и `{`...`}`), кавычки, а также разницу между двойными `\"` и одинарными `'` кавычками (больше о расширении переменных читайте ниже).\n\n- Освойте управление процессами в Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill` и т.д.\n\n- Знайте `ssh` и основы беспарольной аутентификации через `ssh-agent`, `ssh-add` и т.д.\n\n- Основы работы с файлами: `ls` и `ls -l` (в частности, узнайте, что значит каждый столбец в  `ls -l`), `less`, `head`, `tail` и `tail -f` (или даже лучше – `less +F`), `ln` и `ln -s` (узнайте разницу между символьными ссылками и жёсткими ссылками, и почему жёсткие ссылки лучше), `chown`, `chmod`, `du` (для быстрой сводки по использованию диска: `du -hk *`). Для менеджмента файловой системы, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Узнайте что такое inodes (`ls -i` или `df -i`).\n\n- Основы работы с сетью: `ip` или `ifconfig`, `dig`.\n\n- Освойте работу с системой контроля версий, например, `git`.\n\n- Хорошо знайте регулярные выражения и разные флаги к `grep`/`egrep`. Такие флаги, как `-i`, `-o`, `-v`, `-A`, `-B` и `-C` стоит знать.\n\n- Обучитесь использованию систем управления пакетами `apt-get`, `yum`, `dnf` или `pacman` (в зависимости от дистрибутива), чтобы искать и устанавливать пакеты и обязательно имейте установленым `pip` для установки командных утилит, написанных на Python (некоторые из тех, что вы найдёте ниже, легче всего установить через `pip`).\n\n\n## Ежедневное использование\n\n- Используйте таб в Баше для автодополнения аргументов к командам и **ctrl-r** для поиска по истории командной строки (после нажатия введите запрос, нажмите **ctrl-r** снова, чтобы найти следующее совпадение, нажмите **Enter** для выполнения текущей найденной команды или стрелку вправо, чтобы отредактировать команду).\n\n- Используйте **ctrl-w** в Баше для того, чтобы удалить последнее слово в команде; **ctrl-u** для того, чтобы удалить команду полностью. Используйте **alt-b** и **alt-f** для того, чтобы бегать между словами команды, **ctrl-a** и **ctrl-e** для того, чтобы переместиться к началу и концу строки соответственно, **ctrl-k** для того, чтобы удалить часть команды от текущей позиции до конца строки, **ctrl-l** для того, чтобы очистить экран. Гляньте на `man readline`, чтобы узнать о всех клавиатурных сочетаниях Баша. Их много! Например, **alt-.** бежит по предыдущим аргументам команды, а **alt-*** раскрывает глоб (globbing).\n\n\n- Если Вам нравятся клавиатурные сочетания vim, сделайте `set -o vi` (и `set -o emacs`, чтобы вернуться обратно).\n\n- Для редактирования длинных команд после установки другого редактора (например `export EDITOR=vim`), нажатие **ctrl-x** **ctrl-e** откроет текущую команду в редакторе для многострочного редактирования. Или, как в vi, **escape-v**.\n\n- Для просмотра последних команд используйте `history`. Повторить команду: `!n` (где `n` - порядковый номер истории). Также есть много сокращений, например, `!$` (последний аргумент) и `!!` (последняя команда) (сверьтесь со страницей man \"HISTORY EXPANSION\"). Впрочем, их часто проще  заменить с помощью **ctrl-r** и **alt-.**.\n\n- Перейти в домашнюю директорию можно с помощью `cd`. Для указания пути к файлам из домашней директории можно воспользоваться префиксом `~` (например, `~/.bashrc`). В `sh` скриптах для обращения к домашней директории можно использовать переменную `$HOME`.\n\n- Для того, чтобы перейти к предыдущей рабочей директории, используйте `cd -`.\n\n- Если вы написали команду наполовину и вдруг передумали, нажмите **alt-#** для того, чтобы добавить `#` к началу, и отправьте команду как комментарий (или используйте **ctrl-a**, **#**, **enter**). Потом вы сможете вернуться к ней через историю.\n\n- Не забывайте использовать `xargs` (или `parallel`). Это очень мощная штука. Обратите внимание, что вы можете контролировать количество команд на каждую строку (`-L`), а также параллельность (`-P`). Если вы не уверены, что делаете что-то правильно, начните с `xargs echo`. Еще `-I{}` – полезная штука. Примеры:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n\n- `pstree -p` – полезный тип вывода дерева процессов.\n\n- Используйте `pgrep` или `pkill` для того, чтобы находить/слать сигналы к процессам по имени (`-f` помогает).\n\n- Знайте разные сигналы, которые можно слать процессам. Например, чтобы приостановить процесс, используйте `kill -STOP [pid]`. Для полного списка посмотрите `man 7 signal`.\n\n- Используйте `nohup` или `disown`, чтобы процесс в фоне выполнялся бесконечно.\n\n- Узнайте, какие процессы слушают порты через `netstat -lntp` или `ss -plat` (для TCP; добавьте `-u` для UDP).\n\n- Используйте `lsof` для того, чтобы посмотреть открытые сокеты и файлы.\n\n- Используйте `uptime` или `w` для того, чтобы узнать продолжительность работы системы.\n\n- Используйте `alias`, чтобы поименовать часто используемые команды. Например, `alias ll='ls -latr'` создаст новое сокращение `ll`.\n\n- Сохраняйте псевдонимы (aliases), настройки оболочки и часто используемые сокращения в `~/.bashrc`, и [организуйте их подгрузку](http://superuser.com/a/183980/7106). Это сделает ваши настройки доступными во всех сессиях оболочки.\n\n- Пропишите настройки переменных окружения и команды, которые должны быть выполнены при входе в систему в файл `~/.bash_profile`. Отдельная настройка будет необходима для оболочек, которые запускаются из GUI и `cron`.\n\n- Синхронизируйте ваши конфигурационные файлы (например, `.bashrc` и `.bash_profile`) между разными компьютерами с помощью Git.\n\n- Помните, что необходима осторожность при работе с переменными, которые содержат пробелы. Оберните свои переменные в кавычки, например `\"$FOO\"`. Предпочтительно использовать `-0` или `-print0` флаги, чтобы использовать нулевой символ для разделения имен файлов, например: `locate -0 pattern | xargs -0 ls -al` или `find / -print0 -type d | xargs -0 ls -al`. Для циклов, которые используют имена файлов, содержащие пробелы, установите IFS чтобы символом новой строки был только `\\n`:`IFS=$'\\n'`.\n\n- В Баш-скриптах используйте `set -x` (или вариант `set -v`, который логгирует сырой ввод, включая нераскрытые переменные и комментарии) для того, чтобы отлаживать вывод (output). Используйте строгие режимы везде, где возможно. Используйте `set -e` для того, чтобы прекращать выполнение при ошибках (ненулевой код возврата). Используйте `set -u`, чтобы определять использование неинициализированных переменных. Используйте `set -o pipefail` для того, чтобы строго относиться к ошибкам (это немного глубокая тема). Для более сложных скриптов также используйте `trap` на EXIT или ERR. Полезная привычка - начинать скрипт примерно так (это поможет обнаружить ошибки и выведет предупреждение):\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- В Баш-скриптах подоболочки (subshells) – удобный способ группировать команды. Один из самых распространенных примеров – временно передвинуться в другую рабочую директорию, вот так:\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- В Баше много типов пространства переменных. Проверить, существует ли переменная – `${name:?error message}`. Например, если Баш-скрипту нужен всего один аргумент, просто напишите `input_file=${1:?usage: $0 input_file}`. Арифметическая область видимости: `i=$(( (i + 1) % 5 ))`. Последовательности: `{1..10}`. Обрезка строк: `${var%suffix}` и `${var#prefix}`. Например, если `var=foo.pdf` тогда `echo ${var%.pdf}.txt` выведет `foo.txt`.\n\n- Использование скобок `{...}` может уменьшить необходиость повторно вводить схожий текст и автоматизирует комбинирование элементов. Это полезно, например, здесь: `mv foo.{txt,pdf} some-dir` (переместит оба файла), `cp somefile{,.bak}` (приведется к `cp somefile somefile.bak`) или `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (раскроет все возможные комбинации и создаст дерево каталогов).\n\n- Вывод любой команды можно сохранить в файлоподобный контекст с помощью `<(some command)`. Например, сравнение локального файла `/etc/hosts с удалённым:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Знайте про *heredoc*-синтаксис в Баше, работает он так: `cat <<EOF ...`.\n\n- В Баше перенаправляйте стандартный вывод, а также стандартные ошибки, вот так: `some-command >logfile 2>&1` или `some-command &>logfile`. Зачастую, для того, чтобы убедиться, что команда не оставит открытым файл, привязав его к открытому терминалу, считается хорошей практикой добавлять `</dev/null`.\n\n- Используйте `man ascii` для просмотра хорошей ASCII таблицы с шестнадцатеричными и десятичными значениями. Для информации по основным кодировкам полезны `man unicode`, `man utf-8` и `man latin1`.\n\n- Используйте `screen` или [`tmux`](https://tmux.github.io/) для того, чтобы иметь несколько экранов в одном терминале. Это особенно полезно, когда вы работаете с удаленным сервером по ssh, тогда вы можете подключаться/отключаться от сессий. `byobu` может улучшить использование `screen` или `tmux`, предоставляя больше информации и удобное управление. Более минималистичный подход для этого – использование [`dtach`](https://github.com/bogner/dtach).\n\n- В SSH полезно знать как сделать port tunnel с ключами `-L` и `-D` (и иногда `-R`). Например для того, чтобы зайти на сайт с удаленного сервера.\n\n- Еще может быть полезно оптимизировать вашу SSH конфигурацию, например этот файл `~/.ssh/config` содержит настройки, которые помогают избегать потерянных подключений в некоторых сетевых окружениях. Используйте сжатие (которое полезно с scp через медленные подключения) и увеличьте количество каналов к одному серверу через этот конфиг, вот так:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Некоторые другие настройки SSH могут сильно повлиять на безопасность и должны меняться осторожно, например, для конкретной подсети или конкретной машины или в доверенных сетях: `StrictHostKeyChecking=no`, `ForwardAgent=yes`.\n\n- Рассмотрите [`mosh`](https://mosh.org/) как альтернативу SSH, которая использует UDP и позволяет избежать разрывов соединений и добавляет удобства (требует настройки со стороны сервера).\n\n- Чтобы получить разрешения файла в восьмеричном виде, что полезно для конфигурации систем, но нельзя получить из `ls`, можно использовать что-то типа:\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Для интерактивного выделения результатов других команд используйте [`percol`](https://github.com/mooz/percol) или [`fzf`](https://github.com/junegunn/fzf).\n\n- Для работы с файлами, список которых дала другая команда (например, `git`), используйте `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Чтобы быстро поднять веб-сервер в текущей директории (и поддиректориях), который доступен для всех в вашей сети, используйте:\n`python -m SimpleHTTPServer 7777` (если у вас Python 2 и вы хотите открыть сервер на порту 7777) или `python -m http.server 7777` (для Python 3 и порта 7777).\n\n- Чтобы выполнить определённую команду с привилегиями, используйте `sudo` (для рута) и `sudo -u` (для другого пользователя). Используйте `su` или `sudo bash`, чтобы запустить шелл от имени этого пользователя. Используйте `su -`, чтобы эмулировать свежий логин от рута или другого пользователя.\n\n- Знайте про [ограничение 128Кб](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) в командной строке. Ошибка \"Argument list too long\" часто бывает, когда маска по имени включает большое количество файлов (в таких случаях помогают варианты с `find` или `xargs`).\n\n- В качестве простого калькулятора (и, конечно, вообще для работы с Python) используйте интерпретатор `python`. Например,\n```\n>>> 2+3\n5\n```\n\n\n## Обработка файлов и информации\n\n- Для того, чтобы найти файл в текущей директории, сделайте `find . -iname '*something*'`. Для того, чтобы искать файл по всей системе, используйте `locate something` (но не забывайте, что `updatedb` мог еще не проиндексировать недавно созданные файлы).\n\n- Для основного поиска по содержимому файлов (более сложному, чем `grep -r`) используйте [`ag`](https://github.com/ggreer/the_silver_searcher).\n\n- Для конвертации HTML в текст: `lynx -dump -stdin`.\n\n- Для конвертации разных типов разметки (HTML, Markdown и др.) попробуйте [`pandoc`](http://pandoc.org/).\n\n- Если нужно работать с XML, есть старая, но хорошая утилита – `xmlstarlet`.\n\n- Для работы с JSON используйте [`jq`](http://stedolan.github.io/jq/).\n\n- Для работы с YAML используйте [`shyaml`](https://github.com/0k/shyaml).\n\n- Для работы с Excel и CSV-файлами используйте [csvkit](https://github.com/onyxfish/csvkit) (программа предоставляет команды `in2csv`, `csvcut`, `csvjoin`, `csvgrep` и т.д.)\n\n- Для работы с Amazon S3 удобно работать с [`s3cmd`](https://github.com/s3tools/s3cmd) и [`s4cmd`](https://github.com/bloomreach/s4cmd) (последний работает быстрее). Для остальных сервисов Амазона используйте стандартный [`aws`](https://github.com/aws/aws-cli) или улучшенный [`saws`](https://github.com/donnemartin/saws).\n\n- Знайте про `sort` и `uniq`, включая флаги `-u` и `-d`, смотрите примеры ниже. Также попробуйте `comm`.\n\n- Знайте про `cut`, `paste` и `join` для работы с текстовыми файлами. Многие люди используют `cut`, забыв про `join`.\n\n- Знайте о `wc`: для подсчёта переводов строк (`-l`), для символов – (`-m`), для слов – words (`-w`), для байтового подсчёта – (`-c`).\n\n- Знайте про `tee` для копирования из stdin и в stdout, и в файл, например `ls -al | tee file.txt`.\n\n- Для более сложных вычислений, включающих групповые операции с данными, преобразование матриц и статистические функции, имейте в виду [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Не забывайте, что локализация вашей системы влияет на многие команды, включая порядки сортировки, сравнение и производительность. Многие дистрибутивы Linux автоматически выставляют `LANG` или любую другую переменную в подходящую для Вашего региона. Из-за этого результаты функций сортировки могут работать непредсказуемо. Рутины `i18n` могут *значительно* снизить производительность сортировок. В некоторых случаях можно полностью этого избегать (за исключением редких случаев), сортируя традиционно побайтово, для этого `export LC_ALL=C`.\n\n- Вы можете установить специфическое окружение для команды с помощью  префикса перед ее вызовом, например `TZ=Pacific/Fiji date`.\n\n- Знайте основы `awk` и `sed` для простых манипуляций с данными. Например, чтобы получить сумму всех чисел, которые находятся в третьей колонке текстового файла, можно использовать `awk '{ x += $3 } END { print x }'`. Скорее всего, это получится раза в 3 быстрее и раза в 3 проще, чем делать это в Питоне.\n\n- Чтобы заменить все вхождения подстроки в одном или нескольких файлах:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\nДля того, чтобы переименовать сразу много файлов по шаблону, используйте `rename`. Для сложных переименований может помочь [`repren`](https://github.com/jlevy/repren). В некоторых ситуациях `rename` тоже позволяет совершать множественное переименование, но будьте осторожны, т.к. его функциональность может меняться в зависимости от дистрибутива.\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Как говорит man, `rsync` на деле - быстрая, с множеством возможностей, утилита для копирования файлов. Но она хороша не только для синхронизации между машинами, но и локально. Если есть доступ, то `rsync`, в отличие от `scp`, позволяет возобновить процесс копирования, не начиная заново.  Он также является [самым быстрым способом](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) удалить большое количество файлов:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Используйте `shuf`, чтобы перемешать строки или выбрать случайную строчку из файла.\n\n- Знайте флаги `sort`а. Для чисел используйте `-n`, для работы с человекочитаемыми числами используйте `-h` (например `du -h`). Знайте как работают ключи (`-t` и `-k`). В частности, не забывайте, что вам нужно писать `-k1,1` для того, чтобы отсортировать только первое поле; `-k1` - это сортировка, учитывая всю строчку. Также стабильная сортировка может быть полезной (`sort -s`). Например для того, чтобы отсортировать самое важное по второму полю, а второстепенное по первому, можно использовать `sort -k1,1 | sort -s -k2,2`.\n\n- Если вам когда-нибудь придётся написать код символа табуляции в терминале, например, для сортировки по табуляциям с флагом -t, используйте сокращение **ctrl-v** **[Tab]** или напишите `$'\\t'`. Последнее лучше, потому что его можно скопировать.\n\n- Стандартные инструменты для патчинга исходников это `diff` и `patch`. Также посмотрите на `diffstat` для просмотра статистики изменений (диффа) и `sdiff` для сравнения бок-о-бок (side-by-side). `diff -r` работает рекурсивно по всей директории. Используйте `diff -r tree1 tree2 | diffstat` для полной сводки изменений. Используйте `vimdiff` для сравнения и редактирования файлов.\n\n- Для бинарных файлов используйте `hd`, `hexdump` или `xxd` для простых hex-дампов, и `bvi` для двоичного изменения бинарных файлов.\n\n- `strings` (в связке с `grep` или чем-то похожим) помогает найти строки в бинарных файлах.\n\n- Чтобы посмотреть разницу в бинарниках (дельта-кодирование) используйте `xdelta3`.\n\n- Для конвертирования кодировок используйте `iconv`. Для более сложных задач – `uconv`, он поддерживает некоторые сложные фичи Юникода. Например, эта команда переводит строки из файла в нижний регистр и убирает ударения (которые бывают, например, в испанском языке)\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- Для того, чтобы разбить файл на куски, используйте `split` (разбивает на куски по размеру), или `csplit` (по шаблону или регулярному выражению).\n\n- Для операций с датами и временем используйте `dateadd`, `datediff`, `strptime` и т.д. из [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Используйте `zless`, `zmore`, `zcat` и `zgrep` для работы со сжатыми файлами.\n\n- `chattr` устанавливает атрибуты файлов, которые также являются низкоуровневой альтернативой правам доступа. Например, от случайного удаления файла защитит атрибут неизменяемости: `sudo chattr +i /critical/directory/or/file`.\n\n- Используйте `getfacl` и `setfacl` для сохранения и восстановления файловых прав доступа. Например:\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n## Отладка системы\n\n- Для веб-отладки используйте `curl` и `curl -I`, или их альтернативу - `wget`. Также есть более современные утилиты, например [`httpie`](https://github.com/jakubroztocil/httpie).\n\n- Чтобы узнать текущее состояние процессора/диска, можно использовать классический `top` (или улучшенную альтернативу `htop`) и `iostat`, `iotop`. Используйте `iostat -mxz 15` для получения базовой информации о процессоре и детализированной о каждом разделе жесткого диска.\n\n- Для получения информации о сетевых соедиениях используйте `netstat` и `ss`.\n\n- Для получения краткой информации о происходящем в системе используйте `dstat`, для более детальной информации – [`glances`](https://github.com/nicolargo/glances). Эта программа показывает сразу несколько разных статистик в одном окне терминала. Полезно, когда следите за сразу несколькими системами.\n\n- Для того, чтобы следить за памятью, научитесь понимать `free` и `vmstat`. В частности, не забывайте, что кешированые значения (\"cached\" value) – это память, которую держит ядро и эти значения являются частью `free`.\n\n- Отладка Java – совсем другая рыбка, но некоторые манипуляции над виртуальной машиной Оракла, или любой другой, позволят вам использовать `kill -3 <pid>` и трассировать сводки стека и хипа (включая детали работы сборщика мусора, которые бывают очень полезными), и их можно сдампить в stderr или логи. `jps`, `jstat`, `jstack`, `jmap` также полезны. [SJK tools](https://github.com/aragozin/jvm-tools) более продвинуты.\n\n- Используйте [`mtr`](http://www.bitwizard.nl/mtr/) для лучшей трассировки, чтобы находить проблемы сети.\n\n- Для того, чтобы узнать, почему диск полностью забит, используйте [`ncdu`](https://dev.yorhel.nl/ncdu), это сохраняет время по сравнению с тем же `du -sh *`.\n\n- Для того, чтобы узнать, какой сокет или процесс использует интернет, используйте [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) или [`nethogs`](https://github.com/raboof/nethogs).\n\n- `ab`, которая поставляется вместе с apache, полезна для быстрой и поверхностной проверки производительности веб-сервера. Для более серьезного нагрузочного тестирования используйте `siege`.\n\n- Для более серьёзной отладки сетей используйте [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) и [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Знайте про `strace` и `ltrace`. Эти команды могут быть полезны, если программа падает или висит, и вы не знаете почему. Или если вы хотите протестировать производительность программы. Не забывайте про возможность отладки (`-c`) и возможность прицепиться к процессу по pid (`-p`).\n\n- Не забывайте про `ldd` для проверки используемых библиотек.\n\n- Знайте как прицепиться к работающему процессу через `gdb` и получить трассировку стека.\n\n- Используйте `/proc`. Иногда он невероятно полезен для отладки запущенных программ. Примеры: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (где `xxx` это pid).\n\n- Когда отлаживаете что-то, что сломалось в прошлом, используйте [`sar`](http://sebastien.godard.pagesperso-orange.fr/) – бывает очень полезно. Показывает историю CPU, памяти, сети и т.д.\n\n- Для анализа более сложных систем и производительности посмотрите на `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](http://en.wikipedia.org/wiki/Perf_(Linux)), и [`sysdig`](https://github.com/draios/sysdig).\n\n- Узнайте, какая у вас ОС, через `uname` или `uname -a` (основная Unix-информация/информация о ядре), или `lsb_release -a` (информация о дистрибутиве).\n\n- Используйте `dmesg`, когда что-то ведет себя совсем странно (например, железо или драйвера).\n\n- Если вы удалили файл и это вопреки ожиданиям не освободило место на диске, как показывает `du`, проверьте, использует ли файл какой-нибудь процесс:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`.\n\n\n## В одну строчку\n\nДавайте соберем все вместе и напишем несколько команд:\n\n- Это довольно круто, что можно найти множественные пересечения файлов, соединить отсортированные файлы и посмотреть разницу в нескольких файлах через `sort`/`uniq`. Это быстрый подход и работает на файлах любого размера, включая многогигабайтные файлы (сортировка не ограничена памятью, но, возможно, вам придется добавить `-T`, если `/tmp` находится на небольшом логическом диске). Еще посмотрите то, что было сказано выше о `LC_ALL`. Флаг сортировки `-u` не используется ниже, чтобы было понятнее:\n```sh\n      cat a b | sort | uniq > c        # c is a union b\n      cat a b | sort | uniq -d > c     # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n\n- Используйте `grep . *` для того, чтобы посмотреть содержимое всех файлов в директории. Особенно полезно, когда у вас много конфигов типа `/sys`, `/proc`, `/etc`.\n\n\n- Получить сумму всех чисел, которые находятся в третьей колонке текстового файла (скорее всего, это раза в 3 быстрее и раза в 3 проще, чем делать это в Питоне):\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Чтобы посмотреть размеры и даты в дереве файлов, есть почти как рекурсивная `ls -l`, но легче читаемая, чем `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n-  Скажем, у нас есть какой-то текстовый файл, например лог какого-то сервера и на каких-то строках появляется значение, строки с которым нам интересны. Например, `acct_id`. Давайте подсчитаем, сколько таких запросов в нашем логе:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Для непрерывного мониторинга измененний используйте `watch`, например, проверка измений файлов в директории: `watch -d -n 2 'ls -rtlh | tail'` или сетевых настроек во время устранения проблем с вашей wifi сетью: `watch -d -n 2 ifconfig`.\n\n- Запустите этот скрипт, чтобы получить случайный совет из этой инструкции:\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Сложно, но полезно\n\n- `expr`: для выполнения арифметических и булевых операций, а также регулярных выражений\n\n- `m4`: простенький макро-процессор\n\n- `yes`: вывод строки в бесконечном цикле\n\n- `cal`: классный календарь\n\n- `env`: для того, чтобы выполнить команду (полезно в Bash-скриптах)\n\n- `printenv`: показать переменные окружения (полезно в скриптах или отладке)\n\n- `look`: найти английские слова (или строки) в файле\n\n- `cut `, `paste` и `join`: манипуляции с данными\n\n- `fmt`: форматирование параграфов в тексте\n\n- `pr`: отформатировать текст в страницы/колонки\n\n- `fold`: (обернуть) ограничить длину строк в файле\n\n- `column`: форматировать текст в колонки или таблицы\n\n- `expand` и `unexpand`: конвертация между табами и пробелами\n\n- `nl`: добавить номера строк\n\n- `seq`: вывести последовательность чисел\n\n- `bc`: калькулятор\n\n- `factor`: возвести числа в степень\n\n- [`gpg`](https://gnupg.org/): зашифровать и подписать файлы\n\n- `toe`: таблица терминалов terminfo с описанием\n\n- `nc`: отладка сети и передачи данных\n\n- `socat`: переключатель сокетов и перенаправление tcp-портов (похоже на `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): визуализация трафика сети\n\n- `dd`: перенос информации между блочными устройствами\n\n- `file`: узнать тип файла\n\n- `tree`: показать директории и поддиректории в виде дерева, как `ls`, но рекурсивно\n\n- `stat`: информация о файле\n\n- `time`: время выполнения команды\n\n- `timeout`: выполнять команду указанное количество времени и остановить процесс по его истечении\n\n- `lockfile`: создание семафорного файла, который может быть удален только с помощью `rm -f`\n\n- `logrotate`: ротация, сжатие и отправка логов по почте\n\n- `watch`: повторный запуск команды с выводом результата или подсветкой изменений\n\n- `tac`: вывести файл построчно в обратном порядке\n\n- `shuf`: случайная выборка строк из файла\n\n- `comm`: построчно сравнить отсортированные файлы\n\n- `pv`: мониторинг прогресса прохождения информации через пайп\n\n- `hd`, `hexdump`, `xxd`, `biew` и `bvi`: hex-дамп и редактирование бинарных файлов\n\n- `strings`: найти текст в бинарниках\n\n- `tr`: манипуляция с char (символьным типом)\n\n- `iconv` и `uconv`: конвертация кодировок\n\n- `split` и `csplit`: разбить файлы\n\n- `sponge`: прочитать весь входной поток перед тем, как его записать. Полезно, когда читаешь из того же файла, куда записываешь. Например, вот так: `grep -v something some-file | sponge some-file`\n\n- `units`: конвертер. Метры в километры, версты в пяди (смотрите `/usr/share/units/definitions.units`)\n\n- `apg`: генерация случайных паролей\n\n- `7z`: архиватор с высокой степенью сжатия\n\n- `ldd`: показывает зависимости программы от системных библиотек\n\n- `nm`: получаем названия всех функций, которые определены в .o или .a (объектные файлы)\n\n- `ab`: бенчмаркинг веб-серверов\n\n- `strace`: отладка системных вызовов\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): лучшая трассировка для отладки сети\n\n- `cssh`: несколько терминалов в одном UI\n\n- `rsync`: синхронизация файлов и папок через SSH\n\n- [`wireshark`](https://wireshark.org/) и [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): перехват пакетов и отладка сети\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep для слоя сети (network layer). Перехват пакетов по заданной маске.\n\n- `host` и `dig`: узнать DNS\n\n- `lsof`: информация о дескрипторах и сокетах процесса\n\n- `dstat`: полезная статистика ОС\n\n- [`glances`](https://github.com/nicolargo/glances): высокоуровневая статистика по многим подсистемам\n\n- `iostat`: статистика процессора и использования жёсткого диска\n\n- `mpstat`: статистика использования процессора\n\n- `vmstat`: статистика использования памяти\n\n- `htop`: улучшенная версия `top`\n\n- `last`: история логинов в систему\n\n- `w`: под каким пользователем вы сидите\n\n- `id`: информация о пользователе/группе\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): история системной статистики\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) или [`nethogs`](https://github.com/raboof/nethogs): использование сети конкретным сокетом или процессом\n\n- `ss`: статистика сокетов\n\n- `dmesg`: ошибки загрузки и ошибки системы\n\n- `sysctl`: просмотр и конфигурирование параметров ядра Linux\n\n- `hdparm`: манипуляции с SATA/ATA\n\n- `lsblk`: cписок блочных устройств компьютера: дерево ваших дисков и логических дисков\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: информация о железе, включая CPU, BIOS, RAID, графику, девайсы, и т.д.\n\n- `lsmod` и `modinfo`: информация о модулях ядра\n\n- `fortune`, `ddate`, и `sl`: хм, не знаю, будут ли вам \"полезны\" веселые цитатки и поезда, пересекающие ваш терминал :)\n\n\n## OS X only\n\nНекоторые вещи, подходящие *только* для OS X.\n\n- Системы управлением пакетами – `brew` (Homebrew) и `port` (MacPorts). Они могут быть использованы для того, чтобы установить большинство программ, упомянутых в этом документе.\n\n- Копируйте выдачу консольных программ в десктопные через `pbcopy` и вставляйте входные данные через `pbpaste`.\n\n- Чтобы использовать в OS X кнопку Options как Alt (для использования команд **alt-b**, **alt-f** и т.д.) в настройках Терминала откройте Профили -> Клавиатура и выберите \"Использовать клавишу Option в качестве метаклавиши\" (\"Use Option as Meta key\").\n\n- Для того, чтобы открыть файл или десктопную программу типа Finder, используйте `open`. Вот так: `open -a /Applications/Whatever.app`.\n\n- Spotlight: Ищите файлы в консоли, через `mdfind`, и смотрите метаданные (например EXIF информацию фотографий) через `mdls`.\n\n- Не забывайте, что OS X основана на BSD Unix и многие команды (например `ps`, `ls`, `tail`, `awk`, `sed`) имеют небольшие различия с линуксовыми. Это обусловлено влянием `UNIX System V` и `GNU Tools`. Разницу можно заметить, увидев заголовок \"BSD General Commands Manual.\" в манах программ. В некоторых случаях, на Мак можно поставить GNU-версии программ, например `gawk` и `gsed`. Когда пишите кроссплатформенные Bash-скрипты, старайтесь избегать использовать команды, которые могут различаться (например, лучше используйте Python или `perl`), или тщательно все тестируйте.\n\n- Чтобы получить информацию о версии OS X используйте `sw_vers`.\n\n## Windows only\n\n- Используйте силу Unix shell в Microsoft Windows, установив [Cygwin](https://cygwin.com/). Большая часть описанных в этом документе возможностей заработает сразу.\n\n- Установите еще Unix программ с помощью встроенного в Cygwin менеджера пакетов.\n\n- Используйте `mintty` в качестве терминала.\n\n- Работайте с буфером обмена Windows с помощью `/dev/clipboard`.\n\n- Запустите `cygstart`, чтобы открыть файл в приложении по умолчанию.\n\n- Работайте с реестром Windows с помощью `regtool`.\n\n- Имейте в виду, что виндовый диск `C:\\` доступен в Cygwin по пути `/cygdrive/c`, и cygwin''ский `/` является папкой `C:\\cygwin` в Windows. Конвертируйте файловые пути в виндовые и обратно с помощью `cygpath`. Это самый полезный скрипт, который запускает программы Windows.\n\n- Вы можете запускать и автоматизировать большинство задач по администрированию Windows из командной строки, освоив `wmic`.\n\n## Больше информации по теме\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Дополняемый список инструментов и ресурсов для командной строки.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Более детальные гайды по терминалу в OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/): Для того, чтобы писать шелл-скрипты лучше.\n- [shellcheck](https://github.com/koalaman/shellcheck): Статический анализатор скриптов.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Сборник мелочей о правильной обработке имен файлов в скриптах.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Обзор команд и утилит, используемых для обработки данных, из одноименной книги.\n\n## Дисклеймер\n\nЗа небольшим исключением, весь код написан так, чтобы другие смогли его прочитать. Чем больше сила, тем больше и ответственность. Тот факт, что вы *способны* что-то сделать в Баше, вовсе не означает, что это нужно делать! ;)\n\n\n## Лицензия\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nОригинальная работа и перевод на русский язык распространяется под лицензией [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-sl.md",
          "type": "blob",
          "size": 42.22,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# Umetnost ukazne vrstice\n\n[![Vprašajte](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Meta](#meta)\n- [Osnove](#osnove)\n- [Vsakodnevna uporaba](#vsakodnevna-uporaba)\n- [Procesiranje datotek in podatkov](#procesiranje-datotek-in-podatkov)\n- [Sistemsko razhroščevanje](#sistemsko-razhroščevanje)\n- [V eni vrstici](#v-eni-vrstici)\n- [Nepregledno vendar uporabno](#nepregledno-vendar-uporabno)\n- [Samo za macOS](#samo-za-macos)\n- [Samo za Windows](#samo-za-windows)\n- [Več virov](#več-virov)\n- [Pogoji uporabe](#pogoji-uporabe)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nJedrnatost v ukazni vrstici je znanje, ki je pogostokrat zanemarjeno ali smatrano za zastarelo, vendar izboljša vašo fleksibilnost in produktivnost kot inženir na očitne in neočitne načine. To so izbrani zapiski in nasveti glede uporabe ukazne vrstice, ki smo jo našli uporabno pri delu z Linux-om. Nekateri nasveti so elementarni in nekateri so precej določeni, sofisticirani ali nepregledni. Ta stran ni dolga, vendar če lahko uporabite in se spomnite vseh elementov tu, boste vedeli veliko.\n\nTo delo je rezultat [mnogih avtorjev in prevajalcev](AUTHORS.md).\nNekaj tega\nse je [prvotno](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[pojavilo](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\nna [Quori](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nvendar se je premaknilo na GitHub, kjer so ljudje bolj talentirani od prvotnega avtorja naredili številne izboljšave.\n[**Vprašajte**](https://airtable.com/shrzMhx00YiIVAWJg), če imate vprašanje povezano z ukazno vrstico. [**Prosimo, prispevajte**](/CONTRIBUTING.md), če vidite napako ali nekaj, kar bi lahko bilo boljše!\n\n## Meta\n\nObseg:\n\n- Ta vodič je tako za začetnike kot za poznavalce. Cilji so *širina* (vse pomembno), *specifičnost* (podaja konkretne primere najpogostejših primerov uporabe) in *kratkost* (izogiba se stvarem, ki niso bistvene ali se odmikajo, kar lahko enostavno pogledate drugje). Vsak nasvet je bistven v določeni situaciji ali bistveno prihrani čas pred alternativami.\n- To je napisano za Linux z izjemo sekcij \"[Samo za macOS](#samo-za-macos)\" in \"[Samo za Windows](#samo-za-windows)\". Mnogi ostali elementi veljajo ali pa so lahko nameščeni na drugih Unix-ih ali macOS (ali celo Cygwin).\n- Poudarek je na interaktivnosti Bash-a, čeprav mnogo nasvetov velja za ostale lupine in splošno skriptanje Bash-a.\n- Vključuje tako \"standardne\" ukaze Unix-a kot tudi tiste, ki zahtevajo namestitev posebnih paketov -- dokler so dovolj pomembni, da zaslužijo vključitev.\n\nOpombe:\n\n- Da se obdrži to na eni strani, je vsebina implicitno vključena z referencami. Ste dovolj pametni, da poiščete več podrobnosti drugje, ko enkrat poznate idejo ali ukaz za iskanje na Google-u. Uporabite `apt-get`, `yum`, `dnf`, `pacman`, `pip` ali `brew` (kot je ustrezno), da namestite nove programe.\n- Uporabite [Explainshell](http://explainshell.com/), da dobite uporabne razčlenitve, kaj ukazi, opcije, cevi itd. naredijo.\n\n\n## Osnove\n\n- Naučite se osnovni Bash. Dejansko vtipkajte `man bash` in vsaj prelistajte celotno stvar; slediti je precej enostavno in ni tako dolgo. Alternativne lupine so lahko lepe, vendar Bash je močan in vedno na voljo (učenje *samo* zsh, fish itd., medtem ko poskušate na lastno pest na vašem prenosniku, vas omeji v mnogih situacijah, kot je uporaba obstoječih strežnikov).\n\n- Dobro se naučite vsaj enega izmed tekstovnih urejevalnikov. Urejevalnik `nano` je eden izmed najenostavnejših za osnovno urejanje (odpiranje, urejanje, shranjevanje, iskanje). Vendar za bolj vešče uporabnike v tekstovnem terminalu, ni zamenjave za Vim (`vi`), težko priučljiv vendar častljiv, hiter urejevalnik poln možnosti. Mnogi uporabljajo tudi klasični Emacs, še posebej za večja opravila urejanja. (Seveda, katerikoli moderni razvijalec, ki dela na razširljivem projektu, ne bo uporabljal samo čisto tekstovnega urejevalnika in bi moral biti seznanjen tudi z modernimi IDE in orodji z grafičnimi vmesniki.)\n\n- Spoznajte, kako brati dokumentacijo z `man` (za radovedne, `man man` izpiše številke sekcij, npr. 1 so \"splošni\" ukazi, 5 so datoteke/konvencije in 8 je za administracijo). Najdite strani man z `apropos`. Vedite, da nekateri ukazi niso izvršljivi, vendar vgrajeni v Bash in pomoč zanje lahko dobite s `help` in `help -d`. Z uporabo `type command` lahko izvedete, ali je ukaz izvršljiv, vgrajen v lupino ali pa je alias.\n\n- Naučite se o preusmeritvi izpisa in vnosa z uporabo `>` in `<` ter uporabo cevi `|`. Vedite, da `>` prepiše izpis datoteke in `>>` ga pripne. Naučite se o stdout in stderr.\n\n- Naučite se o razširitvi datotek glob z `*` (in mogoče `?` ter `[`...`]`) in citiranje ter razliko med dvojnim `\"` in enojnim `'` citatom. (Poglejte več o razširitvi spremenljivk spodaj.)\n\n- Seznanite se z upravljanjem nalog Bash-a: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill` itd.\n\n- Spoznajte `ssh` in osnove avtentikacije brez gesla, preko `ssh-agent`, `ssh-add` itd.\n\n- Osnovno upravljanje datotek: `ls` in `ls -l` (še posebej se naučite, kaj vsak stolpec v `ls -l` pomeni), `less`, `head`, `tail` in `tail -f` (ali celo boljše, `less +F`), `ln` in `ln -s` (naučite se razlike in prednosti trdih in mehkih povezav), `chown`, `chmod`, `du` (za hiter povzetek uporabe diska: `du -hs *`). Za upravljanje datotečnega sistema, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Naučite se, kaj je inode (`ls -i` or `df -i`).\n\n- Osnovno upravljanje omrežja: `ip` ali `ifconfig`, `dig`, `traceroute`, `route`.\n\n- Naučite se in uporabljajte sistem za nadzor različic, kot je `git`.\n\n- Poznajte tudi splošne izraze in različne zastavice za `grep`/`egrep`. Opcije `-i`, `-o`, `-v`, `-A`, `-B` in `-C` so vredne poznavanja.\n\n- Naučite se uporabljati `apt-get`, `yum`, `dnf` ali `pacman` (odvisno od distribucije), da najdete in namestite pakete. In zagotovite, da imate `pip`, da lahko nameščate orodja ukazne vrstice na osnovi Python-a (nekaj spodnjih je najenostavneje namestiti preko `pip`).\n\n\n## Vsakodnevna uporaba\n\n- V Bash-u uporabite **Tab** za dokončanje argumentov ali izpis vseh ukazov, ki so na voljo, in **ctrl-r**, da iščete skozi zgodovino ukazov (po pritiski, vtipkajte za iskanje, pritisnite **ctrl-r** s ponavljanjem za kroženje skozi več ujemanj, pritisnite **Enter**, da izvršite najdeni ukaz, ali pritisnite desno puščico, da date trenutni rezultat v trenutno vrstico in omogočite urejanje).\n\n- V Bash-u uporabite **ctrl-w**, da izbrišete zadnjo besedo in **ctrl-u**, da izbrišete vse do začetka vrstice. Uporabite **alt-b** in **alt-f**, da se premikate po besedah, **ctrl-a**, da premaknete kurzor na začetek vrstice, **ctrl-e**, da premaknete kurzor na konec vrstice, **ctrl-k**, da ubijete do začetka vrstice, **ctrl-l**, da počistite zaslon. Glejte `man readline` za vse privzete vezave tipk v Bash-u. Na voljo jih je veliko. Na primer **alt-.** kroži skozi prejšnje argumente in **alt-*** razširi glob.\n\n\n- Alternativno, če imate radi vi-stilske vezave tipk, uporabite `set -o vi` (in `set -o emacs` za povrnitev nazaj).\n\n- Za urejanje dolgih ukazov, po nastavitvi vašega urejevalnika (na primer `export EDITOR=vim`), **ctrl-x** **ctrl-e** bo odprlo trenutni ukaz v urejevalniku za več vrstično urejanje. Ali v stilu vi, **escape-v**.\n\n- Če si želite ogledati nedavne ukaze, uporabite `history`. Nadalje `!n` (kjer je `n` številka ukaza), da ga ponovno izvedete. Na voljo je tudi veliko okrajšav, najuporabnejša verjetno `!$` za zadnji argument in `!!` za zadnji ukaz (glejte \"HISTORY EXPANSION\" na man straneh). Vendar so le-te pogostokrat enostavno zamenjane s **ctrl-r** in **alt-.**.\n\n- Pojdite v vaš domači direktorij s `cd`. Dostopajte do datotek relativno glede na vaš domači direktorij s predpono `~` (npr. `~/.bashrc`). V `sh` skriptah se sklicujte na domači direktorij kot `$HOME`.\n\n- Da greste nazaj na prejšnji delovni dirketorij: `cd -`\n\n- Če ste na pol poti skozi vpisovanje ukaza, vendar si premislite, vtipkajte **alt-#**, da dodate `#` na začetek in ga vnesete kot komentar (ali uporabite **ctrl-a**, **#**, **enter**). Nato se lahko vrnete k njemu kasneje preko zgodovine ukazov.\n\n- Uporabite `xargs` (ali `parallel`). Je zelo močan. Bodite pozorni, da lahko kontrolirate, kolikokrat izvršite na vrstico (`-L`) kot tudi paralelnost (`-P`). Če niste prepričani, da bo naredilo pravilno stvar, uporabite najprej `xargs echo`. Tudi `-I{}` je priročen. Primeri:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` je priročen prikaz drevesa procesov.\n\n- Uporabite `pgrep` in `pkill`, da najdete ali signalizirate procese po imenu (`-f` je v pomoč).\n\n- Poznajte različne signale, katerim lahko pošljete procese. Na primer, da suspendirate proces, uporabite `kill -STOP [pid]`. Za celotni seznam glejte `man 7 signal`\n\n- Uporabite `nohup` ali `disown`, če želite, da proces iz ozadja vedno poteka.\n\n- Preverite, kateri procesi se poslušajo preko `netstat -lntp` ali `ss -plat` (za TCP; dodajte `-u` za UDP) ali `lsof -iTCP -sTCP:LISTEN -P -n` (kar deluje tudi na macOS).\n\n- Glejte tudi `lsof` in `fuser` za odprte priključke in datoteke.\n\n- Glejte `uptime` ali `w`, da izveste, koliko časa se sistem poganja.\n\n- Uporabite `alias`, da ustvarite bližnjice za pogosto uporabljene ukaze. Na primer, `alias ll='ls -latr'` ustvari nov alias `ll`.\n\n- Shranite aliase, nastavitve lupine in funkcije, ki jih pogosto uporabljate v `~/.bashrc` in [uredite prijave lupin za izvorno kodo](http://superuser.com/a/183980/7106). To bo naredilo vašo namestitev na voljo v vseh sejah vaše lupine.\n\n- Dajte nastavitve spremenljivk okolja kot tudi ukaze, ki bi morali biti izvršeni, ko se prijavite v `~/.bash_profile`. Ločena nastavitev bo potrebna za lupine, ki jih zaženete iz prijave grafičnega okolja in s periodičnimi opravili `cron`.\n\n- Sinhronizirajte vaše nastavitvene datoteke (npr. `.bashrc` in `.bash_profile`) med različnimi računalniki s pomočjo Git.\n\n- Razumite, da je potrebna skrb, ko spremenljivke in imena datotek vsebujejo prazne znake. Obdajte vaše spremenljivke Bash s citati, npr. `\"$FOO\"`. Raje cenite opciji `-0` ali `-print0`, da omogočite razmejevanje imen datotek z ničelnimi znaki, npr. `locate -0 pattern | xargs -0 ls -al` ali `find / -print0 -type d | xargs -0 ls -al`. Za iteracijo v for zanki na imenih datotek, ki vsebujejo prazne znake, nastavite da vaš IFS za nove vrstice uporablja samo `IFS=$'\\n'`.\n\n- V skriptah Bash uporabite `set -x` (ali varianto `set -v`, ki beleži dnevnik surovega izpisa, vključno z nerazširjenimi spremenljivkami in komentarji) za razhroščevanje izpisa. Uporabite striktni način razen, če imate dober razlog, da ga ne: Uporabite `set -e`, da preskočite napake (neničelna koda izhoda). Uporabite `set -u`, da zaznate uporabo nenastavljenih spremenljivk. Premislite tudi o `set -o pipefail`, da na napakah znotraj pip, (vendar preberite o tem več, če boste to uporabili, saj je ta tema nekoliko subtilna). Za bolj vključene skripte, uporabite tudi `trap` pri EXIT ali ERR. Uporabna navada je tako začeti skripto, kar bo naredilo, da lahko zazna ali prekliče na pogostih napakah in izpiše sporočilo:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- V skriptah Bash so podlupine (napisane z oklepaji) priročen način za grupiranje ukazov. Skupen primer je začasno premakniti na različen delovni direktorij, npr.\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- V Bash-u bodite pozorni, saj je veliko vrst razširjenih spremenljivk. Preverjanje, če spremenljivka obstaja: `${name:?error message}`. Na primer, če skripta Bash zahteva en argument, samo napišite `input_file=${1:?usage: $0 input_file}`. Uporaba privzete vrednosti, če je spremenljivka prazna: `${name:-default}`. Če želite, imeti dodatni (opcijski) parameter dodan k prejšnjemu primeru, lahko uporabite nekaj takega `output_file=${2:-logfile}`. Če je `$2` izpuščen in tako prazen, bo `output_file`  nastavljen na `logfile`. Aritmetična raširitev: `i=$(( (i + 1) % 5 ))`. Sekvence: `{1..10}`. Obrezovanje nizov: `${var%suffix}` in `${var#prefix}`. Na primer, če je `var=foo.pdf`, potem `echo ${var%.pdf}.txt` izpiše `foo.txt`.\n\n- Lupinska razširitev zavitih oklepajev z `{`...`}` lahko pomaga zmanjšati potrebo po ponovnem vpisovanju podobnega teksta in avtomatizira kombiniranje elementov. To je v pomoč v primerih kot je `mv foo.{txt,pdf} some-dir` (ki premakne obe datoteki), `cp somefile{,.bak}` (kar razširi v `cp somefile somefile.bak`) ali `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (kar razširi vse možne kombinacije in ustvari drevo direktorijev). Razširitev zavitih oklepajev je izvedena pred katerokoli drugo razširitvijo.\n\n- Vrstni red razširitev je: razširitev zavitega oklepaja; razširitev tilda, razširitev parametra in spremenljivke, aritmetična razširitev in zamenjava ukaza (izvedeno na način levo proti desnem); delitev besed; in razširitev imena datoteke. Na primer, obseg kot je `{1..20}` ne more biti izražen s spremenljivkami z uporabo `{$a..$b}` ob predpostavki `a=1` in `b=20` in doprinese `{1..20}`. Uporabite `seq` ali `for` zanko, npr., `seq $a $b` ali `for((i=a; i<=b; i++)); do ... ; done`.\n\n- Izpis ukaza se lahko tretira kot datoteko preko `<(some command)` (znan kot proces zamenjave). Na primer, primerjajte lokalno `/etc/hosts` z oddaljeno:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- Ko pišete skripte, boste morda želeli dati vašo kodo v zavite oklepaje. Če zapirajoči se oklepaj manjka, se vaša skripta ne bo izvršila zaradi sintaktične napake. To je smiselno, ko se vašo skripto prenese iz spleta, saj preprečuje izvrševanje delno prenešene skripte:\n```bash\n{\n    # Vaša koda\n}\n```\n\n- T.i. \"here document\" omogoča [preusmeritev večih vrstic vnosa](https://www.tldp.org/LDP/abs/html/here-docs.html) kot da gre za datoteko:\n```\ncat << EOF\nThese lines will\nprint to stdout\nEOF\n```\n\n- V Bash-u je preusmeritev obeh standardov izpisa in standardnih napak preko: `some-command >logfile 2>&1` ali `some-command &>logfile`. Pogosto zagotavlja, da ukaz ne pusti ročaja odprte datoteke za standardni vnos, kar ga veže na terminal v katerem se nahajate, je tudi dobra praksa, da dodate `</dev/null`.\n\n- Uporabite `man ascii` za dobro tabelo ASCII s heksadecimalnimi in decimalnimi vrednostmi. Za splošne informacije enkodiranja so priročni `man unicode`, `man utf-8` in `man latin1`.\n\n- Uporabite `screen` ali [`tmux`](https://tmux.github.io/), da muliplicirate zaslon, posebej uporabno na oddaljenih sejah ssh in da odstranite in se ponovno pripnete k seji. `byobu` lahko poveča t.i. screen ali tmux s ponujanjem več informacij in enostavnejšim upravljanjem. Bolj minimalna alternativa za samo obstojnost sej je [`dtach`](https://github.com/bogner/dtach).\n\n- V ssh je poznavanje, kako usmeriti tunel z `-L` ali `-D` (in občasno `-R`) je uporaben, npr. za dostopanje do spletnih strani iz oddaljenega strežnika.\n\n- Lahko je uporabno, da se naredi nekaj optimizacij na vaših nastavitvah ssh; na primer, ta `~/.ssh/config` vsebuje nastavitve za izogib padle povezave v določenih okoljih omrežja, uporablja kompresijo (ki je v pomoč s scp preko nizko pasovnih povezav) in multiplicira kanale na isti strežnik z lokalno krmilno datoteko:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- Nekaj ostalih opcij relevantnih za ssh je varnostno občutljivih in bi morale biti omogočene s pazljivostjo, npr. na podomrežju ali gostitelju ali v zaupljivih omrežjih: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Premislite o [`mosh`](https://mosh.org/) kot alternativi za ssh, ki uporablja UDP, da se izognete padlim povezavam in dodate priročnost, ko ste na poti (zahteva nastavitev strežniške strani).\n\n- Da dobite pravice na datoteki v osmiškem zapisu, ki je uporaben za nastavitve sistema vendar ni na voljo pri `ls` in enostaven za mešanje, uporabite nekaj takega kot je\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- Za interaktivno izbiro vrednosti iz izpisa drugega ukaza, uporabite [`percol`](https://github.com/mooz/percol) ali [`fzf`](https://github.com/junegunn/fzf).\n\n- Za interakcijo z datotekami osnovanimi na izpisu drugega ukaza (kot je `git`), uporabite `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- Za enostaven spletni strežnik za vse datoteke v trenutnem direktoriju (in poddirektorijih), ki so na voljo komurkoli v vašem omrežju, uporabite:\n`python -m SimpleHTTPServer 7777` (za port 7777 in Python 2) in `python -m http.server 7777` (za port 7777 in Python 3).\n\n- Za pogon ukaza pod drugim uporabnikom, uporabite `sudo`. Privzeto požene kot root; uporabite `-u`, da določite drugega uporabnika. Uporabite `-i` za prijavo tega uporabnika (vprašalo vas bo za _vaše_ geslo).\n\n- Za preklop lupine na drugega uporabnika, uporabite `su username` ali `su - username`. Pripona `-` dobi okolje, kakor da bi se drug uporabnik ravnokar prijavil. Izpustitev uporabniškega imena pomeni privzeto root. Vprašani boste za geslo _uporabnika na katerega preklapljate_.\n\n- Spoznajte [omejitev 128K](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) v ukaznih vrsticah. Ta napaka \"Argument list too long\" je pogosta, ko se nadomestni znak ujema z velikim številom datotek. (Ko se to zgodi, lahko pomagajo alternative kot sta `find` in `xargs`.)\n\n- Za osnovni kalkulator (in seveda splošni dostop do Python-a) uporabite interpreter `python`. Na primer,\n```\n>>> 2+3\n5\n```\n\n\n## Procesiranje datotek in podatkov\n\n- Da locirate datoteko po imenu v trenutnem direktoriju, `find . -iname '*something*'` (ali podobno). Da najdete datoteko kjerkoli po imenu, uporabite `locate something` (vendar imejte v mislih, da `updatedb` morda ni poindeksiral nazadnje ustvarjenih datotek).\n\n- Za splošno iskanje skozi izvorne ali podatkovne datoteke, na voljo je nekaj možnosti bolj naprednih in hitrejših možnosti od `grep -r`, vključno z (po surovem vrstnem redu od starejših do novejših) [`ack`](https://github.com/beyondgrep/ack2), [`ag`](https://github.com/ggreer/the_silver_searcher) (\"t.i. silver searcher\") in [`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep).\n\n- Da pretvorite HTML v tekst: `lynx -dump -stdin`\n\n- Za Markdown, HTML in vse vrste pretvorb dokumentov poskusite [`pandoc`](http://pandoc.org/).\n\n- Če morate upravljati z XML, je `xmlstarlet` star vendar dober.\n\n- Za JSON, use [`jq`](http://stedolan.github.io/jq/). Za interaktivnost glejte tudi [`jid`](https://github.com/simeji/jid) in [`jiq`](https://github.com/fiatjaf/jiq).\n\n- Za YAML, uporabite [`shyaml`]((https://github.com/0k/shyaml).\n\n- Za Excel ali CSV datoteke, [csvkit](https://github.com/onyxfish/csvkit) ponuja `in2csv`, `csvcut`, `csvjoin`, `csvgrep` itd.\n\n- Za Amazon S3 je priročen [`s3cmd`](https://github.com/s3tools/s3cmd) in [`s4cmd`](https://github.com/bloomreach/s4cmd) je hitrejši. Amazon-ov [`aws`](https://github.com/aws/aws-cli) in izboljšan [`saws`](https://github.com/donnemartin/saws) sta bistvena za druga AWS-povezana opravila.\n\n- Naučite se o `sort` in `uniq` vključno z uniq-ovima opcijama `-u` in `-d` -- glejte spodaj sekcijo v eni vrstici. Glejte tudi `comm`.\n\n- Naučite se o `cut`, `paste` in `join` za manipuliranje tekstovnih datotek. Mnogi uporabljajo `cut` vendar pozabijo na `join`.\n\n- Naučite se o `wc`, da preštejete nove vrstice (`-l`), znake (`-m`), besede (`-w`) in bajte (`-c`).\n\n- Naučite se o `tee`, da prekopirate iz stdin v datoteko in tudi v stdout, kot pri `ls -al | tee file.txt`.\n\n- Za kompleksnejše kalkulacije, vključno z združevanjem, obračanjem polj in statističnimi izračuni, razmislite o [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Vedite, da lokalizacija vpliva na veliko orodij ukazne vrstice na subtilne načine, vključno z vrstnim redom (kolokacijo) in uspešnostjo. Večina namestitev Linux-a bo nastavila `LANG` ali druge spremenljivke lokalizacije na lokalne nastavitve kot je US English. Vendar bodite pozorni, saj se bo vrstni red spremenil, če spremenite lokalizacijo. In vedite, da rutine i18n lahko naredijo sortiranje ali poganjanje drugih ukazov *nekajkrat* počasnejše. V nekaterih situacijah (kot je skupek operacij ali unikatnih operacij spodaj) lahko v celoti varno ignorirate počasne rutine i18n in uporabite tradicionalne vrstne rede na osnovi bajtov z uporabo `export LC_ALL=C`.\n\n- Nastavite lahko določeno okolje ukaza s predpono njegovega sklicevanja na nastavitve spremenljivk okolja, kot pri `TZ=Pacific/Fiji date`.\n\n- Spoznajte osnove `awk` in `sed` za enostavno manipuliranje podatkov. Za primere glejte sekcijo [v eni vrstici](#v-eni-vrstici).\n\n- Da zamenjate vsa pojavljanja niza na mestu v eni ali večih datotekah:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- Da preimenujete več datotek in/ali poiščete in poiščete in zamenjate znotraj datotek, poskusite [`repren`](https://github.com/jlevy/repren). (V nekaterih primerih ukaz `rename` tudi omogoča preimenovanje, vendar bodite pozorni, saj funkcionalnost ni enaka na vseh distribucijah Linux).\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- Kot pravi stran vodiča, je `rsync` resnično hiter in izredno vsestransko orodje kopiranja datotek. Znano je po sinhronizaciji med napravami vendar je enakovredno uporaben tudi lokalno. Ko omejitve varnosti omogočajo, uporaba `rsync` namesto `scp` omogoča povrnitev prenosa brez ponovnega zagona od začetka. Je tudi eden izmed [najhitrejših načinov](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) za izbris velikega števila datotek:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- Za spremljanje napredka med kopiranjem datotek uporabite [`pv`](http://www.ivarch.com/programs/pv.shtml), [`pycp`](https://github.com/dmerejkowsky/pycp), [`pmonitor`](https://github.com/dspinellis/pmonitor), [`progress`](https://github.com/Xfennec/progress), `rsync --progress`, ali za kopiranje na nivoju blokov `dd status=progress`.\n\n- Uporabite `shuf` za naključno mešanje ali izbiro naključnih vrstic iz datoteke.\n\n- Poznajte opcije za `sort`. Za številke uporabite `-n` ali `-h` za upravljanje številk človeku prijaznih za branje (npr. iz `du -h`). Vedite, kako delujejo ključi (`-t` in `-k`). Še posebej pazite, da morate zapisati `-k1,1`, da razvrstite samo po prvem polju; `-k1` pomeni razvrščanje glede na celotno vrstico. Stabilno razvrščanje (`sort -s`) je lahko uporabno. Na primer, da sortirate najprej po polju 2 in nato po polju 1, lahko uporabite `sort -k1,1 | sort -s -k2,2`.\n\n- Če kadarkoli potrebujete zapisati tabulator dobesedno v ukazni vrstici v Bash-u (npr. za sortiranje argumenta -t), pritisnite **ctrl-v** **[Tab]** ali zapišite `$'\\t'` (slednji je boljši, saj ga lahko kopirate in prilepite).\n\n- Standardna orodja za popravljanje izvorne kode so `diff` in `patch`. Glejte tudi `diffstat` za povzetek statistike diff-a in `sdiff` za diff drug ob drugem. Bodite pozorni, saj `diff -r` deluje za celotne direktorije. Uporabite `diff -r tree1 tree2 | diffstat` za povzetek sprememb. Uporabite `vimdiff` za primerjanje in urejanje datotek.\n\n- Pri binarnih datotekah uporabite `hd`, `hexdump` ali `xxd` za enostavne heksadecimalne izpise in `bvi`, `hexedit`, ali `biew` za binarno urejanje.\n\n- `strings` (plus `grep` itd.) vam omogoča najti bite v tekstu tudi za binarne datoteke.\n\n- Za binarne diff-e (delta kompresije) uporabite `xdelta3`.\n\n- Da pretvorite enkodiranje teksta, poskusite `iconv`. Ali `uconv` za bolj napredno uporabo; podpira nekaj naprednih Unicode stvari. Na primer:\n```sh\n      # Prikaže hex kode ali dejanska imea znakov (uporabno za razhroščevanje):\n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < input.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < input.txt\n      # Male črke in odstrani vsa naglasna znamenja (z razširitvijo in opustitvijo):\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC;' < input.txt > output.txt\n```\n\n- Da razcepite datoteke na dele, glejte `split` (da razcepite po velikosti) in `csplit` (da razcepite po vzorcu).\n\n- Datum in čas: Da dobite trenutni datum in čas v priročnem [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatu, uporabite `date -u +\"%Y-%m-%dT%H:%M:%SZ\"` (ostale opcije [so](https://stackoverflow.com/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [problematične](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option)). Za manipuliranje izrazov datuma in časa, uporabite `dateadd`, `datediff`, `strptime` itd. iz [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Uporabite `zless`, `zmore`, `zcat` in `zgrep` za operiranje na kompresiranih datotekah.\n\n- Atributi datotek so nastavljivi preko `chattr` in ponujajo nizko nivojsko alternativo pravicam datotek. Na primer za zaščito pred ponesrečenim brisanjem datoteke se uporabi nespremenljiva zastavica: `sudo chattr +i /critical/directory/or/file`\n\n- Uporabite `getfacl` in `setfacl`, da shranite in povrnete pravice datotek. Na primer:\n```sh\n    getfacl -R /some/path > permissions.txt\n    setfacl --restore=permissions.txt\n```\n\n- Za hitro ustvarjanje praznih datotek, uporabite `truncate` (ustvari t.i. [sparse file](https://en.wikipedia.org/wiki/Sparse_file)), `fallocate` (ext4, xfs, btrfs in ocfs2 datotečni sistemi), `xfs_mkfile` (skoraj katerikoli datotečni sistem, pride skupaj s paketom xfsprogs), `mkfile` (za Unix in podobne sisteme kot sta Solaris in Mac OS).\n\n## Sistemsko razhroščevanje\n\n- Za spletno razhroščevanje, sta priročna `curl` in `curl -I` ali pa njun ekvivalent `wget`, ali bolj moderen [`httpie`](https://github.com/jkbrzt/httpie).\n\n- Da izveste trenutni status diska/procesorja/omrežja, so na voljo klasična orodja `top`, (ali bolje `htop`), `iostat` in `iotop` . Uporabite `iostat -mxz 15` za osnovno statistiko CPU in podrobno na particijo statistiko diska in vpogled v uspešnost.\n\n- Za podrobnosti omrežne povezave uporabite `netstat` in `ss`.\n\n- Za hiter pregled, kaj se dogaja na sistemu, je `dstat` posebno uporaben. Za širši pregled s podrobnostmi uporabite [`glances`](https://github.com/nicolargo/glances).\n\n- Da izveste status spomina, poženite in razumite izpis `free` in `vmstat`. Še posebej bodite pozorni, da je vrednost \"cached\" držana v spominu s strani jedra Linux-a kot datoteka predpomnilnika, tako da efektivno šteje proti vrednosti \"free\".\n\n- Sistemsko razhroščevanje Java je drugačen tip, vendar enostaven trik na JVM-jih Oracle-a in nekaterih ostalih je, da lahko poženete `kill -3 <pid>` in sledite celotnemu stack-u in povzetku kopic (vključno s podrobnostmi zbirke splošnih smeti, ki so lahko zelo informativne), ki bodo oddane v stderr/logs. JDK-jevi `jps`, `jstat`, `jstack`, `jmap` so uporabni. [SJK Tools](https://github.com/aragozin/jvm-tools) so bolj napredni.\n\n- Uporabite [`mtr`](http://www.bitwizard.nl/mtr/) kot boljši usmerjevalnik sledenja za identifikacijo težav omrežja.\n\n- Za iskanje, zakaj je disk poln, vam [`ncdu`](https://dev.yorhel.nl/ncdu) prihrani čas preko običajnih ukazov kot je `du -sh *`.\n\n- Da najdete katera vtičnica ali proces uporablja pasovno širino, poskusite [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ali [`nethogs`](https://github.com/raboof/nethogs).\n\n- Orodje `ab` (prihaja z Apache-jem) je v pomoč za hitro in nečisto preverjanje uspešnosti spletnega strežnika. Za bolj kompleksno testiranje nalaganja poskusite `siege`.\n\n- Za bolj resno razhroščevanje omrežja, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) ali [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Poznajte `strace` in `ltrace`. Ta sta v pomoč, če program ni uspešen, se ustavlja ali poruši in ne veste zakaj, ali če želite dobiti splošno idejo o uspešnosti. Bodite pozorni na opcijo profiliranja (`-c`) in zmožnost dodajanja k procesu, ki se poganja (`-p`). Uporabite podrejene opcije trace (`-f`), da se izognete manjkajočim pomembnim klicem.\n\n- Poznajte `ldd`, da preverite deljene knjižnice itd. —  vendar [nikoli ne poženite na nezaupljivih datotekah](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/).\n\n- Vedite, kako se povezati k procesu v pogonu z `gdb` in dobiti njegove sledi skladovnice.\n\n- Uporabite `/proc`. Včasih je izjemno v pomoč, ko se razhroščuje probleme v živo. Primeri: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (kjer je `xxx` id procesa ali pid).\n\n- Ko se razhroščuje, zakaj je šlo nekaj narobe v preteklosti, je lahko zelo uporaben [`sar`](http://sebastien.godard.pagesperso-orange.fr/). Prikazuje statistiko zgodovine na procesorju, spominu, omrežju itd.\n\n- Za globlje analize sistema in uspešnosti, poglejte `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_%28Linux%29) in [`sysdig`](https://github.com/draios/sysdig).\n\n- Preverite na katerem operacijskem sistemu ste z `uname` ali `uname -a` (splošne informacije Unix-a/jedra) ali `lsb_release -a` (informacije distribucuje Linux).\n\n- Uporabite `dmesg` kadarkoli gre nekaj dejansko čudno (lahko je težava strojne opreme ali gonilnika).\n\n- Če izbrišete datoteko in se prostor na voljo ne poveča, kot je pričakovano s poročilom `du`, preverite ali datoteko uporablja proces:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## V eni vrstici\n\nNekaj primerov sestavljanja ukazov skupaj:\n\n- Včasih je izredno v pomoč, da lahko nastavite presek, unijo in razliko tekstovnih datotek preko `sort`/`uniq`. Predpostavimo `a` in `b` sta tekstovni datoteki, ki sta že unikatni. To je hitro in deluje na datotekah arbitrarnih velikosti do nekaj gigabajtov. (Urejanje ni omejeno glede na spomin, čeprav morda potrebujete uporabiti opcijo `-T`, če je `/tmp` na majhni root particiji.) Glejte tudi opombo o `LC_ALL` zgoraj in `sort`-ovo opcijo `-u` (puščeno zaradi jasnosti spodaj).\n```sh\n      sort a b | uniq > c   # c is a union b\n      sort a b | uniq -d > c   # c is a intersect b\n      sort a b b | uniq -u > c   # c is set difference a - b\n```\n\n- Uporabite `grep . *`, da hitro preučite vsebine vseh datotek v direktoriju (vsaka vrstica ima par z imenom datoteke) ali `head -100 *` (da iima vsaka datoteka glavo). To je lahko uporabno za direktorije napolnjene s konfiguracijskimi nastavitvami, kot so tiste v `/sys`, `/proc`, `/etc`.\n\n\n- Povzetje vseh številk v tretjem stolpcu tekstovne datoteke (to je verjetno 3X hitrejše in 3X manj kode kot Python-ov ekvivalent):\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- Da vidite velikost/datume v drevesu datotek, je to kot rekurzivni `ls -l` vendar enostavnejše za branje kot `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Recimo, da imate tekstovno datoteko, kot dnevnik spletnega strežnika in določena vrednost se pojavi na nekaterih vrsticah, kot parameter `acct_id`, ki je prisoten v URL-ju. Če želite ujemanja, koliko je zahtevkov za vsak `acct_id`:\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- Da neprekinjeno nadzirate spremembe, uporabite `watch`, npr. preverite spremembe datotek v direktoriju z `watch -d -n 2 'ls -rtlh | tail'` ali med odpravljanjem težav vaših nastavitev wifi z `watch -d -n 2 ifconfig`.\n\n- Poženite to funkcijo, da dobite naključni nasvet iz tega dokumenta (razčleni Markdown in izvleče element):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          sed '/cowsay[.]png/d' |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80 | iconv -t US\n      }\n```\n\n\n## Nepregledno vendar uporabno\n\n- `expr`: izvede aritmetične ali logične operacije ali oceni splošne izraze\n\n- `m4`: enostaven makro procesor\n\n- `yes`: velikokrat izpiše niz\n\n- `cal`: lep koledar\n\n- `env`: požene ukaz (uporabno v skriptah)\n\n- `printenv`: izpiše spremenljivke okolja (uporabno pri razhroščevanju in v skriptah)\n\n- `look`: najde angleške besede (ali vrstice v datoteki) začenši z nizom\n\n- `cut`, `paste` in `join`: manipulacija podatkov\n\n- `fmt`: oblikuje odstavke teksta\n\n- `pr`: oblikuje tekst v strani/stolpce\n\n- `fold`: ovije vrstice teksta\n\n- `column`: oblikuje tekstovna polja v poravnane stolpce s fiksno širino ali tabele\n\n- `expand` in `unexpand`: pretvori med tabulatorji in presledki\n\n- `nl`: doda vrstice številk\n\n- `seq`: izpiše številke\n\n- `bc`: kalkulator\n\n- `factor`: celo številski faktorji\n\n- [`gpg`](https://gnupg.org/): enkriptira in podpiše datoteke\n\n- `toe`: tabela vnosov terminfo\n\n- `nc`: rahroščevanje omrežja in prenos podatkov\n\n- `socat`: rele vtičnice in odpravnik tcp porta (podobno kot `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): vizualizacija prometa omrežja\n\n- `dd`: premikanje podatkov med datotekami in napravami\n\n- `file`: identifikacija tipa datoteke\n\n- `tree`: prikaže direktorije in poddirektorije kot gnezdeno drevo; kot `ls` vendar rekurzivno\n\n- `stat`: informacije datoteke\n\n- `time`: izvrši in da ukaz v čas\n\n- `timeout`: izvršite ukaz za določen čas in ustavite proces, ko se določen čas konča.\n\n- `lockfile`: ustvari semaforno datoteko, ki je lahko odstranjena samo z `rm -f`\n\n- `logrotate`: rotiranje, kompresiranje in pošiljanje dnevnikov po e-pošti.\n\n- `watch`: večkrat požene ukaz in prikazuje rezultate in/ali poudari spremembe\n\n- [`when-changed`](https://github.com/joh/when-changed): požene kateri koli ukaz, ki ga določite, kadarkoli opazi spremembo datoteke. Glejte tudi `inotifywait` in `entr`.\n\n- `tac`: izpiše datoteke v obratnem redu\n\n- `comm`: primerja sortirane datoteke vrstico za vrstico\n\n- `strings`: izvleče tekst iz binarnih datotek\n\n- `tr`: prevod znakov ali manipulacija\n\n- `iconv` ali `uconv`: pretvorba enkodiranja teksta\n\n- `split` in `csplit`: cepljenje datotek\n\n- `sponge`: prebere vse vnose pred pisanjem, uporabno za branje iz njih in nato za pisanje v isto datoteko, npr. `grep -v something some-file | sponge some-file`\n\n- `units`: pretvorba enot in kalkulacije; pretvori furlonge (osmino milje) na štirinajst dni v dvajsetine točke na blink (glejte tudi `/usr/share/units/definitions.units`)\n\n- `apg`: generira naključna gesla\n\n- `xz`: kompresija datoteke visokega razmerja\n\n- `ldd`: informacije dinamične knjižnice\n\n- `nm`: simboli iz datotek objekta\n\n- `ab` ali [`wrk`](https://github.com/wg/wrk): merjenje uspešnosti spletnih strežnikov\n\n- `strace`: razhroščevanje sistemskega klica\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): boljše sledenje usmerjanja za razhroščevanje omrežja\n\n- `cssh`: vizualna sočasna lupina\n\n- `rsync`: sinhronizacija datotek in map preko SSH ali v lokalnem datotečnem sistemu\n\n- [`wireshark`](https://wireshark.org/) in [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): zajem paketov in razhroščevanje omrežja\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep za nivo omrežja\n\n- `host` in `dig`: pogled DNS\n\n- `lsof`: procesira deskriptorje datoteke in informacije vtičnice\n\n- `dstat`: uporabna statistika sistema\n\n- [`glances`](https://github.com/nicolargo/glances): visoko nivojski, večkratni podsistemski pregled\n\n- `iostat`: statistika uporabe diska\n\n- `mpstat`: statistika uporabe procesorja\n\n- `vmstat`: statistika uporabe spomina\n\n- `htop`: izboljšana verzija top\n\n- `last`: zgodovina prijav\n\n- `w`: kdo je prijavljen\n\n- `id`: informacije identifikacije uporabnika/skupine\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): statistika zgodovine sistema\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) ali [`nethogs`](https://github.com/raboof/nethogs): izkoriščenost omrežja po vtičnici ali procesu\n\n- `ss`: statistika vtičnice\n\n- `dmesg`: sporočila napak zagona in sistema\n\n- `sysctl`: ogled in nastavitev parametrov jedra Linux pri pogonu\n\n- `hdparm`: manipulacija/uspešnost SATA/ATA disk-a\n\n- `lsblk`: izpiše blokovne naprave: drevesni pogled vaših diskov in particij diska\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: informacije strojne opreme, vključno s procesorjem, BIOS-om, RAID-om, grafiko, napravami itd.\n\n- `lsmod` in `modinfo`: izpišeta in prikažeta podrobnosti o modulih jedra.\n\n- `fortune`, `ddate` in `sl`: hm, torej zavisi glede na to ali smatrate parne lokomotive in dinamične kotacije \"uporabne\"\n\n\n## Samo za macOS\n\nTo so elementi pomembni *samo* za macOS.\n\n- Upravljanje paketov z `brew` (Homebrew) in/ali `port` (MacPorts). Te so lahko uporabljeni za namestitev mnogih zgornjih ukazov na macOS.\n\n- Kopirajte izpis katerega koli ukaza na namizno aplikacijo s `pbcopy` in prilepite vnos iz ene s `pbpaste`.\n\n- Da omogočite uporabo tipke Option v macOS terminalu kot tipka alt (kot je uporabljena v ukazih zgoraj kot **alt-b**, **alt-f** itd), odprite Preferences -> Profiles -> Keyboard in izberite \"Use Option as Meta key\".\n\n- Da odprete datoteko z namizno aplikacijo, uporabite `open` ali `open -a /Applications/Whatever.app`.\n\n- Spotlight: Poiščite datoteke z `mdfind` in izpišite meta podatke (kot so EXIF informacije fotografije) z `mdls`.\n\n- Bodite pozorni, saj je macOS osnovan na BSD Unix in mnogi ukazi (na primer `ps`, `ls`, `tail`, `awk`, `sed`) imajo mnoge subtilne različice iz Linux-a, na katerega je večinoma vplival System V-style Unix in GNU tools. Pogostokrat lahko poveste razliko tako, da opazite, da ima stran man naslov \"BSD General Commands Manual.\" V nekaterih primerih se lahko namestijo tudi GNU različice (kot so `gawk` in `gsed` za GNU awk in sed). Če pišete skripte Bash za vse platforme, se izogibajte takim ukazom (na primer, z upoštevanjem Python ali `perl`) ali pazljivo testirajte.\n\n- Da dobite informacije o izdaji macOS, uporabite `sw_vers`.\n\n## Samo za Windows\n\nSledeče velja *samo* za Windows.\n\n### Načini pridobitve Unix orodij na Windows\n\n- Dostopajte do moči lupine Unix na Microsoft Windows z namestitvijo [Cygwin](https://cygwin.com/). Večina stvari opisanih v tem dokumentu bo delala \"Out of the Box\".\n\n- Na Windows 10 lahko uporabite [Windows Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about), ki ponuja znano okolje Bash z orodji ukazne vrstice Unix.\n\n- Če želite v glavnem uporabljati GNU razvojna orodja (kot je GCC) na Windows, premislite o [MinGW](http://www.mingw.org/) in njegovem paketu [MSYS](http://www.mingw.org/wiki/msys), ki ponuja orodja, kot so bash, gawk, make in grep. MSYS nima vseh funkcij v primerjavi s Cygwin. MinGW je posebej uporaben za ustvarjanje izvornih Windows prenosov orodij Unix.\n\n- Druga opcija, da dobite izgled in občutek Unix-a na Windows-u, je [Cash](https://github.com/dthree/cash). Upoštevajte, da so v tem okolju na voljo le nekateri ukazi Unix in opcije ukazne vrstice.\n\n### Uporabna Windows orodja ukazne vrstice\n\n- Izvajate in kodirate lahko večino sistemskih opravil Windows iz ukazne vrstice, če se naučite uporabljati `wmic`.\n\n- Izvorna mrežna orodja ukazne vrstice Windows, ki jih morda najdete uporabne, vključujejo `ping`, `ipconfig`, `tracert` in `netstat`.\n\n- Izvajate lahko [mnoga upporabna opravila Windows](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) s klicem ukaza `Rundll32`.\n\n### Cygwin nasveti in triki\n\n- Namestite dodatne programe Unix z upraviteljem paketov Cygwin.\n\n- Uporabite `mintty` za vaše okno ukazne vrstice.\n\n- Do odložišča Windows dostopajte preko `/dev/clipboard`.\n\n- Poženite `cygstart`, da odprete poljubno datoteko preko njene registrirane aplikacije.\n\n- Do registra Windows dostopajte z `regtool`.\n\n- Upoštevajte, da pot diska Windows `C:\\` postane v Cygwin `/cygdrive/c` in Cigwin-ov `/` se na Windows pojavi pod `C:\\cygwin`. Pretvorite med Cygwin in Windows stilom poti datotek s `cygpath`. To je najbolj uporabno v skriptah, ki se sklicujejo na programe Windows.\n\n## Več virov\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): urejan seznam orodij lupine in virov.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Bolj poglobljen vodič za macOS ukazno vrstico.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) za pisanje boljših skript lupine.\n- [shellcheck](https://github.com/koalaman/shellcheck): lupinska skripta orodja statične analize. V osnovi, lint za bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): Na žalost kompleksne podrobnosti, kako pravilno ravnati z imeni datotek v lupinskih skriptah.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): Več koristnih ukazov in orodij za uporabo v znanosti podatkov iz knjige z enakim imenom.\n\n## Pogoji uporabe\n\nZ izjemo zelo majhnih opravil je koda napisana tako, da jo lahko ostali berejo. Z močjo pride odgovornost. Dejstvo, da *lahko* naredite nekaj v Bash-u ne pomeni nujno, da bi morali! ;)\n\n\n## Licenca\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nTo delo je izdano pod [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-uk.md",
          "type": "blob",
          "size": 53.4,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# Мистецтво командного рядка\n\n[![Задайте питання](https://img.shields.io/badge/%3f-Ask%20a%20Question-ff69b4.svg)](https://airtable.com/shrzMhx00YiIVAWJg)\n[![Вступайте в англомовний чат проекту https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n- [Опис](#Опис)\n- [Основи](#Основи)\n- [Щоденне використання](#Щоденне-використання)\n- [Обробка файлів та інформації](#Обробка-файлів-та-інформації)\n- [Відладка](#Відладка)\n- [Одним рядком](#Одним-рядком)\n- [Складно але корисно](#Складно-але-корисно)\n- [Тільки для OS X](#Тільки-для-os-x)\n- [Тільки для Windows](#Тільки-для-windows)\n- [Інші джерела](#Інші-джерела)\n- [Відмова від відповідальності](#Відмова-від-відповідальності)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nВикористанню командного рядка часто не приділяють достатньої уваги. Про термінал говорять, як про щось містичне. Насправді, ці навики явно (і не явно) збільшують вашу продуктивність у роботі. Даний документ є підбіркою на наш погляд корисних при роботі з командним рядком в Linux заміток і порад. Деякі з них - прості та очевидні, але інші - або призначені для вирішення конкретних завдань, або досить складні чи широко невідомі. Це невелика публікація, але якщо ви вже все знаєте, що тут написано, і можете згадати як це все використовувати - ви знаєте багато!\n\nЦе -- результат роботи [багатьох авторів і перекладачів](AUTHORS.md).\nДещо з цього [спочатку](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands) [з'явилось](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix) на [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know), але потім переїхало на Github, де багато людей талановитіших за початкового автора, внесли багато удосконалень.\n[**Задайте питання**](https://airtable.com/shrzMhx00YiIVAWJg) якщо у вас є питання стосовно командного рядка. \n[**Будь-ласка, зробіть свій внесок**](/CONTRIBUTING.md) якщо ви знайшли помилку або можете щось покращити!\n\n\n\n## Опис\n\nОхоплення:\n\n- Дана публікація призначена як для початківців, так і для досвідчених користувачів. Цілі: *наповнення* (зібрати всі важливі аспекти використання командного рядка), *практичність* (надати конкретні приклади для найпоширеніших ситуацій) та *стислість* (не варто вдаватись у несуттєві деталі, про які можна прочитати деінде).\n- Цей документ написаний для користувачів Linux, за винятком розділів \"[Тільки для OS X](#Тільки-для-os-x)\" та \"[Тільки для Windows(#Тільки-для-Windows)]\". Все інше підходить для всіх UNIX чи OS X систем (і навіть для Cygwin).\n- Сфокусована на інтерактивному Bash, але багато порад також можуть застосовуватися в інших командних оболонках чи загалом до Bash-скриптів.\n- Ця інструкція включає в себе як стандартні Unix команди, так і ті, для використання яких потрібно встановлювати додаткові пакети, якщо користь  від  застосування команди виправдовує установку пакету.\n\nНотатки:\n\n- Вся інформація збережена в одному файлі для спрощення пошуку, перекладу та навігації. У  вас вистачить  вмінь, щоб самостійно вивчити питання більш детально в іншому місці. Використовуйте `apt-get`, `yum`, `dnf`, `pacman`, `pip` та `brew` (залежно від вашої системи управління пакетами) для установки нових програм.\n\n- На [Explainshell](http://explainshell.com/) можна знайти просте і докладне пояснення того, що таке команди, їх опції, пайпи(pipes(*|*)) і т.д.\n\n\n## Основи\n\n- Вивчіть основи Bash. Просто візьміть і наберіть у командному рядку термінала `man bash` і хоча б перегляньте; він досить просто читається і він не дуже великий. Інші шелли теж можуть бути хороші, але Bash - потужна програма, і Bash завжди під рукою (вивчення *виключно* zsh, fish і т.д., хоч і привабливо  на вашому особистому комп'ютері, насправді обмежує в багатьох випадках, наприклад при використанні існуючих серверів).\n\n- Вивчіть використання хоча б одного консольного редактора тексту. Найкраще Vim (`vi`), адже у нього немає конкурентів, коли вам потрібно швидко щось правити (навіть якщо ви постійно використовуєте Emacs чи якийсь важкий IDE або модний хіпстерський редактор).\n\n- Знайте, як читати документацію командою `man` (для допитливих: `man man` пояснює номери розділів документації, наприклад 1 - для звичайних команд, 5 - для файлів, 8 - для адміністративних команд). Шукайте інформацію через `apropos`, і пам'ятайте, що деякі команди - не виконувані (executables), а внутрішні команди Bash, і допомогу по них можна отримати через команду `help` і `help -d`. Ви можете з'ясувати чи є Ваша команда виконуваним файлом чи вбудована в shell чи є псевдонім, використовуючи команду `type команда`.\n\n- Можна перенаправляти ввід та вивід користуючися `>`, `<` та каналами `|`. Пам'ятайте, що `>` - переписує вихідний файл, а `>>` додає до нього. Дізнайтеся побільше про stdout і stderr.\n\n- Дізнайтеся побільше про розширення шаблонів `*` (а також `?` і `[`...`]`), про вживанняя лапок та про відмінності між подвійними `\"` та одинарними `'` лапками.\n\n- Ознайомтеся, як працювати із процесами в Bash: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, і т.д.\n\n- Знайте `ssh` та основи безпарольної аутентифікації через `ssh-agent`, `ssh-add`, і т.д.\n\n- Основи роботи з файлами: `ls` і `ls -l` (зокрема, дізнайтеся, що значить кожен стовпець в `ls -l`), `less`, `head`,` tail` і `tail -f` (або навіть краще - `less +F`), `ln` і `ln -s` (дізнайтеся про відмінності та переваги символьних і жорстких посилань), `chown`, `chmod`, `du` (для отримання швидкої інформації по використанню диска: `du -hk *`). Для керування файловою системою: `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Дізнайтеся, що таке inode (`ls -i` чи `df -i`).\n\n- Основи роботи з мережею: `ip`, `ifconfig`, `dig`, `traceroute` або `route`.\n\n- Вивчіть і використовуйте систему управління версіями, наприклад таку, як `git`.\n\n- Навчіться писати регулярні вирази і вивчіть різні опції для `grep`/`egrep`. Такі опції як `-i`, `-o`, `-A`, та `-B` варто знати.\n\n- Навчіться використовувати системами управління пакетами `apt-get`, `yum`, `dnf` та `pacman` (залежно від дистрибутива). Знайте як шукати і встановлювати пакети. Обов'язково майте встановленим `pip` для встановки модулів та програм, написаних на Python (деякі з тих команд, що ви знайдете нижче, найлегше встановити через `pip`).\n\n\n\n## Щоденне використання\n\n- Використовуйте клавішу табуляції (**Tab**) в Bash для автодоповнення аргументів до команд та **ctrl-r** для пошуку по історії командного рядка.\n\n- Використовуйте **ctrl-w** в Bash для того, щоб видалити останнє слово в команді; **ctrl-u** для того, щоб видалити команду повністю. Використовуйте **alt-b** і **alt-f** для того, щоб переміщатись між словами у команді, **ctrl-k** для того, щоб перейти в кінець рядка, **ctrl-l** для того, щоб очистити екран. Гляньте на `man readline` щоб дізнатися про всі комбінації клавіш Bash. Їх багато! Наприклад, **alt-.**  переміщається між попередніми аргументам команди, а **alt-*** максимально розширює аргументи.\n\n- Якщо вам подобаються клавішні комбінації vim, виконайте `set -o vi` (`set -o emacs` щоб повернути налаштування).\n- Для редагування довгих команд після налаштування вашого консольного редактора (наприклад `export EDITOR=vim`), **ctrl-x** **ctrl-e** відкриє поточну команду в редакторі для багаторядкового редагування команди. Або у vi стилі, **escape-v**.\n- Для того, щоб переглянути історію, введіть `history`. Також існує безліч абревіатур, наприклад `! $` - Останній аргумент, `!!` - остання команда, хоча ці абревіатури часто заміняються комбінаціями **ctrl-r** та **alt-.**.\n- Перейти в домашню директорію можна за допомогою `cd`. Щоб вказати шлях до файлів із домашньої директорії можна скористатися префіксом `~` (наприклад: `~/.bashrc`). У `sh` скриптах для звернення до домашньої директорії можна використовувати змінну `$HOME`.\n- Для того, щоб стрибнути до останньої робочої директорії, використовуйте `cd -`\n- Якщо ви написали команду наполовину і раптом передумали, натисніть **alt-#** для того, щоб додати `#` на початок команди, та відправте команду як коментар. Потім ви зможете повернутися до неї через історію команд.\n- Використовуйти `xargs` (або `parallel`). Це дуже корисно. Зверніть увагу, що ви можете контролювати кількість команд на кожен рядок (`-L`) також паралельність (`-P`). Якщо ви не впевнені, що робите щось правильно, почніть з `xargs echo`. Також `-I{}` - корисно. Приклади:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n- `pstree -p` - допоможе побачити дерево процесів.\n- Grep the output of `ps aux` to know the pid of a process, like `ps aux | grep postgresql`\n- Використовуйте `pgrep` і `pkill` для того, щоб знаходити або слати сигнали до процесів по імені (`-f` корисна опція).\n- Знайте різні сигнали, які можна слати процесам. Наприклад, щоб призупинити процес, використовуйте `kill -STOP [pid]`. Для повного списку подивіться `man 7 signal`.\n- Використовуйте `nohup` або` disown`, якщо ви хочете запустити фоновий процес що б він постійно виконувався у фоні.\n- Дізнайтеся, які процеси слухають порти через `netstat -lntp` або `ss -plat` (для TCP; додайте `-u` для UDP).\n- Зверніть увагу на команду `lsof` і `fuser`. Вони допоможуть Вам подивитися відкриті сокети і файли.\n- Команда `uptime` or `w` показує як довго працює система.\n- Використовуйте `alias`, щоб створити скорочення для часто використовуємих команд. Наприклад, `alias ll='ls -latr'` створить нове скорочення(alias) `ll`.\n- Збережіть свої синоніми (aliases), налаштування і фунції які ви часто використовуєте у `~/.bashrc`, більш детально [тут](http://superuser.com/a/183980/7106). Це зробить їх доступними в усіх ваших сесіях shell.\n- Синхронізуйте ваші конфігураційні файли (наприклад `.bashrc` та `.bash_profile`) між різними комп'ютерами за допомогою Git.\n- Вставте настройки змінних середовища і команди, які повинні бути виконані при вході у систему в файл `~/.bash_profile`. Окремі налаштування будуть потрібні для оболонок, які запускаються із під графічного інтерфейсу та з під `cron` задач.\n- Необхідно розуміти, що потрібна обережність коли змінні та імена файлів включають пробіли. Окружіть ваші Bash змінні в подвійні лапки: `\"$FOO\"`. Використовуйте `-0` або `-print0` опції щоб дозволити розмежувати імена файлів за допомогою нульових(null) символів. Наприклад: `locate -0 pattern | xargs -0 ls -al` або `find / -print0 -type d | xargs -0 ls -al`. Щоб перебрати імена файлів які містять пробільні символи для циклу встановіть ваш IFS(API файлової системи) використовувати тільки '\\n' для цього використовуйте - `IFS=$'\\n'`.\n- У Bash скриптах використовуйте `set -x` (або `set -v`) щоб дебажити вивід. Використовуйте строгий(strict) режим скрізь, де це можливо. Використовуйте `set -e` для того, щоб припиняти виконання при помилках (не нульовий вихідний код). Використовуйте `set -u` що б визначити невстановленні змінні. Використовуйте `set -o pipefail` щоб при помилках невикористовувати пайпи(вертикальна риска). Для більш складних скриптів також використовуйте `trap` на EXIT or ERR.\nКорисною буде звичка почати використовувати настипний скрипт, який допоможе виявити і перервати на загальних помилках і вивести повідомлення:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n- У Bash-скриптах підоболочки(subshells) - зручний спосіб групувати команди. Один із найпоширеніших прикладів - тимчасово пересунутися в іншу робочу директорію:\n```bash\n     # Do something in current dir\n     (cd / some / other / dir && other-command)\n     # Continue in original dir\n```\n- У Bash багато типів простору змінних. Перевірити, чи існує змінна - `${name:? Error message}`. Наприклад, якщо Bash-скрипту потрібен всього один аргумент, просто напишіть `input_file=${1:?usage: $0 input_file}`. Арифметична область видимості: `i=$(( (i + 1) % 5 ))`. Послідовності: `{1..10}`. Обрізка рядків: `${var%suffix}` і `${var#prefix}`. Наприклад, якщо `var=foo.pdf` тоді `echo ${var%.pdf}.txt` виведе `foo.txt`.\n- Фігурні скобки, використовуючи `{`...`}` може зменшити необхідність повторно вводити той самий текст і автоматизувати. Це корисно в такому прикладі як `mv foo.{txt,pdf} some-dir` (який пересуває обидва файла), `cp somefile{,.bak}` (який розширюється у `cp somefile somefile.bak`) або `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (яка розширює всі можливі комбінації і створює дерево деректорій).\n- Вивід будь-якої команди можна обробити як файл наступним чином `<(some command)`. Наприклад, порівняння локального файлу `/etc/hosts з віддаленим:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n- Знайте про *heredoc* -синтаксис в Bash: `cat << EOF ...`.\n- У Bash перенаправляйте стандартні потоки виводу(output) та помилок, ось так: `some-command >logfile 2>&1`. Найчастіше, для того, щоб переконатись, що команда не залишить відкритим файл, прив'язавши його до відкритого терміналу, вважається хорошою практикою додавати `</dev/null`.\n- Використовуйте `man ascii` щоб отримати таблицю ASCII символів із шіснадцядковими і десятковими значеннями. Для інших основних кодувань користуйтесь: `man unicode`,` man utf-8` і `man latin1`.\n- Використовуйте `screen` або [`tmux`](https://tmux.github.io/) для того, щоб мати кілька екранів в одному терміналі. Це особливо корисно в ssh сесії що б приєднатись чи відєднатись до сесії. `byobu` розширює функціонал screen або tmux надає більше інформації і полегшить керування. Більш мінімалістичною альтернативою для цього є [`dtach`](https://github.com/bogner/dtach).\n- У SSH корисно знати як зробити port tunnel з опціями `-L` і` -D` (іноді `-R`) це корисно наприклад для того, щоб отримати доступ до сайту із віддаленого сервера.\n- Ще може бути корисно зробити декілька оптимізацій у конфігурації вашого SSH, наприклад у файлі `~/.ssh/config` містить налаштування, які допомагають уникати втрачених підключень в деяких мережевих оточеннях, використати стиснення (яке корисне при використанні scp при повільному підключенні) і збільште кількість каналів до одного сервера через цей конфіг, ось так:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n- Деякі із інших налаштування SSH можуть сильно вплинути на безпеку і повинні мінятися обережно, наприклад, для конкретної підмережі, конкретної машини або в домашніх мережах: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n- Розглянемо [`mosh`](https://mosh.org/) як альтернатива ssh який використовує UDP, уникаючи розривів підключеня (вимагає установки на стороні сервера).\n- Щоб отримати права доступу до файлу у вісімковому вигляді, що є корисно для конфігурації систем але не можна отримати з допомогою команди `ls`, можна використовувати щось схоже на це:\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n- Для інтерактивного виділення результатів інших команд використовуйте [`percol`](https://github.com/mooz/percol) або [`fzf`](https://github.com/junegunn/fzf).\n- Для роботи з файлами, список яких дала інша команда (наприклад `git`), використовуйте `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n- Щоб швидко підняти веб-сервер в поточній директорії (і піддерикторіях), який доступний для всіх у вашій мережі, використовуйте:\n`python -m SimpleHTTPServer 7777` (на прту 7777 і для Python 2) або `python -m http.server 7777` (на прту 7777 і для Python 3).\n- Щоб виконати команду з привілеями, використовуйте `sudo` (для root) і `sudo -u` (для іншого користувача). Використовуйте `su` або `sudo bash`, щоб запустити шелл від імені цього користувача. Використовуйте `su -`, щоб симулювати свіжий вхід під root або під іншим користувачем.\n\n\n## Обробка файлів та інформації\n\n- Для того, щоб знайти файл в поточній директорії, виконайте `find. -iname '*something*'`. Для того, щоб шукати файл по всій системі, використовуйте `locate something` (але не забувайте, що `updatedb` міг ще не проіндексувати нещодавно створені файли).\n- Для пошуку по вмісту або фалах (більш детально зробити пошук допоможе `grep -r`) використовуйте [`ag`](https://github.com/ggreer/the_silver_searcher).\n- Для конвертації HTML в текст: `lynx -dump -stdin`\n- Для конвертації різних типів розмітки (HTML, Markdown та ін.) спроробуйте утиліту [`pandoc`](http://pandoc.org/).\n- Якщо нуобхідно працювати з XML, є стара, але хороша утиліта - `xmlstarlet`.\n- Для роботи з JSON використовуйте [`jq`](http://stedolan.github.io/jq/).\n- Для YAML використовуйте [`shyaml`](https://github.com/0k/shyaml).\n- Для Excel і CSV файлів [csvkit](https://github.com/onyxfish/csvkit) надає `in2csv`, `csvcut`, `csvjoin`, `csvgrep` і т.д.\n- Для Amazon S3 [`s3cmd`](https://github.com/s3tools/s3cmd) є зручним і [`s4cmd`](https://github.com/bloomreach/s4cmd) є швидшим. Для решти сервісів Амазону використовуйте стандартний [`aws`](https://github.com/aws/aws-cli) і удосконалений [`saws`](https://github.com/donnemartin/saws).\n- Знайте про `sort` і `uniq`, включаючи опції `-u` і `-d`, дивіться приклади нижче. Ще спробуйте `comm`.\n- Знайте про `cut`, `paste`, і `join` для роботи з текстовими файлами. Багато людей використовують `cut`, забувши про `join`.\n- Знайте про `wc`: для підрахунку нових рядків (`-l`), символів (`-m`), слів (`-w`) і для байтового підрахунку (`-c`).\n- Знайте про `tee` для копіювання в файл з stdin і stdout, щось типу `ls -al | tee file.txt`.\n- Не забувайте, що ваші налаштування консолі та мовні/регіональні налаштування (локаль) впливають на багато команд, включаючи порядок сортування, порівняння і продуктивність. Багато дистрибутиви Linux автоматично виставляють `LANG` або будь-яку іншу змінну в підходящу для вашого регіону. Через це результати функцій сортування можуть працювати непередбачувано. Знайте що `i18n` можуть значно знизити продуктивність сортувань. У деяких випадках можна повністю цього уникати (за винятком рідкісних випадків), сортуючи традиційно побайтово, використовуйте `export LC_ALL = C`.\n- Ви можете встановити спецефічне середовище для команди за допомогогю префікса, а саме: `TZ=Pacific/Fiji date`.\n- Знайте основи `awk` і `sed` для простих маніпуляцій з даними. Наприклад, щоб отримати суму всіх чисел, які знаходяться в третій колонці текстового файлу, можна використати `awk '{ x += $3 } END { print x }'`. Швидше за все, це вийде в рази 3 швидше і рази в 3 простіше, ніж робити це в Пітоні.\n- Щоб замінити всі входження підрядка в одному або декількох файлах:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n- Щоб перейменувати відразу багато файлів за шаблоном, використовуйте `rename`. Для складних перейменувань може допомогти [`repren`](https://github.com/jlevy/repren):\n```sh\n      # Recover backup files foo.bak -> foo:\n      rename 's/\\.bak$//' *.bak\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n```\n- Як говорить man сторінка, `rsync` дійсно є швидким і універсальним інструментом копіювання файлів, для синхронізації між машинами, але в рівній мірі корисні на локальному рівні. Також [швидке рішення](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) що б видалити велику кількість файлів:\n```sh\n      mkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n- Використовуйте `shuf`, щоб перемішати або вибрати випадкові рядки з файлу.\n- Знайте опції для команди `sort`. Для чисел використовуйте `-n` або `-h`, для роботи з числами (наприклад `du -h`). Знайте як працюють ключі (`-t` і `-k`). Зокрема, не забувайте, що вам потрібно писати `-k1,1` для того, щоб впорядкувати тільки перше поле; `-k1` - це означає сортування враховуючи цілий рядок. Може бути корисною (`sort -s`). Наприклад для того, щоб відсортувати найважливіше по другому полю, а другорядне по першому, можна використовувати `sort -k1,1 | sort -s -k2,2`.\n- Якщо вам коли-небудь доведеться написати код символу табуляції в терміналі, наприклад, для сортування за табуляції з прапором -t, використовуйте скорочення **ctrl-v** **[Tab]** або напишіть `$'\\t'`. Останнє краще, тому що його можна скопіювати/вставити.\n- Стандартні інструменти для виправлення вихідного коду це `diff` і `patch`. Також зверніть увагу на `diffstat` для перегляду статистики diff і `sdiff` для крок за кроком diff. Запамятайте `diff -r` працює рекурсивно по всій директорії. Використовуйте `diff -r tree1 tree2 | diffstat` для повного зведення змін. Використовуйте `vimdiff` порівняти і редагувати файли.\n- Для бінарних файлів використовуйте `hd`, `hexdump` або `xxd` для простих hex-дампом, і `bvi`, hexedit або `biew` для зміни бінарників.\n- Також для бінарних файлів, `strings` (плюс `grep`, і т.п.) дозволить вам знайти біти тексту.\n- Щоб подивитися різницю в бінарниках (дельта-кодування): `xdelta3`.\n- Для конвертування кодувань використовуйте `iconv`. Для більш складних завдань - `uconv`, він підтримує деякі складні фічі Юникода. Наприклад, ця команда переводить рядки з файлу в нижній регістр і прибирає наголоси (наприклад в іспанській мові)\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n- Для того, щоб розбити файл на шматки, використовуйте `split` (розбиває на шматки за розміром), або `csplit` (за шаблоном або по регулярному виразу).\n- Для дати і часу використовуйте  `dateadd`, `datediff`, `strptime` ще можете знайти на [`dateutils`](http://www.fresse.org/dateutils).\n- Використовуйте `zless`, `zmore`, `zcat`, і `zgrep` для роботи зі стиснутими файлами.\n\n\n## Відладка\n\n- Для відладки веб сторінок використовуйте `curl` і `curl -I`, або альтернативу - `wget` або [`httpie`](https://github.com/jakubroztocil/httpie).\n- Щоб отримати інформацію про диск/CPU/мережі використовуйте `iostat`, `netstat`, `top` (краще `htop`) і `dstat`. Використовуйте `iostat -mxz 15` для отримання основної інформації CPU.\n- Для інформації про мережу використовуйте `netstat` і `ss`.\n- Для більш детальної інформації використовуйте [`glances`](https://github.com/nicolargo/glances). Ця програма показує відразу кілька різних статистик в одному вікні терміналу. Корисно, коли стежите за відразу декількома системами.\n- Для того, щоб стежити за пам'яттю вокористовуйте `free` і `vmstat`. Зокрема, не забувайте, що значення кешування (\"cached\" value) - Це пам'ять, яку тримає ядро і ці значення є частиною `free`.\n- Використовуйте [`mtr`](http://www.bitwizard.nl/mtr/) для збору статистики трасування(простежити маршрут до віддаленого сервера), щоб знаходити проблеми мережі.\n- Для того, щоб дізнатися, чому диск повністю забитий, використовуйте [`ncdu`](https://dev.yorhel.nl/ncdu), це зберігає час у порівнянні з тим же `du -sh *`.\n- Для того, щоб дізнатися, який сокет або процес використовує інтернет, використовуйте [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) або [`nethogs`](https://github.com/raboof/nethogs).\n- Додаток `ab` який поставляється разом з apache, корисний для швидкої і поверхневої перевірки продуктивності веб-сервера. Для більш серйозного лоад-тестінгу використовуйте `siege`.\n- Для більш серйозної відладки мережі використовуйте [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), і [`ngrep`](http://ngrep.sourceforge.net/).\n- Знайте про `strace` та `ltrace`. Ці команди можуть бути корисні, якщо програма падає або висить, і ви не знаєте чому або якщо ви хочете протестувати продуктивність програми. Не забувайте про можливість відладки (`-c`) і можливість причепитися до процесу по pid (` -p`).\n- `ldd` для перевірки системних бібліотек.\n- Знайте як причепитися до працюючого процесу через `gdb` і отримати трасування стека.\n- Використовуйте `/proc`. Іноді він неймовірно корисний для налагодження запущених програм. Приклади: `/proc/cpuinfo`, `/proc/xxx/cwd`, ​​`/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (де `xxx` id or pid процесу).\n- Коли дебажите щось, що зламалося в минулому, використовуйте [`sar`](http://sebastien.godard.pagesperso-orange.fr/) буває дуже корисно. Показує історію та статистику CPU, пам'яті, мережі і т.д.\n- Для аналізу більш складних систем і продуктивності використовуйте `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](http://en.wikipedia.org/wiki/ Perf_(Linux)) і [`sysdig`](https://github.com/draios/sysdig).\n- Дізнайтеся, яка у вас операційна система, через `uname` або `uname -a` (інформація про ядро) або `lsb_release -a` (інформація про дистрибутив Linux).\n- Використовуйте `dmesg`, коли щось відбувається зовсім дивне (це можуть бути проблеми із залізом, драйверами, тощо).\n\n\n## Одним рядком\n\nКілька прикладів склеювання команд:\n- Це досить круто, що можна знайти множинни перетину файлів, з'єднати відсортовані файли і подивитися різницю декількох файлів через `sort`/`uniq`. Це швидкий підхід і працює на файлах будь-якого розміру (включаючи багатогігабайтні файли). (Сортування не обмежено пам'яттю, але можливо вам доведеться додати `-T`, якщо `/tmp` знаходиться на невеликому логічному диску). Ще подивіться на те, що було сказано вище про `LC_ALL`. Опція сортування `-u` не використовується нижче, щоб було зрозуміліше:\n```sh\n      cat a b | sort | uniq > c   # c is a union b\n      cat a b | sort | uniq -d > c   # c is a intersect b\n      cat a b b | sort | uniq -u > c   # c is set difference a - b\n```\n- Використовуйте `grep . *` для того, щоб подивитися вміст всіх файлів в директорії. Це може бути корисно для директорій заповнених конфігураціями як ці в `/sys`, `/proc`, `/etc`.\n- Просумувати всі числа, які знаходяться в третій колонці текстового файлу (це в 3 рази швидше і 3 рази простіше, ніж робити це в Пітоні) можна наступним чином:\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n- Щоб побачити розмір/дату файлів в дереві, це як рекурсивний `ls -l` але легше `ls -lR`:\n```sh\n      find . -type f -ls\n```\n- Скажемо що у нас є якийсь текстовий файл, наприклад лог веб сервера і на якихось рядках з'являється значення, рядки з яким нам цікаві. Наприклад, `acct_id`. Давайте підрахуємо, скільки таких запитів в нашім логу:\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n- Використовуйте `xargs` (або `parallel`). Зверніть увагу, що ви можете контролювати кількість команд на кожен рядок, а так само паралельність. Якщо ви не впевнені, що робите правильно, почніть з `xargs echo`. Ще `-I {}` - корисна штука. Приклади:\n```sh\n      find. -name '* .py' | xargs grep some_function\n      cat hosts | xargs -I {} ssh root @ {} hostname\n```\n- Запустіть цю функцію, щоб отримати випадкову вибірку із цього документа:\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## Складно але корисно\n\n- `expr`: для виконання арифметичних і булевих операцій, а також регулярних виразів\n- `m4`: простий макро-процесор\n- `yes`: безкінечно виводить рядок зі словом \"yes\"\n- `cal`: хороший календар\n- `env`: показує змінні середовища (корисно в Bash-скриптах)\n- `printenv`: показує змінні оточення (корисно в скриптах або при відладці)\n- `look`: виведе рядки у файлі які починаються із заданого слова/підрядка\n- `cut`, `paste` і `join`: маніпуляції з даними\n- `fmt`: форматування параграфів у тексті\n- `pr`: відформатовує текст в сторінки/колонки\n- `fold`: (обернути) обмежити довжину рядків у файлі\n- `column`: форматувати текст в колонки або таблиці\n- `expand` і `unexpand`: конвертація між табами і пробілами\n- `nl`: додає номери до рядків\n- `seq`: вивести послідовність чисел\n- `bc`: калькулятор\n- `factor`: піднести число в степінь\n- [`gpg`](https://gnupg.org/): зашифрувати і підписати файли\n- `toe`: таблиця терміналів terminfo з описом\n- `nc`: відладка мережі і передачі даних\n- `socat`: перемикач сокетів і перенаправлення tcp-портів (схоже на `netcat`)\n- [`slurm`](https://github.com/mattthias/slurm): візуалізація трафіку мережі\n- `dd`: перенесення інформації між файлами або пристроями\n- `file`: визначає тип файлу\n- `tree`: показує директорії і піддиректорії у вигляді дерева, як `ls`, але рекурсивно\n- `stat`: інформація про файл\n- `time`: виведе інформацію про час виконання команди/програми\n- `timeout`: зупиняє виконання команди після того як завершиться вказаний час в аргументі\n- `lockfile`: створює позначку в файлі який може бути видаленим тільки через команду `rm -f`\n- `logrotate`: змінити, зжати і відправити логи.\n- `watch`: запустити команду повторно, показуючи результати і/або виділення змін\n- `tac`: вивести файли посимвольно навпаки\n- `shuf`: випадкова вибірка рядків з файлу\n- `comm`: порядково порівняти відсортовані файли\n- `pv`: моніторинг прогресу проходження інформації через пайп\n- `hd`, `hexdump`, `xxd`, `biew` і `bvi`: дамп і редагування бінарних файлів\n- `strings`: витягнути текст із бінарних файлів\n- `tr`: маніпуляція з char (символьним типом)\n- `iconv` або `uconv`: конвертація кодувань\n- `split` і `csplit`: розбити файли\n- `sponge`: прочитати весь інпут перед тим, як його записати. Корисно, коли читаєш з того ж файлу, куди записуєш. Наприклад, ось так: `grep -v something some-file | sponge some-file`\n- `units`: використовується для конвертації одиниць вимірювання (дивіться `/usr/share/units/definitions.units`)\n- `apg`: генерація паролів\n- `7z`: архіватор з високим ступенем стиснення\n- `ldd`: показує залежності програми від системних бібліотек\n- `nm`: symbols from object files\n- `ab`: вбудований в Apache бенчмарк веб-серверів\n- `strace` або `wrk`: відладка системних викликів\n- [`mtr`](http://www.bitwizard.nl/mtr/): трасування для відладки мережі\n- `cssh`: паралельне виконання команд в графічному інтерфейсі\n- `rsync`: синхронізація файлів і папок через SSH або на локальній файловій системі\n- [`wireshark`](https://wireshark.org/) і [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): перехоплення пакетів і відладка мережі\n- [`ngrep`](http://ngrep.sourceforge.net/): grep мережевого рівня\n- `host` і `dig`: пошук в DNS\n- `lsof`: інформація про файлові дескриптори та сокети\n- `dstat`: корисна статистика ОС\n- [`glances`](https://github.com/nicolargo/glances): сумарна статистика багатьох підсистем\n- `iostat`: статистика системи вводу/виводу жорстких дисків\n- `mpstat`: статистика використання CPU\n- `vmstat`: статистика використання оперативної пам'яті\n- `htop`: вдосконалена версія `top`\n- `last`: історія входів у систему\n- `w`: хто є залогіненим\n- `id`: інформація про користувача/групу\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): historic system stats\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) або [`nethogs`](https://github.com/raboof/nethogs): використання мережі конкретним сокетом або процесом\n- `ss`: статистика сокетів\n- `dmesg`: помилки завантаження і помилки системи\n- `sysctl`: перегляду і налаштування параметрів ядра Linux коли воно запущене\n- `hdparm`: маніпуляція/налаштування SATA/ATA диску\n- `lsblk`: cписок блокових пристроїв комп'ютера: дерево ваших дисків і логічних дисків\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: інформація про апаратне забезпечення, включає CPU, BIOS, RAID, графічну карту і т.д.\n- `lsmod` і `modinfo`: показує список і детальну інформацію модулів ядра.\n- `fortune`, `ddate`, and `sl`: um, well, it depends on whether you consider steam locomotives and Zippy quotations \"useful\"\n\n\n## Тільки для OS X\n\nДеякі речі, які підходять *тільки* для Мака.\n\n- Система управління пакетами - `brew` (Homebrew) і `port` (MacPorts) можуть бути використані для того, щоб встановити більшість програм, згаданих у цьому документі.\n- Копіюйте вивід будь-якої консольної команди до графічної за допомогою `pbcopy` і вставляйте вивід за допомогою `pbpaste`.\n- Щоб відкрити файл або десктопну програму, використовуйте `open` або `open -a /Applications/Whatever.app`.\n- Spotlight: Шукає файли в консолі, через `mdfind`, і дивиться метадані (наприклад EXIF ​​інформацію із фотографії) із `mdls`.\n- Не забувайте, що MacOS створений на основі BSD Unix і багато команд (наприклад `ps`, `ls`, `tail`, `awk`, `sed`) мають невеликі відмінності від лінуксових. Це обумовлено впливом `UNIX System V` і `GNU Tools`. Різницю можна помітити, побачивши заголовок \"BSD General Commands Manual.\" Інколи на MacOS можна поставити GNU-версії програм, наприклад `gawk` і `gsed`. Коли пишете кросплатформені Bash-скрипти, намагайтеся уникати використовувати команди, які можуть відрізнятися (наприклад, краще використовуйте Python або `perl`), або ретельно все перевіряйте.\n\n\n## Тільки для Windows\n\n- Ви можете використовувати Unix shell у Windows, встановивши [Cygwin](https://cygwin.com/).\n- Встановіть ще Unix програми за допомогою менеджера пакетів Cygwin.\n- Використовуйте `mintty` в якості термінала.\n- Ви можете працювати із буфером обміну Windows за допомогою `/dev/clipboard`.\n- Запустіть `cygstart`, щоб відкрити файл за допомогою програми, що встановлена за замовчуванням.\n- Працювати з реєстром Windows можна за допомогою `regtool`.\n- Майте на увазі, що диск `C:\\` доступний в Cygwin за шляхом `/cygdrive/c`, `/` являється папкою `C:\\cygwin`. Конвертуйте шляхи до файлів за допомогою `cygpath`.\n- Ви можете запускати і автоматизувати більшість задач з адміністрування Windows із командного рядка, оволодівши `wmic`.\n\n\n## Інші джерела\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): Розширює Shell.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): Поглиблений посібник до командного рядка OS X.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) щоб краще писати Shell скрипти.\n- [shellcheck](https://github.com/koalaman/shellcheck): A shell script static analysis tool. Essentially, lint for bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): The sadly complex minutiae on how to handle filenames correctly in shell scripts.\n\n\n## Відмова від відповідальності\n\nЗа невеликим винятком, весь код написаний так, щоб інші його змогли прочитати.\nТой факт, що щось може бути написано на Bash, зовсім не означає, що воно має бути на ньому написано. ;)\n\n\n## Ліцензія\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nЦя работа і переклад на Українську мову розповсюджується за ліцензією [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "README-zh-Hant.md",
          "type": "blob",
          "size": 31.41,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n# 命令列的藝術\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [必讀](#必讀)\n- [基礎](#基礎)\n- [日常使用](#日常使用)\n- [檔案及資料處理](#檔案及資料處理)\n- [系統偵錯](#系統偵錯)\n- [單行指令碼](#單行指令碼)\n- [冷門但有用的指令](#冷門但有用的指令)\n- [僅限 OS X 系統](#僅限-os-x-系統)\n- [僅限 Windows 系統](#僅限-windows-系统)\n- [更多資源](#更多資源)\n- [免責聲明](#免責聲明)\n- [授權條款](#授權條款)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\n熟練使用命令列是一種常常被忽視，或被認為難以掌握的技能，但實際上，它會提高你作為工程師的靈活性以及生產力。本文是一份我在 Linux 上工作時，發現的一些命令列使用技巧的摘要。有些技巧非常基礎，而另一些則相當複雜，甚至晦澀難懂。這篇文章並不長，但當你能夠熟練掌握這裡列出的所有技巧時，你就學會了很多關於命令列的東西了。\n\n這篇文章是[許多作者和譯者](AUTHORS.md)共同的成果。這裡的大部分內容\n[首次](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[出現](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n於 [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know)，但考慮到這裡的人們都具有學習的天賦且樂於接受別人的建議，使用 Github 來做這件事是更佳的選擇。如果你在本文中發現了錯誤或者​​存在可以改善的地方，請果斷提交 Issue 或 Pull Request！ (當然在提交前請看一下必讀節和已有的 PR/issue）。\n\n\n## 必讀\n\n涵蓋範圍：\n\n- 這篇文章對剛接觸命令列的新手以及具有命令列使用經驗的人都有用處。本文致力於做到*覆蓋面廣*（盡量包括一切重要的內容），*具體*（給出最常見的具體的例子）以及*簡潔*（避免不必要的，或是可以在其他地方輕鬆查到的細枝末節）。每個技巧都是在特定情境下必備的，或是能顯著減省時間的。\n- 本文為 Linux 所寫，除了 [僅限OS X 系統](#僅限-os-x-系統) 和 [僅限 Windows 系統](#僅限-windows-系统) 章節外，其它章節中的大部分內容都適用於其它 Unix 系統或 MacOS 系統，甚至 Cygwin。\n- 本文關注於互動式 Bash，儘管很多技巧也適用於其他 shell 或 Bash 指令碼。\n- 本文包括了“標準的” Unix 命令和需要安裝特定套件的命令，只要它們足夠重要。\n\n注意事項：\n\n- 為了能在一頁內展示盡量多的東西，一些具體的資訊會被間接的包含在引用頁裡。聰明機智的你如果掌握了使用 Google 搜尋引擎的基本方法與命令，那麼你將可以查閱到更多的詳細資訊。使用`apt-get`，`yum`，`dnf`，`pacman`，`pip` 或`brew`（以及其它合適的包管理器）來安裝新程式。\n- 使用 [Explainshell](http://explainshell.com/) 去獲取相關命令、參數、管道等解釋。\n\n\n## 基礎\n\n- 學習 Bash 的基礎知識。具體來說，輸入`man bash` 並至少全文瀏覽一遍; 它很簡單並且不長。其他的 shell 可能很好用，但 Bash 功能強大且幾乎所有情況下都是可用的（ *只*學習 zsh，fish 或其他的 shell 的話，在你自己的電腦上會顯得很方便，但在很多情況下會限制你，比如當你需要在伺服器上工作時）。\n\n- 學習並掌握至少一個基於文字的編輯器。通常 Vim （`vi`） 會是你最好的選擇，因為在終端裡進行隨機編輯 Vim 真的毫無敵手，哪怕是Emacs、某大型IDE 甚至時下非常流行的編輯器。\n\n- 學會如何使用`man` 命令去閱讀文件。學會使用 `apropos` 去查詢文件。瞭解有些命令是不可執行，而是Bash內建的，可以使用`help` 和`help -d` 命令獲取幫助資訊。\n\n- 學會使用`>` 和`<` 來重定向輸出和輸入，學會使用`|` 來重定向管道。明白`>` 會覆蓋了輸出文件而`>>` 是在檔案末新增。瞭解標準輸出 stdout 和標準錯誤 stderr。\n\n- 學會使用通配符`*` （或許再算上`?` 和`[`...`]`） 和引用以及引用中`'` 和`\"` 的區別。\n\n- 熟悉 Bash 任務管理工具：`&`，**ctrl-z**，**ctrl-c**，`jobs`，`fg`，`bg`，`kill` 等。\n\n- 瞭解`ssh`，以及學會通過使用`ssh-agent`，`ssh-add` 等命令來實現基本的無密碼認證。\n\n- 學會基本的檔案管理：`ls` 和`ls -l` （瞭解`ls -l` 中每一列代表的意義），`less`，`head`，`tail` 和`tail -f` （甚至`less +F`），`ln` 和`ln -s` （瞭解硬連結與軟連結的區別），`chown`，`chmod`，`du` （硬碟使用情況概述：`du -hs *` ）。關於檔案系統的管理，學習`df`，`mount`，`fdisk`，`mkfs`，`lsblk`。知道 inode 是什麼（與`ls -i` 和`df -i` 等命令相關）。\n\n- 學習基本的網路管理：`ip` 或`ifconfig`，`dig`。\n\n- 熟悉正規表示式，以及`grep`／`egrep` 裡不同參數的作用，例如`-i`，`-o`，`-v`，`-A`，`-B` 和`-C` ，這些參數是值得學習並掌握的。\n\n- 學會使用`apt-get`，`yum`，`dnf` 或`pacman` （取決於你使用的 Linux 發行版）來查詢或安裝軟體包。並確保你的環境中有`pip` 來安裝基於 Python 的命令列工具（接下來提到的部分程式使用`pip` 來安裝會很方便）。\n\n\n## 日常使用\n\n- 在 Bash 中，可以使用 **Tab** 自動補全參數，使用 **ctrl-r** 搜尋命令列歷史（在按下之後，鍵入便可以搜尋，重複按下**ctrl-r**會在更多匹配中迴圈，按下 **Enter** 會執行找到的命令，按下右方向鍵會將結果放入當前行中，使你可以進行編輯）。\n\n- 在 Bash 中，可以使用 **ctrl-w** 刪除你鍵入的最後一個單詞，使用 **ctrl-u** 刪除當前游標所在位置之前的內容，使用 **alt-b** 和 **alt-f**以單詞為單位移動游標，​​使用 **ctrl-a** 將游標移至行首，使用 **ctrl-e** 將游標移至行尾，使用 **ctrl-k** 刪除游標至行尾的所有內容，使用 **ctrl-l** 清屏。鍵入`man readline` 檢視 Bash 中的預設快捷鍵，內容很多。例如 **alt-.** 迴圈地移向前一個參數，以及 **alt-*** 展開通配符。\n\n- 你喜歡的話，可以鍵入`set -o vi` 來使用vi 風格的快捷鍵，而`set -o emacs` 可以把它改回來。\n\n- 為了方便地鍵入長命令，在設定你的編輯器後（例如`export EDITOR=vim`），鍵入 **ctrl-x** **ctrl-e** 會開啟一個編輯器來編輯當前命令。在 vi 模式下則鍵入 **escape-v** 實現相同的功能。\n\n- 鍵入 `history` 檢視命令列歷史記錄。其中有許多縮寫，例如`!$`（最後鍵入的參數）和`!!`（最後鍵入的命令），儘管通常被 **ctrl-r** 和 **alt-.** 取代。\n\n- 回到上一個工作路徑：`cd -`\n\n- 如果你輸入命令的時候改變了主意，按下 **alt-#** 來在行首新增`#`，或者依次按下 **ctrl-a**， **#**， **enter**。這樣做的話，之後你可以很方便的利用命令列歷史回到你剛才輸入到一半的命令。\n\n- 使用 `xargs` （ 或 `parallel`），他們非常強大。注意到你可以控制每行參數的個數（`-L`）和最大並行數（`-P`）。如果你不確定它們是否會按你想的那樣工作，先使用`xargs echo` 檢視一下。此外，使用 `-I{}` 會很方便。例如：\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` 有助於展示程序樹。\n\n- 使用`pgrep` 和`pkill` 根據名字查詢程序或傳送訊號（`-f` 參數通常有用）。\n\n- 瞭解你可以發往程序的訊號的種類。比如，使用`kill -STOP [pid]` 停止一個程序。使用 `man 7 signal` 檢視詳細列表。\n\n- 使用`nohup` 或`disown` 使一個後臺程序持續運行。\n\n- 使用`netstat -lntp` 或`ss -plat` 檢查哪些程序在監聽埠（預設是檢查 TCP 埠; 使用參數`-u` 檢查 UDP 埠）。\n\n- 有關開啟 socket 和檔案，請參閱`lsof`。\n\n- 使用`uptime` 或`w` 來檢視系統已經運行多長時間。\n\n- 使用`alias` 來創建常用命令的快捷形式。例如：`alias ll='ls -latr'` 使你可以方便地執行`ls -latr`命令。\n\n- 在 Bash 指令碼中，使用`set -x` 去偵錯輸出，盡可能的使用嚴格模式，使用`set -e` 令指令碼在發生錯誤時退出而不是繼續運行，使用`set -u` 來檢查是否使用了未賦值的變數，使用`set -o pipefail` 嚴謹地對待錯誤（儘管問題可能很微妙）。當牽扯到很多指令碼時，使用 `trap`。一個好的習慣是在指令碼檔案開頭這樣寫，這會使它檢測一些錯誤，並在錯誤發生時中斷程式並輸出資訊：\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- 在 Bash 指令碼中，子 shell（使用括號`(...)`）是一種組織參數的便捷方式。一個常見的例子是臨時地移動工作路徑，程式碼如下：\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- 在 Bash 中，要注意其中有許多形式的擴展。檢查變數是否存在：`${name:?error message}`。例如，當 Bash 指令碼需要一個參數時，可以使用這樣的程式碼`input_file=${1:?usage: $0 input_file}`。數學表示式：`i=$(( (i + 1) % 5 ))`。序列：`{1..10}`。截斷字元串：`${var%suffix}` 和`${var#prefix}`。例如，假設`var=foo.pdf`，那麼`echo ${var%.pdf}.txt` 將輸出`foo.txt`。\n\n- 使用括號擴展（`{`...`}`）來減少輸入相似文字，並自動化文字組合。這在某些情況下會很有用，例如`mv foo.{txt,pdf} some-dir`（同時移動兩個檔案），`cp somefile{,.bak}`（會被擴展成`cp somefile somefile .bak`）或者`mkdir -p test-{a,b,c}/subtest-{1,2,3}`（會被擴展成所有可能的組合，並創建一個目錄樹）。\n\n- 通過使用`<(some command)` 可以將輸出視為檔案。例如，對比本地檔案`/etc/hosts` 和一個​​遠端檔案：\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- 瞭解 Bash 中的“here documents”，例如`cat <<EOF ...`。\n\n- 在 Bash 中，同時重定向標準輸出和標準錯誤，`some-command >logfile 2>&1`。通常，為了保證命令不會在標準輸入裡殘留一個開啟了的檔案控制代碼導致你當前所在的終端無法操作，新增`</dev/null` 是一個好習慣。\n\n- 使用`man ascii` 檢視具有十六進位制和十進位制值的ASCII表。 `man unicode`，`man utf-8`，以及`man latin1` 有助於你去了解通用的編碼資訊。\n\n- 使用`screen` 或[`tmux`](https://tmux.github.io/) 來使用多個螢幕，當你在使用 ssh 時（儲存session 資訊）特別有用。另一個輕量級的解決方案是 `dtach`。\n\n- ssh 中，瞭解如何使用`-L` 或`-D`（偶爾需要用`-R`）去開啟通道是非常有用的，例如當你需要從一臺遠端伺服器上訪問 web。\n\n- 對 ssh 設定做一些小優化可能是很有用的，例如這個`​​~/.ssh/config` 檔案包含了防止特定環境下斷開連線、壓縮資料、多通道等選項：\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- 部分其他的關於 ssh 的選項是安全敏感且應當小心啟用的。例如在可信任的網路中：`StrictHostKeyChecking=no`，`ForwardAgent=yes`\n\n- 考慮使用[`mosh`](https://mosh.org/) 作為 ssh 的替代品，它使用 UDP 協議。\n\n- 獲取檔案的八進位制格式許可權，使用類似如下的程式碼：\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 使用[`percol`](https://github.com/mooz/percol) 或者[`fzf`](https://github.com/junegunn/fzf) 可以互動式地從另一個命令輸出中選取值。\n\n- 使用`fpp`（[PathPicker](https://github.com/facebook/PathPicker)）可以與基於另一個命令(例如`git`）輸出的檔案互動。\n\n- 要基於當前目錄(以及子目錄)建立一個簡易的 web 伺服器給所處網路的所有使用者，可以使用：`python -m SimpleHTTPServer 7777` （使用埠 7777 和 Python 2）或`python -m http.server 7777` （使用埠 7777 和 Python 3）。\n\n- 以某種許可權執行命令，使用`sudo`（root 許可權）或`sudo -u`（其他使用者）。使用`su`或者`sudo bash`來啟動一個以對應使用者許可權運行的shell。使用`su -`模擬其他使用者的登入。\n\n## 檔案及資料處理\n\n- 在當前路徑下通過檔名定位一個檔案，`find . -iname '*something*'`（或類似的）。在所有路徑下通過檔名查詢檔案，使用`locate something` （但請記住`updatedb` 可能沒有對最近新建的檔案建立索引）。\n\n- 使用[`ag`](https://github.com/ggreer/the_silver_searcher) 在原始碼或資料檔案裡檢索（比`grep -r` 更好）。\n\n- 將 HTML 轉為文字：`lynx -dump -stdin`\n\n- Markdown，HTML，以及所有文件格式之間的轉換，試試[`pandoc`](http://pandoc.org/)。\n\n- 如果你不得不處理 XML，`xmlstarlet` 寶刀未老。\n\n- 使用[`jq`](http://stedolan.github.io/jq/) 處理 JSON。\n\n- 使用[`shyaml`](https://github.com/0k/shyaml) 處理 YAML。\n\n- Excel 或 CSV 檔案的處理，[csvkit](https://github.com/onyxfish/csvkit) 提供了`in2csv`，`csvcut`，`csvjoin`，`csvgrep` 等工具。\n\n- 關於 Amazon S3，[`s3cmd`](https://github.com/s3tools/s3cmd) 很方便，而[`s4cmd`](https://github.com/bloomreach/s4cmd) 更快。 Amazon 官方的[`aws`](https://github.com/aws/aws-cli) 以及[`saws`](https://github.com/donnemartin/saws) 是其他 AWS 相關工作的基礎。\n\n- 瞭解如何使用`sort` 和`uniq`，包括 uniq 的`-u` 參數和`-d` 參數，詳見後文單行指令碼節。另外可以瞭解一下 `comm`。\n\n- 瞭解如何使用`cut`，`paste` 和`join` 來更改檔案。很多人都會使用`cut`，但幾乎都不會使用`join`。\n\n- 瞭解如何運用`wc` 去計算新行數（`-l`），字元數（`-m`），單詞數（`-w`）以及位位元數（`-c`）。\n\n- 瞭解如何使用`tee` 將標準輸入複製到檔案甚至標準輸出，例如`ls -al | tee file.txt`。\n\n- 瞭解語言環境對許多命令列工具的微妙影響，包括排序的順序和效能。大多數 Linux 的安裝過程會將`LANG` 或其他有關的變數設定為符合本地的設定。意識到當你改變語言環境時，排序的結果可能會改變。明白國際化可能會使 sort 或其他命令運行效率下降*許多倍*。某些情況下（例如集合運算）你可以放心的使用`export LC_ALL=C` 來忽略掉國際化並使用基於位元組的順序。\n\n- 瞭解`awk` 和`sed` 關於資料的簡單處理的用法。例如，將文字檔案中第三列的所有數字求和：`awk '{ x += $3 } END { print x }'`. 這可能比同等作用的 Python 程式碼快三倍且程式碼量少三倍。\n\n- 替換一個或多個檔案中出現的字元：\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 使用[`repren`](https://github.com/jlevy/repren) 來批次重新命名，或是在多個檔案中搜索替換。（有些時候`rename` 命令也可以批次重新命名，但要注意，它在不同 Linux 發行版中的功能並不完全一樣。）\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- 根據 man 頁面的描述，`rsync` 真的是一個快速且非常靈​​活的檔案複製工具。它通常被用於機器間的同步，但在本地也同樣有用。它同時也是刪除大量檔案的[最快方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove -huge-number-of-files.html)之一：\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- 使用`shuf` 從一個檔案中隨機選取多行。\n\n- 瞭解 `sort` 的參數。處理數字方面，使用`-n` 或者`-h` 來處理可讀性數字（例如`du -h` 的輸出）。明白鍵的工作原理（`-t` 和 `-k`）。例如，注意到你需要`-k1，1` 來按照第一個欄位來排序，而`-k1` 意味著按照整行排序。穩定排序（`sort -s`）在某些情況下很有用。例如，以第二個欄位為主關鍵字，第一個欄位為次關鍵字進行排序，你可以使用`sort -k1，1 | sort -s -k2，2`。\n\n- 如果你想在 Bash 命令列中寫 tab 製表符，按下**ctrl-v** **[Tab]** 或鍵入`$'\\t'` （後者可能更好，因為你可以複製貼上它）。\n\n- 標準的原始碼對比及合併工具是`diff` 和`patch`。使用 `diffstat` 檢視變更總覽資料。注意到 `diff -r` 對整個資料夾有效。使用`diff -r tree1 tree2 | diffstat` 檢視變更總覽資料。\n\n- 對於二進制檔案，使用`hd` 使其以十六進位制顯示以及使用`bvi` 來編輯二進位制。\n\n- 同樣對於二進制檔案，`strings`（包括`grep` 等等）允許你查詢一些文字。\n\n- 二進制檔案對比（Delta 壓縮），使用`xdelta3`。\n\n- 轉換文字編碼可使用 `iconv` 或 `uconv`，後者支援 Unicode 相關的進階用法。例如：\n```sh\n      # 顯示十六進制碼或字元標準名稱（有益於除錯）\n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < input.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < input.txt\n      # 將文字轉換為小寫並移除所有重音標記（展開字元並移除標記）：\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC;' < input.txt > output.txt\n```\n\n- 拆分檔案，檢視`split`（按大小拆分）和`csplit`（按模式拆分）。\n\n- 用[`dateutils`](http://www.fresse.org/dateutils/) 中的`dateadd`, `datediff`, `strptime` 等工具操作日期和時間表示式。\n\n- 使用`zless`，`zmore`，`zcat` 和`zgrep` 對壓縮過的檔案進行操作。\n\n\n## 系統偵錯\n\n- `curl` 和`curl -I` 可以便捷地被應用於 web 偵錯，它們的好兄弟`wget` 也可以，或者是更潮的[`httpie`](https://github.com/jakubroztocil /httpie)。\n\n- 使用`iostat`、`netstat`、`top` （`htop` 更佳）和`dstat` 去獲取硬碟、cpu 和網路的狀態。熟練掌握這些工具可以使你快速的對系統的當前狀態有一個大概的認識。\n\n- 使用`netstat` 和`ss` 檢視網路連線的細節。\n\n- 若要對系統有一個深度的總體認識，使用[`glances`](https://github.com/nicolargo/glances)。它在一個終端視窗中向你提供一些系統層級的資料。這對於快速的檢查各個子系統非常有幫助。\n\n- 若要了解記憶體狀態，運行並理解`free` 和`vmstat` 的輸出。尤其注意 “cached” 的值，它指的是 Linux 核心用來作為檔案快取的記憶體大小，因此它與空閒記憶體無關。\n\n- Java 系統偵錯則是一件截然不同的事，一個可以用於 Oracle 的 JVM 或其他 JVM 上的偵錯的技巧是你可以運行`kill -3 <pid>` 同時一個完整的棧軌跡和堆概述（包括 GC 的細節）會被儲存到標準輸出/日誌檔案。 JDK 中的`jps`，`jstat`，`jstack`，`jmap` 很有用。 [SJK tools](https://github.com/aragozin/jvm-tools) 更高階.\n\n- 使用[`mtr`](http://www.bitwizard.nl/mtr/) ​​去跟蹤路由，用於確定網路問題。\n\n- 用[`ncdu`](https://dev.yorhel.nl/ncdu) 來檢視磁碟使用情況，它比常用的命令，如`du -sh *`，更節省時間。\n\n- 查詢正在使用頻寬的 socket 連線或程序，使用[`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或[`nethogs`](https://github.com/raboof/nethogs)。\n\n- `ab` 工具（內建於Apache）可以簡單粗暴地檢查 web 伺服器的效能。對於更複雜的負載測試，使用`siege`。\n\n- [`wireshark`](https://wireshark.org/)，[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) 和[`ngrep`](http://ngrep.sourceforge.net/) 可用於復雜的網路偵錯。\n\n- 瞭解 `strace` 和 `ltrace`。這倆工具在你的程式運行失敗、掛起甚至崩潰，而你卻不知道為什麼或你想對效能有個總體的認識的時候是非常有用的。注意 profile 參數（`-c`）和附加到一個運行的程序參數（`-p`）。\n\n- 瞭解使用 `ldd` 來檢查共享庫。\n\n- 瞭解如何運用`gdb` 連線到一個運行著的程序並獲取它的堆棧軌跡。\n\n- 學會使用 `/proc`。它在偵錯正在出現的問題的時候有時會效果驚人。比如：`/proc/cpuinfo`，`/proc/meminfo`，`/proc/cmdline`，`/proc/xxx/cwd`，`/proc/xxx/exe`，`/proc/xxx/fd/` ，`/proc/xxx/smaps`（這裡的`xxx` 表示程序的 id 或 pid）。\n\n- 當偵錯一些之前出現的問題的時候，[`sar`](http://sebastien.godard.pagesperso-orange.fr/) 非常有用。它展示了 cpu、記憶體以及網路等的歷史資料。\n\n- 關於更深層次的系統分析以及效能分析，看看`stap`（[SystemTap](https://sourceware.org/systemtap/wiki)），[`perf`](http://en.wikipedia.org /wiki/Perf_(Linux))，以及[`sysdig`](https://github.com/draios/sysdig)。\n\n- 檢視你當前使用的系統，使用`uname` ， `uname -a` （Unix／kernel 資訊） 或者`lsb_release -a` （Linux 發行版資訊）。\n\n- 無論什麼東西工作得很歡樂時試試`dmesg`（可能是硬體或驅動問題）。\n\n\n## 單行指令碼\n\n一些命令組合的例子：\n\n- 當你需要對文字檔案做集合交、並、差運算時，結合使用`sort`/`uniq` 很有幫助。假設 `a` 與 `b` 是兩內容不同的檔案。這種方式效率很高，並且在小檔案和上G的檔案上都能運用（`sort` 不被記憶體大小約束，儘管在`/tmp` 在一個小的根分區上時你可能需要`-T ` 參數），參閱前文中關於`LC_ALL` 和`sort` 的`-u` 參數的部分。\n```sh\n      cat a b | sort | uniq > c # c is a union b\n      cat ab | sort | uniq -d > c # c is a intersect b\n      cat abb | sort | uniq -u > c # c is set difference a - b\n```\n\n- 使用`grep . *`（每行都會附上檔名）或者`head -100 *`（每個檔案有一個標題）來閱讀檢查目錄下所有檔案的內容。這在檢查一個充滿配置檔案的目錄（如`/sys`、`/proc`、`/etc`）時特別好用。\n\n- 計算文字檔案第三列中所有數的和（可能比同等作用的Python 程式碼快三倍且程式碼量少三倍）：\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- 如果你想在檔案樹上檢視大小/日期，這可能看起來像遞迴版的`ls -l` 但比`ls -lR` 更易於理解：\n```sh\n      find . -type f -ls\n```\n\n- 假設你有一個類似於 web 伺服器日誌檔案的文字檔案，並且一個確定的值只會出現在某些行上，假設一個`acct_id` 參數在URI中。如果你想計算出每個`acct_id` 值有多少次請求，使用如下程式碼：\n```sh\n      cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 運行這個函數從這篇文件中隨機獲取一條技巧（解析 Markdown 檔案並抽取項目）：\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n\n## 冷門但有用的指令\n\n- `expr`：計算表示式或正規表示法\n\n- `m4`：簡易的巨集處理器\n\n- `yes`：列印多次字串\n\n- `cal`：漂亮的日曆\n\n- `env`：執行一個命令（指令碼中很有用）\n\n- `printenv`：列印環境變數（偵錯時或在使用指令碼時很有用）\n\n- `look`：查詢以特定字元串開頭的單詞\n\n- `cut`、`paste` 和 `join`：資料操作\n\n- `fmt`：格式化文字段落\n\n- `pr`：將文字格式化成頁/列形式\n\n- `fold`：包裹文字中的幾行\n\n- `column`：將文字格式化成多列或表格\n\n- `expand` 和`unexpand`：在 tab 與空格之間轉換\n\n- `nl`：新增行號\n\n- `seq`：列印數字\n\n- `bc`：計算機\n\n- `factor`：分解因數\n\n- [`gpg`](https://gnupg.org/)：加密並針對檔案簽章\n\n- `toe`：terminfo entries 列表\n\n- `nc`：網路偵錯及資料傳輸\n\n- `socat`：socket 代理，與 `netcat` 類似\n\n- [`slurm`](https://github.com/mattthias/slurm)：網路流量視覺化\n\n- `dd`：在檔案或裝置間傳輸資料\n\n- `file`：確定檔案類型\n\n- `tree`：以樹的形式顯示路徑和檔案，類似於遞迴的`ls`\n\n- `stat`：檔案資訊\n\n- `time`：執行命令，同時計算執行時間\n\n- `lockfile`：使檔案只能通過`rm -f` 移除\n\n- `logrotate`: 切換、壓縮以及傳送日誌檔案\n\n- `watch`：重複運行同一個命令，展示結果並 highlight 有更改的部分\n\n- `tac`：反向輸出文件\n\n- `shuf`：檔案中隨機選取幾行\n\n- `comm`：一行一行的比較排序過的檔案\n\n- `pv`：監視通過 pipe 的資料\n\n- `hd`，`hexdump`，`xxd`，`biew` 和`bvi`：儲存或編輯二進位檔案\n\n- `strings`：從二進位檔案中抽取文字\n\n- `tr`：轉換字母\n\n- `iconv` 或 `uconv`：簡易的檔案編碼\n\n- `split` 和 `csplit`：分割檔案\n\n- `sponge`：在寫入前讀取所有輸入，在讀取檔案後再向同一檔案寫入時比較有用，例如`grep -v something some-file | sponge some-file`\n\n- `units`：將一種計量單位轉換為另一種等效的計量單位（參閱`/usr/share/units/definitions.units`）\n\n- `apg`：隨機生成密碼\n\n- `7z`：高比例的檔案壓縮\n\n- `ldd`：動態庫資訊\n\n- `nm`：提取 obj 檔案中的符號\n\n- `ab`：效能分析 web 伺服器\n\n- `strace`：系統呼叫偵錯\n\n- [`mtr`](http://www.bitwizard.nl/mtr/)：更好的網路偵錯跟蹤工具\n\n- `cssh`：視覺化的並發 shell\n\n- `rsync`：通過ssh 或本地檔案系統同步檔案和資料夾\n\n- [`wireshark`](https://wireshark.org/) 和[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)：抓包和網路偵錯工具\n\n- [`ngrep`](http://ngrep.sourceforge.net/)：網路層的 grep\n\n- `host` 和 `dig`：DNS 查詢\n\n- `lsof`：列出當前系統開啟檔案的工具以及檢視埠資訊\n\n- `dstat`：系統狀態檢視\n\n- [`glances`](https://github.com/nicolargo/glances)：高層次的多子系統總覽\n\n- `iostat`：硬碟使用狀態\n\n- `mpstat`: CPU 使用狀態\n\n- `vmstat`: 記憶體使用狀態\n\n- `htop`：top 的加強版\n\n- `last`：登入記錄\n\n- `w`：檢視處於登入狀態的使用者\n\n- `id`：使用者/組 ID 資訊\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/)：系統歷史資料\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或[`nethogs`](https://github.com/raboof/nethogs)：套接字及程序的網路利用\n\n- `ss`：socket 資料\n\n- `dmesg`：引導及系統錯誤資訊\n\n- `sysctl`: 在核心運行時動態地檢視和修改內核的運行參數\n\n- `hdparm`：SATA/ATA 磁碟更改及效能分析\n\n- `lsblk`：列出塊裝置資訊：以樹形展示你的磁碟以及磁碟分區資訊\n\n- `lshw`，`lscpu`，`lspci`，`lsusb` 和`dmidecode`：檢視硬體資訊，包括CPU、BIOS、RAID、顯示卡、USB裝置等\n\n- `lsmod` 和`modinfo`：列出核心模組，並顯示其細節\n\n- `fortune`，`ddate` 和`sl`：額，這主要取決於你是否認為蒸汽火車和莫名其妙的名人名言是否“有用”\n\n## 僅限 OS X 系統\n\n以下是*僅限於* MacOS 系統的技巧\n\n- 用`brew` （Homebrew）或者`port` （MacPorts）進行套件管理。這些可以用來在 Mac 系統上安裝以上的大多數命令。\n\n- 用`pbcopy` 複製任何命令的輸出到桌面應用，用`pbpaste` 貼上輸入。\n\n- 若要在 Mac OS 終端中將 Option 鍵視為 alt 鍵（例如在上面介紹的**alt-b**, **alt-f** 等命令中用到），開啟偏好設定-> 描述檔案-> 鍵盤並勾選“使用 Option 鍵作為 Meta 鍵”。\n\n- 用`open` 或者`open -a /Applications/Whatever.app` 使用桌面應用開啟檔案。\n\n- Spotlight： 用`mdfind` 搜尋檔案，用`mdls` 列出後設資料（例如照片的EXIF 資訊）。\n\n- 注意 MacOS 系統是基於BSD UNIX 的，許多命令（例如`ps`，`ls`，`tail`，`awk`，`sed`）都和 Linux 中有些微的不同，這些指令主要是被 System V -style Unix 和 GNU 工具影響。你可以透過標題為\"BSD General Commands Manual\" 的 man 頁面發現這些不同。在有些情況下 GNU 版本的命令也可能被安裝（例如`gawk` 和`gsed` 對應GNU 中的awk 和sed ）。如果要寫跨平臺的 Bash 指令碼，避免使用這些命令（例如，考慮 Python 或者`perl` ）或者經過仔細的測試。\n\n- 用 `sw_vers` 獲取 MacOS 的版本資訊。\n\n\n## 僅限 Windows 系统\n\n- 要在 Microsoft Windows 中使用 Unix shell，可以安装 [Cygwin](https://cygwin.com/)。本文件中介绍的大多數内容都將適用。\n\n- 透過 Cygwin 的套件管理器來安裝額外的 Unix 指令。\n\n- 使用 `mintty` 作為你的命令列視窗。\n\n- 要訪問 Windows 剪貼簿，可以透過 `/dev/clipboard`。\n\n- 執行 `cygstart` 以透過預設程式打開一個文件。\n\n- 要訪問 Windows 登錄檔，可以使用 `regtool`。\n\n- 注意 Windows 磁碟機路徑 `C:\\` 在 Cygwin 中用 `/cygdrive/c` 代表，而 Cygwin 的 `/` 在 Windows 中顯示在 `C:\\cygwin`。要轉換 Cygwin 和 Windows 風格的路徑可以用 `cygpath`。這在需要使用 Windows 指令的脚本裡很有用。\n\n- 學會使用 `wmic`，你就可以從命令列執行大多數 Windows 系統管理任務，並編成腳本。\n\n## 更多資源\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell)：一份精美的命令列工具及資源的列表。\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)：一份針對 Mac OS 命令列的更深入的指南。\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)：為了編寫更好的指令碼檔案。\n- [shellcheck](https://github.com/koalaman/shellcheck)：一個靜態shell 指令碼分析工具，本質上是 bash／sh／zsh 的lint。\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)：有關如何在 shell 腳本里正確處理檔名的細枝末節。\n\n\n## 免責聲明\n\n除去特別微小的任務，編寫程式碼是出於方便閱讀的目的。能力往往伴隨著責任。你 *可以* 在 Bash 中做一些事並不意味著你應該去做！ ;)\n\n\n## 授權條款\n\n[![創作共用License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\n本文使用授權協議 [知識共享署名 - 相同方式共享 4.0 國際許可](http://creativecommons.org/licenses/by-sa/4.0/)。\n"
        },
        {
          "name": "README-zh.md",
          "type": "blob",
          "size": 39.6,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# 命令行的艺术\n\n[![Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n- [前言](#前言)\n- [基础](#基础)\n- [日常使用](#日常使用)\n- [文件及数据处理](#文件及数据处理)\n- [系统调试](#系统调试)\n- [单行脚本](#单行脚本)\n- [冷门但有用](#冷门但有用)\n- [仅限 OS X 系统](#仅限-os-x-系统)\n- [仅限 Windows 系统](#仅限-windows-系统)\n- [更多资源](#更多资源)\n- [免责声明](#免责声明)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\n熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\n\n这篇文章是[许多作者和译者](AUTHORS.md)共同的成果。\n这里的部分内容\n[首次](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[出现](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n于 [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know)，\n但已经迁移到了 GitHub，并由众多高手做出了许多改进。\n如果你在本文中发现了错误或者存在可以改善的地方，请[**贡献你的一份力量**](/CONTRIBUTING.md)。\n\n## 前言\n\n涵盖范围：\n\n- 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到*覆盖面广*（涉及所有重要的内容），*具体*（给出具体的最常用的例子），以及*简洁*（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。\n- 本文主要为 Linux 所写，但在[仅限 OS X 系统](#仅限-os-x-系统)章节和[仅限 Windows 系统](#仅限-windows-系统)章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。\n- 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。\n- 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。\n\n注意事项：\n\n- 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 `apt-get`，`yum`，`dnf`，`pacman`，\n`pip` 或 `brew`（以及其它合适的包管理器）来安装依赖的程序。\n- 遇到问题的话，请尝试使用 [Explainshell](http://explainshell.com/) 去获取相关命令、参数、管道等内容的解释。\n\n\n## 基础\n\n- 学习 Bash 的基础知识。具体地，在命令行中输入 `man bash` 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你*只*学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。\n\n- 熟悉至少一个基于文本的编辑器。通常而言 Vim （`vi`） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。\n\n- 学会如何使用 `man` 命令去阅读文档。学会使用 `apropos` 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 `help` 和 `help -d` 命令获取帮助信息。你可以用 `type 命令` 来判断这个命令到底是可执行文件、shell 内置命令还是别名。\n\n- 学会使用 `>` 和 `<` 来重定向输出和输入，学会使用 `|` 来重定向管道。明白 `>` 会覆盖了输出文件而 `>>` 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。\n\n- 学会使用通配符 `*` （或许再算上 `?` 和 `[`...`]`） 和引用以及引用中 `'` 和 `\"` 的区别（后文中有一些具体的例子）。\n\n- 熟悉 Bash 中的任务管理工具：`&`，**ctrl-z**，**ctrl-c**，`jobs`，`fg`，`bg`，`kill` 等。\n\n- 学会使用 `ssh` 进行远程命令行登录，最好知道如何使用 `ssh-agent`，`ssh-add` 等命令来实现基础的无密码认证登录。\n\n- 学会基本的文件管理工具：`ls` 和 `ls -l` （了解 `ls -l` 中每一列代表的意义），`less`，`head`，`tail` 和 `tail -f` （甚至 `less +F`），`ln` 和 `ln -s` （了解硬链接与软链接的区别），`chown`，`chmod`，`du` （硬盘使用情况概述：`du -hs *`）。 关于文件系统的管理，学习 `df`，`mount`，`fdisk`，`mkfs`，`lsblk`。知道 inode 是什么（与 `ls -i` 和 `df -i` 等命令相关）。\n\n- 学习基本的网络管理工具：`ip` 或 `ifconfig`，`dig`。\n\n- 学习并使用一种版本控制管理系统，例如 `git`。\n\n- 熟悉正则表达式，学会使用 `grep`／`egrep`，它们的参数中 `-i`，`-o`，`-v`，`-A`，`-B` 和 `-C` 这些是很常用并值得认真学习的。\n\n- 学会使用 `apt-get`，`yum`，`dnf` 或 `pacman` （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 `pip` 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 `pip` 来安装会很方便）。\n\n\n## 日常使用\n\n- 在 Bash 中，可以通过按 **Tab** 键实现自动补全参数，使用 **ctrl-r** 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 **ctrl-r** 会向后查找匹配项，按下 **Enter** 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。\n\n- 在 Bash 中，可以按下 **ctrl-w** 删除你键入的最后一个单词，**ctrl-u** 可以删除行内光标所在位置之前的内容，**alt-b** 和 **alt-f** 可以以单词为单位移动光标，**ctrl-a** 可以将光标移至行首，**ctrl-e** 可以将光标移至行尾，**ctrl-k** 可以删除光标至行尾的所有内容，**ctrl-l** 可以清屏。键入 `man readline` 可以查看 Bash 中的默认快捷键。内容有很多，例如 **alt-.** 循环地移向前一个参数，而 **alt-*** 可以展开通配符。\n\n\n- 你喜欢的话，可以执行 `set -o vi` 来使用 vi 风格的快捷键，而执行 `set -o emacs` 可以把它改回来。\n\n- 为了便于编辑长命令，在设置你的默认编辑器后（例如 `export EDITOR=vim`），**ctrl-x** **ctrl-e** 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 **escape-v**。\n\n- 键入 `history` 查看命令行历史记录，再用 `!n`（`n` 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 `!$`， 它用于指代上次键入的参数，而 `!!` 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 **ctrl-r** 和 **alt-.** 来实现。\n\n- `cd` 命令可以切换工作路径，输入 `cd ~` 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 `~`（例如 `~/.bashrc`）。在 `sh` 脚本里则用环境变量 `$HOME` 指代 home 目录的路径。\n\n- 回到前一个工作路径：`cd -`。\n\n- 如果你输入命令的时候中途改了主意，按下 **alt-#** 在行首添加 `#` 把它当做注释再按下回车执行（或者依次按下 **ctrl-a**， **#**， **enter**）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。\n\n- 使用 `xargs` （ 或 `parallel`）。他们非常给力。注意到你可以控制每行参数个数（`-L`）和最大并行数（`-P`）。如果你不确定它们是否会按你想的那样工作，先使用 `xargs echo` 查看一下。此外，使用 `-I{}` 会很方便。例如：\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n\n- `pstree -p` 以一种优雅的方式展示进程树。\n\n- 使用 `pgrep` 和 `pkill` 根据名字查找进程或发送信号（`-f` 参数通常有用）。\n\n- 了解你可以发往进程的信号的种类。比如，使用 `kill -STOP [pid]` 停止一个进程。使用 `man 7 signal` 查看详细列表。\n\n- 使用 `nohup` 或 `disown` 使一个后台进程持续运行。\n\n- 使用 `netstat -lntp` 或 `ss -plat` 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 `-u` 则检查 UDP 端口）或者 `lsof -iTCP -sTCP:LISTEN -P -n` (这也可以在 OS X 上运行)。\n\n- `lsof` 来查看开启的套接字和文件。\n\n- 使用 `uptime` 或 `w` 来查看系统已经运行多长时间。\n\n- 使用 `alias` 来创建常用命令的快捷形式。例如：`alias ll='ls -latr'` 创建了一个新的命令别名 `ll`。\n\n- 可以把别名、shell 选项和常用函数保存在 `~/.bashrc`，具体看下这篇[文章](http://superuser.com/a/183980/7106)。这样做的话你就可以在所有 shell 会话中使用你的设定。\n\n- 把环境变量的设定以及登陆时要执行的命令保存在 `~/.bash_profile`。而对于从图形界面启动的 shell 和 `cron` 启动的 shell，则需要单独配置文件。\n\n- 要想在几台电脑中同步你的配置文件（例如 `.bashrc` 和 `.bash_profile`），可以借助 Git。\n\n- 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 `\"$FOO\"`。尽量使用 `-0` 或 `-print0` 选项以便用 NULL 来分隔文件名，例如 `locate -0 pattern | xargs -0 ls -al` 或 `find / -print0 -type d | xargs -0 ls -al`。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 `IFS=$'\\n'` 把内部字段分隔符设为换行符。\n\n- 在 Bash 脚本中，使用 `set -x` 去调试输出（或者使用它的变体 `set -v`，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 `set -e` 令脚本在发生错误时退出而不是继续运行；使用 `set -u` 来检查是否使用了未赋值的变量；试试 `set -o pipefail`，它可以监测管道中的错误。当牵扯到很多脚本时，使用 `trap` 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- 在 Bash 脚本中，子 shell（使用括号 `(...)`）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- 在 Bash 中，变量有许多的扩展方式。`${name:?error message}` 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 `input_file=${1:?usage: $0 input_file}`。在变量为空时使用默认值：`${name:-default}`。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 `output_file=${2:-logfile}`，如果省略了 $2，它的值就为空，于是 `output_file` 就会被设为 `logfile`。数学表达式：`i=$(( (i + 1) % 5 ))`。序列：`{1..10}`。截断字符串：`${var%suffix}` 和 `${var#prefix}`。例如，假设 `var=foo.pdf`，那么 `echo ${var%.pdf}.txt` 将输出 `foo.txt`。\n\n- 使用括号扩展（`{`...`}`）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 `mv foo.{txt,pdf} some-dir`（同时移动两个文件），`cp somefile{,.bak}`（会被扩展成 `cp somefile somefile.bak`）或者 `mkdir -p test-{a,b,c}/subtest-{1,2,3}`（会被扩展成所有可能的组合，并创建一个目录树）。\n\n- 通过使用 `<(some command)` 可以将输出视为文件。例如，对比本地文件 `/etc/hosts` 和一个远程文件：\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。\n```bash\n{\n      # 在这里写代码\n}\n```\n\n- 了解 Bash 中的“here documents”，例如 `cat <<EOF ...`。\n\n- 在 Bash 中，同时重定向标准输出和标准错误：`some-command >logfile 2>&1` 或者 `some-command &>logfile`。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 `</dev/null` 是一个好习惯。\n\n- 使用 `man ascii` 查看具有十六进制和十进制值的ASCII表。`man unicode`，`man utf-8`，以及 `man latin1` 有助于你去了解通用的编码信息。\n\n- 使用 `screen` 或 [`tmux`](https://tmux.github.io/) 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 `byobu` 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 [`dtach`](https://github.com/bogner/dtach)。\n\n- ssh 中，了解如何使用 `-L` 或 `-D`（偶尔需要用 `-R`）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。\n\n- 对 ssh 设置做一些小优化可能是很有用的，例如这个 `~/.ssh/config` 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 `StrictHostKeyChecking=no`，`ForwardAgent=yes`。\n\n- 考虑使用 [`mosh`](https://mosh.org/) 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。\n\n- 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 `ls` 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 使用 [`percol`](https://github.com/mooz/percol) 或者 [`fzf`](https://github.com/junegunn/fzf) 可以交互式地从另一个命令输出中选取值。\n\n- 使用 `fpp`（[PathPicker](https://github.com/facebook/PathPicker)）可以与基于另一个命令(例如 `git`）输出的文件交互。\n\n- 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：\n`python -m SimpleHTTPServer 7777` （使用端口 7777 和 Python 2）或`python -m http.server 7777` （使用端口 7777 和 Python 3）。\n\n- 以其他用户的身份执行命令，使用 `sudo`。默认以 root 用户的身份执行；使用 `-u` 来指定其他用户。使用 `-i` 来以该用户登录（需要输入_你自己的_密码）。\n\n- 将 shell 切换为其他用户，使用 `su username` 或者 `su - username`。加入 `-` 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。\n\n- 了解命令行的 [128K 限制](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 `find` 或 `xargs` 通常可以解决。）\n\n- 当你需要一个基本的计算器时，可以使用 `python` 解释器（当然你要用 python 的时候也是这样）。例如：\n```\n>>> 2+3\n5\n```\n\n\n## 文件及数据处理\n\n- 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：`find . -iname '*something*'`。在所有路径下通过文件名查找文件，使用 `locate something` （但注意到 `updatedb` 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。\n\n- 使用 [`ag`](https://github.com/ggreer/the_silver_searcher) 在源代码或数据文件里检索（`grep -r` 同样可以做到，但相比之下 `ag` 更加先进）。\n\n- 将 HTML 转为文本：`lynx -dump -stdin`。\n\n- Markdown，HTML，以及所有文档格式之间的转换，试试 [`pandoc`](http://pandoc.org/)。\n\n- 当你要处理棘手的 XML 时候，`xmlstarlet` 算是上古时代流传下来的神器。\n\n- 使用 [`jq`](http://stedolan.github.io/jq/) 处理 JSON。\n\n- 使用 [`shyaml`](https://github.com/0k/shyaml) 处理 YAML。\n\n- 要处理 Excel 或 CSV 文件的话，[csvkit](https://github.com/onyxfish/csvkit) 提供了 `in2csv`，`csvcut`，`csvjoin`，`csvgrep` 等方便易用的工具。\n\n- 当你要处理 Amazon S3 相关的工作的时候，[`s3cmd`](https://github.com/s3tools/s3cmd) 是一个很方便的工具而 [`s4cmd`](https://github.com/bloomreach/s4cmd) 的效率更高。Amazon 官方提供的 [`aws`](https://github.com/aws/aws-cli) 以及  [`saws`](https://github.com/donnemartin/saws) 是其他 AWS 相关工作的基础，值得学习。\n\n- 了解如何使用 `sort` 和 `uniq`，包括 uniq 的 `-u` 参数和 `-d` 参数，具体内容在后文单行脚本节中。另外可以了解一下 `comm`。\n\n- 了解如何使用 `cut`，`paste` 和 `join` 来更改文件。很多人都会使用 `cut`，但遗忘了 `join`。\n\n- 了解如何运用 `wc` 去计算新行数（`-l`），字符数（`-m`），单词数（`-w`）以及字节数（`-c`）。\n\n- 了解如何使用 `tee` 将标准输入复制到文件甚至标准输出，例如 `ls -al | tee file.txt`。\n\n- 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 [`datamash`](https://www.gnu.org/software/datamash/)。\n\n- 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 `LANG` 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降*许多倍*。某些情况下（例如集合运算）你可以放心的使用 `export LC_ALL=C` 来忽略掉国际化并按照字节来判断顺序。\n\n- 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 `TZ=Pacific/Fiji date` 可以获取斐济的时间。\n\n- 了解如何使用 `awk` 和 `sed` 来进行简单的数据处理。 参阅 [One-liners](#one-liners) 获取示例。\n\n- 替换一个或多个文件中出现的字符串：\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 使用 [`repren`](https://github.com/jlevy/repren) 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 `rename` 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）\n```sh\n      # 将文件、目录和内容全部重命名 foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # 还原所有备份文件 whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # 用 rename 实现上述功能（若可用）:\n      rename 's/\\.bak$//' *.bak\n```\n\n- 根据 man 页面的描述，`rsync` 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 `rsync` 代替 `scp` 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的[最快方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)之一：\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- 若要在复制文件时获取当前进度，可使用 `pv`，[`pycp`](https://github.com/dmerejkowsky/pycp)，[`progress`](https://github.com/Xfennec/progress)，`rsync --progress`。若所执行的复制为block块拷贝，可以使用 `dd status=progress`。\n\n- 使用 `shuf` 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。\n\n- 了解 `sort` 的参数。显示数字时，使用 `-n` 或者 `-h` 来显示更易读的数（例如 `du -h` 的输出）。明白排序时关键字的工作原理（`-t` 和 `-k`）。例如，注意到你需要 `-k1，1` 来仅按第一个域来排序，而 `-k1` 意味着按整行排序。稳定排序（`sort -s`）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 `sort -k1，1 | sort -s -k2，2`。\n\n- 如果你想在 Bash 命令行中写 tab 制表符，按下 **ctrl-v** **[Tab]** 或键入 `$'\\t'` （后者可能更好，因为你可以复制粘贴它）。\n\n- 标准的源代码对比及合并工具是 `diff` 和 `patch`。使用 `diffstat` 查看变更总览数据。注意到 `diff -r` 对整个文件夹有效。使用 `diff -r tree1 tree2 | diffstat` 查看变更的统计数据。`vimdiff` 用于比对并编辑文件。\n\n- 对于二进制文件，使用 `hd`，`hexdump` 或者 `xxd` 使其以十六进制显示，使用 `bvi`，`hexedit` 或者 `biew` 来进行二进制编辑。\n\n- 同样对于二进制文件，`strings`（包括 `grep` 等工具）可以帮助在二进制文件中查找特定比特。\n\n- 制作二进制差分文件（Delta 压缩），使用 `xdelta3`。\n\n- 使用 `iconv` 更改文本编码。需要更高级的功能，可以使用 `uconv`，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- 拆分文件可以使用 `split`（按大小拆分）和 `csplit`（按模式拆分）。\n\n- 操作日期和时间表达式，可以用 [`dateutils`](http://www.fresse.org/dateutils/) 中的 `dateadd`、`datediff`、`strptime` 等工具。\n\n- 使用 `zless`、`zmore`、`zcat` 和 `zgrep` 对压缩过的文件进行操作。\n\n- 文件属性可以通过 `chattr` 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：`sudo chattr +i /critical/directory/or/file`\n\n- 使用 `getfacl` 和 `setfacl` 以保存和恢复文件权限。例如：\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- 为了高效地创建空文件，请使用 `truncate`（创建[稀疏文件](https://zh.wikipedia.org/wiki/稀疏文件)），`fallocate`（用于 ext4，xfs，btrf 和 ocfs2 文件系统），`xfs_mkfile`（适用于几乎所有的文件系统，包含在 xfsprogs 包中），`mkfile`（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。\n\n## 系统调试\n\n- `curl` 和 `curl -I` 可以被轻松地应用于 web 调试中，它们的好兄弟 `wget` 也是如此，或者也可以试试更潮的 [`httpie`](https://github.com/jkbrzt/httpie)。\n\n- 获取 CPU 和硬盘的使用状态，通常使用使用 `top`（`htop` 更佳），`iostat` 和 `iotop`。而 `iostat -mxz 15` 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。\n\n- 使用 `netstat` 和 `ss` 查看网络连接的细节。\n\n- `dstat` 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 [`glances`](https://github.com/nicolargo/glances)，它会在一个终端窗口中向你提供一些系统级的数据。\n\n- 若要了解内存状态，运行并理解 `free` 和 `vmstat` 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。\n\n- Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 `kill -3 <pid>` 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 `jps`，`jstat`，`jstack`，`jmap` 很有用。[SJK tools](https://github.com/aragozin/jvm-tools) 更高级。\n\n- 使用 [`mtr`](http://www.bitwizard.nl/mtr/) 去跟踪路由，用于确定网络问题。\n\n- 用 [`ncdu`](https://dev.yorhel.nl/ncdu) 来查看磁盘使用情况，它比寻常的命令，如 `du -sh *`，更节省时间。\n\n- 查找正在使用带宽的套接字连接或进程，使用 [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)。\n\n- `ab` 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 `siege`。\n\n- [`wireshark`](https://wireshark.org/)，[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) 和 [`ngrep`](http://ngrep.sourceforge.net/) 可用于复杂的网络调试。\n\n- 了解 `strace` 和 `ltrace`。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（`-c`）和附加到一个运行的进程参数 （`-p`）。\n\n- 了解使用 `ldd` 来检查共享库。但是[永远不要在不信任的文件上运行](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)。\n\n- 了解如何运用 `gdb` 连接到一个运行着的进程并获取它的堆栈轨迹。\n\n- 学会使用 `/proc`。它在调试正在出现的问题的时候有时会效果惊人。比如：`/proc/cpuinfo`，`/proc/meminfo`，`/proc/cmdline`，`/proc/xxx/cwd`，`/proc/xxx/exe`，`/proc/xxx/fd/`，`/proc/xxx/smaps`（这里的 `xxx` 表示进程的 id 或 pid）。\n\n- 当调试一些之前出现的问题的时候，[`sar`](http://sebastien.godard.pagesperso-orange.fr/) 非常有用。它展示了 cpu、内存以及网络等的历史数据。\n\n- 关于更深层次的系统分析以及性能分析，看看 `stap`（[SystemTap](https://sourceware.org/systemtap/wiki)），[`perf`](https://en.wikipedia.org/wiki/Perf_(Linux))，以及[`sysdig`](https://github.com/draios/sysdig)。\n\n- 查看你当前使用的系统，使用 `uname`，`uname -a`（Unix／kernel 信息）或者 `lsb_release -a`（Linux 发行版信息）。\n\n- 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 `dmesg`。\n\n- 如果你删除了一个文件，但通过 `du` 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## 单行脚本\n\n一些命令组合的例子：\n\n- 当你需要对文本文件做集合交、并、差运算时，`sort` 和 `uniq` 会是你的好帮手。具体例子请参照代码后面的，此处假设 `a` 与 `b` 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 `/tmp` 在一个小的根分区上时你可能需要 `-T` 参数，但是实际上 `sort` 并不被内存大小约束），参阅前文中关于 `LC_ALL` 和 `sort` 的 `-u` 参数的部分。\n```sh\n      sort a b | uniq > c   # c 是 a 并 b\n      sort a b | uniq -d > c   # c 是 a 交 b\n      sort a b b | uniq -u > c   # c 是 a - b\n```\n\n- 使用 `grep . *`（每行都会附上文件名）或者 `head -100 *`（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 `/sys`、`/proc`、`/etc`）时特别好用。\n\n\n- 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 `ls -l` 但比 `ls -lR` 更易于理解：\n```sh\n      find . -type f -ls\n```\n\n- 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 `acct_id` 参数在 URI 中。如果你想计算出每个 `acct_id` 值有多少次请求，使用如下代码：\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 要持续监测文件改动，可以使用 `watch`，例如检查某个文件夹中文件的改变，可以用 `watch -d -n 2 'ls -rtlh | tail'`；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 `watch -d -n 2 ifconfig`。\n\n- 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|\n          pandoc -f markdown -t html |\n          iconv -f 'utf-8' -t 'unicode' |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## 冷门但有用\n\n- `expr`：计算表达式或正则匹配\n\n- `m4`：简单的宏处理器\n\n- `yes`：多次打印字符串\n\n- `cal`：漂亮的日历\n\n- `env`：执行一个命令（脚本文件中很有用）\n\n- `printenv`：打印环境变量（调试时或在写脚本文件时很有用）\n\n- `look`：查找以特定字符串开头的单词或行\n\n- `cut`，`paste` 和 `join`：数据修改\n\n- `fmt`：格式化文本段落\n\n- `pr`：将文本格式化成页／列形式\n\n- `fold`：包裹文本中的几行\n\n- `column`：将文本格式化成多个对齐、定宽的列或表格\n\n- `expand` 和 `unexpand`：制表符与空格之间转换\n\n- `nl`：添加行号\n\n- `seq`：打印数字\n\n- `bc`：计算器\n\n- `factor`：分解因数\n\n- [`gpg`](https://gnupg.org/)：加密并签名文件\n\n- `toe`：terminfo 入口列表\n\n- `nc`：网络调试及数据传输\n\n- `socat`：套接字代理，与 `netcat` 类似\n\n- [`slurm`](https://github.com/mattthias/slurm)：网络流量可视化\n\n- `dd`：文件或设备间传输数据\n\n- `file`：确定文件类型\n\n- `tree`：以树的形式显示路径和文件，类似于递归的 `ls`\n\n- `stat`：文件信息\n\n- `time`：执行命令，并计算执行时间\n\n- `timeout`：在指定时长范围内执行命令，并在规定时间结束后停止进程\n\n- `lockfile`：使文件只能通过 `rm -f` 移除\n\n- `logrotate`： 切换、压缩以及发送日志文件\n\n- `watch`：重复运行同一个命令，展示结果并／或高亮有更改的部分\n\n- [`when-changed`](https://github.com/joh/when-changed)：当检测到文件更改时执行指定命令。参阅 `inotifywait` 和 `entr`。\n\n- `tac`：反向输出文件\n\n- `shuf`：文件中随机选取几行\n\n- `comm`：一行一行的比较排序过的文件\n\n- `strings`：从二进制文件中抽取文本\n\n- `tr`：转换字母\n\n- `iconv` 或 `uconv`：文本编码转换\n\n- `split` 和 `csplit`：分割文件\n\n- `sponge`：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 `grep -v something some-file | sponge some-file`\n\n- `units`：将一种计量单位转换为另一种等效的计量单位（参阅 `/usr/share/units/definitions.units`）\n\n- `apg`：随机生成密码\n\n- `xz`：高比例的文件压缩\n\n- `ldd`：动态库信息\n\n- `nm`：提取 obj 文件中的符号\n\n- `ab` 或 [`wrk`](https://github.com/wg/wrk)：web 服务器性能分析\n\n- `strace`：调试系统调用\n\n- [`mtr`](http://www.bitwizard.nl/mtr/)：更好的网络调试跟踪工具\n\n- `cssh`：可视化的并发 shell\n\n- `rsync`：通过 ssh 或本地文件系统同步文件和文件夹\n\n- [`wireshark`](https://wireshark.org/) 和 [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)：抓包和网络调试工具\n\n- [`ngrep`](http://ngrep.sourceforge.net/)：网络层的 grep\n\n- `host` 和 `dig`：DNS 查找\n\n- `lsof`：列出当前系统打开文件的工具以及查看端口信息\n\n- `dstat`：系统状态查看\n\n- [`glances`](https://github.com/nicolargo/glances)：高层次的多子系统总览\n\n- `iostat`：硬盘使用状态\n\n- `mpstat`： CPU 使用状态\n\n- `vmstat`： 内存使用状态\n\n- `htop`：top 的加强版\n\n- `last`：登入记录\n\n- `w`：查看处于登录状态的用户\n\n- `id`：用户/组 ID 信息\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/)：系统历史数据\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)：套接字及进程的网络利用情况\n\n- `ss`：套接字数据\n\n- `dmesg`：引导及系统错误信息\n\n- `sysctl`： 在内核运行时动态地查看和修改内核的运行参数\n\n- `hdparm`：SATA/ATA 磁盘更改及性能分析\n\n- `lsblk`：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息\n\n- `lshw`，`lscpu`，`lspci`，`lsusb` 和 `dmidecode`：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等\n\n- `lsmod` 和 `modinfo`：列出内核模块，并显示其细节\n\n- `fortune`，`ddate` 和 `sl`：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”\n\n\n## 仅限 OS X 系统\n\n以下是*仅限于* OS X 系统的技巧。\n\n- 用 `brew` （Homebrew）或者 `port` （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。\n\n- 用 `pbcopy` 复制任何命令的输出到桌面应用，用 `pbpaste` 粘贴输入。\n\n- 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 **alt-b**、**alt-f** 等命令中用到），打开 偏好设置 -> 描述文件 -> 键盘 并勾选“使用 Option 键作为 Meta 键”。\n\n- 用 `open` 或者 `open -a /Applications/Whatever.app` 使用桌面应用打开文件。\n\n- Spotlight：用 `mdfind` 搜索文件，用 `mdls` 列出元数据（例如照片的 EXIF 信息）。\n\n- 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 `ps`，`ls`，`tail`，`awk`，`sed`）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 \"BSD General Commands Manual\" 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 `gawk` 和 `gsed` 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 `perl` ）或者经过仔细的测试。\n\n- 用 `sw_vers` 获取 OS X 的版本信息。\n\n## 仅限 Windows 系统\n\n以下是*仅限于* Windows 系统的技巧。\n\n### 在 Windows 下获取 Unix 工具\n\n- 可以安装 [Cygwin](https://cygwin.com/) 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。\n\n- 在 Windows 10 上，你可以使用 [Bash on Ubuntu on Windows](https://msdn.microsoft.com/commandline/wsl/about)，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。\n\n- 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。\n\n- 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 [Cash](https://github.com/dthree/cash)。注意在此环境下只有很少的 Unix 命令和命令行可用。\n\n### 实用 Windows 命令行工具\n\n- 可以使用 `wmic` 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。\n\n- Windows 实用的原生命令行网络工具包括 `ping`，`ipconfig`，`tracert`，和 `netstat`。\n\n- 可以使用 `Rundll32` 命令来实现[许多有用的 Windows 任务](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) 。\n\n### Cygwin 技巧\n\n- 通过 Cygwin 的包管理器来安装额外的 Unix 程序。\n\n- 使用 `mintty` 作为你的命令行窗口。\n\n- 要访问 Windows 剪贴板，可以通过 `/dev/clipboard`。\n\n- 运行 `cygstart` 以通过默认程序打开一个文件。\n\n- 要访问 Windows 注册表，可以使用 `regtool`。\n\n- 注意 Windows 驱动器路径 `C:\\` 在 Cygwin 中用 `/cygdrive/c` 代表，而 Cygwin 的 `/` 代表 Windows 中的 `C:\\cygwin`。要转换 Cygwin 和 Windows 风格的路径可以用 `cygpath`。这在需要调用 Windows 程序的脚本里很有用。\n\n- 学会使用 `wmic`，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。\n\n- 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 [Cash](https://github.com/dthree/cash)。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。\n\n- 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。\n\n## 更多资源\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell)：一份精心组织的命令行工具及资源的列表。\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)：一份针对 OS X 命令行的更深入的指南。\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)：为了编写更好的脚本文件。\n- [shellcheck](https://github.com/koalaman/shellcheck)：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)：有关如何在 shell 脚本里正确处理文件名的细枝末节。\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools)：用于数据科学的一些命令和工具，摘自同名书籍。\n\n## 免责声明\n\n除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 *有能力* 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)\n\n\n## 授权条款\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\n本文使用授权协议 [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)。\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 39.95,
          "content": "🌍\n*[Čeština](README-cs.md) ∙ [Deutsch](README-de.md) ∙ [Ελληνικά](README-el.md) ∙ [English](README.md) ∙ [Español](README-es.md) ∙ [Français](README-fr.md) ∙ [Indonesia](README-id.md) ∙ [Italiano](README-it.md) ∙ [日本語](README-ja.md) ∙ [한국어](README-ko.md) ∙ [polski](README-pl.md) ∙ [Português](README-pt.md) ∙ [Română](README-ro.md) ∙ [Русский](README-ru.md) ∙ [Slovenščina](README-sl.md) ∙ [Українська](README-uk.md) ∙ [简体中文](README-zh.md) ∙ [繁體中文](README-zh-Hant.md)*\n\n\n# The Art of Command Line\n\n*Note: I'm planning to revise this and looking for a new co-author to help with expanding this into a more comprehensive guide. While it's very popular, it could be broader and a bit deeper. If you like to write and are close to being an expert on this material and willing to consider helping, please drop me a note at josh (0x40) holloway.com. –[jlevy](https://github.com/jlevy), [Holloway](https://www.holloway.com). Thank you!*\n\n- [Meta](#meta)\n- [Basics](#basics)\n- [Everyday use](#everyday-use)\n- [Processing files and data](#processing-files-and-data)\n- [System debugging](#system-debugging)\n- [One-liners](#one-liners)\n- [Obscure but useful](#obscure-but-useful)\n- [macOS only](#macos-only)\n- [Windows only](#windows-only)\n- [More resources](#more-resources)\n- [Disclaimer](#disclaimer)\n\n\n![curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '`\\w+`' | tr -d '`' | cowsay -W50](cowsay.png)\n\nFluency on the command line is a skill often neglected or considered arcane, but it improves your flexibility and productivity as an engineer in both obvious and subtle ways. This is a selection of notes and tips on using the command-line that we've found useful when working on Linux. Some tips are elementary, and some are fairly specific, sophisticated, or obscure. This page is not long, but if you can use and recall all the items here, you know a lot.\n\nThis work is the result of [many authors and translators](AUTHORS.md).\nSome of this\n[originally](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[appeared](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\non [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know),\nbut it has since moved to GitHub, where people more talented than the original author have made numerous improvements.\n[**Please submit a question**](https://airtable.com/shrzMhx00YiIVAWJg) if you have a question related to the command line. [**Please contribute**](/CONTRIBUTING.md) if you see an error or something that could be better!\n\n## Meta\n\nScope:\n\n- This guide is for both beginners and experienced users. The goals are *breadth* (everything important), *specificity* (give concrete examples of the most common case), and *brevity* (avoid things that aren't essential or digressions you can easily look up elsewhere). Every tip is essential in some situation or significantly saves time over alternatives.\n- This is written for Linux, with the exception of the \"[macOS only](#macos-only)\" and \"[Windows only](#windows-only)\" sections. Many of the other items apply or can be installed on other Unices or macOS (or even Cygwin).\n- The focus is on interactive Bash, though many tips apply to other shells and to general Bash scripting.\n- It includes both \"standard\" Unix commands as well as ones that require special package installs -- so long as they are important enough to merit inclusion.\n\nNotes:\n\n- To keep this to one page, content is implicitly included by reference. You're smart enough to look up more detail elsewhere once you know the idea or command to Google. Use `apt`, `yum`, `dnf`, `pacman`, `pip` or `brew` (as appropriate) to install new programs.\n- Use [Explainshell](http://explainshell.com/) to get a helpful breakdown of what commands, options, pipes etc. do.\n\n\n## Basics\n\n- Learn basic Bash. Actually, type `man bash` and at least skim the whole thing; it's pretty easy to follow and not that long. Alternate shells can be nice, but Bash is powerful and always available (learning *only* zsh, fish, etc., while tempting on your own laptop, restricts you in many situations, such as using existing servers).\n\n- Learn at least one text-based editor well. The `nano` editor is one of the simplest for basic editing (opening, editing, saving, searching). However, for the power user in a text terminal, there is no substitute for Vim (`vi`), the hard-to-learn but venerable, fast, and full-featured editor. Many people also use the classic Emacs, particularly for larger editing tasks. (Of course, any modern software developer working on an extensive project is unlikely to use only a pure text-based editor and should also be familiar with modern graphical IDEs and tools.)\n\n- Finding documentation:\n  - Know how to read official documentation with `man` (for the inquisitive, `man man` lists the section numbers, e.g. 1 is \"regular\" commands, 5 is files/conventions, and 8 are for administration). Find man pages with `apropos`.\n  - Know that some commands are not executables, but Bash builtins, and that you can get help on them with `help` and `help -d`. You can find out whether a command is an executable, shell builtin or an alias by using `type command`.\n  - `curl cheat.sh/command` will give a brief \"cheat sheet\" with common examples of how to use a shell command.\n\n- Learn about redirection of output and input using `>` and `<` and pipes using `|`. Know `>` overwrites the output file and `>>` appends. Learn about stdout and stderr.\n\n- Learn about file glob expansion with `*` (and perhaps `?` and `[`...`]`) and quoting and the difference between double `\"` and single `'` quotes. (See more on variable expansion below.)\n\n- Be familiar with Bash job management: `&`, **ctrl-z**, **ctrl-c**, `jobs`, `fg`, `bg`, `kill`, etc.\n\n- Know `ssh`, and the basics of passwordless authentication, via `ssh-agent`, `ssh-add`, etc.\n\n- Basic file management: `ls` and `ls -l` (in particular, learn what every column in `ls -l` means), `less`, `head`, `tail` and `tail -f` (or even better, `less +F`), `ln` and `ln -s` (learn the differences and advantages of hard versus soft links), `chown`, `chmod`, `du` (for a quick summary of disk usage: `du -hs *`). For filesystem management, `df`, `mount`, `fdisk`, `mkfs`, `lsblk`. Learn what an inode is (`ls -i` or `df -i`).\n\n- Basic network management: `ip` or `ifconfig`, `dig`, `traceroute`, `route`.\n\n- Learn and use a version control management system, such as `git`.\n\n- Know regular expressions well, and the various flags to `grep`/`egrep`. The `-i`, `-o`, `-v`, `-A`, `-B`, and `-C` options are worth knowing.\n\n- Learn to use `apt-get`, `yum`, `dnf` or `pacman` (depending on distro) to find and install packages. And make sure you have `pip` to install Python-based command-line tools (a few below are easiest to install via `pip`).\n\n\n## Everyday use\n\n- In Bash, use **Tab** to complete arguments or list all available commands and **ctrl-r** to search through command history (after pressing, type to search, press **ctrl-r** repeatedly to cycle through more matches, press **Enter** to execute the found command, or hit the right arrow to put the result in the current line to allow editing).\n\n- In Bash, use **ctrl-w** to delete the last word, and **ctrl-u** to delete the content from current cursor back to the start of the line. Use **alt-b** and **alt-f** to move by word, **ctrl-a** to move cursor to beginning of line,  **ctrl-e** to move cursor to end of line, **ctrl-k** to kill to the end of the line, **ctrl-l** to clear the screen. See `man readline` for all the default keybindings in Bash. There are a lot. For example **alt-.** cycles through previous arguments, and **alt-*** expands a glob.\n\n\n- Alternatively, if you love vi-style key-bindings, use `set -o vi` (and `set -o emacs` to put it back).\n\n- For editing long commands, after setting your editor (for example `export EDITOR=vim`), **ctrl-x** **ctrl-e** will open the current command in an editor for multi-line editing. Or in vi style, **escape-v**.\n\n- To see recent commands, use `history`. Follow with `!n` (where `n` is the command number) to execute again. There are also many abbreviations you can use, the most useful probably being `!$` for last argument and `!!` for last command (see \"HISTORY EXPANSION\" in the man page). However, these are often easily replaced with **ctrl-r** and **alt-.**.\n\n- Go to your home directory with `cd`. Access files relative to your home directory with the `~` prefix (e.g. `~/.bashrc`). In `sh` scripts refer to the home directory as `$HOME`.\n\n- To go back to the previous working directory: `cd -`.\n\n- If you are halfway through typing a command but change your mind, hit **alt-#** to add a `#` at the beginning and enter it as a comment (or use **ctrl-a**, **#**, **enter**). You can then return to it later via command history.\n\n- Use `xargs` (or `parallel`). It's very powerful. Note you can control how many items execute per line (`-L`) as well as parallelism (`-P`). If you're not sure if it'll do the right thing, use `xargs echo` first. Also, `-I{}` is handy. Examples:\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n- `pstree -p` is a helpful display of the process tree.\n\n- Use `pgrep` and `pkill` to find or signal processes by name (`-f` is helpful).\n\n- Know the various signals you can send processes. For example, to suspend a process, use `kill -STOP [pid]`. For the full list, see `man 7 signal`\n\n- Use `nohup` or `disown` if you want a background process to keep running forever.\n\n- Check what processes are listening via `netstat -lntp` or `ss -plat` (for TCP; add `-u` for UDP) or `lsof -iTCP -sTCP:LISTEN -P -n` (which also works on macOS).\n\n- See also `lsof` and `fuser` for open sockets and files.\n\n- See `uptime` or `w` to know how long the system has been running.\n\n- Use `alias` to create shortcuts for commonly used commands. For example, `alias ll='ls -latr'` creates a new alias `ll`.\n\n- Save aliases, shell settings, and functions you commonly use in `~/.bashrc`, and [arrange for login shells to source it](http://superuser.com/a/183980/7106). This will make your setup available in all your shell sessions.\n\n- Put the settings of environment variables as well as commands that should be executed when you login in `~/.bash_profile`. Separate configuration will be needed for shells you launch from graphical environment logins and `cron` jobs.\n\n- Synchronize your configuration files (e.g. `.bashrc` and `.bash_profile`) among various computers with Git.\n\n- Understand that care is needed when variables and filenames include whitespace. Surround your Bash variables with quotes, e.g. `\"$FOO\"`. Prefer the `-0` or `-print0` options to enable null characters to delimit filenames, e.g. `locate -0 pattern | xargs -0 ls -al` or `find / -print0 -type d | xargs -0 ls -al`. To iterate on filenames containing whitespace in a for loop, set your IFS to be a newline only using `IFS=$'\\n'`.\n\n- In Bash scripts, use `set -x` (or the variant `set -v`, which logs raw input, including unexpanded variables and comments) for debugging output. Use strict modes unless you have a good reason not to: Use `set -e` to abort on errors (nonzero exit code). Use `set -u` to detect unset variable usages. Consider `set -o pipefail` too, to abort on errors within pipes (though read up on it more if you do, as this topic is a bit subtle). For more involved scripts, also use `trap` on EXIT or ERR. A useful habit is to start a script like this, which will make it detect and abort on common errors and print a message:\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- In Bash scripts, subshells (written with parentheses) are convenient ways to group commands. A common example is to temporarily move to a different working directory, e.g.\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- In Bash, note there are lots of kinds of variable expansion. Checking a variable exists: `${name:?error message}`. For example, if a Bash script requires a single argument, just write `input_file=${1:?usage: $0 input_file}`. Using a default value if a variable is empty: `${name:-default}`. If you want to have an additional (optional) parameter added to the previous example, you can use something like `output_file=${2:-logfile}`. If `$2` is omitted and thus empty, `output_file` will be set to `logfile`. Arithmetic expansion: `i=$(( (i + 1) % 5 ))`. Sequences: `{1..10}`. Trimming of strings: `${var%suffix}` and `${var#prefix}`. For example if `var=foo.pdf`, then `echo ${var%.pdf}.txt` prints `foo.txt`.\n\n- Brace expansion using `{`...`}` can reduce having to re-type similar text and automate combinations of items.  This is helpful in examples like `mv foo.{txt,pdf} some-dir` (which moves both files), `cp somefile{,.bak}` (which expands to `cp somefile somefile.bak`) or `mkdir -p test-{a,b,c}/subtest-{1,2,3}` (which expands all possible combinations and creates a directory tree). Brace expansion is performed before any other expansion.\n\n- The order of expansions is: brace expansion; tilde expansion, parameter and variable expansion, arithmetic expansion, and command substitution (done in a left-to-right fashion); word splitting; and filename expansion. (For example, a range like `{1..20}` cannot be expressed with variables using `{$a..$b}`. Use `seq` or a `for` loop instead, e.g., `seq $a $b` or `for((i=a; i<=b; i++)); do ... ; done`.)\n\n- The output of a command can be treated like a file via `<(some command)` (known as process substitution). For example, compare local `/etc/hosts` with a remote one:\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- When writing scripts you may want to put all of your code in curly braces. If the closing brace is missing, your script will be prevented from executing due to a syntax error. This makes sense when your script is going to be downloaded from the web, since it prevents partially downloaded scripts from executing:\n```bash\n{\n      # Your code here\n}\n```\n\n- A \"here document\" allows [redirection of multiple lines of input](https://www.tldp.org/LDP/abs/html/here-docs.html) as if from a file:\n```\ncat <<EOF\ninput\non multiple lines\nEOF\n```\n\n- In Bash, redirect both standard output and standard error via: `some-command >logfile 2>&1` or `some-command &>logfile`. Often, to ensure a command does not leave an open file handle to standard input, tying it to the terminal you are in, it is also good practice to add `</dev/null`.\n\n- Use `man ascii` for a good ASCII table, with hex and decimal values. For general encoding info, `man unicode`, `man utf-8`, and `man latin1` are helpful.\n\n- Use `screen` or [`tmux`](https://tmux.github.io/) to multiplex the screen, especially useful on remote ssh sessions and to detach and re-attach to a session. `byobu` can enhance screen or tmux by providing more information and easier management. A more minimal alternative for session persistence only is [`dtach`](https://github.com/bogner/dtach).\n\n- In ssh, knowing how to port tunnel with `-L` or `-D` (and occasionally `-R`) is useful, e.g. to access web sites from a remote server.\n\n- It can be useful to make a few optimizations to your ssh configuration; for example, this `~/.ssh/config` contains settings to avoid dropped connections in certain network environments, uses compression (which is helpful with scp over low-bandwidth connections), and multiplex channels to the same server with a local control file:\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- A few other options relevant to ssh are security sensitive and should be enabled with care, e.g. per subnet or host or in trusted networks: `StrictHostKeyChecking=no`, `ForwardAgent=yes`\n\n- Consider [`mosh`](https://mosh.org/) an alternative to ssh that uses UDP, avoiding dropped connections and adding convenience on the road (requires server-side setup).\n\n- To get the permissions on a file in octal form, which is useful for system configuration but not available in `ls` and easy to bungle, use something like\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- For interactive selection of values from the output of another command, use [`percol`](https://github.com/mooz/percol) or [`fzf`](https://github.com/junegunn/fzf).\n\n- For interaction with files based on the output of another command (like `git`), use `fpp` ([PathPicker](https://github.com/facebook/PathPicker)).\n\n- For a simple web server for all files in the current directory (and subdirs), available to anyone on your network, use:\n`python -m SimpleHTTPServer 7777` (for port 7777 and Python 2) and `python -m http.server 7777` (for port 7777 and Python 3).\n\n- For running a command as another user, use `sudo`. Defaults to running as root; use `-u` to specify another user. Use `-i` to login as that user (you will be asked for _your_ password).\n\n- For switching the shell to another user, use `su username` or `su - username`. The latter with \"-\" gets an environment as if another user just logged in. Omitting the username defaults to root. You will be asked for the password _of the user you are switching to_.\n\n- Know about the [128K limit](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong) on command lines. This \"Argument list too long\" error is common when wildcard matching large numbers of files. (When this happens alternatives like `find` and `xargs` may help.)\n\n- For a basic calculator (and of course access to Python in general), use the `python` interpreter. For example,\n```\n>>> 2+3\n5\n```\n\n\n## Processing files and data\n\n- To locate a file by name in the current directory, `find . -iname '*something*'` (or similar). To find a file anywhere by name, use `locate something` (but bear in mind `updatedb` may not have indexed recently created files).\n\n- For general searching through source or data files, there are several options more advanced or faster than `grep -r`, including (in rough order from older to newer) [`ack`](https://github.com/beyondgrep/ack2), [`ag`](https://github.com/ggreer/the_silver_searcher) (\"the silver searcher\"), and [`rg`](https://github.com/BurntSushi/ripgrep) (ripgrep).\n\n- To convert HTML to text: `lynx -dump -stdin`\n\n- For Markdown, HTML, and all kinds of document conversion, try [`pandoc`](http://pandoc.org/). For example, to convert a Markdown document to Word format: `pandoc README.md --from markdown --to docx -o temp.docx`\n\n- If you must handle XML, `xmlstarlet` is old but good.\n\n- For JSON, use [`jq`](http://stedolan.github.io/jq/). For interactive use, also see [`jid`](https://github.com/simeji/jid) and [`jiq`](https://github.com/fiatjaf/jiq).\n\n- For YAML, use [`shyaml`](https://github.com/0k/shyaml).\n\n- For Excel or CSV files, [csvkit](https://github.com/onyxfish/csvkit) provides `in2csv`, `csvcut`, `csvjoin`, `csvgrep`, etc.\n\n- For Amazon S3, [`s3cmd`](https://github.com/s3tools/s3cmd) is convenient and [`s4cmd`](https://github.com/bloomreach/s4cmd) is faster. Amazon's [`aws`](https://github.com/aws/aws-cli) and the improved [`saws`](https://github.com/donnemartin/saws) are essential for other AWS-related tasks.\n\n- Know about `sort` and `uniq`, including uniq's `-u` and `-d` options -- see one-liners below. See also `comm`.\n\n- Know about `cut`, `paste`, and `join` to manipulate text files. Many people use `cut` but forget about `join`.\n\n- Know about `wc` to count newlines (`-l`), characters (`-m`), words (`-w`) and bytes (`-c`).\n\n- Know about `tee` to copy from stdin to a file and also to stdout, as in `ls -al | tee file.txt`.\n\n- For more complex calculations, including grouping, reversing fields, and statistical calculations, consider [`datamash`](https://www.gnu.org/software/datamash/).\n\n- Know that locale affects a lot of command line tools in subtle ways, including sorting order (collation) and performance. Most Linux installations will set `LANG` or other locale variables to a local setting like US English. But be aware sorting will change if you change locale. And know i18n routines can make sort or other commands run *many times* slower. In some situations (such as the set operations or uniqueness operations below) you can safely ignore slow i18n routines entirely and use traditional byte-based sort order, using `export LC_ALL=C`.\n\n- You can set a specific command's environment by prefixing its invocation with the environment variable settings, as in `TZ=Pacific/Fiji date`.\n\n- Know basic `awk` and `sed` for simple data munging. See [One-liners](#one-liners) for examples.\n\n- To replace all occurrences of a string in place, in one or more files:\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- To rename multiple files and/or search and replace within files, try [`repren`](https://github.com/jlevy/repren). (In some cases the `rename` command also allows multiple renames, but be careful as its functionality is not the same on all Linux distributions.)\n```sh\n      # Full rename of filenames, directories, and contents foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # Recover backup files whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # Same as above, using rename, if available:\n      rename 's/\\.bak$//' *.bak\n```\n\n- As the man page says, `rsync` really is a fast and extraordinarily versatile file copying tool. It's known for synchronizing between machines but is equally useful locally. When security restrictions allow, using `rsync` instead of `scp` allows recovery of a transfer without restarting from scratch. It also is among the [fastest ways](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html) to delete large numbers of files:\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- For monitoring progress when processing files, use [`pv`](http://www.ivarch.com/programs/pv.shtml), [`pycp`](https://github.com/dmerejkowsky/pycp), [`pmonitor`](https://github.com/dspinellis/pmonitor), [`progress`](https://github.com/Xfennec/progress), `rsync --progress`, or, for block-level copying, `dd status=progress`.\n\n- Use `shuf` to shuffle or select random lines from a file.\n\n- Know `sort`'s options. For numbers, use `-n`, or `-h` for handling human-readable numbers (e.g. from `du -h`). Know how keys work (`-t` and `-k`). In particular, watch out that you need to write `-k1,1` to sort by only the first field; `-k1` means sort according to the whole line. Stable sort (`sort -s`) can be useful. For example, to sort first by field 2, then secondarily by field 1, you can use `sort -k1,1 | sort -s -k2,2`.\n\n- If you ever need to write a tab literal in a command line in Bash (e.g. for the -t argument to sort), press **ctrl-v** **[Tab]** or write `$'\\t'` (the latter is better as you can copy/paste it).\n\n- The standard tools for patching source code are `diff` and `patch`. See also `diffstat` for summary statistics of a diff and `sdiff` for a side-by-side diff. Note `diff -r` works for entire directories. Use `diff -r tree1 tree2 | diffstat` for a summary of changes. Use `vimdiff` to compare and edit files.\n\n- For binary files, use `hd`, `hexdump` or `xxd` for simple hex dumps and `bvi`, `hexedit` or `biew` for binary editing.\n\n- Also for binary files, `strings` (plus `grep`, etc.) lets you find bits of text.\n\n- For binary diffs (delta compression), use `xdelta3`.\n\n- To convert text encodings, try `iconv`. Or `uconv` for more advanced use; it supports some advanced Unicode things. For example:\n```sh\n      # Displays hex codes or actual names of characters (useful for debugging):\n      uconv -f utf-8 -t utf-8 -x '::Any-Hex;' < input.txt\n      uconv -f utf-8 -t utf-8 -x '::Any-Name;' < input.txt\n      # Lowercase and removes all accents (by expanding and dropping them):\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC;' < input.txt > output.txt\n```\n\n- To split files into pieces, see `split` (to split by size) and `csplit` (to split by a pattern).\n\n- Date and time: To get the current date and time in the helpful [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, use `date -u +\"%Y-%m-%dT%H:%M:%SZ\"` (other options [are](https://stackoverflow.com/questions/7216358/date-command-on-os-x-doesnt-have-iso-8601-i-option) [problematic](https://unix.stackexchange.com/questions/164826/date-command-iso-8601-option)). To manipulate date and time expressions, use `dateadd`, `datediff`, `strptime` etc. from [`dateutils`](http://www.fresse.org/dateutils/).\n\n- Use `zless`, `zmore`, `zcat`, and `zgrep` to operate on compressed files.\n\n- File attributes are settable via `chattr` and offer a lower-level alternative to file permissions. For example, to protect against accidental file deletion the immutable flag:  `sudo chattr +i /critical/directory/or/file`\n\n- Use `getfacl` and `setfacl` to save and restore file permissions. For example:\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- To create empty files quickly, use `truncate` (creates [sparse file](https://en.wikipedia.org/wiki/Sparse_file)), `fallocate` (ext4, xfs, btrfs and ocfs2 filesystems), `xfs_mkfile` (almost any filesystems, comes in xfsprogs package), `mkfile` (for Unix-like systems like Solaris, Mac OS).\n\n## System debugging\n\n- For web debugging, `curl` and `curl -I` are handy, or their `wget` equivalents, or the more modern [`httpie`](https://github.com/jkbrzt/httpie).\n\n- To know current cpu/disk status, the classic tools are `top` (or the better `htop`), `iostat`, and `iotop`. Use `iostat -mxz 15` for basic CPU and detailed per-partition disk stats and performance insight.\n\n- For network connection details, use `netstat` and `ss`.\n\n- For a quick overview of what's happening on a system, `dstat` is especially useful. For broadest overview with details, use [`glances`](https://github.com/nicolargo/glances).\n\n- To know memory status, run and understand the output of `free` and `vmstat`. In particular, be aware the \"cached\" value is memory held by the Linux kernel as file cache, so effectively counts toward the \"free\" value.\n\n- Java system debugging is a different kettle of fish, but a simple trick on Oracle's and some other JVMs is that you can run `kill -3 <pid>` and a full stack trace and heap summary (including generational garbage collection details, which can be highly informative) will be dumped to stderr/logs. The JDK's `jps`, `jstat`, `jstack`, `jmap` are useful. [SJK tools](https://github.com/aragozin/jvm-tools) are more advanced.\n\n- Use [`mtr`](http://www.bitwizard.nl/mtr/) as a better traceroute, to identify network issues.\n\n- For looking at why a disk is full, [`ncdu`](https://dev.yorhel.nl/ncdu) saves time over the usual commands like `du -sh *`.\n\n- To find which socket or process is using bandwidth, try [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) or [`nethogs`](https://github.com/raboof/nethogs).\n\n- The `ab` tool (comes with Apache) is helpful for quick-and-dirty checking of web server performance. For more complex load testing, try `siege`.\n\n- For more serious network debugging, [`wireshark`](https://wireshark.org/), [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html), or [`ngrep`](http://ngrep.sourceforge.net/).\n\n- Know about `strace` and `ltrace`. These can be helpful if a program is failing, hanging, or crashing, and you don't know why, or if you want to get a general idea of performance. Note the profiling option (`-c`), and the ability to attach to a running process (`-p`). Use trace child option (`-f`) to avoid missing important calls.\n\n- Know about `ldd` to check shared libraries etc — but [never run it on untrusted files](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/).\n\n- Know how to connect to a running process with `gdb` and get its stack traces.\n\n- Use `/proc`. It's amazingly helpful sometimes when debugging live problems. Examples: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/cmdline`, `/proc/xxx/cwd`, `/proc/xxx/exe`, `/proc/xxx/fd/`, `/proc/xxx/smaps` (where `xxx` is the process id or pid).\n\n- When debugging why something went wrong in the past, [`sar`](http://sebastien.godard.pagesperso-orange.fr/) can be very helpful. It shows historic statistics on CPU, memory, network, etc.\n\n- For deeper systems and performance analyses, look at `stap` ([SystemTap](https://sourceware.org/systemtap/wiki)), [`perf`](https://en.wikipedia.org/wiki/Perf_%28Linux%29), and [`sysdig`](https://github.com/draios/sysdig).\n\n- Check what OS you're on with `uname` or `uname -a` (general Unix/kernel info) or `lsb_release -a` (Linux distro info).\n\n- Use `dmesg` whenever something's acting really funny (it could be hardware or driver issues).\n\n- If you delete a file and it doesn't free up expected disk space as reported by `du`, check whether the file is in use by a process:\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## One-liners\n\nA few examples of piecing together commands:\n\n- It is remarkably helpful sometimes that you can do set intersection, union, and difference of text files via `sort`/`uniq`. Suppose `a` and `b` are text files that are already uniqued. This is fast, and works on files of arbitrary size, up to many gigabytes. (Sort is not limited by memory, though you may need to use the `-T` option if `/tmp` is on a small root partition.) See also the note about `LC_ALL` above and `sort`'s `-u` option (left out for clarity below).\n```sh\n      sort a b | uniq > c   # c is a union b\n      sort a b | uniq -d > c   # c is a intersect b\n      sort a b b | uniq -u > c   # c is set difference a - b\n```\n\n- Pretty-print two JSON files, normalizing their syntax, then coloring and paginating the result:\n```\n      diff <(jq --sort-keys . < file1.json) <(jq --sort-keys . < file2.json) | colordiff | less -R\n```\n\n- Use `grep . *` to quickly examine the contents of all files in a directory (so each line is paired with the filename), or `head -100 *` (so each file has a heading). This can be useful for directories filled with config settings like those in `/sys`, `/proc`, `/etc`.\n\n\n- Summing all numbers in the third column of a text file (this is probably 3X faster and 3X less code than equivalent Python):\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- To see sizes/dates on a tree of files, this is like a recursive `ls -l` but is easier to read than `ls -lR`:\n```sh\n      find . -type f -ls\n```\n\n- Say you have a text file, like a web server log, and a certain value that appears on some lines, such as an `acct_id` parameter that is present in the URL. If you want a tally of how many requests for each `acct_id`:\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- To continuously monitor changes, use `watch`, e.g. check changes to files in a directory with `watch -d -n 2 'ls -rtlh | tail'` or to network settings while troubleshooting your wifi settings with `watch -d -n 2 ifconfig`.\n\n- Run this function to get a random tip from this document (parses Markdown and extracts an item):\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |\n          sed '/cowsay[.]png/d' |\n          pandoc -f markdown -t html |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80 | iconv -t US\n      }\n```\n\n\n## Obscure but useful\n\n- `expr`: perform arithmetic or boolean operations or evaluate regular expressions\n\n- `m4`: simple macro processor\n\n- `yes`: print a string a lot\n\n- `cal`: nice calendar\n\n- `env`: run a command (useful in scripts)\n\n- `printenv`: print out environment variables (useful in debugging and scripts)\n\n- `look`: find English words (or lines in a file) beginning with a string\n\n- `cut`, `paste` and `join`: data manipulation\n\n- `fmt`: format text paragraphs\n\n- `pr`: format text into pages/columns\n\n- `fold`: wrap lines of text\n\n- `column`: format text fields into aligned, fixed-width columns or tables\n\n- `expand` and `unexpand`: convert between tabs and spaces\n\n- `nl`: add line numbers\n\n- `seq`: print numbers\n\n- `bc`: calculator\n\n- `factor`: factor integers\n\n- [`gpg`](https://gnupg.org/): encrypt and sign files\n\n- `toe`: table of terminfo entries\n\n- `nc`: network debugging and data transfer\n\n- `socat`: socket relay and tcp port forwarder (similar to `netcat`)\n\n- [`slurm`](https://github.com/mattthias/slurm): network traffic visualization\n\n- `dd`: moving data between files or devices\n\n- `file`: identify type of a file\n\n- `tree`: display directories and subdirectories as a nesting tree; like `ls` but recursive\n\n- `stat`: file info\n\n- `time`: execute and time a command\n\n- `timeout`: execute a command for specified amount of time and stop the process when the specified amount of time completes.\n\n- `lockfile`: create semaphore file that can only be removed by `rm -f`\n\n- `logrotate`: rotate, compress and mail logs.\n\n- `watch`: run a command repeatedly, showing results and/or highlighting changes\n\n- [`when-changed`](https://github.com/joh/when-changed): runs any command you specify whenever it sees file changed. See `inotifywait` and `entr` as well.\n\n- `tac`: print files in reverse\n\n- `comm`: compare sorted files line by line\n\n- `strings`: extract text from binary files\n\n- `tr`: character translation or manipulation\n\n- `iconv` or `uconv`: conversion for text encodings\n\n- `split` and `csplit`: splitting files\n\n- `sponge`: read all input before writing it, useful for reading from then writing to the same file, e.g., `grep -v something some-file | sponge some-file`\n\n- `units`: unit conversions and calculations; converts furlongs per fortnight to twips per blink (see also `/usr/share/units/definitions.units`)\n\n- `apg`: generates random passwords\n\n- `xz`: high-ratio file compression\n\n- `ldd`: dynamic library info\n\n- `nm`: symbols from object files\n\n- `ab` or [`wrk`](https://github.com/wg/wrk): benchmarking web servers\n\n- `strace`: system call debugging\n\n- [`mtr`](http://www.bitwizard.nl/mtr/): better traceroute for network debugging\n\n- `cssh`: visual concurrent shell\n\n- `rsync`: sync files and folders over SSH or in local file system\n\n- [`wireshark`](https://wireshark.org/) and [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html): packet capture and network debugging\n\n- [`ngrep`](http://ngrep.sourceforge.net/): grep for the network layer\n\n- `host` and `dig`: DNS lookups\n\n- `lsof`: process file descriptor and socket info\n\n- `dstat`: useful system stats\n\n- [`glances`](https://github.com/nicolargo/glances): high level, multi-subsystem overview\n\n- `iostat`: Disk usage stats\n\n- `mpstat`: CPU usage stats\n\n- `vmstat`: Memory usage stats\n\n- `htop`: improved version of top\n\n- `last`: login history\n\n- `w`: who's logged on\n\n- `id`: user/group identity info\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/): historic system stats\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) or [`nethogs`](https://github.com/raboof/nethogs): network utilization by socket or process\n\n- `ss`: socket statistics\n\n- `dmesg`: boot and system error messages\n\n- `sysctl`: view and configure Linux kernel parameters at run time\n\n- `hdparm`: SATA/ATA disk manipulation/performance\n\n- `lsblk`: list block devices: a tree view of your disks and disk partitions\n\n- `lshw`, `lscpu`, `lspci`, `lsusb`, `dmidecode`: hardware information, including CPU, BIOS, RAID, graphics, devices, etc.\n\n- `lsmod` and `modinfo`: List and show details of kernel modules.\n\n- `fortune`, `ddate`, and `sl`: um, well, it depends on whether you consider steam locomotives and Zippy quotations \"useful\"\n\n\n## macOS only\n\nThese are items relevant *only* on macOS.\n\n- Package management with `brew` (Homebrew) and/or `port` (MacPorts). These can be used to install on macOS many of the above commands.\n\n- Copy output of any command to a desktop app with `pbcopy` and paste input from one with `pbpaste`.\n\n- To enable the Option key in macOS Terminal as an alt key (such as used in the commands above like **alt-b**, **alt-f**, etc.), open Preferences -> Profiles -> Keyboard and select \"Use Option as Meta key\".\n\n- To open a file with a desktop app, use `open` or `open -a /Applications/Whatever.app`.\n\n- Spotlight: Search files with `mdfind` and list metadata (such as photo EXIF info) with `mdls`.\n\n- Be aware macOS is based on BSD Unix, and many commands (for example `ps`, `ls`, `tail`, `awk`, `sed`) have many subtle variations from Linux, which is largely influenced by System V-style Unix and GNU tools. You can often tell the difference by noting a man page has the heading \"BSD General Commands Manual.\" In some cases GNU versions can be installed, too (such as `gawk` and `gsed` for GNU awk and sed). If writing cross-platform Bash scripts, avoid such commands (for example, consider Python or `perl`) or test carefully.\n\n- To get macOS release information, use `sw_vers`.\n\n## Windows only\n\nThese items are relevant *only* on Windows.\n\n### Ways to obtain Unix tools under Windows\n\n- Access the power of the Unix shell under Microsoft Windows by installing [Cygwin](https://cygwin.com/). Most of the things described in this document will work out of the box.\n\n- On Windows 10, you can use [Windows Subsystem for Linux (WSL)](https://msdn.microsoft.com/commandline/wsl/about), which provides a familiar Bash environment with Unix command line utilities.\n\n- If you mainly want to use GNU developer tools (such as GCC) on Windows, consider [MinGW](http://www.mingw.org/) and its [MSYS](http://www.mingw.org/wiki/msys) package, which provides utilities such as bash, gawk, make and grep. MSYS doesn't have all the features compared to Cygwin. MinGW is particularly useful for creating native Windows ports of Unix tools.\n\n- Another option to get Unix look and feel under Windows is [Cash](https://github.com/dthree/cash). Note that only very few Unix commands and command-line options are available in this environment.\n\n### Useful Windows command-line tools\n\n- You can perform and script most Windows system administration tasks from the command line by learning and using `wmic`.\n\n- Native command-line Windows networking tools you may find useful include `ping`, `ipconfig`, `tracert`, and `netstat`.\n\n- You can perform [many useful Windows tasks](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) by invoking the `Rundll32` command.\n\n### Cygwin tips and tricks\n\n- Install additional Unix programs with the Cygwin's package manager.\n\n- Use `mintty` as your command-line window.\n\n- Access the Windows clipboard through `/dev/clipboard`.\n\n- Run `cygstart` to open an arbitrary file through its registered application.\n\n- Access the Windows registry with `regtool`.\n\n- Note that a `C:\\` Windows drive path becomes `/cygdrive/c` under Cygwin, and that Cygwin's `/` appears under `C:\\cygwin` on Windows. Convert between Cygwin and Windows-style file paths with `cygpath`. This is most useful in scripts that invoke Windows programs.\n\n## More resources\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell): A curated list of shell tools and resources.\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line): A more in-depth guide for the macOS command line.\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) for writing better shell scripts.\n- [shellcheck](https://github.com/koalaman/shellcheck): A shell script static analysis tool. Essentially, lint for bash/sh/zsh.\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html): The sadly complex minutiae on how to handle filenames correctly in shell scripts.\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools): More commands and tools helpful for doing data science, from the book of the same name\n\n## Disclaimer\n\nWith the exception of very small tasks, code is written so others can read it. With power comes responsibility. The fact you *can* do something in Bash doesn't necessarily mean you should! ;)\n\n\n## License\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\nThis work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).\n"
        },
        {
          "name": "admin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cowsay.png",
          "type": "blob",
          "size": 202.77,
          "content": null
        }
      ]
    }
  ]
}