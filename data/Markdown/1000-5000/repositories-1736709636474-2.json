{
  "metadata": {
    "timestamp": 1736709636474,
    "page": 2,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "walkccc/CLRS",
      "stars": 4775,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0625,
          "content": "*.md linguist-detectable=true\n*.md linguist-documentation=false\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": ".DS_Store\nsite/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2024 Peng-Yu Chen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.205078125,
          "content": "<p align=\"center\">\n  <img src=\"https://i.imgur.com/ESwjKaR.png\" height=\"150\" alt=\"CLRS\">\n</p>\n\n<div align=\"center\">\n\n# Solutions to **Introduction to Algorithms** _Third Edition_\n\nðŸ“š _A crowdsourced work contributed from nice people all around the world._\n\n![](https://img.shields.io/badge/GitHub%20Pages-121011.svg?logo=github&style=flat-square)\n![](https://img.shields.io/badge/Material%20UI-0081CB.svg?logo=material-ui&style=flat-square)\n![](https://img.shields.io/badge/Markdown-239120.svg?logo=markdown&style=flat-square)\n![](https://img.shields.io/badge/KaTeX-008080.svg?logo=latex&style=flat-square)\n<br/>\n![](https://img.shields.io/badge/PRs-welcome-E87A90.svg?style=flat-square)\n[![](https://img.shields.io/github/contributors/walkccc/CLRS.svg?style=flat-square)](https://github.com/walkccc/CLRS/graphs/contributors)\n[![](https://img.shields.io/github/license/walkccc/CLRS.svg?style=flat-square)](./LICENSE)\n\n</div>\n\n## Getting Started\n\nThis **[website](https://walkccc.github.io/CLRS/)** contains nearly complete solutions to the bible textbook - [**Introduction to Algorithms** _Third Edition_](https://mitpress.mit.edu/books/introduction-algorithms-third-edition), published by [Thomas H. Cormen](https://mitpress.mit.edu/contributors/thomas-h-cormen), [Charles E. Leiserson](https://mitpress.mit.edu/contributors/charles-e-leiserson), [Ronald L. Rivest](https://mitpress.mit.edu/contributors/ronald-l-rivest), and [Clifford Stein](https://mitpress.mit.edu/contributors/clifford-stein).\n\nI hope to organize solutions to help people and myself study algorithms. By using [Markdown (.md)](https://en.wikipedia.org/wiki/Markdown) files and [KaTeX](https://katex.org) math library, this page is much more readable on portable devices.\n\n_\"Many a little makes a mickle.\"_\n\n## Contributors\n\nThanks to the authors of [CLRS Solutions](https://sites.math.rutgers.edu/~ajl213/CLRS/CLRS.html), [Michelle Bodnar](mailto:chellebodnar@gmail.com) (who writes the even-numbered problems) and [Andrew Lohr](mailto:Andrew.Lohr@gmail.com) (who writes the odd-numbered problems), [@skanev](https://github.com/skanev), [@CyberZHG](https://github.com/CyberZHG), [@yinyanghu](https://github.com/yinyanghu), [@Gutdub](https://github.com/Gutdub), etc.\n\nThanks to [all contributors on GitHub](https://github.com/walkccc/CLRS/graphs/contributors), you guys make this repository a better reference!\n\nSpecial thanks to [@JeffreyCA](https://github.com/JeffreyCA), who fixed math rendering on iOS Safari in [#26](https://github.com/walkccc/CLRS/pull/26).\n\nIf I miss your name here, please tell me!\n\n## Motivation\n\nI build this website since I want to help everyone learn algorithms by providing something easy to read on mobile devices.\n\nTherefore, if any adjustment is needed or you have the same motivation to contribute to this work, please don't hesitate to give me your feedback. You can press the \"pencil icon\" in the upper right corner to edit the content or [open an issue](https://github.com/walkccc/CLRS/issues/new) in [this repository](https://github.com/walkccc/CLRS/). Your solution will be rebased after I review it and make some form modifications to your pull request.\n\nThere're lots of [issues](https://github.com/walkccc/CLRS/issues) regarding to solutions in this repository, if you have time, please take a look and try to help people on the internet :)\n\nThank you very much, and I hope that everyone will learn algorithms smoothly.\n\n## How I Generate the Website?\n\nI use the static site generator [MkDocs](http://www.mkdocs.org/) and the beautiful theme [Material for MkDocs](https://squidfunk.github.io/mkdocs-material/) to build this website.\n\nAs for rendering math equations, I use [KaTeX](https://katex.org/), which is fast and beautiful.\n\nI also add `overflow-x: auto` to prevent the overflow issue on small screen devices so that you can scroll horizontally in the math display equations.\n\n## More Information\n\nFor a clear commit history, I rebase my repository regularly. Therefore, if you have forked the repository before, consider re-forking it again.\n\nFor more information, please visit [**my GitHub**](https://github.com/walkccc).\n\nUpdated to this new page on April 13, 2018, at 04:48 [(GMT+8)](https://time.is/GMT+8).\n\nRevised on July 21, 2019.\n\n## License\n\nLicensed under the MIT License.\n"
        },
        {
          "name": "custom",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 23.5224609375,
          "content": "site_name: CLRS Solutions\nsite_description: Solutions to Introduction to Algorithms Third Edition. CLRS Solutions. The textbook that a Computer Science (CS) student must read.\nsite_author: P.-Y. Chen\nsite_url: https://walkccc.me/CLRS\n\nrepo_name: walkccc/CLRS\nrepo_url: https://github.com/walkccc/CLRS\n\ntheme:\n  name: material\n  custom_dir: custom\n  language: en\n  favicon: assets/favicon.png\n  font:\n    text: Roboto\n    code: Roboto Mono\n  icon:\n    logo: fontawesome/solid/earth-americas\n    repo: fontawesome/brands/github\n  features:\n    - content.code.copy\n    - navigation.footer\n  palette:\n    - media: \"(prefers-color-scheme: light)\"\n      scheme: default\n      primary: teal\n      accent: blue\n      toggle:\n        icon: material/weather-night\n        name: Switch to dark mode\n    - media: \"(prefers-color-scheme: dark)\"\n      scheme: slate\n      primary: cyan\n      accent: amber\n      toggle:\n        icon: material/weather-sunny\n        name: Switch to light mode\n\n# Customization\ncopyright: Built by <a href=\"http://github.com/walkccc\">P.-Y. Chen</a> &copy; 2017 - 2024\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/walkccc\n    - icon: fontawesome/brands/x-twitter\n      link: https://twitter.com/pengyuc_\n    - icon: fontawesome/brands/linkedin\n      link: https://www.linkedin.com/in/pengyuc\n    - icon: fontawesome/solid/code\n      link: https://walkccc.me/LeetCode\n  analytics:\n    provider: google\n    property: G-NE8FKX91SB\n\nextra_css:\n  - css/katex.css\n  - css/custom.css\n  - https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css\n\nextra_javascript:\n  - js/katex.js\n  - https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js\n  - https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js\n\nmarkdown_extensions:\n  - pymdownx.highlight:\n      anchor_linenums: true\n  - pymdownx.inlinehilite\n  - pymdownx.snippets\n  - pymdownx.superfences\n  - toc:\n      permalink: true\n\nnav:\n  - Preface: index.md\n  - I Foundations:\n      - 1 The Role of Algorithms in Computing:\n          - 1.1 Algorithms: Chap01/1.1.md\n          - 1.2 Algorithms as a technology: Chap01/1.2.md\n          - Chap 1 Problems:\n              - Problem 1-1: Chap01/Problems/1-1.md\n      - 2 Getting Started:\n          - 2.1 Insertion sort: Chap02/2.1.md\n          - 2.2 Analyzing algorithms: Chap02/2.2.md\n          - 2.3 Designing algorithms: Chap02/2.3.md\n          - Chap 2 Problems:\n              - 2-1 Insertion sort on small arrays in merge sort: Chap02/Problems/2-1.md\n              - 2-2 Correctness of bubblesort: Chap02/Problems/2-2.md\n              - 2-3 Correctness of Horner's rule: Chap02/Problems/2-3.md\n              - 2-4 Inversions: Chap02/Problems/2-4.md\n      - 3 Growth of Functions:\n          - 3.1 Asymptotic notation: Chap03/3.1.md\n          - 3.2 Standard notations and common functions: Chap03/3.2.md\n          - Chap 3 Problems:\n              - 3-1 Asymptotic behavior of polynomials: Chap03/Problems/3-1.md\n              - 3-2 Relative asymptotic growths: Chap03/Problems/3-2.md\n              - 3-3 Ordering by asymptotic growth rates: Chap03/Problems/3-3.md\n              - 3-4 Asymptotic notation properties: Chap03/Problems/3-4.md\n              - 3-5 Variations on $O$ and $\\Omega$: Chap03/Problems/3-5.md\n              - 3-6 Iterated functions: Chap03/Problems/3-6.md\n      - 4 Divide-and-Conquer:\n          - 4.1 The maximum-subarray problem: Chap04/4.1.md\n          - 4.2 Strassen's algorithm for matrix multiplication: Chap04/4.2.md\n          - 4.3 The substitution method for solving recurrences: Chap04/4.3.md\n          - 4.4 The recursion-tree method for solving recurrences: Chap04/4.4.md\n          - 4.5 The master method for solving recurrences: Chap04/4.5.md\n          - 4.6 Proof of the master theorem: Chap04/4.6.md\n          - Chap 4 Problems:\n              - 4-1 Recurrence examples: Chap04/Problems/4-1.md\n              - 4-2 Parameter-passing costs: Chap04/Problems/4-2.md\n              - 4-3 More recurrence examples: Chap04/Problems/4-3.md\n              - 4-4 Fibonacci numbers: Chap04/Problems/4-4.md\n              - 4-5 Chip testing: Chap04/Problems/4-5.md\n              - 4-6 Monge arrays: Chap04/Problems/4-6.md\n      - 5 Probabilistic Analysis and Randomized Algorithms:\n          - 5.1 The hiring problem: Chap05/5.1.md\n          - 5.2 Indicator random variables: Chap05/5.2.md\n          - 5.3 Randomized algorithms: Chap05/5.3.md\n          - 5.4 Probabilistic analysis and further uses of indicator random variables: Chap05/5.4.md\n          - Chap 5 Problems:\n              - 5-1 Probabilstic counting: Chap05/Problems/5-1.md\n              - 5-2 Searching an unsorted array: Chap05/Problems/5-2.md\n  - II Sorting and Order Statistics:\n      - 6 Heapsort:\n          - 6.1 Heaps: Chap06/6.1.md\n          - 6.2 Maintaining the heap property: Chap06/6.2.md\n          - 6.3 Building a heap: Chap06/6.3.md\n          - 6.4 The heapsort algorithm: Chap06/6.4.md\n          - 6.5 Priority queues: Chap06/6.5.md\n          - Chap 6 Problems:\n              - 6-1 Building a heap using insertion: Chap06/Problems/6-1.md\n              - 6-2 Analysis of $d$-ary heaps: Chap06/Problems/6-2.md\n              - 6-3 Young tableaus: Chap06/Problems/6-3.md\n      - 7 Quicksort:\n          - 7.1 Description of quicksort: Chap07/7.1.md\n          - 7.2 Performance of quicksort: Chap07/7.2.md\n          - 7.3 A randomized version of quicksort: Chap07/7.3.md\n          - 7.4 Analysis of quicksort: Chap07/7.4.md\n          - Chap 7 Problems:\n              - 7-1 Hoare partition correctness: Chap07/Problems/7-1.md\n              - 7-2 Quicksort with equal element values: Chap07/Problems/7-2.md\n              - 7-3 Alternative quicksort analysis: Chap07/Problems/7-3.md\n              - 7-4 Stack depth for quicksort: Chap07/Problems/7-4.md\n              - 7-5 Median-of-3 partition: Chap07/Problems/7-5.md\n              - 7-6 Fuzzy sorting of intervals: Chap07/Problems/7-6.md\n      - 8 Sorting in Linear Time:\n          - 8.1 Lower bounds for sorting: Chap08/8.1.md\n          - 8.2 Counting sort: Chap08/8.2.md\n          - 8.3 Radix sort: Chap08/8.3.md\n          - 8.4 Bucket sort: Chap08/8.4.md\n          - Chap 8 Problems:\n              - 8-1 Probabilistic lower bounds on comparison sorting: Chap08/Problems/8-1.md\n              - 8-2 Sorting in place in linear time: Chap08/Problems/8-2.md\n              - 8-3 Sorting variable-length items: Chap08/Problems/8-3.md\n              - 8-4 Water jugs: Chap08/Problems/8-4.md\n              - 8-5 Average sorting: Chap08/Problems/8-5.md\n              - 8-6 Lower bound on merging sorted lists: Chap08/Problems/8-6.md\n              - 8-7 The $0$-$1$ sorting lemma and columnsort: Chap08/Problems/8-7.md\n      - 9 Medians and Order Statistics:\n          - 9.1 Minimum and maximum: Chap09/9.1.md\n          - 9.2 Selection in expected linear time: Chap09/9.2.md\n          - 9.3 Selection in worst-case linear time: Chap09/9.3.md\n          - Chap 9 Problems:\n              - 9-1 Largest $i$ numbers in sorted order: Chap09/Problems/9-1.md\n              - 9-2 Weighted median: Chap09/Problems/9-2.md\n              - 9-3 Small order statistics: Chap09/Problems/9-3.md\n              - 9-4 Alternative analysis of randomized selection: Chap09/Problems/9-4.md\n  - III Data Structures:\n      - 10 Elementary Data Structures:\n          - 10.1 Stacks and queues: Chap10/10.1.md\n          - 10.2 Linked lists: Chap10/10.2.md\n          - 10.3 Implementing pointers and objects: Chap10/10.3.md\n          - 10.4 Representing rooted trees: Chap10/10.4.md\n          - Chap 10 Problems:\n              - 10-1 Comparisons among lists: Chap10/Problems/10-1.md\n              - 10-2 Mergeable heaps using linked lists: Chap10/Problems/10-2.md\n              - 10-3 Searching a sorted compact list: Chap10/Problems/10-3.md\n      - 11 Hash Tables:\n          - 11.1 Direct-address tables: Chap11/11.1.md\n          - 11.2 Hash tables: Chap11/11.2.md\n          - 11.3 Hash functions: Chap11/11.3.md\n          - 11.4 Open addressing: Chap11/11.4.md\n          - 11.5 Perfect hashing: Chap11/11.5.md\n          - Chap 11 Problems:\n              - 11-1 Longest-probe bound for hashing: Chap11/Problems/11-1.md\n              - 11-2 Slot-size bound for chaining: Chap11/Problems/11-2.md\n              - 11-3 Quadratic probing: Chap11/Problems/11-3.md\n              - 11-4 Hashing and authentication: Chap11/Problems/11-4.md\n      - 12 Binary Search Trees:\n          - 12.1 What is a binary search tree?: Chap12/12.1.md\n          - 12.2 Querying a binary search tree: Chap12/12.2.md\n          - 12.3 Insertion and deletion: Chap12/12.3.md\n          - 12.4 Randomly built binary search trees: Chap12/12.4.md\n          - Chap 12 Problems:\n              - 12-1 Binary search trees with equal keys: Chap12/Problems/12-1.md\n              - 12-2 Radix trees: Chap12/Problems/12-2.md\n              - 12-3 Average node depth in a randomly built binary search tree: Chap12/Problems/12-3.md\n              - 12-4 Number of different binary trees: Chap12/Problems/12-4.md\n      - 13 Red-Black Trees:\n          - 13.1 Properties of red-black trees: Chap13/13.1.md\n          - 13.2 Rotations: Chap13/13.2.md\n          - 13.3 Insertion: Chap13/13.3.md\n          - 13.4 Deletion: Chap13/13.4.md\n          - Chap 13 Problems:\n              - 13-1 Persistent dynamic sets: Chap13/Problems/13-1.md\n              - 13-2 Join operation on red-black trees: Chap13/Problems/13-2.md\n              - 13-3 AVL trees: Chap13/Problems/13-3.md\n              - 13-4 Treaps: Chap13/Problems/13-4.md\n      - 14 Augmenting Data Structures:\n          - 14.1 Dynamic order statistics: Chap14/14.1.md\n          - 14.2 How to augment a data structure: Chap14/14.2.md\n          - 14.3 Interval trees: Chap14/14.3.md\n          - Chap 14 Problems:\n              - 14-1 Point of maximum overlap: Chap14/Problems/14-1.md\n              - 14-2 Josephus permutation: Chap14/Problems/14-2.md\n  - IV Advanced Design and Analysis Techniques:\n      - 15 Dynamic Programming:\n          - 15.1 Rod cutting: Chap15/15.1.md\n          - 15.2 Matrix-chain multiplication: Chap15/15.2.md\n          - 15.3 Elements of dynamic programming: Chap15/15.3.md\n          - 15.4 Longest common subsequence: Chap15/15.4.md\n          - 15.5 Optimal binary search trees: Chap15/15.5.md\n          - Chap 15 Problems:\n              - 15-1 Longest simple path in a directed acyclic graph: Chap15/Problems/15-1.md\n              - 15-2 Longest palindrome subsequence: Chap15/Problems/15-2.md\n              - 15-3 Bitonic euclidean: Chap15/Problems/15-3.md\n              - 15-4 Printing neatly: Chap15/Problems/15-4.md\n              - 15-5 Edit distance: Chap15/Problems/15-5.md\n              - 15-6 Planning a company party: Chap15/Problems/15-6.md\n              - 15-7 Viterbi algorithm: Chap15/Problems/15-7.md\n              - 15-8 Image compression by seam carving: Chap15/Problems/15-8.md\n              - 15-9 Breaking a string: Chap15/Problems/15-9.md\n              - 15-10 Planning an investment strategy: Chap15/Problems/15-10.md\n              - 15-11 Inventory planning: Chap15/Problems/15-11.md\n              - 15-12 Signing free-agent baseball players: Chap15/Problems/15-12.md\n      - 16 Greedy Algorithms:\n          - 16.1 An activity-selection problem: Chap16/16.1.md\n          - 16.2 Elements of the greedy strategy: Chap16/16.2.md\n          - 16.3 Huffman codes: Chap16/16.3.md\n          - 16.4 Matroids and greedy methods: Chap16/16.4.md\n          - 16.5 A task-scheduling problem as a matroid: Chap16/16.5.md\n          - Chap 16 Problems:\n              - 16-1 Coin changing: Chap16/Problems/16-1.md\n              - 16-2 Scheduling to minimize average completion time: Chap16/Problems/16-2.md\n              - 16-3 Acyclic subgraphs: Chap16/Problems/16-3.md\n              - 16-4 Scheduling variations: Chap16/Problems/16-4.md\n              - 16-5 Off-line caching: Chap16/Problems/16-5.md\n      - 17 Amortized Analysis:\n          - 17.1 Aggregate analysis: Chap17/17.1.md\n          - 17.2 The accounting method: Chap17/17.2.md\n          - 17.3 The potential method: Chap17/17.3.md\n          - 17.4 Dynamic tables: Chap17/17.4.md\n          - Chap 17 Problems:\n              - 17-1 Bit-reversed binary counter: Chap17/Problems/17-1.md\n              - 17-2 Making binary search dynamic: Chap17/Problems/17-2.md\n              - 17-3 Amortized weight-balanced trees: Chap17/Problems/17-3.md\n              - 17-4 The cost of restructuring red-black trees: Chap17/Problems/17-4.md\n              - 17-5 Competitive analysis of self-organizing lists with move-to-front: Chap17/Problems/17-5.md\n  - V Advanced Data Structures:\n      - 18 B-Trees:\n          - 18.1 Definition of B-trees: Chap18/18.1.md\n          - 18.2 Basic operations on B-trees: Chap18/18.2.md\n          - 18.3 Deleting a key from a B-tree: Chap18/18.3.md\n          - Chap 18 Problems:\n              - 18-1 Stacks on secondary storage: Chap18/Problems/18-1.md\n              - 18-2 Joining and splitting 2-3-4 trees: Chap18/Problems/18-2.md\n      - 19 Fibonacci Heaps:\n          - 19.1 Structure of Fibonacci heaps: Chap19/19.1.md\n          - 19.2 Mergeable-heap operations: Chap19/19.2.md\n          - 19.3 Decreasing a key and deleting a node: Chap19/19.3.md\n          - 19.4 Bounding the maximum degree: Chap19/19.4.md\n          - Chap 19 Problems:\n              - 19-1 Alternative implementation of deletion: Chap19/Problems/19-1.md\n              - 19-2 Binomial trees and binomial heaps: Chap19/Problems/19-2.md\n              - 19-3 More Fibonacci-heap operations: Chap19/Problems/19-3.md\n              - 19-4 2-3-4 heaps: Chap19/Problems/19-4.md\n      - 20 van Emde Boas Trees:\n          - 20.1 Preliminary approaches: Chap20/20.1.md\n          - 20.2 A recursive structure: Chap20/20.2.md\n          - 20.3 The van Emde Boas tree: Chap20/20.3.md\n          - Chap 20 Problems:\n              - 20-1 Space requirements for van Emde Boas trees: Chap20/Problems/20-1.md\n              - 20-2 $y$-fast tries: Chap20/Problems/20-2.md\n      - 21 Data Structures for Disjoint Sets:\n          - 21.1 Disjoint-set operations: Chap21/21.1.md\n          - 21.2 Linked-list representation of disjoint sets: Chap21/21.2.md\n          - 21.3 Disjoint-set forests: Chap21/21.3.md\n          - 21.4 Analysis of union by rank with path compression: Chap21/21.4.md\n          - Chap 21 Problems:\n              - 21-1 Off-line minimum: Chap21/Problems/21-1.md\n              - 21-2 Depth determination: Chap21/Problems/21-2.md\n              - 21-3 Tarjan's off-line least-common-ancestors algorithm: Chap21/Problems/21-3.md\n  - VI Graph Algorithms:\n      - 22 Elementary Graph Algorithms:\n          - 22.1 Representations of graphs: Chap22/22.1.md\n          - 22.2 Breadth-first search: Chap22/22.2.md\n          - 22.3 Depth-first search: Chap22/22.3.md\n          - 22.4 Topological sort: Chap22/22.4.md\n          - 22.5 Strongly connected components: Chap22/22.5.md\n          - Chap 22 Problems:\n              - 22-1 Classifying edges by breadth-first search: Chap22/Problems/22-1.md\n              - 22-2 Articulation points, bridges, and biconnected components: Chap22/Problems/22-2.md\n              - 22-3 Euler tour: Chap22/Problems/22-3.md\n              - 22-4 Reachability: Chap22/Problems/22-4.md\n      - 23 Minimum Spanning Trees:\n          - 23.1 Growing a minimum spanning tree: Chap23/23.1.md\n          - 23.2 The algorithms of Kruskal and Prim: Chap23/23.2.md\n          - Chap 23 Problems:\n              - 23-1 Second-best minimum spanning tree: Chap23/Problems/23-1.md\n              - 23-2 Minimum spanning tree in sparse graphs: Chap23/Problems/23-2.md\n              - 23-3 Bottleneck spanning tree: Chap23/Problems/23-3.md\n              - 23-4 Alternative minimum-spanning-tree algorithms: Chap23/Problems/23-4.md\n      - 24 Single-Source Shortest Paths:\n          - 24.1 The Bellman-Ford algorithm: Chap24/24.1.md\n          - 24.2 Single-source shortest paths in directed acyclic graphs: Chap24/24.2.md\n          - 24.3 Dijkstra's algorithm: Chap24/24.3.md\n          - 24.4 Difference constraints and shortest paths: Chap24/24.4.md\n          - 24.5 Proofs of shortest-paths properties: Chap24/24.5.md\n          - Chap 24 Problems:\n              - 24-1 Yen's improvement to Bellman-Ford: Chap24/Problems/24-1.md\n              - 24-2 Nesting boxes: Chap24/Problems/24-2.md\n              - 24-3 Arbitrage: Chap24/Problems/24-3.md\n              - 24-4 Gabow's scaling algorithm for single-source shortest paths: Chap24/Problems/24-4.md\n              - 24-5 Karp's minimum mean-weight cycle algorithm: Chap24/Problems/24-5.md\n              - 24-6 Bitonic shortest paths: Chap24/Problems/24-6.md\n      - 25 All-Pairs Shortest Paths:\n          - 25.1 Shortest paths and matrix multiplication: Chap25/25.1.md\n          - 25.2 The Floyd-Warshall algorithm: Chap25/25.2.md\n          - 25.3 Johnson's algorithm for sparse graphs: Chap25/25.3.md\n          - Chap 25 Problems:\n              - 25-1 Transitive closure of a dynamic graph: Chap25/Problems/25-1.md\n              - 25-2 Shortest paths in epsilon-dense graphs: Chap25/Problems/25-2.md\n      - 26 Maximum Flow:\n          - 26.1 Flow networks: Chap26/26.1.md\n          - 26.2 The Ford-Fulkerson method: Chap26/26.2.md\n          - 26.3 Maximum bipartite matching: Chap26/26.3.md\n          - 26.4 Push-relabel algorithms: Chap26/26.4.md\n          - 26.5 The relabel-to-front algorithm: Chap26/26.5.md\n          - Chap 26 Problems:\n              - 26-1 Escape problem: Chap26/Problems/26-1.md\n              - 26-2 Minimum path cover: Chap26/Problems/26-2.md\n              - 26-3 Algorithmic consulting: Chap26/Problems/26-3.md\n              - 26-4 Updating maximum flow: Chap26/Problems/26-4.md\n              - 26-5 Maximum flow by scaling: Chap26/Problems/26-5.md\n              - 26-6 The Hopcroft-Karp bipartite matching algorithm: Chap26/Problems/26-6.md\n  - VII Selected Topics:\n      - 27 Multithreaded Algorithms:\n          - 27.1 The basics of dynamic multithreading: Chap27/27.1.md\n          - 27.2 Multithreaded matrix multiplication: Chap27/27.2.md\n          - 27.3 Multithreaded merge sort: Chap27/27.3.md\n          - Chap 27 Problems:\n              - 27-1 Implementing parallel loops using nested parallelism: Chap27/Problems/27-1.md\n              - 27-2 Saving temporary space in matrix multiplication: Chap27/Problems/27-2.md\n              - 27-3 Multithreaded matrix algorithms: Chap27/Problems/27-3.md\n              - 27-4 Multithreading reductions and prefix computations: Chap27/Problems/27-4.md\n              - 27-5 Multithreading a simple stencil calculation: Chap27/Problems/27-5.md\n              - 27-6 Randomized multithreaded algorithms: Chap27/Problems/27-6.md\n      - 28 Matrix Operations:\n          - 28.1 Solving systems of linear equations: Chap28/28.1.md\n          - 28.2 Inverting matrices: Chap28/28.2.md\n          - 28.3 Symmetric positive-definite matrices and least-squares approximation: Chap28/28.3.md\n          - Chap 28 Problems:\n              - 28-1 Tridiagonal systems of linear equations: Chap28/Problems/28-1.md\n              - 28-2 Splines: Chap28/Problems/28-2.md\n      - 29 Linear Programming:\n          - 29.1 Standard and slack forms: Chap29/29.1.md\n          - 29.2 Formulating problems as linear programs: Chap29/29.2.md\n          - 29.3 The simplex algorithm: Chap29/29.3.md\n          - 29.4 Duality: Chap29/29.4.md\n          - 29.5 The initial basic feasible solution: Chap29/29.5.md\n          - Chap 29 Problems:\n              - 29-1 Linear-inequality feasibility: Chap29/Problems/29-1.md\n              - 29-2 Complementary slackness: Chap29/Problems/29-2.md\n              - 29-3 Integer linear programming: Chap29/Problems/29-3.md\n              - 29-4 Farkas'ss lemma: Chap29/Problems/29-4.md\n              - 29-5 Minimum-cost circulation: Chap29/Problems/29-5.md\n      - 30 Polynomials and the FFT:\n          - 30.1 Representing polynomials: Chap30/30.1.md\n          - 30.2 The DFT and FFT: Chap30/30.2.md\n          - 30.3 Efficient FFT implementations: Chap30/30.3.md\n          - Chap 30 Problems:\n              - 30-1 Divide-and-conquer multiplication: Chap30/Problems/30-1.md\n              - 30-2 Toeplitz matrices: Chap30/Problems/30-2.md\n              - 30-3 Multidimensional fast Fourier transform: Chap30/Problems/30-3.md\n              - 30-4 Evaluating all derivatives of a polynomial at a point: Chap30/Problems/30-4.md\n              - 30-5 Polynomial evaluation at multiple points: Chap30/Problems/30-5.md\n              - 30-6 FFT using modular arithmetic: Chap30/Problems/30-6.md\n      - 31 Number-Theoretic Algorithms:\n          - 31.1 Elementary number-theoretic notions: Chap31/31.1.md\n          - 31.2 Greatest common divisor: Chap31/31.2.md\n          - 31.3 Modular arithmetic: Chap31/31.3.md\n          - 31.4 Solving modular linear equations: Chap31/31.4.md\n          - 31.5 The Chinese remainder theorem: Chap31/31.5.md\n          - 31.6 Powers of an element: Chap31/31.6.md\n          - 31.7 The RSA public-key cryptosystem: Chap31/31.7.md\n          - 31.8 Primality testing: Chap31/31.8.md\n          - 31.9 Integer factorization: Chap31/31.9.md\n          - Chap 31 Problems:\n              - 31-1 Binary gcd algorithm: Chap31/Problems/31-1.md\n              - 31-2 Analysis of bit operations in Euclid's algorithm: Chap31/Problems/31-2.md\n              - 31-3 Three algorithms for Fibonacci numbers: Chap31/Problems/31-3.md\n              - 31-4 Quadratic residues: Chap31/Problems/31-4.md\n      - 32 String Matching:\n          - 32.1 The naive string-matching algorithm: Chap32/32.1.md\n          - 32.2 The Rabin-Karp algorithm: Chap32/32.2.md\n          - 32.3 String matching with finite automata: Chap32/32.3.md\n          - 32.4 The Knuth-Morris-Pratt algorithm: Chap32/32.4.md\n          - Chap 32 Problems:\n              - 32-1 String matching based on repetition factors: Chap32/Problems/32-1.md\n      - 33 Computational Geometry:\n          - 33.1 Line-segment properties: Chap33/33.1.md\n          - 33.2 Determining whether any pair of segments intersects: Chap33/33.2.md\n          - 33.3 Finding the convex hull: Chap33/33.3.md\n          - 33.4 Finding the closest pair of points: Chap33/33.4.md\n          - Chap 33 Problems:\n              - 33-1 Convex layers: Chap33/Problems/33-1.md\n              - 33-2 Maximal layers: Chap33/Problems/33-2.md\n              - 33-3 Ghostbusters and ghosts: Chap33/Problems/33-3.md\n              - 33-4 Picking up sticks: Chap33/Problems/33-4.md\n              - 33-5 Sparse-hulled distributions: Chap33/Problems/33-5.md\n      - 34 NP-Completeness:\n          - 34.1 Polynomial time: Chap34/34.1.md\n          - 34.2 Polynomial-time verification: Chap34/34.2.md\n          - 34.3 NP-completeness and reducibility: Chap34/34.3.md\n          - 34.4 NP-completeness proofs: Chap34/34.4.md\n          - 34.5 NP-complete problems: Chap34/34.5.md\n          - Chap 34 Problems:\n              - 34-1 Independent set: Chap34/Problems/34-1.md\n              - 34-2 Bonnie and Clyde: Chap34/Problems/34-2.md\n              - 34-3 Graph coloring: Chap34/Problems/34-3.md\n              - 34-4 Scheduling with profits and deadlines: Chap34/Problems/34-4.md\n      - 35 Approximation Algorithms:\n          - 35.1 The vertex-cover problem: Chap35/35.1.md\n          - 35.2 The traveling-salesman problem: Chap35/35.2.md\n          - 35.3 The set-covering problem: Chap35/35.3.md\n          - 35.4 Randomization and linear programming: Chap35/35.4.md\n          - 35.5 The subset-sum problem: Chap35/35.5.md\n          - Chap 35 Problems:\n              - 35-1 Bin packing: Chap35/Problems/35-1.md\n              - 35-2 Approximating the size of a maximum clique: Chap35/Problems/35-2.md\n              - 35-3 Weighted set-covering problem: Chap35/Problems/35-3.md\n              - 35-4 Maximum matching: Chap35/Problems/35-4.md\n              - 35-5 Parallel machine scheduling: Chap35/Problems/35-5.md\n              - 35-6 Approximating a maximum spanning tree: Chap35/Problems/35-6.md\n              - 35-7 An approximation algorithm for the 0-1 knapsack problem: Chap35/Problems/35-7.md\n"
        }
      ]
    }
  ]
}