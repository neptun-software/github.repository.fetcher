{
  "metadata": {
    "timestamp": 1736557445524,
    "page": 459,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dylanaraps/pure-bash-bible",
      "stars": 36726,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.06,
          "content": "language: bash\n\nos:\n    - linux\n\nscript:\n    - ./test.sh\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.7,
          "content": "# Writing the Bible\n\n<!-- vim-markdown-toc GFM -->\n\n* [Adding Code to the Bible.](#adding-code-to-the-bible)\n* [Special meanings for code blocks.](#special-meanings-for-code-blocks)\n* [Writing tests](#writing-tests)\n* [Running tests](#running-tests)\n\n<!-- vim-markdown-toc -->\n\n## Adding Code to the Bible.\n\n- The code must use only `bash` built-ins.\n    - A fallback to an external program is allowed if the code doesn't\n      always work.\n    - Example Fallback: `${HOSTNAME:-$(hostname)}`\n- If possible, wrap the code in a function.\n    - This allows tests to be written.\n    - It also allows `shellcheck` to properly lint it.\n    - An added bonus is showing a working use-case.\n- Write some examples.\n    - Show some input and the modified output.\n\n\n## Special meanings for code blocks.\n\nUse `sh` for functions that should be linted and unit tested.\n\n    ```sh\n    # Shellcheck will lint this and the test script will source this.\n    func() {\n        # Usage: func \"arg\"\n        :\n    }\n    ```\n\nUse `shell` for code that should be ignored.\n\n    ```shell\n    # Shorter file creation syntax.\n    :>file\n    ```\n\n## Writing tests\n\nThe test file is viewable here: https://github.com/dylanaraps/pure-bash-bible/blob/master/test.sh\n\nExample test:\n\n```sh\ntest_upper() {\n    result=\"$(upper \"HeLlO\")\"\n    assert_equals \"$result\" \"HELLO\"\n}\n```\n\nSteps:\n\n1. Write the test.\n    - Naming is `test_func_name`\n    - Store the function output in a variable (`$result` or `${result[@]}`).\n    - Use `assert_equals` to test equality between the variable and the\n      expected output.\n2. The test script will automatically execute it. :+1:\n\n\n## Running tests\n\nRunning `test.sh` also runs `shellcheck` on the code.\n\n```sh\ncd pure-bash-bible\n./test.sh\n```\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.05,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 Dylan Araps\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 48.26,
          "content": "<p align=\"center\"><b>NEW: <a href=\"https://github.com/dylanaraps/pure-sh-bible\">pure sh bible (ðŸ“– A collection of pure POSIX sh alternatives to external processes).</a></b></p>\n\n<br>\n\n<p align=\"center\"><img src=\"https://raw.githubusercontent.com/odb/official-bash-logo/master/assets/Logos/Icons/PNG/512x512.png\" width=\"200px\"></p>\n<h1 align=\"center\">pure bash bible</h1> <p\nalign=\"center\">A collection of pure bash alternatives to external\nprocesses.</p>\n\n<p align=\"center\"> <a\nhref=\"https://travis-ci.com/dylanaraps/pure-bash-bible\"><img\nsrc=\"https://travis-ci.com/dylanaraps/pure-bash-bible.svg?branch=master\"></a>\n<a href=\"./LICENSE.md\"><img\nsrc=\"https://img.shields.io/badge/license-MIT-blue.svg\"></a>\n</p>\n\n<br>\n\n<a href=\"https://leanpub.com/bash/\">\n<img src=\"https://s3.amazonaws.com/titlepages.leanpub.com/bash/hero\" width=\"40%\" align=\"right\">\n</a>\n\nThe goal of this book is to document commonly-known and lesser-known methods of doing various tasks using only built-in `bash` features. Using the snippets from this bible can help remove unneeded dependencies from scripts and in most cases make them faster. I came across these tips and discovered a few while developing [neofetch](https://github.com/dylanaraps/neofetch), [pxltrm](https://github.com/dylanaraps/pxltrm) and other smaller projects.\n\nThe snippets below are linted using `shellcheck` and tests have been written where applicable. Want to contribute? Read the [CONTRIBUTING.md](https://github.com/dylanaraps/pure-bash-bible/blob/master/CONTRIBUTING.md). It outlines how the unit tests work and what is required when adding snippets to the bible.\n\nSee something incorrectly described, buggy or outright wrong? Open an issue or send a pull request. If the bible is missing something, open an issue and a solution will be found.\n\n<br>\n<p align=\"center\"><b>This book is also available to purchase on leanpub. https://leanpub.com/bash</b></p>\n<p align=\"center\"><b>Or you can buy me a coffee.</b>\n<a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=V7QNJNKS3WYVS\"><img src=\"https://img.shields.io/badge/don-paypal-yellow.svg\"></a> <a href=\"https://www.patreon.com/dyla\"><img src=\"https://img.shields.io/badge/don-patreon-yellow.svg\"> </a><a href=\"https://liberapay.com/2211/\"><img src=\"https://img.shields.io/badge/don-liberapay-yellow.svg\"></a>\n</p>\n\n<br>\n\n# Table of Contents\n\n<!-- vim-markdown-toc GFM -->\n\n* [FOREWORD](#foreword)\n* [STRINGS](#strings)\n    * [Trim leading and trailing white-space from string](#trim-leading-and-trailing-white-space-from-string)\n    * [Trim all white-space from string and truncate spaces](#trim-all-white-space-from-string-and-truncate-spaces)\n    * [Use regex on a string](#use-regex-on-a-string)\n    * [Split a string on a delimiter](#split-a-string-on-a-delimiter)\n    * [Change a string to lowercase](#change-a-string-to-lowercase)\n    * [Change a string to uppercase](#change-a-string-to-uppercase)\n    * [Reverse a string case](#reverse-a-string-case)\n    * [Trim quotes from a string](#trim-quotes-from-a-string)\n    * [Strip all instances of pattern from string](#strip-all-instances-of-pattern-from-string)\n    * [Strip first occurrence of pattern from string](#strip-first-occurrence-of-pattern-from-string)\n    * [Strip pattern from start of string](#strip-pattern-from-start-of-string)\n    * [Strip pattern from end of string](#strip-pattern-from-end-of-string)\n    * [Percent-encode a string](#percent-encode-a-string)\n    * [Decode a percent-encoded string](#decode-a-percent-encoded-string)\n    * [Check if string contains a sub-string](#check-if-string-contains-a-sub-string)\n    * [Check if string starts with sub-string](#check-if-string-starts-with-sub-string)\n    * [Check if string ends with sub-string](#check-if-string-ends-with-sub-string)\n* [ARRAYS](#arrays)\n    * [Reverse an array](#reverse-an-array)\n    * [Remove duplicate array elements](#remove-duplicate-array-elements)\n    * [Random array element](#random-array-element)\n    * [Cycle through an array](#cycle-through-an-array)\n    * [Toggle between two values](#toggle-between-two-values)\n* [LOOPS](#loops)\n    * [Loop over a range of numbers](#loop-over-a-range-of-numbers)\n    * [Loop over a variable range of numbers](#loop-over-a-variable-range-of-numbers)\n    * [Loop over an array](#loop-over-an-array)\n    * [Loop over an array with an index](#loop-over-an-array-with-an-index)\n    * [Loop over the contents of a file](#loop-over-the-contents-of-a-file)\n    * [Loop over files and directories](#loop-over-files-and-directories)\n* [FILE HANDLING](#file-handling)\n    * [Read a file to a string](#read-a-file-to-a-string)\n    * [Read a file to an array (*by line*)](#read-a-file-to-an-array-by-line)\n    * [Get the first N lines of a file](#get-the-first-n-lines-of-a-file)\n    * [Get the last N lines of a file](#get-the-last-n-lines-of-a-file)\n    * [Get the number of lines in a file](#get-the-number-of-lines-in-a-file)\n    * [Count files or directories in directory](#count-files-or-directories-in-directory)\n    * [Create an empty file](#create-an-empty-file)\n    * [Extract lines between two markers](#extract-lines-between-two-markers)\n* [FILE PATHS](#file-paths)\n    * [Get the directory name of a file path](#get-the-directory-name-of-a-file-path)\n    * [Get the base-name of a file path](#get-the-base-name-of-a-file-path)\n* [VARIABLES](#variables)\n    * [Assign and access a variable using a variable](#assign-and-access-a-variable-using-a-variable)\n    * [Name a variable based on another variable](#name-a-variable-based-on-another-variable)\n* [ESCAPE SEQUENCES](#escape-sequences)\n    * [Text Colors](#text-colors)\n    * [Text Attributes](#text-attributes)\n    * [Cursor Movement](#cursor-movement)\n    * [Erasing Text](#erasing-text)\n* [PARAMETER EXPANSION](#parameter-expansion)\n    * [Indirection](#indirection)\n    * [Replacement](#replacement)\n    * [Length](#length)\n    * [Expansion](#expansion)\n    * [Case Modification](#case-modification)\n    * [Default Value](#default-value)\n* [BRACE EXPANSION](#brace-expansion)\n    * [Ranges](#ranges)\n    * [String Lists](#string-lists)\n* [CONDITIONAL EXPRESSIONS](#conditional-expressions)\n    * [File Conditionals](#file-conditionals)\n    * [File Comparisons](#file-comparisons)\n    * [Variable Conditionals](#variable-conditionals)\n    * [Variable Comparisons](#variable-comparisons)\n* [ARITHMETIC OPERATORS](#arithmetic-operators)\n    * [Assignment](#assignment)\n    * [Arithmetic](#arithmetic)\n    * [Bitwise](#bitwise)\n    * [Logical](#logical)\n    * [Miscellaneous](#miscellaneous)\n* [ARITHMETIC](#arithmetic-1)\n    * [Simpler syntax to set variables](#simpler-syntax-to-set-variables)\n    * [Ternary Tests](#ternary-tests)\n* [TRAPS](#traps)\n    * [Do something on script exit](#do-something-on-script-exit)\n    * [Ignore terminal interrupt (CTRL+C, SIGINT)](#ignore-terminal-interrupt-ctrlc-sigint)\n    * [React to window resize](#react-to-window-resize)\n    * [Do something before every command](#do-something-before-every-command)\n    * [Do something when a shell function or a sourced file finishes executing](#do-something-when-a-shell-function-or-a-sourced-file-finishes-executing)\n* [PERFORMANCE](#performance)\n    * [Disable Unicode](#disable-unicode)\n* [OBSOLETE SYNTAX](#obsolete-syntax)\n    * [Shebang](#shebang)\n    * [Command Substitution](#command-substitution)\n    * [Function Declaration](#function-declaration)\n* [INTERNAL VARIABLES](#internal-variables)\n    * [Get the location to the `bash` binary](#get-the-location-to-the-bash-binary)\n    * [Get the version of the current running `bash` process](#get-the-version-of-the-current-running-bash-process)\n    * [Open the user's preferred text editor](#open-the-users-preferred-text-editor)\n    * [Get the name of the current function](#get-the-name-of-the-current-function)\n    * [Get the host-name of the system](#get-the-host-name-of-the-system)\n    * [Get the architecture of the Operating System](#get-the-architecture-of-the-operating-system)\n    * [Get the name of the Operating System / Kernel](#get-the-name-of-the-operating-system--kernel)\n    * [Get the current working directory](#get-the-current-working-directory)\n    * [Get the number of seconds the script has been running](#get-the-number-of-seconds-the-script-has-been-running)\n    * [Get a pseudorandom integer](#get-a-pseudorandom-integer)\n* [INFORMATION ABOUT THE TERMINAL](#information-about-the-terminal)\n    * [Get the terminal size in lines and columns (*from a script*)](#get-the-terminal-size-in-lines-and-columns-from-a-script)\n    * [Get the terminal size in pixels](#get-the-terminal-size-in-pixels)\n    * [Get the current cursor position](#get-the-current-cursor-position)\n* [CONVERSION](#conversion)\n    * [Convert a hex color to RGB](#convert-a-hex-color-to-rgb)\n    * [Convert an RGB color to hex](#convert-an-rgb-color-to-hex)\n* [CODE GOLF](#code-golf)\n    * [Shorter `for` loop syntax](#shorter-for-loop-syntax)\n    * [Shorter infinite loops](#shorter-infinite-loops)\n    * [Shorter function declaration](#shorter-function-declaration)\n    * [Shorter `if` syntax](#shorter-if-syntax)\n    * [Simpler `case` statement to set variable](#simpler-case-statement-to-set-variable)\n* [OTHER](#other)\n    * [Use `read` as an alternative to the `sleep` command](#use-read-as-an-alternative-to-the-sleep-command)\n    * [Check if a program is in the user's PATH](#check-if-a-program-is-in-the-users-path)\n    * [Get the current date using `strftime`](#get-the-current-date-using-strftime)\n    * [Get the username of the current user](#get-the-username-of-the-current-user)\n    * [Generate a UUID V4](#generate-a-uuid-v4)\n    * [Progress bars](#progress-bars)\n    * [Get the list of functions in a script](#get-the-list-of-functions-in-a-script)\n    * [Bypass shell aliases](#bypass-shell-aliases)\n    * [Bypass shell functions](#bypass-shell-functions)\n    * [Run a command in the background](#run-a-command-in-the-background)\n    * [Capture function return without command substitution](#capture-the-return-value-of-a-function-without-command-substitution)\n* [AFTERWORD](#afterword)\n\n<!-- vim-markdown-toc -->\n\n<br>\n\n<!-- CHAPTER START -->\n# FOREWORD\n\nA collection of pure `bash` alternatives to external processes and programs. The `bash` scripting language is more powerful than people realise and most tasks can be accomplished without depending on external programs.\n\nCalling an external process in `bash` is expensive and excessive use will cause a noticeable slowdown. Scripts and programs written using built-in methods (*where applicable*) will be faster, require fewer dependencies and afford a better understanding of the language itself.\n\nThe contents of this book provide a reference for solving problems encountered when writing programs and scripts in `bash`. Examples are in function formats showcasing how to incorporate these solutions into code.\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# STRINGS\n\n## Trim leading and trailing white-space from string\n\nThis is an alternative to `sed`, `awk`, `perl` and other tools. The\nfunction below works by finding all leading and trailing white-space and\nremoving it from the start and end of the string. The `:` built-in is used in place of a temporary variable.\n\n**Example Function:**\n\n```sh\ntrim_string() {\n    # Usage: trim_string \"   example   string    \"\n    : \"${1#\"${1%%[![:space:]]*}\"}\"\n    : \"${_%\"${_##*[![:space:]]}\"}\"\n    printf '%s\\n' \"$_\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ trim_string \"    Hello,  World    \"\nHello,  World\n\n$ name=\"   John Black  \"\n$ trim_string \"$name\"\nJohn Black\n```\n\n\n## Trim all white-space from string and truncate spaces\n\nThis is an alternative to `sed`, `awk`, `perl` and other tools. The\nfunction below works by abusing word splitting to create a new string\nwithout leading/trailing white-space and with truncated spaces.\n\n**Example Function:**\n\n```sh\n# shellcheck disable=SC2086,SC2048\ntrim_all() {\n    # Usage: trim_all \"   example   string    \"\n    set -f\n    set -- $*\n    printf '%s\\n' \"$*\"\n    set +f\n}\n```\n\n**Example Usage:**\n\n```shell\n$ trim_all \"    Hello,    World    \"\nHello, World\n\n$ name=\"   John   Black  is     my    name.    \"\n$ trim_all \"$name\"\nJohn Black is my name.\n```\n\n## Use regex on a string\n\nThe result of `bash`'s regex matching can be used to replace `sed` for a\nlarge number of use-cases.\n\n**CAVEAT**: This is one of the few platform dependent `bash` features.\n`bash` will use whatever regex engine is installed on the user's system.\nStick to POSIX regex features if aiming for compatibility.\n\n**CAVEAT**: This example only prints the first matching group. When using\nmultiple capture groups some modification is needed.\n\n**Example Function:**\n\n```sh\nregex() {\n    # Usage: regex \"string\" \"regex\"\n    [[ $1 =~ $2 ]] && printf '%s\\n' \"${BASH_REMATCH[1]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ # Trim leading white-space.\n$ regex '    hello' '^\\s*(.*)'\nhello\n\n$ # Validate a hex color.\n$ regex \"#FFFFFF\" '^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$'\n#FFFFFF\n\n$ # Validate a hex color (invalid).\n$ regex \"red\" '^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$'\n# no output (invalid)\n```\n\n**Example Usage in script:**\n\n```shell\nis_hex_color() {\n    if [[ $1 =~ ^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$ ]]; then\n        printf '%s\\n' \"${BASH_REMATCH[1]}\"\n    else\n        printf '%s\\n' \"error: $1 is an invalid color.\"\n        return 1\n    fi\n}\n\nread -r color\nis_hex_color \"$color\" || color=\"#FFFFFF\"\n\n# Do stuff.\n```\n\n\n## Split a string on a delimiter\n\n**CAVEAT:** Requires `bash` 4+\n\nThis is an alternative to `cut`, `awk` and other tools.\n\n**Example Function:**\n\n```sh\nsplit() {\n   # Usage: split \"string\" \"delimiter\"\n   IFS=$'\\n' read -d \"\" -ra arr <<< \"${1//$2/$'\\n'}\"\n   printf '%s\\n' \"${arr[@]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ split \"apples,oranges,pears,grapes\" \",\"\napples\noranges\npears\ngrapes\n\n$ split \"1, 2, 3, 4, 5\" \", \"\n1\n2\n3\n4\n5\n\n# Multi char delimiters work too!\n$ split \"hello---world---my---name---is---john\" \"---\"\nhello\nworld\nmy\nname\nis\njohn\n```\n\n## Change a string to lowercase\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\nlower() {\n    # Usage: lower \"string\"\n    printf '%s\\n' \"${1,,}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ lower \"HELLO\"\nhello\n\n$ lower \"HeLlO\"\nhello\n\n$ lower \"hello\"\nhello\n```\n\n## Change a string to uppercase\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\nupper() {\n    # Usage: upper \"string\"\n    printf '%s\\n' \"${1^^}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ upper \"hello\"\nHELLO\n\n$ upper \"HeLlO\"\nHELLO\n\n$ upper \"HELLO\"\nHELLO\n```\n\n## Reverse a string case\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\nreverse_case() {\n    # Usage: reverse_case \"string\"\n    printf '%s\\n' \"${1~~}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ reverse_case \"hello\"\nHELLO\n\n$ reverse_case \"HeLlO\"\nhElLo\n\n$ reverse_case \"HELLO\"\nhello\n```\n\n## Trim quotes from a string\n\n**Example Function:**\n\n```sh\ntrim_quotes() {\n    # Usage: trim_quotes \"string\"\n    : \"${1//\\'}\"\n    printf '%s\\n' \"${_//\\\"}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ var=\"'Hello', \\\"World\\\"\"\n$ trim_quotes \"$var\"\nHello, World\n```\n\n## Strip all instances of pattern from string\n\n**Example Function:**\n\n```sh\nstrip_all() {\n    # Usage: strip_all \"string\" \"pattern\"\n    printf '%s\\n' \"${1//$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ strip_all \"The Quick Brown Fox\" \"[aeiou]\"\nTh Qck Brwn Fx\n\n$ strip_all \"The Quick Brown Fox\" \"[[:space:]]\"\nTheQuickBrownFox\n\n$ strip_all \"The Quick Brown Fox\" \"Quick \"\nThe Brown Fox\n```\n\n## Strip first occurrence of pattern from string\n\n**Example Function:**\n\n```sh\nstrip() {\n    # Usage: strip \"string\" \"pattern\"\n    printf '%s\\n' \"${1/$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ strip \"The Quick Brown Fox\" \"[aeiou]\"\nTh Quick Brown Fox\n\n$ strip \"The Quick Brown Fox\" \"[[:space:]]\"\nTheQuick Brown Fox\n```\n\n## Strip pattern from start of string\n\n**Example Function:**\n\n```sh\nlstrip() {\n    # Usage: lstrip \"string\" \"pattern\"\n    printf '%s\\n' \"${1##$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ lstrip \"The Quick Brown Fox\" \"The \"\nQuick Brown Fox\n```\n\n## Strip pattern from end of string\n\n**Example Function:**\n\n```sh\nrstrip() {\n    # Usage: rstrip \"string\" \"pattern\"\n    printf '%s\\n' \"${1%%$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ rstrip \"The Quick Brown Fox\" \" Fox\"\nThe Quick Brown\n```\n\n## Percent-encode a string\n\n**Example Function:**\n\n```sh\nurlencode() {\n    # Usage: urlencode \"string\"\n    local LC_ALL=C\n    for (( i = 0; i < ${#1}; i++ )); do\n        : \"${1:i:1}\"\n        case \"$_\" in\n            [a-zA-Z0-9.~_-])\n                printf '%s' \"$_\"\n            ;;\n\n            *)\n                printf '%%%02X' \"'$_\"\n            ;;\n        esac\n    done\n    printf '\\n'\n}\n```\n\n**Example Usage:**\n\n```shell\n$ urlencode \"https://github.com/dylanaraps/pure-bash-bible\"\nhttps%3A%2F%2Fgithub.com%2Fdylanaraps%2Fpure-bash-bible\n```\n\n## Decode a percent-encoded string\n\n**Example Function:**\n\n```sh\nurldecode() {\n    # Usage: urldecode \"string\"\n    : \"${1//+/ }\"\n    printf '%b\\n' \"${_//%/\\\\x}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ urldecode \"https%3A%2F%2Fgithub.com%2Fdylanaraps%2Fpure-bash-bible\"\nhttps://github.com/dylanaraps/pure-bash-bible\n```\n\n## Check if string contains a sub-string\n\n**Using a test:**\n\n```shell\nif [[ $var == *sub_string* ]]; then\n    printf '%s\\n' \"sub_string is in var.\"\nfi\n\n# Inverse (substring not in string).\nif [[ $var != *sub_string* ]]; then\n    printf '%s\\n' \"sub_string is not in var.\"\nfi\n\n# This works for arrays too!\nif [[ ${arr[*]} == *sub_string* ]]; then\n    printf '%s\\n' \"sub_string is in array.\"\nfi\n```\n\n**Using a case statement:**\n\n```shell\ncase \"$var\" in\n    *sub_string*)\n        # Do stuff\n    ;;\n\n    *sub_string2*)\n        # Do more stuff\n    ;;\n\n    *)\n        # Else\n    ;;\nesac\n```\n\n## Check if string starts with sub-string\n\n```shell\nif [[ $var == sub_string* ]]; then\n    printf '%s\\n' \"var starts with sub_string.\"\nfi\n\n# Inverse (var does not start with sub_string).\nif [[ $var != sub_string* ]]; then\n    printf '%s\\n' \"var does not start with sub_string.\"\nfi\n```\n\n## Check if string ends with sub-string\n\n```shell\nif [[ $var == *sub_string ]]; then\n    printf '%s\\n' \"var ends with sub_string.\"\nfi\n\n# Inverse (var does not end with sub_string).\nif [[ $var != *sub_string ]]; then\n    printf '%s\\n' \"var does not end with sub_string.\"\nfi\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# ARRAYS\n\n## Reverse an array\n\nEnabling `extdebug` allows access to the `BASH_ARGV` array which stores\nthe current functionâ€™s arguments in reverse.\n\n**CAVEAT**: Requires `shopt -s compat44` in `bash` 5.0+.\n\n**Example Function:**\n\n```sh\nreverse_array() {\n    # Usage: reverse_array \"array\"\n    shopt -s extdebug\n    f()(printf '%s\\n' \"${BASH_ARGV[@]}\"); f \"$@\"\n    shopt -u extdebug\n}\n```\n\n**Example Usage:**\n\n```shell\n$ reverse_array 1 2 3 4 5\n5\n4\n3\n2\n1\n\n$ arr=(red blue green)\n$ reverse_array \"${arr[@]}\"\ngreen\nblue\nred\n```\n\n## Remove duplicate array elements\n\nCreate a temporary associative array. When setting associative array\nvalues and a duplicate assignment occurs, bash overwrites the key. This\nallows us to effectively remove array duplicates.\n\n**CAVEAT:** Requires `bash` 4+\n\n**CAVEAT:** List order may not stay the same.\n\n**Example Function:**\n\n```sh\nremove_array_dups() {\n    # Usage: remove_array_dups \"array\"\n    declare -A tmp_array\n\n    for i in \"$@\"; do\n        [[ $i ]] && IFS=\" \" tmp_array[\"${i:- }\"]=1\n    done\n\n    printf '%s\\n' \"${!tmp_array[@]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ remove_array_dups 1 1 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 5\n1\n2\n3\n4\n5\n\n$ arr=(red red green blue blue)\n$ remove_array_dups \"${arr[@]}\"\nred\ngreen\nblue\n```\n\n## Random array element\n\n**Example Function:**\n\n```sh\nrandom_array_element() {\n    # Usage: random_array_element \"array\"\n    local arr=(\"$@\")\n    printf '%s\\n' \"${arr[RANDOM % $#]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ array=(red green blue yellow brown)\n$ random_array_element \"${array[@]}\"\nyellow\n\n# Multiple arguments can also be passed.\n$ random_array_element 1 2 3 4 5 6 7\n3\n```\n\n## Cycle through an array\n\nEach time the `printf` is called, the next array element is printed. When\nthe print hits the last array element it starts from the first element\nagain.\n\n```sh\narr=(a b c d)\n\ncycle() {\n    printf '%s ' \"${arr[${i:=0}]}\"\n    ((i=i>=${#arr[@]}-1?0:++i))\n}\n```\n\n\n## Toggle between two values\n\nThis works the same as above, this is just a different use case.\n\n```sh\narr=(true false)\n\ncycle() {\n    printf '%s ' \"${arr[${i:=0}]}\"\n    ((i=i>=${#arr[@]}-1?0:++i))\n}\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# LOOPS\n\n## Loop over a range of numbers\n\nAlternative to `seq`.\n\n```shell\n# Loop from 0-100 (no variable support).\nfor i in {0..100}; do\n    printf '%s\\n' \"$i\"\ndone\n```\n\n## Loop over a variable range of numbers\n\nAlternative to `seq`.\n\n```shell\n# Loop from 0-VAR.\nVAR=50\nfor ((i=0;i<=VAR;i++)); do\n    printf '%s\\n' \"$i\"\ndone\n```\n\n## Loop over an array\n\n```shell\narr=(apples oranges tomatoes)\n\n# Just elements.\nfor element in \"${arr[@]}\"; do\n    printf '%s\\n' \"$element\"\ndone\n```\n\n## Loop over an array with an index\n\n```shell\narr=(apples oranges tomatoes)\n\n# Elements and index.\nfor i in \"${!arr[@]}\"; do\n    printf '%s\\n' \"${arr[i]}\"\ndone\n\n# Alternative method.\nfor ((i=0;i<${#arr[@]};i++)); do\n    printf '%s\\n' \"${arr[i]}\"\ndone\n```\n\n## Loop over the contents of a file\n\n```shell\nwhile read -r line; do\n    printf '%s\\n' \"$line\"\ndone < \"file\"\n```\n\n## Loop over files and directories\n\nDonâ€™t use `ls`.\n\n```shell\n# Greedy example.\nfor file in *; do\n    printf '%s\\n' \"$file\"\ndone\n\n# PNG files in dir.\nfor file in ~/Pictures/*.png; do\n    printf '%s\\n' \"$file\"\ndone\n\n# Iterate over directories.\nfor dir in ~/Downloads/*/; do\n    printf '%s\\n' \"$dir\"\ndone\n\n# Brace Expansion.\nfor file in /path/to/parentdir/{file1,file2,subdir/file3}; do\n    printf '%s\\n' \"$file\"\ndone\n\n# Iterate recursively.\nshopt -s globstar\nfor file in ~/Pictures/**/*; do\n    printf '%s\\n' \"$file\"\ndone\nshopt -u globstar\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# FILE HANDLING\n\n**CAVEAT:** `bash` does not handle binary data properly in versions `< 4.4`.\n\n## Read a file to a string\n\nAlternative to the `cat` command.\n\n```shell\nfile_data=\"$(<\"file\")\"\n```\n\n## Read a file to an array (*by line*)\n\nAlternative to the `cat` command.\n\n```shell\n# Bash <4 (discarding empty lines).\nIFS=$'\\n' read -d \"\" -ra file_data < \"file\"\n\n# Bash <4 (preserving empty lines).\nwhile read -r line; do\n    file_data+=(\"$line\")\ndone < \"file\"\n\n# Bash 4+\nmapfile -t file_data < \"file\"\n```\n\n## Get the first N lines of a file\n\nAlternative to the `head` command.\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\nhead() {\n    # Usage: head \"n\" \"file\"\n    mapfile -tn \"$1\" line < \"$2\"\n    printf '%s\\n' \"${line[@]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ head 2 ~/.bashrc\n# Prompt\nPS1='âžœ '\n\n$ head 1 ~/.bashrc\n# Prompt\n```\n\n## Get the last N lines of a file\n\nAlternative to the `tail` command.\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\ntail() {\n    # Usage: tail \"n\" \"file\"\n    mapfile -tn 0 line < \"$2\"\n    printf '%s\\n' \"${line[@]: -$1}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ tail 2 ~/.bashrc\n# Enable tmux.\n# [[ -z \"$TMUX\"  ]] && exec tmux\n\n$ tail 1 ~/.bashrc\n# [[ -z \"$TMUX\"  ]] && exec tmux\n```\n\n## Get the number of lines in a file\n\nAlternative to `wc -l`.\n\n**Example Function (bash 4):**\n\n```sh\nlines() {\n    # Usage: lines \"file\"\n    mapfile -tn 0 lines < \"$1\"\n    printf '%s\\n' \"${#lines[@]}\"\n}\n```\n\n**Example Function (bash 3):**\n\nThis method uses less memory than the `mapfile` method and works in `bash` 3 but it is slower for bigger files.\n\n```sh\nlines_loop() {\n    # Usage: lines_loop \"file\"\n    count=0\n    while IFS= read -r _; do\n        ((count++))\n    done < \"$1\"\n    printf '%s\\n' \"$count\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ lines ~/.bashrc\n48\n\n$ lines_loop ~/.bashrc\n48\n```\n\n## Count files or directories in directory\n\nThis works by passing the output of the glob to the function and then counting the number of arguments.\n\n**Example Function:**\n\n```sh\ncount() {\n    # Usage: count /path/to/dir/*\n    #        count /path/to/dir/*/\n    printf '%s\\n' \"$#\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Count all files in dir.\n$ count ~/Downloads/*\n232\n\n# Count all dirs in dir.\n$ count ~/Downloads/*/\n45\n\n# Count all jpg files in dir.\n$ count ~/Pictures/*.jpg\n64\n```\n\n## Create an empty file\n\nAlternative to `touch`.\n\n```shell\n# Shortest.\n>file\n\n# Longer alternatives:\n:>file\necho -n >file\nprintf '' >file\n```\n\n## Extract lines between two markers\n\n**Example Function:**\n\n```sh\nextract() {\n    # Usage: extract file \"opening marker\" \"closing marker\"\n    while IFS=$'\\n' read -r line; do\n        [[ $extract && $line != \"$3\" ]] &&\n            printf '%s\\n' \"$line\"\n\n        [[ $line == \"$2\" ]] && extract=1\n        [[ $line == \"$3\" ]] && extract=\n    done < \"$1\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Extract code blocks from MarkDown file.\n$ extract ~/projects/pure-bash/README.md '```sh' '```'\n# Output here...\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# FILE PATHS\n\n## Get the directory name of a file path\n\nAlternative to the `dirname` command.\n\n**Example Function:**\n\n```sh\ndirname() {\n    # Usage: dirname \"path\"\n    local tmp=${1:-.}\n\n    [[ $tmp != *[!/]* ]] && {\n        printf '/\\n'\n        return\n    }\n\n    tmp=${tmp%%\"${tmp##*[!/]}\"}\n\n    [[ $tmp != */* ]] && {\n        printf '.\\n'\n        return\n    }\n\n    tmp=${tmp%/*}\n    tmp=${tmp%%\"${tmp##*[!/]}\"}\n\n    printf '%s\\n' \"${tmp:-/}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ dirname ~/Pictures/Wallpapers/1.jpg\n/home/black/Pictures/Wallpapers\n\n$ dirname ~/Pictures/Downloads/\n/home/black/Pictures\n```\n\n## Get the base-name of a file path\n\nAlternative to the `basename` command.\n\n**Example Function:**\n\n```sh\nbasename() {\n    # Usage: basename \"path\" [\"suffix\"]\n    local tmp\n\n    tmp=${1%\"${1##*[!/]}\"}\n    tmp=${tmp##*/}\n    tmp=${tmp%\"${2/\"$tmp\"}\"}\n\n    printf '%s\\n' \"${tmp:-/}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ basename ~/Pictures/Wallpapers/1.jpg\n1.jpg\n\n$ basename ~/Pictures/Wallpapers/1.jpg .jpg\n1\n\n$ basename ~/Pictures/Downloads/\nDownloads\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# VARIABLES\n\n## Assign and access a variable using a variable\n\n```shell\n$ hello_world=\"value\"\n\n# Create the variable name.\n$ var=\"world\"\n$ ref=\"hello_$var\"\n\n# Print the value of the variable name stored in 'hello_$var'.\n$ printf '%s\\n' \"${!ref}\"\nvalue\n```\n\nAlternatively, on `bash` 4.3+:\n\n```shell\n$ hello_world=\"value\"\n$ var=\"world\"\n\n# Declare a nameref.\n$ declare -n ref=hello_$var\n\n$ printf '%s\\n' \"$ref\"\nvalue\n```\n\n## Name a variable based on another variable\n\n```shell\n$ var=\"world\"\n$ declare \"hello_$var=value\"\n$ printf '%s\\n' \"$hello_world\"\nvalue\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# ESCAPE SEQUENCES\n\nContrary to popular belief, there is no issue in utilizing raw escape sequences. Using `tput` abstracts the same ANSI sequences as if printed manually. Worse still, `tput` is not actually portable. There are a number of `tput` variants each with different commands and syntaxes (*try `tput setaf 3` on a FreeBSD system*). Raw sequences are fine.\n\n## Text Colors\n\n**NOTE:** Sequences requiring RGB values only work in True-Color Terminal Emulators.\n\n| Sequence | What does it do? | Value |\n| -------- | ---------------- | ----- |\n| `\\e[38;5;<NUM>m` | Set text foreground color. | `0-255`\n| `\\e[48;5;<NUM>m` | Set text background color. | `0-255`\n| `\\e[38;2;<R>;<G>;<B>m` | Set text foreground color to RGB color. | `R`, `G`, `B`\n| `\\e[48;2;<R>;<G>;<B>m` | Set text background color to RGB color. | `R`, `G`, `B`\n\n## Text Attributes\n\n**NOTE:** Prepend 2 to any code below to turn it's effect off\n(examples: 21=bold text off, 22=faint text off, 23=italic text off).\n\n| Sequence | What does it do? |\n| -------- | ---------------- |\n| `\\e[m` | Reset text formatting and colors. |\n| `\\e[1m` | Bold text. |\n| `\\e[2m` | Faint text. |\n| `\\e[3m` | Italic text. |\n| `\\e[4m` | Underline text. |\n| `\\e[5m` | Blinking text. |\n| `\\e[7m` | Highlighted text. |\n| `\\e[8m` | Hidden text. |\n| `\\e[9m` | Strike-through text. |\n\n\n## Cursor Movement\n\n| Sequence | What does it do? | Value |\n| -------- | ---------------- | ----- |\n| `\\e[<LINE>;<COLUMN>H` | Move cursor to absolute position. | `line`, `column`\n| `\\e[H` | Move cursor to home position (`0,0`). |\n| `\\e[<NUM>A` | Move cursor up N lines. | `num`\n| `\\e[<NUM>B` | Move cursor down N lines. | `num`\n| `\\e[<NUM>C` | Move cursor right N columns. | `num`\n| `\\e[<NUM>D` | Move cursor left N columns. | `num`\n| `\\e[s` | Save cursor position. |\n| `\\e[u` | Restore cursor position. |\n\n\n## Erasing Text\n\n| Sequence | What does it do? |\n| -------- | ---------------- |\n| `\\e[K` | Erase from cursor position to end of line.\n| `\\e[1K` | Erase from cursor position to start of line.\n| `\\e[2K` | Erase the entire current line.\n| `\\e[J` | Erase from the current line to the bottom of the screen.\n| `\\e[1J` | Erase from the current line to the top of the screen.\n| `\\e[2J` | Clear the screen.\n| `\\e[2J\\e[H` | Clear the screen and move cursor to `0,0`.\n\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# PARAMETER EXPANSION\n\n## Indirection\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${!VAR}` | Access a variable based on the value of `VAR`.\n| `${!VAR*}` | Expand to `IFS` separated list of variable names starting with `VAR`. |\n| `${!VAR@}` | Expand to `IFS` separated list of variable names starting with `VAR`. If double-quoted, each variable name expands to a separate word. |\n\n\n## Replacement\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${VAR#PATTERN}` | Remove shortest match of pattern from start of string. |\n| `${VAR##PATTERN}` | Remove longest match of pattern from start of string. |\n| `${VAR%PATTERN}` | Remove shortest match of pattern from end of string. |\n| `${VAR%%PATTERN}` | Remove longest match of pattern from end of string. |\n| `${VAR/PATTERN/REPLACE}` | Replace first match with string.\n| `${VAR//PATTERN/REPLACE}` | Replace all matches with string.\n| `${VAR/PATTERN}` | Remove first match.\n| `${VAR//PATTERN}` | Remove all matches.\n\n## Length\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${#VAR}` | Length of var in characters.\n| `${#ARR[@]}` | Length of array in elements.\n\n## Expansion\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${VAR:OFFSET}` | Remove first `N` chars from variable.\n| `${VAR:OFFSET:LENGTH}` | Get substring from `N` character to `N` character. <br> (`${VAR:10:10}`: Get sub-string from char `10` to char `20`)\n| `${VAR:: OFFSET}` | Get first `N` chars from variable.\n| `${VAR:: -OFFSET}` | Remove last `N` chars from variable.\n| `${VAR: -OFFSET}` | Get last `N` chars from variable.\n| `${VAR:OFFSET:-OFFSET}` | Cut first `N` chars and last `N` chars. | `bash 4.2+` |\n\n## Case Modification\n\n| Parameter | What does it do? | CAVEAT |\n| --------- | ---------------- | ------ |\n| `${VAR^}` | Uppercase first character. | `bash 4+` |\n| `${VAR^^}` | Uppercase all characters. | `bash 4+` |\n| `${VAR,}` | Lowercase first character. | `bash 4+` |\n| `${VAR,,}` | Lowercase all characters. | `bash 4+` |\n| `${VAR~}` | Reverse case of first character. | `bash 4+` |\n| `${VAR~~}` | Reverse case of all characters. | `bash 4+` |\n\n\n## Default Value\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${VAR:-STRING}` | If `VAR` is empty or unset, use `STRING` as its value.\n| `${VAR-STRING}` | If `VAR` is unset, use `STRING` as its value.\n| `${VAR:=STRING}` | If `VAR` is empty or unset, set the value of `VAR` to `STRING`.\n| `${VAR=STRING}` | If `VAR` is unset, set the value of `VAR` to `STRING`.\n| `${VAR:+STRING}` | If `VAR` is not empty, use `STRING` as its value.\n| `${VAR+STRING}` | If `VAR` is set, use `STRING` as its value.\n| `${VAR:?STRING}` | Display an error if empty or unset.\n| `${VAR?STRING}` | Display an error if unset.\n\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# BRACE EXPANSION\n\n## Ranges\n\n```shell\n# Syntax: {<START>..<END>}\n\n# Print numbers 1-100.\necho {1..100}\n\n# Print range of floats.\necho 1.{1..9}\n\n# Print chars a-z.\necho {a..z}\necho {A..Z}\n\n# Nesting.\necho {A..Z}{0..9}\n\n# Print zero-padded numbers.\n# CAVEAT: bash 4+\necho {01..100}\n\n# Change increment amount.\n# Syntax: {<START>..<END>..<INCREMENT>}\n# CAVEAT: bash 4+\necho {1..10..2} # Increment by 2.\n```\n\n## String Lists\n\n```shell\necho {apples,oranges,pears,grapes}\n\n# Example Usage:\n# Remove dirs Movies, Music and ISOS from ~/Downloads/.\nrm -rf ~/Downloads/{Movies,Music,ISOS}\n```\n\n<!-- CHAPTER END -->\n\n\n<!-- CHAPTER START -->\n\n# CONDITIONAL EXPRESSIONS\n\n## File Conditionals\n\n| Expression | Value  | What does it do? |\n| ---------- | ------ | ---------------- |\n| `-a`       | `file` | If file exists.\n| `-b`       | `file` | If file exists and is a block special file.\n| `-c`       | `file` | If file exists and is a character special file.\n| `-d`       | `file` | If file exists and is a directory.\n| `-e`       | `file` | If file exists.\n| `-f`       | `file` | If file exists and is a regular file.\n| `-g`       | `file` | If file exists and its set-group-id bit is set.\n| `-h`       | `file` | If file exists and is a symbolic link.\n| `-k`       | `file` | If file exists and its sticky-bit is set\n| `-p`       | `file` | If file exists and is a named pipe (*FIFO*).\n| `-r`       | `file` | If file exists and is readable.\n| `-s`       | `file` | If file exists and its size is greater than zero.\n| `-t`       | `fd`   | If file descriptor is open and refers to a terminal.\n| `-u`       | `file` | If file exists and its set-user-id bit is set.\n| `-w`       | `file` | If file exists and is writable.\n| `-x`       | `file` | If file exists and is executable.\n| `-G`       | `file` | If file exists and is owned by the effective group ID.\n| `-L`       | `file` | If file exists and is a symbolic link.\n| `-N`       | `file` | If file exists and has been modified since last read.\n| `-O`       | `file` | If file exists and is owned by the effective user ID.\n| `-S`       | `file` | If file exists and is a socket.\n\n## File Comparisons\n\n| Expression | What does it do? |\n| ---------- | ---------------- |\n| `file -ef file2` | If both files refer to the same inode and device numbers.\n| `file -nt file2` | If `file` is newer than `file2` (*uses modification time*) or `file` exists and `file2` does not.\n| `file -ot file2` | If `file` is older than `file2` (*uses modification time*) or `file2` exists and `file` does not.\n\n## Variable Conditionals\n\n| Expression | Value | What does it do? |\n| ---------- | ----- | ---------------- |\n| `-o`       | `opt` | If shell option is enabled.\n| `-v`       | `var` | If variable has a value assigned.\n| `-R`       | `var` | If variable is a name reference.\n| `-z`       | `var` | If the length of string is zero.\n| `-n`       | `var` | If the length of string is non-zero.\n\n## Variable Comparisons\n\n| Expression | What does it do? |\n| ---------- | ---------------- |\n| `var = var2` | Equal to.\n| `var == var2` | Equal to (*synonym for `=`*).\n| `var != var2` | Not equal to.\n| `var < var2` | Less than (*in ASCII alphabetical order.*)\n| `var > var2` | Greater than (*in ASCII alphabetical order.*)\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n\n# ARITHMETIC OPERATORS\n\n## Assignment\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `=`       | Initialize or change the value of a variable.\n\n## Arithmetic\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `+` | Addition\n| `-` | Subtraction\n| `*` | Multiplication\n| `/` | Division\n| `**` | Exponentiation\n| `%` | Modulo\n| `+=` | Plus-Equal (*Increment a variable.*)\n| `-=` | Minus-Equal (*Decrement a variable.*)\n| `*=` | Times-Equal (*Multiply a variable.*)\n| `/=` | Slash-Equal (*Divide a variable.*)\n| `%=` | Mod-Equal (*Remainder of dividing a variable.*)\n\n## Bitwise\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `<<` | Bitwise Left Shift\n| `<<=` | Left-Shift-Equal\n| `>>` | Bitwise Right Shift\n| `>>=` | Right-Shift-Equal\n| `&` | Bitwise AND\n| `&=` | Bitwise AND-Equal\n| `\\|` | Bitwise OR\n| `\\|=` | Bitwise OR-Equal\n| `~` | Bitwise NOT\n| `^` | Bitwise XOR\n| `^=` | Bitwise XOR-Equal\n\n## Logical\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `!` | NOT\n| `&&` | AND\n| `\\|\\|` | OR\n\n## Miscellaneous\n\n| Operators | What does it do? | Example |\n| --------- | ---------------- | ------- |\n| `,` | Comma Separator | `((a=1,b=2,c=3))`\n\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# ARITHMETIC\n\n## Simpler syntax to set variables\n\n```shell\n# Simple math\n((var=1+2))\n\n# Decrement/Increment variable\n((var++))\n((var--))\n((var+=1))\n((var-=1))\n\n# Using variables\n((var=var2*arr[2]))\n```\n\n## Ternary Tests\n\n```shell\n# Set the value of var to var2 if var2 is greater than var.\n# var: variable to set.\n# var2>var: Condition to test.\n# ?var2: If the test succeeds.\n# :var: If the test fails.\n((var=var2>var?var2:var))\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# TRAPS\n\nTraps allow a script to execute code on various signals. In [pxltrm](https://github.com/dylanaraps/pxltrm) (*a pixel art editor written in bash*)  traps are used to redraw the user interface on window resize. Another use case is cleaning up temporary files on script exit.\n\nTraps should be added near the start of scripts so any early errors are also caught.\n\n**NOTE:** For a full list of signals, see `trap -l`.\n\n\n## Do something on script exit\n\n```shell\n# Clear screen on script exit.\ntrap 'printf \\\\e[2J\\\\e[H\\\\e[m' EXIT\n```\n\n## Ignore terminal interrupt (CTRL+C, SIGINT)\n\n```shell\ntrap '' INT\n```\n\n## React to window resize\n\n```shell\n# Call a function on window resize.\ntrap 'code_here' SIGWINCH\n```\n\n## Do something before every command\n\n```shell\ntrap 'code_here' DEBUG\n```\n\n## Do something when a shell function or a sourced file finishes executing\n\n```shell\ntrap 'code_here' RETURN\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# PERFORMANCE\n\n## Disable Unicode\n\nIf unicode is not required, it can be disabled for a performance increase. Results may vary however there have been noticeable improvements in [neofetch](https://github.com/dylanaraps/neofetch) and other programs.\n\n```shell\n# Disable unicode.\nLC_ALL=C\nLANG=C\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# OBSOLETE SYNTAX\n\n## Shebang\n\nUse `#!/usr/bin/env bash` instead of `#!/bin/bash`.\n\n- The former searches the user's `PATH` to find the `bash` binary.\n- The latter assumes it is always installed to `/bin/` which can cause issues.\n\n**NOTE**: There are times when one may have a good reason for using `#!/bin/bash` or another direct path to the binary.\n\n\n```shell\n# Right:\n\n    #!/usr/bin/env bash\n\n# Less right:\n\n    #!/bin/bash\n```\n\n## Command Substitution\n\nUse `$()` instead of `` ` ` ``.\n\n```shell\n# Right.\nvar=\"$(command)\"\n\n# Wrong.\nvar=`command`\n\n# $() can easily be nested whereas `` cannot.\nvar=\"$(command \"$(command)\")\"\n```\n\n## Function Declaration\n\nDo not use the `function` keyword, it reduces compatibility with older versions of `bash`.\n\n```shell\n# Right.\ndo_something() {\n    # ...\n}\n\n# Wrong.\nfunction do_something() {\n    # ...\n}\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# INTERNAL VARIABLES\n\n## Get the location to the `bash` binary\n\n```shell\n\"$BASH\"\n```\n\n## Get the version of the current running `bash` process\n\n```shell\n# As a string.\n\"$BASH_VERSION\"\n\n# As an array.\n\"${BASH_VERSINFO[@]}\"\n```\n\n## Open the user's preferred text editor\n\n```shell\n\"$EDITOR\" \"$file\"\n\n# NOTE: This variable may be empty, set a fallback value.\n\"${EDITOR:-vi}\" \"$file\"\n```\n\n## Get the name of the current function\n\n```shell\n# Current function.\n\"${FUNCNAME[0]}\"\n\n# Parent function.\n\"${FUNCNAME[1]}\"\n\n# So on and so forth.\n\"${FUNCNAME[2]}\"\n\"${FUNCNAME[3]}\"\n\n# All functions including parents.\n\"${FUNCNAME[@]}\"\n```\n\n## Get the host-name of the system\n\n```shell\n\"$HOSTNAME\"\n\n# NOTE: This variable may be empty.\n# Optionally set a fallback to the hostname command.\n\"${HOSTNAME:-$(hostname)}\"\n```\n\n## Get the architecture of the Operating System\n\n```shell\n\"$HOSTTYPE\"\n```\n\n## Get the name of the Operating System / Kernel\n\nThis can be used to add conditional support for different Operating\nSystems without needing to call `uname`.\n\n```shell\n\"$OSTYPE\"\n```\n\n## Get the current working directory\n\nThis is an alternative to the `pwd` built-in.\n\n```shell\n\"$PWD\"\n```\n\n## Get the number of seconds the script has been running\n\n```shell\n\"$SECONDS\"\n```\n\n## Get a pseudorandom integer\n\nEach time `$RANDOM` is used, a different integer between `0` and `32767` is returned. This variable should not be used for anything related to security (*this includes encryption keys etc*).\n\n\n```shell\n\"$RANDOM\"\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# INFORMATION ABOUT THE TERMINAL\n\n## Get the terminal size in lines and columns (*from a script*)\n\nThis is handy when writing scripts in pure bash and `stty`/`tput` canâ€™t be\ncalled.\n\n**Example Function:**\n\n```sh\nget_term_size() {\n    # Usage: get_term_size\n\n    # (:;:) is a micro sleep to ensure the variables are\n    # exported immediately.\n    shopt -s checkwinsize; (:;:)\n    printf '%s\\n' \"$LINES $COLUMNS\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Output: LINES COLUMNS\n$ get_term_size\n15 55\n```\n\n## Get the terminal size in pixels\n\n**CAVEAT**: This does not work in some terminal emulators.\n\n**Example Function:**\n\n```sh\nget_window_size() {\n    # Usage: get_window_size\n    printf '%b' \"${TMUX:+\\\\ePtmux;\\\\e}\\\\e[14t${TMUX:+\\\\e\\\\\\\\}\"\n    IFS=';t' read -d t -t 0.05 -sra term_size\n    printf '%s\\n' \"${term_size[1]}x${term_size[2]}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Output: WIDTHxHEIGHT\n$ get_window_size\n1200x800\n\n# Output (fail):\n$ get_window_size\nx\n```\n\n## Get the current cursor position\n\nThis is useful when creating a TUI in pure bash.\n\n**Example Function:**\n\n```sh\nget_cursor_pos() {\n    # Usage: get_cursor_pos\n    IFS='[;' read -p $'\\e[6n' -d R -rs _ y x _\n    printf '%s\\n' \"$x $y\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Output: X Y\n$ get_cursor_pos\n1 8\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# CONVERSION\n\n## Convert a hex color to RGB\n\n**Example Function:**\n\n```sh\nhex_to_rgb() {\n    # Usage: hex_to_rgb \"#FFFFFF\"\n    #        hex_to_rgb \"000000\"\n    : \"${1/\\#}\"\n    ((r=16#${_:0:2},g=16#${_:2:2},b=16#${_:4:2}))\n    printf '%s\\n' \"$r $g $b\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ hex_to_rgb \"#FFFFFF\"\n255 255 255\n```\n\n\n## Convert an RGB color to hex\n\n**Example Function:**\n\n```sh\nrgb_to_hex() {\n    # Usage: rgb_to_hex \"r\" \"g\" \"b\"\n    printf '#%02x%02x%02x\\n' \"$1\" \"$2\" \"$3\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ rgb_to_hex \"255\" \"255\" \"255\"\n#FFFFFF\n```\n\n\n# CODE GOLF\n\n## Shorter `for` loop syntax\n\n```shell\n# Tiny C Style.\nfor((;i++<10;)){ echo \"$i\";}\n\n# Undocumented method.\nfor i in {1..10};{ echo \"$i\";}\n\n# Expansion.\nfor i in {1..10}; do echo \"$i\"; done\n\n# C Style.\nfor((i=0;i<=10;i++)); do echo \"$i\"; done\n```\n\n## Shorter infinite loops\n\n```shell\n# Normal method\nwhile :; do echo hi; done\n\n# Shorter\nfor((;;)){ echo hi;}\n```\n\n## Shorter function declaration\n\n```shell\n# Normal method\nf(){ echo hi;}\n\n# Using a subshell\nf()(echo hi)\n\n# Using arithmetic\n# This can be used to assign integer values.\n# Example: f a=1\n#          f a++\nf()(($1))\n\n# Using tests, loops etc.\n# NOTE: â€˜whileâ€™, â€˜untilâ€™, â€˜caseâ€™, â€˜(())â€™, â€˜[[]]â€™ can also be used.\nf()if true; then echo \"$1\"; fi\nf()for i in \"$@\"; do echo \"$i\"; done\n```\n\n## Shorter `if` syntax\n\n```shell\n# One line\n# Note: The 3rd statement may run when the 1st is true\n[[ $var == hello ]] && echo hi || echo bye\n[[ $var == hello ]] && { echo hi; echo there; } || echo bye\n\n# Multi line (no else, single statement)\n# Note: The exit status may not be the same as with an if statement\n[[ $var == hello ]] &&\n    echo hi\n\n# Multi line (no else)\n[[ $var == hello ]] && {\n    echo hi\n    # ...\n}\n```\n\n## Simpler `case` statement to set variable\n\nThe `:` built-in can be used to avoid repeating `variable=` in a case statement. The `$_` variable stores the last argument of the last command. `:` always succeeds so it can be used to store the variable value.\n\n```shell\n# Modified snippet from Neofetch.\ncase \"$OSTYPE\" in\n    \"darwin\"*)\n        : \"MacOS\"\n    ;;\n\n    \"linux\"*)\n        : \"Linux\"\n    ;;\n\n    *\"bsd\"* | \"dragonfly\" | \"bitrig\")\n        : \"BSD\"\n    ;;\n\n    \"cygwin\" | \"msys\" | \"win32\")\n        : \"Windows\"\n    ;;\n\n    *)\n        printf '%s\\n' \"Unknown OS detected, aborting...\" >&2\n        exit 1\n    ;;\nesac\n\n# Finally, set the variable.\nos=\"$_\"\n```\n\n<!-- CHAPTER END -->\n\n<!-- CHAPTER START -->\n# OTHER\n\n## Use `read` as an alternative to the `sleep` command\n\nSurprisingly, `sleep` is an external command and not a `bash` built-in.\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\nread_sleep() {\n    # Usage: read_sleep 1\n    #        read_sleep 0.2\n    read -rt \"$1\" <> <(:) || :\n}\n```\n\n**Example Usage:**\n\n```shell\nread_sleep 1\nread_sleep 0.1\nread_sleep 30\n```\n\nFor performance-critical situations, where it is not economic to open and close an excessive number of file descriptors, the allocation of a file descriptor may be done only once for all invocations of `read`:\n\n(See the generic original implementation at https://blog.dhampir.no/content/sleeping-without-a-subprocess-in-bash-and-how-to-sleep-forever)\n\n```shell\nexec {sleep_fd}<> <(:)\nwhile some_quick_test; do\n    # equivalent of sleep 0.001\n    read -t 0.001 -u $sleep_fd\ndone\n```\n\n## Check if a program is in the user's PATH\n\n```shell\n# There are 3 ways to do this and either one can be used.\ntype -p executable_name &>/dev/null\nhash executable_name &>/dev/null\ncommand -v executable_name &>/dev/null\n\n# As a test.\nif type -p executable_name &>/dev/null; then\n    # Program is in PATH.\nfi\n\n# Inverse.\nif ! type -p executable_name &>/dev/null; then\n    # Program is not in PATH.\nfi\n\n# Example (Exit early if program is not installed).\nif ! type -p convert &>/dev/null; then\n    printf '%s\\n' \"error: convert is not installed, exiting...\"\n    exit 1\nfi\n```\n\n## Get the current date using `strftime`\n\nBashâ€™s `printf` has a built-in method of getting the date which can be used in place of the `date` command.\n\n**CAVEAT:** Requires `bash` 4+\n\n**Example Function:**\n\n```sh\ndate() {\n    # Usage: date \"format\"\n    # See: 'man strftime' for format.\n    printf \"%($1)T\\\\n\" \"-1\"\n}\n```\n\n**Example Usage:**\n\n```shell\n# Using above function.\n$ date \"%a %d %b  - %l:%M %p\"\nFri 15 Jun  - 10:00 AM\n\n# Using printf directly.\n$ printf '%(%a %d %b  - %l:%M %p)T\\n' \"-1\"\nFri 15 Jun  - 10:00 AM\n\n# Assigning a variable using printf.\n$ printf -v date '%(%a %d %b  - %l:%M %p)T\\n' '-1'\n$ printf '%s\\n' \"$date\"\nFri 15 Jun  - 10:00 AM\n```\n\n## Get the username of the current user\n\n**CAVEAT:** Requires `bash` 4.4+\n\n```shell\n$ : \\\\u\n# Expand the parameter as if it were a prompt string.\n$ printf '%s\\n' \"${_@P}\"\nblack\n```\n\n## Generate a UUID V4\n\n**CAVEAT**: The generated value is not cryptographically secure.\n\n**Example Function:**\n\n```sh\nuuid() {\n    # Usage: uuid\n    C=\"89ab\"\n\n    for ((N=0;N<16;++N)); do\n        B=\"$((RANDOM%256))\"\n\n        case \"$N\" in\n            6)  printf '4%x' \"$((B%16))\" ;;\n            8)  printf '%c%x' \"${C:$RANDOM%${#C}:1}\" \"$((B%16))\" ;;\n\n            3|5|7|9)\n                printf '%02x-' \"$B\"\n            ;;\n\n            *)\n                printf '%02x' \"$B\"\n            ;;\n        esac\n    done\n\n    printf '\\n'\n}\n```\n\n**Example Usage:**\n\n```shell\n$ uuid\nd5b6c731-1310-4c24-9fe3-55d556d44374\n```\n\n## Progress bars\n\nThis is a simple way of drawing progress bars without needing a for loop\nin the function itself.\n\n**Example Function:**\n\n```sh\nbar() {\n    # Usage: bar 1 10\n    #            ^----- Elapsed Percentage (0-100).\n    #               ^-- Total length in chars.\n    ((elapsed=$1*$2/100))\n\n    # Create the bar with spaces.\n    printf -v prog  \"%${elapsed}s\"\n    printf -v total \"%$(($2-elapsed))s\"\n\n    printf '%s\\r' \"[${prog// /-}${total}]\"\n}\n```\n\n**Example Usage:**\n\n```shell\nfor ((i=0;i<=100;i++)); do\n    # Pure bash micro sleeps (for the example).\n    (:;:) && (:;:) && (:;:) && (:;:) && (:;:)\n\n    # Print the bar.\n    bar \"$i\" \"10\"\ndone\n\nprintf '\\n'\n```\n\n## Get the list of functions in a script\n\n```sh\nget_functions() {\n    # Usage: get_functions\n    IFS=$'\\n' read -d \"\" -ra functions < <(declare -F)\n    printf '%s\\n' \"${functions[@]//declare -f }\"\n}\n```\n\n## Bypass shell aliases\n\n```shell\n# alias\nls\n\n# command\n# shellcheck disable=SC1001\n\\ls\n```\n\n## Bypass shell functions\n\n```shell\n# function\nls\n\n# command\ncommand ls\n```\n\n## Run a command in the background\n\nThis will run the given command and keep it running, even after the terminal or SSH connection is terminated. All output is ignored.\n\n```sh\nbkr() {\n    (nohup \"$@\" &>/dev/null &)\n}\n\nbkr ./some_script.sh # some_script.sh is now running in the background\n```\n\n## Capture the return value of a function without command substitution\n\n**CAVEAT:** Requires `bash` 4+\n\nThis uses local namerefs to avoid using `var=$(some_func)` style command substitution for function output capture.\n\n```sh\nto_upper() {\n  local -n ptr=${1}\n\n  ptr=${ptr^^}\n}\n\nfoo=\"bar\"\nto_upper foo\nprintf \"%s\\n\" \"${foo}\" # BAR\n```\n\n<!-- CHAPTER END -->\n\n# AFTERWORD\n\nThanks for reading! If this bible helped you in any way and you'd like to give back, consider donating. Donations give me the time to make this the best resource possible. Can't donate? That's OK, star the repo and share it with your friends!\n\n<a href=\"https://www.patreon.com/dyla\"><img src=\"https://img.shields.io/badge/donate-patreon-yellow.svg\"></a>\n\n\nRock on. ðŸ¤˜\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.72,
          "content": "#!/usr/bin/env bash\n#\n# Turn the single document bible into a book separated by chapters.\n\nmain() {\n    rm -rf manuscript\n    mkdir -p manuscript\n\n    # Split the README.md into chapters based on markers.\n    while IFS=$'\\n' read -r line; do\n        [[ \"$chap\" ]] && chapter[$i]+=\"$line\"$'\\n'\n        [[ \"$line\" == \"<!-- CHAPTER START -->\" ]] && chap=1\n        [[ \"$line\" == \"<!-- CHAPTER END -->\" ]]   && { chap=; ((i++)); }\n    done < README.md\n\n    # Write the chapters to separate files.\n    for i in \"${!chapter[@]}\"; do\n        : \"${chapter[$i]/$'\\n'*}\"; : \"${_/\\# }\"; : \"${_,,}\"\n        printf '%s\\n' \"${chapter[$i]}\" > \"manuscript/chapter${i}.txt\"\n        printf '%s\\n' \"chapter${i}.txt\" >> \"manuscript/Book.txt\"\n    done\n}\n\nmain\n"
        },
        {
          "name": "manuscript",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 5.92,
          "content": "#!/usr/bin/env bash\n# shellcheck source=/dev/null disable=2178,2128\n#\n# Tests for the Pure Bash Bible.\n\ntest_trim_string() {\n    result=\"$(trim_string \"    Hello,    World    \")\"\n    assert_equals \"$result\" \"Hello,    World\"\n}\n\ntest_trim_all() {\n    result=\"$(trim_all \"    Hello,    World    \")\"\n    assert_equals \"$result\" \"Hello, World\"\n}\n\ntest_regex() {\n    result=\"$(regex \"#FFFFFF\" '^(#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3}))$')\"\n    assert_equals \"$result\" \"#FFFFFF\"\n}\n\ntest_lower() {\n    result=\"$(lower \"HeLlO\")\"\n    assert_equals \"$result\" \"hello\"\n}\n\ntest_upper() {\n    result=\"$(upper \"HeLlO\")\"\n    assert_equals \"$result\" \"HELLO\"\n}\n\ntest_reverse_case() {\n    result=\"$(reverse_case \"HeLlO\")\"\n    assert_equals \"$result\" \"hElLo\"\n}\n\ntest_trim_quotes() {\n    result=\"$(trim_quotes \"\\\"te'st' 'str'ing\\\"\")\"\n    assert_equals \"$result\" \"test string\"\n}\n\ntest_strip_all() {\n    result=\"$(strip_all \"The Quick Brown Fox\" \"[aeiou]\")\"\n    assert_equals \"$result\" \"Th Qck Brwn Fx\"\n}\n\ntest_strip() {\n    result=\"$(strip \"The Quick Brown Fox\" \"[aeiou]\")\"\n    assert_equals \"$result\" \"Th Quick Brown Fox\"\n}\n\ntest_lstrip() {\n    result=\"$(lstrip \"!:IHello\" \"!:I\")\"\n    assert_equals \"$result\" \"Hello\"\n}\n\ntest_rstrip() {\n    result=\"$(rstrip \"Hello!:I\" \"!:I\")\"\n    assert_equals \"$result\" \"Hello\"\n}\n\ntest_urlencode() {\n    result=\"$(urlencode \"https://github.com/dylanaraps/pure-bash-bible\")\"\n    assert_equals \"$result\" \"https%3A%2F%2Fgithub.com%2Fdylanaraps%2Fpure-bash-bible\"\n}\n\ntest_urldecode() {\n    result=\"$(urldecode \"https%3A%2F%2Fgithub.com%2Fdylanaraps%2Fpure-bash-bible\")\"\n    assert_equals \"$result\" \"https://github.com/dylanaraps/pure-bash-bible\"\n}\n\ntest_reverse_array() {\n    shopt -s compat44\n    IFS=$'\\n' read -d \"\" -ra result < <(reverse_array 1 2 3 4 5)\n    assert_equals \"${result[*]}\" \"5 4 3 2 1\"\n    shopt -u compat44\n}\n\ntest_cycle() {\n    # shellcheck disable=2034\n    arr=(a b c d)\n    result=\"$(cycle; cycle; cycle)\"\n    assert_equals \"$result\" \"a b c \"\n}\n\ntest_head() {\n    printf '%s\\n%s\\n\\n\\n' \"hello\" \"world\" > test_file\n    result=\"$(head 2 test_file)\"\n    assert_equals \"$result\" $'hello\\nworld'\n}\n\ntest_tail() {\n    printf '\\n\\n\\n%s\\n%s\\n' \"hello\" \"world\" > test_file\n    result=\"$(tail 2 test_file)\"\n    assert_equals \"$result\" $'hello\\nworld'\n}\n\ntest_lines() {\n    printf '\\n\\n\\n\\n\\n\\n\\n\\n' > test_file\n    result=\"$(lines test_file)\"\n    assert_equals \"$result\" \"8\"\n}\n\ntest_lines_loop() {\n    printf '\\n\\n\\n\\n\\n\\n\\n\\n' > test_file\n    result=\"$(lines_loop test_file)\"\n    assert_equals \"$result\" \"8\"\n}\n\ntest_count() {\n    result=\"$(count ./{README.m,LICENSE.m,.travis.ym}*)\"\n    assert_equals \"$result\" \"3\"\n}\n\ntest_dirname() {\n    result=\"$(dirname \"/home/black/Pictures/Wallpapers/1.jpg\")\"\n    assert_equals \"$result\" \"/home/black/Pictures/Wallpapers\"\n\n    result=\"$(dirname \"/\")\"\n    assert_equals \"$result\" \"/\"\n\n    result=\"$(dirname \"/foo\")\"\n    assert_equals \"$result\" \"/\"\n\n    result=\"$(dirname \".\")\"\n    assert_equals \"$result\" \".\"\n\n    result=\"$(dirname \"/foo/foo\")\"\n    assert_equals \"$result\" \"/foo\"\n\n    result=\"$(dirname \"something/\")\"\n    assert_equals \"$result\" \".\"\n\n    result=\"$(dirname \"//\")\"\n    assert_equals \"$result\" \"/\"\n\n    result=\"$(dirname \"//foo\")\"\n    assert_equals \"$result\" \"/\"\n\n    result=\"$(dirname \"\")\"\n    assert_equals \"$result\" \".\"\n\n    result=\"$(dirname \"something//\")\"\n    assert_equals \"$result\" \".\"\n\n    result=\"$(dirname \"something/////////////////////\")\"\n    assert_equals \"$result\" \".\"\n\n    result=\"$(dirname \"something/////////////////////a\")\"\n    assert_equals \"$result\" \"something\"\n\n    result=\"$(dirname \"something//////////.///////////\")\"\n    assert_equals \"$result\" \"something\"\n\n    result=\"$(dirname \"//////\")\"\n    assert_equals \"$result\" \"/\"\n}\n\ntest_basename() {\n    result=\"$(basename \"/home/black/Pictures/Wallpapers/1.jpg\")\"\n    assert_equals \"$result\" \"1.jpg\"\n}\n\ntest_hex_to_rgb() {\n    result=\"$(hex_to_rgb \"#FFFFFF\")\"\n    assert_equals \"$result\" \"255 255 255\"\n\n    result=\"$(hex_to_rgb \"000000\")\"\n    assert_equals \"$result\" \"0 0 0\"\n}\n\ntest_rgb_to_hex() {\n    result=\"$(rgb_to_hex 0 0 0)\"\n    assert_equals \"$result\" \"#000000\"\n}\n\ntest_date() {\n    result=\"$(date \"%C\")\"\n    assert_equals \"$result\" \"20\"\n}\n\ntest_read_sleep() {\n    result=\"$((SECONDS+1))\"\n    read_sleep 1\n    assert_equals \"$result\" \"$SECONDS\"\n}\n\ntest_bar() {\n    result=\"$(bar 50 10)\"\n    assert_equals \"${result//$'\\r'}\" \"[-----     ]\"\n}\n\ntest_get_functions() {\n    IFS=$'\\n' read -d \"\" -ra functions < <(get_functions)\n    assert_equals \"${functions[0]}\" \"assert_equals\"\n}\n\ntest_extract() {\n    printf '{\\nhello, world\\n}\\n' > test_file\n    result=\"$(extract test_file \"{\" \"}\")\"\n    assert_equals \"$result\" \"hello, world\"\n}\n\ntest_split() {\n    IFS=$'\\n' read -d \"\" -ra result < <(split \"hello,world,my,name,is,john\" \",\")\n    assert_equals \"${result[*]}\" \"hello world my name is john\"\n}\n\nassert_equals() {\n    if [[ \"$1\" == \"$2\" ]]; then\n        ((pass+=1))\n        status=$'\\e[32mâœ”'\n    else\n        ((fail+=1))\n        status=$'\\e[31mâœ–'\n        local err=\"(\\\"$1\\\" != \\\"$2\\\")\"\n    fi\n\n    printf ' %s\\e[m | %s\\n' \"$status\" \"${FUNCNAME[1]/test_} $err\"\n}\n\nmain() {\n    trap 'rm readme_code test_file' EXIT\n\n    # Extract code blocks from the README.\n    while IFS=$'\\n' read -r line; do\n        [[ \"$code\" && \"$line\" != \\`\\`\\` ]] && printf '%s\\n' \"$line\"\n        [[ \"$line\" =~ ^\\`\\`\\`sh$ ]] && code=1\n        [[ \"$line\" =~ ^\\`\\`\\`$ ]]   && code=\n    done < README.md > readme_code\n\n    # Run shellcheck and source the code.\n    shellcheck -s bash readme_code test.sh build.sh || exit 1\n    . readme_code\n\n    head=\"-> Running tests on the Pure Bash Bible..\"\n    printf '\\n%s\\n%s\\n' \"$head\" \"${head//?/-}\"\n\n    # Generate the list of tests to run.\n    IFS=$'\\n' read -d \"\" -ra funcs < <(declare -F)\n    for func in \"${funcs[@]//declare -f }\"; do\n        [[ \"$func\" == test_* ]] && \"$func\";\n    done\n\n    comp=\"Completed $((fail+pass)) tests. ${pass:-0} passed, ${fail:-0} failed.\"\n    printf '%s\\n%s\\n\\n' \"${comp//?/-}\" \"$comp\"\n\n    # If a test failed, exit with '1'.\n    ((fail>0)) || exit 0 && exit 1\n}\n\nmain \"$@\"\n"
        }
      ]
    }
  ]
}