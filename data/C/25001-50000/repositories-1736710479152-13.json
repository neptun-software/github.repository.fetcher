{
  "metadata": {
    "timestamp": 1736710479152,
    "page": 13,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjE5",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nothings/stb",
      "stars": 27530,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*.o\n*.obj\n*.exe\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0859375,
          "content": "language: C\narch:\n  - AMD64\n  - ppc64le\ninstall: true\nscript:\n  - cd tests\n  - make all\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.451171875,
          "content": "This software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.11328125,
          "content": "<!---   THIS FILE IS AUTOMATICALLY GENERATED, DO NOT CHANGE IT BY HAND   --->\n\nstb\n===\n\nsingle-file public domain (or MIT licensed) libraries for C/C++\n\n# This project discusses security-relevant bugs in public in Github Issues and Pull Requests, and it may take significant time for security fixes to be implemented or merged. If this poses an unreasonable risk to your project, do not use stb libraries.\n\nNoteworthy:\n\n* image loader: [stb_image.h](stb_image.h)\n* image writer: [stb_image_write.h](stb_image_write.h)\n* image resizer: [stb_image_resize2.h](stb_image_resize2.h)\n* font text rasterizer: [stb_truetype.h](stb_truetype.h)\n* typesafe containers: [stb_ds.h](stb_ds.h)\n\nMost libraries by stb, except: stb_dxt by Fabian \"ryg\" Giesen, original stb_image_resize\nby Jorge L. \"VinoBS\" Rodriguez, and stb_image_resize2 and stb_sprintf by Jeff Roberts.\n\n<a name=\"stb_libs\"></a>\n\nlibrary    | lastest version | category | LoC | description\n--------------------- | ---- | -------- | --- | --------------------------------\n**[stb_vorbis.c](stb_vorbis.c)** | 1.22 | audio | 5584 | decode ogg vorbis files from file/memory to float/16-bit signed output\n**[stb_hexwave.h](stb_hexwave.h)** | 0.5 | audio | 680 | audio waveform synthesizer\n**[stb_image.h](stb_image.h)** | 2.30 | graphics | 7988 | image loading/decoding from file/memory: JPG, PNG, TGA, BMP, PSD, GIF, HDR, PIC\n**[stb_truetype.h](stb_truetype.h)** | 1.26 | graphics | 5079 | parse, decode, and rasterize characters from truetype fonts\n**[stb_image_write.h](stb_image_write.h)** | 1.16 | graphics | 1724 | image writing to disk: PNG, TGA, BMP\n**[stb_image_resize2.h](stb_image_resize2.h)** | 2.12 | graphics | 10601 | resize images larger/smaller with good quality\n**[stb_rect_pack.h](stb_rect_pack.h)** | 1.01 | graphics | 623 | simple 2D rectangle packer with decent quality\n**[stb_perlin.h](stb_perlin.h)** | 0.5 | graphics | 428 | perlin's revised simplex noise w/ different seeds\n**[stb_ds.h](stb_ds.h)** | 0.67 | utility | 1895 | typesafe dynamic array and hash tables for C, will compile in C++\n**[stb_sprintf.h](stb_sprintf.h)** | 1.10 | utility | 1906 | fast sprintf, snprintf for C/C++\n**[stb_textedit.h](stb_textedit.h)** | 1.14 | user&nbsp;interface | 1429 | guts of a text editor for games etc implementing them from scratch\n**[stb_voxel_render.h](stb_voxel_render.h)** | 0.89 | 3D&nbsp;graphics | 3807 | Minecraft-esque voxel rendering \"engine\" with many more features\n**[stb_dxt.h](stb_dxt.h)** | 1.12 | 3D&nbsp;graphics | 719 | Fabian \"ryg\" Giesen's real-time DXT compressor\n**[stb_easy_font.h](stb_easy_font.h)** | 1.1 | 3D&nbsp;graphics | 305 | quick-and-dirty easy-to-deploy bitmap font for printing frame rate, etc\n**[stb_tilemap_editor.h](stb_tilemap_editor.h)** | 0.42 | game&nbsp;dev | 4187 | embeddable tilemap editor\n**[stb_herringbone_wa...](stb_herringbone_wang_tile.h)** | 0.7 | game&nbsp;dev | 1221 | herringbone Wang tile map generator\n**[stb_c_lexer.h](stb_c_lexer.h)** | 0.12 | parsing | 941 | simplify writing parsers for C-like languages\n**[stb_divide.h](stb_divide.h)** | 0.94 | math | 433 | more useful 32-bit modulus e.g. \"euclidean divide\"\n**[stb_connected_comp...](stb_connected_components.h)** | 0.96 | misc | 1049 | incrementally compute reachability on grids\n**[stb_leakcheck.h](stb_leakcheck.h)** | 0.6 | misc | 194 | quick-and-dirty malloc/free leak-checking\n**[stb_include.h](stb_include.h)** | 0.02 | misc | 295 | implement recursive #include support, particularly for GLSL\n\nTotal libraries: 21\nTotal lines of C code: 51088\n\n\nFAQ\n---\n\n#### What's the license?\n\nThese libraries are in the public domain. You can do anything you\nwant with them. You have no legal obligation\nto do anything else, although I appreciate attribution.\n\nThey are also licensed under the MIT open source license, if you have lawyers\nwho are unhappy with public domain. Every source file includes an explicit\ndual-license for you to choose from.\n\n#### How do I use these libraries?\n\nThe idea behind single-header file libraries is that they're easy to distribute and deploy\nbecause all the code is contained in a single file. By default, the .h files in here act as\ntheir own header files, i.e. they declare the functions contained in the file but don't\nactually result in any code getting compiled.\n\nSo in addition, you should select _exactly one_ C/C++ source file that actually instantiates\nthe code, preferably a file you're not editing frequently. This file should define a\nspecific macro (this is documented per-library) to actually enable the function definitions.\nFor example, to use stb_image, you should have exactly one C/C++ file that doesn't\ninclude stb_image.h regularly, but instead does\n\n    #define STB_IMAGE_IMPLEMENTATION\n    #include \"stb_image.h\"\n\nThe right macro to define is pointed out right at the top of each of these libraries.\n\n#### <a name=\"other_libs\"></a> Are there other single-file public-domain/open source libraries with minimal dependencies out there?\n\n[Yes.](https://github.com/nothings/single_file_libs)\n\n#### If I wrap an stb library in a new library, does the new library have to be public domain/MIT?\n\nNo, because it's public domain you can freely relicense it to whatever license your new\nlibrary wants to be.\n\n#### What's the deal with SSE support in GCC-based compilers?\n\nstb_image will either use SSE2 (if you compile with -msse2) or\nwill not use any SIMD at all, rather than trying to detect the\nprocessor at runtime and handle it correctly. As I understand it,\nthe approved path in GCC for runtime-detection require\nyou to use multiple source files, one for each CPU configuration.\nBecause stb_image is a header-file library that compiles in only\none source file, there's no approved way to build both an\nSSE-enabled and a non-SSE-enabled variation.\n\nWhile we've tried to work around it, we've had multiple issues over\nthe years due to specific versions of gcc breaking what we're doing,\nso we've given up on it. See https://github.com/nothings/stb/issues/280\nand https://github.com/nothings/stb/issues/410 for examples.\n\n#### Some of these libraries seem redundant to existing open source libraries. Are they better somehow?\n\nGenerally they're only better in that they're easier to integrate,\neasier to use, and easier to release (single file; good API; no\nattribution requirement). They may be less featureful, slower,\nand/or use more memory. If you're already using an equivalent\nlibrary, there's probably no good reason to switch.\n\n#### Can I link directly to the table of stb libraries?\n\nYou can use [this URL](https://github.com/nothings/stb#stb_libs) to link directly to that list.\n\n#### Why do you list \"lines of code\"? It's a terrible metric.\n\nJust to give you some idea of the internal complexity of the library,\nto help you manage your expectations, or to let you know what you're\ngetting into. While not all the libraries are written in the same\nstyle, they're certainly similar styles, and so comparisons between\nthe libraries are probably still meaningful.\n\nNote though that the lines do include both the implementation, the\npart that corresponds to a header file, and the documentation.\n\n#### Why single-file headers?\n\nWindows doesn't have standard directories where libraries\nlive. That makes deploying libraries in Windows a lot more\npainful than open source developers on Unix-derivates generally\nrealize. (It also makes library dependencies a lot worse in Windows.)\n\nThere's also a common problem in Windows where a library was built\nagainst a different version of the runtime library, which causes\nlink conflicts and confusion. Shipping the libs as headers means\nyou normally just compile them straight into your project without\nmaking libraries, thus sidestepping that problem.\n\nMaking them a single file makes it very easy to just\ndrop them into a project that needs them. (Of course you can\nstill put them in a proper shared library tree if you want.)\n\nWhy not two files, one a header and one an implementation?\nThe difference between 10 files and 9 files is not a big deal,\nbut the difference between 2 files and 1 file is a big deal.\nYou don't need to zip or tar the files up, you don't have to\nremember to attach *two* files, etc.\n\n#### Why \"stb\"? Is this something to do with Set-Top Boxes?\n\nNo, they are just the initials for my name, Sean T. Barrett.\nThis was not chosen out of egomania, but as a moderately sane\nway of namespacing the filenames and source function names.\n\n#### Will you add more image types to stb_image.h?\n\nNo. As stb_image use has grown, it has become more important\nfor us to focus on security of the codebase. Adding new image\nformats increases the amount of code we need to secure, so it\nis no longer worth adding new formats.\n\n#### Do you have any advice on how to create my own single-file library?\n\nYes. https://github.com/nothings/stb/blob/master/docs/stb_howto.txt\n\n#### Why public domain?\n\nI prefer it over GPL, LGPL, BSD, zlib, etc. for many reasons.\nSome of them are listed here:\nhttps://github.com/nothings/stb/blob/master/docs/why_public_domain.md\n\n#### Why C?\n\nPrimarily, because I use C, not C++. But it does also make it easier\nfor other people to use them from other languages.\n\n#### Why not C99? stdint.h, declare-anywhere, etc.\n\nI still use MSVC 6 (1998) as my IDE because it has better human factors\nfor me than later versions of MSVC.\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "deprecated",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "stb_c_lexer.h",
          "type": "blob",
          "size": 33.904296875,
          "content": "// stb_c_lexer.h - v0.12 - public domain Sean Barrett 2013\n// lexer for making little C-like languages with recursive-descent parsers\n//\n// This file provides both the interface and the implementation.\n// To instantiate the implementation,\n//      #define STB_C_LEXER_IMPLEMENTATION\n// in *ONE* source file, before #including this file.\n//\n// The default configuration is fairly close to a C lexer, although\n// suffixes on integer constants are not handled (you can override this).\n//\n// History:\n//     0.12 fix compilation bug for NUL support; better support separate inclusion\n//     0.11 fix clang static analysis warning\n//     0.10 fix warnings\n//     0.09 hex floats, no-stdlib fixes\n//     0.08 fix bad pointer comparison\n//     0.07 fix mishandling of hexadecimal constants parsed by strtol\n//     0.06 fix missing next character after ending quote mark (Andreas Fredriksson)\n//     0.05 refixed get_location because github version had lost the fix\n//     0.04 fix octal parsing bug\n//     0.03 added STB_C_LEX_DISCARD_PREPROCESSOR option\n//          refactor API to simplify (only one struct instead of two)\n//          change literal enum names to have 'lit' at the end\n//     0.02 first public release\n//\n// Status:\n//     - haven't tested compiling as C++\n//     - haven't tested the float parsing path\n//     - haven't tested the non-default-config paths (e.g. non-stdlib)\n//     - only tested default-config paths by eyeballing output of self-parse\n//\n//     - haven't implemented multiline strings\n//     - haven't implemented octal/hex character constants\n//     - haven't implemented support for unicode CLEX_char\n//     - need to expand error reporting so you don't just get \"CLEX_parse_error\"\n//\n// Contributors:\n//   Arpad Goretity (bugfix)\n//   Alan Hickman (hex floats)\n//   github:mundusnine (bugfix)\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n#ifdef STB_C_LEXER_IMPLEMENTATION\n#ifndef STB_C_LEXER_DEFINITIONS\n// to change the default parsing rules, copy the following lines\n// into your C/C++ file *before* including this, and then replace\n// the Y's with N's for the ones you don't want. This needs to be\n// set to the same values for every place in your program where\n// stb_c_lexer.h is included.\n// --BEGIN--\n\n#if defined(Y) || defined(N)\n#error \"Can only use stb_c_lexer in contexts where the preprocessor symbols 'Y' and 'N' are not defined\"\n#endif\n\n#define STB_C_LEX_C_DECIMAL_INTS    Y   //  \"0|[1-9][0-9]*\"                        CLEX_intlit\n#define STB_C_LEX_C_HEX_INTS        Y   //  \"0x[0-9a-fA-F]+\"                       CLEX_intlit\n#define STB_C_LEX_C_OCTAL_INTS      Y   //  \"[0-7]+\"                               CLEX_intlit\n#define STB_C_LEX_C_DECIMAL_FLOATS  Y   //  \"[0-9]*(.[0-9]*([eE][-+]?[0-9]+)?)     CLEX_floatlit\n#define STB_C_LEX_C99_HEX_FLOATS    N   //  \"0x{hex}+(.{hex}*)?[pP][-+]?{hex}+     CLEX_floatlit\n#define STB_C_LEX_C_IDENTIFIERS     Y   //  \"[_a-zA-Z][_a-zA-Z0-9]*\"               CLEX_id\n#define STB_C_LEX_C_DQ_STRINGS      Y   //  double-quote-delimited strings with escapes  CLEX_dqstring\n#define STB_C_LEX_C_SQ_STRINGS      N   //  single-quote-delimited strings with escapes  CLEX_ssstring\n#define STB_C_LEX_C_CHARS           Y   //  single-quote-delimited character with escape CLEX_charlits\n#define STB_C_LEX_C_COMMENTS        Y   //  \"/* comment */\"\n#define STB_C_LEX_CPP_COMMENTS      Y   //  \"// comment to end of line\\n\"\n#define STB_C_LEX_C_COMPARISONS     Y   //  \"==\" CLEX_eq  \"!=\" CLEX_noteq   \"<=\" CLEX_lesseq  \">=\" CLEX_greatereq\n#define STB_C_LEX_C_LOGICAL         Y   //  \"&&\"  CLEX_andand   \"||\"  CLEX_oror\n#define STB_C_LEX_C_SHIFTS          Y   //  \"<<\"  CLEX_shl      \">>\"  CLEX_shr\n#define STB_C_LEX_C_INCREMENTS      Y   //  \"++\"  CLEX_plusplus \"--\"  CLEX_minusminus\n#define STB_C_LEX_C_ARROW           Y   //  \"->\"  CLEX_arrow\n#define STB_C_LEX_EQUAL_ARROW       N   //  \"=>\"  CLEX_eqarrow\n#define STB_C_LEX_C_BITWISEEQ       Y   //  \"&=\"  CLEX_andeq    \"|=\"  CLEX_oreq     \"^=\"  CLEX_xoreq\n#define STB_C_LEX_C_ARITHEQ         Y   //  \"+=\"  CLEX_pluseq   \"-=\"  CLEX_minuseq\n                                        //  \"*=\"  CLEX_muleq    \"/=\"  CLEX_diveq    \"%=\" CLEX_modeq\n                                        //  if both STB_C_LEX_SHIFTS & STB_C_LEX_ARITHEQ:\n                                        //                      \"<<=\" CLEX_shleq    \">>=\" CLEX_shreq\n\n#define STB_C_LEX_PARSE_SUFFIXES    N   // letters after numbers are parsed as part of those numbers, and must be in suffix list below\n#define STB_C_LEX_DECIMAL_SUFFIXES  \"\"  // decimal integer suffixes e.g. \"uUlL\" -- these are returned as-is in string storage\n#define STB_C_LEX_HEX_SUFFIXES      \"\"  // e.g. \"uUlL\"\n#define STB_C_LEX_OCTAL_SUFFIXES    \"\"  // e.g. \"uUlL\"\n#define STB_C_LEX_FLOAT_SUFFIXES    \"\"  //\n\n#define STB_C_LEX_0_IS_EOF             N  // if Y, ends parsing at '\\0'; if N, returns '\\0' as token\n#define STB_C_LEX_INTEGERS_AS_DOUBLES  N  // parses integers as doubles so they can be larger than 'int', but only if STB_C_LEX_STDLIB==N\n#define STB_C_LEX_MULTILINE_DSTRINGS   N  // allow newlines in double-quoted strings\n#define STB_C_LEX_MULTILINE_SSTRINGS   N  // allow newlines in single-quoted strings\n#define STB_C_LEX_USE_STDLIB           Y  // use strtod,strtol for parsing #s; otherwise inaccurate hack\n#define STB_C_LEX_DOLLAR_IDENTIFIER    Y  // allow $ as an identifier character\n#define STB_C_LEX_FLOAT_NO_DECIMAL     Y  // allow floats that have no decimal point if they have an exponent\n\n#define STB_C_LEX_DEFINE_ALL_TOKEN_NAMES  N   // if Y, all CLEX_ token names are defined, even if never returned\n                                              // leaving it as N should help you catch config bugs\n\n#define STB_C_LEX_DISCARD_PREPROCESSOR    Y   // discard C-preprocessor directives (e.g. after prepocess\n                                              // still have #line, #pragma, etc)\n\n//#define STB_C_LEX_ISWHITE(str)    ... // return length in bytes of whitespace characters if first char is whitespace\n\n#define STB_C_LEXER_DEFINITIONS         // This line prevents the header file from replacing your definitions\n// --END--\n#endif\n#endif\n\n#ifndef INCLUDE_STB_C_LEXER_H\n#define INCLUDE_STB_C_LEXER_H\n\ntypedef struct\n{\n   // lexer variables\n   char *input_stream;\n   char *eof;\n   char *parse_point;\n   char *string_storage;\n   int   string_storage_len;\n\n   // lexer parse location for error messages\n   char *where_firstchar;\n   char *where_lastchar;\n\n   // lexer token variables\n   long token;\n   double real_number;\n   long   int_number;\n   char *string;\n   int string_len;\n} stb_lexer;\n\ntypedef struct\n{\n   int line_number;\n   int line_offset;\n} stb_lex_location;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void stb_c_lexer_init(stb_lexer *lexer, const char *input_stream, const char *input_stream_end, char *string_store, int store_length);\n// this function initialize the 'lexer' structure\n//   Input:\n//   - input_stream points to the file to parse, loaded into memory\n//   - input_stream_end points to the end of the file, or NULL if you use 0-for-EOF\n//   - string_store is storage the lexer can use for storing parsed strings and identifiers\n//   - store_length is the length of that storage\n\nextern int stb_c_lexer_get_token(stb_lexer *lexer);\n// this function returns non-zero if a token is parsed, or 0 if at EOF\n//   Output:\n//   - lexer->token is the token ID, which is unicode code point for a single-char token, < 0 for a multichar or eof or error\n//   - lexer->real_number is a double constant value for CLEX_floatlit, or CLEX_intlit if STB_C_LEX_INTEGERS_AS_DOUBLES\n//   - lexer->int_number is an integer constant for CLEX_intlit if !STB_C_LEX_INTEGERS_AS_DOUBLES, or character for CLEX_charlit\n//   - lexer->string is a 0-terminated string for CLEX_dqstring or CLEX_sqstring or CLEX_identifier\n//   - lexer->string_len is the byte length of lexer->string\n\nextern void stb_c_lexer_get_location(const stb_lexer *lexer, const char *where, stb_lex_location *loc);\n// this inefficient function returns the line number and character offset of a\n// given location in the file as returned by stb_lex_token. Because it's inefficient,\n// you should only call it for errors, not for every token.\n// For error messages of invalid tokens, you typically want the location of the start\n// of the token (which caused the token to be invalid). For bugs involving legit\n// tokens, you can report the first or the range.\n//    Output:\n//    - loc->line_number is the line number in the file, counting from 1, of the location\n//    - loc->line_offset is the char-offset in the line, counting from 0, of the location\n\n\n#ifdef __cplusplus\n}\n#endif\n\nenum\n{\n   CLEX_eof = 256,\n   CLEX_parse_error,\n   CLEX_intlit        ,\n   CLEX_floatlit      ,\n   CLEX_id            ,\n   CLEX_dqstring      ,\n   CLEX_sqstring      ,\n   CLEX_charlit       ,\n   CLEX_eq            ,\n   CLEX_noteq         ,\n   CLEX_lesseq        ,\n   CLEX_greatereq     ,\n   CLEX_andand        ,\n   CLEX_oror          ,\n   CLEX_shl           ,\n   CLEX_shr           ,\n   CLEX_plusplus      ,\n   CLEX_minusminus    ,\n   CLEX_pluseq        ,\n   CLEX_minuseq       ,\n   CLEX_muleq         ,\n   CLEX_diveq         ,\n   CLEX_modeq         ,\n   CLEX_andeq         ,\n   CLEX_oreq          ,\n   CLEX_xoreq         ,\n   CLEX_arrow         ,\n   CLEX_eqarrow       ,\n   CLEX_shleq, CLEX_shreq,\n\n   CLEX_first_unused_token\n\n};\n#endif // INCLUDE_STB_C_LEXER_H\n\n#ifdef STB_C_LEXER_IMPLEMENTATION\n\n// Hacky definitions so we can easily #if on them\n#define Y(x) 1\n#define N(x) 0\n\n#if STB_C_LEX_INTEGERS_AS_DOUBLES(x)\ntypedef double     stb__clex_int;\n#define intfield   real_number\n#define STB__clex_int_as_double\n#else\ntypedef long       stb__clex_int;\n#define intfield   int_number\n#endif\n\n// Convert these config options to simple conditional #defines so we can more\n// easily test them once we've change the meaning of Y/N\n\n#if STB_C_LEX_PARSE_SUFFIXES(x)\n#define STB__clex_parse_suffixes\n#endif\n\n#if STB_C_LEX_C99_HEX_FLOATS(x)\n#define STB__clex_hex_floats\n#endif\n\n#if STB_C_LEX_C_HEX_INTS(x)\n#define STB__clex_hex_ints\n#endif\n\n#if STB_C_LEX_C_DECIMAL_INTS(x)\n#define STB__clex_decimal_ints\n#endif\n\n#if STB_C_LEX_C_OCTAL_INTS(x)\n#define STB__clex_octal_ints\n#endif\n\n#if STB_C_LEX_C_DECIMAL_FLOATS(x)\n#define STB__clex_decimal_floats\n#endif\n\n#if STB_C_LEX_DISCARD_PREPROCESSOR(x)\n#define STB__clex_discard_preprocessor\n#endif\n\n#if STB_C_LEX_USE_STDLIB(x) && (!defined(STB__clex_hex_floats) || __STDC_VERSION__ >= 199901L)\n#define STB__CLEX_use_stdlib\n#include <stdlib.h>\n#endif\n\n// Now for the rest of the file we'll use the basic definition where\n// where Y expands to its contents and N expands to nothing\n#undef  Y\n#define Y(a) a\n#undef N\n#define N(a)\n\n// API function\nvoid stb_c_lexer_init(stb_lexer *lexer, const char *input_stream, const char *input_stream_end, char *string_store, int store_length)\n{\n   lexer->input_stream = (char *) input_stream;\n   lexer->eof = (char *) input_stream_end;\n   lexer->parse_point = (char *) input_stream;\n   lexer->string_storage = string_store;\n   lexer->string_storage_len = store_length;\n}\n\n// API function\nvoid stb_c_lexer_get_location(const stb_lexer *lexer, const char *where, stb_lex_location *loc)\n{\n   char *p = lexer->input_stream;\n   int line_number = 1;\n   int char_offset = 0;\n   while (*p && p < where) {\n      if (*p == '\\n' || *p == '\\r') {\n         p += (p[0]+p[1] == '\\r'+'\\n' ? 2 : 1); // skip newline\n         line_number += 1;\n         char_offset = 0;\n      } else {\n         ++p;\n         ++char_offset;\n      }\n   }\n   loc->line_number = line_number;\n   loc->line_offset = char_offset;\n}\n\n// main helper function for returning a parsed token\nstatic int stb__clex_token(stb_lexer *lexer, int token, char *start, char *end)\n{\n   lexer->token = token;\n   lexer->where_firstchar = start;\n   lexer->where_lastchar = end;\n   lexer->parse_point = end+1;\n   return 1;\n}\n\n// helper function for returning eof\nstatic int stb__clex_eof(stb_lexer *lexer)\n{\n   lexer->token = CLEX_eof;\n   return 0;\n}\n\nstatic int stb__clex_iswhite(int x)\n{\n   return x == ' ' || x == '\\t' || x == '\\r' || x == '\\n' || x == '\\f';\n}\n\nstatic const char *stb__strchr(const char *str, int ch)\n{\n   for (; *str; ++str)\n      if (*str == ch)\n         return str;\n   return 0;\n}\n\n// parse suffixes at the end of a number\nstatic int stb__clex_parse_suffixes(stb_lexer *lexer, long tokenid, char *start, char *cur, const char *suffixes)\n{\n   #ifdef STB__clex_parse_suffixes\n   lexer->string = lexer->string_storage;\n   lexer->string_len = 0;\n\n   while ((*cur >= 'a' && *cur <= 'z') || (*cur >= 'A' && *cur <= 'Z')) {\n      if (stb__strchr(suffixes, *cur) == 0)\n         return stb__clex_token(lexer, CLEX_parse_error, start, cur);\n      if (lexer->string_len+1 >= lexer->string_storage_len)\n         return stb__clex_token(lexer, CLEX_parse_error, start, cur);\n      lexer->string[lexer->string_len++] = *cur++;\n   }\n   #else\n   suffixes = suffixes; // attempt to suppress warnings\n   #endif\n   return stb__clex_token(lexer, tokenid, start, cur-1);\n}\n\n#ifndef STB__CLEX_use_stdlib\nstatic double stb__clex_pow(double base, unsigned int exponent)\n{\n   double value=1;\n   for ( ; exponent; exponent >>= 1) {\n      if (exponent & 1)\n         value *= base;\n      base *= base;\n   }\n   return value;\n}\n\nstatic double stb__clex_parse_float(char *p, char **q)\n{\n   char *s = p;\n   double value=0;\n   int base=10;\n   int exponent=0;\n\n#ifdef STB__clex_hex_floats\n   if (*p == '0') {\n      if (p[1] == 'x' || p[1] == 'X') {\n         base=16;\n         p += 2;\n      }\n   }\n#endif\n\n   for (;;) {\n      if (*p >= '0' && *p <= '9')\n         value = value*base + (*p++ - '0');\n#ifdef STB__clex_hex_floats\n      else if (base == 16 && *p >= 'a' && *p <= 'f')\n         value = value*base + 10 + (*p++ - 'a');\n      else if (base == 16 && *p >= 'A' && *p <= 'F')\n         value = value*base + 10 + (*p++ - 'A');\n#endif\n      else\n         break;\n   }\n\n   if (*p == '.') {\n      double pow, addend = 0;\n      ++p;\n      for (pow=1; ; pow*=base) {\n         if (*p >= '0' && *p <= '9')\n            addend = addend*base + (*p++ - '0');\n#ifdef STB__clex_hex_floats\n         else if (base == 16 && *p >= 'a' && *p <= 'f')\n            addend = addend*base + 10 + (*p++ - 'a');\n         else if (base == 16 && *p >= 'A' && *p <= 'F')\n            addend = addend*base + 10 + (*p++ - 'A');\n#endif\n         else\n            break;\n      }\n      value += addend / pow;\n   }\n#ifdef STB__clex_hex_floats\n   if (base == 16) {\n      // exponent required for hex float literal\n      if (*p != 'p' && *p != 'P') {\n         *q = s;\n         return 0;\n      }\n      exponent = 1;\n   } else\n#endif\n      exponent = (*p == 'e' || *p == 'E');\n\n   if (exponent) {\n      int sign = p[1] == '-';\n      unsigned int exponent=0;\n      double power=1;\n      ++p;\n      if (*p == '-' || *p == '+')\n         ++p;\n      while (*p >= '0' && *p <= '9')\n         exponent = exponent*10 + (*p++ - '0');\n\n#ifdef STB__clex_hex_floats\n      if (base == 16)\n         power = stb__clex_pow(2, exponent);\n      else\n#endif\n         power = stb__clex_pow(10, exponent);\n      if (sign)\n         value /= power;\n      else\n         value *= power;\n   }\n   *q = p;\n   return value;\n}\n#endif\n\nstatic int stb__clex_parse_char(char *p, char **q)\n{\n   if (*p == '\\\\') {\n      *q = p+2; // tentatively guess we'll parse two characters\n      switch(p[1]) {\n         case '\\\\': return '\\\\';\n         case '\\'': return '\\'';\n         case '\"': return '\"';\n         case 't': return '\\t';\n         case 'f': return '\\f';\n         case 'n': return '\\n';\n         case 'r': return '\\r';\n         case '0': return '\\0'; // @TODO ocatal constants\n         case 'x': case 'X': return -1; // @TODO hex constants\n         case 'u': return -1; // @TODO unicode constants\n      }\n   }\n   *q = p+1;\n   return (unsigned char) *p;\n}\n\nstatic int stb__clex_parse_string(stb_lexer *lexer, char *p, int type)\n{\n   char *start = p;\n   char delim = *p++; // grab the \" or ' for later matching\n   char *out = lexer->string_storage;\n   char *outend = lexer->string_storage + lexer->string_storage_len;\n   while (*p != delim) {\n      int n;\n      if (*p == '\\\\') {\n         char *q;\n         n = stb__clex_parse_char(p, &q);\n         if (n < 0)\n            return stb__clex_token(lexer, CLEX_parse_error, start, q);\n         p = q;\n      } else {\n         // @OPTIMIZE: could speed this up by looping-while-not-backslash\n         n = (unsigned char) *p++;\n      }\n      if (out+1 > outend)\n         return stb__clex_token(lexer, CLEX_parse_error, start, p);\n      // @TODO expand unicode escapes to UTF8\n      *out++ = (char) n;\n   }\n   *out = 0;\n   lexer->string = lexer->string_storage;\n   lexer->string_len = (int) (out - lexer->string_storage);\n   return stb__clex_token(lexer, type, start, p);\n}\n\nint stb_c_lexer_get_token(stb_lexer *lexer)\n{\n   char *p = lexer->parse_point;\n\n   // skip whitespace and comments\n   for (;;) {\n      #ifdef STB_C_LEX_ISWHITE\n      while (p != lexer->stream_end) {\n         int n;\n         n = STB_C_LEX_ISWHITE(p);\n         if (n == 0) break;\n         if (lexer->eof && lexer->eof - lexer->parse_point < n)\n            return stb__clex_token(tok, CLEX_parse_error, p,lexer->eof-1);\n         p += n;\n      }\n      #else\n      while (p != lexer->eof && stb__clex_iswhite(*p))\n         ++p;\n      #endif\n\n      STB_C_LEX_CPP_COMMENTS(\n         if (p != lexer->eof && p[0] == '/' && p[1] == '/') {\n            while (p != lexer->eof && *p != '\\r' && *p != '\\n')\n               ++p;\n            continue;\n         }\n      )\n\n      STB_C_LEX_C_COMMENTS(\n         if (p != lexer->eof && p[0] == '/' && p[1] == '*') {\n            char *start = p;\n            p += 2;\n            while (p != lexer->eof && (p[0] != '*' || p[1] != '/'))\n               ++p;\n            if (p == lexer->eof)\n               return stb__clex_token(lexer, CLEX_parse_error, start, p-1);\n            p += 2;\n            continue;\n         }\n      )\n\n      #ifdef STB__clex_discard_preprocessor\n         // @TODO this discards everything after a '#', regardless\n         // of where in the line the # is, rather than requiring it\n         // be at the start. (because this parser doesn't otherwise\n         // check for line breaks!)\n         if (p != lexer->eof && p[0] == '#') {\n            while (p != lexer->eof && *p != '\\r' && *p != '\\n')\n               ++p;\n            continue;\n         }\n      #endif\n\n      break;\n   }\n\n   if (p == lexer->eof)\n      return stb__clex_eof(lexer);\n\n   switch (*p) {\n      default:\n         if (   (*p >= 'a' && *p <= 'z')\n             || (*p >= 'A' && *p <= 'Z')\n             || *p == '_' || (unsigned char) *p >= 128    // >= 128 is UTF8 char\n             STB_C_LEX_DOLLAR_IDENTIFIER( || *p == '$' ) )\n         {\n            int n = 0;\n            lexer->string = lexer->string_storage;\n            do {\n               if (n+1 >= lexer->string_storage_len)\n                  return stb__clex_token(lexer, CLEX_parse_error, p, p+n);\n               lexer->string[n] = p[n];\n               ++n;\n            } while (\n                  (p[n] >= 'a' && p[n] <= 'z')\n               || (p[n] >= 'A' && p[n] <= 'Z')\n               || (p[n] >= '0' && p[n] <= '9') // allow digits in middle of identifier\n               || p[n] == '_' || (unsigned char) p[n] >= 128\n                STB_C_LEX_DOLLAR_IDENTIFIER( || p[n] == '$' )\n            );\n            lexer->string[n] = 0;\n            lexer->string_len = n;\n            return stb__clex_token(lexer, CLEX_id, p, p+n-1);\n         }\n\n         // check for EOF\n         STB_C_LEX_0_IS_EOF(\n            if (*p == 0)\n               return stb__clex_eof(lexer);\n         )\n\n      single_char:\n         // not an identifier, return the character as itself\n         return stb__clex_token(lexer, *p, p, p);\n\n      case '+':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_INCREMENTS(if (p[1] == '+') return stb__clex_token(lexer, CLEX_plusplus, p,p+1);)\n            STB_C_LEX_C_ARITHEQ(   if (p[1] == '=') return stb__clex_token(lexer, CLEX_pluseq  , p,p+1);)\n         }\n         goto single_char;\n      case '-':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_INCREMENTS(if (p[1] == '-') return stb__clex_token(lexer, CLEX_minusminus, p,p+1);)\n            STB_C_LEX_C_ARITHEQ(   if (p[1] == '=') return stb__clex_token(lexer, CLEX_minuseq   , p,p+1);)\n            STB_C_LEX_C_ARROW(     if (p[1] == '>') return stb__clex_token(lexer, CLEX_arrow     , p,p+1);)\n         }\n         goto single_char;\n      case '&':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_LOGICAL(  if (p[1] == '&') return stb__clex_token(lexer, CLEX_andand, p,p+1);)\n            STB_C_LEX_C_BITWISEEQ(if (p[1] == '=') return stb__clex_token(lexer, CLEX_andeq , p,p+1);)\n         }\n         goto single_char;\n      case '|':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_LOGICAL(  if (p[1] == '|') return stb__clex_token(lexer, CLEX_oror, p,p+1);)\n            STB_C_LEX_C_BITWISEEQ(if (p[1] == '=') return stb__clex_token(lexer, CLEX_oreq, p,p+1);)\n         }\n         goto single_char;\n      case '=':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_COMPARISONS(if (p[1] == '=') return stb__clex_token(lexer, CLEX_eq, p,p+1);)\n            STB_C_LEX_EQUAL_ARROW(  if (p[1] == '>') return stb__clex_token(lexer, CLEX_eqarrow, p,p+1);)\n         }\n         goto single_char;\n      case '!':\n         STB_C_LEX_C_COMPARISONS(if (p+1 != lexer->eof && p[1] == '=') return stb__clex_token(lexer, CLEX_noteq, p,p+1);)\n         goto single_char;\n      case '^':\n         STB_C_LEX_C_BITWISEEQ(if (p+1 != lexer->eof && p[1] == '=') return stb__clex_token(lexer, CLEX_xoreq, p,p+1));\n         goto single_char;\n      case '%':\n         STB_C_LEX_C_ARITHEQ(if (p+1 != lexer->eof && p[1] == '=') return stb__clex_token(lexer, CLEX_modeq, p,p+1));\n         goto single_char;\n      case '*':\n         STB_C_LEX_C_ARITHEQ(if (p+1 != lexer->eof && p[1] == '=') return stb__clex_token(lexer, CLEX_muleq, p,p+1));\n         goto single_char;\n      case '/':\n         STB_C_LEX_C_ARITHEQ(if (p+1 != lexer->eof && p[1] == '=') return stb__clex_token(lexer, CLEX_diveq, p,p+1));\n         goto single_char;\n      case '<':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_COMPARISONS(if (p[1] == '=') return stb__clex_token(lexer, CLEX_lesseq, p,p+1);)\n            STB_C_LEX_C_SHIFTS(     if (p[1] == '<') {\n                                       STB_C_LEX_C_ARITHEQ(if (p+2 != lexer->eof && p[2] == '=')\n                                                              return stb__clex_token(lexer, CLEX_shleq, p,p+2);)\n                                       return stb__clex_token(lexer, CLEX_shl, p,p+1);\n                                    }\n                              )\n         }\n         goto single_char;\n      case '>':\n         if (p+1 != lexer->eof) {\n            STB_C_LEX_C_COMPARISONS(if (p[1] == '=') return stb__clex_token(lexer, CLEX_greatereq, p,p+1);)\n            STB_C_LEX_C_SHIFTS(     if (p[1] == '>') {\n                                       STB_C_LEX_C_ARITHEQ(if (p+2 != lexer->eof && p[2] == '=')\n                                                              return stb__clex_token(lexer, CLEX_shreq, p,p+2);)\n                                       return stb__clex_token(lexer, CLEX_shr, p,p+1);\n                                    }\n                              )\n         }\n         goto single_char;\n\n      case '\"':\n         STB_C_LEX_C_DQ_STRINGS(return stb__clex_parse_string(lexer, p, CLEX_dqstring);)\n         goto single_char;\n      case '\\'':\n         STB_C_LEX_C_SQ_STRINGS(return stb__clex_parse_string(lexer, p, CLEX_sqstring);)\n         STB_C_LEX_C_CHARS(\n         {\n            char *start = p;\n            lexer->int_number = stb__clex_parse_char(p+1, &p);\n            if (lexer->int_number < 0)\n               return stb__clex_token(lexer, CLEX_parse_error, start,start);\n            if (p == lexer->eof || *p != '\\'')\n               return stb__clex_token(lexer, CLEX_parse_error, start,p);\n            return stb__clex_token(lexer, CLEX_charlit, start, p+1);\n         })\n         goto single_char;\n\n      case '0':\n         #if defined(STB__clex_hex_ints) || defined(STB__clex_hex_floats)\n            if (p+1 != lexer->eof) {\n               if (p[1] == 'x' || p[1] == 'X') {\n                  char *q;\n\n                  #ifdef STB__clex_hex_floats\n                  for (q=p+2;\n                       q != lexer->eof && ((*q >= '0' && *q <= '9') || (*q >= 'a' && *q <= 'f') || (*q >= 'A' && *q <= 'F'));\n                       ++q);\n                  if (q != lexer->eof) {\n                     if (*q == '.' STB_C_LEX_FLOAT_NO_DECIMAL(|| *q == 'p' || *q == 'P')) {\n                        #ifdef STB__CLEX_use_stdlib\n                        lexer->real_number = strtod((char *) p, (char**) &q);\n                        #else\n                        lexer->real_number = stb__clex_parse_float(p, &q);\n                        #endif\n\n                        if (p == q)\n                           return stb__clex_token(lexer, CLEX_parse_error, p,q);\n                        return stb__clex_parse_suffixes(lexer, CLEX_floatlit, p,q, STB_C_LEX_FLOAT_SUFFIXES);\n\n                     }\n                  }\n                  #endif   // STB__CLEX_hex_floats\n\n                  #ifdef STB__clex_hex_ints\n                  #ifdef STB__CLEX_use_stdlib\n                  lexer->int_number = strtol((char *) p, (char **) &q, 16);\n                  #else\n                  {\n                     stb__clex_int n=0;\n                     for (q=p+2; q != lexer->eof; ++q) {\n                        if (*q >= '0' && *q <= '9')\n                           n = n*16 + (*q - '0');\n                        else if (*q >= 'a' && *q <= 'f')\n                           n = n*16 + (*q - 'a') + 10;\n                        else if (*q >= 'A' && *q <= 'F')\n                           n = n*16 + (*q - 'A') + 10;\n                        else\n                           break;\n                     }\n                     lexer->int_number = n;\n                  }\n                  #endif\n                  if (q == p+2)\n                     return stb__clex_token(lexer, CLEX_parse_error, p-2,p-1);\n                  return stb__clex_parse_suffixes(lexer, CLEX_intlit, p,q, STB_C_LEX_HEX_SUFFIXES);\n                  #endif\n               }\n            }\n         #endif // defined(STB__clex_hex_ints) || defined(STB__clex_hex_floats)\n         // can't test for octal because we might parse '0.0' as float or as '0' '.' '0',\n         // so have to do float first\n\n         /* FALL THROUGH */\n      case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':\n\n         #ifdef STB__clex_decimal_floats\n         {\n            char *q = p;\n            while (q != lexer->eof && (*q >= '0' && *q <= '9'))\n               ++q;\n            if (q != lexer->eof) {\n               if (*q == '.' STB_C_LEX_FLOAT_NO_DECIMAL(|| *q == 'e' || *q == 'E')) {\n                  #ifdef STB__CLEX_use_stdlib\n                  lexer->real_number = strtod((char *) p, (char**) &q);\n                  #else\n                  lexer->real_number = stb__clex_parse_float(p, &q);\n                  #endif\n\n                  return stb__clex_parse_suffixes(lexer, CLEX_floatlit, p,q, STB_C_LEX_FLOAT_SUFFIXES);\n\n               }\n            }\n         }\n         #endif // STB__clex_decimal_floats\n\n         #ifdef STB__clex_octal_ints\n         if (p[0] == '0') {\n            char *q = p;\n            #ifdef STB__CLEX_use_stdlib\n            lexer->int_number = strtol((char *) p, (char **) &q, 8);\n            #else\n            stb__clex_int n=0;\n            while (q != lexer->eof) {\n               if (*q >= '0' && *q <= '7')\n                  n = n*8 + (*q - '0');\n               else\n                  break;\n               ++q;\n            }\n            if (q != lexer->eof && (*q == '8' || *q=='9'))\n               return stb__clex_token(lexer, CLEX_parse_error, p, q);\n            lexer->int_number = n;\n            #endif\n            return stb__clex_parse_suffixes(lexer, CLEX_intlit, p,q, STB_C_LEX_OCTAL_SUFFIXES);\n         }\n         #endif // STB__clex_octal_ints\n\n         #ifdef STB__clex_decimal_ints\n         {\n            char *q = p;\n            #ifdef STB__CLEX_use_stdlib\n            lexer->int_number = strtol((char *) p, (char **) &q, 10);\n            #else\n            stb__clex_int n=0;\n            while (q != lexer->eof) {\n               if (*q >= '0' && *q <= '9')\n                  n = n*10 + (*q - '0');\n               else\n                  break;\n               ++q;\n            }\n            lexer->int_number = n;\n            #endif\n            return stb__clex_parse_suffixes(lexer, CLEX_intlit, p,q, STB_C_LEX_OCTAL_SUFFIXES);\n         }\n         #endif // STB__clex_decimal_ints\n         goto single_char;\n   }\n}\n#endif // STB_C_LEXER_IMPLEMENTATION\n\n#ifdef STB_C_LEXER_SELF_TEST\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic void print_token(stb_lexer *lexer)\n{\n   switch (lexer->token) {\n      case CLEX_id        : printf(\"_%s\", lexer->string); break;\n      case CLEX_eq        : printf(\"==\"); break;\n      case CLEX_noteq     : printf(\"!=\"); break;\n      case CLEX_lesseq    : printf(\"<=\"); break;\n      case CLEX_greatereq : printf(\">=\"); break;\n      case CLEX_andand    : printf(\"&&\"); break;\n      case CLEX_oror      : printf(\"||\"); break;\n      case CLEX_shl       : printf(\"<<\"); break;\n      case CLEX_shr       : printf(\">>\"); break;\n      case CLEX_plusplus  : printf(\"++\"); break;\n      case CLEX_minusminus: printf(\"--\"); break;\n      case CLEX_arrow     : printf(\"->\"); break;\n      case CLEX_andeq     : printf(\"&=\"); break;\n      case CLEX_oreq      : printf(\"|=\"); break;\n      case CLEX_xoreq     : printf(\"^=\"); break;\n      case CLEX_pluseq    : printf(\"+=\"); break;\n      case CLEX_minuseq   : printf(\"-=\"); break;\n      case CLEX_muleq     : printf(\"*=\"); break;\n      case CLEX_diveq     : printf(\"/=\"); break;\n      case CLEX_modeq     : printf(\"%%=\"); break;\n      case CLEX_shleq     : printf(\"<<=\"); break;\n      case CLEX_shreq     : printf(\">>=\"); break;\n      case CLEX_eqarrow   : printf(\"=>\"); break;\n      case CLEX_dqstring  : printf(\"\\\"%s\\\"\", lexer->string); break;\n      case CLEX_sqstring  : printf(\"'\\\"%s\\\"'\", lexer->string); break;\n      case CLEX_charlit   : printf(\"'%s'\", lexer->string); break;\n      #if defined(STB__clex_int_as_double) && !defined(STB__CLEX_use_stdlib)\n      case CLEX_intlit    : printf(\"#%g\", lexer->real_number); break;\n      #else\n      case CLEX_intlit    : printf(\"#%ld\", lexer->int_number); break;\n      #endif\n      case CLEX_floatlit  : printf(\"%g\", lexer->real_number); break;\n      default:\n         if (lexer->token >= 0 && lexer->token < 256)\n            printf(\"%c\", (int) lexer->token);\n         else {\n            printf(\"<<<UNKNOWN TOKEN %ld >>>\\n\", lexer->token);\n         }\n         break;\n   }\n}\n\n/* Force a test\nof parsing\nmultiline comments */\n\n/*/ comment /*/\n/**/ extern /**/\n\nvoid dummy(void)\n{\n   double some_floats[] = {\n      1.0501, -10.4e12, 5E+10,\n#if 0   // not supported in C++ or C-pre-99, so don't try to compile it, but let our parser test it\n      0x1.0p+24, 0xff.FP-8, 0x1p-23,\n#endif\n      4.\n   };\n   (void) sizeof(some_floats);\n   (void) some_floats[1];\n\n   printf(\"test %d\",1); // https://github.com/nothings/stb/issues/13\n}\n\nint main(int argc, char **argv)\n{\n   FILE *f = fopen(\"stb_c_lexer.h\",\"rb\");\n   char *text = (char *) malloc(1 << 20);\n   int len = f ? (int) fread(text, 1, 1<<20, f) : -1;\n   stb_lexer lex;\n   if (len < 0) {\n      fprintf(stderr, \"Error opening file\\n\");\n      free(text);\n      fclose(f);\n      return 1;\n   }\n   fclose(f);\n\n   stb_c_lexer_init(&lex, text, text+len, (char *) malloc(0x10000), 0x10000);\n   while (stb_c_lexer_get_token(&lex)) {\n      if (lex.token == CLEX_parse_error) {\n         printf(\"\\n<<<PARSE ERROR>>>\\n\");\n         break;\n      }\n      print_token(&lex);\n      printf(\"  \");\n   }\n   return 0;\n}\n#endif\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_connected_components.h",
          "type": "blob",
          "size": 36.4248046875,
          "content": "// stb_connected_components - v0.96 - public domain connected components on grids\n//                                                 http://github.com/nothings/stb\n//\n// Finds connected components on 2D grids for testing reachability between\n// two points, with fast updates when changing reachability (e.g. on one machine\n// it was typically 0.2ms w/ 1024x1024 grid). Each grid square must be \"open\" or\n// \"closed\" (traversable or untraversable), and grid squares are only connected\n// to their orthogonal neighbors, not diagonally.\n//\n// In one source file, create the implementation by doing something like this:\n//\n//   #define STBCC_GRID_COUNT_X_LOG2    10\n//   #define STBCC_GRID_COUNT_Y_LOG2    10\n//   #define STB_CONNECTED_COMPONENTS_IMPLEMENTATION\n//   #include \"stb_connected_components.h\"\n//\n// The above creates an implementation that can run on maps up to 1024x1024.\n// Map sizes must be a multiple of (1<<(LOG2/2)) on each axis (e.g. 32 if LOG2=10,\n// 16 if LOG2=8, etc.) (You can just pad your map with untraversable space.)\n//\n// MEMORY USAGE\n//\n//   Uses about 6-7 bytes per grid square (e.g. 7MB for a 1024x1024 grid).\n//   Uses a single worst-case allocation which you pass in.\n//\n// PERFORMANCE\n//\n//   On a core i7-2700K at 3.5 Ghz, for a particular 1024x1024 map (map_03.png):\n//\n//       Creating map                   : 44.85 ms\n//       Making one square   traversable:  0.27 ms    (average over 29,448 calls)\n//       Making one square untraversable:  0.23 ms    (average over 30,123 calls)\n//       Reachability query:               0.00001 ms (average over 4,000,000 calls)\n//\n//   On non-degenerate maps update time is O(N^0.5), but on degenerate maps like\n//   checkerboards or 50% random, update time is O(N^0.75) (~2ms on above machine).\n//\n// CHANGELOG\n//\n//    0.96  (2019-03-04)  Fix warnings\n//    0.95  (2016-10-16)  Bugfix if multiple clumps in one cluster connect to same clump in another\n//    0.94  (2016-04-17)  Bugfix & optimize worst case (checkerboard & random)\n//    0.93  (2016-04-16)  Reduce memory by 10x for 1Kx1K map; small speedup\n//    0.92  (2016-04-16)  Compute sqrt(N) cluster size by default\n//    0.91  (2016-04-15)  Initial release\n//\n// TODO:\n//    - better API documentation\n//    - more comments\n//    - try re-integrating naive algorithm & compare performance\n//    - more optimized batching (current approach still recomputes local clumps many times)\n//    - function for setting a grid of squares at once (just use batching)\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// ALGORITHM\n//\n//   The NxN grid map is split into sqrt(N) x sqrt(N) blocks called\n//  \"clusters\". Each cluster independently computes a set of connected\n//   components within that cluster (ignoring all connectivity out of\n//   that cluster) using a union-find disjoint set forest. This produces a bunch\n//   of locally connected components called \"clumps\". Each clump is (a) connected\n//   within its cluster, (b) does not directly connect to any other clumps in the\n//   cluster (though it may connect to them by paths that lead outside the cluster,\n//   but those are ignored at this step), and (c) maintains an adjacency list of\n//   all clumps in adjacent clusters that it _is_ connected to. Then a second\n//   union-find disjoint set forest is used to compute connected clumps\n//   globally, across the whole map. Reachability is then computed by\n//   finding which clump each input point belongs to, and checking whether\n//   those clumps are in the same \"global\" connected component.\n//\n//   The above data structure can be updated efficiently; on a change\n//   of a single grid square on the map, only one cluster changes its\n//   purely-local state, so only one cluster needs its clumps fully\n//   recomputed. Clumps in adjacent clusters need their adjacency lists\n//   updated: first to remove all references to the old clumps in the\n//   rebuilt cluster, then to add new references to the new clumps. Both\n//   of these operations can use the existing \"find which clump each input\n//   point belongs to\" query to compute that adjacency information rapidly.\n\n#ifndef INCLUDE_STB_CONNECTED_COMPONENTS_H\n#define INCLUDE_STB_CONNECTED_COMPONENTS_H\n\n#include <stdlib.h>\n\ntypedef struct st_stbcc_grid stbcc_grid;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//\n//  initialization\n//\n\n// you allocate the grid data structure to this size (note that it will be very big!!!)\nextern size_t stbcc_grid_sizeof(void);\n\n// initialize the grid, value of map[] is 0 = traversable, non-0 is solid\nextern void stbcc_init_grid(stbcc_grid *g, unsigned char *map, int w, int h);\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//\n//  main functionality\n//\n\n// update a grid square state, 0 = traversable, non-0 is solid\n// i can add a batch-update if it's needed\nextern void stbcc_update_grid(stbcc_grid *g, int x, int y, int solid);\n\n// query if two grid squares are reachable from each other\nextern int stbcc_query_grid_node_connection(stbcc_grid *g, int x1, int y1, int x2, int y2);\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//\n//  bonus functions\n//\n\n// wrap multiple stbcc_update_grid calls in these function to compute\n// multiple updates more efficiently; cannot make queries inside batch\nextern void stbcc_update_batch_begin(stbcc_grid *g);\nextern void stbcc_update_batch_end(stbcc_grid *g);\n\n// query the grid data structure for whether a given square is open or not\nextern int stbcc_query_grid_open(stbcc_grid *g, int x, int y);\n\n// get a unique id for the connected component this is in; it's not necessarily\n// small, you'll need a hash table or something to remap it (or just use\nextern unsigned int stbcc_get_unique_id(stbcc_grid *g, int x, int y);\n#define STBCC_NULL_UNIQUE_ID 0xffffffff // returned for closed map squares\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // INCLUDE_STB_CONNECTED_COMPONENTS_H\n\n#ifdef STB_CONNECTED_COMPONENTS_IMPLEMENTATION\n\n#include <assert.h>\n#include <string.h> // memset\n\n#if !defined(STBCC_GRID_COUNT_X_LOG2) || !defined(STBCC_GRID_COUNT_Y_LOG2)\n   #error \"You must define STBCC_GRID_COUNT_X_LOG2 and STBCC_GRID_COUNT_Y_LOG2 to define the max grid supported.\"\n#endif\n\n#define STBCC__GRID_COUNT_X (1 << STBCC_GRID_COUNT_X_LOG2)\n#define STBCC__GRID_COUNT_Y (1 << STBCC_GRID_COUNT_Y_LOG2)\n\n#define STBCC__MAP_STRIDE   (1 << (STBCC_GRID_COUNT_X_LOG2-3))\n\n#ifndef STBCC_CLUSTER_SIZE_X_LOG2\n   #define STBCC_CLUSTER_SIZE_X_LOG2   (STBCC_GRID_COUNT_X_LOG2/2) // log2(sqrt(2^N)) = 1/2 * log2(2^N)) = 1/2 * N\n   #if STBCC_CLUSTER_SIZE_X_LOG2 > 6\n   #undef STBCC_CLUSTER_SIZE_X_LOG2\n   #define STBCC_CLUSTER_SIZE_X_LOG2 6\n   #endif\n#endif\n\n#ifndef STBCC_CLUSTER_SIZE_Y_LOG2\n   #define STBCC_CLUSTER_SIZE_Y_LOG2   (STBCC_GRID_COUNT_Y_LOG2/2)\n   #if STBCC_CLUSTER_SIZE_Y_LOG2 > 6\n   #undef STBCC_CLUSTER_SIZE_Y_LOG2\n   #define STBCC_CLUSTER_SIZE_Y_LOG2 6\n   #endif\n#endif\n\n#define STBCC__CLUSTER_SIZE_X   (1 << STBCC_CLUSTER_SIZE_X_LOG2)\n#define STBCC__CLUSTER_SIZE_Y   (1 << STBCC_CLUSTER_SIZE_Y_LOG2)\n\n#define STBCC__CLUSTER_COUNT_X_LOG2   (STBCC_GRID_COUNT_X_LOG2 - STBCC_CLUSTER_SIZE_X_LOG2)\n#define STBCC__CLUSTER_COUNT_Y_LOG2   (STBCC_GRID_COUNT_Y_LOG2 - STBCC_CLUSTER_SIZE_Y_LOG2)\n\n#define STBCC__CLUSTER_COUNT_X  (1 << STBCC__CLUSTER_COUNT_X_LOG2)\n#define STBCC__CLUSTER_COUNT_Y  (1 << STBCC__CLUSTER_COUNT_Y_LOG2)\n\n#if STBCC__CLUSTER_SIZE_X >= STBCC__GRID_COUNT_X || STBCC__CLUSTER_SIZE_Y >= STBCC__GRID_COUNT_Y\n   #error \"STBCC_CLUSTER_SIZE_X/Y_LOG2 must be smaller than STBCC_GRID_COUNT_X/Y_LOG2\"\n#endif\n\n// worst case # of clumps per cluster\n#define STBCC__MAX_CLUMPS_PER_CLUSTER_LOG2   (STBCC_CLUSTER_SIZE_X_LOG2 + STBCC_CLUSTER_SIZE_Y_LOG2-1)\n#define STBCC__MAX_CLUMPS_PER_CLUSTER        (1 << STBCC__MAX_CLUMPS_PER_CLUSTER_LOG2)\n#define STBCC__MAX_CLUMPS                    (STBCC__MAX_CLUMPS_PER_CLUSTER * STBCC__CLUSTER_COUNT_X * STBCC__CLUSTER_COUNT_Y)\n#define STBCC__NULL_CLUMPID                  STBCC__MAX_CLUMPS_PER_CLUSTER\n\n#define STBCC__CLUSTER_X_FOR_COORD_X(x)  ((x) >> STBCC_CLUSTER_SIZE_X_LOG2)\n#define STBCC__CLUSTER_Y_FOR_COORD_Y(y)  ((y) >> STBCC_CLUSTER_SIZE_Y_LOG2)\n\n#define STBCC__MAP_BYTE_MASK(x,y)       (1 << ((x) & 7))\n#define STBCC__MAP_BYTE(g,x,y)          ((g)->map[y][(x) >> 3])\n#define STBCC__MAP_OPEN(g,x,y)          (STBCC__MAP_BYTE(g,x,y) & STBCC__MAP_BYTE_MASK(x,y))\n\ntypedef unsigned short stbcc__clumpid;\ntypedef unsigned char stbcc__verify_max_clumps[STBCC__MAX_CLUMPS_PER_CLUSTER < (1 << (8*sizeof(stbcc__clumpid))) ? 1 : -1];\n\n#define STBCC__MAX_EXITS_PER_CLUSTER   (STBCC__CLUSTER_SIZE_X + STBCC__CLUSTER_SIZE_Y)   // 64 for 32x32\n#define STBCC__MAX_EXITS_PER_CLUMP     (STBCC__CLUSTER_SIZE_X + STBCC__CLUSTER_SIZE_Y)   // 64 for 32x32\n#define STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER  (STBCC__MAX_EXITS_PER_CLUMP)\n\n// 2^19 * 2^6 => 2^25 exits => 2^26  => 64MB for 1024x1024\n\n// Logic for above on 4x4 grid:\n//\n// Many clumps:      One clump:\n//   + +               +  +\n//  +X.X.             +XX.X+\n//   .X.X+             .XXX\n//  +X.X.              XXX.\n//   .X.X+            +X.XX+\n//    + +              +  +\n//\n// 8 exits either way\n\ntypedef unsigned char stbcc__verify_max_exits[STBCC__MAX_EXITS_PER_CLUMP <= 256];\n\ntypedef struct\n{\n   unsigned short clump_index:12;\n     signed short cluster_dx:2;\n     signed short cluster_dy:2;\n} stbcc__relative_clumpid;\n\ntypedef union\n{\n   struct {\n      unsigned int clump_index:12;\n      unsigned int cluster_x:10;\n      unsigned int cluster_y:10;\n   } f;\n   unsigned int c;\n} stbcc__global_clumpid;\n\n// rebuilt cluster 3,4\n\n// what changes in cluster 2,4\n\ntypedef struct\n{\n   stbcc__global_clumpid global_label;        // 4\n   unsigned char num_adjacent;                // 1\n   unsigned char max_adjacent;                // 1\n   unsigned char adjacent_clump_list_index;   // 1\n   unsigned char reserved;\n} stbcc__clump; // 8\n\n#define STBCC__CLUSTER_ADJACENCY_COUNT   (STBCC__MAX_EXITS_PER_CLUSTER*2)\ntypedef struct\n{\n   short num_clumps;\n   unsigned char num_edge_clumps;\n   unsigned char rebuild_adjacency;\n   stbcc__clump clump[STBCC__MAX_CLUMPS_PER_CLUSTER];       // 8 * 2^9 = 4KB\n   stbcc__relative_clumpid adjacency_storage[STBCC__CLUSTER_ADJACENCY_COUNT]; // 256 bytes\n} stbcc__cluster;\n\nstruct st_stbcc_grid\n{\n   int w,h,cw,ch;\n   int in_batched_update;\n   //unsigned char cluster_dirty[STBCC__CLUSTER_COUNT_Y][STBCC__CLUSTER_COUNT_X]; // could bitpack, but: 1K x 1K => 1KB\n   unsigned char map[STBCC__GRID_COUNT_Y][STBCC__MAP_STRIDE]; // 1K x 1K => 1K x 128 => 128KB\n   stbcc__clumpid clump_for_node[STBCC__GRID_COUNT_Y][STBCC__GRID_COUNT_X];  // 1K x 1K x 2 = 2MB\n   stbcc__cluster cluster[STBCC__CLUSTER_COUNT_Y][STBCC__CLUSTER_COUNT_X]; //  1K x 4.5KB = 4.5MB\n};\n\nint stbcc_query_grid_node_connection(stbcc_grid *g, int x1, int y1, int x2, int y2)\n{\n   stbcc__global_clumpid label1, label2;\n   stbcc__clumpid c1 = g->clump_for_node[y1][x1];\n   stbcc__clumpid c2 = g->clump_for_node[y2][x2];\n   int cx1 = STBCC__CLUSTER_X_FOR_COORD_X(x1);\n   int cy1 = STBCC__CLUSTER_Y_FOR_COORD_Y(y1);\n   int cx2 = STBCC__CLUSTER_X_FOR_COORD_X(x2);\n   int cy2 = STBCC__CLUSTER_Y_FOR_COORD_Y(y2);\n   assert(!g->in_batched_update);\n   if (c1 == STBCC__NULL_CLUMPID || c2 == STBCC__NULL_CLUMPID)\n      return 0;\n   label1 = g->cluster[cy1][cx1].clump[c1].global_label;\n   label2 = g->cluster[cy2][cx2].clump[c2].global_label;\n   if (label1.c == label2.c)\n      return 1;\n   return 0;\n}\n\nint stbcc_query_grid_open(stbcc_grid *g, int x, int y)\n{\n   return STBCC__MAP_OPEN(g, x, y) != 0;\n}\n\nunsigned int stbcc_get_unique_id(stbcc_grid *g, int x, int y)\n{\n   stbcc__clumpid c = g->clump_for_node[y][x];\n   int cx = STBCC__CLUSTER_X_FOR_COORD_X(x);\n   int cy = STBCC__CLUSTER_Y_FOR_COORD_Y(y);\n   assert(!g->in_batched_update);\n   if (c == STBCC__NULL_CLUMPID) return STBCC_NULL_UNIQUE_ID;\n   return g->cluster[cy][cx].clump[c].global_label.c;\n}\n\ntypedef struct\n{\n   unsigned char x,y;\n} stbcc__tinypoint;\n\ntypedef struct\n{\n   stbcc__tinypoint parent[STBCC__CLUSTER_SIZE_Y][STBCC__CLUSTER_SIZE_X]; // 32x32 => 2KB\n   stbcc__clumpid   label[STBCC__CLUSTER_SIZE_Y][STBCC__CLUSTER_SIZE_X];\n} stbcc__cluster_build_info;\n\nstatic void stbcc__build_clumps_for_cluster(stbcc_grid *g, int cx, int cy);\nstatic void stbcc__remove_connections_to_adjacent_cluster(stbcc_grid *g, int cx, int cy, int dx, int dy);\nstatic void stbcc__add_connections_to_adjacent_cluster(stbcc_grid *g, int cx, int cy, int dx, int dy);\n\nstatic stbcc__global_clumpid stbcc__clump_find(stbcc_grid *g, stbcc__global_clumpid n)\n{\n   stbcc__global_clumpid q;\n   stbcc__clump *c = &g->cluster[n.f.cluster_y][n.f.cluster_x].clump[n.f.clump_index];\n\n   if (c->global_label.c == n.c)\n      return n;\n\n   q = stbcc__clump_find(g, c->global_label);\n   c->global_label = q;\n   return q;\n}\n\ntypedef struct\n{\n   unsigned int cluster_x;\n   unsigned int cluster_y;\n   unsigned int clump_index;\n} stbcc__unpacked_clumpid;\n\nstatic void stbcc__clump_union(stbcc_grid *g, stbcc__unpacked_clumpid m, int x, int y, int idx)\n{\n   stbcc__clump *mc = &g->cluster[m.cluster_y][m.cluster_x].clump[m.clump_index];\n   stbcc__clump *nc = &g->cluster[y][x].clump[idx];\n   stbcc__global_clumpid mp = stbcc__clump_find(g, mc->global_label);\n   stbcc__global_clumpid np = stbcc__clump_find(g, nc->global_label);\n\n   if (mp.c == np.c)\n      return;\n\n   g->cluster[mp.f.cluster_y][mp.f.cluster_x].clump[mp.f.clump_index].global_label = np;\n}\n\nstatic void stbcc__build_connected_components_for_clumps(stbcc_grid *g)\n{\n   int i,j,k,h;\n\n   for (j=0; j < STBCC__CLUSTER_COUNT_Y; ++j) {\n      for (i=0; i < STBCC__CLUSTER_COUNT_X; ++i) {\n         stbcc__cluster *cluster = &g->cluster[j][i];\n         for (k=0; k < (int) cluster->num_edge_clumps; ++k) {\n            stbcc__global_clumpid m;\n            m.f.clump_index = k;\n            m.f.cluster_x = i;\n            m.f.cluster_y = j;\n            assert((int) m.f.clump_index == k && (int) m.f.cluster_x == i && (int) m.f.cluster_y == j);\n            cluster->clump[k].global_label = m;\n         }\n      }\n   }\n\n   for (j=0; j < STBCC__CLUSTER_COUNT_Y; ++j) {\n      for (i=0; i < STBCC__CLUSTER_COUNT_X; ++i) {\n         stbcc__cluster *cluster = &g->cluster[j][i];\n         for (k=0; k < (int) cluster->num_edge_clumps; ++k) {\n            stbcc__clump *clump = &cluster->clump[k];\n            stbcc__unpacked_clumpid m;\n            stbcc__relative_clumpid *adj;\n            m.clump_index = k;\n            m.cluster_x = i;\n            m.cluster_y = j;\n            adj = &cluster->adjacency_storage[clump->adjacent_clump_list_index];\n            for (h=0; h < clump->num_adjacent; ++h) {\n               unsigned int clump_index = adj[h].clump_index;\n               unsigned int x = adj[h].cluster_dx + i;\n               unsigned int y = adj[h].cluster_dy + j;\n               stbcc__clump_union(g, m, x, y, clump_index);\n            }\n         }\n      }\n   }\n\n   for (j=0; j < STBCC__CLUSTER_COUNT_Y; ++j) {\n      for (i=0; i < STBCC__CLUSTER_COUNT_X; ++i) {\n         stbcc__cluster *cluster = &g->cluster[j][i];\n         for (k=0; k < (int) cluster->num_edge_clumps; ++k) {\n            stbcc__global_clumpid m;\n            m.f.clump_index = k;\n            m.f.cluster_x = i;\n            m.f.cluster_y = j;\n            stbcc__clump_find(g, m);\n         }\n      }\n   }\n}\n\nstatic void stbcc__build_all_connections_for_cluster(stbcc_grid *g, int cx, int cy)\n{\n   // in this particular case, we are fully non-incremental. that means we\n   // can discover the correct sizes for the arrays, but requires we build\n   // the data into temporary data structures, or just count the sizes, so\n   // for simplicity we do the latter\n   stbcc__cluster *cluster = &g->cluster[cy][cx];\n   unsigned char connected[STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER][STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER/8]; // 64 x 8 => 1KB\n   unsigned char num_adj[STBCC__MAX_CLUMPS_PER_CLUSTER] = { 0 };\n   int x = cx * STBCC__CLUSTER_SIZE_X;\n   int y = cy * STBCC__CLUSTER_SIZE_Y;\n   int step_x, step_y=0, i, j, k, n, m, dx, dy, total;\n   int extra;\n\n   g->cluster[cy][cx].rebuild_adjacency = 0;\n\n   total = 0;\n   for (m=0; m < 4; ++m) {\n      switch (m) {\n         case 0:\n            dx = 1, dy = 0;\n            step_x = 0, step_y = 1;\n            i = STBCC__CLUSTER_SIZE_X-1;\n            j = 0;\n            n = STBCC__CLUSTER_SIZE_Y;\n            break;\n         case 1:\n            dx = -1, dy = 0;\n            i = 0;\n            j = 0;\n            step_x = 0;\n            step_y = 1;\n            n = STBCC__CLUSTER_SIZE_Y;\n            break;\n         case 2:\n            dy = -1, dx = 0;\n            i = 0;\n            j = 0;\n            step_x = 1;\n            step_y = 0;\n            n = STBCC__CLUSTER_SIZE_X;\n            break;\n         case 3:\n            dy = 1, dx = 0;\n            i = 0;\n            j = STBCC__CLUSTER_SIZE_Y-1;\n            step_x = 1;\n            step_y = 0;\n            n = STBCC__CLUSTER_SIZE_X;\n            break;\n      }\n\n      if (cx+dx < 0 || cx+dx >= g->cw || cy+dy < 0 || cy+dy >= g->ch)\n         continue;\n\n      memset(connected, 0, sizeof(connected));\n      for (k=0; k < n; ++k) {\n         if (STBCC__MAP_OPEN(g, x+i, y+j) && STBCC__MAP_OPEN(g, x+i+dx, y+j+dy)) {\n            stbcc__clumpid src = g->clump_for_node[y+j][x+i];\n            stbcc__clumpid dest = g->clump_for_node[y+j+dy][x+i+dx];\n            if (0 == (connected[src][dest>>3] & (1 << (dest & 7)))) {\n               connected[src][dest>>3] |= 1 << (dest & 7);\n               ++num_adj[src];\n               ++total;\n            }\n         }\n         i += step_x;\n         j += step_y;\n      }\n   }\n\n   assert(total <= STBCC__CLUSTER_ADJACENCY_COUNT);\n\n   // decide how to apportion unused adjacency slots; only clumps that lie\n   // on the edges of the cluster need adjacency slots, so divide them up\n   // evenly between those clumps\n\n   // we want:\n   //    extra = (STBCC__CLUSTER_ADJACENCY_COUNT - total) / cluster->num_edge_clumps;\n   // but we efficiently approximate this without a divide, because\n   // ignoring edge-vs-non-edge with 'num_adj[i]*2' was faster than\n   // 'num_adj[i]+extra' with the divide\n   if      (total + (cluster->num_edge_clumps<<2) <= STBCC__CLUSTER_ADJACENCY_COUNT)\n      extra = 4;\n   else if (total + (cluster->num_edge_clumps<<1) <= STBCC__CLUSTER_ADJACENCY_COUNT)\n      extra = 2;\n   else if (total + (cluster->num_edge_clumps<<0) <= STBCC__CLUSTER_ADJACENCY_COUNT)\n      extra = 1;\n   else\n      extra = 0;\n\n   total = 0;\n   for (i=0; i < (int) cluster->num_edge_clumps; ++i) {\n      int alloc = num_adj[i]+extra;\n      if (alloc > STBCC__MAX_EXITS_PER_CLUSTER)\n         alloc = STBCC__MAX_EXITS_PER_CLUSTER;\n      assert(total < 256); // must fit in byte\n      cluster->clump[i].adjacent_clump_list_index = (unsigned char) total;\n      cluster->clump[i].max_adjacent = alloc;\n      cluster->clump[i].num_adjacent = 0;\n      total += alloc;\n   }\n   assert(total <= STBCC__CLUSTER_ADJACENCY_COUNT);\n\n   stbcc__add_connections_to_adjacent_cluster(g, cx, cy, -1, 0);\n   stbcc__add_connections_to_adjacent_cluster(g, cx, cy,  1, 0);\n   stbcc__add_connections_to_adjacent_cluster(g, cx, cy,  0,-1);\n   stbcc__add_connections_to_adjacent_cluster(g, cx, cy,  0, 1);\n   // make sure all of the above succeeded.\n   assert(g->cluster[cy][cx].rebuild_adjacency == 0);\n}\n\nstatic void stbcc__add_connections_to_adjacent_cluster_with_rebuild(stbcc_grid *g, int cx, int cy, int dx, int dy)\n{\n   if (cx >= 0 && cx < g->cw && cy >= 0 && cy < g->ch) {\n      stbcc__add_connections_to_adjacent_cluster(g, cx, cy, dx, dy);\n      if (g->cluster[cy][cx].rebuild_adjacency)\n         stbcc__build_all_connections_for_cluster(g, cx, cy);\n   }\n}\n\nvoid stbcc_update_grid(stbcc_grid *g, int x, int y, int solid)\n{\n   int cx,cy;\n\n   if (!solid) {\n      if (STBCC__MAP_OPEN(g,x,y))\n         return;\n   } else {\n      if (!STBCC__MAP_OPEN(g,x,y))\n         return;\n   }\n\n   cx = STBCC__CLUSTER_X_FOR_COORD_X(x);\n   cy = STBCC__CLUSTER_Y_FOR_COORD_Y(y);\n\n   stbcc__remove_connections_to_adjacent_cluster(g, cx-1, cy,  1, 0);\n   stbcc__remove_connections_to_adjacent_cluster(g, cx+1, cy, -1, 0);\n   stbcc__remove_connections_to_adjacent_cluster(g, cx, cy-1,  0, 1);\n   stbcc__remove_connections_to_adjacent_cluster(g, cx, cy+1,  0,-1);\n\n   if (!solid)\n      STBCC__MAP_BYTE(g,x,y) |= STBCC__MAP_BYTE_MASK(x,y);\n   else\n      STBCC__MAP_BYTE(g,x,y) &= ~STBCC__MAP_BYTE_MASK(x,y);\n\n   stbcc__build_clumps_for_cluster(g, cx, cy);\n   stbcc__build_all_connections_for_cluster(g, cx, cy);\n\n   stbcc__add_connections_to_adjacent_cluster_with_rebuild(g, cx-1, cy,  1, 0);\n   stbcc__add_connections_to_adjacent_cluster_with_rebuild(g, cx+1, cy, -1, 0);\n   stbcc__add_connections_to_adjacent_cluster_with_rebuild(g, cx, cy-1,  0, 1);\n   stbcc__add_connections_to_adjacent_cluster_with_rebuild(g, cx, cy+1,  0,-1);\n\n   if (!g->in_batched_update)\n      stbcc__build_connected_components_for_clumps(g);\n   #if 0\n   else\n      g->cluster_dirty[cy][cx] = 1;\n   #endif\n}\n\nvoid stbcc_update_batch_begin(stbcc_grid *g)\n{\n   assert(!g->in_batched_update);\n   g->in_batched_update = 1;\n}\n\nvoid stbcc_update_batch_end(stbcc_grid *g)\n{\n   assert(g->in_batched_update);\n   g->in_batched_update =  0;\n   stbcc__build_connected_components_for_clumps(g); // @OPTIMIZE: only do this if update was non-empty\n}\n\nsize_t stbcc_grid_sizeof(void)\n{\n   return sizeof(stbcc_grid);\n}\n\nvoid stbcc_init_grid(stbcc_grid *g, unsigned char *map, int w, int h)\n{\n   int i,j,k;\n   assert(w % STBCC__CLUSTER_SIZE_X == 0);\n   assert(h % STBCC__CLUSTER_SIZE_Y == 0);\n   assert(w % 8 == 0);\n\n   g->w = w;\n   g->h = h;\n   g->cw = w >> STBCC_CLUSTER_SIZE_X_LOG2;\n   g->ch = h >> STBCC_CLUSTER_SIZE_Y_LOG2;\n   g->in_batched_update = 0;\n\n   #if 0\n   for (j=0; j < STBCC__CLUSTER_COUNT_Y; ++j)\n      for (i=0; i < STBCC__CLUSTER_COUNT_X; ++i)\n         g->cluster_dirty[j][i] = 0;\n   #endif\n\n   for (j=0; j < h; ++j) {\n      for (i=0; i < w; i += 8) {\n         unsigned char c = 0;\n         for (k=0; k < 8; ++k)\n            if (map[j*w + (i+k)] == 0)\n               c |= (1 << k);\n         g->map[j][i>>3] = c;\n      }\n   }\n\n   for (j=0; j < g->ch; ++j)\n      for (i=0; i < g->cw; ++i)\n         stbcc__build_clumps_for_cluster(g, i, j);\n\n   for (j=0; j < g->ch; ++j)\n      for (i=0; i < g->cw; ++i)\n         stbcc__build_all_connections_for_cluster(g, i, j);\n\n   stbcc__build_connected_components_for_clumps(g);\n\n   for (j=0; j < g->h; ++j)\n      for (i=0; i < g->w; ++i)\n         assert(g->clump_for_node[j][i] <= STBCC__NULL_CLUMPID);\n}\n\n\nstatic void stbcc__add_clump_connection(stbcc_grid *g, int x1, int y1, int x2, int y2)\n{\n   stbcc__cluster *cluster;\n   stbcc__clump *clump;\n\n   int cx1 = STBCC__CLUSTER_X_FOR_COORD_X(x1);\n   int cy1 = STBCC__CLUSTER_Y_FOR_COORD_Y(y1);\n   int cx2 = STBCC__CLUSTER_X_FOR_COORD_X(x2);\n   int cy2 = STBCC__CLUSTER_Y_FOR_COORD_Y(y2);\n\n   stbcc__clumpid c1 = g->clump_for_node[y1][x1];\n   stbcc__clumpid c2 = g->clump_for_node[y2][x2];\n\n   stbcc__relative_clumpid rc;\n\n   assert(cx1 != cx2 || cy1 != cy2);\n   assert(abs(cx1-cx2) + abs(cy1-cy2) == 1);\n\n   // add connection to c2 in c1\n\n   rc.clump_index = c2;\n   rc.cluster_dx = x2-x1;\n   rc.cluster_dy = y2-y1;\n\n   cluster = &g->cluster[cy1][cx1];\n   clump = &cluster->clump[c1];\n   assert(clump->num_adjacent <= clump->max_adjacent);\n   if (clump->num_adjacent == clump->max_adjacent)\n      g->cluster[cy1][cx1].rebuild_adjacency = 1;\n   else {\n      stbcc__relative_clumpid *adj = &cluster->adjacency_storage[clump->adjacent_clump_list_index];\n      assert(clump->num_adjacent < STBCC__MAX_EXITS_PER_CLUMP);\n      assert(clump->adjacent_clump_list_index + clump->num_adjacent <= STBCC__CLUSTER_ADJACENCY_COUNT);\n      adj[clump->num_adjacent++] = rc;\n   }\n}\n\nstatic void stbcc__remove_clump_connection(stbcc_grid *g, int x1, int y1, int x2, int y2)\n{\n   stbcc__cluster *cluster;\n   stbcc__clump *clump;\n   stbcc__relative_clumpid *adj;\n   int i;\n\n   int cx1 = STBCC__CLUSTER_X_FOR_COORD_X(x1);\n   int cy1 = STBCC__CLUSTER_Y_FOR_COORD_Y(y1);\n   int cx2 = STBCC__CLUSTER_X_FOR_COORD_X(x2);\n   int cy2 = STBCC__CLUSTER_Y_FOR_COORD_Y(y2);\n\n   stbcc__clumpid c1 = g->clump_for_node[y1][x1];\n   stbcc__clumpid c2 = g->clump_for_node[y2][x2];\n\n   stbcc__relative_clumpid rc;\n\n   assert(cx1 != cx2 || cy1 != cy2);\n   assert(abs(cx1-cx2) + abs(cy1-cy2) == 1);\n\n   // add connection to c2 in c1\n\n   rc.clump_index = c2;\n   rc.cluster_dx = x2-x1;\n   rc.cluster_dy = y2-y1;\n\n   cluster = &g->cluster[cy1][cx1];\n   clump = &cluster->clump[c1];\n   adj = &cluster->adjacency_storage[clump->adjacent_clump_list_index];\n\n   for (i=0; i < clump->num_adjacent; ++i)\n      if (rc.clump_index == adj[i].clump_index &&\n          rc.cluster_dx  == adj[i].cluster_dx  &&\n          rc.cluster_dy  == adj[i].cluster_dy)\n         break;\n\n   if (i < clump->num_adjacent)\n      adj[i] = adj[--clump->num_adjacent];\n   else\n      assert(0);\n}\n\nstatic void stbcc__add_connections_to_adjacent_cluster(stbcc_grid *g, int cx, int cy, int dx, int dy)\n{\n   unsigned char connected[STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER][STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER/8] = { { 0 } };\n   int x = cx * STBCC__CLUSTER_SIZE_X;\n   int y = cy * STBCC__CLUSTER_SIZE_Y;\n   int step_x, step_y=0, i, j, k, n;\n\n   if (cx < 0 || cx >= g->cw || cy < 0 || cy >= g->ch)\n      return;\n\n   if (cx+dx < 0 || cx+dx >= g->cw || cy+dy < 0 || cy+dy >= g->ch)\n      return;\n\n   if (g->cluster[cy][cx].rebuild_adjacency)\n      return;\n\n   assert(abs(dx) + abs(dy) == 1);\n\n   if (dx == 1) {\n      i = STBCC__CLUSTER_SIZE_X-1;\n      j = 0;\n      step_x = 0;\n      step_y = 1;\n      n = STBCC__CLUSTER_SIZE_Y;\n   } else if (dx == -1) {\n      i = 0;\n      j = 0;\n      step_x = 0;\n      step_y = 1;\n      n = STBCC__CLUSTER_SIZE_Y;\n   } else if (dy == -1) {\n      i = 0;\n      j = 0;\n      step_x = 1;\n      step_y = 0;\n      n = STBCC__CLUSTER_SIZE_X;\n   } else if (dy == 1) {\n      i = 0;\n      j = STBCC__CLUSTER_SIZE_Y-1;\n      step_x = 1;\n      step_y = 0;\n      n = STBCC__CLUSTER_SIZE_X;\n   } else {\n      assert(0);\n      return;\n   }\n\n   for (k=0; k < n; ++k) {\n      if (STBCC__MAP_OPEN(g, x+i, y+j) && STBCC__MAP_OPEN(g, x+i+dx, y+j+dy)) {\n         stbcc__clumpid src = g->clump_for_node[y+j][x+i];\n         stbcc__clumpid dest = g->clump_for_node[y+j+dy][x+i+dx];\n         if (0 == (connected[src][dest>>3] & (1 << (dest & 7)))) {\n            assert((dest>>3) < sizeof(connected));\n            connected[src][dest>>3] |= 1 << (dest & 7);\n            stbcc__add_clump_connection(g, x+i, y+j, x+i+dx, y+j+dy);\n            if (g->cluster[cy][cx].rebuild_adjacency)\n               break;\n         }\n      }\n      i += step_x;\n      j += step_y;\n   }\n}\n\nstatic void stbcc__remove_connections_to_adjacent_cluster(stbcc_grid *g, int cx, int cy, int dx, int dy)\n{\n   unsigned char disconnected[STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER][STBCC__MAX_EDGE_CLUMPS_PER_CLUSTER/8] = { { 0 } };\n   int x = cx * STBCC__CLUSTER_SIZE_X;\n   int y = cy * STBCC__CLUSTER_SIZE_Y;\n   int step_x, step_y=0, i, j, k, n;\n\n   if (cx < 0 || cx >= g->cw || cy < 0 || cy >= g->ch)\n      return;\n\n   if (cx+dx < 0 || cx+dx >= g->cw || cy+dy < 0 || cy+dy >= g->ch)\n      return;\n\n   assert(abs(dx) + abs(dy) == 1);\n\n   if (dx == 1) {\n      i = STBCC__CLUSTER_SIZE_X-1;\n      j = 0;\n      step_x = 0;\n      step_y = 1;\n      n = STBCC__CLUSTER_SIZE_Y;\n   } else if (dx == -1) {\n      i = 0;\n      j = 0;\n      step_x = 0;\n      step_y = 1;\n      n = STBCC__CLUSTER_SIZE_Y;\n   } else if (dy == -1) {\n      i = 0;\n      j = 0;\n      step_x = 1;\n      step_y = 0;\n      n = STBCC__CLUSTER_SIZE_X;\n   } else if (dy == 1) {\n      i = 0;\n      j = STBCC__CLUSTER_SIZE_Y-1;\n      step_x = 1;\n      step_y = 0;\n      n = STBCC__CLUSTER_SIZE_X;\n   } else {\n      assert(0);\n      return;\n   }\n\n   for (k=0; k < n; ++k) {\n      if (STBCC__MAP_OPEN(g, x+i, y+j) && STBCC__MAP_OPEN(g, x+i+dx, y+j+dy)) {\n         stbcc__clumpid src = g->clump_for_node[y+j][x+i];\n         stbcc__clumpid dest = g->clump_for_node[y+j+dy][x+i+dx];\n         if (0 == (disconnected[src][dest>>3] & (1 << (dest & 7)))) {\n            disconnected[src][dest>>3] |= 1 << (dest & 7);\n            stbcc__remove_clump_connection(g, x+i, y+j, x+i+dx, y+j+dy);\n         }\n      }\n      i += step_x;\n      j += step_y;\n   }\n}\n\nstatic stbcc__tinypoint stbcc__incluster_find(stbcc__cluster_build_info *cbi, int x, int y)\n{\n   stbcc__tinypoint p,q;\n   p = cbi->parent[y][x];\n   if (p.x == x && p.y == y)\n      return p;\n   q = stbcc__incluster_find(cbi, p.x, p.y);\n   cbi->parent[y][x] = q;\n   return q;\n}\n\nstatic void stbcc__incluster_union(stbcc__cluster_build_info *cbi, int x1, int y1, int x2, int y2)\n{\n   stbcc__tinypoint p = stbcc__incluster_find(cbi, x1,y1);\n   stbcc__tinypoint q = stbcc__incluster_find(cbi, x2,y2);\n\n   if (p.x == q.x && p.y == q.y)\n      return;\n\n   cbi->parent[p.y][p.x] = q;\n}\n\nstatic void stbcc__switch_root(stbcc__cluster_build_info *cbi, int x, int y, stbcc__tinypoint p)\n{\n   cbi->parent[p.y][p.x].x = x;\n   cbi->parent[p.y][p.x].y = y;\n   cbi->parent[y][x].x = x;\n   cbi->parent[y][x].y = y;\n}\n\nstatic void stbcc__build_clumps_for_cluster(stbcc_grid *g, int cx, int cy)\n{\n   stbcc__cluster *c;\n   stbcc__cluster_build_info cbi;\n   int label=0;\n   int i,j;\n   int x = cx * STBCC__CLUSTER_SIZE_X;\n   int y = cy * STBCC__CLUSTER_SIZE_Y;\n\n   // set initial disjoint set forest state\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j) {\n      for (i=0; i < STBCC__CLUSTER_SIZE_X; ++i) {\n         cbi.parent[j][i].x = i;\n         cbi.parent[j][i].y = j;\n      }\n   }\n\n   // join all sets that are connected\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j) {\n      // check down only if not on bottom row\n      if (j < STBCC__CLUSTER_SIZE_Y-1)\n         for (i=0; i < STBCC__CLUSTER_SIZE_X; ++i)\n            if (STBCC__MAP_OPEN(g,x+i,y+j) && STBCC__MAP_OPEN(g,x+i  ,y+j+1))\n               stbcc__incluster_union(&cbi, i,j, i,j+1);\n      // check right for everything but rightmost column\n      for (i=0; i < STBCC__CLUSTER_SIZE_X-1; ++i)\n         if (STBCC__MAP_OPEN(g,x+i,y+j) && STBCC__MAP_OPEN(g,x+i+1,y+j  ))\n            stbcc__incluster_union(&cbi, i,j, i+1,j);\n   }\n\n   // label all non-empty clumps along edges so that all edge clumps are first\n   // in list; this means in degenerate case we can skip traversing non-edge clumps.\n   // because in the first pass we only label leaders, we swap the leader to the\n   // edge first\n\n   // first put solid labels on all the edges; these will get overwritten if they're open\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j)\n      cbi.label[j][0] = cbi.label[j][STBCC__CLUSTER_SIZE_X-1] = STBCC__NULL_CLUMPID;\n   for (i=0; i < STBCC__CLUSTER_SIZE_X; ++i)\n      cbi.label[0][i] = cbi.label[STBCC__CLUSTER_SIZE_Y-1][i] = STBCC__NULL_CLUMPID;\n\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j) {\n      i = 0;\n      if (STBCC__MAP_OPEN(g, x+i, y+j)) {\n         stbcc__tinypoint p = stbcc__incluster_find(&cbi, i,j);\n         if (p.x == i && p.y == j)\n            // if this is the leader, give it a label\n            cbi.label[j][i] = label++;\n         else if (!(p.x == 0 || p.x == STBCC__CLUSTER_SIZE_X-1 || p.y == 0 || p.y == STBCC__CLUSTER_SIZE_Y-1)) {\n            // if leader is in interior, promote this edge node to leader and label\n            stbcc__switch_root(&cbi, i, j, p);\n            cbi.label[j][i] = label++;\n         }\n         // else if leader is on edge, do nothing (it'll get labelled when we reach it)\n      }\n      i = STBCC__CLUSTER_SIZE_X-1;\n      if (STBCC__MAP_OPEN(g, x+i, y+j)) {\n         stbcc__tinypoint p = stbcc__incluster_find(&cbi, i,j);\n         if (p.x == i && p.y == j)\n            cbi.label[j][i] = label++;\n         else if (!(p.x == 0 || p.x == STBCC__CLUSTER_SIZE_X-1 || p.y == 0 || p.y == STBCC__CLUSTER_SIZE_Y-1)) {\n            stbcc__switch_root(&cbi, i, j, p);\n            cbi.label[j][i] = label++;\n         }\n      }\n   }\n\n   for (i=1; i < STBCC__CLUSTER_SIZE_Y-1; ++i) {\n      j = 0;\n      if (STBCC__MAP_OPEN(g, x+i, y+j)) {\n         stbcc__tinypoint p = stbcc__incluster_find(&cbi, i,j);\n         if (p.x == i && p.y == j)\n            cbi.label[j][i] = label++;\n         else if (!(p.x == 0 || p.x == STBCC__CLUSTER_SIZE_X-1 || p.y == 0 || p.y == STBCC__CLUSTER_SIZE_Y-1)) {\n            stbcc__switch_root(&cbi, i, j, p);\n            cbi.label[j][i] = label++;\n         }\n      }\n      j = STBCC__CLUSTER_SIZE_Y-1;\n      if (STBCC__MAP_OPEN(g, x+i, y+j)) {\n         stbcc__tinypoint p = stbcc__incluster_find(&cbi, i,j);\n         if (p.x == i && p.y == j)\n            cbi.label[j][i] = label++;\n         else if (!(p.x == 0 || p.x == STBCC__CLUSTER_SIZE_X-1 || p.y == 0 || p.y == STBCC__CLUSTER_SIZE_Y-1)) {\n            stbcc__switch_root(&cbi, i, j, p);\n            cbi.label[j][i] = label++;\n         }\n      }\n   }\n\n   c = &g->cluster[cy][cx];\n   c->num_edge_clumps = label;\n\n   // label any internal clusters\n   for (j=1; j < STBCC__CLUSTER_SIZE_Y-1; ++j) {\n      for (i=1; i < STBCC__CLUSTER_SIZE_X-1; ++i) {\n         stbcc__tinypoint p = cbi.parent[j][i];\n         if (p.x == i && p.y == j) {\n            if (STBCC__MAP_OPEN(g,x+i,y+j))\n               cbi.label[j][i] = label++;\n            else\n               cbi.label[j][i] = STBCC__NULL_CLUMPID;\n         }\n      }\n   }\n\n   // label all other nodes\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j) {\n      for (i=0; i < STBCC__CLUSTER_SIZE_X; ++i) {\n         stbcc__tinypoint p = stbcc__incluster_find(&cbi, i,j);\n         if (p.x != i || p.y != j) {\n            if (STBCC__MAP_OPEN(g,x+i,y+j))\n               cbi.label[j][i] = cbi.label[p.y][p.x];\n         }\n         if (STBCC__MAP_OPEN(g,x+i,y+j))\n            assert(cbi.label[j][i] != STBCC__NULL_CLUMPID);\n      }\n   }\n\n   c->num_clumps = label;\n\n   for (i=0; i < label; ++i) {\n      c->clump[i].num_adjacent = 0;\n      c->clump[i].max_adjacent = 0;\n   }\n\n   for (j=0; j < STBCC__CLUSTER_SIZE_Y; ++j)\n      for (i=0; i < STBCC__CLUSTER_SIZE_X; ++i) {\n         g->clump_for_node[y+j][x+i] = cbi.label[j][i]; // @OPTIMIZE: remove cbi.label entirely\n         assert(g->clump_for_node[y+j][x+i] <= STBCC__NULL_CLUMPID);\n      }\n\n   // set the global label for all interior clumps since they can't have connections,\n   // so we don't have to do this on the global pass (brings from O(N) to O(N^0.75))\n   for (i=(int) c->num_edge_clumps; i < (int) c->num_clumps; ++i) {\n      stbcc__global_clumpid gc;\n      gc.f.cluster_x = cx;\n      gc.f.cluster_y = cy;\n      gc.f.clump_index = i;\n      c->clump[i].global_label = gc;\n   }\n\n   c->rebuild_adjacency = 1; // flag that it has no valid adjacency data\n}\n\n#endif // STB_CONNECTED_COMPONENTS_IMPLEMENTATION\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_divide.h",
          "type": "blob",
          "size": 14.1669921875,
          "content": "// stb_divide.h - v0.94 - public domain - Sean Barrett, Feb 2010\n// Three kinds of divide/modulus of signed integers.\n//\n// HISTORY\n//\n//   v0.94              Fix integer overflow issues\n//   v0.93  2020-02-02  Write useful exit() value from main()\n//   v0.92  2019-02-25  Fix warning\n//   v0.91  2010-02-27  Fix euclidean division by INT_MIN for non-truncating C\n//                      Check result with 64-bit math to catch such cases\n//   v0.90  2010-02-24  First public release\n//\n// USAGE\n//\n// In *ONE* source file, put:\n//\n//    #define STB_DIVIDE_IMPLEMENTATION\n//    // #define C_INTEGER_DIVISION_TRUNCATES  // see Note 1\n//    // #define C_INTEGER_DIVISION_FLOORS     // see Note 2\n//    #include \"stb_divide.h\"\n//\n// Other source files should just include stb_divide.h\n//\n// Note 1: On platforms/compilers that you know signed C division\n// truncates, you can #define C_INTEGER_DIVISION_TRUNCATES.\n//\n// Note 2: On platforms/compilers that you know signed C division\n// floors (rounds to negative infinity), you can #define\n// C_INTEGER_DIVISION_FLOORS.\n//\n// You can #define STB_DIVIDE_TEST in which case the implementation\n// will generate a main() and compiling the result will create a\n// program that tests the implementation. Run it with no arguments\n// and any output indicates an error; run it with any argument and\n// it will also print the test results. Define STB_DIVIDE_TEST_64\n// to a 64-bit integer type to avoid overflows in the result-checking\n// which give false negatives.\n//\n// ABOUT\n//\n// This file provides three different consistent divide/mod pairs\n// implemented on top of arbitrary C/C++ division, including correct\n// handling of overflow of intermediate calculations:\n//\n//     trunc:   a/b truncates to 0,           a%b has same sign as a\n//     floor:   a/b truncates to -inf,        a%b has same sign as b\n//     eucl:    a/b truncates to sign(b)*inf, a%b is non-negative\n//\n// Not necessarily optimal; I tried to keep it generally efficient,\n// but there may be better ways.\n//\n// Briefly, for those who are not familiar with the problem, we note\n// the reason these divides exist and are interesting:\n//\n//     'trunc' is easy to implement in hardware (strip the signs,\n//          compute, reapply the signs), thus is commonly defined\n//          by many languages (including C99)\n//\n//     'floor' is simple to define and better behaved than trunc;\n//          for example it divides integers into fixed-size buckets\n//          without an extra-wide bucket at 0, and for a fixed\n//          divisor N there are only |N| possible moduli.\n//\n//     'eucl' guarantees fixed-sized buckets *and* a non-negative\n//          modulus and defines division to be whatever is needed\n//          to achieve that result.\n//\n// See \"The Euclidean definition of the functions div and mod\"\n// by Raymond Boute (1992), or \"Division and Modulus for Computer\n// Scientists\" by Daan Leijen (2001)\n//\n// We assume of the built-in C division:\n//     (a) modulus is the remainder for the corresponding division\n//     (b) a/b truncates if a and b are the same sign\n//\n// Property (a) requires (a/b)*b + (a%b)==a, and is required by C.\n// Property (b) seems to be true of all hardware but is *not* satisfied\n// by the euclidean division operator we define, so it's possibly not\n// always true. If any such platform turns up, we can add more cases.\n// (Possibly only stb_div_trunc currently relies on property (b).)\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n\n#ifndef INCLUDE_STB_DIVIDE_H\n#define INCLUDE_STB_DIVIDE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int stb_div_trunc(int value_to_be_divided, int value_to_divide_by);\nextern int stb_div_floor(int value_to_be_divided, int value_to_divide_by);\nextern int stb_div_eucl (int value_to_be_divided, int value_to_divide_by);\nextern int stb_mod_trunc(int value_to_be_divided, int value_to_divide_by);\nextern int stb_mod_floor(int value_to_be_divided, int value_to_divide_by);\nextern int stb_mod_eucl (int value_to_be_divided, int value_to_divide_by);\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifdef STB_DIVIDE_IMPLEMENTATION\n\n#if defined(__STDC_VERSION) && __STDC_VERSION__ >= 19901\n   #ifndef C_INTEGER_DIVISION_TRUNCATES\n      #define C_INTEGER_DIVISION_TRUNCATES\n   #endif\n#endif\n\n#ifndef INT_MIN\n#include <limits.h> // if you have no limits.h, #define INT_MIN yourself\n#endif\n\n// the following macros are designed to allow testing\n// other platforms by simulating them\n#ifndef STB_DIVIDE_TEST_FLOOR\n   #define stb__div(a,b)  ((a)/(b))\n   #define stb__mod(a,b)  ((a)%(b))\n#else\n   // implement floor-style divide on trunc platform\n   #ifndef C_INTEGER_DIVISION_TRUNCATES\n   #error \"floor test requires truncating division\"\n   #endif\n   #undef C_INTEGER_DIVISION_TRUNCATES\n   int stb__div(int v1, int v2)\n   {\n      int q = v1/v2, r = v1%v2;\n      if ((r > 0 && v2 < 0) || (r < 0 && v2 > 0))\n         return q-1;\n      else\n         return q;\n   }\n\n   int stb__mod(int v1, int v2)\n   {\n      int r = v1%v2;\n      if ((r > 0 && v2 < 0) || (r < 0 && v2 > 0))\n         return r+v2;\n      else\n         return r;\n   }\n#endif\n\nint stb_div_trunc(int v1, int v2)\n{\n   #ifdef C_INTEGER_DIVISION_TRUNCATES\n   return v1/v2;\n   #else\n   if (v1 >= 0 && v2 <= 0)\n      return -stb__div(-v1,v2);  // both negative to avoid overflow\n   if (v1 <= 0 && v2 >= 0)\n      if (v1 != INT_MIN)\n         return -stb__div(v1,-v2);    // both negative to avoid overflow\n      else\n         return -stb__div(v1+v2,-v2)-1; // push v1 away from wrap point\n   else\n      return v1/v2;            // same sign, so expect truncation\n   #endif\n}\n\nint stb_div_floor(int v1, int v2)\n{\n   #ifdef C_INTEGER_DIVISION_FLOORS\n   return v1/v2;\n   #else\n   if (v1 >= 0 && v2 < 0) {\n      if (v2 + 1 >= INT_MIN + v1) // check if increasing v1's magnitude overflows\n         return -stb__div((v2+1)-v1,v2); // nope, so just compute it\n      else\n         return -stb__div(-v1,v2) + ((-v1)%v2 ? -1 : 0);\n   }\n   if (v1 < 0 && v2 >= 0) {\n      if (v1 != INT_MIN) {\n         if (v1 + 1 >= INT_MIN + v2) // check if increasing v1's magnitude overflows\n            return -stb__div((v1+1)-v2,-v2); // nope, so just compute it\n         else\n            return -stb__div(-v1,v2) + (stb__mod(v1,-v2) ? -1 : 0);\n      } else // it must be possible to compute -(v1+v2) without overflowing\n         return -stb__div(-(v1+v2),v2) + (stb__mod(-(v1+v2),v2) ? -2 : -1);\n   } else\n      return v1/v2;           // same sign, so expect truncation\n   #endif\n}\n\nint stb_div_eucl(int v1, int v2)\n{\n   int q,r;\n   #ifdef C_INTEGER_DIVISION_TRUNCATES\n   q = v1/v2;\n   r = v1%v2;\n   #else\n   // handle every quadrant separately, since we can't rely on q and r flor\n   if (v1 >= 0)\n      if (v2 >= 0)\n         return stb__div(v1,v2);\n      else if (v2 != INT_MIN)\n         q = -stb__div(v1,-v2), r = stb__mod(v1,-v2);\n      else\n         q = 0, r = v1;\n   else if (v1 != INT_MIN)\n      if (v2 >= 0)\n         q = -stb__div(-v1,v2), r = -stb__mod(-v1,v2);\n      else if (v2 != INT_MIN)\n         q = stb__div(-v1,-v2), r = -stb__mod(-v1,-v2);\n      else // if v2 is INT_MIN, then we can't use -v2, but we can't divide by v2\n         q = 1, r = v1-q*v2;\n   else // if v1 is INT_MIN, we have to move away from overflow place\n      if (v2 >= 0)\n         q = -stb__div(-(v1+v2),v2)-1, r = -stb__mod(-(v1+v2),v2);\n      else if (v2 != INT_MIN)\n         q = stb__div(-(v1-v2),-v2)+1, r = -stb__mod(-(v1-v2),-v2);\n      else // for INT_MIN / INT_MIN, we need to be extra-careful to avoid overflow\n         q = 1, r = 0;\n   #endif\n   if (r >= 0)\n      return q;\n   else\n      return q + (v2 > 0 ? -1 : 1);\n}\n\nint stb_mod_trunc(int v1, int v2)\n{\n   #ifdef C_INTEGER_DIVISION_TRUNCATES\n   return v1%v2;\n   #else\n   if (v1 >= 0) { // modulus result should always be positive\n      int r = stb__mod(v1,v2);\n      if (r >= 0)\n         return r;\n      else\n         return r - (v2 < 0 ? v2 : -v2);\n   } else {    // modulus result should always be negative\n      int r = stb__mod(v1,v2);\n      if (r <= 0)\n         return r;\n      else\n         return r + (v2 < 0 ? v2 : -v2);\n   }\n   #endif\n}\n\nint stb_mod_floor(int v1, int v2)\n{\n   #ifdef C_INTEGER_DIVISION_FLOORS\n   return v1%v2;\n   #else\n   if (v2 >= 0) { // result should always be positive\n      int r = stb__mod(v1,v2);\n      if (r >= 0)\n         return r;\n      else\n         return r + v2;\n   } else { // result should always be negative\n      int r = stb__mod(v1,v2);\n      if (r <= 0)\n         return r;\n      else\n         return r + v2;\n   }\n   #endif\n}\n\nint stb_mod_eucl(int v1, int v2)\n{\n   int r = stb__mod(v1,v2);\n\n   if (r >= 0)\n      return r;\n   else\n      return r - (v2 < 0 ? v2 : -v2); // negative abs() [to avoid overflow]\n}\n\n#ifdef STB_DIVIDE_TEST\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n\nint show=0;\nint err=0;\n\nvoid stbdiv_check(int q, int r, int a, int b, char *type, int dir)\n{\n   if ((dir > 0 && r < 0) || (dir < 0 && r > 0)) {\n      fprintf(stderr, \"FAILED: %s(%d,%d) remainder %d in wrong direction\\n\", type,a,b,r);\n      err++;\n   } else\n      if (b != INT_MIN) // can't compute abs(), but if b==INT_MIN all remainders are valid\n         if (r <= -abs(b) || r >= abs(b)) {\n            fprintf(stderr, \"FAILED: %s(%d,%d) remainder %d out of range\\n\", type,a,b,r);\n            err++;\n         }\n   #ifdef STB_DIVIDE_TEST_64\n   {\n      STB_DIVIDE_TEST_64 q64 = q, r64=r, a64=a, b64=b;\n      if (q64*b64+r64 != a64) {\n         fprintf(stderr, \"FAILED: %s(%d,%d) remainder %d doesn't match quotient %d\\n\", type,a,b,r,q);\n         err++;\n      }\n   }\n   #else\n   if (q*b+r != a) {\n      fprintf(stderr, \"FAILED: %s(%d,%d) remainder %d doesn't match quotient %d\\n\", type,a,b,r,q);\n      err++;\n   }\n   #endif\n}\n\nvoid test(int a, int b)\n{\n   int q,r;\n   if (show) printf(\"(%+11d,%+d) |  \", a,b);\n   q = stb_div_trunc(a,b), r = stb_mod_trunc(a,b);\n   if (show) printf(\"(%+11d,%+2d)  \", q,r); stbdiv_check(q,r,a,b, \"trunc\",a);\n   q = stb_div_floor(a,b), r = stb_mod_floor(a,b);\n   if (show) printf(\"(%+11d,%+2d)  \", q,r); stbdiv_check(q,r,a,b, \"floor\",b);\n   q = stb_div_eucl (a,b), r = stb_mod_eucl (a,b);\n   if (show) printf(\"(%+11d,%+2d)\\n\", q,r); stbdiv_check(q,r,a,b, \"euclidean\",1);\n}\n\nvoid testh(int a, int b)\n{\n   int q,r;\n   if (show) printf(\"(%08x,%08x) |\\n\", a,b);\n   q = stb_div_trunc(a,b), r = stb_mod_trunc(a,b); stbdiv_check(q,r,a,b, \"trunc\",a);\n   if (show) printf(\"             (%08x,%08x)\", q,r);\n   q = stb_div_floor(a,b), r = stb_mod_floor(a,b); stbdiv_check(q,r,a,b, \"floor\",b);\n   if (show) printf(\"   (%08x,%08x)\", q,r);\n   q = stb_div_eucl (a,b), r = stb_mod_eucl (a,b); stbdiv_check(q,r,a,b, \"euclidean\",1);\n   if (show) printf(\"   (%08x,%08x)\\n \", q,r);\n}\n\nint main(int argc, char **argv)\n{\n   if (argc > 1) show=1;\n\n   test(8,3);\n   test(8,-3);\n   test(-8,3);\n   test(-8,-3);\n   test(1,2);\n   test(1,-2);\n   test(-1,2);\n   test(-1,-2);\n   test(8,4);\n   test(8,-4);\n   test(-8,4);\n   test(-8,-4);\n\n   test(INT_MAX,1);\n   test(INT_MIN,1);\n   test(INT_MIN+1,1);\n   test(INT_MAX,-1);\n   //test(INT_MIN,-1); // this traps in MSVC, so we leave it untested\n   test(INT_MIN+1,-1);\n   test(INT_MIN,-2);\n   test(INT_MIN+1,2);\n   test(INT_MIN+1,-2);\n   test(INT_MAX,2);\n   test(INT_MAX,-2);\n   test(INT_MIN+1,2);\n   test(INT_MIN+1,-2);\n   test(INT_MIN,2);\n   test(INT_MIN,-2);\n   test(INT_MIN,7);\n   test(INT_MIN,-7);\n   test(INT_MIN+1,4);\n   test(INT_MIN+1,-4);\n\n   testh(-7, INT_MIN);\n   testh(-1, INT_MIN);\n   testh(1, INT_MIN);\n   testh(7, INT_MIN);\n\n   testh(INT_MAX-1, INT_MIN);\n   testh(INT_MAX,   INT_MIN);\n   testh(INT_MIN,   INT_MIN);\n   testh(INT_MIN+1, INT_MIN);\n\n   testh(INT_MAX-1, INT_MAX);\n   testh(INT_MAX  , INT_MAX);\n   testh(INT_MIN  , INT_MAX);\n   testh(INT_MIN+1, INT_MAX);\n\n   return err > 0 ? 1 : 0;\n}\n#endif // STB_DIVIDE_TEST\n#endif // STB_DIVIDE_IMPLEMENTATION\n#endif // INCLUDE_STB_DIVIDE_H\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_ds.h",
          "type": "blob",
          "size": 67.3974609375,
          "content": "/* stb_ds.h - v0.67 - public domain data structures - Sean Barrett 2019\n\n   This is a single-header-file library that provides easy-to-use\n   dynamic arrays and hash tables for C (also works in C++).\n\n   For a gentle introduction:\n      http://nothings.org/stb_ds\n\n   To use this library, do this in *one* C or C++ file:\n      #define STB_DS_IMPLEMENTATION\n      #include \"stb_ds.h\"\n\nTABLE OF CONTENTS\n\n  Table of Contents\n  Compile-time options\n  License\n  Documentation\n  Notes\n  Notes - Dynamic arrays\n  Notes - Hash maps\n  Credits\n\nCOMPILE-TIME OPTIONS\n\n  #define STBDS_NO_SHORT_NAMES\n\n     This flag needs to be set globally.\n\n     By default stb_ds exposes shorter function names that are not qualified\n     with the \"stbds_\" prefix. If these names conflict with the names in your\n     code, define this flag.\n\n  #define STBDS_SIPHASH_2_4\n\n     This flag only needs to be set in the file containing #define STB_DS_IMPLEMENTATION.\n\n     By default stb_ds.h hashes using a weaker variant of SipHash and a custom hash for\n     4- and 8-byte keys. On 64-bit platforms, you can define the above flag to force\n     stb_ds.h to use specification-compliant SipHash-2-4 for all keys. Doing so makes\n     hash table insertion about 20% slower on 4- and 8-byte keys, 5% slower on\n     64-byte keys, and 10% slower on 256-byte keys on my test computer.\n\n  #define STBDS_REALLOC(context,ptr,size) better_realloc\n  #define STBDS_FREE(context,ptr)         better_free\n\n     These defines only need to be set in the file containing #define STB_DS_IMPLEMENTATION.\n\n     By default stb_ds uses stdlib realloc() and free() for memory management. You can\n     substitute your own functions instead by defining these symbols. You must either\n     define both, or neither. Note that at the moment, 'context' will always be NULL.\n     @TODO add an array/hash initialization function that takes a memory context pointer.\n\n  #define STBDS_UNIT_TESTS\n\n     Defines a function stbds_unit_tests() that checks the functioning of the data structures.\n\n  Note that on older versions of gcc (e.g. 5.x.x) you may need to build with '-std=c++0x'\n     (or equivalentally '-std=c++11') when using anonymous structures as seen on the web\n     page or in STBDS_UNIT_TESTS.\n\nLICENSE\n\n  Placed in the public domain and also MIT licensed.\n  See end of file for detailed license information.\n\nDOCUMENTATION\n\n  Dynamic Arrays\n\n    Non-function interface:\n\n      Declare an empty dynamic array of type T\n        T* foo = NULL;\n\n      Access the i'th item of a dynamic array 'foo' of type T, T* foo:\n        foo[i]\n\n    Functions (actually macros)\n\n      arrfree:\n        void arrfree(T*);\n          Frees the array.\n\n      arrlen:\n        ptrdiff_t arrlen(T*);\n          Returns the number of elements in the array.\n\n      arrlenu:\n        size_t arrlenu(T*);\n          Returns the number of elements in the array as an unsigned type.\n\n      arrpop:\n        T arrpop(T* a)\n          Removes the final element of the array and returns it.\n\n      arrput:\n        T arrput(T* a, T b);\n          Appends the item b to the end of array a. Returns b.\n\n      arrins:\n        T arrins(T* a, int p, T b);\n          Inserts the item b into the middle of array a, into a[p],\n          moving the rest of the array over. Returns b.\n\n      arrinsn:\n        void arrinsn(T* a, int p, int n);\n          Inserts n uninitialized items into array a starting at a[p],\n          moving the rest of the array over.\n\n      arraddnptr:\n        T* arraddnptr(T* a, int n)\n          Appends n uninitialized items onto array at the end.\n          Returns a pointer to the first uninitialized item added.\n\n      arraddnindex:\n        size_t arraddnindex(T* a, int n)\n          Appends n uninitialized items onto array at the end.\n          Returns the index of the first uninitialized item added.\n\n      arrdel:\n        void arrdel(T* a, int p);\n          Deletes the element at a[p], moving the rest of the array over.\n\n      arrdeln:\n        void arrdeln(T* a, int p, int n);\n          Deletes n elements starting at a[p], moving the rest of the array over.\n\n      arrdelswap:\n        void arrdelswap(T* a, int p);\n          Deletes the element at a[p], replacing it with the element from\n          the end of the array. O(1) performance.\n\n      arrsetlen:\n        void arrsetlen(T* a, int n);\n          Changes the length of the array to n. Allocates uninitialized\n          slots at the end if necessary.\n\n      arrsetcap:\n        size_t arrsetcap(T* a, int n);\n          Sets the length of allocated storage to at least n. It will not\n          change the length of the array.\n\n      arrcap:\n        size_t arrcap(T* a);\n          Returns the number of total elements the array can contain without\n          needing to be reallocated.\n\n  Hash maps & String hash maps\n\n    Given T is a structure type: struct { TK key; TV value; }. Note that some\n    functions do not require TV value and can have other fields. For string\n    hash maps, TK must be 'char *'.\n\n    Special interface:\n\n      stbds_rand_seed:\n        void stbds_rand_seed(size_t seed);\n          For security against adversarially chosen data, you should seed the\n          library with a strong random number. Or at least seed it with time().\n\n      stbds_hash_string:\n        size_t stbds_hash_string(char *str, size_t seed);\n          Returns a hash value for a string.\n\n      stbds_hash_bytes:\n        size_t stbds_hash_bytes(void *p, size_t len, size_t seed);\n          These functions hash an arbitrary number of bytes. The function\n          uses a custom hash for 4- and 8-byte data, and a weakened version\n          of SipHash for everything else. On 64-bit platforms you can get\n          specification-compliant SipHash-2-4 on all data by defining\n          STBDS_SIPHASH_2_4, at a significant cost in speed.\n\n    Non-function interface:\n\n      Declare an empty hash map of type T\n        T* foo = NULL;\n\n      Access the i'th entry in a hash table T* foo:\n        foo[i]\n\n    Function interface (actually macros):\n\n      hmfree\n      shfree\n        void hmfree(T*);\n        void shfree(T*);\n          Frees the hashmap and sets the pointer to NULL.\n\n      hmlen\n      shlen\n        ptrdiff_t hmlen(T*)\n        ptrdiff_t shlen(T*)\n          Returns the number of elements in the hashmap.\n\n      hmlenu\n      shlenu\n        size_t hmlenu(T*)\n        size_t shlenu(T*)\n          Returns the number of elements in the hashmap.\n\n      hmgeti\n      shgeti\n      hmgeti_ts\n        ptrdiff_t hmgeti(T*, TK key)\n        ptrdiff_t shgeti(T*, char* key)\n        ptrdiff_t hmgeti_ts(T*, TK key, ptrdiff_t tempvar)\n          Returns the index in the hashmap which has the key 'key', or -1\n          if the key is not present.\n\n      hmget\n      hmget_ts\n      shget\n        TV hmget(T*, TK key)\n        TV shget(T*, char* key)\n        TV hmget_ts(T*, TK key, ptrdiff_t tempvar)\n          Returns the value corresponding to 'key' in the hashmap.\n          The structure must have a 'value' field\n\n      hmgets\n      shgets\n        T hmgets(T*, TK key)\n        T shgets(T*, char* key)\n          Returns the structure corresponding to 'key' in the hashmap.\n\n      hmgetp\n      shgetp\n      hmgetp_ts\n      hmgetp_null\n      shgetp_null\n        T* hmgetp(T*, TK key)\n        T* shgetp(T*, char* key)\n        T* hmgetp_ts(T*, TK key, ptrdiff_t tempvar)\n        T* hmgetp_null(T*, TK key)\n        T* shgetp_null(T*, char *key)\n          Returns a pointer to the structure corresponding to 'key' in\n          the hashmap. Functions ending in \"_null\" return NULL if the key\n          is not present in the hashmap; the others return a pointer to a\n          structure holding the default value (but not the searched-for key).\n\n      hmdefault\n      shdefault\n        TV hmdefault(T*, TV value)\n        TV shdefault(T*, TV value)\n          Sets the default value for the hashmap, the value which will be\n          returned by hmget/shget if the key is not present.\n\n      hmdefaults\n      shdefaults\n        TV hmdefaults(T*, T item)\n        TV shdefaults(T*, T item)\n          Sets the default struct for the hashmap, the contents which will be\n          returned by hmgets/shgets if the key is not present.\n\n      hmput\n      shput\n        TV hmput(T*, TK key, TV value)\n        TV shput(T*, char* key, TV value)\n          Inserts a <key,value> pair into the hashmap. If the key is already\n          present in the hashmap, updates its value.\n\n      hmputs\n      shputs\n        T hmputs(T*, T item)\n        T shputs(T*, T item)\n          Inserts a struct with T.key into the hashmap. If the struct is already\n          present in the hashmap, updates it.\n\n      hmdel\n      shdel\n        int hmdel(T*, TK key)\n        int shdel(T*, char* key)\n          If 'key' is in the hashmap, deletes its entry and returns 1.\n          Otherwise returns 0.\n\n    Function interface (actually macros) for strings only:\n\n      sh_new_strdup\n        void sh_new_strdup(T*);\n          Overwrites the existing pointer with a newly allocated\n          string hashmap which will automatically allocate and free\n          each string key using realloc/free\n\n      sh_new_arena\n        void sh_new_arena(T*);\n          Overwrites the existing pointer with a newly allocated\n          string hashmap which will automatically allocate each string\n          key to a string arena. Every string key ever used by this\n          hash table remains in the arena until the arena is freed.\n          Additionally, any key which is deleted and reinserted will\n          be allocated multiple times in the string arena.\n\nNOTES\n\n  * These data structures are realloc'd when they grow, and the macro\n    \"functions\" write to the provided pointer. This means: (a) the pointer\n    must be an lvalue, and (b) the pointer to the data structure is not\n    stable, and you must maintain it the same as you would a realloc'd\n    pointer. For example, if you pass a pointer to a dynamic array to a\n    function which updates it, the function must return back the new\n    pointer to the caller. This is the price of trying to do this in C.\n\n  * The following are the only functions that are thread-safe on a single data\n    structure, i.e. can be run in multiple threads simultaneously on the same\n    data structure\n        hmlen        shlen\n        hmlenu       shlenu\n        hmget_ts     shget_ts\n        hmgeti_ts    shgeti_ts\n        hmgets_ts    shgets_ts\n\n  * You iterate over the contents of a dynamic array and a hashmap in exactly\n    the same way, using arrlen/hmlen/shlen:\n\n      for (i=0; i < arrlen(foo); ++i)\n         ... foo[i] ...\n\n  * All operations except arrins/arrdel are O(1) amortized, but individual\n    operations can be slow, so these data structures may not be suitable\n    for real time use. Dynamic arrays double in capacity as needed, so\n    elements are copied an average of once. Hash tables double/halve\n    their size as needed, with appropriate hysteresis to maintain O(1)\n    performance.\n\nNOTES - DYNAMIC ARRAY\n\n  * If you know how long a dynamic array is going to be in advance, you can avoid\n    extra memory allocations by using arrsetlen to allocate it to that length in\n    advance and use foo[n] while filling it out, or arrsetcap to allocate the memory\n    for that length and use arrput/arrpush as normal.\n\n  * Unlike some other versions of the dynamic array, this version should\n    be safe to use with strict-aliasing optimizations.\n\nNOTES - HASH MAP\n\n  * For compilers other than GCC and clang (e.g. Visual Studio), for hmput/hmget/hmdel\n    and variants, the key must be an lvalue (so the macro can take the address of it).\n    Extensions are used that eliminate this requirement if you're using C99 and later\n    in GCC or clang, or if you're using C++ in GCC. But note that this can make your\n    code less portable.\n\n  * To test for presence of a key in a hashmap, just do 'hmgeti(foo,key) >= 0'.\n\n  * The iteration order of your data in the hashmap is determined solely by the\n    order of insertions and deletions. In particular, if you never delete, new\n    keys are always added at the end of the array. This will be consistent\n    across all platforms and versions of the library. However, you should not\n    attempt to serialize the internal hash table, as the hash is not consistent\n    between different platforms, and may change with future versions of the library.\n\n  * Use sh_new_arena() for string hashmaps that you never delete from. Initialize\n    with NULL if you're managing the memory for your strings, or your strings are\n    never freed (at least until the hashmap is freed). Otherwise, use sh_new_strdup().\n    @TODO: make an arena variant that garbage collects the strings with a trivial\n    copy collector into a new arena whenever the table shrinks / rebuilds. Since\n    current arena recommendation is to only use arena if it never deletes, then\n    this can just replace current arena implementation.\n\n  * If adversarial input is a serious concern and you're on a 64-bit platform,\n    enable STBDS_SIPHASH_2_4 (see the 'Compile-time options' section), and pass\n    a strong random number to stbds_rand_seed.\n\n  * The default value for the hash table is stored in foo[-1], so if you\n    use code like 'hmget(T,k)->value = 5' you can accidentally overwrite\n    the value stored by hmdefault if 'k' is not present.\n\nCREDITS\n\n  Sean Barrett -- library, idea for dynamic array API/implementation\n  Per Vognsen  -- idea for hash table API/implementation\n  Rafael Sachetto -- arrpop()\n  github:HeroicKatora -- arraddn() reworking\n\n  Bugfixes:\n    Andy Durdin\n    Shane Liesegang\n    Vinh Truong\n    Andreas Molzer\n    github:hashitaku\n    github:srdjanstipic\n    Macoy Madson\n    Andreas Vennstrom\n    Tobias Mansfield-Williams\n*/\n\n#ifdef STBDS_UNIT_TESTS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef INCLUDE_STB_DS_H\n#define INCLUDE_STB_DS_H\n\n#include <stddef.h>\n#include <string.h>\n\n#ifndef STBDS_NO_SHORT_NAMES\n#define arrlen      stbds_arrlen\n#define arrlenu     stbds_arrlenu\n#define arrput      stbds_arrput\n#define arrpush     stbds_arrput\n#define arrpop      stbds_arrpop\n#define arrfree     stbds_arrfree\n#define arraddn     stbds_arraddn // deprecated, use one of the following instead:\n#define arraddnptr  stbds_arraddnptr\n#define arraddnindex stbds_arraddnindex\n#define arrsetlen   stbds_arrsetlen\n#define arrlast     stbds_arrlast\n#define arrins      stbds_arrins\n#define arrinsn     stbds_arrinsn\n#define arrdel      stbds_arrdel\n#define arrdeln     stbds_arrdeln\n#define arrdelswap  stbds_arrdelswap\n#define arrcap      stbds_arrcap\n#define arrsetcap   stbds_arrsetcap\n\n#define hmput       stbds_hmput\n#define hmputs      stbds_hmputs\n#define hmget       stbds_hmget\n#define hmget_ts    stbds_hmget_ts\n#define hmgets      stbds_hmgets\n#define hmgetp      stbds_hmgetp\n#define hmgetp_ts   stbds_hmgetp_ts\n#define hmgetp_null stbds_hmgetp_null\n#define hmgeti      stbds_hmgeti\n#define hmgeti_ts   stbds_hmgeti_ts\n#define hmdel       stbds_hmdel\n#define hmlen       stbds_hmlen\n#define hmlenu      stbds_hmlenu\n#define hmfree      stbds_hmfree\n#define hmdefault   stbds_hmdefault\n#define hmdefaults  stbds_hmdefaults\n\n#define shput       stbds_shput\n#define shputi      stbds_shputi\n#define shputs      stbds_shputs\n#define shget       stbds_shget\n#define shgeti      stbds_shgeti\n#define shgets      stbds_shgets\n#define shgetp      stbds_shgetp\n#define shgetp_null stbds_shgetp_null\n#define shdel       stbds_shdel\n#define shlen       stbds_shlen\n#define shlenu      stbds_shlenu\n#define shfree      stbds_shfree\n#define shdefault   stbds_shdefault\n#define shdefaults  stbds_shdefaults\n#define sh_new_arena  stbds_sh_new_arena\n#define sh_new_strdup stbds_sh_new_strdup\n\n#define stralloc    stbds_stralloc\n#define strreset    stbds_strreset\n#endif\n\n#if defined(STBDS_REALLOC) && !defined(STBDS_FREE) || !defined(STBDS_REALLOC) && defined(STBDS_FREE)\n#error \"You must define both STBDS_REALLOC and STBDS_FREE, or neither.\"\n#endif\n#if !defined(STBDS_REALLOC) && !defined(STBDS_FREE)\n#include <stdlib.h>\n#define STBDS_REALLOC(c,p,s) realloc(p,s)\n#define STBDS_FREE(c,p)      free(p)\n#endif\n\n#ifdef _MSC_VER\n#define STBDS_NOTUSED(v)  (void)(v)\n#else\n#define STBDS_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// for security against attackers, seed the library with a random number, at least time() but stronger is better\nextern void stbds_rand_seed(size_t seed);\n\n// these are the hash functions used internally if you want to test them or use them for other purposes\nextern size_t stbds_hash_bytes(void *p, size_t len, size_t seed);\nextern size_t stbds_hash_string(char *str, size_t seed);\n\n// this is a simple string arena allocator, initialize with e.g. 'stbds_string_arena my_arena={0}'.\ntypedef struct stbds_string_arena stbds_string_arena;\nextern char * stbds_stralloc(stbds_string_arena *a, char *str);\nextern void   stbds_strreset(stbds_string_arena *a);\n\n// have to #define STBDS_UNIT_TESTS to call this\nextern void stbds_unit_tests(void);\n\n///////////////\n//\n// Everything below here is implementation details\n//\n\nextern void * stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap);\nextern void   stbds_arrfreef(void *a);\nextern void   stbds_hmfree_func(void *p, size_t elemsize);\nextern void * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);\nextern void * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode);\nextern void * stbds_hmput_default(void *a, size_t elemsize);\nextern void * stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);\nextern void * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode);\nextern void * stbds_shmode_func(size_t elemsize, int mode);\n\n#ifdef __cplusplus\n}\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n#define STBDS_HAS_TYPEOF\n#ifdef __cplusplus\n//#define STBDS_HAS_LITERAL_ARRAY  // this is currently broken for clang\n#endif\n#endif\n\n#if !defined(__cplusplus)\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n#define STBDS_HAS_LITERAL_ARRAY\n#endif\n#endif\n\n// this macro takes the address of the argument, but on gcc/clang can accept rvalues\n#if defined(STBDS_HAS_LITERAL_ARRAY) && defined(STBDS_HAS_TYPEOF)\n  #if __clang__\n  #define STBDS_ADDRESSOF(typevar, value)     ((__typeof__(typevar)[1]){value}) // literal array decays to pointer to value\n  #else\n  #define STBDS_ADDRESSOF(typevar, value)     ((typeof(typevar)[1]){value}) // literal array decays to pointer to value\n  #endif\n#else\n#define STBDS_ADDRESSOF(typevar, value)     &(value)\n#endif\n\n#define STBDS_OFFSETOF(var,field)           ((char *) &(var)->field - (char *) (var))\n\n#define stbds_header(t)  ((stbds_array_header *) (t) - 1)\n#define stbds_temp(t)    stbds_header(t)->temp\n#define stbds_temp_key(t) (*(char **) stbds_header(t)->hash_table)\n\n#define stbds_arrsetcap(a,n)   (stbds_arrgrow(a,0,n))\n#define stbds_arrsetlen(a,n)   ((stbds_arrcap(a) < (size_t) (n) ? stbds_arrsetcap((a),(size_t)(n)),0 : 0), (a) ? stbds_header(a)->length = (size_t) (n) : 0)\n#define stbds_arrcap(a)        ((a) ? stbds_header(a)->capacity : 0)\n#define stbds_arrlen(a)        ((a) ? (ptrdiff_t) stbds_header(a)->length : 0)\n#define stbds_arrlenu(a)       ((a) ?             stbds_header(a)->length : 0)\n#define stbds_arrput(a,v)      (stbds_arrmaybegrow(a,1), (a)[stbds_header(a)->length++] = (v))\n#define stbds_arrpush          stbds_arrput  // synonym\n#define stbds_arrpop(a)        (stbds_header(a)->length--, (a)[stbds_header(a)->length])\n#define stbds_arraddn(a,n)     ((void)(stbds_arraddnindex(a, n)))    // deprecated, use one of the following instead:\n#define stbds_arraddnptr(a,n)  (stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), &(a)[stbds_header(a)->length-(n)]) : (a))\n#define stbds_arraddnindex(a,n)(stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), stbds_header(a)->length-(n)) : stbds_arrlen(a))\n#define stbds_arraddnoff       stbds_arraddnindex\n#define stbds_arrlast(a)       ((a)[stbds_header(a)->length-1])\n#define stbds_arrfree(a)       ((void) ((a) ? STBDS_FREE(NULL,stbds_header(a)) : (void)0), (a)=NULL)\n#define stbds_arrdel(a,i)      stbds_arrdeln(a,i,1)\n#define stbds_arrdeln(a,i,n)   (memmove(&(a)[i], &(a)[(i)+(n)], sizeof *(a) * (stbds_header(a)->length-(n)-(i))), stbds_header(a)->length -= (n))\n#define stbds_arrdelswap(a,i)  ((a)[i] = stbds_arrlast(a), stbds_header(a)->length -= 1)\n#define stbds_arrinsn(a,i,n)   (stbds_arraddn((a),(n)), memmove(&(a)[(i)+(n)], &(a)[i], sizeof *(a) * (stbds_header(a)->length-(n)-(i))))\n#define stbds_arrins(a,i,v)    (stbds_arrinsn((a),(i),1), (a)[i]=(v))\n\n#define stbds_arrmaybegrow(a,n)  ((!(a) || stbds_header(a)->length + (n) > stbds_header(a)->capacity) \\\n                                  ? (stbds_arrgrow(a,n,0),0) : 0)\n\n#define stbds_arrgrow(a,b,c)   ((a) = stbds_arrgrowf_wrapper((a), sizeof *(a), (b), (c)))\n\n#define stbds_hmput(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, 0),   \\\n     (t)[stbds_temp((t)-1)].key = (k),    \\\n     (t)[stbds_temp((t)-1)].value = (v))\n\n#define stbds_hmputs(t, s) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), &(s).key, sizeof (s).key, STBDS_HM_BINARY), \\\n     (t)[stbds_temp((t)-1)] = (s))\n\n#define stbds_hmgeti(t,k) \\\n    ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_HM_BINARY), \\\n      stbds_temp((t)-1))\n\n#define stbds_hmgeti_ts(t,k,temp) \\\n    ((t) = stbds_hmget_key_ts_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, &(temp), STBDS_HM_BINARY), \\\n      (temp))\n\n#define stbds_hmgetp(t, k) \\\n    ((void) stbds_hmgeti(t,k), &(t)[stbds_temp((t)-1)])\n\n#define stbds_hmgetp_ts(t, k, temp) \\\n    ((void) stbds_hmgeti_ts(t,k,temp), &(t)[temp])\n\n#define stbds_hmdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_BINARY)),(t)?stbds_temp((t)-1):0)\n\n#define stbds_hmdefault(t, v) \\\n    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1].value = (v))\n\n#define stbds_hmdefaults(t, s) \\\n    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1] = (s))\n\n#define stbds_hmfree(p)        \\\n    ((void) ((p) != NULL ? stbds_hmfree_func((p)-1,sizeof*(p)),0 : 0),(p)=NULL)\n\n#define stbds_hmgets(t, k)    (*stbds_hmgetp(t,k))\n#define stbds_hmget(t, k)     (stbds_hmgetp(t,k)->value)\n#define stbds_hmget_ts(t, k, temp)  (stbds_hmgetp_ts(t,k,temp)->value)\n#define stbds_hmlen(t)        ((t) ? (ptrdiff_t) stbds_header((t)-1)->length-1 : 0)\n#define stbds_hmlenu(t)       ((t) ?             stbds_header((t)-1)->length-1 : 0)\n#define stbds_hmgetp_null(t,k)  (stbds_hmgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])\n\n#define stbds_shput(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \\\n     (t)[stbds_temp((t)-1)].value = (v))\n\n#define stbds_shputi(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \\\n     (t)[stbds_temp((t)-1)].value = (v), stbds_temp((t)-1))\n\n#define stbds_shputs(t, s) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (s).key, sizeof (s).key, STBDS_HM_STRING), \\\n     (t)[stbds_temp((t)-1)] = (s), \\\n     (t)[stbds_temp((t)-1)].key = stbds_temp_key((t)-1)) // above line overwrites whole structure, so must rewrite key here if it was allocated internally\n\n#define stbds_pshput(t, p) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (p)->key, sizeof (p)->key, STBDS_HM_PTR_TO_STRING), \\\n     (t)[stbds_temp((t)-1)] = (p))\n\n#define stbds_shgeti(t,k) \\\n     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING), \\\n      stbds_temp((t)-1))\n\n#define stbds_pshgeti(t,k) \\\n     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_HM_PTR_TO_STRING), \\\n      stbds_temp((t)-1))\n\n#define stbds_shgetp(t, k) \\\n    ((void) stbds_shgeti(t,k), &(t)[stbds_temp((t)-1)])\n\n#define stbds_pshget(t, k) \\\n    ((void) stbds_pshgeti(t,k), (t)[stbds_temp((t)-1)])\n\n#define stbds_shdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_STRING)),(t)?stbds_temp((t)-1):0)\n#define stbds_pshdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_OFFSETOF(*(t),key), STBDS_HM_PTR_TO_STRING)),(t)?stbds_temp((t)-1):0)\n\n#define stbds_sh_new_arena(t)  \\\n    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_ARENA))\n#define stbds_sh_new_strdup(t) \\\n    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_STRDUP))\n\n#define stbds_shdefault(t, v)  stbds_hmdefault(t,v)\n#define stbds_shdefaults(t, s) stbds_hmdefaults(t,s)\n\n#define stbds_shfree       stbds_hmfree\n#define stbds_shlenu       stbds_hmlenu\n\n#define stbds_shgets(t, k) (*stbds_shgetp(t,k))\n#define stbds_shget(t, k)  (stbds_shgetp(t,k)->value)\n#define stbds_shgetp_null(t,k)  (stbds_shgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])\n#define stbds_shlen        stbds_hmlen\n\ntypedef struct\n{\n  size_t      length;\n  size_t      capacity;\n  void      * hash_table;\n  ptrdiff_t   temp;\n} stbds_array_header;\n\ntypedef struct stbds_string_block\n{\n  struct stbds_string_block *next;\n  char storage[8];\n} stbds_string_block;\n\nstruct stbds_string_arena\n{\n  stbds_string_block *storage;\n  size_t remaining;\n  unsigned char block;\n  unsigned char mode;  // this isn't used by the string arena itself\n};\n\n#define STBDS_HM_BINARY         0\n#define STBDS_HM_STRING         1\n\nenum\n{\n   STBDS_SH_NONE,\n   STBDS_SH_DEFAULT,\n   STBDS_SH_STRDUP,\n   STBDS_SH_ARENA\n};\n\n#ifdef __cplusplus\n// in C we use implicit assignment from these void*-returning functions to T*.\n// in C++ these templates make the same code work\ntemplate<class T> static T * stbds_arrgrowf_wrapper(T *a, size_t elemsize, size_t addlen, size_t min_cap) {\n  return (T*)stbds_arrgrowf((void *)a, elemsize, addlen, min_cap);\n}\ntemplate<class T> static T * stbds_hmget_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {\n  return (T*)stbds_hmget_key((void*)a, elemsize, key, keysize, mode);\n}\ntemplate<class T> static T * stbds_hmget_key_ts_wrapper(T *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode) {\n  return (T*)stbds_hmget_key_ts((void*)a, elemsize, key, keysize, temp, mode);\n}\ntemplate<class T> static T * stbds_hmput_default_wrapper(T *a, size_t elemsize) {\n  return (T*)stbds_hmput_default((void *)a, elemsize);\n}\ntemplate<class T> static T * stbds_hmput_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {\n  return (T*)stbds_hmput_key((void*)a, elemsize, key, keysize, mode);\n}\ntemplate<class T> static T * stbds_hmdel_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode){\n  return (T*)stbds_hmdel_key((void*)a, elemsize, key, keysize, keyoffset, mode);\n}\ntemplate<class T> static T * stbds_shmode_func_wrapper(T *, size_t elemsize, int mode) {\n  return (T*)stbds_shmode_func(elemsize, mode);\n}\n#else\n#define stbds_arrgrowf_wrapper            stbds_arrgrowf\n#define stbds_hmget_key_wrapper           stbds_hmget_key\n#define stbds_hmget_key_ts_wrapper        stbds_hmget_key_ts\n#define stbds_hmput_default_wrapper       stbds_hmput_default\n#define stbds_hmput_key_wrapper           stbds_hmput_key\n#define stbds_hmdel_key_wrapper           stbds_hmdel_key\n#define stbds_shmode_func_wrapper(t,e,m)  stbds_shmode_func(e,m)\n#endif\n\n#endif // INCLUDE_STB_DS_H\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//   IMPLEMENTATION\n//\n\n#ifdef STB_DS_IMPLEMENTATION\n#include <assert.h>\n#include <string.h>\n\n#ifndef STBDS_ASSERT\n#define STBDS_ASSERT_WAS_UNDEFINED\n#define STBDS_ASSERT(x)   ((void) 0)\n#endif\n\n#ifdef STBDS_STATISTICS\n#define STBDS_STATS(x)   x\nsize_t stbds_array_grow;\nsize_t stbds_hash_grow;\nsize_t stbds_hash_shrink;\nsize_t stbds_hash_rebuild;\nsize_t stbds_hash_probes;\nsize_t stbds_hash_alloc;\nsize_t stbds_rehash_probes;\nsize_t stbds_rehash_items;\n#else\n#define STBDS_STATS(x)\n#endif\n\n//\n// stbds_arr implementation\n//\n\n//int *prev_allocs[65536];\n//int num_prev;\n\nvoid *stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap)\n{\n  stbds_array_header temp={0}; // force debugging\n  void *b;\n  size_t min_len = stbds_arrlen(a) + addlen;\n  (void) sizeof(temp);\n\n  // compute the minimum capacity needed\n  if (min_len > min_cap)\n    min_cap = min_len;\n\n  if (min_cap <= stbds_arrcap(a))\n    return a;\n\n  // increase needed capacity to guarantee O(1) amortized\n  if (min_cap < 2 * stbds_arrcap(a))\n    min_cap = 2 * stbds_arrcap(a);\n  else if (min_cap < 4)\n    min_cap = 4;\n\n  //if (num_prev < 65536) if (a) prev_allocs[num_prev++] = (int *) ((char *) a+1);\n  //if (num_prev == 2201)\n  //  num_prev = num_prev;\n  b = STBDS_REALLOC(NULL, (a) ? stbds_header(a) : 0, elemsize * min_cap + sizeof(stbds_array_header));\n  //if (num_prev < 65536) prev_allocs[num_prev++] = (int *) (char *) b;\n  b = (char *) b + sizeof(stbds_array_header);\n  if (a == NULL) {\n    stbds_header(b)->length = 0;\n    stbds_header(b)->hash_table = 0;\n    stbds_header(b)->temp = 0;\n  } else {\n    STBDS_STATS(++stbds_array_grow);\n  }\n  stbds_header(b)->capacity = min_cap;\n\n  return b;\n}\n\nvoid stbds_arrfreef(void *a)\n{\n  STBDS_FREE(NULL, stbds_header(a));\n}\n\n//\n// stbds_hm hash table implementation\n//\n\n#ifdef STBDS_INTERNAL_SMALL_BUCKET\n#define STBDS_BUCKET_LENGTH      4\n#else\n#define STBDS_BUCKET_LENGTH      8\n#endif\n\n#define STBDS_BUCKET_SHIFT      (STBDS_BUCKET_LENGTH == 8 ? 3 : 2)\n#define STBDS_BUCKET_MASK       (STBDS_BUCKET_LENGTH-1)\n#define STBDS_CACHE_LINE_SIZE   64\n\n#define STBDS_ALIGN_FWD(n,a)   (((n) + (a) - 1) & ~((a)-1))\n\ntypedef struct\n{\n   size_t    hash [STBDS_BUCKET_LENGTH];\n   ptrdiff_t index[STBDS_BUCKET_LENGTH];\n} stbds_hash_bucket; // in 32-bit, this is one 64-byte cache line; in 64-bit, each array is one 64-byte cache line\n\ntypedef struct\n{\n  char * temp_key; // this MUST be the first field of the hash table\n  size_t slot_count;\n  size_t used_count;\n  size_t used_count_threshold;\n  size_t used_count_shrink_threshold;\n  size_t tombstone_count;\n  size_t tombstone_count_threshold;\n  size_t seed;\n  size_t slot_count_log2;\n  stbds_string_arena string;\n  stbds_hash_bucket *storage; // not a separate allocation, just 64-byte aligned storage after this struct\n} stbds_hash_index;\n\n#define STBDS_INDEX_EMPTY    -1\n#define STBDS_INDEX_DELETED  -2\n#define STBDS_INDEX_IN_USE(x)  ((x) >= 0)\n\n#define STBDS_HASH_EMPTY      0\n#define STBDS_HASH_DELETED    1\n\nstatic size_t stbds_hash_seed=0x31415926;\n\nvoid stbds_rand_seed(size_t seed)\n{\n  stbds_hash_seed = seed;\n}\n\n#define stbds_load_32_or_64(var, temp, v32, v64_hi, v64_lo)                                          \\\n  temp = v64_lo ^ v32, temp <<= 16, temp <<= 16, temp >>= 16, temp >>= 16, /* discard if 32-bit */   \\\n  var = v64_hi, var <<= 16, var <<= 16,                                    /* discard if 32-bit */   \\\n  var ^= temp ^ v32\n\n#define STBDS_SIZE_T_BITS           ((sizeof (size_t)) * 8)\n\nstatic size_t stbds_probe_position(size_t hash, size_t slot_count, size_t slot_log2)\n{\n  size_t pos;\n  STBDS_NOTUSED(slot_log2);\n  pos = hash & (slot_count-1);\n  #ifdef STBDS_INTERNAL_BUCKET_START\n  pos &= ~STBDS_BUCKET_MASK;\n  #endif\n  return pos;\n}\n\nstatic size_t stbds_log2(size_t slot_count)\n{\n  size_t n=0;\n  while (slot_count > 1) {\n    slot_count >>= 1;\n    ++n;\n  }\n  return n;\n}\n\nstatic stbds_hash_index *stbds_make_hash_index(size_t slot_count, stbds_hash_index *ot)\n{\n  stbds_hash_index *t;\n  t = (stbds_hash_index *) STBDS_REALLOC(NULL,0,(slot_count >> STBDS_BUCKET_SHIFT) * sizeof(stbds_hash_bucket) + sizeof(stbds_hash_index) + STBDS_CACHE_LINE_SIZE-1);\n  t->storage = (stbds_hash_bucket *) STBDS_ALIGN_FWD((size_t) (t+1), STBDS_CACHE_LINE_SIZE);\n  t->slot_count = slot_count;\n  t->slot_count_log2 = stbds_log2(slot_count);\n  t->tombstone_count = 0;\n  t->used_count = 0;\n\n  #if 0 // A1\n  t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink\n  #elif 1 // A2\n  //t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow\n  //t->tombstone_count_threshold   = slot_count* 3/16; // if tombstones are 3/16th of table, rebuild\n  //t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink\n\n  // compute without overflowing\n  t->used_count_threshold        = slot_count - (slot_count>>2);\n  t->tombstone_count_threshold   = (slot_count>>3) + (slot_count>>4);\n  t->used_count_shrink_threshold = slot_count >> 2;\n\n  #elif 0 // B1\n  t->used_count_threshold        = slot_count*13/16; // if 13/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 5/16; // if table is only 5/16th full, shrink\n  #else // C1\n  t->used_count_threshold        = slot_count*14/16; // if 14/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 6/16; // if table is only 6/16th full, shrink\n  #endif\n  // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2\n    // Note that the larger tables have high variance as they were run fewer times\n  //     A1            A2          B1           C1\n  //    0.10ms :     0.10ms :     0.10ms :     0.11ms :      2,000 inserts creating 2K table\n  //    0.96ms :     0.95ms :     0.97ms :     1.04ms :     20,000 inserts creating 20K table\n  //   14.48ms :    14.46ms :    10.63ms :    11.00ms :    200,000 inserts creating 200K table\n  //  195.74ms :   196.35ms :   203.69ms :   214.92ms :  2,000,000 inserts creating 2M table\n  // 2193.88ms :  2209.22ms :  2285.54ms :  2437.17ms : 20,000,000 inserts creating 20M table\n  //   65.27ms :    53.77ms :    65.33ms :    65.47ms : 500,000 inserts & deletes in 2K table\n  //   72.78ms :    62.45ms :    71.95ms :    72.85ms : 500,000 inserts & deletes in 20K table\n  //   89.47ms :    77.72ms :    96.49ms :    96.75ms : 500,000 inserts & deletes in 200K table\n  //   97.58ms :    98.14ms :    97.18ms :    97.53ms : 500,000 inserts & deletes in 2M table\n  //  118.61ms :   119.62ms :   120.16ms :   118.86ms : 500,000 inserts & deletes in 20M table\n  //  192.11ms :   194.39ms :   196.38ms :   195.73ms : 500,000 inserts & deletes in 200M table\n\n  if (slot_count <= STBDS_BUCKET_LENGTH)\n    t->used_count_shrink_threshold = 0;\n  // to avoid infinite loop, we need to guarantee that at least one slot is empty and will terminate probes\n  STBDS_ASSERT(t->used_count_threshold + t->tombstone_count_threshold < t->slot_count);\n  STBDS_STATS(++stbds_hash_alloc);\n  if (ot) {\n    t->string = ot->string;\n    // reuse old seed so we can reuse old hashes so below \"copy out old data\" doesn't do any hashing\n    t->seed = ot->seed;\n  } else {\n    size_t a,b,temp;\n    memset(&t->string, 0, sizeof(t->string));\n    t->seed = stbds_hash_seed;\n    // LCG\n    // in 32-bit, a =          2147001325   b =  715136305\n    // in 64-bit, a = 2862933555777941757   b = 3037000493\n    stbds_load_32_or_64(a,temp, 2147001325, 0x27bb2ee6, 0x87b0b0fd);\n    stbds_load_32_or_64(b,temp,  715136305,          0, 0xb504f32d);\n    stbds_hash_seed = stbds_hash_seed  * a + b;\n  }\n\n  {\n    size_t i,j;\n    for (i=0; i < slot_count >> STBDS_BUCKET_SHIFT; ++i) {\n      stbds_hash_bucket *b = &t->storage[i];\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j)\n        b->hash[j] = STBDS_HASH_EMPTY;\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j)\n        b->index[j] = STBDS_INDEX_EMPTY;\n    }\n  }\n\n  // copy out the old data, if any\n  if (ot) {\n    size_t i,j;\n    t->used_count = ot->used_count;\n    for (i=0; i < ot->slot_count >> STBDS_BUCKET_SHIFT; ++i) {\n      stbds_hash_bucket *ob = &ot->storage[i];\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j) {\n        if (STBDS_INDEX_IN_USE(ob->index[j])) {\n          size_t hash = ob->hash[j];\n          size_t pos = stbds_probe_position(hash, t->slot_count, t->slot_count_log2);\n          size_t step = STBDS_BUCKET_LENGTH;\n          STBDS_STATS(++stbds_rehash_items);\n          for (;;) {\n            size_t limit,z;\n            stbds_hash_bucket *bucket;\n            bucket = &t->storage[pos >> STBDS_BUCKET_SHIFT];\n            STBDS_STATS(++stbds_rehash_probes);\n\n            for (z=pos & STBDS_BUCKET_MASK; z < STBDS_BUCKET_LENGTH; ++z) {\n              if (bucket->hash[z] == 0) {\n                bucket->hash[z] = hash;\n                bucket->index[z] = ob->index[j];\n                goto done;\n              }\n            }\n\n            limit = pos & STBDS_BUCKET_MASK;\n            for (z = 0; z < limit; ++z) {\n              if (bucket->hash[z] == 0) {\n                bucket->hash[z] = hash;\n                bucket->index[z] = ob->index[j];\n                goto done;\n              }\n            }\n\n            pos += step;                  // quadratic probing\n            step += STBDS_BUCKET_LENGTH;\n            pos &= (t->slot_count-1);\n          }\n        }\n       done:\n        ;\n      }\n    }\n  }\n\n  return t;\n}\n\n#define STBDS_ROTATE_LEFT(val, n)   (((val) << (n)) | ((val) >> (STBDS_SIZE_T_BITS - (n))))\n#define STBDS_ROTATE_RIGHT(val, n)  (((val) >> (n)) | ((val) << (STBDS_SIZE_T_BITS - (n))))\n\nsize_t stbds_hash_string(char *str, size_t seed)\n{\n  size_t hash = seed;\n  while (*str)\n     hash = STBDS_ROTATE_LEFT(hash, 9) + (unsigned char) *str++;\n\n  // Thomas Wang 64-to-32 bit mix function, hopefully also works in 32 bits\n  hash ^= seed;\n  hash = (~hash) + (hash << 18);\n  hash ^= hash ^ STBDS_ROTATE_RIGHT(hash,31);\n  hash = hash * 21;\n  hash ^= hash ^ STBDS_ROTATE_RIGHT(hash,11);\n  hash += (hash << 6);\n  hash ^= STBDS_ROTATE_RIGHT(hash,22);\n  return hash+seed;\n}\n\n#ifdef STBDS_SIPHASH_2_4\n#define STBDS_SIPHASH_C_ROUNDS 2\n#define STBDS_SIPHASH_D_ROUNDS 4\ntypedef int STBDS_SIPHASH_2_4_can_only_be_used_in_64_bit_builds[sizeof(size_t) == 8 ? 1 : -1];\n#endif\n\n#ifndef STBDS_SIPHASH_C_ROUNDS\n#define STBDS_SIPHASH_C_ROUNDS 1\n#endif\n#ifndef STBDS_SIPHASH_D_ROUNDS\n#define STBDS_SIPHASH_D_ROUNDS 1\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable:4127) // conditional expression is constant, for do..while(0) and sizeof()==\n#endif\n\nstatic size_t stbds_siphash_bytes(void *p, size_t len, size_t seed)\n{\n  unsigned char *d = (unsigned char *) p;\n  size_t i,j;\n  size_t v0,v1,v2,v3, data;\n\n  // hash that works on 32- or 64-bit registers without knowing which we have\n  // (computes different results on 32-bit and 64-bit platform)\n  // derived from siphash, but on 32-bit platforms very different as it uses 4 32-bit state not 4 64-bit\n  v0 = ((((size_t) 0x736f6d65 << 16) << 16) + 0x70736575) ^  seed;\n  v1 = ((((size_t) 0x646f7261 << 16) << 16) + 0x6e646f6d) ^ ~seed;\n  v2 = ((((size_t) 0x6c796765 << 16) << 16) + 0x6e657261) ^  seed;\n  v3 = ((((size_t) 0x74656462 << 16) << 16) + 0x79746573) ^ ~seed;\n\n  #ifdef STBDS_TEST_SIPHASH_2_4\n  // hardcoded with key material in the siphash test vectors\n  v0 ^= 0x0706050403020100ull ^  seed;\n  v1 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;\n  v2 ^= 0x0706050403020100ull ^  seed;\n  v3 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;\n  #endif\n\n  #define STBDS_SIPROUND() \\\n    do {                   \\\n      v0 += v1; v1 = STBDS_ROTATE_LEFT(v1, 13);  v1 ^= v0; v0 = STBDS_ROTATE_LEFT(v0,STBDS_SIZE_T_BITS/2); \\\n      v2 += v3; v3 = STBDS_ROTATE_LEFT(v3, 16);  v3 ^= v2;                                                 \\\n      v2 += v1; v1 = STBDS_ROTATE_LEFT(v1, 17);  v1 ^= v2; v2 = STBDS_ROTATE_LEFT(v2,STBDS_SIZE_T_BITS/2); \\\n      v0 += v3; v3 = STBDS_ROTATE_LEFT(v3, 21);  v3 ^= v0;                                                 \\\n    } while (0)\n\n  for (i=0; i+sizeof(size_t) <= len; i += sizeof(size_t), d += sizeof(size_t)) {\n    data = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    data |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // discarded if size_t == 4\n\n    v3 ^= data;\n    for (j=0; j < STBDS_SIPHASH_C_ROUNDS; ++j)\n      STBDS_SIPROUND();\n    v0 ^= data;\n  }\n  data = len << (STBDS_SIZE_T_BITS-8);\n  switch (len - i) {\n    case 7: data |= ((size_t) d[6] << 24) << 24; // fall through\n    case 6: data |= ((size_t) d[5] << 20) << 20; // fall through\n    case 5: data |= ((size_t) d[4] << 16) << 16; // fall through\n    case 4: data |= (d[3] << 24); // fall through\n    case 3: data |= (d[2] << 16); // fall through\n    case 2: data |= (d[1] << 8); // fall through\n    case 1: data |= d[0]; // fall through\n    case 0: break;\n  }\n  v3 ^= data;\n  for (j=0; j < STBDS_SIPHASH_C_ROUNDS; ++j)\n    STBDS_SIPROUND();\n  v0 ^= data;\n  v2 ^= 0xff;\n  for (j=0; j < STBDS_SIPHASH_D_ROUNDS; ++j)\n    STBDS_SIPROUND();\n\n#ifdef STBDS_SIPHASH_2_4\n  return v0^v1^v2^v3;\n#else\n  return v1^v2^v3; // slightly stronger since v0^v3 in above cancels out final round operation? I tweeted at the authors of SipHash about this but they didn't reply\n#endif\n}\n\nsize_t stbds_hash_bytes(void *p, size_t len, size_t seed)\n{\n#ifdef STBDS_SIPHASH_2_4\n  return stbds_siphash_bytes(p,len,seed);\n#else\n  unsigned char *d = (unsigned char *) p;\n\n  if (len == 4) {\n    unsigned int hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    #if 0\n    // HASH32-A  Bob Jenkin's hash function w/o large constants\n    hash ^= seed;\n    hash -= (hash<<6);\n    hash ^= (hash>>17);\n    hash -= (hash<<9);\n    hash ^= seed;\n    hash ^= (hash<<4);\n    hash -= (hash<<3);\n    hash ^= (hash<<10);\n    hash ^= (hash>>15);\n    #elif 1\n    // HASH32-BB  Bob Jenkin's presumably-accidental version of Thomas Wang hash with rotates turned into shifts.\n    // Note that converting these back to rotates makes it run a lot slower, presumably due to collisions, so I'm\n    // not really sure what's going on.\n    hash ^= seed;\n    hash = (hash ^ 61) ^ (hash >> 16);\n    hash = hash + (hash << 3);\n    hash = hash ^ (hash >> 4);\n    hash = hash * 0x27d4eb2d;\n    hash ^= seed;\n    hash = hash ^ (hash >> 15);\n    #else  // HASH32-C   -  Murmur3\n    hash ^= seed;\n    hash *= 0xcc9e2d51;\n    hash = (hash << 17) | (hash >> 15);\n    hash *= 0x1b873593;\n    hash ^= seed;\n    hash = (hash << 19) | (hash >> 13);\n    hash = hash*5 + 0xe6546b64;\n    hash ^= hash >> 16;\n    hash *= 0x85ebca6b;\n    hash ^= seed;\n    hash ^= hash >> 13;\n    hash *= 0xc2b2ae35;\n    hash ^= hash >> 16;\n    #endif\n    // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2\n    // Note that the larger tables have high variance as they were run fewer times\n    //  HASH32-A   //  HASH32-BB  //  HASH32-C\n    //    0.10ms   //    0.10ms   //    0.10ms :      2,000 inserts creating 2K table\n    //    0.96ms   //    0.95ms   //    0.99ms :     20,000 inserts creating 20K table\n    //   14.69ms   //   14.43ms   //   14.97ms :    200,000 inserts creating 200K table\n    //  199.99ms   //  195.36ms   //  202.05ms :  2,000,000 inserts creating 2M table\n    // 2234.84ms   // 2187.74ms   // 2240.38ms : 20,000,000 inserts creating 20M table\n    //   55.68ms   //   53.72ms   //   57.31ms : 500,000 inserts & deletes in 2K table\n    //   63.43ms   //   61.99ms   //   65.73ms : 500,000 inserts & deletes in 20K table\n    //   80.04ms   //   77.96ms   //   81.83ms : 500,000 inserts & deletes in 200K table\n    //  100.42ms   //   97.40ms   //  102.39ms : 500,000 inserts & deletes in 2M table\n    //  119.71ms   //  120.59ms   //  121.63ms : 500,000 inserts & deletes in 20M table\n    //  185.28ms   //  195.15ms   //  187.74ms : 500,000 inserts & deletes in 200M table\n    //   15.58ms   //   14.79ms   //   15.52ms : 200,000 inserts creating 200K table with varying key spacing\n\n    return (((size_t) hash << 16 << 16) | hash) ^ seed;\n  } else if (len == 8 && sizeof(size_t) == 8) {\n    size_t hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    hash |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // avoid warning if size_t == 4\n    hash ^= seed;\n    hash = (~hash) + (hash << 21);\n    hash ^= STBDS_ROTATE_RIGHT(hash,24);\n    hash *= 265;\n    hash ^= STBDS_ROTATE_RIGHT(hash,14);\n    hash ^= seed;\n    hash *= 21;\n    hash ^= STBDS_ROTATE_RIGHT(hash,28);\n    hash += (hash << 31);\n    hash = (~hash) + (hash << 18);\n    return hash;\n  } else {\n    return stbds_siphash_bytes(p,len,seed);\n  }\n#endif\n}\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n\nstatic int stbds_is_key_equal(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode, size_t i)\n{\n  if (mode >= STBDS_HM_STRING)\n    return 0==strcmp((char *) key, * (char **) ((char *) a + elemsize*i + keyoffset));\n  else\n    return 0==memcmp(key, (char *) a + elemsize*i + keyoffset, keysize);\n}\n\n#define STBDS_HASH_TO_ARR(x,elemsize) ((char*) (x) - (elemsize))\n#define STBDS_ARR_TO_HASH(x,elemsize) ((char*) (x) + (elemsize))\n\n#define stbds_hash_table(a)  ((stbds_hash_index *) stbds_header(a)->hash_table)\n\nvoid stbds_hmfree_func(void *a, size_t elemsize)\n{\n  if (a == NULL) return;\n  if (stbds_hash_table(a) != NULL) {\n    if (stbds_hash_table(a)->string.mode == STBDS_SH_STRDUP) {\n      size_t i;\n      // skip 0th element, which is default\n      for (i=1; i < stbds_header(a)->length; ++i)\n        STBDS_FREE(NULL, *(char**) ((char *) a + elemsize*i));\n    }\n    stbds_strreset(&stbds_hash_table(a)->string);\n  }\n  STBDS_FREE(NULL, stbds_header(a)->hash_table);\n  STBDS_FREE(NULL, stbds_header(a));\n}\n\nstatic ptrdiff_t stbds_hm_find_slot(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)\n{\n  void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n  stbds_hash_index *table = stbds_hash_table(raw_a);\n  size_t hash = mode >= STBDS_HM_STRING ? stbds_hash_string((char*)key,table->seed) : stbds_hash_bytes(key, keysize,table->seed);\n  size_t step = STBDS_BUCKET_LENGTH;\n  size_t limit,i;\n  size_t pos;\n  stbds_hash_bucket *bucket;\n\n  if (hash < 2) hash += 2; // stored hash values are forbidden from being 0, so we can detect empty slots\n\n  pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);\n\n  for (;;) {\n    STBDS_STATS(++stbds_hash_probes);\n    bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n\n    // start searching from pos to end of bucket, this should help performance on small hash tables that fit in cache\n    for (i=pos & STBDS_BUCKET_MASK; i < STBDS_BUCKET_LENGTH; ++i) {\n      if (bucket->hash[i] == hash) {\n        if (stbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n          return (pos & ~STBDS_BUCKET_MASK)+i;\n        }\n      } else if (bucket->hash[i] == STBDS_HASH_EMPTY) {\n        return -1;\n      }\n    }\n\n    // search from beginning of bucket to pos\n    limit = pos & STBDS_BUCKET_MASK;\n    for (i = 0; i < limit; ++i) {\n      if (bucket->hash[i] == hash) {\n        if (stbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n          return (pos & ~STBDS_BUCKET_MASK)+i;\n        }\n      } else if (bucket->hash[i] == STBDS_HASH_EMPTY) {\n        return -1;\n      }\n    }\n\n    // quadratic probing\n    pos += step;\n    step += STBDS_BUCKET_LENGTH;\n    pos &= (table->slot_count-1);\n  }\n  /* NOTREACHED */\n}\n\nvoid * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode)\n{\n  size_t keyoffset = 0;\n  if (a == NULL) {\n    // make it non-empty so we can return a temp\n    a = stbds_arrgrowf(0, elemsize, 0, 1);\n    stbds_header(a)->length += 1;\n    memset(a, 0, elemsize);\n    *temp = STBDS_INDEX_EMPTY;\n    // adjust a to point after the default element\n    return STBDS_ARR_TO_HASH(a,elemsize);\n  } else {\n    stbds_hash_index *table;\n    void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n    // adjust a to point to the default element\n    table = (stbds_hash_index *) stbds_header(raw_a)->hash_table;\n    if (table == 0) {\n      *temp = -1;\n    } else {\n      ptrdiff_t slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);\n      if (slot < 0) {\n        *temp = STBDS_INDEX_EMPTY;\n      } else {\n        stbds_hash_bucket *b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n        *temp = b->index[slot & STBDS_BUCKET_MASK];\n      }\n    }\n    return a;\n  }\n}\n\nvoid * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)\n{\n  ptrdiff_t temp;\n  void *p = stbds_hmget_key_ts(a, elemsize, key, keysize, &temp, mode);\n  stbds_temp(STBDS_HASH_TO_ARR(p,elemsize)) = temp;\n  return p;\n}\n\nvoid * stbds_hmput_default(void *a, size_t elemsize)\n{\n  // three cases:\n  //   a is NULL <- allocate\n  //   a has a hash table but no entries, because of shmode <- grow\n  //   a has entries <- do nothing\n  if (a == NULL || stbds_header(STBDS_HASH_TO_ARR(a,elemsize))->length == 0) {\n    a = stbds_arrgrowf(a ? STBDS_HASH_TO_ARR(a,elemsize) : NULL, elemsize, 0, 1);\n    stbds_header(a)->length += 1;\n    memset(a, 0, elemsize);\n    a=STBDS_ARR_TO_HASH(a,elemsize);\n  }\n  return a;\n}\n\nstatic char *stbds_strdup(char *str);\n\nvoid *stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)\n{\n  size_t keyoffset=0;\n  void *raw_a;\n  stbds_hash_index *table;\n\n  if (a == NULL) {\n    a = stbds_arrgrowf(0, elemsize, 0, 1);\n    memset(a, 0, elemsize);\n    stbds_header(a)->length += 1;\n    // adjust a to point AFTER the default element\n    a = STBDS_ARR_TO_HASH(a,elemsize);\n  }\n\n  // adjust a to point to the default element\n  raw_a = a;\n  a = STBDS_HASH_TO_ARR(a,elemsize);\n\n  table = (stbds_hash_index *) stbds_header(a)->hash_table;\n\n  if (table == NULL || table->used_count >= table->used_count_threshold) {\n    stbds_hash_index *nt;\n    size_t slot_count;\n\n    slot_count = (table == NULL) ? STBDS_BUCKET_LENGTH : table->slot_count*2;\n    nt = stbds_make_hash_index(slot_count, table);\n    if (table)\n      STBDS_FREE(NULL, table);\n    else\n      nt->string.mode = mode >= STBDS_HM_STRING ? STBDS_SH_DEFAULT : 0;\n    stbds_header(a)->hash_table = table = nt;\n    STBDS_STATS(++stbds_hash_grow);\n  }\n\n  // we iterate hash table explicitly because we want to track if we saw a tombstone\n  {\n    size_t hash = mode >= STBDS_HM_STRING ? stbds_hash_string((char*)key,table->seed) : stbds_hash_bytes(key, keysize,table->seed);\n    size_t step = STBDS_BUCKET_LENGTH;\n    size_t pos;\n    ptrdiff_t tombstone = -1;\n    stbds_hash_bucket *bucket;\n\n    // stored hash values are forbidden from being 0, so we can detect empty slots to early out quickly\n    if (hash < 2) hash += 2;\n\n    pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);\n\n    for (;;) {\n      size_t limit, i;\n      STBDS_STATS(++stbds_hash_probes);\n      bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n\n      // start searching from pos to end of bucket\n      for (i=pos & STBDS_BUCKET_MASK; i < STBDS_BUCKET_LENGTH; ++i) {\n        if (bucket->hash[i] == hash) {\n          if (stbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n            stbds_temp(a) = bucket->index[i];\n            if (mode >= STBDS_HM_STRING)\n              stbds_temp_key(a) = * (char **) ((char *) raw_a + elemsize*bucket->index[i] + keyoffset);\n            return STBDS_ARR_TO_HASH(a,elemsize);\n          }\n        } else if (bucket->hash[i] == 0) {\n          pos = (pos & ~STBDS_BUCKET_MASK) + i;\n          goto found_empty_slot;\n        } else if (tombstone < 0) {\n          if (bucket->index[i] == STBDS_INDEX_DELETED)\n            tombstone = (ptrdiff_t) ((pos & ~STBDS_BUCKET_MASK) + i);\n        }\n      }\n\n      // search from beginning of bucket to pos\n      limit = pos & STBDS_BUCKET_MASK;\n      for (i = 0; i < limit; ++i) {\n        if (bucket->hash[i] == hash) {\n          if (stbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n            stbds_temp(a) = bucket->index[i];\n            return STBDS_ARR_TO_HASH(a,elemsize);\n          }\n        } else if (bucket->hash[i] == 0) {\n          pos = (pos & ~STBDS_BUCKET_MASK) + i;\n          goto found_empty_slot;\n        } else if (tombstone < 0) {\n          if (bucket->index[i] == STBDS_INDEX_DELETED)\n            tombstone = (ptrdiff_t) ((pos & ~STBDS_BUCKET_MASK) + i);\n        }\n      }\n\n      // quadratic probing\n      pos += step;\n      step += STBDS_BUCKET_LENGTH;\n      pos &= (table->slot_count-1);\n    }\n   found_empty_slot:\n    if (tombstone >= 0) {\n      pos = tombstone;\n      --table->tombstone_count;\n    }\n    ++table->used_count;\n\n    {\n      ptrdiff_t i = (ptrdiff_t) stbds_arrlen(a);\n      // we want to do stbds_arraddn(1), but we can't use the macros since we don't have something of the right type\n      if ((size_t) i+1 > stbds_arrcap(a))\n        *(void **) &a = stbds_arrgrowf(a, elemsize, 1, 0);\n      raw_a = STBDS_ARR_TO_HASH(a,elemsize);\n\n      STBDS_ASSERT((size_t) i+1 <= stbds_arrcap(a));\n      stbds_header(a)->length = i+1;\n      bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n      bucket->hash[pos & STBDS_BUCKET_MASK] = hash;\n      bucket->index[pos & STBDS_BUCKET_MASK] = i-1;\n      stbds_temp(a) = i-1;\n\n      switch (table->string.mode) {\n         case STBDS_SH_STRDUP:  stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = stbds_strdup((char*) key); break;\n         case STBDS_SH_ARENA:   stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = stbds_stralloc(&table->string, (char*)key); break;\n         case STBDS_SH_DEFAULT: stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = (char *) key; break;\n         default:                memcpy((char *) a + elemsize*i, key, keysize); break;\n      }\n    }\n    return STBDS_ARR_TO_HASH(a,elemsize);\n  }\n}\n\nvoid * stbds_shmode_func(size_t elemsize, int mode)\n{\n  void *a = stbds_arrgrowf(0, elemsize, 0, 1);\n  stbds_hash_index *h;\n  memset(a, 0, elemsize);\n  stbds_header(a)->length = 1;\n  stbds_header(a)->hash_table = h = (stbds_hash_index *) stbds_make_hash_index(STBDS_BUCKET_LENGTH, NULL);\n  h->string.mode = (unsigned char) mode;\n  return STBDS_ARR_TO_HASH(a,elemsize);\n}\n\nvoid * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)\n{\n  if (a == NULL) {\n    return 0;\n  } else {\n    stbds_hash_index *table;\n    void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n    table = (stbds_hash_index *) stbds_header(raw_a)->hash_table;\n    stbds_temp(raw_a) = 0;\n    if (table == 0) {\n      return a;\n    } else {\n      ptrdiff_t slot;\n      slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);\n      if (slot < 0)\n        return a;\n      else {\n        stbds_hash_bucket *b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n        int i = slot & STBDS_BUCKET_MASK;\n        ptrdiff_t old_index = b->index[i];\n        ptrdiff_t final_index = (ptrdiff_t) stbds_arrlen(raw_a)-1-1; // minus one for the raw_a vs a, and minus one for 'last'\n        STBDS_ASSERT(slot < (ptrdiff_t) table->slot_count);\n        --table->used_count;\n        ++table->tombstone_count;\n        stbds_temp(raw_a) = 1;\n        STBDS_ASSERT(table->used_count >= 0);\n        //STBDS_ASSERT(table->tombstone_count < table->slot_count/4);\n        b->hash[i] = STBDS_HASH_DELETED;\n        b->index[i] = STBDS_INDEX_DELETED;\n\n        if (mode == STBDS_HM_STRING && table->string.mode == STBDS_SH_STRDUP)\n          STBDS_FREE(NULL, *(char**) ((char *) a+elemsize*old_index));\n\n        // if indices are the same, memcpy is a no-op, but back-pointer-fixup will fail, so skip\n        if (old_index != final_index) {\n          // swap delete\n          memmove((char*) a + elemsize*old_index, (char*) a + elemsize*final_index, elemsize);\n\n          // now find the slot for the last element\n          if (mode == STBDS_HM_STRING)\n            slot = stbds_hm_find_slot(a, elemsize, *(char**) ((char *) a+elemsize*old_index + keyoffset), keysize, keyoffset, mode);\n          else\n            slot = stbds_hm_find_slot(a, elemsize,  (char* ) a+elemsize*old_index + keyoffset, keysize, keyoffset, mode);\n          STBDS_ASSERT(slot >= 0);\n          b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n          i = slot & STBDS_BUCKET_MASK;\n          STBDS_ASSERT(b->index[i] == final_index);\n          b->index[i] = old_index;\n        }\n        stbds_header(raw_a)->length -= 1;\n\n        if (table->used_count < table->used_count_shrink_threshold && table->slot_count > STBDS_BUCKET_LENGTH) {\n          stbds_header(raw_a)->hash_table = stbds_make_hash_index(table->slot_count>>1, table);\n          STBDS_FREE(NULL, table);\n          STBDS_STATS(++stbds_hash_shrink);\n        } else if (table->tombstone_count > table->tombstone_count_threshold) {\n          stbds_header(raw_a)->hash_table = stbds_make_hash_index(table->slot_count   , table);\n          STBDS_FREE(NULL, table);\n          STBDS_STATS(++stbds_hash_rebuild);\n        }\n\n        return a;\n      }\n    }\n  }\n  /* NOTREACHED */\n}\n\nstatic char *stbds_strdup(char *str)\n{\n  // to keep replaceable allocator simple, we don't want to use strdup.\n  // rolling our own also avoids problem of strdup vs _strdup\n  size_t len = strlen(str)+1;\n  char *p = (char*) STBDS_REALLOC(NULL, 0, len);\n  memmove(p, str, len);\n  return p;\n}\n\n#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MIN\n#define STBDS_STRING_ARENA_BLOCKSIZE_MIN  512u\n#endif\n#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MAX\n#define STBDS_STRING_ARENA_BLOCKSIZE_MAX  (1u<<20)\n#endif\n\nchar *stbds_stralloc(stbds_string_arena *a, char *str)\n{\n  char *p;\n  size_t len = strlen(str)+1;\n  if (len > a->remaining) {\n    // compute the next blocksize\n    size_t blocksize = a->block;\n\n    // size is 512, 512, 1024, 1024, 2048, 2048, 4096, 4096, etc., so that\n    // there are log(SIZE) allocations to free when we destroy the table\n    blocksize = (size_t) (STBDS_STRING_ARENA_BLOCKSIZE_MIN) << (blocksize>>1);\n\n    // if size is under 1M, advance to next blocktype\n    if (blocksize < (size_t)(STBDS_STRING_ARENA_BLOCKSIZE_MAX))\n      ++a->block;\n\n    if (len > blocksize) {\n      // if string is larger than blocksize, then just allocate the full size.\n      // note that we still advance string_block so block size will continue\n      // increasing, so e.g. if somebody only calls this with 1000-long strings,\n      // eventually the arena will start doubling and handling those as well\n      stbds_string_block *sb = (stbds_string_block *) STBDS_REALLOC(NULL, 0, sizeof(*sb)-8 + len);\n      memmove(sb->storage, str, len);\n      if (a->storage) {\n        // insert it after the first element, so that we don't waste the space there\n        sb->next = a->storage->next;\n        a->storage->next = sb;\n      } else {\n        sb->next = 0;\n        a->storage = sb;\n        a->remaining = 0; // this is redundant, but good for clarity\n      }\n      return sb->storage;\n    } else {\n      stbds_string_block *sb = (stbds_string_block *) STBDS_REALLOC(NULL, 0, sizeof(*sb)-8 + blocksize);\n      sb->next = a->storage;\n      a->storage = sb;\n      a->remaining = blocksize;\n    }\n  }\n\n  STBDS_ASSERT(len <= a->remaining);\n  p = a->storage->storage + a->remaining - len;\n  a->remaining -= len;\n  memmove(p, str, len);\n  return p;\n}\n\nvoid stbds_strreset(stbds_string_arena *a)\n{\n  stbds_string_block *x,*y;\n  x = a->storage;\n  while (x) {\n    y = x->next;\n    STBDS_FREE(NULL, x);\n    x = y;\n  }\n  memset(a, 0, sizeof(*a));\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//   UNIT TESTS\n//\n\n#ifdef STBDS_UNIT_TESTS\n#include <stdio.h>\n#ifdef STBDS_ASSERT_WAS_UNDEFINED\n#undef STBDS_ASSERT\n#endif\n#ifndef STBDS_ASSERT\n#define STBDS_ASSERT assert\n#include <assert.h>\n#endif\n\ntypedef struct { int key,b,c,d; } stbds_struct;\ntypedef struct { int key[2],b,c,d; } stbds_struct2;\n\nstatic char buffer[256];\nchar *strkey(int n)\n{\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   sprintf_s(buffer, sizeof(buffer), \"test_%d\", n);\n#else\n   sprintf(buffer, \"test_%d\", n);\n#endif\n   return buffer;\n}\n\nvoid stbds_unit_tests(void)\n{\n#if defined(_MSC_VER) && _MSC_VER <= 1200 && defined(__cplusplus)\n  // VC6 C++ doesn't like the template<> trick on unnamed structures, so do nothing!\n  STBDS_ASSERT(0);\n#else\n  const int testsize = 100000;\n  const int testsize2 = testsize/20;\n  int *arr=NULL;\n  struct { int   key;        int value; }  *intmap  = NULL;\n  struct { char *key;        int value; }  *strmap  = NULL, s;\n  struct { stbds_struct key; int value; }  *map     = NULL;\n  stbds_struct                             *map2    = NULL;\n  stbds_struct2                            *map3    = NULL;\n  stbds_string_arena                        sa      = { 0 };\n  int key3[2] = { 1,2 };\n  ptrdiff_t temp;\n\n  int i,j;\n\n  STBDS_ASSERT(arrlen(arr)==0);\n  for (i=0; i < 20000; i += 50) {\n    for (j=0; j < i; ++j)\n      arrpush(arr,j);\n    arrfree(arr);\n  }\n\n  for (i=0; i < 4; ++i) {\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    arrdel(arr,i);\n    arrfree(arr);\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    arrdelswap(arr,i);\n    arrfree(arr);\n  }\n\n  for (i=0; i < 5; ++i) {\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    stbds_arrins(arr,i,5);\n    STBDS_ASSERT(arr[i] == 5);\n    if (i < 4)\n      STBDS_ASSERT(arr[4] == 4);\n    arrfree(arr);\n  }\n\n  i = 1;\n  STBDS_ASSERT(hmgeti(intmap,i) == -1);\n  hmdefault(intmap, -2);\n  STBDS_ASSERT(hmgeti(intmap, i) == -1);\n  STBDS_ASSERT(hmget (intmap, i) == -2);\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*5);\n  for (i=0; i < testsize; i+=1) {\n    if (i & 1) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*5);\n    if (i & 1) STBDS_ASSERT(hmget_ts(intmap, i, temp) == -2 );\n    else       STBDS_ASSERT(hmget_ts(intmap, i, temp) == i*5);\n  }\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*3);\n  for (i=0; i < testsize; i+=1)\n    if (i & 1) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*3);\n  for (i=2; i < testsize; i+=4)\n    hmdel(intmap, i); // delete half the entries\n  for (i=0; i < testsize; i+=1)\n    if (i & 3) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*3);\n  for (i=0; i < testsize; i+=1)\n    hmdel(intmap, i); // delete the rest of the entries\n  for (i=0; i < testsize; i+=1)\n    STBDS_ASSERT(hmget(intmap, i) == -2 );\n  hmfree(intmap);\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*3);\n  hmfree(intmap);\n\n  #if defined(__clang__) || defined(__GNUC__)\n  #ifndef __cplusplus\n  intmap = NULL;\n  hmput(intmap, 15, 7);\n  hmput(intmap, 11, 3);\n  hmput(intmap,  9, 5);\n  STBDS_ASSERT(hmget(intmap, 9) == 5);\n  STBDS_ASSERT(hmget(intmap, 11) == 3);\n  STBDS_ASSERT(hmget(intmap, 15) == 7);\n  #endif\n  #endif\n\n  for (i=0; i < testsize; ++i)\n    stralloc(&sa, strkey(i));\n  strreset(&sa);\n\n  {\n    s.key = \"a\", s.value = 1;\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key == s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  {\n    s.key = \"a\", s.value = 1;\n    sh_new_strdup(strmap);\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key != s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  {\n    s.key = \"a\", s.value = 1;\n    sh_new_arena(strmap);\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key != s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  for (j=0; j < 2; ++j) {\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    if (j == 0)\n      sh_new_strdup(strmap);\n    else\n      sh_new_arena(strmap);\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    shdefault(strmap, -2);\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    for (i=0; i < testsize; i+=2)\n      shput(strmap, strkey(i), i*3);\n    for (i=0; i < testsize; i+=1)\n      if (i & 1) STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n      else       STBDS_ASSERT(shget(strmap, strkey(i)) == i*3);\n    for (i=2; i < testsize; i+=4)\n      shdel(strmap, strkey(i)); // delete half the entries\n    for (i=0; i < testsize; i+=1)\n      if (i & 3) STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n      else       STBDS_ASSERT(shget(strmap, strkey(i)) == i*3);\n    for (i=0; i < testsize; i+=1)\n      shdel(strmap, strkey(i)); // delete the rest of the entries\n    for (i=0; i < testsize; i+=1)\n      STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n    shfree(strmap);\n  }\n\n  {\n    struct { char *key; char value; } *hash = NULL;\n    char name[4] = \"jen\";\n    shput(hash, \"bob\"   , 'h');\n    shput(hash, \"sally\" , 'e');\n    shput(hash, \"fred\"  , 'l');\n    shput(hash, \"jen\"   , 'x');\n    shput(hash, \"doug\"  , 'o');\n\n    shput(hash, name    , 'l');\n    shfree(hash);\n  }\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    hmput(map, s, i*5);\n  }\n\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct s = { i,i*2,i*3  ,i*4 };\n    stbds_struct t = { i,i*2,i*3+1,i*4 };\n    if (i & 1) STBDS_ASSERT(hmget(map, s) == 0);\n    else       STBDS_ASSERT(hmget(map, s) == i*5);\n    if (i & 1) STBDS_ASSERT(hmget_ts(map, s, temp) == 0);\n    else       STBDS_ASSERT(hmget_ts(map, s, temp) == i*5);\n    //STBDS_ASSERT(hmget(map, t.key) == 0);\n  }\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    hmputs(map2, s);\n  }\n  hmfree(map);\n\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    stbds_struct t = { i,i*2,i*3+1,i*4 };\n    if (i & 1) STBDS_ASSERT(hmgets(map2, s.key).d == 0);\n    else       STBDS_ASSERT(hmgets(map2, s.key).d == i*4);\n    //STBDS_ASSERT(hmgetp(map2, t.key) == 0);\n  }\n  hmfree(map2);\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct2 s = { { i,i*2 }, i*3,i*4, i*5 };\n    hmputs(map3, s);\n  }\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct2 s = { { i,i*2}, i*3, i*4, i*5 };\n    stbds_struct2 t = { { i,i*2}, i*3+1, i*4, i*5 };\n    if (i & 1) STBDS_ASSERT(hmgets(map3, s.key).d == 0);\n    else       STBDS_ASSERT(hmgets(map3, s.key).d == i*5);\n    //STBDS_ASSERT(hmgetp(map3, t.key) == 0);\n  }\n#endif\n}\n#endif\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2019 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_dxt.h",
          "type": "blob",
          "size": 27.6552734375,
          "content": "// stb_dxt.h - v1.12 - DXT1/DXT5 compressor - public domain\n// original by fabian \"ryg\" giesen - ported to C by stb\n// use '#define STB_DXT_IMPLEMENTATION' before including to create the implementation\n//\n// USAGE:\n//   call stb_compress_dxt_block() for every block (you must pad)\n//     source should be a 4x4 block of RGBA data in row-major order;\n//     Alpha channel is not stored if you specify alpha=0 (but you\n//     must supply some constant alpha in the alpha channel).\n//     You can turn on dithering and \"high quality\" using mode.\n//\n// version history:\n//   v1.12  - (ryg) fix bug in single-color table generator\n//   v1.11  - (ryg) avoid racy global init, better single-color tables, remove dither\n//   v1.10  - (i.c) various small quality improvements\n//   v1.09  - (stb) update documentation re: surprising alpha channel requirement\n//   v1.08  - (stb) fix bug in dxt-with-alpha block\n//   v1.07  - (stb) bc4; allow not using libc; add STB_DXT_STATIC\n//   v1.06  - (stb) fix to known-broken 1.05\n//   v1.05  - (stb) support bc5/3dc (Arvids Kokins), use extern \"C\" in C++ (Pavel Krajcevski)\n//   v1.04  - (ryg) default to no rounding bias for lerped colors (as per S3TC/DX10 spec);\n//            single color match fix (allow for inexact color interpolation);\n//            optimal DXT5 index finder; \"high quality\" mode that runs multiple refinement steps.\n//   v1.03  - (stb) endianness support\n//   v1.02  - (stb) fix alpha encoding bug\n//   v1.01  - (stb) fix bug converting to RGB that messed up quality, thanks ryg & cbloom\n//   v1.00  - (stb) first release\n//\n// contributors:\n//   Rich Geldreich (more accurate index selection)\n//   Kevin Schmidt (#defines for \"freestanding\" compilation)\n//   github:ppiastucki (BC4 support)\n//   Ignacio Castano - improve DXT endpoint quantization\n//   Alan Hickman - static table initialization\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n#ifndef STB_INCLUDE_STB_DXT_H\n#define STB_INCLUDE_STB_DXT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef STB_DXT_STATIC\n#define STBDDEF static\n#else\n#define STBDDEF extern\n#endif\n\n// compression mode (bitflags)\n#define STB_DXT_NORMAL    0\n#define STB_DXT_DITHER    1   // use dithering. was always dubious, now deprecated. does nothing!\n#define STB_DXT_HIGHQUAL  2   // high quality mode, does two refinement steps instead of 1. ~30-40% slower.\n\nSTBDDEF void stb_compress_dxt_block(unsigned char *dest, const unsigned char *src_rgba_four_bytes_per_pixel, int alpha, int mode);\nSTBDDEF void stb_compress_bc4_block(unsigned char *dest, const unsigned char *src_r_one_byte_per_pixel);\nSTBDDEF void stb_compress_bc5_block(unsigned char *dest, const unsigned char *src_rg_two_byte_per_pixel);\n\n#define STB_COMPRESS_DXT_BLOCK\n\n#ifdef __cplusplus\n}\n#endif\n#endif // STB_INCLUDE_STB_DXT_H\n\n#ifdef STB_DXT_IMPLEMENTATION\n\n// configuration options for DXT encoder. set them in the project/makefile or just define\n// them at the top.\n\n// STB_DXT_USE_ROUNDING_BIAS\n//     use a rounding bias during color interpolation. this is closer to what \"ideal\"\n//     interpolation would do but doesn't match the S3TC/DX10 spec. old versions (pre-1.03)\n//     implicitly had this turned on.\n//\n//     in case you're targeting a specific type of hardware (e.g. console programmers):\n//     NVidia and Intel GPUs (as of 2010) as well as DX9 ref use DXT decoders that are closer\n//     to STB_DXT_USE_ROUNDING_BIAS. AMD/ATI, S3 and DX10 ref are closer to rounding with no bias.\n//     you also see \"(a*5 + b*3) / 8\" on some old GPU designs.\n// #define STB_DXT_USE_ROUNDING_BIAS\n\n#include <stdlib.h>\n\n#if !defined(STBD_FABS)\n#include <math.h>\n#endif\n\n#ifndef STBD_FABS\n#define STBD_FABS(x)          fabs(x)\n#endif\n\nstatic const unsigned char stb__OMatch5[256][2] = {\n   {  0,  0 }, {  0,  0 }, {  0,  1 }, {  0,  1 }, {  1,  0 }, {  1,  0 }, {  1,  0 }, {  1,  1 },\n   {  1,  1 }, {  1,  1 }, {  1,  2 }, {  0,  4 }, {  2,  1 }, {  2,  1 }, {  2,  1 }, {  2,  2 },\n   {  2,  2 }, {  2,  2 }, {  2,  3 }, {  1,  5 }, {  3,  2 }, {  3,  2 }, {  4,  0 }, {  3,  3 },\n   {  3,  3 }, {  3,  3 }, {  3,  4 }, {  3,  4 }, {  3,  4 }, {  3,  5 }, {  4,  3 }, {  4,  3 },\n   {  5,  2 }, {  4,  4 }, {  4,  4 }, {  4,  5 }, {  4,  5 }, {  5,  4 }, {  5,  4 }, {  5,  4 },\n   {  6,  3 }, {  5,  5 }, {  5,  5 }, {  5,  6 }, {  4,  8 }, {  6,  5 }, {  6,  5 }, {  6,  5 },\n   {  6,  6 }, {  6,  6 }, {  6,  6 }, {  6,  7 }, {  5,  9 }, {  7,  6 }, {  7,  6 }, {  8,  4 },\n   {  7,  7 }, {  7,  7 }, {  7,  7 }, {  7,  8 }, {  7,  8 }, {  7,  8 }, {  7,  9 }, {  8,  7 },\n   {  8,  7 }, {  9,  6 }, {  8,  8 }, {  8,  8 }, {  8,  9 }, {  8,  9 }, {  9,  8 }, {  9,  8 },\n   {  9,  8 }, { 10,  7 }, {  9,  9 }, {  9,  9 }, {  9, 10 }, {  8, 12 }, { 10,  9 }, { 10,  9 },\n   { 10,  9 }, { 10, 10 }, { 10, 10 }, { 10, 10 }, { 10, 11 }, {  9, 13 }, { 11, 10 }, { 11, 10 },\n   { 12,  8 }, { 11, 11 }, { 11, 11 }, { 11, 11 }, { 11, 12 }, { 11, 12 }, { 11, 12 }, { 11, 13 },\n   { 12, 11 }, { 12, 11 }, { 13, 10 }, { 12, 12 }, { 12, 12 }, { 12, 13 }, { 12, 13 }, { 13, 12 },\n   { 13, 12 }, { 13, 12 }, { 14, 11 }, { 13, 13 }, { 13, 13 }, { 13, 14 }, { 12, 16 }, { 14, 13 },\n   { 14, 13 }, { 14, 13 }, { 14, 14 }, { 14, 14 }, { 14, 14 }, { 14, 15 }, { 13, 17 }, { 15, 14 },\n   { 15, 14 }, { 16, 12 }, { 15, 15 }, { 15, 15 }, { 15, 15 }, { 15, 16 }, { 15, 16 }, { 15, 16 },\n   { 15, 17 }, { 16, 15 }, { 16, 15 }, { 17, 14 }, { 16, 16 }, { 16, 16 }, { 16, 17 }, { 16, 17 },\n   { 17, 16 }, { 17, 16 }, { 17, 16 }, { 18, 15 }, { 17, 17 }, { 17, 17 }, { 17, 18 }, { 16, 20 },\n   { 18, 17 }, { 18, 17 }, { 18, 17 }, { 18, 18 }, { 18, 18 }, { 18, 18 }, { 18, 19 }, { 17, 21 },\n   { 19, 18 }, { 19, 18 }, { 20, 16 }, { 19, 19 }, { 19, 19 }, { 19, 19 }, { 19, 20 }, { 19, 20 },\n   { 19, 20 }, { 19, 21 }, { 20, 19 }, { 20, 19 }, { 21, 18 }, { 20, 20 }, { 20, 20 }, { 20, 21 },\n   { 20, 21 }, { 21, 20 }, { 21, 20 }, { 21, 20 }, { 22, 19 }, { 21, 21 }, { 21, 21 }, { 21, 22 },\n   { 20, 24 }, { 22, 21 }, { 22, 21 }, { 22, 21 }, { 22, 22 }, { 22, 22 }, { 22, 22 }, { 22, 23 },\n   { 21, 25 }, { 23, 22 }, { 23, 22 }, { 24, 20 }, { 23, 23 }, { 23, 23 }, { 23, 23 }, { 23, 24 },\n   { 23, 24 }, { 23, 24 }, { 23, 25 }, { 24, 23 }, { 24, 23 }, { 25, 22 }, { 24, 24 }, { 24, 24 },\n   { 24, 25 }, { 24, 25 }, { 25, 24 }, { 25, 24 }, { 25, 24 }, { 26, 23 }, { 25, 25 }, { 25, 25 },\n   { 25, 26 }, { 24, 28 }, { 26, 25 }, { 26, 25 }, { 26, 25 }, { 26, 26 }, { 26, 26 }, { 26, 26 },\n   { 26, 27 }, { 25, 29 }, { 27, 26 }, { 27, 26 }, { 28, 24 }, { 27, 27 }, { 27, 27 }, { 27, 27 },\n   { 27, 28 }, { 27, 28 }, { 27, 28 }, { 27, 29 }, { 28, 27 }, { 28, 27 }, { 29, 26 }, { 28, 28 },\n   { 28, 28 }, { 28, 29 }, { 28, 29 }, { 29, 28 }, { 29, 28 }, { 29, 28 }, { 30, 27 }, { 29, 29 },\n   { 29, 29 }, { 29, 30 }, { 29, 30 }, { 30, 29 }, { 30, 29 }, { 30, 29 }, { 30, 30 }, { 30, 30 },\n   { 30, 30 }, { 30, 31 }, { 30, 31 }, { 31, 30 }, { 31, 30 }, { 31, 30 }, { 31, 31 }, { 31, 31 },\n};\nstatic const unsigned char stb__OMatch6[256][2] = {\n   {  0,  0 }, {  0,  1 }, {  1,  0 }, {  1,  1 }, {  1,  1 }, {  1,  2 }, {  2,  1 }, {  2,  2 },\n   {  2,  2 }, {  2,  3 }, {  3,  2 }, {  3,  3 }, {  3,  3 }, {  3,  4 }, {  4,  3 }, {  4,  4 },\n   {  4,  4 }, {  4,  5 }, {  5,  4 }, {  5,  5 }, {  5,  5 }, {  5,  6 }, {  6,  5 }, {  6,  6 },\n   {  6,  6 }, {  6,  7 }, {  7,  6 }, {  7,  7 }, {  7,  7 }, {  7,  8 }, {  8,  7 }, {  8,  8 },\n   {  8,  8 }, {  8,  9 }, {  9,  8 }, {  9,  9 }, {  9,  9 }, {  9, 10 }, { 10,  9 }, { 10, 10 },\n   { 10, 10 }, { 10, 11 }, { 11, 10 }, {  8, 16 }, { 11, 11 }, { 11, 12 }, { 12, 11 }, {  9, 17 },\n   { 12, 12 }, { 12, 13 }, { 13, 12 }, { 11, 16 }, { 13, 13 }, { 13, 14 }, { 14, 13 }, { 12, 17 },\n   { 14, 14 }, { 14, 15 }, { 15, 14 }, { 14, 16 }, { 15, 15 }, { 15, 16 }, { 16, 14 }, { 16, 15 },\n   { 17, 14 }, { 16, 16 }, { 16, 17 }, { 17, 16 }, { 18, 15 }, { 17, 17 }, { 17, 18 }, { 18, 17 },\n   { 20, 14 }, { 18, 18 }, { 18, 19 }, { 19, 18 }, { 21, 15 }, { 19, 19 }, { 19, 20 }, { 20, 19 },\n   { 20, 20 }, { 20, 20 }, { 20, 21 }, { 21, 20 }, { 21, 21 }, { 21, 21 }, { 21, 22 }, { 22, 21 },\n   { 22, 22 }, { 22, 22 }, { 22, 23 }, { 23, 22 }, { 23, 23 }, { 23, 23 }, { 23, 24 }, { 24, 23 },\n   { 24, 24 }, { 24, 24 }, { 24, 25 }, { 25, 24 }, { 25, 25 }, { 25, 25 }, { 25, 26 }, { 26, 25 },\n   { 26, 26 }, { 26, 26 }, { 26, 27 }, { 27, 26 }, { 24, 32 }, { 27, 27 }, { 27, 28 }, { 28, 27 },\n   { 25, 33 }, { 28, 28 }, { 28, 29 }, { 29, 28 }, { 27, 32 }, { 29, 29 }, { 29, 30 }, { 30, 29 },\n   { 28, 33 }, { 30, 30 }, { 30, 31 }, { 31, 30 }, { 30, 32 }, { 31, 31 }, { 31, 32 }, { 32, 30 },\n   { 32, 31 }, { 33, 30 }, { 32, 32 }, { 32, 33 }, { 33, 32 }, { 34, 31 }, { 33, 33 }, { 33, 34 },\n   { 34, 33 }, { 36, 30 }, { 34, 34 }, { 34, 35 }, { 35, 34 }, { 37, 31 }, { 35, 35 }, { 35, 36 },\n   { 36, 35 }, { 36, 36 }, { 36, 36 }, { 36, 37 }, { 37, 36 }, { 37, 37 }, { 37, 37 }, { 37, 38 },\n   { 38, 37 }, { 38, 38 }, { 38, 38 }, { 38, 39 }, { 39, 38 }, { 39, 39 }, { 39, 39 }, { 39, 40 },\n   { 40, 39 }, { 40, 40 }, { 40, 40 }, { 40, 41 }, { 41, 40 }, { 41, 41 }, { 41, 41 }, { 41, 42 },\n   { 42, 41 }, { 42, 42 }, { 42, 42 }, { 42, 43 }, { 43, 42 }, { 40, 48 }, { 43, 43 }, { 43, 44 },\n   { 44, 43 }, { 41, 49 }, { 44, 44 }, { 44, 45 }, { 45, 44 }, { 43, 48 }, { 45, 45 }, { 45, 46 },\n   { 46, 45 }, { 44, 49 }, { 46, 46 }, { 46, 47 }, { 47, 46 }, { 46, 48 }, { 47, 47 }, { 47, 48 },\n   { 48, 46 }, { 48, 47 }, { 49, 46 }, { 48, 48 }, { 48, 49 }, { 49, 48 }, { 50, 47 }, { 49, 49 },\n   { 49, 50 }, { 50, 49 }, { 52, 46 }, { 50, 50 }, { 50, 51 }, { 51, 50 }, { 53, 47 }, { 51, 51 },\n   { 51, 52 }, { 52, 51 }, { 52, 52 }, { 52, 52 }, { 52, 53 }, { 53, 52 }, { 53, 53 }, { 53, 53 },\n   { 53, 54 }, { 54, 53 }, { 54, 54 }, { 54, 54 }, { 54, 55 }, { 55, 54 }, { 55, 55 }, { 55, 55 },\n   { 55, 56 }, { 56, 55 }, { 56, 56 }, { 56, 56 }, { 56, 57 }, { 57, 56 }, { 57, 57 }, { 57, 57 },\n   { 57, 58 }, { 58, 57 }, { 58, 58 }, { 58, 58 }, { 58, 59 }, { 59, 58 }, { 59, 59 }, { 59, 59 },\n   { 59, 60 }, { 60, 59 }, { 60, 60 }, { 60, 60 }, { 60, 61 }, { 61, 60 }, { 61, 61 }, { 61, 61 },\n   { 61, 62 }, { 62, 61 }, { 62, 62 }, { 62, 62 }, { 62, 63 }, { 63, 62 }, { 63, 63 }, { 63, 63 },\n};\n\nstatic int stb__Mul8Bit(int a, int b)\n{\n  int t = a*b + 128;\n  return (t + (t >> 8)) >> 8;\n}\n\nstatic void stb__From16Bit(unsigned char *out, unsigned short v)\n{\n   int rv = (v & 0xf800) >> 11;\n   int gv = (v & 0x07e0) >>  5;\n   int bv = (v & 0x001f) >>  0;\n\n   // expand to 8 bits via bit replication\n   out[0] = (rv * 33) >> 2;\n   out[1] = (gv * 65) >> 4;\n   out[2] = (bv * 33) >> 2;\n   out[3] = 0;\n}\n\nstatic unsigned short stb__As16Bit(int r, int g, int b)\n{\n   return (unsigned short)((stb__Mul8Bit(r,31) << 11) + (stb__Mul8Bit(g,63) << 5) + stb__Mul8Bit(b,31));\n}\n\n// linear interpolation at 1/3 point between a and b, using desired rounding type\nstatic int stb__Lerp13(int a, int b)\n{\n#ifdef STB_DXT_USE_ROUNDING_BIAS\n   // with rounding bias\n   return a + stb__Mul8Bit(b-a, 0x55);\n#else\n   // without rounding bias\n   // replace \"/ 3\" by \"* 0xaaab) >> 17\" if your compiler sucks or you really need every ounce of speed.\n   return (2*a + b) / 3;\n#endif\n}\n\n// lerp RGB color\nstatic void stb__Lerp13RGB(unsigned char *out, unsigned char *p1, unsigned char *p2)\n{\n   out[0] = (unsigned char)stb__Lerp13(p1[0], p2[0]);\n   out[1] = (unsigned char)stb__Lerp13(p1[1], p2[1]);\n   out[2] = (unsigned char)stb__Lerp13(p1[2], p2[2]);\n}\n\n/****************************************************************************/\n\nstatic void stb__EvalColors(unsigned char *color,unsigned short c0,unsigned short c1)\n{\n   stb__From16Bit(color+ 0, c0);\n   stb__From16Bit(color+ 4, c1);\n   stb__Lerp13RGB(color+ 8, color+0, color+4);\n   stb__Lerp13RGB(color+12, color+4, color+0);\n}\n\n// The color matching function\nstatic unsigned int stb__MatchColorsBlock(unsigned char *block, unsigned char *color)\n{\n   unsigned int mask = 0;\n   int dirr = color[0*4+0] - color[1*4+0];\n   int dirg = color[0*4+1] - color[1*4+1];\n   int dirb = color[0*4+2] - color[1*4+2];\n   int dots[16];\n   int stops[4];\n   int i;\n   int c0Point, halfPoint, c3Point;\n\n   for(i=0;i<16;i++)\n      dots[i] = block[i*4+0]*dirr + block[i*4+1]*dirg + block[i*4+2]*dirb;\n\n   for(i=0;i<4;i++)\n      stops[i] = color[i*4+0]*dirr + color[i*4+1]*dirg + color[i*4+2]*dirb;\n\n   // think of the colors as arranged on a line; project point onto that line, then choose\n   // next color out of available ones. we compute the crossover points for \"best color in top\n   // half\"/\"best in bottom half\" and then the same inside that subinterval.\n   //\n   // relying on this 1d approximation isn't always optimal in terms of euclidean distance,\n   // but it's very close and a lot faster.\n   // http://cbloomrants.blogspot.com/2008/12/12-08-08-dxtc-summary.html\n\n   c0Point   = (stops[1] + stops[3]);\n   halfPoint = (stops[3] + stops[2]);\n   c3Point   = (stops[2] + stops[0]);\n\n   for (i=15;i>=0;i--) {\n      int dot = dots[i]*2;\n      mask <<= 2;\n\n      if(dot < halfPoint)\n         mask |= (dot < c0Point) ? 1 : 3;\n      else\n         mask |= (dot < c3Point) ? 2 : 0;\n   }\n\n   return mask;\n}\n\n// The color optimization function. (Clever code, part 1)\nstatic void stb__OptimizeColorsBlock(unsigned char *block, unsigned short *pmax16, unsigned short *pmin16)\n{\n  int mind,maxd;\n  unsigned char *minp, *maxp;\n  double magn;\n  int v_r,v_g,v_b;\n  static const int nIterPower = 4;\n  float covf[6],vfr,vfg,vfb;\n\n  // determine color distribution\n  int cov[6];\n  int mu[3],min[3],max[3];\n  int ch,i,iter;\n\n  for(ch=0;ch<3;ch++)\n  {\n    const unsigned char *bp = ((const unsigned char *) block) + ch;\n    int muv,minv,maxv;\n\n    muv = minv = maxv = bp[0];\n    for(i=4;i<64;i+=4)\n    {\n      muv += bp[i];\n      if (bp[i] < minv) minv = bp[i];\n      else if (bp[i] > maxv) maxv = bp[i];\n    }\n\n    mu[ch] = (muv + 8) >> 4;\n    min[ch] = minv;\n    max[ch] = maxv;\n  }\n\n  // determine covariance matrix\n  for (i=0;i<6;i++)\n     cov[i] = 0;\n\n  for (i=0;i<16;i++)\n  {\n    int r = block[i*4+0] - mu[0];\n    int g = block[i*4+1] - mu[1];\n    int b = block[i*4+2] - mu[2];\n\n    cov[0] += r*r;\n    cov[1] += r*g;\n    cov[2] += r*b;\n    cov[3] += g*g;\n    cov[4] += g*b;\n    cov[5] += b*b;\n  }\n\n  // convert covariance matrix to float, find principal axis via power iter\n  for(i=0;i<6;i++)\n    covf[i] = cov[i] / 255.0f;\n\n  vfr = (float) (max[0] - min[0]);\n  vfg = (float) (max[1] - min[1]);\n  vfb = (float) (max[2] - min[2]);\n\n  for(iter=0;iter<nIterPower;iter++)\n  {\n    float r = vfr*covf[0] + vfg*covf[1] + vfb*covf[2];\n    float g = vfr*covf[1] + vfg*covf[3] + vfb*covf[4];\n    float b = vfr*covf[2] + vfg*covf[4] + vfb*covf[5];\n\n    vfr = r;\n    vfg = g;\n    vfb = b;\n  }\n\n  magn = STBD_FABS(vfr);\n  if (STBD_FABS(vfg) > magn) magn = STBD_FABS(vfg);\n  if (STBD_FABS(vfb) > magn) magn = STBD_FABS(vfb);\n\n   if(magn < 4.0f) { // too small, default to luminance\n      v_r = 299; // JPEG YCbCr luma coefs, scaled by 1000.\n      v_g = 587;\n      v_b = 114;\n   } else {\n      magn = 512.0 / magn;\n      v_r = (int) (vfr * magn);\n      v_g = (int) (vfg * magn);\n      v_b = (int) (vfb * magn);\n   }\n\n   minp = maxp = block;\n   mind = maxd = block[0]*v_r + block[1]*v_g + block[2]*v_b;\n   // Pick colors at extreme points\n   for(i=1;i<16;i++)\n   {\n      int dot = block[i*4+0]*v_r + block[i*4+1]*v_g + block[i*4+2]*v_b;\n\n      if (dot < mind) {\n         mind = dot;\n         minp = block+i*4;\n      }\n\n      if (dot > maxd) {\n         maxd = dot;\n         maxp = block+i*4;\n      }\n   }\n\n   *pmax16 = stb__As16Bit(maxp[0],maxp[1],maxp[2]);\n   *pmin16 = stb__As16Bit(minp[0],minp[1],minp[2]);\n}\n\nstatic const float stb__midpoints5[32] = {\n   0.015686f, 0.047059f, 0.078431f, 0.111765f, 0.145098f, 0.176471f, 0.207843f, 0.241176f, 0.274510f, 0.305882f, 0.337255f, 0.370588f, 0.403922f, 0.435294f, 0.466667f, 0.5f,\n   0.533333f, 0.564706f, 0.596078f, 0.629412f, 0.662745f, 0.694118f, 0.725490f, 0.758824f, 0.792157f, 0.823529f, 0.854902f, 0.888235f, 0.921569f, 0.952941f, 0.984314f, 1.0f\n};\n\nstatic const float stb__midpoints6[64] = {\n   0.007843f, 0.023529f, 0.039216f, 0.054902f, 0.070588f, 0.086275f, 0.101961f, 0.117647f, 0.133333f, 0.149020f, 0.164706f, 0.180392f, 0.196078f, 0.211765f, 0.227451f, 0.245098f,\n   0.262745f, 0.278431f, 0.294118f, 0.309804f, 0.325490f, 0.341176f, 0.356863f, 0.372549f, 0.388235f, 0.403922f, 0.419608f, 0.435294f, 0.450980f, 0.466667f, 0.482353f, 0.500000f,\n   0.517647f, 0.533333f, 0.549020f, 0.564706f, 0.580392f, 0.596078f, 0.611765f, 0.627451f, 0.643137f, 0.658824f, 0.674510f, 0.690196f, 0.705882f, 0.721569f, 0.737255f, 0.754902f,\n   0.772549f, 0.788235f, 0.803922f, 0.819608f, 0.835294f, 0.850980f, 0.866667f, 0.882353f, 0.898039f, 0.913725f, 0.929412f, 0.945098f, 0.960784f, 0.976471f, 0.992157f, 1.0f\n};\n\nstatic unsigned short stb__Quantize5(float x)\n{\n   unsigned short q;\n   x = x < 0 ? 0 : x > 1 ? 1 : x;  // saturate\n   q = (unsigned short)(x * 31);\n   q += (x > stb__midpoints5[q]);\n   return q;\n}\n\nstatic unsigned short stb__Quantize6(float x)\n{\n   unsigned short q;\n   x = x < 0 ? 0 : x > 1 ? 1 : x;  // saturate\n   q = (unsigned short)(x * 63);\n   q += (x > stb__midpoints6[q]);\n   return q;\n}\n\n// The refinement function. (Clever code, part 2)\n// Tries to optimize colors to suit block contents better.\n// (By solving a least squares system via normal equations+Cramer's rule)\nstatic int stb__RefineBlock(unsigned char *block, unsigned short *pmax16, unsigned short *pmin16, unsigned int mask)\n{\n   static const int w1Tab[4] = { 3,0,2,1 };\n   static const int prods[4] = { 0x090000,0x000900,0x040102,0x010402 };\n   // ^some magic to save a lot of multiplies in the accumulating loop...\n   // (precomputed products of weights for least squares system, accumulated inside one 32-bit register)\n\n   float f;\n   unsigned short oldMin, oldMax, min16, max16;\n   int i, akku = 0, xx,xy,yy;\n   int At1_r,At1_g,At1_b;\n   int At2_r,At2_g,At2_b;\n   unsigned int cm = mask;\n\n   oldMin = *pmin16;\n   oldMax = *pmax16;\n\n   if((mask ^ (mask<<2)) < 4) // all pixels have the same index?\n   {\n      // yes, linear system would be singular; solve using optimal\n      // single-color match on average color\n      int r = 8, g = 8, b = 8;\n      for (i=0;i<16;++i) {\n         r += block[i*4+0];\n         g += block[i*4+1];\n         b += block[i*4+2];\n      }\n\n      r >>= 4; g >>= 4; b >>= 4;\n\n      max16 = (stb__OMatch5[r][0]<<11) | (stb__OMatch6[g][0]<<5) | stb__OMatch5[b][0];\n      min16 = (stb__OMatch5[r][1]<<11) | (stb__OMatch6[g][1]<<5) | stb__OMatch5[b][1];\n   } else {\n      At1_r = At1_g = At1_b = 0;\n      At2_r = At2_g = At2_b = 0;\n      for (i=0;i<16;++i,cm>>=2) {\n         int step = cm&3;\n         int w1 = w1Tab[step];\n         int r = block[i*4+0];\n         int g = block[i*4+1];\n         int b = block[i*4+2];\n\n         akku    += prods[step];\n         At1_r   += w1*r;\n         At1_g   += w1*g;\n         At1_b   += w1*b;\n         At2_r   += r;\n         At2_g   += g;\n         At2_b   += b;\n      }\n\n      At2_r = 3*At2_r - At1_r;\n      At2_g = 3*At2_g - At1_g;\n      At2_b = 3*At2_b - At1_b;\n\n      // extract solutions and decide solvability\n      xx = akku >> 16;\n      yy = (akku >> 8) & 0xff;\n      xy = (akku >> 0) & 0xff;\n\n      f = 3.0f / 255.0f / (xx*yy - xy*xy);\n\n      max16 =  stb__Quantize5((At1_r*yy - At2_r * xy) * f) << 11;\n      max16 |= stb__Quantize6((At1_g*yy - At2_g * xy) * f) << 5;\n      max16 |= stb__Quantize5((At1_b*yy - At2_b * xy) * f) << 0;\n\n      min16 =  stb__Quantize5((At2_r*xx - At1_r * xy) * f) << 11;\n      min16 |= stb__Quantize6((At2_g*xx - At1_g * xy) * f) << 5;\n      min16 |= stb__Quantize5((At2_b*xx - At1_b * xy) * f) << 0;\n   }\n\n   *pmin16 = min16;\n   *pmax16 = max16;\n   return oldMin != min16 || oldMax != max16;\n}\n\n// Color block compression\nstatic void stb__CompressColorBlock(unsigned char *dest, unsigned char *block, int mode)\n{\n   unsigned int mask;\n   int i;\n   int refinecount;\n   unsigned short max16, min16;\n   unsigned char color[4*4];\n\n   refinecount = (mode & STB_DXT_HIGHQUAL) ? 2 : 1;\n\n   // check if block is constant\n   for (i=1;i<16;i++)\n      if (((unsigned int *) block)[i] != ((unsigned int *) block)[0])\n         break;\n\n   if(i == 16) { // constant color\n      int r = block[0], g = block[1], b = block[2];\n      mask  = 0xaaaaaaaa;\n      max16 = (stb__OMatch5[r][0]<<11) | (stb__OMatch6[g][0]<<5) | stb__OMatch5[b][0];\n      min16 = (stb__OMatch5[r][1]<<11) | (stb__OMatch6[g][1]<<5) | stb__OMatch5[b][1];\n   } else {\n      // first step: PCA+map along principal axis\n      stb__OptimizeColorsBlock(block,&max16,&min16);\n      if (max16 != min16) {\n         stb__EvalColors(color,max16,min16);\n         mask = stb__MatchColorsBlock(block,color);\n      } else\n         mask = 0;\n\n      // third step: refine (multiple times if requested)\n      for (i=0;i<refinecount;i++) {\n         unsigned int lastmask = mask;\n\n         if (stb__RefineBlock(block,&max16,&min16,mask)) {\n            if (max16 != min16) {\n               stb__EvalColors(color,max16,min16);\n               mask = stb__MatchColorsBlock(block,color);\n            } else {\n               mask = 0;\n               break;\n            }\n         }\n\n         if(mask == lastmask)\n            break;\n      }\n  }\n\n  // write the color block\n  if(max16 < min16)\n  {\n     unsigned short t = min16;\n     min16 = max16;\n     max16 = t;\n     mask ^= 0x55555555;\n  }\n\n  dest[0] = (unsigned char) (max16);\n  dest[1] = (unsigned char) (max16 >> 8);\n  dest[2] = (unsigned char) (min16);\n  dest[3] = (unsigned char) (min16 >> 8);\n  dest[4] = (unsigned char) (mask);\n  dest[5] = (unsigned char) (mask >> 8);\n  dest[6] = (unsigned char) (mask >> 16);\n  dest[7] = (unsigned char) (mask >> 24);\n}\n\n// Alpha block compression (this is easy for a change)\nstatic void stb__CompressAlphaBlock(unsigned char *dest,unsigned char *src, int stride)\n{\n   int i,dist,bias,dist4,dist2,bits,mask;\n\n   // find min/max color\n   int mn,mx;\n   mn = mx = src[0];\n\n   for (i=1;i<16;i++)\n   {\n      if (src[i*stride] < mn) mn = src[i*stride];\n      else if (src[i*stride] > mx) mx = src[i*stride];\n   }\n\n   // encode them\n   dest[0] = (unsigned char)mx;\n   dest[1] = (unsigned char)mn;\n   dest += 2;\n\n   // determine bias and emit color indices\n   // given the choice of mx/mn, these indices are optimal:\n   // http://fgiesen.wordpress.com/2009/12/15/dxt5-alpha-block-index-determination/\n   dist = mx-mn;\n   dist4 = dist*4;\n   dist2 = dist*2;\n   bias = (dist < 8) ? (dist - 1) : (dist/2 + 2);\n   bias -= mn * 7;\n   bits = 0,mask=0;\n\n   for (i=0;i<16;i++) {\n      int a = src[i*stride]*7 + bias;\n      int ind,t;\n\n      // select index. this is a \"linear scale\" lerp factor between 0 (val=min) and 7 (val=max).\n      t = (a >= dist4) ? -1 : 0; ind =  t & 4; a -= dist4 & t;\n      t = (a >= dist2) ? -1 : 0; ind += t & 2; a -= dist2 & t;\n      ind += (a >= dist);\n\n      // turn linear scale into DXT index (0/1 are extremal pts)\n      ind = -ind & 7;\n      ind ^= (2 > ind);\n\n      // write index\n      mask |= ind << bits;\n      if((bits += 3) >= 8) {\n         *dest++ = (unsigned char)mask;\n         mask >>= 8;\n         bits -= 8;\n      }\n   }\n}\n\nvoid stb_compress_dxt_block(unsigned char *dest, const unsigned char *src, int alpha, int mode)\n{\n   unsigned char data[16][4];\n   if (alpha) {\n      int i;\n      stb__CompressAlphaBlock(dest,(unsigned char*) src+3, 4);\n      dest += 8;\n      // make a new copy of the data in which alpha is opaque,\n      // because code uses a fast test for color constancy\n      memcpy(data, src, 4*16);\n      for (i=0; i < 16; ++i)\n         data[i][3] = 255;\n      src = &data[0][0];\n   }\n\n   stb__CompressColorBlock(dest,(unsigned char*) src,mode);\n}\n\nvoid stb_compress_bc4_block(unsigned char *dest, const unsigned char *src)\n{\n   stb__CompressAlphaBlock(dest,(unsigned char*) src, 1);\n}\n\nvoid stb_compress_bc5_block(unsigned char *dest, const unsigned char *src)\n{\n   stb__CompressAlphaBlock(dest,(unsigned char*) src,2);\n   stb__CompressAlphaBlock(dest + 8,(unsigned char*) src+1,2);\n}\n#endif // STB_DXT_IMPLEMENTATION\n\n// Compile with STB_DXT_IMPLEMENTATION and STB_DXT_GENERATE_TABLES\n// defined to generate the tables above.\n#ifdef STB_DXT_GENERATE_TABLES\n#include <stdio.h>\n\nint main()\n{\n   int i, j;\n   const char *omatch_names[] = { \"stb__OMatch5\", \"stb__OMatch6\" };\n   int dequant_mults[2] = { 33*4, 65 }; // .4 fixed-point dequant multipliers\n\n   // optimal endpoint tables\n   for (i = 0; i < 2; ++i) {\n      int dequant = dequant_mults[i];\n      int size = i ? 64 : 32;\n      printf(\"static const unsigned char %s[256][2] = {\\n\", omatch_names[i]);\n      for (int j = 0; j < 256; ++j) {\n         int mn, mx;\n         int best_mn = 0, best_mx = 0;\n         int best_err = 256 * 100;\n         for (mn=0;mn<size;mn++) {\n            for (mx=0;mx<size;mx++) {\n               int mine = (mn * dequant) >> 4;\n               int maxe = (mx * dequant) >> 4;\n               int err = abs(stb__Lerp13(maxe, mine) - j) * 100;\n\n               // DX10 spec says that interpolation must be within 3% of \"correct\" result,\n               // add this as error term. Normally we'd expect a random distribution of\n               // +-1.5% error, but nowhere in the spec does it say that the error has to be\n               // unbiased - better safe than sorry.\n               err += abs(maxe - mine) * 3;\n\n               if(err < best_err) {\n                  best_mn = mn;\n                  best_mx = mx;\n                  best_err = err;\n               }\n            }\n         }\n         if ((j % 8) == 0) printf(\"  \"); // 2 spaces, third is done below\n         printf(\" { %2d, %2d },\", best_mx, best_mn);\n         if ((j % 8) == 7) printf(\"\\n\");\n      }\n      printf(\"};\\n\");\n   }\n\n   return 0;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_easy_font.h",
          "type": "blob",
          "size": 12.5126953125,
          "content": "// stb_easy_font.h - v1.1 - bitmap font for 3D rendering - public domain\n// Sean Barrett, Feb 2015\n//\n//    Easy-to-deploy,\n//    reasonably compact,\n//    extremely inefficient performance-wise,\n//    crappy-looking,\n//    ASCII-only,\n//    bitmap font for use in 3D APIs.\n//\n// Intended for when you just want to get some text displaying\n// in a 3D app as quickly as possible.\n//\n// Doesn't use any textures, instead builds characters out of quads.\n//\n// DOCUMENTATION:\n//\n//   int stb_easy_font_width(char *text)\n//   int stb_easy_font_height(char *text)\n//\n//      Takes a string and returns the horizontal size and the\n//      vertical size (which can vary if 'text' has newlines).\n//\n//   int stb_easy_font_print(float x, float y,\n//                           char *text, unsigned char color[4],\n//                           void *vertex_buffer, int vbuf_size)\n//\n//      Takes a string (which can contain '\\n') and fills out a\n//      vertex buffer with renderable data to draw the string.\n//      Output data assumes increasing x is rightwards, increasing y\n//      is downwards.\n//\n//      The vertex data is divided into quads, i.e. there are four\n//      vertices in the vertex buffer for each quad.\n//\n//      The vertices are stored in an interleaved format:\n//\n//         x:float\n//         y:float\n//         z:float\n//         color:uint8[4]\n//\n//      You can ignore z and color if you get them from elsewhere\n//      This format was chosen in the hopes it would make it\n//      easier for you to reuse existing vertex-buffer-drawing code.\n//\n//      If you pass in NULL for color, it becomes 255,255,255,255.\n//\n//      Returns the number of quads.\n//\n//      If the buffer isn't large enough, it will truncate.\n//      Expect it to use an average of ~270 bytes per character.\n//\n//      If your API doesn't draw quads, build a reusable index\n//      list that allows you to render quads as indexed triangles.\n//\n//   void stb_easy_font_spacing(float spacing)\n//\n//      Use positive values to expand the space between characters,\n//      and small negative values (no smaller than -1.5) to contract\n//      the space between characters.\n//\n//      E.g. spacing = 1 adds one \"pixel\" of spacing between the\n//      characters. spacing = -1 is reasonable but feels a bit too\n//      compact to me; -0.5 is a reasonable compromise as long as\n//      you're scaling the font up.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// VERSION HISTORY\n//\n//   (2020-02-02)  1.1   make everything static so can compile it in more than one src file\n//   (2017-01-15)  1.0   space character takes same space as numbers; fix bad spacing of 'f'\n//   (2016-01-22)  0.7   width() supports multiline text; add height()\n//   (2015-09-13)  0.6   #include <math.h>; updated license\n//   (2015-02-01)  0.5   First release\n//\n// CONTRIBUTORS\n//\n//   github:vassvik    --  bug report\n//   github:podsvirov  --  fix multiple definition errors\n\n#if 0\n// SAMPLE CODE:\n//\n//    Here's sample code for old OpenGL; it's a lot more complicated\n//    to make work on modern APIs, and that's your problem.\n//\nvoid print_string(float x, float y, char *text, float r, float g, float b)\n{\n  static char buffer[99999]; // ~500 chars\n  int num_quads;\n\n  num_quads = stb_easy_font_print(x, y, text, NULL, buffer, sizeof(buffer));\n\n  glColor3f(r,g,b);\n  glEnableClientState(GL_VERTEX_ARRAY);\n  glVertexPointer(2, GL_FLOAT, 16, buffer);\n  glDrawArrays(GL_QUADS, 0, num_quads*4);\n  glDisableClientState(GL_VERTEX_ARRAY);\n}\n#endif\n\n#ifndef INCLUDE_STB_EASY_FONT_H\n#define INCLUDE_STB_EASY_FONT_H\n\n#include <stdlib.h>\n#include <math.h>\n\nstatic struct stb_easy_font_info_struct {\n    unsigned char advance;\n    unsigned char h_seg;\n    unsigned char v_seg;\n} stb_easy_font_charinfo[96] = {\n    {  6,  0,  0 },  {  3,  0,  0 },  {  5,  1,  1 },  {  7,  1,  4 },\n    {  7,  3,  7 },  {  7,  6, 12 },  {  7,  8, 19 },  {  4, 16, 21 },\n    {  4, 17, 22 },  {  4, 19, 23 },  { 23, 21, 24 },  { 23, 22, 31 },\n    { 20, 23, 34 },  { 22, 23, 36 },  { 19, 24, 36 },  { 21, 25, 36 },\n    {  6, 25, 39 },  {  6, 27, 43 },  {  6, 28, 45 },  {  6, 30, 49 },\n    {  6, 33, 53 },  {  6, 34, 57 },  {  6, 40, 58 },  {  6, 46, 59 },\n    {  6, 47, 62 },  {  6, 55, 64 },  { 19, 57, 68 },  { 20, 59, 68 },\n    { 21, 61, 69 },  { 22, 66, 69 },  { 21, 68, 69 },  {  7, 73, 69 },\n    {  9, 75, 74 },  {  6, 78, 81 },  {  6, 80, 85 },  {  6, 83, 90 },\n    {  6, 85, 91 },  {  6, 87, 95 },  {  6, 90, 96 },  {  7, 92, 97 },\n    {  6, 96,102 },  {  5, 97,106 },  {  6, 99,107 },  {  6,100,110 },\n    {  6,100,115 },  {  7,101,116 },  {  6,101,121 },  {  6,101,125 },\n    {  6,102,129 },  {  7,103,133 },  {  6,104,140 },  {  6,105,145 },\n    {  7,107,149 },  {  6,108,151 },  {  7,109,155 },  {  7,109,160 },\n    {  7,109,165 },  {  7,118,167 },  {  6,118,172 },  {  4,120,176 },\n    {  6,122,177 },  {  4,122,181 },  { 23,124,182 },  { 22,129,182 },\n    {  4,130,182 },  { 22,131,183 },  {  6,133,187 },  { 22,135,191 },\n    {  6,137,192 },  { 22,139,196 },  {  6,144,197 },  { 22,147,198 },\n    {  6,150,202 },  { 19,151,206 },  { 21,152,207 },  {  6,155,209 },\n    {  3,160,210 },  { 23,160,211 },  { 22,164,216 },  { 22,165,220 },\n    { 22,167,224 },  { 22,169,228 },  { 21,171,232 },  { 21,173,233 },\n    {  5,178,233 },  { 22,179,234 },  { 23,180,238 },  { 23,180,243 },\n    { 23,180,248 },  { 22,189,248 },  { 22,191,252 },  {  5,196,252 },\n    {  3,203,252 },  {  5,203,253 },  { 22,210,253 },  {  0,214,253 },\n};\n\nstatic unsigned char stb_easy_font_hseg[214] = {\n   97,37,69,84,28,51,2,18,10,49,98,41,65,25,81,105,33,9,97,1,97,37,37,36,\n    81,10,98,107,3,100,3,99,58,51,4,99,58,8,73,81,10,50,98,8,73,81,4,10,50,\n    98,8,25,33,65,81,10,50,17,65,97,25,33,25,49,9,65,20,68,1,65,25,49,41,\n    11,105,13,101,76,10,50,10,50,98,11,99,10,98,11,50,99,11,50,11,99,8,57,\n    58,3,99,99,107,10,10,11,10,99,11,5,100,41,65,57,41,65,9,17,81,97,3,107,\n    9,97,1,97,33,25,9,25,41,100,41,26,82,42,98,27,83,42,98,26,51,82,8,41,\n    35,8,10,26,82,114,42,1,114,8,9,73,57,81,41,97,18,8,8,25,26,26,82,26,82,\n    26,82,41,25,33,82,26,49,73,35,90,17,81,41,65,57,41,65,25,81,90,114,20,\n    84,73,57,41,49,25,33,65,81,9,97,1,97,25,33,65,81,57,33,25,41,25,\n};\n\nstatic unsigned char stb_easy_font_vseg[253] = {\n   4,2,8,10,15,8,15,33,8,15,8,73,82,73,57,41,82,10,82,18,66,10,21,29,1,65,\n    27,8,27,9,65,8,10,50,97,74,66,42,10,21,57,41,29,25,14,81,73,57,26,8,8,\n    26,66,3,8,8,15,19,21,90,58,26,18,66,18,105,89,28,74,17,8,73,57,26,21,\n    8,42,41,42,8,28,22,8,8,30,7,8,8,26,66,21,7,8,8,29,7,7,21,8,8,8,59,7,8,\n    8,15,29,8,8,14,7,57,43,10,82,7,7,25,42,25,15,7,25,41,15,21,105,105,29,\n    7,57,57,26,21,105,73,97,89,28,97,7,57,58,26,82,18,57,57,74,8,30,6,8,8,\n    14,3,58,90,58,11,7,74,43,74,15,2,82,2,42,75,42,10,67,57,41,10,7,2,42,\n    74,106,15,2,35,8,8,29,7,8,8,59,35,51,8,8,15,35,30,35,8,8,30,7,8,8,60,\n    36,8,45,7,7,36,8,43,8,44,21,8,8,44,35,8,8,43,23,8,8,43,35,8,8,31,21,15,\n    20,8,8,28,18,58,89,58,26,21,89,73,89,29,20,8,8,30,7,\n};\n\ntypedef struct\n{\n   unsigned char c[4];\n} stb_easy_font_color;\n\nstatic int stb_easy_font_draw_segs(float x, float y, unsigned char *segs, int num_segs, int vertical, stb_easy_font_color c, char *vbuf, int vbuf_size, int offset)\n{\n    int i,j;\n    for (i=0; i < num_segs; ++i) {\n        int len = segs[i] & 7;\n        x += (float) ((segs[i] >> 3) & 1);\n        if (len && offset+64 <= vbuf_size) {\n            float y0 = y + (float) (segs[i]>>4);\n            for (j=0; j < 4; ++j) {\n                * (float *) (vbuf+offset+0) = x  + (j==1 || j==2 ? (vertical ? 1 : len) : 0);\n                * (float *) (vbuf+offset+4) = y0 + (    j >= 2   ? (vertical ? len : 1) : 0);\n                * (float *) (vbuf+offset+8) = 0.f;\n                * (stb_easy_font_color *) (vbuf+offset+12) = c;\n                offset += 16;\n            }\n        }\n    }\n    return offset;\n}\n\nstatic float stb_easy_font_spacing_val = 0;\nstatic void stb_easy_font_spacing(float spacing)\n{\n   stb_easy_font_spacing_val = spacing;\n}\n\nstatic int stb_easy_font_print(float x, float y, char *text, unsigned char color[4], void *vertex_buffer, int vbuf_size)\n{\n    char *vbuf = (char *) vertex_buffer;\n    float start_x = x;\n    int offset = 0;\n\n    stb_easy_font_color c = { 255,255,255,255 }; // use structure copying to avoid needing depending on memcpy()\n    if (color) { c.c[0] = color[0]; c.c[1] = color[1]; c.c[2] = color[2]; c.c[3] = color[3]; }\n\n    while (*text && offset < vbuf_size) {\n        if (*text == '\\n') {\n            y += 12;\n            x = start_x;\n        } else {\n            unsigned char advance = stb_easy_font_charinfo[*text-32].advance;\n            float y_ch = advance & 16 ? y+1 : y;\n            int h_seg, v_seg, num_h, num_v;\n            h_seg = stb_easy_font_charinfo[*text-32  ].h_seg;\n            v_seg = stb_easy_font_charinfo[*text-32  ].v_seg;\n            num_h = stb_easy_font_charinfo[*text-32+1].h_seg - h_seg;\n            num_v = stb_easy_font_charinfo[*text-32+1].v_seg - v_seg;\n            offset = stb_easy_font_draw_segs(x, y_ch, &stb_easy_font_hseg[h_seg], num_h, 0, c, vbuf, vbuf_size, offset);\n            offset = stb_easy_font_draw_segs(x, y_ch, &stb_easy_font_vseg[v_seg], num_v, 1, c, vbuf, vbuf_size, offset);\n            x += advance & 15;\n            x += stb_easy_font_spacing_val;\n        }\n        ++text;\n    }\n    return (unsigned) offset/64;\n}\n\nstatic int stb_easy_font_width(char *text)\n{\n    float len = 0;\n    float max_len = 0;\n    while (*text) {\n        if (*text == '\\n') {\n            if (len > max_len) max_len = len;\n            len = 0;\n        } else {\n            len += stb_easy_font_charinfo[*text-32].advance & 15;\n            len += stb_easy_font_spacing_val;\n        }\n        ++text;\n    }\n    if (len > max_len) max_len = len;\n    return (int) ceil(max_len);\n}\n\nstatic int stb_easy_font_height(char *text)\n{\n    float y = 0;\n    int nonempty_line=0;\n    while (*text) {\n        if (*text == '\\n') {\n            y += 12;\n            nonempty_line = 0;\n        } else {\n            nonempty_line = 1;\n        }\n        ++text;\n    }\n    return (int) ceil(y + (nonempty_line ? 12 : 0));\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_herringbone_wang_tile.h",
          "type": "blob",
          "size": 42.1552734375,
          "content": "/* stbhw - v0.7 -  http://nothings.org/gamedev/herringbone\n   Herringbone Wang Tile Generator - Sean Barrett 2014 - public domain\n\n== LICENSE ==============================\n\nThis software is dual-licensed to the public domain and under the following\nlicense: you are granted a perpetual, irrevocable license to copy, modify,\npublish, and distribute this file as you see fit.\n\n== WHAT IT IS ===========================\n\n This library is an SDK for Herringbone Wang Tile generation:\n\n      http://nothings.org/gamedev/herringbone\n\n The core design is that you use this library offline to generate a\n \"template\" of the tiles you'll create. You then edit those tiles, then\n load the created tile image file back into this library and use it at\n runtime to generate \"maps\".\n\n You cannot load arbitrary tile image files with this library; it is\n only designed to load image files made from the template it created.\n It stores a binary description of the tile sizes & constraints in a\n few pixels, and uses those to recover the rules, rather than trying\n to parse the tiles themselves.\n\n You *can* use this library to generate from arbitrary tile sets, but\n only by loading the tile set and specifying the constraints explicitly\n yourself.\n\n== COMPILING ============================\n\n 1. #define STB_HERRINGBONE_WANG_TILE_IMPLEMENTATION before including this\n    header file in *one* source file to create the implementation\n    in that source file.\n\n 2. optionally #define STB_HBWANG_RAND() to be a random number\n    generator. if you don't define it, it will use rand(),\n    and you need to seed srand() yourself.\n\n 3. optionally #define STB_HBWANG_ASSERT(x), otherwise\n    it will use assert()\n\n 4. optionally #define STB_HBWANG_STATIC to force all symbols to be\n    static instead of public, so they are only accesible\n    in the source file that creates the implementation\n\n 5. optionally #define STB_HBWANG_NO_REPITITION_REDUCTION to disable\n    the code that tries to reduce having the same tile appear\n    adjacent to itself in wang-corner-tile mode (e.g. imagine\n    if you were doing something where 90% of things should be\n    the same grass tile, you need to disable this system)\n\n 6. optionally define STB_HBWANG_MAX_X and STB_HBWANG_MAX_Y\n    to be the max dimensions of the generated map in multiples\n    of the wang tile's short side's length (e.g. if you\n    have 20x10 wang tiles, so short_side_len=10, and you\n    have MAX_X is 17, then the largest map you can generate\n    is 170 pixels wide). The defaults are 100x100. This\n    is used to define static arrays which affect memory\n    usage.\n\n== USING ================================\n\n  To use the map generator, you need a tileset. You can download\n  some sample tilesets from http://nothings.org/gamedev/herringbone\n\n  Then see the \"sample application\" below.\n\n  You can also use this file to generate templates for\n  tilesets which you then hand-edit to create the data.\n\n\n== MEMORY MANAGEMENT ====================\n\n  The tileset loader allocates memory with malloc(). The map\n  generator does no memory allocation, so e.g. you can load\n  tilesets at startup and never free them and never do any\n  further allocation.\n\n\n== SAMPLE APPLICATION ===================\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"        // http://nothings.org/stb_image.c\n\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#include \"stb_image_write.h\"  // http://nothings.org/stb/stb_image_write.h\n\n#define STB_HBWANG_IMPLEMENTATION\n#include \"stb_hbwang.h\"\n\nint main(int argc, char **argv)\n{\n   unsigned char *data;\n   int xs,ys, w,h;\n   stbhw_tileset ts;\n\n   if (argc != 4) {\n      fprintf(stderr, \"Usage: mapgen {tile-file} {xsize} {ysize}\\n\"\n                      \"generates file named 'test_map.png'\\n\");\n      exit(1);\n   }\n   data = stbi_load(argv[1], &w, &h, NULL, 3);\n   xs = atoi(argv[2]);\n   ys = atoi(argv[3]);\n   if (data == NULL) {\n      fprintf(stderr, \"Error opening or parsing '%s' as an image file\\n\", argv[1]);\n      exit(1);\n   }\n   if (xs < 1 || xs > 1000) {\n      fprintf(stderr, \"xsize invalid or out of range\\n\");\n      exit(1);\n   }\n   if (ys < 1 || ys > 1000) {\n      fprintf(stderr, \"ysize invalid or out of range\\n\");\n      exit(1);\n   }\n\n   stbhw_build_tileset_from_image(&ts, data, w*3, w, h);\n   free(data);\n\n   // allocate a buffer to create the final image to\n   data = malloc(3 * xs * ys);\n\n   srand(time(NULL));\n   stbhw_generate_image(&ts, NULL, data, xs*3, xs, ys);\n\n   stbi_write_png(\"test_map.png\", xs, ys, 3, data, xs*3);\n\n   stbhw_free_tileset(&ts);\n   free(data);\n\n   return 0;\n}\n\n== VERSION HISTORY ===================\n\n   0.7   2019-03-04   - fix warnings\n\t0.6   2014-08-17   - fix broken map-maker\n\t0.5   2014-07-07   - initial release\n\n*/\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                         HEADER FILE SECTION                              //\n//                                                                          //\n\n#ifndef INCLUDE_STB_HWANG_H\n#define INCLUDE_STB_HWANG_H\n\n#ifdef STB_HBWANG_STATIC\n#define STBHW_EXTERN static\n#else\n#ifdef __cplusplus\n#define STBHW_EXTERN extern \"C\"\n#else\n#define STBHW_EXTERN extern\n#endif\n#endif\n\ntypedef struct stbhw_tileset stbhw_tileset;\n\n// returns description of last error produced by any function (not thread-safe)\nSTBHW_EXTERN const char *stbhw_get_last_error(void);\n\n// build a tileset from an image that conforms to a template created by this\n// library. (you allocate storage for stbhw_tileset and function fills it out;\n// memory for individual tiles are malloc()ed).\n// returns non-zero on success, 0 on error\nSTBHW_EXTERN int stbhw_build_tileset_from_image(stbhw_tileset *ts,\n                     unsigned char *pixels, int stride_in_bytes, int w, int h);\n\n// free a tileset built by stbhw_build_tileset_from_image\nSTBHW_EXTERN void stbhw_free_tileset(stbhw_tileset *ts);\n\n// generate a map that is w * h pixels (3-bytes each)\n// returns non-zero on success, 0 on error\n// not thread-safe (uses a global data structure to avoid memory management)\n// weighting should be NULL, as non-NULL weighting is currently untested\nSTBHW_EXTERN int stbhw_generate_image(stbhw_tileset *ts, int **weighting,\n                     unsigned char *pixels, int stride_in_bytes, int w, int h);\n\n//////////////////////////////////////\n//\n// TILESET DATA STRUCTURE\n//\n// if you use the image-to-tileset system from this file, you\n// don't need to worry about these data structures. but if you\n// want to build/load a tileset yourself, you'll need to fill\n// these out.\n\ntypedef struct\n{\n   // the edge or vertex constraints, according to diagram below\n   signed char a,b,c,d,e,f;\n\n   // The herringbone wang tile data; it is a bitmap which is either\n   // w=2*short_sidelen,h=short_sidelen, or w=short_sidelen,h=2*short_sidelen.\n   // it is always RGB, stored row-major, with no padding between rows.\n   // (allocate stbhw_tile structure to be large enough for the pixel data)\n   unsigned char pixels[1];\n} stbhw_tile;\n\nstruct stbhw_tileset\n{\n   int is_corner;\n   int num_color[6];  // number of colors for each of 6 edge types or 4 corner types\n   int short_side_len;\n   stbhw_tile **h_tiles;\n   stbhw_tile **v_tiles;\n   int num_h_tiles, max_h_tiles;\n   int num_v_tiles, max_v_tiles;\n};\n\n///////////////  TEMPLATE GENERATOR  //////////////////////////\n\n// when requesting a template, you fill out this data\ntypedef struct\n{\n   int is_corner;      // using corner colors or edge colors?\n   int short_side_len; // rectangles is 2n x n, n = short_side_len\n   int num_color[6];   // see below diagram for meaning of the index to this;\n                       // 6 values if edge (!is_corner), 4 values if is_corner\n                       // legal numbers: 1..8 if edge, 1..4 if is_corner\n   int num_vary_x;     // additional number of variations along x axis in the template\n   int num_vary_y;     // additional number of variations along y axis in the template\n   int corner_type_color_template[4][4];\n      // if corner_type_color_template[s][t] is non-zero, then any\n      // corner of type s generated as color t will get a little\n      // corner sample markup in the template image data\n\n} stbhw_config;\n\n// computes the size needed for the template image\nSTBHW_EXTERN void stbhw_get_template_size(stbhw_config *c, int *w, int *h);\n\n// generates a template image, assuming data is 3*w*h bytes long, RGB format\nSTBHW_EXTERN int stbhw_make_template(stbhw_config *c, unsigned char *data, int w, int h, int stride_in_bytes);\n\n#endif//INCLUDE_STB_HWANG_H\n\n\n// TILE CONSTRAINT TYPES\n//\n// there are 4 \"types\" of corners and 6 types of edges.\n// you can configure the tileset to have different numbers\n// of colors for each type of color or edge.\n//\n// corner types:\n//\n//                     0---*---1---*---2---*---3\n//                     |       |               |\n//                     *       *               *\n//                     |       |               |\n//     1---*---2---*---3       0---*---1---*---2\n//     |               |       |\n//     *               *       *\n//     |               |       |\n//     0---*---1---*---2---*---3\n//\n//\n//  edge types:\n//\n//     *---2---*---3---*      *---0---*\n//     |               |      |       |\n//     1               4      5       1\n//     |               |      |       |\n//     *---0---*---2---*      *       *\n//                            |       |\n//                            4       5\n//                            |       |\n//                            *---3---*\n//\n// TILE CONSTRAINTS\n//\n// each corner/edge has a color; this shows the name\n// of the variable containing the color\n//\n// corner constraints:\n//\n//                        a---*---d\n//                        |       |\n//                        *       *\n//                        |       |\n//     a---*---b---*---c  b       e\n//     |               |  |       |\n//     *               *  *       *\n//     |               |  |       |\n//     d---*---e---*---f  c---*---f\n//\n//\n//  edge constraints:\n//\n//     *---a---*---b---*      *---a---*\n//     |               |      |       |\n//     c               d      b       c\n//     |               |      |       |\n//     *---e---*---f---*      *       *\n//                            |       |\n//                            d       e\n//                            |       |\n//                            *---f---*\n//\n\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                       IMPLEMENTATION SECTION                             //\n//                                                                          //\n\n#ifdef STB_HERRINGBONE_WANG_TILE_IMPLEMENTATION\n\n\n#include <string.h> // memcpy\n#include <stdlib.h> // malloc\n\n#ifndef STB_HBWANG_RAND\n#include <stdlib.h>\n#define STB_HBWANG_RAND()  (rand() >> 4)\n#endif\n\n#ifndef STB_HBWANG_ASSERT\n#include <assert.h>\n#define STB_HBWANG_ASSERT(x)  assert(x)\n#endif\n\n// map size\n#ifndef STB_HBWANG_MAX_X\n#define STB_HBWANG_MAX_X  100\n#endif\n\n#ifndef STB_HBWANG_MAX_Y\n#define STB_HBWANG_MAX_Y  100\n#endif\n\n// global variables for color assignments\n// @MEMORY change these to just store last two/three rows\n//         and keep them on the stack\nstatic signed char c_color[STB_HBWANG_MAX_Y+6][STB_HBWANG_MAX_X+6];\nstatic signed char v_color[STB_HBWANG_MAX_Y+6][STB_HBWANG_MAX_X+5];\nstatic signed char h_color[STB_HBWANG_MAX_Y+5][STB_HBWANG_MAX_X+6];\n\nstatic const char *stbhw_error;\nSTBHW_EXTERN const char *stbhw_get_last_error(void)\n{\n   const char *temp = stbhw_error;\n   stbhw_error = 0;\n   return temp;\n}\n\n\n\n\n/////////////////////////////////////////////////////////////\n//\n//  SHARED TEMPLATE-DESCRIPTION CODE\n//\n//  Used by both template generator and tileset parser; by\n//  using the same code, they are locked in sync and we don't\n//  need to try to do more sophisticated parsing of edge color\n//  markup or something.\n\ntypedef void stbhw__process_rect(struct stbhw__process *p, int xpos, int ypos,\n                                 int a, int b, int c, int d, int e, int f);\n\ntypedef struct stbhw__process\n{\n   stbhw_tileset *ts;\n   stbhw_config *c;\n   stbhw__process_rect *process_h_rect;\n   stbhw__process_rect *process_v_rect;\n   unsigned char *data;\n   int stride,w,h;\n} stbhw__process;\n\nstatic void stbhw__process_h_row(stbhw__process *p,\n                           int xpos, int ypos,\n                           int a0, int a1,\n                           int b0, int b1,\n                           int c0, int c1,\n                           int d0, int d1,\n                           int e0, int e1,\n                           int f0, int f1,\n                           int variants)\n{\n   int a,b,c,d,e,f,v;\n\n   for (v=0; v < variants; ++v)\n      for (f=f0; f <= f1; ++f)\n         for (e=e0; e <= e1; ++e)\n            for (d=d0; d <= d1; ++d)\n               for (c=c0; c <= c1; ++c)\n                  for (b=b0; b <= b1; ++b)\n                     for (a=a0; a <= a1; ++a) {\n                        p->process_h_rect(p, xpos, ypos, a,b,c,d,e,f);\n                        xpos += 2*p->c->short_side_len + 3;\n                     }\n}\n\nstatic void stbhw__process_v_row(stbhw__process *p,\n                           int xpos, int ypos,\n                           int a0, int a1,\n                           int b0, int b1,\n                           int c0, int c1,\n                           int d0, int d1,\n                           int e0, int e1,\n                           int f0, int f1,\n                           int variants)\n{\n   int a,b,c,d,e,f,v;\n\n   for (v=0; v < variants; ++v)\n      for (f=f0; f <= f1; ++f)\n         for (e=e0; e <= e1; ++e)\n            for (d=d0; d <= d1; ++d)\n               for (c=c0; c <= c1; ++c)\n                  for (b=b0; b <= b1; ++b)\n                     for (a=a0; a <= a1; ++a) {\n                        p->process_v_rect(p, xpos, ypos, a,b,c,d,e,f);\n                        xpos += p->c->short_side_len+3;\n                     }\n}\n\nstatic void stbhw__get_template_info(stbhw_config *c, int *w, int *h, int *h_count, int *v_count)\n{\n   int size_x,size_y;\n   int horz_count,vert_count;\n\n   if (c->is_corner) {\n      int horz_w = c->num_color[1] * c->num_color[2] * c->num_color[3] * c->num_vary_x;\n      int horz_h = c->num_color[0] * c->num_color[1] * c->num_color[2] * c->num_vary_y;\n\n      int vert_w = c->num_color[0] * c->num_color[3] * c->num_color[2] * c->num_vary_y;\n      int vert_h = c->num_color[1] * c->num_color[0] * c->num_color[3] * c->num_vary_x;\n\n      int horz_x = horz_w * (2*c->short_side_len + 3);\n      int horz_y = horz_h * (  c->short_side_len + 3);\n\n      int vert_x = vert_w * (  c->short_side_len + 3);\n      int vert_y = vert_h * (2*c->short_side_len + 3);\n\n      horz_count = horz_w * horz_h;\n      vert_count = vert_w * vert_h;\n\n      size_x = horz_x > vert_x ? horz_x : vert_x;\n      size_y = 2 + horz_y + 2 + vert_y;\n   } else {\n      int horz_w = c->num_color[0] * c->num_color[1] * c->num_color[2] * c->num_vary_x;\n      int horz_h = c->num_color[3] * c->num_color[4] * c->num_color[2] * c->num_vary_y;\n\n      int vert_w = c->num_color[0] * c->num_color[5] * c->num_color[1] * c->num_vary_y;\n      int vert_h = c->num_color[3] * c->num_color[4] * c->num_color[5] * c->num_vary_x;\n\n      int horz_x = horz_w * (2*c->short_side_len + 3);\n      int horz_y = horz_h * (  c->short_side_len + 3);\n\n      int vert_x = vert_w * (  c->short_side_len + 3);\n      int vert_y = vert_h * (2*c->short_side_len + 3);\n\n      horz_count = horz_w * horz_h;\n      vert_count = vert_w * vert_h;\n\n      size_x = horz_x > vert_x ? horz_x : vert_x;\n      size_y = 2 + horz_y + 2 + vert_y;\n   }\n   if (w) *w = size_x;\n   if (h) *h = size_y;\n   if (h_count) *h_count = horz_count;\n   if (v_count) *v_count = vert_count;\n}\n\nSTBHW_EXTERN void stbhw_get_template_size(stbhw_config *c, int *w, int *h)\n{\n   stbhw__get_template_info(c, w, h, NULL, NULL);\n}\n\nstatic int stbhw__process_template(stbhw__process *p)\n{\n   int i,j,k,q, ypos;\n   int size_x, size_y;\n   stbhw_config *c = p->c;\n\n   stbhw__get_template_info(c, &size_x, &size_y, NULL, NULL);\n\n   if (p->w < size_x || p->h < size_y) {\n      stbhw_error = \"image too small for configuration\";\n      return 0;\n   }\n\n   if (c->is_corner) {\n      ypos = 2;\n      for (k=0; k < c->num_color[2]; ++k) {\n         for (j=0; j < c->num_color[1]; ++j) {\n            for (i=0; i < c->num_color[0]; ++i) {\n               for (q=0; q < c->num_vary_y; ++q) {\n                  stbhw__process_h_row(p, 0,ypos,\n                     0,c->num_color[1]-1, 0,c->num_color[2]-1, 0,c->num_color[3]-1,\n                     i,i, j,j, k,k,\n                     c->num_vary_x);\n                  ypos += c->short_side_len + 3;\n               }\n            }\n         }\n      }\n      ypos += 2;\n      for (k=0; k < c->num_color[3]; ++k) {\n         for (j=0; j < c->num_color[0]; ++j) {\n            for (i=0; i < c->num_color[1]; ++i) {\n               for (q=0; q < c->num_vary_x; ++q) {\n                  stbhw__process_v_row(p, 0,ypos,\n                     0,c->num_color[0]-1, 0,c->num_color[3]-1, 0,c->num_color[2]-1,\n                     i,i, j,j, k,k,\n                     c->num_vary_y);\n                  ypos += (c->short_side_len*2) + 3;\n               }\n            }\n         }\n      }\n      assert(ypos == size_y);\n   } else {\n      ypos = 2;\n      for (k=0; k < c->num_color[3]; ++k) {\n         for (j=0; j < c->num_color[4]; ++j) {\n            for (i=0; i < c->num_color[2]; ++i) {\n               for (q=0; q < c->num_vary_y; ++q) {\n                  stbhw__process_h_row(p, 0,ypos,\n                     0,c->num_color[2]-1, k,k,\n                     0,c->num_color[1]-1, j,j,\n                     0,c->num_color[0]-1, i,i,\n                     c->num_vary_x);\n                  ypos += c->short_side_len + 3;\n               }\n            }\n         }\n      }\n      ypos += 2;\n      for (k=0; k < c->num_color[3]; ++k) {\n         for (j=0; j < c->num_color[4]; ++j) {\n            for (i=0; i < c->num_color[5]; ++i) {\n               for (q=0; q < c->num_vary_x; ++q) {\n                  stbhw__process_v_row(p, 0,ypos,\n                     0,c->num_color[0]-1, i,i,\n                     0,c->num_color[1]-1, j,j,\n                     0,c->num_color[5]-1, k,k,\n                     c->num_vary_y);\n                  ypos += (c->short_side_len*2) + 3;\n               }\n            }\n         }\n      }\n      assert(ypos == size_y);\n   }\n   return 1;\n}\n\n\n/////////////////////////////////////////////////////////////\n//\n//  MAP GENERATOR\n//\n\nstatic void stbhw__draw_pixel(unsigned char *output, int stride, int x, int y, unsigned char c[3])\n{\n   memcpy(output + y*stride + x*3, c, 3);\n}\n\nstatic void stbhw__draw_h_tile(unsigned char *output, int stride, int xmax, int ymax, int x, int y, stbhw_tile *h, int sz)\n{\n   int i,j;\n   for (j=0; j < sz; ++j)\n      if (y+j >= 0 && y+j < ymax)\n         for (i=0; i < sz*2; ++i)\n            if (x+i >= 0 && x+i < xmax)\n               stbhw__draw_pixel(output,stride, x+i,y+j, &h->pixels[(j*sz*2 + i)*3]);\n}\n\nstatic void stbhw__draw_v_tile(unsigned char *output, int stride, int xmax, int ymax, int x, int y, stbhw_tile *h, int sz)\n{\n   int i,j;\n   for (j=0; j < sz*2; ++j)\n      if (y+j >= 0 && y+j < ymax)\n         for (i=0; i < sz; ++i)\n            if (x+i >= 0 && x+i < xmax)\n               stbhw__draw_pixel(output,stride, x+i,y+j, &h->pixels[(j*sz + i)*3]);\n}\n\n\n// randomly choose a tile that fits constraints for a given spot, and update the constraints\nstatic stbhw_tile * stbhw__choose_tile(stbhw_tile **list, int numlist,\n                                      signed char *a, signed char *b, signed char *c,\n                                      signed char *d, signed char *e, signed char *f,\n                                      int **weighting)\n{\n   int i,n,m = 1<<30,pass;\n   for (pass=0; pass < 2; ++pass) {\n      n=0;\n      // pass #1:\n      //   count number of variants that match this partial set of constraints\n      // pass #2:\n      //   stop on randomly selected match\n      for (i=0; i < numlist; ++i) {\n         stbhw_tile *h = list[i];\n         if ((*a < 0 || *a == h->a) &&\n             (*b < 0 || *b == h->b) &&\n             (*c < 0 || *c == h->c) &&\n             (*d < 0 || *d == h->d) &&\n             (*e < 0 || *e == h->e) &&\n             (*f < 0 || *f == h->f)) {\n            if (weighting)\n               n += weighting[0][i];\n            else\n               n += 1;\n            if (n > m) {\n               // use list[i]\n               // update constraints to reflect what we placed\n               *a = h->a;\n               *b = h->b;\n               *c = h->c;\n               *d = h->d;\n               *e = h->e;\n               *f = h->f;\n               return h;\n            }\n         }\n      }\n      if (n == 0) {\n         stbhw_error = \"couldn't find tile matching constraints\";\n         return NULL;\n      }\n      m = STB_HBWANG_RAND() % n;\n   }\n   STB_HBWANG_ASSERT(0);\n   return NULL;\n}\n\nstatic int stbhw__match(int x, int y)\n{\n   return c_color[y][x] == c_color[y+1][x+1];\n}\n\nstatic int stbhw__weighted(int num_options, int *weights)\n{\n   int k, total, choice;\n   total = 0;\n   for (k=0; k < num_options; ++k)\n      total += weights[k];\n   choice = STB_HBWANG_RAND() % total;\n   total = 0;\n   for (k=0; k < num_options; ++k) {\n      total += weights[k];\n      if (choice < total)\n         break;\n   }\n   STB_HBWANG_ASSERT(k < num_options);\n   return k;\n}\n\nstatic int stbhw__change_color(int old_color, int num_options, int *weights)\n{\n   if (weights) {\n      int k, total, choice;\n      total = 0;\n      for (k=0; k < num_options; ++k)\n         if (k != old_color)\n            total += weights[k];\n      choice = STB_HBWANG_RAND() % total;\n      total = 0;\n      for (k=0; k < num_options; ++k) {\n         if (k != old_color) {\n            total += weights[k];\n            if (choice < total)\n               break;\n         }\n      }\n      STB_HBWANG_ASSERT(k < num_options);\n      return k;\n   } else {\n      int offset = 1+STB_HBWANG_RAND() % (num_options-1);\n      return (old_color+offset) % num_options;\n   }\n}\n\n\n\n// generate a map that is w * h pixels (3-bytes each)\n// returns 1 on success, 0 on error\nSTBHW_EXTERN int stbhw_generate_image(stbhw_tileset *ts, int **weighting, unsigned char *output, int stride, int w, int h)\n{\n   int sidelen = ts->short_side_len;\n   int xmax = (w / sidelen) + 6;\n   int ymax = (h / sidelen) + 6;\n   if (xmax > STB_HBWANG_MAX_X+6 || ymax > STB_HBWANG_MAX_Y+6) {\n      stbhw_error = \"increase STB_HBWANG_MAX_X/Y\";\n      return 0;\n   }\n\n   if (ts->is_corner) {\n      int i,j, ypos;\n      int *cc = ts->num_color;\n\n      for (j=0; j < ymax; ++j) {\n         for (i=0; i < xmax; ++i) {\n            int p = (i-j+1)&3; // corner type\n            if (weighting==NULL || weighting[p]==0 || cc[p] == 1)\n               c_color[j][i] = STB_HBWANG_RAND() % cc[p];\n            else\n               c_color[j][i] = stbhw__weighted(cc[p], weighting[p]);\n         }\n      }\n      #ifndef STB_HBWANG_NO_REPITITION_REDUCTION\n      // now go back through and make sure we don't have adjancent 3x2 vertices that are identical,\n      // to avoid really obvious repetition (which happens easily with extreme weights)\n      for (j=0; j < ymax-3; ++j) {\n         for (i=0; i < xmax-3; ++i) {\n            //int p = (i-j+1) & 3; // corner type   // unused, not sure what the intent was so commenting it out\n            STB_HBWANG_ASSERT(i+3 < STB_HBWANG_MAX_X+6);\n            STB_HBWANG_ASSERT(j+3 < STB_HBWANG_MAX_Y+6);\n            if (stbhw__match(i,j) && stbhw__match(i,j+1) && stbhw__match(i,j+2)\n                && stbhw__match(i+1,j) && stbhw__match(i+1,j+1) && stbhw__match(i+1,j+2)) {\n               int p = ((i+1)-(j+1)+1) & 3;\n               if (cc[p] > 1)\n                  c_color[j+1][i+1] = stbhw__change_color(c_color[j+1][i+1], cc[p], weighting ? weighting[p] : NULL);\n            }\n            if (stbhw__match(i,j) && stbhw__match(i+1,j) && stbhw__match(i+2,j)\n                && stbhw__match(i,j+1) && stbhw__match(i+1,j+1) && stbhw__match(i+2,j+1)) {\n               int p = ((i+2)-(j+1)+1) & 3;\n               if (cc[p] > 1)\n                  c_color[j+1][i+2] = stbhw__change_color(c_color[j+1][i+2], cc[p], weighting ? weighting[p] : NULL);\n            }\n         }\n      }\n      #endif\n\n      ypos = -1 * sidelen;\n      for (j = -1; ypos < h; ++j) {\n         // a general herringbone row consists of:\n         //    horizontal left block, the bottom of a previous vertical, the top of a new vertical\n         int phase = (j & 3);\n         // displace horizontally according to pattern\n         if (phase == 0) {\n            i = 0;\n         } else {\n            i = phase-4;\n         }\n         for (;; i += 4) {\n            int xpos = i * sidelen;\n            if (xpos >= w)\n               break;\n            // horizontal left-block\n            if (xpos + sidelen*2 >= 0 && ypos >= 0) {\n               stbhw_tile *t = stbhw__choose_tile(\n                  ts->h_tiles, ts->num_h_tiles,\n                  &c_color[j+2][i+2], &c_color[j+2][i+3], &c_color[j+2][i+4],\n                  &c_color[j+3][i+2], &c_color[j+3][i+3], &c_color[j+3][i+4],\n                  weighting\n               );\n               if (t == NULL)\n                  return 0;\n               stbhw__draw_h_tile(output,stride,w,h, xpos, ypos, t, sidelen);\n            }\n            xpos += sidelen * 2;\n            // now we're at the end of a previous vertical one\n            xpos += sidelen;\n            // now we're at the start of a new vertical one\n            if (xpos < w) {\n               stbhw_tile *t = stbhw__choose_tile(\n                  ts->v_tiles, ts->num_v_tiles,\n                  &c_color[j+2][i+5], &c_color[j+3][i+5], &c_color[j+4][i+5],\n                  &c_color[j+2][i+6], &c_color[j+3][i+6], &c_color[j+4][i+6],\n                  weighting\n               );\n               if (t == NULL)\n                  return 0;\n               stbhw__draw_v_tile(output,stride,w,h, xpos, ypos,  t, sidelen);\n            }\n         }\n         ypos += sidelen;\n      }\n   } else {\n      // @TODO edge-color repetition reduction\n      int i,j, ypos;\n      memset(v_color, -1, sizeof(v_color));\n      memset(h_color, -1, sizeof(h_color));\n\n      ypos = -1 * sidelen;\n      for (j = -1; ypos<h; ++j) {\n         // a general herringbone row consists of:\n         //    horizontal left block, the bottom of a previous vertical, the top of a new vertical\n         int phase = (j & 3);\n         // displace horizontally according to pattern\n         if (phase == 0) {\n            i = 0;\n         } else {\n            i = phase-4;\n         }\n         for (;; i += 4) {\n            int xpos = i * sidelen;\n            if (xpos >= w)\n               break;\n            // horizontal left-block\n            if (xpos + sidelen*2 >= 0 && ypos >= 0) {\n               stbhw_tile *t = stbhw__choose_tile(\n                  ts->h_tiles, ts->num_h_tiles,\n                  &h_color[j+2][i+2], &h_color[j+2][i+3],\n                  &v_color[j+2][i+2], &v_color[j+2][i+4],\n                  &h_color[j+3][i+2], &h_color[j+3][i+3],\n                  weighting\n               );\n               if (t == NULL) return 0;\n               stbhw__draw_h_tile(output,stride,w,h, xpos, ypos, t, sidelen);\n            }\n            xpos += sidelen * 2;\n            // now we're at the end of a previous vertical one\n            xpos += sidelen;\n            // now we're at the start of a new vertical one\n            if (xpos < w) {\n               stbhw_tile *t = stbhw__choose_tile(\n                  ts->v_tiles, ts->num_v_tiles,\n                  &h_color[j+2][i+5],\n                  &v_color[j+2][i+5], &v_color[j+2][i+6],\n                  &v_color[j+3][i+5], &v_color[j+3][i+6],\n                  &h_color[j+4][i+5],\n                  weighting\n               );\n               if (t == NULL) return 0;\n               stbhw__draw_v_tile(output,stride,w,h, xpos, ypos,  t, sidelen);\n            }\n         }\n         ypos += sidelen;\n      }\n   }\n   return 1;\n}\n\nstatic void stbhw__parse_h_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n   stbhw_tile *h = (stbhw_tile *) malloc(sizeof(*h)-1 + 3 * (len*2) * len);\n   int i,j;\n   ++xpos;\n   ++ypos;\n   h->a = a, h->b = b, h->c = c, h->d = d, h->e = e, h->f = f;\n   for (j=0; j < len; ++j)\n      for (i=0; i < len*2; ++i)\n         memcpy(h->pixels + j*(3*len*2) + i*3, p->data+(ypos+j)*p->stride+(xpos+i)*3, 3);\n   STB_HBWANG_ASSERT(p->ts->num_h_tiles < p->ts->max_h_tiles);\n   p->ts->h_tiles[p->ts->num_h_tiles++] = h;\n}\n\nstatic void stbhw__parse_v_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n   stbhw_tile *h = (stbhw_tile *) malloc(sizeof(*h)-1 + 3 * (len*2) * len);\n   int i,j;\n   ++xpos;\n   ++ypos;\n   h->a = a, h->b = b, h->c = c, h->d = d, h->e = e, h->f = f;\n   for (j=0; j < len*2; ++j)\n      for (i=0; i < len; ++i)\n         memcpy(h->pixels + j*(3*len) + i*3, p->data+(ypos+j)*p->stride+(xpos+i)*3, 3);\n   STB_HBWANG_ASSERT(p->ts->num_v_tiles < p->ts->max_v_tiles);\n   p->ts->v_tiles[p->ts->num_v_tiles++] = h;\n}\n\nSTBHW_EXTERN int stbhw_build_tileset_from_image(stbhw_tileset *ts, unsigned char *data, int stride, int w, int h)\n{\n   int i, h_count, v_count;\n   unsigned char header[9];\n   stbhw_config c = { 0 };\n   stbhw__process p = { 0 };\n\n   // extract binary header\n\n   // remove encoding that makes it more visually obvious it encodes actual data\n   for (i=0; i < 9; ++i)\n      header[i] = data[w*3 - 1 - i] ^ (i*55);\n\n   // extract header info\n   if (header[7] == 0xc0) {\n      // corner-type\n      c.is_corner = 1;\n      for (i=0; i < 4; ++i)\n         c.num_color[i] = header[i];\n      c.num_vary_x = header[4];\n      c.num_vary_y = header[5];\n      c.short_side_len = header[6];\n   } else {\n      c.is_corner = 0;\n      // edge-type\n      for (i=0; i < 6; ++i)\n         c.num_color[i] = header[i];\n      c.num_vary_x = header[6];\n      c.num_vary_y = header[7];\n      c.short_side_len = header[8];\n   }\n\n   if (c.num_vary_x < 0 || c.num_vary_x > 64 || c.num_vary_y < 0 || c.num_vary_y > 64)\n      return 0;\n   if (c.short_side_len == 0)\n      return 0;\n   if (c.num_color[0] > 32 || c.num_color[1] > 32 || c.num_color[2] > 32 || c.num_color[3] > 32)\n      return 0;\n\n   stbhw__get_template_info(&c, NULL, NULL, &h_count, &v_count);\n\n   ts->is_corner = c.is_corner;\n   ts->short_side_len = c.short_side_len;\n   memcpy(ts->num_color, c.num_color, sizeof(ts->num_color));\n\n   ts->max_h_tiles = h_count;\n   ts->max_v_tiles = v_count;\n\n   ts->num_h_tiles = ts->num_v_tiles = 0;\n\n   ts->h_tiles = (stbhw_tile **) malloc(sizeof(*ts->h_tiles) * h_count);\n   ts->v_tiles = (stbhw_tile **) malloc(sizeof(*ts->v_tiles) * v_count);\n\n   p.ts = ts;\n   p.data = data;\n   p.stride = stride;\n   p.process_h_rect = stbhw__parse_h_rect;\n   p.process_v_rect = stbhw__parse_v_rect;\n   p.w = w;\n   p.h = h;\n   p.c = &c;\n\n   // load all the tiles out of the image\n   return stbhw__process_template(&p);\n}\n\nSTBHW_EXTERN void stbhw_free_tileset(stbhw_tileset *ts)\n{\n   int i;\n   for (i=0; i < ts->num_h_tiles; ++i)\n      free(ts->h_tiles[i]);\n   for (i=0; i < ts->num_v_tiles; ++i)\n      free(ts->v_tiles[i]);\n   free(ts->h_tiles);\n   free(ts->v_tiles);\n   ts->h_tiles = NULL;\n   ts->v_tiles = NULL;\n   ts->num_h_tiles = ts->max_h_tiles = 0;\n   ts->num_v_tiles = ts->max_v_tiles = 0;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//               GENERATOR\n//\n//\n\n\n// shared code\n\nstatic void stbhw__set_pixel(unsigned char *data, int stride, int xpos, int ypos, unsigned char color[3])\n{\n   memcpy(data + ypos*stride + xpos*3, color, 3);\n}\n\nstatic void stbhw__stbhw__set_pixel_whiten(unsigned char *data, int stride, int xpos, int ypos, unsigned char color[3])\n{\n   unsigned char c2[3];\n   int i;\n   for (i=0; i < 3; ++i)\n      c2[i] = (color[i]*2 + 255)/3;\n   memcpy(data + ypos*stride + xpos*3, c2, 3);\n}\n\n\nstatic unsigned char stbhw__black[3] = { 0,0,0 };\n\n// each edge set gets its own unique color variants\n// used http://phrogz.net/css/distinct-colors.html to generate this set,\n// but it's not very good and needs to be revised\n\nstatic unsigned char stbhw__color[7][8][3] =\n{\n   { {255,51,51}  , {143,143,29}, {0,199,199}, {159,119,199},     {0,149,199}  , {143, 0,143}, {255,128,0}, {64,255,0},  },\n   { {235,255,30 }, {255,0,255},  {199,139,119},  {29,143, 57},    {143,0,71}   , { 0,143,143}, {0,99,199}, {143,71,0},  },\n   { {0,149,199}  , {143, 0,143}, {255,128,0}, {64,255,0},        {255,191,0}  , {51,255,153}, {0,0,143}, {199,119,159},},\n   { {143,0,71}   , { 0,143,143}, {0,99,199}, {143,71,0},         {255,190,153}, { 0,255,255}, {128,0,255}, {255,51,102},},\n   { {255,191,0}  , {51,255,153}, {0,0,143}, {199,119,159},       {255,51,51}  , {143,143,29}, {0,199,199}, {159,119,199},},\n   { {255,190,153}, { 0,255,255}, {128,0,255}, {255,51,102},      {235,255,30 }, {255,0,255}, {199,139,119},  {29,143, 57}, },\n\n   { {40,40,40 },  { 90,90,90 }, { 150,150,150 }, { 200,200,200 },\n     { 255,90,90 }, { 160,160,80}, { 50,150,150 }, { 200,50,200 } },\n};\n\nstatic void stbhw__draw_hline(unsigned char *data, int stride, int xpos, int ypos, int color, int len, int slot)\n{\n   int i;\n   int j = len * 6 / 16;\n   int k = len * 10 / 16;\n   for (i=0; i < len; ++i)\n      stbhw__set_pixel(data, stride, xpos+i, ypos, stbhw__black);\n   if (k-j < 2) {\n      j = len/2 - 1;\n      k = j+2;\n      if (len & 1)\n         ++k;\n   }\n   for (i=j; i < k; ++i)\n      stbhw__stbhw__set_pixel_whiten(data, stride, xpos+i, ypos, stbhw__color[slot][color]);\n}\n\nstatic void stbhw__draw_vline(unsigned char *data, int stride, int xpos, int ypos, int color, int len, int slot)\n{\n   int i;\n   int j = len * 6 / 16;\n   int k = len * 10 / 16;\n   for (i=0; i < len; ++i)\n      stbhw__set_pixel(data, stride, xpos, ypos+i, stbhw__black);\n   if (k-j < 2) {\n      j = len/2 - 1;\n      k = j+2;\n      if (len & 1)\n         ++k;\n   }\n   for (i=j; i < k; ++i)\n      stbhw__stbhw__set_pixel_whiten(data, stride, xpos, ypos+i, stbhw__color[slot][color]);\n}\n\n//                 0--*--1--*--2--*--3\n//                 |     |           |\n//                 *     *           *\n//                 |     |           |\n//     1--*--2--*--3     0--*--1--*--2\n//     |           |     |\n//     *           *     *\n//     |           |     |\n//     0--*--1--*--2--*--3\n//\n// variables while enumerating (no correspondence between corners\n// of the types is implied by these variables)\n//\n//     a-----b-----c      a-----d\n//     |           |      |     |\n//     |           |      |     |\n//     |           |      |     |\n//     d-----e-----f      b     e\n//                        |     |\n//                        |     |\n//                        |     |\n//                        c-----f\n//\n\nunsigned char stbhw__corner_colors[4][4][3] =\n{\n   { { 255,0,0 }, { 200,200,200 }, { 100,100,200 }, { 255,200,150 }, },\n   { { 0,0,255 }, { 255,255,0 },   { 100,200,100 }, { 150,255,200 }, },\n   { { 255,0,255 }, { 80,80,80 },  { 200,100,100 }, { 200,150,255 }, },\n   { { 0,255,255 }, { 0,255,0 },   { 200,120,200 }, { 255,200,200 }, },\n};\n\nint stbhw__corner_colors_to_edge_color[4][4] =\n{\n   // 0   1   2   3\n   {  0,  1,  4,  9, }, // 0\n   {  2,  3,  5, 10, }, // 1\n   {  6,  7,  8, 11, }, // 2\n   { 12, 13, 14, 15, }, // 3\n};\n\n#define stbhw__c2e stbhw__corner_colors_to_edge_color\n\nstatic void stbhw__draw_clipped_corner(unsigned char *data, int stride, int xpos, int ypos, int w, int h, int x, int y)\n{\n   static unsigned char template_color[3] = { 167,204,204 };\n   int i,j;\n   for (j = -2; j <= 1; ++j) {\n      for (i = -2; i <= 1; ++i) {\n         if ((i == -2 || i == 1) && (j == -2 || j == 1))\n            continue;\n         else {\n            if (x+i < 1 || x+i > w) continue;\n            if (y+j < 1 || y+j > h) continue;\n            stbhw__set_pixel(data, stride, xpos+x+i, ypos+y+j, template_color);\n\n         }\n      }\n   }\n}\n\nstatic void stbhw__edge_process_h_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n   stbhw__draw_hline(p->data, p->stride, xpos+1        , ypos        , a, len, 2);\n   stbhw__draw_hline(p->data, p->stride, xpos+  len+1  , ypos        , b, len, 3);\n   stbhw__draw_vline(p->data, p->stride, xpos          , ypos+1      , c, len, 1);\n   stbhw__draw_vline(p->data, p->stride, xpos+2*len+1  , ypos+1      , d, len, 4);\n   stbhw__draw_hline(p->data, p->stride, xpos+1        , ypos + len+1, e, len, 0);\n   stbhw__draw_hline(p->data, p->stride, xpos + len+1  , ypos + len+1, f, len, 2);\n}\n\nstatic void stbhw__edge_process_v_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n   stbhw__draw_hline(p->data, p->stride, xpos+1      , ypos          , a, len, 0);\n   stbhw__draw_vline(p->data, p->stride, xpos        , ypos+1        , b, len, 5);\n   stbhw__draw_vline(p->data, p->stride, xpos + len+1, ypos+1        , c, len, 1);\n   stbhw__draw_vline(p->data, p->stride, xpos        , ypos +   len+1, d, len, 4);\n   stbhw__draw_vline(p->data, p->stride, xpos + len+1, ypos +   len+1, e, len, 5);\n   stbhw__draw_hline(p->data, p->stride, xpos+1      , ypos + 2*len+1, f, len, 3);\n}\n\nstatic void stbhw__corner_process_h_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n\n   stbhw__draw_hline(p->data, p->stride, xpos+1        , ypos        , stbhw__c2e[a][b], len, 2);\n   stbhw__draw_hline(p->data, p->stride, xpos+  len+1  , ypos        , stbhw__c2e[b][c], len, 3);\n   stbhw__draw_vline(p->data, p->stride, xpos          , ypos+1      , stbhw__c2e[a][d], len, 1);\n   stbhw__draw_vline(p->data, p->stride, xpos+2*len+1  , ypos+1      , stbhw__c2e[c][f], len, 4);\n   stbhw__draw_hline(p->data, p->stride, xpos+1        , ypos + len+1, stbhw__c2e[d][e], len, 0);\n   stbhw__draw_hline(p->data, p->stride, xpos + len+1  , ypos + len+1, stbhw__c2e[e][f], len, 2);\n\n   if (p->c->corner_type_color_template[1][a]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, 1,1);\n   if (p->c->corner_type_color_template[2][b]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, len+1,1);\n   if (p->c->corner_type_color_template[3][c]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, len*2+1,1);\n\n   if (p->c->corner_type_color_template[0][d]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, 1,len+1);\n   if (p->c->corner_type_color_template[1][e]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, len+1,len+1);\n   if (p->c->corner_type_color_template[2][f]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len*2,len, len*2+1,len+1);\n\n   stbhw__set_pixel(p->data, p->stride, xpos        , ypos, stbhw__corner_colors[1][a]);\n   stbhw__set_pixel(p->data, p->stride, xpos+len    , ypos, stbhw__corner_colors[2][b]);\n   stbhw__set_pixel(p->data, p->stride, xpos+2*len+1, ypos, stbhw__corner_colors[3][c]);\n   stbhw__set_pixel(p->data, p->stride, xpos        , ypos+len+1, stbhw__corner_colors[0][d]);\n   stbhw__set_pixel(p->data, p->stride, xpos+len    , ypos+len+1, stbhw__corner_colors[1][e]);\n   stbhw__set_pixel(p->data, p->stride, xpos+2*len+1, ypos+len+1, stbhw__corner_colors[2][f]);\n}\n\nstatic void stbhw__corner_process_v_rect(stbhw__process *p, int xpos, int ypos,\n                            int a, int b, int c, int d, int e, int f)\n{\n   int len = p->c->short_side_len;\n\n   stbhw__draw_hline(p->data, p->stride, xpos+1      , ypos          , stbhw__c2e[a][d], len, 0);\n   stbhw__draw_vline(p->data, p->stride, xpos        , ypos+1        , stbhw__c2e[a][b], len, 5);\n   stbhw__draw_vline(p->data, p->stride, xpos + len+1, ypos+1        , stbhw__c2e[d][e], len, 1);\n   stbhw__draw_vline(p->data, p->stride, xpos        , ypos +   len+1, stbhw__c2e[b][c], len, 4);\n   stbhw__draw_vline(p->data, p->stride, xpos + len+1, ypos +   len+1, stbhw__c2e[e][f], len, 5);\n   stbhw__draw_hline(p->data, p->stride, xpos+1      , ypos + 2*len+1, stbhw__c2e[c][f], len, 3);\n\n   if (p->c->corner_type_color_template[0][a]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, 1,1);\n   if (p->c->corner_type_color_template[3][b]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, 1,len+1);\n   if (p->c->corner_type_color_template[2][c]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, 1,len*2+1);\n\n   if (p->c->corner_type_color_template[1][d]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, len+1,1);\n   if (p->c->corner_type_color_template[0][e]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, len+1,len+1);\n   if (p->c->corner_type_color_template[3][f]) stbhw__draw_clipped_corner(p->data,p->stride, xpos,ypos, len,len*2, len+1,len*2+1);\n\n   stbhw__set_pixel(p->data, p->stride, xpos      , ypos        , stbhw__corner_colors[0][a]);\n   stbhw__set_pixel(p->data, p->stride, xpos      , ypos+len    , stbhw__corner_colors[3][b]);\n   stbhw__set_pixel(p->data, p->stride, xpos      , ypos+2*len+1, stbhw__corner_colors[2][c]);\n   stbhw__set_pixel(p->data, p->stride, xpos+len+1, ypos        , stbhw__corner_colors[1][d]);\n   stbhw__set_pixel(p->data, p->stride, xpos+len+1, ypos+len    , stbhw__corner_colors[0][e]);\n   stbhw__set_pixel(p->data, p->stride, xpos+len+1, ypos+2*len+1, stbhw__corner_colors[3][f]);\n}\n\n// generates a template image, assuming data is 3*w*h bytes long, RGB format\nSTBHW_EXTERN int stbhw_make_template(stbhw_config *c, unsigned char *data, int w, int h, int stride_in_bytes)\n{\n   stbhw__process p;\n   int i;\n\n   p.data = data;\n   p.w = w;\n   p.h = h;\n   p.stride = stride_in_bytes;\n   p.ts = 0;\n   p.c = c;\n\n   if (c->is_corner) {\n      p.process_h_rect = stbhw__corner_process_h_rect;\n      p.process_v_rect = stbhw__corner_process_v_rect;\n   } else {\n      p.process_h_rect = stbhw__edge_process_h_rect;\n      p.process_v_rect = stbhw__edge_process_v_rect;\n   }\n\n   for (i=0; i < p.h; ++i)\n      memset(p.data + i*p.stride, 255, 3*p.w);\n\n   if (!stbhw__process_template(&p))\n      return 0;\n\n   if (c->is_corner) {\n      // write out binary information in first line of image\n      for (i=0; i < 4; ++i)\n         data[w*3-1-i] = c->num_color[i];\n      data[w*3-1-i] = c->num_vary_x;\n      data[w*3-2-i] = c->num_vary_y;\n      data[w*3-3-i] = c->short_side_len;\n      data[w*3-4-i] = 0xc0;\n   } else {\n      for (i=0; i < 6; ++i)\n         data[w*3-1-i] = c->num_color[i];\n      data[w*3-1-i] = c->num_vary_x;\n      data[w*3-2-i] = c->num_vary_y;\n      data[w*3-3-i] = c->short_side_len;\n   }\n\n   // make it more obvious it encodes actual data\n   for (i=0; i < 9; ++i)\n      p.data[p.w*3 - 1 - i] ^= i*55;\n\n   return 1;\n}\n#endif // STB_HBWANG_IMPLEMENTATION\n"
        },
        {
          "name": "stb_hexwave.h",
          "type": "blob",
          "size": 26.8291015625,
          "content": "// stb_hexwave - v0.5 - public domain, initial release 2021-04-01\n//\n// A flexible anti-aliased (bandlimited) digital audio oscillator.\n//\n// This library generates waveforms of a variety of shapes made of\n// line segments. It does not do envelopes, LFO effects, etc.; it\n// merely tries to solve the problem of generating an artifact-free\n// morphable digital waveform with a variety of spectra, and leaves\n// it to the user to rescale the waveform and mix multiple voices, etc.\n//\n// Compiling:\n//\n//   In one C/C++ file that #includes this file, do\n//\n//      #define STB_HEXWAVE_IMPLEMENTATION\n//      #include \"stb_hexwave.h\"\n//\n//   Optionally, #define STB_HEXWAVE_STATIC before including\n//   the header to cause the definitions to be private to the\n//   implementation file (i.e. to be \"static\" instead of \"extern\").\n//\n// Notes:\n//\n//   Optionally performs memory allocation during initialization,\n//   never allocates otherwise.\n//\n// License:\n//\n//   See end of file for license information.\n//\n// Usage:\n//\n//   Initialization:\n//\n//     hexwave_init(32,16,NULL); // read \"header section\" for alternatives\n//\n//   Create oscillator:\n//\n//     HexWave *osc = malloc(sizeof(*osc)); // or \"new HexWave\", or declare globally or on stack\n//     hexwave_create(osc, reflect_flag, peak_time, half_height, zero_wait);\n//       see \"Waveform shapes\" below for the meaning of these parameters\n//\n//   Generate audio:\n//\n//     hexwave_generate_samples(output, number_of_samples, osc, oscillator_freq)\n//       where:\n//         output is a buffer where the library will store floating point audio samples\n//         number_of_samples is the number of audio samples to generate\n//         osc is a pointer to a Hexwave\n//         oscillator_freq is the frequency of the oscillator divided by the sample rate\n//\n//       The output samples will continue from where the samples generated by the\n//       previous hexwave_generate_samples() on this oscillator ended.\n//\n//   Change oscillator waveform:\n//\n//     hexwave_change(osc, reflect_flag, peak_time, half_height, zero_wait);\n//       can call in between calls to hexwave_generate_samples\n//\n// Waveform shapes:\n//\n//   All waveforms generated by hexwave are constructed from six line segments\n//   characterized by 3 parameters.\n//\n//   See demonstration: https://www.youtube.com/watch?v=hsUCrAsDN-M\n//\n//                 reflect=0                          reflect=1\n//\n//           0-----P---1                        0-----P---1    peak_time = P\n//                 .     1                            .     1\n//                /\\_    :                           /\\_    :\n//               /   \\_  :                          /   \\_  :\n//              /      \\.H                         /      \\.H  half_height = H\n//             /       | :                        /       | :\n//       _____/        |_:___               _____/        | :       _____\n//           .           :   \\        |         .         | :      /\n//           .           :    \\       |         .         | :     /\n//           .           :     \\     _/         .         \\_:    /\n//           .           :      \\  _/           .           :_  /\n//           .          -1       \\/             .          -1 \\/\n//       0 - Z - - - - 1                    0 - Z - - - - 1   zero_wait = Z\n//\n//    Classic waveforms:\n//                               peak    half    zero\n//                     reflect   time   height   wait\n//      Sawtooth          1       0       0       0\n//      Square            1       0       1       0\n//      Triangle          1       0.5     0       0\n//\n//    Some waveforms can be produced in multiple ways, which is useful when morphing\n//    into other waveforms, and there are a few more notable shapes:\n//\n//                               peak    half    zero\n//                     reflect   time   height   wait\n//      Sawtooth          1       1      any      0\n//      Sawtooth (8va)    1       0      -1       0\n//      Triangle          1       0.5     0       0\n//      Square            1       0       1       0\n//      Square            0       0       1       0\n//      Triangle          0       0.5     0       0\n//      Triangle          0       0      -1       0\n//      AlternatingSaw    0       0       0       0\n//      AlternatingSaw    0       1      any      0\n//      Stairs            0       0       1       0.5\n//\n//    The \"Sawtooth (8va)\" waveform is identical to a sawtooth wave with 2x the\n//    frequency, but when morphed with other values, it becomes an overtone of\n//    the base frequency.\n//\n//  Morphing waveforms:\n//\n//    Sweeping peak_time morphs the waveform while producing various spectra.\n//    Sweeping half_height effectively crossfades between two waveforms; useful, but less exciting.\n//    Sweeping zero_wait produces a similar effect no matter the reset of the waveform,\n//        a sort of high-pass/PWM effect where the wave becomes silent at zero_wait=1.\n//\n//    You can trivially morph between any two waveforms from the above table\n//    which only differ in one column.\n//\n//    Crossfade between classic waveforms:\n//                                            peak     half    zero\n//        Start         End         reflect   time    height   wait\n//        -----         ---         -------   ----    ------   ----\n//        Triangle      Square         0       0      -1..1    0\n//        Saw           Square         1       0       0..1    0\n//        Triangle      Saw            1       0.5     0..2    0\n//\n//    The last morph uses uses half-height values larger than 1, which means it will\n//    be louder and the output should be scaled down by half to compensate, or better\n//    by dynamically tracking the morph: volume_scale = 1 - half_height/4\n//\n//    Non-crossfade morph between classic waveforms, most require changing\n//    two parameters at the same time:\n//                                           peak     half    zero\n//      Start         End         reflect    time    height   wait\n//      -----         ---         -------    ----    ------   ----\n//      Square        Triangle      any      0..0.5   1..0     0\n//      Square        Saw            1       0..1     1..any   0\n//      Triangle      Saw            1     0.5..1     0..-1    0\n//\n//    Other noteworthy morphs between simple shapes:\n//                                                            peak     half    zero\n//      Start           Halfway       End          reflect    time    height   wait\n//      -----           ---------     ---          -------    ----    ------   ----\n//      Saw (8va,neg)                Saw (pos)        1       0..1      -1      0\n//      Saw (neg)                    Saw (pos)        1       0..1       0      0\n//      Triangle                     AlternatingSaw   0       0..1      -1      0\n//      AlternatingSaw  Triangle     AlternatingSaw   0       0..1       0      0\n//      Square                       AlternatingSaw   0       0..1       1      0\n//      Triangle        Triangle     AlternatingSaw   0       0..1    -1..1     0\n//      Square                       AlternatingSaw   0       0..1     1..0     0\n//      Saw (8va)       Triangle     Saw              1       0..1    -1..1     0\n//      Saw (neg)                    Saw (pos)        1       0..1     0..1     0\n//      AlternatingSaw               AlternatingSaw   0       0..1     0..any   0\n//\n//   The last entry is noteworthy because the morph from the halfway point to either\n//   endpoint sounds very different. For example, an LFO sweeping back and forth over\n//   the whole range will morph between the middle timbre and the AlternatingSaw\n//   timbre in two different ways, alternating.\n//\n//   Entries with \"any\" for half_height are whole families of morphs, as you can pick\n//   any value you want as the endpoint for half_height.\n//\n//   You can always morph between any two waveforms with the same value of 'reflect'\n//   by just sweeping the parameters simultaneously. There will never be artifacts\n//   and the result will always be useful, if not necessarily what you want.\n//\n//   You can vary the sound of two-parameter morphs by ramping them differently,\n//   e.g. if the morph goes from t=0..1, then square-to-triangle looks like:\n//        peak_time   = lerp(t, 0, 0.5)\n//        half_height = lerp(t, 1, 0  )\n//   but you can also do things like:\n//        peak_time   = lerp(smoothstep(t), 0, 0.5)\n//        half_height = cos(PI/2 * t)\n//\n// How it works:\n//\n//   hexwave use BLEP to bandlimit discontinuities and BLAMP\n//   to bandlimit C1 discontinuities. This is not polyBLEP\n//   (polynomial BLEP), it is table-driven BLEP. It is\n//   also not minBLEP (minimum-phase BLEP), as that complicates\n//   things for little benefit once BLAMP is involved.\n//\n//   The previous oscillator frequency is remembered, and when\n//   the frequency changes, a BLAMP is generated to remove the\n//   C1 discontinuity, which reduces artifacts for sweeps/LFO.\n//\n//   Changes to an oscillator timbre using hexwave_change() actually\n//   wait until the oscillator finishes its current cycle. All\n//   waveforms with non-zero \"zero_wait\" settings pass through 0\n//   and have 0-slope at the start of a cycle, which means changing\n//   the settings is artifact free at that time. (If zero_wait is 0,\n//   the code still treats it as passing through 0 with 0-slope; it'll\n//   apply the necessary fixups to make it artifact free as if it does\n//   transition to 0 with 0-slope vs. the waveform at the end of\n//   the cycle, then adds the fixups for a non-0 and non-0 slope\n//   at the start of the cycle, which cancels out if zero_wait is 0,\n//   and still does the right thing if zero_wait is 0 when the\n//   settings are updated.)\n//\n//   BLEP/BLAMP normally requires overlapping buffers, but this\n//   is hidden from the user by generating the waveform to a\n//   temporary buffer and saving the overlap regions internally\n//   between calls. (It is slightly more complicated; see code.)\n//\n//   By design all shapes have 0 DC offset; this is one reason\n//   hexwave uses zero_wait instead of standard PWM.\n//\n//   The internals of hexwave could support any arbitrary shape\n//   made of line segments, but I chose not to expose this\n//   generality in favor of a simple, easy-to-use API.\n\n#ifndef STB_INCLUDE_STB_HEXWAVE_H\n#define STB_INCLUDE_STB_HEXWAVE_H\n\n#ifndef STB_HEXWAVE_MAX_BLEP_LENGTH\n#define STB_HEXWAVE_MAX_BLEP_LENGTH   64 // good enough for anybody\n#endif\n\n#ifdef STB_HEXWAVE_STATIC\n#define STB_HEXWAVE_DEF static\n#else\n#define STB_HEXWAVE_DEF extern\n#endif\n\ntypedef struct HexWave HexWave;\n\nSTB_HEXWAVE_DEF void hexwave_init(int width, int oversample, float *user_buffer);\n//         width: size of BLEP, from 4..64, larger is slower & more memory but less aliasing\n//    oversample: 2+, number of subsample positions, larger uses more memory but less noise\n//   user_buffer: optional, if provided the library will perform no allocations.\n//                16*width*(oversample+1) bytes, must stay allocated as long as library is used\n//                technically it only needs:   8*( width * (oversample  + 1))\n//                                           + 8*((width *  oversample) + 1)  bytes\n//\n// width can be larger than 64 if you define STB_HEXWAVE_MAX_BLEP_LENGTH to a larger value\n\nSTB_HEXWAVE_DEF void hexwave_shutdown(float *user_buffer);\n//       user_buffer: pass in same parameter as passed to hexwave_init\n\nSTB_HEXWAVE_DEF void hexwave_create(HexWave *hex, int reflect, float peak_time, float half_height, float zero_wait);\n// see docs above for description\n//\n//   reflect is tested as 0 or non-zero\n//   peak_time is clamped to 0..1\n//   half_height is not clamped\n//   zero_wait is clamped to 0..1\n\nSTB_HEXWAVE_DEF void hexwave_change(HexWave *hex, int reflect, float peak_time, float half_height, float zero_wait);\n// see docs\n\nSTB_HEXWAVE_DEF void hexwave_generate_samples(float *output, int num_samples, HexWave *hex, float freq);\n//            output: buffer where the library will store generated floating point audio samples\n// number_of_samples: the number of audio samples to generate\n//               osc: pointer to a Hexwave initialized with 'hexwave_create'\n//   oscillator_freq: frequency of the oscillator divided by the sample rate\n\n// private:\ntypedef struct\n{\n   int   reflect;\n   float peak_time;\n   float zero_wait;\n   float half_height;\n} HexWaveParameters;\n\nstruct HexWave\n{\n   float t, prev_dt;\n   HexWaveParameters current, pending;\n   int have_pending;\n   float buffer[STB_HEXWAVE_MAX_BLEP_LENGTH];\n}; \n#endif\n\n#ifdef STB_HEXWAVE_IMPLEMENTATION\n\n#ifndef STB_HEXWAVE_NO_ALLOCATION\n#include <stdlib.h> // malloc,free\n#endif\n\n#include <string.h> // memset,memcpy,memmove\n#include <math.h>   // sin,cos,fabs\n\n#define hexwave_clamp(v,a,b)   ((v) < (a) ? (a) : (v) > (b) ? (b) : (v))\n\nSTB_HEXWAVE_DEF void hexwave_change(HexWave *hex, int reflect, float peak_time, float half_height, float zero_wait)\n{\n   hex->pending.reflect     = reflect;\n   hex->pending.peak_time   = hexwave_clamp(peak_time,0,1);\n   hex->pending.half_height = half_height;\n   hex->pending.zero_wait   = hexwave_clamp(zero_wait,0,1);\n   // put a barrier here to allow changing from a different thread than the generator\n   hex->have_pending        = 1;\n}\n\nSTB_HEXWAVE_DEF void hexwave_create(HexWave *hex, int reflect, float peak_time, float half_height, float zero_wait)\n{\n   memset(hex, 0, sizeof(*hex));\n   hexwave_change(hex, reflect, peak_time, half_height, zero_wait);\n   hex->current = hex->pending;\n   hex->have_pending = 0;\n   hex->t = 0;\n   hex->prev_dt = 0;\n}\n\nstatic struct\n{\n   int width;       // width of fixup in samples\n   int oversample;  // number of oversampled versions (there's actually one more to allow lerpign)\n   float *blep;\n   float *blamp;\n} hexblep;\n\nstatic void hex_add_oversampled_bleplike(float *output, float time_since_transition, float scale, float *data)\n{\n   float *d1,*d2;\n   float lerpweight;\n   int i, bw = hexblep.width;\n\n   int slot = (int) (time_since_transition * hexblep.oversample);\n   if (slot >= hexblep.oversample)\n      slot = hexblep.oversample-1; // clamp in case the floats overshoot\n\n   d1 = &data[ slot   *bw];\n   d2 = &data[(slot+1)*bw];\n\n   lerpweight = time_since_transition * hexblep.oversample - slot;\n   for (i=0; i < bw; ++i)\n      output[i] += scale * (d1[i] + (d2[i]-d1[i])*lerpweight);\n}\n\nstatic void hex_blep (float *output, float time_since_transition, float scale)\n{\n   hex_add_oversampled_bleplike(output, time_since_transition, scale, hexblep.blep);\n}\n\nstatic void hex_blamp(float *output, float time_since_transition, float scale)\n{\n   hex_add_oversampled_bleplike(output, time_since_transition, scale, hexblep.blamp);\n}\n\ntypedef struct\n{\n   float t,v,s; // time, value, slope\n} hexvert;\n\n// each half of the waveform needs 4 vertices to represent 3 line\n// segments, plus 1 more for wraparound\nstatic void hexwave_generate_linesegs(hexvert vert[9], HexWave *hex, float dt)\n{\n   int j;\n   float min_len = dt / 256.0f;\n\n   vert[0].t = 0;\n   vert[0].v = 0;\n   vert[1].t = hex->current.zero_wait*0.5f;\n   vert[1].v = 0;\n   vert[2].t = 0.5f*hex->current.peak_time + vert[1].t*(1-hex->current.peak_time);\n   vert[2].v = 1;\n   vert[3].t = 0.5f;\n   vert[3].v = hex->current.half_height;\n\n   if (hex->current.reflect) {\n      for (j=4; j <= 7; ++j) {\n         vert[j].t = 1 -  vert[7-j].t;\n         vert[j].v =    - vert[7-j].v;\n      }\n   } else {\n      for (j=4; j <= 7; ++j) {\n         vert[j].t =  0.5f +  vert[j-4].t;\n         vert[j].v =        - vert[j-4].v;\n      }\n   }\n   vert[8].t = 1;\n   vert[8].v = 0;\n\n   for (j=0; j < 8; ++j) {\n      if (vert[j+1].t <= vert[j].t + min_len) {\n          // if change takes place over less than a fraction of a sample treat as discontinuity\n          //\n          // otherwise the slope computation can blow up to arbitrarily large and we\n          // try to generate a huge BLAMP and the result is wrong.\n          // \n          // why does this happen if the math is right? i believe if done perfectly,\n          // the two BLAMPs on either side of the slope would cancel out, but our\n          // BLAMPs have only limited sub-sample precision and limited integration\n          // accuracy. or maybe it's just the math blowing up w/ floating point precision\n          // limits as we try to make x * (1/x) cancel out\n          //\n          // min_len verified artifact-free even near nyquist with only oversample=4\n         vert[j+1].t = vert[j].t;\n      }\n   }\n\n   if (vert[8].t != 1.0f) {\n      // if the above fixup moved the endpoint away from 1.0, move it back,\n      // along with any other vertices that got moved to the same time\n      float t = vert[8].t;\n      for (j=5; j <= 8; ++j)\n         if (vert[j].t == t)\n            vert[j].t = 1.0f;\n   }\n\n   // compute the exact slopes from the final fixed-up positions\n   for (j=0; j < 8; ++j)\n      if (vert[j+1].t == vert[j].t)\n         vert[j].s = 0;\n      else\n         vert[j].s = (vert[j+1].v - vert[j].v) / (vert[j+1].t - vert[j].t);\n\n   // wraparound at end\n   vert[8].t = 1;\n   vert[8].v = vert[0].v;\n   vert[8].s = vert[0].s;\n}\n\nSTB_HEXWAVE_DEF void hexwave_generate_samples(float *output, int num_samples, HexWave *hex, float freq)\n{\n   hexvert vert[9];\n   int pass,i,j;\n   float t = hex->t;\n   float temp_output[2*STB_HEXWAVE_MAX_BLEP_LENGTH];\n   int buffered_length = sizeof(float)*hexblep.width;\n   float dt = (float) fabs(freq);\n   float recip_dt = (dt == 0.0f) ? 0.0f : 1.0f / dt;\n\n   int halfw = hexblep.width/2;\n   // all sample times are biased by halfw to leave room for BLEP/BLAMP to go back in time\n\n   if (num_samples <= 0)\n      return;\n\n   // convert parameters to times and slopes\n   hexwave_generate_linesegs(vert, hex, dt);\n\n   if (hex->prev_dt != dt) {\n      // if frequency changes, add a fixup at the derivative discontinuity starting at now\n      float slope;\n      for (j=1; j < 6; ++j)\n         if (t < vert[j].t)\n            break;\n      slope = vert[j].s;\n      if (slope != 0)\n         hex_blamp(output, 0, (dt - hex->prev_dt)*slope);\n      hex->prev_dt = dt;\n   }\n\n   // copy the buffered data from last call and clear the rest of the output array\n   memset(output, 0, sizeof(float)*num_samples);\n   memset(temp_output, 0, 2*hexblep.width*sizeof(float));\n\n   if (num_samples >= hexblep.width) {\n      memcpy(output, hex->buffer, buffered_length);\n   } else {\n      // if the output is shorter than hexblep.width, we do all synthesis to temp_output\n      memcpy(temp_output, hex->buffer, buffered_length);\n   }\n\n   for (pass=0; pass < 2; ++pass) {\n      int i0,i1;\n      float *out;\n\n      // we want to simulate having one buffer that is num_output + hexblep.width\n      // samples long, without putting that requirement on the user, and without\n      // allocating a temp buffer that's as long as the whole thing. so we use two\n      // overlapping buffers, one the user's buffer and one a fixed-length temp\n      // buffer.\n\n      if (pass == 0) {\n         if (num_samples < hexblep.width)\n            continue;\n         // run as far as we can without overwriting the end of the user's buffer \n         out = output;\n         i0 = 0;\n         i1 = num_samples - hexblep.width;\n      } else {\n         // generate the rest into a temp buffer\n         out = temp_output;\n         i0 = 0;\n         if (num_samples >= hexblep.width)\n            i1 = hexblep.width;\n         else\n            i1 = num_samples;\n      }\n\n      // determine current segment\n      for (j=0; j < 8; ++j)\n         if (t < vert[j+1].t)                                  \n            break;\n\n      i = i0;\n      for(;;) {\n         while (t < vert[j+1].t) {\n            if (i == i1)\n               goto done;\n            out[i+halfw] += vert[j].v + vert[j].s*(t - vert[j].t);\n            t += dt;\n            ++i;\n         }\n         // transition from lineseg starting at j to lineseg starting at j+1\n\n         if (vert[j].t == vert[j+1].t)\n            hex_blep(out+i, recip_dt*(t-vert[j+1].t), (vert[j+1].v - vert[j].v));\n         hex_blamp(out+i, recip_dt*(t-vert[j+1].t), dt*(vert[j+1].s - vert[j].s));\n         ++j;\n\n         if (j == 8) {\n            // change to different waveform if there's a change pending\n            j = 0;\n            t -= 1.0; // t was >= 1.f if j==8\n            if (hex->have_pending) {\n               float prev_s0 = vert[j].s;\n               float prev_v0 = vert[j].v;\n               hex->current = hex->pending;\n               hex->have_pending = 0;\n               hexwave_generate_linesegs(vert, hex, dt);\n               // the following never occurs with this oscillator, but it makes\n               // the code work in more general cases\n               if (vert[j].v != prev_v0)\n                  hex_blep (out+i, recip_dt*t,    (vert[j].v - prev_v0));\n               if (vert[j].s != prev_s0)\n                  hex_blamp(out+i, recip_dt*t, dt*(vert[j].s - prev_s0));\n            }\n         }\n      }\n     done:\n      ;\n   }\n\n   // at this point, we've written output[] and temp_output[]\n   if (num_samples >= hexblep.width) {\n      // the first half of temp[] overlaps the end of output, the second half will be the new start overlap\n      for (i=0; i < hexblep.width; ++i)\n         output[num_samples-hexblep.width + i] += temp_output[i];\n      memcpy(hex->buffer, temp_output+hexblep.width, buffered_length);\n   } else {\n      for (i=0; i < num_samples; ++i)\n         output[i] = temp_output[i];\n      memcpy(hex->buffer, temp_output+num_samples, buffered_length);\n   }\n\n   hex->t = t;\n}\n\nSTB_HEXWAVE_DEF void hexwave_shutdown(float *user_buffer)\n{\n   #ifndef STB_HEXWAVE_NO_ALLOCATION\n   if (user_buffer != 0) {\n      free(hexblep.blep);\n      free(hexblep.blamp);\n   }\n   #endif\n}\n\n// buffer should be NULL or must be 4*(width*(oversample+1)*2 + \nSTB_HEXWAVE_DEF void hexwave_init(int width, int oversample, float *user_buffer)\n{\n   int halfwidth = width/2;\n   int half = halfwidth*oversample;\n   int blep_buffer_count = width*(oversample+1);\n   int n = 2*half+1;\n#ifdef STB_HEXWAVE_NO_ALLOCATION\n   float *buffers = user_buffer;\n#else\n   float *buffers = user_buffer ? user_buffer : (float *) malloc(sizeof(float) * n * 2);\n#endif\n   float *step    = buffers+0*n;\n   float *ramp    = buffers+1*n;\n   float *blep_buffer, *blamp_buffer;\n   double integrate_impulse=0, integrate_step=0;\n   int i,j;\n\n   if (width > STB_HEXWAVE_MAX_BLEP_LENGTH)\n      width = STB_HEXWAVE_MAX_BLEP_LENGTH;\n\n   if (user_buffer == 0) {\n      #ifndef STB_HEXWAVE_NO_ALLOCATION\n      blep_buffer  = (float *) malloc(sizeof(float)*blep_buffer_count);\n      blamp_buffer = (float *) malloc(sizeof(float)*blep_buffer_count);\n      #endif\n   } else {\n      blep_buffer  = ramp+n;\n      blamp_buffer = blep_buffer + blep_buffer_count;\n   }\n\n   // compute BLEP and BLAMP by integerating windowed sinc\n   for (i=0; i < n; ++i) {\n      for (j=0; j < 16; ++j) {\n         float sinc_t = 3.141592f* (i-half) / oversample;\n         float sinc   = (i==half) ? 1.0f : (float) sin(sinc_t) / (sinc_t);\n         float wt     = 2.0f*3.1415926f * i / (n-1);\n         float window = (float) (0.355768 - 0.487396*cos(wt) + 0.144232*cos(2*wt) - 0.012604*cos(3*wt)); // Nuttall\n         double value       =         window * sinc;\n         integrate_impulse +=         value/16;\n         integrate_step    +=         integrate_impulse/16;\n      }\n      step[i]            = (float) integrate_impulse;\n      ramp[i]            = (float) integrate_step;\n   }\n\n   // renormalize\n   for (i=0; i < n; ++i) {\n      step[i] = step[i] * (float) (1.0       / step[n-1]); // step needs to reach to 1.0\n      ramp[i] = ramp[i] * (float) (halfwidth / ramp[n-1]); // ramp needs to become a slope of 1.0 after oversampling\n   }\n\n   // deinterleave to allow efficient interpolation e.g. w/SIMD\n   for (j=0; j <= oversample; ++j) {\n      for (i=0; i < width; ++i) {\n         blep_buffer [j*width+i] = step[j+i*oversample];\n         blamp_buffer[j*width+i] = ramp[j+i*oversample];\n      }\n   }\n\n   // subtract out the naive waveform; note we can't do this to the raw data\n   // above, because we want the discontinuity to be in a different locations\n   // for j=0 and j=oversample (which exists to provide something to interpolate against)\n   for (j=0; j <= oversample; ++j) {\n      // subtract step\n      for (i=halfwidth; i < width; ++i)\n         blep_buffer [j*width+i] -= 1.0f;\n      // subtract ramp\n      for (i=halfwidth; i < width; ++i)\n         blamp_buffer[j*width+i] -= (j+i*oversample-half)*(1.0f/oversample);\n   }\n\n   hexblep.blep  = blep_buffer;\n   hexblep.blamp = blamp_buffer;\n   hexblep.width = width;\n   hexblep.oversample = oversample;\n\n   #ifndef STB_HEXWAVE_NO_ALLOCATION\n   if (user_buffer == 0)\n      free(buffers);\n   #endif\n}\n#endif // STB_HEXWAVE_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_image.h",
          "type": "blob",
          "size": 276.376953125,
          "content": "/* stb_image - v2.30 - public domain image loader - http://nothings.org/stb\n                                  no warranty implied; use at your own risk\n\n   Do this:\n      #define STB_IMAGE_IMPLEMENTATION\n   before you include this file in *one* C or C++ file to create the implementation.\n\n   // i.e. it should look like this:\n   #include ...\n   #include ...\n   #include ...\n   #define STB_IMAGE_IMPLEMENTATION\n   #include \"stb_image.h\"\n\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\n\n\n   QUICK NOTES:\n      Primarily of interest to game developers and other people who can\n          avoid problematic images and only need the trivial interface\n\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\n      PNG 1/2/4/8/16-bit-per-channel\n\n      TGA (not sure what subset, if a subset)\n      BMP non-1bpp, non-RLE\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\n\n      GIF (*comp always reports as 4-channel)\n      HDR (radiance rgbE format)\n      PIC (Softimage PIC)\n      PNM (PPM and PGM binary only)\n\n      Animated GIF still needs a proper API, but here's one way to do it:\n          http://gist.github.com/urraka/685d9a6340b26b830d49\n\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\n      - decode from arbitrary I/O callbacks\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\n\n   Full documentation under \"DOCUMENTATION\" below.\n\n\nLICENSE\n\n  See end of file for license information.\n\nRECENT REVISION HISTORY:\n\n      2.30  (2024-05-31) avoid erroneous gcc warning\n      2.29  (2023-05-xx) optimizations\n      2.28  (2023-01-29) many error fixes, security errors, just tons of stuff\n      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes\n      2.26  (2020-07-13) many minor fixes\n      2.25  (2020-02-02) fix warnings\n      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically\n      2.23  (2019-08-11) fix clang static analysis warning\n      2.22  (2019-03-04) gif fixes, fix warnings\n      2.21  (2019-02-25) fix typo in comment\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\n                         RGB-format JPEG; remove white matting in PSD;\n                         allocate large structures on the stack;\n                         correct channel count for PNG & BMP\n      2.10  (2016-01-22) avoid warning introduced in 2.09\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\n\n   See end of file for full revision history.\n\n\n ============================    Contributors    =========================\n\n Image formats                          Extensions, features\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\n    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)\n                                           socks-the-fox (16-bit PNG)\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\n Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)\n    Fabian \"ryg\" Giesen                    Anael Seghezzi (is-16-bit query)\n    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)\n    John-Mark Allen\n    Carmelo J Fdez-Aguera\n\n Bug & warning fixes\n    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski\n    Phil Jordan                                Dave Moore           Roy Eltham\n    Hayaki Saito            Nathan Reed        Won Chun\n    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community\n    Thomas Ruf              Ronny Chevalier                         github:rlyeh\n    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou\n    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk\n    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar\n    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex\n    Cass Everitt            Ryamond Barbiero                        github:grim210\n    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw\n    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus\n    Josh Tobin              Neil Bickford      Matthew Gregan       github:poppolopoppo\n    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji\n    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007\n                            Brad Weinberger    Matvey Cherevko      github:mosra\n    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]\n    Ryan C. Gordon          [reserved]                              [reserved]\n                     DO NOT ADD YOUR NAME HERE\n\n                     Jacko Dirks\n\n  To add your name to the credits, pick a random blank space in the middle and fill it.\n  80% of merge conflicts on stb PRs are due to people adding their name at the end\n  of the credits.\n*/\n\n#ifndef STBI_INCLUDE_STB_IMAGE_H\n#define STBI_INCLUDE_STB_IMAGE_H\n\n// DOCUMENTATION\n//\n// Limitations:\n//    - no 12-bit-per-channel JPEG\n//    - no JPEGs with arithmetic coding\n//    - GIF always returns *comp=4\n//\n// Basic usage (see HDR discussion below for HDR usage):\n//    int x,y,n;\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\n//    // ... process data if not NULL ...\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\n//    // ... but 'n' will always be the number that it would have been if you said 0\n//    stbi_image_free(data);\n//\n// Standard parameters:\n//    int *x                 -- outputs image width in pixels\n//    int *y                 -- outputs image height in pixels\n//    int *channels_in_file  -- outputs # of image components in image file\n//    int desired_channels   -- if non-zero, # of image components requested in result\n//\n// The return value from an image loader is an 'unsigned char *' which points\n// to the pixel data, or NULL on an allocation failure or if the image is\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\n// with each pixel consisting of N interleaved 8-bit components; the first\n// pixel pointed to is top-left-most in the image. There is no padding between\n// image scanlines or between pixels, regardless of format. The number of\n// components N is 'desired_channels' if desired_channels is non-zero, or\n// *channels_in_file otherwise. If desired_channels is non-zero,\n// *channels_in_file has the number of components that _would_ have been\n// output otherwise. E.g. if you set desired_channels to 4, you will always\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\n// opaque because e.g. there were only 3 channels in the source image.\n//\n// An output image with N components has the following components interleaved\n// in this order in each pixel:\n//\n//     N=#comp     components\n//       1           grey\n//       2           grey, alpha\n//       3           red, green, blue\n//       4           red, green, blue, alpha\n//\n// If image loading fails for any reason, the return value will be NULL,\n// and *x, *y, *channels_in_file will be unchanged. The function\n// stbi_failure_reason() can be queried for an extremely brief, end-user\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\n// more user-friendly ones.\n//\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\n//\n// To query the width, height and component count of an image without having to\n// decode the full file, you can use the stbi_info family of functions:\n//\n//   int x,y,n,ok;\n//   ok = stbi_info(filename, &x, &y, &n);\n//   // returns ok=1 and sets x, y, n if image is a supported format,\n//   // 0 otherwise.\n//\n// Note that stb_image pervasively uses ints in its public API for sizes,\n// including sizes of memory buffers. This is now part of the API and thus\n// hard to change without causing breakage. As a result, the various image\n// loaders all have certain limits on image size; these differ somewhat\n// by format but generally boil down to either just under 2GB or just under\n// 1GB. When the decoded image would be larger than this, stb_image decoding\n// will fail.\n//\n// Additionally, stb_image will reject image files that have any of their\n// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,\n// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,\n// the only way to have an image with such dimensions load correctly\n// is for it to have a rather extreme aspect ratio. Either way, the\n// assumption here is that such larger images are likely to be malformed\n// or malicious. If you do need to load an image with individual dimensions\n// larger than that, and it still fits in the overall size limit, you can\n// #define STBI_MAX_DIMENSIONS on your own to be something larger.\n//\n// ===========================================================================\n//\n// UNICODE:\n//\n//   If compiling for Windows and you wish to use Unicode filenames, compile\n//   with\n//       #define STBI_WINDOWS_UTF8\n//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert\n//   Windows wchar_t filenames to utf8.\n//\n// ===========================================================================\n//\n// Philosophy\n//\n// stb libraries are designed with the following priorities:\n//\n//    1. easy to use\n//    2. easy to maintain\n//    3. good performance\n//\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\n// and for best performance I may provide less-easy-to-use APIs that give higher\n// performance, in addition to the easy-to-use ones. Nevertheless, it's important\n// to keep in mind that from the standpoint of you, a client of this library,\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\n//\n// Some secondary priorities arise directly from the first two, some of which\n// provide more explicit reasons why performance can't be emphasized.\n//\n//    - Portable (\"ease of use\")\n//    - Small source code footprint (\"easy to maintain\")\n//    - No dependencies (\"ease of use\")\n//\n// ===========================================================================\n//\n// I/O callbacks\n//\n// I/O callbacks allow you to read from arbitrary sources, like packaged\n// files or some other source. Data read from callbacks are processed\n// through a small internal buffer (currently 128 bytes) to try to reduce\n// overhead.\n//\n// The three functions you must define are \"read\" (reads some bytes of data),\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\n//\n// ===========================================================================\n//\n// SIMD support\n//\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\n// supported by the compiler. For ARM Neon support, you must explicitly\n// request it.\n//\n// (The old do-it-yourself SIMD API is no longer supported in the current\n// code.)\n//\n// On x86, SSE2 will automatically be used when available based on a run-time\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\n// the typical path is to have separate builds for NEON and non-NEON devices\n// (at least this is true for iOS and Android). Therefore, the NEON support is\n// toggled by a build flag: define STBI_NEON to get NEON loops.\n//\n// If for some reason you do not want to use any of SIMD code, or if\n// you have issues compiling it, you can disable it entirely by\n// defining STBI_NO_SIMD.\n//\n// ===========================================================================\n//\n// HDR image support   (disable by defining STBI_NO_HDR)\n//\n// stb_image supports loading HDR images in general, and currently the Radiance\n// .HDR file format specifically. You can still load any file through the existing\n// interface; if you attempt to load an HDR file, it will be automatically remapped\n// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\n// both of these constants can be reconfigured through this interface:\n//\n//     stbi_hdr_to_ldr_gamma(2.2f);\n//     stbi_hdr_to_ldr_scale(1.0f);\n//\n// (note, do not use _inverse_ constants; stbi_image will invert them\n// appropriately).\n//\n// Additionally, there is a new, parallel interface for loading files as\n// (linear) floats to preserve the full dynamic range:\n//\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\n//\n// If you load LDR images through this interface, those images will\n// be promoted to floating point values, run through the inverse of\n// constants corresponding to the above:\n//\n//     stbi_ldr_to_hdr_scale(1.0f);\n//     stbi_ldr_to_hdr_gamma(2.2f);\n//\n// Finally, given a filename (or an open file or memory block--see header\n// file for details) containing image data, you can query for the \"most\n// appropriate\" interface to use (that is, whether the image is HDR or\n// not), using:\n//\n//     stbi_is_hdr(char *filename);\n//\n// ===========================================================================\n//\n// iPhone PNG support:\n//\n// We optionally support converting iPhone-formatted PNGs (which store\n// premultiplied BGRA) back to RGB, even though they're internally encoded\n// differently. To enable this conversion, call\n// stbi_convert_iphone_png_to_rgb(1).\n//\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\n// says there's premultiplied data (currently only happens in iPhone images,\n// and only if iPhone convert-to-rgb processing is on).\n//\n// ===========================================================================\n//\n// ADDITIONAL CONFIGURATION\n//\n//  - You can suppress implementation of any of the decoders to reduce\n//    your code footprint by #defining one or more of the following\n//    symbols before creating the implementation.\n//\n//        STBI_NO_JPEG\n//        STBI_NO_PNG\n//        STBI_NO_BMP\n//        STBI_NO_PSD\n//        STBI_NO_TGA\n//        STBI_NO_GIF\n//        STBI_NO_HDR\n//        STBI_NO_PIC\n//        STBI_NO_PNM   (.ppm and .pgm)\n//\n//  - You can request *only* certain decoders and suppress all other ones\n//    (this will be more forward-compatible, as addition of new decoders\n//    doesn't require you to disable them explicitly):\n//\n//        STBI_ONLY_JPEG\n//        STBI_ONLY_PNG\n//        STBI_ONLY_BMP\n//        STBI_ONLY_PSD\n//        STBI_ONLY_TGA\n//        STBI_ONLY_GIF\n//        STBI_ONLY_HDR\n//        STBI_ONLY_PIC\n//        STBI_ONLY_PNM   (.ppm and .pgm)\n//\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\n//\n//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater\n//    than that size (in either width or height) without further processing.\n//    This is to let programs in the wild set an upper bound to prevent\n//    denial-of-service attacks on untrusted data, as one could generate a\n//    valid image of gigantic dimensions and force stb_image to allocate a\n//    huge block of memory and spend disproportionate time decoding it. By\n//    default this is set to (1 << 24), which is 16777216, but that's still\n//    very big.\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif // STBI_NO_STDIO\n\n#define STBI_VERSION 1\n\nenum\n{\n   STBI_default = 0, // only used for desired_channels\n\n   STBI_grey       = 1,\n   STBI_grey_alpha = 2,\n   STBI_rgb        = 3,\n   STBI_rgb_alpha  = 4\n};\n\n#include <stdlib.h>\ntypedef unsigned char stbi_uc;\ntypedef unsigned short stbi_us;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef STBIDEF\n#ifdef STB_IMAGE_STATIC\n#define STBIDEF static\n#else\n#define STBIDEF extern\n#endif\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PRIMARY API - works on images of any type\n//\n\n//\n// load image by filename, open file, or memory buffer\n//\n\ntypedef struct\n{\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\n} stbi_io_callbacks;\n\n////////////////////////////////////\n//\n// 8-bits-per-channel interface\n//\n\nSTBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n// for stbi_load_from_file, file pointer is left pointing immediately after image\n#endif\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\n#endif\n\n#ifdef STBI_WINDOWS_UTF8\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);\n#endif\n\n////////////////////////////////////\n//\n// 16-bits-per-channel interface\n//\n\nSTBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n#endif\n\n////////////////////////////////////\n//\n// float-per-channel interface\n//\n#ifndef STBI_NO_LINEAR\n   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);\n\n   #ifndef STBI_NO_STDIO\n   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n   #endif\n#endif\n\n#ifndef STBI_NO_HDR\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_LINEAR\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\n#endif // STBI_NO_LINEAR\n\n// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename);\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\n#endif // STBI_NO_STDIO\n\n\n// get a VERY brief reason for failure\n// on most compilers (and ALL modern mainstream compilers) this is threadsafe\nSTBIDEF const char *stbi_failure_reason  (void);\n\n// free the loaded image -- this is just free()\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\n\n// get image dimensions & components without fully decoding\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);\nSTBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit          (char const *filename);\nSTBIDEF int      stbi_is_16_bit_from_file(FILE *f);\n#endif\n\n\n\n// for image formats that explicitly notate that they have premultiplied alpha,\n// we just return the colors as stored in the file. set this flag to force\n// unpremultiplication. results are undefined if the unpremultiply overflow.\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\n\n// indicate whether we should process iphone images back to canonical format,\n// or just pass them through \"as-is\"\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\n\n// flip the image vertically, so the first pixel in the output array is the bottom left\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\n\n// as above, but only applies to images loaded on the thread that calls the function\n// this function is only available if your compiler supports thread-local variables;\n// calling it will fail to link if your compiler doesn't\nSTBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);\n\n// ZLIB client - used by PNG, available for other purposes\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n//\n//\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBI_INCLUDE_STB_IMAGE_H\n\n#ifdef STB_IMAGE_IMPLEMENTATION\n\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\n  || defined(STBI_ONLY_ZLIB)\n   #ifndef STBI_ONLY_JPEG\n   #define STBI_NO_JPEG\n   #endif\n   #ifndef STBI_ONLY_PNG\n   #define STBI_NO_PNG\n   #endif\n   #ifndef STBI_ONLY_BMP\n   #define STBI_NO_BMP\n   #endif\n   #ifndef STBI_ONLY_PSD\n   #define STBI_NO_PSD\n   #endif\n   #ifndef STBI_ONLY_TGA\n   #define STBI_NO_TGA\n   #endif\n   #ifndef STBI_ONLY_GIF\n   #define STBI_NO_GIF\n   #endif\n   #ifndef STBI_ONLY_HDR\n   #define STBI_NO_HDR\n   #endif\n   #ifndef STBI_ONLY_PIC\n   #define STBI_NO_PIC\n   #endif\n   #ifndef STBI_ONLY_PNM\n   #define STBI_NO_PNM\n   #endif\n#endif\n\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\n#define STBI_NO_ZLIB\n#endif\n\n\n#include <stdarg.h>\n#include <stddef.h> // ptrdiff_t on osx\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\n#include <math.h>  // ldexp, pow\n#endif\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef STBI_ASSERT\n#include <assert.h>\n#define STBI_ASSERT(x) assert(x)\n#endif\n\n#ifdef __cplusplus\n#define STBI_EXTERN extern \"C\"\n#else\n#define STBI_EXTERN extern\n#endif\n\n\n#ifndef _MSC_VER\n   #ifdef __cplusplus\n   #define stbi_inline inline\n   #else\n   #define stbi_inline\n   #endif\n#else\n   #define stbi_inline __forceinline\n#endif\n\n#ifndef STBI_NO_THREAD_LOCALS\n   #if defined(__cplusplus) &&  __cplusplus >= 201103L\n      #define STBI_THREAD_LOCAL       thread_local\n   #elif defined(__GNUC__) && __GNUC__ < 5\n      #define STBI_THREAD_LOCAL       __thread\n   #elif defined(_MSC_VER)\n      #define STBI_THREAD_LOCAL       __declspec(thread)\n   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n      #define STBI_THREAD_LOCAL       _Thread_local\n   #endif\n\n   #ifndef STBI_THREAD_LOCAL\n      #if defined(__GNUC__)\n        #define STBI_THREAD_LOCAL       __thread\n      #endif\n   #endif\n#endif\n\n#if defined(_MSC_VER) || defined(__SYMBIAN32__)\ntypedef unsigned short stbi__uint16;\ntypedef   signed short stbi__int16;\ntypedef unsigned int   stbi__uint32;\ntypedef   signed int   stbi__int32;\n#else\n#include <stdint.h>\ntypedef uint16_t stbi__uint16;\ntypedef int16_t  stbi__int16;\ntypedef uint32_t stbi__uint32;\ntypedef int32_t  stbi__int32;\n#endif\n\n// should produce compiler error if size is wrong\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\n\n#ifdef _MSC_VER\n#define STBI_NOTUSED(v)  (void)(v)\n#else\n#define STBI_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef _MSC_VER\n#define STBI_HAS_LROTL\n#endif\n\n#ifdef STBI_HAS_LROTL\n   #define stbi_lrot(x,y)  _lrotl(x,y)\n#else\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))\n#endif\n\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\n// ok\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\n// ok\n#else\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\n#endif\n\n#ifndef STBI_MALLOC\n#define STBI_MALLOC(sz)           malloc(sz)\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\n#define STBI_FREE(p)              free(p)\n#endif\n\n#ifndef STBI_REALLOC_SIZED\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\n#endif\n\n// x86/x64 detection\n#if defined(__x86_64__) || defined(_M_X64)\n#define STBI__X64_TARGET\n#elif defined(__i386) || defined(_M_IX86)\n#define STBI__X86_TARGET\n#endif\n\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\n// but previous attempts to provide the SSE2 functions with runtime\n// detection caused numerous issues. The way architecture extensions are\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\n// New behavior: if compiled with -msse2, we use SSE2 without any\n// detection; if not, we don't use it at all.\n#define STBI_NO_SIMD\n#endif\n\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\n//\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\n// simultaneously enabling \"-mstackrealign\".\n//\n// See https://github.com/nothings/stb/issues/81 for more information.\n//\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\n#define STBI_NO_SIMD\n#endif\n\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\n#define STBI_SSE2\n#include <emmintrin.h>\n\n#ifdef _MSC_VER\n\n#if _MSC_VER >= 1400  // not VC6\n#include <intrin.h> // __cpuid\nstatic int stbi__cpuid3(void)\n{\n   int info[4];\n   __cpuid(info,1);\n   return info[3];\n}\n#else\nstatic int stbi__cpuid3(void)\n{\n   int res;\n   __asm {\n      mov  eax,1\n      cpuid\n      mov  res,edx\n   }\n   return res;\n}\n#endif\n\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   int info3 = stbi__cpuid3();\n   return ((info3 >> 26) & 1) != 0;\n}\n#endif\n\n#else // assume GCC-style if not VC++\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   // If we're even attempting to compile this on GCC/Clang, that means\n   // -msse2 is on, which means the compiler is allowed to use SSE2\n   // instructions at will, and so are we.\n   return 1;\n}\n#endif\n\n#endif\n#endif\n\n// ARM NEON\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\n#undef STBI_NEON\n#endif\n\n#ifdef STBI_NEON\n#include <arm_neon.h>\n#ifdef _MSC_VER\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n#else\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n#endif\n#endif\n\n#ifndef STBI_SIMD_ALIGN\n#define STBI_SIMD_ALIGN(type, name) type name\n#endif\n\n#ifndef STBI_MAX_DIMENSIONS\n#define STBI_MAX_DIMENSIONS (1 << 24)\n#endif\n\n///////////////////////////////////////////////\n//\n//  stbi__context struct and start_xxx functions\n\n// stbi__context structure is our basic context used by all images, so it\n// contains all the IO context, plus some basic image information\ntypedef struct\n{\n   stbi__uint32 img_x, img_y;\n   int img_n, img_out_n;\n\n   stbi_io_callbacks io;\n   void *io_user_data;\n\n   int read_from_callbacks;\n   int buflen;\n   stbi_uc buffer_start[128];\n   int callback_already_read;\n\n   stbi_uc *img_buffer, *img_buffer_end;\n   stbi_uc *img_buffer_original, *img_buffer_original_end;\n} stbi__context;\n\n\nstatic void stbi__refill_buffer(stbi__context *s);\n\n// initialize a memory-decode context\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\n{\n   s->io.read = NULL;\n   s->read_from_callbacks = 0;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\n   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;\n}\n\n// initialize a callback-based context\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\n{\n   s->io = *c;\n   s->io_user_data = user;\n   s->buflen = sizeof(s->buffer_start);\n   s->read_from_callbacks = 1;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = s->buffer_start;\n   stbi__refill_buffer(s);\n   s->img_buffer_original_end = s->img_buffer_end;\n}\n\n#ifndef STBI_NO_STDIO\n\nstatic int stbi__stdio_read(void *user, char *data, int size)\n{\n   return (int) fread(data,1,size,(FILE*) user);\n}\n\nstatic void stbi__stdio_skip(void *user, int n)\n{\n   int ch;\n   fseek((FILE*) user, n, SEEK_CUR);\n   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */\n   if (ch != EOF) {\n      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */\n   }\n}\n\nstatic int stbi__stdio_eof(void *user)\n{\n   return feof((FILE*) user) || ferror((FILE *) user);\n}\n\nstatic stbi_io_callbacks stbi__stdio_callbacks =\n{\n   stbi__stdio_read,\n   stbi__stdio_skip,\n   stbi__stdio_eof,\n};\n\nstatic void stbi__start_file(stbi__context *s, FILE *f)\n{\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\n}\n\n//static void stop_file(stbi__context *s) { }\n\n#endif // !STBI_NO_STDIO\n\nstatic void stbi__rewind(stbi__context *s)\n{\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\n   // but we just rewind to the beginning of the initial buffer, because\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\n   s->img_buffer = s->img_buffer_original;\n   s->img_buffer_end = s->img_buffer_original_end;\n}\n\nenum\n{\n   STBI_ORDER_RGB,\n   STBI_ORDER_BGR\n};\n\ntypedef struct\n{\n   int bits_per_channel;\n   int num_channels;\n   int channel_order;\n} stbi__result_info;\n\n#ifndef STBI_NO_JPEG\nstatic int      stbi__jpeg_test(stbi__context *s);\nstatic void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNG\nstatic int      stbi__png_test(stbi__context *s);\nstatic void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__png_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_BMP\nstatic int      stbi__bmp_test(stbi__context *s);\nstatic void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_TGA\nstatic int      stbi__tga_test(stbi__context *s);\nstatic void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int      stbi__psd_test(stbi__context *s);\nstatic void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);\nstatic int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__psd_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic int      stbi__hdr_test(stbi__context *s);\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int      stbi__pic_test(stbi__context *s);\nstatic void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_GIF\nstatic int      stbi__gif_test(stbi__context *s);\nstatic void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNM\nstatic int      stbi__pnm_test(stbi__context *s);\nstatic void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__pnm_is16(stbi__context *s);\n#endif\n\nstatic\n#ifdef STBI_THREAD_LOCAL\nSTBI_THREAD_LOCAL\n#endif\nconst char *stbi__g_failure_reason;\n\nSTBIDEF const char *stbi_failure_reason(void)\n{\n   return stbi__g_failure_reason;\n}\n\n#ifndef STBI_NO_FAILURE_STRINGS\nstatic int stbi__err(const char *str)\n{\n   stbi__g_failure_reason = str;\n   return 0;\n}\n#endif\n\nstatic void *stbi__malloc(size_t size)\n{\n    return STBI_MALLOC(size);\n}\n\n// stb_image uses ints pervasively, including for offset calculations.\n// therefore the largest decoded image size we can support with the\n// current code, even on 64-bit targets, is INT_MAX. this is not a\n// significant limitation for the intended use case.\n//\n// we do, however, need to make sure our size calculations don't\n// overflow. hence a few helper functions for size calculations that\n// multiply integers together, making sure that they're non-negative\n// and no overflow occurs.\n\n// return 1 if the sum is valid, 0 on overflow.\n// negative terms are considered invalid.\nstatic int stbi__addsizes_valid(int a, int b)\n{\n   if (b < 0) return 0;\n   // now 0 <= b <= INT_MAX, hence also\n   // 0 <= INT_MAX - b <= INTMAX.\n   // And \"a + b <= INT_MAX\" (which might overflow) is the\n   // same as a <= INT_MAX - b (no overflow)\n   return a <= INT_MAX - b;\n}\n\n// returns 1 if the product is valid, 0 on overflow.\n// negative factors are considered invalid.\nstatic int stbi__mul2sizes_valid(int a, int b)\n{\n   if (a < 0 || b < 0) return 0;\n   if (b == 0) return 1; // mul-by-0 is always safe\n   // portable way to check for no overflows in a*b\n   return a <= INT_MAX/b;\n}\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);\n}\n#endif\n\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__addsizes_valid(a*b*c, add);\n}\n\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);\n}\n#endif\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// mallocs with size overflow checking\nstatic void *stbi__malloc_mad2(int a, int b, int add)\n{\n   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\n   return stbi__malloc(a*b + add);\n}\n#endif\n\nstatic void *stbi__malloc_mad3(int a, int b, int c, int add)\n{\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\n   return stbi__malloc(a*b*c + add);\n}\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic void *stbi__malloc_mad4(int a, int b, int c, int d, int add)\n{\n   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\n   return stbi__malloc(a*b*c*d + add);\n}\n#endif\n\n// returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.\nstatic int stbi__addints_valid(int a, int b)\n{\n   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow\n   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.\n   return a <= INT_MAX - b;\n}\n\n// returns 1 if the product of two ints fits in a signed short, 0 on overflow.\nstatic int stbi__mul2shorts_valid(int a, int b)\n{\n   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow\n   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid\n   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN\n   return a >= SHRT_MIN / b;\n}\n\n// stbi__err - error\n// stbi__errpf - error returning pointer to float\n// stbi__errpuc - error returning pointer to unsigned char\n\n#ifdef STBI_NO_FAILURE_STRINGS\n   #define stbi__err(x,y)  0\n#elif defined(STBI_FAILURE_USERMSG)\n   #define stbi__err(x,y)  stbi__err(y)\n#else\n   #define stbi__err(x,y)  stbi__err(x)\n#endif\n\n#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))\n#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))\n\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\n{\n   STBI_FREE(retval_from_stbi_load);\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\n#endif\n\nstatic int stbi__vertically_flip_on_load_global = 0;\n\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;\n\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;\n   stbi__vertically_flip_on_load_set = 1;\n}\n\n#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \\\n                                         ? stbi__vertically_flip_on_load_local  \\\n                                         : stbi__vertically_flip_on_load_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\n   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\n   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\n   ri->num_channels = 0;\n\n   // test the formats with a very explicit header first (at least a FOURCC\n   // or distinctive magic number first)\n   #ifndef STBI_NO_PNG\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);\n   #else\n   STBI_NOTUSED(bpc);\n   #endif\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   // then the formats that can end up attempting to load with just 1 or 2\n   // bytes matching expectations; these are prone to false positives, so\n   // try them later\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\n   }\n   #endif\n\n   #ifndef STBI_NO_TGA\n   // test tga last because it's a crappy test!\n   if (stbi__tga_test(s))\n      return stbi__tga_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi_uc *reduced;\n\n   reduced = (stbi_uc *) stbi__malloc(img_len);\n   if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\n\n   STBI_FREE(orig);\n   return reduced;\n}\n\nstatic stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi__uint16 *enlarged;\n\n   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);\n   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\n\n   STBI_FREE(orig);\n   return enlarged;\n}\n\nstatic void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)\n{\n   int row;\n   size_t bytes_per_row = (size_t)w * bytes_per_pixel;\n   stbi_uc temp[2048];\n   stbi_uc *bytes = (stbi_uc *)image;\n\n   for (row = 0; row < (h>>1); row++) {\n      stbi_uc *row0 = bytes + row*bytes_per_row;\n      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;\n      // swap row0 with row1\n      size_t bytes_left = bytes_per_row;\n      while (bytes_left) {\n         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\n         memcpy(temp, row0, bytes_copy);\n         memcpy(row0, row1, bytes_copy);\n         memcpy(row1, temp, bytes_copy);\n         row0 += bytes_copy;\n         row1 += bytes_copy;\n         bytes_left -= bytes_copy;\n      }\n   }\n}\n\n#ifndef STBI_NO_GIF\nstatic void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)\n{\n   int slice;\n   int slice_size = w * h * bytes_per_pixel;\n\n   stbi_uc *bytes = (stbi_uc *)image;\n   for (slice = 0; slice < z; ++slice) {\n      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);\n      bytes += slice_size;\n   }\n}\n#endif\n\nstatic unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 8) {\n      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 8;\n   }\n\n   // @TODO: move stbi__convert_format to here\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\n   }\n\n   return (unsigned char *) result;\n}\n\nstatic stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 16) {\n      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 16;\n   }\n\n   // @TODO: move stbi__convert_format16 to here\n   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\n   }\n\n   return (stbi__uint16 *) result;\n}\n\n#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)\nstatic void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)\n{\n   if (stbi__vertically_flip_on_load && result != NULL) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\n   }\n}\n#endif\n\n#ifndef STBI_NO_STDIO\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);\nSTBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);\n#endif\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)\n{\n\treturn WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);\n}\n#endif\n\nstatic FILE *stbi__fopen(char const *filename, char const *mode)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\n   wchar_t wMode[64];\n   wchar_t wFilename[1024];\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))\n      return 0;\n\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))\n      return 0;\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n\tif (0 != _wfopen_s(&f, wFilename, wMode))\n\t\tf = 0;\n#else\n   f = _wfopen(wFilename, wMode);\n#endif\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != fopen_s(&f, filename, mode))\n      f=0;\n#else\n   f = fopen(filename, mode);\n#endif\n   return f;\n}\n\n\nSTBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   unsigned char *result;\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__uint16 *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   stbi__uint16 *result;\n   if (!f) return (stbi_us *) stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file_16(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\n\n#endif //!STBI_NO_STDIO\n\nSTBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n\n   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);\n   if (stbi__vertically_flip_on_load) {\n      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );\n   }\n\n   return result;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *data;\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      stbi__result_info ri;\n      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);\n      if (hdr_data)\n         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);\n      return hdr_data;\n   }\n   #endif\n   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\n   if (data)\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nSTBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   float *result;\n   FILE *f = stbi__fopen(filename, \"rb\");\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_file(&s,f);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n#endif // !STBI_NO_STDIO\n\n#endif // !STBI_NO_LINEAR\n\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\n// reports false!\n\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   int result=0;\n   if (f) {\n      result = stbi_is_hdr_from_file(f);\n      fclose(f);\n   }\n   return result;\n}\n\nSTBIDEF int stbi_is_hdr_from_file(FILE *f)\n{\n   #ifndef STBI_NO_HDR\n   long pos = ftell(f);\n   int res;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   res = stbi__hdr_test(&s);\n   fseek(f, pos, SEEK_SET);\n   return res;\n   #else\n   STBI_NOTUSED(f);\n   return 0;\n   #endif\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(clbk);\n   STBI_NOTUSED(user);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\n\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\n#endif\n\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\n\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Common code used by all image loaders\n//\n\nenum\n{\n   STBI__SCAN_load=0,\n   STBI__SCAN_type,\n   STBI__SCAN_header\n};\n\nstatic void stbi__refill_buffer(stbi__context *s)\n{\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\n   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);\n   if (n == 0) {\n      // at end of file, treat same as if from memory, but need to handle case\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\n      s->read_from_callbacks = 0;\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start+1;\n      *s->img_buffer = 0;\n   } else {\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start + n;\n   }\n}\n\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\n{\n   if (s->img_buffer < s->img_buffer_end)\n      return *s->img_buffer++;\n   if (s->read_from_callbacks) {\n      stbi__refill_buffer(s);\n      return *s->img_buffer++;\n   }\n   return 0;\n}\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstbi_inline static int stbi__at_eof(stbi__context *s)\n{\n   if (s->io.read) {\n      if (!(s->io.eof)(s->io_user_data)) return 0;\n      // if feof() is true, check if buffer = end\n      // special case: we've only got the special 0 character at the end\n      if (s->read_from_callbacks == 0) return 1;\n   }\n\n   return s->img_buffer >= s->img_buffer_end;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic void stbi__skip(stbi__context *s, int n)\n{\n   if (n == 0) return;  // already there!\n   if (n < 0) {\n      s->img_buffer = s->img_buffer_end;\n      return;\n   }\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         s->img_buffer = s->img_buffer_end;\n         (s->io.skip)(s->io_user_data, n - blen);\n         return;\n      }\n   }\n   s->img_buffer += n;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         int res, count;\n\n         memcpy(buffer, s->img_buffer, blen);\n\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\n         res = (count == (n-blen));\n         s->img_buffer = s->img_buffer_end;\n         return res;\n      }\n   }\n\n   if (s->img_buffer+n <= s->img_buffer_end) {\n      memcpy(buffer, s->img_buffer, n);\n      s->img_buffer += n;\n      return 1;\n   } else\n      return 0;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic int stbi__get16be(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return (z << 8) + stbi__get8(s);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16be(s);\n   return (z << 16) + stbi__get16be(s);\n}\n#endif\n\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\n// nothing\n#else\nstatic int stbi__get16le(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return z + (stbi__get8(s) << 8);\n}\n#endif\n\n#ifndef STBI_NO_BMP\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16le(s);\n   z += (stbi__uint32)stbi__get16le(s) << 16;\n   return z;\n}\n#endif\n\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\n//////////////////////////////////////////////////////////////////////////////\n//\n//  generic converter from built-in img_n to req_comp\n//    individual types do this automatically as much as possible (e.g. jpeg\n//    does all cases internally since it needs to colorspace convert anyway,\n//    and it never has alpha, so very few cases ). png can automatically\n//    interleave an alpha=255 channel, but falls back to this for other cases\n//\n//  assume data buffer is malloced, so malloc a new one and free that one\n//  only failure mode is malloc failing\n\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\n{\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   unsigned char *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      unsigned char *src  = data + j * x * img_n   ;\n      unsigned char *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\n{\n   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   stbi__uint16 *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      stbi__uint16 *src  = data + j * x * img_n   ;\n      stbi__uint16 *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\n{\n   int i,k,n;\n   float *output;\n   if (!data) return NULL;\n   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\n      }\n   }\n   if (n < comp) {\n      for (i=0; i < x*y; ++i) {\n         output[i*comp + n] = data[i*comp + n]/255.0f;\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n#ifndef STBI_NO_HDR\n#define stbi__float2int(x)   ((int) (x))\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\n{\n   int i,k,n;\n   stbi_uc *output;\n   if (!data) return NULL;\n   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n      if (k < comp) {\n         float z = data[i*comp+k] * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  \"baseline\" JPEG/JFIF decoder\n//\n//    simple implementation\n//      - doesn't support delayed output of y-dimension\n//      - simple interface (only one output format: 8-bit interleaved RGB)\n//      - doesn't try to recover corrupt jpegs\n//      - doesn't allow partial loading, loading multiple at once\n//      - still fast on x86 (copying globals into locals doesn't help x86)\n//      - allocates lots of intermediate memory (full size of all components)\n//        - non-interleaved case requires this anyway\n//        - allows good upsampling (see next)\n//    high-quality\n//      - upsampled channels are bilinearly interpolated, even across blocks\n//      - quality integer IDCT derived from IJG's 'slow'\n//    performance\n//      - fast huffman; reasonable integer IDCT\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\n//      - uses a lot of intermediate memory, could cache poorly\n\n#ifndef STBI_NO_JPEG\n\n// huffman decoding acceleration\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\n\ntypedef struct\n{\n   stbi_uc  fast[1 << FAST_BITS];\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\n   stbi__uint16 code[256];\n   stbi_uc  values[256];\n   stbi_uc  size[257];\n   unsigned int maxcode[18];\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\n} stbi__huffman;\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi__huffman huff_dc[4];\n   stbi__huffman huff_ac[4];\n   stbi__uint16 dequant[4][64];\n   stbi__int16 fast_ac[4][1 << FAST_BITS];\n\n// sizes for components, interleaved MCUs\n   int img_h_max, img_v_max;\n   int img_mcu_x, img_mcu_y;\n   int img_mcu_w, img_mcu_h;\n\n// definition of jpeg image component\n   struct\n   {\n      int id;\n      int h,v;\n      int tq;\n      int hd,ha;\n      int dc_pred;\n\n      int x,y,w2,h2;\n      stbi_uc *data;\n      void *raw_data, *raw_coeff;\n      stbi_uc *linebuf;\n      short   *coeff;   // progressive only\n      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\n   } img_comp[4];\n\n   stbi__uint32   code_buffer; // jpeg entropy-coded buffer\n   int            code_bits;   // number of valid bits\n   unsigned char  marker;      // marker seen while filling entropy buffer\n   int            nomore;      // flag if we saw a marker so must stop\n\n   int            progressive;\n   int            spec_start;\n   int            spec_end;\n   int            succ_high;\n   int            succ_low;\n   int            eob_run;\n   int            jfif;\n   int            app14_color_transform; // Adobe APP14 tag\n   int            rgb;\n\n   int scan_n, order[4];\n   int restart_interval, todo;\n\n// kernels\n   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);\n   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);\n   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);\n} stbi__jpeg;\n\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\n{\n   int i,j,k=0;\n   unsigned int code;\n   // build size list for each symbol (from JPEG spec)\n   for (i=0; i < 16; ++i) {\n      for (j=0; j < count[i]; ++j) {\n         h->size[k++] = (stbi_uc) (i+1);\n         if(k >= 257) return stbi__err(\"bad size list\",\"Corrupt JPEG\");\n      }\n   }\n   h->size[k] = 0;\n\n   // compute actual symbols (from jpeg spec)\n   code = 0;\n   k = 0;\n   for(j=1; j <= 16; ++j) {\n      // compute delta to add to code to compute symbol id\n      h->delta[j] = k - code;\n      if (h->size[k] == j) {\n         while (h->size[k] == j)\n            h->code[k++] = (stbi__uint16) (code++);\n         if (code-1 >= (1u << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\n      }\n      // compute largest code + 1 for this size, preshifted as needed later\n      h->maxcode[j] = code << (16-j);\n      code <<= 1;\n   }\n   h->maxcode[j] = 0xffffffff;\n\n   // build non-spec acceleration table; 255 is flag for not-accelerated\n   memset(h->fast, 255, 1 << FAST_BITS);\n   for (i=0; i < k; ++i) {\n      int s = h->size[i];\n      if (s <= FAST_BITS) {\n         int c = h->code[i] << (FAST_BITS-s);\n         int m = 1 << (FAST_BITS-s);\n         for (j=0; j < m; ++j) {\n            h->fast[c+j] = (stbi_uc) i;\n         }\n      }\n   }\n   return 1;\n}\n\n// build a table that decodes both magnitude and value of small ACs in\n// one go.\nstatic void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)\n{\n   int i;\n   for (i=0; i < (1 << FAST_BITS); ++i) {\n      stbi_uc fast = h->fast[i];\n      fast_ac[i] = 0;\n      if (fast < 255) {\n         int rs = h->values[fast];\n         int run = (rs >> 4) & 15;\n         int magbits = rs & 15;\n         int len = h->size[fast];\n\n         if (magbits && len + magbits <= FAST_BITS) {\n            // magnitude code followed by receive_extend code\n            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\n            int m = 1 << (magbits - 1);\n            if (k < m) k += (~0U << magbits) + 1;\n            // if the result is small enough, we can fit it in fast_ac table\n            if (k >= -128 && k <= 127)\n               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));\n         }\n      }\n   }\n}\n\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\n{\n   do {\n      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);\n      if (b == 0xff) {\n         int c = stbi__get8(j->s);\n         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\n         if (c != 0) {\n            j->marker = (unsigned char) c;\n            j->nomore = 1;\n            return;\n         }\n      }\n      j->code_buffer |= b << (24 - j->code_bits);\n      j->code_bits += 8;\n   } while (j->code_bits <= 24);\n}\n\n// (1 << n) - 1\nstatic const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\n\n// decode a jpeg huffman value from the bitstream\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\n{\n   unsigned int temp;\n   int c,k;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   // look at the top FAST_BITS and determine what symbol ID it is,\n   // if the code is <= FAST_BITS\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n   k = h->fast[c];\n   if (k < 255) {\n      int s = h->size[k];\n      if (s > j->code_bits)\n         return -1;\n      j->code_buffer <<= s;\n      j->code_bits -= s;\n      return h->values[k];\n   }\n\n   // naive test is to shift the code_buffer down so k bits are\n   // valid, then test against maxcode. To speed this up, we've\n   // preshifted maxcode left so that it has (16-k) 0s at the\n   // end; in other words, regardless of the number of bits, it\n   // wants to be compared against something shifted to have 16;\n   // that way we don't need to shift inside the loop.\n   temp = j->code_buffer >> 16;\n   for (k=FAST_BITS+1 ; ; ++k)\n      if (temp < h->maxcode[k])\n         break;\n   if (k == 17) {\n      // error! code not found\n      j->code_bits -= 16;\n      return -1;\n   }\n\n   if (k > j->code_bits)\n      return -1;\n\n   // convert the huffman code to the symbol id\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\n   if(c < 0 || c >= 256) // symbol id out of bounds!\n       return -1;\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\n\n   // convert the id to a symbol\n   j->code_bits -= k;\n   j->code_buffer <<= k;\n   return h->values[c];\n}\n\n// bias[n] = (-1<<n) + 1\nstatic const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};\n\n// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   int sgn;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing\n\n   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k + (stbi__jbias[n] & (sgn - 1));\n}\n\n// get some unsigned bits\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k;\n}\n\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)\n{\n   unsigned int k;\n   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\n   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing\n   k = j->code_buffer;\n   j->code_buffer <<= 1;\n   --j->code_bits;\n   return k & 0x80000000;\n}\n\n// given a value that's at position X in the zigzag stream,\n// where does it appear in the 8x8 matrix coded as row-major?\nstatic const stbi_uc stbi__jpeg_dezigzag[64+15] =\n{\n    0,  1,  8, 16,  9,  2,  3, 10,\n   17, 24, 32, 25, 18, 11,  4,  5,\n   12, 19, 26, 33, 40, 48, 41, 34,\n   27, 20, 13,  6,  7, 14, 21, 28,\n   35, 42, 49, 56, 57, 50, 43, 36,\n   29, 22, 15, 23, 30, 37, 44, 51,\n   58, 59, 52, 45, 38, 31, 39, 46,\n   53, 60, 61, 54, 47, 55, 62, 63,\n   // let corrupt input sample past end\n   63, 63, 63, 63, 63, 63, 63, 63,\n   63, 63, 63, 63, 63, 63, 63\n};\n\n// decode one 64-entry block--\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\n{\n   int diff,dc,k;\n   int t;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n   t = stbi__jpeg_huff_decode(j, hdc);\n   if (t < 0 || t > 15) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? stbi__extend_receive(j, t) : 0;\n   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(\"bad delta\",\"Corrupt JPEG\");\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n   data[0] = (short) (dc * dequant[0]);\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      unsigned int zig;\n      int c,r,s;\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n      r = fac[c];\n      if (r) { // fast-AC path\n         k += (r >> 4) & 15; // run\n         s = r & 15; // combined length\n         if (s > j->code_bits) return stbi__err(\"bad huffman code\", \"Combined length longer than code bits available\");\n         j->code_buffer <<= s;\n         j->code_bits -= s;\n         // decode into unzigzag'd location\n         zig = stbi__jpeg_dezigzag[k++];\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\n      } else {\n         int rs = stbi__jpeg_huff_decode(j, hac);\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n         s = rs & 15;\n         r = rs >> 4;\n         if (s == 0) {\n            if (rs != 0xf0) break; // end block\n            k += 16;\n         } else {\n            k += r;\n            // decode into unzigzag'd location\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\n         }\n      }\n   } while (k < 64);\n   return 1;\n}\n\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)\n{\n   int diff,dc;\n   int t;\n   if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   if (j->succ_high == 0) {\n      // first scan for DC coefficient, must be first\n      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now\n      t = stbi__jpeg_huff_decode(j, hdc);\n      if (t < 0 || t > 15) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n      diff = t ? stbi__extend_receive(j, t) : 0;\n\n      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err(\"bad delta\", \"Corrupt JPEG\");\n      dc = j->img_comp[b].dc_pred + diff;\n      j->img_comp[b].dc_pred = dc;\n      if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n      data[0] = (short) (dc * (1 << j->succ_low));\n   } else {\n      // refinement scan for DC coefficient\n      if (stbi__jpeg_get_bit(j))\n         data[0] += (short) (1 << j->succ_low);\n   }\n   return 1;\n}\n\n// @OPTIMIZE: store non-zigzagged during the decode passes,\n// and only de-zigzag when dequantizing\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)\n{\n   int k;\n   if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->succ_high == 0) {\n      int shift = j->succ_low;\n\n      if (j->eob_run) {\n         --j->eob_run;\n         return 1;\n      }\n\n      k = j->spec_start;\n      do {\n         unsigned int zig;\n         int c,r,s;\n         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n         r = fac[c];\n         if (r) { // fast-AC path\n            k += (r >> 4) & 15; // run\n            s = r & 15; // combined length\n            if (s > j->code_bits) return stbi__err(\"bad huffman code\", \"Combined length longer than code bits available\");\n            j->code_buffer <<= s;\n            j->code_bits -= s;\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) ((r >> 8) * (1 << shift));\n         } else {\n            int rs = stbi__jpeg_huff_decode(j, hac);\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r);\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  --j->eob_run;\n                  break;\n               }\n               k += 16;\n            } else {\n               k += r;\n               zig = stbi__jpeg_dezigzag[k++];\n               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));\n            }\n         }\n      } while (k <= j->spec_end);\n   } else {\n      // refinement scan for these AC coefficients\n\n      short bit = (short) (1 << j->succ_low);\n\n      if (j->eob_run) {\n         --j->eob_run;\n         for (k = j->spec_start; k <= j->spec_end; ++k) {\n            short *p = &data[stbi__jpeg_dezigzag[k]];\n            if (*p != 0)\n               if (stbi__jpeg_get_bit(j))\n                  if ((*p & bit)==0) {\n                     if (*p > 0)\n                        *p += bit;\n                     else\n                        *p -= bit;\n                  }\n         }\n      } else {\n         k = j->spec_start;\n         do {\n            int r,s;\n            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r) - 1;\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  r = 64; // force end of block\n               } else {\n                  // r=15 s=0 should write 16 0s, so we just do\n                  // a run of 15 0s and then write s (which is 0),\n                  // so we don't have to do anything special here\n               }\n            } else {\n               if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\n               // sign bit\n               if (stbi__jpeg_get_bit(j))\n                  s = bit;\n               else\n                  s = -bit;\n            }\n\n            // advance by r\n            while (k <= j->spec_end) {\n               short *p = &data[stbi__jpeg_dezigzag[k++]];\n               if (*p != 0) {\n                  if (stbi__jpeg_get_bit(j))\n                     if ((*p & bit)==0) {\n                        if (*p > 0)\n                           *p += bit;\n                        else\n                           *p -= bit;\n                     }\n               } else {\n                  if (r == 0) {\n                     *p = (short) s;\n                     break;\n                  }\n                  --r;\n               }\n            }\n         } while (k <= j->spec_end);\n      }\n   }\n   return 1;\n}\n\n// take a -128..127 value and stbi__clamp it and convert to 0..255\nstbi_inline static stbi_uc stbi__clamp(int x)\n{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (stbi_uc) x;\n}\n\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\n#define stbi__fsh(x)  ((x) * 4096)\n\n// derived from jidctint -- DCT_ISLOW\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\n   p2 = s2;                                    \\\n   p3 = s6;                                    \\\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\n   p2 = s0;                                    \\\n   p3 = s4;                                    \\\n   t0 = stbi__fsh(p2+p3);                      \\\n   t1 = stbi__fsh(p2-p3);                      \\\n   x0 = t0+t3;                                 \\\n   x3 = t0-t3;                                 \\\n   x1 = t1+t2;                                 \\\n   x2 = t1-t2;                                 \\\n   t0 = s7;                                    \\\n   t1 = s5;                                    \\\n   t2 = s3;                                    \\\n   t3 = s1;                                    \\\n   p3 = t0+t2;                                 \\\n   p4 = t1+t3;                                 \\\n   p1 = t0+t3;                                 \\\n   p2 = t1+t2;                                 \\\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\n   t3 += p1+p4;                                \\\n   t2 += p2+p3;                                \\\n   t1 += p2+p4;                                \\\n   t0 += p1+p3;\n\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])\n{\n   int i,val[64],*v=val;\n   stbi_uc *o;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0]*4;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      // so we want to round that, which means adding 0.5 * 1<<17,\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\n      x0 += 65536 + (128<<17);\n      x1 += 65536 + (128<<17);\n      x2 += 65536 + (128<<17);\n      x3 += 65536 + (128<<17);\n      // tried computing the shifts into temps, or'ing the temps to see\n      // if any were out of range, but that was slower\n      o[0] = stbi__clamp((x0+t3) >> 17);\n      o[7] = stbi__clamp((x0-t3) >> 17);\n      o[1] = stbi__clamp((x1+t2) >> 17);\n      o[6] = stbi__clamp((x1-t2) >> 17);\n      o[2] = stbi__clamp((x2+t1) >> 17);\n      o[5] = stbi__clamp((x2-t1) >> 17);\n      o[3] = stbi__clamp((x3+t0) >> 17);\n      o[4] = stbi__clamp((x3-t0) >> 17);\n   }\n}\n\n#ifdef STBI_SSE2\n// sse2 integer IDCT. not the fastest possible implementation but it\n// produces bit-identical results to the generic C version so it's\n// fully \"transparent\".\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   // This is constructed to match our regular (generic) integer IDCT exactly.\n   __m128i row0, row1, row2, row3, row4, row5, row6, row7;\n   __m128i tmp;\n\n   // dot product constant: even elems=x, odd elems=y\n   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\n\n   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\n   // out(1) = c1[even]*x + c1[odd]*y\n   #define dct_rot(out0,out1, x,y,c0,c1) \\\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\n\n   // out = in << 12  (in 16-bit, out 32-bit)\n   #define dct_widen(out, in) \\\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\n\n   // wide add\n   #define dct_wadd(out, a, b) \\\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\n\n   // wide sub\n   #define dct_wsub(out, a, b) \\\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\n\n   // butterfly a/b, add bias, then shift by \"s\" and pack\n   #define dct_bfly32o(out0, out1, a,b,bias,s) \\\n      { \\\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\n         dct_wadd(sum, abiased, b); \\\n         dct_wsub(dif, abiased, b); \\\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\n      }\n\n   // 8-bit interleave step (for transposes)\n   #define dct_interleave8(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi8(a, b); \\\n      b = _mm_unpackhi_epi8(tmp, b)\n\n   // 16-bit interleave step (for transposes)\n   #define dct_interleave16(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi16(a, b); \\\n      b = _mm_unpackhi_epi16(tmp, b)\n\n   #define dct_pass(bias,shift) \\\n      { \\\n         /* even part */ \\\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\n         dct_widen(t0e, sum04); \\\n         dct_widen(t1e, dif04); \\\n         dct_wadd(x0, t0e, t3e); \\\n         dct_wsub(x3, t0e, t3e); \\\n         dct_wadd(x1, t1e, t2e); \\\n         dct_wsub(x2, t1e, t2e); \\\n         /* odd part */ \\\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\n         dct_wadd(x4, y0o, y4o); \\\n         dct_wadd(x5, y1o, y5o); \\\n         dct_wadd(x6, y2o, y5o); \\\n         dct_wadd(x7, y3o, y4o); \\\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\n      }\n\n   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\n   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));\n   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\n   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\n   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));\n   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));\n   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));\n   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));\n\n   // rounding biases in column/row passes, see stbi__idct_block for explanation.\n   __m128i bias_0 = _mm_set1_epi32(512);\n   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));\n\n   // load\n   row0 = _mm_load_si128((const __m128i *) (data + 0*8));\n   row1 = _mm_load_si128((const __m128i *) (data + 1*8));\n   row2 = _mm_load_si128((const __m128i *) (data + 2*8));\n   row3 = _mm_load_si128((const __m128i *) (data + 3*8));\n   row4 = _mm_load_si128((const __m128i *) (data + 4*8));\n   row5 = _mm_load_si128((const __m128i *) (data + 5*8));\n   row6 = _mm_load_si128((const __m128i *) (data + 6*8));\n   row7 = _mm_load_si128((const __m128i *) (data + 7*8));\n\n   // column pass\n   dct_pass(bias_0, 10);\n\n   {\n      // 16bit 8x8 transpose pass 1\n      dct_interleave16(row0, row4);\n      dct_interleave16(row1, row5);\n      dct_interleave16(row2, row6);\n      dct_interleave16(row3, row7);\n\n      // transpose pass 2\n      dct_interleave16(row0, row2);\n      dct_interleave16(row1, row3);\n      dct_interleave16(row4, row6);\n      dct_interleave16(row5, row7);\n\n      // transpose pass 3\n      dct_interleave16(row0, row1);\n      dct_interleave16(row2, row3);\n      dct_interleave16(row4, row5);\n      dct_interleave16(row6, row7);\n   }\n\n   // row pass\n   dct_pass(bias_1, 17);\n\n   {\n      // pack\n      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\n      __m128i p1 = _mm_packus_epi16(row2, row3);\n      __m128i p2 = _mm_packus_epi16(row4, row5);\n      __m128i p3 = _mm_packus_epi16(row6, row7);\n\n      // 8bit 8x8 transpose pass 1\n      dct_interleave8(p0, p2); // a0e0a1e1...\n      dct_interleave8(p1, p3); // c0g0c1g1...\n\n      // transpose pass 2\n      dct_interleave8(p0, p1); // a0c0e0g0...\n      dct_interleave8(p2, p3); // b0d0f0h0...\n\n      // transpose pass 3\n      dct_interleave8(p0, p2); // a0b0c0d0...\n      dct_interleave8(p1, p3); // a4b4c4d4...\n\n      // store\n      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));\n   }\n\n#undef dct_const\n#undef dct_rot\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_interleave8\n#undef dct_interleave16\n#undef dct_pass\n}\n\n#endif // STBI_SSE2\n\n#ifdef STBI_NEON\n\n// NEON integer IDCT. should produce bit-identical\n// results to the generic C version.\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\n\n   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\n   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\n   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));\n   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));\n   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\n   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\n   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\n   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\n   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));\n   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));\n   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));\n   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));\n\n#define dct_long_mul(out, inq, coeff) \\\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\n\n#define dct_long_mac(out, acc, inq, coeff) \\\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\n\n#define dct_widen(out, inq) \\\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\n\n// wide add\n#define dct_wadd(out, a, b) \\\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\n\n// wide sub\n#define dct_wsub(out, a, b) \\\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\n\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\n   { \\\n      dct_wadd(sum, a, b); \\\n      dct_wsub(dif, a, b); \\\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\n   }\n\n#define dct_pass(shiftop, shift) \\\n   { \\\n      /* even part */ \\\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\n      dct_long_mul(p1e, sum26, rot0_0); \\\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\n      dct_widen(t0e, sum04); \\\n      dct_widen(t1e, dif04); \\\n      dct_wadd(x0, t0e, t3e); \\\n      dct_wsub(x3, t0e, t3e); \\\n      dct_wadd(x1, t1e, t2e); \\\n      dct_wsub(x2, t1e, t2e); \\\n      /* odd part */ \\\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\n      dct_long_mul(p5o, sumodd, rot1_0); \\\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\n      dct_long_mul(p3o, sum37, rot2_0); \\\n      dct_long_mul(p4o, sum15, rot2_1); \\\n      dct_wadd(sump13o, p1o, p3o); \\\n      dct_wadd(sump24o, p2o, p4o); \\\n      dct_wadd(sump23o, p2o, p3o); \\\n      dct_wadd(sump14o, p1o, p4o); \\\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\n   }\n\n   // load\n   row0 = vld1q_s16(data + 0*8);\n   row1 = vld1q_s16(data + 1*8);\n   row2 = vld1q_s16(data + 2*8);\n   row3 = vld1q_s16(data + 3*8);\n   row4 = vld1q_s16(data + 4*8);\n   row5 = vld1q_s16(data + 5*8);\n   row6 = vld1q_s16(data + 6*8);\n   row7 = vld1q_s16(data + 7*8);\n\n   // add DC bias\n   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\n\n   // column pass\n   dct_pass(vrshrn_n_s32, 10);\n\n   // 16bit 8x8 transpose\n   {\n// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\n// whether compilers actually get this is another story, sadly.\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\n\n      // pass 1\n      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\n      dct_trn16(row2, row3);\n      dct_trn16(row4, row5);\n      dct_trn16(row6, row7);\n\n      // pass 2\n      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\n      dct_trn32(row1, row3);\n      dct_trn32(row4, row6);\n      dct_trn32(row5, row7);\n\n      // pass 3\n      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\n      dct_trn64(row1, row5);\n      dct_trn64(row2, row6);\n      dct_trn64(row3, row7);\n\n#undef dct_trn16\n#undef dct_trn32\n#undef dct_trn64\n   }\n\n   // row pass\n   // vrshrn_n_s32 only supports shifts up to 16, we need\n   // 17. so do a non-rounding shift of 16 first then follow\n   // up with a rounding shift by 1.\n   dct_pass(vshrn_n_s32, 16);\n\n   {\n      // pack and round\n      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\n      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\n      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\n      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\n      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\n      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\n      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\n      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\n\n      // again, these can translate into one instruction, but often don't.\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\n\n      // sadly can't use interleaved stores here since we only write\n      // 8 bytes to each scan line!\n\n      // 8x8 8-bit transpose pass 1\n      dct_trn8_8(p0, p1);\n      dct_trn8_8(p2, p3);\n      dct_trn8_8(p4, p5);\n      dct_trn8_8(p6, p7);\n\n      // pass 2\n      dct_trn8_16(p0, p2);\n      dct_trn8_16(p1, p3);\n      dct_trn8_16(p4, p6);\n      dct_trn8_16(p5, p7);\n\n      // pass 3\n      dct_trn8_32(p0, p4);\n      dct_trn8_32(p1, p5);\n      dct_trn8_32(p2, p6);\n      dct_trn8_32(p3, p7);\n\n      // store\n      vst1_u8(out, p0); out += out_stride;\n      vst1_u8(out, p1); out += out_stride;\n      vst1_u8(out, p2); out += out_stride;\n      vst1_u8(out, p3); out += out_stride;\n      vst1_u8(out, p4); out += out_stride;\n      vst1_u8(out, p5); out += out_stride;\n      vst1_u8(out, p6); out += out_stride;\n      vst1_u8(out, p7);\n\n#undef dct_trn8_8\n#undef dct_trn8_16\n#undef dct_trn8_32\n   }\n\n#undef dct_long_mul\n#undef dct_long_mac\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_pass\n}\n\n#endif // STBI_NEON\n\n#define STBI__MARKER_none  0xff\n// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\n{\n   stbi_uc x;\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\n   x = stbi__get8(j->s);\n   if (x != 0xff) return STBI__MARKER_none;\n   while (x == 0xff)\n      x = stbi__get8(j->s); // consume repeated 0xff fill bytes\n   return x;\n}\n\n// in each scan, we'll have scan_n components, and the order\n// of the components is specified by order[]\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\n\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\n// the dc prediction\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\n{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\n   j->marker = STBI__MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   j->eob_run = 0;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}\n\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\n{\n   stbi__jpeg_reset(z);\n   if (!z->progressive) {\n      if (z->scan_n == 1) {\n         int i,j;\n         STBI_SIMD_ALIGN(short, data[64]);\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               int ha = z->img_comp[n].ha;\n               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  // if it's NOT a restart, then just bail, so we get corrupt data\n                  // rather than no data\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         STBI_SIMD_ALIGN(short, data[64]);\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x)*8;\n                        int y2 = (j*z->img_comp[n].v + y)*8;\n                        int ha = z->img_comp[n].ha;\n                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   } else {\n      if (z->scan_n == 1) {\n         int i,j;\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               if (z->spec_start == 0) {\n                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                     return 0;\n               } else {\n                  int ha = z->img_comp[n].ha;\n                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\n                     return 0;\n               }\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x);\n                        int y2 = (j*z->img_comp[n].v + y);\n                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                           return 0;\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->todo <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   }\n}\n\nstatic void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)\n{\n   int i;\n   for (i=0; i < 64; ++i)\n      data[i] *= dequant[i];\n}\n\nstatic void stbi__jpeg_finish(stbi__jpeg *z)\n{\n   if (z->progressive) {\n      // dequantize and idct the data\n      int i,j,n;\n      for (n=0; n < z->s->img_n; ++n) {\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n            }\n         }\n      }\n   }\n}\n\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\n{\n   int L;\n   switch (m) {\n      case STBI__MARKER_none: // no marker found\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\n\n      case 0xDD: // DRI - specify restart interval\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\n         z->restart_interval = stbi__get16be(z->s);\n         return 1;\n\n      case 0xDB: // DQT - define quantization table\n         L = stbi__get16be(z->s)-2;\n         while (L > 0) {\n            int q = stbi__get8(z->s);\n            int p = q >> 4, sixteen = (p != 0);\n            int t = q & 15,i;\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\n\n            for (i=0; i < 64; ++i)\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\n            L -= (sixteen ? 129 : 65);\n         }\n         return L==0;\n\n      case 0xC4: // DHT - define huffman table\n         L = stbi__get16be(z->s)-2;\n         while (L > 0) {\n            stbi_uc *v;\n            int sizes[16],i,n=0;\n            int q = stbi__get8(z->s);\n            int tc = q >> 4;\n            int th = q & 15;\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\n            for (i=0; i < 16; ++i) {\n               sizes[i] = stbi__get8(z->s);\n               n += sizes[i];\n            }\n            if(n > 256) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\"); // Loop over i < n would write past end of values!\n            L -= 17;\n            if (tc == 0) {\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\n               v = z->huff_dc[th].values;\n            } else {\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\n               v = z->huff_ac[th].values;\n            }\n            for (i=0; i < n; ++i)\n               v[i] = stbi__get8(z->s);\n            if (tc != 0)\n               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\n            L -= n;\n         }\n         return L==0;\n   }\n\n   // check for comment block or APP blocks\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\n      L = stbi__get16be(z->s);\n      if (L < 2) {\n         if (m == 0xFE)\n            return stbi__err(\"bad COM len\",\"Corrupt JPEG\");\n         else\n            return stbi__err(\"bad APP len\",\"Corrupt JPEG\");\n      }\n      L -= 2;\n\n      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment\n         static const unsigned char tag[5] = {'J','F','I','F','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 5; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         L -= 5;\n         if (ok)\n            z->jfif = 1;\n      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment\n         static const unsigned char tag[6] = {'A','d','o','b','e','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 6; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         L -= 6;\n         if (ok) {\n            stbi__get8(z->s); // version\n            stbi__get16be(z->s); // flags0\n            stbi__get16be(z->s); // flags1\n            z->app14_color_transform = stbi__get8(z->s); // color transform\n            L -= 6;\n         }\n      }\n\n      stbi__skip(z->s, L);\n      return 1;\n   }\n\n   return stbi__err(\"unknown marker\",\"Corrupt JPEG\");\n}\n\n// after we see SOS\nstatic int stbi__process_scan_header(stbi__jpeg *z)\n{\n   int i;\n   int Ls = stbi__get16be(z->s);\n   z->scan_n = stbi__get8(z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = stbi__get8(z->s), which;\n      int q = stbi__get8(z->s);\n      for (which = 0; which < z->s->img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s->img_n) return 0; // no match\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n\n   {\n      int aa;\n      z->spec_start = stbi__get8(z->s);\n      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0\n      aa = stbi__get8(z->s);\n      z->succ_high = (aa >> 4);\n      z->succ_low  = (aa & 15);\n      if (z->progressive) {\n         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\n            return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\n      } else {\n         if (z->spec_start != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         z->spec_end = 63;\n      }\n   }\n\n   return 1;\n}\n\nstatic int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)\n{\n   int i;\n   for (i=0; i < ncomp; ++i) {\n      if (z->img_comp[i].raw_data) {\n         STBI_FREE(z->img_comp[i].raw_data);\n         z->img_comp[i].raw_data = NULL;\n         z->img_comp[i].data = NULL;\n      }\n      if (z->img_comp[i].raw_coeff) {\n         STBI_FREE(z->img_comp[i].raw_coeff);\n         z->img_comp[i].raw_coeff = 0;\n         z->img_comp[i].coeff = 0;\n      }\n      if (z->img_comp[i].linebuf) {\n         STBI_FREE(z->img_comp[i].linebuf);\n         z->img_comp[i].linebuf = NULL;\n      }\n   }\n   return why;\n}\n\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\n{\n   stbi__context *s = z->s;\n   int Lf,p,i,q, h_max=1,v_max=1,c;\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   c = stbi__get8(s);\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\n   s->img_n = c;\n   for (i=0; i < c; ++i) {\n      z->img_comp[i].data = NULL;\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\n\n   z->rgb = 0;\n   for (i=0; i < s->img_n; ++i) {\n      static const unsigned char rgb[3] = { 'R', 'G', 'B' };\n      z->img_comp[i].id = stbi__get8(s);\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\n         ++z->rgb;\n      q = stbi__get8(s);\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\n   }\n\n   if (scan != STBI__SCAN_load) return 1;\n\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\n\n   for (i=0; i < s->img_n; ++i) {\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\n   }\n\n   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios\n   // and I've never seen a non-corrupted JPEG file actually use them\n   for (i=0; i < s->img_n; ++i) {\n      if (h_max % z->img_comp[i].h != 0) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      if (v_max % z->img_comp[i].v != 0) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n   }\n\n   // compute interleaved mcu info\n   z->img_h_max = h_max;\n   z->img_v_max = v_max;\n   z->img_mcu_w = h_max * 8;\n   z->img_mcu_h = v_max * 8;\n   // these sizes can't be more than 17 bits\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\n\n   for (i=0; i < s->img_n; ++i) {\n      // number of effective pixels (e.g. for non-interleaved MCU)\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\n      // to simplify generation, we'll allocate enough memory to decode\n      // the bogus oversized data from using interleaved MCUs and their\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\n      // discard the extra data until colorspace conversion\n      //\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\n      // so these muls can't overflow with 32-bit ints (which we require)\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\n      z->img_comp[i].coeff = 0;\n      z->img_comp[i].raw_coeff = 0;\n      z->img_comp[i].linebuf = NULL;\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\n      if (z->img_comp[i].raw_data == NULL)\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n      // align blocks for idct using mmx/sse\n      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);\n      if (z->progressive) {\n         // w2, h2 are multiples of 8 (see above)\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\n         if (z->img_comp[i].raw_coeff == NULL)\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);\n      }\n   }\n\n   return 1;\n}\n\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\n#define stbi__DNL(x)         ((x) == 0xdc)\n#define stbi__SOI(x)         ((x) == 0xd8)\n#define stbi__EOI(x)         ((x) == 0xd9)\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\n#define stbi__SOS(x)         ((x) == 0xda)\n\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\n\nstatic int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)\n{\n   int m;\n   z->jfif = 0;\n   z->app14_color_transform = -1; // valid values are 0,1,2\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\n   m = stbi__get_marker(z);\n   if (!stbi__SOI(m)) return stbi__err(\"no SOI\",\"Corrupt JPEG\");\n   if (scan == STBI__SCAN_type) return 1;\n   m = stbi__get_marker(z);\n   while (!stbi__SOF(m)) {\n      if (!stbi__process_marker(z,m)) return 0;\n      m = stbi__get_marker(z);\n      while (m == STBI__MARKER_none) {\n         // some files have extra padding after their blocks, so ok, we'll scan\n         if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\n         m = stbi__get_marker(z);\n      }\n   }\n   z->progressive = stbi__SOF_progressive(m);\n   if (!stbi__process_frame_header(z, scan)) return 0;\n   return 1;\n}\n\nstatic stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)\n{\n   // some JPEGs have junk at end, skip over it but if we find what looks\n   // like a valid marker, resume there\n   while (!stbi__at_eof(j->s)) {\n      stbi_uc x = stbi__get8(j->s);\n      while (x == 0xff) { // might be a marker\n         if (stbi__at_eof(j->s)) return STBI__MARKER_none;\n         x = stbi__get8(j->s);\n         if (x != 0x00 && x != 0xff) {\n            // not a stuffed zero or lead-in to another marker, looks\n            // like an actual marker, return it\n            return x;\n         }\n         // stuffed zero has x=0 now which ends the loop, meaning we go\n         // back to regular scan loop.\n         // repeated 0xff keeps trying to read the next byte of the marker.\n      }\n   }\n   return STBI__MARKER_none;\n}\n\n// decode image to YCbCr format\nstatic int stbi__decode_jpeg_image(stbi__jpeg *j)\n{\n   int m;\n   for (m = 0; m < 4; m++) {\n      j->img_comp[m].raw_data = NULL;\n      j->img_comp[m].raw_coeff = NULL;\n   }\n   j->restart_interval = 0;\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\n   m = stbi__get_marker(j);\n   while (!stbi__EOI(m)) {\n      if (stbi__SOS(m)) {\n         if (!stbi__process_scan_header(j)) return 0;\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\n         if (j->marker == STBI__MARKER_none ) {\n         j->marker = stbi__skip_jpeg_junk_at_end(j);\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\n         }\n         m = stbi__get_marker(j);\n         if (STBI__RESTART(m))\n            m = stbi__get_marker(j);\n      } else if (stbi__DNL(m)) {\n         int Ld = stbi__get16be(j->s);\n         stbi__uint32 NL = stbi__get16be(j->s);\n         if (Ld != 4) return stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\n         if (NL != j->s->img_y) return stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\n         m = stbi__get_marker(j);\n      } else {\n         if (!stbi__process_marker(j, m)) return 1;\n         m = stbi__get_marker(j);\n      }\n   }\n   if (j->progressive)\n      stbi__jpeg_finish(j);\n   return 1;\n}\n\n// static jfif-centered resampling (across block boundaries)\n\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\n                                    int w, int hs);\n\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\n\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   STBI_NOTUSED(out);\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(w);\n   STBI_NOTUSED(hs);\n   return in_near;\n}\n\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples vertically for every one in input\n   int i;\n   STBI_NOTUSED(hs);\n   for (i=0; i < w; ++i)\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\n   return out;\n}\n\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples horizontally for every one in input\n   int i;\n   stbi_uc *input = in_near;\n\n   if (w == 1) {\n      // if only one sample, can't do any interpolation\n      out[0] = out[1] = input[0];\n      return out;\n   }\n\n   out[0] = input[0];\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\n   for (i=1; i < w-1; ++i) {\n      int n = 3*input[i]+2;\n      out[i*2+0] = stbi__div4(n+input[i-1]);\n      out[i*2+1] = stbi__div4(n+input[i+1]);\n   }\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\n   out[i*2+1] = input[w-1];\n\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\n\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i,t0,t1;\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   out[0] = stbi__div4(t1+2);\n   for (i=1; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i=0,t0,t1;\n\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   // process groups of 8 pixels for as long as we can.\n   // note we can't handle the last pixel in a row in this loop\n   // because we need to handle the filter boundary conditions.\n   for (; i < ((w-1) & ~7); i += 8) {\n#if defined(STBI_SSE2)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      __m128i zero  = _mm_setzero_si128();\n      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));\n      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));\n      __m128i farw  = _mm_unpacklo_epi8(farb, zero);\n      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\n      __m128i diff  = _mm_sub_epi16(farw, nearw);\n      __m128i nears = _mm_slli_epi16(nearw, 2);\n      __m128i curr  = _mm_add_epi16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      __m128i prv0 = _mm_slli_si128(curr, 2);\n      __m128i nxt0 = _mm_srli_si128(curr, 2);\n      __m128i prev = _mm_insert_epi16(prv0, t1, 0);\n      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      __m128i bias  = _mm_set1_epi16(8);\n      __m128i curs = _mm_slli_epi16(curr, 2);\n      __m128i prvd = _mm_sub_epi16(prev, curr);\n      __m128i nxtd = _mm_sub_epi16(next, curr);\n      __m128i curb = _mm_add_epi16(curs, bias);\n      __m128i even = _mm_add_epi16(prvd, curb);\n      __m128i odd  = _mm_add_epi16(nxtd, curb);\n\n      // interleave even and odd pixels, then undo scaling.\n      __m128i int0 = _mm_unpacklo_epi16(even, odd);\n      __m128i int1 = _mm_unpackhi_epi16(even, odd);\n      __m128i de0  = _mm_srli_epi16(int0, 4);\n      __m128i de1  = _mm_srli_epi16(int1, 4);\n\n      // pack and write output\n      __m128i outv = _mm_packus_epi16(de0, de1);\n      _mm_storeu_si128((__m128i *) (out + i*2), outv);\n#elif defined(STBI_NEON)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      uint8x8_t farb  = vld1_u8(in_far + i);\n      uint8x8_t nearb = vld1_u8(in_near + i);\n      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\n      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\n      int16x8_t curr  = vaddq_s16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      int16x8_t prv0 = vextq_s16(curr, curr, 7);\n      int16x8_t nxt0 = vextq_s16(curr, curr, 1);\n      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\n      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      int16x8_t curs = vshlq_n_s16(curr, 2);\n      int16x8_t prvd = vsubq_s16(prev, curr);\n      int16x8_t nxtd = vsubq_s16(next, curr);\n      int16x8_t even = vaddq_s16(curs, prvd);\n      int16x8_t odd  = vaddq_s16(curs, nxtd);\n\n      // undo scaling and round, then store with even/odd phases interleaved\n      uint8x8x2_t o;\n      o.val[0] = vqrshrun_n_s16(even, 4);\n      o.val[1] = vqrshrun_n_s16(odd,  4);\n      vst2_u8(out + i*2, o);\n#endif\n\n      // \"previous\" value for next iter\n      t1 = 3*in_near[i+7] + in_far[i+7];\n   }\n\n   t0 = t1;\n   t1 = 3*in_near[i] + in_far[i];\n   out[i*2] = stbi__div16(3*t1 + t0 + 8);\n\n   for (++i; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n#endif\n\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // resample with nearest-neighbor\n   int i,j;\n   STBI_NOTUSED(in_far);\n   for (i=0; i < w; ++i)\n      for (j=0; j < hs; ++j)\n         out[i*hs+j] = in_near[i];\n   return out;\n}\n\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\n// to make sure the code produces the same results in both SIMD and scalar\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\n{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed +  cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)\n{\n   int i = 0;\n\n#ifdef STBI_SSE2\n   // step == 3 is pretty ugly on the final interleave, and i'm not convinced\n   // it's useful in practice (you wouldn't use it for textures, for example).\n   // so just accelerate step == 4 case.\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      __m128i signflip  = _mm_set1_epi8(-0x80);\n      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));\n      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));\n      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));\n      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));\n      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);\n      __m128i xw = _mm_set1_epi16(255); // alpha channel\n\n      for (; i+7 < count; i += 8) {\n         // load\n         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));\n         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));\n         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));\n         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\n         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\n\n         // unpack to short (and left-shift cr, cb by 8)\n         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);\n         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\n         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\n\n         // color transform\n         __m128i yws = _mm_srli_epi16(yw, 4);\n         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\n         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\n         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\n         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\n         __m128i rws = _mm_add_epi16(cr0, yws);\n         __m128i gwt = _mm_add_epi16(cb0, yws);\n         __m128i bws = _mm_add_epi16(yws, cb1);\n         __m128i gws = _mm_add_epi16(gwt, cr1);\n\n         // descale\n         __m128i rw = _mm_srai_epi16(rws, 4);\n         __m128i bw = _mm_srai_epi16(bws, 4);\n         __m128i gw = _mm_srai_epi16(gws, 4);\n\n         // back to byte, set up for transpose\n         __m128i brb = _mm_packus_epi16(rw, bw);\n         __m128i gxb = _mm_packus_epi16(gw, xw);\n\n         // transpose to interleave channels\n         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\n         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\n         __m128i o0 = _mm_unpacklo_epi16(t0, t1);\n         __m128i o1 = _mm_unpackhi_epi16(t0, t1);\n\n         // store\n         _mm_storeu_si128((__m128i *) (out + 0), o0);\n         _mm_storeu_si128((__m128i *) (out + 16), o1);\n         out += 32;\n      }\n   }\n#endif\n\n#ifdef STBI_NEON\n   // in this version, step=3 support would be easy to add. but is there demand?\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      uint8x8_t signflip = vdup_n_u8(0x80);\n      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));\n      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));\n      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));\n      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));\n\n      for (; i+7 < count; i += 8) {\n         // load\n         uint8x8_t y_bytes  = vld1_u8(y + i);\n         uint8x8_t cr_bytes = vld1_u8(pcr + i);\n         uint8x8_t cb_bytes = vld1_u8(pcb + i);\n         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\n         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\n\n         // expand to s16\n         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\n         int16x8_t crw = vshll_n_s8(cr_biased, 7);\n         int16x8_t cbw = vshll_n_s8(cb_biased, 7);\n\n         // color transform\n         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\n         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\n         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\n         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\n         int16x8_t rws = vaddq_s16(yws, cr0);\n         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\n         int16x8_t bws = vaddq_s16(yws, cb1);\n\n         // undo scaling, round, convert to byte\n         uint8x8x4_t o;\n         o.val[0] = vqrshrun_n_s16(rws, 4);\n         o.val[1] = vqrshrun_n_s16(gws, 4);\n         o.val[2] = vqrshrun_n_s16(bws, 4);\n         o.val[3] = vdup_n_u8(255);\n\n         // store, interleaving r/g/b/a\n         vst4_u8(out, o);\n         out += 8*4;\n      }\n   }\n#endif\n\n   for (; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n#endif\n\n// set up the kernels\nstatic void stbi__setup_jpeg(stbi__jpeg *j)\n{\n   j->idct_block_kernel = stbi__idct_block;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\n\n#ifdef STBI_SSE2\n   if (stbi__sse2_available()) {\n      j->idct_block_kernel = stbi__idct_simd;\n      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n   }\n#endif\n\n#ifdef STBI_NEON\n   j->idct_block_kernel = stbi__idct_simd;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n#endif\n}\n\n// clean up the temporary component buffers\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\n{\n   stbi__free_jpeg_components(j, j->s->img_n, 0);\n}\n\ntypedef struct\n{\n   resample_row_func resample;\n   stbi_uc *line0,*line1;\n   int hs,vs;   // expansion factor in each axis\n   int w_lores; // horizontal pixels pre-expansion\n   int ystep;   // how far through vertical expansion we are\n   int ypos;    // which pre-expansion row we're on\n} stbi__resample;\n\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\n{\n   unsigned int t = x*y + 128;\n   return (stbi_uc) ((t + (t >>8)) >> 8);\n}\n\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\n{\n   int n, decode_n, is_rgb;\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\n\n   // validate req_comp\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n\n   // load a jpeg image from whichever source, but leave in YCbCr format\n   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // determine actual number of components to generate\n   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\n\n   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\n\n   if (z->s->img_n == 3 && n < 3 && !is_rgb)\n      decode_n = 1;\n   else\n      decode_n = z->s->img_n;\n\n   // nothing to do if no components requested; check this now to avoid\n   // accessing uninitialized coutput[0] later\n   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // resample and color-convert\n   {\n      int k;\n      unsigned int i,j;\n      stbi_uc *output;\n      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };\n\n      stbi__resample res_comp[4];\n\n      for (k=0; k < decode_n; ++k) {\n         stbi__resample *r = &res_comp[k];\n\n         // allocate line buffer big enough for upsampling off the edges\n         // with upsample factor of 4\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n         r->hs      = z->img_h_max / z->img_comp[k].h;\n         r->vs      = z->img_v_max / z->img_comp[k].v;\n         r->ystep   = r->vs >> 1;\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\n         r->ypos    = 0;\n         r->line0   = r->line1 = z->img_comp[k].data;\n\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\n         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\n         else                               r->resample = stbi__resample_row_generic;\n      }\n\n      // can't error after this so, this is safe\n      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n      // now go ahead and resample\n      for (j=0; j < z->s->img_y; ++j) {\n         stbi_uc *out = output + n * z->s->img_x * j;\n         for (k=0; k < decode_n; ++k) {\n            stbi__resample *r = &res_comp[k];\n            int y_bot = r->ystep >= (r->vs >> 1);\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\n                                     y_bot ? r->line1 : r->line0,\n                                     y_bot ? r->line0 : r->line1,\n                                     r->w_lores, r->hs);\n            if (++r->ystep >= r->vs) {\n               r->ystep = 0;\n               r->line0 = r->line1;\n               if (++r->ypos < z->img_comp[k].y)\n                  r->line1 += z->img_comp[k].w2;\n            }\n         }\n         if (n >= 3) {\n            stbi_uc *y = coutput[0];\n            if (z->s->img_n == 3) {\n               if (is_rgb) {\n                  for (i=0; i < z->s->img_x; ++i) {\n                     out[0] = y[i];\n                     out[1] = coutput[1][i];\n                     out[2] = coutput[2][i];\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else {\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else if (z->s->img_n == 4) {\n               if (z->app14_color_transform == 0) { // CMYK\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(coutput[0][i], m);\n                     out[1] = stbi__blinn_8x8(coutput[1][i], m);\n                     out[2] = stbi__blinn_8x8(coutput[2][i], m);\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else if (z->app14_color_transform == 2) { // YCCK\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(255 - out[0], m);\n                     out[1] = stbi__blinn_8x8(255 - out[1], m);\n                     out[2] = stbi__blinn_8x8(255 - out[2], m);\n                     out += n;\n                  }\n               } else { // YCbCr + alpha?  Ignore the fourth channel for now\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = out[1] = out[2] = y[i];\n                  out[3] = 255; // not used if n==3\n                  out += n;\n               }\n         } else {\n            if (is_rgb) {\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i)\n                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n               else {\n                  for (i=0; i < z->s->img_x; ++i, out += 2) {\n                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n                     out[1] = 255;\n                  }\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  stbi_uc m = coutput[3][i];\n                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\n                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\n                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\n                  out[0] = stbi__compute_y(r, g, b);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else {\n               stbi_uc *y = coutput[0];\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\n               else\n                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }\n            }\n         }\n      }\n      stbi__cleanup_jpeg(z);\n      *out_x = z->s->img_x;\n      *out_y = z->s->img_y;\n      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\n      return output;\n   }\n}\n\nstatic void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   unsigned char* result;\n   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   memset(j, 0, sizeof(stbi__jpeg));\n   STBI_NOTUSED(ri);\n   j->s = s;\n   stbi__setup_jpeg(j);\n   result = load_jpeg_image(j, x,y,comp,req_comp);\n   STBI_FREE(j);\n   return result;\n}\n\nstatic int stbi__jpeg_test(stbi__context *s)\n{\n   int r;\n   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   memset(j, 0, sizeof(stbi__jpeg));\n   j->s = s;\n   stbi__setup_jpeg(j);\n   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\n   stbi__rewind(s);\n   STBI_FREE(j);\n   return r;\n}\n\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\n{\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\n      stbi__rewind( j->s );\n      return 0;\n   }\n   if (x) *x = j->s->img_x;\n   if (y) *y = j->s->img_y;\n   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\n   return 1;\n}\n\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int result;\n   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   memset(j, 0, sizeof(stbi__jpeg));\n   j->s = s;\n   result = stbi__jpeg_info_raw(j, x, y, comp);\n   STBI_FREE(j);\n   return result;\n}\n#endif\n\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\n//    simple implementation\n//      - all input must be provided in an upfront buffer\n//      - all output is written to a single output buffer (can malloc/realloc)\n//    performance\n//      - fast huffman\n\n#ifndef STBI_NO_ZLIB\n\n// fast-way is faster to check than jpeg huffman, but slow way is slower\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\n#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet\n\n// zlib-style huffman encoding\n// (jpegs packs from left, zlib from right, so can't share code)\ntypedef struct\n{\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\n   stbi__uint16 firstcode[16];\n   int maxcode[17];\n   stbi__uint16 firstsymbol[16];\n   stbi_uc  size[STBI__ZNSYMS];\n   stbi__uint16 value[STBI__ZNSYMS];\n} stbi__zhuffman;\n\nstbi_inline static int stbi__bitreverse16(int n)\n{\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\n  return n;\n}\n\nstbi_inline static int stbi__bit_reverse(int v, int bits)\n{\n   STBI_ASSERT(bits <= 16);\n   // to bit reverse n bits, reverse 16 and shift\n   // e.g. 11 bits, bit reverse and shift away 5\n   return stbi__bitreverse16(v) >> (16-bits);\n}\n\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)\n{\n   int i,k=0;\n   int code, next_code[16], sizes[17];\n\n   // DEFLATE spec for generating codes\n   memset(sizes, 0, sizeof(sizes));\n   memset(z->fast, 0, sizeof(z->fast));\n   for (i=0; i < num; ++i)\n      ++sizes[sizelist[i]];\n   sizes[0] = 0;\n   for (i=1; i < 16; ++i)\n      if (sizes[i] > (1 << i))\n         return stbi__err(\"bad sizes\", \"Corrupt PNG\");\n   code = 0;\n   for (i=1; i < 16; ++i) {\n      next_code[i] = code;\n      z->firstcode[i] = (stbi__uint16) code;\n      z->firstsymbol[i] = (stbi__uint16) k;\n      code = (code + sizes[i]);\n      if (sizes[i])\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\n      code <<= 1;\n      k += sizes[i];\n   }\n   z->maxcode[16] = 0x10000; // sentinel\n   for (i=0; i < num; ++i) {\n      int s = sizelist[i];\n      if (s) {\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\n         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);\n         z->size [c] = (stbi_uc     ) s;\n         z->value[c] = (stbi__uint16) i;\n         if (s <= STBI__ZFAST_BITS) {\n            int j = stbi__bit_reverse(next_code[s],s);\n            while (j < (1 << STBI__ZFAST_BITS)) {\n               z->fast[j] = fastv;\n               j += (1 << s);\n            }\n         }\n         ++next_code[s];\n      }\n   }\n   return 1;\n}\n\n// zlib-from-memory implementation for PNG reading\n//    because PNG allows splitting the zlib stream arbitrarily,\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\n//    we require PNG read all the IDATs and combine them into a single\n//    memory buffer\n\ntypedef struct\n{\n   stbi_uc *zbuffer, *zbuffer_end;\n   int num_bits;\n   int hit_zeof_once;\n   stbi__uint32 code_buffer;\n\n   char *zout;\n   char *zout_start;\n   char *zout_end;\n   int   z_expandable;\n\n   stbi__zhuffman z_length, z_distance;\n} stbi__zbuf;\n\nstbi_inline static int stbi__zeof(stbi__zbuf *z)\n{\n   return (z->zbuffer >= z->zbuffer_end);\n}\n\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\n{\n   return stbi__zeof(z) ? 0 : *z->zbuffer++;\n}\n\nstatic void stbi__fill_bits(stbi__zbuf *z)\n{\n   do {\n      if (z->code_buffer >= (1U << z->num_bits)) {\n        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */\n        return;\n      }\n      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;\n      z->num_bits += 8;\n   } while (z->num_bits <= 24);\n}\n\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\n{\n   unsigned int k;\n   if (z->num_bits < n) stbi__fill_bits(z);\n   k = z->code_buffer & ((1 << n) - 1);\n   z->code_buffer >>= n;\n   z->num_bits -= n;\n   return k;\n}\n\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s,k;\n   // not resolved by fast table, so compute it the slow way\n   // use jpeg approach, which requires MSbits at top\n   k = stbi__bit_reverse(a->code_buffer, 16);\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\n      if (k < z->maxcode[s])\n         break;\n   if (s >= 16) return -1; // invalid code!\n   // code size is s, so:\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\n   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!\n   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.\n   a->code_buffer >>= s;\n   a->num_bits -= s;\n   return z->value[b];\n}\n\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s;\n   if (a->num_bits < 16) {\n      if (stbi__zeof(a)) {\n         if (!a->hit_zeof_once) {\n            // This is the first time we hit eof, insert 16 extra padding btis\n            // to allow us to keep going; if we actually consume any of them\n            // though, that is invalid data. This is caught later.\n            a->hit_zeof_once = 1;\n            a->num_bits += 16; // add 16 implicit zero bits\n         } else {\n            // We already inserted our extra 16 padding bits and are again\n            // out, this stream is actually prematurely terminated.\n            return -1;\n         }\n      } else {\n         stbi__fill_bits(a);\n      }\n   }\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\n   if (b) {\n      s = b >> 9;\n      a->code_buffer >>= s;\n      a->num_bits -= s;\n      return b & 511;\n   }\n   return stbi__zhuffman_decode_slowpath(a, z);\n}\n\nstatic int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes\n{\n   char *q;\n   unsigned int cur, limit, old_limit;\n   z->zout = zout;\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\n   cur   = (unsigned int) (z->zout - z->zout_start);\n   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);\n   if (UINT_MAX - cur < (unsigned) n) return stbi__err(\"outofmem\", \"Out of memory\");\n   while (cur + n > limit) {\n      if(limit > UINT_MAX / 2) return stbi__err(\"outofmem\", \"Out of memory\");\n      limit *= 2;\n   }\n   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\n   STBI_NOTUSED(old_limit);\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n   z->zout_start = q;\n   z->zout       = q + cur;\n   z->zout_end   = q + limit;\n   return 1;\n}\n\nstatic const int stbi__zlength_base[31] = {\n   3,4,5,6,7,8,9,10,11,13,\n   15,17,19,23,27,31,35,43,51,59,\n   67,83,99,115,131,163,195,227,258,0,0 };\n\nstatic const int stbi__zlength_extra[31]=\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n\nstatic const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n\nstatic const int stbi__zdist_extra[32] =\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\n{\n   char *zout = a->zout;\n   for(;;) {\n      int z = stbi__zhuffman_decode(a, &a->z_length);\n      if (z < 256) {\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\n         if (zout >= a->zout_end) {\n            if (!stbi__zexpand(a, zout, 1)) return 0;\n            zout = a->zout;\n         }\n         *zout++ = (char) z;\n      } else {\n         stbi_uc *p;\n         int len,dist;\n         if (z == 256) {\n            a->zout = zout;\n            if (a->hit_zeof_once && a->num_bits < 16) {\n               // The first time we hit zeof, we inserted 16 extra zero bits into our bit\n               // buffer so the decoder can just do its speculative decoding. But if we\n               // actually consumed any of those bits (which is the case when num_bits < 16),\n               // the stream actually read past the end so it is malformed.\n               return stbi__err(\"unexpected end\",\"Corrupt PNG\");\n            }\n            return 1;\n         }\n         if (z >= 286) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data\n         z -= 257;\n         len = stbi__zlength_base[z];\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\n         z = stbi__zhuffman_decode(a, &a->z_distance);\n         if (z < 0 || z >= 30) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data\n         dist = stbi__zdist_base[z];\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\n         if (zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\n         if (len > a->zout_end - zout) {\n            if (!stbi__zexpand(a, zout, len)) return 0;\n            zout = a->zout;\n         }\n         p = (stbi_uc *) (zout - dist);\n         if (dist == 1) { // run of one byte; common in images.\n            stbi_uc v = *p;\n            if (len) { do *zout++ = v; while (--len); }\n         } else {\n            if (len) { do *zout++ = *p++; while (--len); }\n         }\n      }\n   }\n}\n\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\n{\n   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n   stbi__zhuffman z_codelength;\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\n   stbi_uc codelength_sizes[19];\n   int i,n;\n\n   int hlit  = stbi__zreceive(a,5) + 257;\n   int hdist = stbi__zreceive(a,5) + 1;\n   int hclen = stbi__zreceive(a,4) + 4;\n   int ntot  = hlit + hdist;\n\n   memset(codelength_sizes, 0, sizeof(codelength_sizes));\n   for (i=0; i < hclen; ++i) {\n      int s = stbi__zreceive(a,3);\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\n   }\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\n\n   n = 0;\n   while (n < ntot) {\n      int c = stbi__zhuffman_decode(a, &z_codelength);\n      if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n      if (c < 16)\n         lencodes[n++] = (stbi_uc) c;\n      else {\n         stbi_uc fill = 0;\n         if (c == 16) {\n            c = stbi__zreceive(a,2)+3;\n            if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n            fill = lencodes[n-1];\n         } else if (c == 17) {\n            c = stbi__zreceive(a,3)+3;\n         } else if (c == 18) {\n            c = stbi__zreceive(a,7)+11;\n         } else {\n            return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         }\n         if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         memset(lencodes+n, fill, c);\n         n += c;\n      }\n   }\n   if (n != ntot) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\n   return 1;\n}\n\nstatic int stbi__parse_uncompressed_block(stbi__zbuf *a)\n{\n   stbi_uc header[4];\n   int len,nlen,k;\n   if (a->num_bits & 7)\n      stbi__zreceive(a, a->num_bits & 7); // discard\n   // drain the bit-packed data into header\n   k = 0;\n   while (a->num_bits > 0) {\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\n      a->code_buffer >>= 8;\n      a->num_bits -= 8;\n   }\n   if (a->num_bits < 0) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   // now fill header the normal way\n   while (k < 4)\n      header[k++] = stbi__zget8(a);\n   len  = header[1] * 256 + header[0];\n   nlen = header[3] * 256 + header[2];\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\n   if (a->zout + len > a->zout_end)\n      if (!stbi__zexpand(a, a->zout, len)) return 0;\n   memcpy(a->zout, a->zbuffer, len);\n   a->zbuffer += len;\n   a->zout += len;\n   return 1;\n}\n\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\n{\n   int cmf   = stbi__zget8(a);\n   int cm    = cmf & 15;\n   /* int cinfo = cmf >> 4; */\n   int flg   = stbi__zget8(a);\n   if (stbi__zeof(a)) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\n   return 1;\n}\n\nstatic const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =\n{\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\n};\nstatic const stbi_uc stbi__zdefault_distance[32] =\n{\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\n};\n/*\nInit algorithm:\n{\n   int i;   // use <= to match clearly with spec\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\n\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\n}\n*/\n\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\n{\n   int final, type;\n   if (parse_header)\n      if (!stbi__parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   a->hit_zeof_once = 0;\n   do {\n      final = stbi__zreceive(a,1);\n      type = stbi__zreceive(a,2);\n      if (type == 0) {\n         if (!stbi__parse_uncompressed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\n         } else {\n            if (!stbi__compute_huffman_codes(a)) return 0;\n         }\n         if (!stbi__parse_huffman_block(a)) return 0;\n      }\n   } while (!final);\n   return 1;\n}\n\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\n{\n   a->zout_start = obuf;\n   a->zout       = obuf;\n   a->zout_end   = obuf + olen;\n   a->z_expandable = exp;\n\n   return stbi__parse_zlib(a, parse_header);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\n{\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(16384);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer+len;\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n#endif\n\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\n//    simple implementation\n//      - only 8-bit samples\n//      - no CRC checking\n//      - allocates lots of intermediate memory\n//        - avoids problem of streaming data between subsystems\n//        - avoids explicit window management\n//    performance\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\n\n#ifndef STBI_NO_PNG\ntypedef struct\n{\n   stbi__uint32 length;\n   stbi__uint32 type;\n} stbi__pngchunk;\n\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\n{\n   stbi__pngchunk c;\n   c.length = stbi__get32be(s);\n   c.type   = stbi__get32be(s);\n   return c;\n}\n\nstatic int stbi__check_png_header(stbi__context *s)\n{\n   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\n   int i;\n   for (i=0; i < 8; ++i)\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\n   return 1;\n}\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi_uc *idata, *expanded, *out;\n   int depth;\n} stbi__png;\n\n\nenum {\n   STBI__F_none=0,\n   STBI__F_sub=1,\n   STBI__F_up=2,\n   STBI__F_avg=3,\n   STBI__F_paeth=4,\n   // synthetic filter used for first scanline to avoid needing a dummy row of 0s\n   STBI__F_avg_first\n};\n\nstatic stbi_uc first_row_filter[5] =\n{\n   STBI__F_none,\n   STBI__F_sub,\n   STBI__F_none,\n   STBI__F_avg_first,\n   STBI__F_sub // Paeth with b=c=0 turns out to be equivalent to sub\n};\n\nstatic int stbi__paeth(int a, int b, int c)\n{\n   // This formulation looks very different from the reference in the PNG spec, but is\n   // actually equivalent and has favorable data dependencies and admits straightforward\n   // generation of branch-free code, which helps performance significantly.\n   int thresh = c*3 - (a + b);\n   int lo = a < b ? a : b;\n   int hi = a < b ? b : a;\n   int t0 = (hi <= thresh) ? lo : c;\n   int t1 = (thresh <= lo) ? hi : t0;\n   return t1;\n}\n\nstatic const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\n\n// adds an extra all-255 alpha channel\n// dest == src is legal\n// img_n must be 1 or 3\nstatic void stbi__create_png_alpha_expand8(stbi_uc *dest, stbi_uc *src, stbi__uint32 x, int img_n)\n{\n   int i;\n   // must process data backwards since we allow dest==src\n   if (img_n == 1) {\n      for (i=x-1; i >= 0; --i) {\n         dest[i*2+1] = 255;\n         dest[i*2+0] = src[i];\n      }\n   } else {\n      STBI_ASSERT(img_n == 3);\n      for (i=x-1; i >= 0; --i) {\n         dest[i*4+3] = 255;\n         dest[i*4+2] = src[i*3+2];\n         dest[i*4+1] = src[i*3+1];\n         dest[i*4+0] = src[i*3+0];\n      }\n   }\n}\n\n// create the png data from post-deflated data\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\n{\n   int bytes = (depth == 16 ? 2 : 1);\n   stbi__context *s = a->s;\n   stbi__uint32 i,j,stride = x*out_n*bytes;\n   stbi__uint32 img_len, img_width_bytes;\n   stbi_uc *filter_buf;\n   int all_ok = 1;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n\n   int output_bytes = out_n*bytes;\n   int filter_bytes = img_n*bytes;\n   int width = x;\n\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\n   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // note: error exits here don't need to clean up a->out individually,\n   // stbi__do_png always does on error.\n   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(\"too large\", \"Corrupt PNG\");\n   img_width_bytes = (((img_n * x * depth) + 7) >> 3);\n   if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err(\"too large\", \"Corrupt PNG\");\n   img_len = (img_width_bytes + 1) * y;\n\n   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\n   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\n   // so just check for raw_len < img_len always.\n   if (raw_len < img_len) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\n\n   // Allocate two scan lines worth of filter workspace buffer.\n   filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);\n   if (!filter_buf) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // Filtering for low-bit-depth images\n   if (depth < 8) {\n      filter_bytes = 1;\n      width = img_width_bytes;\n   }\n\n   for (j=0; j < y; ++j) {\n      // cur/prior filter buffers alternate\n      stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;\n      stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;\n      stbi_uc *dest = a->out + stride*j;\n      int nk = width * filter_bytes;\n      int filter = *raw++;\n\n      // check filter type\n      if (filter > 4) {\n         all_ok = stbi__err(\"invalid filter\",\"Corrupt PNG\");\n         break;\n      }\n\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n\n      // perform actual filtering\n      switch (filter) {\n      case STBI__F_none:\n         memcpy(cur, raw, nk);\n         break;\n      case STBI__F_sub:\n         memcpy(cur, raw, filter_bytes);\n         for (k = filter_bytes; k < nk; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);\n         break;\n      case STBI__F_up:\n         for (k = 0; k < nk; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + prior[k]);\n         break;\n      case STBI__F_avg:\n         for (k = 0; k < filter_bytes; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));\n         for (k = filter_bytes; k < nk; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));\n         break;\n      case STBI__F_paeth:\n         for (k = 0; k < filter_bytes; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)\n         for (k = filter_bytes; k < nk; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));\n         break;\n      case STBI__F_avg_first:\n         memcpy(cur, raw, filter_bytes);\n         for (k = filter_bytes; k < nk; ++k)\n            cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));\n         break;\n      }\n\n      raw += nk;\n\n      // expand decoded bits in cur to dest, also adding an extra alpha channel if desired\n      if (depth < 8) {\n         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\n         stbi_uc *in = cur;\n         stbi_uc *out = dest;\n         stbi_uc inb = 0;\n         stbi__uint32 nsmp = x*img_n;\n\n         // expand bits to bytes first\n         if (depth == 4) {\n            for (i=0; i < nsmp; ++i) {\n               if ((i & 1) == 0) inb = *in++;\n               *out++ = scale * (inb >> 4);\n               inb <<= 4;\n            }\n         } else if (depth == 2) {\n            for (i=0; i < nsmp; ++i) {\n               if ((i & 3) == 0) inb = *in++;\n               *out++ = scale * (inb >> 6);\n               inb <<= 2;\n            }\n         } else {\n            STBI_ASSERT(depth == 1);\n            for (i=0; i < nsmp; ++i) {\n               if ((i & 7) == 0) inb = *in++;\n               *out++ = scale * (inb >> 7);\n               inb <<= 1;\n            }\n         }\n\n         // insert alpha=255 values if desired\n         if (img_n != out_n)\n            stbi__create_png_alpha_expand8(dest, dest, x, img_n);\n      } else if (depth == 8) {\n         if (img_n == out_n)\n            memcpy(dest, cur, x*img_n);\n         else\n            stbi__create_png_alpha_expand8(dest, cur, x, img_n);\n      } else if (depth == 16) {\n         // convert the image data from big-endian to platform-native\n         stbi__uint16 *dest16 = (stbi__uint16*)dest;\n         stbi__uint32 nsmp = x*img_n;\n\n         if (img_n == out_n) {\n            for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)\n               *dest16 = (cur[0] << 8) | cur[1];\n         } else {\n            STBI_ASSERT(img_n+1 == out_n);\n            if (img_n == 1) {\n               for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {\n                  dest16[0] = (cur[0] << 8) | cur[1];\n                  dest16[1] = 0xffff;\n               }\n            } else {\n               STBI_ASSERT(img_n == 3);\n               for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {\n                  dest16[0] = (cur[0] << 8) | cur[1];\n                  dest16[1] = (cur[2] << 8) | cur[3];\n                  dest16[2] = (cur[4] << 8) | cur[5];\n                  dest16[3] = 0xffff;\n               }\n            }\n         }\n      }\n   }\n\n   STBI_FREE(filter_buf);\n   if (!all_ok) return 0;\n\n   return 1;\n}\n\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\n{\n   int bytes = (depth == 16 ? 2 : 1);\n   int out_bytes = out_n * bytes;\n   stbi_uc *final;\n   int p;\n   if (!interlaced)\n      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\n\n   // de-interlacing\n   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\n   if (!final) return stbi__err(\"outofmem\", \"Out of memory\");\n   for (p=0; p < 7; ++p) {\n      int xorig[] = { 0,4,0,2,0,1,0 };\n      int yorig[] = { 0,0,4,0,2,0,1 };\n      int xspc[]  = { 8,8,4,4,2,2,1 };\n      int yspc[]  = { 8,8,8,4,4,2,2 };\n      int i,j,x,y;\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\n      if (x && y) {\n         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\n         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\n            STBI_FREE(final);\n            return 0;\n         }\n         for (j=0; j < y; ++j) {\n            for (i=0; i < x; ++i) {\n               int out_y = j*yspc[p]+yorig[p];\n               int out_x = i*xspc[p]+xorig[p];\n               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,\n                      a->out + (j*x+i)*out_bytes, out_bytes);\n            }\n         }\n         STBI_FREE(a->out);\n         image_data += img_len;\n         image_data_len -= img_len;\n      }\n   }\n   a->out = final;\n\n   return 1;\n}\n\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 255 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i=0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 255);\n         p += 2;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi__uint16 *p = (stbi__uint16*) z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 65535 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i = 0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 65535);\n         p += 2;\n      }\n   } else {\n      for (i = 0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\n{\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\n   stbi_uc *p, *temp_out, *orig = a->out;\n\n   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // between here and free(out) below, exitting would leak\n   temp_out = p;\n\n   if (pal_img_n == 3) {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p += 3;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p[3] = palette[n+3];\n         p += 4;\n      }\n   }\n   STBI_FREE(a->out);\n   a->out = temp_out;\n\n   STBI_NOTUSED(len);\n\n   return 1;\n}\n\nstatic int stbi__unpremultiply_on_load_global = 0;\nstatic int stbi__de_iphone_flag_global = 0;\n\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_global = flag_true_if_should_convert;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global\n#define stbi__de_iphone_flag  stbi__de_iphone_flag_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;\nstatic STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;\n\nSTBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;\n   stbi__unpremultiply_on_load_set = 1;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_local = flag_true_if_should_convert;\n   stbi__de_iphone_flag_set = 1;\n}\n\n#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \\\n                                       ? stbi__unpremultiply_on_load_local      \\\n                                       : stbi__unpremultiply_on_load_global)\n#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \\\n                                ? stbi__de_iphone_flag_local                    \\\n                                : stbi__de_iphone_flag_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void stbi__de_iphone(stbi__png *z)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   if (s->img_out_n == 3) {  // convert bgr to rgb\n      for (i=0; i < pixel_count; ++i) {\n         stbi_uc t = p[0];\n         p[0] = p[2];\n         p[2] = t;\n         p += 3;\n      }\n   } else {\n      STBI_ASSERT(s->img_out_n == 4);\n      if (stbi__unpremultiply_on_load) {\n         // convert bgr to rgb and unpremultiply\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc a = p[3];\n            stbi_uc t = p[0];\n            if (a) {\n               stbi_uc half = a / 2;\n               p[0] = (p[2] * 255 + half) / a;\n               p[1] = (p[1] * 255 + half) / a;\n               p[2] = ( t   * 255 + half) / a;\n            } else {\n               p[0] = p[2];\n               p[2] = t;\n            }\n            p += 4;\n         }\n      } else {\n         // convert bgr to rgb\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc t = p[0];\n            p[0] = p[2];\n            p[2] = t;\n            p += 4;\n         }\n      }\n   }\n}\n\n#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))\n\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\n{\n   stbi_uc palette[1024], pal_img_n=0;\n   stbi_uc has_trans=0, tc[3]={0};\n   stbi__uint16 tc16[3];\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\n   int first=1,k,interlace=0, color=0, is_iphone=0;\n   stbi__context *s = z->s;\n\n   z->expanded = NULL;\n   z->idata = NULL;\n   z->out = NULL;\n\n   if (!stbi__check_png_header(s)) return 0;\n\n   if (scan == STBI__SCAN_type) return 1;\n\n   for (;;) {\n      stbi__pngchunk c = stbi__get_chunk_header(s);\n      switch (c.type) {\n         case STBI__PNG_TYPE('C','g','B','I'):\n            is_iphone = 1;\n            stbi__skip(s, c.length);\n            break;\n         case STBI__PNG_TYPE('I','H','D','R'): {\n            int comp,filter;\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\n            first = 0;\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\n            s->img_x = stbi__get32be(s);\n            s->img_y = stbi__get32be(s);\n            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\",\"PNG not supported: 1/2/4/8/16-bit only\");\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\n            if (!pal_img_n) {\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\n            } else {\n               // if paletted, then pal_n is our final components, and\n               // img_n is # components to decompress/filter.\n               s->img_n = 1;\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\n            }\n            // even with SCAN_header, have to scan to see if we have a tRNS\n            break;\n         }\n\n         case STBI__PNG_TYPE('P','L','T','E'):  {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            pal_len = c.length / 3;\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            for (i=0; i < pal_len; ++i) {\n               palette[i*4+0] = stbi__get8(s);\n               palette[i*4+1] = stbi__get8(s);\n               palette[i*4+2] = stbi__get8(s);\n               palette[i*4+3] = 255;\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('t','R','N','S'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\n            if (pal_img_n) {\n               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               pal_img_n = 4;\n               for (i=0; i < c.length; ++i)\n                  palette[i*4+3] = stbi__get8(s);\n            } else {\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               has_trans = 1;\n               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.\n               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }\n               if (z->depth == 16) {\n                  for (k = 0; k < s->img_n && k < 3; ++k) // extra loop test to suppress false GCC warning\n                     tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\n               } else {\n                  for (k = 0; k < s->img_n && k < 3; ++k)\n                     tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\n               }\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','D','A','T'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\n            if (scan == STBI__SCAN_header) {\n               // header scan definitely stops at first IDAT\n               if (pal_img_n)\n                  s->img_n = pal_img_n;\n               return 1;\n            }\n            if (c.length > (1u << 30)) return stbi__err(\"IDAT size limit\", \"IDAT section larger than 2^30 bytes\");\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\n            if (ioff + c.length > idata_limit) {\n               stbi__uint32 idata_limit_old = idata_limit;\n               stbi_uc *p;\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\n               while (ioff + c.length > idata_limit)\n                  idata_limit *= 2;\n               STBI_NOTUSED(idata_limit_old);\n               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n               z->idata = p;\n            }\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\n            ioff += c.length;\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','E','N','D'): {\n            stbi__uint32 raw_len, bpl;\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (scan != STBI__SCAN_load) return 1;\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\n            // initial guess for decoded data size to avoid unnecessary reallocs\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);\n            if (z->expanded == NULL) return 0; // zlib should set error\n            STBI_FREE(z->idata); z->idata = NULL;\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\n               s->img_out_n = s->img_n+1;\n            else\n               s->img_out_n = s->img_n;\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\n            if (has_trans) {\n               if (z->depth == 16) {\n                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\n               } else {\n                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\n               }\n            }\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\n               stbi__de_iphone(z);\n            if (pal_img_n) {\n               // pal_img_n == 3 or 4\n               s->img_n = pal_img_n; // record the actual colors we had\n               s->img_out_n = pal_img_n;\n               if (req_comp >= 3) s->img_out_n = req_comp;\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\n                  return 0;\n            } else if (has_trans) {\n               // non-paletted image with tRNS -> source image has (constant) alpha\n               ++s->img_n;\n            }\n            STBI_FREE(z->expanded); z->expanded = NULL;\n            // end of PNG chunk, read and skip CRC\n            stbi__get32be(s);\n            return 1;\n         }\n\n         default:\n            // if critical, fail\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if ((c.type & (1 << 29)) == 0) {\n               #ifndef STBI_NO_FAILURE_STRINGS\n               // not threadsafe\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\n               #endif\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\n            }\n            stbi__skip(s, c.length);\n            break;\n      }\n      // end of PNG chunk, read and skip CRC\n      stbi__get32be(s);\n   }\n}\n\nstatic void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)\n{\n   void *result=NULL;\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\n      if (p->depth <= 8)\n         ri->bits_per_channel = 8;\n      else if (p->depth == 16)\n         ri->bits_per_channel = 16;\n      else\n         return stbi__errpuc(\"bad bits_per_channel\", \"PNG not supported: unsupported color depth\");\n      result = p->out;\n      p->out = NULL;\n      if (req_comp && req_comp != p->s->img_out_n) {\n         if (ri->bits_per_channel == 8)\n            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         else\n            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         p->s->img_out_n = req_comp;\n         if (result == NULL) return result;\n      }\n      *x = p->s->img_x;\n      *y = p->s->img_y;\n      if (n) *n = p->s->img_n;\n   }\n   STBI_FREE(p->out);      p->out      = NULL;\n   STBI_FREE(p->expanded); p->expanded = NULL;\n   STBI_FREE(p->idata);    p->idata    = NULL;\n\n   return result;\n}\n\nstatic void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__do_png(&p, x,y,comp,req_comp, ri);\n}\n\nstatic int stbi__png_test(stbi__context *s)\n{\n   int r;\n   r = stbi__check_png_header(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\n{\n   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\n      stbi__rewind( p->s );\n      return 0;\n   }\n   if (x) *x = p->s->img_x;\n   if (y) *y = p->s->img_y;\n   if (comp) *comp = p->s->img_n;\n   return 1;\n}\n\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__png_info_raw(&p, x, y, comp);\n}\n\nstatic int stbi__png_is16(stbi__context *s)\n{\n   stbi__png p;\n   p.s = s;\n   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))\n\t   return 0;\n   if (p.depth != 16) {\n      stbi__rewind(p.s);\n      return 0;\n   }\n   return 1;\n}\n#endif\n\n// Microsoft/Windows BMP image\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_test_raw(stbi__context *s)\n{\n   int r;\n   int sz;\n   if (stbi__get8(s) != 'B') return 0;\n   if (stbi__get8(s) != 'M') return 0;\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   stbi__get32le(s); // discard data offset\n   sz = stbi__get32le(s);\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\n   return r;\n}\n\nstatic int stbi__bmp_test(stbi__context *s)\n{\n   int r = stbi__bmp_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\n\n// returns 0..31 for the highest set bit\nstatic int stbi__high_bit(unsigned int z)\n{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) { n += 16; z >>= 16; }\n   if (z >= 0x00100) { n +=  8; z >>=  8; }\n   if (z >= 0x00010) { n +=  4; z >>=  4; }\n   if (z >= 0x00004) { n +=  2; z >>=  2; }\n   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }\n   return n;\n}\n\nstatic int stbi__bitcount(unsigned int a)\n{\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\n   a = (a + (a >> 8)); // max 16 per 8 bits\n   a = (a + (a >> 16)); // max 32 per 8 bits\n   return a & 0xff;\n}\n\n// extract an arbitrarily-aligned N-bit value (N=bits)\n// from v, and then make it 8-bits long and fractionally\n// extend it to full full range.\nstatic int stbi__shiftsigned(unsigned int v, int shift, int bits)\n{\n   static unsigned int mul_table[9] = {\n      0,\n      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,\n      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,\n   };\n   static unsigned int shift_table[9] = {\n      0, 0,0,1,0,2,4,6,0,\n   };\n   if (shift < 0)\n      v <<= -shift;\n   else\n      v >>= shift;\n   STBI_ASSERT(v < 256);\n   v >>= (8-bits);\n   STBI_ASSERT(bits >= 0 && bits <= 8);\n   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];\n}\n\ntypedef struct\n{\n   int bpp, offset, hsz;\n   unsigned int mr,mg,mb,ma, all_a;\n   int extra_read;\n} stbi__bmp_data;\n\nstatic int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)\n{\n   // BI_BITFIELDS specifies masks explicitly, don't override\n   if (compress == 3)\n      return 1;\n\n   if (compress == 0) {\n      if (info->bpp == 16) {\n         info->mr = 31u << 10;\n         info->mg = 31u <<  5;\n         info->mb = 31u <<  0;\n      } else if (info->bpp == 32) {\n         info->mr = 0xffu << 16;\n         info->mg = 0xffu <<  8;\n         info->mb = 0xffu <<  0;\n         info->ma = 0xffu << 24;\n         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\n      } else {\n         // otherwise, use defaults, which is all-0\n         info->mr = info->mg = info->mb = info->ma = 0;\n      }\n      return 1;\n   }\n   return 0; // error\n}\n\nstatic void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)\n{\n   int hsz;\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   info->offset = stbi__get32le(s);\n   info->hsz = hsz = stbi__get32le(s);\n   info->mr = info->mg = info->mb = info->ma = 0;\n   info->extra_read = 14;\n\n   if (info->offset < 0) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\n   if (hsz == 12) {\n      s->img_x = stbi__get16le(s);\n      s->img_y = stbi__get16le(s);\n   } else {\n      s->img_x = stbi__get32le(s);\n      s->img_y = stbi__get32le(s);\n   }\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n   info->bpp = stbi__get16le(s);\n   if (hsz != 12) {\n      int compress = stbi__get32le(s);\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\n      if (compress >= 4) return stbi__errpuc(\"BMP JPEG/PNG\", \"BMP type not supported: unsupported compression\"); // this includes PNG/JPEG modes\n      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(\"bad BMP\", \"bad BMP\"); // bitfields requires 16 or 32 bits/pixel\n      stbi__get32le(s); // discard sizeof\n      stbi__get32le(s); // discard hres\n      stbi__get32le(s); // discard vres\n      stbi__get32le(s); // discard colorsused\n      stbi__get32le(s); // discard max important\n      if (hsz == 40 || hsz == 56) {\n         if (hsz == 56) {\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n         }\n         if (info->bpp == 16 || info->bpp == 32) {\n            if (compress == 0) {\n               stbi__bmp_set_mask_defaults(info, compress);\n            } else if (compress == 3) {\n               info->mr = stbi__get32le(s);\n               info->mg = stbi__get32le(s);\n               info->mb = stbi__get32le(s);\n               info->extra_read += 12;\n               // not documented, but generated by photoshop and handled by mspaint\n               if (info->mr == info->mg && info->mg == info->mb) {\n                  // ?!?!?\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n               }\n            } else\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         }\n      } else {\n         // V4/V5 header\n         int i;\n         if (hsz != 108 && hsz != 124)\n            return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         info->mr = stbi__get32le(s);\n         info->mg = stbi__get32le(s);\n         info->mb = stbi__get32le(s);\n         info->ma = stbi__get32le(s);\n         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs\n            stbi__bmp_set_mask_defaults(info, compress);\n         stbi__get32le(s); // discard color space\n         for (i=0; i < 12; ++i)\n            stbi__get32le(s); // discard color space parameters\n         if (hsz == 124) {\n            stbi__get32le(s); // discard rendering intent\n            stbi__get32le(s); // discard offset of profile data\n            stbi__get32le(s); // discard size of profile data\n            stbi__get32le(s); // discard reserved\n         }\n      }\n   }\n   return (void *) 1;\n}\n\n\nstatic void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;\n   stbi_uc pal[256][4];\n   int psize=0,i,j,width;\n   int flip_vertically, pad, target;\n   stbi__bmp_data info;\n   STBI_NOTUSED(ri);\n\n   info.all_a = 255;\n   if (stbi__bmp_parse_header(s, &info) == NULL)\n      return NULL; // error code already set\n\n   flip_vertically = ((int) s->img_y) > 0;\n   s->img_y = abs((int) s->img_y);\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   mr = info.mr;\n   mg = info.mg;\n   mb = info.mb;\n   ma = info.ma;\n   all_a = info.all_a;\n\n   if (info.hsz == 12) {\n      if (info.bpp < 24)\n         psize = (info.offset - info.extra_read - 24) / 3;\n   } else {\n      if (info.bpp < 16)\n         psize = (info.offset - info.extra_read - info.hsz) >> 2;\n   }\n   if (psize == 0) {\n      // accept some number of extra bytes after the header, but if the offset points either to before\n      // the header ends or implies a large amount of extra data, reject the file as malformed\n      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);\n      int header_limit = 1024; // max we actually read is below 256 bytes currently.\n      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.\n      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {\n         return stbi__errpuc(\"bad header\", \"Corrupt BMP\");\n      }\n      // we established that bytes_read_so_far is positive and sensible.\n      // the first half of this test rejects offsets that are either too small positives, or\n      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn\n      // ensures the number computed in the second half of the test can't overflow.\n      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {\n         return stbi__errpuc(\"bad offset\", \"Corrupt BMP\");\n      } else {\n         stbi__skip(s, info.offset - bytes_read_so_far);\n      }\n   }\n\n   if (info.bpp == 24 && ma == 0xff000000)\n      s->img_n = 3;\n   else\n      s->img_n = ma ? 4 : 3;\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\n      target = req_comp;\n   else\n      target = s->img_n; // if they want monochrome, we'll post-convert\n\n   // sanity-check size\n   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt BMP\");\n\n   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (info.bpp < 16) {\n      int z=0;\n      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\n      for (i=0; i < psize; ++i) {\n         pal[i][2] = stbi__get8(s);\n         pal[i][1] = stbi__get8(s);\n         pal[i][0] = stbi__get8(s);\n         if (info.hsz != 12) stbi__get8(s);\n         pal[i][3] = 255;\n      }\n      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\n      if (info.bpp == 1) width = (s->img_x + 7) >> 3;\n      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;\n      else if (info.bpp == 8) width = s->img_x;\n      else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\n      pad = (-width)&3;\n      if (info.bpp == 1) {\n         for (j=0; j < (int) s->img_y; ++j) {\n            int bit_offset = 7, v = stbi__get8(s);\n            for (i=0; i < (int) s->img_x; ++i) {\n               int color = (v>>bit_offset)&0x1;\n               out[z++] = pal[color][0];\n               out[z++] = pal[color][1];\n               out[z++] = pal[color][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               if((--bit_offset) < 0) {\n                  bit_offset = 7;\n                  v = stbi__get8(s);\n               }\n            }\n            stbi__skip(s, pad);\n         }\n      } else {\n         for (j=0; j < (int) s->img_y; ++j) {\n            for (i=0; i < (int) s->img_x; i += 2) {\n               int v=stbi__get8(s),v2=0;\n               if (info.bpp == 4) {\n                  v2 = v & 15;\n                  v >>= 4;\n               }\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               v = (info.bpp == 8) ? stbi__get8(s) : v2;\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n            }\n            stbi__skip(s, pad);\n         }\n      }\n   } else {\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\n      int z = 0;\n      int easy=0;\n      stbi__skip(s, info.offset - info.extra_read - info.hsz);\n      if (info.bpp == 24) width = 3 * s->img_x;\n      else if (info.bpp == 16) width = 2*s->img_x;\n      else /* bpp = 32 and pad = 0 */ width=0;\n      pad = (-width) & 3;\n      if (info.bpp == 24) {\n         easy = 1;\n      } else if (info.bpp == 32) {\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\n            easy = 2;\n      }\n      if (!easy) {\n         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n         // right shift amt to put high bit in position #7\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\n         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n      }\n      for (j=0; j < (int) s->img_y; ++j) {\n         if (easy) {\n            for (i=0; i < (int) s->img_x; ++i) {\n               unsigned char a;\n               out[z+2] = stbi__get8(s);\n               out[z+1] = stbi__get8(s);\n               out[z+0] = stbi__get8(s);\n               z += 3;\n               a = (easy == 2 ? stbi__get8(s) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = a;\n            }\n         } else {\n            int bpp = info.bpp;\n            for (i=0; i < (int) s->img_x; ++i) {\n               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));\n               unsigned int a;\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = STBI__BYTECAST(a);\n            }\n         }\n         stbi__skip(s, pad);\n      }\n   }\n\n   // if alpha channel is all 0s, replace with all 255s\n   if (target == 4 && all_a == 0)\n      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)\n         out[i] = 255;\n\n   if (flip_vertically) {\n      stbi_uc t;\n      for (j=0; j < (int) s->img_y>>1; ++j) {\n         stbi_uc *p1 = out +      j     *s->img_x*target;\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\n         for (i=0; i < (int) s->img_x*target; ++i) {\n            t = p1[i]; p1[i] = p2[i]; p2[i] = t;\n         }\n      }\n   }\n\n   if (req_comp && req_comp != target) {\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n   return out;\n}\n#endif\n\n// Targa Truevision - TGA\n// by Jonathan Dummer\n#ifndef STBI_NO_TGA\n// returns STBI_rgb or whatever, 0 on error\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\n{\n   // only RGB or RGBA (incl. 16bit) or grey allowed\n   if (is_rgb16) *is_rgb16 = 0;\n   switch(bits_per_pixel) {\n      case 8:  return STBI_grey;\n      case 16: if(is_grey) return STBI_grey_alpha;\n               // fallthrough\n      case 15: if(is_rgb16) *is_rgb16 = 1;\n               return STBI_rgb;\n      case 24: // fallthrough\n      case 32: return bits_per_pixel/8;\n      default: return 0;\n   }\n}\n\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\n{\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\n    int sz, tga_colormap_type;\n    stbi__get8(s);                   // discard Offset\n    tga_colormap_type = stbi__get8(s); // colormap type\n    if( tga_colormap_type > 1 ) {\n        stbi__rewind(s);\n        return 0;      // only RGB or indexed allowed\n    }\n    tga_image_type = stbi__get8(s); // image type\n    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image\n        if (tga_image_type != 1 && tga_image_type != 9) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n        sz = stbi__get8(s);    //   check bits per palette color entry\n        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip image x and y origin\n        tga_colormap_bpp = sz;\n    } else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\n        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {\n            stbi__rewind(s);\n            return 0; // only RGB or grey allowed, +/- RLE\n        }\n        stbi__skip(s,9); // skip colormap specification and image x/y origin\n        tga_colormap_bpp = 0;\n    }\n    tga_w = stbi__get16le(s);\n    if( tga_w < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test width\n    }\n    tga_h = stbi__get16le(s);\n    if( tga_h < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test height\n    }\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\n    stbi__get8(s); // ignore alpha bits\n    if (tga_colormap_bpp != 0) {\n        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\n            // I don't think anything but 8 or 16bit indexes makes sense\n            stbi__rewind(s);\n            return 0;\n        }\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\n    } else {\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\n    }\n    if(!tga_comp) {\n      stbi__rewind(s);\n      return 0;\n    }\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp;\n    return 1;                   // seems to have passed everything\n}\n\nstatic int stbi__tga_test(stbi__context *s)\n{\n   int res = 0;\n   int sz, tga_color_type;\n   stbi__get8(s);      //   discard Offset\n   tga_color_type = stbi__get8(s);   //   color type\n   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed\n   sz = stbi__get8(s);   //   image type\n   if ( tga_color_type == 1 ) { // colormapped (paletted) image\n      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\n      stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n      sz = stbi__get8(s);    //   check bits per palette color entry\n      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n      stbi__skip(s,4);       // skip image x and y origin\n   } else { // \"normal\" image w/o colormap\n      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE\n      stbi__skip(s,9); // skip colormap specification and image x/y origin\n   }\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height\n   sz = stbi__get8(s);   //   bits per pixel\n   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index\n   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n\n   res = 1; // if we got this far, everything's good and we can return 1 instead of 0\n\nerrorEnd:\n   stbi__rewind(s);\n   return res;\n}\n\n// read 16bit value and convert to 24bit RGB\nstatic void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)\n{\n   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\n   stbi__uint16 fiveBitMask = 31;\n   // we have 3 channels with 5bits each\n   int r = (px >> 10) & fiveBitMask;\n   int g = (px >> 5) & fiveBitMask;\n   int b = px & fiveBitMask;\n   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\n   out[0] = (stbi_uc)((r * 255)/31);\n   out[1] = (stbi_uc)((g * 255)/31);\n   out[2] = (stbi_uc)((b * 255)/31);\n\n   // some people claim that the most significant bit might be used for alpha\n   // (possibly if an alpha-bit is set in the \"image descriptor byte\")\n   // but that only made 16bit test images completely translucent..\n   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\n}\n\nstatic void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   //   read in the TGA header stuff\n   int tga_offset = stbi__get8(s);\n   int tga_indexed = stbi__get8(s);\n   int tga_image_type = stbi__get8(s);\n   int tga_is_RLE = 0;\n   int tga_palette_start = stbi__get16le(s);\n   int tga_palette_len = stbi__get16le(s);\n   int tga_palette_bits = stbi__get8(s);\n   int tga_x_origin = stbi__get16le(s);\n   int tga_y_origin = stbi__get16le(s);\n   int tga_width = stbi__get16le(s);\n   int tga_height = stbi__get16le(s);\n   int tga_bits_per_pixel = stbi__get8(s);\n   int tga_comp, tga_rgb16=0;\n   int tga_inverted = stbi__get8(s);\n   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\n   //   image data\n   unsigned char *tga_data;\n   unsigned char *tga_palette = NULL;\n   int i, j;\n   unsigned char raw_data[4] = {0};\n   int RLE_count = 0;\n   int RLE_repeating = 0;\n   int read_next_pixel = 1;\n   STBI_NOTUSED(ri);\n   STBI_NOTUSED(tga_x_origin); // @TODO\n   STBI_NOTUSED(tga_y_origin); // @TODO\n\n   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   //   do a tiny bit of precessing\n   if ( tga_image_type >= 8 )\n   {\n      tga_image_type -= 8;\n      tga_is_RLE = 1;\n   }\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\n\n   //   If I'm paletted, then I'll use the number of bits from the palette\n   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\n   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\n\n   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\n      return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\n\n   //   tga info\n   *x = tga_width;\n   *y = tga_height;\n   if (comp) *comp = tga_comp;\n\n   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt TGA\");\n\n   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   // skip to the data's starting position (offset usually = 0)\n   stbi__skip(s, tga_offset );\n\n   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {\n      for (i=0; i < tga_height; ++i) {\n         int row = tga_inverted ? tga_height -i - 1 : i;\n         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;\n         stbi__getn(s, tga_row, tga_width * tga_comp);\n      }\n   } else  {\n      //   do I need to load a palette?\n      if ( tga_indexed)\n      {\n         if (tga_palette_len == 0) {  /* you have to have at least one entry! */\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n\n         //   any data to skip? (offset usually = 0)\n         stbi__skip(s, tga_palette_start );\n         //   load the palette\n         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\n         if (!tga_palette) {\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\n         }\n         if (tga_rgb16) {\n            stbi_uc *pal_entry = tga_palette;\n            STBI_ASSERT(tga_comp == STBI_rgb);\n            for (i=0; i < tga_palette_len; ++i) {\n               stbi__tga_read_rgb16(s, pal_entry);\n               pal_entry += tga_comp;\n            }\n         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\n               STBI_FREE(tga_data);\n               STBI_FREE(tga_palette);\n               return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n      }\n      //   load the data\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\n         if ( tga_is_RLE )\n         {\n            if ( RLE_count == 0 )\n            {\n               //   yep, get the next byte as a RLE command\n               int RLE_cmd = stbi__get8(s);\n               RLE_count = 1 + (RLE_cmd & 127);\n               RLE_repeating = RLE_cmd >> 7;\n               read_next_pixel = 1;\n            } else if ( !RLE_repeating )\n            {\n               read_next_pixel = 1;\n            }\n         } else\n         {\n            read_next_pixel = 1;\n         }\n         //   OK, if I need to read a pixel, do it now\n         if ( read_next_pixel )\n         {\n            //   load however much data we did have\n            if ( tga_indexed )\n            {\n               // read in index, then perform the lookup\n               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\n               if ( pal_idx >= tga_palette_len ) {\n                  // invalid index\n                  pal_idx = 0;\n               }\n               pal_idx *= tga_comp;\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = tga_palette[pal_idx+j];\n               }\n            } else if(tga_rgb16) {\n               STBI_ASSERT(tga_comp == STBI_rgb);\n               stbi__tga_read_rgb16(s, raw_data);\n            } else {\n               //   read in the data raw\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = stbi__get8(s);\n               }\n            }\n            //   clear the reading flag for the next pixel\n            read_next_pixel = 0;\n         } // end of reading a pixel\n\n         // copy data\n         for (j = 0; j < tga_comp; ++j)\n           tga_data[i*tga_comp+j] = raw_data[j];\n\n         //   in case we're in RLE mode, keep counting down\n         --RLE_count;\n      }\n      //   do I need to invert the image?\n      if ( tga_inverted )\n      {\n         for (j = 0; j*2 < tga_height; ++j)\n         {\n            int index1 = j * tga_width * tga_comp;\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\n            for (i = tga_width * tga_comp; i > 0; --i)\n            {\n               unsigned char temp = tga_data[index1];\n               tga_data[index1] = tga_data[index2];\n               tga_data[index2] = temp;\n               ++index1;\n               ++index2;\n            }\n         }\n      }\n      //   clear my palette, if I had one\n      if ( tga_palette != NULL )\n      {\n         STBI_FREE( tga_palette );\n      }\n   }\n\n   // swap RGB - if the source data was RGB16, it already is in the right order\n   if (tga_comp >= 3 && !tga_rgb16)\n   {\n      unsigned char* tga_pixel = tga_data;\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         unsigned char temp = tga_pixel[0];\n         tga_pixel[0] = tga_pixel[2];\n         tga_pixel[2] = temp;\n         tga_pixel += tga_comp;\n      }\n   }\n\n   // convert to target component count\n   if (req_comp && req_comp != tga_comp)\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\n\n   //   the things I do to get rid of an error message, and yet keep\n   //   Microsoft's C compilers happy... [8^(\n   tga_palette_start = tga_palette_len = tga_palette_bits =\n         tga_x_origin = tga_y_origin = 0;\n   STBI_NOTUSED(tga_palette_start);\n   //   OK, done\n   return tga_data;\n}\n#endif\n\n// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_test(stbi__context *s)\n{\n   int r = (stbi__get32be(s) == 0x38425053);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)\n{\n   int count, nleft, len;\n\n   count = 0;\n   while ((nleft = pixelCount - count) > 0) {\n      len = stbi__get8(s);\n      if (len == 128) {\n         // No-op.\n      } else if (len < 128) {\n         // Copy next len+1 bytes literally.\n         len++;\n         if (len > nleft) return 0; // corrupt data\n         count += len;\n         while (len) {\n            *p = stbi__get8(s);\n            p += 4;\n            len--;\n         }\n      } else if (len > 128) {\n         stbi_uc   val;\n         // Next -len+1 bytes in the dest are replicated from next source byte.\n         // (Interpret len as a negative 8-bit int.)\n         len = 257 - len;\n         if (len > nleft) return 0; // corrupt data\n         val = stbi__get8(s);\n         count += len;\n         while (len) {\n            *p = val;\n            p += 4;\n            len--;\n         }\n      }\n   }\n\n   return 1;\n}\n\nstatic void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   int pixelCount;\n   int channelCount, compression;\n   int channel, i;\n   int bitdepth;\n   int w,h;\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\n\n   // Check file type version.\n   if (stbi__get16be(s) != 1)\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\n\n   // Skip 6 reserved bytes.\n   stbi__skip(s, 6 );\n\n   // Read the number of channels (R, G, B, A, etc).\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16)\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\n\n   // Read the rows and columns of the image.\n   h = stbi__get32be(s);\n   w = stbi__get32be(s);\n\n   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   // Make sure the depth is 8 bits.\n   bitdepth = stbi__get16be(s);\n   if (bitdepth != 8 && bitdepth != 16)\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\n\n   // Make sure the color mode is RGB.\n   // Valid options are:\n   //   0: Bitmap\n   //   1: Grayscale\n   //   2: Indexed color\n   //   3: RGB color\n   //   4: CMYK color\n   //   7: Multichannel\n   //   8: Duotone\n   //   9: Lab color\n   if (stbi__get16be(s) != 3)\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\n\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\n   stbi__skip(s,stbi__get32be(s) );\n\n   // Skip the image resources.  (resolution, pen tool paths, etc)\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Skip the reserved data.\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Find out if the data is compressed.\n   // Known values:\n   //   0: no compression\n   //   1: RLE compressed\n   compression = stbi__get16be(s);\n   if (compression > 1)\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\n\n   // Check size\n   if (!stbi__mad3sizes_valid(4, w, h, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt PSD\");\n\n   // Create the destination image.\n\n   if (!compression && bitdepth == 16 && bpc == 16) {\n      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);\n      ri->bits_per_channel = 16;\n   } else\n      out = (stbi_uc *) stbi__malloc(4 * w*h);\n\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   pixelCount = w*h;\n\n   // Initialize the data to zero.\n   //memset( out, 0, pixelCount * 4 );\n\n   // Finally, the image data.\n   if (compression) {\n      // RLE as used by .PSD and .TIFF\n      // Loop until you get the number of unpacked bytes you are expecting:\n      //     Read the next source byte into n.\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\n      //     Else if n is 128, noop.\n      // Endloop\n\n      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,\n      // which we're going to just skip.\n      stbi__skip(s, h * channelCount * 2 );\n\n      // Read the RLE data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         stbi_uc *p;\n\n         p = out+channel;\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            for (i = 0; i < pixelCount; i++, p += 4)\n               *p = (channel == 3 ? 255 : 0);\n         } else {\n            // Read the RLE data.\n            if (!stbi__psd_decode_rle(s, p, pixelCount)) {\n               STBI_FREE(out);\n               return stbi__errpuc(\"corrupt\", \"bad RLE data\");\n            }\n         }\n      }\n\n   } else {\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\n      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\n\n      // Read the data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            if (bitdepth == 16 && bpc == 16) {\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               stbi__uint16 val = channel == 3 ? 65535 : 0;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = val;\n            } else {\n               stbi_uc *p = out+channel;\n               stbi_uc val = channel == 3 ? 255 : 0;\n               for (i = 0; i < pixelCount; i++, p += 4)\n                  *p = val;\n            }\n         } else {\n            if (ri->bits_per_channel == 16) {    // output bpc\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = (stbi__uint16) stbi__get16be(s);\n            } else {\n               stbi_uc *p = out+channel;\n               if (bitdepth == 16) {  // input bpc\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = (stbi_uc) (stbi__get16be(s) >> 8);\n               } else {\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = stbi__get8(s);\n               }\n            }\n         }\n      }\n   }\n\n   // remove weird white matte from PSD\n   if (channelCount >= 4) {\n      if (ri->bits_per_channel == 16) {\n         for (i=0; i < w*h; ++i) {\n            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 65535) {\n               float a = pixel[3] / 65535.0f;\n               float ra = 1.0f / a;\n               float inv_a = 65535.0f * (1 - ra);\n               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);\n               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);\n               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);\n            }\n         }\n      } else {\n         for (i=0; i < w*h; ++i) {\n            unsigned char *pixel = out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 255) {\n               float a = pixel[3] / 255.0f;\n               float ra = 1.0f / a;\n               float inv_a = 255.0f * (1 - ra);\n               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);\n               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);\n               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);\n            }\n         }\n      }\n   }\n\n   // convert to desired output format\n   if (req_comp && req_comp != 4) {\n      if (ri->bits_per_channel == 16)\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);\n      else\n         out = stbi__convert_format(out, 4, req_comp, w, h);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   if (comp) *comp = 4;\n   *y = h;\n   *x = w;\n\n   return out;\n}\n#endif\n\n// *************************************************************************************************\n// Softimage PIC loader\n// by Tom Seddon\n//\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\n{\n   int i;\n   for (i=0; i<4; ++i)\n      if (stbi__get8(s) != (stbi_uc)str[i])\n         return 0;\n\n   return 1;\n}\n\nstatic int stbi__pic_test_core(stbi__context *s)\n{\n   int i;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\n      return 0;\n\n   for(i=0;i<84;++i)\n      stbi__get8(s);\n\n   if (!stbi__pic_is4(s,\"PICT\"))\n      return 0;\n\n   return 1;\n}\n\ntypedef struct\n{\n   stbi_uc size,type,channel;\n} stbi__pic_packet;\n\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\n{\n   int mask=0x80, i;\n\n   for (i=0; i<4; ++i, mask>>=1) {\n      if (channel & mask) {\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\n         dest[i]=stbi__get8(s);\n      }\n   }\n\n   return dest;\n}\n\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\n{\n   int mask=0x80,i;\n\n   for (i=0;i<4; ++i, mask>>=1)\n      if (channel&mask)\n         dest[i]=src[i];\n}\n\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\n{\n   int act_comp=0,num_packets=0,y,chained;\n   stbi__pic_packet packets[10];\n\n   // this will (should...) cater for even some bizarre stuff like having data\n    // for the same channel in multiple packets.\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return stbi__errpuc(\"bad format\",\"too many packets\");\n\n      packet = &packets[num_packets++];\n\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\n\n   for(y=0; y<height; ++y) {\n      int packet_idx;\n\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\n         stbi__pic_packet *packet = &packets[packet_idx];\n         stbi_uc *dest = result+y*width*4;\n\n         switch (packet->type) {\n            default:\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\n\n            case 0: {//uncompressed\n               int x;\n\n               for(x=0;x<width;++x, dest+=4)\n                  if (!stbi__readval(s,packet->channel,dest))\n                     return 0;\n               break;\n            }\n\n            case 1://Pure RLE\n               {\n                  int left=width, i;\n\n                  while (left>0) {\n                     stbi_uc count,value[4];\n\n                     count=stbi__get8(s);\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\n\n                     if (count > left)\n                        count = (stbi_uc) left;\n\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\n\n                     for(i=0; i<count; ++i,dest+=4)\n                        stbi__copyval(packet->channel,dest,value);\n                     left -= count;\n                  }\n               }\n               break;\n\n            case 2: {//Mixed RLE\n               int left=width;\n               while (left>0) {\n                  int count = stbi__get8(s), i;\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\n\n                  if (count >= 128) { // Repeated\n                     stbi_uc value[4];\n\n                     if (count==128)\n                        count = stbi__get16be(s);\n                     else\n                        count -= 127;\n                     if (count > left)\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     if (!stbi__readval(s,packet->channel,value))\n                        return 0;\n\n                     for(i=0;i<count;++i, dest += 4)\n                        stbi__copyval(packet->channel,dest,value);\n                  } else { // Raw\n                     ++count;\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     for(i=0;i<count;++i, dest+=4)\n                        if (!stbi__readval(s,packet->channel,dest))\n                           return 0;\n                  }\n                  left-=count;\n               }\n               break;\n            }\n         }\n      }\n   }\n\n   return result;\n}\n\nstatic void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n#endif\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\n\n#ifndef STBI_NO_GIF\ntypedef struct\n{\n   stbi__int16 prefix;\n   stbi_uc first;\n   stbi_uc suffix;\n} stbi__gif_lzw;\n\ntypedef struct\n{\n   int w,h;\n   stbi_uc *out;                 // output buffer (always 4 components)\n   stbi_uc *background;          // The current \"background\" as far as a gif is concerned\n   stbi_uc *history;\n   int flags, bgindex, ratio, transparent, eflags;\n   stbi_uc  pal[256][4];\n   stbi_uc lpal[256][4];\n   stbi__gif_lzw codes[8192];\n   stbi_uc *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n   int delay;\n} stbi__gif;\n\nstatic int stbi__gif_test_raw(stbi__context *s)\n{\n   int sz;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\n   sz = stbi__get8(s);\n   if (sz != '9' && sz != '7') return 0;\n   if (stbi__get8(s) != 'a') return 0;\n   return 1;\n}\n\nstatic int stbi__gif_test(stbi__context *s)\n{\n   int r = stbi__gif_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\n{\n   int i;\n   for (i=0; i < num_entries; ++i) {\n      pal[i][2] = stbi__get8(s);\n      pal[i][1] = stbi__get8(s);\n      pal[i][0] = stbi__get8(s);\n      pal[i][3] = transp == i ? 0 : 255;\n   }\n}\n\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\n{\n   stbi_uc version;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   version = stbi__get8(s);\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\n   if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   stbi__g_failure_reason = \"\";\n   g->w = stbi__get16le(s);\n   g->h = stbi__get16le(s);\n   g->flags = stbi__get8(s);\n   g->bgindex = stbi__get8(s);\n   g->ratio = stbi__get8(s);\n   g->transparent = -1;\n\n   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\n\n   if (is_info) return 1;\n\n   if (g->flags & 0x80)\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\n\n   return 1;\n}\n\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\n   if (!g) return stbi__err(\"outofmem\", \"Out of memory\");\n   if (!stbi__gif_header(s, g, comp, 1)) {\n      STBI_FREE(g);\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = g->w;\n   if (y) *y = g->h;\n   STBI_FREE(g);\n   return 1;\n}\n\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\n{\n   stbi_uc *p, *c;\n   int idx;\n\n   // recurse to decode the prefixes, since the linked-list is backwards,\n   // and working backwards through an interleaved image would be nasty\n   if (g->codes[code].prefix >= 0)\n      stbi__out_gif_code(g, g->codes[code].prefix);\n\n   if (g->cur_y >= g->max_y) return;\n\n   idx = g->cur_x + g->cur_y;\n   p = &g->out[idx];\n   g->history[idx / 4] = 1;\n\n   c = &g->color_table[g->codes[code].suffix * 4];\n   if (c[3] > 128) { // don't render transparent pixels;\n      p[0] = c[2];\n      p[1] = c[1];\n      p[2] = c[0];\n      p[3] = c[3];\n   }\n   g->cur_x += 4;\n\n   if (g->cur_x >= g->max_x) {\n      g->cur_x = g->start_x;\n      g->cur_y += g->step;\n\n      while (g->cur_y >= g->max_y && g->parse > 0) {\n         g->step = (1 << g->parse) * g->line_size;\n         g->cur_y = g->start_y + (g->step >> 1);\n         --g->parse;\n      }\n   }\n}\n\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\n{\n   stbi_uc lzw_cs;\n   stbi__int32 len, init_code;\n   stbi__uint32 first;\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n   stbi__gif_lzw *p;\n\n   lzw_cs = stbi__get8(s);\n   if (lzw_cs > 12) return NULL;\n   clear = 1 << lzw_cs;\n   first = 1;\n   codesize = lzw_cs + 1;\n   codemask = (1 << codesize) - 1;\n   bits = 0;\n   valid_bits = 0;\n   for (init_code = 0; init_code < clear; init_code++) {\n      g->codes[init_code].prefix = -1;\n      g->codes[init_code].first = (stbi_uc) init_code;\n      g->codes[init_code].suffix = (stbi_uc) init_code;\n   }\n\n   // support no starting clear code\n   avail = clear+2;\n   oldcode = -1;\n\n   len = 0;\n   for(;;) {\n      if (valid_bits < codesize) {\n         if (len == 0) {\n            len = stbi__get8(s); // start new block\n            if (len == 0)\n               return g->out;\n         }\n         --len;\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\n         valid_bits += 8;\n      } else {\n         stbi__int32 code = bits & codemask;\n         bits >>= codesize;\n         valid_bits -= codesize;\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\n         if (code == clear) {  // clear code\n            codesize = lzw_cs + 1;\n            codemask = (1 << codesize) - 1;\n            avail = clear + 2;\n            oldcode = -1;\n            first = 0;\n         } else if (code == clear + 1) { // end of stream code\n            stbi__skip(s, len);\n            while ((len = stbi__get8(s)) > 0)\n               stbi__skip(s,len);\n            return g->out;\n         } else if (code <= avail) {\n            if (first) {\n               return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\n            }\n\n            if (oldcode >= 0) {\n               p = &g->codes[avail++];\n               if (avail > 8192) {\n                  return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\n               }\n\n               p->prefix = (stbi__int16) oldcode;\n               p->first = g->codes[oldcode].first;\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\n            } else if (code == avail)\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n\n            stbi__out_gif_code(g, (stbi__uint16) code);\n\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n               codesize++;\n               codemask = (1 << codesize) - 1;\n            }\n\n            oldcode = code;\n         } else {\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n         }\n      }\n   }\n}\n\n// this function is designed to support animated gifs, although stb_image doesn't support it\n// two back is the image from two frames ago, used for a very specific disposal format\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)\n{\n   int dispose;\n   int first_frame;\n   int pi;\n   int pcount;\n   STBI_NOTUSED(req_comp);\n\n   // on first frame, any non-written pixels get the background colour (non-transparent)\n   first_frame = 0;\n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\n      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\n         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n      pcount = g->w * g->h;\n      g->out = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->background = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->history = (stbi_uc *) stbi__malloc(pcount);\n      if (!g->out || !g->background || !g->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background;\n      // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n      // color refers to the color that was there the previous frame.\n      memset(g->out, 0x00, 4 * pcount);\n      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\n      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame\n      first_frame = 1;\n   } else {\n      // second frame - how do we dispose of the previous one?\n      dispose = (g->eflags & 0x1C) >> 2;\n      pcount = g->w * g->h;\n\n      if ((dispose == 3) && (two_back == 0)) {\n         dispose = 2; // if I don't have an image to revert back to, default to the old background\n      }\n\n      if (dispose == 3) { // use previous graphic\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );\n            }\n         }\n      } else if (dispose == 2) {\n         // restore what was changed last frame to background before that frame;\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );\n            }\n         }\n      } else {\n         // This is a non-disposal case eithe way, so just\n         // leave the pixels as is, and they will become the new background\n         // 1: do not dispose\n         // 0:  not specified.\n      }\n\n      // background is what out is after the undoing of the previou frame;\n      memcpy( g->background, g->out, 4 * g->w * g->h );\n   }\n\n   // clear my history;\n   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n\n   for (;;) {\n      int tag = stbi__get8(s);\n      switch (tag) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            // if the width of the specified rectangle is 0, that means\n            // we may not see *any* pixels or the image is malformed;\n            // to make sure this is caught, move the current y down to\n            // max_y (which is what out_gif_code checks).\n            if (w == 0)\n               g->cur_y = g->max_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;\n            } else if (g->flags & 0x80) {\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\n\n            o = stbi__process_gif_raster(s, g);\n            if (!o) return NULL;\n\n            // if this was the first frame,\n            pcount = g->w * g->h;\n            if (first_frame && (g->bgindex > 0)) {\n               // if first frame, any pixel not drawn to gets the background color\n               for (pi = 0; pi < pcount; ++pi) {\n                  if (g->history[pi] == 0) {\n                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;\n                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );\n                  }\n               }\n            }\n\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            int ext = stbi__get8(s);\n            if (ext == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\n\n                  // unset old transparent\n                  if (g->transparent >= 0) {\n                     g->pal[g->transparent][3] = 255;\n                  }\n                  if (g->eflags & 0x01) {\n                     g->transparent = stbi__get8(s);\n                     if (g->transparent >= 0) {\n                        g->pal[g->transparent][3] = 0;\n                     }\n                  } else {\n                     // don't need transparent\n                     stbi__skip(s, 1);\n                     g->transparent = -1;\n                  }\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            }\n            while ((len = stbi__get8(s)) != 0) {\n               stbi__skip(s, len);\n            }\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}\n\nstatic void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)\n{\n   STBI_FREE(g->out);\n   STBI_FREE(g->history);\n   STBI_FREE(g->background);\n\n   if (out) STBI_FREE(out);\n   if (delays && *delays) STBI_FREE(*delays);\n   return stbi__errpuc(\"outofmem\", \"Out of memory\");\n}\n\nstatic void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   if (stbi__gif_test(s)) {\n      int layers = 0;\n      stbi_uc *u = 0;\n      stbi_uc *out = 0;\n      stbi_uc *two_back = 0;\n      stbi__gif g;\n      int stride;\n      int out_size = 0;\n      int delays_size = 0;\n\n      STBI_NOTUSED(out_size);\n      STBI_NOTUSED(delays_size);\n\n      memset(&g, 0, sizeof(g));\n      if (delays) {\n         *delays = 0;\n      }\n\n      do {\n         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);\n         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n\n         if (u) {\n            *x = g.w;\n            *y = g.h;\n            ++layers;\n            stride = g.w * g.h * 4;\n\n            if (out) {\n               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );\n               if (!tmp)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               else {\n                   out = (stbi_uc*) tmp;\n                   out_size = layers * stride;\n               }\n\n               if (delays) {\n                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );\n                  if (!new_delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  *delays = new_delays;\n                  delays_size = layers * sizeof(int);\n               }\n            } else {\n               out = (stbi_uc*)stbi__malloc( layers * stride );\n               if (!out)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               out_size = layers * stride;\n               if (delays) {\n                  *delays = (int*) stbi__malloc( layers * sizeof(int) );\n                  if (!*delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  delays_size = layers * sizeof(int);\n               }\n            }\n            memcpy( out + ((layers - 1) * stride), u, stride );\n            if (layers >= 2) {\n               two_back = out - 2 * stride;\n            }\n\n            if (delays) {\n               (*delays)[layers - 1U] = g.delay;\n            }\n         }\n      } while (u != 0);\n\n      // free temp buffer;\n      STBI_FREE(g.out);\n      STBI_FREE(g.history);\n      STBI_FREE(g.background);\n\n      // do the final conversion after loading everything;\n      if (req_comp && req_comp != 4)\n         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);\n\n      *z = layers;\n      return out;\n   } else {\n      return stbi__errpuc(\"not GIF\", \"Image was not as a gif type.\");\n   }\n}\n\nstatic void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   memset(&g, 0, sizeof(g));\n   STBI_NOTUSED(ri);\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n\n      // moved conversion to after successful load so that the same\n      // can be done for multiple frames.\n      if (req_comp && req_comp != 4)\n         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n   } else if (g.out) {\n      // if there was an error and we allocated an image buffer, free it!\n      STBI_FREE(g.out);\n   }\n\n   // free buffers needed for multiple frame loading;\n   STBI_FREE(g.history);\n   STBI_FREE(g.background);\n\n   return u;\n}\n\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   return stbi__gif_info_raw(s,x,y,comp);\n}\n#endif\n\n// *************************************************************************************************\n// Radiance RGBE HDR loader\n// originally by Nicolas Schulz\n#ifndef STBI_NO_HDR\nstatic int stbi__hdr_test_core(stbi__context *s, const char *signature)\n{\n   int i;\n   for (i=0; signature[i]; ++i)\n      if (stbi__get8(s) != signature[i])\n          return 0;\n   stbi__rewind(s);\n   return 1;\n}\n\nstatic int stbi__hdr_test(stbi__context* s)\n{\n   int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\n   stbi__rewind(s);\n   if(!r) {\n       r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\n       stbi__rewind(s);\n   }\n   return r;\n}\n\n#define STBI__HDR_BUFLEN  1024\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\n{\n   int len=0;\n   char c = '\\0';\n\n   c = (char) stbi__get8(z);\n\n   while (!stbi__at_eof(z) && c != '\\n') {\n      buffer[len++] = c;\n      if (len == STBI__HDR_BUFLEN-1) {\n         // flush to end of line\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\n            ;\n         break;\n      }\n      c = (char) stbi__get8(z);\n   }\n\n   buffer[len] = 0;\n   return buffer;\n}\n\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\n{\n   if ( input[3] != 0 ) {\n      float f1;\n      // Exponent\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\n      if (req_comp <= 2)\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\n      else {\n         output[0] = input[0] * f1;\n         output[1] = input[1] * f1;\n         output[2] = input[2] * f1;\n      }\n      if (req_comp == 2) output[1] = 1;\n      if (req_comp == 4) output[3] = 1;\n   } else {\n      switch (req_comp) {\n         case 4: output[3] = 1; /* fallthrough */\n         case 3: output[0] = output[1] = output[2] = 0;\n                 break;\n         case 2: output[1] = 1; /* fallthrough */\n         case 1: output[0] = 0;\n                 break;\n      }\n   }\n}\n\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}\n\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int dummy;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (stbi__hdr_test(s) == 0) {\n       stbi__rewind( s );\n       return 0;\n   }\n\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *y = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *x = (int) strtol(token, NULL, 10);\n   *comp = 3;\n   return 1;\n}\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   void *p;\n   stbi__bmp_data info;\n\n   info.all_a = 255;\n   p = stbi__bmp_parse_header(s, &info);\n   if (p == NULL) {\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = s->img_x;\n   if (y) *y = s->img_y;\n   if (comp) {\n      if (info.bpp == 24 && info.ma == 0xff000000)\n         *comp = 3;\n      else\n         *comp = info.ma ? 4 : 3;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int channelCount, dummy, depth;\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *y = stbi__get32be(s);\n   *x = stbi__get32be(s);\n   depth = stbi__get16be(s);\n   if (depth != 8 && depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 3) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *comp = 4;\n   return 1;\n}\n\nstatic int stbi__psd_is16(stbi__context *s)\n{\n   int channelCount, depth;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   STBI_NOTUSED(stbi__get32be(s));\n   STBI_NOTUSED(stbi__get32be(s));\n   depth = stbi__get16be(s);\n   if (depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int act_comp=0,num_packets=0,chained,dummy;\n   stbi__pic_packet packets[10];\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\")) {\n      stbi__rewind(s);\n      return 0;\n   }\n\n   stbi__skip(s, 88);\n\n   *x = stbi__get16be(s);\n   *y = stbi__get16be(s);\n   if (stbi__at_eof(s)) {\n      stbi__rewind( s);\n      return 0;\n   }\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\n      stbi__rewind( s );\n      return 0;\n   }\n\n   stbi__skip(s, 8);\n\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return 0;\n\n      packet = &packets[num_packets++];\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s)) {\n          stbi__rewind( s );\n          return 0;\n      }\n      if (packet->size != 8) {\n          stbi__rewind( s );\n          return 0;\n      }\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3);\n\n   return 1;\n}\n#endif\n\n// *************************************************************************************************\n// Portable Gray Map and Portable Pixel Map loader\n// by Ken Miller\n//\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\n//\n// Known limitations:\n//    Does not support comments in the header section\n//    Does not support ASCII image data (formats P2 and P3)\n\n#ifndef STBI_NO_PNM\n\nstatic int      stbi__pnm_test(stbi__context *s)\n{\n   char p, t;\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n\nstatic void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n      STBI_FREE(out);\n      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n   }\n\n   if (req_comp && req_comp != s->img_n) {\n      if (ri->bits_per_channel == 16) {\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n      } else {\n         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      }\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}\n\nstatic int      stbi__pnm_isspace(char c)\n{\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\n}\n\nstatic void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)\n{\n   for (;;) {\n      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\n         *c = (char) stbi__get8(s);\n\n      if (stbi__at_eof(s) || *c != '#')\n         break;\n\n      while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r' )\n         *c = (char) stbi__get8(s);\n   }\n}\n\nstatic int      stbi__pnm_isdigit(char c)\n{\n   return c >= '0' && c <= '9';\n}\n\nstatic int      stbi__pnm_getinteger(stbi__context *s, char *c)\n{\n   int value = 0;\n\n   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\n      value = value*10 + (*c - '0');\n      *c = (char) stbi__get8(s);\n      if((value > 214748364) || (value == 214748364 && *c > '7'))\n          return stbi__err(\"integer parse overflow\", \"Parsing an integer in the PPM header overflowed a 32-bit int\");\n   }\n\n   return value;\n}\n\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int maxv, dummy;\n   char c, p, t;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   stbi__rewind(s);\n\n   // Get identifier\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind(s);\n       return 0;\n   }\n\n   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\n\n   c = (char) stbi__get8(s);\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *x = stbi__pnm_getinteger(s, &c); // read width\n   if(*x == 0)\n       return stbi__err(\"invalid width\", \"PPM image header had zero or overflowing width\");\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *y = stbi__pnm_getinteger(s, &c); // read height\n   if (*y == 0)\n       return stbi__err(\"invalid width\", \"PPM image header had zero or overflowing width\");\n   stbi__pnm_skip_whitespace(s, &c);\n\n   maxv = stbi__pnm_getinteger(s, &c);  // read max value\n   if (maxv > 65535)\n      return stbi__err(\"max value > 65535\", \"PPM image supports only 8-bit and 16-bit images\");\n   else if (maxv > 255)\n      return 16;\n   else\n      return 8;\n}\n\nstatic int stbi__pnm_is16(stbi__context *s)\n{\n   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)\n\t   return 1;\n   return 0;\n}\n#endif\n\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\n{\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_info(s, x, y, comp)) return 1;\n   #endif\n\n   #ifndef STBI_NO_PNG\n   if (stbi__png_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_info(s, x, y, comp))  return 1;\n   #endif\n\n   // test tga last because it's a crappy test!\n   #ifndef STBI_NO_TGA\n   if (stbi__tga_info(s, x, y, comp))\n       return 1;\n   #endif\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic int stbi__is_16_main(stbi__context *s)\n{\n   #ifndef STBI_NO_PNG\n   if (stbi__png_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_is16(s))  return 1;\n   #endif\n   return 0;\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_info_from_file(f, x, y, comp);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__info_main(&s,x,y,comp);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n\nSTBIDEF int stbi_is_16_bit(char const *filename)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_is_16_bit_from_file(f);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_is_16_bit_from_file(FILE *f)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__is_16_main(&s);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__is_16_main(&s);\n}\n\nSTBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__is_16_main(&s);\n}\n\n#endif // STB_IMAGE_IMPLEMENTATION\n\n/*\n   revision history:\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug\n                         1-bit BMP\n                         *_is_16_bit api\n                         avoid warnings\n      2.16  (2017-07-23) all functions have 16-bit variants;\n                         STBI_NO_STDIO works again;\n                         compilation fixes;\n                         fix rounding in unpremultiply;\n                         optimize vertical flip;\n                         disable raw_len validation;\n                         documentation fixes\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\n                         warning fixes; disable run-time SSE detection on gcc;\n                         uniform handling of optional \"return\" values;\n                         thread-safe initialization of zlib tables\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) allocate large structures on the stack\n                         remove white matting for transparent PSD\n                         fix reported channel count for PNG & BMP\n                         re-enable SSE2 in non-gcc 64-bit\n                         support RGB-formatted JPEG\n                         read 16-bit PNGs (only as 8-bit)\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\n      2.09  (2016-01-16) allow comments in PNM files\n                         16-bit-per-pixel TGA (not bit-per-component)\n                         info() for TGA could break due to .hdr handling\n                         info() for BMP to shares code instead of sloppy parse\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\n                         code cleanup\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\n      2.07  (2015-09-13) fix compiler warnings\n                         partial animated GIF support\n                         limited 16-bpc PSD support\n                         #ifdef unused functions\n                         bug with < 92 byte PIC,PNM,HDR,TGA\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\n                         stbi_set_flip_vertically_on_load (nguillemot)\n                         fix NEON support; fix mingw support\n      2.02  (2015-01-19) fix incorrect assert, fix warning\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\n                         progressive JPEG (stb)\n                         PGM/PPM support (Ken Miller)\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\n                         GIF bugfix -- seemingly never worked\n                         STBI_NO_*, STBI_ONLY_*\n      1.48  (2014-12-14) fix incorrectly-named assert()\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\n                         optimize PNG (ryg)\n                         fix bug in interlaced PNG with user-specified channel count (stb)\n      1.46  (2014-08-26)\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\n      1.45  (2014-08-16)\n              fix MSVC-ARM internal compiler error by wrapping malloc\n      1.44  (2014-08-07)\n              various warning fixes from Ronny Chevalier\n      1.43  (2014-07-15)\n              fix MSVC-only compiler problem in code changed in 1.42\n      1.42  (2014-07-09)\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\n              fixes to stbi__cleanup_jpeg path\n              added STBI_ASSERT to avoid requiring assert.h\n      1.41  (2014-06-25)\n              fix search&replace from 1.36 that messed up comments/error messages\n      1.40  (2014-06-22)\n              fix gcc struct-initialization warning\n      1.39  (2014-06-15)\n              fix to TGA optimization when req_comp != number of components in TGA;\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\n              add support for BMP version 5 (more ignored fields)\n      1.38  (2014-06-06)\n              suppress MSVC warnings on integer casts truncating values\n              fix accidental rename of 'skip' field of I/O\n      1.37  (2014-06-04)\n              remove duplicate typedef\n      1.36  (2014-06-03)\n              convert to header file single-file library\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\n      1.35  (2014-05-27)\n              various warnings\n              fix broken STBI_SIMD path\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\n              fix broken non-easy path for 32-bit BMP (possibly never used)\n              TGA optimization by Arseny Kapoulkine\n      1.34  (unknown)\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\n      1.33  (2011-07-14)\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\n      1.32  (2011-07-13)\n              support for \"info\" function for all supported filetypes (SpartanJ)\n      1.31  (2011-06-20)\n              a few more leak fixes, bug in PNG handling (SpartanJ)\n      1.30  (2011-06-11)\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\n              removed deprecated format-specific test/load functions\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\n              fix inefficiency in decoding 32-bit BMP (David Woo)\n      1.29  (2010-08-16)\n              various warning fixes from Aurelien Pocheville\n      1.28  (2010-08-01)\n              fix bug in GIF palette transparency (SpartanJ)\n      1.27  (2010-08-01)\n              cast-to-stbi_uc to fix warnings\n      1.26  (2010-07-24)\n              fix bug in file buffering for PNG reported by SpartanJ\n      1.25  (2010-07-17)\n              refix trans_data warning (Won Chun)\n      1.24  (2010-07-12)\n              perf improvements reading from files on platforms with lock-heavy fgetc()\n              minor perf improvements for jpeg\n              deprecated type-specific functions so we'll get feedback if they're needed\n              attempt to fix trans_data warning (Won Chun)\n      1.23    fixed bug in iPhone support\n      1.22  (2010-07-10)\n              removed image *writing* support\n              stbi_info support from Jetro Lauha\n              GIF support from Jean-Marc Lienher\n              iPhone PNG-extensions from James Brown\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\n      1.20    added support for Softimage PIC, by Tom Seddon\n      1.19    bug in interlaced PNG corruption check (found by ryg)\n      1.18  (2008-08-02)\n              fix a threading bug (local mutable static)\n      1.17    support interlaced PNG\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\n      1.15    initialize some fields for thread safety\n      1.14    fix threadsafe conversion bug\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\n      1.13    threadsafe\n      1.12    const qualifiers in the API\n      1.11    Support installable IDCT, colorspace conversion routines\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\n              optimized upsampling by Fabian \"ryg\" Giesen\n      1.09    Fix format-conversion for PSD code (bad global variables!)\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\n      1.07    attempt to fix C++ warning/errors again\n      1.06    attempt to fix C++ warning/errors again\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\n      1.00    interface to zlib that skips zlib header\n      0.99    correct handling of alpha in palette\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\n      0.97    jpeg errors on too large a file; also catch another malloc failure\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\n      0.95    during header scan, seek to markers in case of padding\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\n      0.93    handle jpegtran output; verbose errors\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\n      0.91    output 24-bit Windows 3.0 BMP files\n      0.90    fix a few more warnings; bump version number to approach 1.0\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\n      0.60    fix compiling as c++\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\n      0.55    fix bug: restart_interval not initialized to 0\n      0.54    allow NULL for 'int *comp'\n      0.53    fix bug in png 3->4; speedup png decoding\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\n              on 'test' only check type, not whether we support this variant\n      0.50  (2006-11-19)\n              first released version\n*/\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_image_resize2.h",
          "type": "blob",
          "size": 440.5322265625,
          "content": "/* stb_image_resize2 - v2.12 - public domain image resizing\n\n   by Jeff Roberts (v2) and Jorge L Rodriguez\n   http://github.com/nothings/stb\n\n   Can be threaded with the extended API. SSE2, AVX, Neon and WASM SIMD support. Only\n   scaling and translation is supported, no rotations or shears.\n\n   COMPILING & LINKING\n      In one C/C++ file that #includes this file, do this:\n         #define STB_IMAGE_RESIZE_IMPLEMENTATION\n      before the #include. That will create the implementation in that file.\n\n   EASY API CALLS:\n     Easy API downsamples w/Mitchell filter, upsamples w/cubic interpolation, clamps to edge.\n\n     stbir_resize_uint8_srgb( input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                              output_pixels, output_w, output_h, output_stride_in_bytes,\n                              pixel_layout_enum )\n\n     stbir_resize_uint8_linear( input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                                output_pixels, output_w, output_h, output_stride_in_bytes,\n                                pixel_layout_enum )\n\n     stbir_resize_float_linear( input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                                output_pixels, output_w, output_h, output_stride_in_bytes,\n                                pixel_layout_enum )\n\n     If you pass NULL or zero for the output_pixels, we will allocate the output buffer\n     for you and return it from the function (free with free() or STBIR_FREE).\n     As a special case, XX_stride_in_bytes of 0 means packed continuously in memory.\n\n   API LEVELS\n      There are three levels of API - easy-to-use, medium-complexity and extended-complexity.\n\n      See the \"header file\" section of the source for API documentation.\n\n   ADDITIONAL DOCUMENTATION\n\n      MEMORY ALLOCATION\n         By default, we use malloc and free for memory allocation.  To override the\n         memory allocation, before the implementation #include, add a:\n\n            #define STBIR_MALLOC(size,user_data) ...\n            #define STBIR_FREE(ptr,user_data)   ...\n\n         Each resize makes exactly one call to malloc/free (unless you use the\n         extended API where you can do one allocation for many resizes). Under\n         address sanitizer, we do separate allocations to find overread/writes.\n\n      PERFORMANCE\n         This library was written with an emphasis on performance. When testing\n         stb_image_resize with RGBA, the fastest mode is STBIR_4CHANNEL with\n         STBIR_TYPE_UINT8 pixels and CLAMPed edges (which is what many other resize\n         libs do by default). Also, make sure SIMD is turned on of course (default\n         for 64-bit targets). Avoid WRAP edge mode if you want the fastest speed.\n\n         This library also comes with profiling built-in. If you define STBIR_PROFILE,\n         you can use the advanced API and get low-level profiling information by\n         calling stbir_resize_extended_profile_info() or stbir_resize_split_profile_info()\n         after a resize.\n\n      SIMD\n         Most of the routines have optimized SSE2, AVX, NEON and WASM versions.\n\n         On Microsoft compilers, we automatically turn on SIMD for 64-bit x64 and\n         ARM; for 32-bit x86 and ARM, you select SIMD mode by defining STBIR_SSE2 or\n         STBIR_NEON. For AVX and AVX2, we auto-select it by detecting the /arch:AVX\n         or /arch:AVX2 switches. You can also always manually turn SSE2, AVX or AVX2\n         support on by defining STBIR_SSE2, STBIR_AVX or STBIR_AVX2.\n\n         On Linux, SSE2 and Neon is on by default for 64-bit x64 or ARM64. For 32-bit,\n         we select x86 SIMD mode by whether you have -msse2, -mavx or -mavx2 enabled\n         on the command line. For 32-bit ARM, you must pass -mfpu=neon-vfpv4 for both\n         clang and GCC, but GCC also requires an additional -mfp16-format=ieee to\n         automatically enable NEON.\n\n         On x86 platforms, you can also define STBIR_FP16C to turn on FP16C instructions\n         for converting back and forth to half-floats. This is autoselected when we\n         are using AVX2. Clang and GCC also require the -mf16c switch. ARM always uses\n         the built-in half float hardware NEON instructions.\n\n         You can also tell us to use multiply-add instructions with STBIR_USE_FMA.\n         Because x86 doesn't always have fma, we turn it off by default to maintain\n         determinism across all platforms. If you don't care about non-FMA determinism\n         and are willing to restrict yourself to more recent x86 CPUs (around the AVX\n         timeframe), then fma will give you around a 15% speedup.\n\n         You can force off SIMD in all cases by defining STBIR_NO_SIMD. You can turn\n         off AVX or AVX2 specifically with STBIR_NO_AVX or STBIR_NO_AVX2. AVX is 10%\n         to 40% faster, and AVX2 is generally another 12%.\n\n      ALPHA CHANNEL\n         Most of the resizing functions provide the ability to control how the alpha\n         channel of an image is processed.\n\n         When alpha represents transparency, it is important that when combining\n         colors with filtering, the pixels should not be treated equally; they\n         should use a weighted average based on their alpha values. For example,\n         if a pixel is 1% opaque bright green and another pixel is 99% opaque\n         black and you average them, the average will be 50% opaque, but the\n         unweighted average and will be a middling green color, while the weighted\n         average will be nearly black. This means the unweighted version introduced\n         green energy that didn't exist in the source image.\n\n         (If you want to know why this makes sense, you can work out the math for\n         the following: consider what happens if you alpha composite a source image\n         over a fixed color and then average the output, vs. if you average the\n         source image pixels and then composite that over the same fixed color.\n         Only the weighted average produces the same result as the ground truth\n         composite-then-average result.)\n\n         Therefore, it is in general best to \"alpha weight\" the pixels when applying\n         filters to them. This essentially means multiplying the colors by the alpha\n         values before combining them, and then dividing by the alpha value at the\n         end.\n\n         The computer graphics industry introduced a technique called \"premultiplied\n         alpha\" or \"associated alpha\" in which image colors are stored in image files\n         already multiplied by their alpha. This saves some math when compositing,\n         and also avoids the need to divide by the alpha at the end (which is quite\n         inefficient). However, while premultiplied alpha is common in the movie CGI\n         industry, it is not commonplace in other industries like videogames, and most\n         consumer file formats are generally expected to contain not-premultiplied\n         colors. For example, Photoshop saves PNG files \"unpremultiplied\", and web\n         browsers like Chrome and Firefox expect PNG images to be unpremultiplied.\n\n         Note that there are three possibilities that might describe your image\n         and resize expectation:\n\n             1. images are not premultiplied, alpha weighting is desired\n             2. images are not premultiplied, alpha weighting is not desired\n             3. images are premultiplied\n\n         Both case #2 and case #3 require the exact same math: no alpha weighting\n         should be applied or removed. Only case 1 requires extra math operations;\n         the other two cases can be handled identically.\n\n         stb_image_resize expects case #1 by default, applying alpha weighting to\n         images, expecting the input images to be unpremultiplied. This is what the\n         COLOR+ALPHA buffer types tell the resizer to do.\n\n         When you use the pixel layouts STBIR_RGBA, STBIR_BGRA, STBIR_ARGB,\n         STBIR_ABGR, STBIR_RX, or STBIR_XR you are telling us that the pixels are\n         non-premultiplied. In these cases, the resizer will alpha weight the colors\n         (effectively creating the premultiplied image), do the filtering, and then\n         convert back to non-premult on exit.\n\n         When you use the pixel layouts STBIR_RGBA_PM, STBIR_RGBA_PM, STBIR_RGBA_PM,\n         STBIR_RGBA_PM, STBIR_RX_PM or STBIR_XR_PM, you are telling that the pixels\n         ARE premultiplied. In this case, the resizer doesn't have to do the\n         premultipling - it can filter directly on the input. This about twice as\n         fast as the non-premultiplied case, so it's the right option if your data is\n         already setup correctly.\n\n         When you use the pixel layout STBIR_4CHANNEL or STBIR_2CHANNEL, you are\n         telling us that there is no channel that represents transparency; it may be\n         RGB and some unrelated fourth channel that has been stored in the alpha\n         channel, but it is actually not alpha. No special processing will be\n         performed.\n\n         The difference between the generic 4 or 2 channel layouts, and the\n         specialized _PM versions is with the _PM versions you are telling us that\n         the data *is* alpha, just don't premultiply it. That's important when\n         using SRGB pixel formats, we need to know where the alpha is, because\n         it is converted linearly (rather than with the SRGB converters).\n\n         Because alpha weighting produces the same effect as premultiplying, you\n         even have the option with non-premultiplied inputs to let the resizer\n         produce a premultiplied output. Because the intially computed alpha-weighted\n         output image is effectively premultiplied, this is actually more performant\n         than the normal path which un-premultiplies the output image as a final step.\n\n         Finally, when converting both in and out of non-premulitplied space (for\n         example, when using STBIR_RGBA), we go to somewhat heroic measures to\n         ensure that areas with zero alpha value pixels get something reasonable\n         in the RGB values. If you don't care about the RGB values of zero alpha\n         pixels, you can call the stbir_set_non_pm_alpha_speed_over_quality()\n         function - this runs a premultiplied resize about 25% faster. That said,\n         when you really care about speed, using premultiplied pixels for both in\n         and out (STBIR_RGBA_PM, etc) much faster than both of these premultiplied\n         options.\n\n      PIXEL LAYOUT CONVERSION\n         The resizer can convert from some pixel layouts to others. When using the\n         stbir_set_pixel_layouts(), you can, for example, specify STBIR_RGBA\n         on input, and STBIR_ARGB on output, and it will re-organize the channels\n         during the resize. Currently, you can only convert between two pixel\n         layouts with the same number of channels.\n\n      DETERMINISM\n         We commit to being deterministic (from x64 to ARM to scalar to SIMD, etc).\n         This requires compiling with fast-math off (using at least /fp:precise).\n         Also, you must turn off fp-contracting (which turns mult+adds into fmas)!\n         We attempt to do this with pragmas, but with Clang, you usually want to add\n         -ffp-contract=off to the command line as well.\n\n         For 32-bit x86, you must use SSE and SSE2 codegen for determinism. That is,\n         if the scalar x87 unit gets used at all, we immediately lose determinism.\n         On Microsoft Visual Studio 2008 and earlier, from what we can tell there is\n         no way to be deterministic in 32-bit x86 (some x87 always leaks in, even\n         with fp:strict). On 32-bit x86 GCC, determinism requires both -msse2 and\n         -fpmath=sse.\n\n         Note that we will not be deterministic with float data containing NaNs -\n         the NaNs will propagate differently on different SIMD and platforms.\n\n         If you turn on STBIR_USE_FMA, then we will be deterministic with other\n         fma targets, but we will differ from non-fma targets (this is unavoidable,\n         because a fma isn't simply an add with a mult - it also introduces a\n         rounding difference compared to non-fma instruction sequences.\n\n      FLOAT PIXEL FORMAT RANGE\n         Any range of values can be used for the non-alpha float data that you pass\n         in (0 to 1, -1 to 1, whatever). However, if you are inputting float values\n         but *outputting* bytes or shorts, you must use a range of 0 to 1 so that we\n         scale back properly. The alpha channel must also be 0 to 1 for any format\n         that does premultiplication prior to resizing.\n\n         Note also that with float output, using filters with negative lobes, the\n         output filtered values might go slightly out of range. You can define\n         STBIR_FLOAT_LOW_CLAMP and/or STBIR_FLOAT_HIGH_CLAMP to specify the range\n         to clamp to on output, if that's important.\n\n      MAX/MIN SCALE FACTORS\n         The input pixel resolutions are in integers, and we do the internal pointer\n         resolution in size_t sized integers. However, the scale ratio from input\n         resolution to output resolution is calculated in float form. This means\n         the effective possible scale ratio is limited to 24 bits (or 16 million\n         to 1). As you get close to the size of the float resolution (again, 16\n         million pixels wide or high), you might start seeing float inaccuracy\n         issues in general in the pipeline. If you have to do extreme resizes,\n         you can usually do this is multiple stages (using float intermediate\n         buffers).\n\n      FLIPPED IMAGES\n         Stride is just the delta from one scanline to the next. This means you can\n         use a negative stride to handle inverted images (point to the final\n         scanline and use a negative stride). You can invert the input or output,\n         using negative strides.\n\n      DEFAULT FILTERS\n         For functions which don't provide explicit control over what filters to\n         use, you can change the compile-time defaults with:\n\n            #define STBIR_DEFAULT_FILTER_UPSAMPLE     STBIR_FILTER_something\n            #define STBIR_DEFAULT_FILTER_DOWNSAMPLE   STBIR_FILTER_something\n\n         See stbir_filter in the header-file section for the list of filters.\n\n      NEW FILTERS\n         A number of 1D filter kernels are supplied. For a list of supported\n         filters, see the stbir_filter enum. You can install your own filters by\n         using the stbir_set_filter_callbacks function.\n\n      PROGRESS\n         For interactive use with slow resize operations, you can use the the\n         scanline callbacks in the extended API. It would have to be a *very* large\n         image resample to need progress though - we're very fast.\n\n      CEIL and FLOOR\n         In scalar mode, the only functions we use from math.h are ceilf and floorf,\n         but if you have your own versions, you can define the STBIR_CEILF(v) and\n         STBIR_FLOORF(v) macros and we'll use them instead. In SIMD, we just use\n         our own versions.\n\n      ASSERT\n         Define STBIR_ASSERT(boolval) to override assert() and not use assert.h\n\n     PORTING FROM VERSION 1\n        The API has changed. You can continue to use the old version of stb_image_resize.h,\n        which is available in the \"deprecated/\" directory.\n\n        If you're using the old simple-to-use API, porting is straightforward.\n        (For more advanced APIs, read the documentation.)\n\n          stbir_resize_uint8():\n            - call `stbir_resize_uint8_linear`, cast channel count to `stbir_pixel_layout`\n\n          stbir_resize_float():\n            - call `stbir_resize_float_linear`, cast channel count to `stbir_pixel_layout`\n\n          stbir_resize_uint8_srgb():\n            - function name is unchanged\n            - cast channel count to `stbir_pixel_layout`\n            - above is sufficient unless your image has alpha and it's not RGBA/BGRA\n              - in that case, follow the below instructions for stbir_resize_uint8_srgb_edgemode\n\n          stbir_resize_uint8_srgb_edgemode()\n            - switch to the \"medium complexity\" API\n            - stbir_resize(), very similar API but a few more parameters:\n              - pixel_layout: cast channel count to `stbir_pixel_layout`\n              - data_type:    STBIR_TYPE_UINT8_SRGB\n              - edge:         unchanged (STBIR_EDGE_WRAP, etc.)\n              - filter:       STBIR_FILTER_DEFAULT\n            - which channel is alpha is specified in stbir_pixel_layout, see enum for details\n\n      FUTURE TODOS\n        *  For polyphase integral filters, we just memcpy the coeffs to dupe\n           them, but we should indirect and use the same coeff memory.\n        *  Add pixel layout conversions for sensible different channel counts\n           (maybe, 1->3/4, 3->4, 4->1, 3->1).\n         * For SIMD encode and decode scanline routines, do any pre-aligning\n           for bad input/output buffer alignments and pitch?\n         * For very wide scanlines, we should we do vertical strips to stay within\n           L2 cache. Maybe do chunks of 1K pixels at a time. There would be\n           some pixel reconversion, but probably dwarfed by things falling out\n           of cache. Probably also something possible with alternating between\n           scattering and gathering at high resize scales?\n         * Rewrite the coefficient generator to do many at once.\n         * AVX-512 vertical kernels - worried about downclocking here.\n         * Convert the reincludes to macros when we know they aren't changing.\n         * Experiment with pivoting the horizontal and always using the\n           vertical filters (which are faster, but perhaps not enough to overcome\n           the pivot cost and the extra memory touches). Need to buffer the whole\n           image so have to balance memory use.\n         * Most of our code is internally function pointers, should we compile\n           all the SIMD stuff always and dynamically dispatch?\n\n   CONTRIBUTORS\n      Jeff Roberts: 2.0 implementation, optimizations, SIMD\n      Martins Mozeiko: NEON simd, WASM simd, clang and GCC whisperer\n      Fabian Giesen: half float and srgb converters\n      Sean Barrett: API design, optimizations\n      Jorge L Rodriguez: Original 1.0 implementation\n      Aras Pranckevicius: bugfixes\n      Nathan Reed: warning fixes for 1.0\n\n   REVISIONS\n      2.12 (2024-10-18) fix incorrect use of user_data with STBIR_FREE\n      2.11 (2024-09-08) fix harmless asan warnings in 2-channel and 3-channel mode\n                          with AVX-2, fix some weird scaling edge conditions with\n                          point sample mode.\n      2.10 (2024-07-27) fix the defines GCC and mingw for loop unroll control,\n                          fix MSVC 32-bit arm half float routines.\n      2.09 (2024-06-19) fix the defines for 32-bit ARM GCC builds (was selecting\n                          hardware half floats).\n      2.08 (2024-06-10) fix for RGB->BGR three channel flips and add SIMD (thanks\n                          to Ryan Salsbury), fix for sub-rect resizes, use the\n                          pragmas to control unrolling when they are available.\n      2.07 (2024-05-24) fix for slow final split during threaded conversions of very \n                          wide scanlines when downsampling (caused by extra input \n                          converting), fix for wide scanline resamples with many \n                          splits (int overflow), fix GCC warning.\n      2.06 (2024-02-10) fix for identical width/height 3x or more down-scaling \n                          undersampling a single row on rare resize ratios (about 1%).\n      2.05 (2024-02-07) fix for 2 pixel to 1 pixel resizes with wrap (thanks Aras),\n                        fix for output callback (thanks Julien Koenen).\n      2.04 (2023-11-17) fix for rare AVX bug, shadowed symbol (thanks Nikola Smiljanic).\n      2.03 (2023-11-01) ASAN and TSAN warnings fixed, minor tweaks.\n      2.00 (2023-10-10) mostly new source: new api, optimizations, simd, vertical-first, etc\n                          2x-5x faster without simd, 4x-12x faster with simd,\n                          in some cases, 20x to 40x faster esp resizing large to very small.\n      0.96 (2019-03-04) fixed warnings\n      0.95 (2017-07-23) fixed warnings\n      0.94 (2017-03-18) fixed warnings\n      0.93 (2017-03-03) fixed bug with certain combinations of heights\n      0.92 (2017-01-02) fix integer overflow on large (>2GB) images\n      0.91 (2016-04-02) fix warnings; fix handling of subpixel regions\n      0.90 (2014-09-17) first released version\n\n   LICENSE\n     See end of file for license information.\n*/\n\n#if !defined(STB_IMAGE_RESIZE_DO_HORIZONTALS) && !defined(STB_IMAGE_RESIZE_DO_VERTICALS) && !defined(STB_IMAGE_RESIZE_DO_CODERS)   // for internal re-includes\n\n#ifndef STBIR_INCLUDE_STB_IMAGE_RESIZE2_H\n#define STBIR_INCLUDE_STB_IMAGE_RESIZE2_H\n\n#include <stddef.h>\n#ifdef _MSC_VER\ntypedef unsigned char    stbir_uint8;\ntypedef unsigned short   stbir_uint16;\ntypedef unsigned int     stbir_uint32;\ntypedef unsigned __int64 stbir_uint64;\n#else\n#include <stdint.h>\ntypedef uint8_t  stbir_uint8;\ntypedef uint16_t stbir_uint16;\ntypedef uint32_t stbir_uint32;\ntypedef uint64_t stbir_uint64;\n#endif\n\n#ifdef _M_IX86_FP\n#if ( _M_IX86_FP >= 1 )\n#ifndef STBIR_SSE\n#define STBIR_SSE\n#endif\n#endif\n#endif\n\n#if defined(_x86_64) || defined( __x86_64__ ) || defined( _M_X64 ) || defined(__x86_64) || defined(_M_AMD64) || defined(__SSE2__) || defined(STBIR_SSE) || defined(STBIR_SSE2)\n  #ifndef STBIR_SSE2\n    #define STBIR_SSE2\n  #endif\n  #if defined(__AVX__) || defined(STBIR_AVX2)\n    #ifndef STBIR_AVX\n      #ifndef STBIR_NO_AVX\n        #define STBIR_AVX\n      #endif\n    #endif\n  #endif\n  #if defined(__AVX2__) || defined(STBIR_AVX2)\n    #ifndef STBIR_NO_AVX2\n      #ifndef STBIR_AVX2\n        #define STBIR_AVX2\n      #endif\n      #if defined( _MSC_VER ) && !defined(__clang__)\n        #ifndef STBIR_FP16C  // FP16C instructions are on all AVX2 cpus, so we can autoselect it here on microsoft - clang needs -m16c\n          #define STBIR_FP16C\n        #endif\n      #endif\n    #endif\n  #endif\n  #ifdef __F16C__\n    #ifndef STBIR_FP16C  // turn on FP16C instructions if the define is set (for clang and gcc)\n      #define STBIR_FP16C\n    #endif\n  #endif\n#endif\n\n#if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) || ((__ARM_NEON_FP & 4) != 0) || defined(__ARM_NEON__)\n#ifndef STBIR_NEON\n#define STBIR_NEON\n#endif\n#endif\n\n#if defined(_M_ARM) || defined(__arm__)\n#ifdef STBIR_USE_FMA\n#undef STBIR_USE_FMA // no FMA for 32-bit arm on MSVC\n#endif\n#endif\n\n#if defined(__wasm__) && defined(__wasm_simd128__)\n#ifndef STBIR_WASM\n#define STBIR_WASM\n#endif\n#endif\n\n#ifndef STBIRDEF\n#ifdef STB_IMAGE_RESIZE_STATIC\n#define STBIRDEF static\n#else\n#ifdef __cplusplus\n#define STBIRDEF extern \"C\"\n#else\n#define STBIRDEF extern\n#endif\n#endif\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n////   start \"header file\" ///////////////////////////////////////////////////\n//\n// Easy-to-use API:\n//\n//     * stride is the offset between successive rows of image data\n//        in memory, in bytes. specify 0 for packed continuously in memory\n//     * colorspace is linear or sRGB as specified by function name\n//     * Uses the default filters\n//     * Uses edge mode clamped\n//     * returned result is 1 for success or 0 in case of an error.\n\n\n// stbir_pixel_layout specifies:\n//   number of channels\n//   order of channels\n//   whether color is premultiplied by alpha\n// for back compatibility, you can cast the old channel count to an stbir_pixel_layout\ntypedef enum\n{\n  STBIR_1CHANNEL = 1,\n  STBIR_2CHANNEL = 2,\n  STBIR_RGB      = 3,               // 3-chan, with order specified (for channel flipping)\n  STBIR_BGR      = 0,               // 3-chan, with order specified (for channel flipping)\n  STBIR_4CHANNEL = 5,\n\n  STBIR_RGBA = 4,                   // alpha formats, where alpha is NOT premultiplied into color channels\n  STBIR_BGRA = 6,\n  STBIR_ARGB = 7,\n  STBIR_ABGR = 8,\n  STBIR_RA   = 9,\n  STBIR_AR   = 10,\n\n  STBIR_RGBA_PM = 11,               // alpha formats, where alpha is premultiplied into color channels\n  STBIR_BGRA_PM = 12,\n  STBIR_ARGB_PM = 13,\n  STBIR_ABGR_PM = 14,\n  STBIR_RA_PM   = 15,\n  STBIR_AR_PM   = 16,\n\n  STBIR_RGBA_NO_AW = 11,            // alpha formats, where NO alpha weighting is applied at all!\n  STBIR_BGRA_NO_AW = 12,            //   these are just synonyms for the _PM flags (which also do\n  STBIR_ARGB_NO_AW = 13,            //   no alpha weighting). These names just make it more clear\n  STBIR_ABGR_NO_AW = 14,            //   for some folks).\n  STBIR_RA_NO_AW   = 15,\n  STBIR_AR_NO_AW   = 16,\n\n} stbir_pixel_layout;\n\n//===============================================================\n//  Simple-complexity API\n//\n//    If output_pixels is NULL (0), then we will allocate the buffer and return it to you.\n//--------------------------------\n\nSTBIRDEF unsigned char * stbir_resize_uint8_srgb( const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                        unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                        stbir_pixel_layout pixel_type );\n\nSTBIRDEF unsigned char * stbir_resize_uint8_linear( const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                          unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                          stbir_pixel_layout pixel_type );\n\nSTBIRDEF float * stbir_resize_float_linear( const float *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                  float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                  stbir_pixel_layout pixel_type );\n//===============================================================\n\n//===============================================================\n// Medium-complexity API\n//\n// This extends the easy-to-use API as follows:\n//\n//     * Can specify the datatype - U8, U8_SRGB, U16, FLOAT, HALF_FLOAT\n//     * Edge wrap can selected explicitly\n//     * Filter can be selected explicitly\n//--------------------------------\n\ntypedef enum\n{\n  STBIR_EDGE_CLAMP   = 0,\n  STBIR_EDGE_REFLECT = 1,\n  STBIR_EDGE_WRAP    = 2,  // this edge mode is slower and uses more memory\n  STBIR_EDGE_ZERO    = 3,\n} stbir_edge;\n\ntypedef enum\n{\n  STBIR_FILTER_DEFAULT      = 0,  // use same filter type that easy-to-use API chooses\n  STBIR_FILTER_BOX          = 1,  // A trapezoid w/1-pixel wide ramps, same result as box for integer scale ratios\n  STBIR_FILTER_TRIANGLE     = 2,  // On upsampling, produces same results as bilinear texture filtering\n  STBIR_FILTER_CUBICBSPLINE = 3,  // The cubic b-spline (aka Mitchell-Netrevalli with B=1,C=0), gaussian-esque\n  STBIR_FILTER_CATMULLROM   = 4,  // An interpolating cubic spline\n  STBIR_FILTER_MITCHELL     = 5,  // Mitchell-Netrevalli filter with B=1/3, C=1/3\n  STBIR_FILTER_POINT_SAMPLE = 6,  // Simple point sampling\n  STBIR_FILTER_OTHER        = 7,  // User callback specified\n} stbir_filter;\n\ntypedef enum\n{\n  STBIR_TYPE_UINT8            = 0,\n  STBIR_TYPE_UINT8_SRGB       = 1,\n  STBIR_TYPE_UINT8_SRGB_ALPHA = 2,  // alpha channel, when present, should also be SRGB (this is very unusual)\n  STBIR_TYPE_UINT16           = 3,\n  STBIR_TYPE_FLOAT            = 4,\n  STBIR_TYPE_HALF_FLOAT       = 5\n} stbir_datatype;\n\n// medium api\nSTBIRDEF void *  stbir_resize( const void *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                     void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                               stbir_pixel_layout pixel_layout, stbir_datatype data_type,\n                               stbir_edge edge, stbir_filter filter );\n//===============================================================\n\n\n\n//===============================================================\n// Extended-complexity API\n//\n// This API exposes all resize functionality.\n//\n//     * Separate filter types for each axis\n//     * Separate edge modes for each axis\n//     * Separate input and output data types\n//     * Can specify regions with subpixel correctness\n//     * Can specify alpha flags\n//     * Can specify a memory callback\n//     * Can specify a callback data type for pixel input and output\n//     * Can be threaded for a single resize\n//     * Can be used to resize many frames without recalculating the sampler info\n//\n//  Use this API as follows:\n//     1) Call the stbir_resize_init function on a local STBIR_RESIZE structure\n//     2) Call any of the stbir_set functions\n//     3) Optionally call stbir_build_samplers() if you are going to resample multiple times\n//        with the same input and output dimensions (like resizing video frames)\n//     4) Resample by calling stbir_resize_extended().\n//     5) Call stbir_free_samplers() if you called stbir_build_samplers()\n//--------------------------------\n\n\n// Types:\n\n// INPUT CALLBACK: this callback is used for input scanlines\ntypedef void const * stbir_input_callback( void * optional_output, void const * input_ptr, int num_pixels, int x, int y, void * context );\n\n// OUTPUT CALLBACK: this callback is used for output scanlines\ntypedef void stbir_output_callback( void const * output_ptr, int num_pixels, int y, void * context );\n\n// callbacks for user installed filters\ntypedef float stbir__kernel_callback( float x, float scale, void * user_data ); // centered at zero\ntypedef float stbir__support_callback( float scale, void * user_data );\n\n// internal structure with precomputed scaling\ntypedef struct stbir__info stbir__info;\n\ntypedef struct STBIR_RESIZE  // use the stbir_resize_init and stbir_override functions to set these values for future compatibility\n{\n  void * user_data;\n  void const * input_pixels;\n  int input_w, input_h;\n  double input_s0, input_t0, input_s1, input_t1;\n  stbir_input_callback * input_cb;\n  void * output_pixels;\n  int output_w, output_h;\n  int output_subx, output_suby, output_subw, output_subh;\n  stbir_output_callback * output_cb;\n  int input_stride_in_bytes;\n  int output_stride_in_bytes;\n  int splits;\n  int fast_alpha;\n  int needs_rebuild;\n  int called_alloc;\n  stbir_pixel_layout input_pixel_layout_public;\n  stbir_pixel_layout output_pixel_layout_public;\n  stbir_datatype input_data_type;\n  stbir_datatype output_data_type;\n  stbir_filter horizontal_filter, vertical_filter;\n  stbir_edge horizontal_edge, vertical_edge;\n  stbir__kernel_callback * horizontal_filter_kernel; stbir__support_callback * horizontal_filter_support;\n  stbir__kernel_callback * vertical_filter_kernel; stbir__support_callback * vertical_filter_support;\n  stbir__info * samplers;\n} STBIR_RESIZE;\n\n// extended complexity api\n\n\n// First off, you must ALWAYS call stbir_resize_init on your resize structure before any of the other calls!\nSTBIRDEF void stbir_resize_init( STBIR_RESIZE * resize,\n                                 const void *input_pixels,  int input_w,  int input_h, int input_stride_in_bytes, // stride can be zero\n                                       void *output_pixels, int output_w, int output_h, int output_stride_in_bytes, // stride can be zero\n                                 stbir_pixel_layout pixel_layout, stbir_datatype data_type );\n\n//===============================================================\n// You can update these parameters any time after resize_init and there is no cost\n//--------------------------------\n\nSTBIRDEF void stbir_set_datatypes( STBIR_RESIZE * resize, stbir_datatype input_type, stbir_datatype output_type );\nSTBIRDEF void stbir_set_pixel_callbacks( STBIR_RESIZE * resize, stbir_input_callback * input_cb, stbir_output_callback * output_cb );   // no callbacks by default\nSTBIRDEF void stbir_set_user_data( STBIR_RESIZE * resize, void * user_data );                                               // pass back STBIR_RESIZE* by default\nSTBIRDEF void stbir_set_buffer_ptrs( STBIR_RESIZE * resize, const void * input_pixels, int input_stride_in_bytes, void * output_pixels, int output_stride_in_bytes );\n\n//===============================================================\n\n\n//===============================================================\n// If you call any of these functions, you will trigger a sampler rebuild!\n//--------------------------------\n\nSTBIRDEF int stbir_set_pixel_layouts( STBIR_RESIZE * resize, stbir_pixel_layout input_pixel_layout, stbir_pixel_layout output_pixel_layout );  // sets new buffer layouts\nSTBIRDEF int stbir_set_edgemodes( STBIR_RESIZE * resize, stbir_edge horizontal_edge, stbir_edge vertical_edge );       // CLAMP by default\n\nSTBIRDEF int stbir_set_filters( STBIR_RESIZE * resize, stbir_filter horizontal_filter, stbir_filter vertical_filter ); // STBIR_DEFAULT_FILTER_UPSAMPLE/DOWNSAMPLE by default\nSTBIRDEF int stbir_set_filter_callbacks( STBIR_RESIZE * resize, stbir__kernel_callback * horizontal_filter, stbir__support_callback * horizontal_support, stbir__kernel_callback * vertical_filter, stbir__support_callback * vertical_support );\n\nSTBIRDEF int stbir_set_pixel_subrect( STBIR_RESIZE * resize, int subx, int suby, int subw, int subh );        // sets both sub-regions (full regions by default)\nSTBIRDEF int stbir_set_input_subrect( STBIR_RESIZE * resize, double s0, double t0, double s1, double t1 );    // sets input sub-region (full region by default)\nSTBIRDEF int stbir_set_output_pixel_subrect( STBIR_RESIZE * resize, int subx, int suby, int subw, int subh ); // sets output sub-region (full region by default)\n\n// when inputting AND outputting non-premultiplied alpha pixels, we use a slower but higher quality technique\n//   that fills the zero alpha pixel's RGB values with something plausible.  If you don't care about areas of\n//   zero alpha, you can call this function to get about a 25% speed improvement for STBIR_RGBA to STBIR_RGBA\n//   types of resizes.\nSTBIRDEF int stbir_set_non_pm_alpha_speed_over_quality( STBIR_RESIZE * resize, int non_pma_alpha_speed_over_quality );\n//===============================================================\n\n\n//===============================================================\n// You can call build_samplers to prebuild all the internal data we need to resample.\n//   Then, if you call resize_extended many times with the same resize, you only pay the\n//   cost once.\n// If you do call build_samplers, you MUST call free_samplers eventually.\n//--------------------------------\n\n// This builds the samplers and does one allocation\nSTBIRDEF int stbir_build_samplers( STBIR_RESIZE * resize );\n\n// You MUST call this, if you call stbir_build_samplers or stbir_build_samplers_with_splits\nSTBIRDEF void stbir_free_samplers( STBIR_RESIZE * resize );\n//===============================================================\n\n\n// And this is the main function to perform the resize synchronously on one thread.\nSTBIRDEF int stbir_resize_extended( STBIR_RESIZE * resize );\n\n\n//===============================================================\n// Use these functions for multithreading.\n//   1) You call stbir_build_samplers_with_splits first on the main thread\n//   2) Then stbir_resize_with_split on each thread\n//   3) stbir_free_samplers when done on the main thread\n//--------------------------------\n\n// This will build samplers for threading.\n//   You can pass in the number of threads you'd like to use (try_splits).\n//   It returns the number of splits (threads) that you can call it with.\n///  It might be less if the image resize can't be split up that many ways.\n\nSTBIRDEF int stbir_build_samplers_with_splits( STBIR_RESIZE * resize, int try_splits );\n\n// This function does a split of the resizing (you call this fuction for each\n// split, on multiple threads). A split is a piece of the output resize pixel space.\n\n// Note that you MUST call stbir_build_samplers_with_splits before stbir_resize_extended_split!\n\n// Usually, you will always call stbir_resize_split with split_start as the thread_index\n//   and \"1\" for the split_count.\n// But, if you have a weird situation where you MIGHT want 8 threads, but sometimes\n//   only 4 threads, you can use 0,2,4,6 for the split_start's and use \"2\" for the\n//   split_count each time to turn in into a 4 thread resize. (This is unusual).\n\nSTBIRDEF int stbir_resize_extended_split( STBIR_RESIZE * resize, int split_start, int split_count );\n//===============================================================\n\n\n//===============================================================\n// Pixel Callbacks info:\n//--------------------------------\n\n//   The input callback is super flexible - it calls you with the input address\n//   (based on the stride and base pointer), it gives you an optional_output\n//   pointer that you can fill, or you can just return your own pointer into\n//   your own data.\n//\n//   You can also do conversion from non-supported data types if necessary - in\n//   this case, you ignore the input_ptr and just use the x and y parameters to\n//   calculate your own input_ptr based on the size of each non-supported pixel.\n//   (Something like the third example below.)\n//\n//   You can also install just an input or just an output callback by setting the\n//   callback that you don't want to zero.\n//\n//     First example, progress: (getting a callback that you can monitor the progress):\n//        void const * my_callback( void * optional_output, void const * input_ptr, int num_pixels, int x, int y, void * context )\n//        {\n//           percentage_done = y / input_height;\n//           return input_ptr;  // use buffer from call\n//        }\n//\n//     Next example, copying: (copy from some other buffer or stream):\n//        void const * my_callback( void * optional_output, void const * input_ptr, int num_pixels, int x, int y, void * context )\n//        {\n//           CopyOrStreamData( optional_output, other_data_src, num_pixels * pixel_width_in_bytes );\n//           return optional_output;  // return the optional buffer that we filled\n//        }\n//\n//     Third example, input another buffer without copying: (zero-copy from other buffer):\n//        void const * my_callback( void * optional_output, void const * input_ptr, int num_pixels, int x, int y, void * context )\n//        {\n//           void * pixels = ( (char*) other_image_base ) + ( y * other_image_stride ) + ( x * other_pixel_width_in_bytes );\n//           return pixels;       // return pointer to your data without copying\n//        }\n//\n//\n//   The output callback is considerably simpler - it just calls you so that you can dump\n//   out each scanline. You could even directly copy out to disk if you have a simple format\n//   like TGA or BMP. You can also convert to other output types here if you want.\n//\n//   Simple example:\n//        void const * my_output( void * output_ptr, int num_pixels, int y, void * context )\n//        {\n//           percentage_done = y / output_height;\n//           fwrite( output_ptr, pixel_width_in_bytes, num_pixels, output_file );\n//        }\n//===============================================================\n\n\n\n\n//===============================================================\n// optional built-in profiling API\n//--------------------------------\n\n#ifdef STBIR_PROFILE\n\ntypedef struct STBIR_PROFILE_INFO\n{\n  stbir_uint64 total_clocks;\n\n  // how many clocks spent (of total_clocks) in the various resize routines, along with a string description\n  //    there are \"resize_count\" number of zones\n  stbir_uint64 clocks[ 8 ];\n  char const ** descriptions;\n\n  // count of clocks and descriptions\n  stbir_uint32 count;\n} STBIR_PROFILE_INFO;\n\n// use after calling stbir_resize_extended (or stbir_build_samplers or stbir_build_samplers_with_splits)\nSTBIRDEF void stbir_resize_build_profile_info( STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize );\n\n// use after calling stbir_resize_extended\nSTBIRDEF void stbir_resize_extended_profile_info( STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize );\n\n// use after calling stbir_resize_extended_split\nSTBIRDEF void stbir_resize_split_profile_info( STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize, int split_start, int split_num );\n\n//===============================================================\n\n#endif\n\n\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBIR_INCLUDE_STB_IMAGE_RESIZE2_H\n\n#if defined(STB_IMAGE_RESIZE_IMPLEMENTATION) || defined(STB_IMAGE_RESIZE2_IMPLEMENTATION)\n\n#ifndef STBIR_ASSERT\n#include <assert.h>\n#define STBIR_ASSERT(x) assert(x)\n#endif\n\n#ifndef STBIR_MALLOC\n#include <stdlib.h>\n#define STBIR_MALLOC(size,user_data) ((void)(user_data), malloc(size))\n#define STBIR_FREE(ptr,user_data)    ((void)(user_data), free(ptr))\n// (we used the comma operator to evaluate user_data, to avoid \"unused parameter\" warnings)\n#endif\n\n#ifdef _MSC_VER\n\n#define stbir__inline __forceinline\n\n#else\n\n#define stbir__inline __inline__\n\n// Clang address sanitizer\n#if defined(__has_feature)\n  #if __has_feature(address_sanitizer) || __has_feature(memory_sanitizer)\n    #ifndef STBIR__SEPARATE_ALLOCATIONS\n      #define STBIR__SEPARATE_ALLOCATIONS\n    #endif\n  #endif\n#endif\n\n#endif\n\n// GCC and MSVC\n#if defined(__SANITIZE_ADDRESS__)\n  #ifndef STBIR__SEPARATE_ALLOCATIONS\n    #define STBIR__SEPARATE_ALLOCATIONS\n  #endif\n#endif\n\n// Always turn off automatic FMA use - use STBIR_USE_FMA if you want.\n// Otherwise, this is a determinism disaster.\n#ifndef STBIR_DONT_CHANGE_FP_CONTRACT  // override in case you don't want this behavior\n#if defined(_MSC_VER) && !defined(__clang__)\n#if _MSC_VER > 1200\n#pragma fp_contract(off)\n#endif\n#elif defined(__GNUC__) &&  !defined(__clang__)\n#pragma GCC optimize(\"fp-contract=off\")\n#else\n#pragma STDC FP_CONTRACT OFF\n#endif\n#endif\n\n#ifdef _MSC_VER\n#define STBIR__UNUSED(v)  (void)(v)\n#else\n#define STBIR__UNUSED(v)  (void)sizeof(v)\n#endif\n\n#define STBIR__ARRAY_SIZE(a) (sizeof((a))/sizeof((a)[0]))\n\n\n#ifndef STBIR_DEFAULT_FILTER_UPSAMPLE\n#define STBIR_DEFAULT_FILTER_UPSAMPLE    STBIR_FILTER_CATMULLROM\n#endif\n\n#ifndef STBIR_DEFAULT_FILTER_DOWNSAMPLE\n#define STBIR_DEFAULT_FILTER_DOWNSAMPLE  STBIR_FILTER_MITCHELL\n#endif\n\n\n#ifndef STBIR__HEADER_FILENAME\n#define STBIR__HEADER_FILENAME \"stb_image_resize2.h\"\n#endif\n\n// the internal pixel layout enums are in a different order, so we can easily do range comparisons of types\n//   the public pixel layout is ordered in a way that if you cast num_channels (1-4) to the enum, you get something sensible\ntypedef enum\n{\n  STBIRI_1CHANNEL = 0,\n  STBIRI_2CHANNEL = 1,\n  STBIRI_RGB      = 2,\n  STBIRI_BGR      = 3,\n  STBIRI_4CHANNEL = 4,\n\n  STBIRI_RGBA = 5,\n  STBIRI_BGRA = 6,\n  STBIRI_ARGB = 7,\n  STBIRI_ABGR = 8,\n  STBIRI_RA   = 9,\n  STBIRI_AR   = 10,\n\n  STBIRI_RGBA_PM = 11,\n  STBIRI_BGRA_PM = 12,\n  STBIRI_ARGB_PM = 13,\n  STBIRI_ABGR_PM = 14,\n  STBIRI_RA_PM   = 15,\n  STBIRI_AR_PM   = 16,\n} stbir_internal_pixel_layout;\n\n// define the public pixel layouts to not compile inside the implementation (to avoid accidental use)\n#define STBIR_BGR bad_dont_use_in_implementation\n#define STBIR_1CHANNEL STBIR_BGR\n#define STBIR_2CHANNEL STBIR_BGR\n#define STBIR_RGB STBIR_BGR\n#define STBIR_RGBA STBIR_BGR\n#define STBIR_4CHANNEL STBIR_BGR\n#define STBIR_BGRA STBIR_BGR\n#define STBIR_ARGB STBIR_BGR\n#define STBIR_ABGR STBIR_BGR\n#define STBIR_RA STBIR_BGR\n#define STBIR_AR STBIR_BGR\n#define STBIR_RGBA_PM STBIR_BGR\n#define STBIR_BGRA_PM STBIR_BGR\n#define STBIR_ARGB_PM STBIR_BGR\n#define STBIR_ABGR_PM STBIR_BGR\n#define STBIR_RA_PM STBIR_BGR\n#define STBIR_AR_PM STBIR_BGR\n\n// must match stbir_datatype\nstatic unsigned char stbir__type_size[] = {\n  1,1,1,2,4,2 // STBIR_TYPE_UINT8,STBIR_TYPE_UINT8_SRGB,STBIR_TYPE_UINT8_SRGB_ALPHA,STBIR_TYPE_UINT16,STBIR_TYPE_FLOAT,STBIR_TYPE_HALF_FLOAT\n};\n\n// When gathering, the contributors are which source pixels contribute.\n// When scattering, the contributors are which destination pixels are contributed to.\ntypedef struct\n{\n  int n0; // First contributing pixel\n  int n1; // Last contributing pixel\n} stbir__contributors;\n\ntypedef struct\n{\n  int lowest;    // First sample index for whole filter\n  int highest;   // Last sample index for whole filter\n  int widest;    // widest single set of samples for an output\n} stbir__filter_extent_info;\n\ntypedef struct\n{\n  int n0; // First pixel of decode buffer to write to\n  int n1; // Last pixel of decode that will be written to\n  int pixel_offset_for_input;  // Pixel offset into input_scanline\n} stbir__span;\n\ntypedef struct stbir__scale_info\n{\n  int input_full_size;\n  int output_sub_size;\n  float scale;\n  float inv_scale;\n  float pixel_shift; // starting shift in output pixel space (in pixels)\n  int scale_is_rational;\n  stbir_uint32 scale_numerator, scale_denominator;\n} stbir__scale_info;\n\ntypedef struct\n{\n  stbir__contributors * contributors;\n  float* coefficients;\n  stbir__contributors * gather_prescatter_contributors;\n  float * gather_prescatter_coefficients;\n  stbir__scale_info scale_info;\n  float support;\n  stbir_filter filter_enum;\n  stbir__kernel_callback * filter_kernel;\n  stbir__support_callback * filter_support;\n  stbir_edge edge;\n  int coefficient_width;\n  int filter_pixel_width;\n  int filter_pixel_margin;\n  int num_contributors;\n  int contributors_size;\n  int coefficients_size;\n  stbir__filter_extent_info extent_info;\n  int is_gather;  // 0 = scatter, 1 = gather with scale >= 1, 2 = gather with scale < 1\n  int gather_prescatter_num_contributors;\n  int gather_prescatter_coefficient_width;\n  int gather_prescatter_contributors_size;\n  int gather_prescatter_coefficients_size;\n} stbir__sampler;\n\ntypedef struct\n{\n  stbir__contributors conservative;\n  int edge_sizes[2];    // this can be less than filter_pixel_margin, if the filter and scaling falls off\n  stbir__span spans[2]; // can be two spans, if doing input subrect with clamp mode WRAP\n} stbir__extents;\n\ntypedef struct\n{\n#ifdef STBIR_PROFILE\n  union\n  {\n    struct { stbir_uint64 total, looping, vertical, horizontal, decode, encode, alpha, unalpha; } named;\n    stbir_uint64 array[8];\n  } profile;\n  stbir_uint64 * current_zone_excluded_ptr;\n#endif\n  float* decode_buffer;\n\n  int ring_buffer_first_scanline;\n  int ring_buffer_last_scanline;\n  int ring_buffer_begin_index;    // first_scanline is at this index in the ring buffer\n  int start_output_y, end_output_y;\n  int start_input_y, end_input_y;  // used in scatter only\n\n  #ifdef STBIR__SEPARATE_ALLOCATIONS\n    float** ring_buffers; // one pointer for each ring buffer\n  #else\n    float* ring_buffer;  // one big buffer that we index into\n  #endif\n\n  float* vertical_buffer;\n\n  char no_cache_straddle[64];\n} stbir__per_split_info;\n\ntypedef void stbir__decode_pixels_func( float * decode, int width_times_channels, void const * input );\ntypedef void stbir__alpha_weight_func( float * decode_buffer, int width_times_channels );\ntypedef void stbir__horizontal_gather_channels_func( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer,\n  stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width );\ntypedef void stbir__alpha_unweight_func(float * encode_buffer, int width_times_channels );\ntypedef void stbir__encode_pixels_func( void * output, int width_times_channels, float const * encode );\n\nstruct stbir__info\n{\n#ifdef STBIR_PROFILE\n  union\n  {\n    struct { stbir_uint64 total, build, alloc, horizontal, vertical, cleanup, pivot; } named;\n    stbir_uint64 array[7];\n  } profile;\n  stbir_uint64 * current_zone_excluded_ptr;\n#endif\n  stbir__sampler horizontal;\n  stbir__sampler vertical;\n\n  void const * input_data;\n  void * output_data;\n\n  int input_stride_bytes;\n  int output_stride_bytes;\n  int ring_buffer_length_bytes;   // The length of an individual entry in the ring buffer. The total number of ring buffers is stbir__get_filter_pixel_width(filter)\n  int ring_buffer_num_entries;    // Total number of entries in the ring buffer.\n\n  stbir_datatype input_type;\n  stbir_datatype output_type;\n\n  stbir_input_callback * in_pixels_cb;\n  void * user_data;\n  stbir_output_callback * out_pixels_cb;\n\n  stbir__extents scanline_extents;\n\n  void * alloced_mem;\n  stbir__per_split_info * split_info;  // by default 1, but there will be N of these allocated based on the thread init you did\n\n  stbir__decode_pixels_func * decode_pixels;\n  stbir__alpha_weight_func * alpha_weight;\n  stbir__horizontal_gather_channels_func * horizontal_gather_channels;\n  stbir__alpha_unweight_func * alpha_unweight;\n  stbir__encode_pixels_func * encode_pixels;\n\n  int alloc_ring_buffer_num_entries;    // Number of entries in the ring buffer that will be allocated\n  int splits; // count of splits\n\n  stbir_internal_pixel_layout input_pixel_layout_internal;\n  stbir_internal_pixel_layout output_pixel_layout_internal;\n\n  int input_color_and_type;\n  int offset_x, offset_y; // offset within output_data\n  int vertical_first;\n  int channels;\n  int effective_channels; // same as channels, except on RGBA/ARGB (7), or XA/AX (3)\n  size_t alloced_total;\n};\n\n\n#define stbir__max_uint8_as_float             255.0f\n#define stbir__max_uint16_as_float            65535.0f\n#define stbir__max_uint8_as_float_inverted    (1.0f/255.0f)\n#define stbir__max_uint16_as_float_inverted   (1.0f/65535.0f)\n#define stbir__small_float ((float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20))\n\n// min/max friendly\n#define STBIR_CLAMP(x, xmin, xmax) for(;;) { \\\n  if ( (x) < (xmin) ) (x) = (xmin);     \\\n  if ( (x) > (xmax) ) (x) = (xmax);     \\\n  break;                                \\\n}\n\nstatic stbir__inline int stbir__min(int a, int b)\n{\n  return a < b ? a : b;\n}\n\nstatic stbir__inline int stbir__max(int a, int b)\n{\n  return a > b ? a : b;\n}\n\nstatic float stbir__srgb_uchar_to_linear_float[256] = {\n  0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f,\n  0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f,\n  0.008023f, 0.008568f, 0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f,\n  0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f,\n  0.025187f, 0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f,\n  0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f, 0.051269f, 0.052861f,\n  0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f,\n  0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,\n  0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f, 0.116971f, 0.119538f, 0.122139f,\n  0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f,\n  0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f,\n  0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f,\n  0.230740f, 0.234551f, 0.238398f, 0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f,\n  0.274677f, 0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f,\n  0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f,\n  0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,\n  0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f, 0.485150f, 0.491021f,\n  0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f,\n  0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f, 0.630757f,\n  0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f,\n  0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f,\n  0.799103f, 0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f,\n  0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f,\n  0.982251f, 0.991102f, 1.0f\n};\n\ntypedef union\n{\n  unsigned int u;\n  float f;\n} stbir__FP32;\n\n// From https://gist.github.com/rygorous/2203834\n\nstatic const stbir_uint32 fp32_to_srgb8_tab4[104] = {\n  0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,\n  0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,\n  0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,\n  0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,\n  0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,\n  0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,\n  0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,\n  0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,\n  0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,\n  0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,\n  0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,\n  0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,\n  0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723,\n};\n\nstatic stbir__inline stbir_uint8 stbir__linear_to_srgb_uchar(float in)\n{\n  static const stbir__FP32 almostone = { 0x3f7fffff }; // 1-eps\n  static const stbir__FP32 minval = { (127-13) << 23 };\n  stbir_uint32 tab,bias,scale,t;\n  stbir__FP32 f;\n\n  // Clamp to [2^(-13), 1-eps]; these two values map to 0 and 1, respectively.\n  // The tests are carefully written so that NaNs map to 0, same as in the reference\n  // implementation.\n  if (!(in > minval.f)) // written this way to catch NaNs\n      return 0;\n  if (in > almostone.f)\n      return 255;\n\n  // Do the table lookup and unpack bias, scale\n  f.f = in;\n  tab = fp32_to_srgb8_tab4[(f.u - minval.u) >> 20];\n  bias = (tab >> 16) << 9;\n  scale = tab & 0xffff;\n\n  // Grab next-highest mantissa bits and perform linear interpolation\n  t = (f.u >> 12) & 0xff;\n  return (unsigned char) ((bias + scale*t) >> 16);\n}\n\n#ifndef STBIR_FORCE_GATHER_FILTER_SCANLINES_AMOUNT\n#define STBIR_FORCE_GATHER_FILTER_SCANLINES_AMOUNT 32 // when downsampling and <= 32 scanlines of buffering, use gather. gather used down to 1/8th scaling for 25% win.\n#endif\n\n#ifndef STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS\n#define STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS 4 // when threading, what is the minimum number of scanlines for a split?\n#endif\n\n// restrict pointers for the output pointers, other loop and unroll control\n#if defined( _MSC_VER ) && !defined(__clang__)\n  #define STBIR_STREAMOUT_PTR( star ) star __restrict\n  #define STBIR_NO_UNROLL( ptr ) __assume(ptr) // this oddly keeps msvc from unrolling a loop\n  #if _MSC_VER >= 1900\n    #define STBIR_NO_UNROLL_LOOP_START __pragma(loop( no_vector )) \n  #else\n    #define STBIR_NO_UNROLL_LOOP_START \n  #endif\n#elif defined( __clang__ )\n  #define STBIR_STREAMOUT_PTR( star ) star __restrict__\n  #define STBIR_NO_UNROLL( ptr ) __asm__ (\"\"::\"r\"(ptr)) \n  #if ( __clang_major__ >= 4 ) || ( ( __clang_major__ >= 3 ) && ( __clang_minor__ >= 5 ) )\n    #define STBIR_NO_UNROLL_LOOP_START _Pragma(\"clang loop unroll(disable)\") _Pragma(\"clang loop vectorize(disable)\")\n  #else\n    #define STBIR_NO_UNROLL_LOOP_START\n  #endif \n#elif defined( __GNUC__ )\n  #define STBIR_STREAMOUT_PTR( star ) star __restrict__\n  #define STBIR_NO_UNROLL( ptr ) __asm__ (\"\"::\"r\"(ptr))\n  #if __GNUC__ >= 14\n    #define STBIR_NO_UNROLL_LOOP_START _Pragma(\"GCC unroll 0\") _Pragma(\"GCC novector\")\n  #else\n    #define STBIR_NO_UNROLL_LOOP_START\n  #endif\n  #define STBIR_NO_UNROLL_LOOP_START_INF_FOR\n#else\n  #define STBIR_STREAMOUT_PTR( star ) star\n  #define STBIR_NO_UNROLL( ptr )\n  #define STBIR_NO_UNROLL_LOOP_START\n#endif\n\n#ifndef STBIR_NO_UNROLL_LOOP_START_INF_FOR\n#define STBIR_NO_UNROLL_LOOP_START_INF_FOR STBIR_NO_UNROLL_LOOP_START\n#endif\n\n#ifdef STBIR_NO_SIMD // force simd off for whatever reason\n\n// force simd off overrides everything else, so clear it all\n\n#ifdef STBIR_SSE2\n#undef STBIR_SSE2\n#endif\n\n#ifdef STBIR_AVX\n#undef STBIR_AVX\n#endif\n\n#ifdef STBIR_NEON\n#undef STBIR_NEON\n#endif\n\n#ifdef STBIR_AVX2\n#undef STBIR_AVX2\n#endif\n\n#ifdef STBIR_FP16C\n#undef STBIR_FP16C\n#endif\n\n#ifdef STBIR_WASM\n#undef STBIR_WASM\n#endif\n\n#ifdef STBIR_SIMD\n#undef STBIR_SIMD\n#endif\n\n#else // STBIR_SIMD\n\n#ifdef STBIR_SSE2\n  #include <emmintrin.h>\n\n  #define stbir__simdf __m128\n  #define stbir__simdi __m128i\n\n  #define stbir_simdi_castf( reg ) _mm_castps_si128(reg)\n  #define stbir_simdf_casti( reg ) _mm_castsi128_ps(reg)\n\n  #define stbir__simdf_load( reg, ptr ) (reg) = _mm_loadu_ps( (float const*)(ptr) )\n  #define stbir__simdi_load( reg, ptr ) (reg) = _mm_loadu_si128 ( (stbir__simdi const*)(ptr) )\n  #define stbir__simdf_load1( out, ptr ) (out) = _mm_load_ss( (float const*)(ptr) )  // top values can be random (not denormal or nan for perf)\n  #define stbir__simdi_load1( out, ptr ) (out) = _mm_castps_si128( _mm_load_ss( (float const*)(ptr) ))\n  #define stbir__simdf_load1z( out, ptr ) (out) = _mm_load_ss( (float const*)(ptr) )  // top values must be zero\n  #define stbir__simdf_frep4( fvar ) _mm_set_ps1( fvar )\n  #define stbir__simdf_load1frep4( out, fvar ) (out) = _mm_set_ps1( fvar )\n  #define stbir__simdf_load2( out, ptr ) (out) = _mm_castsi128_ps( _mm_loadl_epi64( (__m128i*)(ptr)) ) // top values can be random (not denormal or nan for perf)\n  #define stbir__simdf_load2z( out, ptr ) (out) = _mm_castsi128_ps( _mm_loadl_epi64( (__m128i*)(ptr)) ) // top values must be zero\n  #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = _mm_castpd_ps(_mm_loadh_pd( _mm_castps_pd(reg), (double*)(ptr) ))\n\n  #define stbir__simdf_zeroP() _mm_setzero_ps()\n  #define stbir__simdf_zero( reg ) (reg) = _mm_setzero_ps()\n\n  #define stbir__simdf_store( ptr, reg )  _mm_storeu_ps( (float*)(ptr), reg )\n  #define stbir__simdf_store1( ptr, reg ) _mm_store_ss( (float*)(ptr), reg )\n  #define stbir__simdf_store2( ptr, reg ) _mm_storel_epi64( (__m128i*)(ptr), _mm_castps_si128(reg) )\n  #define stbir__simdf_store2h( ptr, reg ) _mm_storeh_pd( (double*)(ptr), _mm_castps_pd(reg) )\n\n  #define stbir__simdi_store( ptr, reg )  _mm_storeu_si128( (__m128i*)(ptr), reg )\n  #define stbir__simdi_store1( ptr, reg ) _mm_store_ss( (float*)(ptr), _mm_castsi128_ps(reg) )\n  #define stbir__simdi_store2( ptr, reg ) _mm_storel_epi64( (__m128i*)(ptr), (reg) )\n\n  #define stbir__prefetch( ptr ) _mm_prefetch((char*)(ptr), _MM_HINT_T0 )\n\n  #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg) \\\n  { \\\n    stbir__simdi zero = _mm_setzero_si128(); \\\n    out2 = _mm_unpacklo_epi8( ireg, zero ); \\\n    out3 = _mm_unpackhi_epi8( ireg, zero ); \\\n    out0 = _mm_unpacklo_epi16( out2, zero ); \\\n    out1 = _mm_unpackhi_epi16( out2, zero ); \\\n    out2 = _mm_unpacklo_epi16( out3, zero ); \\\n    out3 = _mm_unpackhi_epi16( out3, zero ); \\\n  }\n\n#define stbir__simdi_expand_u8_to_1u32(out,ireg) \\\n  { \\\n    stbir__simdi zero = _mm_setzero_si128(); \\\n    out = _mm_unpacklo_epi8( ireg, zero ); \\\n    out = _mm_unpacklo_epi16( out, zero ); \\\n  }\n\n  #define stbir__simdi_expand_u16_to_u32(out0,out1,ireg) \\\n  { \\\n    stbir__simdi zero = _mm_setzero_si128(); \\\n    out0 = _mm_unpacklo_epi16( ireg, zero ); \\\n    out1 = _mm_unpackhi_epi16( ireg, zero ); \\\n  }\n\n  #define stbir__simdf_convert_float_to_i32( i, f ) (i) = _mm_cvttps_epi32(f)\n  #define stbir__simdf_convert_float_to_int( f ) _mm_cvtt_ss2si(f)\n  #define stbir__simdf_convert_float_to_uint8( f ) ((unsigned char)_mm_cvtsi128_si32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(f,STBIR__CONSTF(STBIR_max_uint8_as_float)),_mm_setzero_ps()))))\n  #define stbir__simdf_convert_float_to_short( f ) ((unsigned short)_mm_cvtsi128_si32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(f,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps()))))\n\n  #define stbir__simdi_to_int( i ) _mm_cvtsi128_si32(i)\n  #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = _mm_cvtepi32_ps( ireg )\n  #define stbir__simdf_add( out, reg0, reg1 ) (out) = _mm_add_ps( reg0, reg1 )\n  #define stbir__simdf_mult( out, reg0, reg1 ) (out) = _mm_mul_ps( reg0, reg1 )\n  #define stbir__simdf_mult_mem( out, reg, ptr ) (out) = _mm_mul_ps( reg, _mm_loadu_ps( (float const*)(ptr) ) )\n  #define stbir__simdf_mult1_mem( out, reg, ptr ) (out) = _mm_mul_ss( reg, _mm_load_ss( (float const*)(ptr) ) )\n  #define stbir__simdf_add_mem( out, reg, ptr ) (out) = _mm_add_ps( reg, _mm_loadu_ps( (float const*)(ptr) ) )\n  #define stbir__simdf_add1_mem( out, reg, ptr ) (out) = _mm_add_ss( reg, _mm_load_ss( (float const*)(ptr) ) )\n\n  #ifdef STBIR_USE_FMA           // not on by default to maintain bit identical simd to non-simd\n  #include <immintrin.h>\n  #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = _mm_fmadd_ps( mul1, mul2, add )\n  #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = _mm_fmadd_ss( mul1, mul2, add )\n  #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = _mm_fmadd_ps( mul, _mm_loadu_ps( (float const*)(ptr) ), add )\n  #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = _mm_fmadd_ss( mul, _mm_load_ss( (float const*)(ptr) ), add )\n  #else\n  #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = _mm_add_ps( add, _mm_mul_ps( mul1, mul2 ) )\n  #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = _mm_add_ss( add, _mm_mul_ss( mul1, mul2 ) )\n  #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = _mm_add_ps( add, _mm_mul_ps( mul, _mm_loadu_ps( (float const*)(ptr) ) ) )\n  #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = _mm_add_ss( add, _mm_mul_ss( mul, _mm_load_ss( (float const*)(ptr) ) ) )\n  #endif\n\n  #define stbir__simdf_add1( out, reg0, reg1 ) (out) = _mm_add_ss( reg0, reg1 )\n  #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = _mm_mul_ss( reg0, reg1 )\n\n  #define stbir__simdf_and( out, reg0, reg1 ) (out) = _mm_and_ps( reg0, reg1 )\n  #define stbir__simdf_or( out, reg0, reg1 ) (out) = _mm_or_ps( reg0, reg1 )\n\n  #define stbir__simdf_min( out, reg0, reg1 ) (out) = _mm_min_ps( reg0, reg1 )\n  #define stbir__simdf_max( out, reg0, reg1 ) (out) = _mm_max_ps( reg0, reg1 )\n  #define stbir__simdf_min1( out, reg0, reg1 ) (out) = _mm_min_ss( reg0, reg1 )\n  #define stbir__simdf_max1( out, reg0, reg1 ) (out) = _mm_max_ss( reg0, reg1 )\n\n  #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_shuffle_ps( reg1,reg0, (0<<0) + (1<<2) + (2<<4) + (3<<6) )), (3<<0) + (0<<2) + (1<<4) + (2<<6) ) )\n  #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_shuffle_ps( reg1,reg0, (0<<0) + (1<<2) + (2<<4) + (3<<6) )), (2<<0) + (3<<2) + (0<<4) + (1<<6) ) )\n\n  static const stbir__simdf STBIR_zeroones = { 0.0f,1.0f,0.0f,1.0f };\n  static const stbir__simdf STBIR_onezeros = { 1.0f,0.0f,1.0f,0.0f };\n  #define stbir__simdf_aaa1( out, alp, ones ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_movehl_ps( ones, alp ) ), (1<<0) + (1<<2) + (1<<4) + (2<<6) ) )\n  #define stbir__simdf_1aaa( out, alp, ones ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_movelh_ps( ones, alp ) ), (0<<0) + (2<<2) + (2<<4) + (2<<6) ) )\n  #define stbir__simdf_a1a1( out, alp, ones) (out) = _mm_or_ps( _mm_castsi128_ps( _mm_srli_epi64( _mm_castps_si128(alp), 32 ) ), STBIR_zeroones )\n  #define stbir__simdf_1a1a( out, alp, ones) (out) = _mm_or_ps( _mm_castsi128_ps( _mm_slli_epi64( _mm_castps_si128(alp), 32 ) ), STBIR_onezeros )\n\n  #define stbir__simdf_swiz( reg, one, two, three, four ) _mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( reg ), (one<<0) + (two<<2) + (three<<4) + (four<<6) ) )\n\n  #define stbir__simdi_and( out, reg0, reg1 ) (out) = _mm_and_si128( reg0, reg1 )\n  #define stbir__simdi_or( out, reg0, reg1 ) (out) = _mm_or_si128( reg0, reg1 )\n  #define stbir__simdi_16madd( out, reg0, reg1 ) (out) = _mm_madd_epi16( reg0, reg1 )\n\n  #define stbir__simdf_pack_to_8bytes(out,aa,bb) \\\n  { \\\n    stbir__simdf af,bf; \\\n    stbir__simdi a,b; \\\n    af = _mm_min_ps( aa, STBIR_max_uint8_as_float ); \\\n    bf = _mm_min_ps( bb, STBIR_max_uint8_as_float ); \\\n    af = _mm_max_ps( af, _mm_setzero_ps() ); \\\n    bf = _mm_max_ps( bf, _mm_setzero_ps() ); \\\n    a = _mm_cvttps_epi32( af ); \\\n    b = _mm_cvttps_epi32( bf ); \\\n    a = _mm_packs_epi32( a, b ); \\\n    out = _mm_packus_epi16( a, a ); \\\n  }\n\n  #define stbir__simdf_load4_transposed( o0, o1, o2, o3, ptr ) \\\n      stbir__simdf_load( o0, (ptr) );    \\\n      stbir__simdf_load( o1, (ptr)+4 );  \\\n      stbir__simdf_load( o2, (ptr)+8 );  \\\n      stbir__simdf_load( o3, (ptr)+12 ); \\\n      {                                  \\\n        __m128 tmp0, tmp1, tmp2, tmp3;   \\\n        tmp0 = _mm_unpacklo_ps(o0, o1);  \\\n        tmp2 = _mm_unpacklo_ps(o2, o3);  \\\n        tmp1 = _mm_unpackhi_ps(o0, o1);  \\\n        tmp3 = _mm_unpackhi_ps(o2, o3);  \\\n        o0 = _mm_movelh_ps(tmp0, tmp2);  \\\n        o1 = _mm_movehl_ps(tmp2, tmp0);  \\\n        o2 = _mm_movelh_ps(tmp1, tmp3);  \\\n        o3 = _mm_movehl_ps(tmp3, tmp1);  \\\n      }\n\n  #define stbir__interleave_pack_and_store_16_u8( ptr, r0, r1, r2, r3 ) \\\n      r0 = _mm_packs_epi32( r0, r1 ); \\\n      r2 = _mm_packs_epi32( r2, r3 ); \\\n      r1 = _mm_unpacklo_epi16( r0, r2 ); \\\n      r3 = _mm_unpackhi_epi16( r0, r2 ); \\\n      r0 = _mm_unpacklo_epi16( r1, r3 ); \\\n      r2 = _mm_unpackhi_epi16( r1, r3 ); \\\n      r0 = _mm_packus_epi16( r0, r2 ); \\\n      stbir__simdi_store( ptr, r0 ); \\\n\n  #define stbir__simdi_32shr( out, reg, imm ) out = _mm_srli_epi32( reg, imm )\n\n  #if defined(_MSC_VER) && !defined(__clang__)\n    // msvc inits with 8 bytes\n    #define STBIR__CONST_32_TO_8( v ) (char)(unsigned char)((v)&255),(char)(unsigned char)(((v)>>8)&255),(char)(unsigned char)(((v)>>16)&255),(char)(unsigned char)(((v)>>24)&255)\n    #define STBIR__CONST_4_32i( v ) STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v )\n    #define STBIR__CONST_4d_32i( v0, v1, v2, v3 ) STBIR__CONST_32_TO_8( v0 ), STBIR__CONST_32_TO_8( v1 ), STBIR__CONST_32_TO_8( v2 ), STBIR__CONST_32_TO_8( v3 )\n  #else\n    // everything else inits with long long's\n    #define STBIR__CONST_4_32i( v ) (long long)((((stbir_uint64)(stbir_uint32)(v))<<32)|((stbir_uint64)(stbir_uint32)(v))),(long long)((((stbir_uint64)(stbir_uint32)(v))<<32)|((stbir_uint64)(stbir_uint32)(v)))\n    #define STBIR__CONST_4d_32i( v0, v1, v2, v3 ) (long long)((((stbir_uint64)(stbir_uint32)(v1))<<32)|((stbir_uint64)(stbir_uint32)(v0))),(long long)((((stbir_uint64)(stbir_uint32)(v3))<<32)|((stbir_uint64)(stbir_uint32)(v2)))\n  #endif\n\n  #define STBIR__SIMDF_CONST(var, x) stbir__simdf var = { x, x, x, x }\n  #define STBIR__SIMDI_CONST(var, x) stbir__simdi var = { STBIR__CONST_4_32i(x) }\n  #define STBIR__CONSTF(var) (var)\n  #define STBIR__CONSTI(var) (var)\n\n  #if defined(STBIR_AVX) || defined(__SSE4_1__)\n    #include <smmintrin.h>\n    #define stbir__simdf_pack_to_8words(out,reg0,reg1) out = _mm_packus_epi32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg0,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())), _mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg1,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())))\n  #else\n    STBIR__SIMDI_CONST(stbir__s32_32768, 32768);\n    STBIR__SIMDI_CONST(stbir__s16_32768, ((32768<<16)|32768));\n\n    #define stbir__simdf_pack_to_8words(out,reg0,reg1) \\\n      { \\\n        stbir__simdi tmp0,tmp1; \\\n        tmp0 = _mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg0,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())); \\\n        tmp1 = _mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg1,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())); \\\n        tmp0 = _mm_sub_epi32( tmp0, stbir__s32_32768 ); \\\n        tmp1 = _mm_sub_epi32( tmp1, stbir__s32_32768 ); \\\n        out = _mm_packs_epi32( tmp0, tmp1 ); \\\n        out = _mm_sub_epi16( out, stbir__s16_32768 ); \\\n      }\n\n  #endif\n\n  #define STBIR_SIMD\n\n  // if we detect AVX, set the simd8 defines\n  #ifdef STBIR_AVX\n    #include <immintrin.h>\n    #define STBIR_SIMD8\n    #define stbir__simdf8 __m256\n    #define stbir__simdi8 __m256i\n    #define stbir__simdf8_load( out, ptr ) (out) = _mm256_loadu_ps( (float const *)(ptr) )\n    #define stbir__simdi8_load( out, ptr ) (out) = _mm256_loadu_si256( (__m256i const *)(ptr) )\n    #define stbir__simdf8_mult( out, a, b ) (out) = _mm256_mul_ps( (a), (b) )\n    #define stbir__simdf8_store( ptr, out ) _mm256_storeu_ps( (float*)(ptr), out )\n    #define stbir__simdi8_store( ptr, reg )  _mm256_storeu_si256( (__m256i*)(ptr), reg )\n    #define stbir__simdf8_frep8( fval ) _mm256_set1_ps( fval )\n\n    #define stbir__simdf8_min( out, reg0, reg1 ) (out) = _mm256_min_ps( reg0, reg1 )\n    #define stbir__simdf8_max( out, reg0, reg1 ) (out) = _mm256_max_ps( reg0, reg1 )\n\n    #define stbir__simdf8_add4halves( out, bot4, top8 ) (out) = _mm_add_ps( bot4, _mm256_extractf128_ps( top8, 1 ) )\n    #define stbir__simdf8_mult_mem( out, reg, ptr ) (out) = _mm256_mul_ps( reg, _mm256_loadu_ps( (float const*)(ptr) ) )\n    #define stbir__simdf8_add_mem( out, reg, ptr ) (out) = _mm256_add_ps( reg, _mm256_loadu_ps( (float const*)(ptr) ) )\n    #define stbir__simdf8_add( out, a, b ) (out) = _mm256_add_ps( a, b )\n    #define stbir__simdf8_load1b( out, ptr ) (out) = _mm256_broadcast_ss( ptr )\n    #define stbir__simdf_load1rep4( out, ptr ) (out) = _mm_broadcast_ss( ptr )  // avx load instruction\n\n    #define stbir__simdi8_convert_i32_to_float(out, ireg) (out) = _mm256_cvtepi32_ps( ireg )\n    #define stbir__simdf8_convert_float_to_i32( i, f ) (i) = _mm256_cvttps_epi32(f)\n\n    #define stbir__simdf8_bot4s( out, a, b ) (out) = _mm256_permute2f128_ps(a,b, (0<<0)+(2<<4) )\n    #define stbir__simdf8_top4s( out, a, b ) (out) = _mm256_permute2f128_ps(a,b, (1<<0)+(3<<4) )\n\n    #define stbir__simdf8_gettop4( reg ) _mm256_extractf128_ps(reg,1)\n\n    #ifdef STBIR_AVX2\n\n    #define stbir__simdi8_expand_u8_to_u32(out0,out1,ireg) \\\n    { \\\n      stbir__simdi8 a, zero  =_mm256_setzero_si256();\\\n      a = _mm256_permute4x64_epi64( _mm256_unpacklo_epi8( _mm256_permute4x64_epi64(_mm256_castsi128_si256(ireg),(0<<0)+(2<<2)+(1<<4)+(3<<6)), zero ),(0<<0)+(2<<2)+(1<<4)+(3<<6)); \\\n      out0 = _mm256_unpacklo_epi16( a, zero ); \\\n      out1 = _mm256_unpackhi_epi16( a, zero ); \\\n    }\n\n    #define stbir__simdf8_pack_to_16bytes(out,aa,bb) \\\n    { \\\n      stbir__simdi8 t; \\\n      stbir__simdf8 af,bf; \\\n      stbir__simdi8 a,b; \\\n      af = _mm256_min_ps( aa, STBIR_max_uint8_as_floatX ); \\\n      bf = _mm256_min_ps( bb, STBIR_max_uint8_as_floatX ); \\\n      af = _mm256_max_ps( af, _mm256_setzero_ps() ); \\\n      bf = _mm256_max_ps( bf, _mm256_setzero_ps() ); \\\n      a = _mm256_cvttps_epi32( af ); \\\n      b = _mm256_cvttps_epi32( bf ); \\\n      t = _mm256_permute4x64_epi64( _mm256_packs_epi32( a, b ), (0<<0)+(2<<2)+(1<<4)+(3<<6) ); \\\n      out = _mm256_castsi256_si128( _mm256_permute4x64_epi64( _mm256_packus_epi16( t, t ), (0<<0)+(2<<2)+(1<<4)+(3<<6) ) ); \\\n    }\n\n    #define stbir__simdi8_expand_u16_to_u32(out,ireg) out = _mm256_unpacklo_epi16( _mm256_permute4x64_epi64(_mm256_castsi128_si256(ireg),(0<<0)+(2<<2)+(1<<4)+(3<<6)), _mm256_setzero_si256() );\n\n    #define stbir__simdf8_pack_to_16words(out,aa,bb) \\\n      { \\\n        stbir__simdf8 af,bf; \\\n        stbir__simdi8 a,b; \\\n        af = _mm256_min_ps( aa, STBIR_max_uint16_as_floatX ); \\\n        bf = _mm256_min_ps( bb, STBIR_max_uint16_as_floatX ); \\\n        af = _mm256_max_ps( af, _mm256_setzero_ps() ); \\\n        bf = _mm256_max_ps( bf, _mm256_setzero_ps() ); \\\n        a = _mm256_cvttps_epi32( af ); \\\n        b = _mm256_cvttps_epi32( bf ); \\\n        (out) = _mm256_permute4x64_epi64( _mm256_packus_epi32(a, b), (0<<0)+(2<<2)+(1<<4)+(3<<6) ); \\\n      }\n\n    #else\n\n    #define stbir__simdi8_expand_u8_to_u32(out0,out1,ireg) \\\n    { \\\n      stbir__simdi a,zero = _mm_setzero_si128(); \\\n      a = _mm_unpacklo_epi8( ireg, zero ); \\\n      out0 = _mm256_setr_m128i( _mm_unpacklo_epi16( a, zero ), _mm_unpackhi_epi16( a, zero ) ); \\\n      a = _mm_unpackhi_epi8( ireg, zero ); \\\n      out1 = _mm256_setr_m128i( _mm_unpacklo_epi16( a, zero ), _mm_unpackhi_epi16( a, zero ) ); \\\n    }\n\n    #define stbir__simdf8_pack_to_16bytes(out,aa,bb) \\\n    { \\\n      stbir__simdi t; \\\n      stbir__simdf8 af,bf; \\\n      stbir__simdi8 a,b; \\\n      af = _mm256_min_ps( aa, STBIR_max_uint8_as_floatX ); \\\n      bf = _mm256_min_ps( bb, STBIR_max_uint8_as_floatX ); \\\n      af = _mm256_max_ps( af, _mm256_setzero_ps() ); \\\n      bf = _mm256_max_ps( bf, _mm256_setzero_ps() ); \\\n      a = _mm256_cvttps_epi32( af ); \\\n      b = _mm256_cvttps_epi32( bf ); \\\n      out = _mm_packs_epi32( _mm256_castsi256_si128(a), _mm256_extractf128_si256( a, 1 ) ); \\\n      out = _mm_packus_epi16( out, out ); \\\n      t = _mm_packs_epi32( _mm256_castsi256_si128(b), _mm256_extractf128_si256( b, 1 ) ); \\\n      t = _mm_packus_epi16( t, t ); \\\n      out = _mm_castps_si128( _mm_shuffle_ps( _mm_castsi128_ps(out), _mm_castsi128_ps(t), (0<<0)+(1<<2)+(0<<4)+(1<<6) ) ); \\\n    }\n\n    #define stbir__simdi8_expand_u16_to_u32(out,ireg) \\\n    { \\\n      stbir__simdi a,b,zero = _mm_setzero_si128(); \\\n      a = _mm_unpacklo_epi16( ireg, zero ); \\\n      b = _mm_unpackhi_epi16( ireg, zero ); \\\n      out = _mm256_insertf128_si256( _mm256_castsi128_si256( a ), b, 1 ); \\\n    }\n\n    #define stbir__simdf8_pack_to_16words(out,aa,bb) \\\n      { \\\n        stbir__simdi t0,t1; \\\n        stbir__simdf8 af,bf; \\\n        stbir__simdi8 a,b; \\\n        af = _mm256_min_ps( aa, STBIR_max_uint16_as_floatX ); \\\n        bf = _mm256_min_ps( bb, STBIR_max_uint16_as_floatX ); \\\n        af = _mm256_max_ps( af, _mm256_setzero_ps() ); \\\n        bf = _mm256_max_ps( bf, _mm256_setzero_ps() ); \\\n        a = _mm256_cvttps_epi32( af ); \\\n        b = _mm256_cvttps_epi32( bf ); \\\n        t0 = _mm_packus_epi32( _mm256_castsi256_si128(a), _mm256_extractf128_si256( a, 1 ) ); \\\n        t1 = _mm_packus_epi32( _mm256_castsi256_si128(b), _mm256_extractf128_si256( b, 1 ) ); \\\n        out = _mm256_setr_m128i( t0, t1 ); \\\n      }\n\n    #endif\n\n    static __m256i stbir_00001111 = { STBIR__CONST_4d_32i( 0, 0, 0, 0 ), STBIR__CONST_4d_32i( 1, 1, 1, 1 ) };\n    #define stbir__simdf8_0123to00001111( out, in ) (out) = _mm256_permutevar_ps ( in, stbir_00001111 )\n\n    static __m256i stbir_22223333 = { STBIR__CONST_4d_32i( 2, 2, 2, 2 ), STBIR__CONST_4d_32i( 3, 3, 3, 3 ) };\n    #define stbir__simdf8_0123to22223333( out, in ) (out) = _mm256_permutevar_ps ( in, stbir_22223333 )\n\n    #define stbir__simdf8_0123to2222( out, in ) (out) = stbir__simdf_swiz(_mm256_castps256_ps128(in), 2,2,2,2 )\n\n    #define stbir__simdf8_load4b( out, ptr ) (out) = _mm256_broadcast_ps( (__m128 const *)(ptr) )\n\n    static __m256i stbir_00112233 = { STBIR__CONST_4d_32i( 0, 0, 1, 1 ), STBIR__CONST_4d_32i( 2, 2, 3, 3 ) };\n    #define stbir__simdf8_0123to00112233( out, in ) (out) = _mm256_permutevar_ps ( in, stbir_00112233 )\n    #define stbir__simdf8_add4( out, a8, b ) (out) = _mm256_add_ps( a8,  _mm256_castps128_ps256( b ) )\n\n    static __m256i stbir_load6 = { STBIR__CONST_4_32i( 0x80000000 ), STBIR__CONST_4d_32i(  0x80000000,  0x80000000, 0, 0 ) };\n    #define stbir__simdf8_load6z( out, ptr ) (out) = _mm256_maskload_ps( ptr, stbir_load6 )\n\n    #define stbir__simdf8_0123to00000000( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (0<<0)+(0<<2)+(0<<4)+(0<<6) )\n    #define stbir__simdf8_0123to11111111( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (1<<0)+(1<<2)+(1<<4)+(1<<6) )\n    #define stbir__simdf8_0123to22222222( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (2<<0)+(2<<2)+(2<<4)+(2<<6) )\n    #define stbir__simdf8_0123to33333333( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (3<<0)+(3<<2)+(3<<4)+(3<<6) )\n    #define stbir__simdf8_0123to21032103( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (2<<0)+(1<<2)+(0<<4)+(3<<6) )\n    #define stbir__simdf8_0123to32103210( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (3<<0)+(2<<2)+(1<<4)+(0<<6) )\n    #define stbir__simdf8_0123to12301230( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (1<<0)+(2<<2)+(3<<4)+(0<<6) )\n    #define stbir__simdf8_0123to10321032( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (1<<0)+(0<<2)+(3<<4)+(2<<6) )\n    #define stbir__simdf8_0123to30123012( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (3<<0)+(0<<2)+(1<<4)+(2<<6) )\n\n    #define stbir__simdf8_0123to11331133( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (1<<0)+(1<<2)+(3<<4)+(3<<6) )\n    #define stbir__simdf8_0123to00220022( out, in ) (out) =  _mm256_shuffle_ps ( in, in, (0<<0)+(0<<2)+(2<<4)+(2<<6) )\n\n    #define stbir__simdf8_aaa1( out, alp, ones ) (out) = _mm256_blend_ps( alp, ones, (1<<0)+(1<<1)+(1<<2)+(0<<3)+(1<<4)+(1<<5)+(1<<6)+(0<<7)); (out)=_mm256_shuffle_ps( out,out, (3<<0) + (3<<2) + (3<<4) + (0<<6) )\n    #define stbir__simdf8_1aaa( out, alp, ones ) (out) = _mm256_blend_ps( alp, ones, (0<<0)+(1<<1)+(1<<2)+(1<<3)+(0<<4)+(1<<5)+(1<<6)+(1<<7)); (out)=_mm256_shuffle_ps( out,out, (1<<0) + (0<<2) + (0<<4) + (0<<6) )\n    #define stbir__simdf8_a1a1( out, alp, ones) (out) = _mm256_blend_ps( alp, ones, (1<<0)+(0<<1)+(1<<2)+(0<<3)+(1<<4)+(0<<5)+(1<<6)+(0<<7)); (out)=_mm256_shuffle_ps( out,out, (1<<0) + (0<<2) + (3<<4) + (2<<6) )\n    #define stbir__simdf8_1a1a( out, alp, ones) (out) = _mm256_blend_ps( alp, ones, (0<<0)+(1<<1)+(0<<2)+(1<<3)+(0<<4)+(1<<5)+(0<<6)+(1<<7)); (out)=_mm256_shuffle_ps( out,out, (1<<0) + (0<<2) + (3<<4) + (2<<6) )\n\n    #define stbir__simdf8_zero( reg ) (reg) = _mm256_setzero_ps()\n\n    #ifdef STBIR_USE_FMA           // not on by default to maintain bit identical simd to non-simd\n    #define stbir__simdf8_madd( out, add, mul1, mul2 ) (out) = _mm256_fmadd_ps( mul1, mul2, add )\n    #define stbir__simdf8_madd_mem( out, add, mul, ptr ) (out) = _mm256_fmadd_ps( mul, _mm256_loadu_ps( (float const*)(ptr) ), add )\n    #define stbir__simdf8_madd_mem4( out, add, mul, ptr )(out) = _mm256_fmadd_ps( _mm256_setr_m128( mul, _mm_setzero_ps() ), _mm256_setr_m128( _mm_loadu_ps( (float const*)(ptr) ), _mm_setzero_ps() ), add )\n    #else\n    #define stbir__simdf8_madd( out, add, mul1, mul2 ) (out) = _mm256_add_ps( add, _mm256_mul_ps( mul1, mul2 ) )\n    #define stbir__simdf8_madd_mem( out, add, mul, ptr ) (out) = _mm256_add_ps( add, _mm256_mul_ps( mul, _mm256_loadu_ps( (float const*)(ptr) ) ) )\n    #define stbir__simdf8_madd_mem4( out, add, mul, ptr )  (out) = _mm256_add_ps( add, _mm256_setr_m128( _mm_mul_ps( mul, _mm_loadu_ps( (float const*)(ptr) ) ), _mm_setzero_ps() ) )\n    #endif\n    #define stbir__if_simdf8_cast_to_simdf4( val ) _mm256_castps256_ps128( val )\n\n  #endif\n\n  #ifdef STBIR_FLOORF\n  #undef STBIR_FLOORF\n  #endif\n  #define STBIR_FLOORF stbir_simd_floorf\n  static stbir__inline float stbir_simd_floorf(float x)  // martins floorf\n  {\n    #if defined(STBIR_AVX) || defined(__SSE4_1__) || defined(STBIR_SSE41)\n    __m128 t = _mm_set_ss(x);\n    return _mm_cvtss_f32( _mm_floor_ss(t, t) );\n    #else\n    __m128 f = _mm_set_ss(x);\n    __m128 t = _mm_cvtepi32_ps(_mm_cvttps_epi32(f));\n    __m128 r = _mm_add_ss(t, _mm_and_ps(_mm_cmplt_ss(f, t), _mm_set_ss(-1.0f)));\n    return _mm_cvtss_f32(r);\n    #endif\n  }\n\n  #ifdef STBIR_CEILF\n  #undef STBIR_CEILF\n  #endif\n  #define STBIR_CEILF stbir_simd_ceilf\n  static stbir__inline float stbir_simd_ceilf(float x)  // martins ceilf\n  {\n    #if defined(STBIR_AVX) || defined(__SSE4_1__) || defined(STBIR_SSE41)\n    __m128 t = _mm_set_ss(x);\n    return _mm_cvtss_f32( _mm_ceil_ss(t, t) );\n    #else\n    __m128 f = _mm_set_ss(x);\n    __m128 t = _mm_cvtepi32_ps(_mm_cvttps_epi32(f));\n    __m128 r = _mm_add_ss(t, _mm_and_ps(_mm_cmplt_ss(t, f), _mm_set_ss(1.0f)));\n    return _mm_cvtss_f32(r);\n    #endif\n  }\n\n#elif defined(STBIR_NEON)\n\n  #include <arm_neon.h>\n\n  #define stbir__simdf float32x4_t\n  #define stbir__simdi uint32x4_t\n\n  #define stbir_simdi_castf( reg ) vreinterpretq_u32_f32(reg)\n  #define stbir_simdf_casti( reg ) vreinterpretq_f32_u32(reg)\n\n  #define stbir__simdf_load( reg, ptr ) (reg) = vld1q_f32( (float const*)(ptr) )\n  #define stbir__simdi_load( reg, ptr ) (reg) = vld1q_u32( (uint32_t const*)(ptr) )\n  #define stbir__simdf_load1( out, ptr ) (out) = vld1q_dup_f32( (float const*)(ptr) ) // top values can be random (not denormal or nan for perf)\n  #define stbir__simdi_load1( out, ptr ) (out) = vld1q_dup_u32( (uint32_t const*)(ptr) )\n  #define stbir__simdf_load1z( out, ptr ) (out) = vld1q_lane_f32( (float const*)(ptr), vdupq_n_f32(0), 0 ) // top values must be zero\n  #define stbir__simdf_frep4( fvar ) vdupq_n_f32( fvar )\n  #define stbir__simdf_load1frep4( out, fvar ) (out) = vdupq_n_f32( fvar )\n  #define stbir__simdf_load2( out, ptr ) (out) = vcombine_f32( vld1_f32( (float const*)(ptr) ), vcreate_f32(0) ) // top values can be random (not denormal or nan for perf)\n  #define stbir__simdf_load2z( out, ptr ) (out) = vcombine_f32( vld1_f32( (float const*)(ptr) ), vcreate_f32(0) )  // top values must be zero\n  #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = vcombine_f32( vget_low_f32(reg), vld1_f32( (float const*)(ptr) ) )\n\n  #define stbir__simdf_zeroP() vdupq_n_f32(0)\n  #define stbir__simdf_zero( reg ) (reg) = vdupq_n_f32(0)\n\n  #define stbir__simdf_store( ptr, reg )  vst1q_f32( (float*)(ptr), reg )\n  #define stbir__simdf_store1( ptr, reg ) vst1q_lane_f32( (float*)(ptr), reg, 0)\n  #define stbir__simdf_store2( ptr, reg ) vst1_f32( (float*)(ptr), vget_low_f32(reg) )\n  #define stbir__simdf_store2h( ptr, reg ) vst1_f32( (float*)(ptr), vget_high_f32(reg) )\n\n  #define stbir__simdi_store( ptr, reg )  vst1q_u32( (uint32_t*)(ptr), reg )\n  #define stbir__simdi_store1( ptr, reg ) vst1q_lane_u32( (uint32_t*)(ptr), reg, 0 )\n  #define stbir__simdi_store2( ptr, reg ) vst1_u32( (uint32_t*)(ptr), vget_low_u32(reg) )\n\n  #define stbir__prefetch( ptr )\n\n  #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg) \\\n  { \\\n    uint16x8_t l = vmovl_u8( vget_low_u8 ( vreinterpretq_u8_u32(ireg) ) ); \\\n    uint16x8_t h = vmovl_u8( vget_high_u8( vreinterpretq_u8_u32(ireg) ) ); \\\n    out0 = vmovl_u16( vget_low_u16 ( l ) ); \\\n    out1 = vmovl_u16( vget_high_u16( l ) ); \\\n    out2 = vmovl_u16( vget_low_u16 ( h ) ); \\\n    out3 = vmovl_u16( vget_high_u16( h ) ); \\\n  }\n\n  #define stbir__simdi_expand_u8_to_1u32(out,ireg) \\\n  { \\\n    uint16x8_t tmp = vmovl_u8( vget_low_u8( vreinterpretq_u8_u32(ireg) ) ); \\\n    out = vmovl_u16( vget_low_u16( tmp ) ); \\\n  }\n\n  #define stbir__simdi_expand_u16_to_u32(out0,out1,ireg) \\\n  { \\\n    uint16x8_t tmp = vreinterpretq_u16_u32(ireg); \\\n    out0 = vmovl_u16( vget_low_u16 ( tmp ) ); \\\n    out1 = vmovl_u16( vget_high_u16( tmp ) ); \\\n  }\n\n  #define stbir__simdf_convert_float_to_i32( i, f ) (i) = vreinterpretq_u32_s32( vcvtq_s32_f32(f) )\n  #define stbir__simdf_convert_float_to_int( f ) vgetq_lane_s32(vcvtq_s32_f32(f), 0)\n  #define stbir__simdi_to_int( i ) (int)vgetq_lane_u32(i, 0)\n  #define stbir__simdf_convert_float_to_uint8( f ) ((unsigned char)vgetq_lane_s32(vcvtq_s32_f32(vmaxq_f32(vminq_f32(f,STBIR__CONSTF(STBIR_max_uint8_as_float)),vdupq_n_f32(0))), 0))\n  #define stbir__simdf_convert_float_to_short( f ) ((unsigned short)vgetq_lane_s32(vcvtq_s32_f32(vmaxq_f32(vminq_f32(f,STBIR__CONSTF(STBIR_max_uint16_as_float)),vdupq_n_f32(0))), 0))\n  #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = vcvtq_f32_s32( vreinterpretq_s32_u32(ireg) )\n  #define stbir__simdf_add( out, reg0, reg1 ) (out) = vaddq_f32( reg0, reg1 )\n  #define stbir__simdf_mult( out, reg0, reg1 ) (out) = vmulq_f32( reg0, reg1 )\n  #define stbir__simdf_mult_mem( out, reg, ptr ) (out) = vmulq_f32( reg, vld1q_f32( (float const*)(ptr) ) )\n  #define stbir__simdf_mult1_mem( out, reg, ptr ) (out) = vmulq_f32( reg, vld1q_dup_f32( (float const*)(ptr) ) )\n  #define stbir__simdf_add_mem( out, reg, ptr ) (out) = vaddq_f32( reg, vld1q_f32( (float const*)(ptr) ) )\n  #define stbir__simdf_add1_mem( out, reg, ptr ) (out) = vaddq_f32( reg, vld1q_dup_f32( (float const*)(ptr) ) )\n\n  #ifdef STBIR_USE_FMA           // not on by default to maintain bit identical simd to non-simd (and also x64 no madd to arm madd)\n  #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = vfmaq_f32( add, mul1, mul2 )\n  #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = vfmaq_f32( add, mul1, mul2 )\n  #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = vfmaq_f32( add, mul, vld1q_f32( (float const*)(ptr) ) )\n  #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = vfmaq_f32( add, mul, vld1q_dup_f32( (float const*)(ptr) ) )\n  #else\n  #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = vaddq_f32( add, vmulq_f32( mul1, mul2 ) )\n  #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = vaddq_f32( add, vmulq_f32( mul1, mul2 ) )\n  #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = vaddq_f32( add, vmulq_f32( mul, vld1q_f32( (float const*)(ptr) ) ) )\n  #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = vaddq_f32( add, vmulq_f32( mul, vld1q_dup_f32( (float const*)(ptr) ) ) )\n  #endif\n\n  #define stbir__simdf_add1( out, reg0, reg1 ) (out) = vaddq_f32( reg0, reg1 )\n  #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = vmulq_f32( reg0, reg1 )\n\n  #define stbir__simdf_and( out, reg0, reg1 ) (out) = vreinterpretq_f32_u32( vandq_u32( vreinterpretq_u32_f32(reg0), vreinterpretq_u32_f32(reg1) ) )\n  #define stbir__simdf_or( out, reg0, reg1 ) (out) = vreinterpretq_f32_u32( vorrq_u32( vreinterpretq_u32_f32(reg0), vreinterpretq_u32_f32(reg1) ) )\n\n  #define stbir__simdf_min( out, reg0, reg1 ) (out) = vminq_f32( reg0, reg1 )\n  #define stbir__simdf_max( out, reg0, reg1 ) (out) = vmaxq_f32( reg0, reg1 )\n  #define stbir__simdf_min1( out, reg0, reg1 ) (out) = vminq_f32( reg0, reg1 )\n  #define stbir__simdf_max1( out, reg0, reg1 ) (out) = vmaxq_f32( reg0, reg1 )\n\n  #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out) = vextq_f32( reg0, reg1, 3 )\n  #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out) = vextq_f32( reg0, reg1, 2 )\n\n  #define stbir__simdf_a1a1( out, alp, ones ) (out) = vzipq_f32(vuzpq_f32(alp, alp).val[1], ones).val[0]\n  #define stbir__simdf_1a1a( out, alp, ones ) (out) = vzipq_f32(ones, vuzpq_f32(alp, alp).val[0]).val[0]\n\n  #if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ )\n\n    #define stbir__simdf_aaa1( out, alp, ones ) (out) = vcopyq_laneq_f32(vdupq_n_f32(vgetq_lane_f32(alp, 3)), 3, ones, 3)\n    #define stbir__simdf_1aaa( out, alp, ones ) (out) = vcopyq_laneq_f32(vdupq_n_f32(vgetq_lane_f32(alp, 0)), 0, ones, 0)\n\n    #if defined( _MSC_VER ) && !defined(__clang__)\n      #define stbir_make16(a,b,c,d) vcombine_u8( \\\n        vcreate_u8( (4*a+0) | ((4*a+1)<<8) | ((4*a+2)<<16) | ((4*a+3)<<24) | \\\n          ((stbir_uint64)(4*b+0)<<32) | ((stbir_uint64)(4*b+1)<<40) | ((stbir_uint64)(4*b+2)<<48) | ((stbir_uint64)(4*b+3)<<56)), \\\n        vcreate_u8( (4*c+0) | ((4*c+1)<<8) | ((4*c+2)<<16) | ((4*c+3)<<24) | \\\n          ((stbir_uint64)(4*d+0)<<32) | ((stbir_uint64)(4*d+1)<<40) | ((stbir_uint64)(4*d+2)<<48) | ((stbir_uint64)(4*d+3)<<56) ) )\n\n      static stbir__inline uint8x16x2_t stbir_make16x2(float32x4_t rega,float32x4_t regb)\n      {\n        uint8x16x2_t r = { vreinterpretq_u8_f32(rega), vreinterpretq_u8_f32(regb) };\n        return r;\n      }\n    #else\n      #define stbir_make16(a,b,c,d) (uint8x16_t){4*a+0,4*a+1,4*a+2,4*a+3,4*b+0,4*b+1,4*b+2,4*b+3,4*c+0,4*c+1,4*c+2,4*c+3,4*d+0,4*d+1,4*d+2,4*d+3}\n      #define stbir_make16x2(a,b) (uint8x16x2_t){{vreinterpretq_u8_f32(a),vreinterpretq_u8_f32(b)}}\n    #endif\n\n    #define stbir__simdf_swiz( reg, one, two, three, four ) vreinterpretq_f32_u8( vqtbl1q_u8( vreinterpretq_u8_f32(reg), stbir_make16(one, two, three, four) ) )\n    #define stbir__simdf_swiz2( rega, regb, one, two, three, four ) vreinterpretq_f32_u8( vqtbl2q_u8( stbir_make16x2(rega,regb), stbir_make16(one, two, three, four) ) )\n\n    #define stbir__simdi_16madd( out, reg0, reg1 ) \\\n    { \\\n      int16x8_t r0 = vreinterpretq_s16_u32(reg0); \\\n      int16x8_t r1 = vreinterpretq_s16_u32(reg1); \\\n      int32x4_t tmp0 = vmull_s16( vget_low_s16(r0), vget_low_s16(r1) ); \\\n      int32x4_t tmp1 = vmull_s16( vget_high_s16(r0), vget_high_s16(r1) ); \\\n      (out) = vreinterpretq_u32_s32( vpaddq_s32(tmp0, tmp1) ); \\\n    }\n\n  #else\n\n    #define stbir__simdf_aaa1( out, alp, ones ) (out) = vsetq_lane_f32(1.0f, vdupq_n_f32(vgetq_lane_f32(alp, 3)), 3)\n    #define stbir__simdf_1aaa( out, alp, ones ) (out) = vsetq_lane_f32(1.0f, vdupq_n_f32(vgetq_lane_f32(alp, 0)), 0)\n\n    #if defined( _MSC_VER ) && !defined(__clang__)\n      static stbir__inline uint8x8x2_t stbir_make8x2(float32x4_t reg)\n      {\n        uint8x8x2_t r = { { vget_low_u8(vreinterpretq_u8_f32(reg)), vget_high_u8(vreinterpretq_u8_f32(reg)) } };\n        return r;\n      }\n      #define stbir_make8(a,b) vcreate_u8( \\\n        (4*a+0) | ((4*a+1)<<8) | ((4*a+2)<<16) | ((4*a+3)<<24) | \\\n        ((stbir_uint64)(4*b+0)<<32) | ((stbir_uint64)(4*b+1)<<40) | ((stbir_uint64)(4*b+2)<<48) | ((stbir_uint64)(4*b+3)<<56) )\n    #else\n      #define stbir_make8x2(reg) (uint8x8x2_t){ { vget_low_u8(vreinterpretq_u8_f32(reg)), vget_high_u8(vreinterpretq_u8_f32(reg)) } }\n      #define stbir_make8(a,b) (uint8x8_t){4*a+0,4*a+1,4*a+2,4*a+3,4*b+0,4*b+1,4*b+2,4*b+3}\n    #endif\n\n    #define stbir__simdf_swiz( reg, one, two, three, four ) vreinterpretq_f32_u8( vcombine_u8( \\\n        vtbl2_u8( stbir_make8x2( reg ), stbir_make8( one, two ) ), \\\n        vtbl2_u8( stbir_make8x2( reg ), stbir_make8( three, four ) ) ) )\n\n    #define stbir__simdi_16madd( out, reg0, reg1 ) \\\n    { \\\n      int16x8_t r0 = vreinterpretq_s16_u32(reg0); \\\n      int16x8_t r1 = vreinterpretq_s16_u32(reg1); \\\n      int32x4_t tmp0 = vmull_s16( vget_low_s16(r0), vget_low_s16(r1) ); \\\n      int32x4_t tmp1 = vmull_s16( vget_high_s16(r0), vget_high_s16(r1) ); \\\n      int32x2_t out0 = vpadd_s32( vget_low_s32(tmp0), vget_high_s32(tmp0) ); \\\n      int32x2_t out1 = vpadd_s32( vget_low_s32(tmp1), vget_high_s32(tmp1) ); \\\n      (out) = vreinterpretq_u32_s32( vcombine_s32(out0, out1) ); \\\n    }\n\n  #endif\n\n  #define stbir__simdi_and( out, reg0, reg1 ) (out) = vandq_u32( reg0, reg1 )\n  #define stbir__simdi_or( out, reg0, reg1 ) (out) = vorrq_u32( reg0, reg1 )\n\n  #define stbir__simdf_pack_to_8bytes(out,aa,bb) \\\n  { \\\n    float32x4_t af = vmaxq_f32( vminq_f32(aa,STBIR__CONSTF(STBIR_max_uint8_as_float) ), vdupq_n_f32(0) ); \\\n    float32x4_t bf = vmaxq_f32( vminq_f32(bb,STBIR__CONSTF(STBIR_max_uint8_as_float) ), vdupq_n_f32(0) ); \\\n    int16x4_t ai = vqmovn_s32( vcvtq_s32_f32( af ) ); \\\n    int16x4_t bi = vqmovn_s32( vcvtq_s32_f32( bf ) ); \\\n    uint8x8_t out8 = vqmovun_s16( vcombine_s16(ai, bi) ); \\\n    out = vreinterpretq_u32_u8( vcombine_u8(out8, out8) ); \\\n  }\n\n  #define stbir__simdf_pack_to_8words(out,aa,bb) \\\n  { \\\n    float32x4_t af = vmaxq_f32( vminq_f32(aa,STBIR__CONSTF(STBIR_max_uint16_as_float) ), vdupq_n_f32(0) ); \\\n    float32x4_t bf = vmaxq_f32( vminq_f32(bb,STBIR__CONSTF(STBIR_max_uint16_as_float) ), vdupq_n_f32(0) ); \\\n    int32x4_t ai = vcvtq_s32_f32( af ); \\\n    int32x4_t bi = vcvtq_s32_f32( bf ); \\\n    out = vreinterpretq_u32_u16( vcombine_u16(vqmovun_s32(ai), vqmovun_s32(bi)) ); \\\n  }\n\n  #define stbir__interleave_pack_and_store_16_u8( ptr, r0, r1, r2, r3 ) \\\n  { \\\n    int16x4x2_t tmp0 = vzip_s16( vqmovn_s32(vreinterpretq_s32_u32(r0)), vqmovn_s32(vreinterpretq_s32_u32(r2)) ); \\\n    int16x4x2_t tmp1 = vzip_s16( vqmovn_s32(vreinterpretq_s32_u32(r1)), vqmovn_s32(vreinterpretq_s32_u32(r3)) ); \\\n    uint8x8x2_t out = \\\n    { { \\\n      vqmovun_s16( vcombine_s16(tmp0.val[0], tmp0.val[1]) ), \\\n      vqmovun_s16( vcombine_s16(tmp1.val[0], tmp1.val[1]) ), \\\n    } }; \\\n    vst2_u8(ptr, out); \\\n  }\n\n  #define stbir__simdf_load4_transposed( o0, o1, o2, o3, ptr ) \\\n  { \\\n    float32x4x4_t tmp = vld4q_f32(ptr); \\\n    o0 = tmp.val[0]; \\\n    o1 = tmp.val[1]; \\\n    o2 = tmp.val[2]; \\\n    o3 = tmp.val[3]; \\\n  }\n\n  #define stbir__simdi_32shr( out, reg, imm ) out = vshrq_n_u32( reg, imm )\n\n  #if defined( _MSC_VER ) && !defined(__clang__)\n    #define STBIR__SIMDF_CONST(var, x) __declspec(align(8)) float var[] = { x, x, x, x }\n    #define STBIR__SIMDI_CONST(var, x) __declspec(align(8)) uint32_t var[] = { x, x, x, x }\n    #define STBIR__CONSTF(var) (*(const float32x4_t*)var)\n    #define STBIR__CONSTI(var) (*(const uint32x4_t*)var)\n  #else\n    #define STBIR__SIMDF_CONST(var, x) stbir__simdf var = { x, x, x, x }\n    #define STBIR__SIMDI_CONST(var, x) stbir__simdi var = { x, x, x, x }\n    #define STBIR__CONSTF(var) (var)\n    #define STBIR__CONSTI(var) (var)\n  #endif\n\n  #ifdef STBIR_FLOORF\n  #undef STBIR_FLOORF\n  #endif\n  #define STBIR_FLOORF stbir_simd_floorf\n  static stbir__inline float stbir_simd_floorf(float x)\n  {\n    #if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ )\n    return vget_lane_f32( vrndm_f32( vdup_n_f32(x) ), 0);\n    #else\n    float32x2_t f = vdup_n_f32(x);\n    float32x2_t t = vcvt_f32_s32(vcvt_s32_f32(f));\n    uint32x2_t a = vclt_f32(f, t);\n    uint32x2_t b = vreinterpret_u32_f32(vdup_n_f32(-1.0f));\n    float32x2_t r = vadd_f32(t, vreinterpret_f32_u32(vand_u32(a, b)));\n    return vget_lane_f32(r, 0);\n    #endif\n  }\n\n  #ifdef STBIR_CEILF\n  #undef STBIR_CEILF\n  #endif\n  #define STBIR_CEILF stbir_simd_ceilf\n  static stbir__inline float stbir_simd_ceilf(float x)\n  {\n    #if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ )\n    return vget_lane_f32( vrndp_f32( vdup_n_f32(x) ), 0);\n    #else\n    float32x2_t f = vdup_n_f32(x);\n    float32x2_t t = vcvt_f32_s32(vcvt_s32_f32(f));\n    uint32x2_t a = vclt_f32(t, f);\n    uint32x2_t b = vreinterpret_u32_f32(vdup_n_f32(1.0f));\n    float32x2_t r = vadd_f32(t, vreinterpret_f32_u32(vand_u32(a, b)));\n    return vget_lane_f32(r, 0);\n    #endif\n  }\n\n  #define STBIR_SIMD\n\n#elif defined(STBIR_WASM)\n\n  #include <wasm_simd128.h>\n\n  #define stbir__simdf v128_t\n  #define stbir__simdi v128_t\n\n  #define stbir_simdi_castf( reg ) (reg)\n  #define stbir_simdf_casti( reg ) (reg)\n\n  #define stbir__simdf_load( reg, ptr )             (reg) = wasm_v128_load( (void const*)(ptr) )\n  #define stbir__simdi_load( reg, ptr )             (reg) = wasm_v128_load( (void const*)(ptr) )\n  #define stbir__simdf_load1( out, ptr )            (out) = wasm_v128_load32_splat( (void const*)(ptr) ) // top values can be random (not denormal or nan for perf)\n  #define stbir__simdi_load1( out, ptr )            (out) = wasm_v128_load32_splat( (void const*)(ptr) )\n  #define stbir__simdf_load1z( out, ptr )           (out) = wasm_v128_load32_zero( (void const*)(ptr) ) // top values must be zero\n  #define stbir__simdf_frep4( fvar )                wasm_f32x4_splat( fvar )\n  #define stbir__simdf_load1frep4( out, fvar )      (out) = wasm_f32x4_splat( fvar )\n  #define stbir__simdf_load2( out, ptr )            (out) = wasm_v128_load64_splat( (void const*)(ptr) ) // top values can be random (not denormal or nan for perf)\n  #define stbir__simdf_load2z( out, ptr )           (out) = wasm_v128_load64_zero( (void const*)(ptr) ) // top values must be zero\n  #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = wasm_v128_load64_lane( (void const*)(ptr), reg, 1 )\n\n  #define stbir__simdf_zeroP() wasm_f32x4_const_splat(0)\n  #define stbir__simdf_zero( reg ) (reg) = wasm_f32x4_const_splat(0)\n\n  #define stbir__simdf_store( ptr, reg )   wasm_v128_store( (void*)(ptr), reg )\n  #define stbir__simdf_store1( ptr, reg )  wasm_v128_store32_lane( (void*)(ptr), reg, 0 )\n  #define stbir__simdf_store2( ptr, reg )  wasm_v128_store64_lane( (void*)(ptr), reg, 0 )\n  #define stbir__simdf_store2h( ptr, reg ) wasm_v128_store64_lane( (void*)(ptr), reg, 1 )\n\n  #define stbir__simdi_store( ptr, reg )  wasm_v128_store( (void*)(ptr), reg )\n  #define stbir__simdi_store1( ptr, reg ) wasm_v128_store32_lane( (void*)(ptr), reg, 0 )\n  #define stbir__simdi_store2( ptr, reg ) wasm_v128_store64_lane( (void*)(ptr), reg, 0 )\n\n  #define stbir__prefetch( ptr )\n\n  #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg) \\\n  { \\\n    v128_t l = wasm_u16x8_extend_low_u8x16 ( ireg ); \\\n    v128_t h = wasm_u16x8_extend_high_u8x16( ireg ); \\\n    out0 = wasm_u32x4_extend_low_u16x8 ( l ); \\\n    out1 = wasm_u32x4_extend_high_u16x8( l ); \\\n    out2 = wasm_u32x4_extend_low_u16x8 ( h ); \\\n    out3 = wasm_u32x4_extend_high_u16x8( h ); \\\n  }\n\n  #define stbir__simdi_expand_u8_to_1u32(out,ireg) \\\n  { \\\n    v128_t tmp = wasm_u16x8_extend_low_u8x16(ireg); \\\n    out = wasm_u32x4_extend_low_u16x8(tmp); \\\n  }\n\n  #define stbir__simdi_expand_u16_to_u32(out0,out1,ireg) \\\n  { \\\n    out0 = wasm_u32x4_extend_low_u16x8 ( ireg ); \\\n    out1 = wasm_u32x4_extend_high_u16x8( ireg ); \\\n  }\n\n  #define stbir__simdf_convert_float_to_i32( i, f )    (i) = wasm_i32x4_trunc_sat_f32x4(f)\n  #define stbir__simdf_convert_float_to_int( f )       wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(f), 0)\n  #define stbir__simdi_to_int( i )                     wasm_i32x4_extract_lane(i, 0)\n  #define stbir__simdf_convert_float_to_uint8( f )     ((unsigned char)wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(wasm_f32x4_max(wasm_f32x4_min(f,STBIR_max_uint8_as_float),wasm_f32x4_const_splat(0))), 0))\n  #define stbir__simdf_convert_float_to_short( f )     ((unsigned short)wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(wasm_f32x4_max(wasm_f32x4_min(f,STBIR_max_uint16_as_float),wasm_f32x4_const_splat(0))), 0))\n  #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = wasm_f32x4_convert_i32x4(ireg)\n  #define stbir__simdf_add( out, reg0, reg1 )          (out) = wasm_f32x4_add( reg0, reg1 )\n  #define stbir__simdf_mult( out, reg0, reg1 )         (out) = wasm_f32x4_mul( reg0, reg1 )\n  #define stbir__simdf_mult_mem( out, reg, ptr )       (out) = wasm_f32x4_mul( reg, wasm_v128_load( (void const*)(ptr) ) )\n  #define stbir__simdf_mult1_mem( out, reg, ptr )      (out) = wasm_f32x4_mul( reg, wasm_v128_load32_splat( (void const*)(ptr) ) )\n  #define stbir__simdf_add_mem( out, reg, ptr )        (out) = wasm_f32x4_add( reg, wasm_v128_load( (void const*)(ptr) ) )\n  #define stbir__simdf_add1_mem( out, reg, ptr )       (out) = wasm_f32x4_add( reg, wasm_v128_load32_splat( (void const*)(ptr) ) )\n\n  #define stbir__simdf_madd( out, add, mul1, mul2 )    (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul1, mul2 ) )\n  #define stbir__simdf_madd1( out, add, mul1, mul2 )   (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul1, mul2 ) )\n  #define stbir__simdf_madd_mem( out, add, mul, ptr )  (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul, wasm_v128_load( (void const*)(ptr) ) ) )\n  #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul, wasm_v128_load32_splat( (void const*)(ptr) ) ) )\n\n  #define stbir__simdf_add1( out, reg0, reg1 )  (out) = wasm_f32x4_add( reg0, reg1 )\n  #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = wasm_f32x4_mul( reg0, reg1 )\n\n  #define stbir__simdf_and( out, reg0, reg1 ) (out) = wasm_v128_and( reg0, reg1 )\n  #define stbir__simdf_or( out, reg0, reg1 )  (out) = wasm_v128_or( reg0, reg1 )\n\n  #define stbir__simdf_min( out, reg0, reg1 ) (out) = wasm_f32x4_min( reg0, reg1 )\n  #define stbir__simdf_max( out, reg0, reg1 ) (out) = wasm_f32x4_max( reg0, reg1 )\n  #define stbir__simdf_min1( out, reg0, reg1 ) (out) = wasm_f32x4_min( reg0, reg1 )\n  #define stbir__simdf_max1( out, reg0, reg1 ) (out) = wasm_f32x4_max( reg0, reg1 )\n\n  #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out) = wasm_i32x4_shuffle( reg0, reg1, 3, 4, 5, -1 )\n  #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out) = wasm_i32x4_shuffle( reg0, reg1, 2, 3, 4, -1 )\n\n  #define stbir__simdf_aaa1(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 3, 3, 3, 4)\n  #define stbir__simdf_1aaa(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 4, 0, 0, 0)\n  #define stbir__simdf_a1a1(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 1, 4, 3, 4)\n  #define stbir__simdf_1a1a(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 4, 0, 4, 2)\n\n  #define stbir__simdf_swiz( reg, one, two, three, four ) wasm_i32x4_shuffle(reg, reg, one, two, three, four)\n\n  #define stbir__simdi_and( out, reg0, reg1 )    (out) = wasm_v128_and( reg0, reg1 )\n  #define stbir__simdi_or( out, reg0, reg1 )     (out) = wasm_v128_or( reg0, reg1 )\n  #define stbir__simdi_16madd( out, reg0, reg1 ) (out) = wasm_i32x4_dot_i16x8( reg0, reg1 )\n\n  #define stbir__simdf_pack_to_8bytes(out,aa,bb) \\\n  { \\\n    v128_t af = wasm_f32x4_max( wasm_f32x4_min(aa, STBIR_max_uint8_as_float), wasm_f32x4_const_splat(0) ); \\\n    v128_t bf = wasm_f32x4_max( wasm_f32x4_min(bb, STBIR_max_uint8_as_float), wasm_f32x4_const_splat(0) ); \\\n    v128_t ai = wasm_i32x4_trunc_sat_f32x4( af ); \\\n    v128_t bi = wasm_i32x4_trunc_sat_f32x4( bf ); \\\n    v128_t out16 = wasm_i16x8_narrow_i32x4( ai, bi ); \\\n    out = wasm_u8x16_narrow_i16x8( out16, out16 ); \\\n  }\n\n  #define stbir__simdf_pack_to_8words(out,aa,bb) \\\n  { \\\n    v128_t af = wasm_f32x4_max( wasm_f32x4_min(aa, STBIR_max_uint16_as_float), wasm_f32x4_const_splat(0)); \\\n    v128_t bf = wasm_f32x4_max( wasm_f32x4_min(bb, STBIR_max_uint16_as_float), wasm_f32x4_const_splat(0)); \\\n    v128_t ai = wasm_i32x4_trunc_sat_f32x4( af ); \\\n    v128_t bi = wasm_i32x4_trunc_sat_f32x4( bf ); \\\n    out = wasm_u16x8_narrow_i32x4( ai, bi ); \\\n  }\n\n  #define stbir__interleave_pack_and_store_16_u8( ptr, r0, r1, r2, r3 ) \\\n  { \\\n    v128_t tmp0 = wasm_i16x8_narrow_i32x4(r0, r1); \\\n    v128_t tmp1 = wasm_i16x8_narrow_i32x4(r2, r3); \\\n    v128_t tmp = wasm_u8x16_narrow_i16x8(tmp0, tmp1); \\\n    tmp = wasm_i8x16_shuffle(tmp, tmp, 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15); \\\n    wasm_v128_store( (void*)(ptr), tmp); \\\n  }\n\n  #define stbir__simdf_load4_transposed( o0, o1, o2, o3, ptr ) \\\n  { \\\n    v128_t t0 = wasm_v128_load( ptr    ); \\\n    v128_t t1 = wasm_v128_load( ptr+4  ); \\\n    v128_t t2 = wasm_v128_load( ptr+8  ); \\\n    v128_t t3 = wasm_v128_load( ptr+12 ); \\\n    v128_t s0 = wasm_i32x4_shuffle(t0, t1, 0, 4, 2, 6); \\\n    v128_t s1 = wasm_i32x4_shuffle(t0, t1, 1, 5, 3, 7); \\\n    v128_t s2 = wasm_i32x4_shuffle(t2, t3, 0, 4, 2, 6); \\\n    v128_t s3 = wasm_i32x4_shuffle(t2, t3, 1, 5, 3, 7); \\\n    o0 = wasm_i32x4_shuffle(s0, s2, 0, 1, 4, 5); \\\n    o1 = wasm_i32x4_shuffle(s1, s3, 0, 1, 4, 5); \\\n    o2 = wasm_i32x4_shuffle(s0, s2, 2, 3, 6, 7); \\\n    o3 = wasm_i32x4_shuffle(s1, s3, 2, 3, 6, 7); \\\n  }\n\n  #define stbir__simdi_32shr( out, reg, imm ) out = wasm_u32x4_shr( reg, imm )\n\n  typedef float stbir__f32x4 __attribute__((__vector_size__(16), __aligned__(16)));\n  #define STBIR__SIMDF_CONST(var, x) stbir__simdf var = (v128_t)(stbir__f32x4){ x, x, x, x }\n  #define STBIR__SIMDI_CONST(var, x) stbir__simdi var = { x, x, x, x }\n  #define STBIR__CONSTF(var) (var)\n  #define STBIR__CONSTI(var) (var)\n\n  #ifdef STBIR_FLOORF\n  #undef STBIR_FLOORF\n  #endif\n  #define STBIR_FLOORF stbir_simd_floorf\n  static stbir__inline float stbir_simd_floorf(float x)\n  {\n    return wasm_f32x4_extract_lane( wasm_f32x4_floor( wasm_f32x4_splat(x) ), 0);\n  }\n\n  #ifdef STBIR_CEILF\n  #undef STBIR_CEILF\n  #endif\n  #define STBIR_CEILF stbir_simd_ceilf\n  static stbir__inline float stbir_simd_ceilf(float x)\n  {\n    return wasm_f32x4_extract_lane( wasm_f32x4_ceil( wasm_f32x4_splat(x) ), 0);\n  }\n\n  #define STBIR_SIMD\n\n#endif  // SSE2/NEON/WASM\n\n#endif // NO SIMD\n\n#ifdef STBIR_SIMD8\n  #define stbir__simdfX stbir__simdf8\n  #define stbir__simdiX stbir__simdi8\n  #define stbir__simdfX_load stbir__simdf8_load\n  #define stbir__simdiX_load stbir__simdi8_load\n  #define stbir__simdfX_mult stbir__simdf8_mult\n  #define stbir__simdfX_add_mem stbir__simdf8_add_mem\n  #define stbir__simdfX_madd_mem stbir__simdf8_madd_mem\n  #define stbir__simdfX_store stbir__simdf8_store\n  #define stbir__simdiX_store stbir__simdi8_store\n  #define stbir__simdf_frepX  stbir__simdf8_frep8\n  #define stbir__simdfX_madd stbir__simdf8_madd\n  #define stbir__simdfX_min stbir__simdf8_min\n  #define stbir__simdfX_max stbir__simdf8_max\n  #define stbir__simdfX_aaa1 stbir__simdf8_aaa1\n  #define stbir__simdfX_1aaa stbir__simdf8_1aaa\n  #define stbir__simdfX_a1a1 stbir__simdf8_a1a1\n  #define stbir__simdfX_1a1a stbir__simdf8_1a1a\n  #define stbir__simdfX_convert_float_to_i32 stbir__simdf8_convert_float_to_i32\n  #define stbir__simdfX_pack_to_words stbir__simdf8_pack_to_16words\n  #define stbir__simdfX_zero stbir__simdf8_zero\n  #define STBIR_onesX STBIR_ones8\n  #define STBIR_max_uint8_as_floatX STBIR_max_uint8_as_float8\n  #define STBIR_max_uint16_as_floatX STBIR_max_uint16_as_float8\n  #define STBIR_simd_point5X STBIR_simd_point58\n  #define stbir__simdfX_float_count 8\n  #define stbir__simdfX_0123to1230 stbir__simdf8_0123to12301230\n  #define stbir__simdfX_0123to2103 stbir__simdf8_0123to21032103\n  static const stbir__simdf8 STBIR_max_uint16_as_float_inverted8 = { stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted };\n  static const stbir__simdf8 STBIR_max_uint8_as_float_inverted8 = { stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted };\n  static const stbir__simdf8 STBIR_ones8 = { 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0 };\n  static const stbir__simdf8 STBIR_simd_point58 = { 0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5 };\n  static const stbir__simdf8 STBIR_max_uint8_as_float8 = { stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float, stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float };\n  static const stbir__simdf8 STBIR_max_uint16_as_float8 = { stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float, stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float };\n#else\n  #define stbir__simdfX stbir__simdf\n  #define stbir__simdiX stbir__simdi\n  #define stbir__simdfX_load stbir__simdf_load\n  #define stbir__simdiX_load stbir__simdi_load\n  #define stbir__simdfX_mult stbir__simdf_mult\n  #define stbir__simdfX_add_mem stbir__simdf_add_mem\n  #define stbir__simdfX_madd_mem stbir__simdf_madd_mem\n  #define stbir__simdfX_store stbir__simdf_store\n  #define stbir__simdiX_store stbir__simdi_store\n  #define stbir__simdf_frepX  stbir__simdf_frep4\n  #define stbir__simdfX_madd stbir__simdf_madd\n  #define stbir__simdfX_min stbir__simdf_min\n  #define stbir__simdfX_max stbir__simdf_max\n  #define stbir__simdfX_aaa1 stbir__simdf_aaa1\n  #define stbir__simdfX_1aaa stbir__simdf_1aaa\n  #define stbir__simdfX_a1a1 stbir__simdf_a1a1\n  #define stbir__simdfX_1a1a stbir__simdf_1a1a\n  #define stbir__simdfX_convert_float_to_i32 stbir__simdf_convert_float_to_i32\n  #define stbir__simdfX_pack_to_words stbir__simdf_pack_to_8words\n  #define stbir__simdfX_zero stbir__simdf_zero\n  #define STBIR_onesX STBIR__CONSTF(STBIR_ones)\n  #define STBIR_simd_point5X STBIR__CONSTF(STBIR_simd_point5)\n  #define STBIR_max_uint8_as_floatX STBIR__CONSTF(STBIR_max_uint8_as_float)\n  #define STBIR_max_uint16_as_floatX STBIR__CONSTF(STBIR_max_uint16_as_float)\n  #define stbir__simdfX_float_count 4\n  #define stbir__if_simdf8_cast_to_simdf4( val ) ( val )\n  #define stbir__simdfX_0123to1230 stbir__simdf_0123to1230\n  #define stbir__simdfX_0123to2103 stbir__simdf_0123to2103\n#endif\n\n\n#if defined(STBIR_NEON) && !defined(_M_ARM) && !defined(__arm__)\n\n  #if defined( _MSC_VER ) && !defined(__clang__)\n  typedef __int16 stbir__FP16;\n  #else\n  typedef float16_t stbir__FP16;\n  #endif\n\n#else // no NEON, or 32-bit ARM for MSVC\n\n  typedef union stbir__FP16\n  {\n    unsigned short u;\n  } stbir__FP16;\n\n#endif\n\n#if (!defined(STBIR_NEON) && !defined(STBIR_FP16C)) || (defined(STBIR_NEON) && defined(_M_ARM)) || (defined(STBIR_NEON) && defined(__arm__))\n\n  // Fabian's half float routines, see: https://gist.github.com/rygorous/2156668\n\n  static stbir__inline float stbir__half_to_float( stbir__FP16 h )\n  {\n    static const stbir__FP32 magic = { (254 - 15) << 23 };\n    static const stbir__FP32 was_infnan = { (127 + 16) << 23 };\n    stbir__FP32 o;\n\n    o.u = (h.u & 0x7fff) << 13;     // exponent/mantissa bits\n    o.f *= magic.f;                 // exponent adjust\n    if (o.f >= was_infnan.f)        // make sure Inf/NaN survive\n      o.u |= 255 << 23;\n    o.u |= (h.u & 0x8000) << 16;    // sign bit\n    return o.f;\n  }\n\n  static stbir__inline stbir__FP16 stbir__float_to_half(float val)\n  {\n    stbir__FP32 f32infty = { 255 << 23 };\n    stbir__FP32 f16max   = { (127 + 16) << 23 };\n    stbir__FP32 denorm_magic = { ((127 - 15) + (23 - 10) + 1) << 23 };\n    unsigned int sign_mask = 0x80000000u;\n    stbir__FP16 o = { 0 };\n    stbir__FP32 f;\n    unsigned int sign;\n\n    f.f = val;\n    sign = f.u & sign_mask;\n    f.u ^= sign;\n\n    if (f.u >= f16max.u) // result is Inf or NaN (all exponent bits set)\n      o.u = (f.u > f32infty.u) ? 0x7e00 : 0x7c00; // NaN->qNaN and Inf->Inf\n    else // (De)normalized number or zero\n    {\n      if (f.u < (113 << 23)) // resulting FP16 is subnormal or zero\n      {\n        // use a magic value to align our 10 mantissa bits at the bottom of\n        // the float. as long as FP addition is round-to-nearest-even this\n        // just works.\n        f.f += denorm_magic.f;\n        // and one integer subtract of the bias later, we have our final float!\n        o.u = (unsigned short) ( f.u - denorm_magic.u );\n      }\n      else\n      {\n        unsigned int mant_odd = (f.u >> 13) & 1; // resulting mantissa is odd\n        // update exponent, rounding bias part 1\n        f.u = f.u + ((15u - 127) << 23) + 0xfff;\n        // rounding bias part 2\n        f.u += mant_odd;\n        // take the bits!\n        o.u = (unsigned short) ( f.u >> 13 );\n      }\n    }\n\n    o.u |= sign >> 16;\n    return o;\n  }\n\n#endif\n\n\n#if defined(STBIR_FP16C)\n\n  #include <immintrin.h>\n\n  static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)\n  {\n    _mm256_storeu_ps( (float*)output, _mm256_cvtph_ps( _mm_loadu_si128( (__m128i const* )input ) ) );\n  }\n\n  static stbir__inline void stbir__float_to_half_SIMD(stbir__FP16 * output, float const * input)\n  {\n    _mm_storeu_si128( (__m128i*)output, _mm256_cvtps_ph( _mm256_loadu_ps( input ), 0 ) );\n  }\n\n  static stbir__inline float stbir__half_to_float( stbir__FP16 h )\n  {\n    return _mm_cvtss_f32( _mm_cvtph_ps( _mm_cvtsi32_si128( (int)h.u ) ) );\n  }\n\n  static stbir__inline stbir__FP16 stbir__float_to_half( float f )\n  {\n    stbir__FP16 h;\n    h.u = (unsigned short) _mm_cvtsi128_si32( _mm_cvtps_ph( _mm_set_ss( f ), 0 ) );\n    return h;\n  }\n\n#elif defined(STBIR_SSE2)\n\n  // Fabian's half float routines, see: https://gist.github.com/rygorous/2156668\n  stbir__inline static void stbir__half_to_float_SIMD(float * output, void const * input)\n  {\n    static const STBIR__SIMDI_CONST(mask_nosign,      0x7fff);\n    static const STBIR__SIMDI_CONST(smallest_normal,  0x0400);\n    static const STBIR__SIMDI_CONST(infinity,         0x7c00);\n    static const STBIR__SIMDI_CONST(expadjust_normal, (127 - 15) << 23);\n    static const STBIR__SIMDI_CONST(magic_denorm,     113 << 23);\n\n    __m128i i = _mm_loadu_si128 ( (__m128i const*)(input) );\n    __m128i h = _mm_unpacklo_epi16 ( i, _mm_setzero_si128() );\n    __m128i mnosign     = STBIR__CONSTI(mask_nosign);\n    __m128i eadjust     = STBIR__CONSTI(expadjust_normal);\n    __m128i smallest    = STBIR__CONSTI(smallest_normal);\n    __m128i infty       = STBIR__CONSTI(infinity);\n    __m128i expmant     = _mm_and_si128(mnosign, h);\n    __m128i justsign    = _mm_xor_si128(h, expmant);\n    __m128i b_notinfnan = _mm_cmpgt_epi32(infty, expmant);\n    __m128i b_isdenorm  = _mm_cmpgt_epi32(smallest, expmant);\n    __m128i shifted     = _mm_slli_epi32(expmant, 13);\n    __m128i adj_infnan  = _mm_andnot_si128(b_notinfnan, eadjust);\n    __m128i adjusted    = _mm_add_epi32(eadjust, shifted);\n    __m128i den1        = _mm_add_epi32(shifted, STBIR__CONSTI(magic_denorm));\n    __m128i adjusted2   = _mm_add_epi32(adjusted, adj_infnan);\n    __m128  den2        = _mm_sub_ps(_mm_castsi128_ps(den1), *(const __m128 *)&magic_denorm);\n    __m128  adjusted3   = _mm_and_ps(den2, _mm_castsi128_ps(b_isdenorm));\n    __m128  adjusted4   = _mm_andnot_ps(_mm_castsi128_ps(b_isdenorm), _mm_castsi128_ps(adjusted2));\n    __m128  adjusted5   = _mm_or_ps(adjusted3, adjusted4);\n    __m128i sign        = _mm_slli_epi32(justsign, 16);\n    __m128  final       = _mm_or_ps(adjusted5, _mm_castsi128_ps(sign));\n    stbir__simdf_store( output + 0,  final );\n\n    h = _mm_unpackhi_epi16 ( i, _mm_setzero_si128() );\n    expmant     = _mm_and_si128(mnosign, h);\n    justsign    = _mm_xor_si128(h, expmant);\n    b_notinfnan = _mm_cmpgt_epi32(infty, expmant);\n    b_isdenorm  = _mm_cmpgt_epi32(smallest, expmant);\n    shifted     = _mm_slli_epi32(expmant, 13);\n    adj_infnan  = _mm_andnot_si128(b_notinfnan, eadjust);\n    adjusted    = _mm_add_epi32(eadjust, shifted);\n    den1        = _mm_add_epi32(shifted, STBIR__CONSTI(magic_denorm));\n    adjusted2   = _mm_add_epi32(adjusted, adj_infnan);\n    den2        = _mm_sub_ps(_mm_castsi128_ps(den1), *(const __m128 *)&magic_denorm);\n    adjusted3   = _mm_and_ps(den2, _mm_castsi128_ps(b_isdenorm));\n    adjusted4   = _mm_andnot_ps(_mm_castsi128_ps(b_isdenorm), _mm_castsi128_ps(adjusted2));\n    adjusted5   = _mm_or_ps(adjusted3, adjusted4);\n    sign        = _mm_slli_epi32(justsign, 16);\n    final       = _mm_or_ps(adjusted5, _mm_castsi128_ps(sign));\n    stbir__simdf_store( output + 4,  final );\n\n    // ~38 SSE2 ops for 8 values\n  }\n\n  // Fabian's round-to-nearest-even float to half\n  // ~48 SSE2 ops for 8 output\n  stbir__inline static void stbir__float_to_half_SIMD(void * output, float const * input)\n  {\n    static const STBIR__SIMDI_CONST(mask_sign,      0x80000000u);\n    static const STBIR__SIMDI_CONST(c_f16max,       (127 + 16) << 23); // all FP32 values >=this round to +inf\n    static const STBIR__SIMDI_CONST(c_nanbit,        0x200);\n    static const STBIR__SIMDI_CONST(c_infty_as_fp16, 0x7c00);\n    static const STBIR__SIMDI_CONST(c_min_normal,    (127 - 14) << 23); // smallest FP32 that yields a normalized FP16\n    static const STBIR__SIMDI_CONST(c_subnorm_magic, ((127 - 15) + (23 - 10) + 1) << 23);\n    static const STBIR__SIMDI_CONST(c_normal_bias,    0xfff - ((127 - 15) << 23)); // adjust exponent and add mantissa rounding\n\n    __m128  f           =  _mm_loadu_ps(input);\n    __m128  msign       = _mm_castsi128_ps(STBIR__CONSTI(mask_sign));\n    __m128  justsign    = _mm_and_ps(msign, f);\n    __m128  absf        = _mm_xor_ps(f, justsign);\n    __m128i absf_int    = _mm_castps_si128(absf); // the cast is \"free\" (extra bypass latency, but no thruput hit)\n    __m128i f16max      = STBIR__CONSTI(c_f16max);\n    __m128  b_isnan     = _mm_cmpunord_ps(absf, absf); // is this a NaN?\n    __m128i b_isregular = _mm_cmpgt_epi32(f16max, absf_int); // (sub)normalized or special?\n    __m128i nanbit      = _mm_and_si128(_mm_castps_si128(b_isnan), STBIR__CONSTI(c_nanbit));\n    __m128i inf_or_nan  = _mm_or_si128(nanbit, STBIR__CONSTI(c_infty_as_fp16)); // output for specials\n\n    __m128i min_normal  = STBIR__CONSTI(c_min_normal);\n    __m128i b_issub     = _mm_cmpgt_epi32(min_normal, absf_int);\n\n    // \"result is subnormal\" path\n    __m128  subnorm1    = _mm_add_ps(absf, _mm_castsi128_ps(STBIR__CONSTI(c_subnorm_magic))); // magic value to round output mantissa\n    __m128i subnorm2    = _mm_sub_epi32(_mm_castps_si128(subnorm1), STBIR__CONSTI(c_subnorm_magic)); // subtract out bias\n\n    // \"result is normal\" path\n    __m128i mantoddbit  = _mm_slli_epi32(absf_int, 31 - 13); // shift bit 13 (mantissa LSB) to sign\n    __m128i mantodd     = _mm_srai_epi32(mantoddbit, 31); // -1 if FP16 mantissa odd, else 0\n\n    __m128i round1      = _mm_add_epi32(absf_int, STBIR__CONSTI(c_normal_bias));\n    __m128i round2      = _mm_sub_epi32(round1, mantodd); // if mantissa LSB odd, bias towards rounding up (RTNE)\n    __m128i normal      = _mm_srli_epi32(round2, 13); // rounded result\n\n    // combine the two non-specials\n    __m128i nonspecial  = _mm_or_si128(_mm_and_si128(subnorm2, b_issub), _mm_andnot_si128(b_issub, normal));\n\n    // merge in specials as well\n    __m128i joined      = _mm_or_si128(_mm_and_si128(nonspecial, b_isregular), _mm_andnot_si128(b_isregular, inf_or_nan));\n\n    __m128i sign_shift  = _mm_srai_epi32(_mm_castps_si128(justsign), 16);\n    __m128i final2, final= _mm_or_si128(joined, sign_shift);\n\n    f           =  _mm_loadu_ps(input+4);\n    justsign    = _mm_and_ps(msign, f);\n    absf        = _mm_xor_ps(f, justsign);\n    absf_int    = _mm_castps_si128(absf); // the cast is \"free\" (extra bypass latency, but no thruput hit)\n    b_isnan     = _mm_cmpunord_ps(absf, absf); // is this a NaN?\n    b_isregular = _mm_cmpgt_epi32(f16max, absf_int); // (sub)normalized or special?\n    nanbit      = _mm_and_si128(_mm_castps_si128(b_isnan), c_nanbit);\n    inf_or_nan  = _mm_or_si128(nanbit, STBIR__CONSTI(c_infty_as_fp16)); // output for specials\n\n    b_issub     = _mm_cmpgt_epi32(min_normal, absf_int);\n\n    // \"result is subnormal\" path\n    subnorm1    = _mm_add_ps(absf, _mm_castsi128_ps(STBIR__CONSTI(c_subnorm_magic))); // magic value to round output mantissa\n    subnorm2    = _mm_sub_epi32(_mm_castps_si128(subnorm1), STBIR__CONSTI(c_subnorm_magic)); // subtract out bias\n\n    // \"result is normal\" path\n    mantoddbit  = _mm_slli_epi32(absf_int, 31 - 13); // shift bit 13 (mantissa LSB) to sign\n    mantodd     = _mm_srai_epi32(mantoddbit, 31); // -1 if FP16 mantissa odd, else 0\n\n    round1      = _mm_add_epi32(absf_int, STBIR__CONSTI(c_normal_bias));\n    round2      = _mm_sub_epi32(round1, mantodd); // if mantissa LSB odd, bias towards rounding up (RTNE)\n    normal      = _mm_srli_epi32(round2, 13); // rounded result\n\n    // combine the two non-specials\n    nonspecial  = _mm_or_si128(_mm_and_si128(subnorm2, b_issub), _mm_andnot_si128(b_issub, normal));\n\n    // merge in specials as well\n    joined      = _mm_or_si128(_mm_and_si128(nonspecial, b_isregular), _mm_andnot_si128(b_isregular, inf_or_nan));\n\n    sign_shift  = _mm_srai_epi32(_mm_castps_si128(justsign), 16);\n    final2      = _mm_or_si128(joined, sign_shift);\n    final       = _mm_packs_epi32(final, final2);\n    stbir__simdi_store( output,final );\n  }\n\n#elif defined(STBIR_NEON) && defined(_MSC_VER) && defined(_M_ARM64) && !defined(__clang__) // 64-bit ARM on MSVC (not clang)\n\n  static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)\n  {\n    float16x4_t in0 = vld1_f16(input + 0);\n    float16x4_t in1 = vld1_f16(input + 4);\n    vst1q_f32(output + 0, vcvt_f32_f16(in0));\n    vst1q_f32(output + 4, vcvt_f32_f16(in1));\n  }\n\n  static stbir__inline void stbir__float_to_half_SIMD(stbir__FP16 * output, float const * input)\n  {\n    float16x4_t out0 = vcvt_f16_f32(vld1q_f32(input + 0));\n    float16x4_t out1 = vcvt_f16_f32(vld1q_f32(input + 4));\n    vst1_f16(output+0, out0);\n    vst1_f16(output+4, out1);\n  }\n\n  static stbir__inline float stbir__half_to_float( stbir__FP16 h )\n  {\n    return vgetq_lane_f32(vcvt_f32_f16(vld1_dup_f16(&h)), 0);\n  }\n\n  static stbir__inline stbir__FP16 stbir__float_to_half( float f )\n  {\n    return vget_lane_f16(vcvt_f16_f32(vdupq_n_f32(f)), 0).n16_u16[0];\n  }\n\n#elif defined(STBIR_NEON) && ( defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) ) // 64-bit ARM\n\n  static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)\n  {\n    float16x8_t in = vld1q_f16(input);\n    vst1q_f32(output + 0, vcvt_f32_f16(vget_low_f16(in)));\n    vst1q_f32(output + 4, vcvt_f32_f16(vget_high_f16(in)));\n  }\n\n  static stbir__inline void stbir__float_to_half_SIMD(stbir__FP16 * output, float const * input)\n  {\n    float16x4_t out0 = vcvt_f16_f32(vld1q_f32(input + 0));\n    float16x4_t out1 = vcvt_f16_f32(vld1q_f32(input + 4));\n    vst1q_f16(output, vcombine_f16(out0, out1));\n  }\n\n  static stbir__inline float stbir__half_to_float( stbir__FP16 h )\n  {\n    return vgetq_lane_f32(vcvt_f32_f16(vdup_n_f16(h)), 0);\n  }\n\n  static stbir__inline stbir__FP16 stbir__float_to_half( float f )\n  {\n    return vget_lane_f16(vcvt_f16_f32(vdupq_n_f32(f)), 0);\n  }\n\n#elif defined(STBIR_WASM) || (defined(STBIR_NEON) && (defined(_MSC_VER) || defined(_M_ARM) || defined(__arm__))) // WASM or 32-bit ARM on MSVC/clang\n\n  static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)\n  {\n    for (int i=0; i<8; i++)\n    {\n      output[i] = stbir__half_to_float(input[i]);\n    }\n  }\n  static stbir__inline void stbir__float_to_half_SIMD(stbir__FP16 * output, float const * input)\n  {\n    for (int i=0; i<8; i++)\n    {\n      output[i] = stbir__float_to_half(input[i]);\n    }\n  }\n\n#endif\n\n\n#ifdef STBIR_SIMD\n\n#define stbir__simdf_0123to3333( out, reg ) (out) = stbir__simdf_swiz( reg, 3,3,3,3 )\n#define stbir__simdf_0123to2222( out, reg ) (out) = stbir__simdf_swiz( reg, 2,2,2,2 )\n#define stbir__simdf_0123to1111( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,1,1 )\n#define stbir__simdf_0123to0000( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,0 )\n#define stbir__simdf_0123to0003( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,3 )\n#define stbir__simdf_0123to0001( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,1 )\n#define stbir__simdf_0123to1122( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,2,2 )\n#define stbir__simdf_0123to2333( out, reg ) (out) = stbir__simdf_swiz( reg, 2,3,3,3 )\n#define stbir__simdf_0123to0023( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,2,3 )\n#define stbir__simdf_0123to1230( out, reg ) (out) = stbir__simdf_swiz( reg, 1,2,3,0 )\n#define stbir__simdf_0123to2103( out, reg ) (out) = stbir__simdf_swiz( reg, 2,1,0,3 )\n#define stbir__simdf_0123to3210( out, reg ) (out) = stbir__simdf_swiz( reg, 3,2,1,0 )\n#define stbir__simdf_0123to2301( out, reg ) (out) = stbir__simdf_swiz( reg, 2,3,0,1 )\n#define stbir__simdf_0123to3012( out, reg ) (out) = stbir__simdf_swiz( reg, 3,0,1,2 )\n#define stbir__simdf_0123to0011( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,1,1 )\n#define stbir__simdf_0123to1100( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,0,0 )\n#define stbir__simdf_0123to2233( out, reg ) (out) = stbir__simdf_swiz( reg, 2,2,3,3 )\n#define stbir__simdf_0123to1133( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,3,3 )\n#define stbir__simdf_0123to0022( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,2,2 )\n#define stbir__simdf_0123to1032( out, reg ) (out) = stbir__simdf_swiz( reg, 1,0,3,2 )\n\ntypedef union stbir__simdi_u32\n{\n  stbir_uint32 m128i_u32[4];\n  int m128i_i32[4];\n  stbir__simdi m128i_i128;\n} stbir__simdi_u32;\n\nstatic const int STBIR_mask[9] = { 0,0,0,-1,-1,-1,0,0,0 };\n\nstatic const STBIR__SIMDF_CONST(STBIR_max_uint8_as_float,           stbir__max_uint8_as_float);\nstatic const STBIR__SIMDF_CONST(STBIR_max_uint16_as_float,          stbir__max_uint16_as_float);\nstatic const STBIR__SIMDF_CONST(STBIR_max_uint8_as_float_inverted,  stbir__max_uint8_as_float_inverted);\nstatic const STBIR__SIMDF_CONST(STBIR_max_uint16_as_float_inverted, stbir__max_uint16_as_float_inverted);\n\nstatic const STBIR__SIMDF_CONST(STBIR_simd_point5,   0.5f);\nstatic const STBIR__SIMDF_CONST(STBIR_ones,          1.0f);\nstatic const STBIR__SIMDI_CONST(STBIR_almost_zero,   (127 - 13) << 23);\nstatic const STBIR__SIMDI_CONST(STBIR_almost_one,    0x3f7fffff);\nstatic const STBIR__SIMDI_CONST(STBIR_mastissa_mask, 0xff);\nstatic const STBIR__SIMDI_CONST(STBIR_topscale,      0x02000000);\n\n//   Basically, in simd mode, we unroll the proper amount, and we don't want\n//   the non-simd remnant loops to be unroll because they only run a few times\n//   Adding this switch saves about 5K on clang which is Captain Unroll the 3rd.\n#define STBIR_SIMD_STREAMOUT_PTR( star )  STBIR_STREAMOUT_PTR( star )\n#define STBIR_SIMD_NO_UNROLL(ptr) STBIR_NO_UNROLL(ptr)\n#define STBIR_SIMD_NO_UNROLL_LOOP_START STBIR_NO_UNROLL_LOOP_START\n#define STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR STBIR_NO_UNROLL_LOOP_START_INF_FOR\n\n#ifdef STBIR_MEMCPY\n#undef STBIR_MEMCPY\n#endif\n#define STBIR_MEMCPY stbir_simd_memcpy\n\n// override normal use of memcpy with much simpler copy (faster and smaller with our sized copies)\nstatic void stbir_simd_memcpy( void * dest, void const * src, size_t bytes )\n{\n  char STBIR_SIMD_STREAMOUT_PTR (*) d = (char*) dest;\n  char STBIR_SIMD_STREAMOUT_PTR( * ) d_end = ((char*) dest) + bytes;\n  ptrdiff_t ofs_to_src = (char*)src - (char*)dest;\n\n  // check overlaps\n  STBIR_ASSERT( ( ( d >= ( (char*)src) + bytes ) ) || ( ( d + bytes ) <= (char*)src ) );\n\n  if ( bytes < (16*stbir__simdfX_float_count) )\n  {\n    if ( bytes < 16 )\n    {\n      if ( bytes )\n      {\n        STBIR_SIMD_NO_UNROLL_LOOP_START\n        do\n        {\n          STBIR_SIMD_NO_UNROLL(d);\n          d[ 0 ] = d[ ofs_to_src ];\n          ++d;\n        } while ( d < d_end );\n      }\n    }\n    else\n    {\n      stbir__simdf x;\n      // do one unaligned to get us aligned for the stream out below\n      stbir__simdf_load( x, ( d + ofs_to_src ) );\n      stbir__simdf_store( d, x );\n      d = (char*)( ( ( (size_t)d ) + 16 ) & ~15 );\n\n      STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n      for(;;)\n      {\n        STBIR_SIMD_NO_UNROLL(d);\n\n        if ( d > ( d_end - 16 ) )\n        {\n          if ( d == d_end )\n            return;\n          d = d_end - 16;\n        }\n\n        stbir__simdf_load( x, ( d + ofs_to_src ) );\n        stbir__simdf_store( d, x );\n        d += 16;\n      }\n    }\n  }\n  else\n  {\n    stbir__simdfX x0,x1,x2,x3;\n\n    // do one unaligned to get us aligned for the stream out below\n    stbir__simdfX_load( x0, ( d + ofs_to_src ) +  0*stbir__simdfX_float_count );\n    stbir__simdfX_load( x1, ( d + ofs_to_src ) +  4*stbir__simdfX_float_count );\n    stbir__simdfX_load( x2, ( d + ofs_to_src ) +  8*stbir__simdfX_float_count );\n    stbir__simdfX_load( x3, ( d + ofs_to_src ) + 12*stbir__simdfX_float_count );\n    stbir__simdfX_store( d +  0*stbir__simdfX_float_count, x0 );\n    stbir__simdfX_store( d +  4*stbir__simdfX_float_count, x1 );\n    stbir__simdfX_store( d +  8*stbir__simdfX_float_count, x2 );\n    stbir__simdfX_store( d + 12*stbir__simdfX_float_count, x3 );\n    d = (char*)( ( ( (size_t)d ) + (16*stbir__simdfX_float_count) ) & ~((16*stbir__simdfX_float_count)-1) );\n\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      STBIR_SIMD_NO_UNROLL(d);\n\n      if ( d > ( d_end - (16*stbir__simdfX_float_count) ) )\n      {\n        if ( d == d_end )\n          return;\n        d = d_end - (16*stbir__simdfX_float_count);\n      }\n\n      stbir__simdfX_load( x0, ( d + ofs_to_src ) +  0*stbir__simdfX_float_count );\n      stbir__simdfX_load( x1, ( d + ofs_to_src ) +  4*stbir__simdfX_float_count );\n      stbir__simdfX_load( x2, ( d + ofs_to_src ) +  8*stbir__simdfX_float_count );\n      stbir__simdfX_load( x3, ( d + ofs_to_src ) + 12*stbir__simdfX_float_count );\n      stbir__simdfX_store( d +  0*stbir__simdfX_float_count, x0 );\n      stbir__simdfX_store( d +  4*stbir__simdfX_float_count, x1 );\n      stbir__simdfX_store( d +  8*stbir__simdfX_float_count, x2 );\n      stbir__simdfX_store( d + 12*stbir__simdfX_float_count, x3 );\n      d += (16*stbir__simdfX_float_count);\n    }\n  }\n}\n\n// memcpy that is specically intentionally overlapping (src is smaller then dest, so can be\n//   a normal forward copy, bytes is divisible by 4 and bytes is greater than or equal to\n//   the diff between dest and src)\nstatic void stbir_overlapping_memcpy( void * dest, void const * src, size_t bytes )\n{\n  char STBIR_SIMD_STREAMOUT_PTR (*) sd = (char*) src;\n  char STBIR_SIMD_STREAMOUT_PTR( * ) s_end = ((char*) src) + bytes;\n  ptrdiff_t ofs_to_dest = (char*)dest - (char*)src;\n\n  if ( ofs_to_dest >= 16 ) // is the overlap more than 16 away?\n  {\n    char STBIR_SIMD_STREAMOUT_PTR( * ) s_end16 = ((char*) src) + (bytes&~15);\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    do\n    {\n      stbir__simdf x;\n      STBIR_SIMD_NO_UNROLL(sd);\n      stbir__simdf_load( x, sd );\n      stbir__simdf_store(  ( sd + ofs_to_dest ), x );\n      sd += 16;\n    } while ( sd < s_end16 );\n\n    if ( sd == s_end )\n      return;\n  }\n\n  do\n  {\n    STBIR_SIMD_NO_UNROLL(sd);\n    *(int*)( sd + ofs_to_dest ) = *(int*) sd;\n    sd += 4;\n  } while ( sd < s_end );\n}\n\n#else // no SSE2\n\n// when in scalar mode, we let unrolling happen, so this macro just does the __restrict\n#define STBIR_SIMD_STREAMOUT_PTR( star ) STBIR_STREAMOUT_PTR( star )\n#define STBIR_SIMD_NO_UNROLL(ptr)\n#define STBIR_SIMD_NO_UNROLL_LOOP_START\n#define STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n\n#endif // SSE2\n\n\n#ifdef STBIR_PROFILE\n\n#ifndef STBIR_PROFILE_FUNC\n\n#if defined(_x86_64) || defined( __x86_64__ ) || defined( _M_X64 ) || defined(__x86_64) || defined(__SSE2__) || defined(STBIR_SSE) || defined( _M_IX86_FP ) || defined(__i386) || defined( __i386__ ) || defined( _M_IX86 ) || defined( _X86_ )\n\n#ifdef _MSC_VER\n\n  STBIRDEF stbir_uint64 __rdtsc();\n  #define STBIR_PROFILE_FUNC() __rdtsc()\n\n#else // non msvc\n\n  static stbir__inline stbir_uint64 STBIR_PROFILE_FUNC()\n  {\n    stbir_uint32 lo, hi;\n    asm volatile (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi) );\n    return ( ( (stbir_uint64) hi ) << 32 ) | ( (stbir_uint64) lo );\n  }\n\n#endif  // msvc\n\n#elif defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) || defined(__ARM_NEON__)\n\n#if defined( _MSC_VER ) && !defined(__clang__)\n\n  #define STBIR_PROFILE_FUNC() _ReadStatusReg(ARM64_CNTVCT)\n\n#else\n\n  static stbir__inline stbir_uint64 STBIR_PROFILE_FUNC()\n  {\n    stbir_uint64 tsc;\n    asm volatile(\"mrs %0, cntvct_el0\" : \"=r\" (tsc));\n    return tsc;\n  }\n\n#endif\n\n#else // x64, arm\n\n#error Unknown platform for profiling.\n\n#endif  // x64, arm\n\n#endif // STBIR_PROFILE_FUNC\n\n#define STBIR_ONLY_PROFILE_GET_SPLIT_INFO ,stbir__per_split_info * split_info\n#define STBIR_ONLY_PROFILE_SET_SPLIT_INFO ,split_info\n\n#define STBIR_ONLY_PROFILE_BUILD_GET_INFO ,stbir__info * profile_info\n#define STBIR_ONLY_PROFILE_BUILD_SET_INFO ,profile_info\n\n// super light-weight micro profiler\n#define STBIR_PROFILE_START_ll( info, wh ) { stbir_uint64 wh##thiszonetime = STBIR_PROFILE_FUNC(); stbir_uint64 * wh##save_parent_excluded_ptr = info->current_zone_excluded_ptr; stbir_uint64 wh##current_zone_excluded = 0; info->current_zone_excluded_ptr = &wh##current_zone_excluded;\n#define STBIR_PROFILE_END_ll( info, wh ) wh##thiszonetime = STBIR_PROFILE_FUNC() - wh##thiszonetime; info->profile.named.wh += wh##thiszonetime - wh##current_zone_excluded; *wh##save_parent_excluded_ptr += wh##thiszonetime; info->current_zone_excluded_ptr = wh##save_parent_excluded_ptr; }\n#define STBIR_PROFILE_FIRST_START_ll( info, wh ) { int i; info->current_zone_excluded_ptr = &info->profile.named.total; for(i=0;i<STBIR__ARRAY_SIZE(info->profile.array);i++) info->profile.array[i]=0; } STBIR_PROFILE_START_ll( info, wh );\n#define STBIR_PROFILE_CLEAR_EXTRAS_ll( info, num ) { int extra; for(extra=1;extra<(num);extra++) { int i; for(i=0;i<STBIR__ARRAY_SIZE((info)->profile.array);i++) (info)[extra].profile.array[i]=0; } }\n\n// for thread data\n#define STBIR_PROFILE_START( wh ) STBIR_PROFILE_START_ll( split_info, wh )\n#define STBIR_PROFILE_END( wh ) STBIR_PROFILE_END_ll( split_info, wh )\n#define STBIR_PROFILE_FIRST_START( wh ) STBIR_PROFILE_FIRST_START_ll( split_info, wh )\n#define STBIR_PROFILE_CLEAR_EXTRAS() STBIR_PROFILE_CLEAR_EXTRAS_ll( split_info, split_count )\n\n// for build data\n#define STBIR_PROFILE_BUILD_START( wh ) STBIR_PROFILE_START_ll( profile_info, wh )\n#define STBIR_PROFILE_BUILD_END( wh ) STBIR_PROFILE_END_ll( profile_info, wh )\n#define STBIR_PROFILE_BUILD_FIRST_START( wh ) STBIR_PROFILE_FIRST_START_ll( profile_info, wh )\n#define STBIR_PROFILE_BUILD_CLEAR( info ) { int i; for(i=0;i<STBIR__ARRAY_SIZE(info->profile.array);i++) info->profile.array[i]=0; }\n\n#else  // no profile\n\n#define STBIR_ONLY_PROFILE_GET_SPLIT_INFO\n#define STBIR_ONLY_PROFILE_SET_SPLIT_INFO\n\n#define STBIR_ONLY_PROFILE_BUILD_GET_INFO\n#define STBIR_ONLY_PROFILE_BUILD_SET_INFO\n\n#define STBIR_PROFILE_START( wh )\n#define STBIR_PROFILE_END( wh )\n#define STBIR_PROFILE_FIRST_START( wh )\n#define STBIR_PROFILE_CLEAR_EXTRAS( )\n\n#define STBIR_PROFILE_BUILD_START( wh )\n#define STBIR_PROFILE_BUILD_END( wh )\n#define STBIR_PROFILE_BUILD_FIRST_START( wh )\n#define STBIR_PROFILE_BUILD_CLEAR( info )\n\n#endif  // stbir_profile\n\n#ifndef STBIR_CEILF\n#include <math.h>\n#if _MSC_VER <= 1200 // support VC6 for Sean\n#define STBIR_CEILF(x) ((float)ceil((float)(x)))\n#define STBIR_FLOORF(x) ((float)floor((float)(x)))\n#else\n#define STBIR_CEILF(x) ceilf(x)\n#define STBIR_FLOORF(x) floorf(x)\n#endif\n#endif\n\n#ifndef STBIR_MEMCPY\n// For memcpy\n#include <string.h>\n#define STBIR_MEMCPY( dest, src, len ) memcpy( dest, src, len )\n#endif\n\n#ifndef STBIR_SIMD\n\n// memcpy that is specifically intentionally overlapping (src is smaller then dest, so can be\n//   a normal forward copy, bytes is divisible by 4 and bytes is greater than or equal to\n//   the diff between dest and src)\nstatic void stbir_overlapping_memcpy( void * dest, void const * src, size_t bytes )\n{\n  char STBIR_SIMD_STREAMOUT_PTR (*) sd = (char*) src;\n  char STBIR_SIMD_STREAMOUT_PTR( * ) s_end = ((char*) src) + bytes;\n  ptrdiff_t ofs_to_dest = (char*)dest - (char*)src;\n\n  if ( ofs_to_dest >= 8 ) // is the overlap more than 8 away?\n  {\n    char STBIR_SIMD_STREAMOUT_PTR( * ) s_end8 = ((char*) src) + (bytes&~7);\n    STBIR_NO_UNROLL_LOOP_START\n    do\n    {\n      STBIR_NO_UNROLL(sd);\n      *(stbir_uint64*)( sd + ofs_to_dest ) = *(stbir_uint64*) sd;\n      sd += 8;\n    } while ( sd < s_end8 );\n\n    if ( sd == s_end )\n      return;\n  }\n\n  STBIR_NO_UNROLL_LOOP_START\n  do\n  {\n    STBIR_NO_UNROLL(sd);\n    *(int*)( sd + ofs_to_dest ) = *(int*) sd;\n    sd += 4;\n  } while ( sd < s_end );\n}\n\n#endif\n\nstatic float stbir__filter_trapezoid(float x, float scale, void * user_data)\n{\n  float halfscale = scale / 2;\n  float t = 0.5f + halfscale;\n  STBIR_ASSERT(scale <= 1);\n  STBIR__UNUSED(user_data);\n\n  if ( x < 0.0f ) x = -x;\n\n  if (x >= t)\n    return 0.0f;\n  else\n  {\n    float r = 0.5f - halfscale;\n    if (x <= r)\n      return 1.0f;\n    else\n      return (t - x) / scale;\n  }\n}\n\nstatic float stbir__support_trapezoid(float scale, void * user_data)\n{\n  STBIR__UNUSED(user_data);\n  return 0.5f + scale / 2.0f;\n}\n\nstatic float stbir__filter_triangle(float x, float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n\n  if ( x < 0.0f ) x = -x;\n\n  if (x <= 1.0f)\n    return 1.0f - x;\n  else\n    return 0.0f;\n}\n\nstatic float stbir__filter_point(float x, float s, void * user_data)\n{\n  STBIR__UNUSED(x);\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n\n  return 1.0f;\n}\n\nstatic float stbir__filter_cubic(float x, float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n\n  if ( x < 0.0f ) x = -x;\n\n  if (x < 1.0f)\n    return (4.0f + x*x*(3.0f*x - 6.0f))/6.0f;\n  else if (x < 2.0f)\n    return (8.0f + x*(-12.0f + x*(6.0f - x)))/6.0f;\n\n  return (0.0f);\n}\n\nstatic float stbir__filter_catmullrom(float x, float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n\n  if ( x < 0.0f ) x = -x;\n\n  if (x < 1.0f)\n    return 1.0f - x*x*(2.5f - 1.5f*x);\n  else if (x < 2.0f)\n    return 2.0f - x*(4.0f + x*(0.5f*x - 2.5f));\n\n  return (0.0f);\n}\n\nstatic float stbir__filter_mitchell(float x, float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n\n  if ( x < 0.0f ) x = -x;\n\n  if (x < 1.0f)\n    return (16.0f + x*x*(21.0f * x - 36.0f))/18.0f;\n  else if (x < 2.0f)\n    return (32.0f + x*(-60.0f + x*(36.0f - 7.0f*x)))/18.0f;\n\n  return (0.0f);\n}\n\nstatic float stbir__support_zeropoint5(float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n  return 0.5f;\n}\n\nstatic float stbir__support_one(float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n  return 1;\n}\n\nstatic float stbir__support_two(float s, void * user_data)\n{\n  STBIR__UNUSED(s);\n  STBIR__UNUSED(user_data);\n  return 2;\n}\n\n// This is the maximum number of input samples that can affect an output sample\n// with the given filter from the output pixel's perspective\nstatic int stbir__get_filter_pixel_width(stbir__support_callback * support, float scale, void * user_data)\n{\n  STBIR_ASSERT(support != 0);\n\n  if ( scale >= ( 1.0f-stbir__small_float ) ) // upscale\n    return (int)STBIR_CEILF(support(1.0f/scale,user_data) * 2.0f);\n  else\n    return (int)STBIR_CEILF(support(scale,user_data) * 2.0f / scale);\n}\n\n// this is how many coefficents per run of the filter (which is different\n//   from the filter_pixel_width depending on if we are scattering or gathering)\nstatic int stbir__get_coefficient_width(stbir__sampler * samp, int is_gather, void * user_data)\n{\n  float scale = samp->scale_info.scale;\n  stbir__support_callback * support = samp->filter_support;\n\n  switch( is_gather )\n  {\n    case 1:\n      return (int)STBIR_CEILF(support(1.0f / scale, user_data) * 2.0f);\n    case 2:\n      return (int)STBIR_CEILF(support(scale, user_data) * 2.0f / scale);\n    case 0:\n      return (int)STBIR_CEILF(support(scale, user_data) * 2.0f);\n    default:\n      STBIR_ASSERT( (is_gather >= 0 ) && (is_gather <= 2 ) );\n      return 0;\n  }\n}\n\nstatic int stbir__get_contributors(stbir__sampler * samp, int is_gather)\n{\n  if (is_gather)\n      return samp->scale_info.output_sub_size;\n  else\n      return (samp->scale_info.input_full_size + samp->filter_pixel_margin * 2);\n}\n\nstatic int stbir__edge_zero_full( int n, int max )\n{\n  STBIR__UNUSED(n);\n  STBIR__UNUSED(max);\n  return 0; // NOTREACHED\n}\n\nstatic int stbir__edge_clamp_full( int n, int max )\n{\n  if (n < 0)\n    return 0;\n\n  if (n >= max)\n    return max - 1;\n\n  return n; // NOTREACHED\n}\n\nstatic int stbir__edge_reflect_full( int n, int max )\n{\n  if (n < 0)\n  {\n    if (n > -max)\n      return -n;\n    else\n      return max - 1;\n  }\n\n  if (n >= max)\n  {\n    int max2 = max * 2;\n    if (n >= max2)\n      return 0;\n    else\n      return max2 - n - 1;\n  }\n\n  return n; // NOTREACHED\n}\n\nstatic int stbir__edge_wrap_full( int n, int max )\n{\n  if (n >= 0)\n    return (n % max);\n  else\n  {\n    int m = (-n) % max;\n\n    if (m != 0)\n      m = max - m;\n\n    return (m);\n  }\n}\n\ntypedef int stbir__edge_wrap_func( int n, int max );\nstatic stbir__edge_wrap_func * stbir__edge_wrap_slow[] =\n{\n  stbir__edge_clamp_full,    // STBIR_EDGE_CLAMP\n  stbir__edge_reflect_full,  // STBIR_EDGE_REFLECT\n  stbir__edge_wrap_full,     // STBIR_EDGE_WRAP\n  stbir__edge_zero_full,     // STBIR_EDGE_ZERO\n};\n\nstbir__inline static int stbir__edge_wrap(stbir_edge edge, int n, int max)\n{\n  // avoid per-pixel switch\n  if (n >= 0 && n < max)\n      return n;\n  return stbir__edge_wrap_slow[edge]( n, max );\n}\n\n#define STBIR__MERGE_RUNS_PIXEL_THRESHOLD 16\n\n// get information on the extents of a sampler\nstatic void stbir__get_extents( stbir__sampler * samp, stbir__extents * scanline_extents )\n{\n  int j, stop;\n  int left_margin, right_margin;\n  int min_n = 0x7fffffff, max_n = -0x7fffffff;\n  int min_left = 0x7fffffff, max_left = -0x7fffffff;\n  int min_right = 0x7fffffff, max_right = -0x7fffffff;\n  stbir_edge edge = samp->edge;\n  stbir__contributors* contributors = samp->contributors;\n  int output_sub_size = samp->scale_info.output_sub_size;\n  int input_full_size = samp->scale_info.input_full_size;\n  int filter_pixel_margin = samp->filter_pixel_margin;\n\n  STBIR_ASSERT( samp->is_gather );\n\n  stop = output_sub_size;\n  for (j = 0; j < stop; j++ )\n  {\n    STBIR_ASSERT( contributors[j].n1 >= contributors[j].n0 );\n    if ( contributors[j].n0 < min_n )\n    {\n      min_n = contributors[j].n0;\n      stop = j + filter_pixel_margin;  // if we find a new min, only scan another filter width\n      if ( stop > output_sub_size ) stop = output_sub_size;\n    }\n  }\n\n  stop = 0;\n  for (j = output_sub_size - 1; j >= stop; j-- )\n  {\n    STBIR_ASSERT( contributors[j].n1 >= contributors[j].n0 );\n    if ( contributors[j].n1 > max_n )\n    {\n      max_n = contributors[j].n1;\n      stop = j - filter_pixel_margin;  // if we find a new max, only scan another filter width\n      if (stop<0) stop = 0;\n    }\n  }\n\n  STBIR_ASSERT( scanline_extents->conservative.n0 <= min_n );\n  STBIR_ASSERT( scanline_extents->conservative.n1 >= max_n );\n\n  // now calculate how much into the margins we really read\n  left_margin = 0;\n  if ( min_n < 0 )\n  {\n    left_margin = -min_n;\n    min_n = 0;\n  }\n\n  right_margin = 0;\n  if ( max_n >= input_full_size )\n  {\n    right_margin = max_n - input_full_size + 1;\n    max_n = input_full_size - 1;\n  }\n\n  // index 1 is margin pixel extents (how many pixels we hang over the edge)\n  scanline_extents->edge_sizes[0] = left_margin;\n  scanline_extents->edge_sizes[1] = right_margin;\n\n  // index 2 is pixels read from the input\n  scanline_extents->spans[0].n0 = min_n;\n  scanline_extents->spans[0].n1 = max_n;\n  scanline_extents->spans[0].pixel_offset_for_input = min_n;\n\n  // default to no other input range\n  scanline_extents->spans[1].n0 = 0;\n  scanline_extents->spans[1].n1 = -1;\n  scanline_extents->spans[1].pixel_offset_for_input = 0;\n\n  // don't have to do edge calc for zero clamp\n  if ( edge == STBIR_EDGE_ZERO )\n    return;\n\n  // convert margin pixels to the pixels within the input (min and max)\n  for( j = -left_margin ; j < 0 ; j++ )\n  {\n      int p = stbir__edge_wrap( edge, j, input_full_size );\n      if ( p < min_left )\n        min_left = p;\n      if ( p > max_left )\n        max_left = p;\n  }\n\n  for( j = input_full_size ; j < (input_full_size + right_margin) ; j++ )\n  {\n      int p = stbir__edge_wrap( edge, j, input_full_size );\n      if ( p < min_right )\n        min_right = p;\n      if ( p > max_right )\n        max_right = p;\n  }\n\n  // merge the left margin pixel region if it connects within 4 pixels of main pixel region\n  if ( min_left != 0x7fffffff )\n  {\n    if ( ( ( min_left <= min_n ) && ( ( max_left  + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= min_n ) ) ||\n         ( ( min_n <= min_left ) && ( ( max_n  + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= max_left ) ) )\n    {\n      scanline_extents->spans[0].n0 = min_n = stbir__min( min_n, min_left );\n      scanline_extents->spans[0].n1 = max_n = stbir__max( max_n, max_left );\n      scanline_extents->spans[0].pixel_offset_for_input = min_n;\n      left_margin = 0;\n    }\n  }\n\n  // merge the right margin pixel region if it connects within 4 pixels of main pixel region\n  if ( min_right != 0x7fffffff )\n  {\n    if ( ( ( min_right <= min_n ) && ( ( max_right  + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= min_n ) ) ||\n         ( ( min_n <= min_right ) && ( ( max_n  + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= max_right ) ) )\n    {\n      scanline_extents->spans[0].n0 = min_n = stbir__min( min_n, min_right );\n      scanline_extents->spans[0].n1 = max_n = stbir__max( max_n, max_right );\n      scanline_extents->spans[0].pixel_offset_for_input = min_n;\n      right_margin = 0;\n    }\n  }\n\n  STBIR_ASSERT( scanline_extents->conservative.n0 <= min_n );\n  STBIR_ASSERT( scanline_extents->conservative.n1 >= max_n );\n\n  // you get two ranges when you have the WRAP edge mode and you are doing just the a piece of the resize\n  //   so you need to get a second run of pixels from the opposite side of the scanline (which you\n  //   wouldn't need except for WRAP)\n\n\n  // if we can't merge the min_left range, add it as a second range\n  if ( ( left_margin ) && ( min_left != 0x7fffffff ) )\n  {\n    stbir__span * newspan = scanline_extents->spans + 1;\n    STBIR_ASSERT( right_margin == 0 );\n    if ( min_left < scanline_extents->spans[0].n0 )\n    {\n      scanline_extents->spans[1].pixel_offset_for_input = scanline_extents->spans[0].n0;\n      scanline_extents->spans[1].n0 = scanline_extents->spans[0].n0;\n      scanline_extents->spans[1].n1 = scanline_extents->spans[0].n1;\n      --newspan;\n    }\n    newspan->pixel_offset_for_input = min_left;\n    newspan->n0 = -left_margin;\n    newspan->n1 = ( max_left - min_left ) - left_margin;\n    scanline_extents->edge_sizes[0] = 0;  // don't need to copy the left margin, since we are directly decoding into the margin\n    return;\n  }\n\n  // if we can't merge the min_left range, add it as a second range\n  if ( ( right_margin ) && ( min_right != 0x7fffffff ) )\n  {\n    stbir__span * newspan = scanline_extents->spans + 1;\n    if ( min_right < scanline_extents->spans[0].n0 )\n    {\n      scanline_extents->spans[1].pixel_offset_for_input = scanline_extents->spans[0].n0;\n      scanline_extents->spans[1].n0 = scanline_extents->spans[0].n0;\n      scanline_extents->spans[1].n1 = scanline_extents->spans[0].n1;\n      --newspan;\n    }\n    newspan->pixel_offset_for_input = min_right;\n    newspan->n0 = scanline_extents->spans[1].n1 + 1;\n    newspan->n1 = scanline_extents->spans[1].n1 + 1 + ( max_right - min_right );\n    scanline_extents->edge_sizes[1] = 0;  // don't need to copy the right margin, since we are directly decoding into the margin\n    return;\n  }\n}\n\nstatic void stbir__calculate_in_pixel_range( int * first_pixel, int * last_pixel, float out_pixel_center, float out_filter_radius, float inv_scale, float out_shift, int input_size, stbir_edge edge )\n{\n  int first, last;\n  float out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius;\n  float out_pixel_influence_upperbound = out_pixel_center + out_filter_radius;\n\n  float in_pixel_influence_lowerbound = (out_pixel_influence_lowerbound + out_shift) * inv_scale;\n  float in_pixel_influence_upperbound = (out_pixel_influence_upperbound + out_shift) * inv_scale;\n\n  first = (int)(STBIR_FLOORF(in_pixel_influence_lowerbound + 0.5f));\n  last = (int)(STBIR_FLOORF(in_pixel_influence_upperbound - 0.5f));\n  if ( last < first ) last = first; // point sample mode can span a value *right* at 0.5, and cause these to cross\n\n  if ( edge == STBIR_EDGE_WRAP )\n  {\n    if ( first < -input_size )\n      first = -input_size;\n    if ( last >= (input_size*2))\n      last = (input_size*2) - 1;\n  }\n\n  *first_pixel = first;\n  *last_pixel = last;\n}\n\nstatic void stbir__calculate_coefficients_for_gather_upsample( float out_filter_radius, stbir__kernel_callback * kernel, stbir__scale_info * scale_info, int num_contributors, stbir__contributors* contributors, float* coefficient_group, int coefficient_width, stbir_edge edge, void * user_data )\n{\n  int n, end;\n  float inv_scale = scale_info->inv_scale;\n  float out_shift = scale_info->pixel_shift;\n  int input_size  = scale_info->input_full_size;\n  int numerator = scale_info->scale_numerator;\n  int polyphase = ( ( scale_info->scale_is_rational ) && ( numerator < num_contributors ) );\n\n  // Looping through out pixels\n  end = num_contributors; if ( polyphase ) end = numerator;\n  for (n = 0; n < end; n++)\n  {\n    int i;\n    int last_non_zero;\n    float out_pixel_center = (float)n + 0.5f;\n    float in_center_of_out = (out_pixel_center + out_shift) * inv_scale;\n\n    int in_first_pixel, in_last_pixel;\n\n    stbir__calculate_in_pixel_range( &in_first_pixel, &in_last_pixel, out_pixel_center, out_filter_radius, inv_scale, out_shift, input_size, edge );\n\n    // make sure we never generate a range larger than our precalculated coeff width\n    //   this only happens in point sample mode, but it's a good safe thing to do anyway\n    if ( ( in_last_pixel - in_first_pixel + 1 ) > coefficient_width )\n      in_last_pixel = in_first_pixel + coefficient_width - 1;\n\n    last_non_zero = -1;\n    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)\n    {\n      float in_pixel_center = (float)(i + in_first_pixel) + 0.5f;\n      float coeff = kernel(in_center_of_out - in_pixel_center, inv_scale, user_data);\n\n      // kill denormals\n      if ( ( ( coeff < stbir__small_float ) && ( coeff > -stbir__small_float ) ) )\n      {\n        if ( i == 0 )  // if we're at the front, just eat zero contributors\n        {\n          STBIR_ASSERT ( ( in_last_pixel - in_first_pixel ) != 0 ); // there should be at least one contrib\n          ++in_first_pixel;\n          i--;\n          continue;\n        }\n        coeff = 0;  // make sure is fully zero (should keep denormals away)\n      }\n      else\n        last_non_zero = i;\n\n      coefficient_group[i] = coeff;\n    }\n\n    in_last_pixel = last_non_zero+in_first_pixel; // kills trailing zeros\n    contributors->n0 = in_first_pixel;\n    contributors->n1 = in_last_pixel;\n\n    STBIR_ASSERT(contributors->n1 >= contributors->n0);\n\n    ++contributors;\n    coefficient_group += coefficient_width;\n  }\n}\n\nstatic void stbir__insert_coeff( stbir__contributors * contribs, float * coeffs, int new_pixel, float new_coeff, int max_width )\n{\n  if ( new_pixel <= contribs->n1 )  // before the end\n  {\n    if ( new_pixel < contribs->n0 ) // before the front?\n    {\n      if ( ( contribs->n1 - new_pixel + 1 ) <= max_width )\n      { \n        int j, o = contribs->n0 - new_pixel;\n        for ( j = contribs->n1 - contribs->n0 ; j <= 0 ; j-- )\n          coeffs[ j + o ] = coeffs[ j ];\n        for ( j = 1 ; j < o ; j-- )\n          coeffs[ j ] = coeffs[ 0 ];\n        coeffs[ 0 ] = new_coeff;\n        contribs->n0 = new_pixel;\n      }\n    }\n    else\n    {\n      coeffs[ new_pixel - contribs->n0 ] += new_coeff;\n    }\n  }\n  else\n  {\n    if ( ( new_pixel - contribs->n0 + 1 ) <= max_width )\n    {\n      int j, e = new_pixel - contribs->n0;\n      for( j = ( contribs->n1 - contribs->n0 ) + 1 ; j < e ; j++ ) // clear in-betweens coeffs if there are any\n        coeffs[j] = 0;\n\n      coeffs[ e ] = new_coeff;\n      contribs->n1 = new_pixel;\n    }\n  }\n}\n\nstatic void stbir__calculate_out_pixel_range( int * first_pixel, int * last_pixel, float in_pixel_center, float in_pixels_radius, float scale, float out_shift, int out_size )\n{\n  float in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius;\n  float in_pixel_influence_upperbound = in_pixel_center + in_pixels_radius;\n  float out_pixel_influence_lowerbound = in_pixel_influence_lowerbound * scale - out_shift;\n  float out_pixel_influence_upperbound = in_pixel_influence_upperbound * scale - out_shift;\n  int out_first_pixel = (int)(STBIR_FLOORF(out_pixel_influence_lowerbound + 0.5f));\n  int out_last_pixel = (int)(STBIR_FLOORF(out_pixel_influence_upperbound - 0.5f));\n\n  if ( out_first_pixel < 0 )\n    out_first_pixel = 0;\n  if ( out_last_pixel >= out_size )\n    out_last_pixel = out_size - 1;\n  *first_pixel = out_first_pixel;\n  *last_pixel = out_last_pixel;\n}\n\nstatic void stbir__calculate_coefficients_for_gather_downsample( int start, int end, float in_pixels_radius, stbir__kernel_callback * kernel, stbir__scale_info * scale_info, int coefficient_width, int num_contributors, stbir__contributors * contributors, float * coefficient_group, void * user_data )\n{\n  int in_pixel;\n  int i;\n  int first_out_inited = -1;\n  float scale = scale_info->scale;\n  float out_shift = scale_info->pixel_shift;\n  int out_size = scale_info->output_sub_size;\n  int numerator = scale_info->scale_numerator;\n  int polyphase = ( ( scale_info->scale_is_rational ) && ( numerator < out_size ) );\n\n  STBIR__UNUSED(num_contributors);\n\n  // Loop through the input pixels\n  for (in_pixel = start; in_pixel < end; in_pixel++)\n  {\n    float in_pixel_center = (float)in_pixel + 0.5f;\n    float out_center_of_in = in_pixel_center * scale - out_shift;\n    int out_first_pixel, out_last_pixel;\n\n    stbir__calculate_out_pixel_range( &out_first_pixel, &out_last_pixel, in_pixel_center, in_pixels_radius, scale, out_shift, out_size );\n\n    if ( out_first_pixel > out_last_pixel )\n      continue;\n\n    // clamp or exit if we are using polyphase filtering, and the limit is up\n    if ( polyphase )\n    {\n      // when polyphase, you only have to do coeffs up to the numerator count\n      if ( out_first_pixel == numerator )\n        break;\n\n      // don't do any extra work, clamp last pixel at numerator too\n      if ( out_last_pixel >= numerator )\n        out_last_pixel = numerator - 1;\n    }\n\n    for (i = 0; i <= out_last_pixel - out_first_pixel; i++)\n    {\n      float out_pixel_center = (float)(i + out_first_pixel) + 0.5f;\n      float x = out_pixel_center - out_center_of_in;\n      float coeff = kernel(x, scale, user_data) * scale;\n\n      // kill the coeff if it's too small (avoid denormals)\n      if ( ( ( coeff < stbir__small_float ) && ( coeff > -stbir__small_float ) ) )\n        coeff = 0.0f;\n\n      {\n        int out = i + out_first_pixel;\n        float * coeffs = coefficient_group + out * coefficient_width;\n        stbir__contributors * contribs = contributors + out;\n\n        // is this the first time this output pixel has been seen?  Init it.\n        if ( out > first_out_inited )\n        {\n          STBIR_ASSERT( out == ( first_out_inited + 1 ) ); // ensure we have only advanced one at time\n          first_out_inited = out;\n          contribs->n0 = in_pixel;\n          contribs->n1 = in_pixel;\n          coeffs[0]  = coeff;\n        }\n        else\n        {\n          // insert on end (always in order)\n          if ( coeffs[0] == 0.0f )  // if the first coefficent is zero, then zap it for this coeffs\n          {\n            STBIR_ASSERT( ( in_pixel - contribs->n0 ) == 1 ); // ensure that when we zap, we're at the 2nd pos\n            contribs->n0 = in_pixel;\n          }\n          contribs->n1 = in_pixel;\n          STBIR_ASSERT( ( in_pixel - contribs->n0 ) < coefficient_width );\n          coeffs[in_pixel - contribs->n0]  = coeff;\n        }\n      }\n    }\n  }\n}\n\n#ifdef STBIR_RENORMALIZE_IN_FLOAT\n#define STBIR_RENORM_TYPE float\n#else\n#define STBIR_RENORM_TYPE double\n#endif\n\nstatic void stbir__cleanup_gathered_coefficients( stbir_edge edge, stbir__filter_extent_info* filter_info, stbir__scale_info * scale_info, int num_contributors, stbir__contributors* contributors, float * coefficient_group, int coefficient_width )\n{\n  int input_size = scale_info->input_full_size;\n  int input_last_n1 = input_size - 1;\n  int n, end;\n  int lowest = 0x7fffffff;\n  int highest = -0x7fffffff;\n  int widest = -1;\n  int numerator = scale_info->scale_numerator;\n  int denominator = scale_info->scale_denominator;\n  int polyphase = ( ( scale_info->scale_is_rational ) && ( numerator < num_contributors ) );\n  float * coeffs;\n  stbir__contributors * contribs;\n\n  // weight all the coeffs for each sample\n  coeffs = coefficient_group;\n  contribs = contributors;\n  end = num_contributors; if ( polyphase ) end = numerator;\n  for (n = 0; n < end; n++)\n  {\n    int i;\n    STBIR_RENORM_TYPE filter_scale, total_filter = 0;\n    int e;\n\n    // add all contribs\n    e = contribs->n1 - contribs->n0;\n    for( i = 0 ; i <= e ; i++ )\n    {\n      total_filter += (STBIR_RENORM_TYPE) coeffs[i];\n      STBIR_ASSERT( ( coeffs[i] >= -2.0f ) && ( coeffs[i] <= 2.0f )  ); // check for wonky weights\n    }\n\n    // rescale\n    if ( ( total_filter < stbir__small_float ) && ( total_filter > -stbir__small_float ) )\n    {\n      // all coeffs are extremely small, just zero it\n      contribs->n1 = contribs->n0;\n      coeffs[0] = 0.0f;\n    }\n    else\n    {\n      // if the total isn't 1.0, rescale everything\n      if ( ( total_filter < (1.0f-stbir__small_float) ) || ( total_filter > (1.0f+stbir__small_float) ) )\n      {\n        filter_scale = ((STBIR_RENORM_TYPE)1.0) / total_filter;\n\n        // scale them all\n        for (i = 0; i <= e; i++)\n          coeffs[i] = (float) ( coeffs[i] * filter_scale );\n      }\n    }\n    ++contribs;\n    coeffs += coefficient_width;\n  }\n\n  // if we have a rational for the scale, we can exploit the polyphaseness to not calculate\n  //   most of the coefficients, so we copy them here\n  if ( polyphase )\n  {\n    stbir__contributors * prev_contribs = contributors;\n    stbir__contributors * cur_contribs = contributors + numerator;\n\n    for( n = numerator ; n < num_contributors ; n++ )\n    {\n      cur_contribs->n0 = prev_contribs->n0 + denominator;\n      cur_contribs->n1 = prev_contribs->n1 + denominator;\n      ++cur_contribs;\n      ++prev_contribs;\n    }\n    stbir_overlapping_memcpy( coefficient_group + numerator * coefficient_width, coefficient_group, ( num_contributors - numerator ) * coefficient_width * sizeof( coeffs[ 0 ] ) );\n  }\n\n  coeffs = coefficient_group;\n  contribs = contributors;\n\n  for (n = 0; n < num_contributors; n++)\n  {\n    int i;\n\n    // in zero edge mode, just remove out of bounds contribs completely (since their weights are accounted for now)\n    if ( edge == STBIR_EDGE_ZERO )\n    {\n      // shrink the right side if necessary\n      if ( contribs->n1 > input_last_n1 )\n        contribs->n1 = input_last_n1;\n\n      // shrink the left side\n      if ( contribs->n0 < 0 )\n      {\n        int j, left, skips = 0;\n\n        skips = -contribs->n0;\n        contribs->n0 = 0;\n\n        // now move down the weights\n        left = contribs->n1 - contribs->n0 + 1;\n        if ( left > 0 )\n        {\n          for( j = 0 ; j < left ; j++ )\n            coeffs[ j ] = coeffs[ j + skips ];\n        }\n      }\n    }\n    else if ( ( edge == STBIR_EDGE_CLAMP ) || ( edge == STBIR_EDGE_REFLECT ) )\n    {\n      // for clamp and reflect, calculate the true inbounds position (based on edge type) and just add that to the existing weight\n\n      // right hand side first\n      if ( contribs->n1 > input_last_n1 )\n      {\n        int start = contribs->n0;\n        int endi = contribs->n1;\n        contribs->n1 = input_last_n1;\n        for( i = input_size; i <= endi; i++ )\n          stbir__insert_coeff( contribs, coeffs, stbir__edge_wrap_slow[edge]( i, input_size ), coeffs[i-start], coefficient_width );\n      }\n\n      // now check left hand edge\n      if ( contribs->n0 < 0 )\n      {\n        int save_n0;\n        float save_n0_coeff;\n        float * c = coeffs - ( contribs->n0 + 1 );\n\n        // reinsert the coeffs with it reflected or clamped (insert accumulates, if the coeffs exist)\n        for( i = -1 ; i > contribs->n0 ; i-- )\n          stbir__insert_coeff( contribs, coeffs, stbir__edge_wrap_slow[edge]( i, input_size ), *c--, coefficient_width );\n        save_n0 = contribs->n0;\n        save_n0_coeff = c[0]; // save it, since we didn't do the final one (i==n0), because there might be too many coeffs to hold (before we resize)!\n\n        // now slide all the coeffs down (since we have accumulated them in the positive contribs) and reset the first contrib\n        contribs->n0 = 0;\n        for(i = 0 ; i <= contribs->n1 ; i++ )\n          coeffs[i] = coeffs[i-save_n0];\n\n        // now that we have shrunk down the contribs, we insert the first one safely\n        stbir__insert_coeff( contribs, coeffs, stbir__edge_wrap_slow[edge]( save_n0, input_size ), save_n0_coeff, coefficient_width );\n      }\n    }\n\n    if ( contribs->n0 <= contribs->n1 )\n    {\n      int diff = contribs->n1 - contribs->n0 + 1;\n      while ( diff && ( coeffs[ diff-1 ] == 0.0f ) )\n        --diff;\n\n      contribs->n1 = contribs->n0 + diff - 1;\n\n      if ( contribs->n0 <= contribs->n1 )\n      {\n        if ( contribs->n0 < lowest )\n          lowest = contribs->n0;\n        if ( contribs->n1 > highest )\n          highest = contribs->n1;\n        if ( diff > widest )\n          widest = diff;\n      }\n\n      // re-zero out unused coefficients (if any)\n      for( i = diff ; i < coefficient_width ; i++ )\n        coeffs[i] = 0.0f;\n    }\n\n    ++contribs;\n    coeffs += coefficient_width;\n  }\n  filter_info->lowest = lowest;\n  filter_info->highest = highest;\n  filter_info->widest = widest;\n}\n\n#undef STBIR_RENORM_TYPE \n\nstatic int stbir__pack_coefficients( int num_contributors, stbir__contributors* contributors, float * coefficents, int coefficient_width, int widest, int row0, int row1 ) \n{\n  #define STBIR_MOVE_1( dest, src ) { STBIR_NO_UNROLL(dest); ((stbir_uint32*)(dest))[0] = ((stbir_uint32*)(src))[0]; }\n  #define STBIR_MOVE_2( dest, src ) { STBIR_NO_UNROLL(dest); ((stbir_uint64*)(dest))[0] = ((stbir_uint64*)(src))[0]; }\n  #ifdef STBIR_SIMD\n  #define STBIR_MOVE_4( dest, src ) { stbir__simdf t; STBIR_NO_UNROLL(dest); stbir__simdf_load( t, src ); stbir__simdf_store( dest, t ); }\n  #else\n  #define STBIR_MOVE_4( dest, src ) { STBIR_NO_UNROLL(dest); ((stbir_uint64*)(dest))[0] = ((stbir_uint64*)(src))[0]; ((stbir_uint64*)(dest))[1] = ((stbir_uint64*)(src))[1]; }\n  #endif\n\n  int row_end = row1 + 1;\n  STBIR__UNUSED( row0 ); // only used in an assert\n\n  if ( coefficient_width != widest )\n  {\n    float * pc = coefficents;\n    float * coeffs = coefficents;\n    float * pc_end = coefficents + num_contributors * widest;\n    switch( widest )\n    {\n      case 1:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_1( pc, coeffs );\n          ++pc;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 2:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_2( pc, coeffs );\n          pc += 2;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 3:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_2( pc, coeffs );\n          STBIR_MOVE_1( pc+2, coeffs+2 );\n          pc += 3;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 4:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          pc += 4;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 5:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_1( pc+4, coeffs+4 );\n          pc += 5;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 6:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_2( pc+4, coeffs+4 );\n          pc += 6;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 7:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_2( pc+4, coeffs+4 );\n          STBIR_MOVE_1( pc+6, coeffs+6 );\n          pc += 7;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 8:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_4( pc+4, coeffs+4 );\n          pc += 8;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 9:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_4( pc+4, coeffs+4 );\n          STBIR_MOVE_1( pc+8, coeffs+8 );\n          pc += 9;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 10:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_4( pc+4, coeffs+4 );\n          STBIR_MOVE_2( pc+8, coeffs+8 );\n          pc += 10;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 11:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_4( pc+4, coeffs+4 );\n          STBIR_MOVE_2( pc+8, coeffs+8 );\n          STBIR_MOVE_1( pc+10, coeffs+10 );\n          pc += 11;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      case 12:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          STBIR_MOVE_4( pc, coeffs );\n          STBIR_MOVE_4( pc+4, coeffs+4 );\n          STBIR_MOVE_4( pc+8, coeffs+8 );\n          pc += 12;\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n      default:\n        STBIR_NO_UNROLL_LOOP_START\n        do {\n          float * copy_end = pc + widest - 4;\n          float * c = coeffs;\n          do {\n            STBIR_NO_UNROLL( pc );\n            STBIR_MOVE_4( pc, c );\n            pc += 4;\n            c += 4;\n          } while ( pc <= copy_end );\n          copy_end += 4;\n          STBIR_NO_UNROLL_LOOP_START\n          while ( pc < copy_end )\n          {\n            STBIR_MOVE_1( pc, c );\n            ++pc; ++c;\n          }\n          coeffs += coefficient_width;\n        } while ( pc < pc_end );\n        break;\n    }\n  }\n\n  // some horizontal routines read one float off the end (which is then masked off), so put in a sentinal so we don't read an snan or denormal\n  coefficents[ widest * num_contributors ] = 8888.0f;\n\n  // the minimum we might read for unrolled filters widths is 12. So, we need to\n  //   make sure we never read outside the decode buffer, by possibly moving\n  //   the sample area back into the scanline, and putting zeros weights first.\n  // we start on the right edge and check until we're well past the possible\n  //   clip area (2*widest).\n  {\n    stbir__contributors * contribs = contributors + num_contributors - 1;\n    float * coeffs = coefficents + widest * ( num_contributors - 1 );\n\n    // go until no chance of clipping (this is usually less than 8 lops)\n    while ( ( contribs >= contributors ) && ( ( contribs->n0 + widest*2 ) >= row_end ) )\n    {\n      // might we clip??\n      if ( ( contribs->n0 + widest ) > row_end )\n      {\n        int stop_range = widest;\n\n        // if range is larger than 12, it will be handled by generic loops that can terminate on the exact length\n        //   of this contrib n1, instead of a fixed widest amount - so calculate this\n        if ( widest > 12 )\n        {\n          int mod;\n\n          // how far will be read in the n_coeff loop (which depends on the widest count mod4);\n          mod = widest & 3;\n          stop_range = ( ( ( contribs->n1 - contribs->n0 + 1 ) - mod + 3 ) & ~3 ) + mod;\n\n          // the n_coeff loops do a minimum amount of coeffs, so factor that in!\n          if ( stop_range < ( 8 + mod ) ) stop_range = 8 + mod;\n        }\n\n        // now see if we still clip with the refined range\n        if ( ( contribs->n0 + stop_range ) > row_end )\n        {\n          int new_n0 = row_end - stop_range;\n          int num = contribs->n1 - contribs->n0 + 1;\n          int backup = contribs->n0 - new_n0;\n          float * from_co = coeffs + num - 1;\n          float * to_co = from_co + backup;\n\n          STBIR_ASSERT( ( new_n0 >= row0 ) && ( new_n0 < contribs->n0 ) );\n\n          // move the coeffs over\n          while( num )\n          {\n            *to_co-- = *from_co--;\n            --num;\n          }\n          // zero new positions\n          while ( to_co >= coeffs )\n            *to_co-- = 0;\n          // set new start point\n          contribs->n0 = new_n0;\n          if ( widest > 12 )\n          {\n            int mod;\n\n            // how far will be read in the n_coeff loop (which depends on the widest count mod4);\n            mod = widest & 3;\n            stop_range = ( ( ( contribs->n1 - contribs->n0 + 1 ) - mod + 3 ) & ~3 ) + mod;\n\n            // the n_coeff loops do a minimum amount of coeffs, so factor that in!\n            if ( stop_range < ( 8 + mod ) ) stop_range = 8 + mod;\n          }\n        }\n      }\n      --contribs;\n      coeffs -= widest;\n    }\n  }\n\n  return widest;\n  #undef STBIR_MOVE_1\n  #undef STBIR_MOVE_2\n  #undef STBIR_MOVE_4\n}\n\nstatic void stbir__calculate_filters( stbir__sampler * samp, stbir__sampler * other_axis_for_pivot, void * user_data STBIR_ONLY_PROFILE_BUILD_GET_INFO )\n{\n  int n;\n  float scale = samp->scale_info.scale;\n  stbir__kernel_callback * kernel = samp->filter_kernel;\n  stbir__support_callback * support = samp->filter_support;\n  float inv_scale = samp->scale_info.inv_scale;\n  int input_full_size = samp->scale_info.input_full_size;\n  int gather_num_contributors = samp->num_contributors;\n  stbir__contributors* gather_contributors = samp->contributors;\n  float * gather_coeffs = samp->coefficients;\n  int gather_coefficient_width = samp->coefficient_width;\n\n  switch ( samp->is_gather )\n  {\n    case 1: // gather upsample\n    {\n      float out_pixels_radius = support(inv_scale,user_data) * scale;\n\n      stbir__calculate_coefficients_for_gather_upsample( out_pixels_radius, kernel, &samp->scale_info, gather_num_contributors, gather_contributors, gather_coeffs, gather_coefficient_width, samp->edge, user_data );\n\n      STBIR_PROFILE_BUILD_START( cleanup );\n      stbir__cleanup_gathered_coefficients( samp->edge, &samp->extent_info, &samp->scale_info, gather_num_contributors, gather_contributors, gather_coeffs, gather_coefficient_width );\n      STBIR_PROFILE_BUILD_END( cleanup );\n    }\n    break;\n\n    case 0: // scatter downsample (only on vertical)\n    case 2: // gather downsample\n    {\n      float in_pixels_radius = support(scale,user_data) * inv_scale;\n      int filter_pixel_margin = samp->filter_pixel_margin;\n      int input_end = input_full_size + filter_pixel_margin;\n\n      // if this is a scatter, we do a downsample gather to get the coeffs, and then pivot after\n      if ( !samp->is_gather )\n      {\n        // check if we are using the same gather downsample on the horizontal as this vertical,\n        //   if so, then we don't have to generate them, we can just pivot from the horizontal.\n        if ( other_axis_for_pivot )\n        {\n          gather_contributors = other_axis_for_pivot->contributors;\n          gather_coeffs = other_axis_for_pivot->coefficients;\n          gather_coefficient_width = other_axis_for_pivot->coefficient_width;\n          gather_num_contributors = other_axis_for_pivot->num_contributors;\n          samp->extent_info.lowest = other_axis_for_pivot->extent_info.lowest;\n          samp->extent_info.highest = other_axis_for_pivot->extent_info.highest;\n          samp->extent_info.widest = other_axis_for_pivot->extent_info.widest;\n          goto jump_right_to_pivot;\n        }\n\n        gather_contributors = samp->gather_prescatter_contributors;\n        gather_coeffs = samp->gather_prescatter_coefficients;\n        gather_coefficient_width = samp->gather_prescatter_coefficient_width;\n        gather_num_contributors = samp->gather_prescatter_num_contributors;\n      }\n\n      stbir__calculate_coefficients_for_gather_downsample( -filter_pixel_margin, input_end, in_pixels_radius, kernel, &samp->scale_info, gather_coefficient_width, gather_num_contributors, gather_contributors, gather_coeffs, user_data );\n\n      STBIR_PROFILE_BUILD_START( cleanup );\n      stbir__cleanup_gathered_coefficients( samp->edge, &samp->extent_info, &samp->scale_info, gather_num_contributors, gather_contributors, gather_coeffs, gather_coefficient_width );\n      STBIR_PROFILE_BUILD_END( cleanup );\n\n      if ( !samp->is_gather )\n      {\n        // if this is a scatter (vertical only), then we need to pivot the coeffs\n        stbir__contributors * scatter_contributors;\n        int highest_set;\n\n        jump_right_to_pivot:\n\n        STBIR_PROFILE_BUILD_START( pivot );\n\n        highest_set = (-filter_pixel_margin) - 1;\n        for (n = 0; n < gather_num_contributors; n++)\n        {\n          int k;\n          int gn0 = gather_contributors->n0, gn1 = gather_contributors->n1;\n          int scatter_coefficient_width = samp->coefficient_width;\n          float * scatter_coeffs = samp->coefficients + ( gn0 + filter_pixel_margin ) * scatter_coefficient_width;\n          float * g_coeffs = gather_coeffs;\n          scatter_contributors = samp->contributors + ( gn0 + filter_pixel_margin );\n\n          for (k = gn0 ; k <= gn1 ; k++ )\n          {\n            float gc = *g_coeffs++;\n            \n            // skip zero and denormals - must skip zeros to avoid adding coeffs beyond scatter_coefficient_width\n            //   (which happens when pivoting from horizontal, which might have dummy zeros)\n            if ( ( ( gc >= stbir__small_float ) || ( gc <= -stbir__small_float ) ) )\n            {\n              if ( ( k > highest_set ) || ( scatter_contributors->n0 > scatter_contributors->n1 ) )\n              {\n                {\n                  // if we are skipping over several contributors, we need to clear the skipped ones\n                  stbir__contributors * clear_contributors = samp->contributors + ( highest_set + filter_pixel_margin + 1);\n                  while ( clear_contributors < scatter_contributors )\n                  {\n                    clear_contributors->n0 = 0;\n                    clear_contributors->n1 = -1;\n                    ++clear_contributors;\n                  }\n                }\n                scatter_contributors->n0 = n;\n                scatter_contributors->n1 = n;\n                scatter_coeffs[0]  = gc;\n                highest_set = k;\n              }\n              else\n              {\n                stbir__insert_coeff( scatter_contributors, scatter_coeffs, n, gc, scatter_coefficient_width );\n              }\n              STBIR_ASSERT( ( scatter_contributors->n1 - scatter_contributors->n0 + 1 ) <= scatter_coefficient_width );\n            }\n            ++scatter_contributors;\n            scatter_coeffs += scatter_coefficient_width;\n          }\n\n          ++gather_contributors;\n          gather_coeffs += gather_coefficient_width;\n        }\n\n        // now clear any unset contribs\n        {\n          stbir__contributors * clear_contributors = samp->contributors + ( highest_set + filter_pixel_margin + 1);\n          stbir__contributors * end_contributors = samp->contributors + samp->num_contributors;\n          while ( clear_contributors < end_contributors )\n          {\n            clear_contributors->n0 = 0;\n            clear_contributors->n1 = -1;\n            ++clear_contributors;\n          }\n        }\n\n        STBIR_PROFILE_BUILD_END( pivot );\n      }\n    }\n    break;\n  }\n}\n\n\n//========================================================================================================\n// scanline decoders and encoders\n\n#define stbir__coder_min_num 1\n#define STB_IMAGE_RESIZE_DO_CODERS\n#include STBIR__HEADER_FILENAME\n\n#define stbir__decode_suffix BGRA\n#define stbir__decode_swizzle\n#define stbir__decode_order0  2\n#define stbir__decode_order1  1\n#define stbir__decode_order2  0\n#define stbir__decode_order3  3\n#define stbir__encode_order0  2\n#define stbir__encode_order1  1\n#define stbir__encode_order2  0\n#define stbir__encode_order3  3\n#define stbir__coder_min_num 4\n#define STB_IMAGE_RESIZE_DO_CODERS\n#include STBIR__HEADER_FILENAME\n\n#define stbir__decode_suffix ARGB\n#define stbir__decode_swizzle\n#define stbir__decode_order0  1\n#define stbir__decode_order1  2\n#define stbir__decode_order2  3\n#define stbir__decode_order3  0\n#define stbir__encode_order0  3\n#define stbir__encode_order1  0\n#define stbir__encode_order2  1\n#define stbir__encode_order3  2\n#define stbir__coder_min_num 4\n#define STB_IMAGE_RESIZE_DO_CODERS\n#include STBIR__HEADER_FILENAME\n\n#define stbir__decode_suffix ABGR\n#define stbir__decode_swizzle\n#define stbir__decode_order0  3\n#define stbir__decode_order1  2\n#define stbir__decode_order2  1\n#define stbir__decode_order3  0\n#define stbir__encode_order0  3\n#define stbir__encode_order1  2\n#define stbir__encode_order2  1\n#define stbir__encode_order3  0\n#define stbir__coder_min_num 4\n#define STB_IMAGE_RESIZE_DO_CODERS\n#include STBIR__HEADER_FILENAME\n\n#define stbir__decode_suffix AR\n#define stbir__decode_swizzle\n#define stbir__decode_order0  1\n#define stbir__decode_order1  0\n#define stbir__decode_order2  3\n#define stbir__decode_order3  2\n#define stbir__encode_order0  1\n#define stbir__encode_order1  0\n#define stbir__encode_order2  3\n#define stbir__encode_order3  2\n#define stbir__coder_min_num 2\n#define STB_IMAGE_RESIZE_DO_CODERS\n#include STBIR__HEADER_FILENAME\n\n\n// fancy alpha means we expand to keep both premultipied and non-premultiplied color channels\nstatic void stbir__fancy_alpha_weight_4ch( float * out_buffer, int width_times_channels )\n{\n  float STBIR_STREAMOUT_PTR(*) out = out_buffer;\n  float const * end_decode = out_buffer + ( width_times_channels / 4 ) * 7;  // decode buffer aligned to end of out_buffer\n  float STBIR_STREAMOUT_PTR(*) decode = (float*)end_decode - width_times_channels;\n\n  // fancy alpha is stored internally as R G B A Rpm Gpm Bpm\n\n  #ifdef STBIR_SIMD\n\n  #ifdef STBIR_SIMD8\n  decode += 16;\n  STBIR_NO_UNROLL_LOOP_START\n  while ( decode <= end_decode )\n  {\n    stbir__simdf8 d0,d1,a0,a1,p0,p1;\n    STBIR_NO_UNROLL(decode);\n    stbir__simdf8_load( d0, decode-16 );\n    stbir__simdf8_load( d1, decode-16+8 );\n    stbir__simdf8_0123to33333333( a0, d0 );\n    stbir__simdf8_0123to33333333( a1, d1 );\n    stbir__simdf8_mult( p0, a0, d0 );\n    stbir__simdf8_mult( p1, a1, d1 );\n    stbir__simdf8_bot4s( a0, d0, p0 );\n    stbir__simdf8_bot4s( a1, d1, p1 );\n    stbir__simdf8_top4s( d0, d0, p0 );\n    stbir__simdf8_top4s( d1, d1, p1 );\n    stbir__simdf8_store ( out, a0 );\n    stbir__simdf8_store ( out+7, d0 );\n    stbir__simdf8_store ( out+14, a1 );\n    stbir__simdf8_store ( out+21, d1 );\n    decode += 16;\n    out += 28;\n  }\n  decode -= 16;\n  #else\n  decode += 8;\n  STBIR_NO_UNROLL_LOOP_START\n  while ( decode <= end_decode )\n  {\n    stbir__simdf d0,a0,d1,a1,p0,p1;\n    STBIR_NO_UNROLL(decode);\n    stbir__simdf_load( d0, decode-8 );\n    stbir__simdf_load( d1, decode-8+4 );\n    stbir__simdf_0123to3333( a0, d0 );\n    stbir__simdf_0123to3333( a1, d1 );\n    stbir__simdf_mult( p0, a0, d0 );\n    stbir__simdf_mult( p1, a1, d1 );\n    stbir__simdf_store ( out, d0 );\n    stbir__simdf_store ( out+4, p0 );\n    stbir__simdf_store ( out+7, d1 );\n    stbir__simdf_store ( out+7+4, p1 );\n    decode += 8;\n    out += 14;\n  }\n  decode -= 8;\n  #endif\n\n  // might be one last odd pixel\n  #ifdef STBIR_SIMD8\n  STBIR_NO_UNROLL_LOOP_START\n  while ( decode < end_decode )\n  #else\n  if ( decode < end_decode )\n  #endif\n  {\n    stbir__simdf d,a,p;\n    STBIR_NO_UNROLL(decode);\n    stbir__simdf_load( d, decode );\n    stbir__simdf_0123to3333( a, d );\n    stbir__simdf_mult( p, a, d );\n    stbir__simdf_store ( out, d );\n    stbir__simdf_store ( out+4, p );\n    decode += 4;\n    out += 7;\n  }\n\n  #else\n\n  while( decode < end_decode )\n  {\n    float r = decode[0], g = decode[1], b = decode[2], alpha = decode[3];\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = alpha;\n    out[4] = r * alpha;\n    out[5] = g * alpha;\n    out[6] = b * alpha;\n    out += 7;\n    decode += 4;\n  }\n\n  #endif\n}\n\nstatic void stbir__fancy_alpha_weight_2ch( float * out_buffer, int width_times_channels )\n{\n  float STBIR_STREAMOUT_PTR(*) out = out_buffer;\n  float const * end_decode = out_buffer + ( width_times_channels / 2 ) * 3;\n  float STBIR_STREAMOUT_PTR(*) decode = (float*)end_decode - width_times_channels;\n\n  //  for fancy alpha, turns into: [X A Xpm][X A Xpm],etc\n\n  #ifdef STBIR_SIMD\n\n  decode += 8;\n  if ( decode <= end_decode )\n  {\n    STBIR_NO_UNROLL_LOOP_START\n    do {\n      #ifdef STBIR_SIMD8\n      stbir__simdf8 d0,a0,p0;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdf8_load( d0, decode-8 );\n      stbir__simdf8_0123to11331133( p0, d0 );\n      stbir__simdf8_0123to00220022( a0, d0 );\n      stbir__simdf8_mult( p0, p0, a0 );\n\n      stbir__simdf_store2( out, stbir__if_simdf8_cast_to_simdf4( d0 ) );\n      stbir__simdf_store( out+2, stbir__if_simdf8_cast_to_simdf4( p0 ) );\n      stbir__simdf_store2h( out+3, stbir__if_simdf8_cast_to_simdf4( d0 ) );\n\n      stbir__simdf_store2( out+6, stbir__simdf8_gettop4( d0 ) );\n      stbir__simdf_store( out+8, stbir__simdf8_gettop4( p0 ) );\n      stbir__simdf_store2h( out+9, stbir__simdf8_gettop4( d0 ) );\n      #else\n      stbir__simdf d0,a0,d1,a1,p0,p1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdf_load( d0, decode-8 );\n      stbir__simdf_load( d1, decode-8+4 );\n      stbir__simdf_0123to1133( p0, d0 );\n      stbir__simdf_0123to1133( p1, d1 );\n      stbir__simdf_0123to0022( a0, d0 );\n      stbir__simdf_0123to0022( a1, d1 );\n      stbir__simdf_mult( p0, p0, a0 );\n      stbir__simdf_mult( p1, p1, a1 );\n\n      stbir__simdf_store2( out, d0 );\n      stbir__simdf_store( out+2, p0 );\n      stbir__simdf_store2h( out+3, d0 );\n\n      stbir__simdf_store2( out+6, d1 );\n      stbir__simdf_store( out+8, p1 );\n      stbir__simdf_store2h( out+9, d1 );\n      #endif\n      decode += 8;\n      out += 12;\n    } while ( decode <= end_decode );\n  }\n  decode -= 8;\n  #endif\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode < end_decode )\n  {\n    float x = decode[0], y = decode[1];\n    STBIR_SIMD_NO_UNROLL(decode);\n    out[0] = x;\n    out[1] = y;\n    out[2] = x * y;\n    out += 3;\n    decode += 2;\n  }\n}\n\nstatic void stbir__fancy_alpha_unweight_4ch( float * encode_buffer, int width_times_channels )\n{\n  float STBIR_SIMD_STREAMOUT_PTR(*) encode = encode_buffer;\n  float STBIR_SIMD_STREAMOUT_PTR(*) input = encode_buffer;\n  float const * end_output = encode_buffer + width_times_channels;\n\n  // fancy RGBA is stored internally as R G B A Rpm Gpm Bpm\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float alpha = input[3];\n#ifdef STBIR_SIMD\n    stbir__simdf i,ia;\n    STBIR_SIMD_NO_UNROLL(encode);\n    if ( alpha < stbir__small_float )\n    {\n      stbir__simdf_load( i, input );\n      stbir__simdf_store( encode, i );\n    }\n    else\n    {\n      stbir__simdf_load1frep4( ia, 1.0f / alpha );\n      stbir__simdf_load( i, input+4 );\n      stbir__simdf_mult( i, i, ia );\n      stbir__simdf_store( encode, i );\n      encode[3] = alpha;\n    }\n#else\n    if ( alpha < stbir__small_float )\n    {\n      encode[0] = input[0];\n      encode[1] = input[1];\n      encode[2] = input[2];\n    }\n    else\n    {\n      float ialpha = 1.0f / alpha;\n      encode[0] = input[4] * ialpha;\n      encode[1] = input[5] * ialpha;\n      encode[2] = input[6] * ialpha;\n    }\n    encode[3] = alpha;\n#endif\n\n    input += 7;\n    encode += 4;\n  } while ( encode < end_output );\n}\n\n//  format: [X A Xpm][X A Xpm] etc\nstatic void stbir__fancy_alpha_unweight_2ch( float * encode_buffer, int width_times_channels )\n{\n  float STBIR_SIMD_STREAMOUT_PTR(*) encode = encode_buffer;\n  float STBIR_SIMD_STREAMOUT_PTR(*) input = encode_buffer;\n  float const * end_output = encode_buffer + width_times_channels;\n\n  do {\n    float alpha = input[1];\n    encode[0] = input[0];\n    if ( alpha >= stbir__small_float )\n      encode[0] = input[2] / alpha;\n    encode[1] = alpha;\n\n    input += 3;\n    encode += 2;\n  } while ( encode < end_output );\n}\n\nstatic void stbir__simple_alpha_weight_4ch( float * decode_buffer, int width_times_channels )\n{\n  float STBIR_STREAMOUT_PTR(*) decode = decode_buffer;\n  float const * end_decode = decode_buffer + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  {\n    decode += 2 * stbir__simdfX_float_count;\n    STBIR_NO_UNROLL_LOOP_START\n    while ( decode <= end_decode )\n    {\n      stbir__simdfX d0,a0,d1,a1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdfX_load( d0, decode-2*stbir__simdfX_float_count );\n      stbir__simdfX_load( d1, decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count );\n      stbir__simdfX_aaa1( a0, d0, STBIR_onesX );\n      stbir__simdfX_aaa1( a1, d1, STBIR_onesX );\n      stbir__simdfX_mult( d0, d0, a0 );\n      stbir__simdfX_mult( d1, d1, a1 );\n      stbir__simdfX_store ( decode-2*stbir__simdfX_float_count, d0 );\n      stbir__simdfX_store ( decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count, d1 );\n      decode += 2 * stbir__simdfX_float_count;\n    }\n    decode -= 2 * stbir__simdfX_float_count;\n\n    // few last pixels remnants\n    #ifdef STBIR_SIMD8\n    STBIR_NO_UNROLL_LOOP_START\n    while ( decode < end_decode )\n    #else\n    if ( decode < end_decode )\n    #endif\n    {\n      stbir__simdf d,a;\n      stbir__simdf_load( d, decode );\n      stbir__simdf_aaa1( a, d, STBIR__CONSTF(STBIR_ones) );\n      stbir__simdf_mult( d, d, a );\n      stbir__simdf_store ( decode, d );\n      decode += 4;\n    }\n  }\n\n  #else\n\n  while( decode < end_decode )\n  {\n    float alpha = decode[3];\n    decode[0] *= alpha;\n    decode[1] *= alpha;\n    decode[2] *= alpha;\n    decode += 4;\n  }\n\n  #endif\n}\n\nstatic void stbir__simple_alpha_weight_2ch( float * decode_buffer, int width_times_channels )\n{\n  float STBIR_STREAMOUT_PTR(*) decode = decode_buffer;\n  float const * end_decode = decode_buffer + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  decode += 2 * stbir__simdfX_float_count;\n  STBIR_NO_UNROLL_LOOP_START\n  while ( decode <= end_decode )\n  {\n    stbir__simdfX d0,a0,d1,a1;\n    STBIR_NO_UNROLL(decode);\n    stbir__simdfX_load( d0, decode-2*stbir__simdfX_float_count );\n    stbir__simdfX_load( d1, decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count );\n    stbir__simdfX_a1a1( a0, d0, STBIR_onesX );\n    stbir__simdfX_a1a1( a1, d1, STBIR_onesX );\n    stbir__simdfX_mult( d0, d0, a0 );\n    stbir__simdfX_mult( d1, d1, a1 );\n    stbir__simdfX_store ( decode-2*stbir__simdfX_float_count, d0 );\n    stbir__simdfX_store ( decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count, d1 );\n    decode += 2 * stbir__simdfX_float_count;\n  }\n  decode -= 2 * stbir__simdfX_float_count;\n  #endif\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode < end_decode )\n  {\n    float alpha = decode[1];\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0] *= alpha;\n    decode += 2;\n  }\n}\n\nstatic void stbir__simple_alpha_unweight_4ch( float * encode_buffer, int width_times_channels )\n{\n  float STBIR_SIMD_STREAMOUT_PTR(*) encode = encode_buffer;\n  float const * end_output = encode_buffer + width_times_channels;\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float alpha = encode[3];\n\n#ifdef STBIR_SIMD\n    stbir__simdf i,ia;\n    STBIR_SIMD_NO_UNROLL(encode);\n    if ( alpha >= stbir__small_float )\n    {\n      stbir__simdf_load1frep4( ia, 1.0f / alpha );\n      stbir__simdf_load( i, encode );\n      stbir__simdf_mult( i, i, ia );\n      stbir__simdf_store( encode, i );\n      encode[3] = alpha;\n    }\n#else\n    if ( alpha >= stbir__small_float )\n    {\n      float ialpha = 1.0f / alpha;\n      encode[0] *= ialpha;\n      encode[1] *= ialpha;\n      encode[2] *= ialpha;\n    }\n#endif\n    encode += 4;\n  } while ( encode < end_output );\n}\n\nstatic void stbir__simple_alpha_unweight_2ch( float * encode_buffer, int width_times_channels )\n{\n  float STBIR_SIMD_STREAMOUT_PTR(*) encode = encode_buffer;\n  float const * end_output = encode_buffer + width_times_channels;\n\n  do {\n    float alpha = encode[1];\n    if ( alpha >= stbir__small_float )\n      encode[0] /= alpha;\n    encode += 2;\n  } while ( encode < end_output );\n}\n\n\n// only used in RGB->BGR or BGR->RGB\nstatic void stbir__simple_flip_3ch( float * decode_buffer, int width_times_channels )\n{\n  float STBIR_STREAMOUT_PTR(*) decode = decode_buffer;\n  float const * end_decode = decode_buffer + width_times_channels;\n\n#ifdef STBIR_SIMD\n    #ifdef stbir__simdf_swiz2 // do we have two argument swizzles?\n      end_decode -= 12; \n      STBIR_NO_UNROLL_LOOP_START\n      while( decode <= end_decode )\n      {\n        // on arm64 8 instructions, no overlapping stores\n        stbir__simdf a,b,c,na,nb;\n        STBIR_SIMD_NO_UNROLL(decode);\n        stbir__simdf_load( a, decode );\n        stbir__simdf_load( b, decode+4 );\n        stbir__simdf_load( c, decode+8 );\n\n        na = stbir__simdf_swiz2( a, b, 2, 1, 0, 5 );   \n        b  = stbir__simdf_swiz2( a, b, 4, 3, 6, 7 );   \n        nb = stbir__simdf_swiz2( b, c, 0, 1, 4, 3 );   \n        c  = stbir__simdf_swiz2( b, c, 2, 7, 6, 5 );   \n\n        stbir__simdf_store( decode, na );\n        stbir__simdf_store( decode+4, nb ); \n        stbir__simdf_store( decode+8, c );\n        decode += 12;\n      }\n      end_decode += 12;\n    #else\n      end_decode -= 24;\n      STBIR_NO_UNROLL_LOOP_START\n      while( decode <= end_decode )\n      {\n        // 26 instructions on x64\n        stbir__simdf a,b,c,d,e,f,g;\n        float i21, i23;\n        STBIR_SIMD_NO_UNROLL(decode);\n        stbir__simdf_load( a, decode );\n        stbir__simdf_load( b, decode+3 );\n        stbir__simdf_load( c, decode+6 );\n        stbir__simdf_load( d, decode+9 );\n        stbir__simdf_load( e, decode+12 );\n        stbir__simdf_load( f, decode+15 );\n        stbir__simdf_load( g, decode+18 );\n\n        a = stbir__simdf_swiz( a, 2, 1, 0, 3 );   \n        b = stbir__simdf_swiz( b, 2, 1, 0, 3 );   \n        c = stbir__simdf_swiz( c, 2, 1, 0, 3 );   \n        d = stbir__simdf_swiz( d, 2, 1, 0, 3 );   \n        e = stbir__simdf_swiz( e, 2, 1, 0, 3 );   \n        f = stbir__simdf_swiz( f, 2, 1, 0, 3 );   \n        g = stbir__simdf_swiz( g, 2, 1, 0, 3 );   \n\n        // stores overlap, need to be in order, \n        stbir__simdf_store( decode,    a );\n        i21 = decode[21];\n        stbir__simdf_store( decode+3,  b ); \n        i23 = decode[23];\n        stbir__simdf_store( decode+6,  c );\n        stbir__simdf_store( decode+9,  d );\n        stbir__simdf_store( decode+12, e );\n        stbir__simdf_store( decode+15, f );\n        stbir__simdf_store( decode+18, g );\n        decode[21] = i23;\n        decode[23] = i21;\n        decode += 24;\n      }\n      end_decode += 24;\n    #endif\n#else\n  end_decode -= 12;\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode <= end_decode )\n  {\n    // 16 instructions\n    float t0,t1,t2,t3;\n    STBIR_NO_UNROLL(decode);\n    t0 = decode[0]; t1 = decode[3]; t2 = decode[6]; t3 = decode[9];\n    decode[0] = decode[2]; decode[3] = decode[5]; decode[6] = decode[8]; decode[9] = decode[11];\n    decode[2] = t0; decode[5] = t1; decode[8] = t2; decode[11] = t3;\n    decode += 12;\n  }\n  end_decode += 12;\n#endif\n\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < end_decode )\n  {\n    float t = decode[0];\n    STBIR_NO_UNROLL(decode);\n    decode[0] = decode[2];\n    decode[2] = t;\n    decode += 3;\n  }\n}\n\n\n\nstatic void stbir__decode_scanline(stbir__info const * stbir_info, int n, float * output_buffer STBIR_ONLY_PROFILE_GET_SPLIT_INFO )\n{\n  int channels = stbir_info->channels;\n  int effective_channels = stbir_info->effective_channels;\n  int input_sample_in_bytes = stbir__type_size[stbir_info->input_type] * channels;\n  stbir_edge edge_horizontal = stbir_info->horizontal.edge;\n  stbir_edge edge_vertical = stbir_info->vertical.edge;\n  int row = stbir__edge_wrap(edge_vertical, n, stbir_info->vertical.scale_info.input_full_size);\n  const void* input_plane_data = ( (char *) stbir_info->input_data ) + (size_t)row * (size_t) stbir_info->input_stride_bytes;\n  stbir__span const * spans = stbir_info->scanline_extents.spans;\n  float* full_decode_buffer = output_buffer - stbir_info->scanline_extents.conservative.n0 * effective_channels;\n\n  // if we are on edge_zero, and we get in here with an out of bounds n, then the calculate filters has failed\n  STBIR_ASSERT( !(edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->vertical.scale_info.input_full_size)) );\n\n  do\n  {\n    float * decode_buffer;\n    void const * input_data;\n    float * end_decode;\n    int width_times_channels;\n    int width;\n\n    if ( spans->n1 < spans->n0 )\n      break;\n\n    width = spans->n1 + 1 - spans->n0;\n    decode_buffer = full_decode_buffer + spans->n0 * effective_channels;\n    end_decode = full_decode_buffer + ( spans->n1 + 1 ) * effective_channels;\n    width_times_channels = width * channels;\n\n    // read directly out of input plane by default\n    input_data = ( (char*)input_plane_data ) + spans->pixel_offset_for_input * input_sample_in_bytes;\n\n    // if we have an input callback, call it to get the input data\n    if ( stbir_info->in_pixels_cb )\n    {\n      // call the callback with a temp buffer (that they can choose to use or not).  the temp is just right aligned memory in the decode_buffer itself\n      input_data = stbir_info->in_pixels_cb( ( (char*) end_decode ) - ( width * input_sample_in_bytes ), input_plane_data, width, spans->pixel_offset_for_input, row, stbir_info->user_data );\n    }\n\n    STBIR_PROFILE_START( decode );\n    // convert the pixels info the float decode_buffer, (we index from end_decode, so that when channels<effective_channels, we are right justified in the buffer)\n    stbir_info->decode_pixels( (float*)end_decode - width_times_channels, width_times_channels, input_data );\n    STBIR_PROFILE_END( decode );\n\n    if (stbir_info->alpha_weight)\n    {\n      STBIR_PROFILE_START( alpha );\n      stbir_info->alpha_weight( decode_buffer, width_times_channels );\n      STBIR_PROFILE_END( alpha );\n    }\n\n    ++spans;\n  } while ( spans <= ( &stbir_info->scanline_extents.spans[1] ) );\n\n  // handle the edge_wrap filter (all other types are handled back out at the calculate_filter stage)\n  // basically the idea here is that if we have the whole scanline in memory, we don't redecode the\n  //   wrapped edge pixels, and instead just memcpy them from the scanline into the edge positions\n  if ( ( edge_horizontal == STBIR_EDGE_WRAP ) && ( stbir_info->scanline_extents.edge_sizes[0] | stbir_info->scanline_extents.edge_sizes[1] ) )\n  {\n    // this code only runs if we're in edge_wrap, and we're doing the entire scanline\n    int e, start_x[2];\n    int input_full_size = stbir_info->horizontal.scale_info.input_full_size;\n\n    start_x[0] = -stbir_info->scanline_extents.edge_sizes[0];  // left edge start x\n    start_x[1] =  input_full_size;                             // right edge\n\n    for( e = 0; e < 2 ; e++ )\n    {\n      // do each margin\n      int margin = stbir_info->scanline_extents.edge_sizes[e];\n      if ( margin )\n      {\n        int x = start_x[e];\n        float * marg = full_decode_buffer + x * effective_channels;\n        float const * src = full_decode_buffer + stbir__edge_wrap(edge_horizontal, x, input_full_size) * effective_channels;\n        STBIR_MEMCPY( marg, src, margin * effective_channels * sizeof(float) );\n      }\n    }\n  }\n}\n\n\n//=================\n// Do 1 channel horizontal routines\n\n#ifdef STBIR_SIMD\n\n#define stbir__1_coeff_only()          \\\n    stbir__simdf tot,c;                \\\n    STBIR_SIMD_NO_UNROLL(decode);      \\\n    stbir__simdf_load1( c, hc );       \\\n    stbir__simdf_mult1_mem( tot, c, decode );\n\n#define stbir__2_coeff_only()          \\\n    stbir__simdf tot,c,d;              \\\n    STBIR_SIMD_NO_UNROLL(decode);      \\\n    stbir__simdf_load2z( c, hc );      \\\n    stbir__simdf_load2( d, decode );   \\\n    stbir__simdf_mult( tot, c, d );    \\\n    stbir__simdf_0123to1230( c, tot ); \\\n    stbir__simdf_add1( tot, tot, c );\n\n#define stbir__3_coeff_only()                  \\\n    stbir__simdf tot,c,t;                      \\\n    STBIR_SIMD_NO_UNROLL(decode);              \\\n    stbir__simdf_load( c, hc );                \\\n    stbir__simdf_mult_mem( tot, c, decode );   \\\n    stbir__simdf_0123to1230( c, tot );         \\\n    stbir__simdf_0123to2301( t, tot );         \\\n    stbir__simdf_add1( tot, tot, c );          \\\n    stbir__simdf_add1( tot, tot, t );\n\n#define stbir__store_output_tiny()                \\\n    stbir__simdf_store1( output, tot );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 1;\n\n#define stbir__4_coeff_start()                 \\\n    stbir__simdf tot,c;                        \\\n    STBIR_SIMD_NO_UNROLL(decode);              \\\n    stbir__simdf_load( c, hc );                \\\n    stbir__simdf_mult_mem( tot, c, decode );   \\\n\n#define stbir__4_coeff_continue_from_4( ofs )  \\\n    STBIR_SIMD_NO_UNROLL(decode);              \\\n    stbir__simdf_load( c, hc + (ofs) );        \\\n    stbir__simdf_madd_mem( tot, tot, c, decode+(ofs) );\n\n#define stbir__1_coeff_remnant( ofs )          \\\n    { stbir__simdf d;                          \\\n    stbir__simdf_load1z( c, hc + (ofs) );      \\\n    stbir__simdf_load1( d, decode + (ofs) );   \\\n    stbir__simdf_madd( tot, tot, d, c ); }\n\n#define stbir__2_coeff_remnant( ofs )          \\\n    { stbir__simdf d;                          \\\n    stbir__simdf_load2z( c, hc+(ofs) );        \\\n    stbir__simdf_load2( d, decode+(ofs) );     \\\n    stbir__simdf_madd( tot, tot, d, c ); }\n\n#define stbir__3_coeff_setup()                 \\\n    stbir__simdf mask;                         \\\n    stbir__simdf_load( mask, STBIR_mask + 3 );\n\n#define stbir__3_coeff_remnant( ofs )                  \\\n    stbir__simdf_load( c, hc+(ofs) );                  \\\n    stbir__simdf_and( c, c, mask );                    \\\n    stbir__simdf_madd_mem( tot, tot, c, decode+(ofs) );\n\n#define stbir__store_output()                     \\\n    stbir__simdf_0123to2301( c, tot );            \\\n    stbir__simdf_add( tot, tot, c );              \\\n    stbir__simdf_0123to1230( c, tot );            \\\n    stbir__simdf_add1( tot, tot, c );             \\\n    stbir__simdf_store1( output, tot );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 1;\n\n#else\n\n#define stbir__1_coeff_only()  \\\n    float tot;                 \\\n    tot = decode[0]*hc[0];\n\n#define stbir__2_coeff_only()  \\\n    float tot;                 \\\n    tot = decode[0] * hc[0];   \\\n    tot += decode[1] * hc[1];\n\n#define stbir__3_coeff_only()  \\\n    float tot;                 \\\n    tot = decode[0] * hc[0];   \\\n    tot += decode[1] * hc[1];  \\\n    tot += decode[2] * hc[2];\n\n#define stbir__store_output_tiny()                \\\n    output[0] = tot;                              \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 1;\n\n#define stbir__4_coeff_start()  \\\n    float tot0,tot1,tot2,tot3;  \\\n    tot0 = decode[0] * hc[0];   \\\n    tot1 = decode[1] * hc[1];   \\\n    tot2 = decode[2] * hc[2];   \\\n    tot3 = decode[3] * hc[3];\n\n#define stbir__4_coeff_continue_from_4( ofs )  \\\n    tot0 += decode[0+(ofs)] * hc[0+(ofs)];     \\\n    tot1 += decode[1+(ofs)] * hc[1+(ofs)];     \\\n    tot2 += decode[2+(ofs)] * hc[2+(ofs)];     \\\n    tot3 += decode[3+(ofs)] * hc[3+(ofs)];\n\n#define stbir__1_coeff_remnant( ofs )        \\\n    tot0 += decode[0+(ofs)] * hc[0+(ofs)];\n\n#define stbir__2_coeff_remnant( ofs )        \\\n    tot0 += decode[0+(ofs)] * hc[0+(ofs)];   \\\n    tot1 += decode[1+(ofs)] * hc[1+(ofs)];   \\\n\n#define stbir__3_coeff_remnant( ofs )        \\\n    tot0 += decode[0+(ofs)] * hc[0+(ofs)];   \\\n    tot1 += decode[1+(ofs)] * hc[1+(ofs)];   \\\n    tot2 += decode[2+(ofs)] * hc[2+(ofs)];\n\n#define stbir__store_output()                     \\\n    output[0] = (tot0+tot2)+(tot1+tot3);          \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 1;\n\n#endif\n\n#define STBIR__horizontal_channels 1\n#define STB_IMAGE_RESIZE_DO_HORIZONTALS\n#include STBIR__HEADER_FILENAME\n\n\n//=================\n// Do 2 channel horizontal routines\n\n#ifdef STBIR_SIMD\n\n#define stbir__1_coeff_only()         \\\n    stbir__simdf tot,c,d;             \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    stbir__simdf_load1z( c, hc );     \\\n    stbir__simdf_0123to0011( c, c );  \\\n    stbir__simdf_load2( d, decode );  \\\n    stbir__simdf_mult( tot, d, c );\n\n#define stbir__2_coeff_only()         \\\n    stbir__simdf tot,c;               \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    stbir__simdf_load2( c, hc );      \\\n    stbir__simdf_0123to0011( c, c );  \\\n    stbir__simdf_mult_mem( tot, c, decode );\n\n#define stbir__3_coeff_only()                \\\n    stbir__simdf tot,c,cs,d;                 \\\n    STBIR_SIMD_NO_UNROLL(decode);            \\\n    stbir__simdf_load( cs, hc );             \\\n    stbir__simdf_0123to0011( c, cs );        \\\n    stbir__simdf_mult_mem( tot, c, decode ); \\\n    stbir__simdf_0123to2222( c, cs );        \\\n    stbir__simdf_load2z( d, decode+4 );      \\\n    stbir__simdf_madd( tot, tot, d, c );\n\n#define stbir__store_output_tiny()                \\\n    stbir__simdf_0123to2301( c, tot );            \\\n    stbir__simdf_add( tot, tot, c );              \\\n    stbir__simdf_store2( output, tot );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 2;\n\n#ifdef STBIR_SIMD8\n\n#define stbir__4_coeff_start()                    \\\n    stbir__simdf8 tot0,c,cs;                      \\\n    STBIR_SIMD_NO_UNROLL(decode);                 \\\n    stbir__simdf8_load4b( cs, hc );               \\\n    stbir__simdf8_0123to00112233( c, cs );        \\\n    stbir__simdf8_mult_mem( tot0, c, decode );\n\n#define stbir__4_coeff_continue_from_4( ofs )        \\\n    STBIR_SIMD_NO_UNROLL(decode);                    \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );          \\\n    stbir__simdf8_0123to00112233( c, cs );           \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*2 );\n\n#define stbir__1_coeff_remnant( ofs )                \\\n    { stbir__simdf t,d;                              \\\n    stbir__simdf_load1z( t, hc + (ofs) );            \\\n    stbir__simdf_load2( d, decode + (ofs) * 2 );     \\\n    stbir__simdf_0123to0011( t, t );                 \\\n    stbir__simdf_mult( t, t, d );                    \\\n    stbir__simdf8_add4( tot0, tot0, t ); }\n \n#define stbir__2_coeff_remnant( ofs )                \\\n    { stbir__simdf t;                                \\\n    stbir__simdf_load2( t, hc + (ofs) );             \\\n    stbir__simdf_0123to0011( t, t );                 \\\n    stbir__simdf_mult_mem( t, t, decode+(ofs)*2 );   \\\n    stbir__simdf8_add4( tot0, tot0, t ); }\n\n#define stbir__3_coeff_remnant( ofs )                \\\n    { stbir__simdf8 d;                               \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );          \\\n    stbir__simdf8_0123to00112233( c, cs );           \\\n    stbir__simdf8_load6z( d, decode+(ofs)*2 );       \\\n    stbir__simdf8_madd( tot0, tot0, c, d ); }\n\n#define stbir__store_output()                     \\\n    { stbir__simdf t,d;                           \\\n    stbir__simdf8_add4halves( t, stbir__if_simdf8_cast_to_simdf4(tot0), tot0 );    \\\n    stbir__simdf_0123to2301( d, t );              \\\n    stbir__simdf_add( t, t, d );                  \\\n    stbir__simdf_store2( output, t );             \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 2; }\n\n#else\n\n#define stbir__4_coeff_start()                   \\\n    stbir__simdf tot0,tot1,c,cs;                 \\\n    STBIR_SIMD_NO_UNROLL(decode);                \\\n    stbir__simdf_load( cs, hc );                 \\\n    stbir__simdf_0123to0011( c, cs );            \\\n    stbir__simdf_mult_mem( tot0, c, decode );    \\\n    stbir__simdf_0123to2233( c, cs );            \\\n    stbir__simdf_mult_mem( tot1, c, decode+4 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                \\\n    STBIR_SIMD_NO_UNROLL(decode);                            \\\n    stbir__simdf_load( cs, hc + (ofs) );                     \\\n    stbir__simdf_0123to0011( c, cs );                        \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*2 );  \\\n    stbir__simdf_0123to2233( c, cs );                        \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*2+4 );\n\n#define stbir__1_coeff_remnant( ofs )            \\\n    { stbir__simdf d;                            \\\n    stbir__simdf_load1z( cs, hc + (ofs) );       \\\n    stbir__simdf_0123to0011( c, cs );            \\\n    stbir__simdf_load2( d, decode + (ofs) * 2 ); \\\n    stbir__simdf_madd( tot0, tot0, d, c ); }\n\n#define stbir__2_coeff_remnant( ofs )                      \\\n    stbir__simdf_load2( cs, hc + (ofs) );                  \\\n    stbir__simdf_0123to0011( c, cs );                      \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*2 );\n\n#define stbir__3_coeff_remnant( ofs )                       \\\n    { stbir__simdf d;                                       \\\n    stbir__simdf_load( cs, hc + (ofs) );                    \\\n    stbir__simdf_0123to0011( c, cs );                       \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*2 ); \\\n    stbir__simdf_0123to2222( c, cs );                       \\\n    stbir__simdf_load2z( d, decode + (ofs) * 2 + 4 );       \\\n    stbir__simdf_madd( tot1, tot1, d, c ); }\n\n#define stbir__store_output()                     \\\n    stbir__simdf_add( tot0, tot0, tot1 );         \\\n    stbir__simdf_0123to2301( c, tot0 );           \\\n    stbir__simdf_add( tot0, tot0, c );            \\\n    stbir__simdf_store2( output, tot0 );          \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 2;\n\n#endif\n\n#else\n\n#define stbir__1_coeff_only()  \\\n    float tota,totb,c;         \\\n    c = hc[0];                 \\\n    tota = decode[0]*c;        \\\n    totb = decode[1]*c;\n\n#define stbir__2_coeff_only()  \\\n    float tota,totb,c;         \\\n    c = hc[0];                 \\\n    tota = decode[0]*c;        \\\n    totb = decode[1]*c;        \\\n    c = hc[1];                 \\\n    tota += decode[2]*c;       \\\n    totb += decode[3]*c;\n\n// this weird order of add matches the simd\n#define stbir__3_coeff_only()  \\\n    float tota,totb,c;         \\\n    c = hc[0];                 \\\n    tota = decode[0]*c;        \\\n    totb = decode[1]*c;        \\\n    c = hc[2];                 \\\n    tota += decode[4]*c;       \\\n    totb += decode[5]*c;       \\\n    c = hc[1];                 \\\n    tota += decode[2]*c;       \\\n    totb += decode[3]*c;\n\n#define stbir__store_output_tiny()                \\\n    output[0] = tota;                             \\\n    output[1] = totb;                             \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 2;\n\n#define stbir__4_coeff_start()      \\\n    float tota0,tota1,tota2,tota3,totb0,totb1,totb2,totb3,c;  \\\n    c = hc[0];                      \\\n    tota0 = decode[0]*c;            \\\n    totb0 = decode[1]*c;            \\\n    c = hc[1];                      \\\n    tota1 = decode[2]*c;            \\\n    totb1 = decode[3]*c;            \\\n    c = hc[2];                      \\\n    tota2 = decode[4]*c;            \\\n    totb2 = decode[5]*c;            \\\n    c = hc[3];                      \\\n    tota3 = decode[6]*c;            \\\n    totb3 = decode[7]*c;\n\n#define stbir__4_coeff_continue_from_4( ofs )  \\\n    c = hc[0+(ofs)];                           \\\n    tota0 += decode[0+(ofs)*2]*c;              \\\n    totb0 += decode[1+(ofs)*2]*c;              \\\n    c = hc[1+(ofs)];                           \\\n    tota1 += decode[2+(ofs)*2]*c;              \\\n    totb1 += decode[3+(ofs)*2]*c;              \\\n    c = hc[2+(ofs)];                           \\\n    tota2 += decode[4+(ofs)*2]*c;              \\\n    totb2 += decode[5+(ofs)*2]*c;              \\\n    c = hc[3+(ofs)];                           \\\n    tota3 += decode[6+(ofs)*2]*c;              \\\n    totb3 += decode[7+(ofs)*2]*c;\n\n#define stbir__1_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*2] * c;    \\\n    totb0 += decode[1+(ofs)*2] * c;\n\n#define stbir__2_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*2] * c;    \\\n    totb0 += decode[1+(ofs)*2] * c;    \\\n    c = hc[1+(ofs)];                   \\\n    tota1 += decode[2+(ofs)*2] * c;    \\\n    totb1 += decode[3+(ofs)*2] * c;\n\n#define stbir__3_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*2] * c;    \\\n    totb0 += decode[1+(ofs)*2] * c;    \\\n    c = hc[1+(ofs)];                   \\\n    tota1 += decode[2+(ofs)*2] * c;    \\\n    totb1 += decode[3+(ofs)*2] * c;    \\\n    c = hc[2+(ofs)];                   \\\n    tota2 += decode[4+(ofs)*2] * c;    \\\n    totb2 += decode[5+(ofs)*2] * c;\n\n#define stbir__store_output()                     \\\n    output[0] = (tota0+tota2)+(tota1+tota3);      \\\n    output[1] = (totb0+totb2)+(totb1+totb3);      \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 2;\n\n#endif\n\n#define STBIR__horizontal_channels 2\n#define STB_IMAGE_RESIZE_DO_HORIZONTALS\n#include STBIR__HEADER_FILENAME\n\n\n//=================\n// Do 3 channel horizontal routines\n\n#ifdef STBIR_SIMD\n\n#define stbir__1_coeff_only()         \\\n    stbir__simdf tot,c,d;             \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    stbir__simdf_load1z( c, hc );     \\\n    stbir__simdf_0123to0001( c, c );  \\\n    stbir__simdf_load( d, decode );   \\\n    stbir__simdf_mult( tot, d, c );\n\n#define stbir__2_coeff_only()         \\\n    stbir__simdf tot,c,cs,d;          \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    stbir__simdf_load2( cs, hc );     \\\n    stbir__simdf_0123to0000( c, cs ); \\\n    stbir__simdf_load( d, decode );   \\\n    stbir__simdf_mult( tot, d, c );   \\\n    stbir__simdf_0123to1111( c, cs ); \\\n    stbir__simdf_load( d, decode+3 ); \\\n    stbir__simdf_madd( tot, tot, d, c );\n\n#define stbir__3_coeff_only()            \\\n    stbir__simdf tot,c,d,cs;             \\\n    STBIR_SIMD_NO_UNROLL(decode);        \\\n    stbir__simdf_load( cs, hc );         \\\n    stbir__simdf_0123to0000( c, cs );    \\\n    stbir__simdf_load( d, decode );      \\\n    stbir__simdf_mult( tot, d, c );      \\\n    stbir__simdf_0123to1111( c, cs );    \\\n    stbir__simdf_load( d, decode+3 );    \\\n    stbir__simdf_madd( tot, tot, d, c ); \\\n    stbir__simdf_0123to2222( c, cs );    \\\n    stbir__simdf_load( d, decode+6 );    \\\n    stbir__simdf_madd( tot, tot, d, c );\n\n#define stbir__store_output_tiny()                \\\n    stbir__simdf_store2( output, tot );           \\\n    stbir__simdf_0123to2301( tot, tot );          \\\n    stbir__simdf_store1( output+2, tot );         \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 3;\n\n#ifdef STBIR_SIMD8\n\n// we're loading from the XXXYYY decode by -1 to get the XXXYYY into different halves of the AVX reg fyi\n#define stbir__4_coeff_start()                     \\\n    stbir__simdf8 tot0,tot1,c,cs; stbir__simdf t;  \\\n    STBIR_SIMD_NO_UNROLL(decode);                  \\\n    stbir__simdf8_load4b( cs, hc );                \\\n    stbir__simdf8_0123to00001111( c, cs );         \\\n    stbir__simdf8_mult_mem( tot0, c, decode - 1 ); \\\n    stbir__simdf8_0123to22223333( c, cs );         \\\n    stbir__simdf8_mult_mem( tot1, c, decode+6 - 1 );\n\n#define stbir__4_coeff_continue_from_4( ofs )      \\\n    STBIR_SIMD_NO_UNROLL(decode);                  \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );        \\\n    stbir__simdf8_0123to00001111( c, cs );         \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*3 - 1 ); \\\n    stbir__simdf8_0123to22223333( c, cs );         \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+(ofs)*3 + 6 - 1 );\n\n#define stbir__1_coeff_remnant( ofs )                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf_load1rep4( t, hc + (ofs) );                   \\\n    stbir__simdf8_madd_mem4( tot0, tot0, t, decode+(ofs)*3 - 1 );\n\n#define stbir__2_coeff_remnant( ofs )                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf8_load4b( cs, hc + (ofs) - 2 );                \\\n    stbir__simdf8_0123to22223333( c, cs );                     \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*3 - 1 );\n\n #define stbir__3_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                                \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );                      \\\n    stbir__simdf8_0123to00001111( c, cs );                       \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*3 - 1 ); \\\n    stbir__simdf8_0123to2222( t, cs );                           \\\n    stbir__simdf8_madd_mem4( tot1, tot1, t, decode+(ofs)*3 + 6 - 1 );\n\n#define stbir__store_output()                       \\\n    stbir__simdf8_add( tot0, tot0, tot1 );          \\\n    stbir__simdf_0123to1230( t, stbir__if_simdf8_cast_to_simdf4( tot0 ) ); \\\n    stbir__simdf8_add4halves( t, t, tot0 );         \\\n    horizontal_coefficients += coefficient_width;   \\\n    ++horizontal_contributors;                      \\\n    output += 3;                                    \\\n    if ( output < output_end )                      \\\n    {                                               \\\n      stbir__simdf_store( output-3, t );            \\\n      continue;                                     \\\n    }                                               \\\n    { stbir__simdf tt; stbir__simdf_0123to2301( tt, t ); \\\n    stbir__simdf_store2( output-3, t );             \\\n    stbir__simdf_store1( output+2-3, tt ); }        \\\n    break;\n\n\n#else\n\n#define stbir__4_coeff_start()                  \\\n    stbir__simdf tot0,tot1,tot2,c,cs;           \\\n    STBIR_SIMD_NO_UNROLL(decode);               \\\n    stbir__simdf_load( cs, hc );                \\\n    stbir__simdf_0123to0001( c, cs );           \\\n    stbir__simdf_mult_mem( tot0, c, decode );   \\\n    stbir__simdf_0123to1122( c, cs );           \\\n    stbir__simdf_mult_mem( tot1, c, decode+4 ); \\\n    stbir__simdf_0123to2333( c, cs );           \\\n    stbir__simdf_mult_mem( tot2, c, decode+8 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                 \\\n    STBIR_SIMD_NO_UNROLL(decode);                             \\\n    stbir__simdf_load( cs, hc + (ofs) );                      \\\n    stbir__simdf_0123to0001( c, cs );                         \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*3 );   \\\n    stbir__simdf_0123to1122( c, cs );                         \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*3+4 ); \\\n    stbir__simdf_0123to2333( c, cs );                         \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+(ofs)*3+8 );\n\n#define stbir__1_coeff_remnant( ofs )         \\\n    STBIR_SIMD_NO_UNROLL(decode);             \\\n    stbir__simdf_load1z( c, hc + (ofs) );     \\\n    stbir__simdf_0123to0001( c, c );          \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*3 );\n\n#define stbir__2_coeff_remnant( ofs )                       \\\n    { stbir__simdf d;                                       \\\n    STBIR_SIMD_NO_UNROLL(decode);                           \\\n    stbir__simdf_load2z( cs, hc + (ofs) );                  \\\n    stbir__simdf_0123to0001( c, cs );                       \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*3 ); \\\n    stbir__simdf_0123to1122( c, cs );                       \\\n    stbir__simdf_load2z( d, decode+(ofs)*3+4 );             \\\n    stbir__simdf_madd( tot1, tot1, c, d ); }\n\n#define stbir__3_coeff_remnant( ofs )                         \\\n    { stbir__simdf d;                                         \\\n    STBIR_SIMD_NO_UNROLL(decode);                             \\\n    stbir__simdf_load( cs, hc + (ofs) );                      \\\n    stbir__simdf_0123to0001( c, cs );                         \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*3 );   \\\n    stbir__simdf_0123to1122( c, cs );                         \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*3+4 ); \\\n    stbir__simdf_0123to2222( c, cs );                         \\\n    stbir__simdf_load1z( d, decode+(ofs)*3+8 );               \\\n    stbir__simdf_madd( tot2, tot2, c, d );  }\n\n#define stbir__store_output()                       \\\n    stbir__simdf_0123ABCDto3ABx( c, tot0, tot1 );   \\\n    stbir__simdf_0123ABCDto23Ax( cs, tot1, tot2 );  \\\n    stbir__simdf_0123to1230( tot2, tot2 );          \\\n    stbir__simdf_add( tot0, tot0, cs );             \\\n    stbir__simdf_add( c, c, tot2 );                 \\\n    stbir__simdf_add( tot0, tot0, c );              \\\n    horizontal_coefficients += coefficient_width;   \\\n    ++horizontal_contributors;                      \\\n    output += 3;                                    \\\n    if ( output < output_end )                      \\\n    {                                               \\\n      stbir__simdf_store( output-3, tot0 );         \\\n      continue;                                     \\\n    }                                               \\\n    stbir__simdf_0123to2301( tot1, tot0 );          \\\n    stbir__simdf_store2( output-3, tot0 );          \\\n    stbir__simdf_store1( output+2-3, tot1 );        \\\n    break;\n\n#endif\n\n#else\n\n#define stbir__1_coeff_only()  \\\n    float tot0, tot1, tot2, c; \\\n    c = hc[0];                 \\\n    tot0 = decode[0]*c;        \\\n    tot1 = decode[1]*c;        \\\n    tot2 = decode[2]*c;\n\n#define stbir__2_coeff_only()  \\\n    float tot0, tot1, tot2, c; \\\n    c = hc[0];                 \\\n    tot0 = decode[0]*c;        \\\n    tot1 = decode[1]*c;        \\\n    tot2 = decode[2]*c;        \\\n    c = hc[1];                 \\\n    tot0 += decode[3]*c;       \\\n    tot1 += decode[4]*c;       \\\n    tot2 += decode[5]*c;\n\n#define stbir__3_coeff_only()  \\\n    float tot0, tot1, tot2, c; \\\n    c = hc[0];                 \\\n    tot0 = decode[0]*c;        \\\n    tot1 = decode[1]*c;        \\\n    tot2 = decode[2]*c;        \\\n    c = hc[1];                 \\\n    tot0 += decode[3]*c;       \\\n    tot1 += decode[4]*c;       \\\n    tot2 += decode[5]*c;       \\\n    c = hc[2];                 \\\n    tot0 += decode[6]*c;       \\\n    tot1 += decode[7]*c;       \\\n    tot2 += decode[8]*c;\n\n#define stbir__store_output_tiny()                \\\n    output[0] = tot0;                             \\\n    output[1] = tot1;                             \\\n    output[2] = tot2;                             \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 3;\n\n#define stbir__4_coeff_start()      \\\n    float tota0,tota1,tota2,totb0,totb1,totb2,totc0,totc1,totc2,totd0,totd1,totd2,c;  \\\n    c = hc[0];                      \\\n    tota0 = decode[0]*c;            \\\n    tota1 = decode[1]*c;            \\\n    tota2 = decode[2]*c;            \\\n    c = hc[1];                      \\\n    totb0 = decode[3]*c;            \\\n    totb1 = decode[4]*c;            \\\n    totb2 = decode[5]*c;            \\\n    c = hc[2];                      \\\n    totc0 = decode[6]*c;            \\\n    totc1 = decode[7]*c;            \\\n    totc2 = decode[8]*c;            \\\n    c = hc[3];                      \\\n    totd0 = decode[9]*c;            \\\n    totd1 = decode[10]*c;           \\\n    totd2 = decode[11]*c;\n\n#define stbir__4_coeff_continue_from_4( ofs )  \\\n    c = hc[0+(ofs)];                           \\\n    tota0 += decode[0+(ofs)*3]*c;              \\\n    tota1 += decode[1+(ofs)*3]*c;              \\\n    tota2 += decode[2+(ofs)*3]*c;              \\\n    c = hc[1+(ofs)];                           \\\n    totb0 += decode[3+(ofs)*3]*c;              \\\n    totb1 += decode[4+(ofs)*3]*c;              \\\n    totb2 += decode[5+(ofs)*3]*c;              \\\n    c = hc[2+(ofs)];                           \\\n    totc0 += decode[6+(ofs)*3]*c;              \\\n    totc1 += decode[7+(ofs)*3]*c;              \\\n    totc2 += decode[8+(ofs)*3]*c;              \\\n    c = hc[3+(ofs)];                           \\\n    totd0 += decode[9+(ofs)*3]*c;              \\\n    totd1 += decode[10+(ofs)*3]*c;             \\\n    totd2 += decode[11+(ofs)*3]*c;\n\n#define stbir__1_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*3]*c;      \\\n    tota1 += decode[1+(ofs)*3]*c;      \\\n    tota2 += decode[2+(ofs)*3]*c;\n\n#define stbir__2_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*3]*c;      \\\n    tota1 += decode[1+(ofs)*3]*c;      \\\n    tota2 += decode[2+(ofs)*3]*c;      \\\n    c = hc[1+(ofs)];                   \\\n    totb0 += decode[3+(ofs)*3]*c;      \\\n    totb1 += decode[4+(ofs)*3]*c;      \\\n    totb2 += decode[5+(ofs)*3]*c;      \\\n\n#define stbir__3_coeff_remnant( ofs )  \\\n    c = hc[0+(ofs)];                   \\\n    tota0 += decode[0+(ofs)*3]*c;      \\\n    tota1 += decode[1+(ofs)*3]*c;      \\\n    tota2 += decode[2+(ofs)*3]*c;      \\\n    c = hc[1+(ofs)];                   \\\n    totb0 += decode[3+(ofs)*3]*c;      \\\n    totb1 += decode[4+(ofs)*3]*c;      \\\n    totb2 += decode[5+(ofs)*3]*c;      \\\n    c = hc[2+(ofs)];                   \\\n    totc0 += decode[6+(ofs)*3]*c;      \\\n    totc1 += decode[7+(ofs)*3]*c;      \\\n    totc2 += decode[8+(ofs)*3]*c;\n\n#define stbir__store_output()                     \\\n    output[0] = (tota0+totc0)+(totb0+totd0);      \\\n    output[1] = (tota1+totc1)+(totb1+totd1);      \\\n    output[2] = (tota2+totc2)+(totb2+totd2);      \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 3;\n\n#endif\n\n#define STBIR__horizontal_channels 3\n#define STB_IMAGE_RESIZE_DO_HORIZONTALS\n#include STBIR__HEADER_FILENAME\n\n//=================\n// Do 4 channel horizontal routines\n\n#ifdef STBIR_SIMD\n\n#define stbir__1_coeff_only()             \\\n    stbir__simdf tot,c;                   \\\n    STBIR_SIMD_NO_UNROLL(decode);         \\\n    stbir__simdf_load1( c, hc );          \\\n    stbir__simdf_0123to0000( c, c );      \\\n    stbir__simdf_mult_mem( tot, c, decode );\n\n#define stbir__2_coeff_only()                       \\\n    stbir__simdf tot,c,cs;                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                   \\\n    stbir__simdf_load2( cs, hc );                   \\\n    stbir__simdf_0123to0000( c, cs );               \\\n    stbir__simdf_mult_mem( tot, c, decode );        \\\n    stbir__simdf_0123to1111( c, cs );               \\\n    stbir__simdf_madd_mem( tot, tot, c, decode+4 );\n\n#define stbir__3_coeff_only()                       \\\n    stbir__simdf tot,c,cs;                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                   \\\n    stbir__simdf_load( cs, hc );                    \\\n    stbir__simdf_0123to0000( c, cs );               \\\n    stbir__simdf_mult_mem( tot, c, decode );        \\\n    stbir__simdf_0123to1111( c, cs );               \\\n    stbir__simdf_madd_mem( tot, tot, c, decode+4 ); \\\n    stbir__simdf_0123to2222( c, cs );               \\\n    stbir__simdf_madd_mem( tot, tot, c, decode+8 );\n\n#define stbir__store_output_tiny()                \\\n    stbir__simdf_store( output, tot );            \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 4;\n\n#ifdef STBIR_SIMD8\n\n#define stbir__4_coeff_start()                     \\\n    stbir__simdf8 tot0,c,cs; stbir__simdf t;  \\\n    STBIR_SIMD_NO_UNROLL(decode);                  \\\n    stbir__simdf8_load4b( cs, hc );                \\\n    stbir__simdf8_0123to00001111( c, cs );         \\\n    stbir__simdf8_mult_mem( tot0, c, decode );     \\\n    stbir__simdf8_0123to22223333( c, cs );         \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+8 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                  \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );                    \\\n    stbir__simdf8_0123to00001111( c, cs );                     \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*4 );   \\\n    stbir__simdf8_0123to22223333( c, cs );                     \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*4+8 );\n\n#define stbir__1_coeff_remnant( ofs )                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf_load1rep4( t, hc + (ofs) );                   \\\n    stbir__simdf8_madd_mem4( tot0, tot0, t, decode+(ofs)*4 );\n\n#define stbir__2_coeff_remnant( ofs )                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf8_load4b( cs, hc + (ofs) - 2 );                \\\n    stbir__simdf8_0123to22223333( c, cs );                     \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*4 );\n\n #define stbir__3_coeff_remnant( ofs )                         \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );                    \\\n    stbir__simdf8_0123to00001111( c, cs );                     \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*4 );   \\\n    stbir__simdf8_0123to2222( t, cs );                         \\\n    stbir__simdf8_madd_mem4( tot0, tot0, t, decode+(ofs)*4+8 );\n\n#define stbir__store_output()                      \\\n    stbir__simdf8_add4halves( t, stbir__if_simdf8_cast_to_simdf4(tot0), tot0 );     \\\n    stbir__simdf_store( output, t );               \\\n    horizontal_coefficients += coefficient_width;  \\\n    ++horizontal_contributors;                     \\\n    output += 4;\n\n#else\n\n#define stbir__4_coeff_start()                        \\\n    stbir__simdf tot0,tot1,c,cs;                      \\\n    STBIR_SIMD_NO_UNROLL(decode);                     \\\n    stbir__simdf_load( cs, hc );                      \\\n    stbir__simdf_0123to0000( c, cs );                 \\\n    stbir__simdf_mult_mem( tot0, c, decode );         \\\n    stbir__simdf_0123to1111( c, cs );                 \\\n    stbir__simdf_mult_mem( tot1, c, decode+4 );       \\\n    stbir__simdf_0123to2222( c, cs );                 \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+8 ); \\\n    stbir__simdf_0123to3333( c, cs );                 \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+12 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                  \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf_load( cs, hc + (ofs) );                       \\\n    stbir__simdf_0123to0000( c, cs );                          \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4 );    \\\n    stbir__simdf_0123to1111( c, cs );                          \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*4+4 );  \\\n    stbir__simdf_0123to2222( c, cs );                          \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4+8 );  \\\n    stbir__simdf_0123to3333( c, cs );                          \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*4+12 );\n\n#define stbir__1_coeff_remnant( ofs )                       \\\n    STBIR_SIMD_NO_UNROLL(decode);                           \\\n    stbir__simdf_load1( c, hc + (ofs) );                    \\\n    stbir__simdf_0123to0000( c, c );                        \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4 );\n\n#define stbir__2_coeff_remnant( ofs )                         \\\n    STBIR_SIMD_NO_UNROLL(decode);                             \\\n    stbir__simdf_load2( cs, hc + (ofs) );                     \\\n    stbir__simdf_0123to0000( c, cs );                         \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4 );   \\\n    stbir__simdf_0123to1111( c, cs );                         \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*4+4 );\n\n#define stbir__3_coeff_remnant( ofs )                          \\\n    STBIR_SIMD_NO_UNROLL(decode);                              \\\n    stbir__simdf_load( cs, hc + (ofs) );                       \\\n    stbir__simdf_0123to0000( c, cs );                          \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4 );    \\\n    stbir__simdf_0123to1111( c, cs );                          \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*4+4 );  \\\n    stbir__simdf_0123to2222( c, cs );                          \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*4+8 );\n\n#define stbir__store_output()                     \\\n    stbir__simdf_add( tot0, tot0, tot1 );         \\\n    stbir__simdf_store( output, tot0 );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 4;\n\n#endif\n\n#else\n\n#define stbir__1_coeff_only()         \\\n    float p0,p1,p2,p3,c;              \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0];                        \\\n    p0 = decode[0] * c;               \\\n    p1 = decode[1] * c;               \\\n    p2 = decode[2] * c;               \\\n    p3 = decode[3] * c;\n\n#define stbir__2_coeff_only()         \\\n    float p0,p1,p2,p3,c;              \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0];                        \\\n    p0 = decode[0] * c;               \\\n    p1 = decode[1] * c;               \\\n    p2 = decode[2] * c;               \\\n    p3 = decode[3] * c;               \\\n    c = hc[1];                        \\\n    p0 += decode[4] * c;              \\\n    p1 += decode[5] * c;              \\\n    p2 += decode[6] * c;              \\\n    p3 += decode[7] * c;\n\n#define stbir__3_coeff_only()         \\\n    float p0,p1,p2,p3,c;              \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0];                        \\\n    p0 = decode[0] * c;               \\\n    p1 = decode[1] * c;               \\\n    p2 = decode[2] * c;               \\\n    p3 = decode[3] * c;               \\\n    c = hc[1];                        \\\n    p0 += decode[4] * c;              \\\n    p1 += decode[5] * c;              \\\n    p2 += decode[6] * c;              \\\n    p3 += decode[7] * c;              \\\n    c = hc[2];                        \\\n    p0 += decode[8] * c;              \\\n    p1 += decode[9] * c;              \\\n    p2 += decode[10] * c;             \\\n    p3 += decode[11] * c;\n\n#define stbir__store_output_tiny()                \\\n    output[0] = p0;                               \\\n    output[1] = p1;                               \\\n    output[2] = p2;                               \\\n    output[3] = p3;                               \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 4;\n\n#define stbir__4_coeff_start()        \\\n    float x0,x1,x2,x3,y0,y1,y2,y3,c;  \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0];                        \\\n    x0 = decode[0] * c;               \\\n    x1 = decode[1] * c;               \\\n    x2 = decode[2] * c;               \\\n    x3 = decode[3] * c;               \\\n    c = hc[1];                        \\\n    y0 = decode[4] * c;               \\\n    y1 = decode[5] * c;               \\\n    y2 = decode[6] * c;               \\\n    y3 = decode[7] * c;               \\\n    c = hc[2];                        \\\n    x0 += decode[8] * c;              \\\n    x1 += decode[9] * c;              \\\n    x2 += decode[10] * c;             \\\n    x3 += decode[11] * c;             \\\n    c = hc[3];                        \\\n    y0 += decode[12] * c;             \\\n    y1 += decode[13] * c;             \\\n    y2 += decode[14] * c;             \\\n    y3 += decode[15] * c;\n\n#define stbir__4_coeff_continue_from_4( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0+(ofs)];                  \\\n    x0 += decode[0+(ofs)*4] * c;      \\\n    x1 += decode[1+(ofs)*4] * c;      \\\n    x2 += decode[2+(ofs)*4] * c;      \\\n    x3 += decode[3+(ofs)*4] * c;      \\\n    c = hc[1+(ofs)];                  \\\n    y0 += decode[4+(ofs)*4] * c;      \\\n    y1 += decode[5+(ofs)*4] * c;      \\\n    y2 += decode[6+(ofs)*4] * c;      \\\n    y3 += decode[7+(ofs)*4] * c;      \\\n    c = hc[2+(ofs)];                  \\\n    x0 += decode[8+(ofs)*4] * c;      \\\n    x1 += decode[9+(ofs)*4] * c;      \\\n    x2 += decode[10+(ofs)*4] * c;     \\\n    x3 += decode[11+(ofs)*4] * c;     \\\n    c = hc[3+(ofs)];                  \\\n    y0 += decode[12+(ofs)*4] * c;     \\\n    y1 += decode[13+(ofs)*4] * c;     \\\n    y2 += decode[14+(ofs)*4] * c;     \\\n    y3 += decode[15+(ofs)*4] * c;\n\n#define stbir__1_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0+(ofs)];                  \\\n    x0 += decode[0+(ofs)*4] * c;      \\\n    x1 += decode[1+(ofs)*4] * c;      \\\n    x2 += decode[2+(ofs)*4] * c;      \\\n    x3 += decode[3+(ofs)*4] * c;\n\n#define stbir__2_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0+(ofs)];                  \\\n    x0 += decode[0+(ofs)*4] * c;      \\\n    x1 += decode[1+(ofs)*4] * c;      \\\n    x2 += decode[2+(ofs)*4] * c;      \\\n    x3 += decode[3+(ofs)*4] * c;      \\\n    c = hc[1+(ofs)];                  \\\n    y0 += decode[4+(ofs)*4] * c;      \\\n    y1 += decode[5+(ofs)*4] * c;      \\\n    y2 += decode[6+(ofs)*4] * c;      \\\n    y3 += decode[7+(ofs)*4] * c;\n\n#define stbir__3_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);     \\\n    c = hc[0+(ofs)];                  \\\n    x0 += decode[0+(ofs)*4] * c;      \\\n    x1 += decode[1+(ofs)*4] * c;      \\\n    x2 += decode[2+(ofs)*4] * c;      \\\n    x3 += decode[3+(ofs)*4] * c;      \\\n    c = hc[1+(ofs)];                  \\\n    y0 += decode[4+(ofs)*4] * c;      \\\n    y1 += decode[5+(ofs)*4] * c;      \\\n    y2 += decode[6+(ofs)*4] * c;      \\\n    y3 += decode[7+(ofs)*4] * c;      \\\n    c = hc[2+(ofs)];                  \\\n    x0 += decode[8+(ofs)*4] * c;      \\\n    x1 += decode[9+(ofs)*4] * c;      \\\n    x2 += decode[10+(ofs)*4] * c;     \\\n    x3 += decode[11+(ofs)*4] * c;\n\n#define stbir__store_output()                     \\\n    output[0] = x0 + y0;                          \\\n    output[1] = x1 + y1;                          \\\n    output[2] = x2 + y2;                          \\\n    output[3] = x3 + y3;                          \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 4;\n\n#endif\n\n#define STBIR__horizontal_channels 4\n#define STB_IMAGE_RESIZE_DO_HORIZONTALS\n#include STBIR__HEADER_FILENAME\n\n\n\n//=================\n// Do 7 channel horizontal routines\n\n#ifdef STBIR_SIMD\n\n#define stbir__1_coeff_only()                   \\\n    stbir__simdf tot0,tot1,c;                   \\\n    STBIR_SIMD_NO_UNROLL(decode);               \\\n    stbir__simdf_load1( c, hc );                \\\n    stbir__simdf_0123to0000( c, c );            \\\n    stbir__simdf_mult_mem( tot0, c, decode );   \\\n    stbir__simdf_mult_mem( tot1, c, decode+3 );\n\n#define stbir__2_coeff_only()                         \\\n    stbir__simdf tot0,tot1,c,cs;                      \\\n    STBIR_SIMD_NO_UNROLL(decode);                     \\\n    stbir__simdf_load2( cs, hc );                     \\\n    stbir__simdf_0123to0000( c, cs );                 \\\n    stbir__simdf_mult_mem( tot0, c, decode );         \\\n    stbir__simdf_mult_mem( tot1, c, decode+3 );       \\\n    stbir__simdf_0123to1111( c, cs );                 \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+7 ); \\\n    stbir__simdf_madd_mem( tot1, tot1, c,decode+10 );\n\n#define stbir__3_coeff_only()                           \\\n    stbir__simdf tot0,tot1,c,cs;                        \\\n    STBIR_SIMD_NO_UNROLL(decode);                       \\\n    stbir__simdf_load( cs, hc );                        \\\n    stbir__simdf_0123to0000( c, cs );                   \\\n    stbir__simdf_mult_mem( tot0, c, decode );           \\\n    stbir__simdf_mult_mem( tot1, c, decode+3 );         \\\n    stbir__simdf_0123to1111( c, cs );                   \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+7 );   \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+10 );  \\\n    stbir__simdf_0123to2222( c, cs );                   \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+14 );  \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+17 );\n\n#define stbir__store_output_tiny()                \\\n    stbir__simdf_store( output+3, tot1 );         \\\n    stbir__simdf_store( output, tot0 );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 7;\n\n#ifdef STBIR_SIMD8\n\n#define stbir__4_coeff_start()                     \\\n    stbir__simdf8 tot0,tot1,c,cs;                  \\\n    STBIR_SIMD_NO_UNROLL(decode);                  \\\n    stbir__simdf8_load4b( cs, hc );                \\\n    stbir__simdf8_0123to00000000( c, cs );         \\\n    stbir__simdf8_mult_mem( tot0, c, decode );     \\\n    stbir__simdf8_0123to11111111( c, cs );         \\\n    stbir__simdf8_mult_mem( tot1, c, decode+7 );   \\\n    stbir__simdf8_0123to22222222( c, cs );         \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+14 );  \\\n    stbir__simdf8_0123to33333333( c, cs );         \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+21 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                   \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );                     \\\n    stbir__simdf8_0123to00000000( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7 );    \\\n    stbir__simdf8_0123to11111111( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+(ofs)*7+7 );  \\\n    stbir__simdf8_0123to22222222( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7+14 ); \\\n    stbir__simdf8_0123to33333333( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+(ofs)*7+21 );\n\n#define stbir__1_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf8_load1b( c, hc + (ofs) );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7 );\n\n#define stbir__2_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf8_load1b( c, hc + (ofs) );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7 );    \\\n    stbir__simdf8_load1b( c, hc + (ofs)+1 );                    \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+(ofs)*7+7 );\n\n#define stbir__3_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf8_load4b( cs, hc + (ofs) );                     \\\n    stbir__simdf8_0123to00000000( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7 );    \\\n    stbir__simdf8_0123to11111111( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot1, tot1, c, decode+(ofs)*7+7 );  \\\n    stbir__simdf8_0123to22222222( c, cs );                      \\\n    stbir__simdf8_madd_mem( tot0, tot0, c, decode+(ofs)*7+14 );\n\n#define stbir__store_output()                     \\\n    stbir__simdf8_add( tot0, tot0, tot1 );        \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 7;                                  \\\n    if ( output < output_end )                    \\\n    {                                             \\\n      stbir__simdf8_store( output-7, tot0 );      \\\n      continue;                                   \\\n    }                                             \\\n    stbir__simdf_store( output-7+3, stbir__simdf_swiz(stbir__simdf8_gettop4(tot0),0,0,1,2) ); \\\n    stbir__simdf_store( output-7, stbir__if_simdf8_cast_to_simdf4(tot0) );           \\\n    break;\n\n#else\n\n#define stbir__4_coeff_start()                    \\\n    stbir__simdf tot0,tot1,tot2,tot3,c,cs;        \\\n    STBIR_SIMD_NO_UNROLL(decode);                 \\\n    stbir__simdf_load( cs, hc );                  \\\n    stbir__simdf_0123to0000( c, cs );             \\\n    stbir__simdf_mult_mem( tot0, c, decode );     \\\n    stbir__simdf_mult_mem( tot1, c, decode+3 );   \\\n    stbir__simdf_0123to1111( c, cs );             \\\n    stbir__simdf_mult_mem( tot2, c, decode+7 );   \\\n    stbir__simdf_mult_mem( tot3, c, decode+10 );  \\\n    stbir__simdf_0123to2222( c, cs );             \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+14 );  \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+17 );  \\\n    stbir__simdf_0123to3333( c, cs );                   \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+21 );  \\\n    stbir__simdf_madd_mem( tot3, tot3, c, decode+24 );\n\n#define stbir__4_coeff_continue_from_4( ofs )                   \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf_load( cs, hc + (ofs) );                        \\\n    stbir__simdf_0123to0000( c, cs );                           \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7 );     \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+3 );   \\\n    stbir__simdf_0123to1111( c, cs );                           \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+(ofs)*7+7 );   \\\n    stbir__simdf_madd_mem( tot3, tot3, c, decode+(ofs)*7+10 );  \\\n    stbir__simdf_0123to2222( c, cs );                           \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7+14 );  \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+17 );  \\\n    stbir__simdf_0123to3333( c, cs );                           \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+(ofs)*7+21 );  \\\n    stbir__simdf_madd_mem( tot3, tot3, c, decode+(ofs)*7+24 );\n\n#define stbir__1_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf_load1( c, hc + (ofs) );                        \\\n    stbir__simdf_0123to0000( c, c );                            \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7 );     \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+3 );   \\\n\n#define stbir__2_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf_load2( cs, hc + (ofs) );                       \\\n    stbir__simdf_0123to0000( c, cs );                           \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7 );     \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+3 );   \\\n    stbir__simdf_0123to1111( c, cs );                           \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+(ofs)*7+7 );   \\\n    stbir__simdf_madd_mem( tot3, tot3, c, decode+(ofs)*7+10 );\n\n#define stbir__3_coeff_remnant( ofs )                           \\\n    STBIR_SIMD_NO_UNROLL(decode);                               \\\n    stbir__simdf_load( cs, hc + (ofs) );                        \\\n    stbir__simdf_0123to0000( c, cs );                           \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7 );     \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+3 );   \\\n    stbir__simdf_0123to1111( c, cs );                           \\\n    stbir__simdf_madd_mem( tot2, tot2, c, decode+(ofs)*7+7 );   \\\n    stbir__simdf_madd_mem( tot3, tot3, c, decode+(ofs)*7+10 );  \\\n    stbir__simdf_0123to2222( c, cs );                           \\\n    stbir__simdf_madd_mem( tot0, tot0, c, decode+(ofs)*7+14 );  \\\n    stbir__simdf_madd_mem( tot1, tot1, c, decode+(ofs)*7+17 );\n\n#define stbir__store_output()                     \\\n    stbir__simdf_add( tot0, tot0, tot2 );         \\\n    stbir__simdf_add( tot1, tot1, tot3 );         \\\n    stbir__simdf_store( output+3, tot1 );         \\\n    stbir__simdf_store( output, tot0 );           \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 7;\n\n#endif\n\n#else\n\n#define stbir__1_coeff_only()        \\\n    float tot0, tot1, tot2, tot3, tot4, tot5, tot6, c; \\\n    c = hc[0];                       \\\n    tot0 = decode[0]*c;              \\\n    tot1 = decode[1]*c;              \\\n    tot2 = decode[2]*c;              \\\n    tot3 = decode[3]*c;              \\\n    tot4 = decode[4]*c;              \\\n    tot5 = decode[5]*c;              \\\n    tot6 = decode[6]*c;\n\n#define stbir__2_coeff_only()        \\\n    float tot0, tot1, tot2, tot3, tot4, tot5, tot6, c; \\\n    c = hc[0];                       \\\n    tot0 = decode[0]*c;              \\\n    tot1 = decode[1]*c;              \\\n    tot2 = decode[2]*c;              \\\n    tot3 = decode[3]*c;              \\\n    tot4 = decode[4]*c;              \\\n    tot5 = decode[5]*c;              \\\n    tot6 = decode[6]*c;              \\\n    c = hc[1];                       \\\n    tot0 += decode[7]*c;             \\\n    tot1 += decode[8]*c;             \\\n    tot2 += decode[9]*c;             \\\n    tot3 += decode[10]*c;            \\\n    tot4 += decode[11]*c;            \\\n    tot5 += decode[12]*c;            \\\n    tot6 += decode[13]*c;            \\\n\n#define stbir__3_coeff_only()        \\\n    float tot0, tot1, tot2, tot3, tot4, tot5, tot6, c; \\\n    c = hc[0];                       \\\n    tot0 = decode[0]*c;              \\\n    tot1 = decode[1]*c;              \\\n    tot2 = decode[2]*c;              \\\n    tot3 = decode[3]*c;              \\\n    tot4 = decode[4]*c;              \\\n    tot5 = decode[5]*c;              \\\n    tot6 = decode[6]*c;              \\\n    c = hc[1];                       \\\n    tot0 += decode[7]*c;             \\\n    tot1 += decode[8]*c;             \\\n    tot2 += decode[9]*c;             \\\n    tot3 += decode[10]*c;            \\\n    tot4 += decode[11]*c;            \\\n    tot5 += decode[12]*c;            \\\n    tot6 += decode[13]*c;            \\\n    c = hc[2];                       \\\n    tot0 += decode[14]*c;            \\\n    tot1 += decode[15]*c;            \\\n    tot2 += decode[16]*c;            \\\n    tot3 += decode[17]*c;            \\\n    tot4 += decode[18]*c;            \\\n    tot5 += decode[19]*c;            \\\n    tot6 += decode[20]*c;            \\\n\n#define stbir__store_output_tiny()                \\\n    output[0] = tot0;                             \\\n    output[1] = tot1;                             \\\n    output[2] = tot2;                             \\\n    output[3] = tot3;                             \\\n    output[4] = tot4;                             \\\n    output[5] = tot5;                             \\\n    output[6] = tot6;                             \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 7;\n\n#define stbir__4_coeff_start()    \\\n    float x0,x1,x2,x3,x4,x5,x6,y0,y1,y2,y3,y4,y5,y6,c; \\\n    STBIR_SIMD_NO_UNROLL(decode); \\\n    c = hc[0];                    \\\n    x0 = decode[0] * c;           \\\n    x1 = decode[1] * c;           \\\n    x2 = decode[2] * c;           \\\n    x3 = decode[3] * c;           \\\n    x4 = decode[4] * c;           \\\n    x5 = decode[5] * c;           \\\n    x6 = decode[6] * c;           \\\n    c = hc[1];                    \\\n    y0 = decode[7] * c;           \\\n    y1 = decode[8] * c;           \\\n    y2 = decode[9] * c;           \\\n    y3 = decode[10] * c;          \\\n    y4 = decode[11] * c;          \\\n    y5 = decode[12] * c;          \\\n    y6 = decode[13] * c;          \\\n    c = hc[2];                    \\\n    x0 += decode[14] * c;         \\\n    x1 += decode[15] * c;         \\\n    x2 += decode[16] * c;         \\\n    x3 += decode[17] * c;         \\\n    x4 += decode[18] * c;         \\\n    x5 += decode[19] * c;         \\\n    x6 += decode[20] * c;         \\\n    c = hc[3];                    \\\n    y0 += decode[21] * c;         \\\n    y1 += decode[22] * c;         \\\n    y2 += decode[23] * c;         \\\n    y3 += decode[24] * c;         \\\n    y4 += decode[25] * c;         \\\n    y5 += decode[26] * c;         \\\n    y6 += decode[27] * c;\n\n#define stbir__4_coeff_continue_from_4( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);  \\\n    c = hc[0+(ofs)];               \\\n    x0 += decode[0+(ofs)*7] * c;   \\\n    x1 += decode[1+(ofs)*7] * c;   \\\n    x2 += decode[2+(ofs)*7] * c;   \\\n    x3 += decode[3+(ofs)*7] * c;   \\\n    x4 += decode[4+(ofs)*7] * c;   \\\n    x5 += decode[5+(ofs)*7] * c;   \\\n    x6 += decode[6+(ofs)*7] * c;   \\\n    c = hc[1+(ofs)];               \\\n    y0 += decode[7+(ofs)*7] * c;   \\\n    y1 += decode[8+(ofs)*7] * c;   \\\n    y2 += decode[9+(ofs)*7] * c;   \\\n    y3 += decode[10+(ofs)*7] * c;  \\\n    y4 += decode[11+(ofs)*7] * c;  \\\n    y5 += decode[12+(ofs)*7] * c;  \\\n    y6 += decode[13+(ofs)*7] * c;  \\\n    c = hc[2+(ofs)];               \\\n    x0 += decode[14+(ofs)*7] * c;  \\\n    x1 += decode[15+(ofs)*7] * c;  \\\n    x2 += decode[16+(ofs)*7] * c;  \\\n    x3 += decode[17+(ofs)*7] * c;  \\\n    x4 += decode[18+(ofs)*7] * c;  \\\n    x5 += decode[19+(ofs)*7] * c;  \\\n    x6 += decode[20+(ofs)*7] * c;  \\\n    c = hc[3+(ofs)];               \\\n    y0 += decode[21+(ofs)*7] * c;  \\\n    y1 += decode[22+(ofs)*7] * c;  \\\n    y2 += decode[23+(ofs)*7] * c;  \\\n    y3 += decode[24+(ofs)*7] * c;  \\\n    y4 += decode[25+(ofs)*7] * c;  \\\n    y5 += decode[26+(ofs)*7] * c;  \\\n    y6 += decode[27+(ofs)*7] * c;\n\n#define stbir__1_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);  \\\n    c = hc[0+(ofs)];               \\\n    x0 += decode[0+(ofs)*7] * c;   \\\n    x1 += decode[1+(ofs)*7] * c;   \\\n    x2 += decode[2+(ofs)*7] * c;   \\\n    x3 += decode[3+(ofs)*7] * c;   \\\n    x4 += decode[4+(ofs)*7] * c;   \\\n    x5 += decode[5+(ofs)*7] * c;   \\\n    x6 += decode[6+(ofs)*7] * c;   \\\n\n#define stbir__2_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);  \\\n    c = hc[0+(ofs)];               \\\n    x0 += decode[0+(ofs)*7] * c;   \\\n    x1 += decode[1+(ofs)*7] * c;   \\\n    x2 += decode[2+(ofs)*7] * c;   \\\n    x3 += decode[3+(ofs)*7] * c;   \\\n    x4 += decode[4+(ofs)*7] * c;   \\\n    x5 += decode[5+(ofs)*7] * c;   \\\n    x6 += decode[6+(ofs)*7] * c;   \\\n    c = hc[1+(ofs)];               \\\n    y0 += decode[7+(ofs)*7] * c;   \\\n    y1 += decode[8+(ofs)*7] * c;   \\\n    y2 += decode[9+(ofs)*7] * c;   \\\n    y3 += decode[10+(ofs)*7] * c;  \\\n    y4 += decode[11+(ofs)*7] * c;  \\\n    y5 += decode[12+(ofs)*7] * c;  \\\n    y6 += decode[13+(ofs)*7] * c;  \\\n\n#define stbir__3_coeff_remnant( ofs ) \\\n    STBIR_SIMD_NO_UNROLL(decode);  \\\n    c = hc[0+(ofs)];               \\\n    x0 += decode[0+(ofs)*7] * c;   \\\n    x1 += decode[1+(ofs)*7] * c;   \\\n    x2 += decode[2+(ofs)*7] * c;   \\\n    x3 += decode[3+(ofs)*7] * c;   \\\n    x4 += decode[4+(ofs)*7] * c;   \\\n    x5 += decode[5+(ofs)*7] * c;   \\\n    x6 += decode[6+(ofs)*7] * c;   \\\n    c = hc[1+(ofs)];               \\\n    y0 += decode[7+(ofs)*7] * c;   \\\n    y1 += decode[8+(ofs)*7] * c;   \\\n    y2 += decode[9+(ofs)*7] * c;   \\\n    y3 += decode[10+(ofs)*7] * c;  \\\n    y4 += decode[11+(ofs)*7] * c;  \\\n    y5 += decode[12+(ofs)*7] * c;  \\\n    y6 += decode[13+(ofs)*7] * c;  \\\n    c = hc[2+(ofs)];               \\\n    x0 += decode[14+(ofs)*7] * c;  \\\n    x1 += decode[15+(ofs)*7] * c;  \\\n    x2 += decode[16+(ofs)*7] * c;  \\\n    x3 += decode[17+(ofs)*7] * c;  \\\n    x4 += decode[18+(ofs)*7] * c;  \\\n    x5 += decode[19+(ofs)*7] * c;  \\\n    x6 += decode[20+(ofs)*7] * c;  \\\n\n#define stbir__store_output()                     \\\n    output[0] = x0 + y0;                          \\\n    output[1] = x1 + y1;                          \\\n    output[2] = x2 + y2;                          \\\n    output[3] = x3 + y3;                          \\\n    output[4] = x4 + y4;                          \\\n    output[5] = x5 + y5;                          \\\n    output[6] = x6 + y6;                          \\\n    horizontal_coefficients += coefficient_width; \\\n    ++horizontal_contributors;                    \\\n    output += 7;\n\n#endif\n\n#define STBIR__horizontal_channels 7\n#define STB_IMAGE_RESIZE_DO_HORIZONTALS\n#include STBIR__HEADER_FILENAME\n\n\n// include all of the vertical resamplers (both scatter and gather versions)\n\n#define STBIR__vertical_channels 1\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 1\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 2\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 2\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 3\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 3\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 4\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 4\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 5\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 5\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 6\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 6\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 7\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 7\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 8\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#include STBIR__HEADER_FILENAME\n\n#define STBIR__vertical_channels 8\n#define STB_IMAGE_RESIZE_DO_VERTICALS\n#define STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#include STBIR__HEADER_FILENAME\n\ntypedef void STBIR_VERTICAL_GATHERFUNC( float * output, float const * coeffs, float const ** inputs, float const * input0_end );\n\nstatic STBIR_VERTICAL_GATHERFUNC * stbir__vertical_gathers[ 8 ] =\n{\n  stbir__vertical_gather_with_1_coeffs,stbir__vertical_gather_with_2_coeffs,stbir__vertical_gather_with_3_coeffs,stbir__vertical_gather_with_4_coeffs,stbir__vertical_gather_with_5_coeffs,stbir__vertical_gather_with_6_coeffs,stbir__vertical_gather_with_7_coeffs,stbir__vertical_gather_with_8_coeffs\n};\n\nstatic STBIR_VERTICAL_GATHERFUNC * stbir__vertical_gathers_continues[ 8 ] =\n{\n  stbir__vertical_gather_with_1_coeffs_cont,stbir__vertical_gather_with_2_coeffs_cont,stbir__vertical_gather_with_3_coeffs_cont,stbir__vertical_gather_with_4_coeffs_cont,stbir__vertical_gather_with_5_coeffs_cont,stbir__vertical_gather_with_6_coeffs_cont,stbir__vertical_gather_with_7_coeffs_cont,stbir__vertical_gather_with_8_coeffs_cont\n};\n\ntypedef void STBIR_VERTICAL_SCATTERFUNC( float ** outputs, float const * coeffs, float const * input, float const * input_end );\n\nstatic STBIR_VERTICAL_SCATTERFUNC * stbir__vertical_scatter_sets[ 8 ] =\n{\n  stbir__vertical_scatter_with_1_coeffs,stbir__vertical_scatter_with_2_coeffs,stbir__vertical_scatter_with_3_coeffs,stbir__vertical_scatter_with_4_coeffs,stbir__vertical_scatter_with_5_coeffs,stbir__vertical_scatter_with_6_coeffs,stbir__vertical_scatter_with_7_coeffs,stbir__vertical_scatter_with_8_coeffs\n};\n\nstatic STBIR_VERTICAL_SCATTERFUNC * stbir__vertical_scatter_blends[ 8 ] =\n{\n  stbir__vertical_scatter_with_1_coeffs_cont,stbir__vertical_scatter_with_2_coeffs_cont,stbir__vertical_scatter_with_3_coeffs_cont,stbir__vertical_scatter_with_4_coeffs_cont,stbir__vertical_scatter_with_5_coeffs_cont,stbir__vertical_scatter_with_6_coeffs_cont,stbir__vertical_scatter_with_7_coeffs_cont,stbir__vertical_scatter_with_8_coeffs_cont\n};\n\n\nstatic void stbir__encode_scanline( stbir__info const * stbir_info, void *output_buffer_data, float * encode_buffer, int row  STBIR_ONLY_PROFILE_GET_SPLIT_INFO )\n{\n  int num_pixels = stbir_info->horizontal.scale_info.output_sub_size;\n  int channels = stbir_info->channels;\n  int width_times_channels = num_pixels * channels;\n  void * output_buffer;\n\n  // un-alpha weight if we need to\n  if ( stbir_info->alpha_unweight )\n  {\n    STBIR_PROFILE_START( unalpha );\n    stbir_info->alpha_unweight( encode_buffer, width_times_channels );\n    STBIR_PROFILE_END( unalpha );\n  }\n\n  // write directly into output by default\n  output_buffer = output_buffer_data;\n\n  // if we have an output callback, we first convert the decode buffer in place (and then hand that to the callback)\n  if ( stbir_info->out_pixels_cb )\n    output_buffer = encode_buffer;\n\n  STBIR_PROFILE_START( encode );\n  // convert into the output buffer\n  stbir_info->encode_pixels( output_buffer, width_times_channels, encode_buffer );\n  STBIR_PROFILE_END( encode );\n\n  // if we have an output callback, call it to send the data\n  if ( stbir_info->out_pixels_cb )\n    stbir_info->out_pixels_cb( output_buffer, num_pixels, row, stbir_info->user_data );\n}\n\n\n// Get the ring buffer pointer for an index\nstatic float* stbir__get_ring_buffer_entry(stbir__info const * stbir_info, stbir__per_split_info const * split_info, int index )\n{\n  STBIR_ASSERT( index < stbir_info->ring_buffer_num_entries );\n\n  #ifdef STBIR__SEPARATE_ALLOCATIONS\n    return split_info->ring_buffers[ index ];\n  #else\n    return (float*) ( ( (char*) split_info->ring_buffer ) + ( index * stbir_info->ring_buffer_length_bytes ) );\n  #endif\n}\n\n// Get the specified scan line from the ring buffer\nstatic float* stbir__get_ring_buffer_scanline(stbir__info const * stbir_info, stbir__per_split_info const * split_info, int get_scanline)\n{\n  int ring_buffer_index = (split_info->ring_buffer_begin_index + (get_scanline - split_info->ring_buffer_first_scanline)) % stbir_info->ring_buffer_num_entries;\n  return stbir__get_ring_buffer_entry( stbir_info, split_info, ring_buffer_index );\n}\n\nstatic void stbir__resample_horizontal_gather(stbir__info const * stbir_info, float* output_buffer, float const * input_buffer STBIR_ONLY_PROFILE_GET_SPLIT_INFO )\n{\n  float const * decode_buffer = input_buffer - ( stbir_info->scanline_extents.conservative.n0 * stbir_info->effective_channels );\n\n  STBIR_PROFILE_START( horizontal );\n  if ( ( stbir_info->horizontal.filter_enum == STBIR_FILTER_POINT_SAMPLE ) && ( stbir_info->horizontal.scale_info.scale == 1.0f ) )\n    STBIR_MEMCPY( output_buffer, input_buffer, stbir_info->horizontal.scale_info.output_sub_size * sizeof( float ) * stbir_info->effective_channels );\n  else\n    stbir_info->horizontal_gather_channels( output_buffer, stbir_info->horizontal.scale_info.output_sub_size, decode_buffer, stbir_info->horizontal.contributors, stbir_info->horizontal.coefficients, stbir_info->horizontal.coefficient_width );\n  STBIR_PROFILE_END( horizontal );\n}\n\nstatic void stbir__resample_vertical_gather(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n, int contrib_n0, int contrib_n1, float const * vertical_coefficients )\n{\n  float* encode_buffer = split_info->vertical_buffer;\n  float* decode_buffer = split_info->decode_buffer;\n  int vertical_first = stbir_info->vertical_first;\n  int width = (vertical_first) ? ( stbir_info->scanline_extents.conservative.n1-stbir_info->scanline_extents.conservative.n0+1 ) : stbir_info->horizontal.scale_info.output_sub_size;\n  int width_times_channels = stbir_info->effective_channels * width;\n\n  STBIR_ASSERT( stbir_info->vertical.is_gather );\n\n  // loop over the contributing scanlines and scale into the buffer\n  STBIR_PROFILE_START( vertical );\n  {\n    int k = 0, total = contrib_n1 - contrib_n0 + 1;\n    STBIR_ASSERT( total > 0 );\n    do {\n      float const * inputs[8];\n      int i, cnt = total; if ( cnt > 8 ) cnt = 8;\n      for( i = 0 ; i < cnt ; i++ )\n        inputs[ i ] = stbir__get_ring_buffer_scanline(stbir_info, split_info, k+i+contrib_n0 );\n\n      // call the N scanlines at a time function (up to 8 scanlines of blending at once)\n      ((k==0)?stbir__vertical_gathers:stbir__vertical_gathers_continues)[cnt-1]( (vertical_first) ? decode_buffer : encode_buffer, vertical_coefficients + k, inputs, inputs[0] + width_times_channels );\n      k += cnt;\n      total -= cnt;\n    } while ( total );\n  }\n  STBIR_PROFILE_END( vertical );\n\n  if ( vertical_first )\n  {\n    // Now resample the gathered vertical data in the horizontal axis into the encode buffer\n    stbir__resample_horizontal_gather(stbir_info, encode_buffer, decode_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n  }\n\n  stbir__encode_scanline( stbir_info, ( (char *) stbir_info->output_data ) + ((size_t)n * (size_t)stbir_info->output_stride_bytes),\n                          encode_buffer, n  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n}\n\nstatic void stbir__decode_and_resample_for_vertical_gather_loop(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n)\n{\n  int ring_buffer_index;\n  float* ring_buffer;\n\n  // Decode the nth scanline from the source image into the decode buffer.\n  stbir__decode_scanline( stbir_info, n, split_info->decode_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n  // update new end scanline\n  split_info->ring_buffer_last_scanline = n;\n\n  // get ring buffer\n  ring_buffer_index = (split_info->ring_buffer_begin_index + (split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline)) % stbir_info->ring_buffer_num_entries;\n  ring_buffer = stbir__get_ring_buffer_entry(stbir_info, split_info, ring_buffer_index);\n\n  // Now resample it into the ring buffer.\n  stbir__resample_horizontal_gather( stbir_info, ring_buffer, split_info->decode_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n  // Now it's sitting in the ring buffer ready to be used as source for the vertical sampling.\n}\n\nstatic void stbir__vertical_gather_loop( stbir__info const * stbir_info, stbir__per_split_info* split_info, int split_count )\n{\n  int y, start_output_y, end_output_y;\n  stbir__contributors* vertical_contributors = stbir_info->vertical.contributors;\n  float const * vertical_coefficients = stbir_info->vertical.coefficients;\n\n  STBIR_ASSERT( stbir_info->vertical.is_gather );\n\n  start_output_y = split_info->start_output_y;\n  end_output_y = split_info[split_count-1].end_output_y;\n\n  vertical_contributors += start_output_y;\n  vertical_coefficients += start_output_y * stbir_info->vertical.coefficient_width;\n\n  // initialize the ring buffer for gathering\n  split_info->ring_buffer_begin_index = 0;\n  split_info->ring_buffer_first_scanline = vertical_contributors->n0;\n  split_info->ring_buffer_last_scanline = split_info->ring_buffer_first_scanline - 1; // means \"empty\"\n\n  for (y = start_output_y; y < end_output_y; y++)\n  {\n    int in_first_scanline, in_last_scanline;\n\n    in_first_scanline = vertical_contributors->n0;\n    in_last_scanline = vertical_contributors->n1;\n\n    // make sure the indexing hasn't broken\n    STBIR_ASSERT( in_first_scanline >= split_info->ring_buffer_first_scanline );\n\n    // Load in new scanlines\n    while (in_last_scanline > split_info->ring_buffer_last_scanline)\n    {\n      STBIR_ASSERT( ( split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline + 1 ) <= stbir_info->ring_buffer_num_entries );\n\n      // make sure there was room in the ring buffer when we add new scanlines\n      if ( ( split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline + 1 ) == stbir_info->ring_buffer_num_entries )\n      {\n        split_info->ring_buffer_first_scanline++;\n        split_info->ring_buffer_begin_index++;\n      }\n\n      if ( stbir_info->vertical_first )\n      {\n        float * ring_buffer = stbir__get_ring_buffer_scanline( stbir_info, split_info, ++split_info->ring_buffer_last_scanline );\n        // Decode the nth scanline from the source image into the decode buffer.\n        stbir__decode_scanline( stbir_info, split_info->ring_buffer_last_scanline, ring_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n      }\n      else\n      {\n        stbir__decode_and_resample_for_vertical_gather_loop(stbir_info, split_info, split_info->ring_buffer_last_scanline + 1);\n      }\n    }\n\n    // Now all buffers should be ready to write a row of vertical sampling, so do it.\n    stbir__resample_vertical_gather(stbir_info, split_info, y, in_first_scanline, in_last_scanline, vertical_coefficients );\n\n    ++vertical_contributors;\n    vertical_coefficients += stbir_info->vertical.coefficient_width;\n  }\n}\n\n#define STBIR__FLOAT_EMPTY_MARKER 3.0e+38F\n#define STBIR__FLOAT_BUFFER_IS_EMPTY(ptr) ((ptr)[0]==STBIR__FLOAT_EMPTY_MARKER)\n\nstatic void stbir__encode_first_scanline_from_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info)\n{\n  // evict a scanline out into the output buffer\n  float* ring_buffer_entry = stbir__get_ring_buffer_entry(stbir_info, split_info, split_info->ring_buffer_begin_index );\n\n  // dump the scanline out\n  stbir__encode_scanline( stbir_info, ( (char *)stbir_info->output_data ) + ( (size_t)split_info->ring_buffer_first_scanline * (size_t)stbir_info->output_stride_bytes ), ring_buffer_entry, split_info->ring_buffer_first_scanline  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n  // mark it as empty\n  ring_buffer_entry[ 0 ] = STBIR__FLOAT_EMPTY_MARKER;\n\n  // advance the first scanline\n  split_info->ring_buffer_first_scanline++;\n  if ( ++split_info->ring_buffer_begin_index == stbir_info->ring_buffer_num_entries )\n    split_info->ring_buffer_begin_index = 0;\n}\n\nstatic void stbir__horizontal_resample_and_encode_first_scanline_from_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info)\n{\n  // evict a scanline out into the output buffer\n\n  float* ring_buffer_entry = stbir__get_ring_buffer_entry(stbir_info, split_info, split_info->ring_buffer_begin_index );\n\n  // Now resample it into the buffer.\n  stbir__resample_horizontal_gather( stbir_info, split_info->vertical_buffer, ring_buffer_entry  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n  // dump the scanline out\n  stbir__encode_scanline( stbir_info, ( (char *)stbir_info->output_data ) + ( (size_t)split_info->ring_buffer_first_scanline * (size_t)stbir_info->output_stride_bytes ), split_info->vertical_buffer, split_info->ring_buffer_first_scanline  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n  // mark it as empty\n  ring_buffer_entry[ 0 ] = STBIR__FLOAT_EMPTY_MARKER;\n\n  // advance the first scanline\n  split_info->ring_buffer_first_scanline++;\n  if ( ++split_info->ring_buffer_begin_index == stbir_info->ring_buffer_num_entries )\n    split_info->ring_buffer_begin_index = 0;\n}\n\nstatic void stbir__resample_vertical_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n0, int n1, float const * vertical_coefficients, float const * vertical_buffer, float const * vertical_buffer_end )\n{\n  STBIR_ASSERT( !stbir_info->vertical.is_gather );\n\n  STBIR_PROFILE_START( vertical );\n  {\n    int k = 0, total = n1 - n0 + 1;\n    STBIR_ASSERT( total > 0 );\n    do {\n      float * outputs[8];\n      int i, n = total; if ( n > 8 ) n = 8;\n      for( i = 0 ; i < n ; i++ )\n      {\n        outputs[ i ] = stbir__get_ring_buffer_scanline(stbir_info, split_info, k+i+n0 );\n        if ( ( i ) && ( STBIR__FLOAT_BUFFER_IS_EMPTY( outputs[i] ) != STBIR__FLOAT_BUFFER_IS_EMPTY( outputs[0] ) ) ) // make sure runs are of the same type\n        {\n          n = i;\n          break;\n        }\n      }\n      // call the scatter to N scanlines at a time function (up to 8 scanlines of scattering at once)\n      ((STBIR__FLOAT_BUFFER_IS_EMPTY( outputs[0] ))?stbir__vertical_scatter_sets:stbir__vertical_scatter_blends)[n-1]( outputs, vertical_coefficients + k, vertical_buffer, vertical_buffer_end );\n      k += n;\n      total -= n;\n    } while ( total );\n  }\n\n  STBIR_PROFILE_END( vertical );\n}\n\ntypedef void stbir__handle_scanline_for_scatter_func(stbir__info const * stbir_info, stbir__per_split_info* split_info);\n\nstatic void stbir__vertical_scatter_loop( stbir__info const * stbir_info, stbir__per_split_info* split_info, int split_count )\n{\n  int y, start_output_y, end_output_y, start_input_y, end_input_y;\n  stbir__contributors* vertical_contributors = stbir_info->vertical.contributors;\n  float const * vertical_coefficients = stbir_info->vertical.coefficients;\n  stbir__handle_scanline_for_scatter_func * handle_scanline_for_scatter;\n  void * scanline_scatter_buffer;\n  void * scanline_scatter_buffer_end;\n  int on_first_input_y, last_input_y;\n\n  STBIR_ASSERT( !stbir_info->vertical.is_gather );\n\n  start_output_y = split_info->start_output_y;\n  end_output_y = split_info[split_count-1].end_output_y;  // may do multiple split counts\n\n  start_input_y = split_info->start_input_y;\n  end_input_y = split_info[split_count-1].end_input_y;\n\n  // adjust for starting offset start_input_y\n  y = start_input_y + stbir_info->vertical.filter_pixel_margin;\n  vertical_contributors += y ;\n  vertical_coefficients += stbir_info->vertical.coefficient_width * y;\n\n  if ( stbir_info->vertical_first )\n  {\n    handle_scanline_for_scatter = stbir__horizontal_resample_and_encode_first_scanline_from_scatter;\n    scanline_scatter_buffer = split_info->decode_buffer;\n    scanline_scatter_buffer_end = ( (char*) scanline_scatter_buffer ) + sizeof( float ) * stbir_info->effective_channels * (stbir_info->scanline_extents.conservative.n1-stbir_info->scanline_extents.conservative.n0+1);\n  }\n  else\n  {\n    handle_scanline_for_scatter = stbir__encode_first_scanline_from_scatter;\n    scanline_scatter_buffer = split_info->vertical_buffer;\n    scanline_scatter_buffer_end = ( (char*) scanline_scatter_buffer ) + sizeof( float ) * stbir_info->effective_channels * stbir_info->horizontal.scale_info.output_sub_size;\n  }\n\n  // initialize the ring buffer for scattering\n  split_info->ring_buffer_first_scanline = start_output_y;\n  split_info->ring_buffer_last_scanline = -1;\n  split_info->ring_buffer_begin_index = -1;\n\n  // mark all the buffers as empty to start\n  for( y = 0 ; y < stbir_info->ring_buffer_num_entries ; y++ )\n    stbir__get_ring_buffer_entry( stbir_info, split_info, y )[0] = STBIR__FLOAT_EMPTY_MARKER; // only used on scatter\n\n  // do the loop in input space\n  on_first_input_y = 1; last_input_y = start_input_y;\n  for (y = start_input_y ; y < end_input_y; y++)\n  {\n    int out_first_scanline, out_last_scanline;\n\n    out_first_scanline = vertical_contributors->n0;\n    out_last_scanline = vertical_contributors->n1;\n\n    STBIR_ASSERT(out_last_scanline - out_first_scanline + 1 <= stbir_info->ring_buffer_num_entries);\n\n    if ( ( out_last_scanline >= out_first_scanline ) && ( ( ( out_first_scanline >= start_output_y ) && ( out_first_scanline < end_output_y ) ) || ( ( out_last_scanline >= start_output_y ) && ( out_last_scanline < end_output_y ) ) ) )\n    {\n      float const * vc = vertical_coefficients;\n\n      // keep track of the range actually seen for the next resize\n      last_input_y = y;\n      if ( ( on_first_input_y ) && ( y > start_input_y ) )\n        split_info->start_input_y = y;\n      on_first_input_y = 0;\n\n      // clip the region\n      if ( out_first_scanline < start_output_y )\n      {\n        vc += start_output_y - out_first_scanline;\n        out_first_scanline = start_output_y;\n      }\n\n      if ( out_last_scanline >= end_output_y )\n        out_last_scanline = end_output_y - 1;\n\n      // if very first scanline, init the index\n      if (split_info->ring_buffer_begin_index < 0)\n        split_info->ring_buffer_begin_index = out_first_scanline - start_output_y;\n\n      STBIR_ASSERT( split_info->ring_buffer_begin_index <= out_first_scanline );\n\n      // Decode the nth scanline from the source image into the decode buffer.\n      stbir__decode_scanline( stbir_info, y, split_info->decode_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n      // When horizontal first, we resample horizontally into the vertical buffer before we scatter it out\n      if ( !stbir_info->vertical_first )\n        stbir__resample_horizontal_gather( stbir_info, split_info->vertical_buffer, split_info->decode_buffer  STBIR_ONLY_PROFILE_SET_SPLIT_INFO );\n\n      // Now it's sitting in the buffer ready to be distributed into the ring buffers.\n\n      // evict from the ringbuffer, if we need are full\n      if ( ( ( split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline + 1 ) == stbir_info->ring_buffer_num_entries ) &&\n           ( out_last_scanline > split_info->ring_buffer_last_scanline ) )\n        handle_scanline_for_scatter( stbir_info, split_info );\n\n      // Now the horizontal buffer is ready to write to all ring buffer rows, so do it.\n      stbir__resample_vertical_scatter(stbir_info, split_info, out_first_scanline, out_last_scanline, vc, (float*)scanline_scatter_buffer, (float*)scanline_scatter_buffer_end );\n\n      // update the end of the buffer\n      if ( out_last_scanline > split_info->ring_buffer_last_scanline )\n        split_info->ring_buffer_last_scanline = out_last_scanline;\n    }\n    ++vertical_contributors;\n    vertical_coefficients += stbir_info->vertical.coefficient_width;\n  }\n\n  // now evict the scanlines that are left over in the ring buffer\n  while ( split_info->ring_buffer_first_scanline < end_output_y )\n    handle_scanline_for_scatter(stbir_info, split_info);\n\n  // update the end_input_y if we do multiple resizes with the same data\n  ++last_input_y;\n  for( y = 0 ; y < split_count; y++ )\n    if ( split_info[y].end_input_y > last_input_y )\n      split_info[y].end_input_y = last_input_y;\n}\n\n\nstatic stbir__kernel_callback * stbir__builtin_kernels[] =   { 0, stbir__filter_trapezoid,  stbir__filter_triangle, stbir__filter_cubic, stbir__filter_catmullrom, stbir__filter_mitchell, stbir__filter_point };\nstatic stbir__support_callback * stbir__builtin_supports[] = { 0, stbir__support_trapezoid, stbir__support_one,     stbir__support_two,  stbir__support_two,       stbir__support_two,     stbir__support_zeropoint5 };\n\nstatic void stbir__set_sampler(stbir__sampler * samp, stbir_filter filter, stbir__kernel_callback * kernel, stbir__support_callback * support, stbir_edge edge, stbir__scale_info * scale_info, int always_gather, void * user_data )\n{\n  // set filter\n  if (filter == 0)\n  {\n    filter = STBIR_DEFAULT_FILTER_DOWNSAMPLE; // default to downsample\n    if (scale_info->scale >= ( 1.0f - stbir__small_float ) )\n    {\n      if ( (scale_info->scale <= ( 1.0f + stbir__small_float ) ) && ( STBIR_CEILF(scale_info->pixel_shift) == scale_info->pixel_shift ) )\n        filter = STBIR_FILTER_POINT_SAMPLE;\n      else\n        filter = STBIR_DEFAULT_FILTER_UPSAMPLE;\n    }\n  }\n  samp->filter_enum = filter;\n\n  STBIR_ASSERT(samp->filter_enum != 0);\n  STBIR_ASSERT((unsigned)samp->filter_enum < STBIR_FILTER_OTHER);\n  samp->filter_kernel = stbir__builtin_kernels[ filter ];\n  samp->filter_support = stbir__builtin_supports[ filter ];\n\n  if ( kernel && support )\n  {\n    samp->filter_kernel = kernel;\n    samp->filter_support = support;\n    samp->filter_enum = STBIR_FILTER_OTHER;\n  }\n\n  samp->edge = edge;\n  samp->filter_pixel_width  = stbir__get_filter_pixel_width (samp->filter_support, scale_info->scale, user_data );\n  // Gather is always better, but in extreme downsamples, you have to most or all of the data in memory\n  //    For horizontal, we always have all the pixels, so we always use gather here (always_gather==1).\n  //    For vertical, we use gather if scaling up (which means we will have samp->filter_pixel_width\n  //    scanlines in memory at once).\n  samp->is_gather = 0;\n  if ( scale_info->scale >= ( 1.0f - stbir__small_float ) )\n    samp->is_gather = 1;\n  else if ( ( always_gather ) || ( samp->filter_pixel_width <= STBIR_FORCE_GATHER_FILTER_SCANLINES_AMOUNT ) )\n    samp->is_gather = 2;\n\n  // pre calculate stuff based on the above\n  samp->coefficient_width = stbir__get_coefficient_width(samp, samp->is_gather, user_data);\n\n  // filter_pixel_width is the conservative size in pixels of input that affect an output pixel.\n  //   In rare cases (only with 2 pix to 1 pix with the default filters), it's possible that the \n  //   filter will extend before or after the scanline beyond just one extra entire copy of the \n  //   scanline (we would hit the edge twice). We don't let you do that, so we clamp the total \n  //   width to 3x the total of input pixel (once for the scanline, once for the left side \n  //   overhang, and once for the right side). We only do this for edge mode, since the other \n  //   modes can just re-edge clamp back in again.\n  if ( edge == STBIR_EDGE_WRAP )\n    if ( samp->filter_pixel_width > ( scale_info->input_full_size * 3 ) )\n      samp->filter_pixel_width = scale_info->input_full_size * 3;\n\n  // This is how much to expand buffers to account for filters seeking outside\n  // the image boundaries.\n  samp->filter_pixel_margin = samp->filter_pixel_width / 2;\n  \n  // filter_pixel_margin is the amount that this filter can overhang on just one side of either \n  //   end of the scanline (left or the right). Since we only allow you to overhang 1 scanline's \n  //   worth of pixels, we clamp this one side of overhang to the input scanline size. Again, \n  //   this clamping only happens in rare cases with the default filters (2 pix to 1 pix). \n  if ( edge == STBIR_EDGE_WRAP )\n    if ( samp->filter_pixel_margin > scale_info->input_full_size )\n      samp->filter_pixel_margin = scale_info->input_full_size;\n\n  samp->num_contributors = stbir__get_contributors(samp, samp->is_gather);\n\n  samp->contributors_size = samp->num_contributors * sizeof(stbir__contributors);\n  samp->coefficients_size = samp->num_contributors * samp->coefficient_width * sizeof(float) + sizeof(float); // extra sizeof(float) is padding\n\n  samp->gather_prescatter_contributors = 0;\n  samp->gather_prescatter_coefficients = 0;\n  if ( samp->is_gather == 0 )\n  {\n    samp->gather_prescatter_coefficient_width = samp->filter_pixel_width;\n    samp->gather_prescatter_num_contributors  = stbir__get_contributors(samp, 2);\n    samp->gather_prescatter_contributors_size = samp->gather_prescatter_num_contributors * sizeof(stbir__contributors);\n    samp->gather_prescatter_coefficients_size = samp->gather_prescatter_num_contributors * samp->gather_prescatter_coefficient_width * sizeof(float);\n  }\n}\n\nstatic void stbir__get_conservative_extents( stbir__sampler * samp, stbir__contributors * range, void * user_data )\n{\n  float scale = samp->scale_info.scale;\n  float out_shift = samp->scale_info.pixel_shift;\n  stbir__support_callback * support = samp->filter_support;\n  int input_full_size = samp->scale_info.input_full_size;\n  stbir_edge edge = samp->edge;\n  float inv_scale = samp->scale_info.inv_scale;\n\n  STBIR_ASSERT( samp->is_gather != 0 );\n\n  if ( samp->is_gather == 1 )\n  {\n    int in_first_pixel, in_last_pixel;\n    float out_filter_radius = support(inv_scale, user_data) * scale;\n\n    stbir__calculate_in_pixel_range( &in_first_pixel, &in_last_pixel, 0.5, out_filter_radius, inv_scale, out_shift, input_full_size, edge );\n    range->n0 = in_first_pixel;\n    stbir__calculate_in_pixel_range( &in_first_pixel, &in_last_pixel, ( (float)(samp->scale_info.output_sub_size-1) ) + 0.5f, out_filter_radius, inv_scale, out_shift, input_full_size, edge );\n    range->n1 = in_last_pixel;\n  }\n  else if ( samp->is_gather == 2 ) // downsample gather, refine\n  {\n    float in_pixels_radius = support(scale, user_data) * inv_scale;\n    int filter_pixel_margin = samp->filter_pixel_margin;\n    int output_sub_size = samp->scale_info.output_sub_size;\n    int input_end;\n    int n;\n    int in_first_pixel, in_last_pixel;\n\n    // get a conservative area of the input range\n    stbir__calculate_in_pixel_range( &in_first_pixel, &in_last_pixel, 0, 0, inv_scale, out_shift, input_full_size, edge );\n    range->n0 = in_first_pixel;\n    stbir__calculate_in_pixel_range( &in_first_pixel, &in_last_pixel, (float)output_sub_size, 0, inv_scale, out_shift, input_full_size, edge );\n    range->n1 = in_last_pixel;\n\n    // now go through the margin to the start of area to find bottom\n    n = range->n0 + 1;\n    input_end = -filter_pixel_margin;\n    while( n >= input_end )\n    {\n      int out_first_pixel, out_last_pixel;\n      stbir__calculate_out_pixel_range( &out_first_pixel, &out_last_pixel, ((float)n)+0.5f, in_pixels_radius, scale, out_shift, output_sub_size );\n      if ( out_first_pixel > out_last_pixel )\n        break;\n\n      if ( ( out_first_pixel < output_sub_size ) || ( out_last_pixel >= 0 ) )\n        range->n0 = n;\n      --n;\n    }\n\n    // now go through the end of the area through the margin to find top\n    n = range->n1 - 1;\n    input_end = n + 1 + filter_pixel_margin;\n    while( n <= input_end )\n    {\n      int out_first_pixel, out_last_pixel;\n      stbir__calculate_out_pixel_range( &out_first_pixel, &out_last_pixel, ((float)n)+0.5f, in_pixels_radius, scale, out_shift, output_sub_size );\n      if ( out_first_pixel > out_last_pixel )\n        break;\n      if ( ( out_first_pixel < output_sub_size ) || ( out_last_pixel >= 0 ) )\n        range->n1 = n;\n      ++n;\n    }\n  }\n\n  if ( samp->edge == STBIR_EDGE_WRAP )\n  {\n    // if we are wrapping, and we are very close to the image size (so the edges might merge), just use the scanline up to the edge\n    if ( ( range->n0 > 0 ) && ( range->n1 >= input_full_size ) )\n    {\n      int marg = range->n1 - input_full_size + 1;\n      if ( ( marg + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= range->n0 )\n        range->n0 = 0;\n    }\n    if ( ( range->n0 < 0 ) && ( range->n1 < (input_full_size-1) ) )\n    {\n      int marg = -range->n0;\n      if ( ( input_full_size - marg - STBIR__MERGE_RUNS_PIXEL_THRESHOLD - 1 ) <= range->n1 )\n        range->n1 = input_full_size - 1;\n    }\n  }\n  else\n  {\n    // for non-edge-wrap modes, we never read over the edge, so clamp\n    if ( range->n0 < 0 )\n      range->n0 = 0;\n    if ( range->n1 >= input_full_size )\n      range->n1 = input_full_size - 1;\n  }\n}\n\nstatic void stbir__get_split_info( stbir__per_split_info* split_info, int splits, int output_height, int vertical_pixel_margin, int input_full_height )\n{\n  int i, cur;\n  int left = output_height;\n\n  cur = 0;\n  for( i = 0 ; i < splits ; i++ )\n  {\n    int each;\n    split_info[i].start_output_y = cur;\n    each = left / ( splits - i );\n    split_info[i].end_output_y = cur + each;\n    cur += each;\n    left -= each;\n\n    // scatter range (updated to minimum as you run it)\n    split_info[i].start_input_y = -vertical_pixel_margin;\n    split_info[i].end_input_y = input_full_height + vertical_pixel_margin;\n  }\n}\n\nstatic void stbir__free_internal_mem( stbir__info *info )\n{\n  #define STBIR__FREE_AND_CLEAR( ptr ) { if ( ptr ) { void * p = (ptr); (ptr) = 0; STBIR_FREE( p, info->user_data); } }\n\n  if ( info )\n  {\n  #ifndef STBIR__SEPARATE_ALLOCATIONS\n    STBIR__FREE_AND_CLEAR( info->alloced_mem );\n  #else\n    int i,j;\n\n    if ( ( info->vertical.gather_prescatter_contributors ) && ( (void*)info->vertical.gather_prescatter_contributors != (void*)info->split_info[0].decode_buffer ) )\n    {\n      STBIR__FREE_AND_CLEAR( info->vertical.gather_prescatter_coefficients );\n      STBIR__FREE_AND_CLEAR( info->vertical.gather_prescatter_contributors );\n    }\n    for( i = 0 ; i < info->splits ; i++ )\n    {\n      for( j = 0 ; j < info->alloc_ring_buffer_num_entries ; j++ )\n      {\n        #ifdef STBIR_SIMD8\n        if ( info->effective_channels == 3 )\n          --info->split_info[i].ring_buffers[j]; // avx in 3 channel mode needs one float at the start of the buffer\n        #endif\n        STBIR__FREE_AND_CLEAR( info->split_info[i].ring_buffers[j] );\n      }\n\n      #ifdef STBIR_SIMD8\n      if ( info->effective_channels == 3 )\n        --info->split_info[i].decode_buffer; // avx in 3 channel mode needs one float at the start of the buffer\n      #endif\n      STBIR__FREE_AND_CLEAR( info->split_info[i].decode_buffer );\n      STBIR__FREE_AND_CLEAR( info->split_info[i].ring_buffers );\n      STBIR__FREE_AND_CLEAR( info->split_info[i].vertical_buffer );\n    }\n    STBIR__FREE_AND_CLEAR( info->split_info );\n    if ( info->vertical.coefficients != info->horizontal.coefficients )\n    {\n      STBIR__FREE_AND_CLEAR( info->vertical.coefficients );\n      STBIR__FREE_AND_CLEAR( info->vertical.contributors );\n    }\n    STBIR__FREE_AND_CLEAR( info->horizontal.coefficients );\n    STBIR__FREE_AND_CLEAR( info->horizontal.contributors );\n    STBIR__FREE_AND_CLEAR( info->alloced_mem );\n    STBIR_FREE( info, info->user_data );\n  #endif\n  }\n\n  #undef STBIR__FREE_AND_CLEAR\n}\n\nstatic int stbir__get_max_split( int splits, int height )\n{\n  int i;\n  int max = 0;\n\n  for( i = 0 ; i < splits ; i++ )\n  {\n    int each = height / ( splits - i );\n    if ( each > max )\n      max = each;\n    height -= each;\n  }\n  return max;\n}\n\nstatic stbir__horizontal_gather_channels_func ** stbir__horizontal_gather_n_coeffs_funcs[8] =\n{\n  0, stbir__horizontal_gather_1_channels_with_n_coeffs_funcs, stbir__horizontal_gather_2_channels_with_n_coeffs_funcs, stbir__horizontal_gather_3_channels_with_n_coeffs_funcs, stbir__horizontal_gather_4_channels_with_n_coeffs_funcs, 0,0, stbir__horizontal_gather_7_channels_with_n_coeffs_funcs\n};\n\nstatic stbir__horizontal_gather_channels_func ** stbir__horizontal_gather_channels_funcs[8] =\n{\n  0, stbir__horizontal_gather_1_channels_funcs, stbir__horizontal_gather_2_channels_funcs, stbir__horizontal_gather_3_channels_funcs, stbir__horizontal_gather_4_channels_funcs, 0,0, stbir__horizontal_gather_7_channels_funcs\n};\n\n// there are six resize classifications: 0 == vertical scatter, 1 == vertical gather < 1x scale, 2 == vertical gather 1x-2x scale, 4 == vertical gather < 3x scale, 4 == vertical gather > 3x scale, 5 == <=4 pixel height, 6 == <=4 pixel wide column\n#define STBIR_RESIZE_CLASSIFICATIONS 8\n\nstatic float stbir__compute_weights[5][STBIR_RESIZE_CLASSIFICATIONS][4]=  // 5 = 0=1chan, 1=2chan, 2=3chan, 3=4chan, 4=7chan\n{\n  {\n    { 1.00000f, 1.00000f, 0.31250f, 1.00000f },\n    { 0.56250f, 0.59375f, 0.00000f, 0.96875f },\n    { 1.00000f, 0.06250f, 0.00000f, 1.00000f },\n    { 0.00000f, 0.09375f, 1.00000f, 1.00000f },\n    { 1.00000f, 1.00000f, 1.00000f, 1.00000f },\n    { 0.03125f, 0.12500f, 1.00000f, 1.00000f },\n    { 0.06250f, 0.12500f, 0.00000f, 1.00000f },\n    { 0.00000f, 1.00000f, 0.00000f, 0.03125f },\n  }, {\n    { 0.00000f, 0.84375f, 0.00000f, 0.03125f },\n    { 0.09375f, 0.93750f, 0.00000f, 0.78125f },\n    { 0.87500f, 0.21875f, 0.00000f, 0.96875f },\n    { 0.09375f, 0.09375f, 1.00000f, 1.00000f },\n    { 1.00000f, 1.00000f, 1.00000f, 1.00000f },\n    { 0.03125f, 0.12500f, 1.00000f, 1.00000f },\n    { 0.06250f, 0.12500f, 0.00000f, 1.00000f },\n    { 0.00000f, 1.00000f, 0.00000f, 0.53125f },\n  }, {\n    { 0.00000f, 0.53125f, 0.00000f, 0.03125f },\n    { 0.06250f, 0.96875f, 0.00000f, 0.53125f },\n    { 0.87500f, 0.18750f, 0.00000f, 0.93750f },\n    { 0.00000f, 0.09375f, 1.00000f, 1.00000f },\n    { 1.00000f, 1.00000f, 1.00000f, 1.00000f },\n    { 0.03125f, 0.12500f, 1.00000f, 1.00000f },\n    { 0.06250f, 0.12500f, 0.00000f, 1.00000f },\n    { 0.00000f, 1.00000f, 0.00000f, 0.56250f },\n  }, {\n    { 0.00000f, 0.50000f, 0.00000f, 0.71875f },\n    { 0.06250f, 0.84375f, 0.00000f, 0.87500f },\n    { 1.00000f, 0.50000f, 0.50000f, 0.96875f },\n    { 1.00000f, 0.09375f, 0.31250f, 0.50000f },\n    { 1.00000f, 1.00000f, 1.00000f, 1.00000f },\n    { 1.00000f, 0.03125f, 0.03125f, 0.53125f },\n    { 0.18750f, 0.12500f, 0.00000f, 1.00000f },\n    { 0.00000f, 1.00000f, 0.03125f, 0.18750f },\n  }, {\n    { 0.00000f, 0.59375f, 0.00000f, 0.96875f },\n    { 0.06250f, 0.81250f, 0.06250f, 0.59375f },\n    { 0.75000f, 0.43750f, 0.12500f, 0.96875f },\n    { 0.87500f, 0.06250f, 0.18750f, 0.43750f },\n    { 1.00000f, 1.00000f, 1.00000f, 1.00000f },\n    { 0.15625f, 0.12500f, 1.00000f, 1.00000f },\n    { 0.06250f, 0.12500f, 0.00000f, 1.00000f },\n    { 0.00000f, 1.00000f, 0.03125f, 0.34375f },\n  }\n};\n\n// structure that allow us to query and override info for training the costs\ntypedef struct STBIR__V_FIRST_INFO\n{\n  double v_cost, h_cost;\n  int control_v_first; // 0 = no control, 1 = force hori, 2 = force vert\n  int v_first;\n  int v_resize_classification;\n  int is_gather;\n} STBIR__V_FIRST_INFO;\n\n#ifdef STBIR__V_FIRST_INFO_BUFFER\nstatic STBIR__V_FIRST_INFO STBIR__V_FIRST_INFO_BUFFER = {0};\n#define STBIR__V_FIRST_INFO_POINTER &STBIR__V_FIRST_INFO_BUFFER\n#else\n#define STBIR__V_FIRST_INFO_POINTER 0\n#endif\n\n// Figure out whether to scale along the horizontal or vertical first.\n//   This only *super* important when you are scaling by a massively\n//   different amount in the vertical vs the horizontal (for example, if\n//   you are scaling by 2x in the width, and 0.5x in the height, then you\n//   want to do the vertical scale first, because it's around 3x faster\n//   in that order.\n//\n//   In more normal circumstances, this makes a 20-40% differences, so\n//     it's good to get right, but not critical. The normal way that you\n//     decide which direction goes first is just figuring out which\n//     direction does more multiplies. But with modern CPUs with their\n//     fancy caches and SIMD and high IPC abilities, so there's just a lot\n//     more that goes into it.\n//\n//   My handwavy sort of solution is to have an app that does a whole\n//     bunch of timing for both vertical and horizontal first modes,\n//     and then another app that can read lots of these timing files\n//     and try to search for the best weights to use. Dotimings.c\n//     is the app that does a bunch of timings, and vf_train.c is the\n//     app that solves for the best weights (and shows how well it\n//     does currently).\n\nstatic int stbir__should_do_vertical_first( float weights_table[STBIR_RESIZE_CLASSIFICATIONS][4], int horizontal_filter_pixel_width, float horizontal_scale, int horizontal_output_size, int vertical_filter_pixel_width, float vertical_scale, int vertical_output_size, int is_gather, STBIR__V_FIRST_INFO * info )\n{\n  double v_cost, h_cost;\n  float * weights;\n  int vertical_first;\n  int v_classification;\n\n  // categorize the resize into buckets\n  if ( ( vertical_output_size <= 4 ) || ( horizontal_output_size <= 4 ) )\n    v_classification = ( vertical_output_size < horizontal_output_size ) ? 6 : 7;\n  else if ( vertical_scale <= 1.0f )\n    v_classification = ( is_gather ) ? 1 : 0;\n  else if ( vertical_scale <= 2.0f)\n    v_classification = 2;\n  else if ( vertical_scale <= 3.0f)\n    v_classification = 3;\n  else if ( vertical_scale <= 4.0f)\n    v_classification = 5;\n  else\n    v_classification = 6;\n\n  // use the right weights\n  weights = weights_table[ v_classification ];\n\n  // this is the costs when you don't take into account modern CPUs with high ipc and simd and caches - wish we had a better estimate\n  h_cost = (float)horizontal_filter_pixel_width * weights[0] + horizontal_scale * (float)vertical_filter_pixel_width * weights[1];\n  v_cost = (float)vertical_filter_pixel_width  * weights[2] + vertical_scale * (float)horizontal_filter_pixel_width * weights[3];\n\n  // use computation estimate to decide vertical first or not\n  vertical_first = ( v_cost <= h_cost ) ? 1 : 0;\n\n  // save these, if requested\n  if ( info )\n  {\n    info->h_cost = h_cost;\n    info->v_cost = v_cost;\n    info->v_resize_classification = v_classification;\n    info->v_first = vertical_first;\n    info->is_gather = is_gather;\n  }\n\n  // and this allows us to override everything for testing (see dotiming.c)\n  if ( ( info ) && ( info->control_v_first ) )\n    vertical_first = ( info->control_v_first == 2 ) ? 1 : 0;\n\n  return vertical_first;\n}\n\n// layout lookups - must match stbir_internal_pixel_layout\nstatic unsigned char stbir__pixel_channels[] = {\n  1,2,3,3,4,   // 1ch, 2ch, rgb, bgr, 4ch\n  4,4,4,4,2,2, // RGBA,BGRA,ARGB,ABGR,RA,AR\n  4,4,4,4,2,2, // RGBA_PM,BGRA_PM,ARGB_PM,ABGR_PM,RA_PM,AR_PM\n};\n\n// the internal pixel layout enums are in a different order, so we can easily do range comparisons of types\n//   the public pixel layout is ordered in a way that if you cast num_channels (1-4) to the enum, you get something sensible\nstatic stbir_internal_pixel_layout stbir__pixel_layout_convert_public_to_internal[] = {\n  STBIRI_BGR, STBIRI_1CHANNEL, STBIRI_2CHANNEL, STBIRI_RGB, STBIRI_RGBA,\n  STBIRI_4CHANNEL, STBIRI_BGRA, STBIRI_ARGB, STBIRI_ABGR, STBIRI_RA, STBIRI_AR,\n  STBIRI_RGBA_PM, STBIRI_BGRA_PM, STBIRI_ARGB_PM, STBIRI_ABGR_PM, STBIRI_RA_PM, STBIRI_AR_PM,\n};\n\nstatic stbir__info * stbir__alloc_internal_mem_and_build_samplers( stbir__sampler * horizontal, stbir__sampler * vertical, stbir__contributors * conservative, stbir_pixel_layout input_pixel_layout_public, stbir_pixel_layout output_pixel_layout_public, int splits, int new_x, int new_y, int fast_alpha, void * user_data STBIR_ONLY_PROFILE_BUILD_GET_INFO )\n{\n  static char stbir_channel_count_index[8]={ 9,0,1,2, 3,9,9,4 };\n\n  stbir__info * info = 0;\n  void * alloced = 0;\n  size_t alloced_total = 0;\n  int vertical_first;\n  int decode_buffer_size, ring_buffer_length_bytes, ring_buffer_size, vertical_buffer_size, alloc_ring_buffer_num_entries;\n\n  int alpha_weighting_type = 0; // 0=none, 1=simple, 2=fancy\n  int conservative_split_output_size = stbir__get_max_split( splits, vertical->scale_info.output_sub_size );\n  stbir_internal_pixel_layout input_pixel_layout = stbir__pixel_layout_convert_public_to_internal[ input_pixel_layout_public ];\n  stbir_internal_pixel_layout output_pixel_layout = stbir__pixel_layout_convert_public_to_internal[ output_pixel_layout_public ];\n  int channels = stbir__pixel_channels[ input_pixel_layout ];\n  int effective_channels = channels;\n\n  // first figure out what type of alpha weighting to use (if any)\n  if ( ( horizontal->filter_enum != STBIR_FILTER_POINT_SAMPLE ) || ( vertical->filter_enum != STBIR_FILTER_POINT_SAMPLE ) ) // no alpha weighting on point sampling\n  {\n    if ( ( input_pixel_layout >= STBIRI_RGBA ) && ( input_pixel_layout <= STBIRI_AR ) && ( output_pixel_layout >= STBIRI_RGBA ) && ( output_pixel_layout <= STBIRI_AR ) )\n    {\n      if ( fast_alpha )\n      {\n        alpha_weighting_type = 4;\n      }\n      else\n      {\n        static int fancy_alpha_effective_cnts[6] = { 7, 7, 7, 7, 3, 3 };\n        alpha_weighting_type = 2;\n        effective_channels = fancy_alpha_effective_cnts[ input_pixel_layout - STBIRI_RGBA ];\n      }\n    }\n    else if ( ( input_pixel_layout >= STBIRI_RGBA_PM ) && ( input_pixel_layout <= STBIRI_AR_PM ) && ( output_pixel_layout >= STBIRI_RGBA ) && ( output_pixel_layout <= STBIRI_AR ) )\n    {\n      // input premult, output non-premult\n      alpha_weighting_type = 3;\n    }\n    else if ( ( input_pixel_layout >= STBIRI_RGBA ) && ( input_pixel_layout <= STBIRI_AR ) && ( output_pixel_layout >= STBIRI_RGBA_PM ) && ( output_pixel_layout <= STBIRI_AR_PM ) )\n    {\n      // input non-premult, output premult\n      alpha_weighting_type = 1;\n    }\n  }\n\n  // channel in and out count must match currently\n  if ( channels != stbir__pixel_channels[ output_pixel_layout ] )\n    return 0;\n\n  // get vertical first\n  vertical_first = stbir__should_do_vertical_first( stbir__compute_weights[ (int)stbir_channel_count_index[ effective_channels ] ], horizontal->filter_pixel_width, horizontal->scale_info.scale, horizontal->scale_info.output_sub_size, vertical->filter_pixel_width, vertical->scale_info.scale, vertical->scale_info.output_sub_size, vertical->is_gather, STBIR__V_FIRST_INFO_POINTER );\n\n  // sometimes read one float off in some of the unrolled loops (with a weight of zero coeff, so it doesn't have an effect)\n  decode_buffer_size = ( conservative->n1 - conservative->n0 + 1 ) * effective_channels * sizeof(float) + sizeof(float); // extra float for padding\n\n#if defined( STBIR__SEPARATE_ALLOCATIONS ) && defined(STBIR_SIMD8)\n  if ( effective_channels == 3 )\n    decode_buffer_size += sizeof(float); // avx in 3 channel mode needs one float at the start of the buffer (only with separate allocations)\n#endif\n\n  ring_buffer_length_bytes = horizontal->scale_info.output_sub_size * effective_channels * sizeof(float) + sizeof(float); // extra float for padding\n\n  // if we do vertical first, the ring buffer holds a whole decoded line\n  if ( vertical_first )\n    ring_buffer_length_bytes = ( decode_buffer_size + 15 ) & ~15;\n\n  if ( ( ring_buffer_length_bytes & 4095 ) == 0 ) ring_buffer_length_bytes += 64*3; // avoid 4k alias\n\n  // One extra entry because floating point precision problems sometimes cause an extra to be necessary.\n  alloc_ring_buffer_num_entries = vertical->filter_pixel_width + 1;\n\n  // we never need more ring buffer entries than the scanlines we're outputting when in scatter mode\n  if ( ( !vertical->is_gather ) && ( alloc_ring_buffer_num_entries > conservative_split_output_size ) )\n    alloc_ring_buffer_num_entries = conservative_split_output_size;\n\n  ring_buffer_size = alloc_ring_buffer_num_entries * ring_buffer_length_bytes;\n\n  // The vertical buffer is used differently, depending on whether we are scattering\n  //   the vertical scanlines, or gathering them.\n  //   If scattering, it's used at the temp buffer to accumulate each output.\n  //   If gathering, it's just the output buffer.\n  vertical_buffer_size = horizontal->scale_info.output_sub_size * effective_channels * sizeof(float) + sizeof(float);  // extra float for padding\n\n  // we make two passes through this loop, 1st to add everything up, 2nd to allocate and init\n  for(;;)\n  {\n    int i;\n    void * advance_mem = alloced;\n    int copy_horizontal = 0;\n    stbir__sampler * possibly_use_horizontal_for_pivot = 0;\n\n#ifdef STBIR__SEPARATE_ALLOCATIONS\n    #define STBIR__NEXT_PTR( ptr, size, ntype ) if ( alloced ) { void * p = STBIR_MALLOC( size, user_data); if ( p == 0 ) { stbir__free_internal_mem( info ); return 0; } (ptr) = (ntype*)p; }\n#else\n    #define STBIR__NEXT_PTR( ptr, size, ntype ) advance_mem = (void*) ( ( ((size_t)advance_mem) + 15 ) & ~15 ); if ( alloced ) ptr = (ntype*)advance_mem; advance_mem = ((char*)advance_mem) + (size);\n#endif\n\n    STBIR__NEXT_PTR( info, sizeof( stbir__info ), stbir__info );\n\n    STBIR__NEXT_PTR( info->split_info, sizeof( stbir__per_split_info ) * splits, stbir__per_split_info );\n\n    if ( info )\n    {\n      static stbir__alpha_weight_func * fancy_alpha_weights[6]  =    { stbir__fancy_alpha_weight_4ch,   stbir__fancy_alpha_weight_4ch,   stbir__fancy_alpha_weight_4ch,   stbir__fancy_alpha_weight_4ch,   stbir__fancy_alpha_weight_2ch,   stbir__fancy_alpha_weight_2ch };\n      static stbir__alpha_unweight_func * fancy_alpha_unweights[6] = { stbir__fancy_alpha_unweight_4ch, stbir__fancy_alpha_unweight_4ch, stbir__fancy_alpha_unweight_4ch, stbir__fancy_alpha_unweight_4ch, stbir__fancy_alpha_unweight_2ch, stbir__fancy_alpha_unweight_2ch };\n      static stbir__alpha_weight_func * simple_alpha_weights[6] = { stbir__simple_alpha_weight_4ch, stbir__simple_alpha_weight_4ch, stbir__simple_alpha_weight_4ch, stbir__simple_alpha_weight_4ch, stbir__simple_alpha_weight_2ch, stbir__simple_alpha_weight_2ch };\n      static stbir__alpha_unweight_func * simple_alpha_unweights[6] = { stbir__simple_alpha_unweight_4ch, stbir__simple_alpha_unweight_4ch, stbir__simple_alpha_unweight_4ch, stbir__simple_alpha_unweight_4ch, stbir__simple_alpha_unweight_2ch, stbir__simple_alpha_unweight_2ch };\n\n      // initialize info fields\n      info->alloced_mem = alloced;\n      info->alloced_total = alloced_total;\n\n      info->channels = channels;\n      info->effective_channels = effective_channels;\n\n      info->offset_x = new_x;\n      info->offset_y = new_y;\n      info->alloc_ring_buffer_num_entries = alloc_ring_buffer_num_entries;\n      info->ring_buffer_num_entries = 0;\n      info->ring_buffer_length_bytes = ring_buffer_length_bytes;\n      info->splits = splits;\n      info->vertical_first = vertical_first;\n\n      info->input_pixel_layout_internal = input_pixel_layout;\n      info->output_pixel_layout_internal = output_pixel_layout;\n\n      // setup alpha weight functions\n      info->alpha_weight = 0;\n      info->alpha_unweight = 0;\n\n      // handle alpha weighting functions and overrides\n      if ( alpha_weighting_type == 2 )\n      {\n        // high quality alpha multiplying on the way in, dividing on the way out\n        info->alpha_weight = fancy_alpha_weights[ input_pixel_layout - STBIRI_RGBA ];\n        info->alpha_unweight = fancy_alpha_unweights[ output_pixel_layout - STBIRI_RGBA ];\n      }\n      else if ( alpha_weighting_type == 4 )\n      {\n        // fast alpha multiplying on the way in, dividing on the way out\n        info->alpha_weight = simple_alpha_weights[ input_pixel_layout - STBIRI_RGBA ];\n        info->alpha_unweight = simple_alpha_unweights[ output_pixel_layout - STBIRI_RGBA ];\n      }\n      else if ( alpha_weighting_type == 1 )\n      {\n        // fast alpha on the way in, leave in premultiplied form on way out\n        info->alpha_weight = simple_alpha_weights[ input_pixel_layout - STBIRI_RGBA ];\n      }\n      else if ( alpha_weighting_type == 3 )\n      {\n        // incoming is premultiplied, fast alpha dividing on the way out - non-premultiplied output\n        info->alpha_unweight = simple_alpha_unweights[ output_pixel_layout - STBIRI_RGBA ];\n      }\n\n      // handle 3-chan color flipping, using the alpha weight path\n      if ( ( ( input_pixel_layout == STBIRI_RGB ) && ( output_pixel_layout == STBIRI_BGR ) ) ||\n           ( ( input_pixel_layout == STBIRI_BGR ) && ( output_pixel_layout == STBIRI_RGB ) ) )\n      {\n        // do the flipping on the smaller of the two ends\n        if ( horizontal->scale_info.scale < 1.0f )\n          info->alpha_unweight = stbir__simple_flip_3ch;\n        else\n          info->alpha_weight = stbir__simple_flip_3ch;\n      }\n\n    }\n\n    // get all the per-split buffers\n    for( i = 0 ; i < splits ; i++ )\n    {\n      STBIR__NEXT_PTR( info->split_info[i].decode_buffer, decode_buffer_size, float );\n\n#ifdef STBIR__SEPARATE_ALLOCATIONS\n\n      #ifdef STBIR_SIMD8\n      if ( ( info ) && ( effective_channels == 3 ) )\n        ++info->split_info[i].decode_buffer; // avx in 3 channel mode needs one float at the start of the buffer\n      #endif\n\n      STBIR__NEXT_PTR( info->split_info[i].ring_buffers, alloc_ring_buffer_num_entries * sizeof(float*), float* );\n      {\n        int j;\n        for( j = 0 ; j < alloc_ring_buffer_num_entries ; j++ )\n        {\n          STBIR__NEXT_PTR( info->split_info[i].ring_buffers[j], ring_buffer_length_bytes, float );\n          #ifdef STBIR_SIMD8\n          if ( ( info ) && ( effective_channels == 3 ) )\n            ++info->split_info[i].ring_buffers[j]; // avx in 3 channel mode needs one float at the start of the buffer\n          #endif\n        }\n      }\n#else\n      STBIR__NEXT_PTR( info->split_info[i].ring_buffer, ring_buffer_size, float );\n#endif\n      STBIR__NEXT_PTR( info->split_info[i].vertical_buffer, vertical_buffer_size, float );\n    }\n\n    // alloc memory for to-be-pivoted coeffs (if necessary)\n    if ( vertical->is_gather == 0 )\n    {\n      int both;\n      int temp_mem_amt;\n\n      // when in vertical scatter mode, we first build the coefficients in gather mode, and then pivot after,\n      //   that means we need two buffers, so we try to use the decode buffer and ring buffer for this. if that\n      //   is too small, we just allocate extra memory to use as this temp.\n\n      both = vertical->gather_prescatter_contributors_size + vertical->gather_prescatter_coefficients_size;\n\n#ifdef STBIR__SEPARATE_ALLOCATIONS\n      temp_mem_amt = decode_buffer_size;\n\n      #ifdef STBIR_SIMD8\n      if ( effective_channels == 3 )\n        --temp_mem_amt; // avx in 3 channel mode needs one float at the start of the buffer\n      #endif\n#else\n      temp_mem_amt = ( decode_buffer_size + ring_buffer_size + vertical_buffer_size ) * splits;\n#endif\n      if ( temp_mem_amt >= both )\n      {\n        if ( info )\n        {\n          vertical->gather_prescatter_contributors = (stbir__contributors*)info->split_info[0].decode_buffer;\n          vertical->gather_prescatter_coefficients = (float*) ( ( (char*)info->split_info[0].decode_buffer ) + vertical->gather_prescatter_contributors_size );\n        }\n      }\n      else\n      {\n        // ring+decode memory is too small, so allocate temp memory\n        STBIR__NEXT_PTR( vertical->gather_prescatter_contributors, vertical->gather_prescatter_contributors_size, stbir__contributors );\n        STBIR__NEXT_PTR( vertical->gather_prescatter_coefficients, vertical->gather_prescatter_coefficients_size, float );\n      }\n    }\n\n    STBIR__NEXT_PTR( horizontal->contributors, horizontal->contributors_size, stbir__contributors );\n    STBIR__NEXT_PTR( horizontal->coefficients, horizontal->coefficients_size, float );\n\n    // are the two filters identical?? (happens a lot with mipmap generation)\n    if ( ( horizontal->filter_kernel == vertical->filter_kernel ) && ( horizontal->filter_support == vertical->filter_support ) && ( horizontal->edge == vertical->edge ) && ( horizontal->scale_info.output_sub_size == vertical->scale_info.output_sub_size ) )\n    {\n      float diff_scale = horizontal->scale_info.scale - vertical->scale_info.scale;\n      float diff_shift = horizontal->scale_info.pixel_shift - vertical->scale_info.pixel_shift;\n      if ( diff_scale < 0.0f ) diff_scale = -diff_scale;\n      if ( diff_shift < 0.0f ) diff_shift = -diff_shift;\n      if ( ( diff_scale <= stbir__small_float ) && ( diff_shift <= stbir__small_float ) )\n      {\n        if ( horizontal->is_gather == vertical->is_gather )\n        {\n          copy_horizontal = 1;\n          goto no_vert_alloc;\n        }\n        // everything matches, but vertical is scatter, horizontal is gather, use horizontal coeffs for vertical pivot coeffs\n        possibly_use_horizontal_for_pivot = horizontal;\n      }\n    }\n\n    STBIR__NEXT_PTR( vertical->contributors, vertical->contributors_size, stbir__contributors );\n    STBIR__NEXT_PTR( vertical->coefficients, vertical->coefficients_size, float );\n\n   no_vert_alloc:\n\n    if ( info )\n    {\n      STBIR_PROFILE_BUILD_START( horizontal );\n\n      stbir__calculate_filters( horizontal, 0, user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO );\n\n      // setup the horizontal gather functions\n      // start with defaulting to the n_coeffs functions (specialized on channels and remnant leftover)\n      info->horizontal_gather_channels = stbir__horizontal_gather_n_coeffs_funcs[ effective_channels ][ horizontal->extent_info.widest & 3 ];\n      // but if the number of coeffs <= 12, use another set of special cases. <=12 coeffs is any enlarging resize, or shrinking resize down to about 1/3 size\n      if ( horizontal->extent_info.widest <= 12 )\n        info->horizontal_gather_channels = stbir__horizontal_gather_channels_funcs[ effective_channels ][ horizontal->extent_info.widest - 1 ];\n\n      info->scanline_extents.conservative.n0 = conservative->n0;\n      info->scanline_extents.conservative.n1 = conservative->n1;\n\n      // get exact extents\n      stbir__get_extents( horizontal, &info->scanline_extents );\n\n      // pack the horizontal coeffs\n      horizontal->coefficient_width = stbir__pack_coefficients(horizontal->num_contributors, horizontal->contributors, horizontal->coefficients, horizontal->coefficient_width, horizontal->extent_info.widest, info->scanline_extents.conservative.n0, info->scanline_extents.conservative.n1 );\n\n      STBIR_MEMCPY( &info->horizontal, horizontal, sizeof( stbir__sampler ) );\n\n      STBIR_PROFILE_BUILD_END( horizontal );\n\n      if ( copy_horizontal )\n      {\n        STBIR_MEMCPY( &info->vertical, horizontal, sizeof( stbir__sampler ) );\n      }\n      else\n      {\n        STBIR_PROFILE_BUILD_START( vertical );\n\n        stbir__calculate_filters( vertical, possibly_use_horizontal_for_pivot, user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO );\n        STBIR_MEMCPY( &info->vertical, vertical, sizeof( stbir__sampler ) );\n\n        STBIR_PROFILE_BUILD_END( vertical );\n      }\n\n      // setup the vertical split ranges\n      stbir__get_split_info( info->split_info, info->splits, info->vertical.scale_info.output_sub_size, info->vertical.filter_pixel_margin, info->vertical.scale_info.input_full_size );\n\n      // now we know precisely how many entries we need\n      info->ring_buffer_num_entries = info->vertical.extent_info.widest;\n\n      // we never need more ring buffer entries than the scanlines we're outputting\n      if ( ( !info->vertical.is_gather ) && ( info->ring_buffer_num_entries > conservative_split_output_size ) )\n        info->ring_buffer_num_entries = conservative_split_output_size;\n      STBIR_ASSERT( info->ring_buffer_num_entries <= info->alloc_ring_buffer_num_entries );\n\n      // a few of the horizontal gather functions read past the end of the decode (but mask it out), \n      //   so put in normal values so no snans or denormals accidentally sneak in (also, in the ring \n      //   buffer for vertical first)\n      for( i = 0 ; i < splits ; i++ )\n      {\n        int t, ofs, start;\n\n        ofs = decode_buffer_size / 4;\n\n        #if defined( STBIR__SEPARATE_ALLOCATIONS ) && defined(STBIR_SIMD8)\n        if ( effective_channels == 3 ) \n          --ofs; // avx in 3 channel mode needs one float at the start of the buffer, so we snap back for clearing\n        #endif\n\n        start = ofs - 4;\n        if ( start < 0 ) start = 0;\n\n        for( t = start ; t < ofs; t++ )\n          info->split_info[i].decode_buffer[ t ] = 9999.0f;\n\n        if ( vertical_first )\n        {\n          int j;\n          for( j = 0; j < info->ring_buffer_num_entries ; j++ )\n          {\n            for( t = start ; t < ofs; t++ )\n              stbir__get_ring_buffer_entry( info, info->split_info + i, j )[ t ] = 9999.0f;\n          }\n        }\n      }\n    }\n\n    #undef STBIR__NEXT_PTR\n\n\n    // is this the first time through loop?\n    if ( info == 0 )\n    {\n      alloced_total = ( 15 + (size_t)advance_mem );\n      alloced = STBIR_MALLOC( alloced_total, user_data );\n      if ( alloced == 0 )\n        return 0;\n    }\n    else\n      return info;  // success\n  }\n}\n\nstatic int stbir__perform_resize( stbir__info const * info, int split_start, int split_count )\n{\n  stbir__per_split_info * split_info = info->split_info + split_start;\n\n  STBIR_PROFILE_CLEAR_EXTRAS();\n\n  STBIR_PROFILE_FIRST_START( looping );\n  if (info->vertical.is_gather)\n    stbir__vertical_gather_loop( info, split_info, split_count );\n  else\n    stbir__vertical_scatter_loop( info, split_info, split_count );\n  STBIR_PROFILE_END( looping );\n\n  return 1;\n}\n\nstatic void stbir__update_info_from_resize( stbir__info * info, STBIR_RESIZE * resize )\n{\n  static stbir__decode_pixels_func * decode_simple[STBIR_TYPE_HALF_FLOAT-STBIR_TYPE_UINT8_SRGB+1]=\n  {\n    /* 1ch-4ch */ stbir__decode_uint8_srgb, stbir__decode_uint8_srgb, 0, stbir__decode_float_linear, stbir__decode_half_float_linear,\n  };\n\n  static stbir__decode_pixels_func * decode_alphas[STBIRI_AR-STBIRI_RGBA+1][STBIR_TYPE_HALF_FLOAT-STBIR_TYPE_UINT8_SRGB+1]=\n  {\n    { /* RGBA */ stbir__decode_uint8_srgb4_linearalpha,      stbir__decode_uint8_srgb,      0, stbir__decode_float_linear,      stbir__decode_half_float_linear },\n    { /* BGRA */ stbir__decode_uint8_srgb4_linearalpha_BGRA, stbir__decode_uint8_srgb_BGRA, 0, stbir__decode_float_linear_BGRA, stbir__decode_half_float_linear_BGRA },\n    { /* ARGB */ stbir__decode_uint8_srgb4_linearalpha_ARGB, stbir__decode_uint8_srgb_ARGB, 0, stbir__decode_float_linear_ARGB, stbir__decode_half_float_linear_ARGB },\n    { /* ABGR */ stbir__decode_uint8_srgb4_linearalpha_ABGR, stbir__decode_uint8_srgb_ABGR, 0, stbir__decode_float_linear_ABGR, stbir__decode_half_float_linear_ABGR },\n    { /* RA   */ stbir__decode_uint8_srgb2_linearalpha,      stbir__decode_uint8_srgb,      0, stbir__decode_float_linear,      stbir__decode_half_float_linear },\n    { /* AR   */ stbir__decode_uint8_srgb2_linearalpha_AR,   stbir__decode_uint8_srgb_AR,   0, stbir__decode_float_linear_AR,   stbir__decode_half_float_linear_AR },\n  };\n\n  static stbir__decode_pixels_func * decode_simple_scaled_or_not[2][2]=\n  {\n    { stbir__decode_uint8_linear_scaled,  stbir__decode_uint8_linear }, { stbir__decode_uint16_linear_scaled, stbir__decode_uint16_linear },\n  };\n\n  static stbir__decode_pixels_func * decode_alphas_scaled_or_not[STBIRI_AR-STBIRI_RGBA+1][2][2]=\n  {\n    { /* RGBA */ { stbir__decode_uint8_linear_scaled,       stbir__decode_uint8_linear },      { stbir__decode_uint16_linear_scaled,      stbir__decode_uint16_linear } },\n    { /* BGRA */ { stbir__decode_uint8_linear_scaled_BGRA,  stbir__decode_uint8_linear_BGRA }, { stbir__decode_uint16_linear_scaled_BGRA, stbir__decode_uint16_linear_BGRA } },\n    { /* ARGB */ { stbir__decode_uint8_linear_scaled_ARGB,  stbir__decode_uint8_linear_ARGB }, { stbir__decode_uint16_linear_scaled_ARGB, stbir__decode_uint16_linear_ARGB } },\n    { /* ABGR */ { stbir__decode_uint8_linear_scaled_ABGR,  stbir__decode_uint8_linear_ABGR }, { stbir__decode_uint16_linear_scaled_ABGR, stbir__decode_uint16_linear_ABGR } },\n    { /* RA   */ { stbir__decode_uint8_linear_scaled,       stbir__decode_uint8_linear },      { stbir__decode_uint16_linear_scaled,      stbir__decode_uint16_linear } },\n    { /* AR   */ { stbir__decode_uint8_linear_scaled_AR,    stbir__decode_uint8_linear_AR },   { stbir__decode_uint16_linear_scaled_AR,   stbir__decode_uint16_linear_AR } }\n  };\n\n  static stbir__encode_pixels_func * encode_simple[STBIR_TYPE_HALF_FLOAT-STBIR_TYPE_UINT8_SRGB+1]=\n  {\n    /* 1ch-4ch */ stbir__encode_uint8_srgb, stbir__encode_uint8_srgb, 0, stbir__encode_float_linear, stbir__encode_half_float_linear,\n  };\n\n  static stbir__encode_pixels_func * encode_alphas[STBIRI_AR-STBIRI_RGBA+1][STBIR_TYPE_HALF_FLOAT-STBIR_TYPE_UINT8_SRGB+1]=\n  {\n    { /* RGBA */ stbir__encode_uint8_srgb4_linearalpha,      stbir__encode_uint8_srgb,      0, stbir__encode_float_linear,      stbir__encode_half_float_linear },\n    { /* BGRA */ stbir__encode_uint8_srgb4_linearalpha_BGRA, stbir__encode_uint8_srgb_BGRA, 0, stbir__encode_float_linear_BGRA, stbir__encode_half_float_linear_BGRA },\n    { /* ARGB */ stbir__encode_uint8_srgb4_linearalpha_ARGB, stbir__encode_uint8_srgb_ARGB, 0, stbir__encode_float_linear_ARGB, stbir__encode_half_float_linear_ARGB },\n    { /* ABGR */ stbir__encode_uint8_srgb4_linearalpha_ABGR, stbir__encode_uint8_srgb_ABGR, 0, stbir__encode_float_linear_ABGR, stbir__encode_half_float_linear_ABGR },\n    { /* RA   */ stbir__encode_uint8_srgb2_linearalpha,      stbir__encode_uint8_srgb,      0, stbir__encode_float_linear,      stbir__encode_half_float_linear },\n    { /* AR   */ stbir__encode_uint8_srgb2_linearalpha_AR,   stbir__encode_uint8_srgb_AR,   0, stbir__encode_float_linear_AR,   stbir__encode_half_float_linear_AR }\n  };\n\n  static stbir__encode_pixels_func * encode_simple_scaled_or_not[2][2]=\n  {\n    { stbir__encode_uint8_linear_scaled,  stbir__encode_uint8_linear }, { stbir__encode_uint16_linear_scaled, stbir__encode_uint16_linear },\n  };\n\n  static stbir__encode_pixels_func * encode_alphas_scaled_or_not[STBIRI_AR-STBIRI_RGBA+1][2][2]=\n  {\n    { /* RGBA */ { stbir__encode_uint8_linear_scaled,       stbir__encode_uint8_linear },       { stbir__encode_uint16_linear_scaled,      stbir__encode_uint16_linear } },\n    { /* BGRA */ { stbir__encode_uint8_linear_scaled_BGRA,  stbir__encode_uint8_linear_BGRA },  { stbir__encode_uint16_linear_scaled_BGRA, stbir__encode_uint16_linear_BGRA } },\n    { /* ARGB */ { stbir__encode_uint8_linear_scaled_ARGB,  stbir__encode_uint8_linear_ARGB },  { stbir__encode_uint16_linear_scaled_ARGB, stbir__encode_uint16_linear_ARGB } },\n    { /* ABGR */ { stbir__encode_uint8_linear_scaled_ABGR,  stbir__encode_uint8_linear_ABGR },  { stbir__encode_uint16_linear_scaled_ABGR, stbir__encode_uint16_linear_ABGR } },\n    { /* RA   */ { stbir__encode_uint8_linear_scaled,       stbir__encode_uint8_linear },       { stbir__encode_uint16_linear_scaled,      stbir__encode_uint16_linear } },\n    { /* AR   */ { stbir__encode_uint8_linear_scaled_AR,    stbir__encode_uint8_linear_AR },    { stbir__encode_uint16_linear_scaled_AR,   stbir__encode_uint16_linear_AR } }\n  };\n\n  stbir__decode_pixels_func * decode_pixels = 0;\n  stbir__encode_pixels_func * encode_pixels = 0;\n  stbir_datatype input_type, output_type;\n\n  input_type = resize->input_data_type;\n  output_type = resize->output_data_type;\n  info->input_data = resize->input_pixels;\n  info->input_stride_bytes = resize->input_stride_in_bytes;\n  info->output_stride_bytes = resize->output_stride_in_bytes;\n\n  // if we're completely point sampling, then we can turn off SRGB\n  if ( ( info->horizontal.filter_enum == STBIR_FILTER_POINT_SAMPLE ) && ( info->vertical.filter_enum == STBIR_FILTER_POINT_SAMPLE ) )\n  {\n    if ( ( ( input_type  == STBIR_TYPE_UINT8_SRGB ) || ( input_type  == STBIR_TYPE_UINT8_SRGB_ALPHA ) ) &&\n         ( ( output_type == STBIR_TYPE_UINT8_SRGB ) || ( output_type == STBIR_TYPE_UINT8_SRGB_ALPHA ) ) )\n    {\n      input_type = STBIR_TYPE_UINT8;\n      output_type = STBIR_TYPE_UINT8;\n    }\n  }\n\n  // recalc the output and input strides\n  if ( info->input_stride_bytes == 0 )\n    info->input_stride_bytes = info->channels * info->horizontal.scale_info.input_full_size * stbir__type_size[input_type];\n\n  if ( info->output_stride_bytes == 0 )\n    info->output_stride_bytes = info->channels * info->horizontal.scale_info.output_sub_size * stbir__type_size[output_type];\n\n  // calc offset\n  info->output_data = ( (char*) resize->output_pixels ) + ( (size_t) info->offset_y * (size_t) resize->output_stride_in_bytes ) + ( info->offset_x * info->channels * stbir__type_size[output_type] );\n\n  info->in_pixels_cb = resize->input_cb;\n  info->user_data = resize->user_data;\n  info->out_pixels_cb = resize->output_cb;\n\n  // setup the input format converters\n  if ( ( input_type == STBIR_TYPE_UINT8 ) || ( input_type == STBIR_TYPE_UINT16 ) )\n  {\n    int non_scaled = 0;\n\n    // check if we can run unscaled - 0-255.0/0-65535.0 instead of 0-1.0 (which is a tiny bit faster when doing linear 8->8 or 16->16)\n    if ( ( !info->alpha_weight ) && ( !info->alpha_unweight )  ) // don't short circuit when alpha weighting (get everything to 0-1.0 as usual)\n      if ( ( ( input_type == STBIR_TYPE_UINT8 ) && ( output_type == STBIR_TYPE_UINT8 ) ) || ( ( input_type == STBIR_TYPE_UINT16 ) && ( output_type == STBIR_TYPE_UINT16 ) ) )\n        non_scaled = 1;\n\n    if ( info->input_pixel_layout_internal <= STBIRI_4CHANNEL )\n      decode_pixels = decode_simple_scaled_or_not[ input_type == STBIR_TYPE_UINT16 ][ non_scaled ];\n    else\n      decode_pixels = decode_alphas_scaled_or_not[ ( info->input_pixel_layout_internal - STBIRI_RGBA ) % ( STBIRI_AR-STBIRI_RGBA+1 ) ][ input_type == STBIR_TYPE_UINT16 ][ non_scaled ];\n  }\n  else\n  {\n    if ( info->input_pixel_layout_internal <= STBIRI_4CHANNEL )\n      decode_pixels = decode_simple[ input_type - STBIR_TYPE_UINT8_SRGB ];\n    else\n      decode_pixels = decode_alphas[ ( info->input_pixel_layout_internal - STBIRI_RGBA ) % ( STBIRI_AR-STBIRI_RGBA+1 ) ][ input_type - STBIR_TYPE_UINT8_SRGB ];\n  }\n\n  // setup the output format converters\n  if ( ( output_type == STBIR_TYPE_UINT8 ) || ( output_type == STBIR_TYPE_UINT16 ) )\n  {\n    int non_scaled = 0;\n\n    // check if we can run unscaled - 0-255.0/0-65535.0 instead of 0-1.0 (which is a tiny bit faster when doing linear 8->8 or 16->16)\n    if ( ( !info->alpha_weight ) && ( !info->alpha_unweight ) ) // don't short circuit when alpha weighting (get everything to 0-1.0 as usual)\n      if ( ( ( input_type == STBIR_TYPE_UINT8 ) && ( output_type == STBIR_TYPE_UINT8 ) ) || ( ( input_type == STBIR_TYPE_UINT16 ) && ( output_type == STBIR_TYPE_UINT16 ) ) )\n        non_scaled = 1;\n\n    if ( info->output_pixel_layout_internal <= STBIRI_4CHANNEL )\n      encode_pixels = encode_simple_scaled_or_not[ output_type == STBIR_TYPE_UINT16 ][ non_scaled ];\n    else\n      encode_pixels = encode_alphas_scaled_or_not[ ( info->output_pixel_layout_internal - STBIRI_RGBA ) % ( STBIRI_AR-STBIRI_RGBA+1 ) ][ output_type == STBIR_TYPE_UINT16 ][ non_scaled ];\n  }\n  else\n  {\n    if ( info->output_pixel_layout_internal <= STBIRI_4CHANNEL )\n      encode_pixels = encode_simple[ output_type - STBIR_TYPE_UINT8_SRGB ];\n    else\n      encode_pixels = encode_alphas[ ( info->output_pixel_layout_internal - STBIRI_RGBA ) % ( STBIRI_AR-STBIRI_RGBA+1 ) ][ output_type - STBIR_TYPE_UINT8_SRGB ];\n  }\n\n  info->input_type = input_type;\n  info->output_type = output_type;\n  info->decode_pixels = decode_pixels;\n  info->encode_pixels = encode_pixels;\n}\n\nstatic void stbir__clip( int * outx, int * outsubw, int outw, double * u0, double * u1 )\n{\n  double per, adj;\n  int over;\n\n  // do left/top edge\n  if ( *outx < 0 )\n  {\n    per = ( (double)*outx ) / ( (double)*outsubw ); // is negative\n    adj = per * ( *u1 - *u0 );\n    *u0 -= adj; // increases u0\n    *outx = 0;\n  }\n\n  // do right/bot edge\n  over = outw - ( *outx + *outsubw );\n  if ( over < 0 )\n  {\n    per = ( (double)over ) / ( (double)*outsubw ); // is negative\n    adj = per * ( *u1 - *u0 );\n    *u1 += adj; // decrease u1\n    *outsubw = outw - *outx;\n  }\n}\n\n// converts a double to a rational that has less than one float bit of error (returns 0 if unable to do so)\nstatic int stbir__double_to_rational(double f, stbir_uint32 limit, stbir_uint32 *numer, stbir_uint32 *denom, int limit_denom ) // limit_denom (1) or limit numer (0)\n{\n  double err;\n  stbir_uint64 top, bot;\n  stbir_uint64 numer_last = 0;\n  stbir_uint64 denom_last = 1;\n  stbir_uint64 numer_estimate = 1;\n  stbir_uint64 denom_estimate = 0;\n\n  // scale to past float error range\n  top = (stbir_uint64)( f * (double)(1 << 25) );\n  bot = 1 << 25;\n\n  // keep refining, but usually stops in a few loops - usually 5 for bad cases\n  for(;;)\n  {\n    stbir_uint64 est, temp;\n\n    // hit limit, break out and do best full range estimate\n    if ( ( ( limit_denom ) ? denom_estimate : numer_estimate ) >= limit )\n      break;\n\n    // is the current error less than 1 bit of a float? if so, we're done\n    if ( denom_estimate )\n    {\n      err = ( (double)numer_estimate / (double)denom_estimate ) - f;\n      if ( err < 0.0 ) err = -err;\n      if ( err < ( 1.0 / (double)(1<<24) ) )\n      {\n        // yup, found it\n        *numer = (stbir_uint32) numer_estimate;\n        *denom = (stbir_uint32) denom_estimate;\n        return 1;\n      }\n    }\n\n    // no more refinement bits left? break out and do full range estimate\n    if ( bot == 0 )\n      break;\n\n    // gcd the estimate bits\n    est = top / bot;\n    temp = top % bot;\n    top = bot;\n    bot = temp;\n\n    // move remainders\n    temp = est * denom_estimate + denom_last;\n    denom_last = denom_estimate;\n    denom_estimate = temp;\n\n    // move remainders\n    temp = est * numer_estimate + numer_last;\n    numer_last = numer_estimate;\n    numer_estimate = temp;\n  }\n\n  // we didn't fine anything good enough for float, use a full range estimate\n  if ( limit_denom )\n  {\n    numer_estimate= (stbir_uint64)( f * (double)limit + 0.5 );\n    denom_estimate = limit;\n  }\n  else\n  {\n    numer_estimate = limit;\n    denom_estimate = (stbir_uint64)( ( (double)limit / f ) + 0.5 );\n  }\n\n  *numer = (stbir_uint32) numer_estimate;\n  *denom = (stbir_uint32) denom_estimate;\n\n  err = ( denom_estimate ) ? ( ( (double)(stbir_uint32)numer_estimate / (double)(stbir_uint32)denom_estimate ) - f ) : 1.0;\n  if ( err < 0.0 ) err = -err;\n  return ( err < ( 1.0 / (double)(1<<24) ) ) ? 1 : 0;\n}\n\nstatic int stbir__calculate_region_transform( stbir__scale_info * scale_info, int output_full_range, int * output_offset, int output_sub_range, int input_full_range, double input_s0, double input_s1 )\n{\n  double output_range, input_range, output_s, input_s, ratio, scale;\n\n  input_s = input_s1 - input_s0;\n\n  // null area\n  if ( ( output_full_range == 0 ) || ( input_full_range == 0 ) ||\n       ( output_sub_range == 0 ) || ( input_s <= stbir__small_float ) )\n    return 0;\n\n  // are either of the ranges completely out of bounds?\n  if ( ( *output_offset >= output_full_range ) || ( ( *output_offset + output_sub_range ) <= 0 ) || ( input_s0 >= (1.0f-stbir__small_float) ) || ( input_s1 <= stbir__small_float ) )\n    return 0;\n\n  output_range = (double)output_full_range;\n  input_range = (double)input_full_range;\n\n  output_s = ( (double)output_sub_range) / output_range;\n\n  // figure out the scaling to use\n  ratio = output_s / input_s;\n\n  // save scale before clipping\n  scale = ( output_range / input_range ) * ratio;\n  scale_info->scale = (float)scale;\n  scale_info->inv_scale = (float)( 1.0 / scale );\n\n  // clip output area to left/right output edges (and adjust input area)\n  stbir__clip( output_offset, &output_sub_range, output_full_range, &input_s0, &input_s1 );\n\n  // recalc input area\n  input_s = input_s1 - input_s0;\n\n  // after clipping do we have zero input area?\n  if ( input_s <= stbir__small_float )\n    return 0;\n\n  // calculate and store the starting source offsets in output pixel space\n  scale_info->pixel_shift = (float) ( input_s0 * ratio * output_range );\n\n  scale_info->scale_is_rational = stbir__double_to_rational( scale, ( scale <= 1.0 ) ? output_full_range : input_full_range, &scale_info->scale_numerator, &scale_info->scale_denominator, ( scale >= 1.0 ) );\n\n  scale_info->input_full_size = input_full_range;\n  scale_info->output_sub_size = output_sub_range;\n\n  return 1;\n}\n\n\nstatic void stbir__init_and_set_layout( STBIR_RESIZE * resize, stbir_pixel_layout pixel_layout, stbir_datatype data_type )\n{\n  resize->input_cb = 0;\n  resize->output_cb = 0;\n  resize->user_data = resize;\n  resize->samplers = 0;\n  resize->called_alloc = 0;\n  resize->horizontal_filter = STBIR_FILTER_DEFAULT;\n  resize->horizontal_filter_kernel = 0; resize->horizontal_filter_support = 0;\n  resize->vertical_filter = STBIR_FILTER_DEFAULT;\n  resize->vertical_filter_kernel = 0; resize->vertical_filter_support = 0;\n  resize->horizontal_edge = STBIR_EDGE_CLAMP;\n  resize->vertical_edge = STBIR_EDGE_CLAMP;\n  resize->input_s0 = 0; resize->input_t0 = 0; resize->input_s1 = 1; resize->input_t1 = 1;\n  resize->output_subx = 0; resize->output_suby = 0; resize->output_subw = resize->output_w; resize->output_subh = resize->output_h;\n  resize->input_data_type = data_type;\n  resize->output_data_type = data_type;\n  resize->input_pixel_layout_public = pixel_layout;\n  resize->output_pixel_layout_public = pixel_layout;\n  resize->needs_rebuild = 1;\n}\n\nSTBIRDEF void stbir_resize_init( STBIR_RESIZE * resize,\n                                 const void *input_pixels,  int input_w,  int input_h, int input_stride_in_bytes, // stride can be zero\n                                       void *output_pixels, int output_w, int output_h, int output_stride_in_bytes, // stride can be zero\n                                 stbir_pixel_layout pixel_layout, stbir_datatype data_type )\n{\n  resize->input_pixels = input_pixels;\n  resize->input_w = input_w;\n  resize->input_h = input_h;\n  resize->input_stride_in_bytes = input_stride_in_bytes;\n  resize->output_pixels = output_pixels;\n  resize->output_w = output_w;\n  resize->output_h = output_h;\n  resize->output_stride_in_bytes = output_stride_in_bytes;\n  resize->fast_alpha = 0;\n\n  stbir__init_and_set_layout( resize, pixel_layout, data_type );\n}\n\n// You can update parameters any time after resize_init\nSTBIRDEF void stbir_set_datatypes( STBIR_RESIZE * resize, stbir_datatype input_type, stbir_datatype output_type )  // by default, datatype from resize_init\n{\n  resize->input_data_type = input_type;\n  resize->output_data_type = output_type;\n  if ( ( resize->samplers ) && ( !resize->needs_rebuild ) )\n    stbir__update_info_from_resize( resize->samplers, resize );\n}\n\nSTBIRDEF void stbir_set_pixel_callbacks( STBIR_RESIZE * resize, stbir_input_callback * input_cb, stbir_output_callback * output_cb )   // no callbacks by default\n{\n  resize->input_cb = input_cb;\n  resize->output_cb = output_cb;\n\n  if ( ( resize->samplers ) && ( !resize->needs_rebuild ) )\n  {\n    resize->samplers->in_pixels_cb = input_cb;\n    resize->samplers->out_pixels_cb = output_cb;\n  }\n}\n\nSTBIRDEF void stbir_set_user_data( STBIR_RESIZE * resize, void * user_data )                                     // pass back STBIR_RESIZE* by default\n{\n  resize->user_data = user_data;\n  if ( ( resize->samplers ) && ( !resize->needs_rebuild ) )\n    resize->samplers->user_data = user_data;\n}\n\nSTBIRDEF void stbir_set_buffer_ptrs( STBIR_RESIZE * resize, const void * input_pixels, int input_stride_in_bytes, void * output_pixels, int output_stride_in_bytes )\n{\n  resize->input_pixels = input_pixels;\n  resize->input_stride_in_bytes = input_stride_in_bytes;\n  resize->output_pixels = output_pixels;\n  resize->output_stride_in_bytes = output_stride_in_bytes;\n  if ( ( resize->samplers ) && ( !resize->needs_rebuild ) )\n    stbir__update_info_from_resize( resize->samplers, resize );\n}\n\n\nSTBIRDEF int stbir_set_edgemodes( STBIR_RESIZE * resize, stbir_edge horizontal_edge, stbir_edge vertical_edge )       // CLAMP by default\n{\n  resize->horizontal_edge = horizontal_edge;\n  resize->vertical_edge = vertical_edge;\n  resize->needs_rebuild = 1;\n  return 1;\n}\n\nSTBIRDEF int stbir_set_filters( STBIR_RESIZE * resize, stbir_filter horizontal_filter, stbir_filter vertical_filter ) // STBIR_DEFAULT_FILTER_UPSAMPLE/DOWNSAMPLE by default\n{\n  resize->horizontal_filter = horizontal_filter;\n  resize->vertical_filter = vertical_filter;\n  resize->needs_rebuild = 1;\n  return 1;\n}\n\nSTBIRDEF int stbir_set_filter_callbacks( STBIR_RESIZE * resize, stbir__kernel_callback * horizontal_filter, stbir__support_callback * horizontal_support, stbir__kernel_callback * vertical_filter, stbir__support_callback * vertical_support )\n{\n  resize->horizontal_filter_kernel = horizontal_filter; resize->horizontal_filter_support = horizontal_support;\n  resize->vertical_filter_kernel = vertical_filter; resize->vertical_filter_support = vertical_support;\n  resize->needs_rebuild = 1;\n  return 1;\n}\n\nSTBIRDEF int stbir_set_pixel_layouts( STBIR_RESIZE * resize, stbir_pixel_layout input_pixel_layout, stbir_pixel_layout output_pixel_layout )   // sets new pixel layouts\n{\n  resize->input_pixel_layout_public = input_pixel_layout;\n  resize->output_pixel_layout_public = output_pixel_layout;\n  resize->needs_rebuild = 1;\n  return 1;\n}\n\n\nSTBIRDEF int stbir_set_non_pm_alpha_speed_over_quality( STBIR_RESIZE * resize, int non_pma_alpha_speed_over_quality )   // sets alpha speed\n{\n  resize->fast_alpha = non_pma_alpha_speed_over_quality;\n  resize->needs_rebuild = 1;\n  return 1;\n}\n\nSTBIRDEF int stbir_set_input_subrect( STBIR_RESIZE * resize, double s0, double t0, double s1, double t1 )                 // sets input region (full region by default)\n{\n  resize->input_s0 = s0;\n  resize->input_t0 = t0;\n  resize->input_s1 = s1;\n  resize->input_t1 = t1;\n  resize->needs_rebuild = 1;\n\n  // are we inbounds?\n  if ( ( s1 < stbir__small_float ) || ( (s1-s0) < stbir__small_float ) ||\n       ( t1 < stbir__small_float ) || ( (t1-t0) < stbir__small_float ) ||\n       ( s0 > (1.0f-stbir__small_float) ) ||\n       ( t0 > (1.0f-stbir__small_float) ) )\n    return 0;\n\n  return 1;\n}\n\nSTBIRDEF int stbir_set_output_pixel_subrect( STBIR_RESIZE * resize, int subx, int suby, int subw, int subh )          // sets input region (full region by default)\n{\n  resize->output_subx = subx;\n  resize->output_suby = suby;\n  resize->output_subw = subw;\n  resize->output_subh = subh;\n  resize->needs_rebuild = 1;\n\n  // are we inbounds?\n  if ( ( subx >= resize->output_w ) || ( ( subx + subw ) <= 0 ) || ( suby >= resize->output_h ) || ( ( suby + subh ) <= 0 ) || ( subw == 0 ) || ( subh == 0 ) )\n    return 0;\n\n  return 1;\n}\n\nSTBIRDEF int stbir_set_pixel_subrect( STBIR_RESIZE * resize, int subx, int suby, int subw, int subh )                 // sets both regions (full regions by default)\n{\n  double s0, t0, s1, t1;\n\n  s0 = ( (double)subx ) / ( (double)resize->output_w );\n  t0 = ( (double)suby ) / ( (double)resize->output_h );\n  s1 = ( (double)(subx+subw) ) / ( (double)resize->output_w );\n  t1 = ( (double)(suby+subh) ) / ( (double)resize->output_h );\n\n  resize->input_s0 = s0;\n  resize->input_t0 = t0;\n  resize->input_s1 = s1;\n  resize->input_t1 = t1;\n  resize->output_subx = subx;\n  resize->output_suby = suby;\n  resize->output_subw = subw;\n  resize->output_subh = subh;\n  resize->needs_rebuild = 1;\n\n  // are we inbounds?\n  if ( ( subx >= resize->output_w ) || ( ( subx + subw ) <= 0 ) || ( suby >= resize->output_h ) || ( ( suby + subh ) <= 0 ) || ( subw == 0 ) || ( subh == 0 ) )\n    return 0;\n\n  return 1;\n}\n\nstatic int stbir__perform_build( STBIR_RESIZE * resize, int splits )\n{\n  stbir__contributors conservative = { 0, 0 };\n  stbir__sampler horizontal, vertical;\n  int new_output_subx, new_output_suby;\n  stbir__info * out_info;\n  #ifdef STBIR_PROFILE\n  stbir__info profile_infod;  // used to contain building profile info before everything is allocated\n  stbir__info * profile_info = &profile_infod;\n  #endif\n\n  // have we already built the samplers?\n  if ( resize->samplers )\n    return 0;\n\n  #define STBIR_RETURN_ERROR_AND_ASSERT( exp )  STBIR_ASSERT( !(exp) ); if (exp) return 0;\n  STBIR_RETURN_ERROR_AND_ASSERT( (unsigned)resize->horizontal_filter >= STBIR_FILTER_OTHER)\n  STBIR_RETURN_ERROR_AND_ASSERT( (unsigned)resize->vertical_filter >= STBIR_FILTER_OTHER)\n  #undef STBIR_RETURN_ERROR_AND_ASSERT\n\n  if ( splits <= 0 )\n    return 0;\n\n  STBIR_PROFILE_BUILD_FIRST_START( build );\n\n  new_output_subx = resize->output_subx;\n  new_output_suby = resize->output_suby;\n\n  // do horizontal clip and scale calcs\n  if ( !stbir__calculate_region_transform( &horizontal.scale_info, resize->output_w, &new_output_subx, resize->output_subw, resize->input_w, resize->input_s0, resize->input_s1 ) )\n    return 0;\n\n  // do vertical clip and scale calcs\n  if ( !stbir__calculate_region_transform( &vertical.scale_info, resize->output_h, &new_output_suby, resize->output_subh, resize->input_h, resize->input_t0, resize->input_t1 ) )\n    return 0;\n\n  // if nothing to do, just return\n  if ( ( horizontal.scale_info.output_sub_size == 0 ) || ( vertical.scale_info.output_sub_size == 0 ) )\n    return 0;\n\n  stbir__set_sampler(&horizontal, resize->horizontal_filter, resize->horizontal_filter_kernel, resize->horizontal_filter_support, resize->horizontal_edge, &horizontal.scale_info, 1, resize->user_data );\n  stbir__get_conservative_extents( &horizontal, &conservative, resize->user_data );\n  stbir__set_sampler(&vertical, resize->vertical_filter, resize->horizontal_filter_kernel, resize->vertical_filter_support, resize->vertical_edge, &vertical.scale_info, 0, resize->user_data );\n\n  if ( ( vertical.scale_info.output_sub_size / splits ) < STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS ) // each split should be a minimum of 4 scanlines (handwavey choice)\n  {\n    splits = vertical.scale_info.output_sub_size / STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS;\n    if ( splits == 0 ) splits = 1;\n  }\n\n  STBIR_PROFILE_BUILD_START( alloc );\n  out_info = stbir__alloc_internal_mem_and_build_samplers( &horizontal, &vertical, &conservative, resize->input_pixel_layout_public, resize->output_pixel_layout_public, splits, new_output_subx, new_output_suby, resize->fast_alpha, resize->user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO );\n  STBIR_PROFILE_BUILD_END( alloc );\n  STBIR_PROFILE_BUILD_END( build );\n\n  if ( out_info )\n  {\n    resize->splits = splits;\n    resize->samplers = out_info;\n    resize->needs_rebuild = 0;\n    #ifdef STBIR_PROFILE\n      STBIR_MEMCPY( &out_info->profile, &profile_infod.profile, sizeof( out_info->profile ) );\n    #endif\n\n    // update anything that can be changed without recalcing samplers\n    stbir__update_info_from_resize( out_info, resize );\n\n    return splits;\n  }\n\n  return 0;\n}\n\nvoid stbir_free_samplers( STBIR_RESIZE * resize )\n{\n  if ( resize->samplers )\n  {\n    stbir__free_internal_mem( resize->samplers );\n    resize->samplers = 0;\n    resize->called_alloc = 0;\n  }\n}\n\nSTBIRDEF int stbir_build_samplers_with_splits( STBIR_RESIZE * resize, int splits )\n{\n  if ( ( resize->samplers == 0 ) || ( resize->needs_rebuild ) )\n  {\n    if ( resize->samplers )\n      stbir_free_samplers( resize );\n\n    resize->called_alloc = 1;\n    return stbir__perform_build( resize, splits );\n  }\n\n  STBIR_PROFILE_BUILD_CLEAR( resize->samplers );\n\n  return 1;\n}\n\nSTBIRDEF int stbir_build_samplers( STBIR_RESIZE * resize )\n{\n  return stbir_build_samplers_with_splits( resize, 1 );\n}\n\nSTBIRDEF int stbir_resize_extended( STBIR_RESIZE * resize )\n{\n  int result;\n\n  if ( ( resize->samplers == 0 ) || ( resize->needs_rebuild ) )\n  {\n    int alloc_state = resize->called_alloc;  // remember allocated state\n\n    if ( resize->samplers )\n    {\n      stbir__free_internal_mem( resize->samplers );\n      resize->samplers = 0;\n    }\n\n    if ( !stbir_build_samplers( resize ) )\n      return 0;\n\n    resize->called_alloc = alloc_state;\n\n    // if build_samplers succeeded (above), but there are no samplers set, then\n    //   the area to stretch into was zero pixels, so don't do anything and return\n    //   success\n    if ( resize->samplers == 0 )\n      return 1;\n  }\n  else\n  {\n    // didn't build anything - clear it\n    STBIR_PROFILE_BUILD_CLEAR( resize->samplers );\n  }\n\n  // do resize\n  result = stbir__perform_resize( resize->samplers, 0, resize->splits );\n\n  // if we alloced, then free\n  if ( !resize->called_alloc )\n  {\n    stbir_free_samplers( resize );\n    resize->samplers = 0;\n  }\n\n  return result;\n}\n\nSTBIRDEF int stbir_resize_extended_split( STBIR_RESIZE * resize, int split_start, int split_count )\n{\n  STBIR_ASSERT( resize->samplers );\n\n  // if we're just doing the whole thing, call full\n  if ( ( split_start == -1 ) || ( ( split_start == 0 ) && ( split_count == resize->splits ) ) )\n    return stbir_resize_extended( resize );\n\n  // you **must** build samplers first when using split resize\n  if ( ( resize->samplers == 0 ) || ( resize->needs_rebuild ) )\n    return 0;\n\n  if ( ( split_start >= resize->splits ) || ( split_start < 0 ) || ( ( split_start + split_count ) > resize->splits ) || ( split_count <= 0 ) )\n    return 0;\n\n  // do resize\n  return stbir__perform_resize( resize->samplers, split_start, split_count );\n}\n\nstatic int stbir__check_output_stuff( void ** ret_ptr, int * ret_pitch, void * output_pixels, int type_size, int output_w, int output_h, int output_stride_in_bytes, stbir_internal_pixel_layout pixel_layout )\n{\n  size_t size;\n  int pitch;\n  void * ptr;\n\n  pitch = output_w * type_size * stbir__pixel_channels[ pixel_layout ];\n  if ( pitch == 0 )\n    return 0;\n\n  if ( output_stride_in_bytes == 0 )\n    output_stride_in_bytes = pitch;\n\n  if ( output_stride_in_bytes < pitch )\n    return 0;\n\n  size = (size_t)output_stride_in_bytes * (size_t)output_h;\n  if ( size == 0 )\n    return 0;\n\n  *ret_ptr = 0;\n  *ret_pitch = output_stride_in_bytes;\n\n  if ( output_pixels == 0 )\n  {\n    ptr = STBIR_MALLOC( size, 0 );\n    if ( ptr == 0 )\n      return 0;\n\n    *ret_ptr = ptr;\n    *ret_pitch = pitch;\n  }\n\n  return 1;\n}\n\n\nSTBIRDEF unsigned char * stbir_resize_uint8_linear( const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                          unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                          stbir_pixel_layout pixel_layout )\n{\n  STBIR_RESIZE resize;\n  unsigned char * optr;\n  int opitch;\n\n  if ( !stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, sizeof( unsigned char ), output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ) )\n    return 0;\n\n  stbir_resize_init( &resize,\n                     input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                     (optr) ? optr : output_pixels, output_w, output_h, opitch,\n                     pixel_layout, STBIR_TYPE_UINT8 );\n\n  if ( !stbir_resize_extended( &resize ) )\n  {\n    if ( optr )\n      STBIR_FREE( optr, 0 );\n    return 0;\n  }\n\n  return (optr) ? optr : output_pixels;\n}\n\nSTBIRDEF unsigned char * stbir_resize_uint8_srgb( const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                        unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                        stbir_pixel_layout pixel_layout )\n{\n  STBIR_RESIZE resize;\n  unsigned char * optr;\n  int opitch;\n\n  if ( !stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, sizeof( unsigned char ), output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ) )\n    return 0;\n\n  stbir_resize_init( &resize,\n                     input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                     (optr) ? optr : output_pixels, output_w, output_h, opitch,\n                     pixel_layout, STBIR_TYPE_UINT8_SRGB );\n\n  if ( !stbir_resize_extended( &resize ) )\n  {\n    if ( optr )\n      STBIR_FREE( optr, 0 );\n    return 0;\n  }\n\n  return (optr) ? optr : output_pixels;\n}\n\n\nSTBIRDEF float * stbir_resize_float_linear( const float *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                                  float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                                  stbir_pixel_layout pixel_layout )\n{\n  STBIR_RESIZE resize;\n  float * optr;\n  int opitch;\n\n  if ( !stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, sizeof( float ), output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ) )\n    return 0;\n\n  stbir_resize_init( &resize,\n                     input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                     (optr) ? optr : output_pixels, output_w, output_h, opitch,\n                     pixel_layout, STBIR_TYPE_FLOAT );\n\n  if ( !stbir_resize_extended( &resize ) )\n  {\n    if ( optr )\n      STBIR_FREE( optr, 0 );\n    return 0;\n  }\n\n  return (optr) ? optr : output_pixels;\n}\n\n\nSTBIRDEF void * stbir_resize( const void *input_pixels , int input_w , int input_h, int input_stride_in_bytes,\n                                    void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                              stbir_pixel_layout pixel_layout, stbir_datatype data_type,\n                              stbir_edge edge, stbir_filter filter )\n{\n  STBIR_RESIZE resize;\n  float * optr;\n  int opitch;\n\n  if ( !stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, stbir__type_size[data_type], output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ) )\n    return 0;\n\n  stbir_resize_init( &resize,\n                     input_pixels,  input_w,  input_h,  input_stride_in_bytes,\n                     (optr) ? optr : output_pixels, output_w, output_h, output_stride_in_bytes,\n                     pixel_layout, data_type );\n\n  resize.horizontal_edge = edge;\n  resize.vertical_edge = edge;\n  resize.horizontal_filter = filter;\n  resize.vertical_filter = filter;\n\n  if ( !stbir_resize_extended( &resize ) )\n  {\n    if ( optr )\n      STBIR_FREE( optr, 0 );\n    return 0;\n  }\n\n  return (optr) ? optr : output_pixels;\n}\n\n#ifdef STBIR_PROFILE\n\nSTBIRDEF void stbir_resize_build_profile_info( STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize )\n{\n  static char const * bdescriptions[6] = { \"Building\", \"Allocating\", \"Horizontal sampler\", \"Vertical sampler\", \"Coefficient cleanup\", \"Coefficient piovot\" } ;\n  stbir__info* samp = resize->samplers;\n  int i;\n\n  typedef int testa[ (STBIR__ARRAY_SIZE( bdescriptions ) == (STBIR__ARRAY_SIZE( samp->profile.array )-1) )?1:-1];\n  typedef int testb[ (sizeof( samp->profile.array ) == (sizeof(samp->profile.named)) )?1:-1];\n  typedef int testc[ (sizeof( info->clocks ) >= (sizeof(samp->profile.named)) )?1:-1];\n\n  for( i = 0 ; i < STBIR__ARRAY_SIZE( bdescriptions ) ; i++)\n    info->clocks[i] = samp->profile.array[i+1];\n\n  info->total_clocks = samp->profile.named.total;\n  info->descriptions = bdescriptions;\n  info->count = STBIR__ARRAY_SIZE( bdescriptions );\n}\n\nSTBIRDEF void stbir_resize_split_profile_info( STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize, int split_start, int split_count )\n{\n  static char const * descriptions[7] = { \"Looping\", \"Vertical sampling\", \"Horizontal sampling\", \"Scanline input\", \"Scanline output\", \"Alpha weighting\", \"Alpha unweighting\" };\n  stbir__per_split_info * split_info;\n  int s, i;\n\n  typedef int testa[ (STBIR__ARRAY_SIZE( descriptions ) == (STBIR__ARRAY_SIZE( split_info->profile.array )-1) )?1:-1];\n  typedef int testb[ (sizeof( split_info->profile.array ) == (sizeof(split_info->profile.named)) )?1:-1];\n  typedef int testc[ (sizeof( info->clocks ) >= (sizeof(split_info->profile.named)) )?1:-1];\n\n  if ( split_start == -1 )\n  {\n    split_start = 0;\n    split_count = resize->samplers->splits;\n  }\n\n  if ( ( split_start >= resize->splits ) || ( split_start < 0 ) || ( ( split_start + split_count ) > resize->splits ) || ( split_count <= 0 ) )\n  {\n    info->total_clocks = 0;\n    info->descriptions = 0;\n    info->count = 0;\n    return;\n  }\n\n  split_info = resize->samplers->split_info + split_start;\n\n  // sum up the profile from all the splits\n  for( i = 0 ; i < STBIR__ARRAY_SIZE( descriptions ) ; i++ )\n  {\n    stbir_uint64 sum = 0;\n    for( s = 0 ; s < split_count ; s++ )\n      sum += split_info[s].profile.array[i+1];\n    info->clocks[i] = sum;\n  }\n\n  info->total_clocks = split_info->profile.named.total;\n  info->descriptions = descriptions;\n  info->count = STBIR__ARRAY_SIZE( descriptions );\n}\n\nSTBIRDEF void stbir_resize_extended_profile_info( STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize )\n{\n  stbir_resize_split_profile_info( info, resize, -1, 0 );\n}\n\n#endif // STBIR_PROFILE\n\n#undef STBIR_BGR\n#undef STBIR_1CHANNEL\n#undef STBIR_2CHANNEL\n#undef STBIR_RGB\n#undef STBIR_RGBA\n#undef STBIR_4CHANNEL\n#undef STBIR_BGRA\n#undef STBIR_ARGB\n#undef STBIR_ABGR\n#undef STBIR_RA\n#undef STBIR_AR\n#undef STBIR_RGBA_PM\n#undef STBIR_BGRA_PM\n#undef STBIR_ARGB_PM\n#undef STBIR_ABGR_PM\n#undef STBIR_RA_PM\n#undef STBIR_AR_PM\n\n#endif // STB_IMAGE_RESIZE_IMPLEMENTATION\n\n#else  // STB_IMAGE_RESIZE_HORIZONTALS&STB_IMAGE_RESIZE_DO_VERTICALS\n\n// we reinclude the header file to define all the horizontal functions\n//   specializing each function for the number of coeffs is 20-40% faster *OVERALL*\n\n// by including the header file again this way, we can still debug the functions\n\n#define STBIR_strs_join2( start, mid, end ) start##mid##end\n#define STBIR_strs_join1( start, mid, end ) STBIR_strs_join2( start, mid, end )\n\n#define STBIR_strs_join24( start, mid1, mid2, end ) start##mid1##mid2##end\n#define STBIR_strs_join14( start, mid1, mid2, end ) STBIR_strs_join24( start, mid1, mid2, end )\n\n#ifdef STB_IMAGE_RESIZE_DO_CODERS\n\n#ifdef stbir__decode_suffix\n#define STBIR__CODER_NAME( name ) STBIR_strs_join1( name, _, stbir__decode_suffix )\n#else\n#define STBIR__CODER_NAME( name ) name\n#endif\n\n#ifdef stbir__decode_swizzle\n#define stbir__decode_simdf8_flip(reg) STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( stbir__simdf8_0123to,stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3),stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3)(reg, reg)\n#define stbir__decode_simdf4_flip(reg) STBIR_strs_join1( STBIR_strs_join1( stbir__simdf_0123to,stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3)(reg, reg)\n#define stbir__encode_simdf8_unflip(reg) STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( stbir__simdf8_0123to,stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3),stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3)(reg, reg)\n#define stbir__encode_simdf4_unflip(reg) STBIR_strs_join1( STBIR_strs_join1( stbir__simdf_0123to,stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3)(reg, reg)\n#else\n#define stbir__decode_order0 0\n#define stbir__decode_order1 1\n#define stbir__decode_order2 2\n#define stbir__decode_order3 3\n#define stbir__encode_order0 0\n#define stbir__encode_order1 1\n#define stbir__encode_order2 2\n#define stbir__encode_order3 3\n#define stbir__decode_simdf8_flip(reg)\n#define stbir__decode_simdf4_flip(reg)\n#define stbir__encode_simdf8_unflip(reg)\n#define stbir__encode_simdf4_unflip(reg)\n#endif\n\n#ifdef STBIR_SIMD8\n#define stbir__encode_simdfX_unflip  stbir__encode_simdf8_unflip\n#else\n#define stbir__encode_simdfX_unflip  stbir__encode_simdf4_unflip\n#endif\n\nstatic void STBIR__CODER_NAME( stbir__decode_uint8_linear_scaled )( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  unsigned char const * input = (unsigned char const*)inputp;\n\n  #ifdef STBIR_SIMD\n  unsigned char const * end_input_m16 = input + width_times_channels - 16;\n  if ( width_times_channels >= 16 )\n  {\n    decode_end -= 16;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      #ifdef STBIR_SIMD8\n      stbir__simdi i; stbir__simdi8 o0,o1;\n      stbir__simdf8 of0, of1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi8_expand_u8_to_u32( o0, o1, i );\n      stbir__simdi8_convert_i32_to_float( of0, o0 );\n      stbir__simdi8_convert_i32_to_float( of1, o1 );\n      stbir__simdf8_mult( of0, of0, STBIR_max_uint8_as_float_inverted8);\n      stbir__simdf8_mult( of1, of1, STBIR_max_uint8_as_float_inverted8);\n      stbir__decode_simdf8_flip( of0 );\n      stbir__decode_simdf8_flip( of1 );\n      stbir__simdf8_store( decode + 0, of0 );\n      stbir__simdf8_store( decode + 8, of1 );\n      #else\n      stbir__simdi i, o0, o1, o2, o3;\n      stbir__simdf of0, of1, of2, of3;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi_expand_u8_to_u32( o0,o1,o2,o3,i);\n      stbir__simdi_convert_i32_to_float( of0, o0 );\n      stbir__simdi_convert_i32_to_float( of1, o1 );\n      stbir__simdi_convert_i32_to_float( of2, o2 );\n      stbir__simdi_convert_i32_to_float( of3, o3 );\n      stbir__simdf_mult( of0, of0, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted) );\n      stbir__simdf_mult( of1, of1, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted) );\n      stbir__simdf_mult( of2, of2, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted) );\n      stbir__simdf_mult( of3, of3, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted) );\n      stbir__decode_simdf4_flip( of0 );\n      stbir__decode_simdf4_flip( of1 );\n      stbir__decode_simdf4_flip( of2 );\n      stbir__decode_simdf4_flip( of3 );\n      stbir__simdf_store( decode + 0,  of0 );\n      stbir__simdf_store( decode + 4,  of1 );\n      stbir__simdf_store( decode + 8,  of2 );\n      stbir__simdf_store( decode + 12, of3 );\n      #endif\n      decode += 16;\n      input += 16;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 16 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m16;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = ((float)(input[stbir__decode_order0])) * stbir__max_uint8_as_float_inverted;\n    decode[1-4] = ((float)(input[stbir__decode_order1])) * stbir__max_uint8_as_float_inverted;\n    decode[2-4] = ((float)(input[stbir__decode_order2])) * stbir__max_uint8_as_float_inverted;\n    decode[3-4] = ((float)(input[stbir__decode_order3])) * stbir__max_uint8_as_float_inverted;\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = ((float)(input[stbir__decode_order0])) * stbir__max_uint8_as_float_inverted;\n    #if stbir__coder_min_num >= 2\n    decode[1] = ((float)(input[stbir__decode_order1])) * stbir__max_uint8_as_float_inverted;\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = ((float)(input[stbir__decode_order2])) * stbir__max_uint8_as_float_inverted;\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_uint8_linear_scaled )( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned char STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned char *) outputp;\n  unsigned char * end_output = ( (unsigned char *) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  if ( width_times_channels >= stbir__simdfX_float_count*2 )\n  {\n    float const * end_encode_m8 = encode + width_times_channels - stbir__simdfX_float_count*2;\n    end_output -= stbir__simdfX_float_count*2;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdfX e0, e1;\n      stbir__simdi i;\n      STBIR_SIMD_NO_UNROLL(encode);\n      stbir__simdfX_madd_mem( e0, STBIR_simd_point5X, STBIR_max_uint8_as_floatX, encode );\n      stbir__simdfX_madd_mem( e1, STBIR_simd_point5X, STBIR_max_uint8_as_floatX, encode+stbir__simdfX_float_count );\n      stbir__encode_simdfX_unflip( e0 );\n      stbir__encode_simdfX_unflip( e1 );\n      #ifdef STBIR_SIMD8\n      stbir__simdf8_pack_to_16bytes( i, e0, e1 );\n      stbir__simdi_store( output, i );\n      #else\n      stbir__simdf_pack_to_8bytes( i, e0, e1 );\n      stbir__simdi_store2( output, i );\n      #endif\n      encode += stbir__simdfX_float_count*2;\n      output += stbir__simdfX_float_count*2;\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + stbir__simdfX_float_count*2 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m8;\n    }\n    return;\n  }\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    stbir__simdf e0;\n    stbir__simdi i0;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_load( e0, encode );\n    stbir__simdf_madd( e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), e0 );\n    stbir__encode_simdf4_unflip( e0 );\n    stbir__simdf_pack_to_8bytes( i0, e0, e0 );  // only use first 4\n    *(int*)(output-4) = stbir__simdi_to_int( i0 );\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    stbir__simdf e0;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_madd1_mem( e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order0 ); output[0] = stbir__simdf_convert_float_to_uint8( e0 );\n    #if stbir__coder_min_num >= 2\n    stbir__simdf_madd1_mem( e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order1 ); output[1] = stbir__simdf_convert_float_to_uint8( e0 );\n    #endif\n    #if stbir__coder_min_num >= 3\n    stbir__simdf_madd1_mem( e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order2 ); output[2] = stbir__simdf_convert_float_to_uint8( e0 );\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n\n  #else\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  while( output <= end_output )\n  {\n    float f;\n    f = encode[stbir__encode_order0] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[0-4] = (unsigned char)f;\n    f = encode[stbir__encode_order1] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[1-4] = (unsigned char)f;\n    f = encode[stbir__encode_order2] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[2-4] = (unsigned char)f;\n    f = encode[stbir__encode_order3] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[3-4] = (unsigned char)f;\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    float f;\n    STBIR_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[0] = (unsigned char)f;\n    #if stbir__coder_min_num >= 2\n    f = encode[stbir__encode_order1] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[1] = (unsigned char)f;\n    #endif\n    #if stbir__coder_min_num >= 3\n    f = encode[stbir__encode_order2] * stbir__max_uint8_as_float + 0.5f; STBIR_CLAMP(f, 0, 255); output[2] = (unsigned char)f;\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint8_linear)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  unsigned char const * input = (unsigned char const*)inputp;\n\n  #ifdef STBIR_SIMD\n  unsigned char const * end_input_m16 = input + width_times_channels - 16;\n  if ( width_times_channels >= 16 )\n  {\n    decode_end -= 16;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      #ifdef STBIR_SIMD8\n      stbir__simdi i; stbir__simdi8 o0,o1;\n      stbir__simdf8 of0, of1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi8_expand_u8_to_u32( o0, o1, i );\n      stbir__simdi8_convert_i32_to_float( of0, o0 );\n      stbir__simdi8_convert_i32_to_float( of1, o1 );\n      stbir__decode_simdf8_flip( of0 );\n      stbir__decode_simdf8_flip( of1 );\n      stbir__simdf8_store( decode + 0, of0 );\n      stbir__simdf8_store( decode + 8, of1 );\n      #else\n      stbir__simdi i, o0, o1, o2, o3;\n      stbir__simdf of0, of1, of2, of3;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi_expand_u8_to_u32( o0,o1,o2,o3,i);\n      stbir__simdi_convert_i32_to_float( of0, o0 );\n      stbir__simdi_convert_i32_to_float( of1, o1 );\n      stbir__simdi_convert_i32_to_float( of2, o2 );\n      stbir__simdi_convert_i32_to_float( of3, o3 );\n      stbir__decode_simdf4_flip( of0 );\n      stbir__decode_simdf4_flip( of1 );\n      stbir__decode_simdf4_flip( of2 );\n      stbir__decode_simdf4_flip( of3 );\n      stbir__simdf_store( decode + 0,  of0 );\n      stbir__simdf_store( decode + 4,  of1 );\n      stbir__simdf_store( decode + 8,  of2 );\n      stbir__simdf_store( decode + 12, of3 );\n#endif\n      decode += 16;\n      input += 16;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 16 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m16;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = ((float)(input[stbir__decode_order0]));\n    decode[1-4] = ((float)(input[stbir__decode_order1]));\n    decode[2-4] = ((float)(input[stbir__decode_order2]));\n    decode[3-4] = ((float)(input[stbir__decode_order3]));\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = ((float)(input[stbir__decode_order0]));\n    #if stbir__coder_min_num >= 2\n    decode[1] = ((float)(input[stbir__decode_order1]));\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = ((float)(input[stbir__decode_order2]));\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_uint8_linear )( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned char STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned char *) outputp;\n  unsigned char * end_output = ( (unsigned char *) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  if ( width_times_channels >= stbir__simdfX_float_count*2 )\n  {\n    float const * end_encode_m8 = encode + width_times_channels - stbir__simdfX_float_count*2;\n    end_output -= stbir__simdfX_float_count*2;\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdfX e0, e1;\n      stbir__simdi i;\n      STBIR_SIMD_NO_UNROLL(encode);\n      stbir__simdfX_add_mem( e0, STBIR_simd_point5X, encode );\n      stbir__simdfX_add_mem( e1, STBIR_simd_point5X, encode+stbir__simdfX_float_count );\n      stbir__encode_simdfX_unflip( e0 );\n      stbir__encode_simdfX_unflip( e1 );\n      #ifdef STBIR_SIMD8\n      stbir__simdf8_pack_to_16bytes( i, e0, e1 );\n      stbir__simdi_store( output, i );\n      #else\n      stbir__simdf_pack_to_8bytes( i, e0, e1 );\n      stbir__simdi_store2( output, i );\n      #endif\n      encode += stbir__simdfX_float_count*2;\n      output += stbir__simdfX_float_count*2;\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + stbir__simdfX_float_count*2 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m8;\n    }\n    return;\n  }\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    stbir__simdf e0;\n    stbir__simdi i0;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_load( e0, encode );\n    stbir__simdf_add( e0, STBIR__CONSTF(STBIR_simd_point5), e0 );\n    stbir__encode_simdf4_unflip( e0 );\n    stbir__simdf_pack_to_8bytes( i0, e0, e0 );  // only use first 4\n    *(int*)(output-4) = stbir__simdi_to_int( i0 );\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  #else\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  while( output <= end_output )\n  {\n    float f;\n    f = encode[stbir__encode_order0] + 0.5f; STBIR_CLAMP(f, 0, 255); output[0-4] = (unsigned char)f;\n    f = encode[stbir__encode_order1] + 0.5f; STBIR_CLAMP(f, 0, 255); output[1-4] = (unsigned char)f;\n    f = encode[stbir__encode_order2] + 0.5f; STBIR_CLAMP(f, 0, 255); output[2-4] = (unsigned char)f;\n    f = encode[stbir__encode_order3] + 0.5f; STBIR_CLAMP(f, 0, 255); output[3-4] = (unsigned char)f;\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    float f;\n    STBIR_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] + 0.5f; STBIR_CLAMP(f, 0, 255); output[0] = (unsigned char)f;\n    #if stbir__coder_min_num >= 2\n    f = encode[stbir__encode_order1] + 0.5f; STBIR_CLAMP(f, 0, 255); output[1] = (unsigned char)f;\n    #endif\n    #if stbir__coder_min_num >= 3\n    f = encode[stbir__encode_order2] + 0.5f; STBIR_CLAMP(f, 0, 255); output[2] = (unsigned char)f;\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint8_srgb)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float const * decode_end = (float*) decode + width_times_channels;\n  unsigned char const * input = (unsigned char const *)inputp;\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  while( decode <= decode_end )\n  {\n    decode[0-4] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order0 ] ];\n    decode[1-4] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order1 ] ];\n    decode[2-4] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order2 ] ];\n    decode[3-4] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order3 ] ];\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order0 ] ];\n    #if stbir__coder_min_num >= 2\n    decode[1] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order1 ] ];\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = stbir__srgb_uchar_to_linear_float[ input[ stbir__decode_order2 ] ];\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\n#define stbir__min_max_shift20( i, f ) \\\n    stbir__simdf_max( f, f, stbir_simdf_casti(STBIR__CONSTI( STBIR_almost_zero )) ); \\\n    stbir__simdf_min( f, f, stbir_simdf_casti(STBIR__CONSTI( STBIR_almost_one  )) ); \\\n    stbir__simdi_32shr( i, stbir_simdi_castf( f ), 20 );\n\n#define stbir__scale_and_convert( i, f ) \\\n    stbir__simdf_madd( f, STBIR__CONSTF( STBIR_simd_point5 ), STBIR__CONSTF( STBIR_max_uint8_as_float ), f ); \\\n    stbir__simdf_max( f, f, stbir__simdf_zeroP() ); \\\n    stbir__simdf_min( f, f, STBIR__CONSTF( STBIR_max_uint8_as_float ) ); \\\n    stbir__simdf_convert_float_to_i32( i, f );\n\n#define stbir__linear_to_srgb_finish( i, f ) \\\n{ \\\n    stbir__simdi temp;  \\\n    stbir__simdi_32shr( temp, stbir_simdi_castf( f ), 12 ) ; \\\n    stbir__simdi_and( temp, temp, STBIR__CONSTI(STBIR_mastissa_mask) ); \\\n    stbir__simdi_or( temp, temp, STBIR__CONSTI(STBIR_topscale) ); \\\n    stbir__simdi_16madd( i, i, temp ); \\\n    stbir__simdi_32shr( i, i, 16 ); \\\n}\n\n#define stbir__simdi_table_lookup2( v0,v1, table ) \\\n{ \\\n  stbir__simdi_u32 temp0,temp1; \\\n  temp0.m128i_i128 = v0; \\\n  temp1.m128i_i128 = v1; \\\n  temp0.m128i_u32[0] = table[temp0.m128i_i32[0]]; temp0.m128i_u32[1] = table[temp0.m128i_i32[1]]; temp0.m128i_u32[2] = table[temp0.m128i_i32[2]]; temp0.m128i_u32[3] = table[temp0.m128i_i32[3]]; \\\n  temp1.m128i_u32[0] = table[temp1.m128i_i32[0]]; temp1.m128i_u32[1] = table[temp1.m128i_i32[1]]; temp1.m128i_u32[2] = table[temp1.m128i_i32[2]]; temp1.m128i_u32[3] = table[temp1.m128i_i32[3]]; \\\n  v0 = temp0.m128i_i128; \\\n  v1 = temp1.m128i_i128; \\\n}\n\n#define stbir__simdi_table_lookup3( v0,v1,v2, table ) \\\n{ \\\n  stbir__simdi_u32 temp0,temp1,temp2; \\\n  temp0.m128i_i128 = v0; \\\n  temp1.m128i_i128 = v1; \\\n  temp2.m128i_i128 = v2; \\\n  temp0.m128i_u32[0] = table[temp0.m128i_i32[0]]; temp0.m128i_u32[1] = table[temp0.m128i_i32[1]]; temp0.m128i_u32[2] = table[temp0.m128i_i32[2]]; temp0.m128i_u32[3] = table[temp0.m128i_i32[3]]; \\\n  temp1.m128i_u32[0] = table[temp1.m128i_i32[0]]; temp1.m128i_u32[1] = table[temp1.m128i_i32[1]]; temp1.m128i_u32[2] = table[temp1.m128i_i32[2]]; temp1.m128i_u32[3] = table[temp1.m128i_i32[3]]; \\\n  temp2.m128i_u32[0] = table[temp2.m128i_i32[0]]; temp2.m128i_u32[1] = table[temp2.m128i_i32[1]]; temp2.m128i_u32[2] = table[temp2.m128i_i32[2]]; temp2.m128i_u32[3] = table[temp2.m128i_i32[3]]; \\\n  v0 = temp0.m128i_i128; \\\n  v1 = temp1.m128i_i128; \\\n  v2 = temp2.m128i_i128; \\\n}\n\n#define stbir__simdi_table_lookup4( v0,v1,v2,v3, table ) \\\n{ \\\n  stbir__simdi_u32 temp0,temp1,temp2,temp3; \\\n  temp0.m128i_i128 = v0; \\\n  temp1.m128i_i128 = v1; \\\n  temp2.m128i_i128 = v2; \\\n  temp3.m128i_i128 = v3; \\\n  temp0.m128i_u32[0] = table[temp0.m128i_i32[0]]; temp0.m128i_u32[1] = table[temp0.m128i_i32[1]]; temp0.m128i_u32[2] = table[temp0.m128i_i32[2]]; temp0.m128i_u32[3] = table[temp0.m128i_i32[3]]; \\\n  temp1.m128i_u32[0] = table[temp1.m128i_i32[0]]; temp1.m128i_u32[1] = table[temp1.m128i_i32[1]]; temp1.m128i_u32[2] = table[temp1.m128i_i32[2]]; temp1.m128i_u32[3] = table[temp1.m128i_i32[3]]; \\\n  temp2.m128i_u32[0] = table[temp2.m128i_i32[0]]; temp2.m128i_u32[1] = table[temp2.m128i_i32[1]]; temp2.m128i_u32[2] = table[temp2.m128i_i32[2]]; temp2.m128i_u32[3] = table[temp2.m128i_i32[3]]; \\\n  temp3.m128i_u32[0] = table[temp3.m128i_i32[0]]; temp3.m128i_u32[1] = table[temp3.m128i_i32[1]]; temp3.m128i_u32[2] = table[temp3.m128i_i32[2]]; temp3.m128i_u32[3] = table[temp3.m128i_i32[3]]; \\\n  v0 = temp0.m128i_i128; \\\n  v1 = temp1.m128i_i128; \\\n  v2 = temp2.m128i_i128; \\\n  v3 = temp3.m128i_i128; \\\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_uint8_srgb )( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned char STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned char*) outputp;\n  unsigned char * end_output = ( (unsigned char*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n\n  if ( width_times_channels >= 16 )\n  {\n    float const * end_encode_m16 = encode + width_times_channels - 16;\n    end_output -= 16;\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdf f0, f1, f2, f3;\n      stbir__simdi i0, i1, i2, i3;\n      STBIR_SIMD_NO_UNROLL(encode);\n\n      stbir__simdf_load4_transposed( f0, f1, f2, f3, encode );\n\n      stbir__min_max_shift20( i0, f0 );\n      stbir__min_max_shift20( i1, f1 );\n      stbir__min_max_shift20( i2, f2 );\n      stbir__min_max_shift20( i3, f3 );\n\n      stbir__simdi_table_lookup4( i0, i1, i2, i3, ( fp32_to_srgb8_tab4 - (127-13)*8 ) );\n\n      stbir__linear_to_srgb_finish( i0, f0 );\n      stbir__linear_to_srgb_finish( i1, f1 );\n      stbir__linear_to_srgb_finish( i2, f2 );\n      stbir__linear_to_srgb_finish( i3, f3 );\n\n      stbir__interleave_pack_and_store_16_u8( output,  STBIR_strs_join1(i, ,stbir__encode_order0), STBIR_strs_join1(i, ,stbir__encode_order1), STBIR_strs_join1(i, ,stbir__encode_order2), STBIR_strs_join1(i, ,stbir__encode_order3) );\n\n      encode += 16;\n      output += 16;\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + 16 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m16;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while ( output <= end_output )\n  {\n    STBIR_SIMD_NO_UNROLL(encode);\n\n    output[0-4] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order0] );\n    output[1-4] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order1] );\n    output[2-4] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order2] );\n    output[3-4] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order3] );\n\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    STBIR_NO_UNROLL(encode);\n    output[0] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order0] );\n    #if stbir__coder_min_num >= 2\n    output[1] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order1] );\n    #endif\n    #if stbir__coder_min_num >= 3\n    output[2] = stbir__linear_to_srgb_uchar( encode[stbir__encode_order2] );\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n}\n\n#if ( stbir__coder_min_num == 4 ) || ( ( stbir__coder_min_num == 1 ) && ( !defined(stbir__decode_swizzle) ) )\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint8_srgb4_linearalpha)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float const * decode_end = (float*) decode + width_times_channels;\n  unsigned char const * input = (unsigned char const *)inputp;\n  do {\n    decode[0] = stbir__srgb_uchar_to_linear_float[ input[stbir__decode_order0] ];\n    decode[1] = stbir__srgb_uchar_to_linear_float[ input[stbir__decode_order1] ];\n    decode[2] = stbir__srgb_uchar_to_linear_float[ input[stbir__decode_order2] ];\n    decode[3] = ( (float) input[stbir__decode_order3] ) * stbir__max_uint8_as_float_inverted;\n    input += 4;\n    decode += 4;\n  } while( decode < decode_end );\n}\n\n\nstatic void STBIR__CODER_NAME( stbir__encode_uint8_srgb4_linearalpha )( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned char STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned char*) outputp;\n  unsigned char * end_output = ( (unsigned char*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n\n  if ( width_times_channels >= 16 )\n  {\n    float const * end_encode_m16 = encode + width_times_channels - 16;\n    end_output -= 16;\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdf f0, f1, f2, f3;\n      stbir__simdi i0, i1, i2, i3;\n\n      STBIR_SIMD_NO_UNROLL(encode);\n      stbir__simdf_load4_transposed( f0, f1, f2, f3, encode );\n\n      stbir__min_max_shift20( i0, f0 );\n      stbir__min_max_shift20( i1, f1 );\n      stbir__min_max_shift20( i2, f2 );\n      stbir__scale_and_convert( i3, f3 );\n\n      stbir__simdi_table_lookup3( i0, i1, i2, ( fp32_to_srgb8_tab4 - (127-13)*8 ) );\n\n      stbir__linear_to_srgb_finish( i0, f0 );\n      stbir__linear_to_srgb_finish( i1, f1 );\n      stbir__linear_to_srgb_finish( i2, f2 );\n\n      stbir__interleave_pack_and_store_16_u8( output,  STBIR_strs_join1(i, ,stbir__encode_order0), STBIR_strs_join1(i, ,stbir__encode_order1), STBIR_strs_join1(i, ,stbir__encode_order2), STBIR_strs_join1(i, ,stbir__encode_order3) );\n\n      output += 16;\n      encode += 16;\n\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + 16 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m16;\n    }\n    return;\n  }\n  #endif\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float f;\n    STBIR_SIMD_NO_UNROLL(encode);\n\n    output[stbir__decode_order0] = stbir__linear_to_srgb_uchar( encode[0] );\n    output[stbir__decode_order1] = stbir__linear_to_srgb_uchar( encode[1] );\n    output[stbir__decode_order2] = stbir__linear_to_srgb_uchar( encode[2] );\n\n    f = encode[3] * stbir__max_uint8_as_float + 0.5f;\n    STBIR_CLAMP(f, 0, 255);\n    output[stbir__decode_order3] = (unsigned char) f;\n\n    output += 4;\n    encode += 4;\n  } while( output < end_output );\n}\n\n#endif\n\n#if ( stbir__coder_min_num == 2 ) || ( ( stbir__coder_min_num == 1 ) && ( !defined(stbir__decode_swizzle) ) )\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint8_srgb2_linearalpha)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float const * decode_end = (float*) decode + width_times_channels;\n  unsigned char const * input = (unsigned char const *)inputp;\n  decode += 4;\n  while( decode <= decode_end )\n  {\n    decode[0-4] = stbir__srgb_uchar_to_linear_float[ input[stbir__decode_order0] ];\n    decode[1-4] = ( (float) input[stbir__decode_order1] ) * stbir__max_uint8_as_float_inverted;\n    decode[2-4] = stbir__srgb_uchar_to_linear_float[ input[stbir__decode_order0+2] ];\n    decode[3-4] = ( (float) input[stbir__decode_order1+2] ) * stbir__max_uint8_as_float_inverted;\n    input += 4;\n    decode += 4;\n  }\n  decode -= 4;\n  if( decode < decode_end )\n  {\n    decode[0] = stbir__srgb_uchar_to_linear_float[ stbir__decode_order0 ];\n    decode[1] = ( (float) input[stbir__decode_order1] ) * stbir__max_uint8_as_float_inverted;\n  }\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_uint8_srgb2_linearalpha )( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned char STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned char*) outputp;\n  unsigned char * end_output = ( (unsigned char*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n\n  if ( width_times_channels >= 16 )\n  {\n    float const * end_encode_m16 = encode + width_times_channels - 16;\n    end_output -= 16;\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdf f0, f1, f2, f3;\n      stbir__simdi i0, i1, i2, i3;\n\n      STBIR_SIMD_NO_UNROLL(encode);\n      stbir__simdf_load4_transposed( f0, f1, f2, f3, encode );\n\n      stbir__min_max_shift20( i0, f0 );\n      stbir__scale_and_convert( i1, f1 );\n      stbir__min_max_shift20( i2, f2 );\n      stbir__scale_and_convert( i3, f3 );\n\n      stbir__simdi_table_lookup2( i0, i2, ( fp32_to_srgb8_tab4 - (127-13)*8 ) );\n\n      stbir__linear_to_srgb_finish( i0, f0 );\n      stbir__linear_to_srgb_finish( i2, f2 );\n\n      stbir__interleave_pack_and_store_16_u8( output,  STBIR_strs_join1(i, ,stbir__encode_order0), STBIR_strs_join1(i, ,stbir__encode_order1), STBIR_strs_join1(i, ,stbir__encode_order2), STBIR_strs_join1(i, ,stbir__encode_order3) );\n\n      output += 16;\n      encode += 16;\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + 16 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m16;\n    }\n    return;\n  }\n  #endif\n\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float f;\n    STBIR_SIMD_NO_UNROLL(encode);\n\n    output[stbir__decode_order0] = stbir__linear_to_srgb_uchar( encode[0] );\n\n    f = encode[1] * stbir__max_uint8_as_float + 0.5f;\n    STBIR_CLAMP(f, 0, 255);\n    output[stbir__decode_order1] = (unsigned char) f;\n\n    output += 2;\n    encode += 2;\n  } while( output < end_output );\n}\n\n#endif\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint16_linear_scaled)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  unsigned short const * input = (unsigned short const *)inputp;\n\n  #ifdef STBIR_SIMD\n  unsigned short const * end_input_m8 = input + width_times_channels - 8;\n  if ( width_times_channels >= 8 )\n  {\n    decode_end -= 8;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      #ifdef STBIR_SIMD8\n      stbir__simdi i; stbir__simdi8 o;\n      stbir__simdf8 of;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi8_expand_u16_to_u32( o, i );\n      stbir__simdi8_convert_i32_to_float( of, o );\n      stbir__simdf8_mult( of, of, STBIR_max_uint16_as_float_inverted8);\n      stbir__decode_simdf8_flip( of );\n      stbir__simdf8_store( decode + 0, of );\n      #else\n      stbir__simdi i, o0, o1;\n      stbir__simdf of0, of1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi_expand_u16_to_u32( o0,o1,i );\n      stbir__simdi_convert_i32_to_float( of0, o0 );\n      stbir__simdi_convert_i32_to_float( of1, o1 );\n      stbir__simdf_mult( of0, of0, STBIR__CONSTF(STBIR_max_uint16_as_float_inverted) );\n      stbir__simdf_mult( of1, of1, STBIR__CONSTF(STBIR_max_uint16_as_float_inverted));\n      stbir__decode_simdf4_flip( of0 );\n      stbir__decode_simdf4_flip( of1 );\n      stbir__simdf_store( decode + 0,  of0 );\n      stbir__simdf_store( decode + 4,  of1 );\n      #endif\n      decode += 8;\n      input += 8;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 8 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m8;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = ((float)(input[stbir__decode_order0])) * stbir__max_uint16_as_float_inverted;\n    decode[1-4] = ((float)(input[stbir__decode_order1])) * stbir__max_uint16_as_float_inverted;\n    decode[2-4] = ((float)(input[stbir__decode_order2])) * stbir__max_uint16_as_float_inverted;\n    decode[3-4] = ((float)(input[stbir__decode_order3])) * stbir__max_uint16_as_float_inverted;\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = ((float)(input[stbir__decode_order0])) * stbir__max_uint16_as_float_inverted;\n    #if stbir__coder_min_num >= 2\n    decode[1] = ((float)(input[stbir__decode_order1])) * stbir__max_uint16_as_float_inverted;\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = ((float)(input[stbir__decode_order2])) * stbir__max_uint16_as_float_inverted;\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\n\nstatic void STBIR__CODER_NAME(stbir__encode_uint16_linear_scaled)( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned short STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned short*) outputp;\n  unsigned short * end_output = ( (unsigned short*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  {\n    if ( width_times_channels >= stbir__simdfX_float_count*2 )\n    {\n      float const * end_encode_m8 = encode + width_times_channels - stbir__simdfX_float_count*2;\n      end_output -= stbir__simdfX_float_count*2;\n      STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n      for(;;)\n      {\n        stbir__simdfX e0, e1;\n        stbir__simdiX i;\n        STBIR_SIMD_NO_UNROLL(encode);\n        stbir__simdfX_madd_mem( e0, STBIR_simd_point5X, STBIR_max_uint16_as_floatX, encode );\n        stbir__simdfX_madd_mem( e1, STBIR_simd_point5X, STBIR_max_uint16_as_floatX, encode+stbir__simdfX_float_count );\n        stbir__encode_simdfX_unflip( e0 );\n        stbir__encode_simdfX_unflip( e1 );\n        stbir__simdfX_pack_to_words( i, e0, e1 );\n        stbir__simdiX_store( output, i );\n        encode += stbir__simdfX_float_count*2;\n        output += stbir__simdfX_float_count*2;\n        if ( output <= end_output )\n          continue;\n        if ( output == ( end_output + stbir__simdfX_float_count*2 ) )\n          break;\n        output = end_output;     // backup and do last couple\n        encode = end_encode_m8;\n      }\n      return;\n    }\n  }\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    stbir__simdf e;\n    stbir__simdi i;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_load( e, encode );\n    stbir__simdf_madd( e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), e );\n    stbir__encode_simdf4_unflip( e );\n    stbir__simdf_pack_to_8words( i, e, e );  // only use first 4\n    stbir__simdi_store2( output-4, i );\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    stbir__simdf e;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_madd1_mem( e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order0 ); output[0] = stbir__simdf_convert_float_to_short( e );\n    #if stbir__coder_min_num >= 2\n    stbir__simdf_madd1_mem( e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order1 ); output[1] = stbir__simdf_convert_float_to_short( e );\n    #endif\n    #if stbir__coder_min_num >= 3\n    stbir__simdf_madd1_mem( e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order2 ); output[2] = stbir__simdf_convert_float_to_short( e );\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n\n  #else\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    float f;\n    STBIR_SIMD_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[0-4] = (unsigned short)f;\n    f = encode[stbir__encode_order1] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[1-4] = (unsigned short)f;\n    f = encode[stbir__encode_order2] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[2-4] = (unsigned short)f;\n    f = encode[stbir__encode_order3] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[3-4] = (unsigned short)f;\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    float f;\n    STBIR_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[0] = (unsigned short)f;\n    #if stbir__coder_min_num >= 2\n    f = encode[stbir__encode_order1] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[1] = (unsigned short)f;\n    #endif\n    #if stbir__coder_min_num >= 3\n    f = encode[stbir__encode_order2] * stbir__max_uint16_as_float + 0.5f; STBIR_CLAMP(f, 0, 65535); output[2] = (unsigned short)f;\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__decode_uint16_linear)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  unsigned short const * input = (unsigned short const *)inputp;\n\n  #ifdef STBIR_SIMD\n  unsigned short const * end_input_m8 = input + width_times_channels - 8;\n  if ( width_times_channels >= 8 )\n  {\n    decode_end -= 8;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      #ifdef STBIR_SIMD8\n      stbir__simdi i; stbir__simdi8 o;\n      stbir__simdf8 of;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi8_expand_u16_to_u32( o, i );\n      stbir__simdi8_convert_i32_to_float( of, o );\n      stbir__decode_simdf8_flip( of );\n      stbir__simdf8_store( decode + 0, of );\n      #else\n      stbir__simdi i, o0, o1;\n      stbir__simdf of0, of1;\n      STBIR_NO_UNROLL(decode);\n      stbir__simdi_load( i, input );\n      stbir__simdi_expand_u16_to_u32( o0, o1, i );\n      stbir__simdi_convert_i32_to_float( of0, o0 );\n      stbir__simdi_convert_i32_to_float( of1, o1 );\n      stbir__decode_simdf4_flip( of0 );\n      stbir__decode_simdf4_flip( of1 );\n      stbir__simdf_store( decode + 0,  of0 );\n      stbir__simdf_store( decode + 4,  of1 );\n      #endif\n      decode += 8;\n      input += 8;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 8 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m8;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = ((float)(input[stbir__decode_order0]));\n    decode[1-4] = ((float)(input[stbir__decode_order1]));\n    decode[2-4] = ((float)(input[stbir__decode_order2]));\n    decode[3-4] = ((float)(input[stbir__decode_order3]));\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = ((float)(input[stbir__decode_order0]));\n    #if stbir__coder_min_num >= 2\n    decode[1] = ((float)(input[stbir__decode_order1]));\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = ((float)(input[stbir__decode_order2]));\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__encode_uint16_linear)( void * outputp, int width_times_channels, float const * encode )\n{\n  unsigned short STBIR_SIMD_STREAMOUT_PTR( * ) output = (unsigned short*) outputp;\n  unsigned short * end_output = ( (unsigned short*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  {\n    if ( width_times_channels >= stbir__simdfX_float_count*2 )\n    {\n      float const * end_encode_m8 = encode + width_times_channels - stbir__simdfX_float_count*2;\n      end_output -= stbir__simdfX_float_count*2;\n      STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n      for(;;)\n      {\n        stbir__simdfX e0, e1;\n        stbir__simdiX i;\n        STBIR_SIMD_NO_UNROLL(encode);\n        stbir__simdfX_add_mem( e0, STBIR_simd_point5X, encode );\n        stbir__simdfX_add_mem( e1, STBIR_simd_point5X, encode+stbir__simdfX_float_count );\n        stbir__encode_simdfX_unflip( e0 );\n        stbir__encode_simdfX_unflip( e1 );\n        stbir__simdfX_pack_to_words( i, e0, e1 );\n        stbir__simdiX_store( output, i );\n        encode += stbir__simdfX_float_count*2;\n        output += stbir__simdfX_float_count*2;\n        if ( output <= end_output )\n          continue;\n        if ( output == ( end_output + stbir__simdfX_float_count*2 ) )\n          break;\n        output = end_output; // backup and do last couple\n        encode = end_encode_m8;\n      }\n      return;\n    }\n  }\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    stbir__simdf e;\n    stbir__simdi i;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_load( e, encode );\n    stbir__simdf_add( e, STBIR__CONSTF(STBIR_simd_point5), e );\n    stbir__encode_simdf4_unflip( e );\n    stbir__simdf_pack_to_8words( i, e, e );  // only use first 4\n    stbir__simdi_store2( output-4, i );\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  #else\n\n  // try to do blocks of 4 when you can\n  #if  stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    float f;\n    STBIR_SIMD_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[0-4] = (unsigned short)f;\n    f = encode[stbir__encode_order1] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[1-4] = (unsigned short)f;\n    f = encode[stbir__encode_order2] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[2-4] = (unsigned short)f;\n    f = encode[stbir__encode_order3] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[3-4] = (unsigned short)f;\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    float f;\n    STBIR_NO_UNROLL(encode);\n    f = encode[stbir__encode_order0] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[0] = (unsigned short)f;\n    #if stbir__coder_min_num >= 2\n    f = encode[stbir__encode_order1] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[1] = (unsigned short)f;\n    #endif\n    #if stbir__coder_min_num >= 3\n    f = encode[stbir__encode_order2] + 0.5f; STBIR_CLAMP(f, 0, 65535); output[2] = (unsigned short)f;\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__decode_half_float_linear)( float * decodep, int width_times_channels, void const * inputp )\n{\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  stbir__FP16 const * input = (stbir__FP16 const *)inputp;\n\n  #ifdef STBIR_SIMD\n  if ( width_times_channels >= 8 )\n  {\n    stbir__FP16 const * end_input_m8 = input + width_times_channels - 8;\n    decode_end -= 8;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      STBIR_NO_UNROLL(decode);\n\n      stbir__half_to_float_SIMD( decode, input );\n      #ifdef stbir__decode_swizzle\n      #ifdef STBIR_SIMD8\n      {\n        stbir__simdf8 of;\n        stbir__simdf8_load( of, decode );\n        stbir__decode_simdf8_flip( of );\n        stbir__simdf8_store( decode, of );\n      }\n      #else\n      {\n        stbir__simdf of0,of1;\n        stbir__simdf_load( of0, decode );\n        stbir__simdf_load( of1, decode+4 );\n        stbir__decode_simdf4_flip( of0 );\n        stbir__decode_simdf4_flip( of1 );\n        stbir__simdf_store( decode, of0 );\n        stbir__simdf_store( decode+4, of1 );\n      }\n      #endif\n      #endif\n      decode += 8;\n      input += 8;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 8 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m8;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = stbir__half_to_float(input[stbir__decode_order0]);\n    decode[1-4] = stbir__half_to_float(input[stbir__decode_order1]);\n    decode[2-4] = stbir__half_to_float(input[stbir__decode_order2]);\n    decode[3-4] = stbir__half_to_float(input[stbir__decode_order3]);\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = stbir__half_to_float(input[stbir__decode_order0]);\n    #if stbir__coder_min_num >= 2\n    decode[1] = stbir__half_to_float(input[stbir__decode_order1]);\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = stbir__half_to_float(input[stbir__decode_order2]);\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_half_float_linear )( void * outputp, int width_times_channels, float const * encode )\n{\n  stbir__FP16 STBIR_SIMD_STREAMOUT_PTR( * ) output = (stbir__FP16*) outputp;\n  stbir__FP16 * end_output = ( (stbir__FP16*) output ) + width_times_channels;\n\n  #ifdef STBIR_SIMD\n  if ( width_times_channels >= 8 )\n  {\n    float const * end_encode_m8 = encode + width_times_channels - 8;\n    end_output -= 8;\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      STBIR_SIMD_NO_UNROLL(encode);\n      #ifdef stbir__decode_swizzle\n      #ifdef STBIR_SIMD8\n      {\n        stbir__simdf8 of;\n        stbir__simdf8_load( of, encode );\n        stbir__encode_simdf8_unflip( of );\n        stbir__float_to_half_SIMD( output, (float*)&of );\n      }\n      #else\n      {\n        stbir__simdf of[2];\n        stbir__simdf_load( of[0], encode );\n        stbir__simdf_load( of[1], encode+4 );\n        stbir__encode_simdf4_unflip( of[0] );\n        stbir__encode_simdf4_unflip( of[1] );\n        stbir__float_to_half_SIMD( output, (float*)of );\n      }\n      #endif\n      #else\n      stbir__float_to_half_SIMD( output, encode );\n      #endif\n      encode += 8;\n      output += 8;\n      if ( output <= end_output )\n        continue;\n      if ( output == ( end_output + 8 ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m8;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    STBIR_SIMD_NO_UNROLL(output);\n    output[0-4] = stbir__float_to_half(encode[stbir__encode_order0]);\n    output[1-4] = stbir__float_to_half(encode[stbir__encode_order1]);\n    output[2-4] = stbir__float_to_half(encode[stbir__encode_order2]);\n    output[3-4] = stbir__float_to_half(encode[stbir__encode_order3]);\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    STBIR_NO_UNROLL(output);\n    output[0] = stbir__float_to_half(encode[stbir__encode_order0]);\n    #if stbir__coder_min_num >= 2\n    output[1] = stbir__float_to_half(encode[stbir__encode_order1]);\n    #endif\n    #if stbir__coder_min_num >= 3\n    output[2] = stbir__float_to_half(encode[stbir__encode_order2]);\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n}\n\nstatic void STBIR__CODER_NAME(stbir__decode_float_linear)( float * decodep, int width_times_channels, void const * inputp )\n{\n  #ifdef stbir__decode_swizzle\n  float STBIR_STREAMOUT_PTR( * ) decode = decodep;\n  float * decode_end = (float*) decode + width_times_channels;\n  float const * input = (float const *)inputp;\n\n  #ifdef STBIR_SIMD\n  if ( width_times_channels >= 16 )\n  {\n    float const * end_input_m16 = input + width_times_channels - 16;\n    decode_end -= 16;\n    STBIR_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      STBIR_NO_UNROLL(decode);\n      #ifdef stbir__decode_swizzle\n      #ifdef STBIR_SIMD8\n      {\n        stbir__simdf8 of0,of1;\n        stbir__simdf8_load( of0, input );\n        stbir__simdf8_load( of1, input+8 );\n        stbir__decode_simdf8_flip( of0 );\n        stbir__decode_simdf8_flip( of1 );\n        stbir__simdf8_store( decode, of0 );\n        stbir__simdf8_store( decode+8, of1 );\n      }\n      #else\n      {\n        stbir__simdf of0,of1,of2,of3;\n        stbir__simdf_load( of0, input );\n        stbir__simdf_load( of1, input+4 );\n        stbir__simdf_load( of2, input+8 );\n        stbir__simdf_load( of3, input+12 );\n        stbir__decode_simdf4_flip( of0 );\n        stbir__decode_simdf4_flip( of1 );\n        stbir__decode_simdf4_flip( of2 );\n        stbir__decode_simdf4_flip( of3 );\n        stbir__simdf_store( decode, of0 );\n        stbir__simdf_store( decode+4, of1 );\n        stbir__simdf_store( decode+8, of2 );\n        stbir__simdf_store( decode+12, of3 );\n      }\n      #endif\n      #endif\n      decode += 16;\n      input += 16;\n      if ( decode <= decode_end )\n        continue;\n      if ( decode == ( decode_end + 16 ) )\n        break;\n      decode = decode_end; // backup and do last couple\n      input = end_input_m16;\n    }\n    return;\n  }\n  #endif\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  decode += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( decode <= decode_end )\n  {\n    STBIR_SIMD_NO_UNROLL(decode);\n    decode[0-4] = input[stbir__decode_order0];\n    decode[1-4] = input[stbir__decode_order1];\n    decode[2-4] = input[stbir__decode_order2];\n    decode[3-4] = input[stbir__decode_order3];\n    decode += 4;\n    input += 4;\n  }\n  decode -= 4;\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( decode < decode_end )\n  {\n    STBIR_NO_UNROLL(decode);\n    decode[0] = input[stbir__decode_order0];\n    #if stbir__coder_min_num >= 2\n    decode[1] = input[stbir__decode_order1];\n    #endif\n    #if stbir__coder_min_num >= 3\n    decode[2] = input[stbir__decode_order2];\n    #endif\n    decode += stbir__coder_min_num;\n    input += stbir__coder_min_num;\n  }\n  #endif\n\n  #else\n\n  if ( (void*)decodep != inputp )\n    STBIR_MEMCPY( decodep, inputp, width_times_channels * sizeof( float ) );\n\n  #endif\n}\n\nstatic void STBIR__CODER_NAME( stbir__encode_float_linear )( void * outputp, int width_times_channels, float const * encode )\n{\n  #if !defined( STBIR_FLOAT_HIGH_CLAMP ) && !defined(STBIR_FLOAT_LO_CLAMP) && !defined(stbir__decode_swizzle)\n\n  if ( (void*)outputp != (void*) encode )\n    STBIR_MEMCPY( outputp, encode, width_times_channels * sizeof( float ) );\n\n  #else\n\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = (float*) outputp;\n  float * end_output = ( (float*) output ) + width_times_channels;\n\n  #ifdef STBIR_FLOAT_HIGH_CLAMP\n  #define stbir_scalar_hi_clamp( v ) if ( v > STBIR_FLOAT_HIGH_CLAMP ) v = STBIR_FLOAT_HIGH_CLAMP;\n  #else\n  #define stbir_scalar_hi_clamp( v )\n  #endif\n  #ifdef STBIR_FLOAT_LOW_CLAMP\n  #define stbir_scalar_lo_clamp( v ) if ( v < STBIR_FLOAT_LOW_CLAMP ) v = STBIR_FLOAT_LOW_CLAMP;\n  #else\n  #define stbir_scalar_lo_clamp( v )\n  #endif\n\n  #ifdef STBIR_SIMD\n\n  #ifdef STBIR_FLOAT_HIGH_CLAMP\n  const stbir__simdfX high_clamp = stbir__simdf_frepX(STBIR_FLOAT_HIGH_CLAMP);\n  #endif\n  #ifdef STBIR_FLOAT_LOW_CLAMP\n  const stbir__simdfX low_clamp = stbir__simdf_frepX(STBIR_FLOAT_LOW_CLAMP);\n  #endif\n\n  if ( width_times_channels >= ( stbir__simdfX_float_count * 2 ) )\n  {\n    float const * end_encode_m8 = encode + width_times_channels - ( stbir__simdfX_float_count * 2 );\n    end_output -= ( stbir__simdfX_float_count * 2 );\n    STBIR_SIMD_NO_UNROLL_LOOP_START_INF_FOR\n    for(;;)\n    {\n      stbir__simdfX e0, e1;\n      STBIR_SIMD_NO_UNROLL(encode);\n      stbir__simdfX_load( e0, encode );\n      stbir__simdfX_load( e1, encode+stbir__simdfX_float_count );\n#ifdef STBIR_FLOAT_HIGH_CLAMP\n      stbir__simdfX_min( e0, e0, high_clamp );\n      stbir__simdfX_min( e1, e1, high_clamp );\n#endif\n#ifdef STBIR_FLOAT_LOW_CLAMP\n      stbir__simdfX_max( e0, e0, low_clamp );\n      stbir__simdfX_max( e1, e1, low_clamp );\n#endif\n      stbir__encode_simdfX_unflip( e0 );\n      stbir__encode_simdfX_unflip( e1 );\n      stbir__simdfX_store( output, e0 );\n      stbir__simdfX_store( output+stbir__simdfX_float_count, e1 );\n      encode += stbir__simdfX_float_count * 2;\n      output += stbir__simdfX_float_count * 2;\n      if ( output < end_output )\n        continue;\n      if ( output == ( end_output + ( stbir__simdfX_float_count * 2 ) ) )\n        break;\n      output = end_output; // backup and do last couple\n      encode = end_encode_m8;\n    }\n    return;\n  }\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    stbir__simdf e0;\n    STBIR_NO_UNROLL(encode);\n    stbir__simdf_load( e0, encode );\n#ifdef STBIR_FLOAT_HIGH_CLAMP\n    stbir__simdf_min( e0, e0, high_clamp );\n#endif\n#ifdef STBIR_FLOAT_LOW_CLAMP\n    stbir__simdf_max( e0, e0, low_clamp );\n#endif\n    stbir__encode_simdf4_unflip( e0 );\n    stbir__simdf_store( output-4, e0 );\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n  #endif\n\n  #else\n\n  // try to do blocks of 4 when you can\n  #if stbir__coder_min_num != 3 // doesn't divide cleanly by four\n  output += 4;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  while( output <= end_output )\n  {\n    float e;\n    STBIR_SIMD_NO_UNROLL(encode);\n    e = encode[ stbir__encode_order0 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[0-4] = e;\n    e = encode[ stbir__encode_order1 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[1-4] = e;\n    e = encode[ stbir__encode_order2 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[2-4] = e;\n    e = encode[ stbir__encode_order3 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[3-4] = e;\n    output += 4;\n    encode += 4;\n  }\n  output -= 4;\n\n  #endif\n\n  #endif\n\n  // do the remnants\n  #if stbir__coder_min_num < 4\n  STBIR_NO_UNROLL_LOOP_START\n  while( output < end_output )\n  {\n    float e;\n    STBIR_NO_UNROLL(encode);\n    e = encode[ stbir__encode_order0 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[0] = e;\n    #if stbir__coder_min_num >= 2\n    e = encode[ stbir__encode_order1 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[1] = e;\n    #endif\n    #if stbir__coder_min_num >= 3\n    e = encode[ stbir__encode_order2 ]; stbir_scalar_hi_clamp( e ); stbir_scalar_lo_clamp( e ); output[2] = e;\n    #endif\n    output += stbir__coder_min_num;\n    encode += stbir__coder_min_num;\n  }\n  #endif\n\n  #endif\n}\n\n#undef stbir__decode_suffix\n#undef stbir__decode_simdf8_flip\n#undef stbir__decode_simdf4_flip\n#undef stbir__decode_order0\n#undef stbir__decode_order1\n#undef stbir__decode_order2\n#undef stbir__decode_order3\n#undef stbir__encode_order0\n#undef stbir__encode_order1\n#undef stbir__encode_order2\n#undef stbir__encode_order3\n#undef stbir__encode_simdf8_unflip\n#undef stbir__encode_simdf4_unflip\n#undef stbir__encode_simdfX_unflip\n#undef STBIR__CODER_NAME\n#undef stbir__coder_min_num\n#undef stbir__decode_swizzle\n#undef stbir_scalar_hi_clamp\n#undef stbir_scalar_lo_clamp\n#undef STB_IMAGE_RESIZE_DO_CODERS\n\n#elif defined( STB_IMAGE_RESIZE_DO_VERTICALS)\n\n#ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#define STBIR_chans( start, end ) STBIR_strs_join14(start,STBIR__vertical_channels,end,_cont)\n#else\n#define STBIR_chans( start, end ) STBIR_strs_join1(start,STBIR__vertical_channels,end)\n#endif\n\n#if STBIR__vertical_channels >= 1\n#define stbIF0( code ) code\n#else\n#define stbIF0( code )\n#endif\n#if STBIR__vertical_channels >= 2\n#define stbIF1( code ) code\n#else\n#define stbIF1( code )\n#endif\n#if STBIR__vertical_channels >= 3\n#define stbIF2( code ) code\n#else\n#define stbIF2( code )\n#endif\n#if STBIR__vertical_channels >= 4\n#define stbIF3( code ) code\n#else\n#define stbIF3( code )\n#endif\n#if STBIR__vertical_channels >= 5\n#define stbIF4( code ) code\n#else\n#define stbIF4( code )\n#endif\n#if STBIR__vertical_channels >= 6\n#define stbIF5( code ) code\n#else\n#define stbIF5( code )\n#endif\n#if STBIR__vertical_channels >= 7\n#define stbIF6( code ) code\n#else\n#define stbIF6( code )\n#endif\n#if STBIR__vertical_channels >= 8\n#define stbIF7( code ) code\n#else\n#define stbIF7( code )\n#endif\n\nstatic void STBIR_chans( stbir__vertical_scatter_with_,_coeffs)( float ** outputs, float const * vertical_coefficients, float const * input, float const * input_end )\n{\n  stbIF0( float STBIR_SIMD_STREAMOUT_PTR( * ) output0 = outputs[0]; float c0s = vertical_coefficients[0]; )\n  stbIF1( float STBIR_SIMD_STREAMOUT_PTR( * ) output1 = outputs[1]; float c1s = vertical_coefficients[1]; )\n  stbIF2( float STBIR_SIMD_STREAMOUT_PTR( * ) output2 = outputs[2]; float c2s = vertical_coefficients[2]; )\n  stbIF3( float STBIR_SIMD_STREAMOUT_PTR( * ) output3 = outputs[3]; float c3s = vertical_coefficients[3]; )\n  stbIF4( float STBIR_SIMD_STREAMOUT_PTR( * ) output4 = outputs[4]; float c4s = vertical_coefficients[4]; )\n  stbIF5( float STBIR_SIMD_STREAMOUT_PTR( * ) output5 = outputs[5]; float c5s = vertical_coefficients[5]; )\n  stbIF6( float STBIR_SIMD_STREAMOUT_PTR( * ) output6 = outputs[6]; float c6s = vertical_coefficients[6]; )\n  stbIF7( float STBIR_SIMD_STREAMOUT_PTR( * ) output7 = outputs[7]; float c7s = vertical_coefficients[7]; )\n\n  #ifdef STBIR_SIMD\n  {\n    stbIF0(stbir__simdfX c0 = stbir__simdf_frepX( c0s ); )\n    stbIF1(stbir__simdfX c1 = stbir__simdf_frepX( c1s ); )\n    stbIF2(stbir__simdfX c2 = stbir__simdf_frepX( c2s ); )\n    stbIF3(stbir__simdfX c3 = stbir__simdf_frepX( c3s ); )\n    stbIF4(stbir__simdfX c4 = stbir__simdf_frepX( c4s ); )\n    stbIF5(stbir__simdfX c5 = stbir__simdf_frepX( c5s ); )\n    stbIF6(stbir__simdfX c6 = stbir__simdf_frepX( c6s ); )\n    stbIF7(stbir__simdfX c7 = stbir__simdf_frepX( c7s ); )\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    while ( ( (char*)input_end - (char*) input ) >= (16*stbir__simdfX_float_count) )\n    {\n      stbir__simdfX o0, o1, o2, o3, r0, r1, r2, r3;\n      STBIR_SIMD_NO_UNROLL(output0);\n\n      stbir__simdfX_load( r0, input );               stbir__simdfX_load( r1, input+stbir__simdfX_float_count );     stbir__simdfX_load( r2, input+(2*stbir__simdfX_float_count) );      stbir__simdfX_load( r3, input+(3*stbir__simdfX_float_count) );\n\n      #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n      stbIF0( stbir__simdfX_load( o0, output0 );     stbir__simdfX_load( o1, output0+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output0+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output0+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c0 );  stbir__simdfX_madd( o1, o1, r1, c0 );  stbir__simdfX_madd( o2, o2, r2, c0 );   stbir__simdfX_madd( o3, o3, r3, c0 );\n              stbir__simdfX_store( output0, o0 );    stbir__simdfX_store( output0+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output0+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output0+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF1( stbir__simdfX_load( o0, output1 );     stbir__simdfX_load( o1, output1+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output1+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output1+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c1 );  stbir__simdfX_madd( o1, o1, r1, c1 );  stbir__simdfX_madd( o2, o2, r2, c1 );   stbir__simdfX_madd( o3, o3, r3, c1 );\n              stbir__simdfX_store( output1, o0 );    stbir__simdfX_store( output1+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output1+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output1+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF2( stbir__simdfX_load( o0, output2 );     stbir__simdfX_load( o1, output2+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output2+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output2+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c2 );  stbir__simdfX_madd( o1, o1, r1, c2 );  stbir__simdfX_madd( o2, o2, r2, c2 );   stbir__simdfX_madd( o3, o3, r3, c2 );\n              stbir__simdfX_store( output2, o0 );    stbir__simdfX_store( output2+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output2+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output2+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF3( stbir__simdfX_load( o0, output3 );     stbir__simdfX_load( o1, output3+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output3+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output3+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c3 );  stbir__simdfX_madd( o1, o1, r1, c3 );  stbir__simdfX_madd( o2, o2, r2, c3 );   stbir__simdfX_madd( o3, o3, r3, c3 );\n              stbir__simdfX_store( output3, o0 );    stbir__simdfX_store( output3+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output3+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output3+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF4( stbir__simdfX_load( o0, output4 );     stbir__simdfX_load( o1, output4+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output4+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output4+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c4 );  stbir__simdfX_madd( o1, o1, r1, c4 );  stbir__simdfX_madd( o2, o2, r2, c4 );   stbir__simdfX_madd( o3, o3, r3, c4 );\n              stbir__simdfX_store( output4, o0 );    stbir__simdfX_store( output4+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output4+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output4+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF5( stbir__simdfX_load( o0, output5 );     stbir__simdfX_load( o1, output5+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output5+(2*stbir__simdfX_float_count));    stbir__simdfX_load( o3, output5+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c5 );  stbir__simdfX_madd( o1, o1, r1, c5 );  stbir__simdfX_madd( o2, o2, r2, c5 );   stbir__simdfX_madd( o3, o3, r3, c5 );\n              stbir__simdfX_store( output5, o0 );    stbir__simdfX_store( output5+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output5+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output5+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF6( stbir__simdfX_load( o0, output6 );     stbir__simdfX_load( o1, output6+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output6+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output6+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c6 );  stbir__simdfX_madd( o1, o1, r1, c6 );  stbir__simdfX_madd( o2, o2, r2, c6 );   stbir__simdfX_madd( o3, o3, r3, c6 );\n              stbir__simdfX_store( output6, o0 );    stbir__simdfX_store( output6+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output6+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output6+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF7( stbir__simdfX_load( o0, output7 );     stbir__simdfX_load( o1, output7+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output7+(2*stbir__simdfX_float_count) );    stbir__simdfX_load( o3, output7+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c7 );  stbir__simdfX_madd( o1, o1, r1, c7 );  stbir__simdfX_madd( o2, o2, r2, c7 );   stbir__simdfX_madd( o3, o3, r3, c7 );\n              stbir__simdfX_store( output7, o0 );    stbir__simdfX_store( output7+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output7+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output7+(3*stbir__simdfX_float_count), o3 ); )\n      #else\n      stbIF0( stbir__simdfX_mult( o0, r0, c0 );      stbir__simdfX_mult( o1, r1, c0 );      stbir__simdfX_mult( o2, r2, c0 );       stbir__simdfX_mult( o3, r3, c0 );\n              stbir__simdfX_store( output0, o0 );    stbir__simdfX_store( output0+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output0+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output0+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF1( stbir__simdfX_mult( o0, r0, c1 );      stbir__simdfX_mult( o1, r1, c1 );      stbir__simdfX_mult( o2, r2, c1 );       stbir__simdfX_mult( o3, r3, c1 );\n              stbir__simdfX_store( output1, o0 );    stbir__simdfX_store( output1+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output1+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output1+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF2( stbir__simdfX_mult( o0, r0, c2 );      stbir__simdfX_mult( o1, r1, c2 );      stbir__simdfX_mult( o2, r2, c2 );       stbir__simdfX_mult( o3, r3, c2 );\n              stbir__simdfX_store( output2, o0 );    stbir__simdfX_store( output2+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output2+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output2+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF3( stbir__simdfX_mult( o0, r0, c3 );      stbir__simdfX_mult( o1, r1, c3 );      stbir__simdfX_mult( o2, r2, c3 );       stbir__simdfX_mult( o3, r3, c3 );\n              stbir__simdfX_store( output3, o0 );    stbir__simdfX_store( output3+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output3+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output3+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF4( stbir__simdfX_mult( o0, r0, c4 );      stbir__simdfX_mult( o1, r1, c4 );      stbir__simdfX_mult( o2, r2, c4 );       stbir__simdfX_mult( o3, r3, c4 );\n              stbir__simdfX_store( output4, o0 );    stbir__simdfX_store( output4+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output4+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output4+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF5( stbir__simdfX_mult( o0, r0, c5 );      stbir__simdfX_mult( o1, r1, c5 );      stbir__simdfX_mult( o2, r2, c5 );       stbir__simdfX_mult( o3, r3, c5 );\n              stbir__simdfX_store( output5, o0 );    stbir__simdfX_store( output5+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output5+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output5+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF6( stbir__simdfX_mult( o0, r0, c6 );      stbir__simdfX_mult( o1, r1, c6 );      stbir__simdfX_mult( o2, r2, c6 );       stbir__simdfX_mult( o3, r3, c6 );\n              stbir__simdfX_store( output6, o0 );    stbir__simdfX_store( output6+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output6+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output6+(3*stbir__simdfX_float_count), o3 ); )\n      stbIF7( stbir__simdfX_mult( o0, r0, c7 );      stbir__simdfX_mult( o1, r1, c7 );      stbir__simdfX_mult( o2, r2, c7 );       stbir__simdfX_mult( o3, r3, c7 );\n              stbir__simdfX_store( output7, o0 );    stbir__simdfX_store( output7+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output7+(2*stbir__simdfX_float_count), o2 );   stbir__simdfX_store( output7+(3*stbir__simdfX_float_count), o3 ); )\n      #endif\n\n      input += (4*stbir__simdfX_float_count);\n      stbIF0( output0 += (4*stbir__simdfX_float_count); ) stbIF1( output1 += (4*stbir__simdfX_float_count); ) stbIF2( output2 += (4*stbir__simdfX_float_count); ) stbIF3( output3 += (4*stbir__simdfX_float_count); ) stbIF4( output4 += (4*stbir__simdfX_float_count); ) stbIF5( output5 += (4*stbir__simdfX_float_count); ) stbIF6( output6 += (4*stbir__simdfX_float_count); ) stbIF7( output7 += (4*stbir__simdfX_float_count); )\n    }\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    while ( ( (char*)input_end - (char*) input ) >= 16 )\n    {\n      stbir__simdf o0, r0;\n      STBIR_SIMD_NO_UNROLL(output0);\n\n      stbir__simdf_load( r0, input );\n\n      #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n      stbIF0( stbir__simdf_load( o0, output0 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) );  stbir__simdf_store( output0, o0 ); )\n      stbIF1( stbir__simdf_load( o0, output1 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) );  stbir__simdf_store( output1, o0 ); )\n      stbIF2( stbir__simdf_load( o0, output2 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) );  stbir__simdf_store( output2, o0 ); )\n      stbIF3( stbir__simdf_load( o0, output3 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) );  stbir__simdf_store( output3, o0 ); )\n      stbIF4( stbir__simdf_load( o0, output4 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) );  stbir__simdf_store( output4, o0 ); )\n      stbIF5( stbir__simdf_load( o0, output5 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) );  stbir__simdf_store( output5, o0 ); )\n      stbIF6( stbir__simdf_load( o0, output6 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) );  stbir__simdf_store( output6, o0 ); )\n      stbIF7( stbir__simdf_load( o0, output7 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) );  stbir__simdf_store( output7, o0 ); )\n      #else\n      stbIF0( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) );   stbir__simdf_store( output0, o0 ); )\n      stbIF1( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) );   stbir__simdf_store( output1, o0 ); )\n      stbIF2( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) );   stbir__simdf_store( output2, o0 ); )\n      stbIF3( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) );   stbir__simdf_store( output3, o0 ); )\n      stbIF4( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) );   stbir__simdf_store( output4, o0 ); )\n      stbIF5( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) );   stbir__simdf_store( output5, o0 ); )\n      stbIF6( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) );   stbir__simdf_store( output6, o0 ); )\n      stbIF7( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) );   stbir__simdf_store( output7, o0 ); )\n      #endif\n\n      input += 4;\n      stbIF0( output0 += 4; ) stbIF1( output1 += 4; ) stbIF2( output2 += 4; ) stbIF3( output3 += 4; ) stbIF4( output4 += 4; ) stbIF5( output5 += 4; ) stbIF6( output6 += 4; ) stbIF7( output7 += 4; )\n    }\n  }\n  #else\n  STBIR_NO_UNROLL_LOOP_START\n  while ( ( (char*)input_end - (char*) input ) >= 16 )\n  {\n    float r0, r1, r2, r3;\n    STBIR_NO_UNROLL(input);\n\n    r0 = input[0], r1 = input[1], r2 = input[2], r3 = input[3];\n\n    #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n    stbIF0( output0[0] += ( r0 * c0s ); output0[1] += ( r1 * c0s ); output0[2] += ( r2 * c0s ); output0[3] += ( r3 * c0s ); )\n    stbIF1( output1[0] += ( r0 * c1s ); output1[1] += ( r1 * c1s ); output1[2] += ( r2 * c1s ); output1[3] += ( r3 * c1s ); )\n    stbIF2( output2[0] += ( r0 * c2s ); output2[1] += ( r1 * c2s ); output2[2] += ( r2 * c2s ); output2[3] += ( r3 * c2s ); )\n    stbIF3( output3[0] += ( r0 * c3s ); output3[1] += ( r1 * c3s ); output3[2] += ( r2 * c3s ); output3[3] += ( r3 * c3s ); )\n    stbIF4( output4[0] += ( r0 * c4s ); output4[1] += ( r1 * c4s ); output4[2] += ( r2 * c4s ); output4[3] += ( r3 * c4s ); )\n    stbIF5( output5[0] += ( r0 * c5s ); output5[1] += ( r1 * c5s ); output5[2] += ( r2 * c5s ); output5[3] += ( r3 * c5s ); )\n    stbIF6( output6[0] += ( r0 * c6s ); output6[1] += ( r1 * c6s ); output6[2] += ( r2 * c6s ); output6[3] += ( r3 * c6s ); )\n    stbIF7( output7[0] += ( r0 * c7s ); output7[1] += ( r1 * c7s ); output7[2] += ( r2 * c7s ); output7[3] += ( r3 * c7s ); )\n    #else\n    stbIF0( output0[0]  = ( r0 * c0s ); output0[1]  = ( r1 * c0s ); output0[2]  = ( r2 * c0s ); output0[3]  = ( r3 * c0s ); )\n    stbIF1( output1[0]  = ( r0 * c1s ); output1[1]  = ( r1 * c1s ); output1[2]  = ( r2 * c1s ); output1[3]  = ( r3 * c1s ); )\n    stbIF2( output2[0]  = ( r0 * c2s ); output2[1]  = ( r1 * c2s ); output2[2]  = ( r2 * c2s ); output2[3]  = ( r3 * c2s ); )\n    stbIF3( output3[0]  = ( r0 * c3s ); output3[1]  = ( r1 * c3s ); output3[2]  = ( r2 * c3s ); output3[3]  = ( r3 * c3s ); )\n    stbIF4( output4[0]  = ( r0 * c4s ); output4[1]  = ( r1 * c4s ); output4[2]  = ( r2 * c4s ); output4[3]  = ( r3 * c4s ); )\n    stbIF5( output5[0]  = ( r0 * c5s ); output5[1]  = ( r1 * c5s ); output5[2]  = ( r2 * c5s ); output5[3]  = ( r3 * c5s ); )\n    stbIF6( output6[0]  = ( r0 * c6s ); output6[1]  = ( r1 * c6s ); output6[2]  = ( r2 * c6s ); output6[3]  = ( r3 * c6s ); )\n    stbIF7( output7[0]  = ( r0 * c7s ); output7[1]  = ( r1 * c7s ); output7[2]  = ( r2 * c7s ); output7[3]  = ( r3 * c7s ); )\n    #endif\n\n    input += 4;\n    stbIF0( output0 += 4; ) stbIF1( output1 += 4; ) stbIF2( output2 += 4; ) stbIF3( output3 += 4; ) stbIF4( output4 += 4; ) stbIF5( output5 += 4; ) stbIF6( output6 += 4; ) stbIF7( output7 += 4; )\n  }\n  #endif\n  STBIR_NO_UNROLL_LOOP_START\n  while ( input < input_end )\n  {\n    float r = input[0];\n    STBIR_NO_UNROLL(output0);\n\n    #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n    stbIF0( output0[0] += ( r * c0s ); )\n    stbIF1( output1[0] += ( r * c1s ); )\n    stbIF2( output2[0] += ( r * c2s ); )\n    stbIF3( output3[0] += ( r * c3s ); )\n    stbIF4( output4[0] += ( r * c4s ); )\n    stbIF5( output5[0] += ( r * c5s ); )\n    stbIF6( output6[0] += ( r * c6s ); )\n    stbIF7( output7[0] += ( r * c7s ); )\n    #else\n    stbIF0( output0[0]  = ( r * c0s ); )\n    stbIF1( output1[0]  = ( r * c1s ); )\n    stbIF2( output2[0]  = ( r * c2s ); )\n    stbIF3( output3[0]  = ( r * c3s ); )\n    stbIF4( output4[0]  = ( r * c4s ); )\n    stbIF5( output5[0]  = ( r * c5s ); )\n    stbIF6( output6[0]  = ( r * c6s ); )\n    stbIF7( output7[0]  = ( r * c7s ); )\n    #endif\n\n    ++input;\n    stbIF0( ++output0; ) stbIF1( ++output1; ) stbIF2( ++output2; ) stbIF3( ++output3; ) stbIF4( ++output4; ) stbIF5( ++output5; ) stbIF6( ++output6; ) stbIF7( ++output7; )\n  }\n}\n\nstatic void STBIR_chans( stbir__vertical_gather_with_,_coeffs)( float * outputp, float const * vertical_coefficients, float const ** inputs, float const * input0_end )\n{\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = outputp;\n\n  stbIF0( float const * input0 = inputs[0]; float c0s = vertical_coefficients[0]; )\n  stbIF1( float const * input1 = inputs[1]; float c1s = vertical_coefficients[1]; )\n  stbIF2( float const * input2 = inputs[2]; float c2s = vertical_coefficients[2]; )\n  stbIF3( float const * input3 = inputs[3]; float c3s = vertical_coefficients[3]; )\n  stbIF4( float const * input4 = inputs[4]; float c4s = vertical_coefficients[4]; )\n  stbIF5( float const * input5 = inputs[5]; float c5s = vertical_coefficients[5]; )\n  stbIF6( float const * input6 = inputs[6]; float c6s = vertical_coefficients[6]; )\n  stbIF7( float const * input7 = inputs[7]; float c7s = vertical_coefficients[7]; )\n\n#if ( STBIR__vertical_channels == 1 ) && !defined(STB_IMAGE_RESIZE_VERTICAL_CONTINUE)\n  // check single channel one weight\n  if ( ( c0s >= (1.0f-0.000001f) ) && ( c0s <= (1.0f+0.000001f) ) )\n  {\n    STBIR_MEMCPY( output, input0, (char*)input0_end - (char*)input0 );\n    return;\n  }\n#endif\n\n  #ifdef STBIR_SIMD\n  {\n    stbIF0(stbir__simdfX c0 = stbir__simdf_frepX( c0s ); )\n    stbIF1(stbir__simdfX c1 = stbir__simdf_frepX( c1s ); )\n    stbIF2(stbir__simdfX c2 = stbir__simdf_frepX( c2s ); )\n    stbIF3(stbir__simdfX c3 = stbir__simdf_frepX( c3s ); )\n    stbIF4(stbir__simdfX c4 = stbir__simdf_frepX( c4s ); )\n    stbIF5(stbir__simdfX c5 = stbir__simdf_frepX( c5s ); )\n    stbIF6(stbir__simdfX c6 = stbir__simdf_frepX( c6s ); )\n    stbIF7(stbir__simdfX c7 = stbir__simdf_frepX( c7s ); )\n\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    while ( ( (char*)input0_end - (char*) input0 ) >= (16*stbir__simdfX_float_count) )\n    {\n      stbir__simdfX o0, o1, o2, o3, r0, r1, r2, r3;\n      STBIR_SIMD_NO_UNROLL(output);\n\n      // prefetch four loop iterations ahead (doesn't affect much for small resizes, but helps with big ones)\n      stbIF0( stbir__prefetch( input0 + (16*stbir__simdfX_float_count) ); )\n      stbIF1( stbir__prefetch( input1 + (16*stbir__simdfX_float_count) ); )\n      stbIF2( stbir__prefetch( input2 + (16*stbir__simdfX_float_count) ); )\n      stbIF3( stbir__prefetch( input3 + (16*stbir__simdfX_float_count) ); )\n      stbIF4( stbir__prefetch( input4 + (16*stbir__simdfX_float_count) ); )\n      stbIF5( stbir__prefetch( input5 + (16*stbir__simdfX_float_count) ); )\n      stbIF6( stbir__prefetch( input6 + (16*stbir__simdfX_float_count) ); )\n      stbIF7( stbir__prefetch( input7 + (16*stbir__simdfX_float_count) ); )\n\n      #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n      stbIF0( stbir__simdfX_load( o0, output );      stbir__simdfX_load( o1, output+stbir__simdfX_float_count );   stbir__simdfX_load( o2, output+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( o3, output+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_load( r0, input0 );      stbir__simdfX_load( r1, input0+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input0+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input0+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c0 );  stbir__simdfX_madd( o1, o1, r1, c0 );                         stbir__simdfX_madd( o2, o2, r2, c0 );                             stbir__simdfX_madd( o3, o3, r3, c0 ); )\n      #else\n      stbIF0( stbir__simdfX_load( r0, input0 );      stbir__simdfX_load( r1, input0+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input0+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input0+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_mult( o0, r0, c0 );      stbir__simdfX_mult( o1, r1, c0 );                             stbir__simdfX_mult( o2, r2, c0 );                                 stbir__simdfX_mult( o3, r3, c0 );  )\n      #endif\n\n      stbIF1( stbir__simdfX_load( r0, input1 );      stbir__simdfX_load( r1, input1+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input1+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input1+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c1 );  stbir__simdfX_madd( o1, o1, r1, c1 );                         stbir__simdfX_madd( o2, o2, r2, c1 );                             stbir__simdfX_madd( o3, o3, r3, c1 ); )\n      stbIF2( stbir__simdfX_load( r0, input2 );      stbir__simdfX_load( r1, input2+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input2+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input2+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c2 );  stbir__simdfX_madd( o1, o1, r1, c2 );                         stbir__simdfX_madd( o2, o2, r2, c2 );                             stbir__simdfX_madd( o3, o3, r3, c2 ); )\n      stbIF3( stbir__simdfX_load( r0, input3 );      stbir__simdfX_load( r1, input3+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input3+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input3+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c3 );  stbir__simdfX_madd( o1, o1, r1, c3 );                         stbir__simdfX_madd( o2, o2, r2, c3 );                             stbir__simdfX_madd( o3, o3, r3, c3 ); )\n      stbIF4( stbir__simdfX_load( r0, input4 );      stbir__simdfX_load( r1, input4+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input4+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input4+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c4 );  stbir__simdfX_madd( o1, o1, r1, c4 );                         stbir__simdfX_madd( o2, o2, r2, c4 );                             stbir__simdfX_madd( o3, o3, r3, c4 ); )\n      stbIF5( stbir__simdfX_load( r0, input5 );      stbir__simdfX_load( r1, input5+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input5+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input5+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c5 );  stbir__simdfX_madd( o1, o1, r1, c5 );                         stbir__simdfX_madd( o2, o2, r2, c5 );                             stbir__simdfX_madd( o3, o3, r3, c5 ); )\n      stbIF6( stbir__simdfX_load( r0, input6 );      stbir__simdfX_load( r1, input6+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input6+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input6+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c6 );  stbir__simdfX_madd( o1, o1, r1, c6 );                         stbir__simdfX_madd( o2, o2, r2, c6 );                             stbir__simdfX_madd( o3, o3, r3, c6 ); )\n      stbIF7( stbir__simdfX_load( r0, input7 );      stbir__simdfX_load( r1, input7+stbir__simdfX_float_count );   stbir__simdfX_load( r2, input7+(2*stbir__simdfX_float_count) );   stbir__simdfX_load( r3, input7+(3*stbir__simdfX_float_count) );\n              stbir__simdfX_madd( o0, o0, r0, c7 );  stbir__simdfX_madd( o1, o1, r1, c7 );                         stbir__simdfX_madd( o2, o2, r2, c7 );                             stbir__simdfX_madd( o3, o3, r3, c7 ); )\n\n      stbir__simdfX_store( output, o0 );             stbir__simdfX_store( output+stbir__simdfX_float_count, o1 );  stbir__simdfX_store( output+(2*stbir__simdfX_float_count), o2 );  stbir__simdfX_store( output+(3*stbir__simdfX_float_count), o3 );\n      output += (4*stbir__simdfX_float_count);\n      stbIF0( input0 += (4*stbir__simdfX_float_count); ) stbIF1( input1 += (4*stbir__simdfX_float_count); ) stbIF2( input2 += (4*stbir__simdfX_float_count); ) stbIF3( input3 += (4*stbir__simdfX_float_count); ) stbIF4( input4 += (4*stbir__simdfX_float_count); ) stbIF5( input5 += (4*stbir__simdfX_float_count); ) stbIF6( input6 += (4*stbir__simdfX_float_count); ) stbIF7( input7 += (4*stbir__simdfX_float_count); )\n    }\n\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    while ( ( (char*)input0_end - (char*) input0 ) >= 16 )\n    {\n      stbir__simdf o0, r0;\n      STBIR_SIMD_NO_UNROLL(output);\n\n      #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n      stbIF0( stbir__simdf_load( o0, output );   stbir__simdf_load( r0, input0 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); )\n      #else\n      stbIF0( stbir__simdf_load( r0, input0 );  stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); )\n      #endif\n      stbIF1( stbir__simdf_load( r0, input1 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) ); )\n      stbIF2( stbir__simdf_load( r0, input2 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) ); )\n      stbIF3( stbir__simdf_load( r0, input3 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) ); )\n      stbIF4( stbir__simdf_load( r0, input4 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) ); )\n      stbIF5( stbir__simdf_load( r0, input5 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) ); )\n      stbIF6( stbir__simdf_load( r0, input6 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) ); )\n      stbIF7( stbir__simdf_load( r0, input7 );  stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) ); )\n\n      stbir__simdf_store( output, o0 );\n      output += 4;\n      stbIF0( input0 += 4; ) stbIF1( input1 += 4; ) stbIF2( input2 += 4; ) stbIF3( input3 += 4; ) stbIF4( input4 += 4; ) stbIF5( input5 += 4; ) stbIF6( input6 += 4; ) stbIF7( input7 += 4; )\n    }\n  }\n  #else\n  STBIR_NO_UNROLL_LOOP_START\n  while ( ( (char*)input0_end - (char*) input0 ) >= 16 )\n  {\n    float o0, o1, o2, o3;\n    STBIR_NO_UNROLL(output);\n    #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n    stbIF0( o0 = output[0] + input0[0] * c0s; o1 = output[1] + input0[1] * c0s; o2 = output[2] + input0[2] * c0s; o3 = output[3] + input0[3] * c0s; )\n    #else\n    stbIF0( o0  = input0[0] * c0s; o1  = input0[1] * c0s; o2  = input0[2] * c0s; o3  = input0[3] * c0s; )\n    #endif\n    stbIF1( o0 += input1[0] * c1s; o1 += input1[1] * c1s; o2 += input1[2] * c1s; o3 += input1[3] * c1s; )\n    stbIF2( o0 += input2[0] * c2s; o1 += input2[1] * c2s; o2 += input2[2] * c2s; o3 += input2[3] * c2s; )\n    stbIF3( o0 += input3[0] * c3s; o1 += input3[1] * c3s; o2 += input3[2] * c3s; o3 += input3[3] * c3s; )\n    stbIF4( o0 += input4[0] * c4s; o1 += input4[1] * c4s; o2 += input4[2] * c4s; o3 += input4[3] * c4s; )\n    stbIF5( o0 += input5[0] * c5s; o1 += input5[1] * c5s; o2 += input5[2] * c5s; o3 += input5[3] * c5s; )\n    stbIF6( o0 += input6[0] * c6s; o1 += input6[1] * c6s; o2 += input6[2] * c6s; o3 += input6[3] * c6s; )\n    stbIF7( o0 += input7[0] * c7s; o1 += input7[1] * c7s; o2 += input7[2] * c7s; o3 += input7[3] * c7s; )\n    output[0] = o0; output[1] = o1; output[2] = o2; output[3] = o3;\n    output += 4;\n    stbIF0( input0 += 4; ) stbIF1( input1 += 4; ) stbIF2( input2 += 4; ) stbIF3( input3 += 4; ) stbIF4( input4 += 4; ) stbIF5( input5 += 4; ) stbIF6( input6 += 4; ) stbIF7( input7 += 4; )\n  }\n  #endif\n  STBIR_NO_UNROLL_LOOP_START\n  while ( input0 < input0_end )\n  {\n    float o0;\n    STBIR_NO_UNROLL(output);\n    #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n    stbIF0( o0 = output[0] + input0[0] * c0s; )\n    #else\n    stbIF0( o0  = input0[0] * c0s; )\n    #endif\n    stbIF1( o0 += input1[0] * c1s; )\n    stbIF2( o0 += input2[0] * c2s; )\n    stbIF3( o0 += input3[0] * c3s; )\n    stbIF4( o0 += input4[0] * c4s; )\n    stbIF5( o0 += input5[0] * c5s; )\n    stbIF6( o0 += input6[0] * c6s; )\n    stbIF7( o0 += input7[0] * c7s; )\n    output[0] = o0;\n    ++output;\n    stbIF0( ++input0; ) stbIF1( ++input1; ) stbIF2( ++input2; ) stbIF3( ++input3; ) stbIF4( ++input4; ) stbIF5( ++input5; ) stbIF6( ++input6; ) stbIF7( ++input7; )\n  }\n}\n\n#undef stbIF0\n#undef stbIF1\n#undef stbIF2\n#undef stbIF3\n#undef stbIF4\n#undef stbIF5\n#undef stbIF6\n#undef stbIF7\n#undef STB_IMAGE_RESIZE_DO_VERTICALS\n#undef STBIR__vertical_channels\n#undef STB_IMAGE_RESIZE_DO_HORIZONTALS\n#undef STBIR_strs_join24\n#undef STBIR_strs_join14\n#undef STBIR_chans\n#ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#undef STB_IMAGE_RESIZE_VERTICAL_CONTINUE\n#endif\n\n#else // !STB_IMAGE_RESIZE_DO_VERTICALS\n\n#define STBIR_chans( start, end ) STBIR_strs_join1(start,STBIR__horizontal_channels,end)\n\n#ifndef stbir__2_coeff_only\n#define stbir__2_coeff_only()             \\\n    stbir__1_coeff_only();                \\\n    stbir__1_coeff_remnant(1);\n#endif\n\n#ifndef stbir__2_coeff_remnant\n#define stbir__2_coeff_remnant( ofs )     \\\n    stbir__1_coeff_remnant(ofs);          \\\n    stbir__1_coeff_remnant((ofs)+1);\n#endif\n\n#ifndef stbir__3_coeff_only\n#define stbir__3_coeff_only()             \\\n    stbir__2_coeff_only();                \\\n    stbir__1_coeff_remnant(2);\n#endif\n\n#ifndef stbir__3_coeff_remnant\n#define stbir__3_coeff_remnant( ofs )     \\\n    stbir__2_coeff_remnant(ofs);          \\\n    stbir__1_coeff_remnant((ofs)+2);\n#endif\n\n#ifndef stbir__3_coeff_setup\n#define stbir__3_coeff_setup()\n#endif\n\n#ifndef stbir__4_coeff_start\n#define stbir__4_coeff_start()            \\\n    stbir__2_coeff_only();                \\\n    stbir__2_coeff_remnant(2);\n#endif\n\n#ifndef stbir__4_coeff_continue_from_4\n#define stbir__4_coeff_continue_from_4( ofs )     \\\n    stbir__2_coeff_remnant(ofs);                  \\\n    stbir__2_coeff_remnant((ofs)+2);\n#endif\n\n#ifndef stbir__store_output_tiny\n#define stbir__store_output_tiny stbir__store_output\n#endif\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_1_coeff)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__1_coeff_only();\n    stbir__store_output_tiny();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_2_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__2_coeff_only();\n    stbir__store_output_tiny();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_3_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__3_coeff_only();\n    stbir__store_output_tiny();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_4_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_5_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__1_coeff_remnant(4);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_6_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__2_coeff_remnant(4);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_7_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  stbir__3_coeff_setup();\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n\n    stbir__4_coeff_start();\n    stbir__3_coeff_remnant(4);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_8_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__4_coeff_continue_from_4(4);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_9_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__4_coeff_continue_from_4(4);\n    stbir__1_coeff_remnant(8);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_10_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__4_coeff_continue_from_4(4);\n    stbir__2_coeff_remnant(8);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_11_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  stbir__3_coeff_setup();\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__4_coeff_continue_from_4(4);\n    stbir__3_coeff_remnant(8);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_12_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    float const * hc = horizontal_coefficients;\n    stbir__4_coeff_start();\n    stbir__4_coeff_continue_from_4(4);\n    stbir__4_coeff_continue_from_4(8);\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_n_coeffs_mod0 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    int n = ( ( horizontal_contributors->n1 - horizontal_contributors->n0 + 1 ) - 4 + 3 ) >> 2;\n    float const * hc = horizontal_coefficients;\n\n    stbir__4_coeff_start();\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    do {\n      hc += 4;\n      decode += STBIR__horizontal_channels * 4;\n      stbir__4_coeff_continue_from_4( 0 );\n      --n;\n    } while ( n > 0 );\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_n_coeffs_mod1 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    int n = ( ( horizontal_contributors->n1 - horizontal_contributors->n0 + 1 ) - 5 + 3 ) >> 2;\n    float const * hc = horizontal_coefficients;\n\n    stbir__4_coeff_start();\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    do {\n      hc += 4;\n      decode += STBIR__horizontal_channels * 4;\n      stbir__4_coeff_continue_from_4( 0 );\n      --n;\n    } while ( n > 0 );\n    stbir__1_coeff_remnant( 4 );\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_n_coeffs_mod2 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    int n = ( ( horizontal_contributors->n1 - horizontal_contributors->n0 + 1 ) - 6 + 3 ) >> 2;\n    float const * hc = horizontal_coefficients;\n\n    stbir__4_coeff_start();\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    do {\n      hc += 4;\n      decode += STBIR__horizontal_channels * 4;\n      stbir__4_coeff_continue_from_4( 0 );\n      --n;\n    } while ( n > 0 );\n    stbir__2_coeff_remnant( 4 );\n\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic void STBIR_chans( stbir__horizontal_gather_,_channels_with_n_coeffs_mod3 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width )\n{\n  float const * output_end = output_buffer + output_sub_size * STBIR__horizontal_channels;\n  float STBIR_SIMD_STREAMOUT_PTR( * ) output = output_buffer;\n  stbir__3_coeff_setup();\n  STBIR_SIMD_NO_UNROLL_LOOP_START\n  do {\n    float const * decode = decode_buffer + horizontal_contributors->n0 * STBIR__horizontal_channels;\n    int n = ( ( horizontal_contributors->n1 - horizontal_contributors->n0 + 1 ) - 7 + 3 ) >> 2;\n    float const * hc = horizontal_coefficients;\n\n    stbir__4_coeff_start();\n    STBIR_SIMD_NO_UNROLL_LOOP_START\n    do {\n      hc += 4;\n      decode += STBIR__horizontal_channels * 4;\n      stbir__4_coeff_continue_from_4( 0 );\n      --n;\n    } while ( n > 0 );\n    stbir__3_coeff_remnant( 4 );\n\n    stbir__store_output();\n  } while ( output < output_end );\n}\n\nstatic stbir__horizontal_gather_channels_func * STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_funcs)[4]=\n{\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod0),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod1),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod2),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod3),\n};\n\nstatic stbir__horizontal_gather_channels_func * STBIR_chans(stbir__horizontal_gather_,_channels_funcs)[12]=\n{\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_1_coeff),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_2_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_3_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_4_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_5_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_6_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_7_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_8_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_9_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_10_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_11_coeffs),\n  STBIR_chans(stbir__horizontal_gather_,_channels_with_12_coeffs),\n};\n\n#undef STBIR__horizontal_channels\n#undef STB_IMAGE_RESIZE_DO_HORIZONTALS\n#undef stbir__1_coeff_only\n#undef stbir__1_coeff_remnant\n#undef stbir__2_coeff_only\n#undef stbir__2_coeff_remnant\n#undef stbir__3_coeff_only\n#undef stbir__3_coeff_remnant\n#undef stbir__3_coeff_setup\n#undef stbir__4_coeff_start\n#undef stbir__4_coeff_continue_from_4\n#undef stbir__store_output\n#undef stbir__store_output_tiny\n#undef STBIR_chans\n\n#endif  // HORIZONALS\n\n#undef STBIR_strs_join2\n#undef STBIR_strs_join1\n\n#endif // STB_IMAGE_RESIZE_DO_HORIZONTALS/VERTICALS/CODERS\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_image_resize_test",
          "type": "tree",
          "content": null
        },
        {
          "name": "stb_image_write.h",
          "type": "blob",
          "size": 69.5517578125,
          "content": "/* stb_image_write - v1.16 - public domain - http://nothings.org/stb\n   writes out PNG/BMP/TGA/JPEG/HDR images to C stdio - Sean Barrett 2010-2015\n                                     no warranty implied; use at your own risk\n\n   Before #including,\n\n       #define STB_IMAGE_WRITE_IMPLEMENTATION\n\n   in the file that you want to have the implementation.\n\n   Will probably not work correctly with strict-aliasing optimizations.\n\nABOUT:\n\n   This header file is a library for writing images to C stdio or a callback.\n\n   The PNG output is not optimal; it is 20-50% larger than the file\n   written by a decent optimizing implementation; though providing a custom\n   zlib compress function (see STBIW_ZLIB_COMPRESS) can mitigate that.\n   This library is designed for source code compactness and simplicity,\n   not optimal image file size or run-time performance.\n\nBUILDING:\n\n   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.\n   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace\n   malloc,realloc,free.\n   You can #define STBIW_MEMMOVE() to replace memmove()\n   You can #define STBIW_ZLIB_COMPRESS to use a custom zlib-style compress function\n   for PNG compression (instead of the builtin one), it must have the following signature:\n   unsigned char * my_compress(unsigned char *data, int data_len, int *out_len, int quality);\n   The returned data will be freed with STBIW_FREE() (free() by default),\n   so it must be heap allocated with STBIW_MALLOC() (malloc() by default),\n\nUNICODE:\n\n   If compiling for Windows and you wish to use Unicode filenames, compile\n   with\n       #define STBIW_WINDOWS_UTF8\n   and pass utf8-encoded filenames. Call stbiw_convert_wchar_to_utf8 to convert\n   Windows wchar_t filenames to utf8.\n\nUSAGE:\n\n   There are five functions, one for each image file format:\n\n     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);\n     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);\n     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);\n     int stbi_write_jpg(char const *filename, int w, int h, int comp, const void *data, int quality);\n     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\n\n     void stbi_flip_vertically_on_write(int flag); // flag is non-zero to flip data vertically\n\n   There are also five equivalent functions that use an arbitrary write function. You are\n   expected to open/close your file-equivalent before and after calling these:\n\n     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);\n     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\n     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\n     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);\n     int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);\n\n   where the callback is:\n      void stbi_write_func(void *context, void *data, int size);\n\n   You can configure it with these global variables:\n      int stbi_write_tga_with_rle;             // defaults to true; set to 0 to disable RLE\n      int stbi_write_png_compression_level;    // defaults to 8; set to higher for more compression\n      int stbi_write_force_png_filter;         // defaults to -1; set to 0..5 to force a filter mode\n\n\n   You can define STBI_WRITE_NO_STDIO to disable the file variant of these\n   functions, so the library will not use stdio.h at all. However, this will\n   also disable HDR writing, because it requires stdio for formatted output.\n\n   Each function returns 0 on failure and non-0 on success.\n\n   The functions create an image file defined by the parameters. The image\n   is a rectangle of pixels stored from left-to-right, top-to-bottom.\n   Each pixel contains 'comp' channels of data stored interleaved with 8-bits\n   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is\n   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.\n   The *data pointer points to the first byte of the top-left-most pixel.\n   For PNG, \"stride_in_bytes\" is the distance in bytes from the first byte of\n   a row of pixels to the first byte of the next row of pixels.\n\n   PNG creates output files with the same number of components as the input.\n   The BMP format expands Y to RGB in the file format and does not\n   output alpha.\n\n   PNG supports writing rectangles of data even when the bytes storing rows of\n   data are not consecutive in memory (e.g. sub-rectangles of a larger image),\n   by supplying the stride between the beginning of adjacent rows. The other\n   formats do not. (Thus you cannot write a native-format BMP through the BMP\n   writer, both because it is in BGR order and because it may have padding\n   at the end of the line.)\n\n   PNG allows you to set the deflate compression level by setting the global\n   variable 'stbi_write_png_compression_level' (it defaults to 8).\n\n   HDR expects linear float data. Since the format is always 32-bit rgb(e)\n   data, alpha (if provided) is discarded, and for monochrome data it is\n   replicated across all three channels.\n\n   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed\n   data, set the global variable 'stbi_write_tga_with_rle' to 0.\n\n   JPEG does ignore alpha channels in input data; quality is between 1 and 100.\n   Higher quality looks better but results in a bigger image.\n   JPEG baseline (no JPEG progressive).\n\nCREDITS:\n\n\n   Sean Barrett           -    PNG/BMP/TGA\n   Baldur Karlsson        -    HDR\n   Jean-Sebastien Guay    -    TGA monochrome\n   Tim Kelsey             -    misc enhancements\n   Alan Hickman           -    TGA RLE\n   Emmanuel Julien        -    initial file IO callback implementation\n   Jon Olick              -    original jo_jpeg.cpp code\n   Daniel Gibson          -    integrate JPEG, allow external zlib\n   Aarni Koskela          -    allow choosing PNG filter\n\n   bugfixes:\n      github:Chribba\n      Guillaume Chereau\n      github:jry2\n      github:romigrou\n      Sergio Gonzalez\n      Jonas Karlsson\n      Filip Wasil\n      Thatcher Ulrich\n      github:poppolopoppo\n      Patrick Boettcher\n      github:xeekworx\n      Cap Petschulat\n      Simon Rodriguez\n      Ivan Tikhonov\n      github:ignotion\n      Adam Schackart\n      Andrew Kensler\n\nLICENSE\n\n  See end of file for license information.\n\n*/\n\n#ifndef INCLUDE_STB_IMAGE_WRITE_H\n#define INCLUDE_STB_IMAGE_WRITE_H\n\n#include <stdlib.h>\n\n// if STB_IMAGE_WRITE_STATIC causes problems, try defining STBIWDEF to 'inline' or 'static inline'\n#ifndef STBIWDEF\n#ifdef STB_IMAGE_WRITE_STATIC\n#define STBIWDEF  static\n#else\n#ifdef __cplusplus\n#define STBIWDEF  extern \"C\"\n#else\n#define STBIWDEF  extern\n#endif\n#endif\n#endif\n\n#ifndef STB_IMAGE_WRITE_STATIC  // C++ forbids static forward declarations\nSTBIWDEF int stbi_write_tga_with_rle;\nSTBIWDEF int stbi_write_png_compression_level;\nSTBIWDEF int stbi_write_force_png_filter;\n#endif\n\n#ifndef STBI_WRITE_NO_STDIO\nSTBIWDEF int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);\nSTBIWDEF int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);\nSTBIWDEF int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);\nSTBIWDEF int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\nSTBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void  *data, int quality);\n\n#ifdef STBIW_WINDOWS_UTF8\nSTBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);\n#endif\n#endif\n\ntypedef void stbi_write_func(void *context, void *data, int size);\n\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void  *data, int quality);\n\nSTBIWDEF void stbi_flip_vertically_on_write(int flip_boolean);\n\n#endif//INCLUDE_STB_IMAGE_WRITE_H\n\n#ifdef STB_IMAGE_WRITE_IMPLEMENTATION\n\n#ifdef _WIN32\n   #ifndef _CRT_SECURE_NO_WARNINGS\n   #define _CRT_SECURE_NO_WARNINGS\n   #endif\n   #ifndef _CRT_NONSTDC_NO_DEPRECATE\n   #define _CRT_NONSTDC_NO_DEPRECATE\n   #endif\n#endif\n\n#ifndef STBI_WRITE_NO_STDIO\n#include <stdio.h>\n#endif // STBI_WRITE_NO_STDIO\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))\n// ok\n#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)\n// ok\n#else\n#error \"Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED).\"\n#endif\n\n#ifndef STBIW_MALLOC\n#define STBIW_MALLOC(sz)        malloc(sz)\n#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)\n#define STBIW_FREE(p)           free(p)\n#endif\n\n#ifndef STBIW_REALLOC_SIZED\n#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)\n#endif\n\n\n#ifndef STBIW_MEMMOVE\n#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)\n#endif\n\n\n#ifndef STBIW_ASSERT\n#include <assert.h>\n#define STBIW_ASSERT(x) assert(x)\n#endif\n\n#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)\n\n#ifdef STB_IMAGE_WRITE_STATIC\nstatic int stbi_write_png_compression_level = 8;\nstatic int stbi_write_tga_with_rle = 1;\nstatic int stbi_write_force_png_filter = -1;\n#else\nint stbi_write_png_compression_level = 8;\nint stbi_write_tga_with_rle = 1;\nint stbi_write_force_png_filter = -1;\n#endif\n\nstatic int stbi__flip_vertically_on_write = 0;\n\nSTBIWDEF void stbi_flip_vertically_on_write(int flag)\n{\n   stbi__flip_vertically_on_write = flag;\n}\n\ntypedef struct\n{\n   stbi_write_func *func;\n   void *context;\n   unsigned char buffer[64];\n   int buf_used;\n} stbi__write_context;\n\n// initialize a callback-based context\nstatic void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)\n{\n   s->func    = c;\n   s->context = context;\n}\n\n#ifndef STBI_WRITE_NO_STDIO\n\nstatic void stbi__stdio_write(void *context, void *data, int size)\n{\n   fwrite(data,1,size,(FILE*) context);\n}\n\n#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)\n#ifdef __cplusplus\n#define STBIW_EXTERN extern \"C\"\n#else\n#define STBIW_EXTERN extern\n#endif\nSTBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);\nSTBIW_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);\n\nSTBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)\n{\n   return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);\n}\n#endif\n\nstatic FILE *stbiw__fopen(char const *filename, char const *mode)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)\n   wchar_t wMode[64];\n   wchar_t wFilename[1024];\n   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))\n      return 0;\n\n   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))\n      return 0;\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != _wfopen_s(&f, wFilename, wMode))\n      f = 0;\n#else\n   f = _wfopen(wFilename, wMode);\n#endif\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != fopen_s(&f, filename, mode))\n      f=0;\n#else\n   f = fopen(filename, mode);\n#endif\n   return f;\n}\n\nstatic int stbi__start_write_file(stbi__write_context *s, const char *filename)\n{\n   FILE *f = stbiw__fopen(filename, \"wb\");\n   stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f);\n   return f != NULL;\n}\n\nstatic void stbi__end_write_file(stbi__write_context *s)\n{\n   fclose((FILE *)s->context);\n}\n\n#endif // !STBI_WRITE_NO_STDIO\n\ntypedef unsigned int stbiw_uint32;\ntypedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];\n\nstatic void stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)\n{\n   while (*fmt) {\n      switch (*fmt++) {\n         case ' ': break;\n         case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));\n                     s->func(s->context,&x,1);\n                     break; }\n         case '2': { int x = va_arg(v,int);\n                     unsigned char b[2];\n                     b[0] = STBIW_UCHAR(x);\n                     b[1] = STBIW_UCHAR(x>>8);\n                     s->func(s->context,b,2);\n                     break; }\n         case '4': { stbiw_uint32 x = va_arg(v,int);\n                     unsigned char b[4];\n                     b[0]=STBIW_UCHAR(x);\n                     b[1]=STBIW_UCHAR(x>>8);\n                     b[2]=STBIW_UCHAR(x>>16);\n                     b[3]=STBIW_UCHAR(x>>24);\n                     s->func(s->context,b,4);\n                     break; }\n         default:\n            STBIW_ASSERT(0);\n            return;\n      }\n   }\n}\n\nstatic void stbiw__writef(stbi__write_context *s, const char *fmt, ...)\n{\n   va_list v;\n   va_start(v, fmt);\n   stbiw__writefv(s, fmt, v);\n   va_end(v);\n}\n\nstatic void stbiw__write_flush(stbi__write_context *s)\n{\n   if (s->buf_used) {\n      s->func(s->context, &s->buffer, s->buf_used);\n      s->buf_used = 0;\n   }\n}\n\nstatic void stbiw__putc(stbi__write_context *s, unsigned char c)\n{\n   s->func(s->context, &c, 1);\n}\n\nstatic void stbiw__write1(stbi__write_context *s, unsigned char a)\n{\n   if ((size_t)s->buf_used + 1 > sizeof(s->buffer))\n      stbiw__write_flush(s);\n   s->buffer[s->buf_used++] = a;\n}\n\nstatic void stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)\n{\n   int n;\n   if ((size_t)s->buf_used + 3 > sizeof(s->buffer))\n      stbiw__write_flush(s);\n   n = s->buf_used;\n   s->buf_used = n+3;\n   s->buffer[n+0] = a;\n   s->buffer[n+1] = b;\n   s->buffer[n+2] = c;\n}\n\nstatic void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)\n{\n   unsigned char bg[3] = { 255, 0, 255}, px[3];\n   int k;\n\n   if (write_alpha < 0)\n      stbiw__write1(s, d[comp - 1]);\n\n   switch (comp) {\n      case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case\n      case 1:\n         if (expand_mono)\n            stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp\n         else\n            stbiw__write1(s, d[0]);  // monochrome TGA\n         break;\n      case 4:\n         if (!write_alpha) {\n            // composite against pink background\n            for (k = 0; k < 3; ++k)\n               px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;\n            stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);\n            break;\n         }\n         /* FALLTHROUGH */\n      case 3:\n         stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);\n         break;\n   }\n   if (write_alpha > 0)\n      stbiw__write1(s, d[comp - 1]);\n}\n\nstatic void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)\n{\n   stbiw_uint32 zero = 0;\n   int i,j, j_end;\n\n   if (y <= 0)\n      return;\n\n   if (stbi__flip_vertically_on_write)\n      vdir *= -1;\n\n   if (vdir < 0) {\n      j_end = -1; j = y-1;\n   } else {\n      j_end =  y; j = 0;\n   }\n\n   for (; j != j_end; j += vdir) {\n      for (i=0; i < x; ++i) {\n         unsigned char *d = (unsigned char *) data + (j*x+i)*comp;\n         stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);\n      }\n      stbiw__write_flush(s);\n      s->func(s->context, &zero, scanline_pad);\n   }\n}\n\nstatic int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)\n{\n   if (y < 0 || x < 0) {\n      return 0;\n   } else {\n      va_list v;\n      va_start(v, fmt);\n      stbiw__writefv(s, fmt, v);\n      va_end(v);\n      stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);\n      return 1;\n   }\n}\n\nstatic int stbi_write_bmp_core(stbi__write_context *s, int x, int y, int comp, const void *data)\n{\n   if (comp != 4) {\n      // write RGB bitmap\n      int pad = (-x*3) & 3;\n      return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *) data,0,pad,\n              \"11 4 22 4\" \"4 44 22 444444\",\n              'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header\n               40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header\n   } else {\n      // RGBA bitmaps need a v4 header\n      // use BI_BITFIELDS mode with 32bpp and alpha mask\n      // (straight BI_RGB with alpha mask doesn't work in most readers)\n      return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *)data,1,0,\n         \"11 4 22 4\" \"4 44 22 444444 4444 4 444 444 444 444\",\n         'B', 'M', 14+108+x*y*4, 0, 0, 14+108, // file header\n         108, x,y, 1,32, 3,0,0,0,0,0, 0xff0000,0xff00,0xff,0xff000000u, 0, 0,0,0, 0,0,0, 0,0,0, 0,0,0); // bitmap V4 header\n   }\n}\n\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)\n{\n   stbi__write_context s = { 0 };\n   stbi__start_write_callbacks(&s, func, context);\n   return stbi_write_bmp_core(&s, x, y, comp, data);\n}\n\n#ifndef STBI_WRITE_NO_STDIO\nSTBIWDEF int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)\n{\n   stbi__write_context s = { 0 };\n   if (stbi__start_write_file(&s,filename)) {\n      int r = stbi_write_bmp_core(&s, x, y, comp, data);\n      stbi__end_write_file(&s);\n      return r;\n   } else\n      return 0;\n}\n#endif //!STBI_WRITE_NO_STDIO\n\nstatic int stbi_write_tga_core(stbi__write_context *s, int x, int y, int comp, void *data)\n{\n   int has_alpha = (comp == 2 || comp == 4);\n   int colorbytes = has_alpha ? comp-1 : comp;\n   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3\n\n   if (y < 0 || x < 0)\n      return 0;\n\n   if (!stbi_write_tga_with_rle) {\n      return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,\n         \"111 221 2222 11\", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);\n   } else {\n      int i,j,k;\n      int jend, jdir;\n\n      stbiw__writef(s, \"111 221 2222 11\", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);\n\n      if (stbi__flip_vertically_on_write) {\n         j = 0;\n         jend = y;\n         jdir = 1;\n      } else {\n         j = y-1;\n         jend = -1;\n         jdir = -1;\n      }\n      for (; j != jend; j += jdir) {\n         unsigned char *row = (unsigned char *) data + j * x * comp;\n         int len;\n\n         for (i = 0; i < x; i += len) {\n            unsigned char *begin = row + i * comp;\n            int diff = 1;\n            len = 1;\n\n            if (i < x - 1) {\n               ++len;\n               diff = memcmp(begin, row + (i + 1) * comp, comp);\n               if (diff) {\n                  const unsigned char *prev = begin;\n                  for (k = i + 2; k < x && len < 128; ++k) {\n                     if (memcmp(prev, row + k * comp, comp)) {\n                        prev += comp;\n                        ++len;\n                     } else {\n                        --len;\n                        break;\n                     }\n                  }\n               } else {\n                  for (k = i + 2; k < x && len < 128; ++k) {\n                     if (!memcmp(begin, row + k * comp, comp)) {\n                        ++len;\n                     } else {\n                        break;\n                     }\n                  }\n               }\n            }\n\n            if (diff) {\n               unsigned char header = STBIW_UCHAR(len - 1);\n               stbiw__write1(s, header);\n               for (k = 0; k < len; ++k) {\n                  stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);\n               }\n            } else {\n               unsigned char header = STBIW_UCHAR(len - 129);\n               stbiw__write1(s, header);\n               stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);\n            }\n         }\n      }\n      stbiw__write_flush(s);\n   }\n   return 1;\n}\n\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)\n{\n   stbi__write_context s = { 0 };\n   stbi__start_write_callbacks(&s, func, context);\n   return stbi_write_tga_core(&s, x, y, comp, (void *) data);\n}\n\n#ifndef STBI_WRITE_NO_STDIO\nSTBIWDEF int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)\n{\n   stbi__write_context s = { 0 };\n   if (stbi__start_write_file(&s,filename)) {\n      int r = stbi_write_tga_core(&s, x, y, comp, (void *) data);\n      stbi__end_write_file(&s);\n      return r;\n   } else\n      return 0;\n}\n#endif\n\n// *************************************************************************************************\n// Radiance RGBE HDR writer\n// by Baldur Karlsson\n\n#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))\n\n#ifndef STBI_WRITE_NO_STDIO\n\nstatic void stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)\n{\n   int exponent;\n   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));\n\n   if (maxcomp < 1e-32f) {\n      rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;\n   } else {\n      float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;\n\n      rgbe[0] = (unsigned char)(linear[0] * normalize);\n      rgbe[1] = (unsigned char)(linear[1] * normalize);\n      rgbe[2] = (unsigned char)(linear[2] * normalize);\n      rgbe[3] = (unsigned char)(exponent + 128);\n   }\n}\n\nstatic void stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)\n{\n   unsigned char lengthbyte = STBIW_UCHAR(length+128);\n   STBIW_ASSERT(length+128 <= 255);\n   s->func(s->context, &lengthbyte, 1);\n   s->func(s->context, &databyte, 1);\n}\n\nstatic void stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)\n{\n   unsigned char lengthbyte = STBIW_UCHAR(length);\n   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code\n   s->func(s->context, &lengthbyte, 1);\n   s->func(s->context, data, length);\n}\n\nstatic void stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)\n{\n   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };\n   unsigned char rgbe[4];\n   float linear[3];\n   int x;\n\n   scanlineheader[2] = (width&0xff00)>>8;\n   scanlineheader[3] = (width&0x00ff);\n\n   /* skip RLE for images too small or large */\n   if (width < 8 || width >= 32768) {\n      for (x=0; x < width; x++) {\n         switch (ncomp) {\n            case 4: /* fallthrough */\n            case 3: linear[2] = scanline[x*ncomp + 2];\n                    linear[1] = scanline[x*ncomp + 1];\n                    linear[0] = scanline[x*ncomp + 0];\n                    break;\n            default:\n                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];\n                    break;\n         }\n         stbiw__linear_to_rgbe(rgbe, linear);\n         s->func(s->context, rgbe, 4);\n      }\n   } else {\n      int c,r;\n      /* encode into scratch buffer */\n      for (x=0; x < width; x++) {\n         switch(ncomp) {\n            case 4: /* fallthrough */\n            case 3: linear[2] = scanline[x*ncomp + 2];\n                    linear[1] = scanline[x*ncomp + 1];\n                    linear[0] = scanline[x*ncomp + 0];\n                    break;\n            default:\n                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];\n                    break;\n         }\n         stbiw__linear_to_rgbe(rgbe, linear);\n         scratch[x + width*0] = rgbe[0];\n         scratch[x + width*1] = rgbe[1];\n         scratch[x + width*2] = rgbe[2];\n         scratch[x + width*3] = rgbe[3];\n      }\n\n      s->func(s->context, scanlineheader, 4);\n\n      /* RLE each component separately */\n      for (c=0; c < 4; c++) {\n         unsigned char *comp = &scratch[width*c];\n\n         x = 0;\n         while (x < width) {\n            // find first run\n            r = x;\n            while (r+2 < width) {\n               if (comp[r] == comp[r+1] && comp[r] == comp[r+2])\n                  break;\n               ++r;\n            }\n            if (r+2 >= width)\n               r = width;\n            // dump up to first run\n            while (x < r) {\n               int len = r-x;\n               if (len > 128) len = 128;\n               stbiw__write_dump_data(s, len, &comp[x]);\n               x += len;\n            }\n            // if there's a run, output it\n            if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd\n               // find next byte after run\n               while (r < width && comp[r] == comp[x])\n                  ++r;\n               // output run up to r\n               while (x < r) {\n                  int len = r-x;\n                  if (len > 127) len = 127;\n                  stbiw__write_run_data(s, len, comp[x]);\n                  x += len;\n               }\n            }\n         }\n      }\n   }\n}\n\nstatic int stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)\n{\n   if (y <= 0 || x <= 0 || data == NULL)\n      return 0;\n   else {\n      // Each component is stored separately. Allocate scratch space for full output scanline.\n      unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);\n      int i, len;\n      char buffer[128];\n      char header[] = \"#?RADIANCE\\n# Written by stb_image_write.h\\nFORMAT=32-bit_rle_rgbe\\n\";\n      s->func(s->context, header, sizeof(header)-1);\n\n#ifdef __STDC_LIB_EXT1__\n      len = sprintf_s(buffer, sizeof(buffer), \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x);\n#else\n      len = sprintf(buffer, \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x);\n#endif\n      s->func(s->context, buffer, len);\n\n      for(i=0; i < y; i++)\n         stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*x*(stbi__flip_vertically_on_write ? y-1-i : i));\n      STBIW_FREE(scratch);\n      return 1;\n   }\n}\n\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const float *data)\n{\n   stbi__write_context s = { 0 };\n   stbi__start_write_callbacks(&s, func, context);\n   return stbi_write_hdr_core(&s, x, y, comp, (float *) data);\n}\n\nSTBIWDEF int stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)\n{\n   stbi__write_context s = { 0 };\n   if (stbi__start_write_file(&s,filename)) {\n      int r = stbi_write_hdr_core(&s, x, y, comp, (float *) data);\n      stbi__end_write_file(&s);\n      return r;\n   } else\n      return 0;\n}\n#endif // STBI_WRITE_NO_STDIO\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PNG writer\n//\n\n#ifndef STBIW_ZLIB_COMPRESS\n// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()\n#define stbiw__sbraw(a) ((int *) (void *) (a) - 2)\n#define stbiw__sbm(a)   stbiw__sbraw(a)[0]\n#define stbiw__sbn(a)   stbiw__sbraw(a)[1]\n\n#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))\n#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)\n#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))\n\n#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))\n#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)\n#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)\n\nstatic void *stbiw__sbgrowf(void **arr, int increment, int itemsize)\n{\n   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;\n   void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);\n   STBIW_ASSERT(p);\n   if (p) {\n      if (!*arr) ((int *) p)[1] = 0;\n      *arr = (void *) ((int *) p + 2);\n      stbiw__sbm(*arr) = m;\n   }\n   return *arr;\n}\n\nstatic unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)\n{\n   while (*bitcount >= 8) {\n      stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));\n      *bitbuffer >>= 8;\n      *bitcount -= 8;\n   }\n   return data;\n}\n\nstatic int stbiw__zlib_bitrev(int code, int codebits)\n{\n   int res=0;\n   while (codebits--) {\n      res = (res << 1) | (code & 1);\n      code >>= 1;\n   }\n   return res;\n}\n\nstatic unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)\n{\n   int i;\n   for (i=0; i < limit && i < 258; ++i)\n      if (a[i] != b[i]) break;\n   return i;\n}\n\nstatic unsigned int stbiw__zhash(unsigned char *data)\n{\n   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);\n   hash ^= hash << 3;\n   hash += hash >> 5;\n   hash ^= hash << 4;\n   hash += hash >> 17;\n   hash ^= hash << 25;\n   hash += hash >> 6;\n   return hash;\n}\n\n#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))\n#define stbiw__zlib_add(code,codebits) \\\n      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())\n#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)\n// default huffman tables\n#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)\n#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)\n#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)\n#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)\n#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))\n#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))\n\n#define stbiw__ZHASH   16384\n\n#endif // STBIW_ZLIB_COMPRESS\n\nSTBIWDEF unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)\n{\n#ifdef STBIW_ZLIB_COMPRESS\n   // user provided a zlib compress implementation, use that\n   return STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality);\n#else // use builtin\n   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };\n   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };\n   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };\n   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };\n   unsigned int bitbuf=0;\n   int i,j, bitcount=0;\n   unsigned char *out = NULL;\n   unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**));\n   if (hash_table == NULL)\n      return NULL;\n   if (quality < 5) quality = 5;\n\n   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window\n   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1\n   stbiw__zlib_add(1,1);  // BFINAL = 1\n   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman\n\n   for (i=0; i < stbiw__ZHASH; ++i)\n      hash_table[i] = NULL;\n\n   i=0;\n   while (i < data_len-3) {\n      // hash next 3 bytes of data to be compressed\n      int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;\n      unsigned char *bestloc = 0;\n      unsigned char **hlist = hash_table[h];\n      int n = stbiw__sbcount(hlist);\n      for (j=0; j < n; ++j) {\n         if (hlist[j]-data > i-32768) { // if entry lies within window\n            int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);\n            if (d >= best) { best=d; bestloc=hlist[j]; }\n         }\n      }\n      // when hash table entry is too long, delete half the entries\n      if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {\n         STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);\n         stbiw__sbn(hash_table[h]) = quality;\n      }\n      stbiw__sbpush(hash_table[h],data+i);\n\n      if (bestloc) {\n         // \"lazy matching\" - check match at *next* byte, and if it's better, do cur byte as literal\n         h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);\n         hlist = hash_table[h];\n         n = stbiw__sbcount(hlist);\n         for (j=0; j < n; ++j) {\n            if (hlist[j]-data > i-32767) {\n               int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);\n               if (e > best) { // if next match is better, bail on current match\n                  bestloc = NULL;\n                  break;\n               }\n            }\n         }\n      }\n\n      if (bestloc) {\n         int d = (int) (data+i - bestloc); // distance back\n         STBIW_ASSERT(d <= 32767 && best <= 258);\n         for (j=0; best > lengthc[j+1]-1; ++j);\n         stbiw__zlib_huff(j+257);\n         if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);\n         for (j=0; d > distc[j+1]-1; ++j);\n         stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);\n         if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);\n         i += best;\n      } else {\n         stbiw__zlib_huffb(data[i]);\n         ++i;\n      }\n   }\n   // write out final bytes\n   for (;i < data_len; ++i)\n      stbiw__zlib_huffb(data[i]);\n   stbiw__zlib_huff(256); // end of block\n   // pad with 0 bits to byte boundary\n   while (bitcount)\n      stbiw__zlib_add(0,1);\n\n   for (i=0; i < stbiw__ZHASH; ++i)\n      (void) stbiw__sbfree(hash_table[i]);\n   STBIW_FREE(hash_table);\n\n   // store uncompressed instead if compression was worse\n   if (stbiw__sbn(out) > data_len + 2 + ((data_len+32766)/32767)*5) {\n      stbiw__sbn(out) = 2;  // truncate to DEFLATE 32K window and FLEVEL = 1\n      for (j = 0; j < data_len;) {\n         int blocklen = data_len - j;\n         if (blocklen > 32767) blocklen = 32767;\n         stbiw__sbpush(out, data_len - j == blocklen); // BFINAL = ?, BTYPE = 0 -- no compression\n         stbiw__sbpush(out, STBIW_UCHAR(blocklen)); // LEN\n         stbiw__sbpush(out, STBIW_UCHAR(blocklen >> 8));\n         stbiw__sbpush(out, STBIW_UCHAR(~blocklen)); // NLEN\n         stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));\n         memcpy(out+stbiw__sbn(out), data+j, blocklen);\n         stbiw__sbn(out) += blocklen;\n         j += blocklen;\n      }\n   }\n\n   {\n      // compute adler32 on input\n      unsigned int s1=1, s2=0;\n      int blocklen = (int) (data_len % 5552);\n      j=0;\n      while (j < data_len) {\n         for (i=0; i < blocklen; ++i) { s1 += data[j+i]; s2 += s1; }\n         s1 %= 65521; s2 %= 65521;\n         j += blocklen;\n         blocklen = 5552;\n      }\n      stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));\n      stbiw__sbpush(out, STBIW_UCHAR(s2));\n      stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));\n      stbiw__sbpush(out, STBIW_UCHAR(s1));\n   }\n   *out_len = stbiw__sbn(out);\n   // make returned pointer freeable\n   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);\n   return (unsigned char *) stbiw__sbraw(out);\n#endif // STBIW_ZLIB_COMPRESS\n}\n\nstatic unsigned int stbiw__crc32(unsigned char *buffer, int len)\n{\n#ifdef STBIW_CRC32\n    return STBIW_CRC32(buffer, len);\n#else\n   static unsigned int crc_table[256] =\n   {\n      0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n      0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n      0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n      0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n      0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n      0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n      0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n      0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n      0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n      0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n      0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n      0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n      0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n      0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n      0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n      0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n      0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n      0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n      0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n      0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n      0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n      0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n      0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n      0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n      0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n      0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n      0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n      0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n      0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n      0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n      0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n      0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n   };\n\n   unsigned int crc = ~0u;\n   int i;\n   for (i=0; i < len; ++i)\n      crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];\n   return ~crc;\n#endif\n}\n\n#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)\n#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));\n#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])\n\nstatic void stbiw__wpcrc(unsigned char **data, int len)\n{\n   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);\n   stbiw__wp32(*data, crc);\n}\n\nstatic unsigned char stbiw__paeth(int a, int b, int c)\n{\n   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);\n   if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);\n   if (pb <= pc) return STBIW_UCHAR(b);\n   return STBIW_UCHAR(c);\n}\n\n// @OPTIMIZE: provide an option that always forces left-predict or paeth predict\nstatic void stbiw__encode_png_line(unsigned char *pixels, int stride_bytes, int width, int height, int y, int n, int filter_type, signed char *line_buffer)\n{\n   static int mapping[] = { 0,1,2,3,4 };\n   static int firstmap[] = { 0,1,0,5,6 };\n   int *mymap = (y != 0) ? mapping : firstmap;\n   int i;\n   int type = mymap[filter_type];\n   unsigned char *z = pixels + stride_bytes * (stbi__flip_vertically_on_write ? height-1-y : y);\n   int signed_stride = stbi__flip_vertically_on_write ? -stride_bytes : stride_bytes;\n\n   if (type==0) {\n      memcpy(line_buffer, z, width*n);\n      return;\n   }\n\n   // first loop isn't optimized since it's just one pixel\n   for (i = 0; i < n; ++i) {\n      switch (type) {\n         case 1: line_buffer[i] = z[i]; break;\n         case 2: line_buffer[i] = z[i] - z[i-signed_stride]; break;\n         case 3: line_buffer[i] = z[i] - (z[i-signed_stride]>>1); break;\n         case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-signed_stride],0)); break;\n         case 5: line_buffer[i] = z[i]; break;\n         case 6: line_buffer[i] = z[i]; break;\n      }\n   }\n   switch (type) {\n      case 1: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-n]; break;\n      case 2: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-signed_stride]; break;\n      case 3: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - ((z[i-n] + z[i-signed_stride])>>1); break;\n      case 4: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-signed_stride], z[i-signed_stride-n]); break;\n      case 5: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - (z[i-n]>>1); break;\n      case 6: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;\n   }\n}\n\nSTBIWDEF unsigned char *stbi_write_png_to_mem(const unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)\n{\n   int force_filter = stbi_write_force_png_filter;\n   int ctype[5] = { -1, 0, 4, 2, 6 };\n   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };\n   unsigned char *out,*o, *filt, *zlib;\n   signed char *line_buffer;\n   int j,zlen;\n\n   if (stride_bytes == 0)\n      stride_bytes = x * n;\n\n   if (force_filter >= 5) {\n      force_filter = -1;\n   }\n\n   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;\n   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }\n   for (j=0; j < y; ++j) {\n      int filter_type;\n      if (force_filter > -1) {\n         filter_type = force_filter;\n         stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer);\n      } else { // Estimate the best filter by running through all of them:\n         int best_filter = 0, best_filter_val = 0x7fffffff, est, i;\n         for (filter_type = 0; filter_type < 5; filter_type++) {\n            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);\n\n            // Estimate the entropy of the line using this filter; the less, the better.\n            est = 0;\n            for (i = 0; i < x*n; ++i) {\n               est += abs((signed char) line_buffer[i]);\n            }\n            if (est < best_filter_val) {\n               best_filter_val = est;\n               best_filter = filter_type;\n            }\n         }\n         if (filter_type != best_filter) {  // If the last iteration already got us the best filter, don't redo it\n            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer);\n            filter_type = best_filter;\n         }\n      }\n      // when we get here, filter_type contains the filter type, and line_buffer contains the data\n      filt[j*(x*n+1)] = (unsigned char) filter_type;\n      STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);\n   }\n   STBIW_FREE(line_buffer);\n   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, stbi_write_png_compression_level);\n   STBIW_FREE(filt);\n   if (!zlib) return 0;\n\n   // each tag requires 12 bytes of overhead\n   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);\n   if (!out) return 0;\n   *out_len = 8 + 12+13 + 12+zlen + 12;\n\n   o=out;\n   STBIW_MEMMOVE(o,sig,8); o+= 8;\n   stbiw__wp32(o, 13); // header length\n   stbiw__wptag(o, \"IHDR\");\n   stbiw__wp32(o, x);\n   stbiw__wp32(o, y);\n   *o++ = 8;\n   *o++ = STBIW_UCHAR(ctype[n]);\n   *o++ = 0;\n   *o++ = 0;\n   *o++ = 0;\n   stbiw__wpcrc(&o,13);\n\n   stbiw__wp32(o, zlen);\n   stbiw__wptag(o, \"IDAT\");\n   STBIW_MEMMOVE(o, zlib, zlen);\n   o += zlen;\n   STBIW_FREE(zlib);\n   stbiw__wpcrc(&o, zlen);\n\n   stbiw__wp32(o,0);\n   stbiw__wptag(o, \"IEND\");\n   stbiw__wpcrc(&o,0);\n\n   STBIW_ASSERT(o == out + *out_len);\n\n   return out;\n}\n\n#ifndef STBI_WRITE_NO_STDIO\nSTBIWDEF int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)\n{\n   FILE *f;\n   int len;\n   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);\n   if (png == NULL) return 0;\n\n   f = stbiw__fopen(filename, \"wb\");\n   if (!f) { STBIW_FREE(png); return 0; }\n   fwrite(png, 1, len, f);\n   fclose(f);\n   STBIW_FREE(png);\n   return 1;\n}\n#endif\n\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int stride_bytes)\n{\n   int len;\n   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);\n   if (png == NULL) return 0;\n   func(context, png, len);\n   STBIW_FREE(png);\n   return 1;\n}\n\n\n/* ***************************************************************************\n *\n * JPEG writer\n *\n * This is based on Jon Olick's jo_jpeg.cpp:\n * public domain Simple, Minimalistic JPEG writer - http://www.jonolick.com/code.html\n */\n\nstatic const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,\n      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };\n\nstatic void stbiw__jpg_writeBits(stbi__write_context *s, int *bitBufP, int *bitCntP, const unsigned short *bs) {\n   int bitBuf = *bitBufP, bitCnt = *bitCntP;\n   bitCnt += bs[1];\n   bitBuf |= bs[0] << (24 - bitCnt);\n   while(bitCnt >= 8) {\n      unsigned char c = (bitBuf >> 16) & 255;\n      stbiw__putc(s, c);\n      if(c == 255) {\n         stbiw__putc(s, 0);\n      }\n      bitBuf <<= 8;\n      bitCnt -= 8;\n   }\n   *bitBufP = bitBuf;\n   *bitCntP = bitCnt;\n}\n\nstatic void stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p) {\n   float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;\n   float z1, z2, z3, z4, z5, z11, z13;\n\n   float tmp0 = d0 + d7;\n   float tmp7 = d0 - d7;\n   float tmp1 = d1 + d6;\n   float tmp6 = d1 - d6;\n   float tmp2 = d2 + d5;\n   float tmp5 = d2 - d5;\n   float tmp3 = d3 + d4;\n   float tmp4 = d3 - d4;\n\n   // Even part\n   float tmp10 = tmp0 + tmp3;   // phase 2\n   float tmp13 = tmp0 - tmp3;\n   float tmp11 = tmp1 + tmp2;\n   float tmp12 = tmp1 - tmp2;\n\n   d0 = tmp10 + tmp11;       // phase 3\n   d4 = tmp10 - tmp11;\n\n   z1 = (tmp12 + tmp13) * 0.707106781f; // c4\n   d2 = tmp13 + z1;       // phase 5\n   d6 = tmp13 - z1;\n\n   // Odd part\n   tmp10 = tmp4 + tmp5;       // phase 2\n   tmp11 = tmp5 + tmp6;\n   tmp12 = tmp6 + tmp7;\n\n   // The rotator is modified from fig 4-8 to avoid extra negations.\n   z5 = (tmp10 - tmp12) * 0.382683433f; // c6\n   z2 = tmp10 * 0.541196100f + z5; // c2-c6\n   z4 = tmp12 * 1.306562965f + z5; // c2+c6\n   z3 = tmp11 * 0.707106781f; // c4\n\n   z11 = tmp7 + z3;      // phase 5\n   z13 = tmp7 - z3;\n\n   *d5p = z13 + z2;         // phase 6\n   *d3p = z13 - z2;\n   *d1p = z11 + z4;\n   *d7p = z11 - z4;\n\n   *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;\n}\n\nstatic void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {\n   int tmp1 = val < 0 ? -val : val;\n   val = val < 0 ? val-1 : val;\n   bits[1] = 1;\n   while(tmp1 >>= 1) {\n      ++bits[1];\n   }\n   bits[0] = val & ((1<<bits[1])-1);\n}\n\nstatic int stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, int du_stride, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {\n   const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };\n   const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };\n   int dataOff, i, j, n, diff, end0pos, x, y;\n   int DU[64];\n\n   // DCT rows\n   for(dataOff=0, n=du_stride*8; dataOff<n; dataOff+=du_stride) {\n      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);\n   }\n   // DCT columns\n   for(dataOff=0; dataOff<8; ++dataOff) {\n      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],\n                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);\n   }\n   // Quantize/descale/zigzag the coefficients\n   for(y = 0, j=0; y < 8; ++y) {\n      for(x = 0; x < 8; ++x,++j) {\n         float v;\n         i = y*du_stride+x;\n         v = CDU[i]*fdtbl[j];\n         // DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));\n         // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?\n         DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);\n      }\n   }\n\n   // Encode DC\n   diff = DU[0] - DC;\n   if (diff == 0) {\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);\n   } else {\n      unsigned short bits[2];\n      stbiw__jpg_calcBits(diff, bits);\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\n   }\n   // Encode ACs\n   end0pos = 63;\n   for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {\n   }\n   // end0pos = first element in reverse order !=0\n   if(end0pos == 0) {\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\n      return DU[0];\n   }\n   for(i = 1; i <= end0pos; ++i) {\n      int startpos = i;\n      int nrzeroes;\n      unsigned short bits[2];\n      for (; DU[i]==0 && i<=end0pos; ++i) {\n      }\n      nrzeroes = i-startpos;\n      if ( nrzeroes >= 16 ) {\n         int lng = nrzeroes>>4;\n         int nrmarker;\n         for (nrmarker=1; nrmarker <= lng; ++nrmarker)\n            stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);\n         nrzeroes &= 15;\n      }\n      stbiw__jpg_calcBits(DU[i], bits);\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\n   }\n   if(end0pos != 63) {\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\n   }\n   return DU[0];\n}\n\nstatic int stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality) {\n   // Constants that don't pollute global namespace\n   static const unsigned char std_dc_luminance_nrcodes[] = {0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0};\n   static const unsigned char std_dc_luminance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};\n   static const unsigned char std_ac_luminance_nrcodes[] = {0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d};\n   static const unsigned char std_ac_luminance_values[] = {\n      0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\n      0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\n      0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\n      0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\n      0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\n      0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\n      0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\n   };\n   static const unsigned char std_dc_chrominance_nrcodes[] = {0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0};\n   static const unsigned char std_dc_chrominance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};\n   static const unsigned char std_ac_chrominance_nrcodes[] = {0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77};\n   static const unsigned char std_ac_chrominance_values[] = {\n      0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\n      0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\n      0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\n      0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\n      0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\n      0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\n      0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\n   };\n   // Huffman tables\n   static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9}};\n   static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11}};\n   static const unsigned short YAC_HT[256][2] = {\n      {10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\n   };\n   static const unsigned short UVAC_HT[256][2] = {\n      {0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},\n      {1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\n   };\n   static const int YQT[] = {16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,\n                             37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99};\n   static const int UVQT[] = {17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,\n                              99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};\n   static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f,\n                                 1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };\n\n   int row, col, i, k, subsample;\n   float fdtbl_Y[64], fdtbl_UV[64];\n   unsigned char YTable[64], UVTable[64];\n\n   if(!data || !width || !height || comp > 4 || comp < 1) {\n      return 0;\n   }\n\n   quality = quality ? quality : 90;\n   subsample = quality <= 90 ? 1 : 0;\n   quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;\n   quality = quality < 50 ? 5000 / quality : 200 - quality * 2;\n\n   for(i = 0; i < 64; ++i) {\n      int uvti, yti = (YQT[i]*quality+50)/100;\n      YTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti);\n      uvti = (UVQT[i]*quality+50)/100;\n      UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);\n   }\n\n   for(row = 0, k = 0; row < 8; ++row) {\n      for(col = 0; col < 8; ++col, ++k) {\n         fdtbl_Y[k]  = 1 / (YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\n         fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\n      }\n   }\n\n   // Write Headers\n   {\n      static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };\n      static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };\n      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),\n                                      3,1,(unsigned char)(subsample?0x22:0x11),0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };\n      s->func(s->context, (void*)head0, sizeof(head0));\n      s->func(s->context, (void*)YTable, sizeof(YTable));\n      stbiw__putc(s, 1);\n      s->func(s->context, UVTable, sizeof(UVTable));\n      s->func(s->context, (void*)head1, sizeof(head1));\n      s->func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1);\n      s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));\n      stbiw__putc(s, 0x10); // HTYACinfo\n      s->func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1);\n      s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));\n      stbiw__putc(s, 1); // HTUDCinfo\n      s->func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1);\n      s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));\n      stbiw__putc(s, 0x11); // HTUACinfo\n      s->func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1);\n      s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));\n      s->func(s->context, (void*)head2, sizeof(head2));\n   }\n\n   // Encode 8x8 macroblocks\n   {\n      static const unsigned short fillBits[] = {0x7F, 7};\n      int DCY=0, DCU=0, DCV=0;\n      int bitBuf=0, bitCnt=0;\n      // comp == 2 is grey+alpha (alpha is ignored)\n      int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;\n      const unsigned char *dataR = (const unsigned char *)data;\n      const unsigned char *dataG = dataR + ofsG;\n      const unsigned char *dataB = dataR + ofsB;\n      int x, y, pos;\n      if(subsample) {\n         for(y = 0; y < height; y += 16) {\n            for(x = 0; x < width; x += 16) {\n               float Y[256], U[256], V[256];\n               for(row = y, pos = 0; row < y+16; ++row) {\n                  // row >= height => use last input row\n                  int clamped_row = (row < height) ? row : height - 1;\n                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;\n                  for(col = x; col < x+16; ++col, ++pos) {\n                     // if col >= width => use pixel from last input column\n                     int p = base_p + ((col < width) ? col : (width-1))*comp;\n                     float r = dataR[p], g = dataG[p], b = dataB[p];\n                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;\n                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;\n                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;\n                  }\n               }\n               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+0,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+8,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+128, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+136, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n\n               // subsample U,V\n               {\n                  float subU[64], subV[64];\n                  int yy, xx;\n                  for(yy = 0, pos = 0; yy < 8; ++yy) {\n                     for(xx = 0; xx < 8; ++xx, ++pos) {\n                        int j = yy*32+xx*2;\n                        subU[pos] = (U[j+0] + U[j+1] + U[j+16] + U[j+17]) * 0.25f;\n                        subV[pos] = (V[j+0] + V[j+1] + V[j+16] + V[j+17]) * 0.25f;\n                     }\n                  }\n                  DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subU, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n                  DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subV, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n               }\n            }\n         }\n      } else {\n         for(y = 0; y < height; y += 8) {\n            for(x = 0; x < width; x += 8) {\n               float Y[64], U[64], V[64];\n               for(row = y, pos = 0; row < y+8; ++row) {\n                  // row >= height => use last input row\n                  int clamped_row = (row < height) ? row : height - 1;\n                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;\n                  for(col = x; col < x+8; ++col, ++pos) {\n                     // if col >= width => use pixel from last input column\n                     int p = base_p + ((col < width) ? col : (width-1))*comp;\n                     float r = dataR[p], g = dataG[p], b = dataB[p];\n                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;\n                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;\n                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;\n                  }\n               }\n\n               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y, 8, fdtbl_Y,  DCY, YDC_HT, YAC_HT);\n               DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, U, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n               DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, V, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n            }\n         }\n      }\n\n      // Do the bit alignment of the EOI marker\n      stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);\n   }\n\n   // EOI\n   stbiw__putc(s, 0xFF);\n   stbiw__putc(s, 0xD9);\n\n   return 1;\n}\n\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)\n{\n   stbi__write_context s = { 0 };\n   stbi__start_write_callbacks(&s, func, context);\n   return stbi_write_jpg_core(&s, x, y, comp, (void *) data, quality);\n}\n\n\n#ifndef STBI_WRITE_NO_STDIO\nSTBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void *data, int quality)\n{\n   stbi__write_context s = { 0 };\n   if (stbi__start_write_file(&s,filename)) {\n      int r = stbi_write_jpg_core(&s, x, y, comp, data, quality);\n      stbi__end_write_file(&s);\n      return r;\n   } else\n      return 0;\n}\n#endif\n\n#endif // STB_IMAGE_WRITE_IMPLEMENTATION\n\n/* Revision history\n      1.16  (2021-07-11)\n             make Deflate code emit uncompressed blocks when it would otherwise expand\n             support writing BMPs with alpha channel\n      1.15  (2020-07-13) unknown\n      1.14  (2020-02-02) updated JPEG writer to downsample chroma channels\n      1.13\n      1.12\n      1.11  (2019-08-11)\n\n      1.10  (2019-02-07)\n             support utf8 filenames in Windows; fix warnings and platform ifdefs\n      1.09  (2018-02-11)\n             fix typo in zlib quality API, improve STB_I_W_STATIC in C++\n      1.08  (2018-01-29)\n             add stbi__flip_vertically_on_write, external zlib, zlib quality, choose PNG filter\n      1.07  (2017-07-24)\n             doc fix\n      1.06 (2017-07-23)\n             writing JPEG (using Jon Olick's code)\n      1.05   ???\n      1.04 (2017-03-03)\n             monochrome BMP expansion\n      1.03   ???\n      1.02 (2016-04-02)\n             avoid allocating large structures on the stack\n      1.01 (2016-01-16)\n             STBIW_REALLOC_SIZED: support allocators with no realloc support\n             avoid race-condition in crc initialization\n             minor compile issues\n      1.00 (2015-09-14)\n             installable file IO function\n      0.99 (2015-09-13)\n             warning fixes; TGA rle support\n      0.98 (2015-04-08)\n             added STBIW_MALLOC, STBIW_ASSERT etc\n      0.97 (2015-01-18)\n             fixed HDR asserts, rewrote HDR rle logic\n      0.96 (2015-01-17)\n             add HDR output\n             fix monochrome BMP\n      0.95 (2014-08-17)\n             add monochrome TGA output\n      0.94 (2014-05-31)\n             rename private functions to avoid conflicts with stb_image.h\n      0.93 (2014-05-27)\n             warning fixes\n      0.92 (2010-08-01)\n             casts to unsigned char to fix warnings\n      0.91 (2010-07-17)\n             first public release\n      0.90   first internal release\n*/\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_include.h",
          "type": "blob",
          "size": 8.970703125,
          "content": "// stb_include.h - v0.02 - parse and process #include directives - public domain\n//\n// To build this, in one source file that includes this file do\n//      #define STB_INCLUDE_IMPLEMENTATION\n//\n// This program parses a string and replaces lines of the form\n//         #include \"foo\"\n// with the contents of a file named \"foo\". It also embeds the\n// appropriate #line directives. Note that all include files must\n// reside in the location specified in the path passed to the API;\n// it does not check multiple directories.\n//\n// If the string contains a line of the form\n//         #inject\n// then it will be replaced with the contents of the string 'inject' passed to the API.\n//\n// Options:\n//\n//      Define STB_INCLUDE_LINE_GLSL to get GLSL-style #line directives\n//      which use numbers instead of filenames.\n//\n//      Define STB_INCLUDE_LINE_NONE to disable output of #line directives.\n//\n// Standard libraries:\n//\n//      stdio.h     FILE, fopen, fclose, fseek, ftell\n//      stdlib.h    malloc, realloc, free\n//      string.h    strcpy, strncmp, memcpy\n//\n// Credits:\n//\n// Written by Sean Barrett.\n//\n// Fixes:\n//  Michal Klos\n\n#ifndef STB_INCLUDE_STB_INCLUDE_H\n#define STB_INCLUDE_STB_INCLUDE_H\n\n// Do include-processing on the string 'str'. To free the return value, pass it to free()\nchar *stb_include_string(char *str, char *inject, char *path_to_includes, char *filename_for_line_directive, char error[256]);\n\n// Concatenate the strings 'strs' and do include-processing on the result. To free the return value, pass it to free()\nchar *stb_include_strings(char **strs, int count, char *inject, char *path_to_includes, char *filename_for_line_directive, char error[256]);\n\n// Load the file 'filename' and do include-processing on the string therein. note that\n// 'filename' is opened directly; 'path_to_includes' is not used. To free the return value, pass it to free()\nchar *stb_include_file(char *filename, char *inject, char *path_to_includes, char error[256]);\n\n#endif\n\n\n#ifdef STB_INCLUDE_IMPLEMENTATION\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char *stb_include_load_file(char *filename, size_t *plen)\n{\n   char *text;\n   size_t len;\n   FILE *f = fopen(filename, \"rb\");\n   if (f == 0) return 0;\n   fseek(f, 0, SEEK_END);\n   len = (size_t) ftell(f);\n   if (plen) *plen = len;\n   text = (char *) malloc(len+1);\n   if (text == 0) return 0;\n   fseek(f, 0, SEEK_SET);\n   fread(text, 1, len, f);\n   fclose(f);\n   text[len] = 0;\n   return text;\n}\n\ntypedef struct\n{\n   int offset;\n   int end;\n   char *filename;\n   int next_line_after;\n} include_info;\n\nstatic include_info *stb_include_append_include(include_info *array, int len, int offset, int end, char *filename, int next_line)\n{\n   include_info *z = (include_info *) realloc(array, sizeof(*z) * (len+1));\n   z[len].offset   = offset;\n   z[len].end      = end;\n   z[len].filename = filename;\n   z[len].next_line_after = next_line;\n   return z;\n}\n\nstatic void stb_include_free_includes(include_info *array, int len)\n{\n   int i;\n   for (i=0; i < len; ++i)\n      free(array[i].filename);\n   free(array);\n}\n\nstatic int stb_include_isspace(int ch)\n{\n   return (ch == ' ' || ch == '\\t' || ch == '\\r' || ch == '\\n');\n}\n\n// find location of all #include and #inject\nstatic int stb_include_find_includes(char *text, include_info **plist)\n{\n   int line_count = 1;\n   int inc_count = 0;\n   char *s = text, *start;\n   include_info *list = NULL;\n   while (*s) {\n      // parse is always at start of line when we reach here\n      start = s;\n      while (*s == ' ' || *s == '\\t')\n         ++s;\n      if (*s == '#') {\n         ++s;\n         while (*s == ' ' || *s == '\\t')\n            ++s;\n         if (0==strncmp(s, \"include\", 7) && stb_include_isspace(s[7])) {\n            s += 7;\n            while (*s == ' ' || *s == '\\t')\n               ++s;\n            if (*s == '\"') {\n               char *t = ++s;\n               while (*t != '\"' && *t != '\\n' && *t != '\\r' && *t != 0)\n                  ++t;\n               if (*t == '\"') {\n                  char *filename = (char *) malloc(t-s+1);\n                  memcpy(filename, s, t-s);\n                  filename[t-s] = 0;\n                  s=t;\n                  while (*s != '\\r' && *s != '\\n' && *s != 0)\n                     ++s;\n                  // s points to the newline, so s-start is everything except the newline\n                  list = stb_include_append_include(list, inc_count++, start-text, s-text, filename, line_count+1);\n               }\n            }\n         } else if (0==strncmp(s, \"inject\", 6) && (stb_include_isspace(s[6]) || s[6]==0)) {\n            while (*s != '\\r' && *s != '\\n' && *s != 0)\n               ++s;\n            list = stb_include_append_include(list, inc_count++, start-text, s-text, NULL, line_count+1);\n         }\n      }\n      while (*s != '\\r' && *s != '\\n' && *s != 0)\n         ++s;\n      if (*s == '\\r' || *s == '\\n') {\n         s = s + (s[0] + s[1] == '\\r' + '\\n' ? 2 : 1);\n      }\n      ++line_count;\n   }\n   *plist = list;\n   return inc_count;\n}\n\n// avoid dependency on sprintf()\nstatic void stb_include_itoa(char str[9], int n)\n{\n   int i;\n   for (i=0; i < 8; ++i)\n      str[i] = ' ';\n   str[i] = 0;\n\n   for (i=1; i < 8; ++i) {\n      str[7-i] = '0' + (n % 10);\n      n /= 10;\n      if (n == 0)\n         break;\n   }\n}\n\nstatic char *stb_include_append(char *str, size_t *curlen, char *addstr, size_t addlen)\n{\n   str = (char *) realloc(str, *curlen + addlen);\n   memcpy(str + *curlen, addstr, addlen);\n   *curlen += addlen;\n   return str;\n}\n\nchar *stb_include_string(char *str, char *inject, char *path_to_includes, char *filename, char error[256])\n{\n   char temp[4096];\n   include_info *inc_list;\n   int i, num = stb_include_find_includes(str, &inc_list);\n   size_t source_len = strlen(str);\n   char *text=0;\n   size_t textlen=0, last=0;\n   for (i=0; i < num; ++i) {\n      text = stb_include_append(text, &textlen, str+last, inc_list[i].offset - last);\n      // write out line directive for the include\n      #ifndef STB_INCLUDE_LINE_NONE\n      #ifdef STB_INCLUDE_LINE_GLSL\n      if (textlen != 0)  // GLSL #version must appear first, so don't put a #line at the top\n      #endif\n      {\n         strcpy(temp, \"#line \");\n         stb_include_itoa(temp+6, 1);\n         strcat(temp, \" \");\n         #ifdef STB_INCLUDE_LINE_GLSL\n         stb_include_itoa(temp+15, i+1);\n         #else\n         strcat(temp, \"\\\"\");\n         if (inc_list[i].filename == 0)\n            strcmp(temp, \"INJECT\");\n         else\n            strcat(temp, inc_list[i].filename);\n         strcat(temp, \"\\\"\");\n         #endif\n         strcat(temp, \"\\n\");\n         text = stb_include_append(text, &textlen, temp, strlen(temp));\n      }\n      #endif\n      if (inc_list[i].filename == 0) {\n         if (inject != 0)\n            text = stb_include_append(text, &textlen, inject, strlen(inject));\n      } else {\n         char *inc;\n         strcpy(temp, path_to_includes);\n         strcat(temp, \"/\");\n         strcat(temp, inc_list[i].filename);\n         inc = stb_include_file(temp, inject, path_to_includes, error);\n         if (inc == NULL) {\n            stb_include_free_includes(inc_list, num);\n            return NULL;\n         }\n         text = stb_include_append(text, &textlen, inc, strlen(inc));\n         free(inc);\n      }\n      // write out line directive\n      #ifndef STB_INCLUDE_LINE_NONE\n      strcpy(temp, \"\\n#line \");\n      stb_include_itoa(temp+6, inc_list[i].next_line_after);\n      strcat(temp, \" \");\n      #ifdef STB_INCLUDE_LINE_GLSL\n      stb_include_itoa(temp+15, 0);\n      #else\n      strcat(temp, filename != 0 ? filename : \"source-file\");\n      #endif\n      text = stb_include_append(text, &textlen, temp, strlen(temp));\n      // no newlines, because we kept the #include newlines, which will get appended next\n      #endif\n      last = inc_list[i].end;\n   }\n   text = stb_include_append(text, &textlen, str+last, source_len - last + 1); // append '\\0'\n   stb_include_free_includes(inc_list, num);\n   return text;\n}\n\nchar *stb_include_strings(char **strs, int count, char *inject, char *path_to_includes, char *filename, char error[256])\n{\n   char *text;\n   char *result;\n   int i;\n   size_t length=0;\n   for (i=0; i < count; ++i)\n      length += strlen(strs[i]);\n   text = (char *) malloc(length+1);\n   length = 0;\n   for (i=0; i < count; ++i) {\n      strcpy(text + length, strs[i]);\n      length += strlen(strs[i]);\n   }\n   result = stb_include_string(text, inject, path_to_includes, filename, error);\n   free(text);\n   return result;\n}\n\nchar *stb_include_file(char *filename, char *inject, char *path_to_includes, char error[256])\n{\n   size_t len;\n   char *result;\n   char *text = stb_include_load_file(filename, &len);\n   if (text == NULL) {\n      strcpy(error, \"Error: couldn't load '\");\n      strcat(error, filename);\n      strcat(error, \"'\");\n      return 0;\n   }\n   result = stb_include_string(text, inject, path_to_includes, filename, error);\n   free(text);\n   return result;\n}\n\n#if 0 // @TODO, GL_ARB_shader_language_include-style system that doesn't touch filesystem\nchar *stb_include_preloaded(char *str, char *inject, char *includes[][2], char error[256])\n{\n\n}\n#endif\n\n#endif // STB_INCLUDE_IMPLEMENTATION\n"
        },
        {
          "name": "stb_leakcheck.h",
          "type": "blob",
          "size": 6.9814453125,
          "content": "// stb_leakcheck.h - v0.6 - quick & dirty malloc leak-checking - public domain\n// LICENSE\n//\n//   See end of file.\n\n#ifdef STB_LEAKCHECK_IMPLEMENTATION\n#undef STB_LEAKCHECK_IMPLEMENTATION // don't implement more than once\n\n// if we've already included leakcheck before, undefine the macros\n#ifdef malloc\n#undef malloc\n#undef free\n#undef realloc\n#endif\n\n#ifndef STB_LEAKCHECK_OUTPUT_PIPE\n#define STB_LEAKCHECK_OUTPUT_PIPE stdout\n#endif\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\ntypedef struct malloc_info stb_leakcheck_malloc_info;\n\nstruct malloc_info\n{\n   const char *file;\n   int line;\n   size_t size;\n   stb_leakcheck_malloc_info *next,*prev;\n};\n\nstatic stb_leakcheck_malloc_info *mi_head;\n\nvoid *stb_leakcheck_malloc(size_t sz, const char *file, int line)\n{\n   stb_leakcheck_malloc_info *mi = (stb_leakcheck_malloc_info *) malloc(sz + sizeof(*mi));\n   if (mi == NULL) return mi;\n   mi->file = file;\n   mi->line = line;\n   mi->next = mi_head;\n   if (mi_head)\n      mi->next->prev = mi;\n   mi->prev = NULL;\n   mi->size = (int) sz;\n   mi_head = mi;\n   return mi+1;\n}\n\nvoid stb_leakcheck_free(void *ptr)\n{\n   if (ptr != NULL) {\n      stb_leakcheck_malloc_info *mi = (stb_leakcheck_malloc_info *) ptr - 1;\n      mi->size = ~mi->size;\n      #ifndef STB_LEAKCHECK_SHOWALL\n      if (mi->prev == NULL) {\n         assert(mi_head == mi);\n         mi_head = mi->next;\n      } else\n         mi->prev->next = mi->next;\n      if (mi->next)\n         mi->next->prev = mi->prev;\n      free(mi);\n      #endif\n   }\n}\n\nvoid *stb_leakcheck_realloc(void *ptr, size_t sz, const char *file, int line)\n{\n   if (ptr == NULL) {\n      return stb_leakcheck_malloc(sz, file, line);\n   } else if (sz == 0) {\n      stb_leakcheck_free(ptr);\n      return NULL;\n   } else {\n      stb_leakcheck_malloc_info *mi = (stb_leakcheck_malloc_info *) ptr - 1;\n      if (sz <= mi->size)\n         return ptr;\n      else {\n         #ifdef STB_LEAKCHECK_REALLOC_PRESERVE_MALLOC_FILELINE\n         void *q = stb_leakcheck_malloc(sz, mi->file, mi->line);\n         #else\n         void *q = stb_leakcheck_malloc(sz, file, line);\n         #endif\n         if (q) {\n            memcpy(q, ptr, mi->size);\n            stb_leakcheck_free(ptr);\n         }\n         return q;\n      }\n   }\n}\n\nstatic void stblkck_internal_print(const char *reason, stb_leakcheck_malloc_info *mi)\n{\n#if defined(_MSC_VER) && _MSC_VER < 1900 // 1900=VS 2015\n   // Compilers that use the old MS C runtime library don't have %zd\n   // and the older ones don't even have %lld either... however, the old compilers\n   // without \"long long\" don't support 64-bit targets either, so here's the\n   // compromise:\n   #if _MSC_VER < 1400 // before VS 2005\n      fprintf(STB_LEAKCHECK_OUTPUT_PIPE, \"%s: %s (%4d): %8d bytes at %p\\n\", reason, mi->file, mi->line, (int)mi->size, (void*)(mi+1));\n   #else\n      fprintf(STB_LEAKCHECK_OUTPUT_PIPE, \"%s: %s (%4d): %16lld bytes at %p\\n\", reason, mi->file, mi->line, (long long)mi->size, (void*)(mi+1));\n   #endif\n#else\n   // Assume we have %zd on other targets.\n   #ifdef __MINGW32__\n      __mingw_fprintf(STB_LEAKCHECK_OUTPUT_PIPE, \"%s: %s (%4d): %zd bytes at %p\\n\", reason, mi->file, mi->line, mi->size, (void*)(mi+1));\n   #else\n      fprintf(STB_LEAKCHECK_OUTPUT_PIPE, \"%s: %s (%4d): %zd bytes at %p\\n\", reason, mi->file, mi->line, mi->size, (void*)(mi+1));\n   #endif\n#endif\n}\n\nvoid stb_leakcheck_dumpmem(void)\n{\n   stb_leakcheck_malloc_info *mi = mi_head;\n   while (mi) {\n      if ((ptrdiff_t) mi->size >= 0)\n         stblkck_internal_print(\"LEAKED\", mi);\n      mi = mi->next;\n   }\n   #ifdef STB_LEAKCHECK_SHOWALL\n   mi = mi_head;\n   while (mi) {\n      if ((ptrdiff_t) mi->size < 0)\n         stblkck_internal_print(\"FREED \", mi);\n      mi = mi->next;\n   }\n   #endif\n}\n#endif // STB_LEAKCHECK_IMPLEMENTATION\n\n#if !defined(INCLUDE_STB_LEAKCHECK_H) || !defined(malloc)\n#define INCLUDE_STB_LEAKCHECK_H\n\n#include <stdlib.h> // we want to define the macros *after* stdlib to avoid a slew of errors\n\n#define malloc(sz)    stb_leakcheck_malloc(sz, __FILE__, __LINE__)\n#define free(p)       stb_leakcheck_free(p)\n#define realloc(p,sz) stb_leakcheck_realloc(p,sz, __FILE__, __LINE__)\n\nextern void * stb_leakcheck_malloc(size_t sz, const char *file, int line);\nextern void * stb_leakcheck_realloc(void *ptr, size_t sz, const char *file, int line);\nextern void   stb_leakcheck_free(void *ptr);\nextern void   stb_leakcheck_dumpmem(void);\n\n#endif // INCLUDE_STB_LEAKCHECK_H\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_perlin.h",
          "type": "blob",
          "size": 17.498046875,
          "content": "// stb_perlin.h - v0.5 - perlin noise\n// public domain single-file C implementation by Sean Barrett\n//\n// LICENSE\n//\n//   See end of file.\n//\n//\n// to create the implementation,\n//     #define STB_PERLIN_IMPLEMENTATION\n// in *one* C/CPP file that includes this file.\n//\n//\n// Documentation:\n//\n// float  stb_perlin_noise3( float x,\n//                           float y,\n//                           float z,\n//                           int   x_wrap=0,\n//                           int   y_wrap=0,\n//                           int   z_wrap=0)\n//\n// This function computes a random value at the coordinate (x,y,z).\n// Adjacent random values are continuous but the noise fluctuates\n// its randomness with period 1, i.e. takes on wholly unrelated values\n// at integer points. Specifically, this implements Ken Perlin's\n// revised noise function from 2002.\n//\n// The \"wrap\" parameters can be used to create wraparound noise that\n// wraps at powers of two. The numbers MUST be powers of two. Specify\n// 0 to mean \"don't care\". (The noise always wraps every 256 due\n// details of the implementation, even if you ask for larger or no\n// wrapping.)\n//\n// float  stb_perlin_noise3_seed( float x,\n//                                float y,\n//                                float z,\n//                                int   x_wrap=0,\n//                                int   y_wrap=0,\n//                                int   z_wrap=0,\n//                                int   seed)\n//\n// As above, but 'seed' selects from multiple different variations of the\n// noise function. The current implementation only uses the bottom 8 bits\n// of 'seed', but possibly in the future more bits will be used.\n//\n//\n// Fractal Noise:\n//\n// Three common fractal noise functions are included, which produce\n// a wide variety of nice effects depending on the parameters\n// provided. Note that each function will call stb_perlin_noise3\n// 'octaves' times, so this parameter will affect runtime.\n//\n// float stb_perlin_ridge_noise3(float x, float y, float z,\n//                               float lacunarity, float gain, float offset, int octaves)\n//\n// float stb_perlin_fbm_noise3(float x, float y, float z,\n//                             float lacunarity, float gain, int octaves)\n//\n// float stb_perlin_turbulence_noise3(float x, float y, float z,\n//                                    float lacunarity, float gain, int octaves)\n//\n// Typical values to start playing with:\n//     octaves    =   6     -- number of \"octaves\" of noise3() to sum\n//     lacunarity = ~ 2.0   -- spacing between successive octaves (use exactly 2.0 for wrapping output)\n//     gain       =   0.5   -- relative weighting applied to each successive octave\n//     offset     =   1.0?  -- used to invert the ridges, may need to be larger, not sure\n//\n//\n// Contributors:\n//    Jack Mott - additional noise functions\n//    Jordan Peck - seeded noise\n//\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nextern float stb_perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap);\nextern float stb_perlin_noise3_seed(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap, int seed);\nextern float stb_perlin_ridge_noise3(float x, float y, float z, float lacunarity, float gain, float offset, int octaves);\nextern float stb_perlin_fbm_noise3(float x, float y, float z, float lacunarity, float gain, int octaves);\nextern float stb_perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves);\nextern float stb_perlin_noise3_wrap_nonpow2(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap, unsigned char seed);\n#ifdef __cplusplus\n}\n#endif\n\n#ifdef STB_PERLIN_IMPLEMENTATION\n\n#include <math.h> // fabs()\n\n// not same permutation table as Perlin's reference to avoid copyright issues;\n// Perlin's table can be found at http://mrl.nyu.edu/~perlin/noise/\nstatic unsigned char stb__perlin_randtab[512] =\n{\n   23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n   152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n   175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n   8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n   225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n   94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n   165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n   65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n   26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n   250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n   132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n   91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n   38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n   131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n   27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n   61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,\n\n   // and a second copy so we don't need an extra mask or static initializer\n   23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n   152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n   175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n   8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n   225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n   94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n   165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n   65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n   26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n   250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n   132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n   91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n   38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n   131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n   27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n   61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,\n};\n\n\n// perlin's gradient has 12 cases so some get used 1/16th of the time\n// and some 2/16ths. We reduce bias by changing those fractions\n// to 5/64ths and 6/64ths\n\n// this array is designed to match the previous implementation\n// of gradient hash: indices[stb__perlin_randtab[i]&63]\nstatic unsigned char stb__perlin_randtab_grad_idx[512] =\n{\n    7, 9, 5, 0, 11, 1, 6, 9, 3, 9, 11, 1, 8, 10, 4, 7,\n    8, 6, 1, 5, 3, 10, 9, 10, 0, 8, 4, 1, 5, 2, 7, 8,\n    7, 11, 9, 10, 1, 0, 4, 7, 5, 0, 11, 6, 1, 4, 2, 8,\n    8, 10, 4, 9, 9, 2, 5, 7, 9, 1, 7, 2, 2, 6, 11, 5,\n    5, 4, 6, 9, 0, 1, 1, 0, 7, 6, 9, 8, 4, 10, 3, 1,\n    2, 8, 8, 9, 10, 11, 5, 11, 11, 2, 6, 10, 3, 4, 2, 4,\n    9, 10, 3, 2, 6, 3, 6, 10, 5, 3, 4, 10, 11, 2, 9, 11,\n    1, 11, 10, 4, 9, 4, 11, 0, 4, 11, 4, 0, 0, 0, 7, 6,\n    10, 4, 1, 3, 11, 5, 3, 4, 2, 9, 1, 3, 0, 1, 8, 0,\n    6, 7, 8, 7, 0, 4, 6, 10, 8, 2, 3, 11, 11, 8, 0, 2,\n    4, 8, 3, 0, 0, 10, 6, 1, 2, 2, 4, 5, 6, 0, 1, 3,\n    11, 9, 5, 5, 9, 6, 9, 8, 3, 8, 1, 8, 9, 6, 9, 11,\n    10, 7, 5, 6, 5, 9, 1, 3, 7, 0, 2, 10, 11, 2, 6, 1,\n    3, 11, 7, 7, 2, 1, 7, 3, 0, 8, 1, 1, 5, 0, 6, 10,\n    11, 11, 0, 2, 7, 0, 10, 8, 3, 5, 7, 1, 11, 1, 0, 7,\n    9, 0, 11, 5, 10, 3, 2, 3, 5, 9, 7, 9, 8, 4, 6, 5,\n\n    // and a second copy so we don't need an extra mask or static initializer\n    7, 9, 5, 0, 11, 1, 6, 9, 3, 9, 11, 1, 8, 10, 4, 7,\n    8, 6, 1, 5, 3, 10, 9, 10, 0, 8, 4, 1, 5, 2, 7, 8,\n    7, 11, 9, 10, 1, 0, 4, 7, 5, 0, 11, 6, 1, 4, 2, 8,\n    8, 10, 4, 9, 9, 2, 5, 7, 9, 1, 7, 2, 2, 6, 11, 5,\n    5, 4, 6, 9, 0, 1, 1, 0, 7, 6, 9, 8, 4, 10, 3, 1,\n    2, 8, 8, 9, 10, 11, 5, 11, 11, 2, 6, 10, 3, 4, 2, 4,\n    9, 10, 3, 2, 6, 3, 6, 10, 5, 3, 4, 10, 11, 2, 9, 11,\n    1, 11, 10, 4, 9, 4, 11, 0, 4, 11, 4, 0, 0, 0, 7, 6,\n    10, 4, 1, 3, 11, 5, 3, 4, 2, 9, 1, 3, 0, 1, 8, 0,\n    6, 7, 8, 7, 0, 4, 6, 10, 8, 2, 3, 11, 11, 8, 0, 2,\n    4, 8, 3, 0, 0, 10, 6, 1, 2, 2, 4, 5, 6, 0, 1, 3,\n    11, 9, 5, 5, 9, 6, 9, 8, 3, 8, 1, 8, 9, 6, 9, 11,\n    10, 7, 5, 6, 5, 9, 1, 3, 7, 0, 2, 10, 11, 2, 6, 1,\n    3, 11, 7, 7, 2, 1, 7, 3, 0, 8, 1, 1, 5, 0, 6, 10,\n    11, 11, 0, 2, 7, 0, 10, 8, 3, 5, 7, 1, 11, 1, 0, 7,\n    9, 0, 11, 5, 10, 3, 2, 3, 5, 9, 7, 9, 8, 4, 6, 5,\n};\n\nstatic float stb__perlin_lerp(float a, float b, float t)\n{\n   return a + (b-a) * t;\n}\n\nstatic int stb__perlin_fastfloor(float a)\n{\n    int ai = (int) a;\n    return (a < ai) ? ai-1 : ai;\n}\n\n// different grad function from Perlin's, but easy to modify to match reference\nstatic float stb__perlin_grad(int grad_idx, float x, float y, float z)\n{\n   static float basis[12][4] =\n   {\n      {  1, 1, 0 },\n      { -1, 1, 0 },\n      {  1,-1, 0 },\n      { -1,-1, 0 },\n      {  1, 0, 1 },\n      { -1, 0, 1 },\n      {  1, 0,-1 },\n      { -1, 0,-1 },\n      {  0, 1, 1 },\n      {  0,-1, 1 },\n      {  0, 1,-1 },\n      {  0,-1,-1 },\n   };\n\n   float *grad = basis[grad_idx];\n   return grad[0]*x + grad[1]*y + grad[2]*z;\n}\n\nfloat stb_perlin_noise3_internal(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap, unsigned char seed)\n{\n   float u,v,w;\n   float n000,n001,n010,n011,n100,n101,n110,n111;\n   float n00,n01,n10,n11;\n   float n0,n1;\n\n   unsigned int x_mask = (x_wrap-1) & 255;\n   unsigned int y_mask = (y_wrap-1) & 255;\n   unsigned int z_mask = (z_wrap-1) & 255;\n   int px = stb__perlin_fastfloor(x);\n   int py = stb__perlin_fastfloor(y);\n   int pz = stb__perlin_fastfloor(z);\n   int x0 = px & x_mask, x1 = (px+1) & x_mask;\n   int y0 = py & y_mask, y1 = (py+1) & y_mask;\n   int z0 = pz & z_mask, z1 = (pz+1) & z_mask;\n   int r0,r1, r00,r01,r10,r11;\n\n   #define stb__perlin_ease(a)   (((a*6-15)*a + 10) * a * a * a)\n\n   x -= px; u = stb__perlin_ease(x);\n   y -= py; v = stb__perlin_ease(y);\n   z -= pz; w = stb__perlin_ease(z);\n\n   r0 = stb__perlin_randtab[x0+seed];\n   r1 = stb__perlin_randtab[x1+seed];\n\n   r00 = stb__perlin_randtab[r0+y0];\n   r01 = stb__perlin_randtab[r0+y1];\n   r10 = stb__perlin_randtab[r1+y0];\n   r11 = stb__perlin_randtab[r1+y1];\n\n   n000 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r00+z0], x  , y  , z   );\n   n001 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r00+z1], x  , y  , z-1 );\n   n010 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r01+z0], x  , y-1, z   );\n   n011 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r01+z1], x  , y-1, z-1 );\n   n100 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r10+z0], x-1, y  , z   );\n   n101 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r10+z1], x-1, y  , z-1 );\n   n110 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r11+z0], x-1, y-1, z   );\n   n111 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r11+z1], x-1, y-1, z-1 );\n\n   n00 = stb__perlin_lerp(n000,n001,w);\n   n01 = stb__perlin_lerp(n010,n011,w);\n   n10 = stb__perlin_lerp(n100,n101,w);\n   n11 = stb__perlin_lerp(n110,n111,w);\n\n   n0 = stb__perlin_lerp(n00,n01,v);\n   n1 = stb__perlin_lerp(n10,n11,v);\n\n   return stb__perlin_lerp(n0,n1,u);\n}\n\nfloat stb_perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap)\n{\n    return stb_perlin_noise3_internal(x,y,z,x_wrap,y_wrap,z_wrap,0);\n}\n\nfloat stb_perlin_noise3_seed(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap, int seed)\n{\n    return stb_perlin_noise3_internal(x,y,z,x_wrap,y_wrap,z_wrap, (unsigned char) seed);\n}\n\nfloat stb_perlin_ridge_noise3(float x, float y, float z, float lacunarity, float gain, float offset, int octaves)\n{\n   int i;\n   float frequency = 1.0f;\n   float prev = 1.0f;\n   float amplitude = 0.5f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = stb_perlin_noise3_internal(x*frequency,y*frequency,z*frequency,0,0,0,(unsigned char)i);\n      r = offset - (float) fabs(r);\n      r = r*r;\n      sum += r*amplitude*prev;\n      prev = r;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n\nfloat stb_perlin_fbm_noise3(float x, float y, float z, float lacunarity, float gain, int octaves)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      sum += stb_perlin_noise3_internal(x*frequency,y*frequency,z*frequency,0,0,0,(unsigned char)i)*amplitude;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n\nfloat stb_perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = stb_perlin_noise3_internal(x*frequency,y*frequency,z*frequency,0,0,0,(unsigned char)i)*amplitude;\n      sum += (float) fabs(r);\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n\nfloat stb_perlin_noise3_wrap_nonpow2(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap, unsigned char seed)\n{\n   float u,v,w;\n   float n000,n001,n010,n011,n100,n101,n110,n111;\n   float n00,n01,n10,n11;\n   float n0,n1;\n\n   int px = stb__perlin_fastfloor(x);\n   int py = stb__perlin_fastfloor(y);\n   int pz = stb__perlin_fastfloor(z);\n   int x_wrap2 = (x_wrap ? x_wrap : 256);\n   int y_wrap2 = (y_wrap ? y_wrap : 256);\n   int z_wrap2 = (z_wrap ? z_wrap : 256);\n   int x0 = px % x_wrap2, x1;\n   int y0 = py % y_wrap2, y1;\n   int z0 = pz % z_wrap2, z1;\n   int r0,r1, r00,r01,r10,r11;\n\n   if (x0 < 0) x0 += x_wrap2;\n   if (y0 < 0) y0 += y_wrap2;\n   if (z0 < 0) z0 += z_wrap2;\n   x1 = (x0+1) % x_wrap2;\n   y1 = (y0+1) % y_wrap2;\n   z1 = (z0+1) % z_wrap2;\n\n   #define stb__perlin_ease(a)   (((a*6-15)*a + 10) * a * a * a)\n\n   x -= px; u = stb__perlin_ease(x);\n   y -= py; v = stb__perlin_ease(y);\n   z -= pz; w = stb__perlin_ease(z);\n\n   r0 = stb__perlin_randtab[x0];\n   r0 = stb__perlin_randtab[r0+seed];\n   r1 = stb__perlin_randtab[x1];\n   r1 = stb__perlin_randtab[r1+seed];\n\n   r00 = stb__perlin_randtab[r0+y0];\n   r01 = stb__perlin_randtab[r0+y1];\n   r10 = stb__perlin_randtab[r1+y0];\n   r11 = stb__perlin_randtab[r1+y1];\n\n   n000 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r00+z0], x  , y  , z   );\n   n001 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r00+z1], x  , y  , z-1 );\n   n010 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r01+z0], x  , y-1, z   );\n   n011 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r01+z1], x  , y-1, z-1 );\n   n100 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r10+z0], x-1, y  , z   );\n   n101 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r10+z1], x-1, y  , z-1 );\n   n110 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r11+z0], x-1, y-1, z   );\n   n111 = stb__perlin_grad(stb__perlin_randtab_grad_idx[r11+z1], x-1, y-1, z-1 );\n\n   n00 = stb__perlin_lerp(n000,n001,w);\n   n01 = stb__perlin_lerp(n010,n011,w);\n   n10 = stb__perlin_lerp(n100,n101,w);\n   n11 = stb__perlin_lerp(n110,n111,w);\n\n   n0 = stb__perlin_lerp(n00,n01,v);\n   n1 = stb__perlin_lerp(n10,n11,v);\n\n   return stb__perlin_lerp(n0,n1,u);\n}\n#endif  // STB_PERLIN_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_rect_pack.h",
          "type": "blob",
          "size": 19.7255859375,
          "content": "// stb_rect_pack.h - v1.01 - public domain - rectangle packing\n// Sean Barrett 2014\n//\n// Useful for e.g. packing rectangular textures into an atlas.\n// Does not do rotation.\n//\n// Before #including,\n//\n//    #define STB_RECT_PACK_IMPLEMENTATION\n//\n// in the file that you want to have the implementation.\n//\n// Not necessarily the awesomest packing method, but better than\n// the totally naive one in stb_truetype (which is primarily what\n// this is meant to replace).\n//\n// Has only had a few tests run, may have issues.\n//\n// More docs to come.\n//\n// No memory allocations; uses qsort() and assert() from stdlib.\n// Can override those by defining STBRP_SORT and STBRP_ASSERT.\n//\n// This library currently uses the Skyline Bottom-Left algorithm.\n//\n// Please note: better rectangle packers are welcome! Please\n// implement them to the same API, but with a different init\n// function.\n//\n// Credits\n//\n//  Library\n//    Sean Barrett\n//  Minor features\n//    Martins Mozeiko\n//    github:IntellectualKitty\n//\n//  Bugfixes / warning fixes\n//    Jeremy Jaussaud\n//    Fabian Giesen\n//\n// Version history:\n//\n//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section\n//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles\n//     0.99  (2019-02-07)  warning fixes\n//     0.11  (2017-03-03)  return packing success/fail result\n//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings\n//     0.09  (2016-08-27)  fix compiler warnings\n//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)\n//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)\n//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort\n//     0.05:  added STBRP_ASSERT to allow replacing assert\n//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support\n//     0.01:  initial release\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//       INCLUDE SECTION\n//\n\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\n#define STB_INCLUDE_STB_RECT_PACK_H\n\n#define STB_RECT_PACK_VERSION  1\n\n#ifdef STBRP_STATIC\n#define STBRP_DEF static\n#else\n#define STBRP_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct stbrp_context stbrp_context;\ntypedef struct stbrp_node    stbrp_node;\ntypedef struct stbrp_rect    stbrp_rect;\n\ntypedef int            stbrp_coord;\n\n#define STBRP__MAXVAL  0x7fffffff\n// Mostly for internal use, but this is the maximum supported coordinate value.\n\nSTBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);\n// Assign packed locations to rectangles. The rectangles are of type\n// 'stbrp_rect' defined below, stored in the array 'rects', and there\n// are 'num_rects' many of them.\n//\n// Rectangles which are successfully packed have the 'was_packed' flag\n// set to a non-zero value and 'x' and 'y' store the minimum location\n// on each axis (i.e. bottom-left in cartesian coordinates, top-left\n// if you imagine y increasing downwards). Rectangles which do not fit\n// have the 'was_packed' flag set to 0.\n//\n// You should not try to access the 'rects' array from another thread\n// while this function is running, as the function temporarily reorders\n// the array while it executes.\n//\n// To pack into another rectangle, you need to call stbrp_init_target\n// again. To continue packing into the same rectangle, you can call\n// this function again. Calling this multiple times with multiple rect\n// arrays will probably produce worse packing results than calling it\n// a single time with the full rectangle array, but the option is\n// available.\n//\n// The function returns 1 if all of the rectangles were successfully\n// packed and 0 otherwise.\n\nstruct stbrp_rect\n{\n   // reserved for your use:\n   int            id;\n\n   // input:\n   stbrp_coord    w, h;\n\n   // output:\n   stbrp_coord    x, y;\n   int            was_packed;  // non-zero if valid packing\n\n}; // 16 bytes, nominally\n\n\nSTBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);\n// Initialize a rectangle packer to:\n//    pack a rectangle that is 'width' by 'height' in dimensions\n//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long\n//\n// You must call this function every time you start packing into a new target.\n//\n// There is no \"shutdown\" function. The 'nodes' memory must stay valid for\n// the following stbrp_pack_rects() call (or calls), but can be freed after\n// the call (or calls) finish.\n//\n// Note: to guarantee best results, either:\n//       1. make sure 'num_nodes' >= 'width'\n//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'\n//\n// If you don't do either of the above things, widths will be quantized to multiples\n// of small integers to guarantee the algorithm doesn't run out of temporary storage.\n//\n// If you do #2, then the non-quantized algorithm will be used, but the algorithm\n// may run out of temporary storage and be unable to pack some rectangles.\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);\n// Optionally call this function after init but before doing any packing to\n// change the handling of the out-of-temp-memory scenario, described above.\n// If you call init again, this will be reset to the default (false).\n\n\nSTBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);\n// Optionally select which packing heuristic the library should use. Different\n// heuristics will produce better/worse results for different data sets.\n// If you call init again, this will be reset to the default.\n\nenum\n{\n   STBRP_HEURISTIC_Skyline_default=0,\n   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\n   STBRP_HEURISTIC_Skyline_BF_sortHeight\n};\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// the details of the following structures don't matter to you, but they must\n// be visible so you can handle the memory allocations for them\n\nstruct stbrp_node\n{\n   stbrp_coord  x,y;\n   stbrp_node  *next;\n};\n\nstruct stbrp_context\n{\n   int width;\n   int height;\n   int align;\n   int init_mode;\n   int heuristic;\n   int num_nodes;\n   stbrp_node *active_head;\n   stbrp_node *free_head;\n   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//     IMPLEMENTATION SECTION\n//\n\n#ifdef STB_RECT_PACK_IMPLEMENTATION\n#ifndef STBRP_SORT\n#include <stdlib.h>\n#define STBRP_SORT qsort\n#endif\n\n#ifndef STBRP_ASSERT\n#include <assert.h>\n#define STBRP_ASSERT assert\n#endif\n\n#ifdef _MSC_VER\n#define STBRP__NOTUSED(v)  (void)(v)\n#define STBRP__CDECL       __cdecl\n#else\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\n#define STBRP__CDECL\n#endif\n\nenum\n{\n   STBRP__INIT_skyline = 1\n};\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)\n{\n   switch (context->init_mode) {\n      case STBRP__INIT_skyline:\n         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\n         context->heuristic = heuristic;\n         break;\n      default:\n         STBRP_ASSERT(0);\n   }\n}\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)\n{\n   if (allow_out_of_mem)\n      // if it's ok to run out of memory, then don't bother aligning them;\n      // this gives better packing, but may fail due to OOM (even though\n      // the rectangles easily fit). @TODO a smarter approach would be to only\n      // quantize once we've hit OOM, then we could get rid of this parameter.\n      context->align = 1;\n   else {\n      // if it's not ok to run out of memory, then quantize the widths\n      // so that num_nodes is always enough nodes.\n      //\n      // I.e. num_nodes * align >= width\n      //                  align >= width / num_nodes\n      //                  align = ceil(width/num_nodes)\n\n      context->align = (context->width + context->num_nodes-1) / context->num_nodes;\n   }\n}\n\nSTBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)\n{\n   int i;\n\n   for (i=0; i < num_nodes-1; ++i)\n      nodes[i].next = &nodes[i+1];\n   nodes[i].next = NULL;\n   context->init_mode = STBRP__INIT_skyline;\n   context->heuristic = STBRP_HEURISTIC_Skyline_default;\n   context->free_head = &nodes[0];\n   context->active_head = &context->extra[0];\n   context->width = width;\n   context->height = height;\n   context->num_nodes = num_nodes;\n   stbrp_setup_allow_out_of_mem(context, 0);\n\n   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)\n   context->extra[0].x = 0;\n   context->extra[0].y = 0;\n   context->extra[0].next = &context->extra[1];\n   context->extra[1].x = (stbrp_coord) width;\n   context->extra[1].y = (1<<30);\n   context->extra[1].next = NULL;\n}\n\n// find minimum y position if it starts at x1\nstatic int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)\n{\n   stbrp_node *node = first;\n   int x1 = x0 + width;\n   int min_y, visited_width, waste_area;\n\n   STBRP__NOTUSED(c);\n\n   STBRP_ASSERT(first->x <= x0);\n\n   #if 0\n   // skip in case we're past the node\n   while (node->next->x <= x0)\n      ++node;\n   #else\n   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency\n   #endif\n\n   STBRP_ASSERT(node->x <= x0);\n\n   min_y = 0;\n   waste_area = 0;\n   visited_width = 0;\n   while (node->x < x1) {\n      if (node->y > min_y) {\n         // raise min_y higher.\n         // we've accounted for all waste up to min_y,\n         // but we'll now add more waste for everything we've visted\n         waste_area += visited_width * (node->y - min_y);\n         min_y = node->y;\n         // the first time through, visited_width might be reduced\n         if (node->x < x0)\n            visited_width += node->next->x - x0;\n         else\n            visited_width += node->next->x - node->x;\n      } else {\n         // add waste area\n         int under_width = node->next->x - node->x;\n         if (under_width + visited_width > width)\n            under_width = width - visited_width;\n         waste_area += under_width * (min_y - node->y);\n         visited_width += under_width;\n      }\n      node = node->next;\n   }\n\n   *pwaste = waste_area;\n   return min_y;\n}\n\ntypedef struct\n{\n   int x,y;\n   stbrp_node **prev_link;\n} stbrp__findresult;\n\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)\n{\n   int best_waste = (1<<30), best_x, best_y = (1 << 30);\n   stbrp__findresult fr;\n   stbrp_node **prev, *node, *tail, **best = NULL;\n\n   // align to multiple of c->align\n   width = (width + c->align - 1);\n   width -= width % c->align;\n   STBRP_ASSERT(width % c->align == 0);\n\n   // if it can't possibly fit, bail immediately\n   if (width > c->width || height > c->height) {\n      fr.prev_link = NULL;\n      fr.x = fr.y = 0;\n      return fr;\n   }\n\n   node = c->active_head;\n   prev = &c->active_head;\n   while (node->x + width <= c->width) {\n      int y,waste;\n      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\n      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL\n         // bottom left\n         if (y < best_y) {\n            best_y = y;\n            best = prev;\n         }\n      } else {\n         // best-fit\n         if (y + height <= c->height) {\n            // can only use it if it first vertically\n            if (y < best_y || (y == best_y && waste < best_waste)) {\n               best_y = y;\n               best_waste = waste;\n               best = prev;\n            }\n         }\n      }\n      prev = &node->next;\n      node = node->next;\n   }\n\n   best_x = (best == NULL) ? 0 : (*best)->x;\n\n   // if doing best-fit (BF), we also have to try aligning right edge to each node position\n   //\n   // e.g, if fitting\n   //\n   //     ____________________\n   //    |____________________|\n   //\n   //            into\n   //\n   //   |                         |\n   //   |             ____________|\n   //   |____________|\n   //\n   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned\n   //\n   // This makes BF take about 2x the time\n\n   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\n      tail = c->active_head;\n      node = c->active_head;\n      prev = &c->active_head;\n      // find first node that's admissible\n      while (tail->x < width)\n         tail = tail->next;\n      while (tail) {\n         int xpos = tail->x - width;\n         int y,waste;\n         STBRP_ASSERT(xpos >= 0);\n         // find the left position that matches this\n         while (node->next->x <= xpos) {\n            prev = &node->next;\n            node = node->next;\n         }\n         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\n         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\n         if (y + height <= c->height) {\n            if (y <= best_y) {\n               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {\n                  best_x = xpos;\n                  STBRP_ASSERT(y <= best_y);\n                  best_y = y;\n                  best_waste = waste;\n                  best = prev;\n               }\n            }\n         }\n         tail = tail->next;\n      }\n   }\n\n   fr.prev_link = best;\n   fr.x = best_x;\n   fr.y = best_y;\n   return fr;\n}\n\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)\n{\n   // find best position according to heuristic\n   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\n   stbrp_node *node, *cur;\n\n   // bail if:\n   //    1. it failed\n   //    2. the best node doesn't fit (we don't always check this)\n   //    3. we're out of memory\n   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {\n      res.prev_link = NULL;\n      return res;\n   }\n\n   // on success, create new node\n   node = context->free_head;\n   node->x = (stbrp_coord) res.x;\n   node->y = (stbrp_coord) (res.y + height);\n\n   context->free_head = node->next;\n\n   // insert the new node into the right starting point, and\n   // let 'cur' point to the remaining nodes needing to be\n   // stiched back in\n\n   cur = *res.prev_link;\n   if (cur->x < res.x) {\n      // preserve the existing one, so start testing with the next one\n      stbrp_node *next = cur->next;\n      cur->next = node;\n      cur = next;\n   } else {\n      *res.prev_link = node;\n   }\n\n   // from here, traverse cur and free the nodes, until we get to one\n   // that shouldn't be freed\n   while (cur->next && cur->next->x <= res.x + width) {\n      stbrp_node *next = cur->next;\n      // move the current node to the free list\n      cur->next = context->free_head;\n      context->free_head = cur;\n      cur = next;\n   }\n\n   // stitch the list back in\n   node->next = cur;\n\n   if (cur->x < res.x + width)\n      cur->x = (stbrp_coord) (res.x + width);\n\n#ifdef _DEBUG\n   cur = context->active_head;\n   while (cur->x < context->width) {\n      STBRP_ASSERT(cur->x < cur->next->x);\n      cur = cur->next;\n   }\n   STBRP_ASSERT(cur->next == NULL);\n\n   {\n      int count=0;\n      cur = context->active_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      cur = context->free_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      STBRP_ASSERT(count == context->num_nodes+2);\n   }\n#endif\n\n   return res;\n}\n\nstatic int STBRP__CDECL rect_height_compare(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   if (p->h > q->h)\n      return -1;\n   if (p->h < q->h)\n      return  1;\n   return (p->w > q->w) ? -1 : (p->w < q->w);\n}\n\nstatic int STBRP__CDECL rect_original_order(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\n}\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)\n{\n   int i, all_rects_packed = 1;\n\n   // we use the 'was_packed' field internally to allow sorting/unsorting\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = i;\n   }\n\n   // sort according to heuristic\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\n\n   for (i=0; i < num_rects; ++i) {\n      if (rects[i].w == 0 || rects[i].h == 0) {\n         rects[i].x = rects[i].y = 0;  // empty rect needs no space\n      } else {\n         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\n         if (fr.prev_link) {\n            rects[i].x = (stbrp_coord) fr.x;\n            rects[i].y = (stbrp_coord) fr.y;\n         } else {\n            rects[i].x = rects[i].y = STBRP__MAXVAL;\n         }\n      }\n   }\n\n   // unsort\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\n\n   // set was_packed flags and all_rects_packed status\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\n      if (!rects[i].was_packed)\n         all_rects_packed = 0;\n   }\n\n   // return the all_rects_packed status\n   return all_rects_packed;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_sprintf.h",
          "type": "blob",
          "size": 56.8583984375,
          "content": "// stb_sprintf - v1.10 - public domain snprintf() implementation\n// originally by Jeff Roberts / RAD Game Tools, 2015/10/20\n// http://github.com/nothings/stb\n//\n// allowed types:  sc uidBboXx p AaGgEef n\n// lengths      :  hh h ll j z t I64 I32 I\n//\n// Contributors:\n//    Fabian \"ryg\" Giesen (reformatting)\n//    github:aganm (attribute format)\n//\n// Contributors (bugfixes):\n//    github:d26435\n//    github:trex78\n//    github:account-login\n//    Jari Komppa (SI suffixes)\n//    Rohit Nirmal\n//    Marcin Wojdyr\n//    Leonard Ritter\n//    Stefano Zanotti\n//    Adam Allison\n//    Arvid Gerstmann\n//    Markus Kolb\n//\n// LICENSE:\n//\n//   See end of file for license information.\n\n#ifndef STB_SPRINTF_H_INCLUDE\n#define STB_SPRINTF_H_INCLUDE\n\n/*\nSingle file sprintf replacement.\n\nOriginally written by Jeff Roberts at RAD Game Tools - 2015/10/20.\nHereby placed in public domain.\n\nThis is a full sprintf replacement that supports everything that\nthe C runtime sprintfs support, including float/double, 64-bit integers,\nhex floats, field parameters (%*.*d stuff), length reads backs, etc.\n\nWhy would you need this if sprintf already exists?  Well, first off,\nit's *much* faster (see below). It's also much smaller than the CRT\nversions code-space-wise. We've also added some simple improvements\nthat are super handy (commas in thousands, callbacks at buffer full,\nfor example). Finally, the format strings for MSVC and GCC differ\nfor 64-bit integers (among other small things), so this lets you use\nthe same format strings in cross platform code.\n\nIt uses the standard single file trick of being both the header file\nand the source itself. If you just include it normally, you just get\nthe header file function definitions. To get the code, you include\nit from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.\n\nIt only uses va_args macros from the C runtime to do it's work. It\ndoes cast doubles to S64s and shifts and divides U64s, which does\ndrag in CRT code on most platforms.\n\nIt compiles to roughly 8K with float support, and 4K without.\nAs a comparison, when using MSVC static libs, calling sprintf drags\nin 16K.\n\nAPI:\n====\nint stbsp_sprintf( char * buf, char const * fmt, ... )\nint stbsp_snprintf( char * buf, int count, char const * fmt, ... )\n  Convert an arg list into a buffer.  stbsp_snprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintf( char * buf, char const * fmt, va_list va )\nint stbsp_vsnprintf( char * buf, int count, char const * fmt, va_list va )\n  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )\n    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );\n  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.\n  Your callback can then copy the chars out, print them or whatever.\n  This function is actually the workhorse for everything else.\n  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.\n    // you return the next buffer to use or 0 to stop converting\n\nvoid stbsp_set_separators( char comma, char period )\n  Set the comma and period characters to use.\n\nFLOATS/DOUBLES:\n===============\nThis code uses a internal float->ascii conversion method that uses\ndoubles with error correction (double-doubles, for ~105 bits of\nprecision).  This conversion is round-trip perfect - that is, an atof\nof the values output here will give you the bit-exact double back.\n\nOne difference is that our insignificant digits will be different than\nwith MSVC or GCC (but they don't match each other either).  We also\ndon't attempt to find the minimum length matching float (pre-MSVC15\ndoesn't either).\n\nIf you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT\nand you'll save 4K of code space.\n\n64-BIT INTS:\n============\nThis library also supports 64-bit integers and you can use MSVC style or\nGCC style indicators (%I64d or %lld).  It supports the C99 specifiers\nfor size_t and ptr_diff_t (%jd %zd) as well.\n\nEXTRAS:\n=======\nLike some GCCs, for integers and floats, you can use a ' (single quote)\nspecifier and commas will be inserted on the thousands: \"%'d\" on 12345\nwould print 12,345.\n\nFor integers and floats, you can use a \"$\" specifier and the number\nwill be converted to float and then divided to get kilo, mega, giga or\ntera and then printed, so \"%$d\" 1000 is \"1.0 k\", \"%$.2d\" 2536000 is\n\"2.53 M\", etc. For byte values, use two $:s, like \"%$$d\" to turn\n2536000 to \"2.42 Mi\". If you prefer JEDEC suffixes to SI ones, use three\n$:s: \"%$$$d\" -> \"2.42 M\". To remove the space between the number and the\nsuffix, add \"_\" specifier: \"%_$d\" -> \"2.53M\".\n\nIn addition to octal and hexadecimal conversions, you can print\nintegers in binary: \"%b\" for 256 would print 100.\n\nPERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):\n===================================================================\n\"%d\" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)\n\"%24d\" across all 32-bit ints (4.5x/4.2x faster)\n\"%x\" across all 32-bit ints (4.5x/3.8x faster)\n\"%08x\" across all 32-bit ints (4.3x/3.8x faster)\n\"%f\" across e-10 to e+10 floats (7.3x/6.0x faster)\n\"%e\" across e-10 to e+10 floats (8.1x/6.0x faster)\n\"%g\" across e-10 to e+10 floats (10.0x/7.1x faster)\n\"%f\" for values near e-300 (7.9x/6.5x faster)\n\"%f\" for values near e+300 (10.0x/9.1x faster)\n\"%e\" for values near e-300 (10.1x/7.0x faster)\n\"%e\" for values near e+300 (9.2x/6.0x faster)\n\"%.320f\" for values near e-300 (12.6x/11.2x faster)\n\"%a\" for random values (8.6x/4.3x faster)\n\"%I64d\" for 64-bits with 32-bit values (4.8x/3.4x faster)\n\"%I64d\" for 64-bits > 32-bit values (4.9x/5.5x faster)\n\"%s%s%s\" for 64 char strings (7.1x/7.3x faster)\n\"...512 char string...\" ( 35.0x/32.5x faster!)\n*/\n\n#if defined(__clang__)\n #if defined(__has_feature) && defined(__has_attribute)\n  #if __has_feature(address_sanitizer)\n   #if __has_attribute(__no_sanitize__)\n    #define STBSP__ASAN __attribute__((__no_sanitize__(\"address\")))\n   #elif __has_attribute(__no_sanitize_address__)\n    #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n   #elif __has_attribute(__no_address_safety_analysis__)\n    #define STBSP__ASAN __attribute__((__no_address_safety_analysis__))\n   #endif\n  #endif\n #endif\n#elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n #if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__\n  #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n #endif\n#endif\n\n#ifndef STBSP__ASAN\n#define STBSP__ASAN\n#endif\n\n#ifdef STB_SPRINTF_STATIC\n#define STBSP__PUBLICDEC static\n#define STBSP__PUBLICDEF static STBSP__ASAN\n#else\n#ifdef __cplusplus\n#define STBSP__PUBLICDEC extern \"C\"\n#define STBSP__PUBLICDEF extern \"C\" STBSP__ASAN\n#else\n#define STBSP__PUBLICDEC extern\n#define STBSP__PUBLICDEF STBSP__ASAN\n#endif\n#endif\n\n#if defined(__has_attribute)\n #if __has_attribute(format)\n   #define STBSP__ATTRIBUTE_FORMAT(fmt,va) __attribute__((format(printf,fmt,va)))\n #endif\n#endif\n\n#ifndef STBSP__ATTRIBUTE_FORMAT\n#define STBSP__ATTRIBUTE_FORMAT(fmt,va)\n#endif\n\n#ifdef _MSC_VER\n#define STBSP__NOTUSED(v)  (void)(v)\n#else\n#define STBSP__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#include <stdarg.h> // for va_arg(), va_list()\n#include <stddef.h> // size_t, ptrdiff_t\n\n#ifndef STB_SPRINTF_MIN\n#define STB_SPRINTF_MIN 512 // how many characters per callback\n#endif\ntypedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);\n\n#ifndef STB_SPRINTF_DECORATE\n#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names\n#endif\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, int count, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(2,3);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(3,4);\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);\n\n#endif // STB_SPRINTF_H_INCLUDE\n\n#ifdef STB_SPRINTF_IMPLEMENTATION\n\n#define stbsp__uint32 unsigned int\n#define stbsp__int32 signed int\n\n#ifdef _MSC_VER\n#define stbsp__uint64 unsigned __int64\n#define stbsp__int64 signed __int64\n#else\n#define stbsp__uint64 unsigned long long\n#define stbsp__int64 signed long long\n#endif\n#define stbsp__uint16 unsigned short\n\n#ifndef stbsp__uintptr\n#if defined(__ppc64__) || defined(__powerpc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64) || defined(__s390x__)\n#define stbsp__uintptr stbsp__uint64\n#else\n#define stbsp__uintptr stbsp__uint32\n#endif\n#endif\n\n#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define STB_SPRINTF_MSVC_MODE\n#endif\n#endif\n\n#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses\n#define STBSP__UNALIGNED(code)\n#else\n#define STBSP__UNALIGNED(code) code\n#endif\n\n#ifndef STB_SPRINTF_NOFLOAT\n// internal float utility functions\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);\n#define STBSP__SPECIAL 0x7000\n#endif\n\nstatic char stbsp__period = '.';\nstatic char stbsp__comma = ',';\nstatic struct\n{\n   short temp; // force next field to be 2-byte aligned\n   char pair[201];\n} stbsp__digitpair =\n{\n  0,\n   \"00010203040506070809101112131415161718192021222324\"\n   \"25262728293031323334353637383940414243444546474849\"\n   \"50515253545556575859606162636465666768697071727374\"\n   \"75767778798081828384858687888990919293949596979899\"\n};\n\nSTBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)\n{\n   stbsp__period = pperiod;\n   stbsp__comma = pcomma;\n}\n\n#define STBSP__LEFTJUST 1\n#define STBSP__LEADINGPLUS 2\n#define STBSP__LEADINGSPACE 4\n#define STBSP__LEADING_0X 8\n#define STBSP__LEADINGZERO 16\n#define STBSP__INTMAX 32\n#define STBSP__TRIPLET_COMMA 64\n#define STBSP__NEGATIVE 128\n#define STBSP__METRIC_SUFFIX 256\n#define STBSP__HALFWIDTH 512\n#define STBSP__METRIC_NOSPACE 1024\n#define STBSP__METRIC_1024 2048\n#define STBSP__METRIC_JEDEC 4096\n\nstatic void stbsp__lead_sign(stbsp__uint32 fl, char *sign)\n{\n   sign[0] = 0;\n   if (fl & STBSP__NEGATIVE) {\n      sign[0] = 1;\n      sign[1] = '-';\n   } else if (fl & STBSP__LEADINGSPACE) {\n      sign[0] = 1;\n      sign[1] = ' ';\n   } else if (fl & STBSP__LEADINGPLUS) {\n      sign[0] = 1;\n      sign[1] = '+';\n   }\n}\n\nstatic STBSP__ASAN stbsp__uint32 stbsp__strlen_limited(char const *s, stbsp__uint32 limit)\n{\n   char const * sn = s;\n\n   // get up to 4-byte alignment\n   for (;;) {\n      if (((stbsp__uintptr)sn & 3) == 0)\n         break;\n\n      if (!limit || *sn == 0)\n         return (stbsp__uint32)(sn - s);\n\n      ++sn;\n      --limit;\n   }\n\n   // scan over 4 bytes at a time to find terminating 0\n   // this will intentionally scan up to 3 bytes past the end of buffers,\n   // but becase it works 4B aligned, it will never cross page boundaries\n   // (hence the STBSP__ASAN markup; the over-read here is intentional\n   // and harmless)\n   while (limit >= 4) {\n      stbsp__uint32 v = *(stbsp__uint32 *)sn;\n      // bit hack to find if there's a 0 byte in there\n      if ((v - 0x01010101) & (~v) & 0x80808080UL)\n         break;\n\n      sn += 4;\n      limit -= 4;\n   }\n\n   // handle the last few characters to find actual size\n   while (limit && *sn) {\n      ++sn;\n      --limit;\n   }\n\n   return (stbsp__uint32)(sn - s);\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)\n{\n   static char hex[] = \"0123456789abcdefxp\";\n   static char hexu[] = \"0123456789ABCDEFXP\";\n   char *bf;\n   char const *f;\n   int tlen = 0;\n\n   bf = buf;\n   f = fmt;\n   for (;;) {\n      stbsp__int32 fw, pr, tz;\n      stbsp__uint32 fl;\n\n      // macros for the callback buffer stuff\n      #define stbsp__chk_cb_bufL(bytes)                        \\\n         {                                                     \\\n            int len = (int)(bf - buf);                         \\\n            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \\\n               tlen += len;                                    \\\n               if (0 == (bf = buf = callback(buf, user, len))) \\\n                  goto done;                                   \\\n            }                                                  \\\n         }\n      #define stbsp__chk_cb_buf(bytes)    \\\n         {                                \\\n            if (callback) {               \\\n               stbsp__chk_cb_bufL(bytes); \\\n            }                             \\\n         }\n      #define stbsp__flush_cb()                      \\\n         {                                           \\\n            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \\\n         } // flush if there is even one byte in the buffer\n      #define stbsp__cb_buf_clamp(cl, v)                \\\n         cl = v;                                        \\\n         if (callback) {                                \\\n            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \\\n            if (cl > lg)                                \\\n               cl = lg;                                 \\\n         }\n\n      // fast copy everything up to the next % (or end of string)\n      for (;;) {\n         while (((stbsp__uintptr)f) & 3) {\n         schk1:\n            if (f[0] == '%')\n               goto scandd;\n         schk2:\n            if (f[0] == 0)\n               goto endfmt;\n            stbsp__chk_cb_buf(1);\n            *bf++ = f[0];\n            ++f;\n         }\n         for (;;) {\n            // Check if the next 4 bytes contain %(0x25) or end of string.\n            // Using the 'hasless' trick:\n            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord\n            stbsp__uint32 v, c;\n            v = *(stbsp__uint32 *)f;\n            c = (~v) & 0x80808080;\n            if (((v ^ 0x25252525) - 0x01010101) & c)\n               goto schk1;\n            if ((v - 0x01010101) & c)\n               goto schk2;\n            if (callback)\n               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)\n                  goto schk1;\n            #ifdef STB_SPRINTF_NOUNALIGNED\n                if(((stbsp__uintptr)bf) & 3) {\n                    bf[0] = f[0];\n                    bf[1] = f[1];\n                    bf[2] = f[2];\n                    bf[3] = f[3];\n                } else\n            #endif\n            {\n                *(stbsp__uint32 *)bf = v;\n            }\n            bf += 4;\n            f += 4;\n         }\n      }\n   scandd:\n\n      ++f;\n\n      // ok, we have a percent, read the modifiers first\n      fw = 0;\n      pr = -1;\n      fl = 0;\n      tz = 0;\n\n      // flags\n      for (;;) {\n         switch (f[0]) {\n         // if we have left justify\n         case '-':\n            fl |= STBSP__LEFTJUST;\n            ++f;\n            continue;\n         // if we have leading plus\n         case '+':\n            fl |= STBSP__LEADINGPLUS;\n            ++f;\n            continue;\n         // if we have leading space\n         case ' ':\n            fl |= STBSP__LEADINGSPACE;\n            ++f;\n            continue;\n         // if we have leading 0x\n         case '#':\n            fl |= STBSP__LEADING_0X;\n            ++f;\n            continue;\n         // if we have thousand commas\n         case '\\'':\n            fl |= STBSP__TRIPLET_COMMA;\n            ++f;\n            continue;\n         // if we have kilo marker (none->kilo->kibi->jedec)\n         case '$':\n            if (fl & STBSP__METRIC_SUFFIX) {\n               if (fl & STBSP__METRIC_1024) {\n                  fl |= STBSP__METRIC_JEDEC;\n               } else {\n                  fl |= STBSP__METRIC_1024;\n               }\n            } else {\n               fl |= STBSP__METRIC_SUFFIX;\n            }\n            ++f;\n            continue;\n         // if we don't want space between metric suffix and number\n         case '_':\n            fl |= STBSP__METRIC_NOSPACE;\n            ++f;\n            continue;\n         // if we have leading zero\n         case '0':\n            fl |= STBSP__LEADINGZERO;\n            ++f;\n            goto flags_done;\n         default: goto flags_done;\n         }\n      }\n   flags_done:\n\n      // get the field width\n      if (f[0] == '*') {\n         fw = va_arg(va, stbsp__uint32);\n         ++f;\n      } else {\n         while ((f[0] >= '0') && (f[0] <= '9')) {\n            fw = fw * 10 + f[0] - '0';\n            f++;\n         }\n      }\n      // get the precision\n      if (f[0] == '.') {\n         ++f;\n         if (f[0] == '*') {\n            pr = va_arg(va, stbsp__uint32);\n            ++f;\n         } else {\n            pr = 0;\n            while ((f[0] >= '0') && (f[0] <= '9')) {\n               pr = pr * 10 + f[0] - '0';\n               f++;\n            }\n         }\n      }\n\n      // handle integer size overrides\n      switch (f[0]) {\n      // are we halfwidth?\n      case 'h':\n         fl |= STBSP__HALFWIDTH;\n         ++f;\n         if (f[0] == 'h')\n            ++f;  // QUARTERWIDTH\n         break;\n      // are we 64-bit (unix style)\n      case 'l':\n         fl |= ((sizeof(long) == 8) ? STBSP__INTMAX : 0);\n         ++f;\n         if (f[0] == 'l') {\n            fl |= STBSP__INTMAX;\n            ++f;\n         }\n         break;\n      // are we 64-bit on intmax? (c99)\n      case 'j':\n         fl |= (sizeof(size_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit on size_t or ptrdiff_t? (c99)\n      case 'z':\n         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      case 't':\n         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit (msft style)\n      case 'I':\n         if ((f[1] == '6') && (f[2] == '4')) {\n            fl |= STBSP__INTMAX;\n            f += 3;\n         } else if ((f[1] == '3') && (f[2] == '2')) {\n            f += 3;\n         } else {\n            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);\n            ++f;\n         }\n         break;\n      default: break;\n      }\n\n      // handle each replacement\n      switch (f[0]) {\n         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307\n         char num[STBSP__NUMSZ];\n         char lead[8];\n         char tail[8];\n         char *s;\n         char const *h;\n         stbsp__uint32 l, n, cs;\n         stbsp__uint64 n64;\n#ifndef STB_SPRINTF_NOFLOAT\n         double fv;\n#endif\n         stbsp__int32 dp;\n         char const *sn;\n\n      case 's':\n         // get the string\n         s = va_arg(va, char *);\n         if (s == 0)\n            s = (char *)\"null\";\n         // get the length, limited to desired precision\n         // always limit to ~0u chars since our counts are 32b\n         l = stbsp__strlen_limited(s, (pr >= 0) ? pr : ~0u);\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         // copy the string in\n         goto scopy;\n\n      case 'c': // char\n         // get the character\n         s = num + STBSP__NUMSZ - 1;\n         *s = (char)va_arg(va, int);\n         l = 1;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n\n      case 'n': // weird write-bytes specifier\n      {\n         int *d = va_arg(va, int *);\n         *d = tlen + (int)(bf - buf);\n      } break;\n\n#ifdef STB_SPRINTF_NOFLOAT\n      case 'A':              // float\n      case 'a':              // hex float\n      case 'G':              // float\n      case 'g':              // float\n      case 'E':              // float\n      case 'e':              // float\n      case 'f':              // float\n         va_arg(va, double); // eat it\n         s = (char *)\"No float\";\n         l = 8;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         cs = 0;\n         STBSP__NOTUSED(dp);\n         goto scopy;\n#else\n      case 'A': // hex float\n      case 'a': // hex float\n         h = (f[0] == 'A') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))\n            fl |= STBSP__NEGATIVE;\n\n         s = num + 64;\n\n         stbsp__lead_sign(fl, lead);\n\n         if (dp == -1023)\n            dp = (n64) ? -1022 : 0;\n         else\n            n64 |= (((stbsp__uint64)1) << 52);\n         n64 <<= (64 - 56);\n         if (pr < 15)\n            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));\n// add leading chars\n\n#ifdef STB_SPRINTF_MSVC_MODE\n         *s++ = '0';\n         *s++ = 'x';\n#else\n         lead[1 + lead[0]] = '0';\n         lead[2 + lead[0]] = 'x';\n         lead[0] += 2;\n#endif\n         *s++ = h[(n64 >> 60) & 15];\n         n64 <<= 4;\n         if (pr)\n            *s++ = stbsp__period;\n         sn = s;\n\n         // print the bits\n         n = pr;\n         if (n > 13)\n            n = 13;\n         if (pr > (stbsp__int32)n)\n            tz = pr - n;\n         pr = 0;\n         while (n--) {\n            *s++ = h[(n64 >> 60) & 15];\n            n64 <<= 4;\n         }\n\n         // print the expo\n         tail[1] = h[17];\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n\n         dp = (int)(s - sn);\n         l = (int)(s - (num + 64));\n         s = num + 64;\n         cs = 1 + (3 << 24);\n         goto scopy;\n\n      case 'G': // float\n      case 'g': // float\n         h = (f[0] == 'G') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6;\n         else if (pr == 0)\n            pr = 1; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n\n         // clamp the precision and delete extra zeros after clamp\n         n = pr;\n         if (l > (stbsp__uint32)pr)\n            l = pr;\n         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {\n            --pr;\n            --l;\n         }\n\n         // should we use %e\n         if ((dp <= -4) || (dp > (stbsp__int32)n)) {\n            if (pr > (stbsp__int32)l)\n               pr = l - 1;\n            else if (pr)\n               --pr; // when using %e, there is one digit before the decimal\n            goto doexpfromg;\n         }\n         // this is the insane action to get the pr to match %g semantics for %f\n         if (dp > 0) {\n            pr = (dp < (stbsp__int32)l) ? l - dp : 0;\n         } else {\n            pr = -dp + ((pr > (stbsp__int32)l) ? (stbsp__int32) l : pr);\n         }\n         goto dofloatfromg;\n\n      case 'E': // float\n      case 'e': // float\n         h = (f[0] == 'E') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n      doexpfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n         // handle leading chars\n         *s++ = sn[0];\n\n         if (pr)\n            *s++ = stbsp__period;\n\n         // handle after decimal\n         if ((l - 1) > (stbsp__uint32)pr)\n            l = pr + 1;\n         for (n = 1; n < l; n++)\n            *s++ = sn[n];\n         // trailing zeros\n         tz = pr - (l - 1);\n         pr = 0;\n         // dump expo\n         tail[1] = h[0xe];\n         dp -= 1;\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n#ifdef STB_SPRINTF_MSVC_MODE\n         n = 5;\n#else\n         n = (dp >= 100) ? 5 : 4;\n#endif\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n         cs = 1 + (3 << 24); // how many tens\n         goto flt_lead;\n\n      case 'f': // float\n         fv = va_arg(va, double);\n      doafloat:\n         // do kilos\n         if (fl & STBSP__METRIC_SUFFIX) {\n            double divisor;\n            divisor = 1000.0f;\n            if (fl & STBSP__METRIC_1024)\n               divisor = 1024.0;\n            while (fl < 0x4000000) {\n               if ((fv < divisor) && (fv > -divisor))\n                  break;\n               fv /= divisor;\n               fl += 0x1000000;\n            }\n         }\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))\n            fl |= STBSP__NEGATIVE;\n      dofloatfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n\n         // handle the three decimal varieties\n         if (dp <= 0) {\n            stbsp__int32 i;\n            // handle 0.000*000xxxx\n            *s++ = '0';\n            if (pr)\n               *s++ = stbsp__period;\n            n = -dp;\n            if ((stbsp__int32)n > pr)\n               n = pr;\n            i = n;\n            while (i) {\n               if ((((stbsp__uintptr)s) & 3) == 0)\n                  break;\n               *s++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)s = 0x30303030;\n               s += 4;\n               i -= 4;\n            }\n            while (i) {\n               *s++ = '0';\n               --i;\n            }\n            if ((stbsp__int32)(l + n) > pr)\n               l = pr - n;\n            i = l;\n            while (i) {\n               *s++ = *sn++;\n               --i;\n            }\n            tz = pr - (n + l);\n            cs = 1 + (3 << 24); // how many tens did we write (for commas below)\n         } else {\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;\n            if ((stbsp__uint32)dp >= l) {\n               // handle xxxx000*000.0\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= l)\n                        break;\n                  }\n               }\n               if (n < (stbsp__uint32)dp) {\n                  n = dp - n;\n                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                     while (n) {\n                        if ((((stbsp__uintptr)s) & 3) == 0)\n                           break;\n                        *s++ = '0';\n                        --n;\n                     }\n                     while (n >= 4) {\n                        *(stbsp__uint32 *)s = 0x30303030;\n                        s += 4;\n                        n -= 4;\n                     }\n                  }\n                  while (n) {\n                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                        cs = 0;\n                        *s++ = stbsp__comma;\n                     } else {\n                        *s++ = '0';\n                        --n;\n                     }\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr) {\n                  *s++ = stbsp__period;\n                  tz = pr;\n               }\n            } else {\n               // handle xxxxx.xxxx000*000\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= (stbsp__uint32)dp)\n                        break;\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr)\n                  *s++ = stbsp__period;\n               if ((l - dp) > (stbsp__uint32)pr)\n                  l = pr + dp;\n               while (n < l) {\n                  *s++ = sn[n];\n                  ++n;\n               }\n               tz = pr - (l - dp);\n            }\n         }\n         pr = 0;\n\n         // handle k,m,g,t\n         if (fl & STBSP__METRIC_SUFFIX) {\n            char idx;\n            idx = 1;\n            if (fl & STBSP__METRIC_NOSPACE)\n               idx = 0;\n            tail[0] = idx;\n            tail[1] = ' ';\n            {\n               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.\n                  if (fl & STBSP__METRIC_1024)\n                     tail[idx + 1] = \"_KMGT\"[fl >> 24];\n                  else\n                     tail[idx + 1] = \"_kMGT\"[fl >> 24];\n                  idx++;\n                  // If printing kibits and not in jedec, add the 'i'.\n                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {\n                     tail[idx + 1] = 'i';\n                     idx++;\n                  }\n                  tail[0] = idx;\n               }\n            }\n         };\n\n      flt_lead:\n         // get the length that we copied\n         l = (stbsp__uint32)(s - (num + 64));\n         s = num + 64;\n         goto scopy;\n#endif\n\n      case 'B': // upper binary\n      case 'b': // lower binary\n         h = (f[0] == 'B') ? hexu : hex;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[0xb];\n         }\n         l = (8 << 4) | (1 << 8);\n         goto radixnum;\n\n      case 'o': // octal\n         h = hexu;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 1;\n            lead[1] = '0';\n         }\n         l = (3 << 4) | (3 << 8);\n         goto radixnum;\n\n      case 'p': // pointer\n         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;\n         pr = sizeof(void *) * 2;\n         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros\n                                    // fall through - to X\n\n      case 'X': // upper hex\n      case 'x': // lower hex\n         h = (f[0] == 'X') ? hexu : hex;\n         l = (4 << 4) | (4 << 8);\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[16];\n         }\n      radixnum:\n         // get the number\n         if (fl & STBSP__INTMAX)\n            n64 = va_arg(va, stbsp__uint64);\n         else\n            n64 = va_arg(va, stbsp__uint32);\n\n         s = num + STBSP__NUMSZ;\n         dp = 0;\n         // clear tail, and clear leading if value is zero\n         tail[0] = 0;\n         if (n64 == 0) {\n            lead[0] = 0;\n            if (pr == 0) {\n               l = 0;\n               cs = 0;\n               goto scopy;\n            }\n         }\n         // convert to string\n         for (;;) {\n            *--s = h[n64 & ((1 << (l >> 8)) - 1)];\n            n64 >>= (l >> 8);\n            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))\n               break;\n            if (fl & STBSP__TRIPLET_COMMA) {\n               ++l;\n               if ((l & 15) == ((l >> 4) & 15)) {\n                  l &= ~15;\n                  *--s = stbsp__comma;\n               }\n            }\n         };\n         // get the tens and the comma pos\n         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         // copy it\n         goto scopy;\n\n      case 'u': // unsigned\n      case 'i':\n      case 'd': // integer\n         // get the integer and abs it\n         if (fl & STBSP__INTMAX) {\n            stbsp__int64 i64 = va_arg(va, stbsp__int64);\n            n64 = (stbsp__uint64)i64;\n            if ((f[0] != 'u') && (i64 < 0)) {\n               n64 = (stbsp__uint64)-i64;\n               fl |= STBSP__NEGATIVE;\n            }\n         } else {\n            stbsp__int32 i = va_arg(va, stbsp__int32);\n            n64 = (stbsp__uint32)i;\n            if ((f[0] != 'u') && (i < 0)) {\n               n64 = (stbsp__uint32)-i;\n               fl |= STBSP__NEGATIVE;\n            }\n         }\n\n#ifndef STB_SPRINTF_NOFLOAT\n         if (fl & STBSP__METRIC_SUFFIX) {\n            if (n64 < 1024)\n               pr = 0;\n            else if (pr == -1)\n               pr = 1;\n            fv = (double)(stbsp__int64)n64;\n            goto doafloat;\n         }\n#endif\n\n         // convert to string\n         s = num + STBSP__NUMSZ;\n         l = 0;\n\n         for (;;) {\n            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)\n            char *o = s - 8;\n            if (n64 >= 100000000) {\n               n = (stbsp__uint32)(n64 % 100000000);\n               n64 /= 100000000;\n            } else {\n               n = (stbsp__uint32)n64;\n               n64 = 0;\n            }\n            if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n               do {\n                  s -= 2;\n                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n                  n /= 100;\n               } while (n);\n            }\n            while (n) {\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = (char)(n % 10) + '0';\n                  n /= 10;\n               }\n            }\n            if (n64 == 0) {\n               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))\n                  ++s;\n               break;\n            }\n            while (s != o)\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = '0';\n               }\n         }\n\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         if (l == 0) {\n            *--s = '0';\n            l = 1;\n         }\n         cs = l + (3 << 24);\n         if (pr < 0)\n            pr = 0;\n\n      scopy:\n         // get fw=leading/trailing space, pr=leading zeros\n         if (pr < (stbsp__int32)l)\n            pr = l;\n         n = pr + lead[0] + tail[0] + tz;\n         if (fw < (stbsp__int32)n)\n            fw = n;\n         fw -= n;\n         pr -= l;\n\n         // handle right justify and leading zeros\n         if ((fl & STBSP__LEFTJUST) == 0) {\n            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr\n            {\n               pr = (fw > pr) ? fw : pr;\n               fw = 0;\n            } else {\n               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas\n            }\n         }\n\n         // copy the spaces and/or zeros\n         if (fw + pr) {\n            stbsp__int32 i;\n            stbsp__uint32 c;\n\n            // copy leading spaces (or when doing %8.4d stuff)\n            if ((fl & STBSP__LEFTJUST) == 0)\n               while (fw > 0) {\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i) {\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  stbsp__chk_cb_buf(1);\n               }\n\n            // copy leader\n            sn = lead + 1;\n            while (lead[0]) {\n               stbsp__cb_buf_clamp(i, lead[0]);\n               lead[0] -= (char)i;\n               while (i) {\n                  *bf++ = *sn++;\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n\n            // copy leading zeros\n            c = cs >> 24;\n            cs &= 0xffffff;\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;\n            while (pr > 0) {\n               stbsp__cb_buf_clamp(i, pr);\n               pr -= i;\n               if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = '0';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x30303030;\n                     bf += 4;\n                     i -= 4;\n                  }\n               }\n               while (i) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {\n                     cs = 0;\n                     *bf++ = stbsp__comma;\n                  } else\n                     *bf++ = '0';\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n         }\n\n         // copy leader if there is still one\n         sn = lead + 1;\n         while (lead[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, lead[0]);\n            lead[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy the string\n         n = l;\n         while (n) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, n);\n            n -= i;\n            STBSP__UNALIGNED(while (i >= 4) {\n               *(stbsp__uint32 volatile *)bf = *(stbsp__uint32 volatile *)s;\n               bf += 4;\n               s += 4;\n               i -= 4;\n            })\n            while (i) {\n               *bf++ = *s++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy trailing zeros\n         while (tz) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tz);\n            tz -= i;\n            while (i) {\n               if ((((stbsp__uintptr)bf) & 3) == 0)\n                  break;\n               *bf++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)bf = 0x30303030;\n               bf += 4;\n               i -= 4;\n            }\n            while (i) {\n               *bf++ = '0';\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy tail if there is one\n         sn = tail + 1;\n         while (tail[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tail[0]);\n            tail[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // handle the left justify\n         if (fl & STBSP__LEFTJUST)\n            if (fw > 0) {\n               while (fw) {\n                  stbsp__int32 i;\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i--)\n                     *bf++ = ' ';\n                  stbsp__chk_cb_buf(1);\n               }\n            }\n         break;\n\n      default: // unknown, just copy code\n         s = num + STBSP__NUMSZ - 1;\n         *s = f[0];\n         l = 1;\n         fw = fl = 0;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n      }\n      ++f;\n   }\nendfmt:\n\n   if (!callback)\n      *bf = 0;\n   else\n      stbsp__flush_cb();\n\ndone:\n   return tlen + (int)(bf - buf);\n}\n\n// cleanup\n#undef STBSP__LEFTJUST\n#undef STBSP__LEADINGPLUS\n#undef STBSP__LEADINGSPACE\n#undef STBSP__LEADING_0X\n#undef STBSP__LEADINGZERO\n#undef STBSP__INTMAX\n#undef STBSP__TRIPLET_COMMA\n#undef STBSP__NEGATIVE\n#undef STBSP__METRIC_SUFFIX\n#undef STBSP__NUMSZ\n#undef stbsp__chk_cb_bufL\n#undef stbsp__chk_cb_buf\n#undef stbsp__flush_cb\n#undef stbsp__cb_buf_clamp\n\n// ============================================================================\n//   wrapper functions\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n   va_end(va);\n   return result;\n}\n\ntypedef struct stbsp__context {\n   char *buf;\n   int count;\n   int length;\n   char tmp[STB_SPRINTF_MIN];\n} stbsp__context;\n\nstatic char *stbsp__clamp_callback(const char *buf, void *user, int len)\n{\n   stbsp__context *c = (stbsp__context *)user;\n   c->length += len;\n\n   if (len > c->count)\n      len = c->count;\n\n   if (len) {\n      if (buf != c->buf) {\n         const char *s, *se;\n         char *d;\n         d = c->buf;\n         s = buf;\n         se = buf + len;\n         do {\n            *d++ = *s++;\n         } while (s < se);\n      }\n      c->buf += len;\n      c->count -= len;\n   }\n\n   if (c->count <= 0)\n      return c->tmp;\n   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can\n}\n\nstatic char * stbsp__count_clamp_callback( const char * buf, void * user, int len )\n{\n   stbsp__context * c = (stbsp__context*)user;\n   (void) sizeof(buf);\n\n   c->length += len;\n   return c->tmp; // go direct into buffer if you can\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE( vsnprintf )( char * buf, int count, char const * fmt, va_list va )\n{\n   stbsp__context c;\n\n   if ( (count == 0) && !buf )\n   {\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );\n   }\n   else\n   {\n      int l;\n\n      c.buf = buf;\n      c.count = count;\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );\n\n      // zero-terminate\n      l = (int)( c.buf - buf );\n      if ( l >= count ) // should never be greater, only equal (or less) than count\n         l = count - 1;\n      buf[l] = 0;\n   }\n\n   return c.length;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n\n   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);\n   va_end(va);\n\n   return result;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)\n{\n   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n}\n\n// =======================================================================\n//   low level float utility functions\n\n#ifndef STB_SPRINTF_NOFLOAT\n\n// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)\n#define STBSP__COPYFP(dest, src)                   \\\n   {                                               \\\n      int cn;                                      \\\n      for (cn = 0; cn < 8; cn++)                   \\\n         ((char *)&dest)[cn] = ((char *)&src)[cn]; \\\n   }\n\n// get float info\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)\n{\n   double d;\n   stbsp__int64 b = 0;\n\n   // load value and round at the frac_digits\n   d = value;\n\n   STBSP__COPYFP(b, d);\n\n   *bits = b & ((((stbsp__uint64)1) << 52) - 1);\n   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);\n\n   return (stbsp__int32)((stbsp__uint64) b >> 63);\n}\n\nstatic double const stbsp__bot[23] = {\n   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,\n   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022\n};\nstatic double const stbsp__negbot[22] = {\n   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,\n   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022\n};\nstatic double const stbsp__negboterr[22] = {\n   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,\n   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,\n   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,\n   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039\n};\nstatic double const stbsp__top[13] = {\n   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299\n};\nstatic double const stbsp__negtop[13] = {\n   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299\n};\nstatic double const stbsp__toperr[13] = {\n   8388608,\n   6.8601809640529717e+028,\n   -7.253143638152921e+052,\n   -4.3377296974619174e+075,\n   -1.5559416129466825e+098,\n   -3.2841562489204913e+121,\n   -3.7745893248228135e+144,\n   -1.7356668416969134e+167,\n   -3.8893577551088374e+190,\n   -9.9566444326005119e+213,\n   6.3641293062232429e+236,\n   -5.2069140800249813e+259,\n   -5.2504760255204387e+282\n};\nstatic double const stbsp__negtoperr[13] = {\n   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,\n   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,\n   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,\n   8.0970921678014997e-317\n};\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1200)\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000,\n   100000000000,\n   1000000000000,\n   10000000000000,\n   100000000000000,\n   1000000000000000,\n   10000000000000000,\n   100000000000000000,\n   1000000000000000000,\n   10000000000000000000U\n};\n#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)\n#else\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000ULL,\n   100000000000ULL,\n   1000000000000ULL,\n   10000000000000ULL,\n   100000000000000ULL,\n   1000000000000000ULL,\n   10000000000000000ULL,\n   100000000000000000ULL,\n   1000000000000000000ULL,\n   10000000000000000000ULL\n};\n#define stbsp__tento19th (1000000000000000000ULL)\n#endif\n\n#define stbsp__ddmulthi(oh, ol, xh, yh)                            \\\n   {                                                               \\\n      double ahi = 0, alo, bhi = 0, blo;                           \\\n      stbsp__int64 bt;                                             \\\n      oh = xh * yh;                                                \\\n      STBSP__COPYFP(bt, xh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(ahi, bt);                                      \\\n      alo = xh - ahi;                                              \\\n      STBSP__COPYFP(bt, yh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(bhi, bt);                                      \\\n      blo = yh - bhi;                                              \\\n      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \\\n   }\n\n#define stbsp__ddtoS64(ob, xh, xl)          \\\n   {                                        \\\n      double ahi = 0, alo, vh, t;           \\\n      ob = (stbsp__int64)xh;                \\\n      vh = (double)ob;                      \\\n      ahi = (xh - vh);                      \\\n      t = (ahi - xh);                       \\\n      alo = (xh - (ahi - t)) - (vh + t);    \\\n      ob += (stbsp__int64)(ahi + alo + xl); \\\n   }\n\n#define stbsp__ddrenorm(oh, ol) \\\n   {                            \\\n      double s;                 \\\n      s = oh + ol;              \\\n      ol = ol - (s - oh);       \\\n      oh = s;                   \\\n   }\n\n#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);\n\n#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);\n\nstatic void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350\n{\n   double ph, pl;\n   if ((power >= 0) && (power <= 22)) {\n      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);\n   } else {\n      stbsp__int32 e, et, eb;\n      double p2h, p2l;\n\n      e = power;\n      if (power < 0)\n         e = -e;\n      et = (e * 0x2c9) >> 14; /* %23 */\n      if (et > 13)\n         et = 13;\n      eb = e - (et * 23);\n\n      ph = d;\n      pl = 0.0;\n      if (power < 0) {\n         if (eb) {\n            --eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);\n            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      } else {\n         if (eb) {\n            e = eb;\n            if (eb > 22)\n               eb = 22;\n            e -= eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);\n            if (e) {\n               stbsp__ddrenorm(ph, pl);\n               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);\n               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);\n               ph = p2h;\n               pl = p2l;\n            }\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      }\n   }\n   stbsp__ddrenorm(ph, pl);\n   *ohi = ph;\n   *olo = pl;\n}\n\n// given a float value, returns the significant bits in bits, and the position of the\n//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values\n//   returned in the decimal_pos parameter.\n// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)\n{\n   double d;\n   stbsp__int64 bits = 0;\n   stbsp__int32 expo, e, ng, tens;\n\n   d = value;\n   STBSP__COPYFP(bits, d);\n   expo = (stbsp__int32)((bits >> 52) & 2047);\n   ng = (stbsp__int32)((stbsp__uint64) bits >> 63);\n   if (ng)\n      d = -d;\n\n   if (expo == 2047) // is nan or inf?\n   {\n      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? \"NaN\" : \"Inf\";\n      *decimal_pos = STBSP__SPECIAL;\n      *len = 3;\n      return ng;\n   }\n\n   if (expo == 0) // is zero or denormal\n   {\n      if (((stbsp__uint64) bits << 1) == 0) // do zero\n      {\n         *decimal_pos = 1;\n         *start = out;\n         out[0] = '0';\n         *len = 1;\n         return ng;\n      }\n      // find the right expo for denormals\n      {\n         stbsp__int64 v = ((stbsp__uint64)1) << 51;\n         while ((bits & v) == 0) {\n            --expo;\n            v >>= 1;\n         }\n      }\n   }\n\n   // find the decimal exponent as well as the decimal bits of the value\n   {\n      double ph, pl;\n\n      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046\n      tens = expo - 1023;\n      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);\n\n      // move the significant bits into position and stick them into an int\n      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);\n\n      // get full as much precision from double-double as possible\n      stbsp__ddtoS64(bits, ph, pl);\n\n      // check if we undershot\n      if (((stbsp__uint64)bits) >= stbsp__tento19th)\n         ++tens;\n   }\n\n   // now do the rounding in integer land\n   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);\n   if ((frac_digits < 24)) {\n      stbsp__uint32 dg = 1;\n      if ((stbsp__uint64)bits >= stbsp__powten[9])\n         dg = 10;\n      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {\n         ++dg;\n         if (dg == 20)\n            goto noround;\n      }\n      if (frac_digits < dg) {\n         stbsp__uint64 r;\n         // add 0.5 at the right position and round\n         e = dg - frac_digits;\n         if ((stbsp__uint32)e >= 24)\n            goto noround;\n         r = stbsp__powten[e];\n         bits = bits + (r / 2);\n         if ((stbsp__uint64)bits >= stbsp__powten[dg])\n            ++tens;\n         bits /= r;\n      }\n   noround:;\n   }\n\n   // kill long trailing runs of zeros\n   if (bits) {\n      stbsp__uint32 n;\n      for (;;) {\n         if (bits <= 0xffffffff)\n            break;\n         if (bits % 1000)\n            goto donez;\n         bits /= 1000;\n      }\n      n = (stbsp__uint32)bits;\n      while ((n % 1000) == 0)\n         n /= 1000;\n      bits = n;\n   donez:;\n   }\n\n   // convert to string\n   out += 64;\n   e = 0;\n   for (;;) {\n      stbsp__uint32 n;\n      char *o = out - 8;\n      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)\n      if (bits >= 100000000) {\n         n = (stbsp__uint32)(bits % 100000000);\n         bits /= 100000000;\n      } else {\n         n = (stbsp__uint32)bits;\n         bits = 0;\n      }\n      while (n) {\n         out -= 2;\n         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n         n /= 100;\n         e += 2;\n      }\n      if (bits == 0) {\n         if ((e) && (out[0] == '0')) {\n            ++out;\n            --e;\n         }\n         break;\n      }\n      while (out != o) {\n         *--out = '0';\n         ++e;\n      }\n   }\n\n   *decimal_pos = tens;\n   *start = out;\n   *len = e;\n   return ng;\n}\n\n#undef stbsp__ddmulthi\n#undef stbsp__ddrenorm\n#undef stbsp__ddmultlo\n#undef stbsp__ddmultlos\n#undef STBSP__SPECIAL\n#undef STBSP__COPYFP\n\n#endif // STB_SPRINTF_NOFLOAT\n\n// clean up\n#undef stbsp__uint16\n#undef stbsp__uint32\n#undef stbsp__int32\n#undef stbsp__uint64\n#undef stbsp__int64\n#undef STBSP__UNALIGNED\n\n#endif // STB_SPRINTF_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_textedit.h",
          "type": "blob",
          "size": 52.75,
          "content": "// stb_textedit.h - v1.14  - public domain - Sean Barrett\n// Development of this library was sponsored by RAD Game Tools\n//\n// This C header file implements the guts of a multi-line text-editing\n// widget; you implement display, word-wrapping, and low-level string\n// insertion/deletion, and stb_textedit will map user inputs into\n// insertions & deletions, plus updates to the cursor position,\n// selection state, and undo state.\n//\n// It is intended for use in games and other systems that need to build\n// their own custom widgets and which do not have heavy text-editing\n// requirements (this library is not recommended for use for editing large\n// texts, as its performance does not scale and it has limited undo).\n//\n// Non-trivial behaviors are modelled after Windows text controls.\n//\n//\n// LICENSE\n//\n// See end of file for license information.\n//\n//\n// DEPENDENCIES\n//\n// Uses the C runtime function 'memmove', which you can override\n// by defining STB_TEXTEDIT_memmove before the implementation.\n// Uses no other functions. Performs no runtime allocations.\n//\n//\n// VERSION HISTORY\n//\n//   1.14 (2021-07-11) page up/down, various fixes\n//   1.13 (2019-02-07) fix bug in undo size management\n//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash\n//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield\n//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual\n//   1.9  (2016-08-27) customizable move-by-word\n//   1.8  (2016-04-02) better keyboard handling when mouse button is down\n//   1.7  (2015-09-13) change y range handling in case baseline is non-0\n//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove\n//   1.5  (2014-09-10) add support for secondary keys for OS X\n//   1.4  (2014-08-17) fix signed/unsigned warnings\n//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary\n//   1.2  (2014-05-27) fix some RAD types that had crept into the new code\n//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )\n//   1.0  (2012-07-26) improve documentation, initial public release\n//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode\n//   0.2  (2011-11-28) fixes to undo/redo\n//   0.1  (2010-07-08) initial version\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Ulf Winklemann: move-by-word in 1.1\n//   Fabian Giesen: secondary key inputs in 1.5\n//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6\n//   Louis Schnellbach: page up/down in 1.14\n//\n//   Bugfixes:\n//      Scott Graham\n//      Daniel Keller\n//      Omar Cornut\n//      Dan Thompson\n//\n// USAGE\n//\n// This file behaves differently depending on what symbols you define\n// before including it.\n//\n//\n// Header-file mode:\n//\n//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,\n//   it will operate in \"header file\" mode. In this mode, it declares a\n//   single public symbol, STB_TexteditState, which encapsulates the current\n//   state of a text widget (except for the string, which you will store\n//   separately).\n//\n//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a\n//   primitive type that defines a single character (e.g. char, wchar_t, etc).\n//\n//   To save space or increase undo-ability, you can optionally define the\n//   following things that are used by the undo system:\n//\n//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position\n//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\n//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\n//\n//   If you don't define these, they are set to permissive types and\n//   moderate sizes. The undo system does no memory allocations, so\n//   it grows STB_TexteditState by the worst-case storage which is (in bytes):\n//\n//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT\n//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT\n//\n//\n// Implementation mode:\n//\n//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it\n//   will compile the implementation of the text edit widget, depending\n//   on a large number of symbols which must be defined before the include.\n//\n//   The implementation is defined only as static functions. You will then\n//   need to provide your own APIs in the same file which will access the\n//   static functions.\n//\n//   The basic concept is that you provide a \"string\" object which\n//   behaves like an array of characters. stb_textedit uses indices to\n//   refer to positions in the string, implicitly representing positions\n//   in the displayed textedit. This is true for both plain text and\n//   rich text; even with rich text stb_truetype interacts with your\n//   code as if there was an array of all the displayed characters.\n//\n// Symbols that must be the same in header-file and implementation mode:\n//\n//     STB_TEXTEDIT_CHARTYPE             the character type\n//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position\n//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\n//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\n//\n// Symbols you must define for implementation mode:\n//\n//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,\n//                                      typically this is a wrapper object with other data you need\n//\n//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))\n//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters\n//                                        starting from character #n (see discussion below)\n//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character\n//                                        to the xpos of the i+1'th char for a line of characters\n//                                        starting at character #n (i.e. accounts for kerning\n//                                        with previous char)\n//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character\n//                                        (return type is int, -1 means not valid to insert)\n//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based\n//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize\n//                                        as manually wordwrapping for end-of-line positioning\n//\n//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i\n//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)\n//\n//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key\n//\n//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left\n//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right\n//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up\n//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down\n//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page\n//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page\n//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME\n//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END\n//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME\n//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END\n//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor\n//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor\n//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo\n//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo\n//\n// Optional:\n//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode\n//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),\n//                                          required for default WORDLEFT/WORDRIGHT handlers\n//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to\n//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to\n//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT\n//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT\n//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line\n//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line\n//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text\n//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text\n//\n// Keyboard input must be encoded as a single integer value; e.g. a character code\n// and some bitflags that represent shift states. to simplify the interface, SHIFT must\n// be a bitflag, so we can test the shifted state of cursor movements to allow selection,\n// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.\n//\n// You can encode other things, such as CONTROL or ALT, in additional bits, and\n// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,\n// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN\n// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,\n// and I pass both WM_KEYDOWN and WM_CHAR events to the \"key\" function in the\n// API below. The control keys will only match WM_KEYDOWN events because of the\n// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN\n// bit so it only decodes WM_CHAR events.\n//\n// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed\n// row of characters assuming they start on the i'th character--the width and\n// the height and the number of characters consumed. This allows this library\n// to traverse the entire layout incrementally. You need to compute word-wrapping\n// here.\n//\n// Each textfield keeps its own insert mode state, which is not how normal\n// applications work. To keep an app-wide insert mode, update/copy the\n// \"insert_mode\" field of STB_TexteditState before/after calling API functions.\n//\n// API\n//\n//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\n//\n//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)\n//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)\n//\n//    Each of these functions potentially updates the string and updates the\n//    state.\n//\n//      initialize_state:\n//          set the textedit state to a known good default state when initially\n//          constructing the textedit.\n//\n//      click:\n//          call this with the mouse x,y on a mouse down; it will update the cursor\n//          and reset the selection start/end to the cursor point. the x,y must\n//          be relative to the text widget, with (0,0) being the top left.\n//\n//      drag:\n//          call this with the mouse x,y on a mouse drag/up; it will update the\n//          cursor and the selection end point\n//\n//      cut:\n//          call this to delete the current selection; returns true if there was\n//          one. you should FIRST copy the current selection to the system paste buffer.\n//          (To copy, just copy the current selection out of the string yourself.)\n//\n//      paste:\n//          call this to paste text at the current cursor point or over the current\n//          selection if there is one.\n//\n//      key:\n//          call this for keyboard inputs sent to the textfield. you can use it\n//          for \"key down\" events or for \"translated\" key events. if you need to\n//          do both (as in Win32), or distinguish Unicode characters from control\n//          inputs, set a high bit to distinguish the two; then you can define the\n//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit\n//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is\n//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to\n//          anything other type you wante before including.\n//\n//\n//   When rendering, you can read the cursor position and selection state from\n//   the STB_TexteditState.\n//\n//\n// Notes:\n//\n// This is designed to be usable in IMGUI, so it allows for the possibility of\n// running in an IMGUI that has NOT cached the multi-line layout. For this\n// reason, it provides an interface that is compatible with computing the\n// layout incrementally--we try to make sure we make as few passes through\n// as possible. (For example, to locate the mouse pointer in the text, we\n// could define functions that return the X and Y positions of characters\n// and binary search Y and then X, but if we're doing dynamic layout this\n// will run the layout algorithm many times, so instead we manually search\n// forward in one pass. Similar logic applies to e.g. up-arrow and\n// down-arrow movement.)\n//\n// If it's run in a widget that *has* cached the layout, then this is less\n// efficient, but it's not horrible on modern computers. But you wouldn't\n// want to edit million-line files with it.\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////\n////   Header-file mode\n////\n////\n\n#ifndef INCLUDE_STB_TEXTEDIT_H\n#define INCLUDE_STB_TEXTEDIT_H\n\n////////////////////////////////////////////////////////////////////////\n//\n//     STB_TexteditState\n//\n// Definition of STB_TexteditState which you should store\n// per-textfield; it includes cursor position, selection state,\n// and undo state.\n//\n\n#ifndef STB_TEXTEDIT_UNDOSTATECOUNT\n#define STB_TEXTEDIT_UNDOSTATECOUNT   99\n#endif\n#ifndef STB_TEXTEDIT_UNDOCHARCOUNT\n#define STB_TEXTEDIT_UNDOCHARCOUNT   999\n#endif\n#ifndef STB_TEXTEDIT_CHARTYPE\n#define STB_TEXTEDIT_CHARTYPE        int\n#endif\n#ifndef STB_TEXTEDIT_POSITIONTYPE\n#define STB_TEXTEDIT_POSITIONTYPE    int\n#endif\n\ntypedef struct\n{\n   // private data\n   STB_TEXTEDIT_POSITIONTYPE  where;\n   STB_TEXTEDIT_POSITIONTYPE  insert_length;\n   STB_TEXTEDIT_POSITIONTYPE  delete_length;\n   int                        char_storage;\n} StbUndoRecord;\n\ntypedef struct\n{\n   // private data\n   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];\n   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];\n   short undo_point, redo_point;\n   int undo_char_point, redo_char_point;\n} StbUndoState;\n\ntypedef struct\n{\n   /////////////////////\n   //\n   // public data\n   //\n\n   int cursor;\n   // position of the text cursor within the string\n\n   int select_start;          // selection start point\n   int select_end;\n   // selection start and end point in characters; if equal, no selection.\n   // note that start may be less than or greater than end (e.g. when\n   // dragging the mouse, start is where the initial click was, and you\n   // can drag in either direction)\n\n   unsigned char insert_mode;\n   // each textfield keeps its own insert mode state. to keep an app-wide\n   // insert mode, copy this value in/out of the app state\n\n   int row_count_per_page;\n   // page size in number of row.\n   // this value MUST be set to >0 for pageup or pagedown in multilines documents.\n\n   /////////////////////\n   //\n   // private data\n   //\n   unsigned char cursor_at_end_of_line; // not implemented yet\n   unsigned char initialized;\n   unsigned char has_preferred_x;\n   unsigned char single_line;\n   unsigned char padding1, padding2, padding3;\n   float preferred_x; // this determines where the cursor up/down tries to seek to along x\n   StbUndoState undostate;\n} STB_TexteditState;\n\n\n////////////////////////////////////////////////////////////////////////\n//\n//     StbTexteditRow\n//\n// Result of layout query, used by stb_textedit to determine where\n// the text in each row is.\n\n// result of layout query\ntypedef struct\n{\n   float x0,x1;             // starting x location, end x location (allows for align=right, etc)\n   float baseline_y_delta;  // position of baseline relative to previous row's baseline\n   float ymin,ymax;         // height of row above and below baseline\n   int num_chars;\n} StbTexteditRow;\n#endif //INCLUDE_STB_TEXTEDIT_H\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////\n////   Implementation mode\n////\n////\n\n\n// implementation isn't include-guarded, since it might have indirectly\n// included just the \"header\" portion\n#ifdef STB_TEXTEDIT_IMPLEMENTATION\n\n#ifndef STB_TEXTEDIT_memmove\n#include <string.h>\n#define STB_TEXTEDIT_memmove memmove\n#endif\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Mouse input handling\n//\n\n// traverse the layout to locate the nearest character to a display position\nstatic int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)\n{\n   StbTexteditRow r;\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   float base_y = 0, prev_x;\n   int i=0, k;\n\n   r.x0 = r.x1 = 0;\n   r.ymin = r.ymax = 0;\n   r.num_chars = 0;\n\n   // search rows to find one that straddles 'y'\n   while (i < n) {\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\n      if (r.num_chars <= 0)\n         return n;\n\n      if (i==0 && y < base_y + r.ymin)\n         return 0;\n\n      if (y < base_y + r.ymax)\n         break;\n\n      i += r.num_chars;\n      base_y += r.baseline_y_delta;\n   }\n\n   // below all text, return 'after' last character\n   if (i >= n)\n      return n;\n\n   // check if it's before the beginning of the line\n   if (x < r.x0)\n      return i;\n\n   // check if it's before the end of the line\n   if (x < r.x1) {\n      // search characters in row for one that straddles 'x'\n      prev_x = r.x0;\n      for (k=0; k < r.num_chars; ++k) {\n         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);\n         if (x < prev_x+w) {\n            if (x < prev_x+w/2)\n               return k+i;\n            else\n               return k+i+1;\n         }\n         prev_x += w;\n      }\n      // shouldn't happen, but if it does, fall through to end-of-line case\n   }\n\n   // if the last character is a newline, return that. otherwise return 'after' the last character\n   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)\n      return i+r.num_chars-1;\n   else\n      return i+r.num_chars;\n}\n\n// API click: on mouse down, move the cursor to the clicked location, and reset the selection\nstatic void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n{\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\n   // goes off the top or bottom of the text\n   if( state->single_line )\n   {\n      StbTexteditRow r;\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n      y = r.ymin;\n   }\n\n   state->cursor = stb_text_locate_coord(str, x, y);\n   state->select_start = state->cursor;\n   state->select_end = state->cursor;\n   state->has_preferred_x = 0;\n}\n\n// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location\nstatic void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\n{\n   int p = 0;\n\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\n   // goes off the top or bottom of the text\n   if( state->single_line )\n   {\n      StbTexteditRow r;\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n      y = r.ymin;\n   }\n\n   if (state->select_start == state->select_end)\n      state->select_start = state->cursor;\n\n   p = stb_text_locate_coord(str, x, y);\n   state->cursor = state->select_end = p;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Keyboard input handling\n//\n\n// forward declarations\nstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);\nstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);\nstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);\nstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);\n\ntypedef struct\n{\n   float x,y;    // position of n'th character\n   float height; // height of line\n   int first_char, length; // first char of row, and length\n   int prev_first;  // first char of previous row\n} StbFindState;\n\n// find the x/y location of a character, and remember info about the previous row in\n// case we get a move-up event (for page up, we'll have to rescan)\nstatic void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)\n{\n   StbTexteditRow r;\n   int prev_start = 0;\n   int z = STB_TEXTEDIT_STRINGLEN(str);\n   int i=0, first;\n\n   if (n == z) {\n      // if it's at the end, then find the last line -- simpler than trying to\n      // explicitly handle this case in the regular code\n      if (single_line) {\n         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\n         find->y = 0;\n         find->first_char = 0;\n         find->length = z;\n         find->height = r.ymax - r.ymin;\n         find->x = r.x1;\n      } else {\n         find->y = 0;\n         find->x = 0;\n         find->height = 1;\n         while (i < z) {\n            STB_TEXTEDIT_LAYOUTROW(&r, str, i);\n            prev_start = i;\n            i += r.num_chars;\n         }\n         find->first_char = i;\n         find->length = 0;\n         find->prev_first = prev_start;\n      }\n      return;\n   }\n\n   // search rows to find the one that straddles character n\n   find->y = 0;\n\n   for(;;) {\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\n      if (n < i + r.num_chars)\n         break;\n      prev_start = i;\n      i += r.num_chars;\n      find->y += r.baseline_y_delta;\n   }\n\n   find->first_char = first = i;\n   find->length = r.num_chars;\n   find->height = r.ymax - r.ymin;\n   find->prev_first = prev_start;\n\n   // now scan to find xpos\n   find->x = r.x0;\n   for (i=0; first+i < n; ++i)\n      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);\n}\n\n#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)\n\n// make the selection/cursor state valid if client altered the string\nstatic void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start > n) state->select_start = n;\n      if (state->select_end   > n) state->select_end = n;\n      // if clamping forced them to be equal, move the cursor to match\n      if (state->select_start == state->select_end)\n         state->cursor = state->select_start;\n   }\n   if (state->cursor > n) state->cursor = n;\n}\n\n// delete characters while updating undo\nstatic void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)\n{\n   stb_text_makeundo_delete(str, state, where, len);\n   STB_TEXTEDIT_DELETECHARS(str, where, len);\n   state->has_preferred_x = 0;\n}\n\n// delete the section\nstatic void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   stb_textedit_clamp(str, state);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start < state->select_end) {\n         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);\n         state->select_end = state->cursor = state->select_start;\n      } else {\n         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);\n         state->select_start = state->cursor = state->select_end;\n      }\n      state->has_preferred_x = 0;\n   }\n}\n\n// canoncialize the selection so start <= end\nstatic void stb_textedit_sortselection(STB_TexteditState *state)\n{\n   if (state->select_end < state->select_start) {\n      int temp = state->select_end;\n      state->select_end = state->select_start;\n      state->select_start = temp;\n   }\n}\n\n// move cursor to first character of selection\nstatic void stb_textedit_move_to_first(STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_sortselection(state);\n      state->cursor = state->select_start;\n      state->select_end = state->select_start;\n      state->has_preferred_x = 0;\n   }\n}\n\n// move cursor to last character of selection\nstatic void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_sortselection(state);\n      stb_textedit_clamp(str, state);\n      state->cursor = state->select_end;\n      state->select_start = state->select_end;\n      state->has_preferred_x = 0;\n   }\n}\n\n#ifdef STB_TEXTEDIT_IS_SPACE\nstatic int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )\n{\n   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;\n}\n\n#ifndef STB_TEXTEDIT_MOVEWORDLEFT\nstatic int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )\n{\n   --c; // always move at least one character\n   while( c >= 0 && !is_word_boundary( str, c ) )\n      --c;\n\n   if( c < 0 )\n      c = 0;\n\n   return c;\n}\n#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous\n#endif\n\n#ifndef STB_TEXTEDIT_MOVEWORDRIGHT\nstatic int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )\n{\n   const int len = STB_TEXTEDIT_STRINGLEN(str);\n   ++c; // always move at least one character\n   while( c < len && !is_word_boundary( str, c ) )\n      ++c;\n\n   if( c > len )\n      c = len;\n\n   return c;\n}\n#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next\n#endif\n\n#endif\n\n// update selection and cursor to match each other\nstatic void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)\n{\n   if (!STB_TEXT_HAS_SELECTION(state))\n      state->select_start = state->select_end = state->cursor;\n   else\n      state->cursor = state->select_end;\n}\n\n// API cut: delete selection\nstatic int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_delete_selection(str,state); // implicitly clamps\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   return 0;\n}\n\n// API paste: replace existing selection with passed-in text\nstatic int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)\n{\n   // if there's a selection, the paste should delete it\n   stb_textedit_clamp(str, state);\n   stb_textedit_delete_selection(str,state);\n   // try to insert the characters\n   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {\n      stb_text_makeundo_insert(state, state->cursor, len);\n      state->cursor += len;\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)\n   return 0;\n}\n\n#ifndef STB_TEXTEDIT_KEYTYPE\n#define STB_TEXTEDIT_KEYTYPE int\n#endif\n\n// API key: process a keyboard input\nstatic void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)\n{\nretry:\n   switch (key) {\n      default: {\n         int c = STB_TEXTEDIT_KEYTOTEXT(key);\n         if (c > 0) {\n            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;\n\n            // can't add newline in single-line mode\n            if (c == '\\n' && state->single_line)\n               break;\n\n            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {\n               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);\n               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);\n               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {\n                  ++state->cursor;\n                  state->has_preferred_x = 0;\n               }\n            } else {\n               stb_textedit_delete_selection(str,state); // implicitly clamps\n               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {\n                  stb_text_makeundo_insert(state, state->cursor, 1);\n                  ++state->cursor;\n                  state->has_preferred_x = 0;\n               }\n            }\n         }\n         break;\n      }\n\n#ifdef STB_TEXTEDIT_K_INSERT\n      case STB_TEXTEDIT_K_INSERT:\n         state->insert_mode = !state->insert_mode;\n         break;\n#endif\n\n      case STB_TEXTEDIT_K_UNDO:\n         stb_text_undo(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_REDO:\n         stb_text_redo(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_LEFT:\n         // if currently there's a selection, move cursor to start of selection\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n         else\n            if (state->cursor > 0)\n               --state->cursor;\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_RIGHT:\n         // if currently there's a selection, move cursor to end of selection\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n         else\n            ++state->cursor;\n         stb_textedit_clamp(str, state);\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         // move selection left\n         if (state->select_end > 0)\n            --state->select_end;\n         state->cursor = state->select_end;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_MOVEWORDLEFT\n      case STB_TEXTEDIT_K_WORDLEFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n         else {\n            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\n            stb_textedit_clamp( str, state );\n         }\n         break;\n\n      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:\n         if( !STB_TEXT_HAS_SELECTION( state ) )\n            stb_textedit_prep_selection_at_cursor(state);\n\n         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\n         state->select_end = state->cursor;\n\n         stb_textedit_clamp( str, state );\n         break;\n#endif\n\n#ifdef STB_TEXTEDIT_MOVEWORDRIGHT\n      case STB_TEXTEDIT_K_WORDRIGHT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n         else {\n            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\n            stb_textedit_clamp( str, state );\n         }\n         break;\n\n      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:\n         if( !STB_TEXT_HAS_SELECTION( state ) )\n            stb_textedit_prep_selection_at_cursor(state);\n\n         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\n         state->select_end = state->cursor;\n\n         stb_textedit_clamp( str, state );\n         break;\n#endif\n\n      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         // move selection right\n         ++state->select_end;\n         stb_textedit_clamp(str, state);\n         state->cursor = state->select_end;\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_DOWN:\n      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:\n      case STB_TEXTEDIT_K_PGDOWN:\n      case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {\n         StbFindState find;\n         StbTexteditRow row;\n         int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\n         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;\n         int row_count = is_page ? state->row_count_per_page : 1;\n\n         if (!is_page && state->single_line) {\n            // on windows, up&down in single-line behave like left&right\n            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);\n            goto retry;\n         }\n\n         if (sel)\n            stb_textedit_prep_selection_at_cursor(state);\n         else if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_last(str, state);\n\n         // compute current position of cursor point\n         stb_textedit_clamp(str, state);\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\n\n         for (j = 0; j < row_count; ++j) {\n            float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;\n            int start = find.first_char + find.length;\n\n            if (find.length == 0)\n               break;\n\n            // now find character position down a row\n            state->cursor = start;\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\n            x = row.x0;\n            for (i=0; i < row.num_chars; ++i) {\n               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);\n               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE\n               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)\n                  break;\n               #endif\n               x += dx;\n               if (x > goal_x)\n                  break;\n               ++state->cursor;\n            }\n            stb_textedit_clamp(str, state);\n\n            state->has_preferred_x = 1;\n            state->preferred_x = goal_x;\n\n            if (sel)\n               state->select_end = state->cursor;\n\n            // go to next line\n            find.first_char = find.first_char + find.length;\n            find.length = row.num_chars;\n         }\n         break;\n      }\n\n      case STB_TEXTEDIT_K_UP:\n      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:\n      case STB_TEXTEDIT_K_PGUP:\n      case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {\n         StbFindState find;\n         StbTexteditRow row;\n         int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\n         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;\n         int row_count = is_page ? state->row_count_per_page : 1;\n\n         if (!is_page && state->single_line) {\n            // on windows, up&down become left&right\n            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);\n            goto retry;\n         }\n\n         if (sel)\n            stb_textedit_prep_selection_at_cursor(state);\n         else if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_move_to_first(state);\n\n         // compute current position of cursor point\n         stb_textedit_clamp(str, state);\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\n\n         for (j = 0; j < row_count; ++j) {\n            float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;\n\n            // can only go up if there's a previous row\n            if (find.prev_first == find.first_char)\n               break;\n\n            // now find character position up a row\n            state->cursor = find.prev_first;\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\n            x = row.x0;\n            for (i=0; i < row.num_chars; ++i) {\n               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);\n               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE\n               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)\n                  break;\n               #endif\n               x += dx;\n               if (x > goal_x)\n                  break;\n               ++state->cursor;\n            }\n            stb_textedit_clamp(str, state);\n\n            state->has_preferred_x = 1;\n            state->preferred_x = goal_x;\n\n            if (sel)\n               state->select_end = state->cursor;\n\n            // go to previous line\n            // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)\n            prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;\n            while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)\n               --prev_scan;\n            find.first_char = find.prev_first;\n            find.prev_first = prev_scan;\n         }\n         break;\n      }\n\n      case STB_TEXTEDIT_K_DELETE:\n      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_delete_selection(str, state);\n         else {\n            int n = STB_TEXTEDIT_STRINGLEN(str);\n            if (state->cursor < n)\n               stb_textedit_delete(str, state, state->cursor, 1);\n         }\n         state->has_preferred_x = 0;\n         break;\n\n      case STB_TEXTEDIT_K_BACKSPACE:\n      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:\n         if (STB_TEXT_HAS_SELECTION(state))\n            stb_textedit_delete_selection(str, state);\n         else {\n            stb_textedit_clamp(str, state);\n            if (state->cursor > 0) {\n               stb_textedit_delete(str, state, state->cursor-1, 1);\n               --state->cursor;\n            }\n         }\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\n      case STB_TEXTEDIT_K_TEXTSTART2:\n#endif\n      case STB_TEXTEDIT_K_TEXTSTART:\n         state->cursor = state->select_start = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTEND2\n      case STB_TEXTEDIT_K_TEXTEND2:\n#endif\n      case STB_TEXTEDIT_K_TEXTEND:\n         state->cursor = STB_TEXTEDIT_STRINGLEN(str);\n         state->select_start = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\n      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         state->cursor = state->select_end = 0;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_TEXTEND2\n      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_prep_selection_at_cursor(state);\n         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);\n         state->has_preferred_x = 0;\n         break;\n\n\n#ifdef STB_TEXTEDIT_K_LINESTART2\n      case STB_TEXTEDIT_K_LINESTART2:\n#endif\n      case STB_TEXTEDIT_K_LINESTART:\n         stb_textedit_clamp(str, state);\n         stb_textedit_move_to_first(state);\n         if (state->single_line)\n            state->cursor = 0;\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\n            --state->cursor;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_LINEEND2\n      case STB_TEXTEDIT_K_LINEEND2:\n#endif\n      case STB_TEXTEDIT_K_LINEEND: {\n         int n = STB_TEXTEDIT_STRINGLEN(str);\n         stb_textedit_clamp(str, state);\n         stb_textedit_move_to_first(state);\n         if (state->single_line)\n             state->cursor = n;\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\n             ++state->cursor;\n         state->has_preferred_x = 0;\n         break;\n      }\n\n#ifdef STB_TEXTEDIT_K_LINESTART2\n      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         if (state->single_line)\n            state->cursor = 0;\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\n            --state->cursor;\n         state->select_end = state->cursor;\n         state->has_preferred_x = 0;\n         break;\n\n#ifdef STB_TEXTEDIT_K_LINEEND2\n      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:\n#endif\n      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {\n         int n = STB_TEXTEDIT_STRINGLEN(str);\n         stb_textedit_clamp(str, state);\n         stb_textedit_prep_selection_at_cursor(state);\n         if (state->single_line)\n             state->cursor = n;\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\n            ++state->cursor;\n         state->select_end = state->cursor;\n         state->has_preferred_x = 0;\n         break;\n      }\n   }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//      Undo processing\n//\n// @OPTIMIZE: the undo/redo buffer should be circular\n\nstatic void stb_textedit_flush_redo(StbUndoState *state)\n{\n   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;\n   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;\n}\n\n// discard the oldest entry in the undo list\nstatic void stb_textedit_discard_undo(StbUndoState *state)\n{\n   if (state->undo_point > 0) {\n      // if the 0th undo state has characters, clean those up\n      if (state->undo_rec[0].char_storage >= 0) {\n         int n = state->undo_rec[0].insert_length, i;\n         // delete n characters from all other records\n         state->undo_char_point -= n;\n         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));\n         for (i=0; i < state->undo_point; ++i)\n            if (state->undo_rec[i].char_storage >= 0)\n               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it\n      }\n      --state->undo_point;\n      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));\n   }\n}\n\n// discard the oldest entry in the redo list--it's bad if this\n// ever happens, but because undo & redo have to store the actual\n// characters in different cases, the redo character buffer can\n// fill up even though the undo buffer didn't\nstatic void stb_textedit_discard_redo(StbUndoState *state)\n{\n   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;\n\n   if (state->redo_point <= k) {\n      // if the k'th undo state has characters, clean those up\n      if (state->undo_rec[k].char_storage >= 0) {\n         int n = state->undo_rec[k].insert_length, i;\n         // move the remaining redo character data to the end of the buffer\n         state->redo_char_point += n;\n         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));\n         // adjust the position of all the other records to account for above memmove\n         for (i=state->redo_point; i < k; ++i)\n            if (state->undo_rec[i].char_storage >= 0)\n               state->undo_rec[i].char_storage += n;\n      }\n      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'\n      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, (size_t) ((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point)*sizeof(state->undo_rec[0])));\n      // now move redo_point to point to the new one\n      ++state->redo_point;\n   }\n}\n\nstatic StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)\n{\n   // any time we create a new undo record, we discard redo\n   stb_textedit_flush_redo(state);\n\n   // if we have no free records, we have to make room, by sliding the\n   // existing records down\n   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\n      stb_textedit_discard_undo(state);\n\n   // if the characters to store won't possibly fit in the buffer, we can't undo\n   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {\n      state->undo_point = 0;\n      state->undo_char_point = 0;\n      return NULL;\n   }\n\n   // if we don't have enough free characters in the buffer, we have to make room\n   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)\n      stb_textedit_discard_undo(state);\n\n   return &state->undo_rec[state->undo_point++];\n}\n\nstatic STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)\n{\n   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);\n   if (r == NULL)\n      return NULL;\n\n   r->where = pos;\n   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;\n   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;\n\n   if (insert_len == 0) {\n      r->char_storage = -1;\n      return NULL;\n   } else {\n      r->char_storage = state->undo_char_point;\n      state->undo_char_point += insert_len;\n      return &state->undo_char[r->char_storage];\n   }\n}\n\nstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   StbUndoState *s = &state->undostate;\n   StbUndoRecord u, *r;\n   if (s->undo_point == 0)\n      return;\n\n   // we need to do two things: apply the undo record, and create a redo record\n   u = s->undo_rec[s->undo_point-1];\n   r = &s->undo_rec[s->redo_point-1];\n   r->char_storage = -1;\n\n   r->insert_length = u.delete_length;\n   r->delete_length = u.insert_length;\n   r->where = u.where;\n\n   if (u.delete_length) {\n      // if the undo record says to delete characters, then the redo record will\n      // need to re-insert the characters that get deleted, so we need to store\n      // them.\n\n      // there are three cases:\n      //    there's enough room to store the characters\n      //    characters stored for *redoing* don't leave room for redo\n      //    characters stored for *undoing* don't leave room for redo\n      // if the last is true, we have to bail\n\n      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {\n         // the undo records take up too much character space; there's no space to store the redo characters\n         r->insert_length = 0;\n      } else {\n         int i;\n\n         // there's definitely room to store the characters eventually\n         while (s->undo_char_point + u.delete_length > s->redo_char_point) {\n            // should never happen:\n            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\n               return;\n            // there's currently not enough room, so discard a redo record\n            stb_textedit_discard_redo(s);\n         }\n         r = &s->undo_rec[s->redo_point-1];\n\n         r->char_storage = s->redo_char_point - u.delete_length;\n         s->redo_char_point = s->redo_char_point - u.delete_length;\n\n         // now save the characters\n         for (i=0; i < u.delete_length; ++i)\n            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);\n      }\n\n      // now we can carry out the deletion\n      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);\n   }\n\n   // check type of recorded action:\n   if (u.insert_length) {\n      // easy case: was a deletion, so we need to insert n characters\n      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);\n      s->undo_char_point -= u.insert_length;\n   }\n\n   state->cursor = u.where + u.insert_length;\n\n   s->undo_point--;\n   s->redo_point--;\n}\n\nstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   StbUndoState *s = &state->undostate;\n   StbUndoRecord *u, r;\n   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\n      return;\n\n   // we need to do two things: apply the redo record, and create an undo record\n   u = &s->undo_rec[s->undo_point];\n   r = s->undo_rec[s->redo_point];\n\n   // we KNOW there must be room for the undo record, because the redo record\n   // was derived from an undo record\n\n   u->delete_length = r.insert_length;\n   u->insert_length = r.delete_length;\n   u->where = r.where;\n   u->char_storage = -1;\n\n   if (r.delete_length) {\n      // the redo record requires us to delete characters, so the undo record\n      // needs to store the characters\n\n      if (s->undo_char_point + u->insert_length > s->redo_char_point) {\n         u->insert_length = 0;\n         u->delete_length = 0;\n      } else {\n         int i;\n         u->char_storage = s->undo_char_point;\n         s->undo_char_point = s->undo_char_point + u->insert_length;\n\n         // now save the characters\n         for (i=0; i < u->insert_length; ++i)\n            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);\n      }\n\n      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);\n   }\n\n   if (r.insert_length) {\n      // easy case: need to insert n characters\n      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);\n      s->redo_char_point += r.insert_length;\n   }\n\n   state->cursor = r.where + r.insert_length;\n\n   s->undo_point++;\n   s->redo_point++;\n}\n\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)\n{\n   stb_text_createundo(&state->undostate, where, 0, length);\n}\n\nstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)\n{\n   int i;\n   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);\n   if (p) {\n      for (i=0; i < length; ++i)\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\n   }\n}\n\nstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)\n{\n   int i;\n   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);\n   if (p) {\n      for (i=0; i < old_length; ++i)\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\n   }\n}\n\n// reset the state to default\nstatic void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)\n{\n   state->undostate.undo_point = 0;\n   state->undostate.undo_char_point = 0;\n   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;\n   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;\n   state->select_end = state->select_start = 0;\n   state->cursor = 0;\n   state->has_preferred_x = 0;\n   state->preferred_x = 0;\n   state->cursor_at_end_of_line = 0;\n   state->initialized = 1;\n   state->single_line = (unsigned char) is_single_line;\n   state->insert_mode = 0;\n   state->row_count_per_page = 0;\n}\n\n// API initialize\nstatic void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\n{\n   stb_textedit_clear_state(state, is_single_line);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nstatic int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)\n{\n   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif//STB_TEXTEDIT_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_tilemap_editor.h",
          "type": "blob",
          "size": 143.12890625,
          "content": "// stb_tilemap_editor.h - v0.42 - Sean Barrett - http://nothings.org/stb\n// placed in the public domain - not copyrighted - first released 2014-09\n//\n// Embeddable tilemap editor for C/C++\n//\n//\n// TABLE OF CONTENTS\n//    FAQ\n//    How to compile/use the library\n//    Additional configuration macros\n//    API documentation\n//    Info on editing multiple levels\n//    Revision history\n//    Todo\n//    Credits\n//    License\n//\n//\n// FAQ\n//\n//   Q: What counts as a tilemap for this library?\n//\n//   A: An array of rectangles, where each rectangle contains a small\n//      stack of images.\n//\n//   Q: What are the limitations?\n//\n//   A: Maps are limited to 4096x4096 in dimension.\n//      Each map square can only contain a stack of at most 32 images.\n//      A map can only use up to 32768 distinct image tiles.\n//\n//   Q: How do I compile this?\n//\n//   A: You need to #define several symbols before #including it, but only\n//      in one file. This will cause all the function definitions to be\n//      generated in that file. See the \"HOW TO COMPILE\" section.\n//\n//   Q: What advantages does this have over a standalone editor?\n//\n//   A: For one, you can integrate the editor into your game so you can\n//      flip between editing and testing without even switching windows.\n//      For another, you don't need an XML parser to get at the map data.\n//\n//   Q: Can I live-edit my game maps?\n//\n//   A: Not really, the editor keeps its own map representation.\n//\n//   Q: How do I save and load maps?\n//\n//   A: You have to do this yourself. The editor provides serialization\n//      functions (get & set) for reading and writing the map it holds.\n//      You can choose whatever format you want to store the map to on\n//      disk; you just need to provide functions to convert. (For example,\n//      I actually store the editor's map representation to disk basically\n//      as-is; then I have a single function that converts from the editor\n//      map representation to the game representation, which is used both\n//      to go from editor-to-game and from loaded-map-to-game.)\n//\n//   Q: I want to have tiles change appearance based on what's\n//      adjacent, or other tile-display/substitution trickiness.\n//\n//   A: You can do this when you convert from the editor's map\n//      representation to the game representation, but there's\n//      no way to show this live in the editor.\n//\n//   Q: The editor appears to be put map location (0,0) at the top left?\n//      I want to use a different coordinate system in my game (e.g. y\n//      increasing upwards, or origin at the center).\n//\n//   A: You can do this when you convert from the editor's map\n//      representation to the game representation. (Don't forget to\n//      translate link coordinates as well!)\n//\n//   Q: The editor appears to put pixel (0,0) at the top left? I want\n//      to use a different coordinate system in my game.\n//\n//   A: The editor defines an \"editor pixel coordinate system\" with\n//      (0,0) at the top left and requires you to display things in\n//      that coordinate system. You can freely remap those coordinates\n//      to anything you want on screen.\n//\n//   Q: How do I scale the user interface?\n//\n//   A: Since you do all the rendering, you can scale up all the rendering\n//      calls that the library makes to you. If you do, (a) you need\n//      to also scale up the mouse coordinates, and (b) you may want\n//      to scale the map display back down so that you're only scaling\n//      the UI and not everything. See the next question.\n//\n//   Q: How do I scale the map display?\n//\n//   A: Use stbte_set_spacing() to change the size that the map is displayed\n//      at. Note that the \"callbacks\" to draw tiles are used for both drawing\n//      the map and drawing the tile palette, so that callback may need to\n//      draw at two different scales. You should choose the scales to match\n//       You can tell them apart because the\n//      tile palette gets NULL for the property pointer.\n//\n//   Q: How does object editing work?\n//\n//   A: One way to think of this is that in the editor, you're placing\n//      spawners, not objects. Each spawner must be tile-aligned, because\n//      it's only a tile editor. Each tile (stack of layers) gets\n//      an associated set of properties, and it's up to you to\n//      determine what properties should appear for a given tile,\n//      based on e.g. the spawners that are in it.\n//\n//   Q: How are properties themselves handled?\n//\n//   A: All properties, regardless of UI behavior, are internally floats.\n//      Each tile has an array of floats associated with it, which is\n//      passed back to you when drawing the tiles so you can draw\n//      objects appropriately modified by the properties.\n//\n//   Q: What if I want to have two different objects/spawners in\n//      one tile, both of which have their own properties?\n//\n//   A: Make sure STBTE_MAX_PROPERTIES is large enough for the sum of\n//      properties in both objects, and then you have to explicitly\n//      map the property slot #s to the appropriate objects. They'll\n//      still all appear in a single property panel; there's no way\n//      to get multiple panels.\n//\n//   Q: Can I do one-to-many linking?\n//\n//   A: The library only supports one link per tile. However, you\n//      can have multiple tiles all link to a single tile. So, you\n//      can fake one-to-many linking by linking in the reverse\n//      direction.\n//\n//   Q: What if I have two objects in the same tile, and they each\n//      need an independent link? Or I have two kinds of link associated\n//      with a single object?\n//\n//   A: There is no way to do this. (Unless you can reverse one link.)\n//\n//   Q: How does cut & paste interact with object properties & links?\n//\n//   A: Currently the library has no idea which properties or links\n//      are associated with which layers of a tile. So currently, the\n//      library will only copy properties & links if the layer panel\n//      is set to allow all layers to be copied, OR if you set the\n//      \"props\" in the layer panel to \"always\". Similarly, you can\n//      set \"props\" to \"none\" so it will never copy.\n//\n//   Q: What happens if the library gets a memory allocation failure\n//      while I'm editing? Will I lose my work?\n//\n//   A: The library allocates all editor memory when you create\n//      the tilemap. It allocates a maximally-sized map and a\n//      fixed-size undo buffer (and the fixed-size copy buffer\n//      is static), and never allocates memory while it's running.\n//      So it can't fail due to running out of memory.\n//\n//   Q: What happens if the library crashes while I'm editing? Will\n//      I lose my work?\n//\n//   A: Yes. Save often.\n//\n//\n// HOW TO COMPILE\n//\n//   This header file contains both the header file and the\n//   implementation file in one. To create the implementation,\n//   in one source file define a few symbols first and then\n//   include this header:\n//\n//      #define STB_TILEMAP_EDITOR_IMPLEMENTATION\n//      // this triggers the implementation\n//\n//      void STBTE_DRAW_RECT(int x0, int y0, int x1, int y1, unsigned int color);\n//      // this must draw a filled rectangle (exclusive on right/bottom)\n//      // color = (r<<16)|(g<<8)|(b)\n//\n//      void STBTE_DRAW_TILE(int x0, int y0,\n//                    unsigned short id, int highlight, float *data);\n//      // this draws the tile image identified by 'id' in one of several\n//      // highlight modes (see STBTE_drawmode_* in the header section);\n//      // if 'data' is NULL, it's drawing the tile in the palette; if 'data'\n//      // is not NULL, it's drawing a tile on the map, and that is the data\n//      // associated with that map tile\n//\n//      #include \"stb_tilemap_editor.h\"\n//\n//   Optionally you can define the following functions before the include;\n//   note these must be macros (but they can just call a function) so\n//   this library can #ifdef to detect if you've defined them:\n//\n//      #define STBTE_PROP_TYPE(int n, short *tiledata, float *params) ...\n//      // Returns the type of the n'th property of a given tile, which\n//      // controls how it is edited. Legal types are:\n//      //     0                    /* no editable property in this slot */\n//      //     STBTE_PROP_int       /* uses a slider to adjust value     */\n//      //     STBTE_PROP_float     /* uses a weird multi-axis control   */\n//      //     STBTE_PROP_bool      /* uses a checkbox to change value   */\n//      // And you can bitwise-OR in the following flags:\n//      //     STBTE_PROP_disabled\n//      // Note that all of these are stored as floats in the param array.\n//      // The integer slider is limited in precision based on the space\n//      // available on screen, so for wide-ranged integers you may want\n//      // to use floats instead.\n//      //\n//      // Since the tiledata is passed to you, you can choose which property\n//      // is bound to that slot based on that data.\n//      //\n//      // Changing the type of a parameter does not cause the underlying\n//      // value to be clamped to the type min/max except when the tile is\n//      // explicitly selected.\n//\n//      #define STBTE_PROP_NAME(int n, short *tiledata, float *params) ...\n//      // these return a string with the name for slot #n in the float\n//      // property list for the tile.\n//\n//      #define STBTE_PROP_MIN(int n, short *tiledata) ...your code here...\n//      #define STBTE_PROP_MAX(int n, short *tiledata) ...your code here...\n//      // These return the allowable range for the property values for\n//      // the specified slot. It is never called for boolean types.\n//\n//      #define STBTE_PROP_FLOAT_SCALE(int n, short *tiledata, float *params)\n//      // This rescales the float control for a given property; by default\n//      // left mouse drags add integers, right mouse drags adds fractions,\n//      // but you can rescale this per-property.\n//\n//      #define STBTE_FLOAT_CONTROL_GRANULARITY       ... value ...\n//      // This returns the number of pixels of mouse motion necessary\n//      // to advance the object float control. Default is 4\n//\n//      #define STBTE_ALLOW_LINK(short *src, float *src_data,  \\\n//                               short *dest, float *dest_data) ...your code...\n//      // this returns true or false depending on whether you allow a link\n//      // to be drawn from a tile 'src' to a tile 'dest'. if you don't\n//      // define this, linking will not be supported\n//\n//      #define STBTE_LINK_COLOR(short *src, float *src_data,  \\\n//                               short *dest, float *dest_data) ...your code...\n//      // return a color encoded as a 24-bit unsigned integer in the\n//      // form 0xRRGGBB. If you don't define this, default colors will\n//      // be used.\n//\n//\n//      [[ support for those below is not implemented yet ]]\n//\n//      #define STBTE_HITTEST_TILE(x0,y0,id,mx,my)   ...your code here...\n//      // this returns true or false depending on whether the mouse\n//      // pointer at mx,my is over (touching) a tile of type 'id'\n//      // displayed at x0,y0. Normally stb_tilemap_editor just does\n//      // this hittest based on the tile geometry, but if you have\n//      // tiles whose images extend out of the tile, you'll need this.\n//\n// ADDITIONAL CONFIGURATION\n//\n//   The following symbols set static limits which determine how much\n//   memory will be allocated for the editor. You can override them\n//   by making similar definitions, but memory usage will increase.\n//\n//      #define STBTE_MAX_TILEMAP_X      200   // max 4096\n//      #define STBTE_MAX_TILEMAP_Y      200   // max 4096\n//      #define STBTE_MAX_LAYERS         8     // max 32\n//      #define STBTE_MAX_CATEGORIES     100\n//      #define STBTE_UNDO_BUFFER_BYTES  (1 << 24) // 16 MB\n//      #define STBTE_MAX_COPY           90000  // e.g. 300x300\n//      #define STBTE_MAX_PROPERTIES     10     // max properties per tile\n//\n// API\n//\n//   Further documentation appears in the header-file section below.\n//\n// EDITING MULTIPLE LEVELS\n//\n//   You can only have one active editor instance. To switch between multiple\n//   levels, you can either store the levels in your own format and copy them\n//   in and out of the editor format, or you can create multiple stbte_tilemap\n//   objects and switch between them. The latter has the advantage that each\n//   stbte_tilemap keeps its own undo state. (The clipboard is global, so\n//   either approach allows cut&pasting between levels.)\n//\n// REVISION HISTORY\n//   0.42  fix compilation errors\n//   0.41  fix warnings\n//   0.40  fix warning\n//   0.39  fix warning\n//   0.38  fix warning\n//   0.37  fix warning\n//   0.36  minor compiler support\n//   0.35  layername button changes\n//          - layername buttons grow with the layer panel\n//          - fix stbte_create_map being declared as stbte_create\n//          - fix declaration of stbte_create_map\n//   0.30  properties release\n//          - properties panel for editing user-defined \"object\" properties\n//          - can link each tile to one other tile\n//          - keyboard interface\n//          - fix eraser tool bug (worked in complex cases, failed in simple)\n//          - undo/redo tools have visible disabled state\n//          - tiles on higher layers draw on top of adjacent lower-layer tiles\n//   0.20  erasable release\n//          - eraser tool\n//          - fix bug when pasting into protected layer\n//          - better color scheme\n//          - internal-use color picker\n//   0.10  initial release\n//\n// TODO\n//\n//   Separate scroll state for each category\n//   Implement paint bucket\n//   Support STBTE_HITTEST_TILE above\n//  ?Cancel drags by clicking other button? - may be fixed\n//   Finish support for toolbar at side\n//\n// CREDITS\n//\n//\n//   Main editor & features\n//      Sean Barrett\n//   Additional features:\n//      Josh Huelsman\n//   Bugfixes:\n//      Ryan Whitworth\n//      Eugene Opalev\n//      Rob Loach\n//      github:wernsey\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n\n\n///////////////////////////////////////////////////////////////////////\n//\n//   HEADER SECTION\n\n#ifndef STB_TILEMAP_INCLUDE_STB_TILEMAP_EDITOR_H\n#define STB_TILEMAP_INCLUDE_STB_TILEMAP_EDITOR_H\n\n#ifdef _WIN32\n  #ifndef _CRT_SECURE_NO_WARNINGS\n  #define _CRT_SECURE_NO_WARNINGS\n  #endif\n  #include <stdlib.h>\n  #include <stdio.h>\n#endif\n\ntypedef struct stbte_tilemap stbte_tilemap;\n\n// these are the drawmodes used in STBTE_DRAW_TILE\nenum\n{\n   STBTE_drawmode_deemphasize = -1,\n   STBTE_drawmode_normal      =  0,\n   STBTE_drawmode_emphasize   =  1,\n};\n\n// these are the property types\n#define STBTE_PROP_none     0\n#define STBTE_PROP_int      1\n#define STBTE_PROP_float    2\n#define STBTE_PROP_bool     3\n#define STBTE_PROP_disabled 4\n\n////////\n//\n// creation\n//\n\nextern stbte_tilemap *stbte_create_map(int map_x, int map_y, int map_layers, int spacing_x, int spacing_y, int max_tiles);\n// create an editable tilemap\n//   map_x      : dimensions of map horizontally (user can change this in editor), <= STBTE_MAX_TILEMAP_X\n//   map_y      : dimensions of map vertically (user can change this in editor)    <= STBTE_MAX_TILEMAP_Y\n//   map_layers : number of layers to use (fixed), <= STBTE_MAX_LAYERS\n//   spacing_x  : initial horizontal distance between left edges of map tiles in stb_tilemap_editor pixels\n//   spacing_y  : initial vertical distance between top edges of map tiles in stb_tilemap_editor pixels\n//   max_tiles  : maximum number of tiles that can defined\n//\n// If insufficient memory, returns NULL\n\nextern void stbte_define_tile(stbte_tilemap *tm, unsigned short id, unsigned int layermask, const char * category);\n// call this repeatedly for each tile to install the tile definitions into the editable tilemap\n//   tm        : tilemap created by stbte_create_map\n//   id        : unique identifier for each tile, 0 <= id < 32768\n//   layermask : bitmask of which layers tile is allowed on: 1 = layer 0, 255 = layers 0..7\n//               (note that onscreen, the editor numbers the layers from 1 not 0)\n//               layer 0 is the furthest back, layer 1 is just in front of layer 0, etc\n//   category  : which category this tile is grouped in\n\nextern void stbte_set_display(int x0, int y0, int x1, int y1);\n// call this once to set the size; if you resize, call it again\n\n\n/////////\n//\n// every frame\n//\n\nextern void stbte_draw(stbte_tilemap *tm);\n\nextern void stbte_tick(stbte_tilemap *tm, float time_in_seconds_since_last_frame);\n\n////////////\n//\n//  user input\n//\n\n// if you're using SDL, call the next function for SDL_MOUSEMOTION, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_MOUSEWHEEL;\n// the transformation lets you scale from SDL mouse coords to stb_tilemap_editor coords\nextern void stbte_mouse_sdl(stbte_tilemap *tm, const void *sdl_event, float xscale, float yscale, int xoffset, int yoffset);\n\n// otherwise, hook these up explicitly:\nextern void stbte_mouse_move(stbte_tilemap *tm, int x, int y, int shifted, int scrollkey);\nextern void stbte_mouse_button(stbte_tilemap *tm, int x, int y, int right, int down, int shifted, int scrollkey);\nextern void stbte_mouse_wheel(stbte_tilemap *tm, int x, int y, int vscroll);\n\n// note: at the moment, mouse wheel events (SDL_MOUSEWHEEL) are ignored.\n\n// for keyboard, define your own mapping from keys to the following actions.\n// this is totally optional, as all features are accessible with the mouse\nenum stbte_action\n{\n   STBTE_tool_select,\n   STBTE_tool_brush,\n   STBTE_tool_erase,\n   STBTE_tool_rectangle,\n   STBTE_tool_eyedropper,\n   STBTE_tool_link,\n   STBTE_act_toggle_grid,\n   STBTE_act_toggle_links,\n   STBTE_act_undo,\n   STBTE_act_redo,\n   STBTE_act_cut,\n   STBTE_act_copy,\n   STBTE_act_paste,\n   STBTE_scroll_left,\n   STBTE_scroll_right,\n   STBTE_scroll_up,\n   STBTE_scroll_down,\n};\nextern void stbte_action(stbte_tilemap *tm, enum stbte_action act);\n\n////////////////\n//\n//  save/load\n//\n//  There is no editor file format. You have to save and load the data yourself\n//  through the following functions. You can also use these functions to get the\n//  data to generate game-formatted levels directly. (But make sure you save\n//  first! You may also want to autosave to a temp file periodically, etc etc.)\n\n#define STBTE_EMPTY    -1\n\nextern void stbte_get_dimensions(stbte_tilemap *tm, int *max_x, int *max_y);\n// get the dimensions of the level, since the user can change them\n\nextern short* stbte_get_tile(stbte_tilemap *tm, int x, int y);\n// returns an array of shorts that is 'map_layers' in length. each short is\n// either one of the tile_id values from define_tile, or STBTE_EMPTY.\n\nextern float *stbte_get_properties(stbte_tilemap *tm, int x, int y);\n// get the property array associated with the tile at x,y. this is an\n// array of floats that is STBTE_MAX_PROPERTIES in length; you have to\n// interpret the slots according to the semantics you've chosen\n\nextern void stbte_get_link(stbte_tilemap *tm, int x, int y, int *destx, int *desty);\n// gets the link associated with the tile at x,y.\n\nextern void stbte_set_dimensions(stbte_tilemap *tm, int max_x, int max_y);\n// set the dimensions of the level, overrides previous stbte_create_map()\n// values or anything the user has changed\n\nextern void stbte_clear_map(stbte_tilemap *tm);\n// clears the map, including the region outside the defined region, so if the\n// user expands the map, they won't see garbage there\n\nextern void stbte_set_tile(stbte_tilemap *tm, int x, int y, int layer, signed short tile);\n// tile is your tile_id from define_tile, or STBTE_EMPTY\n\nextern void stbte_set_property(stbte_tilemap *tm, int x, int y, int n, float val);\n// set the value of the n'th slot of the tile at x,y\n\nextern void stbte_set_link(stbte_tilemap *tm, int x, int y, int destx, int desty);\n// set a link going from x,y to destx,desty. to force no link,\n// use destx=desty=-1\n\n////////\n//\n// optional\n//\n\nextern void stbte_set_background_tile(stbte_tilemap *tm, short id);\n// selects the tile to fill the bottom layer with and used to clear bottom tiles to;\n// should be same ID as\n\nextern void stbte_set_sidewidths(int left, int right);\n// call this once to set the left & right side widths. don't call\n// it again since the user can change it\n\nextern void stbte_set_spacing(stbte_tilemap *tm, int spacing_x, int spacing_y, int palette_spacing_x, int palette_spacing_y);\n// call this to set the spacing of map tiles and the spacing of palette tiles.\n// if you rescale your display, call it again (e.g. you can implement map zooming yourself)\n\nextern void stbte_set_layername(stbte_tilemap *tm, int layer, const char *layername);\n// sets a string name for your layer that shows in the layer selector. note that this\n// makes the layer selector wider. 'layer' is from 0..(map_layers-1)\n\n#endif\n\n#ifdef STB_TILEMAP_EDITOR_IMPLEMENTATION\n\n#ifndef STBTE_ASSERT\n#define STBTE_ASSERT assert\n#include <assert.h>\n#endif\n\n#ifdef _MSC_VER\n#define STBTE__NOTUSED(v)  (void)(v)\n#else\n#define STBTE__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifndef STBTE_MAX_TILEMAP_X\n#define STBTE_MAX_TILEMAP_X      200\n#endif\n\n#ifndef STBTE_MAX_TILEMAP_Y\n#define STBTE_MAX_TILEMAP_Y      200\n#endif\n\n#ifndef STBTE_MAX_LAYERS\n#define STBTE_MAX_LAYERS         8\n#endif\n\n#ifndef STBTE_MAX_CATEGORIES\n#define STBTE_MAX_CATEGORIES     100\n#endif\n\n#ifndef STBTE_MAX_COPY\n#define STBTE_MAX_COPY           65536\n#endif\n\n#ifndef STBTE_UNDO_BUFFER_BYTES\n#define STBTE_UNDO_BUFFER_BYTES  (1 << 24) // 16 MB\n#endif\n\n#ifndef STBTE_PROP_TYPE\n#define STBTE__NO_PROPS\n#define STBTE_PROP_TYPE(n,td,tp)   0\n#endif\n\n#ifndef STBTE_PROP_NAME\n#define STBTE_PROP_NAME(n,td,tp)  \"\"\n#endif\n\n#ifndef STBTE_MAX_PROPERTIES\n#define STBTE_MAX_PROPERTIES           10\n#endif\n\n#ifndef STBTE_PROP_MIN\n#define STBTE_PROP_MIN(n,td,tp)  0\n#endif\n\n#ifndef STBTE_PROP_MAX\n#define STBTE_PROP_MAX(n,td,tp)  100.0\n#endif\n\n#ifndef STBTE_PROP_FLOAT_SCALE\n#define STBTE_PROP_FLOAT_SCALE(n,td,tp)  1   // default scale size\n#endif\n\n#ifndef STBTE_FLOAT_CONTROL_GRANULARITY\n#define STBTE_FLOAT_CONTROL_GRANULARITY 4\n#endif\n\n\n#define STBTE__UNDO_BUFFER_COUNT  (STBTE_UNDO_BUFFER_BYTES>>1)\n\n#if STBTE_MAX_TILEMAP_X > 4096 || STBTE_MAX_TILEMAP_Y > 4096\n#error \"Maximum editable map size is 4096 x 4096\"\n#endif\n#if STBTE_MAX_LAYERS > 32\n#error \"Maximum layers allowed is 32\"\n#endif\n#if STBTE_UNDO_BUFFER_COUNT & (STBTE_UNDO_BUFFER_COUNT-1)\n#error \"Undo buffer size must be a power of 2\"\n#endif\n\n#if STBTE_MAX_PROPERTIES == 0\n#define STBTE__NO_PROPS\n#endif\n\n#ifdef STBTE__NO_PROPS\n#undef STBTE_MAX_PROPERTIES\n#define STBTE_MAX_PROPERTIES 1  // so we can declare arrays\n#endif\n\ntypedef struct\n{\n   short x,y;\n} stbte__link;\n\nenum\n{\n   STBTE__base,\n   STBTE__outline,\n   STBTE__text,\n\n   STBTE__num_color_aspects,\n};\n\nenum\n{\n   STBTE__idle,\n   STBTE__over,\n   STBTE__down,\n   STBTE__over_down,\n   STBTE__selected,\n   STBTE__selected_over,\n   STBTE__disabled,\n   STBTE__num_color_states,\n};\n\nenum\n{\n   STBTE__cexpander,\n   STBTE__ctoolbar,\n   STBTE__ctoolbar_button,\n   STBTE__cpanel,\n   STBTE__cpanel_sider,\n   STBTE__cpanel_sizer,\n   STBTE__cscrollbar,\n   STBTE__cmapsize,\n   STBTE__clayer_button,\n   STBTE__clayer_hide,\n   STBTE__clayer_lock,\n   STBTE__clayer_solo,\n   STBTE__ccategory_button,\n\n   STBTE__num_color_modes,\n};\n\n#ifdef STBTE__COLORPICKER\nstatic char *stbte__color_names[] =\n{\n   \"expander\", \"toolbar\", \"tool button\", \"panel\",\n   \"panel c1\", \"panel c2\", \"scollbar\", \"map button\",\n   \"layer\", \"hide\", \"lock\", \"solo\",\n   \"category\",\n};\n#endif // STBTE__COLORPICKER\n\n      // idle,    over,     down,    over&down, selected, sel&over, disabled\nstatic int stbte__color_table[STBTE__num_color_modes][STBTE__num_color_aspects][STBTE__num_color_states] =\n{\n   {\n      { 0x000000, 0x84987c, 0xdcdca8, 0xdcdca8, 0x40c040, 0x60d060, 0x505050, },\n      { 0xa4b090, 0xe0ec80, 0xffffc0, 0xffffc0, 0x80ff80, 0x80ff80, 0x606060, },\n      { 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0x808890, 0x606060, 0x606060, 0x606060, 0x606060, 0x606060, 0x606060, },\n      { 0x605860, 0x606060, 0x606060, 0x606060, 0x606060, 0x606060, 0x606060, },\n      { 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, },\n   }, {\n      { 0x3c5068, 0x7088a8, 0x647488, 0x94b4dc, 0x8890c4, 0x9caccc, 0x404040, },\n      { 0x889cb8, 0x889cb8, 0x889cb8, 0x889cb8, 0x84c4e8, 0xacc8ff, 0x0c0c08, },\n      { 0xbcc4cc, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x707074, },\n   }, {\n      { 0x403848, 0x403010, 0x403010, 0x403010, 0x403010, 0x403010, 0x303024, },\n      { 0x68546c, 0xc08040, 0xc08040, 0xc08040, 0xc08040, 0xc08040, 0x605030, },\n      { 0xf4e4ff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0xb4b04c, 0xacac60, 0xc0ffc0, 0xc0ffc0, 0x40c040, 0x60d060, 0x505050, },\n      { 0xa0a04c, 0xd0d04c, 0xffff80, 0xffff80, 0x80ff80, 0x80ff80, 0x606060, },\n      { 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0x40c440, 0x60d060, 0xc0ffc0, 0xc0ffc0, 0x40c040, 0x60d060, 0x505050, },\n      { 0x40c040, 0x80ff80, 0x80ff80, 0x80ff80, 0x80ff80, 0x80ff80, 0x606060, },\n      { 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0x9090ac, 0xa0a0b8, 0xbcb8cc, 0xbcb8cc, 0x909040, 0x909040, 0x909040, },\n      { 0xa0a0b8, 0xb0b4d0, 0xa0a0b8, 0xa0a0b8, 0xa0a050, 0xa0a050, 0xa0a050, },\n      { 0x808088, 0x808030, 0x808030, 0x808030, 0x808030, 0x808030, 0x808030, },\n   }, {\n      { 0x704c70, 0x885c8c, 0x9c68a4, 0xb870bc, 0xb490bc, 0xb490bc, 0x302828, },\n      { 0x646064, 0xcca8d4, 0xc060c0, 0xa07898, 0xe0b8e0, 0xe0b8e0, 0x403838, },\n      { 0xdccce4, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0x704c70, 0x885c8c, 0x9c68a4, 0xb870bc, 0xb490bc, 0xb490bc, 0x302828, },\n      { 0xb09cb4, 0xcca8d4, 0xc060c0, 0xa07898, 0xe0b8e0, 0xe0b8e0, 0x403838, },\n      { 0xdccce4, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x909090, },\n   }, {\n      { 0x646494, 0x888cb8, 0xb0b0b0, 0xb0b0cc, 0x9c9cf4, 0x8888b0, 0x50506c, },\n      { 0x9090a4, 0xb0b4d4, 0xb0b0dc, 0xb0b0cc, 0xd0d0fc, 0xd0d4f0, 0x606060, },\n      { 0xb4b4d4, 0xe4e4ff, 0xffffff, 0xffffff, 0xe0e4ff, 0xececff, 0x909090, },\n   }, {\n      { 0x646444, 0x888c64, 0xb0b0b0, 0xb0b088, 0xaca858, 0x88886c, 0x505050, },\n      { 0x88886c, 0xb0b490, 0xb0b0b0, 0xb0b088, 0xd8d898, 0xd0d4b0, 0x606060, },\n      { 0xb4b49c, 0xffffd8, 0xffffff, 0xffffd4, 0xffffdc, 0xffffcc, 0x909090, },\n   }, {\n      { 0x906464, 0xb48c8c, 0xd4b0b0, 0xdcb0b0, 0xff9c9c, 0xc88888, 0x505050, },\n      { 0xb47c80, 0xd4b4b8, 0xc4a8a8, 0xdcb0b0, 0xffc0c0, 0xfce8ec, 0x606060, },\n      { 0xe0b4b4, 0xffdcd8, 0xffd8d4, 0xffe0e4, 0xffece8, 0xffffff, 0x909090, },\n   }, {\n      { 0x403848, 0x403848, 0x403848, 0x886894, 0x7c80c8, 0x7c80c8, 0x302828, },\n      { 0x403848, 0x403848, 0x403848, 0x403848, 0x7c80c8, 0x7c80c8, 0x403838, },\n      { 0xc8c4c8, 0xffffff, 0xffffff, 0xffffff, 0xe8e8ec, 0xffffff, 0x909090, },\n   },\n};\n\n#define STBTE_COLOR_TILEMAP_BACKGROUND      0x000000\n#define STBTE_COLOR_TILEMAP_BORDER          0x203060\n#define STBTE_COLOR_TILEMAP_HIGHLIGHT       0xffffff\n#define STBTE_COLOR_GRID                    0x404040\n#define STBTE_COLOR_SELECTION_OUTLINE1      0xdfdfdf\n#define STBTE_COLOR_SELECTION_OUTLINE2      0x303030\n#define STBTE_COLOR_TILEPALETTE_OUTLINE     0xffffff\n#define STBTE_COLOR_TILEPALETTE_BACKGROUND  0x000000\n\n#ifndef STBTE_LINK_COLOR\n#define STBTE_LINK_COLOR(src,sp,dest,dp)    0x5030ff\n#endif\n\n#ifndef STBTE_LINK_COLOR_DRAWING\n#define STBTE_LINK_COLOR_DRAWING            0xff40ff\n#endif\n\n#ifndef STBTE_LINK_COLOR_DISALLOWED\n#define STBTE_LINK_COLOR_DISALLOWED         0x602060\n#endif\n\n\n// disabled, selected, down, over\nstatic unsigned char stbte__state_to_index[2][2][2][2] =\n{\n   {\n      { { STBTE__idle    , STBTE__over          }, { STBTE__down    , STBTE__over_down }, },\n      { { STBTE__selected, STBTE__selected_over }, { STBTE__down    , STBTE__over_down }, },\n   },{\n      { { STBTE__disabled, STBTE__disabled      }, { STBTE__disabled, STBTE__disabled  }, },\n      { { STBTE__selected, STBTE__selected_over }, { STBTE__disabled, STBTE__disabled  }, },\n   }\n};\n#define STBTE__INDEX_FOR_STATE(disable,select,down,over) stbte__state_to_index[disable][select][down][over]\n#define STBTE__INDEX_FOR_ID(id,disable,select) STBTE__INDEX_FOR_STATE(disable,select,STBTE__IS_ACTIVE(id),STBTE__IS_HOT(id))\n\n#define STBTE__FONT_HEIGHT    9\nstatic short stbte__font_offset[95+16];\nstatic short stbte__fontdata[769] =\n{\n   4,9,6,9,9,9,9,8,9,8,4,9,7,7,7,7,4,2,6,8,6,6,7,3,4,4,8,6,3,6,2,6,6,6,6,6,6,\n   6,6,6,6,6,2,3,5,4,5,6,6,6,6,6,6,6,6,6,6,6,6,7,6,7,7,7,6,7,6,6,6,6,7,7,6,6,\n   6,4,6,4,7,7,3,6,6,5,6,6,5,6,6,4,5,6,4,7,6,6,6,6,6,6,6,6,6,7,6,6,6,5,2,5,8,\n   0,0,0,0,2,253,130,456,156,8,72,184,64,2,125,66,64,160,64,146,511,146,146,\n   511,146,146,511,146,511,257,341,297,341,297,341,257,511,16,56,124,16,16,16,\n   124,56,16,96,144,270,261,262,136,80,48,224,192,160,80,40,22,14,15,3,448,496,\n   496,240,232,20,10,5,2,112,232,452,450,225,113,58,28,63,30,60,200,455,257,\n   257,0,0,0,257,257,455,120,204,132,132,159,14,4,4,14,159,132,132,204,120,8,\n   24,56,120,56,24,8,32,48,56,60,56,48,32,0,0,0,0,111,111,7,7,0,0,7,7,34,127,\n   127,34,34,127,127,34,36,46,107,107,58,18,99,51,24,12,102,99,48,122,79,93,\n   55,114,80,4,7,3,62,127,99,65,65,99,127,62,8,42,62,28,28,62,42,8,8,8,62,62,\n   8,8,128,224,96,8,8,8,8,8,8,96,96,96,48,24,12,6,3,62,127,89,77,127,62,64,66,\n   127,127,64,64,98,115,89,77,71,66,33,97,73,93,119,35,24,28,22,127,127,16,39,\n   103,69,69,125,57,62,127,73,73,121,48,1,1,113,121,15,7,54,127,73,73,127,54,\n   6,79,73,105,63,30,54,54,128,246,118,8,28,54,99,65,20,20,20,20,65,99,54,28,\n   8,2,3,105,109,7,2,30,63,33,45,47,46,124,126,19,19,126,124,127,127,73,73,127,\n   54,62,127,65,65,99,34,127,127,65,99,62,28,127,127,73,73,73,65,127,127,9,9,\n   9,1,62,127,65,73,121,121,127,127,8,8,127,127,65,65,127,127,65,65,32,96,64,\n   64,127,63,127,127,8,28,54,99,65,127,127,64,64,64,64,127,127,6,12,6,127,127,\n   127,127,6,12,24,127,127,62,127,65,65,65,127,62,127,127,9,9,15,6,62,127,65,\n   81,49,127,94,127,127,9,25,127,102,70,79,73,73,121,49,1,1,127,127,1,1,63,127,\n   64,64,127,63,15,31,48,96,48,31,15,127,127,48,24,48,127,127,99,119,28,28,119,\n   99,7,15,120,120,15,7,97,113,89,77,71,67,127,127,65,65,3,6,12,24,48,96,65,\n   65,127,127,8,12,6,3,6,12,8,64,64,64,64,64,64,64,3,7,4,32,116,84,84,124,120,\n   127,127,68,68,124,56,56,124,68,68,68,56,124,68,68,127,127,56,124,84,84,92,\n   24,8,124,126,10,10,56,380,324,324,508,252,127,127,4,4,124,120,72,122,122,\n   64,256,256,256,506,250,126,126,16,56,104,64,66,126,126,64,124,124,24,56,28,\n   124,120,124,124,4,4,124,120,56,124,68,68,124,56,508,508,68,68,124,56,56,124,\n   68,68,508,508,124,124,4,4,12,8,72,92,84,84,116,36,4,4,62,126,68,68,60,124,\n   64,64,124,124,28,60,96,96,60,28,28,124,112,56,112,124,28,68,108,56,56,108,\n   68,284,316,352,320,508,252,68,100,116,92,76,68,8,62,119,65,65,127,127,65,\n   65,119,62,8,16,24,12,12,24,24,12,4,\n};\n\ntypedef struct\n{\n   short id;\n   unsigned short category_id;\n   char *category;\n   unsigned int layermask;\n} stbte__tileinfo;\n\n#define MAX_LAYERMASK    (1 << (8*sizeof(unsigned int)))\n\ntypedef short stbte__tiledata;\n\n#define STBTE__NO_TILE   -1\n\nenum\n{\n   STBTE__panel_toolbar,\n   STBTE__panel_colorpick,\n   STBTE__panel_info,\n   STBTE__panel_layers,\n   STBTE__panel_props,\n   STBTE__panel_categories,\n   STBTE__panel_tiles,\n\n   STBTE__num_panel,\n};\n\nenum\n{\n   STBTE__side_left,\n   STBTE__side_right,\n   STBTE__side_top,\n   STBTE__side_bottom,\n};\n\nenum\n{\n   STBTE__tool_select,\n   STBTE__tool_brush,\n   STBTE__tool_erase,\n   STBTE__tool_rect,\n   STBTE__tool_eyedrop,\n   STBTE__tool_fill,\n   STBTE__tool_link,\n\n   STBTE__tool_showgrid,\n   STBTE__tool_showlinks,\n\n   STBTE__tool_undo,\n   STBTE__tool_redo,\n   // copy/cut/paste aren't included here because they're displayed differently\n\n   STBTE__num_tool,\n};\n\n// icons are stored in the 0-31 range of ASCII in the font\nstatic int toolchar[] = { 26,24,25,20,23,22,18, 19,17, 29,28, };\n\nenum\n{\n   STBTE__propmode_default,\n   STBTE__propmode_always,\n   STBTE__propmode_never,\n};\n\nenum\n{\n   STBTE__paint,\n\n   // from here down does hittesting\n   STBTE__tick,\n   STBTE__mousemove,\n   STBTE__mousewheel,\n   STBTE__leftdown,\n   STBTE__leftup,\n   STBTE__rightdown,\n   STBTE__rightup,\n};\n\ntypedef struct\n{\n   int expanded, mode;\n   int delta_height;     // number of rows they've requested for this\n   int side;\n   int width,height;\n   int x0,y0;\n} stbte__panel;\n\ntypedef struct\n{\n   int x0,y0,x1,y1,color;\n} stbte__colorrect;\n\n#define STBTE__MAX_DELAYRECT 256\n\ntypedef struct\n{\n   int tool, active_event;\n   int active_id, hot_id, next_hot_id;\n   int event;\n   int mx,my, dx,dy;\n   int ms_time;\n   int shift, scrollkey;\n   int initted;\n   int side_extended[2];\n   stbte__colorrect delayrect[STBTE__MAX_DELAYRECT];\n   int delaycount;\n   int show_grid, show_links;\n   int brush_state; // used to decide which kind of erasing\n   int eyedrop_x, eyedrop_y, eyedrop_last_layer;\n   int pasting, paste_x, paste_y;\n   int scrolling, start_x, start_y;\n   int last_mouse_x, last_mouse_y;\n   int accum_x, accum_y;\n   int linking;\n   int dragging;\n   int drag_x, drag_y, drag_w, drag_h;\n   int drag_offx, drag_offy, drag_dest_x, drag_dest_y;\n   int undoing;\n   int has_selection, select_x0, select_y0, select_x1, select_y1;\n   int sx,sy;\n   int x0,y0,x1,y1, left_width, right_width; // configurable widths\n   float alert_timer;\n   const char *alert_msg;\n   float dt;\n   stbte__panel panel[STBTE__num_panel];\n   short copybuffer[STBTE_MAX_COPY][STBTE_MAX_LAYERS];\n   float copyprops[STBTE_MAX_COPY][STBTE_MAX_PROPERTIES];\n#ifdef STBTE_ALLOW_LINK\n   stbte__link copylinks[STBTE_MAX_COPY];\n#endif\n   int copy_src_x, copy_src_y;\n   stbte_tilemap *copy_src;\n   int copy_width,copy_height,has_copy,copy_has_props;\n} stbte__ui_t;\n\n// there's only one UI system at a time, so we can globalize this\nstatic stbte__ui_t stbte__ui = { STBTE__tool_brush, 0 };\n\n#define STBTE__INACTIVE()     (stbte__ui.active_id == 0)\n#define STBTE__IS_ACTIVE(id)  (stbte__ui.active_id == (id))\n#define STBTE__IS_HOT(id)     (stbte__ui.hot_id    == (id))\n\n#define STBTE__BUTTON_HEIGHT            (STBTE__FONT_HEIGHT + 2 * STBTE__BUTTON_INTERNAL_SPACING)\n#define STBTE__BUTTON_INTERNAL_SPACING  (2 + (STBTE__FONT_HEIGHT>>4))\n\ntypedef struct\n{\n   const char *name;\n   int locked;\n   int hidden;\n} stbte__layer;\n\nenum\n{\n   STBTE__unlocked,\n   STBTE__protected,\n   STBTE__locked,\n};\n\nstruct stbte_tilemap\n{\n    stbte__tiledata data[STBTE_MAX_TILEMAP_Y][STBTE_MAX_TILEMAP_X][STBTE_MAX_LAYERS];\n    float props[STBTE_MAX_TILEMAP_Y][STBTE_MAX_TILEMAP_X][STBTE_MAX_PROPERTIES];\n    #ifdef STBTE_ALLOW_LINK\n    stbte__link link[STBTE_MAX_TILEMAP_Y][STBTE_MAX_TILEMAP_X];\n    int linkcount[STBTE_MAX_TILEMAP_Y][STBTE_MAX_TILEMAP_X];\n    #endif\n    int max_x, max_y, num_layers;\n    int spacing_x, spacing_y;\n    int palette_spacing_x, palette_spacing_y;\n    int scroll_x,scroll_y;\n    int cur_category, cur_tile, cur_layer;\n    char *categories[STBTE_MAX_CATEGORIES];\n    int num_categories, category_scroll;\n    stbte__tileinfo *tiles;\n    int num_tiles, max_tiles, digits;\n    unsigned char undo_available_valid;\n    unsigned char undo_available;\n    unsigned char redo_available;\n    unsigned char padding;\n    int cur_palette_count;\n    int palette_scroll;\n    int tileinfo_dirty;\n    stbte__layer layerinfo[STBTE_MAX_LAYERS];\n    int has_layer_names;\n    int layername_width;\n    int layer_scroll;\n    int propmode;\n    int solo_layer;\n    int undo_pos, undo_len, redo_len;\n    short background_tile;\n    unsigned char id_in_use[32768>>3];\n    short *undo_buffer;\n};\n\nstatic char *default_category = (char*) \"[unassigned]\";\n\nstatic void stbte__init_gui(void)\n{\n   int i,n;\n   stbte__ui.initted = 1;\n   // init UI state\n   stbte__ui.show_links = 1;\n   for (i=0; i < STBTE__num_panel; ++i) {\n      stbte__ui.panel[i].expanded     = 1; // visible if not autohidden\n      stbte__ui.panel[i].delta_height = 0;\n      stbte__ui.panel[i].side         = STBTE__side_left;\n   }\n   stbte__ui.panel[STBTE__panel_toolbar  ].side = STBTE__side_top;\n   stbte__ui.panel[STBTE__panel_colorpick].side = STBTE__side_right;\n\n   if (stbte__ui.left_width == 0)\n      stbte__ui.left_width = 80;\n   if (stbte__ui.right_width == 0)\n      stbte__ui.right_width = 80;\n\n   // init font\n   n=95+16;\n   for (i=0; i < 95+16; ++i) {\n      stbte__font_offset[i] = n;\n      n += stbte__fontdata[i];\n   }\n}\n\nstbte_tilemap *stbte_create_map(int map_x, int map_y, int map_layers, int spacing_x, int spacing_y, int max_tiles)\n{\n   int i;\n   stbte_tilemap *tm;\n   STBTE_ASSERT(map_layers >= 0 && map_layers <= STBTE_MAX_LAYERS);\n   STBTE_ASSERT(map_x >= 0 && map_x <= STBTE_MAX_TILEMAP_X);\n   STBTE_ASSERT(map_y >= 0 && map_y <= STBTE_MAX_TILEMAP_Y);\n   if (map_x < 0 || map_y < 0 || map_layers < 0 ||\n       map_x > STBTE_MAX_TILEMAP_X || map_y > STBTE_MAX_TILEMAP_Y || map_layers > STBTE_MAX_LAYERS)\n      return NULL;\n\n   if (!stbte__ui.initted)\n      stbte__init_gui();\n\n   tm = (stbte_tilemap *) malloc(sizeof(*tm) + sizeof(*tm->tiles) * max_tiles + STBTE_UNDO_BUFFER_BYTES);\n   if (tm == NULL)\n      return NULL;\n\n   tm->tiles = (stbte__tileinfo *) (tm+1);\n   tm->undo_buffer = (short *) (tm->tiles + max_tiles);\n   tm->num_layers = map_layers;\n   tm->max_x = map_x;\n   tm->max_y = map_y;\n   tm->spacing_x = spacing_x;\n   tm->spacing_y = spacing_y;\n   tm->scroll_x = 0;\n   tm->scroll_y = 0;\n   tm->palette_scroll = 0;\n   tm->palette_spacing_x = spacing_x+1;\n   tm->palette_spacing_y = spacing_y+1;\n   tm->cur_category = -1;\n   tm->cur_tile = 0;\n   tm->solo_layer = -1;\n   tm->undo_len = 0;\n   tm->redo_len = 0;\n   tm->undo_pos = 0;\n   tm->category_scroll = 0;\n   tm->layer_scroll = 0;\n   tm->propmode = 0;\n   tm->has_layer_names = 0;\n   tm->layername_width = 0;\n   tm->undo_available_valid = 0;\n\n   for (i=0; i < tm->num_layers; ++i) {\n      tm->layerinfo[i].hidden = 0;\n      tm->layerinfo[i].locked = STBTE__unlocked;\n      tm->layerinfo[i].name   = 0;\n   }\n\n   tm->background_tile = STBTE__NO_TILE;\n   stbte_clear_map(tm);\n\n   tm->max_tiles = max_tiles;\n   tm->num_tiles = 0;\n   for (i=0; i < 32768/8; ++i)\n      tm->id_in_use[i] = 0;\n   tm->tileinfo_dirty = 1;\n   return tm;\n}\n\nvoid stbte_set_background_tile(stbte_tilemap *tm, short id)\n{\n   int i;\n   STBTE_ASSERT(id >= -1);\n   // STBTE_ASSERT(id < 32768);\n   if (id < -1)\n      return;\n   for (i=0; i < STBTE_MAX_TILEMAP_X * STBTE_MAX_TILEMAP_Y; ++i)\n      if (tm->data[0][i][0] == -1)\n         tm->data[0][i][0] = id;\n   tm->background_tile = id;\n}\n\nvoid stbte_set_spacing(stbte_tilemap *tm, int spacing_x, int spacing_y, int palette_spacing_x, int palette_spacing_y)\n{\n   tm->spacing_x = spacing_x;\n   tm->spacing_y = spacing_y;\n   tm->palette_spacing_x = palette_spacing_x;\n   tm->palette_spacing_y = palette_spacing_y;\n}\n\nvoid stbte_set_sidewidths(int left, int right)\n{\n   stbte__ui.left_width  = left;\n   stbte__ui.right_width = right;\n}\n\nvoid stbte_set_display(int x0, int y0, int x1, int y1)\n{\n   stbte__ui.x0 = x0;\n   stbte__ui.y0 = y0;\n   stbte__ui.x1 = x1;\n   stbte__ui.y1 = y1;\n}\n\nvoid stbte_define_tile(stbte_tilemap *tm, unsigned short id, unsigned int layermask, const char * category_c)\n{\n   char *category = (char *) category_c;\n   STBTE_ASSERT(id < 32768);\n   STBTE_ASSERT(tm->num_tiles < tm->max_tiles);\n   STBTE_ASSERT((tm->id_in_use[id>>3]&(1<<(id&7))) == 0);\n   if (id >= 32768 || tm->num_tiles >= tm->max_tiles || (tm->id_in_use[id>>3]&(1<<(id&7))))\n      return;\n\n   if (category == NULL)\n      category = (char*) default_category;\n   tm->id_in_use[id>>3] |= 1 << (id&7);\n   tm->tiles[tm->num_tiles].category    = category;\n   tm->tiles[tm->num_tiles].id        = id;\n   tm->tiles[tm->num_tiles].layermask = layermask;\n   ++tm->num_tiles;\n   tm->tileinfo_dirty = 1;\n}\n\nstatic int stbte__text_width(const char *str);\n\nvoid stbte_set_layername(stbte_tilemap *tm, int layer, const char *layername)\n{\n   STBTE_ASSERT(layer >= 0 && layer < tm->num_layers);\n   if (layer >= 0 && layer < tm->num_layers) {\n      int width;\n      tm->layerinfo[layer].name = layername;\n      tm->has_layer_names = 1;\n      width = stbte__text_width(layername);\n      tm->layername_width = (width > tm->layername_width ? width : tm->layername_width);\n   }\n}\n\nvoid stbte_get_dimensions(stbte_tilemap *tm, int *max_x, int *max_y)\n{\n   *max_x = tm->max_x;\n   *max_y = tm->max_y;\n}\n\nshort* stbte_get_tile(stbte_tilemap *tm, int x, int y)\n{\n   STBTE_ASSERT(x >= 0 && x < tm->max_x && y >= 0 && y < tm->max_y);\n   if (x < 0 || x >= STBTE_MAX_TILEMAP_X || y < 0 || y >= STBTE_MAX_TILEMAP_Y)\n      return NULL;\n   return tm->data[y][x];\n}\n\nfloat *stbte_get_properties(stbte_tilemap *tm, int x, int y)\n{\n   STBTE_ASSERT(x >= 0 && x < tm->max_x && y >= 0 && y < tm->max_y);\n   if (x < 0 || x >= STBTE_MAX_TILEMAP_X || y < 0 || y >= STBTE_MAX_TILEMAP_Y)\n      return NULL;\n   return tm->props[y][x];\n}\n\nvoid stbte_get_link(stbte_tilemap *tm, int x, int y, int *destx, int *desty)\n{\n   int gx=-1,gy=-1;\n   STBTE_ASSERT(x >= 0 && x < tm->max_x && y >= 0 && y < tm->max_y);\n#ifdef STBTE_ALLOW_LINK\n   if (x >= 0 && x < STBTE_MAX_TILEMAP_X && y >= 0 && y < STBTE_MAX_TILEMAP_Y) {\n      gx = tm->link[y][x].x;\n      gy = tm->link[y][x].y;\n      if (gx >= 0)\n         if (!STBTE_ALLOW_LINK(tm->data[y][x], tm->props[y][x], tm->data[gy][gx], tm->props[gy][gx]))\n            gx = gy = -1;\n   }\n#endif\n   *destx = gx;\n   *desty = gy;\n}\n\nvoid stbte_set_property(stbte_tilemap *tm, int x, int y, int n, float val)\n{\n   tm->props[y][x][n] = val;\n}\n\n#ifdef STBTE_ALLOW_LINK\nstatic void stbte__set_link(stbte_tilemap *tm, int src_x, int src_y, int dest_x, int dest_y, int undo_mode);\n#endif\n\nenum\n{\n   STBTE__undo_none,\n   STBTE__undo_record,\n   STBTE__undo_block,\n};\n\nvoid stbte_set_link(stbte_tilemap *tm, int x, int y, int destx, int desty)\n{\n#ifdef STBTE_ALLOW_LINK\n   stbte__set_link(tm, x, y, destx, desty, STBTE__undo_none);\n#else\n   STBTE_ASSERT(0);\n#endif\n}\n\n\n// returns an array of map_layers shorts. each short is either\n// one of the tile_id values from define_tile, or STBTE_EMPTY\n\nvoid stbte_set_dimensions(stbte_tilemap *tm, int map_x, int map_y)\n{\n   STBTE_ASSERT(map_x >= 0 && map_x <= STBTE_MAX_TILEMAP_X);\n   STBTE_ASSERT(map_y >= 0 && map_y <= STBTE_MAX_TILEMAP_Y);\n   if (map_x < 0 || map_y < 0 || map_x > STBTE_MAX_TILEMAP_X || map_y > STBTE_MAX_TILEMAP_Y)\n      return;\n   tm->max_x = map_x;\n   tm->max_y = map_y;\n}\n\nvoid stbte_clear_map(stbte_tilemap *tm)\n{\n   int i,j;\n   for (i=0; i < STBTE_MAX_TILEMAP_X * STBTE_MAX_TILEMAP_Y; ++i) {\n      tm->data[0][i][0] = tm->background_tile;\n      for (j=1; j < tm->num_layers; ++j)\n         tm->data[0][i][j] = STBTE__NO_TILE;\n      for (j=0; j < STBTE_MAX_PROPERTIES; ++j)\n         tm->props[0][i][j] = 0;\n      #ifdef STBTE_ALLOW_LINK\n      tm->link[0][i].x = -1;\n      tm->link[0][i].y = -1;\n      tm->linkcount[0][i] = 0;\n      #endif\n   }\n}\n\nvoid stbte_set_tile(stbte_tilemap *tm, int x, int y, int layer, signed short tile)\n{\n   STBTE_ASSERT(x >= 0 && x < tm->max_x && y >= 0 && y < tm->max_y);\n   STBTE_ASSERT(layer >= 0 && layer < tm->num_layers);\n   STBTE_ASSERT(tile >= -1);\n   //STBTE_ASSERT(tile < 32768);\n   if (x < 0 || x >= STBTE_MAX_TILEMAP_X || y < 0 || y >= STBTE_MAX_TILEMAP_Y)\n      return;\n   if (layer < 0 || layer >= tm->num_layers || tile < -1)\n      return;\n   tm->data[y][x][layer] = tile;\n}\n\nstatic void stbte__choose_category(stbte_tilemap *tm, int category)\n{\n   int i,n=0;\n   tm->cur_category = category;\n   for (i=0; i < tm->num_tiles; ++i)\n      if (tm->tiles[i].category_id == category || category == -1)\n         ++n;\n   tm->cur_palette_count = n;\n   tm->palette_scroll = 0;\n}\n\nstatic int stbte__strequal(char *p, char *q)\n{\n   while (*p)\n      if (*p++ != *q++) return 0;\n   return *q == 0;\n}\n\nstatic void stbte__compute_tileinfo(stbte_tilemap *tm)\n{\n   int i,j;\n\n   tm->num_categories=0;\n\n   for (i=0; i < tm->num_tiles; ++i) {\n      stbte__tileinfo *t = &tm->tiles[i];\n      // find category\n      for (j=0; j < tm->num_categories; ++j)\n         if (stbte__strequal(t->category, tm->categories[j]))\n            goto found;\n      tm->categories[j] = t->category;\n      ++tm->num_categories;\n     found:\n      t->category_id = (unsigned short) j;\n   }\n\n   // currently number of categories can never decrease because you\n   // can't remove tile definitions, but let's get it right anyway\n   if (tm->cur_category > tm->num_categories) {\n      tm->cur_category = -1;\n   }\n\n   stbte__choose_category(tm, tm->cur_category);\n\n   tm->tileinfo_dirty = 0;\n}\n\nstatic void stbte__prepare_tileinfo(stbte_tilemap *tm)\n{\n   if (tm->tileinfo_dirty)\n      stbte__compute_tileinfo(tm);\n}\n\n\n/////////////////////// undo system ////////////////////////\n\n// the undo system works by storing \"commands\" into a buffer, and\n// then playing back those commands. undo and redo have to store\n// the commands in different order.\n//\n// the commands are:\n//\n// 1)  end_of_undo_record\n//       -1:short\n//\n// 2)  end_of_redo_record\n//       -2:short\n//\n// 3)  tile update\n//       tile_id:short (-1..32767)\n//       x_coord:short\n//       y_coord:short\n//       layer:short (0..31)\n//\n// 4)  property update (also used for links)\n//       value_hi:short\n//       value_lo:short\n//       y_coord:short\n//       x_coord:short\n//       property:short (256+prop#)\n//\n// Since we use a circular buffer, we might overwrite the undo storage.\n// To detect this, before playing back commands we scan back and see\n// if we see an end_of_undo_record before hitting the relevant boundary,\n// it's wholly contained.\n//\n// When we read back through, we see them in reverse order, so\n// we'll see the layer number or property number first\n//\n// To be clearer about the circular buffer, there are two cases:\n//     1. a single record is larger than the whole buffer.\n//        this is caught because the end_of_undo_record will\n//        get overwritten.\n//     2. multiple records written are larger than the whole\n//        buffer, so some of them have been overwritten by\n//        the later ones. this is handled by explicitly tracking\n//        the undo length; we never try to parse the data that\n//        got overwritten\n\n// given two points, compute the length between them\n#define stbte__wrap(pos)            ((pos) & (STBTE__UNDO_BUFFER_COUNT-1))\n\n#define STBTE__undo_record  -2\n#define STBTE__redo_record  -3\n#define STBTE__undo_junk    -4  // this is written underneath the undo pointer, never used\n\nstatic void stbte__write_undo(stbte_tilemap *tm, short value)\n{\n   int pos = tm->undo_pos;\n   tm->undo_buffer[pos] = value;\n   tm->undo_pos = stbte__wrap(pos+1);\n   tm->undo_len += (tm->undo_len < STBTE__UNDO_BUFFER_COUNT-2);\n   tm->redo_len -= (tm->redo_len > 0);\n   tm->undo_available_valid = 0;\n}\n\nstatic void stbte__write_redo(stbte_tilemap *tm, short value)\n{\n   int pos = tm->undo_pos;\n   tm->undo_buffer[pos] = value;\n   tm->undo_pos = stbte__wrap(pos-1);\n   tm->redo_len += (tm->redo_len < STBTE__UNDO_BUFFER_COUNT-2);\n   tm->undo_len -= (tm->undo_len > 0);\n   tm->undo_available_valid = 0;\n}\n\nstatic void stbte__begin_undo(stbte_tilemap *tm)\n{\n   tm->redo_len = 0;\n   stbte__write_undo(tm, STBTE__undo_record);\n   stbte__ui.undoing = 1;\n   stbte__ui.alert_msg = 0; // clear alert if they start doing something\n}\n\nstatic void stbte__end_undo(stbte_tilemap *tm)\n{\n   if (stbte__ui.undoing) {\n      // check if anything got written\n      int pos = stbte__wrap(tm->undo_pos-1);\n      if (tm->undo_buffer[pos] == STBTE__undo_record) {\n         // empty undo record, move back\n         tm->undo_pos = pos;\n         STBTE_ASSERT(tm->undo_len > 0);\n         tm->undo_len -= 1;\n      }\n      tm->undo_buffer[tm->undo_pos] = STBTE__undo_junk;\n      // otherwise do nothing\n\n      stbte__ui.undoing = 0;\n   }\n}\n\nstatic void stbte__undo_record(stbte_tilemap *tm, int x, int y, int i, int v)\n{\n   STBTE_ASSERT(stbte__ui.undoing);\n   if (stbte__ui.undoing) {\n      stbte__write_undo(tm, v);\n      stbte__write_undo(tm, x);\n      stbte__write_undo(tm, y);\n      stbte__write_undo(tm, i);\n   }\n}\n\nstatic void stbte__redo_record(stbte_tilemap *tm, int x, int y, int i, int v)\n{\n   stbte__write_redo(tm, v);\n   stbte__write_redo(tm, x);\n   stbte__write_redo(tm, y);\n   stbte__write_redo(tm, i);\n}\n\nstatic float stbte__extract_float(short s0, short s1)\n{\n   union { float f; short s[2]; } converter;\n   converter.s[0] = s0;\n   converter.s[1] = s1;\n   return converter.f;\n}\n\nstatic short stbte__extract_short(float f, int slot)\n{\n   union { float f; short s[2]; } converter;\n   converter.f = f;\n   return converter.s[slot];\n}\n\nstatic void stbte__undo_record_prop(stbte_tilemap *tm, int x, int y, int i, short s0, short s1)\n{\n   STBTE_ASSERT(stbte__ui.undoing);\n   if (stbte__ui.undoing) {\n      stbte__write_undo(tm, s1);\n      stbte__write_undo(tm, s0);\n      stbte__write_undo(tm, x);\n      stbte__write_undo(tm, y);\n      stbte__write_undo(tm, 256+i);\n   }\n}\n\nstatic void stbte__undo_record_prop_float(stbte_tilemap *tm, int x, int y, int i, float f)\n{\n   stbte__undo_record_prop(tm, x,y,i, stbte__extract_short(f,0), stbte__extract_short(f,1));\n}\n\nstatic void stbte__redo_record_prop(stbte_tilemap *tm, int x, int y, int i, short s0, short s1)\n{\n   stbte__write_redo(tm, s1);\n   stbte__write_redo(tm, s0);\n   stbte__write_redo(tm, x);\n   stbte__write_redo(tm, y);\n   stbte__write_redo(tm, 256+i);\n}\n\n\nstatic int stbte__undo_find_end(stbte_tilemap *tm)\n{\n   // first scan through for the end record\n   int i, pos = stbte__wrap(tm->undo_pos-1);\n   for (i=0; i < tm->undo_len;) {\n      STBTE_ASSERT(tm->undo_buffer[pos] != STBTE__undo_junk);\n      if (tm->undo_buffer[pos] == STBTE__undo_record)\n         break;\n      if (tm->undo_buffer[pos] >= 255)\n         pos = stbte__wrap(pos-5), i += 5;\n      else\n         pos = stbte__wrap(pos-4), i += 4;\n   }\n   if (i >= tm->undo_len)\n      return -1;\n   return pos;\n}\n\nstatic void stbte__undo(stbte_tilemap *tm)\n{\n   int i, pos, endpos;\n   endpos = stbte__undo_find_end(tm);\n   if (endpos < 0)\n      return;\n\n   // we found a complete undo record\n   pos = stbte__wrap(tm->undo_pos-1);\n\n   // start a redo record\n   stbte__write_redo(tm, STBTE__redo_record);\n\n   // so now go back through undo and apply in reverse\n   // order, and copy it to redo\n   for (i=0; endpos != pos; i += 4) {\n      int x,y,n,v;\n      // get the undo entry\n      n = tm->undo_buffer[pos];\n      y = tm->undo_buffer[stbte__wrap(pos-1)];\n      x = tm->undo_buffer[stbte__wrap(pos-2)];\n      v = tm->undo_buffer[stbte__wrap(pos-3)];\n      if (n >= 255) {\n         short s0=0,s1=0;\n         int v2 = tm->undo_buffer[stbte__wrap(pos-4)];\n         pos = stbte__wrap(pos-5);\n         if (n > 255) {\n            float vf = stbte__extract_float(v, v2);\n            s0 = stbte__extract_short(tm->props[y][x][n-256], 0);\n            s1 = stbte__extract_short(tm->props[y][x][n-256], 1);\n            tm->props[y][x][n-256] = vf;\n         } else {\n#ifdef STBTE_ALLOW_LINK\n            s0 = tm->link[y][x].x;\n            s1 = tm->link[y][x].y;\n            stbte__set_link(tm, x,y, v, v2, STBTE__undo_none);\n#endif\n         }\n         // write the redo entry\n         stbte__redo_record_prop(tm, x, y, n-256, s0,s1);\n         // apply the undo entry\n      } else {\n         pos = stbte__wrap(pos-4);\n         // write the redo entry\n         stbte__redo_record(tm, x, y, n, tm->data[y][x][n]);\n         // apply the undo entry\n         tm->data[y][x][n] = (short) v;\n      }\n   }\n   // overwrite undo record with junk\n   tm->undo_buffer[tm->undo_pos] = STBTE__undo_junk;\n}\n\nstatic int stbte__redo_find_end(stbte_tilemap *tm)\n{\n   // first scan through for the end record\n   int i, pos = stbte__wrap(tm->undo_pos+1);\n   for (i=0; i < tm->redo_len;) {\n      STBTE_ASSERT(tm->undo_buffer[pos] != STBTE__undo_junk);\n      if (tm->undo_buffer[pos] == STBTE__redo_record)\n         break;\n      if (tm->undo_buffer[pos] >= 255)\n         pos = stbte__wrap(pos+5), i += 5;\n      else\n         pos = stbte__wrap(pos+4), i += 4;\n   }\n   if (i >= tm->redo_len)\n      return -1; // this should only ever happen if redo buffer is empty\n   return pos;\n}\n\nstatic void stbte__redo(stbte_tilemap *tm)\n{\n   // first scan through for the end record\n   int i, pos, endpos;\n   endpos = stbte__redo_find_end(tm);\n   if (endpos < 0)\n      return;\n\n   // we found a complete redo record\n   pos = stbte__wrap(tm->undo_pos+1);\n\n   // start an undo record\n   stbte__write_undo(tm, STBTE__undo_record);\n\n   for (i=0; pos != endpos; i += 4) {\n      int x,y,n,v;\n      n = tm->undo_buffer[pos];\n      y = tm->undo_buffer[stbte__wrap(pos+1)];\n      x = tm->undo_buffer[stbte__wrap(pos+2)];\n      v = tm->undo_buffer[stbte__wrap(pos+3)];\n      if (n >= 255) {\n         int v2 = tm->undo_buffer[stbte__wrap(pos+4)];\n         short s0=0,s1=0;\n         pos = stbte__wrap(pos+5);\n         if (n > 255) {\n            float vf = stbte__extract_float(v, v2);\n            s0 = stbte__extract_short(tm->props[y][x][n-256],0);\n            s1 = stbte__extract_short(tm->props[y][x][n-256],1);\n            tm->props[y][x][n-256] = vf;\n         } else {\n#ifdef STBTE_ALLOW_LINK\n            s0 = tm->link[y][x].x;\n            s1 = tm->link[y][x].y;\n            stbte__set_link(tm, x,y,v,v2, STBTE__undo_none);\n#endif\n         }\n         // don't use stbte__undo_record_prop because it's guarded\n         stbte__write_undo(tm, s1);\n         stbte__write_undo(tm, s0);\n         stbte__write_undo(tm, x);\n         stbte__write_undo(tm, y);\n         stbte__write_undo(tm, n);\n      } else {\n         pos = stbte__wrap(pos+4);\n         // don't use stbte__undo_record because it's guarded\n         stbte__write_undo(tm, tm->data[y][x][n]);\n         stbte__write_undo(tm, x);\n         stbte__write_undo(tm, y);\n         stbte__write_undo(tm, n);\n         tm->data[y][x][n] = (short) v;\n      }\n   }\n   tm->undo_buffer[tm->undo_pos] = STBTE__undo_junk;\n}\n\n// because detecting that undo is available\nstatic void stbte__recompute_undo_available(stbte_tilemap *tm)\n{\n   tm->undo_available = (stbte__undo_find_end(tm) >= 0);\n   tm->redo_available = (stbte__redo_find_end(tm) >= 0);\n}\n\nstatic int stbte__undo_available(stbte_tilemap *tm)\n{\n   if (!tm->undo_available_valid)\n      stbte__recompute_undo_available(tm);\n   return tm->undo_available;\n}\n\nstatic int stbte__redo_available(stbte_tilemap *tm)\n{\n   if (!tm->undo_available_valid)\n      stbte__recompute_undo_available(tm);\n   return tm->redo_available;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n#ifdef STBTE_ALLOW_LINK\nstatic void stbte__set_link(stbte_tilemap *tm, int src_x, int src_y, int dest_x, int dest_y, int undo_mode)\n{\n   stbte__link *a;\n   STBTE_ASSERT(src_x >= 0 && src_x < STBTE_MAX_TILEMAP_X && src_y >= 0 && src_y < STBTE_MAX_TILEMAP_Y);\n   a = &tm->link[src_y][src_x];\n   // check if it's a do nothing\n   if (a->x == dest_x && a->y == dest_y)\n      return;\n   if (undo_mode != STBTE__undo_none ) {\n      if (undo_mode == STBTE__undo_block) stbte__begin_undo(tm);\n      stbte__undo_record_prop(tm, src_x, src_y, -1, a->x, a->y);\n      if (undo_mode == STBTE__undo_block) stbte__end_undo(tm);\n   }\n   // check if there's an existing link\n   if (a->x >= 0) {\n      // decrement existing link refcount\n      STBTE_ASSERT(tm->linkcount[a->y][a->x] > 0);\n      --tm->linkcount[a->y][a->x];\n   }\n   // increment new dest\n   if (dest_x >= 0) {\n      ++tm->linkcount[dest_y][dest_x];\n   }\n   a->x = dest_x;\n   a->y = dest_y;\n}\n#endif\n\n\nstatic void stbte__draw_rect(int x0, int y0, int x1, int y1, unsigned int color)\n{\n   STBTE_DRAW_RECT(x0,y0,x1,y1, color);\n}\n\n#ifdef STBTE_ALLOW_LINK\nstatic void stbte__draw_line(int x0, int y0, int x1, int y1, unsigned int color)\n{\n   int temp;\n   if (x1 < x0) temp=x0,x0=x1,x1=temp;\n   if (y1 < y0) temp=y0,y0=y1,y1=temp;\n   stbte__draw_rect(x0,y0,x1+1,y1+1,color);\n}\n\nstatic void stbte__draw_link(int x0, int y0, int x1, int y1, unsigned int color)\n{\n   stbte__draw_line(x0,y0,x0,y1, color);\n   stbte__draw_line(x0,y1,x1,y1, color);\n}\n#endif\n\nstatic void stbte__draw_frame(int x0, int y0, int x1, int y1, unsigned int color)\n{\n   stbte__draw_rect(x0,y0,x1-1,y0+1,color);\n   stbte__draw_rect(x1-1,y0,x1,y1-1,color);\n   stbte__draw_rect(x0+1,y1-1,x1,y1,color);\n   stbte__draw_rect(x0,y0+1,x0+1,y1,color);\n}\n\nstatic int stbte__get_char_width(int ch)\n{\n   return stbte__fontdata[ch-16];\n}\n\nstatic short *stbte__get_char_bitmap(int ch)\n{\n   return stbte__fontdata + stbte__font_offset[ch-16];\n}\n\nstatic void stbte__draw_bitmask_as_columns(int x, int y, short bitmask, int color)\n{\n   int start_i = -1, i=0;\n   while (bitmask) {\n      if (bitmask & (1<<i)) {\n         if (start_i < 0)\n            start_i = i;\n      } else if (start_i >= 0) {\n         stbte__draw_rect(x, y+start_i, x+1, y+i, color);\n         start_i = -1;\n         bitmask &= ~((1<<i)-1); // clear all the old bits; we don't clear them as we go to save code\n      }\n      ++i;\n   }\n}\n\nstatic void stbte__draw_bitmap(int x, int y, int w, short *bitmap, int color)\n{\n   int i;\n   for (i=0; i < w; ++i)\n      stbte__draw_bitmask_as_columns(x+i, y, *bitmap++, color);\n}\n\nstatic void stbte__draw_text_core(int x, int y, const char *str, int w, int color, int digitspace)\n{\n   int x_end = x+w;\n   while (*str) {\n      int c = *str++;\n      int cw = stbte__get_char_width(c);\n      if (x + cw > x_end)\n         break;\n      stbte__draw_bitmap(x, y, cw, stbte__get_char_bitmap(c), color);\n      if (digitspace && c == ' ')\n         cw = stbte__get_char_width('0');\n      x += cw+1;\n   }\n}\n\nstatic void stbte__draw_text(int x, int y, const char *str, int w, int color)\n{\n   stbte__draw_text_core(x,y,str,w,color,0);\n}\n\nstatic int stbte__text_width(const char *str)\n{\n   int x = 0;\n   while (*str) {\n      int c = *str++;\n      int cw = stbte__get_char_width(c);\n      x += cw+1;\n   }\n   return x;\n}\n\nstatic void stbte__draw_frame_delayed(int x0, int y0, int x1, int y1, int color)\n{\n   if (stbte__ui.delaycount < STBTE__MAX_DELAYRECT) {\n      stbte__colorrect r = { x0,y0,x1,y1,color };\n      stbte__ui.delayrect[stbte__ui.delaycount++] = r;\n   }\n}\n\nstatic void stbte__flush_delay(void)\n{\n   stbte__colorrect *r;\n   int i;\n   r = stbte__ui.delayrect;\n   for (i=0; i < stbte__ui.delaycount; ++i,++r)\n      stbte__draw_frame(r->x0,r->y0,r->x1,r->y1,r->color);\n   stbte__ui.delaycount = 0;\n}\n\nstatic void stbte__activate(int id)\n{\n   stbte__ui.active_id = id;\n   stbte__ui.active_event = stbte__ui.event;\n   stbte__ui.accum_x = 0;\n   stbte__ui.accum_y = 0;\n}\n\nstatic int stbte__hittest(int x0, int y0, int x1, int y1, int id)\n{\n   int over =    stbte__ui.mx >= x0 && stbte__ui.my >= y0\n              && stbte__ui.mx <  x1 && stbte__ui.my <  y1;\n\n   if (over && stbte__ui.event >= STBTE__tick)\n      stbte__ui.next_hot_id = id;\n\n   return over;\n}\n\nstatic int stbte__button_core(int id)\n{\n   switch (stbte__ui.event) {\n      case STBTE__leftdown:\n         if (stbte__ui.hot_id == id && STBTE__INACTIVE())\n            stbte__activate(id);\n         break;\n      case STBTE__leftup:\n         if (stbte__ui.active_id == id && STBTE__IS_HOT(id)) {\n            stbte__activate(0);\n            return 1;\n         }\n         break;\n      case STBTE__rightdown:\n         if (stbte__ui.hot_id == id && STBTE__INACTIVE())\n            stbte__activate(id);\n         break;\n      case STBTE__rightup:\n         if (stbte__ui.active_id == id && STBTE__IS_HOT(id)) {\n            stbte__activate(0);\n            return -1;\n         }\n         break;\n   }\n   return 0;\n}\n\nstatic void stbte__draw_box(int x0, int y0, int x1, int y1, int colormode, int colorindex)\n{\n   stbte__draw_rect (x0,y0,x1,y1, stbte__color_table[colormode][STBTE__base   ][colorindex]);\n   stbte__draw_frame(x0,y0,x1,y1, stbte__color_table[colormode][STBTE__outline][colorindex]);\n}\n\nstatic void stbte__draw_textbox(int x0, int y0, int x1, int y1, char *text, int xoff, int yoff, int colormode, int colorindex)\n{\n   stbte__draw_box(x0,y0,x1,y1,colormode,colorindex);\n   stbte__draw_text(x0+xoff,y0+yoff, text, x1-x0-xoff-1, stbte__color_table[colormode][STBTE__text][colorindex]);\n}\n\nstatic int stbte__button(int colormode, const char *label, int x, int y, int textoff, int width, int id, int toggled, int disabled)\n{\n   int x0=x,y0=y, x1=x+width,y1=y+STBTE__BUTTON_HEIGHT;\n   int s = STBTE__BUTTON_INTERNAL_SPACING;\n\n   if(!disabled) stbte__hittest(x0,y0,x1,y1,id);\n\n   if (stbte__ui.event == STBTE__paint)\n      stbte__draw_textbox(x0,y0,x1,y1, (char*) label,s+textoff,s, colormode, STBTE__INDEX_FOR_ID(id,disabled,toggled));\n   if (disabled)\n      return 0;\n   return (stbte__button_core(id) == 1);\n}\n\nstatic int stbte__button_icon(int colormode, char ch, int x, int y, int width, int id, int toggled, int disabled)\n{\n   int x0=x,y0=y, x1=x+width,y1=y+STBTE__BUTTON_HEIGHT;\n   int s = STBTE__BUTTON_INTERNAL_SPACING;\n\n   stbte__hittest(x0,y0,x1,y1,id);\n\n   if (stbte__ui.event == STBTE__paint) {\n      char label[2] = { ch, 0 };\n      int pad = (9 - stbte__get_char_width(ch))/2;\n      stbte__draw_textbox(x0,y0,x1,y1, label,s+pad,s, colormode, STBTE__INDEX_FOR_ID(id,disabled,toggled));\n   }\n   if (disabled)\n      return 0;\n   return (stbte__button_core(id) == 1);\n}\n\nstatic int stbte__minibutton(int colormode, int x, int y, int ch, int id)\n{\n   int x0 = x, y0 = y, x1 = x+8, y1 = y+7;\n   stbte__hittest(x0,y0,x1,y1,id);\n   if (stbte__ui.event == STBTE__paint) {\n      char str[2] = { (char)ch, 0 };\n      stbte__draw_textbox(x0,y0,x1,y1, str,1,0,colormode, STBTE__INDEX_FOR_ID(id,0,0));\n   }\n   return stbte__button_core(id);\n}\n\nstatic int stbte__layerbutton(int x, int y, int ch, int id, int toggled, int disabled, int colormode)\n{\n   int x0 = x, y0 = y, x1 = x+10, y1 = y+11;\n   if(!disabled) stbte__hittest(x0,y0,x1,y1,id);\n   if (stbte__ui.event == STBTE__paint) {\n      char str[2] = { (char)ch, 0 };\n      int off = (9-stbte__get_char_width(ch))/2;\n      stbte__draw_textbox(x0,y0,x1,y1, str, off+1,2, colormode, STBTE__INDEX_FOR_ID(id,disabled,toggled));\n   }\n   if (disabled)\n      return 0;\n   return stbte__button_core(id);\n}\n\nstatic int stbte__microbutton(int x, int y, int size, int id, int colormode)\n{\n   int x0 = x, y0 = y, x1 = x+size, y1 = y+size;\n   stbte__hittest(x0,y0,x1,y1,id);\n   if (stbte__ui.event == STBTE__paint) {\n      stbte__draw_box(x0,y0,x1,y1, colormode, STBTE__INDEX_FOR_ID(id,0,0));\n   }\n   return stbte__button_core(id);\n}\n\nstatic int stbte__microbutton_dragger(int x, int y, int size, int id, int *pos)\n{\n   int x0 = x, y0 = y, x1 = x+size, y1 = y+size;\n   stbte__hittest(x0,y0,x1,y1,id);\n   switch (stbte__ui.event) {\n      case STBTE__paint:\n         stbte__draw_box(x0,y0,x1,y1, STBTE__cexpander, STBTE__INDEX_FOR_ID(id,0,0));\n         break;\n      case STBTE__leftdown:\n         if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n            stbte__activate(id);\n            stbte__ui.sx = stbte__ui.mx - *pos;\n         }\n         break;\n      case STBTE__mousemove:\n         if (STBTE__IS_ACTIVE(id) && stbte__ui.active_event == STBTE__leftdown) {\n            *pos = stbte__ui.mx - stbte__ui.sx;\n         }\n         break;\n      case STBTE__leftup:\n         if (STBTE__IS_ACTIVE(id))\n            stbte__activate(0);\n         break;\n      default:\n         return stbte__button_core(id);\n   }\n   return 0;\n}\n\nstatic int stbte__category_button(const char *label, int x, int y, int width, int id, int toggled)\n{\n   int x0=x,y0=y, x1=x+width,y1=y+STBTE__BUTTON_HEIGHT;\n   int s = STBTE__BUTTON_INTERNAL_SPACING;\n\n   stbte__hittest(x0,y0,x1,y1,id);\n\n   if (stbte__ui.event == STBTE__paint)\n      stbte__draw_textbox(x0,y0,x1,y1, (char*) label, s,s, STBTE__ccategory_button, STBTE__INDEX_FOR_ID(id,0,toggled));\n\n   return (stbte__button_core(id) == 1);\n}\n\nenum\n{\n   STBTE__none,\n   STBTE__begin,\n   STBTE__end,\n   STBTE__change,\n};\n\n// returns -1 if value changes, 1 at end of drag\nstatic int stbte__slider(int x0, int w, int y, int range, int *value, int id)\n{\n   int x1 = x0+w;\n   int pos = *value * w / (range+1);\n   stbte__hittest(x0,y-2,x1,y+3,id);\n   int event_mouse_move = STBTE__change;\n   switch (stbte__ui.event) {\n      case STBTE__paint:\n         stbte__draw_rect(x0,y,x1,y+1, 0x808080);\n         stbte__draw_rect(x0+pos-1,y-1,x0+pos+2,y+2, 0xffffff);\n         break;\n      case STBTE__leftdown:\n         if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n            stbte__activate(id);\n            event_mouse_move = STBTE__begin;\n         }\n         // fall through\n      case STBTE__mousemove:\n         if (STBTE__IS_ACTIVE(id)) {\n            int v = (stbte__ui.mx-x0)*(range+1)/w;\n            if (v < 0) v = 0; else if (v > range) v = range;\n            *value = v;\n            return event_mouse_move;\n         }\n         break;\n      case STBTE__leftup:\n         if (STBTE__IS_ACTIVE(id)) {\n            stbte__activate(0);\n            return STBTE__end;\n         }\n         break;\n   }\n   return STBTE__none;\n}\n\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   #define stbte__sprintf      sprintf_s\n   #define stbte__sizeof(s)    , sizeof(s)\n#else\n   #define stbte__sprintf      sprintf\n   #define stbte__sizeof(s)\n#endif\n\nstatic int stbte__float_control(int x0, int y0, int w, float minv, float maxv, float scale, const char *fmt, float *value, int colormode, int id)\n{\n   int x1 = x0+w;\n   int y1 = y0+11;\n   stbte__hittest(x0,y0,x1,y1,id);\n   switch (stbte__ui.event) {\n      case STBTE__paint: {\n         char text[32];\n         stbte__sprintf(text stbte__sizeof(text), fmt ? fmt : \"%6.2f\", *value);\n         stbte__draw_textbox(x0,y0,x1,y1, text, 1,2, colormode, STBTE__INDEX_FOR_ID(id,0,0));\n         break;\n      }\n      case STBTE__leftdown:\n      case STBTE__rightdown:\n         if (STBTE__IS_HOT(id) && STBTE__INACTIVE())\n            stbte__activate(id);\n         return STBTE__begin;\n         break;\n      case STBTE__leftup:\n      case STBTE__rightup:\n         if (STBTE__IS_ACTIVE(id)) {\n            stbte__activate(0);\n            return STBTE__end;\n         }\n         break;\n      case STBTE__mousemove:\n         if (STBTE__IS_ACTIVE(id)) {\n            float v = *value, delta;\n            int ax = stbte__ui.accum_x/STBTE_FLOAT_CONTROL_GRANULARITY;\n            int ay = stbte__ui.accum_y/STBTE_FLOAT_CONTROL_GRANULARITY;\n            stbte__ui.accum_x -= ax*STBTE_FLOAT_CONTROL_GRANULARITY;\n            stbte__ui.accum_y -= ay*STBTE_FLOAT_CONTROL_GRANULARITY;\n            if (stbte__ui.shift) {\n               if (stbte__ui.active_event == STBTE__leftdown)\n                  delta = ax * 16.0f + ay;\n               else\n                  delta = ax / 16.0f + ay / 256.0f;\n            } else {\n               if (stbte__ui.active_event == STBTE__leftdown)\n                  delta = ax*10.0f + ay;\n               else\n                  delta = ax * 0.1f + ay * 0.01f;\n            }\n            v += delta * scale;\n            if (v < minv) v = minv;\n            if (v > maxv) v = maxv;\n            *value = v;\n            return STBTE__change;\n         }\n         break;\n   }\n   return STBTE__none;\n}\n\nstatic void stbte__scrollbar(int x, int y0, int y1, int *val, int v0, int v1, int num_vis, int id)\n{\n   int thumbpos;\n   if (v1 - v0 <= num_vis)\n      return;\n\n   // generate thumbpos from numvis\n   thumbpos = y0+2 + (y1-y0-4) * *val / (v1 - v0 - num_vis);\n   if (thumbpos < y0) thumbpos = y0;\n   if (thumbpos >= y1) thumbpos = y1;\n   stbte__hittest(x-1,y0,x+2,y1,id);\n   switch (stbte__ui.event) {\n      case STBTE__paint:\n         stbte__draw_rect(x,y0,x+1,y1, stbte__color_table[STBTE__cscrollbar][STBTE__text][STBTE__idle]);\n         stbte__draw_box(x-1,thumbpos-3,x+2,thumbpos+4, STBTE__cscrollbar, STBTE__INDEX_FOR_ID(id,0,0));\n         break;\n      case STBTE__leftdown:\n         if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n            // check if it's over the thumb\n            stbte__activate(id);\n            *val = ((stbte__ui.my-y0) * (v1 - v0 - num_vis) + (y1-y0)/2)/ (y1-y0);\n         }\n         break;\n      case STBTE__mousemove:\n         if (STBTE__IS_ACTIVE(id) && stbte__ui.mx >= x-15 && stbte__ui.mx <= x+15)\n            *val = ((stbte__ui.my-y0) * (v1 - v0 - num_vis) + (y1-y0)/2)/ (y1-y0);\n         break;\n      case STBTE__leftup:\n         if (STBTE__IS_ACTIVE(id))\n            stbte__activate(0);\n         break;\n\n   }\n\n   if (*val >= v1-num_vis)\n      *val = v1-num_vis;\n   if (*val <= v0)\n      *val = v0;\n}\n\n\nstatic void stbte__compute_digits(stbte_tilemap *tm)\n{\n   if (tm->max_x >= 1000 || tm->max_y >= 1000)\n      tm->digits = 4;\n   else if (tm->max_x >= 100 || tm->max_y >= 100)\n      tm->digits = 3;\n   else\n      tm->digits = 2;\n}\n\nstatic int stbte__is_single_selection(void)\n{\n   return stbte__ui.has_selection\n       && stbte__ui.select_x0 == stbte__ui.select_x1\n       && stbte__ui.select_y0 == stbte__ui.select_y1;\n}\n\ntypedef struct\n{\n   int width, height;\n   int x,y;\n   int active;\n   float retracted;\n} stbte__region_t;\n\nstatic stbte__region_t stbte__region[4];\n\n#define STBTE__TOOLBAR_ICON_SIZE   (9+2*2)\n#define STBTE__TOOLBAR_PASTE_SIZE  (34+2*2)\n\n// This routine computes where every panel goes onscreen: computes\n// a minimum width for each side based on which panels are on that\n// side, and accounts for width-dependent layout of certain panels.\nstatic void stbte__compute_panel_locations(stbte_tilemap *tm)\n{\n   int i, limit, w, k;\n   int window_width  = stbte__ui.x1 - stbte__ui.x0;\n   int window_height = stbte__ui.y1 - stbte__ui.y0;\n   int min_width[STBTE__num_panel]={0,0,0,0,0,0,0};\n   int height[STBTE__num_panel]={0,0,0,0,0,0,0};\n   int panel_active[STBTE__num_panel]={1,0,1,1,1,1,1};\n   int vpos[4] = { 0,0,0,0 };\n   stbte__panel *p = stbte__ui.panel;\n   stbte__panel *pt = &p[STBTE__panel_toolbar];\n#ifdef STBTE__NO_PROPS\n   int props = 0;\n#else\n   int props = 1;\n#endif\n\n   for (i=0; i < 4; ++i) {\n      stbte__region[i].active = 0;\n      stbte__region[i].width = 0;\n      stbte__region[i].height = 0;\n   }\n\n   // compute number of digits needs for info panel\n   stbte__compute_digits(tm);\n\n   // determine which panels are active\n   panel_active[STBTE__panel_categories] = tm->num_categories != 0;\n   panel_active[STBTE__panel_layers    ] = tm->num_layers     >  1;\n#ifdef STBTE__COLORPICKER\n   panel_active[STBTE__panel_colorpick ] = 1;\n#endif\n\n   panel_active[STBTE__panel_props     ] = props && stbte__is_single_selection();\n\n   // compute minimum widths for each panel (assuming they're on sides not top)\n   min_width[STBTE__panel_info      ] = 8 + 11 + 7*tm->digits+17+7;               // estimate min width of \"w:0000\"\n   min_width[STBTE__panel_colorpick ] = 120;\n   min_width[STBTE__panel_tiles     ] = 4 + tm->palette_spacing_x + 5;            // 5 for scrollbar\n   min_width[STBTE__panel_categories] = 4 + 42 + 5;                               // 42 is enough to show ~7 chars; 5 for scrollbar\n   min_width[STBTE__panel_layers    ] = 4 + 54 + 30*tm->has_layer_names;          // 2 digits plus 3 buttons plus scrollbar\n   min_width[STBTE__panel_toolbar   ] = 4 + STBTE__TOOLBAR_PASTE_SIZE;            // wide enough for 'Paste' button\n   min_width[STBTE__panel_props     ] = 80;                    // narrowest info panel\n\n   // compute minimum widths for left & right panels based on the above\n   stbte__region[0].width = stbte__ui.left_width;\n   stbte__region[1].width = stbte__ui.right_width;\n\n   for (i=0; i < STBTE__num_panel; ++i) {\n      if (panel_active[i]) {\n         int side = stbte__ui.panel[i].side;\n         if (min_width[i] > stbte__region[side].width)\n            stbte__region[side].width = min_width[i];\n         stbte__region[side].active = 1;\n      }\n   }\n\n   // now compute the heights of each panel\n\n   // if toolbar at top, compute its size & push the left and right start points down\n   if (stbte__region[STBTE__side_top].active) {\n      int height = STBTE__TOOLBAR_ICON_SIZE+2;\n      pt->x0     = stbte__ui.x0;\n      pt->y0     = stbte__ui.y0;\n      pt->width  = window_width;\n      pt->height = height;\n      vpos[STBTE__side_left] = vpos[STBTE__side_right] = height;\n   } else {\n      int num_rows = STBTE__num_tool * ((stbte__region[pt->side].width-4)/STBTE__TOOLBAR_ICON_SIZE);\n      height[STBTE__panel_toolbar] = num_rows*13 + 3*15 + 4; // 3*15 for cut/copy/paste, which are stacked vertically\n   }\n\n   for (i=0; i < 4; ++i)\n      stbte__region[i].y = stbte__ui.y0 + vpos[i];\n\n   for (i=0; i < 2; ++i) {\n      int anim = (int) (stbte__region[i].width * stbte__region[i].retracted);\n      stbte__region[i].x = (i == STBTE__side_left) ? stbte__ui.x0 - anim : stbte__ui.x1 - stbte__region[i].width + anim;\n   }\n\n   // color picker\n   height[STBTE__panel_colorpick] = 300;\n\n   // info panel\n   w = stbte__region[p[STBTE__panel_info].side].width;\n   p[STBTE__panel_info].mode = (w >= 8 + (11+7*tm->digits+17)*2 + 4);\n   if (p[STBTE__panel_info].mode)\n      height[STBTE__panel_info] = 5 + 11*2 + 2 + tm->palette_spacing_y;\n   else\n      height[STBTE__panel_info] = 5 + 11*4 + 2 + tm->palette_spacing_y;\n\n   // layers\n   limit = 6 + stbte__ui.panel[STBTE__panel_layers].delta_height;\n   height[STBTE__panel_layers] = (tm->num_layers > limit ? limit : tm->num_layers)*15 + 7 + (tm->has_layer_names ? 0 : 11) + props*13;\n\n   // categories\n   limit = 6 + stbte__ui.panel[STBTE__panel_categories].delta_height;\n   height[STBTE__panel_categories] = (tm->num_categories+1 > limit ? limit : tm->num_categories+1)*11 + 14;\n   if (stbte__ui.panel[STBTE__panel_categories].side == stbte__ui.panel[STBTE__panel_categories].side)\n      height[STBTE__panel_categories] -= 4;\n\n   // palette\n   k =  (stbte__region[p[STBTE__panel_tiles].side].width - 8) / tm->palette_spacing_x;\n   if (k == 0) k = 1;\n   height[STBTE__panel_tiles] = ((tm->num_tiles+k-1)/k) * tm->palette_spacing_y + 8;\n\n   // properties panel\n   height[STBTE__panel_props] = 9 + STBTE_MAX_PROPERTIES*14;\n\n   // now compute the locations of all the panels\n   for (i=0; i < STBTE__num_panel; ++i) {\n      if (panel_active[i]) {\n         int side = p[i].side;\n         if (side == STBTE__side_left || side == STBTE__side_right) {\n            p[i].width  = stbte__region[side].width;\n            p[i].x0     = stbte__region[side].x;\n            p[i].y0     = stbte__ui.y0 + vpos[side];\n            p[i].height = height[i];\n            vpos[side] += height[i];\n            if (vpos[side] > window_height) {\n               vpos[side] = window_height;\n               p[i].height = stbte__ui.y1 - p[i].y0;\n            }\n         } else {\n            ; // it's at top, it's already been explicitly set up earlier\n         }\n      } else {\n         // inactive panel\n         p[i].height = 0;\n         p[i].width  = 0;\n         p[i].x0     = stbte__ui.x1;\n         p[i].y0     = stbte__ui.y1;\n      }\n   }\n}\n\n// unique identifiers for imgui\nenum\n{\n   STBTE__map=1,\n   STBTE__region,\n   STBTE__panel,                          // panel background to hide map, and misc controls\n   STBTE__info,                           // info data\n   STBTE__toolbarA, STBTE__toolbarB,      // toolbar buttons: param is tool number\n   STBTE__palette,                        // palette selectors: param is tile index\n   STBTE__categories,                     // category selectors: param is category index\n   STBTE__layer,                          //\n   STBTE__solo, STBTE__hide, STBTE__lock, // layer controls: param is layer\n   STBTE__scrollbar,                      // param is panel ID\n   STBTE__panel_mover,                    // p1 is panel ID, p2 is destination side\n   STBTE__panel_sizer,                    // param panel ID\n   STBTE__scrollbar_id,\n   STBTE__colorpick_id,\n   STBTE__prop_flag,\n   STBTE__prop_float,\n   STBTE__prop_int,\n};\n\n// id is:      [      24-bit data     : 7-bit identifier ]\n// map id is:  [  12-bit y : 12 bit x : 7-bit identifier ]\n\n#define STBTE__ID(n,p)     ((n) + ((p)<<7))\n#define STBTE__ID2(n,p,q)  STBTE__ID(n, ((p)<<12)+(q) )\n#define STBTE__IDMAP(x,y)  STBTE__ID2(STBTE__map, x,y)\n\nstatic void stbte__activate_map(int x, int y)\n{\n   stbte__ui.active_id = STBTE__IDMAP(x,y);\n   stbte__ui.active_event = stbte__ui.event;\n   stbte__ui.sx = x;\n   stbte__ui.sy = y;\n}\n\nstatic void stbte__alert(const char *msg)\n{\n   stbte__ui.alert_msg = msg;\n   stbte__ui.alert_timer = 3;\n}\n\n#define STBTE__BG(tm,layer) ((layer) == 0 ? (tm)->background_tile : STBTE__NO_TILE)\n\n\n\nstatic void stbte__brush_predict(stbte_tilemap *tm, short result[])\n{\n   stbte__tileinfo *ti;\n   int i;\n\n   if (tm->cur_tile < 0) return;\n\n   ti = &tm->tiles[tm->cur_tile];\n\n   // find lowest legit layer to paint it on, and put it there\n   for (i=0; i < tm->num_layers; ++i) {\n      // check if object is allowed on layer\n      if (!(ti->layermask & (1 << i)))\n         continue;\n\n      if (i != tm->solo_layer) {\n         // if there's a selected layer, can only paint on that\n         if (tm->cur_layer >= 0 && i != tm->cur_layer)\n            continue;\n\n         // if the layer is hidden, we can't see it\n         if (tm->layerinfo[i].hidden)\n            continue;\n\n         // if the layer is locked, we can't write to it\n         if (tm->layerinfo[i].locked == STBTE__locked)\n            continue;\n\n         // if the layer is non-empty and protected, can't write to it\n         if (tm->layerinfo[i].locked == STBTE__protected && result[i] != STBTE__BG(tm,i))\n            continue;\n      }\n\n      result[i] = ti->id;\n      return;\n   }\n}\n\nstatic void stbte__brush(stbte_tilemap *tm, int x, int y)\n{\n   stbte__tileinfo *ti;\n\n   // find lowest legit layer to paint it on, and put it there\n   int i;\n\n   if (tm->cur_tile < 0) return;\n\n   ti = &tm->tiles[tm->cur_tile];\n\n   for (i=0; i < tm->num_layers; ++i) {\n      // check if object is allowed on layer\n      if (!(ti->layermask & (1 << i)))\n         continue;\n\n      if (i != tm->solo_layer) {\n         // if there's a selected layer, can only paint on that\n         if (tm->cur_layer >= 0 && i != tm->cur_layer)\n            continue;\n\n         // if the layer is hidden, we can't see it\n         if (tm->layerinfo[i].hidden)\n            continue;\n\n         // if the layer is locked, we can't write to it\n         if (tm->layerinfo[i].locked == STBTE__locked)\n            continue;\n\n         // if the layer is non-empty and protected, can't write to it\n         if (tm->layerinfo[i].locked == STBTE__protected && tm->data[y][x][i] != STBTE__BG(tm,i))\n            continue;\n      }\n\n      stbte__undo_record(tm,x,y,i,tm->data[y][x][i]);\n      tm->data[y][x][i] = ti->id;\n      return;\n   }\n\n   //stbte__alert(\"Selected tile not valid on active layer(s)\");\n}\n\nenum\n{\n   STBTE__erase_none = -1,\n   STBTE__erase_brushonly = 0,\n   STBTE__erase_any = 1,\n   STBTE__erase_all = 2,\n};\n\nstatic int stbte__erase_predict(stbte_tilemap *tm, short result[], int allow_any)\n{\n   stbte__tileinfo *ti = tm->cur_tile >= 0 ? &tm->tiles[tm->cur_tile] : NULL;\n   int i;\n\n   if (allow_any == STBTE__erase_none)\n      return allow_any;\n\n   // first check if only one layer is legit\n   i = tm->cur_layer;\n   if (tm->solo_layer >= 0)\n      i = tm->solo_layer;\n\n   // if only one layer is legit, directly process that one for clarity\n   if (i >= 0) {\n      short bg = (i == 0 ? tm->background_tile : -1);\n      if (tm->solo_layer < 0) {\n         // check that we're allowed to write to it\n         if (tm->layerinfo[i].hidden) return STBTE__erase_none;\n         if (tm->layerinfo[i].locked) return STBTE__erase_none;\n      }\n      if (result[i] == bg)\n         return STBTE__erase_none; // didn't erase anything\n      if (ti && result[i] == ti->id && (i != 0 || ti->id != tm->background_tile)) {\n         result[i] = bg;\n         return STBTE__erase_brushonly;\n      }\n      if (allow_any == STBTE__erase_any) {\n         result[i] = bg;\n         return STBTE__erase_any;\n      }\n      return STBTE__erase_none;\n   }\n\n   // if multiple layers are legit, first scan all for brush data\n\n   if (ti && allow_any != STBTE__erase_all) {\n      for (i=tm->num_layers-1; i >= 0; --i) {\n         if (result[i] != ti->id)\n            continue;\n         if (tm->layerinfo[i].locked || tm->layerinfo[i].hidden)\n            continue;\n         if (i == 0 && result[i] == tm->background_tile)\n            return STBTE__erase_none;\n         result[i] = STBTE__BG(tm,i);\n         return STBTE__erase_brushonly;\n      }\n   }\n\n   if (allow_any != STBTE__erase_any && allow_any != STBTE__erase_all)\n      return STBTE__erase_none;\n\n   // apply layer filters, erase from top\n   for (i=tm->num_layers-1; i >= 0; --i) {\n      if (result[i] < 0)\n         continue;\n      if (tm->layerinfo[i].locked || tm->layerinfo[i].hidden)\n         continue;\n      if (i == 0 && result[i] == tm->background_tile)\n         return STBTE__erase_none;\n      result[i] = STBTE__BG(tm,i);\n      if (allow_any != STBTE__erase_all)\n         return STBTE__erase_any;\n   }\n\n   if (allow_any == STBTE__erase_all)\n      return allow_any;\n   return STBTE__erase_none;\n}\n\nstatic int stbte__erase(stbte_tilemap *tm, int x, int y, int allow_any)\n{\n   stbte__tileinfo *ti = tm->cur_tile >= 0 ? &tm->tiles[tm->cur_tile] : NULL;\n   int i;\n\n   if (allow_any == STBTE__erase_none)\n      return allow_any;\n\n   // first check if only one layer is legit\n   i = tm->cur_layer;\n   if (tm->solo_layer >= 0)\n      i = tm->solo_layer;\n\n   // if only one layer is legit, directly process that one for clarity\n   if (i >= 0) {\n      short bg = (i == 0 ? tm->background_tile : -1);\n      if (tm->solo_layer < 0) {\n         // check that we're allowed to write to it\n         if (tm->layerinfo[i].hidden) return STBTE__erase_none;\n         if (tm->layerinfo[i].locked) return STBTE__erase_none;\n      }\n      if (tm->data[y][x][i] == bg)\n         return -1; // didn't erase anything\n      if (ti && tm->data[y][x][i] == ti->id && (i != 0 || ti->id != tm->background_tile)) {\n         stbte__undo_record(tm,x,y,i,tm->data[y][x][i]);\n         tm->data[y][x][i] = bg;\n         return STBTE__erase_brushonly;\n      }\n      if (allow_any == STBTE__erase_any) {\n         stbte__undo_record(tm,x,y,i,tm->data[y][x][i]);\n         tm->data[y][x][i] = bg;\n         return STBTE__erase_any;\n      }\n      return STBTE__erase_none;\n   }\n\n   // if multiple layers are legit, first scan all for brush data\n\n   if (ti && allow_any != STBTE__erase_all) {\n      for (i=tm->num_layers-1; i >= 0; --i) {\n         if (tm->data[y][x][i] != ti->id)\n            continue;\n         if (tm->layerinfo[i].locked || tm->layerinfo[i].hidden)\n            continue;\n         if (i == 0 && tm->data[y][x][i] == tm->background_tile)\n            return STBTE__erase_none;\n         stbte__undo_record(tm,x,y,i,tm->data[y][x][i]);\n         tm->data[y][x][i] = STBTE__BG(tm,i);\n         return STBTE__erase_brushonly;\n      }\n   }\n\n   if (allow_any != STBTE__erase_any && allow_any != STBTE__erase_all)\n      return STBTE__erase_none;\n\n   // apply layer filters, erase from top\n   for (i=tm->num_layers-1; i >= 0; --i) {\n      if (tm->data[y][x][i] < 0)\n         continue;\n      if (tm->layerinfo[i].locked || tm->layerinfo[i].hidden)\n         continue;\n      if (i == 0 && tm->data[y][x][i] == tm->background_tile)\n         return STBTE__erase_none;\n      stbte__undo_record(tm,x,y,i,tm->data[y][x][i]);\n      tm->data[y][x][i] = STBTE__BG(tm,i);\n      if (allow_any != STBTE__erase_all)\n         return STBTE__erase_any;\n   }\n   if (allow_any == STBTE__erase_all)\n      return allow_any;\n   return STBTE__erase_none;\n}\n\nstatic int stbte__find_tile(stbte_tilemap *tm, int tile_id)\n{\n   int i;\n   for (i=0; i < tm->num_tiles; ++i)\n      if (tm->tiles[i].id == tile_id)\n         return i;\n   stbte__alert(\"Eyedropped tile that isn't in tileset\");\n   return -1;\n}\n\nstatic void stbte__eyedrop(stbte_tilemap *tm, int x, int y)\n{\n   int i,j;\n\n   // flush eyedropper state\n   if (stbte__ui.eyedrop_x != x || stbte__ui.eyedrop_y != y) {\n      stbte__ui.eyedrop_x = x;\n      stbte__ui.eyedrop_y = y;\n      stbte__ui.eyedrop_last_layer = tm->num_layers;\n   }\n\n   // if only one layer is active, query that\n   i = tm->cur_layer;\n   if (tm->solo_layer >= 0)\n      i = tm->solo_layer;\n   if (i >= 0) {\n      if (tm->data[y][x][i] == STBTE__NO_TILE)\n         return;\n      tm->cur_tile = stbte__find_tile(tm, tm->data[y][x][i]);\n      return;\n   }\n\n   // if multiple layers, continue from previous\n   i = stbte__ui.eyedrop_last_layer;\n   for (j=0; j < tm->num_layers; ++j) {\n      if (--i < 0)\n         i = tm->num_layers-1;\n      if (tm->layerinfo[i].hidden)\n         continue;\n      if (tm->data[y][x][i] == STBTE__NO_TILE)\n         continue;\n      stbte__ui.eyedrop_last_layer = i;\n      tm->cur_tile = stbte__find_tile(tm, tm->data[y][x][i]);\n      return;\n   }\n}\n\nstatic int stbte__should_copy_properties(stbte_tilemap *tm)\n{\n   int i;\n   if (tm->propmode == STBTE__propmode_always)\n      return 1;\n   if (tm->propmode == STBTE__propmode_never)\n      return 0;\n   if (tm->solo_layer >= 0 || tm->cur_layer >= 0)\n      return 0;\n   for (i=0; i < tm->num_layers; ++i)\n      if (tm->layerinfo[i].hidden || tm->layerinfo[i].locked)\n         return 0;\n   return 1;\n}\n\n// compute the result of pasting into a tile non-destructively so we can preview it\nstatic void stbte__paste_stack(stbte_tilemap *tm, short result[], short dest[], short src[], int dragging)\n{\n   int i;\n\n   // special case single-layer\n   i = tm->cur_layer;\n   if (tm->solo_layer >= 0)\n      i = tm->solo_layer;\n   if (i >= 0) {\n      if (tm->solo_layer < 0) {\n         // check that we're allowed to write to it\n         if (tm->layerinfo[i].hidden) return;\n         if (tm->layerinfo[i].locked == STBTE__locked) return;\n         // if protected, dest has to be empty\n         if (tm->layerinfo[i].locked == STBTE__protected && dest[i] != STBTE__BG(tm,i)) return;\n         // if dragging w/o copy, we will try to erase stuff, which protection disallows\n         if (dragging && tm->layerinfo[i].locked == STBTE__protected)\n             return;\n      }\n      result[i] = dest[i];\n      if (src[i] != STBTE__BG(tm,i))\n         result[i] = src[i];\n      return;\n   }\n\n   for (i=0; i < tm->num_layers; ++i) {\n      result[i] = dest[i];\n      if (src[i] != STBTE__NO_TILE)\n         if (!tm->layerinfo[i].hidden && tm->layerinfo[i].locked != STBTE__locked)\n            if (tm->layerinfo[i].locked == STBTE__unlocked || (!dragging && dest[i] == STBTE__BG(tm,i)))\n               result[i] = src[i];\n   }\n}\n\n// compute the result of dragging away from a tile\nstatic void stbte__clear_stack(stbte_tilemap *tm, short result[])\n{\n   int i;\n   // special case single-layer\n   i = tm->cur_layer;\n   if (tm->solo_layer >= 0)\n      i = tm->solo_layer;\n   if (i >= 0)\n      result[i] = STBTE__BG(tm,i);\n   else\n      for (i=0; i < tm->num_layers; ++i)\n         if (!tm->layerinfo[i].hidden && tm->layerinfo[i].locked == STBTE__unlocked)\n            result[i] = STBTE__BG(tm,i);\n}\n\n// check if some map square is active\n#define STBTE__IS_MAP_ACTIVE()  ((stbte__ui.active_id & 127) == STBTE__map)\n#define STBTE__IS_MAP_HOT()     ((stbte__ui.hot_id & 127) == STBTE__map)\n\nstatic void stbte__fillrect(stbte_tilemap *tm, int x0, int y0, int x1, int y1, int fill)\n{\n   int i,j;\n\n   stbte__begin_undo(tm);\n   if (x0 > x1) i=x0,x0=x1,x1=i;\n   if (y0 > y1) j=y0,y0=y1,y1=j;\n   for (j=y0; j <= y1; ++j)\n      for (i=x0; i <= x1; ++i)\n         if (fill)\n            stbte__brush(tm, i,j);\n         else\n            stbte__erase(tm, i,j,STBTE__erase_any);\n   stbte__end_undo(tm);\n   // suppress warning from brush\n   stbte__ui.alert_msg = 0;\n}\n\nstatic void stbte__select_rect(stbte_tilemap *tm, int x0, int y0, int x1, int y1)\n{\n   stbte__ui.has_selection = 1;\n   stbte__ui.select_x0 = (x0 < x1 ? x0 : x1);\n   stbte__ui.select_x1 = (x0 < x1 ? x1 : x0);\n   stbte__ui.select_y0 = (y0 < y1 ? y0 : y1);\n   stbte__ui.select_y1 = (y0 < y1 ? y1 : y0);\n}\n\nstatic void stbte__copy_properties(float *dest, float *src)\n{\n   int i;\n   for (i=0; i < STBTE_MAX_PROPERTIES; ++i)\n      dest[i] = src[i];\n}\n\nstatic void stbte__copy_cut(stbte_tilemap *tm, int cut)\n{\n   int i,j,n,w,h,p=0;\n   int copy_props = stbte__should_copy_properties(tm);\n   if (!stbte__ui.has_selection)\n      return;\n   w = stbte__ui.select_x1 - stbte__ui.select_x0 + 1;\n   h = stbte__ui.select_y1 - stbte__ui.select_y0 + 1;\n   if (STBTE_MAX_COPY / w < h) {\n      stbte__alert(\"Selection too large for copy buffer, increase STBTE_MAX_COPY\");\n      return;\n   }\n\n   for (i=0; i < w*h; ++i)\n      for (n=0; n < tm->num_layers; ++n)\n         stbte__ui.copybuffer[i][n] = STBTE__NO_TILE;\n\n   if (cut)\n      stbte__begin_undo(tm);\n   for (j=stbte__ui.select_y0; j <= stbte__ui.select_y1; ++j) {\n      for (i=stbte__ui.select_x0; i <= stbte__ui.select_x1; ++i) {\n         for (n=0; n < tm->num_layers; ++n) {\n            if (tm->solo_layer >= 0) {\n               if (tm->solo_layer != n)\n                  continue;\n            } else {\n               if (tm->cur_layer >= 0)\n                  if (tm->cur_layer != n)\n                     continue;\n               if (tm->layerinfo[n].hidden)\n                  continue;\n               if (cut && tm->layerinfo[n].locked)\n                  continue;\n            }\n            stbte__ui.copybuffer[p][n] = tm->data[j][i][n];\n            if (cut) {\n               stbte__undo_record(tm,i,j,n, tm->data[j][i][n]);\n               tm->data[j][i][n] = (n==0 ? tm->background_tile : -1);\n            }\n         }\n         if (copy_props) {\n            stbte__copy_properties(stbte__ui.copyprops[p], tm->props[j][i]);\n#ifdef STBTE_ALLOW_LINK\n            stbte__ui.copylinks[p] = tm->link[j][i];\n            if (cut)\n               stbte__set_link(tm, i,j,-1,-1, STBTE__undo_record);\n#endif\n         }\n         ++p;\n      }\n   }\n   if (cut)\n      stbte__end_undo(tm);\n   stbte__ui.copy_width = w;\n   stbte__ui.copy_height = h;\n   stbte__ui.has_copy = 1;\n   //stbte__ui.has_selection = 0;\n   stbte__ui.copy_has_props = copy_props;\n   stbte__ui.copy_src = tm; // used to give better semantics when copying links\n   stbte__ui.copy_src_x = stbte__ui.select_x0;\n   stbte__ui.copy_src_y = stbte__ui.select_y0;\n}\n\nstatic int stbte__in_rect(int x, int y, int x0, int y0, int w, int h)\n{\n   return x >= x0 && x < x0+w && y >= y0 && y < y0+h;\n}\n\n#ifdef STBTE_ALLOW_LINK\nstatic int stbte__in_src_rect(int x, int y)\n{\n   return stbte__in_rect(x,y, stbte__ui.copy_src_x, stbte__ui.copy_src_y, stbte__ui.copy_width, stbte__ui.copy_height);\n}\n\nstatic int stbte__in_dest_rect(int x, int y, int destx, int desty)\n{\n   return stbte__in_rect(x,y, destx, desty, stbte__ui.copy_width, stbte__ui.copy_height);\n}\n#endif\n\nstatic void stbte__paste(stbte_tilemap *tm, int mapx, int mapy)\n{\n   int w = stbte__ui.copy_width;\n   int h = stbte__ui.copy_height;\n   int i,j,k,p;\n   int x = mapx - (w>>1);\n   int y = mapy - (h>>1);\n   int copy_props = stbte__should_copy_properties(tm) && stbte__ui.copy_has_props;\n   if (stbte__ui.has_copy == 0)\n      return;\n   stbte__begin_undo(tm);\n   p = 0;\n   for (j=0; j < h; ++j) {\n      for (i=0; i < w; ++i) {\n         if (y+j >= 0 && y+j < tm->max_y && x+i >= 0 && x+i < tm->max_x) {\n            // compute the new stack\n            short tilestack[STBTE_MAX_LAYERS];\n            for (k=0; k < tm->num_layers; ++k)\n               tilestack[k] = tm->data[y+j][x+i][k];\n            stbte__paste_stack(tm, tilestack, tilestack, stbte__ui.copybuffer[p], 0);\n            // update anything that changed\n            for (k=0; k < tm->num_layers; ++k) {\n               if (tilestack[k] != tm->data[y+j][x+i][k]) {\n                  stbte__undo_record(tm, x+i,y+j,k, tm->data[y+j][x+i][k]);\n                  tm->data[y+j][x+i][k] = tilestack[k];\n               }\n            }\n         }\n         if (copy_props) {\n#ifdef STBTE_ALLOW_LINK\n            // need to decide how to paste a link, so there's a few cases\n            int destx = -1, desty = -1;\n            stbte__link *link = &stbte__ui.copylinks[p];\n\n            // check if link is within-rect\n            if (stbte__in_src_rect(link->x, link->y)) {\n               // new link should point to copy (but only if copy is within map)\n               destx = x + (link->x - stbte__ui.copy_src_x);\n               desty = y + (link->y - stbte__ui.copy_src_y);\n            } else if (tm == stbte__ui.copy_src) {\n               // if same map, then preserve link unless target is overwritten\n               if (!stbte__in_dest_rect(link->x,link->y,x,y)) {\n                  destx = link->x;\n                  desty = link->y;\n               }\n            }\n            // this is necessary for offset-copy, but also in case max_x/max_y has changed\n            if (destx < 0 || destx >= tm->max_x || desty < 0 || desty >= tm->max_y)\n               destx = -1, desty = -1;\n            stbte__set_link(tm, x+i, y+j, destx, desty, STBTE__undo_record);\n#endif\n            for (k=0; k < STBTE_MAX_PROPERTIES; ++k) {\n               if (tm->props[y+j][x+i][k] != stbte__ui.copyprops[p][k])\n                  stbte__undo_record_prop_float(tm, x+i, y+j, k, tm->props[y+j][x+i][k]);\n            }\n            stbte__copy_properties(tm->props[y+j][x+i], stbte__ui.copyprops[p]);\n         }\n         ++p;\n      }\n   }\n   stbte__end_undo(tm);\n}\n\nstatic void stbte__drag_update(stbte_tilemap *tm, int mapx, int mapy, int copy_props)\n{\n   int w = stbte__ui.drag_w, h = stbte__ui.drag_h;\n   int ox,oy,i,deleted=0,written=0;\n   short temp[STBTE_MAX_LAYERS];\n   short *data = NULL;\n\n   STBTE__NOTUSED(deleted);\n   STBTE__NOTUSED(written);\n\n   if (!stbte__ui.shift) {\n      ox = mapx - stbte__ui.drag_x;\n      oy = mapy - stbte__ui.drag_y;\n      if (ox >= 0 && ox < w && oy >= 0 && oy < h) {\n         deleted=1;\n         for (i=0; i < tm->num_layers; ++i)\n            temp[i] = tm->data[mapy][mapx][i];\n         data = temp;\n         stbte__clear_stack(tm, data);\n      }\n   }\n   ox = mapx - stbte__ui.drag_dest_x;\n   oy = mapy - stbte__ui.drag_dest_y;\n   // if this map square is in the target drag region\n   if (ox >= 0 && ox < w && oy >= 0 && oy < h) {\n      // and the src map square is on the map\n      if (stbte__in_rect(stbte__ui.drag_x+ox, stbte__ui.drag_y+oy, 0, 0, tm->max_x, tm->max_y)) {\n         written = 1;\n         if (data == NULL) {\n            for (i=0; i < tm->num_layers; ++i)\n               temp[i] = tm->data[mapy][mapx][i];\n            data = temp;\n         }\n         stbte__paste_stack(tm, data, data, tm->data[stbte__ui.drag_y+oy][stbte__ui.drag_x+ox], !stbte__ui.shift);\n         if (copy_props) {\n            for (i=0; i < STBTE_MAX_PROPERTIES; ++i) {\n               if (tm->props[mapy][mapx][i] != tm->props[stbte__ui.drag_y+oy][stbte__ui.drag_x+ox][i]) {\n                  stbte__undo_record_prop_float(tm, mapx, mapy, i, tm->props[mapy][mapx][i]);\n                  tm->props[mapy][mapx][i] = tm->props[stbte__ui.drag_y+oy][stbte__ui.drag_x+ox][i];\n               }\n            }\n         }\n      }\n   }\n   if (data) {\n      for (i=0; i < tm->num_layers; ++i) {\n         if (tm->data[mapy][mapx][i] != data[i]) {\n            stbte__undo_record(tm, mapx, mapy, i, tm->data[mapy][mapx][i]);\n            tm->data[mapy][mapx][i] = data[i];\n         }\n      }\n   }\n   #ifdef STBTE_ALLOW_LINK\n   if (copy_props) {\n      int overwritten=0, moved=0, copied=0;\n      // since this function is called on EVERY tile, we can fix up even tiles not\n      // involved in the move\n\n      stbte__link *k;\n      // first, determine what src link ends up here\n      k = &tm->link[mapy][mapx]; // by default, it's the one currently here\n      if (deleted)               // if dragged away, it's erased\n         k = NULL;\n      if (written)               // if dragged into, it gets that link\n         k = &tm->link[stbte__ui.drag_y+oy][stbte__ui.drag_x+ox];\n\n      // now check whether the *target* gets moved or overwritten\n      if (k && k->x >= 0) {\n         overwritten = stbte__in_rect(k->x, k->y, stbte__ui.drag_dest_x, stbte__ui.drag_dest_y, w, h);\n         if (!stbte__ui.shift)\n            moved    = stbte__in_rect(k->x, k->y, stbte__ui.drag_x     , stbte__ui.drag_y     , w, h);\n         else\n            copied   = stbte__in_rect(k->x, k->y, stbte__ui.drag_x     , stbte__ui.drag_y     , w, h);\n      }\n\n      if (deleted || written || overwritten || moved || copied) {\n         // choose the final link value based on the above\n         if (k == NULL || k->x < 0)\n            stbte__set_link(tm, mapx, mapy, -1, -1, STBTE__undo_record);\n         else if (moved || (copied && written)) {\n            // if we move the target, we update to point to the new target;\n            // or, if we copy the target and the source is part of the copy, then update to new target\n            int x = k->x + (stbte__ui.drag_dest_x - stbte__ui.drag_x);\n            int y = k->y + (stbte__ui.drag_dest_y - stbte__ui.drag_y);\n            if (!(x >= 0 && y >= 0 && x < tm->max_x && y < tm->max_y))\n               x = -1, y = -1;\n            stbte__set_link(tm, mapx, mapy, x, y, STBTE__undo_record);\n         } else if (overwritten) {\n            stbte__set_link(tm, mapx, mapy, -1, -1, STBTE__undo_record);\n         } else\n            stbte__set_link(tm, mapx, mapy, k->x, k->y, STBTE__undo_record);\n      }\n   }\n   #endif\n}\n\nstatic void stbte__drag_place(stbte_tilemap *tm, int mapx, int mapy)\n{\n   int i,j;\n   int copy_props = stbte__should_copy_properties(tm);\n   int move_x = (stbte__ui.drag_dest_x - stbte__ui.drag_x);\n   int move_y = (stbte__ui.drag_dest_y - stbte__ui.drag_y);\n   if (move_x == 0 && move_y == 0)\n      return;\n\n   stbte__begin_undo(tm);\n   // we now need a 2D memmove-style mover that doesn't\n   // overwrite any data as it goes. this requires being\n   // direction sensitive in the same way as memmove\n   if (move_y > 0 || (move_y == 0 && move_x > 0)) {\n      for (j=tm->max_y-1; j >= 0; --j)\n         for (i=tm->max_x-1; i >= 0; --i)\n            stbte__drag_update(tm,i,j,copy_props);\n   } else {\n      for (j=0; j < tm->max_y; ++j)\n         for (i=0; i < tm->max_x; ++i)\n            stbte__drag_update(tm,i,j,copy_props);\n   }\n   stbte__end_undo(tm);\n\n   stbte__ui.has_selection = 1;\n   stbte__ui.select_x0 = stbte__ui.drag_dest_x;\n   stbte__ui.select_y0 = stbte__ui.drag_dest_y;\n   stbte__ui.select_x1 = stbte__ui.select_x0 + stbte__ui.drag_w - 1;\n   stbte__ui.select_y1 = stbte__ui.select_y0 + stbte__ui.drag_h - 1;\n}\n\nstatic void stbte__tile_paint(stbte_tilemap *tm, int sx, int sy, int mapx, int mapy, int layer)\n{\n   int i;\n   int id = STBTE__IDMAP(mapx,mapy);\n   int x0=sx, y0=sy;\n   int x1=sx+tm->spacing_x, y1=sy+tm->spacing_y;\n   stbte__hittest(x0,y0,x1,y1, id);\n   short *data = tm->data[mapy][mapx];\n   short temp[STBTE_MAX_LAYERS];\n\n   if (STBTE__IS_MAP_HOT()) {\n      if (stbte__ui.pasting) {\n         int ox = mapx - stbte__ui.paste_x;\n         int oy = mapy - stbte__ui.paste_y;\n         if (ox >= 0 && ox < stbte__ui.copy_width && oy >= 0 && oy < stbte__ui.copy_height) {\n            stbte__paste_stack(tm, temp, tm->data[mapy][mapx], stbte__ui.copybuffer[oy*stbte__ui.copy_width+ox], 0);\n            data = temp;\n         }\n      } else if (stbte__ui.dragging) {\n         int ox,oy;\n         for (i=0; i < tm->num_layers; ++i)\n            temp[i] = tm->data[mapy][mapx][i];\n         data = temp;\n\n         // if it's in the source area, remove things unless shift-dragging\n         ox = mapx - stbte__ui.drag_x;\n         oy = mapy - stbte__ui.drag_y;\n         if (!stbte__ui.shift && ox >= 0 && ox < stbte__ui.drag_w && oy >= 0 && oy < stbte__ui.drag_h) {\n            stbte__clear_stack(tm, temp);\n         }\n\n         ox = mapx - stbte__ui.drag_dest_x;\n         oy = mapy - stbte__ui.drag_dest_y;\n         if (ox >= 0 && ox < stbte__ui.drag_w && oy >= 0 && oy < stbte__ui.drag_h) {\n            stbte__paste_stack(tm, temp, temp, tm->data[stbte__ui.drag_y+oy][stbte__ui.drag_x+ox], !stbte__ui.shift);\n         }\n      } else if (STBTE__IS_MAP_ACTIVE()) {\n         if (stbte__ui.tool == STBTE__tool_rect) {\n            if ((stbte__ui.ms_time & 511) < 380) {\n               int ex = ((stbte__ui.hot_id >> 19) & 4095);\n               int ey = ((stbte__ui.hot_id >>  7) & 4095);\n               int sx = stbte__ui.sx;\n               int sy = stbte__ui.sy;\n\n               if (   ((mapx >= sx && mapx < ex+1) || (mapx >= ex && mapx < sx+1))\n                   && ((mapy >= sy && mapy < ey+1) || (mapy >= ey && mapy < sy+1))) {\n                  int i;\n                  for (i=0; i < tm->num_layers; ++i)\n                     temp[i] = tm->data[mapy][mapx][i];\n                  data = temp;\n                  if (stbte__ui.active_event == STBTE__leftdown)\n                     stbte__brush_predict(tm, temp);\n                  else\n                     stbte__erase_predict(tm, temp, STBTE__erase_any);\n               }\n            }\n         }\n      }\n   }\n\n   if (STBTE__IS_HOT(id) && STBTE__INACTIVE() && !stbte__ui.pasting) {\n      if (stbte__ui.tool == STBTE__tool_brush) {\n         if ((stbte__ui.ms_time & 511) < 300) {\n            data = temp;\n            for (i=0; i < tm->num_layers; ++i)\n               temp[i] = tm->data[mapy][mapx][i];\n            stbte__brush_predict(tm, temp);\n         }\n      }\n   }\n\n   {\n      i = layer;\n      if (i == tm->solo_layer || (!tm->layerinfo[i].hidden && tm->solo_layer < 0))\n         if (data[i] >= 0)\n            STBTE_DRAW_TILE(sx,sy, (unsigned short) data[i], 0, tm->props[mapy][mapx]);\n   }\n}\n\nstatic void stbte__tile(stbte_tilemap *tm, int sx, int sy, int mapx, int mapy)\n{\n   int tool = stbte__ui.tool;\n   int x0=sx, y0=sy;\n   int x1=sx+tm->spacing_x, y1=sy+tm->spacing_y;\n   int id = STBTE__IDMAP(mapx,mapy);\n   int over = stbte__hittest(x0,y0,x1,y1, id);\n   switch (stbte__ui.event) {\n      case STBTE__paint: {\n         if (stbte__ui.pasting || stbte__ui.dragging || stbte__ui.scrolling)\n            break;\n         if (stbte__ui.scrollkey && !STBTE__IS_MAP_ACTIVE())\n            break;\n         if (STBTE__IS_HOT(id) && STBTE__IS_MAP_ACTIVE() && (tool == STBTE__tool_rect || tool == STBTE__tool_select)) {\n            int rx0,ry0,rx1,ry1,t;\n            // compute the center of each rect\n            rx0 = x0 + tm->spacing_x/2;\n            ry0 = y0 + tm->spacing_y/2;\n            rx1 = rx0 + (stbte__ui.sx - mapx) * tm->spacing_x;\n            ry1 = ry0 + (stbte__ui.sy - mapy) * tm->spacing_y;\n            if (rx0 > rx1) t=rx0,rx0=rx1,rx1=t;\n            if (ry0 > ry1) t=ry0,ry0=ry1,ry1=t;\n            rx0 -= tm->spacing_x/2;\n            ry0 -= tm->spacing_y/2;\n            rx1 += tm->spacing_x/2;\n            ry1 += tm->spacing_y/2;\n            stbte__draw_frame(rx0-1,ry0-1,rx1+1,ry1+1, STBTE_COLOR_TILEMAP_HIGHLIGHT);\n            break;\n         }\n         if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n            stbte__draw_frame(x0-1,y0-1,x1+1,y1+1, STBTE_COLOR_TILEMAP_HIGHLIGHT);\n         }\n#ifdef STBTE_ALLOW_LINK\n         if (stbte__ui.show_links && tm->link[mapy][mapx].x >= 0) {\n            int tx = tm->link[mapy][mapx].x;\n            int ty = tm->link[mapy][mapx].y;\n            int lx0,ly0,lx1,ly1;\n            if (STBTE_ALLOW_LINK(tm->data[mapy][mapx], tm->props[mapy][mapx],\n                                 tm->data[ty  ][tx  ], tm->props[ty  ][tx  ]))\n            {\n               lx0 =  x0 + (tm->spacing_x >> 1) - 1;\n               ly0 =  y0 + (tm->spacing_y >> 1) - 1;\n               lx1 = lx0 + (tx - mapx) * tm->spacing_x + 2;\n               ly1 = ly0 + (ty - mapy) * tm->spacing_y + 2;\n               stbte__draw_link(lx0,ly0,lx1,ly1,\n                   STBTE_LINK_COLOR(tm->data[mapy][mapx], tm->props[mapy][mapx],\n                                    tm->data[ty  ][tx  ], tm->props[ty  ][tx]));\n            }\n         }\n#endif\n         break;\n      }\n   }\n\n   if (stbte__ui.pasting) {\n      switch (stbte__ui.event) {\n         case STBTE__leftdown:\n            if (STBTE__IS_HOT(id)) {\n               stbte__ui.pasting = 0;\n               stbte__paste(tm, mapx, mapy);\n               stbte__activate(0);\n            }\n            break;\n         case STBTE__leftup:\n            // just clear it no matter what, since they might click away to clear it\n            stbte__activate(0);\n            break;\n         case STBTE__rightdown:\n            if (STBTE__IS_HOT(id)) {\n               stbte__activate(0);\n               stbte__ui.pasting = 0;\n            }\n            break;\n      }\n      return;\n   }\n\n   if (stbte__ui.scrolling) {\n      if (stbte__ui.event == STBTE__leftup) {\n         stbte__activate(0);\n         stbte__ui.scrolling = 0;\n      }\n      if (stbte__ui.event == STBTE__mousemove) {\n         tm->scroll_x += (stbte__ui.start_x - stbte__ui.mx);\n         tm->scroll_y += (stbte__ui.start_y - stbte__ui.my);\n         stbte__ui.start_x = stbte__ui.mx;\n         stbte__ui.start_y = stbte__ui.my;\n      }\n      return;\n   }\n\n   // regardless of tool, leftdown is a scrolldrag\n   if (STBTE__IS_HOT(id) && stbte__ui.scrollkey && stbte__ui.event == STBTE__leftdown) {\n      stbte__ui.scrolling = 1;\n      stbte__ui.start_x = stbte__ui.mx;\n      stbte__ui.start_y = stbte__ui.my;\n      return;\n   }\n\n   switch (tool) {\n      case STBTE__tool_brush:\n         switch (stbte__ui.event) {\n            case STBTE__mousemove:\n               if (STBTE__IS_MAP_ACTIVE() && over) {\n                  // don't brush/erase same tile multiple times unless they move away and back @TODO should just be only once, but that needs another data structure\n                  if (!STBTE__IS_ACTIVE(id)) {\n                     if (stbte__ui.active_event == STBTE__leftdown)\n                        stbte__brush(tm, mapx, mapy);\n                     else\n                        stbte__erase(tm, mapx, mapy, stbte__ui.brush_state);\n                     stbte__ui.active_id = id; // switch to this map square so we don't rebrush IT multiple times\n                  }\n               }\n               break;\n            case STBTE__leftdown:\n               if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n                  stbte__activate(id);\n                  stbte__begin_undo(tm);\n                  stbte__brush(tm, mapx, mapy);\n               }\n               break;\n            case STBTE__rightdown:\n               if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n                  stbte__activate(id);\n                  stbte__begin_undo(tm);\n                  if (stbte__erase(tm, mapx, mapy, STBTE__erase_any) == STBTE__erase_brushonly)\n                     stbte__ui.brush_state = STBTE__erase_brushonly;\n                  else\n                     stbte__ui.brush_state = STBTE__erase_any;\n               }\n               break;\n            case STBTE__leftup:\n            case STBTE__rightup:\n               if (STBTE__IS_MAP_ACTIVE()) {\n                  stbte__end_undo(tm);\n                  stbte__activate(0);\n               }\n               break;\n         }\n         break;\n\n#ifdef STBTE_ALLOW_LINK\n      case STBTE__tool_link:\n         switch (stbte__ui.event) {\n            case STBTE__leftdown:\n               if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n                  stbte__activate(id);\n                  stbte__ui.linking = 1;\n                  stbte__ui.sx = mapx;\n                  stbte__ui.sy = mapy;\n                  // @TODO: undo\n               }\n               break;\n            case STBTE__leftup:\n               if (STBTE__IS_HOT(id) && STBTE__IS_MAP_ACTIVE()) {\n                  if ((mapx != stbte__ui.sx || mapy != stbte__ui.sy) &&\n                         STBTE_ALLOW_LINK(tm->data[stbte__ui.sy][stbte__ui.sx], tm->props[stbte__ui.sy][stbte__ui.sx],\n                                          tm->data[mapy][mapx], tm->props[mapy][mapx]))\n                     stbte__set_link(tm, stbte__ui.sx, stbte__ui.sy, mapx, mapy, STBTE__undo_block);\n                  else\n                     stbte__set_link(tm, stbte__ui.sx, stbte__ui.sy, -1,-1, STBTE__undo_block);\n                  stbte__ui.linking = 0;\n                  stbte__activate(0);\n               }\n               break;\n\n            case STBTE__rightdown:\n               if (STBTE__IS_ACTIVE(id)) {\n                  stbte__activate(0);\n                  stbte__ui.linking = 0;\n               }\n               break;\n         }\n         break;\n#endif\n\n      case STBTE__tool_erase:\n         switch (stbte__ui.event) {\n            case STBTE__mousemove:\n               if (STBTE__IS_MAP_ACTIVE() && over)\n                  stbte__erase(tm, mapx, mapy, STBTE__erase_all);\n               break;\n            case STBTE__leftdown:\n               if (STBTE__IS_HOT(id) && STBTE__INACTIVE()) {\n                  stbte__activate(id);\n                  stbte__begin_undo(tm);\n                  stbte__erase(tm, mapx, mapy, STBTE__erase_all);\n               }\n               break;\n            case STBTE__leftup:\n               if (STBTE__IS_MAP_ACTIVE()) {\n                  stbte__end_undo(tm);\n                  stbte__activate(0);\n               }\n               break;\n         }\n         break;\n\n      case STBTE__tool_select:\n         if (STBTE__IS_HOT(id)) {\n            switch (stbte__ui.event) {\n               case STBTE__leftdown:\n                  if (STBTE__INACTIVE()) {\n                     // if we're clicking in an existing selection...\n                     if (stbte__ui.has_selection) {\n                        if (  mapx >= stbte__ui.select_x0 && mapx <= stbte__ui.select_x1\n                           && mapy >= stbte__ui.select_y0 && mapy <= stbte__ui.select_y1)\n                        {\n                           stbte__ui.dragging = 1;\n                           stbte__ui.drag_x = stbte__ui.select_x0;\n                           stbte__ui.drag_y = stbte__ui.select_y0;\n                           stbte__ui.drag_w = stbte__ui.select_x1 - stbte__ui.select_x0 + 1;\n                           stbte__ui.drag_h = stbte__ui.select_y1 - stbte__ui.select_y0 + 1;\n                           stbte__ui.drag_offx = mapx - stbte__ui.select_x0;\n                           stbte__ui.drag_offy = mapy - stbte__ui.select_y0;\n                        }\n                     }\n                     stbte__ui.has_selection = 0; // no selection until it completes\n                     stbte__activate_map(mapx,mapy);\n                  }\n                  break;\n               case STBTE__leftup:\n                  if (STBTE__IS_MAP_ACTIVE()) {\n                     if (stbte__ui.dragging) {\n                        stbte__drag_place(tm, mapx,mapy);\n                        stbte__ui.dragging = 0;\n                        stbte__activate(0);\n                     } else {\n                        stbte__select_rect(tm, stbte__ui.sx, stbte__ui.sy, mapx, mapy);\n                        stbte__activate(0);\n                     }\n                  }\n                  break;\n               case STBTE__rightdown:\n                  stbte__ui.has_selection = 0;\n                  break;\n            }\n         }\n         break;\n\n      case STBTE__tool_rect:\n         if (STBTE__IS_HOT(id)) {\n            switch (stbte__ui.event) {\n               case STBTE__leftdown:\n                  if (STBTE__INACTIVE())\n                     stbte__activate_map(mapx,mapy);\n                  break;\n               case STBTE__leftup:\n                  if (STBTE__IS_MAP_ACTIVE()) {\n                     stbte__fillrect(tm, stbte__ui.sx, stbte__ui.sy, mapx, mapy, 1);\n                     stbte__activate(0);\n                  }\n                  break;\n               case STBTE__rightdown:\n                  if (STBTE__INACTIVE())\n                     stbte__activate_map(mapx,mapy);\n                  break;\n               case STBTE__rightup:\n                  if (STBTE__IS_MAP_ACTIVE()) {\n                     stbte__fillrect(tm, stbte__ui.sx, stbte__ui.sy, mapx, mapy, 0);\n                     stbte__activate(0);\n                  }\n                  break;\n            }\n         }\n         break;\n\n\n      case STBTE__tool_eyedrop:\n         switch (stbte__ui.event) {\n            case STBTE__leftdown:\n               if (STBTE__IS_HOT(id) && STBTE__INACTIVE())\n                  stbte__eyedrop(tm,mapx,mapy);\n               break;\n         }\n         break;\n   }\n}\n\nstatic void stbte__start_paste(stbte_tilemap *tm)\n{\n   if (stbte__ui.has_copy) {\n      stbte__ui.pasting = 1;\n      stbte__activate(STBTE__ID(STBTE__toolbarB,3));\n   }\n}\n\nstatic void stbte__toolbar(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   int i;\n   int estimated_width = 13 * STBTE__num_tool + 8+8+ 120+4 - 30;\n   int x = x0 + w/2 - estimated_width/2;\n   int y = y0+1;\n\n   for (i=0; i < STBTE__num_tool; ++i) {\n      int highlight=0, disable=0;\n      highlight = (stbte__ui.tool == i);\n      if (i == STBTE__tool_undo || i == STBTE__tool_showgrid)\n          x += 8;\n      if (i == STBTE__tool_showgrid && stbte__ui.show_grid)\n         highlight = 1;\n      if (i == STBTE__tool_showlinks && stbte__ui.show_links)\n         highlight = 1;\n      if (i == STBTE__tool_fill)\n         continue;\n      #ifndef STBTE_ALLOW_LINK\n      if (i == STBTE__tool_link || i == STBTE__tool_showlinks)\n         disable = 1;\n      #endif\n      if (i == STBTE__tool_undo && !stbte__undo_available(tm))\n         disable = 1;\n      if (i == STBTE__tool_redo && !stbte__redo_available(tm))\n         disable = 1;\n      if (stbte__button_icon(STBTE__ctoolbar_button, toolchar[i], x, y, 13, STBTE__ID(STBTE__toolbarA, i), highlight, disable)) {\n         switch (i) {\n            case STBTE__tool_eyedrop:\n               stbte__ui.eyedrop_last_layer = tm->num_layers; // flush eyedropper state\n               // fallthrough\n            default:\n               stbte__ui.tool = i;\n               stbte__ui.has_selection = 0;\n               break;\n            case STBTE__tool_showlinks:\n               stbte__ui.show_links = !stbte__ui.show_links;\n               break;\n            case STBTE__tool_showgrid:\n               stbte__ui.show_grid = (stbte__ui.show_grid+1)%3;\n               break;\n            case STBTE__tool_undo:\n               stbte__undo(tm);\n               break;\n            case STBTE__tool_redo:\n               stbte__redo(tm);\n               break;\n         }\n      }\n      x += 13;\n   }\n\n   x += 8;\n   if (stbte__button(STBTE__ctoolbar_button, \"cut\"  , x, y,10, 40, STBTE__ID(STBTE__toolbarB,0), 0, !stbte__ui.has_selection))\n      stbte__copy_cut(tm, 1);\n   x += 42;\n   if (stbte__button(STBTE__ctoolbar_button, \"copy\" , x, y, 5, 40, STBTE__ID(STBTE__toolbarB,1), 0, !stbte__ui.has_selection))\n      stbte__copy_cut(tm, 0);\n   x += 42;\n   if (stbte__button(STBTE__ctoolbar_button, \"paste\", x, y, 0, 40, STBTE__ID(STBTE__toolbarB,2), stbte__ui.pasting, !stbte__ui.has_copy))\n      stbte__start_paste(tm);\n}\n\n#define STBTE__TEXTCOLOR(n)  stbte__color_table[n][STBTE__text][STBTE__idle]\n\nstatic int stbte__info_value(const char *label, int x, int y, int val, int digits, int id)\n{\n   if (stbte__ui.event == STBTE__paint) {\n      int off = 9-stbte__get_char_width(label[0]);\n      char text[16];\n      stbte__sprintf(text stbte__sizeof(text), label, digits, val);\n      stbte__draw_text_core(x+off,y, text, 999, STBTE__TEXTCOLOR(STBTE__cpanel),1);\n   }\n   if (id) {\n      x += 9+7*digits+4;\n      if (stbte__minibutton(STBTE__cmapsize, x,y, '+', STBTE__ID2(id,1,0)))\n         val += (stbte__ui.shift ? 10 : 1);\n      x += 9;\n      if (stbte__minibutton(STBTE__cmapsize, x,y, '-', STBTE__ID2(id,2,0)))\n         val -= (stbte__ui.shift ? 10 : 1);\n      if (val < 1) val = 1; else if (val > 4096) val = 4096;\n   }\n   return val;\n}\n\nstatic void stbte__info(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   int mode = stbte__ui.panel[STBTE__panel_info].mode;\n   int s = 11+7*tm->digits+4+15;\n   int x,y;\n   int in_region;\n\n   x = x0+2;\n   y = y0+2;\n   tm->max_x = stbte__info_value(\"w:%*d\",x,y, tm->max_x, tm->digits, STBTE__ID(STBTE__info,0));\n   if (mode)\n      x += s;\n   else\n      y += 11;\n   tm->max_y = stbte__info_value(\"h:%*d\",x,y, tm->max_y, tm->digits, STBTE__ID(STBTE__info,1));\n   x = x0+2;\n   y += 11;\n   in_region = (stbte__ui.hot_id & 127) == STBTE__map;\n   stbte__info_value(in_region ? \"x:%*d\" : \"x:\",x,y, (stbte__ui.hot_id>>19)&4095, tm->digits, 0);\n   if (mode)\n      x += s;\n   else\n      y += 11;\n   stbte__info_value(in_region ? \"y:%*d\" : \"y:\",x,y, (stbte__ui.hot_id>> 7)&4095, tm->digits, 0);\n   y += 15;\n   x = x0+2;\n   stbte__draw_text(x,y,\"brush:\",40,STBTE__TEXTCOLOR(STBTE__cpanel));\n   if (tm->cur_tile >= 0)\n      STBTE_DRAW_TILE(x+43,y-3,tm->tiles[tm->cur_tile].id,1,0);\n}\n\nstatic void stbte__layers(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   static const char *propmodes[3] = {\n      \"default\", \"always\", \"never\"\n   };\n   int num_rows;\n   int i, y, n;\n   int x1 = x0+w;\n   int y1 = y0+h;\n   int xoff = 20;\n\n   if (tm->has_layer_names) {\n      int side = stbte__ui.panel[STBTE__panel_layers].side;\n      xoff = stbte__region[side].width - 42;\n      xoff = (xoff < tm->layername_width + 10 ? xoff : tm->layername_width + 10);\n   }\n\n   x0 += 2;\n   y0 += 5;\n   if (!tm->has_layer_names) {\n      if (stbte__ui.event == STBTE__paint) {\n         stbte__draw_text(x0,y0, \"Layers\", w-4, STBTE__TEXTCOLOR(STBTE__cpanel));\n      }\n      y0 += 11;\n   }\n   num_rows = (y1-y0)/15;\n#ifndef STBTE_NO_PROPS\n   --num_rows;\n#endif\n   y = y0;\n   for (i=0; i < tm->num_layers; ++i) {\n      char text[3], *str = (char *) tm->layerinfo[i].name;\n      static char lockedchar[3] = { 'U', 'P', 'L' };\n      int locked = tm->layerinfo[i].locked;\n      int disabled = (tm->solo_layer >= 0 && tm->solo_layer != i);\n      if (i-tm->layer_scroll >= 0 && i-tm->layer_scroll < num_rows) {\n         if (str == NULL)\n            stbte__sprintf(str=text stbte__sizeof(text), \"%2d\", i+1);\n         if (stbte__button(STBTE__clayer_button, str, x0,y,(i+1<10)*2,xoff-2, STBTE__ID(STBTE__layer,i), tm->cur_layer==i,0))\n            tm->cur_layer = (tm->cur_layer == i ? -1 : i);\n         if (stbte__layerbutton(x0+xoff +  0,y+1,'H',STBTE__ID(STBTE__hide,i), tm->layerinfo[i].hidden,disabled,STBTE__clayer_hide))\n            tm->layerinfo[i].hidden = !tm->layerinfo[i].hidden;\n         if (stbte__layerbutton(x0+xoff + 12,y+1,lockedchar[locked],STBTE__ID(STBTE__lock,i), locked!=0,disabled,STBTE__clayer_lock))\n            tm->layerinfo[i].locked = (locked+1)%3;\n         if (stbte__layerbutton(x0+xoff + 24,y+1,'S',STBTE__ID(STBTE__solo,i), tm->solo_layer==i,0,STBTE__clayer_solo))\n            tm->solo_layer = (tm->solo_layer == i ? -1 : i);\n         y += 15;\n      }\n   }\n   stbte__scrollbar(x1-4, y0,y-2, &tm->layer_scroll, 0, tm->num_layers, num_rows, STBTE__ID(STBTE__scrollbar_id, STBTE__layer));\n#ifndef STBTE_NO_PROPS\n   n = stbte__text_width(\"prop:\")+2;\n   stbte__draw_text(x0,y+2, \"prop:\", w, STBTE__TEXTCOLOR(STBTE__cpanel));\n   i = w - n - 4;\n   if (i > 50) i = 50;\n   if (stbte__button(STBTE__clayer_button, propmodes[tm->propmode], x0+n,y,0,i, STBTE__ID(STBTE__layer,256), 0,0))\n      tm->propmode = (tm->propmode+1)%3;\n#endif\n}\n\nstatic void stbte__categories(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   int s=11, x,y, i;\n   int num_rows = h / s;\n\n   w -= 4;\n   x = x0+2;\n   y = y0+4;\n   if (tm->category_scroll == 0) {\n      if (stbte__category_button(\"*ALL*\", x,y, w, STBTE__ID(STBTE__categories, 65535), tm->cur_category == -1)) {\n         stbte__choose_category(tm, -1);\n      }\n      y += s;\n   }\n\n   for (i=0; i < tm->num_categories; ++i) {\n      if (i+1 - tm->category_scroll >= 0 && i+1 - tm->category_scroll < num_rows) {\n         if (y + 10 > y0+h)\n            return;\n         if (stbte__category_button(tm->categories[i], x,y,w, STBTE__ID(STBTE__categories,i), tm->cur_category == i))\n            stbte__choose_category(tm, i);\n         y += s;\n      }\n   }\n   stbte__scrollbar(x0+w, y0+4, y0+h-4, &tm->category_scroll, 0, tm->num_categories+1, num_rows, STBTE__ID(STBTE__scrollbar_id, STBTE__categories));\n}\n\nstatic void stbte__tile_in_palette(stbte_tilemap *tm, int x, int y, int slot)\n{\n   stbte__tileinfo *t = &tm->tiles[slot];\n   int x0=x, y0=y, x1 = x+tm->palette_spacing_x - 1, y1 = y+tm->palette_spacing_y;\n   int id = STBTE__ID(STBTE__palette, slot);\n   stbte__hittest(x0,y0,x1,y1, id);\n   switch (stbte__ui.event) {\n      case STBTE__paint:\n         stbte__draw_rect(x,y,x+tm->palette_spacing_x-1,y+tm->palette_spacing_x-1, STBTE_COLOR_TILEPALETTE_BACKGROUND);\n         STBTE_DRAW_TILE(x,y,id, slot == tm->cur_tile,0);\n         if (slot == tm->cur_tile)\n            stbte__draw_frame_delayed(x-1,y-1,x+tm->palette_spacing_x,y+tm->palette_spacing_y, STBTE_COLOR_TILEPALETTE_OUTLINE);\n         break;\n      default:\n         if (stbte__button_core(id))\n            tm->cur_tile = slot;\n         break;\n   }\n}\n\nstatic void stbte__palette_of_tiles(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   int i,x,y;\n   int num_vis_rows = (h-6) / tm->palette_spacing_y;\n   int num_columns = (w-2-6) / tm->palette_spacing_x;\n   int num_total_rows;\n   int column,row;\n   int x1 = x0+w, y1=y0+h;\n   x = x0+2;\n   y = y0+6;\n\n   if (num_columns == 0)\n      return;\n\n   num_total_rows = (tm->cur_palette_count + num_columns-1) / num_columns; // ceil()\n\n   column = 0;\n   row    = -tm->palette_scroll;\n   for (i=0; i < tm->num_tiles; ++i) {\n      stbte__tileinfo *t = &tm->tiles[i];\n\n      // filter based on category\n      if (tm->cur_category >= 0 && t->category_id != tm->cur_category)\n         continue;\n\n      // display it\n      if (row >= 0 && row < num_vis_rows) {\n         x = x0 + 2 + tm->palette_spacing_x * column;\n         y = y0 + 6 + tm->palette_spacing_y * row;\n         stbte__tile_in_palette(tm,x,y,i);\n      }\n\n      ++column;\n      if (column == num_columns) {\n         column = 0;\n         ++row;\n      }\n   }\n   stbte__flush_delay();\n   stbte__scrollbar(x1-4, y0+6, y1-2, &tm->palette_scroll, 0, num_total_rows, num_vis_rows, STBTE__ID(STBTE__scrollbar_id, STBTE__palette));\n}\n\nstatic float stbte__saved;\nstatic void stbte__props_panel(stbte_tilemap *tm, int x0, int y0, int w, int h)\n{\n   int x1 = x0+w;\n   int i;\n   int y = y0 + 5, x = x0+2;\n   int slider_width = 60;\n   int mx,my;\n   float *p;\n   short *data;\n   if (!stbte__is_single_selection())\n      return;\n   mx = stbte__ui.select_x0;\n   my = stbte__ui.select_y0;\n   p = tm->props[my][mx];\n   data = tm->data[my][mx];\n   STBTE__NOTUSED(data);\n   for (i=0; i < STBTE_MAX_PROPERTIES; ++i) {\n      unsigned int n = STBTE_PROP_TYPE(i, data, p);\n      if (n) {\n         char *s = (char*) STBTE_PROP_NAME(i, data, p);\n         if (s == NULL) s = (char*) \"\";\n         switch (n & 3) {\n            case STBTE_PROP_bool: {\n               int flag = (int) p[i];\n               if (stbte__layerbutton(x,y, flag ? 'x' : ' ', STBTE__ID(STBTE__prop_flag,i), flag, 0, 2)) {\n                  stbte__begin_undo(tm);\n                  stbte__undo_record_prop_float(tm,mx,my,i,(float) flag);\n                  p[i] = (float) !flag;\n                  stbte__end_undo(tm);\n               }\n               stbte__draw_text(x+13,y+1,s,x1-(x+13)-2,STBTE__TEXTCOLOR(STBTE__cpanel));\n               y += 13;\n               break;\n            }\n            case STBTE_PROP_int: {\n               int a = (int) STBTE_PROP_MIN(i,data,p);\n               int b = (int) STBTE_PROP_MAX(i,data,p);\n               int v = (int) p[i] - a;\n               if (a+v != p[i] || v < 0 || v > b-a) {\n                  if (v < 0) v = 0;\n                  if (v > b-a) v = b-a;\n                  p[i] = (float) (a+v); // @TODO undo\n               }\n               switch (stbte__slider(x, slider_width, y+7, b-a, &v, STBTE__ID(STBTE__prop_int,i)))\n               {\n                  case STBTE__begin:\n                     stbte__saved = p[i];\n                     // fallthrough\n                  case STBTE__change:\n                     p[i] = (float) (a+v); // @TODO undo\n                     break;\n                  case STBTE__end:\n                     if (p[i] != stbte__saved) {\n                        stbte__begin_undo(tm);\n                        stbte__undo_record_prop_float(tm,mx,my,i,stbte__saved);\n                        stbte__end_undo(tm);\n                     }\n                     break;\n               }\n               stbte__draw_text(x+slider_width+2,y+2, s, x1-1-(x+slider_width+2), STBTE__TEXTCOLOR(STBTE__cpanel));\n               y += 12;\n               break;\n            }\n            case STBTE_PROP_float: {\n               float a = (float) STBTE_PROP_MIN(i, data,p);\n               float b = (float) STBTE_PROP_MAX(i, data,p);\n               float c = STBTE_PROP_FLOAT_SCALE(i, data, p);\n               float old;\n               if (p[i] < a || p[i] > b) {\n                  // @TODO undo\n                  if (p[i] < a) p[i] = a;\n                  if (p[i] > b) p[i] = b;\n               }\n               old = p[i];\n               switch (stbte__float_control(x, y, 50, a, b, c, \"%8.4f\", &p[i], STBTE__layer,STBTE__ID(STBTE__prop_float,i))) {\n                  case STBTE__begin:\n                     stbte__saved = old;\n                     break;\n                  case STBTE__end:\n                     if (stbte__saved != p[i]) {\n                        stbte__begin_undo(tm);\n                        stbte__undo_record_prop_float(tm,mx,my,i, stbte__saved);\n                        stbte__end_undo(tm);\n                     }\n                     break;\n               }\n               stbte__draw_text(x+53,y+1, s, x1-1-(x+53), STBTE__TEXTCOLOR(STBTE__cpanel));\n               y += 12;\n               break;\n            }\n         }\n      }\n   }\n}\n\nstatic int stbte__cp_mode, stbte__cp_aspect, stbte__save, stbte__cp_altered;\n#ifdef STBTE__COLORPICKER\nstatic int stbte__cp_state, stbte__cp_index, stbte__color_copy;\nstatic void stbte__dump_colorstate(void)\n{\n   int i,j,k;\n   printf(\"static int stbte__color_table[STBTE__num_color_modes][STBTE__num_color_aspects][STBTE__num_color_states] =\\n\");\n   printf(\"{\\n\");\n   printf(\"   {\\n\");\n   for (k=0; k < STBTE__num_color_modes; ++k) {\n      for (j=0; j < STBTE__num_color_aspects; ++j) {\n         printf(\"      { \");\n         for (i=0; i < STBTE__num_color_states; ++i) {\n            printf(\"0x%06x, \", stbte__color_table[k][j][i]);\n         }\n         printf(\"},\\n\");\n      }\n      if (k+1 < STBTE__num_color_modes)\n         printf(\"   }, {\\n\");\n      else\n         printf(\"   },\\n\");\n   }\n   printf(\"};\\n\");\n}\n\nstatic void stbte__colorpicker(int x0, int y0, int w, int h)\n{\n   int x1 = x0+w, y1 = y0+h, x,y, i;\n\n   x =  x0+2; y = y0+6;\n\n   y += 5;\n   x += 8;\n\n\n   {\n      int color = stbte__color_table[stbte__cp_mode][stbte__cp_aspect][stbte__cp_index];\n      int rgb[3];\n      if (stbte__cp_altered && stbte__cp_index == STBTE__idle)\n         color = stbte__save;\n\n      if (stbte__minibutton(STBTE__cmapsize, x1-20,y+ 5, 'C', STBTE__ID2(STBTE__colorpick_id,4,0)))\n         stbte__color_copy = color;\n      if (stbte__minibutton(STBTE__cmapsize, x1-20,y+15, 'P', STBTE__ID2(STBTE__colorpick_id,4,1)))\n         color = stbte__color_copy;\n\n      rgb[0] = color >> 16; rgb[1] = (color>>8)&255; rgb[2] = color & 255;\n      for (i=0; i < 3; ++i) {\n         if (stbte__slider(x+8,64, y, 255, rgb+i, STBTE__ID2(STBTE__colorpick_id,3,i)) > 0)\n            stbte__dump_colorstate();\n         y += 15;\n      }\n      if (stbte__ui.event != STBTE__paint && stbte__ui.event != STBTE__tick)\n         stbte__color_table[stbte__cp_mode][stbte__cp_aspect][stbte__cp_index] = (rgb[0]<<16)|(rgb[1]<<8)|(rgb[2]);\n   }\n\n   y += 5;\n\n   // states\n   x = x0+2+35;\n   if (stbte__ui.event == STBTE__paint) {\n      static char *states[] = { \"idle\", \"over\", \"down\", \"down&over\", \"selected\", \"selected&over\", \"disabled\" };\n      stbte__draw_text(x, y+1, states[stbte__cp_index], x1-x-1, 0xffffff);\n   }\n\n   x = x0+24; y += 12;\n\n   for (i=3; i >= 0; --i) {\n      int state = 0 != (stbte__cp_state & (1 << i));\n      if (stbte__layerbutton(x,y, \"OASD\"[i], STBTE__ID2(STBTE__colorpick_id, 0,i), state,0, STBTE__clayer_button)) {\n         stbte__cp_state ^= (1 << i);\n         stbte__cp_index = stbte__state_to_index[0][0][0][stbte__cp_state];\n      }\n      x += 16;\n   }\n   x = x0+2; y += 18;\n\n   for (i=0; i < 3; ++i) {\n      static char *labels[] = { \"Base\", \"Edge\", \"Text\" };\n      if (stbte__button(STBTE__ctoolbar_button, labels[i], x,y,0,36, STBTE__ID2(STBTE__colorpick_id,1,i), stbte__cp_aspect==i,0))\n         stbte__cp_aspect = i;\n      x += 40;\n   }\n\n   y += 18;\n   x = x0+2;\n\n   for (i=0; i < STBTE__num_color_modes; ++i) {\n      if (stbte__button(STBTE__ctoolbar_button, stbte__color_names[i], x, y, 0,80, STBTE__ID2(STBTE__colorpick_id,2,i), stbte__cp_mode == i,0))\n         stbte__cp_mode = i;\n      y += 12;\n   }\n\n   // make the currently selected aspect flash, unless we're actively dragging color slider etc\n   if (stbte__ui.event == STBTE__tick) {\n      stbte__save = stbte__color_table[stbte__cp_mode][stbte__cp_aspect][STBTE__idle];\n      if ((stbte__ui.active_id & 127) != STBTE__colorpick_id) {\n         if ((stbte__ui.ms_time & 2047) < 200) {\n            stbte__color_table[stbte__cp_mode][stbte__cp_aspect][STBTE__idle] ^= 0x1f1f1f;\n            stbte__cp_altered = 1;\n         }\n      }\n   }\n}\n#endif\n\nstatic void stbte__editor_traverse(stbte_tilemap *tm)\n{\n   int i,j,i0,j0,i1,j1,n;\n\n   if (tm == NULL)\n      return;\n   if (stbte__ui.x0 == stbte__ui.x1 || stbte__ui.y0 == stbte__ui.y1)\n      return;\n\n   stbte__prepare_tileinfo(tm);\n\n   stbte__compute_panel_locations(tm); // @OPTIMIZE: we don't need to recompute this every time\n\n   if (stbte__ui.event == STBTE__paint) {\n      // fill screen with border\n      stbte__draw_rect(stbte__ui.x0, stbte__ui.y0, stbte__ui.x1, stbte__ui.y1, STBTE_COLOR_TILEMAP_BORDER);\n      // fill tilemap with tilemap background\n      stbte__draw_rect(stbte__ui.x0 - tm->scroll_x, stbte__ui.y0 - tm->scroll_y,\n                       stbte__ui.x0 - tm->scroll_x + tm->spacing_x * tm->max_x,\n                       stbte__ui.y0 - tm->scroll_y + tm->spacing_y * tm->max_y, STBTE_COLOR_TILEMAP_BACKGROUND);\n   }\n\n   // step 1: traverse all the tilemap data...\n\n   i0 = (tm->scroll_x - tm->spacing_x) / tm->spacing_x;\n   j0 = (tm->scroll_y - tm->spacing_y) / tm->spacing_y;\n   i1 = (tm->scroll_x + stbte__ui.x1 - stbte__ui.x0) / tm->spacing_x + 1;\n   j1 = (tm->scroll_y + stbte__ui.y1 - stbte__ui.y0) / tm->spacing_y + 1;\n\n   if (i0 < 0) i0 = 0;\n   if (j0 < 0) j0 = 0;\n   if (i1 > tm->max_x) i1 = tm->max_x;\n   if (j1 > tm->max_y) j1 = tm->max_y;\n\n   if (stbte__ui.event == STBTE__paint) {\n      // draw all of layer 0, then all of layer 1, etc, instead of old\n      // way which drew entire stack of each tile at once\n      for (n=0; n < tm->num_layers; ++n) {\n         for (j=j0; j < j1; ++j) {\n            for (i=i0; i < i1; ++i) {\n               int x = stbte__ui.x0 + i * tm->spacing_x - tm->scroll_x;\n               int y = stbte__ui.y0 + j * tm->spacing_y - tm->scroll_y;\n               stbte__tile_paint(tm, x, y, i, j, n);\n            }\n         }\n         if (n == 0 && stbte__ui.show_grid == 1) {\n            int x = stbte__ui.x0 + i0 * tm->spacing_x - tm->scroll_x;\n            int y = stbte__ui.y0 + j0 * tm->spacing_y - tm->scroll_y;\n            for (i=0; x < stbte__ui.x1 && i <= i1; ++i, x += tm->spacing_x)\n               stbte__draw_rect(x, stbte__ui.y0, x+1, stbte__ui.y1, STBTE_COLOR_GRID);\n            for (j=0; y < stbte__ui.y1 && j <= j1; ++j, y += tm->spacing_y)\n               stbte__draw_rect(stbte__ui.x0, y, stbte__ui.x1, y+1, STBTE_COLOR_GRID);\n         }\n      }\n   }\n\n   if (stbte__ui.event == STBTE__paint) {\n      // draw grid on top of everything except UI\n      if (stbte__ui.show_grid == 2) {\n         int x = stbte__ui.x0 + i0 * tm->spacing_x - tm->scroll_x;\n         int y = stbte__ui.y0 + j0 * tm->spacing_y - tm->scroll_y;\n         for (i=0; x < stbte__ui.x1 && i <= i1; ++i, x += tm->spacing_x)\n            stbte__draw_rect(x, stbte__ui.y0, x+1, stbte__ui.y1, STBTE_COLOR_GRID);\n         for (j=0; y < stbte__ui.y1 && j <= j1; ++j, y += tm->spacing_y)\n            stbte__draw_rect(stbte__ui.x0, y, stbte__ui.x1, y+1, STBTE_COLOR_GRID);\n      }\n   }\n\n   for (j=j0; j < j1; ++j) {\n      for (i=i0; i < i1; ++i) {\n         int x = stbte__ui.x0 + i * tm->spacing_x - tm->scroll_x;\n         int y = stbte__ui.y0 + j * tm->spacing_y - tm->scroll_y;\n         stbte__tile(tm, x, y, i, j);\n      }\n   }\n\n   if (stbte__ui.event == STBTE__paint) {\n      // draw the selection border\n      if (stbte__ui.has_selection) {\n         int x0,y0,x1,y1;\n         x0 = stbte__ui.x0 + (stbte__ui.select_x0    ) * tm->spacing_x - tm->scroll_x;\n         y0 = stbte__ui.y0 + (stbte__ui.select_y0    ) * tm->spacing_y - tm->scroll_y;\n         x1 = stbte__ui.x0 + (stbte__ui.select_x1 + 1) * tm->spacing_x - tm->scroll_x + 1;\n         y1 = stbte__ui.y0 + (stbte__ui.select_y1 + 1) * tm->spacing_y - tm->scroll_y + 1;\n         stbte__draw_frame(x0,y0,x1,y1, (stbte__ui.ms_time & 256 ? STBTE_COLOR_SELECTION_OUTLINE1 : STBTE_COLOR_SELECTION_OUTLINE2));\n      }\n\n      stbte__flush_delay(); // draw a dynamic link on top of the queued links\n\n      #ifdef STBTE_ALLOW_LINK\n      if (stbte__ui.linking && STBTE__IS_MAP_HOT()) {\n         int x0,y0,x1,y1;\n         int color;\n         int ex = ((stbte__ui.hot_id >> 19) & 4095);\n         int ey = ((stbte__ui.hot_id >>  7) & 4095);\n         x0 = stbte__ui.x0 + (stbte__ui.sx    ) * tm->spacing_x - tm->scroll_x + (tm->spacing_x>>1)+1;\n         y0 = stbte__ui.y0 + (stbte__ui.sy    ) * tm->spacing_y - tm->scroll_y + (tm->spacing_y>>1)+1;\n         x1 = stbte__ui.x0 + (ex              ) * tm->spacing_x - tm->scroll_x + (tm->spacing_x>>1)-1;\n         y1 = stbte__ui.y0 + (ey              ) * tm->spacing_y - tm->scroll_y + (tm->spacing_y>>1)-1;\n         if (STBTE_ALLOW_LINK(tm->data[stbte__ui.sy][stbte__ui.sx], tm->props[stbte__ui.sy][stbte__ui.sx], tm->data[ey][ex], tm->props[ey][ex]))\n            color = STBTE_LINK_COLOR_DRAWING;\n         else\n            color = STBTE_LINK_COLOR_DISALLOWED;\n         stbte__draw_link(x0,y0,x1,y1, color);\n      }\n      #endif\n   }\n   stbte__flush_delay();\n\n   // step 2: traverse the panels\n   for (i=0; i < STBTE__num_panel; ++i) {\n      stbte__panel *p = &stbte__ui.panel[i];\n      if (stbte__ui.event == STBTE__paint) {\n         stbte__draw_box(p->x0,p->y0,p->x0+p->width,p->y0+p->height, STBTE__cpanel, STBTE__idle);\n      }\n      // obscure tilemap data underneath panel\n      stbte__hittest(p->x0,p->y0,p->x0+p->width,p->y0+p->height, STBTE__ID2(STBTE__panel, i, 0));\n      switch (i) {\n         case STBTE__panel_toolbar:\n            if (stbte__ui.event == STBTE__paint)\n               stbte__draw_rect(p->x0,p->y0,p->x0+p->width,p->y0+p->height, stbte__color_table[STBTE__ctoolbar][STBTE__base][STBTE__idle]);\n            stbte__toolbar(tm,p->x0,p->y0,p->width,p->height);\n            break;\n         case STBTE__panel_info:\n            stbte__info(tm,p->x0,p->y0,p->width,p->height);\n            break;\n         case STBTE__panel_layers:\n            stbte__layers(tm,p->x0,p->y0,p->width,p->height);\n            break;\n         case STBTE__panel_categories:\n            stbte__categories(tm,p->x0,p->y0,p->width,p->height);\n            break;\n         case STBTE__panel_colorpick:\n#ifdef STBTE__COLORPICKER\n            stbte__colorpicker(p->x0,p->y0,p->width,p->height);\n#endif\n            break;\n         case STBTE__panel_tiles:\n            // erase boundary between categories and tiles if they're on same side\n            if (stbte__ui.event == STBTE__paint && p->side == stbte__ui.panel[STBTE__panel_categories].side)\n               stbte__draw_rect(p->x0+1,p->y0-1,p->x0+p->width-1,p->y0+1, stbte__color_table[STBTE__cpanel][STBTE__base][STBTE__idle]);\n            stbte__palette_of_tiles(tm,p->x0,p->y0,p->width,p->height);\n            break;\n         case STBTE__panel_props:\n            stbte__props_panel(tm,p->x0,p->y0,p->width,p->height);\n            break;\n      }\n      // draw the panel side selectors\n      for (j=0; j < 2; ++j) {\n         int result;\n         if (i == STBTE__panel_toolbar) continue;\n         result = stbte__microbutton(p->x0+p->width - 1 - 2*4 + 4*j,p->y0+2,3, STBTE__ID2(STBTE__panel, i, j+1), STBTE__cpanel_sider+j);\n         if (result) {\n            switch (j) {\n               case 0: p->side = result > 0 ? STBTE__side_left : STBTE__side_right; break;\n               case 1: p->delta_height += result; break;\n            }\n         }\n      }\n   }\n\n   if (stbte__ui.panel[STBTE__panel_categories].delta_height < -5) stbte__ui.panel[STBTE__panel_categories].delta_height = -5;\n   if (stbte__ui.panel[STBTE__panel_layers    ].delta_height < -5) stbte__ui.panel[STBTE__panel_layers    ].delta_height = -5;\n\n\n   // step 3: traverse the regions to place expander controls on them\n   for (i=0; i < 2; ++i) {\n      if (stbte__region[i].active) {\n         int x = stbte__region[i].x;\n         int width;\n         if (i == STBTE__side_left)\n            width =  stbte__ui.left_width , x += stbte__region[i].width + 1;\n         else\n            width = -stbte__ui.right_width, x -= 6;\n         if (stbte__microbutton_dragger(x, stbte__region[i].y+2, 5, STBTE__ID(STBTE__region,i), &width)) {\n            // if non-0, it is expanding, so retract it\n            if (stbte__region[i].retracted == 0.0)\n               stbte__region[i].retracted = 0.01f;\n            else\n               stbte__region[i].retracted = 0.0;\n         }\n         if (i == STBTE__side_left)\n            stbte__ui.left_width  =  width;\n         else\n            stbte__ui.right_width = -width;\n         if (stbte__ui.event == STBTE__tick) {\n            if (stbte__region[i].retracted && stbte__region[i].retracted < 1.0f) {\n               stbte__region[i].retracted += stbte__ui.dt*4;\n               if (stbte__region[i].retracted > 1)\n                  stbte__region[i].retracted = 1;\n            }\n         }\n      }\n   }\n\n   if (stbte__ui.event == STBTE__paint && stbte__ui.alert_msg) {\n      int w = stbte__text_width(stbte__ui.alert_msg);\n      int x = (stbte__ui.x0+stbte__ui.x1)/2;\n      int y = (stbte__ui.y0+stbte__ui.y1)*5/6;\n      stbte__draw_rect (x-w/2-4,y-8, x+w/2+4,y+8, 0x604020);\n      stbte__draw_frame(x-w/2-4,y-8, x+w/2+4,y+8, 0x906030);\n      stbte__draw_text (x-w/2,y-4, stbte__ui.alert_msg, w+1, 0xff8040);\n   }\n\n#ifdef STBTE_SHOW_CURSOR\n   if (stbte__ui.event == STBTE__paint)\n      stbte__draw_bitmap(stbte__ui.mx, stbte__ui.my, stbte__get_char_width(26), stbte__get_char_bitmap(26), 0xe0e0e0);\n#endif\n\n   if (stbte__ui.event == STBTE__tick && stbte__ui.alert_msg) {\n      stbte__ui.alert_timer -= stbte__ui.dt;\n      if (stbte__ui.alert_timer < 0) {\n         stbte__ui.alert_timer = 0;\n         stbte__ui.alert_msg = 0;\n      }\n   }\n\n   if (stbte__ui.event == STBTE__paint) {\n      stbte__color_table[stbte__cp_mode][stbte__cp_aspect][STBTE__idle] = stbte__save;\n      stbte__cp_altered = 0;\n   }\n}\n\nstatic void stbte__do_event(stbte_tilemap *tm)\n{\n   stbte__ui.next_hot_id = 0;\n   stbte__editor_traverse(tm);\n   stbte__ui.hot_id = stbte__ui.next_hot_id;\n\n   // automatically cancel on mouse-up in case the object that triggered it\n   // doesn't exist anymore\n   if (stbte__ui.active_id) {\n      if (stbte__ui.event == STBTE__leftup || stbte__ui.event == STBTE__rightup) {\n         if (!stbte__ui.pasting) {\n            stbte__activate(0);\n            if (stbte__ui.undoing)\n               stbte__end_undo(tm);\n            stbte__ui.scrolling = 0;\n            stbte__ui.dragging = 0;\n            stbte__ui.linking = 0;\n         }\n      }\n   }\n\n   // we could do this stuff in the widgets directly, but it would keep recomputing\n   // the same thing on every tile, which seems dumb.\n\n   if (stbte__ui.pasting) {\n      if (STBTE__IS_MAP_HOT()) {\n         // compute pasting location based on last hot\n         stbte__ui.paste_x = ((stbte__ui.hot_id >> 19) & 4095) - (stbte__ui.copy_width >> 1);\n         stbte__ui.paste_y = ((stbte__ui.hot_id >>  7) & 4095) - (stbte__ui.copy_height >> 1);\n      }\n   }\n   if (stbte__ui.dragging) {\n      if (STBTE__IS_MAP_HOT()) {\n         stbte__ui.drag_dest_x = ((stbte__ui.hot_id >> 19) & 4095) - stbte__ui.drag_offx;\n         stbte__ui.drag_dest_y = ((stbte__ui.hot_id >>  7) & 4095) - stbte__ui.drag_offy;\n      }\n   }\n}\n\nstatic void stbte__set_event(int event, int x, int y)\n{\n   stbte__ui.event = event;\n   stbte__ui.mx    = x;\n   stbte__ui.my    = y;\n   stbte__ui.dx    = x - stbte__ui.last_mouse_x;\n   stbte__ui.dy    = y - stbte__ui.last_mouse_y;\n   stbte__ui.last_mouse_x = x;\n   stbte__ui.last_mouse_y = y;\n   stbte__ui.accum_x += stbte__ui.dx;\n   stbte__ui.accum_y += stbte__ui.dy;\n}\n\nvoid stbte_draw(stbte_tilemap *tm)\n{\n   stbte__ui.event = STBTE__paint;\n   stbte__editor_traverse(tm);\n}\n\nvoid stbte_mouse_move(stbte_tilemap *tm, int x, int y, int shifted, int scrollkey)\n{\n   stbte__set_event(STBTE__mousemove, x,y);\n   stbte__ui.shift = shifted;\n   stbte__ui.scrollkey = scrollkey;\n   stbte__do_event(tm);\n}\n\nvoid stbte_mouse_button(stbte_tilemap *tm, int x, int y, int right, int down, int shifted, int scrollkey)\n{\n   static int events[2][2] = { { STBTE__leftup , STBTE__leftdown  },\n                               { STBTE__rightup, STBTE__rightdown } };\n   stbte__set_event(events[right][down], x,y);\n   stbte__ui.shift = shifted;\n   stbte__ui.scrollkey = scrollkey;\n\n   stbte__do_event(tm);\n}\n\nvoid stbte_mouse_wheel(stbte_tilemap *tm, int x, int y, int vscroll)\n{\n   // not implemented yet -- need different way of hittesting\n}\n\nvoid stbte_action(stbte_tilemap *tm, enum stbte_action act)\n{\n   switch (act) {\n      case STBTE_tool_select:      stbte__ui.tool = STBTE__tool_select;               break;\n      case STBTE_tool_brush:       stbte__ui.tool = STBTE__tool_brush;                break;\n      case STBTE_tool_erase:       stbte__ui.tool = STBTE__tool_erase;                break;\n      case STBTE_tool_rectangle:   stbte__ui.tool = STBTE__tool_rect;                 break;\n      case STBTE_tool_eyedropper:  stbte__ui.tool = STBTE__tool_eyedrop;              break;\n      case STBTE_tool_link:        stbte__ui.tool = STBTE__tool_link;                 break;\n      case STBTE_act_toggle_grid:  stbte__ui.show_grid = (stbte__ui.show_grid+1) % 3; break;\n      case STBTE_act_toggle_links: stbte__ui.show_links ^= 1;                         break;\n      case STBTE_act_undo:         stbte__undo(tm);                                   break;\n      case STBTE_act_redo:         stbte__redo(tm);                                   break;\n      case STBTE_act_cut:          stbte__copy_cut(tm, 1);                            break;\n      case STBTE_act_copy:         stbte__copy_cut(tm, 0);                            break;\n      case STBTE_act_paste:        stbte__start_paste(tm);                            break;\n      case STBTE_scroll_left:      tm->scroll_x -= tm->spacing_x;                     break;\n      case STBTE_scroll_right:     tm->scroll_x += tm->spacing_x;                     break;\n      case STBTE_scroll_up:        tm->scroll_y -= tm->spacing_y;                     break;\n      case STBTE_scroll_down:      tm->scroll_y += tm->spacing_y;                     break;\n   }\n}\n\nvoid stbte_tick(stbte_tilemap *tm, float dt)\n{\n   stbte__ui.event = STBTE__tick;\n   stbte__ui.dt    = dt;\n   stbte__do_event(tm);\n   stbte__ui.ms_time += (int) (dt * 1024) + 1; // make sure if time is superfast it always updates a little\n}\n\nvoid stbte_mouse_sdl(stbte_tilemap *tm, const void *sdl_event, float xs, float ys, int xo, int yo)\n{\n#ifdef _SDL_H\n   SDL_Event *event = (SDL_Event *) sdl_event;\n   SDL_Keymod km = SDL_GetModState();\n   int shift = (km & KMOD_LCTRL) || (km & KMOD_RCTRL);\n   int scrollkey = 0 != SDL_GetKeyboardState(NULL)[SDL_SCANCODE_SPACE];\n   switch (event->type) {\n      case SDL_MOUSEMOTION:\n         stbte_mouse_move(tm, (int) (xs*event->motion.x+xo), (int) (ys*event->motion.y+yo), shift, scrollkey);\n         break;\n      case SDL_MOUSEBUTTONUP:\n         stbte_mouse_button(tm, (int) (xs*event->button.x+xo), (int) (ys*event->button.y+yo), event->button.button != SDL_BUTTON_LEFT, 0, shift, scrollkey);\n         break;\n      case SDL_MOUSEBUTTONDOWN:\n         stbte_mouse_button(tm, (int) (xs*event->button.x+xo), (int) (ys*event->button.y+yo), event->button.button != SDL_BUTTON_LEFT, 1, shift, scrollkey);\n         break;\n      case SDL_MOUSEWHEEL:\n         stbte_mouse_wheel(tm, stbte__ui.mx, stbte__ui.my, event->wheel.y);\n         break;\n   }\n#else\n   STBTE__NOTUSED(tm);\n   STBTE__NOTUSED(sdl_event);\n   STBTE__NOTUSED(xs);\n   STBTE__NOTUSED(ys);\n   STBTE__NOTUSED(xo);\n   STBTE__NOTUSED(yo);\n#endif\n}\n\n#endif // STB_TILEMAP_EDITOR_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_truetype.h",
          "type": "blob",
          "size": 194.5234375,
          "content": "// stb_truetype.h - v1.26 - public domain\n// authored from 2009-2021 by Sean Barrett / RAD Game Tools\n//\n// =======================================================================\n//\n//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES\n//\n// This library does no range checking of the offsets found in the file,\n// meaning an attacker can use it to read arbitrary memory.\n//\n// =======================================================================\n//\n//   This library processes TrueType files:\n//        parse files\n//        extract glyph metrics\n//        extract glyph shapes\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\n//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)\n//\n//   Todo:\n//        non-MS cmaps\n//        crashproof on bad data\n//        hinting? (no longer patented)\n//        cleartype-style AA?\n//        optimize: use simple memory allocator for intermediates\n//        optimize: build edge-list directly from curves\n//        optimize: rasterize directly from curves?\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Mikko Mononen: compound shape support, more cmap formats\n//   Tor Andersson: kerning, subpixel rendering\n//   Dougall Johnson: OpenType / Type 2 font handling\n//   Daniel Ribeiro Maciel: basic GPOS-based kerning\n//\n//   Misc other:\n//       Ryan Gordon\n//       Simon Glass\n//       github:IntellectualKitty\n//       Imanol Celaya\n//       Daniel Ribeiro Maciel\n//\n//   Bug/warning reports/fixes:\n//       \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen   github:NiLuJe\n//       Cass Everitt               Martins Mozeiko       github:aloucks\n//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam\n//       Brian Hook                 Omar Cornut           github:vassvik\n//       Walter van Niftrik         Ryan Griege\n//       David Gow                  Peter LaValle\n//       David Given                Sergey Popov\n//       Ivan-Assen Ivanov          Giumo X. Clanjor\n//       Anthony Pesch              Higor Euripedes\n//       Johan Duparc               Thomas Fields\n//       Hou Qiming                 Derek Vinyard\n//       Rob Loach                  Cort Stratton\n//       Kenney Phillis Jr.         Brian Costabile\n//       Ken Voskuil (kaesve)       Yakov Galka\n//\n// VERSION HISTORY\n//\n//   1.26 (2021-08-28) fix broken rasterizer\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     variant PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//\n//   Full history can be found at the end of this file.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// USAGE\n//\n//   Include this file in whatever places need to refer to it. In ONE C/C++\n//   file, write:\n//      #define STB_TRUETYPE_IMPLEMENTATION\n//   before the #include of this file. This expands out the actual\n//   implementation into that C/C++ file.\n//\n//   To make the implementation private to the file that generates the implementation,\n//      #define STBTT_STATIC\n//\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start)\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\n//\n//   Improved 3D API (more shippable):\n//           #include \"stb_rect_pack.h\"           -- optional, but you really want it\n//           stbtt_PackBegin()\n//           stbtt_PackSetOversampling()          -- for improved quality on small fonts\n//           stbtt_PackFontRanges()               -- pack and renders\n//           stbtt_PackEnd()\n//           stbtt_GetPackedQuad()\n//\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\n//           stbtt_InitFont()\n//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections\n//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections\n//\n//   Render a unicode codepoint to a bitmap\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\n//\n//   Character advance/positioning\n//           stbtt_GetCodepointHMetrics()\n//           stbtt_GetFontVMetrics()\n//           stbtt_GetFontVMetricsOS2()\n//           stbtt_GetCodepointKernAdvance()\n//\n//   Starting with version 1.06, the rasterizer was replaced with a new,\n//   faster and generally-more-precise rasterizer. The new rasterizer more\n//   accurately measures pixel coverage for anti-aliasing, except in the case\n//   where multiple shapes overlap, in which case it overestimates the AA pixel\n//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If\n//   this turns out to be a problem, you can re-enable the old rasterizer with\n//        #define STBTT_RASTERIZER_VERSION 1\n//   which will incur about a 15% speed hit.\n//\n// ADDITIONAL DOCUMENTATION\n//\n//   Immediately after this block comment are a series of sample programs.\n//\n//   After the sample programs is the \"header file\" section. This section\n//   includes documentation for each API function.\n//\n//   Some important concepts to understand to use this library:\n//\n//      Codepoint\n//         Characters are defined by unicode codepoints, e.g. 65 is\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\n//         the hiragana for \"ma\".\n//\n//      Glyph\n//         A visual character shape (every codepoint is rendered as\n//         some glyph)\n//\n//      Glyph index\n//         A font-specific integer ID representing a glyph\n//\n//      Baseline\n//         Glyph shapes are defined relative to a baseline, which is the\n//         bottom of uppercase characters. Characters extend both above\n//         and below the baseline.\n//\n//      Current Point\n//         As you draw text to the screen, you keep track of a \"current point\"\n//         which is the origin of each character. The current point's vertical\n//         position is the baseline. Even \"baked fonts\" use this model.\n//\n//      Vertical Font Metrics\n//         The vertical qualities of the font, used to vertically position\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\n//\n//      Font Size in Pixels or Points\n//         The preferred interface for specifying font sizes in stb_truetype\n//         is to specify how tall the font's vertical extent should be in pixels.\n//         If that sounds good enough, skip the next paragraph.\n//\n//         Most font APIs instead use \"points\", which are a common typographic\n//         measurement for describing font size, defined as 72 points per inch.\n//         stb_truetype provides a point API for compatibility. However, true\n//         \"per inch\" conventions don't make much sense on computer displays\n//         since different monitors have different number of pixels per\n//         inch. For example, Windows traditionally uses a convention that\n//         there are 96 pixels per inch, thus making 'inch' measurements have\n//         nothing to do with inches, and thus effectively defining a point to\n//         be 1.333 pixels. Additionally, the TrueType font data provides\n//         an explicit scale factor to scale a given font's glyphs to points,\n//         but the author has observed that this scale factor is often wrong\n//         for non-commercial fonts, thus making fonts scaled in points\n//         according to the TrueType spec incoherently sized in practice.\n//\n// DETAILED USAGE:\n//\n//  Scale:\n//    Select how high you want the font to be, in points or pixels.\n//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute\n//    a scale factor SF that will be used by all other functions.\n//\n//  Baseline:\n//    You need to select a y-coordinate that is the baseline of where\n//    your text will appear. Call GetFontBoundingBox to get the baseline-relative\n//    bounding box for all characters. SF*-y0 will be the distance in pixels\n//    that the worst-case character could extend above the baseline, so if\n//    you want the top edge of characters to appear at the top of the\n//    screen where y=0, then you would set the baseline to SF*-y0.\n//\n//  Current point:\n//    Set the current point where the first character will appear. The\n//    first character could extend left of the current point; this is font\n//    dependent. You can either choose a current point that is the leftmost\n//    point and hope, or add some padding, or check the bounding box or\n//    left-side-bearing of the first character to be displayed and set\n//    the current point based on that.\n//\n//  Displaying a character:\n//    Compute the bounding box of the character. It will contain signed values\n//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,\n//    then the character should be displayed in the rectangle from\n//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).\n//\n//  Advancing for the next character:\n//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.\n//\n//\n// ADVANCED USAGE\n//\n//   Quality:\n//\n//    - Use the functions with Subpixel at the end to allow your characters\n//      to have subpixel positioning. Since the font is anti-aliased, not\n//      hinted, this is very import for quality. (This is not possible with\n//      baked fonts.)\n//\n//    - Kerning is now supported, and if you're supporting subpixel rendering\n//      then kerning is worth using to give your text a polished look.\n//\n//   Performance:\n//\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\n//      if you don't do this, stb_truetype is forced to do the conversion on\n//      every call.\n//\n//    - There are a lot of memory allocations. We should modify it to take\n//      a temp buffer and allocate from the temp buffer (without freeing),\n//      should help performance a lot.\n//\n// NOTES\n//\n//   The system uses the raw data found in the .ttf file without changing it\n//   and without building auxiliary data structures. This is a bit inefficient\n//   on little-endian systems (the data is big-endian), but assuming you're\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\n//\n//   It appears to be very hard to programmatically determine what font a\n//   given file is in a general way. I provide an API for this, but I don't\n//   recommend it.\n//\n//\n// PERFORMANCE MEASUREMENTS FOR 1.06:\n//\n//                      32-bit     64-bit\n//   Previous release:  8.83 s     7.68 s\n//   Pool allocations:  7.72 s     6.34 s\n//   Inline sort     :  6.54 s     5.65 s\n//   New rasterizer  :  5.63 s     5.00 s\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////  SAMPLE PROGRAMS\n////\n//\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.\n//  See \"tests/truetype_demo_win32.c\" for a complete version.\n#if 0\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\n#include \"stb_truetype.h\"\n\nunsigned char ttf_buffer[1<<20];\nunsigned char temp_bitmap[512*512];\n\nstbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs\nGLuint ftex;\n\nvoid my_stbtt_initfont(void)\n{\n   fread(ttf_buffer, 1, 1<<20, fopen(\"c:/windows/fonts/times.ttf\", \"rb\"));\n   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!\n   // can free ttf_buffer at this point\n   glGenTextures(1, &ftex);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);\n   // can free temp_bitmap at this point\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n}\n\nvoid my_stbtt_print(float x, float y, char *text)\n{\n   // assume orthographic projection with units = screen pixels, origin at top left\n   glEnable(GL_BLEND);\n   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n   glEnable(GL_TEXTURE_2D);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glBegin(GL_QUADS);\n   while (*text) {\n      if (*text >= 32 && *text < 128) {\n         stbtt_aligned_quad q;\n         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9\n         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);\n         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);\n         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);\n         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);\n      }\n      ++text;\n   }\n   glEnd();\n}\n#endif\n//\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program (this compiles): get a single bitmap, print as ASCII art\n//\n#if 0\n#include <stdio.h>\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\n#include \"stb_truetype.h\"\n\nchar ttf_buffer[1<<25];\n\nint main(int argc, char **argv)\n{\n   stbtt_fontinfo font;\n   unsigned char *bitmap;\n   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);\n\n   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n\n   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));\n   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);\n\n   for (j=0; j < h; ++j) {\n      for (i=0; i < w; ++i)\n         putchar(\" .:ioVM@\"[bitmap[j*w+i]>>5]);\n      putchar('\\n');\n   }\n   return 0;\n}\n#endif\n//\n// Output:\n//\n//     .ii.\n//    @@@@@@.\n//   V@Mio@@o\n//   :i.  V@V\n//     :oM@@M\n//   :@@@MM@M\n//   @@o  o@M\n//  :@@.  M@M\n//   @@@o@@@@\n//   :M@@V:@@.\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program: print \"Hello World!\" banner, with bugs\n//\n#if 0\nchar buffer[24<<20];\nunsigned char screen[20][79];\n\nint main(int arg, char **argv)\n{\n   stbtt_fontinfo font;\n   int i,j,ascent,baseline,ch=0;\n   float scale, xpos=2; // leave a little padding in case the character extends left\n   char *text = \"Heljo World!\"; // intentionally misspelled to show 'lj' brokenness\n\n   fread(buffer, 1, 1000000, fopen(\"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n   stbtt_InitFont(&font, buffer, 0);\n\n   scale = stbtt_ScaleForPixelHeight(&font, 15);\n   stbtt_GetFontVMetrics(&font, &ascent,0,0);\n   baseline = (int) (ascent*scale);\n\n   while (text[ch]) {\n      int advance,lsb,x0,y0,x1,y1;\n      float x_shift = xpos - (float) floor(xpos);\n      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);\n      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);\n      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);\n      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong\n      // because this API is really for baking character bitmaps into textures. if you want to render\n      // a sequence of characters, you really need to render each bitmap to a temp buffer, then\n      // \"alpha blend\" that into the working buffer\n      xpos += (advance * scale);\n      if (text[ch+1])\n         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);\n      ++ch;\n   }\n\n   for (j=0; j < 20; ++j) {\n      for (i=0; i < 78; ++i)\n         putchar(\" .:ioVM@\"[screen[j][i]>>5]);\n      putchar('\\n');\n   }\n\n   return 0;\n}\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////   INTEGRATION WITH YOUR CODEBASE\n////\n////   The following sections allow you to supply alternate definitions\n////   of C library functions used by stb_truetype, e.g. if you don't\n////   link with the C runtime library.\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n   // #define your own (u)stbtt_int8/16/32 before including to override this\n   #ifndef stbtt_uint8\n   typedef unsigned char   stbtt_uint8;\n   typedef signed   char   stbtt_int8;\n   typedef unsigned short  stbtt_uint16;\n   typedef signed   short  stbtt_int16;\n   typedef unsigned int    stbtt_uint32;\n   typedef signed   int    stbtt_int32;\n   #endif\n\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\n\n   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\n   #ifndef STBTT_ifloor\n   #include <math.h>\n   #define STBTT_ifloor(x)   ((int) floor(x))\n   #define STBTT_iceil(x)    ((int) ceil(x))\n   #endif\n\n   #ifndef STBTT_sqrt\n   #include <math.h>\n   #define STBTT_sqrt(x)      sqrt(x)\n   #define STBTT_pow(x,y)     pow(x,y)\n   #endif\n\n   #ifndef STBTT_fmod\n   #include <math.h>\n   #define STBTT_fmod(x,y)    fmod(x,y)\n   #endif\n\n   #ifndef STBTT_cos\n   #include <math.h>\n   #define STBTT_cos(x)       cos(x)\n   #define STBTT_acos(x)      acos(x)\n   #endif\n\n   #ifndef STBTT_fabs\n   #include <math.h>\n   #define STBTT_fabs(x)      fabs(x)\n   #endif\n\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\n   #ifndef STBTT_malloc\n   #include <stdlib.h>\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\n   #define STBTT_free(x,u)    ((void)(u),free(x))\n   #endif\n\n   #ifndef STBTT_assert\n   #include <assert.h>\n   #define STBTT_assert(x)    assert(x)\n   #endif\n\n   #ifndef STBTT_strlen\n   #include <string.h>\n   #define STBTT_strlen(x)    strlen(x)\n   #endif\n\n   #ifndef STBTT_memcpy\n   #include <string.h>\n   #define STBTT_memcpy       memcpy\n   #define STBTT_memset       memset\n   #endif\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   INTERFACE\n////\n////\n\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\n#define __STB_INCLUDE_STB_TRUETYPE_H__\n\n#ifdef STBTT_STATIC\n#define STBTT_DEF static\n#else\n#define STBTT_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// private structure\ntypedef struct\n{\n   unsigned char *data;\n   int cursor;\n   int size;\n} stbtt__buf;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// TEXTURE BAKING API\n//\n// If you use this API, you only have to call two functions ever.\n//\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n} stbtt_bakedchar;\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\n// if return is positive, the first unused row of the bitmap\n// if return is negative, returns the negative of the number of characters that fit\n// if return is 0, no characters fit and no rows were used\n// This uses a very crappy packing.\n\ntypedef struct\n{\n   float x0,y0,s0,t0; // top-left\n   float x1,y1,s1,t1; // bottom-right\n} stbtt_aligned_quad;\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\n// Call GetBakedQuad with char_index = 'character - first_char', and it\n// creates the quad you need to draw and advances the current position.\n//\n// The coordinate system used assumes y increases downwards.\n//\n// Characters will extend both above and below the current position;\n// see discussion of \"BASELINE\" above.\n//\n// It's inefficient; you might want to c&p it and optimize it.\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);\n// Query the font vertical metrics without having to create a font first.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// NEW TEXTURE BAKING API\n//\n// This provides options for packing multiple fonts into one atlas, not\n// perfectly but better than nothing.\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n   float xoff2,yoff2;\n} stbtt_packedchar;\n\ntypedef struct stbtt_pack_context stbtt_pack_context;\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\n#ifndef STB_RECT_PACK_VERSION\ntypedef struct stbrp_rect stbrp_rect;\n#endif\n\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\n// Initializes a packing context stored in the passed-in stbtt_pack_context.\n// Future calls using this context will pack characters into the bitmap passed\n// in here: a 1-channel bitmap that is width * height. stride_in_bytes is\n// the distance from one row to the next (or 0 to mean they are packed tightly\n// together). \"padding\" is the amount of padding to leave between each\n// character (normally you want '1' for bitmaps you'll use as textures with\n// bilinear filtering).\n//\n// Returns 0 on failure, 1 on success.\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\n// Cleans up the packing context and frees all memory.\n\n#define STBTT_POINT_SIZE(x)   (-(x))\n\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\n// Creates character bitmaps from the font_index'th font found in fontdata (use\n// font_index=0 if you don't know what that is). It creates num_chars_in_range\n// bitmaps for characters with unicode values starting at first_unicode_char_in_range\n// and increasing. Data for how to render them is stored in chardata_for_range;\n// pass these to stbtt_GetPackedQuad to get back renderable quads.\n//\n// font_size is the full height of the character from ascender to descender,\n// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed\n// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()\n// and pass that result as 'font_size':\n//       ...,                  20 , ... // font max minus min y is 20 pixels tall\n//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall\n\ntypedef struct\n{\n   float font_size;\n   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint\n   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints\n   int num_chars;\n   stbtt_packedchar *chardata_for_range; // output\n   unsigned char h_oversample, v_oversample; // don't set these, they're used internally\n} stbtt_pack_range;\n\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\n// Creates character bitmaps from multiple ranges of characters stored in\n// ranges. This will usually create a better-packed bitmap than multiple\n// calls to stbtt_PackFontRange. Note that you can call this multiple\n// times within a single PackBegin/PackEnd.\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\n// Oversampling a font increases the quality by allowing higher-quality subpixel\n// positioning, and is especially valuable at smaller text sizes.\n//\n// This function sets the amount of oversampling for all following calls to\n// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given\n// pack context. The default (no oversampling) is achieved by h_oversample=1\n// and v_oversample=1. The total number of pixels required is\n// h_oversample*v_oversample larger than the default; for example, 2x2\n// oversampling requires 4x the storage of 1x1. For best results, render\n// oversampled textures with bilinear filtering. Look at the readme in\n// stb/tests/oversample for information about oversampled fonts\n//\n// To use with PackFontRangesGather etc., you must set it before calls\n// call to PackFontRangesGatherRects.\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);\n// If skip != 0, this tells stb_truetype to skip any codepoints for which\n// there is no corresponding glyph. If skip=0, which is the default, then\n// codepoints without a glyph recived the font's \"missing character\" glyph,\n// typically an empty box by convention.\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int align_to_integer);\n\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\n// Calling these functions in sequence is roughly equivalent to calling\n// stbtt_PackFontRanges(). If you more control over the packing of multiple\n// fonts, or if you want to pack custom data into a font texture, take a look\n// at the source to of stbtt_PackFontRanges() and create a custom version\n// using these functions, e.g. call GatherRects multiple times,\n// building up a single array of rects, then call PackRects once,\n// then call RenderIntoRects repeatedly. This may result in a\n// better packing than calling PackFontRanges multiple times\n// (or it may not).\n\n// this is an opaque structure that you shouldn't mess with which holds\n// all the context needed from PackBegin to PackEnd.\nstruct stbtt_pack_context {\n   void *user_allocator_context;\n   void *pack_info;\n   int   width;\n   int   height;\n   int   stride_in_bytes;\n   int   padding;\n   int   skip_missing;\n   unsigned int   h_oversample, v_oversample;\n   unsigned char *pixels;\n   void  *nodes;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// FONT LOADING\n//\n//\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\n// This function will determine the number of fonts in a font file.  TrueType\n// collection (.ttc) files may contain multiple fonts, while TrueType font\n// (.ttf) files only contain one font. The number of fonts can be used for\n// indexing with the previous function where the index is between zero and one\n// less than the total fonts. If an error occurs, -1 is returned.\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\n// index number starting from 0. Call this function to get the font offset for\n// a given index; it returns -1 if the index is out of range. A regular .ttf\n// file will only define one font and it always be at offset 0, so it will\n// return '0' for index 0, and -1 for all other indices.\n\n// The following structure is defined publicly so you can declare one on\n// the stack or as a global or etc, but you should treat it as opaque.\nstruct stbtt_fontinfo\n{\n   void           * userdata;\n   unsigned char  * data;              // pointer to .ttf file\n   int              fontstart;         // offset of start of font\n\n   int numGlyphs;                     // number of glyphs, needed for range checking\n\n   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf\n   int index_map;                     // a cmap mapping for our chosen character encoding\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\n\n   stbtt__buf cff;                    // cff font data\n   stbtt__buf charstrings;            // the charstring index\n   stbtt__buf gsubrs;                 // global charstring subroutines index\n   stbtt__buf subrs;                  // private charstring subroutines index\n   stbtt__buf fontdicts;              // array of font dicts\n   stbtt__buf fdselect;               // map from glyph to fontdict\n};\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\n// Given an offset into the file that defines a font, this function builds\n// the necessary cached info for the rest of the system. You must allocate\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\n// need to do anything special to free it, because the contents are pure\n// value data with no additional data structures. Returns 0 on failure.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\n// If you're going to perform multiple operations on the same character\n// and you want a speed-up, call this function with the character you're\n// going to process, then use glyph-based functions instead of the\n// codepoint-based functions.\n// Returns 0 if the character codepoint is not defined in the font.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER PROPERTIES\n//\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\n// Height is measured as the distance from the highest ascender to the lowest\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\n// and computing:\n//       scale = pixels / (ascent - descent)\n// so if you prefer to measure height by the ascent only, use a similar calculation.\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose EM size is mapped to\n// 'pixels' tall. This is probably what traditional APIs compute, but\n// I'm not positive.\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\n// ascent is the coordinate above the baseline the font extends; descent\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\n// lineGap is the spacing between one row's descent and the next row's ascent...\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\n//   these are expressed in unscaled coordinates, so you must multiply by\n//   the scale factor for a given size\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\n// analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2\n// table (specific to MS/Windows TTF files).\n//\n// Returns 1 on success (table present), 0 on failure.\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\n// the bounding box around all possible characters\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\n//   these are expressed in unscaled coordinates\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\n// an additional amount to add to the 'advance' value between ch1 and ch2\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n// as above, but takes one or more glyph indices for greater efficiency\n\ntypedef struct stbtt_kerningentry\n{\n   int glyph1; // use stbtt_FindGlyphIndex\n   int glyph2;\n   int advance;\n} stbtt_kerningentry;\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);\nSTBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);\n// Retrieves a complete list of all of the kerning pairs provided by the font\n// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.\n// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// GLYPH SHAPES (you probably don't need these, but they have to go before\n// the bitmaps for C declaration-order reasons)\n//\n\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\n   enum {\n      STBTT_vmove=1,\n      STBTT_vline,\n      STBTT_vcurve,\n      STBTT_vcubic\n   };\n#endif\n\n#ifndef stbtt_vertex // you can predefine this to use different values\n                   // (we share this with other code at RAD)\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\n   typedef struct\n   {\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\n      unsigned char type,padding;\n   } stbtt_vertex;\n#endif\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\n// returns non-zero if nothing is drawn for this glyph\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\n// returns # of vertices and fills *vertices with the pointer to them\n//   these are expressed in \"unscaled\" coordinates\n//\n// The shape is a series of contours. Each one starts with\n// a STBTT_moveto, then consists of a series of mixed\n// STBTT_lineto and STBTT_curveto segments. A lineto\n// draws a line from previous endpoint to its x,y; a curveto\n// draws a quadratic bezier from previous endpoint to\n// its x,y, using cx,cy as the bezier control point.\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\n// frees the data allocated above\n\nSTBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);\n// fills svg with the character's SVG data.\n// returns data size or 0 if SVG not found.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BITMAP RENDERING\n//\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\n// frees the bitmap allocated below\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// allocates a large-enough single-channel 8bpp bitmap and renders the\n// specified character/glyph at the specified scale into it, with\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\n// *width & *height are filled out with the width & height of the bitmap,\n// which is stored left-to-right, top-to-bottom.\n//\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\n// width and height and positioning info for it first.\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\n// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering\n// is performed (see stbtt_PackSetOversampling)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// get the bbox of the bitmap centered around the glyph origin; so the\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\n// the bitmap top left is (leftSideBearing*scale,iy0).\n// (Note that the bitmap uses y-increases-down, but the shape uses\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\n// shift for the character\n\n// the following functions are equivalent to the above functions, but operate\n// on glyph indices instead of Unicode codepoints (for efficiency)\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n\n\n// @TODO: don't expose this structure\ntypedef struct\n{\n   int w,h,stride;\n   unsigned char *pixels;\n} stbtt__bitmap;\n\n// rasterize a shape with quadratic beziers into a bitmap\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into\n                               float flatness_in_pixels,     // allowable error of curve in pixels\n                               stbtt_vertex *vertices,       // array of vertices defining shape\n                               int num_verts,                // number of vertices in above array\n                               float scale_x, float scale_y, // scale applied to input vertices\n                               float shift_x, float shift_y, // translation applied to input vertices\n                               int x_off, int y_off,         // another translation applied to input\n                               int invert,                   // if non-zero, vertically flip shape\n                               void *userdata);              // context for to STBTT_MALLOC\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Signed Distance Function (or Field) rendering\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\n// frees the SDF bitmap allocated below\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\n// These functions compute a discretized SDF field for a single character, suitable for storing\n// in a single-channel texture, sampling with bilinear filtering, and testing against\n// larger than some threshold to produce scalable fonts.\n//        info              --  the font\n//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap\n//        glyph/codepoint   --  the character to generate the SDF for\n//        padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0),\n//                                 which allows effects like bit outlines\n//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)\n//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale)\n//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside\n//        width,height      --  output height & width of the SDF bitmap (including padding)\n//        xoff,yoff         --  output origin of the character\n//        return value      --  a 2D array of bytes 0..255, width*height in size\n//\n// pixel_dist_scale & onedge_value are a scale & bias that allows you to make\n// optimal use of the limited 0..255 for your application, trading off precision\n// and special effects. SDF values outside the range 0..255 are clamped to 0..255.\n//\n// Example:\n//      scale = stbtt_ScaleForPixelHeight(22)\n//      padding = 5\n//      onedge_value = 180\n//      pixel_dist_scale = 180/5.0 = 36.0\n//\n//      This will create an SDF bitmap in which the character is about 22 pixels\n//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled\n//      shape, sample the SDF at each pixel and fill the pixel if the SDF value\n//      is greater than or equal to 180/255. (You'll actually want to antialias,\n//      which is beyond the scope of this example.) Additionally, you can compute\n//      offset outlines (e.g. to stroke the character border inside & outside,\n//      or only outside). For example, to fill outside the character up to 3 SDF\n//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above\n//      choice of variables maps a range from 5 pixels outside the shape to\n//      2 pixels inside the shape to 0..255; this is intended primarily for apply\n//      outside effects only (the interior range is needed to allow proper\n//      antialiasing of the font at *smaller* sizes)\n//\n// The function computes the SDF analytically at each SDF pixel, not by e.g.\n// building a higher-res bitmap and approximating it. In theory the quality\n// should be as high as possible for an SDF of this size & representation, but\n// unclear if this is true in practice (perhaps building a higher-res bitmap\n// and computing from that can allow drop-out prevention).\n//\n// The algorithm has not been optimized at all, so expect it to be slow\n// if computing lots of characters or very large sizes.\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Finding the right font...\n//\n// You should really just solve this offline, keep your own tables\n// of what font is what, and don't try to get it out of the .ttf file.\n// That's because getting it out of the .ttf file is really hard, because\n// the names in the file can appear in many possible encodings, in many\n// possible languages, and e.g. if you need a case-insensitive comparison,\n// the details of that depend on the encoding & language in a complex way\n// (actually underspecified in truetype, but also gigantic).\n//\n// But you can use the provided functions in two possible ways:\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\n//             unicode-encoded names to try to find the font you want;\n//             you can run this before calling stbtt_InitFont()\n//\n//     stbtt_GetFontNameString() lets you get any of the various strings\n//             from the file yourself and do your own comparisons on them.\n//             You have to have called stbtt_InitFont() first.\n\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\n// returns the offset (not index) of the font that matches, or -1 if none\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\n//   if you use any other flag, use a font name like \"Arial\"; this checks\n//     the 'macStyle' header field; i don't know if fonts set this consistently\n#define STBTT_MACSTYLE_DONTCARE     0\n#define STBTT_MACSTYLE_BOLD         1\n#define STBTT_MACSTYLE_ITALIC       2\n#define STBTT_MACSTYLE_UNDERSCORE   4\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\n// returns 1/0 whether the first string interpreted as utf8 is identical to\n// the second string interpreted as big-endian utf16... useful for strings from next func\n\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\n// returns the string (which may be big-endian double byte, e.g. for unicode)\n// and puts the length in bytes in *length.\n//\n// some of the values for the IDs are below; for more see the truetype spec:\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\n//     http://www.microsoft.com/typography/otspec/name.htm\n\nenum { // platformID\n   STBTT_PLATFORM_ID_UNICODE   =0,\n   STBTT_PLATFORM_ID_MAC       =1,\n   STBTT_PLATFORM_ID_ISO       =2,\n   STBTT_PLATFORM_ID_MICROSOFT =3\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\n   STBTT_UNICODE_EID_ISO_10646      =2,\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\n   STBTT_MS_EID_SYMBOL        =0,\n   STBTT_MS_EID_UNICODE_BMP   =1,\n   STBTT_MS_EID_SHIFTJIS      =2,\n   STBTT_MS_EID_UNICODE_FULL  =10\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MAC\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   IMPLEMENTATION\n////\n////\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n\n#ifndef STBTT_MAX_OVERSAMPLE\n#define STBTT_MAX_OVERSAMPLE   8\n#endif\n\n#if STBTT_MAX_OVERSAMPLE > 255\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\n#endif\n\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\n\n#ifndef STBTT_RASTERIZER_VERSION\n#define STBTT_RASTERIZER_VERSION 2\n#endif\n\n#ifdef _MSC_VER\n#define STBTT__NOTUSED(v)  (void)(v)\n#else\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n//////////////////////////////////////////////////////////////////////////\n//\n// stbtt__buf helpers to parse data from file\n//\n\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}\n\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}\n\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\n{\n   STBTT_assert(!(o > b->size || o < 0));\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\n}\n\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}\n\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}\n\nstatic stbtt__buf stbtt__new_buf(const void *p, size_t size)\n{\n   stbtt__buf r;\n   STBTT_assert(size < 0x40000000);\n   r.data = (stbtt_uint8*) p;\n   r.size = (int) size;\n   r.cursor = 0;\n   return r;\n}\n\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\n\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}\n\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\n{\n   int count, start, offsize;\n   start = b->cursor;\n   count = stbtt__buf_get16(b);\n   if (count) {\n      offsize = stbtt__buf_get8(b);\n      STBTT_assert(offsize >= 1 && offsize <= 4);\n      stbtt__buf_skip(b, offsize * count);\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\n   }\n   return stbtt__buf_range(b, start, b->cursor - start);\n}\n\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\n{\n   int b0 = stbtt__buf_get8(b);\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\n   else if (b0 == 28)               return stbtt__buf_get16(b);\n   else if (b0 == 29)               return stbtt__buf_get32(b);\n   STBTT_assert(0);\n   return 0;\n}\n\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\n   int v, b0 = stbtt__buf_peek8(b);\n   STBTT_assert(b0 >= 28);\n   if (b0 == 30) {\n      stbtt__buf_skip(b, 1);\n      while (b->cursor < b->size) {\n         v = stbtt__buf_get8(b);\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\n            break;\n      }\n   } else {\n      stbtt__cff_int(b);\n   }\n}\n\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\n{\n   stbtt__buf_seek(b, 0);\n   while (b->cursor < b->size) {\n      int start = b->cursor, end, op;\n      while (stbtt__buf_peek8(b) >= 28)\n         stbtt__cff_skip_operand(b);\n      end = b->cursor;\n      op = stbtt__buf_get8(b);\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\n      if (op == key) return stbtt__buf_range(b, start, end-start);\n   }\n   return stbtt__buf_range(b, 0, 0);\n}\n\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\n{\n   int i;\n   stbtt__buf operands = stbtt__dict_get(b, key);\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\n      out[i] = stbtt__cff_int(&operands);\n}\n\nstatic int stbtt__cff_index_count(stbtt__buf *b)\n{\n   stbtt__buf_seek(b, 0);\n   return stbtt__buf_get16(b);\n}\n\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\n{\n   int count, offsize, start, end;\n   stbtt__buf_seek(&b, 0);\n   count = stbtt__buf_get16(&b);\n   offsize = stbtt__buf_get8(&b);\n   STBTT_assert(i >= 0 && i < count);\n   STBTT_assert(offsize >= 1 && offsize <= 4);\n   stbtt__buf_skip(&b, i*offsize);\n   start = stbtt__buf_get(&b, offsize);\n   end = stbtt__buf_get(&b, offsize);\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\n}\n\n//////////////////////////////////////////////////////////////////////////\n//\n// accessors to parse data from file\n//\n\n// on platforms that don't allow misaligned reads, if we want to allow\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\n\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\n#define ttFixed(p)    ttLONG(p)\n\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\n\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\n\nstatic int stbtt__isfont(stbtt_uint8 *font)\n{\n   // check the version number\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\n   if (stbtt_tag(font, \"true\"))   return 1; // Apple specification for TrueType fonts\n   return 0;\n}\n\n// @OPTIMIZE: binary search\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\n{\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\n   stbtt_uint32 tabledir = fontstart + 12;\n   stbtt_int32 i;\n   for (i=0; i < num_tables; ++i) {\n      stbtt_uint32 loc = tabledir + 16*i;\n      if (stbtt_tag(data+loc+0, tag))\n         return ttULONG(data+loc+8);\n   }\n   return 0;\n}\n\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\n{\n   // if it's just a font, there's only one valid index\n   if (stbtt__isfont(font_collection))\n      return index == 0 ? 0 : -1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         stbtt_int32 n = ttLONG(font_collection+8);\n         if (index >= n)\n            return -1;\n         return ttULONG(font_collection+12+index*4);\n      }\n   }\n   return -1;\n}\n\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\n{\n   // if it's just a font, there's only one valid font\n   if (stbtt__isfont(font_collection))\n      return 1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         return ttLONG(font_collection+8);\n      }\n   }\n   return 0;\n}\n\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\n{\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\n   stbtt__buf pdict;\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\n   if (!subrsoff) return stbtt__new_buf(NULL, 0);\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\n   return stbtt__cff_get_index(&cff);\n}\n\n// since most people won't use this, find this table the first time it's needed\nstatic int stbtt__get_svg(stbtt_fontinfo *info)\n{\n   stbtt_uint32 t;\n   if (info->svg < 0) {\n      t = stbtt__find_table(info->data, info->fontstart, \"SVG \");\n      if (t) {\n         stbtt_uint32 offset = ttULONG(info->data + t + 2);\n         info->svg = t + offset;\n      } else {\n         info->svg = 0;\n      }\n   }\n   return info->svg;\n}\n\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\n{\n   stbtt_uint32 cmap, t;\n   stbtt_int32 i,numTables;\n\n   info->data = data;\n   info->fontstart = fontstart;\n   info->cff = stbtt__new_buf(NULL, 0);\n\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\n   info->gpos = stbtt__find_table(data, fontstart, \"GPOS\"); // not required\n\n   if (!cmap || !info->head || !info->hhea || !info->hmtx)\n      return 0;\n   if (info->glyf) {\n      // required for truetype\n      if (!info->loca) return 0;\n   } else {\n      // initialization for CFF / Type2 fonts (OTF)\n      stbtt__buf b, topdict, topdictidx;\n      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;\n      stbtt_uint32 cff;\n\n      cff = stbtt__find_table(data, fontstart, \"CFF \");\n      if (!cff) return 0;\n\n      info->fontdicts = stbtt__new_buf(NULL, 0);\n      info->fdselect = stbtt__new_buf(NULL, 0);\n\n      // @TODO this should use size from table (not 512MB)\n      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);\n      b = info->cff;\n\n      // read the header\n      stbtt__buf_skip(&b, 2);\n      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize\n\n      // @TODO the name INDEX could list multiple fonts,\n      // but we just use the first one.\n      stbtt__cff_get_index(&b);  // name INDEX\n      topdictidx = stbtt__cff_get_index(&b);\n      topdict = stbtt__cff_index_get(topdictidx, 0);\n      stbtt__cff_get_index(&b);  // string INDEX\n      info->gsubrs = stbtt__cff_get_index(&b);\n\n      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);\n      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);\n      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);\n      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);\n      info->subrs = stbtt__get_subrs(b, topdict);\n\n      // we only support Type 2 charstrings\n      if (cstype != 2) return 0;\n      if (charstrings == 0) return 0;\n\n      if (fdarrayoff) {\n         // looks like a CID font\n         if (!fdselectoff) return 0;\n         stbtt__buf_seek(&b, fdarrayoff);\n         info->fontdicts = stbtt__cff_get_index(&b);\n         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);\n      }\n\n      stbtt__buf_seek(&b, charstrings);\n      info->charstrings = stbtt__cff_get_index(&b);\n   }\n\n   t = stbtt__find_table(data, fontstart, \"maxp\");\n   if (t)\n      info->numGlyphs = ttUSHORT(data+t+4);\n   else\n      info->numGlyphs = 0xffff;\n\n   info->svg = -1;\n\n   // find a cmap encoding table we understand *now* to avoid searching\n   // later. (todo: could make this installable)\n   // the same regardless of glyph.\n   numTables = ttUSHORT(data + cmap + 2);\n   info->index_map = 0;\n   for (i=0; i < numTables; ++i) {\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\n      // find an encoding we understand:\n      switch(ttUSHORT(data+encoding_record)) {\n         case STBTT_PLATFORM_ID_MICROSOFT:\n            switch (ttUSHORT(data+encoding_record+2)) {\n               case STBTT_MS_EID_UNICODE_BMP:\n               case STBTT_MS_EID_UNICODE_FULL:\n                  // MS/Unicode\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\n                  break;\n            }\n            break;\n        case STBTT_PLATFORM_ID_UNICODE:\n            // Mac/iOS has these\n            // all the encodingIDs are unicode, so we don't bother to check it\n            info->index_map = cmap + ttULONG(data+encoding_record+4);\n            break;\n      }\n   }\n   if (info->index_map == 0)\n      return 0;\n\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\n   return 1;\n}\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint32 index_map = info->index_map;\n\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\n   if (format == 0) { // apple byte encoding\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\n      if (unicode_codepoint < bytes-6)\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\n      return 0;\n   } else if (format == 6) {\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\n      return 0;\n   } else if (format == 2) {\n      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean\n      return 0;\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\n\n      // do a binary search of the segments\n      stbtt_uint32 endCount = index_map + 14;\n      stbtt_uint32 search = endCount;\n\n      if (unicode_codepoint > 0xffff)\n         return 0;\n\n      // they lie from endCount .. endCount + segCount\n      // but searchRange is the nearest power of two, so...\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\n         search += rangeShift*2;\n\n      // now decrement to bias correctly to find smallest\n      search -= 2;\n      while (entrySelector) {\n         stbtt_uint16 end;\n         searchRange >>= 1;\n         end = ttUSHORT(data + search + searchRange*2);\n         if (unicode_codepoint > end)\n            search += searchRange*2;\n         --entrySelector;\n      }\n      search += 2;\n\n      {\n         stbtt_uint16 offset, start, last;\n         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);\n\n         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\n         last = ttUSHORT(data + endCount + 2*item);\n         if (unicode_codepoint < start || unicode_codepoint > last)\n            return 0;\n\n         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\n         if (offset == 0)\n            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\n\n         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\n      }\n   } else if (format == 12 || format == 13) {\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\n      stbtt_int32 low,high;\n      low = 0; high = (stbtt_int32)ngroups;\n      // Binary search the right group.\n      while (low < high) {\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\n         if ((stbtt_uint32) unicode_codepoint < start_char)\n            high = mid;\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\n            low = mid+1;\n         else {\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\n            if (format == 12)\n               return start_glyph + unicode_codepoint-start_char;\n            else // format == 13\n               return start_glyph;\n         }\n      }\n      return 0; // not found\n   }\n   // @TODO\n   STBTT_assert(0);\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}\n\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}\n\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\n{\n   int g1,g2;\n\n   STBTT_assert(!info->cff.size);\n\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\n\n   if (info->indexToLocFormat == 0) {\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\n   } else {\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\n   }\n\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n\nSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   if (info->cff.size) {\n      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);\n   } else {\n      int g = stbtt__GetGlyfOffset(info, glyph_index);\n      if (g < 0) return 0;\n\n      if (x0) *x0 = ttSHORT(info->data + g + 2);\n      if (y0) *y0 = ttSHORT(info->data + g + 4);\n      if (x1) *x1 = ttSHORT(info->data + g + 6);\n      if (y1) *y1 = ttSHORT(info->data + g + 8);\n   }\n   return 1;\n}\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt_int16 numberOfContours;\n   int g;\n   if (info->cff.size)\n      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;\n   g = stbtt__GetGlyfOffset(info, glyph_index);\n   if (g < 0) return 1;\n   numberOfContours = ttSHORT(info->data + g);\n   return numberOfContours == 0;\n}\n\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\n{\n   if (start_off) {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\n   } else {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\n      else\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\n   }\n   return num_vertices;\n}\n\nstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   stbtt_int16 numberOfContours;\n   stbtt_uint8 *endPtsOfContours;\n   stbtt_uint8 *data = info->data;\n   stbtt_vertex *vertices=0;\n   int num_vertices=0;\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\n\n   *pvertices = NULL;\n\n   if (g < 0) return 0;\n\n   numberOfContours = ttSHORT(data + g);\n\n   if (numberOfContours > 0) {\n      stbtt_uint8 flags=0,flagcount;\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\n      stbtt_uint8 *points;\n      endPtsOfContours = (data + g + 10);\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\n\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\n\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\n      if (vertices == 0)\n         return 0;\n\n      next_move = 0;\n      flagcount=0;\n\n      // in first pass, we load uninterpreted data into the allocated array\n      // above, shifted to the end of the array so we won't overwrite it when\n      // we create our final data starting from the front\n\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\n\n      // first load flags\n\n      for (i=0; i < n; ++i) {\n         if (flagcount == 0) {\n            flags = *points++;\n            if (flags & 8)\n               flagcount = *points++;\n         } else\n            --flagcount;\n         vertices[off+i].type = flags;\n      }\n\n      // now load x coordinates\n      x=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 2) {\n            stbtt_int16 dx = *points++;\n            x += (flags & 16) ? dx : -dx; // ???\n         } else {\n            if (!(flags & 16)) {\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].x = (stbtt_int16) x;\n      }\n\n      // now load y coordinates\n      y=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 4) {\n            stbtt_int16 dy = *points++;\n            y += (flags & 32) ? dy : -dy; // ???\n         } else {\n            if (!(flags & 32)) {\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].y = (stbtt_int16) y;\n      }\n\n      // now convert them to our format\n      num_vertices=0;\n      sx = sy = cx = cy = scx = scy = 0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         x     = (stbtt_int16) vertices[off+i].x;\n         y     = (stbtt_int16) vertices[off+i].y;\n\n         if (next_move == i) {\n            if (i != 0)\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n\n            // now start the new one\n            start_off = !(flags & 1);\n            if (start_off) {\n               // if we start off with an off-curve point, then when we need to find a point on the curve\n               // where we can start, and we need to save some state for when we wraparound.\n               scx = x;\n               scy = y;\n               if (!(vertices[off+i+1].type & 1)) {\n                  // next point is also a curve point, so interpolate an on-point curve\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n               } else {\n                  // otherwise just use the next point as our start point\n                  sx = (stbtt_int32) vertices[off+i+1].x;\n                  sy = (stbtt_int32) vertices[off+i+1].y;\n                  ++i; // we're using point i+1 as the starting point, so skip it\n               }\n            } else {\n               sx = x;\n               sy = y;\n            }\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\n            was_off = 0;\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\n            ++j;\n         } else {\n            if (!(flags & 1)) { // if it's a curve\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n               cx = x;\n               cy = y;\n               was_off = 1;\n            } else {\n               if (was_off)\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\n               else\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\n               was_off = 0;\n            }\n         }\n      }\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n   } else if (numberOfContours < 0) {\n      // Compound shapes.\n      int more = 1;\n      stbtt_uint8 *comp = data + g + 10;\n      num_vertices = 0;\n      vertices = 0;\n      while (more) {\n         stbtt_uint16 flags, gidx;\n         int comp_num_verts = 0, i;\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\n\n         flags = ttSHORT(comp); comp+=2;\n         gidx = ttSHORT(comp); comp+=2;\n\n         if (flags & 2) { // XY values\n            if (flags & 1) { // shorts\n               mtx[4] = ttSHORT(comp); comp+=2;\n               mtx[5] = ttSHORT(comp); comp+=2;\n            } else {\n               mtx[4] = ttCHAR(comp); comp+=1;\n               mtx[5] = ttCHAR(comp); comp+=1;\n            }\n         }\n         else {\n            // @TODO handle matching point\n            STBTT_assert(0);\n         }\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         }\n\n         // Find transformation scales.\n         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\n         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\n\n         // Get indexed glyph.\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\n         if (comp_num_verts > 0) {\n            // Transform vertices.\n            for (i = 0; i < comp_num_verts; ++i) {\n               stbtt_vertex* v = &comp_verts[i];\n               stbtt_vertex_type x,y;\n               x=v->x; y=v->y;\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n               x=v->cx; y=v->cy;\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n            }\n            // Append vertices.\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\n            if (!tmp) {\n               if (vertices) STBTT_free(vertices, info->userdata);\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\n               return 0;\n            }\n            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\n            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\n            if (vertices) STBTT_free(vertices, info->userdata);\n            vertices = tmp;\n            STBTT_free(comp_verts, info->userdata);\n            num_vertices += comp_num_verts;\n         }\n         // More components ?\n         more = flags & (1<<5);\n      }\n   } else {\n      // numberOfCounters == 0, do nothing\n   }\n\n   *pvertices = vertices;\n   return num_vertices;\n}\n\ntypedef struct\n{\n   int bounds;\n   int started;\n   float first_x, first_y;\n   float x, y;\n   stbtt_int32 min_x, max_x, min_y, max_y;\n\n   stbtt_vertex *pvertices;\n   int num_vertices;\n} stbtt__csctx;\n\n#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}\n\nstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)\n{\n   if (x > c->max_x || !c->started) c->max_x = x;\n   if (y > c->max_y || !c->started) c->max_y = y;\n   if (x < c->min_x || !c->started) c->min_x = x;\n   if (y < c->min_y || !c->started) c->min_y = y;\n   c->started = 1;\n}\n\nstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)\n{\n   if (c->bounds) {\n      stbtt__track_vertex(c, x, y);\n      if (type == STBTT_vcubic) {\n         stbtt__track_vertex(c, cx, cy);\n         stbtt__track_vertex(c, cx1, cy1);\n      }\n   } else {\n      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);\n      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;\n      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;\n   }\n   c->num_vertices++;\n}\n\nstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)\n{\n   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)\n      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)\n{\n   float cx1 = ctx->x + dx1;\n   float cy1 = ctx->y + dy1;\n   float cx2 = cx1 + dx2;\n   float cy2 = cy1 + dy2;\n   ctx->x = cx2 + dx3;\n   ctx->y = cy2 + dy3;\n   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);\n}\n\nstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)\n{\n   int count = stbtt__cff_index_count(&idx);\n   int bias = 107;\n   if (count >= 33900)\n      bias = 32768;\n   else if (count >= 1240)\n      bias = 1131;\n   n += bias;\n   if (n < 0 || n >= count)\n      return stbtt__new_buf(NULL, 0);\n   return stbtt__cff_index_get(idx, n);\n}\n\nstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt__buf fdselect = info->fdselect;\n   int nranges, start, end, v, fmt, fdselector = -1, i;\n\n   stbtt__buf_seek(&fdselect, 0);\n   fmt = stbtt__buf_get8(&fdselect);\n   if (fmt == 0) {\n      // untested\n      stbtt__buf_skip(&fdselect, glyph_index);\n      fdselector = stbtt__buf_get8(&fdselect);\n   } else if (fmt == 3) {\n      nranges = stbtt__buf_get16(&fdselect);\n      start = stbtt__buf_get16(&fdselect);\n      for (i = 0; i < nranges; i++) {\n         v = stbtt__buf_get8(&fdselect);\n         end = stbtt__buf_get16(&fdselect);\n         if (glyph_index >= start && glyph_index < end) {\n            fdselector = v;\n            break;\n         }\n         start = end;\n      }\n   }\n   if (fdselector == -1) stbtt__new_buf(NULL, 0);\n   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));\n}\n\nstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)\n{\n   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;\n   int has_subrs = 0, clear_stack;\n   float s[48];\n   stbtt__buf subr_stack[10], subrs = info->subrs, b;\n   float f;\n\n#define STBTT__CSERR(s) (0)\n\n   // this currently ignores the initial width value, which isn't needed if we have hmtx\n   b = stbtt__cff_index_get(info->charstrings, glyph_index);\n   while (b.cursor < b.size) {\n      i = 0;\n      clear_stack = 1;\n      b0 = stbtt__buf_get8(&b);\n      switch (b0) {\n      // @TODO implement hinting\n      case 0x13: // hintmask\n      case 0x14: // cntrmask\n         if (in_header)\n            maskbits += (sp / 2); // implicit \"vstem\"\n         in_header = 0;\n         stbtt__buf_skip(&b, (maskbits + 7) / 8);\n         break;\n\n      case 0x01: // hstem\n      case 0x03: // vstem\n      case 0x12: // hstemhm\n      case 0x17: // vstemhm\n         maskbits += (sp / 2);\n         break;\n\n      case 0x15: // rmoveto\n         in_header = 0;\n         if (sp < 2) return STBTT__CSERR(\"rmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);\n         break;\n      case 0x04: // vmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"vmoveto stack\");\n         stbtt__csctx_rmove_to(c, 0, s[sp-1]);\n         break;\n      case 0x16: // hmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"hmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-1], 0);\n         break;\n\n      case 0x05: // rlineto\n         if (sp < 2) return STBTT__CSERR(\"rlineto stack\");\n         for (; i + 1 < sp; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical\n      // starting from a different place.\n\n      case 0x07: // vlineto\n         if (sp < 1) return STBTT__CSERR(\"vlineto stack\");\n         goto vlineto;\n      case 0x06: // hlineto\n         if (sp < 1) return STBTT__CSERR(\"hlineto stack\");\n         for (;;) {\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, s[i], 0);\n            i++;\n      vlineto:\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, 0, s[i]);\n            i++;\n         }\n         break;\n\n      case 0x1F: // hvcurveto\n         if (sp < 4) return STBTT__CSERR(\"hvcurveto stack\");\n         goto hvcurveto;\n      case 0x1E: // vhcurveto\n         if (sp < 4) return STBTT__CSERR(\"vhcurveto stack\");\n         for (;;) {\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);\n            i += 4;\n      hvcurveto:\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);\n            i += 4;\n         }\n         break;\n\n      case 0x08: // rrcurveto\n         if (sp < 6) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x18: // rcurveline\n         if (sp < 8) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp - 2; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         if (i + 1 >= sp) return STBTT__CSERR(\"rcurveline stack\");\n         stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      case 0x19: // rlinecurve\n         if (sp < 8) return STBTT__CSERR(\"rlinecurve stack\");\n         for (; i + 1 < sp - 6; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         if (i + 5 >= sp) return STBTT__CSERR(\"rlinecurve stack\");\n         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x1A: // vvcurveto\n      case 0x1B: // hhcurveto\n         if (sp < 4) return STBTT__CSERR(\"(vv|hh)curveto stack\");\n         f = 0.0;\n         if (sp & 1) { f = s[i]; i++; }\n         for (; i + 3 < sp; i += 4) {\n            if (b0 == 0x1B)\n               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);\n            else\n               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);\n            f = 0.0;\n         }\n         break;\n\n      case 0x0A: // callsubr\n         if (!has_subrs) {\n            if (info->fdselect.size)\n               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);\n            has_subrs = 1;\n         }\n         // FALLTHROUGH\n      case 0x1D: // callgsubr\n         if (sp < 1) return STBTT__CSERR(\"call(g|)subr stack\");\n         v = (int) s[--sp];\n         if (subr_stack_height >= 10) return STBTT__CSERR(\"recursion limit\");\n         subr_stack[subr_stack_height++] = b;\n         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);\n         if (b.size == 0) return STBTT__CSERR(\"subr not found\");\n         b.cursor = 0;\n         clear_stack = 0;\n         break;\n\n      case 0x0B: // return\n         if (subr_stack_height <= 0) return STBTT__CSERR(\"return outside subr\");\n         b = subr_stack[--subr_stack_height];\n         clear_stack = 0;\n         break;\n\n      case 0x0E: // endchar\n         stbtt__csctx_close_shape(c);\n         return 1;\n\n      case 0x0C: { // two-byte escape\n         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;\n         float dx, dy;\n         int b1 = stbtt__buf_get8(&b);\n         switch (b1) {\n         // @TODO These \"flex\" implementations ignore the flex-depth and resolution,\n         // and always draw beziers.\n         case 0x22: // hflex\n            if (sp < 7) return STBTT__CSERR(\"hflex stack\");\n            dx1 = s[0];\n            dx2 = s[1];\n            dy2 = s[2];\n            dx3 = s[3];\n            dx4 = s[4];\n            dx5 = s[5];\n            dx6 = s[6];\n            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);\n            break;\n\n         case 0x23: // flex\n            if (sp < 13) return STBTT__CSERR(\"flex stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = s[10];\n            dy6 = s[11];\n            //fd is s[12]\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         case 0x24: // hflex1\n            if (sp < 9) return STBTT__CSERR(\"hflex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dx4 = s[5];\n            dx5 = s[6];\n            dy5 = s[7];\n            dx6 = s[8];\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));\n            break;\n\n         case 0x25: // flex1\n            if (sp < 11) return STBTT__CSERR(\"flex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = dy6 = s[10];\n            dx = dx1+dx2+dx3+dx4+dx5;\n            dy = dy1+dy2+dy3+dy4+dy5;\n            if (STBTT_fabs(dx) > STBTT_fabs(dy))\n               dy6 = -dy;\n            else\n               dx6 = -dx;\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         default:\n            return STBTT__CSERR(\"unimplemented\");\n         }\n      } break;\n\n      default:\n         if (b0 != 255 && b0 != 28 && b0 < 32)\n            return STBTT__CSERR(\"reserved operator\");\n\n         // push immediate\n         if (b0 == 255) {\n            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;\n         } else {\n            stbtt__buf_skip(&b, -1);\n            f = (float)(stbtt_int16)stbtt__cff_int(&b);\n         }\n         if (sp >= 48) return STBTT__CSERR(\"push stack overflow\");\n         s[sp++] = f;\n         clear_stack = 0;\n         break;\n      }\n      if (clear_stack) sp = 0;\n   }\n   return STBTT__CSERR(\"no endchar\");\n\n#undef STBTT__CSERR\n}\n\nstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   // runs the charstring twice, once to count and once to output (to avoid realloc)\n   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);\n   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);\n   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {\n      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);\n      output_ctx.pvertices = *pvertices;\n      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {\n         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);\n         return output_ctx.num_vertices;\n      }\n   }\n   *pvertices = NULL;\n   return 0;\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   stbtt__csctx c = STBTT__CSCTX_INIT(1);\n   int r = stbtt__run_charstring(info, glyph_index, &c);\n   if (x0)  *x0 = r ? c.min_x : 0;\n   if (y0)  *y0 = r ? c.min_y : 0;\n   if (x1)  *x1 = r ? c.max_x : 0;\n   if (y1)  *y1 = r ? c.max_y : 0;\n   return r ? c.num_vertices : 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   if (!info->cff.size)\n      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);\n   else\n      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);\n}\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\n   if (glyph_index < numOfLongHorMetrics) {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\n   } else {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\n   }\n}\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   return ttUSHORT(data+10);\n}\n\nSTBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   int k, length;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   length = ttUSHORT(data+10);\n   if (table_length < length)\n      length = table_length;\n\n   for (k = 0; k < length; k++)\n   {\n      table[k].glyph1 = ttUSHORT(data+18+(k*6));\n      table[k].glyph2 = ttUSHORT(data+20+(k*6));\n      table[k].advance = ttSHORT(data+22+(k*6));\n   }\n\n   return length;\n}\n\nstatic int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   stbtt_uint32 needle, straw;\n   int l, r, m;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   l = 0;\n   r = ttUSHORT(data+10) - 1;\n   needle = glyph1 << 16 | glyph2;\n   while (l <= r) {\n      m = (l + r) >> 1;\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\n      if (needle < straw)\n         r = m - 1;\n      else if (needle > straw)\n         l = m + 1;\n      else\n         return ttSHORT(data+22+(m*6));\n   }\n   return 0;\n}\n\nstatic stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)\n{\n   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);\n   switch (coverageFormat) {\n      case 1: {\n         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);\n\n         // Binary search.\n         stbtt_int32 l=0, r=glyphCount-1, m;\n         int straw, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *glyphArray = coverageTable + 4;\n            stbtt_uint16 glyphID;\n            m = (l + r) >> 1;\n            glyphID = ttUSHORT(glyphArray + 2 * m);\n            straw = glyphID;\n            if (needle < straw)\n               r = m - 1;\n            else if (needle > straw)\n               l = m + 1;\n            else {\n               return m;\n            }\n         }\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);\n         stbtt_uint8 *rangeArray = coverageTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=rangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *rangeRecord;\n            m = (l + r) >> 1;\n            rangeRecord = rangeArray + 6 * m;\n            strawStart = ttUSHORT(rangeRecord);\n            strawEnd = ttUSHORT(rangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else {\n               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);\n               return startCoverageIndex + glyph - strawStart;\n            }\n         }\n         break;\n      }\n\n      default: return -1; // unsupported\n   }\n\n   return -1;\n}\n\nstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)\n{\n   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);\n   switch (classDefFormat)\n   {\n      case 1: {\n         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);\n         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);\n         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;\n\n         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)\n            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);\n         stbtt_uint8 *classRangeRecords = classDefTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=classRangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *classRangeRecord;\n            m = (l + r) >> 1;\n            classRangeRecord = classRangeRecords + 6 * m;\n            strawStart = ttUSHORT(classRangeRecord);\n            strawEnd = ttUSHORT(classRangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else\n               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);\n         }\n         break;\n      }\n\n      default:\n         return -1; // Unsupported definition type, return an error.\n   }\n\n   // \"All glyphs not assigned to a class fall into class 0\". (OpenType spec)\n   return 0;\n}\n\n// Define to STBTT_assert(x) if you want to break on unimplemented formats.\n#define STBTT_GPOS_TODO_assert(x)\n\nstatic stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint16 lookupListOffset;\n   stbtt_uint8 *lookupList;\n   stbtt_uint16 lookupCount;\n   stbtt_uint8 *data;\n   stbtt_int32 i, sti;\n\n   if (!info->gpos) return 0;\n\n   data = info->data + info->gpos;\n\n   if (ttUSHORT(data+0) != 1) return 0; // Major version 1\n   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0\n\n   lookupListOffset = ttUSHORT(data+8);\n   lookupList = data + lookupListOffset;\n   lookupCount = ttUSHORT(lookupList);\n\n   for (i=0; i<lookupCount; ++i) {\n      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);\n      stbtt_uint8 *lookupTable = lookupList + lookupOffset;\n\n      stbtt_uint16 lookupType = ttUSHORT(lookupTable);\n      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);\n      stbtt_uint8 *subTableOffsets = lookupTable + 6;\n      if (lookupType != 2) // Pair Adjustment Positioning Subtable\n         continue;\n\n      for (sti=0; sti<subTableCount; sti++) {\n         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);\n         stbtt_uint8 *table = lookupTable + subtableOffset;\n         stbtt_uint16 posFormat = ttUSHORT(table);\n         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);\n         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);\n         if (coverageIndex == -1) continue;\n\n         switch (posFormat) {\n            case 1: {\n               stbtt_int32 l, r, m;\n               int straw, needle;\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_int32 valueRecordPairSizeInBytes = 2;\n                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);\n                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);\n                  stbtt_uint8 *pairValueTable = table + pairPosOffset;\n                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);\n                  stbtt_uint8 *pairValueArray = pairValueTable + 2;\n\n                  if (coverageIndex >= pairSetCount) return 0;\n\n                  needle=glyph2;\n                  r=pairValueCount-1;\n                  l=0;\n\n                  // Binary search.\n                  while (l <= r) {\n                     stbtt_uint16 secondGlyph;\n                     stbtt_uint8 *pairValue;\n                     m = (l + r) >> 1;\n                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;\n                     secondGlyph = ttUSHORT(pairValue);\n                     straw = secondGlyph;\n                     if (needle < straw)\n                        r = m - 1;\n                     else if (needle > straw)\n                        l = m + 1;\n                     else {\n                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);\n                        return xAdvance;\n                     }\n                  }\n               } else\n                  return 0;\n               break;\n            }\n\n            case 2: {\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);\n                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);\n                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);\n                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);\n\n                  stbtt_uint16 class1Count = ttUSHORT(table + 12);\n                  stbtt_uint16 class2Count = ttUSHORT(table + 14);\n                  stbtt_uint8 *class1Records, *class2Records;\n                  stbtt_int16 xAdvance;\n\n                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed\n                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed\n\n                  class1Records = table + 16;\n                  class2Records = class1Records + 2 * (glyph1class * class2Count);\n                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);\n                  return xAdvance;\n               } else\n                  return 0;\n               break;\n            }\n\n            default:\n               return 0; // Unsupported position format\n         }\n      }\n   }\n\n   return 0;\n}\n\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\n{\n   *x0 = ttSHORT(info->data + info->head + 36);\n   *y0 = ttSHORT(info->data + info->head + 38);\n   *x1 = ttSHORT(info->data + info->head + 40);\n   *y1 = ttSHORT(info->data + info->head + 42);\n}\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\n{\n   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\n   return (float) height / fheight;\n}\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\n{\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\n   return pixels / unitsPerEm;\n}\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\n{\n   STBTT_free(v, info->userdata);\n}\n\nSTBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)\n{\n   int i;\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);\n\n   int numEntries = ttUSHORT(svg_doc_list);\n   stbtt_uint8 *svg_docs = svg_doc_list + 2;\n\n   for(i=0; i<numEntries; i++) {\n      stbtt_uint8 *svg_doc = svg_docs + (12 * i);\n      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))\n         return svg_doc;\n   }\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc;\n\n   if (info->svg == 0)\n      return 0;\n\n   svg_doc = stbtt_FindSVGDoc(info, gl);\n   if (svg_doc != NULL) {\n      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);\n      return ttULONG(svg_doc + 8);\n   } else {\n      return 0;\n   }\n}\n\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// antialiasing software rasterizer\n//\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {\n      // e.g. space character\n      if (ix0) *ix0 = 0;\n      if (iy0) *iy0 = 0;\n      if (ix1) *ix1 = 0;\n      if (iy1) *iy1 = 0;\n   } else {\n      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?\n      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);\n      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);\n      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);\n      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);\n   }\n}\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Rasterizer\n\ntypedef struct stbtt__hheap_chunk\n{\n   struct stbtt__hheap_chunk *next;\n} stbtt__hheap_chunk;\n\ntypedef struct stbtt__hheap\n{\n   struct stbtt__hheap_chunk *head;\n   void   *first_free;\n   int    num_remaining_in_head_chunk;\n} stbtt__hheap;\n\nstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)\n{\n   if (hh->first_free) {\n      void *p = hh->first_free;\n      hh->first_free = * (void **) p;\n      return p;\n   } else {\n      if (hh->num_remaining_in_head_chunk == 0) {\n         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);\n         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);\n         if (c == NULL)\n            return NULL;\n         c->next = hh->head;\n         hh->head = c;\n         hh->num_remaining_in_head_chunk = count;\n      }\n      --hh->num_remaining_in_head_chunk;\n      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;\n   }\n}\n\nstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)\n{\n   *(void **) p = hh->first_free;\n   hh->first_free = p;\n}\n\nstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}\n\ntypedef struct stbtt__edge {\n   float x0,y0, x1,y1;\n   int invert;\n} stbtt__edge;\n\n\ntypedef struct stbtt__active_edge\n{\n   struct stbtt__active_edge *next;\n   #if STBTT_RASTERIZER_VERSION==1\n   int x,dx;\n   float ey;\n   int direction;\n   #elif STBTT_RASTERIZER_VERSION==2\n   float fx,fdx,fdy;\n   float direction;\n   float sy;\n   float ey;\n   #else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n   #endif\n} stbtt__active_edge;\n\n#if STBTT_RASTERIZER_VERSION == 1\n#define STBTT_FIXSHIFT   10\n#define STBTT_FIX        (1 << STBTT_FIXSHIFT)\n#define STBTT_FIXMASK    (STBTT_FIX-1)\n\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != NULL);\n   if (!z) return z;\n\n   // round dx down to avoid overshooting\n   if (dxdy < 0)\n      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);\n   else\n      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);\n\n   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount\n   z->x -= off_x * STBTT_FIX;\n\n   z->ey = e->y1;\n   z->next = 0;\n   z->direction = e->invert ? 1 : -1;\n   return z;\n}\n#elif STBTT_RASTERIZER_VERSION == 2\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != NULL);\n   //STBTT_assert(e->y0 <= start_point);\n   if (!z) return z;\n   z->fdx = dxdy;\n   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;\n   z->fx = e->x0 + dxdy * (start_point - e->y0);\n   z->fx -= off_x;\n   z->direction = e->invert ? 1.0f : -1.0f;\n   z->sy = e->y0;\n   z->ey = e->y1;\n   z->next = 0;\n   return z;\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#if STBTT_RASTERIZER_VERSION == 1\n// note: this routine clips fills that extend off the edges... ideally this\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\n// are wrong, or if the user supplies a too-small bitmap\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\n{\n   // non-zero winding fill\n   int x0=0, w=0;\n\n   while (e) {\n      if (w == 0) {\n         // if we're currently at zero, we need to record the edge start point\n         x0 = e->x; w += e->direction;\n      } else {\n         int x1 = e->x; w += e->direction;\n         // if we went to zero, we need to draw\n         if (w == 0) {\n            int i = x0 >> STBTT_FIXSHIFT;\n            int j = x1 >> STBTT_FIXSHIFT;\n\n            if (i < len && j >= 0) {\n               if (i == j) {\n                  // x0,x1 are the same pixel, so compute combined coverage\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);\n               } else {\n                  if (i >= 0) // add antialiasing for x0\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     i = -1; // clip\n\n                  if (j < len) // add antialiasing for x1\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     j = len; // clip\n\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\n               }\n            }\n         }\n      }\n\n      e = e->next;\n   }\n}\n\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = NULL;\n   int y,j=0;\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\n   int s; // vertical subsample index\n   unsigned char scanline_data[512], *scanline;\n\n   if (result->w > 512)\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\n   else\n      scanline = scanline_data;\n\n   y = off_y * vsubsample;\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\n\n   while (j < result->h) {\n      STBTT_memset(scanline, 0, result->w);\n      for (s=0; s < vsubsample; ++s) {\n         // find center of pixel for this scanline\n         float scan_y = y + 0.5f;\n         stbtt__active_edge **step = &active;\n\n         // update all active edges;\n         // remove all active edges that terminate before the center of this scanline\n         while (*step) {\n            stbtt__active_edge * z = *step;\n            if (z->ey <= scan_y) {\n               *step = z->next; // delete from list\n               STBTT_assert(z->direction);\n               z->direction = 0;\n               stbtt__hheap_free(&hh, z);\n            } else {\n               z->x += z->dx; // advance to position for current scanline\n               step = &((*step)->next); // advance through list\n            }\n         }\n\n         // resort the list if needed\n         for(;;) {\n            int changed=0;\n            step = &active;\n            while (*step && (*step)->next) {\n               if ((*step)->x > (*step)->next->x) {\n                  stbtt__active_edge *t = *step;\n                  stbtt__active_edge *q = t->next;\n\n                  t->next = q->next;\n                  q->next = t;\n                  *step = q;\n                  changed = 1;\n               }\n               step = &(*step)->next;\n            }\n            if (!changed) break;\n         }\n\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\n         while (e->y0 <= scan_y) {\n            if (e->y1 > scan_y) {\n               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);\n               if (z != NULL) {\n                  // find insertion point\n                  if (active == NULL)\n                     active = z;\n                  else if (z->x < active->x) {\n                     // insert at front\n                     z->next = active;\n                     active = z;\n                  } else {\n                     // find thing to insert AFTER\n                     stbtt__active_edge *p = active;\n                     while (p->next && p->next->x < z->x)\n                        p = p->next;\n                     // at this point, p->next->x is NOT < z->x\n                     z->next = p->next;\n                     p->next = z;\n                  }\n               }\n            }\n            ++e;\n         }\n\n         // now process all active edges in XOR fashion\n         if (active)\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\n\n         ++y;\n      }\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n\n#elif STBTT_RASTERIZER_VERSION == 2\n\n// the edge passed in here does not cross the vertical line at x or the vertical line at x+1\n// (i.e. it has already been clipped to those)\nstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)\n{\n   if (y0 == y1) return;\n   STBTT_assert(y0 < y1);\n   STBTT_assert(e->sy <= e->ey);\n   if (y0 > e->ey) return;\n   if (y1 < e->sy) return;\n   if (y0 < e->sy) {\n      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);\n      y0 = e->sy;\n   }\n   if (y1 > e->ey) {\n      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);\n      y1 = e->ey;\n   }\n\n   if (x0 == x)\n      STBTT_assert(x1 <= x+1);\n   else if (x0 == x+1)\n      STBTT_assert(x1 >= x);\n   else if (x0 <= x)\n      STBTT_assert(x1 <= x);\n   else if (x0 >= x+1)\n      STBTT_assert(x1 >= x+1);\n   else\n      STBTT_assert(x1 >= x && x1 <= x+1);\n\n   if (x0 <= x && x1 <= x)\n      scanline[x] += e->direction * (y1-y0);\n   else if (x0 >= x+1 && x1 >= x+1)\n      ;\n   else {\n      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);\n      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position\n   }\n}\n\nstatic float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) / 2.0f * height;\n}\n\nstatic float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)\n{\n   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);\n}\n\nstatic float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width / 2;\n}\n\nstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)\n{\n   float y_bottom = y_top+1;\n\n   while (e) {\n      // brute force every pixel\n\n      // compute intersection points with top & bottom\n      STBTT_assert(e->ey >= y_top);\n\n      if (e->fdx == 0) {\n         float x0 = e->fx;\n         if (x0 < len) {\n            if (x0 >= 0) {\n               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);\n               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);\n            } else {\n               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);\n            }\n         }\n      } else {\n         float x0 = e->fx;\n         float dx = e->fdx;\n         float xb = x0 + dx;\n         float x_top, x_bottom;\n         float sy0,sy1;\n         float dy = e->fdy;\n         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);\n\n         // compute endpoints of line segment clipped to this scanline (if the\n         // line segment starts on this scanline. x0 is the intersection of the\n         // line with y_top, but that may be off the line segment.\n         if (e->sy > y_top) {\n            x_top = x0 + dx * (e->sy - y_top);\n            sy0 = e->sy;\n         } else {\n            x_top = x0;\n            sy0 = y_top;\n         }\n         if (e->ey < y_bottom) {\n            x_bottom = x0 + dx * (e->ey - y_top);\n            sy1 = e->ey;\n         } else {\n            x_bottom = xb;\n            sy1 = y_bottom;\n         }\n\n         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {\n            // from here on, we don't have to range check x values\n\n            if ((int) x_top == (int) x_bottom) {\n               float height;\n               // simple case, only spans one pixel\n               int x = (int) x_top;\n               height = (sy1 - sy0) * e->direction;\n               STBTT_assert(x >= 0 && x < len);\n               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);\n               scanline_fill[x] += height; // everything right of this pixel is filled\n            } else {\n               int x,x1,x2;\n               float y_crossing, y_final, step, sign, area;\n               // covers 2+ pixels\n               if (x_top > x_bottom) {\n                  // flip scanline vertically; signed area is the same\n                  float t;\n                  sy0 = y_bottom - (sy0 - y_top);\n                  sy1 = y_bottom - (sy1 - y_top);\n                  t = sy0, sy0 = sy1, sy1 = t;\n                  t = x_bottom, x_bottom = x_top, x_top = t;\n                  dx = -dx;\n                  dy = -dy;\n                  t = x0, x0 = xb, xb = t;\n               }\n               STBTT_assert(dy >= 0);\n               STBTT_assert(dx >= 0);\n\n               x1 = (int) x_top;\n               x2 = (int) x_bottom;\n               // compute intersection with y axis at x1+1\n               y_crossing = y_top + dy * (x1+1 - x0);\n\n               // compute intersection with y axis at x2\n               y_final = y_top + dy * (x2 - x0);\n\n               //           x1    x_top                            x2    x_bottom\n               //     y_top  +------|-----+------------+------------+--------|---+------------+\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //       sy0  |      Txxxxx|............|............|............|............|\n               // y_crossing |            *xxxxx.......|............|............|............|\n               //            |            |     xxxxx..|............|............|............|\n               //            |            |     /-   xx*xxxx........|............|............|\n               //            |            | dy <       |    xxxxxx..|............|............|\n               //   y_final  |            |     \\-     |          xx*xxx.........|............|\n               //       sy1  |            |            |            |   xxxxxB...|............|\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //  y_bottom  +------------+------------+------------+------------+------------+\n               //\n               // goal is to measure the area covered by '.' in each pixel\n\n               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057\n               // @TODO: maybe test against sy1 rather than y_bottom?\n               if (y_crossing > y_bottom)\n                  y_crossing = y_bottom;\n\n               sign = e->direction;\n\n               // area of the rectangle covered from sy0..y_crossing\n               area = sign * (y_crossing-sy0);\n\n               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)\n               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);\n\n               // check if final y_crossing is blown up; no test case for this\n               if (y_final > y_bottom) {\n                  y_final = y_bottom;\n                  dy = (y_final - y_crossing ) / (x2 - (x1+1)); // if denom=0, y_final = y_crossing, so y_final <= y_bottom\n               }\n\n               // in second pixel, area covered by line segment found in first pixel\n               // is always a rectangle 1 wide * the height of that line segment; this\n               // is exactly what the variable 'area' stores. it also gets a contribution\n               // from the line segment within it. the THIRD pixel will get the first\n               // pixel's rectangle contribution, the second pixel's rectangle contribution,\n               // and its own contribution. the 'own contribution' is the same in every pixel except\n               // the leftmost and rightmost, a trapezoid that slides down in each pixel.\n               // the second pixel's contribution to the third pixel will be the\n               // rectangle 1 wide times the height change in the second pixel, which is dy.\n\n               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,\n               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x\n               // so the area advances by 'step' every time\n\n               for (x = x1+1; x < x2; ++x) {\n                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2\n                  area += step;\n               }\n               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down\n               STBTT_assert(sy1 > y_final-0.01f);\n\n               // area covered in the last pixel is the rectangle from all the pixels to the left,\n               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge\n               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);\n\n               // the rest of the line is filled based on the total height of the line segment in this pixel\n               scanline_fill[x2] += sign * (sy1-sy0);\n            }\n         } else {\n            // if edge goes outside of box we're drawing, we require\n            // clipping logic. since this does not match the intended use\n            // of this library, we use a different, very slow brute\n            // force implementation\n            // note though that this does happen some of the time because\n            // x_top and x_bottom can be extrapolated at the top & bottom of\n            // the shape and actually lie outside the bounding box\n            int x;\n            for (x=0; x < len; ++x) {\n               // cases:\n               //\n               // there can be up to two intersections with the pixel. any intersection\n               // with left or right edges can be handled by splitting into two (or three)\n               // regions. intersections with top & bottom do not necessitate case-wise logic.\n               //\n               // the old way of doing this found the intersections with the left & right edges,\n               // then used some simple logic to produce up to three segments in sorted order\n               // from top-to-bottom. however, this had a problem: if an x edge was epsilon\n               // across the x border, then the corresponding y position might not be distinct\n               // from the other y segment, and it might ignored as an empty segment. to avoid\n               // that, we need to explicitly produce segments based on x positions.\n\n               // rename variables to clearly-defined pairs\n               float y0 = y_top;\n               float x1 = (float) (x);\n               float x2 = (float) (x+1);\n               float x3 = xb;\n               float y3 = y_bottom;\n\n               // x = e->x + e->dx * (y-y_top)\n               // (y-y_top) = (x - e->x) / e->dx\n               // y = (x - e->x) / e->dx + y_top\n               float y1 = (x - x0) / dx + y_top;\n               float y2 = (x+1 - x0) / dx + y_top;\n\n               if (x0 < x1 && x3 > x2) {         // three segments descending down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else {  // one segment\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);\n               }\n            }\n         }\n      }\n      e = e->next;\n   }\n}\n\n// directly AA rasterize edges w/o supersampling\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = NULL;\n   int y,j=0, i;\n   float scanline_data[129], *scanline, *scanline2;\n\n   STBTT__NOTUSED(vsubsample);\n\n   if (result->w > 64)\n      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);\n   else\n      scanline = scanline_data;\n\n   scanline2 = scanline + result->w;\n\n   y = off_y;\n   e[n].y0 = (float) (off_y + result->h) + 1;\n\n   while (j < result->h) {\n      // find center of pixel for this scanline\n      float scan_y_top    = y + 0.0f;\n      float scan_y_bottom = y + 1.0f;\n      stbtt__active_edge **step = &active;\n\n      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));\n      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));\n\n      // update all active edges;\n      // remove all active edges that terminate before the top of this scanline\n      while (*step) {\n         stbtt__active_edge * z = *step;\n         if (z->ey <= scan_y_top) {\n            *step = z->next; // delete from list\n            STBTT_assert(z->direction);\n            z->direction = 0;\n            stbtt__hheap_free(&hh, z);\n         } else {\n            step = &((*step)->next); // advance through list\n         }\n      }\n\n      // insert all edges that start before the bottom of this scanline\n      while (e->y0 <= scan_y_bottom) {\n         if (e->y0 != e->y1) {\n            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);\n            if (z != NULL) {\n               if (j == 0 && off_y != 0) {\n                  if (z->ey < scan_y_top) {\n                     // this can happen due to subpixel positioning and some kind of fp rounding error i think\n                     z->ey = scan_y_top;\n                  }\n               }\n               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds\n               // insert at front\n               z->next = active;\n               active = z;\n            }\n         }\n         ++e;\n      }\n\n      // now process all active edges\n      if (active)\n         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);\n\n      {\n         float sum = 0;\n         for (i=0; i < result->w; ++i) {\n            float k;\n            int m;\n            sum += scanline2[i];\n            k = scanline[i] + sum;\n            k = (float) STBTT_fabs(k)*255 + 0.5f;\n            m = (int) k;\n            if (m > 255) m = 255;\n            result->pixels[j*result->stride + i] = (unsigned char) m;\n         }\n      }\n      // advance all the edges\n      step = &active;\n      while (*step) {\n         stbtt__active_edge *z = *step;\n         z->fx += z->fdx; // advance to position for current scanline\n         step = &((*step)->next); // advance through list\n      }\n\n      ++y;\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)\n\nstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)\n{\n   int i,j;\n   for (i=1; i < n; ++i) {\n      stbtt__edge t = p[i], *a = &t;\n      j = i;\n      while (j > 0) {\n         stbtt__edge *b = &p[j-1];\n         int c = STBTT__COMPARE(a,b);\n         if (!c) break;\n         p[j] = p[j-1];\n         --j;\n      }\n      if (i != j)\n         p[j] = t;\n   }\n}\n\nstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)\n{\n   /* threshold for transitioning to insertion sort */\n   while (n > 12) {\n      stbtt__edge t;\n      int c01,c12,c,m,i,j;\n\n      /* compute median of three */\n      m = n >> 1;\n      c01 = STBTT__COMPARE(&p[0],&p[m]);\n      c12 = STBTT__COMPARE(&p[m],&p[n-1]);\n      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */\n      if (c01 != c12) {\n         /* otherwise, we'll need to swap something else to middle */\n         int z;\n         c = STBTT__COMPARE(&p[0],&p[n-1]);\n         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */\n         /* 0<mid && mid>n:  0>n => 0; 0<n => n */\n         z = (c == c12) ? 0 : n-1;\n         t = p[z];\n         p[z] = p[m];\n         p[m] = t;\n      }\n      /* now p[m] is the median-of-three */\n      /* swap it to the beginning so it won't move around */\n      t = p[0];\n      p[0] = p[m];\n      p[m] = t;\n\n      /* partition loop */\n      i=1;\n      j=n-1;\n      for(;;) {\n         /* handling of equality is crucial here */\n         /* for sentinels & efficiency with duplicates */\n         for (;;++i) {\n            if (!STBTT__COMPARE(&p[i], &p[0])) break;\n         }\n         for (;;--j) {\n            if (!STBTT__COMPARE(&p[0], &p[j])) break;\n         }\n         /* make sure we haven't crossed */\n         if (i >= j) break;\n         t = p[i];\n         p[i] = p[j];\n         p[j] = t;\n\n         ++i;\n         --j;\n      }\n      /* recurse on smaller side, iterate on larger */\n      if (j < (n-i)) {\n         stbtt__sort_edges_quicksort(p,j);\n         p = p+i;\n         n = n-i;\n      } else {\n         stbtt__sort_edges_quicksort(p+i, n-i);\n         n = j;\n      }\n   }\n}\n\nstatic void stbtt__sort_edges(stbtt__edge *p, int n)\n{\n   stbtt__sort_edges_quicksort(p, n);\n   stbtt__sort_edges_ins_sort(p, n);\n}\n\ntypedef struct\n{\n   float x,y;\n} stbtt__point;\n\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\n{\n   float y_scale_inv = invert ? -scale_y : scale_y;\n   stbtt__edge *e;\n   int n,i,j,k,m;\n#if STBTT_RASTERIZER_VERSION == 1\n   int vsubsample = result->h < 8 ? 15 : 5;\n#elif STBTT_RASTERIZER_VERSION == 2\n   int vsubsample = 1;\n#else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\n\n   // now we have to blow out the windings into explicit edge lists\n   n = 0;\n   for (i=0; i < windings; ++i)\n      n += wcount[i];\n\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\n   if (e == 0) return;\n   n = 0;\n\n   m=0;\n   for (i=0; i < windings; ++i) {\n      stbtt__point *p = pts + m;\n      m += wcount[i];\n      j = wcount[i]-1;\n      for (k=0; k < wcount[i]; j=k++) {\n         int a=k,b=j;\n         // skip the edge if horizontal\n         if (p[j].y == p[k].y)\n            continue;\n         // add edge from j to k to the list\n         e[n].invert = 0;\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\n            e[n].invert = 1;\n            a=j,b=k;\n         }\n         e[n].x0 = p[a].x * scale_x + shift_x;\n         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;\n         e[n].x1 = p[b].x * scale_x + shift_x;\n         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;\n         ++n;\n      }\n   }\n\n   // now sort the edges by their highest point (should snap to integer, and then by x)\n   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\n   stbtt__sort_edges(e, n);\n\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\n\n   STBTT_free(e, userdata);\n}\n\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; // during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}\n\n// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\n{\n   // midpoint\n   float mx = (x0 + 2*x1 + x2)/4;\n   float my = (y0 + 2*y1 + y2)/4;\n   // versus directly drawn line\n   float dx = (x0+x2)/2 - mx;\n   float dy = (y0+y2)/2 - my;\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return 1;\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x2,y2);\n      *num_points = *num_points+1;\n   }\n   return 1;\n}\n\nstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)\n{\n   // @TODO this \"flatness\" calculation is just made-up nonsense that seems to work well enough\n   float dx0 = x1-x0;\n   float dy0 = y1-y0;\n   float dx1 = x2-x1;\n   float dy1 = y2-y1;\n   float dx2 = x3-x2;\n   float dy2 = y3-y2;\n   float dx = x3-x0;\n   float dy = y3-y0;\n   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));\n   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);\n   float flatness_squared = longlen*longlen-shortlen*shortlen;\n\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return;\n\n   if (flatness_squared > objspace_flatness_squared) {\n      float x01 = (x0+x1)/2;\n      float y01 = (y0+y1)/2;\n      float x12 = (x1+x2)/2;\n      float y12 = (y1+y2)/2;\n      float x23 = (x2+x3)/2;\n      float y23 = (y2+y3)/2;\n\n      float xa = (x01+x12)/2;\n      float ya = (y01+y12)/2;\n      float xb = (x12+x23)/2;\n      float yb = (y12+y23)/2;\n\n      float mx = (xa+xb)/2;\n      float my = (ya+yb)/2;\n\n      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x3,y3);\n      *num_points = *num_points+1;\n   }\n}\n\n// returns number of contours\nstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\n{\n   stbtt__point *points=0;\n   int num_points=0;\n\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\n   int i,n=0,start=0, pass;\n\n   // count how many \"moves\" there are to get the contour count\n   for (i=0; i < num_verts; ++i)\n      if (vertices[i].type == STBTT_vmove)\n         ++n;\n\n   *num_contours = n;\n   if (n == 0) return 0;\n\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\n\n   if (*contour_lengths == 0) {\n      *num_contours = 0;\n      return 0;\n   }\n\n   // make two passes through the points so we don't need to realloc\n   for (pass=0; pass < 2; ++pass) {\n      float x=0,y=0;\n      if (pass == 1) {\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\n         if (points == NULL) goto error;\n      }\n      num_points = 0;\n      n= -1;\n      for (i=0; i < num_verts; ++i) {\n         switch (vertices[i].type) {\n            case STBTT_vmove:\n               // start the next contour\n               if (n >= 0)\n                  (*contour_lengths)[n] = num_points - start;\n               ++n;\n               start = num_points;\n\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x,y);\n               break;\n            case STBTT_vline:\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x, y);\n               break;\n            case STBTT_vcurve:\n               stbtt__tesselate_curve(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n            case STBTT_vcubic:\n               stbtt__tesselate_cubic(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].cx1, vertices[i].cy1,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n         }\n      }\n      (*contour_lengths)[n] = num_points - start;\n   }\n\n   return points;\nerror:\n   STBTT_free(points, userdata);\n   STBTT_free(*contour_lengths, userdata);\n   *contour_lengths = 0;\n   *num_contours = 0;\n   return NULL;\n}\n\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\n{\n   float scale            = scale_x > scale_y ? scale_y : scale_x;\n   int winding_count      = 0;\n   int *winding_lengths   = NULL;\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\n   if (windings) {\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\n      STBTT_free(winding_lengths, userdata);\n      STBTT_free(windings, userdata);\n   }\n}\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   int ix0,iy0,ix1,iy1;\n   stbtt__bitmap gbm;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n\n   if (scale_x == 0) scale_x = scale_y;\n   if (scale_y == 0) {\n      if (scale_x == 0) {\n         STBTT_free(vertices, info->userdata);\n         return NULL;\n      }\n      scale_y = scale_x;\n   }\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\n\n   // now we get the size\n   gbm.w = (ix1 - ix0);\n   gbm.h = (iy1 - iy0);\n   gbm.pixels = NULL; // in case we error\n\n   if (width ) *width  = gbm.w;\n   if (height) *height = gbm.h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   if (gbm.w && gbm.h) {\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\n      if (gbm.pixels) {\n         gbm.stride = gbm.w;\n\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\n      }\n   }\n   STBTT_free(vertices, info->userdata);\n   return gbm.pixels;\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\n{\n   int ix0,iy0;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n   stbtt__bitmap gbm;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\n   gbm.pixels = output;\n   gbm.w = out_w;\n   gbm.h = out_h;\n   gbm.stride = out_stride;\n\n   if (gbm.w && gbm.h)\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\n\n   STBTT_free(vertices, info->userdata);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\n{\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-CRAPPY packing to keep source code small\n\nstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata)\n{\n   float scale;\n   int x,y,bottom_y, i;\n   stbtt_fontinfo f;\n   f.userdata = NULL;\n   if (!stbtt_InitFont(&f, data, offset))\n      return -1;\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n   x=y=1;\n   bottom_y = 1;\n\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\n\n   for (i=0; i < num_chars; ++i) {\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\n      gw = x1-x0;\n      gh = y1-y0;\n      if (x + gw + 1 >= pw)\n         y = bottom_y, x = 1; // advance to next row\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\n         return -i;\n      STBTT_assert(x+gw < pw);\n      STBTT_assert(y+gh < ph);\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\n      chardata[i].x0 = (stbtt_int16) x;\n      chardata[i].y0 = (stbtt_int16) y;\n      chardata[i].x1 = (stbtt_int16) (x + gw);\n      chardata[i].y1 = (stbtt_int16) (y + gh);\n      chardata[i].xadvance = scale * advance;\n      chardata[i].xoff     = (float) x0;\n      chardata[i].yoff     = (float) y0;\n      x = x + gw + 1;\n      if (y+gh+1 > bottom_y)\n         bottom_y = y+gh+1;\n   }\n   return bottom_y;\n}\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\n{\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_bakedchar *b = chardata + char_index;\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n\n   q->x0 = round_x + d3d_bias;\n   q->y0 = round_y + d3d_bias;\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// rectangle packing replacement routines if you don't have stb_rect_pack.h\n//\n\n#ifndef STB_RECT_PACK_VERSION\n\ntypedef int stbrp_coord;\n\n////////////////////////////////////////////////////////////////////////////////////\n//                                                                                //\n//                                                                                //\n// COMPILER WARNING ?!?!?                                                         //\n//                                                                                //\n//                                                                                //\n// if you get a compile warning due to these symbols being defined more than      //\n// once, move #include \"stb_rect_pack.h\" before #include \"stb_truetype.h\"         //\n//                                                                                //\n////////////////////////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n   int width,height;\n   int x,y,bottom_y;\n} stbrp_context;\n\ntypedef struct\n{\n   unsigned char x;\n} stbrp_node;\n\nstruct stbrp_rect\n{\n   stbrp_coord x,y;\n   int id,w,h,was_packed;\n};\n\nstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}\n\nstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)\n{\n   int i;\n   for (i=0; i < num_rects; ++i) {\n      if (con->x + rects[i].w > con->width) {\n         con->x = 0;\n         con->y = con->bottom_y;\n      }\n      if (con->y + rects[i].h > con->height)\n         break;\n      rects[i].x = con->x;\n      rects[i].y = con->y;\n      rects[i].was_packed = 1;\n      con->x += rects[i].w;\n      if (con->y + rects[i].h > con->bottom_y)\n         con->bottom_y = con->y + rects[i].h;\n   }\n   for (   ; i < num_rects; ++i)\n      rects[i].was_packed = 0;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If\n// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.\n\nSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)\n{\n   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);\n   int            num_nodes = pw - padding;\n   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);\n\n   if (context == NULL || nodes == NULL) {\n      if (context != NULL) STBTT_free(context, alloc_context);\n      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);\n      return 0;\n   }\n\n   spc->user_allocator_context = alloc_context;\n   spc->width = pw;\n   spc->height = ph;\n   spc->pixels = pixels;\n   spc->pack_info = context;\n   spc->nodes = nodes;\n   spc->padding = padding;\n   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;\n   spc->h_oversample = 1;\n   spc->v_oversample = 1;\n   spc->skip_missing = 0;\n\n   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);\n\n   if (pixels)\n      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n\n   return 1;\n}\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)\n{\n   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);\n   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);\n   if (h_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->h_oversample = h_oversample;\n   if (v_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->v_oversample = v_oversample;\n}\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}\n\n#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)\n\nstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_w = w - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < h; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < w; ++i) {\n         STBTT_assert(pixels[i] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += stride_in_bytes;\n   }\n}\n\nstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_h = h - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < w; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < h; ++i) {\n         STBTT_assert(pixels[i*stride_in_bytes] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += 1;\n   }\n}\n\nstatic float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   // The prefilter is a box filter of width \"oversample\",\n   // which shifts phase by (oversample - 1)/2 pixels in\n   // oversampled space. We want to shift in the opposite\n   // direction to counter this.\n   return (float)-(oversample - 1) / (2.0f * (float)oversample);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k;\n   int missing_glyph_added = 0;\n\n   k=0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      ranges[i].h_oversample = (unsigned char) spc->h_oversample;\n      ranges[i].v_oversample = (unsigned char) spc->v_oversample;\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         int x0,y0,x1,y1;\n         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n         int glyph = stbtt_FindGlyphIndex(info, codepoint);\n         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {\n            rects[k].w = rects[k].h = 0;\n         } else {\n            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,\n                                            scale * spc->h_oversample,\n                                            scale * spc->v_oversample,\n                                            0,0,\n                                            &x0,&y0,&x1,&y1);\n            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);\n            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);\n            if (glyph == 0)\n               missing_glyph_added = 1;\n         }\n         ++k;\n      }\n   }\n\n   return k;\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info,\n                                 output,\n                                 out_w - (prefilter_x - 1),\n                                 out_h - (prefilter_y - 1),\n                                 out_stride,\n                                 scale_x,\n                                 scale_y,\n                                 shift_x,\n                                 shift_y,\n                                 glyph);\n\n   if (prefilter_x > 1)\n      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);\n\n   if (prefilter_y > 1)\n      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);\n\n   *sub_x = stbtt__oversample_shift(prefilter_x);\n   *sub_y = stbtt__oversample_shift(prefilter_y);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k, missing_glyph = -1, return_value = 1;\n\n   // save current values\n   int old_h_over = spc->h_oversample;\n   int old_v_over = spc->v_oversample;\n\n   k = 0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      float recip_h,recip_v,sub_x,sub_y;\n      spc->h_oversample = ranges[i].h_oversample;\n      spc->v_oversample = ranges[i].v_oversample;\n      recip_h = 1.0f / spc->h_oversample;\n      recip_v = 1.0f / spc->v_oversample;\n      sub_x = stbtt__oversample_shift(spc->h_oversample);\n      sub_y = stbtt__oversample_shift(spc->v_oversample);\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         stbrp_rect *r = &rects[k];\n         if (r->was_packed && r->w != 0 && r->h != 0) {\n            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];\n            int advance, lsb, x0,y0,x1,y1;\n            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n            int glyph = stbtt_FindGlyphIndex(info, codepoint);\n            stbrp_coord pad = (stbrp_coord) spc->padding;\n\n            // pad on left and top\n            r->x += pad;\n            r->y += pad;\n            r->w -= pad;\n            r->h -= pad;\n            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);\n            stbtt_GetGlyphBitmapBox(info, glyph,\n                                    scale * spc->h_oversample,\n                                    scale * spc->v_oversample,\n                                    &x0,&y0,&x1,&y1);\n            stbtt_MakeGlyphBitmapSubpixel(info,\n                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                          r->w - spc->h_oversample+1,\n                                          r->h - spc->v_oversample+1,\n                                          spc->stride_in_bytes,\n                                          scale * spc->h_oversample,\n                                          scale * spc->v_oversample,\n                                          0,0,\n                                          glyph);\n\n            if (spc->h_oversample > 1)\n               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->h_oversample);\n\n            if (spc->v_oversample > 1)\n               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->v_oversample);\n\n            bc->x0       = (stbtt_int16)  r->x;\n            bc->y0       = (stbtt_int16)  r->y;\n            bc->x1       = (stbtt_int16) (r->x + r->w);\n            bc->y1       = (stbtt_int16) (r->y + r->h);\n            bc->xadvance =                scale * advance;\n            bc->xoff     =       (float)  x0 * recip_h + sub_x;\n            bc->yoff     =       (float)  y0 * recip_v + sub_y;\n            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;\n            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;\n\n            if (glyph == 0)\n               missing_glyph = j;\n         } else if (spc->skip_missing) {\n            return_value = 0;\n         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {\n            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];\n         } else {\n            return_value = 0; // if any fail, report failure\n         }\n\n         ++k;\n      }\n   }\n\n   // restore original values\n   spc->h_oversample = old_h_over;\n   spc->v_oversample = old_v_over;\n\n   return return_value;\n}\n\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)\n{\n   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);\n}\n\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)\n{\n   stbtt_fontinfo info;\n   int i,j,n, return_value = 1;\n   //stbrp_context *context = (stbrp_context *) spc->pack_info;\n   stbrp_rect    *rects;\n\n   // flag all characters as NOT packed\n   for (i=0; i < num_ranges; ++i)\n      for (j=0; j < ranges[i].num_chars; ++j)\n         ranges[i].chardata_for_range[j].x0 =\n         ranges[i].chardata_for_range[j].y0 =\n         ranges[i].chardata_for_range[j].x1 =\n         ranges[i].chardata_for_range[j].y1 = 0;\n\n   n = 0;\n   for (i=0; i < num_ranges; ++i)\n      n += ranges[i].num_chars;\n\n   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);\n   if (rects == NULL)\n      return 0;\n\n   info.userdata = spc->user_allocator_context;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\n\n   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\n\n   stbtt_PackFontRangesPackRects(spc, rects, n);\n\n   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\n\n   STBTT_free(rects, spc->user_allocator_context);\n   return return_value;\n}\n\nSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)\n{\n   stbtt_pack_range range;\n   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;\n   range.array_of_unicode_codepoints = NULL;\n   range.num_chars                   = num_chars_in_range;\n   range.chardata_for_range          = chardata_for_range;\n   range.font_size                   = font_size;\n   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);\n}\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)\n{\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_packedchar *b = chardata + char_index;\n\n   if (align_to_integer) {\n      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n      q->x0 = x;\n      q->y0 = y;\n      q->x1 = x + b->xoff2 - b->xoff;\n      q->y1 = y + b->yoff2 - b->yoff;\n   } else {\n      q->x0 = *xpos + b->xoff;\n      q->y0 = *ypos + b->yoff;\n      q->x1 = *xpos + b->xoff2;\n      q->y1 = *ypos + b->yoff2;\n   }\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// sdf computation\n//\n\n#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))\n#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))\n\nstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])\n{\n   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];\n   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];\n   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];\n   float roperp = orig[1]*ray[0] - orig[0]*ray[1];\n\n   float a = q0perp - 2*q1perp + q2perp;\n   float b = q1perp - q0perp;\n   float c = q0perp - roperp;\n\n   float s0 = 0., s1 = 0.;\n   int num_s = 0;\n\n   if (a != 0.0) {\n      float discr = b*b - a*c;\n      if (discr > 0.0) {\n         float rcpna = -1 / a;\n         float d = (float) STBTT_sqrt(discr);\n         s0 = (b+d) * rcpna;\n         s1 = (b-d) * rcpna;\n         if (s0 >= 0.0 && s0 <= 1.0)\n            num_s = 1;\n         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {\n            if (num_s == 0) s0 = s1;\n            ++num_s;\n         }\n      }\n   } else {\n      // 2*b*s + c = 0\n      // s = -c / (2*b)\n      s0 = c / (-2 * b);\n      if (s0 >= 0.0 && s0 <= 1.0)\n         num_s = 1;\n   }\n\n   if (num_s == 0)\n      return 0;\n   else {\n      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);\n      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;\n\n      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;\n      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;\n      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;\n      float rod = orig[0]*rayn_x + orig[1]*rayn_y;\n\n      float q10d = q1d - q0d;\n      float q20d = q2d - q0d;\n      float q0rd = q0d - rod;\n\n      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;\n      hits[0][1] = a*s0+b;\n\n      if (num_s > 1) {\n         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;\n         hits[1][1] = a*s1+b;\n         return 2;\n      } else {\n         return 1;\n      }\n   }\n}\n\nstatic int equal(float *a, float *b)\n{\n   return (a[0] == b[0] && a[1] == b[1]);\n}\n\nstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)\n{\n   int i;\n   float orig[2], ray[2] = { 1, 0 };\n   float y_frac;\n   int winding = 0;\n\n   // make sure y never passes through a vertex of the shape\n   y_frac = (float) STBTT_fmod(y, 1.0f);\n   if (y_frac < 0.01f)\n      y += 0.01f;\n   else if (y_frac > 0.99f)\n      y -= 0.01f;\n\n   orig[0] = x;\n   orig[1] = y;\n\n   // test a ray from (-infinity,y) to (x,y)\n   for (i=0; i < nverts; ++i) {\n      if (verts[i].type == STBTT_vline) {\n         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;\n         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;\n         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n            if (x_inter < x)\n               winding += (y0 < y1) ? 1 : -1;\n         }\n      }\n      if (verts[i].type == STBTT_vcurve) {\n         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;\n         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;\n         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;\n         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));\n         int by = STBTT_max(y0,STBTT_max(y1,y2));\n         if (y > ay && y < by && x > ax) {\n            float q0[2],q1[2],q2[2];\n            float hits[2][2];\n            q0[0] = (float)x0;\n            q0[1] = (float)y0;\n            q1[0] = (float)x1;\n            q1[1] = (float)y1;\n            q2[0] = (float)x2;\n            q2[1] = (float)y2;\n            if (equal(q0,q1) || equal(q1,q2)) {\n               x0 = (int)verts[i-1].x;\n               y0 = (int)verts[i-1].y;\n               x1 = (int)verts[i  ].x;\n               y1 = (int)verts[i  ].y;\n               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n                  if (x_inter < x)\n                     winding += (y0 < y1) ? 1 : -1;\n               }\n            } else {\n               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);\n               if (num_hits >= 1)\n                  if (hits[0][0] < 0)\n                     winding += (hits[0][1] < 0 ? -1 : 1);\n               if (num_hits >= 2)\n                  if (hits[1][0] < 0)\n                     winding += (hits[1][1] < 0 ? -1 : 1);\n            }\n         }\n      }\n   }\n   return winding;\n}\n\nstatic float stbtt__cuberoot( float x )\n{\n   if (x<0)\n      return -(float) STBTT_pow(-x,1.0f/3.0f);\n   else\n      return  (float) STBTT_pow( x,1.0f/3.0f);\n}\n\n// x^3 + a*x^2 + b*x + c = 0\nstatic int stbtt__solve_cubic(float a, float b, float c, float* r)\n{\n   float s = -a / 3;\n   float p = b - a*a / 3;\n   float q = a * (2*a*a - 9*b) / 27 + c;\n   float p3 = p*p*p;\n   float d = q*q + 4*p3 / 27;\n   if (d >= 0) {\n      float z = (float) STBTT_sqrt(d);\n      float u = (-q + z) / 2;\n      float v = (-q - z) / 2;\n      u = stbtt__cuberoot(u);\n      v = stbtt__cuberoot(v);\n      r[0] = s + u + v;\n      return 1;\n   } else {\n      float u = (float) STBTT_sqrt(-p/3);\n      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative\n      float m = (float) STBTT_cos(v);\n      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;\n      r[0] = s + u * 2 * m;\n      r[1] = s - u * (m + n);\n      r[2] = s - u * (m - n);\n\n      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?\n      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);\n      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);\n      return 3;\n   }\n}\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   float scale_x = scale, scale_y = scale;\n   int ix0,iy0,ix1,iy1;\n   int w,h;\n   unsigned char *data;\n\n   if (scale == 0) return NULL;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);\n\n   // if empty, return NULL\n   if (ix0 == ix1 || iy0 == iy1)\n      return NULL;\n\n   ix0 -= padding;\n   iy0 -= padding;\n   ix1 += padding;\n   iy1 += padding;\n\n   w = (ix1 - ix0);\n   h = (iy1 - iy0);\n\n   if (width ) *width  = w;\n   if (height) *height = h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   // invert for y-downwards bitmaps\n   scale_y = -scale_y;\n\n   {\n      // distance from singular values (in the same units as the pixel grid)\n      const float eps = 1./1024, eps2 = eps*eps;\n      int x,y,i,j;\n      float *precompute;\n      stbtt_vertex *verts;\n      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);\n      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);\n      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);\n\n      for (i=0,j=num_verts-1; i < num_verts; j=i++) {\n         if (verts[i].type == STBTT_vline) {\n            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;\n            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));\n            precompute[i] = (dist < eps) ? 0.0f : 1.0f / dist;\n         } else if (verts[i].type == STBTT_vcurve) {\n            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;\n            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;\n            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;\n            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n            float len2 = bx*bx + by*by;\n            if (len2 >= eps2)\n               precompute[i] = 1.0f / len2;\n            else\n               precompute[i] = 0.0f;\n         } else\n            precompute[i] = 0.0f;\n      }\n\n      for (y=iy0; y < iy1; ++y) {\n         for (x=ix0; x < ix1; ++x) {\n            float val;\n            float min_dist = 999999.0f;\n            float sx = (float) x + 0.5f;\n            float sy = (float) y + 0.5f;\n            float x_gspace = (sx / scale_x);\n            float y_gspace = (sy / scale_y);\n\n            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path\n\n            for (i=0; i < num_verts; ++i) {\n               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n\n               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {\n                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;\n\n                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                  if (dist2 < min_dist*min_dist)\n                     min_dist = (float) STBTT_sqrt(dist2);\n\n                  // coarse culling against bbox\n                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&\n                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)\n                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];\n                  STBTT_assert(i != 0);\n                  if (dist < min_dist) {\n                     // check position along line\n                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)\n                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)\n                     float dx = x1-x0, dy = y1-y0;\n                     float px = x0-sx, py = y0-sy;\n                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy\n                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve\n                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);\n                     if (t >= 0.0f && t <= 1.0f)\n                        min_dist = dist;\n                  }\n               } else if (verts[i].type == STBTT_vcurve) {\n                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;\n                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;\n                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);\n                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);\n                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);\n                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);\n                  // coarse culling against bbox to avoid computing cubic unnecessarily\n                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {\n                     int num=0;\n                     float ax = x1-x0, ay = y1-y0;\n                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n                     float mx = x0 - sx, my = y0 - sy;\n                     float res[3] = {0.f,0.f,0.f};\n                     float px,py,t,it,dist2;\n                     float a_inv = precompute[i];\n                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula\n                        float a = 3*(ax*bx + ay*by);\n                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);\n                        float c = mx*ax+my*ay;\n                        if (STBTT_fabs(a) < eps2) { // if a is 0, it's linear\n                           if (STBTT_fabs(b) >= eps2) {\n                              res[num++] = -c/b;\n                           }\n                        } else {\n                           float discriminant = b*b - 4*a*c;\n                           if (discriminant < 0)\n                              num = 0;\n                           else {\n                              float root = (float) STBTT_sqrt(discriminant);\n                              res[0] = (-b - root)/(2*a);\n                              res[1] = (-b + root)/(2*a);\n                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work\n                           }\n                        }\n                     } else {\n                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point\n                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;\n                        float d = (mx*ax+my*ay) * a_inv;\n                        num = stbtt__solve_cubic(b, c, d, res);\n                     }\n                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                     if (dist2 < min_dist*min_dist)\n                        min_dist = (float) STBTT_sqrt(dist2);\n\n                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {\n                        t = res[0], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {\n                        t = res[1], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {\n                        t = res[2], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                  }\n               }\n            }\n            if (winding == 0)\n               min_dist = -min_dist;  // if outside the shape, value is negative\n            val = onedge_value + pixel_dist_scale * min_dist;\n            if (val < 0)\n               val = 0;\n            else if (val > 255)\n               val = 255;\n            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;\n         }\n      }\n      STBTT_free(precompute, info->userdata);\n      STBTT_free(verts, info->userdata);\n   }\n   return data;\n}\n\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// font name matching -- recommended not to use this\n//\n\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)\n{\n   stbtt_int32 i=0;\n\n   // convert utf16 to utf8 and compare the results while converting\n   while (len2) {\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\n      if (ch < 0x80) {\n         if (i >= len1) return -1;\n         if (s1[i++] != ch) return -1;\n      } else if (ch < 0x800) {\n         if (i+1 >= len1) return -1;\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\n         stbtt_uint32 c;\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\n         if (i+3 >= len1) return -1;\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\n         s2 += 2; // plus another 2 below\n         len2 -= 2;\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\n         return -1;\n      } else {\n         if (i+2 >= len1) return -1;\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\n      }\n      s2 += 2;\n      len2 -= 2;\n   }\n   return i;\n}\n\nstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)\n{\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);\n}\n\n// returns results in whatever encoding you request... but note that 2-byte encodings\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\n{\n   stbtt_int32 i,count,stringOffset;\n   stbtt_uint8 *fc = font->data;\n   stbtt_uint32 offset = font->fontstart;\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return NULL;\n\n   count = ttUSHORT(fc+nm+2);\n   stringOffset = nm + ttUSHORT(fc+nm+4);\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\n         *length = ttUSHORT(fc+loc+8);\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\n      }\n   }\n   return NULL;\n}\n\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\n{\n   stbtt_int32 i;\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\n\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\n      if (id == target_id) {\n         // find the encoding\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\n\n         // is this a Unicode encoding?\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\n            stbtt_int32 slen = ttUSHORT(fc+loc+8);\n            stbtt_int32 off = ttUSHORT(fc+loc+10);\n\n            // check if there's a prefix match\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\n            if (matchlen >= 0) {\n               // check for target_id+1 immediately following, with same encoding & language\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\n                  slen = ttUSHORT(fc+loc+12+8);\n                  off = ttUSHORT(fc+loc+12+10);\n                  if (slen == 0) {\n                     if (matchlen == nlen)\n                        return 1;\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\n                     ++matchlen;\n                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\n                        return 1;\n                  }\n               } else {\n                  // if nothing immediately following\n                  if (matchlen == nlen)\n                     return 1;\n               }\n            }\n         }\n\n         // @TODO handle other encodings\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\n{\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\n   stbtt_uint32 nm,hd;\n   if (!stbtt__isfont(fc+offset)) return 0;\n\n   // check italics/bold/underline flags in macStyle...\n   if (flags) {\n      hd = stbtt__find_table(fc, offset, \"head\");\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\n   }\n\n   nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   if (flags) {\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   } else {\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   }\n\n   return 0;\n}\n\nstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)\n{\n   stbtt_int32 i;\n   for (i=0;;++i) {\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\n      if (off < 0) return off;\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\n         return off;\n   }\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,\n                                float pixel_height, unsigned char *pixels, int pw, int ph,\n                                int first_char, int num_chars, stbtt_bakedchar *chardata)\n{\n   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);\n}\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)\n{\n   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);\n}\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)\n{\n   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif // STB_TRUETYPE_IMPLEMENTATION\n\n\n// FULL VERSION HISTORY\n//\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) allow user-defined fabs() replacement\n//                     fix memory leak if fontsize=0.0\n//                     fix warning from duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     allow PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)\n//                     also more precise AA rasterizer, except if shapes overlap\n//                     remove need for STBTT_sort\n//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC\n//   1.04 (2015-04-15) typo in example\n//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes\n//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++\n//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match\n//                        non-oversampled; STBTT_POINT_SIZE for packed case only\n//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling\n//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)\n//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID\n//   0.8b (2014-07-07) fix a warning\n//   0.8  (2014-05-25) fix a few more warnings\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\n//   0.6c (2012-07-24) improve documentation\n//   0.6b (2012-07-20) fix a few more warnings\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\n//   0.5  (2011-12-09) bugfixes:\n//                        subpixel glyph renderer computed wrong bounding box\n//                        first vertex of shape can be off-curve (FreeSans)\n//   0.4b (2011-12-03) fixed an error in the font baking example\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\n//                    bugfixes for:\n//                        codepoint-to-glyph conversion using table fmt=12\n//                        codepoint-to-glyph conversion using table fmt=4\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\n//                    updated Hello World! sample to use kerning and subpixel\n//                    fixed some warnings\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\n//                    userdata, malloc-from-userdata, non-zero fill (stb)\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\n//   0.1  (2009-03-09) First public release\n//\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_vorbis.c",
          "type": "blob",
          "size": 188.271484375,
          "content": "// Ogg Vorbis audio decoder - v1.22 - public domain\n// http://nothings.org/stb_vorbis/\n//\n// Original version written by Sean Barrett in 2007.\n//\n// Originally sponsored by RAD Game Tools. Seeking implementation\n// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,\n// Elias Software, Aras Pranckevicius, and Sean Barrett.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// Limitations:\n//\n//   - floor 0 not supported (used in old ogg vorbis files pre-2004)\n//   - lossless sample-truncation at beginning ignored\n//   - cannot concatenate multiple vorbis streams\n//   - sample positions are 32-bit, limiting seekable 192Khz\n//       files to around 6 hours (Ogg supports 64-bit)\n//\n// Feature contributors:\n//    Dougall Johnson (sample-exact seeking)\n//\n// Bugfix/warning contributors:\n//    Terje Mathisen     Niklas Frykholm     Andy Hill\n//    Casey Muratori     John Bolton         Gargaj\n//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier\n//    Bernhard Wodo      Evan Balster        github:alxprd\n//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot\n//    Phillip Bennefall  Rohit               Thiago Goulart\n//    github:manxorist   Saga Musix          github:infatum\n//    Timur Gagiev       Maxwell Koo         Peter Waller\n//    github:audinowho   Dougall Johnson     David Reid\n//    github:Clownacy    Pedro J. Estebanez  Remi Verschelde\n//    AnthoFoxo          github:morlat       Gabriel Ravier\n//\n// Partial history:\n//    1.22    - 2021-07-11 - various small fixes\n//    1.21    - 2021-07-02 - fix bug for files with no comments\n//    1.20    - 2020-07-11 - several small fixes\n//    1.19    - 2020-02-05 - warnings\n//    1.18    - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.\n//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)\n//    1.16    - 2019-03-04 - fix warnings\n//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n//    1.14    - 2018-02-11 - delete bogus dealloca usage\n//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n//    1.11    - 2017-07-23 - fix MinGW compilation\n//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n//    1.09    - 2016-04-04 - back out 'truncation of last frame' fix from previous version\n//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame\n//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const\n//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n//                           some crash fixes when out of memory or with corrupt files\n//                           fix some inappropriately signed shifts\n//    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n//    1.04    - 2014-08-27 - fix missing const-correct case in API\n//    1.03    - 2014-08-07 - warning fixes\n//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows\n//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)\n//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in >2-channel;\n//                           (API change) report sample rate for decode-full-file funcs\n//\n// See end of file for full version history.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  HEADER BEGINS HERE\n//\n\n#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H\n#define STB_VORBIS_INCLUDE_STB_VORBIS_H\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n#define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n///////////   THREAD SAFETY\n\n// Individual stb_vorbis* handles are not thread-safe; you cannot decode from\n// them from multiple threads at the same time. However, you can have multiple\n// stb_vorbis* handles and decode from them independently in multiple thrads.\n\n\n///////////   MEMORY ALLOCATION\n\n// normally stb_vorbis uses malloc() to allocate memory at startup,\n// and alloca() to allocate temporary memory during a frame on the\n// stack. (Memory consumption will depend on the amount of setup\n// data in the file and how you set the compile flags for speed\n// vs. size. In my test files the maximal-size usage is ~150KB.)\n//\n// You can modify the wrapper functions in the source (setup_malloc,\n// setup_temp_malloc, temp_malloc) to change this behavior, or you\n// can use a simpler allocation model: you pass in a buffer from\n// which stb_vorbis will allocate _all_ its memory (including the\n// temp memory). \"open\" may fail with a VORBIS_outofmem if you\n// do not pass in enough data; there is no way to determine how\n// much you do need except to succeed (at which point you can\n// query get_info to find the exact amount required. yes I know\n// this is lame).\n//\n// If you pass in a non-NULL buffer of the type below, allocation\n// will occur from it as described above. Otherwise just pass NULL\n// to use malloc()/alloca()\n\ntypedef struct\n{\n   char *alloc_buffer;\n   int   alloc_buffer_length_in_bytes;\n} stb_vorbis_alloc;\n\n\n///////////   FUNCTIONS USEABLE WITH ALL INPUT MODES\n\ntypedef struct stb_vorbis stb_vorbis;\n\ntypedef struct\n{\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int setup_temp_memory_required;\n   unsigned int temp_memory_required;\n\n   int max_frame_size;\n} stb_vorbis_info;\n\ntypedef struct\n{\n   char *vendor;\n\n   int comment_list_length;\n   char **comment_list;\n} stb_vorbis_comment;\n\n// get general information about the file\nextern stb_vorbis_info stb_vorbis_get_info(stb_vorbis *f);\n\n// get ogg comments\nextern stb_vorbis_comment stb_vorbis_get_comment(stb_vorbis *f);\n\n// get the last error detected (clears it, too)\nextern int stb_vorbis_get_error(stb_vorbis *f);\n\n// close an ogg vorbis file and free all memory in use\nextern void stb_vorbis_close(stb_vorbis *f);\n\n// this function returns the offset (in samples) from the beginning of the\n// file that will be returned by the next decode, if it is known, or -1\n// otherwise. after a flush_pushdata() call, this may take a while before\n// it becomes valid again.\n// NOT WORKING YET after a seek with PULLDATA API\nextern int stb_vorbis_get_sample_offset(stb_vorbis *f);\n\n// returns the current seek point within the file, or offset from the beginning\n// of the memory buffer. In pushdata mode it returns 0.\nextern unsigned int stb_vorbis_get_file_offset(stb_vorbis *f);\n\n///////////   PUSHDATA API\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\n// this API allows you to get blocks of data from any source and hand\n// them to stb_vorbis. you have to buffer them; stb_vorbis will tell\n// you how much it used, and you have to give it the rest next time;\n// and stb_vorbis may not have enough data to work with and you will\n// need to give it the same data again PLUS more. Note that the Vorbis\n// specification does not bound the size of an individual frame.\n\nextern stb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char * datablock, int datablock_length_in_bytes,\n         int *datablock_memory_consumed_in_bytes,\n         int *error,\n         const stb_vorbis_alloc *alloc_buffer);\n// create a vorbis decoder by passing in the initial data block containing\n//    the ogg&vorbis headers (you don't need to do parse them, just provide\n//    the first N bytes of the file--you're told if it's not enough, see below)\n// on success, returns an stb_vorbis *, does not set error, returns the amount of\n//    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;\n// on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed\n// if returns NULL and *error is VORBIS_need_more_data, then the input block was\n//       incomplete and you need to pass in a larger block from the start of the file\n\nextern int stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,\n         const unsigned char *datablock, int datablock_length_in_bytes,\n         int *channels,             // place to write number of float * buffers\n         float ***output,           // place to write float ** array of float * buffers\n         int *samples               // place to write number of output samples\n     );\n// decode a frame of audio sample data if possible from the passed-in data block\n//\n// return value: number of bytes we used from datablock\n//\n// possible cases:\n//     0 bytes used, 0 samples output (need more data)\n//     N bytes used, 0 samples output (resynching the stream, keep going)\n//     N bytes used, M samples output (one frame of data)\n// note that after opening a file, you will ALWAYS get one N-bytes,0-sample\n// frame, because Vorbis always \"discards\" the first frame.\n//\n// Note that on resynch, stb_vorbis will rarely consume all of the buffer,\n// instead only datablock_length_in_bytes-3 or less. This is because it wants\n// to avoid missing parts of a page header if they cross a datablock boundary,\n// without writing state-machiney code to record a partial detection.\n//\n// The number of channels returned are stored in *channels (which can be\n// NULL--it is always the same as the number of channels reported by\n// get_info). *output will contain an array of float* buffers, one per\n// channel. In other words, (*output)[0][0] contains the first sample from\n// the first channel, and (*output)[1][0] contains the first sample from\n// the second channel.\n//\n// *output points into stb_vorbis's internal output buffer storage; these\n// buffers are owned by stb_vorbis and application code should not free\n// them or modify their contents. They are transient and will be overwritten\n// once you ask for more data to get decoded, so be sure to grab any data\n// you need before then.\n\nextern void stb_vorbis_flush_pushdata(stb_vorbis *f);\n// inform stb_vorbis that your next datablock will not be contiguous with\n// previous ones (e.g. you've seeked in the data); future attempts to decode\n// frames will cause stb_vorbis to resynchronize (as noted above), and\n// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it\n// will begin decoding the _next_ frame.\n//\n// if you want to seek using pushdata, you need to seek in your file, then\n// call stb_vorbis_flush_pushdata(), then start calling decoding, then once\n// decoding is returning you data, call stb_vorbis_get_sample_offset, and\n// if you don't like the result, seek your file again and repeat.\n#endif\n\n\n//////////   PULLING INPUT API\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n// This API assumes stb_vorbis is allowed to pull data from a source--\n// either a block of memory containing the _entire_ vorbis stream, or a\n// FILE * that you or it create, or possibly some other reading mechanism\n// if you go modify the source to replace the FILE * case with some kind\n// of callback to your code. (But if you don't support seeking, you may\n// just want to go ahead and use pushdata.)\n\n#if !defined(STB_VORBIS_NO_STDIO) && !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output);\n#endif\n#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)\nextern int stb_vorbis_decode_memory(const unsigned char *mem, int len, int *channels, int *sample_rate, short **output);\n#endif\n// decode an entire file and output the data interleaved into a malloc()ed\n// buffer stored in *output. The return value is the number of samples\n// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.\n// When you're done with it, just free() the pointer returned in *output.\n\nextern stb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an ogg vorbis stream in memory (note\n// this must be the entire stream!). on failure, returns NULL and sets *error\n\n#ifndef STB_VORBIS_NO_STDIO\nextern stb_vorbis * stb_vorbis_open_filename(const char *filename,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from a filename via fopen(). on failure,\n// returns NULL and sets *error (possibly to VORBIS_file_open_failure).\n\nextern stb_vorbis * stb_vorbis_open_file(FILE *f, int close_handle_on_close,\n                                  int *error, const stb_vorbis_alloc *alloc_buffer);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell). on failure, returns NULL and sets *error.\n// note that stb_vorbis must \"own\" this stream; if you seek it in between\n// calls to stb_vorbis, it will become confused. Moreover, if you attempt to\n// perform stb_vorbis_seek_*() operations on this file, it will assume it\n// owns the _entire_ rest of the file after the start point. Use the next\n// function, stb_vorbis_open_file_section(), to limit it.\n\nextern stb_vorbis * stb_vorbis_open_file_section(FILE *f, int close_handle_on_close,\n                int *error, const stb_vorbis_alloc *alloc_buffer, unsigned int len);\n// create an ogg vorbis decoder from an open FILE *, looking for a stream at\n// the _current_ seek point (ftell); the stream will be of length 'len' bytes.\n// on failure, returns NULL and sets *error. note that stb_vorbis must \"own\"\n// this stream; if you seek it in between calls to stb_vorbis, it will become\n// confused.\n#endif\n\nextern int stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number);\nextern int stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number);\n// these functions seek in the Vorbis file to (approximately) 'sample_number'.\n// after calling seek_frame(), the next call to get_frame_*() will include\n// the specified sample. after calling stb_vorbis_seek(), the next call to\n// stb_vorbis_get_samples_* will start with the specified sample. If you\n// do not need to seek to EXACTLY the target sample when using get_samples_*,\n// you can also use seek_frame().\n\nextern int stb_vorbis_seek_start(stb_vorbis *f);\n// this function is equivalent to stb_vorbis_seek(f,0)\n\nextern unsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f);\nextern float        stb_vorbis_stream_length_in_seconds(stb_vorbis *f);\n// these functions return the total length of the vorbis stream\n\nextern int stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output);\n// decode the next frame and return the number of samples. the number of\n// channels returned are stored in *channels (which can be NULL--it is always\n// the same as the number of channels reported by get_info). *output will\n// contain an array of float* buffers, one per channel. These outputs will\n// be overwritten on the next call to stb_vorbis_get_frame_*.\n//\n// You generally should not intermix calls to stb_vorbis_get_frame_*()\n// and stb_vorbis_get_samples_*(), since the latter calls the former.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts);\nextern int stb_vorbis_get_frame_short            (stb_vorbis *f, int num_c, short **buffer, int num_samples);\n#endif\n// decode the next frame and return the number of *samples* per channel.\n// Note that for interleaved data, you pass in the number of shorts (the\n// size of your array), but the return value is the number of samples per\n// channel, not the total number of samples.\n//\n// The data is coerced to the number of channels you request according to the\n// channel coercion rules (see below). You must pass in the size of your\n// buffer(s) so that stb_vorbis will not overwrite the end of the buffer.\n// The maximum buffer size needed can be gotten from get_info(); however,\n// the Vorbis I specification implies an absolute maximum of 4096 samples\n// per channel.\n\n// Channel coercion rules:\n//    Let M be the number of channels requested, and N the number of channels present,\n//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,\n//    and stereo R be the sum of all R and center channels (channel assignment from the\n//    vorbis spec).\n//        M    N       output\n//        1    k      sum(Ck) for all k\n//        2    *      stereo L, stereo R\n//        k    l      k > l, the first l channels, then 0s\n//        k    l      k <= l, the first k channels\n//    Note that this is not _good_ surround etc. mixing at all! It's just so\n//    you get something useful.\n\nextern int stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats);\nextern int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples);\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.\n// Returns the number of samples stored per channel; it may be less than requested\n// at the end of the file. If there are no more samples in the file, returns 0.\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\nextern int stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts);\nextern int stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int num_samples);\n#endif\n// gets num_samples samples, not necessarily on a frame boundary--this requires\n// buffering so you have to supply the buffers. Applies the coercion rules above\n// to produce 'channels' channels. Returns the number of samples stored per channel;\n// it may be less than requested at the end of the file. If there are no more\n// samples in the file, returns 0.\n\n#endif\n\n////////   ERROR CODES\n\nenum STBVorbisError\n{\n   VORBIS__no_error,\n\n   VORBIS_need_more_data=1,             // not a real error\n\n   VORBIS_invalid_api_mixing,           // can't mix API modes\n   VORBIS_outofmem,                     // not enough memory\n   VORBIS_feature_not_supported,        // uses floor 0\n   VORBIS_too_many_channels,            // STB_VORBIS_MAX_CHANNELS is too small\n   VORBIS_file_open_failure,            // fopen() failed\n   VORBIS_seek_without_length,          // can't seek in unknown-length file\n\n   VORBIS_unexpected_eof=10,            // file is truncated?\n   VORBIS_seek_invalid,                 // seek past EOF\n\n   // decoding errors (corrupt/invalid stream) -- you probably\n   // don't care about the exact details of these\n\n   // vorbis errors:\n   VORBIS_invalid_setup=20,\n   VORBIS_invalid_stream,\n\n   // ogg errors:\n   VORBIS_missing_capture_pattern=30,\n   VORBIS_invalid_stream_structure_version,\n   VORBIS_continued_packet_flag_invalid,\n   VORBIS_incorrect_stream_serial_number,\n   VORBIS_invalid_first_page,\n   VORBIS_bad_packet_type,\n   VORBIS_cant_find_last_page,\n   VORBIS_seek_failed,\n   VORBIS_ogg_skeleton_not_supported\n};\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H\n//\n//  HEADER ENDS HERE\n//\n//////////////////////////////////////////////////////////////////////////////\n\n#ifndef STB_VORBIS_HEADER_ONLY\n\n// global configuration settings (e.g. set these in the project/makefile),\n// or just set them in this file at the top (although ideally the first few\n// should be visible when the header file is compiled too, although it's not\n// crucial)\n\n// STB_VORBIS_NO_PUSHDATA_API\n//     does not compile the code for the various stb_vorbis_*_pushdata()\n//     functions\n// #define STB_VORBIS_NO_PUSHDATA_API\n\n// STB_VORBIS_NO_PULLDATA_API\n//     does not compile the code for the non-pushdata APIs\n// #define STB_VORBIS_NO_PULLDATA_API\n\n// STB_VORBIS_NO_STDIO\n//     does not compile the code for the APIs that use FILE *s internally\n//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_STDIO\n\n// STB_VORBIS_NO_INTEGER_CONVERSION\n//     does not compile the code for converting audio sample data from\n//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)\n// #define STB_VORBIS_NO_INTEGER_CONVERSION\n\n// STB_VORBIS_NO_FAST_SCALED_FLOAT\n//      does not use a fast float-to-int trick to accelerate float-to-int on\n//      most platforms which requires endianness be defined correctly.\n//#define STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n\n// STB_VORBIS_MAX_CHANNELS [number]\n//     globally define this to the maximum number of channels you need.\n//     The spec does not put a restriction on channels except that\n//     the count is stored in a byte, so 255 is the hard limit.\n//     Reducing this saves about 16 bytes per value, so using 16 saves\n//     (255-16)*16 or around 4KB. Plus anything other memory usage\n//     I forgot to account for. Can probably go as low as 8 (7.1 audio),\n//     6 (5.1 audio), or 2 (stereo only).\n#ifndef STB_VORBIS_MAX_CHANNELS\n#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?\n#endif\n\n// STB_VORBIS_PUSHDATA_CRC_COUNT [number]\n//     after a flush_pushdata(), stb_vorbis begins scanning for the\n//     next valid page, without backtracking. when it finds something\n//     that looks like a page, it streams through it and verifies its\n//     CRC32. Should that validation fail, it keeps scanning. But it's\n//     possible that _while_ streaming through to check the CRC32 of\n//     one candidate page, it sees another candidate page. This #define\n//     determines how many \"overlapping\" candidate pages it can search\n//     at once. Note that \"real\" pages are typically ~4KB to ~8KB, whereas\n//     garbage pages could be as big as 64KB, but probably average ~16KB.\n//     So don't hose ourselves by scanning an apparent 64KB page and\n//     missing a ton of real ones in the interim; so minimum of 2\n#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT\n#define STB_VORBIS_PUSHDATA_CRC_COUNT  4\n#endif\n\n// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]\n//     sets the log size of the huffman-acceleration table.  Maximum\n//     supported value is 24. with larger numbers, more decodings are O(1),\n//     but the table size is larger so worse cache missing, so you'll have\n//     to probe (and try multiple ogg vorbis files) to find the sweet spot.\n#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH\n#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10\n#endif\n\n// STB_VORBIS_FAST_BINARY_LENGTH [number]\n//     sets the log size of the binary-search acceleration table. this\n//     is used in similar fashion to the fast-huffman size to set initial\n//     parameters for the binary search\n\n// STB_VORBIS_FAST_HUFFMAN_INT\n//     The fast huffman tables are much more efficient if they can be\n//     stored as 16-bit results instead of 32-bit results. This restricts\n//     the codebooks to having only 65535 possible outcomes, though.\n//     (At least, accelerated by the huffman table.)\n#ifndef STB_VORBIS_FAST_HUFFMAN_INT\n#define STB_VORBIS_FAST_HUFFMAN_SHORT\n#endif\n\n// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n//     If the 'fast huffman' search doesn't succeed, then stb_vorbis falls\n//     back on binary searching for the correct one. This requires storing\n//     extra tables with the huffman codes in sorted order. Defining this\n//     symbol trades off space for speed by forcing a linear search in the\n//     non-fast case, except for \"sparse\" codebooks.\n// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n\n// STB_VORBIS_DIVIDES_IN_RESIDUE\n//     stb_vorbis precomputes the result of the scalar residue decoding\n//     that would otherwise require a divide per chunk. you can trade off\n//     space for time by defining this symbol.\n// #define STB_VORBIS_DIVIDES_IN_RESIDUE\n\n// STB_VORBIS_DIVIDES_IN_CODEBOOK\n//     vorbis VQ codebooks can be encoded two ways: with every case explicitly\n//     stored, or with all elements being chosen from a small range of values,\n//     and all values possible in all elements. By default, stb_vorbis expands\n//     this latter kind out to look like the former kind for ease of decoding,\n//     because otherwise an integer divide-per-vector-element is required to\n//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can\n//     trade off storage for speed.\n//#define STB_VORBIS_DIVIDES_IN_CODEBOOK\n\n#ifdef STB_VORBIS_CODEBOOK_SHORTS\n#error \"STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats\"\n#endif\n\n// STB_VORBIS_DIVIDE_TABLE\n//     this replaces small integer divides in the floor decode loop with\n//     table lookups. made less than 1% difference, so disabled by default.\n\n// STB_VORBIS_NO_INLINE_DECODE\n//     disables the inlining of the scalar codebook fast-huffman decode.\n//     might save a little codespace; useful for debugging\n// #define STB_VORBIS_NO_INLINE_DECODE\n\n// STB_VORBIS_NO_DEFER_FLOOR\n//     Normally we only decode the floor without synthesizing the actual\n//     full curve. We can instead synthesize the curve immediately. This\n//     requires more memory and is very likely slower, so I don't think\n//     you'd ever want to do it except for debugging.\n// #define STB_VORBIS_NO_DEFER_FLOOR\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n#ifdef STB_VORBIS_NO_PULLDATA_API\n   #define STB_VORBIS_NO_INTEGER_CONVERSION\n   #define STB_VORBIS_NO_STDIO\n#endif\n\n#if defined(STB_VORBIS_NO_CRT) && !defined(STB_VORBIS_NO_STDIO)\n   #define STB_VORBIS_NO_STDIO 1\n#endif\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n\n   // only need endianness for fast-float-to-int, which we don't\n   // use for pushdata\n\n   #ifndef STB_VORBIS_BIG_ENDIAN\n     #define STB_VORBIS_ENDIAN  0\n   #else\n     #define STB_VORBIS_ENDIAN  1\n   #endif\n\n#endif\n#endif\n\n\n#ifndef STB_VORBIS_NO_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef STB_VORBIS_NO_CRT\n   #include <stdlib.h>\n   #include <string.h>\n   #include <assert.h>\n   #include <math.h>\n\n   // find definition of alloca if it's not in stdlib.h:\n   #if defined(_MSC_VER) || defined(__MINGW32__)\n      #include <malloc.h>\n   #endif\n   #if defined(__linux__) || defined(__linux) || defined(__sun__) || defined(__EMSCRIPTEN__) || defined(__NEWLIB__)\n      #include <alloca.h>\n   #endif\n#else // STB_VORBIS_NO_CRT\n   #define NULL 0\n   #define malloc(s)   0\n   #define free(s)     ((void) 0)\n   #define realloc(s)  0\n#endif // STB_VORBIS_NO_CRT\n\n#include <limits.h>\n\n#ifdef __MINGW32__\n   // eff you mingw:\n   //     \"fixed\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/\n   //     \"no that broke the build, reverted, who cares about C\":\n   //         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/\n   #ifdef __forceinline\n   #undef __forceinline\n   #endif\n   #define __forceinline\n   #ifndef alloca\n   #define alloca __builtin_alloca\n   #endif\n#elif !defined(_MSC_VER)\n   #if __GNUC__\n      #define __forceinline inline\n   #else\n      #define __forceinline\n   #endif\n#endif\n\n#if STB_VORBIS_MAX_CHANNELS > 256\n#error \"Value of STB_VORBIS_MAX_CHANNELS outside of allowed range\"\n#endif\n\n#if STB_VORBIS_FAST_HUFFMAN_LENGTH > 24\n#error \"Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range\"\n#endif\n\n\n#if 0\n#include <crtdbg.h>\n#define CHECK(f)   _CrtIsValidHeapPointer(f->channel_buffers[1])\n#else\n#define CHECK(f)   ((void) 0)\n#endif\n\n#define MAX_BLOCKSIZE_LOG  13   // from specification\n#define MAX_BLOCKSIZE      (1 << MAX_BLOCKSIZE_LOG)\n\n\ntypedef unsigned char  uint8;\ntypedef   signed char   int8;\ntypedef unsigned short uint16;\ntypedef   signed short  int16;\ntypedef unsigned int   uint32;\ntypedef   signed int    int32;\n\n#ifndef TRUE\n#define TRUE 1\n#define FALSE 0\n#endif\n\ntypedef float codetype;\n\n#ifdef _MSC_VER\n#define STBV_NOTUSED(v)  (void)(v)\n#else\n#define STBV_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n// @NOTE\n//\n// Some arrays below are tagged \"//varies\", which means it's actually\n// a variable-sized piece of data, but rather than malloc I assume it's\n// small enough it's better to just allocate it all together with the\n// main thing\n//\n// Most of the variables are specified with the smallest size I could pack\n// them into. It might give better performance to make them all full-sized\n// integers. It should be safe to freely rearrange the structures or change\n// the sizes larger--nothing relies on silently truncating etc., nor the\n// order of variables.\n\n#define FAST_HUFFMAN_TABLE_SIZE   (1 << STB_VORBIS_FAST_HUFFMAN_LENGTH)\n#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)\n\ntypedef struct\n{\n   int dimensions, entries;\n   uint8 *codeword_lengths;\n   float  minimum_value;\n   float  delta_value;\n   uint8  value_bits;\n   uint8  lookup_type;\n   uint8  sequence_p;\n   uint8  sparse;\n   uint32 lookup_values;\n   codetype *multiplicands;\n   uint32 *codewords;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #else\n    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];\n   #endif\n   uint32 *sorted_codewords;\n   int    *sorted_values;\n   int     sorted_entries;\n} Codebook;\n\ntypedef struct\n{\n   uint8 order;\n   uint16 rate;\n   uint16 bark_map_size;\n   uint8 amplitude_bits;\n   uint8 amplitude_offset;\n   uint8 number_of_books;\n   uint8 book_list[16]; // varies\n} Floor0;\n\ntypedef struct\n{\n   uint8 partitions;\n   uint8 partition_class_list[32]; // varies\n   uint8 class_dimensions[16]; // varies\n   uint8 class_subclasses[16]; // varies\n   uint8 class_masterbooks[16]; // varies\n   int16 subclass_books[16][8]; // varies\n   uint16 Xlist[31*8+2]; // varies\n   uint8 sorted_order[31*8+2];\n   uint8 neighbors[31*8+2][2];\n   uint8 floor1_multiplier;\n   uint8 rangebits;\n   int values;\n} Floor1;\n\ntypedef union\n{\n   Floor0 floor0;\n   Floor1 floor1;\n} Floor;\n\ntypedef struct\n{\n   uint32 begin, end;\n   uint32 part_size;\n   uint8 classifications;\n   uint8 classbook;\n   uint8 **classdata;\n   int16 (*residue_books)[8];\n} Residue;\n\ntypedef struct\n{\n   uint8 magnitude;\n   uint8 angle;\n   uint8 mux;\n} MappingChannel;\n\ntypedef struct\n{\n   uint16 coupling_steps;\n   MappingChannel *chan;\n   uint8  submaps;\n   uint8  submap_floor[15]; // varies\n   uint8  submap_residue[15]; // varies\n} Mapping;\n\ntypedef struct\n{\n   uint8 blockflag;\n   uint8 mapping;\n   uint16 windowtype;\n   uint16 transformtype;\n} Mode;\n\ntypedef struct\n{\n   uint32  goal_crc;    // expected crc if match\n   int     bytes_left;  // bytes left in packet\n   uint32  crc_so_far;  // running crc\n   int     bytes_done;  // bytes processed in _current_ chunk\n   uint32  sample_loc;  // granule pos encoded in page\n} CRCscan;\n\ntypedef struct\n{\n   uint32 page_start, page_end;\n   uint32 last_decoded_sample;\n} ProbedPage;\n\nstruct stb_vorbis\n{\n  // user-accessible info\n   unsigned int sample_rate;\n   int channels;\n\n   unsigned int setup_memory_required;\n   unsigned int temp_memory_required;\n   unsigned int setup_temp_memory_required;\n\n   char *vendor;\n   int comment_list_length;\n   char **comment_list;\n\n  // input config\n#ifndef STB_VORBIS_NO_STDIO\n   FILE *f;\n   uint32 f_start;\n   int close_on_free;\n#endif\n\n   uint8 *stream;\n   uint8 *stream_start;\n   uint8 *stream_end;\n\n   uint32 stream_len;\n\n   uint8  push_mode;\n\n   // the page to seek to when seeking to start, may be zero\n   uint32 first_audio_page_offset;\n\n   // p_first is the page on which the first audio packet ends\n   // (but not necessarily the page on which it starts)\n   ProbedPage p_first, p_last;\n\n  // memory management\n   stb_vorbis_alloc alloc;\n   int setup_offset;\n   int temp_offset;\n\n  // run-time results\n   int eof;\n   enum STBVorbisError error;\n\n  // user-useful data\n\n  // header info\n   int blocksize[2];\n   int blocksize_0, blocksize_1;\n   int codebook_count;\n   Codebook *codebooks;\n   int floor_count;\n   uint16 floor_types[64]; // varies\n   Floor *floor_config;\n   int residue_count;\n   uint16 residue_types[64]; // varies\n   Residue *residue_config;\n   int mapping_count;\n   Mapping *mapping;\n   int mode_count;\n   Mode mode_config[64];  // varies\n\n   uint32 total_samples;\n\n  // decode buffer\n   float *channel_buffers[STB_VORBIS_MAX_CHANNELS];\n   float *outputs        [STB_VORBIS_MAX_CHANNELS];\n\n   float *previous_window[STB_VORBIS_MAX_CHANNELS];\n   int previous_length;\n\n   #ifndef STB_VORBIS_NO_DEFER_FLOOR\n   int16 *finalY[STB_VORBIS_MAX_CHANNELS];\n   #else\n   float *floor_buffers[STB_VORBIS_MAX_CHANNELS];\n   #endif\n\n   uint32 current_loc; // sample location of next frame to decode\n   int    current_loc_valid;\n\n  // per-blocksize precomputed data\n\n   // twiddle factors\n   float *A[2],*B[2],*C[2];\n   float *window[2];\n   uint16 *bit_reverse[2];\n\n  // current page/packet/segment streaming info\n   uint32 serial; // stream serial number for verification\n   int last_page;\n   int segment_count;\n   uint8 segments[255];\n   uint8 page_flag;\n   uint8 bytes_in_seg;\n   uint8 first_decode;\n   int next_seg;\n   int last_seg;  // flag that we're on the last segment\n   int last_seg_which; // what was the segment number of the last seg?\n   uint32 acc;\n   int valid_bits;\n   int packet_bytes;\n   int end_seg_with_known_loc;\n   uint32 known_loc_for_packet;\n   int discard_samples_deferred;\n   uint32 samples_output;\n\n  // push mode scanning\n   int page_crc_tests; // only in push_mode: number of tests active; -1 if not searching\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n   CRCscan scan[STB_VORBIS_PUSHDATA_CRC_COUNT];\n#endif\n\n  // sample-access\n   int channel_buffer_start;\n   int channel_buffer_end;\n};\n\n#if defined(STB_VORBIS_NO_PUSHDATA_API)\n   #define IS_PUSH_MODE(f)   FALSE\n#elif defined(STB_VORBIS_NO_PULLDATA_API)\n   #define IS_PUSH_MODE(f)   TRUE\n#else\n   #define IS_PUSH_MODE(f)   ((f)->push_mode)\n#endif\n\ntypedef struct stb_vorbis vorb;\n\nstatic int error(vorb *f, enum STBVorbisError e)\n{\n   f->error = e;\n   if (!f->eof && e != VORBIS_need_more_data) {\n      f->error=e; // breakpoint for debugging\n   }\n   return 0;\n}\n\n\n// these functions are used for allocating temporary memory\n// while decoding. if you can afford the stack space, use\n// alloca(); otherwise, provide a temp buffer and it will\n// allocate out of those.\n\n#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))\n\n#define temp_alloc(f,size)              (f->alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))\n#define temp_free(f,p)                  (void)0\n#define temp_alloc_save(f)              ((f)->temp_offset)\n#define temp_alloc_restore(f,p)         ((f)->temp_offset = (p))\n\n#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)\n\n// given a sufficiently large block of memory, make an array of pointers to subblocks of it\nstatic void *make_block_array(void *mem, int count, int size)\n{\n   int i;\n   void ** p = (void **) mem;\n   char *q = (char *) (p + count);\n   for (i=0; i < count; ++i) {\n      p[i] = q;\n      q += size;\n   }\n   return p;\n}\n\nstatic void *setup_malloc(vorb *f, int sz)\n{\n   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.\n   f->setup_memory_required += sz;\n   if (f->alloc.alloc_buffer) {\n      void *p = (char *) f->alloc.alloc_buffer + f->setup_offset;\n      if (f->setup_offset + sz > f->temp_offset) return NULL;\n      f->setup_offset += sz;\n      return p;\n   }\n   return sz ? malloc(sz) : NULL;\n}\n\nstatic void setup_free(vorb *f, void *p)\n{\n   if (f->alloc.alloc_buffer) return; // do nothing; setup mem is a stack\n   free(p);\n}\n\nstatic void *setup_temp_malloc(vorb *f, int sz)\n{\n   sz = (sz+7) & ~7; // round up to nearest 8 for alignment of future allocs.\n   if (f->alloc.alloc_buffer) {\n      if (f->temp_offset - sz < f->setup_offset) return NULL;\n      f->temp_offset -= sz;\n      return (char *) f->alloc.alloc_buffer + f->temp_offset;\n   }\n   return malloc(sz);\n}\n\nstatic void setup_temp_free(vorb *f, void *p, int sz)\n{\n   if (f->alloc.alloc_buffer) {\n      f->temp_offset += (sz+7)&~7;\n      return;\n   }\n   free(p);\n}\n\n#define CRC32_POLY    0x04c11db7   // from spec\n\nstatic uint32 crc_table[256];\nstatic void crc32_init(void)\n{\n   int i,j;\n   uint32 s;\n   for(i=0; i < 256; i++) {\n      for (s=(uint32) i << 24, j=0; j < 8; ++j)\n         s = (s << 1) ^ (s >= (1U<<31) ? CRC32_POLY : 0);\n      crc_table[i] = s;\n   }\n}\n\nstatic __forceinline uint32 crc32_update(uint32 crc, uint8 byte)\n{\n   return (crc << 8) ^ crc_table[byte ^ (crc >> 24)];\n}\n\n\n// used in setup, and for huffman that doesn't go fast path\nstatic unsigned int bit_reverse(unsigned int n)\n{\n  n = ((n & 0xAAAAAAAA) >>  1) | ((n & 0x55555555) << 1);\n  n = ((n & 0xCCCCCCCC) >>  2) | ((n & 0x33333333) << 2);\n  n = ((n & 0xF0F0F0F0) >>  4) | ((n & 0x0F0F0F0F) << 4);\n  n = ((n & 0xFF00FF00) >>  8) | ((n & 0x00FF00FF) << 8);\n  return (n >> 16) | (n << 16);\n}\n\nstatic float square(float x)\n{\n   return x*x;\n}\n\n// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3\n// as required by the specification. fast(?) implementation from stb.h\n// @OPTIMIZE: called multiple times per-packet with \"constants\"; move to setup\nstatic int ilog(int32 n)\n{\n   static signed char log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };\n\n   if (n < 0) return 0; // signed n returns 0\n\n   // 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)\n   if (n < (1 << 14))\n        if (n < (1 <<  4))            return  0 + log2_4[n      ];\n        else if (n < (1 <<  9))       return  5 + log2_4[n >>  5];\n             else                     return 10 + log2_4[n >> 10];\n   else if (n < (1 << 24))\n             if (n < (1 << 19))       return 15 + log2_4[n >> 15];\n             else                     return 20 + log2_4[n >> 20];\n        else if (n < (1 << 29))       return 25 + log2_4[n >> 25];\n             else                     return 30 + log2_4[n >> 30];\n}\n\n#ifndef M_PI\n  #define M_PI  3.14159265358979323846264f  // from CRC\n#endif\n\n// code length assigned to a value with no huffman encoding\n#define NO_CODE   255\n\n/////////////////////// LEAF SETUP FUNCTIONS //////////////////////////\n//\n// these functions are only called at setup, and only a few times\n// per file\n\nstatic float float32_unpack(uint32 x)\n{\n   // from the specification\n   uint32 mantissa = x & 0x1fffff;\n   uint32 sign = x & 0x80000000;\n   uint32 exp = (x & 0x7fe00000) >> 21;\n   double res = sign ? -(double)mantissa : (double)mantissa;\n   return (float) ldexp((float)res, (int)exp-788);\n}\n\n\n// zlib & jpeg huffman tables assume that the output symbols\n// can either be arbitrarily arranged, or have monotonically\n// increasing frequencies--they rely on the lengths being sorted;\n// this makes for a very simple generation algorithm.\n// vorbis allows a huffman table with non-sorted lengths. This\n// requires a more sophisticated construction, since symbols in\n// order do not map to huffman codes \"in order\".\nstatic void add_entry(Codebook *c, uint32 huff_code, int symbol, int count, int len, uint32 *values)\n{\n   if (!c->sparse) {\n      c->codewords      [symbol] = huff_code;\n   } else {\n      c->codewords       [count] = huff_code;\n      c->codeword_lengths[count] = len;\n      values             [count] = symbol;\n   }\n}\n\nstatic int compute_codewords(Codebook *c, uint8 *len, int n, uint32 *values)\n{\n   int i,k,m=0;\n   uint32 available[32];\n\n   memset(available, 0, sizeof(available));\n   // find the first entry\n   for (k=0; k < n; ++k) if (len[k] < NO_CODE) break;\n   if (k == n) { assert(c->sorted_entries == 0); return TRUE; }\n   assert(len[k] < 32); // no error return required, code reading lens checks this\n   // add to the list\n   add_entry(c, 0, k, m++, len[k], values);\n   // add all available leaves\n   for (i=1; i <= len[k]; ++i)\n      available[i] = 1U << (32-i);\n   // note that the above code treats the first case specially,\n   // but it's really the same as the following code, so they\n   // could probably be combined (except the initial code is 0,\n   // and I use 0 in available[] to mean 'empty')\n   for (i=k+1; i < n; ++i) {\n      uint32 res;\n      int z = len[i], y;\n      if (z == NO_CODE) continue;\n      assert(z < 32); // no error return required, code reading lens checks this\n      // find lowest available leaf (should always be earliest,\n      // which is what the specification calls for)\n      // note that this property, and the fact we can never have\n      // more than one free leaf at a given level, isn't totally\n      // trivial to prove, but it seems true and the assert never\n      // fires, so!\n      while (z > 0 && !available[z]) --z;\n      if (z == 0) { return FALSE; }\n      res = available[z];\n      available[z] = 0;\n      add_entry(c, bit_reverse(res), i, m++, len[i], values);\n      // propagate availability up the tree\n      if (z != len[i]) {\n         for (y=len[i]; y > z; --y) {\n            assert(available[y] == 0);\n            available[y] = res + (1 << (32-y));\n         }\n      }\n   }\n   return TRUE;\n}\n\n// accelerated huffman table allows fast O(1) match of all symbols\n// of length <= STB_VORBIS_FAST_HUFFMAN_LENGTH\nstatic void compute_accelerated_huffman(Codebook *c)\n{\n   int i, len;\n   for (i=0; i < FAST_HUFFMAN_TABLE_SIZE; ++i)\n      c->fast_huffman[i] = -1;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT\n   if (len > 32767) len = 32767; // largest possible value we can encode!\n   #endif\n   for (i=0; i < len; ++i) {\n      if (c->codeword_lengths[i] <= STB_VORBIS_FAST_HUFFMAN_LENGTH) {\n         uint32 z = c->sparse ? bit_reverse(c->sorted_codewords[i]) : c->codewords[i];\n         // set table entries for all bit combinations in the higher bits\n         while (z < FAST_HUFFMAN_TABLE_SIZE) {\n             c->fast_huffman[z] = i;\n             z += 1 << c->codeword_lengths[i];\n         }\n      }\n   }\n}\n\n#ifdef _MSC_VER\n#define STBV_CDECL __cdecl\n#else\n#define STBV_CDECL\n#endif\n\nstatic int STBV_CDECL uint32_compare(const void *p, const void *q)\n{\n   uint32 x = * (uint32 *) p;\n   uint32 y = * (uint32 *) q;\n   return x < y ? -1 : x > y;\n}\n\nstatic int include_in_sort(Codebook *c, uint8 len)\n{\n   if (c->sparse) { assert(len != NO_CODE); return TRUE; }\n   if (len == NO_CODE) return FALSE;\n   if (len > STB_VORBIS_FAST_HUFFMAN_LENGTH) return TRUE;\n   return FALSE;\n}\n\n// if the fast table above doesn't work, we want to binary\n// search them... need to reverse the bits\nstatic void compute_sorted_huffman(Codebook *c, uint8 *lengths, uint32 *values)\n{\n   int i, len;\n   // build a list of all the entries\n   // OPTIMIZATION: don't include the short ones, since they'll be caught by FAST_HUFFMAN.\n   // this is kind of a frivolous optimization--I don't see any performance improvement,\n   // but it's like 4 extra lines of code, so.\n   if (!c->sparse) {\n      int k = 0;\n      for (i=0; i < c->entries; ++i)\n         if (include_in_sort(c, lengths[i]))\n            c->sorted_codewords[k++] = bit_reverse(c->codewords[i]);\n      assert(k == c->sorted_entries);\n   } else {\n      for (i=0; i < c->sorted_entries; ++i)\n         c->sorted_codewords[i] = bit_reverse(c->codewords[i]);\n   }\n\n   qsort(c->sorted_codewords, c->sorted_entries, sizeof(c->sorted_codewords[0]), uint32_compare);\n   c->sorted_codewords[c->sorted_entries] = 0xffffffff;\n\n   len = c->sparse ? c->sorted_entries : c->entries;\n   // now we need to indicate how they correspond; we could either\n   //   #1: sort a different data structure that says who they correspond to\n   //   #2: for each sorted entry, search the original list to find who corresponds\n   //   #3: for each original entry, find the sorted entry\n   // #1 requires extra storage, #2 is slow, #3 can use binary search!\n   for (i=0; i < len; ++i) {\n      int huff_len = c->sparse ? lengths[values[i]] : lengths[i];\n      if (include_in_sort(c,huff_len)) {\n         uint32 code = bit_reverse(c->codewords[i]);\n         int x=0, n=c->sorted_entries;\n         while (n > 1) {\n            // invariant: sc[x] <= code < sc[x+n]\n            int m = x + (n >> 1);\n            if (c->sorted_codewords[m] <= code) {\n               x = m;\n               n -= (n>>1);\n            } else {\n               n >>= 1;\n            }\n         }\n         assert(c->sorted_codewords[x] == code);\n         if (c->sparse) {\n            c->sorted_values[x] = values[i];\n            c->codeword_lengths[x] = huff_len;\n         } else {\n            c->sorted_values[x] = i;\n         }\n      }\n   }\n}\n\n// only run while parsing the header (3 times)\nstatic int vorbis_validate(uint8 *data)\n{\n   static uint8 vorbis[6] = { 'v', 'o', 'r', 'b', 'i', 's' };\n   return memcmp(data, vorbis, 6) == 0;\n}\n\n// called from setup only, once per code book\n// (formula implied by specification)\nstatic int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}\n\n// called twice per file\nstatic void compute_twiddle_factors(int n, float *A, float *B, float *C)\n{\n   int n4 = n >> 2, n8 = n >> 3;\n   int k,k2;\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2) * 0.5f;\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2) * 0.5f;\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n}\n\nstatic void compute_window(int n, float *window)\n{\n   int n2 = n >> 1, i;\n   for (i=0; i < n2; ++i)\n      window[i] = (float) sin(0.5 * M_PI * square((float) sin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));\n}\n\nstatic void compute_bitreverse(int n, uint16 *rev)\n{\n   int ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   int i, n8 = n >> 3;\n   for (i=0; i < n8; ++i)\n      rev[i] = (bit_reverse(i) >> (32-ld+3)) << 2;\n}\n\nstatic int init_blocksize(vorb *f, int b, int n)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;\n   f->A[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->B[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   f->C[b] = (float *) setup_malloc(f, sizeof(float) * n4);\n   if (!f->A[b] || !f->B[b] || !f->C[b]) return error(f, VORBIS_outofmem);\n   compute_twiddle_factors(n, f->A[b], f->B[b], f->C[b]);\n   f->window[b] = (float *) setup_malloc(f, sizeof(float) * n2);\n   if (!f->window[b]) return error(f, VORBIS_outofmem);\n   compute_window(n, f->window[b]);\n   f->bit_reverse[b] = (uint16 *) setup_malloc(f, sizeof(uint16) * n8);\n   if (!f->bit_reverse[b]) return error(f, VORBIS_outofmem);\n   compute_bitreverse(n, f->bit_reverse[b]);\n   return TRUE;\n}\n\nstatic void neighbors(uint16 *x, int n, int *plow, int *phigh)\n{\n   int low = -1;\n   int high = 65536;\n   int i;\n   for (i=0; i < n; ++i) {\n      if (x[i] > low  && x[i] < x[n]) { *plow  = i; low = x[i]; }\n      if (x[i] < high && x[i] > x[n]) { *phigh = i; high = x[i]; }\n   }\n}\n\n// this has been repurposed so y is now the original index instead of y\ntypedef struct\n{\n   uint16 x,id;\n} stbv__floor_ordering;\n\nstatic int STBV_CDECL point_compare(const void *p, const void *q)\n{\n   stbv__floor_ordering *a = (stbv__floor_ordering *) p;\n   stbv__floor_ordering *b = (stbv__floor_ordering *) q;\n   return a->x < b->x ? -1 : a->x > b->x;\n}\n\n//\n/////////////////////// END LEAF SETUP FUNCTIONS //////////////////////////\n\n\n#if defined(STB_VORBIS_NO_STDIO)\n   #define USE_MEMORY(z)    TRUE\n#else\n   #define USE_MEMORY(z)    ((z)->stream)\n#endif\n\nstatic uint8 get8(vorb *z)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream >= z->stream_end) { z->eof = TRUE; return 0; }\n      return *z->stream++;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n   int c = fgetc(z->f);\n   if (c == EOF) { z->eof = TRUE; return 0; }\n   return c;\n   }\n   #endif\n}\n\nstatic uint32 get32(vorb *f)\n{\n   uint32 x;\n   x = get8(f);\n   x += get8(f) << 8;\n   x += get8(f) << 16;\n   x += (uint32) get8(f) << 24;\n   return x;\n}\n\nstatic int getn(vorb *z, uint8 *data, int n)\n{\n   if (USE_MEMORY(z)) {\n      if (z->stream+n > z->stream_end) { z->eof = 1; return 0; }\n      memcpy(data, z->stream, n);\n      z->stream += n;\n      return 1;\n   }\n\n   #ifndef STB_VORBIS_NO_STDIO\n   if (fread(data, n, 1, z->f) == 1)\n      return 1;\n   else {\n      z->eof = 1;\n      return 0;\n   }\n   #endif\n}\n\nstatic void skip(vorb *z, int n)\n{\n   if (USE_MEMORY(z)) {\n      z->stream += n;\n      if (z->stream >= z->stream_end) z->eof = 1;\n      return;\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   {\n      long x = ftell(z->f);\n      fseek(z->f, x+n, SEEK_SET);\n   }\n   #endif\n}\n\nstatic int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n\n\nstatic uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };\n\nstatic int capture_pattern(vorb *f)\n{\n   if (0x4f != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x67 != get8(f)) return FALSE;\n   if (0x53 != get8(f)) return FALSE;\n   return TRUE;\n}\n\n#define PAGEFLAG_continued_packet   1\n#define PAGEFLAG_first_page         2\n#define PAGEFLAG_last_page          4\n\nstatic int start_page_no_capturepattern(vorb *f)\n{\n   uint32 loc0,loc1,n;\n   if (f->first_decode && !IS_PUSH_MODE(f)) {\n      f->p_first.page_start = stb_vorbis_get_file_offset(f) - 4;\n   }\n   // stream structure version\n   if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n   // header flag\n   f->page_flag = get8(f);\n   // absolute granule position\n   loc0 = get32(f);\n   loc1 = get32(f);\n   // @TODO: validate loc0,loc1 as valid positions?\n   // stream serial number -- vorbis doesn't interleave, so discard\n   get32(f);\n   //if (f->serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);\n   // page sequence number\n   n = get32(f);\n   f->last_page = n;\n   // CRC32\n   get32(f);\n   // page_segments\n   f->segment_count = get8(f);\n   if (!getn(f, f->segments, f->segment_count))\n      return error(f, VORBIS_unexpected_eof);\n   // assume we _don't_ know any the sample position of any segments\n   f->end_seg_with_known_loc = -2;\n   if (loc0 != ~0U || loc1 != ~0U) {\n      int i;\n      // determine which packet is the last one that will complete\n      for (i=f->segment_count-1; i >= 0; --i)\n         if (f->segments[i] < 255)\n            break;\n      // 'i' is now the index of the _last_ segment of a packet that ends\n      if (i >= 0) {\n         f->end_seg_with_known_loc = i;\n         f->known_loc_for_packet   = loc0;\n      }\n   }\n   if (f->first_decode) {\n      int i,len;\n      len = 0;\n      for (i=0; i < f->segment_count; ++i)\n         len += f->segments[i];\n      len += 27 + f->segment_count;\n      f->p_first.page_end = f->p_first.page_start + len;\n      f->p_first.last_decoded_sample = loc0;\n   }\n   f->next_seg = 0;\n   return TRUE;\n}\n\nstatic int start_page(vorb *f)\n{\n   if (!capture_pattern(f)) return error(f, VORBIS_missing_capture_pattern);\n   return start_page_no_capturepattern(f);\n}\n\nstatic int start_packet(vorb *f)\n{\n   while (f->next_seg == -1) {\n      if (!start_page(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet)\n         return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   // f->next_seg is now valid\n   return TRUE;\n}\n\nstatic int maybe_start_packet(vorb *f)\n{\n   if (f->next_seg == -1) {\n      int x = get8(f);\n      if (f->eof) return FALSE; // EOF at page boundary is not an error!\n      if (0x4f != x      ) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x67 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (0x53 != get8(f)) return error(f, VORBIS_missing_capture_pattern);\n      if (!start_page_no_capturepattern(f)) return FALSE;\n      if (f->page_flag & PAGEFLAG_continued_packet) {\n         // set up enough state that we can read this packet if we want,\n         // e.g. during recovery\n         f->last_seg = FALSE;\n         f->bytes_in_seg = 0;\n         return error(f, VORBIS_continued_packet_flag_invalid);\n      }\n   }\n   return start_packet(f);\n}\n\nstatic int next_segment(vorb *f)\n{\n   int len;\n   if (f->last_seg) return 0;\n   if (f->next_seg == -1) {\n      f->last_seg_which = f->segment_count-1; // in case start_page fails\n      if (!start_page(f)) { f->last_seg = 1; return 0; }\n      if (!(f->page_flag & PAGEFLAG_continued_packet)) return error(f, VORBIS_continued_packet_flag_invalid);\n   }\n   len = f->segments[f->next_seg++];\n   if (len < 255) {\n      f->last_seg = TRUE;\n      f->last_seg_which = f->next_seg-1;\n   }\n   if (f->next_seg >= f->segment_count)\n      f->next_seg = -1;\n   assert(f->bytes_in_seg == 0);\n   f->bytes_in_seg = len;\n   return len;\n}\n\n#define EOP    (-1)\n#define INVALID_BITS  (-1)\n\nstatic int get8_packet_raw(vorb *f)\n{\n   if (!f->bytes_in_seg) {  // CLANG!\n      if (f->last_seg) return EOP;\n      else if (!next_segment(f)) return EOP;\n   }\n   assert(f->bytes_in_seg > 0);\n   --f->bytes_in_seg;\n   ++f->packet_bytes;\n   return get8(f);\n}\n\nstatic int get8_packet(vorb *f)\n{\n   int x = get8_packet_raw(f);\n   f->valid_bits = 0;\n   return x;\n}\n\nstatic int get32_packet(vorb *f)\n{\n   uint32 x;\n   x = get8_packet(f);\n   x += get8_packet(f) << 8;\n   x += get8_packet(f) << 16;\n   x += (uint32) get8_packet(f) << 24;\n   return x;\n}\n\nstatic void flush_packet(vorb *f)\n{\n   while (get8_packet_raw(f) != EOP);\n}\n\n// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important\n// as the huffman decoder?\nstatic uint32 get_bits(vorb *f, int n)\n{\n   uint32 z;\n\n   if (f->valid_bits < 0) return 0;\n   if (f->valid_bits < n) {\n      if (n > 24) {\n         // the accumulator technique below would not work correctly in this case\n         z = get_bits(f, 24);\n         z += get_bits(f, n-24) << 24;\n         return z;\n      }\n      if (f->valid_bits == 0) f->acc = 0;\n      while (f->valid_bits < n) {\n         int z = get8_packet_raw(f);\n         if (z == EOP) {\n            f->valid_bits = INVALID_BITS;\n            return 0;\n         }\n         f->acc += z << f->valid_bits;\n         f->valid_bits += 8;\n      }\n   }\n\n   assert(f->valid_bits >= n);\n   z = f->acc & ((1 << n)-1);\n   f->acc >>= n;\n   f->valid_bits -= n;\n   return z;\n}\n\n// @OPTIMIZE: primary accumulator for huffman\n// expand the buffer to as many bits as possible without reading off end of packet\n// it might be nice to allow f->valid_bits and f->acc to be stored in registers,\n// e.g. cache them locally and decode locally\nstatic __forceinline void prep_huffman(vorb *f)\n{\n   if (f->valid_bits <= 24) {\n      if (f->valid_bits == 0) f->acc = 0;\n      do {\n         int z;\n         if (f->last_seg && !f->bytes_in_seg) return;\n         z = get8_packet_raw(f);\n         if (z == EOP) return;\n         f->acc += (unsigned) z << f->valid_bits;\n         f->valid_bits += 8;\n      } while (f->valid_bits <= 24);\n   }\n}\n\nenum\n{\n   VORBIS_packet_id = 1,\n   VORBIS_packet_comment = 3,\n   VORBIS_packet_setup = 5\n};\n\nstatic int codebook_decode_scalar_raw(vorb *f, Codebook *c)\n{\n   int i;\n   prep_huffman(f);\n\n   if (c->codewords == NULL && c->sorted_codewords == NULL)\n      return -1;\n\n   // cases to use binary search: sorted_codewords && !c->codewords\n   //                             sorted_codewords && c->entries > 8\n   if (c->entries > 8 ? c->sorted_codewords!=NULL : !c->codewords) {\n      // binary search\n      uint32 code = bit_reverse(f->acc);\n      int x=0, n=c->sorted_entries, len;\n\n      while (n > 1) {\n         // invariant: sc[x] <= code < sc[x+n]\n         int m = x + (n >> 1);\n         if (c->sorted_codewords[m] <= code) {\n            x = m;\n            n -= (n>>1);\n         } else {\n            n >>= 1;\n         }\n      }\n      // x is now the sorted index\n      if (!c->sparse) x = c->sorted_values[x];\n      // x is now sorted index if sparse, or symbol otherwise\n      len = c->codeword_lengths[x];\n      if (f->valid_bits >= len) {\n         f->acc >>= len;\n         f->valid_bits -= len;\n         return x;\n      }\n\n      f->valid_bits = 0;\n      return -1;\n   }\n\n   // if small, linear search\n   assert(!c->sparse);\n   for (i=0; i < c->entries; ++i) {\n      if (c->codeword_lengths[i] == NO_CODE) continue;\n      if (c->codewords[i] == (f->acc & ((1 << c->codeword_lengths[i])-1))) {\n         if (f->valid_bits >= c->codeword_lengths[i]) {\n            f->acc >>= c->codeword_lengths[i];\n            f->valid_bits -= c->codeword_lengths[i];\n            return i;\n         }\n         f->valid_bits = 0;\n         return -1;\n      }\n   }\n\n   error(f, VORBIS_invalid_stream);\n   f->valid_bits = 0;\n   return -1;\n}\n\n#ifndef STB_VORBIS_NO_INLINE_DECODE\n\n#define DECODE_RAW(var, f,c)                                  \\\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)        \\\n      prep_huffman(f);                                        \\\n   var = f->acc & FAST_HUFFMAN_TABLE_MASK;                    \\\n   var = c->fast_huffman[var];                                \\\n   if (var >= 0) {                                            \\\n      int n = c->codeword_lengths[var];                       \\\n      f->acc >>= n;                                           \\\n      f->valid_bits -= n;                                     \\\n      if (f->valid_bits < 0) { f->valid_bits = 0; var = -1; } \\\n   } else {                                                   \\\n      var = codebook_decode_scalar_raw(f,c);                  \\\n   }\n\n#else\n\nstatic int codebook_decode_scalar(vorb *f, Codebook *c)\n{\n   int i;\n   if (f->valid_bits < STB_VORBIS_FAST_HUFFMAN_LENGTH)\n      prep_huffman(f);\n   // fast huffman table lookup\n   i = f->acc & FAST_HUFFMAN_TABLE_MASK;\n   i = c->fast_huffman[i];\n   if (i >= 0) {\n      f->acc >>= c->codeword_lengths[i];\n      f->valid_bits -= c->codeword_lengths[i];\n      if (f->valid_bits < 0) { f->valid_bits = 0; return -1; }\n      return i;\n   }\n   return codebook_decode_scalar_raw(f,c);\n}\n\n#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);\n\n#endif\n\n#define DECODE(var,f,c)                                       \\\n   DECODE_RAW(var,f,c)                                        \\\n   if (c->sparse) var = c->sorted_values[var];\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n  #define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)\n#else\n  #define DECODE_VQ(var,f,c)   DECODE(var,f,c)\n#endif\n\n\n\n\n\n\n// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case\n// where we avoid one addition\n#define CODEBOOK_ELEMENT(c,off)          (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_FAST(c,off)     (c->multiplicands[off])\n#define CODEBOOK_ELEMENT_BASE(c)         (0)\n\nstatic int codebook_decode_start(vorb *f, Codebook *c)\n{\n   int z = -1;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)\n      error(f, VORBIS_invalid_stream);\n   else {\n      DECODE_VQ(z,f,c);\n      if (c->sparse) assert(z < c->sorted_entries);\n      if (z < 0) {  // check for EOP\n         if (!f->bytes_in_seg)\n            if (f->last_seg)\n               return z;\n         error(f, VORBIS_invalid_stream);\n      }\n   }\n   return z;\n}\n\nstatic int codebook_decode(vorb *f, Codebook *c, float *output, int len)\n{\n   int i,z = codebook_decode_start(f,c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i] += val;\n         if (c->sequence_p) last = val + c->minimum_value;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   if (c->sequence_p) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n         output[i] += val;\n         last = val + c->minimum_value;\n      }\n   } else {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      for (i=0; i < len; ++i) {\n         output[i] += CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      }\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_step(vorb *f, Codebook *c, float *output, int len, int step)\n{\n   int i,z = codebook_decode_start(f,c);\n   float last = CODEBOOK_ELEMENT_BASE(c);\n   if (z < 0) return FALSE;\n   if (len > c->dimensions) len = c->dimensions;\n\n#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n   if (c->lookup_type == 1) {\n      int div = 1;\n      for (i=0; i < len; ++i) {\n         int off = (z / div) % c->lookup_values;\n         float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n         output[i*step] += val;\n         if (c->sequence_p) last = val;\n         div *= c->lookup_values;\n      }\n      return TRUE;\n   }\n#endif\n\n   z *= c->dimensions;\n   for (i=0; i < len; ++i) {\n      float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n      output[i*step] += val;\n      if (c->sequence_p) last = val;\n   }\n\n   return TRUE;\n}\n\nstatic int codebook_decode_deinterleave_repeat(vorb *f, Codebook *c, float **outputs, int ch, int *c_inter_p, int *p_inter_p, int len, int total_decode)\n{\n   int c_inter = *c_inter_p;\n   int p_inter = *p_inter_p;\n   int i,z, effective = c->dimensions;\n\n   // type 0 is only legal in a scalar context\n   if (c->lookup_type == 0)   return error(f, VORBIS_invalid_stream);\n\n   while (total_decode > 0) {\n      float last = CODEBOOK_ELEMENT_BASE(c);\n      DECODE_VQ(z,f,c);\n      #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      assert(!c->sparse || z < c->sorted_entries);\n      #endif\n      if (z < 0) {\n         if (!f->bytes_in_seg)\n            if (f->last_seg) return FALSE;\n         return error(f, VORBIS_invalid_stream);\n      }\n\n      // if this will take us off the end of the buffers, stop short!\n      // we check by computing the length of the virtual interleaved\n      // buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),\n      // and the length we'll be using (effective)\n      if (c_inter + p_inter*ch + effective > len * ch) {\n         effective = len*ch - (p_inter*ch - c_inter);\n      }\n\n   #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n      if (c->lookup_type == 1) {\n         int div = 1;\n         for (i=0; i < effective; ++i) {\n            int off = (z / div) % c->lookup_values;\n            float val = CODEBOOK_ELEMENT_FAST(c,off) + last;\n            if (outputs[c_inter])\n               outputs[c_inter][p_inter] += val;\n            if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            if (c->sequence_p) last = val;\n            div *= c->lookup_values;\n         }\n      } else\n   #endif\n      {\n         z *= c->dimensions;\n         if (c->sequence_p) {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n               last = val;\n            }\n         } else {\n            for (i=0; i < effective; ++i) {\n               float val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;\n               if (outputs[c_inter])\n                  outputs[c_inter][p_inter] += val;\n               if (++c_inter == ch) { c_inter = 0; ++p_inter; }\n            }\n         }\n      }\n\n      total_decode -= effective;\n   }\n   *c_inter_p = c_inter;\n   *p_inter_p = p_inter;\n   return TRUE;\n}\n\nstatic int predict_point(int x, int x0, int x1, int y0, int y1)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   // @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?\n   int err = abs(dy) * (x - x0);\n   int off = err / adx;\n   return dy < 0 ? y0 - off : y0 + off;\n}\n\n// the following table is block-copied from the specification\nstatic float inverse_db_table[256] =\n{\n  1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f,\n  1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f,\n  1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f,\n  2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f,\n  2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f,\n  3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f,\n  4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f,\n  6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f,\n  7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f,\n  1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f,\n  1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f,\n  1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f,\n  2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f,\n  2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f,\n  3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f,\n  4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f,\n  5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f,\n  7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f,\n  9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f,\n  1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f,\n  1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f,\n  2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f,\n  2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f,\n  3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f,\n  4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f,\n  5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f,\n  7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f,\n  9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f,\n  0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f,\n  0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f,\n  0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f,\n  0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f,\n  0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f,\n  0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f,\n  0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f,\n  0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f,\n  0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f,\n  0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f,\n  0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f,\n  0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f,\n  0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f,\n  0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f,\n  0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f,\n  0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f,\n  0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f,\n  0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f,\n  0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f,\n  0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f,\n  0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f,\n  0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f,\n  0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f,\n  0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f,\n  0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f,\n  0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f,\n  0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f,\n  0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f,\n  0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f,\n  0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f,\n  0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f,\n  0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f,\n  0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f,\n  0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f,\n  0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f,\n  0.82788260f,    0.88168307f,    0.9389798f,     1.0f\n};\n\n\n// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,\n// note that you must produce bit-identical output to decode correctly;\n// this specific sequence of operations is specified in the spec (it's\n// drawing integer-quantized frequency-space lines that the encoder\n// expects to be exactly the same)\n//     ... also, isn't the whole point of Bresenham's algorithm to NOT\n// have to divide in the setup? sigh.\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n#define LINE_OP(a,b)   a *= b\n#else\n#define LINE_OP(a,b)   a = b\n#endif\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n#define DIVTAB_NUMER   32\n#define DIVTAB_DENOM   64\nint8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; // 2KB\n#endif\n\nstatic __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n   ady -= abs(base) * adx;\n   if (x1 > n) x1 = n;\n   if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y&255]);\n      for (++x; x < x1; ++x) {\n         err += ady;\n         if (err >= adx) {\n            err -= adx;\n            y += sy;\n         } else\n            y += base;\n         LINE_OP(output[x], inverse_db_table[y&255]);\n      }\n   }\n}\n\nstatic int residue_decode(vorb *f, Codebook *book, float *target, int offset, int n, int rtype)\n{\n   int k;\n   if (rtype == 0) {\n      int step = n / book->dimensions;\n      for (k=0; k < step; ++k)\n         if (!codebook_decode_step(f, book, target+offset+k, n-offset-k, step))\n            return FALSE;\n   } else {\n      for (k=0; k < n; ) {\n         if (!codebook_decode(f, book, target+offset, n-k))\n            return FALSE;\n         k += book->dimensions;\n         offset += book->dimensions;\n      }\n   }\n   return TRUE;\n}\n\n// n is 1/2 of the blocksize --\n// specification: \"Correct per-vector decode length is [n]/2\"\nstatic void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)\n{\n   int i,j,pass;\n   Residue *r = f->residue_config + rn;\n   int rtype = f->residue_types[rn];\n   int c = r->classbook;\n   int classwords = f->codebooks[c].dimensions;\n   unsigned int actual_size = rtype == 2 ? n*2 : n;\n   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);\n   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);\n   int n_read = limit_r_end - limit_r_begin;\n   int part_read = n_read / r->part_size;\n   int temp_alloc_point = temp_alloc_save(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata));\n   #else\n   int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications));\n   #endif\n\n   CHECK(f);\n\n   for (i=0; i < ch; ++i)\n      if (!do_not_decode[i])\n         memset(residue_buffers[i], 0, sizeof(float) * n);\n\n   if (rtype == 2 && ch != 1) {\n      for (j=0; j < ch; ++j)\n         if (!do_not_decode[j])\n            break;\n      if (j == ch)\n         goto done;\n\n      for (pass=0; pass < 8; ++pass) {\n         int pcount = 0, class_set = 0;\n         if (ch == 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = (z & 1), p_inter = z>>1;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #else\n                     // saves 1%\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                     #endif\n                  } else {\n                     z += r->part_size;\n                     c_inter = z & 1;\n                     p_inter = z >> 1;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         } else if (ch > 2) {\n            while (pcount < part_read) {\n               int z = r->begin + pcount*r->part_size;\n               int c_inter = z % ch, p_inter = z/ch;\n               if (pass == 0) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int q;\n                  DECODE(q,f,c);\n                  if (q == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[0][class_set] = r->classdata[q];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[0][i+pcount] = q % r->classifications;\n                     q /= r->classifications;\n                  }\n                  #endif\n               }\n               for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n                  int z = r->begin + pcount*r->part_size;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[0][class_set][i];\n                  #else\n                  int c = classifications[0][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     Codebook *book = f->codebooks + b;\n                     if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size))\n                        goto done;\n                  } else {\n                     z += r->part_size;\n                     c_inter = z % ch;\n                     p_inter = z / ch;\n                  }\n               }\n               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n               ++class_set;\n               #endif\n            }\n         }\n      }\n      goto done;\n   }\n   CHECK(f);\n\n   for (pass=0; pass < 8; ++pass) {\n      int pcount = 0, class_set=0;\n      while (pcount < part_read) {\n         if (pass == 0) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  Codebook *c = f->codebooks+r->classbook;\n                  int temp;\n                  DECODE(temp,f,c);\n                  if (temp == EOP) goto done;\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  part_classdata[j][class_set] = r->classdata[temp];\n                  #else\n                  for (i=classwords-1; i >= 0; --i) {\n                     classifications[j][i+pcount] = temp % r->classifications;\n                     temp /= r->classifications;\n                  }\n                  #endif\n               }\n            }\n         }\n         for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) {\n            for (j=0; j < ch; ++j) {\n               if (!do_not_decode[j]) {\n                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n                  int c = part_classdata[j][class_set][i];\n                  #else\n                  int c = classifications[j][pcount];\n                  #endif\n                  int b = r->residue_books[c][pass];\n                  if (b >= 0) {\n                     float *target = residue_buffers[j];\n                     int offset = r->begin + pcount * r->part_size;\n                     int n = r->part_size;\n                     Codebook *book = f->codebooks + b;\n                     if (!residue_decode(f, book, target, offset, n, rtype))\n                        goto done;\n                  }\n               }\n            }\n         }\n         #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n         ++class_set;\n         #endif\n      }\n   }\n  done:\n   CHECK(f);\n   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n   temp_free(f,part_classdata);\n   #else\n   temp_free(f,classifications);\n   #endif\n   temp_alloc_restore(f,temp_alloc_point);\n}\n\n\n#if 0\n// slow way for debugging\nvoid inverse_mdct_slow(float *buffer, int n)\n{\n   int i,j;\n   int n2 = n >> 1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         // formula from paper:\n         //acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n         // formula from wikipedia\n         //acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         // these are equivalent, except the formula from the paper inverts the multiplier!\n         // however, what actually works is NO MULTIPLIER!?!\n         //acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));\n         acc += x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// same as above, but just barely able to run in real time on modern machines\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   float mcos[16384];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 2) -1;\n   float *x = (float *) malloc(sizeof(*x) * n2);\n   memcpy(x, buffer, sizeof(*x) * n2);\n   for (i=0; i < 4*n; ++i)\n      mcos[i] = (float) cos(M_PI / 2 * i / n);\n\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n2; ++j)\n         acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) & nmask];\n      buffer[i] = acc;\n   }\n   free(x);\n}\n#elif 0\n// transform to use a slow dct-iv; this is STILL basically trivial,\n// but only requires half as many ops\nvoid dct_iv_slow(float *buffer, int n)\n{\n   float mcos[16384];\n   float x[2048];\n   int i,j;\n   int n2 = n >> 1, nmask = (n << 3) - 1;\n   memcpy(x, buffer, sizeof(*x) * n);\n   for (i=0; i < 8*n; ++i)\n      mcos[i] = (float) cos(M_PI / 4 * i / n);\n   for (i=0; i < n; ++i) {\n      float acc = 0;\n      for (j=0; j < n; ++j)\n         acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) & nmask];\n      buffer[i] = acc;\n   }\n}\n\nvoid inverse_mdct_slow(float *buffer, int n, vorb *f, int blocktype)\n{\n   int i, n4 = n >> 2, n2 = n >> 1, n3_4 = n - n4;\n   float temp[4096];\n\n   memcpy(temp, buffer, n2 * sizeof(float));\n   dct_iv_slow(temp, n2);  // returns -c'-d, a-b'\n\n   for (i=0; i < n4  ; ++i) buffer[i] = temp[i+n4];            // a-b'\n   for (   ; i < n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   // b-a', c+d'\n   for (   ; i < n   ; ++i) buffer[i] = -temp[i - n3_4];       // c'+d\n}\n#endif\n\n#ifndef LIBVORBIS_MDCT\n#define LIBVORBIS_MDCT 0\n#endif\n\n#if LIBVORBIS_MDCT\n// directly call the vorbis MDCT using an interface documented\n// by Jeff Roberts... useful for performance comparison\ntypedef struct\n{\n  int n;\n  int log2n;\n\n  float *trig;\n  int   *bitrev;\n\n  float scale;\n} mdct_lookup;\n\nextern void mdct_init(mdct_lookup *lookup, int n);\nextern void mdct_clear(mdct_lookup *l);\nextern void mdct_backward(mdct_lookup *init, float *in, float *out);\n\nmdct_lookup M1,M2;\n\nvoid inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   mdct_lookup *M;\n   if (M1.n == n) M = &M1;\n   else if (M2.n == n) M = &M2;\n   else if (M1.n == 0) { mdct_init(&M1, n); M = &M1; }\n   else {\n      if (M2.n) __asm int 3;\n      mdct_init(&M2, n);\n      M = &M2;\n   }\n\n   mdct_backward(M, buffer, buffer);\n}\n#endif\n\n\n// the following were split out into separate functions while optimizing;\n// they could be pushed back up but eh. __forceinline showed no change;\n// they're probably already being inlined.\nstatic void imdct_step3_iter0_loop(int n, float *e, int i_off, int k_off, float *A)\n{\n   float *ee0 = e + i_off;\n   float *ee2 = ee0 + k_off;\n   int i;\n\n   assert((n & 3) == 0);\n   for (i=(n>>2); i > 0; --i) {\n      float k00_20, k01_21;\n      k00_20  = ee0[ 0] - ee2[ 0];\n      k01_21  = ee0[-1] - ee2[-1];\n      ee0[ 0] += ee2[ 0];//ee0[ 0] = ee0[ 0] + ee2[ 0];\n      ee0[-1] += ee2[-1];//ee0[-1] = ee0[-1] + ee2[-1];\n      ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-1] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-2] - ee2[-2];\n      k01_21  = ee0[-3] - ee2[-3];\n      ee0[-2] += ee2[-2];//ee0[-2] = ee0[-2] + ee2[-2];\n      ee0[-3] += ee2[-3];//ee0[-3] = ee0[-3] + ee2[-3];\n      ee2[-2] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-3] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-4] - ee2[-4];\n      k01_21  = ee0[-5] - ee2[-5];\n      ee0[-4] += ee2[-4];//ee0[-4] = ee0[-4] + ee2[-4];\n      ee0[-5] += ee2[-5];//ee0[-5] = ee0[-5] + ee2[-5];\n      ee2[-4] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-5] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n\n      k00_20  = ee0[-6] - ee2[-6];\n      k01_21  = ee0[-7] - ee2[-7];\n      ee0[-6] += ee2[-6];//ee0[-6] = ee0[-6] + ee2[-6];\n      ee0[-7] += ee2[-7];//ee0[-7] = ee0[-7] + ee2[-7];\n      ee2[-6] = k00_20 * A[0] - k01_21 * A[1];\n      ee2[-7] = k01_21 * A[0] + k00_20 * A[1];\n      A += 8;\n      ee0 -= 8;\n      ee2 -= 8;\n   }\n}\n\nstatic void imdct_step3_inner_r_loop(int lim, float *e, int d0, int k_off, float *A, int k1)\n{\n   int i;\n   float k00_20, k01_21;\n\n   float *e0 = e + d0;\n   float *e2 = e0 + k_off;\n\n   for (i=lim >> 2; i > 0; --i) {\n      k00_20 = e0[-0] - e2[-0];\n      k01_21 = e0[-1] - e2[-1];\n      e0[-0] += e2[-0];//e0[-0] = e0[-0] + e2[-0];\n      e0[-1] += e2[-1];//e0[-1] = e0[-1] + e2[-1];\n      e2[-0] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-1] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-2] - e2[-2];\n      k01_21 = e0[-3] - e2[-3];\n      e0[-2] += e2[-2];//e0[-2] = e0[-2] + e2[-2];\n      e0[-3] += e2[-3];//e0[-3] = e0[-3] + e2[-3];\n      e2[-2] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-3] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-4] - e2[-4];\n      k01_21 = e0[-5] - e2[-5];\n      e0[-4] += e2[-4];//e0[-4] = e0[-4] + e2[-4];\n      e0[-5] += e2[-5];//e0[-5] = e0[-5] + e2[-5];\n      e2[-4] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-5] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      A += k1;\n\n      k00_20 = e0[-6] - e2[-6];\n      k01_21 = e0[-7] - e2[-7];\n      e0[-6] += e2[-6];//e0[-6] = e0[-6] + e2[-6];\n      e0[-7] += e2[-7];//e0[-7] = e0[-7] + e2[-7];\n      e2[-6] = (k00_20)*A[0] - (k01_21) * A[1];\n      e2[-7] = (k01_21)*A[0] + (k00_20) * A[1];\n\n      e0 -= 8;\n      e2 -= 8;\n\n      A += k1;\n   }\n}\n\nstatic void imdct_step3_inner_s_loop(int n, float *e, int i_off, int k_off, float *A, int a_off, int k0)\n{\n   int i;\n   float A0 = A[0];\n   float A1 = A[0+1];\n   float A2 = A[0+a_off];\n   float A3 = A[0+a_off+1];\n   float A4 = A[0+a_off*2+0];\n   float A5 = A[0+a_off*2+1];\n   float A6 = A[0+a_off*3+0];\n   float A7 = A[0+a_off*3+1];\n\n   float k00,k11;\n\n   float *ee0 = e  +i_off;\n   float *ee2 = ee0+k_off;\n\n   for (i=n; i > 0; --i) {\n      k00     = ee0[ 0] - ee2[ 0];\n      k11     = ee0[-1] - ee2[-1];\n      ee0[ 0] =  ee0[ 0] + ee2[ 0];\n      ee0[-1] =  ee0[-1] + ee2[-1];\n      ee2[ 0] = (k00) * A0 - (k11) * A1;\n      ee2[-1] = (k11) * A0 + (k00) * A1;\n\n      k00     = ee0[-2] - ee2[-2];\n      k11     = ee0[-3] - ee2[-3];\n      ee0[-2] =  ee0[-2] + ee2[-2];\n      ee0[-3] =  ee0[-3] + ee2[-3];\n      ee2[-2] = (k00) * A2 - (k11) * A3;\n      ee2[-3] = (k11) * A2 + (k00) * A3;\n\n      k00     = ee0[-4] - ee2[-4];\n      k11     = ee0[-5] - ee2[-5];\n      ee0[-4] =  ee0[-4] + ee2[-4];\n      ee0[-5] =  ee0[-5] + ee2[-5];\n      ee2[-4] = (k00) * A4 - (k11) * A5;\n      ee2[-5] = (k11) * A4 + (k00) * A5;\n\n      k00     = ee0[-6] - ee2[-6];\n      k11     = ee0[-7] - ee2[-7];\n      ee0[-6] =  ee0[-6] + ee2[-6];\n      ee0[-7] =  ee0[-7] + ee2[-7];\n      ee2[-6] = (k00) * A6 - (k11) * A7;\n      ee2[-7] = (k11) * A6 + (k00) * A7;\n\n      ee0 -= k0;\n      ee2 -= k0;\n   }\n}\n\nstatic __forceinline void iter_54(float *z)\n{\n   float k00,k11,k22,k33;\n   float y0,y1,y2,y3;\n\n   k00  = z[ 0] - z[-4];\n   y0   = z[ 0] + z[-4];\n   y2   = z[-2] + z[-6];\n   k22  = z[-2] - z[-6];\n\n   z[-0] = y0 + y2;      // z0 + z4 + z2 + z6\n   z[-2] = y0 - y2;      // z0 + z4 - z2 - z6\n\n   // done with y0,y2\n\n   k33  = z[-3] - z[-7];\n\n   z[-4] = k00 + k33;    // z0 - z4 + z3 - z7\n   z[-6] = k00 - k33;    // z0 - z4 - z3 + z7\n\n   // done with k33\n\n   k11  = z[-1] - z[-5];\n   y1   = z[-1] + z[-5];\n   y3   = z[-3] + z[-7];\n\n   z[-1] = y1 + y3;      // z1 + z5 + z3 + z7\n   z[-3] = y1 - y3;      // z1 + z5 - z3 - z7\n   z[-5] = k11 - k22;    // z1 - z5 + z2 - z6\n   z[-7] = k11 + k22;    // z1 - z5 - z2 + z6\n}\n\nstatic void imdct_step3_inner_s_loop_ld654(int n, float *e, int i_off, float *A, int base_n)\n{\n   int a_off = base_n >> 3;\n   float A2 = A[0+a_off];\n   float *z = e + i_off;\n   float *base = z - 16 * n;\n\n   while (z > base) {\n      float k00,k11;\n      float l00,l11;\n\n      k00    = z[-0] - z[ -8];\n      k11    = z[-1] - z[ -9];\n      l00    = z[-2] - z[-10];\n      l11    = z[-3] - z[-11];\n      z[ -0] = z[-0] + z[ -8];\n      z[ -1] = z[-1] + z[ -9];\n      z[ -2] = z[-2] + z[-10];\n      z[ -3] = z[-3] + z[-11];\n      z[ -8] = k00;\n      z[ -9] = k11;\n      z[-10] = (l00+l11) * A2;\n      z[-11] = (l11-l00) * A2;\n\n      k00    = z[ -4] - z[-12];\n      k11    = z[ -5] - z[-13];\n      l00    = z[ -6] - z[-14];\n      l11    = z[ -7] - z[-15];\n      z[ -4] = z[ -4] + z[-12];\n      z[ -5] = z[ -5] + z[-13];\n      z[ -6] = z[ -6] + z[-14];\n      z[ -7] = z[ -7] + z[-15];\n      z[-12] = k11;\n      z[-13] = -k00;\n      z[-14] = (l11-l00) * A2;\n      z[-15] = (l00+l11) * -A2;\n\n      iter_54(z);\n      iter_54(z-8);\n      z -= 16;\n   }\n}\n\nstatic void inverse_mdct(float *buffer, int n, vorb *f, int blocktype)\n{\n   int n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int ld;\n   // @OPTIMIZE: reduce register pressure by using fewer variables?\n   int save_point = temp_alloc_save(f);\n   float *buf2 = (float *) temp_alloc(f, n2 * sizeof(*buf2));\n   float *u=NULL,*v=NULL;\n   // twiddle factors\n   float *A = f->A[blocktype];\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // See notes about bugs in that paper in less-optimal implementation 'inverse_mdct_old' after this function.\n\n   // kernel from paper\n\n\n   // merged:\n   //   copy and reflect spectral data\n   //   step 0\n\n   // note that it turns out that the items added together during\n   // this step are, in fact, being added to themselves (as reflected\n   // by step 0). inexplicable inefficiency! this became obvious\n   // once I combined the passes.\n\n   // so there's a missing 'times 2' here (for adding X to itself).\n   // this propagates through linearly to the end, where the numbers\n   // are 1/2 too small, and need to be compensated for.\n\n   {\n      float *d,*e, *AA, *e_stop;\n      d = &buf2[n2-2];\n      AA = A;\n      e = &buffer[0];\n      e_stop = &buffer[n2];\n      while (e != e_stop) {\n         d[1] = (e[0] * AA[0] - e[2]*AA[1]);\n         d[0] = (e[0] * AA[1] + e[2]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e += 4;\n      }\n\n      e = &buffer[n2-3];\n      while (d >= buf2) {\n         d[1] = (-e[2] * AA[0] - -e[0]*AA[1]);\n         d[0] = (-e[2] * AA[1] + -e[0]*AA[0]);\n         d -= 2;\n         AA += 2;\n         e -= 4;\n      }\n   }\n\n   // now we use symbolic names for these, so that we can\n   // possibly swap their meaning as we change which operations\n   // are in place\n\n   u = buffer;\n   v = buf2;\n\n   // step 2    (paper output is w, now u)\n   // this could be in place, but the data ends up in the wrong\n   // place... _somebody_'s got to swap it, so this is nominated\n   {\n      float *AA = &A[n2-8];\n      float *d0,*d1, *e0, *e1;\n\n      e0 = &v[n4];\n      e1 = &v[0];\n\n      d0 = &u[n4];\n      d1 = &u[0];\n\n      while (AA >= A) {\n         float v40_20, v41_21;\n\n         v41_21 = e0[1] - e1[1];\n         v40_20 = e0[0] - e1[0];\n         d0[1]  = e0[1] + e1[1];\n         d0[0]  = e0[0] + e1[0];\n         d1[1]  = v41_21*AA[4] - v40_20*AA[5];\n         d1[0]  = v40_20*AA[4] + v41_21*AA[5];\n\n         v41_21 = e0[3] - e1[3];\n         v40_20 = e0[2] - e1[2];\n         d0[3]  = e0[3] + e1[3];\n         d0[2]  = e0[2] + e1[2];\n         d1[3]  = v41_21*AA[0] - v40_20*AA[1];\n         d1[2]  = v40_20*AA[0] + v41_21*AA[1];\n\n         AA -= 8;\n\n         d0 += 4;\n         d1 += 4;\n         e0 += 4;\n         e1 += 4;\n      }\n   }\n\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n\n   // optimized step 3:\n\n   // the original step3 loop can be nested r inside s or s inside r;\n   // it's written originally as s inside r, but this is dumb when r\n   // iterates many times, and s few. So I have two copies of it and\n   // switch between them halfway.\n\n   // this is iteration 0 of step 3\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*0, -(n >> 3), A);\n   imdct_step3_iter0_loop(n >> 4, u, n2-1-n4*1, -(n >> 3), A);\n\n   // this is iteration 1 of step 3\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*0, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*1, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*2, -(n >> 4), A, 16);\n   imdct_step3_inner_r_loop(n >> 5, u, n2-1 - n8*3, -(n >> 4), A, 16);\n\n   l=2;\n   for (; l < (ld-3)>>1; ++l) {\n      int k0 = n >> (l+2), k0_2 = k0>>1;\n      int lim = 1 << (l+1);\n      int i;\n      for (i=0; i < lim; ++i)\n         imdct_step3_inner_r_loop(n >> (l+4), u, n2-1 - k0*i, -k0_2, A, 1 << (l+3));\n   }\n\n   for (; l < ld-6; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3), k0_2 = k0>>1;\n      int rlim = n >> (l+6), r;\n      int lim = 1 << (l+1);\n      int i_off;\n      float *A0 = A;\n      i_off = n2-1;\n      for (r=rlim; r > 0; --r) {\n         imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);\n         A0 += k1*4;\n         i_off -= 8;\n      }\n   }\n\n   // iterations with count:\n   //   ld-6,-5,-4 all interleaved together\n   //       the big win comes from getting rid of needless flops\n   //         due to the constants on pass 5 & 4 being all 1 and 0;\n   //       combining them to be simultaneous to improve cache made little difference\n   imdct_step3_inner_s_loop_ld654(n >> 5, u, n2-1, A, n);\n\n   // output is u\n\n   // step 4, 5, and 6\n   // cannot be in-place because of step 5\n   {\n      uint16 *bitrev = f->bit_reverse[blocktype];\n      // weirdly, I'd have thought reading sequentially and writing\n      // erratically would have been better than vice-versa, but in\n      // fact that's not what my testing showed. (That is, with\n      // j = bitreverse(i), do you read i and write j, or read j and write i.)\n\n      float *d0 = &v[n4-4];\n      float *d1 = &v[n2-4];\n      while (d0 >= v) {\n         int k4;\n\n         k4 = bitrev[0];\n         d1[3] = u[k4+0];\n         d1[2] = u[k4+1];\n         d0[3] = u[k4+2];\n         d0[2] = u[k4+3];\n\n         k4 = bitrev[1];\n         d1[1] = u[k4+0];\n         d1[0] = u[k4+1];\n         d0[1] = u[k4+2];\n         d0[0] = u[k4+3];\n\n         d0 -= 4;\n         d1 -= 4;\n         bitrev += 2;\n      }\n   }\n   // (paper output is u, now v)\n\n\n   // data must be in buf2\n   assert(v == buf2);\n\n   // step 7   (paper output is v, now v)\n   // this is now in place\n   {\n      float *C = f->C[blocktype];\n      float *d, *e;\n\n      d = v;\n      e = v + n2 - 4;\n\n      while (d < e) {\n         float a02,a11,b0,b1,b2,b3;\n\n         a02 = d[0] - e[2];\n         a11 = d[1] + e[3];\n\n         b0 = C[1]*a02 + C[0]*a11;\n         b1 = C[1]*a11 - C[0]*a02;\n\n         b2 = d[0] + e[ 2];\n         b3 = d[1] - e[ 3];\n\n         d[0] = b2 + b0;\n         d[1] = b3 + b1;\n         e[2] = b2 - b0;\n         e[3] = b1 - b3;\n\n         a02 = d[2] - e[0];\n         a11 = d[3] + e[1];\n\n         b0 = C[3]*a02 + C[2]*a11;\n         b1 = C[3]*a11 - C[2]*a02;\n\n         b2 = d[2] + e[ 0];\n         b3 = d[3] - e[ 1];\n\n         d[2] = b2 + b0;\n         d[3] = b3 + b1;\n         e[0] = b2 - b0;\n         e[1] = b1 - b3;\n\n         C += 4;\n         d += 4;\n         e -= 4;\n      }\n   }\n\n   // data must be in buf2\n\n\n   // step 8+decode   (paper output is X, now buffer)\n   // this generates pairs of data a la 8 and pushes them directly through\n   // the decode kernel (pushing rather than pulling) to avoid having\n   // to make another pass later\n\n   // this cannot POSSIBLY be in place, so we refer to the buffers directly\n\n   {\n      float *d0,*d1,*d2,*d3;\n\n      float *B = f->B[blocktype] + n2 - 8;\n      float *e = buf2 + n2 - 8;\n      d0 = &buffer[0];\n      d1 = &buffer[n2-4];\n      d2 = &buffer[n2];\n      d3 = &buffer[n-4];\n      while (e >= v) {\n         float p0,p1,p2,p3;\n\n         p3 =  e[6]*B[7] - e[7]*B[6];\n         p2 = -e[6]*B[6] - e[7]*B[7];\n\n         d0[0] =   p3;\n         d1[3] = - p3;\n         d2[0] =   p2;\n         d3[3] =   p2;\n\n         p1 =  e[4]*B[5] - e[5]*B[4];\n         p0 = -e[4]*B[4] - e[5]*B[5];\n\n         d0[1] =   p1;\n         d1[2] = - p1;\n         d2[1] =   p0;\n         d3[2] =   p0;\n\n         p3 =  e[2]*B[3] - e[3]*B[2];\n         p2 = -e[2]*B[2] - e[3]*B[3];\n\n         d0[2] =   p3;\n         d1[1] = - p3;\n         d2[2] =   p2;\n         d3[1] =   p2;\n\n         p1 =  e[0]*B[1] - e[1]*B[0];\n         p0 = -e[0]*B[0] - e[1]*B[1];\n\n         d0[3] =   p1;\n         d1[0] = - p1;\n         d2[3] =   p0;\n         d3[0] =   p0;\n\n         B -= 8;\n         e -= 8;\n         d0 += 4;\n         d2 += 4;\n         d1 -= 4;\n         d3 -= 4;\n      }\n   }\n\n   temp_free(f,buf2);\n   temp_alloc_restore(f,save_point);\n}\n\n#if 0\n// this is the original version of the above code, if you want to optimize it from scratch\nvoid inverse_mdct_naive(float *buffer, int n)\n{\n   float s;\n   float A[1 << 12], B[1 << 12], C[1 << 11];\n   int i,k,k2,k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;\n   int n3_4 = n - n4, ld;\n   // how can they claim this only uses N words?!\n   // oh, because they're only used sparsely, whoops\n   float u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];\n   // set up twiddle factors\n\n   for (k=k2=0; k < n4; ++k,k2+=2) {\n      A[k2  ] = (float)  cos(4*k*M_PI/n);\n      A[k2+1] = (float) -sin(4*k*M_PI/n);\n      B[k2  ] = (float)  cos((k2+1)*M_PI/n/2);\n      B[k2+1] = (float)  sin((k2+1)*M_PI/n/2);\n   }\n   for (k=k2=0; k < n8; ++k,k2+=2) {\n      C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);\n      C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);\n   }\n\n   // IMDCT algorithm from \"The use of multirate filter banks for coding of high quality digital audio\"\n   // Note there are bugs in that pseudocode, presumably due to them attempting\n   // to rename the arrays nicely rather than representing the way their actual\n   // implementation bounces buffers back and forth. As a result, even in the\n   // \"some formulars corrected\" version, a direct implementation fails. These\n   // are noted below as \"paper bug\".\n\n   // copy and reflect spectral data\n   for (k=0; k < n2; ++k) u[k] = buffer[k];\n   for (   ; k < n ; ++k) u[k] = -buffer[n - k - 1];\n   // kernel from paper\n   // step 1\n   for (k=k2=k4=0; k < n4; k+=1, k2+=2, k4+=4) {\n      v[n-k4-1] = (u[k4] - u[n-k4-1]) * A[k2]   - (u[k4+2] - u[n-k4-3])*A[k2+1];\n      v[n-k4-3] = (u[k4] - u[n-k4-1]) * A[k2+1] + (u[k4+2] - u[n-k4-3])*A[k2];\n   }\n   // step 2\n   for (k=k4=0; k < n8; k+=1, k4+=4) {\n      w[n2+3+k4] = v[n2+3+k4] + v[k4+3];\n      w[n2+1+k4] = v[n2+1+k4] + v[k4+1];\n      w[k4+3]    = (v[n2+3+k4] - v[k4+3])*A[n2-4-k4] - (v[n2+1+k4]-v[k4+1])*A[n2-3-k4];\n      w[k4+1]    = (v[n2+1+k4] - v[k4+1])*A[n2-4-k4] + (v[n2+3+k4]-v[k4+3])*A[n2-3-k4];\n   }\n   // step 3\n   ld = ilog(n) - 1; // ilog is off-by-one from normal definitions\n   for (l=0; l < ld-3; ++l) {\n      int k0 = n >> (l+2), k1 = 1 << (l+3);\n      int rlim = n >> (l+4), r4, r;\n      int s2lim = 1 << (l+2), s2;\n      for (r=r4=0; r < rlim; r4+=4,++r) {\n         for (s2=0; s2 < s2lim; s2+=2) {\n            u[n-1-k0*s2-r4] = w[n-1-k0*s2-r4] + w[n-1-k0*(s2+1)-r4];\n            u[n-3-k0*s2-r4] = w[n-3-k0*s2-r4] + w[n-3-k0*(s2+1)-r4];\n            u[n-1-k0*(s2+1)-r4] = (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1]\n                                - (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1+1];\n            u[n-3-k0*(s2+1)-r4] = (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1]\n                                + (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1+1];\n         }\n      }\n      if (l+1 < ld-3) {\n         // paper bug: ping-ponging of u&w here is omitted\n         memcpy(w, u, sizeof(u));\n      }\n   }\n\n   // step 4\n   for (i=0; i < n8; ++i) {\n      int j = bit_reverse(i) >> (32-ld+3);\n      assert(j < n8);\n      if (i == j) {\n         // paper bug: original code probably swapped in place; if copying,\n         //            need to directly copy in this case\n         int i8 = i << 3;\n         v[i8+1] = u[i8+1];\n         v[i8+3] = u[i8+3];\n         v[i8+5] = u[i8+5];\n         v[i8+7] = u[i8+7];\n      } else if (i < j) {\n         int i8 = i << 3, j8 = j << 3;\n         v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];\n         v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];\n         v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];\n         v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];\n      }\n   }\n   // step 5\n   for (k=0; k < n2; ++k) {\n      w[k] = v[k*2+1];\n   }\n   // step 6\n   for (k=k2=k4=0; k < n8; ++k, k2 += 2, k4 += 4) {\n      u[n-1-k2] = w[k4];\n      u[n-2-k2] = w[k4+1];\n      u[n3_4 - 1 - k2] = w[k4+2];\n      u[n3_4 - 2 - k2] = w[k4+3];\n   }\n   // step 7\n   for (k=k2=0; k < n8; ++k, k2 += 2) {\n      v[n2 + k2 ] = ( u[n2 + k2] + u[n-2-k2] + C[k2+1]*(u[n2+k2]-u[n-2-k2]) + C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n-2 - k2] = ( u[n2 + k2] + u[n-2-k2] - C[k2+1]*(u[n2+k2]-u[n-2-k2]) - C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;\n      v[n2+1+ k2] = ( u[n2+1+k2] - u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n      v[n-1 - k2] = (-u[n2+1+k2] + u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;\n   }\n   // step 8\n   for (k=k2=0; k < n4; ++k,k2 += 2) {\n      X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];\n      X[n2-1-k] = v[k2+n2]*B[k2+1] - v[k2+1+n2]*B[k2  ];\n   }\n\n   // decode kernel to output\n   // determined the following value experimentally\n   // (by first figuring out what made inverse_mdct_slow work); then matching that here\n   // (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)\n   s = 0.5; // theoretically would be n4\n\n   // [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,\n   //     so it needs to use the \"old\" B values to behave correctly, or else\n   //     set s to 1.0 ]]]\n   for (i=0; i < n4  ; ++i) buffer[i] = s * X[i+n4];\n   for (   ; i < n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];\n   for (   ; i < n   ; ++i) buffer[i] = -s * X[i - n3_4];\n}\n#endif\n\nstatic float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\ntypedef int16 YTYPE;\n#else\ntypedef int YTYPE;\n#endif\nstatic int do_floor(vorb *f, Mapping *map, int i, int n, float *target, YTYPE *finalY, uint8 *step2_flag)\n{\n   int n2 = n >> 1;\n   int s = map->chan[i].mux, floor;\n   floor = map->submap_floor[s];\n   if (f->floor_types[floor] == 0) {\n      return error(f, VORBIS_invalid_stream);\n   } else {\n      Floor1 *g = &f->floor_config[floor].floor1;\n      int j,q;\n      int lx = 0, ly = finalY[0] * g->floor1_multiplier;\n      for (q=1; q < g->values; ++q) {\n         j = g->sorted_order[q];\n         #ifndef STB_VORBIS_NO_DEFER_FLOOR\n         STBV_NOTUSED(step2_flag);\n         if (finalY[j] >= 0)\n         #else\n         if (step2_flag[j])\n         #endif\n         {\n            int hy = finalY[j] * g->floor1_multiplier;\n            int hx = g->Xlist[j];\n            if (lx != hx)\n               draw_line(target, lx,ly, hx,hy, n2);\n            CHECK(f);\n            lx = hx, ly = hy;\n         }\n      }\n      if (lx < n2) {\n         // optimization of: draw_line(target, lx,ly, n,ly, n2);\n         for (j=lx; j < n2; ++j)\n            LINE_OP(target[j], inverse_db_table[ly]);\n         CHECK(f);\n      }\n   }\n   return TRUE;\n}\n\n// The meaning of \"left\" and \"right\"\n//\n// For a given frame:\n//     we compute samples from 0..n\n//     window_center is n/2\n//     we'll window and mix the samples from left_start to left_end with data from the previous frame\n//     all of the samples from left_end to right_start can be output without mixing; however,\n//        this interval is 0-length except when transitioning between short and long frames\n//     all of the samples from right_start to right_end need to be mixed with the next frame,\n//        which we don't have, so those get saved in a buffer\n//     frame N's right_end-right_start, the number of samples to mix with the next frame,\n//        has to be the same as frame N+1's left_end-left_start (which they are by\n//        construction)\n\nstatic int vorbis_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   Mode *m;\n   int i, n, prev, next, window_center;\n   f->channel_buffer_start = f->channel_buffer_end = 0;\n\n  retry:\n   if (f->eof) return FALSE;\n   if (!maybe_start_packet(f))\n      return FALSE;\n   // check packet type\n   if (get_bits(f,1) != 0) {\n      if (IS_PUSH_MODE(f))\n         return error(f,VORBIS_bad_packet_type);\n      while (EOP != get8_packet(f));\n      goto retry;\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   i = get_bits(f, ilog(f->mode_count-1));\n   if (i == EOP) return FALSE;\n   if (i >= f->mode_count) return FALSE;\n   *mode = i;\n   m = f->mode_config + i;\n   if (m->blockflag) {\n      n = f->blocksize_1;\n      prev = get_bits(f,1);\n      next = get_bits(f,1);\n   } else {\n      prev = next = 0;\n      n = f->blocksize_0;\n   }\n\n// WINDOWING\n\n   window_center = n >> 1;\n   if (m->blockflag && !prev) {\n      *p_left_start = (n - f->blocksize_0) >> 2;\n      *p_left_end   = (n + f->blocksize_0) >> 2;\n   } else {\n      *p_left_start = 0;\n      *p_left_end   = window_center;\n   }\n   if (m->blockflag && !next) {\n      *p_right_start = (n*3 - f->blocksize_0) >> 2;\n      *p_right_end   = (n*3 + f->blocksize_0) >> 2;\n   } else {\n      *p_right_start = window_center;\n      *p_right_end   = n;\n   }\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet_rest(vorb *f, int *len, Mode *m, int left_start, int left_end, int right_start, int right_end, int *p_left)\n{\n   Mapping *map;\n   int i,j,k,n,n2;\n   int zero_channel[256];\n   int really_zero_channel[256];\n\n// WINDOWING\n\n   STBV_NOTUSED(left_end);\n   n = f->blocksize[m->blockflag];\n   map = &f->mapping[m->mapping];\n\n// FLOORS\n   n2 = n >> 1;\n\n   CHECK(f);\n\n   for (i=0; i < f->channels; ++i) {\n      int s = map->chan[i].mux, floor;\n      zero_channel[i] = FALSE;\n      floor = map->submap_floor[s];\n      if (f->floor_types[floor] == 0) {\n         return error(f, VORBIS_invalid_stream);\n      } else {\n         Floor1 *g = &f->floor_config[floor].floor1;\n         if (get_bits(f, 1)) {\n            short *finalY;\n            uint8 step2_flag[256];\n            static int range_list[4] = { 256, 128, 86, 64 };\n            int range = range_list[g->floor1_multiplier-1];\n            int offset = 2;\n            finalY = f->finalY[i];\n            finalY[0] = get_bits(f, ilog(range)-1);\n            finalY[1] = get_bits(f, ilog(range)-1);\n            for (j=0; j < g->partitions; ++j) {\n               int pclass = g->partition_class_list[j];\n               int cdim = g->class_dimensions[pclass];\n               int cbits = g->class_subclasses[pclass];\n               int csub = (1 << cbits)-1;\n               int cval = 0;\n               if (cbits) {\n                  Codebook *c = f->codebooks + g->class_masterbooks[pclass];\n                  DECODE(cval,f,c);\n               }\n               for (k=0; k < cdim; ++k) {\n                  int book = g->subclass_books[pclass][cval & csub];\n                  cval = cval >> cbits;\n                  if (book >= 0) {\n                     int temp;\n                     Codebook *c = f->codebooks + book;\n                     DECODE(temp,f,c);\n                     finalY[offset++] = temp;\n                  } else\n                     finalY[offset++] = 0;\n               }\n            }\n            if (f->valid_bits == INVALID_BITS) goto error; // behavior according to spec\n            step2_flag[0] = step2_flag[1] = 1;\n            for (j=2; j < g->values; ++j) {\n               int low, high, pred, highroom, lowroom, room, val;\n               low = g->neighbors[j][0];\n               high = g->neighbors[j][1];\n               //neighbors(g->Xlist, j, &low, &high);\n               pred = predict_point(g->Xlist[j], g->Xlist[low], g->Xlist[high], finalY[low], finalY[high]);\n               val = finalY[j];\n               highroom = range - pred;\n               lowroom = pred;\n               if (highroom < lowroom)\n                  room = highroom * 2;\n               else\n                  room = lowroom * 2;\n               if (val) {\n                  step2_flag[low] = step2_flag[high] = 1;\n                  step2_flag[j] = 1;\n                  if (val >= room)\n                     if (highroom > lowroom)\n                        finalY[j] = val - lowroom + pred;\n                     else\n                        finalY[j] = pred - val + highroom - 1;\n                  else\n                     if (val & 1)\n                        finalY[j] = pred - ((val+1)>>1);\n                     else\n                        finalY[j] = pred + (val>>1);\n               } else {\n                  step2_flag[j] = 0;\n                  finalY[j] = pred;\n               }\n            }\n\n#ifdef STB_VORBIS_NO_DEFER_FLOOR\n            do_floor(f, map, i, n, f->floor_buffers[i], finalY, step2_flag);\n#else\n            // defer final floor computation until _after_ residue\n            for (j=0; j < g->values; ++j) {\n               if (!step2_flag[j])\n                  finalY[j] = -1;\n            }\n#endif\n         } else {\n           error:\n            zero_channel[i] = TRUE;\n         }\n         // So we just defer everything else to later\n\n         // at this point we've decoded the floor into buffer\n      }\n   }\n   CHECK(f);\n   // at this point we've decoded all floors\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n\n   // re-enable coupled channels if necessary\n   memcpy(really_zero_channel, zero_channel, sizeof(really_zero_channel[0]) * f->channels);\n   for (i=0; i < map->coupling_steps; ++i)\n      if (!zero_channel[map->chan[i].magnitude] || !zero_channel[map->chan[i].angle]) {\n         zero_channel[map->chan[i].magnitude] = zero_channel[map->chan[i].angle] = FALSE;\n      }\n\n   CHECK(f);\n// RESIDUE DECODE\n   for (i=0; i < map->submaps; ++i) {\n      float *residue_buffers[STB_VORBIS_MAX_CHANNELS];\n      int r;\n      uint8 do_not_decode[256];\n      int ch = 0;\n      for (j=0; j < f->channels; ++j) {\n         if (map->chan[j].mux == i) {\n            if (zero_channel[j]) {\n               do_not_decode[ch] = TRUE;\n               residue_buffers[ch] = NULL;\n            } else {\n               do_not_decode[ch] = FALSE;\n               residue_buffers[ch] = f->channel_buffers[j];\n            }\n            ++ch;\n         }\n      }\n      r = map->submap_residue[i];\n      decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);\n   }\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   CHECK(f);\n\n// INVERSE COUPLING\n   for (i = map->coupling_steps-1; i >= 0; --i) {\n      int n2 = n >> 1;\n      float *m = f->channel_buffers[map->chan[i].magnitude];\n      float *a = f->channel_buffers[map->chan[i].angle    ];\n      for (j=0; j < n2; ++j) {\n         float a2,m2;\n         if (m[j] > 0)\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] - a[j];\n            else\n               a2 = m[j], m2 = m[j] + a[j];\n         else\n            if (a[j] > 0)\n               m2 = m[j], a2 = m[j] + a[j];\n            else\n               a2 = m[j], m2 = m[j] - a[j];\n         m[j] = m2;\n         a[j] = a2;\n      }\n   }\n   CHECK(f);\n\n   // finish decoding the floors\n#ifndef STB_VORBIS_NO_DEFER_FLOOR\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         do_floor(f, map, i, n, f->channel_buffers[i], f->finalY[i], NULL);\n      }\n   }\n#else\n   for (i=0; i < f->channels; ++i) {\n      if (really_zero_channel[i]) {\n         memset(f->channel_buffers[i], 0, sizeof(*f->channel_buffers[i]) * n2);\n      } else {\n         for (j=0; j < n2; ++j)\n            f->channel_buffers[i][j] *= f->floor_buffers[i][j];\n      }\n   }\n#endif\n\n// INVERSE MDCT\n   CHECK(f);\n   for (i=0; i < f->channels; ++i)\n      inverse_mdct(f->channel_buffers[i], n, f, m->blockflag);\n   CHECK(f);\n\n   // this shouldn't be necessary, unless we exited on an error\n   // and want to flush to get to the next packet\n   flush_packet(f);\n\n   if (f->first_decode) {\n      // assume we start so first non-discarded sample is sample 0\n      // this isn't to spec, but spec would require us to read ahead\n      // and decode the size of all current frames--could be done,\n      // but presumably it's not a commonly used feature\n      f->current_loc = 0u - n2; // start of first frame is positioned for discard (NB this is an intentional unsigned overflow/wrap-around)\n      // we might have to discard samples \"from\" the next frame too,\n      // if we're lapping a large block then a small at the start?\n      f->discard_samples_deferred = n - right_end;\n      f->current_loc_valid = TRUE;\n      f->first_decode = FALSE;\n   } else if (f->discard_samples_deferred) {\n      if (f->discard_samples_deferred >= right_start - left_start) {\n         f->discard_samples_deferred -= (right_start - left_start);\n         left_start = right_start;\n         *p_left = left_start;\n      } else {\n         left_start += f->discard_samples_deferred;\n         *p_left = left_start;\n         f->discard_samples_deferred = 0;\n      }\n   } else if (f->previous_length == 0 && f->current_loc_valid) {\n      // we're recovering from a seek... that means we're going to discard\n      // the samples from this packet even though we know our position from\n      // the last page header, so we need to update the position based on\n      // the discarded samples here\n      // but wait, the code below is going to add this in itself even\n      // on a discard, so we don't need to do it here...\n   }\n\n   // check if we have ogg information about the sample # for this packet\n   if (f->last_seg_which == f->end_seg_with_known_loc) {\n      // if we have a valid current loc, and this is final:\n      if (f->current_loc_valid && (f->page_flag & PAGEFLAG_last_page)) {\n         uint32 current_end = f->known_loc_for_packet;\n         // then let's infer the size of the (probably) short final frame\n         if (current_end < f->current_loc + (right_end-left_start)) {\n            if (current_end < f->current_loc) {\n               // negative truncation, that's impossible!\n               *len = 0;\n            } else {\n               *len = current_end - f->current_loc;\n            }\n            *len += left_start; // this doesn't seem right, but has no ill effect on my test files\n            if (*len > right_end) *len = right_end; // this should never happen\n            f->current_loc += *len;\n            return TRUE;\n         }\n      }\n      // otherwise, just set our sample loc\n      // guess that the ogg granule pos refers to the _middle_ of the\n      // last frame?\n      // set f->current_loc to the position of left_start\n      f->current_loc = f->known_loc_for_packet - (n2-left_start);\n      f->current_loc_valid = TRUE;\n   }\n   if (f->current_loc_valid)\n      f->current_loc += (right_start - left_start);\n\n   if (f->alloc.alloc_buffer)\n      assert(f->alloc.alloc_buffer_length_in_bytes == f->temp_offset);\n   *len = right_end;  // ignore samples after the window goes to 0\n   CHECK(f);\n\n   return TRUE;\n}\n\nstatic int vorbis_decode_packet(vorb *f, int *len, int *p_left, int *p_right)\n{\n   int mode, left_end, right_end;\n   if (!vorbis_decode_initial(f, p_left, &left_end, p_right, &right_end, &mode)) return 0;\n   return vorbis_decode_packet_rest(f, len, f->mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);\n}\n\nstatic int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n{\n   int prev,i,j;\n   // we use right&left (the start of the right- and left-window sin()-regions)\n   // to determine how much to return, rather than inferring from the rules\n   // (same result, clearer code); 'left' indicates where our sin() window\n   // starts, therefore where the previous window's right edge starts, and\n   // therefore where to start mixing from the previous buffer. 'right'\n   // indicates where our sin() ending-window starts, therefore that's where\n   // we start saving, and where our returned-data ends.\n\n   // mixin from previous window\n   if (f->previous_length) {\n      int i,j, n = f->previous_length;\n      float *w = get_window(f, n);\n      if (w == NULL) return 0;\n      for (i=0; i < f->channels; ++i) {\n         for (j=0; j < n; ++j)\n            f->channel_buffers[i][left+j] =\n               f->channel_buffers[i][left+j]*w[    j] +\n               f->previous_window[i][     j]*w[n-1-j];\n      }\n   }\n\n   prev = f->previous_length;\n\n   // last half of this data becomes previous window\n   f->previous_length = len - right;\n\n   // @OPTIMIZE: could avoid this copy by double-buffering the\n   // output (flipping previous_window with channel_buffers), but\n   // then previous_window would have to be 2x as large, and\n   // channel_buffers couldn't be temp mem (although they're NOT\n   // currently temp mem, they could be (unless we want to level\n   // performance by spreading out the computation))\n   for (i=0; i < f->channels; ++i)\n      for (j=0; right+j < len; ++j)\n         f->previous_window[i][j] = f->channel_buffers[i][right+j];\n\n   if (!prev)\n      // there was no previous packet, so this data isn't valid...\n      // this isn't entirely true, only the would-have-overlapped data\n      // isn't valid, but this seems to be what the spec requires\n      return 0;\n\n   // truncate a short frame\n   if (len < right) right = len;\n\n   f->samples_output += right-left;\n\n   return right - left;\n}\n\nstatic int vorbis_pump_first_frame(stb_vorbis *f)\n{\n   int len, right, left, res;\n   res = vorbis_decode_packet(f, &len, &left, &right);\n   if (res)\n      vorbis_finish_frame(f, len, left, right);\n   return res;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\nstatic int is_whole_packet_present(stb_vorbis *f)\n{\n   // make sure that we have the packet available before continuing...\n   // this requires a full ogg parse, but we know we can fetch from f->stream\n\n   // instead of coding this out explicitly, we could save the current read state,\n   // read the next packet with get8() until end-of-packet, check f->eof, then\n   // reset the state? but that would be slower, esp. since we'd have over 256 bytes\n   // of state to restore (primarily the page segment table)\n\n   int s = f->next_seg, first = TRUE;\n   uint8 *p = f->stream;\n\n   if (s != -1) { // if we're not starting the packet with a 'continue on next page' flag\n      for (; s < f->segment_count; ++s) {\n         p += f->segments[s];\n         if (f->segments[s] < 255)               // stop at first short segment\n            break;\n      }\n      // either this continues, or it ends it...\n      if (s == f->segment_count)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   for (; s == -1;) {\n      uint8 *q;\n      int n;\n\n      // check that we have the page header ready\n      if (p + 26 >= f->stream_end)               return error(f, VORBIS_need_more_data);\n      // validate the page\n      if (memcmp(p, ogg_page_header, 4))         return error(f, VORBIS_invalid_stream);\n      if (p[4] != 0)                             return error(f, VORBIS_invalid_stream);\n      if (first) { // the first segment must NOT have 'continued_packet', later ones MUST\n         if (f->previous_length)\n            if ((p[5] & PAGEFLAG_continued_packet))  return error(f, VORBIS_invalid_stream);\n         // if no previous length, we're resynching, so we can come in on a continued-packet,\n         // which we'll just drop\n      } else {\n         if (!(p[5] & PAGEFLAG_continued_packet)) return error(f, VORBIS_invalid_stream);\n      }\n      n = p[26]; // segment counts\n      q = p+27;  // q points to segment table\n      p = q + n; // advance past header\n      // make sure we've read the segment table\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      for (s=0; s < n; ++s) {\n         p += q[s];\n         if (q[s] < 255)\n            break;\n      }\n      if (s == n)\n         s = -1; // set 'crosses page' flag\n      if (p > f->stream_end)                     return error(f, VORBIS_need_more_data);\n      first = FALSE;\n   }\n   return TRUE;\n}\n#endif // !STB_VORBIS_NO_PUSHDATA_API\n\nstatic int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n   f->first_decode = TRUE;\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30) {\n      // check for the Ogg skeleton fishead identifying header to refine our error\n      if (f->segments[0] == 64 &&\n          getn(f, header, 6) &&\n          header[0] == 'f' &&\n          header[1] == 'i' &&\n          header[2] == 's' &&\n          header[3] == 'h' &&\n          header[4] == 'e' &&\n          header[5] == 'a' &&\n          get8(f)   == 'd' &&\n          get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);\n      else\n                                                    return error(f, VORBIS_invalid_first_page);\n   }\n\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n\n   if (!next_segment(f))                            return FALSE;\n\n   if (get8_packet(f) != VORBIS_packet_comment)            return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n   //file vendor\n   len = get32_packet(f);\n   f->vendor = (char*)setup_malloc(f, sizeof(char) * (len+1));\n   if (f->vendor == NULL)                           return error(f, VORBIS_outofmem);\n   for(i=0; i < len; ++i) {\n      f->vendor[i] = get8_packet(f);\n   }\n   f->vendor[len] = (char)'\\0';\n   //user comments\n   f->comment_list_length = get32_packet(f);\n   f->comment_list = NULL;\n   if (f->comment_list_length > 0)\n   {\n      f->comment_list = (char**) setup_malloc(f, sizeof(char*) * (f->comment_list_length));\n      if (f->comment_list == NULL)                  return error(f, VORBIS_outofmem);\n   }\n\n   for(i=0; i < f->comment_list_length; ++i) {\n      len = get32_packet(f);\n      f->comment_list[i] = (char*)setup_malloc(f, sizeof(char) * (len+1));\n      if (f->comment_list[i] == NULL)               return error(f, VORBIS_outofmem);\n\n      for(j=0; j < len; ++j) {\n         f->comment_list[i][j] = get8_packet(f);\n      }\n      f->comment_list[i][len] = (char)'\\0';\n   }\n\n   // framing_flag\n   x = get8_packet(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_setup);\n\n\n   skip(f, f->bytes_in_seg);\n   f->bytes_in_seg = 0;\n\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            int values = lookup1_values(c->entries, c->dimensions);\n            if (values < 0) return error(f, VORBIS_invalid_setup);\n            c->lookup_values = (uint32) values;\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1;\n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = (int16)get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values-1; ++j)\n            if (p[j].x == p[j+1].x)\n               return error(f, VORBIS_invalid_setup);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low = 0,hi = 0;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;\n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   // @TODO: stb_vorbis_seek_start expects first_audio_page_offset to point to a page\n   // without PAGEFLAG_continued_packet, so this either points to the first page, or\n   // the page after the end of the headers. It might be cleaner to point to a page\n   // in the middle of the headers, when that's the page where the first audio packet\n   // starts, but we'd have to also correctly skip the end of any continued packet in\n   // stb_vorbis_seek_start.\n   if (f->next_seg == -1) {\n      f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n   } else {\n      f->first_audio_page_offset = 0;\n   }\n\n   return TRUE;\n}\n\nstatic void vorbis_deinit(stb_vorbis *p)\n{\n   int i,j;\n\n   setup_free(p, p->vendor);\n   for (i=0; i < p->comment_list_length; ++i) {\n      setup_free(p, p->comment_list[i]);\n   }\n   setup_free(p, p->comment_list);\n\n   if (p->residue_config) {\n      for (i=0; i < p->residue_count; ++i) {\n         Residue *r = p->residue_config+i;\n         if (r->classdata) {\n            for (j=0; j < p->codebooks[r->classbook].entries; ++j)\n               setup_free(p, r->classdata[j]);\n            setup_free(p, r->classdata);\n         }\n         setup_free(p, r->residue_books);\n      }\n   }\n\n   if (p->codebooks) {\n      CHECK(p);\n      for (i=0; i < p->codebook_count; ++i) {\n         Codebook *c = p->codebooks + i;\n         setup_free(p, c->codeword_lengths);\n         setup_free(p, c->multiplicands);\n         setup_free(p, c->codewords);\n         setup_free(p, c->sorted_codewords);\n         // c->sorted_values[-1] is the first entry in the array\n         setup_free(p, c->sorted_values ? c->sorted_values-1 : NULL);\n      }\n      setup_free(p, p->codebooks);\n   }\n   setup_free(p, p->floor_config);\n   setup_free(p, p->residue_config);\n   if (p->mapping) {\n      for (i=0; i < p->mapping_count; ++i)\n         setup_free(p, p->mapping[i].chan);\n      setup_free(p, p->mapping);\n   }\n   CHECK(p);\n   for (i=0; i < p->channels && i < STB_VORBIS_MAX_CHANNELS; ++i) {\n      setup_free(p, p->channel_buffers[i]);\n      setup_free(p, p->previous_window[i]);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      setup_free(p, p->floor_buffers[i]);\n      #endif\n      setup_free(p, p->finalY[i]);\n   }\n   for (i=0; i < 2; ++i) {\n      setup_free(p, p->A[i]);\n      setup_free(p, p->B[i]);\n      setup_free(p, p->C[i]);\n      setup_free(p, p->window[i]);\n      setup_free(p, p->bit_reverse[i]);\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (p->close_on_free) fclose(p->f);\n   #endif\n}\n\nvoid stb_vorbis_close(stb_vorbis *p)\n{\n   if (p == NULL) return;\n   vorbis_deinit(p);\n   setup_free(p,p);\n}\n\nstatic void vorbis_init(stb_vorbis *p, const stb_vorbis_alloc *z)\n{\n   memset(p, 0, sizeof(*p)); // NULL out all malloc'd pointers to start\n   if (z) {\n      p->alloc = *z;\n      p->alloc.alloc_buffer_length_in_bytes &= ~7;\n      p->temp_offset = p->alloc.alloc_buffer_length_in_bytes;\n   }\n   p->eof = 0;\n   p->error = VORBIS__no_error;\n   p->stream = NULL;\n   p->codebooks = NULL;\n   p->page_crc_tests = -1;\n   #ifndef STB_VORBIS_NO_STDIO\n   p->close_on_free = FALSE;\n   p->f = NULL;\n   #endif\n}\n\nint stb_vorbis_get_sample_offset(stb_vorbis *f)\n{\n   if (f->current_loc_valid)\n      return f->current_loc;\n   else\n      return -1;\n}\n\nstb_vorbis_info stb_vorbis_get_info(stb_vorbis *f)\n{\n   stb_vorbis_info d;\n   d.channels = f->channels;\n   d.sample_rate = f->sample_rate;\n   d.setup_memory_required = f->setup_memory_required;\n   d.setup_temp_memory_required = f->setup_temp_memory_required;\n   d.temp_memory_required = f->temp_memory_required;\n   d.max_frame_size = f->blocksize_1 >> 1;\n   return d;\n}\n\nstb_vorbis_comment stb_vorbis_get_comment(stb_vorbis *f)\n{\n   stb_vorbis_comment d;\n   d.vendor = f->vendor;\n   d.comment_list_length = f->comment_list_length;\n   d.comment_list = f->comment_list;\n   return d;\n}\n\nint stb_vorbis_get_error(stb_vorbis *f)\n{\n   int e = f->error;\n   f->error = VORBIS__no_error;\n   return e;\n}\n\nstatic stb_vorbis * vorbis_alloc(stb_vorbis *f)\n{\n   stb_vorbis *p = (stb_vorbis *) setup_malloc(f, sizeof(*p));\n   return p;\n}\n\n#ifndef STB_VORBIS_NO_PUSHDATA_API\n\nvoid stb_vorbis_flush_pushdata(stb_vorbis *f)\n{\n   f->previous_length = 0;\n   f->page_crc_tests  = 0;\n   f->discard_samples_deferred = 0;\n   f->current_loc_valid = FALSE;\n   f->first_decode = FALSE;\n   f->samples_output = 0;\n   f->channel_buffer_start = 0;\n   f->channel_buffer_end = 0;\n}\n\nstatic int vorbis_search_for_page_pushdata(vorb *f, uint8 *data, int data_len)\n{\n   int i,n;\n   for (i=0; i < f->page_crc_tests; ++i)\n      f->scan[i].bytes_done = 0;\n\n   // if we have room for more scans, search for them first, because\n   // they may cause us to stop early if their header is incomplete\n   if (f->page_crc_tests < STB_VORBIS_PUSHDATA_CRC_COUNT) {\n      if (data_len < 4) return 0;\n      data_len -= 3; // need to look for 4-byte sequence, so don't miss\n                     // one that straddles a boundary\n      for (i=0; i < data_len; ++i) {\n         if (data[i] == 0x4f) {\n            if (0==memcmp(data+i, ogg_page_header, 4)) {\n               int j,len;\n               uint32 crc;\n               // make sure we have the whole page header\n               if (i+26 >= data_len || i+27+data[i+26] >= data_len) {\n                  // only read up to this page start, so hopefully we'll\n                  // have the whole page header start next time\n                  data_len = i;\n                  break;\n               }\n               // ok, we have it all; compute the length of the page\n               len = 27 + data[i+26];\n               for (j=0; j < data[i+26]; ++j)\n                  len += data[i+27+j];\n               // scan everything up to the embedded crc (which we must 0)\n               crc = 0;\n               for (j=0; j < 22; ++j)\n                  crc = crc32_update(crc, data[i+j]);\n               // now process 4 0-bytes\n               for (   ; j < 26; ++j)\n                  crc = crc32_update(crc, 0);\n               // len is the total number of bytes we need to scan\n               n = f->page_crc_tests++;\n               f->scan[n].bytes_left = len-j;\n               f->scan[n].crc_so_far = crc;\n               f->scan[n].goal_crc = data[i+22] + (data[i+23] << 8) + (data[i+24]<<16) + (data[i+25]<<24);\n               // if the last frame on a page is continued to the next, then\n               // we can't recover the sample_loc immediately\n               if (data[i+27+data[i+26]-1] == 255)\n                  f->scan[n].sample_loc = ~0;\n               else\n                  f->scan[n].sample_loc = data[i+6] + (data[i+7] << 8) + (data[i+ 8]<<16) + (data[i+ 9]<<24);\n               f->scan[n].bytes_done = i+j;\n               if (f->page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)\n                  break;\n               // keep going if we still have room for more\n            }\n         }\n      }\n   }\n\n   for (i=0; i < f->page_crc_tests;) {\n      uint32 crc;\n      int j;\n      int n = f->scan[i].bytes_done;\n      int m = f->scan[i].bytes_left;\n      if (m > data_len - n) m = data_len - n;\n      // m is the bytes to scan in the current chunk\n      crc = f->scan[i].crc_so_far;\n      for (j=0; j < m; ++j)\n         crc = crc32_update(crc, data[n+j]);\n      f->scan[i].bytes_left -= m;\n      f->scan[i].crc_so_far = crc;\n      if (f->scan[i].bytes_left == 0) {\n         // does it match?\n         if (f->scan[i].crc_so_far == f->scan[i].goal_crc) {\n            // Houston, we have page\n            data_len = n+m; // consumption amount is wherever that scan ended\n            f->page_crc_tests = -1; // drop out of page scan mode\n            f->previous_length = 0; // decode-but-don't-output one frame\n            f->next_seg = -1;       // start a new page\n            f->current_loc = f->scan[i].sample_loc; // set the current sample location\n                                    // to the amount we'd have decoded had we decoded this page\n            f->current_loc_valid = f->current_loc != ~0U;\n            return data_len;\n         }\n         // delete entry\n         f->scan[i] = f->scan[--f->page_crc_tests];\n      } else {\n         ++i;\n      }\n   }\n\n   return data_len;\n}\n\n// return value: number of bytes we used\nint stb_vorbis_decode_frame_pushdata(\n         stb_vorbis *f,                   // the file we're decoding\n         const uint8 *data, int data_len, // the memory available for decoding\n         int *channels,                   // place to write number of float * buffers\n         float ***output,                 // place to write float ** array of float * buffers\n         int *samples                     // place to write number of output samples\n     )\n{\n   int i;\n   int len,right,left;\n\n   if (!IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (f->page_crc_tests >= 0) {\n      *samples = 0;\n      return vorbis_search_for_page_pushdata(f, (uint8 *) data, data_len);\n   }\n\n   f->stream     = (uint8 *) data;\n   f->stream_end = (uint8 *) data + data_len;\n   f->error      = VORBIS__no_error;\n\n   // check that we have the entire packet in memory\n   if (!is_whole_packet_present(f)) {\n      *samples = 0;\n      return 0;\n   }\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      // save the actual error we encountered\n      enum STBVorbisError error = f->error;\n      if (error == VORBIS_bad_packet_type) {\n         // flush and resynch\n         f->error = VORBIS__no_error;\n         while (get8_packet(f) != EOP)\n            if (f->eof) break;\n         *samples = 0;\n         return (int) (f->stream - data);\n      }\n      if (error == VORBIS_continued_packet_flag_invalid) {\n         if (f->previous_length == 0) {\n            // we may be resynching, in which case it's ok to hit one\n            // of these; just discard the packet\n            f->error = VORBIS__no_error;\n            while (get8_packet(f) != EOP)\n               if (f->eof) break;\n            *samples = 0;\n            return (int) (f->stream - data);\n         }\n      }\n      // if we get an error while parsing, what to do?\n      // well, it DEFINITELY won't work to continue from where we are!\n      stb_vorbis_flush_pushdata(f);\n      // restore the error that actually made us bail\n      f->error = error;\n      *samples = 0;\n      return 1;\n   }\n\n   // success!\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   if (channels) *channels = f->channels;\n   *samples = len;\n   *output = f->outputs;\n   return (int) (f->stream - data);\n}\n\nstb_vorbis *stb_vorbis_open_pushdata(\n         const unsigned char *data, int data_len, // the memory available for decoding\n         int *data_used,              // only defined if result is not NULL\n         int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.stream     = (uint8 *) data;\n   p.stream_end = (uint8 *) data + data_len;\n   p.push_mode  = TRUE;\n   if (!start_decoder(&p)) {\n      if (p.eof)\n         *error = VORBIS_need_more_data;\n      else\n         *error = p.error;\n      vorbis_deinit(&p);\n      return NULL;\n   }\n   f = vorbis_alloc(&p);\n   if (f) {\n      *f = p;\n      *data_used = (int) (f->stream - data);\n      *error = 0;\n      return f;\n   } else {\n      vorbis_deinit(&p);\n      return NULL;\n   }\n}\n#endif // STB_VORBIS_NO_PUSHDATA_API\n\nunsigned int stb_vorbis_get_file_offset(stb_vorbis *f)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   if (USE_MEMORY(f)) return (unsigned int) (f->stream - f->stream_start);\n   #ifndef STB_VORBIS_NO_STDIO\n   return (unsigned int) (ftell(f->f) - f->f_start);\n   #endif\n}\n\n#ifndef STB_VORBIS_NO_PULLDATA_API\n//\n// DATA-PULLING API\n//\n\nstatic uint32 vorbis_find_page(stb_vorbis *f, uint32 *end, uint32 *last)\n{\n   for(;;) {\n      int n;\n      if (f->eof) return 0;\n      n = get8(f);\n      if (n == 0x4f) { // page header candidate\n         unsigned int retry_loc = stb_vorbis_get_file_offset(f);\n         int i;\n         // check if we're off the end of a file_section stream\n         if (retry_loc - 25 > f->stream_len)\n            return 0;\n         // check the rest of the header\n         for (i=1; i < 4; ++i)\n            if (get8(f) != ogg_page_header[i])\n               break;\n         if (f->eof) return 0;\n         if (i == 4) {\n            uint8 header[27];\n            uint32 i, crc, goal, len;\n            for (i=0; i < 4; ++i)\n               header[i] = ogg_page_header[i];\n            for (; i < 27; ++i)\n               header[i] = get8(f);\n            if (f->eof) return 0;\n            if (header[4] != 0) goto invalid;\n            goal = header[22] + (header[23] << 8) + (header[24]<<16) + ((uint32)header[25]<<24);\n            for (i=22; i < 26; ++i)\n               header[i] = 0;\n            crc = 0;\n            for (i=0; i < 27; ++i)\n               crc = crc32_update(crc, header[i]);\n            len = 0;\n            for (i=0; i < header[26]; ++i) {\n               int s = get8(f);\n               crc = crc32_update(crc, s);\n               len += s;\n            }\n            if (len && f->eof) return 0;\n            for (i=0; i < len; ++i)\n               crc = crc32_update(crc, get8(f));\n            // finished parsing probable page\n            if (crc == goal) {\n               // we could now check that it's either got the last\n               // page flag set, OR it's followed by the capture\n               // pattern, but I guess TECHNICALLY you could have\n               // a file with garbage between each ogg page and recover\n               // from it automatically? So even though that paranoia\n               // might decrease the chance of an invalid decode by\n               // another 2^32, not worth it since it would hose those\n               // invalid-but-useful files?\n               if (end)\n                  *end = stb_vorbis_get_file_offset(f);\n               if (last) {\n                  if (header[5] & 0x04)\n                     *last = 1;\n                  else\n                     *last = 0;\n               }\n               set_file_offset(f, retry_loc-1);\n               return 1;\n            }\n         }\n        invalid:\n         // not a valid page, so rewind and look for next one\n         set_file_offset(f, retry_loc);\n      }\n   }\n}\n\n\n#define SAMPLE_unknown  0xffffffff\n\n// seeking is implemented with a binary search, which narrows down the range to\n// 64K, before using a linear search (because finding the synchronization\n// pattern can be expensive, and the chance we'd find the end page again is\n// relatively high for small ranges)\n//\n// two initial interpolation-style probes are used at the start of the search\n// to try to bound either side of the binary search sensibly, while still\n// working in O(log n) time if they fail.\n\nstatic int get_seek_page_info(stb_vorbis *f, ProbedPage *z)\n{\n   uint8 header[27], lacing[255];\n   int i,len;\n\n   // record where the page starts\n   z->page_start = stb_vorbis_get_file_offset(f);\n\n   // parse the header\n   getn(f, header, 27);\n   if (header[0] != 'O' || header[1] != 'g' || header[2] != 'g' || header[3] != 'S')\n      return 0;\n   getn(f, lacing, header[26]);\n\n   // determine the length of the payload\n   len = 0;\n   for (i=0; i < header[26]; ++i)\n      len += lacing[i];\n\n   // this implies where the page ends\n   z->page_end = z->page_start + 27 + header[26] + len;\n\n   // read the last-decoded sample out of the data\n   z->last_decoded_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);\n\n   // restore file state to where we were\n   set_file_offset(f, z->page_start);\n   return 1;\n}\n\n// rarely used function to seek back to the preceding page while finding the\n// start of a packet\nstatic int go_to_page_before(stb_vorbis *f, unsigned int limit_offset)\n{\n   unsigned int previous_safe, end;\n\n   // now we want to seek back 64K from the limit\n   if (limit_offset >= 65536 && limit_offset-65536 >= f->first_audio_page_offset)\n      previous_safe = limit_offset - 65536;\n   else\n      previous_safe = f->first_audio_page_offset;\n\n   set_file_offset(f, previous_safe);\n\n   while (vorbis_find_page(f, &end, NULL)) {\n      if (end >= limit_offset && stb_vorbis_get_file_offset(f) < limit_offset)\n         return 1;\n      set_file_offset(f, end);\n   }\n\n   return 0;\n}\n\n// implements the search logic for finding a page and starting decoding. if\n// the function succeeds, current_loc_valid will be true and current_loc will\n// be less than or equal to the provided sample number (the closer the\n// better).\nstatic int seek_to_sample_coarse(stb_vorbis *f, uint32 sample_number)\n{\n   ProbedPage left, right, mid;\n   int i, start_seg_with_known_loc, end_pos, page_start;\n   uint32 delta, stream_length, padding, last_sample_limit;\n   double offset = 0.0, bytes_per_sample = 0.0;\n   int probe = 0;\n\n   // find the last page and validate the target sample\n   stream_length = stb_vorbis_stream_length_in_samples(f);\n   if (stream_length == 0)            return error(f, VORBIS_seek_without_length);\n   if (sample_number > stream_length) return error(f, VORBIS_seek_invalid);\n\n   // this is the maximum difference between the window-center (which is the\n   // actual granule position value), and the right-start (which the spec\n   // indicates should be the granule position (give or take one)).\n   padding = ((f->blocksize_1 - f->blocksize_0) >> 2);\n   if (sample_number < padding)\n      last_sample_limit = 0;\n   else\n      last_sample_limit = sample_number - padding;\n\n   left = f->p_first;\n   while (left.last_decoded_sample == ~0U) {\n      // (untested) the first page does not have a 'last_decoded_sample'\n      set_file_offset(f, left.page_end);\n      if (!get_seek_page_info(f, &left)) goto error;\n   }\n\n   right = f->p_last;\n   assert(right.last_decoded_sample != ~0U);\n\n   // starting from the start is handled differently\n   if (last_sample_limit <= left.last_decoded_sample) {\n      if (stb_vorbis_seek_start(f)) {\n         if (f->current_loc > sample_number)\n            return error(f, VORBIS_seek_failed);\n         return 1;\n      }\n      return 0;\n   }\n\n   while (left.page_end != right.page_start) {\n      assert(left.page_end < right.page_start);\n      // search range in bytes\n      delta = right.page_start - left.page_end;\n      if (delta <= 65536) {\n         // there's only 64K left to search - handle it linearly\n         set_file_offset(f, left.page_end);\n      } else {\n         if (probe < 2) {\n            if (probe == 0) {\n               // first probe (interpolate)\n               double data_bytes = right.page_end - left.page_start;\n               bytes_per_sample = data_bytes / right.last_decoded_sample;\n               offset = left.page_start + bytes_per_sample * (last_sample_limit - left.last_decoded_sample);\n            } else {\n               // second probe (try to bound the other side)\n               double error = ((double) last_sample_limit - mid.last_decoded_sample) * bytes_per_sample;\n               if (error >= 0 && error <  8000) error =  8000;\n               if (error <  0 && error > -8000) error = -8000;\n               offset += error * 2;\n            }\n\n            // ensure the offset is valid\n            if (offset < left.page_end)\n               offset = left.page_end;\n            if (offset > right.page_start - 65536)\n               offset = right.page_start - 65536;\n\n            set_file_offset(f, (unsigned int) offset);\n         } else {\n            // binary search for large ranges (offset by 32K to ensure\n            // we don't hit the right page)\n            set_file_offset(f, left.page_end + (delta / 2) - 32768);\n         }\n\n         if (!vorbis_find_page(f, NULL, NULL)) goto error;\n      }\n\n      for (;;) {\n         if (!get_seek_page_info(f, &mid)) goto error;\n         if (mid.last_decoded_sample != ~0U) break;\n         // (untested) no frames end on this page\n         set_file_offset(f, mid.page_end);\n         assert(mid.page_start < right.page_start);\n      }\n\n      // if we've just found the last page again then we're in a tricky file,\n      // and we're close enough (if it wasn't an interpolation probe).\n      if (mid.page_start == right.page_start) {\n         if (probe >= 2 || delta <= 65536)\n            break;\n      } else {\n         if (last_sample_limit < mid.last_decoded_sample)\n            right = mid;\n         else\n            left = mid;\n      }\n\n      ++probe;\n   }\n\n   // seek back to start of the last packet\n   page_start = left.page_start;\n   set_file_offset(f, page_start);\n   if (!start_page(f)) return error(f, VORBIS_seek_failed);\n   end_pos = f->end_seg_with_known_loc;\n   assert(end_pos >= 0);\n\n   for (;;) {\n      for (i = end_pos; i > 0; --i)\n         if (f->segments[i-1] != 255)\n            break;\n\n      start_seg_with_known_loc = i;\n\n      if (start_seg_with_known_loc > 0 || !(f->page_flag & PAGEFLAG_continued_packet))\n         break;\n\n      // (untested) the final packet begins on an earlier page\n      if (!go_to_page_before(f, page_start))\n         goto error;\n\n      page_start = stb_vorbis_get_file_offset(f);\n      if (!start_page(f)) goto error;\n      end_pos = f->segment_count - 1;\n   }\n\n   // prepare to start decoding\n   f->current_loc_valid = FALSE;\n   f->last_seg = FALSE;\n   f->valid_bits = 0;\n   f->packet_bytes = 0;\n   f->bytes_in_seg = 0;\n   f->previous_length = 0;\n   f->next_seg = start_seg_with_known_loc;\n\n   for (i = 0; i < start_seg_with_known_loc; i++)\n      skip(f, f->segments[i]);\n\n   // start decoding (optimizable - this frame is generally discarded)\n   if (!vorbis_pump_first_frame(f))\n      return 0;\n   if (f->current_loc > sample_number)\n      return error(f, VORBIS_seek_failed);\n   return 1;\n\nerror:\n   // try to restore the file to a valid state\n   stb_vorbis_seek_start(f);\n   return error(f, VORBIS_seek_failed);\n}\n\n// the same as vorbis_decode_initial, but without advancing\nstatic int peek_decode_initial(vorb *f, int *p_left_start, int *p_left_end, int *p_right_start, int *p_right_end, int *mode)\n{\n   int bits_read, bytes_read;\n\n   if (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))\n      return 0;\n\n   // either 1 or 2 bytes were read, figure out which so we can rewind\n   bits_read = 1 + ilog(f->mode_count-1);\n   if (f->mode_config[*mode].blockflag)\n      bits_read += 2;\n   bytes_read = (bits_read + 7) / 8;\n\n   f->bytes_in_seg += bytes_read;\n   f->packet_bytes -= bytes_read;\n   skip(f, -bytes_read);\n   if (f->next_seg == -1)\n      f->next_seg = f->segment_count - 1;\n   else\n      f->next_seg--;\n   f->valid_bits = 0;\n\n   return 1;\n}\n\nint stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number)\n{\n   uint32 max_frame_samples;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   // fast page-level search\n   if (!seek_to_sample_coarse(f, sample_number))\n      return 0;\n\n   assert(f->current_loc_valid);\n   assert(f->current_loc <= sample_number);\n\n   // linear search for the relevant packet\n   max_frame_samples = (f->blocksize_1*3 - f->blocksize_0) >> 2;\n   while (f->current_loc < sample_number) {\n      int left_start, left_end, right_start, right_end, mode, frame_samples;\n      if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n         return error(f, VORBIS_seek_failed);\n      // calculate the number of samples returned by the next frame\n      frame_samples = right_start - left_start;\n      if (f->current_loc + frame_samples > sample_number) {\n         return 1; // the next frame will contain the sample\n      } else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n         // there's a chance the frame after this could contain the sample\n         vorbis_pump_first_frame(f);\n      } else {\n         // this frame is too early to be relevant\n         f->current_loc += frame_samples;\n         f->previous_length = 0;\n         maybe_start_packet(f);\n         flush_packet(f);\n      }\n   }\n   // the next frame should start with the sample\n   if (f->current_loc != sample_number) return error(f, VORBIS_seek_failed);\n   return 1;\n}\n\nint stb_vorbis_seek(stb_vorbis *f, unsigned int sample_number)\n{\n   if (!stb_vorbis_seek_frame(f, sample_number))\n      return 0;\n\n   if (sample_number != f->current_loc) {\n      int n;\n      uint32 frame_start = f->current_loc;\n      stb_vorbis_get_frame_float(f, &n, NULL);\n      assert(sample_number > frame_start);\n      assert(f->channel_buffer_start + (int) (sample_number-frame_start) <= f->channel_buffer_end);\n      f->channel_buffer_start += (sample_number - frame_start);\n   }\n\n   return 1;\n}\n\nint stb_vorbis_seek_start(stb_vorbis *f)\n{\n   if (IS_PUSH_MODE(f)) { return error(f, VORBIS_invalid_api_mixing); }\n   set_file_offset(f, f->first_audio_page_offset);\n   f->previous_length = 0;\n   f->first_decode = TRUE;\n   f->next_seg = -1;\n   return vorbis_pump_first_frame(f);\n}\n\nunsigned int stb_vorbis_stream_length_in_samples(stb_vorbis *f)\n{\n   unsigned int restore_offset, previous_safe;\n   unsigned int end, last_page_loc;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n   if (!f->total_samples) {\n      unsigned int last;\n      uint32 lo,hi;\n      char header[6];\n\n      // first, store the current decode position so we can restore it\n      restore_offset = stb_vorbis_get_file_offset(f);\n\n      // now we want to seek back 64K from the end (the last page must\n      // be at most a little less than 64K, but let's allow a little slop)\n      if (f->stream_len >= 65536 && f->stream_len-65536 >= f->first_audio_page_offset)\n         previous_safe = f->stream_len - 65536;\n      else\n         previous_safe = f->first_audio_page_offset;\n\n      set_file_offset(f, previous_safe);\n      // previous_safe is now our candidate 'earliest known place that seeking\n      // to will lead to the final page'\n\n      if (!vorbis_find_page(f, &end, &last)) {\n         // if we can't find a page, we're hosed!\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = 0xffffffff;\n         goto done;\n      }\n\n      // check if there are more pages\n      last_page_loc = stb_vorbis_get_file_offset(f);\n\n      // stop when the last_page flag is set, not when we reach eof;\n      // this allows us to stop short of a 'file_section' end without\n      // explicitly checking the length of the section\n      while (!last) {\n         set_file_offset(f, end);\n         if (!vorbis_find_page(f, &end, &last)) {\n            // the last page we found didn't have the 'last page' flag\n            // set. whoops!\n            break;\n         }\n         //previous_safe = last_page_loc+1; // NOTE: not used after this point, but note for debugging\n         last_page_loc = stb_vorbis_get_file_offset(f);\n      }\n\n      set_file_offset(f, last_page_loc);\n\n      // parse the header\n      getn(f, (unsigned char *)header, 6);\n      // extract the absolute granule position\n      lo = get32(f);\n      hi = get32(f);\n      if (lo == 0xffffffff && hi == 0xffffffff) {\n         f->error = VORBIS_cant_find_last_page;\n         f->total_samples = SAMPLE_unknown;\n         goto done;\n      }\n      if (hi)\n         lo = 0xfffffffe; // saturate\n      f->total_samples = lo;\n\n      f->p_last.page_start = last_page_loc;\n      f->p_last.page_end   = end;\n      f->p_last.last_decoded_sample = lo;\n\n     done:\n      set_file_offset(f, restore_offset);\n   }\n   return f->total_samples == SAMPLE_unknown ? 0 : f->total_samples;\n}\n\nfloat stb_vorbis_stream_length_in_seconds(stb_vorbis *f)\n{\n   return stb_vorbis_stream_length_in_samples(f) / (float) f->sample_rate;\n}\n\n\n\nint stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)\n{\n   int len, right,left,i;\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      f->channel_buffer_start = f->channel_buffer_end = 0;\n      return 0;\n   }\n\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   f->channel_buffer_start = left;\n   f->channel_buffer_end   = left+len;\n\n   if (channels) *channels = f->channels;\n   if (output)   *output = f->outputs;\n   return len;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_file_section(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc, unsigned int length)\n{\n   stb_vorbis *f, p;\n   vorbis_init(&p, alloc);\n   p.f = file;\n   p.f_start = (uint32) ftell(file);\n   p.stream_len   = length;\n   p.close_on_free = close_on_free;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\nstb_vorbis * stb_vorbis_open_file(FILE *file, int close_on_free, int *error, const stb_vorbis_alloc *alloc)\n{\n   unsigned int len, start;\n   start = (unsigned int) ftell(file);\n   fseek(file, 0, SEEK_END);\n   len = (unsigned int) (ftell(file) - start);\n   fseek(file, start, SEEK_SET);\n   return stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);\n}\n\nstb_vorbis * stb_vorbis_open_filename(const char *filename, int *error, const stb_vorbis_alloc *alloc)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   if (0 != fopen_s(&f, filename, \"rb\"))\n      f = NULL;\n#else\n   f = fopen(filename, \"rb\");\n#endif\n   if (f)\n      return stb_vorbis_open_file(f, TRUE, error, alloc);\n   if (error) *error = VORBIS_file_open_failure;\n   return NULL;\n}\n#endif // STB_VORBIS_NO_STDIO\n\nstb_vorbis * stb_vorbis_open_memory(const unsigned char *data, int len, int *error, const stb_vorbis_alloc *alloc)\n{\n   stb_vorbis *f, p;\n   if (!data) {\n      if (error) *error = VORBIS_unexpected_eof;\n      return NULL;\n   }\n   vorbis_init(&p, alloc);\n   p.stream = (uint8 *) data;\n   p.stream_end = (uint8 *) data + len;\n   p.stream_start = (uint8 *) p.stream;\n   p.stream_len = len;\n   p.push_mode = FALSE;\n   if (start_decoder(&p)) {\n      f = vorbis_alloc(&p);\n      if (f) {\n         *f = p;\n         vorbis_pump_first_frame(f);\n         if (error) *error = VORBIS__no_error;\n         return f;\n      }\n   }\n   if (error) *error = p.error;\n   vorbis_deinit(&p);\n   return NULL;\n}\n\n#ifndef STB_VORBIS_NO_INTEGER_CONVERSION\n#define PLAYBACK_MONO     1\n#define PLAYBACK_LEFT     2\n#define PLAYBACK_RIGHT    4\n\n#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)\n#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)\n#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)\n\nstatic int8 channel_position[7][6] =\n{\n   { 0 },\n   { C },\n   { L, R },\n   { L, C, R },\n   { L, R, L, R },\n   { L, C, R, L, R },\n   { L, C, R, L, R, C },\n};\n\n\n#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT\n   typedef union {\n      float f;\n      int i;\n   } float_conv;\n   typedef char stb_vorbis_float_size_test[sizeof(float)==4 && sizeof(int) == 4];\n   #define FASTDEF(x) float_conv x\n   // add (1<<23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round\n   #define MAGIC(SHIFT) (1.5f * (1 << (23-SHIFT)) + 0.5f/(1 << SHIFT))\n   #define ADDEND(SHIFT) (((150-SHIFT) << 23) + (1 << 22))\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))\n   #define check_endianness()\n#else\n   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 << (s))))\n   #define check_endianness()\n   #define FASTDEF(x)\n#endif\n\nstatic void copy_samples(short *dest, float *src, int len)\n{\n   int i;\n   check_endianness();\n   for (i=0; i < len; ++i) {\n      FASTDEF(temp);\n      int v = FAST_SCALED_FLOAT_TO_INT(temp, src[i],15);\n      if ((unsigned int) (v + 32768) > 65535)\n         v = v < 0 ? -32768 : 32767;\n      dest[i] = v;\n   }\n}\n\nstatic void compute_samples(int mask, short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define STB_BUFFER_SIZE  32\n   float buffer[STB_BUFFER_SIZE];\n   int i,j,o,n = STB_BUFFER_SIZE;\n   check_endianness();\n   for (o = 0; o < len; o += STB_BUFFER_SIZE) {\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         if (channel_position[num_c][j] & mask) {\n            for (i=0; i < n; ++i)\n               buffer[i] += data[j][d_offset+o+i];\n         }\n      }\n      for (i=0; i < n; ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o+i] = v;\n      }\n   }\n   #undef STB_BUFFER_SIZE\n}\n\nstatic void compute_stereo_samples(short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define STB_BUFFER_SIZE  32\n   float buffer[STB_BUFFER_SIZE];\n   int i,j,o,n = STB_BUFFER_SIZE >> 1;\n   // o is the offset in the source data\n   check_endianness();\n   for (o = 0; o < len; o += STB_BUFFER_SIZE >> 1) {\n      // o2 is the offset in the output data\n      int o2 = o << 1;\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         int m = channel_position[num_c][j] & (PLAYBACK_LEFT | PLAYBACK_RIGHT);\n         if (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_LEFT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+0] += data[j][d_offset+o+i];\n            }\n         } else if (m == PLAYBACK_RIGHT) {\n            for (i=0; i < n; ++i) {\n               buffer[i*2+1] += data[j][d_offset+o+i];\n            }\n         }\n      }\n      for (i=0; i < (n<<1); ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o2+i] = v;\n      }\n   }\n   #undef STB_BUFFER_SIZE\n}\n\nstatic void convert_samples_short(int buf_c, short **buffer, int b_offset, int data_c, float **data, int d_offset, int samples)\n{\n   int i;\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      static int channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };\n      for (i=0; i < buf_c; ++i)\n         compute_samples(channel_selector[buf_c][i], buffer[i]+b_offset, data_c, data, d_offset, samples);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      for (i=0; i < limit; ++i)\n         copy_samples(buffer[i]+b_offset, data[i]+d_offset, samples);\n      for (   ; i < buf_c; ++i)\n         memset(buffer[i]+b_offset, 0, sizeof(short) * samples);\n   }\n}\n\nint stb_vorbis_get_frame_short(stb_vorbis *f, int num_c, short **buffer, int num_samples)\n{\n   float **output = NULL;\n   int len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len > num_samples) len = num_samples;\n   if (len)\n      convert_samples_short(num_c, buffer, 0, f->channels, output, 0, len);\n   return len;\n}\n\nstatic void convert_channels_short_interleaved(int buf_c, short *buffer, int data_c, float **data, int d_offset, int len)\n{\n   int i;\n   check_endianness();\n   if (buf_c != data_c && buf_c <= 2 && data_c <= 6) {\n      assert(buf_c == 2);\n      for (i=0; i < buf_c; ++i)\n         compute_stereo_samples(buffer, data_c, data, d_offset, len);\n   } else {\n      int limit = buf_c < data_c ? buf_c : data_c;\n      int j;\n      for (j=0; j < len; ++j) {\n         for (i=0; i < limit; ++i) {\n            FASTDEF(temp);\n            float f = data[i][d_offset+j];\n            int v = FAST_SCALED_FLOAT_TO_INT(temp, f,15);//data[i][d_offset+j],15);\n            if ((unsigned int) (v + 32768) > 65535)\n               v = v < 0 ? -32768 : 32767;\n            *buffer++ = v;\n         }\n         for (   ; i < buf_c; ++i)\n            *buffer++ = 0;\n      }\n   }\n}\n\nint stb_vorbis_get_frame_short_interleaved(stb_vorbis *f, int num_c, short *buffer, int num_shorts)\n{\n   float **output;\n   int len;\n   if (num_c == 1) return stb_vorbis_get_frame_short(f,num_c,&buffer, num_shorts);\n   len = stb_vorbis_get_frame_float(f, NULL, &output);\n   if (len) {\n      if (len*num_c > num_shorts) len = num_shorts / num_c;\n      convert_channels_short_interleaved(num_c, buffer, f->channels, output, 0, len);\n   }\n   return len;\n}\n\nint stb_vorbis_get_samples_short_interleaved(stb_vorbis *f, int channels, short *buffer, int num_shorts)\n{\n   float **outputs;\n   int len = num_shorts / channels;\n   int n=0;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_channels_short_interleaved(channels, buffer, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      buffer += k*channels;\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_short(stb_vorbis *f, int channels, short **buffer, int len)\n{\n   float **outputs;\n   int n=0;\n   while (n < len) {\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      if (k)\n         convert_samples_short(channels, buffer, n, f->channels, f->channel_buffers, f->channel_buffer_start, k);\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len) break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs)) break;\n   }\n   return n;\n}\n\n#ifndef STB_VORBIS_NO_STDIO\nint stb_vorbis_decode_filename(const char *filename, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_filename(filename, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // NO_STDIO\n\nint stb_vorbis_decode_memory(const uint8 *mem, int len, int *channels, int *sample_rate, short **output)\n{\n   int data_len, offset, total, limit, error;\n   short *data;\n   stb_vorbis *v = stb_vorbis_open_memory(mem, len, &error, NULL);\n   if (v == NULL) return -1;\n   limit = v->channels * 4096;\n   *channels = v->channels;\n   if (sample_rate)\n      *sample_rate = v->sample_rate;\n   offset = data_len = 0;\n   total = limit;\n   data = (short *) malloc(total * sizeof(*data));\n   if (data == NULL) {\n      stb_vorbis_close(v);\n      return -2;\n   }\n   for (;;) {\n      int n = stb_vorbis_get_frame_short_interleaved(v, v->channels, data+offset, total-offset);\n      if (n == 0) break;\n      data_len += n;\n      offset += n * v->channels;\n      if (offset + limit > total) {\n         short *data2;\n         total *= 2;\n         data2 = (short *) realloc(data, total * sizeof(*data));\n         if (data2 == NULL) {\n            free(data);\n            stb_vorbis_close(v);\n            return -2;\n         }\n         data = data2;\n      }\n   }\n   *output = data;\n   stb_vorbis_close(v);\n   return data_len;\n}\n#endif // STB_VORBIS_NO_INTEGER_CONVERSION\n\nint stb_vorbis_get_samples_float_interleaved(stb_vorbis *f, int channels, float *buffer, int num_floats)\n{\n   float **outputs;\n   int len = num_floats / channels;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < len) {\n      int i,j;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= len) k = len - n;\n      for (j=0; j < k; ++j) {\n         for (i=0; i < z; ++i)\n            *buffer++ = f->channel_buffers[i][f->channel_buffer_start+j];\n         for (   ; i < channels; ++i)\n            *buffer++ = 0;\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == len)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n\nint stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, int num_samples)\n{\n   float **outputs;\n   int n=0;\n   int z = f->channels;\n   if (z > channels) z = channels;\n   while (n < num_samples) {\n      int i;\n      int k = f->channel_buffer_end - f->channel_buffer_start;\n      if (n+k >= num_samples) k = num_samples - n;\n      if (k) {\n         for (i=0; i < z; ++i)\n            memcpy(buffer[i]+n, f->channel_buffers[i]+f->channel_buffer_start, sizeof(float)*k);\n         for (   ; i < channels; ++i)\n            memset(buffer[i]+n, 0, sizeof(float) * k);\n      }\n      n += k;\n      f->channel_buffer_start += k;\n      if (n == num_samples)\n         break;\n      if (!stb_vorbis_get_frame_float(f, NULL, &outputs))\n         break;\n   }\n   return n;\n}\n#endif // STB_VORBIS_NO_PULLDATA_API\n\n/* Version history\n    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13222, -13223\n                           found with Mayhem by ForAllSecure\n    1.16    - 2019-03-04 - fix warnings\n    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n    1.14    - 2018-02-11 - delete bogus dealloca usage\n    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files\n    1.11    - 2017-07-23 - fix MinGW compilation\n    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory\n    1.09    - 2016-04-04 - back out 'avoid discarding last frame' fix from previous version\n    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;\n                           avoid discarding last frame of audio data\n    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API\n                           some more crash fixes when out of memory or with corrupt files\n    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)\n                           some crash fixes when out of memory or with corrupt files\n    1.05    - 2015-04-19 - don't define __forceinline if it's redundant\n    1.04    - 2014-08-27 - fix missing const-correct case in API\n    1.03    - 2014-08-07 - Warning fixes\n    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows\n    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float\n    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel\n                           (API change) report sample rate for decode-full-file funcs\n    0.99996 - bracket #include <malloc.h> for macintosh compilation by Laurent Gomila\n    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem\n    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence\n    0.99993 - remove assert that fired on legal files with empty tables\n    0.99992 - rewind-to-start\n    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo\n    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++\n    0.9998 - add a full-decode function with a memory source\n    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition\n    0.9996 - query length of vorbis stream in samples/seconds\n    0.9995 - bugfix to another optimization that only happened in certain files\n    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors\n    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation\n    0.9992 - performance improvement of IMDCT; now performs close to reference implementation\n    0.9991 - performance improvement of IMDCT\n    0.999 - (should have been 0.9990) performance improvement of IMDCT\n    0.998 - no-CRT support from Casey Muratori\n    0.997 - bugfixes for bugs found by Terje Mathisen\n    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen\n    0.995 - bugfix: fix to 'effective' overrun detection - found by Terje Mathisen\n    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen\n    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen\n    0.992 - fixes for MinGW warning\n    0.991 - turn fast-float-conversion on by default\n    0.990 - fix push-mode seek recovery if you seek into the headers\n    0.98b - fix to bad release of 0.98\n    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode\n    0.97 - builds under c++ (typecasting, don't use 'class' keyword)\n    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code\n    0.95 - clamping code for 16-bit functions\n    0.94 - not publically released\n    0.93 - fixed all-zero-floor case (was decoding garbage)\n    0.92 - fixed a memory leak\n    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION\n    0.90 - first public release\n*/\n\n#endif // STB_VORBIS_HEADER_ONLY\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "stb_voxel_render.h",
          "type": "blob",
          "size": 157.37890625,
          "content": "// stb_voxel_render.h - v0.89 - Sean Barrett, 2015 - public domain\n//\n// This library helps render large-scale \"voxel\" worlds for games,\n// in this case, one with blocks that can have textures and that\n// can also be a few shapes other than cubes.\n//\n//    Video introduction:\n//       http://www.youtube.com/watch?v=2vnTtiLrV1w\n//\n//    Minecraft-viewer sample app (not very simple though):\n//       http://github.com/nothings/stb/tree/master/tests/caveview\n//\n// It works by creating triangle meshes. The library includes\n//\n//    - converter from dense 3D arrays of block info to vertex mesh\n//    - vertex & fragment shaders for the vertex mesh\n//    - assistance in setting up shader state\n//\n// For portability, none of the library code actually accesses\n// the 3D graphics API. (At the moment, it's not actually portable\n// since the shaders are GLSL only, but patches are welcome.)\n//\n// You have to do all the caching and tracking of vertex buffers\n// yourself. However, you could also try making a game with\n// a small enough world that it's fully loaded rather than\n// streaming. Currently the preferred vertex format is 20 bytes\n// per quad. There are designs to allow much more compact formats\n// with a slight reduction in shader features, but no roadmap\n// for actually implementing them.\n//\n//\n// USAGE\n//\n//   #define the symbol STB_VOXEL_RENDER_IMPLEMENTATION in *one*\n//   C/C++ file before the #include of this file; the implementation\n//   will be generated in that file.\n//\n//   If you define the symbols STB_VOXEL_RENDER_STATIC, then the\n//   implementation will be private to that file.\n//\n//\n// FEATURES\n//\n//   - you can choose textured blocks with the features below,\n//     or colored voxels with 2^24 colors and no textures.\n//\n//   - voxels are mostly just cubes, but there's support for\n//     half-height cubes and diagonal slopes, half-height\n//     diagonals, and even odder shapes especially for doing\n//     more-continuous \"ground\".\n//\n//   - texture coordinates are projections along one of the major\n//     axes, with the per-texture scaling.\n//\n//   - a number of aspects of the shader and the vertex format\n//     are configurable; the library generally takes care of\n//     coordinating the vertex format with the mesh for you.\n//\n//\n// FEATURES (SHADER PERSPECTIVE)\n//\n//   - vertices aligned on integer lattice, z on multiples of 0.5\n//   - per-vertex \"lighting\" or \"ambient occlusion\" value (6 bits)\n//   - per-vertex texture crossfade (3 bits)\n//\n//   - per-face texture #1 id (8-bit index into array texture)\n//   - per-face texture #2 id (8-bit index into second array texture)\n//   - per-face color (6-bit palette index, 2 bits of per-texture boolean enable)\n//   - per-face 5-bit normal for lighting calculations & texture coord computation\n//   - per-face 2-bit texture matrix rotation to rotate faces\n//\n//   - indexed-by-texture-id scale factor (separate for texture #1 and texture #2)\n//   - indexed-by-texture-#2-id blend mode (alpha composite or modulate/multiply);\n//     the first is good for decals, the second for detail textures, \"light maps\",\n//     etc; both modes are controlled by texture #2's alpha, scaled by the\n//     per-vertex texture crossfade and the per-face color (if enabled on texture #2);\n//     modulate/multiply multiplies by an extra factor of 2.0 so that if you\n//     make detail maps whose average brightness is 0.5 everything works nicely.\n//\n//   - ambient lighting: half-lambert directional plus constant, all scaled by vertex ao\n//   - face can be fullbright (emissive), controlled by per-face color\n//   - installable lighting, with default single-point-light\n//   - installable fog, with default hacked smoothstep\n//\n//  Note that all the variations of lighting selection and texture\n//  blending are run-time conditions in the shader, so they can be\n//  intermixed in a single mesh.\n//\n//\n// INTEGRATION ARC\n//\n//   The way to get this library to work from scratch is to do the following:\n//\n//      Step 1. define STBVOX_CONFIG_MODE to 0\n//\n//        This mode uses only vertex attributes and uniforms, and is easiest\n//        to get working. It requires 32 bytes per quad and limits the\n//        size of some tables to avoid hitting uniform limits.\n//\n//      Step 2. define STBVOX_CONFIG_MODE to 1\n//\n//        This requires using a texture buffer to store the quad data,\n//        reducing the size to 20 bytes per quad.\n//\n//      Step 3: define STBVOX_CONFIG_PREFER_TEXBUFFER\n//\n//        This causes some uniforms to be stored as texture buffers\n//        instead. This increases the size of some of those tables,\n//        and avoids a potential slow path (gathering non-uniform\n//        data from uniforms) on some hardware.\n//\n//   In the future I might add additional modes that have significantly\n//   smaller meshes but reduce features, down as small as 6 bytes per quad.\n//   See elsewhere in this file for a table of candidate modes. Switching\n//   to a mode will require changing some of your mesh creation code, but\n//   everything else should be seamless. (And I'd like to change the API\n//   so that mesh creation is data-driven the way the uniforms are, and\n//   then you wouldn't even have to change anything but the mode number.)\n//\n//\n// IMPROVEMENTS FOR SHIP-WORTHY PROGRAMS USING THIS LIBRARY\n//\n//   I currently tolerate a certain level of \"bugginess\" in this library.\n//\n//   I'm referring to things which look a little wrong (as long as they\n//   don't cause holes or cracks in the output meshes), or things which\n//   do not produce as optimal a mesh as possible. Notable examples:\n//\n//        -  incorrect lighting on slopes\n//        -  inefficient meshes for vheight blocks\n//\n//   I am willing to do the work to improve these things if someone is\n//   going to ship a substantial program that would be improved by them.\n//   (It need not be commercial, nor need it be a game.) I just didn't\n//   want to do the work up front if it might never be leveraged. So just\n//   submit a bug report as usual (github is preferred), but add a note\n//   that this is for a thing that is really going to ship. (That means\n//   you need to be far enough into the project that it's clear you're\n//   committed to it; not during early exploratory development.)\n//\n//\n// VOXEL MESH API\n//\n//   Context\n//\n//     To understand the API, make sure you first understand the feature set\n//     listed above.\n//\n//     Because the vertices are compact, they have very limited spatial\n//     precision. Thus a single mesh can only contain the data for a limited\n//     area. To make very large voxel maps, you'll need to build multiple\n//     vertex buffers. (But you want this anyway for frustum culling.)\n//\n//     Each generated mesh has three components:\n//             - vertex data (vertex buffer)\n//             - face data (optional, stored in texture buffer)\n//             - mesh transform (uniforms)\n//\n//     Once you've generated the mesh with this library, it's up to you\n//     to upload it to the GPU, to keep track of the state, and to render\n//     it.\n//\n//   Concept\n//\n//     The basic design is that you pass in one or more 3D arrays; each array\n//     is (typically) one-byte-per-voxel and contains information about one\n//     or more properties of some particular voxel property.\n//\n//     Because there is so much per-vertex and per-face data possible\n//     in the output, and each voxel can have 6 faces and 8 vertices, it\n//     would require an very large data structure to describe all\n//     of the possibilities, and this would cause the mesh-creation\n//     process to be slow. Instead, the API provides multiple ways\n//     to express each property, some more compact, others less so;\n//     each such way has some limitations on what it can express.\n//\n//     Note that there are so many paths and combinations, not all of them\n//     have been tested. Just report bugs and I'll fix 'em.\n//\n//   Details\n//\n//     See the API documentation in the header-file section.\n//\n//\n// CONTRIBUTORS\n//\n//   Features             Porting            Bugfixes & Warnings\n//  Sean Barrett                          github:r-leyh   Jesus Fernandez\n//                                        Miguel Lechon   github:Arbeiterunfallversicherungsgesetz\n//                                        Thomas Frase    James Hofmann\n//                                        Stephen Olsen   github:guitarfreak\n//\n// VERSION HISTORY\n//\n//   0.89   (2020-02-02)  bugfix in sample code\n//   0.88   (2019-03-04)  fix warnings\n//   0.87   (2019-02-25)  fix warning\n//   0.86   (2019-02-07)  fix typos in comments\n//   0.85   (2017-03-03)  add block_selector (by guitarfreak)\n//   0.84   (2016-04-02)  fix GLSL syntax error on glModelView path\n//   0.83   (2015-09-13)  remove non-constant struct initializers to support more compilers\n//   0.82   (2015-08-01)  added input.packed_compact to store rot, vheight & texlerp efficiently\n//                        fix broken tex_overlay2\n//   0.81   (2015-05-28)  fix broken STBVOX_CONFIG_OPTIMIZED_VHEIGHT\n//   0.80   (2015-04-11)  fix broken STBVOX_CONFIG_ROTATION_IN_LIGHTING refactoring\n//                        change STBVOX_MAKE_LIGHTING to STBVOX_MAKE_LIGHTING_EXT so\n//                                    that header defs don't need to see config vars\n//                        add STBVOX_CONFIG_VHEIGHT_IN_LIGHTING and other vheight fixes\n//                        added documentation for vheight (\"weird slopes\")\n//   0.79   (2015-04-01)  fix the missing types from 0.78; fix string constants being const\n//   0.78   (2015-04-02)  bad \"#else\", compile as C++\n//   0.77   (2015-04-01)  documentation tweaks, rename config var to STB_VOXEL_RENDER_STATIC\n//   0.76   (2015-04-01)  typos, signed/unsigned shader issue, more documentation\n//   0.75   (2015-04-01)  initial release\n//\n//\n// HISTORICAL FOUNDATION\n//\n//   stb_voxel_render   20-byte quads   2015/01\n//   zmc engine         32-byte quads   2013/12\n//   zmc engine         96-byte quads   2011/10\n//\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n#ifndef INCLUDE_STB_VOXEL_RENDER_H\n#define INCLUDE_STB_VOXEL_RENDER_H\n\n#include <stdlib.h>\n\ntypedef struct stbvox_mesh_maker stbvox_mesh_maker;\ntypedef struct stbvox_input_description stbvox_input_description;\n\n#ifdef STB_VOXEL_RENDER_STATIC\n#define STBVXDEC static\n#else\n#define STBVXDEC extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CONFIGURATION MACROS\n//\n//  #define STBVOX_CONFIG_MODE <integer>           // REQUIRED\n//     Configures the overall behavior of stb_voxel_render. This\n//     can affect the shaders, the uniform info, and other things.\n//     (If you need more than one mode in the same app, you can\n//     use STB_VOXEL_RENDER_STATIC to create multiple versions\n//     in separate files, and then wrap them.)\n//\n//         Mode value       Meaning\n//             0               Textured blocks, 32-byte quads\n//             1               Textured blocks, 20-byte quads\n//            20               Untextured blocks, 32-byte quads\n//            21               Untextured blocks, 20-byte quads\n//\n//\n//  #define STBVOX_CONFIG_PRECISION_Z  <integer>   // OPTIONAL\n//     Defines the number of bits of fractional position for Z.\n//     Only 0 or 1 are valid. 1 is the default. If 0, then a\n//     single mesh has twice the legal Z range; e.g. in\n//     modes 0,1,20,21, Z in the mesh can extend to 511 instead\n//     of 255. However, half-height blocks cannot be used.\n//\n// All of the following are just #ifdef tested so need no values, and are optional.\n//\n//    STBVOX_CONFIG_BLOCKTYPE_SHORT\n//        use unsigned 16-bit values for 'blocktype' in the input instead of 8-bit values\n//\n//    STBVOX_CONFIG_OPENGL_MODELVIEW\n//        use the gl_ModelView matrix rather than the explicit uniform\n//\n//    STBVOX_CONFIG_HLSL\n//        NOT IMPLEMENTED! Define HLSL shaders instead of GLSL shaders\n//\n//    STBVOX_CONFIG_PREFER_TEXBUFFER\n//        Stores many of the uniform arrays in texture buffers instead,\n//        so they can be larger and may be more efficient on some hardware.\n//\n//    STBVOX_CONFIG_LIGHTING_SIMPLE\n//        Creates a simple lighting engine with a single point light source\n//        in addition to the default half-lambert ambient light.\n//\n//    STBVOX_CONFIG_LIGHTING\n//        Declares a lighting function hook; you must append a lighting function\n//        to the shader before compiling it:\n//            vec3 compute_lighting(vec3 pos, vec3 norm, vec3 albedo, vec3 ambient);\n//        'ambient' is the half-lambert ambient light with vertex ambient-occlusion applied\n//\n//    STBVOX_CONFIG_FOG_SMOOTHSTEP\n//        Defines a simple unrealistic fog system designed to maximize\n//        unobscured view distance while not looking too weird when things\n//        emerge from the fog. Configured using an extra array element\n//        in the STBVOX_UNIFORM_ambient uniform.\n//\n//    STBVOX_CONFIG_FOG\n//        Defines a fog function hook; you must append a fog function to\n//        the shader before compiling it:\n//            vec3 compute_fog(vec3 color, vec3 relative_pos, float fragment_alpha);\n//        \"color\" is the incoming pre-fogged color, fragment_alpha is the alpha value,\n//        and relative_pos is the vector from the point to the camera in worldspace\n//\n//    STBVOX_CONFIG_DISABLE_TEX2\n//        This disables all processing of texture 2 in the shader in case\n//        you don't use it. Eventually this could be replaced with a mode\n//        that omits the unused data entirely.\n//\n//    STBVOX_CONFIG_TEX1_EDGE_CLAMP\n//    STBVOX_CONFIG_TEX2_EDGE_CLAMP\n//        If you want to edge clamp the textures, instead of letting them wrap,\n//        set this flag. By default stb_voxel_render relies on texture wrapping\n//        to simplify texture coordinate generation. This flag forces it to do\n//        it correctly, although there can still be minor artifacts.\n//\n//    STBVOX_CONFIG_ROTATION_IN_LIGHTING\n//        Changes the meaning of the 'lighting' mesher input variable to also\n//        store the rotation; see later discussion.\n//\n//    STBVOX_CONFIG_VHEIGHT_IN_LIGHTING\n//        Changes the meaning of the 'lighting' mesher input variable to also\n//        store the vheight; see later discussion. Cannot use both this and\n//        the previous variable.\n//\n//    STBVOX_CONFIG_PREMULTIPLIED_ALPHA\n//        Adjusts the shader calculations on the assumption that tex1.rgba,\n//        tex2.rgba, and color.rgba all use premultiplied values, and that\n//        the output of the fragment shader should be premultiplied.\n//\n//    STBVOX_CONFIG_UNPREMULTIPLY\n//        Only meaningful if STBVOX_CONFIG_PREMULTIPLIED_ALPHA is defined.\n//        Changes the behavior described above so that the inputs are\n//        still premultiplied alpha, but the output of the fragment\n//        shader is not premultiplied alpha. This is needed when allowing\n//        non-unit alpha values but not doing alpha-blending (for example\n//        when alpha testing).\n//\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// MESHING\n//\n// A mesh represents a (typically) small chunk of a larger world.\n// Meshes encode coordinates using small integers, so those\n// coordinates must be relative to some base location.\n// All of the coordinates in the functions below use\n// these relative coordinates unless explicitly stated\n// otherwise.\n//\n// Input to the meshing step is documented further down\n\nSTBVXDEC void stbvox_init_mesh_maker(stbvox_mesh_maker *mm);\n// Call this function to initialize a mesh-maker context structure\n// used to build meshes. You should have one context per thread\n// that's building meshes.\n\nSTBVXDEC void stbvox_set_buffer(stbvox_mesh_maker *mm, int mesh, int slot, void *buffer, size_t len);\n// Call this to set the buffer into which stbvox will write the mesh\n// it creates. It can build more than one mesh in parallel (distinguished\n// by the 'mesh' parameter), and each mesh can be made up of more than\n// one buffer (distinguished by the 'slot' parameter).\n//\n// Multiple meshes are under your control; use the 'selector' input\n// variable to choose which mesh each voxel's vertices are written to.\n// For example, you can use this to generate separate meshes for opaque\n// and transparent data.\n//\n// You can query the number of slots by calling stbvox_get_buffer_count\n// described below. The meaning of the buffer for each slot depends\n// on STBVOX_CONFIG_MODE.\n//\n//   In mode 0 & mode 20, there is only one slot. The mesh data for that\n//   slot is two interleaved vertex attributes: attr_vertex, a single\n//   32-bit uint, and attr_face, a single 32-bit uint.\n//\n//   In mode 1 & mode 21, there are two slots. The first buffer should\n//   be four times as large as the second buffer. The first buffer\n//   contains a single vertex attribute: 'attr_vertex', a single 32-bit uint.\n//   The second buffer contains texture buffer data (an array of 32-bit uints)\n//   that will be accessed through the sampler identified by STBVOX_UNIFORM_face_data.\n\nSTBVXDEC int stbvox_get_buffer_count(stbvox_mesh_maker *mm);\n// Returns the number of buffers needed per mesh as described above.\n\nSTBVXDEC int stbvox_get_buffer_size_per_quad(stbvox_mesh_maker *mm, int slot);\n// Returns how much of a given buffer will get used per quad. This\n// allows you to choose correct relative sizes for each buffer, although\n// the values are fixed based on the configuration you've selected at\n// compile time, and the details are described in stbvox_set_buffer.\n\nSTBVXDEC void stbvox_set_default_mesh(stbvox_mesh_maker *mm, int mesh);\n// Selects which mesh the mesher will output to (see previous function)\n// if the input doesn't specify a per-voxel selector. (I doubt this is\n// useful, but it's here just in case.)\n\nSTBVXDEC stbvox_input_description *stbvox_get_input_description(stbvox_mesh_maker *mm);\n// This function call returns a pointer to the stbvox_input_description part\n// of stbvox_mesh_maker (which you should otherwise treat as opaque). You\n// zero this structure, then fill out the relevant pointers to the data\n// describing your voxel object/world.\n//\n// See further documentation at the description of stbvox_input_description below.\n\nSTBVXDEC void stbvox_set_input_stride(stbvox_mesh_maker *mm, int x_stride_in_elements, int y_stride_in_elements);\n// This sets the stride between successive elements of the 3D arrays\n// in the stbvox_input_description. Z values are always stored consecutively.\n// (The preferred coordinate system for stbvox is X right, Y forwards, Z up.)\n\nSTBVXDEC void stbvox_set_input_range(stbvox_mesh_maker *mm, int x0, int y0, int z0, int x1, int y1, int z1);\n// This sets the range of values in the 3D array for the voxels that\n// the mesh generator will convert. The lower values are inclusive,\n// the higher values are exclusive, so (0,0,0) to (16,16,16) generates\n// mesh data associated with voxels up to (15,15,15) but no higher.\n//\n// The mesh generate generates faces at the boundary between open space\n// and solid space but associates them with the solid space, so if (15,0,0)\n// is open and (16,0,0) is solid, then the mesh will contain the boundary\n// between them if x0 <= 16 and x1 > 16.\n//\n// Note that the mesh generator will access array elements 1 beyond the\n// limits set in these parameters. For example, if you set the limits\n// to be (0,0,0) and (16,16,16), then the generator will access all of\n// the voxels between (-1,-1,-1) and (16,16,16), including (16,16,16).\n// You may have to do pointer arithmetic to make it work.\n//\n// For example, caveview processes mesh chunks that are 32x32x16, but it\n// does this using input buffers that are 34x34x18.\n//\n// The lower limits are x0 >= 0, y0 >= 0, and z0 >= 0.\n//\n// The upper limits are mode dependent, but all the current methods are\n// limited to x1 < 127, y1 < 127, z1 < 255. Note that these are not\n// powers of two; if you want to use power-of-two chunks (to make\n// it efficient to decide which chunk a coordinate falls in), you're\n// limited to at most x1=64, y1=64, z1=128. For classic Minecraft-style\n// worlds with limited vertical extent, I recommend using a single\n// chunk for the entire height, which limits the height to 255 blocks\n// (one less than Minecraft), and only chunk the map in X & Y.\n\nSTBVXDEC int stbvox_make_mesh(stbvox_mesh_maker *mm);\n// Call this function to create mesh data for the currently configured\n// set of input data. This appends to the currently configured mesh output\n// buffer. Returns 1 on success. If there is not enough room in the buffer,\n// it outputs as much as it can, and returns 0; you need to switch output\n// buffers (either by calling stbvox_set_buffer to set new buffers, or\n// by copying the data out and calling stbvox_reset_buffers), and then\n// call this function again without changing any of the input parameters.\n//\n// Note that this function appends; you can call it multiple times to\n// build a single mesh. For example, caveview uses chunks that are\n// 32x32x255, but builds the mesh for it by processing 32x32x16 at atime\n// (this is faster as it is reuses the same 34x34x18 input buffers rather\n// than needing 34x34x257 input buffers).\n\n// Once you're done creating a mesh into a given buffer,\n// consider the following functions:\n\nSTBVXDEC int stbvox_get_quad_count(stbvox_mesh_maker *mm, int mesh);\n// Returns the number of quads in the mesh currently generated by mm.\n// This is the sum of all consecutive stbvox_make_mesh runs appending\n// to the same buffer. 'mesh' distinguishes between the multiple user\n// meshes available via 'selector' or stbvox_set_default_mesh.\n//\n// Typically you use this function when you're done building the mesh\n// and want to record how to draw it.\n//\n// Note that there are no index buffers; the data stored in the buffers\n// should be drawn as quads (e.g. with GL_QUAD); if your API does not\n// support quads, you can create a single index buffer large enough to\n// draw your largest vertex buffer, and reuse it for every rendering.\n// (Note that if you use 32-bit indices, you'll use 24 bytes of bandwidth\n// per quad, more than the 20 bytes for the vertex/face mesh data.)\n\nSTBVXDEC void stbvox_set_mesh_coordinates(stbvox_mesh_maker *mm, int x, int y, int z);\n// Sets the global coordinates for this chunk, such that (0,0,0) relative\n// coordinates will be at (x,y,z) in global coordinates.\n\nSTBVXDEC void stbvox_get_bounds(stbvox_mesh_maker *mm, float bounds[2][3]);\n// Returns the bounds for the mesh in global coordinates. Use this\n// for e.g. frustum culling the mesh. @BUG: this just uses the\n// values from stbvox_set_input_range(), so if you build by\n// appending multiple values, this will be wrong, and you need to\n// set stbvox_set_input_range() to the full size. Someday this\n// will switch to tracking the actual bounds of the *mesh*, though.\n\nSTBVXDEC void stbvox_get_transform(stbvox_mesh_maker *mm, float transform[3][3]);\n// Returns the 'transform' data for the shader uniforms. It is your\n// job to set this to the shader before drawing the mesh. It is the\n// only uniform that needs to change per-mesh. Note that it is not\n// a 3x3 matrix, but rather a scale to decode fixed point numbers as\n// floats, a translate from relative to global space, and a special\n// translation for texture coordinate generation that avoids\n// floating-point precision issues. @TODO: currently we add the\n// global translation to the vertex, than multiply by modelview,\n// but this means if camera location and vertex are far from the\n// origin, we lose precision. Need to make a special modelview with\n// the translation (or some of it) factored out to avoid this.\n\nSTBVXDEC void stbvox_reset_buffers(stbvox_mesh_maker *mm);\n// Call this function if you're done with the current output buffer\n// but want to reuse it (e.g. you're done appending with\n// stbvox_make_mesh and you've copied the data out to your graphics API\n// so can reuse the buffer).\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// RENDERING\n//\n\nSTBVXDEC char *stbvox_get_vertex_shader(void);\n// Returns the (currently GLSL-only) vertex shader.\n\nSTBVXDEC char *stbvox_get_fragment_shader(void);\n// Returns the (currently GLSL-only) fragment shader.\n// You can override the lighting and fogging calculations\n// by appending data to the end of these; see the #define\n// documentation for more information.\n\nSTBVXDEC char *stbvox_get_fragment_shader_alpha_only(void);\n// Returns a slightly cheaper fragment shader that computes\n// alpha but not color. This is useful for e.g. a depth-only\n// pass when using alpha test.\n\ntypedef struct stbvox_uniform_info stbvox_uniform_info;\n\nSTBVXDEC int stbvox_get_uniform_info(stbvox_uniform_info *info, int uniform);\n// Gets the information about a uniform necessary for you to\n// set up each uniform with a minimal amount of explicit code.\n// See the sample code after the structure definition for stbvox_uniform_info,\n// further down in this header section.\n//\n// \"uniform\" is from the list immediately following. For many\n// of these, default values are provided which you can set.\n// Most values are shared for most draw calls; e.g. for stateful\n// APIs you can set most of the state only once. Only\n// STBVOX_UNIFORM_transform needs to change per draw call.\n//\n// STBVOX_UNIFORM_texscale\n//    64- or 128-long vec4 array. (128 only if STBVOX_CONFIG_PREFER_TEXBUFFER)\n//    x: scale factor to apply to texture #1. must be a power of two. 1.0 means 'face-sized'\n//    y: scale factor to apply to texture #2. must be a power of two. 1.0 means 'face-sized'\n//    z: blend mode indexed by texture #2. 0.0 is alpha compositing; 1.0 is multiplication.\n//    w: unused currently. @TODO use to support texture animation?\n//\n//    Texscale is indexed by the bottom 6 or 7 bits of the texture id; thus for\n//    example the texture at index 0 in the array and the texture in index 128 of\n//    the array must be scaled the same. This means that if you only have 64 or 128\n//    unique textures, they all get distinct values anyway; otherwise you have\n//    to group them in pairs or sets of four.\n//\n// STBVOX_UNIFORM_ambient\n//    4-long vec4 array:\n//      ambient[0].xyz   - negative of direction of a directional light for half-lambert\n//      ambient[1].rgb   - color of light scaled by NdotL (can be negative)\n//      ambient[2].rgb   - constant light added to above calculation;\n//                         effectively light ranges from ambient[2]-ambient[1] to ambient[2]+ambient[1]\n//      ambient[3].rgb   - fog color for STBVOX_CONFIG_FOG_SMOOTHSTEP\n//      ambient[3].a     - reciprocal of squared distance of farthest fog point (viewing distance)\n\n\n                               //  +----- has a default value\n                               //  |  +-- you should always use the default value\nenum                           //  V  V\n{                              //  ------------------------------------------------\n   STBVOX_UNIFORM_face_data,   //  n      the sampler with the face texture buffer\n   STBVOX_UNIFORM_transform,   //  n      the transform data from stbvox_get_transform\n   STBVOX_UNIFORM_tex_array,   //  n      an array of two texture samplers containing the two texture arrays\n   STBVOX_UNIFORM_texscale,    //  Y      a table of texture properties, see above\n   STBVOX_UNIFORM_color_table, //  Y      64 vec4 RGBA values; a default palette is provided; if A > 1.0, fullbright\n   STBVOX_UNIFORM_normals,     //  Y  Y   table of normals, internal-only\n   STBVOX_UNIFORM_texgen,      //  Y  Y   table of texgen vectors, internal-only\n   STBVOX_UNIFORM_ambient,     //  n      lighting & fog info, see above\n   STBVOX_UNIFORM_camera_pos,  //  Y      camera position in global voxel space (for lighting & fog)\n\n   STBVOX_UNIFORM_count,\n};\n\nenum\n{\n   STBVOX_UNIFORM_TYPE_none,\n   STBVOX_UNIFORM_TYPE_sampler,\n   STBVOX_UNIFORM_TYPE_vec2,\n   STBVOX_UNIFORM_TYPE_vec3,\n   STBVOX_UNIFORM_TYPE_vec4,\n};\n\nstruct stbvox_uniform_info\n{\n   int type;                    // which type of uniform\n   int bytes_per_element;       // the size of each uniform array element (e.g. vec3 = 12 bytes)\n   int array_length;            // length of the uniform array\n   char *name;                  // name in the shader @TODO use numeric binding\n   float *default_value;        // if not NULL, you can use this as the uniform pointer\n   int use_tex_buffer;          // if true, then the uniform is a sampler but the data can come from default_value\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Uniform sample code\n//\n\n#if 0\n// Run this once per frame before drawing all the meshes.\n// You still need to separately set the 'transform' uniform for every mesh.\nvoid setup_uniforms(GLuint shader, float camera_pos[4], GLuint tex1, GLuint tex2)\n{\n   int i;\n   glUseProgram(shader); // so uniform binding works\n   for (i=0; i < STBVOX_UNIFORM_count; ++i) {\n      stbvox_uniform_info sui;\n      if (stbvox_get_uniform_info(&sui, i)) {\n         GLint loc = glGetUniformLocation(shader, sui.name);\n         if (loc != -1) {\n            switch (i) {\n               case STBVOX_UNIFORM_camera_pos: // only needed for fog\n                  glUniform4fv(loc, sui.array_length, camera_pos);\n                  break;\n\n               case STBVOX_UNIFORM_tex_array: {\n                  GLuint tex_unit[2] = { 0, 1 }; // your choice of samplers\n                  glUniform1iv(loc, 2, tex_unit);\n\n                  glActiveTexture(GL_TEXTURE0 + tex_unit[0]); glBindTexture(GL_TEXTURE_2D_ARRAY, tex1);\n                  glActiveTexture(GL_TEXTURE0 + tex_unit[1]); glBindTexture(GL_TEXTURE_2D_ARRAY, tex2);\n                  glActiveTexture(GL_TEXTURE0); // reset to default\n                  break;\n               }\n\n               case STBVOX_UNIFORM_face_data:\n                  glUniform1i(loc, SAMPLER_YOU_WILL_BIND_PER_MESH_FACE_DATA_TO);\n                  break;\n\n               case STBVOX_UNIFORM_ambient:     // you definitely want to override this\n               case STBVOX_UNIFORM_color_table: // you might want to override this\n               case STBVOX_UNIFORM_texscale:    // you may want to override this\n                  glUniform4fv(loc, sui.array_length, sui.default_value);\n                  break;\n\n               case STBVOX_UNIFORM_normals:     // you never want to override this\n               case STBVOX_UNIFORM_texgen:      // you never want to override this\n                  glUniform3fv(loc, sui.array_length, sui.default_value);\n                  break;\n            }\n         }\n      }\n   }\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// INPUT TO MESHING\n//\n\n// Shapes of blocks that aren't always cubes\nenum\n{\n   STBVOX_GEOM_empty,\n   STBVOX_GEOM_knockout,  // creates a hole in the mesh\n   STBVOX_GEOM_solid,\n   STBVOX_GEOM_transp,    // solid geometry, but transparent contents so neighbors generate normally, unless same blocktype\n\n   // following 4 can be represented by vheight as well\n   STBVOX_GEOM_slab_upper,\n   STBVOX_GEOM_slab_lower,\n   STBVOX_GEOM_floor_slope_north_is_top,\n   STBVOX_GEOM_ceil_slope_north_is_bottom,\n\n   STBVOX_GEOM_floor_slope_north_is_top_as_wall_UNIMPLEMENTED,   // same as floor_slope above, but uses wall's texture & texture projection\n   STBVOX_GEOM_ceil_slope_north_is_bottom_as_wall_UNIMPLEMENTED,\n   STBVOX_GEOM_crossed_pair,    // corner-to-corner pairs, with normal vector bumped upwards\n   STBVOX_GEOM_force,           // like GEOM_transp, but faces visible even if neighbor is same type, e.g. minecraft fancy leaves\n\n   // these access vheight input\n   STBVOX_GEOM_floor_vheight_03 = 12,  // diagonal is SW-NE\n   STBVOX_GEOM_floor_vheight_12,       // diagonal is SE-NW\n   STBVOX_GEOM_ceil_vheight_03,\n   STBVOX_GEOM_ceil_vheight_12,\n\n   STBVOX_GEOM_count, // number of geom cases\n};\n\nenum\n{\n   STBVOX_FACE_east,\n   STBVOX_FACE_north,\n   STBVOX_FACE_west,\n   STBVOX_FACE_south,\n   STBVOX_FACE_up,\n   STBVOX_FACE_down,\n\n   STBVOX_FACE_count,\n};\n\n#ifdef STBVOX_CONFIG_BLOCKTYPE_SHORT\ntypedef unsigned short stbvox_block_type;\n#else\ntypedef unsigned char stbvox_block_type;\n#endif\n\n// 24-bit color\ntypedef struct\n{\n   unsigned char r,g,b;\n} stbvox_rgb;\n\n#define STBVOX_COLOR_TEX1_ENABLE   64\n#define STBVOX_COLOR_TEX2_ENABLE  128\n\n// This is the data structure you fill out. Most of the arrays can be\n// NULL, except when one is required to get the value to index another.\n//\n// The compass system used in the following descriptions is:\n//     east means increasing x\n//     north means increasing y\n//     up means increasing z\nstruct stbvox_input_description\n{\n   unsigned char lighting_at_vertices;\n   // The default is lighting values (i.e. ambient occlusion) are at block\n   // center, and the vertex light is gathered from those adjacent block\n   // centers that the vertex is facing. This makes smooth lighting\n   // consistent across adjacent faces with the same orientation.\n   //\n   // Setting this flag to non-zero gives you explicit control\n   // of light at each vertex, but now the lighting/ao will be\n   // shared by all vertices at the same point, even if they\n   // have different normals.\n\n   // these are mostly 3D maps you use to define your voxel world, using x_stride and y_stride\n   // note that for cache efficiency, you want to use the block_foo palettes as much as possible instead\n\n   stbvox_rgb *rgb;\n   // Indexed by 3D coordinate.\n   // 24-bit voxel color for STBVOX_CONFIG_MODE = 20 or 21 only\n\n   unsigned char *lighting;\n   // Indexed by 3D coordinate. The lighting value / ambient occlusion\n   // value that is used to define the vertex lighting values.\n   // The raw lighting values are defined at the center of blocks\n   // (or at vertex if 'lighting_at_vertices' is true).\n   //\n   // If the macro STBVOX_CONFIG_ROTATION_IN_LIGHTING is defined,\n   // then an additional 2-bit block rotation value is stored\n   // in this field as well.\n   //\n   // Encode with STBVOX_MAKE_LIGHTING_EXT(lighting,rot)--here\n   // 'lighting' should still be 8 bits, as the macro will\n   // discard the bottom bits automatically. Similarly, if\n   // using STBVOX_CONFIG_VHEIGHT_IN_LIGHTING, encode with\n   // STBVOX_MAKE_LIGHTING_EXT(lighting,vheight).\n   //\n   // (Rationale: rotation needs to be independent of blocktype,\n   // but is only 2 bits so doesn't want to be its own array.\n   // Lighting is the one thing that was likely to already be\n   // in use and that I could easily steal 2 bits from.)\n\n   stbvox_block_type *blocktype;\n   // Indexed by 3D coordinate. This is a core \"block type\" value, which is used\n   // to index into other arrays; essentially a \"palette\". This is much more\n   // memory-efficient and performance-friendly than storing the values explicitly,\n   // but only makes sense if the values are always synchronized.\n   //\n   // If a voxel's blocktype is 0, it is assumed to be empty (STBVOX_GEOM_empty),\n   // and no other blocktypes should be STBVOX_GEOM_empty. (Only if you do not\n   // have blocktypes should STBVOX_GEOM_empty ever used.)\n   //\n   // Normally it is an unsigned byte, but you can override it to be\n   // a short if you have too many blocktypes.\n\n   unsigned char *geometry;\n   // Indexed by 3D coordinate. Contains the geometry type for the block.\n   // Also contains a 2-bit rotation for how the whole block is rotated.\n   // Also includes a 2-bit vheight value when using shared vheight values.\n   // See the separate vheight documentation.\n   // Encode with STBVOX_MAKE_GEOMETRY(geom, rot, vheight)\n\n   unsigned char *block_geometry;\n   // Array indexed by blocktype containing the geometry for this block, plus\n   // a 2-bit \"simple rotation\". Note rotation has limited use since it's not\n   // independent of blocktype.\n   //\n   // Encode with STBVOX_MAKE_GEOMETRY(geom,simple_rot,0)\n\n   unsigned char *block_tex1;\n   // Array indexed by blocktype containing the texture id for texture #1.\n\n   unsigned char (*block_tex1_face)[6];\n   // Array indexed by blocktype and face containing the texture id for texture #1.\n   // The N/E/S/W face choices can be rotated by one of the rotation selectors;\n   // The top & bottom face textures will rotate to match.\n   // Note that it only makes sense to use one of block_tex1 or block_tex1_face;\n   // this pattern repeats throughout and this notice is not repeated.\n\n   unsigned char *tex2;\n   // Indexed by 3D coordinate. Contains the texture id for texture #2\n   // to use on all faces of the block.\n\n   unsigned char *block_tex2;\n   // Array indexed by blocktype containing the texture id for texture #2.\n\n   unsigned char (*block_tex2_face)[6];\n   // Array indexed by blocktype and face containing the texture id for texture #2.\n   // The N/E/S/W face choices can be rotated by one of the rotation selectors;\n   // The top & bottom face textures will rotate to match.\n\n   unsigned char *color;\n   // Indexed by 3D coordinate. Contains the color for all faces of the block.\n   // The core color value is 0..63.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char *block_color;\n   // Array indexed by blocktype containing the color value to apply to the faces.\n   // The core color value is 0..63.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char (*block_color_face)[6];\n   // Array indexed by blocktype and face containing the color value to apply to that face.\n   // The core color value is 0..63.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char *block_texlerp;\n   // Array indexed by blocktype containing 3-bit scalar for texture #2 alpha\n   // (known throughout as 'texlerp'). This is constant over every face even\n   // though the property is potentially per-vertex.\n\n   unsigned char (*block_texlerp_face)[6];\n   // Array indexed by blocktype and face containing 3-bit scalar for texture #2 alpha.\n   // This is constant over the face even though the property is potentially per-vertex.\n\n   unsigned char *block_vheight;\n   // Array indexed by blocktype containing the vheight values for the\n   // top or bottom face of this block. These will rotate properly if the\n   // block is rotated. See discussion of vheight.\n   // Encode with STBVOX_MAKE_VHEIGHT(sw_height, se_height, nw_height, ne_height)\n\n   unsigned char *selector;\n   // Array indexed by 3D coordinates indicating which output mesh to select.\n\n   unsigned char *block_selector;\n   // Array indexed by blocktype indicating which output mesh to select.\n\n   unsigned char *side_texrot;\n   // Array indexed by 3D coordinates encoding 2-bit texture rotations for the\n   // faces on the E/N/W/S sides of the block.\n   // Encode with STBVOX_MAKE_SIDE_TEXROT(rot_e, rot_n, rot_w, rot_s)\n\n   unsigned char *block_side_texrot;\n   // Array indexed by blocktype encoding 2-bit texture rotations for the faces\n   // on the E/N/W/S sides of the block.\n   // Encode with STBVOX_MAKE_SIDE_TEXROT(rot_e, rot_n, rot_w, rot_s)\n\n   unsigned char *overlay;                 // index into palettes listed below\n   // Indexed by 3D coordinate. If 0, there is no overlay. If non-zero,\n   // it indexes into to the below arrays and overrides the values\n   // defined by the blocktype.\n\n   unsigned char (*overlay_tex1)[6];\n   // Array indexed by overlay value and face, containing an override value\n   // for the texture id for texture #1. If 0, the value defined by blocktype\n   // is used.\n\n   unsigned char (*overlay_tex2)[6];\n   // Array indexed by overlay value and face, containing an override value\n   // for the texture id for texture #2. If 0, the value defined by blocktype\n   // is used.\n\n   unsigned char (*overlay_color)[6];\n   // Array indexed by overlay value and face, containing an override value\n   // for the face color. If 0, the value defined by blocktype is used.\n\n   unsigned char *overlay_side_texrot;\n   // Array indexed by overlay value, encoding 2-bit texture rotations for the faces\n   // on the E/N/W/S sides of the block.\n   // Encode with STBVOX_MAKE_SIDE_TEXROT(rot_e, rot_n, rot_w, rot_s)\n\n   unsigned char *rotate;\n   // Indexed by 3D coordinate. Allows independent rotation of several\n   // parts of the voxel, where by rotation I mean swapping textures\n   // and colors between E/N/S/W faces.\n   //    Block: rotates anything indexed by blocktype\n   //    Overlay: rotates anything indexed by overlay\n   //    EColor: rotates faces defined in ecolor_facemask\n   // Encode with STBVOX_MAKE_MATROT(block,overlay,ecolor)\n\n   unsigned char *tex2_for_tex1;\n   // Array indexed by tex1 containing the texture id for texture #2.\n   // You can use this if the two are always/almost-always strictly\n   // correlated (e.g. if tex2 is a detail texture for tex1), as it\n   // will be more efficient (touching fewer cache lines) than using\n   // e.g. block_tex2_face.\n\n   unsigned char *tex2_replace;\n   // Indexed by 3D coordinate. Specifies the texture id for texture #2\n   // to use on a single face of the voxel, which must be E/N/W/S (not U/D).\n   // The texture id is limited to 6 bits unless tex2_facemask is also\n   // defined (see below).\n   // Encode with STBVOX_MAKE_TEX2_REPLACE(tex2, face)\n\n   unsigned char *tex2_facemask;\n   // Indexed by 3D coordinate. Specifies which of the six faces should\n   // have their tex2 replaced by the value of tex2_replace. In this\n   // case, all 8 bits of tex2_replace are used as the texture id.\n   // Encode with STBVOX_MAKE_FACE_MASK(east,north,west,south,up,down)\n\n   unsigned char *extended_color;\n   // Indexed by 3D coordinate. Specifies a value that indexes into\n   // the ecolor arrays below (both of which must be defined).\n\n   unsigned char *ecolor_color;\n   // Indexed by extended_color value, specifies an optional override\n   // for the color value on some faces.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char *ecolor_facemask;\n   // Indexed by extended_color value, this specifies which faces the\n   // color in ecolor_color should be applied to. The faces can be\n   // independently rotated by the ecolor value of 'rotate', if it exists.\n   // Encode with STBVOX_MAKE_FACE_MASK(e,n,w,s,u,d)\n\n   unsigned char *color2;\n   // Indexed by 3D coordinates, specifies an alternative color to apply\n   // to some of the faces of the block.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char *color2_facemask;\n   // Indexed by 3D coordinates, specifies which faces should use the\n   // color defined in color2. No rotation value is applied.\n   // Encode with STBVOX_MAKE_FACE_MASK(e,n,w,s,u,d)\n\n   unsigned char *color3;\n   // Indexed by 3D coordinates, specifies an alternative color to apply\n   // to some of the faces of the block.\n   // Encode with STBVOX_MAKE_COLOR(color_number, tex1_enable, tex2_enable)\n\n   unsigned char *color3_facemask;\n   // Indexed by 3D coordinates, specifies which faces should use the\n   // color defined in color3. No rotation value is applied.\n   // Encode with STBVOX_MAKE_FACE_MASK(e,n,w,s,u,d)\n\n   unsigned char *texlerp_simple;\n   // Indexed by 3D coordinates, this is the smallest texlerp encoding\n   // that can do useful work. It consits of three values: baselerp,\n   // vertlerp, and face_vertlerp. Baselerp defines the value\n   // to use on all of the faces but one, from the STBVOX_TEXLERP_BASE\n   // values. face_vertlerp is one of the 6 face values (or STBVOX_FACE_NONE)\n   // which specifies the face should use the vertlerp values.\n   // Vertlerp defines a lerp value at every vertex of the mesh.\n   // Thus, one face can have per-vertex texlerp values, and those\n   // values are encoded in the space so that they will be shared\n   // by adjacent faces that also use vertlerp, allowing continuity\n   // (this is used for the \"texture crossfade\" bit of the release video).\n   // Encode with STBVOX_MAKE_TEXLERP_SIMPLE(baselerp, vertlerp, face_vertlerp)\n\n   // The following texlerp encodings are experimental and maybe not\n   // that useful.\n\n   unsigned char *texlerp;\n   // Indexed by 3D coordinates, this defines four values:\n   //   vertlerp is a lerp value at every vertex of the mesh (using STBVOX_TEXLERP_BASE values).\n   //   ud is the value to use on up and down faces, from STBVOX_TEXLERP_FACE values\n   //   ew is the value to use on east and west faces, from STBVOX_TEXLERP_FACE values\n   //   ns is the value to use on north and south faces, from STBVOX_TEXLERP_FACE values\n   // If any of ud, ew, or ns is STBVOX_TEXLERP_FACE_use_vert, then the\n   // vertlerp values for the vertices are gathered and used for those faces.\n   // Encode with STBVOX_MAKE_TEXLERP(vertlerp,ud,ew,sw)\n\n   unsigned short *texlerp_vert3;\n   // Indexed by 3D coordinates, this works with texlerp and\n   // provides a unique texlerp value for every direction at\n   // every vertex. The same rules of whether faces share values\n   // applies. The STBVOX_TEXLERP_FACE vertlerp value defined in\n   // texlerp is only used for the down direction. The values at\n   // each vertex in other directions are defined in this array,\n   // and each uses the STBVOX_TEXLERP3 values (i.e. full precision\n   // 3-bit texlerp values).\n   // Encode with STBVOX_MAKE_VERT3(vertlerp_e,vertlerp_n,vertlerp_w,vertlerp_s,vertlerp_u)\n\n   unsigned short *texlerp_face3;          // e:3,n:3,w:3,s:3,u:2,d:2\n   // Indexed by 3D coordinates, this provides a compact way to\n   // fully specify the texlerp value indepenendly for every face,\n   // but doesn't allow per-vertex variation. E/N/W/S values are\n   // encoded using STBVOX_TEXLERP3 values, whereas up and down\n   // use STBVOX_TEXLERP_SIMPLE values.\n   // Encode with STBVOX_MAKE_FACE3(face_e,face_n,face_w,face_s,face_u,face_d)\n\n   unsigned char *vheight;                 // STBVOX_MAKE_VHEIGHT   -- sw:2, se:2, nw:2, ne:2, doesn't rotate\n   // Indexed by 3D coordinates, this defines the four\n   // vheight values to use if the geometry is STBVOX_GEOM_vheight*.\n   // See the vheight discussion.\n\n   unsigned char *packed_compact;\n   // Stores block rotation, vheight, and texlerp values:\n   //    block rotation: 2 bits\n   //    vertex vheight: 2 bits\n   //    use_texlerp   : 1 bit\n   //    vertex texlerp: 3 bits\n   // If STBVOX_CONFIG_UP_TEXLERP_PACKED is defined, then 'vertex texlerp' is\n   // used for up faces if use_texlerp is 1. If STBVOX_CONFIG_DOWN_TEXLERP_PACKED\n   // is defined, then 'vertex texlerp' is used for down faces if use_texlerp is 1.\n   // Note if those symbols are defined but packed_compact is NULL, the normal\n   // texlerp default will be used.\n   // Encode with STBVOX_MAKE_PACKED_COMPACT(rot, vheight, texlerp, use_texlerp)\n};\n// @OPTIMIZE allow specializing; build a single struct with all of the\n// 3D-indexed arrays combined so it's AoS instead of SoA for better\n// cache efficiency\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  VHEIGHT DOCUMENTATION\n//\n//  \"vheight\" is the internal name for the special block types\n//  with sloped tops or bottoms. \"vheight\" stands for \"vertex height\".\n//\n//  Note that these blocks are very flexible (there are 256 of them,\n//  although at least 17 of them should never be used), but they\n//  also have a disadvantage that they generate extra invisible\n//  faces; the generator does not currently detect whether adjacent\n//  vheight blocks hide each others sides, so those side faces are\n//  always generated. For a continuous ground terrain, this means\n//  that you may generate 5x as many quads as needed. See notes\n//  on \"improvements for shipping products\" in the introduction.\n\nenum\n{\n   STBVOX_VERTEX_HEIGHT_0,\n   STBVOX_VERTEX_HEIGHT_half,\n   STBVOX_VERTEX_HEIGHT_1,\n   STBVOX_VERTEX_HEIGHT_one_and_a_half,\n};\n// These are the \"vheight\" values. Vheight stands for \"vertex height\".\n// The idea is that for a \"floor vheight\" block, you take a cube and\n// reposition the top-most vertices at various heights as specified by\n// the vheight values. Similarly, a \"ceiling vheight\" block takes a\n// cube and repositions the bottom-most vertices.\n//\n// A floor block only adjusts the top four vertices; the bottom four vertices\n// remain at the bottom of the block. The height values are 2 bits,\n// measured in halves of a block; so you can specify heights of 0/2,\n// 1/2, 2/2, or 3/2. 0 is the bottom of the block, 1 is halfway\n// up the block, 2 is the top of the block, and 3 is halfway up the\n// next block (and actually outside of the block). The value 3 is\n// actually legal for floor vheight (but not ceiling), and allows you to:\n//\n//     (A) have smoother terrain by having slopes that cross blocks,\n//         e.g. (1,1,3,3) is a regular-seeming slope halfway between blocks\n//     (B) make slopes steeper than 45-degrees, e.g. (0,0,3,3)\n//\n// (Because only z coordinates have half-block precision, and x&y are\n// limited to block corner precision, it's not possible to make these\n// things \"properly\" out of blocks, e.g. a half-slope block on its side\n// or a sloped block halfway between blocks that's made out of two blocks.)\n//\n// If you define STBVOX_CONFIG_OPTIMIZED_VHEIGHT, then the top face\n// (or bottom face for a ceiling vheight block) will be drawn as a\n// single quad even if the four vertex heights aren't planar, and a\n// single normal will be used over the entire quad. If you\n// don't define it, then if the top face is non-planar, it will be\n// split into two triangles, each with their own normal/lighting.\n// (Note that since all output from stb_voxel_render is quad meshes,\n// triangles are actually rendered as degenerate quads.) In this case,\n// the distinction between STBVOX_GEOM_floor_vheight_03 and\n// STBVOX_GEOM_floor_vheight_12 comes into play; the former introduces\n// an edge from the SW to NE corner (i.e. from <0,0,?> to <1,1,?>),\n// while the latter introduces an edge from the NW to SE corner\n// (i.e. from <0,1,?> to <1,0,?>.) For a \"lazy mesh\" look, use\n// exclusively _03 or _12. For a \"classic mesh\" look, alternate\n// _03 and _12 in a checkerboard pattern. For a \"smoothest surface\"\n// look, choose the edge based on actual vertex heights.\n//\n// The four vertex heights can come from several places. The simplest\n// encoding is to just use the 'vheight' parameter which stores four\n// explicit vertex heights for every block. This allows total independence,\n// but at the cost of the largest memory usage, 1 byte per 3D block.\n// Encode this with STBVOX_MAKE_VHEIGHT(vh_sw, vh_se, vh_nw, vh_ne).\n// These coordinates are absolute, not affected by block rotations.\n//\n// An alternative if you just want to encode some very specific block\n// types, not all the possibilities--say you just want half-height slopes,\n// so you want (0,0,1,1) and (1,1,2,2)--then you can use block_vheight\n// to specify them. The geometry rotation will cause block_vheight values\n// to be rotated (because it's as if you're just defining a type of\n// block). This value is also encoded with STBVOX_MAKE_VHEIGHT.\n//\n// If you want to save memory and you're creating a \"continuous ground\"\n// sort of effect, you can make each vertex of the lattice share the\n// vheight value; that is, two adjacent blocks that share a vertex will\n// always get the same vheight value for that vertex. Then you need to\n// store two bits of vheight for every block, which you do by storing it\n// as part another data structure. Store the south-west vertex's vheight\n// with the block. You can either use the \"geometry\" mesh variable (it's\n// a parameter to STBVOX_MAKE_GEOMETRY) or you can store it in the\n// \"lighting\" mesh variable if you defined STBVOX_CONFIG_VHEIGHT_IN_LIGHTING,\n// using STBVOX_MAKE_LIGHTING_EXT(lighting,vheight).\n//\n// Note that if you start with a 2D height map and generate vheight data from\n// it, you don't necessarily store only one value per (x,y) coordinate,\n// as the same value may need to be set up at multiple z heights. For\n// example, if height(8,8) = 13.5, then you want the block at (8,8,13)\n// to store STBVOX_VERTEX_HEIGHT_half, and this will be used by blocks\n// at (7,7,13), (8,7,13), (7,8,13), and (8,8,13). However, if you're\n// allowing steep slopes, it might be the case that you have a block\n// at (7,7,12) which is supposed to stick up to 13.5; that means\n// you also need to store STBVOX_VERTEX_HEIGHT_one_and_a_half at (8,8,12).\n\nenum\n{\n   STBVOX_TEXLERP_FACE_0,\n   STBVOX_TEXLERP_FACE_half,\n   STBVOX_TEXLERP_FACE_1,\n   STBVOX_TEXLERP_FACE_use_vert,\n};\n\nenum\n{\n   STBVOX_TEXLERP_BASE_0,    // 0.0\n   STBVOX_TEXLERP_BASE_2_7,  // 2/7\n   STBVOX_TEXLERP_BASE_5_7,  // 4/7\n   STBVOX_TEXLERP_BASE_1     // 1.0\n};\n\nenum\n{\n   STBVOX_TEXLERP3_0_8,\n   STBVOX_TEXLERP3_1_8,\n   STBVOX_TEXLERP3_2_8,\n   STBVOX_TEXLERP3_3_8,\n   STBVOX_TEXLERP3_4_8,\n   STBVOX_TEXLERP3_5_8,\n   STBVOX_TEXLERP3_6_8,\n   STBVOX_TEXLERP3_7_8,\n};\n\n#define STBVOX_FACE_NONE  7\n\n#define STBVOX_BLOCKTYPE_EMPTY    0\n\n#ifdef STBVOX_BLOCKTYPE_SHORT\n#define STBVOX_BLOCKTYPE_HOLE  65535\n#else\n#define STBVOX_BLOCKTYPE_HOLE    255\n#endif\n\n#define STBVOX_MAKE_GEOMETRY(geom, rotate, vheight) ((geom) + (rotate)*16 + (vheight)*64)\n#define STBVOX_MAKE_VHEIGHT(v_sw, v_se, v_nw, v_ne) ((v_sw) + (v_se)*4 + (v_nw)*16 + (v_ne)*64)\n#define STBVOX_MAKE_MATROT(block, overlay, color)  ((block) + (overlay)*4 + (color)*64)\n#define STBVOX_MAKE_TEX2_REPLACE(tex2, tex2_replace_face) ((tex2) + ((tex2_replace_face) & 3)*64)\n#define STBVOX_MAKE_TEXLERP(ns2, ew2, ud2, vert)  ((ew2) + (ns2)*4 + (ud2)*16 + (vert)*64)\n#define STBVOX_MAKE_TEXLERP_SIMPLE(baselerp,vert,face)   ((vert)*32 + (face)*4 + (baselerp))\n#define STBVOX_MAKE_TEXLERP1(vert,e2,n2,w2,s2,u4,d2) STBVOX_MAKE_TEXLERP(s2, w2, d2, vert)\n#define STBVOX_MAKE_TEXLERP2(vert,e2,n2,w2,s2,u4,d2) ((u2)*16 + (n2)*4 + (s2))\n#define STBVOX_MAKE_FACE_MASK(e,n,w,s,u,d)  ((e)+(n)*2+(w)*4+(s)*8+(u)*16+(d)*32)\n#define STBVOX_MAKE_SIDE_TEXROT(e,n,w,s) ((e)+(n)*4+(w)*16+(s)*64)\n#define STBVOX_MAKE_COLOR(color,t1,t2) ((color)+(t1)*64+(t2)*128)\n#define STBVOX_MAKE_TEXLERP_VERT3(e,n,w,s,u)   ((e)+(n)*8+(w)*64+(s)*512+(u)*4096)\n#define STBVOX_MAKE_TEXLERP_FACE3(e,n,w,s,u,d) ((e)+(n)*8+(w)*64+(s)*512+(u)*4096+(d)*16384)\n#define STBVOX_MAKE_PACKED_COMPACT(rot, vheight, texlerp, def) ((rot)+4*(vheight)+16*(use)+32*(texlerp))\n\n#define STBVOX_MAKE_LIGHTING_EXT(lighting, rot)  (((lighting)&~3)+(rot))\n#define STBVOX_MAKE_LIGHTING(lighting)       (lighting)\n\n#ifndef STBVOX_MAX_MESHES\n#define STBVOX_MAX_MESHES      2           // opaque & transparent\n#endif\n\n#define STBVOX_MAX_MESH_SLOTS  3           // one vertex & two faces, or two vertex and one face\n\n\n// don't mess with this directly, it's just here so you can\n// declare stbvox_mesh_maker on the stack or as a global\nstruct stbvox_mesh_maker\n{\n   stbvox_input_description input;\n   int cur_x, cur_y, cur_z;       // last unprocessed voxel if it splits into multiple buffers\n   int x0,y0,z0,x1,y1,z1;\n   int x_stride_in_bytes;\n   int y_stride_in_bytes;\n   int config_dirty;\n   int default_mesh;\n   unsigned int tags;\n\n   int cube_vertex_offset[6][4]; // this allows access per-vertex data stored block-centered (like texlerp, ambient)\n   int vertex_gather_offset[6][4];\n\n   int pos_x,pos_y,pos_z;\n   int full;\n\n   // computed from user input\n   char *output_cur   [STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS];\n   char *output_end   [STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS];\n   char *output_buffer[STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS];\n   int   output_len   [STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS];\n\n   // computed from config\n   int   output_size  [STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS]; // per quad\n   int   output_step  [STBVOX_MAX_MESHES][STBVOX_MAX_MESH_SLOTS]; // per vertex or per face, depending\n   int   num_mesh_slots;\n\n   float default_tex_scale[128][2];\n};\n\n#endif //  INCLUDE_STB_VOXEL_RENDER_H\n\n\n#ifdef STB_VOXEL_RENDER_IMPLEMENTATION\n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h> // memset\n\n// have to use our own names to avoid the _MSC_VER path having conflicting type names\n#ifndef _MSC_VER\n   #include <stdint.h>\n   typedef uint16_t stbvox_uint16;\n   typedef uint32_t stbvox_uint32;\n#else\n   typedef unsigned short stbvox_uint16;\n   typedef unsigned int   stbvox_uint32;\n#endif\n\n#ifdef _MSC_VER\n   #define STBVOX_NOTUSED(v)  (void)(v)\n#else\n   #define STBVOX_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n\n\n#ifndef STBVOX_CONFIG_MODE\n#error \"Must defined STBVOX_CONFIG_MODE to select the mode\"\n#endif\n\n#if defined(STBVOX_CONFIG_ROTATION_IN_LIGHTING) && defined(STBVOX_CONFIG_VHEIGHT_IN_LIGHTING)\n#error \"Can't store both rotation and vheight in lighting\"\n#endif\n\n\n// The following are candidate voxel modes. Only modes 0, 1, and 20, and 21 are\n// currently implemented. Reducing the storage-per-quad further\n// shouldn't improve performance, although obviously it allow you\n// to create larger worlds without streaming.\n//\n//\n//                      -----------  Two textures -----------       -- One texture --     ---- Color only ----\n//            Mode:     0     1     2     3     4     5     6        10    11    12      20    21    22    23    24\n// ============================================================================================================\n//  uses Tex Buffer     n     Y     Y     Y     Y     Y     Y         Y     Y     Y       n     Y     Y     Y     Y\n//   bytes per quad    32    20    14    12    10     6     6         8     8     4      32    20    10     6     4\n//       non-blocks   all   all   some  some  some slabs stairs     some  some  none    all   all  slabs slabs  none\n//             tex1   256   256   256   256   256   256   256       256   256   256       n     n     n     n     n\n//             tex2   256   256   256   256   256   256   128         n     n     n       n     n     n     n     n\n//           colors    64    64    64    64    64    64    64         8     n     n     2^24  2^24  2^24  2^24  256\n//        vertex ao     Y     Y     Y     Y     Y     n     n         Y     Y     n       Y     Y     Y     n     n\n//   vertex texlerp     Y     Y     Y     n     n     n     n         -     -     -       -     -     -     -     -\n//      x&y extents   127   127   128    64    64   128    64        64   128   128     127   127   128   128   128\n//        z extents   255   255   128    64?   64?   64    64        32    64   128     255   255   128    64   128\n\n// not sure why I only wrote down the above \"result data\" and didn't preserve\n// the vertex formats, but here I've tried to reconstruct the designs...\n//     mode # 3 is wrong, one byte too large, but they may have been an error originally\n\n//            Mode:     0     1     2     3     4     5     6        10    11    12      20    21    22    23    24\n// =============================================================================================================\n//   bytes per quad    32    20    14    12    10     6     6         8     8     4            20    10     6     4\n//\n//    vertex x bits     7     7     0     6     0     0     0         0     0     0             7     0     0     0\n//    vertex y bits     7     7     0     0     0     0     0         0     0     0             7     0     0     0\n//    vertex z bits     9     9     7     4     2     0     0         2     2     0             9     2     0     0\n//   vertex ao bits     6     6     6     6     6     0     0         6     6     0             6     6     0     0\n//  vertex txl bits     3     3     3     0     0     0     0         0     0     0            (3)    0     0     0\n//\n//   face tex1 bits    (8)    8     8     8     8     8     8         8     8     8\n//   face tex2 bits    (8)    8     8     8     8     8     7         -     -     -\n//  face color bits    (8)    8     8     8     8     8     8         3     0     0            24    24    24     8\n// face normal bits    (8)    8     8     8     6     4     7         4     4     3             8     3     4     3\n//      face x bits                 7     0     6     7     6         6     7     7             0     7     7     7\n//      face y bits                 7     6     6     7     6         6     7     7             0     7     7     7\n//      face z bits                 2     2     6     6     6         5     6     7             0     7     6     7\n\n\n#if STBVOX_CONFIG_MODE==0 || STBVOX_CONFIG_MODE==1\n\n   #define STBVOX_ICONFIG_VERTEX_32\n   #define STBVOX_ICONFIG_FACE1_1\n\n#elif STBVOX_CONFIG_MODE==20 || STBVOX_CONFIG_MODE==21\n\n   #define STBVOX_ICONFIG_VERTEX_32\n   #define STBVOX_ICONFIG_FACE1_1\n   #define STBVOX_ICONFIG_UNTEXTURED\n\n#else\n#error \"Selected value of STBVOX_CONFIG_MODE is not supported\"\n#endif\n\n#if STBVOX_CONFIG_MODE==0 || STBVOX_CONFIG_MODE==20\n#define STBVOX_ICONFIG_FACE_ATTRIBUTE\n#endif\n\n#ifndef STBVOX_CONFIG_HLSL\n// the fallback if all others are exhausted is GLSL\n#define STBVOX_ICONFIG_GLSL\n#endif\n\n#ifdef STBVOX_CONFIG_OPENGL_MODELVIEW\n#define STBVOX_ICONFIG_OPENGL_3_1_COMPATIBILITY\n#endif\n\n#if defined(STBVOX_ICONFIG_VERTEX_32)\n   typedef stbvox_uint32 stbvox_mesh_vertex;\n   #define stbvox_vertex_encode(x,y,z,ao,texlerp) \\\n      ((stbvox_uint32) ((x)+((y)<<7)+((z)<<14)+((ao)<<23)+((texlerp)<<29)))\n#elif defined(STBVOX_ICONFIG_VERTEX_16_1)  // mode=2\n   typedef stbvox_uint16 stbvox_mesh_vertex;\n   #define stbvox_vertex_encode(x,y,z,ao,texlerp) \\\n      ((stbvox_uint16) ((z)+((ao)<<7)+((texlerp)<<13)\n#elif defined(STBVOX_ICONFIG_VERTEX_16_2)  // mode=3\n   typedef stbvox_uint16 stbvox_mesh_vertex;\n   #define stbvox_vertex_encode(x,y,z,ao,texlerp) \\\n      ((stbvox_uint16) ((x)+((z)<<6))+((ao)<<10))\n#elif defined(STBVOX_ICONFIG_VERTEX_8)\n   typedef stbvox_uint8 stbvox_mesh_vertex;\n   #define stbvox_vertex_encode(x,y,z,ao,texlerp) \\\n      ((stbvox_uint8) ((z)+((ao)<<6))\n#else\n   #error \"internal error, no vertex type\"\n#endif\n\n#ifdef STBVOX_ICONFIG_FACE1_1\n   typedef struct\n   {\n      unsigned char tex1,tex2,color,face_info;\n   } stbvox_mesh_face;\n#else\n   #error \"internal error, no face type\"\n#endif\n\n\n// 20-byte quad format:\n//\n// per vertex:\n//\n//     x:7\n//     y:7\n//     z:9\n//     ao:6\n//     tex_lerp:3\n//\n// per face:\n//\n//     tex1:8\n//     tex2:8\n//     face:8\n//     color:8\n\n\n// Faces:\n//\n// Faces use the bottom 3 bits to choose the texgen\n// mode, and all the bits to choose the normal.\n// Thus the bottom 3 bits have to be:\n//      e, n, w, s, u, d, u, d\n//\n// These use compact names so tables are readable\n\nenum\n{\n   STBVF_e,\n   STBVF_n,\n   STBVF_w,\n   STBVF_s,\n   STBVF_u,\n   STBVF_d,\n   STBVF_eu,\n   STBVF_ed,\n\n   STBVF_eu_wall,\n   STBVF_nu_wall,\n   STBVF_wu_wall,\n   STBVF_su_wall,\n   STBVF_ne_u,\n   STBVF_ne_d,\n   STBVF_nu,\n   STBVF_nd,\n\n   STBVF_ed_wall,\n   STBVF_nd_wall,\n   STBVF_wd_wall,\n   STBVF_sd_wall,\n   STBVF_nw_u,\n   STBVF_nw_d,\n   STBVF_wu,\n   STBVF_wd,\n\n   STBVF_ne_u_cross,\n   STBVF_nw_u_cross,\n   STBVF_sw_u_cross,\n   STBVF_se_u_cross,\n   STBVF_sw_u,\n   STBVF_sw_d,\n   STBVF_su,\n   STBVF_sd,\n\n   // @TODO we need more than 5 bits to encode the normal to fit the following\n   // so for now we use the right projection but the wrong normal\n   STBVF_se_u = STBVF_su,\n   STBVF_se_d = STBVF_sd,\n\n   STBVF_count,\n};\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//    tables -- i'd prefer if these were at the end of the file, but: C++\n//\n\nstatic float stbvox_default_texgen[2][32][3] =\n{\n   { {  0, 1,0 }, { 0, 0, 1 }, {  0,-1,0 }, { 0, 0,-1 },\n     { -1, 0,0 }, { 0, 0, 1 }, {  1, 0,0 }, { 0, 0,-1 },\n     {  0,-1,0 }, { 0, 0, 1 }, {  0, 1,0 }, { 0, 0,-1 },\n     {  1, 0,0 }, { 0, 0, 1 }, { -1, 0,0 }, { 0, 0,-1 },\n\n     {  1, 0,0 }, { 0, 1, 0 }, { -1, 0,0 }, { 0,-1, 0 },\n     { -1, 0,0 }, { 0,-1, 0 }, {  1, 0,0 }, { 0, 1, 0 },\n     {  1, 0,0 }, { 0, 1, 0 }, { -1, 0,0 }, { 0,-1, 0 },\n     { -1, 0,0 }, { 0,-1, 0 }, {  1, 0,0 }, { 0, 1, 0 },\n   },\n   { { 0, 0,-1 }, {  0, 1,0 }, { 0, 0, 1 }, {  0,-1,0 },\n     { 0, 0,-1 }, { -1, 0,0 }, { 0, 0, 1 }, {  1, 0,0 },\n     { 0, 0,-1 }, {  0,-1,0 }, { 0, 0, 1 }, {  0, 1,0 },\n     { 0, 0,-1 }, {  1, 0,0 }, { 0, 0, 1 }, { -1, 0,0 },\n\n     { 0,-1, 0 }, {  1, 0,0 }, { 0, 1, 0 }, { -1, 0,0 },\n     { 0, 1, 0 }, { -1, 0,0 }, { 0,-1, 0 }, {  1, 0,0 },\n     { 0,-1, 0 }, {  1, 0,0 }, { 0, 1, 0 }, { -1, 0,0 },\n     { 0, 1, 0 }, { -1, 0,0 }, { 0,-1, 0 }, {  1, 0,0 },\n   },\n};\n\n#define STBVOX_RSQRT2   0.7071067811865f\n#define STBVOX_RSQRT3   0.5773502691896f\n\nstatic float stbvox_default_normals[32][3] =\n{\n   { 1,0,0 },  // east\n   { 0,1,0 },  // north\n   { -1,0,0 }, // west\n   { 0,-1,0 }, // south\n   { 0,0,1 },  // up\n   { 0,0,-1 }, // down\n   {  STBVOX_RSQRT2,0, STBVOX_RSQRT2 }, // east & up\n   {  STBVOX_RSQRT2,0, -STBVOX_RSQRT2 }, // east & down\n\n   {  STBVOX_RSQRT2,0, STBVOX_RSQRT2 }, // east & up\n   { 0, STBVOX_RSQRT2, STBVOX_RSQRT2 }, // north & up\n   { -STBVOX_RSQRT2,0, STBVOX_RSQRT2 }, // west & up\n   { 0,-STBVOX_RSQRT2, STBVOX_RSQRT2 }, // south & up\n   {  STBVOX_RSQRT3, STBVOX_RSQRT3, STBVOX_RSQRT3 }, // ne & up\n   {  STBVOX_RSQRT3, STBVOX_RSQRT3,-STBVOX_RSQRT3 }, // ne & down\n   { 0, STBVOX_RSQRT2, STBVOX_RSQRT2 }, // north & up\n   { 0, STBVOX_RSQRT2, -STBVOX_RSQRT2 }, // north & down\n\n   {  STBVOX_RSQRT2,0, -STBVOX_RSQRT2 }, // east & down\n   { 0, STBVOX_RSQRT2, -STBVOX_RSQRT2 }, // north & down\n   { -STBVOX_RSQRT2,0, -STBVOX_RSQRT2 }, // west & down\n   { 0,-STBVOX_RSQRT2, -STBVOX_RSQRT2 }, // south & down\n   { -STBVOX_RSQRT3, STBVOX_RSQRT3, STBVOX_RSQRT3 }, // NW & up\n   { -STBVOX_RSQRT3, STBVOX_RSQRT3,-STBVOX_RSQRT3 }, // NW & down\n   { -STBVOX_RSQRT2,0, STBVOX_RSQRT2 }, // west & up\n   { -STBVOX_RSQRT2,0, -STBVOX_RSQRT2 }, // west & down\n\n   {  STBVOX_RSQRT3, STBVOX_RSQRT3,STBVOX_RSQRT3 }, // NE & up crossed\n   { -STBVOX_RSQRT3, STBVOX_RSQRT3,STBVOX_RSQRT3 }, // NW & up crossed\n   { -STBVOX_RSQRT3,-STBVOX_RSQRT3,STBVOX_RSQRT3 }, // SW & up crossed\n   {  STBVOX_RSQRT3,-STBVOX_RSQRT3,STBVOX_RSQRT3 }, // SE & up crossed\n   { -STBVOX_RSQRT3,-STBVOX_RSQRT3, STBVOX_RSQRT3 }, // SW & up\n   { -STBVOX_RSQRT3,-STBVOX_RSQRT3,-STBVOX_RSQRT3 }, // SW & up\n   { 0,-STBVOX_RSQRT2, STBVOX_RSQRT2 }, // south & up\n   { 0,-STBVOX_RSQRT2, -STBVOX_RSQRT2 }, // south & down\n};\n\nstatic float stbvox_default_texscale[128][4] =\n{\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n   {1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},{1,1,0,0},\n};\n\nstatic unsigned char stbvox_default_palette_compact[64][3] =\n{\n   { 255,255,255 }, { 238,238,238 }, { 221,221,221 }, { 204,204,204 },\n   { 187,187,187 }, { 170,170,170 }, { 153,153,153 }, { 136,136,136 },\n   { 119,119,119 }, { 102,102,102 }, {  85, 85, 85 }, {  68, 68, 68 },\n   {  51, 51, 51 }, {  34, 34, 34 }, {  17, 17, 17 }, {   0,  0,  0 },\n   { 255,240,240 }, { 255,220,220 }, { 255,160,160 }, { 255, 32, 32 },\n   { 200,120,160 }, { 200, 60,150 }, { 220,100,130 }, { 255,  0,128 },\n   { 240,240,255 }, { 220,220,255 }, { 160,160,255 }, {  32, 32,255 },\n   { 120,160,200 }, {  60,150,200 }, { 100,130,220 }, {   0,128,255 },\n   { 240,255,240 }, { 220,255,220 }, { 160,255,160 }, {  32,255, 32 },\n   { 160,200,120 }, { 150,200, 60 }, { 130,220,100 }, { 128,255,  0 },\n   { 255,255,240 }, { 255,255,220 }, { 220,220,180 }, { 255,255, 32 },\n   { 200,160,120 }, { 200,150, 60 }, { 220,130,100 }, { 255,128,  0 },\n   { 255,240,255 }, { 255,220,255 }, { 220,180,220 }, { 255, 32,255 },\n   { 160,120,200 }, { 150, 60,200 }, { 130,100,220 }, { 128,  0,255 },\n   { 240,255,255 }, { 220,255,255 }, { 180,220,220 }, {  32,255,255 },\n   { 120,200,160 }, {  60,200,150 }, { 100,220,130 }, {   0,255,128 },\n};\n\nstatic float stbvox_default_ambient[4][4] =\n{\n   { 0,0,1      ,0 }, // reversed lighting direction\n   { 0.5,0.5,0.5,0 }, // directional color\n   { 0.5,0.5,0.5,0 }, // constant color\n   { 0.5,0.5,0.5,1.0f/1000.0f/1000.0f }, // fog data for simple_fog\n};\n\nstatic float stbvox_default_palette[64][4];\n\nstatic void stbvox_build_default_palette(void)\n{\n   int i;\n   for (i=0; i < 64; ++i) {\n      stbvox_default_palette[i][0] = stbvox_default_palette_compact[i][0] / 255.0f;\n      stbvox_default_palette[i][1] = stbvox_default_palette_compact[i][1] / 255.0f;\n      stbvox_default_palette[i][2] = stbvox_default_palette_compact[i][2] / 255.0f;\n      stbvox_default_palette[i][3] = 1.0f;\n   }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Shaders\n//\n\n#if defined(STBVOX_ICONFIG_OPENGL_3_1_COMPATIBILITY)\n   #define STBVOX_SHADER_VERSION \"#version 150 compatibility\\n\"\n#elif defined(STBVOX_ICONFIG_OPENGL_3_0)\n   #define STBVOX_SHADER_VERSION \"#version 130\\n\"\n#elif defined(STBVOX_ICONFIG_GLSL)\n   #define STBVOX_SHADER_VERSION \"#version 150\\n\"\n#else\n   #define STBVOX_SHADER_VERSION \"\"\n#endif\n\nstatic const char *stbvox_vertex_program =\n{\n      STBVOX_SHADER_VERSION\n\n   #ifdef STBVOX_ICONFIG_FACE_ATTRIBUTE  // NOT TAG_face_sampled\n      \"in uvec4 attr_face;\\n\"\n   #else\n      \"uniform usamplerBuffer facearray;\\n\"\n   #endif\n\n   #ifdef STBVOX_ICONFIG_FACE_ARRAY_2\n      \"uniform usamplerBuffer facearray2;\\n\"\n   #endif\n\n      // vertex input data\n      \"in uint attr_vertex;\\n\"\n\n      // per-buffer data\n      \"uniform vec3 transform[3];\\n\"\n\n      // per-frame data\n      \"uniform vec4 camera_pos;\\n\"  // 4th value is used for arbitrary hacking\n\n      // to simplify things, we avoid using more than 256 uniform vectors\n      // in fragment shader to avoid possible 1024 component limit, so\n      // we access this table in the fragment shader.\n      \"uniform vec3 normal_table[32];\\n\"\n\n      #ifndef STBVOX_CONFIG_OPENGL_MODELVIEW\n         \"uniform mat4x4 model_view;\\n\"\n      #endif\n\n      // fragment output data\n      \"flat out uvec4  facedata;\\n\"\n      \"     out  vec3  voxelspace_pos;\\n\"\n      \"     out  vec3  vnormal;\\n\"\n      \"     out float  texlerp;\\n\"\n      \"     out float  amb_occ;\\n\"\n\n      // @TODO handle the HLSL way to do this\n      \"void main()\\n\"\n      \"{\\n\"\n      #ifdef STBVOX_ICONFIG_FACE_ATTRIBUTE\n         \"   facedata = attr_face;\\n\"\n      #else\n         \"   int faceID = gl_VertexID >> 2;\\n\"\n         \"   facedata   = texelFetch(facearray, faceID);\\n\"\n      #endif\n\n      // extract data for vertex\n      \"   vec3 offset;\\n\"\n      \"   offset.x = float( (attr_vertex       ) & 127u );\\n\"             // a[0..6]\n      \"   offset.y = float( (attr_vertex >>  7u) & 127u );\\n\"             // a[7..13]\n      \"   offset.z = float( (attr_vertex >> 14u) & 511u );\\n\"             // a[14..22]\n      \"   amb_occ  = float( (attr_vertex >> 23u) &  63u ) / 63.0;\\n\"      // a[23..28]\n      \"   texlerp  = float( (attr_vertex >> 29u)        ) /  7.0;\\n\"      // a[29..31]\n\n      \"   vnormal = normal_table[(facedata.w>>2u) & 31u];\\n\"\n      \"   voxelspace_pos = offset * transform[0];\\n\"  // mesh-to-object scale\n      \"   vec3 position  = voxelspace_pos + transform[1];\\n\"  // mesh-to-object translate\n\n      #ifdef STBVOX_DEBUG_TEST_NORMALS\n         \"   if ((facedata.w & 28u) == 16u || (facedata.w & 28u) == 24u)\\n\"\n         \"      position += vnormal.xyz * camera_pos.w;\\n\"\n      #endif\n\n      #ifndef STBVOX_CONFIG_OPENGL_MODELVIEW\n         \"   gl_Position = model_view * vec4(position,1.0);\\n\"\n      #else\n         \"   gl_Position = gl_ModelViewProjectionMatrix * vec4(position,1.0);\\n\"\n      #endif\n\n      \"}\\n\"\n};\n\n\nstatic const char *stbvox_fragment_program =\n{\n      STBVOX_SHADER_VERSION\n\n      // rlerp is lerp but with t on the left, like god intended\n      #if defined(STBVOX_ICONFIG_GLSL)\n         \"#define rlerp(t,x,y) mix(x,y,t)\\n\"\n      #elif defined(STBVOX_CONFIG_HLSL)\n         \"#define rlerp(t,x,y) lerp(x,y,t)\\n\"\n      #else\n         #error \"need definition of rlerp()\"\n      #endif\n\n\n      // vertex-shader output data\n      \"flat in uvec4  facedata;\\n\"\n      \"     in  vec3  voxelspace_pos;\\n\"\n      \"     in  vec3  vnormal;\\n\"\n      \"     in float  texlerp;\\n\"\n      \"     in float  amb_occ;\\n\"\n\n      // per-buffer data\n      \"uniform vec3 transform[3];\\n\"\n\n      // per-frame data\n      \"uniform vec4 camera_pos;\\n\"  // 4th value is used for arbitrary hacking\n\n      // probably constant data\n      \"uniform vec4 ambient[4];\\n\"\n\n      #ifndef STBVOX_ICONFIG_UNTEXTURED\n         // generally constant data\n         \"uniform sampler2DArray tex_array[2];\\n\"\n\n         #ifdef STBVOX_CONFIG_PREFER_TEXBUFFER\n            \"uniform samplerBuffer color_table;\\n\"\n            \"uniform samplerBuffer texscale;\\n\"\n            \"uniform samplerBuffer texgen;\\n\"\n         #else\n            \"uniform vec4 color_table[64];\\n\"\n            \"uniform vec4 texscale[64];\\n\" // instead of 128, to avoid running out of uniforms\n            \"uniform vec3 texgen[64];\\n\"\n         #endif\n      #endif\n\n      \"out vec4  outcolor;\\n\"\n\n      #if defined(STBVOX_CONFIG_LIGHTING) || defined(STBVOX_CONFIG_LIGHTING_SIMPLE)\n      \"vec3 compute_lighting(vec3 pos, vec3 norm, vec3 albedo, vec3 ambient);\\n\"\n      #endif\n      #if defined(STBVOX_CONFIG_FOG) || defined(STBVOX_CONFIG_FOG_SMOOTHSTEP)\n      \"vec3 compute_fog(vec3 color, vec3 relative_pos, float fragment_alpha);\\n\"\n      #endif\n\n      \"void main()\\n\"\n      \"{\\n\"\n      \"   vec3 albedo;\\n\"\n      \"   float fragment_alpha;\\n\"\n\n      #ifndef STBVOX_ICONFIG_UNTEXTURED\n         // unpack the values\n         \"   uint tex1_id = facedata.x;\\n\"\n         \"   uint tex2_id = facedata.y;\\n\"\n         \"   uint texprojid = facedata.w & 31u;\\n\"\n         \"   uint color_id  = facedata.z;\\n\"\n\n         #ifndef STBVOX_CONFIG_PREFER_TEXBUFFER\n            // load from uniforms / texture buffers\n            \"   vec3 texgen_s = texgen[texprojid];\\n\"\n            \"   vec3 texgen_t = texgen[texprojid+32u];\\n\"\n            \"   float tex1_scale = texscale[tex1_id & 63u].x;\\n\"\n            \"   vec4 color = color_table[color_id & 63u];\\n\"\n            #ifndef STBVOX_CONFIG_DISABLE_TEX2\n            \"   vec4 tex2_props = texscale[tex2_id & 63u];\\n\"\n            #endif\n         #else\n            \"   vec3 texgen_s = texelFetch(texgen, int(texprojid)).xyz;\\n\"\n            \"   vec3 texgen_t = texelFetch(texgen, int(texprojid+32u)).xyz;\\n\"\n            \"   float tex1_scale = texelFetch(texscale, int(tex1_id & 127u)).x;\\n\"\n            \"   vec4 color = texelFetch(color_table, int(color_id & 63u));\\n\"\n            #ifndef STBVOX_CONFIG_DISABLE_TEX2\n            \"   vec4 tex2_props = texelFetch(texscale, int(tex1_id & 127u));\\n\"\n            #endif\n         #endif\n\n         #ifndef STBVOX_CONFIG_DISABLE_TEX2\n         \"   float tex2_scale = tex2_props.y;\\n\"\n         \"   bool texblend_mode = tex2_props.z != 0.0;\\n\"\n         #endif\n         \"   vec2 texcoord;\\n\"\n         \"   vec3 texturespace_pos = voxelspace_pos + transform[2].xyz;\\n\"\n         \"   texcoord.s = dot(texturespace_pos, texgen_s);\\n\"\n         \"   texcoord.t = dot(texturespace_pos, texgen_t);\\n\"\n\n         \"   vec2  texcoord_1 = tex1_scale * texcoord;\\n\"\n         #ifndef STBVOX_CONFIG_DISABLE_TEX2\n         \"   vec2  texcoord_2 = tex2_scale * texcoord;\\n\"\n         #endif\n\n         #ifdef STBVOX_CONFIG_TEX1_EDGE_CLAMP\n         \"   texcoord_1 = texcoord_1 - floor(texcoord_1);\\n\"\n         \"   vec4 tex1 = textureGrad(tex_array[0], vec3(texcoord_1, float(tex1_id)), dFdx(tex1_scale*texcoord), dFdy(tex1_scale*texcoord));\\n\"\n         #else\n         \"   vec4 tex1 = texture(tex_array[0], vec3(texcoord_1, float(tex1_id)));\\n\"\n         #endif\n\n         #ifndef STBVOX_CONFIG_DISABLE_TEX2\n         #ifdef STBVOX_CONFIG_TEX2_EDGE_CLAMP\n         \"   texcoord_2 = texcoord_2 - floor(texcoord_2);\\n\"\n         \"   vec4 tex2 = textureGrad(tex_array[0], vec3(texcoord_2, float(tex2_id)), dFdx(tex2_scale*texcoord), dFdy(tex2_scale*texcoord));\\n\"\n         #else\n         \"   vec4 tex2 = texture(tex_array[1], vec3(texcoord_2, float(tex2_id)));\\n\"\n         #endif\n         #endif\n\n         \"   bool emissive = (color.a > 1.0);\\n\"\n         \"   color.a = min(color.a, 1.0);\\n\"\n\n         // recolor textures\n         \"   if ((color_id &  64u) != 0u) tex1.rgba *= color.rgba;\\n\"\n         \"   fragment_alpha = tex1.a;\\n\"\n         #ifndef STBVOX_CONFIG_DISABLE_TEX2\n            \"   if ((color_id & 128u) != 0u) tex2.rgba *= color.rgba;\\n\"\n\n            #ifdef STBVOX_CONFIG_PREMULTIPLIED_ALPHA\n            \"   tex2.rgba *= texlerp;\\n\"\n            #else\n            \"   tex2.a *= texlerp;\\n\"\n            #endif\n\n            \"   if (texblend_mode)\\n\"\n            \"      albedo = tex1.xyz * rlerp(tex2.a, vec3(1.0,1.0,1.0), 2.0*tex2.xyz);\\n\"\n            \"   else {\\n\"\n            #ifdef STBVOX_CONFIG_PREMULTIPLIED_ALPHA\n            \"      albedo = (1.0-tex2.a)*tex1.xyz + tex2.xyz;\\n\"\n            #else\n            \"      albedo = rlerp(tex2.a, tex1.xyz, tex2.xyz);\\n\"\n            #endif\n            \"      fragment_alpha = tex1.a*(1-tex2.a)+tex2.a;\\n\"\n            \"   }\\n\"\n         #else\n            \"      albedo = tex1.xyz;\\n\"\n         #endif\n\n      #else // UNTEXTURED\n         \"   vec4 color;\"\n         \"   color.xyz = vec3(facedata.xyz) / 255.0;\\n\"\n         \"   bool emissive = false;\\n\"\n         \"   albedo = color.xyz;\\n\"\n         \"   fragment_alpha = 1.0;\\n\"\n      #endif\n\n      #ifdef STBVOX_ICONFIG_VARYING_VERTEX_NORMALS\n         // currently, there are no modes that trigger this path; idea is that there\n         // could be a couple of bits per vertex to perturb the normal to e.g. get curved look\n         \"   vec3 normal = normalize(vnormal);\\n\"\n      #else\n         \"   vec3 normal = vnormal;\\n\"\n      #endif\n\n      \"   vec3 ambient_color = dot(normal, ambient[0].xyz) * ambient[1].xyz + ambient[2].xyz;\\n\"\n\n      \"   ambient_color = clamp(ambient_color, 0.0, 1.0);\"\n      \"   ambient_color *= amb_occ;\\n\"\n\n      \"   vec3 lit_color;\\n\"\n      \"   if (!emissive)\\n\"\n      #if defined(STBVOX_ICONFIG_LIGHTING) || defined(STBVOX_CONFIG_LIGHTING_SIMPLE)\n         \"      lit_color = compute_lighting(voxelspace_pos + transform[1], normal, albedo, ambient_color);\\n\"\n      #else\n         \"      lit_color = albedo * ambient_color ;\\n\"\n      #endif\n      \"   else\\n\"\n      \"      lit_color = albedo;\\n\"\n\n      #if defined(STBVOX_ICONFIG_FOG) || defined(STBVOX_CONFIG_FOG_SMOOTHSTEP)\n         \"   vec3 dist = voxelspace_pos + (transform[1] - camera_pos.xyz);\\n\"\n         \"   lit_color = compute_fog(lit_color, dist, fragment_alpha);\\n\"\n      #endif\n\n      #ifdef STBVOX_CONFIG_UNPREMULTIPLY\n      \"   vec4 final_color = vec4(lit_color/fragment_alpha, fragment_alpha);\\n\"\n      #else\n      \"   vec4 final_color = vec4(lit_color, fragment_alpha);\\n\"\n      #endif\n      \"   outcolor = final_color;\\n\"\n      \"}\\n\"\n\n   #ifdef STBVOX_CONFIG_LIGHTING_SIMPLE\n      \"\\n\"\n      \"uniform vec3 light_source[2];\\n\"\n      \"vec3 compute_lighting(vec3 pos, vec3 norm, vec3 albedo, vec3 ambient)\\n\"\n      \"{\\n\"\n      \"   vec3 light_dir = light_source[0] - pos;\\n\"\n      \"   float lambert = dot(light_dir, norm) / dot(light_dir, light_dir);\\n\"\n      \"   vec3 diffuse = clamp(light_source[1] * clamp(lambert, 0.0, 1.0), 0.0, 1.0);\\n\"\n      \"   return (diffuse + ambient) * albedo;\\n\"\n      \"}\\n\"\n   #endif\n\n   #ifdef STBVOX_CONFIG_FOG_SMOOTHSTEP\n      \"\\n\"\n      \"vec3 compute_fog(vec3 color, vec3 relative_pos, float fragment_alpha)\\n\"\n      \"{\\n\"\n      \"   float f = dot(relative_pos,relative_pos)*ambient[3].w;\\n\"\n      //\"   f = rlerp(f, -2,1);\\n\"\n      \"   f = clamp(f, 0.0, 1.0);\\n\"\n      \"   f = 3.0*f*f - 2.0*f*f*f;\\n\" // smoothstep\n      //\"   f = f*f;\\n\"  // fade in more smoothly\n      #ifdef STBVOX_CONFIG_PREMULTIPLIED_ALPHA\n      \"   return rlerp(f, color.xyz, ambient[3].xyz*fragment_alpha);\\n\"\n      #else\n      \"   return rlerp(f, color.xyz, ambient[3].xyz);\\n\"\n      #endif\n      \"}\\n\"\n   #endif\n};\n\n\n// still requires full alpha lookups, including tex2 if texblend is enabled\nstatic const char *stbvox_fragment_program_alpha_only =\n{\n   STBVOX_SHADER_VERSION\n\n   // vertex-shader output data\n   \"flat in uvec4  facedata;\\n\"\n   \"     in  vec3  voxelspace_pos;\\n\"\n   \"     in float  texlerp;\\n\"\n\n   // per-buffer data\n   \"uniform vec3 transform[3];\\n\"\n\n   #ifndef STBVOX_ICONFIG_UNTEXTURED\n      // generally constant data\n      \"uniform sampler2DArray tex_array[2];\\n\"\n\n      #ifdef STBVOX_CONFIG_PREFER_TEXBUFFER\n         \"uniform samplerBuffer texscale;\\n\"\n         \"uniform samplerBuffer texgen;\\n\"\n      #else\n         \"uniform vec4 texscale[64];\\n\" // instead of 128, to avoid running out of uniforms\n         \"uniform vec3 texgen[64];\\n\"\n      #endif\n   #endif\n\n   \"out vec4  outcolor;\\n\"\n\n   \"void main()\\n\"\n   \"{\\n\"\n   \"   vec3 albedo;\\n\"\n   \"   float fragment_alpha;\\n\"\n\n   #ifndef STBVOX_ICONFIG_UNTEXTURED\n      // unpack the values\n      \"   uint tex1_id = facedata.x;\\n\"\n      \"   uint tex2_id = facedata.y;\\n\"\n      \"   uint texprojid = facedata.w & 31u;\\n\"\n      \"   uint color_id  = facedata.z;\\n\"\n\n      #ifndef STBVOX_CONFIG_PREFER_TEXBUFFER\n         // load from uniforms / texture buffers\n         \"   vec3 texgen_s = texgen[texprojid];\\n\"\n         \"   vec3 texgen_t = texgen[texprojid+32u];\\n\"\n         \"   float tex1_scale = texscale[tex1_id & 63u].x;\\n\"\n         \"   vec4 color = color_table[color_id & 63u];\\n\"\n         \"   vec4 tex2_props = texscale[tex2_id & 63u];\\n\"\n      #else\n         \"   vec3 texgen_s = texelFetch(texgen, int(texprojid)).xyz;\\n\"\n         \"   vec3 texgen_t = texelFetch(texgen, int(texprojid+32u)).xyz;\\n\"\n         \"   float tex1_scale = texelFetch(texscale, int(tex1_id & 127u)).x;\\n\"\n         \"   vec4 color = texelFetch(color_table, int(color_id & 63u));\\n\"\n         \"   vec4 tex2_props = texelFetch(texscale, int(tex2_id & 127u));\\n\"\n      #endif\n\n      #ifndef STBVOX_CONFIG_DISABLE_TEX2\n      \"   float tex2_scale = tex2_props.y;\\n\"\n      \"   bool texblend_mode = tex2_props.z &((facedata.w & 128u) != 0u);\\n\"\n      #endif\n\n      \"   color.a = min(color.a, 1.0);\\n\"\n\n      \"   vec2 texcoord;\\n\"\n      \"   vec3 texturespace_pos = voxelspace_pos + transform[2].xyz;\\n\"\n      \"   texcoord.s = dot(texturespace_pos, texgen_s);\\n\"\n      \"   texcoord.t = dot(texturespace_pos, texgen_t);\\n\"\n\n      \"   vec2  texcoord_1 = tex1_scale * texcoord;\\n\"\n      \"   vec2  texcoord_2 = tex2_scale * texcoord;\\n\"\n\n      #ifdef STBVOX_CONFIG_TEX1_EDGE_CLAMP\n      \"   texcoord_1 = texcoord_1 - floor(texcoord_1);\\n\"\n      \"   vec4 tex1 = textureGrad(tex_array[0], vec3(texcoord_1, float(tex1_id)), dFdx(tex1_scale*texcoord), dFdy(tex1_scale*texcoord));\\n\"\n      #else\n      \"   vec4 tex1 = texture(tex_array[0], vec3(texcoord_1, float(tex1_id)));\\n\"\n      #endif\n\n      \"   if ((color_id &  64u) != 0u) tex1.a *= color.a;\\n\"\n      \"   fragment_alpha = tex1.a;\\n\"\n\n      #ifndef STBVOX_CONFIG_DISABLE_TEX2\n      \"   if (!texblend_mode) {\\n\"\n         #ifdef STBVOX_CONFIG_TEX2_EDGE_CLAMP\n         \"      texcoord_2 = texcoord_2 - floor(texcoord_2);\\n\"\n         \"      vec4 tex2 = textureGrad(tex_array[0], vec3(texcoord_2, float(tex2_id)), dFdx(tex2_scale*texcoord), dFdy(tex2_scale*texcoord));\\n\"\n         #else\n         \"      vec4 tex2 = texture(tex_array[1], vec3(texcoord_2, float(tex2_id)));\\n\"\n         #endif\n\n         \"      tex2.a *= texlerp;\\n\"\n         \"      if ((color_id & 128u) != 0u) tex2.rgba *= color.a;\\n\"\n         \"      fragment_alpha = tex1.a*(1-tex2.a)+tex2.a;\\n\"\n         \"}\\n\"\n      \"\\n\"\n      #endif\n\n   #else // UNTEXTURED\n      \"   fragment_alpha = 1.0;\\n\"\n   #endif\n\n   \"   outcolor = vec4(0.0, 0.0, 0.0, fragment_alpha);\\n\"\n   \"}\\n\"\n};\n\n\nSTBVXDEC char *stbvox_get_vertex_shader(void)\n{\n   return (char *) stbvox_vertex_program;\n}\n\nSTBVXDEC char *stbvox_get_fragment_shader(void)\n{\n   return (char *) stbvox_fragment_program;\n}\n\nSTBVXDEC char *stbvox_get_fragment_shader_alpha_only(void)\n{\n   return (char *) stbvox_fragment_program_alpha_only;\n}\n\nstatic float stbvox_dummy_transform[3][3];\n\n#ifdef STBVOX_CONFIG_PREFER_TEXBUFFER\n#define STBVOX_TEXBUF 1\n#else\n#define STBVOX_TEXBUF 0\n#endif\n\nstatic stbvox_uniform_info stbvox_uniforms[] =\n{\n   { STBVOX_UNIFORM_TYPE_sampler  ,  4,   1, (char*) \"facearray\"    , 0                           },\n   { STBVOX_UNIFORM_TYPE_vec3     , 12,   3, (char*) \"transform\"    , stbvox_dummy_transform[0]   },\n   { STBVOX_UNIFORM_TYPE_sampler  ,  4,   2, (char*) \"tex_array\"    , 0                           },\n   { STBVOX_UNIFORM_TYPE_vec4     , 16, 128, (char*) \"texscale\"     , stbvox_default_texscale[0] , STBVOX_TEXBUF },\n   { STBVOX_UNIFORM_TYPE_vec4     , 16,  64, (char*) \"color_table\"  , stbvox_default_palette[0]  , STBVOX_TEXBUF },\n   { STBVOX_UNIFORM_TYPE_vec3     , 12,  32, (char*) \"normal_table\" , stbvox_default_normals[0]   },\n   { STBVOX_UNIFORM_TYPE_vec3     , 12,  64, (char*) \"texgen\"       , stbvox_default_texgen[0][0], STBVOX_TEXBUF },\n   { STBVOX_UNIFORM_TYPE_vec4     , 16,   4, (char*) \"ambient\"      , stbvox_default_ambient[0]   },\n   { STBVOX_UNIFORM_TYPE_vec4     , 16,   1, (char*) \"camera_pos\"   , stbvox_dummy_transform[0]   },\n};\n\nSTBVXDEC int stbvox_get_uniform_info(stbvox_uniform_info *info, int uniform)\n{\n   if (uniform < 0 || uniform >= STBVOX_UNIFORM_count)\n      return 0;\n\n   *info = stbvox_uniforms[uniform];\n   return 1;\n}\n\n#define STBVOX_GET_GEO(geom_data)  ((geom_data) & 15)\n\ntypedef struct\n{\n   unsigned char block:2;\n   unsigned char overlay:2;\n   unsigned char facerot:2;\n   unsigned char ecolor:2;\n} stbvox_rotate;\n\ntypedef struct\n{\n   unsigned char x,y,z;\n} stbvox_pos;\n\nstatic unsigned char stbvox_rotate_face[6][4] =\n{\n   { 0,1,2,3 },\n   { 1,2,3,0 },\n   { 2,3,0,1 },\n   { 3,0,1,2 },\n   { 4,4,4,4 },\n   { 5,5,5,5 },\n};\n\n#define STBVOX_ROTATE(x,r)   stbvox_rotate_face[x][r] // (((x)+(r))&3)\n\nstbvox_mesh_face stbvox_compute_mesh_face_value(stbvox_mesh_maker *mm, stbvox_rotate rot, int face, int v_off, int normal)\n{\n   stbvox_mesh_face face_data = { 0 };\n   stbvox_block_type bt = mm->input.blocktype[v_off];\n   unsigned char bt_face = STBVOX_ROTATE(face, rot.block);\n   int facerot = rot.facerot;\n\n   #ifdef STBVOX_ICONFIG_UNTEXTURED\n   if (mm->input.rgb) {\n      face_data.tex1  = mm->input.rgb[v_off].r;\n      face_data.tex2  = mm->input.rgb[v_off].g;\n      face_data.color = mm->input.rgb[v_off].b;\n      face_data.face_info = (normal<<2);\n      return face_data;\n   }\n   #else\n   unsigned char color_face;\n\n   if (mm->input.color)\n      face_data.color = mm->input.color[v_off];\n\n   if (mm->input.block_tex1)\n      face_data.tex1 = mm->input.block_tex1[bt];\n   else if (mm->input.block_tex1_face)\n      face_data.tex1 = mm->input.block_tex1_face[bt][bt_face];\n   else\n      face_data.tex1 = bt;\n\n   if (mm->input.block_tex2)\n      face_data.tex2 = mm->input.block_tex2[bt];\n   else if (mm->input.block_tex2_face)\n      face_data.tex2 = mm->input.block_tex2_face[bt][bt_face];\n\n   if (mm->input.block_color) {\n      unsigned char mcol = mm->input.block_color[bt];\n      if (mcol)\n         face_data.color = mcol;\n   } else if (mm->input.block_color_face) {\n      unsigned char mcol = mm->input.block_color_face[bt][bt_face];\n      if (mcol)\n         face_data.color = mcol;\n   }\n\n   if (face <= STBVOX_FACE_south) {\n      if (mm->input.side_texrot)\n         facerot = mm->input.side_texrot[v_off] >> (2 * face);\n      else if (mm->input.block_side_texrot)\n         facerot = mm->input.block_side_texrot[v_off] >> (2 * bt_face);\n   }\n\n   if (mm->input.overlay) {\n      int over_face = STBVOX_ROTATE(face, rot.overlay);\n      unsigned char over = mm->input.overlay[v_off];\n      if (over) {\n         if (mm->input.overlay_tex1) {\n            unsigned char rep1 = mm->input.overlay_tex1[over][over_face];\n            if (rep1)\n               face_data.tex1 = rep1;\n         }\n         if (mm->input.overlay_tex2) {\n            unsigned char rep2 = mm->input.overlay_tex2[over][over_face];\n            if (rep2)\n               face_data.tex2 = rep2;\n         }\n         if (mm->input.overlay_color) {\n            unsigned char rep3 = mm->input.overlay_color[over][over_face];\n            if (rep3)\n               face_data.color = rep3;\n         }\n\n         if (mm->input.overlay_side_texrot && face <= STBVOX_FACE_south)\n            facerot = mm->input.overlay_side_texrot[over] >> (2*over_face);\n      }\n   }\n\n   if (mm->input.tex2_for_tex1)\n      face_data.tex2 = mm->input.tex2_for_tex1[face_data.tex1];\n   if (mm->input.tex2)\n      face_data.tex2 = mm->input.tex2[v_off];\n   if (mm->input.tex2_replace) {\n      if (mm->input.tex2_facemask[v_off] & (1 << face))\n         face_data.tex2 = mm->input.tex2_replace[v_off];\n   }\n\n   color_face = STBVOX_ROTATE(face, rot.ecolor);\n   if (mm->input.extended_color) {\n      unsigned char ec = mm->input.extended_color[v_off];\n      if (mm->input.ecolor_facemask[ec] & (1 << color_face))\n         face_data.color = mm->input.ecolor_color[ec];\n   }\n\n   if (mm->input.color2) {\n      if (mm->input.color2_facemask[v_off] & (1 << color_face))\n         face_data.color = mm->input.color2[v_off];\n      if (mm->input.color3 && (mm->input.color3_facemask[v_off] & (1 << color_face)))\n         face_data.color = mm->input.color3[v_off];\n   }\n   #endif\n\n   face_data.face_info = (normal<<2) + facerot;\n   return face_data;\n}\n\n// these are the types of faces each block can have\nenum\n{\n   STBVOX_FT_none    ,\n   STBVOX_FT_upper   ,\n   STBVOX_FT_lower   ,\n   STBVOX_FT_solid   ,\n   STBVOX_FT_diag_012,\n   STBVOX_FT_diag_023,\n   STBVOX_FT_diag_013,\n   STBVOX_FT_diag_123,\n   STBVOX_FT_force   , // can't be covered up, used for internal faces, also hides nothing\n   STBVOX_FT_partial , // only covered by solid, never covers anything else\n\n   STBVOX_FT_count\n};\n\nstatic unsigned char stbvox_face_lerp[6] = { 0,2,0,2,4,4 };\nstatic unsigned char stbvox_vert3_lerp[5] = { 0,3,6,9,12 };\nstatic unsigned char stbvox_vert_lerp_for_face_lerp[4] = { 0, 4, 7, 7 };\nstatic unsigned char stbvox_face3_lerp[6] = { 0,3,6,9,12,14 };\nstatic unsigned char stbvox_vert_lerp_for_simple[4] = { 0,2,5,7 };\nstatic unsigned char stbvox_face3_updown[8] = { 0,2,5,7,0,2,5,7 }; // ignore top bit\n\n// vertex offsets for face vertices\nstatic unsigned char stbvox_vertex_vector[6][4][3] =\n{\n   { { 1,0,1 }, { 1,1,1 }, { 1,1,0 }, { 1,0,0 } }, // east\n   { { 1,1,1 }, { 0,1,1 }, { 0,1,0 }, { 1,1,0 } }, // north\n   { { 0,1,1 }, { 0,0,1 }, { 0,0,0 }, { 0,1,0 } }, // west\n   { { 0,0,1 }, { 1,0,1 }, { 1,0,0 }, { 0,0,0 } }, // south\n   { { 0,1,1 }, { 1,1,1 }, { 1,0,1 }, { 0,0,1 } }, // up\n   { { 0,0,0 }, { 1,0,0 }, { 1,1,0 }, { 0,1,0 } }, // down\n};\n\n// stbvox_vertex_vector, but read coordinates as binary numbers, zyx\nstatic unsigned char stbvox_vertex_selector[6][4] =\n{\n   { 5,7,3,1 },\n   { 7,6,2,3 },\n   { 6,4,0,2 },\n   { 4,5,1,0 },\n   { 6,7,5,4 },\n   { 0,1,3,2 },\n};\n\nstatic stbvox_mesh_vertex stbvox_vmesh_delta_normal[6][4] =\n{\n   {  stbvox_vertex_encode(1,0,1,0,0) ,\n      stbvox_vertex_encode(1,1,1,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0)  },\n   {  stbvox_vertex_encode(1,1,1,0,0) ,\n      stbvox_vertex_encode(0,1,1,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0)  },\n   {  stbvox_vertex_encode(0,1,1,0,0) ,\n      stbvox_vertex_encode(0,0,1,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0)  },\n   {  stbvox_vertex_encode(0,0,1,0,0) ,\n      stbvox_vertex_encode(1,0,1,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0)  },\n   {  stbvox_vertex_encode(0,1,1,0,0) ,\n      stbvox_vertex_encode(1,1,1,0,0) ,\n      stbvox_vertex_encode(1,0,1,0,0) ,\n      stbvox_vertex_encode(0,0,1,0,0)  },\n   {  stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0)  }\n};\n\nstatic stbvox_mesh_vertex stbvox_vmesh_pre_vheight[6][4] =\n{\n   {  stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0)  },\n   {  stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0)  },\n   {  stbvox_vertex_encode(0,1,0,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0)  },\n   {  stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0)  },\n   {  stbvox_vertex_encode(0,1,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(0,0,0,0,0)  },\n   {  stbvox_vertex_encode(0,0,0,0,0) ,\n      stbvox_vertex_encode(1,0,0,0,0) ,\n      stbvox_vertex_encode(1,1,0,0,0) ,\n      stbvox_vertex_encode(0,1,0,0,0)  }\n};\n\nstatic stbvox_mesh_vertex stbvox_vmesh_delta_half_z[6][4] =\n{\n   { stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0)  },\n   { stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0)  },\n   { stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(0,0,2,0,0) ,\n     stbvox_vertex_encode(0,0,0,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0)  },\n   { stbvox_vertex_encode(0,0,2,0,0) ,\n     stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0) ,\n     stbvox_vertex_encode(0,0,0,0,0)  },\n   { stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(0,0,2,0,0)  },\n   { stbvox_vertex_encode(0,0,0,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0)  }\n};\n\nstatic stbvox_mesh_vertex stbvox_vmesh_crossed_pair[6][4] =\n{\n   { stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0)  },\n   { stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(0,0,2,0,0) ,\n     stbvox_vertex_encode(0,0,0,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0)  },\n   { stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0)  },\n   { stbvox_vertex_encode(0,0,2,0,0) ,\n     stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0) ,\n     stbvox_vertex_encode(0,0,0,0,0)  },\n   // not used, so we leave it non-degenerate to make sure it doesn't get gen'd accidentally\n   { stbvox_vertex_encode(0,1,2,0,0) ,\n     stbvox_vertex_encode(1,1,2,0,0) ,\n     stbvox_vertex_encode(1,0,2,0,0) ,\n     stbvox_vertex_encode(0,0,2,0,0)  },\n   { stbvox_vertex_encode(0,0,0,0,0) ,\n     stbvox_vertex_encode(1,0,0,0,0) ,\n     stbvox_vertex_encode(1,1,0,0,0) ,\n     stbvox_vertex_encode(0,1,0,0,0)  }\n};\n\n#define STBVOX_MAX_GEOM     16\n#define STBVOX_NUM_ROTATION  4\n\n// this is used to determine if a face is ever generated at all\nstatic unsigned char stbvox_hasface[STBVOX_MAX_GEOM][STBVOX_NUM_ROTATION] =\n{\n   { 0,0,0,0 }, // empty\n   { 0,0,0,0 }, // knockout\n   { 63,63,63,63 }, // solid\n   { 63,63,63,63 }, // transp\n   { 63,63,63,63 }, // slab\n   { 63,63,63,63 }, // slab\n   { 1|2|4|48, 8|1|2|48, 4|8|1|48, 2|4|8|48, }, // floor slopes\n   { 1|2|4|48, 8|1|2|48, 4|8|1|48, 2|4|8|48, }, // ceil slopes\n   { 47,47,47,47 }, // wall-projected diagonal with down face\n   { 31,31,31,31 }, // wall-projected diagonal with up face\n   { 63,63,63,63 }, // crossed-pair has special handling, but avoid early-out\n   { 63,63,63,63 }, // force\n   { 63,63,63,63 }, // vheight\n   { 63,63,63,63 }, // vheight\n   { 63,63,63,63 }, // vheight\n   { 63,63,63,63 }, // vheight\n};\n\n// this determines which face type above is visible on each side of the geometry\nstatic unsigned char stbvox_facetype[STBVOX_GEOM_count][6] =\n{\n   { 0, },  // STBVOX_GEOM_empty\n   { STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid }, // knockout\n   { STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid, STBVOX_FT_solid }, // solid\n   { STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force }, // transp\n\n   { STBVOX_FT_upper, STBVOX_FT_upper, STBVOX_FT_upper, STBVOX_FT_upper, STBVOX_FT_solid, STBVOX_FT_force },\n   { STBVOX_FT_lower, STBVOX_FT_lower, STBVOX_FT_lower, STBVOX_FT_lower, STBVOX_FT_force, STBVOX_FT_solid },\n   { STBVOX_FT_diag_123, STBVOX_FT_solid, STBVOX_FT_diag_023, STBVOX_FT_none, STBVOX_FT_force, STBVOX_FT_solid },\n   { STBVOX_FT_diag_012, STBVOX_FT_solid, STBVOX_FT_diag_013, STBVOX_FT_none, STBVOX_FT_solid, STBVOX_FT_force },\n\n   { STBVOX_FT_diag_123, STBVOX_FT_solid, STBVOX_FT_diag_023, STBVOX_FT_force, STBVOX_FT_none, STBVOX_FT_solid },\n   { STBVOX_FT_diag_012, STBVOX_FT_solid, STBVOX_FT_diag_013, STBVOX_FT_force, STBVOX_FT_solid, STBVOX_FT_none },\n   { STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, 0,0 }, // crossed pair\n   { STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force, STBVOX_FT_force }, // GEOM_force\n\n   { STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial, STBVOX_FT_force, STBVOX_FT_solid }, // floor vheight, all neighbors forced\n   { STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial, STBVOX_FT_force, STBVOX_FT_solid }, // floor vheight, all neighbors forced\n   { STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial, STBVOX_FT_solid, STBVOX_FT_force }, // ceil vheight, all neighbors forced\n   { STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial,STBVOX_FT_partial, STBVOX_FT_solid, STBVOX_FT_force }, // ceil vheight, all neighbors forced\n};\n\n// This table indicates what normal to use for the \"up\" face of a sloped geom\n// @TODO this could be done with math given the current arrangement of the enum, but let's not require it\nstatic unsigned char stbvox_floor_slope_for_rot[4] =\n{\n   STBVF_su,\n   STBVF_wu, // @TODO: why is this reversed from what it should be? this is a north-is-up face, so slope should be south&up\n   STBVF_nu,\n   STBVF_eu,\n};\n\nstatic unsigned char stbvox_ceil_slope_for_rot[4] =\n{\n   STBVF_sd,\n   STBVF_ed,\n   STBVF_nd,\n   STBVF_wd,\n};\n\n// this table indicates whether, for each pair of types above, a face is visible.\n// each value indicates whether a given type is visible for all neighbor types\nstatic unsigned short stbvox_face_visible[STBVOX_FT_count] =\n{\n   // we encode the table by listing which cases cause *obscuration*, and bitwise inverting that\n   // table is pre-shifted by 5 to save a shift when it's accessed\n   (unsigned short) ((~0x07ffu                                          )<<5),  // none is completely obscured by everything\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_upper)   ))<<5),  // upper\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_lower)   ))<<5),  // lower\n   (unsigned short) ((~((1u<<STBVOX_FT_solid)                          ))<<5),  // solid is only completely obscured only by solid\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_diag_013)))<<5),  // diag012 matches diag013\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_diag_123)))<<5),  // diag023 matches diag123\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_diag_012)))<<5),  // diag013 matches diag012\n   (unsigned short) ((~((1u<<STBVOX_FT_solid) | (1<<STBVOX_FT_diag_023)))<<5),  // diag123 matches diag023\n   (unsigned short) ((~0u                                               )<<5),  // force is always rendered regardless, always forces neighbor\n   (unsigned short) ((~((1u<<STBVOX_FT_solid)                          ))<<5),  // partial is only completely obscured only by solid\n};\n\n// the vertex heights of the block types, in binary vertex order (zyx):\n// lower: SW, SE, NW, NE; upper: SW, SE, NW, NE\nstatic stbvox_mesh_vertex stbvox_geometry_vheight[8][8] =\n{\n   #define STBVOX_HEIGHTS(a,b,c,d,e,f,g,h) \\\n     { stbvox_vertex_encode(0,0,a,0,0),  \\\n       stbvox_vertex_encode(0,0,b,0,0),  \\\n       stbvox_vertex_encode(0,0,c,0,0),  \\\n       stbvox_vertex_encode(0,0,d,0,0),  \\\n       stbvox_vertex_encode(0,0,e,0,0),  \\\n       stbvox_vertex_encode(0,0,f,0,0),  \\\n       stbvox_vertex_encode(0,0,g,0,0),  \\\n       stbvox_vertex_encode(0,0,h,0,0) }\n\n   STBVOX_HEIGHTS(0,0,0,0, 2,2,2,2),\n   STBVOX_HEIGHTS(0,0,0,0, 2,2,2,2),\n   STBVOX_HEIGHTS(0,0,0,0, 2,2,2,2),\n   STBVOX_HEIGHTS(0,0,0,0, 2,2,2,2),\n   STBVOX_HEIGHTS(1,1,1,1, 2,2,2,2),\n   STBVOX_HEIGHTS(0,0,0,0, 1,1,1,1),\n   STBVOX_HEIGHTS(0,0,0,0, 0,0,2,2),\n   STBVOX_HEIGHTS(2,2,0,0, 2,2,2,2),\n};\n\n// rotate vertices defined as [z][y][x] coords\nstatic unsigned char stbvox_rotate_vertex[8][4] =\n{\n   { 0,1,3,2 }, // zyx=000\n   { 1,3,2,0 }, // zyx=001\n   { 2,0,1,3 }, // zyx=010\n   { 3,2,0,1 }, // zyx=011\n   { 4,5,7,6 }, // zyx=100\n   { 5,7,6,4 }, // zyx=101\n   { 6,4,5,7 }, // zyx=110\n   { 7,6,4,5 }, // zyx=111\n};\n\n#ifdef STBVOX_CONFIG_OPTIMIZED_VHEIGHT\n// optimized vheight generates a single normal over the entire face, even if it's not planar\nstatic unsigned char stbvox_optimized_face_up_normal[4][4][4][4] =\n{\n   {\n      {\n         { STBVF_u   , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_nw_u, STBVF_nu  , STBVF_nu  , STBVF_ne_u, },\n         { STBVF_nw_u, STBVF_nu  , STBVF_nu  , STBVF_nu  , },\n         { STBVF_nw_u, STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n         { STBVF_u   , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_nw_u, STBVF_nu  , STBVF_nu  , STBVF_ne_u, },\n         { STBVF_nw_u, STBVF_nu  , STBVF_nu  , STBVF_nu  , },\n      },{\n         { STBVF_eu  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n         { STBVF_u   , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_nw_u, STBVF_nu  , STBVF_nu  , STBVF_ne_u, },\n      },{\n         { STBVF_eu  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_eu  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n         { STBVF_u   , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n      },\n   },{\n      {\n         { STBVF_sw_u, STBVF_u   , STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n         { STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_u   , STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_u   , STBVF_ne_u, STBVF_ne_u, },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_u   , STBVF_ne_u, STBVF_ne_u, },\n      },\n   },{\n      {\n         { STBVF_sw_u, STBVF_sw_u, STBVF_u   , STBVF_ne_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n         { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_u   , STBVF_ne_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_u   , STBVF_ne_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_u   , STBVF_ne_u, },\n      },\n   },{\n      {\n         { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_u   , },\n         { STBVF_sw_u, STBVF_wu  , STBVF_wu  , STBVF_nw_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_wu  , STBVF_nw_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_nw_u, STBVF_nw_u, },\n      },{\n         { STBVF_sw_u, STBVF_su  , STBVF_su  , STBVF_su  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_u   , },\n         { STBVF_sw_u, STBVF_wu  , STBVF_wu  , STBVF_nw_u, },\n         { STBVF_wu  , STBVF_wu  , STBVF_wu  , STBVF_nw_u, },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_su  , STBVF_su  , STBVF_su  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_u   , },\n         { STBVF_sw_u, STBVF_wu  , STBVF_wu  , STBVF_nw_u, },\n      },{\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n         { STBVF_sw_u, STBVF_su  , STBVF_su  , STBVF_su  , },\n         { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_u   , },\n      },\n   },\n};\n#else\n// which normal to use for a given vheight that's planar\n// @TODO: this table was constructed by hand and may have bugs\n//                                 nw se sw\nstatic unsigned char stbvox_planar_face_up_normal[4][4][4] =\n{\n   {                                                      // sw,se,nw,ne;  ne = se+nw-sw\n      { STBVF_u   , 0         , 0         , 0          }, //  0,0,0,0; 1,0,0,-1; 2,0,0,-2; 3,0,0,-3;\n      { STBVF_u   , STBVF_u   , 0         , 0          }, //  0,1,0,1; 1,1,0, 0; 2,1,0,-1; 3,1,0,-2;\n      { STBVF_wu  , STBVF_nw_u, STBVF_nu  , 0          }, //  0,2,0,2; 1,2,0, 1; 2,2,0, 0; 3,2,0,-1;\n      { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nu   }, //  0,3,0,3; 1,3,0, 2; 2,3,0, 1; 3,3,0, 0;\n   },{\n      { STBVF_u   , STBVF_u   , 0         , 0          }, //  0,0,1,1; 1,0,1, 0; 2,0,1,-1; 3,0,1,-2;\n      { STBVF_sw_u, STBVF_u   , STBVF_ne_u, 0          }, //  0,1,1,2; 1,1,1, 1; 2,1,1, 0; 3,1,1,-1;\n      { STBVF_sw_u, STBVF_u   , STBVF_u   , STBVF_ne_u }, //  0,2,1,3; 1,2,1, 2; 2,2,1, 1; 3,2,1, 0;\n      { 0         , STBVF_wu  , STBVF_nw_u, STBVF_nu   }, //  0,3,1,4; 1,3,1, 3; 2,3,1, 2; 3,3,1, 1;\n   },{\n      { STBVF_su  , STBVF_se_u, STBVF_eu  , 0          }, //  0,0,2,2; 1,0,2, 1; 2,0,2, 0; 3,0,2,-1;\n      { STBVF_sw_u, STBVF_u   , STBVF_u   , STBVF_ne_u }, //  0,1,2,3; 1,1,2, 2; 2,1,2, 1; 3,1,2, 0;\n      { 0         , STBVF_sw_u, STBVF_u   , STBVF_ne_u }, //  0,2,2,4; 1,2,2, 3; 2,2,2, 2; 3,2,2, 1;\n      { 0         , 0         , STBVF_u   , STBVF_u    }, //  0,3,2,5; 1,3,2, 4; 2,3,2, 3; 3,3,2, 2;\n   },{\n      { STBVF_su  , STBVF_se_u, STBVF_se_u, STBVF_eu   }, //  0,0,3,3; 1,0,3, 2; 2,0,3, 1; 3,0,3, 0;\n      { 0         , STBVF_su  , STBVF_se_u, STBVF_eu   }, //  0,1,3,4; 1,1,3, 3; 2,1,3, 2; 3,1,3, 1;\n      { 0         , 0         , STBVF_u   , STBVF_u    }, //  0,2,3,5; 1,2,3, 4; 2,2,3, 3; 3,2,3, 2;\n      { 0         , 0         , 0         , STBVF_u    }, //  0,3,3,6; 1,3,3, 5; 2,3,3, 4; 3,3,3, 3;\n   }\n};\n\n// these tables were constructed automatically using a variant of the code\n// below; however, they seem wrong, so who knows\nstatic unsigned char stbvox_face_up_normal_012[4][4][4] =\n{\n   {\n      { STBVF_u   , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_wu  , STBVF_nu  , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_wu  , STBVF_nw_u, STBVF_nu  , STBVF_ne_u, },\n      { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_eu  , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_u   , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_wu  , STBVF_nu  , STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_wu  , STBVF_nw_u, STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_su  , STBVF_eu  , STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_u   , STBVF_ne_u, },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_wu  , STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n      { STBVF_sw_u, STBVF_su  , STBVF_eu  , STBVF_eu  , },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_su  , STBVF_eu  , },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_u   , },\n   }\n};\n\nstatic unsigned char stbvox_face_up_normal_013[4][4][4] =\n{\n   {\n      { STBVF_u   , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n      { STBVF_nw_u, STBVF_nu  , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_nw_u, STBVF_nw_u, STBVF_nu  , STBVF_ne_u, },\n      { STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n      { STBVF_wu  , STBVF_u   , STBVF_eu  , STBVF_eu  , },\n      { STBVF_nw_u, STBVF_nw_u, STBVF_nu  , STBVF_ne_u, },\n      { STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n      { STBVF_sw_u, STBVF_su  , STBVF_eu  , STBVF_eu  , },\n      { STBVF_wu  , STBVF_wu  , STBVF_u   , STBVF_eu  , },\n      { STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, STBVF_nu  , },\n   },{\n      { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_eu  , },\n      { STBVF_sw_u, STBVF_su  , STBVF_su  , STBVF_su  , },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_su  , STBVF_eu  , },\n      { STBVF_wu  , STBVF_wu  , STBVF_wu  , STBVF_u   , },\n   }\n};\n\nstatic unsigned char stbvox_face_up_normal_023[4][4][4] =\n{\n   {\n      { STBVF_u   , STBVF_nu  , STBVF_nu  , STBVF_nu  , },\n      { STBVF_eu  , STBVF_eu  , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n      { STBVF_eu  , STBVF_eu  , STBVF_eu  , STBVF_eu  , },\n   },{\n      { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_su  , STBVF_u   , STBVF_nu  , STBVF_nu  , },\n      { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n      { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n   },{\n      { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_sw_u, STBVF_wu  , STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_su  , STBVF_su  , STBVF_u   , STBVF_nu  , },\n      { STBVF_su  , STBVF_su  , STBVF_eu  , STBVF_eu  , },\n   },{\n      { STBVF_wu  , STBVF_nw_u, STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_sw_u, STBVF_wu  , STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_wu  , STBVF_nw_u, },\n      { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_u   , },\n   }\n};\n\nstatic unsigned char stbvox_face_up_normal_123[4][4][4] =\n{\n   {\n      { STBVF_u   , STBVF_nu  , STBVF_nu  , STBVF_nu  , },\n      { STBVF_eu  , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_eu  , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_eu  , STBVF_ne_u, STBVF_ne_u, STBVF_ne_u, },\n   },{\n      { STBVF_sw_u, STBVF_wu  , STBVF_nw_u, STBVF_nw_u, },\n      { STBVF_su  , STBVF_u   , STBVF_nu  , STBVF_nu  , },\n      { STBVF_eu  , STBVF_eu  , STBVF_ne_u, STBVF_ne_u, },\n      { STBVF_eu  , STBVF_eu  , STBVF_ne_u, STBVF_ne_u, },\n   },{\n      { STBVF_sw_u, STBVF_sw_u, STBVF_wu  , STBVF_nw_u, },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_wu  , STBVF_nw_u, },\n      { STBVF_su  , STBVF_su  , STBVF_u   , STBVF_nu  , },\n      { STBVF_su  , STBVF_eu  , STBVF_eu  , STBVF_ne_u, },\n   },{\n      { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_wu  , },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_wu  , },\n      { STBVF_sw_u, STBVF_sw_u, STBVF_sw_u, STBVF_wu  , },\n      { STBVF_su  , STBVF_su  , STBVF_su  , STBVF_u   , },\n   }\n};\n#endif\n\nvoid stbvox_get_quad_vertex_pointer(stbvox_mesh_maker *mm, int mesh, stbvox_mesh_vertex **vertices, stbvox_mesh_face face)\n{\n   char *p = mm->output_cur[mesh][0];\n   int step = mm->output_step[mesh][0];\n\n   // allocate a new quad from the mesh\n   vertices[0] = (stbvox_mesh_vertex *) p; p += step;\n   vertices[1] = (stbvox_mesh_vertex *) p; p += step;\n   vertices[2] = (stbvox_mesh_vertex *) p; p += step;\n   vertices[3] = (stbvox_mesh_vertex *) p; p += step;\n   mm->output_cur[mesh][0] = p;\n\n   // output the face\n   #ifdef STBVOX_ICONFIG_FACE_ATTRIBUTE\n      // write face as interleaved vertex data\n      *(stbvox_mesh_face *) (vertices[0]+1) = face;\n      *(stbvox_mesh_face *) (vertices[1]+1) = face;\n      *(stbvox_mesh_face *) (vertices[2]+1) = face;\n      *(stbvox_mesh_face *) (vertices[3]+1) = face;\n   #else\n      *(stbvox_mesh_face *) mm->output_cur[mesh][1] = face;\n      mm->output_cur[mesh][1] += 4;\n   #endif\n}\n\nvoid stbvox_make_mesh_for_face(stbvox_mesh_maker *mm, stbvox_rotate rot, int face, int v_off, stbvox_pos pos, stbvox_mesh_vertex vertbase, stbvox_mesh_vertex *face_coord, unsigned char mesh, int normal)\n{\n   stbvox_mesh_face face_data = stbvox_compute_mesh_face_value(mm,rot,face,v_off, normal);\n\n   // still need to compute ao & texlerp for each vertex\n\n   // first compute texlerp into p1\n   stbvox_mesh_vertex p1[4] = { 0 };\n\n   #if defined(STBVOX_CONFIG_DOWN_TEXLERP_PACKED) && defined(STBVOX_CONFIG_UP_TEXLERP_PACKED)\n      #define STBVOX_USE_PACKED(f) ((f) == STBVOX_FACE_up || (f) == STBVOX_FACE_down)\n   #elif defined(STBVOX_CONFIG_UP_TEXLERP_PACKED)\n      #define STBVOX_USE_PACKED(f) ((f) == STBVOX_FACE_up                           )\n   #elif defined(STBVOX_CONFIG_DOWN_TEXLERP_PACKED)\n      #define STBVOX_USE_PACKED(f) (                         (f) == STBVOX_FACE_down)\n   #endif\n\n   #if defined(STBVOX_CONFIG_DOWN_TEXLERP_PACKED) || defined(STBVOX_CONFIG_UP_TEXLERP_PACKED)\n   if (STBVOX_USE_PACKED(face)) {\n      if (!mm->input.packed_compact || 0==(mm->input.packed_compact[v_off]&16))\n         goto set_default;\n      p1[0] = (mm->input.packed_compact[v_off + mm->cube_vertex_offset[face][0]] >> 5);\n      p1[1] = (mm->input.packed_compact[v_off + mm->cube_vertex_offset[face][1]] >> 5);\n      p1[2] = (mm->input.packed_compact[v_off + mm->cube_vertex_offset[face][2]] >> 5);\n      p1[3] = (mm->input.packed_compact[v_off + mm->cube_vertex_offset[face][3]] >> 5);\n      p1[0] = stbvox_vertex_encode(0,0,0,0,p1[0]);\n      p1[1] = stbvox_vertex_encode(0,0,0,0,p1[1]);\n      p1[2] = stbvox_vertex_encode(0,0,0,0,p1[2]);\n      p1[3] = stbvox_vertex_encode(0,0,0,0,p1[3]);\n      goto skip;\n   }\n   #endif\n\n   if (mm->input.block_texlerp) {\n      stbvox_block_type bt = mm->input.blocktype[v_off];\n      unsigned char val = mm->input.block_texlerp[bt];\n      p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,val);\n   } else if (mm->input.block_texlerp_face) {\n      stbvox_block_type bt = mm->input.blocktype[v_off];\n      unsigned char bt_face = STBVOX_ROTATE(face, rot.block);\n      unsigned char val = mm->input.block_texlerp_face[bt][bt_face];\n      p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,val);\n   } else if (mm->input.texlerp_face3) {\n      unsigned char val = (mm->input.texlerp_face3[v_off] >> stbvox_face3_lerp[face]) & 7;\n      if (face >= STBVOX_FACE_up)\n         val = stbvox_face3_updown[val];\n      p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,val);\n   } else if (mm->input.texlerp_simple) {\n      unsigned char val = mm->input.texlerp_simple[v_off];\n      unsigned char lerp_face = (val >> 2) & 7;\n      if (lerp_face == face) {\n         p1[0] = (mm->input.texlerp_simple[v_off + mm->cube_vertex_offset[face][0]] >> 5) & 7;\n         p1[1] = (mm->input.texlerp_simple[v_off + mm->cube_vertex_offset[face][1]] >> 5) & 7;\n         p1[2] = (mm->input.texlerp_simple[v_off + mm->cube_vertex_offset[face][2]] >> 5) & 7;\n         p1[3] = (mm->input.texlerp_simple[v_off + mm->cube_vertex_offset[face][3]] >> 5) & 7;\n         p1[0] = stbvox_vertex_encode(0,0,0,0,p1[0]);\n         p1[1] = stbvox_vertex_encode(0,0,0,0,p1[1]);\n         p1[2] = stbvox_vertex_encode(0,0,0,0,p1[2]);\n         p1[3] = stbvox_vertex_encode(0,0,0,0,p1[3]);\n      } else {\n         unsigned char base = stbvox_vert_lerp_for_simple[val&3];\n         p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,base);\n      }\n   } else if (mm->input.texlerp) {\n      unsigned char facelerp = (mm->input.texlerp[v_off] >> stbvox_face_lerp[face]) & 3;\n      if (facelerp == STBVOX_TEXLERP_FACE_use_vert) {\n         if (mm->input.texlerp_vert3 && face != STBVOX_FACE_down) {\n            unsigned char shift = stbvox_vert3_lerp[face];\n            p1[0] = (mm->input.texlerp_vert3[mm->cube_vertex_offset[face][0]] >> shift) & 7;\n            p1[1] = (mm->input.texlerp_vert3[mm->cube_vertex_offset[face][1]] >> shift) & 7;\n            p1[2] = (mm->input.texlerp_vert3[mm->cube_vertex_offset[face][2]] >> shift) & 7;\n            p1[3] = (mm->input.texlerp_vert3[mm->cube_vertex_offset[face][3]] >> shift) & 7;\n         } else {\n            p1[0] = stbvox_vert_lerp_for_simple[mm->input.texlerp[mm->cube_vertex_offset[face][0]]>>6];\n            p1[1] = stbvox_vert_lerp_for_simple[mm->input.texlerp[mm->cube_vertex_offset[face][1]]>>6];\n            p1[2] = stbvox_vert_lerp_for_simple[mm->input.texlerp[mm->cube_vertex_offset[face][2]]>>6];\n            p1[3] = stbvox_vert_lerp_for_simple[mm->input.texlerp[mm->cube_vertex_offset[face][3]]>>6];\n         }\n         p1[0] = stbvox_vertex_encode(0,0,0,0,p1[0]);\n         p1[1] = stbvox_vertex_encode(0,0,0,0,p1[1]);\n         p1[2] = stbvox_vertex_encode(0,0,0,0,p1[2]);\n         p1[3] = stbvox_vertex_encode(0,0,0,0,p1[3]);\n      } else {\n         p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,stbvox_vert_lerp_for_face_lerp[facelerp]);\n      }\n   } else {\n      #if defined(STBVOX_CONFIG_UP_TEXLERP_PACKED) || defined(STBVOX_CONFIG_DOWN_TEXLERP_PACKED)\n      set_default:\n      #endif\n      p1[0] = p1[1] = p1[2] = p1[3] = stbvox_vertex_encode(0,0,0,0,7); // @TODO make this configurable\n   }\n\n   #if defined(STBVOX_CONFIG_UP_TEXLERP_PACKED) || defined(STBVOX_CONFIG_DOWN_TEXLERP_PACKED)\n   skip:\n   #endif\n\n   // now compute lighting and store to vertices\n   {\n      stbvox_mesh_vertex *mv[4];\n      stbvox_get_quad_vertex_pointer(mm, mesh, mv, face_data);\n\n      if (mm->input.lighting) {\n         // @TODO: lighting at block centers, but not gathered, instead constant-per-face\n         if (mm->input.lighting_at_vertices) {\n            int i;\n            for (i=0; i < 4; ++i) {\n               *mv[i] = vertbase + face_coord[i]\n                          + stbvox_vertex_encode(0,0,0,mm->input.lighting[v_off + mm->cube_vertex_offset[face][i]] & 63,0)\n                          + p1[i];\n            }\n         } else {\n            unsigned char *amb = &mm->input.lighting[v_off];\n            int i,j;\n            #if defined(STBVOX_CONFIG_ROTATION_IN_LIGHTING) || defined(STBVOX_CONFIG_VHEIGHT_IN_LIGHTING)\n            #define STBVOX_GET_LIGHTING(light) ((light) & ~3)\n            #define STBVOX_LIGHTING_ROUNDOFF   8\n            #else\n            #define STBVOX_GET_LIGHTING(light) (light)\n            #define STBVOX_LIGHTING_ROUNDOFF   2\n            #endif\n\n            for (i=0; i < 4; ++i) {\n               // for each vertex, gather from the four neighbor blocks it's facing\n               unsigned char *vamb = &amb[mm->cube_vertex_offset[face][i]];\n               int total=0;\n               for (j=0; j < 4; ++j)\n                  total += STBVOX_GET_LIGHTING(vamb[mm->vertex_gather_offset[face][j]]);\n               *mv[i] = vertbase + face_coord[i]\n                          + stbvox_vertex_encode(0,0,0,(total+STBVOX_LIGHTING_ROUNDOFF)>>4,0)\n                          + p1[i];\n                          // >> 4 is because:\n                          //   >> 2 to divide by 4 to get average over 4 samples\n                          //   >> 2 because input is 8 bits, output is 6 bits\n            }\n\n            // @TODO: note that gathering baked *lighting*\n            // is different from gathering baked ao; baked ao can count\n            // solid blocks as 0 ao, but baked lighting wants average\n            // of non-blocked--not take average & treat blocked as 0. And\n            // we can't bake the right value into the solid blocks\n            // because they can have different lighting values on\n            // different sides. So we need to actually gather and\n            // then divide by 0..4 (which we can do with a table-driven\n            // multiply, or have an 'if' for the 3 case)\n\n         }\n      } else {\n         vertbase += stbvox_vertex_encode(0,0,0,63,0);\n         *mv[0] = vertbase + face_coord[0] + p1[0];\n         *mv[1] = vertbase + face_coord[1] + p1[1];\n         *mv[2] = vertbase + face_coord[2] + p1[2];\n         *mv[3] = vertbase + face_coord[3] + p1[3];\n      }\n   }\n}\n\n// get opposite-facing normal & texgen for opposite face, used to map up-facing vheight data to down-facing data\nstatic unsigned char stbvox_reverse_face[STBVF_count] =\n{\n   STBVF_w, STBVF_s, STBVF_e, STBVF_n, STBVF_d   , STBVF_u   , STBVF_wd, STBVF_wu,\n         0,       0,       0,       0, STBVF_sw_d, STBVF_sw_u, STBVF_sd, STBVF_su,\n         0,       0,       0,       0, STBVF_se_d, STBVF_se_u, STBVF_ed, STBVF_eu,\n         0,       0,       0,       0, STBVF_ne_d, STBVF_ne_d, STBVF_nd, STBVF_nu\n};\n\n#ifndef STBVOX_CONFIG_OPTIMIZED_VHEIGHT\n// render non-planar quads by splitting into two triangles, rendering each as a degenerate quad\nstatic void stbvox_make_12_split_mesh_for_face(stbvox_mesh_maker *mm, stbvox_rotate rot, int face, int v_off, stbvox_pos pos, stbvox_mesh_vertex vertbase, stbvox_mesh_vertex *face_coord, unsigned char mesh, unsigned char *ht)\n{\n   stbvox_mesh_vertex v[4];\n\n   unsigned char normal1 = stbvox_face_up_normal_012[ht[2]][ht[1]][ht[0]];\n   unsigned char normal2 = stbvox_face_up_normal_123[ht[3]][ht[2]][ht[1]];\n\n   if (face == STBVOX_FACE_down) {\n      normal1 = stbvox_reverse_face[normal1];\n      normal2 = stbvox_reverse_face[normal2];\n   }\n\n   // the floor side face_coord is stored in order NW,NE,SE,SW, but ht[] is stored SW,SE,NW,NE\n   v[0] = face_coord[2];\n   v[1] = face_coord[3];\n   v[2] = face_coord[0];\n   v[3] = face_coord[2];\n   stbvox_make_mesh_for_face(mm, rot, face, v_off, pos, vertbase, v, mesh, normal1);\n   v[1] = face_coord[0];\n   v[2] = face_coord[1];\n   stbvox_make_mesh_for_face(mm, rot, face, v_off, pos, vertbase, v, mesh, normal2);\n}\n\nstatic void stbvox_make_03_split_mesh_for_face(stbvox_mesh_maker *mm, stbvox_rotate rot, int face, int v_off, stbvox_pos pos, stbvox_mesh_vertex vertbase, stbvox_mesh_vertex *face_coord, unsigned char mesh, unsigned char *ht)\n{\n   stbvox_mesh_vertex v[4];\n\n   unsigned char normal1 = stbvox_face_up_normal_013[ht[3]][ht[1]][ht[0]];\n   unsigned char normal2 = stbvox_face_up_normal_023[ht[3]][ht[2]][ht[0]];\n\n   if (face == STBVOX_FACE_down) {\n      normal1 = stbvox_reverse_face[normal1];\n      normal2 = stbvox_reverse_face[normal2];\n   }\n\n   v[0] = face_coord[1];\n   v[1] = face_coord[2];\n   v[2] = face_coord[3];\n   v[3] = face_coord[1];\n   stbvox_make_mesh_for_face(mm, rot, face, v_off, pos, vertbase, v, mesh, normal1);\n   v[1] = face_coord[3];\n   v[2] = face_coord[0];\n   stbvox_make_mesh_for_face(mm, rot, face, v_off, pos, vertbase, v, mesh, normal2);  // this one is correct!\n}\n#endif\n\n#ifndef STBVOX_CONFIG_PRECISION_Z\n#define STBVOX_CONFIG_PRECISION_Z 1\n#endif\n\n// simple case for mesh generation: we have only solid and empty blocks\nstatic void stbvox_make_mesh_for_block(stbvox_mesh_maker *mm, stbvox_pos pos, int v_off, stbvox_mesh_vertex *vmesh)\n{\n   int ns_off = mm->y_stride_in_bytes;\n   int ew_off = mm->x_stride_in_bytes;\n\n   unsigned char *blockptr = &mm->input.blocktype[v_off];\n   stbvox_mesh_vertex basevert = stbvox_vertex_encode(pos.x, pos.y, pos.z << STBVOX_CONFIG_PRECISION_Z , 0,0);\n\n   stbvox_rotate rot = { 0,0,0,0 };\n   unsigned char simple_rot = 0;\n\n   unsigned char mesh = mm->default_mesh;\n\n   if (mm->input.selector)\n      mesh = mm->input.selector[v_off];\n   else if (mm->input.block_selector)\n      mesh = mm->input.block_selector[mm->input.blocktype[v_off]];\n\n   // check if we're going off the end\n   if (mm->output_cur[mesh][0] + mm->output_size[mesh][0]*6 > mm->output_end[mesh][0]) {\n      mm->full = 1;\n      return;\n   }\n\n   #ifdef STBVOX_CONFIG_ROTATION_IN_LIGHTING\n   simple_rot = mm->input.lighting[v_off] & 3;\n   #endif\n\n   if (mm->input.packed_compact)\n      simple_rot = mm->input.packed_compact[v_off] & 3;\n\n   if (blockptr[ 1]==0) {\n      rot.facerot = simple_rot;\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_up  , v_off, pos, basevert, vmesh+4*STBVOX_FACE_up, mesh, STBVOX_FACE_up);\n   }\n   if (blockptr[-1]==0) {\n      rot.facerot = (-simple_rot) & 3;\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_down, v_off, pos, basevert, vmesh+4*STBVOX_FACE_down, mesh, STBVOX_FACE_down);\n   }\n\n   if (mm->input.rotate) {\n      unsigned char val = mm->input.rotate[v_off];\n      rot.block   = (val >> 0) & 3;\n      rot.overlay = (val >> 2) & 3;\n      //rot.tex2    = (val >> 4) & 3;\n      rot.ecolor  = (val >> 6) & 3;\n   } else {\n      rot.block = rot.overlay = rot.ecolor = simple_rot;\n   }\n   rot.facerot = 0;\n\n   if (blockptr[ ns_off]==0)\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_north, v_off, pos, basevert, vmesh+4*STBVOX_FACE_north, mesh, STBVOX_FACE_north);\n   if (blockptr[-ns_off]==0)\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_south, v_off, pos, basevert, vmesh+4*STBVOX_FACE_south, mesh, STBVOX_FACE_south);\n   if (blockptr[ ew_off]==0)\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_east , v_off, pos, basevert, vmesh+4*STBVOX_FACE_east, mesh, STBVOX_FACE_east);\n   if (blockptr[-ew_off]==0)\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_west , v_off, pos, basevert, vmesh+4*STBVOX_FACE_west, mesh, STBVOX_FACE_west);\n}\n\n// complex case for mesh generation: we have lots of different\n// block types, and we don't want to generate faces of blocks\n// if they're hidden by neighbors.\n//\n// we use lots of tables to determine this: we have a table\n// which tells us what face type is generated for each type of\n// geometry, and then a table that tells us whether that type\n// is hidden by a neighbor.\nstatic void stbvox_make_mesh_for_block_with_geo(stbvox_mesh_maker *mm, stbvox_pos pos, int v_off)\n{\n   int ns_off = mm->y_stride_in_bytes;\n   int ew_off = mm->x_stride_in_bytes;\n   int visible_faces, visible_base;\n   unsigned char mesh;\n\n   // first gather the geometry info for this block and all neighbors\n\n   unsigned char bt, nbt[6];\n   unsigned char geo, ngeo[6];\n   unsigned char rot, nrot[6];\n\n   bt = mm->input.blocktype[v_off];\n   nbt[0] = mm->input.blocktype[v_off + ew_off];\n   nbt[1] = mm->input.blocktype[v_off + ns_off];\n   nbt[2] = mm->input.blocktype[v_off - ew_off];\n   nbt[3] = mm->input.blocktype[v_off - ns_off];\n   nbt[4] = mm->input.blocktype[v_off +      1];\n   nbt[5] = mm->input.blocktype[v_off -      1];\n   if (mm->input.geometry) {\n      int i;\n      geo = mm->input.geometry[v_off];\n      ngeo[0] = mm->input.geometry[v_off + ew_off];\n      ngeo[1] = mm->input.geometry[v_off + ns_off];\n      ngeo[2] = mm->input.geometry[v_off - ew_off];\n      ngeo[3] = mm->input.geometry[v_off - ns_off];\n      ngeo[4] = mm->input.geometry[v_off +      1];\n      ngeo[5] = mm->input.geometry[v_off -      1];\n\n      rot = (geo >> 4) & 3;\n      geo &= 15;\n      for (i=0; i < 6; ++i) {\n         nrot[i] = (ngeo[i] >> 4) & 3;\n         ngeo[i] &= 15;\n      }\n   } else {\n      int i;\n      assert(mm->input.block_geometry);\n      geo = mm->input.block_geometry[bt];\n      for (i=0; i < 6; ++i)\n         ngeo[i] = mm->input.block_geometry[nbt[i]];\n      if (mm->input.selector) {\n         #ifndef STBVOX_CONFIG_ROTATION_IN_LIGHTING\n         if (mm->input.packed_compact == NULL) {\n            rot     = (mm->input.selector[v_off         ] >> 4) & 3;\n            nrot[0] = (mm->input.selector[v_off + ew_off] >> 4) & 3;\n            nrot[1] = (mm->input.selector[v_off + ns_off] >> 4) & 3;\n            nrot[2] = (mm->input.selector[v_off - ew_off] >> 4) & 3;\n            nrot[3] = (mm->input.selector[v_off - ns_off] >> 4) & 3;\n            nrot[4] = (mm->input.selector[v_off +      1] >> 4) & 3;\n            nrot[5] = (mm->input.selector[v_off -      1] >> 4) & 3;\n         }\n         #endif\n      } else {\n         #ifndef STBVOX_CONFIG_ROTATION_IN_LIGHTING\n         if (mm->input.packed_compact == NULL) {\n            rot = (geo>>4)&3;\n            geo &= 15;\n            for (i=0; i < 6; ++i) {\n               nrot[i] = (ngeo[i]>>4)&3;\n               ngeo[i] &= 15;\n            }\n         }\n         #endif\n      }\n   }\n\n   #ifndef STBVOX_CONFIG_ROTATION_IN_LIGHTING\n   if (mm->input.packed_compact) {\n      rot = mm->input.packed_compact[rot] & 3;\n      nrot[0] = mm->input.packed_compact[v_off + ew_off] & 3;\n      nrot[1] = mm->input.packed_compact[v_off + ns_off] & 3;\n      nrot[2] = mm->input.packed_compact[v_off - ew_off] & 3;\n      nrot[3] = mm->input.packed_compact[v_off - ns_off] & 3;\n      nrot[4] = mm->input.packed_compact[v_off +      1] & 3;\n      nrot[5] = mm->input.packed_compact[v_off -      1] & 3;\n   }\n   #else\n   rot = mm->input.lighting[v_off] & 3;\n   nrot[0] = (mm->input.lighting[v_off + ew_off]) & 3;\n   nrot[1] = (mm->input.lighting[v_off + ns_off]) & 3;\n   nrot[2] = (mm->input.lighting[v_off - ew_off]) & 3;\n   nrot[3] = (mm->input.lighting[v_off - ns_off]) & 3;\n   nrot[4] = (mm->input.lighting[v_off +      1]) & 3;\n   nrot[5] = (mm->input.lighting[v_off -      1]) & 3;\n   #endif\n\n   if (geo == STBVOX_GEOM_transp) {\n      // transparency has a special rule: if the blocktype is the same,\n      // and the faces are compatible, then can hide them; otherwise,\n      // force them on\n      // Note that this means we don't support any transparentshapes other\n      // than solid blocks, since detecting them is too complicated. If\n      // you wanted to do something like minecraft water, you probably\n      // should just do that with a separate renderer anyway. (We don't\n      // support transparency sorting so you need to use alpha test\n      // anyway)\n      int i;\n      for (i=0; i < 6; ++i)\n         if (nbt[i] != bt) {\n            nbt[i] = 0;\n            ngeo[i] = STBVOX_GEOM_empty;\n         } else\n            ngeo[i] = STBVOX_GEOM_solid;\n      geo = STBVOX_GEOM_solid;\n   }\n\n   // now compute the face visibility\n   visible_base = stbvox_hasface[geo][rot];\n   // @TODO: assert(visible_base != 0); // we should have early-outted earlier in this case\n   visible_faces = 0;\n\n   // now, for every face that might be visible, check if neighbor hides it\n   if (visible_base & (1 << STBVOX_FACE_east)) {\n      int  type = stbvox_facetype[ geo   ][(STBVOX_FACE_east+ rot   )&3];\n      int ntype = stbvox_facetype[ngeo[0]][(STBVOX_FACE_west+nrot[0])&3];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_east)) & (1 << STBVOX_FACE_east);\n   }\n   if (visible_base & (1 << STBVOX_FACE_north)) {\n      int  type = stbvox_facetype[ geo   ][(STBVOX_FACE_north+ rot   )&3];\n      int ntype = stbvox_facetype[ngeo[1]][(STBVOX_FACE_south+nrot[1])&3];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_north)) & (1 << STBVOX_FACE_north);\n   }\n   if (visible_base & (1 << STBVOX_FACE_west)) {\n      int  type = stbvox_facetype[ geo   ][(STBVOX_FACE_west+ rot   )&3];\n      int ntype = stbvox_facetype[ngeo[2]][(STBVOX_FACE_east+nrot[2])&3];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_west)) & (1 << STBVOX_FACE_west);\n   }\n   if (visible_base & (1 << STBVOX_FACE_south)) {\n      int  type = stbvox_facetype[ geo   ][(STBVOX_FACE_south+ rot   )&3];\n      int ntype = stbvox_facetype[ngeo[3]][(STBVOX_FACE_north+nrot[3])&3];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_south)) & (1 << STBVOX_FACE_south);\n   }\n   if (visible_base & (1 << STBVOX_FACE_up)) {\n      int  type = stbvox_facetype[ geo   ][STBVOX_FACE_up];\n      int ntype = stbvox_facetype[ngeo[4]][STBVOX_FACE_down];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_up)) & (1 << STBVOX_FACE_up);\n   }\n   if (visible_base & (1 << STBVOX_FACE_down)) {\n      int  type = stbvox_facetype[ geo   ][STBVOX_FACE_down];\n      int ntype = stbvox_facetype[ngeo[5]][STBVOX_FACE_up];\n      visible_faces |= ((stbvox_face_visible[type]) >> (ntype + 5 - STBVOX_FACE_down)) & (1 << STBVOX_FACE_down);\n   }\n\n   if (geo == STBVOX_GEOM_force)\n      geo = STBVOX_GEOM_solid;\n\n   assert((geo == STBVOX_GEOM_crossed_pair) ? (visible_faces == 15) : 1);\n\n   // now we finally know for sure which faces are getting generated\n   if (visible_faces == 0)\n      return;\n\n   mesh = mm->default_mesh;\n   if (mm->input.selector)\n      mesh = mm->input.selector[v_off];\n   else if (mm->input.block_selector)\n      mesh = mm->input.block_selector[bt];\n\n   if (geo <= STBVOX_GEOM_ceil_slope_north_is_bottom) {\n      // this is the simple case, we can just use regular block gen with special vmesh calculated with vheight\n      stbvox_mesh_vertex basevert;\n      stbvox_mesh_vertex vmesh[6][4];\n      stbvox_rotate rotate = { 0,0,0,0 };\n      unsigned char simple_rot = rot;\n      int i;\n      // we only need to do this for the displayed faces, but it's easier\n      // to just do it up front; @OPTIMIZE check if it's faster to do it\n      // for visible faces only\n      for (i=0; i < 6*4; ++i) {\n         int vert = stbvox_vertex_selector[0][i];\n         vert = stbvox_rotate_vertex[vert][rot];\n         vmesh[0][i] = stbvox_vmesh_pre_vheight[0][i]\n                     + stbvox_geometry_vheight[geo][vert];\n      }\n\n      basevert = stbvox_vertex_encode(pos.x, pos.y, pos.z << STBVOX_CONFIG_PRECISION_Z, 0,0);\n      if (mm->input.selector) {\n         mesh = mm->input.selector[v_off];\n      } else if (mm->input.block_selector)\n         mesh = mm->input.block_selector[bt];\n\n\n      // check if we're going off the end\n      if (mm->output_cur[mesh][0] + mm->output_size[mesh][0]*6 > mm->output_end[mesh][0]) {\n         mm->full = 1;\n         return;\n      }\n\n      if (geo >= STBVOX_GEOM_floor_slope_north_is_top) {\n         if (visible_faces & (1 << STBVOX_FACE_up)) {\n            int normal = geo == STBVOX_GEOM_floor_slope_north_is_top ? stbvox_floor_slope_for_rot[simple_rot] : STBVOX_FACE_up;\n            rotate.facerot = simple_rot;\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_up  , v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, normal);\n         }\n         if (visible_faces & (1 << STBVOX_FACE_down)) {\n            int normal = geo == STBVOX_GEOM_ceil_slope_north_is_bottom ? stbvox_ceil_slope_for_rot[simple_rot] : STBVOX_FACE_down;\n            rotate.facerot = (-rotate.facerot) & 3;\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, normal);\n         }\n      } else {\n         if (visible_faces & (1 << STBVOX_FACE_up)) {\n            rotate.facerot = simple_rot;\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_up  , v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, STBVOX_FACE_up);\n         }\n         if (visible_faces & (1 << STBVOX_FACE_down)) {\n            rotate.facerot = (-rotate.facerot) & 3;\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, STBVOX_FACE_down);\n         }\n      }\n\n      if (mm->input.rotate) {\n         unsigned char val = mm->input.rotate[v_off];\n         rotate.block   = (val >> 0) & 3;\n         rotate.overlay = (val >> 2) & 3;\n         //rotate.tex2    = (val >> 4) & 3;\n         rotate.ecolor  = (val >> 6) & 3;\n      } else {\n         rotate.block = rotate.overlay = rotate.ecolor = simple_rot;\n      }\n\n      rotate.facerot = 0;\n\n      if (visible_faces & (1 << STBVOX_FACE_north))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_north, v_off, pos, basevert, vmesh[STBVOX_FACE_north], mesh, STBVOX_FACE_north);\n      if (visible_faces & (1 << STBVOX_FACE_south))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_south, v_off, pos, basevert, vmesh[STBVOX_FACE_south], mesh, STBVOX_FACE_south);\n      if (visible_faces & (1 << STBVOX_FACE_east))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_east , v_off, pos, basevert, vmesh[STBVOX_FACE_east ], mesh, STBVOX_FACE_east);\n      if (visible_faces & (1 << STBVOX_FACE_west))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_west , v_off, pos, basevert, vmesh[STBVOX_FACE_west ], mesh, STBVOX_FACE_west);\n   }\n   if (geo >= STBVOX_GEOM_floor_vheight_03) {\n      // this case can also be generated with regular block gen with special vmesh,\n      // except:\n      //     if we want to generate middle diagonal for 'weird' blocks\n      //     it's more complicated to detect neighbor matchups\n      stbvox_mesh_vertex vmesh[6][4];\n      stbvox_mesh_vertex cube[8];\n      stbvox_mesh_vertex basevert;\n      stbvox_rotate rotate = { 0,0,0,0 };\n      unsigned char simple_rot = rot;\n      unsigned char ht[4];\n      int extreme;\n\n      // extract the heights\n      #ifdef STBVOX_CONFIG_VHEIGHT_IN_LIGHTING\n      ht[0] = mm->input.lighting[v_off              ] & 3;\n      ht[1] = mm->input.lighting[v_off+ew_off       ] & 3;\n      ht[2] = mm->input.lighting[v_off       +ns_off] & 3;\n      ht[3] = mm->input.lighting[v_off+ew_off+ns_off] & 3;\n      #else\n      if (mm->input.vheight) {\n         unsigned char v =  mm->input.vheight[v_off];\n         ht[0] = (v >> 0) & 3;\n         ht[1] = (v >> 2) & 3;\n         ht[2] = (v >> 4) & 3;\n         ht[3] = (v >> 6) & 3;\n      } else if (mm->input.block_vheight) {\n         unsigned char v = mm->input.block_vheight[bt];\n         unsigned char raw[4];\n         int i;\n\n         raw[0] = (v >> 0) & 3;\n         raw[1] = (v >> 2) & 3;\n         raw[2] = (v >> 4) & 3;\n         raw[3] = (v >> 6) & 3;\n\n         for (i=0; i < 4; ++i)\n            ht[i] = raw[stbvox_rotate_vertex[i][rot]];\n      } else if (mm->input.packed_compact) {\n         ht[0] = (mm->input.packed_compact[v_off              ] >> 2) & 3;\n         ht[1] = (mm->input.packed_compact[v_off+ew_off       ] >> 2) & 3;\n         ht[2] = (mm->input.packed_compact[v_off       +ns_off] >> 2) & 3;\n         ht[3] = (mm->input.packed_compact[v_off+ew_off+ns_off] >> 2) & 3;\n      } else if (mm->input.geometry) {\n         ht[0] = mm->input.geometry[v_off              ] >> 6;\n         ht[1] = mm->input.geometry[v_off+ew_off       ] >> 6;\n         ht[2] = mm->input.geometry[v_off       +ns_off] >> 6;\n         ht[3] = mm->input.geometry[v_off+ew_off+ns_off] >> 6;\n      } else {\n         assert(0);\n      }\n      #endif\n\n      // flag whether any sides go off the top of the block, which means\n      // our visible_faces test was wrong\n      extreme = (ht[0] == 3 || ht[1] == 3 || ht[2] == 3 || ht[3] == 3);\n\n      if (geo >= STBVOX_GEOM_ceil_vheight_03) {\n         cube[0] = stbvox_vertex_encode(0,0,ht[0],0,0);\n         cube[1] = stbvox_vertex_encode(0,0,ht[1],0,0);\n         cube[2] = stbvox_vertex_encode(0,0,ht[2],0,0);\n         cube[3] = stbvox_vertex_encode(0,0,ht[3],0,0);\n         cube[4] = stbvox_vertex_encode(0,0,2,0,0);\n         cube[5] = stbvox_vertex_encode(0,0,2,0,0);\n         cube[6] = stbvox_vertex_encode(0,0,2,0,0);\n         cube[7] = stbvox_vertex_encode(0,0,2,0,0);\n      } else {\n         cube[0] = stbvox_vertex_encode(0,0,0,0,0);\n         cube[1] = stbvox_vertex_encode(0,0,0,0,0);\n         cube[2] = stbvox_vertex_encode(0,0,0,0,0);\n         cube[3] = stbvox_vertex_encode(0,0,0,0,0);\n         cube[4] = stbvox_vertex_encode(0,0,ht[0],0,0);\n         cube[5] = stbvox_vertex_encode(0,0,ht[1],0,0);\n         cube[6] = stbvox_vertex_encode(0,0,ht[2],0,0);\n         cube[7] = stbvox_vertex_encode(0,0,ht[3],0,0);\n      }\n      if (!mm->input.vheight && mm->input.block_vheight) {\n         // @TODO: support block vheight here, I've forgotten what needs to be done specially\n      }\n\n      // build vertex mesh\n      {\n         int i;\n         for (i=0; i < 6*4; ++i) {\n            int vert = stbvox_vertex_selector[0][i];\n            vmesh[0][i] = stbvox_vmesh_pre_vheight[0][i]\n                        + cube[vert];\n         }\n      }\n\n      basevert = stbvox_vertex_encode(pos.x, pos.y, pos.z << STBVOX_CONFIG_PRECISION_Z, 0,0);\n      // check if we're going off the end\n      if (mm->output_cur[mesh][0] + mm->output_size[mesh][0]*6 > mm->output_end[mesh][0]) {\n         mm->full = 1;\n         return;\n      }\n\n      // @TODO generate split faces\n      if (visible_faces & (1 << STBVOX_FACE_up)) {\n         if (geo >= STBVOX_GEOM_ceil_vheight_03)\n            // flat\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_up  , v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, STBVOX_FACE_up);\n         else {\n         #ifndef STBVOX_CONFIG_OPTIMIZED_VHEIGHT\n            // check if it's non-planar\n            if (cube[5] + cube[6] != cube[4] + cube[7]) {\n               // not planar, split along diagonal and make degenerate quads\n               if (geo == STBVOX_GEOM_floor_vheight_03)\n                  stbvox_make_03_split_mesh_for_face(mm, rotate, STBVOX_FACE_up, v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, ht);\n               else\n                  stbvox_make_12_split_mesh_for_face(mm, rotate, STBVOX_FACE_up, v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, ht);\n            } else\n               stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_up  , v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, stbvox_planar_face_up_normal[ht[2]][ht[1]][ht[0]]);\n         #else\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_up  , v_off, pos, basevert, vmesh[STBVOX_FACE_up], mesh, stbvox_optimized_face_up_normal[ht[3]][ht[2]][ht[1]][ht[0]]);\n         #endif\n         }\n      }\n      if (visible_faces & (1 << STBVOX_FACE_down)) {\n         if (geo < STBVOX_GEOM_ceil_vheight_03)\n            // flat\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, STBVOX_FACE_down);\n         else {\n         #ifndef STBVOX_CONFIG_OPTIMIZED_VHEIGHT\n            // check if it's non-planar\n            if (cube[1] + cube[2] != cube[0] + cube[3]) {\n               // not planar, split along diagonal and make degenerate quads\n               if (geo == STBVOX_GEOM_ceil_vheight_03)\n                  stbvox_make_03_split_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, ht);\n               else\n                  stbvox_make_12_split_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, ht);\n            } else\n               stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, stbvox_reverse_face[stbvox_planar_face_up_normal[ht[2]][ht[1]][ht[0]]]);\n         #else\n            stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_down, v_off, pos, basevert, vmesh[STBVOX_FACE_down], mesh, stbvox_reverse_face[stbvox_optimized_face_up_normal[ht[3]][ht[2]][ht[1]][ht[0]]]);\n         #endif\n         }\n      }\n\n      if (mm->input.rotate) {\n         unsigned char val = mm->input.rotate[v_off];\n         rotate.block   = (val >> 0) & 3;\n         rotate.overlay = (val >> 2) & 3;\n         //rotate.tex2    = (val >> 4) & 3;\n         rotate.ecolor  = (val >> 6) & 3;\n      } else if (mm->input.selector) {\n         rotate.block = rotate.overlay = rotate.ecolor = simple_rot;\n      }\n\n      if ((visible_faces & (1 << STBVOX_FACE_north)) || (extreme && (ht[2] == 3 || ht[3] == 3)))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_north, v_off, pos, basevert, vmesh[STBVOX_FACE_north], mesh, STBVOX_FACE_north);\n      if ((visible_faces & (1 << STBVOX_FACE_south)) || (extreme && (ht[0] == 3 || ht[1] == 3)))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_south, v_off, pos, basevert, vmesh[STBVOX_FACE_south], mesh, STBVOX_FACE_south);\n      if ((visible_faces & (1 << STBVOX_FACE_east)) || (extreme && (ht[1] == 3 || ht[3] == 3)))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_east , v_off, pos, basevert, vmesh[STBVOX_FACE_east ], mesh, STBVOX_FACE_east);\n      if ((visible_faces & (1 << STBVOX_FACE_west)) || (extreme && (ht[0] == 3 || ht[2] == 3)))\n         stbvox_make_mesh_for_face(mm, rotate, STBVOX_FACE_west , v_off, pos, basevert, vmesh[STBVOX_FACE_west ], mesh, STBVOX_FACE_west);\n   }\n\n   if (geo == STBVOX_GEOM_crossed_pair) {\n      // this can be generated with a special vmesh\n      stbvox_mesh_vertex basevert = stbvox_vertex_encode(pos.x, pos.y, pos.z << STBVOX_CONFIG_PRECISION_Z , 0,0);\n      unsigned char simple_rot=0;\n      stbvox_rotate rot = { 0,0,0,0 };\n      unsigned char mesh = mm->default_mesh;\n      if (mm->input.selector) {\n         mesh = mm->input.selector[v_off];\n         simple_rot = mesh >> 4;\n         mesh &= 15;\n      }\n      if (mm->input.block_selector) {\n         mesh = mm->input.block_selector[bt];\n      }\n\n      // check if we're going off the end\n      if (mm->output_cur[mesh][0] + mm->output_size[mesh][0]*4 > mm->output_end[mesh][0]) {\n         mm->full = 1;\n         return;\n      }\n\n      if (mm->input.rotate) {\n         unsigned char val = mm->input.rotate[v_off];\n         rot.block   = (val >> 0) & 3;\n         rot.overlay = (val >> 2) & 3;\n         //rot.tex2    = (val >> 4) & 3;\n         rot.ecolor  = (val >> 6) & 3;\n      } else if (mm->input.selector) {\n         rot.block = rot.overlay = rot.ecolor = simple_rot;\n      }\n      rot.facerot = 0;\n\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_north, v_off, pos, basevert, stbvox_vmesh_crossed_pair[STBVOX_FACE_north], mesh, STBVF_ne_u_cross);\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_south, v_off, pos, basevert, stbvox_vmesh_crossed_pair[STBVOX_FACE_south], mesh, STBVF_sw_u_cross);\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_east , v_off, pos, basevert, stbvox_vmesh_crossed_pair[STBVOX_FACE_east ], mesh, STBVF_se_u_cross);\n      stbvox_make_mesh_for_face(mm, rot, STBVOX_FACE_west , v_off, pos, basevert, stbvox_vmesh_crossed_pair[STBVOX_FACE_west ], mesh, STBVF_nw_u_cross);\n   }\n\n\n   // @TODO\n   // STBVOX_GEOM_floor_slope_north_is_top_as_wall,\n   // STBVOX_GEOM_ceil_slope_north_is_bottom_as_wall,\n}\n\nstatic void stbvox_make_mesh_for_column(stbvox_mesh_maker *mm, int x, int y, int z0)\n{\n   stbvox_pos pos;\n   int v_off = x * mm->x_stride_in_bytes + y * mm->y_stride_in_bytes;\n   int ns_off = mm->y_stride_in_bytes;\n   int ew_off = mm->x_stride_in_bytes;\n   pos.x = x;\n   pos.y = y;\n   pos.z = 0;\n   if (mm->input.geometry) {\n      unsigned char *bt  = mm->input.blocktype + v_off;\n      unsigned char *geo = mm->input.geometry + v_off;\n      int z;\n      for (z=z0; z < mm->z1; ++z) {\n         if (bt[z] && ( !bt[z+ns_off] || !STBVOX_GET_GEO(geo[z+ns_off]) || !bt[z-ns_off] || !STBVOX_GET_GEO(geo[z-ns_off])\n                      || !bt[z+ew_off] || !STBVOX_GET_GEO(geo[z+ew_off]) || !bt[z-ew_off] || !STBVOX_GET_GEO(geo[z-ew_off])\n                      || !bt[z-1] || !STBVOX_GET_GEO(geo[z-1]) || !bt[z+1] || !STBVOX_GET_GEO(geo[z+1])))\n         {  // TODO check up and down\n            pos.z = z;\n            stbvox_make_mesh_for_block_with_geo(mm, pos, v_off+z);\n            if (mm->full) {\n               mm->cur_z = z;\n               return;\n            }\n         }\n      }\n   } else if (mm->input.block_geometry) {\n      int z;\n      unsigned char *bt  = mm->input.blocktype + v_off;\n      unsigned char *geo = mm->input.block_geometry;\n      for (z=z0; z < mm->z1; ++z) {\n         if (bt[z] && (    geo[bt[z+ns_off]] != STBVOX_GEOM_solid\n                        || geo[bt[z-ns_off]] != STBVOX_GEOM_solid\n                        || geo[bt[z+ew_off]] != STBVOX_GEOM_solid\n                        || geo[bt[z-ew_off]] != STBVOX_GEOM_solid\n                        || geo[bt[z-1]] != STBVOX_GEOM_solid\n                        || geo[bt[z+1]] != STBVOX_GEOM_solid))\n         {\n            pos.z = z;\n            stbvox_make_mesh_for_block_with_geo(mm, pos, v_off+z);\n            if (mm->full) {\n               mm->cur_z = z;\n               return;\n            }\n         }\n      }\n   } else {\n      unsigned char *bt = mm->input.blocktype + v_off;\n      int z;\n      #if STBVOX_CONFIG_PRECISION_Z == 1\n      stbvox_mesh_vertex *vmesh = stbvox_vmesh_delta_half_z[0];\n      #else\n      stbvox_mesh_vertex *vmesh = stbvox_vmesh_delta_normal[0];\n      #endif\n      for (z=z0; z < mm->z1; ++z) {\n         // if it's solid and at least one neighbor isn't solid\n         if (bt[z] && (!bt[z+ns_off] || !bt[z-ns_off] || !bt[z+ew_off] || !bt[z-ew_off] || !bt[z-1] || !bt[z+1])) {\n            pos.z = z;\n            stbvox_make_mesh_for_block(mm, pos, v_off+z, vmesh);\n            if (mm->full) {\n               mm->cur_z = z;\n               return;\n            }\n         }\n      }\n   }\n}\n\nstatic void stbvox_bring_up_to_date(stbvox_mesh_maker *mm)\n{\n   if (mm->config_dirty) {\n      int i;\n      #ifdef STBVOX_ICONFIG_FACE_ATTRIBUTE\n         mm->num_mesh_slots = 1;\n         for (i=0; i < STBVOX_MAX_MESHES; ++i) {\n            mm->output_size[i][0] = 32;\n            mm->output_step[i][0] = 8;\n         }\n      #else\n         mm->num_mesh_slots = 2;\n         for (i=0; i < STBVOX_MAX_MESHES; ++i) {\n            mm->output_size[i][0] = 16;\n            mm->output_step[i][0] = 4;\n            mm->output_size[i][1] = 4;\n            mm->output_step[i][1] = 4;\n         }\n      #endif\n\n      mm->config_dirty = 0;\n   }\n}\n\nint stbvox_make_mesh(stbvox_mesh_maker *mm)\n{\n   int x,y;\n   stbvox_bring_up_to_date(mm);\n   mm->full = 0;\n   if (mm->cur_x > mm->x0 || mm->cur_y > mm->y0 || mm->cur_z > mm->z0) {\n      stbvox_make_mesh_for_column(mm, mm->cur_x, mm->cur_y, mm->cur_z);\n      if (mm->full)\n         return 0;\n      ++mm->cur_y;\n      while (mm->cur_y < mm->y1 && !mm->full) {\n         stbvox_make_mesh_for_column(mm, mm->cur_x, mm->cur_y, mm->z0);\n         if (mm->full)\n            return 0;\n         ++mm->cur_y;\n      }\n      ++mm->cur_x;\n   }\n   for (x=mm->cur_x; x < mm->x1; ++x) {\n      for (y=mm->y0; y < mm->y1; ++y) {\n         stbvox_make_mesh_for_column(mm, x, y, mm->z0);\n         if (mm->full) {\n            mm->cur_x = x;\n            mm->cur_y = y;\n            return 0;\n         }\n      }\n   }\n   return 1;\n}\n\nvoid stbvox_init_mesh_maker(stbvox_mesh_maker *mm)\n{\n   memset(mm, 0, sizeof(*mm));\n   stbvox_build_default_palette();\n\n   mm->config_dirty = 1;\n   mm->default_mesh = 0;\n}\n\nint stbvox_get_buffer_count(stbvox_mesh_maker *mm)\n{\n   stbvox_bring_up_to_date(mm);\n   return mm->num_mesh_slots;\n}\n\nint stbvox_get_buffer_size_per_quad(stbvox_mesh_maker *mm, int n)\n{\n   return mm->output_size[0][n];\n}\n\nvoid stbvox_reset_buffers(stbvox_mesh_maker *mm)\n{\n   int i;\n   for (i=0; i < STBVOX_MAX_MESHES*STBVOX_MAX_MESH_SLOTS; ++i) {\n      mm->output_cur[0][i] = 0;\n      mm->output_buffer[0][i] = 0;\n   }\n}\n\nvoid stbvox_set_buffer(stbvox_mesh_maker *mm, int mesh, int slot, void *buffer, size_t len)\n{\n   int i;\n   stbvox_bring_up_to_date(mm);\n   mm->output_buffer[mesh][slot] = (char *) buffer;\n   mm->output_cur   [mesh][slot] = (char *) buffer;\n   mm->output_len   [mesh][slot] = (int) len;\n   mm->output_end   [mesh][slot] = (char *) buffer + len;\n   for (i=0; i < STBVOX_MAX_MESH_SLOTS; ++i) {\n      if (mm->output_buffer[mesh][i]) {\n         assert(mm->output_len[mesh][i] / mm->output_size[mesh][i] == mm->output_len[mesh][slot] / mm->output_size[mesh][slot]);\n      }\n   }\n}\n\nvoid stbvox_set_default_mesh(stbvox_mesh_maker *mm, int mesh)\n{\n   mm->default_mesh = mesh;\n}\n\nint stbvox_get_quad_count(stbvox_mesh_maker *mm, int mesh)\n{\n   return (int) ((mm->output_cur[mesh][0] - mm->output_buffer[mesh][0]) / mm->output_size[mesh][0]);\n}\n\nstbvox_input_description *stbvox_get_input_description(stbvox_mesh_maker *mm)\n{\n   return &mm->input;\n}\n\nvoid stbvox_set_input_range(stbvox_mesh_maker *mm, int x0, int y0, int z0, int x1, int y1, int z1)\n{\n   mm->x0 = x0;\n   mm->y0 = y0;\n   mm->z0 = z0;\n\n   mm->x1 = x1;\n   mm->y1 = y1;\n   mm->z1 = z1;\n\n   mm->cur_x = x0;\n   mm->cur_y = y0;\n   mm->cur_z = z0;\n\n   // @TODO validate that this range is representable in this mode\n}\n\nvoid stbvox_get_transform(stbvox_mesh_maker *mm, float transform[3][3])\n{\n   // scale\n   transform[0][0] = 1.0;\n   transform[0][1] = 1.0;\n   #if STBVOX_CONFIG_PRECISION_Z==1\n   transform[0][2] = 0.5f;\n   #else\n   transform[0][2] = 1.0f;\n   #endif\n   // translation\n   transform[1][0] = (float) (mm->pos_x);\n   transform[1][1] = (float) (mm->pos_y);\n   transform[1][2] = (float) (mm->pos_z);\n   // texture coordinate projection translation\n   transform[2][0] = (float) (mm->pos_x & 255); // @TODO depends on max texture scale\n   transform[2][1] = (float) (mm->pos_y & 255);\n   transform[2][2] = (float) (mm->pos_z & 255);\n}\n\nvoid stbvox_get_bounds(stbvox_mesh_maker *mm, float bounds[2][3])\n{\n   bounds[0][0] = (float) (mm->pos_x + mm->x0);\n   bounds[0][1] = (float) (mm->pos_y + mm->y0);\n   bounds[0][2] = (float) (mm->pos_z + mm->z0);\n   bounds[1][0] = (float) (mm->pos_x + mm->x1);\n   bounds[1][1] = (float) (mm->pos_y + mm->y1);\n   bounds[1][2] = (float) (mm->pos_z + mm->z1);\n}\n\nvoid stbvox_set_mesh_coordinates(stbvox_mesh_maker *mm, int x, int y, int z)\n{\n   mm->pos_x = x;\n   mm->pos_y = y;\n   mm->pos_z = z;\n}\n\nvoid stbvox_set_input_stride(stbvox_mesh_maker *mm, int x_stride_in_bytes, int y_stride_in_bytes)\n{\n   int f,v;\n   mm->x_stride_in_bytes = x_stride_in_bytes;\n   mm->y_stride_in_bytes = y_stride_in_bytes;\n   for (f=0; f < 6; ++f) {\n      for (v=0; v < 4; ++v) {\n         mm->cube_vertex_offset[f][v]   =   stbvox_vertex_vector[f][v][0]    * mm->x_stride_in_bytes\n                                         +  stbvox_vertex_vector[f][v][1]    * mm->y_stride_in_bytes\n                                         +  stbvox_vertex_vector[f][v][2]                           ;\n         mm->vertex_gather_offset[f][v] =  (stbvox_vertex_vector[f][v][0]-1) * mm->x_stride_in_bytes\n                                         + (stbvox_vertex_vector[f][v][1]-1) * mm->y_stride_in_bytes\n                                         + (stbvox_vertex_vector[f][v][2]-1)                        ;\n      }\n   }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n//    offline computation of tables\n//\n\n#if 0\n// compute optimized vheight table\nstatic char *normal_names[32] =\n{\n   0,0,0,0,\"u   \",0, \"eu  \",0,\n   0,0,0,0,\"ne_u\",0, \"nu  \",0,\n   0,0,0,0,\"nw_u\",0, \"wu  \",0,\n   0,0,0,0,\"sw_u\",0, \"su  \",0,\n};\n\nstatic char *find_best_normal(float x, float y, float z)\n{\n   int best_slot = 4;\n   float best_dot = 0;\n   int i;\n   for (i=0; i < 32; ++i) {\n      if (normal_names[i]) {\n         float dot = x * stbvox_default_normals[i][0] + y * stbvox_default_normals[i][1] + z * stbvox_default_normals[i][2];\n         if (dot > best_dot) {\n            best_dot = dot;\n            best_slot = i;\n         }\n      }\n   }\n   return normal_names[best_slot];\n}\n\nint main(int argc, char **argv)\n{\n   int sw,se,nw,ne;\n   for (ne=0; ne < 4; ++ne) {\n      for (nw=0; nw < 4; ++nw) {\n         for (se=0; se < 4; ++se) {\n            printf(\"        { \");\n            for (sw=0; sw < 4; ++sw) {\n               float x = (float) (nw + sw - ne - se);\n               float y = (float) (sw + se - nw - ne);\n               float z = 2;\n               printf(\"STBVF_%s, \", find_best_normal(x,y,z));\n            }\n            printf(\"},\\n\");\n         }\n      }\n   }\n   return 0;\n}\n#endif\n\n// @TODO\n//\n//   - test API for texture rotation on side faces\n//   - API for texture rotation on top & bottom\n//   - better culling of vheight faces with vheight neighbors\n//   - better culling of non-vheight faces with vheight neighbors\n//   - gather vertex lighting from slopes correctly\n//   - better support texture edge_clamp: currently if you fall\n//     exactly on 1.0 you get wrapped incorrectly; this is rare, but\n//     can avoid: compute texcoords in vertex shader, offset towards\n//     center before modding, need 2 bits per vertex to know offset direction)\n//   - other mesh modes (10,6,4-byte quads)\n//\n//\n// With TexBuffer for the fixed vertex data, we can actually do\n// minecrafty non-blocks like stairs -- we still probably only\n// want 256 or so, so we can't do the equivalent of all the vheight\n// combos, but that's ok. The 256 includes baked rotations, but only\n// some of them need it, and lots of block types share some faces.\n//\n// mode 5 (6 bytes):   mode 6 (6 bytes)\n//   x:7                x:6\n//   y:7                y:6\n//   z:6                z:6\n//   tex1:8             tex1:8\n//   tex2:8             tex2:7\n//   color:8            color:8\n//   face:4             face:7\n//\n//\n//  side faces (all x4)        top&bottom faces (2x)    internal faces (1x)\n//     1  regular                1 regular\n//     2  slabs                                             2\n//     8  stairs                 4 stairs                  16\n//     4  diag side                                         8\n//     4  upper diag side                                   8\n//     4  lower diag side                                   8\n//                                                          4 crossed pairs\n//\n//    23*4                   +   5*4                    +  46\n//  == 92 + 20 + 46 = 158\n//\n//   Must drop 30 of them to fit in 7 bits:\n//       ceiling half diagonals: 16+8 = 24\n//   Need to get rid of 6 more.\n//       ceiling diagonals: 8+4 = 12\n//   This brings it to 122, so can add a crossed-pair variant.\n//       (diagonal and non-diagonal, or randomly offset)\n//   Or carpet, which would be 5 more.\n//\n//\n// Mode 4 (10 bytes):\n//  v:  z:2,light:6\n//  f:  x:6,y:6,z:7, t1:8,t2:8,c:8,f:5\n//\n// Mode ? (10 bytes)\n//  v:  xyz:5 (27 values), light:3\n//  f:  x:7,y:7,z:6, t1:8,t2:8,c:8,f:4\n// (v:  x:2,y:2,z:2,light:2)\n\n#endif // STB_VOXEL_RENDER_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}