{
  "metadata": {
    "timestamp": 1736710474239,
    "page": 5,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tmux/tmux",
      "stars": 36068,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.203125,
          "content": "*.o\n*~\n*.diff\n*.patch\n*.core\ncore\ntags\n.deps/\ncompat/.dirstamp\naclocal.m4\nautom4te.cache/\nconfig.log\nconfig.status\netc/\ntmux\nMakefile\nMakefile.in\nconfigure\ntmux.1.*\n*.dSYM\ncmd-parse.c\nfuzz/*-fuzzer\n.dirstamp\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 1.9638671875,
          "content": "Bob Beck\t\t<beck@openbsd.org> beck <beck>\nClaudio Jeker\t\t<claudio@openbsd.org> claudio <claudio>\nIgor Sobrado\t\t<sobrado@openbsd.org> sobrado <sobrado>\nIngo Schwarze\t\t<schwarze@openbsd.org> schwarze <schwarze>\nJacek Masiulaniec\t<jacekm@openbsd.org> jacekm <jacekm>\nJason McIntyre\t\t<jmc@openbsd.org> jmc <jmc>\nJoel Sing\t\t<jsing@openbsd.org> jsing <jsing>\nJonathan Gray\t\t<jsg@openbsd.org> jsg <jsg>\nKenneth R Westerback\t<krw@openbsd.org> krw <krw>\nMarc Espie\t\t<espie@openbsd.org> espie <espie>\nMatthew Dempsky\t\t<matthew@openbsd.org> matthew <matthew>\nMatthias Kilian\t\t<kili@openbsd.org> kili <kili>\nMatthieu Herrb\t\t<matthieu@openbsd.org> matthieu <matthieu>\nMichael McConville\t<mmcc@openbsd.org> mmcc <mmcc>\nMiod Vallat\t\t<miod@openbsd.org> miod <miod>\nNicholas Marriott\t<nicholas.marriott@gmail.com> Nicholas Marriott <nicm@openbsd.org>\nNicholas Marriott\t<nicholas.marriott@gmail.com> nicm <nicm>\nNicholas Marriott\t<nicholas.marriott@gmail.com> no_author <no_author@example.org>\nOkan Demirmen\t\t<okan@openbsd.org> okan <okan>\nPhilip Guenther\t\t<guenther@openbsd.org> guenther <guenther>\nPierre-Yves Ritschard\t<pyr@openbsd.org> pyr <pyr>\nRay Lai\t\t\t<ray@openbsd.org> ray <ray>\nRyan McBride\t\t<mcbride@openbsd.org> mcbride <mcbride>\nSebastian Benoit\t<benno@openbsd.org> benno <benno>\nSebastien Marie\t\t<semarie@openbsd.org> semarie <semarie>\nStefan Sperling\t\t<stsp@openbsd.org> stsp <stsp>\nStuart Henderson\t<sthen@openbsd.org> sthen <sthen>\nTed Unangst\t\t<tedu@openbsd.org> tedu <tedu>\nTheo de Raadt\t\t<deraadt@openbsd.org> Theo Deraadt <deraadt@openbsd.org>\nTheo de Raadt\t\t<deraadt@openbsd.org> deraadt <deraadt>\nThomas Adam\t\t<thomas@xteddy.org> Thomas <thomas@xteddy.org>\nThomas Adam\t\t<thomas@xteddy.org> Thomas Adam <thomas.adam@smoothwall.net>\nThomas Adam\t\t<thomas@xteddy.org> n6tadam <n6tadam@xteddy.org>\nTim van der Molen\t<tim@openbsd.org> tim <tim>\nTobias Stoeckmann\t<tobias@openbsd.org> tobias <tobias>\nTodd C Miller\t\t<millert@openbsd.org> millert <millert>\nWilliam Yodlowsky\t<william@openbsd.org> william <william>\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.4892578125,
          "content": "language: c\n\nos:\n  - linux\n  - freebsd\n  - osx\n\ncompiler:\n  - gcc\n  - clang\n\narch:\n  - amd64\n  - arm64\n\nenv:\n  - BUILD=\n  - BUILD=static\n  - BUILD=all\n  - BUILD=musl\n  - BUILD=musl-static\n\njobs:\n  exclude:\n    # Static builds are broken on OS X (by Apple)\n    - os: osx\n      compiler: gcc\n      env: BUILD=static\n    - os: osx\n      compiler: clang\n      env: BUILD=static\n    # No musl on FreeBSD\n    - os: freebsd\n      compiler: gcc\n      env: BUILD=musl\n    - os: freebsd\n      compiler: clang\n      env: BUILD=musl\n    - os: freebsd\n      compiler: gcc\n      env: BUILD=musl-static\n    - os: freebsd\n      compiler: clang\n      env: BUILD=musl-static\n    # No musl on OS X\n    - os: osx\n      compiler: gcc\n      env: BUILD=musl\n    - os: osx\n      compiler: clang\n      env: BUILD=musl\n    - os: osx\n      compiler: gcc\n      env: BUILD=musl-static\n    - os: osx\n      compiler: clang\n      env: BUILD=musl-static\n    # arm64 doesn't link ncurses\n    - os: linux\n      compiler: gcc\n      arch: arm64\n      env: BUILD=all\n    - os: linux\n      compiler: clang\n      arch: arm64\n      env: BUILD=all\n    - os: linux\n      compiler: gcc\n      arch: arm64\n      env: BUILD=musl\n    - os: linux\n      compiler: clang\n      arch: arm64\n      env: BUILD=musl\n    - os: linux\n      compiler: gcc\n      arch: arm64\n      env: BUILD=musl-static\n    - os: linux\n      compiler: clang\n      arch: arm64\n      env: BUILD=musl-static\n\nbefore_install:\n  - sh .github/travis/before-install.sh\n\nscript:\n  - sh .github/travis/build.sh\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 143.1181640625,
          "content": "CHANGES FROM 3.4 TO 3.5\n\n* Revamp extended keys support to more closely match xterm and support mode 2\n  as well as mode 1. This is a substantial change to key handling which changes\n  tmux to always request mode 2 from parent terminal, changes to an unambiguous\n  internal representation of keys, and adds an option (extended-keys-format) to\n  control the format similar to the xterm(1) formatOtherKeys resource.\n\n* Clear an overlay (popup or menu) when command prompt is entered.\n\n* Add copy-mode -d flag to scroll a page down if in copy mode already (matching\n  -e).\n\n* Display hyperlinks in copy mode and add copy_cursor_hyperlink format to get\n  the hyperlink under the cursor.\n\n* Add a prefix timeout option.\n\n* Mouse move keys are not useful as key bindings because we do not turn them on\n  unless the application requests them. Ignore them so they do not cause the\n  prefix to be canceled\n\n* Add search_count and search_count_partial formats in copy mode.\n\n* Do not reset mouse pane if clicked on status line,\n\n* Add mirrored versions of the main-horizontal and main-vertical layouts where\n  the main pane is bottom or right instead of top or left.\n\n* Allow REP to work with Unicode characters.\n\n* Fix size calculation of terminators for clipboard escape sequences.\n\n* Treat CRLF as LF in config files where it is easy to do so.\n\n* The Linux console has some bugs with bright colours, so add some workarounds\n  for it.\n\n* If built with systemd, remove some environment variables it uses.\n\n* Adjust the logic when deleting last buffer to better preserve the selection:\n  if selecting the element below the deleted one fails (because as the last\n  one), select the one above it instead.\n\n* Add --enable-jemalloc to build with jemalloc memory allocator (since glibc\n  malloc is so poor).\n\n* Add a way (refresh-client -r) for control mode clients to provide OSC 10 and\n  11 responses to tmux so they can set the default foreground and background\n  colours.\n\n* Add N to search backwards in tree modes.\n\n* Use default-shell for command prompt, #() and popups.\n\n* Revert part of a change intended to improve search performance by skipping\n  parts of lines already searched, but which in fact skipped the ends of lines\n  altogether.\n\n* Add a command-error hook when a command fails.\n\n* Add an option allow-set-title to forbid applications from changing the pane\n  title.\n\n* Correct handling of mouse up events (don't ignore all but the last released\n  button), and always process down event for double click.\n\n* Fix a crash if focusing a pane that is exiting.\n\n* Pick newest session (as documented) when looking for next session for\n  detach-on-destroy.\n\n* Reduce default escape-time to 10 milliseconds.\n\n* Add display-menu -M to always turn mouse on in a menu.\n\n* Look for feature code 21 for DECSLRM and 28 for DECFRA in the device\n  attributes and also accept level 1.\n\n* Fix crash if built with SIXEL and the SIXEL colour register is invalid; also\n  remove SIXEL images before reflow.\n\n* Do not notify window-layout-changed if the window is about to be destroyed.\n\n* Do not consider a selection present if it is empty for the selection_active\n  and selection_present format variables.\n\n* Fix split-window -p.\n\nCHANGES FROM 3.3a TO 3.4\n\n* Add options keep-last and keep-group to destroy-unattached to keep the last\n  session whether in a group.\n\n* Don't allow paste-buffer into dead panes.\n\n* Add -t to source-file.\n\n* Rewrite combined character handling to be more consistent and to support\n  newer Unicode combined characters.\n\n* Add basic support for SIXEL if built with --enable-sixel.\n\n* Add a session, pane and user mouse range types for the status line and add\n  format variables for mouse_status_line and mouse_status_range so they can be\n  associated with different commands in the key bindings.\n\n* Add flag (-o) to next-prompt/previous-prompt to go to OSC 133 command output.\n\n* Add options and flags for menu styles (menu-style, menu-border-style) similar\n  to those existing for popups.\n\n* Add support for marking lines with a shell prompt based on the OSC 133 extension.\n\n* Check for libterminfo for NetBSD.\n\n* Add \"us\" to styles for underscore colour.\n\n* Add flags (-c and -y) to change the confirm key and default behaviour of\n  confirm-before.\n\n* Use ncurses' new tparm_s function (added in 6.4-20230424) instead of tparm so\n  it does not object to string arguments in c apabilities it doesn't already\n  know. Also ignore errors from tparm if using previous ncurses versions.\n\n* Set default lock command to vlock on Linux if present at build time.\n\n* Discard mouse sequences that have the right form but actually are invalid.\n\n* Add support for spawning panes in separate cgroups with systemd and a\n  configure flag (--disable-cgroups) to turn off.\n\n* Add a format (pane_unseen_changes) to show if there are unseen changes while\n  in a mode.\n\n* Remove old buffer when renaming rather than complaining.\n\n* Add an L modifier like P, W, S to loop over clients.\n\n* Add -f to list-clients like the other list commands.\n\n* Extend display-message to work for control clients.\n\n* Add a flag to display-menu to select the manu item selected when the menu is\n  open.\n\n* Have tmux recognise pasted text wrapped in bracket paste sequences, rather\n  than only forwarding them to the program inside.\n\n* Have client return 1 if process is interrupted to an input pane.\n\n* Query the client terminal for foreground and background colours and if OSC 10\n  or 11 is received but no colour has been set inside tmux, return the colour\n  from the first attached client.\n\n* Add send-keys -K to handle keys directly as if typed (so look up in key\n  table).\n\n* Process escape sequences in show-buffer.\n\n* Add a -l flag to display-message to disable format expansion.\n\n* Add paste-buffer-deleted notification and fix name of paste-buffer-changed.\n\n* Do not attempt to connect to the socket as a client if systemd is active.\n\n* Add scroll-top and scroll-bottom commands to scroll so cursor is at top or\n  bottom.\n\n* Add a -T flag to capture-pane to stop at the last used cell instead of the\n  full width. Restore the previous behaviour by making it default to off unless\n  -J is used.\n\n* Add message-line option to control where message and prompt go.\n\n* Notification when a paste buffer is deleted.\n\n* Add a Nobr terminfo(5) capability to tell tmux the terminal does not use bright\n  colours for bold.\n\n* Change g and G to go to top and bottom in menus.\n\n* Add a third state \"all\" to allow-passthrough to work even in invisible panes.\n\n* Add support for OSC 8 hyperlinks.\n\n* Store the time lines are scrolled into history and display in copy mode.\n\n* Add a %config-error reply to control mode for configuration file errors since\n  reporting them in view mode is useless.\n\n* A new feature flag (ignorefkeys) to ignore terminfo(5) function key\n  definitions for rxvt.\n\n* Pass through first argument to OSC 52 (which clipboards to set) if the\n  application provides it.\n\n* Expand arguments to send-keys, capture-pane, split-window, join-pane where it\n  makes sense to do so.\n\n* Ignore named buffers when choosing a buffer if one is not specified by the user.\n\nCHANGES FROM 3.3 TO 3.3a\n\n* Do not crash when run-shell produces output from a config file.\n\n* Do not unintentionally turn off all mouse mode when button mode is also\n  present.\n\nCHANGES FROM 3.2a TO 3.3\n\n* Add an ACL list for users connecting to the tmux socket. Users may be\n  forbidden from attaching, forced to attach read-only, or allowed to attach\n  read-write. A new command, server-access, configures the list. File system\n  permissions must still be configured manually.\n\n* Emit window-layout-changed on swap-pane.\n\n* Better error reporting when applying custom layouts.\n\n* Handle ANSI escape sequences in run-shell output.\n\n* Add pane_start_path to match start_command.\n\n* Set PWD so shells have a hint about the real path.\n\n* Do not allow pipe-pane on dead panes.\n\n* Do not report mouse positions (incorrectly) above the maximum of 223 in\n  normal mouse mode.\n\n* Add an option (default off) to control the passthrough escape sequence.\n\n* Support more mouse buttons when the terminal sends them.\n\n* Add a window-resized hook which is fired when the window is actually resized\n  which may be later than the client resize.\n\n* Add next_session_id format with the next session ID.\n\n* Add formats for client and server UID and user.\n\n* Add argument to refresh-client -l to forward clipboard to a pane.\n\n* Add remain-on-exit-format to set text shown when pane is dead.\n\n* With split-window -f use percentages of window size not pane size.\n\n* Add an option (fill-character) to set the character used for unused areas of\n  a client.\n\n* Add an option (scroll-on-clear) to control if tmux scrolls into history on\n  clear.\n\n* Add a capability for OSC 7 and use it similarly to how the title is set (and\n  controlled by the same set-titles option).\n\n* Add support for systemd socket activation (where systemd creates the Unix\n  domain socket for tmux rather than tmux creating it). Build with\n  --enable-systemd.\n\n* Add an option (pane-border-indicators) to select how the active pane is shown\n  on the pane border (colour, arrows or both).\n\n* Support underscore styles with capture-pane -e.\n\n* Make pane-border-format a pane option rather than window.\n\n* Respond to OSC 4 queries\n\n* Fix g/G keys in modes to do the same thing as copy mode (and vi).\n\n* Bump the time terminals have to respond to device attributes queries to three\n  seconds.\n\n* If automatic-rename is off, allow the rename escape sequence to set an empty\n  name.\n\n* Trim menu item text more intelligently.\n\n* Add cursor-style and cursor-colour options to set the default cursor style\n  and colour.\n\n* Accept some useful and non-conflicting emacs keys in vi normal mode at the\n  command prompt.\n\n* Add a format modifier (c) to force a colour to RGB.\n\n* Add -s and -S to display-popup to set styles, -b to set lines and -T to set\n  popup title. New popup-border-lines, popup-border-style and popup-style\n  options set the defaults.\n\n* Add -e flag to set an environment variable for a popup.\n\n* Make send-keys without arguments send the key it is bound to (if bound to a\n  key).\n\n* Try to leave terminal cursor at the right position even when tmux is drawing\n  its own cursor or selection (such as at the command prompt and in choose\n  mode) for people using screen readers and similar which can make use of it.\n\n* Change so that {} is converted to tmux commands immediately when parsed. This\n  means it must contain valid tmux commands. For commands which expand %% and\n  %%%, this now only happens within string arguments. Use of nested aliases\n  inside {} is now forbidden. Processing of commands given in quotes remains\n  the same.\n\n* Disable evports on SunOS since they are broken.\n\n* Do not expand the file given with tmux -f so it can contain :s.\n\n* Bump FORMAT_LOOP_LIMIT and add a log message when hit.\n\n* Add a terminal feature for the mouse (since FreeBSD termcap does not have kmous).\n\n* Forbid empty session names.\n\n* Improve error reporting when the tmux /tmp directory cannot be created or\n  used.\n\n* Give #() commands a one second grace period where the output is empty before\n  telling the user they aren't doing anything (\"not ready\").\n\n* When building, pick default-terminal from the first of tmux-256color, tmux,\n  screen-256color, screen that is available on the build system (--with-TERM\n  can override).\n\n* Do not close popups on resize, instead adjust them to fit.\n\n* Add a client-active hook.\n\n* Make window-linked and window-unlinked window options.\n\n* Do not configure on macOS without the user making a choice about utf8proc\n  (either --enable-utf8proc or --disable-utf8proc).\n\n* Do not freeze output in panes when a popup is open, let them continue to\n  redraw.\n\n* Add pipe variants of the line copy commands.\n\n* Change copy-line and copy-end-of-line not to cancel and add -and-cancel\n  variants, like the other copy commands.\n\n* Support the OSC palette-setting sequences in popups.\n\n* Add a pane-colours array option to specify the defaults palette.\n\n* Add support for Unicode zero-width joiner.\n\n* Make newline a style delimiter as well so they can cross multiple lines for\n  readability in configuration files.\n\n* Change focus to be driven by events rather than scanning panes so the\n  ordering of in and out is consistent.\n\n* Add display-popup -B to open a popup without a border.\n\n* Add a menu for popups that can be opened with button three outside the popup\n  or on the left or top border. Resizing now only works on the right and bottom\n  borders or when using Meta. The menu allows a popup to be closed, expanded to\n  the full size of the client, centered in the client or changed into a pane.\n\n* Make command-prompt and confirm-before block by default (like run-shell). A\n  new -b flags runs them in the background as before. Also set return code for\n  confirm-before.\n\n* Change cursor style handling so tmux understands which sequences contain\n  blinking and sets the flag appropriately, means that it works whether cnorm\n  disables blinking or not. This now matches xterm's behaviour.\n\n* More accurate vi(1) word navigation in copy mode and on the status line. This\n  changes the meaning of the word-separators option: setting it to the empty\n  string is equivalent to the previous behavior.\n\n* Add -F for command-prompt and use it to fix \"Rename\" on the window menu.\n\n* Add different command histories for different types of prompts (\"command\",\n  \"search\" etc).\n\nCHANGES FROM 3.2 TO 3.2a\n\n* Add an \"always\" value for the \"extended-keys\" option; if set then tmux will\n  forward extended keys to applications even if they do not request them.\n\n* Add a \"mouse\" terminal feature so tmux can enable the mouse on terminals\n  where it is known to be supported even if terminfo(5) says otherwise.\n\n* Do not expand the filename given to -f so it can contain colons.\n\n* Fixes for problems with extended keys and modifiers, scroll region,\n  source-file, crosscompiling, format modifiers and other minor issues.\n\nCHANGES FROM 3.1c TO 3.2\n\n* Add a flag to disable keys to close a message.\n\n* Permit shortcut keys in buffer, client, tree modes to be configured with a\n  format (-K flag to choose-buffer, choose-client, choose-tree).\n\n* Add a current_file format for the config file being parsed.\n\n* When display-message used in config file, show the message after the config\n  file finishes.\n\n* Add client-detached notification in control mode.\n\n* Improve performance of format evaluation.\n\n* Make jump command support UTF-8 in copy mode.\n\n* Support X11 colour names and other colour formats for OSC 10 and 11.\n\n* Add \"pipe\" variants of \"copy-pipe\" commands which do not copy.\n\n* Include \"focused\" in client flags.\n\n* Send Unicode directional isolate characters around horizontal pane borders if\n  the terminal supports UTF-8 and an extension terminfo(5) capability \"Bidi\" is\n  present.\n\n* Add a -S flag to new-window to make it select the existing window if one\n  with the given name already exists rather than failing with an error.\n\n* Add a format modifier to check if a window or session name exists (N/w or\n  N/s).\n\n* Add compat clock_gettime for older macOS.\n\n* Add a no-detached choice to detach-on-destroy which detaches only if there\n  are no other detached sessions to switch to.\n\n* Add rectangle-on and rectangle-off copy mode commands.\n\n* Change so that window_flags escapes # automatically. A new format\n  window_raw_flags contains the old unescaped version.\n\n* Add -N flag to never start server even if command would normally do so.\n\n* With incremental search, start empty and only repeat the previous search if\n  the user tries to search again with an empty prompt.\n\n* Add a value for remain-on-exit that only keeps the pane if the program\n  failed.\n\n* Add a -C flag to run-shell to use a tmux command rather than a shell command.\n\n* Do not list user options with show-hooks.\n\n* Remove current match indicator in copy mode which can't work anymore since we\n  only search the visible region.\n\n* Make synchronize-panes a pane option and add -U flag to set-option to unset\n  an option on all panes.\n\n* Make replacement of ##s consistent when drawing formats, whether followed by\n  [ or not. Add a flag (e) to the q: format modifier to double up #s.\n\n* Add -N flag to display-panes to ignore keys.\n\n* Change how escaping is processed for formats so that ## and # can be used in\n  styles.\n\n* Add a 'w' format modifier for string width.\n\n* Add support for Haiku.\n\n* Expand menu and popup -x and -y as formats.\n\n* Add numeric comparisons for formats.\n\n* Fire focus events even when the pane is in a mode.\n\n* Add -O flag to display-menu to not automatically close when all mouse buttons\n  are released.\n\n* Allow fnmatch(3) wildcards in update-environment.\n\n* Disable nested job expansion so that the result of #() is not expanded again.\n\n* Use the setal capability as well as (tmux's) Setulc.\n\n* Add -q flag to unbind-key to hide errors.\n\n* Allow -N without a command to change or add a note to an existing key.\n\n* Add a -w flag to set- and load-buffer to send to clipboard using OSC 52.\n\n* Add -F to set-environment and source-file.\n\n* Allow colour to be spelt as color in various places.\n\n* Add n: modifier to get length of a format.\n\n* Respond to OSC colour requests if a colour is available.\n\n* Add a -d option to display-message to set delay.\n\n* Add a way for control mode clients to subscribe to a format and be notified\n  of changes rather than having to poll.\n\n* Add some formats for search in copy mode (search_present, search_match).\n\n* Do not wait on shutdown for commands started with run -b.\n\n* Add -b flags to insert a window before (like the existing -a for after) to\n  break-pane, move-window, new-window.\n\n* Make paste -p the default for ].\n\n* Add support for pausing a pane when the output buffered for a control mode\n  client gets too far behind. The pause-after flag with a time is set on the\n  pane with refresh-client -f and a paused pane may be resumed with\n  refresh-client -A.\n\n* Allow strings in configuration files to span multiple lines - newlines and\n  any leading whitespace are removed, as well as any following comments that\n  couldn't be part of a format. This allows long formats or other strings to be\n  annotated and indented.\n\n* Instead of using a custom parse function to process {} in configuration\n  files, treat as a set of statements the same as outside {} and convert back\n  to a string as the last step. This means the rules are consistent inside and\n  outside {}, %if and friends work at the right time, and the final result\n  isn't littered with unnecessary newlines.\n\n* Add support for extended keys - both xterm(1)'s CSI 27 ~ sequence and the\n  libtickit CSI u sequence are accepted; only the latter is output. tmux will\n  only attempt to use these if the extended-keys option is on and it can detect\n  that the terminal outside supports them (or is told it does with the\n  \"extkeys\" terminal feature).\n\n* Add an option to set the pane border lines style from a choice of single\n  lines (ACS or UTF-8), double or heavy (UTF-8), simple (plain ASCII) or number\n  (the pane numbers). Lines that won't work on a non-UTF-8 terminal are\n  translated back into ACS when they are output.\n\n* Make focus events update the latest client (like a key press).\n\n* Store UTF-8 characters differently to reduce memory use.\n\n* Fix break-pane -n when only one pane in the window.\n\n* Instead of sending all data to control mode clients as fast as possible, add\n  a limit of how much data will be sent to the client and try to use it for\n  panes with some degree of fairness.\n\n* Add an active-pane client flag (set with attach-session -f, new-session -f\n  or refresh-client -f). This allows a client to have an independent active\n  pane for interactive use (the window client pane is still used for many\n  things however).\n\n* Add a mark to copy mode, this is set with the set-mark command (bound to X)\n  and appears with the entire line shown using copy-mode-mark-style and the\n  marked character in reverse. The jump-to-mark command (bound to M-x) swaps\n  the mark and the cursor positions.\n\n* Add a -D flag to make the tmux server run in the foreground and not as a\n  daemon.\n\n* Do not loop forever in copy mode when search finds an empty match.\n\n* Fix the next-matching-bracket logic when using vi(1) keys.\n\n* Add a customize mode where options may be browsed and changed, includes\n  adding a brief description of each option. Bound to C-b C by default.\n\n* Change message log (C-b ~) so there is one for the server rather than one per\n  client and it remains after detach, and make it useful by logging every\n  command.\n\n* Add M-+ and M-- to tree mode to expand and collapse all.\n\n* Change the existing client flags for control mode to apply for any client,\n  use the same mechanism for the read-only flag and add an ignore-size flag.\n\n  refresh-client -F has become -f (-F stays for backwards compatibility) and\n  attach-session and switch-client now have -f flags also. A new format\n  client_flags lists the flags and is shown by list-clients by default.\n\n  This separates the read-only flag from \"ignore size\" behaviour (new\n  ignore-size) flag - both behaviours are useful in different circumstances.\n\n  attach -r and switchc -r remain and set or toggle both flags together.\n\n* Store and restore cursor position when copy mode is resized.\n\n* Export TERM_PROGRAM and TERM_PROGRAM_VERSION like various other terminals.\n\n* Add formats for after hook command arguments: hook_arguments with all the\n  arguments together; hook_argument_0, hook_argument_1 and so on with\n  individual arguments; hook_flag_X if flag -X is present; hook_flag_X_0,\n  hook_flag_X_1 and so on if -X appears multiple times.\n\n* Try to search the entire history first for up to 200 ms so a search count can\n  be shown. If it takes too long, search the visible text only.\n\n* Use VIS_CSTYLE for paste buffers also (show \\012 as \\n).\n\n* Change default formats for tree mode, client mode and buffer mode to be more\n  compact and remove some clutter.\n\n* Add a key (e) in buffer mode to open the buffer in an editor. The buffer\n  contents is updated when the editor exits.\n\n* Add -e flag for new-session to set environment variables, like the same flag\n  for new-window.\n\n* Improve search match marking in copy mode. Two new options\n  copy-mode-match-style and copy-mode-current-match-style to set the style for\n  matches and for the current match respectively. Also a change so that if a\n  copy key is pressed with no selection, the current match (if any) is copied.\n\n* Sanitize session names like window names instead of forbidding invalid ones.\n\n* Check if the clear terminfo(5) capability starts with CSI and if so then\n  assume the terminal is VT100-like, rather than relying on the XT capability.\n\n* Improve command prompt tab completion and add menus both for strings and -t\n  and -s (when used without a trailing space). command-prompt has additional\n  flags for only completing a window (-W) and a target (-T), allowing C-b ' to\n  only show windows and C-b . only targets.\n\n* Change all the style options to string options so they can support formats.\n  Change pane-active-border-style to use this to change the border colour when\n  in a mode or with synchronize-panes on. This also implies a few minor changes\n  to existing behaviour:\n\n  - set-option -a with a style option automatically inserts a comma between the\n    old value and appended text.\n\n  - OSC 10 and 11 no longer set the window-style option, instead they store the\n    colour internally in the pane data and it is used as the default when the\n    option is evaluated.\n\n  - status-fg and -bg now override status-style instead of the option values\n    being changed.\n\n* Add extension terminfo(5) capabilities for margins and focus reporting.\n\n* Try $XDG_CONFIG_HOME/tmux/tmux.conf as well as ~/.config/tmux/tmux.conf for\n  configuration file (the search paths are in TMUX_CONF in Makefile.am).\n\n* Remove the DSR 1337 iTerm2 extension and replace by the extended device\n  attributes sequence (CSI > q) supported by more terminals.\n\n* Add a -s flag to copy-mode to specify a different pane for the source\n  content. This means it is possible to view two places in a pane's history at\n  the same time in different panes, or view the history while still using the\n  pane. Pressing r refreshes the content from the source pane.\n\n* Add an argument to list-commands to show only a single command.\n\n* Change copy mode to make copy of the pane history so it does not need to\n  freeze the pane.\n\n* Restore pane_current_path format from portable tmux on OpenBSD.\n\n* Wait until the initial command sequence is done before sending a device\n  attributes request and other bits that prompt a reply from the terminal. This\n  means that stray replies are not left on the terminal if the command has\n  attached and then immediately detached and tmux will not be around to receive\n  them.\n\n* Add a -f filter argument to the list commands like choose-tree.\n\n* Move specific hooks for panes to pane options and windows for window options\n  rather than all hooks being session options. These hooks are now window options:\n\n  window-layout-changed\n  window-linked\n  window-pane-changed\n  window-renamed\n  window-unlinked\n\n  And these are now pane options:\n\n  pane-died\n  pane-exited\n  pane-focus-in\n  pane-focus-out\n  pane-mode-changed\n  pane-set-clipboard\n\n  Any existing configurations using these hooks on a session rather than\n  globally (that is, set-hook or set-option without -g) may need to be changed.\n\n* Show signal names when a process exits with remain-on-exit on platforms which\n  have a way to get them.\n\n* Start menu with top item selected if no mouse and use mode-style for the\n  selected item.\n\n* Add a copy-command option and change copy-pipe and friends to pipe to it if\n  used without arguments, allows all the default copy key bindings to be\n  changed to pipe with one option rather than needing to change each key\n  binding individually.\n\n* Tidy up the terminal detection and feature code and add named sets of\n  terminal features, each of which are defined in one place and map to a\n  builtin set of terminfo(5) capabilities. Features can be specified based on\n  TERM with a new terminal-features option or with the -T flag when running\n  tmux. tmux will also detect a few common terminals from the DA and DSR\n  responses.\n\n  This is intended to make it easier to configure tmux's use of terminfo(5)\n  even in the presence of outdated ncurses(3) or terminfo(5) databases or for\n  features which do not yet have a terminfo(5) entry. Instead of having to grok\n  terminfo(5) capability names and what they should be set to in the\n  terminal-overrides option, the user can hopefully just give tmux a feature\n  name and let it do the right thing.\n\n  The terminal-overrides option remains both for backwards compatibility and to\n  allow tweaks of individual capabilities.\n\n* Support mintty's application escape sequence (means tmux doesn't have to\n  delay to wait for Escape, so no need to reduce escape-time when using\n  mintty).\n\n* Change so main-pane-width and height can be given as a percentage.\n\n* Support for the iTerm2 synchronized updates feature (allows the terminal to\n  avoid unnecessary drawing while output is still in progress).\n\n* Make the mouse_word and mouse_line formats work in copy mode and enable the\n  default pane menu in copy mode.\n\n* Add a -T flag to resize-pane to trim lines below the cursor, moving lines out\n  of the history.\n\n* Add a way to mark environment variables as \"hidden\" so they can be used by\n  tmux (for example in formats) but are not set in the environment for new\n  panes. set-environment and show-environment have a new -h flag and there is a\n  new %hidden statement for the configuration file.\n\n* Change default position for display-menu -x and -y to centre rather than top\n  left.\n\n* Add support for per-client transient popups, similar to menus but which are\n  connected to an external command (like a pane). These are created with new\n  command display-popup.\n\n* Change double and triple click bindings so that only one is fired (previously\n  double click was fired on the way to triple click). Also add default double\n  and triple click bindings to copy the word or line under the cursor and\n  change the existing bindings in copy mode to do the same.\n\n* Add a default binding for button 2 to paste.\n\n* Add -d flag to run-shell to delay before running the command and allow it to\n  be used without a command so it just delays.\n\n* Add C-g to cancel command prompt with vi keys as well as emacs, and q in\n  command mode.\n\n* When the server socket is given with -S, create it with umask 177 instead of\n  117 (because it may not be in a safe directory like the default directory in\n  /tmp).\n\n* Add a copy-mode -H flag to hide the position marker in the top right.\n\n* Add number operators for formats (+, -, *, / and m),\n\nCHANGED FROM 3.1b TO 3.1c\n\n* Do not write after the end of the array and overwrite the stack when\n  colon-separated SGR sequences contain empty arguments.\n\nCHANGES FROM 3.1a TO 3.1b\n\n* Fix build on systems without sys/queue.h.\n\n* Fix crash when allow-rename is on and an empty name is set.\n\nCHANGES FROM 3.1 TO 3.1a\n\n* Do not close stdout prematurely in control mode since it is needed to print\n  exit messages. Prevents hanging when detaching with iTerm2.\n\nCHANGES FROM 3.0a TO 3.1\n\n* Only search the visible part of the history when marking (highlighting)\n  search terms. This is much faster than searching the whole history and solves\n  problems with large histories. The count of matches shown is now the visible\n  matches rather than all matches.\n\n* Search using regular expressions in copy mode. search-forward and\n  search-backward use regular expressions by default; the incremental versions\n  do not.\n\n* Turn off mouse mode 1003 as well as the rest when exiting.\n\n* Add selection_active format for when the selection is present but not moving\n  with the cursor.\n\n* Fix dragging with modifier keys, so binding keys such as C-MouseDrag1Pane and\n  C-MouseDragEnd1Pane now work.\n\n* Add -a to list-keys to also list keys without notes with -N.\n\n* Do not jump to next word end if already on a word end when selecting a word;\n  fixes select-word with single character words and vi(1) keys.\n\n* Fix top and bottom pane calculation with pane border status enabled.\n\n* Add support for adding a note to a key binding (with bind-key -N) and use\n  this to add descriptions to the default key bindings. A new -N flag to\n  list-keys shows key bindings with notes. Change the default ? binding to use\n  this to show a readable summary of keys. Also extend command-prompt to return\n  the name of the key pressed and add a default binding (/) to show the note\n  for the next key pressed.\n\n* Add support for the iTerm2 DSR 1337 sequence to get the terminal version.\n\n* Treat plausible but invalid keys (like C-BSpace) as literal like any other\n  unrecognised string passed to send-keys.\n\n* Detect iTerm2 and enable use of DECSLRM (much faster with horizontally split\n  windows).\n\n* Add -Z to default switch-client command in tree mode.\n\n* Add ~ to quoted characters for %%%.\n\n* Document client exit messages in the manual page.\n\n* Do not let read-only clients limit the size, unless all clients are\n  read-only.\n\n* Add a number of new formats to inspect what sessions and clients a window is\n  present or active in.\n\n* Change file reading and writing to go through the client if necessary. This\n  fixes commands like \"tmux loadb /dev/fd/X\". Also modify source-file to\n  support \"-\" for standard input, like load-buffer and save-buffer.\n\n* Add ~/.config/tmux/tmux.conf to the default search path for configuration\n  files.\n\n* Bump the escape sequence timeout to five seconds to allow for longer\n  legitimate sequences.\n\n* Make a best effort to set xpixel and ypixel for each pane and add formats for\n  them.\n\n* Add push-default to status-left and status-right in status-format[0].\n\n* Do not clear search marks on cursor movement with vi(1) keys.\n\n* Add p format modifier for padding to width and allow multiple substitutions\n  in a single format.\n\n* Add -f for full size to join-pane (like split-window).\n\n* Do not use bright when emulating 256 colours on an 8 colour terminal because\n  it is also bold on some terminals.\n\n* Make select-pane -P set window-active-style also to match previous behaviour.\n\n* Do not truncate list-keys output.\n\n* Turn automatic-rename back on if the \\033k rename escape sequence is used\n  with an empty name.\n\n* Add support for percentage sizes for resize-pane (\"-x 10%\"). Also change\n  split-window and join-pane -l to accept similar percentages and deprecate the\n  -p flag.\n\n* Add -F flag to send-keys to expand formats in search-backward and forward\n  copy mode commands and copy_cursor_word and copy_cursor_line formats for word\n  and line at cursor in copy mode. Use for default # and * binding with vi(1)\n  keys.\n\n* Add formats for word and line at cursor position in copy mode.\n\n* Add formats for cursor and selection position in copy mode.\n\n* Support all the forms of RGB colour strings in OSC sequences rather than\n  requiring two digits.\n\n* Limit lazy resize to panes in attached sessions only.\n\n* Add an option to set the key sent by backspace for those whose system uses ^H\n  rather than ^?.\n\n* Change new-session -A without a session name (that is, no -s option also) to\n  attach to the best existing session like attach-session rather than a new\n  one.\n\n* Add a \"latest\" window-size option which tries to size windows based on the\n  most recently used client. This is now the default.\n\n* Add simple support for OSC 7 (result is available in the pane_path format).\n\n* Add push-default and pop-default for styles which change the colours and\n  attributes used for #[default]. These are used in status-format to restore\n  the behaviour of window-status-style being the default for\n  window-status-format.\n\n* Add window_marked_flag.\n\n* Add cursor-down-and-cancel in copy mode.\n\n* Default to previous search string for search-forward and search-backward.\n\n* Add -Z flag to rotate-window, select-pane, swap-pane, switch-client to\n  preserve zoomed state.\n\n* Add -N to capture-pane to preserve trailing spaces.\n\n* Add reverse sorting in tree, client and buffer modes.\n\nCHANGES FROM 3.0 TO 3.0a\n\n* Do not require REG_STARTEND.\n\n* Respawn panes or windows correctly if default-command is set.\n\n* Add missing option for after-kill-pane hook.\n\n* Fix for crash with a format variable that doesn't exist.\n\n* Do not truncate list-keys output on some platforms.\n\n* Do not crash when restoring a layout with only one pane.\n\nCHANGES FROM 2.9 TO 3.0\n\n* Workaround invalid layout strings generated by older tmux versions and add\n  some additional sanity checks\n\n* xterm 348 now disables margins when resized, so send DECLRMM again after\n  resize.\n\n* Add support for the SD (scroll down) escape sequence.\n\n* Expand arguments to C and s format modifiers to match the m modifier.\n\n* Add support for underscore colours (Setulc capability must be added with\n  terminal-overrides as described in tmux(1)).\n\n* Add a \"fill\" style attribute for the fill colour of the drawing area (where\n  appropriate).\n\n* New -H flag to send-keys to send literal keys.\n\n* Format variables for pane mouse modes (mouse_utf8_flag and mouse_sgr_flag)\n  and for origin mode (origin_flag).\n\n* Add -F to refresh-client for flags for control mode clients, only one flag\n  (no-output) supported at the moment.\n\n* Add a few vi(1) keys for menus.\n\n* Add pane options, set with set-option -p and displayed with show-options -p.\n  Pane options inherit from window options (so every pane option is also\n  a window option). The pane style is now configured by setting window-style\n  and window-active-style in the pane options; select-pane -P and -g now change\n  the option but are no longer documented.\n\n* Do not document set-window-option and show-window-options. set-option -w and\n  show-options -w should be used instead.\n\n* Add a -A flag to show-options to show parent options as well (they are marked\n  with a *).\n\n* Resize panes lazily - do not resize unless they are in an attached, active\n  window.\n\n* Add regular expression support for the format search, match and substitute\n  modifiers and make them able to ignore case. find-window now accepts -r to\n  use regular expressions.\n\n* Do not use $TMUX to find the session because for windows in multiple sessions\n  it is wrong as often as it is right, and for windows in one session it is\n  pointless. Instead use TMUX_PANE if it is present.\n\n* Do not always resize the window back to its original size after applying a\n  layout, keep it at the layout size until it must be resized (for example when\n  attached and window-size is not manual).\n\n* Add new-session -X and attach-session -x to send SIGHUP to parent when\n  detaching (like detach-client -P).\n\n* Support for octal escapes in strings (such as \\007) and improve list-keys\n  output so it parses correctly if copied into a configuration file.\n\n* INCOMPATIBLE: Add a new {} syntax to the configuration file. This is a string\n  similar to single quotes but also includes newlines and allows commands that\n  take other commands as string arguments to be expressed more clearly and\n  without additional escaping.\n\n  A literal { and } or a string containing { or } must now be escaped or\n  quoted, for example '{' and '}' instead of { or }, or 'X#{foo}' instead of\n  X#{foo}.\n\n* New <, >, <= and >= comparison operators for formats.\n\n* Improve escaping of special characters in list-keys output.\n\n* INCOMPATIBLE: tmux's configuration parsing has changed to use yacc(1). There\n  is one incompatible change: a \\ on its own must be escaped or quoted as\n  either \\\\ or '\\' (the latter works on older tmux versions).\n\n  Entirely the same parser is now used for parsing the configuration file\n  and for string commands. This means that constructs previously only\n  available in .tmux.conf, such as %if, can now be used in string commands\n  (for example, those given to if-shell - not commands invoked from the\n  shell, they are still parsed by the shell itself).\n\n* Add support for the overline attribute (SGR 53). The Smol capability is\n  needed in terminal-overrides.\n\n* Add the ability to create simple menus. Introduces new command\n  display-menu. Default menus are bound to MouseDown3 on the status line;\n  MouseDown3 or M-MouseDown3 on panes; MouseDown3 in tree, client and\n  buffer modes; and C-b < and >.\n\n* Allow panes to be empty (no command). They can be created either by piping to\n  split-window -I, or by passing an empty command ('') to split-window. Output\n  can be sent to an existing empty window with display-message -I.\n\n* Add keys to jump between matching brackets (emacs C-M-f and C-M-b, vi %).\n\n* Add a -e flag to new-window, split-window, respawn-window, respawn-pane to\n  pass environment variables into the newly created process.\n\n* Hooks are now stored in the options tree as array options, allowing them to\n  have multiple separate commands. set-hook and show-hooks remain but\n  set-option and show-options can now also be used (show-options will only show\n  hooks if given the -H flag). Hooks with multiple commands are run in index\n  order.\n\n* Automatically scroll if dragging to create a selection with the mouse and the\n  cursor reaches the top or bottom line.\n\n* Add -no-clear variants of copy-selection and copy-pipe which do not clear the\n  selection after copying. Make copy-pipe clear the selection by default to be\n  consistent with copy-selection.\n\n* Add an argument to copy commands to set the prefix for the buffer name, this\n  (for example) allows buffers for different sessions to be named separately.\n\n* Update session activity on focus event.\n\n* Pass target from source-file into the config file parser so formats in %if\n  and %endif have access to more useful variables.\n\n* Add the ability to infer an option type (server, session, window) from its\n  name to show-options (it was already present in set-option).\n\nCHANGES FROM 2.9 TO 2.9a\n\n* Fix bugs in select-pane and the main-horizontal and main-vertical layouts.\n\nCHANGES FROM 2.8 TO 2.9\n\n* Attempt to preserve horizontal cursor position as well as vertical with\n  reflow.\n\n* Rewrite main-vertical and horizontal and change layouts to better handle the\n  case where all panes won't fit into the window size, reduce problems with\n  pane border status lines and fix other bugs mostly found by Thomas Sattler.\n\n* Add format variables for the default formats in the various modes\n  (tree_mode_format and so on) and add a -a flag to display-message to list\n  variables with values.\n\n* Add a -v flag to display-message to show verbose messages as the format is\n  parsed, this allows formats to be debugged\n\n* Add support for HPA (\\033[`).\n\n* Add support for origin mode (\\033[?6h).\n\n* No longer clear history on RIS.\n\n* Extend the #[] style syntax and use that together with previous format\n  changes to allow the status line to be entirely configured with a single\n  option.\n\n  Now that it is possible to configure their content, enable the existing code\n  that lets the status line be multiple lines in height. The status option can\n  now take a value of 2, 3, 4 or 5 (as well as the previous on or off) to\n  configure more than one line. The new status-format array option configures\n  the format of each line, the default just references the existing status-*\n  options, although some of the more obscure status options may be eliminated\n  in time.\n\n  Additions to the #[] syntax are: \"align\" to specify alignment (left, centre,\n  right), \"list\" for the window list and \"range\" to configure ranges of text\n  for the mouse bindings.\n\n  The \"align\" keyword can also be used to specify alignment of entries in tree\n  mode and the pane status lines.\n\n* Add E: and T: format modifiers to expand a format twice (useful to expand the\n  value of an option).\n\n* The individual -fg, -bg and -attr options have been removed; they\n  were superseded by -style options in tmux 1.9.\n\n* Allow more than one mode to be opened in a pane. Modes are kept on a stack\n  and retrieved if the same mode is entered again. Exiting the active mode goes\n  back to the previous one.\n\n* When showing command output in copy mode, call it view mode instead (affects\n  pane_mode format).\n\n* Add -b to display-panes like run-shell.\n\n* Handle UTF-8 in word-separators option.\n\n* New \"terminal\" colour allowing options to use the terminal default colour\n  rather than inheriting the default from a parent option.\n\n* Do not move the cursor in copy mode when the mouse wheel is used.\n\n* Use the same working directory rules for jobs as new windows rather than\n  always starting in the user's home.\n\n* Allow panes to be one line or column in size.\n\n* Go to last line when goto-line number is out of range in copy mode.\n\n* Yank previously cut text if any with C-y in the command prompt, only use the\n  buffer if no text has been cut.\n\n* Add q: format modifier to quote shell special characters.\n\n* Add StatusLeft and StatusRight mouse locations (keys such as\n  MouseDown1StatusLeft) for the status-left and status-right areas of the\n  status line.\n\n* Add -Z to find-window.\n\n* Support for windows larger than the client. This adds two new options,\n  window-size and default-size, and a new command, resize-window. The\n  force-width and force-height options and the session_width and session_height\n  formats have been removed.\n\n  The new window-size option tells tmux how to work out the size of windows:\n  largest means it picks the size of the largest session, smallest the smallest\n  session (similar to the old behaviour) and manual means that it does not\n  automatically resize windows. aggressive-resize modifies the choice of\n  session for largest and smallest as it did before.\n\n  If a window is in a session attached to a client that is too small, only part\n  of the window is shown. tmux attempts to keep the cursor visible, so the part\n  of the window displayed is changed as the cursor moves (with a small delay,\n  to try and avoid excess redrawing when applications redraw status lines or\n  similar that are not currently visible).\n\n  Drawing windows which are larger than the client is not as efficient as those\n  which fit, particularly when the cursor moves, so it is recommended to avoid\n  using this on slow machines or networks (set window-size to smallest or\n  manual).\n\n  The resize-window command can be used to resize a window manually. If it is\n  used, the window-size option is automatically set to manual for the window\n  (undo this with \"setw -u window-size\"). resize-window works in a similar way\n  to resize-pane (-U -D -L -R -x -y flags) but also has -a and -A flags. -a\n  sets the window to the size of the smallest client (what it would be if\n  window-size was smallest) and -A the largest.\n\n  For the same behaviour as force-width or force-height, use resize-window -x\n  or -y.\n\n  If the global window-size option is set to manual, the default-size option is\n  used for new windows. If -x or -y is used with new-session, that sets the\n  default-size option for the new session.\n\n  The maximum size of a window is 10000x10000. But expect applications to\n  complain and higher memory use if making a window that big. The minimum size\n  is the size required for the current layout including borders.\n\n  The refresh-client command can be used to pan around a window, -U -D -L -R\n  moves up, down, left or right and -c returns to automatic cursor\n  tracking. The position is reset when the current window is changed.\n\nCHANGES FROM 2.7 TO 2.8\n\n* Make display-panes block the client until a pane is chosen or it\n  times out.\n\n* Clear history on RIS like most other terminals do.\n\n* Add an \"Any\" key to run a command if a key is pressed that is not\n  bound in the current key table.\n\n* Expand formats in load-buffer and save-buffer.\n\n* Add a rectangle_toggle format.\n\n* Add set-hook -R to run a hook immediately.\n\n* Add README.ja.\n\n* Add pane focus hooks.\n\n* Allow any punctuation as separator for s/x/y not only /.\n\n* Improve resizing with the mouse (fix resizing the wrong pane in some\n  layouts, and allow resizing multiple panes at the same time).\n\n* Allow , and } to be escaped in formats as #, and #}.\n\n* Add KRB5CCNAME to update-environment.\n\n* Change meaning of -c to display-message so the client is used if it\n  matches the session given to -t.\n\n* Fixes to : form of SGR.\n\n* Add x and X to choose-tree to kill sessions, windows or panes.\n\nCHANGES FROM 2.6 TO 2.7\n\n* Remove EVENT_* variables from environment on platforms where tmux uses them\n  so they do not pass on to panes.\n\n* Fixes for hooks at server exit.\n\n* Remove SGR 10 (was equivalent to SGR 0 but no other terminal seems to do\n  this).\n\n* Expand formats in window and session names.\n\n* Add -Z flag to choose-tree, choose-client, choose-buffer to automatically\n  zoom the pane when the mode is entered and unzoom when it exits, assuming the\n  pane is not already zoomed. This is now part of the default key bindings.\n\n* Add C-g to exit modes with emacs keys.\n\n* Add exit-empty option to exit server if no sessions (defaults to on).\n\n* Show if a filter is present in choose modes.\n\n* Add pipe-pane -I to to connect stdin of the child process.\n\n* Performance improvements for reflow.\n\n* Use RGB terminfo(5) capability to detect RGB colour terminals (the existing\n  Tc extension remains unchanged).\n\n* Support for ISO colon-separated SGR sequences.\n\n* Add select-layout -E to spread panes out evenly (bound to E key).\n\n* Support wide characters properly when reflowing.\n\n* Pass PWD to new panes as a hint to shells, as well as calling chdir().\n\n* Performance improvements for the various choose modes.\n\n* Only show first member of session groups in tree mode (-G flag to choose-tree\n  to show all).\n\n* Support %else in config files to match %if; from Brad Town in GitHub issue\n  1071.\n\n* Fix \"kind\" terminfo(5) capability to be S-Down not S-Up.\n\n* Add a box around the preview label in tree mode.\n\n* Show exit status and time in the remain-on-exit pane text; from Timo\n  Boettcher in GitHub issue 1103.\n\n* Correctly use pane-base-index in tree mode.\n\n* Change the allow-rename option default to off.\n\n* Support for xterm(1) title stack escape sequences (GitHub issue 1075 from\n  Brad Town).\n\n* Correctly remove padding cells to fix a UTF-8 display problem (GitHub issue\n  1090).\n\nCHANGES FROM 2.5 TO 2.6, 05 October 2017\n\n* Add select-pane -T to set pane title.\n\n* Fix memory leak when lines with BCE are removed from history.\n\n* Fix (again) the \"prefer unattached\" behaviour of attach-session.\n\n* Reorder how keys are checked to allow keys to be specified that have a\n  leading escape. GitHub issue 1048.\n\n* Support REP escape sequence (\\033[b).\n\n* Run alert hooks based on options rather than always, and allow further bells\n  even if there is an existing bell.\n\n* Add -d flag to display-panes to override display-panes-time.\n\n* Add selection_present format when in copy mode (allows key bindings that do\n  something different if there is a selection).\n\n* Add pane_at_left, pane_at_right, pane_at_top and pane_at_bottom formats.\n\n* Make bell, activity and silence alerting more consistent by: removing the\n  bell-on-alert option; adding activity-action and silence-action options with\n  the same possible values as the existing bell-action; adding a \"both\" value\n  for the visual-bell, visual-activity and visual-silence options to trigger\n  both a bell and a message.\n\n* Add a pane_pipe format to show if pipe-pane is active.\n\n* Block signals between forking and resetting signal handlers so that the\n  libevent signal handler doesn't get called in the child and incorrectly write\n  into the signal pipe that it still shares with the parent. GitHub issue 1001.\n\n* Allow punctuation in pane_current_command.\n\n* Add -c for respawn-pane and respawn-window.\n\n* Wait for any remaining data to flush when a pane is closed while pipe-pane is\n  in use.\n\n* Fix working out current client with no target. GitHub issue 995.\n\n* Try to fallback to C.UTF-8 as well as en_US.UTF-8 when looking for a UTF-8\n  locale.\n\n* Add user-keys option for user-defined key escape sequences (mapped to User0\n  to User999 keys).\n\n* Add pane-set-clipboard hook.\n\n* FAQ file has moved out of repository to online.\n\n* Fix problem with high CPU usage when a client dies unexpectedly. GitHub issue\n  941.\n\n* Do a dance on OS X 10.10 and above to return tmux to the user namespace,\n  allowing access to the clipboard.\n\n* Do not allow escape sequences which expect a specific terminator (APC, DSC,\n  OSC) to wait for forever - use a small timeout. This reduces the chance of\n  the pane locking up completely when sent garbage (cat /dev/random or\n  similar).\n\n* Support SIGUSR2 to toggle logging on a running server, also generate the\n  \"out\" log file with -vv not -vvvv.\n\n* Make set-clipboard a three state option: on (tmux both sends to outside\n  terminal and accepts from applications inside); external (tmux sends outside\n  but does not accept inside); and off.\n\n* Fix OSC 4 palette setting for bright foreground colours. GitHub issue 954.\n\n* Use setrgbf and setrgbb terminfo(5) capabilities to set RGB colours, if they\n  are available. (Tc is still supported as well.)\n\n* Fix redrawing panes when they are resized several times but end up with the\n  size unchanged (for example, splitw/resizep -Z/breakp).\n\n* Major rewrite of choose mode. Now includes preview, sorting, searching and\n  tagging; commands that can be executed directly from the mode (for example,\n  to delete one or more buffers); and filtering in tree mode.\n\n* choose-window and choose-session are now aliases of choose-tree (in the\n  command-alias option).\n\n* Support OSC 10 and OSC 11 to set foreground and background colours.\n\n* Check the U8 capability to determine whether to use UTF-8 line drawing\n  characters for ACS.\n\n* Some missing notifications for layout changes.\n\n* Control mode clients now do not affect session sizes until they issue\n  refresh-client -C. new-session -x and -y works with control clients even if\n  the session is not detached.\n\n* All new sessions that are unattached (whether with -d or started with no\n  terminal) are now created with size 80 x 24. Whether the status line is on or\n  off does not affect the size of new sessions until they are attached.\n\n* Expand formats in option names and add -F flag to expand them in option values.\n\n* Remember the search string for a pane even if copy mode is exited and entered\n  again.\n\n* Some further BCE fixes (scroll up, reverse index).\n\n* Improvements to how terminals are cleared (entirely or partially).\n\nCHANGES FROM 2.4 TO 2.5, 09 May 2017\n\n* Reset updated flag when restarting #() command so that new output is properly\n  recognised. GitHub issue 922.\n\n* Fix ECH with a background colour.\n\n* Do not rely on the terminal not moving the cursor after DL or EL.\n\n* Fix send-keys and send-prefix in copy-mode (so C-b C-b works). GitHub issue\n  905.\n\n* Set the current pane for rotate-window so it works in command sequences.\n\n* Add pane_mode format.\n\n* Differentiate M-Up from Escape+Up when possible (that is, in terminals with\n  xterm(1) style function keys). GitHub issue 907.\n\n* Add session_stack and window_stack_index formats.\n\n* Some new control mode notifications and corresponding hooks:\n  pane-mode-changed, window-pane-changed, client-session-changed,\n  session-window-changed.\n\n* Format pane_search_string for last search term while in copy mode (useful\n  with command-prompt -I).\n\n* Fix a problem with high CPU usage and multiple clients with #(). GitHub issue\n  889.\n\n* Fix UTF-8 combining characters in column 0.\n\n* Fix reference counting so that panes are properly destroyed and their\n  processes killed.\n\n* Clamp SU (CSI S) parameter to work around a bug in Konsole.\n\n* Tweak line wrapping in full width panes to play more nicely with terminal\n  copy and paste.\n\n* Fix when we emit SGR 0 in capture-pane -e.\n\n* Do not change TERM until after config file parsing has finished, so that\n  commands run inside the config file can use it to make decisions (typically\n  about default-terminal).\n\n* Make the initial client wait until config file parsing has finished to avoid\n  racing with commands.\n\n* Fix core when if-shell fails.\n\n* Only use ED to clear screen if the pane is at the bottom.\n\n* Fix multibyte UTF-8 output.\n\n* Code improvements around target (-t) resolution.\n\n* Change how the default target (for commands without -t) is managed across\n  command sequences: now it is set up at the start and commands are required\n  to update it if needed. Fixes binding command sequences to mouse keys.\n\n* Make if-shell from the config file work correctly.\n\n* Change to always check the root key table if no binding is found in the\n  current table (prefix table or copy-mode table or whatever). This means that\n  root key bindings will take effect even in copy mode, if not overridden by a\n  copy mode key binding.\n\n* Fix so that the history file works again.\n\n* Run config file without a client rather than using the first client, restores\n  previous behaviour.\n\n* If a #() command doesn't exit, continue to read from it and use its last full\n  line of output.\n\n* Handle slow terminals and fast output better: when the amount of data\n  outstanding gets too large, discard output until it is drained and we are\n  able to do a full redraw. Prevents tmux sitting on a huge buffer that the\n  terminal will take forever to consume.\n\n* Do not redraw a client unless we realistically think it can accept the data -\n  defer redraws until the client has nothing else waiting to write.\n\nCHANGES FROM 2.3 TO 2.4, 20 April 2017\n\nIncompatible Changes\n====================\n\n* Key tables have undergone major changes. Mode key tables are no longer\n  separate from the main key tables. All mode key tables have been removed,\n  together with the -t flag to bind-key and unbind-key.\n\n  The emacs-edit, vi-edit, emacs-choose and vi-choose tables have been replaced\n  by fixed key bindings in the command prompt and choose modes. The mode-keys\n  and status-keys options remain.\n\n  The emacs-copy and vi-copy tables have been replaced by the copy-mode and\n  copy-mode-vi tables. Commands are sent using the -X and -N flags to\n  send-keys. So the following:\n\n    bind -temacs-copy C-Up scroll-up\n    bind -temacs-copy -R5 WheelUpPane scroll-up\n\n  Becomes:\n\n    bind -Tcopy-mode C-Up send -X scroll-up\n    bind -Tcopy-mode WheelUpPane send -N5 -X scroll-up\n\n  These changes allows the full command parser (including command sequences) and\n  command set to be used - for example, the normal command prompt with editing\n  and history is now used for searching, jumping, and so on instead of a custom\n  one. The default C-r binding is now:\n\n    bind -Tcopy-mode C-r command-prompt -i -p'search up' \"send -X search-backward-incremental '%%'\"\n\n  There are also some new commands available with send -X, such as\n  copy-pipe-and-cancel.\n* set-remain-on-exit has gone -- can be achieved with hooks instead.\n* Hooks: before hooks have been removed and only a selection of commands now\n  have after hooks (they are no longer automatic). Additional hooks have been\n  added.\n* The xterm-keys option now defaults to on.\n\nNormal Changes\n==============\n\n* Support for mouse double and triple clicks.\n* BCE (Background Colour Erase) is now supported.\n* All occurrences of a search string in copy mode are now highlighted;\n  additionally, the number of search results is displayed. The highlighting\n  updates interactively with the default emacs key bindings (incremental\n  search).\n* source-file now understands glob patterns.\n* Formats now have simple comparisons:\n\n    #{==:a,b}\n    #{!=:a,b}\n\n* There are the following new formats:\n\n  - #{version} -- the tmux server version;\n  - #{client_termtype} -- the terminal type of the client;\n  - #{client_name} -- the name of a client;\n  - #{client_written} -- the number of bytes written to the client.\n\n* The configuration file now accepts %if/%endif conditional blocks which are\n  processed when it is parsed; the argument is a format string (useful with the\n  new format comparison options).\n* detach-client now has -E to execute a command replacing the client instead of\n  exiting.\n* Add support for custom command aliases, this is an array option which\n  contains items of the form \"alias=command\". This is consulted when an\n  unknown command is parsed.\n* break-pane now has -n to specify the new window name.\n* OSC 52 support has been added for programs inside tmux to set a tmux buffer.\n* The mouse \"all event\" mode (1003) is now supported.\n* Palette setting is now possible (OSC 4 and 104).\n* Strikethrough support (a recent terminfo is required).\n* Grouped sessions can now be named (new -t).\n* terminal-overrides and update-environment are now array options (the previous\n  set -ag syntax should work without change).\n* There have been substantial performance improvements.\n\nCHANGES FROM 2.2 TO 2.3, 29 September 2016\n\nIncompatible Changes\n====================\n\nNone.\n\nNormal Changes\n==============\n\n* New option 'pane-border-status' to add text in the pane borders.\n* Support for hooks on commands: 'after' and 'before' hooks.\n* 'source-file' understands '-q' to suppress errors for nonexistent files.\n* Lots of UTF8 improvements, especially on MacOS.\n* 'window-status-separator' understands #[] expansions.\n* 'split-window' understands '-f' for performing a full-width split.\n* Allow report count to be specified when using 'bind-key -R'.\n* 'set -a' for appending to user options (@foo) is now supported.\n* 'display-panes' can now accept a command to run, rather than always\n  selecting the pane.\n\nCHANGES FROM 2.1 TO 2.2, 10 April 2016\n\nIncompatible Changes\n====================\n\n* The format strings which referenced time have been removed.  Instead:\n\n  #{t:window_activity}\n\ncan be used.\n\n* Support for TMPDIR has been removed.  Use TMUX_TMPDIR instead.\n* UTF8 detection now happens automatically if the client supports it, hence\n  the:\n\n  mouse-utf8\n  utf8\n\n  options has been removed.\n* The:\n\n  mouse_utf8_flag\n\n  format string has been removed.\n* The -I option to show-messages has been removed.  See:\n\n  #{t:start_time}\n\n  format option instead.\n\nNormal Changes\n==============\n\n* Panes are unzoomed with selectp -LRUD\n* New formats added:\n\n  #{scroll_position}\n  #{socket_path}\n  #{=10:...} -- limit to N characters (from the start)\n  #{=-10:...} -- limit to N characters (from the end)\n  #{t:...} -- used to format time-based formats\n  #{b:...} -- used to ascertain basename from string\n  #{d:...} -- used to ascertain dirname from string\n  #{s:...} -- used to perform substitutions on a string\n\n* Job output is run via the format system, so formats work again\n* If display-time is set to 0, then the indicators wait for a key to be\n  pressed.\n* list-keys and list-commands can be run without starting the tmux server.\n* kill-session learns -C to clear all alerts in all windows of the session.\n* Support for hooks (internal for now), but hooks for the following have been\n  implemented:\n\n  alert-bell\n  alert-silence\n  alert-activity\n  client-attached\n  client-detached\n  client-resized\n  pane-died\n  pane-exited\n\n* RGB (24bit) colour support.  The 'Tc' flag must be set in the external TERM\n  entry (using terminal-overrides or a custom terminfo entry).\n\nCHANGES FROM 2.0 TO 2.1, 18 October 2015\n\nIncompatible Changes\n====================\n\n* Mouse-mode has been rewritten.  There's now no longer options for:\n\t- mouse-resize-pane\n\t- mouse-select-pane\n\t- mouse-select-window\n\t- mode-mouse\n\n  Instead there is just one option:  'mouse' which turns on mouse support\n  entirely.\n* 'default-terminal' is now a session option.  Furthermore, if this is set\n  to 'screen-*' then emulate what screen does.  If italics are wanted, this\n  can be set to 'tmux' but this is still new and not necessarily supported\n  on all platforms with older ncurses installs.\n* The c0-* options for rate-limiting have been removed.  Instead, a backoff\n  approach is used.\n\nNormal Changes\n==============\n\n* New formats:\n\t- session_activity\n\t- window_linked\n\t- window_activity_format\n\t- session_alerts\n\t- session_last_attached\n\t- client_pid\n\t- pid\n* 'copy-selection', 'append-selection', 'start-named-buffer' now understand\n  an '-x' flag to prevent it exiting copying mode.\n* 'select-pane' now understands '-P' to set window/pane background colours.\n* 'renumber-windows' now understands windows which are unlinked.\n* 'bind' now understands multiple key tables.  Allows for key-chaining.\n* 'select-layout' understands '-o' to undo the last layout change.\n* The environment is updated when switching sessions as well as attaching.\n* 'select-pane' now understands '-M' for marking a pane.  This marked pane\n  can then be used with commands which understand src-pane specifiers\n  automatically.\n* If a session/window target is prefixed with '=' then only an exact match\n  is considered.\n* 'move-window' understands '-a'.\n* 'update-environment' understands '-E' when attach-session is used on an\n  already attached client.\n* 'show-environment' understands '-s' to output Bourne-compatible commands.\n* New option: 'history-file' to save/restore command prompt history.\n* Copy mode is exited if the history is cleared whilst in copy-mode.\n* 'copy-mode' learned '-e' to exit copy-mode when scrolling to end.\n\nCHANGES FROM 1.9a TO 2.0, 06 March 2015\n\nIncompatible Changes\n====================\n\n* The choose-list command has been removed.\n* 'terminal-overrides' is now a server option, not a session option.\n* 'message-limit' is now a server option, not a session option.\n* 'monitor-content' option has been removed.\n* 'pane_start_path' option has been removed.\n* The \"info\" mechanism which used to (for some commands) provide feedback\n  has been removed, and like other commands, they now produce nothing on\n  success.\n\nNormal Changes\n==============\n\n* tmux can now write an entry to utmp if the library 'utempter' is present\n  at compile time.\n* set-buffer learned append mode (-a), and a corresponding\n  'append-selection' command has been added to copy-mode.\n* choose-mode now has the following commands which can be bound:\n\t- start-of-list\n\t- end-of-list\n\t- top-line\n\t- bottom-line\n\n* choose-buffer now understands UTF-8.\n* Pane navigation has changed:\n\t- The old way of always using the top or left if the choice is ambiguous.\n\t- The new way of remembering the last used pane is annoying if the\n\t  layout is balanced and the leftmost is obvious to the user (because\n\t  clearly if we go right from the top-left in a tiled set of four we want\n\t  to end up in top-right, even if we were last using the bottom-right).\n\n      So instead, use a combination of both: if there is only one possible\n      pane alongside the current pane, move to it, otherwise choose the most\n      recently used of the choice.\n* 'set-buffer' can now be told to give names to buffers.\n* The 'new-session', 'new-window', 'split-window', and 'respawn-pane' commands\n  now understand multiple arguments and handle quoting problems correctly.\n* 'capture-pane' understands '-S-' to mean the start of the pane, and '-E-' to\n  mean the end of the pane.\n* Support for function keys beyond F12 has changed.  The following explains:\n\t- F13-F24 are S-F1 to S-F12\n\t- F25-F36 are C-F1 to C-F12\n\t- F37-F48 are C-S-F1 to C-S-F12\n\t- F49-F60 are M-F1 to M-F12\n\t- F61-F63 are M-S-F1 to M-S-F3\n\n Therefore, F13 becomes a binding of S-F1, etc.\n* Support using pane id as part of session or window specifier (so % means\n  session-of-%1 or window-of-%1) and window id as part of session\n  (so @1 means session-of-@1).\n* 'copy-pipe' command now understands formats via -F\n* 'if-shell'  command now understands formats via -F\n* 'split-window' and 'join-window' understand -b to create the pane to the left\n  or above the target pane.\n\nCHANGES FROM 1.9 TO 1.9a, 22 February 2014\n\nNOTE: This is a bug-fix release to address some important bugs which just\nmissed the 1.9 deadline, but were found afterwards.\n\nNormal Changes\n==============\n\n* Fix crash due to uninitialized lastwp member of layout_cell\n* Fix -fg/-bg/-style with 256 colour terminals.\n\nCHANGES FROM 1.8 TO 1.9, 20 February 2014\n\nNOTE:  This release has bumped the tmux protocol version.  It is therefore\nadvised that the prior tmux server is restarted when this version of tmux is\ninstalled, to avoid protocol mismatch errors for newer clients trying to\ntalk to an older running tmux server.\n\nIncompatible Changes\n====================\n\n* 88 colour support has been removed.\n* 'default-path' has been removed.  The new-window command accepts '-c' to\n  cater for this.  The previous value of \".\" can be replaced with: 'neww -c\n  $PWD', the previous value of '' which meant current path of the pane can\n  be specified as:  'neww -c \"#{pane_current_path}\"'\n\nDeprecated Changes\n==================\n\n* The single format specifiers:  #A -> #Z (where defined) have been\n  deprecated and replaced with longer-named equivalents, as listed in the\n  FORMATS section of the tmux manpage.\n* The various foo-{fg,bg,attr} commands have been deprecated and replaced\n  with equivalent foo-style option instead.  Currently this is still\n  backwards-compatible, but will be removed over time.\n\nNormal Changes\n==============\n\n* A new environment variable TMUX_TMPDIR is now honoured, allowing the\n  socket directory to be set outside of TMPDIR (/tmp/ if not set).\n* If -s not given to swap-pane the current pane is assumed.\n* A #{pane_synchronized} format specifier has been added to be a conditional\n  format if a pane is in a synchronised mode (c.f. synchronize-panes)\n* Tmux now runs under Cygwin natively.\n* Formats can now be nested within each other and expanded accordingly.\n* Added 'automatic-rename-format' option to allow the automatic rename\n  mechanism to use something other than the default of\n  #{pane_current_command}.\n* new-session learnt '-c' to specify the starting directory for that session\n  and all subsequent windows therein.\n* The session name is now shown in the message printed to the terminal when\n  a session is detached.\n* Lots more format specifiers have been added.\n* Server race conditions have been fixed; in particular commands are not run\n  until after the configuration file is read completely.\n* Case insensitive searching in tmux's copy-mode is now possible.\n* attach-session and switch-client learnt the '-t' option to accept a window\n  and/or a pane to use.\n* Copy-mode is only exited if no selection is in progress.\n* Paste key in copy-mode is now possible to enter text from the clipboard.\n* status-interval set to '0' now works as intended.\n* tmux now supports 256 colours running under fbterm.\n* Many bug fixes!\n\nCHANGES FROM 1.7 TO 1.8, 26 March 2013\n\nIncompatible Changes\n====================\n\n* layout redo/undo has been removed.\n\nNormal Changes\n==============\n\n* Add halfpage up/down bindings to copy mode.\n* Session choosing fixed to work with unattached sessions.\n* New window options window-status-last-{attr,bg,fg} to denote the last\n  window which was active.\n* Scrolling in copy-mode now scrolls the region without moving the mouse\n  cursor.\n* run-shell learnt '-t' to specify the pane to use when displaying output.\n* Support for middle-click pasting.\n* choose-tree learns '-u' to start uncollapsed.\n* select-window learnt '-T' to toggle to the last window if it's already\n  current.\n* New session option 'assume-paste-time' for pasting text versus key-binding\n  actions.\n* choose-* commands now work outside of an attached client.\n* Aliases are now shown for list-commands command.\n* Status learns about formats.\n* Free-form options can be set with set-option if prepended with an '@'\n  sign.\n* capture-pane learnt '-p' to send to stdout, and '-e' for capturing escape\n  sequences, and '-a' to capture the alternate screen, and '-P' to dump\n  pending output.\n* Many new formats added (client_session, client_last_session, etc.)\n* Control mode, which is a way for a client to send tmux commands.\n  Currently more useful to users of iterm2.\n* resize-pane learnt '-x' and '-y' for absolute pane sizing.\n* Config file loading now reports errors from all files which are loaded via\n  the 'source-file' command.\n* 'copy-pipe' mode command to copy selection and pipe the selection to a\n  command.\n* Panes can now emit focus notifications for certain applications\n  which use those.\n* run-shell and if-shell now accept formats.\n* resize-pane learnt '-Z' for zooming a pane temporarily.\n* new-session learnt '-A' to make it behave like attach-session.\n* set-option learnt '-o' to prevent setting an option which is already set.\n* capture-pane and show-options learns '-q' to silence errors.\n* New command 'wait-for' which blocks a client until woken up again.\n* Resizing panes will now reflow the text inside them.\n* Lots and lots of bug fixes, fixing memory-leaks, etc.\n* Various manpage improvements.\n\nCHANGES FROM 1.6 TO 1.7, 13 October 2012\n\n* tmux configuration files now support line-continuation with a \"\\\" at the\n  end of a line.\n* New option status-position to move the status line to the top or bottom of\n  the screen.\n* Enforce history-limit option when clearing the screen.\n* Give each window a unique id, like panes but prefixed with @.\n* Add pane id to each pane in layout description (while still accepting\n  the old form).\n* Provide defined ways to set the various default-path possibilities: ~\n  for home directory, . for server start directory, - for session start\n  directory and empty for the pane's working directory (the default). All\n  can also be used as part of a relative path (eg -/foo). Also provide -c\n  flags to neww and splitw to override default-path setting.\n* Add -l flag to send-keys to send input literally (without translating\n  key names).\n* Allow a single option to be specified to show-options to show just that\n  option.\n* New command \"move-pane\" (like join-pane but allows the same window).\n* join-pane and move-pane commands learn \"-b\" option to place the pane to\n  the left or above.\n* Support for bracketed-paste mode.\n* Allow send-keys command to accept hex values.\n* Add locking around \"start-server\" to avoid race-conditions.\n* break-pane learns -P/-F arguments for display formatting.\n* set-option learns \"-q\" to make it quiet, and not print out anything.\n* copy mode learns \"wrap-search\" option.\n* Add a simple form of output rate limiting by counting the number of\n  certain C0 sequences (linefeeds, backspaces, carriage returns) and if it\n  exceeds a threshold (current default 250/millisecond), start to redraw\n  the pane every 100 milliseconds instead of making each change as it\n  comes. Two configuration options - c0-change-trigger and\n  c0-change-interval.\n* find-window learns new flags:  \"-C\", \"-N\", \"-T\" to match against either or\n  all of a window's content, name, or title.  Defaults to all three options\n  if none specified.\n* find-window automatically selects the appropriate pane for the found\n  matches.\n* show-environment can now accept one option to show that environment value.\n* Exit mouse mode when end-of-screen reached when scrolling with the mouse\n  wheel.\n* select-layout learns -u and -U for layout history stacks.\n* kill-window, detach-client, kill-session all  learn \"-a\" option for\n  killing all but the current thing specified.\n* move-window learns \"-r\" option to renumber window sequentially in a\n  session.\n* New session option \"renumber-windows\" to automatically renumber windows in\n  a session when a window is closed.  (see \"move-window -r\").\n* Only enter copy-mode on scroll up.\n* choose-* and list-* commands all use \"-F\" for format specifiers.\n* When spawning external commands, the value from the \"default-shell\" option\n  is now used, rather than assuming /bin/sh.\n* New choose-tree command to render window/sessions as a tree for selection.\n* display-message learns new format options.\n* For linked-windows across sessions, all flags for that window are now\n  cleared across sessions.\n* Lots and lots of bug fixes, fixing memory-leaks, etc.\n* Various manpage improvements.\n\nCHANGES FROM 1.5 TO 1.6, 23 January 2012\n\n* Extend the mode-mouse option to add a third choice which means the mouse\n  does not enter copy mode.\n* Add a -r flag to switch-client to toggle the client read-only flag.\n* Add pane-base-index option.\n* Support \\ for line continuation in the configuration file.\n* Framework for more powerful formatting of command output and use it for\n  list-{panes,windows,sessions}. This allows more descriptive replacements\n  (such as #{session_name}) and conditionals.\n* Mark dead panes with some text saying they are dead.\n* Reject $SHELL if it is not a full path.\n* Add -S option to refresh-client to redraw status line.\n* Add an else clause for if-shell.\n* Try to resolve relative paths for loadb and saveb (first, using client\n  working directory, if any, then default-path or session working directory).\n* Support for \\e[3J to clear the history and send the corresponding\n  terminfo code (E3) before locking.\n* When in copy mode, make repeat count indicate buffer to replace, if used.\n* Add screen*:XT to terminal-overrides for tmux-in-tmux.\n* Status-line message attributes added.\n* Move word-separators to be a session rather than window option.\n* Change the way the working directory for new processes is discovered. If\n  default-path isn't empty, it is used. Otherwise, if a new window is created\n  from the command-line, the working directory of the client is used. If not,\n  platform specific code is used to retrieve the current working directory\n  of the process in the active pane. If that fails, the directory where the\n  session was created is used, instead.\n* Do not change the current pane if both mouse-select-{pane,window} are\n  enabled.\n* Add \\033[s and \\033[u to save and restore cursor position.\n* Allow $HOME to be used as default-path.\n* Add CNL and CPL escape sequences.\n* Calculate last position correctly for UTF-8 wide characters.\n* Add an option allow-rename to disable the window rename escape sequence.\n* Attributes for each type of status-line alert (ie bell, content and\n  activity) added. Therefore, remove the superfluous options\n  window-status-alert-{attr,bg,fg}.\n* Add a -R flag to send-keys to reset the terminal.\n* Add strings to allow the aixterm bright colours to be used when\n  configuring colours.\n* Drop the ability to have a list of keys in the prefix in favour of two\n  separate options, prefix and prefix2.\n* Flag -2 added to send-prefix to send the secondary prefix key.\n* Show pane size in top right of display panes mode.\n* Some memory leaks plugged.\n* More command-prompt editing improvements.\n* Various manpage improvements.\n* More Vi mode improvements.\n\nCHANGES FROM 1.4 TO 1.5, 09 July 2011\n\n* Support xterm mouse modes 1002 and 1003.\n* Change from a per-session stack of buffers to one global stack. This renders\n  copy-buffer useless and makes buffer-limit now a server option.\n* Fix most-recently-used choice by avoiding reset the activity timer for\n  unattached sessions every second.\n* Add a -P option to new-window and split-window to print the new window or\n  pane index in target form (useful to pass it into other commands).\n* Handle a # at the end of a replacement string (such as status-left)\n  correctly.\n* Support for UTF-8 mouse input (\\033[1005h) which was added in xterm 262.\n  If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all\n  UTF-8 terminals. The option defaults to on if LANG etc are set in the same\n  manner as the utf8 option.\n* Support for HP-UX.\n* Accept colours of the hex form #ffffff and translate to the nearest from the\n  xterm(1) 256-colour set.\n* Clear the non-blocking IO flag (O_NONBLOCK) on the stdio file descriptors\n  before closing them (fixes things like \"tmux ls && cat\").\n* Use TMPDIR if set.\n* Fix next and previous session functions to actually work.\n* Support -x and -y for new-session to specify the initial size of the window\n  if created detached with -d.\n* Make bind-key accept characters with the top-bit-set and print them as octal.\n* Set $TMUX without the session when background jobs are run.\n* Simplify the way jobs work and drop the persist type, so all jobs are\n  fire-and-forget.\n* Accept tcgetattr/tcsetattr(3) failure, fixes problems with fatal() if the\n  terminal disappears while locked.\n* Add a -P option to detach to HUP the client's parent process (usually causing\n  it to exit as well).\n* Support passing through escape sequences to the underlying terminal by using\n  DCS with a \"tmux;\" prefix.\n* Prevent tiled producing a corrupt layout when only one column is needed.\n* Give each pane created in a tmux server a unique id (starting from 0), put it\n  in the TMUX_PANE environment variable and accept it as a target.\n* Allow a start and end line to be specified for capture-pane which may be\n  negative to capture part of the history.\n* Add -a and -s options to lsp to list all panes in the server or session\n  respectively. Likewise add -s to lsw.\n* Change -t on display-message to be target-pane for the #[A-Z] replacements\n  and add -c as target-client.\n* The attach-session command now prefers the most recently used unattached\n  session.\n* Add -s option to detach-client to detach all clients attached to a session.\n* Add -t to list-clients.\n* Change window with mouse wheel over status line if mouse-select-window is on.\n* When mode-mouse is on, automatically enter copy mode when the mouse is\n  dragged or the mouse wheel is used. Also exit copy mode when the mouse wheel\n  is scrolled off the bottom.\n* Provide #h character pair for short hostname (no domain).\n* Don't use strnvis(3) for the title as it breaks UTF-8.\n* Use the tsl and fsl terminfo(5) capabilities to update terminal title and\n  automatically fill them in on terminals with the XT capability (which means\n  their title setting is xterm-compatible).\n* Add a new option, mouse-resize-pane. When on, panes may be resized by\n  dragging their borders.\n* Fix crash by resetting last pane on {break,swap}-pane across windows.\n* Add three new copy-mode commands - select-line, copy-line, copy-end-of-line.\n* Support setting the xterm clipboard when copying from copy mode using the\n  xterm escape sequence for the purpose (if xterm is configured to allow it).\n* Support xterm(1) cursor colour change sequences through terminfo(5) Cc\n  (set) and Cr (reset) extensions.\n* Support DECSCUSR sequence to set the cursor style with two new terminfo(5)\n  extensions, Cs and Csr.\n* Make the command-prompt custom prompts recognize the status-left option\n  character pairs.\n* Add a respawn-pane command.\n* Add a couple of extra xterm-style keys that gnome terminal provides.\n* Allow the initial context on prompts to be set with the new -I option to\n  command-prompt. Include the current window and session name in the prompt\n  when renaming and add a new key binding ($) for rename session.\n* Option bell-on-alert added to trigger the terminal bell when there is an\n  alert.\n* Change the list-keys format so that it shows the keys using actual tmux\n  commands which should be able to be directly copied into the config file.\n* Show full targets for lsp/lsw -a.\n* Make confirm-before prompt customizable with -p option like command-prompt\n  and add the character pairs #W and #P to the default kill-{pane,window}\n  prompts.\n* Avoid sending data to suspended/locked clients.\n* Small memory leaks in error paths plugged.\n* Vi mode improvements.\n\nCHANGES FROM 1.3 TO 1.4, 27 December 2010\n\n* Window bell reporting fixed.\n* Show which pane is active in the list-panes output.\n* Backoff reworked.\n* Prevent the server from dying when switching into copy mode when already\n  in a different mode.\n* Reset running jobs when the status line is enabled or disabled.\n* Simplify xterm modifier detection.\n* Avoid crashing in copy mode if the screen size is too small for the\n  indicator.\n* Flags -n and -p added to switch-client.\n* Use UTF-8 line drawing characters on UTF-8 terminals, thus fixing some\n  terminals (eg putty) which disable the vt100 ACS mode switching sequences\n  in UTF-8 mode. On terminals without ACS, use ASCII equivalents.\n* New server option exit-unattached added.\n* New session option destroy-unattached added.\n* Fall back on normal session choice method if $TMUX exists but is invalid\n  rather than rejecting.\n* Mark repeating keys with \"(repeat)\" in the key list.\n* When removing a pane, don't change the active pane unless the active pane\n  is actually the one being removed.\n* New command last-pane added.\n* AIX fixes.\n* Flag -a added to unbind-key.\n* Add XAUTHORITY to update-environment.\n* More info regarding window and pane flags is now shown in list-*.\n* If VISUAL or EDITOR contains \"vi\" configure mode-keys and status-key to vi.\n* New window option monitor-silence and session option visual-silence added.\n* In the built-in layouts distribute the panes more evenly.\n* Set the default value of main-pane-width to 80 instead of 81.\n* Command-line flag -V added.\n* Instead of keeping a per-client prompt history make it global.\n* Fix rectangle copy to behave like emacs (the cursor is not part of the\n  selection on the right edge but on the left it is).\n* Flag -l added to switch-client.\n* Retrieve environment variables from the global environment rather than\n  getenv(3), thus allowing them to be updated during the configuration file.\n* New window options other-pane-{height,width} added.\n* More minor bugs fixed and manpage improvements.\n\nCHANGES FROM 1.2 TO 1.3, 18 July 2010\n\n* New input parser.\n* Flags to move through panes -UDLR added to select-pane.\n* Commands up-pane, and down-pane removed, since equivalent behaviour is now\n  available through the target flag (-t:+ and -t:-).\n* Jump-forward/backward in copy move (based on vi's F, and f commands).\n* Make paste-buffer accept a pane as a target.\n* Flag -a added to new-window to insert a window after an existing one, moving\n  windows up if necessary.\n* Merge more mode into copy mode.\n* Run job commands explicitly in the global environment (which can be modified\n  with setenv -g), rather than with the environment tmux started with.\n* Use the machine's hostname as the default title, instead of an empty string.\n* Prevent double free if the window option remain-on-exit is set.\n* Key string conversions rewritten.\n* Mark zombie windows as dead in the choose-window list.\n* Tiled layout added.\n* Signal handling reworked.\n* Reset SIGCHLD after fork to fix problems with some shells.\n* Select-prompt command removed. Therefore, bound ' to command-prompt -p index\n  \"select-window -t:%%\" by default.\n* Catch SIGHUP and terminate if running as a client, thus avoiding clients from\n  being left hanging around when, for instance, a SSH session is disconnected.\n* Solaris 9 fixes (such as adding compat {get,set}env(3) code).\n* Accept none instead of default for attributes.\n* Window options window-status-alert-{alert,bg,fg} added.\n* Flag -s added to the paste-buffer command to specify a custom separator.\n* Allow dragging to make a selection in copy mode if the mode-mouse option is\n  set.\n* Support the mouse scroll wheel.\n* Make pipe-pane accept special character sequences (eg #I).\n* Fix problems with window sizing when starting tmux from .xinitrc.\n* Give tmux sockets (but not the containing folder) group permissions.\n* Extend the target flags (ie -t) to accept an offset (for example -t:+2), and\n  make it wrap windows, and panes.\n* New command choose-buffer added.\n* New server option detach-on-destroy to set what happens to a client when the\n  session it is attached to is destroyed. If on (default), the client is\n  detached. Otherwise, the client is switched to the most recently active of\n  the remaining sessions.\n* The commands load-buffer, and save-buffer now accept a dash (-) as the file\n  to read from stdin, or write to stdout.\n* Custom layouts added.\n* Additional code reduction, bug fixes, and manpage enhancements.\n\nCHANGES FROM 1.1 TO 1.2, 10 March 2010\n\n* Switch to libevent.\n* Emulate the ri (reverse index) capability, ergo allowing tmux to at least\n  start on Sun consoles (TERM=sun, or sun-color).\n* Assign each entry a number, or lowercase letter in choose mode, and accept\n  that as a shortcut key.\n* Permit top-bit-set characters to be entered in the status line.\n* Mark no-prefix keys with (no prefix), rather than [] in list-keys.\n* New command show-messages (alias showmsgs), and new session option\n  message-limit, to show a per-client log of status lines messages up to the\n  number defined by message-limit.\n* Do not interpret #() for display-message to avoid leaking commands.\n* New window options window-status-format, and window-status-current-format to\n  control the format of each window in the status line.\n* Add a -p flag to display-message to print the output, instead of displaying\n  it in the status line.\n* Emulate il1, dl1, ich1 to run with vt100 feature set.\n* New command capture-pane (alias capturep) to copy the entire pane contents\n  to a paste buffer.\n* Avoid duplicating code by adding a -w flag to set-option, and show-options to\n  set, and show window options. The commands set-window-option, and\n  show-window-options are now aliases.\n* Panes can now be referred to as top, bottom, top-left, etc.\n* Add server-wide options, which can be set with set-option -s, and shown with\n  show-options -s.\n* New server option quiet (like -q from the command line).\n* New server option escape-time to set the timeout used to detect if escapes\n  are alone, part of a function key, or meta sequence.\n* New session options pane-active-border-bg, pane-active-border-fg,\n  pane-border-bg, and pane-border-fg to set pane colours.\n* Make split-window accept a pane target, instead of a window.\n* New command join-pane (alias joinp) to split, and move an existing pane into\n  the space (the opposite of break-pane), thus simplifying calls to\n  split-window, followed by move-window.\n* Permit S- prefix on keys for shift when the terminal/terminfo supports them.\n* Window targets (-t flag) can now refer to the last window (!), next (+), and\n  previous (-) window by number.\n* Mode keys to jump to the bottom/top of history, end of the next word, scroll\n  up/down, and reverse search in copy mode.\n* New session option display-panes-active-colour to display the active pane in\n  a different colour with the display-panes command.\n* Read the socket path from $TMUX if it's present, and -L, and -S are not\n  given.\n* Vi-style mode keys B, W, and E to navigate between words in copy mode.\n* Start in more mode when configuration file errors are detected.\n* Rectangle copy support added.\n* If attach-session was specified with the -r flag, make the client read-only.\n* Per-window alternate-screen option.\n* Make load-buffer work with FIFOs.\n* New window option word-separators to set the characters considered as word\n  separators in copy mode.\n* Permit keys in copy mode to be prefixed by a repeat count, entered with [1-9]\n  in vi mode, or M-[1-9] in emacs mode.\n* utf8 improvements.\n* As usual, additional code reduction, bug fixes, and manpage enhancements.\n\nCHANGES FROM 1.0 TO 1.1, 05 November 2009\n\n* New run-shell (alias run) command to run an external command without a\n  window, capture it's stdout, and send it to output mode.\n* Ability to define multiple prefix keys.\n* Internal locking mechanism removed. Instead, detach each client and run the\n  external command specified in the new session option lock-command (by default\n  lock -np), thus allowing the system password to be used.\n* set-password command, and -U command line flag removed per the above change.\n* Add support for -c command line flag to execute a shell command.\n* New lock-client (alias lockc), and lock-session (alias locks) commands to\n  lock a particular client, or all clients attached to a session.\n* Support C-n/C-p/C-v/M-v with emacs keys in choice mode.\n* Use : for goto line rather than g in vi mode.\n* Try to guess which client to use when no target client was specified. Finds\n  the current session, and if only one client is present, use it. Otherwise,\n  return the most recently used client.\n* Make C-Down/C-Up in copy mode scroll the screen down/up one line without\n  moving the cursor.\n* Scroll mode superseded by copy mode.\n* New synchronize-panes window option to send all input to all other panes in\n  the same window.\n* New lock-server session option to lock, when off (on by default), each\n  session when it has been idle for the lock-after-time setting. When on, the\n  entire server locks when all sessions have been idle for their individual\n  lock-after-time setting.\n* Add support for grouped sessions which have independent name, options,\n  current window, but where the linked windows are synchronized (ie creating,\n  killing windows are mirrored between the sessions). A grouped session may be\n  created by passing -t to new-session.\n* New mouse-select-pane session option to select the current pane with the\n  mouse.\n* Queue, and run commands in the background for if-shell, status-left,\n  status-right, and #() by starting each once every status-interval. Adds the\n  capability to call some programs which would previously cause the server to\n  hang (eg sleep/tmux). It also avoids running commands excessively (ie if used\n  multiple times, it will be run only once).\n* When a window is zombified and automatic-rename is on, append [dead] to the\n  name.\n* Split list-panes (alias lsp) off from list-windows.\n* New pipe-pane (alias pipep) to redirect a pane output to an external command.\n* Support for automatic-renames for Solaris.\n* Permit attributes to be turned off in #[] by prefixing with no (eg nobright).\n* Add H/M/L in vi mode, and M-R/M-r in emacs to move the cursor to the top,\n  middle, and bottom of the screen.\n* -a option added to kill-pane to kill all except current pane.\n* The -d command line flag is now gone (can be replaced by terminal-overrides).\n  Just use op/AX to detect default colours.\n* input/tty/utf8 improvements.\n* xterm-keys rewrite.\n* Additional code reduction, and bug fixes.\n\nCHANGES FROM 0.9 TO 1.0, 20 September 2009\n\n* Option to alter the format of the window title set by tmux.\n* Backoff for a while after multiple incorrect password attempts.\n* Quick display of pane numbers (C-b q).\n* Better choose-window, choose-session commands and a new choose-client command.\n* Option to request multiple responses when using command-prompt.\n* Improved environment handling.\n* Combine wrapped lines when pasting.\n* Option to override terminal settings (terminal-overrides).\n* Use the full range of ACS characters for drawing pane separator lines.\n* Customisable mode keys.\n* Status line colour options, with embedded colours in status-left/right, and\n  an option to centre the window list.\n* Much improved layouts, including both horizontal and vertical splitting.\n* Optional visual bell, activity and content indications.\n* Set the utf8 and status-utf8 options when the server is started with -u.\n* display-message command to show a message in the status line, by default some\n  information about the current window.\n* Improved current process detection on NetBSD.\n* unlink-window -k is now the same as kill-window.\n* attach-session now works from inside tmux.\n* A system-wide configuration file, /etc/tmux.conf.\n* A number of new commands in copy mode, including searching.\n* Panes are now specified using the target (-t) notation.\n* -t now accepts fnmatch(3) patterns and looks for prefixes.\n* Translate \\r into \\n when pasting.\n* Support for binding commands to keys without the prefix key\n* Support for alternate screen (terminfo smcup/rmcup).\n* Maintain data that goes off screen after reducing the window size, so it can\n  be restored when the size is increased again.\n* New if-shell command to test a shell command before running a tmux command.\n* tmux now works as the shell.\n* Man page reorganisation.\n* Many minor additions, much code tidying and several bug fixes.\n\nCHANGES FROM 0.8 TO 0.9, 01 July 2009\n\n* Major changes to build infrastructure: cleanup of makefiles and addition\n  of a configure script.\n* monitor-content window option to monitor a window for a specific fnmatch(3)\n  pattern. The find-window command also now accepts fnmatch(3) patterns.\n* previous-layout and select-layout commands, and a main-horizontal layout.\n* Recreate the server socket on SIGUSR1.\n* clear-history command.\n* Use ACS line drawing characters for pane separator lines.\n* UTF-8 improvements, and code to detect UTF-8 support by looking at\n  environment variables.\n* The resize-pane-up and resize-pane-down commands are now merged together\n  into a new resize-pane command with -U and -D flags.\n* confirm-before command to request a yes/no answer before executing dangerous\n  commands.\n* Status line bug fixes, support for UTF-8 (status-utf8 option), and a key to\n  paste from the paste buffer.\n* Support for some additional escape sequences and terminal features, including\n  better support for insert mode and tab stops.\n* Improved window resizing behaviour, modelled after xterm.\n* Some code reduction and a number of miscellaneous bug fixes.\n\n================================================================================\n\nOn 01 June 2009, tmux was imported into the OpenBSD base system. From this date\nonward changes are logged as part of the normal CVS commit message to either\nOpenBSD or SourceForge CVS. This file will be updated to contain a summary of\nmajor changes with each release, and to mention important configuration or\ncommand syntax changes during development.\n\nThe list of older changes is below.\n\n================================================================================\n\n21 May 2009\n\n* stat(2) files before trying to load them to avoid problems, for example\n  with \"source-file /dev/zero\".\n\n19 May 2009\n\n* Try to guess if the window is UTF-8 by outputting a three-byte UTF-8 wide\n  character and seeing how much the cursor moves. Currently tries to figure out\n  if this works by some stupid checks on the terminal, these need to be\n  rethought. Also might be better using a width 1 character rather than width 2.\n* If LANG contains \"UTF-8\", assume the terminal supports UTF-8, on the grounds\n  that anyone who configures it probably wants UTF-8. Not certain if this is\n  a perfect idea but let's see if it causes any problems.\n* New window option: monitor-content. Searches for a string in a window and if\n  it matches, highlight the status line.\n\n18 May 2009\n\n* main-horizontal layout and main-pane-height option to match vertical.\n* New window option main-pane-width to set the width of the large left pane with\n  main-vertical (was left-vertical) layout.\n* Lots of layout cleanup. manual layout is now manual-vertical.\n\n16 May 2009\n\n* select-layout command and a few default key bindings (M-0, M-1, M-2, M-9) to\n  select layouts.\n* Recreate server socket on SIGUSR1, per SF feature request 2792533.\n\n14 May 2009\n\n* Keys in status line (p in vi mode, M-y in emacs) to paste the first line\n  of the upper paste buffer. Suggested by Dan Colish.\n* clear-history command to clear a pane's history.\n* Don't force wrapping with \\n when asked, let the cursor code figure it out.\n  Should fix terminals which use this to detect line breaks.\n* Major cleanup and restructuring of build infrastructure. Still separate files\n  for GNU and BSD make, but they are now hugely simplified at the expense of\n  adding a configure script which must be run before make. Now build and\n  install with:\n\n\t$ ./configure && make && sudo make install\n\n04 May 2009\n\n* Use ACS line drawing characters for pane separator lines.\n\n30 April 2009\n\n* Support command sequences without a space before the semicolon, for example\n  \"neww; neww\" now works as well as \"neww ; neww\". \"neww;neww\" is still an\n  error.\n* previous-layout command.\n* Display the layout name in window lists.\n* Merge resize-pane-up and resize-pane-down into resize-pane with -U and -D\n  flags.\n\n29 April 2009\n\n* Get rid of compat/vis.* - only one function was used which is easily\n  replaced,and less compat code == good.\n\n27 April 2009\n\n* Avoid using the prompt history when the server is locked, and prevent any\n  input entered from being added to the client's prompt history.\n* New command, confirm-before (alias confirm), which asks for confirmation\n  before executing a command. Bound \"&\" and \"x\" by default to confirm-before\n  \"kill-window\" and confirm-before \"kill-pane\", respectively.\n\n23 April 2009\n\n* Support NEL, yet another way of making newline. Fixes the output from some\n  Gentoo packaging thing. Reported by someone on SF then logs that allowed a\n  fix sent by tcunha.\n* Use the xenl terminfo flag to detect early-wrap terminals like the FreeBSD\n  console. Many thanks for a very informative email from Christian Weisgerber.\n\n21 April 2009\n\n* tmux 0.8 released.\n\n17 April 2009\n\n* Remove the right number of characters from the buffer when escape then\n  a cursor key (or other key prefixed by \\033) is pressed. Reported by\n  Stuart Henderson.\n\n03 April 2009\n\n* rotate-window command. -U flag (default) for up, -D flag for down.\n\n02 April 2009\n\n* Change scroll/pane redraws to only redraw the single pane affected rather\n  than the entire window.\n* If redrawing the region would mean redrawing > half the pane, just schedule\n  to redraw the entire window. Also add a flag to skip updating the window any\n  further if it is scheduled to be redrawn. This has the effect of batching\n  multiple redraws together.\n\n01 April 2009\n\n* Basic horizontal splitting and layout management. Still some redraw and other\n  issues - particularly, don't mix with manual pane resizing, be careful when\n  viewing from multiple clients and don't expect shell windows to redraw very\n  well after the layout is changed; generally cycling the layout a few times\n  will fix most problems. Getting this in for testing while I think about how\n  to deal with manual mode.\n\n  Split window as normal and cycle the layouts with C-b space. Some of the\n  layouts will work better when swap-pane comes along.\n\n31 March 2009\n\n* AIX port, thanks to cmihai for access to a box. Only tested on 6.1 with xlc\n  10.1 (make sure CC is set). Needs GNU make and probably ncurses (didn't try\n  plain curses). Also won't build with DEBUG, so comment the FDEBUG=1 line in\n  GNUmakefile.\n* Draw a vertical line on the right when the window size is less than the\n  terminal size. This is partly to shake out any horizontal limit bugs on the\n  way to horizontal splitting/pane tiling. Currently a bit slow since it has to\n  do a lot of redrawing but hopefully that will improve as I get some better\n  ideas for how to do it.\n* Fix remaining problems with copy and paste and UTF-8.\n\n28 March 2009\n\n* Better UTF-8 support, including combined characters. Unicode data is now\n  stored as UTF-8 in a separate array, the code does a lookup into this every\n  time it gets to a UTF-8 cell. Zero width characters are just appended onto\n  the UTF-8 data for the previous cell. This also means that almost no bytes\n  extra are wasted non-Unicode data (yay).\n\n  Still some oddities, such as copy mode skips over wide characters in a\n  strange way, and the code could do with some tidying.\n* Key repeating is now a property of the key binding not of the command.\n  Repeat is turned on when the key is bound with the -r flag to bind-key.\n  next/previous-window no longer repeat by default as it turned out to annoy\n  me.\n\n27 March 2009\n\n* Clear using ED when redrawing the screen. I foolishly assumed using spaces\n  would be equivalent and terminals would pick up on this, but apparently not.\n  This fixes copy and paste in xterm/rxvt.\n* Sockets in /tmp are now created in a subdirectory named, tmux-UID, eg\n  tmux-1000. The default socket is thus /tmp/tmux-UID/default. To start a\n  separate server, the new -L command line option should be used: this creates\n  a socket in the same directory with a different name (\"-L main\" will create\n  socket called \"main\"). -S should only be used to place the socket outside\n  /tmp. This makes sockets a little more secure and a bit more convenient to\n  use multiple servers.\n\n21 March 2009\n\n* New session flag \"set-remain-on-exit\" to set remain-on-exit flag for new\n  windows created in that session (like \"remain-by-default\" used to do). Not\n  perfectly happy about this, but until I can think of a good way to introduce\n  it generically (maybe a set of options in the session) this will do. Fixes\n  SF request 2527847.\n\n07 March 2009\n\n* Support for 88 colour terminals.\n* break-pane command to create a new window using an existing pane.\n\n02 March 2009\n\n* Make escape key timer work properly so escape+key can be used without\n  lightning fast key presses.\n\n13 February 2009\n\n* Redo mode keys slightly more cleanly and apply them to command prompt\n  editing. vi or emacs mode is controlled by the session option status-keys.\n\n12 February 2009\n\n* Looking up argv[0] is expensive, so just use p_comm for the window name which\n  is good enough. Also increase name update time to 500 ms.\n\n11 February 2009\n\n* Only use ri when actually at the top of the screen; just move the cursor up\n  otherwise.\n* FreeBSD's console wraps lines at $COLUMNS - 1 rather than $COLUMNS (the\n  cursor can never be beyond $COLUMNS - 1) and does not appear to support\n  changing this behaviour, or any of the obvious possibilities (turning off\n  right margin wrapping, insert mode). This is irritating, most notably because\n  it impossible to write to the very bottom-right of the screen without\n  scrolling. To work around this, if built on FreeBSD and run with a \"cons\"\n  $TERM, the bottom-right cell on the screen is omitted.\n* Emulate scroll regions (slowly) to support the few terminals which don't have\n  it (some of which don't really have any excuse).\n\n10 February 2009\n\n* No longer redraw the status line every status-interval unless it has actually\n  changed.\n\n08 February 2009\n\n* Don't treat empty arguments (\"\") differently when parsing configuration\n  file/command prompt rather than command line.\n* tmux 0.7 released.\n\n03 February 2009\n\n* New command, copy-buffer (alias copyb), to copy a session paste buffer to\n  another session.\n\n01 February 2009\n\n* The character pair #(command) may now contain (escaped) right parenthesis.\n\n30 January 2009\n\n* . now bound to \"command-prompt 'move-window %%'\" by default, from joshe.\n\n29 January 2009\n\n* Window options to set status line fg, bg and attributes for a single\n  window. Options are: window-status-fg, window-status-bg,\n  window-status-attr. Set to \"default\" to use the session status colours.\n\n  This allows quite neat things like:\n\n\t$ cat ~/bin/xssh\n\t#!/bin/sh\n\n\tif [ ! -z \"$TMUX\" ]; then\n\tcase \"$1\" in\n    \tnatalya)\n\t        tmux setw window-status-fg red >/dev/null\n\t\t;;\n\tnatasha)\n        \ttmux setw window-status-fg yellow >/dev/null\n\t\t;;\n\tesac\n\tfi\n\tssh \"$@\"\n\t[ ! -z \"$TMUX\" ] && tmux setw -u window-status-fg >/dev/null\n\t$ alias ssh=\"~/bin/xssh\"\n\n* Support #(command) in status-left, and status-right, which is displayed as\n  the first line of command's output (e.g. set -g status-right\n  \"#(whoami)@#(hostname -s)\"). Commands with )s aren't supported.\n\n28 January 2009\n\n* Support mouse in copy mode to move cursor. Can't do anything else at the\n  moment until other mouse modes are handled.\n* Better support for at least the most common variant of mouse input: parse it\n  and adjust for different panes. Also support mouse in window/session choice\n  mode.\n\n27 January 2009\n\n* Bring back the fancy window titles with session/window names: it is easy to\n  work around problems with elinks (see FAQ).\n* -u flag to scroll-mode and copy-mode to start scrolled one page\n  up. scroll-mode -u is bound to prefix,page-up (ppage) by default.\n* Allow status, mode and message attributes to be changed by three new options:\n  status-attr, mode-attr, message-attr. A comma-separated list is accepted\n  containing: bright, dim, underscore, blink, reverse, hidden, italics, for\n  example:\n\n\tset -g status-attr bright,blink\n\n  From Josh Elsasser, thanks!\n\n26 January 2009\n\n* Be more clever about picking the right process to create the window name.\n* Don't balls up the terminal on UTF-8 combined characters. Don't support them\n  properly either - they are just discarded for the moment.\n\n25 January 2009\n\n* load-buffer command\n\n23 January 2009\n\n* Use reverse colours rather than swapping fg and bg for message, mode and\n  status line. This makes these usable on black and white terminals.\n* Better error messages when creating a session or window fails.\n* Oops. Return non-zero on error. Reported by Will Maier.\n\n21 January 2009\n\n* Handle SIGTERM (and kill-server which uses it), a bit more neatly - tidy\n  up properly and print a nicer message. Same effect though :-).\n* new-window now supports -k to kill target window if it exists.\n* Bring back split-window -p and -l options to specify the height a percentage\n  or as a number of lines.\n* Make window and session choice modes allow you to choose items in vi keys\n  mode (doh!). As a side-effect, this makes enter copy selection (as well\n  as C-w/M-w) when using emacs keys in copy mode. Reported by merdely.\n\n20 January 2009\n\n* Darwin support for automatic-rename from joshe; Darwin doesn't seem to have\n  a sane method of getting argv[0] and searching for the precise insane way\n  is too frustrating, so this just uses the executable name.\n* Try to change the window title to match the command running it in. This is\n  done by reading argv[0] from the process group leader of the group that owns\n  the tty (tcgetpgrp()). This can't be done portably so some OS-dependent code\n  is introduced (ugh); OpenBSD, FreeBSD and Linux are supported at the moment.\n\n  A new window flag, automatic-rename, is available: if this is set to off, the\n  window name is not changed. Specifying a name with the new-window,\n  new-session or rename-window commands will automatically set this flag to off\n  for the window in question. To disable it entirely set the option to off\n  globally (setw -g automatic-rename off).\n\n19 January 2009\n\n* Fix various stupid issues when the status line is turned off. Grr.\n* Use reverse attributes for clock and cursor, otherwise they do not\n  appear on black and white terminals.\n* An error in a command sequence now stops execution of that sequence.\n  Internally, each command code now passes a return code back rather than\n  talking to the calling client (if any) directly.\n* attach-session now tries to start the server if it isn't already started - if\n  no sessions are created in .tmux.conf this will cause an error.\n* Clean up starting server by making initial client get a special socketpair.\n\n18 January 2009\n\n* Unbreak UTF-8.\n* -a flag to next-window and previous-window to select the next or previous\n  window with activity or bell. Bound to M-n and M-p.\n* find-window command to search window names, titles and visible content (but\n  not history) for a string. If only one is found, the window is selected\n  otherwise a choice list is shown. This (as with the other choice commands)\n  only works from a key. Bound to \"f\" by default.\n* Cleaned up command printing code, also enclose arguments with spaces in \"s.\n* Added command sequences. These are entered by separating each argument by a ;\n  argument (spaces on both sides), for example:\n\n\tlsk ; lsc\n\n  To use a literal ; as the argument prefix it with \\, for example:\n\n\tbind x lsk \\; lsc\n\n  Commands are executed from left to right. Also note that command sequences do\n  not support repeat-time repetition unless all commands making up the sequence\n  support it.\n* suspend-client command to suspend a client. Don't try to background it\n  though...\n* Mark attached sessions in sessions lists. Suggested by Simon Kuhnle.\n\n17 January 2009\n\n* tmux 0.6 released.\n\n15 January 2009\n\n* Support #H for hostname and #S for session name in status-left/right.\n* Two new commands, choose-window and choose-session which work only when bound\n  to a key and allow the window or session to be selected from a list. These\n  are now bound to \"w\" and \"s\" instead of the list commands.\n\n14 January 2009\n\n* Rework the prefix-time stuff. The option is now called repeat-time and\n  defaults to 500 ms. It only applies to a small subset of commands, currently:\n  up-pane, down-pane, next-window, previous-window, resize-pane-up,\n  resize-pane-down. These are the commands for which it is obviously useful,\n  having it for everything else was just bloody annoying.\n* The alt-up and alt-down keys now resize a pane by five lines at a time.\n* switch-pane is now select-pane and requires -p to select a pane. The\n  \"o\" key binding is changed to down-pane.\n* up-pane and down-pane commands, bound to arrow up and down by default.\n* Multiple vertical window splitting. Minimum pane size is four lines, an\n  (unhelpful) error will be shown if attempting to split a window with less\n  that eight lines. If the window is resized, as many panes are shown as can\n  fit without reducing them below four lines. There is (currently!) not a way\n  to show a hidden pane without making the window larger.\n\n  Note the -p and -l options to split-window are now gone, these may reappear\n  once I think them through again.\n* Server locking on inactivity (lock-after-time) is now disabled by default.\n\n13 January 2009\n\n* kill-pane command.\n\n12 January 2009\n\n* command-prompt now accepts a single argument, a template string. Any\n  occurrences of %% in this string are replaced by whatever is entered at the\n  prompt and the result is executed as a command. This allows things like (now\n  bound by default):\n\n  \t bind , command-prompt \"rename-window %%\"\n\n  Or my favourite:\n\n         bind x command-prompt \"split-window 'man %%'\"\n\n* Option to set prefix time, allowing multiple commands to be entered without\n  pressing the prefix key again, so long as they each typed within this time of\n  each other.\n* Yet more hacks for key handling. Think it is just about working now.\n* Two commands, resize-pane-up and resize-pane-down to resize a pane.\n* Make the window pane code handle panes of different sizes, and add a -l\n  and -p arguments to split-window to specify the new window size in lines\n  or as a percentage.\n\n11 January 2009\n\n* Vertical window splitting. Currently can only split a window into two panes.\n  New split-window command splits (bound to \") and switch-pane command (bound to\n  o) switches between panes.\n\n  close-pane, swap-pane commands are to follow. Also to come are pane resizing,\n  >2 panes, the ability to break a pane out to a full window and vice versa and\n  possibly horizontal splitting.\n\n  Panes are subelements of windows rather than being windows in their own\n  right. I tried to make them windows (so the splitting was at the session or\n  client level) but this rapidly became very complex and invasive. So in the\n  interests of having something working, I just made it so each window can have\n  two child processes instead of one (and it still took me 12 hours straight\n  coding). Now the concept is proven and much of the support code is there,\n  this may change in future if more flexibility is needed.\n* save-buffer command, from Tiago Cunha.\n\n10 January 2009\n\n* New option, lock-after-time. If there is no activity in the period specified\n  by this option (in seconds), tmux will lock the server. Default is 1800 (30\n  minutes), set to 0 to disable.\n* Server locking. Two new commands: set-password to set a password (a\n  preencrypted password may be specified with -c); and lock-server to lock the\n  server until the password is entered. Also an additional command line flag,\n  -U, to unlock from the shell. The default password is blank (any password\n  accepted). If specifying an encrypted password from encrypt(1) in .tmux.conf\n  with -c, don't forget to enclose it in single-quotes (') to prevent shell\n  variable expansion.\n* If a window is created from the command line, tmux will now use the same\n  current working directory for the new process. A new default-path option to\n  sets the working directory for processes created from keys or interactively\n  from the prompt.\n* New mode to display a large clock. Entered with clock-mode command (bound to\n  C-b t by default); two window options: clock-mode-colour and clock-mode-style\n  (12 or 24). This will probably be used as the basis for window locking.\n* New command, server-info, to show some server information and terminal\n  details.\n\n09 January 2009\n\n* Stop using ncurses variables and instead build a table of the codes we want\n  into an array for each terminal type. This makes the code a little more\n  untidy in places but gets rid of the awful global variables and calling\n  setterm all the time, and shoves all the ncurses-dependent mess into a single\n  file, tty-term.c. It also allows overriding single terminal codes, this is\n  used to fix rxvt on some platforms (where it is missing dch) and in future\n  may allow user customisation a la vim.\n* Update key handling code. Simplify, support ctrl properly and add a new\n  window option (xterm-keys) to output xterm key codes including ctrl and,\n  if available, alt and shift.\n\n08 January 2009\n\n* If built without DEBUG (the release versions), don't cause a fatal error if\n  the grid functions notice an input error, just log and ignore the\n  request. This might mean me getting shouted at less often when bugs kill\n  long-running sessions, at least in release versions.\n* Hopefully fix cursor out-of-bounds checking when writing to grid. When I\n  wrote the code I must have forgotten that the cursor can be one cell off the\n  right of the screen (yes, I know), so there were number of out-of-bounds/\n  overflow problems.\n\n07 January 2009\n\n* New flag to set and setw, -u, to unset an option (allowing it to inherit from)\n  the global options again.\n* Added more info messages for options changes.\n* A bit of tidying and reorganisation of options code.\n\n06 January 2009\n\n* Don't crash when backspacing if cursor is off the right of the screen,\n  reported by David Chisnall.\n* Complete words at any point inside command in prompt, also use option name\n  as well as command names.\n* Per-client prompt history of up to 100 items.\n* Use a splay tree for key bindings instead of an array. As a side-effect this\n  sorts them when listed.\n\n22 December 2008\n\n* Use the right keys for home and end.\n\n20 December 2008\n\n* Add vim mode for tmux configuration file to examples/, from Tiago Cunha.\n\n15 December 2008\n\n* New command, source-file (alias source), to load a configuration\n  file. Written by Tiago Cunha, many thanks.\n\n13 December 2008\n\n* Work around lack of dch. On Linux, the rxvt termcap doesn't have it (it is\n  lying, but we can't really start disbelieving termcaps...). This is a bit\n  horrible - I can see no way to do it without pretty much redrawing the whole\n  line, but it works...\n\n10 December 2008\n\n* glibc's getopt(3) is useless: it is not POSIX compliant without jumping\n  through non-portable hoops, and the method of resetting it is unclear (the\n  man page on my system says set optind to 1, but other sources say 0). So,\n  import OpenBSD's getopt_long.c into compat/ for use on Linux and use the\n  clearly documented optreset = optind = 1 method. This fixes some strange\n  issues with command parsing (getting the syntax wrong would prevent any\n  further commands being parsed).\n\n06 December 2008\n\n* Bring set/setw/show/showw into line with other commands. This means that by\n  default they now affect the current window (if any); the new -g flag must be\n  passed to set the global options. This changes the behaviour of set/show and\n  WILL BREAK CURRENT CONFIGURATIONS.\n\n  In summary, whether in the configuration file, the command prompt, or a key\n  binding, use -g to set a global option, use -t to specify a particular window\n  or session, or omit both to try and use the current window or session.\n\n  This makes set/show a bit of a pain but is the correct behaviour for\n  setw/showw and is the same as every other command, so we can put up with a\n  bit of pain for consistency.\n* Redo window options. They now work in the same way to session options with a\n  global options set. showw/setw commands now have similar syntax to show/set\n  (including the ability to use abbreviations).\n\n  PLEASE NOTE this includes the following configuration-breaking changes:\n\n  - remain-by-default is now GONE, use \"setw -g remain-on-exit\" to apply the\n    global window option instead;\n  - mode-keys is now a window option rather than session - use \"setw [-g]\n    mode-keys\" instead of set.\n\n  There are also some additions:\n\n  - message-fg and message-bg session options to control status line message\n    colours;\n  - mode-fg and mode-bg window options to set colours in window modes such as\n    copy mode.\n\n  The options code still a mess and now there is twice as much of it :-(.\n\n02 December 2008\n\n* Add support for including the window title in status-left or status-right\n  strings by including the character pair \"#T\". This may be prefixed with\n  a number to specify a maximum length, for example \"#24T\" to use at most\n  24 characters of the title.\n* Introduce two new options, status-left-length and status-right-length,\n  control the maximum length of left and right components of the status bar.\n* elinks (and possibly others) bypass the terminal and talk directly to X to\n  restore the window title when exiting. tmux can't know about this particular\n  bit of stupidity so the title ends up strange - the prefix isn't terribly\n  important and elinks is quite useful so just get rid of it.\n\n27 November 2008\n\n* Tweaks to support Dragonfly.\n\n17 November 2008\n\n* tmux 0.5 released.\n\n16 November 2008\n\n* New window option: \"utf8\"; this must be on (it is off by default) for UTF-8\n  to be parsed. The global/session option \"utf8-default\" controls the setting\n  for new windows.\n\n  This means that by default tmux does not handle UTF-8. To use UTF-8 by\n  default it is necessary to a) \"set utf8-default on\" in .tmux.conf b) start\n  tmux with -u on any terminal which support UTF-8.\n\n  It seems a bit unnecessary for this to be a per-window option but that is\n  the easiest way to do it, and it can't do any harm...\n* Enable default colours if op contains \\033[39;49m, based on a report from\n  fulvio ciriaco.\n\n12 November 2008\n\n* Keep stack of last windows rather than just most recent; based on a diff from\n  joshe.\n\n04 November 2008\n\n* Don't try to redraw status line when showing a prompt or message; if it does,\n  the status timer is never reset so it redraws on every loop. Spotted by\n  joshe.\n\n09 October 2008\n\n* Translate 256 colours into 16 if 256 is not available, same as screen does.\n* Better support for OSC command (only to set window title now), and also\n  support using APC for the same purpose (some Linux default shell profiles do\n  this).\n\n25 September 2008\n\n* Large internal rewrite to better support 256 colours and UTF-8. Screen data\n  is now stored as single two-way array of structures rather than as multiple\n  separate arrays. Also simplified a lot of code.\n\n  Only external changes are three new flags, -2, -d and -u, which force tmux to\n  assume the terminal supports 256 colours, default colours (useful for\n  xterm-256color which lacks the AX flag), or UTF-8 respectively.\n\n10 September 2008\n\n* Split off colour conversion code from screen code.\n\n09 September 2008\n\n* Initial UTF-8 support. A bit ugly and with a limit of 4096 UTF-8\n  characters per window.\n\n08 September 2008\n\n* 256 colour support. tmux attempts to autodetect the terminal by looking\n  both at what ncurses reports (usually wrong for xterm) and checking if\n  the TERM contains \"256col\". For xterm TERM=xterm-256color is needed (as\n  well as a build that support 256 colours); this seems to work for rxvt\n  as well. On non-256 colour terminals, high colours are translated to white\n  foreground and black background.\n\n28 August 2008\n\n* Support OS X/Darwin thanks to bsd-poll.c from OpenSSH. Also convert\n  from clock_gettime(2) to gettimeofday(2) as OS X doesn't support the\n  former; microsecond accuracy will have to be sufficient ;-).\n\n07 August 2008\n\n* Lose some unused/useless wrapper functions.\n\n25 July 2008\n\n* Shell variables may now be defined and used in configuration file. Define\n  variables with:\n\n\tVAR=1\n\n  And use with:\n\n        renamew ${VAR}\n\trenamew \"x${VAR}x\"\n\n Also some other fixes to make, for example, \"abc\"\"abc\" work similarly to\n the shell.\n\n24 July 2008\n\n* Finally lose inconsistently-used SCREEN_DEF* defines.\n* If cursor mode is on, switch the arrow keys from \\033[A to \\033OA.\n* Support the numeric keypad in both application and numbers mode. This is\n  different from screen which always keeps it in application mode.\n\n19 July 2008\n\n* Unbreak \"set status\" - tmux thought it was ambiguous, reported by rivo nurges.\n\n02 July 2008\n\n* Split vi and emacs mode keys into two tables and add an option (mode-keys)\n  to select between them. Default is emacs, use,\n\n     tmux set mode-keys vi\n\n  to change to vi.\n\n  vi mode uses space to start selection, enter to copy selection and escape\n  to clear selection.\n\n01 July 2008\n\n* Protocol versioning. Clients which identify as a different version from the\n  server will be rejected.\n* tmux 0.4 released.\n\n29 June 2008\n\n* Zombie windows. These are not closed when the child process dies. May be\n  set for a window with the new \"remain-on-exit\" option; the default setting\n  of this flag for new windows may be set with the \"remain-by-default\" session\n  option.\n\n  A window may be restarted with the respawn-window command:\n\n  \trespawn-window [-k] [command]\n\n  If -k is given, any existing process running in the window is killed;\n  if command is omitted, the same command as when the window was first\n  created is used.\n\n27 June 2008\n\n* Handle nonexistent session or client to -t properly.\n\n25 June 2008\n\n* select-prompt command to allow a window to be selected at a prompt. Only\n  windows in the current session may be selected. Bound to ' by default.\n  Suggested by merdely.\n* move-window command. Requested by merdely.\n* Support binding alt keys (prefixed with M-). Change default to use\n  C- for ctrl keys (^ is still accepted as an alternative).\n* Slim down default key bindings: support lowercase only.\n* Handle escaped keys properly (parse eg \\033b into a single key code) and\n  use this to change copy mode next/previous work to M-f and M-b to match\n  emacs.\n\n24 June 2008\n\n* Next word (C-n/w) and previous word (C-b/b) in copy mode.\n\n23 June 2008\n\n* list-commands command (alias lscm).\n* Split information about options into a table and use it to parse options\n  on input (allowing abbreviations) and to print them with show-options\n  (meaning that bell-action gets a proper string). This turned out a bit ugly\n  though :-/.\n\n22 June 2008\n\n* Do not translate black and white into default if the terminal supports\n  default colours. This was nice to force programs which didn't use default\n  colours to be properly transparent in rxvt/aterm windows with a background\n  image, but it causes trouble if someone redefines the default foreground and\n  background (to have black on white or something).\n\n21 June 2008\n\n* Naive tab completion in the command prompt. This only completes command\n  names if a) they are at the start of the text b) the cursor is at\n  the end of the text c) the text contains no spaces.\n* Only attempt to set the title where TERM looks like an xterm (contains\n  \"xterm\", \"rxvt\" or is \"screen\"). I hate this but I don't see a better way:\n  setting the title actually kills some other terminals pretty much dead.\n* Strip padding out of terminfo(5) strings. Currently the padding is just\n  ignored, this may need to be altered if there are any software terminals\n  out there that actually need it.\n\n20 June 2008\n\n* buffer-limit option to set maximum size of buffer stack. Default is 9.\n* Initial buffer improvements. Each session has a stack of buffers and each\n  buffer command takes a -b option to manipulate items on the stack. If -b\n  is omitted, the top entry is used. The following commands are currently\n  available:\n\n\tset-buffer [-b index] [-t target-session] string\n\tpaste-buffer [-d] [-b index] [-t target-window]\n\tdelete-buffer [-b index] [-t target-session]\n\tshow-buffers [-t target-session]\n\tshow-buffer [-b index] [-t target-session]\n\n  -d to paste-buffer deletes the buffer after pasting it.\n* New option, display-time, sets the time status line messages stay on screen\n  (unless a key is pressed). Set in milliseconds, default is 750 (0.75 seconds).\n  The timer is only checked every 100 ms or so.\n\n19 June 2008\n\n* Use \"status\" consistently for status line option, and prefix for \"prefix\" key\n  option.\n* Allow commands to be entered at a prompt. This is triggered with the\n  command-prompt command, bound to : by default.\n* Show status messages properly, without blocking the server.\n\n18 June 2008\n\n* New option, set-titles. On by default, this attempts to set the window title\n  using the \\e]2;...\\007 xterm code.\n\n  Note that elinks requires the STY environment variable (used by screen) to be\n  set before it will set the window title. So, if you want window titles set by\n  elinks, set STY before running it (any value will do). I can't do this for all\n  windows since setting it to an invalid value breaks screen.\n* Show arrows at either end of status line when scrolled if more windows\n  exist. Highlight the arrow if a hidden window has activity or bell.\n* Scroll the status line to show the current window if necessary. Also handle\n  windows smaller than needed better (show a blank status line instead of\n  hanging or crashing).\n\n17 June 2008\n\n* tmux 0.3 released.\n\n16 June 2008\n\n* Add some information messages when window options are changed, suggested by\n  Mike Erdely. Also add a -q command-line option to suppress them.\n* show-window-options (showw) command.\n\n15 June 2008\n\n* show-options (show) command to show one or all options.\n\n14 June 2008\n\n* New window options: force-width and force-height. This will force a window\n  to an arbitrary width and height (0 for the default unlimited). This is\n  neat for emacs which doesn't have a sensible way to force hard wrapping at 80\n  columns. Also, don't try to be clever and use clr_eol when redrawing the\n  whole screen, it causes trouble since the redraw functions are used to draw\n  the blank areas too.\n* Clear the blank area below windows properly when they are smaller than client,\n  also add an indicator line to show the vertical limit.\n* Don't die on empty strings in config file, reported by Will Maier.\n\n08 June 2008\n\n* Set socket mode +x if any sessions are attached and -x if not.\n\n07 June 2008\n\n* Make status-interval actually changeable.\n\n06 June 2008\n\n* New window option: aggressive-resize. Normally, windows are resized to the\n  size of the smallest attached session to which they are linked. This means a\n  window only changes size when sessions are detached or attached, or they are\n  linked or unlinked from a session. This flag changes a window to be the size\n  of the smallest attached session for which it is the current window - it is\n  resized every time a session changes to it or away from it. This is nice for\n  things that handle SIGWINCH well (like irssi) and bad for things like shells.\n* The server now exits when no sessions remain.\n* Fix bug with inserting characters with TERM=xterm-color.\n\n05 June 2008\n\n* Completely reorganise command parsing. Much more common code in cmd-generic.c\n  and a new way of specifying windows, clients or sessions. Now, most commands\n  take a -t argument, which specifies a client, a session, or a window target.\n  Clients and sessions are given alone (sessions are fnmatch(3)d and\n  clients currently not), windows are give by (client|session):index. For\n  example, if a user is in session \"1\" window 0 on /dev/ttypi, these should all\n  be equivalent:\n\n\ttmux renamew newname\t\t\t(current session and window)\n\ttmux renamew -t: newname\t\t(current session and window)\n\ttmux renamew -t:0 newname\t\t(current session, window 0)\n\ttmux renamew -t0 newname\t\t(current session, window 0)\n\ttmux renamew -t1:0 newname\t\t(session 1, window 0)\n\ttmux renamew -t1: newname\t\t(session 1's current window)\n\ttmux renamew -t/dev/ttypi newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session and window)\n\ttmux renamew -t/dev/ttypi: newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session and window)\n\ttmux renamew -t/dev/ttypi:0 newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session, window 0)\n\n  This does have some downsides, for example, having to use -t on selectw,\n\n\ttmux selectw -t7\n\n  is annoying. But then using non-flagged arguments would mean renaming the\n  current window would need to be something like:\n\n\ttmux renamew : newname\n\n  It might be better not to try and be so consistent; comments to the usual\n  address ;-).\n* Infrastructure for printing arguments in list-keys output. Easy ones only for\n  now.\n\n04 June 2008\n\n* Add some vi(1) key bindings in copy mode, and support binding ^[, ^\\, ^]\n  ^^ and ^_. Both from/prompted by Will Maier.\n* setw monitor-activity and set status without arguments now toggle the current\n  value; suggested by merdely.\n* New command set-window-option (alias setw) to set the single current window\n  option: monitor-activity to determine whether window activity is shown in\n  the status bar for that window (default off).\n* Change so active/bell windows are inverted in status line.\n* Activity monitoring - window with activity are marked in status line. No\n  way to disable this/filter windows yet.\n* Brought select-window command into line with everything else; it now uses\n  -i for the window index.\n* Strings to display on the left and right of the status bar may now be set\n  with the status-left and status-right options. These are passed through\n  strftime(3) before being displayed. The status bar is automatically updated\n  at an interval set by the status-interval option. The default is to display\n  nothing on the left and the date and time on the left; the default update\n  interval is 15 seconds.\n\n03 June 2008\n\n* Per session options. Setting options without specifying a session sets the\n  global options as normal (global options are inherited by all sessions);\n  passing -c or -s will set the option only for that session.\n* Because a client has a session attached, any command needing a session can\n  take a client and use its session. So, anything that used to accept -s now\n  accepts -c as well.\n* -s to specify session name now supports fnmatch(3) wildcards; if multiple\n  sessions are found, or if no -s is specified, the most newly created is used.\n* If no command is specified, assume new-session. As a byproduct, clean up\n  command default values into separate init functions.\n* kill-server command.\n\n02 June 2008\n\n* New command, start-server (alias \"start\"), to start the tmux server and do\n  nothing else. This is good if you have a configuration file which creates\n  windows or sessions (like me): in that case, starting the server the first\n  time tmux new is run is bad since it creates a new session and window (as\n  it is supposed to - starting the server is a side-effect).\n\n  Instead, I have a little script which does the equivalent of:\n\n  \ttmux has -s0 2>/dev/null || tmux start\n  \ttmux attach -d -s0\n\n  And I use it to start the server if necessary and attach to my primary\n  session.\n* Basic configuration file in ~/.tmux.conf or specified with -f. This is file\n  contains a set of tmux commands that are run the first time the server is\n  started. The configuration commands are executed before any others, so\n  if you have a configuration file that contains:\n\n\tnew -d\n\tneww -s0\n\n  And you do the following without an existing server running:\n\n\ttmux new\n\n  You will end up with two sessions, session 0 with two windows (created by\n  the configuration file) and your client attached to session 1 with one\n  window (created by the command-line command). I'm not completely happy with\n  this, it seems a little non-obvious, but I haven't yet decided what to do\n  about it.\n\n  There is no environment variable handling or other special stuff yet.\n\n  In the future, it might be nice to be able to have per-session configuration\n  settings, probably by having conditionals in the file (so you could, for\n  example, have commands to define a particular window layout that would only\n  be invoked if you called tmux new -smysession and mysession did not already\n  exist).\n* BIG CHANGE: -s and -c to specify session name and client name are now passed\n  after the command rather than before it. So, for example:\n\n\ttmux -s0 neww\n\n  Becomes:\n\n\ttmux neww -s0\n\n  This is to allow them to be used in the (forthcoming) configuration file\n  THIS WILL BREAK ANY CURRENT SCRIPTS OR ALIASES USING -s OR -c.\n\n01 June 2008\n\n* Bug fix: don't die if -k passed to link-window and the destination doesn't\n  exist.\n* New command, send-keys, will send a set of keys to a window.\n\n31 May 2008\n\n* Fix so tmux doesn't hang if the initial window fails for some reason. This\n  was highlighted by problems on Darwin, thanks to Elias Pipping for the report\n  and access to a test account. (tmux still won't work on Darwin since its\n  poll(2) is broken.)\n\n02 January 2008\n\n* Don't attempt to reset the tty on exit if it has been closed externally.\n\n06 December 2007\n\n* Restore checks for required termcap entries and add a few more obvious\n  emulations.\n* Another major reorganisation, this time of screen handling. A new set of\n  functions, screen_write_*, are now used to write to a screen and a tty\n  simultaneously. These are used by the input parser to update the base\n  window screen and also by the different modes which now interpose their own\n  screen.\n\n30 November 2007\n\n* Support \\ek...\\e\\ to set window name.\n\n27 November 2007\n\n* Enable/disable mouse when asked, if terminal claims to support it. Mouse\n  sequences are just passed through unaltered for the moment.\n* Big internal reorganisation. Rather than leaving control of the tty solely in\n  the client and piping all data through a socket to it, change so that the\n  server opens the tty again and reads and writes to it directly. This avoids\n  a lot of buffering and copying. Also reorganise the redrawing stuff so that\n  everything goes through screen_draw_* - this makes the code simpler, but\n  still needs broken up more, and all the ways of writing to screens should be\n  more consistent.\n\n26 November 2007\n\n* Rather than shifting up one line at a time once the history is full,\n  shift by 10% of the history each time. This is faster.\n* Add ^A and ^E to copy mode to move to start-of-line/end-of-line.\n\n24 November 2007\n\n* Support for alt charset mode (VT100 graphics characters).\n\n23 November 2007\n\n* Mostly complete copy & paste. Copy mode entered with C-b [ (copy-mode\n  command). In copy mode, arrow keys/page up/page down/hjkl/C-u/C-f navigate,\n  space or C-space starts selection, and enter or C-w copies and (important!)\n  exits copy mode. C-b ] (paste-buffer) pastes into current window. No\n  extra utility keys (bol/eol/clear selection/etc), only one single buffer,\n  and no buffer manipulation commands (clear/view/etc) yet. The code is also\n  fugly :-(.\n* history-limit option to set maximum history. Does not apply retroactively to\n  existing windows! Lines take up a variable amount of space, but a reasonable\n  guess for an 80-column terminal is 250 KB per 1000 lines (of history used,\n  an empty history takes no space).\n\n21 November 2007\n\n* Create every line as zero length and only expand it as data is written,\n  rather than creating at full size immediately.\n* Make command output (eg list-keys) go to a scrollable window similar to\n  scroll mode.\n* Redo screen redrawing so it is a) readable b) split into utility functions\n  that can be used outside screen.c. Use these to make scroll mode only\n  redraw what it has to which gets rid of irritating flickering status box and\n  makes it much faster.\n* Full line width memory and horizontal scrolling in history.\n* Initial support for scroll history. = to enter scrolling mode, and then\n  vi keys or up/down/pgup/pgdown to navigate. Q to exit. No horizontal history\n  yet (need per-line sizes) and a few kinks to be worked out (resizing while in\n  history mode will probably cause trouble).\n\n20 November 2007\n\n* Fix format string error with \"must specify a client\" message. Also\n  sprinkle some printflike tags.\n* tmux 0.1 released.\n\n17 November 2007\n\n* (nicm) Add -k option to link-window to kill target window if it exists.\n\n16 November 2007\n\n* (nicm) Split in-client display into two columns. This is a hack but not a lot\n  more so than that bit is already and it helps with lots of keys.\n* (nicm) switch-client command to switch client between different sessions. This\n  is pretty cool:\n\n\t$ tmux bind q switch 0\n\t$ tmux bind w switch 1\n\n  Then you can switch between sessions 0 and 1 with a key :-).\n* (nicm) Accept \"-c client-tty\" on command line to allow client manipulation\n  commands, and change detach-/refresh-session to detach-/refresh-client (this\n  loses the -a behaviour, but at some point -session versions may return, and\n  -c will allow fnmatch(3)).\n* (nicm) List available commands on ambiguous command.\n\n12 November 2007\n\n* (nicm) If the terminal supports default colours (AX present), force black\n  background and white foreground to default. This is useful on transparent\n  *terms for programs which don't do it themselves (like most(1)).\n* (nicm) Fill in the rest of the man page.\n* (nicm) kill-session command.\n\n09 November 2007\n\n* (nicm) C-space is now \"^ \" not \"^@\".\n* (nicm) Support tab (\\011).\n* (nicm) Initial man page outline.\n* (nicm) -V to show version.\n* (nicm) rename-session command.\n\n08 November 2007\n\n* (nicm) Check for required terminal capabilities on start.\n\n31 October 2007\n\n* (nicm) Linux port.\n\n30 October 2007\n\n* (nicm) swap-window command. Same as link-window but swaps windows.\n\n26 October 2007\n\n* (nicm) Saving scroll region on \\e7 causes problems with ncmpc so I guess\n  it is not required.\n* (nicm) unlink-window command.\n* (nicm) link-window command to link an existing window into another session\n  (or another index in the same session). Syntax:\n\n\ttmux -s dstname link-window [-i dstidx] srcname srcidx\n\n* (nicm) Redo window data structures. The global array remains, but each per-\n  session list is now a RB tree of winlink structures. This disassociates the\n  window index from the array size (allowing arbitrary indexes) which still\n  allowing windows to have multiple indexes.\n\n25 October 2007\n\n* (nicm) has-session command: checks if session exists.\n\n24 October 2007\n\n* (nicm) Support for \\e6n to request cursor position. resize(1) now works.\n* (nicm) Support for \\e7, \\e8 save/restore cursor and attribute sequences.\n  Currently don't save mode (probably should). Also change some cases where\n  out-of-bound values are ignored to limit them to within range (there are\n  others than need to be checked too).\n\n23 October 2007\n\n* (nicm) Lift limit on session name passed with -s.\n* (nicm) Show size in session/window lists.\n* (nicm) Pass tty up to server when client identifies and add a list-clients\n  command to list connected clients.\n\n20 October 2007\n\n* (nicm) Add default-command option and change default to be $SHELL rather than\n  $SHELL -l. Also try to read shell from passwd db if $SHELL isn't present.\n\n19 October 2007\n\n* (nicm) -n on new-session is now -s, and -n is now the initial window name.\n  This was documented but not implemented :-/.\n* (nicm) kill-window command, bound to & by default (because it should be hard\n  to hit accidentally).\n* (nicm) bell-style option with three choices: \"none\" completely ignore bell;\n  \"any\" pass through a bell in any window to current; \"current\" ignore bells\n  except in current window. This applies only to the bell terminal signal,\n  the status bar always reflects any bells.\n* (nicm) Refresh session command.\n\n12 October 2007\n\n* (nicm) Add a warning if $TMUX exists on new/attach.\n* (nicm) send-prefix command. Bound to C-b by default.\n* (nicm) set status, status-fg, status-bg commands. fg and bg are as a number\n  from 0 to 8 or a string (\"red\", \"blue\", etc). status may be 1/0, on/off,\n  yes/no.\n* (nicm) Make status line mark window in yellow on bell.\n\n04 October 2007\n\n* (nicm) -d option to attach to detach all other clients on the same session.\n* (nicm) Partial resizing support. Still buggy. A C-b S and back sometimes fixes\n  it when it goes wonky.\n* (mxey) Added my tmux start script as an example (examples/start-tmux.sh).\n* (mxey) New sessions can now be given a command for their first window.\n* (mxey) Fixed usage statement for new-window.\n* (nicm) attach-session (can't believe I forgot it until now!) and list-windows\n  commands.\n* (nicm) rename-window and select-window commands.\n* (nicm) set-option command (alias set): \"tmux set-option prefix ^A\".\n* (nicm) Key binding and unbinding is back.\n\n03 October 2007\n\n* (nicm) {new,next,last,previous}-window.\n* (nicm) Rewrite command handling so commands are much more generic and the\n  same commands are used for command line and keys (although most will probably\n  need to check how they are called). Currently incomplete (only new/detach/ls\n  implemented). Change: -s is now passed before command again!\n* (nicm) String number arguments. So you can do: tmux bind ^Q create \"blah\".\n* (nicm) Key binding. tmux bind key command [argument] and tmux unbind key.\n  Key names are in a table in key-string.c, plus A is A, ^A is ctrl-A.\n  Possible commands are in cmd.c (look at cmd_bind_table).\n* (nicm) Move command parsing into the client. Also rename some messages and\n  tidy up a few bits. Lots more tidying up needed :-/.\n\n02 October 2007\n\n* (nicm) Redraw client status lines on rename.\n* (nicm) Error on ambiguous command.\n\n01 October 2007\n\n* (nicm) Restore window title handling.\n* (nicm) Simple uncustomisable status line with window list.\n\n30 September 2007\n\n* (nicm) Window info command for debugging, C-b I.\n\n29 September 2007\n\n* (nicm) Deleting/inserting lines should follow scrolling region. Fix.\n* (nicm) Allow creation of detached sessions: \"tmux new-session -d\".\n* (nicm) Permit error messages to be passed back for transient clients like\n  rename. Also make rename -i work.\n* (nicm) Pass through bell in any window to current.\n\n28 September 2007\n\n* (nicm) Major rewrite of input parser:\n\t- Lose the old weirdness in favour of a state machine.\n\t- Merge in parsing from screen.c.\n\t- Split key parsing off into a separate file.\n  This is step one towards hopefully allowing a status line. It requires\n  that we output data as if the terminal had one line less than it really does -\n  a serious problem when it comes to things like scrolling. This change\n  consolidates all the range checking and limiting together which should make\n  it easier.\n* (mxey) Added window renaming, like \"tmux rename [-s session] [-i index] name\"\n\n27 September 2007\n\n* Split \"tmux list\" into \"tmux list-sessions\" (ls) and \"list-windows\" (lsw).\n* New command session selection:\n\t- if name is specified, look for it and use it if it exists, otherwise\n\t  error\n\t- if no name specified, try the current session from $TMUX\n\t- if $TMUX doesn't exist, and there is only one session, use it,\n\t  otherwise error\n\n26 September 2007\n\n* Add command aliases, so \"ls\" is an alias for \"list\".\n* Rename some commands and alter syntax to take options after a la CVS. Also\n  change some flags. So:\n\n\ttmux -s/socket -nabc new\n\n  Becomes:\n\n\ttmux -S/socket new -sabc\n\n* Major tidy and split of client/server code.\n\n22 September 2007\n\n* Window list command (C-b W). Started by Maximilian Gass, finished by me.\n\n20 September 2007\n\n* Specify meta via environment variable (META).\n* Record last window and ^L key to switch to it. Largely from Maximilian Gass.\n* Reset ignored signals in child after forkpty, makes ^C work.\n* Wrap on next/previous. From Maximilian Gass.\n\n19 September 2007\n\n* Don't renumber windows on close.\n\n28 August 2007\n\n* Scrolling region (\\e[r) support.\n\n27 August 2007\n\n* Change screen.c to work more logically and hopefully fix heap corruption.\n\n09 July 2007\n\n* Initial import to CVS. Basic functions are working, albeit with a couple of\n  showstopper memory bugs and many missing features. Detaching, reattaching,\n  creating new sessions, listing sessions work acceptably for using with shells.\n  Simple curses programs (top, systat, tetris) and more complicated ones (mutt,\n  emacs) that don't require scrolling regions (ESC[r) mostly work fine\n  (including mutt, emacs). No status bar yet and no key remapping or other\n  customisation.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 0.9384765625,
          "content": "THIS IS FOR INFORMATION ONLY, CODE IS UNDER THE LICENCE AT THE TOP OF ITS FILE.\n\nThe README, CHANGES, FAQ and TODO files are licensed under the ISC license. All\nother files have a license and copyright notice at their start, typically:\n\nCopyright (c) <author>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\nOUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 4.9970703125,
          "content": "# Obvious program stuff.\nbin_PROGRAMS = tmux\nCLEANFILES = tmux.1.mdoc tmux.1.man cmd-parse.c\n\n# Distribution tarball options.\nEXTRA_DIST = \\\n\tCHANGES README README.ja COPYING example_tmux.conf \\\n\tosdep-*.c mdoc2man.awk tmux.1\ndist_EXTRA_tmux_SOURCES = compat/*.[ch]\n\n# Preprocessor flags.\nAM_CPPFLAGS += @XOPEN_DEFINES@ \\\n\t-DTMUX_VERSION='\"@VERSION@\"' \\\n\t-DTMUX_CONF='\"$(sysconfdir)/tmux.conf:~/.tmux.conf:$$XDG_CONFIG_HOME/tmux/tmux.conf:~/.config/tmux/tmux.conf\"' \\\n\t-DTMUX_LOCK_CMD='\"@DEFAULT_LOCK_CMD@\"' \\\n\t-DTMUX_TERM='\"@DEFAULT_TERM@\"'\n\n# Additional object files.\nLDADD = $(LIBOBJS)\n\n# Set flags for gcc.\nif IS_GCC\nAM_CFLAGS += -std=gnu99 -O2\nif IS_DEBUG\nAM_CFLAGS += -g\nAM_CFLAGS += -Wno-long-long -Wall -W -Wformat=2\nAM_CFLAGS += -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations\nAM_CFLAGS += -Wwrite-strings -Wshadow -Wpointer-arith -Wsign-compare\nAM_CFLAGS += -Wundef -Wbad-function-cast -Winline -Wcast-align\nAM_CFLAGS += -Wdeclaration-after-statement -Wno-pointer-sign -Wno-attributes\nAM_CFLAGS += -Wno-unused-result -Wno-format-y2k\nif IS_DARWIN\nAM_CFLAGS += -Wno-deprecated-declarations -Wno-cast-align -Wno-macro-redefined\nendif\nAM_CPPFLAGS += -DDEBUG\nendif\nAM_CPPFLAGS += -iquote.\nendif\n\n# Set flags for Solaris.\nif IS_SUNOS\nif IS_GCC\nAM_CPPFLAGS += -D_XPG6\nelse\nAM_CPPFLAGS += -D_XPG4_2\nendif\nendif\n\n# Set flags for Sun CC.\nif IS_SUNCC\nAM_CFLAGS += -erroff=E_EMPTY_DECLARATION\nendif\n\n# Set _LINUX_SOURCE_COMPAT for AIX for malloc(0).\nif IS_AIX\nAM_CPPFLAGS += -D_LINUX_SOURCE_COMPAT=1\nendif\n\n# Set flags for NetBSD.\nif IS_NETBSD\nAM_CPPFLAGS += -D_OPENBSD_SOURCE\nendif\n\n# Set flags for Haiku.\nif IS_HAIKU\nAM_CPPFLAGS += -D_BSD_SOURCE\nendif\n\n# Set flags for Cygwin.\nif IS_CYGWIN\nAM_CPPFLAGS += -DTMUX_SOCK_PERM=0\nendif\n\n# List of sources.\ndist_tmux_SOURCES = \\\n\talerts.c \\\n\targuments.c \\\n\tattributes.c \\\n\tcfg.c \\\n\tclient.c \\\n\tcmd-attach-session.c \\\n\tcmd-bind-key.c \\\n\tcmd-break-pane.c \\\n\tcmd-capture-pane.c \\\n\tcmd-choose-tree.c \\\n\tcmd-command-prompt.c \\\n\tcmd-confirm-before.c \\\n\tcmd-copy-mode.c \\\n\tcmd-detach-client.c \\\n\tcmd-display-menu.c \\\n\tcmd-display-message.c \\\n\tcmd-display-panes.c \\\n\tcmd-find-window.c \\\n\tcmd-find.c \\\n\tcmd-if-shell.c \\\n\tcmd-join-pane.c \\\n\tcmd-kill-pane.c \\\n\tcmd-kill-server.c \\\n\tcmd-kill-session.c \\\n\tcmd-kill-window.c \\\n\tcmd-list-buffers.c \\\n\tcmd-list-clients.c \\\n\tcmd-list-keys.c \\\n\tcmd-list-panes.c \\\n\tcmd-list-sessions.c \\\n\tcmd-list-windows.c \\\n\tcmd-load-buffer.c \\\n\tcmd-lock-server.c \\\n\tcmd-move-window.c \\\n\tcmd-new-session.c \\\n\tcmd-new-window.c \\\n\tcmd-parse.y \\\n\tcmd-paste-buffer.c \\\n\tcmd-pipe-pane.c \\\n\tcmd-queue.c \\\n\tcmd-refresh-client.c \\\n\tcmd-rename-session.c \\\n\tcmd-rename-window.c \\\n\tcmd-resize-pane.c \\\n\tcmd-resize-window.c \\\n\tcmd-respawn-pane.c \\\n\tcmd-respawn-window.c \\\n\tcmd-rotate-window.c \\\n\tcmd-run-shell.c \\\n\tcmd-save-buffer.c \\\n\tcmd-select-layout.c \\\n\tcmd-select-pane.c \\\n\tcmd-select-window.c \\\n\tcmd-send-keys.c \\\n\tcmd-server-access.c \\\n\tcmd-set-buffer.c \\\n\tcmd-set-environment.c \\\n\tcmd-set-option.c \\\n\tcmd-show-environment.c \\\n\tcmd-show-messages.c \\\n\tcmd-show-options.c \\\n\tcmd-show-prompt-history.c \\\n\tcmd-source-file.c \\\n\tcmd-split-window.c \\\n\tcmd-swap-pane.c \\\n\tcmd-swap-window.c \\\n\tcmd-switch-client.c \\\n\tcmd-unbind-key.c \\\n\tcmd-wait-for.c \\\n\tcmd.c \\\n\tcolour.c \\\n\tcompat.h \\\n\tcontrol-notify.c \\\n\tcontrol.c \\\n\tenviron.c \\\n\tfile.c \\\n\tformat.c \\\n\tformat-draw.c \\\n\tgrid-reader.c \\\n\tgrid-view.c \\\n\tgrid.c \\\n\thyperlinks.c \\\n\tinput-keys.c \\\n\tinput.c \\\n\tjob.c \\\n\tkey-bindings.c \\\n\tkey-string.c \\\n\tlayout-custom.c \\\n\tlayout-set.c \\\n\tlayout.c \\\n\tlog.c \\\n\tmenu.c \\\n\tmode-tree.c \\\n\tnames.c \\\n\tnotify.c \\\n\toptions-table.c \\\n\toptions.c \\\n\tpaste.c \\\n\tpopup.c \\\n\tproc.c \\\n\tregsub.c \\\n\tresize.c \\\n\tscreen-redraw.c \\\n\tscreen-write.c \\\n\tscreen.c \\\n\tserver-acl.c \\\n\tserver-client.c \\\n\tserver-fn.c \\\n\tserver.c \\\n\tsession.c \\\n\tspawn.c \\\n\tstatus.c \\\n\tstyle.c \\\n\ttmux.c \\\n\ttmux.h \\\n\ttmux-protocol.h \\\n\ttty-acs.c \\\n\ttty-features.c \\\n\ttty-keys.c \\\n\ttty-term.c \\\n\ttty.c \\\n\tutf8-combined.c \\\n\tutf8.c \\\n\twindow-buffer.c \\\n\twindow-client.c \\\n\twindow-clock.c \\\n\twindow-copy.c \\\n\twindow-customize.c \\\n\twindow-tree.c \\\n\twindow.c \\\n\txmalloc.c \\\n\txmalloc.h\nnodist_tmux_SOURCES = osdep-@PLATFORM@.c\n\n# Add compat file for forkpty.\nif NEED_FORKPTY\nnodist_tmux_SOURCES += compat/forkpty-@PLATFORM@.c\nendif\n\n# Add compat file for systemd.\nif HAVE_SYSTEMD\nnodist_tmux_SOURCES += compat/systemd.c\nendif\n\n# Add compat file for utf8proc.\nif HAVE_UTF8PROC\nnodist_tmux_SOURCES += compat/utf8proc.c\nendif\n\n# Enable sixel support.\nif ENABLE_SIXEL\ndist_tmux_SOURCES += image.c image-sixel.c\nendif\n\nif NEED_FUZZING\ncheck_PROGRAMS = fuzz/input-fuzzer\nfuzz_input_fuzzer_LDFLAGS = $(FUZZING_LIBS)\nfuzz_input_fuzzer_LDADD = $(LDADD) $(tmux_OBJECTS)\nendif\n\n# Install tmux.1 in the right format.\ninstall-exec-hook:\n\tif test x@MANFORMAT@ = xmdoc; then \\\n\t\tsed -e \"s|@SYSCONFDIR@|$(sysconfdir)|g\" $(srcdir)/tmux.1 \\\n\t\t\t>$(srcdir)/tmux.1.mdoc; \\\n\telse \\\n\t\tsed -e \"s|@SYSCONFDIR@|$(sysconfdir)|g\" $(srcdir)/tmux.1| \\\n\t\t\t$(AWK) -f $(srcdir)/mdoc2man.awk >$(srcdir)/tmux.1.man; \\\n\tfi\n\t$(mkdir_p) $(DESTDIR)$(mandir)/man1\n\t$(INSTALL_DATA) $(srcdir)/tmux.1.@MANFORMAT@ \\\n\t\t$(DESTDIR)$(mandir)/man1/tmux.1\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.162109375,
          "content": "Welcome to tmux!\n\ntmux is a terminal multiplexer: it enables a number of terminals to be created,\naccessed, and controlled from a single screen. tmux may be detached from a\nscreen and continue running in the background, then later reattached.\n\nThis release runs on OpenBSD, FreeBSD, NetBSD, Linux, macOS and Solaris.\n\n* Dependencies\n\ntmux depends on libevent 2.x, available from:\n\n\thttps://github.com/libevent/libevent/releases/latest\n\nIt also depends on ncurses, available from:\n\n\thttps://invisible-mirror.net/archives/ncurses/\n\nTo build tmux, a C compiler (for example gcc or clang), make, pkg-config and a\nsuitable yacc (yacc or bison) are needed.\n\n* Installation\n\nTo build and install tmux from a release tarball, use:\n\n\t$ ./configure && make\n\t$ sudo make install\n\ntmux can use the utempter library to update utmp(5), if it is installed - run\nconfigure with --enable-utempter to enable this.\n\nTo get and build the latest from version control - note that this requires\nautoconf, automake and pkg-config:\n\n\t$ git clone https://github.com/tmux/tmux.git\n\t$ cd tmux\n\t$ sh autogen.sh\n\t$ ./configure && make\n\t$ sudo make install\n\n* Contributing\n\nBug reports, feature suggestions and especially code contributions are most\nwelcome. Please send by email to:\n\n\ttmux-users@googlegroups.com\n\nOr open a GitHub issue or pull request.\n\n* Documentation\n\nFor documentation on using tmux, see the tmux.1 manpage. View it from the\nsource tree with:\n\n\t$ nroff -mdoc tmux.1|less\n\nA small example configuration is in example_tmux.conf.\n\nOther documentation is available in the wiki:\n\n\thttps://github.com/tmux/tmux/wiki\n\nAlso see the tmux FAQ at:\n\n\thttps://github.com/tmux/tmux/wiki/FAQ\n\nA bash(1) completion file is at:\n\n\thttps://github.com/imomaliev/tmux-bash-completion\n\nFor debugging, run tmux with -v and -vv to generate server and client log files\nin the current directory.\n\n* Support\n\nThe tmux mailing list for general discussion and bug reports is:\n\n\thttps://groups.google.com/forum/#!forum/tmux-users\n\nSubscribe by sending an email to:\n\n\ttmux-users+subscribe@googlegroups.com\n\n* License\n\nThis file and the CHANGES files are licensed under the ISC license. All other\nfiles have a license and copyright notice at their start.\n"
        },
        {
          "name": "README.ja",
          "type": "blob",
          "size": 2.712890625,
          "content": "tmuxへようこそ!\n\ntmuxはターミナルマルチプレクサーです。複数のターミナルを一つのスクリーン内に作成し、操作することができます。\nバックグラウンドで処理を実行中に一度スクリーンから離れて後から復帰することも可能です。\n\nOpenBSD、FreeBSD、NetBSD、Linux、macOS、Solarisで実行できます。\n\ntmuxはlibevent 2.x.に依存します。 下記からダウンロードしてください。\n\n\thttp://libevent.org\n\nまた、ncursesも必要です。こちらからどうぞ。\n\n\thttp://invisible-island.net/ncurses/\n\ntarballでのtmuxのビルドとインストール方法。\n\n\t$ ./configure && make\n\t$ sudo make install\n\ntmuxはutmp(5)をアップデートするためにutempterを使うことができます。もしインストール済みであればオプション「--enable-utempter」をつけて実行してください。\n\nリポジトリから最新バージョンを手に入れるためには下記を実行。\n\n\t$ git clone https://github.com/tmux/tmux.git\n\t$ cd tmux\n\t$ sh autogen.sh\n\t$ ./configure && make\n\n(ビルドのためにはlibevent、ncurses libraries、headersに加えて、C compiler、make、autoconf、automake、pkg-configが必要です。)\n\n詳しい情報はhttp://git-scm.comをご覧ください。修正はメール<tmux-users@googlegroups.com>宛、もしくはhttps://github.com/tmux/tmux/issuesにて受け付けています。\n\ntmuxのドキュメントについてはtmux.1マニュアルをご覧ください。こちらのコマンドで参照可能です。\n\n\t$ nroff -mdoc tmux.1|less\n\nサンプル設定は本リポジトリのexample_tmux.confに\nまた、bash-completionファイルは下記にあります。\n\n\thttps://github.com/imomaliev/tmux-bash-completion\n\n「-v」や「-vv」を指定することでデバッグモードでの起動が可能です。カレントディレクトリにサーバーやクライアントのログファイルが生成されます。\n\n議論やバグレポート用のメーリングリストにはこちらから参加可能です。\n\n\thttps://groups.google.com/forum/#!forum/tmux-users\n\ngitコミットについての連絡先\n\n\thttps://groups.google.com/forum/#!forum/tmux-git\n\n購読は<tmux-users+subscribe@googlegroups.com>までメールをお願いします。\n\nバグレポートや機能追加(特にコードへの貢献)は大歓迎です。こちらにご連絡ください。\n\n\ttmux-users@googlegroups.com\n\n本ファイル、CHANGES、 FAQ、SYNCINGそしてTODOはISC licenseで保護されています。\nその他のファイルのライセンスや著作権については、ファイルの上部に明記されています。\n\n-- Nicholas Marriott <nicholas.marriott@gmail.com>\n"
        },
        {
          "name": "SYNCING",
          "type": "blob",
          "size": 5.5478515625,
          "content": "Preamble\n========\n\nTmux portable relies on  repositories \"tmux\" and \"tmux-openbsd\".\nHere's a description of them:\n\n* \"tmux\" is the portable version, the one which contains code for other\n  operating systems, and autotools, etc., which isn't found or needed in the\n  OpenBSD base system.\n\n* \"tmux-openbsd\" is the version of tmux in OpenBSD base system which provides\n  the basis of the portable tmux version.\n\nNote:  The \"tmux-openbsd\" repository is actually handled by \"git cvsimport\"\nrunning at 15 minute intervals, so a commit made to OpenBSD's tmux CVS\nrepository will take at least that long to appear in this git repository.\n(It might take longer, depending on the CVS mirror used to import the\nOpenBSD code).\n\nIf you've never used git before, git tracks meta-data about the committer\nand the author, as part of a commit, hence:\n\n% git config [--global] user.name \"Your name\"\n% git config [--global] user.email \"you@yourdomain.com\"\n\nNote that, if you already have this in the global ~/.gitconfig option, then\nthis will be used.  Setting this per-repository would involve not using the\n\"--global\" flag above.   If you wish to use the same credentials always,\npass the \"--global\" option, as shown.\n\nThis is a one-off operation once the repository has been cloned, assuming\nthis information has ever been set before.\n\nCloning repositories\n====================\n\nThis involves having both tmux and tmux-openbsd cloned, as in:\n\n% cd /some/where/useful\n% git clone https://github.com/tmux/tmux.git\n% git clone https://github.com/ThomasAdam/tmux-openbsd.git\n\nNote that you do not need additional checkouts to manage the sync -- an\nexisting clone of either repositories will suffice.  So if you already have\nthese checkouts existing, skip that.\n\nAdding in git-remotes\n=====================\n\nBecause the portable \"tmux\" git repository and the \"tmux-openbsd\"\nrepository do not inherently share any history between each other, the\nhistory has been faked between them.  This \"faking of history\" is something\nwhich has to be told to git for the purposes of comparing the \"tmux\" and\n\"tmux-openbsd\" repositories for syncing.  To do this, we must reference the\nclone of the \"tmux-openbsd\" repository from the \"tmux\" repository, as\nshown by the following command:\n\n% cd /path/to/tmux\n% git remote add obsd-tmux file:///path/to/tmux-openbsd\n\nSo that now, the remote \"obsd-tmux\" can be used to reference branches and\ncommits from the \"tmux-openbsd\" repository, but from the context of the\nportable \"tmux\" repository, which makes sense because it's the \"tmux\"\nrepository which will have the updates applied to them.\n\nFetching updates\n================\n\nTo ensure the latest commits from \"tmux-openbsd\" can be found from within\n\"tmux\", we have to ensure the \"master\" branch from \"tmux-openbsd\" is\nup-to-date first, and then reference that update in \"tmux\", as in:\n\n% cd /path/to/tmux-openbsd\n% git checkout master\n% git pull\n\nThen back in \"tmux\":\n\n% cd /path/to/tmux\n% git fetch obsd-tmux\n\nCreating the necessary branches\n===============================\n\nNow that \"tmux\" can see commits and branches from \"tmux-openbsd\" by way\nof the remote name \"obsd-tmux\", we can now create the master branch from\n\"tmux-openbsd\" in the \"tmux\" repository:\n\n% git checkout -b obsd-master obsd-tmux/master\n\nAdding in the fake history points\n=================================\n\nTo tie both the \"master\" branch from \"tmux\" and the \"obsd-master\"\nbranch from \"tmux-openbsd\" together, the fake history points added to the\n\"tmux\" repository need to be added.  To do this, we must add an\nadditional refspec line, as in:\n\n% cd /path/to/tmux\n% git config --add remote.origin.fetch '+refs/replace/*:refs/replace/*'\n% git fetch origin\n\nPerforming the Sync\n===================\n\nMake sure the \"master\" branch is checked out:\n\n% git checkout master\n\nThe following will show commits on OpenBSD not yet synched with \"tmux\":\n\n% git log master..obsd-master\n\nFrom there, merge the result in, fixing up any conflicts which might arise.\n\n% git merge obsd-master\n\nThen ensure things look correct by BUILDING the result of that sync:\n\n% make clean && ./autogen.sh && ./configure && make\n\nCompare the git merge result with what's on origin/master -- that is, check\nwhich commits you're about to push:\n\n% git log origin/master..master\n\nAnd if happy:\n\n% git push origin master\n\nKeeping an eye on libutil in OpenBSD\n====================================\n\nA lot of the compat/ code in tmux comes from libutil, especially imsg.\nSometimes the API can change, etc., which might cause interesting problems\ntrying to run the portable version of tmux.  It's worth checking\nperiodically for any changes to libutil in OpenBSD and syncing those files\nto compat/ as and when appropriate.\n\nRelease tmux for next version\n=============================\n\n1. Update and commit README and CHANGES.  The former should be checked for\n   anything outdated and updated with a list of things that might break\n   upgrades and the latter should mention all the major changes since\n   the last version.\n\n2. Make sure configure.ac has the new version number.\n\n3. Tag with:\n\n   % git tag -a 2.X\n\n   Where \"2.X\" is the next version.\n\n   Push the tag out with:\n\n   % git push --tags\n\n4. Build the tarball with 'make dist'.\n\n5. Check the tarball.  If it's good, go here to select the tag just pushed:\n\n   https://github.com/tmux/tmux/tags\n\n   Click the \"Add release notes\", upload the tarball and add a link in the\n   description field to the CHANGES file.\n\n6. Clone the tmux.github.io repository, and change the RELEASE version in the\n   Makefile.  Commit it, and run 'make' to replace %%RELEASE%%.  Push the\n   result out.\n\n7. Change version back to master in configure.ac.\n"
        },
        {
          "name": "alerts.c",
          "type": "blob",
          "size": 7.7412109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\nstatic int\talerts_fired;\n\nstatic void\talerts_timer(int, short, void *);\nstatic int\talerts_enabled(struct window *, int);\nstatic void\talerts_callback(int, short, void *);\nstatic void\talerts_reset(struct window *);\n\nstatic int\talerts_action_applies(struct winlink *, const char *);\nstatic int\talerts_check_all(struct window *);\nstatic int\talerts_check_bell(struct window *);\nstatic int\talerts_check_activity(struct window *);\nstatic int\talerts_check_silence(struct window *);\nstatic void\talerts_set_message(struct winlink *, const char *,\n\t\t    const char *);\n\nstatic TAILQ_HEAD(, window) alerts_list = TAILQ_HEAD_INITIALIZER(alerts_list);\n\nstatic void\nalerts_timer(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window\t*w = arg;\n\n\tlog_debug(\"@%u alerts timer expired\", w->id);\n\talerts_queue(w, WINDOW_SILENCE);\n}\n\nstatic void\nalerts_callback(__unused int fd, __unused short events, __unused void *arg)\n{\n\tstruct window\t*w, *w1;\n\tint\t\t alerts;\n\n\tTAILQ_FOREACH_SAFE(w, &alerts_list, alerts_entry, w1) {\n\t\talerts = alerts_check_all(w);\n\t\tlog_debug(\"@%u alerts check, alerts %#x\", w->id, alerts);\n\n\t\tw->alerts_queued = 0;\n\t\tTAILQ_REMOVE(&alerts_list, w, alerts_entry);\n\n\t\tw->flags &= ~WINDOW_ALERTFLAGS;\n\t\twindow_remove_ref(w, __func__);\n\t}\n\talerts_fired = 0;\n}\n\nstatic int\nalerts_action_applies(struct winlink *wl, const char *name)\n{\n\tint\taction;\n\n\t/*\n\t * {bell,activity,silence}-action determines when to alert: none means\n\t * nothing happens, current means only do something for the current\n\t * window and other means only for windows other than the current.\n\t */\n\n\taction = options_get_number(wl->session->options, name);\n\tif (action == ALERT_ANY)\n\t\treturn (1);\n\tif (action == ALERT_CURRENT)\n\t\treturn (wl == wl->session->curw);\n\tif (action == ALERT_OTHER)\n\t\treturn (wl != wl->session->curw);\n\treturn (0);\n}\n\nstatic int\nalerts_check_all(struct window *w)\n{\n\tint\talerts;\n\n\talerts\t= alerts_check_bell(w);\n\talerts |= alerts_check_activity(w);\n\talerts |= alerts_check_silence(w);\n\treturn (alerts);\n}\n\nvoid\nalerts_check_session(struct session *s)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, &s->windows)\n\t\talerts_check_all(wl->window);\n}\n\nstatic int\nalerts_enabled(struct window *w, int flags)\n{\n\tif (flags & WINDOW_BELL) {\n\t\tif (options_get_number(w->options, \"monitor-bell\"))\n\t\t\treturn (1);\n\t}\n\tif (flags & WINDOW_ACTIVITY) {\n\t\tif (options_get_number(w->options, \"monitor-activity\"))\n\t\t\treturn (1);\n\t}\n\tif (flags & WINDOW_SILENCE) {\n\t\tif (options_get_number(w->options, \"monitor-silence\") != 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nalerts_reset_all(void)\n{\n\tstruct window\t*w;\n\n\tRB_FOREACH(w, windows, &windows)\n\t\talerts_reset(w);\n}\n\nstatic void\nalerts_reset(struct window *w)\n{\n\tstruct timeval\ttv;\n\n\tif (!event_initialized(&w->alerts_timer))\n\t\tevtimer_set(&w->alerts_timer, alerts_timer, w);\n\n\tw->flags &= ~WINDOW_SILENCE;\n\tevent_del(&w->alerts_timer);\n\n\ttimerclear(&tv);\n\ttv.tv_sec = options_get_number(w->options, \"monitor-silence\");\n\n\tlog_debug(\"@%u alerts timer reset %u\", w->id, (u_int)tv.tv_sec);\n\tif (tv.tv_sec != 0)\n\t\tevent_add(&w->alerts_timer, &tv);\n}\n\nvoid\nalerts_queue(struct window *w, int flags)\n{\n\talerts_reset(w);\n\n\tif ((w->flags & flags) != flags) {\n\t\tw->flags |= flags;\n\t\tlog_debug(\"@%u alerts flags added %#x\", w->id, flags);\n\t}\n\n\tif (alerts_enabled(w, flags)) {\n\t\tif (!w->alerts_queued) {\n\t\t\tw->alerts_queued = 1;\n\t\t\tTAILQ_INSERT_TAIL(&alerts_list, w, alerts_entry);\n\t\t\twindow_add_ref(w, __func__);\n\t\t}\n\n\t\tif (!alerts_fired) {\n\t\t\tlog_debug(\"alerts check queued (by @%u)\", w->id);\n\t\t\tevent_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);\n\t\t\talerts_fired = 1;\n\t\t}\n\t}\n}\n\nstatic int\nalerts_check_bell(struct window *w)\n{\n\tstruct winlink\t*wl;\n\tstruct session\t*s;\n\n\tif (~w->flags & WINDOW_BELL)\n\t\treturn (0);\n\tif (!options_get_number(w->options, \"monitor-bell\"))\n\t\treturn (0);\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry)\n\t\twl->session->flags &= ~SESSION_ALERTED;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\t/*\n\t\t * Bells are allowed even if there is an existing bell (so do\n\t\t * not check WINLINK_BELL).\n\t\t */\n\t\ts = wl->session;\n\t\tif (s->curw != wl || s->attached == 0) {\n\t\t\twl->flags |= WINLINK_BELL;\n\t\t\tserver_status_session(s);\n\t\t}\n\t\tif (!alerts_action_applies(wl, \"bell-action\"))\n\t\t\tcontinue;\n\t\tnotify_winlink(\"alert-bell\", wl);\n\n\t\tif (s->flags & SESSION_ALERTED)\n\t\t\tcontinue;\n\t\ts->flags |= SESSION_ALERTED;\n\n\t\talerts_set_message(wl, \"Bell\", \"visual-bell\");\n\t}\n\n\treturn (WINDOW_BELL);\n}\n\nstatic int\nalerts_check_activity(struct window *w)\n{\n\tstruct winlink\t*wl;\n\tstruct session\t*s;\n\n\tif (~w->flags & WINDOW_ACTIVITY)\n\t\treturn (0);\n\tif (!options_get_number(w->options, \"monitor-activity\"))\n\t\treturn (0);\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry)\n\t\twl->session->flags &= ~SESSION_ALERTED;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->flags & WINLINK_ACTIVITY)\n\t\t\tcontinue;\n\t\ts = wl->session;\n\t\tif (s->curw != wl || s->attached == 0) {\n\t\t\twl->flags |= WINLINK_ACTIVITY;\n\t\t\tserver_status_session(s);\n\t\t}\n\t\tif (!alerts_action_applies(wl, \"activity-action\"))\n\t\t\tcontinue;\n\t\tnotify_winlink(\"alert-activity\", wl);\n\n\t\tif (s->flags & SESSION_ALERTED)\n\t\t\tcontinue;\n\t\ts->flags |= SESSION_ALERTED;\n\n\t\talerts_set_message(wl, \"Activity\", \"visual-activity\");\n\t}\n\n\treturn (WINDOW_ACTIVITY);\n}\n\nstatic int\nalerts_check_silence(struct window *w)\n{\n\tstruct winlink\t*wl;\n\tstruct session\t*s;\n\n\tif (~w->flags & WINDOW_SILENCE)\n\t\treturn (0);\n\tif (options_get_number(w->options, \"monitor-silence\") == 0)\n\t\treturn (0);\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry)\n\t\twl->session->flags &= ~SESSION_ALERTED;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->flags & WINLINK_SILENCE)\n\t\t\tcontinue;\n\t\ts = wl->session;\n\t\tif (s->curw != wl || s->attached == 0) {\n\t\t\twl->flags |= WINLINK_SILENCE;\n\t\t\tserver_status_session(s);\n\t\t}\n\t\tif (!alerts_action_applies(wl, \"silence-action\"))\n\t\t\tcontinue;\n\t\tnotify_winlink(\"alert-silence\", wl);\n\n\t\tif (s->flags & SESSION_ALERTED)\n\t\t\tcontinue;\n\t\ts->flags |= SESSION_ALERTED;\n\n\t\talerts_set_message(wl, \"Silence\", \"visual-silence\");\n\t}\n\n\treturn (WINDOW_SILENCE);\n}\n\nstatic void\nalerts_set_message(struct winlink *wl, const char *type, const char *option)\n{\n\tstruct client\t*c;\n\tint\t\t visual;\n\n\t/*\n\t * We have found an alert (bell, activity or silence), so we need to\n\t * pass it on to the user. For each client attached to this session,\n\t * decide whether a bell, message or both is needed.\n\t *\n\t * If visual-{bell,activity,silence} is on, then a message is\n\t * substituted for a bell; if it is off, a bell is sent as normal; both\n\t * mean both a bell and message is sent.\n\t */\n\n\tvisual = options_get_number(wl->session->options, option);\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != wl->session || c->flags & CLIENT_CONTROL)\n\t\t\tcontinue;\n\n\t\tif (visual == VISUAL_OFF || visual == VISUAL_BOTH)\n\t\t\ttty_putcode(&c->tty, TTYC_BEL);\n\t\tif (visual == VISUAL_OFF)\n\t\t\tcontinue;\n\t\tif (c->session->curw == wl) {\n\t\t\tstatus_message_set(c, -1, 1, 0, \"%s in current window\",\n\t\t\t    type);\n\t\t} else {\n\t\t\tstatus_message_set(c, -1, 1, 0, \"%s in window %d\", type,\n\t\t\t    wl->idx);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "arguments.c",
          "type": "blob",
          "size": 23.9521484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Manipulate command arguments.\n */\n\n/* List of argument values. */\nTAILQ_HEAD(args_values, args_value);\n\n/* Single arguments flag. */\nstruct args_entry {\n\tu_char\t\t\t flag;\n\tstruct args_values\t values;\n\tu_int\t\t\t count;\n\n\tint\t\t\t flags;\n#define ARGS_ENTRY_OPTIONAL_VALUE 0x1\n\n\tRB_ENTRY(args_entry)\t entry;\n};\n\n/* Parsed argument flags and values. */\nstruct args {\n\tstruct args_tree\t tree;\n\tu_int\t\t\t count;\n\tstruct args_value\t*values;\n};\n\n/* Prepared command state. */\nstruct args_command_state {\n\tstruct cmd_list\t\t*cmdlist;\n\tchar\t\t\t*cmd;\n\tstruct cmd_parse_input\t pi;\n};\n\nstatic struct args_entry\t*args_find(struct args *, u_char);\n\nstatic int\targs_cmp(struct args_entry *, struct args_entry *);\nRB_GENERATE_STATIC(args_tree, args_entry, entry, args_cmp);\n\n/* Arguments tree comparison function. */\nstatic int\nargs_cmp(struct args_entry *a1, struct args_entry *a2)\n{\n\treturn (a1->flag - a2->flag);\n}\n\n/* Find a flag in the arguments tree. */\nstatic struct args_entry *\nargs_find(struct args *args, u_char flag)\n{\n\tstruct args_entry\tentry;\n\n\tentry.flag = flag;\n\treturn (RB_FIND(args_tree, &args->tree, &entry));\n}\n\n/* Copy value. */\nstatic void\nargs_copy_value(struct args_value *to, struct args_value *from)\n{\n\tto->type = from->type;\n\tswitch (from->type) {\n\tcase ARGS_NONE:\n\t\tbreak;\n\tcase ARGS_COMMANDS:\n\t\tto->cmdlist = from->cmdlist;\n\t\tto->cmdlist->references++;\n\t\tbreak;\n\tcase ARGS_STRING:\n\t\tto->string = xstrdup(from->string);\n\t\tbreak;\n\t}\n}\n\n/* Type to string. */\nstatic const char *\nargs_type_to_string (enum args_type type)\n{\n\tswitch (type)\n\t{\n\tcase ARGS_NONE:\n\t\treturn \"NONE\";\n\tcase ARGS_STRING:\n\t\treturn \"STRING\";\n\tcase ARGS_COMMANDS:\n\t\treturn \"COMMANDS\";\n\t}\n\treturn \"INVALID\";\n}\n\n/* Get value as string. */\nstatic const char *\nargs_value_as_string(struct args_value *value)\n{\n\tswitch (value->type) {\n\tcase ARGS_NONE:\n\t\treturn (\"\");\n\tcase ARGS_COMMANDS:\n\t\tif (value->cached == NULL)\n\t\t\tvalue->cached = cmd_list_print(value->cmdlist, 0);\n\t\treturn (value->cached);\n\tcase ARGS_STRING:\n\t\treturn (value->string);\n\t}\n\tfatalx(\"unexpected argument type\");\n}\n\n/* Create an empty arguments set. */\nstruct args *\nargs_create(void)\n{\n\tstruct args\t *args;\n\n\targs = xcalloc(1, sizeof *args);\n\tRB_INIT(&args->tree);\n\treturn (args);\n}\n\n/* Parse a single flag. */\nstatic int\nargs_parse_flag_argument(struct args_value *values, u_int count, char **cause,\n    struct args *args, u_int *i, const char *string, int flag,\n    int optional_argument)\n{\n\tstruct args_value\t*argument, *new;\n\tconst char\t\t*s;\n\n\tnew = xcalloc(1, sizeof *new);\n\tif (*string != '\\0') {\n\t\tnew->type = ARGS_STRING;\n\t\tnew->string = xstrdup(string);\n\t\tgoto out;\n\t}\n\n\tif (*i == count)\n\t\targument = NULL;\n\telse {\n\t\targument = &values[*i];\n\t\tif (argument->type != ARGS_STRING) {\n\t\t\txasprintf(cause, \"-%c argument must be a string\", flag);\n\t\t\targs_free_value(new);\n\t\t\tfree(new);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tif (argument == NULL) {\n\t\targs_free_value(new);\n\t\tfree(new);\n\t\tif (optional_argument) {\n\t\t\tlog_debug(\"%s: -%c (optional)\", __func__, flag);\n\t\t\targs_set(args, flag, NULL, ARGS_ENTRY_OPTIONAL_VALUE);\n\t\t\treturn (0); /* either - or end */\n\t\t}\n\t\txasprintf(cause, \"-%c expects an argument\", flag);\n\t\treturn (-1);\n\t}\n\targs_copy_value(new, argument);\n\t(*i)++;\n\nout:\n\ts = args_value_as_string(new);\n\tlog_debug(\"%s: -%c = %s\", __func__, flag, s);\n\targs_set(args, flag, new, 0);\n\treturn (0);\n}\n\n/* Parse flags argument. */\nstatic int\nargs_parse_flags(const struct args_parse *parse, struct args_value *values,\n    u_int count, char **cause, struct args *args, u_int *i)\n{\n\tstruct args_value\t*value;\n\tu_char\t\t\t flag;\n\tconst char\t\t*found, *string;\n\tint\t\t\t optional_argument;\n\n\tvalue = &values[*i];\n\tif (value->type != ARGS_STRING)\n\t\treturn (1);\n\n\tstring = value->string;\n\tlog_debug(\"%s: next %s\", __func__, string);\n\tif (*string++ != '-' || *string == '\\0')\n\t\treturn (1);\n\t(*i)++;\n\tif (string[0] == '-' && string[1] == '\\0')\n\t\treturn (1);\n\n\tfor (;;) {\n\t\tflag = *string++;\n\t\tif (flag == '\\0')\n\t\t\treturn (0);\n\t\tif (flag == '?')\n\t\t\treturn (-1);\n\t\tif (!isalnum(flag)) {\n\t\t\txasprintf(cause, \"invalid flag -%c\", flag);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tfound = strchr(parse->template, flag);\n\t\tif (found == NULL) {\n\t\t\txasprintf(cause, \"unknown flag -%c\", flag);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (found[1] != ':') {\n\t\t\tlog_debug(\"%s: -%c\", __func__, flag);\n\t\t\targs_set(args, flag, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\t\toptional_argument = (found[2] == ':');\n\t\treturn (args_parse_flag_argument(values, count, cause, args, i,\n\t\t    string, flag, optional_argument));\n\t}\n}\n\n/* Parse arguments into a new argument set. */\nstruct args *\nargs_parse(const struct args_parse *parse, struct args_value *values,\n    u_int count, char **cause)\n{\n\tstruct args\t\t*args;\n\tu_int\t\t\t i;\n\tenum args_parse_type\t type;\n\tstruct args_value\t*value, *new;\n\tconst char\t\t*s;\n\tint\t\t\t stop;\n\n\tif (count == 0)\n\t\treturn (args_create());\n\n\targs = args_create();\n\tfor (i = 1; i < count; /* nothing */) {\n\t\tstop = args_parse_flags(parse, values, count, cause, args, &i);\n\t\tif (stop == -1) {\n\t\t\targs_free(args);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (stop == 1)\n\t\t\tbreak;\n\t}\n\tlog_debug(\"%s: flags end at %u of %u\", __func__, i, count);\n\tif (i != count) {\n\t\tfor (/* nothing */; i < count; i++) {\n\t\t\tvalue = &values[i];\n\n\t\t\ts = args_value_as_string(value);\n\t\t\tlog_debug(\"%s: %u = %s (type %s)\", __func__, i, s,\n\t\t\t    args_type_to_string (value->type));\n\n\t\t\tif (parse->cb != NULL) {\n\t\t\t\ttype = parse->cb(args, args->count, cause);\n\t\t\t\tif (type == ARGS_PARSE_INVALID) {\n\t\t\t\t\targs_free(args);\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = ARGS_PARSE_STRING;\n\n\t\t\targs->values = xrecallocarray(args->values,\n\t\t\t    args->count, args->count + 1, sizeof *args->values);\n\t\t\tnew = &args->values[args->count++];\n\n\t\t\tswitch (type) {\n\t\t\tcase ARGS_PARSE_INVALID:\n\t\t\t\tfatalx(\"unexpected argument type\");\n\t\t\tcase ARGS_PARSE_STRING:\n\t\t\t\tif (value->type != ARGS_STRING) {\n\t\t\t\t\txasprintf(cause,\n\t\t\t\t\t    \"argument %u must be \\\"string\\\"\",\n\t\t\t\t\t    args->count);\n\t\t\t\t\targs_free(args);\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\targs_copy_value(new, value);\n\t\t\t\tbreak;\n\t\t\tcase ARGS_PARSE_COMMANDS_OR_STRING:\n\t\t\t\targs_copy_value(new, value);\n\t\t\t\tbreak;\n\t\t\tcase ARGS_PARSE_COMMANDS:\n\t\t\t\tif (value->type != ARGS_COMMANDS) {\n\t\t\t\t\txasprintf(cause,\n\t\t\t\t\t    \"argument %u must be { commands }\",\n\t\t\t\t\t    args->count);\n\t\t\t\t\targs_free(args);\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\targs_copy_value(new, value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (parse->lower != -1 && args->count < (u_int)parse->lower) {\n\t\txasprintf(cause,\n\t\t    \"too few arguments (need at least %u)\",\n\t\t    parse->lower);\n\t\targs_free(args);\n\t\treturn (NULL);\n\t}\n\tif (parse->upper != -1 && args->count > (u_int)parse->upper) {\n\t\txasprintf(cause,\n\t\t    \"too many arguments (need at most %u)\",\n\t\t    parse->upper);\n\t\targs_free(args);\n\t\treturn (NULL);\n\t}\n\treturn (args);\n}\n\n/* Copy and expand a value. */\nstatic void\nargs_copy_copy_value(struct args_value *to, struct args_value *from, int argc,\n    char **argv)\n{\n\tchar\t*s, *expanded;\n\tint\t i;\n\n\tto->type = from->type;\n\tswitch (from->type) {\n\tcase ARGS_NONE:\n\t\tbreak;\n\tcase ARGS_STRING:\n\t\texpanded = xstrdup(from->string);\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\ts = cmd_template_replace(expanded, argv[i], i + 1);\n\t\t\tfree(expanded);\n\t\t\texpanded = s;\n\t\t}\n\t\tto->string = expanded;\n\t\tbreak;\n\tcase ARGS_COMMANDS:\n\t\tto->cmdlist = cmd_list_copy(from->cmdlist, argc, argv);\n\t\tbreak;\n\t}\n}\n\n/* Copy an arguments set. */\nstruct args *\nargs_copy(struct args *args, int argc, char **argv)\n{\n\tstruct args\t\t*new_args;\n\tstruct args_entry\t*entry;\n\tstruct args_value\t*value, *new_value;\n\tu_int\t\t\t i;\n\n\tcmd_log_argv(argc, argv, \"%s\", __func__);\n\n\tnew_args = args_create();\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\tif (TAILQ_EMPTY(&entry->values)) {\n\t\t\tfor (i = 0; i < entry->count; i++)\n\t\t\t\targs_set(new_args, entry->flag, NULL, 0);\n\t\t\tcontinue;\n\t\t}\n\t\tTAILQ_FOREACH(value, &entry->values, entry) {\n\t\t\tnew_value = xcalloc(1, sizeof *new_value);\n\t\t\targs_copy_copy_value(new_value, value, argc, argv);\n\t\t\targs_set(new_args, entry->flag, new_value, 0);\n\t\t}\n\t}\n\tif (args->count == 0)\n\t\treturn (new_args);\n\tnew_args->count = args->count;\n\tnew_args->values = xcalloc(args->count, sizeof *new_args->values);\n\tfor (i = 0; i < args->count; i++) {\n\t\tnew_value = &new_args->values[i];\n\t\targs_copy_copy_value(new_value, &args->values[i], argc, argv);\n\t}\n\treturn (new_args);\n}\n\n/* Free a value. */\nvoid\nargs_free_value(struct args_value *value)\n{\n\tswitch (value->type) {\n\tcase ARGS_NONE:\n\t\tbreak;\n\tcase ARGS_STRING:\n\t\tfree(value->string);\n\t\tbreak;\n\tcase ARGS_COMMANDS:\n\t\tcmd_list_free(value->cmdlist);\n\t\tbreak;\n\t}\n\tfree(value->cached);\n}\n\n/* Free values. */\nvoid\nargs_free_values(struct args_value *values, u_int count)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < count; i++)\n\t\targs_free_value(&values[i]);\n}\n\n/* Free an arguments set. */\nvoid\nargs_free(struct args *args)\n{\n\tstruct args_entry\t*entry;\n\tstruct args_entry\t*entry1;\n\tstruct args_value\t*value;\n\tstruct args_value\t*value1;\n\n\targs_free_values(args->values, args->count);\n\tfree(args->values);\n\n\tRB_FOREACH_SAFE(entry, args_tree, &args->tree, entry1) {\n\t\tRB_REMOVE(args_tree, &args->tree, entry);\n\t\tTAILQ_FOREACH_SAFE(value, &entry->values, entry, value1) {\n\t\t\tTAILQ_REMOVE(&entry->values, value, entry);\n\t\t\targs_free_value(value);\n\t\t\tfree(value);\n\t\t}\n\t\tfree(entry);\n\t}\n\n\tfree(args);\n}\n\n/* Convert arguments to vector. */\nvoid\nargs_to_vector(struct args *args, int *argc, char ***argv)\n{\n\tchar\t*s;\n\tu_int\t i;\n\n\t*argc = 0;\n\t*argv = NULL;\n\n\tfor (i = 0; i < args->count; i++) {\n\t\tswitch (args->values[i].type) {\n\t\tcase ARGS_NONE:\n\t\t\tbreak;\n\t\tcase ARGS_STRING:\n\t\t\tcmd_append_argv(argc, argv, args->values[i].string);\n\t\t\tbreak;\n\t\tcase ARGS_COMMANDS:\n\t\t\ts = cmd_list_print(args->values[i].cmdlist, 0);\n\t\t\tcmd_append_argv(argc, argv, s);\n\t\t\tfree(s);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Convert arguments from vector. */\nstruct args_value *\nargs_from_vector(int argc, char **argv)\n{\n\tstruct args_value\t*values;\n\tint\t\t\t i;\n\n\tvalues = xcalloc(argc, sizeof *values);\n\tfor (i = 0; i < argc; i++) {\n\t\tvalues[i].type = ARGS_STRING;\n\t\tvalues[i].string = xstrdup(argv[i]);\n\t}\n\treturn (values);\n}\n\n/* Add to string. */\nstatic void printflike(3, 4)\nargs_print_add(char **buf, size_t *len, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*s;\n\tsize_t\t slen;\n\n\tva_start(ap, fmt);\n\tslen = xvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\t*len += slen;\n\t*buf = xrealloc(*buf, *len);\n\n\tstrlcat(*buf, s, *len);\n\tfree(s);\n}\n\n/* Add value to string. */\nstatic void\nargs_print_add_value(char **buf, size_t *len, struct args_value *value)\n{\n\tchar\t*expanded = NULL;\n\n\tif (**buf != '\\0')\n\t\targs_print_add(buf, len, \" \");\n\n\tswitch (value->type) {\n\tcase ARGS_NONE:\n\t\tbreak;\n\tcase ARGS_COMMANDS:\n\t\texpanded = cmd_list_print(value->cmdlist, 0);\n\t\targs_print_add(buf, len, \"{ %s }\", expanded);\n\t\tbreak;\n\tcase ARGS_STRING:\n\t\texpanded = args_escape(value->string);\n\t\targs_print_add(buf, len, \"%s\", expanded);\n\t\tbreak;\n\t}\n\tfree(expanded);\n}\n\n/* Print a set of arguments. */\nchar *\nargs_print(struct args *args)\n{\n\tsize_t\t\t\t len;\n\tchar\t\t\t*buf;\n\tu_int\t\t\t i, j;\n\tstruct args_entry\t*entry;\n\tstruct args_entry\t*last = NULL;\n\tstruct args_value\t*value;\n\n\tlen = 1;\n\tbuf = xcalloc(1, len);\n\n\t/* Process the flags first. */\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\tif (entry->flags & ARGS_ENTRY_OPTIONAL_VALUE)\n\t\t\tcontinue;\n\t\tif (!TAILQ_EMPTY(&entry->values))\n\t\t\tcontinue;\n\n\t\tif (*buf == '\\0')\n\t\t\targs_print_add(&buf, &len, \"-\");\n\t\tfor (j = 0; j < entry->count; j++)\n\t\t\targs_print_add(&buf, &len, \"%c\", entry->flag);\n\t}\n\n\t/* Then the flags with arguments. */\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\tif (entry->flags & ARGS_ENTRY_OPTIONAL_VALUE) {\n\t\t\tif (*buf != '\\0')\n\t\t\t\targs_print_add(&buf, &len, \" -%c\", entry->flag);\n\t\t\telse\n\t\t\t\targs_print_add(&buf, &len, \"-%c\", entry->flag);\n\t\t\tlast = entry;\n\t\t\tcontinue;\n\t\t}\n\t\tif (TAILQ_EMPTY(&entry->values))\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(value, &entry->values, entry) {\n\t\t\tif (*buf != '\\0')\n\t\t\t\targs_print_add(&buf, &len, \" -%c\", entry->flag);\n\t\t\telse\n\t\t\t\targs_print_add(&buf, &len, \"-%c\", entry->flag);\n\t\t\targs_print_add_value(&buf, &len, value);\n\t\t}\n\t\tlast = entry;\n\t}\n\tif (last && (last->flags & ARGS_ENTRY_OPTIONAL_VALUE))\n\t\targs_print_add(&buf, &len, \" --\");\n\n\t/* And finally the argument vector. */\n\tfor (i = 0; i < args->count; i++)\n\t\targs_print_add_value(&buf, &len, &args->values[i]);\n\n\treturn (buf);\n}\n\n/* Escape an argument. */\nchar *\nargs_escape(const char *s)\n{\n\tstatic const char\t dquoted[] = \" #';${}%\";\n\tstatic const char\t squoted[] = \" \\\"\";\n\tchar\t\t\t*escaped, *result;\n\tint\t\t\t flags, quotes = 0;\n\n\tif (*s == '\\0') {\n\t\txasprintf(&result, \"''\");\n\t\treturn (result);\n\t}\n\tif (s[strcspn(s, dquoted)] != '\\0')\n\t\tquotes = '\"';\n\telse if (s[strcspn(s, squoted)] != '\\0')\n\t\tquotes = '\\'';\n\n\tif (s[0] != ' ' &&\n\t    s[1] == '\\0' &&\n\t    (quotes != 0 || s[0] == '~')) {\n\t\txasprintf(&escaped, \"\\\\%c\", s[0]);\n\t\treturn (escaped);\n\t}\n\n\tflags = VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL;\n\tif (quotes == '\"')\n\t\tflags |= VIS_DQ;\n\tutf8_stravis(&escaped, s, flags);\n\n\tif (quotes == '\\'')\n\t\txasprintf(&result, \"'%s'\", escaped);\n\telse if (quotes == '\"') {\n\t\tif (*escaped == '~')\n\t\t\txasprintf(&result, \"\\\"\\\\%s\\\"\", escaped);\n\t\telse\n\t\t\txasprintf(&result, \"\\\"%s\\\"\", escaped);\n\t} else {\n\t\tif (*escaped == '~')\n\t\t\txasprintf(&result, \"\\\\%s\", escaped);\n\t\telse\n\t\t\tresult = xstrdup(escaped);\n\t}\n\tfree(escaped);\n\treturn (result);\n}\n\n/* Return if an argument is present. */\nint\nargs_has(struct args *args, u_char flag)\n{\n\tstruct args_entry\t*entry;\n\n\tentry = args_find(args, flag);\n\tif (entry == NULL)\n\t\treturn (0);\n\treturn (entry->count);\n}\n\n/* Set argument value in the arguments tree. */\nvoid\nargs_set(struct args *args, u_char flag, struct args_value *value, int flags)\n{\n\tstruct args_entry\t*entry;\n\n\tentry = args_find(args, flag);\n\tif (entry == NULL) {\n\t\tentry = xcalloc(1, sizeof *entry);\n\t\tentry->flag = flag;\n\t\tentry->count = 1;\n\t\tentry->flags = flags;\n\t\tTAILQ_INIT(&entry->values);\n\t\tRB_INSERT(args_tree, &args->tree, entry);\n\t} else\n\t\tentry->count++;\n\tif (value != NULL && value->type != ARGS_NONE)\n\t\tTAILQ_INSERT_TAIL(&entry->values, value, entry);\n\telse\n\t\tfree(value);\n}\n\n/* Get argument value. Will be NULL if it isn't present. */\nconst char *\nargs_get(struct args *args, u_char flag)\n{\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, flag)) == NULL)\n\t\treturn (NULL);\n\tif (TAILQ_EMPTY(&entry->values))\n\t\treturn (NULL);\n\treturn (TAILQ_LAST(&entry->values, args_values)->string);\n}\n\n/* Get first argument. */\nu_char\nargs_first(struct args *args, struct args_entry **entry)\n{\n\t*entry = RB_MIN(args_tree, &args->tree);\n\tif (*entry == NULL)\n\t\treturn (0);\n\treturn ((*entry)->flag);\n}\n\n/* Get next argument. */\nu_char\nargs_next(struct args_entry **entry)\n{\n\t*entry = RB_NEXT(args_tree, &args->tree, *entry);\n\tif (*entry == NULL)\n\t\treturn (0);\n\treturn ((*entry)->flag);\n}\n\n/* Get argument count. */\nu_int\nargs_count(struct args *args)\n{\n\treturn (args->count);\n}\n\n/* Get argument values. */\nstruct args_value *\nargs_values(struct args *args)\n{\n\treturn (args->values);\n}\n\n/* Get argument value. */\nstruct args_value *\nargs_value(struct args *args, u_int idx)\n{\n\tif (idx >= args->count)\n\t\treturn (NULL);\n\treturn (&args->values[idx]);\n}\n\n/* Return argument as string. */\nconst char *\nargs_string(struct args *args, u_int idx)\n{\n\tif (idx >= args->count)\n\t\treturn (NULL);\n\treturn (args_value_as_string(&args->values[idx]));\n}\n\n/* Make a command now. */\nstruct cmd_list *\nargs_make_commands_now(struct cmd *self, struct cmdq_item *item, u_int idx,\n    int expand)\n{\n\tstruct args_command_state\t*state;\n\tchar\t\t\t\t*error;\n\tstruct cmd_list\t\t\t*cmdlist;\n\n\tstate = args_make_commands_prepare(self, item, idx, NULL, 0, expand);\n\tcmdlist = args_make_commands(state, 0, NULL, &error);\n\tif (cmdlist == NULL) {\n\t\tcmdq_error(item, \"%s\", error);\n\t\tfree(error);\n\t}\n\telse\n\t\tcmdlist->references++;\n\targs_make_commands_free(state);\n\treturn (cmdlist);\n}\n\n/* Save bits to make a command later. */\nstruct args_command_state *\nargs_make_commands_prepare(struct cmd *self, struct cmdq_item *item, u_int idx,\n    const char *default_command, int wait, int expand)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct args_value\t\t*value;\n\tstruct args_command_state\t*state;\n\tconst char\t\t\t*cmd;\n\tconst char\t\t\t*file;\n\n\tstate = xcalloc(1, sizeof *state);\n\n\tif (idx < args->count) {\n\t\tvalue = &args->values[idx];\n\t\tif (value->type == ARGS_COMMANDS) {\n\t\t\tstate->cmdlist = value->cmdlist;\n\t\t\tstate->cmdlist->references++;\n\t\t\treturn (state);\n\t\t}\n\t\tcmd = value->string;\n\t} else {\n\t\tif (default_command == NULL)\n\t\t\tfatalx(\"argument out of range\");\n\t\tcmd = default_command;\n\t}\n\n\n\tif (expand)\n\t\tstate->cmd = format_single_from_target(item, cmd);\n\telse\n\t\tstate->cmd = xstrdup(cmd);\n\tlog_debug(\"%s: %s\", __func__, state->cmd);\n\n\tif (wait)\n\t\tstate->pi.item = item;\n\tcmd_get_source(self, &file, &state->pi.line);\n\tif (file != NULL)\n\t\tstate->pi.file = xstrdup(file);\n\tstate->pi.c = tc;\n\tif (state->pi.c != NULL)\n\t\tstate->pi.c->references++;\n\tcmd_find_copy_state(&state->pi.fs, target);\n\n\treturn (state);\n}\n\n/* Return argument as command. */\nstruct cmd_list *\nargs_make_commands(struct args_command_state *state, int argc, char **argv,\n    char **error)\n{\n\tstruct cmd_parse_result\t*pr;\n\tchar\t\t\t*cmd, *new_cmd;\n\tint\t\t\t i;\n\n\tif (state->cmdlist != NULL) {\n\t\tif (argc == 0)\n\t\t\treturn (state->cmdlist);\n\t\treturn (cmd_list_copy(state->cmdlist, argc, argv));\n\t}\n\n\tcmd = xstrdup(state->cmd);\n\tlog_debug(\"%s: %s\", __func__, cmd);\n\tcmd_log_argv(argc, argv, __func__);\n\tfor (i = 0; i < argc; i++) {\n\t\tnew_cmd = cmd_template_replace(cmd, argv[i], i + 1);\n\t\tlog_debug(\"%s: %%%u %s: %s\", __func__, i + 1, argv[i], new_cmd);\n\t\tfree(cmd);\n\t\tcmd = new_cmd;\n\t}\n\tlog_debug(\"%s: %s\", __func__, cmd);\n\n\tpr = cmd_parse_from_string(cmd, &state->pi);\n\tfree(cmd);\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\t*error = pr->error;\n\t\treturn (NULL);\n\tcase CMD_PARSE_SUCCESS:\n\t\treturn (pr->cmdlist);\n\t}\n\tfatalx(\"invalid parse return state\");\n}\n\n/* Free commands state. */\nvoid\nargs_make_commands_free(struct args_command_state *state)\n{\n\tif (state->cmdlist != NULL)\n\t\tcmd_list_free(state->cmdlist);\n\tif (state->pi.c != NULL)\n\t\tserver_client_unref(state->pi.c);\n\tfree((void *)state->pi.file);\n\tfree(state->cmd);\n\tfree(state);\n}\n\n/* Get prepared command. */\nchar *\nargs_make_commands_get_command(struct args_command_state *state)\n{\n\tstruct cmd\t*first;\n\tint\t\t n;\n\tchar\t\t*s;\n\n\tif (state->cmdlist != NULL) {\n\t\tfirst = cmd_list_first(state->cmdlist);\n\t\tif (first == NULL)\n\t\t\treturn (xstrdup(\"\"));\n\t\treturn (xstrdup(cmd_get_entry(first)->name));\n\t}\n\tn = strcspn(state->cmd, \" ,\");\n\txasprintf(&s, \"%.*s\", n, state->cmd);\n\treturn (s);\n}\n\n/* Get first value in argument. */\nstruct args_value *\nargs_first_value(struct args *args, u_char flag)\n{\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, flag)) == NULL)\n\t\treturn (NULL);\n\treturn (TAILQ_FIRST(&entry->values));\n}\n\n/* Get next value in argument. */\nstruct args_value *\nargs_next_value(struct args_value *value)\n{\n\treturn (TAILQ_NEXT(value, entry));\n}\n\n/* Convert an argument value to a number. */\nlong long\nargs_strtonum(struct args *args, u_char flag, long long minval,\n    long long maxval, char **cause)\n{\n\tconst char\t\t*errstr;\n\tlong long\t\t ll;\n\tstruct args_entry\t*entry;\n\tstruct args_value\t*value;\n\n\tif ((entry = args_find(args, flag)) == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\tvalue = TAILQ_LAST(&entry->values, args_values);\n\tif (value == NULL ||\n\t    value->type != ARGS_STRING ||\n\t    value->string == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\n\tll = strtonum(value->string, minval, maxval, &errstr);\n\tif (errstr != NULL) {\n\t\t*cause = xstrdup(errstr);\n\t\treturn (0);\n\t}\n\n\t*cause = NULL;\n\treturn (ll);\n}\n\n/* Convert an argument value to a number, and expand formats. */\nlong long\nargs_strtonum_and_expand(struct args *args, u_char flag, long long minval,\n    long long maxval, struct cmdq_item *item, char **cause)\n{\n\tconst char\t\t*errstr;\n\tchar\t\t\t*formatted;\n\tlong long\t\t ll;\n\tstruct args_entry\t*entry;\n\tstruct args_value\t*value;\n\n\tif ((entry = args_find(args, flag)) == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\tvalue = TAILQ_LAST(&entry->values, args_values);\n\tif (value == NULL ||\n\t    value->type != ARGS_STRING ||\n\t    value->string == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\n\tformatted = format_single_from_target(item, value->string);\n\tll = strtonum(formatted, minval, maxval, &errstr);\n\tfree(formatted);\n\tif (errstr != NULL) {\n\t\t*cause = xstrdup(errstr);\n\t\treturn (0);\n\t}\n\n\t*cause = NULL;\n\treturn (ll);\n}\n\n/* Convert an argument to a number which may be a percentage. */\nlong long\nargs_percentage(struct args *args, u_char flag, long long minval,\n    long long maxval, long long curval, char **cause)\n{\n\tconst char\t\t*value;\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, flag)) == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\tif (TAILQ_EMPTY(&entry->values)) {\n\t\t*cause = xstrdup(\"empty\");\n\t\treturn (0);\n\t}\n\tvalue = TAILQ_LAST(&entry->values, args_values)->string;\n\treturn (args_string_percentage(value, minval, maxval, curval, cause));\n}\n\n/* Convert a string to a number which may be a percentage. */\nlong long\nargs_string_percentage(const char *value, long long minval, long long maxval,\n    long long curval, char **cause)\n{\n\tconst char\t*errstr;\n\tlong long\t ll;\n\tsize_t\t\t valuelen = strlen(value);\n\tchar\t\t*copy;\n\n\tif (valuelen == 0) {\n\t\t*cause = xstrdup(\"empty\");\n\t\treturn (0);\n\t}\n\tif (value[valuelen - 1] == '%') {\n\t\tcopy = xstrdup(value);\n\t\tcopy[valuelen - 1] = '\\0';\n\n\t\tll = strtonum(copy, 0, 100, &errstr);\n\t\tfree(copy);\n\t\tif (errstr != NULL) {\n\t\t\t*cause = xstrdup(errstr);\n\t\t\treturn (0);\n\t\t}\n\t\tll = (curval * ll) / 100;\n\t\tif (ll < minval) {\n\t\t\t*cause = xstrdup(\"too small\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (ll > maxval) {\n\t\t\t*cause = xstrdup(\"too large\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tll = strtonum(value, minval, maxval, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\t*cause = xstrdup(errstr);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t*cause = NULL;\n\treturn (ll);\n}\n\n/*\n * Convert an argument to a number which may be a percentage, and expand\n * formats.\n */\nlong long\nargs_percentage_and_expand(struct args *args, u_char flag, long long minval,\n    long long maxval, long long curval, struct cmdq_item *item, char **cause)\n{\n\tconst char\t\t*value;\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, flag)) == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\tif (TAILQ_EMPTY(&entry->values)) {\n\t\t*cause = xstrdup(\"empty\");\n\t\treturn (0);\n\t}\n\tvalue = TAILQ_LAST(&entry->values, args_values)->string;\n\treturn (args_string_percentage_and_expand(value, minval, maxval, curval,\n\t\t    item, cause));\n}\n\n/*\n * Convert a string to a number which may be a percentage, and expand formats.\n */\nlong long\nargs_string_percentage_and_expand(const char *value, long long minval,\n    long long maxval, long long curval, struct cmdq_item *item, char **cause)\n{\n\tconst char\t*errstr;\n\tlong long\t ll;\n\tsize_t\t\t valuelen = strlen(value);\n\tchar\t\t*copy, *f;\n\n\tif (value[valuelen - 1] == '%') {\n\t\tcopy = xstrdup(value);\n\t\tcopy[valuelen - 1] = '\\0';\n\n\t\tf = format_single_from_target(item, copy);\n\t\tll = strtonum(f, 0, 100, &errstr);\n\t\tfree(f);\n\t\tfree(copy);\n\t\tif (errstr != NULL) {\n\t\t\t*cause = xstrdup(errstr);\n\t\t\treturn (0);\n\t\t}\n\t\tll = (curval * ll) / 100;\n\t\tif (ll < minval) {\n\t\t\t*cause = xstrdup(\"too small\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (ll > maxval) {\n\t\t\t*cause = xstrdup(\"too large\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tf = format_single_from_target(item, value);\n\t\tll = strtonum(f, minval, maxval, &errstr);\n\t\tfree(f);\n\t\tif (errstr != NULL) {\n\t\t\t*cause = xstrdup(errstr);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t*cause = NULL;\n\treturn (ll);\n}\n"
        },
        {
          "name": "attributes.c",
          "type": "blob",
          "size": 3.189453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\nconst char *\nattributes_tostring(int attr)\n{\n\tstatic char\tbuf[512];\n\tsize_t\t\tlen;\n\n\tif (attr == 0)\n\t\treturn (\"none\");\n\n\tlen = xsnprintf(buf, sizeof buf, \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    (attr & GRID_ATTR_CHARSET) ? \"acs,\" : \"\",\n\t    (attr & GRID_ATTR_BRIGHT) ? \"bright,\" : \"\",\n\t    (attr & GRID_ATTR_DIM) ? \"dim,\" : \"\",\n\t    (attr & GRID_ATTR_UNDERSCORE) ? \"underscore,\" : \"\",\n\t    (attr & GRID_ATTR_BLINK)? \"blink,\" : \"\",\n\t    (attr & GRID_ATTR_REVERSE) ? \"reverse,\" : \"\",\n\t    (attr & GRID_ATTR_HIDDEN) ? \"hidden,\" : \"\",\n\t    (attr & GRID_ATTR_ITALICS) ? \"italics,\" : \"\",\n\t    (attr & GRID_ATTR_STRIKETHROUGH) ? \"strikethrough,\" : \"\",\n\t    (attr & GRID_ATTR_UNDERSCORE_2) ? \"double-underscore,\" : \"\",\n\t    (attr & GRID_ATTR_UNDERSCORE_3) ? \"curly-underscore,\" : \"\",\n\t    (attr & GRID_ATTR_UNDERSCORE_4) ? \"dotted-underscore,\" : \"\",\n\t    (attr & GRID_ATTR_UNDERSCORE_5) ? \"dashed-underscore,\" : \"\",\n\t    (attr & GRID_ATTR_OVERLINE) ? \"overline,\" : \"\");\n\tif (len > 0)\n\t\tbuf[len - 1] = '\\0';\n\n\treturn (buf);\n}\n\nint\nattributes_fromstring(const char *str)\n{\n\tconst char\tdelimiters[] = \" ,|\";\n\tint\t\tattr;\n\tsize_t\t\tend;\n\tu_int\t\ti;\n\tstruct {\n\t\tconst char\t*name;\n\t\tint\t\t attr;\n\t} table[] = {\n\t\t{ \"acs\", GRID_ATTR_CHARSET },\n\t\t{ \"bright\", GRID_ATTR_BRIGHT },\n\t\t{ \"bold\", GRID_ATTR_BRIGHT },\n\t\t{ \"dim\", GRID_ATTR_DIM },\n\t\t{ \"underscore\", GRID_ATTR_UNDERSCORE },\n\t\t{ \"blink\", GRID_ATTR_BLINK },\n\t\t{ \"reverse\", GRID_ATTR_REVERSE },\n\t\t{ \"hidden\", GRID_ATTR_HIDDEN },\n\t\t{ \"italics\", GRID_ATTR_ITALICS },\n\t\t{ \"strikethrough\", GRID_ATTR_STRIKETHROUGH },\n\t\t{ \"double-underscore\", GRID_ATTR_UNDERSCORE_2 },\n\t\t{ \"curly-underscore\", GRID_ATTR_UNDERSCORE_3 },\n\t\t{ \"dotted-underscore\", GRID_ATTR_UNDERSCORE_4 },\n\t\t{ \"dashed-underscore\", GRID_ATTR_UNDERSCORE_5 },\n\t\t{ \"overline\", GRID_ATTR_OVERLINE }\n\t};\n\n\tif (*str == '\\0' || strcspn(str, delimiters) == 0)\n\t\treturn (-1);\n\tif (strchr(delimiters, str[strlen(str) - 1]) != NULL)\n\t\treturn (-1);\n\n\tif (strcasecmp(str, \"default\") == 0 || strcasecmp(str, \"none\") == 0)\n\t\treturn (0);\n\n\tattr = 0;\n\tdo {\n\t\tend = strcspn(str, delimiters);\n\t\tfor (i = 0; i < nitems(table); i++) {\n\t\t\tif (end != strlen(table[i].name))\n\t\t\t\tcontinue;\n\t\t\tif (strncasecmp(str, table[i].name, end) == 0) {\n\t\t\t\tattr |= table[i].attr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == nitems(table))\n\t\t\treturn (-1);\n\t\tstr += end + strspn(str + end, delimiters);\n\t} while (*str != '\\0');\n\n\treturn (attr);\n}\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.3681640625,
          "content": "#!/bin/sh\n\nif [ \"x$(uname)\" = \"xOpenBSD\" ]; then\n\t[ -z \"$AUTOMAKE_VERSION\" ] && export AUTOMAKE_VERSION=1.15\n\t[ -z \"$AUTOCONF_VERSION\" ] && export AUTOCONF_VERSION=2.69\nfi\n\ndie()\n{\n    echo \"$@\" >&2\n    exit 1\n}\n\nmkdir -p etc\naclocal || die \"aclocal failed\"\nautomake --add-missing --force-missing --copy --foreign || die \"automake failed\"\nautoreconf || die \"autoreconf failed\"\n"
        },
        {
          "name": "cfg.c",
          "type": "blob",
          "size": 6.4072265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct client\t\t *cfg_client;\nint\t\t\t  cfg_finished;\nstatic char\t\t**cfg_causes;\nstatic u_int\t\t  cfg_ncauses;\nstatic struct cmdq_item\t *cfg_item;\n\nint                       cfg_quiet = 1;\nchar                    **cfg_files;\nu_int                     cfg_nfiles;\n\nstatic enum cmd_retval\ncfg_client_done(__unused struct cmdq_item *item, __unused void *data)\n{\n\tif (!cfg_finished)\n\t\treturn (CMD_RETURN_WAIT);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncfg_done(__unused struct cmdq_item *item, __unused void *data)\n{\n\tif (cfg_finished)\n\t\treturn (CMD_RETURN_NORMAL);\n\tcfg_finished = 1;\n\n\tcfg_show_causes(NULL);\n\n\tif (cfg_item != NULL)\n\t\tcmdq_continue(cfg_item);\n\n\tstatus_prompt_load_history();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\nstart_cfg(void)\n{\n\tstruct client\t *c;\n\tu_int\t\t  i;\n\tint\t\t  flags = 0;\n\n\t/*\n\t * Configuration files are loaded without a client, so commands are run\n\t * in the global queue with item->client NULL.\n\t *\n\t * However, we must block the initial client (but just the initial\n\t * client) so that its command runs after the configuration is loaded.\n\t * Because start_cfg() is called so early, we can be sure the client's\n\t * command queue is currently empty and our callback will be at the\n\t * front - we need to get in before MSG_COMMAND.\n\t */\n\tcfg_client = c = TAILQ_FIRST(&clients);\n\tif (c != NULL) {\n\t\tcfg_item = cmdq_get_callback(cfg_client_done, NULL);\n\t\tcmdq_append(c, cfg_item);\n\t}\n\n\tif (cfg_quiet)\n\t\tflags = CMD_PARSE_QUIET;\n\tfor (i = 0; i < cfg_nfiles; i++)\n\t\tload_cfg(cfg_files[i], c, NULL, NULL, flags, NULL);\n\n\tcmdq_append(NULL, cmdq_get_callback(cfg_done, NULL));\n}\n\nint\nload_cfg(const char *path, struct client *c, struct cmdq_item *item,\n    struct cmd_find_state *current, int flags, struct cmdq_item **new_item)\n{\n\tFILE\t\t\t*f;\n\tstruct cmd_parse_input\t pi;\n\tstruct cmd_parse_result\t*pr;\n\tstruct cmdq_item\t*new_item0;\n\tstruct cmdq_state\t*state;\n\n\tif (new_item != NULL)\n\t\t*new_item = NULL;\n\n\tlog_debug(\"loading %s\", path);\n\tif ((f = fopen(path, \"rb\")) == NULL) {\n\t\tif (errno == ENOENT && (flags & CMD_PARSE_QUIET))\n\t\t\treturn (0);\n\t\tcfg_add_cause(\"%s: %s\", path, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tmemset(&pi, 0, sizeof pi);\n\tpi.flags = flags;\n\tpi.file = path;\n\tpi.line = 1;\n\tpi.item = item;\n\tpi.c = c;\n\n\tpr = cmd_parse_from_file(f, &pi);\n\tfclose(f);\n\tif (pr->status == CMD_PARSE_ERROR) {\n\t\tcfg_add_cause(\"%s\", pr->error);\n\t\tfree(pr->error);\n\t\treturn (-1);\n\t}\n\tif (flags & CMD_PARSE_PARSEONLY) {\n\t\tcmd_list_free(pr->cmdlist);\n\t\treturn (0);\n\t}\n\n\tif (item != NULL)\n\t\tstate = cmdq_copy_state(cmdq_get_state(item), current);\n\telse\n\t\tstate = cmdq_new_state(NULL, NULL, 0);\n\tcmdq_add_format(state, \"current_file\", \"%s\", pi.file);\n\n\tnew_item0 = cmdq_get_command(pr->cmdlist, state);\n\tif (item != NULL)\n\t\tnew_item0 = cmdq_insert_after(item, new_item0);\n\telse\n\t\tnew_item0 = cmdq_append(NULL, new_item0);\n\tcmd_list_free(pr->cmdlist);\n\tcmdq_free_state(state);\n\n\tif (new_item != NULL)\n\t\t*new_item = new_item0;\n\treturn (0);\n}\n\nint\nload_cfg_from_buffer(const void *buf, size_t len, const char *path,\n    struct client *c, struct cmdq_item *item, struct cmd_find_state *current,\n    int flags, struct cmdq_item **new_item)\n{\n\tstruct cmd_parse_input\t pi;\n\tstruct cmd_parse_result\t*pr;\n\tstruct cmdq_item\t*new_item0;\n\tstruct cmdq_state\t*state;\n\n\tif (new_item != NULL)\n\t\t*new_item = NULL;\n\n\tlog_debug(\"loading %s\", path);\n\n\tmemset(&pi, 0, sizeof pi);\n\tpi.flags = flags;\n\tpi.file = path;\n\tpi.line = 1;\n\tpi.item = item;\n\tpi.c = c;\n\n\tpr = cmd_parse_from_buffer(buf, len, &pi);\n\tif (pr->status == CMD_PARSE_ERROR) {\n\t\tcfg_add_cause(\"%s\", pr->error);\n\t\tfree(pr->error);\n\t\treturn (-1);\n\t}\n\tif (flags & CMD_PARSE_PARSEONLY) {\n\t\tcmd_list_free(pr->cmdlist);\n\t\treturn (0);\n\t}\n\n\tif (item != NULL)\n\t\tstate = cmdq_copy_state(cmdq_get_state(item), current);\n\telse\n\t\tstate = cmdq_new_state(NULL, NULL, 0);\n\tcmdq_add_format(state, \"current_file\", \"%s\", pi.file);\n\n\tnew_item0 = cmdq_get_command(pr->cmdlist, state);\n\tif (item != NULL)\n\t\tnew_item0 = cmdq_insert_after(item, new_item0);\n\telse\n\t\tnew_item0 = cmdq_append(NULL, new_item0);\n\tcmd_list_free(pr->cmdlist);\n\tcmdq_free_state(state);\n\n\tif (new_item != NULL)\n\t\t*new_item = new_item0;\n\treturn (0);\n}\n\nvoid\ncfg_add_cause(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*msg;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tcfg_ncauses++;\n\tcfg_causes = xreallocarray(cfg_causes, cfg_ncauses, sizeof *cfg_causes);\n\tcfg_causes[cfg_ncauses - 1] = msg;\n}\n\nvoid\ncfg_print_causes(struct cmdq_item *item)\n{\n\tu_int\t i;\n\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\tcmdq_print(item, \"%s\", cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n}\n\nvoid\ncfg_show_causes(struct session *s)\n{\n\tstruct client\t\t\t*c = TAILQ_FIRST(&clients);\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tu_int\t\t\t\t i;\n\n\tif (cfg_ncauses == 0)\n\t\treturn;\n\n\tif (c != NULL && (c->flags & CLIENT_CONTROL)) {\n\t\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\t\tcontrol_write(c, \"%%config-error %s\", cfg_causes[i]);\n\t\t\tfree(cfg_causes[i]);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (s == NULL) {\n\t\tif (c != NULL && c->session != NULL)\n\t\t\ts = c->session;\n\t\telse\n\t\t\ts = RB_MIN(sessions, &sessions);\n\t}\n\tif (s == NULL || s->attached == 0) /* wait for an attached session */\n\t\treturn;\n\twp = s->curw->window->active;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->mode != &window_view_mode)\n\t\twindow_pane_set_mode(wp, NULL, &window_view_mode, NULL, NULL);\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\twindow_copy_add(wp, 0, \"%s\", cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\nout:\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n}\n"
        },
        {
          "name": "client.c",
          "type": "blob",
          "size": 20.791015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/file.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic struct tmuxproc\t*client_proc;\nstatic struct tmuxpeer\t*client_peer;\nstatic uint64_t\t\t client_flags;\nstatic int\t\t client_suspended;\nstatic enum {\n\tCLIENT_EXIT_NONE,\n\tCLIENT_EXIT_DETACHED,\n\tCLIENT_EXIT_DETACHED_HUP,\n\tCLIENT_EXIT_LOST_TTY,\n\tCLIENT_EXIT_TERMINATED,\n\tCLIENT_EXIT_LOST_SERVER,\n\tCLIENT_EXIT_EXITED,\n\tCLIENT_EXIT_SERVER_EXITED,\n\tCLIENT_EXIT_MESSAGE_PROVIDED\n} client_exitreason = CLIENT_EXIT_NONE;\nstatic int\t\t client_exitflag;\nstatic int\t\t client_exitval;\nstatic enum msgtype\t client_exittype;\nstatic const char\t*client_exitsession;\nstatic char\t\t*client_exitmessage;\nstatic const char\t*client_execshell;\nstatic const char\t*client_execcmd;\nstatic int\t\t client_attached;\nstatic struct client_files client_files = RB_INITIALIZER(&client_files);\n\nstatic __dead void\t client_exec(const char *,const char *);\nstatic int\t\t client_get_lock(char *);\nstatic int\t\t client_connect(struct event_base *, const char *,\n\t\t\t     uint64_t);\nstatic void\t\t client_send_identify(const char *, const char *,\n\t\t\t     char **, u_int, const char *, int);\nstatic void\t\t client_signal(int);\nstatic void\t\t client_dispatch(struct imsg *, void *);\nstatic void\t\t client_dispatch_attached(struct imsg *);\nstatic void\t\t client_dispatch_wait(struct imsg *);\nstatic const char\t*client_exit_message(void);\n\n/*\n * Get server create lock. If already held then server start is happening in\n * another client, so block until the lock is released and return -2 to\n * retry. Return -1 on failure to continue and start the server anyway.\n */\nstatic int\nclient_get_lock(char *lockfile)\n{\n\tint lockfd;\n\n\tlog_debug(\"lock file is %s\", lockfile);\n\n\tif ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {\n\t\tlog_debug(\"open failed: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tif (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {\n\t\tlog_debug(\"flock failed: %s\", strerror(errno));\n\t\tif (errno != EAGAIN)\n\t\t\treturn (lockfd);\n\t\twhile (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)\n\t\t\t/* nothing */;\n\t\tclose(lockfd);\n\t\treturn (-2);\n\t}\n\tlog_debug(\"flock succeeded\");\n\n\treturn (lockfd);\n}\n\n/* Connect client to server. */\nstatic int\nclient_connect(struct event_base *base, const char *path, uint64_t flags)\n{\n\tstruct sockaddr_un\tsa;\n\tsize_t\t\t\tsize;\n\tint\t\t\tfd, lockfd = -1, locked = 0;\n\tchar\t\t       *lockfile = NULL;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sun_family = AF_UNIX;\n\tsize = strlcpy(sa.sun_path, path, sizeof sa.sun_path);\n\tif (size >= sizeof sa.sun_path) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tlog_debug(\"socket is %s\", path);\n\nretry:\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\treturn (-1);\n\n\tlog_debug(\"trying connect\");\n\tif (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {\n\t\tlog_debug(\"connect failed: %s\", strerror(errno));\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\tgoto failed;\n\t\tif (flags & CLIENT_NOSTARTSERVER)\n\t\t\tgoto failed;\n\t\tif (~flags & CLIENT_STARTSERVER)\n\t\t\tgoto failed;\n\t\tclose(fd);\n\n\t\tif (!locked) {\n\t\t\txasprintf(&lockfile, \"%s.lock\", path);\n\t\t\tif ((lockfd = client_get_lock(lockfile)) < 0) {\n\t\t\t\tlog_debug(\"didn't get lock (%d)\", lockfd);\n\n\t\t\t\tfree(lockfile);\n\t\t\t\tlockfile = NULL;\n\n\t\t\t\tif (lockfd == -2)\n\t\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tlog_debug(\"got lock (%d)\", lockfd);\n\n\t\t\t/*\n\t\t\t * Always retry at least once, even if we got the lock,\n\t\t\t * because another client could have taken the lock,\n\t\t\t * started the server and released the lock between our\n\t\t\t * connect() and flock().\n\t\t\t */\n\t\t\tlocked = 1;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {\n\t\t\tfree(lockfile);\n\t\t\tclose(lockfd);\n\t\t\treturn (-1);\n\t\t}\n\t\tfd = server_start(client_proc, flags, base, lockfd, lockfile);\n\t}\n\n\tif (locked && lockfd >= 0) {\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\tsetblocking(fd, 0);\n\treturn (fd);\n\nfailed:\n\tif (locked) {\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\tclose(fd);\n\treturn (-1);\n}\n\n/* Get exit string from reason number. */\nconst char *\nclient_exit_message(void)\n{\n\tstatic char msg[256];\n\n\tswitch (client_exitreason) {\n\tcase CLIENT_EXIT_NONE:\n\t\tbreak;\n\tcase CLIENT_EXIT_DETACHED:\n\t\tif (client_exitsession != NULL) {\n\t\t\txsnprintf(msg, sizeof msg, \"detached \"\n\t\t\t    \"(from session %s)\", client_exitsession);\n\t\t\treturn (msg);\n\t\t}\n\t\treturn (\"detached\");\n\tcase CLIENT_EXIT_DETACHED_HUP:\n\t\tif (client_exitsession != NULL) {\n\t\t\txsnprintf(msg, sizeof msg, \"detached and SIGHUP \"\n\t\t\t    \"(from session %s)\", client_exitsession);\n\t\t\treturn (msg);\n\t\t}\n\t\treturn (\"detached and SIGHUP\");\n\tcase CLIENT_EXIT_LOST_TTY:\n\t\treturn (\"lost tty\");\n\tcase CLIENT_EXIT_TERMINATED:\n\t\treturn (\"terminated\");\n\tcase CLIENT_EXIT_LOST_SERVER:\n\t\treturn (\"server exited unexpectedly\");\n\tcase CLIENT_EXIT_EXITED:\n\t\treturn (\"exited\");\n\tcase CLIENT_EXIT_SERVER_EXITED:\n\t\treturn (\"server exited\");\n\tcase CLIENT_EXIT_MESSAGE_PROVIDED:\n\t\treturn (client_exitmessage);\n\t}\n\treturn (\"unknown reason\");\n}\n\n/* Exit if all streams flushed. */\nstatic void\nclient_exit(void)\n{\n\tif (!file_write_left(&client_files))\n\t\tproc_exit(client_proc);\n}\n\n/* Client main loop. */\nint\nclient_main(struct event_base *base, int argc, char **argv, uint64_t flags,\n    int feat)\n{\n\tstruct cmd_parse_result\t*pr;\n\tstruct msg_command\t*data;\n\tint\t\t\t fd, i;\n\tconst char\t\t*ttynam, *termname, *cwd;\n\tpid_t\t\t\t ppid;\n\tenum msgtype\t\t msg;\n\tstruct termios\t\t tio, saved_tio;\n\tsize_t\t\t\t size, linesize = 0;\n\tssize_t\t\t\t linelen;\n\tchar\t\t\t*line = NULL, **caps = NULL, *cause;\n\tu_int\t\t\t ncaps = 0;\n\tstruct args_value\t*values;\n\n\t/* Set up the initial command. */\n\tif (shell_command != NULL) {\n\t\tmsg = MSG_SHELL;\n\t\tflags |= CLIENT_STARTSERVER;\n\t} else if (argc == 0) {\n\t\tmsg = MSG_COMMAND;\n\t\tflags |= CLIENT_STARTSERVER;\n\t} else {\n\t\tmsg = MSG_COMMAND;\n\n\t\t/*\n\t\t * It's annoying parsing the command string twice (in client\n\t\t * and later in server) but it is necessary to get the start\n\t\t * server flag.\n\t\t */\n\t\tvalues = args_from_vector(argc, argv);\n\t\tpr = cmd_parse_from_arguments(values, argc, NULL);\n\t\tif (pr->status == CMD_PARSE_SUCCESS) {\n\t\t\tif (cmd_list_any_have(pr->cmdlist, CMD_STARTSERVER))\n\t\t\t\tflags |= CLIENT_STARTSERVER;\n\t\t\tcmd_list_free(pr->cmdlist);\n\t\t} else\n\t\t\tfree(pr->error);\n\t\targs_free_values(values, argc);\n\t\tfree(values);\n\t}\n\n\t/* Create client process structure (starts logging). */\n\tclient_proc = proc_start(\"client\");\n\tproc_set_signals(client_proc, client_signal);\n\n\t/* Save the flags. */\n\tclient_flags = flags;\n\tlog_debug(\"flags are %#llx\", (unsigned long long)client_flags);\n\n\t/* Initialize the client socket and start the server. */\n#ifdef HAVE_SYSTEMD\n\tif (systemd_activated()) {\n\t\t/* socket-based activation, do not even try to be a client. */\n\t\tfd = server_start(client_proc, flags, base, 0, NULL);\n\t} else\n#endif\n\tfd = client_connect(base, socket_path, client_flags);\n\tif (fd == -1) {\n\t\tif (errno == ECONNREFUSED) {\n\t\t\tfprintf(stderr, \"no server running on %s\\n\",\n\t\t\t    socket_path);\n\t\t} else {\n\t\t\tfprintf(stderr, \"error connecting to %s (%s)\\n\",\n\t\t\t    socket_path, strerror(errno));\n\t\t}\n\t\treturn (1);\n\t}\n\tclient_peer = proc_add_peer(client_proc, fd, client_dispatch, NULL);\n\n\t/* Save these before pledge(). */\n\tif ((cwd = find_cwd()) == NULL && (cwd = find_home()) == NULL)\n\t\tcwd = \"/\";\n\tif ((ttynam = ttyname(STDIN_FILENO)) == NULL)\n\t\tttynam = \"\";\n\tif ((termname = getenv(\"TERM\")) == NULL)\n\t\ttermname = \"\";\n\n\t/*\n\t * Drop privileges for client. \"proc exec\" is needed for -c and for\n\t * locking (which uses system(3)).\n\t *\n\t * \"tty\" is needed to restore termios(4) and also for some reason -CC\n\t * does not work properly without it (input is not recognised).\n\t *\n\t * \"sendfd\" is dropped later in client_dispatch_wait().\n\t */\n\tif (pledge(\n\t    \"stdio rpath wpath cpath unix sendfd proc exec tty\",\n\t    NULL) != 0)\n\t\tfatal(\"pledge failed\");\n\n\t/* Load terminfo entry if any. */\n\tif (isatty(STDIN_FILENO) &&\n\t    *termname != '\\0' &&\n\t    tty_term_read_list(termname, STDIN_FILENO, &caps, &ncaps,\n\t    &cause) != 0) {\n\t\tfprintf(stderr, \"%s\\n\", cause);\n\t\tfree(cause);\n\t\treturn (1);\n\t}\n\n\t/* Free stuff that is not used in the client. */\n\tif (ptm_fd != -1)\n\t\tclose(ptm_fd);\n\toptions_free(global_options);\n\toptions_free(global_s_options);\n\toptions_free(global_w_options);\n\tenviron_free(global_environ);\n\n\t/* Set up control mode. */\n\tif (client_flags & CLIENT_CONTROLCONTROL) {\n\t\tif (tcgetattr(STDIN_FILENO, &saved_tio) != 0) {\n\t\t\tfprintf(stderr, \"tcgetattr failed: %s\\n\",\n\t\t\t    strerror(errno));\n\t\t\treturn (1);\n\t\t}\n\t\tcfmakeraw(&tio);\n\t\ttio.c_iflag = ICRNL|IXANY;\n\t\ttio.c_oflag = OPOST|ONLCR;\n#ifdef NOKERNINFO\n\t\ttio.c_lflag = NOKERNINFO;\n#endif\n\t\ttio.c_cflag = CREAD|CS8|HUPCL;\n\t\ttio.c_cc[VMIN] = 1;\n\t\ttio.c_cc[VTIME] = 0;\n\t\tcfsetispeed(&tio, cfgetispeed(&saved_tio));\n\t\tcfsetospeed(&tio, cfgetospeed(&saved_tio));\n\t\ttcsetattr(STDIN_FILENO, TCSANOW, &tio);\n\t}\n\n\t/* Send identify messages. */\n\tclient_send_identify(ttynam, termname, caps, ncaps, cwd, feat);\n\ttty_term_free_list(caps, ncaps);\n\tproc_flush_peer(client_peer);\n\n\t/* Send first command. */\n\tif (msg == MSG_COMMAND) {\n\t\t/* How big is the command? */\n\t\tsize = 0;\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tsize += strlen(argv[i]) + 1;\n\t\tif (size > MAX_IMSGSIZE - (sizeof *data)) {\n\t\t\tfprintf(stderr, \"command too long\\n\");\n\t\t\treturn (1);\n\t\t}\n\t\tdata = xmalloc((sizeof *data) + size);\n\n\t\t/* Prepare command for server. */\n\t\tdata->argc = argc;\n\t\tif (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {\n\t\t\tfprintf(stderr, \"command too long\\n\");\n\t\t\tfree(data);\n\t\t\treturn (1);\n\t\t}\n\t\tsize += sizeof *data;\n\n\t\t/* Send the command. */\n\t\tif (proc_send(client_peer, msg, -1, data, size) != 0) {\n\t\t\tfprintf(stderr, \"failed to send command\\n\");\n\t\t\tfree(data);\n\t\t\treturn (1);\n\t\t}\n\t\tfree(data);\n\t} else if (msg == MSG_SHELL)\n\t\tproc_send(client_peer, msg, -1, NULL, 0);\n\n\t/* Start main loop. */\n\tproc_loop(client_proc, NULL);\n\n\t/* Run command if user requested exec, instead of exiting. */\n\tif (client_exittype == MSG_EXEC) {\n\t\tif (client_flags & CLIENT_CONTROLCONTROL)\n\t\t\ttcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);\n\t\tclient_exec(client_execshell, client_execcmd);\n\t}\n\n\t/* Restore streams to blocking. */\n\tsetblocking(STDIN_FILENO, 1);\n\tsetblocking(STDOUT_FILENO, 1);\n\tsetblocking(STDERR_FILENO, 1);\n\n\t/* Print the exit message, if any, and exit. */\n\tif (client_attached) {\n\t\tif (client_exitreason != CLIENT_EXIT_NONE)\n\t\t\tprintf(\"[%s]\\n\", client_exit_message());\n\n\t\tppid = getppid();\n\t\tif (client_exittype == MSG_DETACHKILL && ppid > 1)\n\t\t\tkill(ppid, SIGHUP);\n\t} else if (client_flags & CLIENT_CONTROL) {\n\t\tif (client_exitreason != CLIENT_EXIT_NONE)\n\t\t\tprintf(\"%%exit %s\\n\", client_exit_message());\n\t\telse\n\t\t\tprintf(\"%%exit\\n\");\n\t\tfflush(stdout);\n\t\tif (client_flags & CLIENT_CONTROL_WAITEXIT) {\n\t\t\tsetvbuf(stdin, NULL, _IOLBF, 0);\n\t\t\tfor (;;) {\n\t\t\t\tlinelen = getline(&line, &linesize, stdin);\n\t\t\t\tif (linelen <= 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(line);\n\t\t}\n\t\tif (client_flags & CLIENT_CONTROLCONTROL) {\n\t\t\tprintf(\"\\033\\\\\");\n\t\t\tfflush(stdout);\n\t\t\ttcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);\n\t\t}\n\t} else if (client_exitreason != CLIENT_EXIT_NONE)\n\t\tfprintf(stderr, \"%s\\n\", client_exit_message());\n\treturn (client_exitval);\n}\n\n/* Send identify messages to server. */\nstatic void\nclient_send_identify(const char *ttynam, const char *termname, char **caps,\n    u_int ncaps, const char *cwd, int feat)\n{\n\tchar\t**ss;\n\tsize_t\t  sslen;\n\tint\t  fd;\n\tuint64_t  flags = client_flags;\n\tpid_t\t  pid;\n\tu_int\t  i;\n\n\tproc_send(client_peer, MSG_IDENTIFY_LONGFLAGS, -1, &flags, sizeof flags);\n\tproc_send(client_peer, MSG_IDENTIFY_LONGFLAGS, -1, &client_flags,\n\t    sizeof client_flags);\n\n\tproc_send(client_peer, MSG_IDENTIFY_TERM, -1, termname,\n\t    strlen(termname) + 1);\n\tproc_send(client_peer, MSG_IDENTIFY_FEATURES, -1, &feat, sizeof feat);\n\n\tproc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,\n\t    strlen(ttynam) + 1);\n\tproc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);\n\n\tfor (i = 0; i < ncaps; i++) {\n\t\tproc_send(client_peer, MSG_IDENTIFY_TERMINFO, -1,\n\t\t    caps[i], strlen(caps[i]) + 1);\n\t}\n\n\tif ((fd = dup(STDIN_FILENO)) == -1)\n\t\tfatal(\"dup failed\");\n\tproc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);\n\tif ((fd = dup(STDOUT_FILENO)) == -1)\n\t\tfatal(\"dup failed\");\n\tproc_send(client_peer, MSG_IDENTIFY_STDOUT, fd, NULL, 0);\n\n\tpid = getpid();\n\tproc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);\n\n\tfor (ss = environ; *ss != NULL; ss++) {\n\t\tsslen = strlen(*ss) + 1;\n\t\tif (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)\n\t\t\tcontinue;\n\t\tproc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);\n\t}\n\n\tproc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);\n}\n\n/* Run command in shell; used for -c. */\nstatic __dead void\nclient_exec(const char *shell, const char *shellcmd)\n{\n\tchar\t*argv0;\n\n\tlog_debug(\"shell %s, command %s\", shell, shellcmd);\n\targv0 = shell_argv0(shell, !!(client_flags & CLIENT_LOGIN));\n\tsetenv(\"SHELL\", shell, 1);\n\n\tproc_clear_signals(client_proc, 1);\n\n\tsetblocking(STDIN_FILENO, 1);\n\tsetblocking(STDOUT_FILENO, 1);\n\tsetblocking(STDERR_FILENO, 1);\n\tclosefrom(STDERR_FILENO + 1);\n\n\texecl(shell, argv0, \"-c\", shellcmd, (char *) NULL);\n\tfatal(\"execl failed\");\n}\n\n/* Callback to handle signals in the client. */\nstatic void\nclient_signal(int sig)\n{\n\tstruct sigaction sigact;\n\tint\t\t status;\n\tpid_t\t\t pid;\n\n\tlog_debug(\"%s: %s\", __func__, strsignal(sig));\n\tif (sig == SIGCHLD) {\n\t\tfor (;;) {\n\t\t\tpid = waitpid(WAIT_ANY, &status, WNOHANG);\n\t\t\tif (pid == 0)\n\t\t\t\tbreak;\n\t\t\tif (pid == -1) {\n\t\t\t\tif (errno == ECHILD)\n\t\t\t\t\tbreak;\n\t\t\t\tlog_debug(\"waitpid failed: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t}\n\t} else if (!client_attached) {\n\t\tif (sig == SIGTERM || sig == SIGHUP)\n\t\t\tproc_exit(client_proc);\n\t} else {\n\t\tswitch (sig) {\n\t\tcase SIGHUP:\n\t\t\tclient_exitreason = CLIENT_EXIT_LOST_TTY;\n\t\t\tclient_exitval = 1;\n\t\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tif (!client_suspended)\n\t\t\t\tclient_exitreason = CLIENT_EXIT_TERMINATED;\n\t\t\tclient_exitval = 1;\n\t\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGWINCH:\n\t\t\tproc_send(client_peer, MSG_RESIZE, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGCONT:\n\t\t\tmemset(&sigact, 0, sizeof sigact);\n\t\t\tsigemptyset(&sigact.sa_mask);\n\t\t\tsigact.sa_flags = SA_RESTART;\n\t\t\tsigact.sa_handler = SIG_IGN;\n\t\t\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\t\t\tfatal(\"sigaction failed\");\n\t\t\tproc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);\n\t\t\tclient_suspended = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Callback for file write error or close. */\nstatic void\nclient_file_check_cb(__unused struct client *c, __unused const char *path,\n    __unused int error, __unused int closed, __unused struct evbuffer *buffer,\n    __unused void *data)\n{\n\tif (client_exitflag)\n\t\tclient_exit();\n}\n\n/* Callback for client read events. */\nstatic void\nclient_dispatch(struct imsg *imsg, __unused void *arg)\n{\n\tif (imsg == NULL) {\n\t\tif (!client_exitflag) {\n\t\t\tclient_exitreason = CLIENT_EXIT_LOST_SERVER;\n\t\t\tclient_exitval = 1;\n\t\t}\n\t\tproc_exit(client_proc);\n\t\treturn;\n\t}\n\n\tif (client_attached)\n\t\tclient_dispatch_attached(imsg);\n\telse\n\t\tclient_dispatch_wait(imsg);\n}\n\n/* Process an exit message. */\nstatic void\nclient_dispatch_exit_message(char *data, size_t datalen)\n{\n\tint\tretval;\n\n\tif (datalen < sizeof retval && datalen != 0)\n\t\tfatalx(\"bad MSG_EXIT size\");\n\n\tif (datalen >= sizeof retval) {\n\t\tmemcpy(&retval, data, sizeof retval);\n\t\tclient_exitval = retval;\n\t}\n\n\tif (datalen > sizeof retval) {\n\t\tdatalen -= sizeof retval;\n\t\tdata += sizeof retval;\n\n\t\tclient_exitmessage = xmalloc(datalen);\n\t\tmemcpy(client_exitmessage, data, datalen);\n\t\tclient_exitmessage[datalen - 1] = '\\0';\n\n\t\tclient_exitreason = CLIENT_EXIT_MESSAGE_PROVIDED;\n\t}\n}\n\n/* Dispatch imsgs when in wait state (before MSG_READY). */\nstatic void\nclient_dispatch_wait(struct imsg *imsg)\n{\n\tchar\t\t*data;\n\tssize_t\t\t datalen;\n\tstatic int\t pledge_applied;\n\n\t/*\n\t * \"sendfd\" is no longer required once all of the identify messages\n\t * have been sent. We know the server won't send us anything until that\n\t * point (because we don't ask it to), so we can drop \"sendfd\" once we\n\t * get the first message from the server.\n\t */\n\tif (!pledge_applied) {\n\t\tif (pledge(\n\t\t    \"stdio rpath wpath cpath unix proc exec tty\",\n\t\t    NULL) != 0)\n\t\t\tfatal(\"pledge failed\");\n\t\tpledge_applied = 1;\n\t}\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_EXIT:\n\tcase MSG_SHUTDOWN:\n\t\tclient_dispatch_exit_message(data, datalen);\n\t\tclient_exitflag = 1;\n\t\tclient_exit();\n\t\tbreak;\n\tcase MSG_READY:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_READY size\");\n\n\t\tclient_attached = 1;\n\t\tproc_send(client_peer, MSG_RESIZE, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_VERSION:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_VERSION size\");\n\n\t\tfprintf(stderr, \"protocol version mismatch \"\n\t\t    \"(client %d, server %u)\\n\", PROTOCOL_VERSION,\n\t\t    imsg->hdr.peerid & 0xff);\n\t\tclient_exitval = 1;\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_FLAGS:\n\t\tif (datalen != sizeof client_flags)\n\t\t\tfatalx(\"bad MSG_FLAGS string\");\n\n\t\tmemcpy(&client_flags, data, sizeof client_flags);\n\t\tlog_debug(\"new flags are %#llx\",\n\t\t    (unsigned long long)client_flags);\n\t\tbreak;\n\tcase MSG_SHELL:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_SHELL string\");\n\n\t\tclient_exec(data, shell_command);\n\t\t/* NOTREACHED */\n\tcase MSG_DETACH:\n\tcase MSG_DETACHKILL:\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXITED:\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_READ_OPEN:\n\t\tfile_read_open(&client_files, client_peer, imsg, 1,\n\t\t    !(client_flags & CLIENT_CONTROL), client_file_check_cb,\n\t\t    NULL);\n\t\tbreak;\n\tcase MSG_READ_CANCEL:\n\t\tfile_read_cancel(&client_files, imsg);\n\t\tbreak;\n\tcase MSG_WRITE_OPEN:\n\t\tfile_write_open(&client_files, client_peer, imsg, 1,\n\t\t    !(client_flags & CLIENT_CONTROL), client_file_check_cb,\n\t\t    NULL);\n\t\tbreak;\n\tcase MSG_WRITE:\n\t\tfile_write_data(&client_files, imsg);\n\t\tbreak;\n\tcase MSG_WRITE_CLOSE:\n\t\tfile_write_close(&client_files, imsg);\n\t\tbreak;\n\tcase MSG_OLDSTDERR:\n\tcase MSG_OLDSTDIN:\n\tcase MSG_OLDSTDOUT:\n\t\tfprintf(stderr, \"server version is too old for client\\n\");\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\t}\n}\n\n/* Dispatch imsgs in attached state (after MSG_READY). */\nstatic void\nclient_dispatch_attached(struct imsg *imsg)\n{\n\tstruct sigaction\t sigact;\n\tchar\t\t\t*data;\n\tssize_t\t\t\t datalen;\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_FLAGS:\n\t\tif (datalen != sizeof client_flags)\n\t\t\tfatalx(\"bad MSG_FLAGS string\");\n\n\t\tmemcpy(&client_flags, data, sizeof client_flags);\n\t\tlog_debug(\"new flags are %#llx\",\n\t\t    (unsigned long long)client_flags);\n\t\tbreak;\n\tcase MSG_DETACH:\n\tcase MSG_DETACHKILL:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_DETACH string\");\n\n\t\tclient_exitsession = xstrdup(data);\n\t\tclient_exittype = imsg->hdr.type;\n\t\tif (imsg->hdr.type == MSG_DETACHKILL)\n\t\t\tclient_exitreason = CLIENT_EXIT_DETACHED_HUP;\n\t\telse\n\t\t\tclient_exitreason = CLIENT_EXIT_DETACHED;\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXEC:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0' ||\n\t\t    strlen(data) + 1 == (size_t)datalen)\n\t\t\tfatalx(\"bad MSG_EXEC string\");\n\t\tclient_execcmd = xstrdup(data);\n\t\tclient_execshell = xstrdup(data + strlen(data) + 1);\n\n\t\tclient_exittype = imsg->hdr.type;\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXIT:\n\t\tclient_dispatch_exit_message(data, datalen);\n\t\tif (client_exitreason == CLIENT_EXIT_NONE)\n\t\t\tclient_exitreason = CLIENT_EXIT_EXITED;\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXITED:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_EXITED size\");\n\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_SHUTDOWN:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SHUTDOWN size\");\n\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tclient_exitreason = CLIENT_EXIT_SERVER_EXITED;\n\t\tclient_exitval = 1;\n\t\tbreak;\n\tcase MSG_SUSPEND:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SUSPEND size\");\n\n\t\tmemset(&sigact, 0, sizeof sigact);\n\t\tsigemptyset(&sigact.sa_mask);\n\t\tsigact.sa_flags = SA_RESTART;\n\t\tsigact.sa_handler = SIG_DFL;\n\t\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tclient_suspended = 1;\n\t\tkill(getpid(), SIGTSTP);\n\t\tbreak;\n\tcase MSG_LOCK:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_LOCK string\");\n\n\t\tsystem(data);\n\t\tproc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);\n\t\tbreak;\n\t}\n}\n"
        },
        {
          "name": "cmd-attach-session.c",
          "type": "blob",
          "size": 4.52734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Attach existing session to the current terminal.\n */\n\nstatic enum cmd_retval\tcmd_attach_session_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_attach_session_entry = {\n\t.name = \"attach-session\",\n\t.alias = \"attach\",\n\n\t.args = { \"c:dEf:rt:x\", 0, 0, NULL },\n\t.usage = \"[-dErx] [-c working-directory] [-f flags] \"\n\t         CMD_TARGET_SESSION_USAGE,\n\n\t/* -t is special */\n\n\t.flags = CMD_STARTSERVER|CMD_READONLY,\n\t.exec = cmd_attach_session_exec\n};\n\nenum cmd_retval\ncmd_attach_session(struct cmdq_item *item, const char *tflag, int dflag,\n    int xflag, int rflag, const char *cflag, int Eflag, const char *fflag)\n{\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t target;\n\tenum cmd_find_type\t type;\n\tint\t\t\t flags;\n\tstruct client\t\t*c = cmdq_get_client(item), *c_loop;\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tchar\t\t\t*cwd, *cause;\n\tenum msgtype\t\t msgtype;\n\n\tif (RB_EMPTY(&sessions)) {\n\t\tcmdq_error(item, \"no sessions\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (c == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (server_client_check_nested(c)) {\n\t\tcmdq_error(item, \"sessions should be nested with care, \"\n\t\t    \"unset $TMUX to force\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (tflag != NULL && tflag[strcspn(tflag, \":.\")] != '\\0') {\n\t\ttype = CMD_FIND_PANE;\n\t\tflags = 0;\n\t} else {\n\t\ttype = CMD_FIND_SESSION;\n\t\tflags = CMD_FIND_PREFER_UNATTACHED;\n\t}\n\tif (cmd_find_target(&target, item, tflag, type, flags) != 0)\n\t\treturn (CMD_RETURN_ERROR);\n\ts = target.s;\n\twl = target.wl;\n\twp = target.wp;\n\n\tif (wl != NULL) {\n\t\tif (wp != NULL)\n\t\t\twindow_set_active_pane(wp->window, wp, 1);\n\t\tsession_set_current(s, wl);\n\t\tif (wp != NULL)\n\t\t\tcmd_find_from_winlink_pane(current, wl, wp, 0);\n\t\telse\n\t\t\tcmd_find_from_winlink(current, wl, 0);\n\t}\n\n\tif (cflag != NULL) {\n\t\tcwd = format_single(item, cflag, c, s, wl, wp);\n\t\tfree((void *)s->cwd);\n\t\ts->cwd = cwd;\n\t}\n\tif (fflag)\n\t\tserver_client_set_flags(c, fflag);\n\tif (rflag)\n\t\tc->flags |= (CLIENT_READONLY|CLIENT_IGNORESIZE);\n\n\tc->last_session = c->session;\n\tif (c->session != NULL) {\n\t\tif (dflag || xflag) {\n\t\t\tif (xflag)\n\t\t\t\tmsgtype = MSG_DETACHKILL;\n\t\t\telse\n\t\t\t\tmsgtype = MSG_DETACH;\n\t\t\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\t\t\tif (c_loop->session != s || c == c_loop)\n\t\t\t\t\tcontinue;\n\t\t\t\tserver_client_detach(c_loop, msgtype);\n\t\t\t}\n\t\t}\n\t\tif (!Eflag)\n\t\t\tenviron_update(s->options, c->environ, s->environ);\n\n\t\tserver_client_set_session(c, s);\n\t\tif (~cmdq_get_flags(item) & CMDQ_STATE_REPEAT)\n\t\t\tserver_client_set_key_table(c, NULL);\n\t} else {\n\t\tif (server_client_open(c, &cause) != 0) {\n\t\t\tcmdq_error(item, \"open terminal failed: %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\n\t\tif (dflag || xflag) {\n\t\t\tif (xflag)\n\t\t\t\tmsgtype = MSG_DETACHKILL;\n\t\t\telse\n\t\t\t\tmsgtype = MSG_DETACH;\n\t\t\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\t\t\tif (c_loop->session != s || c == c_loop)\n\t\t\t\t\tcontinue;\n\t\t\t\tserver_client_detach(c_loop, msgtype);\n\t\t\t}\n\t\t}\n\t\tif (!Eflag)\n\t\t\tenviron_update(s->options, c->environ, s->environ);\n\n\t\tserver_client_set_session(c, s);\n\t\tserver_client_set_key_table(c, NULL);\n\n\t\tif (~c->flags & CLIENT_CONTROL)\n\t\t\tproc_send(c->peer, MSG_READY, -1, NULL, 0);\n\t\tnotify_client(\"client-attached\", c);\n\t\tc->flags |= CLIENT_ATTACHED;\n\t}\n\n\tif (cfg_finished)\n\t\tcfg_show_causes(s);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncmd_attach_session_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t*args = cmd_get_args(self);\n\n\treturn (cmd_attach_session(item, args_get(args, 't'),\n\t    args_has(args, 'd'), args_has(args, 'x'), args_has(args, 'r'),\n\t    args_get(args, 'c'), args_has(args, 'E'), args_get(args, 'f')));\n}\n"
        },
        {
          "name": "cmd-bind-key.c",
          "type": "blob",
          "size": 2.947265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Bind a key to a command.\n */\n\nstatic enum args_parse_type\tcmd_bind_key_args_parse(struct args *, u_int,\n\t\t\t\t    char **);\nstatic enum cmd_retval\t\tcmd_bind_key_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_bind_key_entry = {\n\t.name = \"bind-key\",\n\t.alias = \"bind\",\n\n\t.args = { \"nrN:T:\", 1, -1, cmd_bind_key_args_parse },\n\t.usage = \"[-nr] [-T key-table] [-N note] key \"\n\t         \"[command [arguments]]\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_bind_key_exec\n};\n\nstatic enum args_parse_type\ncmd_bind_key_args_parse(__unused struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n}\n\nstatic enum cmd_retval\ncmd_bind_key_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t *args = cmd_get_args(self);\n\tkey_code\t\t  key;\n\tconst char\t\t *tablename, *note = args_get(args, 'N');\n\tstruct cmd_parse_result\t *pr;\n\tint\t\t\t  repeat;\n\tstruct args_value\t *value;\n\tu_int\t\t\t  count = args_count(args);\n\n\tkey = key_string_lookup_string(args_string(args, 0));\n\tif (key == KEYC_NONE || key == KEYC_UNKNOWN) {\n\t\tcmdq_error(item, \"unknown key: %s\", args_string(args, 0));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'T'))\n\t\ttablename = args_get(args, 'T');\n\telse if (args_has(args, 'n'))\n\t\ttablename = \"root\";\n\telse\n\t\ttablename = \"prefix\";\n\trepeat = args_has(args, 'r');\n\n\tif (count == 1) {\n\t\tkey_bindings_add(tablename, key, note, repeat, NULL);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tvalue = args_value(args, 1);\n\tif (count == 2 && value->type == ARGS_COMMANDS) {\n\t\tkey_bindings_add(tablename, key, note, repeat, value->cmdlist);\n\t\tvalue->cmdlist->references++;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (count == 2)\n\t\tpr = cmd_parse_from_string(args_string(args, 1), NULL);\n\telse {\n\t\tpr = cmd_parse_from_arguments(args_values(args) + 1, count - 1,\n\t\t    NULL);\n\t}\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\tcmdq_error(item, \"%s\", pr->error);\n\t\tfree(pr->error);\n\t\treturn (CMD_RETURN_ERROR);\n\tcase CMD_PARSE_SUCCESS:\n\t\tbreak;\n\t}\n\tkey_bindings_add(tablename, key, note, repeat, pr->cmdlist);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-break-pane.c",
          "type": "blob",
          "size": 4.1806640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Break pane off into a window.\n */\n\n#define BREAK_PANE_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nstatic enum cmd_retval\tcmd_break_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_break_pane_entry = {\n\t.name = \"break-pane\",\n\t.alias = \"breakp\",\n\n\t.args = { \"abdPF:n:s:t:\", 0, 0, NULL },\n\t.usage = \"[-abdP] [-F format] [-n window-name] [-s src-pane] \"\n\t\t \"[-t dst-window]\",\n\n\t.source = { 's', CMD_FIND_PANE, 0 },\n\t.target = { 't', CMD_FIND_WINDOW, CMD_FIND_WINDOW_INDEX },\n\n\t.flags = 0,\n\t.exec = cmd_break_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_break_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct winlink\t\t*wl = source->wl;\n\tstruct session\t\t*src_s = source->s;\n\tstruct session\t\t*dst_s = target->s;\n\tstruct window_pane\t*wp = source->wp;\n\tstruct window\t\t*w = wl->window;\n\tchar\t\t\t*name, *cause, *cp;\n\tint\t\t\t idx = target->idx, before;\n\tconst char\t\t*template;\n\n\tbefore = args_has(args, 'b');\n\tif (args_has(args, 'a') || before) {\n\t\tif (target->wl != NULL)\n\t\t\tidx = winlink_shuffle_up(dst_s, target->wl, before);\n\t\telse\n\t\t\tidx = winlink_shuffle_up(dst_s, dst_s->curw, before);\n\t\tif (idx == -1)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tserver_unzoom_window(w);\n\n\tif (window_count_panes(w) == 1) {\n\t\tif (server_link_window(src_s, wl, dst_s, idx, 0,\n\t\t    !args_has(args, 'd'), &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (args_has(args, 'n')) {\n\t\t\twindow_set_name(w, args_get(args, 'n'));\n\t\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t\t}\n\t\tserver_unlink_window(src_s, wl);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (idx != -1 && winlink_find_by_index(&dst_s->windows, idx) != NULL) {\n\t\tcmdq_error(item, \"index in use: %d\", idx);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tTAILQ_REMOVE(&w->panes, wp, entry);\n\tserver_client_remove_pane(wp);\n\twindow_lost_pane(w, wp);\n\tlayout_close_pane(wp);\n\n\tw = wp->window = window_create(w->sx, w->sy, w->xpixel, w->ypixel);\n\toptions_set_parent(wp->options, w->options);\n\twp->flags |= PANE_STYLECHANGED;\n\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\tw->active = wp;\n\tw->latest = tc;\n\n\tif (!args_has(args, 'n')) {\n\t\tname = default_window_name(w);\n\t\twindow_set_name(w, name);\n\t\tfree(name);\n\t} else {\n\t\twindow_set_name(w, args_get(args, 'n'));\n\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t}\n\n\tlayout_init(w, wp);\n\twp->flags |= PANE_CHANGED;\n\tcolour_palette_from_option(&wp->palette, wp->options);\n\n\tif (idx == -1)\n\t\tidx = -1 - options_get_number(dst_s->options, \"base-index\");\n\twl = session_attach(dst_s, w, idx, &cause); /* can't fail */\n\tif (!args_has(args, 'd')) {\n\t\tsession_select(dst_s, wl->idx);\n\t\tcmd_find_from_session(current, dst_s, 0);\n\t}\n\n\tserver_redraw_session(src_s);\n\tif (src_s != dst_s)\n\t\tserver_redraw_session(dst_s);\n\tserver_status_session_group(src_s);\n\tif (src_s != dst_s)\n\t\tserver_status_session_group(dst_s);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = BREAK_PANE_TEMPLATE;\n\t\tcp = format_single(item, template, tc, dst_s, wl, wp);\n\t\tcmdq_print(item, \"%s\", cp);\n\t\tfree(cp);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-capture-pane.c",
          "type": "blob",
          "size": 6.3115234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Jonathan Alvarado <radobobo@users.sourceforge.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Write the entire contents of a pane to a buffer or stdout.\n */\n\nstatic enum cmd_retval\tcmd_capture_pane_exec(struct cmd *, struct cmdq_item *);\n\nstatic char\t*cmd_capture_pane_append(char *, size_t *, char *, size_t);\nstatic char\t*cmd_capture_pane_pending(struct args *, struct window_pane *,\n\t\t     size_t *);\nstatic char\t*cmd_capture_pane_history(struct args *, struct cmdq_item *,\n\t\t     struct window_pane *, size_t *);\n\nconst struct cmd_entry cmd_capture_pane_entry = {\n\t.name = \"capture-pane\",\n\t.alias = \"capturep\",\n\n\t.args = { \"ab:CeE:JNpPqS:Tt:\", 0, 0, NULL },\n\t.usage = \"[-aCeJNpPqT] \" CMD_BUFFER_USAGE \" [-E end-line] \"\n\t\t \"[-S start-line] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_capture_pane_exec\n};\n\nconst struct cmd_entry cmd_clear_history_entry = {\n\t.name = \"clear-history\",\n\t.alias = \"clearhist\",\n\n\t.args = { \"Ht:\", 0, 0, NULL },\n\t.usage = \"[-H] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_capture_pane_exec\n};\n\nstatic char *\ncmd_capture_pane_append(char *buf, size_t *len, char *line, size_t linelen)\n{\n\tbuf = xrealloc(buf, *len + linelen + 1);\n\tmemcpy(buf + *len, line, linelen);\n\t*len += linelen;\n\treturn (buf);\n}\n\nstatic char *\ncmd_capture_pane_pending(struct args *args, struct window_pane *wp,\n    size_t *len)\n{\n\tstruct evbuffer\t*pending;\n\tchar\t\t*buf, *line, tmp[5];\n\tsize_t\t\t linelen;\n\tu_int\t\t i;\n\n\tpending = input_pending(wp->ictx);\n\tif (pending == NULL)\n\t\treturn (xstrdup(\"\"));\n\n\tline = EVBUFFER_DATA(pending);\n\tlinelen = EVBUFFER_LENGTH(pending);\n\n\tbuf = xstrdup(\"\");\n\tif (args_has(args, 'C')) {\n\t\tfor (i = 0; i < linelen; i++) {\n\t\t\tif (line[i] >= ' ' && line[i] != '\\\\') {\n\t\t\t\ttmp[0] = line[i];\n\t\t\t\ttmp[1] = '\\0';\n\t\t\t} else\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"\\\\%03hho\", line[i]);\n\t\t\tbuf = cmd_capture_pane_append(buf, len, tmp,\n\t\t\t    strlen(tmp));\n\t\t}\n\t} else\n\t\tbuf = cmd_capture_pane_append(buf, len, line, linelen);\n\treturn (buf);\n}\n\nstatic char *\ncmd_capture_pane_history(struct args *args, struct cmdq_item *item,\n    struct window_pane *wp, size_t *len)\n{\n\tstruct grid\t\t*gd;\n\tconst struct grid_line\t*gl;\n\tstruct grid_cell\t*gc = NULL;\n\tint\t\t\t n, join_lines, flags = 0;\n\tu_int\t\t\t i, sx, top, bottom, tmp;\n\tchar\t\t\t*cause, *buf, *line;\n\tconst char\t\t*Sflag, *Eflag;\n\tsize_t\t\t\t linelen;\n\n\tsx = screen_size_x(&wp->base);\n\tif (args_has(args, 'a')) {\n\t\tgd = wp->base.saved_grid;\n\t\tif (gd == NULL) {\n\t\t\tif (!args_has(args, 'q')) {\n\t\t\t\tcmdq_error(item, \"no alternate screen\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\treturn (xstrdup(\"\"));\n\t\t}\n\t} else\n\t\tgd = wp->base.grid;\n\n\tSflag = args_get(args, 'S');\n\tif (Sflag != NULL && strcmp(Sflag, \"-\") == 0)\n\t\ttop = 0;\n\telse {\n\t\tn = args_strtonum_and_expand(args, 'S', INT_MIN, SHRT_MAX,\n\t\t\titem, &cause);\n\t\tif (cause != NULL) {\n\t\t\ttop = gd->hsize;\n\t\t\tfree(cause);\n\t\t} else if (n < 0 && (u_int) -n > gd->hsize)\n\t\t\ttop = 0;\n\t\telse\n\t\t\ttop = gd->hsize + n;\n\t\tif (top > gd->hsize + gd->sy - 1)\n\t\t\ttop = gd->hsize + gd->sy - 1;\n\t}\n\n\tEflag = args_get(args, 'E');\n\tif (Eflag != NULL && strcmp(Eflag, \"-\") == 0)\n\t\tbottom = gd->hsize + gd->sy - 1;\n\telse {\n\t\tn = args_strtonum_and_expand(args, 'E', INT_MIN, SHRT_MAX,\n\t\t\titem, &cause);\n\t\tif (cause != NULL) {\n\t\t\tbottom = gd->hsize + gd->sy - 1;\n\t\t\tfree(cause);\n\t\t} else if (n < 0 && (u_int) -n > gd->hsize)\n\t\t\tbottom = 0;\n\t\telse\n\t\t\tbottom = gd->hsize + n;\n\t\tif (bottom > gd->hsize + gd->sy - 1)\n\t\t\tbottom = gd->hsize + gd->sy - 1;\n\t}\n\n\tif (bottom < top) {\n\t\ttmp = bottom;\n\t\tbottom = top;\n\t\ttop = tmp;\n\t}\n\n\tjoin_lines = args_has(args, 'J');\n\tif (args_has(args, 'e'))\n\t\tflags |= GRID_STRING_WITH_SEQUENCES;\n\tif (args_has(args, 'C'))\n\t\tflags |= GRID_STRING_ESCAPE_SEQUENCES;\n\tif (!join_lines && !args_has(args, 'T'))\n\t\tflags |= GRID_STRING_EMPTY_CELLS;\n\tif (!join_lines && !args_has(args, 'N'))\n\t\tflags |= GRID_STRING_TRIM_SPACES;\n\n\tbuf = NULL;\n\tfor (i = top; i <= bottom; i++) {\n\t\tline = grid_string_cells(gd, 0, i, sx, &gc, flags, wp->screen);\n\t\tlinelen = strlen(line);\n\n\t\tbuf = cmd_capture_pane_append(buf, len, line, linelen);\n\n\t\tgl = grid_peek_line(gd, i);\n\t\tif (!join_lines || !(gl->flags & GRID_LINE_WRAPPED))\n\t\t\tbuf[(*len)++] = '\\n';\n\n\t\tfree(line);\n\t}\n\treturn (buf);\n}\n\nstatic enum cmd_retval\ncmd_capture_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct window_pane\t*wp = cmdq_get_target(item)->wp;\n\tchar\t\t\t*buf, *cause;\n\tconst char\t\t*bufname;\n\tsize_t\t\t\t len;\n\n\tif (cmd_get_entry(self) == &cmd_clear_history_entry) {\n\t\twindow_pane_reset_mode_all(wp);\n\t\tgrid_clear_history(wp->base.grid);\n\t\tif (args_has(args, 'H'))\n\t\t\tscreen_reset_hyperlinks(wp->screen);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tlen = 0;\n\tif (args_has(args, 'P'))\n\t\tbuf = cmd_capture_pane_pending(args, wp, &len);\n\telse\n\t\tbuf = cmd_capture_pane_history(args, item, wp, &len);\n\tif (buf == NULL)\n\t\treturn (CMD_RETURN_ERROR);\n\n\tif (args_has(args, 'p')) {\n\t\tif (len > 0 && buf[len - 1] == '\\n')\n\t\t\tlen--;\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tcontrol_write(c, \"%.*s\", (int)len, buf);\n\t\telse {\n\t\t\tif (!file_can_print(c)) {\n\t\t\t\tcmdq_error(item, \"can't write to client\");\n\t\t\t\tfree(buf);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\tfile_print_buffer(c, buf, len);\n\t\t\tfile_print(c, \"\\n\");\n\t\t\tfree(buf);\n\t\t}\n\t} else {\n\t\tbufname = NULL;\n\t\tif (args_has(args, 'b'))\n\t\t\tbufname = args_get(args, 'b');\n\n\t\tif (paste_set(buf, len, bufname, &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tfree(buf);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-choose-tree.c",
          "type": "blob",
          "size": 3.33984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Thomas Adam <thomas@xteddy.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Enter a mode.\n */\n\nstatic enum args_parse_type\tcmd_choose_tree_args_parse(struct args *args,\n\t\t\t\t    u_int idx, char **cause);\nstatic enum cmd_retval\t\tcmd_choose_tree_exec(struct cmd *,\n    \t\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_choose_tree_entry = {\n\t.name = \"choose-tree\",\n\t.alias = NULL,\n\n\t.args = { \"F:f:GK:NO:rst:wyZ\", 0, 1, cmd_choose_tree_args_parse },\n\t.usage = \"[-GNrswZ] [-F format] [-f filter] [-K key-format] \"\n\t\t \"[-O sort-order] \" CMD_TARGET_PANE_USAGE \" [template]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nconst struct cmd_entry cmd_choose_client_entry = {\n\t.name = \"choose-client\",\n\t.alias = NULL,\n\n\t.args = { \"F:f:K:NO:rt:yZ\", 0, 1, cmd_choose_tree_args_parse },\n\t.usage = \"[-NrZ] [-F format] [-f filter] [-K key-format] \"\n\t\t \"[-O sort-order] \" CMD_TARGET_PANE_USAGE \" [template]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nconst struct cmd_entry cmd_choose_buffer_entry = {\n\t.name = \"choose-buffer\",\n\t.alias = NULL,\n\n\t.args = { \"F:f:K:NO:rt:yZ\", 0, 1, cmd_choose_tree_args_parse },\n\t.usage = \"[-NrZ] [-F format] [-f filter] [-K key-format] \"\n\t\t \"[-O sort-order] \" CMD_TARGET_PANE_USAGE \" [template]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nconst struct cmd_entry cmd_customize_mode_entry = {\n\t.name = \"customize-mode\",\n\t.alias = NULL,\n\n\t.args = { \"F:f:Nt:yZ\", 0, 0, NULL },\n\t.usage = \"[-NZ] [-F format] [-f filter] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nstatic enum args_parse_type\ncmd_choose_tree_args_parse(__unused struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n}\n\nstatic enum cmd_retval\ncmd_choose_tree_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct window_pane\t\t*wp = target->wp;\n\tconst struct window_mode\t*mode;\n\n\tif (cmd_get_entry(self) == &cmd_choose_buffer_entry) {\n\t\tif (paste_is_empty())\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tmode = &window_buffer_mode;\n\t} else if (cmd_get_entry(self) == &cmd_choose_client_entry) {\n\t\tif (server_client_how_many() == 0)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tmode = &window_client_mode;\n\t} else if (cmd_get_entry(self) == &cmd_customize_mode_entry)\n\t\tmode = &window_customize_mode;\n\telse\n\t\tmode = &window_tree_mode;\n\n\twindow_pane_set_mode(wp, NULL, mode, target, args);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-command-prompt.c",
          "type": "blob",
          "size": 6.2861328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Prompt for command in client.\n */\n\nstatic enum args_parse_type\tcmd_command_prompt_args_parse(struct args *,\n\t\t\t\t    u_int, char **);\nstatic enum cmd_retval\t\tcmd_command_prompt_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nstatic int\tcmd_command_prompt_callback(struct client *, void *,\n\t\t    const char *, int);\nstatic void\tcmd_command_prompt_free(void *);\n\nconst struct cmd_entry cmd_command_prompt_entry = {\n\t.name = \"command-prompt\",\n\t.alias = NULL,\n\n\t.args = { \"1bFkiI:Np:t:T:\", 0, 1, cmd_command_prompt_args_parse },\n\t.usage = \"[-1bFkiN] [-I inputs] [-p prompts] \" CMD_TARGET_CLIENT_USAGE\n\t\t \" [-T type] [template]\",\n\n\t.flags = CMD_CLIENT_TFLAG,\n\t.exec = cmd_command_prompt_exec\n};\n\nstruct cmd_command_prompt_prompt {\n\tchar\t*input;\n\tchar\t*prompt;\n};\n\nstruct cmd_command_prompt_cdata {\n\tstruct cmdq_item\t\t *item;\n\tstruct args_command_state\t *state;\n\n\tint\t\t\t\t  flags;\n\tenum prompt_type\t\t  prompt_type;\n\n\tstruct cmd_command_prompt_prompt *prompts;\n\tu_int\t\t\t\t  count;\n\tu_int\t\t\t\t  current;\n\n\tint\t\t\t\t  argc;\n\tchar\t\t\t\t**argv;\n};\n\nstatic enum args_parse_type\ncmd_command_prompt_args_parse(__unused struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n}\n\nstatic enum cmd_retval\ncmd_command_prompt_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tconst char\t\t\t*type, *s, *input;\n\tstruct cmd_command_prompt_cdata\t*cdata;\n\tchar\t\t\t\t*tmp, *prompts, *prompt, *next_prompt;\n\tchar\t\t\t\t*inputs = NULL, *next_input;\n\tu_int\t\t\t\t count = args_count(args);\n\tint\t\t\t\t wait = !args_has(args, 'b'), space = 1;\n\n\tif (tc->prompt_string != NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\tif (args_has(args, 'i'))\n\t\twait = 0;\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tif (wait)\n\t\tcdata->item = item;\n\tcdata->state = args_make_commands_prepare(self, item, 0, \"%1\", wait,\n\t    args_has(args, 'F'));\n\n\tif ((s = args_get(args, 'p')) == NULL) {\n\t\tif (count != 0) {\n\t\t\ttmp = args_make_commands_get_command(cdata->state);\n\t\t\txasprintf(&prompts, \"(%s)\", tmp);\n\t\t\tfree(tmp);\n\t\t} else {\n\t\t\tprompts = xstrdup(\":\");\n\t\t\tspace = 0;\n\t\t}\n\t\tnext_prompt = prompts;\n\t} else\n\t\tnext_prompt = prompts = xstrdup(s);\n\tif ((s = args_get(args, 'I')) != NULL)\n\t\tnext_input = inputs = xstrdup(s);\n\telse\n\t\tnext_input = NULL;\n\twhile ((prompt = strsep(&next_prompt, \",\")) != NULL) {\n\t\tcdata->prompts = xreallocarray(cdata->prompts, cdata->count + 1,\n\t\t    sizeof *cdata->prompts);\n\t\tif (!space)\n\t\t\ttmp = xstrdup(prompt);\n\t\telse\n\t\t\txasprintf(&tmp, \"%s \", prompt);\n\t\tcdata->prompts[cdata->count].prompt = tmp;\n\n\t\tif (next_input != NULL) {\n\t\t\tinput = strsep(&next_input, \",\");\n\t\t\tif (input == NULL)\n\t\t\t\tinput = \"\";\n\t\t} else\n\t\t\tinput = \"\";\n\t\tcdata->prompts[cdata->count].input = xstrdup(input);\n\n\t\tcdata->count++;\n\t}\n\tfree(inputs);\n\tfree(prompts);\n\n\tif ((type = args_get(args, 'T')) != NULL) {\n\t\tcdata->prompt_type = status_prompt_type(type);\n\t\tif (cdata->prompt_type == PROMPT_TYPE_INVALID) {\n\t\t\tcmdq_error(item, \"unknown type: %s\", type);\n\t\t\tcmd_command_prompt_free(cdata);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else\n\t\tcdata->prompt_type = PROMPT_TYPE_COMMAND;\n\n\tif (args_has(args, '1'))\n\t\tcdata->flags |= PROMPT_SINGLE;\n\telse if (args_has(args, 'N'))\n\t\tcdata->flags |= PROMPT_NUMERIC;\n\telse if (args_has(args, 'i'))\n\t\tcdata->flags |= PROMPT_INCREMENTAL;\n\telse if (args_has(args, 'k'))\n\t\tcdata->flags |= PROMPT_KEY;\n\tstatus_prompt_set(tc, target, cdata->prompts[0].prompt,\n\t    cdata->prompts[0].input, cmd_command_prompt_callback,\n\t    cmd_command_prompt_free, cdata, cdata->flags, cdata->prompt_type);\n\n\tif (!wait)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic int\ncmd_command_prompt_callback(struct client *c, void *data, const char *s,\n    int done)\n{\n\tstruct cmd_command_prompt_cdata\t\t *cdata = data;\n\tchar\t\t\t\t\t *error;\n\tstruct cmdq_item\t\t\t *item = cdata->item, *new_item;\n\tstruct cmd_list\t\t\t\t *cmdlist;\n\tstruct cmd_command_prompt_prompt\t *prompt;\n\tint\t\t\t\t\t  argc = 0;\n\tchar\t\t\t\t\t**argv = NULL;\n\n\tif (s == NULL)\n\t\tgoto out;\n\n\tif (done) {\n\t\tif (cdata->flags & PROMPT_INCREMENTAL)\n\t\t\tgoto out;\n\t\tcmd_append_argv(&cdata->argc, &cdata->argv, s);\n\t\tif (++cdata->current != cdata->count) {\n\t\t\tprompt = &cdata->prompts[cdata->current];\n\t\t\tstatus_prompt_update(c, prompt->prompt, prompt->input);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\targc = cdata->argc;\n\targv = cmd_copy_argv(cdata->argc, cdata->argv);\n\tif (!done)\n\t\tcmd_append_argv(&argc, &argv, s);\n\n\tif (done) {\n\t\tcmd_free_argv(cdata->argc, cdata->argv);\n\t\tcdata->argc = argc;\n\t\tcdata->argv = cmd_copy_argv(argc, argv);\n\t}\n\n\tcmdlist = args_make_commands(cdata->state, argc, argv, &error);\n\tif (cmdlist == NULL) {\n\t\tcmdq_append(c, cmdq_get_error(error));\n\t\tfree(error);\n\t} else if (item == NULL) {\n\t\tnew_item = cmdq_get_command(cmdlist, NULL);\n\t\tcmdq_append(c, new_item);\n\t} else {\n\t\tnew_item = cmdq_get_command(cmdlist, cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t}\n\tcmd_free_argv(argc, argv);\n\n\tif (c->prompt_inputcb != cmd_command_prompt_callback)\n\t\treturn (1);\n\nout:\n\tif (item != NULL)\n\t\tcmdq_continue(item);\n\treturn (0);\n}\n\nstatic void\ncmd_command_prompt_free(void *data)\n{\n\tstruct cmd_command_prompt_cdata\t*cdata = data;\n\tu_int\t\t\t\t i;\n\n\tfor (i = 0; i < cdata->count; i++) {\n\t\tfree(cdata->prompts[i].prompt);\n\t\tfree(cdata->prompts[i].input);\n\t}\n\tfree(cdata->prompts);\n\tcmd_free_argv(cdata->argc, cdata->argv);\n\targs_make_commands_free(cdata->state);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-confirm-before.c",
          "type": "blob",
          "size": 4.255859375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Asks for confirmation before executing a command.\n */\n\nstatic enum args_parse_type\tcmd_confirm_before_args_parse(struct args *,\n\t\t\t\t    u_int, char **);\nstatic enum cmd_retval\t\tcmd_confirm_before_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nstatic int\tcmd_confirm_before_callback(struct client *, void *,\n\t\t    const char *, int);\nstatic void\tcmd_confirm_before_free(void *);\n\nconst struct cmd_entry cmd_confirm_before_entry = {\n\t.name = \"confirm-before\",\n\t.alias = \"confirm\",\n\n\t.args = { \"bc:p:t:y\", 1, 1, cmd_confirm_before_args_parse },\n\t.usage = \"[-by] [-c confirm_key] [-p prompt] \" CMD_TARGET_CLIENT_USAGE\n\t\t \" command\",\n\n\t.flags = CMD_CLIENT_TFLAG,\n\t.exec = cmd_confirm_before_exec\n};\n\nstruct cmd_confirm_before_data {\n\tstruct cmdq_item\t*item;\n\tstruct cmd_list\t\t*cmdlist;\n\tu_char\t\t\t confirm_key;\n\tint\t\t\t default_yes;\n};\n\nstatic enum args_parse_type\ncmd_confirm_before_args_parse(__unused struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n}\n\nstatic enum cmd_retval\ncmd_confirm_before_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_confirm_before_data\t*cdata;\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tchar\t\t\t\t*new_prompt;\n\tconst char\t\t\t*confirm_key, *prompt, *cmd;\n\tint\t\t\t\t wait = !args_has(args, 'b');\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tcdata->cmdlist = args_make_commands_now(self, item, 0, 1);\n\tif (cdata->cmdlist == NULL) {\n\t\tfree(cdata);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wait)\n\t\tcdata->item = item;\n\n\tcdata->default_yes = args_has(args, 'y');\n\tif ((confirm_key = args_get(args, 'c')) != NULL) {\n\t\tif (confirm_key[1] == '\\0' &&\n\t\t    confirm_key[0] > 31 &&\n\t\t    confirm_key[0] < 127)\n\t\t\tcdata->confirm_key = confirm_key[0];\n\t\telse {\n\t\t\tcmdq_error(item, \"invalid confirm key\");\n\t\t\tfree(cdata);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\telse\n\t\tcdata->confirm_key = 'y';\n\n\tif ((prompt = args_get(args, 'p')) != NULL)\n\t\txasprintf(&new_prompt, \"%s \", prompt);\n\telse {\n\t\tcmd = cmd_get_entry(cmd_list_first(cdata->cmdlist))->name;\n\t\txasprintf(&new_prompt, \"Confirm '%s'? (%c/n) \", cmd,\n\t\t    cdata->confirm_key);\n\t}\n\n\tstatus_prompt_set(tc, target, new_prompt, NULL,\n\t    cmd_confirm_before_callback, cmd_confirm_before_free, cdata,\n\t    PROMPT_SINGLE, PROMPT_TYPE_COMMAND);\n\tfree(new_prompt);\n\n\tif (!wait)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic int\ncmd_confirm_before_callback(struct client *c, void *data, const char *s,\n    __unused int done)\n{\n\tstruct cmd_confirm_before_data\t*cdata = data;\n\tstruct cmdq_item\t\t*item = cdata->item, *new_item;\n\tint\t\t\t\t retcode = 1;\n\n\tif (c->flags & CLIENT_DEAD)\n\t\tgoto out;\n\n\tif (s == NULL)\n\t\tgoto out;\n\tif (s[0] != cdata->confirm_key && (s[0] != '\\r' || !cdata->default_yes))\n\t\tgoto out;\n\tretcode = 0;\n\n\tif (item == NULL) {\n\t\tnew_item = cmdq_get_command(cdata->cmdlist, NULL);\n\t\tcmdq_append(c, new_item);\n\t} else {\n\t\tnew_item = cmdq_get_command(cdata->cmdlist,\n\t\t    cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t}\n\nout:\n\tif (item != NULL) {\n\t\tif (cmdq_get_client(item) != NULL &&\n\t\t    cmdq_get_client(item)->session == NULL)\n\t\t\tcmdq_get_client(item)->retval = retcode;\n\t\tcmdq_continue(item);\n\t}\n\treturn (0);\n}\n\nstatic void\ncmd_confirm_before_free(void *data)\n{\n\tstruct cmd_confirm_before_data\t*cdata = data;\n\n\tcmd_list_free(cdata->cmdlist);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-copy-mode.c",
          "type": "blob",
          "size": 2.849609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Enter copy or clock mode.\n */\n\nstatic enum cmd_retval\tcmd_copy_mode_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_copy_mode_entry = {\n\t.name = \"copy-mode\",\n\t.alias = NULL,\n\n\t.args = { \"deHMqSs:t:u\", 0, 0, NULL },\n\t.usage = \"[-deHMqSu] [-s src-pane] \" CMD_TARGET_PANE_USAGE,\n\n\t.source =  { 's', CMD_FIND_PANE, 0 },\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_copy_mode_exec\n};\n\nconst struct cmd_entry cmd_clock_mode_entry = {\n\t.name = \"clock-mode\",\n\t.alias = NULL,\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_copy_mode_exec\n};\n\nstatic enum cmd_retval\ncmd_copy_mode_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct key_event\t*event = cmdq_get_event(item);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp = target->wp, *swp;\n\n\tif (args_has(args, 'q')) {\n\t\twindow_pane_reset_mode_all(wp);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'M')) {\n\t\tif ((wp = cmd_mouse_pane(&event->m, &s, NULL)) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (c == NULL || c->session != s)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (cmd_get_entry(self) == &cmd_clock_mode_entry) {\n\t\twindow_pane_set_mode(wp, NULL, &window_clock_mode, NULL, NULL);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 's'))\n\t\tswp = source->wp;\n\telse\n\t\tswp = wp;\n\tif (!window_pane_set_mode(wp, swp, &window_copy_mode, NULL, args)) {\n\t\tif (args_has(args, 'M'))\n\t\t\twindow_copy_start_drag(c, &event->m);\n\t}\n\tif (args_has(args, 'u'))\n\t\twindow_copy_pageup(wp, 0);\n\tif (args_has(args, 'd'))\n\t\twindow_copy_pagedown(wp, 0, args_has(args, 'e'));\n\tif (args_has(args, 'S')) {\n\t\twindow_copy_scroll(wp, c->tty.mouse_slider_mpos, event->m.y,\n\t\t    args_has(args, 'e'));\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-detach-client.c",
          "type": "blob",
          "size": 2.7822265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Detach a client.\n */\n\nstatic enum cmd_retval\tcmd_detach_client_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_detach_client_entry = {\n\t.name = \"detach-client\",\n\t.alias = \"detach\",\n\n\t.args = { \"aE:s:t:P\", 0, 0, NULL },\n\t.usage = \"[-aP] [-E shell-command] \"\n\t         \"[-s target-session] \" CMD_TARGET_CLIENT_USAGE,\n\n\t.source = { 's', CMD_FIND_SESSION, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_READONLY|CMD_CLIENT_TFLAG,\n\t.exec = cmd_detach_client_exec\n};\n\nconst struct cmd_entry cmd_suspend_client_entry = {\n\t.name = \"suspend-client\",\n\t.alias = \"suspendc\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_CLIENT_USAGE,\n\n\t.flags = CMD_CLIENT_TFLAG,\n\t.exec = cmd_detach_client_exec\n};\n\nstatic enum cmd_retval\ncmd_detach_client_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct client\t\t*tc = cmdq_get_target_client(item), *loop;\n\tstruct session\t\t*s;\n\tenum msgtype\t\t msgtype;\n\tconst char\t\t*cmd = args_get(args, 'E');\n\n\tif (cmd_get_entry(self) == &cmd_suspend_client_entry) {\n\t\tserver_client_suspend(tc);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'P'))\n\t\tmsgtype = MSG_DETACHKILL;\n\telse\n\t\tmsgtype = MSG_DETACH;\n\n\tif (args_has(args, 's')) {\n\t\ts = source->s;\n\t\tif (s == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\t\tif (loop->session == s) {\n\t\t\t\tif (cmd != NULL)\n\t\t\t\t\tserver_client_exec(loop, cmd);\n\t\t\t\telse\n\t\t\t\t\tserver_client_detach(loop, msgtype);\n\t\t\t}\n\t\t}\n\t\treturn (CMD_RETURN_STOP);\n\t}\n\n\tif (args_has(args, 'a')) {\n\t\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\t\tif (loop->session != NULL && loop != tc) {\n\t\t\t\tif (cmd != NULL)\n\t\t\t\t\tserver_client_exec(loop, cmd);\n\t\t\t\telse\n\t\t\t\t\tserver_client_detach(loop, msgtype);\n\t\t\t}\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (cmd != NULL)\n\t\tserver_client_exec(tc, cmd);\n\telse\n\t\tserver_client_detach(tc, msgtype);\n\treturn (CMD_RETURN_STOP);\n}\n"
        },
        {
          "name": "cmd-display-menu.c",
          "type": "blob",
          "size": 13.4677734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Display a menu on a client.\n */\n\nstatic enum args_parse_type\tcmd_display_menu_args_parse(struct args *,\n\t\t\t\t    u_int, char **);\nstatic enum cmd_retval\t\tcmd_display_menu_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\nstatic enum cmd_retval\t\tcmd_display_popup_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_display_menu_entry = {\n\t.name = \"display-menu\",\n\t.alias = \"menu\",\n\n\t.args = { \"b:c:C:H:s:S:MOt:T:x:y:\", 1, -1, cmd_display_menu_args_parse },\n\t.usage = \"[-MO] [-b border-lines] [-c target-client] \"\n\t\t \"[-C starting-choice] [-H selected-style] [-s style] \"\n\t\t \"[-S border-style] \" CMD_TARGET_PANE_USAGE \"[-T title] \"\n\t\t \"[-x position] [-y position] name key command ...\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_CFLAG,\n\t.exec = cmd_display_menu_exec\n};\n\nconst struct cmd_entry cmd_display_popup_entry = {\n\t.name = \"display-popup\",\n\t.alias = \"popup\",\n\n\t.args = { \"Bb:Cc:d:e:Eh:s:S:t:T:w:x:y:\", 0, -1, NULL },\n\t.usage = \"[-BCE] [-b border-lines] [-c target-client] \"\n\t\t \"[-d start-directory] [-e environment] [-h height] \"\n\t\t \"[-s style] [-S border-style] \" CMD_TARGET_PANE_USAGE\n\t\t \"[-T title] [-w width] [-x position] [-y position] \"\n\t\t \"[shell-command]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_CFLAG,\n\t.exec = cmd_display_popup_exec\n};\n\nstatic enum args_parse_type\ncmd_display_menu_args_parse(struct args *args, u_int idx, __unused char **cause)\n{\n\tu_int\t\t\t i = 0;\n\tenum args_parse_type\t type = ARGS_PARSE_STRING;\n\n\tfor (;;) {\n\t\ttype = ARGS_PARSE_STRING;\n\t\tif (i == idx)\n\t\t\tbreak;\n\t\tif (*args_string(args, i++) == '\\0')\n\t\t\tcontinue;\n\n\t\ttype = ARGS_PARSE_STRING;\n\t\tif (i++ == idx)\n\t\t\tbreak;\n\n\t\ttype = ARGS_PARSE_COMMANDS_OR_STRING;\n\t\tif (i++ == idx)\n\t\t\tbreak;\n\t}\n\treturn (type);\n}\n\nstatic int\ncmd_display_menu_get_position(struct client *tc, struct cmdq_item *item,\n    struct args *args, u_int *px, u_int *py, u_int w, u_int h)\n{\n\tstruct tty\t\t*tty = &tc->tty;\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct key_event\t*event = cmdq_get_event(item);\n\tstruct session\t\t*s = tc->session;\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window_pane\t*wp = target->wp;\n\tstruct style_ranges\t*ranges = NULL;\n\tstruct style_range\t*sr = NULL;\n\tconst char\t\t*xp, *yp;\n\tchar\t\t\t*p;\n\tint\t\t\t top;\n\tu_int\t\t\t line, ox, oy, sx, sy, lines, position;\n\tlong\t\t\t n;\n\tstruct format_tree\t*ft;\n\n\t/*\n\t * Work out the position from the -x and -y arguments. This is the\n\t * bottom-left position.\n\t */\n\n\t/* If the popup is too big, stop now. */\n\tif (w > tty->sx || h > tty->sy)\n\t\treturn (0);\n\n\t/* Create format with mouse position if any. */\n\tft = format_create_from_target(item);\n\tif (event->m.valid) {\n\t\tformat_add(ft, \"popup_mouse_x\", \"%u\", event->m.x);\n\t\tformat_add(ft, \"popup_mouse_y\", \"%u\", event->m.y);\n\t}\n\n\t/*\n\t * If there are any status lines, add this window position and the\n\t * status line position.\n\t */\n\ttop = status_at_line(tc);\n\tif (top != -1) {\n\t\tlines = status_line_size(tc);\n\t\tif (top == 0)\n\t\t\ttop = lines;\n\t\telse\n\t\t\ttop = 0;\n\t\tposition = options_get_number(s->options, \"status-position\");\n\n\t\tfor (line = 0; line < lines; line++) {\n\t\t\tranges = &tc->status.entries[line].ranges;\n\t\t\tTAILQ_FOREACH(sr, ranges, entry) {\n\t\t\t\tif (sr->type != STYLE_RANGE_WINDOW)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sr->argument == (u_int)wl->idx)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sr != NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sr != NULL) {\n\t\t\tformat_add(ft, \"popup_window_status_line_x\", \"%u\",\n\t\t\t    sr->start);\n\t\t\tif (position == 0) {\n\t\t\t\tformat_add(ft, \"popup_window_status_line_y\",\n\t\t\t\t    \"%u\", line + 1 + h);\n\t\t\t} else {\n\t\t\t\tformat_add(ft, \"popup_window_status_line_y\",\n\t\t\t\t    \"%u\", tty->sy - lines + line);\n\t\t\t}\n\t\t}\n\n\t\tif (position == 0)\n\t\t\tformat_add(ft, \"popup_status_line_y\", \"%u\", lines + h);\n\t\telse {\n\t\t\tformat_add(ft, \"popup_status_line_y\", \"%u\",\n\t\t\t    tty->sy - lines);\n\t\t}\n\t} else\n\t\ttop = 0;\n\n\t/* Popup width and height. */\n\tformat_add(ft, \"popup_width\", \"%u\", w);\n\tformat_add(ft, \"popup_height\", \"%u\", h);\n\n\t/* Position so popup is in the centre. */\n\tn = (long)(tty->sx - 1) / 2 - w / 2;\n\tif (n < 0)\n\t\tformat_add(ft, \"popup_centre_x\", \"%u\", 0);\n\telse\n\t\tformat_add(ft, \"popup_centre_x\", \"%ld\", n);\n\tn = (tty->sy - 1) / 2 + h / 2;\n\tif (n >= tty->sy)\n\t\tformat_add(ft, \"popup_centre_y\", \"%u\", tty->sy - h);\n\telse\n\t\tformat_add(ft, \"popup_centre_y\", \"%ld\", n);\n\n\t/* Position of popup relative to mouse. */\n\tif (event->m.valid) {\n\t\tn = (long)event->m.x - w / 2;\n\t\tif (n < 0)\n\t\t\tformat_add(ft, \"popup_mouse_centre_x\", \"%u\", 0);\n\t\telse\n\t\t\tformat_add(ft, \"popup_mouse_centre_x\", \"%ld\", n);\n\t\tn = event->m.y - h / 2;\n\t\tif (n + h >= tty->sy) {\n\t\t\tformat_add(ft, \"popup_mouse_centre_y\", \"%u\",\n\t\t\t    tty->sy - h);\n\t\t} else\n\t\t\tformat_add(ft, \"popup_mouse_centre_y\", \"%ld\", n);\n\t\tn = (long)event->m.y + h;\n\t\tif (n >= tty->sy)\n\t\t\tformat_add(ft, \"popup_mouse_top\", \"%u\", tty->sy - 1);\n\t\telse\n\t\t\tformat_add(ft, \"popup_mouse_top\", \"%ld\", n);\n\t\tn = event->m.y - h;\n\t\tif (n < 0)\n\t\t\tformat_add(ft, \"popup_mouse_bottom\", \"%u\", 0);\n\t\telse\n\t\t\tformat_add(ft, \"popup_mouse_bottom\", \"%ld\", n);\n\t}\n\n\t/* Position in pane. */\n\ttty_window_offset(&tc->tty, &ox, &oy, &sx, &sy);\n\tn = top + wp->yoff - oy + h;\n\tif (n >= tty->sy)\n\t\tformat_add(ft, \"popup_pane_top\", \"%u\", tty->sy - h);\n\telse\n\t\tformat_add(ft, \"popup_pane_top\", \"%ld\", n);\n\tformat_add(ft, \"popup_pane_bottom\", \"%u\", top + wp->yoff + wp->sy - oy);\n\tformat_add(ft, \"popup_pane_left\", \"%u\", wp->xoff - ox);\n\tn = (long)wp->xoff + wp->sx - ox - w;\n\tif (n < 0)\n\t\tformat_add(ft, \"popup_pane_right\", \"%u\", 0);\n\telse\n\t\tformat_add(ft, \"popup_pane_right\", \"%ld\", n);\n\n\t/* Expand horizontal position. */\n\txp = args_get(args, 'x');\n\tif (xp == NULL || strcmp(xp, \"C\") == 0)\n\t\txp = \"#{popup_centre_x}\";\n\telse if (strcmp(xp, \"R\") == 0)\n\t\txp = \"#{popup_pane_right}\";\n\telse if (strcmp(xp, \"P\") == 0)\n\t\txp = \"#{popup_pane_left}\";\n\telse if (strcmp(xp, \"M\") == 0)\n\t\txp = \"#{popup_mouse_centre_x}\";\n\telse if (strcmp(xp, \"W\") == 0)\n\t\txp = \"#{popup_window_status_line_x}\";\n\tp = format_expand(ft, xp);\n\tn = strtol(p, NULL, 10);\n\tif (n + w >= tty->sx)\n\t\tn = tty->sx - w;\n\telse if (n < 0)\n\t\tn = 0;\n\t*px = n;\n\tlog_debug(\"%s: -x: %s = %s = %u (-w %u)\", __func__, xp, p, *px, w);\n\tfree(p);\n\n\t/* Expand vertical position  */\n\typ = args_get(args, 'y');\n\tif (yp == NULL || strcmp(yp, \"C\") == 0)\n\t\typ = \"#{popup_centre_y}\";\n\telse if (strcmp(yp, \"P\") == 0)\n\t\typ = \"#{popup_pane_bottom}\";\n\telse if (strcmp(yp, \"M\") == 0)\n\t\typ = \"#{popup_mouse_top}\";\n\telse if (strcmp(yp, \"S\") == 0)\n\t\typ = \"#{popup_status_line_y}\";\n\telse if (strcmp(yp, \"W\") == 0)\n\t\typ = \"#{popup_window_status_line_y}\";\n\tp = format_expand(ft, yp);\n\tn = strtol(p, NULL, 10);\n\tif (n < h)\n\t\tn = 0;\n\telse\n\t\tn -= h;\n\tif (n + h >= tty->sy)\n\t\tn = tty->sy - h;\n\telse if (n < 0)\n\t\tn = 0;\n\t*py = n;\n\tlog_debug(\"%s: -y: %s = %s = %u (-h %u)\", __func__, yp, p, *py, h);\n\tfree(p);\n\n\tformat_free(ft);\n\treturn (1);\n}\n\nstatic enum cmd_retval\ncmd_display_menu_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct key_event\t*event = cmdq_get_event(item);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct menu\t\t*menu = NULL;\n\tstruct menu_item\t menu_item;\n\tconst char\t\t*key, *name, *value;\n\tconst char\t\t*style = args_get(args, 's');\n\tconst char\t\t*border_style = args_get(args, 'S');\n\tconst char\t\t*selected_style = args_get(args, 'H');\n\tenum box_lines\t\t lines = BOX_LINES_DEFAULT;\n\tchar\t\t\t*title, *cause;\n\tint\t\t\t flags = 0, starting_choice = 0;\n\tu_int\t\t\t px, py, i, count = args_count(args);\n\tstruct options\t\t*o = target->s->curw->window->options;\n\tstruct options_entry\t*oe;\n\n\n\tif (tc->overlay_draw != NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (args_has(args, 'C')) {\n\t\tif (strcmp(args_get(args, 'C'), \"-\") == 0)\n\t\t\tstarting_choice = -1;\n\t\telse {\n\t\t\tstarting_choice = args_strtonum(args, 'C', 0, UINT_MAX,\n\t\t\t    &cause);\n\t\t\tif (cause != NULL) {\n\t\t\t\tcmdq_error(item, \"starting choice %s\", cause);\n\t\t\t\tfree(cause);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (args_has(args, 'T'))\n\t\ttitle = format_single_from_target(item, args_get(args, 'T'));\n\telse\n\t\ttitle = xstrdup(\"\");\n\tmenu = menu_create(title);\n\tfree(title);\n\n\tfor (i = 0; i != count; /* nothing */) {\n\t\tname = args_string(args, i++);\n\t\tif (*name == '\\0') {\n\t\t\tmenu_add_item(menu, NULL, item, tc, target);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (count - i < 2) {\n\t\t\tcmdq_error(item, \"not enough arguments\");\n\t\t\tmenu_free(menu);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tkey = args_string(args, i++);\n\n\t\tmenu_item.name = name;\n\t\tmenu_item.key = key_string_lookup_string(key);\n\t\tmenu_item.command = args_string(args, i++);\n\n\t\tmenu_add_item(menu, &menu_item, item, tc, target);\n\t}\n\tif (menu == NULL) {\n\t\tcmdq_error(item, \"invalid menu arguments\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (menu->count == 0) {\n\t\tmenu_free(menu);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (!cmd_display_menu_get_position(tc, item, args, &px, &py,\n\t    menu->width + 4, menu->count + 2)) {\n\t\tmenu_free(menu);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tvalue = args_get(args, 'b');\n\tif (value != NULL) {\n\t\toe = options_get(o, \"menu-border-lines\");\n\t\tlines = options_find_choice(options_table_entry(oe), value,\n\t\t    &cause);\n\t\tif (lines == -1) {\n\t\t\tcmdq_error(item, \"menu-border-lines %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(args, 'O'))\n\t\tflags |= MENU_STAYOPEN;\n\tif (!event->m.valid && !args_has(args, 'M'))\n\t\tflags |= MENU_NOMOUSE;\n\tif (menu_display(menu, flags, starting_choice, item, px, py, tc, lines,\n\t    style, selected_style, border_style, target, NULL, NULL) != 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic enum cmd_retval\ncmd_display_popup_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct session\t\t*s = target->s;\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct tty\t\t*tty = &tc->tty;\n\tconst char\t\t*value, *shell, *shellcmd = NULL;\n\tconst char\t\t*style = args_get(args, 's');\n\tconst char\t\t*border_style = args_get(args, 'S');\n\tchar\t\t\t*cwd, *cause = NULL, **argv = NULL, *title;\n\tint\t\t\t flags = 0, argc = 0;\n\tenum box_lines\t\t lines = BOX_LINES_DEFAULT;\n\tu_int\t\t\t px, py, w, h, count = args_count(args);\n\tstruct args_value\t*av;\n\tstruct environ\t\t*env = NULL;\n\tstruct options\t\t*o = s->curw->window->options;\n\tstruct options_entry\t*oe;\n\n\tif (args_has(args, 'C')) {\n\t\tserver_client_clear_overlay(tc);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (tc->overlay_draw != NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\th = tty->sy / 2;\n\tif (args_has(args, 'h')) {\n\t\th = args_percentage(args, 'h', 1, tty->sy, tty->sy, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"height %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tw = tty->sx / 2;\n\tif (args_has(args, 'w')) {\n\t\tw = args_percentage(args, 'w', 1, tty->sx, tty->sx, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"width %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (w > tty->sx)\n\t\tw = tty->sx;\n\tif (h > tty->sy)\n\t\th = tty->sy;\n\tif (!cmd_display_menu_get_position(tc, item, args, &px, &py, w, h))\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tvalue = args_get(args, 'b');\n\tif (args_has(args, 'B'))\n\t\tlines = BOX_LINES_NONE;\n\telse if (value != NULL) {\n\t\toe = options_get(o, \"popup-border-lines\");\n\t\tlines = options_find_choice(options_table_entry(oe), value,\n\t\t    &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"popup-border-lines %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tvalue = args_get(args, 'd');\n\tif (value != NULL)\n\t\tcwd = format_single_from_target(item, value);\n\telse\n\t\tcwd = xstrdup(server_client_get_cwd(tc, s));\n\tif (count == 0)\n\t\tshellcmd = options_get_string(s->options, \"default-command\");\n\telse if (count == 1)\n\t\tshellcmd = args_string(args, 0);\n\tif (count <= 1 && (shellcmd == NULL || *shellcmd == '\\0')) {\n\t\tshellcmd = NULL;\n\t\tshell = options_get_string(s->options, \"default-shell\");\n\t\tif (!checkshell(shell))\n\t\t\tshell = _PATH_BSHELL;\n\t\tcmd_append_argv(&argc, &argv, shell);\n\t} else\n\t\targs_to_vector(args, &argc, &argv);\n\n\tif (args_has(args, 'e') >= 1) {\n\t\tenv = environ_create();\n\t\tav = args_first_value(args, 'e');\n\t\twhile (av != NULL) {\n\t\t\tenviron_put(env, av->string, 0);\n\t\t\tav = args_next_value(av);\n\t\t}\n\t}\n\n\tif (args_has(args, 'T'))\n\t\ttitle = format_single_from_target(item, args_get(args, 'T'));\n\telse\n\t\ttitle = xstrdup(\"\");\n\tif (args_has(args, 'E') > 1)\n\t\tflags |= POPUP_CLOSEEXITZERO;\n\telse if (args_has(args, 'E'))\n\t\tflags |= POPUP_CLOSEEXIT;\n\tif (popup_display(flags, lines, item, px, py, w, h, env, shellcmd, argc,\n\t    argv, cwd, title, tc, s, style, border_style, NULL, NULL) != 0) {\n\t\tcmd_free_argv(argc, argv);\n\t\tif (env != NULL)\n\t\t\tenviron_free(env);\n\t\tfree(cwd);\n\t\tfree(title);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (env != NULL)\n\t\tenviron_free(env);\n\tfree(cwd);\n\tfree(title);\n\tcmd_free_argv(argc, argv);\n\treturn (CMD_RETURN_WAIT);\n}\n"
        },
        {
          "name": "cmd-display-message.c",
          "type": "blob",
          "size": 4.259765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Displays a message in the status line.\n */\n\n#define DISPLAY_MESSAGE_TEMPLATE\t\t\t\\\n\t\"[#{session_name}] #{window_index}:\"\t\t\\\n\t\"#{window_name}, current pane #{pane_index} \"\t\\\n\t\"- (%H:%M %d-%b-%y)\"\n\nstatic enum cmd_retval\tcmd_display_message_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_display_message_entry = {\n\t.name = \"display-message\",\n\t.alias = \"display\",\n\n\t.args = { \"ac:d:lINpt:F:v\", 0, 1, NULL },\n\t.usage = \"[-aIlNpv] [-c target-client] [-d delay] [-F format] \"\n\t\t CMD_TARGET_PANE_USAGE \" [message]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_CFLAG|CMD_CLIENT_CANFAIL,\n\t.exec = cmd_display_message_exec\n};\n\nstatic void\ncmd_display_message_each(const char *key, const char *value, void *arg)\n{\n\tstruct cmdq_item\t*item = arg;\n\n\tcmdq_print(item, \"%s=%s\", key, value);\n}\n\nstatic enum cmd_retval\ncmd_display_message_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*tc = cmdq_get_target_client(item), *c;\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window_pane\t*wp = target->wp;\n\tconst char\t\t*template;\n\tchar\t\t\t*msg, *cause;\n\tint\t\t\t delay = -1, flags, Nflag = args_has(args, 'N');\n\tstruct format_tree\t*ft;\n\tu_int\t\t\t count = args_count(args);\n\tstruct evbuffer\t\t*evb;\n\n\tif (args_has(args, 'I')) {\n\t\tif (wp == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tswitch (window_pane_start_input(wp, item, &cause)) {\n\t\tcase -1:\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\tcase 1:\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tcase 0:\n\t\t\treturn (CMD_RETURN_WAIT);\n\t\t}\n\t}\n\n\tif (args_has(args, 'F') && count != 0) {\n\t\tcmdq_error(item, \"only one of -F or argument must be given\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'd')) {\n\t\tdelay = args_strtonum(args, 'd', 0, UINT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"delay %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (count != 0)\n\t\ttemplate = args_string(args, 0);\n\telse\n\t\ttemplate = args_get(args, 'F');\n\tif (template == NULL)\n\t\ttemplate = DISPLAY_MESSAGE_TEMPLATE;\n\n\t/*\n\t * -c is intended to be the client where the message should be\n\t * displayed if -p is not given. But it makes sense to use it for the\n\t * formats too, assuming it matches the session. If it doesn't, use the\n\t * best client for the session.\n\t */\n\tif (tc != NULL && tc->session == s)\n\t\tc = tc;\n\telse if (s != NULL)\n\t\tc = cmd_find_best_client(s);\n\telse\n\t\tc = NULL;\n\tif (args_has(args, 'v'))\n\t\tflags = FORMAT_VERBOSE;\n\telse\n\t\tflags = 0;\n\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, flags);\n\tformat_defaults(ft, c, s, wl, wp);\n\n\tif (args_has(args, 'a')) {\n\t\tformat_each(ft, cmd_display_message_each, item);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'l'))\n\t\tmsg = xstrdup(template);\n\telse\n\t\tmsg = format_expand_time(ft, template);\n\n\tif (cmdq_get_client(item) == NULL)\n\t\tcmdq_error(item, \"%s\", msg);\n\telse if (args_has(args, 'p'))\n\t\tcmdq_print(item, \"%s\", msg);\n\telse if (tc != NULL && (tc->flags & CLIENT_CONTROL)) {\n\t\tevb = evbuffer_new();\n\t\tif (evb == NULL)\n\t\t\tfatalx(\"out of memory\");\n\t\tevbuffer_add_printf(evb, \"%%message %s\", msg);\n\t\tserver_client_print(tc, 0, evb);\n\t\tevbuffer_free(evb);\n\t} else if (tc != NULL)\n\t\tstatus_message_set(tc, delay, 0, Nflag, \"%s\", msg);\n\tfree(msg);\n\n\tformat_free(ft);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-display-panes.c",
          "type": "blob",
          "size": 8,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Display panes on a client.\n */\n\nstatic enum args_parse_type\tcmd_display_panes_args_parse(struct args *,\n\t\t\t\t    u_int, char **);\nstatic enum cmd_retval\t\tcmd_display_panes_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_display_panes_entry = {\n\t.name = \"display-panes\",\n\t.alias = \"displayp\",\n\n\t.args = { \"bd:Nt:\", 0, 1, cmd_display_panes_args_parse },\n\t.usage = \"[-bN] [-d duration] \" CMD_TARGET_CLIENT_USAGE \" [template]\",\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG,\n\t.exec = cmd_display_panes_exec\n};\n\nstruct cmd_display_panes_data {\n\tstruct cmdq_item\t\t*item;\n\tstruct args_command_state\t*state;\n};\n\nstatic enum args_parse_type\ncmd_display_panes_args_parse(__unused struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n}\n\nstatic void\ncmd_display_panes_draw_pane(struct screen_redraw_ctx *ctx,\n    struct window_pane *wp)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct session\t\t*s = c->session;\n\tstruct options\t\t*oo = s->options;\n\tstruct window\t\t*w = wp->window;\n\tstruct grid_cell\t fgc, bgc;\n\tu_int\t\t\t pane, idx, px, py, i, j, xoff, yoff, sx, sy;\n\tint\t\t\t colour, active_colour;\n\tchar\t\t\t buf[16], lbuf[16], rbuf[16], *ptr;\n\tsize_t\t\t\t len, llen, rlen;\n\n\tif (wp->xoff + wp->sx <= ctx->ox ||\n\t    wp->xoff >= ctx->ox + ctx->sx ||\n\t    wp->yoff + wp->sy <= ctx->oy ||\n\t    wp->yoff >= ctx->oy + ctx->sy)\n\t\treturn;\n\n\tif (wp->xoff >= ctx->ox && wp->xoff + wp->sx <= ctx->ox + ctx->sx) {\n\t\t/* All visible. */\n\t\txoff = wp->xoff - ctx->ox;\n\t\tsx = wp->sx;\n\t} else if (wp->xoff < ctx->ox &&\n\t    wp->xoff + wp->sx > ctx->ox + ctx->sx) {\n\t\t/* Both left and right not visible. */\n\t\txoff = 0;\n\t\tsx = ctx->sx;\n\t} else if (wp->xoff < ctx->ox) {\n\t\t/* Left not visible. */\n\t\txoff = 0;\n\t\tsx = wp->sx - (ctx->ox - wp->xoff);\n\t} else {\n\t\t/* Right not visible. */\n\t\txoff = wp->xoff - ctx->ox;\n\t\tsx = wp->sx - xoff;\n\t}\n\tif (wp->yoff >= ctx->oy && wp->yoff + wp->sy <= ctx->oy + ctx->sy) {\n\t\t/* All visible. */\n\t\tyoff = wp->yoff - ctx->oy;\n\t\tsy = wp->sy;\n\t} else if (wp->yoff < ctx->oy &&\n\t    wp->yoff + wp->sy > ctx->oy + ctx->sy) {\n\t\t/* Both top and bottom not visible. */\n\t\tyoff = 0;\n\t\tsy = ctx->sy;\n\t} else if (wp->yoff < ctx->oy) {\n\t\t/* Top not visible. */\n\t\tyoff = 0;\n\t\tsy = wp->sy - (ctx->oy - wp->yoff);\n\t} else {\n\t\t/* Bottom not visible. */\n\t\tyoff = wp->yoff - ctx->oy;\n\t\tsy = wp->sy - yoff;\n\t}\n\n\tif (ctx->statustop)\n\t\tyoff += ctx->statuslines;\n\tpx = sx / 2;\n\tpy = sy / 2;\n\n\tif (window_pane_index(wp, &pane) != 0)\n\t\tfatalx(\"index not found\");\n\tlen = xsnprintf(buf, sizeof buf, \"%u\", pane);\n\n\tif (sx < len)\n\t\treturn;\n\tcolour = options_get_number(oo, \"display-panes-colour\");\n\tactive_colour = options_get_number(oo, \"display-panes-active-colour\");\n\n\tmemcpy(&fgc, &grid_default_cell, sizeof fgc);\n\tmemcpy(&bgc, &grid_default_cell, sizeof bgc);\n\tif (w->active == wp) {\n\t\tfgc.fg = active_colour;\n\t\tbgc.bg = active_colour;\n\t} else {\n\t\tfgc.fg = colour;\n\t\tbgc.bg = colour;\n\t}\n\n\trlen = xsnprintf(rbuf, sizeof rbuf, \"%ux%u\", wp->sx, wp->sy);\n\tif (pane > 9 && pane < 35)\n\t\tllen = xsnprintf(lbuf, sizeof lbuf, \"%c\", 'a' + (pane - 10));\n\telse\n\t\tllen = 0;\n\n\tif (sx < len * 6 || sy < 5) {\n\t\ttty_attributes(tty, &fgc, &grid_default_cell, NULL, NULL);\n\t\tif (sx >= len + llen + 1) {\n\t\t\tlen += llen + 1;\n\t\t\ttty_cursor(tty, xoff + px - len / 2, yoff + py);\n\t\t\ttty_putn(tty, buf, len,\t len);\n\t\t\ttty_putn(tty, \" \", 1, 1);\n\t\t\ttty_putn(tty, lbuf, llen, llen);\n\t\t} else {\n\t\t\ttty_cursor(tty, xoff + px - len / 2, yoff + py);\n\t\t\ttty_putn(tty, buf, len, len);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tpx -= len * 3;\n\tpy -= 2;\n\n\ttty_attributes(tty, &bgc, &grid_default_cell, NULL, NULL);\n\tfor (ptr = buf; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr < '0' || *ptr > '9')\n\t\t\tcontinue;\n\t\tidx = *ptr - '0';\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = px; i < px + 5; i++) {\n\t\t\t\ttty_cursor(tty, xoff + i, yoff + py + j);\n\t\t\t\tif (window_clock_table[idx][j][i - px])\n\t\t\t\t\ttty_putc(tty, ' ');\n\t\t\t}\n\t\t}\n\t\tpx += 6;\n\t}\n\n\tif (sy <= 6)\n\t\tgoto out;\n\ttty_attributes(tty, &fgc, &grid_default_cell, NULL, NULL);\n\tif (rlen != 0 && sx >= rlen) {\n\t\ttty_cursor(tty, xoff + sx - rlen, yoff);\n\t\ttty_putn(tty, rbuf, rlen, rlen);\n\t}\n\tif (llen != 0) {\n\t\ttty_cursor(tty, xoff + sx / 2 + len * 3 - llen - 1,\n\t\t    yoff + py + 5);\n\t\ttty_putn(tty, lbuf, llen, llen);\n\t}\n\nout:\n\ttty_cursor(tty, 0, 0);\n}\n\nstatic void\ncmd_display_panes_draw(struct client *c, __unused void *data,\n    struct screen_redraw_ctx *ctx)\n{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (window_pane_visible(wp))\n\t\t\tcmd_display_panes_draw_pane(ctx, wp);\n\t}\n}\n\nstatic void\ncmd_display_panes_free(__unused struct client *c, void *data)\n{\n\tstruct cmd_display_panes_data\t*cdata = data;\n\n\tif (cdata->item != NULL)\n\t\tcmdq_continue(cdata->item);\n\targs_make_commands_free(cdata->state);\n\tfree(cdata);\n}\n\nstatic int\ncmd_display_panes_key(struct client *c, void *data, struct key_event *event)\n{\n\tstruct cmd_display_panes_data\t*cdata = data;\n\tchar\t\t\t\t*expanded, *error;\n\tstruct cmdq_item\t\t*item = cdata->item, *new_item;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tstruct window\t\t\t*w = c->session->curw->window;\n\tstruct window_pane\t\t*wp;\n\tu_int\t\t\t\t index;\n\tkey_code\t\t\t key;\n\n\tif (event->key >= '0' && event->key <= '9')\n\t\tindex = event->key - '0';\n\telse if ((event->key & KEYC_MASK_MODIFIERS) == 0) {\n\t\tkey = (event->key & KEYC_MASK_KEY);\n\t\tif (key >= 'a' && key <= 'z')\n\t\t\tindex = 10 + (key - 'a');\n\t\telse\n\t\t\treturn (-1);\n\t} else\n\t\treturn (-1);\n\n\twp = window_pane_at_index(w, index);\n\tif (wp == NULL)\n\t\treturn (1);\n\twindow_unzoom(w, 1);\n\n\txasprintf(&expanded, \"%%%u\", wp->id);\n\n\tcmdlist = args_make_commands(cdata->state, 1, &expanded, &error);\n\tif (cmdlist == NULL) {\n\t\tcmdq_append(c, cmdq_get_error(error));\n\t\tfree(error);\n\t} else if (item == NULL) {\n\t\tnew_item = cmdq_get_command(cmdlist, NULL);\n\t\tcmdq_append(c, new_item);\n\t} else {\n\t\tnew_item = cmdq_get_command(cmdlist, cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t}\n\n\tfree(expanded);\n\treturn (1);\n}\n\nstatic enum cmd_retval\ncmd_display_panes_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t\t*s = tc->session;\n\tu_int\t\t\t\t delay;\n\tchar\t\t\t\t*cause;\n\tstruct cmd_display_panes_data\t*cdata;\n\tint\t\t\t\t wait = !args_has(args, 'b');\n\n\tif (tc->overlay_draw != NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (args_has(args, 'd')) {\n\t\tdelay = args_strtonum(args, 'd', 0, UINT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"delay %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else\n\t\tdelay = options_get_number(s->options, \"display-panes-time\");\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tif (wait)\n\t\tcdata->item = item;\n\tcdata->state = args_make_commands_prepare(self, item, 0,\n\t    \"select-pane -t \\\"%%%\\\"\", wait, 0);\n\n\tif (args_has(args, 'N')) {\n\t\tserver_client_set_overlay(tc, delay, NULL, NULL,\n\t\t    cmd_display_panes_draw, NULL, cmd_display_panes_free, NULL,\n\t\t    cdata);\n\t} else {\n\t\tserver_client_set_overlay(tc, delay, NULL, NULL,\n\t\t    cmd_display_panes_draw, cmd_display_panes_key,\n\t\t    cmd_display_panes_free, NULL, cdata);\n\t}\n\n\tif (!wait)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n"
        },
        {
          "name": "cmd-find-window.c",
          "type": "blob",
          "size": 3.21875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Find window containing text.\n */\n\nstatic enum cmd_retval\tcmd_find_window_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_find_window_entry = {\n\t.name = \"find-window\",\n\t.alias = \"findw\",\n\n\t.args = { \"CiNrt:TZ\", 1, 1, NULL },\n\t.usage = \"[-CiNrTZ] \" CMD_TARGET_PANE_USAGE \" match-string\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_find_window_exec\n};\n\nstatic enum cmd_retval\ncmd_find_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self), *new_args;\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct window_pane\t*wp = target->wp;\n\tconst char\t\t*s = args_string(args, 0), *suffix = \"\";\n\tconst char\t\t*star = \"*\";\n\tstruct args_value\t*filter;\n\tint\t\t\t C, N, T;\n\n\tC = args_has(args, 'C');\n\tN = args_has(args, 'N');\n\tT = args_has(args, 'T');\n\n\tif (args_has(args, 'r'))\n\t\tstar = \"\";\n\tif (args_has(args, 'r') && args_has(args, 'i'))\n\t\tsuffix = \"/ri\";\n\telse if (args_has(args, 'r'))\n\t\tsuffix = \"/r\";\n\telse if (args_has(args, 'i'))\n\t\tsuffix = \"/i\";\n\n\tif (!C && !N && !T)\n\t\tC = N = T = 1;\n\n\tfilter = xcalloc(1, sizeof *filter);\n\tfilter->type = ARGS_STRING;\n\n\tif (C && N && T) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{||:\"\n\t\t    \"#{C%s:%s},#{||:#{m%s:%s%s%s,#{window_name}},\"\n\t\t    \"#{m%s:%s%s%s,#{pane_title}}}}\",\n\t\t    suffix, s, suffix, star, s, star, suffix, star, s, star);\n\t} else if (C && N) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{||:#{C%s:%s},#{m%s:%s%s%s,#{window_name}}}\",\n\t\t    suffix, s, suffix, star, s, star);\n\t} else if (C && T) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{||:#{C%s:%s},#{m%s:%s%s%s,#{pane_title}}}\",\n\t\t    suffix, s, suffix, star, s, star);\n\t} else if (N && T) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{||:#{m%s:%s%s%s,#{window_name}},\"\n\t\t    \"#{m%s:%s%s%s,#{pane_title}}}\",\n\t\t    suffix, star, s, star, suffix, star, s, star);\n\t} else if (C) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{C%s:%s}\",\n\t\t    suffix, s);\n\t} else if (N) {\n\t\txasprintf(&filter->string,\n\t\t    \"#{m%s:%s%s%s,#{window_name}}\",\n\t\t    suffix, star, s, star);\n\t} else {\n\t\txasprintf(&filter->string,\n\t\t    \"#{m%s:%s%s%s,#{pane_title}}\",\n\t\t    suffix, star, s, star);\n\t}\n\n\tnew_args = args_create();\n\tif (args_has(args, 'Z'))\n\t\targs_set(new_args, 'Z', NULL, 0);\n\targs_set(new_args, 'f', filter, 0);\n\n\twindow_pane_set_mode(wp, NULL, &window_tree_mode, target, new_args);\n\targs_free(new_args);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-find.c",
          "type": "blob",
          "size": 30.921875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <fnmatch.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic int\tcmd_find_session_better(struct session *, struct session *,\n\t\t    int);\nstatic struct session *cmd_find_best_session(struct session **, u_int, int);\nstatic int\tcmd_find_best_session_with_window(struct cmd_find_state *);\nstatic int\tcmd_find_best_winlink_with_window(struct cmd_find_state *);\n\nstatic const char *cmd_find_map_table(const char *[][2], const char *);\n\nstatic void\tcmd_find_log_state(const char *, struct cmd_find_state *);\nstatic int\tcmd_find_get_session(struct cmd_find_state *, const char *);\nstatic int\tcmd_find_get_window(struct cmd_find_state *, const char *, int);\nstatic int\tcmd_find_get_window_with_session(struct cmd_find_state *,\n\t\t    const char *);\nstatic int\tcmd_find_get_pane(struct cmd_find_state *, const char *, int);\nstatic int\tcmd_find_get_pane_with_session(struct cmd_find_state *,\n\t\t    const char *);\nstatic int\tcmd_find_get_pane_with_window(struct cmd_find_state *,\n\t\t    const char *);\n\nstatic const char *cmd_find_session_table[][2] = {\n\t{ NULL, NULL }\n};\nstatic const char *cmd_find_window_table[][2] = {\n\t{ \"{start}\", \"^\" },\n\t{ \"{last}\", \"!\" },\n\t{ \"{end}\", \"$\" },\n\t{ \"{next}\", \"+\" },\n\t{ \"{previous}\", \"-\" },\n\t{ NULL, NULL }\n};\nstatic const char *cmd_find_pane_table[][2] = {\n\t{ \"{last}\", \"!\" },\n\t{ \"{next}\", \"+\" },\n\t{ \"{previous}\", \"-\" },\n\t{ \"{top}\", \"top\" },\n\t{ \"{bottom}\", \"bottom\" },\n\t{ \"{left}\", \"left\" },\n\t{ \"{right}\", \"right\" },\n\t{ \"{top-left}\", \"top-left\" },\n\t{ \"{top-right}\", \"top-right\" },\n\t{ \"{bottom-left}\", \"bottom-left\" },\n\t{ \"{bottom-right}\", \"bottom-right\" },\n\t{ \"{up-of}\", \"{up-of}\" },\n\t{ \"{down-of}\", \"{down-of}\" },\n\t{ \"{left-of}\", \"{left-of}\" },\n\t{ \"{right-of}\", \"{right-of}\" },\n\t{ NULL, NULL }\n};\n\n/* Find pane containing client if any. */\nstatic struct window_pane *\ncmd_find_inside_pane(struct client *c)\n{\n\tstruct window_pane\t*wp;\n\tstruct environ_entry\t*envent;\n\n\tif (c == NULL)\n\t\treturn (NULL);\n\n\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\tif (wp->fd != -1 && strcmp(wp->tty, c->ttyname) == 0)\n\t\t\tbreak;\n\t}\n\tif (wp == NULL) {\n\t\tenvent = environ_find(c->environ, \"TMUX_PANE\");\n\t\tif (envent != NULL)\n\t\t\twp = window_pane_find_by_id_str(envent->value);\n\t}\n\tif (wp != NULL)\n\t\tlog_debug(\"%s: got pane %%%u (%s)\", __func__, wp->id, wp->tty);\n\treturn (wp);\n}\n\n/* Is this client better? */\nstatic int\ncmd_find_client_better(struct client *c, struct client *than)\n{\n\tif (than == NULL)\n\t\treturn (1);\n\treturn (timercmp(&c->activity_time, &than->activity_time, >));\n}\n\n/* Find best client for session. */\nstruct client *\ncmd_find_best_client(struct session *s)\n{\n\tstruct client\t*c_loop, *c;\n\n\tif (s->attached == 0)\n\t\ts = NULL;\n\n\tc = NULL;\n\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\tif (c_loop->session == NULL)\n\t\t\tcontinue;\n\t\tif (s != NULL && c_loop->session != s)\n\t\t\tcontinue;\n\t\tif (cmd_find_client_better(c_loop, c))\n\t\t\tc = c_loop;\n\t}\n\treturn (c);\n}\n\n/* Is this session better? */\nstatic int\ncmd_find_session_better(struct session *s, struct session *than, int flags)\n{\n\tint\tattached;\n\n\tif (than == NULL)\n\t\treturn (1);\n\tif (flags & CMD_FIND_PREFER_UNATTACHED) {\n\t\tattached = (than->attached != 0);\n\t\tif (attached && s->attached == 0)\n\t\t\treturn (1);\n\t\telse if (!attached && s->attached != 0)\n\t\t\treturn (0);\n\t}\n\treturn (timercmp(&s->activity_time, &than->activity_time, >));\n}\n\n/* Find best session from a list, or all if list is NULL. */\nstatic struct session *\ncmd_find_best_session(struct session **slist, u_int ssize, int flags)\n{\n\tstruct session\t *s_loop, *s;\n\tu_int\t\t  i;\n\n\tlog_debug(\"%s: %u sessions to try\", __func__, ssize);\n\n\ts = NULL;\n\tif (slist != NULL) {\n\t\tfor (i = 0; i < ssize; i++) {\n\t\t\tif (cmd_find_session_better(slist[i], s, flags))\n\t\t\t\ts = slist[i];\n\t\t}\n\t} else {\n\t\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\t\tif (cmd_find_session_better(s_loop, s, flags))\n\t\t\t\ts = s_loop;\n\t\t}\n\t}\n\treturn (s);\n}\n\n/* Find best session and winlink for window. */\nstatic int\ncmd_find_best_session_with_window(struct cmd_find_state *fs)\n{\n\tstruct session\t**slist = NULL;\n\tu_int\t\t  ssize;\n\tstruct session\t *s;\n\n\tlog_debug(\"%s: window is @%u\", __func__, fs->w->id);\n\n\tssize = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (!session_has(s, fs->w))\n\t\t\tcontinue;\n\t\tslist = xreallocarray(slist, ssize + 1, sizeof *slist);\n\t\tslist[ssize++] = s;\n\t}\n\tif (ssize == 0)\n\t\tgoto fail;\n\tfs->s = cmd_find_best_session(slist, ssize, fs->flags);\n\tif (fs->s == NULL)\n\t\tgoto fail;\n\tfree(slist);\n\treturn (cmd_find_best_winlink_with_window(fs));\n\nfail:\n\tfree(slist);\n\treturn (-1);\n}\n\n/*\n * Find the best winlink for a window (the current if it contains the window,\n * otherwise the first).\n */\nstatic int\ncmd_find_best_winlink_with_window(struct cmd_find_state *fs)\n{\n\tstruct winlink\t *wl, *wl_loop;\n\n\tlog_debug(\"%s: window is @%u\", __func__, fs->w->id);\n\n\twl = NULL;\n\tif (fs->s->curw != NULL && fs->s->curw->window == fs->w)\n\t\twl = fs->s->curw;\n\telse {\n\t\tRB_FOREACH(wl_loop, winlinks, &fs->s->windows) {\n\t\t\tif (wl_loop->window == fs->w) {\n\t\t\t\twl = wl_loop;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (wl == NULL)\n\t\treturn (-1);\n\tfs->wl = wl;\n\tfs->idx = fs->wl->idx;\n\treturn (0);\n}\n\n/* Maps string in table. */\nstatic const char *\ncmd_find_map_table(const char *table[][2], const char *s)\n{\n\tu_int\ti;\n\n\tfor (i = 0; table[i][0] != NULL; i++) {\n\t\tif (strcmp(s, table[i][0]) == 0)\n\t\t\treturn (table[i][1]);\n\t}\n\treturn (s);\n}\n\n/* Find session from string. Fills in s. */\nstatic int\ncmd_find_get_session(struct cmd_find_state *fs, const char *session)\n{\n\tstruct session\t*s, *s_loop;\n\tstruct client\t*c;\n\n\tlog_debug(\"%s: %s\", __func__, session);\n\n\t/* Check for session ids starting with $. */\n\tif (*session == '$') {\n\t\tfs->s = session_find_by_id_str(session);\n\t\tif (fs->s == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Look for exactly this session. */\n\tfs->s = session_find(session);\n\tif (fs->s != NULL)\n\t\treturn (0);\n\n\t/* Look for as a client. */\n\tc = cmd_find_client(NULL, session, 1);\n\tif (c != NULL && c->session != NULL) {\n\t\tfs->s = c->session;\n\t\treturn (0);\n\t}\n\n\t/* Stop now if exact only. */\n\tif (fs->flags & CMD_FIND_EXACT_SESSION)\n\t\treturn (-1);\n\n\t/* Otherwise look for prefix. */\n\ts = NULL;\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (strncmp(session, s_loop->name, strlen(session)) == 0) {\n\t\t\tif (s != NULL)\n\t\t\t\treturn (-1);\n\t\t\ts = s_loop;\n\t\t}\n\t}\n\tif (s != NULL) {\n\t\tfs->s = s;\n\t\treturn (0);\n\t}\n\n\t/* Then as a pattern. */\n\ts = NULL;\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (fnmatch(session, s_loop->name, 0) == 0) {\n\t\t\tif (s != NULL)\n\t\t\t\treturn (-1);\n\t\t\ts = s_loop;\n\t\t}\n\t}\n\tif (s != NULL) {\n\t\tfs->s = s;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/* Find window from string. Fills in s, wl, w. */\nstatic int\ncmd_find_get_window(struct cmd_find_state *fs, const char *window, int only)\n{\n\tlog_debug(\"%s: %s\", __func__, window);\n\n\t/* Check for window ids starting with @. */\n\tif (*window == '@') {\n\t\tfs->w = window_find_by_id_str(window);\n\t\tif (fs->w == NULL)\n\t\t\treturn (-1);\n\t\treturn (cmd_find_best_session_with_window(fs));\n\t}\n\n\t/* Not a window id, so use the current session. */\n\tfs->s = fs->current->s;\n\n\t/* We now only need to find the winlink in this session. */\n\tif (cmd_find_get_window_with_session(fs, window) == 0)\n\t\treturn (0);\n\n\t/* Otherwise try as a session itself. */\n\tif (!only && cmd_find_get_session(fs, window) == 0) {\n\t\tfs->wl = fs->s->curw;\n\t\tfs->w = fs->wl->window;\n\t\tif (~fs->flags & CMD_FIND_WINDOW_INDEX)\n\t\t\tfs->idx = fs->wl->idx;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Find window from string, assuming it is in given session. Needs s, fills in\n * wl and w.\n */\nstatic int\ncmd_find_get_window_with_session(struct cmd_find_state *fs, const char *window)\n{\n\tstruct winlink\t*wl;\n\tconst char\t*errstr;\n\tint\t\t idx, n, exact;\n\tstruct session\t*s;\n\n\tlog_debug(\"%s: %s\", __func__, window);\n\texact = (fs->flags & CMD_FIND_EXACT_WINDOW);\n\n\t/*\n\t * Start with the current window as the default. So if only an index is\n\t * found, the window will be the current.\n\t */\n\tfs->wl = fs->s->curw;\n\tfs->w = fs->wl->window;\n\n\t/* Check for window ids starting with @. */\n\tif (*window == '@') {\n\t\tfs->w = window_find_by_id_str(window);\n\t\tif (fs->w == NULL || !session_has(fs->s, fs->w))\n\t\t\treturn (-1);\n\t\treturn (cmd_find_best_winlink_with_window(fs));\n\t}\n\n\t/* Try as an offset. */\n\tif (!exact && (window[0] == '+' || window[0] == '-')) {\n\t\tif (window[1] != '\\0')\n\t\t\tn = strtonum(window + 1, 1, INT_MAX, NULL);\n\t\telse\n\t\t\tn = 1;\n\t\ts = fs->s;\n\t\tif (fs->flags & CMD_FIND_WINDOW_INDEX) {\n\t\t\tif (window[0] == '+') {\n\t\t\t\tif (INT_MAX - s->curw->idx < n)\n\t\t\t\t\treturn (-1);\n\t\t\t\tfs->idx = s->curw->idx + n;\n\t\t\t} else {\n\t\t\t\tif (n > s->curw->idx)\n\t\t\t\t\treturn (-1);\n\t\t\t\tfs->idx = s->curw->idx - n;\n\t\t\t}\n\t\t\treturn (0);\n\t\t}\n\t\tif (window[0] == '+')\n\t\t\tfs->wl = winlink_next_by_number(s->curw, s, n);\n\t\telse\n\t\t\tfs->wl = winlink_previous_by_number(s->curw, s, n);\n\t\tif (fs->wl != NULL) {\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Try special characters. */\n\tif (!exact) {\n\t\tif (strcmp(window, \"!\") == 0) {\n\t\t\tfs->wl = TAILQ_FIRST(&fs->s->lastw);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t} else if (strcmp(window, \"^\") == 0) {\n\t\t\tfs->wl = RB_MIN(winlinks, &fs->s->windows);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t} else if (strcmp(window, \"$\") == 0) {\n\t\t\tfs->wl = RB_MAX(winlinks, &fs->s->windows);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* First see if this is a valid window index in this session. */\n\tif (window[0] != '+' && window[0] != '-') {\n\t\tidx = strtonum(window, 0, INT_MAX, &errstr);\n\t\tif (errstr == NULL) {\n\t\t\tfs->wl = winlink_find_by_index(&fs->s->windows, idx);\n\t\t\tif (fs->wl != NULL) {\n\t\t\t\tfs->idx = fs->wl->idx;\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (fs->flags & CMD_FIND_WINDOW_INDEX) {\n\t\t\t\tfs->idx = idx;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Look for exact matches, error if more than one. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (strcmp(window, wl->window->name) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\t/* Stop now if exact only. */\n\tif (exact)\n\t\treturn (-1);\n\n\t/* Try as the start of a window name, error if multiple. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (strncmp(window, wl->window->name, strlen(window)) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\t/* Now look for pattern matches, again error if multiple. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (fnmatch(window, wl->window->name, 0) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/* Find pane from string. Fills in s, wl, w, wp. */\nstatic int\ncmd_find_get_pane(struct cmd_find_state *fs, const char *pane, int only)\n{\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\tfs->w = fs->wp->window;\n\t\treturn (cmd_find_best_session_with_window(fs));\n\t}\n\n\t/* Not a pane id, so try the current session and window. */\n\tfs->s = fs->current->s;\n\tfs->wl = fs->current->wl;\n\tfs->idx = fs->current->idx;\n\tfs->w = fs->current->w;\n\n\t/* We now only need to find the pane in this window. */\n\tif (cmd_find_get_pane_with_window(fs, pane) == 0)\n\t\treturn (0);\n\n\t/* Otherwise try as a window itself (this will also try as session). */\n\tif (!only && cmd_find_get_window(fs, pane, 0) == 0) {\n\t\tfs->wp = fs->w->active;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Find pane from string, assuming it is in given session. Needs s, fills in wl\n * and w and wp.\n */\nstatic int\ncmd_find_get_pane_with_session(struct cmd_find_state *fs, const char *pane)\n{\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\tfs->w = fs->wp->window;\n\t\treturn (cmd_find_best_winlink_with_window(fs));\n\t}\n\n\t/* Otherwise use the current window. */\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\n\t/* Now we just need to look up the pane. */\n\treturn (cmd_find_get_pane_with_window(fs, pane));\n}\n\n/*\n * Find pane from string, assuming it is in the given window. Needs w, fills in\n * wp.\n */\nstatic int\ncmd_find_get_pane_with_window(struct cmd_find_state *fs, const char *pane)\n{\n\tconst char\t\t*errstr;\n\tint\t\t\t idx;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\tif (fs->wp->window != fs->w)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Try special characters. */\n\tif (strcmp(pane, \"!\") == 0) {\n\t\tfs->wp = TAILQ_FIRST(&fs->w->last_panes);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{up-of}\") == 0) {\n\t\tfs->wp = window_pane_find_up(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{down-of}\") == 0) {\n\t\tfs->wp = window_pane_find_down(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{left-of}\") == 0) {\n\t\tfs->wp = window_pane_find_left(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{right-of}\") == 0) {\n\t\tfs->wp = window_pane_find_right(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Try as an offset. */\n\tif (pane[0] == '+' || pane[0] == '-') {\n\t\tif (pane[1] != '\\0')\n\t\t\tn = strtonum(pane + 1, 1, INT_MAX, NULL);\n\t\telse\n\t\t\tn = 1;\n\t\twp = fs->w->active;\n\t\tif (pane[0] == '+')\n\t\t\tfs->wp = window_pane_next_by_number(fs->w, wp, n);\n\t\telse\n\t\t\tfs->wp = window_pane_previous_by_number(fs->w, wp, n);\n\t\tif (fs->wp != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/* Get pane by index. */\n\tidx = strtonum(pane, 0, INT_MAX, &errstr);\n\tif (errstr == NULL) {\n\t\tfs->wp = window_pane_at_index(fs->w, idx);\n\t\tif (fs->wp != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/* Try as a description. */\n\tfs->wp = window_find_string(fs->w, pane);\n\tif (fs->wp != NULL)\n\t\treturn (0);\n\n\treturn (-1);\n}\n\n/* Clear state. */\nvoid\ncmd_find_clear_state(struct cmd_find_state *fs, int flags)\n{\n\tmemset(fs, 0, sizeof *fs);\n\n\tfs->flags = flags;\n\n\tfs->idx = -1;\n}\n\n/* Check if state is empty. */\nint\ncmd_find_empty_state(struct cmd_find_state *fs)\n{\n\tif (fs->s == NULL && fs->wl == NULL && fs->w == NULL && fs->wp == NULL)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Check if a state if valid. */\nint\ncmd_find_valid_state(struct cmd_find_state *fs)\n{\n\tstruct winlink\t*wl;\n\n\tif (fs->s == NULL || fs->wl == NULL || fs->w == NULL || fs->wp == NULL)\n\t\treturn (0);\n\n\tif (!session_alive(fs->s))\n\t\treturn (0);\n\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (wl->window == fs->w && wl == fs->wl)\n\t\t\tbreak;\n\t}\n\tif (wl == NULL)\n\t\treturn (0);\n\n\tif (fs->w != fs->wl->window)\n\t\treturn (0);\n\n\treturn (window_has_pane(fs->w, fs->wp));\n}\n\n/* Copy a state. */\nvoid\ncmd_find_copy_state(struct cmd_find_state *dst, struct cmd_find_state *src)\n{\n\tdst->s = src->s;\n\tdst->wl = src->wl;\n\tdst->idx = src->idx;\n\tdst->w = src->w;\n\tdst->wp = src->wp;\n}\n\n/* Log the result. */\nstatic void\ncmd_find_log_state(const char *prefix, struct cmd_find_state *fs)\n{\n\tif (fs->s != NULL)\n\t\tlog_debug(\"%s: s=$%u %s\", prefix, fs->s->id, fs->s->name);\n\telse\n\t\tlog_debug(\"%s: s=none\", prefix);\n\tif (fs->wl != NULL) {\n\t\tlog_debug(\"%s: wl=%u %d w=@%u %s\", prefix, fs->wl->idx,\n\t\t    fs->wl->window == fs->w, fs->w->id, fs->w->name);\n\t} else\n\t\tlog_debug(\"%s: wl=none\", prefix);\n\tif (fs->wp != NULL)\n\t\tlog_debug(\"%s: wp=%%%u\", prefix, fs->wp->id);\n\telse\n\t\tlog_debug(\"%s: wp=none\", prefix);\n\tif (fs->idx != -1)\n\t\tlog_debug(\"%s: idx=%d\", prefix, fs->idx);\n\telse\n\t\tlog_debug(\"%s: idx=none\", prefix);\n}\n\n/* Find state from a session. */\nvoid\ncmd_find_from_session(struct cmd_find_state *fs, struct session *s, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->s = s;\n\tfs->wl = fs->s->curw;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\tcmd_find_log_state(__func__, fs);\n}\n\n/* Find state from a winlink. */\nvoid\ncmd_find_from_winlink(struct cmd_find_state *fs, struct winlink *wl, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->s = wl->session;\n\tfs->wl = wl;\n\tfs->w = wl->window;\n\tfs->wp = wl->window->active;\n\n\tcmd_find_log_state(__func__, fs);\n}\n\n/* Find state from a session and window. */\nint\ncmd_find_from_session_window(struct cmd_find_state *fs, struct session *s,\n    struct window *w, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->s = s;\n\tfs->w = w;\n\tif (cmd_find_best_winlink_with_window(fs) != 0) {\n\t\tcmd_find_clear_state(fs, flags);\n\t\treturn (-1);\n\t}\n\tfs->wp = fs->w->active;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from a window. */\nint\ncmd_find_from_window(struct cmd_find_state *fs, struct window *w, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->w = w;\n\tif (cmd_find_best_session_with_window(fs) != 0) {\n\t\tcmd_find_clear_state(fs, flags);\n\t\treturn (-1);\n\t}\n\tif (cmd_find_best_winlink_with_window(fs) != 0) {\n\t\tcmd_find_clear_state(fs, flags);\n\t\treturn (-1);\n\t}\n\tfs->wp = fs->w->active;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from a winlink and pane. */\nvoid\ncmd_find_from_winlink_pane(struct cmd_find_state *fs, struct winlink *wl,\n    struct window_pane *wp, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->s = wl->session;\n\tfs->wl = wl;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\tfs->wp = wp;\n\n\tcmd_find_log_state(__func__, fs);\n}\n\n/* Find state from a pane. */\nint\ncmd_find_from_pane(struct cmd_find_state *fs, struct window_pane *wp, int flags)\n{\n\tif (cmd_find_from_window(fs, wp->window, flags) != 0)\n\t\treturn (-1);\n\tfs->wp = wp;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from nothing. */\nint\ncmd_find_from_nothing(struct cmd_find_state *fs, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tfs->s = cmd_find_best_session(NULL, 0, flags);\n\tif (fs->s == NULL) {\n\t\tcmd_find_clear_state(fs, flags);\n\t\treturn (-1);\n\t}\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from mouse. */\nint\ncmd_find_from_mouse(struct cmd_find_state *fs, struct mouse_event *m, int flags)\n{\n\tcmd_find_clear_state(fs, flags);\n\n\tif (!m->valid)\n\t\treturn (-1);\n\n\tfs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);\n\tif (fs->wp == NULL) {\n\t\tcmd_find_clear_state(fs, flags);\n\t\treturn (-1);\n\t}\n\tfs->w = fs->wl->window;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from client. */\nint\ncmd_find_from_client(struct cmd_find_state *fs, struct client *c, int flags)\n{\n\tstruct window_pane\t*wp;\n\n\t/* If no client, treat as from nothing. */\n\tif (c == NULL)\n\t\treturn (cmd_find_from_nothing(fs, flags));\n\n\t/* If this is an attached client, all done. */\n\tif (c->session != NULL) {\n\t\tcmd_find_clear_state(fs, flags);\n\n\t\tfs->wp = server_client_get_pane(c);\n\t\tif (fs->wp == NULL) {\n\t\t\tcmd_find_from_session(fs, c->session, flags);\n\t\t\treturn (0);\n\t\t}\n\t\tfs->s = c->session;\n\t\tfs->wl = fs->s->curw;\n\t\tfs->w = fs->wl->window;\n\n\t\tcmd_find_log_state(__func__, fs);\n\t\treturn (0);\n\t}\n\tcmd_find_clear_state(fs, flags);\n\n\t/*\n\t * If this is an unattached client running in a pane, we can use that\n\t * to limit the list of sessions to those containing that pane.\n\t */\n\twp = cmd_find_inside_pane(c);\n\tif (wp == NULL)\n\t\tgoto unknown_pane;\n\n\t/*\n\t * Don't have a session, or it doesn't have this pane. Try all\n\t * sessions.\n\t */\n\tfs->w = wp->window;\n\tif (cmd_find_best_session_with_window(fs) != 0) {\n\t\t/*\n\t\t * The window may have been destroyed but the pane\n\t\t * still on all_window_panes due to something else\n\t\t * holding a reference.\n\t\t */\n\t\tgoto unknown_pane;\n\t}\n\tfs->wl = fs->s->curw;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active; /* use active pane */\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n\nunknown_pane:\n\t/* We can't find the pane so need to guess. */\n\treturn (cmd_find_from_nothing(fs, flags));\n}\n\n/*\n * Split target into pieces and resolve for the given type. Fills in the given\n * state. Returns 0 on success or -1 on error.\n */\nint\ncmd_find_target(struct cmd_find_state *fs, struct cmdq_item *item,\n    const char *target, enum cmd_find_type type, int flags)\n{\n\tstruct mouse_event\t*m;\n\tstruct cmd_find_state\t current;\n\tchar\t\t\t*colon, *period, *copy = NULL, tmp[256];\n\tconst char\t\t*session, *window, *pane, *s;\n\tint\t\t\t window_only = 0, pane_only = 0;\n\n\t/* Can fail flag implies quiet. */\n\tif (flags & CMD_FIND_CANFAIL)\n\t\tflags |= CMD_FIND_QUIET;\n\n\t/* Log the arguments. */\n\tif (type == CMD_FIND_PANE)\n\t\ts = \"pane\";\n\telse if (type == CMD_FIND_WINDOW)\n\t\ts = \"window\";\n\telse if (type == CMD_FIND_SESSION)\n\t\ts = \"session\";\n\telse\n\t\ts = \"unknown\";\n\t*tmp = '\\0';\n\tif (flags & CMD_FIND_PREFER_UNATTACHED)\n\t\tstrlcat(tmp, \"PREFER_UNATTACHED,\", sizeof tmp);\n\tif (flags & CMD_FIND_QUIET)\n\t\tstrlcat(tmp, \"QUIET,\", sizeof tmp);\n\tif (flags & CMD_FIND_WINDOW_INDEX)\n\t\tstrlcat(tmp, \"WINDOW_INDEX,\", sizeof tmp);\n\tif (flags & CMD_FIND_DEFAULT_MARKED)\n\t\tstrlcat(tmp, \"DEFAULT_MARKED,\", sizeof tmp);\n\tif (flags & CMD_FIND_EXACT_SESSION)\n\t\tstrlcat(tmp, \"EXACT_SESSION,\", sizeof tmp);\n\tif (flags & CMD_FIND_EXACT_WINDOW)\n\t\tstrlcat(tmp, \"EXACT_WINDOW,\", sizeof tmp);\n\tif (flags & CMD_FIND_CANFAIL)\n\t\tstrlcat(tmp, \"CANFAIL,\", sizeof tmp);\n\tif (*tmp != '\\0')\n\t\ttmp[strlen(tmp) - 1] = '\\0';\n\telse\n\t\tstrlcat(tmp, \"NONE\", sizeof tmp);\n\tlog_debug(\"%s: target %s, type %s, item %p, flags %s\", __func__,\n\t    target == NULL ? \"none\" : target, s, item, tmp);\n\n\t/* Clear new state. */\n\tcmd_find_clear_state(fs, flags);\n\n\t/* Find current state. */\n\tif (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED)) {\n\t\tfs->current = &marked_pane;\n\t\tlog_debug(\"%s: current is marked pane\", __func__);\n\t} else if (cmd_find_valid_state(cmdq_get_current(item))) {\n\t\tfs->current = cmdq_get_current(item);\n\t\tlog_debug(\"%s: current is from queue\", __func__);\n\t} else if (cmd_find_from_client(&current, cmdq_get_client(item),\n\t    flags) == 0) {\n\t\tfs->current = &current;\n\t\tlog_debug(\"%s: current is from client\", __func__);\n\t} else {\n\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\tcmdq_error(item, \"no current target\");\n\t\tgoto error;\n\t}\n\tif (!cmd_find_valid_state(fs->current))\n\t\tfatalx(\"invalid current find state\");\n\n\t/* An empty or NULL target is the current. */\n\tif (target == NULL || *target == '\\0')\n\t\tgoto current;\n\n\t/* Mouse target is a plain = or {mouse}. */\n\tif (strcmp(target, \"=\") == 0 || strcmp(target, \"{mouse}\") == 0) {\n\t\tm = &cmdq_get_event(item)->m;\n\t\tswitch (type) {\n\t\tcase CMD_FIND_PANE:\n\t\t\tfs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);\n\t\t\tif (fs->wp != NULL) {\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase CMD_FIND_WINDOW:\n\t\tcase CMD_FIND_SESSION:\n\t\t\tfs->wl = cmd_mouse_window(m, &fs->s);\n\t\t\tif (fs->wl == NULL && fs->s != NULL)\n\t\t\t\tfs->wl = fs->s->curw;\n\t\t\tif (fs->wl != NULL) {\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\t\tfs->wp = fs->w->active;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (fs->wp == NULL) {\n\t\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\t\tcmdq_error(item, \"no mouse target\");\n\t\t\tgoto error;\n\t\t}\n\t\tgoto found;\n\t}\n\n\t/* Marked target is a plain ~ or {marked}. */\n\tif (strcmp(target, \"~\") == 0 || strcmp(target, \"{marked}\") == 0) {\n\t\tif (!server_check_marked()) {\n\t\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\t\tcmdq_error(item, \"no marked target\");\n\t\t\tgoto error;\n\t\t}\n\t\tcmd_find_copy_state(fs, &marked_pane);\n\t\tgoto found;\n\t}\n\n\t/* Find separators if they exist. */\n\tcopy = xstrdup(target);\n\tcolon = strchr(copy, ':');\n\tif (colon != NULL)\n\t\t*colon++ = '\\0';\n\tif (colon == NULL)\n\t\tperiod = strchr(copy, '.');\n\telse\n\t\tperiod = strchr(colon, '.');\n\tif (period != NULL)\n\t\t*period++ = '\\0';\n\n\t/* Set session, window and pane parts. */\n\tsession = window = pane = NULL;\n\tif (colon != NULL && period != NULL) {\n\t\tsession = copy;\n\t\twindow = colon;\n\t\twindow_only = 1;\n\t\tpane = period;\n\t\tpane_only = 1;\n\t} else if (colon != NULL && period == NULL) {\n\t\tsession = copy;\n\t\twindow = colon;\n\t\twindow_only = 1;\n\t} else if (colon == NULL && period != NULL) {\n\t\twindow = copy;\n\t\tpane = period;\n\t\tpane_only = 1;\n\t} else {\n\t\tif (*copy == '$')\n\t\t\tsession = copy;\n\t\telse if (*copy == '@')\n\t\t\twindow = copy;\n\t\telse if (*copy == '%')\n\t\t\tpane = copy;\n\t\telse {\n\t\t\tswitch (type) {\n\t\t\tcase CMD_FIND_SESSION:\n\t\t\t\tsession = copy;\n\t\t\t\tbreak;\n\t\t\tcase CMD_FIND_WINDOW:\n\t\t\t\twindow = copy;\n\t\t\t\tbreak;\n\t\t\tcase CMD_FIND_PANE:\n\t\t\t\tpane = copy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set exact match flags. */\n\tif (session != NULL && *session == '=') {\n\t\tsession++;\n\t\tfs->flags |= CMD_FIND_EXACT_SESSION;\n\t}\n\tif (window != NULL && *window == '=') {\n\t\twindow++;\n\t\tfs->flags |= CMD_FIND_EXACT_WINDOW;\n\t}\n\n\t/* Empty is the same as NULL. */\n\tif (session != NULL && *session == '\\0')\n\t\tsession = NULL;\n\tif (window != NULL && *window == '\\0')\n\t\twindow = NULL;\n\tif (pane != NULL && *pane == '\\0')\n\t\tpane = NULL;\n\n\t/* Map though conversion table. */\n\tif (session != NULL)\n\t\tsession = cmd_find_map_table(cmd_find_session_table, session);\n\tif (window != NULL)\n\t\twindow = cmd_find_map_table(cmd_find_window_table, window);\n\tif (pane != NULL)\n\t\tpane = cmd_find_map_table(cmd_find_pane_table, pane);\n\n\tif (session != NULL || window != NULL || pane != NULL) {\n\t\tlog_debug(\"%s: target %s is %s%s%s%s%s%s\",\n\t\t    __func__, target,\n\t\t    session == NULL ? \"\" : \"session \",\n\t\t    session == NULL ? \"\" : session,\n\t\t    window == NULL ? \"\" : \"window \",\n\t\t    window == NULL ? \"\" : window,\n\t\t    pane == NULL ? \"\" : \"pane \",\n\t\t    pane == NULL ? \"\" : pane);\n\t}\n\n\t/* No pane is allowed if want an index. */\n\tif (pane != NULL && (flags & CMD_FIND_WINDOW_INDEX)) {\n\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\tcmdq_error(item, \"can't specify pane here\");\n\t\tgoto error;\n\t}\n\n\t/* If the session isn't NULL, look it up. */\n\tif (session != NULL) {\n\t\t/* This will fill in session. */\n\t\tif (cmd_find_get_session(fs, session) != 0)\n\t\t\tgoto no_session;\n\n\t\t/* If window and pane are NULL, use that session's current. */\n\t\tif (window == NULL && pane == NULL) {\n\t\t\tfs->wl = fs->s->curw;\n\t\t\tfs->idx = -1;\n\t\t\tfs->w = fs->wl->window;\n\t\t\tfs->wp = fs->w->active;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/* If window is present but pane not, find window in session. */\n\t\tif (window != NULL && pane == NULL) {\n\t\t\t/* This will fill in winlink and window. */\n\t\t\tif (cmd_find_get_window_with_session(fs, window) != 0)\n\t\t\t\tgoto no_window;\n\t\t\tif (fs->wl != NULL) /* can be NULL if index only */\n\t\t\t\tfs->wp = fs->wl->window->active;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/* If pane is present but window not, find pane. */\n\t\tif (window == NULL && pane != NULL) {\n\t\t\t/* This will fill in winlink and window and pane. */\n\t\t\tif (cmd_find_get_pane_with_session(fs, pane) != 0)\n\t\t\t\tgoto no_pane;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/*\n\t\t * If window and pane are present, find both in session. This\n\t\t * will fill in winlink and window.\n\t\t */\n\t\tif (cmd_find_get_window_with_session(fs, window) != 0)\n\t\t\tgoto no_window;\n\t\t/* This will fill in pane. */\n\t\tif (cmd_find_get_pane_with_window(fs, pane) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\n\t/* No session. If window and pane, try them. */\n\tif (window != NULL && pane != NULL) {\n\t\t/* This will fill in session, winlink and window. */\n\t\tif (cmd_find_get_window(fs, window, window_only) != 0)\n\t\t\tgoto no_window;\n\t\t/* This will fill in pane. */\n\t\tif (cmd_find_get_pane_with_window(fs, pane) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\n\t/* If just window is present, try it. */\n\tif (window != NULL && pane == NULL) {\n\t\t/* This will fill in session, winlink and window. */\n\t\tif (cmd_find_get_window(fs, window, window_only) != 0)\n\t\t\tgoto no_window;\n\t\tif (fs->wl != NULL) /* can be NULL if index only */\n\t\t\tfs->wp = fs->wl->window->active;\n\t\tgoto found;\n\t}\n\n\t/* If just pane is present, try it. */\n\tif (window == NULL && pane != NULL) {\n\t\t/* This will fill in session, winlink, window and pane. */\n\t\tif (cmd_find_get_pane(fs, pane, pane_only) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\ncurrent:\n\t/* Use the current session. */\n\tcmd_find_copy_state(fs, fs->current);\n\tif (flags & CMD_FIND_WINDOW_INDEX)\n\t\tfs->idx = -1;\n\tgoto found;\n\nerror:\n\tfs->current = NULL;\n\tlog_debug(\"%s: error\", __func__);\n\n\tfree(copy);\n\tif (flags & CMD_FIND_CANFAIL)\n\t\treturn (0);\n\treturn (-1);\n\nfound:\n\tfs->current = NULL;\n\tcmd_find_log_state(__func__, fs);\n\n\tfree(copy);\n\treturn (0);\n\nno_session:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(item, \"can't find session: %s\", session);\n\tgoto error;\n\nno_window:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(item, \"can't find window: %s\", window);\n\tgoto error;\n\nno_pane:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(item, \"can't find pane: %s\", pane);\n\tgoto error;\n}\n\n/* Find the current client. */\nstatic struct client *\ncmd_find_current_client(struct cmdq_item *item, int quiet)\n{\n\tstruct client\t\t*c = NULL, *found;\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp;\n\tstruct cmd_find_state\t fs;\n\n\tif (item != NULL)\n\t\tc = cmdq_get_client(item);\n\tif (c != NULL && c->session != NULL)\n\t\treturn (c);\n\n\tfound = NULL;\n\tif (c != NULL && (wp = cmd_find_inside_pane(c)) != NULL) {\n\t\tcmd_find_clear_state(&fs, CMD_FIND_QUIET);\n\t\tfs.w = wp->window;\n\t\tif (cmd_find_best_session_with_window(&fs) == 0)\n\t\t\tfound = cmd_find_best_client(fs.s);\n\t} else {\n\t\ts = cmd_find_best_session(NULL, 0, CMD_FIND_QUIET);\n\t\tif (s != NULL)\n\t\t\tfound = cmd_find_best_client(s);\n\t}\n\tif (found == NULL && item != NULL && !quiet)\n\t\tcmdq_error(item, \"no current client\");\n\tlog_debug(\"%s: no target, return %p\", __func__, found);\n\treturn (found);\n}\n\n/* Find the target client or report an error and return NULL. */\nstruct client *\ncmd_find_client(struct cmdq_item *item, const char *target, int quiet)\n{\n\tstruct client\t*c;\n\tchar\t\t*copy;\n\tsize_t\t\t size;\n\n\t/* A NULL argument means the current client. */\n\tif (target == NULL)\n\t\treturn (cmd_find_current_client(item, quiet));\n\tcopy = xstrdup(target);\n\n\t/* Trim a single trailing colon if any. */\n\tsize = strlen(copy);\n\tif (size != 0 && copy[size - 1] == ':')\n\t\tcopy[size - 1] = '\\0';\n\n\t/* Check name and path of each client. */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(copy, c->name) == 0)\n\t\t\tbreak;\n\n\t\tif (*c->ttyname == '\\0')\n\t\t\tcontinue;\n\t\tif (strcmp(copy, c->ttyname) == 0)\n\t\t\tbreak;\n\t\tif (strncmp(c->ttyname, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(copy, c->ttyname + (sizeof _PATH_DEV) - 1) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* If no client found, report an error. */\n\tif (c == NULL && !quiet)\n\t\tcmdq_error(item, \"can't find client: %s\", copy);\n\n\tfree(copy);\n\tlog_debug(\"%s: target %s, return %p\", __func__, target, c);\n\treturn (c);\n}\n"
        },
        {
          "name": "cmd-if-shell.c",
          "type": "blob",
          "size": 4.998046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n * Copyright (c) 2009 Nicholas Marriott <nicm@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Executes a tmux command if a shell command returns true or false.\n */\n\nstatic enum args_parse_type\tcmd_if_shell_args_parse(struct args *, u_int,\n\t\t\t\t    char **);\nstatic enum cmd_retval\t\tcmd_if_shell_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nstatic void\tcmd_if_shell_callback(struct job *);\nstatic void\tcmd_if_shell_free(void *);\n\nconst struct cmd_entry cmd_if_shell_entry = {\n\t.name = \"if-shell\",\n\t.alias = \"if\",\n\n\t.args = { \"bFt:\", 2, 3, cmd_if_shell_args_parse },\n\t.usage = \"[-bF] \" CMD_TARGET_PANE_USAGE \" shell-command command \"\n\t\t \"[command]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = 0,\n\t.exec = cmd_if_shell_exec\n};\n\nstruct cmd_if_shell_data {\n\tstruct args_command_state\t*cmd_if;\n\tstruct args_command_state\t*cmd_else;\n\n\tstruct client\t\t\t*client;\n\tstruct cmdq_item\t\t*item;\n};\n\nstatic enum args_parse_type\ncmd_if_shell_args_parse(__unused struct args *args, u_int idx,\n    __unused char **cause)\n{\n\tif (idx == 1 || idx == 2)\n\t\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n\treturn (ARGS_PARSE_STRING);\n}\n\nstatic enum cmd_retval\ncmd_if_shell_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct cmd_if_shell_data\t*cdata;\n\tstruct cmdq_item\t\t*new_item;\n\tchar\t\t\t\t*shellcmd;\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t\t*s = target->s;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tu_int\t\t\t\t count = args_count(args);\n\tint\t\t\t\t wait = !args_has(args, 'b');\n\n\tshellcmd = format_single_from_target(item, args_string(args, 0));\n\tif (args_has(args, 'F')) {\n\t\tif (*shellcmd != '0' && *shellcmd != '\\0')\n\t\t\tcmdlist = args_make_commands_now(self, item, 1, 0);\n\t\telse if (count == 3)\n\t\t\tcmdlist = args_make_commands_now(self, item, 2, 0);\n\t\telse {\n\t\t\tfree(shellcmd);\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\tfree(shellcmd);\n\t\tif (cmdlist == NULL)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\tnew_item = cmdq_get_command(cmdlist, cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\n\tcdata->cmd_if = args_make_commands_prepare(self, item, 1, NULL, wait,\n\t    0);\n\tif (count == 3) {\n\t\tcdata->cmd_else = args_make_commands_prepare(self, item, 2,\n\t\t    NULL, wait, 0);\n\t}\n\n\tif (wait) {\n\t\tcdata->client = cmdq_get_client(item);\n\t\tcdata->item = item;\n\t} else\n\t\tcdata->client = tc;\n\tif (cdata->client != NULL)\n\t\tcdata->client->references++;\n\n\tif (job_run(shellcmd, 0, NULL, NULL, s,\n\t    server_client_get_cwd(cmdq_get_client(item), s), NULL,\n\t    cmd_if_shell_callback, cmd_if_shell_free, cdata, 0, -1,\n\t    -1) == NULL) {\n\t\tcmdq_error(item, \"failed to run command: %s\", shellcmd);\n\t\tfree(shellcmd);\n\t\tfree(cdata);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tfree(shellcmd);\n\n\tif (!wait)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic void\ncmd_if_shell_callback(struct job *job)\n{\n\tstruct cmd_if_shell_data\t*cdata = job_get_data(job);\n\tstruct client\t\t\t*c = cdata->client;\n\tstruct cmdq_item\t\t*item = cdata->item, *new_item;\n\tstruct args_command_state\t*state;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tchar\t\t\t\t*error;\n\tint\t\t\t\t status;\n\n\tstatus = job_get_status(job);\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\tstate = cdata->cmd_else;\n\telse\n\t\tstate = cdata->cmd_if;\n\tif (state == NULL)\n\t\tgoto out;\n\n\tcmdlist = args_make_commands(state, 0, NULL, &error);\n\tif (cmdlist == NULL) {\n\t\tif (cdata->item == NULL) {\n\t\t\t*error = toupper((u_char)*error);\n\t\t\tstatus_message_set(c, -1, 1, 0, \"%s\", error);\n\t\t} else\n\t\t\tcmdq_error(cdata->item, \"%s\", error);\n\t\tfree(error);\n\t} else if (item == NULL) {\n\t\tnew_item = cmdq_get_command(cmdlist, NULL);\n\t\tcmdq_append(c, new_item);\n\t} else {\n\t\tnew_item = cmdq_get_command(cmdlist, cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t}\n\nout:\n\tif (cdata->item != NULL)\n\t\tcmdq_continue(cdata->item);\n}\n\nstatic void\ncmd_if_shell_free(void *data)\n{\n\tstruct cmd_if_shell_data\t*cdata = data;\n\n\tif (cdata->client != NULL)\n\t\tserver_client_unref(cdata->client);\n\n\tif (cdata->cmd_else != NULL)\n\t\targs_make_commands_free(cdata->cmd_else);\n\targs_make_commands_free(cdata->cmd_if);\n\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-join-pane.c",
          "type": "blob",
          "size": 4.73828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 George Nachman <tmux@georgester.com>\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Join or move a pane into another (like split/swap/kill).\n */\n\nstatic enum cmd_retval\tcmd_join_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_join_pane_entry = {\n\t.name = \"join-pane\",\n\t.alias = \"joinp\",\n\n\t.args = { \"bdfhvp:l:s:t:\", 0, 0, NULL },\n\t.usage = \"[-bdfhv] [-l size] \" CMD_SRCDST_PANE_USAGE,\n\n\t.source = { 's', CMD_FIND_PANE, CMD_FIND_DEFAULT_MARKED },\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_join_pane_exec\n};\n\nconst struct cmd_entry cmd_move_pane_entry = {\n\t.name = \"move-pane\",\n\t.alias = \"movep\",\n\n\t.args = { \"bdfhvp:l:s:t:\", 0, 0, NULL },\n\t.usage = \"[-bdfhv] [-l size] \" CMD_SRCDST_PANE_USAGE,\n\n\t.source = { 's', CMD_FIND_PANE, CMD_FIND_DEFAULT_MARKED },\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_join_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_join_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct session\t\t*dst_s;\n\tstruct winlink\t\t*src_wl, *dst_wl;\n\tstruct window\t\t*src_w, *dst_w;\n\tstruct window_pane\t*src_wp, *dst_wp;\n\tchar\t\t\t*cause = NULL;\n\tint\t\t\t size, dst_idx;\n\tint\t\t\t flags;\n\tenum layout_type\t type;\n\tstruct layout_cell\t*lc;\n\tu_int\t\t\t curval = 0;\n\n\tdst_s = target->s;\n\tdst_wl = target->wl;\n\tdst_wp = target->wp;\n\tdst_w = dst_wl->window;\n\tdst_idx = dst_wl->idx;\n\tserver_unzoom_window(dst_w);\n\n\tsrc_wl = source->wl;\n\tsrc_wp = source->wp;\n\tsrc_w = src_wl->window;\n\tserver_unzoom_window(src_w);\n\n\tif (src_wp == dst_wp) {\n\t\tcmdq_error(item, \"source and target panes must be different\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\ttype = LAYOUT_TOPBOTTOM;\n\tif (args_has(args, 'h'))\n\t\ttype = LAYOUT_LEFTRIGHT;\n\n\t/* If the 'p' flag is dropped then this bit can be moved into 'l'. */\n\tif (args_has(args, 'l') || args_has(args, 'p')) {\n\t\tif (args_has(args, 'f')) {\n\t\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\t\tcurval = dst_w->sy;\n\t\t\telse\n\t\t\t\tcurval = dst_w->sx;\n\t\t} else {\n\t\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\t\tcurval = dst_wp->sy;\n\t\t\telse\n\t\t\t\tcurval = dst_wp->sx;\n\t\t}\n\t}\n\n\tsize = -1;\n\tif (args_has(args, 'l')) {\n\t\tsize = args_percentage_and_expand(args, 'l', 0, INT_MAX, curval,\n\t\t\t   item, &cause);\n\t} else if (args_has(args, 'p')) {\n\t\tsize = args_strtonum_and_expand(args, 'l', 0, 100, item,\n\t\t\t   &cause);\n\t\tif (cause == NULL)\n\t\t\tsize = curval * size / 100;\n\t}\n\tif (cause != NULL) {\n\t\tcmdq_error(item, \"size %s\", cause);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tflags = 0;\n\tif (args_has(args, 'b'))\n\t\tflags |= SPAWN_BEFORE;\n\tif (args_has(args, 'f'))\n\t\tflags |= SPAWN_FULLSIZE;\n\n\tlc = layout_split_pane(dst_wp, type, size, flags);\n\tif (lc == NULL) {\n\t\tcmdq_error(item, \"create pane failed: pane too small\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tlayout_close_pane(src_wp);\n\n\tserver_client_remove_pane(src_wp);\n\twindow_lost_pane(src_w, src_wp);\n\tTAILQ_REMOVE(&src_w->panes, src_wp, entry);\n\n\tsrc_wp->window = dst_w;\n\toptions_set_parent(src_wp->options, dst_w->options);\n\tsrc_wp->flags |= PANE_STYLECHANGED;\n\tif (flags & SPAWN_BEFORE)\n\t\tTAILQ_INSERT_BEFORE(dst_wp, src_wp, entry);\n\telse\n\t\tTAILQ_INSERT_AFTER(&dst_w->panes, dst_wp, src_wp, entry);\n\tlayout_assign_pane(lc, src_wp, 0);\n\tcolour_palette_from_option(&src_wp->palette, src_wp->options);\n\n\trecalculate_sizes();\n\n\tserver_redraw_window(src_w);\n\tserver_redraw_window(dst_w);\n\n\tif (!args_has(args, 'd')) {\n\t\twindow_set_active_pane(dst_w, src_wp, 1);\n\t\tsession_select(dst_s, dst_idx);\n\t\tcmd_find_from_session(current, dst_s, 0);\n\t\tserver_redraw_session(dst_s);\n\t} else\n\t\tserver_status_session(dst_s);\n\n\tif (window_count_panes(src_w) == 0)\n\t\tserver_kill_window(src_w, 1);\n\telse\n\t\tnotify_window(\"window-layout-changed\", src_w);\n\tnotify_window(\"window-layout-changed\", dst_w);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-pane.c",
          "type": "blob",
          "size": 1.8857421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Kill pane.\n */\n\nstatic enum cmd_retval\tcmd_kill_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_kill_pane_entry = {\n\t.name = \"kill-pane\",\n\t.alias = \"killp\",\n\n\t.args = { \"at:\", 0, 0, NULL },\n\t.usage = \"[-a] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_kill_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_kill_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window_pane\t*loopwp, *tmpwp, *wp = target->wp;\n\n\tif (args_has(args, 'a')) {\n\t\tserver_unzoom_window(wl->window);\n\t\tTAILQ_FOREACH_SAFE(loopwp, &wl->window->panes, entry, tmpwp) {\n\t\t\tif (loopwp == wp)\n\t\t\t\tcontinue;\n\t\t\tserver_client_remove_pane(loopwp);\n\t\t\tlayout_close_pane(loopwp);\n\t\t\twindow_remove_pane(wl->window, loopwp);\n\t\t}\n\t\tserver_redraw_window(wl->window);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tserver_kill_pane(wp);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-server.c",
          "type": "blob",
          "size": 1.5927734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <signal.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Kill the server and do nothing else.\n */\n\nstatic enum cmd_retval\tcmd_kill_server_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_kill_server_entry = {\n\t.name = \"kill-server\",\n\t.alias = NULL,\n\n\t.args = { \"\", 0, 0, NULL },\n\t.usage = \"\",\n\n\t.flags = 0,\n\t.exec = cmd_kill_server_exec\n};\n\nconst struct cmd_entry cmd_start_server_entry = {\n\t.name = \"start-server\",\n\t.alias = \"start\",\n\n\t.args = { \"\", 0, 0, NULL },\n\t.usage = \"\",\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_kill_server_exec\n};\n\nstatic enum cmd_retval\ncmd_kill_server_exec(struct cmd *self, __unused struct cmdq_item *item)\n{\n\tif (cmd_get_entry(self) == &cmd_kill_server_entry)\n\t\tkill(getpid(), SIGTERM);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-session.c",
          "type": "blob",
          "size": 2.1103515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Destroy session, detaching all clients attached to it and destroying any\n * windows linked only to this session.\n *\n * Note this deliberately has no alias to make it hard to hit by accident.\n */\n\nstatic enum cmd_retval\tcmd_kill_session_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_kill_session_entry = {\n\t.name = \"kill-session\",\n\t.alias = NULL,\n\n\t.args = { \"aCt:\", 0, 0, NULL },\n\t.usage = \"[-aC] \" CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_kill_session_exec\n};\n\nstatic enum cmd_retval\ncmd_kill_session_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct session\t\t*s = target->s, *sloop, *stmp;\n\tstruct winlink\t\t*wl;\n\n\tif (args_has(args, 'C')) {\n\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\twl->window->flags &= ~WINDOW_ALERTFLAGS;\n\t\t\twl->flags &= ~WINLINK_ALERTFLAGS;\n\t\t}\n\t\tserver_redraw_session(s);\n\t} else if (args_has(args, 'a')) {\n\t\tRB_FOREACH_SAFE(sloop, sessions, &sessions, stmp) {\n\t\t\tif (sloop != s) {\n\t\t\t\tserver_destroy_session(sloop);\n\t\t\t\tsession_destroy(sloop, 1, __func__);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tserver_destroy_session(s);\n\t\tsession_destroy(s, 1, __func__);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-window.c",
          "type": "blob",
          "size": 2.8466796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Destroy window.\n */\n\nstatic enum cmd_retval\tcmd_kill_window_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_kill_window_entry = {\n\t.name = \"kill-window\",\n\t.alias = \"killw\",\n\n\t.args = { \"at:\", 0, 0, NULL },\n\t.usage = \"[-a] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_kill_window_exec\n};\n\nconst struct cmd_entry cmd_unlink_window_entry = {\n\t.name = \"unlink-window\",\n\t.alias = \"unlinkw\",\n\n\t.args = { \"kt:\", 0, 0, NULL },\n\t.usage = \"[-k] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_kill_window_exec\n};\n\nstatic enum cmd_retval\ncmd_kill_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl, *loop;\n\tstruct window\t\t*w = wl->window;\n\tstruct session\t\t*s = target->s;\n\tu_int\t\t\t found;\n\n\tif (cmd_get_entry(self) == &cmd_unlink_window_entry) {\n\t\tif (!args_has(args, 'k') && !session_is_linked(s, w)) {\n\t\t\tcmdq_error(item, \"window only linked to one session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tserver_unlink_window(s, wl);\n\t\trecalculate_sizes();\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'a')) {\n\t\tif (RB_PREV(winlinks, &s->windows, wl) == NULL &&\n\t\t    RB_NEXT(winlinks, &s->windows, wl) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\n\t\t/* Kill all windows except the current one. */\n\t\tdo {\n\t\t\tfound = 0;\n\t\t\tRB_FOREACH(loop, winlinks, &s->windows) {\n\t\t\t\tif (loop->window != wl->window) {\n\t\t\t\t\tserver_kill_window(loop->window, 0);\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (found != 0);\n\n\t\t/*\n\t\t * If the current window appears in the session more than once,\n\t\t * kill it as well.\n\t\t */\n\t\tfound = 0;\n\t\tRB_FOREACH(loop, winlinks, &s->windows) {\n\t\t\tif (loop->window == wl->window)\n\t\t\t\tfound++;\n\t\t}\n\t\tif (found > 1)\n\t\t\tserver_kill_window(wl->window, 0);\n\n\t\tserver_renumber_all();\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tserver_kill_window(wl->window, 1);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-buffers.c",
          "type": "blob",
          "size": 2.1298828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * List paste buffers.\n */\n\n#define LIST_BUFFERS_TEMPLATE\t\t\t\t\t\t\\\n\t\"#{buffer_name}: #{buffer_size} bytes: \\\"#{buffer_sample}\\\"\"\n\nstatic enum cmd_retval\tcmd_list_buffers_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_list_buffers_entry = {\n\t.name = \"list-buffers\",\n\t.alias = \"lsb\",\n\n\t.args = { \"F:f:\", 0, 0, NULL },\n\t.usage = \"[-F format] [-f filter]\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_list_buffers_exec\n};\n\nstatic enum cmd_retval\ncmd_list_buffers_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct paste_buffer\t*pb;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template, *filter;\n\tchar\t\t\t*line, *expanded;\n\tint\t\t\t flag;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_BUFFERS_TEMPLATE;\n\tfilter = args_get(args, 'f');\n\n\tpb = NULL;\n\twhile ((pb = paste_walk(pb)) != NULL) {\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\t\tformat_defaults_paste_buffer(ft, pb);\n\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tflag = format_true(expanded);\n\t\t\tfree(expanded);\n\t\t} else\n\t\t\tflag = 1;\n\t\tif (flag) {\n\t\t\tline = format_expand(ft, template);\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\t\tfree(line);\n\t\t}\n\n\t\tformat_free(ft);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-clients.c",
          "type": "blob",
          "size": 2.6796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * List all clients.\n */\n\n#define LIST_CLIENTS_TEMPLATE\t\t\t\t\t\t\\\n\t\"#{client_name}: #{session_name} \"\t\t\t\t\\\n\t\"[#{client_width}x#{client_height} #{client_termname}] \"\t\\\n\t\"#{?#{!=:#{client_uid},#{uid}},\"\t\t\t\t\\\n\t\"[user #{?client_user,#{client_user},#{client_uid},}] ,}\"\t\\\n\t\"#{?client_flags,(,}#{client_flags}#{?client_flags,),}\"\n\nstatic enum cmd_retval\tcmd_list_clients_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_list_clients_entry = {\n\t.name = \"list-clients\",\n\t.alias = \"lsc\",\n\n\t.args = { \"F:f:t:\", 0, 0, NULL },\n\t.usage = \"[-F format] [-f filter] \" CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = CMD_READONLY|CMD_AFTERHOOK,\n\t.exec = cmd_list_clients_exec\n};\n\nstatic enum cmd_retval\ncmd_list_clients_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args \t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*c;\n\tstruct session\t\t*s;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template, *filter;\n\tu_int\t\t\t idx;\n\tchar\t\t\t*line, *expanded;\n\tint\t\t\t flag;\n\n\tif (args_has(args, 't'))\n\t\ts = target->s;\n\telse\n\t\ts = NULL;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_CLIENTS_TEMPLATE;\n\tfilter = args_get(args, 'f');\n\n\tidx = 0;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || (s != NULL && s != c->session))\n\t\t\tcontinue;\n\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\t\tformat_add(ft, \"line\", \"%u\", idx);\n\t\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tflag = format_true(expanded);\n\t\t\tfree(expanded);\n\t\t} else\n\t\t\tflag = 1;\n\t\tif (flag) {\n\t\t\tline = format_expand(ft, template);\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\t\tfree(line);\n\t\t}\n\n\t\tformat_free(ft);\n\n\t\tidx++;\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-keys.c",
          "type": "blob",
          "size": 9.44140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * List key bindings.\n */\n\nstatic enum cmd_retval\tcmd_list_keys_exec(struct cmd *, struct cmdq_item *);\n\nstatic enum cmd_retval\tcmd_list_keys_commands(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_list_keys_entry = {\n\t.name = \"list-keys\",\n\t.alias = \"lsk\",\n\n\t.args = { \"1aNP:T:\", 0, 1, NULL },\n\t.usage = \"[-1aN] [-P prefix-string] [-T key-table] [key]\",\n\n\t.flags = CMD_STARTSERVER|CMD_AFTERHOOK,\n\t.exec = cmd_list_keys_exec\n};\n\nconst struct cmd_entry cmd_list_commands_entry = {\n\t.name = \"list-commands\",\n\t.alias = \"lscm\",\n\n\t.args = { \"F:\", 0, 1, NULL },\n\t.usage = \"[-F format] [command]\",\n\n\t.flags = CMD_STARTSERVER|CMD_AFTERHOOK,\n\t.exec = cmd_list_keys_exec\n};\n\nstatic u_int\ncmd_list_keys_get_width(const char *tablename, key_code only)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\tu_int\t\t\t width, keywidth = 0;\n\n\ttable = key_bindings_get_table(tablename, 0);\n\tif (table == NULL)\n\t\treturn (0);\n\tbd = key_bindings_first(table);\n\twhile (bd != NULL) {\n\t\tif ((only != KEYC_UNKNOWN && bd->key != only) ||\n\t\t    KEYC_IS_MOUSE(bd->key) ||\n\t\t    bd->note == NULL ||\n\t\t    *bd->note == '\\0') {\n\t\t\tbd = key_bindings_next(table, bd);\n\t\t\tcontinue;\n\t\t}\n\t\twidth = utf8_cstrwidth(key_string_lookup_key(bd->key, 0));\n\t\tif (width > keywidth)\n\t\t\tkeywidth = width;\n\n\t\tbd = key_bindings_next(table, bd);\n\t}\n\treturn (keywidth);\n}\n\nstatic int\ncmd_list_keys_print_notes(struct cmdq_item *item, struct args *args,\n    const char *tablename, u_int keywidth, key_code only, const char *prefix)\n{\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\tconst char\t\t*key;\n\tchar\t\t\t*tmp, *note;\n\tint\t                 found = 0;\n\n\ttable = key_bindings_get_table(tablename, 0);\n\tif (table == NULL)\n\t\treturn (0);\n\tbd = key_bindings_first(table);\n\twhile (bd != NULL) {\n\t\tif ((only != KEYC_UNKNOWN && bd->key != only) ||\n\t\t    KEYC_IS_MOUSE(bd->key) ||\n\t\t    ((bd->note == NULL || *bd->note == '\\0') &&\n\t\t    !args_has(args, 'a'))) {\n\t\t\tbd = key_bindings_next(table, bd);\n\t\t\tcontinue;\n\t\t}\n\t\tfound = 1;\n\t\tkey = key_string_lookup_key(bd->key, 0);\n\n\t\tif (bd->note == NULL || *bd->note == '\\0')\n\t\t\tnote = cmd_list_print(bd->cmdlist, 1);\n\t\telse\n\t\t\tnote = xstrdup(bd->note);\n\t\ttmp = utf8_padcstr(key, keywidth + 1);\n\t\tif (args_has(args, '1') && tc != NULL) {\n\t\t\tstatus_message_set(tc, -1, 1, 0, \"%s%s%s\", prefix, tmp,\n\t\t\t    note);\n\t\t} else\n\t\t\tcmdq_print(item, \"%s%s%s\", prefix, tmp, note);\n\t\tfree(tmp);\n\t\tfree(note);\n\n\t\tif (args_has(args, '1'))\n\t\t\tbreak;\n\t\tbd = key_bindings_next(table, bd);\n\t}\n\treturn (found);\n}\n\nstatic char *\ncmd_list_keys_get_prefix(struct args *args, key_code *prefix)\n{\n\tchar\t*s;\n\n\t*prefix = options_get_number(global_s_options, \"prefix\");\n\tif (!args_has(args, 'P')) {\n\t\tif (*prefix != KEYC_NONE)\n\t\t\txasprintf(&s, \"%s \", key_string_lookup_key(*prefix, 0));\n\t\telse\n\t\t\ts = xstrdup(\"\");\n\t} else\n\t\ts = xstrdup(args_get(args, 'P'));\n\treturn (s);\n}\n\nstatic enum cmd_retval\ncmd_list_keys_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\tconst char\t\t*tablename, *r, *keystr;\n\tchar\t\t\t*key, *cp, *tmp, *start, *empty;\n\tkey_code\t\t prefix, only = KEYC_UNKNOWN;\n\tint\t\t\t repeat, width, tablewidth, keywidth, found = 0;\n\tsize_t\t\t\t tmpsize, tmpused, cplen;\n\n\tif (cmd_get_entry(self) == &cmd_list_commands_entry)\n\t\treturn (cmd_list_keys_commands(self, item));\n\n\tif ((keystr = args_string(args, 0)) != NULL) {\n\t\tonly = key_string_lookup_string(keystr);\n\t\tif (only == KEYC_UNKNOWN) {\n\t\t\tcmdq_error(item, \"invalid key: %s\", keystr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tonly &= (KEYC_MASK_KEY|KEYC_MASK_MODIFIERS);\n\t}\n\n\ttablename = args_get(args, 'T');\n\tif (tablename != NULL && key_bindings_get_table(tablename, 0) == NULL) {\n\t\tcmdq_error(item, \"table %s doesn't exist\", tablename);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'N')) {\n\t\tif (tablename == NULL) {\n\t\t\tstart = cmd_list_keys_get_prefix(args, &prefix);\n\t\t\tkeywidth = cmd_list_keys_get_width(\"root\", only);\n\t\t\tif (prefix != KEYC_NONE) {\n\t\t\t\twidth = cmd_list_keys_get_width(\"prefix\", only);\n\t\t\t\tif (width == 0)\n\t\t\t\t\tprefix = KEYC_NONE;\n\t\t\t\telse if (width > keywidth)\n\t\t\t\t\tkeywidth = width;\n\t\t\t}\n\t\t\tempty = utf8_padcstr(\"\", utf8_cstrwidth(start));\n\n\t\t\tfound = cmd_list_keys_print_notes(item, args, \"root\",\n\t\t\t    keywidth, only, empty);\n\t\t\tif (prefix != KEYC_NONE) {\n\t\t\t\tif (cmd_list_keys_print_notes(item, args,\n\t\t\t\t    \"prefix\", keywidth, only, start))\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tfree(empty);\n\t\t} else {\n\t\t\tif (args_has(args, 'P'))\n\t\t\t\tstart = xstrdup(args_get(args, 'P'));\n\t\t\telse\n\t\t\t\tstart = xstrdup(\"\");\n\t\t\tkeywidth = cmd_list_keys_get_width(tablename, only);\n\t\t\tfound = cmd_list_keys_print_notes(item, args, tablename,\n\t\t\t    keywidth, only, start);\n\n\t\t}\n\t\tfree(start);\n\t\tgoto out;\n\t}\n\n\trepeat = 0;\n\ttablewidth = keywidth = 0;\n\ttable = key_bindings_first_table();\n\twhile (table != NULL) {\n\t\tif (tablename != NULL && strcmp(table->name, tablename) != 0) {\n\t\t\ttable = key_bindings_next_table(table);\n\t\t\tcontinue;\n\t\t}\n\t\tbd = key_bindings_first(table);\n\t\twhile (bd != NULL) {\n\t\t\tif (only != KEYC_UNKNOWN && bd->key != only) {\n\t\t\t\tbd = key_bindings_next(table, bd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkey = args_escape(key_string_lookup_key(bd->key, 0));\n\n\t\t\tif (bd->flags & KEY_BINDING_REPEAT)\n\t\t\t\trepeat = 1;\n\n\t\t\twidth = utf8_cstrwidth(table->name);\n\t\t\tif (width > tablewidth)\n\t\t\t\ttablewidth = width;\n\t\t\twidth = utf8_cstrwidth(key);\n\t\t\tif (width > keywidth)\n\t\t\t\tkeywidth = width;\n\n\t\t\tfree(key);\n\t\t\tbd = key_bindings_next(table, bd);\n\t\t}\n\t\ttable = key_bindings_next_table(table);\n\t}\n\n\ttmpsize = 256;\n\ttmp = xmalloc(tmpsize);\n\n\ttable = key_bindings_first_table();\n\twhile (table != NULL) {\n\t\tif (tablename != NULL && strcmp(table->name, tablename) != 0) {\n\t\t\ttable = key_bindings_next_table(table);\n\t\t\tcontinue;\n\t\t}\n\t\tbd = key_bindings_first(table);\n\t\twhile (bd != NULL) {\n\t\t\tif (only != KEYC_UNKNOWN && bd->key != only) {\n\t\t\t\tbd = key_bindings_next(table, bd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tkey = args_escape(key_string_lookup_key(bd->key, 0));\n\n\t\t\tif (!repeat)\n\t\t\t\tr = \"\";\n\t\t\telse if (bd->flags & KEY_BINDING_REPEAT)\n\t\t\t\tr = \"-r \";\n\t\t\telse\n\t\t\t\tr = \"   \";\n\t\t\ttmpused = xsnprintf(tmp, tmpsize, \"%s-T \", r);\n\n\t\t\tcp = utf8_padcstr(table->name, tablewidth);\n\t\t\tcplen = strlen(cp) + 1;\n\t\t\twhile (tmpused + cplen + 1 >= tmpsize) {\n\t\t\t\ttmpsize *= 2;\n\t\t\t\ttmp = xrealloc(tmp, tmpsize);\n\t\t\t}\n\t\t\tstrlcat(tmp, cp, tmpsize);\n\t\t\ttmpused = strlcat(tmp, \" \", tmpsize);\n\t\t\tfree(cp);\n\n\t\t\tcp = utf8_padcstr(key, keywidth);\n\t\t\tcplen = strlen(cp) + 1;\n\t\t\twhile (tmpused + cplen + 1 >= tmpsize) {\n\t\t\t\ttmpsize *= 2;\n\t\t\t\ttmp = xrealloc(tmp, tmpsize);\n\t\t\t}\n\t\t\tstrlcat(tmp, cp, tmpsize);\n\t\t\ttmpused = strlcat(tmp, \" \", tmpsize);\n\t\t\tfree(cp);\n\n\t\t\tcp = cmd_list_print(bd->cmdlist, 1);\n\t\t\tcplen = strlen(cp);\n\t\t\twhile (tmpused + cplen + 1 >= tmpsize) {\n\t\t\t\ttmpsize *= 2;\n\t\t\t\ttmp = xrealloc(tmp, tmpsize);\n\t\t\t}\n\t\t\tstrlcat(tmp, cp, tmpsize);\n\t\t\tfree(cp);\n\n\t\t\tif (args_has(args, '1') && tc != NULL) {\n\t\t\t\tstatus_message_set(tc, -1, 1, 0, \"bind-key %s\",\n\t\t\t\t    tmp);\n\t\t\t} else\n\t\t\t\tcmdq_print(item, \"bind-key %s\", tmp);\n\t\t\tfree(key);\n\n\t\t\tif (args_has(args, '1'))\n\t\t\t\tbreak;\n\t\t\tbd = key_bindings_next(table, bd);\n\t\t}\n\t\ttable = key_bindings_next_table(table);\n\t}\n\n\tfree(tmp);\n\nout:\n\tif (only != KEYC_UNKNOWN && !found) {\n\t\tcmdq_error(item, \"unknown key: %s\", args_string(args, 0));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncmd_list_keys_commands(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t *args = cmd_get_args(self);\n\tconst struct cmd_entry\t**entryp;\n\tconst struct cmd_entry\t *entry;\n\tstruct format_tree\t *ft;\n\tconst char\t\t *template, *s, *command;\n\tchar\t\t\t *line;\n\n\tif ((template = args_get(args, 'F')) == NULL) {\n\t\ttemplate = \"#{command_list_name}\"\n\t\t    \"#{?command_list_alias, (#{command_list_alias}),} \"\n\t\t    \"#{command_list_usage}\";\n\t}\n\n\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\tformat_defaults(ft, NULL, NULL, NULL, NULL);\n\n\tcommand = args_string(args, 0);\n\tfor (entryp = cmd_table; *entryp != NULL; entryp++) {\n\t\tentry = *entryp;\n\t\tif (command != NULL &&\n\t\t    (strcmp(entry->name, command) != 0 &&\n\t\t    (entry->alias == NULL ||\n\t\t    strcmp(entry->alias, command) != 0)))\n\t\t    continue;\n\n\t\tformat_add(ft, \"command_list_name\", \"%s\", entry->name);\n\t\tif (entry->alias != NULL)\n\t\t\ts = entry->alias;\n\t\telse\n\t\t\ts = \"\";\n\t\tformat_add(ft, \"command_list_alias\", \"%s\", s);\n\t\tif (entry->usage != NULL)\n\t\t\ts = entry->usage;\n\t\telse\n\t\t\ts = \"\";\n\t\tformat_add(ft, \"command_list_usage\", \"%s\", s);\n\n\t\tline = format_expand(ft, template);\n\t\tif (*line != '\\0')\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\tfree(line);\n\t}\n\n\tformat_free(ft);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-panes.c",
          "type": "blob",
          "size": 4.07421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * List panes on given window.\n */\n\nstatic enum cmd_retval\tcmd_list_panes_exec(struct cmd *, struct cmdq_item *);\n\nstatic void\tcmd_list_panes_server(struct cmd *, struct cmdq_item *);\nstatic void\tcmd_list_panes_session(struct cmd *, struct session *,\n\t\t    struct cmdq_item *, int);\nstatic void\tcmd_list_panes_window(struct cmd *, struct session *,\n\t\t    struct winlink *, struct cmdq_item *, int);\n\nconst struct cmd_entry cmd_list_panes_entry = {\n\t.name = \"list-panes\",\n\t.alias = \"lsp\",\n\n\t.args = { \"asF:f:t:\", 0, 0, NULL },\n\t.usage = \"[-as] [-F format] [-f filter] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_list_panes_exec\n};\n\nstatic enum cmd_retval\ncmd_list_panes_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl;\n\n\tif (args_has(args, 'a'))\n\t\tcmd_list_panes_server(self, item);\n\telse if (args_has(args, 's'))\n\t\tcmd_list_panes_session(self, s, item, 1);\n\telse\n\t\tcmd_list_panes_window(self, s, wl, item, 0);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_list_panes_server(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tcmd_list_panes_session(self, s, item, 2);\n}\n\nstatic void\ncmd_list_panes_session(struct cmd *self, struct session *s,\n    struct cmdq_item *item, int type)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, &s->windows)\n\t\tcmd_list_panes_window(self, s, wl, item, type);\n}\n\nstatic void\ncmd_list_panes_window(struct cmd *self, struct session *s, struct winlink *wl,\n    struct cmdq_item *item, int type)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template, *filter;\n\tchar\t\t\t*line, *expanded;\n\tint\t\t\t flag;\n\n\ttemplate = args_get(args, 'F');\n\tif (template == NULL) {\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\ttemplate = \"#{pane_index}: \"\n\t\t\t    \"[#{pane_width}x#{pane_height}] [history \"\n\t\t\t    \"#{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemplate = \"#{window_index}.#{pane_index}: \"\n\t\t\t    \"[#{pane_width}x#{pane_height}] [history \"\n\t\t\t    \"#{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttemplate = \"#{session_name}:#{window_index}.\"\n\t\t\t    \"#{pane_index}: [#{pane_width}x#{pane_height}] \"\n\t\t\t    \"[history #{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tfilter = args_get(args, 'f');\n\n\tn = 0;\n\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, wl, wp);\n\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tflag = format_true(expanded);\n\t\t\tfree(expanded);\n\t\t} else\n\t\t\tflag = 1;\n\t\tif (flag) {\n\t\t\tline = format_expand(ft, template);\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\t\tfree(line);\n\t\t}\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n}\n"
        },
        {
          "name": "cmd-list-sessions.c",
          "type": "blob",
          "size": 2.34375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * List all sessions.\n */\n\n#define LIST_SESSIONS_TEMPLATE\t\t\t\t\\\n\t\"#{session_name}: #{session_windows} windows \"\t\\\n\t\"(created #{t:session_created})\"\t\t\\\n\t\"#{?session_grouped, (group ,}\"\t\t\t\\\n\t\"#{session_group}#{?session_grouped,),}\"\t\\\n\t\"#{?session_attached, (attached),}\"\n\nstatic enum cmd_retval\tcmd_list_sessions_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_list_sessions_entry = {\n\t.name = \"list-sessions\",\n\t.alias = \"ls\",\n\n\t.args = { \"F:f:\", 0, 0, NULL },\n\t.usage = \"[-F format] [-f filter]\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_list_sessions_exec\n};\n\nstatic enum cmd_retval\ncmd_list_sessions_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct session\t\t*s;\n\tu_int\t\t \t n;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template, *filter;\n\tchar\t\t\t*line, *expanded;\n\tint\t\t\t flag;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_SESSIONS_TEMPLATE;\n\tfilter = args_get(args, 'f');\n\n\tn = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, NULL, NULL);\n\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tflag = format_true(expanded);\n\t\t\tfree(expanded);\n\t\t} else\n\t\t\tflag = 1;\n\t\tif (flag) {\n\t\t\tline = format_expand(ft, template);\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\t\tfree(line);\n\t\t}\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-windows.c",
          "type": "blob",
          "size": 3.412109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * List windows on given session.\n */\n\n#define LIST_WINDOWS_TEMPLATE\t\t\t\t\t\\\n\t\"#{window_index}: #{window_name}#{window_raw_flags} \"\t\\\n\t\"(#{window_panes} panes) \"\t\t\t\t\\\n\t\"[#{window_width}x#{window_height}] \"\t\t\t\\\n\t\"[layout #{window_layout}] #{window_id}\"\t\t\\\n\t\"#{?window_active, (active),}\";\n#define LIST_WINDOWS_WITH_SESSION_TEMPLATE\t\t\t\\\n\t\"#{session_name}:\"\t\t\t\t\t\\\n\t\"#{window_index}: #{window_name}#{window_raw_flags} \"\t\\\n\t\"(#{window_panes} panes) \"\t\t\t\t\\\n\t\"[#{window_width}x#{window_height}] \"\n\nstatic enum cmd_retval\tcmd_list_windows_exec(struct cmd *, struct cmdq_item *);\n\nstatic void\tcmd_list_windows_server(struct cmd *, struct cmdq_item *);\nstatic void\tcmd_list_windows_session(struct cmd *, struct session *,\n\t\t    struct cmdq_item *, int);\n\nconst struct cmd_entry cmd_list_windows_entry = {\n\t.name = \"list-windows\",\n\t.alias = \"lsw\",\n\n\t.args = { \"F:f:at:\", 0, 0, NULL },\n\t.usage = \"[-a] [-F format] [-f filter] \" CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_list_windows_exec\n};\n\nstatic enum cmd_retval\ncmd_list_windows_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\n\tif (args_has(args, 'a'))\n\t\tcmd_list_windows_server(self, item);\n\telse\n\t\tcmd_list_windows_session(self, target->s, item, 0);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_list_windows_server(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tcmd_list_windows_session(self, s, item, 1);\n}\n\nstatic void\ncmd_list_windows_session(struct cmd *self, struct session *s,\n    struct cmdq_item *item, int type)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct winlink\t\t*wl;\n\tu_int\t\t\t n;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template, *filter;\n\tchar\t\t\t*line, *expanded;\n\tint\t\t\t flag;\n\n\ttemplate = args_get(args, 'F');\n\tif (template == NULL) {\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\ttemplate = LIST_WINDOWS_TEMPLATE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemplate = LIST_WINDOWS_WITH_SESSION_TEMPLATE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfilter = args_get(args, 'f');\n\n\tn = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, wl, NULL);\n\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tflag = format_true(expanded);\n\t\t\tfree(expanded);\n\t\t} else\n\t\t\tflag = 1;\n\t\tif (flag) {\n\t\t\tline = format_expand(ft, template);\n\t\t\tcmdq_print(item, \"%s\", line);\n\t\t\tfree(line);\n\t\t}\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n}\n"
        },
        {
          "name": "cmd-load-buffer.c",
          "type": "blob",
          "size": 3.0166015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Loads a paste buffer from a file.\n */\n\nstatic enum cmd_retval\tcmd_load_buffer_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_load_buffer_entry = {\n\t.name = \"load-buffer\",\n\t.alias = \"loadb\",\n\n\t.args = { \"b:t:w\", 1, 1, NULL },\n\t.usage = CMD_BUFFER_USAGE \" \" CMD_TARGET_CLIENT_USAGE \" path\",\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG|CMD_CLIENT_CANFAIL,\n\t.exec = cmd_load_buffer_exec\n};\n\nstruct cmd_load_buffer_data {\n\tstruct client\t\t*client;\n\tstruct cmdq_item\t*item;\n\tchar\t\t\t*name;\n};\n\nstatic void\ncmd_load_buffer_done(__unused struct client *c, const char *path, int error,\n    int closed, struct evbuffer *buffer, void *data)\n{\n\tstruct cmd_load_buffer_data\t*cdata = data;\n\tstruct client\t\t\t*tc = cdata->client;\n\tstruct cmdq_item\t\t*item = cdata->item;\n\tvoid\t\t\t\t*bdata = EVBUFFER_DATA(buffer);\n\tsize_t\t\t\t\t bsize = EVBUFFER_LENGTH(buffer);\n\tvoid\t\t\t\t*copy;\n\tchar\t\t\t\t*cause;\n\n\tif (!closed)\n\t\treturn;\n\n\tif (error != 0)\n\t\tcmdq_error(item, \"%s: %s\", path, strerror(error));\n\telse if (bsize != 0) {\n\t\tcopy = xmalloc(bsize);\n\t\tmemcpy(copy, bdata, bsize);\n\t\tif (paste_set(copy, bsize, cdata->name, &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tfree(copy);\n\t\t} else if (tc != NULL &&\n\t\t    tc->session != NULL &&\n\t\t    (~tc->flags & CLIENT_DEAD))\n\t\t\ttty_set_selection(&tc->tty, \"\", copy, bsize);\n\t\tif (tc != NULL)\n\t\t\tserver_client_unref(tc);\n\t}\n\tcmdq_continue(item);\n\n\tfree(cdata->name);\n\tfree(cdata);\n}\n\nstatic enum cmd_retval\ncmd_load_buffer_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct cmd_load_buffer_data\t*cdata;\n\tconst char\t\t\t*bufname = args_get(args, 'b');\n\tchar\t\t\t\t*path;\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tcdata->item = item;\n\tif (bufname != NULL)\n\t\tcdata->name = xstrdup(bufname);\n\tif (args_has(args, 'w') && tc != NULL) {\n\t\tcdata->client = tc;\n\t\tcdata->client->references++;\n\t}\n\n\tpath = format_single_from_target(item, args_string(args, 0));\n\tfile_read(cmdq_get_client(item), path, cmd_load_buffer_done, cdata);\n\tfree(path);\n\n\treturn (CMD_RETURN_WAIT);\n}\n"
        },
        {
          "name": "cmd-lock-server.c",
          "type": "blob",
          "size": 2.068359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Lock commands.\n */\n\nstatic enum cmd_retval\tcmd_lock_server_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_lock_server_entry = {\n\t.name = \"lock-server\",\n\t.alias = \"lock\",\n\n\t.args = { \"\", 0, 0, NULL },\n\t.usage = \"\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_lock_server_exec\n};\n\nconst struct cmd_entry cmd_lock_session_entry = {\n\t.name = \"lock-session\",\n\t.alias = \"locks\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_lock_server_exec\n};\n\nconst struct cmd_entry cmd_lock_client_entry = {\n\t.name = \"lock-client\",\n\t.alias = \"lockc\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_CLIENT_USAGE,\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG,\n\t.exec = cmd_lock_server_exec\n};\n\nstatic enum cmd_retval\ncmd_lock_server_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\n\tif (cmd_get_entry(self) == &cmd_lock_server_entry)\n\t\tserver_lock();\n\telse if (cmd_get_entry(self) == &cmd_lock_session_entry)\n\t\tserver_lock_session(target->s);\n\telse\n\t\tserver_lock_client(tc);\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-move-window.c",
          "type": "blob",
          "size": 3.2685546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Move a window.\n */\n\nstatic enum cmd_retval\tcmd_move_window_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_move_window_entry = {\n\t.name = \"move-window\",\n\t.alias = \"movew\",\n\n\t.args = { \"abdkrs:t:\", 0, 0, NULL },\n\t.usage = \"[-abdkr] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.source = { 's', CMD_FIND_WINDOW, 0 },\n\t/* -t is special */\n\n\t.flags = 0,\n\t.exec = cmd_move_window_exec\n};\n\nconst struct cmd_entry cmd_link_window_entry = {\n\t.name = \"link-window\",\n\t.alias = \"linkw\",\n\n\t.args = { \"abdks:t:\", 0, 0, NULL },\n\t.usage = \"[-abdk] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.source = { 's', CMD_FIND_WINDOW, 0 },\n\t/* -t is special */\n\n\t.flags = 0,\n\t.exec = cmd_move_window_exec\n};\n\nstatic enum cmd_retval\ncmd_move_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct cmd_find_state\t target;\n\tconst char\t\t*tflag = args_get(args, 't');\n\tstruct session\t\t*src = source->s;\n\tstruct session\t\t*dst;\n\tstruct winlink\t\t*wl = source->wl;\n\tchar\t\t\t*cause;\n\tint\t\t\t idx, kflag, dflag, sflag, before;\n\n\tif (args_has(args, 'r')) {\n\t\tif (cmd_find_target(&target, item, tflag, CMD_FIND_SESSION,\n\t\t    CMD_FIND_QUIET) != 0)\n\t\t\treturn (CMD_RETURN_ERROR);\n\n\t\tsession_renumber_windows(target.s);\n\t\trecalculate_sizes();\n\t\tserver_status_session(target.s);\n\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (cmd_find_target(&target, item, tflag, CMD_FIND_WINDOW,\n\t    CMD_FIND_WINDOW_INDEX) != 0)\n\t\treturn (CMD_RETURN_ERROR);\n\tdst = target.s;\n\tidx = target.idx;\n\n\tkflag = args_has(args, 'k');\n\tdflag = args_has(args, 'd');\n\tsflag = args_has(args, 's');\n\n\tbefore = args_has(args, 'b');\n\tif (args_has(args, 'a') || before) {\n\t\tif (target.wl != NULL)\n\t\t\tidx = winlink_shuffle_up(dst, target.wl, before);\n\t\telse\n\t\t\tidx = winlink_shuffle_up(dst, dst->curw, before);\n\t\tif (idx == -1)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (server_link_window(src, wl, dst, idx, kflag, !dflag, &cause) != 0) {\n\t\tcmdq_error(item, \"%s\", cause);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (cmd_get_entry(self) == &cmd_move_window_entry)\n\t\tserver_unlink_window(src, wl);\n\n\t/*\n\t * Renumber the winlinks in the src session only, the destination\n\t * session already has the correct winlink id to us, either\n\t * automatically or specified by -s.\n\t */\n\tif (!sflag && options_get_number(src->options, \"renumber-windows\"))\n\t\tsession_renumber_windows(src);\n\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-new-session.c",
          "type": "blob",
          "size": 9.4560546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Create a new session and attach to the current terminal unless -d is given.\n */\n\n#define NEW_SESSION_TEMPLATE \"#{session_name}:\"\n\nstatic enum cmd_retval\tcmd_new_session_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_new_session_entry = {\n\t.name = \"new-session\",\n\t.alias = \"new\",\n\n\t.args = { \"Ac:dDe:EF:f:n:Ps:t:x:Xy:\", 0, -1, NULL },\n\t.usage = \"[-AdDEPX] [-c start-directory] [-e environment] [-F format] \"\n\t\t \"[-f flags] [-n window-name] [-s session-name] \"\n\t\t CMD_TARGET_SESSION_USAGE \" [-x width] [-y height] \"\n\t\t \"[shell-command]\",\n\n\t.target = { 't', CMD_FIND_SESSION, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_new_session_exec\n};\n\nconst struct cmd_entry cmd_has_session_entry = {\n\t.name = \"has-session\",\n\t.alias = \"has\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_new_session_exec\n};\n\nstatic enum cmd_retval\ncmd_new_session_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct session\t\t*s, *as, *groupwith = NULL;\n\tstruct environ\t\t*env;\n\tstruct options\t\t*oo;\n\tstruct termios\t\t tio, *tiop;\n\tstruct session_group\t*sg = NULL;\n\tconst char\t\t*errstr, *template, *group, *tmp;\n\tchar\t\t\t*cause, *cwd = NULL, *cp, *newname = NULL;\n\tchar\t\t\t*name, *prefix = NULL;\n\tint\t\t\t detached, already_attached, is_control = 0;\n\tu_int\t\t\t sx, sy, dsx, dsy, count = args_count(args);\n\tstruct spawn_context\t sc = { 0 };\n\tenum cmd_retval\t\t retval;\n\tstruct cmd_find_state    fs;\n\tstruct args_value\t*av;\n\n\tif (cmd_get_entry(self) == &cmd_has_session_entry) {\n\t\t/*\n\t\t * cmd_find_target() will fail if the session cannot be found,\n\t\t * so always return success here.\n\t\t */\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 't') && (count != 0 || args_has(args, 'n'))) {\n\t\tcmdq_error(item, \"command or window name given with target\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\ttmp = args_get(args, 's');\n\tif (tmp != NULL) {\n\t\tname = format_single(item, tmp, c, NULL, NULL, NULL);\n\t\tnewname = session_check_name(name);\n\t\tif (newname == NULL) {\n\t\t\tcmdq_error(item, \"invalid session: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tfree(name);\n\t}\n\tif (args_has(args, 'A')) {\n\t\tif (newname != NULL)\n\t\t\tas = session_find(newname);\n\t\telse\n\t\t\tas = target->s;\n\t\tif (as != NULL) {\n\t\t\tretval = cmd_attach_session(item, as->name,\n\t\t\t    args_has(args, 'D'), args_has(args, 'X'), 0, NULL,\n\t\t\t    args_has(args, 'E'), args_get(args, 'f'));\n\t\t\tfree(newname);\n\t\t\treturn (retval);\n\t\t}\n\t}\n\tif (newname != NULL && session_find(newname) != NULL) {\n\t\tcmdq_error(item, \"duplicate session: %s\", newname);\n\t\tgoto fail;\n\t}\n\n\t/* Is this going to be part of a session group? */\n\tgroup = args_get(args, 't');\n\tif (group != NULL) {\n\t\tgroupwith = target->s;\n\t\tif (groupwith == NULL)\n\t\t\tsg = session_group_find(group);\n\t\telse\n\t\t\tsg = session_group_contains(groupwith);\n\t\tif (sg != NULL)\n\t\t\tprefix = xstrdup(sg->name);\n\t\telse if (groupwith != NULL)\n\t\t\tprefix = xstrdup(groupwith->name);\n\t\telse {\n\t\t\tprefix = session_check_name(group);\n\t\t\tif (prefix == NULL) {\n\t\t\t\tcmdq_error(item, \"invalid session group: %s\",\n\t\t\t\t    group);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set -d if no client. */\n\tdetached = args_has(args, 'd');\n\tif (c == NULL)\n\t\tdetached = 1;\n\telse if (c->flags & CLIENT_CONTROL)\n\t\tis_control = 1;\n\n\t/* Is this client already attached? */\n\talready_attached = 0;\n\tif (c != NULL && c->session != NULL)\n\t\talready_attached = 1;\n\n\t/* Get the new session working directory. */\n\tif ((tmp = args_get(args, 'c')) != NULL)\n\t\tcwd = format_single(item, tmp, c, NULL, NULL, NULL);\n\telse\n\t\tcwd = xstrdup(server_client_get_cwd(c, NULL));\n\n\t/*\n\t * If this is a new client, check for nesting and save the termios\n\t * settings (part of which is used for new windows in this session).\n\t *\n\t * tcgetattr() is used rather than using tty.tio since if the client is\n\t * detached, tty_open won't be called. It must be done before opening\n\t * the terminal as that calls tcsetattr() to prepare for tmux taking\n\t * over.\n\t */\n\tif (!detached &&\n\t    !already_attached &&\n\t    c->fd != -1 &&\n\t    (~c->flags & CLIENT_CONTROL)) {\n\t\tif (server_client_check_nested(cmdq_get_client(item))) {\n\t\t\tcmdq_error(item, \"sessions should be nested with care, \"\n\t\t\t    \"unset $TMUX to force\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (tcgetattr(c->fd, &tio) != 0)\n\t\t\tfatal(\"tcgetattr failed\");\n\t\ttiop = &tio;\n\t} else\n\t\ttiop = NULL;\n\n\t/* Open the terminal if necessary. */\n\tif (!detached && !already_attached) {\n\t\tif (server_client_open(c, &cause) != 0) {\n\t\t\tcmdq_error(item, \"open terminal failed: %s\", cause);\n\t\t\tfree(cause);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* Get default session size. */\n\tif (args_has(args, 'x')) {\n\t\ttmp = args_get(args, 'x');\n\t\tif (strcmp(tmp, \"-\") == 0) {\n\t\t\tif (c != NULL)\n\t\t\t\tdsx = c->tty.sx;\n\t\t\telse\n\t\t\t\tdsx = 80;\n\t\t} else {\n\t\t\tdsx = strtonum(tmp, 1, USHRT_MAX, &errstr);\n\t\t\tif (errstr != NULL) {\n\t\t\t\tcmdq_error(item, \"width %s\", errstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else\n\t\tdsx = 80;\n\tif (args_has(args, 'y')) {\n\t\ttmp = args_get(args, 'y');\n\t\tif (strcmp(tmp, \"-\") == 0) {\n\t\t\tif (c != NULL)\n\t\t\t\tdsy = c->tty.sy;\n\t\t\telse\n\t\t\t\tdsy = 24;\n\t\t} else {\n\t\t\tdsy = strtonum(tmp, 1, USHRT_MAX, &errstr);\n\t\t\tif (errstr != NULL) {\n\t\t\t\tcmdq_error(item, \"height %s\", errstr);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else\n\t\tdsy = 24;\n\n\t/* Find new session size. */\n\tif (!detached && !is_control) {\n\t\tsx = c->tty.sx;\n\t\tsy = c->tty.sy;\n\t\tif (sy > 0 && options_get_number(global_s_options, \"status\"))\n\t\t\tsy--;\n\t} else {\n\t\ttmp = options_get_string(global_s_options, \"default-size\");\n\t\tif (sscanf(tmp, \"%ux%u\", &sx, &sy) != 2) {\n\t\t\tsx = dsx;\n\t\t\tsy = dsy;\n\t\t} else {\n\t\t\tif (args_has(args, 'x'))\n\t\t\t\tsx = dsx;\n\t\t\tif (args_has(args, 'y'))\n\t\t\t\tsy = dsy;\n\t\t}\n\t}\n\tif (sx == 0)\n\t\tsx = 1;\n\tif (sy == 0)\n\t\tsy = 1;\n\n\t/* Create the new session. */\n\too = options_create(global_s_options);\n\tif (args_has(args, 'x') || args_has(args, 'y')) {\n\t\tif (!args_has(args, 'x'))\n\t\t\tdsx = sx;\n\t\tif (!args_has(args, 'y'))\n\t\t\tdsy = sy;\n\t\toptions_set_string(oo, \"default-size\", 0, \"%ux%u\", dsx, dsy);\n\t}\n\tenv = environ_create();\n\tif (c != NULL && !args_has(args, 'E'))\n\t\tenviron_update(global_s_options, c->environ, env);\n\tav = args_first_value(args, 'e');\n\twhile (av != NULL) {\n\t\tenviron_put(env, av->string, 0);\n\t\tav = args_next_value(av);\n\t}\n\ts = session_create(prefix, newname, cwd, env, oo, tiop);\n\n\t/* Spawn the initial window. */\n\tsc.item = item;\n\tsc.s = s;\n\tif (!detached)\n\t\tsc.tc = c;\n\n\tsc.name = args_get(args, 'n');\n\targs_to_vector(args, &sc.argc, &sc.argv);\n\n\tsc.idx = -1;\n\tsc.cwd = args_get(args, 'c');\n\n\tsc.flags = 0;\n\n\tif (spawn_window(&sc, &cause) == NULL) {\n\t\tsession_destroy(s, 0, __func__);\n\t\tcmdq_error(item, \"create window failed: %s\", cause);\n\t\tfree(cause);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * If a target session is given, this is to be part of a session group,\n\t * so add it to the group and synchronize.\n\t */\n\tif (group != NULL) {\n\t\tif (sg == NULL) {\n\t\t\tif (groupwith != NULL) {\n\t\t\t\tsg = session_group_new(groupwith->name);\n\t\t\t\tsession_group_add(sg, groupwith);\n\t\t\t} else\n\t\t\t\tsg = session_group_new(group);\n\t\t}\n\t\tsession_group_add(sg, s);\n\t\tsession_group_synchronize_to(s);\n\t\tsession_select(s, RB_MIN(winlinks, &s->windows)->idx);\n\t}\n\tnotify_session(\"session-created\", s);\n\n\t/*\n\t * Set the client to the new session. If a command client exists, it is\n\t * taking this session and needs to get MSG_READY and stay around.\n\t */\n\tif (!detached) {\n\t\tif (args_has(args, 'f'))\n\t\t\tserver_client_set_flags(c, args_get(args, 'f'));\n\t\tif (!already_attached) {\n\t\t\tif (~c->flags & CLIENT_CONTROL)\n\t\t\t\tproc_send(c->peer, MSG_READY, -1, NULL, 0);\n\t\t} else if (c->session != NULL)\n\t\t\tc->last_session = c->session;\n\t\tserver_client_set_session(c, s);\n\t\tif (~cmdq_get_flags(item) & CMDQ_STATE_REPEAT)\n\t\t\tserver_client_set_key_table(c, NULL);\n\t}\n\n\t/* Print if requested. */\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = NEW_SESSION_TEMPLATE;\n\t\tcp = format_single(item, template, c, s, s->curw, NULL);\n\t\tcmdq_print(item, \"%s\", cp);\n\t\tfree(cp);\n\t}\n\n\tif (!detached)\n\t\tc->flags |= CLIENT_ATTACHED;\n\tif (!args_has(args, 'd'))\n\t\tcmd_find_from_session(current, s, 0);\n\n\tcmd_find_from_session(&fs, s, 0);\n\tcmdq_insert_hook(s, item, &fs, \"after-new-session\");\n\n\tif (cfg_finished)\n\t\tcfg_show_causes(s);\n\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tfree(cwd);\n\tfree(newname);\n\tfree(prefix);\n\treturn (CMD_RETURN_NORMAL);\n\nfail:\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tfree(cwd);\n\tfree(newname);\n\tfree(prefix);\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-new-window.c",
          "type": "blob",
          "size": 4.3759765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Create a new window.\n */\n\n#define NEW_WINDOW_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nstatic enum cmd_retval\tcmd_new_window_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_new_window_entry = {\n\t.name = \"new-window\",\n\t.alias = \"neww\",\n\n\t.args = { \"abc:de:F:kn:PSt:\", 0, -1, NULL },\n\t.usage = \"[-abdkPS] [-c start-directory] [-e environment] [-F format] \"\n\t\t \"[-n window-name] \" CMD_TARGET_WINDOW_USAGE \" [shell-command]\",\n\n\t.target = { 't', CMD_FIND_WINDOW, CMD_FIND_WINDOW_INDEX },\n\n\t.flags = 0,\n\t.exec = cmd_new_window_exec\n};\n\nstatic enum cmd_retval\ncmd_new_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct spawn_context\t sc = { 0 };\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl, *new_wl = NULL;\n\tint\t\t\t idx = target->idx, before;\n\tchar\t\t\t*cause = NULL, *cp, *expanded;\n\tconst char\t\t*template, *name;\n\tstruct cmd_find_state\t fs;\n\tstruct args_value\t*av;\n\n\t/*\n\t * If -S and -n are given and -t is not and a single window with this\n\t * name already exists, select it.\n\t */\n\tname = args_get(args, 'n');\n\tif (args_has(args, 'S') && name != NULL && target->idx == -1) {\n\t\texpanded = format_single(item, name, c, s, NULL, NULL);\n\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\tif (strcmp(wl->window->name, expanded) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (new_wl == NULL) {\n\t\t\t\tnew_wl = wl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcmdq_error(item, \"multiple windows named %s\", name);\n\t\t\tfree(expanded);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tfree(expanded);\n\t\tif (new_wl != NULL) {\n\t\t\tif (args_has(args, 'd'))\n\t\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t\tif (session_set_current(s, new_wl) == 0)\n\t\t\t\tserver_redraw_session(s);\n\t\t\tif (c != NULL && c->session != NULL)\n\t\t\t\ts->curw->window->latest = c;\n\t\t\trecalculate_sizes();\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t}\n\n\tbefore = args_has(args, 'b');\n\tif (args_has(args, 'a') || before) {\n\t\tidx = winlink_shuffle_up(s, wl, before);\n\t\tif (idx == -1)\n\t\t\tidx = target->idx;\n\t}\n\n\tsc.item = item;\n\tsc.s = s;\n\tsc.tc = tc;\n\n\tsc.name = args_get(args, 'n');\n\targs_to_vector(args, &sc.argc, &sc.argv);\n\tsc.environ = environ_create();\n\n\tav = args_first_value(args, 'e');\n\twhile (av != NULL) {\n\t\tenviron_put(sc.environ, av->string, 0);\n\t\tav = args_next_value(av);\n\t}\n\n\tsc.idx = idx;\n\tsc.cwd = args_get(args, 'c');\n\n\tsc.flags = 0;\n\tif (args_has(args, 'd'))\n\t\tsc.flags |= SPAWN_DETACHED;\n\tif (args_has(args, 'k'))\n\t\tsc.flags |= SPAWN_KILL;\n\n\tif ((new_wl = spawn_window(&sc, &cause)) == NULL) {\n\t\tcmdq_error(item, \"create window failed: %s\", cause);\n\t\tfree(cause);\n\t\tif (sc.argv != NULL)\n\t\t\tcmd_free_argv(sc.argc, sc.argv);\n\t\tenviron_free(sc.environ);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (!args_has(args, 'd') || new_wl == s->curw) {\n\t\tcmd_find_from_winlink(current, new_wl, 0);\n\t\tserver_redraw_session_group(s);\n\t} else\n\t\tserver_status_session_group(s);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = NEW_WINDOW_TEMPLATE;\n\t\tcp = format_single(item, template, tc, s, new_wl,\n\t\t\tnew_wl->window->active);\n\t\tcmdq_print(item, \"%s\", cp);\n\t\tfree(cp);\n\t}\n\n\tcmd_find_from_winlink(&fs, new_wl, 0);\n\tcmdq_insert_hook(s, item, &fs, \"after-new-window\");\n\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tenviron_free(sc.environ);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-parse.y",
          "type": "blob",
          "size": 35.4013671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n%{\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <wchar.h>\n\n#include \"tmux.h\"\n\nstatic int\t\t\t yylex(void);\nstatic int\t\t\t yyparse(void);\nstatic int printflike(1,2)\t yyerror(const char *, ...);\n\nstatic char\t\t\t*yylex_token(int);\nstatic char\t\t\t*yylex_format(void);\n\nstruct cmd_parse_scope {\n\tint\t\t\t\t flag;\n\tTAILQ_ENTRY (cmd_parse_scope)\t entry;\n};\n\nenum cmd_parse_argument_type {\n\tCMD_PARSE_STRING,\n\tCMD_PARSE_COMMANDS,\n\tCMD_PARSE_PARSED_COMMANDS\n};\n\nstruct cmd_parse_argument {\n\tenum cmd_parse_argument_type\t type;\n\tchar\t\t\t\t*string;\n\tstruct cmd_parse_commands\t*commands;\n\tstruct cmd_list\t\t\t*cmdlist;\n\n\tTAILQ_ENTRY(cmd_parse_argument)\t entry;\n};\nTAILQ_HEAD(cmd_parse_arguments, cmd_parse_argument);\n\nstruct cmd_parse_command {\n\tu_int\t\t\t\t line;\n\tstruct cmd_parse_arguments\t arguments;\n\n\tTAILQ_ENTRY(cmd_parse_command)\t entry;\n};\nTAILQ_HEAD(cmd_parse_commands, cmd_parse_command);\n\nstruct cmd_parse_state {\n\tFILE\t\t\t\t*f;\n\n\tconst char\t\t\t*buf;\n\tsize_t\t\t\t\t len;\n\tsize_t\t\t\t\t off;\n\n\tint\t\t\t\t condition;\n\tint\t\t\t\t eol;\n\tint\t\t\t\t eof;\n\tstruct cmd_parse_input\t\t*input;\n\tu_int\t\t\t\t escapes;\n\n\tchar\t\t\t\t*error;\n\tstruct cmd_parse_commands\t*commands;\n\n\tstruct cmd_parse_scope\t\t*scope;\n\tTAILQ_HEAD(, cmd_parse_scope)\t stack;\n};\nstatic struct cmd_parse_state parse_state;\n\nstatic char\t*cmd_parse_get_error(const char *, u_int, const char *);\nstatic void\t cmd_parse_free_command(struct cmd_parse_command *);\nstatic struct cmd_parse_commands *cmd_parse_new_commands(void);\nstatic void\t cmd_parse_free_commands(struct cmd_parse_commands *);\nstatic void\t cmd_parse_build_commands(struct cmd_parse_commands *,\n\t\t     struct cmd_parse_input *, struct cmd_parse_result *);\nstatic void\t cmd_parse_print_commands(struct cmd_parse_input *,\n\t\t     struct cmd_list *);\n\n%}\n\n%union\n{\n\tchar\t\t\t\t\t *token;\n\tstruct cmd_parse_arguments\t\t *arguments;\n\tstruct cmd_parse_argument\t\t *argument;\n\tint\t\t\t\t\t  flag;\n\tstruct {\n\t\tint\t\t\t\t  flag;\n\t\tstruct cmd_parse_commands\t *commands;\n\t} elif;\n\tstruct cmd_parse_commands\t\t *commands;\n\tstruct cmd_parse_command\t\t *command;\n}\n\n%token ERROR\n%token HIDDEN\n%token IF\n%token ELSE\n%token ELIF\n%token ENDIF\n%token <token> FORMAT TOKEN EQUALS\n\n%type <token> expanded format\n%type <arguments> arguments\n%type <argument> argument\n%type <flag> if_open if_elif\n%type <elif> elif elif1\n%type <commands> argument_statements statements statement\n%type <commands> commands condition condition1\n%type <command> command\n\n%%\n\nlines\t\t: /* empty */\n\t\t| statements\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\tps->commands = $1;\n\t\t}\n\nstatements\t: statement '\\n'\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\t\t| statements statement '\\n'\n\t\t{\n\t\t\t$$ = $1;\n\t\t\tTAILQ_CONCAT($$, $2, entry);\n\t\t\tfree($2);\n\t\t}\n\nstatement\t: /* empty */\n\t\t{\n\t\t\t$$ = xmalloc (sizeof *$$);\n\t\t\tTAILQ_INIT($$);\n\t\t}\n\t\t| hidden_assignment\n\t\t{\n\t\t\t$$ = xmalloc (sizeof *$$);\n\t\t\tTAILQ_INIT($$);\n\t\t}\n\t\t| condition\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\tif (ps->scope == NULL || ps->scope->flag)\n\t\t\t\t$$ = $1;\n\t\t\telse {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($1);\n\t\t\t}\n\t\t}\n\t\t| commands\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\tif (ps->scope == NULL || ps->scope->flag)\n\t\t\t\t$$ = $1;\n\t\t\telse {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($1);\n\t\t\t}\n\t\t}\n\nformat\t\t: FORMAT\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\t\t| TOKEN\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\nexpanded\t: format\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_input\t*pi = ps->input;\n\t\t\tstruct format_tree\t*ft;\n\t\t\tstruct client\t\t*c = pi->c;\n\t\t\tstruct cmd_find_state\t*fsp;\n\t\t\tstruct cmd_find_state\t fs;\n\t\t\tint\t\t\t flags = FORMAT_NOJOBS;\n\n\t\t\tif (cmd_find_valid_state(&pi->fs))\n\t\t\t\tfsp = &pi->fs;\n\t\t\telse {\n\t\t\t\tcmd_find_from_client(&fs, c, 0);\n\t\t\t\tfsp = &fs;\n\t\t\t}\n\t\t\tft = format_create(NULL, pi->item, FORMAT_NONE, flags);\n\t\t\tformat_defaults(ft, c, fsp->s, fsp->wl, fsp->wp);\n\n\t\t\t$$ = format_expand(ft, $1);\n\t\t\tformat_free(ft);\n\t\t\tfree($1);\n\t\t}\n\noptional_assignment\t: /* empty */\n\t\t\t| assignment\n\nassignment\t: EQUALS\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tint\t\t\t flags = ps->input->flags;\n\t\t\tint\t\t\t flag = 1;\n\t\t\tstruct cmd_parse_scope\t*scope;\n\n\t\t\tif (ps->scope != NULL) {\n\t\t\t\tflag = ps->scope->flag;\n\t\t\t\tTAILQ_FOREACH(scope, &ps->stack, entry)\n\t\t\t\t\tflag = flag && scope->flag;\n\t\t\t}\n\n\t\t\tif ((~flags & CMD_PARSE_PARSEONLY) && flag)\n\t\t\t\tenviron_put(global_environ, $1, 0);\n\t\t\tfree($1);\n\t\t}\n\nhidden_assignment : HIDDEN EQUALS\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tint\t\t\t flags = ps->input->flags;\n\t\t\tint\t\t\t flag = 1;\n\t\t\tstruct cmd_parse_scope\t*scope;\n\n\t\t\tif (ps->scope != NULL) {\n\t\t\t\tflag = ps->scope->flag;\n\t\t\t\tTAILQ_FOREACH(scope, &ps->stack, entry)\n\t\t\t\t\tflag = flag && scope->flag;\n\t\t\t}\n\n\t\t\tif ((~flags & CMD_PARSE_PARSEONLY) && flag)\n\t\t\t\tenviron_put(global_environ, $2, ENVIRON_HIDDEN);\n\t\t\tfree($2);\n\t\t}\n\nif_open\t\t: IF expanded\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_scope\t*scope;\n\n\t\t\tscope = xmalloc(sizeof *scope);\n\t\t\t$$ = scope->flag = format_true($2);\n\t\t\tfree($2);\n\n\t\t\tif (ps->scope != NULL)\n\t\t\t\tTAILQ_INSERT_HEAD(&ps->stack, ps->scope, entry);\n\t\t\tps->scope = scope;\n\t\t}\n\nif_else\t\t: ELSE\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_scope\t*scope;\n\n\t\t\tscope = xmalloc(sizeof *scope);\n\t\t\tscope->flag = !ps->scope->flag;\n\n\t\t\tfree(ps->scope);\n\t\t\tps->scope = scope;\n\t\t}\n\nif_elif\t\t: ELIF expanded\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_scope\t*scope;\n\n\t\t\tscope = xmalloc(sizeof *scope);\n\t\t\t$$ = scope->flag = format_true($2);\n\t\t\tfree($2);\n\n\t\t\tfree(ps->scope);\n\t\t\tps->scope = scope;\n\t\t}\n\nif_close\t: ENDIF\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\tfree(ps->scope);\n\t\t\tps->scope = TAILQ_FIRST(&ps->stack);\n\t\t\tif (ps->scope != NULL)\n\t\t\t\tTAILQ_REMOVE(&ps->stack, ps->scope, entry);\n\t\t}\n\ncondition\t: if_open '\\n' statements if_close\n\t\t{\n\t\t\tif ($1)\n\t\t\t\t$$ = $3;\n\t\t\telse {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t}\n\t\t}\n\t\t| if_open '\\n' statements if_else '\\n' statements if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $3;\n\t\t\t\tcmd_parse_free_commands($6);\n\t\t\t} else {\n\t\t\t\t$$ = $6;\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t}\n\t\t}\n\t\t| if_open '\\n' statements elif if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $3;\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t} else if ($4.flag) {\n\t\t\t\t$$ = $4.commands;\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t} else {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t}\n\t\t}\n\t\t| if_open '\\n' statements elif if_else '\\n' statements if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $3;\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t\tcmd_parse_free_commands($7);\n\t\t\t} else if ($4.flag) {\n\t\t\t\t$$ = $4.commands;\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t\tcmd_parse_free_commands($7);\n\t\t\t} else {\n\t\t\t\t$$ = $7;\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t}\n\t\t}\n\nelif\t\t: if_elif '\\n' statements\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $3;\n\t\t\t} else {\n\t\t\t\t$$.flag = 0;\n\t\t\t\t$$.commands = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t}\n\t\t}\n\t\t| if_elif '\\n' statements elif\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $3;\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t} else if ($4.flag) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $4.commands;\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t} else {\n\t\t\t\t$$.flag = 0;\n\t\t\t\t$$.commands = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($3);\n\t\t\t\tcmd_parse_free_commands($4.commands);\n\t\t\t}\n\t\t}\n\ncommands\t: command\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\t$$ = cmd_parse_new_commands();\n\t\t\tif (!TAILQ_EMPTY(&$1->arguments) &&\n\t\t\t    (ps->scope == NULL || ps->scope->flag))\n\t\t\t\tTAILQ_INSERT_TAIL($$, $1, entry);\n\t\t\telse\n\t\t\t\tcmd_parse_free_command($1);\n\t\t}\n\t\t| commands ';'\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\t\t| commands ';' condition1\n\t\t{\n\t\t\t$$ = $1;\n\t\t\tTAILQ_CONCAT($$, $3, entry);\n\t\t\tfree($3);\n\t\t}\n\t\t| commands ';' command\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\tif (!TAILQ_EMPTY(&$3->arguments) &&\n\t\t\t    (ps->scope == NULL || ps->scope->flag)) {\n\t\t\t\t$$ = $1;\n\t\t\t\tTAILQ_INSERT_TAIL($$, $3, entry);\n\t\t\t} else {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($1);\n\t\t\t\tcmd_parse_free_command($3);\n\t\t\t}\n\t\t}\n\t\t| condition1\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\ncommand\t\t: assignment\n\t\t{\n\t\t\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->line = ps->input->line;\n\t\t\tTAILQ_INIT(&$$->arguments);\n\t\t}\n\t\t| optional_assignment TOKEN\n\t\t{\n\t\t\tstruct cmd_parse_state\t\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_argument\t*arg;\n\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->line = ps->input->line;\n\t\t\tTAILQ_INIT(&$$->arguments);\n\n\t\t\targ = xcalloc(1, sizeof *arg);\n\t\t\targ->type = CMD_PARSE_STRING;\n\t\t\targ->string = $2;\n\t\t\tTAILQ_INSERT_HEAD(&$$->arguments, arg, entry);\n\t\t}\n\t\t| optional_assignment TOKEN arguments\n\t\t{\n\t\t\tstruct cmd_parse_state\t\t*ps = &parse_state;\n\t\t\tstruct cmd_parse_argument\t*arg;\n\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->line = ps->input->line;\n\t\t\tTAILQ_INIT(&$$->arguments);\n\n\t\t\tTAILQ_CONCAT(&$$->arguments, $3, entry);\n\t\t\tfree($3);\n\n\t\t\targ = xcalloc(1, sizeof *arg);\n\t\t\targ->type = CMD_PARSE_STRING;\n\t\t\targ->string = $2;\n\t\t\tTAILQ_INSERT_HEAD(&$$->arguments, arg, entry);\n\t\t}\n\ncondition1\t: if_open commands if_close\n\t\t{\n\t\t\tif ($1)\n\t\t\t\t$$ = $2;\n\t\t\telse {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t}\n\t\t}\n\t\t| if_open commands if_else commands if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $2;\n\t\t\t\tcmd_parse_free_commands($4);\n\t\t\t} else {\n\t\t\t\t$$ = $4;\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t}\n\t\t}\n\t\t| if_open commands elif1 if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $2;\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t} else if ($3.flag) {\n\t\t\t\t$$ = $3.commands;\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t} else {\n\t\t\t\t$$ = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t}\n\t\t}\n\t\t| if_open commands elif1 if_else commands if_close\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$ = $2;\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t\tcmd_parse_free_commands($5);\n\t\t\t} else if ($3.flag) {\n\t\t\t\t$$ = $3.commands;\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t\tcmd_parse_free_commands($5);\n\t\t\t} else {\n\t\t\t\t$$ = $5;\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t}\n\t\t}\n\nelif1\t\t: if_elif commands\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $2;\n\t\t\t} else {\n\t\t\t\t$$.flag = 0;\n\t\t\t\t$$.commands = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t}\n\t\t}\n\t\t| if_elif commands elif1\n\t\t{\n\t\t\tif ($1) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $2;\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t} else if ($3.flag) {\n\t\t\t\t$$.flag = 1;\n\t\t\t\t$$.commands = $3.commands;\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t} else {\n\t\t\t\t$$.flag = 0;\n\t\t\t\t$$.commands = cmd_parse_new_commands();\n\t\t\t\tcmd_parse_free_commands($2);\n\t\t\t\tcmd_parse_free_commands($3.commands);\n\t\t\t}\n\t\t}\n\narguments\t: argument\n\t\t{\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\tTAILQ_INIT($$);\n\n\t\t\tTAILQ_INSERT_HEAD($$, $1, entry);\n\t\t}\n\t\t| argument arguments\n\t\t{\n\t\t\tTAILQ_INSERT_HEAD($2, $1, entry);\n\t\t\t$$ = $2;\n\t\t}\n\nargument\t: TOKEN\n\t\t{\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->type = CMD_PARSE_STRING;\n\t\t\t$$->string = $1;\n\t\t}\n\t\t| EQUALS\n\t\t{\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->type = CMD_PARSE_STRING;\n\t\t\t$$->string = $1;\n\t\t}\n\t\t| '{' argument_statements\n\t\t{\n\t\t\t$$ = xcalloc(1, sizeof *$$);\n\t\t\t$$->type = CMD_PARSE_COMMANDS;\n\t\t\t$$->commands = $2;\n\t\t}\n\nargument_statements\t: statement '}'\n\t\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t\t\t| statements statement '}'\n\t\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t\tTAILQ_CONCAT($$, $2, entry);\n\t\t\t\tfree($2);\n\t\t\t}\n\n%%\n\nstatic char *\ncmd_parse_get_error(const char *file, u_int line, const char *error)\n{\n\tchar\t*s;\n\n\tif (file == NULL)\n\t\ts = xstrdup(error);\n\telse\n\t\txasprintf(&s, \"%s:%u: %s\", file, line, error);\n\treturn (s);\n}\n\nstatic void\ncmd_parse_print_commands(struct cmd_parse_input *pi, struct cmd_list *cmdlist)\n{\n\tchar\t*s;\n\n\tif (pi->item == NULL || (~pi->flags & CMD_PARSE_VERBOSE))\n\t\treturn;\n\ts = cmd_list_print(cmdlist, 0);\n\tif (pi->file != NULL)\n\t\tcmdq_print(pi->item, \"%s:%u: %s\", pi->file, pi->line, s);\n\telse\n\t\tcmdq_print(pi->item, \"%u: %s\", pi->line, s);\n\tfree(s);\n}\n\nstatic void\ncmd_parse_free_argument(struct cmd_parse_argument *arg)\n{\n\tswitch (arg->type) {\n\tcase CMD_PARSE_STRING:\n\t\tfree(arg->string);\n\t\tbreak;\n\tcase CMD_PARSE_COMMANDS:\n\t\tcmd_parse_free_commands(arg->commands);\n\t\tbreak;\n\tcase CMD_PARSE_PARSED_COMMANDS:\n\t\tcmd_list_free(arg->cmdlist);\n\t\tbreak;\n\t}\n\tfree(arg);\n}\n\nstatic void\ncmd_parse_free_arguments(struct cmd_parse_arguments *args)\n{\n\tstruct cmd_parse_argument\t*arg, *arg1;\n\n\tTAILQ_FOREACH_SAFE(arg, args, entry, arg1) {\n\t\tTAILQ_REMOVE(args, arg, entry);\n\t\tcmd_parse_free_argument(arg);\n\t}\n}\n\nstatic void\ncmd_parse_free_command(struct cmd_parse_command *cmd)\n{\n\tcmd_parse_free_arguments(&cmd->arguments);\n\tfree(cmd);\n}\n\nstatic struct cmd_parse_commands *\ncmd_parse_new_commands(void)\n{\n\tstruct cmd_parse_commands\t*cmds;\n\n\tcmds = xmalloc(sizeof *cmds);\n\tTAILQ_INIT(cmds);\n\treturn (cmds);\n}\n\nstatic void\ncmd_parse_free_commands(struct cmd_parse_commands *cmds)\n{\n\tstruct cmd_parse_command\t*cmd, *cmd1;\n\n\tTAILQ_FOREACH_SAFE(cmd, cmds, entry, cmd1) {\n\t\tTAILQ_REMOVE(cmds, cmd, entry);\n\t\tcmd_parse_free_command(cmd);\n\t}\n\tfree(cmds);\n}\n\nstatic struct cmd_parse_commands *\ncmd_parse_run_parser(char **cause)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\tstruct cmd_parse_scope\t*scope, *scope1;\n\tint\t\t\t retval;\n\n\tps->commands = NULL;\n\tTAILQ_INIT(&ps->stack);\n\n\tretval = yyparse();\n\tTAILQ_FOREACH_SAFE(scope, &ps->stack, entry, scope1) {\n\t\tTAILQ_REMOVE(&ps->stack, scope, entry);\n\t\tfree(scope);\n\t}\n\tif (retval != 0) {\n\t\t*cause = ps->error;\n\t\treturn (NULL);\n\t}\n\n\tif (ps->commands == NULL)\n\t\treturn (cmd_parse_new_commands());\n\treturn (ps->commands);\n}\n\nstatic struct cmd_parse_commands *\ncmd_parse_do_file(FILE *f, struct cmd_parse_input *pi, char **cause)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\tmemset(ps, 0, sizeof *ps);\n\tps->input = pi;\n\tps->f = f;\n\treturn (cmd_parse_run_parser(cause));\n}\n\nstatic struct cmd_parse_commands *\ncmd_parse_do_buffer(const char *buf, size_t len, struct cmd_parse_input *pi,\n    char **cause)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\tmemset(ps, 0, sizeof *ps);\n\tps->input = pi;\n\tps->buf = buf;\n\tps->len = len;\n\treturn (cmd_parse_run_parser(cause));\n}\n\nstatic void\ncmd_parse_log_commands(struct cmd_parse_commands *cmds, const char *prefix)\n{\n\tstruct cmd_parse_command\t*cmd;\n\tstruct cmd_parse_argument\t*arg;\n\tu_int\t\t\t\t i, j;\n\tchar\t\t\t\t*s;\n\n\ti = 0;\n\tTAILQ_FOREACH(cmd, cmds, entry) {\n\t\tj = 0;\n\t\tTAILQ_FOREACH(arg, &cmd->arguments, entry) {\n\t\t\tswitch (arg->type) {\n\t\t\tcase CMD_PARSE_STRING:\n\t\t\t\tlog_debug(\"%s %u:%u: %s\", prefix, i, j,\n\t\t\t\t    arg->string);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PARSE_COMMANDS:\n\t\t\t\txasprintf(&s, \"%s %u:%u\", prefix, i, j);\n\t\t\t\tcmd_parse_log_commands(arg->commands, s);\n\t\t\t\tfree(s);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PARSE_PARSED_COMMANDS:\n\t\t\t\ts = cmd_list_print(arg->cmdlist, 0);\n\t\t\t\tlog_debug(\"%s %u:%u: %s\", prefix, i, j, s);\n\t\t\t\tfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic int\ncmd_parse_expand_alias(struct cmd_parse_command *cmd,\n    struct cmd_parse_input *pi, struct cmd_parse_result *pr)\n{\n\tstruct cmd_parse_argument\t*arg, *arg1, *first;\n\tstruct cmd_parse_commands\t*cmds;\n\tstruct cmd_parse_command\t*last;\n\tchar\t\t\t\t*alias, *name, *cause;\n\n\tif (pi->flags & CMD_PARSE_NOALIAS)\n\t\treturn (0);\n\tmemset(pr, 0, sizeof *pr);\n\n\tfirst = TAILQ_FIRST(&cmd->arguments);\n\tif (first == NULL || first->type != CMD_PARSE_STRING) {\n\t\tpr->status = CMD_PARSE_SUCCESS;\n\t\tpr->cmdlist = cmd_list_new();\n\t\treturn (1);\n\t}\n\tname = first->string;\n\n\talias = cmd_get_alias(name);\n\tif (alias == NULL)\n\t\treturn (0);\n\tlog_debug(\"%s: %u alias %s = %s\", __func__, pi->line, name, alias);\n\n\tcmds = cmd_parse_do_buffer(alias, strlen(alias), pi, &cause);\n\tfree(alias);\n\tif (cmds == NULL) {\n\t\tpr->status = CMD_PARSE_ERROR;\n\t\tpr->error = cause;\n\t\treturn (1);\n\t}\n\n\tlast = TAILQ_LAST(cmds, cmd_parse_commands);\n\tif (last == NULL) {\n\t\tpr->status = CMD_PARSE_SUCCESS;\n\t\tpr->cmdlist = cmd_list_new();\n\t\treturn (1);\n\t}\n\n\tTAILQ_REMOVE(&cmd->arguments, first, entry);\n\tcmd_parse_free_argument(first);\n\n\tTAILQ_FOREACH_SAFE(arg, &cmd->arguments, entry, arg1) {\n\t\tTAILQ_REMOVE(&cmd->arguments, arg, entry);\n\t\tTAILQ_INSERT_TAIL(&last->arguments, arg, entry);\n\t}\n\tcmd_parse_log_commands(cmds, __func__);\n\n\tpi->flags |= CMD_PARSE_NOALIAS;\n\tcmd_parse_build_commands(cmds, pi, pr);\n\tpi->flags &= ~CMD_PARSE_NOALIAS;\n\treturn (1);\n}\n\nstatic void\ncmd_parse_build_command(struct cmd_parse_command *cmd,\n    struct cmd_parse_input *pi, struct cmd_parse_result *pr)\n{\n\tstruct cmd_parse_argument\t*arg;\n\tstruct cmd\t\t\t*add;\n\tchar\t\t\t\t*cause;\n\tstruct args_value\t\t*values = NULL;\n\tu_int\t\t\t\t count = 0, idx;\n\n\tmemset(pr, 0, sizeof *pr);\n\n\tif (cmd_parse_expand_alias(cmd, pi, pr))\n\t\treturn;\n\n\tTAILQ_FOREACH(arg, &cmd->arguments, entry) {\n\t\tvalues = xrecallocarray(values, count, count + 1,\n\t\t    sizeof *values);\n\t\tswitch (arg->type) {\n\t\tcase CMD_PARSE_STRING:\n\t\t\tvalues[count].type = ARGS_STRING;\n\t\t\tvalues[count].string = xstrdup(arg->string);\n\t\t\tbreak;\n\t\tcase CMD_PARSE_COMMANDS:\n\t\t\tcmd_parse_build_commands(arg->commands, pi, pr);\n\t\t\tif (pr->status != CMD_PARSE_SUCCESS)\n\t\t\t\tgoto out;\n\t\t\tvalues[count].type = ARGS_COMMANDS;\n\t\t\tvalues[count].cmdlist = pr->cmdlist;\n\t\t\tbreak;\n\t\tcase CMD_PARSE_PARSED_COMMANDS:\n\t\t\tvalues[count].type = ARGS_COMMANDS;\n\t\t\tvalues[count].cmdlist = arg->cmdlist;\n\t\t\tvalues[count].cmdlist->references++;\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t}\n\n\tadd = cmd_parse(values, count, pi->file, pi->line, &cause);\n\tif (add == NULL) {\n\t\tpr->status = CMD_PARSE_ERROR;\n\t\tpr->error = cmd_parse_get_error(pi->file, pi->line, cause);\n\t\tfree(cause);\n\t\tgoto out;\n\t}\n\tpr->status = CMD_PARSE_SUCCESS;\n\tpr->cmdlist = cmd_list_new();\n\tcmd_list_append(pr->cmdlist, add);\n\nout:\n\tfor (idx = 0; idx < count; idx++)\n\t\targs_free_value(&values[idx]);\n\tfree(values);\n}\n\nstatic void\ncmd_parse_build_commands(struct cmd_parse_commands *cmds,\n    struct cmd_parse_input *pi, struct cmd_parse_result *pr)\n{\n\tstruct cmd_parse_command\t*cmd;\n\tu_int\t\t\t\t line = UINT_MAX;\n\tstruct cmd_list\t\t\t*current = NULL, *result;\n\tchar\t\t\t\t*s;\n\n\tmemset(pr, 0, sizeof *pr);\n\n\t/* Check for an empty list. */\n\tif (TAILQ_EMPTY(cmds)) {\n\t\tpr->status = CMD_PARSE_SUCCESS;\n\t\tpr->cmdlist = cmd_list_new();\n\t\treturn;\n\t}\n\tcmd_parse_log_commands(cmds, __func__);\n\n\t/*\n\t * Parse each command into a command list. Create a new command list\n\t * for each line (unless the flag is set) so they get a new group (so\n\t * the queue knows which ones to remove if a command fails when\n\t * executed).\n\t */\n\tresult = cmd_list_new();\n\tTAILQ_FOREACH(cmd, cmds, entry) {\n\t\tif (((~pi->flags & CMD_PARSE_ONEGROUP) && cmd->line != line)) {\n\t\t\tif (current != NULL) {\n\t\t\t\tcmd_parse_print_commands(pi, current);\n\t\t\t\tcmd_list_move(result, current);\n\t\t\t\tcmd_list_free(current);\n\t\t\t}\n\t\t\tcurrent = cmd_list_new();\n\t\t}\n\t\tif (current == NULL)\n\t\t\tcurrent = cmd_list_new();\n\t\tline = pi->line = cmd->line;\n\n\t\tcmd_parse_build_command(cmd, pi, pr);\n\t\tif (pr->status != CMD_PARSE_SUCCESS) {\n\t\t\tcmd_list_free(result);\n\t\t\tcmd_list_free(current);\n\t\t\treturn;\n\t\t}\n\t\tcmd_list_append_all(current, pr->cmdlist);\n\t\tcmd_list_free(pr->cmdlist);\n\t}\n\tif (current != NULL) {\n\t\tcmd_parse_print_commands(pi, current);\n\t\tcmd_list_move(result, current);\n\t\tcmd_list_free(current);\n\t}\n\n\ts = cmd_list_print(result, 0);\n\tlog_debug(\"%s: %s\", __func__, s);\n\tfree(s);\n\n\tpr->status = CMD_PARSE_SUCCESS;\n\tpr->cmdlist = result;\n}\n\nstruct cmd_parse_result *\ncmd_parse_from_file(FILE *f, struct cmd_parse_input *pi)\n{\n\tstatic struct cmd_parse_result\t pr;\n\tstruct cmd_parse_input\t\t input;\n\tstruct cmd_parse_commands\t*cmds;\n\tchar\t\t\t\t*cause;\n\n\tif (pi == NULL) {\n\t\tmemset(&input, 0, sizeof input);\n\t\tpi = &input;\n\t}\n\tmemset(&pr, 0, sizeof pr);\n\n\tcmds = cmd_parse_do_file(f, pi, &cause);\n\tif (cmds == NULL) {\n\t\tpr.status = CMD_PARSE_ERROR;\n\t\tpr.error = cause;\n\t\treturn (&pr);\n\t}\n\tcmd_parse_build_commands(cmds, pi, &pr);\n\tcmd_parse_free_commands(cmds);\n\treturn (&pr);\n\n}\n\nstruct cmd_parse_result *\ncmd_parse_from_string(const char *s, struct cmd_parse_input *pi)\n{\n\tstruct cmd_parse_input\tinput;\n\n\tif (pi == NULL) {\n\t\tmemset(&input, 0, sizeof input);\n\t\tpi = &input;\n\t}\n\n\t/*\n\t * When parsing a string, put commands in one group even if there are\n\t * multiple lines. This means { a \\n b } is identical to \"a ; b\" when\n\t * given as an argument to another command.\n\t */\n\tpi->flags |= CMD_PARSE_ONEGROUP;\n\treturn (cmd_parse_from_buffer(s, strlen(s), pi));\n}\n\nenum cmd_parse_status\ncmd_parse_and_insert(const char *s, struct cmd_parse_input *pi,\n    struct cmdq_item *after, struct cmdq_state *state, char **error)\n{\n\tstruct cmd_parse_result\t*pr;\n\tstruct cmdq_item\t*item;\n\n\tpr = cmd_parse_from_string(s, pi);\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\tif (error != NULL)\n\t\t\t*error = pr->error;\n\t\telse\n\t\t\tfree(pr->error);\n\t\tbreak;\n\tcase CMD_PARSE_SUCCESS:\n\t\titem = cmdq_get_command(pr->cmdlist, state);\n\t\tcmdq_insert_after(after, item);\n\t\tcmd_list_free(pr->cmdlist);\n\t\tbreak;\n\t}\n\treturn (pr->status);\n}\n\nenum cmd_parse_status\ncmd_parse_and_append(const char *s, struct cmd_parse_input *pi,\n    struct client *c, struct cmdq_state *state, char **error)\n{\n\tstruct cmd_parse_result\t*pr;\n\tstruct cmdq_item\t*item;\n\n\tpr = cmd_parse_from_string(s, pi);\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\tif (error != NULL)\n\t\t\t*error = pr->error;\n\t\telse\n\t\t\tfree(pr->error);\n\t\tbreak;\n\tcase CMD_PARSE_SUCCESS:\n\t\titem = cmdq_get_command(pr->cmdlist, state);\n\t\tcmdq_append(c, item);\n\t\tcmd_list_free(pr->cmdlist);\n\t\tbreak;\n\t}\n\treturn (pr->status);\n}\n\nstruct cmd_parse_result *\ncmd_parse_from_buffer(const void *buf, size_t len, struct cmd_parse_input *pi)\n{\n\tstatic struct cmd_parse_result\t pr;\n\tstruct cmd_parse_input\t\t input;\n\tstruct cmd_parse_commands\t*cmds;\n\tchar\t\t\t\t*cause;\n\n\tif (pi == NULL) {\n\t\tmemset(&input, 0, sizeof input);\n\t\tpi = &input;\n\t}\n\tmemset(&pr, 0, sizeof pr);\n\n\tif (len == 0) {\n\t\tpr.status = CMD_PARSE_SUCCESS;\n\t\tpr.cmdlist = cmd_list_new();\n\t\treturn (&pr);\n\t}\n\n\tcmds = cmd_parse_do_buffer(buf, len, pi, &cause);\n\tif (cmds == NULL) {\n\t\tpr.status = CMD_PARSE_ERROR;\n\t\tpr.error = cause;\n\t\treturn (&pr);\n\t}\n\tcmd_parse_build_commands(cmds, pi, &pr);\n\tcmd_parse_free_commands(cmds);\n\treturn (&pr);\n}\n\nstruct cmd_parse_result *\ncmd_parse_from_arguments(struct args_value *values, u_int count,\n    struct cmd_parse_input *pi)\n{\n\tstatic struct cmd_parse_result\t pr;\n\tstruct cmd_parse_input\t\t input;\n\tstruct cmd_parse_commands\t*cmds;\n\tstruct cmd_parse_command\t*cmd;\n\tstruct cmd_parse_argument\t*arg;\n\tu_int\t\t\t\t i;\n\tchar\t\t\t\t*copy;\n\tsize_t\t\t\t\t size;\n\tint\t\t\t\t end;\n\n\t/*\n\t * The commands are already split up into arguments, so just separate\n\t * into a set of commands by ';'.\n\t */\n\n\tif (pi == NULL) {\n\t\tmemset(&input, 0, sizeof input);\n\t\tpi = &input;\n\t}\n\tmemset(&pr, 0, sizeof pr);\n\n\tcmds = cmd_parse_new_commands();\n\n\tcmd = xcalloc(1, sizeof *cmd);\n\tcmd->line = pi->line;\n\tTAILQ_INIT(&cmd->arguments);\n\n\tfor (i = 0; i < count; i++) {\n\t\tend = 0;\n\t\tif (values[i].type == ARGS_STRING) {\n\t\t\tcopy = xstrdup(values[i].string);\n\t\t\tsize = strlen(copy);\n\t\t\tif (size != 0 && copy[size - 1] == ';') {\n\t\t\t\tcopy[--size] = '\\0';\n\t\t\t\tif (size > 0 && copy[size - 1] == '\\\\')\n\t\t\t\t\tcopy[size - 1] = ';';\n\t\t\t\telse\n\t\t\t\t\tend = 1;\n\t\t\t}\n\t\t\tif (!end || size != 0) {\n\t\t\t\targ = xcalloc(1, sizeof *arg);\n\t\t\t\targ->type = CMD_PARSE_STRING;\n\t\t\t\targ->string = copy;\n\t\t\t\tTAILQ_INSERT_TAIL(&cmd->arguments, arg, entry);\n\t\t\t} else\n\t\t\t\tfree(copy);\n\t\t} else if (values[i].type == ARGS_COMMANDS) {\n\t\t\targ = xcalloc(1, sizeof *arg);\n\t\t\targ->type = CMD_PARSE_PARSED_COMMANDS;\n\t\t\targ->cmdlist = values[i].cmdlist;\n\t\t\targ->cmdlist->references++;\n\t\t\tTAILQ_INSERT_TAIL(&cmd->arguments, arg, entry);\n\t\t} else\n\t\t\tfatalx(\"unknown argument type\");\n\t\tif (end) {\n\t\t\tTAILQ_INSERT_TAIL(cmds, cmd, entry);\n\t\t\tcmd = xcalloc(1, sizeof *cmd);\n\t\t\tcmd->line = pi->line;\n\t\t\tTAILQ_INIT(&cmd->arguments);\n\t\t}\n\t}\n\tif (!TAILQ_EMPTY(&cmd->arguments))\n\t\tTAILQ_INSERT_TAIL(cmds, cmd, entry);\n\telse\n\t\tfree(cmd);\n\n\tcmd_parse_build_commands(cmds, pi, &pr);\n\tcmd_parse_free_commands(cmds);\n\treturn (&pr);\n}\n\nstatic int printflike(1, 2)\nyyerror(const char *fmt, ...)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\tstruct cmd_parse_input\t*pi = ps->input;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*error;\n\n\tif (ps->error != NULL)\n\t\treturn (0);\n\n\tva_start(ap, fmt);\n\txvasprintf(&error, fmt, ap);\n\tva_end(ap);\n\n\tps->error = cmd_parse_get_error(pi->file, pi->line, error);\n\tfree(error);\n\treturn (0);\n}\n\nstatic int\nyylex_is_var(char ch, int first)\n{\n\tif (ch == '=')\n\t\treturn (0);\n\tif (first && isdigit((u_char)ch))\n\t\treturn (0);\n\treturn (isalnum((u_char)ch) || ch == '_');\n}\n\nstatic void\nyylex_append(char **buf, size_t *len, const char *add, size_t addlen)\n{\n\tif (addlen > SIZE_MAX - 1 || *len > SIZE_MAX - 1 - addlen)\n\t\tfatalx(\"buffer is too big\");\n\t*buf = xrealloc(*buf, (*len) + 1 + addlen);\n\tmemcpy((*buf) + *len, add, addlen);\n\t(*len) += addlen;\n}\n\nstatic void\nyylex_append1(char **buf, size_t *len, char add)\n{\n\tyylex_append(buf, len, &add, 1);\n}\n\nstatic int\nyylex_getc1(void)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\tint\t\t\t ch;\n\n\tif (ps->f != NULL)\n\t\tch = getc(ps->f);\n\telse {\n\t\tif (ps->off == ps->len)\n\t\t\tch = EOF;\n\t\telse\n\t\t\tch = ps->buf[ps->off++];\n\t}\n\treturn (ch);\n}\n\nstatic void\nyylex_ungetc(int ch)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\n\tif (ps->f != NULL)\n\t\tungetc(ch, ps->f);\n\telse if (ps->off > 0 && ch != EOF)\n\t\tps->off--;\n}\n\nstatic int\nyylex_getc(void)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\tint\t\t\t ch;\n\n\tif (ps->escapes != 0) {\n\t\tps->escapes--;\n\t\treturn ('\\\\');\n\t}\n\tfor (;;) {\n\t\tch = yylex_getc1();\n\t\tif (ch == '\\\\') {\n\t\t\tps->escapes++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\n' && (ps->escapes % 2) == 1) {\n\t\t\tps->input->line++;\n\t\t\tps->escapes--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ps->escapes != 0) {\n\t\t\tyylex_ungetc(ch);\n\t\t\tps->escapes--;\n\t\t\treturn ('\\\\');\n\t\t}\n\t\treturn (ch);\n\t}\n}\n\nstatic char *\nyylex_get_word(int ch)\n{\n\tchar\t*buf;\n\tsize_t\t len;\n\n\tlen = 0;\n\tbuf = xmalloc(1);\n\n\tdo\n\t\tyylex_append1(&buf, &len, ch);\n\twhile ((ch = yylex_getc()) != EOF && strchr(\" \\t\\n\", ch) == NULL);\n\tyylex_ungetc(ch);\n\n\tbuf[len] = '\\0';\n\tlog_debug(\"%s: %s\", __func__, buf);\n\treturn (buf);\n}\n\nstatic int\nyylex(void)\n{\n\tstruct cmd_parse_state\t*ps = &parse_state;\n\tchar\t\t\t*token, *cp;\n\tint\t\t\t ch, next, condition;\n\n\tif (ps->eol)\n\t\tps->input->line++;\n\tps->eol = 0;\n\n\tcondition = ps->condition;\n\tps->condition = 0;\n\n\tfor (;;) {\n\t\tch = yylex_getc();\n\n\t\tif (ch == EOF) {\n\t\t\t/*\n\t\t\t * Ensure every file or string is terminated by a\n\t\t\t * newline. This keeps the parser simpler and avoids\n\t\t\t * having to add a newline to each string.\n\t\t\t */\n\t\t\tif (ps->eof)\n\t\t\t\tbreak;\n\t\t\tps->eof = 1;\n\t\t\treturn ('\\n');\n\t\t}\n\n\t\tif (ch == ' ' || ch == '\\t') {\n\t\t\t/*\n\t\t\t * Ignore whitespace.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ch == '\\r') {\n\t\t\t/*\n\t\t\t * Treat \\r\\n as \\n.\n\t\t\t */\n\t\t\tch = yylex_getc();\n\t\t\tif (ch != '\\n') {\n\t\t\t\tyylex_ungetc(ch);\n\t\t\t\tch = '\\r';\n\t\t\t}\n\t\t}\n\t\tif (ch == '\\n') {\n\t\t\t/*\n\t\t\t * End of line. Update the line number.\n\t\t\t */\n\t\t\tps->eol = 1;\n\t\t\treturn ('\\n');\n\t\t}\n\n\t\tif (ch == ';' || ch == '{' || ch == '}') {\n\t\t\t/*\n\t\t\t * A semicolon or { or } is itself.\n\t\t\t */\n\t\t\treturn (ch);\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\t/*\n\t\t\t * #{ after a condition opens a format; anything else\n\t\t\t * is a comment, ignore up to the end of the line.\n\t\t\t */\n\t\t\tnext = yylex_getc();\n\t\t\tif (condition && next == '{') {\n\t\t\t\tyylval.token = yylex_format();\n\t\t\t\tif (yylval.token == NULL)\n\t\t\t\t\treturn (ERROR);\n\t\t\t\treturn (FORMAT);\n\t\t\t}\n\t\t\twhile (next != '\\n' && next != EOF)\n\t\t\t\tnext = yylex_getc();\n\t\t\tif (next == '\\n') {\n\t\t\t\tps->input->line++;\n\t\t\t\treturn ('\\n');\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ch == '%') {\n\t\t\t/*\n\t\t\t * % is a condition unless it is all % or all numbers,\n\t\t\t * then it is a token.\n\t\t\t */\n\t\t\tyylval.token = yylex_get_word('%');\n\t\t\tfor (cp = yylval.token; *cp != '\\0'; cp++) {\n\t\t\t\tif (*cp != '%' && !isdigit((u_char)*cp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn (TOKEN);\n\t\t\tps->condition = 1;\n\t\t\tif (strcmp(yylval.token, \"%hidden\") == 0) {\n\t\t\t\tfree(yylval.token);\n\t\t\t\treturn (HIDDEN);\n\t\t\t}\n\t\t\tif (strcmp(yylval.token, \"%if\") == 0) {\n\t\t\t\tfree(yylval.token);\n\t\t\t\treturn (IF);\n\t\t\t}\n\t\t\tif (strcmp(yylval.token, \"%else\") == 0) {\n\t\t\t\tfree(yylval.token);\n\t\t\t\treturn (ELSE);\n\t\t\t}\n\t\t\tif (strcmp(yylval.token, \"%elif\") == 0) {\n\t\t\t\tfree(yylval.token);\n\t\t\t\treturn (ELIF);\n\t\t\t}\n\t\t\tif (strcmp(yylval.token, \"%endif\") == 0) {\n\t\t\t\tfree(yylval.token);\n\t\t\t\treturn (ENDIF);\n\t\t\t}\n\t\t\tfree(yylval.token);\n\t\t\treturn (ERROR);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise this is a token.\n\t\t */\n\t\ttoken = yylex_token(ch);\n\t\tif (token == NULL)\n\t\t\treturn (ERROR);\n\t\tyylval.token = token;\n\n\t\tif (strchr(token, '=') != NULL && yylex_is_var(*token, 1)) {\n\t\t\tfor (cp = token + 1; *cp != '='; cp++) {\n\t\t\t\tif (!yylex_is_var(*cp, 0))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*cp == '=')\n\t\t\t\treturn (EQUALS);\n\t\t}\n\t\treturn (TOKEN);\n\t}\n\treturn (0);\n}\n\nstatic char *\nyylex_format(void)\n{\n\tchar\t*buf;\n\tsize_t\t len;\n\tint\t ch, brackets = 1;\n\n\tlen = 0;\n\tbuf = xmalloc(1);\n\n\tyylex_append(&buf, &len, \"#{\", 2);\n\tfor (;;) {\n\t\tif ((ch = yylex_getc()) == EOF || ch == '\\n')\n\t\t\tgoto error;\n\t\tif (ch == '#') {\n\t\t\tif ((ch = yylex_getc()) == EOF || ch == '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (ch == '{')\n\t\t\t\tbrackets++;\n\t\t\tyylex_append1(&buf, &len, '#');\n\t\t} else if (ch == '}') {\n\t\t\tif (brackets != 0 && --brackets == 0) {\n\t\t\t\tyylex_append1(&buf, &len, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tyylex_append1(&buf, &len, ch);\n\t}\n\tif (brackets != 0)\n\t\tgoto error;\n\n\tbuf[len] = '\\0';\n\tlog_debug(\"%s: %s\", __func__, buf);\n\treturn (buf);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nstatic int\nyylex_token_escape(char **buf, size_t *len)\n{\n\tint\t ch, type, o2, o3, mlen;\n\tu_int\t size, i, tmp;\n\tchar\t s[9], m[MB_LEN_MAX];\n\n\tch = yylex_getc();\n\n\tif (ch >= '4' && ch <= '7') {\n\t\tyyerror(\"invalid octal escape\");\n\t\treturn (0);\n\t}\n\tif (ch >= '0' && ch <= '3') {\n\t\to2 = yylex_getc();\n\t\tif (o2 >= '0' && o2 <= '7') {\n\t\t\to3 = yylex_getc();\n\t\t\tif (o3 >= '0' && o3 <= '7') {\n\t\t\t\tch = 64 * (ch - '0') +\n\t\t\t\t      8 * (o2 - '0') +\n\t\t\t\t\t  (o3 - '0');\n\t\t\t\tyylex_append1(buf, len, ch);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t}\n\t\tyyerror(\"invalid octal escape\");\n\t\treturn (0);\n\t}\n\n\tswitch (ch) {\n\tcase EOF:\n\t\treturn (0);\n\tcase 'a':\n\t\tch = '\\a';\n\t\tbreak;\n\tcase 'b':\n\t\tch = '\\b';\n\t\tbreak;\n\tcase 'e':\n\t\tch = '\\033';\n\t\tbreak;\n\tcase 'f':\n\t\tch = '\\f';\n\t\tbreak;\n\tcase 's':\n\t\tch = ' ';\n\t\tbreak;\n\tcase 'v':\n\t\tch = '\\v';\n\t\tbreak;\n\tcase 'r':\n\t\tch = '\\r';\n\t\tbreak;\n\tcase 'n':\n\t\tch = '\\n';\n\t\tbreak;\n\tcase 't':\n\t\tch = '\\t';\n\t\tbreak;\n\tcase 'u':\n\t\ttype = 'u';\n\t\tsize = 4;\n\t\tgoto unicode;\n\tcase 'U':\n\t\ttype = 'U';\n\t\tsize = 8;\n\t\tgoto unicode;\n\t}\n\n\tyylex_append1(buf, len, ch);\n\treturn (1);\n\nunicode:\n\tfor (i = 0; i < size; i++) {\n\t\tch = yylex_getc();\n\t\tif (ch == EOF || ch == '\\n')\n\t\t\treturn (0);\n\t\tif (!isxdigit((u_char)ch)) {\n\t\t\tyyerror(\"invalid \\\\%c argument\", type);\n\t\t\treturn (0);\n\t\t}\n\t\ts[i] = ch;\n\t}\n\ts[i] = '\\0';\n\n\tif ((size == 4 && sscanf(s, \"%4x\", &tmp) != 1) ||\n\t    (size == 8 && sscanf(s, \"%8x\", &tmp) != 1)) {\n\t\tyyerror(\"invalid \\\\%c argument\", type);\n\t\treturn (0);\n\t}\n\tmlen = wctomb(m, tmp);\n\tif (mlen <= 0 || mlen > (int)sizeof m) {\n\t\tyyerror(\"invalid \\\\%c argument\", type);\n\t\treturn (0);\n\t}\n\tyylex_append(buf, len, m, mlen);\n\treturn (1);\n}\n\nstatic int\nyylex_token_variable(char **buf, size_t *len)\n{\n\tstruct environ_entry\t*envent;\n\tint\t\t\t ch, brackets = 0;\n\tchar\t\t\t name[1024];\n\tsize_t\t\t\t namelen = 0;\n\tconst char\t\t*value;\n\n\tch = yylex_getc();\n\tif (ch == EOF)\n\t\treturn (0);\n\tif (ch == '{')\n\t\tbrackets = 1;\n\telse {\n\t\tif (!yylex_is_var(ch, 1)) {\n\t\t\tyylex_append1(buf, len, '$');\n\t\t\tyylex_ungetc(ch);\n\t\t\treturn (1);\n\t\t}\n\t\tname[namelen++] = ch;\n\t}\n\n\tfor (;;) {\n\t\tch = yylex_getc();\n\t\tif (brackets && ch == '}')\n\t\t\tbreak;\n\t\tif (ch == EOF || !yylex_is_var(ch, 0)) {\n\t\t\tif (!brackets) {\n\t\t\t\tyylex_ungetc(ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tyyerror(\"invalid environment variable\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (namelen == (sizeof name) - 2) {\n\t\t\tyyerror(\"environment variable is too long\");\n\t\t\treturn (0);\n\t\t}\n\t\tname[namelen++] = ch;\n\t}\n\tname[namelen] = '\\0';\n\n\tenvent = environ_find(global_environ, name);\n\tif (envent != NULL && envent->value != NULL) {\n\t\tvalue = envent->value;\n\t\tlog_debug(\"%s: %s -> %s\", __func__, name, value);\n\t\tyylex_append(buf, len, value, strlen(value));\n\t}\n\treturn (1);\n}\n\nstatic int\nyylex_token_tilde(char **buf, size_t *len)\n{\n\tstruct environ_entry\t*envent;\n\tint\t\t\t ch;\n\tchar\t\t\t name[1024];\n\tsize_t\t\t\t namelen = 0;\n\tstruct passwd\t\t*pw;\n\tconst char\t\t*home = NULL;\n\n\tfor (;;) {\n\t\tch = yylex_getc();\n\t\tif (ch == EOF || strchr(\"/ \\t\\n\\\"'\", ch) != NULL) {\n\t\t\tyylex_ungetc(ch);\n\t\t\tbreak;\n\t\t}\n\t\tif (namelen == (sizeof name) - 2) {\n\t\t\tyyerror(\"user name is too long\");\n\t\t\treturn (0);\n\t\t}\n\t\tname[namelen++] = ch;\n\t}\n\tname[namelen] = '\\0';\n\n\tif (*name == '\\0') {\n\t\tenvent = environ_find(global_environ, \"HOME\");\n\t\tif (envent != NULL && *envent->value != '\\0')\n\t\t\thome = envent->value;\n\t\telse if ((pw = getpwuid(getuid())) != NULL)\n\t\t\thome = pw->pw_dir;\n\t} else {\n\t\tif ((pw = getpwnam(name)) != NULL)\n\t\t\thome = pw->pw_dir;\n\t}\n\tif (home == NULL)\n\t\treturn (0);\n\n\tlog_debug(\"%s: ~%s -> %s\", __func__, name, home);\n\tyylex_append(buf, len, home, strlen(home));\n\treturn (1);\n}\n\nstatic char *\nyylex_token(int ch)\n{\n\tchar\t\t\t*buf;\n\tsize_t\t\t\t len;\n\tenum { START,\n\t       NONE,\n\t       DOUBLE_QUOTES,\n\t       SINGLE_QUOTES }\t state = NONE, last = START;\n\n\tlen = 0;\n\tbuf = xmalloc(1);\n\n\tfor (;;) {\n\t\t/* EOF or \\n are always the end of the token. */\n\t\tif (ch == EOF) {\n\t\t\tlog_debug(\"%s: end at EOF\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (state == NONE && ch == '\\r') {\n\t\t\tch = yylex_getc();\n\t\t\tif (ch != '\\n') {\n\t\t\t\tyylex_ungetc(ch);\n\t\t\t\tch = '\\r';\n\t\t\t}\n\t\t}\n\t\tif (state == NONE && ch == '\\n') {\n\t\t\tlog_debug(\"%s: end at EOL\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Whitespace or ; or } ends a token unless inside quotes. */\n\t\tif (state == NONE && (ch == ' ' || ch == '\\t')) {\n\t\t\tlog_debug(\"%s: end at WS\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (state == NONE && (ch == ';' || ch == '}')) {\n\t\t\tlog_debug(\"%s: end at %c\", __func__, ch);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Spaces and comments inside quotes after \\n are removed but\n\t\t * the \\n is left.\n\t\t */\n\t\tif (ch == '\\n' && state != NONE) {\n\t\t\tyylex_append1(&buf, &len, '\\n');\n\t\t\twhile ((ch = yylex_getc()) == ' ' || ch == '\\t')\n\t\t\t\t/* nothing */;\n\t\t\tif (ch != '#')\n\t\t\t\tcontinue;\n\t\t\tch = yylex_getc();\n\t\t\tif (strchr(\",#{}:\", ch) != NULL) {\n\t\t\t\tyylex_ungetc(ch);\n\t\t\t\tch = '#';\n\t\t\t} else {\n\t\t\t\twhile ((ch = yylex_getc()) != '\\n' && ch != EOF)\n\t\t\t\t\t/* nothing */;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* \\ ~ and $ are expanded except in single quotes. */\n\t\tif (ch == '\\\\' && state != SINGLE_QUOTES) {\n\t\t\tif (!yylex_token_escape(&buf, &len))\n\t\t\t\tgoto error;\n\t\t\tgoto skip;\n\t\t}\n\t\tif (ch == '~' && last != state && state != SINGLE_QUOTES) {\n\t\t\tif (!yylex_token_tilde(&buf, &len))\n\t\t\t\tgoto error;\n\t\t\tgoto skip;\n\t\t}\n\t\tif (ch == '$' && state != SINGLE_QUOTES) {\n\t\t\tif (!yylex_token_variable(&buf, &len))\n\t\t\t\tgoto error;\n\t\t\tgoto skip;\n\t\t}\n\t\tif (ch == '}' && state == NONE)\n\t\t\tgoto error;  /* unmatched (matched ones were handled) */\n\n\t\t/* ' and \" starts or end quotes (and is consumed). */\n\t\tif (ch == '\\'') {\n\t\t\tif (state == NONE) {\n\t\t\t\tstate = SINGLE_QUOTES;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (state == SINGLE_QUOTES) {\n\t\t\t\tstate = NONE;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tif (state == NONE) {\n\t\t\t\tstate = DOUBLE_QUOTES;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (state == DOUBLE_QUOTES) {\n\t\t\t\tstate = NONE;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\t/* Otherwise add the character to the buffer. */\n\t\tyylex_append1(&buf, &len, ch);\n\n\tskip:\n\t\tlast = state;\n\n\tnext:\n\t\tch = yylex_getc();\n\t}\n\tyylex_ungetc(ch);\n\n\tbuf[len] = '\\0';\n\tlog_debug(\"%s: %s\", __func__, buf);\n\treturn (buf);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n"
        },
        {
          "name": "cmd-paste-buffer.c",
          "type": "blob",
          "size": 2.9521484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Paste paste buffer if present.\n */\n\nstatic enum cmd_retval\tcmd_paste_buffer_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_paste_buffer_entry = {\n\t.name = \"paste-buffer\",\n\t.alias = \"pasteb\",\n\n\t.args = { \"db:prs:t:\", 0, 0, NULL },\n\t.usage = \"[-dpr] [-s separator] \" CMD_BUFFER_USAGE \" \"\n\t\t CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_paste_buffer_exec\n};\n\nstatic enum cmd_retval\ncmd_paste_buffer_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct window_pane\t*wp = target->wp;\n\tstruct paste_buffer\t*pb;\n\tconst char\t\t*sepstr, *bufname, *bufdata, *bufend, *line;\n\tsize_t\t\t\t seplen, bufsize;\n\tint\t\t\t bracket = args_has(args, 'p');\n\n\tif (window_pane_exited(wp)) {\n\t\tcmdq_error(item, \"target pane has exited\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tbufname = NULL;\n\tif (args_has(args, 'b'))\n\t\tbufname = args_get(args, 'b');\n\n\tif (bufname == NULL)\n\t\tpb = paste_get_top(NULL);\n\telse {\n\t\tpb = paste_get_name(bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(item, \"no buffer %s\", bufname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (pb != NULL && ~wp->flags & PANE_INPUTOFF) {\n\t\tsepstr = args_get(args, 's');\n\t\tif (sepstr == NULL) {\n\t\t\tif (args_has(args, 'r'))\n\t\t\t\tsepstr = \"\\n\";\n\t\t\telse\n\t\t\t\tsepstr = \"\\r\";\n\t\t}\n\t\tseplen = strlen(sepstr);\n\n\t\tif (bracket && (wp->screen->mode & MODE_BRACKETPASTE))\n\t\t\tbufferevent_write(wp->event, \"\\033[200~\", 6);\n\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tbufend = bufdata + bufsize;\n\n\t\tfor (;;) {\n\t\t\tline = memchr(bufdata, '\\n', bufend - bufdata);\n\t\t\tif (line == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbufferevent_write(wp->event, bufdata, line - bufdata);\n\t\t\tbufferevent_write(wp->event, sepstr, seplen);\n\n\t\t\tbufdata = line + 1;\n\t\t}\n\t\tif (bufdata != bufend)\n\t\t\tbufferevent_write(wp->event, bufdata, bufend - bufdata);\n\n\t\tif (bracket && (wp->screen->mode & MODE_BRACKETPASTE))\n\t\t\tbufferevent_write(wp->event, \"\\033[201~\", 6);\n\t}\n\n\tif (pb != NULL && args_has(args, 'd'))\n\t\tpaste_free(pb);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-pipe-pane.c",
          "type": "blob",
          "size": 5.9501953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Open pipe to redirect pane output. If already open, close first.\n */\n\nstatic enum cmd_retval\tcmd_pipe_pane_exec(struct cmd *, struct cmdq_item *);\n\nstatic void cmd_pipe_pane_read_callback(struct bufferevent *, void *);\nstatic void cmd_pipe_pane_write_callback(struct bufferevent *, void *);\nstatic void cmd_pipe_pane_error_callback(struct bufferevent *, short, void *);\n\nconst struct cmd_entry cmd_pipe_pane_entry = {\n\t.name = \"pipe-pane\",\n\t.alias = \"pipep\",\n\n\t.args = { \"IOot:\", 0, 1, NULL },\n\t.usage = \"[-IOo] \" CMD_TARGET_PANE_USAGE \" [shell-command]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_pipe_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_pipe_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct window_pane\t\t*wp = target->wp;\n\tstruct session\t\t\t*s = target->s;\n\tstruct winlink\t\t\t*wl = target->wl;\n\tstruct window_pane_offset\t*wpo = &wp->pipe_offset;\n\tchar\t\t\t\t*cmd;\n\tint\t\t\t\t old_fd, pipe_fd[2], null_fd, in, out;\n\tstruct format_tree\t\t*ft;\n\tsigset_t\t\t\t set, oldset;\n\n\t/* Do nothing if pane is dead. */\n\tif (window_pane_exited(wp)) {\n\t\tcmdq_error(item, \"target pane has exited\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\t/* Destroy the old pipe. */\n\told_fd = wp->pipe_fd;\n\tif (wp->pipe_fd != -1) {\n\t\tbufferevent_free(wp->pipe_event);\n\t\tclose(wp->pipe_fd);\n\t\twp->pipe_fd = -1;\n\n\t\tif (window_pane_destroy_ready(wp)) {\n\t\t\tserver_destroy_pane(wp, 1);\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t}\n\n\t/* If no pipe command, that is enough. */\n\tif (args_count(args) == 0 || *args_string(args, 0) == '\\0')\n\t\treturn (CMD_RETURN_NORMAL);\n\n\t/*\n\t * With -o, only open the new pipe if there was no previous one. This\n\t * allows a pipe to be toggled with a single key, for example:\n\t *\n\t *\tbind ^p pipep -o 'cat >>~/output'\n\t */\n\tif (args_has(args, 'o') && old_fd != -1)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\t/* What do we want to do? Neither -I or -O is -O. */\n\tif (args_has(args, 'I')) {\n\t\tin = 1;\n\t\tout = args_has(args, 'O');\n\t} else {\n\t\tin = 0;\n\t\tout = 1;\n\t}\n\n\t/* Open the new pipe. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_fd) != 0) {\n\t\tcmdq_error(item, \"socketpair error: %s\", strerror(errno));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\t/* Expand the command. */\n\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\tformat_defaults(ft, tc, s, wl, wp);\n\tcmd = format_expand_time(ft, args_string(args, 0));\n\tformat_free(ft);\n\n\t/* Fork the child. */\n\tsigfillset(&set);\n\tsigprocmask(SIG_BLOCK, &set, &oldset);\n\tswitch (fork()) {\n\tcase -1:\n\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\t\tcmdq_error(item, \"fork error: %s\", strerror(errno));\n\n\t\tfree(cmd);\n\t\treturn (CMD_RETURN_ERROR);\n\tcase 0:\n\t\t/* Child process. */\n\t\tproc_clear_signals(server_proc, 1);\n\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\t\tclose(pipe_fd[0]);\n\n\t\tnull_fd = open(_PATH_DEVNULL, O_WRONLY);\n\t\tif (out) {\n\t\t\tif (dup2(pipe_fd[1], STDIN_FILENO) == -1)\n\t\t\t\t_exit(1);\n\t\t} else {\n\t\t\tif (dup2(null_fd, STDIN_FILENO) == -1)\n\t\t\t\t_exit(1);\n\t\t}\n\t\tif (in) {\n\t\t\tif (dup2(pipe_fd[1], STDOUT_FILENO) == -1)\n\t\t\t\t_exit(1);\n\t\t\tif (pipe_fd[1] != STDOUT_FILENO)\n\t\t\t\tclose(pipe_fd[1]);\n\t\t} else {\n\t\t\tif (dup2(null_fd, STDOUT_FILENO) == -1)\n\t\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(null_fd, STDERR_FILENO) == -1)\n\t\t\t_exit(1);\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\texecl(_PATH_BSHELL, \"sh\", \"-c\", cmd, (char *) NULL);\n\t\t_exit(1);\n\tdefault:\n\t\t/* Parent process. */\n\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\t\tclose(pipe_fd[1]);\n\n\t\twp->pipe_fd = pipe_fd[0];\n\t\tmemcpy(wpo, &wp->offset, sizeof *wpo);\n\n\t\tsetblocking(wp->pipe_fd, 0);\n\t\twp->pipe_event = bufferevent_new(wp->pipe_fd,\n\t\t    cmd_pipe_pane_read_callback,\n\t\t    cmd_pipe_pane_write_callback,\n\t\t    cmd_pipe_pane_error_callback,\n\t\t    wp);\n\t\tif (wp->pipe_event == NULL)\n\t\t\tfatalx(\"out of memory\");\n\t\tif (out)\n\t\t\tbufferevent_enable(wp->pipe_event, EV_WRITE);\n\t\tif (in)\n\t\t\tbufferevent_enable(wp->pipe_event, EV_READ);\n\n\t\tfree(cmd);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n}\n\nstatic void\ncmd_pipe_pane_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\tstruct evbuffer\t\t*evb = wp->pipe_event->input;\n\tsize_t\t\t\t available;\n\n\tavailable = EVBUFFER_LENGTH(evb);\n\tlog_debug(\"%%%u pipe read %zu\", wp->id, available);\n\n\tbufferevent_write(wp->event, EVBUFFER_DATA(evb), available);\n\tevbuffer_drain(evb, available);\n\n\tif (window_pane_destroy_ready(wp))\n\t\tserver_destroy_pane(wp, 1);\n}\n\nstatic void\ncmd_pipe_pane_write_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\n\tlog_debug(\"%%%u pipe empty\", wp->id);\n\n\tif (window_pane_destroy_ready(wp))\n\t\tserver_destroy_pane(wp, 1);\n}\n\nstatic void\ncmd_pipe_pane_error_callback(__unused struct bufferevent *bufev,\n    __unused short what, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\n\tlog_debug(\"%%%u pipe error\", wp->id);\n\n\tbufferevent_free(wp->pipe_event);\n\tclose(wp->pipe_fd);\n\twp->pipe_fd = -1;\n\n\tif (window_pane_destroy_ready(wp))\n\t\tserver_destroy_pane(wp, 1);\n}\n"
        },
        {
          "name": "cmd-queue.c",
          "type": "blob",
          "size": 19.71875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2013 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/* Command queue flags. */\n#define CMDQ_FIRED 0x1\n#define CMDQ_WAITING 0x2\n\n/* Command queue item type. */\nenum cmdq_type {\n\tCMDQ_COMMAND,\n\tCMDQ_CALLBACK,\n};\n\n/* Command queue item. */\nstruct cmdq_item {\n\tchar\t\t\t*name;\n\tstruct cmdq_list\t*queue;\n\tstruct cmdq_item\t*next;\n\n\tstruct client\t\t*client;\n\tstruct client\t\t*target_client;\n\n\tenum cmdq_type\t\t type;\n\tu_int\t\t\t group;\n\n\tu_int\t\t\t number;\n\ttime_t\t\t\t time;\n\n\tint\t\t\t flags;\n\n\tstruct cmdq_state\t*state;\n\tstruct cmd_find_state\t source;\n\tstruct cmd_find_state\t target;\n\n\tstruct cmd_list\t\t*cmdlist;\n\tstruct cmd\t\t*cmd;\n\n\tcmdq_cb\t\t\t cb;\n\tvoid\t\t\t*data;\n\n\tTAILQ_ENTRY(cmdq_item)\t entry;\n};\nTAILQ_HEAD(cmdq_item_list, cmdq_item);\n\n/*\n * Command queue state. This is the context for commands on the command queue.\n * It holds information about how the commands were fired (the key and flags),\n * any additional formats for the commands, and the current default target.\n * Multiple commands can share the same state and a command may update the\n * default target.\n */\nstruct cmdq_state {\n\tint\t\t\t references;\n\tint\t\t\t flags;\n\n\tstruct format_tree\t*formats;\n\n\tstruct key_event\t event;\n\tstruct cmd_find_state\t current;\n};\n\n/* Command queue. */\nstruct cmdq_list {\n\tstruct cmdq_item\t*item;\n\tstruct cmdq_item_list\t list;\n};\n\n/* Get command queue name. */\nstatic const char *\ncmdq_name(struct client *c)\n{\n\tstatic char\ts[256];\n\n\tif (c == NULL)\n\t\treturn (\"<global>\");\n\tif (c->name != NULL)\n\t\txsnprintf(s, sizeof s, \"<%s>\", c->name);\n\telse\n\t\txsnprintf(s, sizeof s, \"<%p>\", c);\n\treturn (s);\n}\n\n/* Get command queue from client. */\nstatic struct cmdq_list *\ncmdq_get(struct client *c)\n{\n\tstatic struct cmdq_list *global_queue;\n\n\tif (c == NULL) {\n\t\tif (global_queue == NULL)\n\t\t\tglobal_queue = cmdq_new();\n\t\treturn (global_queue);\n\t}\n\treturn (c->queue);\n}\n\n/* Create a queue. */\nstruct cmdq_list *\ncmdq_new(void)\n{\n\tstruct cmdq_list\t*queue;\n\n\tqueue = xcalloc(1, sizeof *queue);\n\tTAILQ_INIT (&queue->list);\n\treturn (queue);\n}\n\n/* Free a queue. */\nvoid\ncmdq_free(struct cmdq_list *queue)\n{\n\tif (!TAILQ_EMPTY(&queue->list))\n\t\tfatalx(\"queue not empty\");\n\tfree(queue);\n}\n\n/* Get item name. */\nconst char *\ncmdq_get_name(struct cmdq_item *item)\n{\n\treturn (item->name);\n}\n\n/* Get item client. */\nstruct client *\ncmdq_get_client(struct cmdq_item *item)\n{\n\treturn (item->client);\n}\n\n/* Get item target client. */\nstruct client *\ncmdq_get_target_client(struct cmdq_item *item)\n{\n\treturn (item->target_client);\n}\n\n/* Get item state. */\nstruct cmdq_state *\ncmdq_get_state(struct cmdq_item *item)\n{\n\treturn (item->state);\n}\n\n/* Get item target. */\nstruct cmd_find_state *\ncmdq_get_target(struct cmdq_item *item)\n{\n\treturn (&item->target);\n}\n\n/* Get item source. */\nstruct cmd_find_state *\ncmdq_get_source(struct cmdq_item *item)\n{\n\treturn (&item->source);\n}\n\n/* Get state event. */\nstruct key_event *\ncmdq_get_event(struct cmdq_item *item)\n{\n\treturn (&item->state->event);\n}\n\n/* Get state current target. */\nstruct cmd_find_state *\ncmdq_get_current(struct cmdq_item *item)\n{\n\treturn (&item->state->current);\n}\n\n/* Get state flags. */\nint\ncmdq_get_flags(struct cmdq_item *item)\n{\n\treturn (item->state->flags);\n}\n\n/* Create a new state. */\nstruct cmdq_state *\ncmdq_new_state(struct cmd_find_state *current, struct key_event *event,\n    int flags)\n{\n\tstruct cmdq_state\t*state;\n\n\tstate = xcalloc(1, sizeof *state);\n\tstate->references = 1;\n\tstate->flags = flags;\n\n\tif (event != NULL)\n\t\tmemcpy(&state->event, event, sizeof state->event);\n\telse\n\t\tstate->event.key = KEYC_NONE;\n\tif (current != NULL && cmd_find_valid_state(current))\n\t\tcmd_find_copy_state(&state->current, current);\n\telse\n\t\tcmd_find_clear_state(&state->current, 0);\n\n\treturn (state);\n}\n\n/* Add a reference to a state. */\nstruct cmdq_state *\ncmdq_link_state(struct cmdq_state *state)\n{\n\tstate->references++;\n\treturn (state);\n}\n\n/* Make a copy of a state. */\nstruct cmdq_state *\ncmdq_copy_state(struct cmdq_state *state, struct cmd_find_state *current)\n{\n\tif (current != NULL)\n\t\treturn (cmdq_new_state(current, &state->event, state->flags));\n\treturn (cmdq_new_state(&state->current, &state->event, state->flags));\n}\n\n/* Free a state. */\nvoid\ncmdq_free_state(struct cmdq_state *state)\n{\n\tif (--state->references != 0)\n\t\treturn;\n\n\tif (state->formats != NULL)\n\t\tformat_free(state->formats);\n\tfree(state);\n}\n\n/* Add a format to command queue. */\nvoid\ncmdq_add_format(struct cmdq_state *state, const char *key, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*value;\n\n\tva_start(ap, fmt);\n\txvasprintf(&value, fmt, ap);\n\tva_end(ap);\n\n\tif (state->formats == NULL)\n\t\tstate->formats = format_create(NULL, NULL, FORMAT_NONE, 0);\n\tformat_add(state->formats, key, \"%s\", value);\n\n\tfree(value);\n}\n\n/* Add formats to command queue. */\nvoid\ncmdq_add_formats(struct cmdq_state *state, struct format_tree *ft)\n{\n\tif (state->formats == NULL)\n\t\tstate->formats = format_create(NULL, NULL, FORMAT_NONE, 0);\n\tformat_merge(state->formats, ft);\n}\n\n/* Merge formats from item. */\nvoid\ncmdq_merge_formats(struct cmdq_item *item, struct format_tree *ft)\n{\n\tconst struct cmd_entry\t*entry;\n\n\tif (item->cmd != NULL) {\n\t\tentry = cmd_get_entry(item->cmd);\n\t\tformat_add(ft, \"command\", \"%s\", entry->name);\n\t}\n\tif (item->state->formats != NULL)\n\t\tformat_merge(ft, item->state->formats);\n}\n\n/* Append an item. */\nstruct cmdq_item *\ncmdq_append(struct client *c, struct cmdq_item *item)\n{\n\tstruct cmdq_list\t*queue = cmdq_get(c);\n\tstruct cmdq_item\t*next;\n\n\tdo {\n\t\tnext = item->next;\n\t\titem->next = NULL;\n\n\t\tif (c != NULL)\n\t\t\tc->references++;\n\t\titem->client = c;\n\n\t\titem->queue = queue;\n\t\tTAILQ_INSERT_TAIL(&queue->list, item, entry);\n\t\tlog_debug(\"%s %s: %s\", __func__, cmdq_name(c), item->name);\n\n\t\titem = next;\n\t} while (item != NULL);\n\treturn (TAILQ_LAST(&queue->list, cmdq_item_list));\n}\n\n/* Insert an item. */\nstruct cmdq_item *\ncmdq_insert_after(struct cmdq_item *after, struct cmdq_item *item)\n{\n\tstruct client\t\t*c = after->client;\n\tstruct cmdq_list\t*queue = after->queue;\n\tstruct cmdq_item\t*next;\n\n\tdo {\n\t\tnext = item->next;\n\t\titem->next = after->next;\n\t\tafter->next = item;\n\n\t\tif (c != NULL)\n\t\t\tc->references++;\n\t\titem->client = c;\n\n\t\titem->queue = queue;\n\t\tTAILQ_INSERT_AFTER(&queue->list, after, item, entry);\n\t\tlog_debug(\"%s %s: %s after %s\", __func__, cmdq_name(c),\n\t\t    item->name, after->name);\n\n\t\tafter = item;\n\t\titem = next;\n\t} while (item != NULL);\n\treturn (after);\n}\n\n/* Insert a hook. */\nvoid\ncmdq_insert_hook(struct session *s, struct cmdq_item *item,\n    struct cmd_find_state *current, const char *fmt, ...)\n{\n\tstruct cmdq_state\t\t*state = item->state;\n\tstruct cmd\t\t\t*cmd = item->cmd;\n\tstruct args\t\t\t*args = cmd_get_args(cmd);\n\tstruct args_entry\t\t*ae;\n\tstruct args_value\t\t*av;\n\tstruct options\t\t\t*oo;\n\tva_list\t\t\t\t ap;\n\tchar\t\t\t\t*name, tmp[32], flag, *arguments;\n\tu_int\t\t\t\t i;\n\tconst char\t\t\t*value;\n\tstruct cmdq_item\t\t*new_item;\n\tstruct cmdq_state\t\t*new_state;\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tstruct cmd_list\t\t\t*cmdlist;\n\n\tif (item->state->flags & CMDQ_STATE_NOHOOKS)\n\t\treturn;\n\tif (s == NULL)\n\t\too = global_s_options;\n\telse\n\t\too = s->options;\n\n\tva_start(ap, fmt);\n\txvasprintf(&name, fmt, ap);\n\tva_end(ap);\n\n\to = options_get(oo, name);\n\tif (o == NULL) {\n\t\tfree(name);\n\t\treturn;\n\t}\n\tlog_debug(\"running hook %s (parent %p)\", name, item);\n\n\t/*\n\t * The hooks get a new state because they should not update the current\n\t * target or formats for any subsequent commands.\n\t */\n\tnew_state = cmdq_new_state(current, &state->event, CMDQ_STATE_NOHOOKS);\n\tcmdq_add_format(new_state, \"hook\", \"%s\", name);\n\n\targuments = args_print(args);\n\tcmdq_add_format(new_state, \"hook_arguments\", \"%s\", arguments);\n\tfree(arguments);\n\n\tfor (i = 0; i < args_count(args); i++) {\n\t\txsnprintf(tmp, sizeof tmp, \"hook_argument_%d\", i);\n\t\tcmdq_add_format(new_state, tmp, \"%s\", args_string(args, i));\n\t}\n\tflag = args_first(args, &ae);\n\twhile (flag != 0) {\n\t\tvalue = args_get(args, flag);\n\t\tif (value == NULL) {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c\", flag);\n\t\t\tcmdq_add_format(new_state, tmp, \"1\");\n\t\t} else {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c\", flag);\n\t\t\tcmdq_add_format(new_state, tmp, \"%s\", value);\n\t\t}\n\n\t\ti = 0;\n\t\tav = args_first_value(args, flag);\n\t\twhile (av != NULL) {\n\t\t\txsnprintf(tmp, sizeof tmp, \"hook_flag_%c_%d\", flag, i);\n\t\t\tcmdq_add_format(new_state, tmp, \"%s\", av->string);\n\t\t\ti++;\n\t\t\tav = args_next_value(av);\n\t\t}\n\n\t\tflag = args_next(&ae);\n\t}\n\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tcmdlist = options_array_item_value(a)->cmdlist;\n\t\tif (cmdlist != NULL) {\n\t\t\tnew_item = cmdq_get_command(cmdlist, new_state);\n\t\t\tif (item != NULL)\n\t\t\t\titem = cmdq_insert_after(item, new_item);\n\t\t\telse\n\t\t\t\titem = cmdq_append(NULL, new_item);\n\t\t}\n\t\ta = options_array_next(a);\n\t}\n\n\tcmdq_free_state(new_state);\n\tfree(name);\n}\n\n/* Continue processing command queue. */\nvoid\ncmdq_continue(struct cmdq_item *item)\n{\n\titem->flags &= ~CMDQ_WAITING;\n}\n\n/* Remove an item. */\nstatic void\ncmdq_remove(struct cmdq_item *item)\n{\n\tif (item->client != NULL)\n\t\tserver_client_unref(item->client);\n\tif (item->cmdlist != NULL)\n\t\tcmd_list_free(item->cmdlist);\n\tcmdq_free_state(item->state);\n\n\tTAILQ_REMOVE(&item->queue->list, item, entry);\n\n\tfree(item->name);\n\tfree(item);\n}\n\n/* Remove all subsequent items that match this item's group. */\nstatic void\ncmdq_remove_group(struct cmdq_item *item)\n{\n\tstruct cmdq_item\t*this, *next;\n\n\tif (item->group == 0)\n\t\treturn;\n\tthis = TAILQ_NEXT(item, entry);\n\twhile (this != NULL) {\n\t\tnext = TAILQ_NEXT(this, entry);\n\t\tif (this->group == item->group)\n\t\t\tcmdq_remove(this);\n\t\tthis = next;\n\t}\n}\n\n/* Empty command callback. */\nstatic enum cmd_retval\ncmdq_empty_command(__unused struct cmdq_item *item, __unused void *data)\n{\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Get a command for the command queue. */\nstruct cmdq_item *\ncmdq_get_command(struct cmd_list *cmdlist, struct cmdq_state *state)\n{\n\tstruct cmdq_item\t*item, *first = NULL, *last = NULL;\n\tstruct cmd\t\t*cmd;\n\tconst struct cmd_entry\t*entry;\n\tint\t\t\t created = 0;\n\n\tif ((cmd = cmd_list_first(cmdlist)) == NULL)\n\t\treturn (cmdq_get_callback(cmdq_empty_command, NULL));\n\n\tif (state == NULL) {\n\t\tstate = cmdq_new_state(NULL, NULL, 0);\n\t\tcreated = 1;\n\t}\n\n\twhile (cmd != NULL) {\n\t\tentry = cmd_get_entry(cmd);\n\n\t\titem = xcalloc(1, sizeof *item);\n\t\txasprintf(&item->name, \"[%s/%p]\", entry->name, item);\n\t\titem->type = CMDQ_COMMAND;\n\n\t\titem->group = cmd_get_group(cmd);\n\t\titem->state = cmdq_link_state(state);\n\n\t\titem->cmdlist = cmdlist;\n\t\titem->cmd = cmd;\n\n\t\tcmdlist->references++;\n\t\tlog_debug(\"%s: %s group %u\", __func__, item->name, item->group);\n\n\t\tif (first == NULL)\n\t\t\tfirst = item;\n\t\tif (last != NULL)\n\t\t\tlast->next = item;\n\t\tlast = item;\n\n\t\tcmd = cmd_list_next(cmd);\n\t}\n\n\tif (created)\n\t\tcmdq_free_state(state);\n\treturn (first);\n}\n\n/* Fill in flag for a command. */\nstatic enum cmd_retval\ncmdq_find_flag(struct cmdq_item *item, struct cmd_find_state *fs,\n    const struct cmd_entry_flag *flag)\n{\n\tconst char\t*value;\n\n\tif (flag->flag == 0) {\n\t\tcmd_find_from_client(fs, item->target_client, 0);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tvalue = args_get(cmd_get_args(item->cmd), flag->flag);\n\tif (cmd_find_target(fs, item, value, flag->type, flag->flags) != 0) {\n\t\tcmd_find_clear_state(fs, 0);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Add message with command. */\nstatic void\ncmdq_add_message(struct cmdq_item *item)\n{\n\tstruct client\t\t*c = item->client;\n\tstruct cmdq_state\t*state = item->state;\n\tconst char\t\t*key;\n\tchar\t\t\t*tmp;\n\tuid_t                    uid;\n\tstruct passwd\t\t*pw;\n\tchar                    *user = NULL;\n\n\ttmp = cmd_print(item->cmd);\n\tif (c != NULL) {\n\t\tuid = proc_get_peer_uid(c->peer);\n\t\tif (uid != (uid_t)-1 && uid != getuid()) {\n\t\t\tif ((pw = getpwuid(uid)) != NULL)\n\t\t\t\txasprintf(&user, \"[%s]\", pw->pw_name);\n\t\t\telse\n\t\t\t\tuser = xstrdup(\"[unknown]\");\n\t\t} else\n\t\t\tuser = xstrdup(\"\");\n\t\tif (c->session != NULL && state->event.key != KEYC_NONE) {\n\t\t\tkey = key_string_lookup_key(state->event.key, 0);\n\t\t\tserver_add_message(\"%s%s key %s: %s\", c->name, user,\n\t\t\t    key, tmp);\n\t\t} else {\n\t\t\tserver_add_message(\"%s%s command: %s\", c->name, user,\n\t\t\t    tmp);\n\t\t}\n\t\tfree(user);\n\t} else\n\t\tserver_add_message(\"command: %s\", tmp);\n\tfree(tmp);\n}\n\n/* Fire command on command queue. */\nstatic enum cmd_retval\ncmdq_fire_command(struct cmdq_item *item)\n{\n\tconst char\t\t*name = cmdq_name(item->client);\n\tstruct cmdq_state\t*state = item->state;\n\tstruct cmd\t\t*cmd = item->cmd;\n\tstruct args\t\t*args = cmd_get_args(cmd);\n\tconst struct cmd_entry\t*entry = cmd_get_entry(cmd);\n\tstruct client\t\t*tc, *saved = item->client;\n\tenum cmd_retval\t\t retval;\n\tstruct cmd_find_state\t*fsp, fs;\n\tint\t\t\t flags, quiet = 0;\n\tchar\t\t\t*tmp;\n\n\tif (cfg_finished)\n\t\tcmdq_add_message(item);\n\tif (log_get_level() > 1) {\n\t\ttmp = cmd_print(cmd);\n\t\tlog_debug(\"%s %s: (%u) %s\", __func__, name, item->group, tmp);\n\t\tfree(tmp);\n\t}\n\n\tflags = !!(state->flags & CMDQ_STATE_CONTROL);\n\tcmdq_guard(item, \"begin\", flags);\n\n\tif (item->client == NULL)\n\t\titem->client = cmd_find_client(item, NULL, 1);\n\n\tif (entry->flags & CMD_CLIENT_CANFAIL)\n\t\tquiet = 1;\n\tif (entry->flags & CMD_CLIENT_CFLAG) {\n\t\ttc = cmd_find_client(item, args_get(args, 'c'), quiet);\n\t\tif (tc == NULL && !quiet) {\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t} else if (entry->flags & CMD_CLIENT_TFLAG) {\n\t\ttc = cmd_find_client(item, args_get(args, 't'), quiet);\n\t\tif (tc == NULL && !quiet) {\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\ttc = cmd_find_client(item, NULL, 1);\n\titem->target_client = tc;\n\n\tretval = cmdq_find_flag(item, &item->source, &entry->source);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\tretval = cmdq_find_flag(item, &item->target, &entry->target);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\n\tretval = entry->exec(cmd, item);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto out;\n\n\tif (entry->flags & CMD_AFTERHOOK) {\n\t\tif (cmd_find_valid_state(&item->target))\n\t\t\tfsp = &item->target;\n\t\telse if (cmd_find_valid_state(&item->state->current))\n\t\t\tfsp = &item->state->current;\n\t\telse if (cmd_find_from_client(&fs, item->client, 0) == 0)\n\t\t\tfsp = &fs;\n\t\telse\n\t\t\tgoto out;\n\t\tcmdq_insert_hook(fsp->s, item, fsp, \"after-%s\", entry->name);\n\t}\n\nout:\n\titem->client = saved;\n\tif (retval == CMD_RETURN_ERROR) {\n\t\tfsp = NULL;\n\t\tif (cmd_find_valid_state(&item->target))\n\t\t\tfsp = &item->target;\n\t\telse if (cmd_find_valid_state(&item->state->current))\n\t\t\tfsp = &item->state->current;\n\t\telse if (cmd_find_from_client(&fs, item->client, 0) == 0)\n\t\t\tfsp = &fs;\n\t\tcmdq_insert_hook(fsp != NULL ? fsp->s : NULL, item, fsp,\n\t\t    \"command-error\");\n\t\tcmdq_guard(item, \"error\", flags);\n\t} else\n\t\tcmdq_guard(item, \"end\", flags);\n\treturn (retval);\n}\n\n/* Get a callback for the command queue. */\nstruct cmdq_item *\ncmdq_get_callback1(const char *name, cmdq_cb cb, void *data)\n{\n\tstruct cmdq_item\t*item;\n\n\titem = xcalloc(1, sizeof *item);\n\txasprintf(&item->name, \"[%s/%p]\", name, item);\n\titem->type = CMDQ_CALLBACK;\n\n\titem->group = 0;\n\titem->state = cmdq_new_state(NULL, NULL, 0);\n\n\titem->cb = cb;\n\titem->data = data;\n\n\treturn (item);\n}\n\n/* Generic error callback. */\nstatic enum cmd_retval\ncmdq_error_callback(struct cmdq_item *item, void *data)\n{\n\tchar\t*error = data;\n\n\tcmdq_error(item, \"%s\", error);\n\tfree(error);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Get an error callback for the command queue. */\nstruct cmdq_item *\ncmdq_get_error(const char *error)\n{\n\treturn (cmdq_get_callback(cmdq_error_callback, xstrdup(error)));\n}\n\n/* Fire callback on callback queue. */\nstatic enum cmd_retval\ncmdq_fire_callback(struct cmdq_item *item)\n{\n\treturn (item->cb(item, item->data));\n}\n\n/* Process next item on command queue. */\nu_int\ncmdq_next(struct client *c)\n{\n\tstruct cmdq_list\t*queue = cmdq_get(c);\n\tconst char\t\t*name = cmdq_name(c);\n\tstruct cmdq_item\t*item;\n\tenum cmd_retval\t\t retval;\n\tu_int\t\t\t items = 0;\n\tstatic u_int\t\t number;\n\n\tif (TAILQ_EMPTY(&queue->list)) {\n\t\tlog_debug(\"%s %s: empty\", __func__, name);\n\t\treturn (0);\n\t}\n\tif (TAILQ_FIRST(&queue->list)->flags & CMDQ_WAITING) {\n\t\tlog_debug(\"%s %s: waiting\", __func__, name);\n\t\treturn (0);\n\t}\n\n\tlog_debug(\"%s %s: enter\", __func__, name);\n\tfor (;;) {\n\t\titem = queue->item = TAILQ_FIRST(&queue->list);\n\t\tif (item == NULL)\n\t\t\tbreak;\n\t\tlog_debug(\"%s %s: %s (%d), flags %x\", __func__, name,\n\t\t    item->name, item->type, item->flags);\n\n\t\t/*\n\t\t * Any item with the waiting flag set waits until an external\n\t\t * event clears the flag (for example, a job - look at\n\t\t * run-shell).\n\t\t */\n\t\tif (item->flags & CMDQ_WAITING)\n\t\t\tgoto waiting;\n\n\t\t/*\n\t\t * Items are only fired once, once the fired flag is set, a\n\t\t * waiting flag can only be cleared by an external event.\n\t\t */\n\t\tif (~item->flags & CMDQ_FIRED) {\n\t\t\titem->time = time(NULL);\n\t\t\titem->number = ++number;\n\n\t\t\tswitch (item->type) {\n\t\t\tcase CMDQ_COMMAND:\n\t\t\t\tretval = cmdq_fire_command(item);\n\n\t\t\t\t/*\n\t\t\t\t * If a command returns an error, remove any\n\t\t\t\t * subsequent commands in the same group.\n\t\t\t\t */\n\t\t\t\tif (retval == CMD_RETURN_ERROR)\n\t\t\t\t\tcmdq_remove_group(item);\n\t\t\t\tbreak;\n\t\t\tcase CMDQ_CALLBACK:\n\t\t\t\tretval = cmdq_fire_callback(item);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem->flags |= CMDQ_FIRED;\n\n\t\t\tif (retval == CMD_RETURN_WAIT) {\n\t\t\t\titem->flags |= CMDQ_WAITING;\n\t\t\t\tgoto waiting;\n\t\t\t}\n\t\t\titems++;\n\t\t}\n\t\tcmdq_remove(item);\n\t}\n\tqueue->item = NULL;\n\n\tlog_debug(\"%s %s: exit (empty)\", __func__, name);\n\treturn (items);\n\nwaiting:\n\tlog_debug(\"%s %s: exit (wait)\", __func__, name);\n\treturn (items);\n}\n\n/* Get running item if any. */\nstruct cmdq_item *\ncmdq_running(struct client *c)\n{\n\tstruct cmdq_list\t*queue = cmdq_get(c);\n\n\tif (queue->item == NULL)\n\t\treturn (NULL);\n\tif (queue->item->flags & CMDQ_WAITING)\n\t\treturn (NULL);\n\treturn (queue->item);\n}\n\n/* Print a guard line. */\nvoid\ncmdq_guard(struct cmdq_item *item, const char *guard, int flags)\n{\n\tstruct client\t*c = item->client;\n\tlong\t\t t = item->time;\n\tu_int\t\t number = item->number;\n\n\tif (c != NULL && (c->flags & CLIENT_CONTROL))\n\t\tcontrol_write(c, \"%%%s %ld %u %d\", guard, t, number, flags);\n}\n\n/* Show message from command. */\nvoid\ncmdq_print_data(struct cmdq_item *item, struct evbuffer *evb)\n{\n\tserver_client_print(item->client, 1, evb);\n}\n\n/* Show message from command. */\nvoid\ncmdq_print(struct cmdq_item *item, const char *fmt, ...)\n{\n\tva_list\t\t ap;\n\tstruct evbuffer\t*evb;\n\n\tevb = evbuffer_new();\n\tif (evb == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tva_start(ap, fmt);\n\tevbuffer_add_vprintf(evb, fmt, ap);\n\tva_end(ap);\n\n\tcmdq_print_data(item, evb);\n\tevbuffer_free(evb);\n}\n\n/* Show error from command. */\nvoid\ncmdq_error(struct cmdq_item *item, const char *fmt, ...)\n{\n\tstruct client\t*c = item->client;\n\tstruct cmd\t*cmd = item->cmd;\n\tva_list\t\t ap;\n\tchar\t\t*msg, *tmp;\n\tconst char\t*file;\n\tu_int\t\t line;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"%s: %s\", __func__, msg);\n\n\tif (c == NULL) {\n\t\tcmd_get_source(cmd, &file, &line);\n\t\tcfg_add_cause(\"%s:%u: %s\", file, line, msg);\n\t} else if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {\n\t\tserver_add_message(\"%s message: %s\", c->name, msg);\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\ttmp = msg;\n\t\t\tmsg = utf8_sanitize(tmp);\n\t\t\tfree(tmp);\n\t\t}\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tcontrol_write(c, \"%s\", msg);\n\t\telse\n\t\t\tfile_error(c, \"%s\\n\", msg);\n\t\tc->retval = 1;\n\t} else {\n\t\t*msg = toupper((u_char) *msg);\n\t\tstatus_message_set(c, -1, 1, 0, \"%s\", msg);\n\t}\n\n\tfree(msg);\n}\n"
        },
        {
          "name": "cmd-refresh-client.c",
          "type": "blob",
          "size": 8.548828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Refresh client.\n */\n\nstatic enum cmd_retval\tcmd_refresh_client_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_refresh_client_entry = {\n\t.name = \"refresh-client\",\n\t.alias = \"refresh\",\n\n\t.args = { \"A:B:cC:Df:r:F:l::LRSt:U\", 0, 1, NULL },\n\t.usage = \"[-cDlLRSU] [-A pane:state] [-B name:what:format] \"\n\t\t \"[-C XxY] [-f flags] [-r pane:report]\" CMD_TARGET_CLIENT_USAGE\n\t\t \" [adjustment]\",\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG,\n\t.exec = cmd_refresh_client_exec\n};\n\nstatic void\ncmd_refresh_client_update_subscription(struct client *tc, const char *value)\n{\n\tchar\t\t\t*copy, *split, *name, *what;\n\tenum control_sub_type\t subtype;\n\tint\t\t\t subid = -1;\n\n\tcopy = name = xstrdup(value);\n\tif ((split = strchr(copy, ':')) == NULL) {\n\t\tcontrol_remove_sub(tc, copy);\n\t\tgoto out;\n\t}\n\t*split++ = '\\0';\n\n\twhat = split;\n\tif ((split = strchr(what, ':')) == NULL)\n\t\tgoto out;\n\t*split++ = '\\0';\n\n\tif (strcmp(what, \"%*\") == 0)\n\t\tsubtype = CONTROL_SUB_ALL_PANES;\n\telse if (sscanf(what, \"%%%d\", &subid) == 1 && subid >= 0)\n\t\tsubtype = CONTROL_SUB_PANE;\n\telse if (strcmp(what, \"@*\") == 0)\n\t\tsubtype = CONTROL_SUB_ALL_WINDOWS;\n\telse if (sscanf(what, \"@%d\", &subid) == 1 && subid >= 0)\n\t\tsubtype = CONTROL_SUB_WINDOW;\n\telse\n\t\tsubtype = CONTROL_SUB_SESSION;\n\tcontrol_add_sub(tc, name, subtype, subid, split);\n\nout:\n\tfree(copy);\n}\n\nstatic enum cmd_retval\ncmd_refresh_client_control_client_size(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tconst char\t\t*size = args_get(args, 'C');\n\tu_int\t\t\t w, x, y;\n\tstruct client_window\t*cw;\n\n\tif (sscanf(size, \"@%u:%ux%u\", &w, &x, &y) == 3) {\n\t\tif (x < WINDOW_MINIMUM || x > WINDOW_MAXIMUM ||\n\t\t    y < WINDOW_MINIMUM || y > WINDOW_MAXIMUM) {\n\t\t\tcmdq_error(item, \"size too small or too big\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tlog_debug(\"%s: client %s window @%u: size %ux%u\", __func__,\n\t\t    tc->name, w, x, y);\n\t\tcw = server_client_add_client_window(tc, w);\n\t\tcw->sx = x;\n\t\tcw->sy = y;\n\t\ttc->flags |= CLIENT_WINDOWSIZECHANGED;\n\t\trecalculate_sizes_now(1);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (sscanf(size, \"@%u:\", &w) == 1) {\n\t\tcw = server_client_get_client_window(tc, w);\n\t\tif (cw != NULL) {\n\t\t\tlog_debug(\"%s: client %s window @%u: no size\", __func__,\n\t\t\t    tc->name, w);\n\t\t\tcw->sx = 0;\n\t\t\tcw->sy = 0;\n\t\t\trecalculate_sizes_now(1);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (sscanf(size, \"%u,%u\", &x, &y) != 2 &&\n\t    sscanf(size, \"%ux%u\", &x, &y) != 2) {\n\t\tcmdq_error(item, \"bad size argument\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (x < WINDOW_MINIMUM || x > WINDOW_MAXIMUM ||\n\t    y < WINDOW_MINIMUM || y > WINDOW_MAXIMUM) {\n\t\tcmdq_error(item, \"size too small or too big\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\ttty_set_size(&tc->tty, x, y, 0, 0);\n\ttc->flags |= CLIENT_SIZECHANGED;\n\trecalculate_sizes_now(1);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_refresh_client_update_offset(struct client *tc, const char *value)\n{\n\tstruct window_pane\t*wp;\n\tchar\t\t\t*copy, *split;\n\tu_int\t\t\t pane;\n\n\tif (*value != '%')\n\t\treturn;\n\tcopy = xstrdup(value);\n\tif ((split = strchr(copy, ':')) == NULL)\n\t\tgoto out;\n\t*split++ = '\\0';\n\n\tif (sscanf(copy, \"%%%u\", &pane) != 1)\n\t\tgoto out;\n\twp = window_pane_find_by_id(pane);\n\tif (wp == NULL)\n\t\tgoto out;\n\n\tif (strcmp(split, \"on\") == 0)\n\t\tcontrol_set_pane_on(tc, wp);\n\telse if (strcmp(split, \"off\") == 0)\n\t\tcontrol_set_pane_off(tc, wp);\n\telse if (strcmp(split, \"continue\") == 0)\n\t\tcontrol_continue_pane(tc, wp);\n\telse if (strcmp(split, \"pause\") == 0)\n\t\tcontrol_pause_pane(tc, wp);\n\nout:\n\tfree(copy);\n}\n\nstatic enum cmd_retval\ncmd_refresh_client_clipboard(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tconst char\t\t*p;\n\tu_int\t\t\t i;\n\tstruct cmd_find_state\t fs;\n\n\tp = args_get(args, 'l');\n\tif (p == NULL) {\n\t\tif (tc->flags & CLIENT_CLIPBOARDBUFFER)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\ttc->flags |= CLIENT_CLIPBOARDBUFFER;\n\t} else {\n\t\tif (cmd_find_target(&fs, item, p, CMD_FIND_PANE, 0) != 0)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\tfor (i = 0; i < tc->clipboard_npanes; i++) {\n\t\t\tif (tc->clipboard_panes[i] == fs.wp->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != tc->clipboard_npanes)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\ttc->clipboard_panes = xreallocarray(tc->clipboard_panes,\n\t\t    tc->clipboard_npanes + 1, sizeof *tc->clipboard_panes);\n\t\ttc->clipboard_panes[tc->clipboard_npanes++] = fs.wp->id;\n\t}\n\ttty_clipboard_query(&tc->tty);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_refresh_report(struct tty *tty, const char *value)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t pane;\n\tsize_t\t\t\t size = 0;\n\tchar\t\t\t*copy, *split;\n\n\tif (*value != '%')\n\t\treturn;\n\tcopy = xstrdup(value);\n\tif ((split = strchr(copy, ':')) == NULL)\n\t\tgoto out;\n\t*split++ = '\\0';\n\n\tif (sscanf(copy, \"%%%u\", &pane) != 1)\n\t\tgoto out;\n\twp = window_pane_find_by_id(pane);\n\tif (wp == NULL)\n\t\tgoto out;\n\n\ttty_keys_colours(tty, split, strlen(split), &size, &wp->control_fg,\n\t    &wp->control_bg);\n\nout:\n\tfree(copy);\n}\n\nstatic enum cmd_retval\ncmd_refresh_client_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct tty\t\t*tty = &tc->tty;\n\tstruct window\t\t*w;\n\tconst char\t\t*errstr;\n\tu_int\t\t\t adjust;\n\tstruct args_value\t*av;\n\n\tif (args_has(args, 'c') ||\n\t    args_has(args, 'L') ||\n\t    args_has(args, 'R') ||\n\t    args_has(args, 'U') ||\n\t    args_has(args, 'D'))\n\t{\n\t\tif (args_count(args) == 0)\n\t\t\tadjust = 1;\n\t\telse {\n\t\t\tadjust = strtonum(args_string(args, 0), 1, INT_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL) {\n\t\t\t\tcmdq_error(item, \"adjustment %s\", errstr);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t}\n\n\t\tif (args_has(args, 'c'))\n\t\t\ttc->pan_window = NULL;\n\t\telse {\n\t\t\tw = tc->session->curw->window;\n\t\t\tif (tc->pan_window != w) {\n\t\t\t\ttc->pan_window = w;\n\t\t\t\ttc->pan_ox = tty->oox;\n\t\t\t\ttc->pan_oy = tty->ooy;\n\t\t\t}\n\t\t\tif (args_has(args, 'L')) {\n\t\t\t\tif (tc->pan_ox > adjust)\n\t\t\t\t\ttc->pan_ox -= adjust;\n\t\t\t\telse\n\t\t\t\t\ttc->pan_ox = 0;\n\t\t\t} else if (args_has(args, 'R')) {\n\t\t\t\ttc->pan_ox += adjust;\n\t\t\t\tif (tc->pan_ox > w->sx - tty->osx)\n\t\t\t\t\ttc->pan_ox = w->sx - tty->osx;\n\t\t\t} else if (args_has(args, 'U')) {\n\t\t\t\tif (tc->pan_oy > adjust)\n\t\t\t\t\ttc->pan_oy -= adjust;\n\t\t\t\telse\n\t\t\t\t\ttc->pan_oy = 0;\n\t\t\t} else if (args_has(args, 'D')) {\n\t\t\t\ttc->pan_oy += adjust;\n\t\t\t\tif (tc->pan_oy > w->sy - tty->osy)\n\t\t\t\t\ttc->pan_oy = w->sy - tty->osy;\n\t\t\t}\n\t\t}\n\t\ttty_update_client_offset(tc);\n\t\tserver_redraw_client(tc);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'l'))\n\t\treturn (cmd_refresh_client_clipboard(self, item));\n\n\tif (args_has(args, 'F')) /* -F is an alias for -f */\n\t\tserver_client_set_flags(tc, args_get(args, 'F'));\n\tif (args_has(args, 'f'))\n\t\tserver_client_set_flags(tc, args_get(args, 'f'));\n\tif (args_has(args, 'r'))\n\t\tcmd_refresh_report(tty, args_get(args, 'r'));\n\n\tif (args_has(args, 'A')) {\n\t\tif (~tc->flags & CLIENT_CONTROL)\n\t\t\tgoto not_control_client;\n\t\tav = args_first_value(args, 'A');\n\t\twhile (av != NULL) {\n\t\t\tcmd_refresh_client_update_offset(tc, av->string);\n\t\t\tav = args_next_value(av);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (args_has(args, 'B')) {\n\t\tif (~tc->flags & CLIENT_CONTROL)\n\t\t\tgoto not_control_client;\n\t\tav = args_first_value(args, 'B');\n\t\twhile (av != NULL) {\n\t\t\tcmd_refresh_client_update_subscription(tc, av->string);\n\t\t\tav = args_next_value(av);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (args_has(args, 'C')) {\n\t\tif (~tc->flags & CLIENT_CONTROL)\n\t\t\tgoto not_control_client;\n\t\treturn (cmd_refresh_client_control_client_size(self, item));\n\t}\n\n\tif (args_has(args, 'S')) {\n\t\ttc->flags |= CLIENT_STATUSFORCE;\n\t\tserver_status_client(tc);\n\t} else {\n\t\ttc->flags |= CLIENT_STATUSFORCE;\n\t\tserver_redraw_client(tc);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n\nnot_control_client:\n\tcmdq_error(item, \"not a control client\");\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-rename-session.c",
          "type": "blob",
          "size": 2.1787109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Change session name.\n */\n\nstatic enum cmd_retval\tcmd_rename_session_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_rename_session_entry = {\n\t.name = \"rename-session\",\n\t.alias = \"rename\",\n\n\t.args = { \"t:\", 1, 1, NULL },\n\t.usage = CMD_TARGET_SESSION_USAGE \" new-name\",\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_rename_session_exec\n};\n\nstatic enum cmd_retval\ncmd_rename_session_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct session\t\t*s = target->s;\n\tchar\t\t\t*newname, *tmp;\n\n\ttmp = format_single_from_target(item, args_string(args, 0));\n\tnewname = session_check_name(tmp);\n\tif (newname == NULL) {\n\t\tcmdq_error(item, \"invalid session: %s\", tmp);\n\t\tfree(tmp);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tfree(tmp);\n\tif (strcmp(newname, s->name) == 0) {\n\t\tfree(newname);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (session_find(newname) != NULL) {\n\t\tcmdq_error(item, \"duplicate session: %s\", newname);\n\t\tfree(newname);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tRB_REMOVE(sessions, &sessions, s);\n\tfree(s->name);\n\ts->name = newname;\n\tRB_INSERT(sessions, &sessions, s);\n\n\tserver_status_session(s);\n\tnotify_session(\"session-renamed\", s);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-rename-window.c",
          "type": "blob",
          "size": 1.787109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Rename a window.\n */\n\nstatic enum cmd_retval\tcmd_rename_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_rename_window_entry = {\n\t.name = \"rename-window\",\n\t.alias = \"renamew\",\n\n\t.args = { \"t:\", 1, 1, NULL },\n\t.usage = CMD_TARGET_WINDOW_USAGE \" new-name\",\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_rename_window_exec\n};\n\nstatic enum cmd_retval\ncmd_rename_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tchar\t\t\t*newname;\n\n\tnewname = format_single_from_target(item, args_string(args, 0));\n\twindow_set_name(wl->window, newname);\n\toptions_set_number(wl->window->options, \"automatic-rename\", 0);\n\n\tserver_redraw_window_borders(wl->window);\n\tserver_status_window(wl->window);\n\tfree(newname);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-resize-pane.c",
          "type": "blob",
          "size": 5.6904296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Increase or decrease pane size.\n */\n\nstatic enum cmd_retval\tcmd_resize_pane_exec(struct cmd *, struct cmdq_item *);\n\nstatic void\tcmd_resize_pane_mouse_update(struct client *,\n\t\t    struct mouse_event *);\n\nconst struct cmd_entry cmd_resize_pane_entry = {\n\t.name = \"resize-pane\",\n\t.alias = \"resizep\",\n\n\t.args = { \"DLMRTt:Ux:y:Z\", 0, 1, NULL },\n\t.usage = \"[-DLMRTUZ] [-x width] [-y height] \" CMD_TARGET_PANE_USAGE \" \"\n\t\t \"[adjustment]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_resize_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_resize_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct key_event\t*event = cmdq_get_event(item);\n\tstruct window_pane\t*wp = target->wp;\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct session\t\t*s = target->s;\n\tconst char\t       \t*errstr;\n\tchar\t\t\t*cause;\n\tu_int\t\t\t adjust;\n\tint\t\t\t x, y, status;\n\tstruct grid\t\t*gd = wp->base.grid;\n\n\tif (args_has(args, 'T')) {\n\t\tif (!TAILQ_EMPTY(&wp->modes))\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tadjust = screen_size_y(&wp->base) - 1 - wp->base.cy;\n\t\tif (adjust > gd->hsize)\n\t\t\tadjust = gd->hsize;\n\t\tgrid_remove_history(gd, adjust);\n\t\twp->base.cy += adjust;\n\t\twp->flags |= PANE_REDRAW;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'M')) {\n\t\tif (!event->m.valid || cmd_mouse_window(&event->m, &s) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (c == NULL || c->session != s)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tc->tty.mouse_drag_update = cmd_resize_pane_mouse_update;\n\t\tcmd_resize_pane_mouse_update(c, &event->m);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'Z')) {\n\t\tif (w->flags & WINDOW_ZOOMED)\n\t\t\twindow_unzoom(w, 1);\n\t\telse\n\t\t\twindow_zoom(wp);\n\t\tserver_redraw_window(w);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tserver_unzoom_window(w);\n\n\tif (args_count(args) == 0)\n\t\tadjust = 1;\n\telse {\n\t\tadjust = strtonum(args_string(args, 0), 1, INT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tcmdq_error(item, \"adjustment %s\", errstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(args, 'x')) {\n\t\tx = args_percentage(args, 'x', 0, INT_MAX, w->sx, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"width %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tlayout_resize_pane_to(wp, LAYOUT_LEFTRIGHT, x);\n\t}\n\tif (args_has(args, 'y')) {\n\t\ty = args_percentage(args, 'y', 0, INT_MAX, w->sy, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"height %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tstatus = options_get_number(w->options, \"pane-border-status\");\n\t\tswitch (status) {\n\t\tcase PANE_STATUS_TOP:\n\t\t\tif (y != INT_MAX && wp->yoff == 1)\n\t\t\t\ty++;\n\t\t\tbreak;\n\t\tcase PANE_STATUS_BOTTOM:\n\t\t\tif (y != INT_MAX && wp->yoff + wp->sy == w->sy - 1)\n\t\t\t\ty++;\n\t\t\tbreak;\n\t\t}\n\t\tlayout_resize_pane_to(wp, LAYOUT_TOPBOTTOM, y);\n\t}\n\n\tif (args_has(args, 'L'))\n\t\tlayout_resize_pane(wp, LAYOUT_LEFTRIGHT, -adjust, 1);\n\telse if (args_has(args, 'R'))\n\t\tlayout_resize_pane(wp, LAYOUT_LEFTRIGHT, adjust, 1);\n\telse if (args_has(args, 'U'))\n\t\tlayout_resize_pane(wp, LAYOUT_TOPBOTTOM, -adjust, 1);\n\telse if (args_has(args, 'D'))\n\t\tlayout_resize_pane(wp, LAYOUT_TOPBOTTOM, adjust, 1);\n\tserver_redraw_window(wl->window);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_resize_pane_mouse_update(struct client *c, struct mouse_event *m)\n{\n\tstruct winlink\t\t*wl;\n\tstruct window\t\t*w;\n\tu_int\t\t\t y, ly, x, lx;\n\tstatic const int         offsets[][2] = {\n\t    { 0, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 },\n\t};\n\tstruct layout_cell\t*cells[nitems(offsets)], *lc;\n\tu_int\t\t\t ncells = 0, i, j, resizes = 0;\n\tenum layout_type\t type;\n\n\twl = cmd_mouse_window(m, NULL);\n\tif (wl == NULL) {\n\t\tc->tty.mouse_drag_update = NULL;\n\t\treturn;\n\t}\n\tw = wl->window;\n\n\ty = m->y + m->oy; x = m->x + m->ox;\n\tif (m->statusat == 0 && y >= m->statuslines)\n\t\ty -= m->statuslines;\n\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\ty = m->statusat - 1;\n\tly = m->ly + m->oy; lx = m->lx + m->ox;\n\tif (m->statusat == 0 && ly >= m->statuslines)\n\t\tly -= m->statuslines;\n\telse if (m->statusat > 0 && ly >= (u_int)m->statusat)\n\t\tly = m->statusat - 1;\n\n\tfor (i = 0; i < nitems(cells); i++) {\n\t\tlc = layout_search_by_border(w->layout_root, lx + offsets[i][0],\n\t\t    ly + offsets[i][1]);\n\t\tif (lc == NULL)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ncells; j++) {\n\t\t\tif (cells[j] == lc) {\n\t\t\t\tlc = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (lc == NULL)\n\t\t\tcontinue;\n\n\t\tcells[ncells] = lc;\n\t\tncells++;\n\t}\n\tif (ncells == 0)\n\t\treturn;\n\n\tfor (i = 0; i < ncells; i++) {\n\t\ttype = cells[i]->parent->type;\n\t\tif (y != ly && type == LAYOUT_TOPBOTTOM) {\n\t\t\tlayout_resize_layout(w, cells[i], type, y - ly, 0);\n\t\t\tresizes++;\n\t\t} else if (x != lx && type == LAYOUT_LEFTRIGHT) {\n\t\t\tlayout_resize_layout(w, cells[i], type, x - lx, 0);\n\t\t\tresizes++;\n\t\t}\n\t}\n\tif (resizes != 0)\n\t\tserver_redraw_window(w);\n}\n"
        },
        {
          "name": "cmd-resize-window.c",
          "type": "blob",
          "size": 3.0205078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2018 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Increase or decrease window size.\n */\n\nstatic enum cmd_retval\tcmd_resize_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_resize_window_entry = {\n\t.name = \"resize-window\",\n\t.alias = \"resizew\",\n\n\t.args = { \"aADLRt:Ux:y:\", 0, 1, NULL },\n\t.usage = \"[-aADLRU] [-x width] [-y height] \" CMD_TARGET_WINDOW_USAGE \" \"\n\t\t \"[adjustment]\",\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_resize_window_exec\n};\n\nstatic enum cmd_retval\ncmd_resize_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct session\t\t*s = target->s;\n\tconst char\t       \t*errstr;\n\tchar\t\t\t*cause;\n\tu_int\t\t\t adjust, sx, sy, xpixel = 0, ypixel = 0;\n\n\tif (args_count(args) == 0)\n\t\tadjust = 1;\n\telse {\n\t\tadjust = strtonum(args_string(args, 0), 1, INT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tcmdq_error(item, \"adjustment %s\", errstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tsx = w->sx;\n\tsy = w->sy;\n\n\tif (args_has(args, 'x')) {\n\t\tsx = args_strtonum(args, 'x', WINDOW_MINIMUM, WINDOW_MAXIMUM,\n\t\t    &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"width %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\tif (args_has(args, 'y')) {\n\t\tsy = args_strtonum(args, 'y', WINDOW_MINIMUM, WINDOW_MAXIMUM,\n\t\t    &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"height %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(args, 'L')) {\n\t\tif (sx >= adjust)\n\t\t\tsx -= adjust;\n\t} else if (args_has(args, 'R'))\n\t\tsx += adjust;\n\telse if (args_has(args, 'U')) {\n\t\tif (sy >= adjust)\n\t\t\tsy -= adjust;\n\t} else if (args_has(args, 'D'))\n\t\tsy += adjust;\n\n\tif (args_has(args, 'A')) {\n\t\tdefault_window_size(NULL, s, w, &sx, &sy, &xpixel, &ypixel,\n\t\t    WINDOW_SIZE_LARGEST);\n\t} else if (args_has(args, 'a')) {\n\t\tdefault_window_size(NULL, s, w, &sx, &sy, &xpixel, &ypixel,\n\t\t    WINDOW_SIZE_SMALLEST);\n\t}\n\n\toptions_set_number(w->options, \"window-size\", WINDOW_SIZE_MANUAL);\n\tw->manual_sx = sx;\n\tw->manual_sy = sy;\n\trecalculate_size(w, 1);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-respawn-pane.c",
          "type": "blob",
          "size": 2.60546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2011 Marcel P. Partap <mpartap@gmx.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Respawn a pane (restart the command). Kill existing if -k given.\n */\n\nstatic enum cmd_retval\tcmd_respawn_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_respawn_pane_entry = {\n\t.name = \"respawn-pane\",\n\t.alias = \"respawnp\",\n\n\t.args = { \"c:e:kt:\", 0, -1, NULL },\n\t.usage = \"[-k] [-c start-directory] [-e environment] \"\n\t\t CMD_TARGET_PANE_USAGE \" [shell-command]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_respawn_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_respawn_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct spawn_context\t sc = { 0 };\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window_pane\t*wp = target->wp;\n\tchar\t\t\t*cause = NULL;\n\tstruct args_value\t*av;\n\n\tsc.item = item;\n\tsc.s = s;\n\tsc.wl = wl;\n\n\tsc.wp0 = wp;\n\n\targs_to_vector(args, &sc.argc, &sc.argv);\n\tsc.environ = environ_create();\n\n\tav = args_first_value(args, 'e');\n\twhile (av != NULL) {\n\t\tenviron_put(sc.environ, av->string, 0);\n\t\tav = args_next_value(av);\n\t}\n\n\tsc.idx = -1;\n\tsc.cwd = args_get(args, 'c');\n\n\tsc.flags = SPAWN_RESPAWN;\n\tif (args_has(args, 'k'))\n\t\tsc.flags |= SPAWN_KILL;\n\n\tif (spawn_pane(&sc, &cause) == NULL) {\n\t\tcmdq_error(item, \"respawn pane failed: %s\", cause);\n\t\tfree(cause);\n\t\tif (sc.argv != NULL)\n\t\t\tcmd_free_argv(sc.argc, sc.argv);\n\t\tenviron_free(sc.environ);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\twp->flags |= PANE_REDRAW;\n\tserver_redraw_window_borders(wp->window);\n\tserver_status_window(wp->window);\n\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tenviron_free(sc.environ);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-respawn-window.c",
          "type": "blob",
          "size": 2.51953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Respawn a window (restart the command). Kill existing if -k given.\n */\n\nstatic enum cmd_retval\tcmd_respawn_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_respawn_window_entry = {\n\t.name = \"respawn-window\",\n\t.alias = \"respawnw\",\n\n\t.args = { \"c:e:kt:\", 0, -1, NULL },\n\t.usage = \"[-k] [-c start-directory] [-e environment] \"\n\t\t CMD_TARGET_WINDOW_USAGE \" [shell-command]\",\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_respawn_window_exec\n};\n\nstatic enum cmd_retval\ncmd_respawn_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct spawn_context\t sc = { 0 };\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl;\n\tchar\t\t\t*cause = NULL;\n\tstruct args_value\t*av;\n\n\tsc.item = item;\n\tsc.s = s;\n\tsc.wl = wl;\n\tsc.tc = tc;\n\n\targs_to_vector(args, &sc.argc, &sc.argv);\n\tsc.environ = environ_create();\n\n\tav = args_first_value(args, 'e');\n\twhile (av != NULL) {\n\t\tenviron_put(sc.environ, av->string, 0);\n\t\tav = args_next_value(av);\n\t}\n\n\tsc.idx = -1;\n\tsc.cwd = args_get(args, 'c');\n\n\tsc.flags = SPAWN_RESPAWN;\n\tif (args_has(args, 'k'))\n\t\tsc.flags |= SPAWN_KILL;\n\n\tif (spawn_window(&sc, &cause) == NULL) {\n\t\tcmdq_error(item, \"respawn window failed: %s\", cause);\n\t\tfree(cause);\n\t\tif (sc.argv != NULL)\n\t\t\tcmd_free_argv(sc.argc, sc.argv);\n\t\tenviron_free(sc.environ);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tserver_redraw_window(wl->window);\n\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tenviron_free(sc.environ);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-rotate-window.c",
          "type": "blob",
          "size": 3.3857421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Rotate the panes in a window.\n */\n\nstatic enum cmd_retval\tcmd_rotate_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_rotate_window_entry = {\n\t.name = \"rotate-window\",\n\t.alias = \"rotatew\",\n\n\t.args = { \"Dt:UZ\", 0, 0, NULL },\n\t.usage = \"[-DUZ] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_rotate_window_exec\n};\n\nstatic enum cmd_retval\ncmd_rotate_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp, *wp2;\n\tstruct layout_cell\t*lc;\n\tu_int\t\t\t sx, sy, xoff, yoff;\n\n\twindow_push_zoom(w, 0, args_has(args, 'Z'));\n\n\tif (args_has(args, 'D')) {\n\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\n\t\tlc = wp->layout_cell;\n\t\txoff = wp->xoff; yoff = wp->yoff;\n\t\tsx = wp->sx; sy = wp->sy;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif ((wp2 = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t\twp->layout_cell = wp2->layout_cell;\n\t\t\tif (wp->layout_cell != NULL)\n\t\t\t\twp->layout_cell->wp = wp;\n\t\t\twp->xoff = wp2->xoff; wp->yoff = wp2->yoff;\n\t\t\twindow_pane_resize(wp, wp2->sx, wp2->sy);\n\t\t}\n\t\twp->layout_cell = lc;\n\t\tif (wp->layout_cell != NULL)\n\t\t\twp->layout_cell->wp = wp;\n\t\twp->xoff = xoff; wp->yoff = yoff;\n\t\twindow_pane_resize(wp, sx, sy);\n\n\t\tif ((wp = TAILQ_PREV(w->active, window_panes, entry)) == NULL)\n\t\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t} else {\n\t\twp = TAILQ_FIRST(&w->panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\tTAILQ_INSERT_TAIL(&w->panes, wp, entry);\n\n\t\tlc = wp->layout_cell;\n\t\txoff = wp->xoff; yoff = wp->yoff;\n\t\tsx = wp->sx; sy = wp->sy;\n\t\tTAILQ_FOREACH_REVERSE(wp, &w->panes, window_panes, entry) {\n\t\t\tif ((wp2 = TAILQ_PREV(wp, window_panes, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t\twp->layout_cell = wp2->layout_cell;\n\t\t\tif (wp->layout_cell != NULL)\n\t\t\t\twp->layout_cell->wp = wp;\n\t\t\twp->xoff = wp2->xoff; wp->yoff = wp2->yoff;\n\t\t\twindow_pane_resize(wp, wp2->sx, wp2->sy);\n\t\t}\n\t\twp->layout_cell = lc;\n\t\tif (wp->layout_cell != NULL)\n\t\t\twp->layout_cell->wp = wp;\n\t\twp->xoff = xoff; wp->yoff = yoff;\n\t\twindow_pane_resize(wp, sx, sy);\n\n\t\tif ((wp = TAILQ_NEXT(w->active, entry)) == NULL)\n\t\t\twp = TAILQ_FIRST(&w->panes);\n\t}\n\n\twindow_set_active_pane(w, wp, 1);\n\tcmd_find_from_winlink_pane(current, wl, wp, 0);\n\twindow_pop_zoom(w);\n\tserver_redraw_window(w);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-run-shell.c",
          "type": "blob",
          "size": 7.4814453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n * Copyright (c) 2009 Nicholas Marriott <nicm@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Runs a command without a window.\n */\n\nstatic enum args_parse_type\tcmd_run_shell_args_parse(struct args *, u_int,\n\t\t\t\t    char **);\nstatic enum cmd_retval\t\tcmd_run_shell_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nstatic void\tcmd_run_shell_timer(int, short, void *);\nstatic void\tcmd_run_shell_callback(struct job *);\nstatic void\tcmd_run_shell_free(void *);\nstatic void\tcmd_run_shell_print(struct job *, const char *);\n\nconst struct cmd_entry cmd_run_shell_entry = {\n\t.name = \"run-shell\",\n\t.alias = \"run\",\n\n\t.args = { \"bd:Ct:c:\", 0, 2, cmd_run_shell_args_parse },\n\t.usage = \"[-bC] [-c start-directory] [-d delay] \" CMD_TARGET_PANE_USAGE\n\t         \" [shell-command]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = 0,\n\t.exec = cmd_run_shell_exec\n};\n\nstruct cmd_run_shell_data {\n\tstruct client\t\t\t*client;\n\tchar\t\t\t\t*cmd;\n\tstruct args_command_state\t*state;\n\tchar\t\t\t\t*cwd;\n\tstruct cmdq_item\t\t*item;\n\tstruct session\t\t\t*s;\n\tint\t\t\t\t wp_id;\n\tstruct event\t\t\t timer;\n\tint\t\t\t\t flags;\n};\n\nstatic enum args_parse_type\ncmd_run_shell_args_parse(struct args *args, __unused u_int idx,\n    __unused char **cause)\n{\n\tif (args_has(args, 'C'))\n\t\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n\treturn (ARGS_PARSE_STRING);\n}\n\nstatic void\ncmd_run_shell_print(struct job *job, const char *msg)\n{\n\tstruct cmd_run_shell_data\t*cdata = job_get_data(job);\n\tstruct window_pane\t\t*wp = NULL;\n\tstruct cmd_find_state\t\t fs;\n\tstruct window_mode_entry\t*wme;\n\n\tif (cdata->wp_id != -1)\n\t\twp = window_pane_find_by_id(cdata->wp_id);\n\tif (wp == NULL) {\n\t\tif (cdata->item != NULL) {\n\t\t\tcmdq_print(cdata->item, \"%s\", msg);\n\t\t\treturn;\n\t\t}\n\t\tif (cdata->item != NULL && cdata->client != NULL)\n\t\t\twp = server_client_get_pane(cdata->client);\n\t\tif (wp == NULL && cmd_find_from_nothing(&fs, 0) == 0)\n\t\t\twp = fs.wp;\n\t\tif (wp == NULL)\n\t\t\treturn;\n\t}\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->mode != &window_view_mode)\n\t\twindow_pane_set_mode(wp, NULL, &window_view_mode, NULL, NULL);\n\twindow_copy_add(wp, 1, \"%s\", msg);\n}\n\nstatic enum cmd_retval\ncmd_run_shell_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct cmd_run_shell_data\t*cdata;\n\tstruct client\t\t\t*c = cmdq_get_client(item);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t\t*s = target->s;\n\tstruct window_pane\t\t*wp = target->wp;\n\tconst char\t\t\t*delay, *cmd;\n\tdouble\t\t\t\t d;\n\tstruct timeval\t\t\t tv;\n\tchar\t\t\t\t*end;\n\tint\t\t\t\t wait = !args_has(args, 'b');\n\n\tif ((delay = args_get(args, 'd')) != NULL) {\n\t\td = strtod(delay, &end);\n\t\tif (*end != '\\0') {\n\t\t\tcmdq_error(item, \"invalid delay time: %s\", delay);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_count(args) == 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tif (!args_has(args, 'C')) {\n\t\tcmd = args_string(args, 0);\n\t\tif (cmd != NULL)\n\t\t\tcdata->cmd = format_single_from_target(item, cmd);\n\t} else {\n\t\tcdata->state = args_make_commands_prepare(self, item, 0, NULL,\n\t\t    wait, 1);\n\t}\n\n\tif (args_has(args, 't') && wp != NULL)\n\t\tcdata->wp_id = wp->id;\n\telse\n\t\tcdata->wp_id = -1;\n\n\tif (wait) {\n\t\tcdata->client = c;\n\t\tcdata->item = item;\n\t} else {\n\t\tcdata->client = tc;\n\t\tcdata->flags |= JOB_NOWAIT;\n\t}\n\tif (cdata->client != NULL)\n\t\tcdata->client->references++;\n\tif (args_has(args, 'c'))\n\t\tcdata->cwd = xstrdup(args_get(args, 'c'));\n\telse\n\t\tcdata->cwd = xstrdup(server_client_get_cwd(c, s));\n\n\tcdata->s = s;\n\tif (s != NULL)\n\t\tsession_add_ref(s, __func__);\n\n\tevtimer_set(&cdata->timer, cmd_run_shell_timer, cdata);\n\tif (delay != NULL) {\n\t\ttimerclear(&tv);\n\t\ttv.tv_sec = (time_t)d;\n\t\ttv.tv_usec = (d - (double)tv.tv_sec) * 1000000U;\n\t\tevtimer_add(&cdata->timer, &tv);\n\t} else\n\t\tevent_active(&cdata->timer, EV_TIMEOUT, 1);\n\n\tif (!wait)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic void\ncmd_run_shell_timer(__unused int fd, __unused short events, void* arg)\n{\n\tstruct cmd_run_shell_data\t*cdata = arg;\n\tstruct client\t\t\t*c = cdata->client;\n\tconst char\t\t\t*cmd = cdata->cmd;\n\tstruct cmdq_item\t\t*item = cdata->item, *new_item;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tchar\t\t\t\t*error;\n\n\tif (cdata->state == NULL) {\n\t\tif (cmd == NULL) {\n\t\t\tif (cdata->item != NULL)\n\t\t\t\tcmdq_continue(cdata->item);\n\t\t\tcmd_run_shell_free(cdata);\n\t\t\treturn;\n\t\t}\n\t\tif (job_run(cmd, 0, NULL, NULL, cdata->s, cdata->cwd, NULL,\n\t\t    cmd_run_shell_callback, cmd_run_shell_free, cdata,\n\t\t    cdata->flags, -1, -1) == NULL)\n\t\t\tcmd_run_shell_free(cdata);\n\t\treturn;\n\t}\n\n\tcmdlist = args_make_commands(cdata->state, 0, NULL, &error);\n\tif (cmdlist == NULL) {\n\t\tif (cdata->item == NULL) {\n\t\t\t*error = toupper((u_char)*error);\n\t\t\tstatus_message_set(c, -1, 1, 0, \"%s\", error);\n\t\t} else\n\t\t\tcmdq_error(cdata->item, \"%s\", error);\n\t\tfree(error);\n\t} else if (item == NULL) {\n\t\tnew_item = cmdq_get_command(cmdlist, NULL);\n\t\tcmdq_append(c, new_item);\n\t} else {\n\t\tnew_item = cmdq_get_command(cmdlist, cmdq_get_state(item));\n\t\tcmdq_insert_after(item, new_item);\n\t}\n\n\tif (cdata->item != NULL)\n\t\tcmdq_continue(cdata->item);\n\tcmd_run_shell_free(cdata);\n}\n\nstatic void\ncmd_run_shell_callback(struct job *job)\n{\n\tstruct cmd_run_shell_data\t*cdata = job_get_data(job);\n\tstruct bufferevent\t\t*event = job_get_event(job);\n\tstruct cmdq_item\t\t*item = cdata->item;\n\tchar\t\t\t\t*cmd = cdata->cmd, *msg = NULL, *line;\n\tsize_t\t\t\t\t size;\n\tint\t\t\t\t retcode, status;\n\n\tdo {\n\t\tline = evbuffer_readln(event->input, NULL, EVBUFFER_EOL_LF);\n\t\tif (line != NULL) {\n\t\t\tcmd_run_shell_print(job, line);\n\t\t\tfree(line);\n\t\t}\n\t} while (line != NULL);\n\n\tsize = EVBUFFER_LENGTH(event->input);\n\tif (size != 0) {\n\t\tline = xmalloc(size + 1);\n\t\tmemcpy(line, EVBUFFER_DATA(event->input), size);\n\t\tline[size] = '\\0';\n\n\t\tcmd_run_shell_print(job, line);\n\n\t\tfree(line);\n\t}\n\n\tstatus = job_get_status(job);\n\tif (WIFEXITED(status)) {\n\t\tif ((retcode = WEXITSTATUS(status)) != 0)\n\t\t\txasprintf(&msg, \"'%s' returned %d\", cmd, retcode);\n\t} else if (WIFSIGNALED(status)) {\n\t\tretcode = WTERMSIG(status);\n\t\txasprintf(&msg, \"'%s' terminated by signal %d\", cmd, retcode);\n\t\tretcode += 128;\n\t} else\n\t\tretcode = 0;\n\tif (msg != NULL)\n\t\tcmd_run_shell_print(job, msg);\n\tfree(msg);\n\n\tif (item != NULL) {\n\t\tif (cmdq_get_client(item) != NULL &&\n\t\t    cmdq_get_client(item)->session == NULL)\n\t\t\tcmdq_get_client(item)->retval = retcode;\n\t\tcmdq_continue(item);\n\t}\n}\n\nstatic void\ncmd_run_shell_free(void *data)\n{\n\tstruct cmd_run_shell_data\t*cdata = data;\n\n\tevtimer_del(&cdata->timer);\n\tif (cdata->s != NULL)\n\t\tsession_remove_ref(cdata->s, __func__);\n\tif (cdata->client != NULL)\n\t\tserver_client_unref(cdata->client);\n\tif (cdata->state != NULL)\n\t\targs_make_commands_free(cdata->state);\n\tfree(cdata->cwd);\n\tfree(cdata->cmd);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-save-buffer.c",
          "type": "blob",
          "size": 3.0654296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Saves a paste buffer to a file.\n */\n\nstatic enum cmd_retval\tcmd_save_buffer_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_save_buffer_entry = {\n\t.name = \"save-buffer\",\n\t.alias = \"saveb\",\n\n\t.args = { \"ab:\", 1, 1, NULL },\n\t.usage = \"[-a] \" CMD_BUFFER_USAGE \" path\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_save_buffer_exec\n};\n\nconst struct cmd_entry cmd_show_buffer_entry = {\n\t.name = \"show-buffer\",\n\t.alias = \"showb\",\n\n\t.args = { \"b:\", 0, 0, NULL },\n\t.usage = CMD_BUFFER_USAGE,\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_save_buffer_exec\n};\n\nstatic void\ncmd_save_buffer_done(__unused struct client *c, const char *path, int error,\n    __unused int closed, __unused struct evbuffer *buffer, void *data)\n{\n\tstruct cmdq_item\t*item = data;\n\n\tif (!closed)\n\t\treturn;\n\n\tif (error != 0)\n\t\tcmdq_error(item, \"%s: %s\", path, strerror(error));\n\tcmdq_continue(item);\n}\n\nstatic enum cmd_retval\ncmd_save_buffer_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct paste_buffer\t*pb;\n\tint\t\t\t flags;\n\tconst char\t\t*bufname = args_get(args, 'b'), *bufdata;\n\tsize_t\t\t\t bufsize;\n\tchar\t\t\t*path;\n\tstruct evbuffer\t\t*evb;\n\n\tif (bufname == NULL) {\n\t\tif ((pb = paste_get_top(NULL)) == NULL) {\n\t\t\tcmdq_error(item, \"no buffers\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tpb = paste_get_name(bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(item, \"no buffer %s\", bufname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\tbufdata = paste_buffer_data(pb, &bufsize);\n\n\tif (cmd_get_entry(self) == &cmd_show_buffer_entry) {\n\t\tif (c->session != NULL || (c->flags & CLIENT_CONTROL)) {\n\t\t\tevb = evbuffer_new();\n\t\t\tif (evb == NULL)\n\t\t\t\tfatalx(\"out of memory\");\n\t\t\tevbuffer_add(evb, bufdata, bufsize);\n\t\t\tcmdq_print_data(item, evb);\n\t\t\tevbuffer_free(evb);\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\tpath = xstrdup(\"-\");\n\t} else\n\t\tpath = format_single_from_target(item, args_string(args, 0));\n\tif (args_has(args, 'a'))\n\t\tflags = O_APPEND;\n\telse\n\t\tflags = O_TRUNC;\n\tfile_write(cmdq_get_client(item), path, flags, bufdata, bufsize,\n\t    cmd_save_buffer_done, item);\n\tfree(path);\n\n\treturn (CMD_RETURN_WAIT);\n}\n"
        },
        {
          "name": "cmd-select-layout.c",
          "type": "blob",
          "size": 3.474609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Switch window to selected layout.\n */\n\nstatic enum cmd_retval\tcmd_select_layout_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_select_layout_entry = {\n\t.name = \"select-layout\",\n\t.alias = \"selectl\",\n\n\t.args = { \"Enopt:\", 0, 1, NULL },\n\t.usage = \"[-Enop] \" CMD_TARGET_PANE_USAGE \" [layout-name]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_select_layout_exec\n};\n\nconst struct cmd_entry cmd_next_layout_entry = {\n\t.name = \"next-layout\",\n\t.alias = \"nextl\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_select_layout_exec\n};\n\nconst struct cmd_entry cmd_previous_layout_entry = {\n\t.name = \"previous-layout\",\n\t.alias = \"prevl\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_select_layout_exec\n};\n\nstatic enum cmd_retval\ncmd_select_layout_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp = target->wp;\n\tconst char\t\t*layoutname;\n\tchar\t\t\t*oldlayout, *cause;\n\tint\t\t\t next, previous, layout;\n\n\tserver_unzoom_window(w);\n\n\tnext = (cmd_get_entry(self) == &cmd_next_layout_entry);\n\tif (args_has(args, 'n'))\n\t\tnext = 1;\n\tprevious = (cmd_get_entry(self) == &cmd_previous_layout_entry);\n\tif (args_has(args, 'p'))\n\t\tprevious = 1;\n\n\toldlayout = w->old_layout;\n\tw->old_layout = layout_dump(w->layout_root);\n\n\tif (next || previous) {\n\t\tif (next)\n\t\t\tlayout_set_next(w);\n\t\telse\n\t\t\tlayout_set_previous(w);\n\t\tgoto changed;\n\t}\n\n\tif (args_has(args, 'E')) {\n\t\tlayout_spread_out(wp);\n\t\tgoto changed;\n\t}\n\n\tif (args_count(args) != 0)\n\t\tlayoutname = args_string(args, 0);\n\telse if (args_has(args, 'o'))\n\t\tlayoutname = oldlayout;\n\telse\n\t\tlayoutname = NULL;\n\n\tif (!args_has(args, 'o')) {\n\t\tif (layoutname == NULL)\n\t\t\tlayout = w->lastlayout;\n\t\telse\n\t\t\tlayout = layout_set_lookup(layoutname);\n\t\tif (layout != -1) {\n\t\t\tlayout_set_select(w, layout);\n\t\t\tgoto changed;\n\t\t}\n\t}\n\n\tif (layoutname != NULL) {\n\t\tif (layout_parse(w, layoutname, &cause) == -1) {\n\t\t\tcmdq_error(item, \"%s: %s\", cause, layoutname);\n\t\t\tfree(cause);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto changed;\n\t}\n\n\tfree(oldlayout);\n\treturn (CMD_RETURN_NORMAL);\n\nchanged:\n\tfree(oldlayout);\n\trecalculate_sizes();\n\tserver_redraw_window(w);\n\tnotify_window(\"window-layout-changed\", w);\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tfree(w->old_layout);\n\tw->old_layout = oldlayout;\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-select-pane.c",
          "type": "blob",
          "size": 6.86328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Select pane.\n */\n\nstatic enum cmd_retval\tcmd_select_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_select_pane_entry = {\n\t.name = \"select-pane\",\n\t.alias = \"selectp\",\n\n\t.args = { \"DdegLlMmP:RT:t:UZ\", 0, 0, NULL }, /* -P and -g deprecated */\n\t.usage = \"[-DdeLlMmRUZ] [-T title] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_pane_exec\n};\n\nconst struct cmd_entry cmd_last_pane_entry = {\n\t.name = \"last-pane\",\n\t.alias = \"lastp\",\n\n\t.args = { \"det:Z\", 0, 0, NULL },\n\t.usage = \"[-deZ] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_pane_exec\n};\n\nstatic void\ncmd_select_pane_redraw(struct window *w)\n{\n\tstruct client\t*c;\n\n\t/*\n\t * Redraw entire window if it is bigger than the client (the\n\t * offset may change), otherwise just draw borders.\n\t */\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || (c->flags & CLIENT_CONTROL))\n\t\t\tcontinue;\n\t\tif (c->session->curw->window == w && tty_window_bigger(&c->tty))\n\t\t\tserver_redraw_client(c);\n\t\telse {\n\t\t\tif (c->session->curw->window == w)\n\t\t\t\tc->flags |= CLIENT_REDRAWBORDERS;\n\t\t\tif (session_has(c->session, w))\n\t\t\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\t}\n\n\t}\n}\n\nstatic enum cmd_retval\ncmd_select_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tconst struct cmd_entry\t*entry = cmd_get_entry(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct session\t\t*s = target->s;\n\tstruct window_pane\t*wp = target->wp, *activewp, *lastwp, *markedwp;\n\tstruct options\t\t*oo = wp->options;\n\tchar\t\t\t*title;\n\tconst char\t\t*style;\n\tstruct options_entry\t*o;\n\n\tif (entry == &cmd_last_pane_entry || args_has(args, 'l')) {\n\t\t/*\n\t\t * Check for no last pane found in case the other pane was\n\t\t * spawned without being visited (for example split-window -d).\n\t\t */\n\t\tlastwp = TAILQ_FIRST(&w->last_panes);\n\t\tif (lastwp == NULL && window_count_panes(w) == 2) {\n\t\t\tlastwp = TAILQ_PREV(w->active, window_panes, entry);\n\t\t\tif (lastwp == NULL)\n\t\t\t\tlastwp = TAILQ_NEXT(w->active, entry);\n\t\t}\n\t\tif (lastwp == NULL) {\n\t\t\tcmdq_error(item, \"no last pane\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (args_has(args, 'e')) {\n\t\t\tlastwp->flags &= ~PANE_INPUTOFF;\n\t\t\tserver_redraw_window_borders(lastwp->window);\n\t\t\tserver_status_window(lastwp->window);\n\t\t} else if (args_has(args, 'd')) {\n\t\t\tlastwp->flags |= PANE_INPUTOFF;\n\t\t\tserver_redraw_window_borders(lastwp->window);\n\t\t\tserver_status_window(lastwp->window);\n\t\t} else {\n\t\t\tif (window_push_zoom(w, 0, args_has(args, 'Z')))\n\t\t\t\tserver_redraw_window(w);\n\t\t\twindow_redraw_active_switch(w, lastwp);\n\t\t\tif (window_set_active_pane(w, lastwp, 1)) {\n\t\t\t\tcmd_find_from_winlink(current, wl, 0);\n\t\t\t\tcmd_select_pane_redraw(w);\n\t\t\t}\n\t\t\tif (window_pop_zoom(w))\n\t\t\t\tserver_redraw_window(w);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'm') || args_has(args, 'M')) {\n\t\tif (args_has(args, 'm') && !window_pane_visible(wp))\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (server_check_marked())\n\t\t\tlastwp = marked_pane.wp;\n\t\telse\n\t\t\tlastwp = NULL;\n\n\t\tif (args_has(args, 'M') || server_is_marked(s, wl, wp))\n\t\t\tserver_clear_marked();\n\t\telse\n\t\t\tserver_set_marked(s, wl, wp);\n\t\tmarkedwp = marked_pane.wp;\n\n\t\tif (lastwp != NULL) {\n\t\t\tlastwp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\t\t\tserver_redraw_window_borders(lastwp->window);\n\t\t\tserver_status_window(lastwp->window);\n\t\t}\n\t\tif (markedwp != NULL) {\n\t\t\tmarkedwp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\t\t\tserver_redraw_window_borders(markedwp->window);\n\t\t\tserver_status_window(markedwp->window);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tstyle = args_get(args, 'P');\n\tif (style != NULL) {\n\t\to = options_set_string(oo, \"window-style\", 0, \"%s\", style);\n\t\tif (o == NULL) {\n\t\t\tcmdq_error(item, \"bad style: %s\", style);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\toptions_set_string(oo, \"window-active-style\", 0, \"%s\", style);\n\t\twp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\t}\n\tif (args_has(args, 'g')) {\n\t\tcmdq_print(item, \"%s\", options_get_string(oo, \"window-style\"));\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'L')) {\n\t\twindow_push_zoom(w, 0, 1);\n\t\twp = window_pane_find_left(wp);\n\t\twindow_pop_zoom(w);\n\t} else if (args_has(args, 'R')) {\n\t\twindow_push_zoom(w, 0, 1);\n\t\twp = window_pane_find_right(wp);\n\t\twindow_pop_zoom(w);\n\t} else if (args_has(args, 'U')) {\n\t\twindow_push_zoom(w, 0, 1);\n\t\twp = window_pane_find_up(wp);\n\t\twindow_pop_zoom(w);\n\t} else if (args_has(args, 'D')) {\n\t\twindow_push_zoom(w, 0, 1);\n\t\twp = window_pane_find_down(wp);\n\t\twindow_pop_zoom(w);\n\t}\n\tif (wp == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (args_has(args, 'e')) {\n\t\twp->flags &= ~PANE_INPUTOFF;\n\t\tserver_redraw_window_borders(wp->window);\n\t\tserver_status_window(wp->window);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (args_has(args, 'd')) {\n\t\twp->flags |= PANE_INPUTOFF;\n\t\tserver_redraw_window_borders(wp->window);\n\t\tserver_status_window(wp->window);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'T')) {\n\t\ttitle = format_single_from_target(item, args_get(args, 'T'));\n\t\tif (screen_set_title(&wp->base, title)) {\n\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\tserver_status_window(wp->window);\n\t\t}\n\t\tfree(title);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (c != NULL && c->session != NULL && (c->flags & CLIENT_ACTIVEPANE))\n\t\tactivewp = server_client_get_pane(c);\n\telse\n\t\tactivewp = w->active;\n\tif (wp == activewp)\n\t\treturn (CMD_RETURN_NORMAL);\n\tif (window_push_zoom(w, 0, args_has(args, 'Z')))\n\t\tserver_redraw_window(w);\n\twindow_redraw_active_switch(w, wp);\n\tif (c != NULL && c->session != NULL && (c->flags & CLIENT_ACTIVEPANE))\n\t\tserver_client_set_pane(c, wp);\n\telse if (window_set_active_pane(w, wp, 1))\n\t\tcmd_find_from_winlink_pane(current, wl, wp, 0);\n\tcmdq_insert_hook(s, item, current, \"after-select-pane\");\n\tcmd_select_pane_redraw(w);\n\tif (window_pop_zoom(w))\n\t\tserver_redraw_window(w);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-select-window.c",
          "type": "blob",
          "size": 3.9326171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Select window by index.\n */\n\nstatic enum cmd_retval\tcmd_select_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_select_window_entry = {\n\t.name = \"select-window\",\n\t.alias = \"selectw\",\n\n\t.args = { \"lnpTt:\", 0, 0, NULL },\n\t.usage = \"[-lnpT] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_next_window_entry = {\n\t.name = \"next-window\",\n\t.alias = \"next\",\n\n\t.args = { \"at:\", 0, 0, NULL },\n\t.usage = \"[-a] \" CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_previous_window_entry = {\n\t.name = \"previous-window\",\n\t.alias = \"prev\",\n\n\t.args = { \"at:\", 0, 0, NULL },\n\t.usage = \"[-a] \" CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_last_window_entry = {\n\t.name = \"last-window\",\n\t.alias = \"last\",\n\n\t.args = { \"t:\", 0, 0, NULL },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.target = { 't', CMD_FIND_SESSION, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nstatic enum cmd_retval\ncmd_select_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct session\t\t*s = target->s;\n\tint\t\t\t next, previous, last, activity;\n\n\tnext = (cmd_get_entry(self) == &cmd_next_window_entry);\n\tif (args_has(args, 'n'))\n\t\tnext = 1;\n\tprevious = (cmd_get_entry(self) == &cmd_previous_window_entry);\n\tif (args_has(args, 'p'))\n\t\tprevious = 1;\n\tlast = (cmd_get_entry(self) == &cmd_last_window_entry);\n\tif (args_has(args, 'l'))\n\t\tlast = 1;\n\n\tif (next || previous || last) {\n\t\tactivity = args_has(args, 'a');\n\t\tif (next) {\n\t\t\tif (session_next(s, activity) != 0) {\n\t\t\t\tcmdq_error(item, \"no next window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t} else if (previous) {\n\t\t\tif (session_previous(s, activity) != 0) {\n\t\t\t\tcmdq_error(item, \"no previous window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t} else {\n\t\t\tif (session_last(s) != 0) {\n\t\t\t\tcmdq_error(item, \"no last window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t}\n\t\tcmd_find_from_session(current, s, 0);\n\t\tserver_redraw_session(s);\n\t\tcmdq_insert_hook(s, item, current, \"after-select-window\");\n\t} else {\n\t\t/*\n\t\t * If -T and select-window is invoked on same window as\n\t\t * current, switch to previous window.\n\t\t */\n\t\tif (args_has(args, 'T') && wl == s->curw) {\n\t\t\tif (session_last(s) != 0) {\n\t\t\t\tcmdq_error(item, \"no last window\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (current->s == s)\n\t\t\t\tcmd_find_from_session(current, s, 0);\n\t\t\tserver_redraw_session(s);\n\t\t} else if (session_select(s, wl->idx) == 0) {\n\t\t\tcmd_find_from_session(current, s, 0);\n\t\t\tserver_redraw_session(s);\n\t\t}\n\t\tcmdq_insert_hook(s, item, current, \"after-select-window\");\n\t}\n\tif (c != NULL && c->session != NULL)\n\t\ts->curw->window->latest = c;\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-send-keys.c",
          "type": "blob",
          "size": 6.2060546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Send keys to client.\n */\n\nstatic enum cmd_retval\tcmd_send_keys_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_send_keys_entry = {\n\t.name = \"send-keys\",\n\t.alias = \"send\",\n\n\t.args = { \"c:FHKlMN:Rt:X\", 0, -1, NULL },\n\t.usage = \"[-FHKlMRX] [-c target-client] [-N repeat-count] \"\n\t         CMD_TARGET_PANE_USAGE \" key ...\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_CFLAG|CMD_CLIENT_CANFAIL,\n\t.exec = cmd_send_keys_exec\n};\n\nconst struct cmd_entry cmd_send_prefix_entry = {\n\t.name = \"send-prefix\",\n\t.alias = NULL,\n\n\t.args = { \"2t:\", 0, 0, NULL },\n\t.usage = \"[-2] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_send_keys_exec\n};\n\nstatic struct cmdq_item *\ncmd_send_keys_inject_key(struct cmdq_item *item, struct cmdq_item *after,\n    struct args *args, key_code key)\n{\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t\t*s = target->s;\n\tstruct winlink\t\t\t*wl = target->wl;\n\tstruct window_pane\t\t*wp = target->wp;\n\tstruct window_mode_entry\t*wme;\n\tstruct key_table\t\t*table = NULL;\n\tstruct key_binding\t\t*bd;\n\tstruct key_event\t\t*event;\n\n\tif (args_has(args, 'K')) {\n\t\tif (tc == NULL)\n\t\t\treturn (item);\n\t\tevent = xcalloc(1, sizeof *event);\n\t\tevent->key = key|KEYC_SENT;\n\t\tmemset(&event->m, 0, sizeof event->m);\n\t\tif (server_client_handle_key(tc, event) == 0) {\n\t\t\tfree(event->buf);\n\t\t\tfree(event);\n\t\t}\n\t\treturn (item);\n\t}\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->mode->key_table == NULL) {\n\t\tif (window_pane_key(wp, tc, s, wl, key, NULL) != 0)\n\t\t\treturn (NULL);\n\t\treturn (item);\n\t}\n\ttable = key_bindings_get_table(wme->mode->key_table(wme), 1);\n\n\tbd = key_bindings_get(table, key & ~KEYC_MASK_FLAGS);\n\tif (bd != NULL) {\n\t\ttable->references++;\n\t\tafter = key_bindings_dispatch(bd, after, tc, NULL, target);\n\t\tkey_bindings_unref_table(table);\n\t}\n\treturn (after);\n}\n\nstatic struct cmdq_item *\ncmd_send_keys_inject_string(struct cmdq_item *item, struct cmdq_item *after,\n    struct args *args, int i)\n{\n\tconst char\t\t*s = args_string(args, i);\n\tstruct utf8_data\t*ud, *loop;\n\tutf8_char\t\t uc;\n\tkey_code\t\t key;\n\tchar\t\t\t*endptr;\n\tlong\t\t\t n;\n\tint\t\t\t literal;\n\n\tif (args_has(args, 'H')) {\n\t\tn = strtol(s, &endptr, 16);\n\t\tif (*s =='\\0' || n < 0 || n > 0xff || *endptr != '\\0')\n\t\t\treturn (item);\n\t\treturn (cmd_send_keys_inject_key(item, after, args,\n\t\t    KEYC_LITERAL|n));\n\t}\n\n\tliteral = args_has(args, 'l');\n\tif (!literal) {\n\t\tkey = key_string_lookup_string(s);\n\t\tif (key != KEYC_NONE && key != KEYC_UNKNOWN) {\n\t\t\tafter = cmd_send_keys_inject_key(item, after, args,\n\t\t\t    key);\n\t\t\tif (after != NULL)\n\t\t\t\treturn (after);\n\t\t}\n\t\tliteral = 1;\n\t}\n\tif (literal) {\n\t\tud = utf8_fromcstr(s);\n\t\tfor (loop = ud; loop->size != 0; loop++) {\n\t\t\tif (loop->size == 1 && loop->data[0] <= 0x7f)\n\t\t\t\tkey = loop->data[0];\n\t\t\telse {\n\t\t\t\tif (utf8_from_data(loop, &uc) != UTF8_DONE)\n\t\t\t\t\tcontinue;\n\t\t\t\tkey = uc;\n\t\t\t}\n\t\t\tafter = cmd_send_keys_inject_key(item, after, args,\n\t\t\t    key);\n\t\t}\n\t\tfree(ud);\n\t}\n\treturn (after);\n}\n\nstatic enum cmd_retval\ncmd_send_keys_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct client\t\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t\t*s = target->s;\n\tstruct winlink\t\t\t*wl = target->wl;\n\tstruct window_pane\t\t*wp = target->wp;\n\tstruct key_event\t\t*event = cmdq_get_event(item);\n\tstruct mouse_event\t\t*m = &event->m;\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct cmdq_item\t\t*after = item;\n\tkey_code\t\t\t key;\n\tu_int\t\t\t\t i, np = 1;\n\tu_int\t\t\t\t count = args_count(args);\n\tchar\t\t\t\t*cause = NULL;\n\n\tif (args_has(args, 'N')) {\n\t\tnp = args_strtonum_and_expand(args, 'N', 1, UINT_MAX, item,\n\t\t\t &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(item, \"repeat count %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (wme != NULL && (args_has(args, 'X') || count == 0)) {\n\t\t\tif (wme->mode->command == NULL) {\n\t\t\t\tcmdq_error(item, \"not in a mode\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\twme->prefix = np;\n\t\t}\n\t}\n\n\tif (args_has(args, 'X')) {\n\t\tif (wme == NULL || wme->mode->command == NULL) {\n\t\t\tcmdq_error(item, \"not in a mode\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (!m->valid)\n\t\t\tm = NULL;\n\t\twme->mode->command(wme, tc, s, wl, args, m);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'M')) {\n\t\twp = cmd_mouse_pane(m, &s, NULL);\n\t\tif (wp == NULL) {\n\t\t\tcmdq_error(item, \"no mouse target\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\twindow_pane_key(wp, tc, s, wl, m->key, m);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (cmd_get_entry(self) == &cmd_send_prefix_entry) {\n\t\tif (args_has(args, '2'))\n\t\t\tkey = options_get_number(s->options, \"prefix2\");\n\t\telse\n\t\t\tkey = options_get_number(s->options, \"prefix\");\n\t\tcmd_send_keys_inject_key(item, item, args, key);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'R')) {\n\t\tcolour_palette_clear(&wp->palette);\n\t\tinput_reset(wp->ictx, 1);\n\t\twp->flags |= (PANE_STYLECHANGED|PANE_REDRAW);\n\t}\n\n\tif (count == 0) {\n\t\tif (args_has(args, 'N') || args_has(args, 'R'))\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tfor (; np != 0; np--)\n\t\t\tcmd_send_keys_inject_key(item, NULL, args, event->key);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tfor (; np != 0; np--) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tafter = cmd_send_keys_inject_string(item, after, args,\n\t\t\t    i);\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-server-access.c",
          "type": "blob",
          "size": 3.9912109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2021 Dallas Lyons <dallasdlyons@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Controls access to session.\n */\n\nstatic enum cmd_retval cmd_server_access_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_server_access_entry = {\n\t.name = \"server-access\",\n\t.alias = NULL,\n\n\t.args = { \"adlrw\", 0, 1, NULL },\n\t.usage = \"[-adlrw] \" CMD_TARGET_PANE_USAGE \" [user]\",\n\n\t.flags = CMD_CLIENT_CANFAIL,\n\t.exec = cmd_server_access_exec\n};\n\nstatic enum cmd_retval\ncmd_server_access_deny(struct cmdq_item *item, struct passwd *pw)\n{\n\tstruct client\t\t*loop;\n\tstruct server_acl_user\t*user;\n\tuid_t\t\t\t uid;\n\n\tif ((user = server_acl_user_find(pw->pw_uid)) == NULL) {\n\t\tcmdq_error(item, \"user %s not found\", pw->pw_name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tuid = proc_get_peer_uid(loop->peer);\n\t\tif (uid == server_acl_get_uid(user)) {\n\t\t\tloop->exit_message = xstrdup(\"access not allowed\");\n\t\t\tloop->flags |= CLIENT_EXIT;\n\t\t}\n\t}\n\tserver_acl_user_deny(pw->pw_uid);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncmd_server_access_exec(struct cmd *self, struct cmdq_item *item)\n{\n\n\tstruct args\t*args = cmd_get_args(self);\n\tstruct client\t*c = cmdq_get_target_client(item);\n\tchar\t\t*name;\n\tstruct passwd\t*pw = NULL;\n\n\tif (args_has(args, 'l')) {\n\t\tserver_acl_display(item);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (args_count(args) == 0) {\n\t\tcmdq_error(item, \"missing user argument\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tname = format_single(item, args_string(args, 0), c, NULL, NULL, NULL);\n\tif (*name != '\\0')\n\t\tpw = getpwnam(name);\n\tif (pw == NULL) {\n\t\tcmdq_error(item, \"unknown user: %s\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tfree(name);\n\n\tif (pw->pw_uid == 0 || pw->pw_uid == getuid()) {\n\t\tcmdq_error(item, \"%s owns the server, can't change access\",\n\t\t    pw->pw_name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'a') && args_has(args, 'd')) {\n\t\tcmdq_error(item, \"-a and -d cannot be used together\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (args_has(args, 'w') && args_has(args, 'r')) {\n\t\tcmdq_error(item, \"-r and -w cannot be used together\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'd'))\n\t\treturn (cmd_server_access_deny(item, pw));\n\tif (args_has(args, 'a')) {\n\t\tif (server_acl_user_find(pw->pw_uid) != NULL) {\n\t\t\tcmdq_error(item, \"user %s is already added\",\n\t\t\t    pw->pw_name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tserver_acl_user_allow(pw->pw_uid);\n\t\t/* Do not return - allow -r or -w with -a. */\n\t} else if (args_has(args, 'r') || args_has(args, 'w')) {\n\t\t/* -r or -w implies -a if user does not exist. */\n\t\tif (server_acl_user_find(pw->pw_uid) == NULL)\n\t\t\tserver_acl_user_allow(pw->pw_uid);\n\t}\n\n\tif (args_has(args, 'w')) {\n\t\tif (server_acl_user_find(pw->pw_uid) == NULL) {\n\t\t\tcmdq_error(item, \"user %s not found\", pw->pw_name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tserver_acl_user_allow_write(pw->pw_uid);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'r')) {\n\t\tif (server_acl_user_find(pw->pw_uid) == NULL) {\n\t\t\tcmdq_error(item, \"user %s not found\", pw->pw_name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tserver_acl_user_deny_write(pw->pw_uid);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-buffer.c",
          "type": "blob",
          "size": 3.5361328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Add, set, append to or delete a paste buffer.\n */\n\nstatic enum cmd_retval\tcmd_set_buffer_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_set_buffer_entry = {\n\t.name = \"set-buffer\",\n\t.alias = \"setb\",\n\n\t.args = { \"ab:t:n:w\", 0, 1, NULL },\n\t.usage = \"[-aw] \" CMD_BUFFER_USAGE \" [-n new-buffer-name] \"\n\t         CMD_TARGET_CLIENT_USAGE \" data\",\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG|CMD_CLIENT_CANFAIL,\n\t.exec = cmd_set_buffer_exec\n};\n\nconst struct cmd_entry cmd_delete_buffer_entry = {\n\t.name = \"delete-buffer\",\n\t.alias = \"deleteb\",\n\n\t.args = { \"b:\", 0, 0, NULL },\n\t.usage = CMD_BUFFER_USAGE,\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_set_buffer_exec\n};\n\nstatic enum cmd_retval\ncmd_set_buffer_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct paste_buffer\t*pb;\n\tchar\t\t\t*bufdata, *cause;\n\tconst char\t\t*bufname, *olddata;\n\tsize_t\t\t\t bufsize, newsize;\n\n\tbufname = args_get(args, 'b');\n\tif (bufname == NULL)\n\t\tpb = NULL;\n\telse\n\t\tpb = paste_get_name(bufname);\n\n\tif (cmd_get_entry(self) == &cmd_delete_buffer_entry) {\n\t\tif (pb == NULL) {\n\t\t\tif (bufname != NULL) {\n\t\t\t\tcmdq_error(item, \"unknown buffer: %s\", bufname);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\tpb = paste_get_top(&bufname);\n\t\t}\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(item, \"no buffer\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tpaste_free(pb);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'n')) {\n\t\tif (pb == NULL) {\n\t\t\tif (bufname != NULL) {\n\t\t\t\tcmdq_error(item, \"unknown buffer: %s\", bufname);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\tpb = paste_get_top(&bufname);\n\t\t}\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(item, \"no buffer\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (paste_rename(bufname, args_get(args, 'n'), &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_count(args) != 1) {\n\t\tcmdq_error(item, \"no data specified\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif ((newsize = strlen(args_string(args, 0))) == 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tbufsize = 0;\n\tbufdata = NULL;\n\n\tif (args_has(args, 'a') && pb != NULL) {\n\t\tolddata = paste_buffer_data(pb, &bufsize);\n\t\tbufdata = xmalloc(bufsize);\n\t\tmemcpy(bufdata, olddata, bufsize);\n\t}\n\n\tbufdata = xrealloc(bufdata, bufsize + newsize);\n\tmemcpy(bufdata + bufsize, args_string(args, 0), newsize);\n\tbufsize += newsize;\n\n\tif (paste_set(bufdata, bufsize, bufname, &cause) != 0) {\n\t\tcmdq_error(item, \"%s\", cause);\n\t\tfree(bufdata);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (args_has(args, 'w') && tc != NULL)\n \t\ttty_set_selection(&tc->tty, \"\", bufdata, bufsize);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-environment.c",
          "type": "blob",
          "size": 3.0595703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set an environment variable.\n */\n\nstatic enum cmd_retval\tcmd_set_environment_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_set_environment_entry = {\n\t.name = \"set-environment\",\n\t.alias = \"setenv\",\n\n\t.args = { \"Fhgrt:u\", 1, 2, NULL },\n\t.usage = \"[-Fhgru] \" CMD_TARGET_SESSION_USAGE \" name [value]\",\n\n\t.target = { 't', CMD_FIND_SESSION, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_set_environment_exec\n};\n\nstatic enum cmd_retval\ncmd_set_environment_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct environ\t\t*env;\n\tconst char\t\t*name = args_string(args, 0), *value;\n\tconst char\t\t*tflag;\n\tchar\t\t\t*expanded = NULL;\n\tenum cmd_retval\t\t retval = CMD_RETURN_NORMAL;\n\n\tif (*name == '\\0') {\n\t\tcmdq_error(item, \"empty variable name\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (strchr(name, '=') != NULL) {\n\t\tcmdq_error(item, \"variable name contains =\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_count(args) < 2)\n\t\tvalue = NULL;\n\telse\n\t\tvalue = args_string(args, 1);\n\tif (value != NULL && args_has(args, 'F')) {\n\t\texpanded = format_single_from_target(item, value);\n\t\tvalue = expanded;\n\t}\n\tif (args_has(args, 'g'))\n\t\tenv = global_environ;\n\telse {\n\t\tif (target->s == NULL) {\n\t\t\ttflag = args_get(args, 't');\n\t\t\tif (tflag != NULL)\n\t\t\t\tcmdq_error(item, \"no such session: %s\", tflag);\n\t\t\telse\n\t\t\t\tcmdq_error(item, \"no current session\");\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tenv = target->s->environ;\n\t}\n\n\tif (args_has(args, 'u')) {\n\t\tif (value != NULL) {\n\t\t\tcmdq_error(item, \"can't specify a value with -u\");\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tenviron_unset(env, name);\n\t} else if (args_has(args, 'r')) {\n\t\tif (value != NULL) {\n\t\t\tcmdq_error(item, \"can't specify a value with -r\");\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tenviron_clear(env, name);\n\t} else {\n\t\tif (value == NULL) {\n\t\t\tcmdq_error(item, \"no value specified\");\n\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (args_has(args, 'h'))\n\t\t\tenviron_set(env, name, ENVIRON_HIDDEN, \"%s\", value);\n\t\telse\n\t\t\tenviron_set(env, name, 0, \"%s\", value);\n\t}\n\nout:\n\tfree(expanded);\n\treturn (retval);\n}\n"
        },
        {
          "name": "cmd-set-option.c",
          "type": "blob",
          "size": 6.1181640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set an option.\n */\n\nstatic enum args_parse_type\tcmd_set_option_args_parse(struct args *,\n\t\t\t\t    u_int, char **);\nstatic enum cmd_retval\t\tcmd_set_option_exec(struct cmd *,\n\t\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_set_option_entry = {\n\t.name = \"set-option\",\n\t.alias = \"set\",\n\n\t.args = { \"aFgopqst:uUw\", 1, 2, cmd_set_option_args_parse },\n\t.usage = \"[-aFgopqsuUw] \" CMD_TARGET_PANE_USAGE \" option [value]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_set_option_exec\n};\n\nconst struct cmd_entry cmd_set_window_option_entry = {\n\t.name = \"set-window-option\",\n\t.alias = \"setw\",\n\n\t.args = { \"aFgoqt:u\", 1, 2, cmd_set_option_args_parse },\n\t.usage = \"[-aFgoqu] \" CMD_TARGET_WINDOW_USAGE \" option [value]\",\n\n\t.target = { 't', CMD_FIND_WINDOW, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_set_option_exec\n};\n\nconst struct cmd_entry cmd_set_hook_entry = {\n\t.name = \"set-hook\",\n\t.alias = NULL,\n\n\t.args = { \"agpRt:uw\", 1, 2, cmd_set_option_args_parse },\n\t.usage = \"[-agpRuw] \" CMD_TARGET_PANE_USAGE \" hook [command]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_set_option_exec\n};\n\nstatic enum args_parse_type\ncmd_set_option_args_parse(__unused struct args *args, u_int idx,\n    __unused char **cause)\n{\n\tif (idx == 1)\n\t\treturn (ARGS_PARSE_COMMANDS_OR_STRING);\n\treturn (ARGS_PARSE_STRING);\n}\n\nstatic enum cmd_retval\ncmd_set_option_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tint\t\t\t\t append = args_has(args, 'a');\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct window_pane\t\t*loop;\n\tstruct options\t\t\t*oo;\n\tstruct options_entry\t\t*parent, *o, *po;\n\tchar\t\t\t\t*name, *argument, *expanded = NULL;\n\tchar\t\t\t\t*cause;\n\tconst char\t\t\t*value;\n\tint\t\t\t\t window, idx, already, error, ambiguous;\n\tint\t\t\t\t scope;\n\n\twindow = (cmd_get_entry(self) == &cmd_set_window_option_entry);\n\n\t/* Expand argument. */\n\targument = format_single_from_target(item, args_string(args, 0));\n\n\t/* If set-hook -R, fire the hook straight away. */\n\tif (cmd_get_entry(self) == &cmd_set_hook_entry && args_has(args, 'R')) {\n\t\tnotify_hook(item, argument);\n\t\tfree(argument);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\t/* Parse option name and index. */\n\tname = options_match(argument, &idx, &ambiguous);\n\tif (name == NULL) {\n\t\tif (args_has(args, 'q'))\n\t\t\tgoto out;\n\t\tif (ambiguous)\n\t\t\tcmdq_error(item, \"ambiguous option: %s\", argument);\n\t\telse\n\t\t\tcmdq_error(item, \"invalid option: %s\", argument);\n\t\tgoto fail;\n\t}\n\tif (args_count(args) < 2)\n\t\tvalue = NULL;\n\telse\n\t\tvalue = args_string(args, 1);\n\tif (value != NULL && args_has(args, 'F')) {\n\t\texpanded = format_single_from_target(item, value);\n\t\tvalue = expanded;\n\t}\n\n\t/* Get the scope and table for the option .*/\n\tscope = options_scope_from_name(args, window, name, target, &oo,\n\t    &cause);\n\tif (scope == OPTIONS_TABLE_NONE) {\n\t\tif (args_has(args, 'q'))\n\t\t\tgoto out;\n\t\tcmdq_error(item, \"%s\", cause);\n\t\tfree(cause);\n\t\tgoto fail;\n\t}\n\to = options_get_only(oo, name);\n\tparent = options_get(oo, name);\n\n\t/* Check that array options and indexes match up. */\n\tif (idx != -1 && (*name == '@' || !options_is_array(parent))) {\n\t\tcmdq_error(item, \"not an array: %s\", argument);\n\t\tgoto fail;\n\t}\n\n\t/* With -o, check this option is not already set. */\n\tif (!args_has(args, 'u') && args_has(args, 'o')) {\n\t\tif (idx == -1)\n\t\t\talready = (o != NULL);\n\t\telse {\n\t\t\tif (o == NULL)\n\t\t\t\talready = 0;\n\t\t\telse\n\t\t\t\talready = (options_array_get(o, idx) != NULL);\n\t\t}\n\t\tif (already) {\n\t\t\tif (args_has(args, 'q'))\n\t\t\t\tgoto out;\n\t\t\tcmdq_error(item, \"already set: %s\", argument);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* Change the option. */\n\tif (args_has(args, 'U') && scope == OPTIONS_TABLE_WINDOW) {\n\t\tTAILQ_FOREACH(loop, &target->w->panes, entry) {\n\t\t\tpo = options_get_only(loop->options, name);\n\t\t\tif (po == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (options_remove_or_default(po, idx, &cause) != 0) {\n\t\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\t\tfree(cause);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\tif (args_has(args, 'u') || args_has(args, 'U')) {\n\t\tif (o == NULL)\n\t\t\tgoto out;\n\t\tif (options_remove_or_default(o, idx, &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tgoto fail;\n\t\t}\n\t} else if (*name == '@') {\n\t\tif (value == NULL) {\n\t\t\tcmdq_error(item, \"empty value\");\n\t\t\tgoto fail;\n\t\t}\n\t\toptions_set_string(oo, name, append, \"%s\", value);\n\t} else if (idx == -1 && !options_is_array(parent)) {\n\t\terror = options_from_string(oo, options_table_entry(parent),\n\t\t    options_table_entry(parent)->name, value,\n\t\t    args_has(args, 'a'), &cause);\n\t\tif (error != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tif (value == NULL) {\n\t\t\tcmdq_error(item, \"empty value\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (o == NULL)\n\t\t\to = options_empty(oo, options_table_entry(parent));\n\t\tif (idx == -1) {\n\t\t\tif (!append)\n\t\t\t\toptions_array_clear(o);\n\t\t\tif (options_array_assign(o, value, &cause) != 0) {\n\t\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\t\tfree(cause);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if (options_array_set(o, idx, value, append,\n\t\t    &cause) != 0) {\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\toptions_push_changes(name);\n\nout:\n\tfree(argument);\n\tfree(expanded);\n\tfree(name);\n\treturn (CMD_RETURN_NORMAL);\n\nfail:\n\tfree(argument);\n\tfree(expanded);\n\tfree(name);\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-show-environment.c",
          "type": "blob",
          "size": 3.7880859375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Show environment.\n */\n\nstatic enum cmd_retval\tcmd_show_environment_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nstatic char\t*cmd_show_environment_escape(struct environ_entry *);\nstatic void\t cmd_show_environment_print(struct cmd *, struct cmdq_item *,\n\t\t     struct environ_entry *);\n\nconst struct cmd_entry cmd_show_environment_entry = {\n\t.name = \"show-environment\",\n\t.alias = \"showenv\",\n\n\t.args = { \"hgst:\", 0, 1, NULL },\n\t.usage = \"[-hgs] \" CMD_TARGET_SESSION_USAGE \" [name]\",\n\n\t.target = { 't', CMD_FIND_SESSION, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_environment_exec\n};\n\nstatic char *\ncmd_show_environment_escape(struct environ_entry *envent)\n{\n\tconst char\t*value = envent->value;\n\tchar\t\t c, *out, *ret;\n\n\tout = ret = xmalloc(strlen(value) * 2 + 1); /* at most twice the size */\n\twhile ((c = *value++) != '\\0') {\n\t\t/* POSIX interprets $ ` \" and \\ in double quotes. */\n\t\tif (c == '$' || c == '`' || c == '\"' || c == '\\\\')\n\t\t\t*out++ = '\\\\';\n\t\t*out++ = c;\n\t}\n\t*out = '\\0';\n\n\treturn (ret);\n}\n\nstatic void\ncmd_show_environment_print(struct cmd *self, struct cmdq_item *item,\n    struct environ_entry *envent)\n{\n\tstruct args\t*args = cmd_get_args(self);\n\tchar\t\t*escaped;\n\n\tif (!args_has(args, 'h') && (envent->flags & ENVIRON_HIDDEN))\n\t\treturn;\n\tif (args_has(args, 'h') && (~envent->flags & ENVIRON_HIDDEN))\n\t\treturn;\n\n\tif (!args_has(args, 's')) {\n\t\tif (envent->value != NULL)\n\t\t\tcmdq_print(item, \"%s=%s\", envent->name, envent->value);\n\t\telse\n\t\t\tcmdq_print(item, \"-%s\", envent->name);\n\t\treturn;\n\t}\n\n\tif (envent->value != NULL) {\n\t\tescaped = cmd_show_environment_escape(envent);\n\t\tcmdq_print(item, \"%s=\\\"%s\\\"; export %s;\", envent->name, escaped,\n\t\t    envent->name);\n\t\tfree(escaped);\n\t} else\n\t\tcmdq_print(item, \"unset %s;\", envent->name);\n}\n\nstatic enum cmd_retval\ncmd_show_environment_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct environ\t\t*env;\n\tstruct environ_entry\t*envent;\n\tconst char\t\t*tflag, *name = args_string(args, 0);\n\n\tif ((tflag = args_get(args, 't')) != NULL) {\n\t\tif (target->s == NULL) {\n\t\t\tcmdq_error(item, \"no such session: %s\", tflag);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(args, 'g'))\n\t\tenv = global_environ;\n\telse {\n\t\tif (target->s == NULL) {\n\t\t\ttflag = args_get(args, 't');\n\t\t\tif (tflag != NULL)\n\t\t\t\tcmdq_error(item, \"no such session: %s\", tflag);\n\t\t\telse\n\t\t\t\tcmdq_error(item, \"no current session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenv = target->s->environ;\n\t}\n\n\tif (name != NULL) {\n\t\tenvent = environ_find(env, name);\n\t\tif (envent == NULL) {\n\t\t\tcmdq_error(item, \"unknown variable: %s\", name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcmd_show_environment_print(self, item, envent);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tenvent = environ_first(env);\n\twhile (envent != NULL) {\n\t\tcmd_show_environment_print(self, item, envent);\n\t\tenvent = environ_next(envent);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-show-messages.c",
          "type": "blob",
          "size": 2.8271484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Show message log.\n */\n\n#define SHOW_MESSAGES_TEMPLATE \\\n\t\"#{t/p:message_time}: #{message_text}\"\n\nstatic enum cmd_retval\tcmd_show_messages_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_show_messages_entry = {\n\t.name = \"show-messages\",\n\t.alias = \"showmsgs\",\n\n\t.args = { \"JTt:\", 0, 0, NULL },\n\t.usage = \"[-JT] \" CMD_TARGET_CLIENT_USAGE,\n\n\t.flags = CMD_AFTERHOOK|CMD_CLIENT_TFLAG,\n\t.exec = cmd_show_messages_exec\n};\n\nstatic int\ncmd_show_messages_terminals(struct cmd *self, struct cmdq_item *item, int blank)\n{\n\tstruct args\t*args = cmd_get_args(self);\n\tstruct client\t*tc = cmdq_get_target_client(item);\n\tstruct tty_term\t*term;\n\tu_int\t\t i, n;\n\n\tn = 0;\n\tLIST_FOREACH(term, &tty_terms, entry) {\n\t\tif (args_has(args, 't') && term != tc->tty.term)\n\t\t\tcontinue;\n\t\tif (blank) {\n\t\t\tcmdq_print(item, \"%s\", \"\");\n\t\t\tblank = 0;\n\t\t}\n\t\tcmdq_print(item, \"Terminal %u: %s for %s, flags=0x%x:\", n,\n\t\t    term->name, term->tty->client->name, term->flags);\n\t\tn++;\n\t\tfor (i = 0; i < tty_term_ncodes(); i++)\n\t\t\tcmdq_print(item, \"%s\", tty_term_describe(term, i));\n\t}\n\treturn (n != 0);\n}\n\nstatic enum cmd_retval\ncmd_show_messages_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct message_entry\t*msg;\n\tchar\t\t\t*s;\n\tint\t\t\t done, blank;\n\tstruct format_tree\t*ft;\n\n\tdone = blank = 0;\n\tif (args_has(args, 'T')) {\n\t\tblank = cmd_show_messages_terminals(self, item, blank);\n\t\tdone = 1;\n\t}\n\tif (args_has(args, 'J')) {\n\t\tjob_print_summary(item, blank);\n\t\tdone = 1;\n\t}\n\tif (done)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tft = format_create_from_target(item);\n\tTAILQ_FOREACH_REVERSE(msg, &message_log, message_list, entry) {\n\t\tformat_add(ft, \"message_text\", \"%s\", msg->msg);\n\t\tformat_add(ft, \"message_number\", \"%u\", msg->msg_num);\n\t\tformat_add_tv(ft, \"message_time\", &msg->msg_time);\n\n\t\ts = format_expand(ft, SHOW_MESSAGES_TEMPLATE);\n\t\tcmdq_print(item, \"%s\", s);\n\t\tfree(s);\n\t}\n\tformat_free(ft);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-show-options.c",
          "type": "blob",
          "size": 6.5009765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Show options.\n */\n\nstatic enum cmd_retval\tcmd_show_options_exec(struct cmd *, struct cmdq_item *);\n\nstatic void\t\tcmd_show_options_print(struct cmd *, struct cmdq_item *,\n\t\t\t    struct options_entry *, int, int);\nstatic enum cmd_retval\tcmd_show_options_all(struct cmd *, struct cmdq_item *,\n\t\t\t    int, struct options *);\n\nconst struct cmd_entry cmd_show_options_entry = {\n\t.name = \"show-options\",\n\t.alias = \"show\",\n\n\t.args = { \"AgHpqst:vw\", 0, 1, NULL },\n\t.usage = \"[-AgHpqsvw] \" CMD_TARGET_PANE_USAGE \" [option]\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_options_exec\n};\n\nconst struct cmd_entry cmd_show_window_options_entry = {\n\t.name = \"show-window-options\",\n\t.alias = \"showw\",\n\n\t.args = { \"gvt:\", 0, 1, NULL },\n\t.usage = \"[-gv] \" CMD_TARGET_WINDOW_USAGE \" [option]\",\n\n\t.target = { 't', CMD_FIND_WINDOW, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_options_exec\n};\n\nconst struct cmd_entry cmd_show_hooks_entry = {\n\t.name = \"show-hooks\",\n\t.alias = NULL,\n\n\t.args = { \"gpt:w\", 0, 1, NULL },\n\t.usage = \"[-gpw] \" CMD_TARGET_PANE_USAGE,\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_options_exec\n};\n\nstatic enum cmd_retval\ncmd_show_options_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\tstruct options\t\t\t*oo;\n\tchar\t\t\t\t*argument, *name = NULL, *cause;\n\tint\t\t\t\t window, idx, ambiguous, parent, scope;\n\tstruct options_entry\t\t*o;\n\n\twindow = (cmd_get_entry(self) == &cmd_show_window_options_entry);\n\n\tif (args_count(args) == 0) {\n\t\tscope = options_scope_from_flags(args, window, target, &oo,\n\t\t    &cause);\n\t\tif (scope == OPTIONS_TABLE_NONE) {\n\t\t\tif (args_has(args, 'q'))\n\t\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (cmd_show_options_all(self, item, scope, oo));\n\t}\n\targument = format_single_from_target(item, args_string(args, 0));\n\n\tname = options_match(argument, &idx, &ambiguous);\n\tif (name == NULL) {\n\t\tif (args_has(args, 'q'))\n\t\t\tgoto out;\n\t\tif (ambiguous)\n\t\t\tcmdq_error(item, \"ambiguous option: %s\", argument);\n\t\telse\n\t\t\tcmdq_error(item, \"invalid option: %s\", argument);\n\t\tgoto fail;\n\t}\n\tscope = options_scope_from_name(args, window, name, target, &oo,\n\t    &cause);\n\tif (scope == OPTIONS_TABLE_NONE) {\n\t\tif (args_has(args, 'q'))\n\t\t\tgoto out;\n\t\tcmdq_error(item, \"%s\", cause);\n\t\tfree(cause);\n\t\tgoto fail;\n\t}\n\to = options_get_only(oo, name);\n\tif (args_has(args, 'A') && o == NULL) {\n\t\to = options_get(oo, name);\n\t\tparent = 1;\n\t} else\n\t\tparent = 0;\n\tif (o != NULL)\n\t\tcmd_show_options_print(self, item, o, idx, parent);\n\telse if (*name == '@') {\n\t\tif (args_has(args, 'q'))\n\t\t\tgoto out;\n\t\tcmdq_error(item, \"invalid option: %s\", argument);\n\t\tgoto fail;\n\t}\n\nout:\n\tfree(name);\n\tfree(argument);\n\treturn (CMD_RETURN_NORMAL);\n\nfail:\n\tfree(name);\n\tfree(argument);\n\treturn (CMD_RETURN_ERROR);\n}\n\nstatic void\ncmd_show_options_print(struct cmd *self, struct cmdq_item *item,\n    struct options_entry *o, int idx, int parent)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct options_array_item\t*a;\n\tconst char\t\t\t*name = options_name(o);\n\tchar\t\t\t\t*value, *tmp = NULL, *escaped;\n\n\tif (idx != -1) {\n\t\txasprintf(&tmp, \"%s[%d]\", name, idx);\n\t\tname = tmp;\n\t} else {\n\t\tif (options_is_array(o)) {\n\t\t\ta = options_array_first(o);\n\t\t\tif (a == NULL) {\n\t\t\t\tif (!args_has(args, 'v'))\n\t\t\t\t\tcmdq_print(item, \"%s\", name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (a != NULL) {\n\t\t\t\tidx = options_array_item_index(a);\n\t\t\t\tcmd_show_options_print(self, item, o, idx,\n\t\t\t\t    parent);\n\t\t\t\ta = options_array_next(a);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvalue = options_to_string(o, idx, 0);\n\tif (args_has(args, 'v'))\n\t\tcmdq_print(item, \"%s\", value);\n\telse if (options_is_string(o)) {\n\t\tescaped = args_escape(value);\n\t\tif (parent)\n\t\t\tcmdq_print(item, \"%s* %s\", name, escaped);\n\t\telse\n\t\t\tcmdq_print(item, \"%s %s\", name, escaped);\n\t\tfree(escaped);\n\t} else {\n\t\tif (parent)\n\t\t\tcmdq_print(item, \"%s* %s\", name, value);\n\t\telse\n\t\t\tcmdq_print(item, \"%s %s\", name, value);\n\t}\n\tfree(value);\n\n\tfree(tmp);\n}\n\nstatic enum cmd_retval\ncmd_show_options_all(struct cmd *self, struct cmdq_item *item, int scope,\n    struct options *oo)\n{\n\tstruct args\t\t\t\t*args = cmd_get_args(self);\n\tconst struct options_table_entry\t*oe;\n\tstruct options_entry\t\t\t*o;\n\tstruct options_array_item\t\t*a;\n\tconst char\t\t\t\t*name;\n\tu_int\t\t\t\t\t idx;\n\tint\t\t\t\t\t parent;\n\n\tif (cmd_get_entry(self) != &cmd_show_hooks_entry) {\n\t\to = options_first(oo);\n\t\twhile (o != NULL) {\n\t\t\tif (options_table_entry(o) == NULL)\n\t\t\t\tcmd_show_options_print(self, item, o, -1, 0);\n\t\t\to = options_next(o);\n\t\t}\n\t}\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (~oe->scope & scope)\n\t\t\tcontinue;\n\n\t\tif ((cmd_get_entry(self) != &cmd_show_hooks_entry &&\n\t\t    !args_has(args, 'H') &&\n\t\t    (oe->flags & OPTIONS_TABLE_IS_HOOK)) ||\n\t\t    (cmd_get_entry(self) == &cmd_show_hooks_entry &&\n\t\t    (~oe->flags & OPTIONS_TABLE_IS_HOOK)))\n\t\t\tcontinue;\n\n\t\to = options_get_only(oo, oe->name);\n\t\tif (o == NULL) {\n\t\t\tif (!args_has(args, 'A'))\n\t\t\t\tcontinue;\n\t\t\to = options_get(oo, oe->name);\n\t\t\tif (o == NULL)\n\t\t\t\tcontinue;\n\t\t\tparent = 1;\n\t\t} else\n\t\t\tparent = 0;\n\n\t\tif (!options_is_array(o))\n\t\t\tcmd_show_options_print(self, item, o, -1, parent);\n\t\telse if ((a = options_array_first(o)) == NULL) {\n\t\t\tif (!args_has(args, 'v')) {\n\t\t\t\tname = options_name(o);\n\t\t\t\tif (parent)\n\t\t\t\t\tcmdq_print(item, \"%s*\", name);\n\t\t\t\telse\n\t\t\t\t\tcmdq_print(item, \"%s\", name);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (a != NULL) {\n\t\t\t\tidx = options_array_item_index(a);\n\t\t\t\tcmd_show_options_print(self, item, o, idx,\n\t\t\t\t    parent);\n\t\t\t\ta = options_array_next(a);\n\t\t\t}\n\t\t}\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-show-prompt-history.c",
          "type": "blob",
          "size": 3.0126953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2021 Anindya Mukherjee <anindya49@hotmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"tmux.h\"\n\n#include <stdlib.h>\n\n/*\n * Show or clear prompt history.\n */\n\nstatic enum cmd_retval\tcmd_show_prompt_history_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_show_prompt_history_entry = {\n\t.name = \"show-prompt-history\",\n\t.alias = \"showphist\",\n\n\t.args = { \"T:\", 0, 0, NULL },\n\t.usage = \"[-T type]\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_prompt_history_exec\n};\n\nconst struct cmd_entry cmd_clear_prompt_history_entry = {\n\t.name = \"clear-prompt-history\",\n\t.alias = \"clearphist\",\n\n\t.args = { \"T:\", 0, 0, NULL },\n\t.usage = \"[-T type]\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_show_prompt_history_exec\n};\n\nstatic enum cmd_retval\ncmd_show_prompt_history_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tconst char\t\t*typestr = args_get(args, 'T');\n\tenum prompt_type\t type;\n\tu_int\t\t\t tidx, hidx;\n\n\tif (cmd_get_entry(self) == &cmd_clear_prompt_history_entry) {\n\t\tif (typestr == NULL) {\n\t\t\tfor (tidx = 0; tidx < PROMPT_NTYPES; tidx++) {\n\t\t\t\tfree(status_prompt_hlist[tidx]);\n\t\t\t\tstatus_prompt_hlist[tidx] = NULL;\n\t\t\t\tstatus_prompt_hsize[tidx] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\ttype = status_prompt_type(typestr);\n\t\t\tif (type == PROMPT_TYPE_INVALID) {\n\t\t\t\tcmdq_error(item, \"invalid type: %s\", typestr);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\tfree(status_prompt_hlist[type]);\n\t\t\tstatus_prompt_hlist[type] = NULL;\n\t\t\tstatus_prompt_hsize[type] = 0;\n\t\t}\n\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (typestr == NULL) {\n\t\tfor (tidx = 0; tidx < PROMPT_NTYPES; tidx++) {\n\t\t\tcmdq_print(item, \"History for %s:\\n\",\n\t\t\t    status_prompt_type_string(tidx));\n\t\t\tfor (hidx = 0; hidx < status_prompt_hsize[tidx];\n\t\t\t    hidx++) {\n\t\t\t\tcmdq_print(item, \"%d: %s\", hidx + 1,\n\t\t\t\t    status_prompt_hlist[tidx][hidx]);\n\t\t\t}\n\t\t\tcmdq_print(item, \"%s\", \"\");\n\t\t}\n\t} else {\n\t\ttype = status_prompt_type(typestr);\n\t\tif (type == PROMPT_TYPE_INVALID) {\n\t\t\tcmdq_error(item, \"invalid type: %s\", typestr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcmdq_print(item, \"History for %s:\\n\",\n\t\t    status_prompt_type_string(type));\n\t\tfor (hidx = 0; hidx < status_prompt_hsize[type]; hidx++) {\n\t\t\tcmdq_print(item, \"%d: %s\", hidx + 1,\n\t\t\t    status_prompt_hlist[type][hidx]);\n\t\t}\n\t\tcmdq_print(item, \"%s\", \"\");\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-source-file.c",
          "type": "blob",
          "size": 6.1533203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <glob.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Sources a configuration file.\n */\n\n#define CMD_SOURCE_FILE_DEPTH_LIMIT 50\nstatic u_int cmd_source_file_depth;\n\nstatic enum cmd_retval\tcmd_source_file_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_source_file_entry = {\n\t.name = \"source-file\",\n\t.alias = \"source\",\n\n\t.args = { \"t:Fnqv\", 1, -1, NULL },\n\t.usage = \"[-Fnqv] \" CMD_TARGET_PANE_USAGE \" path ...\",\n\n\t.target = { 't', CMD_FIND_PANE, CMD_FIND_CANFAIL },\n\n\t.flags = 0,\n\t.exec = cmd_source_file_exec\n};\n\nstruct cmd_source_file_data {\n\tstruct cmdq_item\t *item;\n\tint\t\t\t  flags;\n\n\tstruct cmdq_item\t *after;\n\tenum cmd_retval\t\t  retval;\n\n\tu_int\t\t\t  current;\n\tchar\t\t\t**files;\n\tu_int\t\t\t  nfiles;\n};\n\nstatic enum cmd_retval\ncmd_source_file_complete_cb(struct cmdq_item *item, __unused void *data)\n{\n\tstruct client\t*c = cmdq_get_client(item);\n\n\tif (c == NULL) {\n\t\tcmd_source_file_depth--;\n\t\tlog_debug(\"%s: depth now %u\", __func__, cmd_source_file_depth);\n\t} else {\n\t\tc->source_file_depth--;\n\t\tlog_debug(\"%s: depth now %u\", __func__, c->source_file_depth);\n\t}\n\n\tcfg_print_causes(item);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\ncmd_source_file_complete(struct client *c, struct cmd_source_file_data *cdata)\n{\n\tstruct cmdq_item\t*new_item;\n\tu_int\t\t\t i;\n\n\tif (cfg_finished) {\n\t\tif (cdata->retval == CMD_RETURN_ERROR &&\n\t\t    c != NULL &&\n\t\t    c->session == NULL)\n\t\t\tc->retval = 1;\n\t\tnew_item = cmdq_get_callback(cmd_source_file_complete_cb, NULL);\n\t\tcmdq_insert_after(cdata->after, new_item);\n\t}\n\n\tfor (i = 0; i < cdata->nfiles; i++)\n\t\tfree(cdata->files[i]);\n\tfree(cdata->files);\n\tfree(cdata);\n}\n\nstatic void\ncmd_source_file_done(struct client *c, const char *path, int error,\n    int closed, struct evbuffer *buffer, void *data)\n{\n\tstruct cmd_source_file_data\t*cdata = data;\n\tstruct cmdq_item\t\t*item = cdata->item;\n\tvoid\t\t\t\t*bdata = EVBUFFER_DATA(buffer);\n\tsize_t\t\t\t\t bsize = EVBUFFER_LENGTH(buffer);\n\tu_int\t\t\t\t n;\n\tstruct cmdq_item\t\t*new_item;\n\tstruct cmd_find_state\t\t*target = cmdq_get_target(item);\n\n\tif (!closed)\n\t\treturn;\n\n\tif (error != 0)\n\t\tcmdq_error(item, \"%s: %s\", path, strerror(error));\n\telse if (bsize != 0) {\n\t\tif (load_cfg_from_buffer(bdata, bsize, path, c, cdata->after,\n\t\t    target, cdata->flags, &new_item) < 0)\n\t\t\tcdata->retval = CMD_RETURN_ERROR;\n\t\telse if (new_item != NULL)\n\t\t\tcdata->after = new_item;\n\t}\n\n\tn = ++cdata->current;\n\tif (n < cdata->nfiles)\n\t\tfile_read(c, cdata->files[n], cmd_source_file_done, cdata);\n\telse {\n\t\tcmd_source_file_complete(c, cdata);\n\t\tcmdq_continue(item);\n\t}\n}\n\nstatic void\ncmd_source_file_add(struct cmd_source_file_data *cdata, const char *path)\n{\n\tchar\tresolved[PATH_MAX];\n\n\tif (realpath(path, resolved) == NULL) {\n\t\tlog_debug(\"%s: realpath(\\\"%s\\\") failed: %s\", __func__,\n\t\t\tpath, strerror(errno));\n\t} else\n\t\tpath = resolved;\n\n\tlog_debug(\"%s: %s\", __func__, path);\n\n\tcdata->files = xreallocarray(cdata->files, cdata->nfiles + 1,\n\t    sizeof *cdata->files);\n\tcdata->files[cdata->nfiles++] = xstrdup(path);\n}\n\nstatic enum cmd_retval\ncmd_source_file_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t\t*args = cmd_get_args(self);\n\tstruct cmd_source_file_data\t*cdata;\n\tstruct client\t\t\t*c = cmdq_get_client(item);\n\tenum cmd_retval\t\t\t retval = CMD_RETURN_NORMAL;\n\tchar\t\t\t\t*pattern, *cwd, *expanded = NULL;\n\tconst char\t\t\t*path, *error;\n\tglob_t\t\t\t\t g;\n\tint\t\t\t\t result;\n\tu_int\t\t\t\t i, j;\n\n\tif (c == NULL) {\n\t\tif (cmd_source_file_depth >= CMD_SOURCE_FILE_DEPTH_LIMIT) {\n\t\t\tcmdq_error(item, \"too many nested files\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcmd_source_file_depth++;\n\t\tlog_debug(\"%s: depth now %u\", __func__, cmd_source_file_depth);\n\t} else {\n\t\tif (c->source_file_depth >= CMD_SOURCE_FILE_DEPTH_LIMIT) {\n\t\t\tcmdq_error(item, \"too many nested files\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tc->source_file_depth++;\n\t\tlog_debug(\"%s: depth now %u\", __func__, c->source_file_depth);\n\t}\n\n\tcdata = xcalloc(1, sizeof *cdata);\n\tcdata->item = item;\n\n\tif (args_has(args, 'q'))\n\t\tcdata->flags |= CMD_PARSE_QUIET;\n\tif (args_has(args, 'n'))\n\t\tcdata->flags |= CMD_PARSE_PARSEONLY;\n\tif (args_has(args, 'v'))\n\t\tcdata->flags |= CMD_PARSE_VERBOSE;\n\n\tutf8_stravis(&cwd, server_client_get_cwd(c, NULL), VIS_GLOB);\n\n\tfor (i = 0; i < args_count(args); i++) {\n\t\tpath = args_string(args, i);\n\t\tif (args_has(args, 'F')) {\n\t\t\tfree(expanded);\n\t\t\texpanded = format_single_from_target(item, path);\n\t\t\tpath = expanded;\n\t\t}\n\t\tif (strcmp(path, \"-\") == 0) {\n\t\t\tcmd_source_file_add(cdata, \"-\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*path == '/')\n\t\t\tpattern = xstrdup(path);\n\t\telse\n\t\t\txasprintf(&pattern, \"%s/%s\", cwd, path);\n\t\tlog_debug(\"%s: %s\", __func__, pattern);\n\n\t\tif ((result = glob(pattern, 0, NULL, &g)) != 0) {\n\t\t\tif (result != GLOB_NOMATCH ||\n\t\t\t    (~cdata->flags & CMD_PARSE_QUIET)) {\n\t\t\t\tif (result == GLOB_NOMATCH)\n\t\t\t\t\terror = strerror(ENOENT);\n\t\t\t\telse if (result == GLOB_NOSPACE)\n\t\t\t\t\terror = strerror(ENOMEM);\n\t\t\t\telse\n\t\t\t\t\terror = strerror(EINVAL);\n\t\t\t\tcmdq_error(item, \"%s: %s\", path, error);\n\t\t\t\tretval = CMD_RETURN_ERROR;\n\t\t\t}\n\t\t\tglobfree(&g);\n\t\t\tfree(pattern);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(pattern);\n\n\t\tfor (j = 0; j < g.gl_pathc; j++)\n\t\t\tcmd_source_file_add(cdata, g.gl_pathv[j]);\n\t\tglobfree(&g);\n\t}\n\tfree(expanded);\n\n\tcdata->after = item;\n\tcdata->retval = retval;\n\n\tif (cdata->nfiles != 0) {\n\t\tfile_read(c, cdata->files[0], cmd_source_file_done, cdata);\n\t\tretval = CMD_RETURN_WAIT;\n\t} else\n\t\tcmd_source_file_complete(c, cdata);\n\n\tfree(cwd);\n\treturn (retval);\n}\n"
        },
        {
          "name": "cmd-split-window.c",
          "type": "blob",
          "size": 5.1484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Split a window (add a new pane).\n */\n\n#define SPLIT_WINDOW_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nstatic enum cmd_retval\tcmd_split_window_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_split_window_entry = {\n\t.name = \"split-window\",\n\t.alias = \"splitw\",\n\n\t.args = { \"bc:de:fF:hIl:p:Pt:vZ\", 0, -1, NULL },\n\t.usage = \"[-bdefhIPvZ] [-c start-directory] [-e environment] \"\n\t\t \"[-F format] [-l size] \" CMD_TARGET_PANE_USAGE\n\t\t \"[shell-command]\",\n\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_split_window_exec\n};\n\nstatic enum cmd_retval\ncmd_split_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct spawn_context\t sc = { 0 };\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t*s = target->s;\n\tstruct winlink\t\t*wl = target->wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp = target->wp, *new_wp;\n\tenum layout_type\t type;\n\tstruct layout_cell\t*lc;\n\tstruct cmd_find_state\t fs;\n\tint\t\t\t size, flags, input;\n\tconst char\t\t*template;\n\tchar\t\t\t*cause = NULL, *cp;\n\tstruct args_value\t*av;\n\tu_int\t\t\t count = args_count(args), curval = 0;\n\n\ttype = LAYOUT_TOPBOTTOM;\n\tif (args_has(args, 'h'))\n\t\ttype = LAYOUT_LEFTRIGHT;\n\n\t/* If the 'p' flag is dropped then this bit can be moved into 'l'. */\n\tif (args_has(args, 'l') || args_has(args, 'p')) {\n\t\tif (args_has(args, 'f')) {\n\t\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\t\tcurval = w->sy;\n\t\t\telse\n\t\t\t\tcurval = w->sx;\n\t\t} else {\n\t\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\t\tcurval = wp->sy;\n\t\t\telse\n\t\t\t\tcurval = wp->sx;\n\t\t}\n\t}\n\n\tsize = -1;\n\tif (args_has(args, 'l')) {\n\t\tsize = args_percentage_and_expand(args, 'l', 0, INT_MAX, curval,\n\t\t    item, &cause);\n\t} else if (args_has(args, 'p')) {\n\t\tsize = args_strtonum_and_expand(args, 'p', 0, 100, item,\n\t\t    &cause);\n\t\tif (cause == NULL)\n\t\t\tsize = curval * size / 100;\n\t}\n\tif (cause != NULL) {\n\t\tcmdq_error(item, \"size %s\", cause);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\twindow_push_zoom(wp->window, 1, args_has(args, 'Z'));\n\tinput = (args_has(args, 'I') && count == 0);\n\n\tflags = 0;\n\tif (args_has(args, 'b'))\n\t\tflags |= SPAWN_BEFORE;\n\tif (args_has(args, 'f'))\n\t\tflags |= SPAWN_FULLSIZE;\n\tif (input || (count == 1 && *args_string(args, 0) == '\\0'))\n\t\tflags |= SPAWN_EMPTY;\n\n\tlc = layout_split_pane(wp, type, size, flags);\n\tif (lc == NULL) {\n\t\tcmdq_error(item, \"no space for new pane\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tsc.item = item;\n\tsc.s = s;\n\tsc.wl = wl;\n\n\tsc.wp0 = wp;\n\tsc.lc = lc;\n\n\targs_to_vector(args, &sc.argc, &sc.argv);\n\tsc.environ = environ_create();\n\n\tav = args_first_value(args, 'e');\n\twhile (av != NULL) {\n\t\tenviron_put(sc.environ, av->string, 0);\n\t\tav = args_next_value(av);\n\t}\n\n\tsc.idx = -1;\n\tsc.cwd = args_get(args, 'c');\n\n\tsc.flags = flags;\n\tif (args_has(args, 'd'))\n\t\tsc.flags |= SPAWN_DETACHED;\n\tif (args_has(args, 'Z'))\n\t\tsc.flags |= SPAWN_ZOOM;\n\n\tif ((new_wp = spawn_pane(&sc, &cause)) == NULL) {\n\t\tcmdq_error(item, \"create pane failed: %s\", cause);\n\t\tfree(cause);\n\t\tif (sc.argv != NULL)\n\t\t\tcmd_free_argv(sc.argc, sc.argv);\n\t\tenviron_free(sc.environ);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (input) {\n\t\tswitch (window_pane_start_input(new_wp, item, &cause)) {\n\t\tcase -1:\n\t\t\tserver_client_remove_pane(new_wp);\n\t\t\tlayout_close_pane(new_wp);\n\t\t\twindow_remove_pane(wp->window, new_wp);\n\t\t\tcmdq_error(item, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tif (sc.argv != NULL)\n\t\t\t\tcmd_free_argv(sc.argc, sc.argv);\n\t\t\tenviron_free(sc.environ);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\tcase 1:\n\t\t\tinput = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!args_has(args, 'd'))\n\t\tcmd_find_from_winlink_pane(current, wl, new_wp, 0);\n\twindow_pop_zoom(wp->window);\n\tserver_redraw_window(wp->window);\n\tserver_status_session(s);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = SPLIT_WINDOW_TEMPLATE;\n\t\tcp = format_single(item, template, tc, s, wl, new_wp);\n\t\tcmdq_print(item, \"%s\", cp);\n\t\tfree(cp);\n\t}\n\n\tcmd_find_from_winlink_pane(&fs, wl, new_wp, 0);\n\tcmdq_insert_hook(s, item, &fs, \"after-split-window\");\n\n\tif (sc.argv != NULL)\n\t\tcmd_free_argv(sc.argc, sc.argv);\n\tenviron_free(sc.environ);\n\tif (input)\n\t\treturn (CMD_RETURN_WAIT);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-swap-pane.c",
          "type": "blob",
          "size": 4.3408203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Swap two panes.\n */\n\nstatic enum cmd_retval\tcmd_swap_pane_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_swap_pane_entry = {\n\t.name = \"swap-pane\",\n\t.alias = \"swapp\",\n\n\t.args = { \"dDs:t:UZ\", 0, 0, NULL },\n\t.usage = \"[-dDUZ] \" CMD_SRCDST_PANE_USAGE,\n\n\t.source = { 's', CMD_FIND_PANE, CMD_FIND_DEFAULT_MARKED },\n\t.target = { 't', CMD_FIND_PANE, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_swap_pane_exec\n};\n\nstatic enum cmd_retval\ncmd_swap_pane_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct window\t\t*src_w, *dst_w;\n\tstruct window_pane\t*tmp_wp, *src_wp, *dst_wp;\n\tstruct layout_cell\t*src_lc, *dst_lc;\n\tu_int\t\t\t sx, sy, xoff, yoff;\n\n\tdst_w = target->wl->window;\n\tdst_wp = target->wp;\n\tsrc_w = source->wl->window;\n\tsrc_wp = source->wp;\n\n\tif (window_push_zoom(dst_w, 0, args_has(args, 'Z')))\n\t\tserver_redraw_window(dst_w);\n\n\tif (args_has(args, 'D')) {\n\t\tsrc_w = dst_w;\n\t\tsrc_wp = TAILQ_NEXT(dst_wp, entry);\n\t\tif (src_wp == NULL)\n\t\t\tsrc_wp = TAILQ_FIRST(&dst_w->panes);\n\t} else if (args_has(args, 'U')) {\n\t\tsrc_w = dst_w;\n\t\tsrc_wp = TAILQ_PREV(dst_wp, window_panes, entry);\n\t\tif (src_wp == NULL)\n\t\t\tsrc_wp = TAILQ_LAST(&dst_w->panes, window_panes);\n\t}\n\n\tif (src_w != dst_w && window_push_zoom(src_w, 0, args_has(args, 'Z')))\n\t\tserver_redraw_window(src_w);\n\n\tif (src_wp == dst_wp)\n\t\tgoto out;\n\n\tserver_client_remove_pane(src_wp);\n\tserver_client_remove_pane(dst_wp);\n\n\ttmp_wp = TAILQ_PREV(dst_wp, window_panes, entry);\n\tTAILQ_REMOVE(&dst_w->panes, dst_wp, entry);\n\tTAILQ_REPLACE(&src_w->panes, src_wp, dst_wp, entry);\n\tif (tmp_wp == src_wp)\n\t\ttmp_wp = dst_wp;\n\tif (tmp_wp == NULL)\n\t\tTAILQ_INSERT_HEAD(&dst_w->panes, src_wp, entry);\n\telse\n\t\tTAILQ_INSERT_AFTER(&dst_w->panes, tmp_wp, src_wp, entry);\n\n\tsrc_lc = src_wp->layout_cell;\n\tdst_lc = dst_wp->layout_cell;\n\tsrc_lc->wp = dst_wp;\n\tdst_wp->layout_cell = src_lc;\n\tdst_lc->wp = src_wp;\n\tsrc_wp->layout_cell = dst_lc;\n\n\tsrc_wp->window = dst_w;\n\toptions_set_parent(src_wp->options, dst_w->options);\n\tsrc_wp->flags |= PANE_STYLECHANGED;\n\tdst_wp->window = src_w;\n\toptions_set_parent(dst_wp->options, src_w->options);\n\tdst_wp->flags |= PANE_STYLECHANGED;\n\n\tsx = src_wp->sx; sy = src_wp->sy;\n\txoff = src_wp->xoff; yoff = src_wp->yoff;\n\tsrc_wp->xoff = dst_wp->xoff; src_wp->yoff = dst_wp->yoff;\n\twindow_pane_resize(src_wp, dst_wp->sx, dst_wp->sy);\n\tdst_wp->xoff = xoff; dst_wp->yoff = yoff;\n\twindow_pane_resize(dst_wp, sx, sy);\n\n\tif (!args_has(args, 'd')) {\n\t\tif (src_w != dst_w) {\n\t\t\twindow_set_active_pane(src_w, dst_wp, 1);\n\t\t\twindow_set_active_pane(dst_w, src_wp, 1);\n\t\t} else {\n\t\t\ttmp_wp = dst_wp;\n\t\t\twindow_set_active_pane(src_w, tmp_wp, 1);\n\t\t}\n\t} else {\n\t\tif (src_w->active == src_wp)\n\t\t\twindow_set_active_pane(src_w, dst_wp, 1);\n\t\tif (dst_w->active == dst_wp)\n\t\t\twindow_set_active_pane(dst_w, src_wp, 1);\n\t}\n\tif (src_w != dst_w) {\n\t\twindow_pane_stack_remove(&src_w->last_panes, src_wp);\n\t\twindow_pane_stack_remove(&dst_w->last_panes, dst_wp);\n\t\tcolour_palette_from_option(&src_wp->palette, src_wp->options);\n\t\tcolour_palette_from_option(&dst_wp->palette, dst_wp->options);\n\t}\n\tserver_redraw_window(src_w);\n\tserver_redraw_window(dst_w);\n\tnotify_window(\"window-layout-changed\", src_w);\n\tif (src_w != dst_w)\n\t\tnotify_window(\"window-layout-changed\", dst_w);\n\nout:\n\tif (window_pop_zoom(src_w))\n\t\tserver_redraw_window(src_w);\n\tif (src_w != dst_w && window_pop_zoom(dst_w))\n\t\tserver_redraw_window(dst_w);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-swap-window.c",
          "type": "blob",
          "size": 2.689453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Swap one window with another.\n */\n\nstatic enum cmd_retval\tcmd_swap_window_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_swap_window_entry = {\n\t.name = \"swap-window\",\n\t.alias = \"swapw\",\n\n\t.args = { \"ds:t:\", 0, 0, NULL },\n\t.usage = \"[-d] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.source = { 's', CMD_FIND_WINDOW, CMD_FIND_DEFAULT_MARKED },\n\t.target = { 't', CMD_FIND_WINDOW, 0 },\n\n\t.flags = 0,\n\t.exec = cmd_swap_window_exec\n};\n\nstatic enum cmd_retval\ncmd_swap_window_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*source = cmdq_get_source(item);\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct session\t\t*src = source->s, *dst = target->s;\n\tstruct session_group\t*sg_src, *sg_dst;\n\tstruct winlink\t\t*wl_src = source->wl, *wl_dst = target->wl;\n\tstruct window\t\t*w_src, *w_dst;\n\n\tsg_src = session_group_contains(src);\n\tsg_dst = session_group_contains(dst);\n\n\tif (src != dst &&\n\t    sg_src != NULL &&\n\t    sg_dst != NULL &&\n\t    sg_src == sg_dst) {\n\t\tcmdq_error(item, \"can't move window, sessions are grouped\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wl_dst->window == wl_src->window)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tw_dst = wl_dst->window;\n\tTAILQ_REMOVE(&w_dst->winlinks, wl_dst, wentry);\n\tw_src = wl_src->window;\n\tTAILQ_REMOVE(&w_src->winlinks, wl_src, wentry);\n\n\twl_dst->window = w_src;\n\tTAILQ_INSERT_TAIL(&w_src->winlinks, wl_dst, wentry);\n\twl_src->window = w_dst;\n\tTAILQ_INSERT_TAIL(&w_dst->winlinks, wl_src, wentry);\n\n\tif (args_has(args, 'd')) {\n\t\tsession_select(dst, wl_dst->idx);\n\t\tif (src != dst)\n\t\t\tsession_select(src, wl_src->idx);\n\t}\n\tsession_group_synchronize_from(src);\n\tserver_redraw_session_group(src);\n\tif (src != dst) {\n\t\tsession_group_synchronize_from(dst);\n\t\tserver_redraw_session_group(dst);\n\t}\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-switch-client.c",
          "type": "blob",
          "size": 3.9375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Switch client to a different session.\n */\n\nstatic enum cmd_retval\tcmd_switch_client_exec(struct cmd *,\n\t\t\t    struct cmdq_item *);\n\nconst struct cmd_entry cmd_switch_client_entry = {\n\t.name = \"switch-client\",\n\t.alias = \"switchc\",\n\n\t.args = { \"lc:EFnpt:rT:Z\", 0, 0, NULL },\n\t.usage = \"[-ElnprZ] [-c target-client] [-t target-session] \"\n\t\t \"[-T key-table]\",\n\n\t/* -t is special */\n\n\t.flags = CMD_READONLY|CMD_CLIENT_CFLAG,\n\t.exec = cmd_switch_client_exec\n};\n\nstatic enum cmd_retval\ncmd_switch_client_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t\t*args = cmd_get_args(self);\n\tstruct cmd_find_state\t*current = cmdq_get_current(item);\n\tstruct cmd_find_state\t target;\n\tconst char\t\t*tflag = args_get(args, 't');\n\tenum cmd_find_type\t type;\n\tint\t\t\t flags;\n\tstruct client\t\t*tc = cmdq_get_target_client(item);\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tconst char\t\t*tablename;\n\tstruct key_table\t*table;\n\n\tif (tflag != NULL && tflag[strcspn(tflag, \":.%\")] != '\\0') {\n\t\ttype = CMD_FIND_PANE;\n\t\tflags = 0;\n\t} else {\n\t\ttype = CMD_FIND_SESSION;\n\t\tflags = CMD_FIND_PREFER_UNATTACHED;\n\t}\n\tif (cmd_find_target(&target, item, tflag, type, flags) != 0)\n\t\treturn (CMD_RETURN_ERROR);\n\ts = target.s;\n\twl = target.wl;\n\twp = target.wp;\n\n\tif (args_has(args, 'r')) {\n\t\tif (tc->flags & CLIENT_READONLY)\n\t\t\ttc->flags &= ~(CLIENT_READONLY|CLIENT_IGNORESIZE);\n\t\telse\n\t\t\ttc->flags |= (CLIENT_READONLY|CLIENT_IGNORESIZE);\n\t}\n\n\ttablename = args_get(args, 'T');\n\tif (tablename != NULL) {\n\t\ttable = key_bindings_get_table(tablename, 0);\n\t\tif (table == NULL) {\n\t\t\tcmdq_error(item, \"table %s doesn't exist\", tablename);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\ttable->references++;\n\t\tkey_bindings_unref_table(tc->keytable);\n\t\ttc->keytable = table;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'n')) {\n\t\tif ((s = session_next_session(tc->session)) == NULL) {\n\t\t\tcmdq_error(item, \"can't find next session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'p')) {\n\t\tif ((s = session_previous_session(tc->session)) == NULL) {\n\t\t\tcmdq_error(item, \"can't find previous session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'l')) {\n\t\tif (tc->last_session != NULL && session_alive(tc->last_session))\n\t\t\ts = tc->last_session;\n\t\telse\n\t\t\ts = NULL;\n\t\tif (s == NULL) {\n\t\t\tcmdq_error(item, \"can't find last session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tif (cmdq_get_client(item) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (wl != NULL && wp != NULL && wp != wl->window->active) {\n\t\t\tw = wl->window;\n\t\t\tif (window_push_zoom(w, 0, args_has(args, 'Z')))\n\t\t\t\tserver_redraw_window(w);\n\t\t\twindow_redraw_active_switch(w, wp);\n\t\t\twindow_set_active_pane(w, wp, 1);\n\t\t\tif (window_pop_zoom(w))\n\t\t\t\tserver_redraw_window(w);\n\t\t}\n\t\tif (wl != NULL) {\n\t\t\tsession_set_current(s, wl);\n\t\t\tcmd_find_from_session(current, s, 0);\n\t\t}\n\t}\n\n\tif (!args_has(args, 'E'))\n\t\tenviron_update(s->options, tc->environ, s->environ);\n\n\tserver_client_set_session(tc, s);\n\tif (~cmdq_get_flags(item) & CMDQ_STATE_REPEAT)\n\t\tserver_client_set_key_table(tc, NULL);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-unbind-key.c",
          "type": "blob",
          "size": 2.6416015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Unbind key from command.\n */\n\nstatic enum cmd_retval\tcmd_unbind_key_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_unbind_key_entry = {\n\t.name = \"unbind-key\",\n\t.alias = \"unbind\",\n\n\t.args = { \"anqT:\", 0, 1, NULL },\n\t.usage = \"[-anq] [-T key-table] key\",\n\n\t.flags = CMD_AFTERHOOK,\n\t.exec = cmd_unbind_key_exec\n};\n\nstatic enum cmd_retval\ncmd_unbind_key_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args\t*args = cmd_get_args(self);\n\tkey_code\t key;\n\tconst char\t*tablename, *keystr = args_string(args, 0);\n\tint\t\t quiet = args_has(args, 'q');\n\n\tif (args_has(args, 'a')) {\n\t\tif (keystr != NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tcmdq_error(item, \"key given with -a\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\n\t\ttablename = args_get(args, 'T');\n\t\tif (tablename == NULL) {\n\t\t\tif (args_has(args, 'n'))\n\t\t\t\ttablename = \"root\";\n\t\t\telse\n\t\t\t\ttablename = \"prefix\";\n\t\t}\n\t\tif (key_bindings_get_table(tablename, 0) == NULL) {\n\t\t\tif (!quiet) {\n\t\t\t\tcmdq_error(item, \"table %s doesn't exist\" ,\n\t\t\t\t    tablename);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\n\t\tkey_bindings_remove_table(tablename);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (keystr == NULL) {\n\t\tif (!quiet)\n\t\t\tcmdq_error(item, \"missing key\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tkey = key_string_lookup_string(keystr);\n\tif (key == KEYC_NONE || key == KEYC_UNKNOWN) {\n\t\tif (!quiet)\n\t\t\tcmdq_error(item, \"unknown key: %s\", keystr);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 'T')) {\n\t\ttablename = args_get(args, 'T');\n\t\tif (key_bindings_get_table(tablename, 0) == NULL) {\n\t\t\tif (!quiet) {\n\t\t\t\tcmdq_error(item, \"table %s doesn't exist\" ,\n\t\t\t\t    tablename);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'n'))\n\t\ttablename = \"root\";\n\telse\n\t\ttablename = \"prefix\";\n\tkey_bindings_remove(tablename, key);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-wait-for.c",
          "type": "blob",
          "size": 6.2724609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2013 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2013 Thiago de Arruda <tpadilha84@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Block or wake a client on a named wait channel.\n */\n\nstatic enum cmd_retval cmd_wait_for_exec(struct cmd *, struct cmdq_item *);\n\nconst struct cmd_entry cmd_wait_for_entry = {\n\t.name = \"wait-for\",\n\t.alias = \"wait\",\n\n\t.args = { \"LSU\", 1, 1, NULL },\n\t.usage = \"[-L|-S|-U] channel\",\n\n\t.flags = 0,\n\t.exec = cmd_wait_for_exec\n};\n\nstruct wait_item {\n\tstruct cmdq_item\t*item;\n\tTAILQ_ENTRY(wait_item)\t entry;\n};\n\nstruct wait_channel {\n\tconst char\t       *name;\n\tint\t\t\tlocked;\n\tint\t\t\twoken;\n\n\tTAILQ_HEAD(, wait_item)\twaiters;\n\tTAILQ_HEAD(, wait_item)\tlockers;\n\n\tRB_ENTRY(wait_channel)\tentry;\n};\nRB_HEAD(wait_channels, wait_channel);\nstatic struct wait_channels wait_channels = RB_INITIALIZER(wait_channels);\n\nstatic int wait_channel_cmp(struct wait_channel *, struct wait_channel *);\nRB_GENERATE_STATIC(wait_channels, wait_channel, entry, wait_channel_cmp);\n\nstatic int\nwait_channel_cmp(struct wait_channel *wc1, struct wait_channel *wc2)\n{\n\treturn (strcmp(wc1->name, wc2->name));\n}\n\nstatic enum cmd_retval\tcmd_wait_for_signal(struct cmdq_item *, const char *,\n\t\t\t    struct wait_channel *);\nstatic enum cmd_retval\tcmd_wait_for_wait(struct cmdq_item *, const char *,\n\t\t\t    struct wait_channel *);\nstatic enum cmd_retval\tcmd_wait_for_lock(struct cmdq_item *, const char *,\n\t\t\t    struct wait_channel *);\nstatic enum cmd_retval\tcmd_wait_for_unlock(struct cmdq_item *, const char *,\n\t\t\t    struct wait_channel *);\n\nstatic struct wait_channel\t*cmd_wait_for_add(const char *);\nstatic void\t\t\t cmd_wait_for_remove(struct wait_channel *);\n\nstatic struct wait_channel *\ncmd_wait_for_add(const char *name)\n{\n\tstruct wait_channel *wc;\n\n\twc = xmalloc(sizeof *wc);\n\twc->name = xstrdup(name);\n\n\twc->locked = 0;\n\twc->woken = 0;\n\n\tTAILQ_INIT(&wc->waiters);\n\tTAILQ_INIT(&wc->lockers);\n\n\tRB_INSERT(wait_channels, &wait_channels, wc);\n\n\tlog_debug(\"add wait channel %s\", wc->name);\n\n\treturn (wc);\n}\n\nstatic void\ncmd_wait_for_remove(struct wait_channel *wc)\n{\n\tif (wc->locked)\n\t\treturn;\n\tif (!TAILQ_EMPTY(&wc->waiters) || !wc->woken)\n\t\treturn;\n\n\tlog_debug(\"remove wait channel %s\", wc->name);\n\n\tRB_REMOVE(wait_channels, &wait_channels, wc);\n\n\tfree((void *)wc->name);\n\tfree(wc);\n}\n\nstatic enum cmd_retval\ncmd_wait_for_exec(struct cmd *self, struct cmdq_item *item)\n{\n\tstruct args     \t*args = cmd_get_args(self);\n\tconst char\t\t*name = args_string(args, 0);\n\tstruct wait_channel\t*wc, find;\n\n\tfind.name = name;\n\twc = RB_FIND(wait_channels, &wait_channels, &find);\n\n\tif (args_has(args, 'S'))\n\t\treturn (cmd_wait_for_signal(item, name, wc));\n\tif (args_has(args, 'L'))\n\t\treturn (cmd_wait_for_lock(item, name, wc));\n\tif (args_has(args, 'U'))\n\t\treturn (cmd_wait_for_unlock(item, name, wc));\n\treturn (cmd_wait_for_wait(item, name, wc));\n}\n\nstatic enum cmd_retval\ncmd_wait_for_signal(__unused struct cmdq_item *item, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct wait_item\t*wi, *wi1;\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (TAILQ_EMPTY(&wc->waiters) && !wc->woken) {\n\t\tlog_debug(\"signal wait channel %s, no waiters\", wc->name);\n\t\twc->woken = 1;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tlog_debug(\"signal wait channel %s, with waiters\", wc->name);\n\n\tTAILQ_FOREACH_SAFE(wi, &wc->waiters, entry, wi1) {\n\t\tcmdq_continue(wi->item);\n\n\t\tTAILQ_REMOVE(&wc->waiters, wi, entry);\n\t\tfree(wi);\n\t}\n\n\tcmd_wait_for_remove(wc);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncmd_wait_for_wait(struct cmdq_item *item, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct wait_item\t*wi;\n\n\tif (c == NULL) {\n\t\tcmdq_error(item, \"not able to wait\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (wc->woken) {\n\t\tlog_debug(\"wait channel %s already woken (%p)\", wc->name, c);\n\t\tcmd_wait_for_remove(wc);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tlog_debug(\"wait channel %s not woken (%p)\", wc->name, c);\n\n\twi = xcalloc(1, sizeof *wi);\n\twi->item = item;\n\tTAILQ_INSERT_TAIL(&wc->waiters, wi, entry);\n\n\treturn (CMD_RETURN_WAIT);\n}\n\nstatic enum cmd_retval\ncmd_wait_for_lock(struct cmdq_item *item, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct wait_item\t*wi;\n\n\tif (cmdq_get_client(item) == NULL) {\n\t\tcmdq_error(item, \"not able to lock\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (wc->locked) {\n\t\twi = xcalloc(1, sizeof *wi);\n\t\twi->item = item;\n\t\tTAILQ_INSERT_TAIL(&wc->lockers, wi, entry);\n\t\treturn (CMD_RETURN_WAIT);\n\t}\n\twc->locked = 1;\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic enum cmd_retval\ncmd_wait_for_unlock(struct cmdq_item *item, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct wait_item\t*wi;\n\n\tif (wc == NULL || !wc->locked) {\n\t\tcmdq_error(item, \"channel %s not locked\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif ((wi = TAILQ_FIRST(&wc->lockers)) != NULL) {\n\t\tcmdq_continue(wi->item);\n\t\tTAILQ_REMOVE(&wc->lockers, wi, entry);\n\t\tfree(wi);\n\t} else {\n\t\twc->locked = 0;\n\t\tcmd_wait_for_remove(wc);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_wait_for_flush(void)\n{\n\tstruct wait_channel\t*wc, *wc1;\n\tstruct wait_item\t*wi, *wi1;\n\n\tRB_FOREACH_SAFE(wc, wait_channels, &wait_channels, wc1) {\n\t\tTAILQ_FOREACH_SAFE(wi, &wc->waiters, entry, wi1) {\n\t\t\tcmdq_continue(wi->item);\n\t\t\tTAILQ_REMOVE(&wc->waiters, wi, entry);\n\t\t\tfree(wi);\n\t\t}\n\t\twc->woken = 1;\n\t\tTAILQ_FOREACH_SAFE(wi, &wc->lockers, entry, wi1) {\n\t\t\tcmdq_continue(wi->item);\n\t\t\tTAILQ_REMOVE(&wc->lockers, wi, entry);\n\t\t\tfree(wi);\n\t\t}\n\t\twc->locked = 0;\n\t\tcmd_wait_for_remove(wc);\n\t}\n}\n"
        },
        {
          "name": "cmd.c",
          "type": "blob",
          "size": 20.619140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <fnmatch.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nextern const struct cmd_entry cmd_attach_session_entry;\nextern const struct cmd_entry cmd_bind_key_entry;\nextern const struct cmd_entry cmd_break_pane_entry;\nextern const struct cmd_entry cmd_capture_pane_entry;\nextern const struct cmd_entry cmd_choose_buffer_entry;\nextern const struct cmd_entry cmd_choose_client_entry;\nextern const struct cmd_entry cmd_choose_tree_entry;\nextern const struct cmd_entry cmd_clear_history_entry;\nextern const struct cmd_entry cmd_clear_prompt_history_entry;\nextern const struct cmd_entry cmd_clock_mode_entry;\nextern const struct cmd_entry cmd_command_prompt_entry;\nextern const struct cmd_entry cmd_confirm_before_entry;\nextern const struct cmd_entry cmd_copy_mode_entry;\nextern const struct cmd_entry cmd_customize_mode_entry;\nextern const struct cmd_entry cmd_delete_buffer_entry;\nextern const struct cmd_entry cmd_detach_client_entry;\nextern const struct cmd_entry cmd_display_menu_entry;\nextern const struct cmd_entry cmd_display_message_entry;\nextern const struct cmd_entry cmd_display_popup_entry;\nextern const struct cmd_entry cmd_display_panes_entry;\nextern const struct cmd_entry cmd_find_window_entry;\nextern const struct cmd_entry cmd_has_session_entry;\nextern const struct cmd_entry cmd_if_shell_entry;\nextern const struct cmd_entry cmd_join_pane_entry;\nextern const struct cmd_entry cmd_kill_pane_entry;\nextern const struct cmd_entry cmd_kill_server_entry;\nextern const struct cmd_entry cmd_kill_session_entry;\nextern const struct cmd_entry cmd_kill_window_entry;\nextern const struct cmd_entry cmd_last_pane_entry;\nextern const struct cmd_entry cmd_last_window_entry;\nextern const struct cmd_entry cmd_link_window_entry;\nextern const struct cmd_entry cmd_list_buffers_entry;\nextern const struct cmd_entry cmd_list_clients_entry;\nextern const struct cmd_entry cmd_list_commands_entry;\nextern const struct cmd_entry cmd_list_keys_entry;\nextern const struct cmd_entry cmd_list_panes_entry;\nextern const struct cmd_entry cmd_list_sessions_entry;\nextern const struct cmd_entry cmd_list_windows_entry;\nextern const struct cmd_entry cmd_load_buffer_entry;\nextern const struct cmd_entry cmd_lock_client_entry;\nextern const struct cmd_entry cmd_lock_server_entry;\nextern const struct cmd_entry cmd_lock_session_entry;\nextern const struct cmd_entry cmd_move_pane_entry;\nextern const struct cmd_entry cmd_move_window_entry;\nextern const struct cmd_entry cmd_new_session_entry;\nextern const struct cmd_entry cmd_new_window_entry;\nextern const struct cmd_entry cmd_next_layout_entry;\nextern const struct cmd_entry cmd_next_window_entry;\nextern const struct cmd_entry cmd_paste_buffer_entry;\nextern const struct cmd_entry cmd_pipe_pane_entry;\nextern const struct cmd_entry cmd_previous_layout_entry;\nextern const struct cmd_entry cmd_previous_window_entry;\nextern const struct cmd_entry cmd_refresh_client_entry;\nextern const struct cmd_entry cmd_rename_session_entry;\nextern const struct cmd_entry cmd_rename_window_entry;\nextern const struct cmd_entry cmd_resize_pane_entry;\nextern const struct cmd_entry cmd_resize_window_entry;\nextern const struct cmd_entry cmd_respawn_pane_entry;\nextern const struct cmd_entry cmd_respawn_window_entry;\nextern const struct cmd_entry cmd_rotate_window_entry;\nextern const struct cmd_entry cmd_run_shell_entry;\nextern const struct cmd_entry cmd_save_buffer_entry;\nextern const struct cmd_entry cmd_select_layout_entry;\nextern const struct cmd_entry cmd_select_pane_entry;\nextern const struct cmd_entry cmd_select_window_entry;\nextern const struct cmd_entry cmd_send_keys_entry;\nextern const struct cmd_entry cmd_send_prefix_entry;\nextern const struct cmd_entry cmd_server_access_entry;\nextern const struct cmd_entry cmd_set_buffer_entry;\nextern const struct cmd_entry cmd_set_environment_entry;\nextern const struct cmd_entry cmd_set_hook_entry;\nextern const struct cmd_entry cmd_set_option_entry;\nextern const struct cmd_entry cmd_set_window_option_entry;\nextern const struct cmd_entry cmd_show_buffer_entry;\nextern const struct cmd_entry cmd_show_environment_entry;\nextern const struct cmd_entry cmd_show_hooks_entry;\nextern const struct cmd_entry cmd_show_messages_entry;\nextern const struct cmd_entry cmd_show_options_entry;\nextern const struct cmd_entry cmd_show_prompt_history_entry;\nextern const struct cmd_entry cmd_show_window_options_entry;\nextern const struct cmd_entry cmd_source_file_entry;\nextern const struct cmd_entry cmd_split_window_entry;\nextern const struct cmd_entry cmd_start_server_entry;\nextern const struct cmd_entry cmd_suspend_client_entry;\nextern const struct cmd_entry cmd_swap_pane_entry;\nextern const struct cmd_entry cmd_swap_window_entry;\nextern const struct cmd_entry cmd_switch_client_entry;\nextern const struct cmd_entry cmd_unbind_key_entry;\nextern const struct cmd_entry cmd_unlink_window_entry;\nextern const struct cmd_entry cmd_wait_for_entry;\n\nconst struct cmd_entry *cmd_table[] = {\n\t&cmd_attach_session_entry,\n\t&cmd_bind_key_entry,\n\t&cmd_break_pane_entry,\n\t&cmd_capture_pane_entry,\n\t&cmd_choose_buffer_entry,\n\t&cmd_choose_client_entry,\n\t&cmd_choose_tree_entry,\n\t&cmd_clear_history_entry,\n\t&cmd_clear_prompt_history_entry,\n\t&cmd_clock_mode_entry,\n\t&cmd_command_prompt_entry,\n\t&cmd_confirm_before_entry,\n\t&cmd_copy_mode_entry,\n\t&cmd_customize_mode_entry,\n\t&cmd_delete_buffer_entry,\n\t&cmd_detach_client_entry,\n\t&cmd_display_menu_entry,\n\t&cmd_display_message_entry,\n\t&cmd_display_popup_entry,\n\t&cmd_display_panes_entry,\n\t&cmd_find_window_entry,\n\t&cmd_has_session_entry,\n\t&cmd_if_shell_entry,\n\t&cmd_join_pane_entry,\n\t&cmd_kill_pane_entry,\n\t&cmd_kill_server_entry,\n\t&cmd_kill_session_entry,\n\t&cmd_kill_window_entry,\n\t&cmd_last_pane_entry,\n\t&cmd_last_window_entry,\n\t&cmd_link_window_entry,\n\t&cmd_list_buffers_entry,\n\t&cmd_list_clients_entry,\n\t&cmd_list_commands_entry,\n\t&cmd_list_keys_entry,\n\t&cmd_list_panes_entry,\n\t&cmd_list_sessions_entry,\n\t&cmd_list_windows_entry,\n\t&cmd_load_buffer_entry,\n\t&cmd_lock_client_entry,\n\t&cmd_lock_server_entry,\n\t&cmd_lock_session_entry,\n\t&cmd_move_pane_entry,\n\t&cmd_move_window_entry,\n\t&cmd_new_session_entry,\n\t&cmd_new_window_entry,\n\t&cmd_next_layout_entry,\n\t&cmd_next_window_entry,\n\t&cmd_paste_buffer_entry,\n\t&cmd_pipe_pane_entry,\n\t&cmd_previous_layout_entry,\n\t&cmd_previous_window_entry,\n\t&cmd_refresh_client_entry,\n\t&cmd_rename_session_entry,\n\t&cmd_rename_window_entry,\n\t&cmd_resize_pane_entry,\n\t&cmd_resize_window_entry,\n\t&cmd_respawn_pane_entry,\n\t&cmd_respawn_window_entry,\n\t&cmd_rotate_window_entry,\n\t&cmd_run_shell_entry,\n\t&cmd_save_buffer_entry,\n\t&cmd_select_layout_entry,\n\t&cmd_select_pane_entry,\n\t&cmd_select_window_entry,\n\t&cmd_send_keys_entry,\n\t&cmd_send_prefix_entry,\n\t&cmd_server_access_entry,\n\t&cmd_set_buffer_entry,\n\t&cmd_set_environment_entry,\n\t&cmd_set_hook_entry,\n\t&cmd_set_option_entry,\n\t&cmd_set_window_option_entry,\n\t&cmd_show_buffer_entry,\n\t&cmd_show_environment_entry,\n\t&cmd_show_hooks_entry,\n\t&cmd_show_messages_entry,\n\t&cmd_show_options_entry,\n\t&cmd_show_prompt_history_entry,\n\t&cmd_show_window_options_entry,\n\t&cmd_source_file_entry,\n\t&cmd_split_window_entry,\n\t&cmd_start_server_entry,\n\t&cmd_suspend_client_entry,\n\t&cmd_swap_pane_entry,\n\t&cmd_swap_window_entry,\n\t&cmd_switch_client_entry,\n\t&cmd_unbind_key_entry,\n\t&cmd_unlink_window_entry,\n\t&cmd_wait_for_entry,\n\tNULL\n};\n\n/* Instance of a command. */\nstruct cmd {\n\tconst struct cmd_entry\t *entry;\n\tstruct args\t\t *args;\n\tu_int\t\t\t  group;\n\n\tchar\t\t\t *file;\n\tu_int\t\t\t  line;\n\n\tTAILQ_ENTRY(cmd)\t  qentry;\n};\nTAILQ_HEAD(cmds, cmd);\n\n/* Next group number for new command list. */\nstatic u_int cmd_list_next_group = 1;\n\n/* Log an argument vector. */\nvoid printflike(3, 4)\ncmd_log_argv(int argc, char **argv, const char *fmt, ...)\n{\n\tchar\t*prefix;\n\tva_list\t ap;\n\tint\t i;\n\n\tva_start(ap, fmt);\n\txvasprintf(&prefix, fmt, ap);\n\tva_end(ap);\n\n\tfor (i = 0; i < argc; i++)\n\t\tlog_debug(\"%s: argv[%d]=%s\", prefix, i, argv[i]);\n\tfree(prefix);\n}\n\n/* Prepend to an argument vector. */\nvoid\ncmd_prepend_argv(int *argc, char ***argv, const char *arg)\n{\n\tchar\t**new_argv;\n\tint\t  i;\n\n\tnew_argv = xreallocarray(NULL, (*argc) + 1, sizeof *new_argv);\n\tnew_argv[0] = xstrdup(arg);\n\tfor (i = 0; i < *argc; i++)\n\t\tnew_argv[1 + i] = (*argv)[i];\n\n\tfree(*argv);\n\t*argv = new_argv;\n\t(*argc)++;\n}\n\n/* Append to an argument vector. */\nvoid\ncmd_append_argv(int *argc, char ***argv, const char *arg)\n{\n\t*argv = xreallocarray(*argv, (*argc) + 1, sizeof **argv);\n\t(*argv)[(*argc)++] = xstrdup(arg);\n}\n\n/* Pack an argument vector up into a buffer. */\nint\ncmd_pack_argv(int argc, char **argv, char *buf, size_t len)\n{\n\tsize_t\targlen;\n\tint\ti;\n\n\tif (argc == 0)\n\t\treturn (0);\n\tcmd_log_argv(argc, argv, \"%s\", __func__);\n\n\t*buf = '\\0';\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strlcpy(buf, argv[i], len) >= len)\n\t\t\treturn (-1);\n\t\targlen = strlen(argv[i]) + 1;\n\t\tbuf += arglen;\n\t\tlen -= arglen;\n\t}\n\n\treturn (0);\n}\n\n/* Unpack an argument vector from a packed buffer. */\nint\ncmd_unpack_argv(char *buf, size_t len, int argc, char ***argv)\n{\n\tint\ti;\n\tsize_t\targlen;\n\n\tif (argc == 0)\n\t\treturn (0);\n\t*argv = xcalloc(argc, sizeof **argv);\n\n\tbuf[len - 1] = '\\0';\n\tfor (i = 0; i < argc; i++) {\n\t\tif (len == 0) {\n\t\t\tcmd_free_argv(argc, *argv);\n\t\t\treturn (-1);\n\t\t}\n\n\t\targlen = strlen(buf) + 1;\n\t\t(*argv)[i] = xstrdup(buf);\n\n\t\tbuf += arglen;\n\t\tlen -= arglen;\n\t}\n\tcmd_log_argv(argc, *argv, \"%s\", __func__);\n\n\treturn (0);\n}\n\n/* Copy an argument vector, ensuring it is terminated by NULL. */\nchar **\ncmd_copy_argv(int argc, char **argv)\n{\n\tchar\t**new_argv;\n\tint\t  i;\n\n\tif (argc == 0)\n\t\treturn (NULL);\n\tnew_argv = xcalloc(argc + 1, sizeof *new_argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tif (argv[i] != NULL)\n\t\t\tnew_argv[i] = xstrdup(argv[i]);\n\t}\n\treturn (new_argv);\n}\n\n/* Free an argument vector. */\nvoid\ncmd_free_argv(int argc, char **argv)\n{\n\tint\ti;\n\n\tif (argc == 0)\n\t\treturn;\n\tfor (i = 0; i < argc; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}\n\n/* Convert argument vector to a string. */\nchar *\ncmd_stringify_argv(int argc, char **argv)\n{\n\tchar\t*buf = NULL, *s;\n\tsize_t\t len = 0;\n\tint\t i;\n\n\tif (argc == 0)\n\t\treturn (xstrdup(\"\"));\n\n\tfor (i = 0; i < argc; i++) {\n\t\ts = args_escape(argv[i]);\n\t\tlog_debug(\"%s: %u %s = %s\", __func__, i, argv[i], s);\n\n\t\tlen += strlen(s) + 1;\n\t\tbuf = xrealloc(buf, len);\n\n\t\tif (i == 0)\n\t\t\t*buf = '\\0';\n\t\telse\n\t\t\tstrlcat(buf, \" \", len);\n\t\tstrlcat(buf, s, len);\n\n\t\tfree(s);\n\t}\n\treturn (buf);\n}\n\n/* Get entry for command. */\nconst struct cmd_entry *\ncmd_get_entry(struct cmd *cmd)\n{\n\treturn (cmd->entry);\n}\n\n/* Get arguments for command. */\nstruct args *\ncmd_get_args(struct cmd *cmd)\n{\n\treturn (cmd->args);\n}\n\n/* Get group for command. */\nu_int\ncmd_get_group(struct cmd *cmd)\n{\n\treturn (cmd->group);\n}\n\n/* Get file and line for command. */\nvoid\ncmd_get_source(struct cmd *cmd, const char **file, u_int *line)\n{\n\tif (file != NULL)\n\t\t*file = cmd->file;\n\tif (line != NULL)\n\t\t*line = cmd->line;\n}\n\n/* Look for an alias for a command. */\nchar *\ncmd_get_alias(const char *name)\n{\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tunion options_value\t\t*ov;\n\tsize_t\t\t\t\t wanted, n;\n\tconst char\t\t\t*equals;\n\n\to = options_get_only(global_options, \"command-alias\");\n\tif (o == NULL)\n\t\treturn (NULL);\n\twanted = strlen(name);\n\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tov = options_array_item_value(a);\n\n\t\tequals = strchr(ov->string, '=');\n\t\tif (equals != NULL) {\n\t\t\tn = equals - ov->string;\n\t\t\tif (n == wanted && strncmp(name, ov->string, n) == 0)\n\t\t\t\treturn (xstrdup(equals + 1));\n\t\t}\n\n\t\ta = options_array_next(a);\n\t}\n\treturn (NULL);\n}\n\n/* Look up a command entry by name. */\nstatic const struct cmd_entry *\ncmd_find(const char *name, char **cause)\n{\n\tconst struct cmd_entry\t**loop, *entry, *found = NULL;\n\tint\t\t\t  ambiguous;\n\tchar\t\t\t  s[8192];\n\n\tambiguous = 0;\n\tfor (loop = cmd_table; *loop != NULL; loop++) {\n\t\tentry = *loop;\n\t\tif (entry->alias != NULL && strcmp(entry->alias, name) == 0) {\n\t\t\tambiguous = 0;\n\t\t\tfound = entry;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strncmp(entry->name, name, strlen(name)) != 0)\n\t\t\tcontinue;\n\t\tif (found != NULL)\n\t\t\tambiguous = 1;\n\t\tfound = entry;\n\n\t\tif (strcmp(entry->name, name) == 0)\n\t\t\tbreak;\n\t}\n\tif (ambiguous)\n\t\tgoto ambiguous;\n\tif (found == NULL) {\n\t\txasprintf(cause, \"unknown command: %s\", name);\n\t\treturn (NULL);\n\t}\n\treturn (found);\n\nambiguous:\n\t*s = '\\0';\n\tfor (loop = cmd_table; *loop != NULL; loop++) {\n\t\tentry = *loop;\n\t\tif (strncmp(entry->name, name, strlen(name)) != 0)\n\t\t\tcontinue;\n\t\tif (strlcat(s, entry->name, sizeof s) >= sizeof s)\n\t\t\tbreak;\n\t\tif (strlcat(s, \", \", sizeof s) >= sizeof s)\n\t\t\tbreak;\n\t}\n\ts[strlen(s) - 2] = '\\0';\n\txasprintf(cause, \"ambiguous command: %s, could be: %s\", name, s);\n\treturn (NULL);\n}\n\n/* Parse a single command from an argument vector. */\nstruct cmd *\ncmd_parse(struct args_value *values, u_int count, const char *file, u_int line,\n    char **cause)\n{\n\tconst struct cmd_entry\t*entry;\n\tstruct cmd\t\t*cmd;\n\tstruct args\t\t*args;\n\tchar\t\t\t*error = NULL;\n\n\tif (count == 0 || values[0].type != ARGS_STRING) {\n\t\txasprintf(cause, \"no command\");\n\t\treturn (NULL);\n\t}\n\tentry = cmd_find(values[0].string, cause);\n\tif (entry == NULL)\n\t\treturn (NULL);\n\n\targs = args_parse(&entry->args, values, count, &error);\n\tif (args == NULL && error == NULL) {\n\t\txasprintf(cause, \"usage: %s %s\", entry->name, entry->usage);\n\t\treturn (NULL);\n\t}\n\tif (args == NULL) {\n\t\txasprintf(cause, \"command %s: %s\", entry->name, error);\n\t\tfree(error);\n\t\treturn (NULL);\n\t}\n\n\tcmd = xcalloc(1, sizeof *cmd);\n\tcmd->entry = entry;\n\tcmd->args = args;\n\n\tif (file != NULL)\n\t\tcmd->file = xstrdup(file);\n\tcmd->line = line;\n\n\treturn (cmd);\n}\n\n/* Free a command. */\nvoid\ncmd_free(struct cmd *cmd)\n{\n\tfree(cmd->file);\n\n\targs_free(cmd->args);\n\tfree(cmd);\n}\n\n/* Copy a command. */\nstruct cmd *\ncmd_copy(struct cmd *cmd, int argc, char **argv)\n{\n\tstruct cmd\t*new_cmd;\n\n\tnew_cmd = xcalloc(1, sizeof *new_cmd);\n\tnew_cmd->entry = cmd->entry;\n\tnew_cmd->args = args_copy(cmd->args, argc, argv);\n\n\tif (cmd->file != NULL)\n\t\tnew_cmd->file = xstrdup(cmd->file);\n\tnew_cmd->line = cmd->line;\n\n\treturn (new_cmd);\n}\n\n/* Get a command as a string. */\nchar *\ncmd_print(struct cmd *cmd)\n{\n\tchar\t*out, *s;\n\n\ts = args_print(cmd->args);\n\tif (*s != '\\0')\n\t\txasprintf(&out, \"%s %s\", cmd->entry->name, s);\n\telse\n\t\tout = xstrdup(cmd->entry->name);\n\tfree(s);\n\n\treturn (out);\n}\n\n/* Create a new command list. */\nstruct cmd_list *\ncmd_list_new(void)\n{\n\tstruct cmd_list\t*cmdlist;\n\n\tcmdlist = xcalloc(1, sizeof *cmdlist);\n\tcmdlist->references = 1;\n\tcmdlist->group = cmd_list_next_group++;\n\tcmdlist->list = xcalloc(1, sizeof *cmdlist->list);\n\tTAILQ_INIT(cmdlist->list);\n\treturn (cmdlist);\n}\n\n/* Append a command to a command list. */\nvoid\ncmd_list_append(struct cmd_list *cmdlist, struct cmd *cmd)\n{\n\tcmd->group = cmdlist->group;\n\tTAILQ_INSERT_TAIL(cmdlist->list, cmd, qentry);\n}\n\n/* Append all commands from one list to another.  */\nvoid\ncmd_list_append_all(struct cmd_list *cmdlist, struct cmd_list *from)\n{\n\tstruct cmd\t*cmd;\n\n\tTAILQ_FOREACH(cmd, from->list, qentry)\n\t\tcmd->group = cmdlist->group;\n\tTAILQ_CONCAT(cmdlist->list, from->list, qentry);\n}\n\n/* Move all commands from one command list to another. */\nvoid\ncmd_list_move(struct cmd_list *cmdlist, struct cmd_list *from)\n{\n\tTAILQ_CONCAT(cmdlist->list, from->list, qentry);\n\tcmdlist->group = cmd_list_next_group++;\n}\n\n/* Free a command list. */\nvoid\ncmd_list_free(struct cmd_list *cmdlist)\n{\n\tstruct cmd\t*cmd, *cmd1;\n\n\tif (--cmdlist->references != 0)\n\t\treturn;\n\n\tTAILQ_FOREACH_SAFE(cmd, cmdlist->list, qentry, cmd1) {\n\t\tTAILQ_REMOVE(cmdlist->list, cmd, qentry);\n\t\tcmd_free(cmd);\n\t}\n\tfree(cmdlist->list);\n\tfree(cmdlist);\n}\n\n/* Copy a command list, expanding %s in arguments. */\nstruct cmd_list *\ncmd_list_copy(struct cmd_list *cmdlist, int argc, char **argv)\n{\n\tstruct cmd\t*cmd;\n\tstruct cmd_list\t*new_cmdlist;\n\tstruct cmd\t*new_cmd;\n\tu_int\t\t group = cmdlist->group;\n\tchar\t\t*s;\n\n\ts = cmd_list_print(cmdlist, 0);\n\tlog_debug(\"%s: %s\", __func__, s);\n\tfree(s);\n\n\tnew_cmdlist = cmd_list_new();\n\tTAILQ_FOREACH(cmd, cmdlist->list, qentry) {\n\t\tif (cmd->group != group) {\n\t\t\tnew_cmdlist->group = cmd_list_next_group++;\n\t\t\tgroup = cmd->group;\n\t\t}\n\t\tnew_cmd = cmd_copy(cmd, argc, argv);\n\t\tcmd_list_append(new_cmdlist, new_cmd);\n\t}\n\n\ts = cmd_list_print(new_cmdlist, 0);\n\tlog_debug(\"%s: %s\", __func__, s);\n\tfree(s);\n\n\treturn (new_cmdlist);\n}\n\n/* Get a command list as a string. */\nchar *\ncmd_list_print(struct cmd_list *cmdlist, int escaped)\n{\n\tstruct cmd\t*cmd, *next;\n\tchar\t\t*buf, *this;\n\tsize_t\t\t len;\n\n\tlen = 1;\n\tbuf = xcalloc(1, len);\n\n\tTAILQ_FOREACH(cmd, cmdlist->list, qentry) {\n\t\tthis = cmd_print(cmd);\n\n\t\tlen += strlen(this) + 6;\n\t\tbuf = xrealloc(buf, len);\n\n\t\tstrlcat(buf, this, len);\n\n\t\tnext = TAILQ_NEXT(cmd, qentry);\n\t\tif (next != NULL) {\n\t\t\tif (cmd->group != next->group) {\n\t\t\t\tif (escaped)\n\t\t\t\t\tstrlcat(buf, \" \\\\;\\\\; \", len);\n\t\t\t\telse\n\t\t\t\t\tstrlcat(buf, \" ;; \", len);\n\t\t\t} else {\n\t\t\t\tif (escaped)\n\t\t\t\t\tstrlcat(buf, \" \\\\; \", len);\n\t\t\t\telse\n\t\t\t\t\tstrlcat(buf, \" ; \", len);\n\t\t\t}\n\t\t}\n\n\t\tfree(this);\n\t}\n\n\treturn (buf);\n}\n\n/* Get first command in list. */\nstruct cmd *\ncmd_list_first(struct cmd_list *cmdlist)\n{\n\treturn (TAILQ_FIRST(cmdlist->list));\n}\n\n/* Get next command in list. */\nstruct cmd *\ncmd_list_next(struct cmd *cmd)\n{\n\treturn (TAILQ_NEXT(cmd, qentry));\n}\n\n/* Do all of the commands in this command list have this flag? */\nint\ncmd_list_all_have(struct cmd_list *cmdlist, int flag)\n{\n\tstruct cmd\t*cmd;\n\n\tTAILQ_FOREACH(cmd, cmdlist->list, qentry) {\n\t\tif (~cmd->entry->flags & flag)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}\n\n/* Do any of the commands in this command list have this flag? */\nint\ncmd_list_any_have(struct cmd_list *cmdlist, int flag)\n{\n\tstruct cmd\t*cmd;\n\n\tTAILQ_FOREACH(cmd, cmdlist->list, qentry) {\n\t\tif (cmd->entry->flags & flag)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Adjust current mouse position for a pane. */\nint\ncmd_mouse_at(struct window_pane *wp, struct mouse_event *m, u_int *xp,\n    u_int *yp, int last)\n{\n\tu_int\tx, y;\n\n\tif (last) {\n\t\tx = m->lx + m->ox;\n\t\ty = m->ly + m->oy;\n\t} else {\n\t\tx = m->x + m->ox;\n\t\ty = m->y + m->oy;\n\t}\n\tlog_debug(\"%s: x=%u, y=%u%s\", __func__, x, y, last ? \" (last)\" : \"\");\n\n\tif (m->statusat == 0 && y >= m->statuslines)\n\t\ty -= m->statuslines;\n\n\tif (x < wp->xoff || x >= wp->xoff + wp->sx)\n\t\treturn (-1);\n\tif (y < wp->yoff || y >= wp->yoff + wp->sy)\n\t\treturn (-1);\n\n\tif (xp != NULL)\n\t\t*xp = x - wp->xoff;\n\tif (yp != NULL)\n\t\t*yp = y - wp->yoff;\n\treturn (0);\n}\n\n/* Get current mouse window if any. */\nstruct winlink *\ncmd_mouse_window(struct mouse_event *m, struct session **sp)\n{\n\tstruct session\t*s;\n\tstruct window\t*w;\n\tstruct winlink\t*wl;\n\n\tif (!m->valid)\n\t\treturn (NULL);\n\tif (m->s == -1 || (s = session_find_by_id(m->s)) == NULL)\n\t\treturn (NULL);\n\tif (m->w == -1)\n\t\twl = s->curw;\n\telse {\n\t\tif ((w = window_find_by_id(m->w)) == NULL)\n\t\t\treturn (NULL);\n\t\twl = winlink_find_by_window(&s->windows, w);\n\t}\n\tif (sp != NULL)\n\t\t*sp = s;\n\treturn (wl);\n}\n\n/* Get current mouse pane if any. */\nstruct window_pane *\ncmd_mouse_pane(struct mouse_event *m, struct session **sp,\n    struct winlink **wlp)\n{\n\tstruct winlink\t\t*wl;\n\tstruct window_pane     \t*wp;\n\n\tif ((wl = cmd_mouse_window(m, sp)) == NULL)\n\t\treturn (NULL);\n\tif (m->wp == -1)\n\t\twp = wl->window->active;\n\telse {\n\t\tif ((wp = window_pane_find_by_id(m->wp)) == NULL)\n\t\t\treturn (NULL);\n\t\tif (!window_has_pane(wl->window, wp))\n\t\t\treturn (NULL);\n\t}\n\n\tif (wlp != NULL)\n\t\t*wlp = wl;\n\treturn (wp);\n}\n\n/* Replace the first %% or %idx in template by s. */\nchar *\ncmd_template_replace(const char *template, const char *s, int idx)\n{\n\tchar\t\t ch, *buf;\n\tconst char\t*ptr, *cp, quote[] = \"\\\"\\\\$;~\";\n\tint\t\t replaced, quoted;\n\tsize_t\t\t len;\n\n\tif (strchr(template, '%') == NULL)\n\t\treturn (xstrdup(template));\n\n\tbuf = xmalloc(1);\n\t*buf = '\\0';\n\tlen = 0;\n\treplaced = 0;\n\n\tptr = template;\n\twhile (*ptr != '\\0') {\n\t\tswitch (ch = *ptr++) {\n\t\tcase '%':\n\t\t\tif (*ptr < '1' || *ptr > '9' || *ptr - '0' != idx) {\n\t\t\t\tif (*ptr != '%' || replaced)\n\t\t\t\t\tbreak;\n\t\t\t\treplaced = 1;\n\t\t\t}\n\t\t\tptr++;\n\n\t\t\tquoted = (*ptr == '%');\n\t\t\tif (quoted)\n\t\t\t\tptr++;\n\n\t\t\tbuf = xrealloc(buf, len + (strlen(s) * 3) + 1);\n\t\t\tfor (cp = s; *cp != '\\0'; cp++) {\n\t\t\t\tif (quoted && strchr(quote, *cp) != NULL)\n\t\t\t\t\tbuf[len++] = '\\\\';\n\t\t\t\tbuf[len++] = *cp;\n\t\t\t}\n\t\t\tbuf[len] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn (buf);\n}\n"
        },
        {
          "name": "colour.c",
          "type": "blob",
          "size": 30.9931640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2016 Avi Halachmi <avihpit@yahoo.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"tmux.h\"\n\nstatic int\ncolour_dist_sq(int R, int G, int B, int r, int g, int b)\n{\n\treturn ((R - r) * (R - r) + (G - g) * (G - g) + (B - b) * (B - b));\n}\n\nstatic int\ncolour_to_6cube(int v)\n{\n\tif (v < 48)\n\t\treturn (0);\n\tif (v < 114)\n\t\treturn (1);\n\treturn ((v - 35) / 40);\n}\n\n/*\n * Convert an RGB triplet to the xterm(1) 256 colour palette.\n *\n * xterm provides a 6x6x6 colour cube (16 - 231) and 24 greys (232 - 255). We\n * map our RGB colour to the closest in the cube, also work out the closest\n * grey, and use the nearest of the two.\n *\n * Note that the xterm has much lower resolution for darker colours (they are\n * not evenly spread out), so our 6 levels are not evenly spread: 0x0, 0x5f\n * (95), 0x87 (135), 0xaf (175), 0xd7 (215) and 0xff (255). Greys are more\n * evenly spread (8, 18, 28 ... 238).\n */\nint\ncolour_find_rgb(u_char r, u_char g, u_char b)\n{\n\tstatic const int\tq2c[6] = { 0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff };\n\tint\t\t\tqr, qg, qb, cr, cg, cb, d, idx;\n\tint\t\t\tgrey_avg, grey_idx, grey;\n\n\t/* Map RGB to 6x6x6 cube. */\n\tqr = colour_to_6cube(r); cr = q2c[qr];\n\tqg = colour_to_6cube(g); cg = q2c[qg];\n\tqb = colour_to_6cube(b); cb = q2c[qb];\n\n\t/* If we have hit the colour exactly, return early. */\n\tif (cr == r && cg == g && cb == b)\n\t\treturn ((16 + (36 * qr) + (6 * qg) + qb) | COLOUR_FLAG_256);\n\n\t/* Work out the closest grey (average of RGB). */\n\tgrey_avg = (r + g + b) / 3;\n\tif (grey_avg > 238)\n\t\tgrey_idx = 23;\n\telse\n\t\tgrey_idx = (grey_avg - 3) / 10;\n\tgrey = 8 + (10 * grey_idx);\n\n\t/* Is grey or 6x6x6 colour closest? */\n\td = colour_dist_sq(cr, cg, cb, r, g, b);\n\tif (colour_dist_sq(grey, grey, grey, r, g, b) < d)\n\t\tidx = 232 + grey_idx;\n\telse\n\t\tidx = 16 + (36 * qr) + (6 * qg) + qb;\n\treturn (idx | COLOUR_FLAG_256);\n}\n\n/* Join RGB into a colour. */\nint\ncolour_join_rgb(u_char r, u_char g, u_char b)\n{\n\treturn ((((int)((r) & 0xff)) << 16) |\n\t    (((int)((g) & 0xff)) << 8) |\n\t    (((int)((b) & 0xff))) | COLOUR_FLAG_RGB);\n}\n\n/* Split colour into RGB. */\nvoid\ncolour_split_rgb(int c, u_char *r, u_char *g, u_char *b)\n{\n\t*r = (c >> 16) & 0xff;\n\t*g = (c >> 8) & 0xff;\n\t*b = c & 0xff;\n}\n\n/* Force colour to RGB if not already. */\nint\ncolour_force_rgb(int c)\n{\n\tif (c & COLOUR_FLAG_RGB)\n\t\treturn (c);\n\tif (c & COLOUR_FLAG_256)\n\t\treturn (colour_256toRGB(c));\n\tif (c >= 0 && c <= 7)\n\t\treturn (colour_256toRGB(c));\n\tif (c >= 90 && c <= 97)\n\t\treturn (colour_256toRGB(8 + c - 90));\n\treturn (-1);\n}\n\n/* Convert colour to a string. */\nconst char *\ncolour_tostring(int c)\n{\n\tstatic char\ts[32];\n\tu_char\t\tr, g, b;\n\n\tif (c == -1)\n\t\treturn (\"none\");\n\n\tif (c & COLOUR_FLAG_RGB) {\n\t\tcolour_split_rgb(c, &r, &g, &b);\n\t\txsnprintf(s, sizeof s, \"#%02x%02x%02x\", r, g, b);\n\t\treturn (s);\n\t}\n\n\tif (c & COLOUR_FLAG_256) {\n\t\txsnprintf(s, sizeof s, \"colour%u\", c & 0xff);\n\t\treturn (s);\n\t}\n\n\tswitch (c) {\n\tcase 0:\n\t\treturn (\"black\");\n\tcase 1:\n\t\treturn (\"red\");\n\tcase 2:\n\t\treturn (\"green\");\n\tcase 3:\n\t\treturn (\"yellow\");\n\tcase 4:\n\t\treturn (\"blue\");\n\tcase 5:\n\t\treturn (\"magenta\");\n\tcase 6:\n\t\treturn (\"cyan\");\n\tcase 7:\n\t\treturn (\"white\");\n\tcase 8:\n\t\treturn (\"default\");\n\tcase 9:\n\t\treturn (\"terminal\");\n\tcase 90:\n\t\treturn (\"brightblack\");\n\tcase 91:\n\t\treturn (\"brightred\");\n\tcase 92:\n\t\treturn (\"brightgreen\");\n\tcase 93:\n\t\treturn (\"brightyellow\");\n\tcase 94:\n\t\treturn (\"brightblue\");\n\tcase 95:\n\t\treturn (\"brightmagenta\");\n\tcase 96:\n\t\treturn (\"brightcyan\");\n\tcase 97:\n\t\treturn (\"brightwhite\");\n\t}\n\treturn (\"invalid\");\n}\n\n/* Convert colour from string. */\nint\ncolour_fromstring(const char *s)\n{\n\tconst char\t*errstr;\n\tconst char\t*cp;\n\tint\t\t n;\n\tu_char\t\t r, g, b;\n\n\tif (*s == '#' && strlen(s) == 7) {\n\t\tfor (cp = s + 1; isxdigit((u_char) *cp); cp++)\n\t\t\t;\n\t\tif (*cp != '\\0')\n\t\t\treturn (-1);\n\t\tn = sscanf(s + 1, \"%2hhx%2hhx%2hhx\", &r, &g, &b);\n\t\tif (n != 3)\n\t\t\treturn (-1);\n\t\treturn (colour_join_rgb(r, g, b));\n\t}\n\n\tif (strncasecmp(s, \"colour\", (sizeof \"colour\") - 1) == 0) {\n\t\tn = strtonum(s + (sizeof \"colour\") - 1, 0, 255, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (-1);\n\t\treturn (n | COLOUR_FLAG_256);\n\t}\n\tif (strncasecmp(s, \"color\", (sizeof \"color\") - 1) == 0) {\n\t\tn = strtonum(s + (sizeof \"color\") - 1, 0, 255, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (-1);\n\t\treturn (n | COLOUR_FLAG_256);\n\t}\n\n\tif (strcasecmp(s, \"default\") == 0)\n\t\treturn (8);\n\tif (strcasecmp(s, \"terminal\") == 0)\n\t\treturn (9);\n\n\tif (strcasecmp(s, \"black\") == 0 || strcmp(s, \"0\") == 0)\n\t\treturn (0);\n\tif (strcasecmp(s, \"red\") == 0 || strcmp(s, \"1\") == 0)\n\t\treturn (1);\n\tif (strcasecmp(s, \"green\") == 0 || strcmp(s, \"2\") == 0)\n\t\treturn (2);\n\tif (strcasecmp(s, \"yellow\") == 0 || strcmp(s, \"3\") == 0)\n\t\treturn (3);\n\tif (strcasecmp(s, \"blue\") == 0 || strcmp(s, \"4\") == 0)\n\t\treturn (4);\n\tif (strcasecmp(s, \"magenta\") == 0 || strcmp(s, \"5\") == 0)\n\t\treturn (5);\n\tif (strcasecmp(s, \"cyan\") == 0 || strcmp(s, \"6\") == 0)\n\t\treturn (6);\n\tif (strcasecmp(s, \"white\") == 0 || strcmp(s, \"7\") == 0)\n\t\treturn (7);\n\tif (strcasecmp(s, \"brightblack\") == 0 || strcmp(s, \"90\") == 0)\n\t\treturn (90);\n\tif (strcasecmp(s, \"brightred\") == 0 || strcmp(s, \"91\") == 0)\n\t\treturn (91);\n\tif (strcasecmp(s, \"brightgreen\") == 0 || strcmp(s, \"92\") == 0)\n\t\treturn (92);\n\tif (strcasecmp(s, \"brightyellow\") == 0 || strcmp(s, \"93\") == 0)\n\t\treturn (93);\n\tif (strcasecmp(s, \"brightblue\") == 0 || strcmp(s, \"94\") == 0)\n\t\treturn (94);\n\tif (strcasecmp(s, \"brightmagenta\") == 0 || strcmp(s, \"95\") == 0)\n\t\treturn (95);\n\tif (strcasecmp(s, \"brightcyan\") == 0 || strcmp(s, \"96\") == 0)\n\t\treturn (96);\n\tif (strcasecmp(s, \"brightwhite\") == 0 || strcmp(s, \"97\") == 0)\n\t\treturn (97);\n\treturn (colour_byname(s));\n}\n\n/* Convert 256 colour to RGB colour. */\nint\ncolour_256toRGB(int c)\n{\n\tstatic const int table[256] = {\n\t\t0x000000, 0x800000, 0x008000, 0x808000,\n\t\t0x000080, 0x800080, 0x008080, 0xc0c0c0,\n\t\t0x808080, 0xff0000, 0x00ff00, 0xffff00,\n\t\t0x0000ff, 0xff00ff, 0x00ffff, 0xffffff,\n\t\t0x000000, 0x00005f, 0x000087, 0x0000af,\n\t\t0x0000d7, 0x0000ff, 0x005f00, 0x005f5f,\n\t\t0x005f87, 0x005faf, 0x005fd7, 0x005fff,\n\t\t0x008700, 0x00875f, 0x008787, 0x0087af,\n\t\t0x0087d7, 0x0087ff, 0x00af00, 0x00af5f,\n\t\t0x00af87, 0x00afaf, 0x00afd7, 0x00afff,\n\t\t0x00d700, 0x00d75f, 0x00d787, 0x00d7af,\n\t\t0x00d7d7, 0x00d7ff, 0x00ff00, 0x00ff5f,\n\t\t0x00ff87, 0x00ffaf, 0x00ffd7, 0x00ffff,\n\t\t0x5f0000, 0x5f005f, 0x5f0087, 0x5f00af,\n\t\t0x5f00d7, 0x5f00ff, 0x5f5f00, 0x5f5f5f,\n\t\t0x5f5f87, 0x5f5faf, 0x5f5fd7, 0x5f5fff,\n\t\t0x5f8700, 0x5f875f, 0x5f8787, 0x5f87af,\n\t\t0x5f87d7, 0x5f87ff, 0x5faf00, 0x5faf5f,\n\t\t0x5faf87, 0x5fafaf, 0x5fafd7, 0x5fafff,\n\t\t0x5fd700, 0x5fd75f, 0x5fd787, 0x5fd7af,\n\t\t0x5fd7d7, 0x5fd7ff, 0x5fff00, 0x5fff5f,\n\t\t0x5fff87, 0x5fffaf, 0x5fffd7, 0x5fffff,\n\t\t0x870000, 0x87005f, 0x870087, 0x8700af,\n\t\t0x8700d7, 0x8700ff, 0x875f00, 0x875f5f,\n\t\t0x875f87, 0x875faf, 0x875fd7, 0x875fff,\n\t\t0x878700, 0x87875f, 0x878787, 0x8787af,\n\t\t0x8787d7, 0x8787ff, 0x87af00, 0x87af5f,\n\t\t0x87af87, 0x87afaf, 0x87afd7, 0x87afff,\n\t\t0x87d700, 0x87d75f, 0x87d787, 0x87d7af,\n\t\t0x87d7d7, 0x87d7ff, 0x87ff00, 0x87ff5f,\n\t\t0x87ff87, 0x87ffaf, 0x87ffd7, 0x87ffff,\n\t\t0xaf0000, 0xaf005f, 0xaf0087, 0xaf00af,\n\t\t0xaf00d7, 0xaf00ff, 0xaf5f00, 0xaf5f5f,\n\t\t0xaf5f87, 0xaf5faf, 0xaf5fd7, 0xaf5fff,\n\t\t0xaf8700, 0xaf875f, 0xaf8787, 0xaf87af,\n\t\t0xaf87d7, 0xaf87ff, 0xafaf00, 0xafaf5f,\n\t\t0xafaf87, 0xafafaf, 0xafafd7, 0xafafff,\n\t\t0xafd700, 0xafd75f, 0xafd787, 0xafd7af,\n\t\t0xafd7d7, 0xafd7ff, 0xafff00, 0xafff5f,\n\t\t0xafff87, 0xafffaf, 0xafffd7, 0xafffff,\n\t\t0xd70000, 0xd7005f, 0xd70087, 0xd700af,\n\t\t0xd700d7, 0xd700ff, 0xd75f00, 0xd75f5f,\n\t\t0xd75f87, 0xd75faf, 0xd75fd7, 0xd75fff,\n\t\t0xd78700, 0xd7875f, 0xd78787, 0xd787af,\n\t\t0xd787d7, 0xd787ff, 0xd7af00, 0xd7af5f,\n\t\t0xd7af87, 0xd7afaf, 0xd7afd7, 0xd7afff,\n\t\t0xd7d700, 0xd7d75f, 0xd7d787, 0xd7d7af,\n\t\t0xd7d7d7, 0xd7d7ff, 0xd7ff00, 0xd7ff5f,\n\t\t0xd7ff87, 0xd7ffaf, 0xd7ffd7, 0xd7ffff,\n\t\t0xff0000, 0xff005f, 0xff0087, 0xff00af,\n\t\t0xff00d7, 0xff00ff, 0xff5f00, 0xff5f5f,\n\t\t0xff5f87, 0xff5faf, 0xff5fd7, 0xff5fff,\n\t\t0xff8700, 0xff875f, 0xff8787, 0xff87af,\n\t\t0xff87d7, 0xff87ff, 0xffaf00, 0xffaf5f,\n\t\t0xffaf87, 0xffafaf, 0xffafd7, 0xffafff,\n\t\t0xffd700, 0xffd75f, 0xffd787, 0xffd7af,\n\t\t0xffd7d7, 0xffd7ff, 0xffff00, 0xffff5f,\n\t\t0xffff87, 0xffffaf, 0xffffd7, 0xffffff,\n\t\t0x080808, 0x121212, 0x1c1c1c, 0x262626,\n\t\t0x303030, 0x3a3a3a, 0x444444, 0x4e4e4e,\n\t\t0x585858, 0x626262, 0x6c6c6c, 0x767676,\n\t\t0x808080, 0x8a8a8a, 0x949494, 0x9e9e9e,\n\t\t0xa8a8a8, 0xb2b2b2, 0xbcbcbc, 0xc6c6c6,\n\t\t0xd0d0d0, 0xdadada, 0xe4e4e4, 0xeeeeee\n\t};\n\n\treturn (table[c & 0xff] | COLOUR_FLAG_RGB);\n}\n\n/* Convert 256 colour to 16 colour. */\nint\ncolour_256to16(int c)\n{\n\tstatic const char table[256] = {\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,\n\t\t12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,\n\t\t10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,\n\t\t 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,\n\t\t14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,\n\t\t 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,\n\t\t10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,\n\t\t12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,\n\t\t 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,\n\t\t 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,\n\t\t13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,\n\t\t10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,\n\t\t 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,\n\t\t 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,\n\t\t 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15\n\t};\n\n\treturn (table[c & 0xff]);\n}\n\n/* Get colour by X11 colour name. */\nint\ncolour_byname(const char *name)\n{\n\tstatic const struct {\n\t\tconst char\t*name;\n\t\tint\t\t c;\n\t} colours[] = {\n\t\t{ \"AliceBlue\", 0xf0f8ff },\n\t\t{ \"AntiqueWhite\", 0xfaebd7 },\n\t\t{ \"AntiqueWhite1\", 0xffefdb },\n\t\t{ \"AntiqueWhite2\", 0xeedfcc },\n\t\t{ \"AntiqueWhite3\", 0xcdc0b0 },\n\t\t{ \"AntiqueWhite4\", 0x8b8378 },\n\t\t{ \"BlanchedAlmond\", 0xffebcd },\n\t\t{ \"BlueViolet\", 0x8a2be2 },\n\t\t{ \"CadetBlue\", 0x5f9ea0 },\n\t\t{ \"CadetBlue1\", 0x98f5ff },\n\t\t{ \"CadetBlue2\", 0x8ee5ee },\n\t\t{ \"CadetBlue3\", 0x7ac5cd },\n\t\t{ \"CadetBlue4\", 0x53868b },\n\t\t{ \"CornflowerBlue\", 0x6495ed },\n\t\t{ \"DarkBlue\", 0x00008b },\n\t\t{ \"DarkCyan\", 0x008b8b },\n\t\t{ \"DarkGoldenrod\", 0xb8860b },\n\t\t{ \"DarkGoldenrod1\", 0xffb90f },\n\t\t{ \"DarkGoldenrod2\", 0xeead0e },\n\t\t{ \"DarkGoldenrod3\", 0xcd950c },\n\t\t{ \"DarkGoldenrod4\", 0x8b6508 },\n\t\t{ \"DarkGray\", 0xa9a9a9 },\n\t\t{ \"DarkGreen\", 0x006400 },\n\t\t{ \"DarkGrey\", 0xa9a9a9 },\n\t\t{ \"DarkKhaki\", 0xbdb76b },\n\t\t{ \"DarkMagenta\", 0x8b008b },\n\t\t{ \"DarkOliveGreen\", 0x556b2f },\n\t\t{ \"DarkOliveGreen1\", 0xcaff70 },\n\t\t{ \"DarkOliveGreen2\", 0xbcee68 },\n\t\t{ \"DarkOliveGreen3\", 0xa2cd5a },\n\t\t{ \"DarkOliveGreen4\", 0x6e8b3d },\n\t\t{ \"DarkOrange\", 0xff8c00 },\n\t\t{ \"DarkOrange1\", 0xff7f00 },\n\t\t{ \"DarkOrange2\", 0xee7600 },\n\t\t{ \"DarkOrange3\", 0xcd6600 },\n\t\t{ \"DarkOrange4\", 0x8b4500 },\n\t\t{ \"DarkOrchid\", 0x9932cc },\n\t\t{ \"DarkOrchid1\", 0xbf3eff },\n\t\t{ \"DarkOrchid2\", 0xb23aee },\n\t\t{ \"DarkOrchid3\", 0x9a32cd },\n\t\t{ \"DarkOrchid4\", 0x68228b },\n\t\t{ \"DarkRed\", 0x8b0000 },\n\t\t{ \"DarkSalmon\", 0xe9967a },\n\t\t{ \"DarkSeaGreen\", 0x8fbc8f },\n\t\t{ \"DarkSeaGreen1\", 0xc1ffc1 },\n\t\t{ \"DarkSeaGreen2\", 0xb4eeb4 },\n\t\t{ \"DarkSeaGreen3\", 0x9bcd9b },\n\t\t{ \"DarkSeaGreen4\", 0x698b69 },\n\t\t{ \"DarkSlateBlue\", 0x483d8b },\n\t\t{ \"DarkSlateGray\", 0x2f4f4f },\n\t\t{ \"DarkSlateGray1\", 0x97ffff },\n\t\t{ \"DarkSlateGray2\", 0x8deeee },\n\t\t{ \"DarkSlateGray3\", 0x79cdcd },\n\t\t{ \"DarkSlateGray4\", 0x528b8b },\n\t\t{ \"DarkSlateGrey\", 0x2f4f4f },\n\t\t{ \"DarkTurquoise\", 0x00ced1 },\n\t\t{ \"DarkViolet\", 0x9400d3 },\n\t\t{ \"DeepPink\", 0xff1493 },\n\t\t{ \"DeepPink1\", 0xff1493 },\n\t\t{ \"DeepPink2\", 0xee1289 },\n\t\t{ \"DeepPink3\", 0xcd1076 },\n\t\t{ \"DeepPink4\", 0x8b0a50 },\n\t\t{ \"DeepSkyBlue\", 0x00bfff },\n\t\t{ \"DeepSkyBlue1\", 0x00bfff },\n\t\t{ \"DeepSkyBlue2\", 0x00b2ee },\n\t\t{ \"DeepSkyBlue3\", 0x009acd },\n\t\t{ \"DeepSkyBlue4\", 0x00688b },\n\t\t{ \"DimGray\", 0x696969 },\n\t\t{ \"DimGrey\", 0x696969 },\n\t\t{ \"DodgerBlue\", 0x1e90ff },\n\t\t{ \"DodgerBlue1\", 0x1e90ff },\n\t\t{ \"DodgerBlue2\", 0x1c86ee },\n\t\t{ \"DodgerBlue3\", 0x1874cd },\n\t\t{ \"DodgerBlue4\", 0x104e8b },\n\t\t{ \"FloralWhite\", 0xfffaf0 },\n\t\t{ \"ForestGreen\", 0x228b22 },\n\t\t{ \"GhostWhite\", 0xf8f8ff },\n\t\t{ \"GreenYellow\", 0xadff2f },\n\t\t{ \"HotPink\", 0xff69b4 },\n\t\t{ \"HotPink1\", 0xff6eb4 },\n\t\t{ \"HotPink2\", 0xee6aa7 },\n\t\t{ \"HotPink3\", 0xcd6090 },\n\t\t{ \"HotPink4\", 0x8b3a62 },\n\t\t{ \"IndianRed\", 0xcd5c5c },\n\t\t{ \"IndianRed1\", 0xff6a6a },\n\t\t{ \"IndianRed2\", 0xee6363 },\n\t\t{ \"IndianRed3\", 0xcd5555 },\n\t\t{ \"IndianRed4\", 0x8b3a3a },\n\t\t{ \"LavenderBlush\", 0xfff0f5 },\n\t\t{ \"LavenderBlush1\", 0xfff0f5 },\n\t\t{ \"LavenderBlush2\", 0xeee0e5 },\n\t\t{ \"LavenderBlush3\", 0xcdc1c5 },\n\t\t{ \"LavenderBlush4\", 0x8b8386 },\n\t\t{ \"LawnGreen\", 0x7cfc00 },\n\t\t{ \"LemonChiffon\", 0xfffacd },\n\t\t{ \"LemonChiffon1\", 0xfffacd },\n\t\t{ \"LemonChiffon2\", 0xeee9bf },\n\t\t{ \"LemonChiffon3\", 0xcdc9a5 },\n\t\t{ \"LemonChiffon4\", 0x8b8970 },\n\t\t{ \"LightBlue\", 0xadd8e6 },\n\t\t{ \"LightBlue1\", 0xbfefff },\n\t\t{ \"LightBlue2\", 0xb2dfee },\n\t\t{ \"LightBlue3\", 0x9ac0cd },\n\t\t{ \"LightBlue4\", 0x68838b },\n\t\t{ \"LightCoral\", 0xf08080 },\n\t\t{ \"LightCyan\", 0xe0ffff },\n\t\t{ \"LightCyan1\", 0xe0ffff },\n\t\t{ \"LightCyan2\", 0xd1eeee },\n\t\t{ \"LightCyan3\", 0xb4cdcd },\n\t\t{ \"LightCyan4\", 0x7a8b8b },\n\t\t{ \"LightGoldenrod\", 0xeedd82 },\n\t\t{ \"LightGoldenrod1\", 0xffec8b },\n\t\t{ \"LightGoldenrod2\", 0xeedc82 },\n\t\t{ \"LightGoldenrod3\", 0xcdbe70 },\n\t\t{ \"LightGoldenrod4\", 0x8b814c },\n\t\t{ \"LightGoldenrodYellow\", 0xfafad2 },\n\t\t{ \"LightGray\", 0xd3d3d3 },\n\t\t{ \"LightGreen\", 0x90ee90 },\n\t\t{ \"LightGrey\", 0xd3d3d3 },\n\t\t{ \"LightPink\", 0xffb6c1 },\n\t\t{ \"LightPink1\", 0xffaeb9 },\n\t\t{ \"LightPink2\", 0xeea2ad },\n\t\t{ \"LightPink3\", 0xcd8c95 },\n\t\t{ \"LightPink4\", 0x8b5f65 },\n\t\t{ \"LightSalmon\", 0xffa07a },\n\t\t{ \"LightSalmon1\", 0xffa07a },\n\t\t{ \"LightSalmon2\", 0xee9572 },\n\t\t{ \"LightSalmon3\", 0xcd8162 },\n\t\t{ \"LightSalmon4\", 0x8b5742 },\n\t\t{ \"LightSeaGreen\", 0x20b2aa },\n\t\t{ \"LightSkyBlue\", 0x87cefa },\n\t\t{ \"LightSkyBlue1\", 0xb0e2ff },\n\t\t{ \"LightSkyBlue2\", 0xa4d3ee },\n\t\t{ \"LightSkyBlue3\", 0x8db6cd },\n\t\t{ \"LightSkyBlue4\", 0x607b8b },\n\t\t{ \"LightSlateBlue\", 0x8470ff },\n\t\t{ \"LightSlateGray\", 0x778899 },\n\t\t{ \"LightSlateGrey\", 0x778899 },\n\t\t{ \"LightSteelBlue\", 0xb0c4de },\n\t\t{ \"LightSteelBlue1\", 0xcae1ff },\n\t\t{ \"LightSteelBlue2\", 0xbcd2ee },\n\t\t{ \"LightSteelBlue3\", 0xa2b5cd },\n\t\t{ \"LightSteelBlue4\", 0x6e7b8b },\n\t\t{ \"LightYellow\", 0xffffe0 },\n\t\t{ \"LightYellow1\", 0xffffe0 },\n\t\t{ \"LightYellow2\", 0xeeeed1 },\n\t\t{ \"LightYellow3\", 0xcdcdb4 },\n\t\t{ \"LightYellow4\", 0x8b8b7a },\n\t\t{ \"LimeGreen\", 0x32cd32 },\n\t\t{ \"MediumAquamarine\", 0x66cdaa },\n\t\t{ \"MediumBlue\", 0x0000cd },\n\t\t{ \"MediumOrchid\", 0xba55d3 },\n\t\t{ \"MediumOrchid1\", 0xe066ff },\n\t\t{ \"MediumOrchid2\", 0xd15fee },\n\t\t{ \"MediumOrchid3\", 0xb452cd },\n\t\t{ \"MediumOrchid4\", 0x7a378b },\n\t\t{ \"MediumPurple\", 0x9370db },\n\t\t{ \"MediumPurple1\", 0xab82ff },\n\t\t{ \"MediumPurple2\", 0x9f79ee },\n\t\t{ \"MediumPurple3\", 0x8968cd },\n\t\t{ \"MediumPurple4\", 0x5d478b },\n\t\t{ \"MediumSeaGreen\", 0x3cb371 },\n\t\t{ \"MediumSlateBlue\", 0x7b68ee },\n\t\t{ \"MediumSpringGreen\", 0x00fa9a },\n\t\t{ \"MediumTurquoise\", 0x48d1cc },\n\t\t{ \"MediumVioletRed\", 0xc71585 },\n\t\t{ \"MidnightBlue\", 0x191970 },\n\t\t{ \"MintCream\", 0xf5fffa },\n\t\t{ \"MistyRose\", 0xffe4e1 },\n\t\t{ \"MistyRose1\", 0xffe4e1 },\n\t\t{ \"MistyRose2\", 0xeed5d2 },\n\t\t{ \"MistyRose3\", 0xcdb7b5 },\n\t\t{ \"MistyRose4\", 0x8b7d7b },\n\t\t{ \"NavajoWhite\", 0xffdead },\n\t\t{ \"NavajoWhite1\", 0xffdead },\n\t\t{ \"NavajoWhite2\", 0xeecfa1 },\n\t\t{ \"NavajoWhite3\", 0xcdb38b },\n\t\t{ \"NavajoWhite4\", 0x8b795e },\n\t\t{ \"NavyBlue\", 0x000080 },\n\t\t{ \"OldLace\", 0xfdf5e6 },\n\t\t{ \"OliveDrab\", 0x6b8e23 },\n\t\t{ \"OliveDrab1\", 0xc0ff3e },\n\t\t{ \"OliveDrab2\", 0xb3ee3a },\n\t\t{ \"OliveDrab3\", 0x9acd32 },\n\t\t{ \"OliveDrab4\", 0x698b22 },\n\t\t{ \"OrangeRed\", 0xff4500 },\n\t\t{ \"OrangeRed1\", 0xff4500 },\n\t\t{ \"OrangeRed2\", 0xee4000 },\n\t\t{ \"OrangeRed3\", 0xcd3700 },\n\t\t{ \"OrangeRed4\", 0x8b2500 },\n\t\t{ \"PaleGoldenrod\", 0xeee8aa },\n\t\t{ \"PaleGreen\", 0x98fb98 },\n\t\t{ \"PaleGreen1\", 0x9aff9a },\n\t\t{ \"PaleGreen2\", 0x90ee90 },\n\t\t{ \"PaleGreen3\", 0x7ccd7c },\n\t\t{ \"PaleGreen4\", 0x548b54 },\n\t\t{ \"PaleTurquoise\", 0xafeeee },\n\t\t{ \"PaleTurquoise1\", 0xbbffff },\n\t\t{ \"PaleTurquoise2\", 0xaeeeee },\n\t\t{ \"PaleTurquoise3\", 0x96cdcd },\n\t\t{ \"PaleTurquoise4\", 0x668b8b },\n\t\t{ \"PaleVioletRed\", 0xdb7093 },\n\t\t{ \"PaleVioletRed1\", 0xff82ab },\n\t\t{ \"PaleVioletRed2\", 0xee799f },\n\t\t{ \"PaleVioletRed3\", 0xcd6889 },\n\t\t{ \"PaleVioletRed4\", 0x8b475d },\n\t\t{ \"PapayaWhip\", 0xffefd5 },\n\t\t{ \"PeachPuff\", 0xffdab9 },\n\t\t{ \"PeachPuff1\", 0xffdab9 },\n\t\t{ \"PeachPuff2\", 0xeecbad },\n\t\t{ \"PeachPuff3\", 0xcdaf95 },\n\t\t{ \"PeachPuff4\", 0x8b7765 },\n\t\t{ \"PowderBlue\", 0xb0e0e6 },\n\t\t{ \"RebeccaPurple\", 0x663399 },\n\t\t{ \"RosyBrown\", 0xbc8f8f },\n\t\t{ \"RosyBrown1\", 0xffc1c1 },\n\t\t{ \"RosyBrown2\", 0xeeb4b4 },\n\t\t{ \"RosyBrown3\", 0xcd9b9b },\n\t\t{ \"RosyBrown4\", 0x8b6969 },\n\t\t{ \"RoyalBlue\", 0x4169e1 },\n\t\t{ \"RoyalBlue1\", 0x4876ff },\n\t\t{ \"RoyalBlue2\", 0x436eee },\n\t\t{ \"RoyalBlue3\", 0x3a5fcd },\n\t\t{ \"RoyalBlue4\", 0x27408b },\n\t\t{ \"SaddleBrown\", 0x8b4513 },\n\t\t{ \"SandyBrown\", 0xf4a460 },\n\t\t{ \"SeaGreen\", 0x2e8b57 },\n\t\t{ \"SeaGreen1\", 0x54ff9f },\n\t\t{ \"SeaGreen2\", 0x4eee94 },\n\t\t{ \"SeaGreen3\", 0x43cd80 },\n\t\t{ \"SeaGreen4\", 0x2e8b57 },\n\t\t{ \"SkyBlue\", 0x87ceeb },\n\t\t{ \"SkyBlue1\", 0x87ceff },\n\t\t{ \"SkyBlue2\", 0x7ec0ee },\n\t\t{ \"SkyBlue3\", 0x6ca6cd },\n\t\t{ \"SkyBlue4\", 0x4a708b },\n\t\t{ \"SlateBlue\", 0x6a5acd },\n\t\t{ \"SlateBlue1\", 0x836fff },\n\t\t{ \"SlateBlue2\", 0x7a67ee },\n\t\t{ \"SlateBlue3\", 0x6959cd },\n\t\t{ \"SlateBlue4\", 0x473c8b },\n\t\t{ \"SlateGray\", 0x708090 },\n\t\t{ \"SlateGray1\", 0xc6e2ff },\n\t\t{ \"SlateGray2\", 0xb9d3ee },\n\t\t{ \"SlateGray3\", 0x9fb6cd },\n\t\t{ \"SlateGray4\", 0x6c7b8b },\n\t\t{ \"SlateGrey\", 0x708090 },\n\t\t{ \"SpringGreen\", 0x00ff7f },\n\t\t{ \"SpringGreen1\", 0x00ff7f },\n\t\t{ \"SpringGreen2\", 0x00ee76 },\n\t\t{ \"SpringGreen3\", 0x00cd66 },\n\t\t{ \"SpringGreen4\", 0x008b45 },\n\t\t{ \"SteelBlue\", 0x4682b4 },\n\t\t{ \"SteelBlue1\", 0x63b8ff },\n\t\t{ \"SteelBlue2\", 0x5cacee },\n\t\t{ \"SteelBlue3\", 0x4f94cd },\n\t\t{ \"SteelBlue4\", 0x36648b },\n\t\t{ \"VioletRed\", 0xd02090 },\n\t\t{ \"VioletRed1\", 0xff3e96 },\n\t\t{ \"VioletRed2\", 0xee3a8c },\n\t\t{ \"VioletRed3\", 0xcd3278 },\n\t\t{ \"VioletRed4\", 0x8b2252 },\n\t\t{ \"WebGray\", 0x808080 },\n\t\t{ \"WebGreen\", 0x008000 },\n\t\t{ \"WebGrey\", 0x808080 },\n\t\t{ \"WebMaroon\", 0x800000 },\n\t\t{ \"WebPurple\", 0x800080 },\n\t\t{ \"WhiteSmoke\", 0xf5f5f5 },\n\t\t{ \"X11Gray\", 0xbebebe },\n\t\t{ \"X11Green\", 0x00ff00 },\n\t\t{ \"X11Grey\", 0xbebebe },\n\t\t{ \"X11Maroon\", 0xb03060 },\n\t\t{ \"X11Purple\", 0xa020f0 },\n\t\t{ \"YellowGreen\", 0x9acd32 },\n\t\t{ \"alice blue\", 0xf0f8ff },\n\t\t{ \"antique white\", 0xfaebd7 },\n\t\t{ \"aqua\", 0x00ffff },\n\t\t{ \"aquamarine\", 0x7fffd4 },\n\t\t{ \"aquamarine1\", 0x7fffd4 },\n\t\t{ \"aquamarine2\", 0x76eec6 },\n\t\t{ \"aquamarine3\", 0x66cdaa },\n\t\t{ \"aquamarine4\", 0x458b74 },\n\t\t{ \"azure\", 0xf0ffff },\n\t\t{ \"azure1\", 0xf0ffff },\n\t\t{ \"azure2\", 0xe0eeee },\n\t\t{ \"azure3\", 0xc1cdcd },\n\t\t{ \"azure4\", 0x838b8b },\n\t\t{ \"beige\", 0xf5f5dc },\n\t\t{ \"bisque\", 0xffe4c4 },\n\t\t{ \"bisque1\", 0xffe4c4 },\n\t\t{ \"bisque2\", 0xeed5b7 },\n\t\t{ \"bisque3\", 0xcdb79e },\n\t\t{ \"bisque4\", 0x8b7d6b },\n\t\t{ \"black\", 0x000000 },\n\t\t{ \"blanched almond\", 0xffebcd },\n\t\t{ \"blue violet\", 0x8a2be2 },\n\t\t{ \"blue\", 0x0000ff },\n\t\t{ \"blue1\", 0x0000ff },\n\t\t{ \"blue2\", 0x0000ee },\n\t\t{ \"blue3\", 0x0000cd },\n\t\t{ \"blue4\", 0x00008b },\n\t\t{ \"brown\", 0xa52a2a },\n\t\t{ \"brown1\", 0xff4040 },\n\t\t{ \"brown2\", 0xee3b3b },\n\t\t{ \"brown3\", 0xcd3333 },\n\t\t{ \"brown4\", 0x8b2323 },\n\t\t{ \"burlywood\", 0xdeb887 },\n\t\t{ \"burlywood1\", 0xffd39b },\n\t\t{ \"burlywood2\", 0xeec591 },\n\t\t{ \"burlywood3\", 0xcdaa7d },\n\t\t{ \"burlywood4\", 0x8b7355 },\n\t\t{ \"cadet blue\", 0x5f9ea0 },\n\t\t{ \"chartreuse\", 0x7fff00 },\n\t\t{ \"chartreuse1\", 0x7fff00 },\n\t\t{ \"chartreuse2\", 0x76ee00 },\n\t\t{ \"chartreuse3\", 0x66cd00 },\n\t\t{ \"chartreuse4\", 0x458b00 },\n\t\t{ \"chocolate\", 0xd2691e },\n\t\t{ \"chocolate1\", 0xff7f24 },\n\t\t{ \"chocolate2\", 0xee7621 },\n\t\t{ \"chocolate3\", 0xcd661d },\n\t\t{ \"chocolate4\", 0x8b4513 },\n\t\t{ \"coral\", 0xff7f50 },\n\t\t{ \"coral1\", 0xff7256 },\n\t\t{ \"coral2\", 0xee6a50 },\n\t\t{ \"coral3\", 0xcd5b45 },\n\t\t{ \"coral4\", 0x8b3e2f },\n\t\t{ \"cornflower blue\", 0x6495ed },\n\t\t{ \"cornsilk\", 0xfff8dc },\n\t\t{ \"cornsilk1\", 0xfff8dc },\n\t\t{ \"cornsilk2\", 0xeee8cd },\n\t\t{ \"cornsilk3\", 0xcdc8b1 },\n\t\t{ \"cornsilk4\", 0x8b8878 },\n\t\t{ \"crimson\", 0xdc143c },\n\t\t{ \"cyan\", 0x00ffff },\n\t\t{ \"cyan1\", 0x00ffff },\n\t\t{ \"cyan2\", 0x00eeee },\n\t\t{ \"cyan3\", 0x00cdcd },\n\t\t{ \"cyan4\", 0x008b8b },\n\t\t{ \"dark blue\", 0x00008b },\n\t\t{ \"dark cyan\", 0x008b8b },\n\t\t{ \"dark goldenrod\", 0xb8860b },\n\t\t{ \"dark gray\", 0xa9a9a9 },\n\t\t{ \"dark green\", 0x006400 },\n\t\t{ \"dark grey\", 0xa9a9a9 },\n\t\t{ \"dark khaki\", 0xbdb76b },\n\t\t{ \"dark magenta\", 0x8b008b },\n\t\t{ \"dark olive green\", 0x556b2f },\n\t\t{ \"dark orange\", 0xff8c00 },\n\t\t{ \"dark orchid\", 0x9932cc },\n\t\t{ \"dark red\", 0x8b0000 },\n\t\t{ \"dark salmon\", 0xe9967a },\n\t\t{ \"dark sea green\", 0x8fbc8f },\n\t\t{ \"dark slate blue\", 0x483d8b },\n\t\t{ \"dark slate gray\", 0x2f4f4f },\n\t\t{ \"dark slate grey\", 0x2f4f4f },\n\t\t{ \"dark turquoise\", 0x00ced1 },\n\t\t{ \"dark violet\", 0x9400d3 },\n\t\t{ \"deep pink\", 0xff1493 },\n\t\t{ \"deep sky blue\", 0x00bfff },\n\t\t{ \"dim gray\", 0x696969 },\n\t\t{ \"dim grey\", 0x696969 },\n\t\t{ \"dodger blue\", 0x1e90ff },\n\t\t{ \"firebrick\", 0xb22222 },\n\t\t{ \"firebrick1\", 0xff3030 },\n\t\t{ \"firebrick2\", 0xee2c2c },\n\t\t{ \"firebrick3\", 0xcd2626 },\n\t\t{ \"firebrick4\", 0x8b1a1a },\n\t\t{ \"floral white\", 0xfffaf0 },\n\t\t{ \"forest green\", 0x228b22 },\n\t\t{ \"fuchsia\", 0xff00ff },\n\t\t{ \"gainsboro\", 0xdcdcdc },\n\t\t{ \"ghost white\", 0xf8f8ff },\n\t\t{ \"gold\", 0xffd700 },\n\t\t{ \"gold1\", 0xffd700 },\n\t\t{ \"gold2\", 0xeec900 },\n\t\t{ \"gold3\", 0xcdad00 },\n\t\t{ \"gold4\", 0x8b7500 },\n\t\t{ \"goldenrod\", 0xdaa520 },\n\t\t{ \"goldenrod1\", 0xffc125 },\n\t\t{ \"goldenrod2\", 0xeeb422 },\n\t\t{ \"goldenrod3\", 0xcd9b1d },\n\t\t{ \"goldenrod4\", 0x8b6914 },\n\t\t{ \"green yellow\", 0xadff2f },\n\t\t{ \"green\", 0x00ff00 },\n\t\t{ \"green1\", 0x00ff00 },\n\t\t{ \"green2\", 0x00ee00 },\n\t\t{ \"green3\", 0x00cd00 },\n\t\t{ \"green4\", 0x008b00 },\n\t\t{ \"honeydew\", 0xf0fff0 },\n\t\t{ \"honeydew1\", 0xf0fff0 },\n\t\t{ \"honeydew2\", 0xe0eee0 },\n\t\t{ \"honeydew3\", 0xc1cdc1 },\n\t\t{ \"honeydew4\", 0x838b83 },\n\t\t{ \"hot pink\", 0xff69b4 },\n\t\t{ \"indian red\", 0xcd5c5c },\n\t\t{ \"indigo\", 0x4b0082 },\n\t\t{ \"ivory\", 0xfffff0 },\n\t\t{ \"ivory1\", 0xfffff0 },\n\t\t{ \"ivory2\", 0xeeeee0 },\n\t\t{ \"ivory3\", 0xcdcdc1 },\n\t\t{ \"ivory4\", 0x8b8b83 },\n\t\t{ \"khaki\", 0xf0e68c },\n\t\t{ \"khaki1\", 0xfff68f },\n\t\t{ \"khaki2\", 0xeee685 },\n\t\t{ \"khaki3\", 0xcdc673 },\n\t\t{ \"khaki4\", 0x8b864e },\n\t\t{ \"lavender blush\", 0xfff0f5 },\n\t\t{ \"lavender\", 0xe6e6fa },\n\t\t{ \"lawn green\", 0x7cfc00 },\n\t\t{ \"lemon chiffon\", 0xfffacd },\n\t\t{ \"light blue\", 0xadd8e6 },\n\t\t{ \"light coral\", 0xf08080 },\n\t\t{ \"light cyan\", 0xe0ffff },\n\t\t{ \"light goldenrod yellow\", 0xfafad2 },\n\t\t{ \"light goldenrod\", 0xeedd82 },\n\t\t{ \"light gray\", 0xd3d3d3 },\n\t\t{ \"light green\", 0x90ee90 },\n\t\t{ \"light grey\", 0xd3d3d3 },\n\t\t{ \"light pink\", 0xffb6c1 },\n\t\t{ \"light salmon\", 0xffa07a },\n\t\t{ \"light sea green\", 0x20b2aa },\n\t\t{ \"light sky blue\", 0x87cefa },\n\t\t{ \"light slate blue\", 0x8470ff },\n\t\t{ \"light slate gray\", 0x778899 },\n\t\t{ \"light slate grey\", 0x778899 },\n\t\t{ \"light steel blue\", 0xb0c4de },\n\t\t{ \"light yellow\", 0xffffe0 },\n\t\t{ \"lime green\", 0x32cd32 },\n\t\t{ \"lime\", 0x00ff00 },\n\t\t{ \"linen\", 0xfaf0e6 },\n\t\t{ \"magenta\", 0xff00ff },\n\t\t{ \"magenta1\", 0xff00ff },\n\t\t{ \"magenta2\", 0xee00ee },\n\t\t{ \"magenta3\", 0xcd00cd },\n\t\t{ \"magenta4\", 0x8b008b },\n\t\t{ \"maroon\", 0xb03060 },\n\t\t{ \"maroon1\", 0xff34b3 },\n\t\t{ \"maroon2\", 0xee30a7 },\n\t\t{ \"maroon3\", 0xcd2990 },\n\t\t{ \"maroon4\", 0x8b1c62 },\n\t\t{ \"medium aquamarine\", 0x66cdaa },\n\t\t{ \"medium blue\", 0x0000cd },\n\t\t{ \"medium orchid\", 0xba55d3 },\n\t\t{ \"medium purple\", 0x9370db },\n\t\t{ \"medium sea green\", 0x3cb371 },\n\t\t{ \"medium slate blue\", 0x7b68ee },\n\t\t{ \"medium spring green\", 0x00fa9a },\n\t\t{ \"medium turquoise\", 0x48d1cc },\n\t\t{ \"medium violet red\", 0xc71585 },\n\t\t{ \"midnight blue\", 0x191970 },\n\t\t{ \"mint cream\", 0xf5fffa },\n\t\t{ \"misty rose\", 0xffe4e1 },\n\t\t{ \"moccasin\", 0xffe4b5 },\n\t\t{ \"navajo white\", 0xffdead },\n\t\t{ \"navy blue\", 0x000080 },\n\t\t{ \"navy\", 0x000080 },\n\t\t{ \"old lace\", 0xfdf5e6 },\n\t\t{ \"olive drab\", 0x6b8e23 },\n\t\t{ \"olive\", 0x808000 },\n\t\t{ \"orange red\", 0xff4500 },\n\t\t{ \"orange\", 0xffa500 },\n\t\t{ \"orange1\", 0xffa500 },\n\t\t{ \"orange2\", 0xee9a00 },\n\t\t{ \"orange3\", 0xcd8500 },\n\t\t{ \"orange4\", 0x8b5a00 },\n\t\t{ \"orchid\", 0xda70d6 },\n\t\t{ \"orchid1\", 0xff83fa },\n\t\t{ \"orchid2\", 0xee7ae9 },\n\t\t{ \"orchid3\", 0xcd69c9 },\n\t\t{ \"orchid4\", 0x8b4789 },\n\t\t{ \"pale goldenrod\", 0xeee8aa },\n\t\t{ \"pale green\", 0x98fb98 },\n\t\t{ \"pale turquoise\", 0xafeeee },\n\t\t{ \"pale violet red\", 0xdb7093 },\n\t\t{ \"papaya whip\", 0xffefd5 },\n\t\t{ \"peach puff\", 0xffdab9 },\n\t\t{ \"peru\", 0xcd853f },\n\t\t{ \"pink\", 0xffc0cb },\n\t\t{ \"pink1\", 0xffb5c5 },\n\t\t{ \"pink2\", 0xeea9b8 },\n\t\t{ \"pink3\", 0xcd919e },\n\t\t{ \"pink4\", 0x8b636c },\n\t\t{ \"plum\", 0xdda0dd },\n\t\t{ \"plum1\", 0xffbbff },\n\t\t{ \"plum2\", 0xeeaeee },\n\t\t{ \"plum3\", 0xcd96cd },\n\t\t{ \"plum4\", 0x8b668b },\n\t\t{ \"powder blue\", 0xb0e0e6 },\n\t\t{ \"purple\", 0xa020f0 },\n\t\t{ \"purple1\", 0x9b30ff },\n\t\t{ \"purple2\", 0x912cee },\n\t\t{ \"purple3\", 0x7d26cd },\n\t\t{ \"purple4\", 0x551a8b },\n\t\t{ \"rebecca purple\", 0x663399 },\n\t\t{ \"red\", 0xff0000 },\n\t\t{ \"red1\", 0xff0000 },\n\t\t{ \"red2\", 0xee0000 },\n\t\t{ \"red3\", 0xcd0000 },\n\t\t{ \"red4\", 0x8b0000 },\n\t\t{ \"rosy brown\", 0xbc8f8f },\n\t\t{ \"royal blue\", 0x4169e1 },\n\t\t{ \"saddle brown\", 0x8b4513 },\n\t\t{ \"salmon\", 0xfa8072 },\n\t\t{ \"salmon1\", 0xff8c69 },\n\t\t{ \"salmon2\", 0xee8262 },\n\t\t{ \"salmon3\", 0xcd7054 },\n\t\t{ \"salmon4\", 0x8b4c39 },\n\t\t{ \"sandy brown\", 0xf4a460 },\n\t\t{ \"sea green\", 0x2e8b57 },\n\t\t{ \"seashell\", 0xfff5ee },\n\t\t{ \"seashell1\", 0xfff5ee },\n\t\t{ \"seashell2\", 0xeee5de },\n\t\t{ \"seashell3\", 0xcdc5bf },\n\t\t{ \"seashell4\", 0x8b8682 },\n\t\t{ \"sienna\", 0xa0522d },\n\t\t{ \"sienna1\", 0xff8247 },\n\t\t{ \"sienna2\", 0xee7942 },\n\t\t{ \"sienna3\", 0xcd6839 },\n\t\t{ \"sienna4\", 0x8b4726 },\n\t\t{ \"silver\", 0xc0c0c0 },\n\t\t{ \"sky blue\", 0x87ceeb },\n\t\t{ \"slate blue\", 0x6a5acd },\n\t\t{ \"slate gray\", 0x708090 },\n\t\t{ \"slate grey\", 0x708090 },\n\t\t{ \"snow\", 0xfffafa },\n\t\t{ \"snow1\", 0xfffafa },\n\t\t{ \"snow2\", 0xeee9e9 },\n\t\t{ \"snow3\", 0xcdc9c9 },\n\t\t{ \"snow4\", 0x8b8989 },\n\t\t{ \"spring green\", 0x00ff7f },\n\t\t{ \"steel blue\", 0x4682b4 },\n\t\t{ \"tan\", 0xd2b48c },\n\t\t{ \"tan1\", 0xffa54f },\n\t\t{ \"tan2\", 0xee9a49 },\n\t\t{ \"tan3\", 0xcd853f },\n\t\t{ \"tan4\", 0x8b5a2b },\n\t\t{ \"teal\", 0x008080 },\n\t\t{ \"thistle\", 0xd8bfd8 },\n\t\t{ \"thistle1\", 0xffe1ff },\n\t\t{ \"thistle2\", 0xeed2ee },\n\t\t{ \"thistle3\", 0xcdb5cd },\n\t\t{ \"thistle4\", 0x8b7b8b },\n\t\t{ \"tomato\", 0xff6347 },\n\t\t{ \"tomato1\", 0xff6347 },\n\t\t{ \"tomato2\", 0xee5c42 },\n\t\t{ \"tomato3\", 0xcd4f39 },\n\t\t{ \"tomato4\", 0x8b3626 },\n\t\t{ \"turquoise\", 0x40e0d0 },\n\t\t{ \"turquoise1\", 0x00f5ff },\n\t\t{ \"turquoise2\", 0x00e5ee },\n\t\t{ \"turquoise3\", 0x00c5cd },\n\t\t{ \"turquoise4\", 0x00868b },\n\t\t{ \"violet red\", 0xd02090 },\n\t\t{ \"violet\", 0xee82ee },\n\t\t{ \"web gray\", 0x808080 },\n\t\t{ \"web green\", 0x008000 },\n\t\t{ \"web grey\", 0x808080 },\n\t\t{ \"web maroon\", 0x800000 },\n\t\t{ \"web purple\", 0x800080 },\n\t\t{ \"wheat\", 0xf5deb3 },\n\t\t{ \"wheat1\", 0xffe7ba },\n\t\t{ \"wheat2\", 0xeed8ae },\n\t\t{ \"wheat3\", 0xcdba96 },\n\t\t{ \"wheat4\", 0x8b7e66 },\n\t\t{ \"white smoke\", 0xf5f5f5 },\n\t\t{ \"white\", 0xffffff },\n\t\t{ \"x11 gray\", 0xbebebe },\n\t\t{ \"x11 green\", 0x00ff00 },\n\t\t{ \"x11 grey\", 0xbebebe },\n\t\t{ \"x11 maroon\", 0xb03060 },\n\t\t{ \"x11 purple\", 0xa020f0 },\n\t\t{ \"yellow green\", 0x9acd32 },\n\t\t{ \"yellow\", 0xffff00 },\n\t\t{ \"yellow1\", 0xffff00 },\n\t\t{ \"yellow2\", 0xeeee00 },\n\t\t{ \"yellow3\", 0xcdcd00 },\n\t\t{ \"yellow4\", 0x8b8b00 }\n\t};\n\tu_int\t\t i;\n\tint\t\t c;\n\tconst char\t*errstr;\n\n\tif (strncmp(name, \"grey\", 4) == 0 || strncmp(name, \"gray\", 4) == 0) {\n\t\tif (name[4] == '\\0')\n\t\t\treturn (0xbebebe|COLOUR_FLAG_RGB);\n\t\tc = strtonum(name + 4, 0, 100, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (-1);\n\t\tc = round(2.55 * c);\n\t\tif (c < 0 || c > 255)\n\t\t\treturn (-1);\n\t\treturn (colour_join_rgb(c, c, c));\n\t}\n\tfor (i = 0; i < nitems(colours); i++) {\n\t\tif (strcasecmp(colours[i].name, name) == 0)\n\t\t\treturn (colours[i].c|COLOUR_FLAG_RGB);\n\t}\n\treturn (-1);\n}\n\n/* Parse colour from an X11 string. */\nint\ncolour_parseX11(const char *p)\n{\n\tdouble\t c, m, y, k = 0;\n\tu_int\t r, g, b;\n\tsize_t\t len = strlen(p);\n\tint\t colour = -1;\n\tchar\t*copy;\n\n\tif ((len == 12 && sscanf(p, \"rgb:%02x/%02x/%02x\", &r, &g, &b) == 3) ||\n\t    (len == 7 && sscanf(p, \"#%02x%02x%02x\", &r, &g, &b) == 3) ||\n\t    sscanf(p, \"%d,%d,%d\", &r, &g, &b) == 3)\n\t\tcolour = colour_join_rgb(r, g, b);\n\telse if ((len == 18 &&\n\t    sscanf(p, \"rgb:%04x/%04x/%04x\", &r, &g, &b) == 3) ||\n\t    (len == 13 && sscanf(p, \"#%04x%04x%04x\", &r, &g, &b) == 3))\n\t\tcolour = colour_join_rgb(r >> 8, g >> 8, b >> 8);\n\telse if ((sscanf(p, \"cmyk:%lf/%lf/%lf/%lf\", &c, &m, &y, &k) == 4 ||\n\t    sscanf(p, \"cmy:%lf/%lf/%lf\", &c, &m, &y) == 3) &&\n\t    c >= 0 && c <= 1 && m >= 0 && m <= 1 &&\n\t    y >= 0 && y <= 1 && k >= 0 && k <= 1) {\n\t\tcolour = colour_join_rgb(\n\t\t    (1 - c) * (1 - k) * 255,\n\t\t    (1 - m) * (1 - k) * 255,\n\t\t    (1 - y) * (1 - k) * 255);\n\t} else {\n\t\twhile (len != 0 && *p == ' ') {\n\t\t\tp++;\n\t\t\tlen--;\n\t\t}\n\t\twhile (len != 0 && p[len - 1] == ' ')\n\t\t\tlen--;\n\t\tcopy = xstrndup(p, len);\n\t\tcolour = colour_byname(copy);\n\t\tfree(copy);\n\t}\n\tlog_debug(\"%s: %s = %s\", __func__, p, colour_tostring(colour));\n\treturn (colour);\n}\n\n/* Initialize palette. */\nvoid\ncolour_palette_init(struct colour_palette *p)\n{\n\tp->fg = 8;\n\tp->bg = 8;\n\tp->palette = NULL;\n\tp->default_palette = NULL;\n}\n\n/* Clear palette. */\nvoid\ncolour_palette_clear(struct colour_palette *p)\n{\n\tif (p != NULL) {\n\t\tp->fg = 8;\n\t\tp->bg = 8;\n \t\tfree(p->palette);\n\t\tp->palette = NULL;\n\t}\n}\n\n/* Free a palette. */\nvoid\ncolour_palette_free(struct colour_palette *p)\n{\n\tif (p != NULL) {\n\t\tfree(p->palette);\n\t\tp->palette = NULL;\n\t\tfree(p->default_palette);\n\t\tp->default_palette = NULL;\n\t}\n}\n\n/* Get a colour from a palette. */\nint\ncolour_palette_get(struct colour_palette *p, int c)\n{\n\tif (p == NULL)\n\t\treturn (-1);\n\n\tif (c >= 90 && c <= 97)\n\t\tc = 8 + c - 90;\n\telse if (c & COLOUR_FLAG_256)\n\t\tc &= ~COLOUR_FLAG_256;\n\telse if (c >= 8)\n\t\treturn (-1);\n\n\tif (p->palette != NULL && p->palette[c] != -1)\n\t\treturn (p->palette[c]);\n\tif (p->default_palette != NULL && p->default_palette[c] != -1)\n\t\treturn (p->default_palette[c]);\n\treturn (-1);\n}\n\n/* Set a colour in a palette. */\nint\ncolour_palette_set(struct colour_palette *p, int n, int c)\n{\n\tu_int\ti;\n\n\tif (p == NULL || n > 255)\n\t\treturn (0);\n\n\tif (c == -1 && p->palette == NULL)\n\t\treturn (0);\n\n\tif (c != -1 && p->palette == NULL) {\n\t\tif (p->palette == NULL)\n\t\t\tp->palette = xcalloc(256, sizeof *p->palette);\n\t\tfor (i = 0; i < 256; i++)\n\t\t\tp->palette[i] = -1;\n\t}\n\tp->palette[n] = c;\n\treturn (1);\n}\n\n/* Build palette defaults from an option. */\nvoid\ncolour_palette_from_option(struct colour_palette *p, struct options *oo)\n{\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tu_int\t\t\t\t i, n;\n\tint\t\t\t\t c;\n\n\tif (p == NULL)\n\t\treturn;\n\n\to = options_get(oo, \"pane-colours\");\n\tif ((a = options_array_first(o)) == NULL) {\n\t\tif (p->default_palette != NULL) {\n\t\t\tfree(p->default_palette);\n\t\t\tp->default_palette = NULL;\n\t\t}\n\t\treturn;\n\t}\n\tif (p->default_palette == NULL)\n\t\tp->default_palette = xcalloc(256, sizeof *p->default_palette);\n\tfor (i = 0; i < 256; i++)\n\t\tp->default_palette[i] = -1;\n\twhile (a != NULL) {\n\t\tn = options_array_item_index(a);\n\t\tif (n < 256) {\n\t\t\tc = options_array_item_value(a)->number;\n\t\t\tp->default_palette[n] = c;\n\t\t}\n\t\ta = options_array_next(a);\n\t}\n}\n"
        },
        {
          "name": "compat.h",
          "type": "blob",
          "size": 9.4609375,
          "content": "/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef COMPAT_H\n#define COMPAT_H\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n\n#include <fnmatch.h>\n#include <limits.h>\n#include <stdio.h>\n#include <termios.h>\n#include <wchar.h>\n\n#ifdef HAVE_EVENT2_EVENT_H\n#include <event2/event.h>\n#include <event2/event_compat.h>\n#include <event2/event_struct.h>\n#include <event2/buffer.h>\n#include <event2/buffer_compat.h>\n#include <event2/bufferevent.h>\n#include <event2/bufferevent_struct.h>\n#include <event2/bufferevent_compat.h>\n#else\n#include <event.h>\n#ifndef EVBUFFER_EOL_LF\n/*\n * This doesn't really work because evbuffer_readline is broken, but gets us to\n * build with very old (older than 1.4.14) libevent.\n */\n#define EVBUFFER_EOL_LF\n#define evbuffer_readln(a, b, c) evbuffer_readline(a)\n#endif\n#endif\n\n#ifdef HAVE_MALLOC_TRIM\n#include <malloc.h>\n#endif\n\n#ifdef HAVE_UTF8PROC\n#include <utf8proc.h>\n#endif\n\n#ifndef __GNUC__\n#define __attribute__(a)\n#endif\n\n#ifdef BROKEN___DEAD\n#undef __dead\n#endif\n\n#ifndef __unused\n#define __unused __attribute__ ((__unused__))\n#endif\n#ifndef __dead\n#define __dead __attribute__ ((__noreturn__))\n#endif\n#ifndef __packed\n#define __packed __attribute__ ((__packed__))\n#endif\n#ifndef __weak\n#define __weak __attribute__ ((__weak__))\n#endif\n\n#ifndef ECHOPRT\n#define ECHOPRT 0\n#endif\n\n#ifndef ACCESSPERMS\n#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)\n#endif\n\n#if !defined(FIONREAD) && defined(__sun)\n#include <sys/filio.h>\n#endif\n\n#ifdef HAVE_ERR_H\n#include <err.h>\n#else\nvoid\terr(int, const char *, ...);\nvoid\terrx(int, const char *, ...);\nvoid\twarn(const char *, ...);\nvoid\twarnx(const char *, ...);\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n\n#ifndef _PATH_BSHELL\n#define _PATH_BSHELL\t\"/bin/sh\"\n#endif\n\n#ifndef _PATH_TMP\n#define _PATH_TMP\t\"/tmp/\"\n#endif\n\n#ifndef _PATH_DEVNULL\n#define _PATH_DEVNULL\t\"/dev/null\"\n#endif\n\n#ifndef _PATH_TTY\n#define _PATH_TTY\t\"/dev/tty\"\n#endif\n\n#ifndef _PATH_DEV\n#define _PATH_DEV\t\"/dev/\"\n#endif\n\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH\t\"/usr/bin:/bin\"\n#endif\n\n#ifndef _PATH_VI\n#define _PATH_VI\t\"/usr/bin/vi\"\n#endif\n\n#ifndef __OpenBSD__\n#define pledge(s, p) (0)\n#endif\n\n#ifndef IMAXBEL\n#define IMAXBEL 0\n#endif\n\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#else\n#include <inttypes.h>\n#endif\n\n#ifdef HAVE_QUEUE_H\n#include <sys/queue.h>\n#else\n#include \"compat/queue.h\"\n#endif\n\n#ifdef HAVE_TREE_H\n#include <sys/tree.h>\n#else\n#include \"compat/tree.h\"\n#endif\n\n#ifdef HAVE_BITSTRING_H\n#include <bitstring.h>\n#else\n#include \"compat/bitstring.h\"\n#endif\n\n#ifdef HAVE_LIBUTIL_H\n#include <libutil.h>\n#endif\n\n#ifdef HAVE_PTY_H\n#include <pty.h>\n#endif\n\n#ifdef HAVE_UTIL_H\n#include <util.h>\n#endif\n\n#ifdef HAVE_VIS\n#include <vis.h>\n#else\n#include \"compat/vis.h\"\n#endif\n\n#ifdef HAVE_IMSG\n#include <imsg.h>\n#else\n#include \"compat/imsg.h\"\n#endif\n\n#ifdef BROKEN_CMSG_FIRSTHDR\n#undef CMSG_FIRSTHDR\n#define CMSG_FIRSTHDR(mhdr) \\\n\t((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \\\n\t    (struct cmsghdr *)(mhdr)->msg_control :\t    \\\n\t    (struct cmsghdr *)NULL)\n#endif\n\n#ifndef CMSG_ALIGN\n#ifdef _CMSG_DATA_ALIGN\n#define CMSG_ALIGN _CMSG_DATA_ALIGN\n#else\n#define CMSG_ALIGN(len) (((len) + sizeof(long) - 1) & ~(sizeof(long) - 1))\n#endif\n#endif\n\n#ifndef CMSG_SPACE\n#define CMSG_SPACE(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + CMSG_ALIGN(len))\n#endif\n\n#ifndef CMSG_LEN\n#define CMSG_LEN(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))\n#endif\n\n#ifndef O_DIRECTORY\n#define O_DIRECTORY 0\n#endif\n\n#ifndef FNM_CASEFOLD\n#ifdef FNM_IGNORECASE\n#define FNM_CASEFOLD FNM_IGNORECASE\n#else\n#define FNM_CASEFOLD 0\n#endif\n#endif\n\n#ifndef INFTIM\n#define INFTIM -1\n#endif\n\n#ifndef WAIT_ANY\n#define WAIT_ANY -1\n#endif\n\n#ifndef SUN_LEN\n#define SUN_LEN(sun) (sizeof (sun)->sun_path)\n#endif\n\n#ifndef timercmp\n#define\ttimercmp(tvp, uvp, cmp)\t\t\t\t\t\t\\\n\t(((tvp)->tv_sec == (uvp)->tv_sec) ?\t\t\t\t\\\n\t    ((tvp)->tv_usec cmp (uvp)->tv_usec) :\t\t\t\\\n\t    ((tvp)->tv_sec cmp (uvp)->tv_sec))\n#endif\n\n#ifndef timeradd\n#define\ttimeradd(tvp, uvp, vvp)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;\t\t\\\n\t\t(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;\t\\\n\t\tif ((vvp)->tv_usec >= 1000000) {\t\t\t\\\n\t\t\t(vvp)->tv_sec++;\t\t\t\t\\\n\t\t\t(vvp)->tv_usec -= 1000000;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#endif\n\n#ifndef timersub\n#define timersub(tvp, uvp, vvp)                                         \\\n\tdo {                                                            \\\n\t\t(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;          \\\n\t\t(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;       \\\n\t\tif ((vvp)->tv_usec < 0) {                               \\\n\t\t\t(vvp)->tv_sec--;                                \\\n\t\t\t(vvp)->tv_usec += 1000000;                      \\\n\t\t}                                                       \\\n\t} while (0)\n#endif\n\n#ifndef TTY_NAME_MAX\n#define TTY_NAME_MAX 32\n#endif\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#ifndef CLOCK_REALTIME\n#define CLOCK_REALTIME 0\n#endif\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\n#ifndef HAVE_FLOCK\n#define LOCK_SH 0\n#define LOCK_EX 0\n#define LOCK_NB 0\n#define flock(fd, op) (0)\n#endif\n\n#ifndef HAVE_EXPLICIT_BZERO\n/* explicit_bzero.c */\nvoid\t\t explicit_bzero(void *, size_t);\n#endif\n\n#ifndef HAVE_GETDTABLECOUNT\n/* getdtablecount.c */\nint\t\t getdtablecount(void);\n#endif\n\n#ifndef HAVE_GETDTABLESIZE\n/* getdtablesize.c */\nint\t\t getdtablesize(void);\n#endif\n\n#ifndef HAVE_CLOSEFROM\n/* closefrom.c */\nvoid\t\t closefrom(int);\n#endif\n\n#ifndef HAVE_STRCASESTR\n/* strcasestr.c */\nchar\t\t*strcasestr(const char *, const char *);\n#endif\n\n#ifndef HAVE_STRSEP\n/* strsep.c */\nchar\t\t*strsep(char **, const char *);\n#endif\n\n#ifndef HAVE_STRTONUM\n/* strtonum.c */\nlong long\t strtonum(const char *, long long, long long, const char **);\n#endif\n\n#ifndef HAVE_STRLCPY\n/* strlcpy.c */\nsize_t\t \t strlcpy(char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_STRLCAT\n/* strlcat.c */\nsize_t\t \t strlcat(char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_STRNLEN\n/* strnlen.c */\nsize_t\t\t strnlen(const char *, size_t);\n#endif\n\n#ifndef HAVE_STRNDUP\n/* strndup.c */\nchar\t\t*strndup(const char *, size_t);\n#endif\n\n#ifndef HAVE_MEMMEM\n/* memmem.c */\nvoid\t\t*memmem(const void *, size_t, const void *, size_t);\n#endif\n\n#ifndef HAVE_HTONLL\n/* htonll.c */\n#undef htonll\nuint64_t\t htonll(uint64_t);\n#endif\n\n#ifndef HAVE_NTOHLL\n/* ntohll.c */\n#undef ntohll\nuint64_t\t ntohll(uint64_t);\n#endif\n\n#ifndef HAVE_GETPEEREID\n/* getpeereid.c */\nint\t\tgetpeereid(int, uid_t *, gid_t *);\n#endif\n\n#ifndef HAVE_DAEMON\n/* daemon.c */\nint\t \t daemon(int, int);\n#endif\n\n#ifndef HAVE_GETPROGNAME\n/* getprogname.c */\nconst char\t*getprogname(void);\n#endif\n\n#ifndef HAVE_SETPROCTITLE\n/* setproctitle.c */\nvoid\t\t setproctitle(const char *, ...);\n#endif\n\n#ifndef HAVE_CLOCK_GETTIME\n/* clock_gettime.c */\nint\t\t clock_gettime(int, struct timespec *);\n#endif\n\n#ifndef HAVE_B64_NTOP\n/* base64.c */\n#undef b64_ntop\n#undef b64_pton\nint\t\t b64_ntop(const char *, size_t, char *, size_t);\nint\t\t b64_pton(const char *, u_char *, size_t);\n#endif\n\n#ifndef HAVE_FDFORKPTY\n/* fdforkpty.c */\nint\t\t getptmfd(void);\npid_t\t\t fdforkpty(int, int *, char *, struct termios *,\n\t\t     struct winsize *);\n#endif\n\n#ifndef HAVE_FORKPTY\n/* forkpty.c */\npid_t\t\t forkpty(int *, char *, struct termios *, struct winsize *);\n#endif\n\n#ifndef HAVE_ASPRINTF\n/* asprintf.c */\nint\t\t asprintf(char **, const char *, ...);\nint\t\t vasprintf(char **, const char *, va_list);\n#endif\n\n#ifndef HAVE_FGETLN\n/* fgetln.c */\nchar\t\t*fgetln(FILE *, size_t *);\n#endif\n\n#ifndef HAVE_GETLINE\n/* getline.c */\nssize_t\t\t getline(char **, size_t *, FILE *);\n#endif\n\n#ifndef HAVE_SETENV\n/* setenv.c */\nint\t\t setenv(const char *, const char *, int);\nint\t\t unsetenv(const char *);\n#endif\n\n#ifndef HAVE_CFMAKERAW\n/* cfmakeraw.c */\nvoid\t\t cfmakeraw(struct termios *);\n#endif\n\n#ifndef HAVE_FREEZERO\n/* freezero.c */\nvoid\t\t freezero(void *, size_t);\n#endif\n\n#ifndef HAVE_REALLOCARRAY\n/* reallocarray.c */\nvoid\t\t*reallocarray(void *, size_t, size_t);\n#endif\n\n#ifndef HAVE_RECALLOCARRAY\n/* recallocarray.c */\nvoid\t\t*recallocarray(void *, size_t, size_t, size_t);\n#endif\n\n#ifdef HAVE_SYSTEMD\n/* systemd.c */\nint\t\t systemd_activated(void);\nint\t\t systemd_create_socket(int, char **);\nint\t\t systemd_move_pid_to_new_cgroup(pid_t, char **);\n#endif\n\n#ifdef HAVE_UTF8PROC\n/* utf8proc.c */\nint\t\t utf8proc_wcwidth(wchar_t);\nint\t\t utf8proc_mbtowc(wchar_t *, const char *, size_t);\nint\t\t utf8proc_wctomb(char *, wchar_t);\n#endif\n\n#ifdef NEED_FUZZING\n/* tmux.c */\n#define main __weak main\n#endif\n\n/* getopt.c */\nextern int\tBSDopterr;\nextern int\tBSDoptind;\nextern int\tBSDoptopt;\nextern int\tBSDoptreset;\nextern char    *BSDoptarg;\nint\tBSDgetopt(int, char *const *, const char *);\n#define getopt(ac, av, o)  BSDgetopt(ac, av, o)\n#define opterr             BSDopterr\n#define optind             BSDoptind\n#define optopt             BSDoptopt\n#define optreset           BSDoptreset\n#define optarg             BSDoptarg\n\n#endif /* COMPAT_H */\n"
        },
        {
          "name": "compat",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 21.9111328125,
          "content": "# configure.ac\n\nAC_INIT([tmux], next-3.6)\nAC_PREREQ([2.60])\n\nAC_CONFIG_AUX_DIR(etc)\nAC_CONFIG_LIBOBJ_DIR(compat)\nAM_INIT_AUTOMAKE([foreign subdir-objects])\n\nAC_CANONICAL_HOST\n\n# When CFLAGS isn't set at this stage and gcc is detected by the macro below,\n# autoconf will automatically use CFLAGS=\"-O2 -g\". Prevent that by using an\n# empty default.\n: ${CFLAGS=\"\"}\n\n# Save user CPPFLAGS, CFLAGS and LDFLAGS. We need to change them because\n# AC_CHECK_HEADER doesn't give us any other way to update the include\n# paths. But for Makefile.am we want to use AM_CPPFLAGS and friends.\nSAVED_CFLAGS=\"$CFLAGS\"\nSAVED_CPPFLAGS=\"$CPPFLAGS\"\nSAVED_LDFLAGS=\"$LDFLAGS\"\n\n# Is this oss-fuzz build?\nAC_ARG_ENABLE(\n\tfuzzing,\n\tAS_HELP_STRING(--enable-fuzzing, build fuzzers)\n)\nAC_ARG_VAR(\n\tFUZZING_LIBS,\n\tAS_HELP_STRING(libraries to link fuzzing targets with)\n)\n\n# Set up convenient fuzzing defaults before initializing compiler.\nif test \"x$enable_fuzzing\" = xyes; then\n\tAC_DEFINE(NEED_FUZZING)\n\ttest \"x$CC\" = x && CC=clang\n\ttest \"x$FUZZING_LIBS\" = x && \\\n\t\tFUZZING_LIBS=\"-fsanitize=fuzzer\"\n\ttest \"x$SAVED_CFLAGS\" = x && \\\n\t\tAM_CFLAGS=\"-g -fsanitize=fuzzer-no-link,address\"\nfi\n\n# Set up the compiler in two different ways and say yes we may want to install.\nAC_PROG_CC\nAM_PROG_CC_C_O\nm4_version_prereq(2.70, [AC_PROG_CC], [AC_PROG_CC_C99])\nAC_PROG_CPP\nAC_PROG_EGREP\nAC_PROG_INSTALL\nAC_PROG_YACC\nPKG_PROG_PKG_CONFIG\nAC_USE_SYSTEM_EXTENSIONS\n\n# Default tmux.conf goes in /etc not ${prefix}/etc.\ntest \"$sysconfdir\" = '${prefix}/etc' && sysconfdir=/etc\n\n# Is this --enable-debug?\nAC_ARG_ENABLE(\n\tdebug,\n\tAS_HELP_STRING(--enable-debug, enable debug build flags),\n\t,\n\t[case \"x$VERSION\" in xnext*) enable_debug=yes;; esac]\n)\nAM_CONDITIONAL(IS_DEBUG, test \"x$enable_debug\" = xyes)\n\n# Is this a static build?\nAC_ARG_ENABLE(\n\tstatic,\n\tAS_HELP_STRING(--enable-static, create a static build)\n)\nif test \"x$enable_static\" = xyes; then\n\tcase \"$host_os\" in\n\t\t*darwin*)\n\t\t\tAC_MSG_ERROR([static linking is not supported on macOS])\n\t\t\t;;\n\tesac\n\ttest \"x$PKG_CONFIG\" != x && PKG_CONFIG=\"$PKG_CONFIG --static\"\n\tAM_LDFLAGS=\"-static $AM_LDFLAGS\"\n\tLDFLAGS=\"$AM_LDFLAGS $SAVED_LDFLAGS\"\nfi\n\n# Allow default TERM to be set.\nAC_ARG_WITH(\n\tTERM,\n\tAS_HELP_STRING(--with-TERM, set default TERM),\n\t[DEFAULT_TERM=$withval],\n\t[DEFAULT_TERM=]\n)\ncase \"x$DEFAULT_TERM\" in\n\txscreen*|xtmux*|x)\n\t;;\n\t*)\n\t\tAC_MSG_ERROR(\"unsuitable TERM (must be screen* or tmux*)\")\n\t;;\nesac\n\n# Do we need fuzzers?\nAM_CONDITIONAL(NEED_FUZZING, test \"x$enable_fuzzing\" = xyes)\n\n# Is this gcc?\nAM_CONDITIONAL(IS_GCC, test \"x$GCC\" = xyes -a \"x$enable_fuzzing\" != xyes)\n\n# Is this Sun CC?\nAC_EGREP_CPP(\n\tyes,\n\t[\n\t\t#ifdef __SUNPRO_C\n\t\tyes\n\t\t#endif\n\t],\n\tfound_suncc=yes,\n\tfound_suncc=no\n)\nAM_CONDITIONAL(IS_SUNCC, test \"x$found_suncc\" = xyes)\n\n# Check for various headers. Alternatives included from compat.h.\nAC_CHECK_HEADERS([ \\\n\tbitstring.h \\\n\tdirent.h \\\n\tfcntl.h \\\n\tinttypes.h \\\n\tlibproc.h \\\n\tlibutil.h \\\n\tndir.h \\\n\tpaths.h \\\n\tpty.h \\\n\tstdint.h \\\n\tsys/dir.h \\\n\tsys/ndir.h \\\n\tsys/tree.h \\\n\tucred.h \\\n\tutil.h \\\n])\n\n# Look for sys_signame.\nAC_SEARCH_LIBS(sys_signame, , AC_DEFINE(HAVE_SYS_SIGNAME))\n\n# Look for fmod.\nAC_CHECK_LIB(m, fmod)\n\n# Look for library needed for flock.\nAC_SEARCH_LIBS(flock, bsd)\n\n# Check for functions that are replaced or omitted.\nAC_CHECK_FUNCS([ \\\n\tdirfd \\\n\tflock \\\n\tprctl \\\n\tproc_pidinfo \\\n\tgetpeerucred \\\n\tsysconf\n])\n\n# Check for functions with a compatibility implementation.\nAC_REPLACE_FUNCS([ \\\n\tasprintf \\\n\tcfmakeraw \\\n\tclock_gettime \\\n\tclosefrom \\\n\texplicit_bzero \\\n\tfgetln \\\n\tfreezero \\\n\tgetdtablecount \\\n\tgetdtablesize \\\n\tgetpeereid \\\n\tgetline \\\n\tgetprogname \\\n\thtonll \\\n\tmemmem \\\n\tntohll \\\n\tsetenv \\\n\tsetproctitle \\\n\tstrcasestr \\\n\tstrlcat \\\n\tstrlcpy \\\n\tstrndup \\\n\tstrsep \\\n])\nAC_FUNC_STRNLEN\n\n# Check if strtonum works.\nAC_MSG_CHECKING([for working strtonum])\nAC_RUN_IFELSE([AC_LANG_PROGRAM(\n\t\t[#include <stdlib.h>],\n\t\t[return (strtonum(\"0\", 0, 1, NULL) == 0 ? 0 : 1);]\n\t)],\n\t[AC_DEFINE(HAVE_STRTONUM) AC_MSG_RESULT(yes)],\n\t[AC_LIBOBJ(strtonum) AC_MSG_RESULT(no)],\n\t[AC_LIBOBJ(strtonum) AC_MSG_RESULT(no)]\n)\n\n# Clang sanitizers wrap reallocarray even if it isn't available on the target\n# system. When compiled it always returns NULL and crashes the program. To\n# detect this we need a more complicated test.\nAC_MSG_CHECKING([for working reallocarray])\nAC_RUN_IFELSE([AC_LANG_PROGRAM(\n\t\t[#include <stdlib.h>],\n\t\t[return (reallocarray(NULL, 1, 1) == NULL);]\n\t)],\n\tAC_MSG_RESULT(yes),\n\t[AC_LIBOBJ(reallocarray) AC_MSG_RESULT([no])],\n\t[AC_LIBOBJ(reallocarray) AC_MSG_RESULT([no])]\n)\nAC_MSG_CHECKING([for working recallocarray])\nAC_RUN_IFELSE([AC_LANG_PROGRAM(\n\t\t[#include <stdlib.h>],\n\t\t[return (recallocarray(NULL, 1, 1, 1) == NULL);]\n\t)],\n\tAC_MSG_RESULT(yes),\n\t[AC_LIBOBJ(recallocarray) AC_MSG_RESULT([no])],\n\t[AC_LIBOBJ(recallocarray) AC_MSG_RESULT([no])]\n)\n\n# Look for clock_gettime. Must come before event_init.\nAC_SEARCH_LIBS(clock_gettime, rt)\n\n# Always use our getopt because 1) glibc's doesn't enforce argument order 2)\n# musl does not set optarg to NULL for flags without arguments (although it is\n# not required to, but it is helpful) 3) there are probably other weird\n# implementations.\nAC_LIBOBJ(getopt)\n\n# Look for libevent. Try libevent_core or libevent with pkg-config first then\n# look for the library.\nPKG_CHECK_MODULES(\n\tLIBEVENT_CORE,\n\t[libevent_core >= 2],\n\t[\n\t\tAM_CPPFLAGS=\"$LIBEVENT_CORE_CFLAGS $AM_CPPFLAGS\"\n\t\tCPPFLAGS=\"$AM_CPPFLAGS $SAVED_CPPFLAGS\"\n\t\tLIBS=\"$LIBEVENT_CORE_LIBS $LIBS\"\n\t\tfound_libevent=yes\n\t],\n\tfound_libevent=no\n)\nif test x$found_libevent = xno; then\n\tPKG_CHECK_MODULES(\n\t\tLIBEVENT,\n\t\t[libevent >= 2],\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$LIBEVENT_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$AM_CPPFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$LIBEVENT_LIBS $LIBS\"\n\t\t\tfound_libevent=yes\n\t\t],\n\t\tfound_libevent=no\n\t)\nfi\nif test x$found_libevent = xno; then\n\tAC_SEARCH_LIBS(\n\t\tevent_init,\n\t\t[event_core event event-1.4],\n\t\tfound_libevent=yes,\n\t\tfound_libevent=no\n\t)\nfi\nAC_CHECK_HEADER(\n\tevent2/event.h,\n\tAC_DEFINE(HAVE_EVENT2_EVENT_H),\n\t[\n\t\tAC_CHECK_HEADER(\n\t\t\tevent.h,\n\t\t\tAC_DEFINE(HAVE_EVENT_H),\n\t\t\tfound_libevent=no\n\t\t)\n\t]\n)\nif test \"x$found_libevent\" = xno; then\n\tAC_MSG_ERROR(\"libevent not found\")\nfi\n\n# Look for yacc.\nAC_CHECK_PROG(found_yacc, $YACC, yes, no)\nif test \"x$found_yacc\" = xno; then\n\tAC_MSG_ERROR(\"yacc not found\")\nfi\n\n# Look for ncurses or curses. Try pkg-config first then directly for the\n# library.\nPKG_CHECK_MODULES(\n\tLIBTINFO,\n\ttinfo,\n\t[\n\t\tAM_CPPFLAGS=\"$LIBTINFO_CFLAGS $AM_CPPFLAGS\"\n\t\tCPPFLAGS=\"$LIBTINFO_CFLAGS $SAVED_CPPFLAGS\"\n\t\tLIBS=\"$LIBTINFO_LIBS $LIBS\"\n\t\tfound_ncurses=yes\n\t],\n\tfound_ncurses=no\n)\nif test \"x$found_ncurses\" = xno; then\n\tPKG_CHECK_MODULES(\n\t\tLIBNCURSES,\n\t\tncurses,\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$LIBNCURSES_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$LIBNCURSES_CFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$LIBNCURSES_LIBS $LIBS\"\n\t\t\tfound_ncurses=yes\n\t\t],\n\t\tfound_ncurses=no\n\t)\nfi\nif test \"x$found_ncurses\" = xno; then\n\tPKG_CHECK_MODULES(\n\t\tLIBNCURSESW,\n\t\tncursesw,\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$LIBNCURSESW_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$LIBNCURSESW_CFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$LIBNCURSESW_LIBS $LIBS\"\n\t\t\tfound_ncurses=yes\n\t\t],\n\t\tfound_ncurses=no\n\t)\nfi\nif test \"x$found_ncurses\" = xno; then\n\tAC_SEARCH_LIBS(\n\t\tsetupterm,\n\t\t[tinfo terminfo ncurses ncursesw],\n\t\tfound_ncurses=yes,\n\t\tfound_ncurses=no\n\t)\n\tif test \"x$found_ncurses\" = xyes; then\n\t\tAC_CHECK_HEADER(\n\t\t\tncurses.h,\n\t\t\tLIBS=\"$LIBS -lncurses\",\n\t\t\tfound_ncurses=no\n\t\t)\n\tfi\nfi\nif test \"x$found_ncurses\" = xyes; then\n\tCPPFLAGS=\"$CPPFLAGS -DHAVE_NCURSES_H\"\n\tAC_DEFINE(HAVE_NCURSES_H)\nelse\n\tAC_CHECK_LIB(\n\t\tcurses,\n\t\tsetupterm,\n\t\tfound_curses=yes,\n\t\tfound_curses=no\n\t)\n\tAC_CHECK_HEADER(\n\t\tcurses.h,\n\t\t,\n\t\tfound_curses=no\n\t)\n\tif test \"x$found_curses\" = xyes; then\n\t\tLIBS=\"$LIBS -lcurses\"\n\t\tCPPFLAGS=\"$CPPFLAGS -DHAVE_CURSES_H\"\n\t\tAC_DEFINE(HAVE_CURSES_H)\n\telse\n\t\tAC_MSG_ERROR(\"curses not found\")\n\tfi\nfi\nAC_CHECK_FUNCS([ \\\n\ttiparm \\\n\ttiparm_s \\\n])\n\n# Look for utempter.\nAC_ARG_ENABLE(\n\tutempter,\n\tAS_HELP_STRING(--enable-utempter, use utempter if it is installed)\n)\nif test \"x$enable_utempter\" = xyes; then\n\tAC_CHECK_HEADER(utempter.h, enable_utempter=yes, enable_utempter=no)\n\tif test \"x$enable_utempter\" = xyes; then\n\t\tAC_SEARCH_LIBS(\n\t\t\tutempter_add_record,\n\t\t\tutempter,\n\t\t\tenable_utempter=yes,\n\t\t\tenable_utempter=no\n\t\t)\n\tfi\n\tif test \"x$enable_utempter\" = xyes; then\n\t\tAC_DEFINE(HAVE_UTEMPTER)\n\telse\n\t\tAC_MSG_ERROR(\"utempter not found\")\n\tfi\nfi\n\n# Look for utf8proc.\nAC_ARG_ENABLE(\n\tutf8proc,\n\tAS_HELP_STRING(--enable-utf8proc, use utf8proc if it is installed)\n)\nif test \"x$enable_utf8proc\" = xyes; then\n\tPKG_CHECK_MODULES(\n\t\tLIBUTF8PROC,\n\t\tlibutf8proc,\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$LIBUTF8PROC_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$LIBUTF8PROC_CFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$LIBUTF8PROC_LIBS $LIBS\"\n\t\t]\n\t)\n\tAC_CHECK_HEADER(utf8proc.h, enable_utf8proc=yes, enable_utf8proc=no)\n\tif test \"x$enable_utf8proc\" = xyes; then\n\t\tAC_SEARCH_LIBS(\n\t\t\tutf8proc_charwidth,\n\t\t\tutf8proc,\n\t\t\tenable_utf8proc=yes,\n\t\t\tenable_utf8proc=no\n\t\t)\n\tfi\n\tif test \"x$enable_utf8proc\" = xyes; then\n\t\tAC_DEFINE(HAVE_UTF8PROC)\n\telse\n\t\tAC_MSG_ERROR(\"utf8proc not found\")\n\tfi\nfi\nAM_CONDITIONAL(HAVE_UTF8PROC, [test \"x$enable_utf8proc\" = xyes])\n\n# Check for systemd support.\nAC_ARG_ENABLE(\n\tsystemd,\n\tAS_HELP_STRING(--enable-systemd, enable systemd integration)\n)\nif test x\"$enable_systemd\" = xyes; then\n\tPKG_CHECK_MODULES(\n\t\tSYSTEMD,\n\t\tlibsystemd,\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$SYSTEMD_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$AM_CPPFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$SYSTEMD_LIBS $LIBS\"\n\t\t\tfound_systemd=yes\n\t\t],\n\t\tfound_systemd=no\n\t)\n\tif test \"x$found_systemd\" = xyes; then\n\t\tAC_DEFINE(HAVE_SYSTEMD)\n\telse\n\t\tAC_MSG_ERROR(\"systemd not found\")\n\tfi\nfi\nAM_CONDITIONAL(HAVE_SYSTEMD, [test \"x$found_systemd\" = xyes])\nAC_ARG_ENABLE(\n\tcgroups,\n\tAS_HELP_STRING(--disable-cgroups, disable adding panes to new cgroups with systemd)\n)\nif test \"x$enable_cgroups\" = x; then\n\t# Default to the same as $enable_systemd.\n\tenable_cgroups=$enable_systemd\nfi\nif test \"x$enable_cgroups\" = xyes; then\n\tif test \"x$found_systemd\" = xyes; then\n\t\tAC_DEFINE(ENABLE_CGROUPS)\n\telse\n\t\tAC_MSG_ERROR(\"cgroups requires systemd to be enabled\")\n\tfi\nfi\n\n# Enable sixel support.\nAC_ARG_ENABLE(\n\tsixel,\n\tAS_HELP_STRING(--enable-sixel, enable sixel images)\n)\nif test \"x$enable_sixel\" = xyes; then\n\tAC_DEFINE(ENABLE_SIXEL)\nfi\nAM_CONDITIONAL(ENABLE_SIXEL, [test \"x$enable_sixel\" = xyes])\n\n# Check for b64_ntop. If we have b64_ntop, we assume b64_pton as well.\nAC_MSG_CHECKING(for b64_ntop)\nAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t[\n\t\t#include <sys/types.h>\n\t\t#include <netinet/in.h>\n\t\t#include <resolv.h>\n\t],\n\t[\n\t\tb64_ntop(NULL, 0, NULL, 0);\n\t])],\n\tfound_b64_ntop=yes,\n\tfound_b64_ntop=no\n)\nAC_MSG_RESULT($found_b64_ntop)\nOLD_LIBS=\"$LIBS\"\nif test \"x$found_b64_ntop\" = xno; then\n\tAC_MSG_CHECKING(for b64_ntop with -lresolv)\n\tLIBS=\"$OLD_LIBS -lresolv\"\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <netinet/in.h>\n\t\t\t#include <resolv.h>\n\t\t],\n\t\t[\n\t\t\tb64_ntop(NULL, 0, NULL, 0);\n\t\t])],\n\t\tfound_b64_ntop=yes,\n\t\tfound_b64_ntop=no\n\t)\n\tAC_MSG_RESULT($found_b64_ntop)\nfi\nif test \"x$found_b64_ntop\" = xno; then\n\tAC_MSG_CHECKING(for b64_ntop with -lnetwork)\n\tLIBS=\"$OLD_LIBS -lnetwork\"\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM(\n\t\t[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <netinet/in.h>\n\t\t\t#include <resolv.h>\n\t\t],\n\t\t[\n\t\t\tb64_ntop(NULL, 0, NULL, 0);\n\t\t])],\n\t\tfound_b64_ntop=yes,\n\t\tfound_b64_ntop=no\n\t)\n\tAC_MSG_RESULT($found_b64_ntop)\nfi\nif test \"x$found_b64_ntop\" = xyes; then\n\tAC_DEFINE(HAVE_B64_NTOP)\nelse\n\tLIBS=\"$OLD_LIBS\"\n\tAC_LIBOBJ(base64)\nfi\n\n# Look for networking libraries.\nAC_SEARCH_LIBS(inet_ntoa, nsl)\nAC_SEARCH_LIBS(socket, socket)\nAC_CHECK_LIB(xnet, socket)\n\n# Check if using glibc and have malloc_trim(3). The glibc free(3) is pretty bad\n# about returning memory to the kernel unless the application tells it when to\n# with malloc_trim(3).\nAC_MSG_CHECKING(if free doesn't work very well)\nAC_LINK_IFELSE([AC_LANG_SOURCE(\n\t[\n\t\t#include <stdlib.h>\n\t\t#ifdef __GLIBC__\n\t\t#include <malloc.h>\n\t\tint main(void) {\n\t\t\tmalloc_trim (0);\n\t\t\texit(0);\n\t\t}\n\t\t#else\n\t\tno\n\t\t#endif\n\t])],\n\tfound_malloc_trim=yes,\n\tfound_malloc_trim=no\n)\nAC_MSG_RESULT($found_malloc_trim)\nif test \"x$found_malloc_trim\" = xyes; then\n\tAC_DEFINE(HAVE_MALLOC_TRIM)\nfi\n\n# Build against jemalloc if requested.\nAC_ARG_ENABLE(\n\tjemalloc,\n\tAS_HELP_STRING(--enable-jemalloc, use jemalloc if it is installed)\n)\nif test \"x$enable_jemalloc\" = xyes; then\n\tPKG_CHECK_MODULES(\n\t\tJEMALLOC,\n\t\tjemalloc,\n\t\t[\n\t\t\tAM_CPPFLAGS=\"$JEMALLOC_CFLAGS $AM_CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$AM_CPPFLAGS $SAVED_CPPFLAGS\"\n\t\t\tLIBS=\"$LIBS $JEMALLOC_LIBS\"\n\t\t],\n\t\tAC_MSG_ERROR(\"jemalloc not found\")\n\t)\nfi\n\n# Check for CMSG_DATA. On some platforms like HP-UX this requires UNIX 95\n# (_XOPEN_SOURCE and _XOPEN_SOURCE_EXTENDED) (see xopen_networking(7)). On\n# others, UNIX 03 (_XOPEN_SOURCE 600, see standards(7) on Solaris).\nXOPEN_DEFINES=\nAC_MSG_CHECKING(for CMSG_DATA)\nAC_EGREP_CPP(\n\tyes,\n\t[\n\t\t#include <sys/socket.h>\n\t\t#ifdef CMSG_DATA\n\t\tyes\n\t\t#endif\n\t],\n\tfound_cmsg_data=yes,\n\tfound_cmsg_data=no\n)\nAC_MSG_RESULT($found_cmsg_data)\nif test \"x$found_cmsg_data\" = xno; then\n\tAC_MSG_CHECKING(if CMSG_DATA needs _XOPEN_SOURCE_EXTENDED)\n\tAC_EGREP_CPP(\n\t\tyes,\n\t\t[\n\t\t\t#define _XOPEN_SOURCE 1\n\t\t\t#define _XOPEN_SOURCE_EXTENDED 1\n\t\t\t#include <sys/socket.h>\n\t\t\t#ifdef CMSG_DATA\n\t\t\tyes\n\t\t\t#endif\n\t\t],\n\t\tfound_cmsg_data=yes,\n\t\tfound_cmsg_data=no\n\t)\n\tAC_MSG_RESULT($found_cmsg_data)\n\tif test \"x$found_cmsg_data\" = xyes; then\n\t\tXOPEN_DEFINES=\"-D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED\"\n\tfi\nfi\nif test \"x$found_cmsg_data\" = xno; then\n\tAC_MSG_CHECKING(if CMSG_DATA needs _XOPEN_SOURCE 600)\n\tAC_EGREP_CPP(\n\t\tyes,\n\t\t[\n\t\t\t#define _XOPEN_SOURCE 600\n\t\t\t#include <sys/socket.h>\n\t\t\t#ifdef CMSG_DATA\n\t\t\tyes\n\t\t\t#endif\n\t\t],\n\t\tfound_cmsg_data=yes,\n\t\tfound_cmsg_data=no\n\t)\n\tAC_MSG_RESULT($found_cmsg_data)\n\tif test \"x$found_cmsg_data\" = xyes; then\n\t\tXOPEN_DEFINES=\"-D_XOPEN_SOURCE=600\"\n\telse\n\t\tAC_MSG_ERROR(\"CMSG_DATA not found\")\n\tfi\nfi\nAC_SUBST(XOPEN_DEFINES)\n\n# Look for err and friends in err.h.\nAC_CHECK_FUNC(err, found_err_h=yes, found_err_h=no)\nAC_CHECK_FUNC(errx, , found_err_h=no)\nAC_CHECK_FUNC(warn, , found_err_h=no)\nAC_CHECK_FUNC(warnx, , found_err_h=no)\nif test \"x$found_err_h\" = xyes; then\n\tAC_CHECK_HEADER(err.h, , found_err_h=no)\nelse\n\tAC_LIBOBJ(err)\nfi\n\n# Look for imsg_init in libutil.\nAC_SEARCH_LIBS(imsg_init, util, found_imsg_init=yes, found_imsg_init=no)\nif test \"x$found_imsg_init\" = xyes; then\n\tAC_DEFINE(HAVE_IMSG)\nelse\n\tAC_LIBOBJ(imsg)\n\tAC_LIBOBJ(imsg-buffer)\nfi\n\n# Look for daemon, compat/daemon.c used if missing. Solaris 10 has it in\n# libresolv, but no declaration anywhere, so check for declaration as well as\n# function.\nAC_CHECK_FUNC(daemon, found_daemon=yes, found_daemon=no)\nAC_CHECK_DECL(\n\tdaemon,\n\t,\n\tfound_daemon=no,\n\t[\n\t\t#include <stdlib.h>\n\t\t#include <unistd.h>\n\t]\n)\nif test \"x$found_daemon\" = xyes; then\n\tAC_DEFINE(HAVE_DAEMON)\nelse\n\tAC_LIBOBJ(daemon)\nfi\n\n# Look for stravis, compat/{vis,unvis}.c used if missing.\nAC_CHECK_FUNC(stravis, found_stravis=yes, found_stravis=no)\nif test \"x$found_stravis\" = xyes; then\n\tAC_MSG_CHECKING(if strnvis is broken)\n\tAC_EGREP_HEADER([strnvis\\(char \\*, const char \\*, size_t, int\\)],\n\t\t\tvis.h,\n\t\t\tAC_MSG_RESULT(no),\n\t\t\t[found_stravis=no])\n\tif test \"x$found_stravis\" = xno; then\n\t\tAC_MSG_RESULT(yes)\n\tfi\nfi\nif test \"x$found_stravis\" = xyes; then\n\tAC_CHECK_DECL(\n\t\tVIS_DQ,\n\t\t,\n\t\tfound_stravis=no,\n\t\t[\n\t\t\t#include <stdlib.h>\n\t\t\t#include <vis.h>\n\t\t]\n)\nfi\nif test \"x$found_stravis\" = xyes; then\n\tAC_DEFINE(HAVE_VIS)\nelse\n\tAC_LIBOBJ(vis)\n\tAC_LIBOBJ(unvis)\nfi\n\n# Look for fdforkpty and forkpty in libutil.\nAC_SEARCH_LIBS(fdforkpty, util, found_fdforkpty=yes, found_fdforkpty=no)\nif test \"x$found_fdforkpty\" = xyes; then\n\tAC_DEFINE(HAVE_FDFORKPTY)\nelse\n\tAC_LIBOBJ(fdforkpty)\nfi\nAC_SEARCH_LIBS(forkpty, util, found_forkpty=yes, found_forkpty=no)\nif test \"x$found_forkpty\" = xyes; then\n\tAC_DEFINE(HAVE_FORKPTY)\nfi\nAM_CONDITIONAL(NEED_FORKPTY, test \"x$found_forkpty\" = xno)\n\n# Look for kinfo_getfile in libutil.\nAC_SEARCH_LIBS(kinfo_getfile, [util util-freebsd])\n\n# Look for a suitable queue.h.\nAC_CHECK_DECL(\n\tTAILQ_CONCAT,\n\tfound_queue_h=yes,\n\tfound_queue_h=no,\n\t[#include <sys/queue.h>]\n)\nAC_CHECK_DECL(\n\tTAILQ_PREV,\n\t,\n\tfound_queue_h=no,\n\t[#include <sys/queue.h>]\n)\nAC_CHECK_DECL(\n\tTAILQ_REPLACE,\n\t,\n\tfound_queue_h=no,\n\t[#include <sys/queue.h>]\n)\nif test \"x$found_queue_h\" = xyes; then\n\tAC_DEFINE(HAVE_QUEUE_H)\nfi\n\n# Look for __progname.\nAC_MSG_CHECKING(for __progname)\nAC_LINK_IFELSE([AC_LANG_SOURCE(\n\t[\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\textern char *__progname;\n\t\tint main(void) {\n\t\t\tconst char *cp = __progname;\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\texit(0);\n\t\t}\n\t])],\n\t[AC_DEFINE(HAVE___PROGNAME) AC_MSG_RESULT(yes)],\n\tAC_MSG_RESULT(no)\n)\n\n# Look for program_invocation_short_name.\nAC_MSG_CHECKING(for program_invocation_short_name)\nAC_LINK_IFELSE([AC_LANG_SOURCE(\n\t[\n\t\t#include <errno.h>\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\tint main(void) {\n\t\t\tconst char *cp = program_invocation_short_name;\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\texit(0);\n\t\t}\n\t])],\n\t[AC_DEFINE(HAVE_PROGRAM_INVOCATION_SHORT_NAME) AC_MSG_RESULT(yes)],\n\tAC_MSG_RESULT(no)\n)\n\n# Look for prctl(PR_SET_NAME).\nAC_CHECK_DECL(\n\tPR_SET_NAME,\n\tAC_DEFINE(HAVE_PR_SET_NAME),\n\t,\n\t[#include <sys/prctl.h>]\n)\n\n# Look for setsockopt(SO_PEERCRED).\nAC_CHECK_DECL(\n\tSO_PEERCRED,\n\tAC_DEFINE(HAVE_SO_PEERCRED),\n\t,\n\t[#include <sys/socket.h>]\n)\n\n# Look for fcntl(F_CLOSEM).\nAC_CHECK_DECL(\n\tF_CLOSEM,\n\tAC_DEFINE(HAVE_FCNTL_CLOSEM),\n\t,\n\t[#include <fcntl.h>]\n)\n\n# Look for /proc/$$.\nAC_MSG_CHECKING(for /proc/\\$\\$)\nif test -d /proc/$$; then\n\tAC_DEFINE(HAVE_PROC_PID)\n\tAC_MSG_RESULT(yes)\nelse\n\tAC_MSG_RESULT(no)\nfi\n\n# Try to figure out what the best value for TERM might be.\nif test \"x$DEFAULT_TERM\" = x; then\n\tDEFAULT_TERM=screen\n\tAC_MSG_CHECKING(TERM)\n\tAC_RUN_IFELSE([AC_LANG_SOURCE(\n\t\t[\n\t\t\t#include <stdio.h>\n\t\t\t#include <stdlib.h>\n\t\t\t#if defined(HAVE_CURSES_H)\n\t\t\t#include <curses.h>\n\t\t\t#elif defined(HAVE_NCURSES_H)\n\t\t\t#include <ncurses.h>\n\t\t\t#endif\n\t\t\t#include <term.h>\n\t\t\tint main(void) {\n\t\t\t\tif (setupterm(\"screen-256color\", -1, NULL) != OK)\n\t\t\t\t\texit(1);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t ])],\n\t\t [DEFAULT_TERM=screen-256color],\n\t\t ,\n\t\t [DEFAULT_TERM=screen]\n\t)\n\tAC_RUN_IFELSE([AC_LANG_SOURCE(\n\t\t[\n\t\t\t#include <stdio.h>\n\t\t\t#include <stdlib.h>\n\t\t\t#if defined(HAVE_CURSES_H)\n\t\t\t#include <curses.h>\n\t\t\t#elif defined(HAVE_NCURSES_H)\n\t\t\t#include <ncurses.h>\n\t\t\t#endif\n\t\t\t#include <term.h>\n\t\t\tint main(void) {\n\t\t\t\tif (setupterm(\"tmux\", -1, NULL) != OK)\n\t\t\t\t\texit(1);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t ])],\n\t\t [DEFAULT_TERM=tmux],\n\t\t ,\n\t\t [DEFAULT_TERM=screen]\n\t)\n\tAC_RUN_IFELSE([AC_LANG_SOURCE(\n\t\t[\n\t\t\t#include <stdio.h>\n\t\t\t#include <stdlib.h>\n\t\t\t#if defined(HAVE_CURSES_H)\n\t\t\t#include <curses.h>\n\t\t\t#elif defined(HAVE_NCURSES_H)\n\t\t\t#include <ncurses.h>\n\t\t\t#endif\n\t\t\t#include <term.h>\n\t\t\tint main(void) {\n\t\t\t\tif (setupterm(\"tmux-256color\", -1, NULL) != OK)\n\t\t\t\t\texit(1);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t ])],\n\t\t [DEFAULT_TERM=tmux-256color],\n\t\t ,\n\t\t [DEFAULT_TERM=screen]\n\t)\n\tAC_MSG_RESULT($DEFAULT_TERM)\nfi\nAC_SUBST(DEFAULT_TERM)\n\n# Man page defaults to mdoc.\nMANFORMAT=mdoc\nAC_SUBST(MANFORMAT)\n\n# Figure out the platform.\nAC_MSG_CHECKING(platform)\ncase \"$host_os\" in\n\t*aix*)\n\t\tAC_MSG_RESULT(aix)\n\t\tPLATFORM=aix\n\t\t;;\n\t*darwin*)\n\t\tAC_MSG_RESULT(darwin)\n\t\tPLATFORM=darwin\n\t\t#\n\t\t# macOS uses __dead2 instead of __dead, like FreeBSD. But it defines\n\t\t# __dead away so it needs to be removed before we can replace it.\n\t\t#\n\t\tAC_DEFINE(BROKEN___DEAD)\n\t\t#\n\t\t# macOS CMSG_FIRSTHDR is broken, so redefine it with a working one.\n\t\t# daemon works but has some stupid side effects, so use our internal\n\t\t# version which has a workaround.\n\t\t#\n\t\tAC_DEFINE(BROKEN_CMSG_FIRSTHDR)\n\t\tAC_LIBOBJ(daemon)\n\t\tAC_LIBOBJ(daemon-darwin)\n\t\t#\n\t\t# macOS wcwidth(3) is bad, so complain and suggest using utf8proc\n\t\t# instead.\n\t\t#\n\t\tif test \"x$enable_utf8proc\" = x; then\n\t\t\tAC_MSG_NOTICE([])\n\t\t\tAC_MSG_NOTICE([\t   macOS library support for Unicode is very poor,])\n\t\t\tAC_MSG_NOTICE([\t   particularly for complex codepoints like emojis;])\n\t\t\tAC_MSG_NOTICE([\t   to use these correctly, configuring with])\n\t\t\tAC_MSG_NOTICE([\t   --enable-utf8proc is recommended. To build])\n\t\t\tAC_MSG_NOTICE([\t   without anyway, use --disable-utf8proc])\n\t\t\tAC_MSG_NOTICE([])\n\t\t\tAC_MSG_ERROR([must give --enable-utf8proc or --disable-utf8proc])\n\t\tfi\n\t\t;;\n\t*dragonfly*)\n\t\tAC_MSG_RESULT(dragonfly)\n\t\tPLATFORM=dragonfly\n\t\t;;\n\t*linux*)\n\t\tAC_MSG_RESULT(linux)\n\t\tPLATFORM=linux\n\t\t;;\n\t*freebsd*)\n\t\tAC_MSG_RESULT(freebsd)\n\t\tPLATFORM=freebsd\n\t\t;;\n\t*netbsd*)\n\t\tAC_MSG_RESULT(netbsd)\n\t\tPLATFORM=netbsd\n\t\t;;\n\t*openbsd*)\n\t\tAC_MSG_RESULT(openbsd)\n\t\tPLATFORM=openbsd\n\t\t;;\n\t*sunos*)\n\t\tAC_MSG_RESULT(sunos)\n\t\tPLATFORM=sunos\n\t\t;;\n\t*solaris*)\n\t\tAC_MSG_RESULT(sunos)\n\t\tPLATFORM=sunos\n\t\tcase `/usr/bin/nroff --version 2>&1` in\n\t\t\t*GNU*)\n\t\t\t\t# Solaris 11.4 and later use GNU groff.\n\t\t\t\tMANFORMAT=mdoc\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif test `uname -o 2>/dev/null` = illumos; then\n\t\t\t\t\t# Illumos uses mandoc.\n\t\t\t\t\tMANFORMAT=mdoc\n\t\t\t\telse\n\t\t\t\t\t# Solaris 2.0 to 11.3 use AT&T nroff.\n\t\t\t\t\tMANFORMAT=man\n\t\t\t\tfi\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*hpux*)\n\t\tAC_MSG_RESULT(hpux)\n\t\tPLATFORM=hpux\n\t\t;;\n\t*cygwin*|*msys*)\n\t\tAC_MSG_RESULT(cygwin)\n\t\tPLATFORM=cygwin\n\t\t;;\n\t*haiku*)\n\t\tAC_MSG_RESULT(haiku)\n\t\tPLATFORM=haiku\n\t\t;;\n\t*)\n\t\tAC_MSG_RESULT(unknown)\n\t\tPLATFORM=unknown\n\t\t;;\nesac\nAC_SUBST(PLATFORM)\nAM_CONDITIONAL(IS_AIX, test \"x$PLATFORM\" = xaix)\nAM_CONDITIONAL(IS_DARWIN, test \"x$PLATFORM\" = xdarwin)\nAM_CONDITIONAL(IS_DRAGONFLY, test \"x$PLATFORM\" = xdragonfly)\nAM_CONDITIONAL(IS_LINUX, test \"x$PLATFORM\" = xlinux)\nAM_CONDITIONAL(IS_FREEBSD, test \"x$PLATFORM\" = xfreebsd)\nAM_CONDITIONAL(IS_NETBSD, test \"x$PLATFORM\" = xnetbsd)\nAM_CONDITIONAL(IS_OPENBSD, test \"x$PLATFORM\" = xopenbsd)\nAM_CONDITIONAL(IS_SUNOS, test \"x$PLATFORM\" = xsunos)\nAM_CONDITIONAL(IS_HPUX, test \"x$PLATFORM\" = xhpux)\nAM_CONDITIONAL(IS_CYGWIN, test \"x$PLATFORM\" = xcygwin)\nAM_CONDITIONAL(IS_HAIKU, test \"x$PLATFORM\" = xhaiku)\nAM_CONDITIONAL(IS_UNKNOWN, test \"x$PLATFORM\" = xunknown)\n\n# Set the default lock command\nDEFAULT_LOCK_CMD=\"lock -np\"\nAC_MSG_CHECKING(lock-command)\nif test \"x$PLATFORM\" = xlinux; then\n\tAC_CHECK_PROG(found_vlock, vlock, yes, no)\n\tif test \"x$found_vlock\" = xyes; then\n\t\tDEFAULT_LOCK_CMD=\"vlock\"\n\tfi\nfi\nAC_MSG_RESULT($DEFAULT_LOCK_CMD)\nAC_SUBST(DEFAULT_LOCK_CMD)\n\n\n# Save our CFLAGS/CPPFLAGS/LDFLAGS for the Makefile and restore the old user\n# variables.\nAC_SUBST(AM_CPPFLAGS)\nCPPFLAGS=\"$SAVED_CPPFLAGS\"\nAC_SUBST(AM_CFLAGS)\nCFLAGS=\"$SAVED_CFLAGS\"\nAC_SUBST(AM_LDFLAGS)\nLDFLAGS=\"$SAVED_LDFLAGS\"\n\n# autoconf should create a Makefile.\nAC_CONFIG_FILES(Makefile)\nAC_OUTPUT\n"
        },
        {
          "name": "control-notify.c",
          "type": "blob",
          "size": 5.740234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n#define CONTROL_SHOULD_NOTIFY_CLIENT(c) \\\n\t((c) != NULL && ((c)->flags & CLIENT_CONTROL))\n\nvoid\ncontrol_notify_pane_mode_changed(int pane)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%pane-mode-changed %%%u\", pane);\n\t}\n}\n\nvoid\ncontrol_notify_window_layout_changed(struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\tconst char\t*template;\n\tchar\t\t*cp;\n\n\ttemplate = \"%layout-change #{window_id} #{window_layout} \"\n\t    \"#{window_visible_layout} #{window_raw_flags}\";\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\ts = c->session;\n\n\t\tif (winlink_find_by_window_id(&s->windows, w->id) == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * When the last pane in a window is closed it won't have a\n\t\t * layout root and we don't need to inform the client about the\n\t\t * layout change because the whole window will go away soon.\n\t\t */\n\t\tif (w->layout_root == NULL)\n\t\t\tcontinue;\n\n\t\twl = winlink_find_by_window(&s->windows, w);\n\t\tif (wl != NULL) {\n\t\t\tcp = format_single(NULL, template, c, NULL, wl, NULL);\n\t\t\tcontrol_write(c, \"%s\", cp);\n\t\t\tfree(cp);\n\t\t}\n\t}\n}\n\nvoid\ncontrol_notify_window_pane_changed(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%window-pane-changed @%u %%%u\", w->id,\n\t\t    w->active->id);\n\t}\n}\n\nvoid\ncontrol_notify_window_unlinked(__unused struct session *s, struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL)\n\t\t\tcontrol_write(c, \"%%window-close @%u\", w->id);\n\t\telse\n\t\t\tcontrol_write(c, \"%%unlinked-window-close @%u\", w->id);\n\t}\n}\n\nvoid\ncontrol_notify_window_linked(__unused struct session *s, struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL)\n\t\t\tcontrol_write(c, \"%%window-add @%u\", w->id);\n\t\telse\n\t\t\tcontrol_write(c, \"%%unlinked-window-add @%u\", w->id);\n\t}\n}\n\nvoid\ncontrol_notify_window_renamed(struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL) {\n\t\t\tcontrol_write(c, \"%%window-renamed @%u %s\", w->id,\n\t\t\t    w->name);\n\t\t} else {\n\t\t\tcontrol_write(c, \"%%unlinked-window-renamed @%u %s\",\n\t\t\t    w->id, w->name);\n\t\t}\n\t}\n}\n\nvoid\ncontrol_notify_client_session_changed(struct client *cc)\n{\n\tstruct client\t*c;\n\tstruct session\t*s;\n\n\tif (cc->session == NULL)\n\t\treturn;\n\ts = cc->session;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\n\t\tif (cc == c) {\n\t\t\tcontrol_write(c, \"%%session-changed $%u %s\", s->id,\n\t\t\t    s->name);\n\t\t} else {\n\t\t\tcontrol_write(c, \"%%client-session-changed %s $%u %s\",\n\t\t\t    cc->name, s->id, s->name);\n\t\t}\n\t}\n}\n\nvoid\ncontrol_notify_client_detached(struct client *cc)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontrol_write(c, \"%%client-detached %s\", cc->name);\n\t}\n}\n\nvoid\ncontrol_notify_session_renamed(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%session-renamed $%u %s\", s->id, s->name);\n\t}\n}\n\nvoid\ncontrol_notify_session_created(__unused struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%sessions-changed\");\n\t}\n}\n\nvoid\ncontrol_notify_session_closed(__unused struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%sessions-changed\");\n\t}\n}\n\nvoid\ncontrol_notify_session_window_changed(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%session-window-changed $%u @%u\", s->id,\n\t\t    s->curw->window->id);\n\t}\n}\n\nvoid\ncontrol_notify_paste_buffer_changed(const char *name)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%paste-buffer-changed %s\", name);\n\t}\n}\n\nvoid\ncontrol_notify_paste_buffer_deleted(const char *name)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%paste-buffer-deleted %s\", name);\n\t}\n}\n"
        },
        {
          "name": "control.c",
          "type": "blob",
          "size": 27.291015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Block of data to output. Each client has one \"all\" queue of blocks and\n * another queue for each pane (in struct client_offset). %output blocks are\n * added to both queues and other output lines (notifications) added only to\n * the client queue.\n *\n * When a client becomes writeable, data from blocks on the pane queue are sent\n * up to the maximum size (CLIENT_BUFFER_HIGH). If a block is entirely written,\n * it is removed from both pane and client queues and if this means non-%output\n * blocks are now at the head of the client queue, they are written.\n *\n * This means a %output block holds up any subsequent non-%output blocks until\n * it is written which enforces ordering even if the client cannot accept the\n * entire block in one go.\n */\nstruct control_block {\n\tsize_t\t\t\t\t size;\n\tchar\t\t\t\t*line;\n\tuint64_t\t\t\t t;\n\n\tTAILQ_ENTRY(control_block)\t entry;\n\tTAILQ_ENTRY(control_block)\t all_entry;\n};\n\n/* Control client pane. */\nstruct control_pane {\n\tu_int\t\t\t\t pane;\n\n\t/*\n\t * Offsets into the pane data. The first (offset) is the data we have\n\t * written; the second (queued) the data we have queued (pointed to by\n\t * a block).\n\t */\n\tstruct window_pane_offset\t offset;\n\tstruct window_pane_offset\t queued;\n\n\tint\t\t\t\t flags;\n#define CONTROL_PANE_OFF 0x1\n#define CONTROL_PANE_PAUSED 0x2\n\n\tint\t\t\t\t pending_flag;\n\tTAILQ_ENTRY(control_pane)\t pending_entry;\n\n\tTAILQ_HEAD(, control_block)\t blocks;\n\n\tRB_ENTRY(control_pane)\t\t entry;\n};\nRB_HEAD(control_panes, control_pane);\n\n/* Subscription pane. */\nstruct control_sub_pane {\n\tu_int\t\t\t\t pane;\n\tu_int\t\t\t\t idx;\n\tchar\t\t\t\t*last;\n\n\tRB_ENTRY(control_sub_pane)\t entry;\n};\nRB_HEAD(control_sub_panes, control_sub_pane);\n\n/* Subscription window. */\nstruct control_sub_window {\n\tu_int\t\t\t\t window;\n\tu_int\t\t\t\t idx;\n\tchar\t\t\t\t*last;\n\n\tRB_ENTRY(control_sub_window)\t entry;\n};\nRB_HEAD(control_sub_windows, control_sub_window);\n\n/* Control client subscription. */\nstruct control_sub {\n\tchar\t\t\t\t*name;\n\tchar\t\t\t\t*format;\n\n\tenum control_sub_type\t\t type;\n\tu_int\t\t\t\t id;\n\n\tchar\t\t\t\t*last;\n\tstruct control_sub_panes\t panes;\n\tstruct control_sub_windows\t windows;\n\n\tRB_ENTRY(control_sub)\t\t entry;\n};\nRB_HEAD(control_subs, control_sub);\n\n/* Control client state. */\nstruct control_state {\n\tstruct control_panes\t\t panes;\n\n\tTAILQ_HEAD(, control_pane)\t pending_list;\n\tu_int\t\t\t\t pending_count;\n\n\tTAILQ_HEAD(, control_block)\t all_blocks;\n\n\tstruct bufferevent\t\t*read_event;\n\tstruct bufferevent\t\t*write_event;\n\n\tstruct control_subs\t\t subs;\n\tstruct event\t\t\t subs_timer;\n};\n\n/* Low and high watermarks. */\n#define CONTROL_BUFFER_LOW 512\n#define CONTROL_BUFFER_HIGH 8192\n\n/* Minimum to write to each client. */\n#define CONTROL_WRITE_MINIMUM 32\n\n/* Maximum age for clients that are not using pause mode. */\n#define CONTROL_MAXIMUM_AGE 300000\n\n/* Flags to ignore client. */\n#define CONTROL_IGNORE_FLAGS \\\n\t(CLIENT_CONTROL_NOOUTPUT| \\\n\t CLIENT_UNATTACHEDFLAGS)\n\n/* Compare client panes. */\nstatic int\ncontrol_pane_cmp(struct control_pane *cp1, struct control_pane *cp2)\n{\n\tif (cp1->pane < cp2->pane)\n\t\treturn (-1);\n\tif (cp1->pane > cp2->pane)\n\t\treturn (1);\n\treturn (0);\n}\nRB_GENERATE_STATIC(control_panes, control_pane, entry, control_pane_cmp);\n\n/* Compare client subs. */\nstatic int\ncontrol_sub_cmp(struct control_sub *csub1, struct control_sub *csub2)\n{\n\treturn (strcmp(csub1->name, csub2->name));\n}\nRB_GENERATE_STATIC(control_subs, control_sub, entry, control_sub_cmp);\n\n/* Compare client subscription panes. */\nstatic int\ncontrol_sub_pane_cmp(struct control_sub_pane *csp1,\n    struct control_sub_pane *csp2)\n{\n\tif (csp1->pane < csp2->pane)\n\t\treturn (-1);\n\tif (csp1->pane > csp2->pane)\n\t\treturn (1);\n\tif (csp1->idx < csp2->idx)\n\t\treturn (-1);\n\tif (csp1->idx > csp2->idx)\n\t\treturn (1);\n\treturn (0);\n}\nRB_GENERATE_STATIC(control_sub_panes, control_sub_pane, entry,\n    control_sub_pane_cmp);\n\n/* Compare client subscription windows. */\nstatic int\ncontrol_sub_window_cmp(struct control_sub_window *csw1,\n    struct control_sub_window *csw2)\n{\n\tif (csw1->window < csw2->window)\n\t\treturn (-1);\n\tif (csw1->window > csw2->window)\n\t\treturn (1);\n\tif (csw1->idx < csw2->idx)\n\t\treturn (-1);\n\tif (csw1->idx > csw2->idx)\n\t\treturn (1);\n\treturn (0);\n}\nRB_GENERATE_STATIC(control_sub_windows, control_sub_window, entry,\n    control_sub_window_cmp);\n\n/* Free a subscription. */\nstatic void\ncontrol_free_sub(struct control_state *cs, struct control_sub *csub)\n{\n\tstruct control_sub_pane\t\t*csp, *csp1;\n\tstruct control_sub_window\t*csw, *csw1;\n\n\tRB_FOREACH_SAFE(csp, control_sub_panes, &csub->panes, csp1) {\n\t\tRB_REMOVE(control_sub_panes, &csub->panes, csp);\n\t\tfree(csp);\n\t}\n\tRB_FOREACH_SAFE(csw, control_sub_windows, &csub->windows, csw1) {\n\t\tRB_REMOVE(control_sub_windows, &csub->windows, csw);\n\t\tfree(csw);\n\t}\n\tfree(csub->last);\n\n\tRB_REMOVE(control_subs, &cs->subs, csub);\n\tfree(csub->name);\n\tfree(csub->format);\n\tfree(csub);\n}\n\n/* Free a block. */\nstatic void\ncontrol_free_block(struct control_state *cs, struct control_block *cb)\n{\n\tfree(cb->line);\n\tTAILQ_REMOVE(&cs->all_blocks, cb, all_entry);\n\tfree(cb);\n}\n\n/* Get pane offsets for this client. */\nstatic struct control_pane *\ncontrol_get_pane(struct client *c, struct window_pane *wp)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t cp = { .pane = wp->id };\n\n\treturn (RB_FIND(control_panes, &cs->panes, &cp));\n}\n\n/* Add pane offsets for this client. */\nstatic struct control_pane *\ncontrol_add_pane(struct client *c, struct window_pane *wp)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp;\n\n\tcp = control_get_pane(c, wp);\n\tif (cp != NULL)\n\t\treturn (cp);\n\n\tcp = xcalloc(1, sizeof *cp);\n\tcp->pane = wp->id;\n\tRB_INSERT(control_panes, &cs->panes, cp);\n\n\tmemcpy(&cp->offset, &wp->offset, sizeof cp->offset);\n\tmemcpy(&cp->queued, &wp->offset, sizeof cp->queued);\n\tTAILQ_INIT(&cp->blocks);\n\n\treturn (cp);\n}\n\n/* Discard output for a pane. */\nstatic void\ncontrol_discard_pane(struct client *c, struct control_pane *cp)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_block\t*cb, *cb1;\n\n\tTAILQ_FOREACH_SAFE(cb, &cp->blocks, entry, cb1) {\n\t\tTAILQ_REMOVE(&cp->blocks, cb, entry);\n\t\tcontrol_free_block(cs, cb);\n\t}\n}\n\n/* Get actual pane for this client. */\nstatic struct window_pane *\ncontrol_window_pane(struct client *c, u_int pane)\n{\n\tstruct window_pane\t*wp;\n\n\tif (c->session == NULL)\n\t\treturn (NULL);\n\tif ((wp = window_pane_find_by_id(pane)) == NULL)\n\t\treturn (NULL);\n\tif (winlink_find_by_window(&c->session->windows, wp->window) == NULL)\n\t\treturn (NULL);\n\treturn (wp);\n}\n\n/* Reset control offsets. */\nvoid\ncontrol_reset_offsets(struct client *c)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp, *cp1;\n\n\tRB_FOREACH_SAFE(cp, control_panes, &cs->panes, cp1) {\n\t\tRB_REMOVE(control_panes, &cs->panes, cp);\n\t\tfree(cp);\n\t}\n\n\tTAILQ_INIT(&cs->pending_list);\n\tcs->pending_count = 0;\n}\n\n/* Get offsets for client. */\nstruct window_pane_offset *\ncontrol_pane_offset(struct client *c, struct window_pane *wp, int *off)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp;\n\n\tif (c->flags & CLIENT_CONTROL_NOOUTPUT) {\n\t\t*off = 0;\n\t\treturn (NULL);\n\t}\n\n\tcp = control_get_pane(c, wp);\n\tif (cp == NULL || (cp->flags & CONTROL_PANE_PAUSED)) {\n\t\t*off = 0;\n\t\treturn (NULL);\n\t}\n\tif (cp->flags & CONTROL_PANE_OFF) {\n\t\t*off = 1;\n\t\treturn (NULL);\n\t}\n\t*off = (EVBUFFER_LENGTH(cs->write_event->output) >= CONTROL_BUFFER_LOW);\n\treturn (&cp->offset);\n}\n\n/* Set pane as on. */\nvoid\ncontrol_set_pane_on(struct client *c, struct window_pane *wp)\n{\n\tstruct control_pane\t*cp;\n\n\tcp = control_get_pane(c, wp);\n\tif (cp != NULL && (cp->flags & CONTROL_PANE_OFF)) {\n\t\tcp->flags &= ~CONTROL_PANE_OFF;\n\t\tmemcpy(&cp->offset, &wp->offset, sizeof cp->offset);\n\t\tmemcpy(&cp->queued, &wp->offset, sizeof cp->queued);\n\t}\n}\n\n/* Set pane as off. */\nvoid\ncontrol_set_pane_off(struct client *c, struct window_pane *wp)\n{\n\tstruct control_pane\t*cp;\n\n\tcp = control_add_pane(c, wp);\n\tcp->flags |= CONTROL_PANE_OFF;\n}\n\n/* Continue a paused pane. */\nvoid\ncontrol_continue_pane(struct client *c, struct window_pane *wp)\n{\n\tstruct control_pane\t*cp;\n\n\tcp = control_get_pane(c, wp);\n\tif (cp != NULL && (cp->flags & CONTROL_PANE_PAUSED)) {\n\t\tcp->flags &= ~CONTROL_PANE_PAUSED;\n\t\tmemcpy(&cp->offset, &wp->offset, sizeof cp->offset);\n\t\tmemcpy(&cp->queued, &wp->offset, sizeof cp->queued);\n\t\tcontrol_write(c, \"%%continue %%%u\", wp->id);\n\t}\n}\n\n/* Pause a pane. */\nvoid\ncontrol_pause_pane(struct client *c, struct window_pane *wp)\n{\n\tstruct control_pane\t*cp;\n\n\tcp = control_add_pane(c, wp);\n\tif (~cp->flags & CONTROL_PANE_PAUSED) {\n\t\tcp->flags |= CONTROL_PANE_PAUSED;\n\t\tcontrol_discard_pane(c, cp);\n\t\tcontrol_write(c, \"%%pause %%%u\", wp->id);\n\t}\n}\n\n/* Write a line. */\nstatic void printflike(2, 0)\ncontrol_vwrite(struct client *c, const char *fmt, va_list ap)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tchar\t\t\t*s;\n\n\txvasprintf(&s, fmt, ap);\n\tlog_debug(\"%s: %s: writing line: %s\", __func__, c->name, s);\n\n\tbufferevent_write(cs->write_event, s, strlen(s));\n\tbufferevent_write(cs->write_event, \"\\n\", 1);\n\n\tbufferevent_enable(cs->write_event, EV_WRITE);\n\tfree(s);\n}\n\n/* Write a line. */\nvoid\ncontrol_write(struct client *c, const char *fmt, ...)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_block\t*cb;\n\tva_list\t\t\t ap;\n\n\tva_start(ap, fmt);\n\n\tif (TAILQ_EMPTY(&cs->all_blocks)) {\n\t\tcontrol_vwrite(c, fmt, ap);\n\t\tva_end(ap);\n\t\treturn;\n\t}\n\n\tcb = xcalloc(1, sizeof *cb);\n\txvasprintf(&cb->line, fmt, ap);\n\tTAILQ_INSERT_TAIL(&cs->all_blocks, cb, all_entry);\n\tcb->t = get_timer();\n\n\tlog_debug(\"%s: %s: storing line: %s\", __func__, c->name, cb->line);\n\tbufferevent_enable(cs->write_event, EV_WRITE);\n\n\tva_end(ap);\n}\n\n/* Check age for this pane. */\nstatic int\ncontrol_check_age(struct client *c, struct window_pane *wp,\n    struct control_pane *cp)\n{\n\tstruct control_block\t*cb;\n\tuint64_t\t\t t, age;\n\n\tcb = TAILQ_FIRST(&cp->blocks);\n\tif (cb == NULL)\n\t\treturn (0);\n\tt = get_timer();\n\tif (cb->t >= t)\n\t\treturn (0);\n\n\tage = t - cb->t;\n\tlog_debug(\"%s: %s: %%%u is %llu behind\", __func__, c->name, wp->id,\n\t    (unsigned long long)age);\n\n\tif (c->flags & CLIENT_CONTROL_PAUSEAFTER) {\n\t\tif (age < c->pause_age)\n\t\t\treturn (0);\n\t\tcp->flags |= CONTROL_PANE_PAUSED;\n\t\tcontrol_discard_pane(c, cp);\n\t\tcontrol_write(c, \"%%pause %%%u\", wp->id);\n\t} else {\n\t\tif (age < CONTROL_MAXIMUM_AGE)\n\t\t\treturn (0);\n\t\tc->exit_message = xstrdup(\"too far behind\");\n\t\tc->flags |= CLIENT_EXIT;\n\t\tcontrol_discard(c);\n\t}\n\treturn (1);\n}\n\n/* Write output from a pane. */\nvoid\ncontrol_write_output(struct client *c, struct window_pane *wp)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp;\n\tstruct control_block\t*cb;\n\tsize_t\t\t\t new_size;\n\n\tif (winlink_find_by_window(&c->session->windows, wp->window) == NULL)\n\t\treturn;\n\n\tif (c->flags & CONTROL_IGNORE_FLAGS) {\n\t\tcp = control_get_pane(c, wp);\n\t\tif (cp != NULL)\n\t\t\tgoto ignore;\n\t\treturn;\n\t}\n\tcp = control_add_pane(c, wp);\n\tif (cp->flags & (CONTROL_PANE_OFF|CONTROL_PANE_PAUSED))\n\t\tgoto ignore;\n\tif (control_check_age(c, wp, cp))\n\t\treturn;\n\n\twindow_pane_get_new_data(wp, &cp->queued, &new_size);\n\tif (new_size == 0)\n\t\treturn;\n\twindow_pane_update_used_data(wp, &cp->queued, new_size);\n\n\tcb = xcalloc(1, sizeof *cb);\n\tcb->size = new_size;\n\tTAILQ_INSERT_TAIL(&cs->all_blocks, cb, all_entry);\n\tcb->t = get_timer();\n\n\tTAILQ_INSERT_TAIL(&cp->blocks, cb, entry);\n\tlog_debug(\"%s: %s: new output block of %zu for %%%u\", __func__, c->name,\n\t    cb->size, wp->id);\n\n\tif (!cp->pending_flag) {\n\t\tlog_debug(\"%s: %s: %%%u now pending\", __func__, c->name,\n\t\t    wp->id);\n\t\tTAILQ_INSERT_TAIL(&cs->pending_list, cp, pending_entry);\n\t\tcp->pending_flag = 1;\n\t\tcs->pending_count++;\n\t}\n\tbufferevent_enable(cs->write_event, EV_WRITE);\n\treturn;\n\nignore:\n\tlog_debug(\"%s: %s: ignoring pane %%%u\", __func__, c->name, wp->id);\n\twindow_pane_update_used_data(wp, &cp->offset, SIZE_MAX);\n\twindow_pane_update_used_data(wp, &cp->queued, SIZE_MAX);\n}\n\n/* Control client error callback. */\nstatic enum cmd_retval\ncontrol_error(struct cmdq_item *item, void *data)\n{\n\tstruct client\t*c = cmdq_get_client(item);\n\tchar\t\t*error = data;\n\n\tcmdq_guard(item, \"begin\", 1);\n\tcontrol_write(c, \"parse error: %s\", error);\n\tcmdq_guard(item, \"error\", 1);\n\n\tfree(error);\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Control client error callback. */\nstatic void\ncontrol_error_callback(__unused struct bufferevent *bufev,\n    __unused short what, void *data)\n{\n\tstruct client\t*c = data;\n\n\tc->flags |= CLIENT_EXIT;\n}\n\n/* Control client input callback. Read lines and fire commands. */\nstatic void\ncontrol_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct client\t\t*c = data;\n\tstruct control_state\t*cs = c->control_state;\n\tstruct evbuffer\t\t*buffer = cs->read_event->input;\n\tchar\t\t\t*line, *error;\n\tstruct cmdq_state\t*state;\n\tenum cmd_parse_status\t status;\n\n\tfor (;;) {\n\t\tline = evbuffer_readln(buffer, NULL, EVBUFFER_EOL_LF);\n\t\tif (line == NULL)\n\t\t\tbreak;\n\t\tlog_debug(\"%s: %s: %s\", __func__, c->name, line);\n\t\tif (*line == '\\0') { /* empty line detach */\n\t\t\tfree(line);\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstate = cmdq_new_state(NULL, NULL, CMDQ_STATE_CONTROL);\n\t\tstatus = cmd_parse_and_append(line, NULL, c, state, &error);\n\t\tif (status == CMD_PARSE_ERROR)\n\t\t\tcmdq_append(c, cmdq_get_callback(control_error, error));\n\t\tcmdq_free_state(state);\n\n\t\tfree(line);\n\t}\n}\n\n/* Does this control client have outstanding data to write? */\nint\ncontrol_all_done(struct client *c)\n{\n\tstruct control_state\t*cs = c->control_state;\n\n\tif (!TAILQ_EMPTY(&cs->all_blocks))\n\t\treturn (0);\n\treturn (EVBUFFER_LENGTH(cs->write_event->output) == 0);\n}\n\n/* Flush all blocks until output. */\nstatic void\ncontrol_flush_all_blocks(struct client *c)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_block\t*cb, *cb1;\n\n\tTAILQ_FOREACH_SAFE(cb, &cs->all_blocks, all_entry, cb1) {\n\t\tif (cb->size != 0)\n\t\t\tbreak;\n\t\tlog_debug(\"%s: %s: flushing line: %s\", __func__, c->name,\n\t\t    cb->line);\n\n\t\tbufferevent_write(cs->write_event, cb->line, strlen(cb->line));\n\t\tbufferevent_write(cs->write_event, \"\\n\", 1);\n\t\tcontrol_free_block(cs, cb);\n\t}\n}\n\n/* Append data to buffer. */\nstatic struct evbuffer *\ncontrol_append_data(struct client *c, struct control_pane *cp, uint64_t age,\n    struct evbuffer *message, struct window_pane *wp, size_t size)\n{\n\tu_char\t*new_data;\n\tsize_t\t new_size;\n\tu_int\t i;\n\n\tif (message == NULL) {\n\t\tmessage = evbuffer_new();\n\t\tif (message == NULL)\n\t\t\tfatalx(\"out of memory\");\n\t\tif (c->flags & CLIENT_CONTROL_PAUSEAFTER) {\n\t\t\tevbuffer_add_printf(message,\n\t\t\t    \"%%extended-output %%%u %llu : \", wp->id,\n\t\t\t    (unsigned long long)age);\n\t\t} else\n\t\t\tevbuffer_add_printf(message, \"%%output %%%u \", wp->id);\n\t}\n\n\tnew_data = window_pane_get_new_data(wp, &cp->offset, &new_size);\n\tif (new_size < size)\n\t\tfatalx(\"not enough data: %zu < %zu\", new_size, size);\n\tfor (i = 0; i < size; i++) {\n\t\tif (new_data[i] < ' ' || new_data[i] == '\\\\')\n\t\t\tevbuffer_add_printf(message, \"\\\\%03o\", new_data[i]);\n\t\telse\n\t\t\tevbuffer_add_printf(message, \"%c\", new_data[i]);\n\t}\n\twindow_pane_update_used_data(wp, &cp->offset, size);\n\treturn (message);\n}\n\n/* Write buffer. */\nstatic void\ncontrol_write_data(struct client *c, struct evbuffer *message)\n{\n\tstruct control_state\t*cs = c->control_state;\n\n\tlog_debug(\"%s: %s: %.*s\", __func__, c->name,\n\t    (int)EVBUFFER_LENGTH(message), EVBUFFER_DATA(message));\n\n\tevbuffer_add(message, \"\\n\", 1);\n\tbufferevent_write_buffer(cs->write_event, message);\n\tevbuffer_free(message);\n}\n\n/* Write output to client. */\nstatic int\ncontrol_write_pending(struct client *c, struct control_pane *cp, size_t limit)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct window_pane\t*wp = NULL;\n\tstruct evbuffer\t\t*message = NULL;\n\tsize_t\t\t\t used = 0, size;\n\tstruct control_block\t*cb, *cb1;\n\tuint64_t\t\t age, t = get_timer();\n\n\twp = control_window_pane(c, cp->pane);\n\tif (wp == NULL || wp->fd == -1) {\n\t\tTAILQ_FOREACH_SAFE(cb, &cp->blocks, entry, cb1) {\n\t\t\tTAILQ_REMOVE(&cp->blocks, cb, entry);\n\t\t\tcontrol_free_block(cs, cb);\n\t\t}\n\t\tcontrol_flush_all_blocks(c);\n\t\treturn (0);\n\t}\n\n\twhile (used != limit && !TAILQ_EMPTY(&cp->blocks)) {\n\t\tif (control_check_age(c, wp, cp)) {\n\t\t\tif (message != NULL)\n\t\t\t\tevbuffer_free(message);\n\t\t\tmessage = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tcb = TAILQ_FIRST(&cp->blocks);\n\t\tif (cb->t < t)\n\t\t\tage = t - cb->t;\n\t\telse\n\t\t\tage = 0;\n\t\tlog_debug(\"%s: %s: output block %zu (age %llu) for %%%u \"\n\t\t    \"(used %zu/%zu)\", __func__, c->name, cb->size,\n\t\t    (unsigned long long)age, cp->pane, used, limit);\n\n\t\tsize = cb->size;\n\t\tif (size > limit - used)\n\t\t\tsize = limit - used;\n\t\tused += size;\n\n\t\tmessage = control_append_data(c, cp, age, message, wp, size);\n\n\t\tcb->size -= size;\n\t\tif (cb->size == 0) {\n\t\t\tTAILQ_REMOVE(&cp->blocks, cb, entry);\n\t\t\tcontrol_free_block(cs, cb);\n\n\t\t\tcb = TAILQ_FIRST(&cs->all_blocks);\n\t\t\tif (cb != NULL && cb->size == 0) {\n\t\t\t\tif (wp != NULL && message != NULL) {\n\t\t\t\t\tcontrol_write_data(c, message);\n\t\t\t\t\tmessage = NULL;\n\t\t\t\t}\n\t\t\t\tcontrol_flush_all_blocks(c);\n\t\t\t}\n\t\t}\n\t}\n\tif (message != NULL)\n\t\tcontrol_write_data(c, message);\n\treturn (!TAILQ_EMPTY(&cp->blocks));\n}\n\n/* Control client write callback. */\nstatic void\ncontrol_write_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct client\t\t*c = data;\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp, *cp1;\n\tstruct evbuffer\t\t*evb = cs->write_event->output;\n\tsize_t\t\t\t space, limit;\n\n\tcontrol_flush_all_blocks(c);\n\n\twhile (EVBUFFER_LENGTH(evb) < CONTROL_BUFFER_HIGH) {\n\t\tif (cs->pending_count == 0)\n\t\t\tbreak;\n\t\tspace = CONTROL_BUFFER_HIGH - EVBUFFER_LENGTH(evb);\n\t\tlog_debug(\"%s: %s: %zu bytes available, %u panes\", __func__,\n\t\t    c->name, space, cs->pending_count);\n\n\t\tlimit = (space / cs->pending_count / 3); /* 3 bytes for \\xxx */\n\t\tif (limit < CONTROL_WRITE_MINIMUM)\n\t\t\tlimit = CONTROL_WRITE_MINIMUM;\n\n\t\tTAILQ_FOREACH_SAFE(cp, &cs->pending_list, pending_entry, cp1) {\n\t\t\tif (EVBUFFER_LENGTH(evb) >= CONTROL_BUFFER_HIGH)\n\t\t\t\tbreak;\n\t\t\tif (control_write_pending(c, cp, limit))\n\t\t\t\tcontinue;\n\t\t\tTAILQ_REMOVE(&cs->pending_list, cp, pending_entry);\n\t\t\tcp->pending_flag = 0;\n\t\t\tcs->pending_count--;\n\t\t}\n\t}\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\tbufferevent_disable(cs->write_event, EV_WRITE);\n}\n\n/* Initialize for control mode. */\nvoid\ncontrol_start(struct client *c)\n{\n\tstruct control_state\t*cs;\n\n\tif (c->flags & CLIENT_CONTROLCONTROL) {\n\t\tclose(c->out_fd);\n\t\tc->out_fd = -1;\n\t} else\n\t\tsetblocking(c->out_fd, 0);\n\tsetblocking(c->fd, 0);\n\n\tcs = c->control_state = xcalloc(1, sizeof *cs);\n\tRB_INIT(&cs->panes);\n\tTAILQ_INIT(&cs->pending_list);\n\tTAILQ_INIT(&cs->all_blocks);\n\tRB_INIT(&cs->subs);\n\n\tcs->read_event = bufferevent_new(c->fd, control_read_callback,\n\t    control_write_callback, control_error_callback, c);\n\tif (cs->read_event == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tif (c->flags & CLIENT_CONTROLCONTROL)\n\t\tcs->write_event = cs->read_event;\n\telse {\n\t\tcs->write_event = bufferevent_new(c->out_fd, NULL,\n\t\t    control_write_callback, control_error_callback, c);\n\t\tif (cs->write_event == NULL)\n\t\t\tfatalx(\"out of memory\");\n\t}\n\tbufferevent_setwatermark(cs->write_event, EV_WRITE, CONTROL_BUFFER_LOW,\n\t    0);\n\n\tif (c->flags & CLIENT_CONTROLCONTROL) {\n\t\tbufferevent_write(cs->write_event, \"\\033P1000p\", 7);\n\t\tbufferevent_enable(cs->write_event, EV_WRITE);\n\t}\n}\n\n/* Control client ready. */\nvoid\ncontrol_ready(struct client *c)\n{\n\tbufferevent_enable(c->control_state->read_event, EV_READ);\n}\n\n/* Discard all output for a client. */\nvoid\ncontrol_discard(struct client *c)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_pane\t*cp;\n\n\tRB_FOREACH(cp, control_panes, &cs->panes)\n\t\tcontrol_discard_pane(c, cp);\n\tbufferevent_disable(cs->read_event, EV_READ);\n}\n\n/* Stop control mode. */\nvoid\ncontrol_stop(struct client *c)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_block\t*cb, *cb1;\n\tstruct control_sub\t*csub, *csub1;\n\n\tif (~c->flags & CLIENT_CONTROLCONTROL)\n\t\tbufferevent_free(cs->write_event);\n\tbufferevent_free(cs->read_event);\n\n\tRB_FOREACH_SAFE(csub, control_subs, &cs->subs, csub1)\n\t\tcontrol_free_sub(cs, csub);\n\tif (evtimer_initialized(&cs->subs_timer))\n\t\tevtimer_del(&cs->subs_timer);\n\n\tTAILQ_FOREACH_SAFE(cb, &cs->all_blocks, all_entry, cb1)\n\t\tcontrol_free_block(cs, cb);\n\tcontrol_reset_offsets(c);\n\n\tfree(cs);\n}\n\n/* Check session subscription. */\nstatic void\ncontrol_check_subs_session(struct client *c, struct control_sub *csub)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*value;\n\n\tft = format_create_defaults(NULL, c, s, NULL, NULL);\n\tvalue = format_expand(ft, csub->format);\n\tformat_free(ft);\n\n\tif (csub->last != NULL && strcmp(value, csub->last) == 0) {\n\t\tfree(value);\n\t\treturn;\n\t}\n\tcontrol_write(c,\n\t    \"%%subscription-changed %s $%u - - - : %s\",\n\t    csub->name, s->id, value);\n\tfree(csub->last);\n\tcsub->last = value;\n}\n\n/* Check pane subscription. */\nstatic void\ncontrol_check_subs_pane(struct client *c, struct control_sub *csub)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct window_pane\t*wp;\n\tstruct window\t\t*w;\n\tstruct winlink\t\t*wl;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*value;\n\tstruct control_sub_pane\t*csp, find;\n\n\twp = window_pane_find_by_id(csub->id);\n\tif (wp == NULL || wp->fd == -1)\n\t\treturn;\n\tw = wp->window;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session != s)\n\t\t\tcontinue;\n\n\t\tft = format_create_defaults(NULL, c, s, wl, wp);\n\t\tvalue = format_expand(ft, csub->format);\n\t\tformat_free(ft);\n\n\t\tfind.pane = wp->id;\n\t\tfind.idx = wl->idx;\n\n\t\tcsp = RB_FIND(control_sub_panes, &csub->panes, &find);\n\t\tif (csp == NULL) {\n\t\t\tcsp = xcalloc(1, sizeof *csp);\n\t\t\tcsp->pane = wp->id;\n\t\t\tcsp->idx = wl->idx;\n\t\t\tRB_INSERT(control_sub_panes, &csub->panes, csp);\n\t\t}\n\n\t\tif (csp->last != NULL && strcmp(value, csp->last) == 0) {\n\t\t\tfree(value);\n\t\t\tcontinue;\n\t\t}\n\t\tcontrol_write(c,\n\t\t    \"%%subscription-changed %s $%u @%u %u %%%u : %s\",\n\t\t    csub->name, s->id, w->id, wl->idx, wp->id, value);\n\t\tfree(csp->last);\n\t\tcsp->last = value;\n\t}\n}\n\n/* Check all panes subscription. */\nstatic void\ncontrol_check_subs_all_panes(struct client *c, struct control_sub *csub)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct window_pane\t*wp;\n\tstruct window\t\t*w;\n\tstruct winlink\t\t*wl;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*value;\n\tstruct control_sub_pane\t*csp, find;\n\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tw = wl->window;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tft = format_create_defaults(NULL, c, s, wl, wp);\n\t\t\tvalue = format_expand(ft, csub->format);\n\t\t\tformat_free(ft);\n\n\t\t\tfind.pane = wp->id;\n\t\t\tfind.idx = wl->idx;\n\n\t\t\tcsp = RB_FIND(control_sub_panes, &csub->panes, &find);\n\t\t\tif (csp == NULL) {\n\t\t\t\tcsp = xcalloc(1, sizeof *csp);\n\t\t\t\tcsp->pane = wp->id;\n\t\t\t\tcsp->idx = wl->idx;\n\t\t\t\tRB_INSERT(control_sub_panes, &csub->panes, csp);\n\t\t\t}\n\n\t\t\tif (csp->last != NULL &&\n\t\t\t    strcmp(value, csp->last) == 0) {\n\t\t\t\tfree(value);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcontrol_write(c,\n\t\t\t    \"%%subscription-changed %s $%u @%u %u %%%u : %s\",\n\t\t\t    csub->name, s->id, w->id, wl->idx, wp->id, value);\n\t\t\tfree(csp->last);\n\t\t\tcsp->last = value;\n\t\t}\n\t}\n}\n\n/* Check window subscription. */\nstatic void\ncontrol_check_subs_window(struct client *c, struct control_sub *csub)\n{\n\tstruct session\t\t\t*s = c->session;\n\tstruct window\t\t\t*w;\n\tstruct winlink\t\t\t*wl;\n\tstruct format_tree\t\t*ft;\n\tchar\t\t\t\t*value;\n\tstruct control_sub_window\t*csw, find;\n\n\tw = window_find_by_id(csub->id);\n\tif (w == NULL)\n\t\treturn;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session != s)\n\t\t\tcontinue;\n\n\t\tft = format_create_defaults(NULL, c, s, wl, NULL);\n\t\tvalue = format_expand(ft, csub->format);\n\t\tformat_free(ft);\n\n\t\tfind.window = w->id;\n\t\tfind.idx = wl->idx;\n\n\t\tcsw = RB_FIND(control_sub_windows, &csub->windows, &find);\n\t\tif (csw == NULL) {\n\t\t\tcsw = xcalloc(1, sizeof *csw);\n\t\t\tcsw->window = w->id;\n\t\t\tcsw->idx = wl->idx;\n\t\t\tRB_INSERT(control_sub_windows, &csub->windows, csw);\n\t\t}\n\n\t\tif (csw->last != NULL && strcmp(value, csw->last) == 0) {\n\t\t\tfree(value);\n\t\t\tcontinue;\n\t\t}\n\t\tcontrol_write(c,\n\t\t    \"%%subscription-changed %s $%u @%u %u - : %s\",\n\t\t    csub->name, s->id, w->id, wl->idx, value);\n\t\tfree(csw->last);\n\t\tcsw->last = value;\n\t}\n}\n\n/* Check all windows subscription. */\nstatic void\ncontrol_check_subs_all_windows(struct client *c, struct control_sub *csub)\n{\n\tstruct session\t\t\t*s = c->session;\n\tstruct window\t\t\t*w;\n\tstruct winlink\t\t\t*wl;\n\tstruct format_tree\t\t*ft;\n\tchar\t\t\t\t*value;\n\tstruct control_sub_window\t*csw, find;\n\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tw = wl->window;\n\n\t\tft = format_create_defaults(NULL, c, s, wl, NULL);\n\t\tvalue = format_expand(ft, csub->format);\n\t\tformat_free(ft);\n\n\t\tfind.window = w->id;\n\t\tfind.idx = wl->idx;\n\n\t\tcsw = RB_FIND(control_sub_windows, &csub->windows, &find);\n\t\tif (csw == NULL) {\n\t\t\tcsw = xcalloc(1, sizeof *csw);\n\t\t\tcsw->window = w->id;\n\t\t\tcsw->idx = wl->idx;\n\t\t\tRB_INSERT(control_sub_windows, &csub->windows, csw);\n\t\t}\n\n\t\tif (csw->last != NULL && strcmp(value, csw->last) == 0) {\n\t\t\tfree(value);\n\t\t\tcontinue;\n\t\t}\n\t\tcontrol_write(c,\n\t\t    \"%%subscription-changed %s $%u @%u %u - : %s\",\n\t\t    csub->name, s->id, w->id, wl->idx, value);\n\t\tfree(csw->last);\n\t\tcsw->last = value;\n\t}\n}\n\n/* Check subscriptions timer. */\nstatic void\ncontrol_check_subs_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct client\t\t*c = data;\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_sub\t*csub, *csub1;\n\tstruct timeval\t\t tv = { .tv_sec = 1 };\n\n\tlog_debug(\"%s: timer fired\", __func__);\n\tevtimer_add(&cs->subs_timer, &tv);\n\n\tRB_FOREACH_SAFE(csub, control_subs, &cs->subs, csub1) {\n\t\tswitch (csub->type) {\n\t\tcase CONTROL_SUB_SESSION:\n\t\t\tcontrol_check_subs_session(c, csub);\n\t\t\tbreak;\n\t\tcase CONTROL_SUB_PANE:\n\t\t\tcontrol_check_subs_pane(c, csub);\n\t\t\tbreak;\n\t\tcase CONTROL_SUB_ALL_PANES:\n\t\t\tcontrol_check_subs_all_panes(c, csub);\n\t\t\tbreak;\n\t\tcase CONTROL_SUB_WINDOW:\n\t\t\tcontrol_check_subs_window(c, csub);\n\t\t\tbreak;\n\t\tcase CONTROL_SUB_ALL_WINDOWS:\n\t\t\tcontrol_check_subs_all_windows(c, csub);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Add a subscription. */\nvoid\ncontrol_add_sub(struct client *c, const char *name, enum control_sub_type type,\n    int id, const char *format)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_sub\t*csub, find;\n\tstruct timeval\t\t tv = { .tv_sec = 1 };\n\n\tfind.name = (char *)name;\n\tif ((csub = RB_FIND(control_subs, &cs->subs, &find)) != NULL)\n\t\tcontrol_free_sub(cs, csub);\n\n\tcsub = xcalloc(1, sizeof *csub);\n\tcsub->name = xstrdup(name);\n\tcsub->type = type;\n\tcsub->id = id;\n\tcsub->format = xstrdup(format);\n\tRB_INSERT(control_subs, &cs->subs, csub);\n\n\tRB_INIT(&csub->panes);\n\tRB_INIT(&csub->windows);\n\n\tif (!evtimer_initialized(&cs->subs_timer))\n\t\tevtimer_set(&cs->subs_timer, control_check_subs_timer, c);\n\tif (!evtimer_pending(&cs->subs_timer, NULL))\n\t\tevtimer_add(&cs->subs_timer, &tv);\n}\n\n/* Remove a subscription. */\nvoid\ncontrol_remove_sub(struct client *c, const char *name)\n{\n\tstruct control_state\t*cs = c->control_state;\n\tstruct control_sub\t*csub, find;\n\n\tfind.name = (char *)name;\n\tif ((csub = RB_FIND(control_subs, &cs->subs, &find)) != NULL)\n\t\tcontrol_free_sub(cs, csub);\n\tif (RB_EMPTY(&cs->subs))\n\t\tevtimer_del(&cs->subs_timer);\n}\n"
        },
        {
          "name": "environ.c",
          "type": "blob",
          "size": 6.2890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Environment - manipulate a set of environment variables.\n */\n\nRB_HEAD(environ, environ_entry);\nstatic int environ_cmp(struct environ_entry *, struct environ_entry *);\nRB_GENERATE_STATIC(environ, environ_entry, entry, environ_cmp);\n\nstatic int\nenviron_cmp(struct environ_entry *envent1, struct environ_entry *envent2)\n{\n\treturn (strcmp(envent1->name, envent2->name));\n}\n\n/* Initialise the environment. */\nstruct environ *\nenviron_create(void)\n{\n\tstruct environ\t*env;\n\n\tenv = xcalloc(1, sizeof *env);\n\tRB_INIT(env);\n\n\treturn (env);\n}\n\n/* Free an environment. */\nvoid\nenviron_free(struct environ *env)\n{\n\tstruct environ_entry\t*envent, *envent1;\n\n\tRB_FOREACH_SAFE(envent, environ, env, envent1) {\n\t\tRB_REMOVE(environ, env, envent);\n\t\tfree(envent->name);\n\t\tfree(envent->value);\n\t\tfree(envent);\n\t}\n\tfree(env);\n}\n\nstruct environ_entry *\nenviron_first(struct environ *env)\n{\n\treturn (RB_MIN(environ, env));\n}\n\nstruct environ_entry *\nenviron_next(struct environ_entry *envent)\n{\n\treturn (RB_NEXT(environ, env, envent));\n}\n\n/* Copy one environment into another. */\nvoid\nenviron_copy(struct environ *srcenv, struct environ *dstenv)\n{\n\tstruct environ_entry\t*envent;\n\n\tRB_FOREACH(envent, environ, srcenv) {\n\t\tif (envent->value == NULL)\n\t\t\tenviron_clear(dstenv, envent->name);\n\t\telse {\n\t\t\tenviron_set(dstenv, envent->name, envent->flags,\n\t\t\t    \"%s\", envent->value);\n\t\t}\n\t}\n}\n\n/* Find an environment variable. */\nstruct environ_entry *\nenviron_find(struct environ *env, const char *name)\n{\n\tstruct environ_entry\tenvent;\n\n\tenvent.name = (char *) name;\n\treturn (RB_FIND(environ, env, &envent));\n}\n\n/* Set an environment variable. */\nvoid\nenviron_set(struct environ *env, const char *name, int flags, const char *fmt,\n    ...)\n{\n\tstruct environ_entry\t*envent;\n\tva_list\t\t\t ap;\n\n\tva_start(ap, fmt);\n\tif ((envent = environ_find(env, name)) != NULL) {\n\t\tenvent->flags = flags;\n\t\tfree(envent->value);\n\t\txvasprintf(&envent->value, fmt, ap);\n\t} else {\n\t\tenvent = xmalloc(sizeof *envent);\n\t\tenvent->name = xstrdup(name);\n\t\tenvent->flags = flags;\n\t\txvasprintf(&envent->value, fmt, ap);\n\t\tRB_INSERT(environ, env, envent);\n\t}\n\tva_end(ap);\n}\n\n/* Clear an environment variable. */\nvoid\nenviron_clear(struct environ *env, const char *name)\n{\n\tstruct environ_entry\t*envent;\n\n\tif ((envent = environ_find(env, name)) != NULL) {\n\t\tfree(envent->value);\n\t\tenvent->value = NULL;\n\t} else {\n\t\tenvent = xmalloc(sizeof *envent);\n\t\tenvent->name = xstrdup(name);\n\t\tenvent->flags = 0;\n\t\tenvent->value = NULL;\n\t\tRB_INSERT(environ, env, envent);\n\t}\n}\n\n/* Set an environment variable from a NAME=VALUE string. */\nvoid\nenviron_put(struct environ *env, const char *var, int flags)\n{\n\tchar\t*name, *value;\n\n\tvalue = strchr(var, '=');\n\tif (value == NULL)\n\t\treturn;\n\tvalue++;\n\n\tname = xstrdup(var);\n\tname[strcspn(name, \"=\")] = '\\0';\n\n\tenviron_set(env, name, flags, \"%s\", value);\n\tfree(name);\n}\n\n/* Unset an environment variable. */\nvoid\nenviron_unset(struct environ *env, const char *name)\n{\n\tstruct environ_entry\t*envent;\n\n\tif ((envent = environ_find(env, name)) == NULL)\n\t\treturn;\n\tRB_REMOVE(environ, env, envent);\n\tfree(envent->name);\n\tfree(envent->value);\n\tfree(envent);\n}\n\n/* Copy variables from a destination into a source environment. */\nvoid\nenviron_update(struct options *oo, struct environ *src, struct environ *dst)\n{\n\tstruct environ_entry\t\t*envent;\n\tstruct environ_entry\t\t*envent1;\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tunion options_value\t\t*ov;\n\tint\t\t\t\t found;\n\n\to = options_get(oo, \"update-environment\");\n\tif (o == NULL)\n\t\treturn;\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tov = options_array_item_value(a);\n\t\tfound = 0;\n\t\tRB_FOREACH_SAFE(envent, environ, src, envent1) {\n\t\t\tif (fnmatch(ov->string, envent->name, 0) == 0) {\n\t\t\t\tenviron_set(dst, envent->name, 0, \"%s\", envent->value);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tenviron_clear(dst, ov->string);\n\t\ta = options_array_next(a);\n\t}\n}\n\n/* Push environment into the real environment - use after fork(). */\nvoid\nenviron_push(struct environ *env)\n{\n\tstruct environ_entry\t*envent;\n\n\tenviron = xcalloc(1, sizeof *environ);\n\tRB_FOREACH(envent, environ, env) {\n\t\tif (envent->value != NULL &&\n\t\t    *envent->name != '\\0' &&\n\t\t    (~envent->flags & ENVIRON_HIDDEN))\n\t\t\tsetenv(envent->name, envent->value, 1);\n\t}\n}\n\n/* Log the environment. */\nvoid\nenviron_log(struct environ *env, const char *fmt, ...)\n{\n\tstruct environ_entry\t*envent;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*prefix;\n\n\tva_start(ap, fmt);\n\tvasprintf(&prefix, fmt, ap);\n\tva_end(ap);\n\n\tRB_FOREACH(envent, environ, env) {\n\t\tif (envent->value != NULL && *envent->name != '\\0') {\n\t\t\tlog_debug(\"%s%s=%s\", prefix, envent->name,\n\t\t\t    envent->value);\n\t\t}\n\t}\n\n\tfree(prefix);\n}\n\n/* Create initial environment for new child. */\nstruct environ *\nenviron_for_session(struct session *s, int no_TERM)\n{\n\tstruct environ\t*env;\n\tconst char\t*value;\n\tint\t\t idx;\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tif (s != NULL)\n\t\tenviron_copy(s->environ, env);\n\n\tif (!no_TERM) {\n\t\tvalue = options_get_string(global_options, \"default-terminal\");\n\t\tenviron_set(env, \"TERM\", 0, \"%s\", value);\n\t\tenviron_set(env, \"TERM_PROGRAM\", 0, \"%s\", \"tmux\");\n\t\tenviron_set(env, \"TERM_PROGRAM_VERSION\", 0, \"%s\", getversion());\n\t}\n\n#ifdef HAVE_SYSTEMD\n\tenviron_clear(env, \"LISTEN_PID\");\n\tenviron_clear(env, \"LISTEN_FDS\");\n\tenviron_clear(env, \"LISTEN_FDNAMES\");\n#endif\n\n\tif (s != NULL)\n\t\tidx = s->id;\n\telse\n\t\tidx = -1;\n\tenviron_set(env, \"TMUX\", 0, \"%s,%ld,%d\", socket_path, (long)getpid(),\n\t    idx);\n\n\treturn (env);\n}\n"
        },
        {
          "name": "example_tmux.conf",
          "type": "blob",
          "size": 1.7763671875,
          "content": "#\n# Example .tmux.conf\n#\n# By Nicholas Marriott. Public domain.\n#\n\n# Some tweaks to the status line\nset -g status-right \"%H:%M\"\nset -g window-status-current-style \"underscore\"\n\n# If running inside tmux ($TMUX is set), then change the status line to red\n%if #{TMUX}\nset -g status-bg red\n%endif\n\n# Enable RGB colour if running in xterm(1)\nset-option -sa terminal-features \",xterm*:RGB\"\n\n# Change the default $TERM to tmux-256color\nset -g default-terminal \"tmux-256color\"\n\n# No bells at all\nset -g bell-action none\n\n# Keep windows around after they exit\nset -g remain-on-exit on\n\n# Change the prefix key to C-a\nset -g prefix C-a\nunbind C-b\nbind C-a send-prefix\n\n# Turn the mouse on, but without copy mode dragging\nset -g mouse on\nunbind -n MouseDrag1Pane\nunbind -Tcopy-mode MouseDrag1Pane\n\n# Some extra key bindings to select higher numbered windows\nbind F1 selectw -t:10\nbind F2 selectw -t:11\nbind F3 selectw -t:12\nbind F4 selectw -t:13\nbind F5 selectw -t:14\nbind F6 selectw -t:15\nbind F7 selectw -t:16\nbind F8 selectw -t:17\nbind F9 selectw -t:18\nbind F10 selectw -t:19\nbind F11 selectw -t:20\nbind F12 selectw -t:21\n\n# A key to toggle between smallest and largest sizes if a window is visible in\n# multiple places\nbind F set -w window-size\n\n# Keys to toggle monitoring activity in a window and the synchronize-panes option\nbind m set monitor-activity\nbind y set synchronize-panes\\; display 'synchronize-panes #{?synchronize-panes,on,off}'\n\n# Create a single default session - because a session is created here, tmux\n# should be started with \"tmux attach\" rather than \"tmux new\"\nnew -d -s0 -nirssi 'exec irssi'\nset -t0:0 monitor-activity on\nset -t0:0 aggressive-resize on\nneww -d -ntodo 'exec emacs ~/TODO'\nsetw -t0:1 aggressive-resize on\nneww -d -nmutt 'exec mutt'\nsetw -t0:2 aggressive-resize on\nneww -d\nneww -d\nneww -d\n"
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 19.6455078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * IPC file handling. Both client and server use the same data structures\n * (client_file and client_files) to store list of active files. Most functions\n * are for use either in client or server but not both.\n */\n\nstatic int\tfile_next_stream = 3;\n\nRB_GENERATE(client_files, client_file, entry, file_cmp);\n\n/* Get path for file, either as given or from working directory. */\nstatic char *\nfile_get_path(struct client *c, const char *file)\n{\n\tchar\t*path;\n\n\tif (*file == '/')\n\t\tpath = xstrdup(file);\n\telse\n\t\txasprintf(&path, \"%s/%s\", server_client_get_cwd(c, NULL), file);\n\treturn (path);\n}\n\n/* Tree comparison function. */\nint\nfile_cmp(struct client_file *cf1, struct client_file *cf2)\n{\n\tif (cf1->stream < cf2->stream)\n\t\treturn (-1);\n\tif (cf1->stream > cf2->stream)\n\t\treturn (1);\n\treturn (0);\n}\n\n/*\n * Create a file object in the client process - the peer is the server to send\n * messages to. Check callback is fired when the file is finished with so the\n * process can decide if it needs to exit (if it is waiting for files to\n * flush).\n */\nstruct client_file *\nfile_create_with_peer(struct tmuxpeer *peer, struct client_files *files,\n    int stream, client_file_cb cb, void *cbdata)\n{\n\tstruct client_file\t*cf;\n\n\tcf = xcalloc(1, sizeof *cf);\n\tcf->c = NULL;\n\tcf->references = 1;\n\tcf->stream = stream;\n\n\tcf->buffer = evbuffer_new();\n\tif (cf->buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tcf->cb = cb;\n\tcf->data = cbdata;\n\n\tcf->peer = peer;\n\tcf->tree = files;\n\tRB_INSERT(client_files, files, cf);\n\n\treturn (cf);\n}\n\n/* Create a file object in the server, communicating with the given client. */\nstruct client_file *\nfile_create_with_client(struct client *c, int stream, client_file_cb cb,\n    void *cbdata)\n{\n\tstruct client_file\t*cf;\n\n\tif (c != NULL && (c->flags & CLIENT_ATTACHED))\n\t\tc = NULL;\n\n\tcf = xcalloc(1, sizeof *cf);\n\tcf->c = c;\n\tcf->references = 1;\n\tcf->stream = stream;\n\n\tcf->buffer = evbuffer_new();\n\tif (cf->buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tcf->cb = cb;\n\tcf->data = cbdata;\n\n\tif (cf->c != NULL) {\n\t\tcf->peer = cf->c->peer;\n\t\tcf->tree = &cf->c->files;\n\t\tRB_INSERT(client_files, &cf->c->files, cf);\n\t\tcf->c->references++;\n\t}\n\n\treturn (cf);\n}\n\n/* Free a file. */\nvoid\nfile_free(struct client_file *cf)\n{\n\tif (--cf->references != 0)\n\t\treturn;\n\n\tevbuffer_free(cf->buffer);\n\tfree(cf->path);\n\n\tif (cf->tree != NULL)\n\t\tRB_REMOVE(client_files, cf->tree, cf);\n\tif (cf->c != NULL)\n\t\tserver_client_unref(cf->c);\n\n\tfree(cf);\n}\n\n/* Event to fire the done callback. */\nstatic void\nfile_fire_done_cb(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\tstruct client\t\t*c = cf->c;\n\n\tif (cf->cb != NULL &&\n\t    (cf->closed || c == NULL || (~c->flags & CLIENT_DEAD)))\n\t\tcf->cb(c, cf->path, cf->error, 1, cf->buffer, cf->data);\n\tfile_free(cf);\n}\n\n/* Add an event to fire the done callback (used by the server). */\nvoid\nfile_fire_done(struct client_file *cf)\n{\n\tevent_once(-1, EV_TIMEOUT, file_fire_done_cb, cf, NULL);\n}\n\n/* Fire the read callback. */\nvoid\nfile_fire_read(struct client_file *cf)\n{\n\tif (cf->cb != NULL)\n\t\tcf->cb(cf->c, cf->path, cf->error, 0, cf->buffer, cf->data);\n}\n\n/* Can this file be printed to? */\nint\nfile_can_print(struct client *c)\n{\n\tif (c == NULL ||\n\t    (c->flags & CLIENT_ATTACHED) ||\n\t    (c->flags & CLIENT_CONTROL))\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Print a message to a file. */\nvoid\nfile_print(struct client *c, const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tfile_vprint(c, fmt, ap);\n\tva_end(ap);\n}\n\n/* Print a message to a file. */\nvoid\nfile_vprint(struct client *c, const char *fmt, va_list ap)\n{\n\tstruct client_file\t find, *cf;\n\tstruct msg_write_open\t msg;\n\n\tif (!file_can_print(c))\n\t\treturn;\n\n\tfind.stream = 1;\n\tif ((cf = RB_FIND(client_files, &c->files, &find)) == NULL) {\n\t\tcf = file_create_with_client(c, 1, NULL, NULL);\n\t\tcf->path = xstrdup(\"-\");\n\n\t\tevbuffer_add_vprintf(cf->buffer, fmt, ap);\n\n\t\tmsg.stream = 1;\n\t\tmsg.fd = STDOUT_FILENO;\n\t\tmsg.flags = 0;\n\t\tproc_send(c->peer, MSG_WRITE_OPEN, -1, &msg, sizeof msg);\n\t} else {\n\t\tevbuffer_add_vprintf(cf->buffer, fmt, ap);\n\t\tfile_push(cf);\n\t}\n}\n\n/* Print a buffer to a file. */\nvoid\nfile_print_buffer(struct client *c, void *data, size_t size)\n{\n\tstruct client_file\t find, *cf;\n\tstruct msg_write_open\t msg;\n\n\tif (!file_can_print(c))\n\t\treturn;\n\n\tfind.stream = 1;\n\tif ((cf = RB_FIND(client_files, &c->files, &find)) == NULL) {\n\t\tcf = file_create_with_client(c, 1, NULL, NULL);\n\t\tcf->path = xstrdup(\"-\");\n\n\t\tevbuffer_add(cf->buffer, data, size);\n\n\t\tmsg.stream = 1;\n\t\tmsg.fd = STDOUT_FILENO;\n\t\tmsg.flags = 0;\n\t\tproc_send(c->peer, MSG_WRITE_OPEN, -1, &msg, sizeof msg);\n\t} else {\n\t\tevbuffer_add(cf->buffer, data, size);\n\t\tfile_push(cf);\n\t}\n}\n\n/* Report an error to a file. */\nvoid\nfile_error(struct client *c, const char *fmt, ...)\n{\n\tstruct client_file\t find, *cf;\n\tstruct msg_write_open\t msg;\n\tva_list\t\t\t ap;\n\n\tif (!file_can_print(c))\n\t\treturn;\n\n\tva_start(ap, fmt);\n\n\tfind.stream = 2;\n\tif ((cf = RB_FIND(client_files, &c->files, &find)) == NULL) {\n\t\tcf = file_create_with_client(c, 2, NULL, NULL);\n\t\tcf->path = xstrdup(\"-\");\n\n\t\tevbuffer_add_vprintf(cf->buffer, fmt, ap);\n\n\t\tmsg.stream = 2;\n\t\tmsg.fd = STDERR_FILENO;\n\t\tmsg.flags = 0;\n\t\tproc_send(c->peer, MSG_WRITE_OPEN, -1, &msg, sizeof msg);\n\t} else {\n\t\tevbuffer_add_vprintf(cf->buffer, fmt, ap);\n\t\tfile_push(cf);\n\t}\n\n\tva_end(ap);\n}\n\n/* Write data to a file. */\nvoid\nfile_write(struct client *c, const char *path, int flags, const void *bdata,\n    size_t bsize, client_file_cb cb, void *cbdata)\n{\n\tstruct client_file\t*cf;\n\tstruct msg_write_open\t*msg;\n\tsize_t\t\t\t msglen;\n\tint\t\t\t fd = -1;\n\tu_int\t\t\t stream = file_next_stream++;\n\tFILE\t\t\t*f;\n\tconst char\t\t*mode;\n\n\tif (strcmp(path, \"-\") == 0) {\n\t\tcf = file_create_with_client(c, stream, cb, cbdata);\n\t\tcf->path = xstrdup(\"-\");\n\n\t\tfd = STDOUT_FILENO;\n\t\tif (c == NULL ||\n\t\t    (c->flags & CLIENT_ATTACHED) ||\n\t\t    (c->flags & CLIENT_CONTROL)) {\n\t\t\tcf->error = EBADF;\n\t\t\tgoto done;\n\t\t}\n\t\tgoto skip;\n\t}\n\n\tcf = file_create_with_client(c, stream, cb, cbdata);\n\tcf->path = file_get_path(c, path);\n\n\tif (c == NULL || c->flags & CLIENT_ATTACHED) {\n\t\tif (flags & O_APPEND)\n\t\t\tmode = \"ab\";\n\t\telse\n\t\t\tmode = \"wb\";\n\t\tf = fopen(cf->path, mode);\n\t\tif (f == NULL) {\n\t\t\tcf->error = errno;\n\t\t\tgoto done;\n\t\t}\n\t\tif (fwrite(bdata, 1, bsize, f) != bsize) {\n\t\t\tfclose(f);\n\t\t\tcf->error = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tfclose(f);\n\t\tgoto done;\n\t}\n\nskip:\n\tevbuffer_add(cf->buffer, bdata, bsize);\n\n\tmsglen = strlen(cf->path) + 1 + sizeof *msg;\n\tif (msglen > MAX_IMSGSIZE - IMSG_HEADER_SIZE) {\n\t\tcf->error = E2BIG;\n\t\tgoto done;\n\t}\n\tmsg = xmalloc(msglen);\n\tmsg->stream = cf->stream;\n\tmsg->fd = fd;\n\tmsg->flags = flags;\n\tmemcpy(msg + 1, cf->path, msglen - sizeof *msg);\n\tif (proc_send(cf->peer, MSG_WRITE_OPEN, -1, msg, msglen) != 0) {\n\t\tfree(msg);\n\t\tcf->error = EINVAL;\n\t\tgoto done;\n\t}\n\tfree(msg);\n\treturn;\n\ndone:\n\tfile_fire_done(cf);\n}\n\n/* Read a file. */\nstruct client_file *\nfile_read(struct client *c, const char *path, client_file_cb cb, void *cbdata)\n{\n\tstruct client_file\t*cf;\n\tstruct msg_read_open\t*msg;\n\tsize_t\t\t\t msglen;\n\tint\t\t\t fd = -1;\n\tu_int\t\t\t stream = file_next_stream++;\n\tFILE\t\t\t*f;\n\tsize_t\t\t\t size;\n\tchar\t\t\t buffer[BUFSIZ];\n\n\tif (strcmp(path, \"-\") == 0) {\n\t\tcf = file_create_with_client(c, stream, cb, cbdata);\n\t\tcf->path = xstrdup(\"-\");\n\n\t\tfd = STDIN_FILENO;\n\t\tif (c == NULL ||\n\t\t    (c->flags & CLIENT_ATTACHED) ||\n\t\t    (c->flags & CLIENT_CONTROL)) {\n\t\t\tcf->error = EBADF;\n\t\t\tgoto done;\n\t\t}\n\t\tgoto skip;\n\t}\n\n\tcf = file_create_with_client(c, stream, cb, cbdata);\n\tcf->path = file_get_path(c, path);\n\n\tif (c == NULL || c->flags & CLIENT_ATTACHED) {\n\t\tf = fopen(cf->path, \"rb\");\n\t\tif (f == NULL) {\n\t\t\tcf->error = errno;\n\t\t\tgoto done;\n\t\t}\n\t\tfor (;;) {\n\t\t\tsize = fread(buffer, 1, sizeof buffer, f);\n\t\t\tif (evbuffer_add(cf->buffer, buffer, size) != 0) {\n\t\t\t\tcf->error = ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (size != sizeof buffer)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ferror(f)) {\n\t\t\tcf->error = EIO;\n\t\t\tgoto done;\n\t\t}\n\t\tfclose(f);\n\t\tgoto done;\n\t}\n\nskip:\n\tmsglen = strlen(cf->path) + 1 + sizeof *msg;\n\tif (msglen > MAX_IMSGSIZE - IMSG_HEADER_SIZE) {\n\t\tcf->error = E2BIG;\n\t\tgoto done;\n\t}\n\tmsg = xmalloc(msglen);\n\tmsg->stream = cf->stream;\n\tmsg->fd = fd;\n\tmemcpy(msg + 1, cf->path, msglen - sizeof *msg);\n\tif (proc_send(cf->peer, MSG_READ_OPEN, -1, msg, msglen) != 0) {\n\t\tfree(msg);\n\t\tcf->error = EINVAL;\n\t\tgoto done;\n\t}\n\tfree(msg);\n\treturn cf;\n\ndone:\n\tfile_fire_done(cf);\n\treturn NULL;\n}\n\n/* Cancel a file read. */\nvoid\nfile_cancel(struct client_file *cf)\n{\n\tstruct msg_read_cancel\t msg;\n\n\tlog_debug(\"read cancel file %d\", cf->stream);\n\n\tif (cf->closed)\n\t\treturn;\n\tcf->closed = 1;\n\n\tmsg.stream = cf->stream;\n\tproc_send(cf->peer, MSG_READ_CANCEL, -1, &msg, sizeof msg);\n}\n\n/* Push event, fired if there is more writing to be done. */\nstatic void\nfile_push_cb(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\n\tif (cf->c == NULL || ~cf->c->flags & CLIENT_DEAD)\n\t\tfile_push(cf);\n\tfile_free(cf);\n}\n\n/* Push uwritten data to the client for a file, if it will accept it. */\nvoid\nfile_push(struct client_file *cf)\n{\n\tstruct msg_write_data\t*msg;\n\tsize_t\t\t\t msglen, sent, left;\n\tstruct msg_write_close\t close;\n\n\tmsg = xmalloc(sizeof *msg);\n\tleft = EVBUFFER_LENGTH(cf->buffer);\n\twhile (left != 0) {\n\t\tsent = left;\n\t\tif (sent > MAX_IMSGSIZE - IMSG_HEADER_SIZE - sizeof *msg)\n\t\t\tsent = MAX_IMSGSIZE - IMSG_HEADER_SIZE - sizeof *msg;\n\n\t\tmsglen = (sizeof *msg) + sent;\n\t\tmsg = xrealloc(msg, msglen);\n\t\tmsg->stream = cf->stream;\n\t\tmemcpy(msg + 1, EVBUFFER_DATA(cf->buffer), sent);\n\t\tif (proc_send(cf->peer, MSG_WRITE, -1, msg, msglen) != 0)\n\t\t\tbreak;\n\t\tevbuffer_drain(cf->buffer, sent);\n\n\t\tleft = EVBUFFER_LENGTH(cf->buffer);\n\t\tlog_debug(\"file %d sent %zu, left %zu\", cf->stream, sent, left);\n\t}\n\tif (left != 0) {\n\t\tcf->references++;\n\t\tevent_once(-1, EV_TIMEOUT, file_push_cb, cf, NULL);\n\t} else if (cf->stream > 2) {\n\t\tclose.stream = cf->stream;\n\t\tproc_send(cf->peer, MSG_WRITE_CLOSE, -1, &close, sizeof close);\n\t\tfile_fire_done(cf);\n\t}\n\tfree(msg);\n}\n\n/* Check if any files have data left to write. */\nint\nfile_write_left(struct client_files *files)\n{\n\tstruct client_file\t*cf;\n\tsize_t\t\t\t left;\n\tint\t\t\t waiting = 0;\n\n\tRB_FOREACH(cf, client_files, files) {\n\t\tif (cf->event == NULL)\n\t\t\tcontinue;\n\t\tleft = EVBUFFER_LENGTH(cf->event->output);\n\t\tif (left != 0) {\n\t\t\twaiting++;\n\t\t\tlog_debug(\"file %u %zu bytes left\", cf->stream, left);\n\t\t}\n\t}\n\treturn (waiting != 0);\n}\n\n/* Client file write error callback. */\nstatic void\nfile_write_error_callback(__unused struct bufferevent *bev, __unused short what,\n    void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\n\tlog_debug(\"write error file %d\", cf->stream);\n\n\tbufferevent_free(cf->event);\n\tcf->event = NULL;\n\n\tclose(cf->fd);\n\tcf->fd = -1;\n\n\tif (cf->cb != NULL)\n\t\tcf->cb(NULL, NULL, 0, -1, NULL, cf->data);\n}\n\n/* Client file write callback. */\nstatic void\nfile_write_callback(__unused struct bufferevent *bev, void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\n\tlog_debug(\"write check file %d\", cf->stream);\n\n\tif (cf->cb != NULL)\n\t\tcf->cb(NULL, NULL, 0, -1, NULL, cf->data);\n\n\tif (cf->closed && EVBUFFER_LENGTH(cf->event->output) == 0) {\n\t\tbufferevent_free(cf->event);\n\t\tclose(cf->fd);\n\t\tRB_REMOVE(client_files, cf->tree, cf);\n\t\tfile_free(cf);\n\t}\n}\n\n/* Handle a file write open message (client). */\nvoid\nfile_write_open(struct client_files *files, struct tmuxpeer *peer,\n    struct imsg *imsg, int allow_streams, int close_received,\n    client_file_cb cb, void *cbdata)\n{\n\tstruct msg_write_open\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tconst char\t\t*path;\n\tstruct msg_write_ready\t reply;\n\tstruct client_file\t find, *cf;\n\tconst int\t\t flags = O_NONBLOCK|O_WRONLY|O_CREAT;\n\tint\t\t\t error = 0;\n\n\tif (msglen < sizeof *msg)\n\t\tfatalx(\"bad MSG_WRITE_OPEN size\");\n\tif (msglen == sizeof *msg)\n\t\tpath = \"-\";\n\telse\n\t\tpath = (const char *)(msg + 1);\n\tlog_debug(\"open write file %d %s\", msg->stream, path);\n\n\tfind.stream = msg->stream;\n\tif (RB_FIND(client_files, files, &find) != NULL) {\n\t\terror = EBADF;\n\t\tgoto reply;\n\t}\n\tcf = file_create_with_peer(peer, files, msg->stream, cb, cbdata);\n\tif (cf->closed) {\n\t\terror = EBADF;\n\t\tgoto reply;\n\t}\n\n\tcf->fd = -1;\n\tif (msg->fd == -1)\n\t\tcf->fd = open(path, msg->flags|flags, 0644);\n\telse if (allow_streams) {\n\t\tif (msg->fd != STDOUT_FILENO && msg->fd != STDERR_FILENO)\n\t\t\terrno = EBADF;\n\t\telse {\n\t\t\tcf->fd = dup(msg->fd);\n\t\t\tif (close_received)\n\t\t\t\tclose(msg->fd); /* can only be used once */\n\t\t}\n\t} else\n\t      errno = EBADF;\n\tif (cf->fd == -1) {\n\t\terror = errno;\n\t\tgoto reply;\n\t}\n\n\tcf->event = bufferevent_new(cf->fd, NULL, file_write_callback,\n\t    file_write_error_callback, cf);\n\tif (cf->event == NULL)\n\t\tfatalx(\"out of memory\");\n\tbufferevent_enable(cf->event, EV_WRITE);\n\tgoto reply;\n\nreply:\n\treply.stream = msg->stream;\n\treply.error = error;\n\tproc_send(peer, MSG_WRITE_READY, -1, &reply, sizeof reply);\n}\n\n/* Handle a file write data message (client). */\nvoid\nfile_write_data(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_write_data\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\tsize_t\t\t\t size = msglen - sizeof *msg;\n\n\tif (msglen < sizeof *msg)\n\t\tfatalx(\"bad MSG_WRITE size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\tfatalx(\"unknown stream number\");\n\tlog_debug(\"write %zu to file %d\", size, cf->stream);\n\n\tif (cf->event != NULL)\n\t\tbufferevent_write(cf->event, msg + 1, size);\n}\n\n/* Handle a file write close message (client). */\nvoid\nfile_write_close(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_write_close\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\n\tif (msglen != sizeof *msg)\n\t\tfatalx(\"bad MSG_WRITE_CLOSE size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\tfatalx(\"unknown stream number\");\n\tlog_debug(\"close file %d\", cf->stream);\n\n\tif (cf->event == NULL || EVBUFFER_LENGTH(cf->event->output) == 0) {\n\t\tif (cf->event != NULL)\n\t\t\tbufferevent_free(cf->event);\n\t\tif (cf->fd != -1)\n\t\t\tclose(cf->fd);\n\t\tRB_REMOVE(client_files, files, cf);\n\t\tfile_free(cf);\n\t}\n}\n\n/* Client file read error callback. */\nstatic void\nfile_read_error_callback(__unused struct bufferevent *bev, __unused short what,\n    void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\tstruct msg_read_done\t msg;\n\n\tlog_debug(\"read error file %d\", cf->stream);\n\n\tmsg.stream = cf->stream;\n\tmsg.error = 0;\n\tproc_send(cf->peer, MSG_READ_DONE, -1, &msg, sizeof msg);\n\n\tbufferevent_free(cf->event);\n\tclose(cf->fd);\n\tRB_REMOVE(client_files, cf->tree, cf);\n\tfile_free(cf);\n}\n\n/* Client file read callback. */\nstatic void\nfile_read_callback(__unused struct bufferevent *bev, void *arg)\n{\n\tstruct client_file\t*cf = arg;\n\tvoid\t\t\t*bdata;\n\tsize_t\t\t\t bsize;\n\tstruct msg_read_data\t*msg;\n\tsize_t\t\t\t msglen;\n\n\tmsg = xmalloc(sizeof *msg);\n\tfor (;;) {\n\t\tbdata = EVBUFFER_DATA(cf->event->input);\n\t\tbsize = EVBUFFER_LENGTH(cf->event->input);\n\n\t\tif (bsize == 0)\n\t\t\tbreak;\n\t\tif (bsize > MAX_IMSGSIZE - IMSG_HEADER_SIZE - sizeof *msg)\n\t\t\tbsize = MAX_IMSGSIZE - IMSG_HEADER_SIZE - sizeof *msg;\n\t\tlog_debug(\"read %zu from file %d\", bsize, cf->stream);\n\n\t\tmsglen = (sizeof *msg) + bsize;\n\t\tmsg = xrealloc(msg, msglen);\n\t\tmsg->stream = cf->stream;\n\t\tmemcpy(msg + 1, bdata, bsize);\n\t\tproc_send(cf->peer, MSG_READ, -1, msg, msglen);\n\n\t\tevbuffer_drain(cf->event->input, bsize);\n\t}\n\tfree(msg);\n}\n\n/* Handle a file read open message (client). */\nvoid\nfile_read_open(struct client_files *files, struct tmuxpeer *peer,\n    struct imsg *imsg, int allow_streams, int close_received, client_file_cb cb,\n    void *cbdata)\n{\n\tstruct msg_read_open\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tconst char\t\t*path;\n\tstruct msg_read_done\t reply;\n\tstruct client_file\t find, *cf;\n\tconst int\t\t flags = O_NONBLOCK|O_RDONLY;\n\tint\t\t\t error;\n\n\tif (msglen < sizeof *msg)\n\t\tfatalx(\"bad MSG_READ_OPEN size\");\n\tif (msglen == sizeof *msg)\n\t\tpath = \"-\";\n\telse\n\t\tpath = (const char *)(msg + 1);\n\tlog_debug(\"open read file %d %s\", msg->stream, path);\n\n\tfind.stream = msg->stream;\n\tif (RB_FIND(client_files, files, &find) != NULL) {\n\t\terror = EBADF;\n\t\tgoto reply;\n\t}\n\tcf = file_create_with_peer(peer, files, msg->stream, cb, cbdata);\n\tif (cf->closed) {\n\t\terror = EBADF;\n\t\tgoto reply;\n\t}\n\n\tcf->fd = -1;\n\tif (msg->fd == -1)\n\t\tcf->fd = open(path, flags);\n\telse if (allow_streams) {\n\t\tif (msg->fd != STDIN_FILENO)\n\t\t\terrno = EBADF;\n\t\telse {\n\t\t\tcf->fd = dup(msg->fd);\n\t\t\tif (close_received)\n\t\t\t\tclose(msg->fd); /* can only be used once */\n\t\t}\n\t} else\n\t\terrno = EBADF;\n\tif (cf->fd == -1) {\n\t\terror = errno;\n\t\tgoto reply;\n\t}\n\n\tcf->event = bufferevent_new(cf->fd, file_read_callback, NULL,\n\t    file_read_error_callback, cf);\n\tif (cf->event == NULL)\n\t\tfatalx(\"out of memory\");\n\tbufferevent_enable(cf->event, EV_READ);\n\treturn;\n\nreply:\n\treply.stream = msg->stream;\n\treply.error = error;\n\tproc_send(peer, MSG_READ_DONE, -1, &reply, sizeof reply);\n}\n\n/* Handle a read cancel message (client). */\nvoid\nfile_read_cancel(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_read_cancel\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\n\tif (msglen != sizeof *msg)\n\t\tfatalx(\"bad MSG_READ_CANCEL size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\tfatalx(\"unknown stream number\");\n\tlog_debug(\"cancel file %d\", cf->stream);\n\n\tfile_read_error_callback(NULL, 0, cf);\n}\n\n/* Handle a write ready message (server). */\nvoid\nfile_write_ready(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_write_ready\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\n\tif (msglen != sizeof *msg)\n\t\tfatalx(\"bad MSG_WRITE_READY size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\treturn;\n\tif (msg->error != 0) {\n\t\tcf->error = msg->error;\n\t\tfile_fire_done(cf);\n\t} else\n\t\tfile_push(cf);\n}\n\n/* Handle read data message (server). */\nvoid\nfile_read_data(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_read_data\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\tvoid\t\t\t*bdata = msg + 1;\n\tsize_t\t\t\t bsize = msglen - sizeof *msg;\n\n\tif (msglen < sizeof *msg)\n\t\tfatalx(\"bad MSG_READ_DATA size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\treturn;\n\n\tlog_debug(\"file %d read %zu bytes\", cf->stream, bsize);\n\tif (cf->error == 0 && !cf->closed) {\n\t\tif (evbuffer_add(cf->buffer, bdata, bsize) != 0) {\n\t\t\tcf->error = ENOMEM;\n\t\t\tfile_fire_done(cf);\n\t\t} else\n\t\t\tfile_fire_read(cf);\n\t}\n}\n\n/* Handle a read done message (server). */\nvoid\nfile_read_done(struct client_files *files, struct imsg *imsg)\n{\n\tstruct msg_read_done\t*msg = imsg->data;\n\tsize_t\t\t\t msglen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\tstruct client_file\t find, *cf;\n\n\tif (msglen != sizeof *msg)\n\t\tfatalx(\"bad MSG_READ_DONE size\");\n\tfind.stream = msg->stream;\n\tif ((cf = RB_FIND(client_files, files, &find)) == NULL)\n\t\treturn;\n\n\tlog_debug(\"file %d read done\", cf->stream);\n\tcf->error = msg->error;\n\tfile_fire_done(cf);\n}\n"
        },
        {
          "name": "format-draw.c",
          "type": "blob",
          "size": 32.0185546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/* Format range. */\nstruct format_range {\n\tu_int\t\t\t\t index;\n\tstruct screen\t\t\t*s;\n\n\tu_int\t\t\t\t start;\n\tu_int\t\t\t\t end;\n\n\tenum style_range_type\t\t type;\n\tu_int\t\t\t\t argument;\n\tchar                             string[16];\n\n\tTAILQ_ENTRY(format_range)\t entry;\n};\nTAILQ_HEAD(format_ranges, format_range);\n\n/* Does this range match this style? */\nstatic int\nformat_is_type(struct format_range *fr, struct style *sy)\n{\n\tif (fr->type != sy->range_type)\n\t\treturn (0);\n\tswitch (fr->type) {\n\tcase STYLE_RANGE_NONE:\n\tcase STYLE_RANGE_LEFT:\n\tcase STYLE_RANGE_RIGHT:\n\t\treturn (1);\n\tcase STYLE_RANGE_PANE:\n\tcase STYLE_RANGE_WINDOW:\n\tcase STYLE_RANGE_SESSION:\n\t\treturn (fr->argument == sy->range_argument);\n\tcase STYLE_RANGE_USER:\n\t\treturn (strcmp(fr->string, sy->range_string) == 0);\n\t}\n\treturn (1);\n}\n\n/* Free a range. */\nstatic void\nformat_free_range(struct format_ranges *frs, struct format_range *fr)\n{\n\tTAILQ_REMOVE(frs, fr, entry);\n\tfree(fr);\n}\n\n/* Fix range positions. */\nstatic void\nformat_update_ranges(struct format_ranges *frs, struct screen *s, u_int offset,\n    u_int start, u_int width)\n{\n\tstruct format_range\t*fr, *fr1;\n\n\tif (frs == NULL)\n\t\treturn;\n\n\tTAILQ_FOREACH_SAFE(fr, frs, entry, fr1) {\n\t\tif (fr->s != s)\n\t\t\tcontinue;\n\n\t\tif (fr->end <= start || fr->start >= start + width) {\n\t\t\tformat_free_range(frs, fr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fr->start < start)\n\t\t\tfr->start = start;\n\t\tif (fr->end > start + width)\n\t\t\tfr->end = start + width;\n\t\tif (fr->start == fr->end) {\n\t\t\tformat_free_range(frs, fr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfr->start -= start;\n\t\tfr->end -= start;\n\n\t\tfr->start += offset;\n\t\tfr->end += offset;\n\t}\n}\n\n/* Draw a part of the format. */\nstatic void\nformat_draw_put(struct screen_write_ctx *octx, u_int ocx, u_int ocy,\n    struct screen *s, struct format_ranges *frs, u_int offset, u_int start,\n    u_int width)\n{\n\t/*\n\t * The offset is how far from the cursor on the target screen; start\n\t * and width how much to copy from the source screen.\n\t */\n\tscreen_write_cursormove(octx, ocx + offset, ocy, 0);\n\tscreen_write_fast_copy(octx, s, start, 0, width, 1);\n\tformat_update_ranges(frs, s, offset, start, width);\n}\n\n/* Draw list part of format. */\nstatic void\nformat_draw_put_list(struct screen_write_ctx *octx,\n    u_int ocx, u_int ocy, u_int offset, u_int width, struct screen *list,\n    struct screen *list_left, struct screen *list_right, int focus_start,\n    int focus_end, struct format_ranges *frs)\n{\n\tu_int\tstart, focus_centre;\n\n\t/* If there is enough space for the list, draw it entirely. */\n\tif (width >= list->cx) {\n\t\tformat_draw_put(octx, ocx, ocy, list, frs, offset, 0, width);\n\t\treturn;\n\t}\n\n\t/* The list needs to be trimmed. Try to keep the focus visible. */\n\tfocus_centre = focus_start + (focus_end - focus_start) / 2;\n\tif (focus_centre < width / 2)\n\t\tstart = 0;\n\telse\n\t\tstart = focus_centre - width / 2;\n\tif (start + width > list->cx)\n\t\tstart = list->cx - width;\n\n\t/* Draw <> markers at either side if needed. */\n\tif (start != 0 && width > list_left->cx) {\n\t\tscreen_write_cursormove(octx, ocx + offset, ocy, 0);\n\t\tscreen_write_fast_copy(octx, list_left, 0, 0, list_left->cx, 1);\n\t\toffset += list_left->cx;\n\t\tstart += list_left->cx;\n\t\twidth -= list_left->cx;\n\t}\n\tif (start + width < list->cx && width > list_right->cx) {\n\t\tscreen_write_cursormove(octx, ocx + offset + width -\n\t\t    list_right->cx, ocy, 0);\n\t\tscreen_write_fast_copy(octx, list_right, 0, 0, list_right->cx,\n\t\t    1);\n\t\twidth -= list_right->cx;\n\t}\n\n\t/* Draw the list screen itself. */\n\tformat_draw_put(octx, ocx, ocy, list, frs, offset, start, width);\n}\n\n/* Draw format with no list. */\nstatic void\nformat_draw_none(struct screen_write_ctx *octx, u_int available, u_int ocx,\n    u_int ocy, struct screen *left, struct screen *centre, struct screen *right,\n    struct screen *abs_centre, struct format_ranges *frs)\n{\n\tu_int\twidth_left, width_centre, width_right, width_abs_centre;\n\n\twidth_left = left->cx;\n\twidth_centre = centre->cx;\n\twidth_right = right->cx;\n\twidth_abs_centre = abs_centre->cx;\n\n\t/*\n\t * Try to keep as much of the left and right as possible at the expense\n\t * of the centre.\n\t */\n\twhile (width_left + width_centre + width_right > available) {\n\t\tif (width_centre > 0)\n\t\t\twidth_centre--;\n\t\telse if (width_right > 0)\n\t\t\twidth_right--;\n\t\telse\n\t\t\twidth_left--;\n\t}\n\n\t/* Write left. */\n\tformat_draw_put(octx, ocx, ocy, left, frs, 0, 0, width_left);\n\n\t/* Write right at available - width_right. */\n\tformat_draw_put(octx, ocx, ocy, right, frs,\n\t    available - width_right,\n\t    right->cx - width_right,\n\t    width_right);\n\n\t/*\n\t * Write centre halfway between\n\t *     width_left\n\t * and\n\t *     available - width_right.\n\t */\n\tformat_draw_put(octx, ocx, ocy, centre, frs,\n\t    width_left\n\t    + ((available - width_right) - width_left) / 2\n\t    - width_centre / 2,\n\t    centre->cx / 2 - width_centre / 2,\n\t    width_centre);\n\n\t/*\n\t * Write abs_centre in the perfect centre of all horizontal space.\n\t */\n\tif (width_abs_centre > available)\n\t\twidth_abs_centre = available;\n\tformat_draw_put(octx, ocx, ocy, abs_centre, frs,\n\t    (available - width_abs_centre) / 2,\n\t    0,\n\t    width_abs_centre);\n}\n\n/* Draw format with list on the left. */\nstatic void\nformat_draw_left(struct screen_write_ctx *octx, u_int available, u_int ocx,\n    u_int ocy, struct screen *left, struct screen *centre, struct screen *right,\n    struct screen *abs_centre, struct screen *list, struct screen *list_left,\n    struct screen *list_right, struct screen *after, int focus_start,\n    int focus_end, struct format_ranges *frs)\n{\n\tu_int\t\t\twidth_left, width_centre, width_right;\n\tu_int\t\t\twidth_list, width_after, width_abs_centre;\n\tstruct screen_write_ctx\tctx;\n\n\twidth_left = left->cx;\n\twidth_centre = centre->cx;\n\twidth_right = right->cx;\n\twidth_abs_centre = abs_centre->cx;\n\twidth_list = list->cx;\n\twidth_after = after->cx;\n\n\t/*\n\t * Trim first the centre, then the list, then the right, then after the\n\t * list, then the left.\n\t */\n\twhile (width_left +\n\t    width_centre +\n\t    width_right +\n\t    width_list +\n\t    width_after > available) {\n\t\tif (width_centre > 0)\n\t\t\twidth_centre--;\n\t\telse if (width_list > 0)\n\t\t\twidth_list--;\n\t\telse if (width_right > 0)\n\t\t\twidth_right--;\n\t\telse if (width_after > 0)\n\t\t\twidth_after--;\n\t\telse\n\t\t\twidth_left--;\n\t}\n\n\t/* If there is no list left, pass off to the no list function. */\n\tif (width_list == 0) {\n\t\tscreen_write_start(&ctx, left);\n\t\tscreen_write_fast_copy(&ctx, after, 0, 0, width_after, 1);\n\t\tscreen_write_stop(&ctx);\n\n\t\tformat_draw_none(octx, available, ocx, ocy, left, centre,\n\t\t    right, abs_centre, frs);\n\t\treturn;\n\t}\n\n\t/* Write left at 0. */\n\tformat_draw_put(octx, ocx, ocy, left, frs, 0, 0, width_left);\n\n\t/* Write right at available - width_right. */\n\tformat_draw_put(octx, ocx, ocy, right, frs,\n\t    available - width_right,\n\t    right->cx - width_right,\n\t    width_right);\n\n\t/* Write after at width_left + width_list. */\n\tformat_draw_put(octx, ocx, ocy, after, frs,\n\t    width_left + width_list,\n\t    0,\n\t    width_after);\n\n\t/*\n\t * Write centre halfway between\n\t *     width_left + width_list + width_after\n\t * and\n\t *     available - width_right.\n\t */\n\tformat_draw_put(octx, ocx, ocy, centre, frs,\n\t    (width_left + width_list + width_after)\n\t    + ((available - width_right)\n\t\t- (width_left + width_list + width_after)) / 2\n\t    - width_centre / 2,\n\t    centre->cx / 2 - width_centre / 2,\n\t    width_centre);\n\n\t/*\n\t * The list now goes from\n\t *     width_left\n\t * to\n\t *     width_left + width_list.\n\t * If there is no focus given, keep the left in focus.\n\t */\n\tif (focus_start == -1 || focus_end == -1)\n\t\tfocus_start = focus_end = 0;\n\tformat_draw_put_list(octx, ocx, ocy, width_left, width_list, list,\n\t    list_left, list_right, focus_start, focus_end, frs);\n\n\t/*\n\t * Write abs_centre in the perfect centre of all horizontal space.\n\t */\n\tif (width_abs_centre > available)\n\t\twidth_abs_centre = available;\n\tformat_draw_put(octx, ocx, ocy, abs_centre, frs,\n\t    (available - width_abs_centre) / 2,\n\t    0,\n\t    width_abs_centre);\n}\n\n/* Draw format with list in the centre. */\nstatic void\nformat_draw_centre(struct screen_write_ctx *octx, u_int available, u_int ocx,\n    u_int ocy, struct screen *left, struct screen *centre, struct screen *right,\n    struct screen *abs_centre, struct screen *list, struct screen *list_left,\n    struct screen *list_right, struct screen *after, int focus_start,\n    int focus_end, struct format_ranges *frs)\n{\n\tu_int\t\t\twidth_left, width_centre, width_right, middle;\n\tu_int\t\t\twidth_list, width_after, width_abs_centre;\n\tstruct screen_write_ctx\tctx;\n\n\twidth_left = left->cx;\n\twidth_centre = centre->cx;\n\twidth_right = right->cx;\n\twidth_abs_centre = abs_centre->cx;\n\twidth_list = list->cx;\n\twidth_after = after->cx;\n\n\t/*\n\t * Trim first the list, then after the list, then the centre, then the\n\t * right, then the left.\n\t */\n\twhile (width_left +\n\t    width_centre +\n\t    width_right +\n\t    width_list +\n\t    width_after > available) {\n\t\tif (width_list > 0)\n\t\t\twidth_list--;\n\t\telse if (width_after > 0)\n\t\t\twidth_after--;\n\t\telse if (width_centre > 0)\n\t\t\twidth_centre--;\n\t\telse if (width_right > 0)\n\t\t\twidth_right--;\n\t\telse\n\t\t\twidth_left--;\n\t}\n\n\t/* If there is no list left, pass off to the no list function. */\n\tif (width_list == 0) {\n\t\tscreen_write_start(&ctx, centre);\n\t\tscreen_write_fast_copy(&ctx, after, 0, 0, width_after, 1);\n\t\tscreen_write_stop(&ctx);\n\n\t\tformat_draw_none(octx, available, ocx, ocy, left, centre,\n\t\t    right, abs_centre, frs);\n\t\treturn;\n\t}\n\n\t/* Write left at 0. */\n\tformat_draw_put(octx, ocx, ocy, left, frs, 0, 0, width_left);\n\n\t/* Write right at available - width_right. */\n\tformat_draw_put(octx, ocx, ocy, right, frs,\n\t    available - width_right,\n\t    right->cx - width_right,\n\t    width_right);\n\n\t/*\n\t * All three centre sections are offset from the middle of the\n\t * available space.\n\t */\n\tmiddle = (width_left + ((available - width_right) - width_left) / 2);\n\n\t/*\n\t * Write centre at\n\t *     middle - width_list / 2 - width_centre.\n\t */\n\tformat_draw_put(octx, ocx, ocy, centre, frs,\n\t    middle - width_list / 2 - width_centre,\n\t    0,\n\t    width_centre);\n\n\t/*\n\t * Write after at\n\t *     middle - width_list / 2 + width_list\n\t */\n\tformat_draw_put(octx, ocx, ocy, after, frs,\n\t    middle - width_list / 2 + width_list,\n\t    0,\n\t    width_after);\n\n\t/*\n\t * The list now goes from\n\t *     middle - width_list / 2\n\t * to\n\t *     middle + width_list / 2\n\t * If there is no focus given, keep the centre in focus.\n\t */\n\tif (focus_start == -1 || focus_end == -1)\n\t\tfocus_start = focus_end = list->cx / 2;\n\tformat_draw_put_list(octx, ocx, ocy, middle - width_list / 2,\n\t    width_list, list, list_left, list_right, focus_start, focus_end,\n\t    frs);\n\n\t/*\n\t * Write abs_centre in the perfect centre of all horizontal space.\n\t */\n\tif (width_abs_centre > available)\n\t\twidth_abs_centre = available;\n\tformat_draw_put(octx, ocx, ocy, abs_centre, frs,\n\t    (available - width_abs_centre) / 2,\n\t    0,\n\t    width_abs_centre);\n}\n\n/* Draw format with list on the right. */\nstatic void\nformat_draw_right(struct screen_write_ctx *octx, u_int available, u_int ocx,\n    u_int ocy, struct screen *left, struct screen *centre, struct screen *right,\n    struct screen *abs_centre,     struct screen *list,\n    struct screen *list_left, struct screen *list_right, struct screen *after,\n    int focus_start, int focus_end, struct format_ranges *frs)\n{\n\tu_int\t\t\twidth_left, width_centre, width_right;\n\tu_int\t\t\twidth_list, width_after, width_abs_centre;\n\tstruct screen_write_ctx\tctx;\n\n\twidth_left = left->cx;\n\twidth_centre = centre->cx;\n\twidth_right = right->cx;\n\twidth_abs_centre = abs_centre->cx;\n\twidth_list = list->cx;\n\twidth_after = after->cx;\n\n\t/*\n\t * Trim first the centre, then the list, then the right, then\n\t * after the list, then the left.\n\t */\n\twhile (width_left +\n\t    width_centre +\n\t    width_right +\n\t    width_list +\n\t    width_after > available) {\n\t\tif (width_centre > 0)\n\t\t\twidth_centre--;\n\t\telse if (width_list > 0)\n\t\t\twidth_list--;\n\t\telse if (width_right > 0)\n\t\t\twidth_right--;\n\t\telse if (width_after > 0)\n\t\t\twidth_after--;\n\t\telse\n\t\t\twidth_left--;\n\t}\n\n\t/* If there is no list left, pass off to the no list function. */\n\tif (width_list == 0) {\n\t\tscreen_write_start(&ctx, right);\n\t\tscreen_write_fast_copy(&ctx, after, 0, 0, width_after, 1);\n\t\tscreen_write_stop(&ctx);\n\n\t\tformat_draw_none(octx, available, ocx, ocy, left, centre,\n\t\t    right, abs_centre, frs);\n\t\treturn;\n\t}\n\n\t/* Write left at 0. */\n\tformat_draw_put(octx, ocx, ocy, left, frs, 0, 0, width_left);\n\n\t/* Write after at available - width_after. */\n\tformat_draw_put(octx, ocx, ocy, after, frs,\n\t    available - width_after,\n\t    after->cx - width_after,\n\t    width_after);\n\n\t/*\n\t * Write right at\n\t *     available - width_right - width_list - width_after.\n\t */\n\tformat_draw_put(octx, ocx, ocy, right, frs,\n\t    available - width_right - width_list - width_after,\n\t    0,\n\t    width_right);\n\n\t/*\n\t * Write centre halfway between\n\t *     width_left\n\t * and\n\t *     available - width_right - width_list - width_after.\n\t */\n\tformat_draw_put(octx, ocx, ocy, centre, frs,\n\t    width_left\n\t    + ((available - width_right - width_list - width_after)\n\t\t- width_left) / 2\n\t    - width_centre / 2,\n\t    centre->cx / 2 - width_centre / 2,\n\t    width_centre);\n\n\t/*\n\t * The list now goes from\n\t *     available - width_list - width_after\n\t * to\n\t *     available - width_after\n\t * If there is no focus given, keep the right in focus.\n\t */\n\tif (focus_start == -1 || focus_end == -1)\n\t\tfocus_start = focus_end = 0;\n\tformat_draw_put_list(octx, ocx, ocy, available - width_list -\n\t    width_after, width_list, list, list_left, list_right, focus_start,\n\t    focus_end, frs);\n\n\t/*\n\t * Write abs_centre in the perfect centre of all horizontal space.\n\t */\n\tif (width_abs_centre > available)\n\t\twidth_abs_centre = available;\n\tformat_draw_put(octx, ocx, ocy, abs_centre, frs,\n\t    (available - width_abs_centre) / 2,\n\t    0,\n\t    width_abs_centre);\n}\n\nstatic void\nformat_draw_absolute_centre(struct screen_write_ctx *octx, u_int available,\n    u_int ocx, u_int ocy, struct screen *left, struct screen *centre,\n    struct screen *right, struct screen *abs_centre, struct screen *list,\n    struct screen *list_left, struct screen *list_right, struct screen *after,\n    int focus_start, int focus_end, struct format_ranges *frs)\n{\n\tu_int\twidth_left, width_centre, width_right, width_abs_centre;\n\tu_int\twidth_list, width_after, middle, abs_centre_offset;\n\n\twidth_left = left->cx;\n\twidth_centre = centre->cx;\n\twidth_right = right->cx;\n\twidth_abs_centre = abs_centre->cx;\n\twidth_list = list->cx;\n\twidth_after = after->cx;\n\n\t/*\n\t * Trim first centre, then the right, then the left.\n\t */\n\twhile (width_left +\n\t    width_centre +\n\t    width_right > available) {\n\t\tif (width_centre > 0)\n\t\t\twidth_centre--;\n\t\telse if (width_right > 0)\n\t\t\twidth_right--;\n\t\telse\n\t\t\twidth_left--;\n\t}\n\n\t/*\n\t * We trim list after and abs_centre independently, as we are drawing\n\t * them over the rest. Trim first the list, then after the list, then\n\t * abs_centre.\n\t */\n\twhile (width_list + width_after + width_abs_centre > available) {\n\t\tif (width_list > 0)\n\t\t\twidth_list--;\n\t\telse if (width_after > 0)\n\t\t\twidth_after--;\n\t\telse\n\t\t\twidth_abs_centre--;\n\t}\n\n\t/* Write left at 0. */\n\tformat_draw_put(octx, ocx, ocy, left, frs, 0, 0, width_left);\n\n\t/* Write right at available - width_right. */\n\tformat_draw_put(octx, ocx, ocy, right, frs,\n\t    available - width_right,\n\t    right->cx - width_right,\n\t    width_right);\n\n\t/*\n\t * Keep writing centre at the relative centre. Only the list is written\n\t * in the absolute centre of the horizontal space.\n\t */\n\tmiddle = (width_left + ((available - width_right) - width_left) / 2);\n\n\t/*\n\t * Write centre at\n\t *     middle - width_centre.\n\t */\n\tformat_draw_put(octx, ocx, ocy, centre, frs,\n\t\tmiddle - width_centre,\n\t\t0,\n\t\twidth_centre);\n\n\t/*\n\t * If there is no focus given, keep the centre in focus.\n\t */\n\tif (focus_start == -1 || focus_end == -1)\n\t\tfocus_start = focus_end = list->cx / 2;\n\n\t/*\n\t * We centre abs_centre and the list together, so their shared centre is\n\t * in the perfect centre of horizontal space.\n\t */\n\tabs_centre_offset = (available - width_list - width_abs_centre) / 2;\n\n\t/*\n\t * Write abs_centre before the list.\n\t */\n\tformat_draw_put(octx, ocx, ocy, abs_centre, frs, abs_centre_offset,\n\t    0, width_abs_centre);\n\tabs_centre_offset += width_abs_centre;\n\n\t/*\n\t * Draw the list in the absolute centre\n\t */\n\tformat_draw_put_list(octx, ocx, ocy, abs_centre_offset, width_list,\n\t    list, list_left, list_right, focus_start, focus_end, frs);\n\tabs_centre_offset += width_list;\n\n\t/*\n\t * Write after at the end of the centre\n\t */\n\tformat_draw_put(octx, ocx, ocy, after, frs, abs_centre_offset, 0,\n\t    width_after);\n}\n\n/* Get width and count of any leading #s. */\nstatic const char *\nformat_leading_hashes(const char *cp, u_int *n, u_int *width)\n{\n\tfor (*n = 0; cp[*n] == '#'; (*n)++)\n\t\t/* nothing */;\n\tif (*n == 0) {\n\t\t*width = 0;\n\t\treturn (cp);\n\t}\n\tif (cp[*n] != '[') {\n\t\tif ((*n % 2) == 0)\n\t\t\t*width = (*n / 2);\n\t\telse\n\t\t\t*width = (*n / 2) + 1;\n\t\treturn (cp + *n);\n\t}\n\t*width = (*n / 2);\n\tif ((*n % 2) == 0) {\n\t\t/*\n\t\t * An even number of #s means that all #s are escaped, so not a\n\t\t * style. The caller should not skip this. Return pointing to\n\t\t * the [.\n\t\t */\n\t\treturn (cp + *n);\n\t}\n\t/* This is a style, so return pointing to the #. */\n\treturn (cp + *n - 1);\n}\n\n/* Draw multiple characters. */\nstatic void\nformat_draw_many(struct screen_write_ctx *ctx, struct style *sy, char ch,\n    u_int n)\n{\n\tu_int\ti;\n\n\tutf8_set(&sy->gc.data, ch);\n\tfor (i = 0; i < n; i++)\n\t\tscreen_write_cell(ctx, &sy->gc);\n}\n\n/* Draw a format to a screen. */\nvoid\nformat_draw(struct screen_write_ctx *octx, const struct grid_cell *base,\n    u_int available, const char *expanded, struct style_ranges *srs,\n    int default_colours)\n{\n\tenum { LEFT,\n\t       CENTRE,\n\t       RIGHT,\n\t       ABSOLUTE_CENTRE,\n\t       LIST,\n\t       LIST_LEFT,\n\t       LIST_RIGHT,\n\t       AFTER,\n\t       TOTAL } current = LEFT, last = LEFT;\n\tconst char\t        *names[] = { \"LEFT\",\n\t\t\t\t\t     \"CENTRE\",\n\t\t\t\t\t     \"RIGHT\",\n\t\t\t\t\t     \"ABSOLUTE_CENTRE\",\n\t\t\t\t\t     \"LIST\",\n\t\t\t\t\t     \"LIST_LEFT\",\n\t\t\t\t\t     \"LIST_RIGHT\",\n\t\t\t\t\t     \"AFTER\" };\n\tsize_t\t\t\t size = strlen(expanded);\n\tstruct screen\t\t*os = octx->s, s[TOTAL];\n\tstruct screen_write_ctx\t ctx[TOTAL];\n\tu_int\t\t\t ocx = os->cx, ocy = os->cy, n, i, width[TOTAL];\n\tu_int\t\t\t map[] = { LEFT,\n\t\t\t\t\t   LEFT,\n\t\t\t\t\t   CENTRE,\n\t\t\t\t\t   RIGHT,\n\t\t\t\t\t   ABSOLUTE_CENTRE };\n\tint\t\t\t focus_start = -1, focus_end = -1;\n\tint\t\t\t list_state = -1, fill = -1, even;\n\tenum style_align\t list_align = STYLE_ALIGN_DEFAULT;\n\tstruct grid_cell\t gc, current_default;\n\tstruct style\t\t sy, saved_sy;\n\tstruct utf8_data\t*ud = &sy.gc.data;\n\tconst char\t\t*cp, *end;\n\tenum utf8_state\t\t more;\n\tchar\t\t\t*tmp;\n\tstruct format_range\t*fr = NULL, *fr1;\n\tstruct format_ranges\t frs;\n\tstruct style_range\t*sr;\n\n\tmemcpy(&current_default, base, sizeof current_default);\n\tstyle_set(&sy, &current_default);\n\tTAILQ_INIT(&frs);\n\tlog_debug(\"%s: %s\", __func__, expanded);\n\n\t/*\n\t * We build three screens for left, right, centre alignment, one for\n\t * the list, one for anything after the list and two for the list left\n\t * and right markers.\n\t */\n\tfor (i = 0; i < TOTAL; i++) {\n\t\tscreen_init(&s[i], size, 1, 0);\n\t\tscreen_write_start(&ctx[i], &s[i]);\n\t\tscreen_write_clearendofline(&ctx[i], current_default.bg);\n\t\twidth[i] = 0;\n\t}\n\n\t/*\n\t * Walk the string and add to the corresponding screens,\n\t * parsing styles as we go.\n\t */\n\tcp = expanded;\n\twhile (*cp != '\\0') {\n\t\t/* Handle sequences of #. */\n\t\tif (cp[0] == '#' && cp[1] != '[' && cp[1] != '\\0') {\n\t\t\tfor (n = 1; cp[n] == '#'; n++)\n\t\t\t\t /* nothing */;\n\t\t\teven = ((n % 2) == 0);\n\t\t\tif (cp[n] != '[') {\n\t\t\t\tcp += n;\n\t\t\t\tif (even)\n\t\t\t\t\tn = (n / 2);\n\t\t\t\telse\n\t\t\t\t\tn = (n / 2) + 1;\n\t\t\t\twidth[current] += n;\n\t\t\t\tformat_draw_many(&ctx[current], &sy, '#', n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (even)\n\t\t\t\tcp += (n + 1);\n\t\t\telse\n\t\t\t\tcp += (n - 1);\n\t\t\tif (sy.ignore)\n\t\t\t\tcontinue;\n\t\t\tformat_draw_many(&ctx[current], &sy, '#', n / 2);\n\t\t\twidth[current] += (n / 2);\n\t\t\tif (even) {\n\t\t\t\tutf8_set(ud, '[');\n\t\t\t\tscreen_write_cell(&ctx[current], &sy.gc);\n\t\t\t\twidth[current]++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Is this not a style? */\n\t\tif (cp[0] != '#' || cp[1] != '[' || sy.ignore) {\n\t\t\t/* See if this is a UTF-8 character. */\n\t\t\tif ((more = utf8_open(ud, *cp)) == UTF8_MORE) {\n\t\t\t\twhile (*++cp != '\\0' && more == UTF8_MORE)\n\t\t\t\t\tmore = utf8_append(ud, *cp);\n\t\t\t\tif (more != UTF8_DONE)\n\t\t\t\t\tcp -= ud->have;\n\t\t\t}\n\n\t\t\t/* Not a UTF-8 character - ASCII or not valid. */\n\t\t\tif (more != UTF8_DONE) {\n\t\t\t\tif (*cp < 0x20 || *cp > 0x7e) {\n\t\t\t\t\t/* Ignore nonprintable characters. */\n\t\t\t\t\tcp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tutf8_set(ud, *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\n\t\t\t/* Draw the cell to the current screen. */\n\t\t\tscreen_write_cell(&ctx[current], &sy.gc);\n\t\t\twidth[current] += ud->width;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* This is a style. Work out where the end is and parse it. */\n\t\tend = format_skip(cp + 2, \"]\");\n\t\tif (end == NULL) {\n\t\t\tlog_debug(\"%s: no terminating ] at '%s'\", __func__,\n\t\t\t    cp + 2);\n\t\t\tTAILQ_FOREACH_SAFE(fr, &frs, entry, fr1)\n\t\t\t    format_free_range(&frs, fr);\n\t\t\tgoto out;\n\t\t}\n\t\ttmp = xstrndup(cp + 2, end - (cp + 2));\n\t\tstyle_copy(&saved_sy, &sy);\n\t\tif (style_parse(&sy, &current_default, tmp) != 0) {\n\t\t\tlog_debug(\"%s: invalid style '%s'\", __func__, tmp);\n\t\t\tfree(tmp);\n\t\t\tcp = end + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_debug(\"%s: style '%s' -> '%s'\", __func__, tmp,\n\t\t    style_tostring(&sy));\n\t\tfree(tmp);\n\t\tif (default_colours) {\n\t\t\tsy.gc.bg = base->bg;\n\t\t\tsy.gc.fg = base->fg;\n\t\t}\n\n\t\t/* If this style has a fill colour, store it for later. */\n\t\tif (sy.fill != 8)\n\t\t\tfill = sy.fill;\n\n\t\t/* If this style pushed or popped the default, update it. */\n\t\tif (sy.default_type == STYLE_DEFAULT_PUSH) {\n\t\t\tmemcpy(&current_default, &saved_sy.gc,\n\t\t\t    sizeof current_default);\n\t\t\tsy.default_type = STYLE_DEFAULT_BASE;\n\t\t} else if (sy.default_type == STYLE_DEFAULT_POP) {\n\t\t\tmemcpy(&current_default, base, sizeof current_default);\n\t\t\tsy.default_type = STYLE_DEFAULT_BASE;\n\t\t}\n\n\t\t/* Check the list state. */\n\t\tswitch (sy.list) {\n\t\tcase STYLE_LIST_ON:\n\t\t\t/*\n\t\t\t * Entering the list, exiting a marker, or exiting the\n\t\t\t * focus.\n\t\t\t */\n\t\t\tif (list_state != 0) {\n\t\t\t\tif (fr != NULL) { /* abort any region */\n\t\t\t\t\tfree(fr);\n\t\t\t\t\tfr = NULL;\n\t\t\t\t}\n\t\t\t\tlist_state = 0;\n\t\t\t\tlist_align = sy.align;\n\t\t\t}\n\n\t\t\t/* End the focus if started. */\n\t\t\tif (focus_start != -1 && focus_end == -1)\n\t\t\t\tfocus_end = s[LIST].cx;\n\n\t\t\tcurrent = LIST;\n\t\t\tbreak;\n\t\tcase STYLE_LIST_FOCUS:\n\t\t\t/* Entering the focus. */\n\t\t\tif (list_state != 0) /* not inside the list */\n\t\t\t\tbreak;\n\t\t\tif (focus_start == -1) /* focus already started */\n\t\t\t\tfocus_start = s[LIST].cx;\n\t\t\tbreak;\n\t\tcase STYLE_LIST_OFF:\n\t\t\t/* Exiting or outside the list. */\n\t\t\tif (list_state == 0) {\n\t\t\t\tif (fr != NULL) { /* abort any region */\n\t\t\t\t\tfree(fr);\n\t\t\t\t\tfr = NULL;\n\t\t\t\t}\n\t\t\t\tif (focus_start != -1 && focus_end == -1)\n\t\t\t\t\tfocus_end = s[LIST].cx;\n\n\t\t\t\tmap[list_align] = AFTER;\n\t\t\t\tif (list_align == STYLE_ALIGN_LEFT)\n\t\t\t\t\tmap[STYLE_ALIGN_DEFAULT] = AFTER;\n\t\t\t\tlist_state = 1;\n\t\t\t}\n\t\t\tcurrent = map[sy.align];\n\t\t\tbreak;\n\t\tcase STYLE_LIST_LEFT_MARKER:\n\t\t\t/* Entering left marker. */\n\t\t\tif (list_state != 0) /* not inside the list */\n\t\t\t\tbreak;\n\t\t\tif (s[LIST_LEFT].cx != 0) /* already have marker */\n\t\t\t\tbreak;\n\t\t\tif (fr != NULL) { /* abort any region */\n\t\t\t\tfree(fr);\n\t\t\t\tfr = NULL;\n\t\t\t}\n\t\t\tif (focus_start != -1 && focus_end == -1)\n\t\t\t\tfocus_start = focus_end = -1;\n\t\t\tcurrent = LIST_LEFT;\n\t\t\tbreak;\n\t\tcase STYLE_LIST_RIGHT_MARKER:\n\t\t\t/* Entering right marker. */\n\t\t\tif (list_state != 0) /* not inside the list */\n\t\t\t\tbreak;\n\t\t\tif (s[LIST_RIGHT].cx != 0) /* already have marker */\n\t\t\t\tbreak;\n\t\t\tif (fr != NULL) { /* abort any region */\n\t\t\t\tfree(fr);\n\t\t\t\tfr = NULL;\n\t\t\t}\n\t\t\tif (focus_start != -1 && focus_end == -1)\n\t\t\t\tfocus_start = focus_end = -1;\n\t\t\tcurrent = LIST_RIGHT;\n\t\t\tbreak;\n\t\t}\n\t\tif (current != last) {\n\t\t\tlog_debug(\"%s: change %s -> %s\", __func__,\n\t\t\t    names[last], names[current]);\n\t\t\tlast = current;\n\t\t}\n\n\t\t/*\n\t\t * Check if the range style has changed and if so end the\n\t\t * current range and start a new one if needed.\n\t\t */\n\t\tif (srs != NULL) {\n\t\t\tif (fr != NULL && !format_is_type(fr, &sy)) {\n\t\t\t\tif (s[current].cx != fr->start) {\n\t\t\t\t\tfr->end = s[current].cx + 1;\n\t\t\t\t\tTAILQ_INSERT_TAIL(&frs, fr, entry);\n\t\t\t\t} else\n\t\t\t\t\tfree(fr);\n\t\t\t\tfr = NULL;\n\t\t\t}\n\t\t\tif (fr == NULL && sy.range_type != STYLE_RANGE_NONE) {\n\t\t\t\tfr = xcalloc(1, sizeof *fr);\n\t\t\t\tfr->index = current;\n\n\t\t\t\tfr->s = &s[current];\n\t\t\t\tfr->start = s[current].cx;\n\n\t\t\t\tfr->type = sy.range_type;\n\t\t\t\tfr->argument = sy.range_argument;\n\t\t\t\tstrlcpy(fr->string, sy.range_string,\n\t\t\t\t    sizeof fr->string);\n\t\t\t}\n\t\t}\n\n\t\tcp = end + 1;\n\t}\n\tfree(fr);\n\n\tfor (i = 0; i < TOTAL; i++) {\n\t\tscreen_write_stop(&ctx[i]);\n\t\tlog_debug(\"%s: width %s is %u\", __func__, names[i], width[i]);\n\t}\n\tif (focus_start != -1 && focus_end != -1)\n\t\tlog_debug(\"%s: focus %d-%d\", __func__, focus_start, focus_end);\n\tTAILQ_FOREACH(fr, &frs, entry) {\n\t\tlog_debug(\"%s: range %d|%u is %s %u-%u\", __func__, fr->type,\n\t\t    fr->argument, names[fr->index], fr->start, fr->end);\n\t}\n\n\t/* Clear the available area. */\n\tif (fill != -1) {\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\tgc.bg = fill;\n\t\tfor (i = 0; i < available; i++)\n\t\t\tscreen_write_putc(octx, &gc, ' ');\n\t}\n\n\t/*\n\t * Draw the screens. How they are arranged depends on where the list\n\t * appears.\n\t */\n\tswitch (list_align) {\n\tcase STYLE_ALIGN_DEFAULT:\n\t\t/* No list. */\n\t\tformat_draw_none(octx, available, ocx, ocy, &s[LEFT],\n\t\t    &s[CENTRE], &s[RIGHT], &s[ABSOLUTE_CENTRE], &frs);\n\t\tbreak;\n\tcase STYLE_ALIGN_LEFT:\n\t\t/* List is part of the left. */\n\t\tformat_draw_left(octx, available, ocx, ocy, &s[LEFT],\n\t\t    &s[CENTRE], &s[RIGHT], &s[ABSOLUTE_CENTRE], &s[LIST],\n\t\t    &s[LIST_LEFT], &s[LIST_RIGHT], &s[AFTER],\n\t\t    focus_start, focus_end, &frs);\n\t\tbreak;\n\tcase STYLE_ALIGN_CENTRE:\n\t\t/* List is part of the centre. */\n\t\tformat_draw_centre(octx, available, ocx, ocy, &s[LEFT],\n\t\t    &s[CENTRE], &s[RIGHT], &s[ABSOLUTE_CENTRE], &s[LIST],\n\t\t    &s[LIST_LEFT], &s[LIST_RIGHT], &s[AFTER],\n\t\t    focus_start, focus_end, &frs);\n\t\tbreak;\n\tcase STYLE_ALIGN_RIGHT:\n\t\t/* List is part of the right. */\n\t\tformat_draw_right(octx, available, ocx, ocy, &s[LEFT],\n\t\t    &s[CENTRE], &s[RIGHT], &s[ABSOLUTE_CENTRE], &s[LIST],\n\t\t    &s[LIST_LEFT], &s[LIST_RIGHT], &s[AFTER],\n\t\t    focus_start, focus_end, &frs);\n\t\tbreak;\n\tcase STYLE_ALIGN_ABSOLUTE_CENTRE:\n\t\t/* List is in the centre of the entire horizontal space. */\n\t\tformat_draw_absolute_centre(octx, available, ocx, ocy, &s[LEFT],\n\t\t    &s[CENTRE], &s[RIGHT], &s[ABSOLUTE_CENTRE], &s[LIST],\n\t\t    &s[LIST_LEFT], &s[LIST_RIGHT], &s[AFTER],\n\t\t    focus_start, focus_end, &frs);\n\t\tbreak;\n\t}\n\n\t/* Create ranges to return. */\n\tTAILQ_FOREACH_SAFE(fr, &frs, entry, fr1) {\n\t\tsr = xcalloc(1, sizeof *sr);\n\t\tsr->type = fr->type;\n\t\tsr->argument = fr->argument;\n\t\tstrlcpy(sr->string, fr->string, sizeof sr->string);\n\t\tsr->start = fr->start;\n\t\tsr->end = fr->end;\n\t\tTAILQ_INSERT_TAIL(srs, sr, entry);\n\n\t\tswitch (sr->type) {\n\t\tcase STYLE_RANGE_NONE:\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_LEFT:\n\t\t\tlog_debug(\"%s: range left at %u-%u\", __func__,\n\t\t\t    sr->start, sr->end);\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_RIGHT:\n\t\t\tlog_debug(\"%s: range right at %u-%u\", __func__,\n\t\t\t    sr->start, sr->end);\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_PANE:\n\t\t\tlog_debug(\"%s: range pane|%%%u at %u-%u\", __func__,\n\t\t\t    sr->argument, sr->start, sr->end);\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_WINDOW:\n\t\t\tlog_debug(\"%s: range window|%u at %u-%u\", __func__,\n\t\t\t    sr->argument, sr->start, sr->end);\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_SESSION:\n\t\t\tlog_debug(\"%s: range session|$%u at %u-%u\", __func__,\n\t\t\t    sr->argument, sr->start, sr->end);\n\t\t\tbreak;\n\t\tcase STYLE_RANGE_USER:\n\t\t\tlog_debug(\"%s: range user|%u at %u-%u\", __func__,\n\t\t\t    sr->argument, sr->start, sr->end);\n\t\t\tbreak;\n\t\t}\n\t\tformat_free_range(&frs, fr);\n\t}\n\nout:\n\t/* Free the screens. */\n\tfor (i = 0; i < TOTAL; i++)\n\t\tscreen_free(&s[i]);\n\n\t/* Restore the original cursor position. */\n\tscreen_write_cursormove(octx, ocx, ocy, 0);\n}\n\n/* Get width, taking #[] into account. */\nu_int\nformat_width(const char *expanded)\n{\n\tconst char\t\t*cp, *end;\n\tu_int\t\t\t n, leading_width, width = 0;\n\tstruct utf8_data\t ud;\n\tenum utf8_state\t\t more;\n\n\tcp = expanded;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '#') {\n\t\t\tend = format_leading_hashes(cp, &n, &leading_width);\n\t\t\twidth += leading_width;\n\t\t\tcp = end;\n\t\t\tif (*cp == '#') {\n\t\t\t\tend = format_skip(cp + 2, \"]\");\n\t\t\t\tif (end == NULL)\n\t\t\t\t\treturn (0);\n\t\t\t\tcp = end + 1;\n\t\t\t}\n\t\t} else if ((more = utf8_open(&ud, *cp)) == UTF8_MORE) {\n\t\t\twhile (*++cp != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *cp);\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\twidth += ud.width;\n\t\t\telse\n\t\t\t\tcp -= ud.have;\n\t\t} else if (*cp > 0x1f && *cp < 0x7f) {\n\t\t\twidth++;\n\t\t\tcp++;\n\t\t} else\n\t\t\tcp++;\n\t}\n\treturn (width);\n}\n\n/*\n * Trim on the left, taking #[] into account.  Note, we copy the whole set of\n * unescaped #s, but only add their escaped size to width. This is because the\n * format_draw function will actually do the escaping when it runs\n */\nchar *\nformat_trim_left(const char *expanded, u_int limit)\n{\n\tchar\t\t\t*copy, *out;\n\tconst char\t\t*cp = expanded, *end;\n\tu_int\t\t\t n, width = 0, leading_width;\n\tstruct utf8_data\t ud;\n\tenum utf8_state\t\t more;\n\n\tout = copy = xcalloc(2, strlen(expanded) + 1);\n\twhile (*cp != '\\0') {\n\t\tif (width >= limit)\n\t\t\tbreak;\n\t\tif (*cp == '#') {\n\t\t\tend = format_leading_hashes(cp, &n, &leading_width);\n\t\t\tif (leading_width > limit - width)\n\t\t\t\tleading_width = limit - width;\n\t\t\tif (leading_width != 0) {\n\t\t\t\tif (n == 1)\n\t\t\t\t\t*out++ = '#';\n\t\t\t\telse {\n\t\t\t\t\tmemset(out, '#', 2 * leading_width);\n\t\t\t\t\tout += 2 * leading_width;\n\t\t\t\t}\n\t\t\t\twidth += leading_width;\n\t\t\t}\n\t\t\tcp = end;\n\t\t\tif (*cp == '#') {\n\t\t\t\tend = format_skip(cp + 2, \"]\");\n\t\t\t\tif (end == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(out, cp, end + 1 - cp);\n\t\t\t\tout += (end + 1 - cp);\n\t\t\t\tcp = end + 1;\n\t\t\t}\n\t\t} else if ((more = utf8_open(&ud, *cp)) == UTF8_MORE) {\n\t\t\twhile (*++cp != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *cp);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tif (width + ud.width <= limit) {\n\t\t\t\t\tmemcpy(out, ud.data, ud.size);\n\t\t\t\t\tout += ud.size;\n\t\t\t\t}\n\t\t\t\twidth += ud.width;\n\t\t\t} else {\n\t\t\t\tcp -= ud.have;\n\t\t\t\tcp++;\n\t\t\t}\n\t\t} else if (*cp > 0x1f && *cp < 0x7f) {\n\t\t\tif (width + 1 <= limit)\n\t\t\t\t*out++ = *cp;\n\t\t\twidth++;\n\t\t\tcp++;\n\t\t} else\n\t\t\tcp++;\n\t}\n\t*out = '\\0';\n\treturn (copy);\n}\n\n/* Trim on the right, taking #[] into account. */\nchar *\nformat_trim_right(const char *expanded, u_int limit)\n{\n\tchar\t\t\t*copy, *out;\n\tconst char\t\t*cp = expanded, *end;\n\tu_int\t\t\t width = 0, total_width, skip, n;\n\tu_int\t\t\t leading_width, copy_width;\n\tstruct utf8_data\t ud;\n\tenum utf8_state\t\t more;\n\n\ttotal_width = format_width(expanded);\n\tif (total_width <= limit)\n\t\treturn (xstrdup(expanded));\n\tskip = total_width - limit;\n\n\tout = copy = xcalloc(2, strlen(expanded) + 1);\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '#') {\n\t\t\tend = format_leading_hashes(cp, &n, &leading_width);\n\t\t\tcopy_width = leading_width;\n\t\t\tif (width <= skip) {\n\t\t\t\tif (skip - width >= copy_width)\n\t\t\t\t\tcopy_width = 0;\n\t\t\t\telse\n\t\t\t\t\tcopy_width -= (skip - width);\n\t\t\t}\n\t\t\tif (copy_width != 0) {\n\t\t\t\tif (n == 1)\n\t\t\t\t\t*out++ = '#';\n\t\t\t\telse {\n\t\t\t\t\tmemset(out, '#', 2 * copy_width);\n\t\t\t\t\tout += 2 * copy_width;\n\t\t\t\t}\n\t\t\t}\n\t\t\twidth += leading_width;\n\t\t\tcp = end;\n\t\t\tif (*cp == '#') {\n\t\t\t\tend = format_skip(cp + 2, \"]\");\n\t\t\t\tif (end == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(out, cp, end + 1 - cp);\n\t\t\t\tout += (end + 1 - cp);\n\t\t\t\tcp = end + 1;\n\t\t\t}\n\t\t} else if ((more = utf8_open(&ud, *cp)) == UTF8_MORE) {\n\t\t\twhile (*++cp != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *cp);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tif (width >= skip) {\n\t\t\t\t\tmemcpy(out, ud.data, ud.size);\n\t\t\t\t\tout += ud.size;\n\t\t\t\t}\n\t\t\t\twidth += ud.width;\n\t\t\t} else {\n\t\t\t\tcp -= ud.have;\n\t\t\t\tcp++;\n\t\t\t}\n\t\t} else if (*cp > 0x1f && *cp < 0x7f) {\n\t\t\tif (width >= skip)\n\t\t\t\t*out++ = *cp;\n\t\t\twidth++;\n\t\t\tcp++;\n\t\t} else\n\t\t\tcp++;\n\t}\n\t*out = '\\0';\n\treturn (copy);\n}\n"
        },
        {
          "name": "format.c",
          "type": "blob",
          "size": 115.140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fnmatch.h>\n#include <libgen.h>\n#include <math.h>\n#include <pwd.h>\n#include <regex.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Build a list of key-value pairs and use them to expand #{key} entries in a\n * string.\n */\n\nstruct format_expand_state;\n\nstatic char\t*format_job_get(struct format_expand_state *, const char *);\nstatic char\t*format_expand1(struct format_expand_state *, const char *);\nstatic int\t format_replace(struct format_expand_state *, const char *,\n\t\t     size_t, char **, size_t *, size_t *);\nstatic void\t format_defaults_session(struct format_tree *,\n\t\t     struct session *);\nstatic void\t format_defaults_client(struct format_tree *, struct client *);\nstatic void\t format_defaults_winlink(struct format_tree *,\n\t\t     struct winlink *);\n\n/* Entry in format job tree. */\nstruct format_job {\n\tstruct client\t\t*client;\n\tu_int\t\t\t tag;\n\tconst char\t\t*cmd;\n\tconst char\t\t*expanded;\n\n\ttime_t\t\t\t last;\n\tchar\t\t\t*out;\n\tint\t\t\t updated;\n\n\tstruct job\t\t*job;\n\tint\t\t\t status;\n\n\tRB_ENTRY(format_job)\t entry;\n};\n\n/* Format job tree. */\nstatic int format_job_cmp(struct format_job *, struct format_job *);\nstatic RB_HEAD(format_job_tree, format_job) format_jobs = RB_INITIALIZER();\nRB_GENERATE_STATIC(format_job_tree, format_job, entry, format_job_cmp);\n\n/* Format job tree comparison function. */\nstatic int\nformat_job_cmp(struct format_job *fj1, struct format_job *fj2)\n{\n\tif (fj1->tag < fj2->tag)\n\t\treturn (-1);\n\tif (fj1->tag > fj2->tag)\n\t\treturn (1);\n\treturn (strcmp(fj1->cmd, fj2->cmd));\n}\n\n/* Format modifiers. */\n#define FORMAT_TIMESTRING 0x1\n#define FORMAT_BASENAME 0x2\n#define FORMAT_DIRNAME 0x4\n#define FORMAT_QUOTE_SHELL 0x8\n#define FORMAT_LITERAL 0x10\n#define FORMAT_EXPAND 0x20\n#define FORMAT_EXPANDTIME 0x40\n#define FORMAT_SESSIONS 0x80\n#define FORMAT_WINDOWS 0x100\n#define FORMAT_PANES 0x200\n#define FORMAT_PRETTY 0x400\n#define FORMAT_LENGTH 0x800\n#define FORMAT_WIDTH 0x1000\n#define FORMAT_QUOTE_STYLE 0x2000\n#define FORMAT_WINDOW_NAME 0x4000\n#define FORMAT_SESSION_NAME 0x8000\n#define FORMAT_CHARACTER 0x10000\n#define FORMAT_COLOUR 0x20000\n#define FORMAT_CLIENTS 0x40000\n\n/* Limit on recursion. */\n#define FORMAT_LOOP_LIMIT 100\n\n/* Format expand flags. */\n#define FORMAT_EXPAND_TIME 0x1\n#define FORMAT_EXPAND_NOJOBS 0x2\n\n/* Entry in format tree. */\nstruct format_entry {\n\tchar\t\t\t*key;\n\tchar\t\t\t*value;\n\ttime_t\t\t\t time;\n\tformat_cb\t\t cb;\n\tRB_ENTRY(format_entry)\t entry;\n};\n\n/* Format type. */\nenum format_type {\n\tFORMAT_TYPE_UNKNOWN,\n\tFORMAT_TYPE_SESSION,\n\tFORMAT_TYPE_WINDOW,\n\tFORMAT_TYPE_PANE\n};\n\nstruct format_tree {\n\tenum format_type\t type;\n\n\tstruct client\t\t*c;\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tstruct paste_buffer\t*pb;\n\n\tstruct cmdq_item\t*item;\n\tstruct client\t\t*client;\n\tint\t\t\t flags;\n\tu_int\t\t\t tag;\n\n\tstruct mouse_event\t m;\n\n\tRB_HEAD(format_entry_tree, format_entry) tree;\n};\nstatic int format_entry_cmp(struct format_entry *, struct format_entry *);\nRB_GENERATE_STATIC(format_entry_tree, format_entry, entry, format_entry_cmp);\n\n/* Format expand state. */\nstruct format_expand_state {\n\tstruct format_tree\t*ft;\n\tu_int\t\t\t loop;\n\ttime_t\t\t\t time;\n\tstruct tm\t\t tm;\n\tint\t\t\t flags;\n};\n\n/* Format modifier. */\nstruct format_modifier {\n\tchar\t  modifier[3];\n\tu_int\t  size;\n\n\tchar\t**argv;\n\tint\t  argc;\n};\n\n/* Format entry tree comparison function. */\nstatic int\nformat_entry_cmp(struct format_entry *fe1, struct format_entry *fe2)\n{\n\treturn (strcmp(fe1->key, fe2->key));\n}\n\n/* Single-character uppercase aliases. */\nstatic const char *format_upper[] = {\n\tNULL,\t\t/* A */\n\tNULL,\t\t/* B */\n\tNULL,\t\t/* C */\n\t\"pane_id\",\t/* D */\n\tNULL,\t\t/* E */\n\t\"window_flags\",\t/* F */\n\tNULL,\t\t/* G */\n\t\"host\",\t\t/* H */\n\t\"window_index\",\t/* I */\n\tNULL,\t\t/* J */\n\tNULL,\t\t/* K */\n\tNULL,\t\t/* L */\n\tNULL,\t\t/* M */\n\tNULL,\t\t/* N */\n\tNULL,\t\t/* O */\n\t\"pane_index\",\t/* P */\n\tNULL,\t\t/* Q */\n\tNULL,\t\t/* R */\n\t\"session_name\",\t/* S */\n\t\"pane_title\",\t/* T */\n\tNULL,\t\t/* U */\n\tNULL,\t\t/* V */\n\t\"window_name\",\t/* W */\n\tNULL,\t\t/* X */\n\tNULL,\t\t/* Y */\n\tNULL \t\t/* Z */\n};\n\n/* Single-character lowercase aliases. */\nstatic const char *format_lower[] = {\n\tNULL,\t\t/* a */\n\tNULL,\t\t/* b */\n\tNULL,\t\t/* c */\n\tNULL,\t\t/* d */\n\tNULL,\t\t/* e */\n\tNULL,\t\t/* f */\n\tNULL,\t\t/* g */\n\t\"host_short\",\t/* h */\n\tNULL,\t\t/* i */\n\tNULL,\t\t/* j */\n\tNULL,\t\t/* k */\n\tNULL,\t\t/* l */\n\tNULL,\t\t/* m */\n\tNULL,\t\t/* n */\n\tNULL,\t\t/* o */\n\tNULL,\t\t/* p */\n\tNULL,\t\t/* q */\n\tNULL,\t\t/* r */\n\tNULL,\t\t/* s */\n\tNULL,\t\t/* t */\n\tNULL,\t\t/* u */\n\tNULL,\t\t/* v */\n\tNULL,\t\t/* w */\n\tNULL,\t\t/* x */\n\tNULL,\t\t/* y */\n\tNULL\t\t/* z */\n};\n\n/* Is logging enabled? */\nstatic inline int\nformat_logging(struct format_tree *ft)\n{\n\treturn (log_get_level() != 0 || (ft->flags & FORMAT_VERBOSE));\n}\n\n/* Log a message if verbose. */\nstatic void printflike(3, 4)\nformat_log1(struct format_expand_state *es, const char *from, const char *fmt,\n    ...)\n{\n\tstruct format_tree\t*ft = es->ft;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*s;\n\tstatic const char\t spaces[] = \"          \";\n\n\tif (!format_logging(ft))\n\t\treturn;\n\n\tva_start(ap, fmt);\n\txvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"%s: %s\", from, s);\n\tif (ft->item != NULL && (ft->flags & FORMAT_VERBOSE))\n\t\tcmdq_print(ft->item, \"#%.*s%s\", es->loop, spaces, s);\n\n\tfree(s);\n}\n#define format_log(es, fmt, ...) format_log1(es, __func__, fmt, ##__VA_ARGS__)\n\n/* Copy expand state. */\nstatic void\nformat_copy_state(struct format_expand_state *to,\n    struct format_expand_state *from, int flags)\n{\n\tto->ft = from->ft;\n\tto->loop = from->loop;\n\tto->time = from->time;\n\tmemcpy(&to->tm, &from->tm, sizeof to->tm);\n\tto->flags = from->flags|flags;\n}\n\n/* Format job update callback. */\nstatic void\nformat_job_update(struct job *job)\n{\n\tstruct format_job\t*fj = job_get_data(job);\n\tstruct evbuffer\t\t*evb = job_get_event(job)->input;\n\tchar\t\t\t*line = NULL, *next;\n\ttime_t\t\t\t t;\n\n\twhile ((next = evbuffer_readline(evb)) != NULL) {\n\t\tfree(line);\n\t\tline = next;\n\t}\n\tif (line == NULL)\n\t\treturn;\n\tfj->updated = 1;\n\n\tfree(fj->out);\n\tfj->out = line;\n\n\tlog_debug(\"%s: %p %s: %s\", __func__, fj, fj->cmd, fj->out);\n\n\tt = time(NULL);\n\tif (fj->status && fj->last != t) {\n\t\tif (fj->client != NULL)\n\t\t\tserver_status_client(fj->client);\n\t\tfj->last = t;\n\t}\n}\n\n/* Format job complete callback. */\nstatic void\nformat_job_complete(struct job *job)\n{\n\tstruct format_job\t*fj = job_get_data(job);\n\tstruct evbuffer\t\t*evb = job_get_event(job)->input;\n\tchar\t\t\t*line, *buf;\n\tsize_t\t\t\t len;\n\n\tfj->job = NULL;\n\n\tbuf = NULL;\n\tif ((line = evbuffer_readline(evb)) == NULL) {\n\t\tlen = EVBUFFER_LENGTH(evb);\n\t\tbuf = xmalloc(len + 1);\n\t\tif (len != 0)\n\t\t\tmemcpy(buf, EVBUFFER_DATA(evb), len);\n\t\tbuf[len] = '\\0';\n\t} else\n\t\tbuf = line;\n\n\tlog_debug(\"%s: %p %s: %s\", __func__, fj, fj->cmd, buf);\n\n\tif (*buf != '\\0' || !fj->updated) {\n\t\tfree(fj->out);\n\t\tfj->out = buf;\n\t} else\n\t\tfree(buf);\n\n\tif (fj->status) {\n\t\tif (fj->client != NULL)\n\t\t\tserver_status_client(fj->client);\n\t\tfj->status = 0;\n\t}\n}\n\n/* Find a job. */\nstatic char *\nformat_job_get(struct format_expand_state *es, const char *cmd)\n{\n\tstruct format_tree\t\t*ft = es->ft;\n\tstruct format_job_tree\t\t*jobs;\n\tstruct format_job\t\t fj0, *fj;\n\ttime_t\t\t\t\t t;\n\tchar\t\t\t\t*expanded;\n\tint\t\t\t\t force;\n\tstruct format_expand_state\t next;\n\n\tif (ft->client == NULL)\n\t\tjobs = &format_jobs;\n\telse if (ft->client->jobs != NULL)\n\t\tjobs = ft->client->jobs;\n\telse {\n\t\tjobs = ft->client->jobs = xmalloc(sizeof *ft->client->jobs);\n\t\tRB_INIT(jobs);\n\t}\n\n\tfj0.tag = ft->tag;\n\tfj0.cmd = cmd;\n\tif ((fj = RB_FIND(format_job_tree, jobs, &fj0)) == NULL) {\n\t\tfj = xcalloc(1, sizeof *fj);\n\t\tfj->client = ft->client;\n\t\tfj->tag = ft->tag;\n\t\tfj->cmd = xstrdup(cmd);\n\n\t\tRB_INSERT(format_job_tree, jobs, fj);\n\t}\n\n\tformat_copy_state(&next, es, FORMAT_EXPAND_NOJOBS);\n\tnext.flags &= ~FORMAT_EXPAND_TIME;\n\n\texpanded = format_expand1(&next, cmd);\n\tif (fj->expanded == NULL || strcmp(expanded, fj->expanded) != 0) {\n\t\tfree((void *)fj->expanded);\n\t\tfj->expanded = xstrdup(expanded);\n\t\tforce = 1;\n\t} else\n\t\tforce = (ft->flags & FORMAT_FORCE);\n\n\tt = time(NULL);\n\tif (force && fj->job != NULL)\n\t       job_free(fj->job);\n\tif (force || (fj->job == NULL && fj->last != t)) {\n\t\tfj->job = job_run(expanded, 0, NULL, NULL, NULL,\n\t\t    server_client_get_cwd(ft->client, NULL), format_job_update,\n\t\t    format_job_complete, NULL, fj, JOB_NOWAIT, -1, -1);\n\t\tif (fj->job == NULL) {\n\t\t\tfree(fj->out);\n\t\t\txasprintf(&fj->out, \"<'%s' didn't start>\", fj->cmd);\n\t\t}\n\t\tfj->last = t;\n\t\tfj->updated = 0;\n\t} else if (fj->job != NULL && (t - fj->last) > 1 && fj->out == NULL)\n\t\txasprintf(&fj->out, \"<'%s' not ready>\", fj->cmd);\n\tfree(expanded);\n\n\tif (ft->flags & FORMAT_STATUS)\n\t\tfj->status = 1;\n\tif (fj->out == NULL)\n\t\treturn (xstrdup(\"\"));\n\treturn (format_expand1(&next, fj->out));\n}\n\n/* Remove old jobs. */\nstatic void\nformat_job_tidy(struct format_job_tree *jobs, int force)\n{\n\tstruct format_job\t*fj, *fj1;\n\ttime_t\t\t\t now;\n\n\tnow = time(NULL);\n\tRB_FOREACH_SAFE(fj, format_job_tree, jobs, fj1) {\n\t\tif (!force && (fj->last > now || now - fj->last < 3600))\n\t\t\tcontinue;\n\t\tRB_REMOVE(format_job_tree, jobs, fj);\n\n\t\tlog_debug(\"%s: %s\", __func__, fj->cmd);\n\n\t\tif (fj->job != NULL)\n\t\t\tjob_free(fj->job);\n\n\t\tfree((void *)fj->expanded);\n\t\tfree((void *)fj->cmd);\n\t\tfree(fj->out);\n\n\t\tfree(fj);\n\t}\n}\n\n/* Tidy old jobs for all clients. */\nvoid\nformat_tidy_jobs(void)\n{\n\tstruct client\t*c;\n\n\tformat_job_tidy(&format_jobs, 0);\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->jobs != NULL)\n\t\t\tformat_job_tidy(c->jobs, 0);\n\t}\n}\n\n/* Remove old jobs for client. */\nvoid\nformat_lost_client(struct client *c)\n{\n\tif (c->jobs != NULL)\n\t\tformat_job_tidy(c->jobs, 1);\n\tfree(c->jobs);\n}\n\n/* Wrapper for asprintf. */\nstatic char * printflike(1, 2)\nformat_printf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*s;\n\n\tva_start(ap, fmt);\n\txvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\treturn (s);\n}\n\n/* Callback for host. */\nstatic void *\nformat_cb_host(__unused struct format_tree *ft)\n{\n\tchar host[HOST_NAME_MAX + 1];\n\n\tif (gethostname(host, sizeof host) != 0)\n\t\treturn (xstrdup(\"\"));\n\treturn (xstrdup(host));\n}\n\n/* Callback for host_short. */\nstatic void *\nformat_cb_host_short(__unused struct format_tree *ft)\n{\n\tchar host[HOST_NAME_MAX + 1], *cp;\n\n\tif (gethostname(host, sizeof host) != 0)\n\t\treturn (xstrdup(\"\"));\n\tif ((cp = strchr(host, '.')) != NULL)\n\t\t*cp = '\\0';\n\treturn (xstrdup(host));\n}\n\n/* Callback for pid. */\nstatic void *\nformat_cb_pid(__unused struct format_tree *ft)\n{\n\tchar\t*value;\n\n\txasprintf(&value, \"%ld\", (long)getpid());\n\treturn (value);\n}\n\n/* Callback for session_attached_list. */\nstatic void *\nformat_cb_session_attached_list(struct format_tree *ft)\n{\n\tstruct session\t*s = ft->s;\n\tstruct client\t*loop;\n\tstruct evbuffer\t*buffer;\n\tint\t\t size;\n\tchar\t\t*value = NULL;\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (loop->session == s) {\n\t\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\t\tevbuffer_add_printf(buffer, \"%s\", loop->name);\n\t\t}\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for session_alerts. */\nstatic void *\nformat_cb_session_alerts(struct format_tree *ft)\n{\n\tstruct session\t*s = ft->s;\n\tstruct winlink\t*wl;\n\tchar\t\t alerts[1024], tmp[16];\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\n\t*alerts = '\\0';\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif ((wl->flags & WINLINK_ALERTFLAGS) == 0)\n\t\t\tcontinue;\n\t\txsnprintf(tmp, sizeof tmp, \"%u\", wl->idx);\n\n\t\tif (*alerts != '\\0')\n\t\t\tstrlcat(alerts, \",\", sizeof alerts);\n\t\tstrlcat(alerts, tmp, sizeof alerts);\n\t\tif (wl->flags & WINLINK_ACTIVITY)\n\t\t\tstrlcat(alerts, \"#\", sizeof alerts);\n\t\tif (wl->flags & WINLINK_BELL)\n\t\t\tstrlcat(alerts, \"!\", sizeof alerts);\n\t\tif (wl->flags & WINLINK_SILENCE)\n\t\t\tstrlcat(alerts, \"~\", sizeof alerts);\n\t}\n\treturn (xstrdup(alerts));\n}\n\n/* Callback for session_stack. */\nstatic void *\nformat_cb_session_stack(struct format_tree *ft)\n{\n\tstruct session\t*s = ft->s;\n\tstruct winlink\t*wl;\n\tchar\t\t result[1024], tmp[16];\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\n\txsnprintf(result, sizeof result, \"%u\", s->curw->idx);\n\tTAILQ_FOREACH(wl, &s->lastw, sentry) {\n\t\txsnprintf(tmp, sizeof tmp, \"%u\", wl->idx);\n\n\t\tif (*result != '\\0')\n\t\t\tstrlcat(result, \",\", sizeof result);\n\t\tstrlcat(result, tmp, sizeof result);\n\t}\n\treturn (xstrdup(result));\n}\n\n/* Callback for window_stack_index. */\nstatic void *\nformat_cb_window_stack_index(struct format_tree *ft)\n{\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\tu_int\t\t idx;\n\tchar\t\t*value = NULL;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\ts = ft->wl->session;\n\n\tidx = 0;\n\tTAILQ_FOREACH(wl, &s->lastw, sentry) {\n\t\tidx++;\n\t\tif (wl == ft->wl)\n\t\t\tbreak;\n\t}\n\tif (wl == NULL)\n\t\treturn (xstrdup(\"0\"));\n\txasprintf(&value, \"%u\", idx);\n\treturn (value);\n}\n\n/* Callback for window_linked_sessions_list. */\nstatic void *\nformat_cb_window_linked_sessions_list(struct format_tree *ft)\n{\n\tstruct window\t*w;\n\tstruct winlink\t*wl;\n\tstruct evbuffer\t*buffer;\n\tint\t\t size;\n\tchar\t\t*value = NULL;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\tevbuffer_add_printf(buffer, \"%s\", wl->session->name);\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for window_active_sessions. */\nstatic void *\nformat_cb_window_active_sessions(struct format_tree *ft)\n{\n\tstruct window\t*w;\n\tstruct winlink\t*wl;\n\tu_int\t\t n = 0;\n\tchar\t\t*value;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session->curw == wl)\n\t\t\tn++;\n\t}\n\n\txasprintf(&value, \"%u\", n);\n\treturn (value);\n}\n\n/* Callback for window_active_sessions_list. */\nstatic void *\nformat_cb_window_active_sessions_list(struct format_tree *ft)\n{\n\tstruct window\t*w;\n\tstruct winlink\t*wl;\n\tstruct evbuffer\t*buffer;\n\tint\t\t size;\n\tchar\t\t*value = NULL;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session->curw == wl) {\n\t\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\t\tevbuffer_add_printf(buffer, \"%s\", wl->session->name);\n\t\t}\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for window_active_clients. */\nstatic void *\nformat_cb_window_active_clients(struct format_tree *ft)\n{\n\tstruct window\t*w;\n\tstruct client\t*loop;\n\tstruct session\t*client_session;\n\tu_int\t\t n = 0;\n\tchar\t\t*value;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tclient_session = loop->session;\n\t\tif (client_session == NULL)\n\t\t\tcontinue;\n\n\t\tif (w == client_session->curw->window)\n\t\t\tn++;\n\t}\n\n\txasprintf(&value, \"%u\", n);\n\treturn (value);\n}\n\n/* Callback for window_active_clients_list. */\nstatic void *\nformat_cb_window_active_clients_list(struct format_tree *ft)\n{\n\tstruct window\t*w;\n\tstruct client\t*loop;\n\tstruct session\t*client_session;\n\tstruct evbuffer\t*buffer;\n\tint\t\t size;\n\tchar\t\t*value = NULL;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tclient_session = loop->session;\n\t\tif (client_session == NULL)\n\t\t\tcontinue;\n\n\t\tif (w == client_session->curw->window) {\n\t\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\t\tevbuffer_add_printf(buffer, \"%s\", loop->name);\n\t\t}\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for window_layout. */\nstatic void *\nformat_cb_window_layout(struct format_tree *ft)\n{\n\tstruct window\t*w = ft->w;\n\n\tif (w == NULL)\n\t\treturn (NULL);\n\n\tif (w->saved_layout_root != NULL)\n\t\treturn (layout_dump(w->saved_layout_root));\n\treturn (layout_dump(w->layout_root));\n}\n\n/* Callback for window_visible_layout. */\nstatic void *\nformat_cb_window_visible_layout(struct format_tree *ft)\n{\n\tstruct window\t*w = ft->w;\n\n\tif (w == NULL)\n\t\treturn (NULL);\n\n\treturn (layout_dump(w->layout_root));\n}\n\n/* Callback for pane_start_command. */\nstatic void *\nformat_cb_start_command(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\treturn (cmd_stringify_argv(wp->argc, wp->argv));\n}\n\n/* Callback for pane_start_path. */\nstatic void *\nformat_cb_start_path(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\tif (wp->cwd == NULL)\n\t\treturn (xstrdup(\"\"));\n\treturn (xstrdup(wp->cwd));\n}\n\n/* Callback for pane_current_command. */\nstatic void *\nformat_cb_current_command(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tchar\t\t\t*cmd, *value;\n\n\tif (wp == NULL || wp->shell == NULL)\n\t\treturn (NULL);\n\n\tcmd = osdep_get_name(wp->fd, wp->tty);\n\tif (cmd == NULL || *cmd == '\\0') {\n\t\tfree(cmd);\n\t\tcmd = cmd_stringify_argv(wp->argc, wp->argv);\n\t\tif (cmd == NULL || *cmd == '\\0') {\n\t\t\tfree(cmd);\n\t\t\tcmd = xstrdup(wp->shell);\n\t\t}\n\t}\n\tvalue = parse_window_name(cmd);\n\tfree(cmd);\n\treturn (value);\n}\n\n/* Callback for pane_current_path. */\nstatic void *\nformat_cb_current_path(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tchar\t\t\t*cwd;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\tcwd = osdep_get_cwd(wp->fd);\n\tif (cwd == NULL)\n\t\treturn (NULL);\n\treturn (xstrdup(cwd));\n}\n\n/* Callback for history_bytes. */\nstatic void *\nformat_cb_history_bytes(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid\t\t*gd;\n\tstruct grid_line\t*gl;\n\tsize_t\t\t         size = 0;\n\tu_int\t\t\t i;\n\tchar\t\t\t*value;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tgd = wp->base.grid;\n\n\tfor (i = 0; i < gd->hsize + gd->sy; i++) {\n\t\tgl = grid_get_line(gd, i);\n\t\tsize += gl->cellsize * sizeof *gl->celldata;\n\t\tsize += gl->extdsize * sizeof *gl->extddata;\n\t}\n\tsize += (gd->hsize + gd->sy) * sizeof *gl;\n\n\txasprintf(&value, \"%zu\", size);\n\treturn (value);\n}\n\n/* Callback for history_all_bytes. */\nstatic void *\nformat_cb_history_all_bytes(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid\t\t*gd;\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t i, lines, cells = 0, extended_cells = 0;\n\tchar\t\t\t*value;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tgd = wp->base.grid;\n\n\tlines = gd->hsize + gd->sy;\n\tfor (i = 0; i < lines; i++) {\n\t\tgl = grid_get_line(gd, i);\n\t\tcells += gl->cellsize;\n\t\textended_cells += gl->extdsize;\n\t}\n\n\txasprintf(&value, \"%u,%zu,%u,%zu,%u,%zu\", lines,\n\t    lines * sizeof *gl, cells, cells * sizeof *gl->celldata,\n\t    extended_cells, extended_cells * sizeof *gl->extddata);\n\treturn (value);\n}\n\n/* Callback for pane_tabs. */\nstatic void *\nformat_cb_pane_tabs(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct evbuffer\t\t*buffer;\n\tu_int\t\t\t i;\n\tint\t\t\t size;\n\tchar\t\t\t*value = NULL;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\tfor (i = 0; i < wp->base.grid->sx; i++) {\n\t\tif (!bit_test(wp->base.tabs, i))\n\t\t\tcontinue;\n\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\tevbuffer_add_printf(buffer, \"%u\", i);\n\t}\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for pane_fg. */\nstatic void *\nformat_cb_pane_fg(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid_cell\t gc;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\ttty_default_colours(&gc, wp);\n\treturn (xstrdup(colour_tostring(gc.fg)));\n}\n\n/* Callback for pane_bg. */\nstatic void *\nformat_cb_pane_bg(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid_cell\t gc;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\ttty_default_colours(&gc, wp);\n\treturn (xstrdup(colour_tostring(gc.bg)));\n}\n\n/* Callback for session_group_list. */\nstatic void *\nformat_cb_session_group_list(struct format_tree *ft)\n{\n\tstruct session\t\t*s = ft->s;\n\tstruct session_group\t*sg;\n\tstruct session\t\t*loop;\n\tstruct evbuffer\t\t*buffer;\n\tint\t\t\t size;\n\tchar\t\t\t*value = NULL;\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\tsg = session_group_contains(s);\n\tif (sg == NULL)\n\t\treturn (NULL);\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(loop, &sg->sessions, gentry) {\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\tevbuffer_add_printf(buffer, \"%s\", loop->name);\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for session_group_attached_list. */\nstatic void *\nformat_cb_session_group_attached_list(struct format_tree *ft)\n{\n\tstruct session\t\t*s = ft->s, *client_session, *session_loop;\n\tstruct session_group\t*sg;\n\tstruct client\t\t*loop;\n\tstruct evbuffer\t\t*buffer;\n\tint\t\t\t size;\n\tchar\t\t\t*value = NULL;\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\tsg = session_group_contains(s);\n\tif (sg == NULL)\n\t\treturn (NULL);\n\n\tbuffer = evbuffer_new();\n\tif (buffer == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tclient_session = loop->session;\n\t\tif (client_session == NULL)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(session_loop, &sg->sessions, gentry) {\n\t\t\tif (session_loop == client_session){\n\t\t\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\t\t\tevbuffer_add_printf(buffer, \"%s\", loop->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n\treturn (value);\n}\n\n/* Callback for pane_in_mode. */\nstatic void *\nformat_cb_pane_in_mode(struct format_tree *ft)\n{\n\tstruct window_pane\t\t*wp = ft->wp;\n\tu_int\t\t\t\t n = 0;\n\tstruct window_mode_entry\t*wme;\n\tchar\t\t\t\t*value;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\tTAILQ_FOREACH(wme, &wp->modes, entry)\n\t\tn++;\n\txasprintf(&value, \"%u\", n);\n\treturn (value);\n}\n\n/* Callback for pane_at_top. */\nstatic void *\nformat_cb_pane_at_top(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct window\t\t*w;\n\tint\t\t\t status, flag;\n\tchar\t\t\t*value;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tif (status == PANE_STATUS_TOP)\n\t\tflag = (wp->yoff == 1);\n\telse\n\t\tflag = (wp->yoff == 0);\n\txasprintf(&value, \"%d\", flag);\n\treturn (value);\n}\n\n/* Callback for pane_at_bottom. */\nstatic void *\nformat_cb_pane_at_bottom(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct window\t\t*w;\n\tint\t\t\t status, flag;\n\tchar\t\t\t*value;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tif (status == PANE_STATUS_BOTTOM)\n\t\tflag = (wp->yoff + wp->sy == w->sy - 1);\n\telse\n\t\tflag = (wp->yoff + wp->sy == w->sy);\n\txasprintf(&value, \"%d\", flag);\n\treturn (value);\n}\n\n/* Callback for cursor_character. */\nstatic void *\nformat_cb_cursor_character(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid_cell\t gc;\n\tchar\t\t\t*value = NULL;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\n\tgrid_view_get_cell(wp->base.grid, wp->base.cx, wp->base.cy, &gc);\n\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\txasprintf(&value, \"%.*s\", (int)gc.data.size, gc.data.data);\n\treturn (value);\n}\n\n/* Callback for mouse_word. */\nstatic void *\nformat_cb_mouse_word(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\tstruct grid\t\t*gd;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tif (cmd_mouse_at(wp, &ft->m, &x, &y, 0) != 0)\n\t\treturn (NULL);\n\n\tif (!TAILQ_EMPTY(&wp->modes)) {\n\t\tif (window_pane_mode(wp) != WINDOW_PANE_NO_MODE)\n\t\t\treturn (window_copy_get_word(wp, x, y));\n\t\treturn (NULL);\n\t}\n\tgd = wp->base.grid;\n\treturn (format_grid_word(gd, x, gd->hsize + y));\n}\n\n/* Callback for mouse_hyperlink. */\nstatic void *\nformat_cb_mouse_hyperlink(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\tstruct grid\t\t*gd;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tif (cmd_mouse_at(wp, &ft->m, &x, &y, 0) != 0)\n\t\treturn (NULL);\n\tgd = wp->base.grid;\n\treturn (format_grid_hyperlink(gd, x, gd->hsize + y, wp->screen));\n}\n\n/* Callback for mouse_line. */\nstatic void *\nformat_cb_mouse_line(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\tstruct grid\t\t*gd;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tif (cmd_mouse_at(wp, &ft->m, &x, &y, 0) != 0)\n\t\treturn (NULL);\n\n\tif (!TAILQ_EMPTY(&wp->modes)) {\n\t\tif (window_pane_mode(wp) != WINDOW_PANE_NO_MODE)\n\t\t\treturn (window_copy_get_line(wp, y));\n\t\treturn (NULL);\n\t}\n\tgd = wp->base.grid;\n\treturn (format_grid_line(gd, gd->hsize + y));\n}\n\n/* Callback for mouse_status_line. */\nstatic void *\nformat_cb_mouse_status_line(struct format_tree *ft)\n{\n\tchar\t*value;\n\tu_int\t y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\tif (ft->c == NULL || (~ft->c->tty.flags & TTY_STARTED))\n\t\treturn (NULL);\n\n\tif (ft->m.statusat == 0 && ft->m.y < ft->m.statuslines) {\n\t\ty = ft->m.y;\n\t} else if (ft->m.statusat > 0 && ft->m.y >= (u_int)ft->m.statusat) {\n\t\ty = ft->m.y - ft->m.statusat;\n\t} else\n\t\treturn (NULL);\n\txasprintf(&value, \"%u\", y);\n\treturn (value);\n\n}\n\n/* Callback for mouse_status_range. */\nstatic void *\nformat_cb_mouse_status_range(struct format_tree *ft)\n{\n\tstruct style_range\t*sr;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\tif (ft->c == NULL || (~ft->c->tty.flags & TTY_STARTED))\n\t\treturn (NULL);\n\n\tif (ft->m.statusat == 0 && ft->m.y < ft->m.statuslines) {\n\t\tx = ft->m.x;\n\t\ty = ft->m.y;\n\t} else if (ft->m.statusat > 0 && ft->m.y >= (u_int)ft->m.statusat) {\n\t\tx = ft->m.x;\n\t\ty = ft->m.y - ft->m.statusat;\n\t} else\n\t\treturn (NULL);\n\n\tsr = status_get_range(ft->c, x, y);\n\tif (sr == NULL)\n\t\treturn (NULL);\n\tswitch (sr->type) {\n\tcase STYLE_RANGE_NONE:\n\t\treturn (NULL);\n\tcase STYLE_RANGE_LEFT:\n\t\treturn (xstrdup(\"left\"));\n\tcase STYLE_RANGE_RIGHT:\n\t\treturn (xstrdup(\"right\"));\n\tcase STYLE_RANGE_PANE:\n\t\treturn (xstrdup(\"pane\"));\n\tcase STYLE_RANGE_WINDOW:\n\t\treturn (xstrdup(\"window\"));\n\tcase STYLE_RANGE_SESSION:\n\t\treturn (xstrdup(\"session\"));\n\tcase STYLE_RANGE_USER:\n\t\treturn (xstrdup(sr->string));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for alternate_on. */\nstatic void *\nformat_cb_alternate_on(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.saved_grid != NULL)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for alternate_saved_x. */\nstatic void *\nformat_cb_alternate_saved_x(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.saved_cx));\n\treturn (NULL);\n}\n\n/* Callback for alternate_saved_y. */\nstatic void *\nformat_cb_alternate_saved_y(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.saved_cy));\n\treturn (NULL);\n}\n\n/* Callback for buffer_name. */\nstatic void *\nformat_cb_buffer_name(struct format_tree *ft)\n{\n\tif (ft->pb != NULL)\n\t\treturn (xstrdup(paste_buffer_name(ft->pb)));\n\treturn (NULL);\n}\n\n/* Callback for buffer_sample. */\nstatic void *\nformat_cb_buffer_sample(struct format_tree *ft)\n{\n\tif (ft->pb != NULL)\n\t\treturn (paste_make_sample(ft->pb));\n\treturn (NULL);\n}\n\n/* Callback for buffer_size. */\nstatic void *\nformat_cb_buffer_size(struct format_tree *ft)\n{\n\tsize_t\tsize;\n\n\tif (ft->pb != NULL) {\n\t\tpaste_buffer_data(ft->pb, &size);\n\t\treturn (format_printf(\"%zu\", size));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_cell_height. */\nstatic void *\nformat_cb_client_cell_height(struct format_tree *ft)\n{\n\tif (ft->c != NULL && (ft->c->tty.flags & TTY_STARTED))\n\t\treturn (format_printf(\"%u\", ft->c->tty.ypixel));\n\treturn (NULL);\n}\n\n/* Callback for client_cell_width. */\nstatic void *\nformat_cb_client_cell_width(struct format_tree *ft)\n{\n\tif (ft->c != NULL && (ft->c->tty.flags & TTY_STARTED))\n\t\treturn (format_printf(\"%u\", ft->c->tty.xpixel));\n\treturn (NULL);\n}\n\n/* Callback for client_control_mode. */\nstatic void *\nformat_cb_client_control_mode(struct format_tree *ft)\n{\n\tif (ft->c != NULL) {\n\t\tif (ft->c->flags & CLIENT_CONTROL)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_discarded. */\nstatic void *\nformat_cb_client_discarded(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (format_printf(\"%zu\", ft->c->discarded));\n\treturn (NULL);\n}\n\n/* Callback for client_flags. */\nstatic void *\nformat_cb_client_flags(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(server_client_get_flags(ft->c)));\n\treturn (NULL);\n}\n\n/* Callback for client_height. */\nstatic void *\nformat_cb_client_height(struct format_tree *ft)\n{\n\tif (ft->c != NULL && (ft->c->tty.flags & TTY_STARTED))\n\t\treturn (format_printf(\"%u\", ft->c->tty.sy));\n\treturn (NULL);\n}\n\n/* Callback for client_key_table. */\nstatic void *\nformat_cb_client_key_table(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(ft->c->keytable->name));\n\treturn (NULL);\n}\n\n/* Callback for client_last_session. */\nstatic void *\nformat_cb_client_last_session(struct format_tree *ft)\n{\n\tif (ft->c != NULL &&\n\t    ft->c->last_session != NULL &&\n\t    session_alive(ft->c->last_session))\n\t\treturn (xstrdup(ft->c->last_session->name));\n\treturn (NULL);\n}\n\n/* Callback for client_name. */\nstatic void *\nformat_cb_client_name(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(ft->c->name));\n\treturn (NULL);\n}\n\n/* Callback for client_pid. */\nstatic void *\nformat_cb_client_pid(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (format_printf(\"%ld\", (long)ft->c->pid));\n\treturn (NULL);\n}\n\n/* Callback for client_prefix. */\nstatic void *\nformat_cb_client_prefix(struct format_tree *ft)\n{\n\tconst char\t*name;\n\n\tif (ft->c != NULL) {\n\t\tname = server_client_get_key_table(ft->c);\n\t\tif (strcmp(ft->c->keytable->name, name) == 0)\n\t\t\treturn (xstrdup(\"0\"));\n\t\treturn (xstrdup(\"1\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_readonly. */\nstatic void *\nformat_cb_client_readonly(struct format_tree *ft)\n{\n\tif (ft->c != NULL) {\n\t\tif (ft->c->flags & CLIENT_READONLY)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_session. */\nstatic void *\nformat_cb_client_session(struct format_tree *ft)\n{\n\tif (ft->c != NULL && ft->c->session != NULL)\n\t\treturn (xstrdup(ft->c->session->name));\n\treturn (NULL);\n}\n\n/* Callback for client_termfeatures. */\nstatic void *\nformat_cb_client_termfeatures(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(tty_get_features(ft->c->term_features)));\n\treturn (NULL);\n}\n\n/* Callback for client_termname. */\nstatic void *\nformat_cb_client_termname(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(ft->c->term_name));\n\treturn (NULL);\n}\n\n/* Callback for client_termtype. */\nstatic void *\nformat_cb_client_termtype(struct format_tree *ft)\n{\n\tif (ft->c != NULL) {\n\t\tif (ft->c->term_type == NULL)\n\t\t\treturn (xstrdup(\"\"));\n\t\treturn (xstrdup(ft->c->term_type));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_tty. */\nstatic void *\nformat_cb_client_tty(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (xstrdup(ft->c->ttyname));\n\treturn (NULL);\n}\n\n/* Callback for client_uid. */\nstatic void *\nformat_cb_client_uid(struct format_tree *ft)\n{\n\tuid_t\tuid;\n\n\tif (ft->c != NULL) {\n\t\tuid = proc_get_peer_uid(ft->c->peer);\n\t\tif (uid != (uid_t)-1)\n\t\t\treturn (format_printf(\"%ld\", (long)uid));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_user. */\nstatic void *\nformat_cb_client_user(struct format_tree *ft)\n{\n\tuid_t\t\t uid;\n\tstruct passwd\t*pw;\n\n\tif (ft->c != NULL) {\n\t\tuid = proc_get_peer_uid(ft->c->peer);\n\t\tif (uid != (uid_t)-1 && (pw = getpwuid(uid)) != NULL)\n\t\t\treturn (xstrdup(pw->pw_name));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_utf8. */\nstatic void *\nformat_cb_client_utf8(struct format_tree *ft)\n{\n\tif (ft->c != NULL) {\n\t\tif (ft->c->flags & CLIENT_UTF8)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_width. */\nstatic void *\nformat_cb_client_width(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (format_printf(\"%u\", ft->c->tty.sx));\n\treturn (NULL);\n}\n\n/* Callback for client_written. */\nstatic void *\nformat_cb_client_written(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (format_printf(\"%zu\", ft->c->written));\n\treturn (NULL);\n}\n\n/* Callback for config_files. */\nstatic void *\nformat_cb_config_files(__unused struct format_tree *ft)\n{\n\tchar\t*s = NULL;\n\tsize_t\t slen = 0;\n\tu_int\t i;\n\tsize_t\t n;\n\n\tfor (i = 0; i < cfg_nfiles; i++) {\n\t\tn = strlen(cfg_files[i]) + 1;\n\t\ts = xrealloc(s, slen + n + 1);\n\t\tslen += xsnprintf(s + slen, n + 1, \"%s,\", cfg_files[i]);\n\t}\n\tif (s == NULL)\n\t\treturn (xstrdup(\"\"));\n\ts[slen - 1] = '\\0';\n\treturn (s);\n}\n\n/* Callback for cursor_flag. */\nstatic void *\nformat_cb_cursor_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_CURSOR)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for cursor_x. */\nstatic void *\nformat_cb_cursor_x(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.cx));\n\treturn (NULL);\n}\n\n/* Callback for cursor_y. */\nstatic void *\nformat_cb_cursor_y(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.cy));\n\treturn (NULL);\n}\n\n/* Callback for history_limit. */\nstatic void *\nformat_cb_history_limit(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.grid->hlimit));\n\treturn (NULL);\n}\n\n/* Callback for history_size. */\nstatic void *\nformat_cb_history_size(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.grid->hsize));\n\treturn (NULL);\n}\n\n/* Callback for insert_flag. */\nstatic void *\nformat_cb_insert_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_INSERT)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for keypad_cursor_flag. */\nstatic void *\nformat_cb_keypad_cursor_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_KCURSOR)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for keypad_flag. */\nstatic void *\nformat_cb_keypad_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_KKEYPAD)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_all_flag. */\nstatic void *\nformat_cb_mouse_all_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_MOUSE_ALL)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_any_flag. */\nstatic void *\nformat_cb_mouse_any_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & ALL_MOUSE_MODES)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_button_flag. */\nstatic void *\nformat_cb_mouse_button_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_MOUSE_BUTTON)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_pane. */\nstatic void *\nformat_cb_mouse_pane(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\n\tif (ft->m.valid) {\n\t\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\t\tif (wp != NULL)\n\t\t\treturn (format_printf(\"%%%u\", wp->id));\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_sgr_flag. */\nstatic void *\nformat_cb_mouse_sgr_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_MOUSE_SGR)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_standard_flag. */\nstatic void *\nformat_cb_mouse_standard_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_MOUSE_STANDARD)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_utf8_flag. */\nstatic void *\nformat_cb_mouse_utf8_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_MOUSE_UTF8)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_x. */\nstatic void *\nformat_cb_mouse_x(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\tif (wp != NULL && cmd_mouse_at(wp, &ft->m, &x, &y, 0) == 0)\n\t\treturn (format_printf(\"%u\", x));\n\tif (ft->c != NULL && (ft->c->tty.flags & TTY_STARTED)) {\n\t\tif (ft->m.statusat == 0 && ft->m.y < ft->m.statuslines)\n\t\t\treturn (format_printf(\"%u\", ft->m.x));\n\t\tif (ft->m.statusat > 0 && ft->m.y >= (u_int)ft->m.statusat)\n\t\t\treturn (format_printf(\"%u\", ft->m.x));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for mouse_y. */\nstatic void *\nformat_cb_mouse_y(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t x, y;\n\n\tif (!ft->m.valid)\n\t\treturn (NULL);\n\twp = cmd_mouse_pane(&ft->m, NULL, NULL);\n\tif (wp != NULL && cmd_mouse_at(wp, &ft->m, &x, &y, 0) == 0)\n\t\treturn (format_printf(\"%u\", y));\n\tif (ft->c != NULL && (ft->c->tty.flags & TTY_STARTED)) {\n\t\tif (ft->m.statusat == 0 && ft->m.y < ft->m.statuslines)\n\t\t\treturn (format_printf(\"%u\", ft->m.y));\n\t\tif (ft->m.statusat > 0 && ft->m.y >= (u_int)ft->m.statusat)\n\t\t\treturn (format_printf(\"%u\", ft->m.y - ft->m.statusat));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for next_session_id. */\nstatic void *\nformat_cb_next_session_id(__unused struct format_tree *ft)\n{\n\treturn (format_printf(\"$%u\", next_session_id));\n}\n\n/* Callback for origin_flag. */\nstatic void *\nformat_cb_origin_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_ORIGIN)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_active. */\nstatic void *\nformat_cb_pane_active(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp == ft->wp->window->active)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_at_left. */\nstatic void *\nformat_cb_pane_at_left(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->xoff == 0)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_at_right. */\nstatic void *\nformat_cb_pane_at_right(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->xoff + ft->wp->sx == ft->wp->window->sx)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_bottom. */\nstatic void *\nformat_cb_pane_bottom(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->yoff + ft->wp->sy - 1));\n\treturn (NULL);\n}\n\n/* Callback for pane_dead. */\nstatic void *\nformat_cb_pane_dead(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->fd == -1)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_dead_signal. */\nstatic void *\nformat_cb_pane_dead_signal(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tconst char\t\t*name;\n\n\tif (wp != NULL) {\n\t\tif ((wp->flags & PANE_STATUSREADY) && WIFSIGNALED(wp->status)) {\n\t\t\tname = sig2name(WTERMSIG(wp->status));\n\t\t\treturn (format_printf(\"%s\", name));\n\t\t}\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_dead_status. */\nstatic void *\nformat_cb_pane_dead_status(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\n\tif (wp != NULL) {\n\t\tif ((wp->flags & PANE_STATUSREADY) && WIFEXITED(wp->status))\n\t\t\treturn (format_printf(\"%d\", WEXITSTATUS(wp->status)));\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_dead_time. */\nstatic void *\nformat_cb_pane_dead_time(struct format_tree *ft)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\n\tif (wp != NULL) {\n\t\tif (wp->flags & PANE_STATUSDRAWN)\n\t\t\treturn (&wp->dead_time);\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_format. */\nstatic void *\nformat_cb_pane_format(struct format_tree *ft)\n{\n\tif (ft->type == FORMAT_TYPE_PANE)\n\t\treturn (xstrdup(\"1\"));\n\treturn (xstrdup(\"0\"));\n}\n\n/* Callback for pane_height. */\nstatic void *\nformat_cb_pane_height(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->sy));\n\treturn (NULL);\n}\n\n/* Callback for pane_id. */\nstatic void *\nformat_cb_pane_id(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%%%u\", ft->wp->id));\n\treturn (NULL);\n}\n\n/* Callback for pane_index. */\nstatic void *\nformat_cb_pane_index(struct format_tree *ft)\n{\n\tu_int\tidx;\n\n\tif (ft->wp != NULL && window_pane_index(ft->wp, &idx) == 0)\n\t\treturn (format_printf(\"%u\", idx));\n\treturn (NULL);\n}\n\n/* Callback for pane_input_off. */\nstatic void *\nformat_cb_pane_input_off(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->flags & PANE_INPUTOFF)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_unseen_changes. */\nstatic void *\nformat_cb_pane_unseen_changes(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->flags & PANE_UNSEENCHANGES)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_key_mode. */\nstatic void *\nformat_cb_pane_key_mode(struct format_tree *ft)\n{\n\tif (ft->wp != NULL && ft->wp->screen != NULL) {\n\t\tswitch (ft->wp->screen->mode & EXTENDED_KEY_MODES) {\n\t\tcase MODE_KEYS_EXTENDED:\n\t\t\treturn (xstrdup(\"Ext 1\"));\n\t\tcase MODE_KEYS_EXTENDED_2:\n\t\t\treturn (xstrdup(\"Ext 2\"));\n\t\tdefault:\n\t\t\treturn (xstrdup(\"VT10x\"));\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_last. */\nstatic void *\nformat_cb_pane_last(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp == TAILQ_FIRST(&ft->wp->window->last_panes))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_left. */\nstatic void *\nformat_cb_pane_left(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->xoff));\n\treturn (NULL);\n}\n\n/* Callback for pane_marked. */\nstatic void *\nformat_cb_pane_marked(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (server_check_marked() && marked_pane.wp == ft->wp)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_marked_set. */\nstatic void *\nformat_cb_pane_marked_set(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (server_check_marked())\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_mode. */\nstatic void *\nformat_cb_pane_mode(struct format_tree *ft)\n{\n\tstruct window_mode_entry\t*wme;\n\n\tif (ft->wp != NULL) {\n\t\twme = TAILQ_FIRST(&ft->wp->modes);\n\t\tif (wme != NULL)\n\t\t\treturn (xstrdup(wme->mode->name));\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_path. */\nstatic void *\nformat_cb_pane_path(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.path == NULL)\n\t\t\treturn (xstrdup(\"\"));\n\t\treturn (xstrdup(ft->wp->base.path));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_pid. */\nstatic void *\nformat_cb_pane_pid(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%ld\", (long)ft->wp->pid));\n\treturn (NULL);\n}\n\n/* Callback for pane_pipe. */\nstatic void *\nformat_cb_pane_pipe(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->pipe_fd != -1)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_right. */\nstatic void *\nformat_cb_pane_right(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->xoff + ft->wp->sx - 1));\n\treturn (NULL);\n}\n\n/* Callback for pane_search_string. */\nstatic void *\nformat_cb_pane_search_string(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->searchstr == NULL)\n\t\t\treturn (xstrdup(\"\"));\n\t\treturn (xstrdup(ft->wp->searchstr));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_synchronized. */\nstatic void *\nformat_cb_pane_synchronized(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (options_get_number(ft->wp->options, \"synchronize-panes\"))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for pane_title. */\nstatic void *\nformat_cb_pane_title(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (xstrdup(ft->wp->base.title));\n\treturn (NULL);\n}\n\n/* Callback for pane_top. */\nstatic void *\nformat_cb_pane_top(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->yoff));\n\treturn (NULL);\n}\n\n/* Callback for pane_tty. */\nstatic void *\nformat_cb_pane_tty(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (xstrdup(ft->wp->tty));\n\treturn (NULL);\n}\n\n/* Callback for pane_width. */\nstatic void *\nformat_cb_pane_width(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->sx));\n\treturn (NULL);\n}\n\n/* Callback for scroll_region_lower. */\nstatic void *\nformat_cb_scroll_region_lower(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.rlower));\n\treturn (NULL);\n}\n\n/* Callback for scroll_region_upper. */\nstatic void *\nformat_cb_scroll_region_upper(struct format_tree *ft)\n{\n\tif (ft->wp != NULL)\n\t\treturn (format_printf(\"%u\", ft->wp->base.rupper));\n\treturn (NULL);\n}\n\n/* Callback for server_sessions. */\nstatic void *\nformat_cb_server_sessions(__unused struct format_tree *ft)\n{\n\tstruct session\t*s;\n\tu_int\t\t n = 0;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tn++;\n\treturn (format_printf(\"%u\", n));\n}\n\n/* Callback for session_attached. */\nstatic void *\nformat_cb_session_attached(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (format_printf(\"%u\", ft->s->attached));\n\treturn (NULL);\n}\n\n/* Callback for session_format. */\nstatic void *\nformat_cb_session_format(struct format_tree *ft)\n{\n\tif (ft->type == FORMAT_TYPE_SESSION)\n\t\treturn (xstrdup(\"1\"));\n\treturn (xstrdup(\"0\"));\n}\n\n/* Callback for session_group. */\nstatic void *\nformat_cb_session_group(struct format_tree *ft)\n{\n\tstruct session_group\t*sg;\n\n\tif (ft->s != NULL && (sg = session_group_contains(ft->s)) != NULL)\n\t\treturn (xstrdup(sg->name));\n\treturn (NULL);\n}\n\n/* Callback for session_group_attached. */\nstatic void *\nformat_cb_session_group_attached(struct format_tree *ft)\n{\n\tstruct session_group\t*sg;\n\n\tif (ft->s != NULL && (sg = session_group_contains(ft->s)) != NULL)\n\t\treturn (format_printf(\"%u\", session_group_attached_count (sg)));\n\treturn (NULL);\n}\n\n/* Callback for session_group_many_attached. */\nstatic void *\nformat_cb_session_group_many_attached(struct format_tree *ft)\n{\n\tstruct session_group\t*sg;\n\n\tif (ft->s != NULL && (sg = session_group_contains(ft->s)) != NULL) {\n\t\tif (session_group_attached_count (sg) > 1)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for session_group_size. */\nstatic void *\nformat_cb_session_group_size(struct format_tree *ft)\n{\n\tstruct session_group\t*sg;\n\n\tif (ft->s != NULL && (sg = session_group_contains(ft->s)) != NULL)\n\t\treturn (format_printf(\"%u\", session_group_count (sg)));\n\treturn (NULL);\n}\n\n/* Callback for session_grouped. */\nstatic void *\nformat_cb_session_grouped(struct format_tree *ft)\n{\n\tif (ft->s != NULL) {\n\t\tif (session_group_contains(ft->s) != NULL)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for session_id. */\nstatic void *\nformat_cb_session_id(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (format_printf(\"$%u\", ft->s->id));\n\treturn (NULL);\n}\n\n/* Callback for session_many_attached. */\nstatic void *\nformat_cb_session_many_attached(struct format_tree *ft)\n{\n\tif (ft->s != NULL) {\n\t\tif (ft->s->attached > 1)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for session_marked. */\nstatic void *\nformat_cb_session_marked(struct format_tree *ft)\n{\n\tif (ft->s != NULL) {\n\t\tif (server_check_marked() && marked_pane.s == ft->s)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for session_name. */\nstatic void *\nformat_cb_session_name(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (xstrdup(ft->s->name));\n\treturn (NULL);\n}\n\n/* Callback for session_path. */\nstatic void *\nformat_cb_session_path(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (xstrdup(ft->s->cwd));\n\treturn (NULL);\n}\n\n/* Callback for session_windows. */\nstatic void *\nformat_cb_session_windows(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (format_printf(\"%u\", winlink_count(&ft->s->windows)));\n\treturn (NULL);\n}\n\n/* Callback for socket_path. */\nstatic void *\nformat_cb_socket_path(__unused struct format_tree *ft)\n{\n\treturn (xstrdup(socket_path));\n}\n\n/* Callback for version. */\nstatic void *\nformat_cb_version(__unused struct format_tree *ft)\n{\n\treturn (xstrdup(getversion()));\n}\n\n/* Callback for sixel_support. */\nstatic void *\nformat_cb_sixel_support(__unused struct format_tree *ft)\n{\n#ifdef ENABLE_SIXEL\n\treturn (xstrdup(\"1\"));\n#else\n\treturn (xstrdup(\"0\"));\n#endif\n}\n\n/* Callback for active_window_index. */\nstatic void *\nformat_cb_active_window_index(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (format_printf(\"%u\", ft->s->curw->idx));\n\treturn (NULL);\n}\n\n/* Callback for last_window_index. */\nstatic void *\nformat_cb_last_window_index(struct format_tree *ft)\n{\n\tstruct winlink\t*wl;\n\n\tif (ft->s != NULL) {\n\t\twl = RB_MAX(winlinks, &ft->s->windows);\n\t\treturn (format_printf(\"%u\", wl->idx));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_active. */\nstatic void *\nformat_cb_window_active(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl == ft->wl->session->curw)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_activity_flag. */\nstatic void *\nformat_cb_window_activity_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl->flags & WINLINK_ACTIVITY)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_bell_flag. */\nstatic void *\nformat_cb_window_bell_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl->flags & WINLINK_BELL)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_bigger. */\nstatic void *\nformat_cb_window_bigger(struct format_tree *ft)\n{\n\tu_int\tox, oy, sx, sy;\n\n\tif (ft->c != NULL) {\n\t\tif (tty_window_offset(&ft->c->tty, &ox, &oy, &sx, &sy))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_cell_height. */\nstatic void *\nformat_cb_window_cell_height(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%u\", ft->w->ypixel));\n\treturn (NULL);\n}\n\n/* Callback for window_cell_width. */\nstatic void *\nformat_cb_window_cell_width(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%u\", ft->w->xpixel));\n\treturn (NULL);\n}\n\n/* Callback for window_end_flag. */\nstatic void *\nformat_cb_window_end_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl == RB_MAX(winlinks, &ft->wl->session->windows))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_flags. */\nstatic void *\nformat_cb_window_flags(struct format_tree *ft)\n{\n\tif (ft->wl != NULL)\n\t\treturn (xstrdup(window_printable_flags(ft->wl, 1)));\n\treturn (NULL);\n}\n\n/* Callback for window_format. */\nstatic void *\nformat_cb_window_format(struct format_tree *ft)\n{\n\tif (ft->type == FORMAT_TYPE_WINDOW)\n\t\treturn (xstrdup(\"1\"));\n\treturn (xstrdup(\"0\"));\n}\n\n/* Callback for window_height. */\nstatic void *\nformat_cb_window_height(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%u\", ft->w->sy));\n\treturn (NULL);\n}\n\n/* Callback for window_id. */\nstatic void *\nformat_cb_window_id(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"@%u\", ft->w->id));\n\treturn (NULL);\n}\n\n/* Callback for window_index. */\nstatic void *\nformat_cb_window_index(struct format_tree *ft)\n{\n\tif (ft->wl != NULL)\n\t\treturn (format_printf(\"%d\", ft->wl->idx));\n\treturn (NULL);\n}\n\n/* Callback for window_last_flag. */\nstatic void *\nformat_cb_window_last_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl == TAILQ_FIRST(&ft->wl->session->lastw))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_linked. */\nstatic void *\nformat_cb_window_linked(struct format_tree *ft)\n{\n\tstruct winlink\t*wl;\n\tstruct session\t*s;\n\tint\t\t found = 0;\n\n\tif (ft->wl != NULL) {\n\t\tRB_FOREACH(s, sessions, &sessions) {\n\t\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\t\tif (wl->window == ft->wl->window) {\n\t\t\t\t\tif (found)\n\t\t\t\t\t\treturn (xstrdup(\"1\"));\n\t\t\t\t\tfound = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_linked_sessions. */\nstatic void *\nformat_cb_window_linked_sessions(struct format_tree *ft)\n{\n\tstruct window\t\t*w;\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s;\n\tu_int\t\t\t n = 0;\n\n\tif (ft->wl == NULL)\n\t\treturn (NULL);\n\tw = ft->wl->window;\n\n\tRB_FOREACH(sg, session_groups, &session_groups) {\n\t\ts = TAILQ_FIRST(&sg->sessions);\n\t\tif (winlink_find_by_window(&s->windows, w) != NULL)\n\t\t\tn++;\n\t}\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (session_group_contains(s) != NULL)\n\t\t\tcontinue;\n\t\tif (winlink_find_by_window(&s->windows, w) != NULL)\n\t\t\tn++;\n\t}\n\treturn (format_printf(\"%u\", n));\n}\n\n/* Callback for window_marked_flag. */\nstatic void *\nformat_cb_window_marked_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (server_check_marked() && marked_pane.wl == ft->wl)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_name. */\nstatic void *\nformat_cb_window_name(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%s\", ft->w->name));\n\treturn (NULL);\n}\n\n/* Callback for window_offset_x. */\nstatic void *\nformat_cb_window_offset_x(struct format_tree *ft)\n{\n\tu_int\tox, oy, sx, sy;\n\n\tif (ft->c != NULL) {\n\t\tif (tty_window_offset(&ft->c->tty, &ox, &oy, &sx, &sy))\n\t\t\treturn (format_printf(\"%u\", ox));\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_offset_y. */\nstatic void *\nformat_cb_window_offset_y(struct format_tree *ft)\n{\n\tu_int\tox, oy, sx, sy;\n\n\tif (ft->c != NULL) {\n\t\tif (tty_window_offset(&ft->c->tty, &ox, &oy, &sx, &sy))\n\t\t\treturn (format_printf(\"%u\", oy));\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_panes. */\nstatic void *\nformat_cb_window_panes(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%u\", window_count_panes(ft->w)));\n\treturn (NULL);\n}\n\n/* Callback for window_raw_flags. */\nstatic void *\nformat_cb_window_raw_flags(struct format_tree *ft)\n{\n\tif (ft->wl != NULL)\n\t\treturn (xstrdup(window_printable_flags(ft->wl, 0)));\n\treturn (NULL);\n}\n\n/* Callback for window_silence_flag. */\nstatic void *\nformat_cb_window_silence_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl->flags & WINLINK_SILENCE)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_start_flag. */\nstatic void *\nformat_cb_window_start_flag(struct format_tree *ft)\n{\n\tif (ft->wl != NULL) {\n\t\tif (ft->wl == RB_MIN(winlinks, &ft->wl->session->windows))\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for window_width. */\nstatic void *\nformat_cb_window_width(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (format_printf(\"%u\", ft->w->sx));\n\treturn (NULL);\n}\n\n/* Callback for window_zoomed_flag. */\nstatic void *\nformat_cb_window_zoomed_flag(struct format_tree *ft)\n{\n\tif (ft->w != NULL) {\n\t\tif (ft->w->flags & WINDOW_ZOOMED)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for wrap_flag. */\nstatic void *\nformat_cb_wrap_flag(struct format_tree *ft)\n{\n\tif (ft->wp != NULL) {\n\t\tif (ft->wp->base.mode & MODE_WRAP)\n\t\t\treturn (xstrdup(\"1\"));\n\t\treturn (xstrdup(\"0\"));\n\t}\n\treturn (NULL);\n}\n\n/* Callback for buffer_created. */\nstatic void *\nformat_cb_buffer_created(struct format_tree *ft)\n{\n\tstatic struct timeval\t tv;\n\n\tif (ft->pb != NULL) {\n\t\ttimerclear(&tv);\n\t\ttv.tv_sec = paste_buffer_created(ft->pb);\n\t\treturn (&tv);\n\t}\n\treturn (NULL);\n}\n\n/* Callback for client_activity. */\nstatic void *\nformat_cb_client_activity(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (&ft->c->activity_time);\n\treturn (NULL);\n}\n\n/* Callback for client_created. */\nstatic void *\nformat_cb_client_created(struct format_tree *ft)\n{\n\tif (ft->c != NULL)\n\t\treturn (&ft->c->creation_time);\n\treturn (NULL);\n}\n\n/* Callback for session_activity. */\nstatic void *\nformat_cb_session_activity(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (&ft->s->activity_time);\n\treturn (NULL);\n}\n\n/* Callback for session_created. */\nstatic void *\nformat_cb_session_created(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (&ft->s->creation_time);\n\treturn (NULL);\n}\n\n/* Callback for session_last_attached. */\nstatic void *\nformat_cb_session_last_attached(struct format_tree *ft)\n{\n\tif (ft->s != NULL)\n\t\treturn (&ft->s->last_attached_time);\n\treturn (NULL);\n}\n\n/* Callback for start_time. */\nstatic void *\nformat_cb_start_time(__unused struct format_tree *ft)\n{\n\treturn (&start_time);\n}\n\n/* Callback for window_activity. */\nstatic void *\nformat_cb_window_activity(struct format_tree *ft)\n{\n\tif (ft->w != NULL)\n\t\treturn (&ft->w->activity_time);\n\treturn (NULL);\n}\n\n/* Callback for buffer_mode_format, */\nstatic void *\nformat_cb_buffer_mode_format(__unused struct format_tree *ft)\n{\n\treturn (xstrdup(window_buffer_mode.default_format));\n}\n\n/* Callback for client_mode_format, */\nstatic void *\nformat_cb_client_mode_format(__unused struct format_tree *ft)\n{\n\treturn (xstrdup(window_client_mode.default_format));\n}\n\n/* Callback for tree_mode_format, */\nstatic void *\nformat_cb_tree_mode_format(__unused struct format_tree *ft)\n{\n\treturn (xstrdup(window_tree_mode.default_format));\n}\n\n/* Callback for uid. */\nstatic void *\nformat_cb_uid(__unused struct format_tree *ft)\n{\n\treturn (format_printf(\"%ld\", (long)getuid()));\n}\n\n/* Callback for user. */\nstatic void *\nformat_cb_user(__unused struct format_tree *ft)\n{\n\tstruct passwd\t*pw;\n\n\tif ((pw = getpwuid(getuid())) != NULL)\n\t\treturn (xstrdup(pw->pw_name));\n\treturn (NULL);\n}\n\n/* Format table type. */\nenum format_table_type {\n\tFORMAT_TABLE_STRING,\n\tFORMAT_TABLE_TIME\n};\n\n/* Format table entry. */\nstruct format_table_entry {\n\tconst char\t\t*key;\n\tenum format_table_type\t type;\n\tformat_cb\t\t cb;\n};\n\n/*\n * Format table. Default format variables (that are almost always in the tree\n * and where the value is expanded by a callback in this file) are listed here.\n * Only variables which are added by the caller go into the tree.\n */\nstatic const struct format_table_entry format_table[] = {\n\t{ \"active_window_index\", FORMAT_TABLE_STRING,\n\t  format_cb_active_window_index\n\t},\n\t{ \"alternate_on\", FORMAT_TABLE_STRING,\n\t  format_cb_alternate_on\n\t},\n\t{ \"alternate_saved_x\", FORMAT_TABLE_STRING,\n\t  format_cb_alternate_saved_x\n\t},\n\t{ \"alternate_saved_y\", FORMAT_TABLE_STRING,\n\t  format_cb_alternate_saved_y\n\t},\n\t{ \"buffer_created\", FORMAT_TABLE_TIME,\n\t  format_cb_buffer_created\n\t},\n\t{ \"buffer_mode_format\", FORMAT_TABLE_STRING,\n\t  format_cb_buffer_mode_format\n\t},\n\t{ \"buffer_name\", FORMAT_TABLE_STRING,\n\t  format_cb_buffer_name\n\t},\n\t{ \"buffer_sample\", FORMAT_TABLE_STRING,\n\t  format_cb_buffer_sample\n\t},\n\t{ \"buffer_size\", FORMAT_TABLE_STRING,\n\t  format_cb_buffer_size\n\t},\n\t{ \"client_activity\", FORMAT_TABLE_TIME,\n\t  format_cb_client_activity\n\t},\n\t{ \"client_cell_height\", FORMAT_TABLE_STRING,\n\t  format_cb_client_cell_height\n\t},\n\t{ \"client_cell_width\", FORMAT_TABLE_STRING,\n\t  format_cb_client_cell_width\n\t},\n\t{ \"client_control_mode\", FORMAT_TABLE_STRING,\n\t  format_cb_client_control_mode\n\t},\n\t{ \"client_created\", FORMAT_TABLE_TIME,\n\t  format_cb_client_created\n\t},\n\t{ \"client_discarded\", FORMAT_TABLE_STRING,\n\t  format_cb_client_discarded\n\t},\n\t{ \"client_flags\", FORMAT_TABLE_STRING,\n\t  format_cb_client_flags\n\t},\n\t{ \"client_height\", FORMAT_TABLE_STRING,\n\t  format_cb_client_height\n\t},\n\t{ \"client_key_table\", FORMAT_TABLE_STRING,\n\t  format_cb_client_key_table\n\t},\n\t{ \"client_last_session\", FORMAT_TABLE_STRING,\n\t  format_cb_client_last_session\n\t},\n\t{ \"client_mode_format\", FORMAT_TABLE_STRING,\n\t  format_cb_client_mode_format\n\t},\n\t{ \"client_name\", FORMAT_TABLE_STRING,\n\t  format_cb_client_name\n\t},\n\t{ \"client_pid\", FORMAT_TABLE_STRING,\n\t  format_cb_client_pid\n\t},\n\t{ \"client_prefix\", FORMAT_TABLE_STRING,\n\t  format_cb_client_prefix\n\t},\n\t{ \"client_readonly\", FORMAT_TABLE_STRING,\n\t  format_cb_client_readonly\n\t},\n\t{ \"client_session\", FORMAT_TABLE_STRING,\n\t  format_cb_client_session\n\t},\n\t{ \"client_termfeatures\", FORMAT_TABLE_STRING,\n\t  format_cb_client_termfeatures\n\t},\n\t{ \"client_termname\", FORMAT_TABLE_STRING,\n\t  format_cb_client_termname\n\t},\n\t{ \"client_termtype\", FORMAT_TABLE_STRING,\n\t  format_cb_client_termtype\n\t},\n\t{ \"client_tty\", FORMAT_TABLE_STRING,\n\t  format_cb_client_tty\n\t},\n\t{ \"client_uid\", FORMAT_TABLE_STRING,\n\t  format_cb_client_uid\n\t},\n\t{ \"client_user\", FORMAT_TABLE_STRING,\n\t  format_cb_client_user\n\t},\n\t{ \"client_utf8\", FORMAT_TABLE_STRING,\n\t  format_cb_client_utf8\n\t},\n\t{ \"client_width\", FORMAT_TABLE_STRING,\n\t  format_cb_client_width\n\t},\n\t{ \"client_written\", FORMAT_TABLE_STRING,\n\t  format_cb_client_written\n\t},\n\t{ \"config_files\", FORMAT_TABLE_STRING,\n\t  format_cb_config_files\n\t},\n\t{ \"cursor_character\", FORMAT_TABLE_STRING,\n\t  format_cb_cursor_character\n\t},\n\t{ \"cursor_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_cursor_flag\n\t},\n\t{ \"cursor_x\", FORMAT_TABLE_STRING,\n\t  format_cb_cursor_x\n\t},\n\t{ \"cursor_y\", FORMAT_TABLE_STRING,\n\t  format_cb_cursor_y\n\t},\n\t{ \"history_all_bytes\", FORMAT_TABLE_STRING,\n\t  format_cb_history_all_bytes\n\t},\n\t{ \"history_bytes\", FORMAT_TABLE_STRING,\n\t  format_cb_history_bytes\n\t},\n\t{ \"history_limit\", FORMAT_TABLE_STRING,\n\t  format_cb_history_limit\n\t},\n\t{ \"history_size\", FORMAT_TABLE_STRING,\n\t  format_cb_history_size\n\t},\n\t{ \"host\", FORMAT_TABLE_STRING,\n\t  format_cb_host\n\t},\n\t{ \"host_short\", FORMAT_TABLE_STRING,\n\t  format_cb_host_short\n\t},\n\t{ \"insert_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_insert_flag\n\t},\n\t{ \"keypad_cursor_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_keypad_cursor_flag\n\t},\n\t{ \"keypad_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_keypad_flag\n\t},\n\t{ \"last_window_index\", FORMAT_TABLE_STRING,\n\t  format_cb_last_window_index\n\t},\n\t{ \"mouse_all_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_all_flag\n\t},\n\t{ \"mouse_any_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_any_flag\n\t},\n\t{ \"mouse_button_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_button_flag\n\t},\n\t{ \"mouse_hyperlink\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_hyperlink\n\t},\n\t{ \"mouse_line\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_line\n\t},\n\t{ \"mouse_pane\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_pane\n\t},\n\t{ \"mouse_sgr_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_sgr_flag\n\t},\n\t{ \"mouse_standard_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_standard_flag\n\t},\n\t{ \"mouse_status_line\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_status_line\n\t},\n\t{ \"mouse_status_range\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_status_range\n\t},\n\t{ \"mouse_utf8_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_utf8_flag\n\t},\n\t{ \"mouse_word\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_word\n\t},\n\t{ \"mouse_x\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_x\n\t},\n\t{ \"mouse_y\", FORMAT_TABLE_STRING,\n\t  format_cb_mouse_y\n\t},\n\t{ \"next_session_id\", FORMAT_TABLE_STRING,\n\t  format_cb_next_session_id\n\t},\n\t{ \"origin_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_origin_flag\n\t},\n\t{ \"pane_active\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_active\n\t},\n\t{ \"pane_at_bottom\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_at_bottom\n\t},\n\t{ \"pane_at_left\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_at_left\n\t},\n\t{ \"pane_at_right\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_at_right\n\t},\n\t{ \"pane_at_top\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_at_top\n\t},\n\t{ \"pane_bg\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_bg\n\t},\n\t{ \"pane_bottom\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_bottom\n\t},\n\t{ \"pane_current_command\", FORMAT_TABLE_STRING,\n\t  format_cb_current_command\n\t},\n\t{ \"pane_current_path\", FORMAT_TABLE_STRING,\n\t  format_cb_current_path\n\t},\n\t{ \"pane_dead\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_dead\n\t},\n\t{ \"pane_dead_signal\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_dead_signal\n\t},\n\t{ \"pane_dead_status\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_dead_status\n\t},\n\t{ \"pane_dead_time\", FORMAT_TABLE_TIME,\n\t  format_cb_pane_dead_time\n\t},\n\t{ \"pane_fg\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_fg\n\t},\n\t{ \"pane_format\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_format\n\t},\n\t{ \"pane_height\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_height\n\t},\n\t{ \"pane_id\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_id\n\t},\n\t{ \"pane_in_mode\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_in_mode\n\t},\n\t{ \"pane_index\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_index\n\t},\n\t{ \"pane_input_off\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_input_off\n\t},\n\t{ \"pane_key_mode\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_key_mode\n\t},\n\t{ \"pane_last\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_last\n\t},\n\t{ \"pane_left\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_left\n\t},\n\t{ \"pane_marked\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_marked\n\t},\n\t{ \"pane_marked_set\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_marked_set\n\t},\n\t{ \"pane_mode\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_mode\n\t},\n\t{ \"pane_path\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_path\n\t},\n\t{ \"pane_pid\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_pid\n\t},\n\t{ \"pane_pipe\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_pipe\n\t},\n\t{ \"pane_right\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_right\n\t},\n\t{ \"pane_search_string\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_search_string\n\t},\n\t{ \"pane_start_command\", FORMAT_TABLE_STRING,\n\t  format_cb_start_command\n\t},\n\t{ \"pane_start_path\", FORMAT_TABLE_STRING,\n\t  format_cb_start_path\n\t},\n\t{ \"pane_synchronized\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_synchronized\n\t},\n\t{ \"pane_tabs\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_tabs\n\t},\n\t{ \"pane_title\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_title\n\t},\n\t{ \"pane_top\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_top\n\t},\n\t{ \"pane_tty\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_tty\n\t},\n\t{ \"pane_unseen_changes\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_unseen_changes\n\t},\n\t{ \"pane_width\", FORMAT_TABLE_STRING,\n\t  format_cb_pane_width\n\t},\n\t{ \"pid\", FORMAT_TABLE_STRING,\n\t  format_cb_pid\n\t},\n\t{ \"scroll_region_lower\", FORMAT_TABLE_STRING,\n\t  format_cb_scroll_region_lower\n\t},\n\t{ \"scroll_region_upper\", FORMAT_TABLE_STRING,\n\t  format_cb_scroll_region_upper\n\t},\n\t{ \"server_sessions\", FORMAT_TABLE_STRING,\n\t  format_cb_server_sessions\n\t},\n\t{ \"session_activity\", FORMAT_TABLE_TIME,\n\t  format_cb_session_activity\n\t},\n\t{ \"session_alerts\", FORMAT_TABLE_STRING,\n\t  format_cb_session_alerts\n\t},\n\t{ \"session_attached\", FORMAT_TABLE_STRING,\n\t  format_cb_session_attached\n\t},\n\t{ \"session_attached_list\", FORMAT_TABLE_STRING,\n\t  format_cb_session_attached_list\n\t},\n\t{ \"session_created\", FORMAT_TABLE_TIME,\n\t  format_cb_session_created\n\t},\n\t{ \"session_format\", FORMAT_TABLE_STRING,\n\t  format_cb_session_format\n\t},\n\t{ \"session_group\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group\n\t},\n\t{ \"session_group_attached\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group_attached\n\t},\n\t{ \"session_group_attached_list\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group_attached_list\n\t},\n\t{ \"session_group_list\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group_list\n\t},\n\t{ \"session_group_many_attached\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group_many_attached\n\t},\n\t{ \"session_group_size\", FORMAT_TABLE_STRING,\n\t  format_cb_session_group_size\n\t},\n\t{ \"session_grouped\", FORMAT_TABLE_STRING,\n\t  format_cb_session_grouped\n\t},\n\t{ \"session_id\", FORMAT_TABLE_STRING,\n\t  format_cb_session_id\n\t},\n\t{ \"session_last_attached\", FORMAT_TABLE_TIME,\n\t  format_cb_session_last_attached\n\t},\n\t{ \"session_many_attached\", FORMAT_TABLE_STRING,\n\t  format_cb_session_many_attached\n\t},\n\t{ \"session_marked\", FORMAT_TABLE_STRING,\n\t  format_cb_session_marked,\n\t},\n\t{ \"session_name\", FORMAT_TABLE_STRING,\n\t  format_cb_session_name\n\t},\n\t{ \"session_path\", FORMAT_TABLE_STRING,\n\t  format_cb_session_path\n\t},\n\t{ \"session_stack\", FORMAT_TABLE_STRING,\n\t  format_cb_session_stack\n\t},\n\t{ \"session_windows\", FORMAT_TABLE_STRING,\n\t  format_cb_session_windows\n\t},\n\t{ \"sixel_support\", FORMAT_TABLE_STRING,\n\t  format_cb_sixel_support\n\t},\n\t{ \"socket_path\", FORMAT_TABLE_STRING,\n\t  format_cb_socket_path\n\t},\n\t{ \"start_time\", FORMAT_TABLE_TIME,\n\t  format_cb_start_time\n\t},\n\t{ \"tree_mode_format\", FORMAT_TABLE_STRING,\n\t  format_cb_tree_mode_format\n\t},\n\t{ \"uid\", FORMAT_TABLE_STRING,\n\t  format_cb_uid\n\t},\n\t{ \"user\", FORMAT_TABLE_STRING,\n\t  format_cb_user\n\t},\n\t{ \"version\", FORMAT_TABLE_STRING,\n\t  format_cb_version\n\t},\n\t{ \"window_active\", FORMAT_TABLE_STRING,\n\t  format_cb_window_active\n\t},\n\t{ \"window_active_clients\", FORMAT_TABLE_STRING,\n\t  format_cb_window_active_clients\n\t},\n\t{ \"window_active_clients_list\", FORMAT_TABLE_STRING,\n\t  format_cb_window_active_clients_list\n\t},\n\t{ \"window_active_sessions\", FORMAT_TABLE_STRING,\n\t  format_cb_window_active_sessions\n\t},\n\t{ \"window_active_sessions_list\", FORMAT_TABLE_STRING,\n\t  format_cb_window_active_sessions_list\n\t},\n\t{ \"window_activity\", FORMAT_TABLE_TIME,\n\t  format_cb_window_activity\n\t},\n\t{ \"window_activity_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_activity_flag\n\t},\n\t{ \"window_bell_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_bell_flag\n\t},\n\t{ \"window_bigger\", FORMAT_TABLE_STRING,\n\t  format_cb_window_bigger\n\t},\n\t{ \"window_cell_height\", FORMAT_TABLE_STRING,\n\t  format_cb_window_cell_height\n\t},\n\t{ \"window_cell_width\", FORMAT_TABLE_STRING,\n\t  format_cb_window_cell_width\n\t},\n\t{ \"window_end_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_end_flag\n\t},\n\t{ \"window_flags\", FORMAT_TABLE_STRING,\n\t  format_cb_window_flags\n\t},\n\t{ \"window_format\", FORMAT_TABLE_STRING,\n\t  format_cb_window_format\n\t},\n\t{ \"window_height\", FORMAT_TABLE_STRING,\n\t  format_cb_window_height\n\t},\n\t{ \"window_id\", FORMAT_TABLE_STRING,\n\t  format_cb_window_id\n\t},\n\t{ \"window_index\", FORMAT_TABLE_STRING,\n\t  format_cb_window_index\n\t},\n\t{ \"window_last_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_last_flag\n\t},\n\t{ \"window_layout\", FORMAT_TABLE_STRING,\n\t  format_cb_window_layout\n\t},\n\t{ \"window_linked\", FORMAT_TABLE_STRING,\n\t  format_cb_window_linked\n\t},\n\t{ \"window_linked_sessions\", FORMAT_TABLE_STRING,\n\t  format_cb_window_linked_sessions\n\t},\n\t{ \"window_linked_sessions_list\", FORMAT_TABLE_STRING,\n\t  format_cb_window_linked_sessions_list\n\t},\n\t{ \"window_marked_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_marked_flag\n\t},\n\t{ \"window_name\", FORMAT_TABLE_STRING,\n\t  format_cb_window_name\n\t},\n\t{ \"window_offset_x\", FORMAT_TABLE_STRING,\n\t  format_cb_window_offset_x\n\t},\n\t{ \"window_offset_y\", FORMAT_TABLE_STRING,\n\t  format_cb_window_offset_y\n\t},\n\t{ \"window_panes\", FORMAT_TABLE_STRING,\n\t  format_cb_window_panes\n\t},\n\t{ \"window_raw_flags\", FORMAT_TABLE_STRING,\n\t  format_cb_window_raw_flags\n\t},\n\t{ \"window_silence_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_silence_flag\n\t},\n\t{ \"window_stack_index\", FORMAT_TABLE_STRING,\n\t  format_cb_window_stack_index\n\t},\n\t{ \"window_start_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_start_flag\n\t},\n\t{ \"window_visible_layout\", FORMAT_TABLE_STRING,\n\t  format_cb_window_visible_layout\n\t},\n\t{ \"window_width\", FORMAT_TABLE_STRING,\n\t  format_cb_window_width\n\t},\n\t{ \"window_zoomed_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_window_zoomed_flag\n\t},\n\t{ \"wrap_flag\", FORMAT_TABLE_STRING,\n\t  format_cb_wrap_flag\n\t}\n};\n\n/* Compare format table entries. */\nstatic int\nformat_table_compare(const void *key0, const void *entry0)\n{\n\tconst char\t\t\t*key = key0;\n\tconst struct format_table_entry\t*entry = entry0;\n\n\treturn (strcmp(key, entry->key));\n}\n\n/* Get a format callback. */\nstatic struct format_table_entry *\nformat_table_get(const char *key)\n{\n\treturn (bsearch(key, format_table, nitems(format_table),\n\t    sizeof *format_table, format_table_compare));\n}\n\n/* Merge one format tree into another. */\nvoid\nformat_merge(struct format_tree *ft, struct format_tree *from)\n{\n\tstruct format_entry\t*fe;\n\n\tRB_FOREACH(fe, format_entry_tree, &from->tree) {\n\t\tif (fe->value != NULL)\n\t\t\tformat_add(ft, fe->key, \"%s\", fe->value);\n\t}\n}\n\n/* Get format pane. */\nstruct window_pane *\nformat_get_pane(struct format_tree *ft)\n{\n\treturn (ft->wp);\n}\n\n/* Add item bits to tree. */\nstatic void\nformat_create_add_item(struct format_tree *ft, struct cmdq_item *item)\n{\n\tstruct key_event\t*event = cmdq_get_event(item);\n\tstruct mouse_event\t*m = &event->m;\n\n\tcmdq_merge_formats(item, ft);\n\tmemcpy(&ft->m, m, sizeof ft->m);\n}\n\n/* Create a new tree. */\nstruct format_tree *\nformat_create(struct client *c, struct cmdq_item *item, int tag, int flags)\n{\n\tstruct format_tree\t*ft;\n\n\tft = xcalloc(1, sizeof *ft);\n\tRB_INIT(&ft->tree);\n\n\tif (c != NULL) {\n\t\tft->client = c;\n\t\tft->client->references++;\n\t}\n\tft->item = item;\n\n\tft->tag = tag;\n\tft->flags = flags;\n\n\tif (item != NULL)\n\t\tformat_create_add_item(ft, item);\n\n\treturn (ft);\n}\n\n/* Free a tree. */\nvoid\nformat_free(struct format_tree *ft)\n{\n\tstruct format_entry\t*fe, *fe1;\n\n\tRB_FOREACH_SAFE(fe, format_entry_tree, &ft->tree, fe1) {\n\t\tRB_REMOVE(format_entry_tree, &ft->tree, fe);\n\t\tfree(fe->value);\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t}\n\n\tif (ft->client != NULL)\n\t\tserver_client_unref(ft->client);\n\tfree(ft);\n}\n\n/* Log each format. */\nstatic void\nformat_log_debug_cb(const char *key, const char *value, void *arg)\n{\n\tconst char\t*prefix = arg;\n\n\tlog_debug(\"%s: %s=%s\", prefix, key, value);\n}\n\n/* Log a format tree. */\nvoid\nformat_log_debug(struct format_tree *ft, const char *prefix)\n{\n\tformat_each(ft, format_log_debug_cb, (void *)prefix);\n}\n\n/* Walk each format. */\nvoid\nformat_each(struct format_tree *ft, void (*cb)(const char *, const char *,\n    void *), void *arg)\n{\n\tconst struct format_table_entry\t*fte;\n\tstruct format_entry\t\t*fe;\n\tu_int\t\t\t\t i;\n\tchar\t\t\t\t s[64];\n\tvoid\t\t\t\t*value;\n\tstruct timeval\t\t\t*tv;\n\n\tfor (i = 0; i < nitems(format_table); i++) {\n\t\tfte = &format_table[i];\n\n\t\tvalue = fte->cb(ft);\n\t\tif (value == NULL)\n\t\t\tcontinue;\n\t\tif (fte->type == FORMAT_TABLE_TIME) {\n\t\t\ttv = value;\n\t\t\txsnprintf(s, sizeof s, \"%lld\", (long long)tv->tv_sec);\n\t\t\tcb(fte->key, s, arg);\n\t\t} else {\n\t\t\tcb(fte->key, value, arg);\n\t\t\tfree(value);\n\t\t}\n\t}\n\tRB_FOREACH(fe, format_entry_tree, &ft->tree) {\n\t\tif (fe->time != 0) {\n\t\t\txsnprintf(s, sizeof s, \"%lld\", (long long)fe->time);\n\t\t\tcb(fe->key, s, arg);\n\t\t} else {\n\t\t\tif (fe->value == NULL && fe->cb != NULL) {\n\t\t\t\tfe->value = fe->cb(ft);\n\t\t\t\tif (fe->value == NULL)\n\t\t\t\t\tfe->value = xstrdup(\"\");\n\t\t\t}\n\t\t\tcb(fe->key, fe->value, arg);\n\t\t}\n\t}\n}\n\n/* Add a key-value pair. */\nvoid\nformat_add(struct format_tree *ft, const char *key, const char *fmt, ...)\n{\n\tstruct format_entry\t*fe;\n\tstruct format_entry\t*fe_now;\n\tva_list\t\t\t ap;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = NULL;\n\tfe->time = 0;\n\n\tva_start(ap, fmt);\n\txvasprintf(&fe->value, fmt, ap);\n\tva_end(ap);\n}\n\n/* Add a key and time. */\nvoid\nformat_add_tv(struct format_tree *ft, const char *key, struct timeval *tv)\n{\n\tstruct format_entry\t*fe, *fe_now;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = NULL;\n\tfe->time = tv->tv_sec;\n\n\tfe->value = NULL;\n}\n\n/* Add a key and function. */\nvoid\nformat_add_cb(struct format_tree *ft, const char *key, format_cb cb)\n{\n\tstruct format_entry\t*fe;\n\tstruct format_entry\t*fe_now;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = cb;\n\tfe->time = 0;\n\n\tfe->value = NULL;\n}\n\n/* Quote shell special characters in string. */\nstatic char *\nformat_quote_shell(const char *s)\n{\n\tconst char\t*cp;\n\tchar\t\t*out, *at;\n\n\tat = out = xmalloc(strlen(s) * 2 + 1);\n\tfor (cp = s; *cp != '\\0'; cp++) {\n\t\tif (strchr(\"|&;<>()$`\\\\\\\"'*?[# =%\", *cp) != NULL)\n\t\t\t*at++ = '\\\\';\n\t\t*at++ = *cp;\n\t}\n\t*at = '\\0';\n\treturn (out);\n}\n\n/* Quote #s in string. */\nstatic char *\nformat_quote_style(const char *s)\n{\n\tconst char\t*cp;\n\tchar\t\t*out, *at;\n\n\tat = out = xmalloc(strlen(s) * 2 + 1);\n\tfor (cp = s; *cp != '\\0'; cp++) {\n\t\tif (*cp == '#')\n\t\t\t*at++ = '#';\n\t\t*at++ = *cp;\n\t}\n\t*at = '\\0';\n\treturn (out);\n}\n\n/* Make a prettier time. */\nchar *\nformat_pretty_time(time_t t, int seconds)\n{\n\tstruct tm       now_tm, tm;\n\ttime_t\t\tnow, age;\n\tchar\t\ts[9];\n\n\ttime(&now);\n\tif (now < t)\n\t\tnow = t;\n\tage = now - t;\n\n\tlocaltime_r(&now, &now_tm);\n\tlocaltime_r(&t, &tm);\n\n\t/* Last 24 hours. */\n\tif (age < 24 * 3600) {\n\t\tif (seconds)\n\t\t\tstrftime(s, sizeof s, \"%H:%M:%S\", &tm);\n\t\telse\n\t\t\tstrftime(s, sizeof s, \"%H:%M\", &tm);\n\t\treturn (xstrdup(s));\n\t}\n\n\t/* This month or last 28 days. */\n\tif ((tm.tm_year == now_tm.tm_year && tm.tm_mon == now_tm.tm_mon) ||\n\t    age < 28 * 24 * 3600) {\n\t\tstrftime(s, sizeof s, \"%a%d\", &tm);\n\t\treturn (xstrdup(s));\n\t}\n\n\t/* Last 12 months. */\n\tif ((tm.tm_year == now_tm.tm_year && tm.tm_mon < now_tm.tm_mon) ||\n\t    (tm.tm_year == now_tm.tm_year - 1 && tm.tm_mon > now_tm.tm_mon)) {\n\t\tstrftime(s, sizeof s, \"%d%b\", &tm);\n\t\treturn (xstrdup(s));\n\t}\n\n\t/* Older than that. */\n\tstrftime(s, sizeof s, \"%h%y\", &tm);\n\treturn (xstrdup(s));\n}\n\n/* Find a format entry. */\nstatic char *\nformat_find(struct format_tree *ft, const char *key, int modifiers,\n    const char *time_format)\n{\n\tstruct format_table_entry\t*fte;\n\tvoid\t\t\t\t*value;\n\tstruct format_entry\t\t*fe, fe_find;\n\tstruct environ_entry\t\t*envent;\n\tstruct options_entry\t\t*o;\n\tint\t\t\t\t idx;\n\tchar\t\t\t\t*found = NULL, *saved, s[512];\n\tconst char\t\t\t*errstr;\n\ttime_t\t\t\t\t t = 0;\n\tstruct tm\t\t\t tm;\n\n\to = options_parse_get(global_options, key, &idx, 0);\n\tif (o == NULL && ft->wp != NULL)\n\t\to = options_parse_get(ft->wp->options, key, &idx, 0);\n\tif (o == NULL && ft->w != NULL)\n\t\to = options_parse_get(ft->w->options, key, &idx, 0);\n\tif (o == NULL)\n\t\to = options_parse_get(global_w_options, key, &idx, 0);\n\tif (o == NULL && ft->s != NULL)\n\t\to = options_parse_get(ft->s->options, key, &idx, 0);\n\tif (o == NULL)\n\t\to = options_parse_get(global_s_options, key, &idx, 0);\n\tif (o != NULL) {\n\t\tfound = options_to_string(o, idx, 1);\n\t\tgoto found;\n\t}\n\n\tfte = format_table_get(key);\n\tif (fte != NULL) {\n\t\tvalue = fte->cb(ft);\n\t\tif (fte->type == FORMAT_TABLE_TIME && value != NULL)\n\t\t\tt = ((struct timeval *)value)->tv_sec;\n\t\telse\n\t\t\tfound = value;\n\t\tgoto found;\n\t}\n\tfe_find.key = (char *)key;\n\tfe = RB_FIND(format_entry_tree, &ft->tree, &fe_find);\n\tif (fe != NULL) {\n\t\tif (fe->time != 0) {\n\t\t\tt = fe->time;\n\t\t\tgoto found;\n\t\t}\n\t\tif (fe->value == NULL && fe->cb != NULL) {\n\t\t\tfe->value = fe->cb(ft);\n\t\t\tif (fe->value == NULL)\n\t\t\t\tfe->value = xstrdup(\"\");\n\t\t}\n\t\tfound = xstrdup(fe->value);\n\t\tgoto found;\n\t}\n\n\tif (~modifiers & FORMAT_TIMESTRING) {\n\t\tenvent = NULL;\n\t\tif (ft->s != NULL)\n\t\t\tenvent = environ_find(ft->s->environ, key);\n\t\tif (envent == NULL)\n\t\t\tenvent = environ_find(global_environ, key);\n\t\tif (envent != NULL && envent->value != NULL) {\n\t\t\tfound = xstrdup(envent->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\treturn (NULL);\n\nfound:\n\tif (modifiers & FORMAT_TIMESTRING) {\n\t\tif (t == 0 && found != NULL) {\n\t\t\tt = strtonum(found, 0, INT64_MAX, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tt = 0;\n\t\t\tfree(found);\n\t\t}\n\t\tif (t == 0)\n\t\t\treturn (NULL);\n\t\tif (modifiers & FORMAT_PRETTY)\n\t\t\tfound = format_pretty_time(t, 0);\n\t\telse {\n\t\t\tif (time_format != NULL) {\n\t\t\t\tlocaltime_r(&t, &tm);\n\t\t\t\tstrftime(s, sizeof s, time_format, &tm);\n\t\t\t} else {\n\t\t\t\tctime_r(&t, s);\n\t\t\t\ts[strcspn(s, \"\\n\")] = '\\0';\n\t\t\t}\n\t\t\tfound = xstrdup(s);\n\t\t}\n\t\treturn (found);\n\t}\n\n\tif (t != 0)\n\t\txasprintf(&found, \"%lld\", (long long)t);\n\telse if (found == NULL)\n\t\treturn (NULL);\n\tif (modifiers & FORMAT_BASENAME) {\n\t\tsaved = found;\n\t\tfound = xstrdup(basename(saved));\n\t\tfree(saved);\n\t}\n\tif (modifiers & FORMAT_DIRNAME) {\n\t\tsaved = found;\n\t\tfound = xstrdup(dirname(saved));\n\t\tfree(saved);\n\t}\n\tif (modifiers & FORMAT_QUOTE_SHELL) {\n\t\tsaved = found;\n\t\tfound = format_quote_shell(saved);\n\t\tfree(saved);\n\t}\n\tif (modifiers & FORMAT_QUOTE_STYLE) {\n\t\tsaved = found;\n\t\tfound = format_quote_style(saved);\n\t\tfree(saved);\n\t}\n\treturn (found);\n}\n\n/* Unescape escaped characters. */\nstatic char *\nformat_unescape(const char *s)\n{\n\tchar\t*out, *cp;\n\tint\t brackets = 0;\n\n\tcp = out = xmalloc(strlen(s) + 1);\n\tfor (; *s != '\\0'; s++) {\n\t\tif (*s == '#' && s[1] == '{')\n\t\t\tbrackets++;\n\t\tif (brackets == 0 &&\n\t\t    *s == '#' &&\n\t\t    strchr(\",#{}:\", s[1]) != NULL) {\n\t\t\t*cp++ = *++s;\n \t\t\tcontinue;\n\t\t}\n\t\tif (*s == '}')\n\t\t\tbrackets--;\n\t\t*cp++ = *s;\n\t}\n\t*cp = '\\0';\n\treturn (out);\n}\n\n/* Remove escaped characters. */\nstatic char *\nformat_strip(const char *s)\n{\n\tchar\t*out, *cp;\n\tint\t brackets = 0;\n\n\tcp = out = xmalloc(strlen(s) + 1);\n\tfor (; *s != '\\0'; s++) {\n\t\tif (*s == '#' && s[1] == '{')\n\t\t\tbrackets++;\n\t\tif (*s == '#' && strchr(\",#{}:\", s[1]) != NULL) {\n\t\t\tif (brackets != 0)\n\t\t\t\t*cp++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*s == '}')\n\t\t\tbrackets--;\n\t\t*cp++ = *s;\n\t}\n\t*cp = '\\0';\n\treturn (out);\n}\n\n/* Skip until end. */\nconst char *\nformat_skip(const char *s, const char *end)\n{\n\tint\tbrackets = 0;\n\n\tfor (; *s != '\\0'; s++) {\n\t\tif (*s == '#' && s[1] == '{')\n\t\t\tbrackets++;\n\t\tif (*s == '#' &&\n\t\t    s[1] != '\\0' &&\n\t\t    strchr(\",#{}:\", s[1]) != NULL) {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*s == '}')\n\t\t\tbrackets--;\n\t\tif (strchr(end, *s) != NULL && brackets == 0)\n\t\t\tbreak;\n\t}\n\tif (*s == '\\0')\n\t\treturn (NULL);\n\treturn (s);\n}\n\n/* Return left and right alternatives separated by commas. */\nstatic int\nformat_choose(struct format_expand_state *es, const char *s, char **left,\n    char **right, int expand)\n{\n\tconst char\t*cp;\n\tchar\t\t*left0, *right0;\n\n\tcp = format_skip(s, \",\");\n\tif (cp == NULL)\n\t\treturn (-1);\n\tleft0 = xstrndup(s, cp - s);\n\tright0 = xstrdup(cp + 1);\n\n\tif (expand) {\n\t\t*left = format_expand1(es, left0);\n\t\tfree(left0);\n\t\t*right = format_expand1(es, right0);\n\t\tfree(right0);\n\t} else {\n\t\t*left = left0;\n\t\t*right = right0;\n\t}\n\treturn (0);\n}\n\n/* Is this true? */\nint\nformat_true(const char *s)\n{\n\tif (s != NULL && *s != '\\0' && (s[0] != '0' || s[1] != '\\0'))\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Check if modifier end. */\nstatic int\nformat_is_end(char c)\n{\n\treturn (c == ';' || c == ':');\n}\n\n/* Add to modifier list. */\nstatic void\nformat_add_modifier(struct format_modifier **list, u_int *count,\n    const char *c, size_t n, char **argv, int argc)\n{\n\tstruct format_modifier *fm;\n\n\t*list = xreallocarray(*list, (*count) + 1, sizeof **list);\n\tfm = &(*list)[(*count)++];\n\n\tmemcpy(fm->modifier, c, n);\n\tfm->modifier[n] = '\\0';\n\tfm->size = n;\n\n\tfm->argv = argv;\n\tfm->argc = argc;\n}\n\n/* Free modifier list. */\nstatic void\nformat_free_modifiers(struct format_modifier *list, u_int count)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < count; i++)\n\t\tcmd_free_argv(list[i].argc, list[i].argv);\n\tfree(list);\n}\n\n/* Build modifier list. */\nstatic struct format_modifier *\nformat_build_modifiers(struct format_expand_state *es, const char **s,\n    u_int *count)\n{\n\tconst char\t\t*cp = *s, *end;\n\tstruct format_modifier\t*list = NULL;\n\tchar\t\t\t c, last[] = \"X;:\", **argv, *value;\n\tint\t\t\t argc;\n\n\t/*\n\t * Modifiers are a ; separated list of the forms:\n\t *      l,m,C,a,b,c,d,n,t,w,q,E,T,S,W,P,<,>\n\t *\t=a\n\t *\t=/a\n\t *      =/a/\n\t *\ts/a/b/\n\t *\ts/a/b\n\t *\t||,&&,!=,==,<=,>=\n\t */\n\n\t*count = 0;\n\n\twhile (*cp != '\\0' && *cp != ':') {\n\t\t/* Skip any separator character. */\n\t\tif (*cp == ';')\n\t\t\tcp++;\n\n\t\t/* Check single character modifiers with no arguments. */\n\t\tif (strchr(\"labcdnwETSWPL<>\", cp[0]) != NULL &&\n\t\t    format_is_end(cp[1])) {\n\t\t\tformat_add_modifier(&list, count, cp, 1, NULL, 0);\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Then try double character with no arguments. */\n\t\tif ((memcmp(\"||\", cp, 2) == 0 ||\n\t\t    memcmp(\"&&\", cp, 2) == 0 ||\n\t\t    memcmp(\"!=\", cp, 2) == 0 ||\n\t\t    memcmp(\"==\", cp, 2) == 0 ||\n\t\t    memcmp(\"<=\", cp, 2) == 0 ||\n\t\t    memcmp(\">=\", cp, 2) == 0) &&\n\t\t    format_is_end(cp[2])) {\n\t\t\tformat_add_modifier(&list, count, cp, 2, NULL, 0);\n\t\t\tcp += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Now try single character with arguments. */\n\t\tif (strchr(\"mCNst=peq\", cp[0]) == NULL)\n\t\t\tbreak;\n\t\tc = cp[0];\n\n\t\t/* No arguments provided. */\n\t\tif (format_is_end(cp[1])) {\n\t\t\tformat_add_modifier(&list, count, cp, 1, NULL, 0);\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\targv = NULL;\n\t\targc = 0;\n\n\t\t/* Single argument with no wrapper character. */\n\t\tif (!ispunct((u_char)cp[1]) || cp[1] == '-') {\n\t\t\tend = format_skip(cp + 1, \":;\");\n\t\t\tif (end == NULL)\n\t\t\t\tbreak;\n\n\t\t\targv = xcalloc(1, sizeof *argv);\n\t\t\tvalue = xstrndup(cp + 1, end - (cp + 1));\n\t\t\targv[0] = format_expand1(es, value);\n\t\t\tfree(value);\n\t\t\targc = 1;\n\n\t\t\tformat_add_modifier(&list, count, &c, 1, argv, argc);\n\t\t\tcp = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Multiple arguments with a wrapper character. */\n\t\tlast[0] = cp[1];\n\t\tcp++;\n\t\tdo {\n\t\t\tif (cp[0] == last[0] && format_is_end(cp[1])) {\n\t\t\t\tcp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend = format_skip(cp + 1, last);\n\t\t\tif (end == NULL)\n\t\t\t\tbreak;\n\t\t\tcp++;\n\n\t\t\targv = xreallocarray(argv, argc + 1, sizeof *argv);\n\t\t\tvalue = xstrndup(cp, end - cp);\n\t\t\targv[argc++] = format_expand1(es, value);\n\t\t\tfree(value);\n\n\t\t\tcp = end;\n\t\t} while (!format_is_end(cp[0]));\n\t\tformat_add_modifier(&list, count, &c, 1, argv, argc);\n\t}\n\tif (*cp != ':') {\n\t\tformat_free_modifiers(list, *count);\n\t\t*count = 0;\n\t\treturn (NULL);\n\t}\n\t*s = cp + 1;\n\treturn (list);\n}\n\n/* Match against an fnmatch(3) pattern or regular expression. */\nstatic char *\nformat_match(struct format_modifier *fm, const char *pattern, const char *text)\n{\n\tconst char\t*s = \"\";\n\tregex_t\t\t r;\n\tint\t\t flags = 0;\n\n\tif (fm->argc >= 1)\n\t\ts = fm->argv[0];\n\tif (strchr(s, 'r') == NULL) {\n\t\tif (strchr(s, 'i') != NULL)\n\t\t\tflags |= FNM_CASEFOLD;\n\t\tif (fnmatch(pattern, text, flags) != 0)\n\t\t\treturn (xstrdup(\"0\"));\n\t} else {\n\t\tflags = REG_EXTENDED|REG_NOSUB;\n\t\tif (strchr(s, 'i') != NULL)\n\t\t\tflags |= REG_ICASE;\n\t\tif (regcomp(&r, pattern, flags) != 0)\n\t\t\treturn (xstrdup(\"0\"));\n\t\tif (regexec(&r, text, 0, NULL, 0) != 0) {\n\t\t\tregfree(&r);\n\t\t\treturn (xstrdup(\"0\"));\n\t\t}\n\t\tregfree(&r);\n\t}\n\treturn (xstrdup(\"1\"));\n}\n\n/* Perform substitution in string. */\nstatic char *\nformat_sub(struct format_modifier *fm, const char *text, const char *pattern,\n    const char *with)\n{\n\tchar\t*value;\n\tint\t flags = REG_EXTENDED;\n\n\tif (fm->argc >= 3 && strchr(fm->argv[2], 'i') != NULL)\n\t\tflags |= REG_ICASE;\n\tvalue = regsub(pattern, with, text, flags);\n\tif (value == NULL)\n\t\treturn (xstrdup(text));\n\treturn (value);\n}\n\n/* Search inside pane. */\nstatic char *\nformat_search(struct format_modifier *fm, struct window_pane *wp, const char *s)\n{\n\tint\t ignore = 0, regex = 0;\n\tchar\t*value;\n\n\tif (fm->argc >= 1) {\n\t\tif (strchr(fm->argv[0], 'i') != NULL)\n\t\t\tignore = 1;\n\t\tif (strchr(fm->argv[0], 'r') != NULL)\n\t\t\tregex = 1;\n\t}\n\txasprintf(&value, \"%u\", window_pane_search(wp, s, regex, ignore));\n\treturn (value);\n}\n\n/* Does session name exist? */\nstatic char *\nformat_session_name(struct format_expand_state *es, const char *fmt)\n{\n\tchar\t\t*name;\n\tstruct session\t*s;\n\n\tname = format_expand1(es, fmt);\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (strcmp(s->name, name) == 0) {\n\t\t\tfree(name);\n\t\t\treturn (xstrdup(\"1\"));\n\t\t}\n\t}\n\tfree(name);\n\treturn (xstrdup(\"0\"));\n}\n\n/* Loop over sessions. */\nstatic char *\nformat_loop_sessions(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t\t*ft = es->ft;\n\tstruct client\t\t\t*c = ft->client;\n\tstruct cmdq_item\t\t*item = ft->item;\n\tstruct format_tree\t\t*nft;\n\tstruct format_expand_state\t next;\n\tchar\t\t\t\t*expanded, *value;\n\tsize_t\t\t\t\t valuelen;\n\tstruct session\t\t\t*s;\n\n\tvalue = xcalloc(1, 1);\n\tvaluelen = 1;\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tformat_log(es, \"session loop: $%u\", s->id);\n\t\tnft = format_create(c, item, FORMAT_NONE, ft->flags);\n\t\tformat_defaults(nft, ft->c, s, NULL, NULL);\n\t\tformat_copy_state(&next, es, 0);\n\t\tnext.ft = nft;\n\t\texpanded = format_expand1(&next, fmt);\n\t\tformat_free(next.ft);\n\n\t\tvaluelen += strlen(expanded);\n\t\tvalue = xrealloc(value, valuelen);\n\n\t\tstrlcat(value, expanded, valuelen);\n\t\tfree(expanded);\n\t}\n\n\treturn (value);\n}\n\n/* Does window name exist? */\nstatic char *\nformat_window_name(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t*ft = es->ft;\n\tchar\t\t\t*name;\n\tstruct winlink\t\t*wl;\n\n\tif (ft->s == NULL) {\n\t\tformat_log(es, \"window name but no session\");\n\t\treturn (NULL);\n\t}\n\n\tname = format_expand1(es, fmt);\n\tRB_FOREACH(wl, winlinks, &ft->s->windows) {\n\t\tif (strcmp(wl->window->name, name) == 0) {\n\t\t\tfree(name);\n\t\t\treturn (xstrdup(\"1\"));\n\t\t}\n\t}\n\tfree(name);\n\treturn (xstrdup(\"0\"));\n}\n\n/* Loop over windows. */\nstatic char *\nformat_loop_windows(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t\t*ft = es->ft;\n\tstruct client\t\t\t*c = ft->client;\n\tstruct cmdq_item\t\t*item = ft->item;\n\tstruct format_tree\t\t*nft;\n\tstruct format_expand_state\t next;\n\tchar\t\t\t\t*all, *active, *use, *expanded, *value;\n\tsize_t\t\t\t\t valuelen;\n\tstruct winlink\t\t\t*wl;\n\tstruct window\t\t\t*w;\n\n\tif (ft->s == NULL) {\n\t\tformat_log(es, \"window loop but no session\");\n\t\treturn (NULL);\n\t}\n\n\tif (format_choose(es, fmt, &all, &active, 0) != 0) {\n\t\tall = xstrdup(fmt);\n\t\tactive = NULL;\n\t}\n\n\tvalue = xcalloc(1, 1);\n\tvaluelen = 1;\n\n\tRB_FOREACH(wl, winlinks, &ft->s->windows) {\n\t\tw = wl->window;\n\t\tformat_log(es, \"window loop: %u @%u\", wl->idx, w->id);\n\t\tif (active != NULL && wl == ft->s->curw)\n\t\t\tuse = active;\n\t\telse\n\t\t\tuse = all;\n\t\tnft = format_create(c, item, FORMAT_WINDOW|w->id, ft->flags);\n\t\tformat_defaults(nft, ft->c, ft->s, wl, NULL);\n\t\tformat_copy_state(&next, es, 0);\n\t\tnext.ft = nft;\n\t\texpanded = format_expand1(&next, use);\n\t\tformat_free(nft);\n\n\t\tvaluelen += strlen(expanded);\n\t\tvalue = xrealloc(value, valuelen);\n\n\t\tstrlcat(value, expanded, valuelen);\n\t\tfree(expanded);\n\t}\n\n\tfree(active);\n\tfree(all);\n\n\treturn (value);\n}\n\n/* Loop over panes. */\nstatic char *\nformat_loop_panes(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t\t*ft = es->ft;\n\tstruct client\t\t\t*c = ft->client;\n\tstruct cmdq_item\t\t*item = ft->item;\n\tstruct format_tree\t\t*nft;\n\tstruct format_expand_state\t next;\n\tchar\t\t\t\t*all, *active, *use, *expanded, *value;\n\tsize_t\t\t\t\t valuelen;\n\tstruct window_pane\t\t*wp;\n\n\tif (ft->w == NULL) {\n\t\tformat_log(es, \"pane loop but no window\");\n\t\treturn (NULL);\n\t}\n\n\tif (format_choose(es, fmt, &all, &active, 0) != 0) {\n\t\tall = xstrdup(fmt);\n\t\tactive = NULL;\n\t}\n\n\tvalue = xcalloc(1, 1);\n\tvaluelen = 1;\n\n\tTAILQ_FOREACH(wp, &ft->w->panes, entry) {\n\t\tformat_log(es, \"pane loop: %%%u\", wp->id);\n\t\tif (active != NULL && wp == ft->w->active)\n\t\t\tuse = active;\n\t\telse\n\t\t\tuse = all;\n\t\tnft = format_create(c, item, FORMAT_PANE|wp->id, ft->flags);\n\t\tformat_defaults(nft, ft->c, ft->s, ft->wl, wp);\n\t\tformat_copy_state(&next, es, 0);\n\t\tnext.ft = nft;\n\t\texpanded = format_expand1(&next, use);\n\t\tformat_free(nft);\n\n\t\tvaluelen += strlen(expanded);\n\t\tvalue = xrealloc(value, valuelen);\n\n\t\tstrlcat(value, expanded, valuelen);\n\t\tfree(expanded);\n\t}\n\n\tfree(active);\n\tfree(all);\n\n\treturn (value);\n}\n\n/* Loop over clients. */\nstatic char *\nformat_loop_clients(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t\t*ft = es->ft;\n\tstruct client\t\t\t*c;\n\tstruct cmdq_item\t\t*item = ft->item;\n\tstruct format_tree\t\t*nft;\n\tstruct format_expand_state\t next;\n\tchar\t\t\t\t*expanded, *value;\n\tsize_t\t\t\t\t valuelen;\n\n\tvalue = xcalloc(1, 1);\n\tvaluelen = 1;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tformat_log(es, \"client loop: %s\", c->name);\n\t\tnft = format_create(c, item, 0, ft->flags);\n\t\tformat_defaults(nft, c, ft->s, ft->wl, ft->wp);\n\t\tformat_copy_state(&next, es, 0);\n\t\tnext.ft = nft;\n\t\texpanded = format_expand1(&next, fmt);\n\t\tformat_free(nft);\n\n\t\tvaluelen += strlen(expanded);\n\t\tvalue = xrealloc(value, valuelen);\n\n\t\tstrlcat(value, expanded, valuelen);\n\t\tfree(expanded);\n\t}\n\n\treturn (value);\n}\n\nstatic char *\nformat_replace_expression(struct format_modifier *mexp,\n    struct format_expand_state *es, const char *copy)\n{\n\tint\t\t\t argc = mexp->argc;\n\tconst char\t\t*errstr;\n\tchar\t\t\t*endch, *value, *left = NULL, *right = NULL;\n\tint\t\t\t use_fp = 0;\n\tu_int\t\t\t prec = 0;\n\tdouble\t\t\t mleft, mright, result;\n\tenum { ADD,\n\t       SUBTRACT,\n\t       MULTIPLY,\n\t       DIVIDE,\n\t       MODULUS,\n\t       EQUAL,\n\t       NOT_EQUAL,\n\t       GREATER_THAN,\n\t       GREATER_THAN_EQUAL,\n\t       LESS_THAN,\n\t       LESS_THAN_EQUAL } operator;\n\n\tif (strcmp(mexp->argv[0], \"+\") == 0)\n\t\toperator = ADD;\n\telse if (strcmp(mexp->argv[0], \"-\") == 0)\n\t\toperator = SUBTRACT;\n\telse if (strcmp(mexp->argv[0], \"*\") == 0)\n\t\toperator = MULTIPLY;\n\telse if (strcmp(mexp->argv[0], \"/\") == 0)\n\t\toperator = DIVIDE;\n\telse if (strcmp(mexp->argv[0], \"%\") == 0 ||\n\t    strcmp(mexp->argv[0], \"m\") == 0)\n\t\toperator = MODULUS;\n\telse if (strcmp(mexp->argv[0], \"==\") == 0)\n\t\toperator = EQUAL;\n\telse if (strcmp(mexp->argv[0], \"!=\") == 0)\n\t\toperator = NOT_EQUAL;\n\telse if (strcmp(mexp->argv[0], \">\") == 0)\n\t\toperator = GREATER_THAN;\n\telse if (strcmp(mexp->argv[0], \"<\") == 0)\n\t\toperator = LESS_THAN;\n\telse if (strcmp(mexp->argv[0], \">=\") == 0)\n\t\toperator = GREATER_THAN_EQUAL;\n\telse if (strcmp(mexp->argv[0], \"<=\") == 0)\n\t\toperator = LESS_THAN_EQUAL;\n\telse {\n\t\tformat_log(es, \"expression has no valid operator: '%s'\",\n\t\t    mexp->argv[0]);\n\t\tgoto fail;\n\t}\n\n\t/* The second argument may be flags. */\n\tif (argc >= 2 && strchr(mexp->argv[1], 'f') != NULL) {\n\t\tuse_fp = 1;\n\t\tprec = 2;\n\t}\n\n\t/* The third argument may be precision. */\n\tif (argc >= 3) {\n\t\tprec = strtonum(mexp->argv[2], INT_MIN, INT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tformat_log(es, \"expression precision %s: %s\", errstr,\n\t\t\t    mexp->argv[2]);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (format_choose(es, copy, &left, &right, 1) != 0) {\n\t\tformat_log(es, \"expression syntax error\");\n\t\tgoto fail;\n\t}\n\n\tmleft = strtod(left, &endch);\n\tif (*endch != '\\0') {\n\t\tformat_log(es, \"expression left side is invalid: %s\", left);\n\t\tgoto fail;\n\t}\n\n\tmright = strtod(right, &endch);\n\tif (*endch != '\\0') {\n\t\tformat_log(es, \"expression right side is invalid: %s\", right);\n\t\tgoto fail;\n\t}\n\n\tif (!use_fp) {\n\t\tmleft = (long long)mleft;\n\t\tmright = (long long)mright;\n\t}\n\tformat_log(es, \"expression left side is: %.*f\", prec, mleft);\n\tformat_log(es, \"expression right side is: %.*f\", prec, mright);\n\n\tswitch (operator) {\n\tcase ADD:\n\t\tresult = mleft + mright;\n\t\tbreak;\n\tcase SUBTRACT:\n\t\tresult = mleft - mright;\n\t\tbreak;\n\tcase MULTIPLY:\n\t\tresult = mleft * mright;\n\t\tbreak;\n\tcase DIVIDE:\n\t\tresult = mleft / mright;\n\t\tbreak;\n\tcase MODULUS:\n\t\tresult = fmod(mleft, mright);\n\t\tbreak;\n\tcase EQUAL:\n\t\tresult = fabs(mleft - mright) < 1e-9;\n\t\tbreak;\n\tcase NOT_EQUAL:\n\t\tresult = fabs(mleft - mright) > 1e-9;\n\t\tbreak;\n\tcase GREATER_THAN:\n\t\tresult = (mleft > mright);\n\t\tbreak;\n\tcase GREATER_THAN_EQUAL:\n\t\tresult = (mleft >= mright);\n\t\tbreak;\n\tcase LESS_THAN:\n\t\tresult = (mleft < mright);\n\t\tbreak;\n\tcase LESS_THAN_EQUAL:\n\t\tresult = (mleft <= mright);\n\t\tbreak;\n\t}\n\tif (use_fp)\n\t\txasprintf(&value, \"%.*f\", prec, result);\n\telse\n\t\txasprintf(&value, \"%.*f\", prec, (double)(long long)result);\n\tformat_log(es, \"expression result is %s\", value);\n\n\tfree(right);\n\tfree(left);\n\treturn (value);\n\nfail:\n\tfree(right);\n\tfree(left);\n\treturn (NULL);\n}\n\n/* Replace a key. */\nstatic int\nformat_replace(struct format_expand_state *es, const char *key, size_t keylen,\n    char **buf, size_t *len, size_t *off)\n{\n\tstruct format_tree\t\t *ft = es->ft;\n\tstruct window_pane\t\t *wp = ft->wp;\n\tconst char\t\t\t *errstr, *copy, *cp, *marker = NULL;\n\tconst char\t\t\t *time_format = NULL;\n\tchar\t\t\t\t *copy0, *condition, *found, *new;\n\tchar\t\t\t\t *value, *left, *right;\n\tsize_t\t\t\t\t  valuelen;\n\tint\t\t\t\t  modifiers = 0, limit = 0, width = 0;\n\tint\t\t\t\t  j, c;\n\tstruct format_modifier\t\t *list, *cmp = NULL, *search = NULL;\n\tstruct format_modifier\t\t**sub = NULL, *mexp = NULL, *fm;\n\tu_int\t\t\t\t  i, count, nsub = 0;\n\tstruct format_expand_state\t  next;\n\n\t/* Make a copy of the key. */\n\tcopy = copy0 = xstrndup(key, keylen);\n\n\t/* Process modifier list. */\n\tlist = format_build_modifiers(es, &copy, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tfm = &list[i];\n\t\tif (format_logging(ft)) {\n\t\t\tformat_log(es, \"modifier %u is %s\", i, fm->modifier);\n\t\t\tfor (j = 0; j < fm->argc; j++) {\n\t\t\t\tformat_log(es, \"modifier %u argument %d: %s\", i,\n\t\t\t\t    j, fm->argv[j]);\n\t\t\t}\n\t\t}\n\t\tif (fm->size == 1) {\n\t\t\tswitch (fm->modifier[0]) {\n\t\t\tcase 'm':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\t\tcmp = fm;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tsearch = fm;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (fm->argc < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tsub = xreallocarray(sub, nsub + 1, sizeof *sub);\n\t\t\t\tsub[nsub++] = fm;\n\t\t\t\tbreak;\n\t\t\tcase '=':\n\t\t\t\tif (fm->argc < 1)\n\t\t\t\t\tbreak;\n\t\t\t\tlimit = strtonum(fm->argv[0], INT_MIN, INT_MAX,\n\t\t\t\t    &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tlimit = 0;\n\t\t\t\tif (fm->argc >= 2 && fm->argv[1] != NULL)\n\t\t\t\t\tmarker = fm->argv[1];\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (fm->argc < 1)\n\t\t\t\t\tbreak;\n\t\t\t\twidth = strtonum(fm->argv[0], INT_MIN, INT_MAX,\n\t\t\t\t    &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\twidth = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tmodifiers |= FORMAT_WIDTH;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (fm->argc < 1 || fm->argc > 3)\n\t\t\t\t\tbreak;\n\t\t\t\tmexp = fm;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tmodifiers |= FORMAT_LITERAL;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tmodifiers |= FORMAT_CHARACTER;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tmodifiers |= FORMAT_BASENAME;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tmodifiers |= FORMAT_COLOUR;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tmodifiers |= FORMAT_DIRNAME;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tmodifiers |= FORMAT_LENGTH;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tmodifiers |= FORMAT_TIMESTRING;\n\t\t\t\tif (fm->argc < 1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strchr(fm->argv[0], 'p') != NULL)\n\t\t\t\t\tmodifiers |= FORMAT_PRETTY;\n\t\t\t\telse if (fm->argc >= 2 &&\n\t\t\t\t    strchr(fm->argv[0], 'f') != NULL)\n\t\t\t\t\ttime_format = format_strip(fm->argv[1]);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tif (fm->argc < 1)\n\t\t\t\t\tmodifiers |= FORMAT_QUOTE_SHELL;\n\t\t\t\telse if (strchr(fm->argv[0], 'e') != NULL ||\n\t\t\t\t    strchr(fm->argv[0], 'h') != NULL)\n\t\t\t\t\tmodifiers |= FORMAT_QUOTE_STYLE;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tmodifiers |= FORMAT_EXPAND;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tmodifiers |= FORMAT_EXPANDTIME;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tif (fm->argc < 1 ||\n\t\t\t\t    strchr(fm->argv[0], 'w') != NULL)\n\t\t\t\t\tmodifiers |= FORMAT_WINDOW_NAME;\n\t\t\t\telse if (strchr(fm->argv[0], 's') != NULL)\n\t\t\t\t\tmodifiers |= FORMAT_SESSION_NAME;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tmodifiers |= FORMAT_SESSIONS;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tmodifiers |= FORMAT_WINDOWS;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tmodifiers |= FORMAT_PANES;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tmodifiers |= FORMAT_CLIENTS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (fm->size == 2) {\n\t\t\tif (strcmp(fm->modifier, \"||\") == 0 ||\n\t\t\t    strcmp(fm->modifier, \"&&\") == 0 ||\n\t\t\t    strcmp(fm->modifier, \"==\") == 0 ||\n\t\t\t    strcmp(fm->modifier, \"!=\") == 0 ||\n\t\t\t    strcmp(fm->modifier, \">=\") == 0 ||\n\t\t\t    strcmp(fm->modifier, \"<=\") == 0)\n\t\t\t\tcmp = fm;\n\t\t}\n\t}\n\n\t/* Is this a literal string? */\n\tif (modifiers & FORMAT_LITERAL) {\n\t\tformat_log(es, \"literal string is '%s'\", copy);\n\t\tvalue = format_unescape(copy);\n\t\tgoto done;\n\t}\n\n\t/* Is this a character? */\n\tif (modifiers & FORMAT_CHARACTER) {\n\t\tnew = format_expand1(es, copy);\n\t\tc = strtonum(new, 32, 126, &errstr);\n\t\tif (errstr != NULL)\n\t\t\tvalue = xstrdup(\"\");\n\t\telse\n\t\t\txasprintf(&value, \"%c\", c);\n\t\tfree(new);\n\t\tgoto done;\n\t}\n\n\t/* Is this a colour? */\n\tif (modifiers & FORMAT_COLOUR) {\n\t\tnew = format_expand1(es, copy);\n\t\tc = colour_fromstring(new);\n\t\tif (c == -1 || (c = colour_force_rgb(c)) == -1)\n\t\t\tvalue = xstrdup(\"\");\n\t\telse\n\t\t\txasprintf(&value, \"%06x\", c & 0xffffff);\n\t\tfree(new);\n\t\tgoto done;\n\t}\n\n\t/* Is this a loop, comparison or condition? */\n\tif (modifiers & FORMAT_SESSIONS) {\n\t\tvalue = format_loop_sessions(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (modifiers & FORMAT_WINDOWS) {\n\t\tvalue = format_loop_windows(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (modifiers & FORMAT_PANES) {\n\t\tvalue = format_loop_panes(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (modifiers & FORMAT_CLIENTS) {\n\t\tvalue = format_loop_clients(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (modifiers & FORMAT_WINDOW_NAME) {\n\t\tvalue = format_window_name(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (modifiers & FORMAT_SESSION_NAME) {\n\t\tvalue = format_session_name(es, copy);\n\t\tif (value == NULL)\n\t\t\tgoto fail;\n\t} else if (search != NULL) {\n\t\t/* Search in pane. */\n\t\tnew = format_expand1(es, copy);\n\t\tif (wp == NULL) {\n\t\t\tformat_log(es, \"search '%s' but no pane\", new);\n\t\t\tvalue = xstrdup(\"0\");\n\t\t} else {\n\t\t\tformat_log(es, \"search '%s' pane %%%u\", new, wp->id);\n\t\t\tvalue = format_search(search, wp, new);\n\t\t}\n\t\tfree(new);\n\t} else if (cmp != NULL) {\n\t\t/* Comparison of left and right. */\n\t\tif (format_choose(es, copy, &left, &right, 1) != 0) {\n\t\t\tformat_log(es, \"compare %s syntax error: %s\",\n\t\t\t    cmp->modifier, copy);\n\t\t\tgoto fail;\n\t\t}\n\t\tformat_log(es, \"compare %s left is: %s\", cmp->modifier, left);\n\t\tformat_log(es, \"compare %s right is: %s\", cmp->modifier, right);\n\n\t\tif (strcmp(cmp->modifier, \"||\") == 0) {\n\t\t\tif (format_true(left) || format_true(right))\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"&&\") == 0) {\n\t\t\tif (format_true(left) && format_true(right))\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"==\") == 0) {\n\t\t\tif (strcmp(left, right) == 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"!=\") == 0) {\n\t\t\tif (strcmp(left, right) != 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"<\") == 0) {\n\t\t\tif (strcmp(left, right) < 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \">\") == 0) {\n\t\t\tif (strcmp(left, right) > 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"<=\") == 0) {\n\t\t\tif (strcmp(left, right) <= 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \">=\") == 0) {\n\t\t\tif (strcmp(left, right) >= 0)\n\t\t\t\tvalue = xstrdup(\"1\");\n\t\t\telse\n\t\t\t\tvalue = xstrdup(\"0\");\n\t\t} else if (strcmp(cmp->modifier, \"m\") == 0)\n\t\t\tvalue = format_match(cmp, left, right);\n\n\t\tfree(right);\n\t\tfree(left);\n\t} else if (*copy == '?') {\n\t\t/* Conditional: check first and choose second or third. */\n\t\tcp = format_skip(copy + 1, \",\");\n\t\tif (cp == NULL) {\n\t\t\tformat_log(es, \"condition syntax error: %s\", copy + 1);\n\t\t\tgoto fail;\n\t\t}\n\t\tcondition = xstrndup(copy + 1, cp - (copy + 1));\n\t\tformat_log(es, \"condition is: %s\", condition);\n\n\t\tfound = format_find(ft, condition, modifiers, time_format);\n\t\tif (found == NULL) {\n\t\t\t/*\n\t\t\t * If the condition not found, try to expand it. If\n\t\t\t * the expansion doesn't have any effect, then assume\n\t\t\t * false.\n\t\t\t */\n\t\t\tfound = format_expand1(es, condition);\n\t\t\tif (strcmp(found, condition) == 0) {\n\t\t\t\tfree(found);\n\t\t\t\tfound = xstrdup(\"\");\n\t\t\t\tformat_log(es,\n\t\t\t\t    \"condition '%s' not found; assuming false\",\n\t\t\t\t    condition);\n\t\t\t}\n\t\t} else {\n\t\t\tformat_log(es, \"condition '%s' found: %s\", condition,\n\t\t\t    found);\n\t\t}\n\n\t\tif (format_choose(es, cp + 1, &left, &right, 0) != 0) {\n\t\t\tformat_log(es, \"condition '%s' syntax error: %s\",\n\t\t\t    condition, cp + 1);\n\t\t\tfree(found);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (format_true(found)) {\n\t\t\tformat_log(es, \"condition '%s' is true\", condition);\n\t\t\tvalue = format_expand1(es, left);\n\t\t} else {\n\t\t\tformat_log(es, \"condition '%s' is false\", condition);\n\t\t\tvalue = format_expand1(es, right);\n\t\t}\n\t\tfree(right);\n\t\tfree(left);\n\n\t\tfree(condition);\n\t\tfree(found);\n\t} else if (mexp != NULL) {\n\t\tvalue = format_replace_expression(mexp, es, copy);\n\t\tif (value == NULL)\n\t\t\tvalue = xstrdup(\"\");\n\t} else {\n\t\tif (strstr(copy, \"#{\") != 0) {\n\t\t\tformat_log(es, \"expanding inner format '%s'\", copy);\n\t\t\tvalue = format_expand1(es, copy);\n\t\t} else {\n\t\t\tvalue = format_find(ft, copy, modifiers, time_format);\n\t\t\tif (value == NULL) {\n\t\t\t\tformat_log(es, \"format '%s' not found\", copy);\n\t\t\t\tvalue = xstrdup(\"\");\n\t\t\t} else {\n\t\t\t\tformat_log(es, \"format '%s' found: %s\", copy,\n\t\t\t\t    value);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\t/* Expand again if required. */\n\tif (modifiers & FORMAT_EXPAND) {\n\t\tnew = format_expand1(es, value);\n\t\tfree(value);\n\t\tvalue = new;\n\t} else if (modifiers & FORMAT_EXPANDTIME) {\n\t\tformat_copy_state(&next, es, FORMAT_EXPAND_TIME);\n\t\tnew = format_expand1(&next, value);\n\t\tfree(value);\n\t\tvalue = new;\n\t}\n\n\t/* Perform substitution if any. */\n\tfor (i = 0; i < nsub; i++) {\n\t\tleft = format_expand1(es, sub[i]->argv[0]);\n\t\tright = format_expand1(es, sub[i]->argv[1]);\n\t\tnew = format_sub(sub[i], value, left, right);\n\t\tformat_log(es, \"substitute '%s' to '%s': %s\", left, right, new);\n\t\tfree(value);\n\t\tvalue = new;\n\t\tfree(right);\n\t\tfree(left);\n\t}\n\n\t/* Truncate the value if needed. */\n\tif (limit > 0) {\n\t\tnew = format_trim_left(value, limit);\n\t\tif (marker != NULL && strcmp(new, value) != 0) {\n\t\t\tfree(value);\n\t\t\txasprintf(&value, \"%s%s\", new, marker);\n\t\t} else {\n\t\t\tfree(value);\n\t\t\tvalue = new;\n\t\t}\n\t\tformat_log(es, \"applied length limit %d: %s\", limit, value);\n\t} else if (limit < 0) {\n\t\tnew = format_trim_right(value, -limit);\n\t\tif (marker != NULL && strcmp(new, value) != 0) {\n\t\t\tfree(value);\n\t\t\txasprintf(&value, \"%s%s\", marker, new);\n\t\t} else {\n\t\t\tfree(value);\n\t\t\tvalue = new;\n\t\t}\n\t\tformat_log(es, \"applied length limit %d: %s\", limit, value);\n\t}\n\n\t/* Pad the value if needed. */\n\tif (width > 0) {\n\t\tnew = utf8_padcstr(value, width);\n\t\tfree(value);\n\t\tvalue = new;\n\t\tformat_log(es, \"applied padding width %d: %s\", width, value);\n\t} else if (width < 0) {\n\t\tnew = utf8_rpadcstr(value, -width);\n\t\tfree(value);\n\t\tvalue = new;\n\t\tformat_log(es, \"applied padding width %d: %s\", width, value);\n\t}\n\n\t/* Replace with the length or width if needed. */\n\tif (modifiers & FORMAT_LENGTH) {\n\t\txasprintf(&new, \"%zu\", strlen(value));\n\t\tfree(value);\n\t\tvalue = new;\n\t\tformat_log(es, \"replacing with length: %s\", new);\n\t}\n\tif (modifiers & FORMAT_WIDTH) {\n\t\txasprintf(&new, \"%u\", format_width(value));\n\t\tfree(value);\n\t\tvalue = new;\n\t\tformat_log(es, \"replacing with width: %s\", new);\n\t}\n\n\t/* Expand the buffer and copy in the value. */\n\tvaluelen = strlen(value);\n\twhile (*len - *off < valuelen + 1) {\n\t\t*buf = xreallocarray(*buf, 2, *len);\n\t\t*len *= 2;\n\t}\n\tmemcpy(*buf + *off, value, valuelen);\n\t*off += valuelen;\n\n\tformat_log(es, \"replaced '%s' with '%s'\", copy0, value);\n\tfree(value);\n\n\tfree(sub);\n\tformat_free_modifiers(list, count);\n\tfree(copy0);\n\treturn (0);\n\nfail:\n\tformat_log(es, \"failed %s\", copy0);\n\n\tfree(sub);\n\tformat_free_modifiers(list, count);\n\tfree(copy0);\n\treturn (-1);\n}\n\n/* Expand keys in a template. */\nstatic char *\nformat_expand1(struct format_expand_state *es, const char *fmt)\n{\n\tstruct format_tree\t*ft = es->ft;\n\tchar\t\t\t*buf, *out, *name;\n\tconst char\t\t*ptr, *s, *style_end = NULL;\n\tsize_t\t\t\t off, len, n, outlen;\n\tint     \t\t ch, brackets;\n\tchar\t\t\t expanded[8192];\n\n\tif (fmt == NULL || *fmt == '\\0')\n\t\treturn (xstrdup(\"\"));\n\n\tif (es->loop == FORMAT_LOOP_LIMIT) {\n\t\tformat_log(es, \"reached loop limit (%u)\", FORMAT_LOOP_LIMIT);\n\t\treturn (xstrdup(\"\"));\n\t}\n\tes->loop++;\n\n\tformat_log(es, \"expanding format: %s\", fmt);\n\n\tif ((es->flags & FORMAT_EXPAND_TIME) && strchr(fmt, '%') != NULL) {\n\t\tif (es->time == 0) {\n\t\t\tes->time = time(NULL);\n\t\t\tlocaltime_r(&es->time, &es->tm);\n\t\t}\n\t\tif (strftime(expanded, sizeof expanded, fmt, &es->tm) == 0) {\n\t\t\tformat_log(es, \"format is too long\");\n\t\t\treturn (xstrdup(\"\"));\n\t\t}\n\t\tif (format_logging(ft) && strcmp(expanded, fmt) != 0)\n\t\t\tformat_log(es, \"after time expanded: %s\", expanded);\n\t\tfmt = expanded;\n\t}\n\n\tlen = 64;\n\tbuf = xmalloc(len);\n\toff = 0;\n\n\twhile (*fmt != '\\0') {\n\t\tif (*fmt != '#') {\n\t\t\twhile (len - off < 2) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tbuf[off++] = *fmt++;\n\t\t\tcontinue;\n\t\t}\n\t\tfmt++;\n\n\t\tch = (u_char)*fmt++;\n\t\tswitch (ch) {\n\t\tcase '(':\n\t\t\tbrackets = 1;\n\t\t\tfor (ptr = fmt; *ptr != '\\0'; ptr++) {\n\t\t\t\tif (*ptr == '(')\n\t\t\t\t\tbrackets++;\n\t\t\t\tif (*ptr == ')' && --brackets == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*ptr != ')' || brackets != 0)\n\t\t\t\tbreak;\n\t\t\tn = ptr - fmt;\n\n\t\t\tname = xstrndup(fmt, n);\n\t\t\tformat_log(es, \"found #(): %s\", name);\n\n\t\t\tif ((ft->flags & FORMAT_NOJOBS) ||\n\t\t\t    (es->flags & FORMAT_EXPAND_NOJOBS)) {\n\t\t\t\tout = xstrdup(\"\");\n\t\t\t\tformat_log(es, \"#() is disabled\");\n\t\t\t} else {\n\t\t\t\tout = format_job_get(es, name);\n\t\t\t\tformat_log(es, \"#() result: %s\", out);\n\t\t\t}\n\t\t\tfree(name);\n\n\t\t\toutlen = strlen(out);\n\t\t\twhile (len - off < outlen + 1) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tmemcpy(buf + off, out, outlen);\n\t\t\toff += outlen;\n\n\t\t\tfree(out);\n\n\t\t\tfmt += n + 1;\n\t\t\tcontinue;\n\t\tcase '{':\n\t\t\tptr = format_skip((char *)fmt - 2, \"}\");\n\t\t\tif (ptr == NULL)\n\t\t\t\tbreak;\n\t\t\tn = ptr - fmt;\n\n\t\t\tformat_log(es, \"found #{}: %.*s\", (int)n, fmt);\n\t\t\tif (format_replace(es, fmt, n, &buf, &len, &off) != 0)\n\t\t\t\tbreak;\n\t\t\tfmt += n + 1;\n\t\t\tcontinue;\n\t\tcase '[':\n\t\tcase '#':\n\t\t\t/*\n\t\t\t * If ##[ (with two or more #s), then it is a style and\n\t\t\t * can be left for format_draw to handle.\n\t\t\t */\n\t\t\tptr = fmt - (ch == '[');\n\t\t\tn = 2 - (ch == '[');\n\t\t\twhile (*ptr == '#') {\n\t\t\t\tptr++;\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tif (*ptr == '[') {\n\t\t\t\tstyle_end = format_skip(fmt - 2, \"]\");\n\t\t\t\tformat_log(es, \"found #*%zu[\", n);\n\t\t\t\twhile (len - off < n + 2) {\n\t\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\t\tlen *= 2;\n\t\t\t\t}\n\t\t\t\tmemcpy(buf + off, fmt - 2, n + 1);\n\t\t\t\toff += n + 1;\n\t\t\t\tfmt = ptr + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tcase '}':\n\t\tcase ',':\n\t\t\tformat_log(es, \"found #%c\", ch);\n\t\t\twhile (len - off < 2) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tbuf[off++] = ch;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\ts = NULL;\n\t\t\tif (fmt > style_end) { /* skip inside #[] */\n\t\t\t\tif (ch >= 'A' && ch <= 'Z')\n\t\t\t\t\ts = format_upper[ch - 'A'];\n\t\t\t\telse if (ch >= 'a' && ch <= 'z')\n\t\t\t\t\ts = format_lower[ch - 'a'];\n\t\t\t}\n\t\t\tif (s == NULL) {\n\t\t\t\twhile (len - off < 3) {\n\t\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\t\tlen *= 2;\n\t\t\t\t}\n\t\t\t\tbuf[off++] = '#';\n\t\t\t\tbuf[off++] = ch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn = strlen(s);\n\t\t\tformat_log(es, \"found #%c: %s\", ch, s);\n\t\t\tif (format_replace(es, s, n, &buf, &len, &off) != 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\tbuf[off] = '\\0';\n\n\tformat_log(es, \"result is: %s\", buf);\n\tes->loop--;\n\n\treturn (buf);\n}\n\n/* Expand keys in a template, passing through strftime first. */\nchar *\nformat_expand_time(struct format_tree *ft, const char *fmt)\n{\n\tstruct format_expand_state\tes;\n\n\tmemset(&es, 0, sizeof es);\n\tes.ft = ft;\n\tes.flags = FORMAT_EXPAND_TIME;\n\treturn (format_expand1(&es, fmt));\n}\n\n/* Expand keys in a template. */\nchar *\nformat_expand(struct format_tree *ft, const char *fmt)\n{\n\tstruct format_expand_state\tes;\n\n\tmemset(&es, 0, sizeof es);\n\tes.ft = ft;\n\tes.flags = 0;\n\treturn (format_expand1(&es, fmt));\n}\n\n/* Expand a single string. */\nchar *\nformat_single(struct cmdq_item *item, const char *fmt, struct client *c,\n    struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*expanded;\n\n\tft = format_create_defaults(item, c, s, wl, wp);\n\texpanded = format_expand(ft, fmt);\n\tformat_free(ft);\n\treturn (expanded);\n}\n\n/* Expand a single string using state. */\nchar *\nformat_single_from_state(struct cmdq_item *item, const char *fmt,\n    struct client *c, struct cmd_find_state *fs)\n{\n\treturn (format_single(item, fmt, c, fs->s, fs->wl, fs->wp));\n}\n\n/* Expand a single string using target. */\nchar *\nformat_single_from_target(struct cmdq_item *item, const char *fmt)\n{\n\tstruct client\t*tc = cmdq_get_target_client(item);\n\n\treturn (format_single_from_state(item, fmt, tc, cmdq_get_target(item)));\n}\n\n/* Create and add defaults. */\nstruct format_tree *\nformat_create_defaults(struct cmdq_item *item, struct client *c,\n    struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tstruct format_tree\t*ft;\n\n\tif (item != NULL)\n\t\tft = format_create(cmdq_get_client(item), item, FORMAT_NONE, 0);\n\telse\n\t\tft = format_create(NULL, item, FORMAT_NONE, 0);\n\tformat_defaults(ft, c, s, wl, wp);\n\treturn (ft);\n}\n\n/* Create and add defaults using state. */\nstruct format_tree *\nformat_create_from_state(struct cmdq_item *item, struct client *c,\n    struct cmd_find_state *fs)\n{\n\treturn (format_create_defaults(item, c, fs->s, fs->wl, fs->wp));\n}\n\n/* Create and add defaults using target. */\nstruct format_tree *\nformat_create_from_target(struct cmdq_item *item)\n{\n\tstruct client\t*tc = cmdq_get_target_client(item);\n\n\treturn (format_create_from_state(item, tc, cmdq_get_target(item)));\n}\n\n/* Set defaults for any of arguments that are not NULL. */\nvoid\nformat_defaults(struct format_tree *ft, struct client *c, struct session *s,\n    struct winlink *wl, struct window_pane *wp)\n{\n\tstruct paste_buffer\t*pb;\n\n\tif (c != NULL && c->name != NULL)\n\t\tlog_debug(\"%s: c=%s\", __func__, c->name);\n\telse\n\t\tlog_debug(\"%s: c=none\", __func__);\n\tif (s != NULL)\n\t\tlog_debug(\"%s: s=$%u\", __func__, s->id);\n\telse\n\t\tlog_debug(\"%s: s=none\", __func__);\n\tif (wl != NULL)\n\t\tlog_debug(\"%s: wl=%u\", __func__, wl->idx);\n\telse\n\t\tlog_debug(\"%s: wl=none\", __func__);\n\tif (wp != NULL)\n\t\tlog_debug(\"%s: wp=%%%u\", __func__, wp->id);\n\telse\n\t\tlog_debug(\"%s: wp=none\", __func__);\n\n\tif (c != NULL && s != NULL && c->session != s)\n\t\tlog_debug(\"%s: session does not match\", __func__);\n\n\tif (wp != NULL)\n\t\tft->type = FORMAT_TYPE_PANE;\n\telse if (wl != NULL)\n\t\tft->type = FORMAT_TYPE_WINDOW;\n\telse if (s != NULL)\n\t\tft->type = FORMAT_TYPE_SESSION;\n\telse\n\t\tft->type = FORMAT_TYPE_UNKNOWN;\n\n\tif (s == NULL && c != NULL)\n\t\ts = c->session;\n\tif (wl == NULL && s != NULL)\n\t\twl = s->curw;\n\tif (wp == NULL && wl != NULL)\n\t\twp = wl->window->active;\n\n\tif (c != NULL)\n\t\tformat_defaults_client(ft, c);\n\tif (s != NULL)\n\t\tformat_defaults_session(ft, s);\n\tif (wl != NULL)\n\t\tformat_defaults_winlink(ft, wl);\n\tif (wp != NULL)\n\t\tformat_defaults_pane(ft, wp);\n\n\tpb = paste_get_top(NULL);\n\tif (pb != NULL)\n\t\tformat_defaults_paste_buffer(ft, pb);\n}\n\n/* Set default format keys for a session. */\nstatic void\nformat_defaults_session(struct format_tree *ft, struct session *s)\n{\n\tft->s = s;\n}\n\n/* Set default format keys for a client. */\nstatic void\nformat_defaults_client(struct format_tree *ft, struct client *c)\n{\n\tif (ft->s == NULL)\n\t\tft->s = c->session;\n\tft->c = c;\n}\n\n/* Set default format keys for a window. */\nvoid\nformat_defaults_window(struct format_tree *ft, struct window *w)\n{\n\tft->w = w;\n}\n\n/* Set default format keys for a winlink. */\nstatic void\nformat_defaults_winlink(struct format_tree *ft, struct winlink *wl)\n{\n\tif (ft->w == NULL)\n\t\tformat_defaults_window(ft, wl->window);\n\tft->wl = wl;\n}\n\n/* Set default format keys for a window pane. */\nvoid\nformat_defaults_pane(struct format_tree *ft, struct window_pane *wp)\n{\n\tstruct window_mode_entry\t*wme;\n\n\tif (ft->w == NULL)\n\t\tformat_defaults_window(ft, wp->window);\n\tft->wp = wp;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme != NULL && wme->mode->formats != NULL)\n\t\twme->mode->formats(wme, ft);\n}\n\n/* Set default format keys for paste buffer. */\nvoid\nformat_defaults_paste_buffer(struct format_tree *ft, struct paste_buffer *pb)\n{\n\tft->pb = pb;\n}\n\nstatic int\nformat_is_word_separator(const char *ws, const struct grid_cell *gc)\n{\n\tif (utf8_cstrhas(ws, &gc->data))\n\t\treturn (1);\n\tif (gc->flags & GRID_FLAG_TAB)\n\t\treturn (1);\n\treturn gc->data.size == 1 && *gc->data.data == ' ';\n}\n\n/* Return word at given coordinates. Caller frees. */\nchar *\nformat_grid_word(struct grid *gd, u_int x, u_int y)\n{\n\tconst struct grid_line\t*gl;\n\tstruct grid_cell\t gc;\n\tconst char\t\t*ws;\n\tstruct utf8_data\t*ud = NULL;\n\tu_int\t\t\t end;\n\tsize_t\t\t\t size = 0;\n\tint\t\t\t found = 0;\n\tchar\t\t\t*s = NULL;\n\n\tws = options_get_string(global_s_options, \"word-separators\");\n\n\tfor (;;) {\n\t\tgrid_get_cell(gd, x, y, &gc);\n\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tif (format_is_word_separator(ws, &gc)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (x == 0) {\n\t\t\tif (y == 0)\n\t\t\t\tbreak;\n\t\t\tgl = grid_peek_line(gd, y - 1);\n\t\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\t\tbreak;\n\t\t\ty--;\n\t\t\tx = grid_line_length(gd, y);\n\t\t\tif (x == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tx--;\n\t}\n\tfor (;;) {\n\t\tif (found) {\n\t\t\tend = grid_line_length(gd, y);\n\t\t\tif (end == 0 || x == end - 1) {\n\t\t\t\tif (y == gd->hsize + gd->sy - 1)\n\t\t\t\t\tbreak;\n\t\t\t\tgl = grid_peek_line(gd, y);\n\t\t\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\t\t\tbreak;\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t} else\n\t\t\t\tx++;\n\t\t}\n\t\tfound = 1;\n\n\t\tgrid_get_cell(gd, x, y, &gc);\n\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tif (format_is_word_separator(ws, &gc))\n\t\t\tbreak;\n\n\t\tud = xreallocarray(ud, size + 2, sizeof *ud);\n\t\tmemcpy(&ud[size++], &gc.data, sizeof *ud);\n\t}\n\tif (size != 0) {\n\t\tud[size].size = 0;\n\t\ts = utf8_tocstr(ud);\n\t\tfree(ud);\n\t}\n\treturn (s);\n}\n\n/* Return line at given coordinates. Caller frees. */\nchar *\nformat_grid_line(struct grid *gd, u_int y)\n{\n\tstruct grid_cell\t gc;\n\tstruct utf8_data\t*ud = NULL;\n\tu_int\t\t\t x;\n\tsize_t\t\t\t size = 0;\n\tchar\t\t\t*s = NULL;\n\n\tfor (x = 0; x < grid_line_length(gd, y); x++) {\n\t\tgrid_get_cell(gd, x, y, &gc);\n\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\tcontinue;\n\n\t\tud = xreallocarray(ud, size + 2, sizeof *ud);\n\t\tif (gc.flags & GRID_FLAG_TAB)\n\t\t\tutf8_set(&ud[size++], '\\t');\n\t\telse\n\t\t\tmemcpy(&ud[size++], &gc.data, sizeof *ud);\n\t}\n\tif (size != 0) {\n\t\tud[size].size = 0;\n\t\ts = utf8_tocstr(ud);\n\t\tfree(ud);\n\t}\n\treturn (s);\n}\n\n/* Return hyperlink at given coordinates. Caller frees. */\nchar *\nformat_grid_hyperlink(struct grid *gd, u_int x, u_int y, struct screen* s)\n{\n\tconst char\t\t*uri;\n\tstruct grid_cell\t gc;\n\n\tgrid_get_cell(gd, x, y, &gc);\n\tif (gc.flags & GRID_FLAG_PADDING)\n\t\treturn (NULL);\n\tif (s->hyperlinks == NULL || gc.link == 0)\n\t\treturn (NULL);\n\tif (!hyperlinks_get(s->hyperlinks, gc.link, &uri, NULL, NULL))\n\t\treturn (NULL);\n\treturn (xstrdup(uri));\n}\n"
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "grid-reader.c",
          "type": "blob",
          "size": 10.57421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2020 Anindya Mukherjee <anindya49@hotmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"tmux.h\"\n#include <string.h>\n\n/* Initialise virtual cursor. */\nvoid\ngrid_reader_start(struct grid_reader *gr, struct grid *gd, u_int cx, u_int cy)\n{\n\tgr->gd = gd;\n\tgr->cx = cx;\n\tgr->cy = cy;\n}\n\n/* Get cursor position from reader. */\nvoid\ngrid_reader_get_cursor(struct grid_reader *gr, u_int *cx, u_int *cy)\n{\n\t*cx = gr->cx;\n\t*cy = gr->cy;\n}\n\n/* Get length of line containing the cursor. */\nu_int\ngrid_reader_line_length(struct grid_reader *gr)\n{\n\treturn (grid_line_length(gr->gd, gr->cy));\n}\n\n/* Move cursor forward one position. */\nvoid\ngrid_reader_cursor_right(struct grid_reader *gr, int wrap, int all)\n{\n\tu_int\t\t\tpx;\n\tstruct grid_cell\tgc;\n\n\tif (all)\n\t\tpx = gr->gd->sx;\n\telse\n\t\tpx = grid_reader_line_length(gr);\n\n\tif (wrap && gr->cx >= px && gr->cy < gr->gd->hsize + gr->gd->sy - 1) {\n\t\tgrid_reader_cursor_start_of_line(gr, 0);\n\t\tgrid_reader_cursor_down(gr);\n\t} else if (gr->cx < px) {\n\t\tgr->cx++;\n\t\twhile (gr->cx < px) {\n\t\t\tgrid_get_cell(gr->gd, gr->cx, gr->cy, &gc);\n\t\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tbreak;\n\t\t\tgr->cx++;\n\t\t}\n\t}\n}\n\n/* Move cursor back one position. */\nvoid\ngrid_reader_cursor_left(struct grid_reader *gr, int wrap)\n{\n\tstruct grid_cell\tgc;\n\n\twhile (gr->cx > 0) {\n\t\tgrid_get_cell(gr->gd, gr->cx, gr->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tgr->cx--;\n\t}\n\tif (gr->cx == 0 && gr->cy > 0 &&\n\t    (wrap ||\n\t     grid_get_line(gr->gd, gr->cy - 1)->flags & GRID_LINE_WRAPPED)) {\n\t\tgrid_reader_cursor_up(gr);\n\t\tgrid_reader_cursor_end_of_line(gr, 0, 0);\n\t} else if (gr->cx > 0)\n\t\tgr->cx--;\n}\n\n/* Move cursor down one line. */\nvoid\ngrid_reader_cursor_down(struct grid_reader *gr)\n{\n\tstruct grid_cell\tgc;\n\n\tif (gr->cy < gr->gd->hsize + gr->gd->sy - 1)\n\t\tgr->cy++;\n\twhile (gr->cx > 0) {\n\t\tgrid_get_cell(gr->gd, gr->cx, gr->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tgr->cx--;\n\t}\n}\n\n/* Move cursor up one line. */\nvoid\ngrid_reader_cursor_up(struct grid_reader *gr)\n{\n\tstruct grid_cell\tgc;\n\n\tif (gr->cy > 0)\n\t\tgr->cy--;\n\twhile (gr->cx > 0) {\n\t\tgrid_get_cell(gr->gd, gr->cx, gr->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tgr->cx--;\n\t}\n}\n\n/* Move cursor to the start of the line. */\nvoid\ngrid_reader_cursor_start_of_line(struct grid_reader *gr, int wrap)\n{\n\tif (wrap) {\n\t\twhile (gr->cy > 0 &&\n\t\t    grid_get_line(gr->gd, gr->cy - 1)->flags &\n\t\t        GRID_LINE_WRAPPED)\n\t\t\tgr->cy--;\n\t}\n\tgr->cx = 0;\n}\n\n/* Move cursor to the end of the line. */\nvoid\ngrid_reader_cursor_end_of_line(struct grid_reader *gr, int wrap, int all)\n{\n\tu_int\tyy;\n\n\tif (wrap) {\n\t\tyy = gr->gd->hsize + gr->gd->sy - 1;\n\t\twhile (gr->cy < yy && grid_get_line(gr->gd, gr->cy)->flags &\n\t\t    GRID_LINE_WRAPPED)\n\t\t\tgr->cy++;\n\t}\n\tif (all)\n\t\tgr->cx = gr->gd->sx;\n\telse\n\t\tgr->cx = grid_reader_line_length(gr);\n}\n\n/* Handle line wrapping while moving the cursor. */\nstatic int\ngrid_reader_handle_wrap(struct grid_reader *gr, u_int *xx, u_int *yy)\n{\n\t/*\n\t * Make sure the cursor lies within the grid reader's bounding area,\n\t * wrapping to the next line as necessary. Return zero if the cursor\n\t * would wrap past the bottom of the grid.\n\t */\n\twhile (gr->cx > *xx) {\n\t\tif (gr->cy == *yy)\n\t\t\treturn (0);\n\t\tgrid_reader_cursor_start_of_line(gr, 0);\n\t\tgrid_reader_cursor_down(gr);\n\n\t\tif (grid_get_line(gr->gd, gr->cy)->flags & GRID_LINE_WRAPPED)\n\t\t\t*xx = gr->gd->sx - 1;\n\t\telse\n\t\t\t*xx = grid_reader_line_length(gr);\n\t}\n\treturn (1);\n}\n\n/* Check if character under cursor is in set. */\nint\ngrid_reader_in_set(struct grid_reader *gr, const char *set)\n{\n\treturn (grid_in_set(gr->gd, gr->cx, gr->cy, set));\n}\n\n/* Move cursor to the start of the next word. */\nvoid\ngrid_reader_cursor_next_word(struct grid_reader *gr, const char *separators)\n{\n\tu_int\txx, yy, width;\n\n\t/* Do not break up wrapped words. */\n\tif (grid_get_line(gr->gd, gr->cy)->flags & GRID_LINE_WRAPPED)\n\t\txx = gr->gd->sx - 1;\n\telse\n\t\txx = grid_reader_line_length(gr);\n\tyy = gr->gd->hsize + gr->gd->sy - 1;\n\n\t/*\n\t * When navigating via spaces (for example with next-space) separators\n\t * should be empty.\n\t *\n\t * If we started on a separator that is not whitespace, skip over\n\t * subsequent separators that are not whitespace. Otherwise, if we\n\t * started on a non-whitespace character, skip over subsequent\n\t * characters that are neither whitespace nor separators. Then, skip\n\t * over whitespace (if any) until the next non-whitespace character.\n\t */\n\tif (!grid_reader_handle_wrap(gr, &xx, &yy))\n\t\treturn;\n\tif (!grid_reader_in_set(gr, WHITESPACE)) {\n\t\tif (grid_reader_in_set(gr, separators)) {\n\t\t\tdo\n\t\t\t\tgr->cx++;\n\t\t\twhile (grid_reader_handle_wrap(gr, &xx, &yy) &&\n\t\t\t    grid_reader_in_set(gr, separators) &&\n\t\t\t    !grid_reader_in_set(gr, WHITESPACE));\n\t\t} else {\n\t\t\tdo\n\t\t\t\tgr->cx++;\n\t\t\twhile (grid_reader_handle_wrap(gr, &xx, &yy) &&\n\t\t\t    !(grid_reader_in_set(gr, separators) ||\n\t\t\t    grid_reader_in_set(gr, WHITESPACE)));\n\t\t}\n\t}\n\twhile (grid_reader_handle_wrap(gr, &xx, &yy) &&\n\t    (width = grid_reader_in_set(gr, WHITESPACE)))\n\t\tgr->cx += width;\n}\n\n/* Move cursor to the end of the next word. */\nvoid\ngrid_reader_cursor_next_word_end(struct grid_reader *gr, const char *separators)\n{\n\tu_int\txx, yy;\n\n\t/* Do not break up wrapped words. */\n\tif (grid_get_line(gr->gd, gr->cy)->flags & GRID_LINE_WRAPPED)\n\t\txx = gr->gd->sx - 1;\n\telse\n\t\txx = grid_reader_line_length(gr);\n\tyy = gr->gd->hsize + gr->gd->sy - 1;\n\n\t/*\n\t * When navigating via spaces (for example with next-space), separators\n\t * should be empty in both modes.\n\t *\n\t * If we started on a whitespace, move until reaching the first\n\t * non-whitespace character. If that character is a separator, treat\n\t * subsequent separators as a word, and continue moving until the first\n\t * non-separator. Otherwise, continue moving until the first separator\n\t * or whitespace.\n\t */\n\n\twhile (grid_reader_handle_wrap(gr, &xx, &yy)) {\n\t\tif (grid_reader_in_set(gr, WHITESPACE))\n\t\t\tgr->cx++;\n\t\telse if (grid_reader_in_set(gr, separators)) {\n\t\t\tdo\n\t\t\t\tgr->cx++;\n\t\t\twhile (grid_reader_handle_wrap(gr, &xx, &yy) &&\n\t\t\t    grid_reader_in_set(gr, separators) &&\n\t\t\t    !grid_reader_in_set(gr, WHITESPACE));\n\t\t\treturn;\n\t\t} else {\n\t\t\tdo\n\t\t\t\tgr->cx++;\n\t\t\twhile (grid_reader_handle_wrap(gr, &xx, &yy) &&\n\t\t\t    !(grid_reader_in_set(gr, WHITESPACE) ||\n\t\t\t    grid_reader_in_set(gr, separators)));\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/* Move to the previous place where a word begins. */\nvoid\ngrid_reader_cursor_previous_word(struct grid_reader *gr, const char *separators,\n    int already, int stop_at_eol)\n{\n\tint\toldx, oldy, at_eol, word_is_letters;\n\n\t/* Move back to the previous word character. */\n\tif (already || grid_reader_in_set(gr, WHITESPACE)) {\n\t\tfor (;;) {\n\t\t\tif (gr->cx > 0) {\n\t\t\t\tgr->cx--;\n\t\t\t\tif (!grid_reader_in_set(gr, WHITESPACE)) {\n\t\t\t\t\tword_is_letters =\n\t\t\t\t\t    !grid_reader_in_set(gr, separators);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gr->cy == 0)\n\t\t\t\t\treturn;\n\t\t\t\tgrid_reader_cursor_up(gr);\n\t\t\t\tgrid_reader_cursor_end_of_line(gr, 0, 0);\n\n\t\t\t\t/* Stop if separator at EOL. */\n\t\t\t\tif (stop_at_eol && gr->cx > 0) {\n\t\t\t\t\toldx = gr->cx;\n\t\t\t\t\tgr->cx--;\n\t\t\t\t\tat_eol = grid_reader_in_set(gr,\n\t\t\t\t\t    WHITESPACE);\n\t\t\t\t\tgr->cx = oldx;\n\t\t\t\t\tif (at_eol) {\n\t\t\t\t\t\tword_is_letters = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\t\tword_is_letters = !grid_reader_in_set(gr, separators);\n\n\t/* Move back to the beginning of this word. */\n\tdo {\n\t\toldx = gr->cx;\n\t\toldy = gr->cy;\n\t\tif (gr->cx == 0) {\n\t\t\tif (gr->cy == 0 ||\n\t\t\t    (~grid_get_line(gr->gd, gr->cy - 1)->flags &\n\t\t\t    GRID_LINE_WRAPPED))\n\t\t\t\tbreak;\n\t\t\tgrid_reader_cursor_up(gr);\n\t\t\tgrid_reader_cursor_end_of_line(gr, 0, 1);\n\t\t}\n\t\tif (gr->cx > 0)\n\t\t\tgr->cx--;\n\t} while (!grid_reader_in_set(gr, WHITESPACE) &&\n\t    word_is_letters != grid_reader_in_set(gr, separators));\n\tgr->cx = oldx;\n\tgr->cy = oldy;\n}\n\n/* Compare grid cell to UTF-8 data. Return 1 if equal, 0 if not. */\nstatic int\ngrid_reader_cell_equals_data(const struct grid_cell *gc,\n    const struct utf8_data *ud)\n{\n\tif (gc->flags & GRID_FLAG_PADDING)\n\t\treturn (0);\n\tif (gc->flags & GRID_FLAG_TAB && ud->size == 1 && *ud->data == '\\t')\n\t\treturn (1);\n\tif (gc->data.size != ud->size)\n\t\treturn (0);\n\treturn (memcmp(gc->data.data, ud->data, gc->data.size) == 0);\n}\n\n/* Jump forward to character. */\nint\ngrid_reader_cursor_jump(struct grid_reader *gr, const struct utf8_data *jc)\n{\n\tstruct grid_cell\tgc;\n\tu_int\t\t\tpx, py, xx, yy;\n\n\tpx = gr->cx;\n\tyy = gr->gd->hsize + gr->gd->sy - 1;\n\n\tfor (py = gr->cy; py <= yy; py++) {\n\t\txx = grid_line_length(gr->gd, py);\n\t\twhile (px < xx) {\n\t\t\tgrid_get_cell(gr->gd, px, py, &gc);\n\t\t\tif (grid_reader_cell_equals_data(&gc, jc)) {\n\t\t\t\tgr->cx = px;\n\t\t\t\tgr->cy = py;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tpx++;\n\t\t}\n\n\t\tif (py == yy ||\n\t\t    !(grid_get_line(gr->gd, py)->flags & GRID_LINE_WRAPPED))\n\t\t\treturn (0);\n\t\tpx = 0;\n\t}\n\treturn (0);\n}\n\n/* Jump back to character. */\nint\ngrid_reader_cursor_jump_back(struct grid_reader *gr, const struct utf8_data *jc)\n{\n\tstruct grid_cell\tgc;\n\tu_int\t\t\tpx, py, xx;\n\n\txx = gr->cx + 1;\n\n\tfor (py = gr->cy + 1; py > 0; py--) {\n\t\tfor (px = xx; px > 0; px--) {\n\t\t\tgrid_get_cell(gr->gd, px - 1, py - 1, &gc);\n\t\t\tif (grid_reader_cell_equals_data(&gc, jc)) {\n\t\t\t\tgr->cx = px - 1;\n\t\t\t\tgr->cy = py - 1;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t}\n\n\t\tif (py == 1 ||\n\t\t    !(grid_get_line(gr->gd, py - 2)->flags & GRID_LINE_WRAPPED))\n\t\t\treturn (0);\n\t\txx = grid_line_length(gr->gd, py - 2);\n\t}\n\treturn (0);\n}\n\n/* Jump back to the first non-blank character of the line. */\nvoid\ngrid_reader_cursor_back_to_indentation(struct grid_reader *gr)\n{\n\tstruct grid_cell\tgc;\n\tu_int\t\t\tpx, py, xx, yy, oldx, oldy;\n\n\tyy = gr->gd->hsize + gr->gd->sy - 1;\n\toldx = gr->cx;\n\toldy = gr->cy;\n\tgrid_reader_cursor_start_of_line(gr, 1);\n\n\tfor (py = gr->cy; py <= yy; py++) {\n\t\txx = grid_line_length(gr->gd, py);\n\t\tfor (px = 0; px < xx; px++) {\n\t\t\tgrid_get_cell(gr->gd, px, py, &gc);\n\t\t\tif ((gc.data.size != 1 || *gc.data.data != ' ') &&\n\t\t\t    ~gc.flags & GRID_FLAG_TAB &&\n\t\t\t    ~gc.flags & GRID_FLAG_PADDING) {\n\t\t\t\tgr->cx = px;\n\t\t\t\tgr->cy = py;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (~grid_get_line(gr->gd, py)->flags & GRID_LINE_WRAPPED)\n\t\t\tbreak;\n\t}\n\tgr->cx = oldx;\n\tgr->cy = oldy;\n}\n"
        },
        {
          "name": "grid-view.c",
          "type": "blob",
          "size": 5.3994140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Grid view functions. These work using coordinates relative to the visible\n * screen area.\n */\n\n#define grid_view_x(gd, x) (x)\n#define grid_view_y(gd, y) ((gd)->hsize + (y))\n\n/* Get cell. */\nvoid\ngrid_view_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)\n{\n\tgrid_get_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);\n}\n\n/* Set cell. */\nvoid\ngrid_view_set_cell(struct grid *gd, u_int px, u_int py,\n    const struct grid_cell *gc)\n{\n\tgrid_set_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);\n}\n\n/* Set padding. */\nvoid\ngrid_view_set_padding(struct grid *gd, u_int px, u_int py)\n{\n\tgrid_set_padding(gd, grid_view_x(gd, px), grid_view_y(gd, py));\n}\n\n/* Set cells. */\nvoid\ngrid_view_set_cells(struct grid *gd, u_int px, u_int py,\n    const struct grid_cell *gc, const char *s, size_t slen)\n{\n\tgrid_set_cells(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc, s,\n\t    slen);\n}\n\n/* Clear into history. */\nvoid\ngrid_view_clear_history(struct grid *gd, u_int bg)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t yy, last;\n\n\t/* Find the last used line. */\n\tlast = 0;\n\tfor (yy = 0; yy < gd->sy; yy++) {\n\t\tgl = grid_get_line(gd, grid_view_y(gd, yy));\n\t\tif (gl->cellused != 0)\n\t\t\tlast = yy + 1;\n\t}\n\tif (last == 0) {\n\t\tgrid_view_clear(gd, 0, 0, gd->sx, gd->sy, bg);\n\t\treturn;\n\t}\n\n\t/* Scroll the lines into the history. */\n\tfor (yy = 0; yy < last; yy++) {\n\t\tgrid_collect_history(gd);\n\t\tgrid_scroll_history(gd, bg);\n\t}\n\tif (last < gd->sy)\n\t\tgrid_view_clear(gd, 0, 0, gd->sx, gd->sy - last, bg);\n\tgd->hscrolled = 0;\n}\n\n/* Clear area. */\nvoid\ngrid_view_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny,\n    u_int bg)\n{\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tgrid_clear(gd, px, py, nx, ny, bg);\n}\n\n/* Scroll region up. */\nvoid\ngrid_view_scroll_region_up(struct grid *gd, u_int rupper, u_int rlower,\n    u_int bg)\n{\n\tif (gd->flags & GRID_HISTORY) {\n\t\tgrid_collect_history(gd);\n\t\tif (rupper == 0 && rlower == gd->sy - 1)\n\t\t\tgrid_scroll_history(gd, bg);\n\t\telse {\n\t\t\trupper = grid_view_y(gd, rupper);\n\t\t\trlower = grid_view_y(gd, rlower);\n\t\t\tgrid_scroll_history_region(gd, rupper, rlower, bg);\n\t\t}\n\t} else {\n\t\trupper = grid_view_y(gd, rupper);\n\t\trlower = grid_view_y(gd, rlower);\n\t\tgrid_move_lines(gd, rupper, rupper + 1, rlower - rupper, bg);\n\t}\n}\n\n/* Scroll region down. */\nvoid\ngrid_view_scroll_region_down(struct grid *gd, u_int rupper, u_int rlower,\n    u_int bg)\n{\n\trupper = grid_view_y(gd, rupper);\n\trlower = grid_view_y(gd, rlower);\n\n\tgrid_move_lines(gd, rupper + 1, rupper, rlower - rupper, bg);\n}\n\n/* Insert lines. */\nvoid\ngrid_view_insert_lines(struct grid *gd, u_int py, u_int ny, u_int bg)\n{\n\tu_int\tsy;\n\n\tpy = grid_view_y(gd, py);\n\n\tsy = grid_view_y(gd, gd->sy);\n\n\tgrid_move_lines(gd, py + ny, py, sy - py - ny, bg);\n}\n\n/* Insert lines in region. */\nvoid\ngrid_view_insert_lines_region(struct grid *gd, u_int rlower, u_int py,\n    u_int ny, u_int bg)\n{\n\tu_int\tny2;\n\n\trlower = grid_view_y(gd, rlower);\n\n\tpy = grid_view_y(gd, py);\n\n\tny2 = rlower + 1 - py - ny;\n\tgrid_move_lines(gd, rlower + 1 - ny2, py, ny2, bg);\n\tgrid_clear(gd, 0, py + ny2, gd->sx, ny - ny2, bg);\n}\n\n/* Delete lines. */\nvoid\ngrid_view_delete_lines(struct grid *gd, u_int py, u_int ny, u_int bg)\n{\n\tu_int\tsy;\n\n\tpy = grid_view_y(gd, py);\n\n\tsy = grid_view_y(gd, gd->sy);\n\n\tgrid_move_lines(gd, py, py + ny, sy - py - ny, bg);\n\tgrid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny), bg);\n}\n\n/* Delete lines inside scroll region. */\nvoid\ngrid_view_delete_lines_region(struct grid *gd, u_int rlower, u_int py,\n    u_int ny, u_int bg)\n{\n\tu_int\tny2;\n\n\trlower = grid_view_y(gd, rlower);\n\n\tpy = grid_view_y(gd, py);\n\n\tny2 = rlower + 1 - py - ny;\n\tgrid_move_lines(gd, py, py + ny, ny2, bg);\n\tgrid_clear(gd, 0, py + ny2, gd->sx, ny - ny2, bg);\n}\n\n/* Insert characters. */\nvoid\ngrid_view_insert_cells(struct grid *gd, u_int px, u_int py, u_int nx, u_int bg)\n{\n\tu_int\tsx;\n\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tsx = grid_view_x(gd, gd->sx);\n\n\tif (px >= sx - 1)\n\t\tgrid_clear(gd, px, py, 1, 1, bg);\n\telse\n\t\tgrid_move_cells(gd, px + nx, px, py, sx - px - nx, bg);\n}\n\n/* Delete characters. */\nvoid\ngrid_view_delete_cells(struct grid *gd, u_int px, u_int py, u_int nx, u_int bg)\n{\n\tu_int\tsx;\n\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tsx = grid_view_x(gd, gd->sx);\n\n\tgrid_move_cells(gd, px, px + nx, py, sx - px - nx, bg);\n\tgrid_clear(gd, sx - nx, py, px + nx - (sx - nx), 1, bg);\n}\n\n/* Convert cells into a string. */\nchar *\ngrid_view_string_cells(struct grid *gd, u_int px, u_int py, u_int nx)\n{\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\treturn (grid_string_cells(gd, px, py, nx, NULL, 0, NULL));\n}\n"
        },
        {
          "name": "grid.c",
          "type": "blob",
          "size": 35.587890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Grid data. This is the basic data structure that represents what is shown on\n * screen.\n *\n * A grid is a grid of cells (struct grid_cell). Lines are not allocated until\n * cells in that line are written to. The grid is split into history and\n * viewable data with the history starting at row (line) 0 and extending to\n * (hsize - 1); from hsize to hsize + (sy - 1) is the viewable data. All\n * functions in this file work on absolute coordinates, grid-view.c has\n * functions which work on the screen data.\n */\n\n/* Default grid cell data. */\nconst struct grid_cell grid_default_cell = {\n\t{ { ' ' }, 0, 1, 1 }, 0, 0, 8, 8, 8, 0\n};\n\n/*\n * Padding grid cell data. Padding cells are the only zero width cell that\n * appears in the grid - because of this, they are always extended cells.\n */\nstatic const struct grid_cell grid_padding_cell = {\n\t{ { '!' }, 0, 0, 0 }, 0, GRID_FLAG_PADDING, 8, 8, 8, 0\n};\n\n/* Cleared grid cell data. */\nstatic const struct grid_cell grid_cleared_cell = {\n\t{ { ' ' }, 0, 1, 1 }, 0, GRID_FLAG_CLEARED, 8, 8, 8, 0\n};\nstatic const struct grid_cell_entry grid_cleared_entry = {\n\t{ .data = { 0, 8, 8, ' ' } }, GRID_FLAG_CLEARED\n};\n\n/* Store cell in entry. */\nstatic void\ngrid_store_cell(struct grid_cell_entry *gce, const struct grid_cell *gc,\n    u_char c)\n{\n\tgce->flags = (gc->flags & ~GRID_FLAG_CLEARED);\n\n\tgce->data.fg = gc->fg & 0xff;\n\tif (gc->fg & COLOUR_FLAG_256)\n\t\tgce->flags |= GRID_FLAG_FG256;\n\n\tgce->data.bg = gc->bg & 0xff;\n\tif (gc->bg & COLOUR_FLAG_256)\n\t\tgce->flags |= GRID_FLAG_BG256;\n\n\tgce->data.attr = gc->attr;\n\tgce->data.data = c;\n}\n\n/* Check if a cell should be an extended cell. */\nstatic int\ngrid_need_extended_cell(const struct grid_cell_entry *gce,\n    const struct grid_cell *gc)\n{\n\tif (gce->flags & GRID_FLAG_EXTENDED)\n\t\treturn (1);\n\tif (gc->attr > 0xff)\n\t\treturn (1);\n\tif (gc->data.size > 1 || gc->data.width > 1)\n\t\treturn (1);\n\tif ((gc->fg & COLOUR_FLAG_RGB) || (gc->bg & COLOUR_FLAG_RGB))\n\t\treturn (1);\n\tif (gc->us != 8) /* only supports 256 or RGB */\n\t\treturn (1);\n\tif (gc->link != 0)\n\t\treturn (1);\n\tif (gc->flags & GRID_FLAG_TAB)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Get an extended cell. */\nstatic void\ngrid_get_extended_cell(struct grid_line *gl, struct grid_cell_entry *gce,\n    int flags)\n{\n\tu_int at = gl->extdsize + 1;\n\n\tgl->extddata = xreallocarray(gl->extddata, at, sizeof *gl->extddata);\n\tgl->extdsize = at;\n\n\tgce->offset = at - 1;\n\tgce->flags = (flags | GRID_FLAG_EXTENDED);\n}\n\n/* Set cell as extended. */\nstatic struct grid_extd_entry *\ngrid_extended_cell(struct grid_line *gl, struct grid_cell_entry *gce,\n    const struct grid_cell *gc)\n{\n\tstruct grid_extd_entry\t*gee;\n\tint\t\t\t flags = (gc->flags & ~GRID_FLAG_CLEARED);\n\tutf8_char\t\t uc;\n\n\tif (~gce->flags & GRID_FLAG_EXTENDED)\n\t\tgrid_get_extended_cell(gl, gce, flags);\n\telse if (gce->offset >= gl->extdsize)\n\t\tfatalx(\"offset too big\");\n\tgl->flags |= GRID_LINE_EXTENDED;\n\n\tif (gc->flags & GRID_FLAG_TAB)\n\t\tuc = gc->data.width;\n\telse\n\t\tutf8_from_data(&gc->data, &uc);\n\n\tgee = &gl->extddata[gce->offset];\n\tgee->data = uc;\n\tgee->attr = gc->attr;\n\tgee->flags = flags;\n\tgee->fg = gc->fg;\n\tgee->bg = gc->bg;\n\tgee->us = gc->us;\n\tgee->link = gc->link;\n\treturn (gee);\n}\n\n/* Free up unused extended cells. */\nstatic void\ngrid_compact_line(struct grid_line *gl)\n{\n\tint\t\t\t new_extdsize = 0;\n\tstruct grid_extd_entry\t*new_extddata;\n\tstruct grid_cell_entry\t*gce;\n\tstruct grid_extd_entry\t*gee;\n\tu_int\t\t\t px, idx;\n\n\tif (gl->extdsize == 0)\n\t\treturn;\n\n\tfor (px = 0; px < gl->cellsize; px++) {\n\t\tgce = &gl->celldata[px];\n\t\tif (gce->flags & GRID_FLAG_EXTENDED)\n\t\t\tnew_extdsize++;\n\t}\n\n\tif (new_extdsize == 0) {\n\t\tfree(gl->extddata);\n\t\tgl->extddata = NULL;\n\t\tgl->extdsize = 0;\n\t\treturn;\n\t}\n\tnew_extddata = xreallocarray(NULL, new_extdsize, sizeof *gl->extddata);\n\n\tidx = 0;\n\tfor (px = 0; px < gl->cellsize; px++) {\n\t\tgce = &gl->celldata[px];\n\t\tif (gce->flags & GRID_FLAG_EXTENDED) {\n\t\t\tgee = &gl->extddata[gce->offset];\n\t\t\tmemcpy(&new_extddata[idx], gee, sizeof *gee);\n\t\t\tgce->offset = idx++;\n\t\t}\n\t}\n\n\tfree(gl->extddata);\n\tgl->extddata = new_extddata;\n\tgl->extdsize = new_extdsize;\n}\n\n/* Get line data. */\nstruct grid_line *\ngrid_get_line(struct grid *gd, u_int line)\n{\n\treturn (&gd->linedata[line]);\n}\n\n/* Adjust number of lines. */\nvoid\ngrid_adjust_lines(struct grid *gd, u_int lines)\n{\n\tgd->linedata = xreallocarray(gd->linedata, lines, sizeof *gd->linedata);\n}\n\n/* Copy default into a cell. */\nstatic void\ngrid_clear_cell(struct grid *gd, u_int px, u_int py, u_int bg)\n{\n\tstruct grid_line\t*gl = &gd->linedata[py];\n\tstruct grid_cell_entry\t*gce = &gl->celldata[px];\n\tstruct grid_extd_entry\t*gee;\n\n\tmemcpy(gce, &grid_cleared_entry, sizeof *gce);\n\tif (bg != 8) {\n\t\tif (bg & COLOUR_FLAG_RGB) {\n\t\t\tgrid_get_extended_cell(gl, gce, gce->flags);\n\t\t\tgee = grid_extended_cell(gl, gce, &grid_cleared_cell);\n\t\t\tgee->bg = bg;\n\t\t} else {\n\t\t\tif (bg & COLOUR_FLAG_256)\n\t\t\t\tgce->flags |= GRID_FLAG_BG256;\n\t\t\tgce->data.bg = bg;\n\t\t}\n\t}\n}\n\n/* Check grid y position. */\nstatic int\ngrid_check_y(struct grid *gd, const char *from, u_int py)\n{\n\tif (py >= gd->hsize + gd->sy) {\n\t\tlog_debug(\"%s: y out of range: %u\", from, py);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/* Check if two styles are (visibly) the same. */\nint\ngrid_cells_look_equal(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\tint flags1 = gc1->flags, flags2 = gc2->flags;;\n\n\tif (gc1->fg != gc2->fg || gc1->bg != gc2->bg)\n\t\treturn (0);\n\tif (gc1->attr != gc2->attr)\n\t\treturn (0);\n\tif ((flags1 & ~GRID_FLAG_CLEARED) != (flags2 & ~GRID_FLAG_CLEARED))\n\t\treturn (0);\n\tif (gc1->link != gc2->link)\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Compare grid cells. Return 1 if equal, 0 if not. */\nint\ngrid_cells_equal(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\tif (!grid_cells_look_equal(gc1, gc2))\n\t\treturn (0);\n\tif (gc1->data.width != gc2->data.width)\n\t\treturn (0);\n\tif (gc1->data.size != gc2->data.size)\n\t\treturn (0);\n\treturn (memcmp(gc1->data.data, gc2->data.data, gc1->data.size) == 0);\n}\n\n/* Set grid cell to a tab. */\nvoid\ngrid_set_tab(struct grid_cell *gc, u_int width)\n{\n\tmemset(gc->data.data, 0, sizeof gc->data.data);\n\tgc->flags |= GRID_FLAG_TAB;\n\tgc->data.width = gc->data.size = gc->data.have = width;\n\tmemset(gc->data.data, ' ', gc->data.size);\n}\n\n/* Free one line. */\nstatic void\ngrid_free_line(struct grid *gd, u_int py)\n{\n\tfree(gd->linedata[py].celldata);\n\tgd->linedata[py].celldata = NULL;\n\tfree(gd->linedata[py].extddata);\n\tgd->linedata[py].extddata = NULL;\n}\n\n/* Free several lines. */\nstatic void\ngrid_free_lines(struct grid *gd, u_int py, u_int ny)\n{\n\tu_int\tyy;\n\n\tfor (yy = py; yy < py + ny; yy++)\n\t\tgrid_free_line(gd, yy);\n}\n\n/* Create a new grid. */\nstruct grid *\ngrid_create(u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct grid\t*gd;\n\n\tgd = xmalloc(sizeof *gd);\n\tgd->sx = sx;\n\tgd->sy = sy;\n\n\tif (hlimit != 0)\n\t\tgd->flags = GRID_HISTORY;\n\telse\n\t\tgd->flags = 0;\n\n\tgd->hscrolled = 0;\n\tgd->hsize = 0;\n\tgd->hlimit = hlimit;\n\n\tif (gd->sy != 0)\n\t\tgd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);\n\telse\n\t\tgd->linedata = NULL;\n\n\treturn (gd);\n}\n\n/* Destroy grid. */\nvoid\ngrid_destroy(struct grid *gd)\n{\n\tgrid_free_lines(gd, 0, gd->hsize + gd->sy);\n\n\tfree(gd->linedata);\n\n\tfree(gd);\n}\n\n/* Compare grids. */\nint\ngrid_compare(struct grid *ga, struct grid *gb)\n{\n\tstruct grid_line\t*gla, *glb;\n\tstruct grid_cell\t gca, gcb;\n\tu_int\t\t\t xx, yy;\n\n\tif (ga->sx != gb->sx || ga->sy != gb->sy)\n\t\treturn (1);\n\n\tfor (yy = 0; yy < ga->sy; yy++) {\n\t\tgla = &ga->linedata[yy];\n\t\tglb = &gb->linedata[yy];\n\t\tif (gla->cellsize != glb->cellsize)\n\t\t\treturn (1);\n\t\tfor (xx = 0; xx < gla->cellsize; xx++) {\n\t\t\tgrid_get_cell(ga, xx, yy, &gca);\n\t\t\tgrid_get_cell(gb, xx, yy, &gcb);\n\t\t\tif (!grid_cells_equal(&gca, &gcb))\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/* Trim lines from the history. */\nstatic void\ngrid_trim_history(struct grid *gd, u_int ny)\n{\n\tgrid_free_lines(gd, 0, ny);\n\tmemmove(&gd->linedata[0], &gd->linedata[ny],\n\t    (gd->hsize + gd->sy - ny) * (sizeof *gd->linedata));\n}\n\n/*\n * Collect lines from the history if at the limit. Free the top (oldest) 10%\n * and shift up.\n */\nvoid\ngrid_collect_history(struct grid *gd)\n{\n\tu_int\tny;\n\n\tif (gd->hsize == 0 || gd->hsize < gd->hlimit)\n\t\treturn;\n\n\tny = gd->hlimit / 10;\n\tif (ny < 1)\n\t\tny = 1;\n\tif (ny > gd->hsize)\n\t\tny = gd->hsize;\n\n\t/*\n\t * Free the lines from 0 to ny then move the remaining lines over\n\t * them.\n\t */\n\tgrid_trim_history(gd, ny);\n\n\tgd->hsize -= ny;\n\tif (gd->hscrolled > gd->hsize)\n\t\tgd->hscrolled = gd->hsize;\n}\n\n/* Remove lines from the bottom of the history. */\nvoid\ngrid_remove_history(struct grid *gd, u_int ny)\n{\n\tu_int\tyy;\n\n\tif (ny > gd->hsize)\n\t\treturn;\n\tfor (yy = 0; yy < ny; yy++)\n\t\tgrid_free_line(gd, gd->hsize + gd->sy - 1 - yy);\n\tgd->hsize -= ny;\n}\n\n/*\n * Scroll the entire visible screen, moving one line into the history. Just\n * allocate a new line at the bottom and move the history size indicator.\n */\nvoid\ngrid_scroll_history(struct grid *gd, u_int bg)\n{\n\tu_int\tyy;\n\n\tyy = gd->hsize + gd->sy;\n\tgd->linedata = xreallocarray(gd->linedata, yy + 1,\n\t    sizeof *gd->linedata);\n\tgrid_empty_line(gd, yy, bg);\n\n\tgd->hscrolled++;\n\tgrid_compact_line(&gd->linedata[gd->hsize]);\n\tgd->linedata[gd->hsize].time = current_time;\n\tgd->hsize++;\n}\n\n/* Clear the history. */\nvoid\ngrid_clear_history(struct grid *gd)\n{\n\tgrid_trim_history(gd, gd->hsize);\n\n\tgd->hscrolled = 0;\n\tgd->hsize = 0;\n\n\tgd->linedata = xreallocarray(gd->linedata, gd->sy,\n\t    sizeof *gd->linedata);\n}\n\n/* Scroll a region up, moving the top line into the history. */\nvoid\ngrid_scroll_history_region(struct grid *gd, u_int upper, u_int lower, u_int bg)\n{\n\tstruct grid_line\t*gl_history, *gl_upper;\n\tu_int\t\t\t yy;\n\n\t/* Create a space for a new line. */\n\tyy = gd->hsize + gd->sy;\n\tgd->linedata = xreallocarray(gd->linedata, yy + 1,\n\t    sizeof *gd->linedata);\n\n\t/* Move the entire screen down to free a space for this line. */\n\tgl_history = &gd->linedata[gd->hsize];\n\tmemmove(gl_history + 1, gl_history, gd->sy * sizeof *gl_history);\n\n\t/* Adjust the region and find its start and end. */\n\tupper++;\n\tgl_upper = &gd->linedata[upper];\n\tlower++;\n\n\t/* Move the line into the history. */\n\tmemcpy(gl_history, gl_upper, sizeof *gl_history);\n\tgl_history->time = current_time;\n\n\t/* Then move the region up and clear the bottom line. */\n\tmemmove(gl_upper, gl_upper + 1, (lower - upper) * sizeof *gl_upper);\n\tgrid_empty_line(gd, lower, bg);\n\n\t/* Move the history offset down over the line. */\n\tgd->hscrolled++;\n\tgd->hsize++;\n}\n\n/* Expand line to fit to cell. */\nstatic void\ngrid_expand_line(struct grid *gd, u_int py, u_int sx, u_int bg)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t xx;\n\n\tgl = &gd->linedata[py];\n\tif (sx <= gl->cellsize)\n\t\treturn;\n\n\tif (sx < gd->sx / 4)\n\t\tsx = gd->sx / 4;\n\telse if (sx < gd->sx / 2)\n\t\tsx = gd->sx / 2;\n\telse if (gd->sx > sx)\n\t\tsx = gd->sx;\n\n\tgl->celldata = xreallocarray(gl->celldata, sx, sizeof *gl->celldata);\n\tfor (xx = gl->cellsize; xx < sx; xx++)\n\t\tgrid_clear_cell(gd, xx, py, bg);\n\tgl->cellsize = sx;\n}\n\n/* Empty a line and set background colour if needed. */\nvoid\ngrid_empty_line(struct grid *gd, u_int py, u_int bg)\n{\n\tmemset(&gd->linedata[py], 0, sizeof gd->linedata[py]);\n\tif (!COLOUR_DEFAULT(bg))\n\t\tgrid_expand_line(gd, py, gd->sx, bg);\n}\n\n/* Peek at grid line. */\nconst struct grid_line *\ngrid_peek_line(struct grid *gd, u_int py)\n{\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn (NULL);\n\treturn (&gd->linedata[py]);\n}\n\n/* Get cell from line. */\nstatic void\ngrid_get_cell1(struct grid_line *gl, u_int px, struct grid_cell *gc)\n{\n\tstruct grid_cell_entry\t*gce = &gl->celldata[px];\n\tstruct grid_extd_entry\t*gee;\n\n\tif (gce->flags & GRID_FLAG_EXTENDED) {\n\t\tif (gce->offset >= gl->extdsize)\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\telse {\n\t\t\tgee = &gl->extddata[gce->offset];\n\t\t\tgc->flags = gee->flags;\n\t\t\tgc->attr = gee->attr;\n\t\t\tgc->fg = gee->fg;\n\t\t\tgc->bg = gee->bg;\n\t\t\tgc->us = gee->us;\n\t\t\tgc->link = gee->link;\n\n\t\t\tif (gc->flags & GRID_FLAG_TAB)\n\t\t\t\tgrid_set_tab(gc, gee->data);\n\t\t\telse\n\t\t\t\tutf8_to_data(gee->data, &gc->data);\n\t\t}\n\t\treturn;\n\t}\n\n\tgc->flags = gce->flags & ~(GRID_FLAG_FG256|GRID_FLAG_BG256);\n\tgc->attr = gce->data.attr;\n\tgc->fg = gce->data.fg;\n\tif (gce->flags & GRID_FLAG_FG256)\n\t\tgc->fg |= COLOUR_FLAG_256;\n\tgc->bg = gce->data.bg;\n\tif (gce->flags & GRID_FLAG_BG256)\n\t\tgc->bg |= COLOUR_FLAG_256;\n\tgc->us = 8;\n\tutf8_set(&gc->data, gce->data.data);\n\tgc->link = 0;\n}\n\n/* Get cell for reading. */\nvoid\ngrid_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)\n{\n\tif (grid_check_y(gd, __func__, py) != 0 ||\n\t    px >= gd->linedata[py].cellsize)\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\telse\n\t\tgrid_get_cell1(&gd->linedata[py], px, gc);\n}\n\n/* Set cell at position. */\nvoid\ngrid_set_cell(struct grid *gd, u_int px, u_int py, const struct grid_cell *gc)\n{\n\tstruct grid_line\t*gl;\n\tstruct grid_cell_entry\t*gce;\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\n\tgrid_expand_line(gd, py, px + 1, 8);\n\n\tgl = &gd->linedata[py];\n\tif (px + 1 > gl->cellused)\n\t\tgl->cellused = px + 1;\n\n\tgce = &gl->celldata[px];\n\tif (grid_need_extended_cell(gce, gc))\n\t\tgrid_extended_cell(gl, gce, gc);\n\telse\n\t\tgrid_store_cell(gce, gc, gc->data.data[0]);\n}\n\n/* Set padding at position. */\nvoid\ngrid_set_padding(struct grid *gd, u_int px, u_int py)\n{\n\tgrid_set_cell(gd, px, py, &grid_padding_cell);\n}\n\n/* Set cells at position. */\nvoid\ngrid_set_cells(struct grid *gd, u_int px, u_int py, const struct grid_cell *gc,\n    const char *s, size_t slen)\n{\n\tstruct grid_line\t*gl;\n\tstruct grid_cell_entry\t*gce;\n\tstruct grid_extd_entry\t*gee;\n\tu_int\t\t\t i;\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\n\tgrid_expand_line(gd, py, px + slen, 8);\n\n\tgl = &gd->linedata[py];\n\tif (px + slen > gl->cellused)\n\t\tgl->cellused = px + slen;\n\n\tfor (i = 0; i < slen; i++) {\n\t\tgce = &gl->celldata[px + i];\n\t\tif (grid_need_extended_cell(gce, gc)) {\n\t\t\tgee = grid_extended_cell(gl, gce, gc);\n\t\t\tgee->data = utf8_build_one(s[i]);\n\t\t} else\n\t\t\tgrid_store_cell(gce, gc, s[i]);\n\t}\n}\n\n/* Clear area. */\nvoid\ngrid_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny, u_int bg)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t xx, yy, ox, sx;\n\n\tif (nx == 0 || ny == 0)\n\t\treturn;\n\n\tif (px == 0 && nx == gd->sx) {\n\t\tgrid_clear_lines(gd, py, ny, bg);\n\t\treturn;\n\t}\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, __func__, py + ny - 1) != 0)\n\t\treturn;\n\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tgl = &gd->linedata[yy];\n\n\t\tsx = gd->sx;\n\t\tif (sx > gl->cellsize)\n\t\t\tsx = gl->cellsize;\n\t\tox = nx;\n\t\tif (COLOUR_DEFAULT(bg)) {\n\t\t\tif (px > sx)\n\t\t\t\tcontinue;\n\t\t\tif (px + nx > sx)\n\t\t\t\tox = sx - px;\n\t\t}\n\n\t\tgrid_expand_line(gd, yy, px + ox, 8); /* default bg first */\n\t\tfor (xx = px; xx < px + ox; xx++)\n\t\t\tgrid_clear_cell(gd, xx, yy, bg);\n\t}\n}\n\n/* Clear lines. This just frees and truncates the lines. */\nvoid\ngrid_clear_lines(struct grid *gd, u_int py, u_int ny, u_int bg)\n{\n\tu_int\tyy;\n\n\tif (ny == 0)\n\t\treturn;\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, __func__, py + ny - 1) != 0)\n\t\treturn;\n\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tgrid_free_line(gd, yy);\n\t\tgrid_empty_line(gd, yy, bg);\n\t}\n\tif (py != 0)\n\t\tgd->linedata[py - 1].flags &= ~GRID_LINE_WRAPPED;\n}\n\n/* Move a group of lines. */\nvoid\ngrid_move_lines(struct grid *gd, u_int dy, u_int py, u_int ny, u_int bg)\n{\n\tu_int\tyy;\n\n\tif (ny == 0 || py == dy)\n\t\treturn;\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, __func__, py + ny - 1) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, __func__, dy) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, __func__, dy + ny - 1) != 0)\n\t\treturn;\n\n\t/* Free any lines which are being replaced. */\n\tfor (yy = dy; yy < dy + ny; yy++) {\n\t\tif (yy >= py && yy < py + ny)\n\t\t\tcontinue;\n\t\tgrid_free_line(gd, yy);\n\t}\n\tif (dy != 0)\n\t\tgd->linedata[dy - 1].flags &= ~GRID_LINE_WRAPPED;\n\n\tmemmove(&gd->linedata[dy], &gd->linedata[py],\n\t    ny * (sizeof *gd->linedata));\n\n\t/*\n\t * Wipe any lines that have been moved (without freeing them - they are\n\t * still present).\n\t */\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tif (yy < dy || yy >= dy + ny)\n\t\t\tgrid_empty_line(gd, yy, bg);\n\t}\n\tif (py != 0 && (py < dy || py >= dy + ny))\n\t\tgd->linedata[py - 1].flags &= ~GRID_LINE_WRAPPED;\n}\n\n/* Move a group of cells. */\nvoid\ngrid_move_cells(struct grid *gd, u_int dx, u_int px, u_int py, u_int nx,\n    u_int bg)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t xx;\n\n\tif (nx == 0 || px == dx)\n\t\treturn;\n\n\tif (grid_check_y(gd, __func__, py) != 0)\n\t\treturn;\n\tgl = &gd->linedata[py];\n\n\tgrid_expand_line(gd, py, px + nx, 8);\n\tgrid_expand_line(gd, py, dx + nx, 8);\n\tmemmove(&gl->celldata[dx], &gl->celldata[px],\n\t    nx * sizeof *gl->celldata);\n\tif (dx + nx > gl->cellused)\n\t\tgl->cellused = dx + nx;\n\n\t/* Wipe any cells that have been moved. */\n\tfor (xx = px; xx < px + nx; xx++) {\n\t\tif (xx >= dx && xx < dx + nx)\n\t\t\tcontinue;\n\t\tgrid_clear_cell(gd, xx, py, bg);\n\t}\n}\n\n/* Get ANSI foreground sequence. */\nstatic size_t\ngrid_string_cells_fg(const struct grid_cell *gc, int *values)\n{\n\tsize_t\tn;\n\tu_char\tr, g, b;\n\n\tn = 0;\n\tif (gc->fg & COLOUR_FLAG_256) {\n\t\tvalues[n++] = 38;\n\t\tvalues[n++] = 5;\n\t\tvalues[n++] = gc->fg & 0xff;\n\t} else if (gc->fg & COLOUR_FLAG_RGB) {\n\t\tvalues[n++] = 38;\n\t\tvalues[n++] = 2;\n\t\tcolour_split_rgb(gc->fg, &r, &g, &b);\n\t\tvalues[n++] = r;\n\t\tvalues[n++] = g;\n\t\tvalues[n++] = b;\n\t} else {\n\t\tswitch (gc->fg) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tvalues[n++] = gc->fg + 30;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalues[n++] = 39;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tvalues[n++] = gc->fg;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (n);\n}\n\n/* Get ANSI background sequence. */\nstatic size_t\ngrid_string_cells_bg(const struct grid_cell *gc, int *values)\n{\n\tsize_t\tn;\n\tu_char\tr, g, b;\n\n\tn = 0;\n\tif (gc->bg & COLOUR_FLAG_256) {\n\t\tvalues[n++] = 48;\n\t\tvalues[n++] = 5;\n\t\tvalues[n++] = gc->bg & 0xff;\n\t} else if (gc->bg & COLOUR_FLAG_RGB) {\n\t\tvalues[n++] = 48;\n\t\tvalues[n++] = 2;\n\t\tcolour_split_rgb(gc->bg, &r, &g, &b);\n\t\tvalues[n++] = r;\n\t\tvalues[n++] = g;\n\t\tvalues[n++] = b;\n\t} else {\n\t\tswitch (gc->bg) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tvalues[n++] = gc->bg + 40;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalues[n++] = 49;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tvalues[n++] = gc->bg + 10;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (n);\n}\n\n/* Get underscore colour sequence. */\nstatic size_t\ngrid_string_cells_us(const struct grid_cell *gc, int *values)\n{\n\tsize_t\tn;\n\tu_char\tr, g, b;\n\n\tn = 0;\n\tif (gc->us & COLOUR_FLAG_256) {\n\t\tvalues[n++] = 58;\n\t\tvalues[n++] = 5;\n\t\tvalues[n++] = gc->us & 0xff;\n\t} else if (gc->us & COLOUR_FLAG_RGB) {\n\t\tvalues[n++] = 58;\n\t\tvalues[n++] = 2;\n\t\tcolour_split_rgb(gc->us, &r, &g, &b);\n\t\tvalues[n++] = r;\n\t\tvalues[n++] = g;\n\t\tvalues[n++] = b;\n\t}\n\treturn (n);\n}\n\n/* Add on SGR code. */\nstatic void\ngrid_string_cells_add_code(char *buf, size_t len, u_int n, int *s, int *newc,\n    int *oldc, size_t nnewc, size_t noldc, int flags)\n{\n\tu_int\ti;\n\tchar\ttmp[64];\n\tint\treset = (n != 0 && s[0] == 0);\n\n\tif (nnewc == 0)\n\t\treturn; /* no code to add */\n\tif (!reset &&\n\t    nnewc == noldc &&\n\t    memcmp(newc, oldc, nnewc * sizeof newc[0]) == 0)\n\t\treturn; /* no reset and colour unchanged */\n\tif (reset && (newc[0] == 49 || newc[0] == 39))\n\t\treturn; /* reset and colour default */\n\n\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\tstrlcat(buf, \"\\\\033[\", len);\n\telse\n\t\tstrlcat(buf, \"\\033[\", len);\n\tfor (i = 0; i < nnewc; i++) {\n\t\tif (i + 1 < nnewc)\n\t\t\txsnprintf(tmp, sizeof tmp, \"%d;\", newc[i]);\n\t\telse\n\t\t\txsnprintf(tmp, sizeof tmp, \"%d\", newc[i]);\n\t\tstrlcat(buf, tmp, len);\n\t}\n\tstrlcat(buf, \"m\", len);\n}\n\nstatic int\ngrid_string_cells_add_hyperlink(char *buf, size_t len, const char *id,\n    const char *uri, int flags)\n{\n\tchar\t*tmp;\n\n\tif (strlen(uri) + strlen(id) + 17 >= len)\n\t\treturn (0);\n\n\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\tstrlcat(buf, \"\\\\033]8;\", len);\n\telse\n\t\tstrlcat(buf, \"\\033]8;\", len);\n\tif (*id != '\\0') {\n\t\txasprintf(&tmp, \"id=%s;\", id);\n\t\tstrlcat(buf, tmp, len);\n\t\tfree(tmp);\n\t} else\n\t\tstrlcat(buf, \";\", len);\n\tstrlcat(buf, uri, len);\n\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\tstrlcat(buf, \"\\\\033\\\\\\\\\", len);\n\telse\n\t\tstrlcat(buf, \"\\033\\\\\", len);\n\treturn (1);\n}\n\n/*\n * Returns ANSI code to set particular attributes (colour, bold and so on)\n * given a current state.\n */\nstatic void\ngrid_string_cells_code(const struct grid_cell *lastgc,\n    const struct grid_cell *gc, char *buf, size_t len, int flags,\n    struct screen *sc, int *has_link)\n{\n\tint\t\t\t oldc[64], newc[64], s[128];\n\tsize_t\t\t\t noldc, nnewc, n, i;\n\tu_int\t\t\t attr = gc->attr, lastattr = lastgc->attr;\n\tchar\t\t\t tmp[64];\n\tconst char\t\t*uri, *id;\n\n\tstatic const struct {\n\t\tu_int\tmask;\n\t\tu_int\tcode;\n\t} attrs[] = {\n\t\t{ GRID_ATTR_BRIGHT, 1 },\n\t\t{ GRID_ATTR_DIM, 2 },\n\t\t{ GRID_ATTR_ITALICS, 3 },\n\t\t{ GRID_ATTR_UNDERSCORE, 4 },\n\t\t{ GRID_ATTR_BLINK, 5 },\n\t\t{ GRID_ATTR_REVERSE, 7 },\n\t\t{ GRID_ATTR_HIDDEN, 8 },\n\t\t{ GRID_ATTR_STRIKETHROUGH, 9 },\n\t\t{ GRID_ATTR_UNDERSCORE_2, 42 },\n\t\t{ GRID_ATTR_UNDERSCORE_3, 43 },\n\t\t{ GRID_ATTR_UNDERSCORE_4, 44 },\n\t\t{ GRID_ATTR_UNDERSCORE_5, 45 },\n\t\t{ GRID_ATTR_OVERLINE, 53 },\n\t};\n\tn = 0;\n\n\t/* If any attribute is removed, begin with 0. */\n\tfor (i = 0; i < nitems(attrs); i++) {\n\t\tif (((~attr & attrs[i].mask) &&\n\t\t    (lastattr & attrs[i].mask)) ||\n\t\t    (lastgc->us != 8 && gc->us == 8)) {\n\t\t\ts[n++] = 0;\n\t\t\tlastattr &= GRID_ATTR_CHARSET;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* For each attribute that is newly set, add its code. */\n\tfor (i = 0; i < nitems(attrs); i++) {\n\t\tif ((attr & attrs[i].mask) && !(lastattr & attrs[i].mask))\n\t\t\ts[n++] = attrs[i].code;\n\t}\n\n\t/* Write the attributes. */\n\t*buf = '\\0';\n\tif (n > 0) {\n\t\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\t\tstrlcat(buf, \"\\\\033[\", len);\n\t\telse\n\t\t\tstrlcat(buf, \"\\033[\", len);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (s[i] < 10)\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"%d\", s[i]);\n\t\t\telse {\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"%d:%d\", s[i] / 10,\n\t\t\t\t    s[i] % 10);\n\t\t\t}\n\t\t\tstrlcat(buf, tmp, len);\n\t\t\tif (i + 1 < n)\n\t\t\t\tstrlcat(buf, \";\", len);\n\t\t}\n\t\tstrlcat(buf, \"m\", len);\n\t}\n\n\t/* If the foreground colour changed, write its parameters. */\n\tnnewc = grid_string_cells_fg(gc, newc);\n\tnoldc = grid_string_cells_fg(lastgc, oldc);\n\tgrid_string_cells_add_code(buf, len, n, s, newc, oldc, nnewc, noldc,\n\t    flags);\n\n\t/* If the background colour changed, append its parameters. */\n\tnnewc = grid_string_cells_bg(gc, newc);\n\tnoldc = grid_string_cells_bg(lastgc, oldc);\n\tgrid_string_cells_add_code(buf, len, n, s, newc, oldc, nnewc, noldc,\n\t    flags);\n\n\t/* If the underscore colour changed, append its parameters. */\n\tnnewc = grid_string_cells_us(gc, newc);\n\tnoldc = grid_string_cells_us(lastgc, oldc);\n\tgrid_string_cells_add_code(buf, len, n, s, newc, oldc, nnewc, noldc,\n\t    flags);\n\n\t/* Append shift in/shift out if needed. */\n\tif ((attr & GRID_ATTR_CHARSET) && !(lastattr & GRID_ATTR_CHARSET)) {\n\t\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\t\tstrlcat(buf, \"\\\\016\", len); /* SO */\n\t\telse\n\t\t\tstrlcat(buf, \"\\016\", len);  /* SO */\n\t}\n\tif (!(attr & GRID_ATTR_CHARSET) && (lastattr & GRID_ATTR_CHARSET)) {\n\t\tif (flags & GRID_STRING_ESCAPE_SEQUENCES)\n\t\t\tstrlcat(buf, \"\\\\017\", len); /* SI */\n\t\telse\n\t\t\tstrlcat(buf, \"\\017\", len);  /* SI */\n\t}\n\n\t/* Add hyperlink if changed. */\n\tif (sc != NULL && sc->hyperlinks != NULL && lastgc->link != gc->link) {\n\t\tif (hyperlinks_get(sc->hyperlinks, gc->link, &uri, &id, NULL)) {\n\t\t\t*has_link = grid_string_cells_add_hyperlink(buf, len,\n\t\t\t    id, uri, flags);\n\t\t} else if (*has_link) {\n\t\t\tgrid_string_cells_add_hyperlink(buf, len, \"\", \"\",\n\t\t\t    flags);\n\t\t\t*has_link = 0;\n\t\t}\n\t}\n}\n\n/* Convert cells into a string. */\nchar *\ngrid_string_cells(struct grid *gd, u_int px, u_int py, u_int nx,\n    struct grid_cell **lastgc, int flags, struct screen *s)\n{\n\tstruct grid_cell\t gc;\n\tstatic struct grid_cell\t lastgc1;\n\tconst char\t\t*data;\n\tchar\t\t\t*buf, code[8192];\n\tsize_t\t\t\t len, off, size, codelen;\n\tu_int\t\t\t xx, end;\n\tint\t\t\t has_link = 0;\n\tconst struct grid_line\t*gl;\n\n\tif (lastgc != NULL && *lastgc == NULL) {\n\t\tmemcpy(&lastgc1, &grid_default_cell, sizeof lastgc1);\n\t\t*lastgc = &lastgc1;\n\t}\n\n\tlen = 128;\n\tbuf = xmalloc(len);\n\toff = 0;\n\n\tgl = grid_peek_line(gd, py);\n\tif (flags & GRID_STRING_EMPTY_CELLS)\n\t\tend = gl->cellsize;\n\telse\n\t\tend = gl->cellused;\n\tfor (xx = px; xx < px + nx; xx++) {\n\t\tif (gl == NULL || xx >= end)\n\t\t\tbreak;\n\t\tgrid_get_cell(gd, xx, py, &gc);\n\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\tcontinue;\n\n\t\tif (flags & GRID_STRING_WITH_SEQUENCES) {\n\t\t\tgrid_string_cells_code(*lastgc, &gc, code, sizeof code,\n\t\t\t    flags, s, &has_link);\n\t\t\tcodelen = strlen(code);\n\t\t\tmemcpy(*lastgc, &gc, sizeof **lastgc);\n\t\t} else\n\t\t\tcodelen = 0;\n\n\t\tif (gc.flags & GRID_FLAG_TAB) {\n\t\t\tdata = \"\\t\";\n\t\t\tsize = 1;\n\t\t} else {\n\t\t\tdata = gc.data.data;\n\t\t\tsize = gc.data.size;\n\t\t\tif ((flags & GRID_STRING_ESCAPE_SEQUENCES) &&\n\t\t\t    size == 1 &&\n\t\t\t    *data == '\\\\') {\n\t\t\t\tdata = \"\\\\\\\\\";\n\t\t\t\tsize = 2;\n\t\t\t}\n\t\t}\n\n\t\twhile (len < off + size + codelen + 1) {\n\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\tlen *= 2;\n\t\t}\n\n\t\tif (codelen != 0) {\n\t\t\tmemcpy(buf + off, code, codelen);\n\t\t\toff += codelen;\n\t\t}\n\t\tmemcpy(buf + off, data, size);\n\t\toff += size;\n\t}\n\n\tif (has_link) {\n\t\tgrid_string_cells_add_hyperlink(code, sizeof code, \"\", \"\",\n\t\t    flags);\n\t\tcodelen = strlen(code);\n\t\twhile (len < off + size + codelen + 1) {\n\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\tlen *= 2;\n\t\t}\n\t\tmemcpy(buf + off, code, codelen);\n\t\toff += codelen;\n\t}\n\n\tif (flags & GRID_STRING_TRIM_SPACES) {\n\t\twhile (off > 0 && buf[off - 1] == ' ')\n\t\t\toff--;\n\t}\n\tbuf[off] = '\\0';\n\n\treturn (buf);\n}\n\n/*\n * Duplicate a set of lines between two grids. Both source and destination\n * should be big enough.\n */\nvoid\ngrid_duplicate_lines(struct grid *dst, u_int dy, struct grid *src, u_int sy,\n    u_int ny)\n{\n\tstruct grid_line\t*dstl, *srcl;\n\tu_int\t\t\t yy;\n\n\tif (dy + ny > dst->hsize + dst->sy)\n\t\tny = dst->hsize + dst->sy - dy;\n\tif (sy + ny > src->hsize + src->sy)\n\t\tny = src->hsize + src->sy - sy;\n\tgrid_free_lines(dst, dy, ny);\n\n\tfor (yy = 0; yy < ny; yy++) {\n\t\tsrcl = &src->linedata[sy];\n\t\tdstl = &dst->linedata[dy];\n\n\t\tmemcpy(dstl, srcl, sizeof *dstl);\n\t\tif (srcl->cellsize != 0) {\n\t\t\tdstl->celldata = xreallocarray(NULL,\n\t\t\t    srcl->cellsize, sizeof *dstl->celldata);\n\t\t\tmemcpy(dstl->celldata, srcl->celldata,\n\t\t\t    srcl->cellsize * sizeof *dstl->celldata);\n\t\t} else\n\t\t\tdstl->celldata = NULL;\n\t\tif (srcl->extdsize != 0) {\n\t\t\tdstl->extdsize = srcl->extdsize;\n\t\t\tdstl->extddata = xreallocarray(NULL, dstl->extdsize,\n\t\t\t    sizeof *dstl->extddata);\n\t\t\tmemcpy(dstl->extddata, srcl->extddata, dstl->extdsize *\n\t\t\t    sizeof *dstl->extddata);\n\t\t} else\n\t\t\tdstl->extddata = NULL;\n\n\t\tsy++;\n\t\tdy++;\n\t}\n}\n\n/* Mark line as dead. */\nstatic void\ngrid_reflow_dead(struct grid_line *gl)\n{\n\tmemset(gl, 0, sizeof *gl);\n\tgl->flags = GRID_LINE_DEAD;\n}\n\n/* Add lines, return the first new one. */\nstatic struct grid_line *\ngrid_reflow_add(struct grid *gd, u_int n)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t sy = gd->sy + n;\n\n\tgd->linedata = xreallocarray(gd->linedata, sy, sizeof *gd->linedata);\n\tgl = &gd->linedata[gd->sy];\n\tmemset(gl, 0, n * (sizeof *gl));\n\tgd->sy = sy;\n\treturn (gl);\n}\n\n/* Move a line across. */\nstatic struct grid_line *\ngrid_reflow_move(struct grid *gd, struct grid_line *from)\n{\n\tstruct grid_line\t*to;\n\n\tto = grid_reflow_add(gd, 1);\n\tmemcpy(to, from, sizeof *to);\n\tgrid_reflow_dead(from);\n\treturn (to);\n}\n\n/* Join line below onto this one. */\nstatic void\ngrid_reflow_join(struct grid *target, struct grid *gd, u_int sx, u_int yy,\n    u_int width, int already)\n{\n\tstruct grid_line\t*gl, *from = NULL;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t lines, left, i, to, line, want = 0;\n\tu_int\t\t\t at;\n\tint\t\t\t wrapped = 1;\n\n\t/*\n\t * Add a new target line.\n\t */\n\tif (!already) {\n\t\tto = target->sy;\n\t\tgl = grid_reflow_move(target, &gd->linedata[yy]);\n\t} else {\n\t\tto = target->sy - 1;\n\t\tgl = &target->linedata[to];\n\t}\n\tat = gl->cellused;\n\n\t/*\n\t * Loop until no more to consume or the target line is full.\n\t */\n\tlines = 0;\n\tfor (;;) {\n\t\t/*\n\t\t * If this is now the last line, there is nothing more to be\n\t\t * done.\n\t\t */\n\t\tif (yy + 1 + lines == gd->hsize + gd->sy)\n\t\t\tbreak;\n\t\tline = yy + 1 + lines;\n\n\t\t/* If the next line is empty, skip it. */\n\t\tif (~gd->linedata[line].flags & GRID_LINE_WRAPPED)\n\t\t\twrapped = 0;\n\t\tif (gd->linedata[line].cellused == 0) {\n\t\t\tif (!wrapped)\n\t\t\t\tbreak;\n\t\t\tlines++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Is the destination line now full? Copy the first character\n\t\t * separately because we need to leave \"from\" set to the last\n\t\t * line if this line is full.\n\t\t */\n\t\tgrid_get_cell1(&gd->linedata[line], 0, &gc);\n\t\tif (width + gc.data.width > sx)\n\t\t\tbreak;\n\t\twidth += gc.data.width;\n\t\tgrid_set_cell(target, at, to, &gc);\n\t\tat++;\n\n\t\t/* Join as much more as possible onto the current line. */\n\t\tfrom = &gd->linedata[line];\n\t\tfor (want = 1; want < from->cellused; want++) {\n\t\t\tgrid_get_cell1(from, want, &gc);\n\t\t\tif (width + gc.data.width > sx)\n\t\t\t\tbreak;\n\t\t\twidth += gc.data.width;\n\n\t\t\tgrid_set_cell(target, at, to, &gc);\n\t\t\tat++;\n\t\t}\n\t\tlines++;\n\n\t\t/*\n\t\t * If this line wasn't wrapped or we didn't consume the entire\n\t\t * line, don't try to join any further lines.\n\t\t */\n\t\tif (!wrapped || want != from->cellused || width == sx)\n\t\t\tbreak;\n\t}\n\tif (lines == 0)\n\t\treturn;\n\n\t/*\n\t * If we didn't consume the entire final line, then remove what we did\n\t * consume. If we consumed the entire line and it wasn't wrapped,\n\t * remove the wrap flag from this line.\n\t */\n\tleft = from->cellused - want;\n\tif (left != 0) {\n\t\tgrid_move_cells(gd, 0, want, yy + lines, left, 8);\n\t\tfrom->cellsize = from->cellused = left;\n\t\tlines--;\n\t} else if (!wrapped)\n\t\tgl->flags &= ~GRID_LINE_WRAPPED;\n\n\t/* Remove the lines that were completely consumed. */\n\tfor (i = yy + 1; i < yy + 1 + lines; i++) {\n\t\tfree(gd->linedata[i].celldata);\n\t\tfree(gd->linedata[i].extddata);\n\t\tgrid_reflow_dead(&gd->linedata[i]);\n\t}\n\n\t/* Adjust scroll position. */\n\tif (gd->hscrolled > to + lines)\n\t\tgd->hscrolled -= lines;\n\telse if (gd->hscrolled > to)\n\t\tgd->hscrolled = to;\n}\n\n/* Split this line into several new ones */\nstatic void\ngrid_reflow_split(struct grid *target, struct grid *gd, u_int sx, u_int yy,\n    u_int at)\n{\n\tstruct grid_line\t*gl = &gd->linedata[yy], *first;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t line, lines, width, i, xx;\n\tu_int\t\t\t used = gl->cellused;\n\tint\t\t\t flags = gl->flags;\n\n\t/* How many lines do we need to insert? We know we need at least two. */\n\tif (~gl->flags & GRID_LINE_EXTENDED)\n\t\tlines = 1 + (gl->cellused - 1) / sx;\n\telse {\n\t\tlines = 2;\n\t\twidth = 0;\n\t\tfor (i = at; i < used; i++) {\n\t\t\tgrid_get_cell1(gl, i, &gc);\n\t\t\tif (width + gc.data.width > sx) {\n\t\t\t\tlines++;\n\t\t\t\twidth = 0;\n\t\t\t}\n\t\t\twidth += gc.data.width;\n\t\t}\n\t}\n\n\t/* Insert new lines. */\n\tline = target->sy + 1;\n\tfirst = grid_reflow_add(target, lines);\n\n\t/* Copy sections from the original line. */\n\twidth = 0;\n\txx = 0;\n\tfor (i = at; i < used; i++) {\n\t\tgrid_get_cell1(gl, i, &gc);\n\t\tif (width + gc.data.width > sx) {\n\t\t\ttarget->linedata[line].flags |= GRID_LINE_WRAPPED;\n\n\t\t\tline++;\n\t\t\twidth = 0;\n\t\t\txx = 0;\n\t\t}\n\t\twidth += gc.data.width;\n\t\tgrid_set_cell(target, xx, line, &gc);\n\t\txx++;\n\t}\n\tif (flags & GRID_LINE_WRAPPED)\n\t\ttarget->linedata[line].flags |= GRID_LINE_WRAPPED;\n\n\t/* Move the remainder of the original line. */\n\tgl->cellsize = gl->cellused = at;\n\tgl->flags |= GRID_LINE_WRAPPED;\n\tmemcpy(first, gl, sizeof *first);\n\tgrid_reflow_dead(gl);\n\n\t/* Adjust the scroll position. */\n\tif (yy <= gd->hscrolled)\n\t\tgd->hscrolled += lines - 1;\n\n\t/*\n\t * If the original line had the wrapped flag and there is still space\n\t * in the last new line, try to join with the next lines.\n\t */\n\tif (width < sx && (flags & GRID_LINE_WRAPPED))\n\t\tgrid_reflow_join(target, gd, sx, yy, width, 1);\n}\n\n/* Reflow lines on grid to new width. */\nvoid\ngrid_reflow(struct grid *gd, u_int sx)\n{\n\tstruct grid\t\t*target;\n\tstruct grid_line\t*gl;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t yy, width, i, at;\n\n\t/*\n\t * Create a destination grid. This is just used as a container for the\n\t * line data and may not be fully valid.\n\t */\n\ttarget = grid_create(gd->sx, 0, 0);\n\n\t/*\n\t * Loop over each source line.\n\t */\n\tfor (yy = 0; yy < gd->hsize + gd->sy; yy++) {\n\t\tgl = &gd->linedata[yy];\n\t\tif (gl->flags & GRID_LINE_DEAD)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Work out the width of this line. at is the point at which\n\t\t * the available width is hit, and width is the full line\n\t\t * width.\n\t\t */\n\t\tat = width = 0;\n\t\tif (~gl->flags & GRID_LINE_EXTENDED) {\n\t\t\twidth = gl->cellused;\n\t\t\tif (width > sx)\n\t\t\t\tat = sx;\n\t\t\telse\n\t\t\t\tat = width;\n\t\t} else {\n\t\t\tfor (i = 0; i < gl->cellused; i++) {\n\t\t\t\tgrid_get_cell1(gl, i, &gc);\n\t\t\t\tif (at == 0 && width + gc.data.width > sx)\n\t\t\t\t\tat = i;\n\t\t\t\twidth += gc.data.width;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the line is exactly right, just move it across\n\t\t * unchanged.\n\t\t */\n\t\tif (width == sx) {\n\t\t\tgrid_reflow_move(target, gl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the line is too big, it needs to be split, whether or not\n\t\t * it was previously wrapped.\n\t\t */\n\t\tif (width > sx) {\n\t\t\tgrid_reflow_split(target, gd, sx, yy, at);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the line was previously wrapped, join as much as possible\n\t\t * of the next line.\n\t\t */\n\t\tif (gl->flags & GRID_LINE_WRAPPED)\n\t\t\tgrid_reflow_join(target, gd, sx, yy, width, 0);\n\t\telse\n\t\t\tgrid_reflow_move(target, gl);\n\t}\n\n\t/*\n\t * Replace the old grid with the new.\n\t */\n\tif (target->sy < gd->sy)\n\t\tgrid_reflow_add(target, gd->sy - target->sy);\n\tgd->hsize = target->sy - gd->sy;\n\tif (gd->hscrolled > gd->hsize)\n\t\tgd->hscrolled = gd->hsize;\n\tfree(gd->linedata);\n\tgd->linedata = target->linedata;\n\tfree(target);\n}\n\n/* Convert to position based on wrapped lines. */\nvoid\ngrid_wrap_position(struct grid *gd, u_int px, u_int py, u_int *wx, u_int *wy)\n{\n\tu_int\tax = 0, ay = 0, yy;\n\n\tfor (yy = 0; yy < py; yy++) {\n\t\tif (gd->linedata[yy].flags & GRID_LINE_WRAPPED)\n\t\t\tax += gd->linedata[yy].cellused;\n\t\telse {\n\t\t\tax = 0;\n\t\t\tay++;\n\t\t}\n\t}\n\tif (px >= gd->linedata[yy].cellused)\n\t\tax = UINT_MAX;\n\telse\n\t\tax += px;\n\t*wx = ax;\n\t*wy = ay;\n}\n\n/* Convert position based on wrapped lines back. */\nvoid\ngrid_unwrap_position(struct grid *gd, u_int *px, u_int *py, u_int wx, u_int wy)\n{\n\tu_int\tyy, ay = 0;\n\n\tfor (yy = 0; yy < gd->hsize + gd->sy - 1; yy++) {\n\t\tif (ay == wy)\n\t\t\tbreak;\n\t\tif (~gd->linedata[yy].flags & GRID_LINE_WRAPPED)\n\t\t\tay++;\n\t}\n\n\t/*\n\t * yy is now 0 on the unwrapped line which contains wx. Walk forwards\n\t * until we find the end or the line now containing wx.\n\t */\n\tif (wx == UINT_MAX) {\n\t\twhile (gd->linedata[yy].flags & GRID_LINE_WRAPPED)\n\t\t\tyy++;\n\t\twx = gd->linedata[yy].cellused;\n\t} else {\n\t\twhile (gd->linedata[yy].flags & GRID_LINE_WRAPPED) {\n\t\t\tif (wx < gd->linedata[yy].cellused)\n\t\t\t\tbreak;\n\t\t\twx -= gd->linedata[yy].cellused;\n\t\t\tyy++;\n\t\t}\n\t}\n\t*px = wx;\n\t*py = yy;\n}\n\n/* Get length of line. */\nu_int\ngrid_line_length(struct grid *gd, u_int py)\n{\n\tstruct grid_cell\tgc;\n\tu_int\t\t\tpx;\n\n\tpx = grid_get_line(gd, py)->cellsize;\n\tif (px > gd->sx)\n\t\tpx = gd->sx;\n\twhile (px > 0) {\n\t\tgrid_get_cell(gd, px - 1, py, &gc);\n\t\tif ((gc.flags & GRID_FLAG_PADDING) ||\n\t\t    gc.data.size != 1 ||\n\t\t    *gc.data.data != ' ')\n\t\t\tbreak;\n\t\tpx--;\n\t}\n\treturn (px);\n}\n\n/* Check if character is in set. */\nint\ngrid_in_set(struct grid *gd, u_int px, u_int py, const char *set)\n{\n\tstruct grid_cell\tgc, tmp_gc;\n\tu_int\t\t\tpxx;\n\n\tgrid_get_cell(gd, px, py, &gc);\n\tif (strchr(set, '\\t')) {\n\t\tif (gc.flags & GRID_FLAG_PADDING) {\n\t\t\tpxx = px;\n\t\t\tdo\n\t\t\t\tgrid_get_cell(gd, --pxx, py, &tmp_gc);\n\t\t\twhile (pxx > 0 && tmp_gc.flags & GRID_FLAG_PADDING);\n\t\t\tif (tmp_gc.flags & GRID_FLAG_TAB)\n\t\t\t\treturn (tmp_gc.data.width - (px - pxx));\n\t\t} else if (gc.flags & GRID_FLAG_TAB)\n\t\t\treturn (gc.data.width);\n\t}\n\tif (gc.flags & GRID_FLAG_PADDING)\n\t\treturn (0);\n\treturn (utf8_cstrhas(set, &gc.data));\n}\n"
        },
        {
          "name": "hyperlinks.c",
          "type": "blob",
          "size": 6.416015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2021 Will <author@will.party>\n * Copyright (c) 2022 Jeff Chiang <pobomp@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * OSC 8 hyperlinks, described at:\n *\n *     https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda\n *\n * Each hyperlink and ID combination is assigned a number (\"inner\" in this\n * file) which is stored in an extended grid cell and maps into a tree here.\n *\n * Each URI has one inner number and one external ID (which tmux uses to send\n * the hyperlink to the terminal) and one internal ID (which is received from\n * the sending application inside tmux).\n *\n * Anonymous hyperlinks are each unique and are not reused even if they have\n * the same URI (terminals will not want to tie them together).\n */\n\n#define MAX_HYPERLINKS 5000\n\nstatic long long hyperlinks_next_external_id = 1;\nstatic u_int global_hyperlinks_count;\n\nstruct hyperlinks_uri {\n\tstruct hyperlinks\t*tree;\n\n\tu_int\t\t\t inner;\n\tconst char\t\t*internal_id;\n\tconst char\t\t*external_id;\n\tconst char\t\t*uri;\n\n\tTAILQ_ENTRY(hyperlinks_uri) list_entry;\n\tRB_ENTRY(hyperlinks_uri)    by_inner_entry;\n\tRB_ENTRY(hyperlinks_uri)    by_uri_entry; /* by internal ID and URI */\n};\nRB_HEAD(hyperlinks_by_uri_tree, hyperlinks_uri);\nRB_HEAD(hyperlinks_by_inner_tree, hyperlinks_uri);\n\nTAILQ_HEAD(hyperlinks_list, hyperlinks_uri);\nstatic struct hyperlinks_list global_hyperlinks =\n    TAILQ_HEAD_INITIALIZER(global_hyperlinks);\n\nstruct hyperlinks {\n\tu_int\t\t\t\tnext_inner;\n\tstruct hyperlinks_by_inner_tree\tby_inner;\n\tstruct hyperlinks_by_uri_tree\tby_uri;\n\tu_int\t\t\t\treferences;\n};\n\nstatic int\nhyperlinks_by_uri_cmp(struct hyperlinks_uri *left, struct hyperlinks_uri *right)\n{\n\tint\tr;\n\n\tif (*left->internal_id == '\\0' || *right->internal_id == '\\0') {\n\t\t/*\n\t\t * If both URIs are anonymous, use the inner for comparison so\n\t\t * that they do not match even if the URI is the same - each\n\t\t * anonymous URI should be unique.\n\t\t */\n\t\tif (*left->internal_id != '\\0')\n\t\t\treturn (-1);\n\t\tif (*right->internal_id != '\\0')\n\t\t\treturn (1);\n\t\treturn (left->inner - right->inner);\n\t}\n\n\tr = strcmp(left->internal_id, right->internal_id);\n\tif (r != 0)\n\t\treturn (r);\n\treturn (strcmp(left->uri, right->uri));\n}\nRB_PROTOTYPE_STATIC(hyperlinks_by_uri_tree, hyperlinks_uri, by_uri_entry,\n    hyperlinks_by_uri_cmp);\nRB_GENERATE_STATIC(hyperlinks_by_uri_tree, hyperlinks_uri, by_uri_entry,\n    hyperlinks_by_uri_cmp);\n\nstatic int\nhyperlinks_by_inner_cmp(struct hyperlinks_uri *left,\n    struct hyperlinks_uri *right)\n{\n\treturn (left->inner - right->inner);\n}\nRB_PROTOTYPE_STATIC(hyperlinks_by_inner_tree, hyperlinks_uri, by_inner_entry,\n    hyperlinks_by_inner_cmp);\nRB_GENERATE_STATIC(hyperlinks_by_inner_tree, hyperlinks_uri, by_inner_entry,\n    hyperlinks_by_inner_cmp);\n\n/* Remove a hyperlink. */\nstatic void\nhyperlinks_remove(struct hyperlinks_uri *hlu)\n{\n\tstruct hyperlinks\t*hl = hlu->tree;\n\n\tTAILQ_REMOVE(&global_hyperlinks, hlu, list_entry);\n\tglobal_hyperlinks_count--;\n\n\tRB_REMOVE(hyperlinks_by_inner_tree, &hl->by_inner, hlu);\n\tRB_REMOVE(hyperlinks_by_uri_tree, &hl->by_uri, hlu);\n\n\tfree((void *)hlu->internal_id);\n\tfree((void *)hlu->external_id);\n\tfree((void *)hlu->uri);\n\tfree(hlu);\n}\n\n/* Store a new hyperlink or return if it already exists. */\nu_int\nhyperlinks_put(struct hyperlinks *hl, const char *uri_in,\n    const char *internal_id_in)\n{\n\tstruct hyperlinks_uri\t find, *hlu;\n\tchar\t\t\t*uri, *internal_id, *external_id;\n\n\t/*\n\t * Anonymous URI are stored with an empty internal ID and the tree\n\t * comparator will make sure they never match each other (so each\n\t * anonymous URI is unique).\n\t */\n\tif (internal_id_in == NULL)\n\t\tinternal_id_in = \"\";\n\n\tutf8_stravis(&uri, uri_in, VIS_OCTAL|VIS_CSTYLE);\n\tutf8_stravis(&internal_id, internal_id_in, VIS_OCTAL|VIS_CSTYLE);\n\n\tif (*internal_id_in != '\\0') {\n\t\tfind.uri = uri;\n\t\tfind.internal_id = internal_id;\n\n\t\thlu = RB_FIND(hyperlinks_by_uri_tree, &hl->by_uri, &find);\n\t\tif (hlu != NULL) {\n\t\t\tfree (uri);\n\t\t\tfree (internal_id);\n\t\t\treturn (hlu->inner);\n\t\t}\n\t}\n\txasprintf(&external_id, \"tmux%llX\", hyperlinks_next_external_id++);\n\n\thlu = xcalloc(1, sizeof *hlu);\n\thlu->inner = hl->next_inner++;\n\thlu->internal_id = internal_id;\n\thlu->external_id = external_id;\n\thlu->uri = uri;\n\thlu->tree = hl;\n\tRB_INSERT(hyperlinks_by_uri_tree, &hl->by_uri, hlu);\n\tRB_INSERT(hyperlinks_by_inner_tree, &hl->by_inner, hlu);\n\n\tTAILQ_INSERT_TAIL(&global_hyperlinks, hlu, list_entry);\n\tif (++global_hyperlinks_count == MAX_HYPERLINKS)\n\t\thyperlinks_remove(TAILQ_FIRST(&global_hyperlinks));\n\n\treturn (hlu->inner);\n}\n\n/* Get hyperlink by inner number. */\nint\nhyperlinks_get(struct hyperlinks *hl, u_int inner, const char **uri_out,\n    const char **internal_id_out, const char **external_id_out)\n{\n\tstruct hyperlinks_uri\tfind, *hlu;\n\n\tfind.inner = inner;\n\n\thlu = RB_FIND(hyperlinks_by_inner_tree, &hl->by_inner, &find);\n\tif (hlu == NULL)\n\t\treturn (0);\n\tif (internal_id_out != NULL)\n\t\t*internal_id_out = hlu->internal_id;\n\tif (external_id_out != NULL)\n\t\t*external_id_out = hlu->external_id;\n\t*uri_out = hlu->uri;\n\treturn (1);\n}\n\n/* Initialize hyperlink set. */\nstruct hyperlinks *\nhyperlinks_init(void)\n{\n\tstruct hyperlinks\t*hl;\n\n\thl = xcalloc(1, sizeof *hl);\n\thl->next_inner = 1;\n\tRB_INIT(&hl->by_uri);\n\tRB_INIT(&hl->by_inner);\n\thl->references = 1;\n\treturn (hl);\n}\n\n/* Copy hyperlink set. */\nstruct hyperlinks *\nhyperlinks_copy(struct hyperlinks *hl)\n{\n\thl->references++;\n\treturn (hl);\n}\n\n/* Free all hyperlinks but not the set itself. */\nvoid\nhyperlinks_reset(struct hyperlinks *hl)\n{\n\tstruct hyperlinks_uri\t*hlu, *hlu1;\n\n\tRB_FOREACH_SAFE(hlu, hyperlinks_by_inner_tree, &hl->by_inner, hlu1)\n\t\thyperlinks_remove(hlu);\n}\n\n/* Free hyperlink set. */\nvoid\nhyperlinks_free(struct hyperlinks *hl)\n{\n\tif (--hl->references == 0) {\n\t\thyperlinks_reset(hl);\n\t\tfree(hl);\n\t}\n}\n"
        },
        {
          "name": "image-sixel.c",
          "type": "blob",
          "size": 14.5341796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n#define SIXEL_WIDTH_LIMIT 10000\n#define SIXEL_HEIGHT_LIMIT 10000\n\nstruct sixel_line {\n\tu_int\t\t x;\n\tuint16_t\t*data;\n};\n\nstruct sixel_image {\n\tu_int\t\t\t x;\n\tu_int\t\t\t y;\n\tu_int\t\t\t xpixel;\n\tu_int\t\t\t ypixel;\n\n\tu_int\t\t\t set_ra;\n\tu_int\t\t\t ra_x;\n\tu_int\t\t\t ra_y;\n\n\tu_int\t\t\t*colours;\n\tu_int\t\t\t ncolours;\n\tu_int\t\t\t p2;\n\n\tu_int\t\t\t dx;\n\tu_int\t\t\t dy;\n\tu_int\t\t\t dc;\n\n\tstruct sixel_line\t*lines;\n};\n\nstruct sixel_chunk {\n\tu_int\t next_x;\n\tu_int\t next_y;\n\n\tu_int\t count;\n\tchar\t pattern;\n\tchar\t next_pattern;\n\n\tsize_t\t len;\n\tsize_t\t used;\n\tchar\t*data;\n};\n\nstatic int\nsixel_parse_expand_lines(struct sixel_image *si, u_int y)\n{\n\tif (y <= si->y)\n\t\treturn (0);\n\tif (y > SIXEL_HEIGHT_LIMIT)\n\t\treturn (1);\n\tsi->lines = xrecallocarray(si->lines, si->y, y, sizeof *si->lines);\n\tsi->y = y;\n\treturn (0);\n}\n\nstatic int\nsixel_parse_expand_line(struct sixel_image *si, struct sixel_line *sl, u_int x)\n{\n\tif (x <= sl->x)\n\t\treturn (0);\n\tif (x > SIXEL_WIDTH_LIMIT)\n\t\treturn (1);\n\tif (x > si->x)\n\t\tsi->x = x;\n\tsl->data = xrecallocarray(sl->data, sl->x, si->x, sizeof *sl->data);\n\tsl->x = si->x;\n\treturn (0);\n}\n\nstatic u_int\nsixel_get_pixel(struct sixel_image *si, u_int x, u_int y)\n{\n\tstruct sixel_line\t*sl;\n\n\tif (y >= si->y)\n\t\treturn (0);\n\tsl = &si->lines[y];\n\tif (x >= sl->x)\n\t\treturn (0);\n\treturn (sl->data[x]);\n}\n\nstatic int\nsixel_set_pixel(struct sixel_image *si, u_int x, u_int y, u_int c)\n{\n\tstruct sixel_line\t*sl;\n\n\tif (sixel_parse_expand_lines(si, y + 1) != 0)\n\t\treturn (1);\n\tsl = &si->lines[y];\n\tif (sixel_parse_expand_line(si, sl, x + 1) != 0)\n\t\treturn (1);\n\tsl->data[x] = c;\n\treturn (0);\n}\n\nstatic int\nsixel_parse_write(struct sixel_image *si, u_int ch)\n{\n\tstruct sixel_line\t*sl;\n\tu_int\t\t\t i;\n\n\tif (sixel_parse_expand_lines(si, si->dy + 6) != 0)\n\t\treturn (1);\n\tsl = &si->lines[si->dy];\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (sixel_parse_expand_line(si, sl, si->dx + 1) != 0)\n\t\t\treturn (1);\n\t\tif (ch & (1 << i))\n\t\t\tsl->data[si->dx] = si->dc;\n\t\tsl++;\n\t}\n\treturn (0);\n}\n\nstatic const char *\nsixel_parse_attributes(struct sixel_image *si, const char *cp, const char *end)\n{\n\tconst char\t*last;\n\tchar\t\t*endptr;\n\tu_int\t\t x, y;\n\n\tlast = cp;\n\twhile (last != end) {\n\t\tif (*last != ';' && (*last < '0' || *last > '9'))\n\t\t\tbreak;\n\t\tlast++;\n\t}\n\tstrtoul(cp, &endptr, 10);\n\tif (endptr == last || *endptr != ';')\n\t\treturn (last);\n\tstrtoul(endptr + 1, &endptr, 10);\n\tif (endptr == last)\n\t\treturn (last);\n\tif (*endptr != ';') {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tx = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr == last || *endptr != ';') {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\tif (x > SIXEL_WIDTH_LIMIT) {\n\t\tlog_debug(\"%s: image is too wide\", __func__);\n\t\treturn (NULL);\n\t}\n\ty = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr != last) {\n\t\tlog_debug(\"%s: extra ;\", __func__);\n\t\treturn (NULL);\n\t}\n\tif (y > SIXEL_HEIGHT_LIMIT) {\n\t\tlog_debug(\"%s: image is too tall\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tsi->x = x;\n\tsixel_parse_expand_lines(si, y);\n\n\tsi->set_ra = 1;\n\tsi->ra_x = x;\n\tsi->ra_y = y;\n\n\treturn (last);\n}\n\nstatic const char *\nsixel_parse_colour(struct sixel_image *si, const char *cp, const char *end)\n{\n\tconst char\t*last;\n\tchar\t\t*endptr;\n\tu_int\t\t c, type, r, g, b;\n\n\tlast = cp;\n\twhile (last != end) {\n\t\tif (*last != ';' && (*last < '0' || *last > '9'))\n\t\t\tbreak;\n\t\tlast++;\n\t}\n\n\tc = strtoul(cp, &endptr, 10);\n\tif (c > SIXEL_COLOUR_REGISTERS) {\n\t\tlog_debug(\"%s: too many colours\", __func__);\n\t\treturn (NULL);\n\t}\n\tsi->dc = c + 1;\n\tif (endptr == last || *endptr != ';')\n\t\treturn (last);\n\n\ttype = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr == last || *endptr != ';') {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\tr = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr == last || *endptr != ';') {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\tg = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr == last || *endptr != ';') {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\tb = strtoul(endptr + 1, &endptr, 10);\n\tif (endptr != last) {\n\t\tlog_debug(\"%s: missing ;\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tif (type != 1 && type != 2) {\n\t\tlog_debug(\"%s: invalid type %d\", __func__, type);\n\t\treturn (NULL);\n\t}\n\tif (c + 1 > si->ncolours) {\n\t\tsi->colours = xrecallocarray(si->colours, si->ncolours, c + 1,\n\t\t    sizeof *si->colours);\n\t\tsi->ncolours = c + 1;\n\t}\n\tsi->colours[c] = (type << 24) | (r << 16) | (g << 8) | b;\n\treturn (last);\n}\n\nstatic const char *\nsixel_parse_repeat(struct sixel_image *si, const char *cp, const char *end)\n{\n\tconst char\t*last;\n\tchar\t\t tmp[32], ch;\n\tu_int\t\t n = 0, i;\n\tconst char\t*errstr = NULL;\n\n\tlast = cp;\n\twhile (last != end) {\n\t\tif (*last < '0' || *last > '9')\n\t\t\tbreak;\n\t\ttmp[n++] = *last++;\n\t\tif (n == (sizeof tmp) - 1) {\n\t\t\tlog_debug(\"%s: repeat not terminated\", __func__);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (n == 0 || last == end) {\n\t\tlog_debug(\"%s: repeat not terminated\", __func__);\n\t\treturn (NULL);\n\t}\n\ttmp[n] = '\\0';\n\n\tn = strtonum(tmp, 1, SIXEL_WIDTH_LIMIT, &errstr);\n\tif (n == 0 || errstr != NULL) {\n\t\tlog_debug(\"%s: repeat too wide\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tch = (*last++) - 0x3f;\n\tfor (i = 0; i < n; i++) {\n\t\tif (sixel_parse_write(si, ch) != 0) {\n\t\t\tlog_debug(\"%s: width limit reached\", __func__);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsi->dx++;\n\t}\n\treturn (last);\n}\n\nstruct sixel_image *\nsixel_parse(const char *buf, size_t len, u_int p2, u_int xpixel, u_int ypixel)\n{\n\tstruct sixel_image\t*si;\n\tconst char\t\t*cp = buf, *end = buf + len;\n\tchar\t\t\t ch;\n\n\tif (len == 0 || len == 1 || *cp++ != 'q') {\n\t\tlog_debug(\"%s: empty image\", __func__);\n\t\treturn (NULL);\n\t}\n\n\tsi = xcalloc (1, sizeof *si);\n\tsi->xpixel = xpixel;\n\tsi->ypixel = ypixel;\n\tsi->p2 = p2;\n\n\twhile (cp != end) {\n\t\tch = *cp++;\n\t\tswitch (ch) {\n\t\tcase '\"':\n\t\t\tcp = sixel_parse_attributes(si, cp, end);\n\t\t\tif (cp == NULL)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tcp = sixel_parse_colour(si, cp, end);\n\t\t\tif (cp == NULL)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase '!':\n\t\t\tcp = sixel_parse_repeat(si, cp, end);\n\t\t\tif (cp == NULL)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tsi->dx = 0;\n\t\t\tsi->dy += 6;\n\t\t\tbreak;\n\t\tcase '$':\n\t\t\tsi->dx = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ch < 0x20)\n\t\t\t\tbreak;\n\t\t\tif (ch < 0x3f || ch > 0x7e)\n\t\t\t\tgoto bad;\n\t\t\tif (sixel_parse_write(si, ch - 0x3f) != 0) {\n\t\t\t\tlog_debug(\"%s: width limit reached\", __func__);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tsi->dx++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (si->x == 0 || si->y == 0)\n\t\tgoto bad;\n\treturn (si);\n\nbad:\n\tfree(si);\n\treturn (NULL);\n}\n\nvoid\nsixel_free(struct sixel_image *si)\n{\n\tu_int\ty;\n\n\tfor (y = 0; y < si->y; y++)\n\t\tfree(si->lines[y].data);\n\tfree(si->lines);\n\n\tfree(si->colours);\n\tfree(si);\n}\n\nvoid\nsixel_log(struct sixel_image *si)\n{\n\tstruct sixel_line\t*sl;\n\tchar\t\t\t s[SIXEL_WIDTH_LIMIT + 1];\n\tu_int\t\t\t i, x, y, cx, cy;\n\n\tsixel_size_in_cells(si, &cx, &cy);\n\tlog_debug(\"%s: image %ux%u (%ux%u)\", __func__, si->x, si->y, cx, cy);\n\tfor (i = 0; i < si->ncolours; i++)\n\t\tlog_debug(\"%s: colour %u is %07x\", __func__, i, si->colours[i]);\n\tfor (y = 0; y < si->y; y++) {\n\t\tsl = &si->lines[y];\n\t\tfor (x = 0; x < si->x; x++) {\n\t\t\tif (x >= sl->x)\n\t\t\t\ts[x] = '_';\n\t\t\telse if (sl->data[x] != 0)\n\t\t\t\ts[x] = '0' + (sl->data[x] - 1) % 10;\n\t\t\telse\n\t\t\t\ts[x] = '.';\n\t\t\t}\n\t\ts[x] = '\\0';\n\t\tlog_debug(\"%s: %4u: %s\", __func__, y, s);\n\t}\n}\n\nvoid\nsixel_size_in_cells(struct sixel_image *si, u_int *x, u_int *y)\n{\n\tif ((si->x % si->xpixel) == 0)\n\t\t*x = (si->x / si->xpixel);\n\telse\n\t\t*x = 1 + (si->x / si->xpixel);\n\tif ((si->y % si->ypixel) == 0)\n\t\t*y = (si->y / si->ypixel);\n\telse\n\t\t*y = 1 + (si->y / si->ypixel);\n}\n\nstruct sixel_image *\nsixel_scale(struct sixel_image *si, u_int xpixel, u_int ypixel, u_int ox,\n    u_int oy, u_int sx, u_int sy, int colours)\n{\n\tstruct sixel_image\t*new;\n\tu_int\t\t\t cx, cy, pox, poy, psx, psy, tsx, tsy, px, py;\n\tu_int\t\t\t x, y, i;\n\n\t/*\n\t * We want to get the section of the image at ox,oy in image cells and\n\t * map it onto the same size in terminal cells, remembering that we\n\t * can only draw vertical sections of six pixels.\n\t */\n\n\tsixel_size_in_cells(si, &cx, &cy);\n\tif (ox >= cx)\n\t\treturn (NULL);\n\tif (oy >= cy)\n\t\treturn (NULL);\n\tif (ox + sx >= cx)\n\t\tsx = cx - ox;\n\tif (oy + sy >= cy)\n\t\tsy = cy - oy;\n\n\tif (xpixel == 0)\n\t\txpixel = si->xpixel;\n\tif (ypixel == 0)\n\t\typixel = si->ypixel;\n\n\tpox = ox * si->xpixel;\n\tpoy = oy * si->ypixel;\n\tpsx = sx * si->xpixel;\n\tpsy = sy * si->ypixel;\n\n\ttsx = sx * xpixel;\n\ttsy = ((sy * ypixel) / 6) * 6;\n\n\tnew = xcalloc (1, sizeof *si);\n\tnew->xpixel = xpixel;\n\tnew->ypixel = ypixel;\n\tnew->p2 = si->p2;\n\n\tnew->set_ra = si->set_ra;\n\t/* clamp to slice end */\n\tnew->ra_x = si->ra_x < psx ? si->ra_x : psx;\n\tnew->ra_y = si->ra_y < psy ? si->ra_y : psy;\n\t/* subtract slice origin */\n\tnew->ra_x = new->ra_x > pox ? new->ra_x - pox : 0;\n\tnew->ra_y = new->ra_y > poy ? new->ra_y - poy : 0;\n\t/* resize */\n\tnew->ra_x = new->ra_x * xpixel / si->xpixel;\n\tnew->ra_y = new->ra_y * ypixel / si->ypixel;\n\n\tfor (y = 0; y < tsy; y++) {\n\t\tpy = poy + ((double)y * psy / tsy);\n\t\tfor (x = 0; x < tsx; x++) {\n\t\t\tpx = pox + ((double)x * psx / tsx);\n\t\t\tsixel_set_pixel(new, x, y, sixel_get_pixel(si, px, py));\n\t\t}\n\t}\n\n\tif (colours) {\n\t\tnew->colours = xmalloc(si->ncolours * sizeof *new->colours);\n\t\tfor (i = 0; i < si->ncolours; i++)\n\t\t\tnew->colours[i] = si->colours[i];\n\t\tnew->ncolours = si->ncolours;\n\t}\n\treturn (new);\n}\n\nstatic void\nsixel_print_add(char **buf, size_t *len, size_t *used, const char *s,\n    size_t slen)\n{\n\tif (*used + slen >= *len + 1) {\n\t\t(*len) *= 2;\n\t\t*buf = xrealloc(*buf, *len);\n\t}\n\tmemcpy(*buf + *used, s, slen);\n\t(*used) += slen;\n}\n\nstatic void\nsixel_print_repeat(char **buf, size_t *len, size_t *used, u_int count, char ch)\n{\n\tchar\ttmp[16];\n\tsize_t\ttmplen;\n\n\tif (count == 1)\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\telse if (count == 2) {\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\t} else if (count == 3) {\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\t\tsixel_print_add(buf, len, used, &ch, 1);\n\t} else if (count != 0) {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"!%u%c\", count, ch);\n\t\tsixel_print_add(buf, len, used, tmp, tmplen);\n\t}\n}\n\nstatic void\nsixel_print_compress_colors(struct sixel_image *si, struct sixel_chunk *chunks,\n    u_int y, u_int *active, u_int *nactive)\n{\n\tu_int\t\t\t i, x, c, dx, colors[6];\n\tstruct sixel_chunk\t*chunk = NULL;\n\tstruct sixel_line\t*sl;\n\n\tfor (x = 0; x < si->x; x++) {\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tcolors[i] = 0;\n\t\t\tif (y + i < si->y) {\n\t\t\t\tsl = &si->lines[y + i];\n\t\t\t\tif (x < sl->x && sl->data[x] != 0) {\n\t\t\t\t\tcolors[i] = sl->data[x];\n\t\t\t\t\tc = sl->data[x] - 1;\n\t\t\t\t\tchunks[c].next_pattern |= 1 << i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tif (colors[i] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tc = colors[i] - 1;\n\t\t\tchunk = &chunks[c];\n\t\t\tif (chunk->next_x == x + 1)\n\t\t\t\tcontinue;\n\n\t\t\tif (chunk->next_y < y + 1) {\n\t\t\t\tchunk->next_y = y + 1;\n\t\t\t\tactive[(*nactive)++] = c;\n\t\t\t}\n\n\t\t\tdx = x - chunk->next_x;\n\t\t\tif (chunk->pattern != chunk->next_pattern || dx != 0) {\n\t\t\t\tsixel_print_repeat(&chunk->data, &chunk->len,\n\t\t\t\t    &chunk->used, chunk->count,\n\t\t\t\t    chunk->pattern + 0x3f);\n\t\t\t\tsixel_print_repeat(&chunk->data, &chunk->len,\n\t\t\t\t    &chunk->used, dx, '?');\n\t\t\t\tchunk->pattern = chunk->next_pattern;\n\t\t\t\tchunk->count = 0;\n\t\t\t}\n\t\t\tchunk->count++;\n\t\t\tchunk->next_pattern = 0;\n\t\t\tchunk->next_x = x + 1;\n\t\t}\n\t}\n}\n\nchar *\nsixel_print(struct sixel_image *si, struct sixel_image *map, size_t *size)\n{\n\tchar\t\t\t*buf, tmp[64];\n\tsize_t\t\t\t len, used = 0, tmplen;\n\tu_int\t\t\t*colours, ncolours, i, c, y, *active, nactive;\n\tstruct sixel_chunk\t*chunks, *chunk;\n\n\tif (map != NULL) {\n\t\tcolours = map->colours;\n\t\tncolours = map->ncolours;\n\t} else {\n\t\tcolours = si->colours;\n\t\tncolours = si->ncolours;\n\t}\n\n\tif (ncolours == 0)\n\t\treturn (NULL);\n\n\tlen = 8192;\n\tbuf = xmalloc(len);\n\n\ttmplen = xsnprintf(tmp, sizeof tmp, \"\\033P0;%uq\", si->p2);\n\tsixel_print_add(&buf, &len, &used, tmp, tmplen);\n\n\tif (si->set_ra) {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"\\\"1;1;%u;%u\", si->ra_x,\n\t\t    si->ra_y);\n\t\tsixel_print_add(&buf, &len, &used, tmp, tmplen);\n\t}\n\n\tchunks = xcalloc(ncolours, sizeof *chunks);\n\tactive = xcalloc(ncolours, sizeof *active);\n\n\tfor (i = 0; i < ncolours; i++) {\n\t\tc = colours[i];\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"#%u;%u;%u;%u;%u\",\n\t\t    i, c >> 24, (c >> 16) & 0xff, (c >> 8) & 0xff, c & 0xff);\n\t\tsixel_print_add(&buf, &len, &used, tmp, tmplen);\n\n\t\tchunk = &chunks[i];\n\t\tchunk->len = 8;\n\t\tchunk->data = xmalloc(chunk->len);\n\t}\n\n\tfor (y = 0; y < si->y; y += 6) {\n\t\tnactive = 0;\n\t\tsixel_print_compress_colors(si, chunks, y, active, &nactive);\n\n\t\tfor (i = 0; i < nactive; i++) {\n\t\t\tc = active[i];\n\t\t\tchunk = &chunks[c];\n\t\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"#%u\", c);\n\t\t\tsixel_print_add(&buf, &len, &used, tmp, tmplen);\n\t\t\tsixel_print_add(&buf, &len, &used, chunk->data,\n\t\t\t    chunk->used);\n\t\t\tsixel_print_repeat(&buf, &len, &used, chunk->count,\n\t\t\t    chunk->pattern + 0x3f);\n\t\t\tsixel_print_add(&buf, &len, &used, \"$\", 1);\n\t\t\tchunk->used = chunk->next_x = chunk->count = 0;\n\t\t}\n\n\t\tif (buf[used - 1] == '$')\n\t\t\tused--;\n\t\tsixel_print_add(&buf, &len, &used, \"-\", 1);\n\t}\n\tif (buf[used - 1] == '-')\n\t\tused--;\n\n\tsixel_print_add(&buf, &len, &used, \"\\033\\\\\", 2);\n\n\tbuf[used] = '\\0';\n\tif (size != NULL)\n\t\t*size = used;\n\n\tfor (i = 0; i < ncolours; i++)\n\t\tfree(chunks[i].data);\n\tfree(active);\n\tfree(chunks);\n\n\treturn (buf);\n}\n\nstruct screen *\nsixel_to_screen(struct sixel_image *si)\n{\n\tstruct screen\t\t*s;\n\tstruct screen_write_ctx\t ctx;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t x, y, sx, sy;\n\n\tsixel_size_in_cells(si, &sx, &sy);\n\n\ts = xmalloc(sizeof *s);\n\tscreen_init(s, sx, sy, 0);\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tgc.attr |= (GRID_ATTR_CHARSET|GRID_ATTR_DIM);\n\tutf8_set(&gc.data, '~');\n\n\tscreen_write_start(&ctx, s);\n\tif (sx == 1 || sy == 1) {\n\t\tfor (y = 0; y < sy; y++) {\n\t\t\tfor (x = 0; x < sx; x++)\n\t\t\t\tgrid_view_set_cell(s->grid, x, y, &gc);\n\t\t}\n\t} else {\n\t\tscreen_write_box(&ctx, sx, sy, BOX_LINES_DEFAULT, NULL, NULL);\n\t\tfor (y = 1; y < sy - 1; y++) {\n\t\t\tfor (x = 1; x < sx - 1; x++)\n\t\t\t\tgrid_view_set_cell(s->grid, x, y, &gc);\n\t\t}\n\t}\n\tscreen_write_stop(&ctx);\n\treturn (s);\n}\n"
        },
        {
          "name": "image.c",
          "type": "blob",
          "size": 3.9873046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic struct images\tall_images = TAILQ_HEAD_INITIALIZER(all_images);\nstatic u_int\t\tall_images_count;\n\nstatic void\nimage_free(struct image *im)\n{\n\tstruct screen\t*s = im->s;\n\n\tTAILQ_REMOVE(&all_images, im, all_entry);\n\tall_images_count--;\n\n\tTAILQ_REMOVE(&s->images, im, entry);\n\tsixel_free(im->data);\n\tfree(im->fallback);\n\tfree(im);\n}\n\nint\nimage_free_all(struct screen *s)\n{\n\tstruct image\t*im, *im1;\n\tint\t\t redraw = !TAILQ_EMPTY(&s->images);\n\n\tTAILQ_FOREACH_SAFE(im, &s->images, entry, im1)\n\t\timage_free(im);\n\treturn (redraw);\n}\n\n/* Create text placeholder for an image. */\nstatic void\nimage_fallback(char **ret, u_int sx, u_int sy)\n{\n\tchar\t*buf, *label;\n\tu_int\t py, size, lsize;\n\n\t/* Allocate first line. */\n\tlsize = xasprintf(&label, \"SIXEL IMAGE (%ux%u)\\r\\n\", sx, sy) + 1;\n\tif (sx < lsize - 3)\n\t\tsize = lsize - 1;\n\telse\n\t\tsize = sx + 2;\n\n\t/* Remaining lines. Every placeholder line has \\r\\n at the end. */\n\tsize += (sx + 2) * (sy - 1) + 1;\n\t*ret = buf = xmalloc(size);\n\n\t/* Render first line. */\n\tif (sx < lsize - 3) {\n\t\tmemcpy(buf, label, lsize);\n\t\tbuf += lsize - 1;\n\t} else {\n\t\tmemcpy(buf, label, lsize - 3);\n\t\tbuf += lsize - 3;\n\t\tmemset(buf, '+', sx - lsize + 3);\n\t\tbuf += sx - lsize + 3;\n\t\tsnprintf(buf, 3, \"\\r\\n\");\n\t\tbuf += 2;\n\t}\n\n\t/* Remaining lines. */\n\tfor (py = 1; py < sy; py++) {\n\t\tmemset(buf, '+', sx);\n\t\tbuf += sx;\n\t\tsnprintf(buf, 3, \"\\r\\n\");\n\t\tbuf += 2;\n\t}\n\n\tfree(label);\n}\n\nstruct image*\nimage_store(struct screen *s, struct sixel_image *si)\n{\n\tstruct image\t*im;\n\n\tim = xcalloc(1, sizeof *im);\n\tim->s = s;\n\tim->data = si;\n\n\tim->px = s->cx;\n\tim->py = s->cy;\n\tsixel_size_in_cells(si, &im->sx, &im->sy);\n\n\timage_fallback(&im->fallback, im->sx, im->sy);\n\n\tTAILQ_INSERT_TAIL(&s->images, im, entry);\n\n\tTAILQ_INSERT_TAIL(&all_images, im, all_entry);\n\tif (++all_images_count == 10/*XXX*/)\n\t\timage_free(TAILQ_FIRST(&all_images));\n\n\treturn (im);\n}\n\nint\nimage_check_line(struct screen *s, u_int py, u_int ny)\n{\n\tstruct image\t*im, *im1;\n\tint\t\t redraw = 0;\n\n\tTAILQ_FOREACH_SAFE(im, &s->images, entry, im1) {\n\t\tif (py + ny > im->py && py < im->py + im->sy) {\n\t\t\timage_free(im);\n\t\t\tredraw = 1;\n\t\t}\n\t}\n\treturn (redraw);\n}\n\nint\nimage_check_area(struct screen *s, u_int px, u_int py, u_int nx, u_int ny)\n{\n\tstruct image\t*im, *im1;\n\tint\t\t redraw = 0;\n\n\tTAILQ_FOREACH_SAFE(im, &s->images, entry, im1) {\n\t\tif (py + ny <= im->py || py >= im->py + im->sy)\n\t\t\tcontinue;\n\t\tif (px + nx <= im->px || px >= im->px + im->sx)\n\t\t\tcontinue;\n\t\timage_free(im);\n\t\tredraw = 1;\n\t}\n\treturn (redraw);\n}\n\nint\nimage_scroll_up(struct screen *s, u_int lines)\n{\n\tstruct image\t\t*im, *im1;\n\tint\t\t\t redraw = 0;\n\tu_int\t\t\t sx, sy;\n\tstruct sixel_image\t*new;\n\n\tTAILQ_FOREACH_SAFE(im, &s->images, entry, im1) {\n\t\tif (im->py >= lines) {\n\t\t\tim->py -= lines;\n\t\t\tredraw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (im->py + im->sy <= lines) {\n\t\t\timage_free(im);\n\t\t\tredraw = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tsx = im->sx;\n\t\tsy = (im->py + im->sy) - lines;\n\n\t\tnew = sixel_scale(im->data, 0, 0, 0, im->sy - sy, sx, sy, 1);\n\t\tsixel_free(im->data);\n\t\tim->data = new;\n\n\t\tim->py = 0;\n\t\tsixel_size_in_cells(im->data, &im->sx, &im->sy);\n\n\t\tfree(im->fallback);\n\t\timage_fallback(&im->fallback, im->sx, im->sy);\n\t\tredraw = 1;\n\t}\n\treturn (redraw);\n}\n"
        },
        {
          "name": "input-keys.c",
          "type": "blob",
          "size": 19.46875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * This file is rather misleadingly named, it contains the code which takes a\n * key code and translates it into something suitable to be sent to the\n * application running in a pane (similar to input.c does in the other\n * direction with output).\n */\n\nstatic void\t input_key_mouse(struct window_pane *, struct mouse_event *);\n\n/* Entry in the key tree. */\nstruct input_key_entry {\n\tkey_code\t\t\t key;\n\tconst char\t\t\t*data;\n\n\tRB_ENTRY(input_key_entry)\t entry;\n};\nRB_HEAD(input_key_tree, input_key_entry);\n\n/* Tree of input keys. */\nstatic int\tinput_key_cmp(struct input_key_entry *,\n\t\t    struct input_key_entry *);\nRB_GENERATE_STATIC(input_key_tree, input_key_entry, entry, input_key_cmp);\nstruct input_key_tree input_key_tree = RB_INITIALIZER(&input_key_tree);\n\n/* List of default keys, the tree is built from this. */\nstatic struct input_key_entry input_key_defaults[] = {\n\t/* Paste keys. */\n\t{ .key = KEYC_PASTE_START,\n\t  .data = \"\\033[200~\"\n\t},\n\t{ .key = KEYC_PASTE_END,\n\t  .data = \"\\033[201~\"\n\t},\n\n\t/* Function keys. */\n\t{ .key = KEYC_F1,\n\t  .data = \"\\033OP\"\n\t},\n\t{ .key = KEYC_F2,\n\t  .data = \"\\033OQ\"\n\t},\n\t{ .key = KEYC_F3,\n\t  .data = \"\\033OR\"\n\t},\n\t{ .key = KEYC_F4,\n\t  .data = \"\\033OS\"\n\t},\n\t{ .key = KEYC_F5,\n\t  .data = \"\\033[15~\"\n\t},\n\t{ .key = KEYC_F6,\n\t  .data = \"\\033[17~\"\n\t},\n\t{ .key = KEYC_F7,\n\t  .data = \"\\033[18~\"\n\t},\n\t{ .key = KEYC_F8,\n\t  .data = \"\\033[19~\"\n\t},\n\t{ .key = KEYC_F9,\n\t  .data = \"\\033[20~\"\n\t},\n\t{ .key = KEYC_F10,\n\t  .data = \"\\033[21~\"\n\t},\n\t{ .key = KEYC_F11,\n\t  .data = \"\\033[23~\"\n\t},\n\t{ .key = KEYC_F12,\n\t  .data = \"\\033[24~\"\n\t},\n\t{ .key = KEYC_IC,\n\t  .data = \"\\033[2~\"\n\t},\n\t{ .key = KEYC_DC,\n\t  .data = \"\\033[3~\"\n\t},\n\t{ .key = KEYC_HOME,\n\t  .data = \"\\033[1~\"\n\t},\n\t{ .key = KEYC_END,\n\t  .data = \"\\033[4~\"\n\t},\n\t{ .key = KEYC_NPAGE,\n\t  .data = \"\\033[6~\"\n\t},\n\t{ .key = KEYC_PPAGE,\n\t  .data = \"\\033[5~\"\n\t},\n\t{ .key = KEYC_BTAB,\n\t  .data = \"\\033[Z\"\n\t},\n\n\t/* Arrow keys. */\n\t{ .key = KEYC_UP|KEYC_CURSOR,\n\t  .data = \"\\033OA\"\n\t},\n\t{ .key = KEYC_DOWN|KEYC_CURSOR,\n\t  .data = \"\\033OB\"\n\t},\n\t{ .key = KEYC_RIGHT|KEYC_CURSOR,\n\t  .data = \"\\033OC\"\n\t},\n\t{ .key = KEYC_LEFT|KEYC_CURSOR,\n\t  .data = \"\\033OD\"\n\t},\n\t{ .key = KEYC_UP,\n\t  .data = \"\\033[A\"\n\t},\n\t{ .key = KEYC_DOWN,\n\t  .data = \"\\033[B\"\n\t},\n\t{ .key = KEYC_RIGHT,\n\t  .data = \"\\033[C\"\n\t},\n\t{ .key = KEYC_LEFT,\n\t  .data = \"\\033[D\"\n\t},\n\n\t/* Keypad keys. */\n\t{ .key = KEYC_KP_SLASH|KEYC_KEYPAD,\n\t  .data = \"\\033Oo\"\n\t},\n\t{ .key = KEYC_KP_STAR|KEYC_KEYPAD,\n\t  .data = \"\\033Oj\"\n\t},\n\t{ .key = KEYC_KP_MINUS|KEYC_KEYPAD,\n\t  .data = \"\\033Om\"\n\t},\n\t{ .key = KEYC_KP_SEVEN|KEYC_KEYPAD,\n\t  .data = \"\\033Ow\"\n\t},\n\t{ .key = KEYC_KP_EIGHT|KEYC_KEYPAD,\n\t  .data = \"\\033Ox\"\n\t},\n\t{ .key = KEYC_KP_NINE|KEYC_KEYPAD,\n\t  .data = \"\\033Oy\"\n\t},\n\t{ .key = KEYC_KP_PLUS|KEYC_KEYPAD,\n\t  .data = \"\\033Ok\"\n\t},\n\t{ .key = KEYC_KP_FOUR|KEYC_KEYPAD,\n\t  .data = \"\\033Ot\"\n\t},\n\t{ .key = KEYC_KP_FIVE|KEYC_KEYPAD,\n\t  .data = \"\\033Ou\"\n\t},\n\t{ .key = KEYC_KP_SIX|KEYC_KEYPAD,\n\t  .data = \"\\033Ov\"\n\t},\n\t{ .key = KEYC_KP_ONE|KEYC_KEYPAD,\n\t  .data = \"\\033Oq\"\n\t},\n\t{ .key = KEYC_KP_TWO|KEYC_KEYPAD,\n\t  .data = \"\\033Or\"\n\t},\n\t{ .key = KEYC_KP_THREE|KEYC_KEYPAD,\n\t  .data = \"\\033Os\"\n\t},\n\t{ .key = KEYC_KP_ENTER|KEYC_KEYPAD,\n\t  .data = \"\\033OM\"\n\t},\n\t{ .key = KEYC_KP_ZERO|KEYC_KEYPAD,\n\t  .data = \"\\033Op\"\n\t},\n\t{ .key = KEYC_KP_PERIOD|KEYC_KEYPAD,\n\t  .data = \"\\033On\"\n\t},\n\t{ .key = KEYC_KP_SLASH,\n\t  .data = \"/\"\n\t},\n\t{ .key = KEYC_KP_STAR,\n\t  .data = \"*\"\n\t},\n\t{ .key = KEYC_KP_MINUS,\n\t  .data = \"-\"\n\t},\n\t{ .key = KEYC_KP_SEVEN,\n\t  .data = \"7\"\n\t},\n\t{ .key = KEYC_KP_EIGHT,\n\t  .data = \"8\"\n\t},\n\t{ .key = KEYC_KP_NINE,\n\t  .data = \"9\"\n\t},\n\t{ .key = KEYC_KP_PLUS,\n\t  .data = \"+\"\n\t},\n\t{ .key = KEYC_KP_FOUR,\n\t  .data = \"4\"\n\t},\n\t{ .key = KEYC_KP_FIVE,\n\t  .data = \"5\"\n\t},\n\t{ .key = KEYC_KP_SIX,\n\t  .data = \"6\"\n\t},\n\t{ .key = KEYC_KP_ONE,\n\t  .data = \"1\"\n\t},\n\t{ .key = KEYC_KP_TWO,\n\t  .data = \"2\"\n\t},\n\t{ .key = KEYC_KP_THREE,\n\t  .data = \"3\"\n\t},\n\t{ .key = KEYC_KP_ENTER,\n\t  .data = \"\\n\"\n\t},\n\t{ .key = KEYC_KP_ZERO,\n\t  .data = \"0\"\n\t},\n\t{ .key = KEYC_KP_PERIOD,\n\t  .data = \".\"\n\t},\n\n\t/* Keys with an embedded modifier. */\n\t{ .key = KEYC_F1|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_P\"\n\t},\n\t{ .key = KEYC_F2|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_Q\"\n\t},\n\t{ .key = KEYC_F3|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_R\"\n\t},\n\t{ .key = KEYC_F4|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_S\"\n\t},\n\t{ .key = KEYC_F5|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[15;_~\"\n\t},\n\t{ .key = KEYC_F6|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[17;_~\"\n\t},\n\t{ .key = KEYC_F7|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[18;_~\"\n\t},\n\t{ .key = KEYC_F8|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[19;_~\"\n\t},\n\t{ .key = KEYC_F9|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[20;_~\"\n\t},\n\t{ .key = KEYC_F10|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[21;_~\"\n\t},\n\t{ .key = KEYC_F11|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[23;_~\"\n\t},\n\t{ .key = KEYC_F12|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[24;_~\"\n\t},\n\t{ .key = KEYC_UP|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_A\"\n\t},\n\t{ .key = KEYC_DOWN|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_B\"\n\t},\n\t{ .key = KEYC_RIGHT|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_C\"\n\t},\n\t{ .key = KEYC_LEFT|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_D\"\n\t},\n\t{ .key = KEYC_HOME|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_H\"\n\t},\n\t{ .key = KEYC_END|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[1;_F\"\n\t},\n\t{ .key = KEYC_PPAGE|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[5;_~\"\n\t},\n\t{ .key = KEYC_NPAGE|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[6;_~\"\n\t},\n\t{ .key = KEYC_IC|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[2;_~\"\n\t},\n\t{ .key = KEYC_DC|KEYC_BUILD_MODIFIERS,\n\t  .data = \"\\033[3;_~\"\n\t},\n};\nstatic const key_code input_key_modifiers[] = {\n\t0,\n\t0,\n\tKEYC_SHIFT,\n\tKEYC_META|KEYC_IMPLIED_META,\n\tKEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META,\n\tKEYC_CTRL,\n\tKEYC_SHIFT|KEYC_CTRL,\n\tKEYC_META|KEYC_IMPLIED_META|KEYC_CTRL,\n\tKEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL\n};\n\n/* Input key comparison function. */\nstatic int\ninput_key_cmp(struct input_key_entry *ike1, struct input_key_entry *ike2)\n{\n\tif (ike1->key < ike2->key)\n\t\treturn (-1);\n\tif (ike1->key > ike2->key)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Look for key in tree. */\nstatic struct input_key_entry *\ninput_key_get(key_code key)\n{\n\tstruct input_key_entry\tentry = { .key = key };\n\n\treturn (RB_FIND(input_key_tree, &input_key_tree, &entry));\n}\n\n/* Split a character into two UTF-8 bytes. */\nstatic size_t\ninput_key_split2(u_int c, u_char *dst)\n{\n\tif (c > 0x7f) {\n\t\tdst[0] = (c >> 6) | 0xc0;\n\t\tdst[1] = (c & 0x3f) | 0x80;\n\t\treturn (2);\n\t}\n\tdst[0] = c;\n\treturn (1);\n}\n\n/* Build input key tree. */\nvoid\ninput_key_build(void)\n{\n\tstruct input_key_entry\t*ike, *new;\n\tu_int\t\t\t i, j;\n\tchar\t\t\t*data;\n\tkey_code\t\t key;\n\n\tfor (i = 0; i < nitems(input_key_defaults); i++) {\n\t\tike = &input_key_defaults[i];\n\t\tif (~ike->key & KEYC_BUILD_MODIFIERS) {\n\t\t\tRB_INSERT(input_key_tree, &input_key_tree, ike);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 2; j < nitems(input_key_modifiers); j++) {\n\t\t\tkey = (ike->key & ~KEYC_BUILD_MODIFIERS);\n\t\t\tdata = xstrdup(ike->data);\n\t\t\tdata[strcspn(data, \"_\")] = '0' + j;\n\n\t\t\tnew = xcalloc(1, sizeof *new);\n\t\t\tnew->key = key|input_key_modifiers[j];\n\t\t\tnew->data = data;\n\t\t\tRB_INSERT(input_key_tree, &input_key_tree, new);\n\t\t}\n\t}\n\n\tRB_FOREACH(ike, input_key_tree, &input_key_tree) {\n\t\tlog_debug(\"%s: 0x%llx (%s) is %s\", __func__, ike->key,\n\t\t    key_string_lookup_key(ike->key, 1), ike->data);\n\t}\n}\n\n/* Translate a key code into an output key sequence for a pane. */\nint\ninput_key_pane(struct window_pane *wp, key_code key, struct mouse_event *m)\n{\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"writing key 0x%llx (%s) to %%%u\", key,\n\t\t    key_string_lookup_key(key, 1), wp->id);\n\t}\n\n\tif (KEYC_IS_MOUSE(key)) {\n\t\tif (m != NULL && m->wp != -1 && (u_int)m->wp == wp->id)\n\t\t\tinput_key_mouse(wp, m);\n\t\treturn (0);\n\t}\n\treturn (input_key(wp->screen, wp->event, key));\n}\n\nstatic void\ninput_key_write(const char *from, struct bufferevent *bev, const char *data,\n    size_t size)\n{\n\tlog_debug(\"%s: %.*s\", from, (int)size, data);\n\tbufferevent_write(bev, data, size);\n}\n\n/*\n * Encode and write an extended key escape sequence in one of the two\n * possible formats, depending on the configured output mode.\n */\nstatic int\ninput_key_extended(struct bufferevent *bev, key_code key)\n{\n\tchar\t\t tmp[64], modifier;\n\tstruct utf8_data ud;\n\twchar_t\t\t wc;\n\n\tswitch (key & KEYC_MASK_MODIFIERS) {\n\tcase KEYC_SHIFT:\n\t\tmodifier = '2';\n\t\tbreak;\n\tcase KEYC_META:\n\t\tmodifier = '3';\n\t\tbreak;\n\tcase KEYC_SHIFT|KEYC_META:\n\t\tmodifier = '4';\n\t\tbreak;\n\tcase KEYC_CTRL:\n\t\tmodifier = '5';\n\t\tbreak;\n\tcase KEYC_SHIFT|KEYC_CTRL:\n\t\tmodifier = '6';\n\t\tbreak;\n\tcase KEYC_META|KEYC_CTRL:\n\t\tmodifier = '7';\n\t\tbreak;\n\tcase KEYC_SHIFT|KEYC_META|KEYC_CTRL:\n\t\tmodifier = '8';\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\tif (KEYC_IS_UNICODE(key)) {\n\t\tutf8_to_data(key & KEYC_MASK_KEY, &ud);\n\t\tif (utf8_towc(&ud, &wc) == UTF8_DONE)\n\t\t\tkey = wc;\n\t\telse\n\t\t\treturn (-1);\n\t} else\n\t\tkey &= KEYC_MASK_KEY;\n\n\tif (options_get_number(global_options, \"extended-keys-format\") == 1)\n\t\txsnprintf(tmp, sizeof tmp, \"\\033[27;%c;%llu~\", modifier, key);\n\telse\n\t\txsnprintf(tmp, sizeof tmp, \"\\033[%llu;%cu\", key, modifier);\n\n\tinput_key_write(__func__, bev, tmp, strlen(tmp));\n\treturn (0);\n}\n\n/*\n * Outputs the key in the \"standard\" mode. This is by far the most\n * complicated output mode, with a lot of remapping in order to\n * emulate quirks of terminals that today can be only found in museums.\n */\nstatic int\ninput_key_vt10x(struct bufferevent *bev, key_code key)\n{\n\tstruct utf8_data\t ud;\n\tkey_code\t\t onlykey;\n\tchar\t\t\t*p;\n\tstatic const char\t*standard_map[2] = {\n\t\t\"1!9(0)=+;:'\\\",<.>/-8? 2\",\n\t\t\"119900=+;;'',,..\\x1f\\x1f\\x7f\\x7f\\0\\0\",\n\t};\n\n\tlog_debug(\"%s: key in %llx\", __func__, key);\n\n\tif (key & KEYC_META)\n\t\tinput_key_write(__func__, bev, \"\\033\", 1);\n\n\t/*\n\t * There's no way to report modifiers for unicode keys in standard mode\n\t * so lose the modifiers.\n\t */\n\tif (KEYC_IS_UNICODE(key)) {\n\t\tutf8_to_data(key, &ud);\n                input_key_write(__func__, bev, ud.data, ud.size);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Prevent TAB, CR and LF from being swallowed by the C0 remapping\n\t * logic.\n\t */\n\tonlykey = key & KEYC_MASK_KEY;\n\tif (onlykey == '\\r' || onlykey == '\\n' || onlykey == '\\t')\n\t\tkey &= ~KEYC_CTRL;\n\n\t/*\n\t * Convert keys with Ctrl modifier into corresponding C0 control codes,\n\t * with the exception of *some* keys, which are remapped into printable\n\t * ASCII characters.\n\t *\n\t * There is no special handling for Shift modifier, which is pretty\n\t * much redundant anyway, as no terminal will send <base key>|SHIFT,\n\t * but only <shifted key>|SHIFT.\n\t */\n\tif (key & KEYC_CTRL) {\n\t\tp = strchr(standard_map[0], onlykey);\n\t\tif (p != NULL)\n\t\t\tkey = standard_map[1][p - standard_map[0]];\n\t\telse if (onlykey >= '3' && onlykey <= '7')\n\t\t\tkey = onlykey - '\\030';\n\t\telse if (onlykey >= '@' && onlykey <= '~')\n\t\t\tkey = onlykey & 0x1f;\n\t\telse\n\t\t\treturn (-1);\n\t}\n\n\tlog_debug(\"%s: key out %llx\", __func__, key);\n\n\tud.data[0] = key & 0x7f;\n\tinput_key_write(__func__, bev, &ud.data[0], 1);\n\treturn (0);\n}\n\n/* Pick keys that are reported as vt10x keys in modifyOtherKeys=1 mode. */\nstatic int\ninput_key_mode1(struct bufferevent *bev, key_code key)\n{\n\tkey_code\t onlykey;\n\n\tlog_debug(\"%s: key in %llx\", __func__, key);\n\n\t/* A regular or shifted key + Meta. */\n\tif ((key & (KEYC_CTRL | KEYC_META)) == KEYC_META)\n\t\treturn (input_key_vt10x(bev, key));\n\n\t/*\n\t * As per\n\t * https://invisible-island.net/xterm/modified-keys-us-pc105.html.\n\t */\n\tonlykey = key & KEYC_MASK_KEY;\n\tif ((key & KEYC_CTRL) &&\n\t    (onlykey == ' ' ||\n\t     onlykey == '/' ||\n\t     onlykey == '@' ||\n\t     onlykey == '^' ||\n\t     (onlykey >= '2' && onlykey <= '8') ||\n\t     (onlykey >= '@' && onlykey <= '~')))\n\t\treturn (input_key_vt10x(bev, key));\n\n\treturn (-1);\n}\n\n/* Translate a key code into an output key sequence. */\nint\ninput_key(struct screen *s, struct bufferevent *bev, key_code key)\n{\n\tstruct input_key_entry\t*ike = NULL;\n\tkey_code\t\t newkey;\n\tstruct utf8_data\t ud;\n\n\t/* Mouse keys need a pane. */\n\tif (KEYC_IS_MOUSE(key))\n\t\treturn (0);\n\n\t/* Literal keys go as themselves (can't be more than eight bits). */\n\tif (key & KEYC_LITERAL) {\n\t\tud.data[0] = (u_char)key;\n\t\tinput_key_write(__func__, bev, &ud.data[0], 1);\n\t\treturn (0);\n\t}\n\n\t/* Is this backspace? */\n\tif ((key & KEYC_MASK_KEY) == KEYC_BSPACE) {\n\t\tnewkey = options_get_number(global_options, \"backspace\");\n\t\tlog_debug(\"%s: key 0x%llx is backspace -> 0x%llx\", __func__,\n\t\t    key, newkey);\n\t\tif ((key & KEYC_MASK_MODIFIERS) == 0) {\n\t\t\tud.data[0] = 255;\n\t\t\tif ((newkey & KEYC_MASK_MODIFIERS) == 0)\n\t\t\t\tud.data[0] = newkey;\n\t\t\telse if ((newkey & KEYC_MASK_MODIFIERS) == KEYC_CTRL) {\n\t\t\t\tnewkey &= KEYC_MASK_KEY;\n\t\t\t\tif (newkey >= 'A' && newkey <= 'Z')\n\t\t\t\t\tud.data[0] = newkey - 0x40;\n\t\t\t\telse if (newkey >= 'a' && newkey <= 'z')\n\t\t\t\t\tud.data[0] = newkey - 0x60;\n\t\t\t}\n\t\t\tif (ud.data[0] != 255)\n\t\t\t\tinput_key_write(__func__, bev, &ud.data[0], 1);\n\t\t\treturn (0);\n\t\t}\n\t\tkey = newkey|(key & (KEYC_MASK_FLAGS|KEYC_MASK_MODIFIERS));\n\t}\n\n\t/* Is this backtab? */\n\tif ((key & KEYC_MASK_KEY) == KEYC_BTAB) {\n\t\tif (s->mode & MODE_KEYS_EXTENDED_2) {\n\t\t\t/* When in xterm extended mode, remap into S-Tab. */\n\t\t\tkey = '\\011' | (key & ~KEYC_MASK_KEY) | KEYC_SHIFT;\n\t\t} else {\n\t\t\t/* Otherwise clear modifiers. */\n\t\t\tkey &= ~KEYC_MASK_MODIFIERS;\n\t\t}\n\t}\n\n\t/*\n\t * A trivial case, that is a 7-bit key, excluding C0 control characters\n\t * that can't be entered from the keyboard, and no modifiers; or a UTF-8\n\t * key and no modifiers.\n\t */\n\tif (!(key & ~KEYC_MASK_KEY)) {\n\t\tif (key == C0_HT ||\n\t\t    key == C0_CR ||\n\t\t    key == C0_ESC ||\n\t\t    (key >= 0x20 && key <= 0x7f)) {\n\t\t\tud.data[0] = key;\n\t\t\tinput_key_write(__func__, bev, &ud.data[0], 1);\n\t\t\treturn (0);\n\t\t}\n\t\tif (KEYC_IS_UNICODE(key)) {\n\t\t\tutf8_to_data(key, &ud);\n\t\t\tinput_key_write(__func__, bev, ud.data, ud.size);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * Look up the standard VT10x keys in the tree. If not in application\n\t * keypad or cursor mode, remove the respective flags from the key.\n\t */\n\tif (~s->mode & MODE_KKEYPAD)\n\t\tkey &= ~KEYC_KEYPAD;\n\tif (~s->mode & MODE_KCURSOR)\n\t\tkey &= ~KEYC_CURSOR;\n\tif (ike == NULL)\n\t\tike = input_key_get(key);\n\tif (ike == NULL && (key & KEYC_META) && (~key & KEYC_IMPLIED_META))\n\t\tike = input_key_get(key & ~KEYC_META);\n\tif (ike == NULL && (key & KEYC_CURSOR))\n\t\tike = input_key_get(key & ~KEYC_CURSOR);\n\tif (ike == NULL && (key & KEYC_KEYPAD))\n\t\tike = input_key_get(key & ~KEYC_KEYPAD);\n\tif (ike != NULL) {\n\t\tlog_debug(\"%s: found key 0x%llx: \\\"%s\\\"\", __func__, key,\n\t\t    ike->data);\n\t\tif (KEYC_IS_PASTE(key) && (~s->mode & MODE_BRACKETPASTE))\n\t\t\treturn (0);\n\t\tif ((key & KEYC_META) && (~key & KEYC_IMPLIED_META))\n\t\t\tinput_key_write(__func__, bev, \"\\033\", 1);\n\t\tinput_key_write(__func__, bev, ike->data, strlen(ike->data));\n\t\treturn (0);\n\t}\n\n\t/* Ignore internal function key codes. */\n\tif ((key >= KEYC_BASE && key < KEYC_BASE_END) ||\n\t    (key >= KEYC_USER && key < KEYC_USER_END)) {\n\t\tlog_debug(\"%s: ignoring key 0x%llx\", __func__, key);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * No builtin key sequence; construct an extended key sequence\n\t * depending on the client mode.\n\t *\n\t * If something invalid reaches here, an invalid output may be\n\t * produced. For example Ctrl-Shift-2 is invalid (as there's\n\t * no way to enter it). The correct form is Ctrl-Shift-@, at\n\t * least in US English keyboard layout.\n\t */\n\tswitch (s->mode & EXTENDED_KEY_MODES) {\n\tcase MODE_KEYS_EXTENDED_2:\n\t\t/*\n\t\t * The simplest mode to handle - *all* modified keys are\n\t\t * reported in the extended form.\n\t\t */\n\t\treturn (input_key_extended(bev, key));\n        case MODE_KEYS_EXTENDED:\n\t\t/*\n\t\t * Some keys are still reported in standard mode, to maintain\n\t\t * compatibility with applications unaware of extended keys.\n\t\t */\n\t\tif (input_key_mode1(bev, key) == -1)\n\t\t\treturn (input_key_extended(bev, key));\n\t\treturn (0);\n\tdefault:\n\t\t/* The standard mode. */\n\t\treturn (input_key_vt10x(bev, key));\n\t}\n}\n\n/* Get mouse event string. */\nint\ninput_key_get_mouse(struct screen *s, struct mouse_event *m, u_int x, u_int y,\n    const char **rbuf, size_t *rlen)\n{\n\tstatic char\t buf[40];\n\tsize_t\t\t len;\n\n\t*rbuf = NULL;\n\t*rlen = 0;\n\n\t/* If this pane is not in button or all mode, discard motion events. */\n\tif (MOUSE_DRAG(m->b) && (s->mode & MOTION_MOUSE_MODES) == 0)\n\t\treturn (0);\n\tif ((s->mode & ALL_MOUSE_MODES) == 0)\n\t\treturn (0);\n\n\t/*\n\t * If this event is a release event and not in all mode, discard it.\n\t * In SGR mode we can tell absolutely because a release is normally\n\t * shown by the last character. Without SGR, we check if the last\n\t * buttons was also a release.\n\t */\n\tif (m->sgr_type != ' ') {\n\t\tif (MOUSE_DRAG(m->sgr_b) &&\n\t\t    MOUSE_RELEASE(m->sgr_b) &&\n\t\t    (~s->mode & MODE_MOUSE_ALL))\n\t\t\treturn (0);\n\t} else {\n\t\tif (MOUSE_DRAG(m->b) &&\n\t\t    MOUSE_RELEASE(m->b) &&\n\t\t    MOUSE_RELEASE(m->lb) &&\n\t\t    (~s->mode & MODE_MOUSE_ALL))\n\t\t\treturn (0);\n\t}\n\n\t/*\n\t * Use the SGR (1006) extension only if the application requested it\n\t * and the underlying terminal also sent the event in this format (this\n\t * is because an old style mouse release event cannot be converted into\n\t * the new SGR format, since the released button is unknown). Otherwise\n\t * pretend that tmux doesn't speak this extension, and fall back to the\n\t * UTF-8 (1005) extension if the application requested, or to the\n\t * legacy format.\n\t */\n\tif (m->sgr_type != ' ' && (s->mode & MODE_MOUSE_SGR)) {\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[<%u;%u;%u%c\",\n\t\t    m->sgr_b, x + 1, y + 1, m->sgr_type);\n\t} else if (s->mode & MODE_MOUSE_UTF8) {\n\t\tif (m->b > MOUSE_PARAM_UTF8_MAX - MOUSE_PARAM_BTN_OFF ||\n\t\t    x > MOUSE_PARAM_UTF8_MAX - MOUSE_PARAM_POS_OFF ||\n\t\t    y > MOUSE_PARAM_UTF8_MAX - MOUSE_PARAM_POS_OFF)\n\t\t\treturn (0);\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[M\");\n\t\tlen += input_key_split2(m->b + MOUSE_PARAM_BTN_OFF, &buf[len]);\n\t\tlen += input_key_split2(x + MOUSE_PARAM_POS_OFF, &buf[len]);\n\t\tlen += input_key_split2(y + MOUSE_PARAM_POS_OFF, &buf[len]);\n\t} else {\n\t\tif (m->b + MOUSE_PARAM_BTN_OFF > MOUSE_PARAM_MAX)\n\t\t\treturn (0);\n\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[M\");\n\t\tbuf[len++] = m->b + MOUSE_PARAM_BTN_OFF;\n\n\t\t/*\n\t\t * The incoming x and y may be out of the range which can be\n\t\t * supported by the \"normal\" mouse protocol. Clamp the\n\t\t * coordinates to the supported range.\n\t\t */\n\t\tif (x + MOUSE_PARAM_POS_OFF > MOUSE_PARAM_MAX)\n\t\t\tbuf[len++] = MOUSE_PARAM_MAX;\n\t\telse\n\t\t\tbuf[len++] = x + MOUSE_PARAM_POS_OFF;\n\t\tif (y + MOUSE_PARAM_POS_OFF > MOUSE_PARAM_MAX)\n\t\t\tbuf[len++] = MOUSE_PARAM_MAX;\n\t\telse\n\t\t\tbuf[len++] = y + MOUSE_PARAM_POS_OFF;\n\t}\n\n\t*rbuf = buf;\n\t*rlen = len;\n\treturn (1);\n}\n\n/* Translate mouse and output. */\nstatic void\ninput_key_mouse(struct window_pane *wp, struct mouse_event *m)\n{\n\tstruct screen\t*s = wp->screen;\n\tu_int\t\t x, y;\n\tconst char\t*buf;\n\tsize_t\t\t len;\n\n\t/* Ignore events if no mouse mode or the pane is not visible. */\n\tif (m->ignore || (s->mode & ALL_MOUSE_MODES) == 0)\n\t\treturn;\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn;\n\tif (!window_pane_visible(wp))\n\t\treturn;\n\tif (!input_key_get_mouse(s, m, x, y, &buf, &len))\n\t\treturn;\n\tlog_debug(\"writing mouse %.*s to %%%u\", (int)len, buf, wp->id);\n\tinput_key_write(__func__, wp->event, buf, len);\n}\n"
        },
        {
          "name": "input.c",
          "type": "blob",
          "size": 70.5126953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Based on the description by Paul Williams at:\n *\n * https://vt100.net/emu/dec_ansi_parser\n *\n * With the following changes:\n *\n * - 7-bit only.\n *\n * - Support for UTF-8.\n *\n * - OSC (but not APC) may be terminated by \\007 as well as ST.\n *\n * - A state for APC similar to OSC. Some terminals appear to use this to set\n *   the title.\n *\n * - A state for the screen \\033k...\\033\\\\ sequence to rename a window. This is\n *   pretty stupid but not supporting it is more trouble than it is worth.\n *\n * - Special handling for ESC inside a DCS to allow arbitrary byte sequences to\n *   be passed to the underlying terminals.\n */\n\n/* Input parser cell. */\nstruct input_cell {\n\tstruct grid_cell\tcell;\n\tint\t\t\tset;\n\tint\t\t\tg0set;\t/* 1 if ACS */\n\tint\t\t\tg1set;\t/* 1 if ACS */\n};\n\n/* Input parser argument. */\nstruct input_param {\n\tenum {\n\t\tINPUT_MISSING,\n\t\tINPUT_NUMBER,\n\t\tINPUT_STRING\n\t}\t\t\ttype;\n\tunion {\n\t\tint\t\tnum;\n\t\tchar\t       *str;\n\t};\n};\n\n/* Input parser context. */\nstruct input_ctx {\n\tstruct window_pane     *wp;\n\tstruct bufferevent     *event;\n\tstruct screen_write_ctx ctx;\n\tstruct colour_palette  *palette;\n\n\tstruct input_cell\tcell;\n\n\tstruct input_cell\told_cell;\n\tu_int\t\t\told_cx;\n\tu_int\t\t\told_cy;\n\tint\t\t\told_mode;\n\n\tu_char\t\t\tinterm_buf[4];\n\tsize_t\t\t\tinterm_len;\n\n\tu_char\t\t\tparam_buf[64];\n\tsize_t\t\t\tparam_len;\n\n#define INPUT_BUF_START 32\n\tu_char\t\t       *input_buf;\n\tsize_t\t\t\tinput_len;\n\tsize_t\t\t\tinput_space;\n\tenum {\n\t\tINPUT_END_ST,\n\t\tINPUT_END_BEL\n\t}\t\t\tinput_end;\n\n\tstruct input_param\tparam_list[24];\n\tu_int\t\t\tparam_list_len;\n\n\tstruct utf8_data\tutf8data;\n\tint\t\t\tutf8started;\n\n\tint\t\t\tch;\n\tstruct utf8_data\tlast;\n\n\tint\t\t\tflags;\n#define INPUT_DISCARD 0x1\n#define INPUT_LAST 0x2\n\n\tconst struct input_state *state;\n\n\tstruct event\t\ttimer;\n\n\t/*\n\t * All input received since we were last in the ground state. Sent to\n\t * control clients on connection.\n\t */\n\tstruct evbuffer\t\t*since_ground;\n};\n\n/* Helper functions. */\nstruct input_transition;\nstatic int\tinput_split(struct input_ctx *);\nstatic int\tinput_get(struct input_ctx *, u_int, int, int);\nstatic void printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);\nstatic void\tinput_set_state(struct input_ctx *,\n\t\t    const struct input_transition *);\nstatic void\tinput_reset_cell(struct input_ctx *);\n\nstatic void\tinput_osc_4(struct input_ctx *, const char *);\nstatic void\tinput_osc_8(struct input_ctx *, const char *);\nstatic void\tinput_osc_10(struct input_ctx *, const char *);\nstatic void\tinput_osc_11(struct input_ctx *, const char *);\nstatic void\tinput_osc_12(struct input_ctx *, const char *);\nstatic void\tinput_osc_52(struct input_ctx *, const char *);\nstatic void\tinput_osc_104(struct input_ctx *, const char *);\nstatic void\tinput_osc_110(struct input_ctx *, const char *);\nstatic void\tinput_osc_111(struct input_ctx *, const char *);\nstatic void\tinput_osc_112(struct input_ctx *, const char *);\nstatic void\tinput_osc_133(struct input_ctx *, const char *);\n\n/* Transition entry/exit handlers. */\nstatic void\tinput_clear(struct input_ctx *);\nstatic void\tinput_ground(struct input_ctx *);\nstatic void\tinput_enter_dcs(struct input_ctx *);\nstatic void\tinput_enter_osc(struct input_ctx *);\nstatic void\tinput_exit_osc(struct input_ctx *);\nstatic void\tinput_enter_apc(struct input_ctx *);\nstatic void\tinput_exit_apc(struct input_ctx *);\nstatic void\tinput_enter_rename(struct input_ctx *);\nstatic void\tinput_exit_rename(struct input_ctx *);\n\n/* Input state handlers. */\nstatic int\tinput_print(struct input_ctx *);\nstatic int\tinput_intermediate(struct input_ctx *);\nstatic int\tinput_parameter(struct input_ctx *);\nstatic int\tinput_input(struct input_ctx *);\nstatic int\tinput_c0_dispatch(struct input_ctx *);\nstatic int\tinput_esc_dispatch(struct input_ctx *);\nstatic int\tinput_csi_dispatch(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm_graphics(struct input_ctx *);\nstatic void\tinput_csi_dispatch_winops(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr(struct input_ctx *);\nstatic int\tinput_dcs_dispatch(struct input_ctx *);\nstatic int\tinput_top_bit_set(struct input_ctx *);\nstatic int\tinput_end_bel(struct input_ctx *);\n\n/* Command table comparison function. */\nstatic int\tinput_table_compare(const void *, const void *);\n\n/* Command table entry. */\nstruct input_table_entry {\n\tint\t\tch;\n\tconst char     *interm;\n\tint\t\ttype;\n};\n\n/* Escape commands. */\nenum input_esc_type {\n\tINPUT_ESC_DECALN,\n\tINPUT_ESC_DECKPAM,\n\tINPUT_ESC_DECKPNM,\n\tINPUT_ESC_DECRC,\n\tINPUT_ESC_DECSC,\n\tINPUT_ESC_HTS,\n\tINPUT_ESC_IND,\n\tINPUT_ESC_NEL,\n\tINPUT_ESC_RI,\n\tINPUT_ESC_RIS,\n\tINPUT_ESC_SCSG0_OFF,\n\tINPUT_ESC_SCSG0_ON,\n\tINPUT_ESC_SCSG1_OFF,\n\tINPUT_ESC_SCSG1_ON,\n\tINPUT_ESC_ST\n};\n\n/* Escape command table. */\nstatic const struct input_table_entry input_esc_table[] = {\n\t{ '0', \"(\", INPUT_ESC_SCSG0_ON },\n\t{ '0', \")\", INPUT_ESC_SCSG1_ON },\n\t{ '7', \"\",  INPUT_ESC_DECSC },\n\t{ '8', \"\",  INPUT_ESC_DECRC },\n\t{ '8', \"#\", INPUT_ESC_DECALN },\n\t{ '=', \"\",  INPUT_ESC_DECKPAM },\n\t{ '>', \"\",  INPUT_ESC_DECKPNM },\n\t{ 'B', \"(\", INPUT_ESC_SCSG0_OFF },\n\t{ 'B', \")\", INPUT_ESC_SCSG1_OFF },\n\t{ 'D', \"\",  INPUT_ESC_IND },\n\t{ 'E', \"\",  INPUT_ESC_NEL },\n\t{ 'H', \"\",  INPUT_ESC_HTS },\n\t{ 'M', \"\",  INPUT_ESC_RI },\n\t{ '\\\\', \"\", INPUT_ESC_ST },\n\t{ 'c', \"\",  INPUT_ESC_RIS },\n};\n\n/* Control (CSI) commands. */\nenum input_csi_type {\n\tINPUT_CSI_CBT,\n\tINPUT_CSI_CNL,\n\tINPUT_CSI_CPL,\n\tINPUT_CSI_CUB,\n\tINPUT_CSI_CUD,\n\tINPUT_CSI_CUF,\n\tINPUT_CSI_CUP,\n\tINPUT_CSI_CUU,\n\tINPUT_CSI_DA,\n\tINPUT_CSI_DA_TWO,\n\tINPUT_CSI_DCH,\n\tINPUT_CSI_DECSCUSR,\n\tINPUT_CSI_DECSTBM,\n\tINPUT_CSI_DL,\n\tINPUT_CSI_DSR,\n\tINPUT_CSI_ECH,\n\tINPUT_CSI_ED,\n\tINPUT_CSI_EL,\n\tINPUT_CSI_HPA,\n\tINPUT_CSI_ICH,\n\tINPUT_CSI_IL,\n\tINPUT_CSI_MODOFF,\n\tINPUT_CSI_MODSET,\n\tINPUT_CSI_RCP,\n\tINPUT_CSI_REP,\n\tINPUT_CSI_RM,\n\tINPUT_CSI_RM_PRIVATE,\n\tINPUT_CSI_SCP,\n\tINPUT_CSI_SD,\n\tINPUT_CSI_SGR,\n\tINPUT_CSI_SM,\n\tINPUT_CSI_SM_PRIVATE,\n\tINPUT_CSI_SM_GRAPHICS,\n\tINPUT_CSI_SU,\n\tINPUT_CSI_TBC,\n\tINPUT_CSI_VPA,\n\tINPUT_CSI_WINOPS,\n\tINPUT_CSI_XDA\n};\n\n/* Control (CSI) command table. */\nstatic const struct input_table_entry input_csi_table[] = {\n\t{ '@', \"\",  INPUT_CSI_ICH },\n\t{ 'A', \"\",  INPUT_CSI_CUU },\n\t{ 'B', \"\",  INPUT_CSI_CUD },\n\t{ 'C', \"\",  INPUT_CSI_CUF },\n\t{ 'D', \"\",  INPUT_CSI_CUB },\n\t{ 'E', \"\",  INPUT_CSI_CNL },\n\t{ 'F', \"\",  INPUT_CSI_CPL },\n\t{ 'G', \"\",  INPUT_CSI_HPA },\n\t{ 'H', \"\",  INPUT_CSI_CUP },\n\t{ 'J', \"\",  INPUT_CSI_ED },\n\t{ 'K', \"\",  INPUT_CSI_EL },\n\t{ 'L', \"\",  INPUT_CSI_IL },\n\t{ 'M', \"\",  INPUT_CSI_DL },\n\t{ 'P', \"\",  INPUT_CSI_DCH },\n\t{ 'S', \"\",  INPUT_CSI_SU },\n\t{ 'S', \"?\", INPUT_CSI_SM_GRAPHICS },\n\t{ 'T', \"\",  INPUT_CSI_SD },\n\t{ 'X', \"\",  INPUT_CSI_ECH },\n\t{ 'Z', \"\",  INPUT_CSI_CBT },\n\t{ '`', \"\",  INPUT_CSI_HPA },\n\t{ 'b', \"\",  INPUT_CSI_REP },\n\t{ 'c', \"\",  INPUT_CSI_DA },\n\t{ 'c', \">\", INPUT_CSI_DA_TWO },\n\t{ 'd', \"\",  INPUT_CSI_VPA },\n\t{ 'f', \"\",  INPUT_CSI_CUP },\n\t{ 'g', \"\",  INPUT_CSI_TBC },\n\t{ 'h', \"\",  INPUT_CSI_SM },\n\t{ 'h', \"?\", INPUT_CSI_SM_PRIVATE },\n\t{ 'l', \"\",  INPUT_CSI_RM },\n\t{ 'l', \"?\", INPUT_CSI_RM_PRIVATE },\n\t{ 'm', \"\",  INPUT_CSI_SGR },\n\t{ 'm', \">\", INPUT_CSI_MODSET },\n\t{ 'n', \"\",  INPUT_CSI_DSR },\n\t{ 'n', \">\", INPUT_CSI_MODOFF },\n\t{ 'q', \" \", INPUT_CSI_DECSCUSR },\n\t{ 'q', \">\", INPUT_CSI_XDA },\n\t{ 'r', \"\",  INPUT_CSI_DECSTBM },\n\t{ 's', \"\",  INPUT_CSI_SCP },\n\t{ 't', \"\",  INPUT_CSI_WINOPS },\n\t{ 'u', \"\",  INPUT_CSI_RCP }\n};\n\n/* Input transition. */\nstruct input_transition {\n\tint\t\t\t\tfirst;\n\tint\t\t\t\tlast;\n\n\tint\t\t\t\t(*handler)(struct input_ctx *);\n\tconst struct input_state       *state;\n};\n\n/* Input state. */\nstruct input_state {\n\tconst char\t\t\t*name;\n\tvoid\t\t\t\t(*enter)(struct input_ctx *);\n\tvoid\t\t\t\t(*exit)(struct input_ctx *);\n\tconst struct input_transition\t*transitions;\n};\n\n/* State transitions available from all states. */\n#define INPUT_STATE_ANYWHERE \\\n\t{ 0x18, 0x18, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1a, 0x1a, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1b, 0x1b, NULL,\t\t &input_state_esc_enter }\n\n/* Forward declarations of state tables. */\nstatic const struct input_transition input_state_ground_table[];\nstatic const struct input_transition input_state_esc_enter_table[];\nstatic const struct input_transition input_state_esc_intermediate_table[];\nstatic const struct input_transition input_state_csi_enter_table[];\nstatic const struct input_transition input_state_csi_parameter_table[];\nstatic const struct input_transition input_state_csi_intermediate_table[];\nstatic const struct input_transition input_state_csi_ignore_table[];\nstatic const struct input_transition input_state_dcs_enter_table[];\nstatic const struct input_transition input_state_dcs_parameter_table[];\nstatic const struct input_transition input_state_dcs_intermediate_table[];\nstatic const struct input_transition input_state_dcs_handler_table[];\nstatic const struct input_transition input_state_dcs_escape_table[];\nstatic const struct input_transition input_state_dcs_ignore_table[];\nstatic const struct input_transition input_state_osc_string_table[];\nstatic const struct input_transition input_state_apc_string_table[];\nstatic const struct input_transition input_state_rename_string_table[];\nstatic const struct input_transition input_state_consume_st_table[];\n\n/* ground state definition. */\nstatic const struct input_state input_state_ground = {\n\t\"ground\",\n\tinput_ground, NULL,\n\tinput_state_ground_table\n};\n\n/* esc_enter state definition. */\nstatic const struct input_state input_state_esc_enter = {\n\t\"esc_enter\",\n\tinput_clear, NULL,\n\tinput_state_esc_enter_table\n};\n\n/* esc_intermediate state definition. */\nstatic const struct input_state input_state_esc_intermediate = {\n\t\"esc_intermediate\",\n\tNULL, NULL,\n\tinput_state_esc_intermediate_table\n};\n\n/* csi_enter state definition. */\nstatic const struct input_state input_state_csi_enter = {\n\t\"csi_enter\",\n\tinput_clear, NULL,\n\tinput_state_csi_enter_table\n};\n\n/* csi_parameter state definition. */\nstatic const struct input_state input_state_csi_parameter = {\n\t\"csi_parameter\",\n\tNULL, NULL,\n\tinput_state_csi_parameter_table\n};\n\n/* csi_intermediate state definition. */\nstatic const struct input_state input_state_csi_intermediate = {\n\t\"csi_intermediate\",\n\tNULL, NULL,\n\tinput_state_csi_intermediate_table\n};\n\n/* csi_ignore state definition. */\nstatic const struct input_state input_state_csi_ignore = {\n\t\"csi_ignore\",\n\tNULL, NULL,\n\tinput_state_csi_ignore_table\n};\n\n/* dcs_enter state definition. */\nstatic const struct input_state input_state_dcs_enter = {\n\t\"dcs_enter\",\n\tinput_enter_dcs, NULL,\n\tinput_state_dcs_enter_table\n};\n\n/* dcs_parameter state definition. */\nstatic const struct input_state input_state_dcs_parameter = {\n\t\"dcs_parameter\",\n\tNULL, NULL,\n\tinput_state_dcs_parameter_table\n};\n\n/* dcs_intermediate state definition. */\nstatic const struct input_state input_state_dcs_intermediate = {\n\t\"dcs_intermediate\",\n\tNULL, NULL,\n\tinput_state_dcs_intermediate_table\n};\n\n/* dcs_handler state definition. */\nstatic const struct input_state input_state_dcs_handler = {\n\t\"dcs_handler\",\n\tNULL, NULL,\n\tinput_state_dcs_handler_table\n};\n\n/* dcs_escape state definition. */\nstatic const struct input_state input_state_dcs_escape = {\n\t\"dcs_escape\",\n\tNULL, NULL,\n\tinput_state_dcs_escape_table\n};\n\n/* dcs_ignore state definition. */\nstatic const struct input_state input_state_dcs_ignore = {\n\t\"dcs_ignore\",\n\tNULL, NULL,\n\tinput_state_dcs_ignore_table\n};\n\n/* osc_string state definition. */\nstatic const struct input_state input_state_osc_string = {\n\t\"osc_string\",\n\tinput_enter_osc, input_exit_osc,\n\tinput_state_osc_string_table\n};\n\n/* apc_string state definition. */\nstatic const struct input_state input_state_apc_string = {\n\t\"apc_string\",\n\tinput_enter_apc, input_exit_apc,\n\tinput_state_apc_string_table\n};\n\n/* rename_string state definition. */\nstatic const struct input_state input_state_rename_string = {\n\t\"rename_string\",\n\tinput_enter_rename, input_exit_rename,\n\tinput_state_rename_string_table\n};\n\n/* consume_st state definition. */\nstatic const struct input_state input_state_consume_st = {\n\t\"consume_st\",\n\tinput_enter_rename, NULL, /* rename also waits for ST */\n\tinput_state_consume_st_table\n};\n\n/* ground state table. */\nstatic const struct input_transition input_state_ground_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x7e, input_print,\t NULL },\n\t{ 0x7f, 0x7f, NULL,\t\t NULL },\n\t{ 0x80, 0xff, input_top_bit_set, NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_enter state table. */\nstatic const struct input_transition input_state_esc_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_esc_intermediate },\n\t{ 0x30, 0x4f, input_esc_dispatch, &input_state_ground },\n\t{ 0x50, 0x50, NULL,\t\t  &input_state_dcs_enter },\n\t{ 0x51, 0x57, input_esc_dispatch, &input_state_ground },\n\t{ 0x58, 0x58, NULL,\t\t  &input_state_consume_st },\n\t{ 0x59, 0x59, input_esc_dispatch, &input_state_ground },\n\t{ 0x5a, 0x5a, input_esc_dispatch, &input_state_ground },\n\t{ 0x5b, 0x5b, NULL,\t\t  &input_state_csi_enter },\n\t{ 0x5c, 0x5c, input_esc_dispatch, &input_state_ground },\n\t{ 0x5d, 0x5d, NULL,\t\t  &input_state_osc_string },\n\t{ 0x5e, 0x5e, NULL,\t\t  &input_state_consume_st },\n\t{ 0x5f, 0x5f, NULL,\t\t  &input_state_apc_string },\n\t{ 0x60, 0x6a, input_esc_dispatch, &input_state_ground },\n\t{ 0x6b, 0x6b, NULL,\t\t  &input_state_rename_string },\n\t{ 0x6c, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_intermediate state table. */\nstatic const struct input_transition input_state_esc_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_enter state table. */\nstatic const struct input_transition input_state_csi_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3a, 0x3a, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_csi_parameter },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_parameter state table. */\nstatic const struct input_transition input_state_csi_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, input_parameter,\t  NULL },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_intermediate state table. */\nstatic const struct input_transition input_state_csi_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_ignore state table. */\nstatic const struct input_transition input_state_csi_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x3f, NULL,\t\t NULL },\n\t{ 0x40, 0x7e, NULL,\t\t &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_enter state table. */\nstatic const struct input_transition input_state_dcs_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_dcs_parameter },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_parameter state table. */\nstatic const struct input_transition input_state_dcs_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_intermediate state table. */\nstatic const struct input_transition input_state_dcs_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_handler state table. */\nstatic const struct input_transition input_state_dcs_handler_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x1a, input_input,  NULL },\n\t{ 0x1b, 0x1b, NULL,\t    &input_state_dcs_escape },\n\t{ 0x1c, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_escape state table. */\nstatic const struct input_transition input_state_dcs_escape_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x5b, input_input,\t  &input_state_dcs_handler },\n\t{ 0x5c, 0x5c, input_dcs_dispatch, &input_state_ground },\n\t{ 0x5d, 0xff, input_input,\t  &input_state_dcs_handler },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_ignore state table. */\nstatic const struct input_transition input_state_dcs_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* osc_string state table. */\nstatic const struct input_transition input_state_osc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x06, NULL,\t     NULL },\n\t{ 0x07, 0x07, input_end_bel, &input_state_ground },\n\t{ 0x08, 0x17, NULL,\t     NULL },\n\t{ 0x19, 0x19, NULL,\t     NULL },\n\t{ 0x1c, 0x1f, NULL,\t     NULL },\n\t{ 0x20, 0xff, input_input,   NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* apc_string state table. */\nstatic const struct input_transition input_state_apc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* rename_string state table. */\nstatic const struct input_transition input_state_rename_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* consume_st state table. */\nstatic const struct input_transition input_state_consume_st_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* Maximum of bytes allowed to read in a single input. */\nstatic size_t input_buffer_size = INPUT_BUF_DEFAULT_SIZE;\n\n/* Input table compare. */\nstatic int\ninput_table_compare(const void *key, const void *value)\n{\n\tconst struct input_ctx\t\t*ictx = key;\n\tconst struct input_table_entry\t*entry = value;\n\n\tif (ictx->ch != entry->ch)\n\t\treturn (ictx->ch - entry->ch);\n\treturn (strcmp(ictx->interm_buf, entry->interm));\n}\n\n/*\n * Timer - if this expires then have been waiting for a terminator for too\n * long, so reset to ground.\n */\nstatic void\ninput_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct input_ctx\t*ictx = arg;\n\n\tlog_debug(\"%s: %s expired\" , __func__, ictx->state->name);\n\tinput_reset(ictx, 0);\n}\n\n/* Start the timer. */\nstatic void\ninput_start_timer(struct input_ctx *ictx)\n{\n\tstruct timeval\ttv = { .tv_sec = 5, .tv_usec = 0 };\n\n\tevent_del(&ictx->timer);\n\tevent_add(&ictx->timer, &tv);\n}\n\n/* Reset cell state to default. */\nstatic void\ninput_reset_cell(struct input_ctx *ictx)\n{\n\tmemcpy(&ictx->cell.cell, &grid_default_cell, sizeof ictx->cell.cell);\n\tictx->cell.set = 0;\n\tictx->cell.g0set = ictx->cell.g1set = 0;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = 0;\n\tictx->old_cy = 0;\n}\n\n/* Save screen state. */\nstatic void\ninput_save_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = s->cx;\n\tictx->old_cy = s->cy;\n\tictx->old_mode = s->mode;\n}\n\n/* Restore screen state. */\nstatic void\ninput_restore_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tmemcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);\n\tif (ictx->old_mode & MODE_ORIGIN)\n\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\telse\n\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\tscreen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy, 0);\n}\n\n/* Initialise input parser. */\nstruct input_ctx *\ninput_init(struct window_pane *wp, struct bufferevent *bev,\n    struct colour_palette *palette)\n{\n\tstruct input_ctx\t*ictx;\n\n\tictx = xcalloc(1, sizeof *ictx);\n\tictx->wp = wp;\n\tictx->event = bev;\n\tictx->palette = palette;\n\n\tictx->input_space = INPUT_BUF_START;\n\tictx->input_buf = xmalloc(INPUT_BUF_START);\n\n\tictx->since_ground = evbuffer_new();\n\tif (ictx->since_ground == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tevtimer_set(&ictx->timer, input_timer_callback, ictx);\n\n\tinput_reset(ictx, 0);\n\treturn (ictx);\n}\n\n/* Destroy input parser. */\nvoid\ninput_free(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\n\tevent_del(&ictx->timer);\n\n\tfree(ictx->input_buf);\n\tevbuffer_free(ictx->since_ground);\n\n\tfree(ictx);\n}\n\n/* Reset input state and clear screen. */\nvoid\ninput_reset(struct input_ctx *ictx, int clear)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tinput_reset_cell(ictx);\n\n\tif (clear && wp != NULL) {\n\t\tif (TAILQ_EMPTY(&wp->modes))\n\t\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\t\telse\n\t\t\tscreen_write_start(sctx, &wp->base);\n\t\tscreen_write_reset(sctx);\n\t\tscreen_write_stop(sctx);\n\t}\n\n\tinput_clear(ictx);\n\n\tictx->state = &input_state_ground;\n\tictx->flags = 0;\n}\n\n/* Return pending data. */\nstruct evbuffer *\ninput_pending(struct input_ctx *ictx)\n{\n\treturn (ictx->since_ground);\n}\n\n/* Change input state. */\nstatic void\ninput_set_state(struct input_ctx *ictx, const struct input_transition *itr)\n{\n\tif (ictx->state->exit != NULL)\n\t\tictx->state->exit(ictx);\n\tictx->state = itr->state;\n\tif (ictx->state->enter != NULL)\n\t\tictx->state->enter(ictx);\n}\n\n/* Parse data. */\nstatic void\ninput_parse(struct input_ctx *ictx, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tconst struct input_state\t*state = NULL;\n\tconst struct input_transition\t*itr = NULL;\n\tsize_t\t\t\t\t off = 0;\n\n\t/* Parse the input. */\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\n\t\t/* Find the transition. */\n\t\tif (ictx->state != state ||\n\t\t    itr == NULL ||\n\t\t    ictx->ch < itr->first ||\n\t\t    ictx->ch > itr->last) {\n\t\t\titr = ictx->state->transitions;\n\t\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\t\tif (ictx->ch >= itr->first &&\n\t\t\t\t    ictx->ch <= itr->last)\n\t\t\t\t\tbreak;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\t\t/* No transition? Eh? */\n\t\t\t\tfatalx(\"no transition from state\");\n\t\t\t}\n\t\t}\n\t\tstate = ictx->state;\n\n\t\t/*\n\t\t * Any state except print stops the current collection. This is\n\t\t * an optimization to avoid checking if the attributes have\n\t\t * changed for every character. It will stop unnecessarily for\n\t\t * sequences that don't make a terminal change, but they should\n\t\t * be the minority.\n\t\t */\n\t\tif (itr->handler != input_print)\n\t\t\tscreen_write_collect_end(sctx);\n\n\t\t/*\n\t\t * Execute the handler, if any. Don't switch state if it\n\t\t * returns non-zero.\n\t\t */\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\n\t\t/* And switch state, if necessary. */\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(ictx, itr);\n\n\t\t/* If not in ground state, save input. */\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n}\n\n/* Parse input from pane. */\nvoid\ninput_parse_pane(struct window_pane *wp)\n{\n\tvoid\t*new_data;\n\tsize_t\t new_size;\n\n\tnew_data = window_pane_get_new_data(wp, &wp->offset, &new_size);\n\tinput_parse_buffer(wp, new_data, new_size);\n\twindow_pane_update_used_data(wp, &wp->offset, new_size);\n}\n\n/* Parse given input. */\nvoid\ninput_parse_buffer(struct window_pane *wp, u_char *buf, size_t len)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\twindow_update_activity(wp->window);\n\twp->flags |= PANE_CHANGED;\n\n\t/* Flag new input while in a mode. */\n\tif (!TAILQ_EMPTY(&wp->modes))\n\t\twp->flags |= PANE_UNSEENCHANGES;\n\n\t/* NULL wp if there is a mode set as don't want to update the tty. */\n\tif (TAILQ_EMPTY(&wp->modes))\n\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(sctx, &wp->base);\n\n\tlog_debug(\"%s: %%%u %s, %zu bytes: %.*s\", __func__, wp->id,\n\t    ictx->state->name, len, (int)len, buf);\n\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Parse given input for screen. */\nvoid\ninput_parse_screen(struct input_ctx *ictx, struct screen *s,\n    screen_write_init_ctx_cb cb, void *arg, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\tscreen_write_start_callback(sctx, s, cb, arg);\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Split the parameter list (if any). */\nstatic int\ninput_split(struct input_ctx *ictx)\n{\n\tconst char\t\t*errstr;\n\tchar\t\t\t*ptr, *out;\n\tstruct input_param\t*ip;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\tictx->param_list_len = 0;\n\n\tif (ictx->param_len == 0)\n\t\treturn (0);\n\tip = &ictx->param_list[0];\n\n\tptr = ictx->param_buf;\n\twhile ((out = strsep(&ptr, \";\")) != NULL) {\n\t\tif (*out == '\\0')\n\t\t\tip->type = INPUT_MISSING;\n\t\telse {\n\t\t\tif (strchr(out, ':') != NULL) {\n\t\t\t\tip->type = INPUT_STRING;\n\t\t\t\tip->str = xstrdup(out);\n\t\t\t} else {\n\t\t\t\tip->type = INPUT_NUMBER;\n\t\t\t\tip->num = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t\tip = &ictx->param_list[++ictx->param_list_len];\n\t\tif (ictx->param_list_len == nitems(ictx->param_list))\n\t\t\treturn (-1);\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tip = &ictx->param_list[i];\n\t\tif (ip->type == INPUT_MISSING)\n\t\t\tlog_debug(\"parameter %u: missing\", i);\n\t\telse if (ip->type == INPUT_STRING)\n\t\t\tlog_debug(\"parameter %u: string %s\", i, ip->str);\n\t\telse if (ip->type == INPUT_NUMBER)\n\t\t\tlog_debug(\"parameter %u: number %d\", i, ip->num);\n\t}\n\n\treturn (0);\n}\n\n/* Get an argument or return default value. */\nstatic int\ninput_get(struct input_ctx *ictx, u_int validx, int minval, int defval)\n{\n\tstruct input_param\t*ip;\n\tint\t\t\t retval;\n\n\tif (validx >= ictx->param_list_len)\n\t    return (defval);\n\tip = &ictx->param_list[validx];\n\tif (ip->type == INPUT_MISSING)\n\t\treturn (defval);\n\tif (ip->type == INPUT_STRING)\n\t\treturn (-1);\n\tretval = ip->num;\n\tif (retval < minval)\n\t\treturn (minval);\n\treturn (retval);\n}\n\n/* Reply to terminal query. */\nstatic void\ninput_reply(struct input_ctx *ictx, const char *fmt, ...)\n{\n\tstruct bufferevent\t*bev = ictx->event;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*reply;\n\n\tif (bev == NULL)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\txvasprintf(&reply, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"%s: %s\", __func__, reply);\n\tbufferevent_write(bev, reply, strlen(reply));\n\tfree(reply);\n}\n\n/* Clear saved state. */\nstatic void\ninput_clear(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\n\t*ictx->interm_buf = '\\0';\n\tictx->interm_len = 0;\n\n\t*ictx->param_buf = '\\0';\n\tictx->param_len = 0;\n\n\t*ictx->input_buf = '\\0';\n\tictx->input_len = 0;\n\n\tictx->input_end = INPUT_END_ST;\n\n\tictx->flags &= ~INPUT_DISCARD;\n}\n\n/* Reset for ground state. */\nstatic void\ninput_ground(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\tevbuffer_drain(ictx->since_ground, EVBUFFER_LENGTH(ictx->since_ground));\n\n\tif (ictx->input_space > INPUT_BUF_START) {\n\t\tictx->input_space = INPUT_BUF_START;\n\t\tictx->input_buf = xrealloc(ictx->input_buf, INPUT_BUF_START);\n\t}\n}\n\n/* Output this character to the screen. */\nstatic int\ninput_print(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tint\t\t\t set;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tset = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;\n\tif (set == 1)\n\t\tictx->cell.cell.attr |= GRID_ATTR_CHARSET;\n\telse\n\t\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\tutf8_set(&ictx->cell.cell.data, ictx->ch);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\n\tutf8_copy(&ictx->last, &ictx->cell.cell.data);\n\tictx->flags |= INPUT_LAST;\n\n\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\treturn (0);\n}\n\n/* Collect intermediate string. */\nstatic int\ninput_intermediate(struct input_ctx *ictx)\n{\n\tif (ictx->interm_len == (sizeof ictx->interm_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->interm_buf[ictx->interm_len++] = ictx->ch;\n\t\tictx->interm_buf[ictx->interm_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect parameter string. */\nstatic int\ninput_parameter(struct input_ctx *ictx)\n{\n\tif (ictx->param_len == (sizeof ictx->param_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->param_buf[ictx->param_len++] = ictx->ch;\n\t\tictx->param_buf[ictx->param_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect input string. */\nstatic int\ninput_input(struct input_ctx *ictx)\n{\n\tsize_t available;\n\n\tavailable = ictx->input_space;\n\twhile (ictx->input_len + 1 >= available) {\n\t\tavailable *= 2;\n\t\tif (available > input_buffer_size) {\n\t\t\tictx->flags |= INPUT_DISCARD;\n\t\t\treturn (0);\n\t\t}\n\t\tictx->input_buf = xrealloc(ictx->input_buf, available);\n\t\tictx->input_space = available;\n\t}\n\tictx->input_buf[ictx->input_len++] = ictx->ch;\n\tictx->input_buf[ictx->input_len] = '\\0';\n\n\treturn (0);\n}\n\n/* Execute C0 control sequence. */\nstatic int\ninput_c0_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct screen\t\t*s = sctx->s;\n\tstruct grid_cell\t gc, first_gc;\n\tu_int\t\t\t cx = s->cx, line = s->cy + s->grid->hsize;\n\tu_int\t\t\t width;\n\tint\t\t\t has_content = 0;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tlog_debug(\"%s: '%c'\", __func__, ictx->ch);\n\n\tswitch (ictx->ch) {\n\tcase '\\000':\t/* NUL */\n\t\tbreak;\n\tcase '\\007':\t/* BEL */\n\t\tif (wp != NULL)\n\t\t\talerts_queue(wp->window, WINDOW_BELL);\n\t\tbreak;\n\tcase '\\010':\t/* BS */\n\t\tscreen_write_backspace(sctx);\n\t\tbreak;\n\tcase '\\011':\t/* HT */\n\t\t/* Don't tab beyond the end of the line. */\n\t\tif (s->cx >= screen_size_x(s) - 1)\n\t\t\tbreak;\n\n\t\t/* Find the next tab point, or use the last column if none. */\n\t\tgrid_get_cell(s->grid, s->cx, line, &first_gc);\n\t\tdo {\n\t\t\tif (!has_content) {\n\t\t\t\tgrid_get_cell(s->grid, cx, line, &gc);\n\t\t\t\tif (gc.data.size != 1 ||\n\t\t\t\t    *gc.data.data != ' ' ||\n\t\t\t\t    !grid_cells_look_equal(&gc, &first_gc))\n\t\t\t\t\thas_content = 1;\n\t\t\t}\n\t\t\tcx++;\n\t\t\tif (bit_test(s->tabs, cx))\n\t\t\t\tbreak;\n\t\t} while (cx < screen_size_x(s) - 1);\n\n\t\twidth = cx - s->cx;\n\t\tif (has_content || width > sizeof gc.data.data)\n\t\t\ts->cx = cx;\n\t\telse {\n\t\t\tgrid_get_cell(s->grid, s->cx, line, &gc);\n\t\t\tgrid_set_tab(&gc, width);\n\t\t\tscreen_write_collect_add(sctx, &gc);\n\t\t}\n\t\tbreak;\n\tcase '\\012':\t/* LF */\n\tcase '\\013':\t/* VT */\n\tcase '\\014':\t/* FF */\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tif (s->mode & MODE_CRLF)\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\015':\t/* CR */\n\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\016':\t/* SO */\n\t\tictx->cell.set = 1;\n\t\tbreak;\n\tcase '\\017':\t/* SI */\n\t\tictx->cell.set = 0;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\tbreak;\n\t}\n\n\tictx->flags &= ~INPUT_LAST;\n\treturn (0);\n}\n\n/* Execute escape sequence. */\nstatic int\ninput_esc_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tstruct screen\t\t\t*s = sctx->s;\n\tstruct input_table_entry\t*entry;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\tlog_debug(\"%s: '%c', %s\", __func__, ictx->ch, ictx->interm_buf);\n\n\tentry = bsearch(ictx, input_esc_table, nitems(input_esc_table),\n\t    sizeof input_esc_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_ESC_RIS:\n\t\tcolour_palette_clear(ictx->palette);\n\t\tinput_reset_cell(ictx);\n\t\tscreen_write_reset(sctx);\n\t\tscreen_write_fullredraw(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_IND:\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_NEL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_HTS:\n\t\tif (s->cx < screen_size_x(s))\n\t\t\tbit_set(s->tabs, s->cx);\n\t\tbreak;\n\tcase INPUT_ESC_RI:\n\t\tscreen_write_reverseindex(sctx, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPAM:\n\t\tscreen_write_mode_set(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPNM:\n\t\tscreen_write_mode_clear(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECSC:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECRC:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECALN:\n\t\tscreen_write_alignmenttest(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_ON:\n\t\tictx->cell.g0set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_OFF:\n\t\tictx->cell.g0set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_ON:\n\t\tictx->cell.g1set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_OFF:\n\t\tictx->cell.g1set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_ST:\n\t\t/* ST terminates OSC but the state transition already did it. */\n\t\tbreak;\n\t}\n\n\tictx->flags &= ~INPUT_LAST;\n\treturn (0);\n}\n\n/* Execute control sequence. */\nstatic int\ninput_csi_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t       *sctx = &ictx->ctx;\n\tstruct screen\t\t       *s = sctx->s;\n\tstruct input_table_entry       *entry;\n\tint\t\t\t\ti, n, m, ek, set;\n\tu_int\t\t\t\tcx, bg = ictx->cell.cell.bg;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: '%c' \\\"%s\\\" \\\"%s\\\"\", __func__, ictx->ch,\n\t    ictx->interm_buf, ictx->param_buf);\n\n\tif (input_split(ictx) != 0)\n\t\treturn (0);\n\n\tentry = bsearch(ictx, input_csi_table, nitems(input_csi_table),\n\t    sizeof input_csi_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_CSI_CBT:\n\t\t/* Find the previous tab point, n times. */\n\t\tcx = s->cx;\n\t\tif (cx > screen_size_x(s) - 1)\n\t\t\tcx = screen_size_x(s) - 1;\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\t\twhile (cx > 0 && n-- > 0) {\n\t\t\tdo\n\t\t\t\tcx--;\n\t\t\twhile (cx > 0 && !bit_test(s->tabs, cx));\n\t\t}\n\t\ts->cx = cx;\n\t\tbreak;\n\tcase INPUT_CSI_CUB:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorleft(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUF:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorright(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, 1);\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_cursormove(sctx, m - 1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_MODSET:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n != 4)\n\t\t\tbreak;\n\t\tm = input_get(ictx, 1, 0, 0);\n\n\t\t/*\n\t\t * Set the extended key reporting mode as per the client\n\t\t * request, unless \"extended-keys\" is set to \"off\".\n\t\t */\n\t\tek = options_get_number(global_options, \"extended-keys\");\n\t\tif (ek == 0)\n\t\t\tbreak;\n\t\tscreen_write_mode_clear(sctx, EXTENDED_KEY_MODES);\n\t\tif (m == 2)\n\t\t\tscreen_write_mode_set(sctx, MODE_KEYS_EXTENDED_2);\n\t\telse if (m == 1 || ek == 2)\n\t\t\tscreen_write_mode_set(sctx, MODE_KEYS_EXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_MODOFF:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n != 4)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Clear the extended key reporting mode as per the client\n\t\t * request, unless \"extended-keys always\" forces into mode 1.\n\t\t */\n\t\tscreen_write_mode_clear(sctx,\n\t\t    MODE_KEYS_EXTENDED|MODE_KEYS_EXTENDED_2);\n\t\tif (options_get_number(global_options, \"extended-keys\") == 2)\n\t\t\tscreen_write_mode_set(sctx, MODE_KEYS_EXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_WINOPS:\n\t\tinput_csi_dispatch_winops(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_CUU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CNL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_CPL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n#ifdef ENABLE_SIXEL\n\t\t\tinput_reply(ictx, \"\\033[?1;2;4c\");\n#else\n\t\t\tinput_reply(ictx, \"\\033[?1;2c\");\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA_TWO:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[>84;0;0c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ECH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_clearcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DCH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deletecharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DECSTBM:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, screen_size_y(s));\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_scrollregion(sctx, n - 1, m - 1);\n\t\tbreak;\n\tcase INPUT_CSI_DL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deleteline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DSR:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinput_reply(ictx, \"\\033[0n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tinput_reply(ictx, \"\\033[%u;%uR\", s->cy + 1, s->cx + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ED:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (input_get(ictx, 1, 0, 0) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Linux console extension to clear history\n\t\t\t\t * (for example before locking the screen).\n\t\t\t\t */\n\t\t\t\tscreen_write_clearhistory(sctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_EL:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearline(sctx, bg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_HPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, n - 1, -1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_ICH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_IL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_REP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\n\t\tm = screen_size_x(s) - s->cx;\n\t\tif (n > m)\n\t\t\tn = m;\n\n\t\tif (~ictx->flags & INPUT_LAST)\n\t\t\tbreak;\n\n\t\tset = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;\n\t\tif (set == 1)\n\t\t\tictx->cell.cell.attr |= GRID_ATTR_CHARSET;\n\t\telse\n\t\t\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\t\tutf8_copy(&ictx->cell.cell.data, &ictx->last);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\t\tbreak;\n\tcase INPUT_CSI_RCP:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM:\n\t\tinput_csi_dispatch_rm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM_PRIVATE:\n\t\tinput_csi_dispatch_rm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SCP:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SGR:\n\t\tinput_csi_dispatch_sgr(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM:\n\t\tinput_csi_dispatch_sm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM_PRIVATE:\n\t\tinput_csi_dispatch_sm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM_GRAPHICS:\n\t\tinput_csi_dispatch_sm_graphics(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrollup(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_SD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrolldown(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_TBC:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (s->cx < screen_size_x(s))\n\t\t\t\tbit_clear(s->tabs, s->cx);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_nclear(s->tabs, 0, screen_size_x(s) - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_VPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, -1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_DECSCUSR:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n != -1)\n\t\t\tscreen_set_cursor_style(n, &s->cstyle, &s->mode);\n\t\tbreak;\n\tcase INPUT_CSI_XDA:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n == 0)\n\t\t\tinput_reply(ictx, \"\\033P>|tmux %s\\033\\\\\", getversion());\n\t\tbreak;\n\n\t}\n\n\tictx->flags &= ~INPUT_LAST;\n\treturn (0);\n}\n\n/* Handle CSI RM. */\nstatic void\ninput_csi_dispatch_rm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR_VERY_VISIBLE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private RM. */\nstatic void\ninput_csi_dispatch_rm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, gc->bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_clear(sctx, MODE_CURSOR_BLINKING);\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR_BLINKING_SET);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\tcase 1001:\n\t\tcase 1002:\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_FOCUSON);\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateoff(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateoff(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI SM. */\nstatic void\ninput_csi_dispatch_sm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_set(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_clear(sctx, MODE_CURSOR_VERY_VISIBLE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private SM. */\nstatic void\ninput_csi_dispatch_sm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_set(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, ictx->cell.cell.bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_set(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR_BLINKING);\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR_BLINKING_SET);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_STANDARD);\n\t\t\tbreak;\n\t\tcase 1002:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_BUTTON);\n\t\t\tbreak;\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_ALL);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tscreen_write_mode_set(sctx, MODE_FOCUSON);\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateon(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateon(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_set(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI graphics SM. */\nstatic void\ninput_csi_dispatch_sm_graphics(__unused struct input_ctx *ictx)\n{\n#ifdef ENABLE_SIXEL\n\tint\tn, m, o;\n\n\tif (ictx->param_list_len > 3)\n\t\treturn;\n\tn = input_get(ictx, 0, 0, 0);\n\tm = input_get(ictx, 1, 0, 0);\n\to = input_get(ictx, 2, 0, 0);\n\n\tif (n == 1 && (m == 1 || m == 2 || m == 4))\n\t\tinput_reply(ictx, \"\\033[?%d;0;%uS\", n, SIXEL_COLOUR_REGISTERS);\n\telse\n\t\tinput_reply(ictx, \"\\033[?%d;3;%dS\", n, o);\n#endif\n}\n\n/* Handle CSI window operations. */\nstatic void\ninput_csi_dispatch_winops(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct window\t\t*w = NULL;\n\tu_int\t\t\t x = screen_size_x(s), y = screen_size_y(s);\n\tint\t\t\t n, m;\n\n\tif (wp != NULL)\n\t\tw = wp->window;\n\n\tm = 0;\n\twhile ((n = input_get(ictx, m, 0, -1)) != -1) {\n\t\tswitch (n) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 11:\n\t\tcase 13:\n\t\tcase 20:\n\t\tcase 21:\n\t\tcase 24:\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 9:\n\t\tcase 10:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tif (w == NULL)\n\t\t\t\tbreak;\n\t\t\tinput_reply(ictx, \"\\033[4;%u;%ut\", y * w->ypixel,\n\t\t\t    x * w->xpixel);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tif (w == NULL)\n\t\t\t\tbreak;\n\t\t\tinput_reply(ictx, \"\\033[5;%u;%ut\", y * w->ypixel,\n\t\t\t    x * w->xpixel);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (w == NULL)\n\t\t\t\tbreak;\n\t\t\tinput_reply(ictx, \"\\033[6;%u;%ut\", w->ypixel,\n\t\t\t    w->xpixel);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tinput_reply(ictx, \"\\033[8;%u;%ut\", y, x);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\tinput_reply(ictx, \"\\033[9;%u;%ut\", y, x);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_push_title(sctx->s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_pop_title(sctx->s);\n\t\t\t\tif (wp == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\t\tserver_redraw_window_borders(w);\n\t\t\t\tserver_status_window(w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tm++;\n\t}\n}\n\n/* Helper for 256 colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_256_do(struct input_ctx *ictx, int fgbg, int c)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (c == -1 || c > 255) {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = 8;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = 8;\n\t} else {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 58)\n\t\t\tgc->us = c | COLOUR_FLAG_256;\n\t}\n\treturn (1);\n}\n\n/* Handle CSI SGR for 256 colours. */\nstatic void\ninput_csi_dispatch_sgr_256(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tc;\n\n\tc = input_get(ictx, (*i) + 1, 0, -1);\n\tif (input_csi_dispatch_sgr_256_do(ictx, fgbg, c))\n\t\t(*i)++;\n}\n\n/* Helper for RGB colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_rgb_do(struct input_ctx *ictx, int fgbg, int r, int g,\n    int b)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (r == -1 || r > 255)\n\t\treturn (0);\n\tif (g == -1 || g > 255)\n\t\treturn (0);\n\tif (b == -1 || b > 255)\n\t\treturn (0);\n\n\tif (fgbg == 38)\n\t\tgc->fg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 48)\n\t\tgc->bg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 58)\n\t\tgc->us = colour_join_rgb(r, g, b);\n\treturn (1);\n}\n\n/* Handle CSI SGR for RGB colours. */\nstatic void\ninput_csi_dispatch_sgr_rgb(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tr, g, b;\n\n\tr = input_get(ictx, (*i) + 1, 0, -1);\n\tg = input_get(ictx, (*i) + 2, 0, -1);\n\tb = input_get(ictx, (*i) + 3, 0, -1);\n\tif (input_csi_dispatch_sgr_rgb_do(ictx, fgbg, r, g, b))\n\t\t(*i) += 3;\n}\n\n/* Handle CSI SGR with a ISO parameter. */\nstatic void\ninput_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tn++;\n\t\t\tif (n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}\n\n/* Handle CSI SGR. */\nstatic void\ninput_csi_dispatch_sgr(struct input_ctx *ictx)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i, link;\n\tint\t\t\t n;\n\n\tif (ictx->param_list_len == 0) {\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING) {\n\t\t\tinput_csi_dispatch_sgr_colon(ictx, i);\n\t\t\tcontinue;\n\t\t}\n\t\tn = input_get(ictx, i, 0, 0);\n\t\tif (n == -1)\n\t\t\tcontinue;\n\n\t\tif (n == 38 || n == 48 || n == 58) {\n\t\t\ti++;\n\t\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\t\tcase 2:\n\t\t\t\tinput_csi_dispatch_sgr_rgb(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tinput_csi_dispatch_sgr_256(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n) {\n\t\tcase 0:\n\t\t\tlink = gc->link;\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\t\tgc->link = link;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr |= GRID_ATTR_DIM;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr |= GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 5:\n\t\tcase 6:\n\t\t\tgc->attr |= GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tgc->attr |= GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tgc->attr |= GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tgc->attr |= GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tgc->attr &= ~(GRID_ATTR_BRIGHT|GRID_ATTR_DIM);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tgc->attr &= ~GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tgc->attr &= ~GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tgc->attr &= ~GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 28:\n\t\t\tgc->attr &= ~GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 29:\n\t\t\tgc->attr &= ~GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 30:\n\t\tcase 31:\n\t\tcase 32:\n\t\tcase 33:\n\t\tcase 34:\n\t\tcase 35:\n\t\tcase 36:\n\t\tcase 37:\n\t\t\tgc->fg = n - 30;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tgc->fg = 8;\n\t\t\tbreak;\n\t\tcase 40:\n\t\tcase 41:\n\t\tcase 42:\n\t\tcase 43:\n\t\tcase 44:\n\t\tcase 45:\n\t\tcase 46:\n\t\tcase 47:\n\t\t\tgc->bg = n - 40;\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tgc->bg = 8;\n\t\t\tbreak;\n\t\tcase 53:\n\t\t\tgc->attr |= GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 55:\n\t\t\tgc->attr &= ~GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tgc->us = 8;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tgc->fg = n;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 101:\n\t\tcase 102:\n\t\tcase 103:\n\t\tcase 104:\n\t\tcase 105:\n\t\tcase 106:\n\t\tcase 107:\n\t\t\tgc->bg = n - 10;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* End of input with BEL. */\nstatic int\ninput_end_bel(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tictx->input_end = INPUT_END_BEL;\n\n\treturn (0);\n}\n\n/* DCS string started. */\nstatic void\ninput_enter_dcs(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->flags &= ~INPUT_LAST;\n}\n\n/* DCS terminator (ST) received. */\nstatic int\ninput_dcs_dispatch(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_char\t\t\t*buf = ictx->input_buf;\n\tsize_t\t\t\t len = ictx->input_len;\n\tconst char\t\t prefix[] = \"tmux;\";\n\tconst u_int\t\t prefixlen = (sizeof prefix) - 1;\n\tlong long\t\t allow_passthrough = 0;\n#ifdef ENABLE_SIXEL\n\tstruct window\t\t*w;\n\tstruct sixel_image\t*si;\n\tint\t\t\t p2;\n#endif\n\n\tif (wp == NULL)\n\t\treturn (0);\n\n\tif (ictx->flags & INPUT_DISCARD) {\n\t\tlog_debug(\"%s: %zu bytes (discard)\", __func__, len);\n\t\treturn (0);\n\t}\n\n#ifdef ENABLE_SIXEL\n\tw = wp->window;\n\tif (buf[0] == 'q') {\n\t\tif (input_split(ictx) != 0)\n\t\t\treturn (0);\n\t\tp2 = input_get(ictx, 1, 0, 0);\n\t\tif (p2 == -1)\n\t\t\tp2 = 0;\n\t\tsi = sixel_parse(buf, len, p2, w->xpixel, w->ypixel);\n\t\tif (si != NULL)\n\t\t\tscreen_write_sixelimage(sctx, si, ictx->cell.cell.bg);\n\t}\n#endif\n\n\tallow_passthrough = options_get_number(wp->options, \"allow-passthrough\");\n\tif (!allow_passthrough)\n\t\treturn (0);\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, buf);\n\n\tif (len >= prefixlen && strncmp(buf, prefix, prefixlen) == 0) {\n\t\tscreen_write_rawstring(sctx, buf + prefixlen, len - prefixlen,\n\t\t    allow_passthrough == 2);\n\t}\n\n\treturn (0);\n}\n\n/* OSC string started. */\nstatic void\ninput_enter_osc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->flags &= ~INPUT_LAST;\n}\n\n/* OSC terminator (ST) received. */\nstatic void\ninput_exit_osc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_char\t\t\t*p = ictx->input_buf;\n\tu_int\t\t\t option;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (ictx->input_len < 1 || *p < '0' || *p > '9')\n\t\treturn;\n\n\tlog_debug(\"%s: \\\"%s\\\" (end %s)\", __func__, p,\n\t    ictx->input_end == INPUT_END_ST ? \"ST\" : \"BEL\");\n\n\toption = 0;\n\twhile (*p >= '0' && *p <= '9')\n\t\toption = option * 10 + *p++ - '0';\n\tif (*p != ';' && *p != '\\0')\n\t\treturn;\n\tif (*p == ';')\n\t\tp++;\n\n\tswitch (option) {\n\tcase 0:\n\tcase 2:\n\t\tif (wp != NULL &&\n\t\t    options_get_number(wp->options, \"allow-set-title\") &&\n\t\t    screen_set_title(sctx->s, p)) {\n\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\tserver_status_window(wp->window);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tinput_osc_4(ictx, p);\n\t\tbreak;\n\tcase 7:\n\t\tif (utf8_isvalid(p)) {\n\t\t\tscreen_set_path(sctx->s, p);\n\t\t\tif (wp != NULL) {\n\t\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\t\tserver_status_window(wp->window);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tinput_osc_8(ictx, p);\n\t\tbreak;\n\tcase 10:\n\t\tinput_osc_10(ictx, p);\n\t\tbreak;\n\tcase 11:\n\t\tinput_osc_11(ictx, p);\n\t\tbreak;\n\tcase 12:\n\t\tinput_osc_12(ictx, p);\n\t\tbreak;\n\tcase 52:\n\t\tinput_osc_52(ictx, p);\n\t\tbreak;\n\tcase 104:\n\t\tinput_osc_104(ictx, p);\n\t\tbreak;\n\tcase 110:\n\t\tinput_osc_110(ictx, p);\n\t\tbreak;\n\tcase 111:\n\t\tinput_osc_111(ictx, p);\n\t\tbreak;\n\tcase 112:\n\t\tinput_osc_112(ictx, p);\n\t\tbreak;\n\tcase 133:\n\t\tinput_osc_133(ictx, p);\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%u'\", __func__, option);\n\t\tbreak;\n\t}\n}\n\n/* APC string started. */\nstatic void\ninput_enter_apc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->flags &= ~INPUT_LAST;\n}\n\n/* APC terminator (ST) received. */\nstatic void\ninput_exit_apc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (screen_set_title(sctx->s, ictx->input_buf) && wp != NULL) {\n\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\tserver_redraw_window_borders(wp->window);\n\t\tserver_status_window(wp->window);\n\t}\n}\n\n/* Rename string started. */\nstatic void\ninput_enter_rename(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->flags &= ~INPUT_LAST;\n}\n\n/* Rename terminator (ST) received. */\nstatic void\ninput_exit_rename(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct window\t\t*w;\n\tstruct options_entry\t*o;\n\n\tif (wp == NULL)\n\t\treturn;\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (!options_get_number(ictx->wp->options, \"allow-rename\"))\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (!utf8_isvalid(ictx->input_buf))\n\t\treturn;\n\tw = wp->window;\n\n\tif (ictx->input_len == 0) {\n\t\to = options_get_only(w->options, \"automatic-rename\");\n\t\tif (o != NULL)\n\t\t\toptions_remove_or_default(o, -1, NULL);\n\t\tif (!options_get_number(w->options, \"automatic-rename\"))\n\t\t\twindow_set_name(w, \"\");\n\t} else {\n\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t\twindow_set_name(w, ictx->input_buf);\n\t}\n\tserver_redraw_window_borders(w);\n\tserver_status_window(w);\n}\n\n/* Open UTF-8 character. */\nstatic int\ninput_top_bit_set(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tictx->flags &= ~INPUT_LAST;\n\n\tif (!ictx->utf8started) {\n\t\tif (utf8_open(ud, ictx->ch) != UTF8_MORE)\n\t\t\treturn (0);\n\t\tictx->utf8started = 1;\n\t\treturn (0);\n\t}\n\n\tswitch (utf8_append(ud, ictx->ch)) {\n\tcase UTF8_MORE:\n\t\treturn (0);\n\tcase UTF8_ERROR:\n\t\tictx->utf8started = 0;\n\t\treturn (0);\n\tcase UTF8_DONE:\n\t\tbreak;\n\t}\n\tictx->utf8started = 0;\n\n\tlog_debug(\"%s %hhu '%*s' (width %hhu)\", __func__, ud->size,\n\t    (int)ud->size, ud->data, ud->width);\n\n\tutf8_copy(&ictx->cell.cell.data, ud);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\n\tutf8_copy(&ictx->last, &ictx->cell.cell.data);\n\tictx->flags |= INPUT_LAST;\n\n\treturn (0);\n}\n\n/* Reply to a colour request. */\nstatic void\ninput_osc_colour_reply(struct input_ctx *ictx, u_int n, int c)\n{\n    u_char\t r, g, b;\n    const char\t*end;\n\n    if (c != -1)\n\t    c = colour_force_rgb(c);\n    if (c == -1)\n\t    return;\n    colour_split_rgb(c, &r, &g, &b);\n\n    if (ictx->input_end == INPUT_END_BEL)\n\t    end = \"\\007\";\n    else\n\t    end = \"\\033\\\\\";\n    input_reply(ictx, \"\\033]%u;rgb:%02hhx%02hhx/%02hhx%02hhx/%02hhx%02hhx%s\",\n\tn, r, r, g, g, b, b, end);\n}\n\n/* Handle the OSC 4 sequence for setting (multiple) palette entries. */\nstatic void\ninput_osc_4(struct input_ctx *ictx, const char *p)\n{\n\tchar\t*copy, *s, *next = NULL;\n\tlong\t idx;\n\tint\t c, bad = 0, redraw = 0;\n\n\tcopy = s = xstrdup(p);\n\twhile (s != NULL && *s != '\\0') {\n\t\tidx = strtol(s, &next, 10);\n\t\tif (*next++ != ';') {\n\t\t\tbad = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (idx < 0 || idx >= 256) {\n\t\t\tbad = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\ts = strsep(&next, \";\");\n\t\tif (strcmp(s, \"?\") == 0) {\n\t\t\tc = colour_palette_get(ictx->palette, idx);\n\t\t\tif (c != -1)\n\t\t\t\tinput_osc_colour_reply(ictx, 4, c);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((c = colour_parseX11(s)) == -1) {\n\t\t\ts = next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (colour_palette_set(ictx->palette, idx, c))\n\t\t\tredraw = 1;\n\t\ts = next;\n\t}\n\tif (bad)\n\t\tlog_debug(\"bad OSC 4: %s\", p);\n\tif (redraw)\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\tfree(copy);\n}\n\n/* Handle the OSC 8 sequence for embedding hyperlinks. */\nstatic void\ninput_osc_8(struct input_ctx *ictx, const char *p)\n{\n\tstruct hyperlinks\t*hl = ictx->ctx.s->hyperlinks;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tconst char\t\t*start, *end, *uri;\n\tchar\t    \t\t*id = NULL;\n\n\tfor (start = p; (end = strpbrk(start, \":;\")) != NULL; start = end + 1) {\n\t\tif (end - start >= 4 && strncmp(start, \"id=\", 3) == 0) {\n\t\t\tif (id != NULL)\n\t\t\t\tgoto bad;\n\t\t\tid = xstrndup(start + 3, end - start - 3);\n\t\t}\n\n\t\t/* The first ; is the end of parameters and start of the URI. */\n\t\tif (*end == ';')\n\t\t\tbreak;\n\t}\n\tif (end == NULL || *end != ';')\n\t\tgoto bad;\n\turi = end + 1;\n\tif (*uri == '\\0') {\n\t\tgc->link = 0;\n\t\tfree(id);\n\t\treturn;\n\t}\n\tgc->link = hyperlinks_put(hl, uri, id);\n\tif (id == NULL)\n\t\tlog_debug(\"hyperlink (anonymous) %s = %u\", uri, gc->link);\n\telse\n\t\tlog_debug(\"hyperlink (id=%s) %s = %u\", id, uri, gc->link);\n\tfree(id);\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 8 %s\", p);\n\tfree(id);\n}\n\n/*\n * Get a client with a foreground for the pane. There isn't much to choose\n * between them so just use the first.\n */\nstatic int\ninput_get_fg_client(struct window_pane *wp)\n{\n\tstruct window\t*w = wp->window;\n\tstruct client\t*loop;\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (loop->flags & CLIENT_UNATTACHEDFLAGS)\n\t\t\tcontinue;\n\t\tif (loop->session == NULL || !session_has(loop->session, w))\n\t\t\tcontinue;\n\t\tif (loop->tty.fg == -1)\n\t\t\tcontinue;\n\t\treturn (loop->tty.fg);\n\t}\n\treturn (-1);\n}\n\n/* Get a client with a background for the pane. */\nstatic int\ninput_get_bg_client(struct window_pane *wp)\n{\n\tstruct window\t*w = wp->window;\n\tstruct client\t*loop;\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (loop->flags & CLIENT_UNATTACHEDFLAGS)\n\t\t\tcontinue;\n\t\tif (loop->session == NULL || !session_has(loop->session, w))\n\t\t\tcontinue;\n\t\tif (loop->tty.bg == -1)\n\t\t\tcontinue;\n\t\treturn (loop->tty.bg);\n\t}\n\treturn (-1);\n}\n\n/*\n * If any control mode client exists that has provided a bg color, return it.\n * Otherwise, return -1.\n */\nstatic int\ninput_get_bg_control_client(struct window_pane *wp)\n{\n\tstruct client\t*c;\n\n\tif (wp->control_bg == -1)\n\t\treturn (-1);\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\treturn (wp->control_bg);\n\t}\n\treturn (-1);\n}\n\n/*\n * If any control mode client exists that has provided a fg color, return it.\n * Otherwise, return -1.\n */\nstatic int\ninput_get_fg_control_client(struct window_pane *wp)\n{\n\tstruct client\t*c;\n\n\tif (wp->control_fg == -1)\n\t\treturn (-1);\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\treturn (wp->control_fg);\n\t}\n\treturn (-1);\n}\n\n/* Handle the OSC 10 sequence for setting and querying foreground colour. */\nstatic void\ninput_osc_10(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tint\t\t\t c;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\tif (wp == NULL)\n\t\t\treturn;\n\t\tc = input_get_fg_control_client(wp);\n\t\tif (c == -1) {\n\t\t\ttty_default_colours(&defaults, wp);\n\t\t\tif (COLOUR_DEFAULT(defaults.fg))\n\t\t\t\tc = input_get_fg_client(wp);\n\t\t\telse\n\t\t\t\tc = defaults.fg;\n\t\t}\n\t\tinput_osc_colour_reply(ictx, 10, c);\n\t\treturn;\n\t}\n\n\tif ((c = colour_parseX11(p)) == -1) {\n\t\tlog_debug(\"bad OSC 10: %s\", p);\n\t\treturn;\n\t}\n\tif (ictx->palette != NULL) {\n\t\tictx->palette->fg = c;\n\t\tif (wp != NULL)\n\t\t\twp->flags |= PANE_STYLECHANGED;\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\t}\n}\n\n/* Handle the OSC 110 sequence for resetting foreground colour. */\nstatic void\ninput_osc_110(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tif (*p != '\\0')\n\t\treturn;\n\tif (ictx->palette != NULL) {\n\t\tictx->palette->fg = 8;\n\t\tif (wp != NULL)\n\t\t\twp->flags |= PANE_STYLECHANGED;\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\t}\n}\n\n/* Handle the OSC 11 sequence for setting and querying background colour. */\nstatic void\ninput_osc_11(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tint\t\t\t c;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\tif (wp == NULL)\n\t\t\treturn;\n\t\tc = input_get_bg_control_client(wp);\n\t\tif (c == -1) {\n\t\t\ttty_default_colours(&defaults, wp);\n\t\t\tif (COLOUR_DEFAULT(defaults.bg))\n\t\t\t\tc = input_get_bg_client(wp);\n\t\t\telse\n\t\t\t\tc = defaults.bg;\n\t\t}\n\t\tinput_osc_colour_reply(ictx, 11, c);\n\t\treturn;\n\t}\n\n\tif ((c = colour_parseX11(p)) == -1) {\n\t\tlog_debug(\"bad OSC 11: %s\", p);\n\t\treturn;\n\t}\n\tif (ictx->palette != NULL) {\n\t\tictx->palette->bg = c;\n\t\tif (wp != NULL)\n\t\t\twp->flags |= PANE_STYLECHANGED;\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\t}\n}\n\n/* Handle the OSC 111 sequence for resetting background colour. */\nstatic void\ninput_osc_111(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tif (*p != '\\0')\n\t\treturn;\n\tif (ictx->palette != NULL) {\n\t\tictx->palette->bg = 8;\n\t\tif (wp != NULL)\n\t\t\twp->flags |= PANE_STYLECHANGED;\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\t}\n}\n\n/* Handle the OSC 12 sequence for setting and querying cursor colour. */\nstatic void\ninput_osc_12(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tint\t\t\t c;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\tif (wp != NULL) {\n\t\t\tc = ictx->ctx.s->ccolour;\n\t\t\tif (c == -1)\n\t\t\t\tc = ictx->ctx.s->default_ccolour;\n\t\t\tinput_osc_colour_reply(ictx, 12, c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((c = colour_parseX11(p)) == -1) {\n\t\tlog_debug(\"bad OSC 12: %s\", p);\n\t\treturn;\n\t}\n\tscreen_set_cursor_colour(ictx->ctx.s, c);\n}\n\n/* Handle the OSC 112 sequence for resetting cursor colour. */\nstatic void\ninput_osc_112(struct input_ctx *ictx, const char *p)\n{\n\tif (*p == '\\0') /* no arguments allowed */\n\t\tscreen_set_cursor_colour(ictx->ctx.s, -1);\n}\n\n/* Handle the OSC 133 sequence. */\nstatic void\ninput_osc_133(struct input_ctx *ictx, const char *p)\n{\n\tstruct grid\t\t*gd = ictx->ctx.s->grid;\n\tu_int\t\t\t line = ictx->ctx.s->cy + gd->hsize;\n\tstruct grid_line\t*gl;\n\n\tif (line > gd->hsize + gd->sy - 1)\n\t\treturn;\n\tgl = grid_get_line(gd, line);\n\n\tswitch (*p) {\n\tcase 'A':\n\t\tgl->flags |= GRID_LINE_START_PROMPT;\n\t\tbreak;\n\tcase 'C':\n\t\tgl->flags |= GRID_LINE_START_OUTPUT;\n\t\tbreak;\n\t}\n}\n\n/* Handle the OSC 52 sequence for setting the clipboard. */\nstatic void\ninput_osc_52(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*end;\n\tconst char\t\t*buf = NULL;\n\tsize_t\t\t\t len = 0;\n\tu_char\t\t\t*out;\n\tint\t\t\t outlen, state;\n\tstruct screen_write_ctx\t ctx;\n\tstruct paste_buffer\t*pb;\n\tconst char*              allow = \"cpqs01234567\";\n\tchar                     flags[sizeof \"cpqs01234567\"] = \"\";\n\tu_int\t\t\t i, j = 0;\n\n\tif (wp == NULL)\n\t\treturn;\n\tstate = options_get_number(global_options, \"set-clipboard\");\n\tif (state != 2)\n\t\treturn;\n\n\tif ((end = strchr(p, ';')) == NULL)\n\t\treturn;\n\tend++;\n\tif (*end == '\\0')\n\t\treturn;\n\tlog_debug(\"%s: %s\", __func__, end);\n\n\tfor (i = 0; p + i != end; i++) {\n\t\tif (strchr(allow, p[i]) != NULL && strchr(flags, p[i]) == NULL)\n\t\t\tflags[j++] = p[i];\n\t}\n\tlog_debug(\"%s: %.*s %s\", __func__, (int)(end - p - 1), p, flags);\n\n\tif (strcmp(end, \"?\") == 0) {\n\t\tif ((pb = paste_get_top(NULL)) != NULL)\n\t\t\tbuf = paste_buffer_data(pb, &len);\n\t\tif (ictx->input_end == INPUT_END_BEL)\n\t\t\tinput_reply_clipboard(ictx->event, buf, len, \"\\007\");\n\t\telse\n\t\t\tinput_reply_clipboard(ictx->event, buf, len, \"\\033\\\\\");\n\t\treturn;\n\t}\n\n\tlen = (strlen(end) / 4) * 3;\n\tif (len == 0)\n\t\treturn;\n\n\tout = xmalloc(len);\n\tif ((outlen = b64_pton(end, out, len)) == -1) {\n\t\tfree(out);\n\t\treturn;\n\t}\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tscreen_write_setselection(&ctx, flags, out, outlen);\n\tscreen_write_stop(&ctx);\n\tnotify_pane(\"pane-set-clipboard\", wp);\n\n\tpaste_add(NULL, out, outlen);\n}\n\n/* Handle the OSC 104 sequence for unsetting (multiple) palette entries. */\nstatic void\ninput_osc_104(struct input_ctx *ictx, const char *p)\n{\n\tchar\t*copy, *s;\n\tlong\t idx;\n\tint\t bad = 0, redraw = 0;\n\n\tif (*p == '\\0') {\n\t\tcolour_palette_clear(ictx->palette);\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\t\treturn;\n\t}\n\n\tcopy = s = xstrdup(p);\n\twhile (*s != '\\0') {\n\t\tidx = strtol(s, &s, 10);\n\t\tif (*s != '\\0' && *s != ';') {\n\t\t\tbad = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (idx < 0 || idx >= 256) {\n\t\t\tbad = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (colour_palette_set(ictx->palette, idx, -1))\n\t\t\tredraw = 1;\n\t\tif (*s == ';')\n\t\t\ts++;\n\t}\n\tif (bad)\n\t\tlog_debug(\"bad OSC 104: %s\", p);\n\tif (redraw)\n\t\tscreen_write_fullredraw(&ictx->ctx);\n\tfree(copy);\n}\n\nvoid\ninput_reply_clipboard(struct bufferevent *bev, const char *buf, size_t len,\n    const char *end)\n{\n\tchar\t*out = NULL;\n\tint\t outlen = 0;\n\n\tif (buf != NULL && len != 0) {\n\t\tif (len >= ((size_t)INT_MAX * 3 / 4) - 1)\n\t\t\treturn;\n\t\toutlen = 4 * ((len + 2) / 3) + 1;\n\t\tout = xmalloc(outlen);\n\t\tif ((outlen = b64_ntop(buf, len, out, outlen)) == -1) {\n\t\t\tfree(out);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbufferevent_write(bev, \"\\033]52;;\", 6);\n\tif (outlen != 0)\n\t\tbufferevent_write(bev, out, outlen);\n\tbufferevent_write(bev, end, strlen(end));\n\tfree(out);\n}\n\n/* Set input buffer size. */\nvoid\ninput_set_buffer_size(size_t buffer_size)\n{\n\tlog_debug(\"%s: %lu -> %lu\", __func__, input_buffer_size, buffer_size);\n\tinput_buffer_size = buffer_size;\n}\n"
        },
        {
          "name": "job.c",
          "type": "blob",
          "size": 9.306640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Job scheduling. Run queued commands in the background and record their\n * output.\n */\n\nstatic void\tjob_read_callback(struct bufferevent *, void *);\nstatic void\tjob_write_callback(struct bufferevent *, void *);\nstatic void\tjob_error_callback(struct bufferevent *, short, void *);\n\n/* A single job. */\nstruct job {\n\tenum {\n\t\tJOB_RUNNING,\n\t\tJOB_DEAD,\n\t\tJOB_CLOSED\n\t} state;\n\n\tint\t\t\t flags;\n\n\tchar\t\t\t*cmd;\n\tpid_t\t\t\t pid;\n\tchar\t\t         tty[TTY_NAME_MAX];\n\tint\t\t\t status;\n\n\tint\t\t\t fd;\n\tstruct bufferevent\t*event;\n\n\tjob_update_cb\t\t updatecb;\n\tjob_complete_cb\t\t completecb;\n\tjob_free_cb\t\t freecb;\n\tvoid\t\t\t*data;\n\n\tLIST_ENTRY(job)\t\t entry;\n};\n\n/* All jobs list. */\nstatic LIST_HEAD(joblist, job) all_jobs = LIST_HEAD_INITIALIZER(all_jobs);\n\n/* Start a job running. */\nstruct job *\njob_run(const char *cmd, int argc, char **argv, struct environ *e,\n    struct session *s, const char *cwd, job_update_cb updatecb,\n    job_complete_cb completecb, job_free_cb freecb, void *data, int flags,\n    int sx, int sy)\n{\n\tstruct job\t *job;\n\tstruct environ\t *env;\n\tpid_t\t\t  pid;\n\tint\t\t  nullfd, out[2], master;\n\tconst char\t *home, *shell;\n\tsigset_t\t  set, oldset;\n\tstruct winsize\t  ws;\n\tchar\t\t**argvp, tty[TTY_NAME_MAX], *argv0;\n\tstruct options\t *oo;\n\n\t/*\n\t * Do not set TERM during .tmux.conf (second argument here), it is nice\n\t * to be able to use if-shell to decide on default-terminal based on\n\t * outside TERM.\n\t */\n\tenv = environ_for_session(s, !cfg_finished);\n\tif (e != NULL)\n\t\tenviron_copy(e, env);\n\n\tif (~flags & JOB_DEFAULTSHELL)\n\t\tshell = _PATH_BSHELL;\n\telse {\n\t\tif (s != NULL)\n\t\t\too = s->options;\n\t\telse\n\t\t\too = global_s_options;\n\t\tshell = options_get_string(oo, \"default-shell\");\n\t\tif (!checkshell(shell))\n\t\t\tshell = _PATH_BSHELL;\n\t}\n\targv0 = shell_argv0(shell, 0);\n\n\tsigfillset(&set);\n\tsigprocmask(SIG_BLOCK, &set, &oldset);\n\n\tif (flags & JOB_PTY) {\n\t\tmemset(&ws, 0, sizeof ws);\n\t\tws.ws_col = sx;\n\t\tws.ws_row = sy;\n\t\tpid = fdforkpty(ptm_fd, &master, tty, NULL, &ws);\n\t} else {\n\t\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, out) != 0)\n\t\t\tgoto fail;\n\t\tpid = fork();\n\t}\n\tif (cmd == NULL) {\n\t\tcmd_log_argv(argc, argv, \"%s:\", __func__);\n\t\tlog_debug(\"%s: cwd=%s, shell=%s\", __func__,\n\t\t    cwd == NULL ? \"\" : cwd, shell);\n\t} else {\n\t\tlog_debug(\"%s: cmd=%s, cwd=%s, shell=%s\", __func__, cmd,\n\t\t    cwd == NULL ? \"\" : cwd, shell);\n\t}\n\n\tswitch (pid) {\n\tcase -1:\n\t\tif (~flags & JOB_PTY) {\n\t\t\tclose(out[0]);\n\t\t\tclose(out[1]);\n\t\t}\n\t\tgoto fail;\n\tcase 0:\n\t\tproc_clear_signals(server_proc, 1);\n\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\n\t\tif ((cwd == NULL || chdir(cwd) != 0) &&\n\t\t    ((home = find_home()) == NULL || chdir(home) != 0) &&\n\t\t    chdir(\"/\") != 0)\n\t\t\tfatal(\"chdir failed\");\n\n\t\tenviron_push(env);\n\t\tenviron_free(env);\n\n\t\tif (~flags & JOB_PTY) {\n\t\t\tif (dup2(out[1], STDIN_FILENO) == -1)\n\t\t\t\tfatal(\"dup2 failed\");\n\t\t\tif (dup2(out[1], STDOUT_FILENO) == -1)\n\t\t\t\tfatal(\"dup2 failed\");\n\t\t\tif (out[1] != STDIN_FILENO && out[1] != STDOUT_FILENO)\n\t\t\t\tclose(out[1]);\n\t\t\tclose(out[0]);\n\n\t\t\tnullfd = open(_PATH_DEVNULL, O_RDWR);\n\t\t\tif (nullfd == -1)\n\t\t\t\tfatal(\"open failed\");\n\t\t\tif (dup2(nullfd, STDERR_FILENO) == -1)\n\t\t\t\tfatal(\"dup2 failed\");\n\t\t\tif (nullfd != STDERR_FILENO)\n\t\t\t\tclose(nullfd);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\tif (cmd != NULL) {\n\t\t\tsetenv(\"SHELL\", shell, 1);\n\t\t\texecl(shell, argv0, \"-c\", cmd, (char *)NULL);\n\t\t\tfatal(\"execl failed\");\n\t\t} else {\n\t\t\targvp = cmd_copy_argv(argc, argv);\n\t\t\texecvp(argvp[0], argvp);\n\t\t\tfatal(\"execvp failed\");\n\t\t}\n\t}\n\n\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\tenviron_free(env);\n\tfree(argv0);\n\n\tjob = xmalloc(sizeof *job);\n\tjob->state = JOB_RUNNING;\n\tjob->flags = flags;\n\n\tif (cmd != NULL)\n\t\tjob->cmd = xstrdup(cmd);\n\telse\n\t\tjob->cmd = cmd_stringify_argv(argc, argv);\n\tjob->pid = pid;\n\tstrlcpy(job->tty, tty, sizeof job->tty);\n\tjob->status = 0;\n\n\tLIST_INSERT_HEAD(&all_jobs, job, entry);\n\n\tjob->updatecb = updatecb;\n\tjob->completecb = completecb;\n\tjob->freecb = freecb;\n\tjob->data = data;\n\n\tif (~flags & JOB_PTY) {\n\t\tclose(out[1]);\n\t\tjob->fd = out[0];\n\t} else\n\t\tjob->fd = master;\n\tsetblocking(job->fd, 0);\n\n\tjob->event = bufferevent_new(job->fd, job_read_callback,\n\t    job_write_callback, job_error_callback, job);\n\tif (job->event == NULL)\n\t\tfatalx(\"out of memory\");\n\tbufferevent_enable(job->event, EV_READ|EV_WRITE);\n\n\tlog_debug(\"run job %p: %s, pid %ld\", job, job->cmd, (long)job->pid);\n\treturn (job);\n\nfail:\n\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\tenviron_free(env);\n\tfree(argv0);\n\treturn (NULL);\n}\n\n/* Take job's file descriptor and free the job. */\nint\njob_transfer(struct job *job, pid_t *pid, char *tty, size_t ttylen)\n{\n\tint\tfd = job->fd;\n\n\tlog_debug(\"transfer job %p: %s\", job, job->cmd);\n\n\tif (pid != NULL)\n\t\t*pid = job->pid;\n\tif (tty != NULL)\n\t\tstrlcpy(tty, job->tty, ttylen);\n\n\tLIST_REMOVE(job, entry);\n\tfree(job->cmd);\n\n\tif (job->freecb != NULL && job->data != NULL)\n\t\tjob->freecb(job->data);\n\n\tif (job->event != NULL)\n\t\tbufferevent_free(job->event);\n\n\tfree(job);\n\treturn (fd);\n}\n\n/* Kill and free an individual job. */\nvoid\njob_free(struct job *job)\n{\n\tlog_debug(\"free job %p: %s\", job, job->cmd);\n\n\tLIST_REMOVE(job, entry);\n\tfree(job->cmd);\n\n\tif (job->freecb != NULL && job->data != NULL)\n\t\tjob->freecb(job->data);\n\n\tif (job->pid != -1)\n\t\tkill(job->pid, SIGTERM);\n\tif (job->event != NULL)\n\t\tbufferevent_free(job->event);\n\tif (job->fd != -1)\n\t\tclose(job->fd);\n\n\tfree(job);\n}\n\n/* Resize job. */\nvoid\njob_resize(struct job *job, u_int sx, u_int sy)\n{\n\tstruct winsize\t ws;\n\n\tif (job->fd == -1 || (~job->flags & JOB_PTY))\n\t\treturn;\n\n\tlog_debug(\"resize job %p: %ux%u\", job, sx, sy);\n\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = sx;\n\tws.ws_row = sy;\n\tif (ioctl(job->fd, TIOCSWINSZ, &ws) == -1)\n\t\tfatal(\"ioctl failed\");\n}\n\n/* Job buffer read callback. */\nstatic void\njob_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct job\t*job = data;\n\n\tif (job->updatecb != NULL)\n\t\tjob->updatecb(job);\n}\n\n/*\n * Job buffer write callback. Fired when the buffer falls below watermark\n * (default is empty). If all the data has been written, disable the write\n * event.\n */\nstatic void\njob_write_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct job\t*job = data;\n\tsize_t\t\t len = EVBUFFER_LENGTH(EVBUFFER_OUTPUT(job->event));\n\n\tlog_debug(\"job write %p: %s, pid %ld, output left %zu\", job, job->cmd,\n\t    (long) job->pid, len);\n\n\tif (len == 0 && (~job->flags & JOB_KEEPWRITE)) {\n\t\tshutdown(job->fd, SHUT_WR);\n\t\tbufferevent_disable(job->event, EV_WRITE);\n\t}\n}\n\n/* Job buffer error callback. */\nstatic void\njob_error_callback(__unused struct bufferevent *bufev, __unused short events,\n    void *data)\n{\n\tstruct job\t*job = data;\n\n\tlog_debug(\"job error %p: %s, pid %ld\", job, job->cmd, (long) job->pid);\n\n\tif (job->state == JOB_DEAD) {\n\t\tif (job->completecb != NULL)\n\t\t\tjob->completecb(job);\n\t\tjob_free(job);\n\t} else {\n\t\tbufferevent_disable(job->event, EV_READ);\n\t\tjob->state = JOB_CLOSED;\n\t}\n}\n\n/* Job died (waitpid() returned its pid). */\nvoid\njob_check_died(pid_t pid, int status)\n{\n\tstruct job\t*job;\n\n\tLIST_FOREACH(job, &all_jobs, entry) {\n\t\tif (pid == job->pid)\n\t\t\tbreak;\n\t}\n\tif (job == NULL)\n\t\treturn;\n\tif (WIFSTOPPED(status)) {\n\t\tif (WSTOPSIG(status) == SIGTTIN || WSTOPSIG(status) == SIGTTOU)\n\t\t\treturn;\n\t\tkillpg(job->pid, SIGCONT);\n\t\treturn;\n\t}\n\tlog_debug(\"job died %p: %s, pid %ld\", job, job->cmd, (long) job->pid);\n\n\tjob->status = status;\n\n\tif (job->state == JOB_CLOSED) {\n\t\tif (job->completecb != NULL)\n\t\t\tjob->completecb(job);\n\t\tjob_free(job);\n\t} else {\n\t\tjob->pid = -1;\n\t\tjob->state = JOB_DEAD;\n\t}\n}\n\n/* Get job status. */\nint\njob_get_status(struct job *job)\n{\n\treturn (job->status);\n}\n\n/* Get job data. */\nvoid *\njob_get_data(struct job *job)\n{\n\treturn (job->data);\n}\n\n/* Get job event. */\nstruct bufferevent *\njob_get_event(struct job *job)\n{\n\treturn (job->event);\n}\n\n/* Kill all jobs. */\nvoid\njob_kill_all(void)\n{\n\tstruct job\t*job;\n\n\tLIST_FOREACH(job, &all_jobs, entry) {\n\t\tif (job->pid != -1)\n\t\t\tkill(job->pid, SIGTERM);\n\t}\n}\n\n/* Are any jobs still running? */\nint\njob_still_running(void)\n{\n\tstruct job\t*job;\n\n\tLIST_FOREACH(job, &all_jobs, entry) {\n\t\tif ((~job->flags & JOB_NOWAIT) && job->state == JOB_RUNNING)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Print job summary. */\nvoid\njob_print_summary(struct cmdq_item *item, int blank)\n{\n\tstruct job\t*job;\n\tu_int\t\t n = 0;\n\n\tLIST_FOREACH(job, &all_jobs, entry) {\n\t\tif (blank) {\n\t\t\tcmdq_print(item, \"%s\", \"\");\n\t\t\tblank = 0;\n\t\t}\n\t\tcmdq_print(item, \"Job %u: %s [fd=%d, pid=%ld, status=%d]\",\n\t\t    n, job->cmd, job->fd, (long)job->pid, job->status);\n\t\tn++;\n\t}\n}\n"
        },
        {
          "name": "key-bindings.c",
          "type": "blob",
          "size": 29.3359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n#define DEFAULT_SESSION_MENU \\\n\t\" 'Next' 'n' {switch-client -n}\" \\\n\t\" 'Previous' 'p' {switch-client -p}\" \\\n\t\" ''\" \\\n\t\" 'Renumber' 'N' {move-window -r}\" \\\n\t\" 'Rename' 'n' {command-prompt -I \\\"#S\\\" {rename-session -- '%%'}}\" \\\n\t\" ''\" \\\n\t\" 'New Session' 's' {new-session}\" \\\n\t\" 'New Window' 'w' {new-window}\"\n#define DEFAULT_WINDOW_MENU \\\n\t\" '#{?#{>:#{session_windows},1},,-}Swap Left' 'l' {swap-window -t:-1}\" \\\n\t\" '#{?#{>:#{session_windows},1},,-}Swap Right' 'r' {swap-window -t:+1}\" \\\n\t\" '#{?pane_marked_set,,-}Swap Marked' 's' {swap-window}\" \\\n\t\" ''\" \\\n\t\" 'Kill' 'X' {kill-window}\" \\\n\t\" 'Respawn' 'R' {respawn-window -k}\" \\\n\t\" '#{?pane_marked,Unmark,Mark}' 'm' {select-pane -m}\" \\\n\t\" 'Rename' 'n' {command-prompt -FI \\\"#W\\\" {rename-window -t '#{window_id}' -- '%%'}}\" \\\n\t\" ''\" \\\n\t\" 'New After' 'w' {new-window -a}\" \\\n\t\" 'New At End' 'W' {new-window}\"\n#define DEFAULT_PANE_MENU \\\n\t\" '#{?#{m/r:(copy|view)-mode,#{pane_mode}},Go To Top,}' '<' {send -X history-top}\" \\\n\t\" '#{?#{m/r:(copy|view)-mode,#{pane_mode}},Go To Bottom,}' '>' {send -X history-bottom}\" \\\n\t\" ''\" \\\n\t\" '#{?mouse_word,Search For #[underscore]#{=/9/...:mouse_word},}' 'C-r' {if -F '#{?#{m/r:(copy|view)-mode,#{pane_mode}},0,1}' 'copy-mode -t='; send -Xt= search-backward -- \\\"#{q:mouse_word}\\\"}\" \\\n\t\" '#{?mouse_word,Type #[underscore]#{=/9/...:mouse_word},}' 'C-y' {copy-mode -q; send-keys -l -- \\\"#{q:mouse_word}\\\"}\" \\\n\t\" '#{?mouse_word,Copy #[underscore]#{=/9/...:mouse_word},}' 'c' {copy-mode -q; set-buffer -- \\\"#{q:mouse_word}\\\"}\" \\\n\t\" '#{?mouse_line,Copy Line,}' 'l' {copy-mode -q; set-buffer -- \\\"#{q:mouse_line}\\\"}\" \\\n\t\" ''\" \\\n\t\" '#{?mouse_hyperlink,Type #[underscore]#{=/9/...:mouse_hyperlink},}' 'C-h' {copy-mode -q; send-keys -l -- \\\"#{q:mouse_hyperlink}\\\"}\" \\\n\t\" '#{?mouse_hyperlink,Copy #[underscore]#{=/9/...:mouse_hyperlink},}' 'h' {copy-mode -q; set-buffer -- \\\"#{q:mouse_hyperlink}\\\"}\" \\\n\t\" ''\" \\\n\t\" 'Horizontal Split' 'h' {split-window -h}\" \\\n\t\" 'Vertical Split' 'v' {split-window -v}\" \\\n\t\" ''\" \\\n\t\" '#{?#{>:#{window_panes},1},,-}Swap Up' 'u' {swap-pane -U}\" \\\n\t\" '#{?#{>:#{window_panes},1},,-}Swap Down' 'd' {swap-pane -D}\" \\\n\t\" '#{?pane_marked_set,,-}Swap Marked' 's' {swap-pane}\" \\\n\t\" ''\" \\\n\t\" 'Kill' 'X' {kill-pane}\" \\\n\t\" 'Respawn' 'R' {respawn-pane -k}\" \\\n\t\" '#{?pane_marked,Unmark,Mark}' 'm' {select-pane -m}\" \\\n\t\" '#{?#{>:#{window_panes},1},,-}#{?window_zoomed_flag,Unzoom,Zoom}' 'z' {resize-pane -Z}\"\n\nstatic int key_bindings_cmp(struct key_binding *, struct key_binding *);\nRB_GENERATE_STATIC(key_bindings, key_binding, entry, key_bindings_cmp);\nstatic int key_table_cmp(struct key_table *, struct key_table *);\nRB_GENERATE_STATIC(key_tables, key_table, entry, key_table_cmp);\nstatic struct key_tables key_tables = RB_INITIALIZER(&key_tables);\n\nstatic int\nkey_table_cmp(struct key_table *table1, struct key_table *table2)\n{\n\treturn (strcmp(table1->name, table2->name));\n}\n\nstatic int\nkey_bindings_cmp(struct key_binding *bd1, struct key_binding *bd2)\n{\n\tif (bd1->key < bd2->key)\n\t\treturn (-1);\n\tif (bd1->key > bd2->key)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic void\nkey_bindings_free(struct key_binding *bd)\n{\n\tcmd_list_free(bd->cmdlist);\n\tfree((void *)bd->note);\n\tfree(bd);\n}\n\nstruct key_table *\nkey_bindings_get_table(const char *name, int create)\n{\n\tstruct key_table\ttable_find, *table;\n\n\ttable_find.name = name;\n\ttable = RB_FIND(key_tables, &key_tables, &table_find);\n\tif (table != NULL || !create)\n\t\treturn (table);\n\n\ttable = xmalloc(sizeof *table);\n\ttable->name = xstrdup(name);\n\tRB_INIT(&table->key_bindings);\n\tRB_INIT(&table->default_key_bindings);\n\n\ttable->references = 1; /* one reference in key_tables */\n\tRB_INSERT(key_tables, &key_tables, table);\n\n\treturn (table);\n}\n\nstruct key_table *\nkey_bindings_first_table(void)\n{\n\treturn (RB_MIN(key_tables, &key_tables));\n}\n\nstruct key_table *\nkey_bindings_next_table(struct key_table *table)\n{\n\treturn (RB_NEXT(key_tables, &key_tables, table));\n}\n\nvoid\nkey_bindings_unref_table(struct key_table *table)\n{\n\tstruct key_binding\t*bd;\n\tstruct key_binding\t*bd1;\n\n\tif (--table->references != 0)\n\t\treturn;\n\n\tRB_FOREACH_SAFE(bd, key_bindings, &table->key_bindings, bd1) {\n\t\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\t\tkey_bindings_free(bd);\n\t}\n\tRB_FOREACH_SAFE(bd, key_bindings, &table->default_key_bindings, bd1) {\n\t\tRB_REMOVE(key_bindings, &table->default_key_bindings, bd);\n\t\tkey_bindings_free(bd);\n\t}\n\n\tfree((void *)table->name);\n\tfree(table);\n}\n\nstruct key_binding *\nkey_bindings_get(struct key_table *table, key_code key)\n{\n\tstruct key_binding\tbd;\n\n\tbd.key = key;\n\treturn (RB_FIND(key_bindings, &table->key_bindings, &bd));\n}\n\nstruct key_binding *\nkey_bindings_get_default(struct key_table *table, key_code key)\n{\n\tstruct key_binding\tbd;\n\n\tbd.key = key;\n\treturn (RB_FIND(key_bindings, &table->default_key_bindings, &bd));\n}\n\nstruct key_binding *\nkey_bindings_first(struct key_table *table)\n{\n\treturn (RB_MIN(key_bindings, &table->key_bindings));\n}\n\nstruct key_binding *\nkey_bindings_next(__unused struct key_table *table, struct key_binding *bd)\n{\n\treturn (RB_NEXT(key_bindings, &table->key_bindings, bd));\n}\n\nvoid\nkey_bindings_add(const char *name, key_code key, const char *note, int repeat,\n    struct cmd_list *cmdlist)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\tchar\t\t\t*s;\n\n\ttable = key_bindings_get_table(name, 1);\n\n\tbd = key_bindings_get(table, key & ~KEYC_MASK_FLAGS);\n\tif (cmdlist == NULL) {\n\t\tif (bd != NULL) {\n\t\t\tfree((void *)bd->note);\n\t\t\tif (note != NULL)\n\t\t\t\tbd->note = xstrdup(note);\n\t\t\telse\n\t\t\t\tbd->note = NULL;\n\t\t}\n\t\treturn;\n\t}\n\tif (bd != NULL) {\n\t\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\t\tkey_bindings_free(bd);\n\t}\n\n\tbd = xcalloc(1, sizeof *bd);\n\tbd->key = (key & ~KEYC_MASK_FLAGS);\n\tif (note != NULL)\n\t\tbd->note = xstrdup(note);\n\tRB_INSERT(key_bindings, &table->key_bindings, bd);\n\n\tif (repeat)\n\t\tbd->flags |= KEY_BINDING_REPEAT;\n\tbd->cmdlist = cmdlist;\n\n\ts = cmd_list_print(bd->cmdlist, 0);\n\tlog_debug(\"%s: %#llx %s = %s\", __func__, bd->key,\n\t    key_string_lookup_key(bd->key, 1), s);\n\tfree(s);\n}\n\nvoid\nkey_bindings_remove(const char *name, key_code key)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table == NULL)\n\t\treturn;\n\n\tbd = key_bindings_get(table, key & ~KEYC_MASK_FLAGS);\n\tif (bd == NULL)\n\t\treturn;\n\n\tlog_debug(\"%s: %#llx %s\", __func__, bd->key,\n\t    key_string_lookup_key(bd->key, 1));\n\n\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\tkey_bindings_free(bd);\n\n\tif (RB_EMPTY(&table->key_bindings) &&\n\t    RB_EMPTY(&table->default_key_bindings)) {\n\t\tRB_REMOVE(key_tables, &key_tables, table);\n\t\tkey_bindings_unref_table(table);\n\t}\n}\n\nvoid\nkey_bindings_reset(const char *name, key_code key)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd, *dd;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table == NULL)\n\t\treturn;\n\n\tbd = key_bindings_get(table, key & ~KEYC_MASK_FLAGS);\n\tif (bd == NULL)\n\t\treturn;\n\n\tdd = key_bindings_get_default(table, bd->key);\n\tif (dd == NULL) {\n\t\tkey_bindings_remove(name, bd->key);\n\t\treturn;\n\t}\n\n\tcmd_list_free(bd->cmdlist);\n\tbd->cmdlist = dd->cmdlist;\n\tbd->cmdlist->references++;\n\n\tfree((void *)bd->note);\n\tif (dd->note != NULL)\n\t\tbd->note = xstrdup(dd->note);\n\telse\n\t\tbd->note = NULL;\n\tbd->flags = dd->flags;\n}\n\nvoid\nkey_bindings_remove_table(const char *name)\n{\n\tstruct key_table\t*table;\n\tstruct client\t\t*c;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table != NULL) {\n\t\tRB_REMOVE(key_tables, &key_tables, table);\n\t\tkey_bindings_unref_table(table);\n\t}\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->keytable == table)\n\t\t\tserver_client_set_key_table(c, NULL);\n\t}\n}\n\nvoid\nkey_bindings_reset_table(const char *name)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd, *bd1;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table == NULL)\n\t\treturn;\n\tif (RB_EMPTY(&table->default_key_bindings)) {\n\t\tkey_bindings_remove_table(name);\n\t\treturn;\n\t}\n\tRB_FOREACH_SAFE(bd, key_bindings, &table->key_bindings, bd1)\n\t\tkey_bindings_reset(name, bd->key);\n}\n\nstatic enum cmd_retval\nkey_bindings_init_done(__unused struct cmdq_item *item, __unused void *data)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd, *new_bd;\n\n\tRB_FOREACH(table, key_tables, &key_tables) {\n\t\tRB_FOREACH(bd, key_bindings, &table->key_bindings) {\n\t\t\tnew_bd = xcalloc(1, sizeof *bd);\n\t\t\tnew_bd->key = bd->key;\n\t\t\tif (bd->note != NULL)\n\t\t\t\tnew_bd->note = xstrdup(bd->note);\n\t\t\tnew_bd->flags = bd->flags;\n\t\t\tnew_bd->cmdlist = bd->cmdlist;\n\t\t\tnew_bd->cmdlist->references++;\n\t\t\tRB_INSERT(key_bindings, &table->default_key_bindings,\n\t\t\t    new_bd);\n\t\t}\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\nkey_bindings_init(void)\n{\n\tstatic const char *const defaults[] = {\n\t\t/* Prefix keys. */\n\t\t\"bind -N 'Send the prefix key' C-b { send-prefix }\",\n\t\t\"bind -N 'Rotate through the panes' C-o { rotate-window }\",\n\t\t\"bind -N 'Suspend the current client' C-z { suspend-client }\",\n\t\t\"bind -N 'Select next layout' Space { next-layout }\",\n\t\t\"bind -N 'Break pane to a new window' ! { break-pane }\",\n\t\t\"bind -N 'Split window vertically' '\\\"' { split-window }\",\n\t\t\"bind -N 'List all paste buffers' '#' { list-buffers }\",\n\t\t\"bind -N 'Rename current session' '$' { command-prompt -I'#S' { rename-session -- '%%' } }\",\n\t\t\"bind -N 'Split window horizontally' % { split-window -h }\",\n\t\t\"bind -N 'Kill current window' & { confirm-before -p\\\"kill-window #W? (y/n)\\\" kill-window }\",\n\t\t\"bind -N 'Prompt for window index to select' \\\"'\\\" { command-prompt -T window-target -pindex { select-window -t ':%%' } }\",\n\t\t\"bind -N 'Switch to previous client' ( { switch-client -p }\",\n\t\t\"bind -N 'Switch to next client' ) { switch-client -n }\",\n\t\t\"bind -N 'Rename current window' , { command-prompt -I'#W' { rename-window -- '%%' } }\",\n\t\t\"bind -N 'Delete the most recent paste buffer' - { delete-buffer }\",\n\t\t\"bind -N 'Move the current window' . { command-prompt -T target { move-window -t '%%' } }\",\n\t\t\"bind -N 'Describe key binding' '/' { command-prompt -kpkey  { list-keys -1N '%%' } }\",\n\t\t\"bind -N 'Select window 0' 0 { select-window -t:=0 }\",\n\t\t\"bind -N 'Select window 1' 1 { select-window -t:=1 }\",\n\t\t\"bind -N 'Select window 2' 2 { select-window -t:=2 }\",\n\t\t\"bind -N 'Select window 3' 3 { select-window -t:=3 }\",\n\t\t\"bind -N 'Select window 4' 4 { select-window -t:=4 }\",\n\t\t\"bind -N 'Select window 5' 5 { select-window -t:=5 }\",\n\t\t\"bind -N 'Select window 6' 6 { select-window -t:=6 }\",\n\t\t\"bind -N 'Select window 7' 7 { select-window -t:=7 }\",\n\t\t\"bind -N 'Select window 8' 8 { select-window -t:=8 }\",\n\t\t\"bind -N 'Select window 9' 9 { select-window -t:=9 }\",\n\t\t\"bind -N 'Prompt for a command' : { command-prompt }\",\n\t\t\"bind -N 'Move to the previously active pane' \\\\; { last-pane }\",\n\t\t\"bind -N 'Choose a paste buffer from a list' = { choose-buffer -Z }\",\n\t\t\"bind -N 'List key bindings' ? { list-keys -N }\",\n\t\t\"bind -N 'Choose and detach a client from a list' D { choose-client -Z }\",\n\t\t\"bind -N 'Spread panes out evenly' E { select-layout -E }\",\n\t\t\"bind -N 'Switch to the last client' L { switch-client -l }\",\n\t\t\"bind -N 'Clear the marked pane' M { select-pane -M }\",\n\t\t\"bind -N 'Enter copy mode' [ { copy-mode }\",\n\t\t\"bind -N 'Paste the most recent paste buffer' ] { paste-buffer -p }\",\n\t\t\"bind -N 'Create a new window' c { new-window }\",\n\t\t\"bind -N 'Detach the current client' d { detach-client }\",\n\t\t\"bind -N 'Search for a pane' f { command-prompt { find-window -Z -- '%%' } }\",\n\t\t\"bind -N 'Display window information' i { display-message }\",\n\t\t\"bind -N 'Select the previously current window' l { last-window }\",\n\t\t\"bind -N 'Toggle the marked pane' m { select-pane -m }\",\n\t\t\"bind -N 'Select the next window' n { next-window }\",\n\t\t\"bind -N 'Select the next pane' o { select-pane -t:.+ }\",\n\t\t\"bind -N 'Customize options' C { customize-mode -Z }\",\n\t\t\"bind -N 'Select the previous window' p { previous-window }\",\n\t\t\"bind -N 'Display pane numbers' q { display-panes }\",\n\t\t\"bind -N 'Redraw the current client' r { refresh-client }\",\n\t\t\"bind -N 'Choose a session from a list' s { choose-tree -Zs }\",\n\t\t\"bind -N 'Show a clock' t { clock-mode }\",\n\t\t\"bind -N 'Choose a window from a list' w { choose-tree -Zw }\",\n\t\t\"bind -N 'Kill the active pane' x { confirm-before -p\\\"kill-pane #P? (y/n)\\\" kill-pane }\",\n\t\t\"bind -N 'Zoom the active pane' z { resize-pane -Z }\",\n\t\t\"bind -N 'Swap the active pane with the pane above' '{' { swap-pane -U }\",\n\t\t\"bind -N 'Swap the active pane with the pane below' '}' { swap-pane -D }\",\n\t\t\"bind -N 'Show messages' '~' { show-messages }\",\n\t\t\"bind -N 'Enter copy mode and scroll up' PPage { copy-mode -u }\",\n\t\t\"bind -N 'Select the pane above the active pane' -r Up { select-pane -U }\",\n\t\t\"bind -N 'Select the pane below the active pane' -r Down { select-pane -D }\",\n\t\t\"bind -N 'Select the pane to the left of the active pane' -r Left { select-pane -L }\",\n\t\t\"bind -N 'Select the pane to the right of the active pane' -r Right { select-pane -R }\",\n\t\t\"bind -N 'Set the even-horizontal layout' M-1 { select-layout even-horizontal }\",\n\t\t\"bind -N 'Set the even-vertical layout' M-2 { select-layout even-vertical }\",\n\t\t\"bind -N 'Set the main-horizontal layout' M-3 { select-layout main-horizontal }\",\n\t\t\"bind -N 'Set the main-vertical layout' M-4 { select-layout main-vertical }\",\n\t\t\"bind -N 'Select the tiled layout' M-5 { select-layout tiled }\",\n\t\t\"bind -N 'Set the main-horizontal-mirrored layout' M-6 { select-layout main-horizontal-mirrored }\",\n\t\t\"bind -N 'Set the main-vertical-mirrored layout' M-7 { select-layout main-vertical-mirrored }\",\n\t\t\"bind -N 'Select the next window with an alert' M-n { next-window -a }\",\n\t\t\"bind -N 'Rotate through the panes in reverse' M-o { rotate-window -D }\",\n\t\t\"bind -N 'Select the previous window with an alert' M-p { previous-window -a }\",\n\t\t\"bind -N 'Move the visible part of the window up' -r S-Up { refresh-client -U 10 }\",\n\t\t\"bind -N 'Move the visible part of the window down' -r S-Down { refresh-client -D 10 }\",\n\t\t\"bind -N 'Move the visible part of the window left' -r S-Left { refresh-client -L 10 }\",\n\t\t\"bind -N 'Move the visible part of the window right' -r S-Right { refresh-client -R 10 }\",\n\t\t\"bind -N 'Reset so the visible part of the window follows the cursor' -r DC { refresh-client -c }\",\n\t\t\"bind -N 'Resize the pane up by 5' -r M-Up { resize-pane -U 5 }\",\n\t\t\"bind -N 'Resize the pane down by 5' -r M-Down { resize-pane -D 5 }\",\n\t\t\"bind -N 'Resize the pane left by 5' -r M-Left { resize-pane -L 5 }\",\n\t\t\"bind -N 'Resize the pane right by 5' -r M-Right { resize-pane -R 5 }\",\n\t\t\"bind -N 'Resize the pane up' -r C-Up { resize-pane -U }\",\n\t\t\"bind -N 'Resize the pane down' -r C-Down { resize-pane -D }\",\n\t\t\"bind -N 'Resize the pane left' -r C-Left { resize-pane -L }\",\n\t\t\"bind -N 'Resize the pane right' -r C-Right { resize-pane -R }\",\n\n\t\t/* Menu keys */\n\t\t\"bind < { display-menu -xW -yW -T '#[align=centre]#{window_index}:#{window_name}' \" DEFAULT_WINDOW_MENU \" }\",\n\t\t\"bind > { display-menu -xP -yP -T '#[align=centre]#{pane_index} (#{pane_id})' \" DEFAULT_PANE_MENU \" }\",\n\n\t\t/* Mouse button 1 down on pane. */\n\t\t\"bind -n MouseDown1Pane { select-pane -t=; send -M }\",\n\n\t\t/* Mouse button 1 drag on pane. */\n\t\t\"bind -n MouseDrag1Pane { if -F '#{||:#{pane_in_mode},#{mouse_any_flag}}' { send -M } { copy-mode -M } }\",\n\n\t\t/* Mouse wheel up on pane. */\n\t\t\"bind -n WheelUpPane { if -F '#{||:#{pane_in_mode},#{mouse_any_flag}}' { send -M } { copy-mode -e } }\",\n\n\t\t/* Mouse button 2 down on pane. */\n\t\t\"bind -n MouseDown2Pane { select-pane -t=; if -F '#{||:#{pane_in_mode},#{mouse_any_flag}}' { send -M } { paste -p } }\",\n\n\t\t/* Mouse button 1 double click on pane. */\n\t\t\"bind -n DoubleClick1Pane { select-pane -t=; if -F '#{||:#{pane_in_mode},#{mouse_any_flag}}' { send -M } { copy-mode -H; send -X select-word; run -d0.3; send -X copy-pipe-and-cancel } }\",\n\n\t\t/* Mouse button 1 triple click on pane. */\n\t\t\"bind -n TripleClick1Pane { select-pane -t=; if -F '#{||:#{pane_in_mode},#{mouse_any_flag}}' { send -M } { copy-mode -H; send -X select-line; run -d0.3; send -X copy-pipe-and-cancel } }\",\n\n\t\t/* Mouse button 1 drag on border. */\n\t\t\"bind -n MouseDrag1Border { resize-pane -M }\",\n\n\t\t/* Mouse button 1 down on status line. */\n\t\t\"bind -n MouseDown1Status { select-window -t= }\",\n\n\t\t/* Mouse wheel down on status line. */\n\t\t\"bind -n WheelDownStatus { next-window }\",\n\n\t\t/* Mouse wheel up on status line. */\n\t\t\"bind -n WheelUpStatus { previous-window }\",\n\n\t\t/* Mouse button 3 down on status left. */\n\t\t\"bind -n MouseDown3StatusLeft { display-menu -t= -xM -yW -T '#[align=centre]#{session_name}' \" DEFAULT_SESSION_MENU \" }\",\n\t\t\"bind -n M-MouseDown3StatusLeft { display-menu -t= -xM -yW -T '#[align=centre]#{session_name}' \" DEFAULT_SESSION_MENU \" }\",\n\n\t\t/* Mouse button 3 down on status line. */\n\t\t\"bind -n MouseDown3Status { display-menu -t= -xW -yW -T '#[align=centre]#{window_index}:#{window_name}' \" DEFAULT_WINDOW_MENU \"}\",\n\t\t\"bind -n M-MouseDown3Status { display-menu -t= -xW -yW -T '#[align=centre]#{window_index}:#{window_name}' \" DEFAULT_WINDOW_MENU \"}\",\n\n\t\t/* Mouse button 3 down on pane. */\n\t\t\"bind -n MouseDown3Pane { if -Ft= '#{||:#{mouse_any_flag},#{&&:#{pane_in_mode},#{?#{m/r:(copy|view)-mode,#{pane_mode}},0,1}}}' { select-pane -t=; send -M } { display-menu -t= -xM -yM -T '#[align=centre]#{pane_index} (#{pane_id})' \" DEFAULT_PANE_MENU \" } }\",\n\t\t\"bind -n M-MouseDown3Pane { display-menu -t= -xM -yM -T '#[align=centre]#{pane_index} (#{pane_id})' \" DEFAULT_PANE_MENU \" }\",\n\n\t\t/* Mouse on scrollbar. */\n\t\t\"bind -n MouseDown1ScrollbarUp { copy-mode -u }\",\n\t\t\"bind -n MouseDown1ScrollbarDown { copy-mode -d }\",\n\t\t\"bind -n MouseDrag1ScrollbarSlider { copy-mode -S }\",\n\n\t\t/* Copy mode (emacs) keys. */\n\t\t\"bind -Tcopy-mode C-Space { send -X begin-selection }\",\n\t\t\"bind -Tcopy-mode C-a { send -X start-of-line }\",\n\t\t\"bind -Tcopy-mode C-c { send -X cancel }\",\n\t\t\"bind -Tcopy-mode C-e { send -X end-of-line }\",\n\t\t\"bind -Tcopy-mode C-f { send -X cursor-right }\",\n\t\t\"bind -Tcopy-mode C-b { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode C-g { send -X clear-selection }\",\n\t\t\"bind -Tcopy-mode C-k { send -X copy-pipe-end-of-line-and-cancel }\",\n\t\t\"bind -Tcopy-mode C-n { send -X cursor-down }\",\n\t\t\"bind -Tcopy-mode C-p { send -X cursor-up }\",\n\t\t\"bind -Tcopy-mode C-r { command-prompt -T search -ip'(search up)' -I'#{pane_search_string}' { send -X search-backward-incremental -- '%%' } }\",\n\t\t\"bind -Tcopy-mode C-s { command-prompt -T search -ip'(search down)' -I'#{pane_search_string}' { send -X search-forward-incremental -- '%%' } }\",\n\t\t\"bind -Tcopy-mode C-v { send -X page-down }\",\n\t\t\"bind -Tcopy-mode C-w { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode Escape { send -X cancel }\",\n\t\t\"bind -Tcopy-mode Space { send -X page-down }\",\n\t\t\"bind -Tcopy-mode , { send -X jump-reverse }\",\n\t\t\"bind -Tcopy-mode \\\\; { send -X jump-again }\",\n\t\t\"bind -Tcopy-mode F { command-prompt -1p'(jump backward)' { send -X jump-backward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode N { send -X search-reverse }\",\n\t\t\"bind -Tcopy-mode P { send -X toggle-position }\",\n\t\t\"bind -Tcopy-mode R { send -X rectangle-toggle }\",\n\t\t\"bind -Tcopy-mode T { command-prompt -1p'(jump to backward)' { send -X jump-to-backward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode X { send -X set-mark }\",\n\t\t\"bind -Tcopy-mode f { command-prompt -1p'(jump forward)' { send -X jump-forward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode g { command-prompt -p'(goto line)' { send -X goto-line -- '%%' } }\",\n\t\t\"bind -Tcopy-mode n { send -X search-again }\",\n\t\t\"bind -Tcopy-mode q { send -X cancel }\",\n\t\t\"bind -Tcopy-mode r { send -X refresh-from-pane }\",\n\t\t\"bind -Tcopy-mode t { command-prompt -1p'(jump to forward)' { send -X jump-to-forward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode Home { send -X start-of-line }\",\n\t\t\"bind -Tcopy-mode End { send -X end-of-line }\",\n\t\t\"bind -Tcopy-mode MouseDown1Pane select-pane\",\n\t\t\"bind -Tcopy-mode MouseDrag1Pane { select-pane; send -X begin-selection }\",\n\t\t\"bind -Tcopy-mode MouseDragEnd1Pane { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode WheelUpPane { select-pane; send -N5 -X scroll-up }\",\n\t\t\"bind -Tcopy-mode WheelDownPane { select-pane; send -N5 -X scroll-down }\",\n\t\t\"bind -Tcopy-mode DoubleClick1Pane { select-pane; send -X select-word; run -d0.3; send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode TripleClick1Pane { select-pane; send -X select-line; run -d0.3; send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode NPage { send -X page-down }\",\n\t\t\"bind -Tcopy-mode PPage { send -X page-up }\",\n\t\t\"bind -Tcopy-mode Up { send -X cursor-up }\",\n\t\t\"bind -Tcopy-mode Down { send -X cursor-down }\",\n\t\t\"bind -Tcopy-mode Left { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode Right { send -X cursor-right }\",\n\t\t\"bind -Tcopy-mode M-1 { command-prompt -Np'(repeat)' -I1 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-2 { command-prompt -Np'(repeat)' -I2 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-3 { command-prompt -Np'(repeat)' -I3 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-4 { command-prompt -Np'(repeat)' -I4 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-5 { command-prompt -Np'(repeat)' -I5 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-6 { command-prompt -Np'(repeat)' -I6 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-7 { command-prompt -Np'(repeat)' -I7 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-8 { command-prompt -Np'(repeat)' -I8 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-9 { command-prompt -Np'(repeat)' -I9 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode M-< { send -X history-top }\",\n\t\t\"bind -Tcopy-mode M-> { send -X history-bottom }\",\n\t\t\"bind -Tcopy-mode M-R { send -X top-line }\",\n\t\t\"bind -Tcopy-mode M-b { send -X previous-word }\",\n\t\t\"bind -Tcopy-mode C-M-b { send -X previous-matching-bracket }\",\n\t\t\"bind -Tcopy-mode M-f { send -X next-word-end }\",\n\t\t\"bind -Tcopy-mode C-M-f { send -X next-matching-bracket }\",\n\t\t\"bind -Tcopy-mode M-m { send -X back-to-indentation }\",\n\t\t\"bind -Tcopy-mode M-r { send -X middle-line }\",\n\t\t\"bind -Tcopy-mode M-v { send -X page-up }\",\n\t\t\"bind -Tcopy-mode M-w { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode M-x { send -X jump-to-mark }\",\n\t\t\"bind -Tcopy-mode 'M-{' { send -X previous-paragraph }\",\n\t\t\"bind -Tcopy-mode 'M-}' { send -X next-paragraph }\",\n\t\t\"bind -Tcopy-mode M-Up { send -X halfpage-up }\",\n\t\t\"bind -Tcopy-mode M-Down { send -X halfpage-down }\",\n\t\t\"bind -Tcopy-mode C-Up { send -X scroll-up }\",\n\t\t\"bind -Tcopy-mode C-Down { send -X scroll-down }\",\n\n\t\t/* Copy mode (vi) keys. */\n\t\t\"bind -Tcopy-mode-vi '#' { send -FX search-backward -- '#{copy_cursor_word}' }\",\n\t\t\"bind -Tcopy-mode-vi * { send -FX search-forward -- '#{copy_cursor_word}' }\",\n\t\t\"bind -Tcopy-mode-vi C-c { send -X cancel }\",\n\t\t\"bind -Tcopy-mode-vi C-d { send -X halfpage-down }\",\n\t\t\"bind -Tcopy-mode-vi C-e { send -X scroll-down }\",\n\t\t\"bind -Tcopy-mode-vi C-b { send -X page-up }\",\n\t\t\"bind -Tcopy-mode-vi C-f { send -X page-down }\",\n\t\t\"bind -Tcopy-mode-vi C-h { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode-vi C-j { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi Enter { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi C-u { send -X halfpage-up }\",\n\t\t\"bind -Tcopy-mode-vi C-v { send -X rectangle-toggle }\",\n\t\t\"bind -Tcopy-mode-vi C-y { send -X scroll-up }\",\n\t\t\"bind -Tcopy-mode-vi Escape { send -X clear-selection }\",\n\t\t\"bind -Tcopy-mode-vi Space { send -X begin-selection }\",\n\t\t\"bind -Tcopy-mode-vi '$' { send -X end-of-line }\",\n\t\t\"bind -Tcopy-mode-vi , { send -X jump-reverse }\",\n\t\t\"bind -Tcopy-mode-vi / { command-prompt -T search -p'(search down)' { send -X search-forward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 0 { send -X start-of-line }\",\n\t\t\"bind -Tcopy-mode-vi 1 { command-prompt -Np'(repeat)' -I1 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 2 { command-prompt -Np'(repeat)' -I2 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 3 { command-prompt -Np'(repeat)' -I3 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 4 { command-prompt -Np'(repeat)' -I4 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 5 { command-prompt -Np'(repeat)' -I5 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 6 { command-prompt -Np'(repeat)' -I6 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 7 { command-prompt -Np'(repeat)' -I7 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 8 { command-prompt -Np'(repeat)' -I8 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi 9 { command-prompt -Np'(repeat)' -I9 { send -N '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi : { command-prompt -p'(goto line)' { send -X goto-line -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi \\\\; { send -X jump-again }\",\n\t\t\"bind -Tcopy-mode-vi ? { command-prompt -T search -p'(search up)' { send -X search-backward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi A { send -X append-selection-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi B { send -X previous-space }\",\n\t\t\"bind -Tcopy-mode-vi D { send -X copy-pipe-end-of-line-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi E { send -X next-space-end }\",\n\t\t\"bind -Tcopy-mode-vi F { command-prompt -1p'(jump backward)' { send -X jump-backward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi G { send -X history-bottom }\",\n\t\t\"bind -Tcopy-mode-vi H { send -X top-line }\",\n\t\t\"bind -Tcopy-mode-vi J { send -X scroll-down }\",\n\t\t\"bind -Tcopy-mode-vi K { send -X scroll-up }\",\n\t\t\"bind -Tcopy-mode-vi L { send -X bottom-line }\",\n\t\t\"bind -Tcopy-mode-vi M { send -X middle-line }\",\n\t\t\"bind -Tcopy-mode-vi N { send -X search-reverse }\",\n\t\t\"bind -Tcopy-mode-vi P { send -X toggle-position }\",\n\t\t\"bind -Tcopy-mode-vi T { command-prompt -1p'(jump to backward)' { send -X jump-to-backward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi V { send -X select-line }\",\n\t\t\"bind -Tcopy-mode-vi W { send -X next-space }\",\n\t\t\"bind -Tcopy-mode-vi X { send -X set-mark }\",\n\t\t\"bind -Tcopy-mode-vi ^ { send -X back-to-indentation }\",\n\t\t\"bind -Tcopy-mode-vi b { send -X previous-word }\",\n\t\t\"bind -Tcopy-mode-vi e { send -X next-word-end }\",\n\t\t\"bind -Tcopy-mode-vi f { command-prompt -1p'(jump forward)' { send -X jump-forward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi g { send -X history-top }\",\n\t\t\"bind -Tcopy-mode-vi h { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode-vi j { send -X cursor-down }\",\n\t\t\"bind -Tcopy-mode-vi k { send -X cursor-up }\",\n\t\t\"bind -Tcopy-mode-vi z { send -X scroll-middle }\",\n\t\t\"bind -Tcopy-mode-vi l { send -X cursor-right }\",\n\t\t\"bind -Tcopy-mode-vi n { send -X search-again }\",\n\t\t\"bind -Tcopy-mode-vi o { send -X other-end }\",\n\t\t\"bind -Tcopy-mode-vi q { send -X cancel }\",\n\t\t\"bind -Tcopy-mode-vi r { send -X refresh-from-pane }\",\n\t\t\"bind -Tcopy-mode-vi t { command-prompt -1p'(jump to forward)' { send -X jump-to-forward -- '%%' } }\",\n\t\t\"bind -Tcopy-mode-vi v { send -X rectangle-toggle }\",\n\t\t\"bind -Tcopy-mode-vi w { send -X next-word }\",\n\t\t\"bind -Tcopy-mode-vi '{' { send -X previous-paragraph }\",\n\t\t\"bind -Tcopy-mode-vi '}' { send -X next-paragraph }\",\n\t\t\"bind -Tcopy-mode-vi % { send -X next-matching-bracket }\",\n\t\t\"bind -Tcopy-mode-vi Home { send -X start-of-line }\",\n\t\t\"bind -Tcopy-mode-vi End { send -X end-of-line }\",\n\t\t\"bind -Tcopy-mode-vi MouseDown1Pane { select-pane }\",\n\t\t\"bind -Tcopy-mode-vi MouseDrag1Pane { select-pane; send -X begin-selection }\",\n\t\t\"bind -Tcopy-mode-vi MouseDragEnd1Pane { send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi WheelUpPane { select-pane; send -N5 -X scroll-up }\",\n\t\t\"bind -Tcopy-mode-vi WheelDownPane { select-pane; send -N5 -X scroll-down }\",\n\t\t\"bind -Tcopy-mode-vi DoubleClick1Pane { select-pane; send -X select-word; run -d0.3; send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi TripleClick1Pane { select-pane; send -X select-line; run -d0.3; send -X copy-pipe-and-cancel }\",\n\t\t\"bind -Tcopy-mode-vi BSpace { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode-vi NPage { send -X page-down }\",\n\t\t\"bind -Tcopy-mode-vi PPage { send -X page-up }\",\n\t\t\"bind -Tcopy-mode-vi Up { send -X cursor-up }\",\n\t\t\"bind -Tcopy-mode-vi Down { send -X cursor-down }\",\n\t\t\"bind -Tcopy-mode-vi Left { send -X cursor-left }\",\n\t\t\"bind -Tcopy-mode-vi Right { send -X cursor-right }\",\n\t\t\"bind -Tcopy-mode-vi M-x { send -X jump-to-mark }\",\n\t\t\"bind -Tcopy-mode-vi C-Up { send -X scroll-up }\",\n\t\t\"bind -Tcopy-mode-vi C-Down { send -X scroll-down }\",\n\t};\n\tu_int\t\t\t i;\n\tstruct cmd_parse_result\t*pr;\n\n\tfor (i = 0; i < nitems(defaults); i++) {\n\t\tpr = cmd_parse_from_string(defaults[i], NULL);\n\t\tif (pr->status != CMD_PARSE_SUCCESS) {\n\t\t\tlog_debug(\"%s\", pr->error);\n\t\t\tfatalx(\"bad default key: %s\", defaults[i]);\n\t\t}\n\t\tcmdq_append(NULL, cmdq_get_command(pr->cmdlist, NULL));\n\t\tcmd_list_free(pr->cmdlist);\n\t}\n\tcmdq_append(NULL, cmdq_get_callback(key_bindings_init_done, NULL));\n}\n\nstatic enum cmd_retval\nkey_bindings_read_only(struct cmdq_item *item, __unused void *data)\n{\n\tcmdq_error(item, \"client is read-only\");\n\treturn (CMD_RETURN_ERROR);\n}\n\nstruct cmdq_item *\nkey_bindings_dispatch(struct key_binding *bd, struct cmdq_item *item,\n    struct client *c, struct key_event *event, struct cmd_find_state *fs)\n{\n\tstruct cmdq_item\t*new_item;\n\tstruct cmdq_state\t*new_state;\n\tint\t\t\t readonly, flags = 0;\n\n\tif (c == NULL || (~c->flags & CLIENT_READONLY))\n\t\treadonly = 1;\n\telse\n\t\treadonly = cmd_list_all_have(bd->cmdlist, CMD_READONLY);\n\tif (!readonly)\n\t\tnew_item = cmdq_get_callback(key_bindings_read_only, NULL);\n\telse {\n\t\tif (bd->flags & KEY_BINDING_REPEAT)\n\t\t\tflags |= CMDQ_STATE_REPEAT;\n\t\tnew_state = cmdq_new_state(fs, event, flags);\n\t\tnew_item = cmdq_get_command(bd->cmdlist, new_state);\n\t\tcmdq_free_state(new_state);\n\t}\n\tif (item != NULL)\n\t\tnew_item = cmdq_insert_after(item, new_item);\n\telse\n\t\tnew_item = cmdq_append(c, new_item);\n\treturn (new_item);\n}\n"
        },
        {
          "name": "key-string.c",
          "type": "blob",
          "size": 12.8818359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"tmux.h\"\n\nstatic key_code\tkey_string_search_table(const char *);\nstatic key_code\tkey_string_get_modifiers(const char **);\n\nstatic const struct {\n\tconst char     *string;\n\tkey_code\tkey;\n} key_string_table[] = {\n\t/* Function keys. */\n\t{ \"F1\",\t\tKEYC_F1|KEYC_IMPLIED_META },\n\t{ \"F2\",\t\tKEYC_F2|KEYC_IMPLIED_META },\n\t{ \"F3\",\t\tKEYC_F3|KEYC_IMPLIED_META },\n\t{ \"F4\",\t\tKEYC_F4|KEYC_IMPLIED_META },\n\t{ \"F5\",\t\tKEYC_F5|KEYC_IMPLIED_META },\n\t{ \"F6\",\t\tKEYC_F6|KEYC_IMPLIED_META },\n\t{ \"F7\",\t\tKEYC_F7|KEYC_IMPLIED_META },\n\t{ \"F8\",\t\tKEYC_F8|KEYC_IMPLIED_META },\n\t{ \"F9\",\t\tKEYC_F9|KEYC_IMPLIED_META },\n\t{ \"F10\",\tKEYC_F10|KEYC_IMPLIED_META },\n\t{ \"F11\",\tKEYC_F11|KEYC_IMPLIED_META },\n\t{ \"F12\",\tKEYC_F12|KEYC_IMPLIED_META },\n\t{ \"IC\",\t\tKEYC_IC|KEYC_IMPLIED_META },\n\t{ \"Insert\",\tKEYC_IC|KEYC_IMPLIED_META },\n\t{ \"DC\",\t\tKEYC_DC|KEYC_IMPLIED_META },\n\t{ \"Delete\",\tKEYC_DC|KEYC_IMPLIED_META },\n\t{ \"Home\",\tKEYC_HOME|KEYC_IMPLIED_META },\n\t{ \"End\",\tKEYC_END|KEYC_IMPLIED_META },\n\t{ \"NPage\",\tKEYC_NPAGE|KEYC_IMPLIED_META },\n\t{ \"PageDown\",\tKEYC_NPAGE|KEYC_IMPLIED_META },\n\t{ \"PgDn\",\tKEYC_NPAGE|KEYC_IMPLIED_META },\n\t{ \"PPage\",\tKEYC_PPAGE|KEYC_IMPLIED_META },\n\t{ \"PageUp\",\tKEYC_PPAGE|KEYC_IMPLIED_META },\n\t{ \"PgUp\",\tKEYC_PPAGE|KEYC_IMPLIED_META },\n\t{ \"BTab\",\tKEYC_BTAB },\n\t{ \"Space\",\t' ' },\n\t{ \"BSpace\",\tKEYC_BSPACE },\n\n\t/*\n\t * C0 control characters, with the exception of Tab, Enter,\n\t * and Esc, should never appear as keys. We still render them,\n\t * so to be able to spot them in logs in case of an abnormality.\n\t */\n\t{ \"[NUL]\",\tC0_NUL },\n\t{ \"[SOH]\",\tC0_SOH },\n\t{ \"[STX]\",\tC0_STX },\n\t{ \"[ETX]\",\tC0_ETX },\n\t{ \"[EOT]\",\tC0_EOT },\n\t{ \"[ENQ]\",\tC0_ENQ },\n\t{ \"[ASC]\",\tC0_ASC },\n\t{ \"[BEL]\",\tC0_BEL },\n\t{ \"[BS]\",\tC0_BS },\n\t{ \"Tab\",\tC0_HT },\n\t{ \"[LF]\",\tC0_LF },\n\t{ \"[VT]\",\tC0_VT },\n\t{ \"[FF]\",\tC0_FF },\n\t{ \"Enter\",\tC0_CR },\n\t{ \"[SO]\",\tC0_SO },\n\t{ \"[SI]\",\tC0_SI },\n\t{ \"[DLE]\",\tC0_DLE },\n\t{ \"[DC1]\",\tC0_DC1 },\n\t{ \"[DC2]\",\tC0_DC2 },\n\t{ \"[DC3]\",\tC0_DC3 },\n\t{ \"[DC4]\",\tC0_DC4 },\n\t{ \"[NAK]\",\tC0_NAK },\n\t{ \"[SYN]\",\tC0_SYN },\n\t{ \"[ETB]\",\tC0_ETB },\n\t{ \"[CAN]\",\tC0_CAN },\n\t{ \"[EM]\",\tC0_EM },\n\t{ \"[SUB]\",\tC0_SUB },\n\t{ \"Escape\",\tC0_ESC },\n\t{ \"[FS]\",\tC0_FS },\n\t{ \"[GS]\",\tC0_GS },\n\t{ \"[RS]\",\tC0_RS },\n\t{ \"[US]\",\tC0_US },\n\n\t/* Arrow keys. */\n\t{ \"Up\",\t\tKEYC_UP|KEYC_CURSOR|KEYC_IMPLIED_META },\n\t{ \"Down\",\tKEYC_DOWN|KEYC_CURSOR|KEYC_IMPLIED_META },\n\t{ \"Left\",\tKEYC_LEFT|KEYC_CURSOR|KEYC_IMPLIED_META },\n\t{ \"Right\",\tKEYC_RIGHT|KEYC_CURSOR|KEYC_IMPLIED_META },\n\n\t/* Numeric keypad. */\n\t{ \"KP/\",\tKEYC_KP_SLASH|KEYC_KEYPAD },\n\t{ \"KP*\",\tKEYC_KP_STAR|KEYC_KEYPAD },\n\t{ \"KP-\",\tKEYC_KP_MINUS|KEYC_KEYPAD },\n\t{ \"KP7\",\tKEYC_KP_SEVEN|KEYC_KEYPAD },\n\t{ \"KP8\",\tKEYC_KP_EIGHT|KEYC_KEYPAD },\n\t{ \"KP9\",\tKEYC_KP_NINE|KEYC_KEYPAD },\n\t{ \"KP+\",\tKEYC_KP_PLUS|KEYC_KEYPAD },\n\t{ \"KP4\",\tKEYC_KP_FOUR|KEYC_KEYPAD },\n\t{ \"KP5\",\tKEYC_KP_FIVE|KEYC_KEYPAD },\n\t{ \"KP6\",\tKEYC_KP_SIX|KEYC_KEYPAD },\n\t{ \"KP1\",\tKEYC_KP_ONE|KEYC_KEYPAD },\n\t{ \"KP2\",\tKEYC_KP_TWO|KEYC_KEYPAD },\n\t{ \"KP3\",\tKEYC_KP_THREE|KEYC_KEYPAD },\n\t{ \"KPEnter\",\tKEYC_KP_ENTER|KEYC_KEYPAD },\n\t{ \"KP0\",\tKEYC_KP_ZERO|KEYC_KEYPAD },\n\t{ \"KP.\",\tKEYC_KP_PERIOD|KEYC_KEYPAD },\n\n\t/* Mouse keys. */\n\tKEYC_MOUSE_STRING(MOUSEDOWN1, MouseDown1),\n\tKEYC_MOUSE_STRING(MOUSEDOWN2, MouseDown2),\n\tKEYC_MOUSE_STRING(MOUSEDOWN3, MouseDown3),\n\tKEYC_MOUSE_STRING(MOUSEDOWN6, MouseDown6),\n\tKEYC_MOUSE_STRING(MOUSEDOWN7, MouseDown7),\n\tKEYC_MOUSE_STRING(MOUSEDOWN8, MouseDown8),\n\tKEYC_MOUSE_STRING(MOUSEDOWN9, MouseDown9),\n\tKEYC_MOUSE_STRING(MOUSEDOWN10, MouseDown10),\n\tKEYC_MOUSE_STRING(MOUSEDOWN11, MouseDown11),\n\tKEYC_MOUSE_STRING(MOUSEUP1, MouseUp1),\n\tKEYC_MOUSE_STRING(MOUSEUP2, MouseUp2),\n\tKEYC_MOUSE_STRING(MOUSEUP3, MouseUp3),\n\tKEYC_MOUSE_STRING(MOUSEUP6, MouseUp6),\n\tKEYC_MOUSE_STRING(MOUSEUP7, MouseUp7),\n\tKEYC_MOUSE_STRING(MOUSEUP8, MouseUp8),\n\tKEYC_MOUSE_STRING(MOUSEUP9, MouseUp9),\n\tKEYC_MOUSE_STRING(MOUSEUP10, MouseUp10),\n\tKEYC_MOUSE_STRING(MOUSEUP11, MouseUp11),\n\tKEYC_MOUSE_STRING(MOUSEDRAG1, MouseDrag1),\n\tKEYC_MOUSE_STRING(MOUSEDRAG2, MouseDrag2),\n\tKEYC_MOUSE_STRING(MOUSEDRAG3, MouseDrag3),\n\tKEYC_MOUSE_STRING(MOUSEDRAG6, MouseDrag6),\n\tKEYC_MOUSE_STRING(MOUSEDRAG7, MouseDrag7),\n\tKEYC_MOUSE_STRING(MOUSEDRAG8, MouseDrag8),\n\tKEYC_MOUSE_STRING(MOUSEDRAG9, MouseDrag9),\n\tKEYC_MOUSE_STRING(MOUSEDRAG10, MouseDrag10),\n\tKEYC_MOUSE_STRING(MOUSEDRAG11, MouseDrag11),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND1, MouseDragEnd1),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND2, MouseDragEnd2),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND3, MouseDragEnd3),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND6, MouseDragEnd6),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND7, MouseDragEnd7),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND8, MouseDragEnd8),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND9, MouseDragEnd9),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND10, MouseDragEnd10),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND11, MouseDragEnd11),\n\tKEYC_MOUSE_STRING(WHEELUP, WheelUp),\n\tKEYC_MOUSE_STRING(WHEELDOWN, WheelDown),\n\tKEYC_MOUSE_STRING(SECONDCLICK1, SecondClick1),\n\tKEYC_MOUSE_STRING(SECONDCLICK2, SecondClick2),\n\tKEYC_MOUSE_STRING(SECONDCLICK3, SecondClick3),\n\tKEYC_MOUSE_STRING(SECONDCLICK6, SecondClick6),\n\tKEYC_MOUSE_STRING(SECONDCLICK7, SecondClick7),\n\tKEYC_MOUSE_STRING(SECONDCLICK8, SecondClick8),\n\tKEYC_MOUSE_STRING(SECONDCLICK9, SecondClick9),\n\tKEYC_MOUSE_STRING(SECONDCLICK10, SecondClick10),\n\tKEYC_MOUSE_STRING(SECONDCLICK11, SecondClick11),\n\tKEYC_MOUSE_STRING(DOUBLECLICK1, DoubleClick1),\n\tKEYC_MOUSE_STRING(DOUBLECLICK2, DoubleClick2),\n\tKEYC_MOUSE_STRING(DOUBLECLICK3, DoubleClick3),\n\tKEYC_MOUSE_STRING(DOUBLECLICK6, DoubleClick6),\n\tKEYC_MOUSE_STRING(DOUBLECLICK7, DoubleClick7),\n\tKEYC_MOUSE_STRING(DOUBLECLICK8, DoubleClick8),\n\tKEYC_MOUSE_STRING(DOUBLECLICK9, DoubleClick9),\n\tKEYC_MOUSE_STRING(DOUBLECLICK10, DoubleClick10),\n\tKEYC_MOUSE_STRING(DOUBLECLICK11, DoubleClick11),\n\tKEYC_MOUSE_STRING(TRIPLECLICK1, TripleClick1),\n\tKEYC_MOUSE_STRING(TRIPLECLICK2, TripleClick2),\n\tKEYC_MOUSE_STRING(TRIPLECLICK3, TripleClick3),\n\tKEYC_MOUSE_STRING(TRIPLECLICK6, TripleClick6),\n\tKEYC_MOUSE_STRING(TRIPLECLICK7, TripleClick7),\n\tKEYC_MOUSE_STRING(TRIPLECLICK8, TripleClick8),\n\tKEYC_MOUSE_STRING(TRIPLECLICK9, TripleClick9),\n\tKEYC_MOUSE_STRING(TRIPLECLICK10, TripleClick10),\n\tKEYC_MOUSE_STRING(TRIPLECLICK11, TripleClick11)\n};\n\n/* Find key string in table. */\nstatic key_code\nkey_string_search_table(const char *string)\n{\n\tu_int\ti, user;\n\n\tfor (i = 0; i < nitems(key_string_table); i++) {\n\t\tif (strcasecmp(string, key_string_table[i].string) == 0)\n\t\t\treturn (key_string_table[i].key);\n\t}\n\n\tif (sscanf(string, \"User%u\", &user) == 1 && user < KEYC_NUSER)\n\t\treturn (KEYC_USER + user);\n\n\treturn (KEYC_UNKNOWN);\n}\n\n/* Find modifiers. */\nstatic key_code\nkey_string_get_modifiers(const char **string)\n{\n\tkey_code\tmodifiers;\n\n\tmodifiers = 0;\n\twhile (((*string)[0] != '\\0') && (*string)[1] == '-') {\n\t\tswitch ((*string)[0]) {\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tmodifiers |= KEYC_CTRL;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\tcase 'm':\n\t\t\tmodifiers |= KEYC_META;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 's':\n\t\t\tmodifiers |= KEYC_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*string = NULL;\n\t\t\treturn (0);\n\t\t}\n\t\t*string += 2;\n\t}\n\treturn (modifiers);\n}\n\n/* Lookup a string and convert to a key value. */\nkey_code\nkey_string_lookup_string(const char *string)\n{\n\tkey_code\t\t key, modifiers = 0;\n\tu_int\t\t\t u, i;\n\tstruct utf8_data\t ud, *udp;\n\tenum utf8_state\t\t more;\n\tutf8_char\t\t uc;\n\tchar\t\t\t m[MB_LEN_MAX + 1];\n\tint\t\t\t mlen;\n\n\t/* Is this no key or any key? */\n\tif (strcasecmp(string, \"None\") == 0)\n\t\treturn (KEYC_NONE);\n\tif (strcasecmp(string, \"Any\") == 0)\n\t\treturn (KEYC_ANY);\n\n\t/* Is this a hexadecimal value? */\n\tif (string[0] == '0' && string[1] == 'x') {\n\t\tif (sscanf(string + 2, \"%x\", &u) != 1)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tif (u < 32)\n\t\t\treturn (u);\n\t\tmlen = wctomb(m, u);\n\t\tif (mlen <= 0 || mlen > MB_LEN_MAX)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tm[mlen] = '\\0';\n\n\t\tudp = utf8_fromcstr(m);\n\t\tif (udp == NULL ||\n\t\t    udp[0].size == 0 ||\n\t\t    udp[1].size != 0 ||\n\t\t    utf8_from_data(&udp[0], &uc) != UTF8_DONE) {\n\t\t\tfree(udp);\n\t\t\treturn (KEYC_UNKNOWN);\n\t\t}\n\t\tfree(udp);\n\t\treturn (uc);\n\t}\n\n\t/* Check for short Ctrl key. */\n\tif (string[0] == '^' && string[1] != '\\0') {\n\t\tif (string[2] == '\\0')\n\t\t\treturn (tolower((u_char)string[1])|KEYC_CTRL);\n\t\tmodifiers |= KEYC_CTRL;\n\t\tstring++;\n\t}\n\n\t/* Check for modifiers. */\n\tmodifiers |= key_string_get_modifiers(&string);\n\tif (string == NULL || string[0] == '\\0')\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Is this a standard ASCII key? */\n\tif (string[1] == '\\0' && (u_char)string[0] <= 127) {\n\t\tkey = (u_char)string[0];\n\t\tif (key < 32)\n\t\t\treturn (KEYC_UNKNOWN);\n\t} else {\n\t\t/* Try as a UTF-8 key. */\n\t\tif ((more = utf8_open(&ud, (u_char)*string)) == UTF8_MORE) {\n\t\t\tif (strlen(string) != ud.size)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tfor (i = 1; i < ud.size; i++)\n\t\t\t\tmore = utf8_append(&ud, (u_char)string[i]);\n\t\t\tif (more != UTF8_DONE)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tif (utf8_from_data(&ud, &uc) != UTF8_DONE)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\treturn (uc|modifiers);\n\t\t}\n\n\t\t/* Otherwise look the key up in the table. */\n\t\tkey = key_string_search_table(string);\n\t\tif (key == KEYC_UNKNOWN)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tif (~modifiers & KEYC_META)\n\t\t\tkey &= ~KEYC_IMPLIED_META;\n\t}\n\n\treturn (key|modifiers);\n}\n\n/* Convert a key code into string format, with prefix if necessary. */\nconst char *\nkey_string_lookup_key(key_code key, int with_flags)\n{\n\tkey_code\t\t saved = key;\n\tstatic char\t\t out[64];\n\tchar\t\t\t tmp[8];\n\tconst char\t\t*s;\n\tu_int\t\t\t i;\n\tstruct utf8_data\t ud;\n\tsize_t\t\t\t off;\n\n\t*out = '\\0';\n\n\t/* Literal keys are themselves. */\n\tif (key & KEYC_LITERAL) {\n\t\tsnprintf(out, sizeof out, \"%c\", (int)(key & 0xff));\n\t\tgoto out;\n\t}\n\n\t/* Fill in the modifiers. */\n\tif (key & KEYC_CTRL)\n\t\tstrlcat(out, \"C-\", sizeof out);\n\tif (key & KEYC_META)\n\t\tstrlcat(out, \"M-\", sizeof out);\n\tif (key & KEYC_SHIFT)\n\t\tstrlcat(out, \"S-\", sizeof out);\n\tkey &= KEYC_MASK_KEY;\n\n\t/* Handle no key. */\n\tif (key == KEYC_NONE) {\n\t\ts = \"None\";\n\t\tgoto append;\n\t}\n\n\t/* Handle special keys. */\n\tif (key == KEYC_UNKNOWN) {\n\t\ts = \"Unknown\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_ANY) {\n\t\ts = \"Any\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_FOCUS_IN) {\n\t\ts = \"FocusIn\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_FOCUS_OUT) {\n\t\ts = \"FocusOut\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_PASTE_START) {\n\t\ts = \"PasteStart\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_PASTE_END) {\n\t\ts = \"PasteEnd\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSE) {\n\t\ts = \"Mouse\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_DRAGGING) {\n\t\ts = \"Dragging\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSEMOVE_PANE) {\n\t\ts = \"MouseMovePane\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSEMOVE_STATUS) {\n\t\ts = \"MouseMoveStatus\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSEMOVE_STATUS_LEFT) {\n\t\ts = \"MouseMoveStatusLeft\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSEMOVE_STATUS_RIGHT) {\n\t\ts = \"MouseMoveStatusRight\";\n\t\tgoto append;\n\t}\n\tif (key == KEYC_MOUSEMOVE_BORDER) {\n\t\ts = \"MouseMoveBorder\";\n\t\tgoto append;\n\t}\n\tif (key >= KEYC_USER && key < KEYC_USER_END) {\n\t\tsnprintf(tmp, sizeof tmp, \"User%u\", (u_int)(key - KEYC_USER));\n\t\tstrlcat(out, tmp, sizeof out);\n\t\tgoto out;\n\t}\n\n\t/* Try the key against the string table. */\n\tfor (i = 0; i < nitems(key_string_table); i++) {\n\t\tif (key == (key_string_table[i].key & KEYC_MASK_KEY))\n\t\t\tbreak;\n\t}\n\tif (i != nitems(key_string_table)) {\n\t\tstrlcat(out, key_string_table[i].string, sizeof out);\n\t\tgoto out;\n\t}\n\n\t/* Is this a Unicode key? */\n\tif (KEYC_IS_UNICODE(key)) {\n\t\tutf8_to_data(key, &ud);\n\t\toff = strlen(out);\n\t\tmemcpy(out + off, ud.data, ud.size);\n\t\tout[off + ud.size] = '\\0';\n\t\tgoto out;\n\t}\n\n\t/* Invalid keys are errors. */\n\tif (key > 255) {\n\t\tsnprintf(out, sizeof out, \"Invalid#%llx\", saved);\n\t\tgoto out;\n\t}\n\n\t/* Printable ASCII keys. */\n\tif (key > 32 && key <= 126) {\n\t\ttmp[0] = key;\n\t\ttmp[1] = '\\0';\n\t} else if (key == 127)\n\t\txsnprintf(tmp, sizeof tmp, \"C-?\");\n\telse if (key >= 128)\n\t\txsnprintf(tmp, sizeof tmp, \"\\\\%llo\", key);\n\n\tstrlcat(out, tmp, sizeof out);\n\tgoto out;\n\nappend:\n\tstrlcat(out, s, sizeof out);\n\nout:\n\tif (with_flags && (saved & KEYC_MASK_FLAGS) != 0) {\n\t\tstrlcat(out, \"[\", sizeof out);\n\t\tif (saved & KEYC_LITERAL)\n\t\t\tstrlcat(out, \"L\", sizeof out);\n\t\tif (saved & KEYC_KEYPAD)\n\t\t\tstrlcat(out, \"K\", sizeof out);\n\t\tif (saved & KEYC_CURSOR)\n\t\t\tstrlcat(out, \"C\", sizeof out);\n\t\tif (saved & KEYC_IMPLIED_META)\n\t\t\tstrlcat(out, \"I\", sizeof out);\n\t\tif (saved & KEYC_BUILD_MODIFIERS)\n\t\t\tstrlcat(out, \"B\", sizeof out);\n\t\tif (saved & KEYC_SENT)\n\t\t\tstrlcat(out, \"S\", sizeof out);\n\t\tstrlcat(out, \"]\", sizeof out);\n\t}\n\treturn (out);\n}\n"
        },
        {
          "name": "layout-custom.c",
          "type": "blob",
          "size": 8.1865234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic struct layout_cell\t*layout_find_bottomright(struct layout_cell *);\nstatic u_short\t\t\t layout_checksum(const char *);\nstatic int\t\t\t layout_append(struct layout_cell *, char *,\n\t\t\t\t     size_t);\nstatic struct layout_cell\t*layout_construct(struct layout_cell *,\n\t\t\t\t     const char **);\nstatic void\t\t\t layout_assign(struct window_pane **,\n\t\t\t\t     struct layout_cell *);\n\n/* Find the bottom-right cell. */\nstatic struct layout_cell *\nlayout_find_bottomright(struct layout_cell *lc)\n{\n\tif (lc->type == LAYOUT_WINDOWPANE)\n\t\treturn (lc);\n\tlc = TAILQ_LAST(&lc->cells, layout_cells);\n\treturn (layout_find_bottomright(lc));\n}\n\n/* Calculate layout checksum. */\nstatic u_short\nlayout_checksum(const char *layout)\n{\n\tu_short\tcsum;\n\n\tcsum = 0;\n\tfor (; *layout != '\\0'; layout++) {\n\t\tcsum = (csum >> 1) + ((csum & 1) << 15);\n\t\tcsum += *layout;\n\t}\n\treturn (csum);\n}\n\n/* Dump layout as a string. */\nchar *\nlayout_dump(struct layout_cell *root)\n{\n\tchar\tlayout[8192], *out;\n\n\t*layout = '\\0';\n\tif (layout_append(root, layout, sizeof layout) != 0)\n\t\treturn (NULL);\n\n\txasprintf(&out, \"%04hx,%s\", layout_checksum(layout), layout);\n\treturn (out);\n}\n\n/* Append information for a single cell. */\nstatic int\nlayout_append(struct layout_cell *lc, char *buf, size_t len)\n{\n\tstruct layout_cell     *lcchild;\n\tchar\t\t\ttmp[64];\n\tsize_t\t\t\ttmplen;\n\tconst char\t       *brackets = \"][\";\n\n\tif (len == 0)\n\t\treturn (-1);\n\n\tif (lc->wp != NULL) {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"%ux%u,%u,%u,%u\",\n\t\t    lc->sx, lc->sy, lc->xoff, lc->yoff, lc->wp->id);\n\t} else {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"%ux%u,%u,%u\",\n\t\t    lc->sx, lc->sy, lc->xoff, lc->yoff);\n\t}\n\tif (tmplen > (sizeof tmp) - 1)\n\t\treturn (-1);\n\tif (strlcat(buf, tmp, len) >= len)\n\t\treturn (-1);\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tbrackets = \"}{\";\n\t\t/* FALLTHROUGH */\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (strlcat(buf, &brackets[1], len) >= len)\n\t\t\treturn (-1);\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (layout_append(lcchild, buf, len) != 0)\n\t\t\t\treturn (-1);\n\t\t\tif (strlcat(buf, \",\", len) >= len)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tbuf[strlen(buf) - 1] = brackets[0];\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n/* Check layout sizes fit. */\nstatic int\nlayout_check(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t n = 0;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\tcase LAYOUT_LEFTRIGHT:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (lcchild->sy != lc->sy)\n\t\t\t\treturn (0);\n\t\t\tif (!layout_check(lcchild))\n\t\t\t\treturn (0);\n\t\t\tn += lcchild->sx + 1;\n\t\t}\n\t\tif (n - 1 != lc->sx)\n\t\t\treturn (0);\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (lcchild->sx != lc->sx)\n\t\t\t\treturn (0);\n\t\t\tif (!layout_check(lcchild))\n\t\t\t\treturn (0);\n\t\t\tn += lcchild->sy + 1;\n\t\t}\n\t\tif (n - 1 != lc->sy)\n\t\t\treturn (0);\n\t\tbreak;\n\t}\n\treturn (1);\n}\n\n/* Parse a layout string and arrange window as layout. */\nint\nlayout_parse(struct window *w, const char *layout, char **cause)\n{\n\tstruct layout_cell\t*lc, *lcchild;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t npanes, ncells, sx = 0, sy = 0;\n\tu_short\t\t\t csum;\n\n\t/* Check validity. */\n\tif (sscanf(layout, \"%hx,\", &csum) != 1) {\n\t\t*cause = xstrdup(\"invalid layout\");\n\t\treturn (-1);\n\t}\n\tlayout += 5;\n\tif (csum != layout_checksum(layout)) {\n\t\t*cause = xstrdup(\"invalid layout\");\n\t\treturn (-1);\n\t}\n\n\t/* Build the layout. */\n\tlc = layout_construct(NULL, &layout);\n\tif (lc == NULL) {\n\t\t*cause = xstrdup(\"invalid layout\");\n\t\treturn (-1);\n\t}\n\tif (*layout != '\\0') {\n\t\t*cause = xstrdup(\"invalid layout\");\n\t\tgoto fail;\n\t}\n\n\t/* Check this window will fit into the layout. */\n\tfor (;;) {\n\t\tnpanes = window_count_panes(w);\n\t\tncells = layout_count_cells(lc);\n\t\tif (npanes > ncells) {\n\t\t\txasprintf(cause, \"have %u panes but need %u\", npanes,\n\t\t\t    ncells);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (npanes == ncells)\n\t\t\tbreak;\n\n\t\t/* Fewer panes than cells - close the bottom right. */\n\t\tlcchild = layout_find_bottomright(lc);\n\t\tlayout_destroy_cell(w, lcchild, &lc);\n\t}\n\n\t/*\n\t * It appears older versions of tmux were able to generate layouts with\n\t * an incorrect top cell size - if it is larger than the top child then\n\t * correct that (if this is still wrong the check code will catch it).\n\t */\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\tcase LAYOUT_LEFTRIGHT:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tsy = lcchild->sy + 1;\n\t\t\tsx += lcchild->sx + 1;\n\t\t}\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tsx = lcchild->sx + 1;\n\t\t\tsy += lcchild->sy + 1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (lc->type != LAYOUT_WINDOWPANE && (lc->sx != sx || lc->sy != sy)) {\n\t\tlog_debug(\"fix layout %u,%u to %u,%u\", lc->sx, lc->sy, sx,sy);\n\t\tlayout_print_cell(lc, __func__, 0);\n\t\tlc->sx = sx - 1; lc->sy = sy - 1;\n\t}\n\n\t/* Check the new layout. */\n\tif (!layout_check(lc)) {\n\t\t*cause = xstrdup(\"size mismatch after applying layout\");\n\t\tgoto fail;\n\t}\n\n\t/* Resize to the layout size. */\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\n\t/* Destroy the old layout and swap to the new. */\n\tlayout_free_cell(w->layout_root);\n\tw->layout_root = lc;\n\n\t/* Assign the panes into the cells. */\n\twp = TAILQ_FIRST(&w->panes);\n\tlayout_assign(&wp, lc);\n\n\t/* Update pane offsets and sizes. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\trecalculate_sizes();\n\n\tlayout_print_cell(lc, __func__, 0);\n\n\tnotify_window(\"window-layout-changed\", w);\n\n\treturn (0);\n\nfail:\n\tlayout_free_cell(lc);\n\treturn (-1);\n}\n\n/* Assign panes into cells. */\nstatic void\nlayout_assign(struct window_pane **wp, struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\tlayout_make_leaf(lc, *wp);\n\t\t*wp = TAILQ_NEXT(*wp, entry);\n\t\treturn;\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tlayout_assign(wp, lcchild);\n\t\treturn;\n\t}\n}\n\n/* Construct a cell from all or part of a layout tree. */\nstatic struct layout_cell *\nlayout_construct(struct layout_cell *lcparent, const char **layout)\n{\n\tstruct layout_cell     *lc, *lcchild;\n\tu_int\t\t\tsx, sy, xoff, yoff;\n\tconst char\t       *saved;\n\n\tif (!isdigit((u_char) **layout))\n\t\treturn (NULL);\n\tif (sscanf(*layout, \"%ux%u,%u,%u\", &sx, &sy, &xoff, &yoff) != 4)\n\t\treturn (NULL);\n\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != 'x')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != ',')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != ',')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout == ',') {\n\t\tsaved = *layout;\n\t\t(*layout)++;\n\t\twhile (isdigit((u_char) **layout))\n\t\t\t(*layout)++;\n\t\tif (**layout == 'x')\n\t\t\t*layout = saved;\n\t}\n\n\tlc = layout_create_cell(lcparent);\n\tlc->sx = sx;\n\tlc->sy = sy;\n\tlc->xoff = xoff;\n\tlc->yoff = yoff;\n\n\tswitch (**layout) {\n\tcase ',':\n\tcase '}':\n\tcase ']':\n\tcase '\\0':\n\t\treturn (lc);\n\tcase '{':\n\t\tlc->type = LAYOUT_LEFTRIGHT;\n\t\tbreak;\n\tcase '[':\n\t\tlc->type = LAYOUT_TOPBOTTOM;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tdo {\n\t\t(*layout)++;\n\t\tlcchild = layout_construct(lc, layout);\n\t\tif (lcchild == NULL)\n\t\t\tgoto fail;\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcchild, entry);\n\t} while (**layout == ',');\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tif (**layout != '}')\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (**layout != ']')\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\t(*layout)++;\n\n\treturn (lc);\n\nfail:\n\tlayout_free_cell(lc);\n\treturn (NULL);\n}\n"
        },
        {
          "name": "layout-set.c",
          "type": "blob",
          "size": 17.4287109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set window layouts - predefined methods to arrange windows. These are\n * one-off and generate a layout tree.\n */\n\nstatic void\tlayout_set_even_h(struct window *);\nstatic void\tlayout_set_even_v(struct window *);\nstatic void\tlayout_set_main_h(struct window *);\nstatic void\tlayout_set_main_h_mirrored(struct window *);\nstatic void\tlayout_set_main_v(struct window *);\nstatic void\tlayout_set_main_v_mirrored(struct window *);\nstatic void\tlayout_set_tiled(struct window *);\n\nstatic const struct {\n\tconst char\t*name;\n\tvoid\t      \t(*arrange)(struct window *);\n} layout_sets[] = {\n\t{ \"even-horizontal\", layout_set_even_h },\n\t{ \"even-vertical\", layout_set_even_v },\n\t{ \"main-horizontal\", layout_set_main_h },\n\t{ \"main-horizontal-mirrored\", layout_set_main_h_mirrored },\n\t{ \"main-vertical\", layout_set_main_v },\n\t{ \"main-vertical-mirrored\", layout_set_main_v_mirrored },\n\t{ \"tiled\", layout_set_tiled },\n};\n\nint\nlayout_set_lookup(const char *name)\n{\n\tu_int\ti;\n\tint\tmatched = -1;\n\n\tfor (i = 0; i < nitems(layout_sets); i++) {\n\t\tif (strcmp(layout_sets[i].name, name) == 0)\n\t\t\treturn (i);\n\t}\n\tfor (i = 0; i < nitems(layout_sets); i++) {\n\t\tif (strncmp(layout_sets[i].name, name, strlen(name)) == 0) {\n\t\t\tif (matched != -1)\t/* ambiguous */\n\t\t\t\treturn (-1);\n\t\t\tmatched = i;\n\t\t}\n\t}\n\n\treturn (matched);\n}\n\nu_int\nlayout_set_select(struct window *w, u_int layout)\n{\n\tif (layout > nitems(layout_sets) - 1)\n\t\tlayout = nitems(layout_sets) - 1;\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nu_int\nlayout_set_next(struct window *w)\n{\n\tu_int\tlayout;\n\n\tif (w->lastlayout == -1)\n\t\tlayout = 0;\n\telse {\n\t\tlayout = w->lastlayout + 1;\n\t\tif (layout > nitems(layout_sets) - 1)\n\t\t\tlayout = 0;\n\t}\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nu_int\nlayout_set_previous(struct window *w)\n{\n\tu_int\tlayout;\n\n\tif (w->lastlayout == -1)\n\t\tlayout = nitems(layout_sets) - 1;\n\telse {\n\t\tlayout = w->lastlayout;\n\t\tif (layout == 0)\n\t\t\tlayout = nitems(layout_sets) - 1;\n\t\telse\n\t\t\tlayout--;\n\t}\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nstatic void\nlayout_set_even(struct window *w, enum layout_type type)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcnew;\n\tu_int\t\t\t n, sx, sy;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\n\t/* Free the old root and construct a new. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tif (type == LAYOUT_LEFTRIGHT) {\n\t\tsx = (n * (PANE_MINIMUM + 1)) - 1;\n\t\tif (sx < w->sx)\n\t\t\tsx = w->sx;\n\t\tsy = w->sy;\n\t} else {\n\t\tsy = (n * (PANE_MINIMUM + 1)) - 1;\n\t\tif (sy < w->sy)\n\t\t\tsy = w->sy;\n\t\tsx = w->sx;\n\t}\n\tlayout_set_size(lc, sx, sy, 0, 0);\n\tlayout_make_node(lc, type);\n\n\t/* Build new leaf cells. */\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tlcnew = layout_create_cell(lc);\n\t\tlayout_make_leaf(lcnew, wp);\n\t\tlcnew->sx = w->sx;\n\t\tlcnew->sy = w->sy;\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcnew, entry);\n\t}\n\n\t/* Spread out cells. */\n\tlayout_spread_cell(w, lc);\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n\nstatic void\nlayout_set_even_h(struct window *w)\n{\n\tlayout_set_even(w, LAYOUT_LEFTRIGHT);\n}\n\nstatic void\nlayout_set_even_v(struct window *w)\n{\n\tlayout_set_even(w, LAYOUT_TOPBOTTOM);\n}\n\nstatic void\nlayout_set_main_h(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lcother, *lcchild;\n\tu_int\t\t\t n, mainh, otherh, sx, sy;\n\tchar\t\t\t*cause;\n\tconst char\t\t*s;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* Find available height - take off one line for the border. */\n\tsy = w->sy - 1;\n\n\t/* Get the main pane height. */\n\ts = options_get_string(w->options, \"main-pane-height\");\n\tmainh = args_string_percentage(s, 0, sy, sy, &cause);\n\tif (cause != NULL) {\n\t\tmainh = 24;\n\t\tfree(cause);\n\t}\n\n\t/* Work out the other pane height. */\n\tif (mainh + PANE_MINIMUM >= sy) {\n\t\tif (sy <= PANE_MINIMUM + PANE_MINIMUM)\n\t\t\tmainh = PANE_MINIMUM;\n\t\telse\n\t\t\tmainh = sy - PANE_MINIMUM;\n\t\totherh = PANE_MINIMUM;\n\t} else {\n\t\ts = options_get_string(w->options, \"other-pane-height\");\n\t\totherh = args_string_percentage(s, 0, sy, sy, &cause);\n\t\tif (cause != NULL || otherh == 0) {\n\t\t\totherh = sy - mainh;\n\t\t\tfree(cause);\n\t\t} else if (otherh > sy || sy - otherh < mainh)\n\t\t\totherh = sy - mainh;\n\t\telse\n\t\t\tmainh = sy - otherh;\n\t}\n\n\t/* Work out what width is needed. */\n\tsx = (n * (PANE_MINIMUM + 1)) - 1;\n\tif (sx < w->sx)\n\t\tsx = w->sx;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, sx, mainh + otherh + 1, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, sx, mainh, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Create the other pane. */\n\tlcother = layout_create_cell(lc);\n\tlayout_set_size(lcother, sx, otherh, 0, 0);\n\tif (n == 1) {\n\t\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\t\tlayout_make_leaf(lcother, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\t} else {\n\t\tlayout_make_node(lcother, LAYOUT_LEFTRIGHT);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\n\t\t/* Add the remaining panes as children. */\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp == TAILQ_FIRST(&w->panes))\n\t\t\t\tcontinue;\n\t\t\tlcchild = layout_create_cell(lcother);\n\t\t\tlayout_set_size(lcchild, PANE_MINIMUM, otherh, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcother->cells, lcchild, entry);\n\t\t}\n\t\tlayout_spread_cell(w, lcother);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n\nstatic void\nlayout_set_main_h_mirrored(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lcother, *lcchild;\n\tu_int\t\t\t n, mainh, otherh, sx, sy;\n\tchar\t\t\t*cause;\n\tconst char\t\t*s;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* Find available height - take off one line for the border. */\n\tsy = w->sy - 1;\n\n\t/* Get the main pane height. */\n\ts = options_get_string(w->options, \"main-pane-height\");\n\tmainh = args_string_percentage(s, 0, sy, sy, &cause);\n\tif (cause != NULL) {\n\t\tmainh = 24;\n\t\tfree(cause);\n\t}\n\n\t/* Work out the other pane height. */\n\tif (mainh + PANE_MINIMUM >= sy) {\n\t\tif (sy <= PANE_MINIMUM + PANE_MINIMUM)\n\t\t\tmainh = PANE_MINIMUM;\n\t\telse\n\t\t\tmainh = sy - PANE_MINIMUM;\n\t\totherh = PANE_MINIMUM;\n\t} else {\n\t\ts = options_get_string(w->options, \"other-pane-height\");\n\t\totherh = args_string_percentage(s, 0, sy, sy, &cause);\n\t\tif (cause != NULL || otherh == 0) {\n\t\t\totherh = sy - mainh;\n\t\t\tfree(cause);\n\t\t} else if (otherh > sy || sy - otherh < mainh)\n\t\t\totherh = sy - mainh;\n\t\telse\n\t\t\tmainh = sy - otherh;\n\t}\n\n\t/* Work out what width is needed. */\n\tsx = (n * (PANE_MINIMUM + 1)) - 1;\n\tif (sx < w->sx)\n\t\tsx = w->sx;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, sx, mainh + otherh + 1, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Create the other pane. */\n\tlcother = layout_create_cell(lc);\n\tlayout_set_size(lcother, sx, otherh, 0, 0);\n\tif (n == 1) {\n\t\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\t\tlayout_make_leaf(lcother, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\t} else {\n\t\tlayout_make_node(lcother, LAYOUT_LEFTRIGHT);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\n\t\t/* Add the remaining panes as children. */\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp == TAILQ_FIRST(&w->panes))\n\t\t\t\tcontinue;\n\t\t\tlcchild = layout_create_cell(lcother);\n\t\t\tlayout_set_size(lcchild, PANE_MINIMUM, otherh, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcother->cells, lcchild, entry);\n\t\t}\n\t\tlayout_spread_cell(w, lcother);\n\t}\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, sx, mainh, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n\nstatic void\nlayout_set_main_v(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lcother, *lcchild;\n\tu_int\t\t\t n, mainw, otherw, sx, sy;\n\tchar\t\t\t*cause;\n\tconst char\t\t*s;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* Find available width - take off one line for the border. */\n\tsx = w->sx - 1;\n\n\t/* Get the main pane width. */\n\ts = options_get_string(w->options, \"main-pane-width\");\n\tmainw = args_string_percentage(s, 0, sx, sx, &cause);\n\tif (cause != NULL) {\n\t\tmainw = 80;\n\t\tfree(cause);\n\t}\n\n\t/* Work out the other pane width. */\n\tif (mainw + PANE_MINIMUM >= sx) {\n\t\tif (sx <= PANE_MINIMUM + PANE_MINIMUM)\n\t\t\tmainw = PANE_MINIMUM;\n\t\telse\n\t\t\tmainw = sx - PANE_MINIMUM;\n\t\totherw = PANE_MINIMUM;\n\t} else {\n\t\ts = options_get_string(w->options, \"other-pane-width\");\n\t\totherw = args_string_percentage(s, 0, sx, sx, &cause);\n\t\tif (cause != NULL || otherw == 0) {\n\t\t\totherw = sx - mainw;\n\t\t\tfree(cause);\n\t\t} else if (otherw > sx || sx - otherw < mainw)\n\t\t\totherw = sx - mainw;\n\t\telse\n\t\t\tmainw = sx - otherw;\n\t}\n\n\t/* Work out what height is needed. */\n\tsy = (n * (PANE_MINIMUM + 1)) - 1;\n\tif (sy < w->sy)\n\t\tsy = w->sy;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, mainw + otherw + 1, sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_LEFTRIGHT);\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, mainw, sy, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Create the other pane. */\n\tlcother = layout_create_cell(lc);\n\tlayout_set_size(lcother, otherw, sy, 0, 0);\n\tif (n == 1) {\n\t\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\t\tlayout_make_leaf(lcother, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\t} else {\n\t\tlayout_make_node(lcother, LAYOUT_TOPBOTTOM);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\n\t\t/* Add the remaining panes as children. */\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp == TAILQ_FIRST(&w->panes))\n\t\t\t\tcontinue;\n\t\t\tlcchild = layout_create_cell(lcother);\n\t\t\tlayout_set_size(lcchild, otherw, PANE_MINIMUM, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcother->cells, lcchild, entry);\n\t\t}\n\t\tlayout_spread_cell(w, lcother);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n\nstatic void\nlayout_set_main_v_mirrored(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lcother, *lcchild;\n\tu_int\t\t\t n, mainw, otherw, sx, sy;\n\tchar\t\t\t*cause;\n\tconst char\t\t*s;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* Find available width - take off one line for the border. */\n\tsx = w->sx - 1;\n\n\t/* Get the main pane width. */\n\ts = options_get_string(w->options, \"main-pane-width\");\n\tmainw = args_string_percentage(s, 0, sx, sx, &cause);\n\tif (cause != NULL) {\n\t\tmainw = 80;\n\t\tfree(cause);\n\t}\n\n\t/* Work out the other pane width. */\n\tif (mainw + PANE_MINIMUM >= sx) {\n\t\tif (sx <= PANE_MINIMUM + PANE_MINIMUM)\n\t\t\tmainw = PANE_MINIMUM;\n\t\telse\n\t\t\tmainw = sx - PANE_MINIMUM;\n\t\totherw = PANE_MINIMUM;\n\t} else {\n\t\ts = options_get_string(w->options, \"other-pane-width\");\n\t\totherw = args_string_percentage(s, 0, sx, sx, &cause);\n\t\tif (cause != NULL || otherw == 0) {\n\t\t\totherw = sx - mainw;\n\t\t\tfree(cause);\n\t\t} else if (otherw > sx || sx - otherw < mainw)\n\t\t\totherw = sx - mainw;\n\t\telse\n\t\t\tmainw = sx - otherw;\n\t}\n\n\t/* Work out what height is needed. */\n\tsy = (n * (PANE_MINIMUM + 1)) - 1;\n\tif (sy < w->sy)\n\t\tsy = w->sy;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, mainw + otherw + 1, sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_LEFTRIGHT);\n\n\t/* Create the other pane. */\n\tlcother = layout_create_cell(lc);\n\tlayout_set_size(lcother, otherw, sy, 0, 0);\n\tif (n == 1) {\n\t\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\t\tlayout_make_leaf(lcother, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\t} else {\n\t\tlayout_make_node(lcother, LAYOUT_TOPBOTTOM);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcother, entry);\n\n\t\t/* Add the remaining panes as children. */\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp == TAILQ_FIRST(&w->panes))\n\t\t\t\tcontinue;\n\t\t\tlcchild = layout_create_cell(lcother);\n\t\t\tlayout_set_size(lcchild, otherw, PANE_MINIMUM, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcother->cells, lcchild, entry);\n\t\t}\n\t\tlayout_spread_cell(w, lcother);\n\t}\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, mainw, sy, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n\nvoid\nlayout_set_tiled(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcrow, *lcchild;\n\tu_int\t\t\t n, width, height, used, sx, sy;\n\tu_int\t\t\t i, j, columns, rows;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\n\t/* How many rows and columns are wanted? */\n\trows = columns = 1;\n\twhile (rows * columns < n) {\n\t\trows++;\n\t\tif (rows * columns < n)\n\t\t\tcolumns++;\n\t}\n\n\t/* What width and height should they be? */\n\twidth = (w->sx - (columns - 1)) / columns;\n\tif (width < PANE_MINIMUM)\n\t\twidth = PANE_MINIMUM;\n\theight = (w->sy - (rows - 1)) / rows;\n\tif (height < PANE_MINIMUM)\n\t\theight = PANE_MINIMUM;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tsx = ((width + 1) * columns) - 1;\n\tif (sx < w->sx)\n\t\tsx = w->sx;\n\tsy = ((height + 1) * rows) - 1;\n\tif (sy < w->sy)\n\t\tsy = w->sy;\n\tlayout_set_size(lc, sx, sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Create a grid of the cells. */\n\twp = TAILQ_FIRST(&w->panes);\n\tfor (j = 0; j < rows; j++) {\n\t\t/* If this is the last cell, all done. */\n\t\tif (wp == NULL)\n\t\t\tbreak;\n\n\t\t/* Create the new row. */\n\t\tlcrow = layout_create_cell(lc);\n\t\tlayout_set_size(lcrow, w->sx, height, 0, 0);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcrow, entry);\n\n\t\t/* If only one column, just use the row directly. */\n\t\tif (n - (j * columns) == 1 || columns == 1) {\n\t\t\tlayout_make_leaf(lcrow, wp);\n\t\t\twp = TAILQ_NEXT(wp, entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Add in the columns. */\n\t\tlayout_make_node(lcrow, LAYOUT_LEFTRIGHT);\n\t\tfor (i = 0; i < columns; i++) {\n\t\t\t/* Create and add a pane cell. */\n\t\t\tlcchild = layout_create_cell(lcrow);\n\t\t\tlayout_set_size(lcchild, width, height, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcrow->cells, lcchild, entry);\n\n\t\t\t/* Move to the next cell. */\n\t\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Adjust the row and columns to fit the full width if\n\t\t * necessary.\n\t\t */\n\t\tif (i == columns)\n\t\t\ti--;\n\t\tused = ((i + 1) * (width + 1)) - 1;\n\t\tif (w->sx <= used)\n\t\t\tcontinue;\n\t\tlcchild = TAILQ_LAST(&lcrow->cells, layout_cells);\n\t\tlayout_resize_adjust(w, lcchild, LAYOUT_LEFTRIGHT,\n\t\t    w->sx - used);\n\t}\n\n\t/* Adjust the last row height to fit if necessary. */\n\tused = (rows * height) + rows - 1;\n\tif (w->sy > used) {\n\t\tlcrow = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(w, lcrow, LAYOUT_TOPBOTTOM,\n\t\t    w->sy - used);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\twindow_resize(w, lc->sx, lc->sy, -1, -1);\n\tnotify_window(\"window-layout-changed\", w);\n\tserver_redraw_window(w);\n}\n"
        },
        {
          "name": "layout.c",
          "type": "blob",
          "size": 29.2373046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2016 Stephen Kent <smkent@smkent.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * The window layout is a tree of cells each of which can be one of: a\n * left-right container for a list of cells, a top-bottom container for a list\n * of cells, or a container for a window pane.\n *\n * Each window has a pointer to the root of its layout tree (containing its\n * panes), every pane has a pointer back to the cell containing it, and each\n * cell a pointer to its parent cell.\n */\n\nstatic u_int\tlayout_resize_check(struct window *, struct layout_cell *,\n\t\t    enum layout_type);\nstatic int\tlayout_resize_pane_grow(struct window *, struct layout_cell *,\n\t\t    enum layout_type, int, int);\nstatic int\tlayout_resize_pane_shrink(struct window *, struct layout_cell *,\n\t\t    enum layout_type, int);\nstatic u_int\tlayout_new_pane_size(struct window *, u_int,\n\t\t    struct layout_cell *, enum layout_type, u_int, u_int,\n\t\t    u_int);\nstatic int\tlayout_set_size_check(struct window *, struct layout_cell *,\n\t\t    enum layout_type, int);\nstatic void\tlayout_resize_child_cells(struct window *,\n\t\t    struct layout_cell *);\n\nstruct layout_cell *\nlayout_create_cell(struct layout_cell *lcparent)\n{\n\tstruct layout_cell\t*lc;\n\n\tlc = xmalloc(sizeof *lc);\n\tlc->type = LAYOUT_WINDOWPANE;\n\tlc->parent = lcparent;\n\n\tTAILQ_INIT(&lc->cells);\n\n\tlc->sx = UINT_MAX;\n\tlc->sy = UINT_MAX;\n\n\tlc->xoff = UINT_MAX;\n\tlc->yoff = UINT_MAX;\n\n\tlc->wp = NULL;\n\n\treturn (lc);\n}\n\nvoid\nlayout_free_cell(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\twhile (!TAILQ_EMPTY(&lc->cells)) {\n\t\t\tlcchild = TAILQ_FIRST(&lc->cells);\n\t\t\tTAILQ_REMOVE(&lc->cells, lcchild, entry);\n\t\t\tlayout_free_cell(lcchild);\n\t\t}\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tif (lc->wp != NULL)\n\t\t\tlc->wp->layout_cell = NULL;\n\t\tbreak;\n\t}\n\n\tfree(lc);\n}\n\nvoid\nlayout_print_cell(struct layout_cell *lc, const char *hdr, u_int n)\n{\n\tstruct layout_cell\t*lcchild;\n\tconst char\t\t*type;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\ttype = \"LEFTRIGHT\";\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\ttype = \"TOPBOTTOM\";\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\ttype = \"WINDOWPANE\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\tlog_debug(\"%s:%*s%p type %s [parent %p] wp=%p [%u,%u %ux%u]\", hdr, n,\n\t    \" \", lc, type, lc->parent, lc->wp, lc->xoff, lc->yoff, lc->sx,\n\t    lc->sy);\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t    \tlayout_print_cell(lcchild, hdr, n + 1);\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\t}\n}\n\nstruct layout_cell *\nlayout_search_by_border(struct layout_cell *lc, u_int x, u_int y)\n{\n\tstruct layout_cell\t*lcchild, *last = NULL;\n\n\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\tif (x >= lcchild->xoff && x < lcchild->xoff + lcchild->sx &&\n\t\t    y >= lcchild->yoff && y < lcchild->yoff + lcchild->sy) {\n\t\t\t/* Inside the cell - recurse. */\n\t\t\treturn (layout_search_by_border(lcchild, x, y));\n\t\t}\n\n\t\tif (last == NULL) {\n\t\t\tlast = lcchild;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (lc->type) {\n\t\tcase LAYOUT_LEFTRIGHT:\n\t\t\tif (x < lcchild->xoff && x >= last->xoff + last->sx)\n\t\t\t\treturn (last);\n\t\t\tbreak;\n\t\tcase LAYOUT_TOPBOTTOM:\n\t\t\tif (y < lcchild->yoff && y >= last->yoff + last->sy)\n\t\t\t\treturn (last);\n\t\t\tbreak;\n\t\tcase LAYOUT_WINDOWPANE:\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = lcchild;\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nlayout_set_size(struct layout_cell *lc, u_int sx, u_int sy, u_int xoff,\n    u_int yoff)\n{\n\tlc->sx = sx;\n\tlc->sy = sy;\n\n\tlc->xoff = xoff;\n\tlc->yoff = yoff;\n}\n\nvoid\nlayout_make_leaf(struct layout_cell *lc, struct window_pane *wp)\n{\n\tlc->type = LAYOUT_WINDOWPANE;\n\n\tTAILQ_INIT(&lc->cells);\n\n\twp->layout_cell = lc;\n\tlc->wp = wp;\n}\n\nvoid\nlayout_make_node(struct layout_cell *lc, enum layout_type type)\n{\n\tif (type == LAYOUT_WINDOWPANE)\n\t\tfatalx(\"bad layout type\");\n\tlc->type = type;\n\n\tTAILQ_INIT(&lc->cells);\n\n\tif (lc->wp != NULL)\n\t\tlc->wp->layout_cell = NULL;\n\tlc->wp = NULL;\n}\n\n/* Fix cell offsets for a child cell. */\nstatic void\nlayout_fix_offsets1(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t xoff, yoff;\n\n\tif (lc->type == LAYOUT_LEFTRIGHT) {\n\t\txoff = lc->xoff;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tlcchild->xoff = xoff;\n\t\t\tlcchild->yoff = lc->yoff;\n\t\t\tif (lcchild->type != LAYOUT_WINDOWPANE)\n\t\t\t\tlayout_fix_offsets1(lcchild);\n\t\t\txoff += lcchild->sx + 1;\n\t\t}\n\t} else {\n\t\tyoff = lc->yoff;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tlcchild->xoff = lc->xoff;\n\t\t\tlcchild->yoff = yoff;\n\t\t\tif (lcchild->type != LAYOUT_WINDOWPANE)\n\t\t\t\tlayout_fix_offsets1(lcchild);\n\t\t\tyoff += lcchild->sy + 1;\n\t\t}\n\t}\n}\n\n/* Update cell offsets based on their sizes. */\nvoid\nlayout_fix_offsets(struct window *w)\n{\n\tstruct layout_cell      *lc = w->layout_root;\n\n\tlc->xoff = 0;\n\tlc->yoff = 0;\n\n\tlayout_fix_offsets1(lc);\n}\n\n/* Is this a top cell? */\nstatic int\nlayout_cell_is_top(struct window *w, struct layout_cell *lc)\n{\n\tstruct layout_cell\t*next;\n\n\twhile (lc != w->layout_root) {\n\t\tnext = lc->parent;\n\t\tif (next->type == LAYOUT_TOPBOTTOM &&\n\t\t    lc != TAILQ_FIRST(&next->cells))\n\t\t\treturn (0);\n\t\tlc = next;\n\t}\n\treturn (1);\n}\n\n/* Is this a bottom cell? */\nstatic int\nlayout_cell_is_bottom(struct window *w, struct layout_cell *lc)\n{\n\tstruct layout_cell\t*next;\n\n\twhile (lc != w->layout_root) {\n\t\tnext = lc->parent;\n\t\tif (next->type == LAYOUT_TOPBOTTOM &&\n\t\t    lc != TAILQ_LAST(&next->cells, layout_cells))\n\t\t\treturn (0);\n\t\tlc = next;\n\t}\n\treturn (1);\n}\n\n/*\n * Returns 1 if we need to add an extra line for the pane status line. This is\n * the case for the most upper or lower panes only.\n */\nstatic int\nlayout_add_horizontal_border(struct window *w, struct layout_cell *lc,\n    int status)\n{\n\tif (status == PANE_STATUS_TOP)\n\t\treturn (layout_cell_is_top(w, lc));\n\tif (status == PANE_STATUS_BOTTOM)\n\t\treturn (layout_cell_is_bottom(w, lc));\n\treturn (0);\n}\n\n/* Update pane offsets and sizes based on their cells. */\nvoid\nlayout_fix_panes(struct window *w, struct window_pane *skip)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc;\n\tint\t\t\t status, scrollbars, sb_pos, sb_w, sb_pad;\n\tu_int\t\t\t sx, sy;\n\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tscrollbars = options_get_number(w->options, \"pane-scrollbars\");\n\tsb_pos = options_get_number(w->options, \"pane-scrollbars-position\");\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif ((lc = wp->layout_cell) == NULL || wp == skip)\n\t\t\tcontinue;\n\n\t\twp->xoff = lc->xoff;\n\t\twp->yoff = lc->yoff;\n\t\tsx = lc->sx;\n\t\tsy = lc->sy;\n\n\t\tif (layout_add_horizontal_border(w, lc, status)) {\n\t\t\tif (status == PANE_STATUS_TOP)\n\t\t\t\twp->yoff++;\n\t\t\tsy--;\n\t\t}\n\n\t\tif (window_pane_show_scrollbar(wp, scrollbars)) {\n\t\t\tsb_w = wp->scrollbar_style.width;\n\t\t\tsb_pad = wp->scrollbar_style.pad;\n\t\t\tif (sb_w < 1)\n\t\t\t\tsb_w = 1;\n\t\t\tif (sb_pad < 0)\n\t\t\t\tsb_pad = 0;\n\t\t\tif (sb_pos == PANE_SCROLLBARS_LEFT) {\n\t\t\t\tif ((int)sx - sb_w < PANE_MINIMUM) {\n\t\t\t\t\twp->xoff = wp->xoff +\n\t\t\t\t\t    (int)sx - PANE_MINIMUM;\n\t\t\t\t\tsx = PANE_MINIMUM;\n\t\t\t\t} else {\n\t\t\t\t\tsx = sx - sb_w - sb_pad;\n\t\t\t\t\twp->xoff = wp->xoff + sb_w + sb_pad;\n\t\t\t\t}\n\t\t\t} else /* sb_pos == PANE_SCROLLBARS_RIGHT */\n\t\t\t\tif ((int)sx - sb_w - sb_pad < PANE_MINIMUM)\n\t\t\t\t\tsx = PANE_MINIMUM;\n\t\t\t\telse\n\t\t\t\t\tsx = sx - sb_w - sb_pad;\n\t\t\twp->flags |= PANE_REDRAWSCROLLBAR;\n\t\t}\n\n\t\twindow_pane_resize(wp, sx, sy);\n\t}\n}\n\n/* Count the number of available cells in a layout. */\nu_int\nlayout_count_cells(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t count;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\treturn (1);\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tcount = 0;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tcount += layout_count_cells(lcchild);\n\t\treturn (count);\n\tdefault:\n\t\tfatalx(\"bad layout type\");\n\t}\n}\n\n/* Calculate how much size is available to be removed from a cell. */\nstatic u_int\nlayout_resize_check(struct window *w, struct layout_cell *lc,\n    enum layout_type type)\n{\n\tstruct layout_cell\t*lcchild;\n\tstruct style\t\t*sb_style = &w->active->scrollbar_style;\n\tu_int\t\t\t available, minimum;\n\tint\t\t\t status, scrollbars;\n\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tscrollbars = options_get_number(w->options, \"pane-scrollbars\");\n\n\tif (lc->type == LAYOUT_WINDOWPANE) {\n\t\t/* Space available in this cell only. */\n\t\tif (type == LAYOUT_LEFTRIGHT) {\n\t\t\tavailable = lc->sx;\n\t\t\tif (scrollbars)\n\t\t\t\tminimum = PANE_MINIMUM + sb_style->width +\n\t\t\t\t    sb_style->pad;\n\t\t\telse\n\t\t\t\tminimum = PANE_MINIMUM;\n\t\t} else {\n\t\t\tavailable = lc->sy;\n\t\t\tif (layout_add_horizontal_border(w, lc, status))\n\t\t\t\tminimum = PANE_MINIMUM + 1;\n\t\t\telse\n\t\t\t\tminimum = PANE_MINIMUM;\n\t\t}\n\t\tif (available > minimum)\n\t\t\tavailable -= minimum;\n\t\telse\n\t\t\tavailable = 0;\n\t} else if (lc->type == type) {\n\t\t/* Same type: total of available space in all child cells. */\n\t\tavailable = 0;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tavailable += layout_resize_check(w, lcchild, type);\n\t} else {\n\t\t/* Different type: minimum of available space in child cells. */\n\t\tminimum = UINT_MAX;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tavailable = layout_resize_check(w, lcchild, type);\n\t\t\tif (available < minimum)\n\t\t\t\tminimum = available;\n\t\t}\n\t\tavailable = minimum;\n\t}\n\n\treturn (available);\n}\n\n/*\n * Adjust cell size evenly, including altering its children. This function\n * expects the change to have already been bounded to the space available.\n */\nvoid\nlayout_resize_adjust(struct window *w, struct layout_cell *lc,\n    enum layout_type type, int change)\n{\n\tstruct layout_cell\t*lcchild;\n\n\t/* Adjust the cell size. */\n\tif (type == LAYOUT_LEFTRIGHT)\n\t\tlc->sx += change;\n\telse\n\t\tlc->sy += change;\n\n\t/* If this is a leaf cell, that is all that is necessary. */\n\tif (type == LAYOUT_WINDOWPANE)\n\t\treturn;\n\n\t/* Child cell runs in a different direction. */\n\tif (lc->type != type) {\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tlayout_resize_adjust(w, lcchild, type, change);\n\t\treturn;\n\t}\n\n\t/*\n\t * Child cell runs in the same direction. Adjust each child equally\n\t * until no further change is possible.\n\t */\n\twhile (change != 0) {\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (change == 0)\n\t\t\t\tbreak;\n\t\t\tif (change > 0) {\n\t\t\t\tlayout_resize_adjust(w, lcchild, type, 1);\n\t\t\t\tchange--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (layout_resize_check(w, lcchild, type) > 0) {\n\t\t\t\tlayout_resize_adjust(w, lcchild, type, -1);\n\t\t\t\tchange++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Destroy a cell and redistribute the space. */\nvoid\nlayout_destroy_cell(struct window *w, struct layout_cell *lc,\n    struct layout_cell **lcroot)\n{\n\tstruct layout_cell     *lcother, *lcparent;\n\n\t/*\n\t * If no parent, this is the last pane so window close is imminent and\n\t * there is no need to resize anything.\n\t */\n\tlcparent = lc->parent;\n\tif (lcparent == NULL) {\n\t\tlayout_free_cell(lc);\n\t\t*lcroot = NULL;\n\t\treturn;\n\t}\n\n\t/* Merge the space into the previous or next cell. */\n\tif (lc == TAILQ_FIRST(&lcparent->cells))\n\t\tlcother = TAILQ_NEXT(lc, entry);\n\telse\n\t\tlcother = TAILQ_PREV(lc, layout_cells, entry);\n\tif (lcother != NULL && lcparent->type == LAYOUT_LEFTRIGHT)\n\t\tlayout_resize_adjust(w, lcother, lcparent->type, lc->sx + 1);\n\telse if (lcother != NULL)\n\t\tlayout_resize_adjust(w, lcother, lcparent->type, lc->sy + 1);\n\n\t/* Remove this from the parent's list. */\n\tTAILQ_REMOVE(&lcparent->cells, lc, entry);\n\tlayout_free_cell(lc);\n\n\t/*\n\t * If the parent now has one cell, remove the parent from the tree and\n\t * replace it by that cell.\n\t */\n\tlc = TAILQ_FIRST(&lcparent->cells);\n\tif (TAILQ_NEXT(lc, entry) == NULL) {\n\t\tTAILQ_REMOVE(&lcparent->cells, lc, entry);\n\n\t\tlc->parent = lcparent->parent;\n\t\tif (lc->parent == NULL) {\n\t\t\tlc->xoff = 0; lc->yoff = 0;\n\t\t\t*lcroot = lc;\n\t\t} else\n\t\t\tTAILQ_REPLACE(&lc->parent->cells, lcparent, lc, entry);\n\n\t\tlayout_free_cell(lcparent);\n\t}\n}\n\nvoid\nlayout_init(struct window *w, struct window_pane *wp)\n{\n\tstruct layout_cell\t*lc;\n\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, w->sx, w->sy, 0, 0);\n\tlayout_make_leaf(lc, wp);\n\tlayout_fix_panes(w, NULL);\n}\n\nvoid\nlayout_free(struct window *w)\n{\n\tlayout_free_cell(w->layout_root);\n}\n\n/* Resize the entire layout after window resize. */\nvoid\nlayout_resize(struct window *w, u_int sx, u_int sy)\n{\n\tstruct layout_cell\t*lc = w->layout_root;\n\tint\t\t\t xlimit, ylimit, xchange, ychange;\n\n\t/*\n\t * Adjust horizontally. Do not attempt to reduce the layout lower than\n\t * the minimum (more than the amount returned by layout_resize_check).\n\t *\n\t * This can mean that the window size is smaller than the total layout\n\t * size: redrawing this is handled at a higher level, but it does leave\n\t * a problem with growing the window size here: if the current size is\n\t * < the minimum, growing proportionately by adding to each pane is\n\t * wrong as it would keep the layout size larger than the window size.\n\t * Instead, spread the difference between the minimum and the new size\n\t * out proportionately - this should leave the layout fitting the new\n\t * window size.\n\t */\n\txchange = sx - lc->sx;\n\txlimit = layout_resize_check(w, lc, LAYOUT_LEFTRIGHT);\n\tif (xchange < 0 && xchange < -xlimit)\n\t\txchange = -xlimit;\n\tif (xlimit == 0) {\n\t\tif (sx <= lc->sx)\t/* lc->sx is minimum possible */\n\t\t\txchange = 0;\n\t\telse\n\t\t\txchange = sx - lc->sx;\n\t}\n\tif (xchange != 0)\n\t\tlayout_resize_adjust(w, lc, LAYOUT_LEFTRIGHT, xchange);\n\n\t/* Adjust vertically in a similar fashion. */\n\tychange = sy - lc->sy;\n\tylimit = layout_resize_check(w, lc, LAYOUT_TOPBOTTOM);\n\tif (ychange < 0 && ychange < -ylimit)\n\t\tychange = -ylimit;\n\tif (ylimit == 0) {\n\t\tif (sy <= lc->sy)\t/* lc->sy is minimum possible */\n\t\t\tychange = 0;\n\t\telse\n\t\t\tychange = sy - lc->sy;\n\t}\n\tif (ychange != 0)\n\t\tlayout_resize_adjust(w, lc, LAYOUT_TOPBOTTOM, ychange);\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n}\n\n/* Resize a pane to an absolute size. */\nvoid\nlayout_resize_pane_to(struct window_pane *wp, enum layout_type type,\n    u_int new_size)\n{\n\tstruct layout_cell     *lc, *lcparent;\n\tint\t\t\tchange, size;\n\n\tlc = wp->layout_cell;\n\n\t/* Find next parent of the same type. */\n\tlcparent = lc->parent;\n\twhile (lcparent != NULL && lcparent->type != type) {\n\t\tlc = lcparent;\n\t\tlcparent = lc->parent;\n\t}\n\tif (lcparent == NULL)\n\t\treturn;\n\n\t/* Work out the size adjustment. */\n\tif (type == LAYOUT_LEFTRIGHT)\n\t\tsize = lc->sx;\n\telse\n\t\tsize = lc->sy;\n\tif (lc == TAILQ_LAST(&lcparent->cells, layout_cells))\n\t\tchange = size - new_size;\n\telse\n\t\tchange = new_size - size;\n\n\t/* Resize the pane. */\n\tlayout_resize_pane(wp, type, change, 1);\n}\n\nvoid\nlayout_resize_layout(struct window *w, struct layout_cell *lc,\n    enum layout_type type, int change, int opposite)\n{\n\tint\tneeded, size;\n\n\t/* Grow or shrink the cell. */\n\tneeded = change;\n\twhile (needed != 0) {\n\t\tif (change > 0) {\n\t\t\tsize = layout_resize_pane_grow(w, lc, type, needed,\n\t\t\t    opposite);\n\t\t\tneeded -= size;\n\t\t} else {\n\t\t\tsize = layout_resize_pane_shrink(w, lc, type, needed);\n\t\t\tneeded += size;\n\t\t}\n\n\t\tif (size == 0)\t/* no more change possible */\n\t\t\tbreak;\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(w);\n\tlayout_fix_panes(w, NULL);\n\tnotify_window(\"window-layout-changed\", w);\n}\n\n/* Resize a single pane within the layout. */\nvoid\nlayout_resize_pane(struct window_pane *wp, enum layout_type type, int change,\n    int opposite)\n{\n\tstruct layout_cell\t*lc, *lcparent;\n\n\tlc = wp->layout_cell;\n\n\t/* Find next parent of the same type. */\n\tlcparent = lc->parent;\n\twhile (lcparent != NULL && lcparent->type != type) {\n\t\tlc = lcparent;\n\t\tlcparent = lc->parent;\n\t}\n\tif (lcparent == NULL)\n\t\treturn;\n\n\t/* If this is the last cell, move back one. */\n\tif (lc == TAILQ_LAST(&lcparent->cells, layout_cells))\n\t\tlc = TAILQ_PREV(lc, layout_cells, entry);\n\n\tlayout_resize_layout(wp->window, lc, type, change, opposite);\n}\n\n/* Helper function to grow pane. */\nstatic int\nlayout_resize_pane_grow(struct window *w, struct layout_cell *lc,\n    enum layout_type type, int needed, int opposite)\n{\n\tstruct layout_cell\t*lcadd, *lcremove;\n\tu_int\t\t\t size = 0;\n\n\t/* Growing. Always add to the current cell. */\n\tlcadd = lc;\n\n\t/* Look towards the tail for a suitable cell for reduction. */\n\tlcremove = TAILQ_NEXT(lc, entry);\n\twhile (lcremove != NULL) {\n\t\tsize = layout_resize_check(w, lcremove, type);\n\t\tif (size > 0)\n\t\t\tbreak;\n\t\tlcremove = TAILQ_NEXT(lcremove, entry);\n\t}\n\n\t/* If none found, look towards the head. */\n\tif (opposite && lcremove == NULL) {\n\t\tlcremove = TAILQ_PREV(lc, layout_cells, entry);\n\t\twhile (lcremove != NULL) {\n\t\t\tsize = layout_resize_check(w, lcremove, type);\n\t\t\tif (size > 0)\n\t\t\t\tbreak;\n\t\t\tlcremove = TAILQ_PREV(lcremove, layout_cells, entry);\n\t\t}\n\t}\n\tif (lcremove == NULL)\n\t\treturn (0);\n\n\t/* Change the cells. */\n\tif (size > (u_int) needed)\n\t\tsize = needed;\n\tlayout_resize_adjust(w, lcadd, type, size);\n\tlayout_resize_adjust(w, lcremove, type, -size);\n\treturn (size);\n}\n\n/* Helper function to shrink pane. */\nstatic int\nlayout_resize_pane_shrink(struct window *w, struct layout_cell *lc,\n    enum layout_type type, int needed)\n{\n\tstruct layout_cell\t*lcadd, *lcremove;\n\tu_int\t\t\t size;\n\n\t/* Shrinking. Find cell to remove from by walking towards head. */\n\tlcremove = lc;\n\tdo {\n\t\tsize = layout_resize_check(w, lcremove, type);\n\t\tif (size != 0)\n\t\t\tbreak;\n\t\tlcremove = TAILQ_PREV(lcremove, layout_cells, entry);\n\t} while (lcremove != NULL);\n\tif (lcremove == NULL)\n\t\treturn (0);\n\n\t/* And add onto the next cell (from the original cell). */\n\tlcadd = TAILQ_NEXT(lc, entry);\n\tif (lcadd == NULL)\n\t\treturn (0);\n\n\t/* Change the cells. */\n\tif (size > (u_int) -needed)\n\t\tsize = -needed;\n\tlayout_resize_adjust(w, lcadd, type, size);\n\tlayout_resize_adjust(w, lcremove, type, -size);\n\treturn (size);\n}\n\n/* Assign window pane to newly split cell. */\nvoid\nlayout_assign_pane(struct layout_cell *lc, struct window_pane *wp,\n    int do_not_resize)\n{\n\tlayout_make_leaf(lc, wp);\n\tif (do_not_resize)\n\t\tlayout_fix_panes(wp->window, wp);\n\telse\n\t\tlayout_fix_panes(wp->window, NULL);\n}\n\n/* Calculate the new pane size for resized parent. */\nstatic u_int\nlayout_new_pane_size(struct window *w, u_int previous, struct layout_cell *lc,\n    enum layout_type type, u_int size, u_int count_left, u_int size_left)\n{\n\tu_int\tnew_size, min, max, available;\n\n\t/* If this is the last cell, it can take all of the remaining size. */\n\tif (count_left == 1)\n\t\treturn (size_left);\n\n\t/* How much is available in this parent? */\n\tavailable = layout_resize_check(w, lc, type);\n\n\t/*\n\t * Work out the minimum size of this cell and the new size\n\t * proportionate to the previous size.\n\t */\n\tmin = (PANE_MINIMUM + 1) * (count_left - 1);\n\tif (type == LAYOUT_LEFTRIGHT) {\n\t\tif (lc->sx - available > min)\n\t\t\tmin = lc->sx - available;\n\t\tnew_size = (lc->sx * size) / previous;\n\t} else {\n\t\tif (lc->sy - available > min)\n\t\t\tmin = lc->sy - available;\n\t\tnew_size = (lc->sy * size) / previous;\n\t}\n\n\t/* Check against the maximum and minimum size. */\n\tmax = size_left - min;\n\tif (new_size > max)\n\t\tnew_size = max;\n\tif (new_size < PANE_MINIMUM)\n\t\tnew_size = PANE_MINIMUM;\n\treturn (new_size);\n}\n\n/* Check if the cell and all its children can be resized to a specific size. */\nstatic int\nlayout_set_size_check(struct window *w, struct layout_cell *lc,\n    enum layout_type type, int size)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t new_size, available, previous, count, idx;\n\n\t/* Cells with no children must just be bigger than minimum. */\n\tif (lc->type == LAYOUT_WINDOWPANE)\n\t\treturn (size >= PANE_MINIMUM);\n\tavailable = size;\n\n\t/* Count number of children. */\n\tcount = 0;\n\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\tcount++;\n\n\t/* Check new size will work for each child. */\n\tif (lc->type == type) {\n\t\tif (available < (count * 2) - 1)\n\t\t\treturn (0);\n\n\t\tif (type == LAYOUT_LEFTRIGHT)\n\t\t\tprevious = lc->sx;\n\t\telse\n\t\t\tprevious = lc->sy;\n\n\t\tidx = 0;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tnew_size = layout_new_pane_size(w, previous, lcchild,\n\t\t\t    type, size, count - idx, available);\n\t\t\tif (idx == count - 1) {\n\t\t\t\tif (new_size > available)\n\t\t\t\t\treturn (0);\n\t\t\t\tavailable -= new_size;\n\t\t\t} else {\n\t\t\t\tif (new_size + 1 > available)\n\t\t\t\t\treturn (0);\n\t\t\t\tavailable -= new_size + 1;\n\t\t\t}\n\t\t\tif (!layout_set_size_check(w, lcchild, type, new_size))\n\t\t\t\treturn (0);\n\t\t\tidx++;\n\t\t}\n\t} else {\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (lcchild->type == LAYOUT_WINDOWPANE)\n\t\t\t\tcontinue;\n\t\t\tif (!layout_set_size_check(w, lcchild, type, size))\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n/* Resize all child cells to fit within the current cell. */\nstatic void\nlayout_resize_child_cells(struct window *w, struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t previous, available, count, idx;\n\n\tif (lc->type == LAYOUT_WINDOWPANE)\n\t\treturn;\n\n\t/* What is the current size used? */\n\tcount = 0;\n\tprevious = 0;\n\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\tcount++;\n\t\tif (lc->type == LAYOUT_LEFTRIGHT)\n\t\t\tprevious += lcchild->sx;\n\t\telse if (lc->type == LAYOUT_TOPBOTTOM)\n\t\t\tprevious += lcchild->sy;\n\t}\n\tprevious += (count - 1);\n\n\t/* And how much is available? */\n\tavailable = 0;\n\tif (lc->type == LAYOUT_LEFTRIGHT)\n\t\tavailable = lc->sx;\n\telse if (lc->type == LAYOUT_TOPBOTTOM)\n\t\tavailable = lc->sy;\n\n\t/* Resize children into the new size. */\n\tidx = 0;\n\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\tif (lc->type == LAYOUT_TOPBOTTOM) {\n\t\t\tlcchild->sx = lc->sx;\n\t\t\tlcchild->xoff = lc->xoff;\n\t\t} else {\n\t\t\tlcchild->sx = layout_new_pane_size(w, previous, lcchild,\n\t\t\t    lc->type, lc->sx, count - idx, available);\n\t\t\tavailable -= (lcchild->sx + 1);\n\t\t}\n\t\tif (lc->type == LAYOUT_LEFTRIGHT)\n\t\t\tlcchild->sy = lc->sy;\n\t\telse {\n\t\t\tlcchild->sy = layout_new_pane_size(w, previous, lcchild,\n\t\t\t    lc->type, lc->sy, count - idx, available);\n\t\t\tavailable -= (lcchild->sy + 1);\n\t\t}\n\t\tlayout_resize_child_cells(w, lcchild);\n\t\tidx++;\n\t}\n}\n\n/*\n * Split a pane into two. size is a hint, or -1 for default half/half\n * split. This must be followed by layout_assign_pane before much else happens!\n */\nstruct layout_cell *\nlayout_split_pane(struct window_pane *wp, enum layout_type type, int size,\n    int flags)\n{\n\tstruct layout_cell\t*lc, *lcparent, *lcnew, *lc1, *lc2;\n\tstruct style\t\t*sb_style = &wp->scrollbar_style;\n\tu_int\t\t\t sx, sy, xoff, yoff, size1, size2, minimum;\n\tu_int\t\t\t new_size, saved_size, resize_first = 0;\n\tint\t\t\t full_size = (flags & SPAWN_FULLSIZE), status;\n\tint\t\t\t scrollbars;\n\n\t/*\n\t * If full_size is specified, add a new cell at the top of the window\n\t * layout. Otherwise, split the cell for the current pane.\n\t */\n\tif (full_size)\n\t\tlc = wp->window->layout_root;\n\telse\n\t\tlc = wp->layout_cell;\n\tstatus = options_get_number(wp->window->options, \"pane-border-status\");\n\tscrollbars = options_get_number(wp->window->options, \"pane-scrollbars\");\n\n\t/* Copy the old cell size. */\n\tsx = lc->sx;\n\tsy = lc->sy;\n\txoff = lc->xoff;\n\tyoff = lc->yoff;\n\n\t/* Check there is enough space for the two new panes. */\n\tswitch (type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tif (scrollbars) {\n\t\t\tminimum = PANE_MINIMUM * 2 + sb_style->width +\n\t\t\t    sb_style->pad;\n\t\t} else\n\t\t\tminimum = PANE_MINIMUM * 2 + 1;\n\t\tif (sx < minimum)\n\t\t\treturn (NULL);\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (layout_add_horizontal_border(wp->window, lc, status))\n\t\t\tminimum = PANE_MINIMUM * 2 + 2;\n\t\telse\n\t\t\tminimum = PANE_MINIMUM * 2 + 1;\n\t\tif (sy < minimum)\n\t\t\treturn (NULL);\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"bad layout type\");\n\t}\n\n\t/*\n\t * Calculate new cell sizes. size is the target size or -1 for middle\n\t * split, size1 is the size of the top/left and size2 the bottom/right.\n\t */\n\tif (type == LAYOUT_LEFTRIGHT)\n\t\tsaved_size = sx;\n\telse\n\t\tsaved_size = sy;\n\tif (size < 0)\n\t\tsize2 = ((saved_size + 1) / 2) - 1;\n\telse if (flags & SPAWN_BEFORE)\n\t\tsize2 = saved_size - size - 1;\n\telse\n\t\tsize2 = size;\n\tif (size2 < PANE_MINIMUM)\n\t\tsize2 = PANE_MINIMUM;\n\telse if (size2 > saved_size - 2)\n\t\tsize2 = saved_size - 2;\n\tsize1 = saved_size - 1 - size2;\n\n\t/* Which size are we using? */\n\tif (flags & SPAWN_BEFORE)\n\t\tnew_size = size2;\n\telse\n\t\tnew_size = size1;\n\n\t/* Confirm there is enough space for full size pane. */\n\tif (full_size && !layout_set_size_check(wp->window, lc, type, new_size))\n\t\treturn (NULL);\n\n\tif (lc->parent != NULL && lc->parent->type == type) {\n\t\t/*\n\t\t * If the parent exists and is of the same type as the split,\n\t\t * create a new cell and insert it after this one.\n\t\t */\n\t\tlcparent = lc->parent;\n\t\tlcnew = layout_create_cell(lcparent);\n\t\tif (flags & SPAWN_BEFORE)\n\t\t\tTAILQ_INSERT_BEFORE(lc, lcnew, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_AFTER(&lcparent->cells, lc, lcnew, entry);\n\t} else if (full_size && lc->parent == NULL && lc->type == type) {\n\t\t/*\n\t\t * If the new full size pane is the same type as the root\n\t\t * split, insert the new pane under the existing root cell\n\t\t * instead of creating a new root cell. The existing layout\n\t\t * must be resized before inserting the new cell.\n\t\t */\n\t\tif (lc->type == LAYOUT_LEFTRIGHT) {\n\t\t\tlc->sx = new_size;\n\t\t\tlayout_resize_child_cells(wp->window, lc);\n\t\t\tlc->sx = saved_size;\n\t\t} else if (lc->type == LAYOUT_TOPBOTTOM) {\n\t\t\tlc->sy = new_size;\n\t\t\tlayout_resize_child_cells(wp->window, lc);\n\t\t\tlc->sy = saved_size;\n\t\t}\n\t\tresize_first = 1;\n\n\t\t/* Create the new cell. */\n\t\tlcnew = layout_create_cell(lc);\n\t\tsize = saved_size - 1 - new_size;\n\t\tif (lc->type == LAYOUT_LEFTRIGHT)\n\t\t\tlayout_set_size(lcnew, size, sy, 0, 0);\n\t\telse if (lc->type == LAYOUT_TOPBOTTOM)\n\t\t\tlayout_set_size(lcnew, sx, size, 0, 0);\n\t\tif (flags & SPAWN_BEFORE)\n\t\t\tTAILQ_INSERT_HEAD(&lc->cells, lcnew, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_TAIL(&lc->cells, lcnew, entry);\n\t} else {\n\t\t/*\n\t\t * Otherwise create a new parent and insert it.\n\t\t */\n\n\t\t/* Create and insert the replacement parent. */\n\t\tlcparent = layout_create_cell(lc->parent);\n\t\tlayout_make_node(lcparent, type);\n\t\tlayout_set_size(lcparent, sx, sy, xoff, yoff);\n\t\tif (lc->parent == NULL)\n\t\t\twp->window->layout_root = lcparent;\n\t\telse\n\t\t\tTAILQ_REPLACE(&lc->parent->cells, lc, lcparent, entry);\n\n\t\t/* Insert the old cell. */\n\t\tlc->parent = lcparent;\n\t\tTAILQ_INSERT_HEAD(&lcparent->cells, lc, entry);\n\n\t\t/* Create the new child cell. */\n\t\tlcnew = layout_create_cell(lcparent);\n\t\tif (flags & SPAWN_BEFORE)\n\t\t\tTAILQ_INSERT_HEAD(&lcparent->cells, lcnew, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_TAIL(&lcparent->cells, lcnew, entry);\n\t}\n\tif (flags & SPAWN_BEFORE) {\n\t\tlc1 = lcnew;\n\t\tlc2 = lc;\n\t} else {\n\t\tlc1 = lc;\n\t\tlc2 = lcnew;\n\t}\n\n\t/*\n\t * Set new cell sizes. size1 is the size of the top/left and size2 the\n\t * bottom/right.\n\t */\n\tif (!resize_first && type == LAYOUT_LEFTRIGHT) {\n\t\tlayout_set_size(lc1, size1, sy, xoff, yoff);\n\t\tlayout_set_size(lc2, size2, sy, xoff + lc1->sx + 1, yoff);\n\t} else if (!resize_first && type == LAYOUT_TOPBOTTOM) {\n\t\tlayout_set_size(lc1, sx, size1, xoff, yoff);\n\t\tlayout_set_size(lc2, sx, size2, xoff, yoff + lc1->sy + 1);\n\t}\n\tif (full_size) {\n\t\tif (!resize_first)\n\t\t\tlayout_resize_child_cells(wp->window, lc);\n\t\tlayout_fix_offsets(wp->window);\n\t} else\n\t\tlayout_make_leaf(lc, wp);\n\n\treturn (lcnew);\n}\n\n/* Destroy the cell associated with a pane. */\nvoid\nlayout_close_pane(struct window_pane *wp)\n{\n\tstruct window\t*w = wp->window;\n\n\t/* Remove the cell. */\n\tlayout_destroy_cell(w, wp->layout_cell, &w->layout_root);\n\n\t/* Fix pane offsets and sizes. */\n\tif (w->layout_root != NULL) {\n\t\tlayout_fix_offsets(w);\n\t\tlayout_fix_panes(w, NULL);\n\t}\n\tnotify_window(\"window-layout-changed\", w);\n}\n\nint\nlayout_spread_cell(struct window *w, struct layout_cell *parent)\n{\n\tstruct layout_cell\t*lc;\n\tstruct style\t\t*sb_style = &w->active->scrollbar_style;\n\tu_int\t\t\t number, each, size, this, remainder;\n\tint\t\t\t change, changed, status, scrollbars;\n\n\tnumber = 0;\n\tTAILQ_FOREACH (lc, &parent->cells, entry)\n\t\tnumber++;\n\tif (number <= 1)\n\t\treturn (0);\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tscrollbars = options_get_number(w->options, \"pane-scrollbars\");\n\n\tif (parent->type == LAYOUT_LEFTRIGHT) {\n\t\tif (scrollbars)\n\t\t\tsize = parent->sx - sb_style->width + sb_style->pad;\n\t\telse\n\t\t\tsize = parent->sx;\n\t}\n\telse if (parent->type == LAYOUT_TOPBOTTOM) {\n\t\tif (layout_add_horizontal_border(w, parent, status))\n\t\t\tsize = parent->sy - 1;\n\t\telse\n\t\t\tsize = parent->sy;\n\t} else\n\t\treturn (0);\n\tif (size < number - 1)\n\t\treturn (0);\n\teach = (size - (number - 1)) / number;\n\tif (each == 0)\n\t\treturn (0);\n\t/*\n\t * Remaining space after assigning that which can be evenly\n\t * distributed.\n\t */\n\tremainder = size - (number * (each + 1)) + 1;\n\n\tchanged = 0;\n\tTAILQ_FOREACH (lc, &parent->cells, entry) {\n\t\tchange = 0;\n\t\tif (parent->type == LAYOUT_LEFTRIGHT) {\n\t\t\tchange = each - (int)lc->sx;\n\t\t\tif (remainder > 0) {\n\t\t\t\tchange++;\n\t\t\t\tremainder--;\n\t\t\t}\n\t\t\tlayout_resize_adjust(w, lc, LAYOUT_LEFTRIGHT, change);\n\t\t} else if (parent->type == LAYOUT_TOPBOTTOM) {\n\t\t\tif (layout_add_horizontal_border(w, lc, status))\n\t\t\t\tthis = each + 1;\n\t\t\telse\n\t\t\t\tthis = each;\n\t\t\tif (remainder > 0) {\n\t\t\t\tthis++;\n\t\t\t\tremainder--;\n\t\t\t}\n\t\t\tchange = this - (int)lc->sy;\n\t\t\tlayout_resize_adjust(w, lc, LAYOUT_TOPBOTTOM, change);\n\t\t}\n\t\tif (change != 0)\n\t\t\tchanged = 1;\n\t}\n\treturn (changed);\n}\n\nvoid\nlayout_spread_out(struct window_pane *wp)\n{\n\tstruct layout_cell\t*parent;\n\tstruct window\t\t*w = wp->window;\n\n\tparent = wp->layout_cell->parent;\n\tif (parent == NULL)\n\t\treturn;\n\n\tdo {\n\t\tif (layout_spread_cell(w, parent)) {\n\t\t\tlayout_fix_offsets(w);\n\t\t\tlayout_fix_panes(w, NULL);\n\t\t\tbreak;\n\t\t}\n\t} while ((parent = parent->parent) != NULL);\n}\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 3.0478515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic FILE\t*log_file;\nstatic int\t log_level;\n\n/* Log callback for libevent. */\nstatic void\nlog_event_cb(__unused int severity, const char *msg)\n{\n\tlog_debug(\"%s\", msg);\n}\n\n/* Increment log level. */\nvoid\nlog_add_level(void)\n{\n\tlog_level++;\n}\n\n/* Get log level. */\nint\nlog_get_level(void)\n{\n\treturn (log_level);\n}\n\n/* Open logging to file. */\nvoid\nlog_open(const char *name)\n{\n\tchar\t*path;\n\n\tif (log_level == 0)\n\t\treturn;\n\tlog_close();\n\n\txasprintf(&path, \"tmux-%s-%ld.log\", name, (long)getpid());\n\tlog_file = fopen(path, \"a\");\n\tfree(path);\n\tif (log_file == NULL)\n\t\treturn;\n\n\tsetvbuf(log_file, NULL, _IOLBF, 0);\n\tevent_set_log_callback(log_event_cb);\n}\n\n/* Toggle logging. */\nvoid\nlog_toggle(const char *name)\n{\n\tif (log_level == 0) {\n\t\tlog_level = 1;\n\t\tlog_open(name);\n\t\tlog_debug(\"log opened\");\n\t} else {\n\t\tlog_debug(\"log closed\");\n\t\tlog_level = 0;\n\t\tlog_close();\n\t}\n}\n\n/* Close logging. */\nvoid\nlog_close(void)\n{\n\tif (log_file != NULL)\n\t\tfclose(log_file);\n\tlog_file = NULL;\n\n\tevent_set_log_callback(NULL);\n}\n\n/* Write a log message. */\nstatic void printflike(1, 0)\nlog_vwrite(const char *msg, va_list ap, const char *prefix)\n{\n\tchar\t\t*s, *out;\n\tstruct timeval\t tv;\n\n\tif (log_file == NULL)\n\t\treturn;\n\n\tif (vasprintf(&s, msg, ap) == -1)\n\t\treturn;\n\tif (stravis(&out, s, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL) == -1) {\n\t\tfree(s);\n\t\treturn;\n\t}\n\tfree(s);\n\n\tgettimeofday(&tv, NULL);\n\tif (fprintf(log_file, \"%lld.%06d %s%s\\n\", (long long)tv.tv_sec,\n\t    (int)tv.tv_usec, prefix, out) != -1)\n\t\tfflush(log_file);\n\tfree(out);\n}\n\n/* Log a debug message. */\nvoid\nlog_debug(const char *msg, ...)\n{\n\tva_list\tap;\n\n\tif (log_file == NULL)\n\t\treturn;\n\n\tva_start(ap, msg);\n\tlog_vwrite(msg, ap, \"\");\n\tva_end(ap);\n}\n\n/* Log a critical error with error string and die. */\n__dead void\nfatal(const char *msg, ...)\n{\n\tchar\t tmp[256];\n\tva_list\t ap;\n\n\tif (snprintf(tmp, sizeof tmp, \"fatal: %s: \", strerror(errno)) < 0)\n\t\texit(1);\n\n\tva_start(ap, msg);\n\tlog_vwrite(msg, ap, tmp);\n\tva_end(ap);\n\n\texit(1);\n}\n\n/* Log a critical error and die. */\n__dead void\nfatalx(const char *msg, ...)\n{\n\tva_list\t ap;\n\n\tva_start(ap, msg);\n\tlog_vwrite(msg, ap, \"fatal: \");\n\tva_end(ap);\n\n\texit(1);\n}\n"
        },
        {
          "name": "logo",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdoc2man.awk",
          "type": "blob",
          "size": 8.40625,
          "content": "#!/usr/bin/awk\n#\n# $Id: mdoc2man.awk,v 1.9 2009/10/24 00:52:42 dtucker Exp $\n#\n# Version history:\n#  v4+ Adapted for OpenSSH Portable (see cvs Id and history)\n#  v3, I put the program under a proper license\n#      Dan Nelson <dnelson@allantgroup.com> added .An, .Aq and fixed a typo\n#  v2, fixed to work on GNU awk --posix and MacOS X\n#  v1, first attempt, didn't work on MacOS X\n#\n# Copyright (c) 2003 Peter Stuge <stuge-mdoc2man@cdy.org>\n#\n# Permission to use, copy, modify, and distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBEGIN {\n  optlist=0\n  oldoptlist=0\n  nospace=0\n  synopsis=0\n  reference=0\n  block=0\n  ext=0\n  extopt=0\n  literal=0\n  prenl=0\n  breakw=0\n  line=\"\"\n}\n\nfunction wtail() {\n  retval=\"\"\n  while(w<nwords) {\n    if(length(retval))\n      retval=retval OFS\n    retval=retval words[++w]\n  }\n  return retval\n}\n\nfunction add(str) {\n  for(;prenl;prenl--)\n    line=line \"\\n\"\n  line=line str\n}\n\n! /^\\./ {\n  for(;prenl;prenl--)\n    print \"\"\n  print\n  if(literal)\n    print \".br\"\n  next\n}\n\n/^\\.\\\\\"/ { next }\n\n{\n  option=0\n  parens=0\n  angles=0\n  sub(\"^\\\\.\",\"\")\n  nwords=split($0,words)\n  for(w=1;w<=nwords;w++) {\n    skip=0\n    if(match(words[w],\"^Li|Pf$\")) {\n      skip=1\n    } else if(match(words[w],\"^Xo$\")) {\n      skip=1\n      ext=1\n      if(length(line)&&!(match(line,\" $\")||prenl))\n\tadd(OFS)\n    } else if(match(words[w],\"^Xc$\")) {\n      skip=1\n      ext=0\n      if(!extopt)\n\tprenl++\n      w=nwords\n    } else if(match(words[w],\"^Bd$\")) {\n      skip=1\n      if(match(words[w+1],\"-literal\")) {\n\tliteral=1\n\tprenl++\n\tw=nwords\n      }\n    } else if(match(words[w],\"^Ed$\")) {\n      skip=1\n      literal=0\n    } else if(match(words[w],\"^Ns$\")) {\n      skip=1\n      if(!nospace)\n\tnospace=1\n      sub(\" $\",\"\",line)\n    } else if(match(words[w],\"^No$\")) {\n      skip=1\n      sub(\" $\",\"\",line)\n      add(words[++w])\n    } else if(match(words[w],\"^Dq$\")) {\n      skip=1\n      add(\"``\")\n      add(words[++w])\n      while(w<nwords&&!match(words[w+1],\"^[\\\\.,]\"))\n\tadd(OFS words[++w])\n      add(\"''\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Sq|Ql$\")) {\n      skip=1\n      add(\"`\" words[++w] \"'\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Oo$\")) {\n      skip=1\n      extopt=1\n      if(!nospace)\n\tnospace=1\n      add(\"[\")\n    } else if(match(words[w],\"^Oc$\")) {\n      skip=1\n      extopt=0\n      add(\"]\")\n    }\n    if(!skip) {\n      if(!nospace&&length(line)&&!(match(line,\" $\")||prenl))\n\tadd(OFS)\n      if(nospace==1)\n\tnospace=0\n    }\n    if(match(words[w],\"^Dd$\")) {\n      if(match(words[w+1],\"^\\\\$Mdocdate:\")) {\n        w++;\n        if(match(words[w+4],\"^\\\\$$\")) {\n          words[w+4] = \"\"\n        }\n      }\n      date=wtail()\n      next\n    } else if(match(words[w],\"^Dt$\")) {\n      id=wtail()\n      next\n    } else if(match(words[w],\"^Ux$\")) {\n      add(\"UNIX\")\n      skip=1\n    } else if(match(words[w],\"^Ox$\")) {\n      add(\"OpenBSD\")\n      skip=1\n    } else if(match(words[w],\"^Os$\")) {\n      add(\".TH \" id \" \\\"\" date \"\\\" \\\"\" wtail() \"\\\"\")\n    } else if(match(words[w],\"^Sh$\")) {\n      add(\".SH\")\n      synopsis=match(words[w+1],\"SYNOPSIS\")\n    } else if(match(words[w],\"^Xr$\")) {\n      add(\"\\\\fB\" words[++w] \"\\\\fP(\" words[++w] \")\" words[++w])\n    } else if(match(words[w],\"^Rs$\")) {\n      split(\"\",refauthors)\n      nrefauthors=0\n      reftitle=\"\"\n      refissue=\"\"\n      refdate=\"\"\n      refopt=\"\"\n      refreport=\"\"\n      reference=1\n      next\n    } else if(match(words[w],\"^Re$\")) {\n      prenl++\n      for(i=nrefauthors-1;i>0;i--) {\n\tadd(refauthors[i])\n\tif(i>1)\n\t  add(\", \")\n      }\n      if(nrefauthors>1)\n\tadd(\" and \")\n      if(nrefauthors>0)\n        add(refauthors[0] \", \")\n      add(\"\\\\fI\" reftitle \"\\\\fP\")\n      if(length(refissue))\n\tadd(\", \" refissue)\n      if(length(refreport)) {\n\tadd(\", \" refreport)\n      }\n      if(length(refdate))\n\tadd(\", \" refdate)\n      if(length(refopt))\n\tadd(\", \" refopt)\n      add(\".\")\n      reference=0\n    } else if(reference) {\n      if(match(words[w],\"^%A$\")) { refauthors[nrefauthors++]=wtail() }\n      if(match(words[w],\"^%T$\")) {\n\treftitle=wtail()\n\tsub(\"^\\\"\",\"\",reftitle)\n\tsub(\"\\\"$\",\"\",reftitle)\n      }\n      if(match(words[w],\"^%N$\")) { refissue=wtail() }\n      if(match(words[w],\"^%D$\")) { refdate=wtail() }\n      if(match(words[w],\"^%O$\")) { refopt=wtail() }\n      if(match(words[w],\"^%R$\")) { refreport=wtail() }\n    } else if(match(words[w],\"^Nm$\")) {\n      if(synopsis) {\n\tadd(\".br\")\n\tprenl++\n      }\n      n=words[++w]\n      if(!length(name))\n\tname=n\n      if(!length(n))\n\tn=name\n      add(\"\\\\fB\" n \"\\\\fP\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Nd$\")) {\n      add(\"\\\\- \" wtail())\n    } else if(match(words[w],\"^Fl$\")) {\n      add(\"\\\\fB\\\\-\" words[++w] \"\\\\fP\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Ar$\")) {\n      add(\"\\\\fI\")\n      if(w==nwords)\n\tadd(\"file ...\\\\fP\")\n      else {\n\tadd(words[++w] \"\\\\fP\")\n\twhile(match(words[w+1],\"^\\\\|$\"))\n\t  add(OFS words[++w] \" \\\\fI\" words[++w] \"\\\\fP\")\n      }\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Cm$\")) {\n      add(\"\\\\fB\" words[++w] \"\\\\fP\")\n      while(w<nwords&&match(words[w+1],\"^[\\\\.,:;)]\"))\n\tadd(words[++w])\n    } else if(match(words[w],\"^Op$\")) {\n      option=1\n      if(!nospace)\n\tnospace=1\n      add(\"[\")\n    } else if(match(words[w],\"^Pp$\")) {\n      prenl++\n    } else if(match(words[w],\"^An$\")) {\n      prenl++\n    } else if(match(words[w],\"^Ss$\")) {\n      add(\".SS\")\n    } else if(match(words[w],\"^Pa$\")&&!option) {\n      add(\"\\\\fI\")\n      w++\n      if(match(words[w],\"^\\\\.\"))\n\tadd(\"\\\\&\")\n      add(words[w] \"\\\\fP\")\n      while(w<nwords&&match(words[w+1],\"^[\\\\.,:;)]\"))\n\tadd(words[++w])\n    } else if(match(words[w],\"^Dv$\")) {\n      add(\".BR\")\n    } else if(match(words[w],\"^Em|Ev$\")) {\n      add(\".IR\")\n    } else if(match(words[w],\"^Pq$\")) {\n      add(\"(\")\n      nospace=1\n      parens=1\n    } else if(match(words[w],\"^Aq$\")) {\n      add(\"<\")\n      nospace=1\n      angles=1\n    } else if(match(words[w],\"^S[xy]$\")) {\n      add(\".B \" wtail())\n    } else if(match(words[w],\"^Ic$\")) {\n      plain=1\n      add(\"\\\\fB\")\n      while(w<nwords) {\n\tw++\n\tif(match(words[w],\"^Op$\")) {\n\t  w++\n\t  add(\"[\")\n\t  words[nwords]=words[nwords] \"]\"\n\t}\n\tif(match(words[w],\"^Ar$\")) {\n\t  add(\"\\\\fI\" words[++w] \"\\\\fP\")\n\t} else if(match(words[w],\"^[\\\\.,]\")) {\n\t  sub(\" $\",\"\",line)\n\t  if(plain) {\n\t    add(\"\\\\fP\")\n\t    plain=0\n\t  }\n\t  add(words[w])\n\t} else {\n\t  if(!plain) {\n\t    add(\"\\\\fB\")\n\t    plain=1\n\t  }\n\t  add(words[w])\n\t}\n\tif(!nospace)\n\t  add(OFS)\n      }\n      sub(\" $\",\"\",line)\n      if(plain)\n\tadd(\"\\\\fP\")\n    } else if(match(words[w],\"^Bl$\")) {\n      oldoptlist=optlist\n      if(match(words[w+1],\"-bullet\"))\n\toptlist=1\n      else if(match(words[w+1],\"-enum\")) {\n\toptlist=2\n\tenum=0\n      } else if(match(words[w+1],\"-tag\"))\n\toptlist=3\n      else if(match(words[w+1],\"-item\"))\n\toptlist=4\n      else if(match(words[w+1],\"-bullet\"))\n\toptlist=1\n      w=nwords\n    } else if(match(words[w],\"^El$\")) {\n      optlist=oldoptlist\n    } else if(match(words[w],\"^Bk$\")) {\n      if(match(words[w+1],\"-words\")) {\n\tw++\n\tbreakw=1\n      }\n    } else if(match(words[w],\"^Ek$\")) {\n      breakw=0\n    } else if(match(words[w],\"^It$\")&&optlist) {\n      if(optlist==1)\n\tadd(\".IP \\\\(bu\")\n      else if(optlist==2)\n\tadd(\".IP \" ++enum \".\")\n      else if(optlist==3) {\n\tadd(\".TP\")\n\tprenl++\n\tif(match(words[w+1],\"^Pa$|^Ev$\")) {\n\t  add(\".B\")\n\t  w++\n\t}\n      } else if(optlist==4)\n\tadd(\".IP\")\n    } else if(match(words[w],\"^Sm$\")) {\n      if(match(words[w+1],\"off\"))\n\tnospace=2\n      else if(match(words[w+1],\"on\"))\n\tnospace=0\n      w++\n    } else if(!skip) {\n      add(words[w])\n    }\n  }\n  if(match(line,\"^\\\\.[^a-zA-Z]\"))\n    sub(\"^\\\\.\",\"\",line)\n  if(parens)\n    add(\")\")\n  if(angles)\n    add(\">\")\n  if(option)\n    add(\"]\")\n  if(ext&&!extopt&&!match(line,\" $\"))\n    add(OFS)\n  if(!ext&&!extopt&&length(line)) {\n    print line\n    prenl=0\n    line=\"\"\n  }\n}\n"
        },
        {
          "name": "menu.c",
          "type": "blob",
          "size": 13.072265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct menu_data {\n\tstruct cmdq_item\t*item;\n\tint\t\t\t flags;\n\n\tstruct grid_cell\t style;\n\tstruct grid_cell\t border_style;\n\tstruct grid_cell\t selected_style;\n\tenum box_lines\t\t border_lines;\n\n\tstruct cmd_find_state\t fs;\n\tstruct screen\t\t s;\n\n\tu_int\t\t\t px;\n\tu_int\t\t\t py;\n\n\tstruct menu\t\t*menu;\n\tint\t\t\t choice;\n\n\tmenu_choice_cb\t\t cb;\n\tvoid\t\t\t*data;\n};\n\nvoid\nmenu_add_items(struct menu *menu, const struct menu_item *items,\n    struct cmdq_item *qitem, struct client *c, struct cmd_find_state *fs)\n{\n\tconst struct menu_item\t*loop;\n\n\tfor (loop = items; loop->name != NULL; loop++)\n\t\tmenu_add_item(menu, loop, qitem, c, fs);\n}\n\nvoid\nmenu_add_item(struct menu *menu, const struct menu_item *item,\n    struct cmdq_item *qitem, struct client *c, struct cmd_find_state *fs)\n{\n\tstruct menu_item\t*new_item;\n\tconst char\t\t*key = NULL, *cmd, *suffix = \"\";\n\tchar\t\t\t*s, *trimmed, *name;\n\tu_int\t\t\t width, max_width;\n\tint\t\t\t line;\n\tsize_t\t\t\t keylen, slen;\n\n\tline = (item == NULL || item->name == NULL || *item->name == '\\0');\n\tif (line && menu->count == 0)\n\t\treturn;\n\tif (line && menu->items[menu->count - 1].name == NULL)\n\t\treturn;\n\n\tmenu->items = xreallocarray(menu->items, menu->count + 1,\n\t    sizeof *menu->items);\n\tnew_item = &menu->items[menu->count++];\n\tmemset(new_item, 0, sizeof *new_item);\n\n\tif (line)\n\t\treturn;\n\n\tif (fs != NULL)\n\t\ts = format_single_from_state(qitem, item->name, c, fs);\n\telse\n\t\ts = format_single(qitem, item->name, c, NULL, NULL, NULL);\n\tif (*s == '\\0') { /* no item if empty after format expanded */\n\t\tmenu->count--;\n\t\treturn;\n\t}\n\tmax_width = c->tty.sx - 4;\n\n\tslen = strlen(s);\n\tif (*s != '-' && item->key != KEYC_UNKNOWN && item->key != KEYC_NONE) {\n\t\tkey = key_string_lookup_key(item->key, 0);\n\t\tkeylen = strlen(key) + 3; /* 3 = space and two brackets */\n\n\t\t/*\n\t\t * Add the key if it is shorter than a quarter of the available\n\t\t * space or there is space for the entire item text and the\n\t\t * key.\n\t\t */\n\t\tif (keylen <= max_width / 4)\n\t\t\tmax_width -= keylen;\n\t\telse if (keylen >= max_width || slen >= max_width - keylen)\n\t\t\tkey = NULL;\n\t}\n\n\tif (slen > max_width) {\n\t\tmax_width--;\n\t\tsuffix = \">\";\n\t}\n\ttrimmed = format_trim_right(s, max_width);\n\tif (key != NULL) {\n\t\txasprintf(&name, \"%s%s#[default] #[align=right](%s)\",\n\t\t    trimmed, suffix, key);\n\t} else\n\t\txasprintf(&name, \"%s%s\", trimmed, suffix);\n\tfree(trimmed);\n\n\tnew_item->name = name;\n\tfree(s);\n\n\tcmd = item->command;\n\tif (cmd != NULL) {\n\t\tif (fs != NULL)\n\t\t\ts = format_single_from_state(qitem, cmd, c, fs);\n\t\telse\n\t\t\ts = format_single(qitem, cmd, c, NULL, NULL, NULL);\n\t} else\n\t\ts = NULL;\n\tnew_item->command = s;\n\tnew_item->key = item->key;\n\n\twidth = format_width(new_item->name);\n\tif (*new_item->name == '-')\n\t\twidth--;\n\tif (width > menu->width)\n\t\tmenu->width = width;\n}\n\nstruct menu *\nmenu_create(const char *title)\n{\n\tstruct menu\t*menu;\n\n\tmenu = xcalloc(1, sizeof *menu);\n\tmenu->title = xstrdup(title);\n\tmenu->width = format_width(title);\n\n\treturn (menu);\n}\n\nvoid\nmenu_free(struct menu *menu)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < menu->count; i++) {\n\t\tfree((void *)menu->items[i].name);\n\t\tfree((void *)menu->items[i].command);\n\t}\n\tfree(menu->items);\n\n\tfree((void *)menu->title);\n\tfree(menu);\n}\n\nstruct screen *\nmenu_mode_cb(__unused struct client *c, void *data, u_int *cx, u_int *cy)\n{\n\tstruct menu_data\t*md = data;\n\n\t*cx = md->px + 2;\n\tif (md->choice == -1)\n\t\t*cy = md->py;\n\telse\n\t\t*cy = md->py + 1 + md->choice;\n\n\treturn (&md->s);\n}\n\n/* Return parts of the input range which are not obstructed by the menu. */\nvoid\nmenu_check_cb(__unused struct client *c, void *data, u_int px, u_int py,\n    u_int nx, struct overlay_ranges *r)\n{\n\tstruct menu_data\t*md = data;\n\tstruct menu\t\t*menu = md->menu;\n\n\tserver_client_overlay_range(md->px, md->py, menu->width + 4,\n\t    menu->count + 2, px, py, nx, r);\n}\n\nvoid\nmenu_draw_cb(struct client *c, void *data,\n    __unused struct screen_redraw_ctx *rctx)\n{\n\tstruct menu_data\t*md = data;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct screen\t\t*s = &md->s;\n\tstruct menu\t\t*menu = md->menu;\n\tstruct screen_write_ctx\t ctx;\n\tu_int\t\t\t i, px = md->px, py = md->py;\n\n\tscreen_write_start(&ctx, s);\n\tscreen_write_clearscreen(&ctx, 8);\n\n\tif (md->border_lines != BOX_LINES_NONE) {\n\t\tscreen_write_box(&ctx, menu->width + 4, menu->count + 2,\n\t\t    md->border_lines, &md->border_style, menu->title);\n\t}\n\n\tscreen_write_menu(&ctx, menu, md->choice, md->border_lines,\n\t    &md->style, &md->border_style, &md->selected_style);\n\tscreen_write_stop(&ctx);\n\n\tfor (i = 0; i < screen_size_y(&md->s); i++) {\n\t\ttty_draw_line(tty, s, 0, i, menu->width + 4, px, py + i,\n\t\t    &grid_default_cell, NULL);\n\t}\n}\n\nvoid\nmenu_free_cb(__unused struct client *c, void *data)\n{\n\tstruct menu_data\t*md = data;\n\n\tif (md->item != NULL)\n\t\tcmdq_continue(md->item);\n\n\tif (md->cb != NULL)\n\t\tmd->cb(md->menu, UINT_MAX, KEYC_NONE, md->data);\n\n\tscreen_free(&md->s);\n\tmenu_free(md->menu);\n\tfree(md);\n}\n\nint\nmenu_key_cb(struct client *c, void *data, struct key_event *event)\n{\n\tstruct menu_data\t\t*md = data;\n\tstruct menu\t\t\t*menu = md->menu;\n\tstruct mouse_event\t\t*m = &event->m;\n\tu_int\t\t\t\t i;\n\tint\t\t\t\t count = menu->count, old = md->choice;\n\tconst char\t\t\t*name = NULL;\n\tconst struct menu_item\t\t*item;\n\tstruct cmdq_state\t\t*state;\n\tenum cmd_parse_status\t\t status;\n\tchar\t\t\t\t*error;\n\n\tif (KEYC_IS_MOUSE(event->key)) {\n\t\tif (md->flags & MENU_NOMOUSE) {\n\t\t\tif (MOUSE_BUTTONS(m->b) != MOUSE_BUTTON_1)\n\t\t\t\treturn (1);\n\t\t\treturn (0);\n\t\t}\n\t\tif (m->x < md->px ||\n\t\t    m->x > md->px + 4 + menu->width ||\n\t\t    m->y < md->py + 1 ||\n\t\t    m->y > md->py + 1 + count - 1) {\n\t\t\tif (~md->flags & MENU_STAYOPEN) {\n\t\t\t\tif (MOUSE_RELEASE(m->b))\n\t\t\t\t\treturn (1);\n\t\t\t} else {\n\t\t\t\tif (!MOUSE_RELEASE(m->b) &&\n\t\t\t\t    !MOUSE_WHEEL(m->b) &&\n\t\t\t\t    !MOUSE_DRAG(m->b))\n\t\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tif (md->choice != -1) {\n\t\t\t\tmd->choice = -1;\n\t\t\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\t\t}\n\t\t\treturn (0);\n\t\t}\n\t\tif (~md->flags & MENU_STAYOPEN) {\n\t\t\tif (MOUSE_RELEASE(m->b))\n\t\t\t\tgoto chosen;\n\t\t} else {\n\t\t\tif (!MOUSE_WHEEL(m->b) && !MOUSE_DRAG(m->b))\n\t\t\t\tgoto chosen;\n\t\t}\n\t\tmd->choice = m->y - (md->py + 1);\n\t\tif (md->choice != old)\n\t\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\treturn (0);\n\t}\n\tfor (i = 0; i < (u_int)count; i++) {\n\t\tname = menu->items[i].name;\n\t\tif (name == NULL || *name == '-')\n\t\t\tcontinue;\n\t\tif (event->key == menu->items[i].key) {\n\t\t\tmd->choice = i;\n\t\t\tgoto chosen;\n\t\t}\n\t}\n\tswitch (event->key & ~KEYC_MASK_FLAGS) {\n\tcase KEYC_UP:\n\tcase 'k':\n\t\tif (old == -1)\n\t\t\told = 0;\n\t\tdo {\n\t\t\tif (md->choice == -1 || md->choice == 0)\n\t\t\t\tmd->choice = count - 1;\n\t\t\telse\n\t\t\t\tmd->choice--;\n\t\t\tname = menu->items[md->choice].name;\n\t\t} while ((name == NULL || *name == '-') && md->choice != old);\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\treturn (0);\n\tcase KEYC_BSPACE:\n\t\tif (~md->flags & MENU_TAB)\n\t\t\tbreak;\n\t\treturn (1);\n\tcase '\\011': /* Tab */\n\t\tif (~md->flags & MENU_TAB)\n\t\t\tbreak;\n\t\tif (md->choice == count - 1)\n\t\t\treturn (1);\n\t\t/* FALLTHROUGH */\n\tcase KEYC_DOWN:\n\tcase 'j':\n\t\tif (old == -1)\n\t\t\told = 0;\n\t\tdo {\n\t\t\tif (md->choice == -1 || md->choice == count - 1)\n\t\t\t\tmd->choice = 0;\n\t\t\telse\n\t\t\t\tmd->choice++;\n\t\t\tname = menu->items[md->choice].name;\n\t\t} while ((name == NULL || *name == '-') && md->choice != old);\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\treturn (0);\n\tcase KEYC_PPAGE:\n\tcase 'b'|KEYC_CTRL:\n\t\tif (md->choice < 6)\n\t\t\tmd->choice = 0;\n\t\telse {\n\t\t\ti = 5;\n\t\t\twhile (i > 0) {\n\t\t\t\tmd->choice--;\n\t\t\t\tname = menu->items[md->choice].name;\n\t\t\t\tif (md->choice != 0 &&\n\t\t\t\t    (name != NULL && *name != '-'))\n\t\t\t\t\ti--;\n\t\t\t\telse if (md->choice == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\tbreak;\n\tcase KEYC_NPAGE:\n\t\tif (md->choice > count - 6) {\n\t\t\tmd->choice = count - 1;\n\t\t\tname = menu->items[md->choice].name;\n\t\t} else {\n\t\t\ti = 5;\n\t\t\twhile (i > 0) {\n\t\t\t\tmd->choice++;\n\t\t\t\tname = menu->items[md->choice].name;\n\t\t\t\tif (md->choice != count - 1 &&\n\t\t\t\t    (name != NULL && *name != '-'))\n\t\t\t\t\ti++;\n\t\t\t\telse if (md->choice == count - 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (name == NULL || *name == '-') {\n\t\t\tmd->choice--;\n\t\t\tname = menu->items[md->choice].name;\n\t\t}\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\tbreak;\n\tcase 'g':\n\tcase KEYC_HOME:\n\t\tmd->choice = 0;\n\t\tname = menu->items[md->choice].name;\n\t\twhile (name == NULL || *name == '-') {\n\t\t\tmd->choice++;\n\t\t\tname = menu->items[md->choice].name;\n\t\t}\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\tbreak;\n\tcase 'G':\n\tcase KEYC_END:\n\t\tmd->choice = count - 1;\n\t\tname = menu->items[md->choice].name;\n\t\twhile (name == NULL || *name == '-') {\n\t\t\tmd->choice--;\n\t\t\tname = menu->items[md->choice].name;\n\t\t}\n\t\tc->flags |= CLIENT_REDRAWOVERLAY;\n\t\tbreak;\n\tcase 'f'|KEYC_CTRL:\n\t\tbreak;\n\tcase '\\r':\n\t\tgoto chosen;\n\tcase '\\033': /* Escape */\n\tcase 'c'|KEYC_CTRL:\n\tcase 'g'|KEYC_CTRL:\n\tcase 'q':\n\t\treturn (1);\n\t}\n\treturn (0);\n\nchosen:\n\tif (md->choice == -1)\n\t\treturn (1);\n\titem = &menu->items[md->choice];\n\tif (item->name == NULL || *item->name == '-') {\n\t\tif (md->flags & MENU_STAYOPEN)\n\t\t\treturn (0);\n\t\treturn (1);\n\t}\n\tif (md->cb != NULL) {\n\t    md->cb(md->menu, md->choice, item->key, md->data);\n\t    md->cb = NULL;\n\t    return (1);\n\t}\n\n\tif (md->item != NULL)\n\t\tevent = cmdq_get_event(md->item);\n\telse\n\t\tevent = NULL;\n\tstate = cmdq_new_state(&md->fs, event, 0);\n\n\tstatus = cmd_parse_and_append(item->command, NULL, c, state, &error);\n\tif (status == CMD_PARSE_ERROR) {\n\t\tcmdq_append(c, cmdq_get_error(error));\n\t\tfree(error);\n\t}\n\tcmdq_free_state(state);\n\n\treturn (1);\n}\n\nstatic void\nmenu_set_style(struct client *c, struct grid_cell *gc, const char *style,\n    const char *option)\n{\n\tstruct style\t sytmp;\n\tstruct options\t*o = c->session->curw->window->options;\n\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\tstyle_apply(gc, o, option, NULL);\n\tif (style != NULL) {\n\t\tstyle_set(&sytmp, &grid_default_cell);\n\t\tif (style_parse(&sytmp, gc, style) == 0) {\n\t\t\tgc->fg = sytmp.gc.fg;\n\t\t\tgc->bg = sytmp.gc.bg;\n\t\t}\n\t}\n}\n\nstruct menu_data *\nmenu_prepare(struct menu *menu, int flags, int starting_choice,\n    struct cmdq_item *item, u_int px, u_int py, struct client *c,\n    enum box_lines lines, const char *style, const char *selected_style,\n    const char *border_style, struct cmd_find_state *fs, menu_choice_cb cb,\n    void *data)\n{\n\tstruct menu_data\t*md;\n\tint\t\t\t choice;\n\tconst char\t\t*name;\n\tstruct options\t\t*o = c->session->curw->window->options;\n\n\tif (c->tty.sx < menu->width + 4 || c->tty.sy < menu->count + 2)\n\t\treturn (NULL);\n\tif (px + menu->width + 4 > c->tty.sx)\n\t\tpx = c->tty.sx - menu->width - 4;\n\tif (py + menu->count + 2 > c->tty.sy)\n\t\tpy = c->tty.sy - menu->count - 2;\n\n\tif (lines == BOX_LINES_DEFAULT)\n\t\tlines = options_get_number(o, \"menu-border-lines\");\n\n\tmd = xcalloc(1, sizeof *md);\n\tmd->item = item;\n\tmd->flags = flags;\n\tmd->border_lines = lines;\n\n\tmenu_set_style(c, &md->style, style, \"menu-style\");\n\tmenu_set_style(c, &md->selected_style, selected_style,\n\t    \"menu-selected-style\");\n\tmenu_set_style(c, &md->border_style, border_style, \"menu-border-style\");\n\n\tif (fs != NULL)\n\t\tcmd_find_copy_state(&md->fs, fs);\n\tscreen_init(&md->s, menu->width + 4, menu->count + 2, 0);\n\tif (~md->flags & MENU_NOMOUSE)\n\t\tmd->s.mode |= (MODE_MOUSE_ALL|MODE_MOUSE_BUTTON);\n\tmd->s.mode &= ~MODE_CURSOR;\n\n\tmd->px = px;\n\tmd->py = py;\n\n\tmd->menu = menu;\n\tmd->choice = -1;\n\n\tif (md->flags & MENU_NOMOUSE) {\n\t\tif (starting_choice >= (int)menu->count) {\n\t\t\tstarting_choice = menu->count - 1;\n\t\t\tchoice = starting_choice + 1;\n\t\t\tfor (;;) {\n\t\t\t\tname = menu->items[choice - 1].name;\n\t\t\t\tif (name != NULL && *name != '-') {\n\t\t\t\t\tmd->choice = choice - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (--choice == 0)\n\t\t\t\t\tchoice = menu->count;\n\t\t\t\tif (choice == starting_choice + 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (starting_choice >= 0) {\n\t\t\tchoice = starting_choice;\n\t\t\tfor (;;) {\n\t\t\t\tname = menu->items[choice].name;\n\t\t\t\tif (name != NULL && *name != '-') {\n\t\t\t\t\tmd->choice = choice;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (++choice == (int)menu->count)\n\t\t\t\t\tchoice = 0;\n\t\t\t\tif (choice == starting_choice)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmd->cb = cb;\n\tmd->data = data;\n\treturn (md);\n}\n\nint\nmenu_display(struct menu *menu, int flags, int starting_choice,\n    struct cmdq_item *item, u_int px, u_int py, struct client *c,\n    enum box_lines lines, const char *style, const char *selected_style,\n    const char *border_style, struct cmd_find_state *fs, menu_choice_cb cb,\n    void *data)\n{\n\tstruct menu_data\t*md;\n\n\tmd = menu_prepare(menu, flags, starting_choice, item, px, py, c, lines,\n\t    style, selected_style, border_style, fs, cb, data);\n\tif (md == NULL)\n\t\treturn (-1);\n\tserver_client_set_overlay(c, 0, NULL, menu_mode_cb, menu_draw_cb,\n\t    menu_key_cb, menu_free_cb, NULL, md);\n\treturn (0);\n}\n"
        },
        {
          "name": "mode-tree.c",
          "type": "blob",
          "size": 28.345703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2017 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nenum mode_tree_search_dir {\n\tMODE_TREE_SEARCH_FORWARD,\n\tMODE_TREE_SEARCH_BACKWARD\n};\n\nenum mode_tree_preview {\n\tMODE_TREE_PREVIEW_OFF,\n\tMODE_TREE_PREVIEW_NORMAL,\n\tMODE_TREE_PREVIEW_BIG\n};\n\nstruct mode_tree_item;\nTAILQ_HEAD(mode_tree_list, mode_tree_item);\n\nstruct mode_tree_data {\n\tint\t\t\t  dead;\n\tu_int\t\t\t  references;\n\tint\t\t\t  zoomed;\n\n\tstruct window_pane\t *wp;\n\tvoid\t\t\t *modedata;\n\tconst struct menu_item\t *menu;\n\n\tconst char\t\t**sort_list;\n\tu_int\t\t\t  sort_size;\n\tstruct mode_tree_sort_criteria sort_crit;\n\n\tmode_tree_build_cb        buildcb;\n\tmode_tree_draw_cb         drawcb;\n\tmode_tree_search_cb       searchcb;\n\tmode_tree_menu_cb         menucb;\n\tmode_tree_height_cb       heightcb;\n\tmode_tree_key_cb\t  keycb;\n\n\tstruct mode_tree_list\t  children;\n\tstruct mode_tree_list\t  saved;\n\n\tstruct mode_tree_line\t *line_list;\n\tu_int\t\t\t  line_size;\n\n\tu_int\t\t\t  depth;\n\n\tu_int\t\t\t  width;\n\tu_int\t\t\t  height;\n\n\tu_int\t\t\t  offset;\n\tu_int\t\t\t  current;\n\n\tstruct screen\t\t  screen;\n\n\tint\t\t\t  preview;\n\tchar\t\t\t *search;\n\tchar\t\t\t *filter;\n\tint\t\t\t  no_matches;\n\tenum mode_tree_search_dir search_dir;\n};\n\nstruct mode_tree_item {\n\tstruct mode_tree_item\t\t*parent;\n\tvoid\t\t\t\t*itemdata;\n\tu_int\t\t\t\t line;\n\n\tkey_code\t\t\t key;\n\tconst char\t\t\t*keystr;\n\tsize_t\t\t\t\t keylen;\n\n\tuint64_t\t\t\t tag;\n\tconst char\t\t\t*name;\n\tconst char\t\t\t*text;\n\n\tint\t\t\t\t expanded;\n\tint\t\t\t\t tagged;\n\n\tint\t\t\t\t draw_as_parent;\n\tint\t\t\t\t no_tag;\n\n\tstruct mode_tree_list\t\t children;\n\tTAILQ_ENTRY(mode_tree_item)\t entry;\n};\n\nstruct mode_tree_line {\n\tstruct mode_tree_item\t\t*item;\n\tu_int\t\t\t\t depth;\n\tint\t\t\t\t last;\n\tint\t\t\t\t flat;\n};\n\nstruct mode_tree_menu {\n\tstruct mode_tree_data\t\t*data;\n\tstruct client\t\t\t*c;\n\tu_int\t\t\t\t line;\n};\n\nstatic void mode_tree_free_items(struct mode_tree_list *);\n\nstatic const struct menu_item mode_tree_menu_items[] = {\n\t{ \"Scroll Left\", '<', NULL },\n\t{ \"Scroll Right\", '>', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Cancel\", 'q', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nstatic struct mode_tree_item *\nmode_tree_find_item(struct mode_tree_list *mtl, uint64_t tag)\n{\n\tstruct mode_tree_item\t*mti, *child;\n\n\tTAILQ_FOREACH(mti, mtl, entry) {\n\t\tif (mti->tag == tag)\n\t\t\treturn (mti);\n\t\tchild = mode_tree_find_item(&mti->children, tag);\n\t\tif (child != NULL)\n\t\t\treturn (child);\n\t}\n\treturn (NULL);\n}\n\nstatic void\nmode_tree_free_item(struct mode_tree_item *mti)\n{\n\tmode_tree_free_items(&mti->children);\n\n\tfree((void *)mti->name);\n\tfree((void *)mti->text);\n\tfree((void *)mti->keystr);\n\n\tfree(mti);\n}\n\nstatic void\nmode_tree_free_items(struct mode_tree_list *mtl)\n{\n\tstruct mode_tree_item\t*mti, *mti1;\n\n\tTAILQ_FOREACH_SAFE(mti, mtl, entry, mti1) {\n\t\tTAILQ_REMOVE(mtl, mti, entry);\n\t\tmode_tree_free_item(mti);\n\t}\n}\n\nstatic void\nmode_tree_check_selected(struct mode_tree_data *mtd)\n{\n\t/*\n\t * If the current line would now be off screen reset the offset to the\n\t * last visible line.\n\t */\n\tif (mtd->current > mtd->height - 1)\n\t\tmtd->offset = mtd->current - mtd->height + 1;\n}\n\nstatic void\nmode_tree_clear_lines(struct mode_tree_data *mtd)\n{\n\tfree(mtd->line_list);\n\tmtd->line_list = NULL;\n\tmtd->line_size = 0;\n}\n\nstatic void\nmode_tree_build_lines(struct mode_tree_data *mtd,\n    struct mode_tree_list *mtl, u_int depth)\n{\n\tstruct mode_tree_item\t*mti;\n\tstruct mode_tree_line\t*line;\n\tu_int\t\t\t i;\n\tint\t\t\t flat = 1;\n\n\tmtd->depth = depth;\n\tTAILQ_FOREACH(mti, mtl, entry) {\n\t\tmtd->line_list = xreallocarray(mtd->line_list,\n\t\t    mtd->line_size + 1, sizeof *mtd->line_list);\n\n\t\tline = &mtd->line_list[mtd->line_size++];\n\t\tline->item = mti;\n\t\tline->depth = depth;\n\t\tline->last = (mti == TAILQ_LAST(mtl, mode_tree_list));\n\n\t\tmti->line = (mtd->line_size - 1);\n\t\tif (!TAILQ_EMPTY(&mti->children))\n\t\t\tflat = 0;\n\t\tif (mti->expanded)\n\t\t\tmode_tree_build_lines(mtd, &mti->children, depth + 1);\n\n\t\tif (mtd->keycb != NULL) {\n\t\t\tmti->key = mtd->keycb(mtd->modedata, mti->itemdata,\n\t\t\t    mti->line);\n\t\t\tif (mti->key == KEYC_UNKNOWN)\n\t\t\t\tmti->key = KEYC_NONE;\n\t\t} else if (mti->line < 10)\n\t\t\tmti->key = '0' + mti->line;\n\t\telse if (mti->line < 36)\n\t\t\tmti->key = KEYC_META|('a' + mti->line - 10);\n\t\telse\n\t\t\tmti->key = KEYC_NONE;\n\t\tif (mti->key != KEYC_NONE) {\n\t\t\tmti->keystr = xstrdup(key_string_lookup_key(mti->key,\n\t\t\t    0));\n\t\t\tmti->keylen = strlen(mti->keystr);\n\t\t} else {\n\t\t\tmti->keystr = NULL;\n\t\t\tmti->keylen = 0;\n\t\t}\n\t}\n\tTAILQ_FOREACH(mti, mtl, entry) {\n\t\tfor (i = 0; i < mtd->line_size; i++) {\n\t\t\tline = &mtd->line_list[i];\n\t\t\tif (line->item == mti)\n\t\t\t\tline->flat = flat;\n\t\t}\n\t}\n}\n\nstatic void\nmode_tree_clear_tagged(struct mode_tree_list *mtl)\n{\n\tstruct mode_tree_item\t*mti;\n\n\tTAILQ_FOREACH(mti, mtl, entry) {\n\t\tmti->tagged = 0;\n\t\tmode_tree_clear_tagged(&mti->children);\n\t}\n}\n\nvoid\nmode_tree_up(struct mode_tree_data *mtd, int wrap)\n{\n\tif (mtd->current == 0) {\n\t\tif (wrap) {\n\t\t\tmtd->current = mtd->line_size - 1;\n\t\t\tif (mtd->line_size >= mtd->height)\n\t\t\t\tmtd->offset = mtd->line_size - mtd->height;\n\t\t}\n\t} else {\n\t\tmtd->current--;\n\t\tif (mtd->current < mtd->offset)\n\t\t\tmtd->offset--;\n\t}\n}\n\nint\nmode_tree_down(struct mode_tree_data *mtd, int wrap)\n{\n\tif (mtd->current == mtd->line_size - 1) {\n\t\tif (wrap) {\n\t\t\tmtd->current = 0;\n\t\t\tmtd->offset = 0;\n\t\t} else\n\t\t\treturn (0);\n\t} else {\n\t\tmtd->current++;\n\t\tif (mtd->current > mtd->offset + mtd->height - 1)\n\t\t\tmtd->offset++;\n\t}\n\treturn (1);\n}\n\nvoid *\nmode_tree_get_current(struct mode_tree_data *mtd)\n{\n\treturn (mtd->line_list[mtd->current].item->itemdata);\n}\n\nconst char *\nmode_tree_get_current_name(struct mode_tree_data *mtd)\n{\n\treturn (mtd->line_list[mtd->current].item->name);\n}\n\nvoid\nmode_tree_expand_current(struct mode_tree_data *mtd)\n{\n\tif (!mtd->line_list[mtd->current].item->expanded) {\n\t\tmtd->line_list[mtd->current].item->expanded = 1;\n\t\tmode_tree_build(mtd);\n\t}\n}\n\nvoid\nmode_tree_collapse_current(struct mode_tree_data *mtd)\n{\n\tif (mtd->line_list[mtd->current].item->expanded) {\n\t\tmtd->line_list[mtd->current].item->expanded = 0;\n\t\tmode_tree_build(mtd);\n\t}\n}\n\nstatic int\nmode_tree_get_tag(struct mode_tree_data *mtd, uint64_t tag, u_int *found)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tif (mtd->line_list[i].item->tag == tag)\n\t\t\tbreak;\n\t}\n\tif (i != mtd->line_size) {\n\t\t*found = i;\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nmode_tree_expand(struct mode_tree_data *mtd, uint64_t tag)\n{\n\tu_int\tfound;\n\n\tif (!mode_tree_get_tag(mtd, tag, &found))\n\t    return;\n\tif (!mtd->line_list[found].item->expanded) {\n\t\tmtd->line_list[found].item->expanded = 1;\n\t\tmode_tree_build(mtd);\n\t}\n}\n\nint\nmode_tree_set_current(struct mode_tree_data *mtd, uint64_t tag)\n{\n\tu_int\tfound;\n\n\tif (mode_tree_get_tag(mtd, tag, &found)) {\n\t\tmtd->current = found;\n\t\tif (mtd->current > mtd->height - 1)\n\t\t\tmtd->offset = mtd->current - mtd->height + 1;\n\t\telse\n\t\t\tmtd->offset = 0;\n\t\treturn (1);\n\t}\n\tif (mtd->current >= mtd->line_size) {\n\t\tmtd->current = mtd->line_size - 1;\n\t\tif (mtd->current > mtd->height - 1)\n\t\t\tmtd->offset = mtd->current - mtd->height + 1;\n\t\telse\n\t\t\tmtd->offset = 0;\n\t}\n\treturn (0);\n}\n\nu_int\nmode_tree_count_tagged(struct mode_tree_data *mtd)\n{\n\tstruct mode_tree_item\t*mti;\n\tu_int\t\t\t i, tagged;\n\n\ttagged = 0;\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tmti = mtd->line_list[i].item;\n\t\tif (mti->tagged)\n\t\t\ttagged++;\n\t}\n\treturn (tagged);\n}\n\nvoid\nmode_tree_each_tagged(struct mode_tree_data *mtd, mode_tree_each_cb cb,\n    struct client *c, key_code key, int current)\n{\n\tstruct mode_tree_item\t*mti;\n\tu_int\t\t\t i;\n\tint\t\t\t fired;\n\n\tfired = 0;\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tmti = mtd->line_list[i].item;\n\t\tif (mti->tagged) {\n\t\t\tfired = 1;\n\t\t\tcb(mtd->modedata, mti->itemdata, c, key);\n\t\t}\n\t}\n\tif (!fired && current) {\n\t\tmti = mtd->line_list[mtd->current].item;\n\t\tcb(mtd->modedata, mti->itemdata, c, key);\n\t}\n}\n\nstruct mode_tree_data *\nmode_tree_start(struct window_pane *wp, struct args *args,\n    mode_tree_build_cb buildcb, mode_tree_draw_cb drawcb,\n    mode_tree_search_cb searchcb, mode_tree_menu_cb menucb,\n    mode_tree_height_cb heightcb, mode_tree_key_cb keycb, void *modedata,\n    const struct menu_item *menu, const char **sort_list, u_int sort_size,\n    struct screen **s)\n{\n\tstruct mode_tree_data\t*mtd;\n\tconst char\t\t*sort;\n\tu_int\t\t\t i;\n\n\tmtd = xcalloc(1, sizeof *mtd);\n\tmtd->references = 1;\n\n\tmtd->wp = wp;\n\tmtd->modedata = modedata;\n\tmtd->menu = menu;\n\n\tmtd->sort_list = sort_list;\n\tmtd->sort_size = sort_size;\n\n\tif (args_has(args, 'N') > 1)\n\t\tmtd->preview = MODE_TREE_PREVIEW_BIG;\n\telse if (args_has(args, 'N'))\n\t\tmtd->preview = MODE_TREE_PREVIEW_OFF;\n\telse\n\t\tmtd->preview = MODE_TREE_PREVIEW_NORMAL;\n\n\tsort = args_get(args, 'O');\n\tif (sort != NULL) {\n\t\tfor (i = 0; i < sort_size; i++) {\n\t\t\tif (strcasecmp(sort, sort_list[i]) == 0)\n\t\t\t\tmtd->sort_crit.field = i;\n\t\t}\n\t}\n\tmtd->sort_crit.reversed = args_has(args, 'r');\n\n\tif (args_has(args, 'f'))\n\t\tmtd->filter = xstrdup(args_get(args, 'f'));\n\telse\n\t\tmtd->filter = NULL;\n\n\tmtd->buildcb = buildcb;\n\tmtd->drawcb = drawcb;\n\tmtd->searchcb = searchcb;\n\tmtd->menucb = menucb;\n\tmtd->heightcb = heightcb;\n\tmtd->keycb = keycb;\n\n\tTAILQ_INIT(&mtd->children);\n\n\t*s = &mtd->screen;\n\tscreen_init(*s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);\n\t(*s)->mode &= ~MODE_CURSOR;\n\n\treturn (mtd);\n}\n\nvoid\nmode_tree_zoom(struct mode_tree_data *mtd, struct args *args)\n{\n\tstruct window_pane\t*wp = mtd->wp;\n\n\tif (args_has(args, 'Z')) {\n\t\tmtd->zoomed = (wp->window->flags & WINDOW_ZOOMED);\n\t\tif (!mtd->zoomed && window_zoom(wp) == 0)\n\t\t\tserver_redraw_window(wp->window);\n\t} else\n\t\tmtd->zoomed = -1;\n}\n\nstatic void\nmode_tree_set_height(struct mode_tree_data *mtd)\n{\n\tstruct screen\t*s = &mtd->screen;\n\tu_int\t\t height;\n\n\tif (mtd->heightcb != NULL) {\n\t\theight = mtd->heightcb(mtd, screen_size_y(s));\n\t\tif (height < screen_size_y(s))\n\t\t    mtd->height = screen_size_y(s) - height;\n\t} else {\n\t\tif (mtd->preview == MODE_TREE_PREVIEW_NORMAL) {\n\t\t\tmtd->height = (screen_size_y(s) / 3) * 2;\n\t\t\tif (mtd->height > mtd->line_size)\n\t\t\t\tmtd->height = screen_size_y(s) / 2;\n\t\t\tif (mtd->height < 10)\n\t\t\t\tmtd->height = screen_size_y(s);\n\t\t} else if (mtd->preview == MODE_TREE_PREVIEW_BIG) {\n\t\t\tmtd->height = screen_size_y(s) / 4;\n\t\t\tif (mtd->height > mtd->line_size)\n\t\t\t\tmtd->height = mtd->line_size;\n\t\t\tif (mtd->height < 2)\n\t\t\t\tmtd->height = 2;\n\t\t} else\n\t\t\tmtd->height = screen_size_y(s);\n\t}\n\tif (screen_size_y(s) - mtd->height < 2)\n\t\tmtd->height = screen_size_y(s);\n}\n\nvoid\nmode_tree_build(struct mode_tree_data *mtd)\n{\n\tstruct screen\t*s = &mtd->screen;\n\tuint64_t\t tag;\n\n\tif (mtd->line_list != NULL)\n\t\ttag = mtd->line_list[mtd->current].item->tag;\n\telse\n\t\ttag = UINT64_MAX;\n\n\tTAILQ_CONCAT(&mtd->saved, &mtd->children, entry);\n\tTAILQ_INIT(&mtd->children);\n\n\tmtd->buildcb(mtd->modedata, &mtd->sort_crit, &tag, mtd->filter);\n\tmtd->no_matches = TAILQ_EMPTY(&mtd->children);\n\tif (mtd->no_matches)\n\t\tmtd->buildcb(mtd->modedata, &mtd->sort_crit, &tag, NULL);\n\n\tmode_tree_free_items(&mtd->saved);\n\tTAILQ_INIT(&mtd->saved);\n\n\tmode_tree_clear_lines(mtd);\n\tmode_tree_build_lines(mtd, &mtd->children, 0);\n\n\tif (mtd->line_list != NULL && tag == UINT64_MAX)\n\t\ttag = mtd->line_list[mtd->current].item->tag;\n\tmode_tree_set_current(mtd, tag);\n\n\tmtd->width = screen_size_x(s);\n\tif (mtd->preview != MODE_TREE_PREVIEW_OFF)\n\t\tmode_tree_set_height(mtd);\n\telse\n\t\tmtd->height = screen_size_y(s);\n\tmode_tree_check_selected(mtd);\n}\n\nstatic void\nmode_tree_remove_ref(struct mode_tree_data *mtd)\n{\n\tif (--mtd->references == 0)\n\t\tfree(mtd);\n}\n\nvoid\nmode_tree_free(struct mode_tree_data *mtd)\n{\n\tstruct window_pane\t*wp = mtd->wp;\n\n\tif (mtd->zoomed == 0)\n\t\tserver_unzoom_window(wp->window);\n\n\tmode_tree_free_items(&mtd->children);\n\tmode_tree_clear_lines(mtd);\n\tscreen_free(&mtd->screen);\n\n\tfree(mtd->search);\n\tfree(mtd->filter);\n\n\tmtd->dead = 1;\n\tmode_tree_remove_ref(mtd);\n}\n\nvoid\nmode_tree_resize(struct mode_tree_data *mtd, u_int sx, u_int sy)\n{\n\tstruct screen\t*s = &mtd->screen;\n\n\tscreen_resize(s, sx, sy, 0);\n\n\tmode_tree_build(mtd);\n\tmode_tree_draw(mtd);\n\n\tmtd->wp->flags |= PANE_REDRAW;\n}\n\nstruct mode_tree_item *\nmode_tree_add(struct mode_tree_data *mtd, struct mode_tree_item *parent,\n    void *itemdata, uint64_t tag, const char *name, const char *text,\n    int expanded)\n{\n\tstruct mode_tree_item\t*mti, *saved;\n\n\tlog_debug(\"%s: %llu, %s %s\", __func__, (unsigned long long)tag,\n\t    name, (text == NULL ? \"\" : text));\n\n\tmti = xcalloc(1, sizeof *mti);\n\tmti->parent = parent;\n\tmti->itemdata = itemdata;\n\n\tmti->tag = tag;\n\tmti->name = xstrdup(name);\n\tif (text != NULL)\n\t\tmti->text = xstrdup(text);\n\n\tsaved = mode_tree_find_item(&mtd->saved, tag);\n\tif (saved != NULL) {\n\t\tif (parent == NULL || parent->expanded)\n\t\t\tmti->tagged = saved->tagged;\n\t\tmti->expanded = saved->expanded;\n\t} else if (expanded == -1)\n\t\tmti->expanded = 1;\n\telse\n\t\tmti->expanded = expanded;\n\n\tTAILQ_INIT(&mti->children);\n\n\tif (parent != NULL)\n\t\tTAILQ_INSERT_TAIL(&parent->children, mti, entry);\n\telse\n\t\tTAILQ_INSERT_TAIL(&mtd->children, mti, entry);\n\n\treturn (mti);\n}\n\nvoid\nmode_tree_draw_as_parent(struct mode_tree_item *mti)\n{\n\tmti->draw_as_parent = 1;\n}\n\nvoid\nmode_tree_no_tag(struct mode_tree_item *mti)\n{\n\tmti->no_tag = 1;\n}\n\nvoid\nmode_tree_remove(struct mode_tree_data *mtd, struct mode_tree_item *mti)\n{\n\tstruct mode_tree_item\t*parent = mti->parent;\n\n\tif (parent != NULL)\n\t\tTAILQ_REMOVE(&parent->children, mti, entry);\n\telse\n\t\tTAILQ_REMOVE(&mtd->children, mti, entry);\n\tmode_tree_free_item(mti);\n}\n\nvoid\nmode_tree_draw(struct mode_tree_data *mtd)\n{\n\tstruct window_pane\t*wp = mtd->wp;\n\tstruct screen\t\t*s = &mtd->screen;\n\tstruct mode_tree_line\t*line;\n\tstruct mode_tree_item\t*mti;\n\tstruct options\t\t*oo = wp->window->options;\n\tstruct screen_write_ctx\t ctx;\n\tstruct grid_cell\t gc0, gc;\n\tu_int\t\t\t w, h, i, j, sy, box_x, box_y, width;\n\tchar\t\t\t*text, *start, *key;\n\tconst char\t\t*tag, *symbol;\n\tsize_t\t\t\t size, n;\n\tint\t\t\t keylen, pad;\n\n\tif (mtd->line_size == 0)\n\t\treturn;\n\n\tmemcpy(&gc0, &grid_default_cell, sizeof gc0);\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tstyle_apply(&gc, oo, \"mode-style\", NULL);\n\n\tw = mtd->width;\n\th = mtd->height;\n\n\tscreen_write_start(&ctx, s);\n\tscreen_write_clearscreen(&ctx, 8);\n\n\tkeylen = 0;\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tmti = mtd->line_list[i].item;\n\t\tif (mti->key == KEYC_NONE)\n\t\t\tcontinue;\n\t\tif ((int)mti->keylen + 3 > keylen)\n\t\t\tkeylen = mti->keylen + 3;\n\t}\n\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tif (i < mtd->offset)\n\t\t\tcontinue;\n\t\tif (i > mtd->offset + h - 1)\n\t\t\tbreak;\n\t\tline = &mtd->line_list[i];\n\t\tmti = line->item;\n\n\t\tscreen_write_cursormove(&ctx, 0, i - mtd->offset, 0);\n\n\t\tpad = keylen - 2 - mti->keylen;\n\t\tif (mti->key != KEYC_NONE)\n\t\t\txasprintf(&key, \"(%s)%*s\", mti->keystr, pad, \"\");\n\t\telse\n\t\t\tkey = xstrdup(\"\");\n\n\t\tif (line->flat)\n\t\t\tsymbol = \"\";\n\t\telse if (TAILQ_EMPTY(&mti->children))\n\t\t\tsymbol = \"  \";\n\t\telse if (mti->expanded)\n\t\t\tsymbol = \"- \";\n\t\telse\n\t\t\tsymbol = \"+ \";\n\n\t\tif (line->depth == 0)\n\t\t\tstart = xstrdup(symbol);\n\t\telse {\n\t\t\tsize = (4 * line->depth) + 32;\n\n\t\t\tstart = xcalloc(1, size);\n\t\t\tfor (j = 1; j < line->depth; j++) {\n\t\t\t\tif (mti->parent != NULL &&\n\t\t\t\t    mtd->line_list[mti->parent->line].last)\n\t\t\t\t\tstrlcat(start, \"    \", size);\n\t\t\t\telse\n\t\t\t\t\tstrlcat(start, \"\\001x\\001   \", size);\n\t\t\t}\n\t\t\tif (line->last)\n\t\t\t\tstrlcat(start, \"\\001mq\\001> \", size);\n\t\t\telse\n\t\t\t\tstrlcat(start, \"\\001tq\\001> \", size);\n\t\t\tstrlcat(start, symbol, size);\n\t\t}\n\n\t\tif (mti->tagged)\n\t\t\ttag = \"*\";\n\t\telse\n\t\t\ttag = \"\";\n\t\txasprintf(&text, \"%-*s%s%s%s%s\", keylen, key, start, mti->name,\n\t\t    tag, (mti->text != NULL) ? \": \" : \"\" );\n\t\twidth = utf8_cstrwidth(text);\n\t\tif (width > w)\n\t\t\twidth = w;\n\t\tfree(start);\n\n\t\tif (mti->tagged) {\n\t\t\tgc.attr ^= GRID_ATTR_BRIGHT;\n\t\t\tgc0.attr ^= GRID_ATTR_BRIGHT;\n\t\t}\n\n\t\tif (i != mtd->current) {\n\t\t\tscreen_write_clearendofline(&ctx, 8);\n\t\t\tscreen_write_nputs(&ctx, w, &gc0, \"%s\", text);\n\t\t\tif (mti->text != NULL) {\n\t\t\t\tformat_draw(&ctx, &gc0, w - width, mti->text,\n\t\t\t\t    NULL, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tscreen_write_clearendofline(&ctx, gc.bg);\n\t\t\tscreen_write_nputs(&ctx, w, &gc, \"%s\", text);\n\t\t\tif (mti->text != NULL) {\n\t\t\t\tformat_draw(&ctx, &gc, w - width, mti->text,\n\t\t\t\t    NULL, 0);\n\t\t\t}\n\t\t}\n\t\tfree(text);\n\t\tfree(key);\n\n\t\tif (mti->tagged) {\n\t\t\tgc.attr ^= GRID_ATTR_BRIGHT;\n\t\t\tgc0.attr ^= GRID_ATTR_BRIGHT;\n\t\t}\n\t}\n\n\tif (mtd->preview == MODE_TREE_PREVIEW_OFF)\n\t\tgoto done;\n\n\tsy = screen_size_y(s);\n\tif (sy <= 4 || h < 2 || sy - h <= 4 || w <= 4)\n\t\tgoto done;\n\n\tline = &mtd->line_list[mtd->current];\n\tmti = line->item;\n\tif (mti->draw_as_parent)\n\t\tmti = mti->parent;\n\n\tscreen_write_cursormove(&ctx, 0, h, 0);\n\tscreen_write_box(&ctx, w, sy - h, BOX_LINES_DEFAULT, NULL, NULL);\n\n\tif (mtd->sort_list != NULL) {\n\t\txasprintf(&text, \" %s (sort: %s%s)\", mti->name,\n\t\t    mtd->sort_list[mtd->sort_crit.field],\n\t\t    mtd->sort_crit.reversed ? \", reversed\" : \"\");\n\t} else\n\t\txasprintf(&text, \" %s\", mti->name);\n\tif (w - 2 >= strlen(text)) {\n\t\tscreen_write_cursormove(&ctx, 1, h, 0);\n\t\tscreen_write_puts(&ctx, &gc0, \"%s\", text);\n\n\t\tif (mtd->no_matches)\n\t\t\tn = (sizeof \"no matches\") - 1;\n\t\telse\n\t\t\tn = (sizeof \"active\") - 1;\n\t\tif (mtd->filter != NULL && w - 2 >= strlen(text) + 10 + n + 2) {\n\t\t\tscreen_write_puts(&ctx, &gc0, \" (filter: \");\n\t\t\tif (mtd->no_matches)\n\t\t\t\tscreen_write_puts(&ctx, &gc, \"no matches\");\n\t\t\telse\n\t\t\t\tscreen_write_puts(&ctx, &gc0, \"active\");\n\t\t\tscreen_write_puts(&ctx, &gc0, \") \");\n\t\t} else\n\t\t\tscreen_write_puts(&ctx, &gc0, \" \");\n\t}\n\tfree(text);\n\n\tbox_x = w - 4;\n\tbox_y = sy - h - 2;\n\n\tif (box_x != 0 && box_y != 0) {\n\t\tscreen_write_cursormove(&ctx, 2, h + 1, 0);\n\t\tmtd->drawcb(mtd->modedata, mti->itemdata, &ctx, box_x, box_y);\n\t}\n\ndone:\n\tscreen_write_cursormove(&ctx, 0, mtd->current - mtd->offset, 0);\n\tscreen_write_stop(&ctx);\n}\n\nstatic struct mode_tree_item *\nmode_tree_search_backward(struct mode_tree_data *mtd)\n{\n    struct mode_tree_item\t*mti, *last, *prev;\n\n    if (mtd->search == NULL)\n\t    return (NULL);\n\n    mti = last = mtd->line_list[mtd->current].item;\n    for (;;) {\n        if ((prev = TAILQ_PREV(mti, mode_tree_list, entry)) != NULL) {\n\t\t/* Point to the last child in the previous subtree. */\n\t\twhile (!TAILQ_EMPTY(&prev->children))\n\t\t\tprev = TAILQ_LAST(&prev->children, mode_tree_list);\n\t\tmti = prev;\n        } else {\n\t\t/* If prev is NULL, jump to the parent. */\n\t\tmti = mti->parent;\n        }\n\n\tif (mti == NULL) {\n\t\t/* Point to the last child in the last root subtree. */\n\t\tprev = TAILQ_LAST(&mtd->children, mode_tree_list);\n\t\twhile (!TAILQ_EMPTY(&prev->children))\n\t\t\tprev = TAILQ_LAST(&prev->children, mode_tree_list);\n\t\tmti = prev;\n\t}\n\tif (mti == last)\n\t\tbreak;\n\n\tif (mtd->searchcb == NULL) {\n\t\tif (strstr(mti->name, mtd->search) != NULL)\n\t\t\treturn (mti);\n\t\tcontinue;\n\t}\n\tif (mtd->searchcb(mtd->modedata, mti->itemdata, mtd->search))\n\t\treturn (mti);\n    }\n    return (NULL);\n}\n\n\nstatic struct mode_tree_item *\nmode_tree_search_forward(struct mode_tree_data *mtd)\n{\n\tstruct mode_tree_item\t*mti, *last, *next;\n\n\tif (mtd->search == NULL)\n\t\treturn (NULL);\n\n\tmti = last = mtd->line_list[mtd->current].item;\n\tfor (;;) {\n\t\tif (!TAILQ_EMPTY(&mti->children))\n\t\t\tmti = TAILQ_FIRST(&mti->children);\n\t\telse if ((next = TAILQ_NEXT(mti, entry)) != NULL)\n\t\t\tmti = next;\n\t\telse {\n\t\t\tfor (;;) {\n\t\t\t\tmti = mti->parent;\n\t\t\t\tif (mti == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((next = TAILQ_NEXT(mti, entry)) != NULL) {\n\t\t\t\t\tmti = next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mti == NULL)\n\t\t\tmti = TAILQ_FIRST(&mtd->children);\n\t\tif (mti == last)\n\t\t\tbreak;\n\n\t\tif (mtd->searchcb == NULL) {\n\t\t\tif (strstr(mti->name, mtd->search) != NULL)\n\t\t\t\treturn (mti);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mtd->searchcb(mtd->modedata, mti->itemdata, mtd->search))\n\t\t\treturn (mti);\n\t}\n\treturn (NULL);\n}\n\nstatic void\nmode_tree_search_set(struct mode_tree_data *mtd)\n{\n\tstruct mode_tree_item\t*mti, *loop;\n\tuint64_t\t\t tag;\n\n\tif (mtd->search_dir == MODE_TREE_SEARCH_FORWARD)\n\t\tmti = mode_tree_search_forward(mtd);\n\telse\n\t\tmti = mode_tree_search_backward(mtd);\n\tif (mti == NULL)\n\t\treturn;\n\ttag = mti->tag;\n\n\tloop = mti->parent;\n\twhile (loop != NULL) {\n\t\tloop->expanded = 1;\n\t\tloop = loop->parent;\n\t}\n\n\tmode_tree_build(mtd);\n\tmode_tree_set_current(mtd, tag);\n\tmode_tree_draw(mtd);\n\tmtd->wp->flags |= PANE_REDRAW;\n}\n\nstatic int\nmode_tree_search_callback(__unused struct client *c, void *data, const char *s,\n    __unused int done)\n{\n\tstruct mode_tree_data\t*mtd = data;\n\n\tif (mtd->dead)\n\t\treturn (0);\n\n\tfree(mtd->search);\n\tif (s == NULL || *s == '\\0') {\n\t\tmtd->search = NULL;\n\t\treturn (0);\n\t}\n\tmtd->search = xstrdup(s);\n\tmode_tree_search_set(mtd);\n\n\treturn (0);\n}\n\nstatic void\nmode_tree_search_free(void *data)\n{\n\tmode_tree_remove_ref(data);\n}\n\nstatic int\nmode_tree_filter_callback(__unused struct client *c, void *data, const char *s,\n    __unused int done)\n{\n\tstruct mode_tree_data\t*mtd = data;\n\n\tif (mtd->dead)\n\t\treturn (0);\n\n\tif (mtd->filter != NULL)\n\t\tfree(mtd->filter);\n\tif (s == NULL || *s == '\\0')\n\t\tmtd->filter = NULL;\n\telse\n\t\tmtd->filter = xstrdup(s);\n\n\tmode_tree_build(mtd);\n\tmode_tree_draw(mtd);\n\tmtd->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n}\n\nstatic void\nmode_tree_filter_free(void *data)\n{\n\tmode_tree_remove_ref(data);\n}\n\nstatic void\nmode_tree_menu_callback(__unused struct menu *menu, __unused u_int idx,\n    key_code key, void *data)\n{\n\tstruct mode_tree_menu\t*mtm = data;\n\tstruct mode_tree_data\t*mtd = mtm->data;\n\n\tif (mtd->dead || key == KEYC_NONE)\n\t\tgoto out;\n\n\tif (mtm->line >= mtd->line_size)\n\t\tgoto out;\n\tmtd->current = mtm->line;\n\tmtd->menucb(mtd->modedata, mtm->c, key);\n\nout:\n\tmode_tree_remove_ref(mtd);\n\tfree(mtm);\n}\n\nstatic void\nmode_tree_display_menu(struct mode_tree_data *mtd, struct client *c, u_int x,\n    u_int y, int outside)\n{\n\tstruct mode_tree_item\t*mti;\n\tstruct menu\t\t*menu;\n\tconst struct menu_item\t*items;\n\tstruct mode_tree_menu\t*mtm;\n\tchar\t\t\t*title;\n\tu_int\t\t\t line;\n\n\tif (mtd->offset + y > mtd->line_size - 1)\n\t\tline = mtd->current;\n\telse\n\t\tline = mtd->offset + y;\n\tmti = mtd->line_list[line].item;\n\n\tif (!outside) {\n\t\titems = mtd->menu;\n\t\txasprintf(&title, \"#[align=centre]%s\", mti->name);\n\t} else {\n\t\titems = mode_tree_menu_items;\n\t\ttitle = xstrdup(\"\");\n\t}\n\tmenu = menu_create(title);\n\tmenu_add_items(menu, items, NULL, c, NULL);\n\tfree(title);\n\n\tmtm = xmalloc(sizeof *mtm);\n\tmtm->data = mtd;\n\tmtm->c = c;\n\tmtm->line = line;\n\tmtd->references++;\n\n\tif (x >= (menu->width + 4) / 2)\n\t\tx -= (menu->width + 4) / 2;\n\telse\n\t\tx = 0;\n\tif (menu_display(menu, 0, 0, NULL, x, y, c, BOX_LINES_DEFAULT, NULL,\n\t    NULL, NULL, NULL, mode_tree_menu_callback, mtm) != 0) {\n\t\tmode_tree_remove_ref(mtd);\n\t\tfree(mtm);\n\t\tmenu_free(menu);\n\t}\n}\n\nint\nmode_tree_key(struct mode_tree_data *mtd, struct client *c, key_code *key,\n    struct mouse_event *m, u_int *xp, u_int *yp)\n{\n\tstruct mode_tree_line\t*line;\n\tstruct mode_tree_item\t*current, *parent, *mti;\n\tu_int\t\t\t i, x, y;\n\tint\t\t\t choice;\n\n\tif (KEYC_IS_MOUSE(*key) && m != NULL) {\n\t\tif (cmd_mouse_at(mtd->wp, m, &x, &y, 0) != 0) {\n\t\t\t*key = KEYC_NONE;\n\t\t\treturn (0);\n\t\t}\n\t\tif (xp != NULL)\n\t\t\t*xp = x;\n\t\tif (yp != NULL)\n\t\t\t*yp = y;\n\t\tif (x > mtd->width || y > mtd->height) {\n\t\t\tif (*key == KEYC_MOUSEDOWN3_PANE)\n\t\t\t\tmode_tree_display_menu(mtd, c, x, y, 1);\n\t\t\tif (mtd->preview == MODE_TREE_PREVIEW_OFF)\n\t\t\t\t*key = KEYC_NONE;\n\t\t\treturn (0);\n\t\t}\n\t\tif (mtd->offset + y < mtd->line_size) {\n\t\t\tif (*key == KEYC_MOUSEDOWN1_PANE ||\n\t\t\t    *key == KEYC_MOUSEDOWN3_PANE ||\n\t\t\t    *key == KEYC_DOUBLECLICK1_PANE)\n\t\t\t\tmtd->current = mtd->offset + y;\n\t\t\tif (*key == KEYC_DOUBLECLICK1_PANE)\n\t\t\t\t*key = '\\r';\n\t\t\telse {\n\t\t\t\tif (*key == KEYC_MOUSEDOWN3_PANE)\n\t\t\t\t\tmode_tree_display_menu(mtd, c, x, y, 0);\n\t\t\t\t*key = KEYC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (*key == KEYC_MOUSEDOWN3_PANE)\n\t\t\t\tmode_tree_display_menu(mtd, c, x, y, 0);\n\t\t\t*key = KEYC_NONE;\n\t\t}\n\t\treturn (0);\n\t}\n\n\tline = &mtd->line_list[mtd->current];\n\tcurrent = line->item;\n\n\tchoice = -1;\n\tfor (i = 0; i < mtd->line_size; i++) {\n\t\tif (*key == mtd->line_list[i].item->key) {\n\t\t\tchoice = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (choice != -1) {\n\t\tif ((u_int)choice > mtd->line_size - 1) {\n\t\t\t*key = KEYC_NONE;\n\t\t\treturn (0);\n\t\t}\n\t\tmtd->current = choice;\n\t\t*key = '\\r';\n\t\treturn (0);\n\t}\n\n\tswitch (*key) {\n\tcase 'q':\n\tcase '\\033': /* Escape */\n\tcase 'g'|KEYC_CTRL:\n\t\treturn (1);\n\tcase KEYC_UP:\n\tcase 'k':\n\tcase KEYC_WHEELUP_PANE:\n\tcase 'p'|KEYC_CTRL:\n\t\tmode_tree_up(mtd, 1);\n\t\tbreak;\n\tcase KEYC_DOWN:\n\tcase 'j':\n\tcase KEYC_WHEELDOWN_PANE:\n\tcase 'n'|KEYC_CTRL:\n\t\tmode_tree_down(mtd, 1);\n\t\tbreak;\n\tcase KEYC_PPAGE:\n\tcase 'b'|KEYC_CTRL:\n\t\tfor (i = 0; i < mtd->height; i++) {\n\t\t\tif (mtd->current == 0)\n\t\t\t\tbreak;\n\t\t\tmode_tree_up(mtd, 1);\n\t\t}\n\t\tbreak;\n\tcase KEYC_NPAGE:\n\tcase 'f'|KEYC_CTRL:\n\t\tfor (i = 0; i < mtd->height; i++) {\n\t\t\tif (mtd->current == mtd->line_size - 1)\n\t\t\t\tbreak;\n\t\t\tmode_tree_down(mtd, 1);\n\t\t}\n\t\tbreak;\n\tcase 'g':\n\tcase KEYC_HOME:\n\t\tmtd->current = 0;\n\t\tmtd->offset = 0;\n\t\tbreak;\n\tcase 'G':\n\tcase KEYC_END:\n\t\tmtd->current = mtd->line_size - 1;\n\t\tif (mtd->current > mtd->height - 1)\n\t\t\tmtd->offset = mtd->current - mtd->height + 1;\n\t\telse\n\t\t\tmtd->offset = 0;\n\t\tbreak;\n\tcase 't':\n\t\t/*\n\t\t * Do not allow parents and children to both be tagged: untag\n\t\t * all parents and children of current.\n\t\t */\n\t\tif (current->no_tag)\n\t\t\tbreak;\n\t\tif (!current->tagged) {\n\t\t\tparent = current->parent;\n\t\t\twhile (parent != NULL) {\n\t\t\t\tparent->tagged = 0;\n\t\t\t\tparent = parent->parent;\n\t\t\t}\n\t\t\tmode_tree_clear_tagged(&current->children);\n\t\t\tcurrent->tagged = 1;\n\t\t} else\n\t\t\tcurrent->tagged = 0;\n\t\tif (m != NULL)\n\t\t\tmode_tree_down(mtd, 0);\n\t\tbreak;\n\tcase 'T':\n\t\tfor (i = 0; i < mtd->line_size; i++)\n\t\t\tmtd->line_list[i].item->tagged = 0;\n\t\tbreak;\n\tcase 't'|KEYC_CTRL:\n\t\tfor (i = 0; i < mtd->line_size; i++) {\n\t\t\tif ((mtd->line_list[i].item->parent == NULL &&\n\t\t\t    !mtd->line_list[i].item->no_tag) ||\n\t\t\t    (mtd->line_list[i].item->parent != NULL &&\n\t\t\t    mtd->line_list[i].item->parent->no_tag))\n\t\t\t\tmtd->line_list[i].item->tagged = 1;\n\t\t\telse\n\t\t\t\tmtd->line_list[i].item->tagged = 0;\n\t\t}\n\t\tbreak;\n\tcase 'O':\n\t\tmtd->sort_crit.field++;\n\t\tif (mtd->sort_crit.field >= mtd->sort_size)\n\t\t\tmtd->sort_crit.field = 0;\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase 'r':\n\t\tmtd->sort_crit.reversed = !mtd->sort_crit.reversed;\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase KEYC_LEFT:\n\tcase 'h':\n\tcase '-':\n\t\tif (line->flat || !current->expanded)\n\t\t\tcurrent = current->parent;\n\t\tif (current == NULL)\n\t\t\tmode_tree_up(mtd, 0);\n\t\telse {\n\t\t\tcurrent->expanded = 0;\n\t\t\tmtd->current = current->line;\n\t\t\tmode_tree_build(mtd);\n\t\t}\n\t\tbreak;\n\tcase KEYC_RIGHT:\n\tcase 'l':\n\tcase '+':\n\t\tif (line->flat || current->expanded)\n\t\t\tmode_tree_down(mtd, 0);\n\t\telse if (!line->flat) {\n\t\t\tcurrent->expanded = 1;\n\t\t\tmode_tree_build(mtd);\n\t\t}\n\t\tbreak;\n\tcase '-'|KEYC_META:\n\t\tTAILQ_FOREACH(mti, &mtd->children, entry)\n\t\t\tmti->expanded = 0;\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase '+'|KEYC_META:\n\t\tTAILQ_FOREACH(mti, &mtd->children, entry)\n\t\t\tmti->expanded = 1;\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase '?':\n\tcase '/':\n\tcase 's'|KEYC_CTRL:\n\t\tmtd->references++;\n\t\tstatus_prompt_set(c, NULL, \"(search) \", \"\",\n\t\t    mode_tree_search_callback, mode_tree_search_free, mtd,\n\t\t    PROMPT_NOFORMAT, PROMPT_TYPE_SEARCH);\n\t\tbreak;\n\tcase 'n':\n\t\tmtd->search_dir = MODE_TREE_SEARCH_FORWARD;\n\t\tmode_tree_search_set(mtd);\n\t\tbreak;\n\tcase 'N':\n\t\tmtd->search_dir = MODE_TREE_SEARCH_BACKWARD;\n\t\tmode_tree_search_set(mtd);\n\t\tbreak;\n\tcase 'f':\n\t\tmtd->references++;\n\t\tstatus_prompt_set(c, NULL, \"(filter) \", mtd->filter,\n\t\t    mode_tree_filter_callback, mode_tree_filter_free, mtd,\n\t\t    PROMPT_NOFORMAT, PROMPT_TYPE_SEARCH);\n\t\tbreak;\n\tcase 'v':\n\t\tswitch (mtd->preview) {\n\t\tcase MODE_TREE_PREVIEW_OFF:\n\t\t\tmtd->preview = MODE_TREE_PREVIEW_BIG;\n\t\t\tbreak;\n\t\tcase MODE_TREE_PREVIEW_NORMAL:\n\t\t\tmtd->preview = MODE_TREE_PREVIEW_OFF;\n\t\t\tbreak;\n\t\tcase MODE_TREE_PREVIEW_BIG:\n\t\t\tmtd->preview = MODE_TREE_PREVIEW_NORMAL;\n\t\t\tbreak;\n\t\t}\n\t\tmode_tree_build(mtd);\n\t\tif (mtd->preview != MODE_TREE_PREVIEW_OFF)\n\t\t\tmode_tree_check_selected(mtd);\n\t\tbreak;\n\t}\n\treturn (0);\n}\n\nvoid\nmode_tree_run_command(struct client *c, struct cmd_find_state *fs,\n    const char *template, const char *name)\n{\n\tstruct cmdq_state\t*state;\n\tchar\t\t\t*command, *error;\n\tenum cmd_parse_status\t status;\n\n\tcommand = cmd_template_replace(template, name, 1);\n\tif (command != NULL && *command != '\\0') {\n\t\tstate = cmdq_new_state(fs, NULL, 0);\n\t\tstatus = cmd_parse_and_append(command, NULL, c, state, &error);\n\t\tif (status == CMD_PARSE_ERROR) {\n\t\t\tif (c != NULL) {\n\t\t\t\t*error = toupper((u_char)*error);\n\t\t\t\tstatus_message_set(c, -1, 1, 0, \"%s\", error);\n\t\t\t}\n\t\t\tfree(error);\n\t\t}\n\t\tcmdq_free_state(state);\n\t}\n\tfree(command);\n}\n"
        },
        {
          "name": "names.c",
          "type": "blob",
          "size": 4.1220703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic void\t name_time_callback(int, short, void *);\nstatic int\t name_time_expired(struct window *, struct timeval *);\n\nstatic char\t*format_window_name(struct window *);\n\nstatic void\nname_time_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window\t*w = arg;\n\n\t/* The event loop will call check_window_name for us on the way out. */\n\tlog_debug(\"@%u name timer expired\", w->id);\n}\n\nstatic int\nname_time_expired(struct window *w, struct timeval *tv)\n{\n\tstruct timeval\toffset;\n\n\ttimersub(tv, &w->name_time, &offset);\n\tif (offset.tv_sec != 0 || offset.tv_usec > NAME_INTERVAL)\n\t\treturn (0);\n\treturn (NAME_INTERVAL - offset.tv_usec);\n}\n\nvoid\ncheck_window_name(struct window *w)\n{\n\tstruct timeval\t tv, next;\n\tchar\t\t*name;\n\tint\t\t left;\n\n\tif (w->active == NULL)\n\t\treturn;\n\n\tif (!options_get_number(w->options, \"automatic-rename\"))\n\t\treturn;\n\n\tif (~w->active->flags & PANE_CHANGED) {\n\t\tlog_debug(\"@%u active pane not changed\", w->id);\n\t\treturn;\n\t}\n\tlog_debug(\"@%u active pane changed\", w->id);\n\n\tgettimeofday(&tv, NULL);\n\tleft = name_time_expired(w, &tv);\n\tif (left != 0) {\n\t\tif (!event_initialized(&w->name_event))\n\t\t\tevtimer_set(&w->name_event, name_time_callback, w);\n\t\tif (!evtimer_pending(&w->name_event, NULL)) {\n\t\t\tlog_debug(\"@%u name timer queued (%d left)\", w->id,\n\t\t\t    left);\n\t\t\ttimerclear(&next);\n\t\t\tnext.tv_usec = left;\n\t\t\tevent_add(&w->name_event, &next);\n\t\t} else {\n\t\t\tlog_debug(\"@%u name timer already queued (%d left)\",\n\t\t\t    w->id, left);\n\t\t}\n\t\treturn;\n\t}\n\tmemcpy(&w->name_time, &tv, sizeof w->name_time);\n\tif (event_initialized(&w->name_event))\n\t\tevtimer_del(&w->name_event);\n\n\tw->active->flags &= ~PANE_CHANGED;\n\n\tname = format_window_name(w);\n\tif (strcmp(name, w->name) != 0) {\n\t\tlog_debug(\"@%u new name %s (was %s)\", w->id, name, w->name);\n\t\twindow_set_name(w, name);\n\t\tserver_redraw_window_borders(w);\n\t\tserver_status_window(w);\n\t} else\n\t\tlog_debug(\"@%u name not changed (still %s)\", w->id, w->name);\n\n\tfree(name);\n}\n\nchar *\ndefault_window_name(struct window *w)\n{\n\tchar\t*cmd, *s;\n\n\tif (w->active == NULL)\n\t\treturn (xstrdup(\"\"));\n\tcmd = cmd_stringify_argv(w->active->argc, w->active->argv);\n\tif (cmd != NULL && *cmd != '\\0')\n\t\ts = parse_window_name(cmd);\n\telse\n\t\ts = parse_window_name(w->active->shell);\n\tfree(cmd);\n\treturn (s);\n}\n\nstatic char *\nformat_window_name(struct window *w)\n{\n\tstruct format_tree\t*ft;\n\tconst char\t\t*fmt;\n\tchar\t\t\t*name;\n\n\tft = format_create(NULL, NULL, FORMAT_WINDOW|w->id, 0);\n\tformat_defaults_window(ft, w);\n\tformat_defaults_pane(ft, w->active);\n\n\tfmt = options_get_string(w->options, \"automatic-rename-format\");\n\tname = format_expand(ft, fmt);\n\n\tformat_free(ft);\n\treturn (name);\n}\n\nchar *\nparse_window_name(const char *in)\n{\n\tchar\t*copy, *name, *ptr;\n\n\tname = copy = xstrdup(in);\n\tif (*name == '\"')\n\t\tname++;\n\tname[strcspn(name, \"\\\"\")] = '\\0';\n\n\tif (strncmp(name, \"exec \", (sizeof \"exec \") - 1) == 0)\n\t\tname = name + (sizeof \"exec \") - 1;\n\n\twhile (*name == ' ' || *name == '-')\n\t\tname++;\n\tif ((ptr = strchr(name, ' ')) != NULL)\n\t\t*ptr = '\\0';\n\n\tif (*name != '\\0') {\n\t\tptr = name + strlen(name) - 1;\n\t\twhile (ptr > name &&\n\t\t    !isalnum((u_char)*ptr) &&\n\t\t    !ispunct((u_char)*ptr))\n\t\t\t*ptr-- = '\\0';\n\t}\n\n\tif (*name == '/')\n\t\tname = basename(name);\n\tname = xstrdup(name);\n\tfree(copy);\n\treturn (name);\n}\n"
        },
        {
          "name": "notify.c",
          "type": "blob",
          "size": 8.501953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct notify_entry {\n\tconst char\t\t*name;\n\tstruct cmd_find_state\t fs;\n\tstruct format_tree\t*formats;\n\n\tstruct client\t\t*client;\n\tstruct session\t\t*session;\n\tstruct window\t\t*window;\n\tint\t\t\t pane;\n\tconst char\t\t*pbname;\n};\n\nstatic struct cmdq_item *\nnotify_insert_one_hook(struct cmdq_item *item, struct notify_entry *ne,\n    struct cmd_list *cmdlist, struct cmdq_state *state)\n{\n\tstruct cmdq_item\t*new_item;\n\tchar\t\t\t*s;\n\n\tif (cmdlist == NULL)\n\t\treturn (item);\n\tif (log_get_level() != 0) {\n\t\ts = cmd_list_print(cmdlist, 0);\n\t\tlog_debug(\"%s: hook %s is: %s\", __func__, ne->name, s);\n\t\tfree(s);\n\t}\n\tnew_item = cmdq_get_command(cmdlist, state);\n\treturn (cmdq_insert_after(item, new_item));\n}\n\nstatic void\nnotify_insert_hook(struct cmdq_item *item, struct notify_entry *ne)\n{\n\tstruct cmd_find_state\t\t fs;\n\tstruct options\t\t\t*oo;\n\tstruct cmdq_state\t\t*state;\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tconst char\t\t\t*value;\n\tstruct cmd_parse_result\t\t*pr;\n\n\tlog_debug(\"%s: inserting hook %s\", __func__, ne->name);\n\n\tcmd_find_clear_state(&fs, 0);\n\tif (cmd_find_empty_state(&ne->fs) || !cmd_find_valid_state(&ne->fs))\n\t\tcmd_find_from_nothing(&fs, 0);\n\telse\n\t\tcmd_find_copy_state(&fs, &ne->fs);\n\n\tif (fs.s == NULL)\n\t\too = global_s_options;\n\telse\n\t\too = fs.s->options;\n\to = options_get(oo, ne->name);\n\tif (o == NULL && fs.wp != NULL) {\n\t\too = fs.wp->options;\n\t\to = options_get(oo, ne->name);\n\t}\n\tif (o == NULL && fs.wl != NULL) {\n\t\too = fs.wl->window->options;\n\t\to = options_get(oo, ne->name);\n\t}\n\tif (o == NULL) {\n\t\tlog_debug(\"%s: hook %s not found\", __func__, ne->name);\n\t\treturn;\n\t}\n\n\tstate = cmdq_new_state(&fs, NULL, CMDQ_STATE_NOHOOKS);\n\tcmdq_add_formats(state, ne->formats);\n\n\tif (*ne->name == '@') {\n\t\tvalue = options_get_string(oo, ne->name);\n\t\tpr = cmd_parse_from_string(value, NULL);\n\t\tswitch (pr->status) {\n\t\tcase CMD_PARSE_ERROR:\n\t\t\tlog_debug(\"%s: can't parse hook %s: %s\", __func__,\n\t\t\t    ne->name, pr->error);\n\t\t\tfree(pr->error);\n\t\t\tbreak;\n\t\tcase CMD_PARSE_SUCCESS:\n\t\t\tnotify_insert_one_hook(item, ne, pr->cmdlist, state);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ta = options_array_first(o);\n\t\twhile (a != NULL) {\n\t\t\tcmdlist = options_array_item_value(a)->cmdlist;\n\t\t\titem = notify_insert_one_hook(item, ne, cmdlist, state);\n\t\t\ta = options_array_next(a);\n\t\t}\n\t}\n\n\tcmdq_free_state(state);\n}\n\nstatic enum cmd_retval\nnotify_callback(struct cmdq_item *item, void *data)\n{\n\tstruct notify_entry\t*ne = data;\n\n\tlog_debug(\"%s: %s\", __func__, ne->name);\n\n\tif (strcmp(ne->name, \"pane-mode-changed\") == 0)\n\t\tcontrol_notify_pane_mode_changed(ne->pane);\n\tif (strcmp(ne->name, \"window-layout-changed\") == 0)\n\t\tcontrol_notify_window_layout_changed(ne->window);\n\tif (strcmp(ne->name, \"window-pane-changed\") == 0)\n\t\tcontrol_notify_window_pane_changed(ne->window);\n\tif (strcmp(ne->name, \"window-unlinked\") == 0)\n\t\tcontrol_notify_window_unlinked(ne->session, ne->window);\n\tif (strcmp(ne->name, \"window-linked\") == 0)\n\t\tcontrol_notify_window_linked(ne->session, ne->window);\n\tif (strcmp(ne->name, \"window-renamed\") == 0)\n\t\tcontrol_notify_window_renamed(ne->window);\n\tif (strcmp(ne->name, \"client-session-changed\") == 0)\n\t\tcontrol_notify_client_session_changed(ne->client);\n\tif (strcmp(ne->name, \"client-detached\") == 0)\n\t\tcontrol_notify_client_detached(ne->client);\n\tif (strcmp(ne->name, \"session-renamed\") == 0)\n\t\tcontrol_notify_session_renamed(ne->session);\n\tif (strcmp(ne->name, \"session-created\") == 0)\n\t\tcontrol_notify_session_created(ne->session);\n\tif (strcmp(ne->name, \"session-closed\") == 0)\n\t\tcontrol_notify_session_closed(ne->session);\n\tif (strcmp(ne->name, \"session-window-changed\") == 0)\n\t\tcontrol_notify_session_window_changed(ne->session);\n\tif (strcmp(ne->name, \"paste-buffer-changed\") == 0)\n\t\tcontrol_notify_paste_buffer_changed(ne->pbname);\n\tif (strcmp(ne->name, \"paste-buffer-deleted\") == 0)\n\t\tcontrol_notify_paste_buffer_deleted(ne->pbname);\n\n\tnotify_insert_hook(item, ne);\n\n\tif (ne->client != NULL)\n\t\tserver_client_unref(ne->client);\n\tif (ne->session != NULL)\n\t\tsession_remove_ref(ne->session, __func__);\n\tif (ne->window != NULL)\n\t\twindow_remove_ref(ne->window, __func__);\n\n\tif (ne->fs.s != NULL)\n\t\tsession_remove_ref(ne->fs.s, __func__);\n\n\tformat_free(ne->formats);\n\tfree((void *)ne->name);\n\tfree((void *)ne->pbname);\n\tfree(ne);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic void\nnotify_add(const char *name, struct cmd_find_state *fs, struct client *c,\n    struct session *s, struct window *w, struct window_pane *wp,\n    const char *pbname)\n{\n\tstruct notify_entry\t*ne;\n\tstruct cmdq_item\t*item;\n\n\titem = cmdq_running(NULL);\n\tif (item != NULL && (cmdq_get_flags(item) & CMDQ_STATE_NOHOOKS))\n\t\treturn;\n\n\tne = xcalloc(1, sizeof *ne);\n\tne->name = xstrdup(name);\n\n\tne->client = c;\n\tne->session = s;\n\tne->window = w;\n\tne->pane = (wp != NULL ? (int)wp->id : -1);\n\tne->pbname = (pbname != NULL ? xstrdup(pbname) : NULL);\n\n\tne->formats = format_create(NULL, NULL, 0, FORMAT_NOJOBS);\n\tformat_add(ne->formats, \"hook\", \"%s\", name);\n\tif (c != NULL)\n\t\tformat_add(ne->formats, \"hook_client\", \"%s\", c->name);\n\tif (s != NULL) {\n\t\tformat_add(ne->formats, \"hook_session\", \"$%u\", s->id);\n\t\tformat_add(ne->formats, \"hook_session_name\", \"%s\", s->name);\n\t}\n\tif (w != NULL) {\n\t\tformat_add(ne->formats, \"hook_window\", \"@%u\", w->id);\n\t\tformat_add(ne->formats, \"hook_window_name\", \"%s\", w->name);\n\t}\n\tif (wp != NULL)\n\t\tformat_add(ne->formats, \"hook_pane\", \"%%%d\", wp->id);\n\tformat_log_debug(ne->formats, __func__);\n\n\tif (c != NULL)\n\t\tc->references++;\n\tif (s != NULL)\n\t\tsession_add_ref(s, __func__);\n\tif (w != NULL)\n\t\twindow_add_ref(w, __func__);\n\n\tcmd_find_copy_state(&ne->fs, fs);\n\tif (ne->fs.s != NULL) /* cmd_find_valid_state needs session */\n\t\tsession_add_ref(ne->fs.s, __func__);\n\n\tcmdq_append(NULL, cmdq_get_callback(notify_callback, ne));\n}\n\nvoid\nnotify_hook(struct cmdq_item *item, const char *name)\n{\n\tstruct cmd_find_state\t*target = cmdq_get_target(item);\n\tstruct notify_entry\t ne;\n\n\tmemset(&ne, 0, sizeof ne);\n\n\tne.name = name;\n\tcmd_find_copy_state(&ne.fs, target);\n\n\tne.client = cmdq_get_client(item);\n\tne.session = target->s;\n\tne.window = target->w;\n\tne.pane = (target->wp != NULL ? (int)target->wp->id : -1);\n\n\tne.formats = format_create(NULL, NULL, 0, FORMAT_NOJOBS);\n\tformat_add(ne.formats, \"hook\", \"%s\", name);\n\tformat_log_debug(ne.formats, __func__);\n\n\tnotify_insert_hook(item, &ne);\n\tformat_free(ne.formats);\n}\n\nvoid\nnotify_client(const char *name, struct client *c)\n{\n\tstruct cmd_find_state\tfs;\n\n\tcmd_find_from_client(&fs, c, 0);\n\tnotify_add(name, &fs, c, NULL, NULL, NULL, NULL);\n}\n\nvoid\nnotify_session(const char *name, struct session *s)\n{\n\tstruct cmd_find_state\tfs;\n\n\tif (session_alive(s))\n\t\tcmd_find_from_session(&fs, s, 0);\n\telse\n\t\tcmd_find_from_nothing(&fs, 0);\n\tnotify_add(name, &fs, NULL, s, NULL, NULL, NULL);\n}\n\nvoid\nnotify_winlink(const char *name, struct winlink *wl)\n{\n\tstruct cmd_find_state\tfs;\n\n\tcmd_find_from_winlink(&fs, wl, 0);\n\tnotify_add(name, &fs, NULL, wl->session, wl->window, NULL, NULL);\n}\n\nvoid\nnotify_session_window(const char *name, struct session *s, struct window *w)\n{\n\tstruct cmd_find_state\tfs;\n\n\tcmd_find_from_session_window(&fs, s, w, 0);\n\tnotify_add(name, &fs, NULL, s, w, NULL, NULL);\n}\n\nvoid\nnotify_window(const char *name, struct window *w)\n{\n\tstruct cmd_find_state\tfs;\n\n\tcmd_find_from_window(&fs, w, 0);\n\tnotify_add(name, &fs, NULL, NULL, w, NULL, NULL);\n}\n\nvoid\nnotify_pane(const char *name, struct window_pane *wp)\n{\n\tstruct cmd_find_state\tfs;\n\n\tcmd_find_from_pane(&fs, wp, 0);\n\tnotify_add(name, &fs, NULL, NULL, NULL, wp, NULL);\n}\n\nvoid\nnotify_paste_buffer(const char *pbname, int deleted)\n{\n  \tstruct cmd_find_state\tfs;\n\n\tcmd_find_clear_state(&fs, 0);\n\tif (deleted) {\n\t\tnotify_add(\"paste-buffer-deleted\", &fs, NULL, NULL, NULL, NULL,\n\t\t    pbname);\n\t} else {\n\t\tnotify_add(\"paste-buffer-changed\", &fs, NULL, NULL, NULL, NULL,\n\t\t    pbname);\n\t}\n}\n"
        },
        {
          "name": "options-table.c",
          "type": "blob",
          "size": 44.1015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * This file has a tables with all the server, session and window\n * options. These tables are the master copy of the options with their real\n * (user-visible) types, range limits and default values. At start these are\n * copied into the runtime global options trees (which only has number and\n * string types). These tables are then used to look up the real type when the\n * user sets an option or its value needs to be shown.\n */\n\n/* Choice option type lists. */\nstatic const char *options_table_mode_keys_list[] = {\n\t\"emacs\", \"vi\", NULL\n};\nstatic const char *options_table_clock_mode_style_list[] = {\n\t\"12\", \"24\", NULL\n};\nstatic const char *options_table_status_list[] = {\n\t\"off\", \"on\", \"2\", \"3\", \"4\", \"5\", NULL\n};\nstatic const char *options_table_message_line_list[] = {\n\t\"0\", \"1\", \"2\", \"3\", \"4\", NULL\n};\nstatic const char *options_table_status_keys_list[] = {\n\t\"emacs\", \"vi\", NULL\n};\nstatic const char *options_table_status_justify_list[] = {\n\t\"left\", \"centre\", \"right\", \"absolute-centre\", NULL\n};\nstatic const char *options_table_status_position_list[] = {\n\t\"top\", \"bottom\", NULL\n};\nstatic const char *options_table_bell_action_list[] = {\n\t\"none\", \"any\", \"current\", \"other\", NULL\n};\nstatic const char *options_table_visual_bell_list[] = {\n\t\"off\", \"on\", \"both\", NULL\n};\nstatic const char *options_table_cursor_style_list[] = {\n\t\"default\", \"blinking-block\", \"block\", \"blinking-underline\", \"underline\",\n\t\"blinking-bar\", \"bar\", NULL\n};\nstatic const char *options_table_pane_scrollbars_list[] = {\n\t\"off\", \"modal\", \"on\", NULL\n};\nstatic const char *options_table_pane_scrollbars_position_list[] = {\n\t\"right\", \"left\", NULL\n};\nstatic const char *options_table_pane_status_list[] = {\n\t\"off\", \"top\", \"bottom\", NULL\n};\nstatic const char *options_table_pane_border_indicators_list[] = {\n\t\"off\", \"colour\", \"arrows\", \"both\", NULL\n};\nstatic const char *options_table_pane_border_lines_list[] = {\n\t\"single\", \"double\", \"heavy\", \"simple\", \"number\", NULL\n};\nstatic const char *options_table_popup_border_lines_list[] = {\n\t\"single\", \"double\", \"heavy\", \"simple\", \"rounded\", \"padded\", \"none\", NULL\n};\nstatic const char *options_table_set_clipboard_list[] = {\n\t\"off\", \"external\", \"on\", NULL\n};\nstatic const char *options_table_window_size_list[] = {\n\t\"largest\", \"smallest\", \"manual\", \"latest\", NULL\n};\nstatic const char *options_table_remain_on_exit_list[] = {\n\t\"off\", \"on\", \"failed\", NULL\n};\nstatic const char *options_table_destroy_unattached_list[] = {\n\t\"off\", \"on\", \"keep-last\", \"keep-group\", NULL\n};\nstatic const char *options_table_detach_on_destroy_list[] = {\n\t\"off\", \"on\", \"no-detached\", \"previous\", \"next\", NULL\n};\nstatic const char *options_table_extended_keys_list[] = {\n\t\"off\", \"on\", \"always\", NULL\n};\nstatic const char *options_table_extended_keys_format_list[] = {\n\t\"csi-u\", \"xterm\", NULL\n};\nstatic const char *options_table_allow_passthrough_list[] = {\n\t\"off\", \"on\", \"all\", NULL\n};\n\n/* Status line format. */\n#define OPTIONS_TABLE_STATUS_FORMAT1 \\\n\t\"#[align=left range=left #{E:status-left-style}]\" \\\n\t\"#[push-default]\" \\\n\t\"#{T;=/#{status-left-length}:status-left}\" \\\n\t\"#[pop-default]\" \\\n\t\"#[norange default]\" \\\n\t\"#[list=on align=#{status-justify}]\" \\\n\t\"#[list=left-marker]<#[list=right-marker]>#[list=on]\" \\\n\t\"#{W:\" \\\n\t\t\"#[range=window|#{window_index} \" \\\n\t\t\t\"#{E:window-status-style}\" \\\n\t\t\t\"#{?#{&&:#{window_last_flag},\" \\\n\t\t\t\t\"#{!=:#{E:window-status-last-style},default}}, \" \\\n\t\t\t\t\"#{E:window-status-last-style},\" \\\n\t\t\t\"}\" \\\n\t\t\t\"#{?#{&&:#{window_bell_flag},\" \\\n\t\t\t\t\"#{!=:#{E:window-status-bell-style},default}}, \" \\\n\t\t\t\t\"#{E:window-status-bell-style},\" \\\n\t\t\t\t\"#{?#{&&:#{||:#{window_activity_flag},\" \\\n\t\t\t\t\t     \"#{window_silence_flag}},\" \\\n\t\t\t\t\t\"#{!=:\" \\\n\t\t\t\t\t\"#{E:window-status-activity-style},\" \\\n\t\t\t\t\t\"default}}, \" \\\n\t\t\t\t\t\"#{E:window-status-activity-style},\" \\\n\t\t\t\t\"}\" \\\n\t\t\t\"}\" \\\n\t\t\"]\" \\\n\t\t\"#[push-default]\" \\\n\t\t\"#{T:window-status-format}\" \\\n\t\t\"#[pop-default]\" \\\n\t\t\"#[norange default]\" \\\n\t\t\"#{?window_end_flag,,#{window-status-separator}}\" \\\n\t\",\" \\\n\t\t\"#[range=window|#{window_index} list=focus \" \\\n\t\t\t\"#{?#{!=:#{E:window-status-current-style},default},\" \\\n\t\t\t\t\"#{E:window-status-current-style},\" \\\n\t\t\t\t\"#{E:window-status-style}\" \\\n\t\t\t\"}\" \\\n\t\t\t\"#{?#{&&:#{window_last_flag},\" \\\n\t\t\t\t\"#{!=:#{E:window-status-last-style},default}}, \" \\\n\t\t\t\t\"#{E:window-status-last-style},\" \\\n\t\t\t\"}\" \\\n\t\t\t\"#{?#{&&:#{window_bell_flag},\" \\\n\t\t\t\t\"#{!=:#{E:window-status-bell-style},default}}, \" \\\n\t\t\t\t\"#{E:window-status-bell-style},\" \\\n\t\t\t\t\"#{?#{&&:#{||:#{window_activity_flag},\" \\\n\t\t\t\t\t     \"#{window_silence_flag}},\" \\\n\t\t\t\t\t\"#{!=:\" \\\n\t\t\t\t\t\"#{E:window-status-activity-style},\" \\\n\t\t\t\t\t\"default}}, \" \\\n\t\t\t\t\t\"#{E:window-status-activity-style},\" \\\n\t\t\t\t\"}\" \\\n\t\t\t\"}\" \\\n\t\t\"]\" \\\n\t\t\"#[push-default]\" \\\n\t\t\"#{T:window-status-current-format}\" \\\n\t\t\"#[pop-default]\" \\\n\t\t\"#[norange list=on default]\" \\\n\t\t\"#{?window_end_flag,,#{window-status-separator}}\" \\\n\t\"}\" \\\n\t\"#[nolist align=right range=right #{E:status-right-style}]\" \\\n\t\"#[push-default]\" \\\n\t\"#{T;=/#{status-right-length}:status-right}\" \\\n\t\"#[pop-default]\" \\\n\t\"#[norange default]\"\n#define OPTIONS_TABLE_STATUS_FORMAT2 \\\n\t\"#[align=centre]#{P:#{?pane_active,#[reverse],}\" \\\n\t\"#{pane_index}[#{pane_width}x#{pane_height}]#[default] }\"\nstatic const char *options_table_status_format_default[] = {\n\tOPTIONS_TABLE_STATUS_FORMAT1, OPTIONS_TABLE_STATUS_FORMAT2, NULL\n};\n\n/* Helpers for hook options. */\n#define OPTIONS_TABLE_HOOK(hook_name, default_value) \\\n\t{ .name = hook_name, \\\n\t  .type = OPTIONS_TABLE_COMMAND, \\\n\t  .scope = OPTIONS_TABLE_SESSION, \\\n\t  .flags = OPTIONS_TABLE_IS_ARRAY|OPTIONS_TABLE_IS_HOOK, \\\n\t  .default_str = default_value,\t\\\n\t  .separator = \"\" \\\n\t}\n\n#define OPTIONS_TABLE_PANE_HOOK(hook_name, default_value) \\\n\t{ .name = hook_name, \\\n\t  .type = OPTIONS_TABLE_COMMAND, \\\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE, \\\n\t  .flags = OPTIONS_TABLE_IS_ARRAY|OPTIONS_TABLE_IS_HOOK, \\\n\t  .default_str = default_value,\t\\\n\t  .separator = \"\" \\\n\t}\n\n#define OPTIONS_TABLE_WINDOW_HOOK(hook_name, default_value) \\\n\t{ .name = hook_name, \\\n\t  .type = OPTIONS_TABLE_COMMAND, \\\n\t  .scope = OPTIONS_TABLE_WINDOW, \\\n\t  .flags = OPTIONS_TABLE_IS_ARRAY|OPTIONS_TABLE_IS_HOOK, \\\n\t  .default_str = default_value,\t\\\n\t  .separator = \"\" \\\n\t}\n\n/* Map of name conversions. */\nconst struct options_name_map options_other_names[] = {\n\t{ \"display-panes-color\", \"display-panes-colour\" },\n\t{ \"display-panes-active-color\", \"display-panes-active-colour\" },\n\t{ \"clock-mode-color\", \"clock-mode-colour\" },\n\t{ \"cursor-color\", \"cursor-colour\" },\n\t{ \"prompt-cursor-color\", \"prompt-cursor-colour\" },\n\t{ \"pane-colors\", \"pane-colours\" },\n\t{ NULL, NULL }\n};\n\n/* Top-level options. */\nconst struct options_table_entry options_table[] = {\n\t/* Server options. */\n\t{ .name = \"backspace\",\n\t  .type = OPTIONS_TABLE_KEY,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = '\\177',\n\t  .text = \"The key to send for backspace.\"\n\t},\n\n\t{ .name = \"buffer-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 50,\n\t  .text = \"The maximum number of automatic buffers. \"\n\t\t  \"When this is reached, the oldest buffer is deleted.\"\n\t},\n\n\t{ .name = \"command-alias\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"split-pane=split-window,\"\n\t\t\t \"splitp=split-window,\"\n\t\t\t \"server-info=show-messages -JT,\"\n\t\t\t \"info=show-messages -JT,\"\n\t\t\t \"choose-window=choose-tree -w,\"\n\t\t\t \"choose-session=choose-tree -s\",\n\t  .separator = \",\",\n\t  .text = \"Array of command aliases. \"\n\t\t  \"Each entry is an alias and a command separated by '='.\"\n\t},\n\n\t{ .name = \"codepoint-widths\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"\",\n\t  .separator = \",\",\n\t  .text = \"Array of override widths for Unicode codepoints.\"\n\t},\n\n\t{ .name = \"copy-command\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\",\n\t  .text = \"Shell command run when text is copied. \"\n\t\t  \"If empty, no command is run.\"\n\t},\n\n\t{ .name = \"cursor-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = -1,\n\t  .text = \"Colour of the cursor.\"\n\t},\n\n\t{ .name = \"cursor-style\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .choices = options_table_cursor_style_list,\n\t  .default_num = 0,\n\t  .text = \"Style of the cursor.\"\n\t},\n\n\t{ .name = \"default-terminal\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = TMUX_TERM,\n\t  .text = \"Default for the 'TERM' environment variable.\"\n\t},\n\n\t{ .name = \"editor\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = _PATH_VI,\n\t  .text = \"Editor run to edit files.\"\n\t},\n\n\t{ .name = \"escape-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 10,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Time to wait before assuming a key is Escape.\"\n\t},\n\n\t{ .name = \"exit-empty\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 1,\n\t  .text = \"Whether the server should exit if there are no sessions.\"\n\t},\n\n\t{ .name = \"exit-unattached\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 0,\n\t  .text = \"Whether the server should exit if there are no attached \"\n\t\t  \"clients.\"\n\t},\n\n\t{ .name = \"extended-keys\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .choices = options_table_extended_keys_list,\n\t  .default_num = 0,\n\t  .text = \"Whether to request extended key sequences from terminals \"\n\t\t  \"that support it.\"\n\t},\n\n\t{ .name = \"extended-keys-format\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .choices = options_table_extended_keys_format_list,\n\t  .default_num = 1,\n\t  .text = \"The format of emitted extended key sequences.\"\n\t},\n\n\t{ .name = \"focus-events\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 0,\n\t  .text = \"Whether to send focus events to applications.\"\n\t},\n\n\t{ .name = \"history-file\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\",\n\t  .text = \"Location of the command prompt history file. \"\n\t\t  \"Empty does not write a history file.\"\n\t},\n\n\t{ .name = \"input-buffer-size\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = INPUT_BUF_DEFAULT_SIZE,\n\t  .maximum = UINT_MAX,\n\t  .default_num = INPUT_BUF_DEFAULT_SIZE,\n\t  .text = \"Number of byte accpted in a single input before dropping.\"\n\t},\n\n\t{ .name = \"menu-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .default_str = \"default\",\n\t  .separator = \",\",\n\t  .text = \"Default style of menu.\"\n\t},\n\n\t{ .name = \"menu-selected-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .default_str = \"bg=yellow,fg=black\",\n\t  .separator = \",\",\n\t  .text = \"Default style of selected menu item.\"\n\t},\n\n\t{ .name = \"menu-border-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Default style of menu borders.\"\n\t},\n\n\t{ .name = \"menu-border-lines\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_popup_border_lines_list,\n\t  .default_num = BOX_LINES_SINGLE,\n\t  .text = \"Type of characters used to draw menu border lines. Some of \"\n\t          \"these are only supported on terminals with UTF-8 support.\"\n\t},\n\n\t{ .name = \"message-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 1000,\n\t  .text = \"Maximum number of server messages to keep.\"\n\t},\n\n\t{ .name = \"prefix-timeout\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0,\n\t  .unit = \"milliseconds\",\n\t  .text = \"The timeout for the prefix key if no subsequent key is \"\n\t          \"pressed. Zero means disabled.\"\n\t},\n\n\t{ .name = \"prompt-history-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 100,\n\t  .text = \"Maximum number of commands to keep in history.\"\n\t},\n\n\t{ .name = \"set-clipboard\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .choices = options_table_set_clipboard_list,\n\t  .default_num = 1,\n\t  .text = \"Whether to attempt to set the system clipboard ('on' or \"\n\t\t  \"'external') and whether to allow applications to create \"\n\t\t  \"paste buffers with an escape sequence ('on' only).\"\n\t},\n\n\t{ .name = \"terminal-overrides\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"linux*:AX@\",\n\t  .separator = \",\",\n\t  .text = \"List of terminal capabilities overrides.\"\n\t},\n\n\t{ .name = \"terminal-features\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"xterm*:clipboard:ccolour:cstyle:focus:title,\"\n\t\t\t \"screen*:title,\"\n\t                 \"rxvt*:ignorefkeys\",\n\t  .separator = \",\",\n\t  .text = \"List of terminal features, used if they cannot be \"\n\t\t  \"automatically detected.\"\n\t},\n\n\t{ .name = \"user-keys\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"\",\n\t  .separator = \",\",\n\t  .text = \"User key assignments. \"\n\t\t  \"Each sequence in the list is translated into a key: \"\n\t\t  \"'User0', 'User1' and so on.\"\n\t},\n\n\t/* Session options. */\n\t{ .name = \"activity-action\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_bell_action_list,\n\t  .default_num = ALERT_OTHER,\n\t  .text = \"Action to take on an activity alert.\"\n\t},\n\n\t{ .name = \"assume-paste-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 1,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Maximum time between input to assume it is pasting rather \"\n\t\t  \"than typing.\"\n\t},\n\n\t{ .name = \"base-index\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0,\n\t  .text = \"Default index of the first window in each session.\"\n\t},\n\n\t{ .name = \"bell-action\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_bell_action_list,\n\t  .default_num = ALERT_ANY,\n\t  .text = \"Action to take on a bell alert.\"\n\t},\n\n\t{ .name = \"default-command\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"\",\n\t  .text = \"Default command to run in new panes. If empty, a shell is \"\n\t\t  \"started.\"\n\t},\n\n\t{ .name = \"default-shell\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = _PATH_BSHELL,\n\t  .text = \"Location of default shell.\"\n\t},\n\n\t{ .name = \"default-size\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .pattern = \"[0-9]*x[0-9]*\",\n\t  .default_str = \"80x24\",\n\t  .text = \"Initial size of new sessions.\"\n\t},\n\n\t{ .name = \"destroy-unattached\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_destroy_unattached_list,\n\t  .default_num = 0,\n\t  .text = \"Whether to destroy sessions when they have no attached \"\n\t\t  \"clients, or keep the last session whether in the group.\"\n\t},\n\n\t{ .name = \"detach-on-destroy\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_detach_on_destroy_list,\n\t  .default_num = 1,\n\t  .text = \"Whether to detach when a session is destroyed, or switch \"\n\t\t  \"the client to another session if any exist.\"\n\t},\n\n\t{ .name = \"display-panes-active-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 1,\n\t  .text = \"Colour of the active pane for 'display-panes'.\"\n\t},\n\n\t{ .name = \"display-panes-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 4,\n\t  .text = \"Colour of not active panes for 'display-panes'.\"\n\t},\n\n\t{ .name = \"display-panes-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 1000,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Time for which 'display-panes' should show pane numbers.\"\n\t},\n\n\t{ .name = \"display-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 750,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Time for which status line messages should appear.\"\n\t},\n\n\t{ .name = \"history-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 2000,\n\t  .unit = \"lines\",\n\t  .text = \"Maximum number of lines to keep in the history for each \"\n\t\t  \"pane. \"\n\t\t  \"If changed, the new value applies only to new panes.\"\n\t},\n\n\t{ .name = \"initial-repeat-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = 2000000,\n\t  .default_num = 0,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Time to wait for a key binding to repeat the first time the \"\n\t          \"key is pressed, if it is bound with the '-r' flag. \"\n\t          \"Subsequent presses use the 'repeat-time' option.\"\n\t},\n\n\t{ .name = \"key-table\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"root\",\n\t  .text = \"Default key table. \"\n\t\t  \"Key presses are first looked up in this table.\"\n\t},\n\n\t{ .name = \"lock-after-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0,\n\t  .unit = \"seconds\",\n\t  .text = \"Time after which a client is locked if not used.\"\n\t},\n\n\t{ .name = \"lock-command\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = TMUX_LOCK_CMD,\n\t  .text = \"Shell command to run to lock a client.\"\n\t},\n\n\t{ .name = \"message-command-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=black,fg=yellow\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the command prompt when in command mode, if \"\n\t\t  \"'mode-keys' is set to 'vi'.\"\n\t},\n\n\t{ .name = \"message-line\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_message_line_list,\n\t  .default_num = 0,\n\t  .text = \"Position (line) of messages and the command prompt.\"\n\t},\n\n\t{ .name = \"message-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=yellow,fg=black\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of messages and the command prompt.\"\n\t},\n\n\t{ .name = \"mouse\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .text = \"Whether the mouse is recognised and mouse key bindings are \"\n\t\t  \"executed. \"\n\t\t  \"Applications inside panes can use the mouse even when 'off'.\"\n\t},\n\n\t{ .name = \"prefix\",\n\t  .type = OPTIONS_TABLE_KEY,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 'b'|KEYC_CTRL,\n\t  .text = \"The prefix key.\"\n\t},\n\n\t{ .name = \"prefix2\",\n\t  .type = OPTIONS_TABLE_KEY,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = KEYC_NONE,\n\t  .text = \"A second prefix key.\"\n\t},\n\n\t{ .name = \"renumber-windows\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .text = \"Whether windows are automatically renumbered rather than \"\n\t\t  \"leaving gaps.\"\n\t},\n\n\t{ .name = \"repeat-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = 2000000,\n\t  .default_num = 500,\n\t  .unit = \"milliseconds\",\n\t  .text = \"Time to wait for a key binding to repeat, if it is bound \"\n\t\t  \"with the '-r' flag.\"\n\t},\n\n\t{ .name = \"set-titles\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .text = \"Whether to set the terminal title, if supported.\"\n\t},\n\n\t{ .name = \"set-titles-string\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"#S:#I:#W - \\\"#T\\\" #{session_alerts}\",\n\t  .text = \"Format of the terminal title to set.\"\n\t},\n\n\t{ .name = \"silence-action\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_bell_action_list,\n\t  .default_num = ALERT_OTHER,\n\t  .text = \"Action to take on a silence alert.\"\n\t},\n\n\t{ .name = \"status\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_list,\n\t  .default_num = 1,\n\t  .text = \"Number of lines in the status line.\"\n\t},\n\n\t{ .name = \"status-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .text = \"Background colour of the status line. This option is \"\n\t\t  \"deprecated, use 'status-style' instead.\"\n\t},\n\n\t{ .name = \"status-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .text = \"Foreground colour of the status line. This option is \"\n\t\t  \"deprecated, use 'status-style' instead.\"\n\t},\n\n\t{ .name = \"status-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_arr = options_table_status_format_default,\n\t  .text = \"Formats for the status lines. \"\n\t\t  \"Each array member is the format for one status line. \"\n\t\t  \"The default status line is made up of several components \"\n\t\t  \"which may be configured individually with other options such \"\n\t\t  \"as 'status-left'.\"\n\t},\n\n\t{ .name = \"status-interval\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 15,\n\t  .unit = \"seconds\",\n\t  .text = \"Number of seconds between status line updates.\"\n\t},\n\n\t{ .name = \"status-justify\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_justify_list,\n\t  .default_num = 0,\n\t  .text = \"Position of the window list in the status line.\"\n\t},\n\n\t{ .name = \"status-keys\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_keys_list,\n\t  .default_num = MODEKEY_EMACS,\n\t  .text = \"Key set to use at the command prompt.\"\n\t},\n\n\t{ .name = \"status-left\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"[#{session_name}] \",\n\t  .text = \"Contents of the left side of the status line.\"\n\t},\n\n\t{ .name = \"status-left-length\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = SHRT_MAX,\n\t  .default_num = 10,\n\t  .text = \"Maximum width of the left side of the status line.\"\n\t},\n\n\t{ .name = \"status-left-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the left side of the status line.\"\n\t},\n\n\t{ .name = \"status-position\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_position_list,\n\t  .default_num = 1,\n\t  .text = \"Position of the status line.\"\n\t},\n\n\t{ .name = \"status-right\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"#{?window_bigger,\"\n\t\t\t \"[#{window_offset_x}#,#{window_offset_y}] ,}\"\n\t\t\t \"\\\"#{=21:pane_title}\\\" %H:%M %d-%b-%y\",\n\t  .text = \"Contents of the right side of the status line.\"\n\n\t},\n\n\t{ .name = \"status-right-length\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = SHRT_MAX,\n\t  .default_num = 40,\n\t  .text = \"Maximum width of the right side of the status line.\"\n\t},\n\n\t{ .name = \"status-right-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the right side of the status line.\"\n\t},\n\n\t{ .name = \"status-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=green,fg=black\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the status line.\"\n\t},\n\n\t{ .name = \"prompt-cursor-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 6,\n\t  .text = \"Colour of the cursor when in the command prompt.\"\n\t},\n\n\t{ .name = \"prompt-cursor-style\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_cursor_style_list,\n\t  .default_num = 0,\n\t  .text = \"Style of the cursor when in the command prompt.\"\n\t},\n\n\t{ .name = \"update-environment\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .default_str = \"DISPLAY KRB5CCNAME MSYSTEM SSH_ASKPASS SSH_AUTH_SOCK \"\n\t\t\t \"SSH_AGENT_PID SSH_CONNECTION WINDOWID XAUTHORITY\",\n\t  .text = \"List of environment variables to update in the session \"\n\t\t  \"environment when a client is attached.\"\n\t},\n\n\t{ .name = \"visual-activity\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_visual_bell_list,\n\t  .default_num = VISUAL_OFF,\n\t  .text = \"How activity alerts should be shown: a message ('on'), \"\n\t\t  \"a message and a bell ('both') or nothing ('off').\"\n\t},\n\n\t{ .name = \"visual-bell\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_visual_bell_list,\n\t  .default_num = VISUAL_OFF,\n\t  .text = \"How bell alerts should be shown: a message ('on'), \"\n\t\t  \"a message and a bell ('both') or nothing ('off').\"\n\t},\n\n\t{ .name = \"visual-silence\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_visual_bell_list,\n\t  .default_num = VISUAL_OFF,\n\t  .text = \"How silence alerts should be shown: a message ('on'), \"\n\t\t  \"a message and a bell ('both') or nothing ('off').\"\n\t},\n\n\t{ .name = \"word-separators\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  /*\n\t   * The set of non-alphanumeric printable ASCII characters minus the\n\t   * underscore.\n\t   */\n\t  .default_str = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^`{|}~\",\n\t  .text = \"Characters considered to separate words.\"\n\t},\n\n\t/* Window options. */\n\t{ .name = \"aggressive-resize\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .text = \"When 'window-size' is 'smallest', whether the maximum size \"\n\t\t  \"of a window is the smallest attached session where it is \"\n\t\t  \"the current window ('on') or the smallest session it is \"\n\t\t  \"linked to ('off').\"\n\t},\n\n\t{ .name = \"allow-passthrough\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .choices = options_table_allow_passthrough_list,\n\t  .default_num = 0,\n\t  .text = \"Whether applications are allowed to use the escape sequence \"\n\t\t  \"to bypass tmux. Can be 'off' (disallowed), 'on' (allowed \"\n\t\t  \"if the pane is visible), or 'all' (allowed even if the pane \"\n\t\t  \"is invisible).\"\n\t},\n\n\t{ .name = \"allow-rename\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = 0,\n\t  .text = \"Whether applications are allowed to use the escape sequence \"\n\t\t  \"to rename windows.\"\n\t},\n\n\t{ .name = \"allow-set-title\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = 1,\n\t  .text = \"Whether applications are allowed to use the escape sequence \"\n\t\t  \"to set the pane title.\"\n\t},\n\n\t{ .name = \"alternate-screen\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = 1,\n\t  .text = \"Whether applications are allowed to use the alternate \"\n\t\t  \"screen.\"\n\t},\n\n\t{ .name = \"automatic-rename\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1,\n\t  .text = \"Whether windows are automatically renamed.\"\n\t},\n\n\t{ .name = \"automatic-rename-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#{?pane_in_mode,[tmux],#{pane_current_command}}\"\n\t\t\t \"#{?pane_dead,[dead],}\",\n\t  .text = \"Format used to automatically rename windows.\"\n\t},\n\n\t{ .name = \"clock-mode-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 4,\n\t  .text = \"Colour of the clock in clock mode.\"\n\t},\n\n\t{ .name = \"clock-mode-style\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_clock_mode_style_list,\n\t  .default_num = 1,\n\t  .text = \"Time format of the clock in clock mode.\"\n\t},\n\n\t{ .name = \"copy-mode-match-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"bg=cyan,fg=black\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of search matches in copy mode.\"\n\t},\n\n\t{ .name = \"copy-mode-current-match-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"bg=magenta,fg=black\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the current search match in copy mode.\"\n\t},\n\n\t{ .name = \"copy-mode-mark-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"bg=red,fg=black\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the marked line in copy mode.\"\n\t},\n\n\t{ .name = \"copy-mode-position-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"#[align=right]\"\n\t                 \"#{t/p:top_line_time}#{?#{e|>:#{top_line_time},0}, ,}\"\n\t                 \"[#{scroll_position}/#{history_size}]\"\n\t                 \"#{?search_timed_out, (timed out),\"\n\t                 \"#{?search_count, (#{search_count}\"\n\t                 \"#{?search_count_partial,+,} results),}}\",\n\t  .text = \"Format of the position indicator in copy mode.\"\n\t},\n\n\t{ .name = \"copy-mode-position-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#{mode-style}\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of position indicator in copy mode.\"\n\t},\n\n\t{ .name = \"copy-mode-selection-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#{mode-style}\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of selection in copy mode.\"\n\t},\n\n\t{ .name = \"fill-character\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"\",\n\t  .text = \"Character used to fill unused parts of window.\"\n\t},\n\n\t{ .name = \"main-pane-height\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"24\",\n\t  .text = \"Height of the main pane in the 'main-horizontal' layout. \"\n\t\t  \"This may be a percentage, for example '10%'.\"\n\t},\n\n\t{ .name = \"main-pane-width\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"80\",\n\t  .text = \"Width of the main pane in the 'main-vertical' layout. \"\n\t\t  \"This may be a percentage, for example '10%'.\"\n\t},\n\n\t{ .name = \"mode-keys\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_mode_keys_list,\n\t  .default_num = MODEKEY_EMACS,\n\t  .text = \"Key set used in copy mode.\"\n\t},\n\n\t{ .name = \"mode-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .default_str = \"bg=yellow,fg=black\",\n\t  .separator = \",\",\n\t  .text = \"Style of indicators and highlighting in modes.\"\n\t},\n\n\t{ .name = \"monitor-activity\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .text = \"Whether an alert is triggered by activity.\"\n\t},\n\n\t{ .name = \"monitor-bell\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1,\n\t  .text = \"Whether an alert is triggered by a bell.\"\n\t},\n\n\t{ .name = \"monitor-silence\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0,\n\t  .text = \"Time after which an alert is triggered by silence. \"\n\t\t  \"Zero means no alert.\"\n\n\t},\n\n\t{ .name = \"other-pane-height\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"0\",\n\t  .text = \"Height of the other panes in the 'main-horizontal' layout. \"\n\t\t  \"This may be a percentage, for example '10%'.\"\n\t},\n\n\t{ .name = \"other-pane-width\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"0\",\n\t  .text = \"Height of the other panes in the 'main-vertical' layout. \"\n\t\t  \"This may be a percentage, for example '10%'.\"\n\t},\n\n\t{ .name = \"pane-active-border-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#{?pane_in_mode,fg=yellow,#{?synchronize-panes,fg=red,fg=green}}\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the active pane border.\"\n\t},\n\n\t{ .name = \"pane-base-index\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = USHRT_MAX,\n\t  .default_num = 0,\n\t  .text = \"Index of the first pane in each window.\"\n\t},\n\n\t{ .name = \"pane-border-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"#{?pane_active,#[reverse],}#{pane_index}#[default] \"\n\t\t\t \"\\\"#{pane_title}\\\"\",\n\t  .text = \"Format of text in the pane status lines.\"\n\t},\n\n\t{ .name = \"pane-border-indicators\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_pane_border_indicators_list,\n\t  .default_num = PANE_BORDER_COLOUR,\n\t  .text = \"Whether to indicate the active pane by colouring border or \"\n\t\t  \"displaying arrow markers.\"\n\t},\n\n\t{ .name = \"pane-border-lines\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_pane_border_lines_list,\n\t  .default_num = PANE_LINES_SINGLE,\n\t  .text = \"Type of characters used to draw pane border lines. Some of \"\n\t\t  \"these are only supported on terminals with UTF-8 support.\"\n\t},\n\n\t{ .name = \"pane-border-status\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_pane_status_list,\n\t  .default_num = PANE_STATUS_OFF,\n\t  .text = \"Position of the pane status lines.\"\n\t},\n\n\t{ .name = \"pane-border-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the pane status lines.\"\n\t},\n\n\t{ .name = \"pane-colours\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"\",\n\t  .flags = OPTIONS_TABLE_IS_ARRAY,\n\t  .text = \"The default colour palette for colours zero to 255.\"\n\t},\n\n\t{ .name = \"pane-scrollbars\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_pane_scrollbars_list,\n\t  .default_num = PANE_SCROLLBARS_OFF,\n\t  .text = \"Pane scrollbar state.\"\n\t},\n\n\t{ .name = \"pane-scrollbars-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"bg=black,fg=white,width=1,pad=0\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the pane scrollbar.\"\n\t},\n\n\t{ .name = \"pane-scrollbars-position\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_pane_scrollbars_position_list,\n\t  .default_num = PANE_SCROLLBARS_RIGHT,\n\t  .text = \"Pane scrollbar position.\"\n\t},\n\n        { .name = \"popup-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Default style of popups.\"\n\t},\n\n\t{ .name = \"popup-border-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Default style of popup borders.\"\n\t},\n\n\t{ .name = \"popup-border-lines\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_popup_border_lines_list,\n\t  .default_num = BOX_LINES_SINGLE,\n\t  .text = \"Type of characters used to draw popup border lines. Some of \"\n\t\t  \"these are only supported on terminals with UTF-8 support.\"\n\t},\n\n\t{ .name = \"remain-on-exit\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .choices = options_table_remain_on_exit_list,\n\t  .default_num = 0,\n\t  .text = \"Whether panes should remain ('on') or be automatically \"\n\t\t  \"killed ('off' or 'failed') when the program inside exits.\"\n\t},\n\n\t{ .name = \"remain-on-exit-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"Pane is dead (\"\n\t\t\t \"#{?#{!=:#{pane_dead_status},},\"\n\t                 \"status #{pane_dead_status},}\"\n\t\t\t \"#{?#{!=:#{pane_dead_signal},},\"\n\t                 \"signal #{pane_dead_signal},}, \"\n\t\t\t \"#{t:pane_dead_time})\",\n\t  .text = \"Message shown after the program in a pane has exited, if \"\n\t          \"remain-on-exit is enabled.\"\n\t},\n\n\t{ .name = \"scroll-on-clear\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = 1,\n\t  .text = \"Whether the contents of the screen should be scrolled into\"\n\t\t  \"history when clearing the whole screen.\"\n\t},\n\n\t{ .name = \"synchronize-panes\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_num = 0,\n\t  .text = \"Whether typing should be sent to all panes simultaneously.\"\n\t},\n\n\t{ .name = \"window-active-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Default style of the active pane.\"\n\t},\n\n\t{ .name = \"window-size\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_window_size_list,\n\t  .default_num = WINDOW_SIZE_LATEST,\n\t  .text = \"How window size is calculated. \"\n\t\t  \"'latest' uses the size of the most recently used client, \"\n\t\t  \"'largest' the largest client, 'smallest' the smallest \"\n\t\t  \"client and 'manual' a size set by the 'resize-window' \"\n\t\t  \"command.\"\n\t},\n\n\t{ .name = \"window-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Default style of panes that are not the active pane.\"\n\t},\n\n\t{ .name = \"window-status-activity-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"reverse\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of windows in the status line with an activity alert.\"\n\t},\n\n\t{ .name = \"window-status-bell-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"reverse\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of windows in the status line with a bell alert.\"\n\t},\n\n\t{ .name = \"window-status-current-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#I:#W#{?window_flags,#{window_flags}, }\",\n\t  .text = \"Format of the current window in the status line.\"\n\t},\n\n\t{ .name = \"window-status-current-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the current window in the status line.\"\n\t},\n\n\t{ .name = \"window-status-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#I:#W#{?window_flags,#{window_flags}, }\",\n\t  .text = \"Format of windows in the status line, except the current \"\n\t\t  \"window.\"\n\t},\n\n\t{ .name = \"window-status-last-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of the last window in the status line.\"\n\t},\n\n\t{ .name = \"window-status-separator\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \" \",\n\t  .text = \"Separator between windows in the status line.\"\n\t},\n\n\t{ .name = \"window-status-style\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\",\n\t  .flags = OPTIONS_TABLE_IS_STYLE,\n\t  .separator = \",\",\n\t  .text = \"Style of windows in the status line, except the current and \"\n\t\t  \"last windows.\"\n\t},\n\n\t{ .name = \"wrap-search\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1,\n\t  .text = \"Whether searching in copy mode should wrap at the top or \"\n\t\t  \"bottom.\"\n\t},\n\n\t{ .name = \"xterm-keys\", /* no longer used */\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1,\n\t  .text = \"Whether xterm-style function key sequences should be sent. \"\n\t\t  \"This option is no longer used.\"\n\t},\n\n\t/* Hook options. */\n\tOPTIONS_TABLE_HOOK(\"after-bind-key\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-capture-pane\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-copy-mode\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-display-message\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-display-panes\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-kill-pane\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-buffers\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-clients\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-keys\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-panes\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-sessions\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-list-windows\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-load-buffer\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-lock-server\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-new-session\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-new-window\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-paste-buffer\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-pipe-pane\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-queue\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-refresh-client\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-rename-session\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-rename-window\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-resize-pane\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-resize-window\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-save-buffer\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-select-layout\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-select-pane\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-select-window\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-send-keys\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-set-buffer\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-set-environment\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-set-hook\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-set-option\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-show-environment\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-show-messages\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-show-options\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-split-window\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"after-unbind-key\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"alert-activity\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"alert-bell\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"alert-silence\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-active\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-attached\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-detached\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-focus-in\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-focus-out\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-resized\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"client-session-changed\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"command-error\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-died\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-exited\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-focus-in\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-focus-out\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-mode-changed\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-set-clipboard\", \"\"),\n\tOPTIONS_TABLE_PANE_HOOK(\"pane-title-changed\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"session-closed\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"session-created\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"session-renamed\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"session-window-changed\", \"\"),\n\tOPTIONS_TABLE_WINDOW_HOOK(\"window-layout-changed\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"window-linked\", \"\"),\n\tOPTIONS_TABLE_WINDOW_HOOK(\"window-pane-changed\", \"\"),\n\tOPTIONS_TABLE_WINDOW_HOOK(\"window-renamed\", \"\"),\n\tOPTIONS_TABLE_WINDOW_HOOK(\"window-resized\", \"\"),\n\tOPTIONS_TABLE_HOOK(\"window-unlinked\", \"\"),\n\n\t{ .name = NULL }\n};\n"
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 27.0419921875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <fnmatch.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Option handling; each option has a name, type and value and is stored in\n * a red-black tree.\n */\n\nstruct options_array_item {\n\tu_int\t\t\t\t index;\n\tunion options_value\t\t value;\n\tRB_ENTRY(options_array_item)\t entry;\n};\nstatic int\noptions_array_cmp(struct options_array_item *a1, struct options_array_item *a2)\n{\n\tif (a1->index < a2->index)\n\t\treturn (-1);\n\tif (a1->index > a2->index)\n\t\treturn (1);\n\treturn (0);\n}\nRB_GENERATE_STATIC(options_array, options_array_item, entry, options_array_cmp);\n\nstruct options_entry {\n\tstruct options\t\t\t\t*owner;\n\n\tconst char\t\t\t\t*name;\n\tconst struct options_table_entry\t*tableentry;\n\tunion options_value\t\t\t value;\n\n\tint\t\t\t\t\t cached;\n\tstruct style\t\t\t\t style;\n\n\tRB_ENTRY(options_entry)\t\t\t entry;\n};\n\nstruct options {\n\tRB_HEAD(options_tree, options_entry)\t tree;\n\tstruct options\t\t\t\t*parent;\n};\n\nstatic struct options_entry\t*options_add(struct options *, const char *);\nstatic void\t\t\t options_remove(struct options_entry *);\n\n#define OPTIONS_IS_STRING(o)\t\t\t\t\t\t\\\n\t((o)->tableentry == NULL ||\t\t\t\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_STRING)\n#define OPTIONS_IS_NUMBER(o) \\\n\t((o)->tableentry != NULL &&\t\t\t\t\t\\\n\t    ((o)->tableentry->type == OPTIONS_TABLE_NUMBER ||\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_KEY ||\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_COLOUR ||\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_FLAG ||\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_CHOICE))\n#define OPTIONS_IS_COMMAND(o) \\\n\t((o)->tableentry != NULL &&\t\t\t\t\t\\\n\t    (o)->tableentry->type == OPTIONS_TABLE_COMMAND)\n\n#define OPTIONS_IS_ARRAY(o)\t\t\t\t\t\t\\\n\t((o)->tableentry != NULL &&\t\t\t\t\t\\\n\t    ((o)->tableentry->flags & OPTIONS_TABLE_IS_ARRAY))\n\nstatic int\toptions_cmp(struct options_entry *, struct options_entry *);\nRB_GENERATE_STATIC(options_tree, options_entry, entry, options_cmp);\n\nstatic int\noptions_cmp(struct options_entry *lhs, struct options_entry *rhs)\n{\n\treturn (strcmp(lhs->name, rhs->name));\n}\n\nstatic const char *\noptions_map_name(const char *name)\n{\n\tconst struct options_name_map\t*map;\n\n\tfor (map = options_other_names; map->from != NULL; map++) {\n\t\tif (strcmp(map->from, name) == 0)\n\t\t\treturn (map->to);\n\t}\n\treturn (name);\n}\n\nstatic const struct options_table_entry *\noptions_parent_table_entry(struct options *oo, const char *s)\n{\n\tstruct options_entry\t*o;\n\n\tif (oo->parent == NULL)\n\t\tfatalx(\"no parent options for %s\", s);\n\to = options_get(oo->parent, s);\n\tif (o == NULL)\n\t\tfatalx(\"%s not in parent options\", s);\n\treturn (o->tableentry);\n}\n\nstatic void\noptions_value_free(struct options_entry *o, union options_value *ov)\n{\n\tif (OPTIONS_IS_STRING(o))\n\t\tfree(ov->string);\n\tif (OPTIONS_IS_COMMAND(o) && ov->cmdlist != NULL)\n\t\tcmd_list_free(ov->cmdlist);\n}\n\nstatic char *\noptions_value_to_string(struct options_entry *o, union options_value *ov,\n    int numeric)\n{\n\tchar\t*s;\n\n\tif (OPTIONS_IS_COMMAND(o))\n\t\treturn (cmd_list_print(ov->cmdlist, 0));\n\tif (OPTIONS_IS_NUMBER(o)) {\n\t\tswitch (o->tableentry->type) {\n\t\tcase OPTIONS_TABLE_NUMBER:\n\t\t\txasprintf(&s, \"%lld\", ov->number);\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_KEY:\n\t\t\ts = xstrdup(key_string_lookup_key(ov->number, 0));\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_COLOUR:\n\t\t\ts = xstrdup(colour_tostring(ov->number));\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_FLAG:\n\t\t\tif (numeric)\n\t\t\t\txasprintf(&s, \"%lld\", ov->number);\n\t\t\telse\n\t\t\t\ts = xstrdup(ov->number ? \"on\" : \"off\");\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_CHOICE:\n\t\t\ts = xstrdup(o->tableentry->choices[ov->number]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatalx(\"not a number option type\");\n\t\t}\n\t\treturn (s);\n\t}\n\tif (OPTIONS_IS_STRING(o))\n\t\treturn (xstrdup(ov->string));\n\treturn (xstrdup(\"\"));\n}\n\nstruct options *\noptions_create(struct options *parent)\n{\n\tstruct options\t*oo;\n\n\too = xcalloc(1, sizeof *oo);\n\tRB_INIT(&oo->tree);\n\too->parent = parent;\n\treturn (oo);\n}\n\nvoid\noptions_free(struct options *oo)\n{\n\tstruct options_entry\t*o, *tmp;\n\n\tRB_FOREACH_SAFE(o, options_tree, &oo->tree, tmp)\n\t\toptions_remove(o);\n\tfree(oo);\n}\n\nstruct options *\noptions_get_parent(struct options *oo)\n{\n\treturn (oo->parent);\n}\n\nvoid\noptions_set_parent(struct options *oo, struct options *parent)\n{\n\too->parent = parent;\n}\n\nstruct options_entry *\noptions_first(struct options *oo)\n{\n\treturn (RB_MIN(options_tree, &oo->tree));\n}\n\nstruct options_entry *\noptions_next(struct options_entry *o)\n{\n\treturn (RB_NEXT(options_tree, &oo->tree, o));\n}\n\nstruct options_entry *\noptions_get_only(struct options *oo, const char *name)\n{\n\tstruct options_entry\to = { .name = name }, *found;\n\n\tfound = RB_FIND(options_tree, &oo->tree, &o);\n\tif (found == NULL) {\n\t\to.name = options_map_name(name);\n\t\treturn (RB_FIND(options_tree, &oo->tree, &o));\n\t}\n\treturn (found);\n}\n\nstruct options_entry *\noptions_get(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\to = options_get_only(oo, name);\n\twhile (o == NULL) {\n\t\too = oo->parent;\n\t\tif (oo == NULL)\n\t\t\tbreak;\n\t\to = options_get_only(oo, name);\n\t}\n\treturn (o);\n}\n\nstruct options_entry *\noptions_empty(struct options *oo, const struct options_table_entry *oe)\n{\n\tstruct options_entry\t*o;\n\n\to = options_add(oo, oe->name);\n\to->tableentry = oe;\n\n\tif (oe->flags & OPTIONS_TABLE_IS_ARRAY)\n\t\tRB_INIT(&o->value.array);\n\n\treturn (o);\n}\n\nstruct options_entry *\noptions_default(struct options *oo, const struct options_table_entry *oe)\n{\n\tstruct options_entry\t*o;\n\tunion options_value\t*ov;\n\tu_int\t\t\t i;\n\n\to = options_empty(oo, oe);\n\tov = &o->value;\n\n\tif (oe->flags & OPTIONS_TABLE_IS_ARRAY) {\n\t\tif (oe->default_arr == NULL) {\n\t\t\toptions_array_assign(o, oe->default_str, NULL);\n\t\t\treturn (o);\n\t\t}\n\t\tfor (i = 0; oe->default_arr[i] != NULL; i++)\n\t\t\toptions_array_set(o, i, oe->default_arr[i], 0, NULL);\n\t\treturn (o);\n\t}\n\n\tswitch (oe->type) {\n\tcase OPTIONS_TABLE_STRING:\n\t\tov->string = xstrdup(oe->default_str);\n\t\tbreak;\n\tdefault:\n\t\tov->number = oe->default_num;\n\t\tbreak;\n\t}\n\treturn (o);\n}\n\nchar *\noptions_default_to_string(const struct options_table_entry *oe)\n{\n\tchar\t*s;\n\n\tswitch (oe->type) {\n\tcase OPTIONS_TABLE_STRING:\n\tcase OPTIONS_TABLE_COMMAND:\n\t\ts = xstrdup(oe->default_str);\n\t\tbreak;\n\tcase OPTIONS_TABLE_NUMBER:\n\t\txasprintf(&s, \"%lld\", oe->default_num);\n\t\tbreak;\n\tcase OPTIONS_TABLE_KEY:\n\t\ts = xstrdup(key_string_lookup_key(oe->default_num, 0));\n\t\tbreak;\n\tcase OPTIONS_TABLE_COLOUR:\n\t\ts = xstrdup(colour_tostring(oe->default_num));\n\t\tbreak;\n\tcase OPTIONS_TABLE_FLAG:\n\t\ts = xstrdup(oe->default_num ? \"on\" : \"off\");\n\t\tbreak;\n\tcase OPTIONS_TABLE_CHOICE:\n\t\ts = xstrdup(oe->choices[oe->default_num]);\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"unknown option type\");\n\t}\n\treturn (s);\n}\n\nstatic struct options_entry *\noptions_add(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\to = options_get_only(oo, name);\n\tif (o != NULL)\n\t\toptions_remove(o);\n\n\to = xcalloc(1, sizeof *o);\n\to->owner = oo;\n\to->name = xstrdup(name);\n\n\tRB_INSERT(options_tree, &oo->tree, o);\n\treturn (o);\n}\n\nstatic void\noptions_remove(struct options_entry *o)\n{\n\tstruct options\t*oo = o->owner;\n\n\tif (OPTIONS_IS_ARRAY(o))\n\t\toptions_array_clear(o);\n\telse\n\t\toptions_value_free(o, &o->value);\n\tRB_REMOVE(options_tree, &oo->tree, o);\n\tfree((void *)o->name);\n\tfree(o);\n}\n\nconst char *\noptions_name(struct options_entry *o)\n{\n\treturn (o->name);\n}\n\nstruct options *\noptions_owner(struct options_entry *o)\n{\n\treturn (o->owner);\n}\n\nconst struct options_table_entry *\noptions_table_entry(struct options_entry *o)\n{\n\treturn (o->tableentry);\n}\n\nstatic struct options_array_item *\noptions_array_item(struct options_entry *o, u_int idx)\n{\n\tstruct options_array_item\ta;\n\n\ta.index = idx;\n\treturn (RB_FIND(options_array, &o->value.array, &a));\n}\n\nstatic struct options_array_item *\noptions_array_new(struct options_entry *o, u_int idx)\n{\n\tstruct options_array_item\t*a;\n\n\ta = xcalloc(1, sizeof *a);\n\ta->index = idx;\n\tRB_INSERT(options_array, &o->value.array, a);\n\treturn (a);\n}\n\nstatic void\noptions_array_free(struct options_entry *o, struct options_array_item *a)\n{\n\toptions_value_free(o, &a->value);\n\tRB_REMOVE(options_array, &o->value.array, a);\n\tfree(a);\n}\n\nvoid\noptions_array_clear(struct options_entry *o)\n{\n\tstruct options_array_item\t*a, *a1;\n\n\tif (!OPTIONS_IS_ARRAY(o))\n\t\treturn;\n\n\tRB_FOREACH_SAFE(a, options_array, &o->value.array, a1)\n\t\toptions_array_free(o, a);\n}\n\nunion options_value *\noptions_array_get(struct options_entry *o, u_int idx)\n{\n\tstruct options_array_item\t*a;\n\n\tif (!OPTIONS_IS_ARRAY(o))\n\t\treturn (NULL);\n\ta = options_array_item(o, idx);\n\tif (a == NULL)\n\t\treturn (NULL);\n\treturn (&a->value);\n}\n\nint\noptions_array_set(struct options_entry *o, u_int idx, const char *value,\n    int append, char **cause)\n{\n\tstruct options_array_item\t*a;\n\tchar\t\t\t\t*new;\n\tstruct cmd_parse_result\t\t*pr;\n\tlong long\t\t \t number;\n\n\tif (!OPTIONS_IS_ARRAY(o)) {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"not an array\");\n\t\treturn (-1);\n\t}\n\n\tif (value == NULL) {\n\t\ta = options_array_item(o, idx);\n\t\tif (a != NULL)\n\t\t\toptions_array_free(o, a);\n\t\treturn (0);\n\t}\n\n\tif (OPTIONS_IS_COMMAND(o)) {\n\t\tpr = cmd_parse_from_string(value, NULL);\n\t\tswitch (pr->status) {\n\t\tcase CMD_PARSE_ERROR:\n\t\t\tif (cause != NULL)\n\t\t\t\t*cause = pr->error;\n\t\t\telse\n\t\t\t\tfree(pr->error);\n\t\t\treturn (-1);\n\t\tcase CMD_PARSE_SUCCESS:\n\t\t\tbreak;\n\t\t}\n\n\t\ta = options_array_item(o, idx);\n\t\tif (a == NULL)\n\t\t\ta = options_array_new(o, idx);\n\t\telse\n\t\t\toptions_value_free(o, &a->value);\n\t\ta->value.cmdlist = pr->cmdlist;\n\t\treturn (0);\n\t}\n\n\tif (OPTIONS_IS_STRING(o)) {\n\t\ta = options_array_item(o, idx);\n\t\tif (a != NULL && append)\n\t\t\txasprintf(&new, \"%s%s\", a->value.string, value);\n\t\telse\n\t\t\tnew = xstrdup(value);\n\t\tif (a == NULL)\n\t\t\ta = options_array_new(o, idx);\n\t\telse\n\t\t\toptions_value_free(o, &a->value);\n\t\ta->value.string = new;\n\t\treturn (0);\n\t}\n\n\tif (o->tableentry->type == OPTIONS_TABLE_COLOUR) {\n\t\tif ((number = colour_fromstring(value)) == -1) {\n\t\t\txasprintf(cause, \"bad colour: %s\", value);\n\t\t\treturn (-1);\n\t\t}\n\t\ta = options_array_item(o, idx);\n\t\tif (a == NULL)\n\t\t\ta = options_array_new(o, idx);\n\t\telse\n\t\t\toptions_value_free(o, &a->value);\n\t\ta->value.number = number;\n\t\treturn (0);\n\t}\n\n\tif (cause != NULL)\n\t\t*cause = xstrdup(\"wrong array type\");\n\treturn (-1);\n}\n\nint\noptions_array_assign(struct options_entry *o, const char *s, char **cause)\n{\n\tconst char\t*separator;\n\tchar\t\t*copy, *next, *string;\n\tu_int\t\t i;\n\n\tseparator = o->tableentry->separator;\n\tif (separator == NULL)\n\t\tseparator = \" ,\";\n\tif (*separator == '\\0') {\n\t\tif (*s == '\\0')\n\t\t\treturn (0);\n\t\tfor (i = 0; i < UINT_MAX; i++) {\n\t\t\tif (options_array_item(o, i) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn (options_array_set(o, i, s, 0, cause));\n\t}\n\n\tif (*s == '\\0')\n\t\treturn (0);\n\tcopy = string = xstrdup(s);\n\twhile ((next = strsep(&string, separator)) != NULL) {\n\t\tif (*next == '\\0')\n\t\t\tcontinue;\n\t\tfor (i = 0; i < UINT_MAX; i++) {\n\t\t\tif (options_array_item(o, i) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == UINT_MAX)\n\t\t\tbreak;\n\t\tif (options_array_set(o, i, next, 0, cause) != 0) {\n\t\t\tfree(copy);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tfree(copy);\n\treturn (0);\n}\n\nstruct options_array_item *\noptions_array_first(struct options_entry *o)\n{\n\tif (!OPTIONS_IS_ARRAY(o))\n\t\treturn (NULL);\n\treturn (RB_MIN(options_array, &o->value.array));\n}\n\nstruct options_array_item *\noptions_array_next(struct options_array_item *a)\n{\n\treturn (RB_NEXT(options_array, &o->value.array, a));\n}\n\nu_int\noptions_array_item_index(struct options_array_item *a)\n{\n\treturn (a->index);\n}\n\nunion options_value *\noptions_array_item_value(struct options_array_item *a)\n{\n\treturn (&a->value);\n}\n\nint\noptions_is_array(struct options_entry *o)\n{\n\treturn (OPTIONS_IS_ARRAY(o));\n}\n\nint\noptions_is_string(struct options_entry *o)\n{\n\treturn (OPTIONS_IS_STRING(o));\n}\n\nchar *\noptions_to_string(struct options_entry *o, int idx, int numeric)\n{\n\tstruct options_array_item\t*a;\n\tchar\t\t\t\t*result = NULL;\n\tchar\t\t\t\t*last = NULL;\n\tchar\t\t\t\t*next;\n\n\tif (OPTIONS_IS_ARRAY(o)) {\n\t\tif (idx == -1) {\n\t\t\tRB_FOREACH(a, options_array, &o->value.array) {\n\t\t\t\tnext = options_value_to_string(o, &a->value,\n\t\t\t\t    numeric);\n\t\t\t\tif (last == NULL)\n\t\t\t\t\tresult = next;\n\t\t\t\telse {\n\t\t\t\t\txasprintf(&result, \"%s %s\", last, next);\n\t\t\t\t\tfree(last);\n\t\t\t\t\tfree(next);\n\t\t\t\t}\n\t\t\t\tlast = result;\n\t\t\t}\n\t\t\tif (result == NULL)\n\t\t\t\treturn (xstrdup(\"\"));\n\t\t\treturn (result);\n\t\t}\n\t\ta = options_array_item(o, idx);\n\t\tif (a == NULL)\n\t\t\treturn (xstrdup(\"\"));\n\t\treturn (options_value_to_string(o, &a->value, numeric));\n\t}\n\treturn (options_value_to_string(o, &o->value, numeric));\n}\n\nchar *\noptions_parse(const char *name, int *idx)\n{\n\tchar\t*copy, *cp, *end;\n\n\tif (*name == '\\0')\n\t\treturn (NULL);\n\tcopy = xstrdup(name);\n\tif ((cp = strchr(copy, '[')) == NULL) {\n\t\t*idx = -1;\n\t\treturn (copy);\n\t}\n\tend = strchr(cp + 1, ']');\n\tif (end == NULL || end[1] != '\\0' || !isdigit((u_char)end[-1])) {\n\t\tfree(copy);\n\t\treturn (NULL);\n\t}\n\tif (sscanf(cp, \"[%d]\", idx) != 1 || *idx < 0) {\n\t\tfree(copy);\n\t\treturn (NULL);\n\t}\n\t*cp = '\\0';\n\treturn (copy);\n}\n\nstruct options_entry *\noptions_parse_get(struct options *oo, const char *s, int *idx, int only)\n{\n\tstruct options_entry\t*o;\n\tchar\t\t\t*name;\n\n\tname = options_parse(s, idx);\n\tif (name == NULL)\n\t\treturn (NULL);\n\tif (only)\n\t\to = options_get_only(oo, name);\n\telse\n\t\to = options_get(oo, name);\n\tfree(name);\n\treturn (o);\n}\n\nchar *\noptions_match(const char *s, int *idx, int *ambiguous)\n{\n\tconst struct options_table_entry\t*oe, *found;\n\tchar\t\t\t\t\t*parsed;\n\tconst char\t\t\t\t*name;\n\tsize_t\t\t\t\t\t namelen;\n\n\tparsed = options_parse(s, idx);\n\tif (parsed == NULL)\n\t\treturn (NULL);\n\tif (*parsed == '@') {\n\t\t*ambiguous = 0;\n\t\treturn (parsed);\n\t}\n\n\tname = options_map_name(parsed);\n\tnamelen = strlen(name);\n\n\tfound = NULL;\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (strcmp(oe->name, name) == 0) {\n\t\t\tfound = oe;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(oe->name, name, namelen) == 0) {\n\t\t\tif (found != NULL) {\n\t\t\t\t*ambiguous = 1;\n\t\t\t\tfree(parsed);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfound = oe;\n\t\t}\n\t}\n\tfree(parsed);\n\tif (found == NULL) {\n\t\t*ambiguous = 0;\n\t\treturn (NULL);\n\t}\n\treturn (xstrdup(found->name));\n}\n\nstruct options_entry *\noptions_match_get(struct options *oo, const char *s, int *idx, int only,\n    int *ambiguous)\n{\n\tchar\t\t\t*name;\n\tstruct options_entry\t*o;\n\n\tname = options_match(s, idx, ambiguous);\n\tif (name == NULL)\n\t\treturn (NULL);\n\t*ambiguous = 0;\n\tif (only)\n\t\to = options_get_only(oo, name);\n\telse\n\t\to = options_get(oo, name);\n\tfree(name);\n\treturn (o);\n}\n\nconst char *\noptions_get_string(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\to = options_get(oo, name);\n\tif (o == NULL)\n\t\tfatalx(\"missing option %s\", name);\n\tif (!OPTIONS_IS_STRING(o))\n\t\tfatalx(\"option %s is not a string\", name);\n\treturn (o->value.string);\n}\n\nlong long\noptions_get_number(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\to = options_get(oo, name);\n\tif (o == NULL)\n\t\tfatalx(\"missing option %s\", name);\n\tif (!OPTIONS_IS_NUMBER(o))\n\t\tfatalx(\"option %s is not a number\", name);\n\treturn (o->value.number);\n}\n\nstruct options_entry *\noptions_set_string(struct options *oo, const char *name, int append,\n    const char *fmt, ...)\n{\n\tstruct options_entry\t*o;\n\tva_list\t\t\t ap;\n\tconst char\t\t*separator = \"\";\n\tchar\t\t\t*s, *value;\n\n\tva_start(ap, fmt);\n\txvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\to = options_get_only(oo, name);\n\tif (o != NULL && append && OPTIONS_IS_STRING(o)) {\n\t\tif (*name != '@') {\n\t\t\tseparator = o->tableentry->separator;\n\t\t\tif (separator == NULL)\n\t\t\t\tseparator = \"\";\n\t\t}\n\t\txasprintf(&value, \"%s%s%s\", o->value.string, separator, s);\n\t\tfree(s);\n\t} else\n\t\tvalue = s;\n\tif (o == NULL && *name == '@')\n\t\to = options_add(oo, name);\n\telse if (o == NULL) {\n\t\to = options_default(oo, options_parent_table_entry(oo, name));\n\t\tif (o == NULL)\n\t\t\treturn (NULL);\n\t}\n\n\tif (!OPTIONS_IS_STRING(o))\n\t\tfatalx(\"option %s is not a string\", name);\n\tfree(o->value.string);\n\to->value.string = value;\n\to->cached = 0;\n\treturn (o);\n}\n\nstruct options_entry *\noptions_set_number(struct options *oo, const char *name, long long value)\n{\n\tstruct options_entry\t*o;\n\n\tif (*name == '@')\n\t\tfatalx(\"user option %s must be a string\", name);\n\n\to = options_get_only(oo, name);\n\tif (o == NULL) {\n\t\to = options_default(oo, options_parent_table_entry(oo, name));\n\t\tif (o == NULL)\n\t\t\treturn (NULL);\n\t}\n\n\tif (!OPTIONS_IS_NUMBER(o))\n\t\tfatalx(\"option %s is not a number\", name);\n\to->value.number = value;\n\treturn (o);\n}\n\nint\noptions_scope_from_name(struct args *args, int window,\n    const char *name, struct cmd_find_state *fs, struct options **oo,\n    char **cause)\n{\n\tstruct session\t\t\t\t*s = fs->s;\n\tstruct winlink\t\t\t\t*wl = fs->wl;\n\tstruct window_pane\t\t\t*wp = fs->wp;\n\tconst char\t\t\t\t*target = args_get(args, 't');\n\tconst struct options_table_entry\t*oe;\n\tint\t\t\t\t\t scope = OPTIONS_TABLE_NONE;\n\n\tif (*name == '@')\n\t\treturn (options_scope_from_flags(args, window, fs, oo, cause));\n\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (strcmp(oe->name, name) == 0)\n\t\t\tbreak;\n\t}\n\tif (oe->name == NULL) {\n\t\txasprintf(cause, \"unknown option: %s\", name);\n\t\treturn (OPTIONS_TABLE_NONE);\n\t}\n\tswitch (oe->scope) {\n\tcase OPTIONS_TABLE_SERVER:\n\t\t*oo = global_options;\n\t\tscope = OPTIONS_TABLE_SERVER;\n\t\tbreak;\n\tcase OPTIONS_TABLE_SESSION:\n\t\tif (args_has(args, 'g')) {\n\t\t\t*oo = global_s_options;\n\t\t\tscope = OPTIONS_TABLE_SESSION;\n\t\t} else if (s == NULL && target != NULL)\n\t\t\txasprintf(cause, \"no such session: %s\", target);\n\t\telse if (s == NULL)\n\t\t\txasprintf(cause, \"no current session\");\n\t\telse {\n\t\t\t*oo = s->options;\n\t\t\tscope = OPTIONS_TABLE_SESSION;\n\t\t}\n\t\tbreak;\n\tcase OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE:\n\t\tif (args_has(args, 'p')) {\n\t\t\tif (wp == NULL && target != NULL)\n\t\t\t\txasprintf(cause, \"no such pane: %s\", target);\n\t\t\telse if (wp == NULL)\n\t\t\t\txasprintf(cause, \"no current pane\");\n\t\t\telse {\n\t\t\t\t*oo = wp->options;\n\t\t\t\tscope = OPTIONS_TABLE_PANE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase OPTIONS_TABLE_WINDOW:\n\t\tif (args_has(args, 'g')) {\n\t\t\t*oo = global_w_options;\n\t\t\tscope = OPTIONS_TABLE_WINDOW;\n\t\t} else if (wl == NULL && target != NULL)\n\t\t\txasprintf(cause, \"no such window: %s\", target);\n\t\telse if (wl == NULL)\n\t\t\txasprintf(cause, \"no current window\");\n\t\telse {\n\t\t\t*oo = wl->window->options;\n\t\t\tscope = OPTIONS_TABLE_WINDOW;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (scope);\n}\n\nint\noptions_scope_from_flags(struct args *args, int window,\n    struct cmd_find_state *fs, struct options **oo, char **cause)\n{\n\tstruct session\t\t*s = fs->s;\n\tstruct winlink\t\t*wl = fs->wl;\n\tstruct window_pane\t*wp = fs->wp;\n\tconst char\t\t*target = args_get(args, 't');\n\n\tif (args_has(args, 's')) {\n\t\t*oo = global_options;\n\t\treturn (OPTIONS_TABLE_SERVER);\n\t}\n\n\tif (args_has(args, 'p')) {\n\t\tif (wp == NULL) {\n\t\t\tif (target != NULL)\n\t\t\t\txasprintf(cause, \"no such pane: %s\", target);\n\t\t\telse\n\t\t\t\txasprintf(cause, \"no current pane\");\n\t\t\treturn (OPTIONS_TABLE_NONE);\n\t\t}\n\t\t*oo = wp->options;\n\t\treturn (OPTIONS_TABLE_PANE);\n\t} else if (window || args_has(args, 'w')) {\n\t\tif (args_has(args, 'g')) {\n\t\t\t*oo = global_w_options;\n\t\t\treturn (OPTIONS_TABLE_WINDOW);\n\t\t}\n\t\tif (wl == NULL) {\n\t\t\tif (target != NULL)\n\t\t\t\txasprintf(cause, \"no such window: %s\", target);\n\t\t\telse\n\t\t\t\txasprintf(cause, \"no current window\");\n\t\t\treturn (OPTIONS_TABLE_NONE);\n\t\t}\n\t\t*oo = wl->window->options;\n\t\treturn (OPTIONS_TABLE_WINDOW);\n\t} else {\n\t\tif (args_has(args, 'g')) {\n\t\t\t*oo = global_s_options;\n\t\t\treturn (OPTIONS_TABLE_SESSION);\n\t\t}\n\t\tif (s == NULL) {\n\t\t\tif (target != NULL)\n\t\t\t\txasprintf(cause, \"no such session: %s\", target);\n\t\t\telse\n\t\t\t\txasprintf(cause, \"no current session\");\n\t\t\treturn (OPTIONS_TABLE_NONE);\n\t\t}\n\t\t*oo = s->options;\n\t\treturn (OPTIONS_TABLE_SESSION);\n\t}\n}\n\nstruct style *\noptions_string_to_style(struct options *oo, const char *name,\n    struct format_tree *ft)\n{\n\tstruct options_entry\t*o;\n\tconst char\t\t*s;\n\tchar\t\t\t*expanded;\n\n\to = options_get(oo, name);\n\tif (o == NULL || !OPTIONS_IS_STRING(o))\n\t\treturn (NULL);\n\n\tif (o->cached)\n\t\treturn (&o->style);\n\ts = o->value.string;\n\tlog_debug(\"%s: %s is '%s'\", __func__, name, s);\n\n\tstyle_set(&o->style, &grid_default_cell);\n\to->cached = (strstr(s, \"#{\") == NULL);\n\n\tif (ft != NULL && !o->cached) {\n\t\texpanded = format_expand(ft, s);\n\t\tif (style_parse(&o->style, &grid_default_cell, expanded) != 0) {\n\t\t\tfree(expanded);\n\t\t\treturn (NULL);\n\t\t}\n\t\tfree(expanded);\n\t} else {\n\t\tif (style_parse(&o->style, &grid_default_cell, s) != 0)\n\t\t\treturn (NULL);\n\t}\n\treturn (&o->style);\n}\n\nstatic int\noptions_from_string_check(const struct options_table_entry *oe,\n    const char *value, char **cause)\n{\n\tstruct style\tsy;\n\n\tif (oe == NULL)\n\t\treturn (0);\n\tif (strcmp(oe->name, \"default-shell\") == 0 && !checkshell(value)) {\n\t\txasprintf(cause, \"not a suitable shell: %s\", value);\n\t\treturn (-1);\n\t}\n\tif (oe->pattern != NULL && fnmatch(oe->pattern, value, 0) != 0) {\n\t\txasprintf(cause, \"value is invalid: %s\", value);\n\t\treturn (-1);\n\t}\n\tif ((oe->flags & OPTIONS_TABLE_IS_STYLE) &&\n\t    strstr(value, \"#{\") == NULL &&\n\t    style_parse(&sy, &grid_default_cell, value) != 0) {\n\t\txasprintf(cause, \"invalid style: %s\", value);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic int\noptions_from_string_flag(struct options *oo, const char *name,\n    const char *value, char **cause)\n{\n\tint\tflag;\n\n\tif (value == NULL || *value == '\\0')\n\t\tflag = !options_get_number(oo, name);\n\telse if (strcmp(value, \"1\") == 0 ||\n\t    strcasecmp(value, \"on\") == 0 ||\n\t    strcasecmp(value, \"yes\") == 0)\n\t\tflag = 1;\n\telse if (strcmp(value, \"0\") == 0 ||\n\t    strcasecmp(value, \"off\") == 0 ||\n\t    strcasecmp(value, \"no\") == 0)\n\t\tflag = 0;\n\telse {\n\t\txasprintf(cause, \"bad value: %s\", value);\n\t\treturn (-1);\n\t}\n\toptions_set_number(oo, name, flag);\n\treturn (0);\n}\n\nint\noptions_find_choice(const struct options_table_entry *oe, const char *value,\n    char **cause)\n{\n\tconst char\t**cp;\n\tint\t\t  n = 0, choice = -1;\n\n\tfor (cp = oe->choices; *cp != NULL; cp++) {\n\t\tif (strcmp(*cp, value) == 0)\n\t\t\tchoice = n;\n\t\tn++;\n\t}\n\tif (choice == -1) {\n\t\txasprintf(cause, \"unknown value: %s\", value);\n\t\treturn (-1);\n\t}\n\treturn (choice);\n}\n\nstatic int\noptions_from_string_choice(const struct options_table_entry *oe,\n    struct options *oo, const char *name, const char *value, char **cause)\n{\n\tint\tchoice = -1;\n\n\tif (value == NULL) {\n\t\tchoice = options_get_number(oo, name);\n\t\tif (choice < 2)\n\t\t\tchoice = !choice;\n\t} else {\n\t\tchoice = options_find_choice(oe, value, cause);\n\t\tif (choice < 0)\n\t\t\treturn (-1);\n\t}\n\toptions_set_number(oo, name, choice);\n\treturn (0);\n}\n\nint\noptions_from_string(struct options *oo, const struct options_table_entry *oe,\n    const char *name, const char *value, int append, char **cause)\n{\n\tenum options_table_type\t type;\n\tlong long\t\t number;\n\tconst char\t\t*errstr, *new;\n\tchar\t\t\t*old;\n\tkey_code\t\t key;\n\n\tif (oe != NULL) {\n\t\tif (value == NULL &&\n\t\t    oe->type != OPTIONS_TABLE_FLAG &&\n\t\t    oe->type != OPTIONS_TABLE_CHOICE) {\n\t\t\txasprintf(cause, \"empty value\");\n\t\t\treturn (-1);\n\t\t}\n\t\ttype = oe->type;\n\t} else {\n\t\tif (*name != '@') {\n\t\t\txasprintf(cause, \"bad option name\");\n\t\t\treturn (-1);\n\t\t}\n\t\ttype = OPTIONS_TABLE_STRING;\n\t}\n\n\tswitch (type) {\n\tcase OPTIONS_TABLE_STRING:\n\t\told = xstrdup(options_get_string(oo, name));\n\t\toptions_set_string(oo, name, append, \"%s\", value);\n\n\t\tnew = options_get_string(oo, name);\n\t\tif (options_from_string_check(oe, new, cause) != 0) {\n\t\t\toptions_set_string(oo, name, 0, \"%s\", old);\n\t\t\tfree(old);\n\t\t\treturn (-1);\n\t\t}\n\t\tfree(old);\n\t\treturn (0);\n\tcase OPTIONS_TABLE_NUMBER:\n\t\tnumber = strtonum(value, oe->minimum, oe->maximum, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\txasprintf(cause, \"value is %s: %s\", errstr, value);\n\t\t\treturn (-1);\n\t\t}\n\t\toptions_set_number(oo, name, number);\n\t\treturn (0);\n\tcase OPTIONS_TABLE_KEY:\n\t\tkey = key_string_lookup_string(value);\n\t\tif (key == KEYC_UNKNOWN) {\n\t\t\txasprintf(cause, \"bad key: %s\", value);\n\t\t\treturn (-1);\n\t\t}\n\t\toptions_set_number(oo, name, key);\n\t\treturn (0);\n\tcase OPTIONS_TABLE_COLOUR:\n\t\tif ((number = colour_fromstring(value)) == -1) {\n\t\t\txasprintf(cause, \"bad colour: %s\", value);\n\t\t\treturn (-1);\n\t\t}\n\t\toptions_set_number(oo, name, number);\n\t\treturn (0);\n\tcase OPTIONS_TABLE_FLAG:\n\t\treturn (options_from_string_flag(oo, name, value, cause));\n\tcase OPTIONS_TABLE_CHOICE:\n\t\treturn (options_from_string_choice(oe, oo, name, value, cause));\n\tcase OPTIONS_TABLE_COMMAND:\n\t\tbreak;\n\t}\n\treturn (-1);\n}\n\nvoid\noptions_push_changes(const char *name)\n{\n\tstruct client\t\t*loop;\n\tstruct session\t\t*s;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\n\tlog_debug(\"%s: %s\", __func__, name);\n\n\tif (strcmp(name, \"automatic-rename\") == 0) {\n\t\tRB_FOREACH(w, windows, &windows) {\n\t\t\tif (w->active == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (options_get_number(w->options, name))\n\t\t\t\tw->active->flags |= PANE_CHANGED;\n\t\t}\n\t}\n\tif (strcmp(name, \"cursor-colour\") == 0) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes)\n\t\t\twindow_pane_default_cursor(wp);\n\t}\n\tif (strcmp(name, \"cursor-style\") == 0) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes)\n\t\t\twindow_pane_default_cursor(wp);\n\t}\n\tif (strcmp(name, \"fill-character\") == 0) {\n\t\tRB_FOREACH(w, windows, &windows)\n\t\t\twindow_set_fill_character(w);\n\t}\n\tif (strcmp(name, \"key-table\") == 0) {\n\t\tTAILQ_FOREACH(loop, &clients, entry)\n\t\t\tserver_client_set_key_table(loop, NULL);\n\t}\n\tif (strcmp(name, \"user-keys\") == 0) {\n\t\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\t\tif (loop->tty.flags & TTY_OPENED)\n\t\t\t\ttty_keys_build(&loop->tty);\n\t\t}\n\t}\n\tif (strcmp(name, \"status\") == 0 ||\n\t    strcmp(name, \"status-interval\") == 0)\n\t\tstatus_timer_start_all();\n\tif (strcmp(name, \"monitor-silence\") == 0)\n\t\talerts_reset_all();\n\tif (strcmp(name, \"window-style\") == 0 ||\n\t    strcmp(name, \"window-active-style\") == 0) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes)\n\t\t\twp->flags |= PANE_STYLECHANGED;\n\t}\n\tif (strcmp(name, \"pane-colours\") == 0) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes)\n\t\t\tcolour_palette_from_option(&wp->palette, wp->options);\n\t}\n\tif (strcmp(name, \"pane-border-status\") == 0 ||\n\t    strcmp(name, \"pane-scrollbars\") == 0 ||\n\t    strcmp(name, \"pane-scrollbars-position\") == 0) {\n\t\tRB_FOREACH(w, windows, &windows)\n\t\t\tlayout_fix_panes(w, NULL);\n\t}\n\tif (strcmp(name, \"pane-scrollbars-style\") == 0) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\t\tstyle_set_scrollbar_style_from_option(\n\t\t\t    &wp->scrollbar_style, wp->options);\n\t\t}\n\t\tRB_FOREACH(w, windows, &windows)\n\t\t\tlayout_fix_panes(w, NULL);\n\t}\n\tif (strcmp(name, \"codepoint-widths\") == 0)\n\t\tutf8_update_width_cache();\n\tif (strcmp(name, \"input-buffer-size\") == 0)\n\t\tinput_set_buffer_size(options_get_number(global_options, name));\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tstatus_update_cache(s);\n\n\trecalculate_sizes();\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (loop->session != NULL)\n\t\t\tserver_redraw_client(loop);\n\t}\n}\n\nint\noptions_remove_or_default(struct options_entry *o, int idx, char **cause)\n{\n\tstruct options\t*oo = o->owner;\n\n\tif (idx == -1) {\n\t\tif (o->tableentry != NULL &&\n\t\t    (oo == global_options ||\n\t\t    oo == global_s_options ||\n\t\t    oo == global_w_options))\n\t\t\toptions_default(oo, o->tableentry);\n\t\telse\n\t\t\toptions_remove(o);\n\t} else if (options_array_set(o, idx, NULL, 0, cause) != 0)\n\t\treturn (-1);\n\treturn (0);\n}\n"
        },
        {
          "name": "osdep-aix.c",
          "type": "blob",
          "size": 2.2197265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/procfs.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, char *tty)\n{\n\tstruct psinfo\t p;\n\tchar\t\t*path;\n\tssize_t\t\t bytes;\n\tint\t\t f, ttyfd, retval;\n\tpid_t\t\t pgrp;\n\n\tif ((ttyfd = open(tty, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/psinfo\", (u_int) pgrp);\n\tf = open(path, O_RDONLY);\n\tfree(path);\n\tif (f < 0)\n\t\treturn (NULL);\n\n\tbytes = read(f, &p, sizeof(p));\n\tclose(f);\n\tif (bytes != sizeof(p))\n\t\treturn (NULL);\n\n\treturn (xstrdup(p.pr_fname));\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char      target[MAXPATHLEN + 1];\n\tchar            *path;\n\tconst char      *ttypath;\n\tssize_t          n;\n\tpid_t            pgrp;\n\tint              len, retval, ttyfd;\n\n\tif ((ttypath = ptsname(fd)) == NULL)\n\t\treturn (NULL);\n\tif ((ttyfd = open(ttypath, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/cwd\", (u_int) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\tif ((len = strlen(target)) > 1 && target[len - 1] == '/')\n\t\t\ttarget[len - 1] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-cygwin.c",
          "type": "blob",
          "size": 1.857421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tFILE\t*f;\n\tchar\t*path, *buf;\n\tsize_t\t len;\n\tint\t ch;\n\tpid_t\t pgrp;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cmdline\", (long long) pgrp);\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tfree(path);\n\t\treturn (NULL);\n\t}\n\tfree(path);\n\n\tlen = 0;\n\tbuf = NULL;\n\twhile ((ch = fgetc(f)) != EOF) {\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t}\n\tif (buf != NULL)\n\t\tbuf[len] = '\\0';\n\n\tfclose(f);\n\treturn (buf);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tpid_t\t\t pgrp;\n\tssize_t\t\t n;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cwd\", (long long) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-darwin.c",
          "type": "blob",
          "size": 2.623046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/sysctl.h>\n\n#include <Availability.h>\n#include <libproc.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"compat.h\"\n\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef __unused\n#define __unused __attribute__ ((__unused__))\n#endif\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n#ifdef __MAC_10_7\n\tstruct proc_bsdshortinfo\tbsdinfo;\n\tpid_t\t\t\t\tpgrp;\n\tint\t\t\t\tret;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tret = proc_pidinfo(pgrp, PROC_PIDT_SHORTBSDINFO, 0,\n\t\t\t&bsdinfo, sizeof bsdinfo);\n\tif (ret == sizeof bsdinfo && *bsdinfo.pbsi_comm != '\\0')\n\t\treturn (strdup(bsdinfo.pbsi_comm));\n\treturn (NULL);\n#else\n\tint\tmib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, 0 };\n\tsize_t\tsize;\n\tstruct kinfo_proc kp;\n\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tsize = sizeof kp;\n\tif (sysctl(mib, 4, &kp, &size, NULL, 0) == -1)\n\t\treturn (NULL);\n\tif (size != (sizeof kp) || *kp.kp_proc.p_comm == '\\0')\n\t\treturn (NULL);\n\n\treturn (strdup(kp.kp_proc.p_comm));\n#endif\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t\t\twd[PATH_MAX];\n\tstruct proc_vnodepathinfo\tpathinfo;\n\tpid_t\t\t\t\tpgrp;\n\tint\t\t\t\tret;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tret = proc_pidinfo(pgrp, PROC_PIDVNODEPATHINFO, 0,\n\t    &pathinfo, sizeof pathinfo);\n\tif (ret == sizeof pathinfo) {\n\t\tstrlcpy(wd, pathinfo.pvi_cdir.vip_path, sizeof wd);\n\t\treturn (wd);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\tstruct event_base\t*base;\n\n\t/*\n\t * On OS X, kqueue and poll are both completely broken and don't\n\t * work on anything except socket file descriptors (yes, really).\n\t */\n\tsetenv(\"EVENT_NOKQUEUE\", \"1\", 1);\n\tsetenv(\"EVENT_NOPOLL\", \"1\", 1);\n\n\tbase = event_init();\n\tunsetenv(\"EVENT_NOKQUEUE\");\n\tunsetenv(\"EVENT_NOPOLL\");\n\treturn (base);\n}\n"
        },
        {
          "name": "osdep-dragonfly.c",
          "type": "blob",
          "size": 2.9375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n\n#include <err.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nstruct kinfo_proc\t*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->kp_stat == SACTIVE || (p)->kp_stat == SIDL)\n#define is_stopped(p) \\\n\t((p)->kp_stat == SSTOP || (p)->kp_stat == SZOMB)\n\nstruct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (strcmp(p1->kp_comm, p2->kp_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->kp_comm, p2->kp_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->kp_pid > p2->kp_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif (buf[i].kp_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->kp_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-freebsd.c",
          "type": "blob",
          "size": 4.4462890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n\n#include <err.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <libutil.h>\n\n#include \"compat.h\"\n\nstruct kinfo_proc\t*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->ki_stat == SRUN || (p)->ki_stat == SIDL)\n#define is_stopped(p) \\\n\t((p)->ki_stat == SSTOP || (p)->ki_stat == SZOMB)\n\nstruct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->ki_estcpu > p2->ki_estcpu)\n\t\treturn (p1);\n\tif (p1->ki_estcpu < p2->ki_estcpu)\n\t\treturn (p2);\n\n\tif (p1->ki_slptime < p2->ki_slptime)\n\t\treturn (p1);\n\tif (p1->ki_slptime > p2->ki_slptime)\n\t\treturn (p2);\n\n\tif (strcmp(p1->ki_comm, p2->ki_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->ki_comm, p2->ki_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->ki_pid > p2->ki_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif (buf[i].ki_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->ki_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nstatic char *\nosdep_get_cwd_fallback(int fd)\n{\n\tstatic char\t\t wd[PATH_MAX];\n\tstruct kinfo_file\t*info = NULL;\n\tpid_t\t\t\t pgrp;\n\tint\t\t\t nrecords, i;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tif ((info = kinfo_getfile(pgrp, &nrecords)) == NULL)\n\t\treturn (NULL);\n\n\tfor (i = 0; i < nrecords; i++) {\n\t\tif (info[i].kf_fd == KF_FD_TYPE_CWD) {\n\t\t\tstrlcpy(wd, info[i].kf_path, sizeof wd);\n\t\t\tfree(info);\n\t\t\treturn (wd);\n\t\t}\n\t}\n\n\tfree(info);\n\treturn (NULL);\n}\n\n#ifdef KERN_PROC_CWD\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic struct kinfo_file\tinfo;\n\tstatic int\t\t\tfallback;\n\tint\tname[] = { CTL_KERN, KERN_PROC, KERN_PROC_CWD, 0 };\n\tsize_t\tlen = sizeof info;\n\n\tif (fallback)\n\t\treturn (osdep_get_cwd_fallback(fd));\n\n\tif ((name[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tif (sysctl(name, 4, &info, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\tfallback = 1;\n\t\t\treturn (osdep_get_cwd_fallback(fd));\n\t\t}\n\t\treturn (NULL);\n\t}\n\treturn (info.kf_path);\n}\n#else /* !KERN_PROC_CWD */\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (osdep_get_cwd_fallback(fd));\n}\n#endif /* KERN_PROC_CWD */\n\nstruct event_base *\nosdep_event_init(void)\n{\n\tstruct event_base\t*base;\n\n\t/*\n\t * On some versions of FreeBSD, kqueue doesn't work properly on tty\n\t * file descriptors. This is fixed in recent FreeBSD versions.\n\t */\n\tsetenv(\"EVENT_NOKQUEUE\", \"1\", 1);\n\n\tbase = event_init();\n\tunsetenv(\"EVENT_NOKQUEUE\");\n\treturn (base);\n}\n"
        },
        {
          "name": "osdep-haiku.c",
          "type": "blob",
          "size": 1.2744140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <unistd.h>\n#include <kernel/OS.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tpid_t\t\ttid;\n\tteam_info\ttinfo;\n\n\tif ((tid = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tif (get_team_info(tid, &tinfo) != B_OK)\n\t\treturn (NULL);\n\n\t/* Up to the first 64 characters. */\n\treturn (xstrdup(tinfo.args));\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-hpux.c",
          "type": "blob",
          "size": 1.0576171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, __unused char *tty)\n{\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(__unused int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-linux.c",
          "type": "blob",
          "size": 2.2119140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tFILE\t*f;\n\tchar\t*path, *buf;\n\tsize_t\t len;\n\tint\t ch;\n\tpid_t\t pgrp;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cmdline\", (long long) pgrp);\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tfree(path);\n\t\treturn (NULL);\n\t}\n\tfree(path);\n\n\tlen = 0;\n\tbuf = NULL;\n\twhile ((ch = fgetc(f)) != EOF) {\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t}\n\tif (buf != NULL)\n\t\tbuf[len] = '\\0';\n\n\tfclose(f);\n\treturn (buf);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tpid_t\t\t pgrp, sid;\n\tssize_t\t\t n;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cwd\", (long long) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\n\tif (n == -1 && ioctl(fd, TIOCGSID, &sid) != -1) {\n\t\txasprintf(&path, \"/proc/%lld/cwd\", (long long) sid);\n\t\tn = readlink(path, target, MAXPATHLEN);\n\t\tfree(path);\n\t}\n\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\tstruct event_base\t*base;\n\n\t/* On Linux, epoll doesn't work on /dev/null (yes, really). */\n\tsetenv(\"EVENT_NOEPOLL\", \"1\", 1);\n\n\tbase = event_init();\n\tunsetenv(\"EVENT_NOEPOLL\");\n\treturn (base);\n}\n"
        },
        {
          "name": "osdep-netbsd.c",
          "type": "blob",
          "size": 3.5087890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n#define is_runnable(p) \\\n\t((p)->p_stat == LSRUN || (p)->p_stat == SIDL)\n#define is_stopped(p) \\\n\t((p)->p_stat == SSTOP || (p)->p_stat == SZOMB)\n\nstruct kinfo_proc2\t*cmp_procs(struct kinfo_proc2 *, struct kinfo_proc2 *);\n\nstruct kinfo_proc2 *\ncmp_procs(struct kinfo_proc2 *p1, struct kinfo_proc2 *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->p_estcpu > p2->p_estcpu)\n\t\treturn (p1);\n\tif (p1->p_estcpu < p2->p_estcpu)\n\t\treturn (p2);\n\n\tif (p1->p_slptime < p2->p_slptime)\n\t\treturn (p1);\n\tif (p1->p_slptime > p2->p_slptime)\n\t\treturn (p2);\n\n\tif (p1->p_pid > p2->p_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tint\t\t mib[6];\n\tstruct stat\t sb;\n\tsize_t\t\t len, i;\n\tstruct kinfo_proc2 *buf, *newbuf, *bestp;\n\tchar\t\t*name;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tbuf = NULL;\n\tlen = sizeof bestp;\n\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC2;\n\tmib[2] = KERN_PROC_PGRP;\n\tmib[4] = sizeof *buf;\n\nretry:\n\tmib[5] = 0;\n\n\tif (sysctl(mib, __arraycount(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tmib[5] = len / (sizeof *buf);\n\tif (sysctl(mib, __arraycount(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / (sizeof *buf); i++) {\n\t\tif (buf[i].p_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->p_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\ttarget[PATH_MAX + 1];\n\tpid_t\t\tpgrp;\n#ifdef KERN_PROC_CWD\n\tint\t\tmib[4];\n\tsize_t\t\tlen;\n#else\n\tchar\t\t*path;\n\tssize_t\t\tn;\n#endif\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n#ifdef KERN_PROC_CWD\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC_ARGS;\n\tmib[2] = pgrp;\n\tmib[3] = KERN_PROC_CWD;\n\tlen = sizeof(target);\n\tif (sysctl(mib, __arraycount(mib), target, &len, NULL, 0) == 0)\n\t\treturn (target);\n#else\n\txasprintf(&path, \"/proc/%lld/cwd\", (long long) pgrp);\n\tn = readlink(path, target, sizeof(target) - 1);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n#endif\n\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-openbsd.c",
          "type": "blob",
          "size": 3.626953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/sysctl.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"compat.h\"\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->p_stat == SRUN || (p)->p_stat == SIDL || (p)->p_stat == SONPROC)\n#define is_stopped(p) \\\n\t((p)->p_stat == SSTOP || (p)->p_stat == SDEAD)\n\nstatic struct kinfo_proc *cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t *osdep_get_name(int, char *);\nchar\t\t\t *osdep_get_cwd(int);\nstruct event_base\t *osdep_event_init(void);\n\nstatic struct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->p_estcpu > p2->p_estcpu)\n\t\treturn (p1);\n\tif (p1->p_estcpu < p2->p_estcpu)\n\t\treturn (p2);\n\n\tif (p1->p_slptime < p2->p_slptime)\n\t\treturn (p1);\n\tif (p1->p_slptime > p2->p_slptime)\n\t\treturn (p2);\n\n\tif ((p1->p_flag & P_SINTR) && !(p2->p_flag & P_SINTR))\n\t\treturn (p1);\n\tif (!(p1->p_flag & P_SINTR) && (p2->p_flag & P_SINTR))\n\t\treturn (p2);\n\n\tif (strcmp(p1->p_comm, p2->p_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->p_comm, p2->p_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->p_pid > p2->p_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[6] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0,\n\t\t\t\t    sizeof(struct kinfo_proc), 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\tgoto error;\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tmib[5] = (int)(len / sizeof(struct kinfo_proc));\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif ((dev_t)buf[i].p_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->p_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tint\t\tname[] = { CTL_KERN, KERN_PROC_CWD, 0 };\n\tstatic char\tpath[PATH_MAX];\n\tsize_t\t\tpathlen = sizeof path;\n\n\tif ((name[2] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\tif (sysctl(name, 3, path, &pathlen, NULL, 0) != 0)\n\t\treturn (NULL);\n\treturn (path);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-sunos.c",
          "type": "blob",
          "size": 2.490234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Todd Carson <toc@daybefore.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <fcntl.h>\n#include <procfs.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, char *tty)\n{\n\tstruct psinfo\t p;\n\tstruct stat\t st;\n\tchar\t\t*path;\n\tssize_t\t\t bytes;\n\tint\t\t f;\n\tpid_t\t\t pgrp;\n\n\tif ((f = open(tty, O_RDONLY)) < 0)\n\t\treturn (NULL);\n\n\tif (fstat(f, &st) != 0 || ioctl(f, TIOCGPGRP, &pgrp) != 0) {\n\t\tclose(f);\n\t\treturn (NULL);\n\t}\n\tclose(f);\n\n\txasprintf(&path, \"/proc/%u/psinfo\", (u_int) pgrp);\n\tf = open(path, O_RDONLY);\n\tfree(path);\n\tif (f < 0)\n\t\treturn (NULL);\n\n\tbytes = read(f, &p, sizeof(p));\n\tclose(f);\n\tif (bytes != sizeof(p))\n\t\treturn (NULL);\n\n\tif (p.pr_ttydev != st.st_rdev)\n\t\treturn (NULL);\n\n\treturn (xstrdup(p.pr_fname));\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tconst char\t*ttypath;\n\tssize_t\t\t n;\n\tpid_t\t\t pgrp;\n\tint\t\t retval, ttyfd;\n\n\tif ((ttypath = ptsname(fd)) == NULL)\n\t\treturn (NULL);\n\tif ((ttyfd = open(ttypath, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/path/cwd\", (u_int) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\tstruct event_base\t*base;\n\n\t/*\n\t * On Illumos, evports don't seem to work properly. It is not clear if\n\t * this a problem in libevent, with the way tmux uses file descriptors,\n\t * or with some types of file descriptor. But using poll instead is\n\t * fine.\n\t */\n\tsetenv(\"EVENT_NOEVPORT\", \"1\", 1);\n\n\tbase = event_init();\n\tunsetenv(\"EVENT_NOEVPORT\");\n\treturn (base);\n}\n"
        },
        {
          "name": "osdep-unknown.c",
          "type": "blob",
          "size": 1.048828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, __unused char *tty)\n{\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "paste.c",
          "type": "blob",
          "size": 7.1689453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Set of paste buffers. Note that paste buffer data is not necessarily a C\n * string!\n */\n\nstruct paste_buffer {\n\tchar\t\t*data;\n\tsize_t\t\t size;\n\n\tchar\t\t*name;\n\ttime_t\t\t created;\n\tint\t\t automatic;\n\tu_int\t\t order;\n\n\tRB_ENTRY(paste_buffer) name_entry;\n\tRB_ENTRY(paste_buffer) time_entry;\n};\n\nstatic u_int\tpaste_next_index;\nstatic u_int\tpaste_next_order;\nstatic u_int\tpaste_num_automatic;\nstatic RB_HEAD(paste_name_tree, paste_buffer) paste_by_name;\nstatic RB_HEAD(paste_time_tree, paste_buffer) paste_by_time;\n\nstatic int\tpaste_cmp_names(const struct paste_buffer *,\n\t\t    const struct paste_buffer *);\nRB_GENERATE_STATIC(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);\n\nstatic int\tpaste_cmp_times(const struct paste_buffer *,\n\t\t    const struct paste_buffer *);\nRB_GENERATE_STATIC(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);\n\nstatic int\npaste_cmp_names(const struct paste_buffer *a, const struct paste_buffer *b)\n{\n\treturn (strcmp(a->name, b->name));\n}\n\nstatic int\npaste_cmp_times(const struct paste_buffer *a, const struct paste_buffer *b)\n{\n\tif (a->order > b->order)\n\t\treturn (-1);\n\tif (a->order < b->order)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Get paste buffer name. */\nconst char *\npaste_buffer_name(struct paste_buffer *pb)\n{\n\treturn (pb->name);\n}\n\n/* Get paste buffer order. */\nu_int\npaste_buffer_order(struct paste_buffer *pb)\n{\n\treturn (pb->order);\n}\n\n/* Get paste buffer created. */\ntime_t\npaste_buffer_created(struct paste_buffer *pb)\n{\n\treturn (pb->created);\n}\n\n/* Get paste buffer data. */\nconst char *\npaste_buffer_data(struct paste_buffer *pb, size_t *size)\n{\n\tif (size != NULL)\n\t\t*size = pb->size;\n\treturn (pb->data);\n}\n\n/* Walk paste buffers by time. */\nstruct paste_buffer *\npaste_walk(struct paste_buffer *pb)\n{\n\tif (pb == NULL)\n\t\treturn (RB_MIN(paste_time_tree, &paste_by_time));\n\treturn (RB_NEXT(paste_time_tree, &paste_by_time, pb));\n}\n\nint\npaste_is_empty(void)\n{\n\treturn RB_ROOT(&paste_by_time) == NULL;\n}\n\n/* Get the most recent automatic buffer. */\nstruct paste_buffer *\npaste_get_top(const char **name)\n{\n\tstruct paste_buffer\t*pb;\n\n\tpb = RB_MIN(paste_time_tree, &paste_by_time);\n\twhile (pb != NULL && !pb->automatic)\n\t\tpb = RB_NEXT(paste_time_tree, &paste_by_time, pb);\n\tif (pb == NULL)\n\t\treturn (NULL);\n\tif (name != NULL)\n\t\t*name = pb->name;\n\treturn (pb);\n}\n\n/* Get a paste buffer by name. */\nstruct paste_buffer *\npaste_get_name(const char *name)\n{\n\tstruct paste_buffer\tpbfind;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn (NULL);\n\n\tpbfind.name = (char *)name;\n\treturn (RB_FIND(paste_name_tree, &paste_by_name, &pbfind));\n}\n\n/* Free a paste buffer. */\nvoid\npaste_free(struct paste_buffer *pb)\n{\n\tnotify_paste_buffer(pb->name, 1);\n\n\tRB_REMOVE(paste_name_tree, &paste_by_name, pb);\n\tRB_REMOVE(paste_time_tree, &paste_by_time, pb);\n\tif (pb->automatic)\n\t\tpaste_num_automatic--;\n\n\tfree(pb->data);\n\tfree(pb->name);\n\tfree(pb);\n}\n\n/*\n * Add an automatic buffer, freeing the oldest automatic item if at limit. Note\n * that the caller is responsible for allocating data.\n */\nvoid\npaste_add(const char *prefix, char *data, size_t size)\n{\n\tstruct paste_buffer\t*pb, *pb1;\n\tu_int\t\t\t limit;\n\n\tif (prefix == NULL)\n\t\tprefix = \"buffer\";\n\n\tif (size == 0) {\n\t\tfree(data);\n\t\treturn;\n\t}\n\n\tlimit = options_get_number(global_options, \"buffer-limit\");\n\tRB_FOREACH_REVERSE_SAFE(pb, paste_time_tree, &paste_by_time, pb1) {\n\t\tif (paste_num_automatic < limit)\n\t\t\tbreak;\n\t\tif (pb->automatic)\n\t\t\tpaste_free(pb);\n\t}\n\n\tpb = xmalloc(sizeof *pb);\n\n\tpb->name = NULL;\n\tdo {\n\t\tfree(pb->name);\n\t\txasprintf(&pb->name, \"%s%u\", prefix, paste_next_index);\n\t\tpaste_next_index++;\n\t} while (paste_get_name(pb->name) != NULL);\n\n\tpb->data = data;\n\tpb->size = size;\n\n\tpb->automatic = 1;\n\tpaste_num_automatic++;\n\n\tpb->created = time(NULL);\n\n\tpb->order = paste_next_order++;\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\tRB_INSERT(paste_time_tree, &paste_by_time, pb);\n\n\tnotify_paste_buffer(pb->name, 0);\n}\n\n/* Rename a paste buffer. */\nint\npaste_rename(const char *oldname, const char *newname, char **cause)\n{\n\tstruct paste_buffer\t*pb, *pb_new;\n\n\tif (cause != NULL)\n\t\t*cause = NULL;\n\n\tif (oldname == NULL || *oldname == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"no buffer\");\n\t\treturn (-1);\n\t}\n\tif (newname == NULL || *newname == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"new name is empty\");\n\t\treturn (-1);\n\t}\n\n\tpb = paste_get_name(oldname);\n\tif (pb == NULL) {\n\t\tif (cause != NULL)\n\t\t\txasprintf(cause, \"no buffer %s\", oldname);\n\t\treturn (-1);\n\t}\n\n\tpb_new = paste_get_name(newname);\n\tif (pb_new == pb)\n\t\treturn (0);\n\tif (pb_new != NULL)\n\t\tpaste_free(pb_new);\n\n\tRB_REMOVE(paste_name_tree, &paste_by_name, pb);\n\n\tfree(pb->name);\n\tpb->name = xstrdup(newname);\n\n\tif (pb->automatic)\n\t\tpaste_num_automatic--;\n\tpb->automatic = 0;\n\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\n\tnotify_paste_buffer(oldname, 1);\n\tnotify_paste_buffer(newname, 0);\n\n\treturn (0);\n}\n\n/*\n * Add or replace an item in the store. Note that the caller is responsible for\n * allocating data.\n */\nint\npaste_set(char *data, size_t size, const char *name, char **cause)\n{\n\tstruct paste_buffer\t*pb, *old;\n\n\tif (cause != NULL)\n\t\t*cause = NULL;\n\n\tif (size == 0) {\n\t\tfree(data);\n\t\treturn (0);\n\t}\n\tif (name == NULL) {\n\t\tpaste_add(NULL, data, size);\n\t\treturn (0);\n\t}\n\n\tif (*name == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"empty buffer name\");\n\t\treturn (-1);\n\t}\n\n\tpb = xmalloc(sizeof *pb);\n\n\tpb->name = xstrdup(name);\n\n\tpb->data = data;\n\tpb->size = size;\n\n\tpb->automatic = 0;\n\tpb->order = paste_next_order++;\n\n\tpb->created = time(NULL);\n\n\tif ((old = paste_get_name(name)) != NULL)\n\t\tpaste_free(old);\n\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\tRB_INSERT(paste_time_tree, &paste_by_time, pb);\n\n\tnotify_paste_buffer(name, 0);\n\n\treturn (0);\n}\n\n/* Set paste data without otherwise changing it. */\nvoid\npaste_replace(struct paste_buffer *pb, char *data, size_t size)\n{\n\tfree(pb->data);\n\tpb->data = data;\n\tpb->size = size;\n\n\tnotify_paste_buffer(pb->name, 0);\n}\n\n/* Convert start of buffer into a nice string. */\nchar *\npaste_make_sample(struct paste_buffer *pb)\n{\n\tchar\t\t*buf;\n\tsize_t\t\t len, used;\n\tconst int\t flags = VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL;\n\tconst size_t\t width = 200;\n\n\tlen = pb->size;\n\tif (len > width)\n\t\tlen = width;\n\tbuf = xreallocarray(NULL, len, 4 + 4);\n\n\tused = utf8_strvis(buf, pb->data, len, flags);\n\tif (pb->size > width || used > width)\n\t\tstrlcpy(buf + width, \"...\", 4);\n\treturn (buf);\n}\n"
        },
        {
          "name": "popup.c",
          "type": "blob",
          "size": 18.8291015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2020 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct popup_data {\n\tstruct client\t\t *c;\n\tstruct cmdq_item\t *item;\n\tint\t\t\t  flags;\n\tchar\t\t\t *title;\n\n\tstruct grid_cell\t  border_cell;\n\tenum box_lines\t\t  border_lines;\n\n\tstruct screen\t\t  s;\n\tstruct grid_cell\t  defaults;\n\tstruct colour_palette\t  palette;\n\n\tstruct job\t\t *job;\n\tstruct input_ctx\t *ictx;\n\tint\t\t\t  status;\n\tpopup_close_cb\t\t  cb;\n\tvoid\t\t\t *arg;\n\n\tstruct menu\t\t *menu;\n\tstruct menu_data\t *md;\n\tint\t\t\t  close;\n\n\t/* Current position and size. */\n\tu_int\t\t\t  px;\n\tu_int\t\t\t  py;\n\tu_int\t\t\t  sx;\n\tu_int\t\t\t  sy;\n\n\t/* Preferred position and size. */\n\tu_int\t\t\t  ppx;\n\tu_int\t\t\t  ppy;\n\tu_int\t\t\t  psx;\n\tu_int\t\t\t  psy;\n\n\tenum { OFF, MOVE, SIZE }  dragging;\n\tu_int\t\t\t  dx;\n\tu_int\t\t\t  dy;\n\n\tu_int\t\t\t  lx;\n\tu_int\t\t\t  ly;\n\tu_int\t\t\t  lb;\n};\n\nstruct popup_editor {\n\tchar\t\t\t*path;\n\tpopup_finish_edit_cb\t cb;\n\tvoid\t\t\t*arg;\n};\n\nstatic const struct menu_item popup_menu_items[] = {\n\t{ \"Close\", 'q', NULL },\n\t{ \"#{?buffer_name,Paste #[underscore]#{buffer_name},}\", 'p', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Fill Space\", 'F', NULL },\n\t{ \"Centre\", 'C', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"To Horizontal Pane\", 'h', NULL },\n\t{ \"To Vertical Pane\", 'v', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nstatic const struct menu_item popup_internal_menu_items[] = {\n\t{ \"Close\", 'q', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Fill Space\", 'F', NULL },\n\t{ \"Centre\", 'C', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nstatic void\npopup_redraw_cb(const struct tty_ctx *ttyctx)\n{\n\tstruct popup_data\t*pd = ttyctx->arg;\n\n\tpd->c->flags |= CLIENT_REDRAWOVERLAY;\n}\n\nstatic int\npopup_set_client_cb(struct tty_ctx *ttyctx, struct client *c)\n{\n\tstruct popup_data\t*pd = ttyctx->arg;\n\n\tif (c != pd->c)\n\t\treturn (0);\n\tif (pd->c->flags & CLIENT_REDRAWOVERLAY)\n\t\treturn (0);\n\n\tttyctx->bigger = 0;\n\tttyctx->wox = 0;\n\tttyctx->woy = 0;\n\tttyctx->wsx = c->tty.sx;\n\tttyctx->wsy = c->tty.sy;\n\n\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\tttyctx->xoff = ttyctx->rxoff = pd->px;\n\t\tttyctx->yoff = ttyctx->ryoff = pd->py;\n\t} else {\n\t\tttyctx->xoff = ttyctx->rxoff = pd->px + 1;\n\t\tttyctx->yoff = ttyctx->ryoff = pd->py + 1;\n\t}\n\n\treturn (1);\n}\n\nstatic void\npopup_init_ctx_cb(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx)\n{\n\tstruct popup_data\t*pd = ctx->arg;\n\n\tmemcpy(&ttyctx->defaults, &pd->defaults, sizeof ttyctx->defaults);\n\tttyctx->palette = &pd->palette;\n\tttyctx->redraw_cb = popup_redraw_cb;\n\tttyctx->set_client_cb = popup_set_client_cb;\n\tttyctx->arg = pd;\n}\n\nstatic struct screen *\npopup_mode_cb(__unused struct client *c, void *data, u_int *cx, u_int *cy)\n{\n\tstruct popup_data\t*pd = data;\n\n\tif (pd->md != NULL)\n\t\treturn (menu_mode_cb(c, pd->md, cx, cy));\n\n\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\t*cx = pd->px + pd->s.cx;\n\t\t*cy = pd->py + pd->s.cy;\n\t} else {\n\t\t*cx = pd->px + 1 + pd->s.cx;\n\t\t*cy = pd->py + 1 + pd->s.cy;\n\t}\n\treturn (&pd->s);\n}\n\n/* Return parts of the input range which are not obstructed by the popup. */\nstatic void\npopup_check_cb(struct client* c, void *data, u_int px, u_int py, u_int nx,\n    struct overlay_ranges *r)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct overlay_ranges\t or[2];\n\tu_int\t\t\t i, j, k = 0;\n\n\tif (pd->md != NULL) {\n\t\t/* Check each returned range for the menu against the popup. */\n\t\tmenu_check_cb(c, pd->md, px, py, nx, r);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tserver_client_overlay_range(pd->px, pd->py, pd->sx,\n\t\t\t    pd->sy, r->px[i], py, r->nx[i], &or[i]);\n\t\t}\n\n\t\t/*\n\t\t * or has up to OVERLAY_MAX_RANGES non-overlapping ranges,\n\t\t * ordered from left to right. Collect them in the output.\n\t\t */\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t/* Each or[i] only has 2 ranges. */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (or[i].nx[j] > 0) {\n\t\t\t\t\tr->px[k] = or[i].px[j];\n\t\t\t\t\tr->nx[k] = or[i].nx[j];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Zero remaining ranges if any. */\n\t\tfor (i = k; i < OVERLAY_MAX_RANGES; i++) {\n\t\t\tr->px[i] = 0;\n\t\t\tr->nx[i] = 0;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tserver_client_overlay_range(pd->px, pd->py, pd->sx, pd->sy, px, py, nx,\n\t    r);\n}\n\nstatic void\npopup_draw_cb(struct client *c, void *data, struct screen_redraw_ctx *rctx)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct screen\t\t s;\n\tstruct screen_write_ctx\t ctx;\n\tu_int\t\t\t i, px = pd->px, py = pd->py;\n\tstruct colour_palette\t*palette = &pd->palette;\n\tstruct grid_cell\t defaults;\n\n\tscreen_init(&s, pd->sx, pd->sy, 0);\n\tscreen_write_start(&ctx, &s);\n\tscreen_write_clearscreen(&ctx, 8);\n\n\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\tscreen_write_cursormove(&ctx, 0, 0, 0);\n\t\tscreen_write_fast_copy(&ctx, &pd->s, 0, 0, pd->sx, pd->sy);\n\t} else if (pd->sx > 2 && pd->sy > 2) {\n\t\tscreen_write_box(&ctx, pd->sx, pd->sy, pd->border_lines,\n\t\t    &pd->border_cell, pd->title);\n\t\tscreen_write_cursormove(&ctx, 1, 1, 0);\n\t\tscreen_write_fast_copy(&ctx, &pd->s, 0, 0, pd->sx - 2,\n\t\t    pd->sy - 2);\n\t}\n\tscreen_write_stop(&ctx);\n\n\tmemcpy(&defaults, &pd->defaults, sizeof defaults);\n\tif (defaults.fg == 8)\n\t\tdefaults.fg = palette->fg;\n\tif (defaults.bg == 8)\n\t\tdefaults.bg = palette->bg;\n\n\tif (pd->md != NULL) {\n\t\tc->overlay_check = menu_check_cb;\n\t\tc->overlay_data = pd->md;\n\t} else {\n\t\tc->overlay_check = NULL;\n\t\tc->overlay_data = NULL;\n\t}\n\tfor (i = 0; i < pd->sy; i++) {\n\t\ttty_draw_line(tty, &s, 0, i, pd->sx, px, py + i, &defaults,\n\t\t    palette);\n\t}\n\tscreen_free(&s);\n\tif (pd->md != NULL) {\n\t\tc->overlay_check = NULL;\n\t\tc->overlay_data = NULL;\n\t\tmenu_draw_cb(c, pd->md, rctx);\n\t}\n\tc->overlay_check = popup_check_cb;\n\tc->overlay_data = pd;\n}\n\nstatic void\npopup_free_cb(struct client *c, void *data)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct cmdq_item\t*item = pd->item;\n\n\tif (pd->md != NULL)\n\t\tmenu_free_cb(c, pd->md);\n\n\tif (pd->cb != NULL)\n\t\tpd->cb(pd->status, pd->arg);\n\n\tif (item != NULL) {\n\t\tif (cmdq_get_client(item) != NULL &&\n\t\t    cmdq_get_client(item)->session == NULL)\n\t\t\tcmdq_get_client(item)->retval = pd->status;\n\t\tcmdq_continue(item);\n\t}\n\tserver_client_unref(pd->c);\n\n\tif (pd->job != NULL)\n\t\tjob_free(pd->job);\n\tinput_free(pd->ictx);\n\n\tscreen_free(&pd->s);\n\tcolour_palette_free(&pd->palette);\n\n\tfree(pd->title);\n\tfree(pd);\n}\n\nstatic void\npopup_resize_cb(__unused struct client *c, void *data)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct tty\t\t*tty = &c->tty;\n\n\tif (pd == NULL)\n\t\treturn;\n\tif (pd->md != NULL)\n\t\tmenu_free_cb(c, pd->md);\n\n\t/* Adjust position and size. */\n\tif (pd->psy > tty->sy)\n\t\tpd->sy = tty->sy;\n\telse\n\t\tpd->sy = pd->psy;\n\tif (pd->psx > tty->sx)\n\t\tpd->sx = tty->sx;\n\telse\n\t\tpd->sx = pd->psx;\n\tif (pd->ppy + pd->sy > tty->sy)\n\t\tpd->py = tty->sy - pd->sy;\n\telse\n\t\tpd->py = pd->ppy;\n\tif (pd->ppx + pd->sx > tty->sx)\n\t\tpd->px = tty->sx - pd->sx;\n\telse\n\t\tpd->px = pd->ppx;\n\n\t/* Avoid zero size screens. */\n\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\tscreen_resize(&pd->s, pd->sx, pd->sy, 0);\n\t\tif (pd->job != NULL)\n\t\t\tjob_resize(pd->job, pd->sx, pd->sy );\n\t} else if (pd->sx > 2 && pd->sy > 2) {\n\t\tscreen_resize(&pd->s, pd->sx - 2, pd->sy - 2, 0);\n\t\tif (pd->job != NULL)\n\t\t\tjob_resize(pd->job, pd->sx - 2, pd->sy - 2);\n\t}\n}\n\nstatic void\npopup_make_pane(struct popup_data *pd, enum layout_type type)\n{\n\tstruct client\t\t*c = pd->c;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct layout_cell\t*lc;\n\tstruct window_pane\t*wp = w->active, *new_wp;\n\tu_int\t\t\t hlimit;\n\tconst char\t\t*shell;\n\n\twindow_unzoom(w, 1);\n\n\tlc = layout_split_pane(wp, type, -1, 0);\n\thlimit = options_get_number(s->options, \"history-limit\");\n\tnew_wp = window_add_pane(wp->window, NULL, hlimit, 0);\n\tlayout_assign_pane(lc, new_wp, 0);\n\n\tif (pd->job != NULL) {\n\t\tnew_wp->fd = job_transfer(pd->job, &new_wp->pid, new_wp->tty,\n\t\t    sizeof new_wp->tty);\n\t\tpd->job = NULL;\n\t}\n\n\tscreen_set_title(&pd->s, new_wp->base.title);\n\tscreen_free(&new_wp->base);\n\tmemcpy(&new_wp->base, &pd->s, sizeof wp->base);\n\tscreen_resize(&new_wp->base, new_wp->sx, new_wp->sy, 1);\n\tscreen_init(&pd->s, 1, 1, 0);\n\n\tshell = options_get_string(s->options, \"default-shell\");\n\tif (!checkshell(shell))\n\t\tshell = _PATH_BSHELL;\n\tnew_wp->shell = xstrdup(shell);\n\n\twindow_pane_set_event(new_wp);\n\twindow_set_active_pane(w, new_wp, 1);\n\tnew_wp->flags |= PANE_CHANGED;\n\n\tpd->close = 1;\n}\n\nstatic void\npopup_menu_done(__unused struct menu *menu, __unused u_int choice,\n    key_code key, void *data)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct client\t\t*c = pd->c;\n\tstruct paste_buffer\t*pb;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len;\n\n\tpd->md = NULL;\n\tpd->menu = NULL;\n\tserver_redraw_client(pd->c);\n\n\tswitch (key) {\n\tcase 'p':\n\t\tpb = paste_get_top(NULL);\n\t\tif (pb != NULL) {\n\t\t\tbuf = paste_buffer_data(pb, &len);\n\t\t\tbufferevent_write(job_get_event(pd->job), buf, len);\n\t\t}\n\t\tbreak;\n\tcase 'F':\n\t\tpd->sx = c->tty.sx;\n\t\tpd->sy = c->tty.sy;\n\t\tpd->px = 0;\n\t\tpd->py = 0;\n\t\tserver_redraw_client(c);\n\t\tbreak;\n\tcase 'C':\n\t\tpd->px = c->tty.sx / 2 - pd->sx / 2;\n\t\tpd->py = c->tty.sy / 2 - pd->sy / 2;\n\t\tserver_redraw_client(c);\n\t\tbreak;\n\tcase 'h':\n\t\tpopup_make_pane(pd, LAYOUT_LEFTRIGHT);\n\t\tbreak;\n\tcase 'v':\n\t\tpopup_make_pane(pd, LAYOUT_TOPBOTTOM);\n\t\tbreak;\n\tcase 'q':\n\t\tpd->close = 1;\n\t\tbreak;\n\t}\n}\n\nstatic void\npopup_handle_drag(struct client *c, struct popup_data *pd,\n    struct mouse_event *m)\n{\n\tu_int\tpx, py;\n\n\tif (!MOUSE_DRAG(m->b))\n\t\tpd->dragging = OFF;\n\telse if (pd->dragging == MOVE) {\n\t\tif (m->x < pd->dx)\n\t\t\tpx = 0;\n\t\telse if (m->x - pd->dx + pd->sx > c->tty.sx)\n\t\t\tpx = c->tty.sx - pd->sx;\n\t\telse\n\t\t\tpx = m->x - pd->dx;\n\t\tif (m->y < pd->dy)\n\t\t\tpy = 0;\n\t\telse if (m->y - pd->dy + pd->sy > c->tty.sy)\n\t\t\tpy = c->tty.sy - pd->sy;\n\t\telse\n\t\t\tpy = m->y - pd->dy;\n\t\tpd->px = px;\n\t\tpd->py = py;\n\t\tpd->dx = m->x - pd->px;\n\t\tpd->dy = m->y - pd->py;\n\t\tpd->ppx = px;\n\t\tpd->ppy = py;\n\t\tserver_redraw_client(c);\n\t} else if (pd->dragging == SIZE) {\n\t\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\t\tif (m->x < pd->px + 1)\n\t\t\t\treturn;\n\t\t\tif (m->y < pd->py + 1)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (m->x < pd->px + 3)\n\t\t\t\treturn;\n\t\t\tif (m->y < pd->py + 3)\n\t\t\t\treturn;\n\t\t}\n\t\tpd->sx = m->x - pd->px;\n\t\tpd->sy = m->y - pd->py;\n\t\tpd->psx = pd->sx;\n\t\tpd->psy = pd->sy;\n\n\t\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\t\tscreen_resize(&pd->s, pd->sx, pd->sy, 0);\n\t\t\tif (pd->job != NULL)\n\t\t\t\tjob_resize(pd->job, pd->sx, pd->sy);\n\t\t} else {\n\t\t\tscreen_resize(&pd->s, pd->sx - 2, pd->sy - 2, 0);\n\t\t\tif (pd->job != NULL)\n\t\t\t\tjob_resize(pd->job, pd->sx - 2, pd->sy - 2);\n\t\t}\n\t\tserver_redraw_client(c);\n\t}\n}\n\nstatic int\npopup_key_cb(struct client *c, void *data, struct key_event *event)\n{\n\tstruct popup_data\t*pd = data;\n\tstruct mouse_event\t*m = &event->m;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len;\n\tu_int\t\t\t px, py, x;\n\tenum { NONE, LEFT, RIGHT, TOP, BOTTOM } border = NONE;\n\n\tif (pd->md != NULL) {\n\t\tif (menu_key_cb(c, pd->md, event) == 1) {\n\t\t\tpd->md = NULL;\n\t\t\tpd->menu = NULL;\n\t\t\tif (pd->close)\n\t\t\t\tserver_client_clear_overlay(c);\n\t\t\telse\n\t\t\t\tserver_redraw_client(c);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (KEYC_IS_MOUSE(event->key)) {\n\t\tif (pd->dragging != OFF) {\n\t\t\tpopup_handle_drag(c, pd, m);\n\t\t\tgoto out;\n\t\t}\n\t\tif (m->x < pd->px ||\n\t\t    m->x > pd->px + pd->sx - 1 ||\n\t\t    m->y < pd->py ||\n\t\t    m->y > pd->py + pd->sy - 1) {\n\t\t\tif (MOUSE_BUTTONS(m->b) == MOUSE_BUTTON_3)\n\t\t\t\tgoto menu;\n\t\t\treturn (0);\n\t\t}\n\t\tif (pd->border_lines != BOX_LINES_NONE) {\n\t\t\tif (m->x == pd->px)\n\t\t\t\tborder = LEFT;\n\t\t\telse if (m->x == pd->px + pd->sx - 1)\n\t\t\t\tborder = RIGHT;\n\t\t\telse if (m->y == pd->py)\n\t\t\t\tborder = TOP;\n\t\t\telse if (m->y == pd->py + pd->sy - 1)\n\t\t\t\tborder = BOTTOM;\n\t\t}\n\t\tif ((m->b & MOUSE_MASK_MODIFIERS) == 0 &&\n\t\t    MOUSE_BUTTONS(m->b) == MOUSE_BUTTON_3 &&\n\t\t    (border == LEFT || border == TOP))\n\t\t    goto menu;\n\t\tif (((m->b & MOUSE_MASK_MODIFIERS) == MOUSE_MASK_META) ||\n\t\t    border != NONE) {\n\t\t\tif (!MOUSE_DRAG(m->b))\n\t\t\t\tgoto out;\n\t\t\tif (MOUSE_BUTTONS(m->lb) == MOUSE_BUTTON_1)\n\t\t\t\tpd->dragging = MOVE;\n\t\t\telse if (MOUSE_BUTTONS(m->lb) == MOUSE_BUTTON_3)\n\t\t\t\tpd->dragging = SIZE;\n\t\t\tpd->dx = m->lx - pd->px;\n\t\t\tpd->dy = m->ly - pd->py;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((((pd->flags & (POPUP_CLOSEEXIT|POPUP_CLOSEEXITZERO)) == 0) ||\n\t    pd->job == NULL) &&\n\t    (event->key == '\\033' || event->key == ('c'|KEYC_CTRL)))\n\t\treturn (1);\n\tif (pd->job != NULL) {\n\t\tif (KEYC_IS_MOUSE(event->key)) {\n\t\t\t/* Must be inside, checked already. */\n\t\t\tif (pd->border_lines == BOX_LINES_NONE) {\n\t\t\t\tpx = m->x - pd->px;\n\t\t\t\tpy = m->y - pd->py;\n\t\t\t} else {\n\t\t\t\tpx = m->x - pd->px - 1;\n\t\t\t\tpy = m->y - pd->py - 1;\n\t\t\t}\n\t\t\tif (!input_key_get_mouse(&pd->s, m, px, py, &buf, &len))\n\t\t\t\treturn (0);\n\t\t\tbufferevent_write(job_get_event(pd->job), buf, len);\n\t\t\treturn (0);\n\t\t}\n\t\tinput_key(&pd->s, job_get_event(pd->job), event->key);\n\t}\n\treturn (0);\n\nmenu:\n\tpd->menu = menu_create(\"\");\n\tif (pd->flags & POPUP_INTERNAL) {\n\t\tmenu_add_items(pd->menu, popup_internal_menu_items, NULL, c,\n\t\t    NULL);\n\t} else\n\t\tmenu_add_items(pd->menu, popup_menu_items, NULL, c, NULL);\n\tif (m->x >= (pd->menu->width + 4) / 2)\n\t\tx = m->x - (pd->menu->width + 4) / 2;\n\telse\n\t\tx = 0;\n\tpd->md = menu_prepare(pd->menu, 0, 0, NULL, x, m->y, c,\n\t    BOX_LINES_DEFAULT, NULL, NULL, NULL, NULL, popup_menu_done, pd);\n\tc->flags |= CLIENT_REDRAWOVERLAY;\n\nout:\n\tpd->lx = m->x;\n\tpd->ly = m->y;\n\tpd->lb = m->b;\n\treturn (0);\n}\n\nstatic void\npopup_job_update_cb(struct job *job)\n{\n\tstruct popup_data\t*pd = job_get_data(job);\n\tstruct evbuffer\t\t*evb = job_get_event(job)->input;\n\tstruct client\t\t*c = pd->c;\n\tstruct screen\t\t*s = &pd->s;\n\tvoid\t\t\t*data = EVBUFFER_DATA(evb);\n\tsize_t\t\t\t size = EVBUFFER_LENGTH(evb);\n\n\tif (size == 0)\n\t\treturn;\n\n\tif (pd->md != NULL) {\n\t\tc->overlay_check = menu_check_cb;\n\t\tc->overlay_data = pd->md;\n\t} else {\n\t\tc->overlay_check = NULL;\n\t\tc->overlay_data = NULL;\n\t}\n\tinput_parse_screen(pd->ictx, s, popup_init_ctx_cb, pd, data, size);\n\tc->overlay_check = popup_check_cb;\n\tc->overlay_data = pd;\n\n\tevbuffer_drain(evb, size);\n}\n\nstatic void\npopup_job_complete_cb(struct job *job)\n{\n\tstruct popup_data\t*pd = job_get_data(job);\n\tint\t\t\t status;\n\n\tstatus = job_get_status(pd->job);\n\tif (WIFEXITED(status))\n\t\tpd->status = WEXITSTATUS(status);\n\telse if (WIFSIGNALED(status))\n\t\tpd->status = WTERMSIG(status);\n\telse\n\t\tpd->status = 0;\n\tpd->job = NULL;\n\n\tif ((pd->flags & POPUP_CLOSEEXIT) ||\n\t    ((pd->flags & POPUP_CLOSEEXITZERO) && pd->status == 0))\n\t\tserver_client_clear_overlay(pd->c);\n}\n\nint\npopup_display(int flags, enum box_lines lines, struct cmdq_item *item, u_int px,\n    u_int py, u_int sx, u_int sy, struct environ *env, const char *shellcmd,\n    int argc, char **argv, const char *cwd, const char *title, struct client *c,\n    struct session *s, const char *style, const char *border_style,\n    popup_close_cb cb, void *arg)\n{\n\tstruct popup_data\t*pd;\n\tu_int\t\t\t jx, jy;\n\tstruct options\t\t*o;\n\tstruct style\t\t sytmp;\n\n\tif (s != NULL)\n\t\to = s->curw->window->options;\n\telse\n\t\to = c->session->curw->window->options;\n\n\tif (lines == BOX_LINES_DEFAULT)\n\t\tlines = options_get_number(o, \"popup-border-lines\");\n\tif (lines == BOX_LINES_NONE) {\n\t\tif (sx < 1 || sy < 1)\n\t\t\treturn (-1);\n\t\tjx = sx;\n\t\tjy = sy;\n\t} else {\n\t\tif (sx < 3 || sy < 3)\n\t\t\treturn (-1);\n\t\tjx = sx - 2;\n\t\tjy = sy - 2;\n\t}\n\tif (c->tty.sx < sx || c->tty.sy < sy)\n\t\treturn (-1);\n\n\tpd = xcalloc(1, sizeof *pd);\n\tpd->item = item;\n\tpd->flags = flags;\n\tif (title != NULL)\n\t\tpd->title = xstrdup(title);\n\n\tpd->c = c;\n\tpd->c->references++;\n\n\tpd->cb = cb;\n\tpd->arg = arg;\n\tpd->status = 128 + SIGHUP;\n\n\tpd->border_lines = lines;\n\tmemcpy(&pd->border_cell, &grid_default_cell, sizeof pd->border_cell);\n\tstyle_apply(&pd->border_cell, o, \"popup-border-style\", NULL);\n\tif (border_style != NULL) {\n\t\tstyle_set(&sytmp, &grid_default_cell);\n\t\tif (style_parse(&sytmp, &pd->border_cell, border_style) == 0) {\n\t\t\tpd->border_cell.fg = sytmp.gc.fg;\n\t\t\tpd->border_cell.bg = sytmp.gc.bg;\n\t\t}\n\t}\n\tpd->border_cell.attr = 0;\n\n\tscreen_init(&pd->s, jx, jy, 0);\n\tscreen_set_default_cursor(&pd->s, global_w_options);\n\tcolour_palette_init(&pd->palette);\n\tcolour_palette_from_option(&pd->palette, global_w_options);\n\n\tmemcpy(&pd->defaults, &grid_default_cell, sizeof pd->defaults);\n\tstyle_apply(&pd->defaults, o, \"popup-style\", NULL);\n\tif (style != NULL) {\n\t\tstyle_set(&sytmp, &grid_default_cell);\n\t\tif (style_parse(&sytmp, &pd->defaults, style) == 0) {\n\t\t\tpd->defaults.fg = sytmp.gc.fg;\n\t\t\tpd->defaults.bg = sytmp.gc.bg;\n\t\t}\n\t}\n\tpd->defaults.attr = 0;\n\n\tpd->px = px;\n\tpd->py = py;\n\tpd->sx = sx;\n\tpd->sy = sy;\n\n\tpd->ppx = px;\n\tpd->ppy = py;\n\tpd->psx = sx;\n\tpd->psy = sy;\n\n\tpd->job = job_run(shellcmd, argc, argv, env, s, cwd,\n\t    popup_job_update_cb, popup_job_complete_cb, NULL, pd,\n\t    JOB_NOWAIT|JOB_PTY|JOB_KEEPWRITE|JOB_DEFAULTSHELL, jx, jy);\n\tpd->ictx = input_init(NULL, job_get_event(pd->job), &pd->palette);\n\n\tserver_client_set_overlay(c, 0, popup_check_cb, popup_mode_cb,\n\t    popup_draw_cb, popup_key_cb, popup_free_cb, popup_resize_cb, pd);\n\treturn (0);\n}\n\nstatic void\npopup_editor_free(struct popup_editor *pe)\n{\n\tunlink(pe->path);\n\tfree(pe->path);\n\tfree(pe);\n}\n\nstatic void\npopup_editor_close_cb(int status, void *arg)\n{\n\tstruct popup_editor\t*pe = arg;\n\tFILE\t\t\t*f;\n\tchar\t\t\t*buf = NULL;\n\toff_t\t\t\t len = 0;\n\n\tif (status != 0) {\n\t\tpe->cb(NULL, 0, pe->arg);\n\t\tpopup_editor_free(pe);\n\t\treturn;\n\t}\n\n\tf = fopen(pe->path, \"r\");\n\tif (f != NULL) {\n\t\tfseeko(f, 0, SEEK_END);\n\t\tlen = ftello(f);\n\t\tfseeko(f, 0, SEEK_SET);\n\n\t\tif (len == 0 ||\n\t\t    (uintmax_t)len > (uintmax_t)SIZE_MAX ||\n\t\t    (buf = malloc(len)) == NULL ||\n\t\t    fread(buf, len, 1, f) != 1) {\n\t\t\tfree(buf);\n\t\t\tbuf = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t\tfclose(f);\n\t}\n\tpe->cb(buf, len, pe->arg); /* callback now owns buffer */\n\tpopup_editor_free(pe);\n}\n\nint\npopup_editor(struct client *c, const char *buf, size_t len,\n    popup_finish_edit_cb cb, void *arg)\n{\n\tstruct popup_editor\t*pe;\n\tint\t\t\t fd;\n\tFILE\t\t\t*f;\n\tchar\t\t\t*cmd;\n\tchar\t\t\t path[] = _PATH_TMP \"tmux.XXXXXXXX\";\n\tconst char\t\t*editor;\n\tu_int\t\t\t px, py, sx, sy;\n\n\teditor = options_get_string(global_options, \"editor\");\n\tif (*editor == '\\0')\n\t\treturn (-1);\n\n\tfd = mkstemp(path);\n\tif (fd == -1)\n\t\treturn (-1);\n\tf = fdopen(fd, \"w\");\n\tif (f == NULL)\n\t\treturn (-1);\n\tif (fwrite(buf, len, 1, f) != 1) {\n\t\tfclose(f);\n\t\treturn (-1);\n\t}\n\tfclose(f);\n\n\tpe = xcalloc(1, sizeof *pe);\n\tpe->path = xstrdup(path);\n\tpe->cb = cb;\n\tpe->arg = arg;\n\n\tsx = c->tty.sx * 9 / 10;\n\tsy = c->tty.sy * 9 / 10;\n\tpx = (c->tty.sx / 2) - (sx / 2);\n\tpy = (c->tty.sy / 2) - (sy / 2);\n\n\txasprintf(&cmd, \"%s %s\", editor, path);\n\tif (popup_display(POPUP_INTERNAL|POPUP_CLOSEEXIT, BOX_LINES_DEFAULT,\n\t    NULL, px, py, sx, sy, NULL, cmd, 0, NULL, _PATH_TMP, NULL, c, NULL,\n\t    NULL, NULL, popup_editor_close_cb, pe) != 0) {\n\t\tpopup_editor_free(pe);\n\t\tfree(cmd);\n\t\treturn (-1);\n\t}\n\tfree(cmd);\n\treturn (0);\n}\n"
        },
        {
          "name": "presentations",
          "type": "tree",
          "content": null
        },
        {
          "name": "proc.c",
          "type": "blob",
          "size": 8.38671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <sys/utsname.h>\n\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#if defined(HAVE_NCURSES_H)\n#include <ncurses.h>\n#endif\n\n#include \"tmux.h\"\n\nstruct tmuxproc {\n\tconst char\t *name;\n\tint\t\t  exit;\n\n\tvoid\t\t(*signalcb)(int);\n\n\tstruct event\t  ev_sigint;\n\tstruct event\t  ev_sighup;\n\tstruct event\t  ev_sigchld;\n\tstruct event\t  ev_sigcont;\n\tstruct event\t  ev_sigterm;\n\tstruct event\t  ev_sigusr1;\n\tstruct event\t  ev_sigusr2;\n\tstruct event\t  ev_sigwinch;\n\n\tTAILQ_HEAD(, tmuxpeer) peers;\n};\n\nstruct tmuxpeer {\n\tstruct tmuxproc\t*parent;\n\n\tstruct imsgbuf\t ibuf;\n\tstruct event\t event;\n\tuid_t\t\t uid;\n\n\tint\t\t flags;\n#define PEER_BAD 0x1\n\n\tvoid\t\t(*dispatchcb)(struct imsg *, void *);\n\tvoid\t\t *arg;\n\n\tTAILQ_ENTRY(tmuxpeer) entry;\n};\n\nstatic int\tpeer_check_version(struct tmuxpeer *, struct imsg *);\nstatic void\tproc_update_event(struct tmuxpeer *);\n\nstatic void\nproc_event_cb(__unused int fd, short events, void *arg)\n{\n\tstruct tmuxpeer\t*peer = arg;\n\tssize_t\t\t n;\n\tstruct imsg\t imsg;\n\n\tif (!(peer->flags & PEER_BAD) && (events & EV_READ)) {\n\t\tif (imsgbuf_read(&peer->ibuf) != 1) {\n\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\treturn;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif ((n = imsg_get(&peer->ibuf, &imsg)) == -1) {\n\t\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tlog_debug(\"peer %p message %d\", peer, imsg.hdr.type);\n\n\t\t\tif (peer_check_version(peer, &imsg) != 0) {\n\t\t\t\timsg_free(&imsg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpeer->dispatchcb(&imsg, peer->arg);\n\t\t\timsg_free(&imsg);\n\t\t}\n\t}\n\n\tif (events & EV_WRITE) {\n\t\tif (imsgbuf_write(&peer->ibuf) == -1) {\n\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ((peer->flags & PEER_BAD) && imsgbuf_queuelen(&peer->ibuf) == 0) {\n\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\treturn;\n\t}\n\n\tproc_update_event(peer);\n}\n\nstatic void\nproc_signal_cb(int signo, __unused short events, void *arg)\n{\n\tstruct tmuxproc\t*tp = arg;\n\n\ttp->signalcb(signo);\n}\n\nstatic int\npeer_check_version(struct tmuxpeer *peer, struct imsg *imsg)\n{\n\tint\tversion;\n\n\tversion = imsg->hdr.peerid & 0xff;\n\tif (imsg->hdr.type != MSG_VERSION && version != PROTOCOL_VERSION) {\n\t\tlog_debug(\"peer %p bad version %d\", peer, version);\n\n\t\tproc_send(peer, MSG_VERSION, -1, NULL, 0);\n\t\tpeer->flags |= PEER_BAD;\n\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic void\nproc_update_event(struct tmuxpeer *peer)\n{\n\tshort\tevents;\n\n\tevent_del(&peer->event);\n\n\tevents = EV_READ;\n\tif (imsgbuf_queuelen(&peer->ibuf) > 0)\n\t\tevents |= EV_WRITE;\n\tevent_set(&peer->event, peer->ibuf.fd, events, proc_event_cb, peer);\n\n\tevent_add(&peer->event, NULL);\n}\n\nint\nproc_send(struct tmuxpeer *peer, enum msgtype type, int fd, const void *buf,\n    size_t len)\n{\n\tstruct imsgbuf\t*ibuf = &peer->ibuf;\n\tvoid\t\t*vp = (void *)buf;\n\tint\t\t retval;\n\n\tif (peer->flags & PEER_BAD)\n\t\treturn (-1);\n\tlog_debug(\"sending message %d to peer %p (%zu bytes)\", type, peer, len);\n\n\tretval = imsg_compose(ibuf, type, PROTOCOL_VERSION, -1, fd, vp, len);\n\tif (retval != 1)\n\t\treturn (-1);\n\tproc_update_event(peer);\n\treturn (0);\n}\n\nstruct tmuxproc *\nproc_start(const char *name)\n{\n\tstruct tmuxproc\t*tp;\n\tstruct utsname\t u;\n\n\tlog_open(name);\n\tsetproctitle(\"%s (%s)\", name, socket_path);\n\n\tif (uname(&u) < 0)\n\t\tmemset(&u, 0, sizeof u);\n\n\tlog_debug(\"%s started (%ld): version %s, socket %s, protocol %d\", name,\n\t    (long)getpid(), getversion(), socket_path, PROTOCOL_VERSION);\n\tlog_debug(\"on %s %s %s\", u.sysname, u.release, u.version);\n\tlog_debug(\"using libevent %s %s\", event_get_version(), event_get_method());\n#ifdef HAVE_UTF8PROC\n\tlog_debug(\"using utf8proc %s\", utf8proc_version());\n#endif\n#ifdef NCURSES_VERSION\n\tlog_debug(\"using ncurses %s %06u\", NCURSES_VERSION, NCURSES_VERSION_PATCH);\n#endif\n\n\ttp = xcalloc(1, sizeof *tp);\n\ttp->name = xstrdup(name);\n\tTAILQ_INIT(&tp->peers);\n\n\treturn (tp);\n}\n\nvoid\nproc_loop(struct tmuxproc *tp, int (*loopcb)(void))\n{\n\tlog_debug(\"%s loop enter\", tp->name);\n\tdo\n\t\tevent_loop(EVLOOP_ONCE);\n\twhile (!tp->exit && (loopcb == NULL || !loopcb ()));\n\tlog_debug(\"%s loop exit\", tp->name);\n}\n\nvoid\nproc_exit(struct tmuxproc *tp)\n{\n\tstruct tmuxpeer\t*peer;\n\n\tTAILQ_FOREACH(peer, &tp->peers, entry)\n\t    imsgbuf_flush(&peer->ibuf);\n\ttp->exit = 1;\n}\n\nvoid\nproc_set_signals(struct tmuxproc *tp, void (*signalcb)(int))\n{\n\tstruct sigaction\tsa;\n\n\ttp->signalcb = signalcb;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsa.sa_handler = SIG_IGN;\n\n\tsigaction(SIGPIPE, &sa, NULL);\n\tsigaction(SIGTSTP, &sa, NULL);\n\tsigaction(SIGTTIN, &sa, NULL);\n\tsigaction(SIGTTOU, &sa, NULL);\n\tsigaction(SIGQUIT, &sa, NULL);\n\n\tsignal_set(&tp->ev_sigint, SIGINT, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigint, NULL);\n\tsignal_set(&tp->ev_sighup, SIGHUP, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sighup, NULL);\n\tsignal_set(&tp->ev_sigchld, SIGCHLD, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigchld, NULL);\n\tsignal_set(&tp->ev_sigcont, SIGCONT, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigcont, NULL);\n\tsignal_set(&tp->ev_sigterm, SIGTERM, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigterm, NULL);\n\tsignal_set(&tp->ev_sigusr1, SIGUSR1, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigusr1, NULL);\n\tsignal_set(&tp->ev_sigusr2, SIGUSR2, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigusr2, NULL);\n\tsignal_set(&tp->ev_sigwinch, SIGWINCH, proc_signal_cb, tp);\n\tsignal_add(&tp->ev_sigwinch, NULL);\n}\n\nvoid\nproc_clear_signals(struct tmuxproc *tp, int defaults)\n{\n\tstruct sigaction\tsa;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsa.sa_handler = SIG_DFL;\n\n\tsigaction(SIGPIPE, &sa, NULL);\n\tsigaction(SIGTSTP, &sa, NULL);\n\n\tsignal_del(&tp->ev_sigint);\n\tsignal_del(&tp->ev_sighup);\n\tsignal_del(&tp->ev_sigchld);\n\tsignal_del(&tp->ev_sigcont);\n\tsignal_del(&tp->ev_sigterm);\n\tsignal_del(&tp->ev_sigusr1);\n\tsignal_del(&tp->ev_sigusr2);\n\tsignal_del(&tp->ev_sigwinch);\n\n\tif (defaults) {\n\t\tsigaction(SIGINT, &sa, NULL);\n\t\tsigaction(SIGQUIT, &sa, NULL);\n\t\tsigaction(SIGHUP, &sa, NULL);\n\t\tsigaction(SIGCHLD, &sa, NULL);\n\t\tsigaction(SIGCONT, &sa, NULL);\n\t\tsigaction(SIGTERM, &sa, NULL);\n\t\tsigaction(SIGUSR1, &sa, NULL);\n\t\tsigaction(SIGUSR2, &sa, NULL);\n\t\tsigaction(SIGWINCH, &sa, NULL);\n\t}\n}\n\nstruct tmuxpeer *\nproc_add_peer(struct tmuxproc *tp, int fd,\n    void (*dispatchcb)(struct imsg *, void *), void *arg)\n{\n\tstruct tmuxpeer\t*peer;\n\tgid_t\t\t gid;\n\n\tpeer = xcalloc(1, sizeof *peer);\n\tpeer->parent = tp;\n\n\tpeer->dispatchcb = dispatchcb;\n\tpeer->arg = arg;\n\n\tif (imsgbuf_init(&peer->ibuf, fd) == -1)\n\t\tfatal(\"imsgbuf_init\");\n\timsgbuf_allow_fdpass(&peer->ibuf);\n\tevent_set(&peer->event, fd, EV_READ, proc_event_cb, peer);\n\n\tif (getpeereid(fd, &peer->uid, &gid) != 0)\n\t\tpeer->uid = (uid_t)-1;\n\n\tlog_debug(\"add peer %p: %d (%p)\", peer, fd, arg);\n\tTAILQ_INSERT_TAIL(&tp->peers, peer, entry);\n\n\tproc_update_event(peer);\n\treturn (peer);\n}\n\nvoid\nproc_remove_peer(struct tmuxpeer *peer)\n{\n\tTAILQ_REMOVE(&peer->parent->peers, peer, entry);\n\tlog_debug(\"remove peer %p\", peer);\n\n\tevent_del(&peer->event);\n\timsgbuf_clear(&peer->ibuf);\n\n\tclose(peer->ibuf.fd);\n\tfree(peer);\n}\n\nvoid\nproc_kill_peer(struct tmuxpeer *peer)\n{\n\tpeer->flags |= PEER_BAD;\n}\n\nvoid\nproc_flush_peer(struct tmuxpeer *peer)\n{\n\timsgbuf_flush(&peer->ibuf);\n}\n\nvoid\nproc_toggle_log(struct tmuxproc *tp)\n{\n\tlog_toggle(tp->name);\n}\n\npid_t\nproc_fork_and_daemon(int *fd)\n{\n\tpid_t\tpid;\n\tint\tpair[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pair) != 0)\n\t\tfatal(\"socketpair failed\");\n\tswitch (pid = fork()) {\n\tcase -1:\n\t\tfatal(\"fork failed\");\n\tcase 0:\n\t\tclose(pair[0]);\n\t\t*fd = pair[1];\n\t\tif (daemon(1, 0) != 0)\n\t\t\tfatal(\"daemon failed\");\n\t\treturn (0);\n\tdefault:\n\t\tclose(pair[1]);\n\t\t*fd = pair[0];\n\t\treturn (pid);\n\t}\n}\n\nuid_t\nproc_get_peer_uid(struct tmuxpeer *peer)\n{\n\treturn (peer->uid);\n}\n"
        },
        {
          "name": "regress",
          "type": "tree",
          "content": null
        },
        {
          "name": "regsub.c",
          "type": "blob",
          "size": 2.8779296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <regex.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic void\nregsub_copy(char **buf, ssize_t *len, const char *text, size_t start, size_t end)\n{\n\tsize_t\tadd = end - start;\n\n\t*buf = xrealloc(*buf, (*len) + add + 1);\n\tmemcpy((*buf) + *len, text + start, add);\n\t(*len) += add;\n}\n\nstatic void\nregsub_expand(char **buf, ssize_t *len, const char *with, const char *text,\n    regmatch_t *m, u_int n)\n{\n\tconst char\t*cp;\n\tu_int\t\t i;\n\n\tfor (cp = with; *cp != '\\0'; cp++) {\n\t\tif (*cp == '\\\\') {\n\t\t\tcp++;\n\t\t\tif (*cp >= '0' && *cp <= '9') {\n\t\t\t\ti = *cp - '0';\n\t\t\t\tif (i < n && m[i].rm_so != m[i].rm_eo) {\n\t\t\t\t\tregsub_copy(buf, len, text, m[i].rm_so,\n\t\t\t\t\t    m[i].rm_eo);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*buf = xrealloc(*buf, (*len) + 2);\n\t\t(*buf)[(*len)++] = *cp;\n\t}\n}\n\nchar *\nregsub(const char *pattern, const char *with, const char *text, int flags)\n{\n\tregex_t\t\t r;\n\tregmatch_t\t m[10];\n\tssize_t\t\t start, end, last, len = 0;\n\tint\t\t empty = 0;\n\tchar\t\t*buf = NULL;\n\n\tif (*text == '\\0')\n\t\treturn (xstrdup(\"\"));\n\tif (regcomp(&r, pattern, flags) != 0)\n\t\treturn (NULL);\n\n\tstart = 0;\n\tlast = 0;\n\tend = strlen(text);\n\n\twhile (start <= end) {\n\t\tif (regexec(&r, text + start, nitems(m), m, 0) != 0) {\n\t\t\tregsub_copy(&buf, &len, text, start, end);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Append any text not part of this match (from the end of the\n\t\t * last match).\n\t\t */\n\t\tregsub_copy(&buf, &len, text, last, m[0].rm_so + start);\n\n\t\t/*\n\t\t * If the last match was empty and this one isn't (it is either\n\t\t * later or has matched text), expand this match. If it is\n\t\t * empty, move on one character and try again from there.\n\t\t */\n\t\tif (empty ||\n\t\t    start + m[0].rm_so != last ||\n\t\t    m[0].rm_so != m[0].rm_eo) {\n\t\t\tregsub_expand(&buf, &len, with, text + start, m,\n\t\t\t    nitems(m));\n\n\t\t\tlast = start + m[0].rm_eo;\n\t\t\tstart += m[0].rm_eo;\n\t\t\tempty = 0;\n\t\t} else {\n\t\t\tlast = start + m[0].rm_eo;\n\t\t\tstart += m[0].rm_eo + 1;\n\t\t\tempty = 1;\n\t\t}\n\n\t\t/* Stop now if anchored to start. */\n\t\tif (*pattern == '^') {\n\t\t\tregsub_copy(&buf, &len, text, start, end);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[len] = '\\0';\n\n\tregfree(&r);\n\treturn (buf);\n}\n"
        },
        {
          "name": "resize.c",
          "type": "blob",
          "size": 11.7822265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\nvoid\nresize_window(struct window *w, u_int sx, u_int sy, int xpixel, int ypixel)\n{\n\tint\tzoomed;\n\n\t/* Check size limits. */\n\tif (sx < WINDOW_MINIMUM)\n\t\tsx = WINDOW_MINIMUM;\n\tif (sx > WINDOW_MAXIMUM)\n\t\tsx = WINDOW_MAXIMUM;\n\tif (sy < WINDOW_MINIMUM)\n\t\tsy = WINDOW_MINIMUM;\n\tif (sy > WINDOW_MAXIMUM)\n\t\tsy = WINDOW_MAXIMUM;\n\n\t/* If the window is zoomed, unzoom. */\n\tzoomed = w->flags & WINDOW_ZOOMED;\n\tif (zoomed)\n\t\twindow_unzoom(w, 1);\n\n\t/* Resize the layout first. */\n\tlayout_resize(w, sx, sy);\n\n\t/* Resize the window, it can be no smaller than the layout. */\n\tif (sx < w->layout_root->sx)\n\t\tsx = w->layout_root->sx;\n\tif (sy < w->layout_root->sy)\n\t\tsy = w->layout_root->sy;\n\twindow_resize(w, sx, sy, xpixel, ypixel);\n\tlog_debug(\"%s: @%u resized to %ux%u; layout %ux%u\", __func__, w->id,\n\t    sx, sy, w->layout_root->sx, w->layout_root->sy);\n\n\t/* Restore the window zoom state. */\n\tif (zoomed)\n\t\twindow_zoom(w->active);\n\n\ttty_update_window_offset(w);\n\tserver_redraw_window(w);\n\tnotify_window(\"window-layout-changed\", w);\n\tnotify_window(\"window-resized\", w);\n\tw->flags &= ~WINDOW_RESIZE;\n}\n\nstatic int\nignore_client_size(struct client *c)\n{\n\tstruct client\t*loop;\n\n\tif (c->session == NULL)\n\t\treturn (1);\n\tif (c->flags & CLIENT_NOSIZEFLAGS)\n\t\treturn (1);\n\tif (c->flags & CLIENT_IGNORESIZE) {\n\t\t/*\n\t\t * Ignore flagged clients if there are any attached clients\n\t\t * that aren't flagged.\n\t\t */\n\t\tTAILQ_FOREACH (loop, &clients, entry) {\n\t\t\tif (loop->session == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (loop->flags & CLIENT_NOSIZEFLAGS)\n\t\t\t\tcontinue;\n\t\t\tif (~loop->flags & CLIENT_IGNORESIZE)\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\tif ((c->flags & CLIENT_CONTROL) &&\n\t    (~c->flags & CLIENT_SIZECHANGED) &&\n\t    (~c->flags & CLIENT_WINDOWSIZECHANGED))\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic u_int\nclients_with_window(struct window *w)\n{\n\tstruct client\t*loop;\n\tu_int\t\t n = 0;\n\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (ignore_client_size(loop) || !session_has(loop->session, w))\n\t\t\tcontinue;\n\t\tif (++n > 1)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}\n\nstatic int\nclients_calculate_size(int type, int current, struct client *c,\n    struct session *s, struct window *w, int (*skip_client)(struct client *,\n    int, int, struct session *, struct window *), u_int *sx, u_int *sy,\n    u_int *xpixel, u_int *ypixel)\n{\n\tstruct client\t\t*loop;\n\tstruct client_window\t*cw;\n\tu_int\t\t\t cx, cy, n = 0;\n\n\t/*\n\t * Start comparing with 0 for largest and UINT_MAX for smallest or\n\t * latest.\n\t */\n\tif (type == WINDOW_SIZE_LARGEST) {\n\t\t*sx = 0;\n\t\t*sy = 0;\n\t} else if (type == WINDOW_SIZE_MANUAL) {\n\t\t*sx = w->manual_sx;\n\t\t*sy = w->manual_sy;\n\t\tlog_debug(\"%s: manual size %ux%u\", __func__, *sx, *sy);\n\t} else {\n\t\t*sx = UINT_MAX;\n\t\t*sy = UINT_MAX;\n\t}\n\t*xpixel = *ypixel = 0;\n\n\t/*\n\t * For latest, count the number of clients with this window. We only\n\t * care if there is more than one.\n\t */\n\tif (type == WINDOW_SIZE_LATEST && w != NULL)\n\t\tn = clients_with_window(w);\n\n\t/* Skip setting the size if manual */\n\tif (type == WINDOW_SIZE_MANUAL)\n\t\tgoto skip;\n\n\t/* Loop over the clients and work out the size. */\n\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\tif (loop != c && ignore_client_size(loop)) {\n\t\t\tlog_debug(\"%s: ignoring %s (1)\", __func__, loop->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (loop != c && skip_client(loop, type, current, s, w)) {\n\t\t\tlog_debug(\"%s: skipping %s (1)\", __func__, loop->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there are multiple clients attached, only accept the\n\t\t * latest client; otherwise let the only client be chosen as\n\t\t * for smallest.\n\t\t */\n\t\tif (type == WINDOW_SIZE_LATEST && n > 1 && loop != w->latest) {\n\t\t\tlog_debug(\"%s: %s is not latest\", __func__, loop->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If the client has a per-window size, use this instead if it is\n\t\t * smaller.\n\t\t */\n\t\tif (w != NULL)\n\t\t\tcw = server_client_get_client_window(loop, w->id);\n\t\telse\n\t\t\tcw = NULL;\n\n\t\t/* Work out this client's size. */\n\t\tif (cw != NULL && cw->sx != 0 && cw->sy != 0) {\n\t\t\tcx = cw->sx;\n\t\t\tcy = cw->sy;\n\t\t} else {\n\t\t\tcx = loop->tty.sx;\n\t\t\tcy = loop->tty.sy - status_line_size(loop);\n\t\t}\n\n\t\t/*\n\t\t * If it is larger or smaller than the best so far, update the\n\t\t * new size.\n\t\t */\n\t\tif (type == WINDOW_SIZE_LARGEST) {\n\t\t\tif (cx > *sx)\n\t\t\t\t*sx = cx;\n\t\t\tif (cy > *sy)\n\t\t\t\t*sy = cy;\n\t\t} else {\n\t\t\tif (cx < *sx)\n\t\t\t\t*sx = cx;\n\t\t\tif (cy < *sy)\n\t\t\t\t*sy = cy;\n\t\t}\n\t\tif (loop->tty.xpixel > *xpixel && loop->tty.ypixel > *ypixel) {\n\t\t\t*xpixel = loop->tty.xpixel;\n\t\t\t*ypixel = loop->tty.ypixel;\n\t\t}\n\t\tlog_debug(\"%s: after %s (%ux%u), size is %ux%u\", __func__,\n\t\t    loop->name, cx, cy, *sx, *sy);\n\t}\n\tif (*sx != UINT_MAX && *sy != UINT_MAX)\n\t\tlog_debug(\"%s: calculated size %ux%u\", __func__, *sx, *sy);\n\telse\n\t\tlog_debug(\"%s: no calculated size\", __func__);\n\nskip:\n\t/*\n\t * Do not allow any size to be larger than the per-client window size\n\t * if one exists.\n\t */\n\tif (w != NULL) {\n\t\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\t\tif (loop != c && ignore_client_size(loop))\n\t\t\t\tcontinue;\n\t\t\tif (loop != c && skip_client(loop, type, current, s, w))\n\t\t\t\tcontinue;\n\n\t\t\t/* Look up per-window size if any. */\n\t\t\tif (~loop->flags & CLIENT_WINDOWSIZECHANGED)\n\t\t\t\tcontinue;\n\t\t\tcw = server_client_get_client_window(loop, w->id);\n\t\t\tif (cw == NULL)\n\t\t\t\tcontinue;\n\n\t\t\t/* Clamp the size. */\n\t\t\tlog_debug(\"%s: %s size for @%u is %ux%u\", __func__,\n\t\t\t    loop->name, w->id, cw->sx, cw->sy);\n\t\t\tif (cw->sx != 0 && *sx > cw->sx)\n\t\t\t\t*sx = cw->sx;\n\t\t\tif (cw->sy != 0 && *sy > cw->sy)\n\t\t\t\t*sy = cw->sy;\n\t\t}\n\t}\n\tif (*sx != UINT_MAX && *sy != UINT_MAX)\n\t\tlog_debug(\"%s: calculated size %ux%u\", __func__, *sx, *sy);\n\telse\n\t\tlog_debug(\"%s: no calculated size\", __func__);\n\n\t/* Return whether a suitable size was found. */\n\tif (type == WINDOW_SIZE_MANUAL) {\n\t\tlog_debug(\"%s: type is manual\", __func__);\n\t\treturn (1);\n\t}\n\tif (type == WINDOW_SIZE_LARGEST) {\n\t\tlog_debug(\"%s: type is largest\", __func__);\n\t\treturn (*sx != 0 && *sy != 0);\n\t}\n\tif (type == WINDOW_SIZE_LATEST)\n\t\tlog_debug(\"%s: type is latest\", __func__);\n\telse\n\t\tlog_debug(\"%s: type is smallest\", __func__);\n\treturn (*sx != UINT_MAX && *sy != UINT_MAX);\n}\n\nstatic int\ndefault_window_size_skip_client(struct client *loop, __unused int type,\n    __unused int current, struct session *s, struct window *w)\n{\n\tif (w != NULL && !session_has(loop->session, w))\n\t\treturn (1);\n\tif (w == NULL && loop->session != s)\n\t\treturn (1);\n\treturn (0);\n}\n\nvoid\ndefault_window_size(struct client *c, struct session *s, struct window *w,\n\tu_int *sx, u_int *sy, u_int *xpixel, u_int *ypixel, int type)\n{\n\tconst char\t*value;\n\n\t/* Get type if not provided. */\n\tif (type == -1)\n\t\ttype = options_get_number(global_w_options, \"window-size\");\n\n\t/*\n\t * Latest clients can use the given client if suitable. If there is no\n\t * client and no window, use the default size as for manual type.\n\t */\n\tif (type == WINDOW_SIZE_LATEST && c != NULL && !ignore_client_size(c)) {\n\t\t*sx = c->tty.sx;\n\t\t*sy = c->tty.sy - status_line_size(c);\n\t\t*xpixel = c->tty.xpixel;\n\t\t*ypixel = c->tty.ypixel;\n\t\tlog_debug(\"%s: using %ux%u from %s\", __func__, *sx, *sy,\n\t\t    c->name);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Ignore the given client if it is a control client - the creating\n\t * client should only affect the size if it is not a control client.\n\t */\n\tif (c != NULL && (c->flags & CLIENT_CONTROL))\n\t\tc = NULL;\n\n\t/*\n\t * Look for a client to base the size on. If none exists (or the type\n\t * is manual), use the default-size option.\n\t */\n\tif (!clients_calculate_size(type, 0, c, s, w,\n\t    default_window_size_skip_client, sx, sy, xpixel, ypixel)) {\n\t\tvalue = options_get_string(s->options, \"default-size\");\n\t\tif (sscanf(value, \"%ux%u\", sx, sy) != 2) {\n\t\t\t*sx = 80;\n\t\t\t*sy = 24;\n\t\t}\n\t\tlog_debug(\"%s: using %ux%u from default-size\", __func__, *sx,\n\t\t    *sy);\n\t}\n\ndone:\n\t/* Make sure the limits are enforced. */\n\tif (*sx < WINDOW_MINIMUM)\n\t\t*sx = WINDOW_MINIMUM;\n\tif (*sx > WINDOW_MAXIMUM)\n\t\t*sx = WINDOW_MAXIMUM;\n\tif (*sy < WINDOW_MINIMUM)\n\t\t*sy = WINDOW_MINIMUM;\n\tif (*sy > WINDOW_MAXIMUM)\n\t\t*sy = WINDOW_MAXIMUM;\n\tlog_debug(\"%s: resulting size is %ux%u\", __func__, *sx, *sy);\n}\n\nstatic int\nrecalculate_size_skip_client(struct client *loop, __unused int type,\n    int current, __unused struct session *s, struct window *w)\n{\n\t/*\n\t * If the current flag is set, then skip any client where this window\n\t * is not the current window - this is used for aggressive-resize.\n\t * Otherwise skip any session that doesn't contain the window.\n\t */\n\tif (loop->session->curw == NULL)\n\t\treturn (1);\n\tif (current)\n\t\treturn (loop->session->curw->window != w);\n\treturn (session_has(loop->session, w) == 0);\n}\n\nvoid\nrecalculate_size(struct window *w, int now)\n{\n\tu_int\tsx, sy, xpixel = 0, ypixel = 0;\n\tint\ttype, current, changed;\n\n\t/*\n\t * Do not attempt to resize windows which have no pane, they must be on\n\t * the way to destruction.\n\t */\n\tif (w->active == NULL)\n\t\treturn;\n\tlog_debug(\"%s: @%u is %ux%u\", __func__, w->id, w->sx, w->sy);\n\n\t/*\n\t * Type is manual, smallest, largest, latest. Current is the\n\t * aggressive-resize option (do not resize based on clients where the\n\t * window is not the current window).\n\t */\n\ttype = options_get_number(w->options, \"window-size\");\n\tcurrent = options_get_number(w->options, \"aggressive-resize\");\n\n\t/* Look for a suitable client and get the new size. */\n\tchanged = clients_calculate_size(type, current, NULL, NULL, w,\n\t    recalculate_size_skip_client, &sx, &sy, &xpixel, &ypixel);\n\n\t/*\n\t * Make sure the size has actually changed. If the window has already\n\t * got a resize scheduled, then use the new size; otherwise the old.\n\t */\n\tif (w->flags & WINDOW_RESIZE) {\n\t\tif (!now && changed && w->new_sx == sx && w->new_sy == sy)\n\t\t\tchanged = 0;\n\t} else {\n\t\tif (!now && changed && w->sx == sx && w->sy == sy)\n\t\t\tchanged = 0;\n\t}\n\n\t/*\n\t * If the size hasn't changed, update the window offset but not the\n\t * size.\n\t */\n\tif (!changed) {\n\t\tlog_debug(\"%s: @%u no size change\", __func__, w->id);\n\t\ttty_update_window_offset(w);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the now flag is set or if the window is sized manually, change\n\t * the size immediately. Otherwise set the flag and it will be done\n\t * later.\n\t */\n\tlog_debug(\"%s: @%u new size %ux%u\", __func__, w->id, sx, sy);\n\tif (now || type == WINDOW_SIZE_MANUAL)\n\t\tresize_window(w, sx, sy, xpixel, ypixel);\n\telse {\n\t\tw->new_sx = sx;\n\t\tw->new_sy = sy;\n\t\tw->new_xpixel = xpixel;\n\t\tw->new_ypixel = ypixel;\n\n\t\tw->flags |= WINDOW_RESIZE;\n\t\ttty_update_window_offset(w);\n\t}\n}\n\nvoid\nrecalculate_sizes(void)\n{\n\trecalculate_sizes_now(0);\n}\n\nvoid\nrecalculate_sizes_now(int now)\n{\n\tstruct session\t*s;\n\tstruct client\t*c;\n\tstruct window\t*w;\n\n\t/*\n\t * Clear attached count and update saved status line information for\n\t * each session.\n\t */\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\ts->attached = 0;\n\t\tstatus_update_cache(s);\n\t}\n\n\t/*\n\t * Increment attached count and check the status line size for each\n\t * client.\n\t */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\ts = c->session;\n\t\tif (s != NULL && !(c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\t\ts->attached++;\n\t\tif (ignore_client_size(c))\n\t\t\tcontinue;\n\t\tif (c->tty.sy <= s->statuslines || (c->flags & CLIENT_CONTROL))\n\t\t\tc->flags |= CLIENT_STATUSOFF;\n\t\telse\n\t\t\tc->flags &= ~CLIENT_STATUSOFF;\n\t}\n\n\t/* Walk each window and adjust the size. */\n\tRB_FOREACH(w, windows, &windows)\n\t\trecalculate_size(w, now);\n}\n"
        },
        {
          "name": "screen-redraw.c",
          "type": "blob",
          "size": 28.3359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic void\tscreen_redraw_draw_borders(struct screen_redraw_ctx *);\nstatic void\tscreen_redraw_draw_panes(struct screen_redraw_ctx *);\nstatic void\tscreen_redraw_draw_status(struct screen_redraw_ctx *);\nstatic void\tscreen_redraw_draw_pane(struct screen_redraw_ctx *,\n\t\t    struct window_pane *);\nstatic void\tscreen_redraw_set_context(struct client *,\n\t\t    struct screen_redraw_ctx *);\nstatic void\tscreen_redraw_draw_pane_scrollbars(struct screen_redraw_ctx *);\nstatic void\tscreen_redraw_draw_scrollbar(struct screen_redraw_ctx *,\n\t\t    struct window_pane *, int, int, int, u_int, u_int, u_int);\nstatic void\tscreen_redraw_draw_pane_scrollbar(struct screen_redraw_ctx *,\n\t\t    struct window_pane *);\n\n#define START_ISOLATE \"\\342\\201\\246\"\n#define END_ISOLATE   \"\\342\\201\\251\"\n\n/* Border in relation to a pane. */\nenum screen_redraw_border_type {\n\tSCREEN_REDRAW_OUTSIDE,\n\tSCREEN_REDRAW_INSIDE,\n\tSCREEN_REDRAW_BORDER_LEFT,\n\tSCREEN_REDRAW_BORDER_RIGHT,\n\tSCREEN_REDRAW_BORDER_TOP,\n\tSCREEN_REDRAW_BORDER_BOTTOM\n};\n#define BORDER_MARKERS \"  +,.-\"\n\n/* Get cell border character. */\nstatic void\nscreen_redraw_border_set(struct window *w, struct window_pane *wp,\n    enum pane_lines pane_lines, int cell_type, struct grid_cell *gc)\n{\n\tu_int\tidx;\n\n\tif (cell_type == CELL_OUTSIDE && w->fill_character != NULL) {\n\t\tutf8_copy(&gc->data, &w->fill_character[0]);\n\t\treturn;\n\t}\n\n\tswitch (pane_lines) {\n\tcase PANE_LINES_NUMBER:\n\t\tif (cell_type == CELL_OUTSIDE) {\n\t\t\tgc->attr |= GRID_ATTR_CHARSET;\n\t\t\tutf8_set(&gc->data, CELL_BORDERS[CELL_OUTSIDE]);\n\t\t\tbreak;\n\t\t}\n\t\tgc->attr &= ~GRID_ATTR_CHARSET;\n\t\tif (wp != NULL && window_pane_index(wp, &idx) == 0)\n\t\t\tutf8_set(&gc->data, '0' + (idx % 10));\n\t\telse\n\t\t\tutf8_set(&gc->data, '*');\n\t\tbreak;\n\tcase PANE_LINES_DOUBLE:\n\t\tgc->attr &= ~GRID_ATTR_CHARSET;\n\t\tutf8_copy(&gc->data, tty_acs_double_borders(cell_type));\n\t\tbreak;\n\tcase PANE_LINES_HEAVY:\n\t\tgc->attr &= ~GRID_ATTR_CHARSET;\n\t\tutf8_copy(&gc->data, tty_acs_heavy_borders(cell_type));\n\t\tbreak;\n\tcase PANE_LINES_SIMPLE:\n\t\tgc->attr &= ~GRID_ATTR_CHARSET;\n\t\tutf8_set(&gc->data, SIMPLE_BORDERS[cell_type]);\n\t\tbreak;\n\tdefault:\n\t\tgc->attr |= GRID_ATTR_CHARSET;\n\t\tutf8_set(&gc->data, CELL_BORDERS[cell_type]);\n\t\tbreak;\n\t}\n}\n\n/* Return if window has only two panes. */\nstatic int\nscreen_redraw_two_panes(struct window *w, int direction)\n{\n\tstruct window_pane\t*wp;\n\n\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\tif (wp == NULL)\n\t\treturn (0); /* one pane */\n\tif (TAILQ_NEXT(wp, entry) != NULL)\n\t\treturn (0); /* more than two panes */\n\tif (direction == 0 && wp->xoff == 0)\n\t\treturn (0);\n\tif (direction == 1 && wp->yoff == 0)\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Check if cell is on the border of a pane. */\nstatic enum screen_redraw_border_type\nscreen_redraw_pane_border(struct screen_redraw_ctx *ctx, struct window_pane *wp,\n    u_int px, u_int py)\n{\n\tstruct options\t*oo = wp->window->options;\n\tu_int\t\t ex = wp->xoff + wp->sx, ey = wp->yoff + wp->sy;\n\tint\t\t hsplit = 0, vsplit = 0, pane_status = ctx->pane_status;\n\tint\t\t pane_scrollbars = ctx->pane_scrollbars, sb_w = 0;\n\tint\t\t sb_pos = ctx->pane_scrollbars_pos;\n\n\t/* Inside pane. */\n\tif (px >= wp->xoff && px < ex && py >= wp->yoff && py < ey)\n\t\treturn (SCREEN_REDRAW_INSIDE);\n\n\t/* Get pane indicator. */\n\tswitch (options_get_number(oo, \"pane-border-indicators\")) {\n\tcase PANE_BORDER_COLOUR:\n\tcase PANE_BORDER_BOTH:\n\t\thsplit = screen_redraw_two_panes(wp->window, 0);\n\t\tvsplit = screen_redraw_two_panes(wp->window, 1);\n\t\tbreak;\n\t}\n\n\t/* Are scrollbars enabled? */\n\tif (window_pane_show_scrollbar(wp, pane_scrollbars))\n\t\tsb_w = wp->scrollbar_style.width + wp->scrollbar_style.pad;\n\n\t/*\n\t * Left/right borders. The wp->sy / 2 test is to colour only half the\n\t * active window's border when there are two panes.\n\t */\n\tif ((wp->yoff == 0 || py >= wp->yoff - 1) && py <= ey) {\n\t\tif (sb_pos == PANE_SCROLLBARS_LEFT) {\n\t\t\tif (wp->xoff - sb_w == 0 && px == wp->sx + sb_w)\n\t\t\t\tif (!hsplit || (hsplit && py <= wp->sy / 2))\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_RIGHT);\n\t\t\tif (wp->xoff - sb_w != 0 && px == wp->xoff - sb_w - 1)\n\t\t\t\tif (!hsplit || (hsplit && py > wp->sy / 2))\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_LEFT);\n\t\t} else { /* sb_pos == PANE_SCROLLBARS_RIGHT */\n\t\t\tif (wp->xoff == 0 && px == wp->sx + sb_w)\n\t\t\t\tif (!hsplit || (hsplit && py <= wp->sy / 2))\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_RIGHT);\n\t\t\tif (wp->xoff != 0 && px == wp->xoff - 1)\n\t\t\t\tif (!hsplit || (hsplit && py > wp->sy / 2))\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_LEFT);\n\t\t}\n\t}\n\n\t/* Top/bottom borders. */\n\tif (vsplit && pane_status == PANE_STATUS_OFF && sb_w == 0) {\n\t\tif (wp->yoff == 0 && py == wp->sy && px <= wp->sx / 2)\n\t\t\treturn (SCREEN_REDRAW_BORDER_BOTTOM);\n\t\tif (wp->yoff != 0 && py == wp->yoff - 1 && px > wp->sx / 2)\n\t\t\treturn (SCREEN_REDRAW_BORDER_TOP);\n\t} else {\n\t\tif (sb_pos == PANE_SCROLLBARS_LEFT) {\n\t\t\tif ((wp->xoff - sb_w == 0 || px >= wp->xoff - sb_w) &&\n\t\t\t    (px <= ex || (sb_w != 0 && px < ex + sb_w))) {\n\t\t\t\tif (wp->yoff != 0 && py == wp->yoff - 1)\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_TOP);\n\t\t\t\tif (py == ey)\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_BOTTOM);\n\t\t\t}\n\t\t} else { /* sb_pos == PANE_SCROLLBARS_RIGHT */\n\t\t\tif ((wp->xoff == 0 || px >= wp->xoff) &&\n\t\t\t    (px <= ex || (sb_w != 0 && px < ex + sb_w))) {\n\t\t\t\tif (wp->yoff != 0 && py == wp->yoff - 1)\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_TOP);\n\t\t\t\tif (py == ey)\n\t\t\t\t\treturn (SCREEN_REDRAW_BORDER_BOTTOM);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Outside pane. */\n\treturn (SCREEN_REDRAW_OUTSIDE);\n}\n\n/* Check if a cell is on a border. */\nstatic int\nscreen_redraw_cell_border(struct screen_redraw_ctx *ctx, u_int px, u_int py)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t sy = w->sy;\n\n\tif (ctx->pane_status == PANE_STATUS_BOTTOM)\n\t\tsy--;\n\n\t/* Outside the window? */\n\tif (px > w->sx || py > sy)\n\t\treturn (0);\n\n\t/* On the window border? */\n\tif (px == w->sx || py == sy)\n\t\treturn (1);\n\n\t/* Check all the panes. */\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\tswitch (screen_redraw_pane_border(ctx, wp, px, py)) {\n\t\tcase SCREEN_REDRAW_INSIDE:\n\t\t\treturn (0);\n\t\tcase SCREEN_REDRAW_OUTSIDE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/* Work out type of border cell from surrounding cells. */\nstatic int\nscreen_redraw_type_of_cell(struct screen_redraw_ctx *ctx, u_int px, u_int py)\n{\n\tstruct client\t*c = ctx->c;\n\tint\t\t pane_status = ctx->pane_status;\n\tstruct window\t*w = c->session->curw->window;\n\tu_int\t\t sx = w->sx, sy = w->sy;\n\tint\t\t borders = 0;\n\n\tif (pane_status == PANE_STATUS_BOTTOM)\n\t\tsy--;\n\n\t/* Is this outside the window? */\n\tif (px > sx || py > sy)\n\t\treturn (CELL_OUTSIDE);\n\n\t/*\n\t * Construct a bitmask of whether the cells to the left (bit 8), right,\n\t * top, and bottom (bit 1) of this cell are borders.\n\t *\n\t * bits 8 4 2 1:     2\n\t *\t\t   8 + 4\n\t *\t\t     1\n\t */\n\tif (px == 0 || screen_redraw_cell_border(ctx, px - 1, py))\n\t\tborders |= 8;\n\tif (px <= sx && screen_redraw_cell_border(ctx, px + 1, py))\n\t\tborders |= 4;\n\tif (pane_status == PANE_STATUS_TOP) {\n\t\tif (py != 0 &&\n\t\t    screen_redraw_cell_border(ctx, px, py - 1))\n\t\t\tborders |= 2;\n\t\tif (screen_redraw_cell_border(ctx, px, py + 1))\n\t\t\tborders |= 1;\n\t} else if (pane_status == PANE_STATUS_BOTTOM) {\n\t\tif (py == 0 ||\n\t\t    screen_redraw_cell_border(ctx, px, py - 1))\n\t\t\tborders |= 2;\n\t\tif (py != sy &&\n\t\t    screen_redraw_cell_border(ctx, px, py + 1))\n\t\t\tborders |= 1;\n\t} else {\n\t\tif (py == 0 ||\n\t\t    screen_redraw_cell_border(ctx, px, py - 1))\n\t\t\tborders |= 2;\n\t\tif (screen_redraw_cell_border(ctx, px, py + 1))\n\t\t\tborders |= 1;\n\t}\n\n\t/*\n\t * Figure out what kind of border this cell is. Only one bit set\n\t * doesn't make sense (can't have a border cell with no others\n\t * connected).\n\t */\n\tswitch (borders) {\n\tcase 15:\t/* 1111, left right top bottom */\n\t\treturn (CELL_JOIN);\n\tcase 14:\t/* 1110, left right top */\n\t\treturn (CELL_BOTTOMJOIN);\n\tcase 13:\t/* 1101, left right bottom */\n\t\treturn (CELL_TOPJOIN);\n\tcase 12:\t/* 1100, left right */\n\t\treturn (CELL_LEFTRIGHT);\n\tcase 11:\t/* 1011, left top bottom */\n\t\treturn (CELL_RIGHTJOIN);\n\tcase 10:\t/* 1010, left top */\n\t\treturn (CELL_BOTTOMRIGHT);\n\tcase 9:\t\t/* 1001, left bottom */\n\t\treturn (CELL_TOPRIGHT);\n\tcase 7:\t\t/* 0111, right top bottom */\n\t\treturn (CELL_LEFTJOIN);\n\tcase 6:\t\t/* 0110, right top */\n\t\treturn (CELL_BOTTOMLEFT);\n\tcase 5:\t\t/* 0101, right bottom */\n\t\treturn (CELL_TOPLEFT);\n\tcase 3:\t\t/* 0011, top bottom */\n\t\treturn (CELL_TOPBOTTOM);\n\t}\n\treturn (CELL_OUTSIDE);\n}\n\n/* Check if cell inside a pane. */\nstatic int\nscreen_redraw_check_cell(struct screen_redraw_ctx *ctx, u_int px, u_int py,\n    struct window_pane **wpp)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp, *active;\n\tint\t\t\t pane_status = ctx->pane_status;\n\tu_int\t\t\t sx = w->sx, sy = w->sy;\n\tint\t\t\t border, pane_scrollbars = ctx->pane_scrollbars;\n\tu_int\t\t\t right, line;\n\tint\t\t\t sb_pos = ctx->pane_scrollbars_pos;\n\tint\t\t\t sb_w;\n\n\t*wpp = NULL;\n\n\tif (px > sx || py > sy)\n\t\treturn (CELL_OUTSIDE);\n\tif (px == sx || py == sy) /* window border */\n\t\treturn (screen_redraw_type_of_cell(ctx, px, py));\n\n\tif (pane_status != PANE_STATUS_OFF) {\n\t\tactive = wp = server_client_get_pane(c);\n\t\tdo {\n\t\t\tif (!window_pane_visible(wp))\n\t\t\t\tgoto next1;\n\n\t\t\tif (pane_status == PANE_STATUS_TOP)\n\t\t\t\tline = wp->yoff - 1;\n\t\t\telse\n\t\t\t\tline = wp->yoff + sy;\n\t\t\tright = wp->xoff + 2 + wp->status_size - 1;\n\n\t\t\tif (py == line && px >= wp->xoff + 2 && px <= right)\n\t\t\t\treturn (CELL_INSIDE);\n\n\t\tnext1:\n\t\t\twp = TAILQ_NEXT(wp, entry);\n\t\t\tif (wp == NULL)\n\t\t\t\twp = TAILQ_FIRST(&w->panes);\n\t\t} while (wp != active);\n\t}\n\n\tactive = wp = server_client_get_pane(c);\n\tdo {\n\t\tif (!window_pane_visible(wp))\n\t\t\tgoto next2;\n\t\t*wpp = wp;\n\n\t\t/* Check if CELL_SCROLLBAR */\n\t\tif (window_pane_show_scrollbar(wp, pane_scrollbars)) {\n\n\t\t\tif (pane_status == PANE_STATUS_TOP)\n\t\t\t\tline = wp->yoff - 1;\n\t\t\telse\n\t\t\t\tline = wp->yoff + wp->sy;\n\n\t\t\t/*\n\t\t\t * Check if py could lie within a scrollbar. If the\n\t\t\t * pane is at the top then py == 0 to sy; if the pane\n\t\t\t * is not at the top, then yoff to yoff + sy.\n\t\t\t */\n\t\t\tsb_w = wp->scrollbar_style.width +\n\t\t\t    wp->scrollbar_style.pad;\n\t\t\tif ((pane_status && py != line) ||\n\t\t\t    (wp->yoff == 0 && py < wp->sy) ||\n\t\t\t     (py >= wp->yoff && py < wp->yoff + wp->sy)) {\n\t\t\t\t/* Check if px lies within a scrollbar. */\n\t\t\t\tif ((sb_pos == PANE_SCROLLBARS_RIGHT &&\n\t\t\t\t     (px >= wp->xoff + wp->sx &&\n\t\t\t\t      px < wp->xoff + wp->sx + sb_w)) ||\n\t\t\t\t    (sb_pos == PANE_SCROLLBARS_LEFT &&\n\t\t\t\t     (px >= wp->xoff - sb_w &&\n\t\t\t\t      px < wp->xoff)))\n\t\t\t\t\treturn (CELL_SCROLLBAR);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If definitely inside, return. If not on border, skip.\n\t\t * Otherwise work out the cell.\n\t\t */\n\t\tborder = screen_redraw_pane_border(ctx, wp, px, py);\n\t\tif (border == SCREEN_REDRAW_INSIDE)\n\t\t\treturn (CELL_INSIDE);\n\t\tif (border == SCREEN_REDRAW_OUTSIDE)\n\t\t\tgoto next2;\n\t\treturn (screen_redraw_type_of_cell(ctx, px, py));\n\n\tnext2:\n\t\twp = TAILQ_NEXT(wp, entry);\n\t\tif (wp == NULL)\n\t\t\twp = TAILQ_FIRST(&w->panes);\n\t} while (wp != active);\n\n\treturn (CELL_OUTSIDE);\n}\n\n/* Check if the border of a particular pane. */\nstatic int\nscreen_redraw_check_is(struct screen_redraw_ctx *ctx, u_int px, u_int py,\n    struct window_pane *wp)\n{\n\tenum screen_redraw_border_type\tborder;\n\n\tborder = screen_redraw_pane_border(ctx, wp, px, py);\n\tif (border != SCREEN_REDRAW_INSIDE && border != SCREEN_REDRAW_OUTSIDE)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Update pane status. */\nstatic int\nscreen_redraw_make_pane_status(struct client *c, struct window_pane *wp,\n    struct screen_redraw_ctx *rctx, enum pane_lines pane_lines)\n{\n\tstruct window\t\t*w = wp->window;\n\tstruct grid_cell\t gc;\n\tconst char\t\t*fmt;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*expanded;\n\tint\t\t\t pane_status = rctx->pane_status;\n\tu_int\t\t\t width, i, cell_type, px, py;\n\tstruct screen_write_ctx\t ctx;\n\tstruct screen\t\t old;\n\n\tft = format_create(c, NULL, FORMAT_PANE|wp->id, FORMAT_STATUS);\n\tformat_defaults(ft, c, c->session, c->session->curw, wp);\n\n\tif (wp == server_client_get_pane(c))\n\t\tstyle_apply(&gc, w->options, \"pane-active-border-style\", ft);\n\telse\n\t\tstyle_apply(&gc, w->options, \"pane-border-style\", ft);\n\tfmt = options_get_string(wp->options, \"pane-border-format\");\n\n\texpanded = format_expand_time(ft, fmt);\n\tif (wp->sx < 4)\n\t\twp->status_size = width = 0;\n\telse\n\t\twp->status_size = width = wp->sx - 4;\n\n\tmemcpy(&old, &wp->status_screen, sizeof old);\n\tscreen_init(&wp->status_screen, width, 1, 0);\n\twp->status_screen.mode = 0;\n\n\tscreen_write_start(&ctx, &wp->status_screen);\n\n\tfor (i = 0; i < width; i++) {\n\t\tpx = wp->xoff + 2 + i;\n\t\tif (pane_status == PANE_STATUS_TOP)\n\t\t\tpy = wp->yoff - 1;\n\t\telse\n\t\t\tpy = wp->yoff + wp->sy;\n\t\tcell_type = screen_redraw_type_of_cell(rctx, px, py);\n\t\tscreen_redraw_border_set(w, wp, pane_lines, cell_type, &gc);\n\t\tscreen_write_cell(&ctx, &gc);\n\t}\n\tgc.attr &= ~GRID_ATTR_CHARSET;\n\n\tscreen_write_cursormove(&ctx, 0, 0, 0);\n\tformat_draw(&ctx, &gc, width, expanded, NULL, 0);\n\tscreen_write_stop(&ctx);\n\n\tfree(expanded);\n\tformat_free(ft);\n\n\tif (grid_compare(wp->status_screen.grid, old.grid) == 0) {\n\t\tscreen_free(&old);\n\t\treturn (0);\n\t}\n\tscreen_free(&old);\n\treturn (1);\n}\n\n/* Draw pane status. */\nstatic void\nscreen_redraw_draw_pane_status(struct screen_redraw_ctx *ctx)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window_pane\t*wp;\n\tstruct screen\t\t*s;\n\tu_int\t\t\t i, x, width, xoff, yoff, size;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\ts = &wp->status_screen;\n\n\t\tsize = wp->status_size;\n\t\tif (ctx->pane_status == PANE_STATUS_TOP)\n\t\t\tyoff = wp->yoff - 1;\n\t\telse\n\t\t\tyoff = wp->yoff + wp->sy;\n\t\txoff = wp->xoff + 2;\n\n\t\tif (xoff + size <= ctx->ox ||\n\t\t    xoff >= ctx->ox + ctx->sx ||\n\t\t    yoff < ctx->oy ||\n\t\t    yoff >= ctx->oy + ctx->sy)\n\t\t\tcontinue;\n\n\t\tif (xoff >= ctx->ox && xoff + size <= ctx->ox + ctx->sx) {\n\t\t\t/* All visible. */\n\t\t\ti = 0;\n\t\t\tx = xoff - ctx->ox;\n\t\t\twidth = size;\n\t\t} else if (xoff < ctx->ox && xoff + size > ctx->ox + ctx->sx) {\n\t\t\t/* Both left and right not visible. */\n\t\t\ti = ctx->ox;\n\t\t\tx = 0;\n\t\t\twidth = ctx->sx;\n\t\t} else if (xoff < ctx->ox) {\n\t\t\t/* Left not visible. */\n\t\t\ti = ctx->ox - xoff;\n\t\t\tx = 0;\n\t\t\twidth = size - i;\n\t\t} else {\n\t\t\t/* Right not visible. */\n\t\t\ti = 0;\n\t\t\tx = xoff - ctx->ox;\n\t\t\twidth = size - x;\n\t\t}\n\n\t\tif (ctx->statustop)\n\t\t\tyoff += ctx->statuslines;\n\t\ttty_draw_line(tty, s, i, 0, width, x, yoff - ctx->oy,\n\t\t    &grid_default_cell, NULL);\n\t}\n\ttty_cursor(tty, 0, 0);\n}\n\n/* Update status line and change flags if unchanged. */\nstatic uint64_t\nscreen_redraw_update(struct screen_redraw_ctx *ctx, uint64_t flags)\n{\n\tstruct client\t\t\t*c = ctx->c;\n\tstruct window\t\t\t*w = c->session->curw->window;\n\tstruct window_pane\t\t*wp;\n\tint\t\t\t\t redraw;\n\tenum pane_lines\t\t\t lines;\n\n\tif (c->message_string != NULL)\n\t\tredraw = status_message_redraw(c);\n\telse if (c->prompt_string != NULL)\n\t\tredraw = status_prompt_redraw(c);\n\telse\n\t\tredraw = status_redraw(c);\n\tif (!redraw && (~flags & CLIENT_REDRAWSTATUSALWAYS))\n\t\tflags &= ~CLIENT_REDRAWSTATUS;\n\n\tif (c->overlay_draw != NULL)\n\t\tflags |= CLIENT_REDRAWOVERLAY;\n\n\tif (ctx->pane_status != PANE_STATUS_OFF) {\n\t\tlines = ctx->pane_lines;\n\t\tredraw = 0;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (screen_redraw_make_pane_status(c, wp, ctx, lines))\n\t\t\t\tredraw = 1;\n\t\t}\n\t\tif (redraw)\n\t\t\tflags |= CLIENT_REDRAWBORDERS;\n\t}\n\n\treturn (flags);\n}\n\n/* Set up redraw context. */\nstatic void\nscreen_redraw_set_context(struct client *c, struct screen_redraw_ctx *ctx)\n{\n\tstruct session\t*s = c->session;\n\tstruct options\t*oo = s->options;\n\tstruct window\t*w = s->curw->window;\n\tstruct options\t*wo = w->options;\n\tu_int\t\t lines;\n\n\tmemset(ctx, 0, sizeof *ctx);\n\tctx->c = c;\n\n\tlines = status_line_size(c);\n\tif (c->message_string != NULL || c->prompt_string != NULL)\n\t\tlines = (lines == 0) ? 1 : lines;\n\tif (lines != 0 && options_get_number(oo, \"status-position\") == 0)\n\t\tctx->statustop = 1;\n\tctx->statuslines = lines;\n\n\tctx->pane_status = options_get_number(wo, \"pane-border-status\");\n\tctx->pane_lines = options_get_number(wo, \"pane-border-lines\");\n\n\tctx->pane_scrollbars = options_get_number(wo, \"pane-scrollbars\");\n\tctx->pane_scrollbars_pos = options_get_number(wo,\n\t    \"pane-scrollbars-position\");\n\n\ttty_window_offset(&c->tty, &ctx->ox, &ctx->oy, &ctx->sx, &ctx->sy);\n\n\tlog_debug(\"%s: %s @%u ox=%u oy=%u sx=%u sy=%u %u/%d\", __func__, c->name,\n\t    w->id, ctx->ox, ctx->oy, ctx->sx, ctx->sy, ctx->statuslines,\n\t    ctx->statustop);\n}\n\n/* Redraw entire screen. */\nvoid\nscreen_redraw_screen(struct client *c)\n{\n\tstruct screen_redraw_ctx\tctx;\n\tuint64_t\t\t\tflags;\n\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\tscreen_redraw_set_context(c, &ctx);\n\n\tflags = screen_redraw_update(&ctx, c->flags);\n\tif ((flags & CLIENT_ALLREDRAWFLAGS) == 0)\n\t\treturn;\n\n\ttty_sync_start(&c->tty);\n\ttty_update_mode(&c->tty, c->tty.mode, NULL);\n\n\tif (flags & (CLIENT_REDRAWWINDOW|CLIENT_REDRAWBORDERS)) {\n\t\tlog_debug(\"%s: redrawing borders\", c->name);\n\t\tscreen_redraw_draw_borders(&ctx);\n\t\tif (ctx.pane_status != PANE_STATUS_OFF)\n\t\t\tscreen_redraw_draw_pane_status(&ctx);\n\t\tscreen_redraw_draw_pane_scrollbars(&ctx);\n\t}\n\tif (flags & CLIENT_REDRAWWINDOW) {\n\t\tlog_debug(\"%s: redrawing panes\", c->name);\n\t\tscreen_redraw_draw_panes(&ctx);\n\t\tscreen_redraw_draw_pane_scrollbars(&ctx);\n\t}\n\tif (ctx.statuslines != 0 &&\n\t    (flags & (CLIENT_REDRAWSTATUS|CLIENT_REDRAWSTATUSALWAYS))) {\n\t\tlog_debug(\"%s: redrawing status\", c->name);\n\t\tscreen_redraw_draw_status(&ctx);\n\t}\n\tif (c->overlay_draw != NULL && (flags & CLIENT_REDRAWOVERLAY)) {\n\t\tlog_debug(\"%s: redrawing overlay\", c->name);\n\t\tc->overlay_draw(c, c->overlay_data, &ctx);\n\t}\n\n\ttty_reset(&c->tty);\n}\n\n/* Redraw a single pane and its scrollbar. */\nvoid\nscreen_redraw_pane(struct client *c, struct window_pane *wp,\n    int redraw_scrollbar_only)\n{\n\tstruct screen_redraw_ctx\tctx;\n\n\tif (!window_pane_visible(wp))\n\t\treturn;\n\n\tscreen_redraw_set_context(c, &ctx);\n\ttty_sync_start(&c->tty);\n\ttty_update_mode(&c->tty, c->tty.mode, NULL);\n\n\tif (!redraw_scrollbar_only)\n\t\tscreen_redraw_draw_pane(&ctx, wp);\n\n\tif (window_pane_show_scrollbar(wp, ctx.pane_scrollbars))\n\t\tscreen_redraw_draw_pane_scrollbar(&ctx, wp);\n\n\ttty_reset(&c->tty);\n}\n\n/* Get border cell style. */\nstatic const struct grid_cell *\nscreen_redraw_draw_borders_style(struct screen_redraw_ctx *ctx, u_int x,\n    u_int y, struct window_pane *wp)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct window_pane\t*active = server_client_get_pane(c);\n\tstruct options\t\t*oo = w->options;\n\tstruct format_tree\t*ft;\n\n\tif (wp->border_gc_set)\n\t\treturn (&wp->border_gc);\n\twp->border_gc_set = 1;\n\n\tft = format_create_defaults(NULL, c, s, s->curw, wp);\n\tif (screen_redraw_check_is(ctx, x, y, active))\n\t\tstyle_apply(&wp->border_gc, oo, \"pane-active-border-style\", ft);\n\telse\n\t\tstyle_apply(&wp->border_gc, oo, \"pane-border-style\", ft);\n\tformat_free(ft);\n\n\treturn (&wp->border_gc);\n}\n\n/* Draw a border cell. */\nstatic void\nscreen_redraw_draw_borders_cell(struct screen_redraw_ctx *ctx, u_int i, u_int j)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct options\t\t*oo = w->options;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct format_tree\t*ft;\n\tstruct window_pane\t*wp, *active = server_client_get_pane(c);\n\tstruct grid_cell\t gc;\n\tconst struct grid_cell\t*tmp;\n\tstruct overlay_ranges\t r;\n\tu_int\t\t\t cell_type, x = ctx->ox + i, y = ctx->oy + j;\n\tint\t\t\t arrows = 0, border, isolates;\n\n\tif (c->overlay_check != NULL) {\n\t\tc->overlay_check(c, c->overlay_data, x, y, 1, &r);\n\t\tif (r.nx[0] + r.nx[1] == 0)\n\t\t\treturn;\n\t}\n\n\tcell_type = screen_redraw_check_cell(ctx, x, y, &wp);\n\tif (cell_type == CELL_INSIDE || cell_type == CELL_SCROLLBAR)\n\t\treturn;\n\n\tif (wp == NULL) {\n\t\tif (!ctx->no_pane_gc_set) {\n\t\t\tft = format_create_defaults(NULL, c, s, s->curw, NULL);\n\t\t\tmemcpy(&ctx->no_pane_gc, &grid_default_cell, sizeof gc);\n\t\t\tstyle_add(&ctx->no_pane_gc, oo, \"pane-border-style\",\n\t\t\t    ft);\n\t\t\tformat_free(ft);\n\t\t\tctx->no_pane_gc_set = 1;\n\t\t}\n\t\tmemcpy(&gc, &ctx->no_pane_gc, sizeof gc);\n\t} else {\n\t\ttmp = screen_redraw_draw_borders_style(ctx, x, y, wp);\n\t\tif (tmp == NULL)\n\t\t\treturn;\n\t\tmemcpy(&gc, tmp, sizeof gc);\n\n\t\tif (server_is_marked(s, s->curw, marked_pane.wp) &&\n\t\t    screen_redraw_check_is(ctx, x, y, marked_pane.wp))\n\t\t\tgc.attr ^= GRID_ATTR_REVERSE;\n\t}\n\tscreen_redraw_border_set(w, wp, ctx->pane_lines, cell_type, &gc);\n\n\tif (cell_type == CELL_TOPBOTTOM &&\n\t    (c->flags & CLIENT_UTF8) &&\n\t    tty_term_has(tty->term, TTYC_BIDI))\n\t\tisolates = 1;\n\telse\n\t\tisolates = 0;\n\n\tif (ctx->statustop)\n\t\ttty_cursor(tty, i, ctx->statuslines + j);\n\telse\n\t\ttty_cursor(tty, i, j);\n\tif (isolates)\n\t\ttty_puts(tty, END_ISOLATE);\n\n\tswitch (options_get_number(oo, \"pane-border-indicators\")) {\n\tcase PANE_BORDER_ARROWS:\n\tcase PANE_BORDER_BOTH:\n\t\tarrows = 1;\n\t\tbreak;\n\t}\n\n\tif (wp != NULL && arrows) {\n\t\tborder = screen_redraw_pane_border(ctx, active, x, y);\n\t\tif (((i == wp->xoff + 1 &&\n\t\t    (cell_type == CELL_LEFTRIGHT ||\n\t\t    (cell_type == CELL_TOPJOIN &&\n\t\t    border == SCREEN_REDRAW_BORDER_BOTTOM) ||\n\t\t    (cell_type == CELL_BOTTOMJOIN &&\n\t\t    border == SCREEN_REDRAW_BORDER_TOP))) ||\n\t\t    (j == wp->yoff + 1 &&\n\t\t    (cell_type == CELL_TOPBOTTOM ||\n\t\t    (cell_type == CELL_LEFTJOIN &&\n\t\t    border == SCREEN_REDRAW_BORDER_RIGHT) ||\n\t\t    (cell_type == CELL_RIGHTJOIN &&\n\t\t    border == SCREEN_REDRAW_BORDER_LEFT)))) &&\n\t\t    screen_redraw_check_is(ctx, x, y, active)) {\n\t\t\tgc.attr |= GRID_ATTR_CHARSET;\n\t\t\tutf8_set(&gc.data, BORDER_MARKERS[border]);\n\t\t}\n\t}\n\n\ttty_cell(tty, &gc, &grid_default_cell, NULL, NULL);\n\tif (isolates)\n\t\ttty_puts(tty, START_ISOLATE);\n}\n\n/* Draw the borders. */\nstatic void\nscreen_redraw_draw_borders(struct screen_redraw_ctx *ctx)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t i, j;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry)\n\t\twp->border_gc_set = 0;\n\n\tfor (j = 0; j < c->tty.sy - ctx->statuslines; j++) {\n\t\tfor (i = 0; i < c->tty.sx; i++)\n\t\t\tscreen_redraw_draw_borders_cell(ctx, i, j);\n\t}\n}\n\n/* Draw the panes. */\nstatic void\nscreen_redraw_draw_panes(struct screen_redraw_ctx *ctx)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (window_pane_visible(wp))\n\t\t\tscreen_redraw_draw_pane(ctx, wp);\n\t}\n}\n\n/* Draw the status line. */\nstatic void\nscreen_redraw_draw_status(struct screen_redraw_ctx *ctx)\n{\n\tstruct client\t*c = ctx->c;\n\tstruct window\t*w = c->session->curw->window;\n\tstruct tty\t*tty = &c->tty;\n\tstruct screen\t*s = c->status.active;\n\tu_int\t\t i, y;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tif (ctx->statustop)\n\t\ty = 0;\n\telse\n\t\ty = c->tty.sy - ctx->statuslines;\n\tfor (i = 0; i < ctx->statuslines; i++) {\n\t\ttty_draw_line(tty, s, 0, i, UINT_MAX, 0, y + i,\n\t\t    &grid_default_cell, NULL);\n\t}\n}\n\n/* Draw one pane. */\nstatic void\nscreen_redraw_draw_pane(struct screen_redraw_ctx *ctx, struct window_pane *wp)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct screen\t\t*s = wp->screen;\n\tstruct colour_palette\t*palette = &wp->palette;\n\tstruct grid_cell\t defaults;\n\tu_int\t\t\t i, j, top, x, y, width;\n\n\tlog_debug(\"%s: %s @%u %%%u\", __func__, c->name, w->id, wp->id);\n\n\tif (wp->xoff + wp->sx <= ctx->ox || wp->xoff >= ctx->ox + ctx->sx)\n\t\treturn;\n\tif (ctx->statustop)\n\t\ttop = ctx->statuslines;\n\telse\n\t\ttop = 0;\n\tfor (j = 0; j < wp->sy; j++) {\n\t\tif (wp->yoff + j < ctx->oy || wp->yoff + j >= ctx->oy + ctx->sy)\n\t\t\tcontinue;\n\t\ty = top + wp->yoff + j - ctx->oy;\n\n\t\tif (wp->xoff >= ctx->ox &&\n\t\t    wp->xoff + wp->sx <= ctx->ox + ctx->sx) {\n\t\t\t/* All visible. */\n\t\t\ti = 0;\n\t\t\tx = wp->xoff - ctx->ox;\n\t\t\twidth = wp->sx;\n\t\t} else if (wp->xoff < ctx->ox &&\n\t\t    wp->xoff + wp->sx > ctx->ox + ctx->sx) {\n\t\t\t/* Both left and right not visible. */\n\t\t\ti = ctx->ox;\n\t\t\tx = 0;\n\t\t\twidth = ctx->sx;\n\t\t} else if (wp->xoff < ctx->ox) {\n\t\t\t/* Left not visible. */\n\t\t\ti = ctx->ox - wp->xoff;\n\t\t\tx = 0;\n\t\t\twidth = wp->sx - i;\n\t\t} else {\n\t\t\t/* Right not visible. */\n\t\t\ti = 0;\n\t\t\tx = wp->xoff - ctx->ox;\n\t\t\twidth = ctx->sx - x;\n\t\t}\n\t\tlog_debug(\"%s: %s %%%u line %u,%u at %u,%u, width %u\",\n\t\t    __func__, c->name, wp->id, i, j, x, y, width);\n\n\t\ttty_default_colours(&defaults, wp);\n\t\ttty_draw_line(tty, s, i, j, width, x, y, &defaults, palette);\n\t}\n\n#ifdef ENABLE_SIXEL\n\ttty_draw_images(c, wp, s);\n#endif\n}\n\n/* Draw the panes scrollbars */\nstatic void\nscreen_redraw_draw_pane_scrollbars(struct screen_redraw_ctx *ctx)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\n\tlog_debug(\"%s: %s @%u\", __func__, c->name, w->id);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (window_pane_show_scrollbar(wp, ctx->pane_scrollbars) &&\n\t\t    window_pane_visible(wp))\n\t\t\tscreen_redraw_draw_pane_scrollbar(ctx, wp);\n\t}\n}\n\n/* Draw pane scrollbar. */\nvoid\nscreen_redraw_draw_pane_scrollbar(struct screen_redraw_ctx *ctx,\n    struct window_pane *wp)\n{\n\tstruct screen\t*s = wp->screen;\n\tdouble\t\t percent_view;\n\tu_int\t\t sb = ctx->pane_scrollbars, total_height, sb_h = wp->sy;\n\tu_int\t\t sb_pos = ctx->pane_scrollbars_pos, slider_h, slider_y;\n\tint\t\t sb_w = wp->scrollbar_style.width;\n\tint\t\t sb_pad = wp->scrollbar_style.pad;\n\tint\t\t cm_y, cm_size, xoff = wp->xoff, ox = ctx->ox;\n\tint\t\t sb_x, sb_y = (int)(wp->yoff - ctx->oy); /* sb top */\n\n\tif (window_pane_mode(wp) == WINDOW_PANE_NO_MODE) {\n\t\tif (sb == PANE_SCROLLBARS_MODAL)\n\t\t\treturn;\n\t\t/* Show slider at the bottom of the scrollbar. */\n\t\ttotal_height = screen_size_y(s) + screen_hsize(s);\n\t\tpercent_view = (double)sb_h / total_height;\n\t\tslider_h = (double)sb_h * percent_view;\n\t\tslider_y = sb_h - slider_h;\n\t} else {\n\t\tif (TAILQ_FIRST(&wp->modes) == NULL)\n\t\t\treturn;\n\t\tif (window_copy_get_current_offset(wp, &cm_y, &cm_size) == 0)\n\t\t\treturn;\n\t\ttotal_height = cm_size + sb_h;\n\t\tpercent_view = (double)sb_h / (cm_size + sb_h);\n\t\tslider_h = (double)sb_h * percent_view;\n\t\tslider_y = (sb_h + 1) * ((double)cm_y / total_height);\n\t}\n\n\tif (sb_pos == PANE_SCROLLBARS_LEFT)\n\t\tsb_x = xoff - sb_w - sb_pad - ox;\n\telse\n\t\tsb_x = xoff + wp->sx - ox;\n\n\tif (slider_h < 1)\n\t\tslider_h = 1;\n\tif (slider_y >= sb_h)\n\t\tslider_y = sb_h - 1;\n\n\tscreen_redraw_draw_scrollbar(ctx, wp, sb_pos, sb_x, sb_y, sb_h,\n\t    slider_h, slider_y);\n\n\t/* Store current position and height of the slider */\n\twp->sb_slider_y = slider_y;  /* top of slider y pos in scrollbar */\n\twp->sb_slider_h = slider_h;  /* height of slider */\n}\n\nstatic void\nscreen_redraw_draw_scrollbar(struct screen_redraw_ctx *ctx,\n    struct window_pane *wp, int sb_pos, int sb_x, int sb_y, u_int sb_h,\n    u_int slider_h, u_int slider_y)\n{\n\tstruct client\t\t*c = ctx->c;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct grid_cell\t gc, slgc, *gcp;\n\tstruct style\t\t*sb_style = &wp->scrollbar_style;\n\tu_int\t\t\t i, j, imax, jmax;\n\tu_int\t\t\t sb_w = sb_style->width, sb_pad = sb_style->pad;\n\tint\t\t\t px, py, ox = ctx->ox, oy = ctx->oy;\n\tint\t\t\t sx = ctx->sx, sy = ctx->sy, xoff = wp->xoff;\n\tint\t\t\t yoff = wp->yoff;\n\n\t/* Set up style for slider. */\n\tgc = sb_style->gc;\n\tmemcpy(&slgc, &gc, sizeof slgc);\n\tslgc.fg = gc.bg;\n\tslgc.bg = gc.fg;\n\n\timax = sb_w + sb_pad;\n\tif ((int)imax + sb_x > sx)\n\t\timax = sx - sb_x;\n\tjmax = sb_h;\n\tif ((int)jmax + sb_y > sy)\n\t\tjmax = sy - sb_y;\n\n\tfor (j = 0; j < jmax; j++) {\n\t\tpy = sb_y + j;\n\t\tfor (i = 0; i < imax; i++) {\n\t\t\tpx = sb_x + i;\n\t\t\tif (px < xoff - ox - (int)sb_w - (int)sb_pad ||\n\t\t\t    px >= sx || px < 0 ||\n\t\t\t    py < yoff - oy - 1 ||\n\t\t\t    py >= sy || py < 0)\n\t\t\t\tcontinue;\n\t\t\ttty_cursor(tty, px, py);\n\t\t\tif ((sb_pos == PANE_SCROLLBARS_LEFT &&\n\t\t\t    i >= sb_w && i < sb_w + sb_pad) ||\n\t\t\t    (sb_pos == PANE_SCROLLBARS_RIGHT &&\n\t\t\t     i < sb_pad)) {\n\t\t\t\ttty_cell(tty, &grid_default_cell,\n\t\t\t\t    &grid_default_cell, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tif (j >= slider_y && j < slider_y + slider_h)\n\t\t\t\t\tgcp = &slgc;\n\t\t\t\telse\n\t\t\t\t\tgcp = &gc;\n\t\t\t\ttty_cell(tty, gcp, &grid_default_cell, NULL,\n\t\t\t\t    NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "screen-write.c",
          "type": "blob",
          "size": 57.0498046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic struct screen_write_citem *screen_write_collect_trim(\n\t\t    struct screen_write_ctx *, u_int, u_int, u_int, int *);\nstatic void\tscreen_write_collect_clear(struct screen_write_ctx *, u_int,\n\t\t    u_int);\nstatic void\tscreen_write_collect_scroll(struct screen_write_ctx *, u_int);\nstatic void\tscreen_write_collect_flush(struct screen_write_ctx *, int,\n\t\t    const char *);\nstatic int\tscreen_write_overwrite(struct screen_write_ctx *,\n\t\t    struct grid_cell *, u_int);\nstatic int\tscreen_write_combine(struct screen_write_ctx *,\n\t\t    const struct grid_cell *);\n\nstruct screen_write_citem {\n\tu_int\t\t\t\tx;\n\tint\t\t\t\twrapped;\n\n\tenum { TEXT, CLEAR }\t\ttype;\n\tu_int\t\t\t\tused;\n\tu_int\t\t\t\tbg;\n\n\tstruct grid_cell\t\tgc;\n\n\tTAILQ_ENTRY(screen_write_citem) entry;\n};\nstruct screen_write_cline {\n\tchar\t\t\t\t*data;\n\tTAILQ_HEAD(, screen_write_citem) items;\n};\nTAILQ_HEAD(, screen_write_citem)  screen_write_citem_freelist =\n    TAILQ_HEAD_INITIALIZER(screen_write_citem_freelist);\n\nstatic struct screen_write_citem *\nscreen_write_get_citem(void)\n{\n    struct screen_write_citem\t*ci;\n\n    ci = TAILQ_FIRST(&screen_write_citem_freelist);\n    if (ci != NULL) {\n        TAILQ_REMOVE(&screen_write_citem_freelist, ci, entry);\n        memset(ci, 0, sizeof *ci);\n        return (ci);\n    }\n    return (xcalloc(1, sizeof *ci));\n}\n\nstatic void\nscreen_write_free_citem(struct screen_write_citem *ci)\n{\n    TAILQ_INSERT_TAIL(&screen_write_citem_freelist, ci, entry);\n}\n\nstatic void\nscreen_write_offset_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct window\t*w = data;\n\n\ttty_update_window_offset(w);\n}\n\n/* Set cursor position. */\nstatic void\nscreen_write_set_cursor(struct screen_write_ctx *ctx, int cx, int cy)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct window\t\t*w;\n\tstruct screen\t\t*s = ctx->s;\n\tstruct timeval\t\t tv = { .tv_usec = 10000 };\n\n\tif (cx != -1 && (u_int)cx == s->cx && cy != -1 && (u_int)cy == s->cy)\n\t\treturn;\n\n\tif (cx != -1) {\n\t\tif ((u_int)cx > screen_size_x(s)) /* allow last column */\n\t\t\tcx = screen_size_x(s) - 1;\n\t\ts->cx = cx;\n\t}\n\tif (cy != -1) {\n\t\tif ((u_int)cy > screen_size_y(s) - 1)\n\t\t\tcy = screen_size_y(s) - 1;\n\t\ts->cy = cy;\n\t}\n\n\tif (wp == NULL)\n\t\treturn;\n\tw = wp->window;\n\n\tif (!event_initialized(&w->offset_timer))\n\t\tevtimer_set(&w->offset_timer, screen_write_offset_timer, w);\n\tif (!evtimer_pending(&w->offset_timer, NULL))\n\t\tevtimer_add(&w->offset_timer, &tv);\n}\n\n/* Do a full redraw. */\nstatic void\nscreen_write_redraw_cb(const struct tty_ctx *ttyctx)\n{\n\tstruct window_pane\t*wp = ttyctx->arg;\n\n\tif (wp != NULL)\n\t\twp->flags |= PANE_REDRAW;\n}\n\n/* Update context for client. */\nstatic int\nscreen_write_set_client_cb(struct tty_ctx *ttyctx, struct client *c)\n{\n\tstruct window_pane\t*wp = ttyctx->arg;\n\n\tif (ttyctx->allow_invisible_panes) {\n\t\tif (session_has(c->session, wp->window))\n\t\t\treturn (1);\n\t\treturn (0);\n\t}\n\n\tif (c->session->curw->window != wp->window)\n\t\treturn (0);\n\tif (wp->layout_cell == NULL)\n\t\treturn (0);\n\n\tif (wp->flags & (PANE_REDRAW|PANE_DROP))\n\t\treturn (-1);\n\tif (c->flags & CLIENT_REDRAWPANES) {\n\t\t/*\n\t\t * Redraw is already deferred to redraw another pane - redraw\n\t\t * this one also when that happens.\n\t\t */\n\t\tlog_debug(\"%s: adding %%%u to deferred redraw\", __func__,\n\t\t    wp->id);\n\t\twp->flags |= (PANE_REDRAW|PANE_REDRAWSCROLLBAR);\n\t\treturn (-1);\n\t}\n\n\tttyctx->bigger = tty_window_offset(&c->tty, &ttyctx->wox, &ttyctx->woy,\n\t    &ttyctx->wsx, &ttyctx->wsy);\n\n\tttyctx->xoff = ttyctx->rxoff = wp->xoff;\n\tttyctx->yoff = ttyctx->ryoff = wp->yoff;\n\n\tif (status_at_line(c) == 0)\n\t\tttyctx->yoff += status_line_size(c);\n\n\treturn (1);\n}\n\n/* Set up context for TTY command. */\nstatic void\nscreen_write_initctx(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx,\n    int sync)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tmemset(ttyctx, 0, sizeof *ttyctx);\n\n\tttyctx->s = s;\n\tttyctx->sx = screen_size_x(s);\n\tttyctx->sy = screen_size_y(s);\n\n\tttyctx->ocx = s->cx;\n\tttyctx->ocy = s->cy;\n\tttyctx->orlower = s->rlower;\n\tttyctx->orupper = s->rupper;\n\n\tmemcpy(&ttyctx->defaults, &grid_default_cell, sizeof ttyctx->defaults);\n\tif (ctx->init_ctx_cb != NULL) {\n\t\tctx->init_ctx_cb(ctx, ttyctx);\n\t\tif (ttyctx->palette != NULL) {\n\t\t\tif (ttyctx->defaults.fg == 8)\n\t\t\t\tttyctx->defaults.fg = ttyctx->palette->fg;\n\t\t\tif (ttyctx->defaults.bg == 8)\n\t\t\t\tttyctx->defaults.bg = ttyctx->palette->bg;\n\t\t}\n\t} else {\n\t\tttyctx->redraw_cb = screen_write_redraw_cb;\n\t\tif (ctx->wp != NULL) {\n\t\t\ttty_default_colours(&ttyctx->defaults, ctx->wp);\n\t\t\tttyctx->palette = &ctx->wp->palette;\n\t\t\tttyctx->set_client_cb = screen_write_set_client_cb;\n\t\t\tttyctx->arg = ctx->wp;\n\t\t}\n\t}\n\n\tif (~ctx->flags & SCREEN_WRITE_SYNC) {\n\t\t/*\n\t\t * For the active pane or for an overlay (no pane), we want to\n\t\t * only use synchronized updates if requested (commands that\n\t\t * move the cursor); for other panes, always use it, since the\n\t\t * cursor will have to move.\n\t\t */\n\t\tif (ctx->wp != NULL) {\n\t\t\tif (ctx->wp != ctx->wp->window->active)\n\t\t\t\tttyctx->num = 1;\n\t\t\telse\n\t\t\t\tttyctx->num = sync;\n\t\t} else\n\t\t\tttyctx->num = 0x10|sync;\n\t\ttty_write(tty_cmd_syncstart, ttyctx);\n\t\tctx->flags |= SCREEN_WRITE_SYNC;\n\t}\n}\n\n/* Make write list. */\nvoid\nscreen_write_make_list(struct screen *s)\n{\n\tu_int\ty;\n\n\ts->write_list = xcalloc(screen_size_y(s), sizeof *s->write_list);\n\tfor (y = 0; y < screen_size_y(s); y++)\n\t\tTAILQ_INIT(&s->write_list[y].items);\n}\n\n/* Free write list. */\nvoid\nscreen_write_free_list(struct screen *s)\n{\n\tu_int\ty;\n\n\tfor (y = 0; y < screen_size_y(s); y++)\n\t\tfree(s->write_list[y].data);\n\tfree(s->write_list);\n}\n\n/* Set up for writing. */\nstatic void\nscreen_write_init(struct screen_write_ctx *ctx, struct screen *s)\n{\n\tmemset(ctx, 0, sizeof *ctx);\n\n\tctx->s = s;\n\n\tif (ctx->s->write_list == NULL)\n\t\tscreen_write_make_list(ctx->s);\n\tctx->item = screen_write_get_citem();\n\n\tctx->scrolled = 0;\n\tctx->bg = 8;\n}\n\n/* Initialize writing with a pane. */\nvoid\nscreen_write_start_pane(struct screen_write_ctx *ctx, struct window_pane *wp,\n    struct screen *s)\n{\n\tif (s == NULL)\n\t\ts = wp->screen;\n\tscreen_write_init(ctx, s);\n\tctx->wp = wp;\n\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"%s: size %ux%u, pane %%%u (at %u,%u)\",\n\t\t    __func__, screen_size_x(ctx->s), screen_size_y(ctx->s),\n\t\t    wp->id, wp->xoff, wp->yoff);\n\t}\n}\n\n/* Initialize writing with a callback. */\nvoid\nscreen_write_start_callback(struct screen_write_ctx *ctx, struct screen *s,\n    screen_write_init_ctx_cb cb, void *arg)\n{\n\tscreen_write_init(ctx, s);\n\n\tctx->init_ctx_cb = cb;\n\tctx->arg = arg;\n\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"%s: size %ux%u, with callback\", __func__,\n\t\t    screen_size_x(ctx->s), screen_size_y(ctx->s));\n\t}\n}\n\n/* Initialize writing. */\nvoid\nscreen_write_start(struct screen_write_ctx *ctx, struct screen *s)\n{\n\tscreen_write_init(ctx, s);\n\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"%s: size %ux%u, no pane\", __func__,\n\t\t    screen_size_x(ctx->s), screen_size_y(ctx->s));\n\t}\n}\n\n/* Finish writing. */\nvoid\nscreen_write_stop(struct screen_write_ctx *ctx)\n{\n\tscreen_write_collect_end(ctx);\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\tscreen_write_free_citem(ctx->item);\n}\n\n/* Reset screen state. */\nvoid\nscreen_write_reset(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tscreen_reset_tabs(s);\n\tscreen_write_scrollregion(ctx, 0, screen_size_y(s) - 1);\n\n\ts->mode = MODE_CURSOR|MODE_WRAP;\n\n\tif (options_get_number(global_options, \"extended-keys\") == 2)\n\t\ts->mode = (s->mode & ~EXTENDED_KEY_MODES)|MODE_KEYS_EXTENDED;\n\n\tscreen_write_clearscreen(ctx, 8);\n\tscreen_write_set_cursor(ctx, 0, 0);\n}\n\n/* Write character. */\nvoid\nscreen_write_putc(struct screen_write_ctx *ctx, const struct grid_cell *gcp,\n    u_char ch)\n{\n\tstruct grid_cell\tgc;\n\n\tmemcpy(&gc, gcp, sizeof gc);\n\n\tutf8_set(&gc.data, ch);\n\tscreen_write_cell(ctx, &gc);\n}\n\n/* Calculate string length. */\nsize_t\nscreen_write_strlen(const char *fmt, ...)\n{\n\tva_list\t\t\tap;\n\tchar   \t       \t       *msg;\n\tstruct utf8_data\tud;\n\tu_char \t      \t       *ptr;\n\tsize_t\t\t\tleft, size = 0;\n\tenum utf8_state\t\tmore;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tptr = msg;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {\n\t\t\tptr++;\n\n\t\t\tleft = strlen(ptr);\n\t\t\tif (left < (size_t)ud.size - 1)\n\t\t\t\tbreak;\n\t\t\twhile ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)\n\t\t\t\tptr++;\n\t\t\tptr++;\n\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\tsize += ud.width;\n\t\t} else {\n\t\t\tif (*ptr == '\\t' || (*ptr > 0x1f && *ptr < 0x7f))\n\t\t\t\tsize++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tfree(msg);\n\treturn (size);\n}\n\n/* Write string wrapped over lines. */\nint\nscreen_write_text(struct screen_write_ctx *ctx, u_int cx, u_int width,\n    u_int lines, int more, const struct grid_cell *gcp, const char *fmt, ...)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*tmp;\n\tu_int\t\t\t cy = s->cy, i, end, next, idx = 0, at, left;\n\tstruct utf8_data\t*text;\n\tstruct grid_cell\t gc;\n\n\tmemcpy(&gc, gcp, sizeof gc);\n\n\tva_start(ap, fmt);\n\txvasprintf(&tmp, fmt, ap);\n\tva_end(ap);\n\n\ttext = utf8_fromcstr(tmp);\n\tfree(tmp);\n\n\tleft = (cx + width) - s->cx;\n\tfor (;;) {\n\t\t/* Find the end of what can fit on the line. */\n\t\tat = 0;\n\t\tfor (end = idx; text[end].size != 0; end++) {\n\t\t\tif (text[end].size == 1 && text[end].data[0] == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (at + text[end].width > left)\n\t\t\t\tbreak;\n\t\t\tat += text[end].width;\n\t\t}\n\n\t\t/*\n\t\t * If we're on a space, that's the end. If not, walk back to\n\t\t * try and find one.\n\t\t */\n\t\tif (text[end].size == 0)\n\t\t\tnext = end;\n\t\telse if (text[end].size == 1 && text[end].data[0] == '\\n')\n\t\t\tnext = end + 1;\n\t\telse if (text[end].size == 1 && text[end].data[0] == ' ')\n\t\t\tnext = end + 1;\n\t\telse {\n\t\t\tfor (i = end; i > idx; i--) {\n\t\t\t\tif (text[i].size == 1 && text[i].data[0] == ' ')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != idx) {\n\t\t\t\tnext = i + 1;\n\t\t\t\tend = i;\n\t\t\t} else\n\t\t\t\tnext = end;\n\t\t}\n\n\t\t/* Print the line. */\n\t\tfor (i = idx; i < end; i++) {\n\t\t\tutf8_copy(&gc.data, &text[i]);\n\t\t\tscreen_write_cell(ctx, &gc);\n\t\t}\n\n\t\t/* If at the bottom, stop. */\n\t\tidx = next;\n\t\tif (s->cy == cy + lines - 1 || text[idx].size == 0)\n\t\t\tbreak;\n\n\t\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0);\n\t\tleft = width;\n\t}\n\n\t/*\n\t * Fail if on the last line and there is more to come or at the end, or\n\t * if the text was not entirely consumed.\n\t */\n\tif ((s->cy == cy + lines - 1 && (!more || s->cx == cx + width)) ||\n\t    text[idx].size != 0) {\n\t\tfree(text);\n\t\treturn (0);\n\t}\n\tfree(text);\n\n\t/*\n\t * If no more to come, move to the next line. Otherwise, leave on\n\t * the same line (except if at the end).\n\t */\n\tif (!more || s->cx == cx + width)\n\t\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0);\n\treturn (1);\n}\n\n/* Write simple string (no maximum length). */\nvoid\nscreen_write_puts(struct screen_write_ctx *ctx, const struct grid_cell *gcp,\n    const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tscreen_write_vnputs(ctx, -1, gcp, fmt, ap);\n\tva_end(ap);\n}\n\n/* Write string with length limit (-1 for unlimited). */\nvoid\nscreen_write_nputs(struct screen_write_ctx *ctx, ssize_t maxlen,\n    const struct grid_cell *gcp, const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tscreen_write_vnputs(ctx, maxlen, gcp, fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nscreen_write_vnputs(struct screen_write_ctx *ctx, ssize_t maxlen,\n    const struct grid_cell *gcp, const char *fmt, va_list ap)\n{\n\tstruct grid_cell\tgc;\n\tstruct utf8_data       *ud = &gc.data;\n\tchar   \t\t       *msg;\n\tu_char \t\t       *ptr;\n\tsize_t\t\t \tleft, size = 0;\n\tenum utf8_state\t\tmore;\n\n\tmemcpy(&gc, gcp, sizeof gc);\n\txvasprintf(&msg, fmt, ap);\n\n\tptr = msg;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr > 0x7f && utf8_open(ud, *ptr) == UTF8_MORE) {\n\t\t\tptr++;\n\n\t\t\tleft = strlen(ptr);\n\t\t\tif (left < (size_t)ud->size - 1)\n\t\t\t\tbreak;\n\t\t\twhile ((more = utf8_append(ud, *ptr)) == UTF8_MORE)\n\t\t\t\tptr++;\n\t\t\tptr++;\n\n\t\t\tif (more != UTF8_DONE)\n\t\t\t\tcontinue;\n\t\t\tif (maxlen > 0 && size + ud->width > (size_t)maxlen) {\n\t\t\t\twhile (size < (size_t)maxlen) {\n\t\t\t\t\tscreen_write_putc(ctx, &gc, ' ');\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize += ud->width;\n\t\t\tscreen_write_cell(ctx, &gc);\n\t\t} else {\n\t\t\tif (maxlen > 0 && size + 1 > (size_t)maxlen)\n\t\t\t\tbreak;\n\n\t\t\tif (*ptr == '\\001')\n\t\t\t\tgc.attr ^= GRID_ATTR_CHARSET;\n\t\t\telse if (*ptr == '\\n') {\n\t\t\t\tscreen_write_linefeed(ctx, 0, 8);\n\t\t\t\tscreen_write_carriagereturn(ctx);\n\t\t\t} else if (*ptr == '\\t' || (*ptr > 0x1f && *ptr < 0x7f)) {\n\t\t\t\tsize++;\n\t\t\t\tscreen_write_putc(ctx, &gc, *ptr);\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tfree(msg);\n}\n\n/*\n * Copy from another screen but without the selection stuff. Assumes the target\n * region is already big enough.\n */\nvoid\nscreen_write_fast_copy(struct screen_write_ctx *ctx, struct screen *src,\n    u_int px, u_int py, u_int nx, u_int ny)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct tty_ctx\t \t ttyctx;\n\tstruct grid\t\t*gd = src->grid;\n\tstruct grid_cell\t gc;\n\tu_int\t\t \t xx, yy, cx = s->cx, cy = s->cy;\n\n\tif (nx == 0 || ny == 0)\n\t\treturn;\n\n\tcy = s->cy;\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tif (yy >= gd->hsize + gd->sy)\n\t\t\tbreak;\n\t\ts->cx = cx;\n\t\tif (wp != NULL)\n\t\t\tscreen_write_initctx(ctx, &ttyctx, 0);\n\t\tfor (xx = px; xx < px + nx; xx++) {\n\t\t\tif (xx >= grid_get_line(gd, yy)->cellsize)\n\t\t\t\tbreak;\n\t\t\tgrid_get_cell(gd, xx, yy, &gc);\n\t\t\tif (xx + gc.data.width > px + nx)\n\t\t\t\tbreak;\n\t\t\tgrid_view_set_cell(ctx->s->grid, s->cx, s->cy, &gc);\n\t\t\tif (wp != NULL) {\n\t\t\t\tttyctx.cell = &gc;\n\t\t\t\ttty_write(tty_cmd_cell, &ttyctx);\n\t\t\t\tttyctx.ocx++;\n\t\t\t}\n\t\t\ts->cx++;\n\t\t}\n\t\ts->cy++;\n\t}\n\n\ts->cx = cx;\n\ts->cy = cy;\n}\n\n/* Select character set for drawing border lines. */\nstatic void\nscreen_write_box_border_set(enum box_lines lines, int cell_type,\n    struct grid_cell *gc)\n{\n\tswitch (lines) {\n        case BOX_LINES_NONE:\n\t\tbreak;\n        case BOX_LINES_DOUBLE:\n                gc->attr &= ~GRID_ATTR_CHARSET;\n                utf8_copy(&gc->data, tty_acs_double_borders(cell_type));\n\t\tbreak;\n        case BOX_LINES_HEAVY:\n                gc->attr &= ~GRID_ATTR_CHARSET;\n                utf8_copy(&gc->data, tty_acs_heavy_borders(cell_type));\n\t\tbreak;\n        case BOX_LINES_ROUNDED:\n                gc->attr &= ~GRID_ATTR_CHARSET;\n                utf8_copy(&gc->data, tty_acs_rounded_borders(cell_type));\n\t\tbreak;\n        case BOX_LINES_SIMPLE:\n                gc->attr &= ~GRID_ATTR_CHARSET;\n                utf8_set(&gc->data, SIMPLE_BORDERS[cell_type]);\n                break;\n        case BOX_LINES_PADDED:\n                gc->attr &= ~GRID_ATTR_CHARSET;\n                utf8_set(&gc->data, PADDED_BORDERS[cell_type]);\n                break;\n\tcase BOX_LINES_SINGLE:\n\tcase BOX_LINES_DEFAULT:\n\t\tgc->attr |= GRID_ATTR_CHARSET;\n\t\tutf8_set(&gc->data, CELL_BORDERS[cell_type]);\n\t\tbreak;\n\t}\n}\n\n/* Draw a horizontal line on screen. */\nvoid\nscreen_write_hline(struct screen_write_ctx *ctx, u_int nx, int left, int right,\n   enum box_lines lines, const struct grid_cell *border_gc)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t cx, cy, i;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\n\tif (border_gc != NULL)\n\t\tmemcpy(&gc, border_gc, sizeof gc);\n\telse\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tgc.attr |= GRID_ATTR_CHARSET;\n\n\tif (left)\n\t\tscreen_write_box_border_set(lines, CELL_LEFTJOIN, &gc);\n\telse\n\t\tscreen_write_box_border_set(lines, CELL_LEFTRIGHT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\n\tscreen_write_box_border_set(lines, CELL_LEFTRIGHT, &gc);\n\tfor (i = 1; i < nx - 1; i++)\n\t\tscreen_write_cell(ctx, &gc);\n\n\tif (right)\n\t\tscreen_write_box_border_set(lines, CELL_RIGHTJOIN, &gc);\n\telse\n\t\tscreen_write_box_border_set(lines, CELL_LEFTRIGHT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Draw a vertical line on screen. */\nvoid\nscreen_write_vline(struct screen_write_ctx *ctx, u_int ny, int top, int bottom)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t cx, cy, i;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tgc.attr |= GRID_ATTR_CHARSET;\n\n\tscreen_write_putc(ctx, &gc, top ? 'w' : 'x');\n\tfor (i = 1; i < ny - 1; i++) {\n\t\tscreen_write_set_cursor(ctx, cx, cy + i);\n\t\tscreen_write_putc(ctx, &gc, 'x');\n\t}\n\tscreen_write_set_cursor(ctx, cx, cy + ny - 1);\n\tscreen_write_putc(ctx, &gc, bottom ? 'v' : 'x');\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Draw a menu on screen. */\nvoid\nscreen_write_menu(struct screen_write_ctx *ctx, struct menu *menu, int choice,\n    enum box_lines lines, const struct grid_cell *menu_gc,\n    const struct grid_cell *border_gc, const struct grid_cell *choice_gc)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_cell\t default_gc;\n\tconst struct grid_cell\t*gc = &default_gc;\n\tu_int\t\t\t cx, cy, i, j, width = menu->width;\n\tconst char\t\t*name;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\n\tmemcpy(&default_gc, menu_gc, sizeof default_gc);\n\n\tscreen_write_box(ctx, menu->width + 4, menu->count + 2, lines,\n\t    border_gc, menu->title);\n\n\tfor (i = 0; i < menu->count; i++) {\n\t\tname = menu->items[i].name;\n\t\tif (name == NULL) {\n\t\t\tscreen_write_cursormove(ctx, cx, cy + 1 + i, 0);\n\t\t\tscreen_write_hline(ctx, width + 4, 1, 1, lines,\n\t\t\t    border_gc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (choice >= 0 && i == (u_int)choice && *name != '-')\n\t\t\tgc = choice_gc;\n\n\t\tscreen_write_cursormove(ctx, cx + 1, cy + 1 + i, 0);\n\t\tfor (j = 0; j < width + 2; j++)\n\t\t\tscreen_write_putc(ctx, gc, ' ');\n\n\t\tscreen_write_cursormove(ctx, cx + 2, cy + 1 + i, 0);\n\t\tif (*name == '-') {\n\t\t\tdefault_gc.attr |= GRID_ATTR_DIM;\n\t\t\tformat_draw(ctx, gc, width, name + 1, NULL, 0);\n\t\t\tdefault_gc.attr &= ~GRID_ATTR_DIM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tformat_draw(ctx, gc, width, name, NULL, 0);\n\t\tgc = &default_gc;\n\t}\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Draw a box on screen. */\nvoid\nscreen_write_box(struct screen_write_ctx *ctx, u_int nx, u_int ny,\n    enum box_lines lines, const struct grid_cell *gcp, const char *title)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_cell         gc;\n\tu_int\t\t\t cx, cy, i;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\n\tif (gcp != NULL)\n\t\tmemcpy(&gc, gcp, sizeof gc);\n\telse\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\n\tgc.attr |= GRID_ATTR_CHARSET;\n\tgc.flags |= GRID_FLAG_NOPALETTE;\n\n\t/* Draw top border */\n\tscreen_write_box_border_set(lines, CELL_TOPLEFT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\tscreen_write_box_border_set(lines, CELL_LEFTRIGHT, &gc);\n\tfor (i = 1; i < nx - 1; i++)\n\t\tscreen_write_cell(ctx, &gc);\n\tscreen_write_box_border_set(lines, CELL_TOPRIGHT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\n\t/* Draw bottom border */\n\tscreen_write_set_cursor(ctx, cx, cy + ny - 1);\n\tscreen_write_box_border_set(lines, CELL_BOTTOMLEFT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\tscreen_write_box_border_set(lines, CELL_LEFTRIGHT, &gc);\n\tfor (i = 1; i < nx - 1; i++)\n\t\tscreen_write_cell(ctx, &gc);\n\tscreen_write_box_border_set(lines, CELL_BOTTOMRIGHT, &gc);\n\tscreen_write_cell(ctx, &gc);\n\n\t/* Draw sides */\n\tscreen_write_box_border_set(lines, CELL_TOPBOTTOM, &gc);\n\tfor (i = 1; i < ny - 1; i++) {\n\t\t/* left side */\n\t\tscreen_write_set_cursor(ctx, cx, cy + i);\n\t\tscreen_write_cell(ctx, &gc);\n\t\t/* right side */\n\t\tscreen_write_set_cursor(ctx, cx + nx - 1, cy + i);\n\t\tscreen_write_cell(ctx, &gc);\n\t}\n\n\tif (title != NULL) {\n\t\tgc.attr &= ~GRID_ATTR_CHARSET;\n\t\tscreen_write_cursormove(ctx, cx + 2, cy, 0);\n\t\tformat_draw(ctx, &gc, nx - 4, title, NULL, 0);\n\t}\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/*\n * Write a preview version of a window. Assumes target area is big enough and\n * already cleared.\n */\nvoid\nscreen_write_preview(struct screen_write_ctx *ctx, struct screen *src, u_int nx,\n    u_int ny)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t cx, cy, px, py;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\n\t/*\n\t * If the cursor is on, pick the area around the cursor, otherwise use\n\t * the top left.\n\t */\n\tif (src->mode & MODE_CURSOR) {\n\t\tpx = src->cx;\n\t\tif (px < nx / 3)\n\t\t\tpx = 0;\n\t\telse\n\t\t\tpx = px - nx / 3;\n\t\tif (px + nx > screen_size_x(src)) {\n\t\t\tif (nx > screen_size_x(src))\n\t\t\t\tpx = 0;\n\t\t\telse\n\t\t\t\tpx = screen_size_x(src) - nx;\n\t\t}\n\t\tpy = src->cy;\n\t\tif (py < ny / 3)\n\t\t\tpy = 0;\n\t\telse\n\t\t\tpy = py - ny / 3;\n\t\tif (py + ny > screen_size_y(src)) {\n\t\t\tif (ny > screen_size_y(src))\n\t\t\t\tpy = 0;\n\t\t\telse\n\t\t\t\tpy = screen_size_y(src) - ny;\n\t\t}\n\t} else {\n\t\tpx = 0;\n\t\tpy = 0;\n\t}\n\n\tscreen_write_fast_copy(ctx, src, px, src->grid->hsize + py, nx, ny);\n\n\tif (src->mode & MODE_CURSOR) {\n\t\tgrid_view_get_cell(src->grid, src->cx, src->cy, &gc);\n\t\tgc.attr |= GRID_ATTR_REVERSE;\n\t\tscreen_write_set_cursor(ctx, cx + (src->cx - px),\n\t\t    cy + (src->cy - py));\n\t\tscreen_write_cell(ctx, &gc);\n\t}\n}\n\n/* Set a mode. */\nvoid\nscreen_write_mode_set(struct screen_write_ctx *ctx, int mode)\n{\n\tstruct screen\t*s = ctx->s;\n\n\ts->mode |= mode;\n\n\tif (log_get_level() != 0)\n\t\tlog_debug(\"%s: %s\", __func__, screen_mode_to_string(mode));\n}\n\n/* Clear a mode. */\nvoid\nscreen_write_mode_clear(struct screen_write_ctx *ctx, int mode)\n{\n\tstruct screen\t*s = ctx->s;\n\n\ts->mode &= ~mode;\n\n\tif (log_get_level() != 0)\n\t\tlog_debug(\"%s: %s\", __func__, screen_mode_to_string(mode));\n}\n\n/* Cursor up by ny. */\nvoid\nscreen_write_cursorup(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\tu_int\t\t cx = s->cx, cy = s->cy;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (cy < s->rupper) {\n\t\t/* Above region. */\n\t\tif (ny > cy)\n\t\t\tny = cy;\n\t} else {\n\t\t/* Below region. */\n\t\tif (ny > cy - s->rupper)\n\t\t\tny = cy - s->rupper;\n\t}\n\tif (cx == screen_size_x(s))\n\t\tcx--;\n\n\tcy -= ny;\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Cursor down by ny. */\nvoid\nscreen_write_cursordown(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\tu_int\t\t cx = s->cx, cy = s->cy;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (cy > s->rlower) {\n\t\t/* Below region. */\n\t\tif (ny > screen_size_y(s) - 1 - cy)\n\t\t\tny = screen_size_y(s) - 1 - cy;\n\t} else {\n\t\t/* Above region. */\n\t\tif (ny > s->rlower - cy)\n\t\t\tny = s->rlower - cy;\n\t}\n\tif (cx == screen_size_x(s))\n\t    cx--;\n\telse if (ny == 0)\n\t\treturn;\n\n\tcy += ny;\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Cursor right by nx. */\nvoid\nscreen_write_cursorright(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\tu_int\t\t cx = s->cx, cy = s->cy;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - 1 - cx)\n\t\tnx = screen_size_x(s) - 1 - cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tcx += nx;\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Cursor left by nx. */\nvoid\nscreen_write_cursorleft(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\tu_int\t\t cx = s->cx, cy = s->cy;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > cx)\n\t\tnx = cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tcx -= nx;\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* Backspace; cursor left unless at start of wrapped line when can move up. */\nvoid\nscreen_write_backspace(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t cx = s->cx, cy = s->cy;\n\n\tif (cx == 0) {\n\t\tif (cy == 0)\n\t\t\treturn;\n\t\tgl = grid_get_line(s->grid, s->grid->hsize + cy - 1);\n\t\tif (gl->flags & GRID_LINE_WRAPPED) {\n\t\t\tcy--;\n\t\t\tcx = screen_size_x(s) - 1;\n\t\t}\n\t} else\n\t\tcx--;\n\n\tscreen_write_set_cursor(ctx, cx, cy);\n}\n\n/* VT100 alignment test. */\nvoid\nscreen_write_alignmenttest(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct tty_ctx\t \t ttyctx;\n\tstruct grid_cell       \t gc;\n\tu_int\t\t\t xx, yy;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tutf8_set(&gc.data, 'E');\n\n#ifdef ENABLE_SIXEL\n\tif (image_free_all(s) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tfor (yy = 0; yy < screen_size_y(s); yy++) {\n\t\tfor (xx = 0; xx < screen_size_x(s); xx++)\n\t\t\tgrid_view_set_cell(s->grid, xx, yy, &gc);\n\t}\n\n\tscreen_write_set_cursor(ctx, 0, 0);\n\n\ts->rupper = 0;\n\ts->rlower = screen_size_y(s) - 1;\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\n\tscreen_write_collect_clear(ctx, 0, screen_size_y(s) - 1);\n\ttty_write(tty_cmd_alignmenttest, &ttyctx);\n}\n\n/* Insert nx characters. */\nvoid\nscreen_write_insertcharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tif (s->cx > screen_size_x(s) - 1)\n\t\treturn;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.bg = bg;\n\n\tgrid_view_insert_cells(s->grid, s->cx, s->cy, nx, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_insertcharacter, &ttyctx);\n}\n\n/* Delete nx characters. */\nvoid\nscreen_write_deletecharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tif (s->cx > screen_size_x(s) - 1)\n\t\treturn;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.bg = bg;\n\n\tgrid_view_delete_cells(s->grid, s->cx, s->cy, nx, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_deletecharacter, &ttyctx);\n}\n\n/* Clear nx characters. */\nvoid\nscreen_write_clearcharacter(struct screen_write_ctx *ctx, u_int nx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tif (s->cx > screen_size_x(s) - 1)\n\t\treturn;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.bg = bg;\n\n\tgrid_view_clear(s->grid, s->cx, s->cy, nx, 1, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_clearcharacter, &ttyctx);\n}\n\n/* Insert ny lines. */\nvoid\nscreen_write_insertline(struct screen_write_ctx *ctx, u_int ny, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\tstruct tty_ctx\t ttyctx;\n\n#ifdef ENABLE_SIXEL\n\tu_int\t\t sy = screen_size_y(s);\n#endif\n\n\tif (ny == 0)\n\t\tny = 1;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, sy - s->cy) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tif (s->cy < s->rupper || s->cy > s->rlower) {\n\t\tif (ny > screen_size_y(s) - s->cy)\n\t\t\tny = screen_size_y(s) - s->cy;\n\t\tif (ny == 0)\n\t\t\treturn;\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 1);\n\t\tttyctx.bg = bg;\n\n\t\tgrid_view_insert_lines(gd, s->cy, ny, bg);\n\n\t\tscreen_write_collect_flush(ctx, 0, __func__);\n\t\tttyctx.num = ny;\n\t\ttty_write(tty_cmd_insertline, &ttyctx);\n\t\treturn;\n\t}\n\n\tif (ny > s->rlower + 1 - s->cy)\n\t\tny = s->rlower + 1 - s->cy;\n\tif (ny == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\tif (s->cy < s->rupper || s->cy > s->rlower)\n\t\tgrid_view_insert_lines(gd, s->cy, ny, bg);\n\telse\n\t\tgrid_view_insert_lines_region(gd, s->rlower, s->cy, ny, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\tttyctx.num = ny;\n\ttty_write(tty_cmd_insertline, &ttyctx);\n}\n\n/* Delete ny lines. */\nvoid\nscreen_write_deleteline(struct screen_write_ctx *ctx, u_int ny, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sy = screen_size_y(s);\n\n\tif (ny == 0)\n\t\tny = 1;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, sy - s->cy) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tif (s->cy < s->rupper || s->cy > s->rlower) {\n\t\tif (ny > sy - s->cy)\n\t\t\tny = sy - s->cy;\n\t\tif (ny == 0)\n\t\t\treturn;\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 1);\n\t\tttyctx.bg = bg;\n\n\t\tgrid_view_delete_lines(gd, s->cy, ny, bg);\n\n\t\tscreen_write_collect_flush(ctx, 0, __func__);\n\t\tttyctx.num = ny;\n\t\ttty_write(tty_cmd_deleteline, &ttyctx);\n\t\treturn;\n\t}\n\n\tif (ny > s->rlower + 1 - s->cy)\n\t\tny = s->rlower + 1 - s->cy;\n\tif (ny == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\tif (s->cy < s->rupper || s->cy > s->rlower)\n\t\tgrid_view_delete_lines(gd, s->cy, ny, bg);\n\telse\n\t\tgrid_view_delete_lines_region(gd, s->rlower, s->cy, ny, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tttyctx.num = ny;\n\ttty_write(tty_cmd_deleteline, &ttyctx);\n}\n\n/* Clear line at cursor. */\nvoid\nscreen_write_clearline(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct grid_line\t\t*gl;\n\tu_int\t\t\t\t sx = screen_size_x(s);\n\tstruct screen_write_citem\t*ci = ctx->item;\n\n\tgl = grid_get_line(s->grid, s->grid->hsize + s->cy);\n\tif (gl->cellsize == 0 && COLOUR_DEFAULT(bg))\n\t\treturn;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tgrid_view_clear(s->grid, 0, s->cy, sx, 1, bg);\n\n\tscreen_write_collect_clear(ctx, s->cy, 1);\n\tci->x = 0;\n\tci->used = sx;\n\tci->type = CLEAR;\n\tci->bg = bg;\n\tTAILQ_INSERT_TAIL(&ctx->s->write_list[s->cy].items, ci, entry);\n\tctx->item = screen_write_get_citem();\n}\n\n/* Clear to end of line from cursor. */\nvoid\nscreen_write_clearendofline(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct grid_line\t\t*gl;\n\tu_int\t\t\t\t sx = screen_size_x(s);\n\tstruct screen_write_citem\t*ci = ctx->item, *before;\n\n\tif (s->cx == 0) {\n\t\tscreen_write_clearline(ctx, bg);\n\t\treturn;\n\t}\n\n\tgl = grid_get_line(s->grid, s->grid->hsize + s->cy);\n\tif (s->cx > sx - 1 || (s->cx >= gl->cellsize && COLOUR_DEFAULT(bg)))\n\t\treturn;\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tgrid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1, bg);\n\n \tbefore = screen_write_collect_trim(ctx, s->cy, s->cx, sx - s->cx, NULL);\n\tci->x = s->cx;\n\tci->used = sx - s->cx;\n\tci->type = CLEAR;\n\tci->bg = bg;\n\tif (before == NULL)\n\t\tTAILQ_INSERT_TAIL(&ctx->s->write_list[s->cy].items, ci, entry);\n\telse\n\t\tTAILQ_INSERT_BEFORE(before, ci, entry);\n\tctx->item = screen_write_get_citem();\n}\n\n/* Clear to start of line from cursor. */\nvoid\nscreen_write_clearstartofline(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t\t\t *s = ctx->s;\n\tu_int\t\t\t\t sx = screen_size_x(s);\n\tstruct screen_write_citem\t*ci = ctx->item, *before;\n\n\tif (s->cx >= sx - 1) {\n\t\tscreen_write_clearline(ctx, bg);\n\t\treturn;\n\t}\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tif (s->cx > sx - 1)\n\t\tgrid_view_clear(s->grid, 0, s->cy, sx, 1, bg);\n\telse\n\t\tgrid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, bg);\n\n\tbefore = screen_write_collect_trim(ctx, s->cy, 0, s->cx + 1, NULL);\n\tci->x = 0;\n\tci->used = s->cx + 1;\n\tci->type = CLEAR;\n\tci->bg = bg;\n\tif (before == NULL)\n\t\tTAILQ_INSERT_TAIL(&ctx->s->write_list[s->cy].items, ci, entry);\n\telse\n\t\tTAILQ_INSERT_BEFORE(before, ci, entry);\n\tctx->item = screen_write_get_citem();\n}\n\n/* Move cursor to px,py. */\nvoid\nscreen_write_cursormove(struct screen_write_ctx *ctx, int px, int py,\n    int origin)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (origin && py != -1 && (s->mode & MODE_ORIGIN)) {\n\t\tif ((u_int)py > s->rlower - s->rupper)\n\t\t\tpy = s->rlower;\n\t\telse\n\t\t\tpy += s->rupper;\n\t}\n\n\tif (px != -1 && (u_int)px > screen_size_x(s) - 1)\n\t\tpx = screen_size_x(s) - 1;\n\tif (py != -1 && (u_int)py > screen_size_y(s) - 1)\n\t\tpy = screen_size_y(s) - 1;\n\n\tlog_debug(\"%s: from %u,%u to %u,%u\", __func__, s->cx, s->cy, px, py);\n\tscreen_write_set_cursor(ctx, px, py);\n}\n\n/* Reverse index (up with scroll). */\nvoid\nscreen_write_reverseindex(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (s->cy == s->rupper) {\n#ifdef ENABLE_SIXEL\n\t\tif (image_free_all(s) && ctx->wp != NULL)\n\t\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\t\tgrid_view_scroll_region_down(s->grid, s->rupper, s->rlower, bg);\n\t\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 1);\n\t\tttyctx.bg = bg;\n\n\t\ttty_write(tty_cmd_reverseindex, &ttyctx);\n\t} else if (s->cy > 0)\n\t\tscreen_write_set_cursor(ctx, -1, s->cy - 1);\n\n}\n\n/* Set scroll region. */\nvoid\nscreen_write_scrollregion(struct screen_write_ctx *ctx, u_int rupper,\n    u_int rlower)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (rupper > screen_size_y(s) - 1)\n\t\trupper = screen_size_y(s) - 1;\n\tif (rlower > screen_size_y(s) - 1)\n\t\trlower = screen_size_y(s) - 1;\n\tif (rupper >= rlower)\t/* cannot be one line */\n\t\treturn;\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\t/* Cursor moves to top-left. */\n\tscreen_write_set_cursor(ctx, 0, 0);\n\n\ts->rupper = rupper;\n\ts->rlower = rlower;\n}\n\n/* Line feed. */\nvoid\nscreen_write_linefeed(struct screen_write_ctx *ctx, int wrapped, u_int bg)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_line\t*gl;\n#ifdef ENABLE_SIXEL\n\tint\t\t\t redraw = 0;\n#endif\n\tu_int\t\t\t rupper = s->rupper, rlower = s->rlower;\n\n\tgl = grid_get_line(gd, gd->hsize + s->cy);\n\tif (wrapped)\n\t\tgl->flags |= GRID_LINE_WRAPPED;\n\n\tlog_debug(\"%s: at %u,%u (region %u-%u)\", __func__, s->cx, s->cy,\n\t    rupper, rlower);\n\n\tif (bg != ctx->bg) {\n\t\tscreen_write_collect_flush(ctx, 1, __func__);\n\t\tctx->bg = bg;\n\t}\n\n\tif (s->cy == s->rlower) {\n#ifdef ENABLE_SIXEL\n\t\tif (rlower == screen_size_y(s) - 1)\n\t\t\tredraw = image_scroll_up(s, 1);\n\t\telse\n\t\t\tredraw = image_check_line(s, rupper, rlower - rupper);\n\t\tif (redraw && ctx->wp != NULL)\n\t\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\t\tgrid_view_scroll_region_up(gd, s->rupper, s->rlower, bg);\n\t\tscreen_write_collect_scroll(ctx, bg);\n\t\tctx->scrolled++;\n\t} else if (s->cy < screen_size_y(s) - 1)\n\t\tscreen_write_set_cursor(ctx, -1, s->cy + 1);\n}\n\n/* Scroll up. */\nvoid\nscreen_write_scrollup(struct screen_write_ctx *ctx, u_int lines, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\tu_int\t\t i;\n\n\tif (lines == 0)\n\t\tlines = 1;\n\telse if (lines > s->rlower - s->rupper + 1)\n\t\tlines = s->rlower - s->rupper + 1;\n\n\tif (bg != ctx->bg) {\n\t\tscreen_write_collect_flush(ctx, 1, __func__);\n\t\tctx->bg = bg;\n\t}\n\n#ifdef ENABLE_SIXEL\n\tif (image_scroll_up(s, lines) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tfor (i = 0; i < lines; i++) {\n\t\tgrid_view_scroll_region_up(gd, s->rupper, s->rlower, bg);\n\t\tscreen_write_collect_scroll(ctx, bg);\n\t}\n\tctx->scrolled += lines;\n}\n\n/* Scroll down. */\nvoid\nscreen_write_scrolldown(struct screen_write_ctx *ctx, u_int lines, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t i;\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\tif (lines == 0)\n\t\tlines = 1;\n\telse if (lines > s->rlower - s->rupper + 1)\n\t\tlines = s->rlower - s->rupper + 1;\n\n#ifdef ENABLE_SIXEL\n\tif (image_free_all(s) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tfor (i = 0; i < lines; i++)\n\t\tgrid_view_scroll_region_down(gd, s->rupper, s->rlower, bg);\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tttyctx.num = lines;\n\ttty_write(tty_cmd_scrolldown, &ttyctx);\n}\n\n/* Carriage return (cursor to start of line). */\nvoid\nscreen_write_carriagereturn(struct screen_write_ctx *ctx)\n{\n\tscreen_write_set_cursor(ctx, 0, -1);\n}\n\n/* Clear to end of screen from cursor. */\nvoid\nscreen_write_clearendofscreen(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx = screen_size_x(s), sy = screen_size_y(s);\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, s->cy, sy - s->cy) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\t/* Scroll into history if it is enabled and clearing entire screen. */\n\tif (s->cx == 0 &&\n\t    s->cy == 0 &&\n\t    (gd->flags & GRID_HISTORY) &&\n\t    ctx->wp != NULL &&\n\t    options_get_number(ctx->wp->options, \"scroll-on-clear\"))\n\t\tgrid_view_clear_history(gd, bg);\n\telse {\n\t\tif (s->cx <= sx - 1)\n\t\t\tgrid_view_clear(gd, s->cx, s->cy, sx - s->cx, 1, bg);\n\t\tgrid_view_clear(gd, 0, s->cy + 1, sx, sy - (s->cy + 1), bg);\n\t}\n\n\tscreen_write_collect_clear(ctx, s->cy + 1, sy - (s->cy + 1));\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\ttty_write(tty_cmd_clearendofscreen, &ttyctx);\n}\n\n/* Clear to start of screen. */\nvoid\nscreen_write_clearstartofscreen(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx = screen_size_x(s);\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_line(s, 0, s->cy - 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\tif (s->cy > 0)\n\t\tgrid_view_clear(s->grid, 0, 0, sx, s->cy, bg);\n\tif (s->cx > sx - 1)\n\t\tgrid_view_clear(s->grid, 0, s->cy, sx, 1, bg);\n\telse\n\t\tgrid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1, bg);\n\n\tscreen_write_collect_clear(ctx, 0, s->cy);\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\ttty_write(tty_cmd_clearstartofscreen, &ttyctx);\n}\n\n/* Clear entire screen. */\nvoid\nscreen_write_clearscreen(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx = screen_size_x(s), sy = screen_size_y(s);\n\n#ifdef ENABLE_SIXEL\n\tif (image_free_all(s) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tttyctx.bg = bg;\n\n\t/* Scroll into history if it is enabled. */\n\tif ((s->grid->flags & GRID_HISTORY) &&\n\t    ctx->wp != NULL &&\n\t    options_get_number(ctx->wp->options, \"scroll-on-clear\"))\n\t\tgrid_view_clear_history(s->grid, bg);\n\telse\n\t\tgrid_view_clear(s->grid, 0, 0, sx, sy, bg);\n\n\tscreen_write_collect_clear(ctx, 0, sy);\n\ttty_write(tty_cmd_clearscreen, &ttyctx);\n}\n\n/* Clear entire history. */\nvoid\nscreen_write_clearhistory(struct screen_write_ctx *ctx)\n{\n\tgrid_clear_history(ctx->s->grid);\n}\n\n/* Force a full redraw. */\nvoid\nscreen_write_fullredraw(struct screen_write_ctx *ctx)\n{\n\tstruct tty_ctx\t ttyctx;\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tif (ttyctx.redraw_cb != NULL)\n\t\tttyctx.redraw_cb(&ttyctx);\n}\n\n/* Trim collected items. */\nstatic struct screen_write_citem *\nscreen_write_collect_trim(struct screen_write_ctx *ctx, u_int y, u_int x,\n    u_int used, int *wrapped)\n{\n\tstruct screen_write_cline\t*cl = &ctx->s->write_list[y];\n\tstruct screen_write_citem\t*ci, *ci2, *tmp, *before = NULL;\n\tu_int\t\t\t\t sx = x, ex = x + used - 1;\n\tu_int\t\t\t\t csx, cex;\n\n\tif (TAILQ_EMPTY(&cl->items))\n\t\treturn (NULL);\n\tTAILQ_FOREACH_SAFE(ci, &cl->items, entry, tmp) {\n\t\tcsx = ci->x;\n\t\tcex = ci->x + ci->used - 1;\n\n\t\t/* Item is entirely before. */\n\t\tif (cex < sx) {\n\t\t\tlog_debug(\"%s: %p %u-%u before %u-%u\", __func__, ci,\n\t\t\t    csx, cex, sx, ex);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item is entirely after. */\n\t\tif (csx > ex) {\n\t\t\tlog_debug(\"%s: %p %u-%u after %u-%u\", __func__, ci,\n\t\t\t    csx, cex, sx, ex);\n\t\t\tbefore = ci;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Item is entirely inside. */\n\t\tif (csx >= sx && cex <= ex) {\n\t\t\tlog_debug(\"%s: %p %u-%u inside %u-%u\", __func__, ci,\n\t\t\t    csx, cex, sx, ex);\n\t\t\tTAILQ_REMOVE(&cl->items, ci, entry);\n\t\t\tscreen_write_free_citem(ci);\n\t\t\tif (csx == 0 && ci->wrapped && wrapped != NULL)\n\t\t\t\t*wrapped = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item under the start. */\n\t\tif (csx < sx && cex >= sx && cex <= ex) {\n\t\t\tlog_debug(\"%s: %p %u-%u start %u-%u\", __func__, ci,\n\t\t\t    csx, cex, sx, ex);\n\t\t\tci->used = sx - csx;\n\t\t\tlog_debug(\"%s: %p now %u-%u\", __func__, ci, ci->x,\n\t\t\t    ci->x + ci->used + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item covers the end. */\n\t\tif (cex > ex && csx >= sx && csx <= ex) {\n\t\t\tlog_debug(\"%s: %p %u-%u end %u-%u\", __func__, ci,\n\t\t\t    csx, cex, sx, ex);\n\t\t\tci->x = ex + 1;\n\t\t\tci->used = cex - ex;\n\t\t\tlog_debug(\"%s: %p now %u-%u\", __func__, ci, ci->x,\n\t\t\t    ci->x + ci->used + 1);\n\t\t\tbefore = ci;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Item must cover both sides. */\n\t\tlog_debug(\"%s: %p %u-%u under %u-%u\", __func__, ci,\n\t\t    csx, cex, sx, ex);\n\t\tci2 = screen_write_get_citem();\n\t\tci2->type = ci->type;\n\t\tci2->bg = ci->bg;\n\t\tmemcpy(&ci2->gc, &ci->gc, sizeof ci2->gc);\n\t\tTAILQ_INSERT_AFTER(&cl->items, ci, ci2, entry);\n\n\t\tci->used = sx - csx;\n\t\tci2->x = ex + 1;\n\t\tci2->used = cex - ex;\n\n\t\tlog_debug(\"%s: %p now %u-%u (%p) and %u-%u (%p)\", __func__, ci,\n\t\t    ci->x, ci->x + ci->used - 1, ci, ci2->x,\n\t\t    ci2->x + ci2->used - 1, ci2);\n\t\tbefore = ci2;\n\t\tbreak;\n\t}\n\treturn (before);\n}\n\n/* Clear collected lines. */\nstatic void\nscreen_write_collect_clear(struct screen_write_ctx *ctx, u_int y, u_int n)\n{\n\tstruct screen_write_cline\t*cl;\n\tu_int\t\t\t\t i;\n\n\tfor (i = y; i < y + n; i++) {\n\t\tcl = &ctx->s->write_list[i];\n\t\tTAILQ_CONCAT(&screen_write_citem_freelist, &cl->items, entry);\n\t}\n}\n\n/* Scroll collected lines up. */\nstatic void\nscreen_write_collect_scroll(struct screen_write_ctx *ctx, u_int bg)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct screen_write_cline\t*cl;\n\tu_int\t\t\t\t y;\n\tchar\t\t\t\t*saved;\n\tstruct screen_write_citem\t*ci;\n\n\tlog_debug(\"%s: at %u,%u (region %u-%u)\", __func__, s->cx, s->cy,\n\t    s->rupper, s->rlower);\n\n\tscreen_write_collect_clear(ctx, s->rupper, 1);\n\tsaved = ctx->s->write_list[s->rupper].data;\n\tfor (y = s->rupper; y < s->rlower; y++) {\n\t\tcl = &ctx->s->write_list[y + 1];\n\t\tTAILQ_CONCAT(&ctx->s->write_list[y].items, &cl->items, entry);\n\t\tctx->s->write_list[y].data = cl->data;\n\t}\n\tctx->s->write_list[s->rlower].data = saved;\n\n\tci = screen_write_get_citem();\n\tci->x = 0;\n\tci->used = screen_size_x(s);\n\tci->type = CLEAR;\n\tci->bg = bg;\n\tTAILQ_INSERT_TAIL(&ctx->s->write_list[s->rlower].items, ci, entry);\n}\n\n/* Flush collected lines. */\nstatic void\nscreen_write_collect_flush(struct screen_write_ctx *ctx, int scroll_only,\n    const char *from)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct screen_write_citem\t*ci, *tmp;\n\tstruct screen_write_cline\t*cl;\n\tu_int\t\t\t\t y, cx, cy, last, items = 0;\n\tstruct tty_ctx\t\t\t ttyctx;\n\n\tif (ctx->scrolled != 0) {\n\t\tlog_debug(\"%s: scrolled %u (region %u-%u)\", __func__,\n\t\t    ctx->scrolled, s->rupper, s->rlower);\n\t\tif (ctx->scrolled > s->rlower - s->rupper + 1)\n\t\t\tctx->scrolled = s->rlower - s->rupper + 1;\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 1);\n\t\tttyctx.num = ctx->scrolled;\n\t\tttyctx.bg = ctx->bg;\n\t\ttty_write(tty_cmd_scrollup, &ttyctx);\n\n\t\tif (ctx->wp != NULL)\n\t\t\tctx->wp->flags |= PANE_REDRAWSCROLLBAR;\n\t}\n\tctx->scrolled = 0;\n\tctx->bg = 8;\n\n\tif (scroll_only)\n\t\treturn;\n\n\tcx = s->cx; cy = s->cy;\n\tfor (y = 0; y < screen_size_y(s); y++) {\n\t\tcl = &ctx->s->write_list[y];\n\t\tlast = UINT_MAX;\n\t\tTAILQ_FOREACH_SAFE(ci, &cl->items, entry, tmp) {\n\t\t\tif (last != UINT_MAX && ci->x <= last) {\n\t\t\t\tfatalx(\"collect list not in order: %u <= %u\",\n\t\t\t\t    ci->x, last);\n\t\t\t}\n\t\t\tscreen_write_set_cursor(ctx, ci->x, y);\n\t\t\tif (ci->type == CLEAR) {\n\t\t\t\tscreen_write_initctx(ctx, &ttyctx, 1);\n\t\t\t\tttyctx.bg = ci->bg;\n\t\t\t\tttyctx.num = ci->used;\n\t\t\t\ttty_write(tty_cmd_clearcharacter, &ttyctx);\n\t\t\t} else {\n\t\t\t\tscreen_write_initctx(ctx, &ttyctx, 0);\n\t\t\t\tttyctx.cell = &ci->gc;\n\t\t\t\tttyctx.wrapped = ci->wrapped;\n\t\t\t\tttyctx.ptr = cl->data + ci->x;\n\t\t\t\tttyctx.num = ci->used;\n\t\t\t\ttty_write(tty_cmd_cells, &ttyctx);\n\t\t\t}\n\t\t\titems++;\n\n\t\t\tTAILQ_REMOVE(&cl->items, ci, entry);\n\t\t\tscreen_write_free_citem(ci);\n\t\t\tlast = ci->x;\n\t\t}\n\t}\n\ts->cx = cx; s->cy = cy;\n\n\tlog_debug(\"%s: flushed %u items (%s)\", __func__, items, from);\n}\n\n/* Finish and store collected cells. */\nvoid\nscreen_write_collect_end(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct screen_write_citem\t*ci = ctx->item, *before;\n\tstruct screen_write_cline\t*cl = &s->write_list[s->cy];\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t xx;\n\tint\t\t\t\t wrapped = ci->wrapped;\n\n\tif (ci->used == 0)\n\t\treturn;\n\n\tbefore = screen_write_collect_trim(ctx, s->cy, s->cx, ci->used,\n\t    &wrapped);\n\tci->x = s->cx;\n\tci->wrapped = wrapped;\n\tif (before == NULL)\n\t\tTAILQ_INSERT_TAIL(&cl->items, ci, entry);\n\telse\n\t\tTAILQ_INSERT_BEFORE(before, ci, entry);\n\tctx->item = screen_write_get_citem();\n\n\tlog_debug(\"%s: %u %.*s (at %u,%u)\", __func__, ci->used,\n\t    (int)ci->used, cl->data + ci->x, s->cx, s->cy);\n\n\tif (s->cx != 0) {\n\t\tfor (xx = s->cx; xx > 0; xx--) {\n\t\t\tgrid_view_get_cell(s->grid, xx, s->cy, &gc);\n\t\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tbreak;\n\t\t\tgrid_view_set_cell(s->grid, xx, s->cy,\n\t\t\t    &grid_default_cell);\n\t\t}\n\t\tif (gc.data.width > 1) {\n\t\t\tgrid_view_set_cell(s->grid, xx, s->cy,\n\t\t\t    &grid_default_cell);\n\t\t}\n\t}\n\n#ifdef ENABLE_SIXEL\n\tif (image_check_area(s, s->cx, s->cy, ci->used, 1) && ctx->wp != NULL)\n\t\tctx->wp->flags |= PANE_REDRAW;\n#endif\n\n\tgrid_view_set_cells(s->grid, s->cx, s->cy, &ci->gc, cl->data + ci->x,\n\t    ci->used);\n\tscreen_write_set_cursor(ctx, s->cx + ci->used, -1);\n\n\tfor (xx = s->cx; xx < screen_size_x(s); xx++) {\n\t\tgrid_view_get_cell(s->grid, xx, s->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tgrid_view_set_cell(s->grid, xx, s->cy, &grid_default_cell);\n\t}\n}\n\n/* Write cell data, collecting if necessary. */\nvoid\nscreen_write_collect_add(struct screen_write_ctx *ctx,\n    const struct grid_cell *gc)\n{\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct screen_write_citem\t*ci;\n\tu_int\t\t\t\t sx = screen_size_x(s);\n\tint\t\t\t\t collect;\n\n\t/*\n\t * Don't need to check that the attributes and whatnot are still the\n\t * same - input_parse will end the collection when anything that isn't\n\t * a plain character is encountered.\n\t */\n\n\tcollect = 1;\n\tif (gc->data.width != 1 || gc->data.size != 1 || *gc->data.data >= 0x7f)\n\t\tcollect = 0;\n\telse if (gc->flags & GRID_FLAG_TAB)\n\t\tcollect = 0;\n\telse if (gc->attr & GRID_ATTR_CHARSET)\n\t\tcollect = 0;\n\telse if (~s->mode & MODE_WRAP)\n\t\tcollect = 0;\n\telse if (s->mode & MODE_INSERT)\n\t\tcollect = 0;\n\telse if (s->sel != NULL)\n\t\tcollect = 0;\n\tif (!collect) {\n\t\tscreen_write_collect_end(ctx);\n\t\tscreen_write_collect_flush(ctx, 0, __func__);\n\t\tscreen_write_cell(ctx, gc);\n\t\treturn;\n\t}\n\n\tif (s->cx > sx - 1 || ctx->item->used > sx - 1 - s->cx)\n\t\tscreen_write_collect_end(ctx);\n\tci = ctx->item; /* may have changed */\n\n\tif (s->cx > sx - 1) {\n\t\tlog_debug(\"%s: wrapped at %u,%u\", __func__, s->cx, s->cy);\n\t\tci->wrapped = 1;\n\t\tscreen_write_linefeed(ctx, 1, 8);\n\t\tscreen_write_set_cursor(ctx, 0, -1);\n\t}\n\n\tif (ci->used == 0)\n\t\tmemcpy(&ci->gc, gc, sizeof ci->gc);\n\tif (ctx->s->write_list[s->cy].data == NULL)\n\t\tctx->s->write_list[s->cy].data = xmalloc(screen_size_x(ctx->s));\n\tctx->s->write_list[s->cy].data[s->cx + ci->used++] = gc->data.data[0];\n}\n\n/* Write cell data. */\nvoid\nscreen_write_cell(struct screen_write_ctx *ctx, const struct grid_cell *gc)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tconst struct utf8_data\t*ud = &gc->data;\n\tstruct grid_line\t*gl;\n\tstruct grid_cell_entry\t*gce;\n\tstruct grid_cell \t tmp_gc, now_gc;\n\tstruct tty_ctx\t\t ttyctx;\n\tu_int\t\t\t sx = screen_size_x(s), sy = screen_size_y(s);\n\tu_int\t\t \t width = ud->width, xx, not_wrap;\n\tint\t\t\t selected, skip = 1;\n\n\t/* Ignore padding cells. */\n\tif (gc->flags & GRID_FLAG_PADDING)\n\t\treturn;\n\n\t/* Get the previous cell to check for combining. */\n\tif (screen_write_combine(ctx, gc) != 0)\n\t\treturn;\n\n\t/* Flush any existing scrolling. */\n\tscreen_write_collect_flush(ctx, 1, __func__);\n\n\t/* If this character doesn't fit, ignore it. */\n\tif ((~s->mode & MODE_WRAP) &&\n\t    width > 1 &&\n\t    (width > sx || (s->cx != sx && s->cx > sx - width)))\n\t\treturn;\n\n\t/* If in insert mode, make space for the cells. */\n\tif (s->mode & MODE_INSERT) {\n\t\tgrid_view_insert_cells(s->grid, s->cx, s->cy, width, 8);\n\t\tskip = 0;\n\t}\n\n\t/* Check this will fit on the current line and wrap if not. */\n\tif ((s->mode & MODE_WRAP) && s->cx > sx - width) {\n\t\tlog_debug(\"%s: wrapped at %u,%u\", __func__, s->cx, s->cy);\n\t\tscreen_write_linefeed(ctx, 1, 8);\n\t\tscreen_write_set_cursor(ctx, 0, -1);\n\t\tscreen_write_collect_flush(ctx, 1, __func__);\n\t}\n\n\t/* Sanity check cursor position. */\n\tif (s->cx > sx - width || s->cy > sy - 1)\n\t\treturn;\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\t/* Handle overwriting of UTF-8 characters. */\n\tgl = grid_get_line(s->grid, s->grid->hsize + s->cy);\n\tif (gl->flags & GRID_LINE_EXTENDED) {\n\t\tgrid_view_get_cell(gd, s->cx, s->cy, &now_gc);\n\t\tif (screen_write_overwrite(ctx, &now_gc, width))\n\t\t\tskip = 0;\n\t}\n\n\t/*\n\t * If the new character is UTF-8 wide, fill in padding cells. Have\n\t * already ensured there is enough room.\n\t */\n\tfor (xx = s->cx + 1; xx < s->cx + width; xx++) {\n\t\tlog_debug(\"%s: new padding at %u,%u\", __func__, xx, s->cy);\n\t\tgrid_view_set_padding(gd, xx, s->cy);\n\t\tskip = 0;\n\t}\n\n\t/* If no change, do not draw. */\n\tif (skip) {\n\t\tif (s->cx >= gl->cellsize)\n\t\t\tskip = grid_cells_equal(gc, &grid_default_cell);\n\t\telse {\n\t\t\tgce = &gl->celldata[s->cx];\n\t\t\tif (gce->flags & GRID_FLAG_EXTENDED)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->flags != gce->flags)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->attr != gce->data.attr)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->fg != gce->data.fg)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->bg != gce->data.bg)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->data.width != 1)\n\t\t\t\tskip = 0;\n\t\t\telse if (gc->data.size != 1)\n\t\t\t\tskip = 0;\n\t\t\telse if (gce->data.data != gc->data.data[0])\n\t\t\t\tskip = 0;\n\t\t}\n\t}\n\n\t/* Update the selected flag and set the cell. */\n\tselected = screen_check_selection(s, s->cx, s->cy);\n\tif (selected && (~gc->flags & GRID_FLAG_SELECTED)) {\n\t\tmemcpy(&tmp_gc, gc, sizeof tmp_gc);\n\t\ttmp_gc.flags |= GRID_FLAG_SELECTED;\n\t\tgrid_view_set_cell(gd, s->cx, s->cy, &tmp_gc);\n\t} else if (!selected && (gc->flags & GRID_FLAG_SELECTED)) {\n\t\tmemcpy(&tmp_gc, gc, sizeof tmp_gc);\n\t\ttmp_gc.flags &= ~GRID_FLAG_SELECTED;\n\t\tgrid_view_set_cell(gd, s->cx, s->cy, &tmp_gc);\n\t} else if (!skip)\n\t\tgrid_view_set_cell(gd, s->cx, s->cy, gc);\n\tif (selected)\n\t\tskip = 0;\n\n\t/*\n\t * Move the cursor. If not wrapping, stick at the last character and\n\t * replace it.\n\t */\n\tnot_wrap = !(s->mode & MODE_WRAP);\n\tif (s->cx <= sx - not_wrap - width)\n\t\tscreen_write_set_cursor(ctx, s->cx + width, -1);\n\telse\n\t\tscreen_write_set_cursor(ctx,  sx - not_wrap, -1);\n\n\t/* Create space for character in insert mode. */\n\tif (s->mode & MODE_INSERT) {\n\t\tscreen_write_collect_flush(ctx, 0, __func__);\n\t\tttyctx.num = width;\n\t\ttty_write(tty_cmd_insertcharacter, &ttyctx);\n\t}\n\n\t/* Write to the screen. */\n\tif (!skip) {\n\t\tif (selected) {\n\t\t\tscreen_select_cell(s, &tmp_gc, gc);\n\t\t\tttyctx.cell = &tmp_gc;\n\t\t} else\n\t\t\tttyctx.cell = gc;\n\t\ttty_write(tty_cmd_cell, &ttyctx);\n\t}\n}\n\n/* Combine a UTF-8 zero-width character onto the previous if necessary. */\nstatic int\nscreen_write_combine(struct screen_write_ctx *ctx, const struct grid_cell *gc)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tconst struct utf8_data\t*ud = &gc->data;\n\tu_int\t\t\t n, cx = s->cx, cy = s->cy;\n\tstruct grid_cell\t last;\n\tstruct tty_ctx\t\t ttyctx;\n\tint\t\t\t force_wide = 0, zero_width = 0;\n\n\t/*\n\t * Is this character which makes no sense without being combined? If\n\t * this is true then flag it here and discard the character (return 1)\n\t * if we cannot combine it.\n\t */\n\tif (utf8_is_zwj(ud))\n\t\tzero_width = 1;\n\telse if (utf8_is_vs(ud))\n\t\tzero_width = force_wide = 1;\n\telse if (ud->width == 0)\n\t\tzero_width = 1;\n\n\t/* Cannot combine empty character or at left. */\n\tif (ud->size < 2 || cx == 0)\n\t\treturn (zero_width);\n\tlog_debug(\"%s: character %.*s at %u,%u (width %u)\", __func__,\n\t    (int)ud->size, ud->data, cx, cy, ud->width);\n\n\t/* Find the cell to combine with. */\n\tn = 1;\n\tgrid_view_get_cell(gd, cx - n, cy, &last);\n\tif (cx != 1 && (last.flags & GRID_FLAG_PADDING)) {\n\t\tn = 2;\n\t\tgrid_view_get_cell(gd, cx - n, cy, &last);\n\t}\n\tif (n != last.data.width || (last.flags & GRID_FLAG_PADDING))\n\t\treturn (zero_width);\n\n\t/*\n\t * Check if we need to combine characters. This could be zero width\n\t * (set above), a modifier character (with an existing Unicode\n\t * character) or a previous ZWJ.\n\t */\n\tif (!zero_width) {\n\t\tif (utf8_is_modifier(ud)) {\n\t\t\tif (last.data.size < 2)\n\t\t\t\treturn (0);\n\t\t\tforce_wide = 1;\n\t\t} else if (!utf8_has_zwj(&last.data))\n\t\t\treturn (0);\n\t}\n\n\t/* Check if this combined character would be too long. */\n\tif (last.data.size + ud->size > sizeof last.data.data)\n\t\treturn (0);\n\n\t/* Combining; flush any pending output. */\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\tlog_debug(\"%s: %.*s -> %.*s at %u,%u (offset %u, width %u)\", __func__,\n\t    (int)ud->size, ud->data, (int)last.data.size, last.data.data,\n\t    cx - n, cy, n, last.data.width);\n\n\t/* Append the data. */\n\tmemcpy(last.data.data + last.data.size, ud->data, ud->size);\n\tlast.data.size += ud->size;\n\n\t/* Force the width to 2 for modifiers and variation selector. */\n\tif (last.data.width == 1 && force_wide) {\n\t\tlast.data.width = 2;\n\t\tn = 2;\n\t\tcx++;\n\t} else\n\t\tforce_wide = 0;\n\n\t/* Set the new cell. */\n\tgrid_view_set_cell(gd, cx - n, cy, &last);\n\tif (force_wide)\n\t\tgrid_view_set_padding(gd, cx - 1, cy);\n\n\t/*\n\t * Redraw the combined cell. If forcing the cell to width 2, reset the\n\t * cached cursor position in the tty, since we don't really know\n\t * whether the terminal thought the character was width 1 or width 2\n\t * and what it is going to do now.\n\t */\n\tscreen_write_set_cursor(ctx, cx - n, cy);\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.cell = &last;\n\tttyctx.num = force_wide; /* reset cached cursor position */\n\ttty_write(tty_cmd_cell, &ttyctx);\n\tscreen_write_set_cursor(ctx, cx, cy);\n\n\treturn (1);\n}\n\n/*\n * UTF-8 wide characters are a bit of an annoyance. They take up more than one\n * cell on the screen, so following cells must not be drawn by marking them as\n * padding.\n *\n * So far, so good. The problem is, when overwriting a padding cell, or a UTF-8\n * character, it is necessary to also overwrite any other cells which covered\n * by the same character.\n */\nstatic int\nscreen_write_overwrite(struct screen_write_ctx *ctx, struct grid_cell *gc,\n    u_int width)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_cell\t tmp_gc;\n\tu_int\t\t\t xx;\n\tint\t\t\t done = 0;\n\n\tif (gc->flags & GRID_FLAG_PADDING) {\n\t\t/*\n\t\t * A padding cell, so clear any following and leading padding\n\t\t * cells back to the character. Don't overwrite the current\n\t\t * cell as that happens later anyway.\n\t\t */\n\t\txx = s->cx + 1;\n\t\twhile (--xx > 0) {\n\t\t\tgrid_view_get_cell(gd, xx, s->cy, &tmp_gc);\n\t\t\tif (~tmp_gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tbreak;\n\t\t\tlog_debug(\"%s: padding at %u,%u\", __func__, xx, s->cy);\n\t\t\tgrid_view_set_cell(gd, xx, s->cy, &grid_default_cell);\n\t\t}\n\n\t\t/* Overwrite the character at the start of this padding. */\n\t\tlog_debug(\"%s: character at %u,%u\", __func__, xx, s->cy);\n\t\tgrid_view_set_cell(gd, xx, s->cy, &grid_default_cell);\n\t\tdone = 1;\n\t}\n\n\t/*\n\t * Overwrite any padding cells that belong to any UTF-8 characters\n\t * we'll be overwriting with the current character.\n\t */\n\tif (width != 1 ||\n\t    gc->data.width != 1 ||\n\t    gc->flags & GRID_FLAG_PADDING) {\n\t\txx = s->cx + width - 1;\n\t\twhile (++xx < screen_size_x(s)) {\n\t\t\tgrid_view_get_cell(gd, xx, s->cy, &tmp_gc);\n\t\t\tif (~tmp_gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tbreak;\n\t\t\tlog_debug(\"%s: overwrite at %u,%u\", __func__, xx,\n\t\t\t    s->cy);\n\t\t\tif (gc->flags & GRID_FLAG_TAB) {\n\t\t\t\tmemcpy(&tmp_gc, gc, sizeof tmp_gc);\n\t\t\t\tmemset(tmp_gc.data.data, 0,\n\t\t\t\t    sizeof tmp_gc.data.data);\n\t\t\t\t*tmp_gc.data.data = ' ';\n\t\t\t\ttmp_gc.data.width = tmp_gc.data.size =\n\t\t\t\t    tmp_gc.data.have = 1;\n\t\t\t\tgrid_view_set_cell(gd, xx, s->cy, &tmp_gc);\n\t\t\t} else\n\t\t\t\tgrid_view_set_cell(gd, xx, s->cy,\n\t\t\t\t    &grid_default_cell);\n\t\t\tdone = 1;\n\t\t}\n\t}\n\n\treturn (done);\n}\n\n/* Set external clipboard. */\nvoid\nscreen_write_setselection(struct screen_write_ctx *ctx, const char *flags,\n    u_char *str, u_int len)\n{\n\tstruct tty_ctx\tttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.ptr = str;\n\tttyctx.ptr2 = (void *)flags;\n\tttyctx.num = len;\n\n\ttty_write(tty_cmd_setselection, &ttyctx);\n}\n\n/* Write unmodified string. */\nvoid\nscreen_write_rawstring(struct screen_write_ctx *ctx, u_char *str, u_int len,\n    int allow_invisible_panes)\n{\n\tstruct tty_ctx\tttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.ptr = str;\n\tttyctx.num = len;\n\tttyctx.allow_invisible_panes = allow_invisible_panes;\n\n\ttty_write(tty_cmd_rawstring, &ttyctx);\n}\n\n#ifdef ENABLE_SIXEL\n/* Write a SIXEL image. */\nvoid\nscreen_write_sixelimage(struct screen_write_ctx *ctx, struct sixel_image *si,\n    u_int bg)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct tty_ctx\t\t ttyctx;\n\tu_int\t\t\t x, y, sx, sy, cx = s->cx, cy = s->cy, i, lines;\n\tstruct sixel_image\t*new;\n\n\tsixel_size_in_cells(si, &x, &y);\n\tif (x > screen_size_x(s) || y > screen_size_y(s)) {\n\t\tif (x > screen_size_x(s) - cx)\n\t\t\tsx = screen_size_x(s) - cx;\n\t\telse\n\t\t\tsx = x;\n\t\tif (y > screen_size_y(s) - 1)\n\t\t\tsy = screen_size_y(s) - 1;\n\t\telse\n\t\t\tsy = y;\n\t\tnew = sixel_scale(si, 0, 0, 0, y - sy, sx, sy, 1);\n\t\tsixel_free(si);\n\t\tsi = new;\n\n\t\t/* Bail out if the image cannot be scaled. */\n\t\tif (si == NULL)\n\t\t\treturn;\n\t\tsixel_size_in_cells(si, &x, &y);\n\t}\n\n\tsy = screen_size_y(s) - cy;\n\tif (sy < y) {\n\t\tlines = y - sy + 1;\n\t\tif (image_scroll_up(s, lines) && ctx->wp != NULL)\n\t\t\tctx->wp->flags |= PANE_REDRAW;\n\t\tfor (i = 0; i < lines; i++) {\n\t\t\tgrid_view_scroll_region_up(gd, 0, screen_size_y(s) - 1,\n\t\t\t    bg);\n\t\t\tscreen_write_collect_scroll(ctx, bg);\n\t\t}\n\t\tctx->scrolled += lines;\n\t\tif (lines > cy)\n\t\t\tscreen_write_cursormove(ctx, -1, 0, 0);\n\t\telse\n\t\t\tscreen_write_cursormove(ctx, -1, cy - lines, 0);\n\t}\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.ptr = image_store(s, si);\n\n\ttty_write(tty_cmd_sixelimage, &ttyctx);\n\n\tscreen_write_cursormove(ctx, 0, cy + y, 0);\n}\n#endif\n\n/* Turn alternate screen on. */\nvoid\nscreen_write_alternateon(struct screen_write_ctx *ctx, struct grid_cell *gc,\n    int cursor)\n{\n\tstruct tty_ctx\t\t ttyctx;\n\tstruct window_pane\t*wp = ctx->wp;\n\n\tif (wp != NULL && !options_get_number(wp->options, \"alternate-screen\"))\n\t\treturn;\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tscreen_alternate_on(ctx->s, gc, cursor);\n\n\tif (wp != NULL)\n\t\tlayout_fix_panes(wp->window, NULL);\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tif (ttyctx.redraw_cb != NULL)\n\t\tttyctx.redraw_cb(&ttyctx);\n}\n\n/* Turn alternate screen off. */\nvoid\nscreen_write_alternateoff(struct screen_write_ctx *ctx, struct grid_cell *gc,\n    int cursor)\n{\n\tstruct tty_ctx\t\t ttyctx;\n\tstruct window_pane\t*wp = ctx->wp;\n\n\tif (wp != NULL && !options_get_number(wp->options, \"alternate-screen\"))\n\t\treturn;\n\n\tscreen_write_collect_flush(ctx, 0, __func__);\n\tscreen_alternate_off(ctx->s, gc, cursor);\n\n\tif (wp != NULL)\n\t\tlayout_fix_panes(wp->window, NULL);\n\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\tif (ttyctx.redraw_cb != NULL)\n\t\tttyctx.redraw_cb(&ttyctx);\n}\n"
        },
        {
          "name": "screen.c",
          "type": "blob",
          "size": 16.583984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/* Selected area in screen. */\nstruct screen_sel {\n\tint\t\t hidden;\n\tint\t\t rectangle;\n\tint\t\t modekeys;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t ex;\n\tu_int\t\t ey;\n\n\tstruct grid_cell cell;\n};\n\n/* Entry on title stack. */\nstruct screen_title_entry {\n\tchar\t\t\t\t*text;\n\n\tTAILQ_ENTRY(screen_title_entry)\t entry;\n};\nTAILQ_HEAD(screen_titles, screen_title_entry);\n\nstatic void\tscreen_resize_y(struct screen *, u_int, int, u_int *);\nstatic void\tscreen_reflow(struct screen *, u_int, u_int *, u_int *, int);\n\n/* Free titles stack. */\nstatic void\nscreen_free_titles(struct screen *s)\n{\n\tstruct screen_title_entry\t*title_entry;\n\n\tif (s->titles == NULL)\n\t\treturn;\n\n\twhile ((title_entry = TAILQ_FIRST(s->titles)) != NULL) {\n\t\tTAILQ_REMOVE(s->titles, title_entry, entry);\n\t\tfree(title_entry->text);\n\t\tfree(title_entry);\n\t}\n\n\tfree(s->titles);\n\ts->titles = NULL;\n}\n\n/* Create a new screen. */\nvoid\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n}\n\n/* Reinitialise screen. */\nvoid\nscreen_reinit(struct screen *s)\n{\n\ts->cx = 0;\n\ts->cy = 0;\n\n\ts->rupper = 0;\n\ts->rlower = screen_size_y(s) - 1;\n\n\ts->mode = MODE_CURSOR|MODE_WRAP|(s->mode & MODE_CRLF);\n\n\tif (options_get_number(global_options, \"extended-keys\") == 2)\n\t\ts->mode = (s->mode & ~EXTENDED_KEY_MODES)|MODE_KEYS_EXTENDED;\n\n\tif (SCREEN_IS_ALTERNATE(s))\n\t\tscreen_alternate_off(s, NULL, 0);\n\ts->saved_cx = UINT_MAX;\n\ts->saved_cy = UINT_MAX;\n\n\tscreen_reset_tabs(s);\n\n\tgrid_clear_lines(s->grid, s->grid->hsize, s->grid->sy, 8);\n\n\tscreen_clear_selection(s);\n\tscreen_free_titles(s);\n\n#ifdef ENABLE_SIXEL\n\timage_free_all(s);\n#endif\n\n\tscreen_reset_hyperlinks(s);\n}\n\n/* Reset hyperlinks of a screen. */\nvoid\nscreen_reset_hyperlinks(struct screen *s)\n{\n\tif (s->hyperlinks == NULL)\n\t\ts->hyperlinks = hyperlinks_init();\n\telse\n\t\thyperlinks_reset(s->hyperlinks);\n}\n\n/* Destroy a screen. */\nvoid\nscreen_free(struct screen *s)\n{\n\tfree(s->sel);\n\tfree(s->tabs);\n\tfree(s->path);\n\tfree(s->title);\n\n\tif (s->write_list != NULL)\n\t\tscreen_write_free_list(s);\n\n\tif (SCREEN_IS_ALTERNATE(s))\n\t\tgrid_destroy(s->saved_grid);\n\tgrid_destroy(s->grid);\n\n\tif (s->hyperlinks != NULL)\n\t\thyperlinks_free(s->hyperlinks);\n\tscreen_free_titles(s);\n\n#ifdef ENABLE_SIXEL\n\timage_free_all(s);\n#endif\n}\n\n/* Reset tabs to default, eight spaces apart. */\nvoid\nscreen_reset_tabs(struct screen *s)\n{\n\tu_int\ti;\n\n\tfree(s->tabs);\n\n\tif ((s->tabs = bit_alloc(screen_size_x(s))) == NULL)\n\t\tfatal(\"bit_alloc failed\");\n\tfor (i = 8; i < screen_size_x(s); i += 8)\n\t\tbit_set(s->tabs, i);\n}\n\n/* Set default cursor style and colour from options. */\nvoid\nscreen_set_default_cursor(struct screen *s, struct options *oo)\n{\n\tint\tc;\n\n\tc = options_get_number(oo, \"cursor-colour\");\n\ts->default_ccolour = c;\n\n\tc = options_get_number(oo, \"cursor-style\");\n\ts->default_mode = 0;\n\tscreen_set_cursor_style(c, &s->default_cstyle, &s->default_mode);\n}\n\n/* Set screen cursor style and mode. */\nvoid\nscreen_set_cursor_style(u_int style, enum screen_cursor_style *cstyle,\n    int *mode)\n{\n\tswitch (style) {\n\tcase 0:\n\t\t*cstyle = SCREEN_CURSOR_DEFAULT;\n\t\tbreak;\n\tcase 1:\n\t\t*cstyle = SCREEN_CURSOR_BLOCK;\n\t\t*mode |= MODE_CURSOR_BLINKING;\n\t\tbreak;\n\tcase 2:\n\t\t*cstyle = SCREEN_CURSOR_BLOCK;\n\t\t*mode &= ~MODE_CURSOR_BLINKING;\n\t\tbreak;\n\tcase 3:\n\t\t*cstyle = SCREEN_CURSOR_UNDERLINE;\n\t\t*mode |= MODE_CURSOR_BLINKING;\n\t\tbreak;\n\tcase 4:\n\t\t*cstyle = SCREEN_CURSOR_UNDERLINE;\n\t\t*mode &= ~MODE_CURSOR_BLINKING;\n\t\tbreak;\n\tcase 5:\n\t\t*cstyle = SCREEN_CURSOR_BAR;\n\t\t*mode |= MODE_CURSOR_BLINKING;\n\t\tbreak;\n\tcase 6:\n\t\t*cstyle = SCREEN_CURSOR_BAR;\n\t\t*mode &= ~MODE_CURSOR_BLINKING;\n\t\tbreak;\n\t}\n}\n\n/* Set screen cursor colour. */\nvoid\nscreen_set_cursor_colour(struct screen *s, int colour)\n{\n\ts->ccolour = colour;\n}\n\n/* Set screen title. */\nint\nscreen_set_title(struct screen *s, const char *title)\n{\n\tif (!utf8_isvalid(title))\n\t\treturn (0);\n\tfree(s->title);\n\ts->title = xstrdup(title);\n\treturn (1);\n}\n\n/* Set screen path. */\nvoid\nscreen_set_path(struct screen *s, const char *path)\n{\n\tfree(s->path);\n\tutf8_stravis(&s->path, path, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL);\n}\n\n/* Push the current title onto the stack. */\nvoid\nscreen_push_title(struct screen *s)\n{\n\tstruct screen_title_entry *title_entry;\n\n\tif (s->titles == NULL) {\n\t\ts->titles = xmalloc(sizeof *s->titles);\n\t\tTAILQ_INIT(s->titles);\n\t}\n\ttitle_entry = xmalloc(sizeof *title_entry);\n\ttitle_entry->text = xstrdup(s->title);\n\tTAILQ_INSERT_HEAD(s->titles, title_entry, entry);\n}\n\n/*\n * Pop a title from the stack and set it as the screen title. If the stack is\n * empty, do nothing.\n */\nvoid\nscreen_pop_title(struct screen *s)\n{\n\tstruct screen_title_entry *title_entry;\n\n\tif (s->titles == NULL)\n\t\treturn;\n\n\ttitle_entry = TAILQ_FIRST(s->titles);\n\tif (title_entry != NULL) {\n\t\tscreen_set_title(s, title_entry->text);\n\n\t\tTAILQ_REMOVE(s->titles, title_entry, entry);\n\t\tfree(title_entry->text);\n\t\tfree(title_entry);\n\t}\n}\n\n/* Resize screen with options. */\nvoid\nscreen_resize_cursor(struct screen *s, u_int sx, u_int sy, int reflow,\n    int eat_empty, int cursor)\n{\n\tu_int\tcx = s->cx, cy = s->grid->hsize + s->cy;\n\n\tif (s->write_list != NULL)\n\t\tscreen_write_free_list(s);\n\n\tlog_debug(\"%s: new size %ux%u, now %ux%u (cursor %u,%u = %u,%u)\",\n\t    __func__, sx, sy, screen_size_x(s), screen_size_y(s), s->cx, s->cy,\n\t    cx, cy);\n\n\tif (sx < 1)\n\t\tsx = 1;\n\tif (sy < 1)\n\t\tsy = 1;\n\n\tif (sx != screen_size_x(s)) {\n\t\ts->grid->sx = sx;\n\t\tscreen_reset_tabs(s);\n\t} else\n\t\treflow = 0;\n\n\tif (sy != screen_size_y(s))\n\t\tscreen_resize_y(s, sy, eat_empty, &cy);\n\n#ifdef ENABLE_SIXEL\n\timage_free_all(s);\n#endif\n\n\tif (reflow)\n\t\tscreen_reflow(s, sx, &cx, &cy, cursor);\n\n\tif (cy >= s->grid->hsize) {\n\t\ts->cx = cx;\n\t\ts->cy = cy - s->grid->hsize;\n\t} else {\n\t\ts->cx = 0;\n\t\ts->cy = 0;\n\t}\n\n\tlog_debug(\"%s: cursor finished at %u,%u = %u,%u\", __func__, s->cx,\n\t    s->cy, cx, cy);\n\n\tif (s->write_list != NULL)\n\t\tscreen_write_make_list(s);\n}\n\n/* Resize screen. */\nvoid\nscreen_resize(struct screen *s, u_int sx, u_int sy, int reflow)\n{\n\tscreen_resize_cursor(s, sx, sy, reflow, 1, 1);\n}\n\nstatic void\nscreen_resize_y(struct screen *s, u_int sy, int eat_empty, u_int *cy)\n{\n\tstruct grid\t*gd = s->grid;\n\tu_int\t\t needed, available, oldy, i;\n\n\tif (sy == 0)\n\t\tfatalx(\"zero size\");\n\toldy = screen_size_y(s);\n\n\t/*\n\t * When resizing:\n\t *\n\t * If the height is decreasing, delete lines from the bottom until\n\t * hitting the cursor, then push lines from the top into the history.\n\t *\n\t * When increasing, pull as many lines as possible from scrolled\n\t * history (not explicitly cleared from view) to the top, then fill the\n\t * remaining with blanks at the bottom.\n\t */\n\n\t/* Size decreasing. */\n\tif (sy < oldy) {\n\t\tneeded = oldy - sy;\n\n\t\t/* Delete as many lines as possible from the bottom. */\n\t\tif (eat_empty) {\n\t\t\tavailable = oldy - 1 - s->cy;\n\t\t\tif (available > 0) {\n\t\t\t\tif (available > needed)\n\t\t\t\t\tavailable = needed;\n\t\t\t\tgrid_view_delete_lines(gd, oldy - available,\n\t\t\t\t    available, 8);\n\t\t\t}\n\t\t\tneeded -= available;\n\t\t}\n\n\t\t/*\n\t\t * Now just increase the history size, if possible, to take\n\t\t * over the lines which are left. If history is off, delete\n\t\t * lines from the top.\n\t\t */\n\t\tavailable = s->cy;\n\t\tif (gd->flags & GRID_HISTORY) {\n\t\t\tgd->hscrolled += needed;\n\t\t\tgd->hsize += needed;\n\t\t} else if (needed > 0 && available > 0) {\n\t\t\tif (available > needed)\n\t\t\t\tavailable = needed;\n\t\t\tgrid_view_delete_lines(gd, 0, available, 8);\n\t\t\t(*cy) -= available;\n\t\t}\n\t}\n\n\t/* Resize line array. */\n\tgrid_adjust_lines(gd, gd->hsize + sy);\n\n\t/* Size increasing. */\n\tif (sy > oldy) {\n\t\tneeded = sy - oldy;\n\n\t\t/*\n\t\t * Try to pull as much as possible out of scrolled history, if\n\t\t * it is enabled.\n\t\t */\n\t\tavailable = gd->hscrolled;\n\t\tif (gd->flags & GRID_HISTORY && available > 0) {\n\t\t\tif (available > needed)\n\t\t\t\tavailable = needed;\n\t\t\tgd->hscrolled -= available;\n\t\t\tgd->hsize -= available;\n\t\t} else\n\t\t\tavailable = 0;\n\t\tneeded -= available;\n\n\t\t/* Then fill the rest in with blanks. */\n\t\tfor (i = gd->hsize + sy - needed; i < gd->hsize + sy; i++)\n\t\t\tgrid_empty_line(gd, i, 8);\n\t}\n\n\t/* Set the new size, and reset the scroll region. */\n\tgd->sy = sy;\n\ts->rupper = 0;\n\ts->rlower = screen_size_y(s) - 1;\n}\n\n/* Set selection. */\nvoid\nscreen_set_selection(struct screen *s, u_int sx, u_int sy,\n    u_int ex, u_int ey, u_int rectangle, int modekeys, struct grid_cell *gc)\n{\n\tif (s->sel == NULL)\n\t\ts->sel = xcalloc(1, sizeof *s->sel);\n\n\tmemcpy(&s->sel->cell, gc, sizeof s->sel->cell);\n\ts->sel->hidden = 0;\n\ts->sel->rectangle = rectangle;\n\ts->sel->modekeys = modekeys;\n\n\ts->sel->sx = sx;\n\ts->sel->sy = sy;\n\ts->sel->ex = ex;\n\ts->sel->ey = ey;\n}\n\n/* Clear selection. */\nvoid\nscreen_clear_selection(struct screen *s)\n{\n\tfree(s->sel);\n\ts->sel = NULL;\n}\n\n/* Hide selection. */\nvoid\nscreen_hide_selection(struct screen *s)\n{\n\tif (s->sel != NULL)\n\t\ts->sel->hidden = 1;\n}\n\n/* Check if cell in selection. */\nint\nscreen_check_selection(struct screen *s, u_int px, u_int py)\n{\n\tstruct screen_sel\t*sel = s->sel;\n\tu_int\t\t\t xx;\n\n\tif (sel == NULL || sel->hidden)\n\t\treturn (0);\n\n\tif (sel->rectangle) {\n\t\tif (sel->sy < sel->ey) {\n\t\t\t/* start line < end line -- downward selection. */\n\t\t\tif (py < sel->sy || py > sel->ey)\n\t\t\t\treturn (0);\n\t\t} else if (sel->sy > sel->ey) {\n\t\t\t/* start line > end line -- upward selection. */\n\t\t\tif (py > sel->sy || py < sel->ey)\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* starting line == ending line. */\n\t\t\tif (py != sel->sy)\n\t\t\t\treturn (0);\n\t\t}\n\n\t\t/*\n\t\t * Need to include the selection start row, but not the cursor\n\t\t * row, which means the selection changes depending on which\n\t\t * one is on the left.\n\t\t */\n\t\tif (sel->ex < sel->sx) {\n\t\t\t/* Cursor (ex) is on the left. */\n\t\t\tif (px < sel->ex)\n\t\t\t\treturn (0);\n\n\t\t\tif (px > sel->sx)\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* Selection start (sx) is on the left. */\n\t\t\tif (px < sel->sx)\n\t\t\t\treturn (0);\n\n\t\t\tif (px > sel->ex)\n\t\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Like emacs, keep the top-left-most character, and drop the\n\t\t * bottom-right-most, regardless of copy direction.\n\t\t */\n\t\tif (sel->sy < sel->ey) {\n\t\t\t/* starting line < ending line -- downward selection. */\n\t\t\tif (py < sel->sy || py > sel->ey)\n\t\t\t\treturn (0);\n\n\t\t\tif (py == sel->sy && px < sel->sx)\n\t\t\t\treturn (0);\n\n\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\txx = (sel->ex == 0 ? 0 : sel->ex - 1);\n\t\t\telse\n\t\t\t\txx = sel->ex;\n\t\t\tif (py == sel->ey && px > xx)\n\t\t\t\treturn (0);\n\t\t} else if (sel->sy > sel->ey) {\n\t\t\t/* starting line > ending line -- upward selection. */\n\t\t\tif (py > sel->sy || py < sel->ey)\n\t\t\t\treturn (0);\n\n\t\t\tif (py == sel->ey && px < sel->ex)\n\t\t\t\treturn (0);\n\n\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\txx = sel->sx - 1;\n\t\t\telse\n\t\t\t\txx = sel->sx;\n\t\t\tif (py == sel->sy && (sel->sx == 0 || px > xx))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* starting line == ending line. */\n\t\t\tif (py != sel->sy)\n\t\t\t\treturn (0);\n\n\t\t\tif (sel->ex < sel->sx) {\n\t\t\t\t/* cursor (ex) is on the left */\n\t\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\t\txx = sel->sx - 1;\n\t\t\t\telse\n\t\t\t\t\txx = sel->sx;\n\t\t\t\tif (px > xx || px < sel->ex)\n\t\t\t\t\treturn (0);\n\t\t\t} else {\n\t\t\t\t/* selection start (sx) is on the left */\n\t\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\t\txx = (sel->ex == 0 ? 0 : sel->ex - 1);\n\t\t\t\telse\n\t\t\t\t\txx = sel->ex;\n\t\t\t\tif (px < sel->sx || px > xx)\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n/* Get selected grid cell. */\nvoid\nscreen_select_cell(struct screen *s, struct grid_cell *dst,\n    const struct grid_cell *src)\n{\n\tif (s->sel == NULL || s->sel->hidden)\n\t\treturn;\n\n\tmemcpy(dst, &s->sel->cell, sizeof *dst);\n\n\tutf8_copy(&dst->data, &src->data);\n\tdst->attr = dst->attr & ~GRID_ATTR_CHARSET;\n\tdst->attr |= src->attr & GRID_ATTR_CHARSET;\n\tdst->flags = src->flags;\n}\n\n/* Reflow wrapped lines. */\nstatic void\nscreen_reflow(struct screen *s, u_int new_x, u_int *cx, u_int *cy, int cursor)\n{\n\tu_int\twx, wy;\n\n\tif (cursor) {\n\t\tgrid_wrap_position(s->grid, *cx, *cy, &wx, &wy);\n\t\tlog_debug(\"%s: cursor %u,%u is %u,%u\", __func__, *cx, *cy, wx,\n\t\t    wy);\n\t}\n\n\tgrid_reflow(s->grid, new_x);\n\n\tif (cursor) {\n\t\tgrid_unwrap_position(s->grid, cx, cy, wx, wy);\n\t\tlog_debug(\"%s: new cursor is %u,%u\", __func__, *cx, *cy);\n\t}\n\telse {\n\t\t*cx = 0;\n\t\t*cy = s->grid->hsize;\n\t}\n}\n\n/*\n * Enter alternative screen mode. A copy of the visible screen is saved and the\n * history is not updated.\n */\nvoid\nscreen_alternate_on(struct screen *s, struct grid_cell *gc, int cursor)\n{\n\tu_int\tsx, sy;\n\n\tif (SCREEN_IS_ALTERNATE(s))\n\t\treturn;\n\tsx = screen_size_x(s);\n\tsy = screen_size_y(s);\n\n\ts->saved_grid = grid_create(sx, sy, 0);\n\tgrid_duplicate_lines(s->saved_grid, 0, s->grid, screen_hsize(s), sy);\n\tif (cursor) {\n\t\ts->saved_cx = s->cx;\n\t\ts->saved_cy = s->cy;\n\t}\n\tmemcpy(&s->saved_cell, gc, sizeof s->saved_cell);\n\n\tgrid_view_clear(s->grid, 0, 0, sx, sy, 8);\n\n\ts->saved_flags = s->grid->flags;\n\ts->grid->flags &= ~GRID_HISTORY;\n}\n\n/* Exit alternate screen mode and restore the copied grid. */\nvoid\nscreen_alternate_off(struct screen *s, struct grid_cell *gc, int cursor)\n{\n\tu_int\tsx = screen_size_x(s), sy = screen_size_y(s);\n\n\t/*\n\t * If the current size is different, temporarily resize to the old size\n\t * before copying back.\n\t */\n\tif (SCREEN_IS_ALTERNATE(s))\n\t\tscreen_resize(s, s->saved_grid->sx, s->saved_grid->sy, 0);\n\n\t/*\n\t * Restore the cursor position and cell. This happens even if not\n\t * currently in the alternate screen.\n\t */\n\tif (cursor && s->saved_cx != UINT_MAX && s->saved_cy != UINT_MAX) {\n\t\ts->cx = s->saved_cx;\n\t\ts->cy = s->saved_cy;\n\t\tif (gc != NULL)\n\t\t\tmemcpy(gc, &s->saved_cell, sizeof *gc);\n\t}\n\n\t/* If not in the alternate screen, do nothing more. */\n\tif (!SCREEN_IS_ALTERNATE(s)) {\n\t\tif (s->cx > screen_size_x(s) - 1)\n\t\t\ts->cx = screen_size_x(s) - 1;\n\t\tif (s->cy > screen_size_y(s) - 1)\n\t\t\ts->cy = screen_size_y(s) - 1;\n\t\treturn;\n\t}\n\n\t/* Restore the saved grid. */\n\tgrid_duplicate_lines(s->grid, screen_hsize(s), s->saved_grid, 0,\n\t    s->saved_grid->sy);\n\n\t/*\n\t * Turn history back on (so resize can use it) and then resize back to\n\t * the current size.\n\t */\n\tif (s->saved_flags & GRID_HISTORY)\n\t\ts->grid->flags |= GRID_HISTORY;\n\tscreen_resize(s, sx, sy, 1);\n\n\tgrid_destroy(s->saved_grid);\n\ts->saved_grid = NULL;\n\n\tif (s->cx > screen_size_x(s) - 1)\n\t\ts->cx = screen_size_x(s) - 1;\n\tif (s->cy > screen_size_y(s) - 1)\n\t\ts->cy = screen_size_y(s) - 1;\n}\n\n/* Get mode as a string. */\nconst char *\nscreen_mode_to_string(int mode)\n{\n\tstatic char\ttmp[1024];\n\n\tif (mode == 0)\n\t\treturn (\"NONE\");\n\tif (mode == ALL_MODES)\n\t\treturn (\"ALL\");\n\n\t*tmp = '\\0';\n\tif (mode & MODE_CURSOR)\n\t\tstrlcat(tmp, \"CURSOR,\", sizeof tmp);\n\tif (mode & MODE_INSERT)\n\t\tstrlcat(tmp, \"INSERT,\", sizeof tmp);\n\tif (mode & MODE_KCURSOR)\n\t\tstrlcat(tmp, \"KCURSOR,\", sizeof tmp);\n\tif (mode & MODE_KKEYPAD)\n\t\tstrlcat(tmp, \"KKEYPAD,\", sizeof tmp);\n\tif (mode & MODE_WRAP)\n\t\tstrlcat(tmp, \"WRAP,\", sizeof tmp);\n\tif (mode & MODE_MOUSE_STANDARD)\n\t\tstrlcat(tmp, \"MOUSE_STANDARD,\", sizeof tmp);\n\tif (mode & MODE_MOUSE_BUTTON)\n\t\tstrlcat(tmp, \"MOUSE_BUTTON,\", sizeof tmp);\n\tif (mode & MODE_CURSOR_BLINKING)\n\t\tstrlcat(tmp, \"CURSOR_BLINKING,\", sizeof tmp);\n\tif (mode & MODE_CURSOR_VERY_VISIBLE)\n\t\tstrlcat(tmp, \"CURSOR_VERY_VISIBLE,\", sizeof tmp);\n\tif (mode & MODE_MOUSE_UTF8)\n\t\tstrlcat(tmp, \"MOUSE_UTF8,\", sizeof tmp);\n\tif (mode & MODE_MOUSE_SGR)\n\t\tstrlcat(tmp, \"MOUSE_SGR,\", sizeof tmp);\n\tif (mode & MODE_BRACKETPASTE)\n\t\tstrlcat(tmp, \"BRACKETPASTE,\", sizeof tmp);\n\tif (mode & MODE_FOCUSON)\n\t\tstrlcat(tmp, \"FOCUSON,\", sizeof tmp);\n\tif (mode & MODE_MOUSE_ALL)\n\t\tstrlcat(tmp, \"MOUSE_ALL,\", sizeof tmp);\n\tif (mode & MODE_ORIGIN)\n\t\tstrlcat(tmp, \"ORIGIN,\", sizeof tmp);\n\tif (mode & MODE_CRLF)\n\t\tstrlcat(tmp, \"CRLF,\", sizeof tmp);\n\tif (mode & MODE_KEYS_EXTENDED)\n\t\tstrlcat(tmp, \"KEYS_EXTENDED,\", sizeof tmp);\n\tif (mode & MODE_KEYS_EXTENDED_2)\n\t\tstrlcat(tmp, \"KEYS_EXTENDED_2,\", sizeof tmp);\n\ttmp[strlen(tmp) - 1] = '\\0';\n\treturn (tmp);\n}\n"
        },
        {
          "name": "server-acl.c",
          "type": "blob",
          "size": 4.1171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2021 Holland Schutte, Jayson Morberg\n * Copyright (c) 2021 Dallas Lyons <dallasdlyons@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n\n#include <ctype.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct server_acl_user {\n\tuid_t\t\t\t\tuid;\n\n\tint\t\t\t\tflags;\n#define SERVER_ACL_READONLY 0x1\n\n\tRB_ENTRY(server_acl_user)\tentry;\n};\n\nstatic int\nserver_acl_cmp(struct server_acl_user *user1, struct server_acl_user *user2)\n{\n\tif (user1->uid < user2->uid)\n\t\treturn (-1);\n\treturn (user1->uid > user2->uid);\n}\n\nRB_HEAD(server_acl_entries, server_acl_user) server_acl_entries;\nRB_GENERATE_STATIC(server_acl_entries, server_acl_user, entry, server_acl_cmp);\n\n/* Initialize server_acl tree. */\nvoid\nserver_acl_init(void)\n{\n\tRB_INIT(&server_acl_entries);\n\n\tif (getuid() != 0)\n\t\tserver_acl_user_allow(0);\n\tserver_acl_user_allow(getuid());\n}\n\n/* Find user entry. */\nstruct server_acl_user*\nserver_acl_user_find(uid_t uid)\n{\n\tstruct server_acl_user\tfind = { .uid = uid };\n\n\treturn (RB_FIND(server_acl_entries, &server_acl_entries, &find));\n}\n\n/* Display the tree. */\nvoid\nserver_acl_display(struct cmdq_item *item)\n{\n\tstruct server_acl_user\t*loop;\n\tstruct passwd\t\t*pw;\n\tconst char\t\t*name;\n\n\tRB_FOREACH(loop, server_acl_entries, &server_acl_entries) {\n\t\tif (loop->uid == 0)\n\t\t\tcontinue;\n\t\tif ((pw = getpwuid(loop->uid)) != NULL)\n\t\t\tname = pw->pw_name;\n\t\telse\n\t\t\tname = \"unknown\";\n\t\tif (loop->flags == SERVER_ACL_READONLY)\n\t\t\tcmdq_print(item, \"%s (R)\", name);\n\t\telse\n\t\t\tcmdq_print(item, \"%s (W)\", name);\n\t}\n}\n\n/* Allow a user. */\nvoid\nserver_acl_user_allow(uid_t uid)\n{\n\tstruct server_acl_user\t*user;\n\n\tuser = server_acl_user_find(uid);\n\tif (user == NULL) {\n\t\tuser = xcalloc(1, sizeof *user);\n\t\tuser->uid = uid;\n\t\tRB_INSERT(server_acl_entries, &server_acl_entries, user);\n\t}\n}\n\n/* Deny a user (remove from the tree). */\nvoid\nserver_acl_user_deny(uid_t uid)\n{\n\tstruct server_acl_user\t*user;\n\n\tuser = server_acl_user_find(uid);\n\tif (user != NULL) {\n\t\tRB_REMOVE(server_acl_entries, &server_acl_entries, user);\n\t\tfree(user);\n\t}\n}\n\n/* Allow this user write access. */\nvoid\nserver_acl_user_allow_write(uid_t uid)\n{\n\tstruct server_acl_user\t*user;\n\tstruct client\t\t*c;\n\n\tuser = server_acl_user_find(uid);\n\tif (user == NULL)\n\t\treturn;\n\tuser->flags &= ~SERVER_ACL_READONLY;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tuid = proc_get_peer_uid(c->peer);\n\t\tif (uid != (uid_t)-1 && uid == user->uid)\n\t\t\tc->flags &= ~CLIENT_READONLY;\n\t}\n}\n\n/* Deny this user write access. */\nvoid\nserver_acl_user_deny_write(uid_t uid)\n{\n\tstruct server_acl_user\t*user;\n\tstruct client\t\t*c;\n\n\tuser = server_acl_user_find(uid);\n\tif (user == NULL)\n\t\treturn;\n\tuser->flags |= SERVER_ACL_READONLY;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tuid = proc_get_peer_uid(c->peer);\n\t\tif (uid != (uid_t)-1 && uid == user->uid)\n\t\t\tc->flags |= CLIENT_READONLY;\n\t}\n}\n\n/*\n * Check if the client's UID exists in the ACL list and if so, set as read only\n * if needed. Return false if the user does not exist.\n */\nint\nserver_acl_join(struct client *c)\n{\n\tstruct server_acl_user\t*user;\n\tuid_t\t\t\t uid;\n\n\tuid = proc_get_peer_uid(c->peer);\n\tif (uid == (uid_t)-1)\n\t\treturn (0);\n\n\tuser = server_acl_user_find(uid);\n\tif (user == NULL)\n\t\treturn (0);\n\tif (user->flags & SERVER_ACL_READONLY)\n\t\tc->flags |= CLIENT_READONLY;\n\treturn (1);\n}\n\n/* Get UID for user entry. */\nuid_t\nserver_acl_get_uid(struct server_acl_user *user)\n{\n\treturn (user->uid);\n}\n"
        },
        {
          "name": "server-client.c",
          "type": "blob",
          "size": 105.50390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nenum mouse_where {\n\tNOWHERE,\n\tPANE,\n\tSTATUS,\n\tSTATUS_LEFT,\n\tSTATUS_RIGHT,\n\tSTATUS_DEFAULT,\n\tBORDER,\n\tSCROLLBAR_UP,\n\tSCROLLBAR_SLIDER,\n\tSCROLLBAR_DOWN\n};\n\nstatic void\tserver_client_free(int, short, void *);\nstatic void\tserver_client_check_pane_resize(struct window_pane *);\nstatic void\tserver_client_check_pane_buffer(struct window_pane *);\nstatic void\tserver_client_check_window_resize(struct window *);\nstatic key_code\tserver_client_check_mouse(struct client *, struct key_event *);\nstatic void\tserver_client_repeat_timer(int, short, void *);\nstatic void\tserver_client_click_timer(int, short, void *);\nstatic void\tserver_client_check_exit(struct client *);\nstatic void\tserver_client_check_redraw(struct client *);\nstatic void\tserver_client_check_modes(struct client *);\nstatic void\tserver_client_set_title(struct client *);\nstatic void\tserver_client_set_path(struct client *);\nstatic void\tserver_client_reset_state(struct client *);\nstatic void\tserver_client_update_latest(struct client *);\n\nstatic void\tserver_client_dispatch(struct imsg *, void *);\nstatic void\tserver_client_dispatch_command(struct client *, struct imsg *);\nstatic void\tserver_client_dispatch_identify(struct client *, struct imsg *);\nstatic void\tserver_client_dispatch_shell(struct client *);\n\n/* Compare client windows. */\nstatic int\nserver_client_window_cmp(struct client_window *cw1,\n    struct client_window *cw2)\n{\n\tif (cw1->window < cw2->window)\n\t\treturn (-1);\n\tif (cw1->window > cw2->window)\n\t\treturn (1);\n\treturn (0);\n}\nRB_GENERATE(client_windows, client_window, entry, server_client_window_cmp);\n\n/* Number of attached clients. */\nu_int\nserver_client_how_many(void)\n{\n\tstruct client\t*c;\n\tu_int\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && (~c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\t\tn++;\n\t}\n\treturn (n);\n}\n\n/* Overlay timer callback. */\nstatic void\nserver_client_overlay_timer(__unused int fd, __unused short events, void *data)\n{\n\tserver_client_clear_overlay(data);\n}\n\n/* Set an overlay on client. */\nvoid\nserver_client_set_overlay(struct client *c, u_int delay,\n    overlay_check_cb checkcb, overlay_mode_cb modecb,\n    overlay_draw_cb drawcb, overlay_key_cb keycb, overlay_free_cb freecb,\n    overlay_resize_cb resizecb, void *data)\n{\n\tstruct timeval\ttv;\n\n\tif (c->overlay_draw != NULL)\n\t\tserver_client_clear_overlay(c);\n\n\ttv.tv_sec = delay / 1000;\n\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\tif (event_initialized(&c->overlay_timer))\n\t\tevtimer_del(&c->overlay_timer);\n\tevtimer_set(&c->overlay_timer, server_client_overlay_timer, c);\n\tif (delay != 0)\n\t\tevtimer_add(&c->overlay_timer, &tv);\n\n\tc->overlay_check = checkcb;\n\tc->overlay_mode = modecb;\n\tc->overlay_draw = drawcb;\n\tc->overlay_key = keycb;\n\tc->overlay_free = freecb;\n\tc->overlay_resize = resizecb;\n\tc->overlay_data = data;\n\n\tif (c->overlay_check == NULL)\n\t\tc->tty.flags |= TTY_FREEZE;\n\tif (c->overlay_mode == NULL)\n\t\tc->tty.flags |= TTY_NOCURSOR;\n\twindow_update_focus(c->session->curw->window);\n\tserver_redraw_client(c);\n}\n\n/* Clear overlay mode on client. */\nvoid\nserver_client_clear_overlay(struct client *c)\n{\n\tif (c->overlay_draw == NULL)\n\t\treturn;\n\n\tif (event_initialized(&c->overlay_timer))\n\t\tevtimer_del(&c->overlay_timer);\n\n\tif (c->overlay_free != NULL)\n\t\tc->overlay_free(c, c->overlay_data);\n\n\tc->overlay_check = NULL;\n\tc->overlay_mode = NULL;\n\tc->overlay_draw = NULL;\n\tc->overlay_key = NULL;\n\tc->overlay_free = NULL;\n\tc->overlay_data = NULL;\n\n\tc->tty.flags &= ~(TTY_FREEZE|TTY_NOCURSOR);\n\twindow_update_focus(c->session->curw->window);\n\tserver_redraw_client(c);\n}\n\n/*\n * Given overlay position and dimensions, return parts of the input range which\n * are visible.\n */\nvoid\nserver_client_overlay_range(u_int x, u_int y, u_int sx, u_int sy, u_int px,\n    u_int py, u_int nx, struct overlay_ranges *r)\n{\n\tu_int\tox, onx;\n\n\t/* Return up to 2 ranges. */\n\tr->px[2] = 0;\n\tr->nx[2] = 0;\n\n\t/* Trivial case of no overlap in the y direction. */\n\tif (py < y || py > y + sy - 1) {\n\t\tr->px[0] = px;\n\t\tr->nx[0] = nx;\n\t\tr->px[1] = 0;\n\t\tr->nx[1] = 0;\n\t\treturn;\n\t}\n\n\t/* Visible bit to the left of the popup. */\n\tif (px < x) {\n\t\tr->px[0] = px;\n\t\tr->nx[0] = x - px;\n\t\tif (r->nx[0] > nx)\n\t\t\tr->nx[0] = nx;\n\t} else {\n\t\tr->px[0] = 0;\n\t\tr->nx[0] = 0;\n\t}\n\n\t/* Visible bit to the right of the popup. */\n\tox = x + sx;\n\tif (px > ox)\n\t\tox = px;\n\tonx = px + nx;\n\tif (onx > ox) {\n\t\tr->px[1] = ox;\n\t\tr->nx[1] = onx - ox;\n\t} else {\n\t\tr->px[1] = 0;\n\t\tr->nx[1] = 0;\n\t}\n}\n\n/* Check if this client is inside this server. */\nint\nserver_client_check_nested(struct client *c)\n{\n\tstruct environ_entry\t*envent;\n\tstruct window_pane\t*wp;\n\n\tenvent = environ_find(c->environ, \"TMUX\");\n\tif (envent == NULL || *envent->value == '\\0')\n\t\treturn (0);\n\n\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\tif (strcmp(wp->tty, c->ttyname) == 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Set client key table. */\nvoid\nserver_client_set_key_table(struct client *c, const char *name)\n{\n\tif (name == NULL)\n\t\tname = server_client_get_key_table(c);\n\n\tkey_bindings_unref_table(c->keytable);\n\tc->keytable = key_bindings_get_table(name, 1);\n\tc->keytable->references++;\n\tif (gettimeofday(&c->keytable->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n}\n\nstatic uint64_t\nserver_client_key_table_activity_diff(struct client *c)\n{\n\tstruct timeval\tdiff;\n\n\ttimersub(&c->activity_time, &c->keytable->activity_time, &diff);\n\treturn ((diff.tv_sec * 1000ULL) + (diff.tv_usec / 1000ULL));\n}\n\n/* Get default key table. */\nconst char *\nserver_client_get_key_table(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\tconst char\t*name;\n\n\tif (s == NULL)\n\t\treturn (\"root\");\n\n\tname = options_get_string(s->options, \"key-table\");\n\tif (*name == '\\0')\n\t\treturn (\"root\");\n\treturn (name);\n}\n\n/* Is this table the default key table? */\nstatic int\nserver_client_is_default_key_table(struct client *c, struct key_table *table)\n{\n\treturn (strcmp(table->name, server_client_get_key_table(c)) == 0);\n}\n\n/* Create a new client. */\nstruct client *\nserver_client_create(int fd)\n{\n\tstruct client\t*c;\n\n\tsetblocking(fd, 0);\n\n\tc = xcalloc(1, sizeof *c);\n\tc->references = 1;\n\tc->peer = proc_add_peer(server_proc, fd, server_client_dispatch, c);\n\n\tif (gettimeofday(&c->creation_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tmemcpy(&c->activity_time, &c->creation_time, sizeof c->activity_time);\n\n\tc->environ = environ_create();\n\n\tc->fd = -1;\n\tc->out_fd = -1;\n\n\tc->queue = cmdq_new();\n\tRB_INIT(&c->windows);\n\tRB_INIT(&c->files);\n\n\tc->tty.sx = 80;\n\tc->tty.sy = 24;\n\n\tstatus_init(c);\n\tc->flags |= CLIENT_FOCUSED;\n\n\tc->keytable = key_bindings_get_table(\"root\", 1);\n\tc->keytable->references++;\n\n\tevtimer_set(&c->repeat_timer, server_client_repeat_timer, c);\n\tevtimer_set(&c->click_timer, server_client_click_timer, c);\n\n\tTAILQ_INSERT_TAIL(&clients, c, entry);\n\tlog_debug(\"new client %p\", c);\n\treturn (c);\n}\n\n/* Open client terminal if needed. */\nint\nserver_client_open(struct client *c, char **cause)\n{\n\tconst char\t*ttynam = _PATH_TTY;\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn (0);\n\n\tif (strcmp(c->ttyname, ttynam) == 0||\n\t    ((isatty(STDIN_FILENO) &&\n\t    (ttynam = ttyname(STDIN_FILENO)) != NULL &&\n\t    strcmp(c->ttyname, ttynam) == 0) ||\n\t    (isatty(STDOUT_FILENO) &&\n\t    (ttynam = ttyname(STDOUT_FILENO)) != NULL &&\n\t    strcmp(c->ttyname, ttynam) == 0) ||\n\t    (isatty(STDERR_FILENO) &&\n\t    (ttynam = ttyname(STDERR_FILENO)) != NULL &&\n\t    strcmp(c->ttyname, ttynam) == 0))) {\n\t\txasprintf(cause, \"can't use %s\", c->ttyname);\n\t\treturn (-1);\n\t}\n\n\tif (!(c->flags & CLIENT_TERMINAL)) {\n\t\t*cause = xstrdup(\"not a terminal\");\n\t\treturn (-1);\n\t}\n\n\tif (tty_open(&c->tty, cause) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/* Lost an attached client. */\nstatic void\nserver_client_attached_lost(struct client *c)\n{\n\tstruct session\t*s;\n\tstruct window\t*w;\n\tstruct client\t*loop;\n\tstruct client\t*found;\n\n\tlog_debug(\"lost attached client %p\", c);\n\n\t/*\n\t * By this point the session in the client has been cleared so walk all\n\t * windows to find any with this client as the latest.\n\t */\n\tRB_FOREACH(w, windows, &windows) {\n\t\tif (w->latest != c)\n\t\t\tcontinue;\n\n\t\tfound = NULL;\n\t\tTAILQ_FOREACH(loop, &clients, entry) {\n\t\t\ts = loop->session;\n\t\t\tif (loop == c || s == NULL || s->curw->window != w)\n\t\t\t\tcontinue;\n\t\t\tif (found == NULL || timercmp(&loop->activity_time,\n\t\t\t    &found->activity_time, >))\n\t\t\t\tfound = loop;\n\t\t}\n\t\tif (found != NULL)\n\t\t\tserver_client_update_latest(found);\n\t}\n}\n\n/* Set client session. */\nvoid\nserver_client_set_session(struct client *c, struct session *s)\n{\n\tstruct session\t*old = c->session;\n\n\tif (s != NULL && c->session != NULL && c->session != s)\n\t\tc->last_session = c->session;\n\telse if (s == NULL)\n\t\tc->last_session = NULL;\n\tc->session = s;\n\tc->flags |= CLIENT_FOCUSED;\n\n\tif (old != NULL && old->curw != NULL)\n\t\twindow_update_focus(old->curw->window);\n\tif (s != NULL) {\n\t\trecalculate_sizes();\n\t\twindow_update_focus(s->curw->window);\n\t\tsession_update_activity(s, NULL);\n\t\tgettimeofday(&s->last_attached_time, NULL);\n\t\ts->curw->flags &= ~WINLINK_ALERTFLAGS;\n\t\ts->curw->window->latest = c;\n\t\talerts_check_session(s);\n\t\ttty_update_client_offset(c);\n\t\tstatus_timer_start(c);\n\t\tnotify_client(\"client-session-changed\", c);\n\t\tserver_redraw_client(c);\n\t}\n\n\tserver_check_unattached();\n\tserver_update_socket();\n}\n\n/* Lost a client. */\nvoid\nserver_client_lost(struct client *c)\n{\n\tstruct client_file\t*cf, *cf1;\n\tstruct client_window\t*cw, *cw1;\n\n\tc->flags |= CLIENT_DEAD;\n\n\tserver_client_clear_overlay(c);\n\tstatus_prompt_clear(c);\n\tstatus_message_clear(c);\n\n\tRB_FOREACH_SAFE(cf, client_files, &c->files, cf1) {\n\t\tcf->error = EINTR;\n\t\tfile_fire_done(cf);\n\t}\n\tRB_FOREACH_SAFE(cw, client_windows, &c->windows, cw1) {\n\t\tRB_REMOVE(client_windows, &c->windows, cw);\n\t\tfree(cw);\n\t}\n\n\tTAILQ_REMOVE(&clients, c, entry);\n\tlog_debug(\"lost client %p\", c);\n\n\tif (c->flags & CLIENT_ATTACHED) {\n\t\tserver_client_attached_lost(c);\n\t\tnotify_client(\"client-detached\", c);\n\t}\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\tcontrol_stop(c);\n\tif (c->flags & CLIENT_TERMINAL)\n\t\ttty_free(&c->tty);\n\tfree(c->ttyname);\n\tfree(c->clipboard_panes);\n\n\tfree(c->term_name);\n\tfree(c->term_type);\n\ttty_term_free_list(c->term_caps, c->term_ncaps);\n\n\tstatus_free(c);\n\n\tfree(c->title);\n\tfree((void *)c->cwd);\n\n\tevtimer_del(&c->repeat_timer);\n\tevtimer_del(&c->click_timer);\n\n\tkey_bindings_unref_table(c->keytable);\n\n\tfree(c->message_string);\n\tif (event_initialized(&c->message_timer))\n\t\tevtimer_del(&c->message_timer);\n\n\tfree(c->prompt_saved);\n\tfree(c->prompt_string);\n\tfree(c->prompt_buffer);\n\n\tformat_lost_client(c);\n\tenviron_free(c->environ);\n\n\tproc_remove_peer(c->peer);\n\tc->peer = NULL;\n\n\tif (c->out_fd != -1)\n\t\tclose(c->out_fd);\n\tif (c->fd != -1) {\n\t\tclose(c->fd);\n\t\tc->fd = -1;\n\t}\n\tserver_client_unref(c);\n\n\tserver_add_accept(0); /* may be more file descriptors now */\n\n\trecalculate_sizes();\n\tserver_check_unattached();\n\tserver_update_socket();\n}\n\n/* Remove reference from a client. */\nvoid\nserver_client_unref(struct client *c)\n{\n\tlog_debug(\"unref client %p (%d references)\", c, c->references);\n\n\tc->references--;\n\tif (c->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, server_client_free, c, NULL);\n}\n\n/* Free dead client. */\nstatic void\nserver_client_free(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\n\tlog_debug(\"free client %p (%d references)\", c, c->references);\n\n\tcmdq_free(c->queue);\n\n\tif (c->references == 0) {\n\t\tfree((void *)c->name);\n\t\tfree(c);\n\t}\n}\n\n/* Suspend a client. */\nvoid\nserver_client_suspend(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (s == NULL || (c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\treturn;\n\n\ttty_stop_tty(&c->tty);\n\tc->flags |= CLIENT_SUSPENDED;\n\tproc_send(c->peer, MSG_SUSPEND, -1, NULL, 0);\n}\n\n/* Detach a client. */\nvoid\nserver_client_detach(struct client *c, enum msgtype msgtype)\n{\n\tstruct session\t*s = c->session;\n\n\tif (s == NULL || (c->flags & CLIENT_NODETACHFLAGS))\n\t\treturn;\n\n\tc->flags |= CLIENT_EXIT;\n\n\tc->exit_type = CLIENT_EXIT_DETACH;\n\tc->exit_msgtype = msgtype;\n\tc->exit_session = xstrdup(s->name);\n}\n\n/* Execute command to replace a client. */\nvoid\nserver_client_exec(struct client *c, const char *cmd)\n{\n\tstruct session\t*s = c->session;\n\tchar\t\t*msg;\n\tconst char\t*shell;\n\tsize_t\t\t cmdsize, shellsize;\n\n\tif (*cmd == '\\0')\n\t\treturn;\n\tcmdsize = strlen(cmd) + 1;\n\n\tif (s != NULL)\n\t\tshell = options_get_string(s->options, \"default-shell\");\n\telse\n\t\tshell = options_get_string(global_s_options, \"default-shell\");\n\tif (!checkshell(shell))\n\t\tshell = _PATH_BSHELL;\n\tshellsize = strlen(shell) + 1;\n\n\tmsg = xmalloc(cmdsize + shellsize);\n\tmemcpy(msg, cmd, cmdsize);\n\tmemcpy(msg + cmdsize, shell, shellsize);\n\n\tproc_send(c->peer, MSG_EXEC, -1, msg, cmdsize + shellsize);\n\tfree(msg);\n}\n\nstatic enum mouse_where\nserver_client_check_mouse_in_pane(struct window_pane *wp, u_int px, u_int py,\n    u_int *sl_mpos)\n{\n\tstruct window\t\t*w = wp->window;\n\tstruct options\t\t*wo = w->options;\n\tstruct window_pane\t*fwp;\n\tint\t\t\t pane_status, sb, sb_pos, sb_w, sb_pad;\n\tu_int\t\t\t line, sl_top, sl_bottom;\n\n\tsb = options_get_number(wo, \"pane-scrollbars\");\n\tsb_pos = options_get_number(wo, \"pane-scrollbars-position\");\n\tpane_status = options_get_number(wo, \"pane-border-status\");\n\tsb_pos = options_get_number(wo, \"pane-scrollbars-position\");\n\n\tif (window_pane_show_scrollbar(wp, sb)) {\n\t\tsb_w = wp->scrollbar_style.width;\n\t\tsb_pad = wp->scrollbar_style.pad;\n\t} else {\n\t\tsb_w = 0;\n\t\tsb_pad = 0;\n\t}\n\tif (pane_status == PANE_STATUS_TOP)\n\t\tline = wp->yoff - 1;\n\telse if (pane_status == PANE_STATUS_BOTTOM)\n\t\tline = wp->yoff + wp->sy;\n\n\t/* Check if point is within the pane or scrollbar. */\n\tif (((pane_status != PANE_STATUS_OFF && py != line) ||\n\t    (wp->yoff == 0 && py < wp->sy) ||\n\t    (py >= wp->yoff && py < wp->yoff + wp->sy)) &&\n\t    ((sb_pos == PANE_SCROLLBARS_RIGHT &&\n\t    px < wp->xoff + wp->sx + sb_pad + sb_w) ||\n\t    (sb_pos == PANE_SCROLLBARS_LEFT &&\n\t    px < wp->xoff + wp->sx - sb_pad - sb_w))) {\n\t\t/* Check if in the scrollbar. */\n\t\tif ((sb_pos == PANE_SCROLLBARS_RIGHT &&\n\t\t    (px >= wp->xoff + wp->sx + sb_pad &&\n\t\t    px < wp->xoff + wp->sx + sb_pad + sb_w)) ||\n\t\t    (sb_pos == PANE_SCROLLBARS_LEFT &&\n\t\t    (px >= wp->xoff - sb_pad - sb_w &&\n\t\t    px < wp->xoff - sb_pad))) {\n\t\t\t/* Check where inside the scrollbar. */\n\t\t\tsl_top = wp->yoff + wp->sb_slider_y;\n\t\t\tsl_bottom = (wp->yoff + wp->sb_slider_y +\n\t\t\t    wp->sb_slider_h - 1);\n\t\t\tif (py < sl_top)\n\t\t\t\treturn (SCROLLBAR_UP);\n\t\t\telse if (py >= sl_top &&\n\t\t\t\t py <= sl_bottom) {\n\t\t\t\t*sl_mpos = (py - wp->sb_slider_y - wp->yoff);\n\t\t\t\treturn (SCROLLBAR_SLIDER);\n\t\t\t} else /* py > sl_bottom */\n\t\t\t\treturn (SCROLLBAR_DOWN);\n\t\t} else {\n\t\t\t/* Must be inside the pane. */\n\t\t\treturn (PANE);\n\t\t}\n\t} else if (~w->flags & WINDOW_ZOOMED) {\n\t\t/* Try the pane borders if not zoomed. */\n\t\tTAILQ_FOREACH(fwp, &w->panes, entry) {\n\t\t\tif ((((sb_pos == PANE_SCROLLBARS_RIGHT &&\n\t\t\t    fwp->xoff + fwp->sx + sb_pad + sb_w == px) ||\n\t\t\t    (sb_pos == PANE_SCROLLBARS_LEFT &&\n\t\t\t    fwp->xoff + fwp->sx == px)) &&\n\t\t\t    fwp->yoff <= 1 + py &&\n\t\t\t    fwp->yoff + fwp->sy >= py) ||\n\t\t\t    (fwp->yoff + fwp->sy == py &&\n\t\t\t    fwp->xoff <= 1 + px &&\n\t\t\t    fwp->xoff + fwp->sx >= px))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (fwp != NULL) {\n\t\t\twp = fwp;\n\t\t\treturn (BORDER);\n\t\t}\n\t}\n\treturn (NOWHERE);\n}\n\n/* Check for mouse keys. */\nstatic key_code\nserver_client_check_mouse(struct client *c, struct key_event *event)\n{\n\tstruct mouse_event\t*m = &event->m;\n\tstruct session\t\t*s = c->session, *fs;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct winlink\t\t*fwl;\n\tstruct window_pane\t*wp, *fwp;\n\tu_int\t\t\t x, y, b, sx, sy, px, py, sl_mpos = 0;\n\tint\t\t\t ignore = 0;\n\tkey_code\t\t key;\n\tstruct timeval\t\t tv;\n\tstruct style_range\t*sr;\n\tenum { NOTYPE,\n\t       MOVE,\n\t       DOWN,\n\t       UP,\n\t       DRAG,\n\t       WHEEL,\n\t       SECOND,\n\t       DOUBLE,\n\t       TRIPLE } type = NOTYPE;\n\tenum mouse_where where = NOWHERE;\n\n\tlog_debug(\"%s mouse %02x at %u,%u (last %u,%u) (%d)\", c->name, m->b,\n\t    m->x, m->y, m->lx, m->ly, c->tty.mouse_drag_flag);\n\n\t/* What type of event is this? */\n\tif (event->key == KEYC_DOUBLECLICK) {\n\t\ttype = DOUBLE;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tignore = 1;\n\t\tlog_debug(\"double-click at %u,%u\", x, y);\n\t} else if ((m->sgr_type != ' ' &&\n\t    MOUSE_DRAG(m->sgr_b) &&\n\t    MOUSE_RELEASE(m->sgr_b)) ||\n\t    (m->sgr_type == ' ' &&\n\t    MOUSE_DRAG(m->b) &&\n\t    MOUSE_RELEASE(m->b) &&\n\t    MOUSE_RELEASE(m->lb))) {\n\t\ttype = MOVE;\n\t\tx = m->x, y = m->y, b = 0;\n\t\tlog_debug(\"move at %u,%u\", x, y);\n\t} else if (MOUSE_DRAG(m->b)) {\n\t\ttype = DRAG;\n\t\tif (c->tty.mouse_drag_flag) {\n\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\tif (x == m->lx && y == m->ly)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tlog_debug(\"drag update at %u,%u\", x, y);\n\t\t} else {\n\t\t\tx = m->lx, y = m->ly, b = m->lb;\n\t\t\tlog_debug(\"drag start at %u,%u\", x, y);\n\t\t}\n\t} else if (MOUSE_WHEEL(m->b)) {\n\t\ttype = WHEEL;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tlog_debug(\"wheel at %u,%u\", x, y);\n\t} else if (MOUSE_RELEASE(m->b)) {\n\t\ttype = UP;\n\t\tx = m->x, y = m->y, b = m->lb;\n\t\tif (m->sgr_type == 'm')\n\t\t\tb = m->sgr_b;\n\t\tlog_debug(\"up at %u,%u\", x, y);\n\t} else {\n\t\tif (c->flags & CLIENT_DOUBLECLICK) {\n\t\t\tevtimer_del(&c->click_timer);\n\t\t\tc->flags &= ~CLIENT_DOUBLECLICK;\n\t\t\tif (m->b == c->click_button) {\n\t\t\t\ttype = SECOND;\n\t\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\t\tlog_debug(\"second-click at %u,%u\", x, y);\n\t\t\t\tc->flags |= CLIENT_TRIPLECLICK;\n\t\t\t}\n\t\t} else if (c->flags & CLIENT_TRIPLECLICK) {\n\t\t\tevtimer_del(&c->click_timer);\n\t\t\tc->flags &= ~CLIENT_TRIPLECLICK;\n\t\t\tif (m->b == c->click_button) {\n\t\t\t\ttype = TRIPLE;\n\t\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\t\tlog_debug(\"triple-click at %u,%u\", x, y);\n\t\t\t\tgoto have_event;\n\t\t\t}\n\t\t}\n\n\t\t/* DOWN is the only remaining event type. */\n\t\tif (type == NOTYPE) {\n\t\t\ttype = DOWN;\n\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\tlog_debug(\"down at %u,%u\", x, y);\n\t\t\tc->flags |= CLIENT_DOUBLECLICK;\n\t\t}\n\n\t\tif (KEYC_CLICK_TIMEOUT != 0) {\n\t\t\tmemcpy(&c->click_event, m, sizeof c->click_event);\n\t\t\tc->click_button = m->b;\n\n\t\t\tlog_debug(\"click timer started\");\n\t\t\ttv.tv_sec = KEYC_CLICK_TIMEOUT / 1000;\n\t\t\ttv.tv_usec = (KEYC_CLICK_TIMEOUT % 1000) * 1000L;\n\t\t\tevtimer_del(&c->click_timer);\n\t\t\tevtimer_add(&c->click_timer, &tv);\n\t\t}\n\t}\n\nhave_event:\n\tif (type == NOTYPE)\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Save the session. */\n\tm->s = s->id;\n\tm->w = -1;\n\tm->wp = -1;\n\tm->ignore = ignore;\n\n\t/* Is this on the status line? */\n\tm->statusat = status_at_line(c);\n\tm->statuslines = status_line_size(c);\n\tif (m->statusat != -1 &&\n\t    y >= (u_int)m->statusat &&\n\t    y < m->statusat + m->statuslines) {\n\t\tsr = status_get_range(c, x, y - m->statusat);\n\t\tif (sr == NULL) {\n\t\t\twhere = STATUS_DEFAULT;\n\t\t} else {\n\t\t\tswitch (sr->type) {\n\t\t\tcase STYLE_RANGE_NONE:\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tcase STYLE_RANGE_LEFT:\n\t\t\t\tlog_debug(\"mouse range: left\");\n\t\t\t\twhere = STATUS_LEFT;\n\t\t\t\tbreak;\n\t\t\tcase STYLE_RANGE_RIGHT:\n\t\t\t\tlog_debug(\"mouse range: right\");\n\t\t\t\twhere = STATUS_RIGHT;\n\t\t\t\tbreak;\n\t\t\tcase STYLE_RANGE_PANE:\n\t\t\t\tfwp = window_pane_find_by_id(sr->argument);\n\t\t\t\tif (fwp == NULL)\n\t\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\t\tm->wp = sr->argument;\n\n\t\t\t\tlog_debug(\"mouse range: pane %%%u\", m->wp);\n\t\t\t\twhere = STATUS;\n\t\t\t\tbreak;\n\t\t\tcase STYLE_RANGE_WINDOW:\n\t\t\t\tfwl = winlink_find_by_index(&s->windows,\n\t\t\t\t    sr->argument);\n\t\t\t\tif (fwl == NULL)\n\t\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\t\tm->w = fwl->window->id;\n\n\t\t\t\tlog_debug(\"mouse range: window @%u\", m->w);\n\t\t\t\twhere = STATUS;\n\t\t\t\tbreak;\n\t\t\tcase STYLE_RANGE_SESSION:\n\t\t\t\tfs = session_find_by_id(sr->argument);\n\t\t\t\tif (fs == NULL)\n\t\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\t\tm->s = sr->argument;\n\n\t\t\t\tlog_debug(\"mouse range: session $%u\", m->s);\n\t\t\t\twhere = STATUS;\n\t\t\t\tbreak;\n\t\t\tcase STYLE_RANGE_USER:\n\t\t\t\twhere = STATUS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Not on status line. Adjust position and check for border, pane, or\n\t * scrollbar.\n\t */\n\tif (where == NOWHERE) {\n\t\tif (c->tty.mouse_scrolling_flag)\n\t\t\twhere = SCROLLBAR_SLIDER;\n\t\telse {\n\t\t\tpx = x;\n\t\t\tif (m->statusat == 0 && y >= m->statuslines)\n\t\t\t\tpy = y - m->statuslines;\n\t\t\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\t\t\tpy = m->statusat - 1;\n\t\t\telse\n\t\t\t\tpy = y;\n\n\t\t\ttty_window_offset(&c->tty, &m->ox, &m->oy, &sx, &sy);\n\t\t\tlog_debug(\"mouse window @%u at %u,%u (%ux%u)\",\n\t\t\t\t  w->id, m->ox, m->oy, sx, sy);\n\t\t\tif (px > sx || py > sy)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tpx = px + m->ox;\n\t\t\tpy = py + m->oy;\n\n\t\t\t/* Try inside the pane. */\n\t\t\twp = window_get_active_at(w, px, py);\n\t\t\tif (wp == NULL)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\twhere = server_client_check_mouse_in_pane(wp, px, py,\n\t\t\t    &sl_mpos);\n\n\t\t\tif (where == PANE) {\n\t\t\t\tlog_debug(\"mouse %u,%u on pane %%%u\", x, y,\n\t\t\t\t    wp->id);\n\t\t\t} else if (where == BORDER)\n\t\t\t\tlog_debug(\"mouse on pane %%%u border\", wp->id);\n\t\t\telse if (where == SCROLLBAR_UP ||\n\t\t\t    where == SCROLLBAR_SLIDER ||\n\t\t\t    where == SCROLLBAR_DOWN) {\n\t\t\t\tlog_debug(\"mouse on pane %%%u scrollbar\",\n\t\t\t\t    wp->id);\n\t\t\t}\n\t\t\tm->wp = wp->id;\n\t\t\tm->w = wp->window->id;\n\t\t}\n\t} else\n\t\tm->wp = -1;\n\n\t/* Stop dragging if needed. */\n\tif (type != DRAG &&\n\t    type != WHEEL &&\n\t    type != DOUBLE &&\n\t    type != TRIPLE &&\n\t    c->tty.mouse_drag_flag != 0) {\n\t\tif (c->tty.mouse_drag_release != NULL)\n\t\t\tc->tty.mouse_drag_release(c, m);\n\n\t\tc->tty.mouse_drag_update = NULL;\n\t\tc->tty.mouse_drag_release = NULL;\n\t\tc->tty.mouse_scrolling_flag = 0;\n\n\t\t/*\n\t\t * End a mouse drag by passing a MouseDragEnd key corresponding\n\t\t * to the button that started the drag.\n\t\t */\n\t\tswitch (c->tty.mouse_drag_flag - 1) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND10_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_SCROLLBAR_SLIDER;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND11_BORDER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = KEYC_MOUSE;\n\t\t\tbreak;\n\t\t}\n\t\tc->tty.mouse_drag_flag = 0;\n\t\tc->tty.mouse_slider_mpos = -1;\n\t\tgoto out;\n\t}\n\n\t/* Convert to a key binding. */\n\tkey = KEYC_UNKNOWN;\n\tswitch (type) {\n\tcase NOTYPE:\n\t\tbreak;\n\tcase MOVE:\n\t\tif (where == PANE)\n\t\t\tkey = KEYC_MOUSEMOVE_PANE;\n\t\tif (where == STATUS)\n\t\t\tkey = KEYC_MOUSEMOVE_STATUS;\n\t\tif (where == STATUS_LEFT)\n\t\t\tkey = KEYC_MOUSEMOVE_STATUS_LEFT;\n\t\tif (where == STATUS_RIGHT)\n\t\t\tkey = KEYC_MOUSEMOVE_STATUS_RIGHT;\n\t\tif (where == STATUS_DEFAULT)\n\t\t\tkey = KEYC_MOUSEMOVE_STATUS_DEFAULT;\n\t\tif (where == BORDER)\n\t\t\tkey = KEYC_MOUSEMOVE_BORDER;\n\t\tbreak;\n\tcase DRAG:\n\t\tif (c->tty.mouse_drag_update != NULL)\n\t\t\tkey = KEYC_DRAGGING;\n\t\telse {\n\t\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\t\tcase MOUSE_BUTTON_1:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_2:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_3:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_6:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG6_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_7:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG7_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_8:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG8_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_9:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG9_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_10:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG10_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase MOUSE_BUTTON_11:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_STATUS;\n\t\t\t\tif (where == STATUS_LEFT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_STATUS_LEFT;\n\t\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_STATUS_RIGHT;\n\t\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_STATUS_DEFAULT;\n\t\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_SCROLLBAR_UP;\n\t\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_SCROLLBAR_SLIDER;\n\t\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_SCROLLBAR_DOWN;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG11_BORDER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Begin a drag by setting the flag to a non-zero value that\n\t\t * corresponds to the mouse button in use. If starting to drag\n\t\t * the scrollbar, store the relative position in the slider\n\t\t * where the user grabbed.\n\t\t */\n\t\tc->tty.mouse_drag_flag = MOUSE_BUTTONS(b) + 1;\n\t\tif (c->tty.mouse_scrolling_flag == 0 &&\n\t\t    where == SCROLLBAR_SLIDER) {\n\t\t\tc->tty.mouse_scrolling_flag = 1;\n\t\t\tc->tty.mouse_slider_mpos = sl_mpos;\n\t\t}\n\t\tbreak;\n\tcase WHEEL:\n\t\tif (MOUSE_BUTTONS(b) == MOUSE_WHEEL_UP) {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELUP_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS_DEFAULT;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELUP_BORDER;\n\t\t} else {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELDOWN_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS_DEFAULT;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELDOWN_BORDER;\n\t\t}\n\t\tbreak;\n\tcase UP:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP1_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP1_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP2_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP2_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP2_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP3_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP3_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP3_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP6_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP6_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP6_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP7_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP7_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP7_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP8_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP8_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP8_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP9_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP9_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP9_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP10_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP10_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEUP11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEUP11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEUP11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEUP11_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEUP11_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEUP11_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP11_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DOWN:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN10_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN11_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SECOND:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK1_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK1_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK2_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK2_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK2_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK3_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK3_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK3_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK6_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK6_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK6_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK7_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK7_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK7_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK8_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK8_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK8_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK9_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK9_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK9_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK10_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK10_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK10_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK10_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK10_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK10_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK10_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK10_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_SECONDCLICK11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_SECONDCLICK11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_SECONDCLICK11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_SECONDCLICK11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_SECONDCLICK11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_SECONDCLICK11_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_SECONDCLICK11_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_SECONDCLICK11_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_SECONDCLICK11_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DOUBLE:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK10_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_DOUBLECLICK11_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TRIPLE:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase MOUSE_BUTTON_1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK1_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK2_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK3_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_6:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK6_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_7:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK7_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_8:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK8_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_9:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK9_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_10:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK10_BORDER;\n\t\t\tbreak;\n\t\tcase MOUSE_BUTTON_11:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_STATUS;\n\t\t\tif (where == STATUS_LEFT)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_STATUS_LEFT;\n\t\t\tif (where == STATUS_RIGHT)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_STATUS_RIGHT;\n\t\t\tif (where == STATUS_DEFAULT)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_STATUS_DEFAULT;\n\t\t\tif (where == SCROLLBAR_UP)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_SCROLLBAR_UP;\n\t\t\tif (where == SCROLLBAR_SLIDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_SCROLLBAR_SLIDER;\n\t\t\tif (where == SCROLLBAR_DOWN)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_SCROLLBAR_DOWN;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_TRIPLECLICK11_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (key == KEYC_UNKNOWN)\n\t\treturn (KEYC_UNKNOWN);\n\nout:\n\t/* Apply modifiers if any. */\n\tif (b & MOUSE_MASK_META)\n\t\tkey |= KEYC_META;\n\tif (b & MOUSE_MASK_CTRL)\n\t\tkey |= KEYC_CTRL;\n\tif (b & MOUSE_MASK_SHIFT)\n\t\tkey |= KEYC_SHIFT;\n\n\tif (log_get_level() != 0)\n\t\tlog_debug(\"mouse key is %s\", key_string_lookup_key (key, 1));\n\treturn (key);\n}\n\n/* Is this a bracket paste key? */\nstatic int\nserver_client_is_bracket_paste(struct client *c, key_code key)\n{\n\tif (key == KEYC_PASTE_START) {\n\t\tc->flags |= CLIENT_BRACKETPASTING;\n\t\tlog_debug(\"%s: bracket paste on\", c->name);\n\t\treturn (0);\n\t}\n\n\tif (key == KEYC_PASTE_END) {\n\t\tc->flags &= ~CLIENT_BRACKETPASTING;\n\t\tlog_debug(\"%s: bracket paste off\", c->name);\n\t\treturn (0);\n\t}\n\n\treturn !!(c->flags & CLIENT_BRACKETPASTING);\n}\n\n/* Is this fast enough to probably be a paste? */\nstatic int\nserver_client_is_assume_paste(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\tstruct timeval\t tv;\n\tint\t\t t;\n\n\tif (c->flags & CLIENT_BRACKETPASTING)\n\t\treturn (0);\n\tif ((t = options_get_number(s->options, \"assume-paste-time\")) == 0)\n\t\treturn (0);\n\n\ttimersub(&c->activity_time, &c->last_activity_time, &tv);\n\tif (tv.tv_sec == 0 && tv.tv_usec < t * 1000) {\n\t\tif (c->flags & CLIENT_ASSUMEPASTING)\n\t\t\treturn (1);\n\t\tc->flags |= CLIENT_ASSUMEPASTING;\n\t\tlog_debug(\"%s: assume paste on\", c->name);\n\t\treturn (0);\n\t}\n\tif (c->flags & CLIENT_ASSUMEPASTING) {\n\t\tc->flags &= ~CLIENT_ASSUMEPASTING;\n\t\tlog_debug(\"%s: assume paste off\", c->name);\n\t}\n\treturn (0);\n}\n\n/* Has the latest client changed? */\nstatic void\nserver_client_update_latest(struct client *c)\n{\n\tstruct window\t*w;\n\n\tif (c->session == NULL)\n\t\treturn;\n\tw = c->session->curw->window;\n\n\tif (w->latest == c)\n\t\treturn;\n\tw->latest = c;\n\n\tif (options_get_number(w->options, \"window-size\") == WINDOW_SIZE_LATEST)\n\t\trecalculate_size(w, 0);\n\n\tnotify_client(\"client-active\", c);\n}\n\n/* Get repeat time. */\nstatic u_int\nserver_client_repeat_time(struct client *c, struct key_binding *bd)\n{\n\tstruct session\t*s = c->session;\n\tu_int\t\t repeat, initial;\n\n\tif (~bd->flags & KEY_BINDING_REPEAT)\n\t\treturn (0);\n\trepeat = options_get_number(s->options, \"repeat-time\");\n\tif (repeat == 0)\n\t\treturn (0);\n\tif ((~c->flags & CLIENT_REPEAT) || bd->key != c->last_key) {\n\t\tinitial = options_get_number(s->options, \"initial-repeat-time\");\n\t\tif (initial != 0)\n\t\t\trepeat = initial;\n\t}\n\treturn (repeat);\n}\n\n/*\n * Handle data key input from client. This owns and can modify the key event it\n * is given and is responsible for freeing it.\n */\nstatic enum cmd_retval\nserver_client_key_callback(struct cmdq_item *item, void *data)\n{\n\tstruct client\t\t\t*c = cmdq_get_client(item);\n\tstruct key_event\t\t*event = data;\n\tkey_code\t\t\t key = event->key;\n\tstruct mouse_event\t\t*m = &event->m;\n\tstruct session\t\t\t*s = c->session;\n\tstruct winlink\t\t\t*wl;\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tstruct timeval\t\t\t tv;\n\tstruct key_table\t\t*table, *first;\n\tstruct key_binding\t\t*bd;\n\tu_int\t\t\t\t repeat;\n\tuint64_t\t\t\t flags, prefix_delay;\n\tstruct cmd_find_state\t\t fs;\n\tkey_code\t\t\t key0, prefix, prefix2;\n\n\t/* Check the client is good to accept input. */\n\tif (s == NULL || (c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\tgoto out;\n\twl = s->curw;\n\n\t/* Update the activity timer. */\n\tmemcpy(&c->last_activity_time, &c->activity_time,\n\t    sizeof c->last_activity_time);\n\tif (gettimeofday(&c->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tsession_update_activity(s, &c->activity_time);\n\n\t/* Check for mouse keys. */\n\tm->valid = 0;\n\tif (key == KEYC_MOUSE || key == KEYC_DOUBLECLICK) {\n\t\tif (c->flags & CLIENT_READONLY)\n\t\t\tgoto out;\n\t\tkey = server_client_check_mouse(c, event);\n\t\tif (key == KEYC_UNKNOWN)\n\t\t\tgoto out;\n\n\t\tm->valid = 1;\n\t\tm->key = key;\n\n\t\t/*\n\t\t * Mouse drag is in progress, so fire the callback (now that\n\t\t * the mouse event is valid).\n\t\t */\n\t\tif ((key & KEYC_MASK_KEY) == KEYC_DRAGGING) {\n\t\t\tc->tty.mouse_drag_update(c, m);\n\t\t\tgoto out;\n\t\t}\n\t\tevent->key = key;\n\t}\n\n\t/* Find affected pane. */\n\tif (!KEYC_IS_MOUSE(key) || cmd_find_from_mouse(&fs, m, 0) != 0)\n\t\tcmd_find_from_client(&fs, c, 0);\n\twp = fs.wp;\n\n\t/* Forward mouse keys if disabled. */\n\tif (KEYC_IS_MOUSE(key) && !options_get_number(s->options, \"mouse\"))\n\t\tgoto forward_key;\n\n\t/* Forward if bracket pasting. */\n\tif (server_client_is_bracket_paste (c, key))\n\t\tgoto paste_key;\n\n\t/* Treat everything as a regular key when pasting is detected. */\n\tif (!KEYC_IS_MOUSE(key) &&\n\t    key != KEYC_FOCUS_IN &&\n\t    key != KEYC_FOCUS_OUT &&\n\t    (~key & KEYC_SENT) &&\n\t    server_client_is_assume_paste(c))\n\t\tgoto paste_key;\n\n\t/*\n\t * Work out the current key table. If the pane is in a mode, use\n\t * the mode table instead of the default key table.\n\t */\n\tif (server_client_is_default_key_table(c, c->keytable) &&\n\t    wp != NULL &&\n\t    (wme = TAILQ_FIRST(&wp->modes)) != NULL &&\n\t    wme->mode->key_table != NULL)\n\t\ttable = key_bindings_get_table(wme->mode->key_table(wme), 1);\n\telse\n\t\ttable = c->keytable;\n\tfirst = table;\n\ntable_changed:\n\t/*\n\t * The prefix always takes precedence and forces a switch to the prefix\n\t * table, unless we are already there.\n\t */\n\tprefix = (key_code)options_get_number(s->options, \"prefix\");\n\tprefix2 = (key_code)options_get_number(s->options, \"prefix2\");\n\tkey0 = (key & (KEYC_MASK_KEY|KEYC_MASK_MODIFIERS));\n\tif ((key0 == (prefix & (KEYC_MASK_KEY|KEYC_MASK_MODIFIERS)) ||\n\t    key0 == (prefix2 & (KEYC_MASK_KEY|KEYC_MASK_MODIFIERS))) &&\n\t    strcmp(table->name, \"prefix\") != 0) {\n\t\tserver_client_set_key_table(c, \"prefix\");\n\t\tserver_status_client(c);\n\t\tgoto out;\n\t}\n\tflags = c->flags;\n\ntry_again:\n\t/* Log key table. */\n\tif (wp == NULL)\n\t\tlog_debug(\"key table %s (no pane)\", table->name);\n\telse\n\t\tlog_debug(\"key table %s (pane %%%u)\", table->name, wp->id);\n\tif (c->flags & CLIENT_REPEAT)\n\t\tlog_debug(\"currently repeating\");\n\n\tbd = key_bindings_get(table, key0);\n\n\t/*\n\t * If prefix-timeout is enabled and we're in the prefix table, see if\n\t * the timeout has been exceeded. Revert to the root table if so.\n\t */\n\tprefix_delay = options_get_number(global_options, \"prefix-timeout\");\n\tif (prefix_delay > 0 &&\n\t    strcmp(table->name, \"prefix\") == 0 &&\n\t    server_client_key_table_activity_diff(c) > prefix_delay) {\n\t\t/*\n\t\t * If repeating is active and this is a repeating binding,\n\t\t * ignore the timeout.\n\t\t */\n\t\tif (bd != NULL &&\n\t\t    (c->flags & CLIENT_REPEAT) &&\n\t\t    (bd->flags & KEY_BINDING_REPEAT)) {\n\t\t\tlog_debug(\"prefix timeout ignored, repeat is active\");\n\t\t} else {\n\t\t\tlog_debug(\"prefix timeout exceeded\");\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t\tfirst = table = c->keytable;\n\t\t\tserver_status_client(c);\n\t\t\tgoto table_changed;\n\t\t}\n\t}\n\n\t/* Try to see if there is a key binding in the current table. */\n\tif (bd != NULL) {\n\t\t/*\n\t\t * Key was matched in this table. If currently repeating but a\n\t\t * non-repeating binding was found, stop repeating and try\n\t\t * again in the root table.\n\t\t */\n\t\tif ((c->flags & CLIENT_REPEAT) &&\n\t\t    (~bd->flags & KEY_BINDING_REPEAT)) {\n\t\t\tlog_debug(\"found in key table %s (not repeating)\",\n\t\t\t    table->name);\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t\tfirst = table = c->keytable;\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_status_client(c);\n\t\t\tgoto table_changed;\n\t\t}\n\t\tlog_debug(\"found in key table %s\", table->name);\n\n\t\t/*\n\t\t * Take a reference to this table to make sure the key binding\n\t\t * doesn't disappear.\n\t\t */\n\t\ttable->references++;\n\n\t\t/*\n\t\t * If this is a repeating key, start the timer. Otherwise reset\n\t\t * the client back to the root table.\n\t\t */\n\t\trepeat = server_client_repeat_time(c, bd);\n\t\tif (repeat != 0) {\n\t\t\tc->flags |= CLIENT_REPEAT;\n\t\t\tc->last_key = bd->key;\n\n\t\t\ttv.tv_sec = repeat / 1000;\n\t\t\ttv.tv_usec = (repeat % 1000) * 1000L;\n\t\t\tevtimer_del(&c->repeat_timer);\n\t\t\tevtimer_add(&c->repeat_timer, &tv);\n\t\t} else {\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t}\n\t\tserver_status_client(c);\n\n\t\t/* Execute the key binding. */\n\t\tkey_bindings_dispatch(bd, item, c, event, &fs);\n\t\tkey_bindings_unref_table(table);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * No match, try the ANY key.\n\t */\n\tif (key0 != KEYC_ANY) {\n\t\tkey0 = KEYC_ANY;\n\t\tgoto try_again;\n\t}\n\n\t/*\n\t * Binding movement keys is useless since we only turn them on when the\n\t * application requests, so don't let them exit the prefix table.\n\t */\n\tif (key == KEYC_MOUSEMOVE_PANE ||\n\t    key == KEYC_MOUSEMOVE_STATUS ||\n\t    key == KEYC_MOUSEMOVE_STATUS_LEFT ||\n\t    key == KEYC_MOUSEMOVE_STATUS_RIGHT ||\n\t    key == KEYC_MOUSEMOVE_STATUS_DEFAULT ||\n\t    key == KEYC_MOUSEMOVE_BORDER)\n\t\tgoto forward_key;\n\n\t/*\n\t * No match in this table. If not in the root table or if repeating\n\t * switch the client back to the root table and try again.\n\t */\n\tlog_debug(\"not found in key table %s\", table->name);\n\tif (!server_client_is_default_key_table(c, table) ||\n\t    (c->flags & CLIENT_REPEAT)) {\n\t\tlog_debug(\"trying in root table\");\n\t\tserver_client_set_key_table(c, NULL);\n\t\ttable = c->keytable;\n\t\tif (c->flags & CLIENT_REPEAT)\n\t\t\tfirst = table;\n\t\tc->flags &= ~CLIENT_REPEAT;\n\t\tserver_status_client(c);\n\t\tgoto table_changed;\n\t}\n\n\t/*\n\t * No match in the root table either. If this wasn't the first table\n\t * tried, don't pass the key to the pane.\n\t */\n\tif (first != table && (~flags & CLIENT_REPEAT)) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tserver_status_client(c);\n\t\tgoto out;\n\t}\n\nforward_key:\n\tif (c->flags & CLIENT_READONLY)\n\t\tgoto out;\n\tif (wp != NULL)\n\t\twindow_pane_key(wp, c, s, wl, key, m);\n\tgoto out;\n\npaste_key:\n\tif (c->flags & CLIENT_READONLY)\n\t\tgoto out;\n\tif (event->buf != NULL)\n\t\twindow_pane_paste(wp, key, event->buf, event->len);\n\tkey = KEYC_NONE;\n\tgoto out;\n\nout:\n\tif (s != NULL && key != KEYC_FOCUS_OUT)\n\t\tserver_client_update_latest(c);\n\tfree(event->buf);\n\tfree(event);\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Handle a key event. */\nint\nserver_client_handle_key(struct client *c, struct key_event *event)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct cmdq_item\t*item;\n\n\t/* Check the client is good to accept input. */\n\tif (s == NULL || (c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\treturn (0);\n\n\t/*\n\t * Key presses in overlay mode and the command prompt are a special\n\t * case. The queue might be blocked so they need to be processed\n\t * immediately rather than queued.\n\t */\n\tif (~c->flags & CLIENT_READONLY) {\n\t\tif (c->message_string != NULL) {\n\t\t\tif (c->message_ignore_keys)\n\t\t\t\treturn (0);\n\t\t\tstatus_message_clear(c);\n\t\t}\n\t\tif (c->overlay_key != NULL) {\n\t\t\tswitch (c->overlay_key(c, c->overlay_data, event)) {\n\t\t\tcase 0:\n\t\t\t\treturn (0);\n\t\t\tcase 1:\n\t\t\t\tserver_client_clear_overlay(c);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\tserver_client_clear_overlay(c);\n\t\tif (c->prompt_string != NULL) {\n\t\t\tif (status_prompt_key(c, event->key) == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * Add the key to the queue so it happens after any commands queued by\n\t * previous keys.\n\t */\n\titem = cmdq_get_callback(server_client_key_callback, event);\n\tcmdq_append(c, item);\n\treturn (1);\n}\n\n/* Client functions that need to happen every loop. */\nvoid\nserver_client_loop(void)\n{\n\tstruct client\t\t*c;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\n\t/* Check for window resize. This is done before redrawing. */\n\tRB_FOREACH(w, windows, &windows)\n\t\tserver_client_check_window_resize(w);\n\n\t/* Check clients. */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tserver_client_check_exit(c);\n\t\tif (c->session != NULL) {\n\t\t\tserver_client_check_modes(c);\n\t\t\tserver_client_check_redraw(c);\n\t\t\tserver_client_reset_state(c);\n\t\t}\n\t}\n\n\t/*\n\t * Any windows will have been redrawn as part of clients, so clear\n\t * their flags now.\n\t */\n\tRB_FOREACH(w, windows, &windows) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->fd != -1) {\n\t\t\t\tserver_client_check_pane_resize(wp);\n\t\t\t\tserver_client_check_pane_buffer(wp);\n\t\t\t}\n\t\t\twp->flags &= ~(PANE_REDRAW|PANE_REDRAWSCROLLBAR);\n\t\t}\n\t\tcheck_window_name(w);\n\t}\n}\n\n/* Check if window needs to be resized. */\nstatic void\nserver_client_check_window_resize(struct window *w)\n{\n\tstruct winlink\t*wl;\n\n\tif (~w->flags & WINDOW_RESIZE)\n\t\treturn;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session->attached != 0 && wl->session->curw == wl)\n\t\t\tbreak;\n\t}\n\tif (wl == NULL)\n\t\treturn;\n\n\tlog_debug(\"%s: resizing window @%u\", __func__, w->id);\n\tresize_window(w, w->new_sx, w->new_sy, w->new_xpixel, w->new_ypixel);\n}\n\n/* Resize timer event. */\nstatic void\nserver_client_resize_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\n\tlog_debug(\"%s: %%%u resize timer expired\", __func__, wp->id);\n\tevtimer_del(&wp->resize_timer);\n}\n\n/* Check if pane should be resized. */\nstatic void\nserver_client_check_pane_resize(struct window_pane *wp)\n{\n\tstruct window_pane_resize\t*r;\n\tstruct window_pane_resize\t*r1;\n\tstruct window_pane_resize\t*first;\n\tstruct window_pane_resize\t*last;\n\tstruct timeval\t\t\t tv = { .tv_usec = 250000 };\n\n\tif (TAILQ_EMPTY(&wp->resize_queue))\n\t\treturn;\n\n\tif (!event_initialized(&wp->resize_timer))\n\t\tevtimer_set(&wp->resize_timer, server_client_resize_timer, wp);\n\tif (evtimer_pending(&wp->resize_timer, NULL))\n\t\treturn;\n\n\tlog_debug(\"%s: %%%u needs to be resized\", __func__, wp->id);\n\tTAILQ_FOREACH(r, &wp->resize_queue, entry) {\n\t\tlog_debug(\"queued resize: %ux%u -> %ux%u\", r->osx, r->osy,\n\t\t    r->sx, r->sy);\n\t}\n\n\t/*\n\t * There are three cases that matter:\n\t *\n\t * - Only one resize. It can just be applied.\n\t *\n\t * - Multiple resizes and the ending size is different from the\n\t *   starting size. We can discard all resizes except the most recent.\n\t *\n\t * - Multiple resizes and the ending size is the same as the starting\n\t *   size. We must resize at least twice to force the application to\n\t *   redraw. So apply the first and leave the last on the queue for\n\t *   next time.\n\t */\n\tfirst = TAILQ_FIRST(&wp->resize_queue);\n\tlast = TAILQ_LAST(&wp->resize_queue, window_pane_resizes);\n\tif (first == last) {\n\t\t/* Only one resize. */\n\t\twindow_pane_send_resize(wp, first->sx, first->sy);\n\t\tTAILQ_REMOVE(&wp->resize_queue, first, entry);\n\t\tfree(first);\n\t} else if (last->sx != first->osx || last->sy != first->osy) {\n\t\t/* Multiple resizes ending up with a different size. */\n\t\twindow_pane_send_resize(wp, last->sx, last->sy);\n\t\tTAILQ_FOREACH_SAFE(r, &wp->resize_queue, entry, r1) {\n\t\t\tTAILQ_REMOVE(&wp->resize_queue, r, entry);\n\t\t\tfree(r);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Multiple resizes ending up with the same size. There will\n\t\t * not be more than one to the same size in succession so we\n\t\t * can just use the last-but-one on the list and leave the last\n\t\t * for later. We reduce the time until the next check to avoid\n\t\t * a long delay between the resizes.\n\t\t */\n\t\tr = TAILQ_PREV(last, window_pane_resizes, entry);\n\t\twindow_pane_send_resize(wp, r->sx, r->sy);\n\t\tTAILQ_FOREACH_SAFE(r, &wp->resize_queue, entry, r1) {\n\t\t\tif (r == last)\n\t\t\t\tbreak;\n\t\t\tTAILQ_REMOVE(&wp->resize_queue, r, entry);\n\t\t\tfree(r);\n\t\t}\n\t\ttv.tv_usec = 10000;\n\t}\n\tevtimer_add(&wp->resize_timer, &tv);\n}\n\n/* Check pane buffer size. */\nstatic void\nserver_client_check_pane_buffer(struct window_pane *wp)\n{\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tsize_t\t\t\t\t minimum;\n\tstruct client\t\t\t*c;\n\tstruct window_pane_offset\t*wpo;\n\tint\t\t\t\t off = 1, flag;\n\tu_int\t\t\t\t attached_clients = 0;\n\tsize_t\t\t\t\t new_size;\n\n\t/*\n\t * Work out the minimum used size. This is the most that can be removed\n\t * from the buffer.\n\t */\n\tminimum = wp->offset.used;\n\tif (wp->pipe_fd != -1 && wp->pipe_offset.used < minimum)\n\t\tminimum = wp->pipe_offset.used;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL)\n\t\t\tcontinue;\n\t\tattached_clients++;\n\n\t\tif (~c->flags & CLIENT_CONTROL) {\n\t\t\toff = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twpo = control_pane_offset(c, wp, &flag);\n\t\tif (wpo == NULL) {\n\t\t\tif (!flag)\n\t\t\t\toff = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!flag)\n\t\t\toff = 0;\n\n\t\twindow_pane_get_new_data(wp, wpo, &new_size);\n\t\tlog_debug(\"%s: %s has %zu bytes used and %zu left for %%%u\",\n\t\t    __func__, c->name, wpo->used - wp->base_offset, new_size,\n\t\t    wp->id);\n\t\tif (wpo->used < minimum)\n\t\t\tminimum = wpo->used;\n\t}\n\tif (attached_clients == 0)\n\t\toff = 0;\n\tminimum -= wp->base_offset;\n\tif (minimum == 0)\n\t\tgoto out;\n\n\t/* Drain the buffer. */\n\tlog_debug(\"%s: %%%u has %zu minimum (of %zu) bytes used\", __func__,\n\t    wp->id, minimum, EVBUFFER_LENGTH(evb));\n\tevbuffer_drain(evb, minimum);\n\n\t/*\n\t * Adjust the base offset. If it would roll over, all the offsets into\n\t * the buffer need to be adjusted.\n\t */\n\tif (wp->base_offset > SIZE_MAX - minimum) {\n\t\tlog_debug(\"%s: %%%u base offset has wrapped\", __func__, wp->id);\n\t\twp->offset.used -= wp->base_offset;\n\t\tif (wp->pipe_fd != -1)\n\t\t\twp->pipe_offset.used -= wp->base_offset;\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->session == NULL || (~c->flags & CLIENT_CONTROL))\n\t\t\t\tcontinue;\n\t\t\twpo = control_pane_offset(c, wp, &flag);\n\t\t\tif (wpo != NULL && !flag)\n\t\t\t\twpo->used -= wp->base_offset;\n\t\t}\n\t\twp->base_offset = minimum;\n\t} else\n\t\twp->base_offset += minimum;\n\nout:\n\t/*\n\t * If there is data remaining, and there are no clients able to consume\n\t * it, do not read any more. This is true when there are attached\n\t * clients, all of which are control clients which are not able to\n\t * accept any more data.\n\t */\n\tlog_debug(\"%s: pane %%%u is %s\", __func__, wp->id, off ? \"off\" : \"on\");\n\tif (off)\n\t\tbufferevent_disable(wp->event, EV_READ);\n\telse\n\t\tbufferevent_enable(wp->event, EV_READ);\n}\n\n/*\n * Update cursor position and mode settings. The scroll region and attributes\n * are cleared when idle (waiting for an event) as this is the most likely time\n * a user may interrupt tmux, for example with ~^Z in ssh(1). This is a\n * compromise between excessive resets and likelihood of an interrupt.\n *\n * tty_region/tty_reset/tty_update_mode already take care of not resetting\n * things that are already in their default state.\n */\nstatic void\nserver_client_reset_state(struct client *c)\n{\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp = server_client_get_pane(c), *loop;\n\tstruct screen\t\t*s = NULL;\n\tstruct options\t\t*oo = c->session->options;\n\tint\t\t\t mode = 0, cursor, flags, n;\n\tu_int\t\t\t cx = 0, cy = 0, ox, oy, sx, sy;\n\n\tif (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))\n\t\treturn;\n\n\t/* Disable the block flag. */\n\tflags = (tty->flags & TTY_BLOCK);\n\ttty->flags &= ~TTY_BLOCK;\n\n\t/* Get mode from overlay if any, else from screen. */\n\tif (c->overlay_draw != NULL) {\n\t\tif (c->overlay_mode != NULL)\n\t\t\ts = c->overlay_mode(c, c->overlay_data, &cx, &cy);\n\t} else if (c->prompt_string == NULL)\n\t\ts = wp->screen;\n\telse\n\t\ts = c->status.active;\n\tif (s != NULL)\n\t\tmode = s->mode;\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"%s: client %s mode %s\", __func__, c->name,\n\t\t    screen_mode_to_string(mode));\n\t}\n\n\t/* Reset region and margin. */\n\ttty_region_off(tty);\n\ttty_margin_off(tty);\n\n\t/* Move cursor to pane cursor and offset. */\n\tif (c->prompt_string != NULL) {\n\t\tn = options_get_number(oo, \"status-position\");\n\t\tif (n == 0)\n\t\t\tcy = 0;\n\t\telse {\n\t\t\tn = status_line_size(c);\n\t\t\tif (n == 0)\n\t\t\t\tcy = tty->sy - 1;\n\t\t\telse\n\t\t\t\tcy = tty->sy - n;\n\t\t}\n\t\tcx = c->prompt_cursor;\n\t} else if (c->overlay_draw == NULL) {\n\t\tcursor = 0;\n\t\ttty_window_offset(tty, &ox, &oy, &sx, &sy);\n\t\tif (wp->xoff + s->cx >= ox && wp->xoff + s->cx <= ox + sx &&\n\t\t    wp->yoff + s->cy >= oy && wp->yoff + s->cy <= oy + sy) {\n\t\t\tcursor = 1;\n\n\t\t\tcx = wp->xoff + s->cx - ox;\n\t\t\tcy = wp->yoff + s->cy - oy;\n\n\t\t\tif (status_at_line(c) == 0)\n\t\t\t\tcy += status_line_size(c);\n\t\t}\n\t\tif (!cursor)\n\t\t\tmode &= ~MODE_CURSOR;\n\t}\n\tlog_debug(\"%s: cursor to %u,%u\", __func__, cx, cy);\n\ttty_cursor(tty, cx, cy);\n\n\t/*\n\t * Set mouse mode if requested. To support dragging, always use button\n\t * mode.\n\t */\n\tif (options_get_number(oo, \"mouse\")) {\n\t\tif (c->overlay_draw == NULL) {\n\t\t\tmode &= ~ALL_MOUSE_MODES;\n\t\t\tTAILQ_FOREACH(loop, &w->panes, entry) {\n\t\t\t\tif (loop->screen->mode & MODE_MOUSE_ALL)\n\t\t\t\t\tmode |= MODE_MOUSE_ALL;\n\t\t\t}\n\t\t}\n\t\tif (~mode & MODE_MOUSE_ALL)\n\t\t\tmode |= MODE_MOUSE_BUTTON;\n\t}\n\n\t/* Clear bracketed paste mode if at the prompt. */\n\tif (c->overlay_draw == NULL && c->prompt_string != NULL)\n\t\tmode &= ~MODE_BRACKETPASTE;\n\n\t/* Set the terminal mode and reset attributes. */\n\ttty_update_mode(tty, mode, s);\n\ttty_reset(tty);\n\n\t/* All writing must be done, send a sync end (if it was started). */\n\ttty_sync_end(tty);\n\ttty->flags |= flags;\n}\n\n/* Repeat time callback. */\nstatic void\nserver_client_repeat_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct client\t*c = data;\n\n\tif (c->flags & CLIENT_REPEAT) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tc->flags &= ~CLIENT_REPEAT;\n\t\tserver_status_client(c);\n\t}\n}\n\n/* Double-click callback. */\nstatic void\nserver_client_click_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct client\t\t*c = data;\n\tstruct key_event\t*event;\n\n\tlog_debug(\"click timer expired\");\n\n\tif (c->flags & CLIENT_TRIPLECLICK) {\n\t\t/*\n\t\t * Waiting for a third click that hasn't happened, so this must\n\t\t * have been a double click.\n\t\t */\n\t\tevent = xcalloc(1, sizeof *event);\n\t\tevent->key = KEYC_DOUBLECLICK;\n\t\tmemcpy(&event->m, &c->click_event, sizeof event->m);\n\t\tif (!server_client_handle_key(c, event)) {\n\t\t\tfree(event->buf);\n\t\t\tfree(event);\n\t\t}\n\t}\n\tc->flags &= ~(CLIENT_DOUBLECLICK|CLIENT_TRIPLECLICK);\n}\n\n/* Check if client should be exited. */\nstatic void\nserver_client_check_exit(struct client *c)\n{\n\tstruct client_file\t*cf;\n\tconst char\t\t*name = c->exit_session;\n\tchar\t\t\t*data;\n\tsize_t\t\t\t size, msize;\n\n\tif (c->flags & (CLIENT_DEAD|CLIENT_EXITED))\n\t\treturn;\n\tif (~c->flags & CLIENT_EXIT)\n\t\treturn;\n\n\tif (c->flags & CLIENT_CONTROL) {\n\t\tcontrol_discard(c);\n\t\tif (!control_all_done(c))\n\t\t\treturn;\n\t}\n\tRB_FOREACH(cf, client_files, &c->files) {\n\t\tif (EVBUFFER_LENGTH(cf->buffer) != 0)\n\t\t\treturn;\n\t}\n\tc->flags |= CLIENT_EXITED;\n\n\tswitch (c->exit_type) {\n\tcase CLIENT_EXIT_RETURN:\n\t\tif (c->exit_message != NULL)\n\t\t\tmsize = strlen(c->exit_message) + 1;\n\t\telse\n\t\t\tmsize = 0;\n\t\tsize = (sizeof c->retval) + msize;\n\t\tdata = xmalloc(size);\n\t\tmemcpy(data, &c->retval, sizeof c->retval);\n\t\tif (c->exit_message != NULL)\n\t\t\tmemcpy(data + sizeof c->retval, c->exit_message, msize);\n\t\tproc_send(c->peer, MSG_EXIT, -1, data, size);\n\t\tfree(data);\n\t\tbreak;\n\tcase CLIENT_EXIT_SHUTDOWN:\n\t\tproc_send(c->peer, MSG_SHUTDOWN, -1, NULL, 0);\n\t\tbreak;\n\tcase CLIENT_EXIT_DETACH:\n\t\tproc_send(c->peer, c->exit_msgtype, -1, name, strlen(name) + 1);\n\t\tbreak;\n\t}\n\tfree(c->exit_session);\n\tfree(c->exit_message);\n}\n\n/* Redraw timer callback. */\nstatic void\nserver_client_redraw_timer(__unused int fd, __unused short events,\n    __unused void *data)\n{\n\tlog_debug(\"redraw timer fired\");\n}\n\n/*\n * Check if modes need to be updated. Only modes in the current window are\n * updated and it is done when the status line is redrawn.\n */\nstatic void\nserver_client_check_modes(struct client *c)\n{\n\tstruct window\t\t\t*w = c->session->curw->window;\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\n\tif (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))\n\t\treturn;\n\tif (~c->flags & CLIENT_REDRAWSTATUS)\n\t\treturn;\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\twme = TAILQ_FIRST(&wp->modes);\n\t\tif (wme != NULL && wme->mode->update != NULL)\n\t\t\twme->mode->update(wme);\n\t}\n}\n\n/* Check for client redraws. */\nstatic void\nserver_client_check_redraw(struct client *c)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\tint\t\t\t needed, tty_flags, mode = tty->mode;\n\tuint64_t\t\t client_flags = 0;\n\tint\t\t\t redraw_pane, redraw_scrollbar_only;\n\tu_int\t\t\t bit = 0;\n\tstruct timeval\t\t tv = { .tv_usec = 1000 };\n\tstatic struct event\t ev;\n\tsize_t\t\t\t left;\n\n\tif (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))\n\t\treturn;\n\tif (c->flags & CLIENT_ALLREDRAWFLAGS) {\n\t\tlog_debug(\"%s: redraw%s%s%s%s%s%s\", c->name,\n\t\t    (c->flags & CLIENT_REDRAWWINDOW) ? \" window\" : \"\",\n\t\t    (c->flags & CLIENT_REDRAWSTATUS) ? \" status\" : \"\",\n\t\t    (c->flags & CLIENT_REDRAWBORDERS) ? \" borders\" : \"\",\n\t\t    (c->flags & CLIENT_REDRAWOVERLAY) ? \" overlay\" : \"\",\n\t\t    (c->flags & CLIENT_REDRAWPANES) ? \" panes\" : \"\",\n\t\t    (c->flags & CLIENT_REDRAWSCROLLBARS) ? \" scrollbars\" : \"\");\n\t}\n\n\t/*\n\t * If there is outstanding data, defer the redraw until it has been\n\t * consumed. We can just add a timer to get out of the event loop and\n\t * end up back here.\n\t */\n\tneeded = 0;\n\tif (c->flags & CLIENT_ALLREDRAWFLAGS)\n\t\tneeded = 1;\n\telse {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->flags & PANE_REDRAW) {\n\t\t\t\tneeded = 1;\n\t\t\t\tclient_flags |= CLIENT_REDRAWPANES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wp->flags & PANE_REDRAWSCROLLBAR) {\n\t\t\t\tneeded = 1;\n\t\t\t\tclient_flags |= CLIENT_REDRAWSCROLLBARS;\n\t\t\t\t/* no break - later panes may need redraw */\n\t\t\t}\n\t\t}\n\t}\n\tif (needed && (left = EVBUFFER_LENGTH(tty->out)) != 0) {\n\t\tlog_debug(\"%s: redraw deferred (%zu left)\", c->name, left);\n\t\tif (!evtimer_initialized(&ev))\n\t\t\tevtimer_set(&ev, server_client_redraw_timer, NULL);\n\t\tif (!evtimer_pending(&ev, NULL)) {\n\t\t\tlog_debug(\"redraw timer started\");\n\t\t\tevtimer_add(&ev, &tv);\n\t\t}\n\n\t\tif (~c->flags & CLIENT_REDRAWWINDOW) {\n\t\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\t\tif (wp->flags & (PANE_REDRAW)) {\n\t\t\t\t\tlog_debug(\"%s: pane %%%u needs redraw\",\n\t\t\t\t\t    c->name, wp->id);\n\t\t\t\t\tc->redraw_panes |= (1 << bit);\n\t\t\t\t} else if (wp->flags & PANE_REDRAWSCROLLBAR) {\n\t\t\t\t\tlog_debug(\"%s: pane %%%u scrollbar \"\n\t\t\t\t\t    \"needs redraw\", c->name, wp->id);\n\t\t\t\t\tc->redraw_scrollbars |= (1 << bit);\n\t\t\t\t}\n\t\t\t\tif (++bit == 64) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If more that 64 panes, give up and\n\t\t\t\t\t * just redraw the window.\n\t\t\t\t\t */\n\t\t\t\t\tclient_flags &= ~(CLIENT_REDRAWPANES|\n\t\t\t\t\t    CLIENT_REDRAWSCROLLBARS);\n\t\t\t\t\tclient_flags |= CLIENT_REDRAWWINDOW;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c->redraw_panes != 0)\n\t\t\t\tc->flags |= CLIENT_REDRAWPANES;\n\t\t\tif (c->redraw_scrollbars != 0)\n\t\t\t\tc->flags |= CLIENT_REDRAWSCROLLBARS;\n\t\t}\n\t\tc->flags |= client_flags;\n\t\treturn;\n\t} else if (needed)\n\t\tlog_debug(\"%s: redraw needed\", c->name);\n\n\ttty_flags = tty->flags & (TTY_BLOCK|TTY_FREEZE|TTY_NOCURSOR);\n\ttty->flags = (tty->flags & ~(TTY_BLOCK|TTY_FREEZE))|TTY_NOCURSOR;\n\n\tif (~c->flags & CLIENT_REDRAWWINDOW) {\n\t\t/*\n\t\t * If not redrawing the entire window, check whether each pane\n\t\t * needs to be redrawn.\n\t\t */\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tredraw_pane = 0;\n\t\t\tredraw_scrollbar_only = 0;\n\t\t\tif (wp->flags & PANE_REDRAW)\n\t\t\t\tredraw_pane = 1;\n\t\t\telse if (c->flags & CLIENT_REDRAWPANES) {\n\t\t\t\tif (c->redraw_panes & (1 << bit))\n\t\t\t\t\tredraw_pane = 1;\n\t\t\t} else if (c->flags & CLIENT_REDRAWSCROLLBARS) {\n\t\t\t\tif (c->redraw_scrollbars & (1 << bit))\n\t\t\t\t\tredraw_scrollbar_only = 1;\n\t\t\t}\n\t\t\tbit++;\n\t\t\tif (!redraw_pane && !redraw_scrollbar_only)\n\t\t\t\tcontinue;\n\t\t\tif (redraw_scrollbar_only) {\n\t\t\t\tlog_debug(\"%s: redrawing (scrollbar only) pane \"\n\t\t\t\t    \"%%%u\", __func__, wp->id);\n\t\t\t} else {\n\t\t\t\tlog_debug(\"%s: redrawing pane %%%u\", __func__,\n\t\t\t\t    wp->id);\n\t\t\t}\n\t\t\tscreen_redraw_pane(c, wp, redraw_scrollbar_only);\n\t\t}\n\t\tc->redraw_panes = 0;\n\t\tc->redraw_scrollbars = 0;\n\t\tc->flags &= ~(CLIENT_REDRAWPANES|CLIENT_REDRAWSCROLLBARS);\n\t}\n\n\tif (c->flags & CLIENT_ALLREDRAWFLAGS) {\n\t\tif (options_get_number(s->options, \"set-titles\")) {\n\t\t\tserver_client_set_title(c);\n\t\t\tserver_client_set_path(c);\n\t\t}\n\t\tscreen_redraw_screen(c);\n\t}\n\n\ttty->flags = (tty->flags & ~TTY_NOCURSOR)|(tty_flags & TTY_NOCURSOR);\n\ttty_update_mode(tty, mode, NULL);\n\ttty->flags = (tty->flags & ~(TTY_BLOCK|TTY_FREEZE|TTY_NOCURSOR))|\n\t    tty_flags;\n\n\tc->flags &= ~(CLIENT_ALLREDRAWFLAGS|CLIENT_STATUSFORCE);\n\n\tif (needed) {\n\t\t/*\n\t\t * We would have deferred the redraw unless the output buffer\n\t\t * was empty, so we can record how many bytes the redraw\n\t\t * generated.\n\t\t */\n\t\tc->redraw = EVBUFFER_LENGTH(tty->out);\n\t\tlog_debug(\"%s: redraw added %zu bytes\", c->name, c->redraw);\n\t}\n}\n\n/* Set client title. */\nstatic void\nserver_client_set_title(struct client *c)\n{\n\tstruct session\t\t*s = c->session;\n\tconst char\t\t*template;\n\tchar\t\t\t*title;\n\tstruct format_tree\t*ft;\n\n\ttemplate = options_get_string(s->options, \"set-titles-string\");\n\n\tft = format_create(c, NULL, FORMAT_NONE, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\ttitle = format_expand_time(ft, template);\n\tif (c->title == NULL || strcmp(title, c->title) != 0) {\n\t\tfree(c->title);\n\t\tc->title = xstrdup(title);\n\t\ttty_set_title(&c->tty, c->title);\n\t}\n\tfree(title);\n\n\tformat_free(ft);\n}\n\n/* Set client path. */\nstatic void\nserver_client_set_path(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\tconst char\t*path;\n\n\tif (s->curw == NULL)\n\t\treturn;\n\tif (s->curw->window->active->base.path == NULL)\n\t\tpath = \"\";\n\telse\n\t\tpath = s->curw->window->active->base.path;\n\tif (c->path == NULL || strcmp(path, c->path) != 0) {\n\t\tfree(c->path);\n\t\tc->path = xstrdup(path);\n\t\ttty_set_path(&c->tty, c->path);\n\t}\n}\n\n/* Dispatch message from client. */\nstatic void\nserver_client_dispatch(struct imsg *imsg, void *arg)\n{\n\tstruct client\t*c = arg;\n\tssize_t\t\t datalen;\n\tstruct session\t*s;\n\n\tif (c->flags & CLIENT_DEAD)\n\t\treturn;\n\n\tif (imsg == NULL) {\n\t\tserver_client_lost(c);\n\t\treturn;\n\t}\n\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_IDENTIFY_CLIENTPID:\n\tcase MSG_IDENTIFY_CWD:\n\tcase MSG_IDENTIFY_ENVIRON:\n\tcase MSG_IDENTIFY_FEATURES:\n\tcase MSG_IDENTIFY_FLAGS:\n\tcase MSG_IDENTIFY_LONGFLAGS:\n\tcase MSG_IDENTIFY_STDIN:\n\tcase MSG_IDENTIFY_STDOUT:\n\tcase MSG_IDENTIFY_TERM:\n\tcase MSG_IDENTIFY_TERMINFO:\n\tcase MSG_IDENTIFY_TTYNAME:\n\tcase MSG_IDENTIFY_DONE:\n\t\tserver_client_dispatch_identify(c, imsg);\n\t\tbreak;\n\tcase MSG_COMMAND:\n\t\tserver_client_dispatch_command(c, imsg);\n\t\tbreak;\n\tcase MSG_RESIZE:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_RESIZE size\");\n\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tbreak;\n\t\tserver_client_update_latest(c);\n\t\ttty_resize(&c->tty);\n\t\ttty_repeat_requests(&c->tty);\n\t\trecalculate_sizes();\n\t\tif (c->overlay_resize == NULL)\n\t\t\tserver_client_clear_overlay(c);\n\t\telse\n\t\t\tc->overlay_resize(c, c->overlay_data);\n\t\tserver_redraw_client(c);\n\t\tif (c->session != NULL)\n\t\t\tnotify_client(\"client-resized\", c);\n\t\tbreak;\n\tcase MSG_EXITING:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_EXITING size\");\n\t\tserver_client_set_session(c, NULL);\n\t\trecalculate_sizes();\n\t\ttty_close(&c->tty);\n\t\tproc_send(c->peer, MSG_EXITED, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_WAKEUP:\n\tcase MSG_UNLOCK:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_WAKEUP size\");\n\n\t\tif (!(c->flags & CLIENT_SUSPENDED))\n\t\t\tbreak;\n\t\tc->flags &= ~CLIENT_SUSPENDED;\n\n\t\tif (c->fd == -1 || c->session == NULL) /* exited already */\n\t\t\tbreak;\n\t\ts = c->session;\n\n\t\tif (gettimeofday(&c->activity_time, NULL) != 0)\n\t\t\tfatal(\"gettimeofday failed\");\n\n\t\ttty_start_tty(&c->tty);\n\t\tserver_redraw_client(c);\n\t\trecalculate_sizes();\n\n\t\tif (s != NULL)\n\t\t\tsession_update_activity(s, &c->activity_time);\n\t\tbreak;\n\tcase MSG_SHELL:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SHELL size\");\n\n\t\tserver_client_dispatch_shell(c);\n\t\tbreak;\n\tcase MSG_WRITE_READY:\n\t\tfile_write_ready(&c->files, imsg);\n\t\tbreak;\n\tcase MSG_READ:\n\t\tfile_read_data(&c->files, imsg);\n\t\tbreak;\n\tcase MSG_READ_DONE:\n\t\tfile_read_done(&c->files, imsg);\n\t\tbreak;\n\t}\n}\n\n/* Callback when command is not allowed. */\nstatic enum cmd_retval\nserver_client_read_only(struct cmdq_item *item, __unused void *data)\n{\n\tcmdq_error(item, \"client is read-only\");\n\treturn (CMD_RETURN_ERROR);\n}\n\n/* Callback when command is done. */\nstatic enum cmd_retval\nserver_client_command_done(struct cmdq_item *item, __unused void *data)\n{\n\tstruct client\t*c = cmdq_get_client(item);\n\n\tif (~c->flags & CLIENT_ATTACHED)\n\t\tc->flags |= CLIENT_EXIT;\n\telse if (~c->flags & CLIENT_EXIT) {\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tcontrol_ready(c);\n\t\ttty_send_requests(&c->tty);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Handle command message. */\nstatic void\nserver_client_dispatch_command(struct client *c, struct imsg *imsg)\n{\n\tstruct msg_command\t  data;\n\tchar\t\t\t *buf;\n\tsize_t\t\t\t  len;\n\tint\t\t\t  argc;\n\tchar\t\t\t**argv, *cause;\n\tstruct cmd_parse_result\t *pr;\n\tstruct args_value\t *values;\n\tstruct cmdq_item\t *new_item;\n\n\tif (c->flags & CLIENT_EXIT)\n\t\treturn;\n\n\tif (imsg->hdr.len - IMSG_HEADER_SIZE < sizeof data)\n\t\tfatalx(\"bad MSG_COMMAND size\");\n\tmemcpy(&data, imsg->data, sizeof data);\n\n\tbuf = (char *)imsg->data + sizeof data;\n\tlen = imsg->hdr.len  - IMSG_HEADER_SIZE - sizeof data;\n\tif (len > 0 && buf[len - 1] != '\\0')\n\t\tfatalx(\"bad MSG_COMMAND string\");\n\n\targc = data.argc;\n\tif (cmd_unpack_argv(buf, len, argc, &argv) != 0) {\n\t\tcause = xstrdup(\"command too long\");\n\t\tgoto error;\n\t}\n\n\tif (argc == 0) {\n\t\targc = 1;\n\t\targv = xcalloc(1, sizeof *argv);\n\t\t*argv = xstrdup(\"new-session\");\n\t}\n\n\tvalues = args_from_vector(argc, argv);\n\tpr = cmd_parse_from_arguments(values, argc, NULL);\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\tcause = pr->error;\n\t\tgoto error;\n\tcase CMD_PARSE_SUCCESS:\n\t\tbreak;\n\t}\n\targs_free_values(values, argc);\n\tfree(values);\n\tcmd_free_argv(argc, argv);\n\n\tif ((c->flags & CLIENT_READONLY) &&\n\t    !cmd_list_all_have(pr->cmdlist, CMD_READONLY))\n\t\tnew_item = cmdq_get_callback(server_client_read_only, NULL);\n\telse\n\t\tnew_item = cmdq_get_command(pr->cmdlist, NULL);\n\tcmdq_append(c, new_item);\n\tcmdq_append(c, cmdq_get_callback(server_client_command_done, NULL));\n\n\tcmd_list_free(pr->cmdlist);\n\treturn;\n\nerror:\n\tcmd_free_argv(argc, argv);\n\n\tcmdq_append(c, cmdq_get_error(cause));\n\tfree(cause);\n\n\tc->flags |= CLIENT_EXIT;\n}\n\n/* Handle identify message. */\nstatic void\nserver_client_dispatch_identify(struct client *c, struct imsg *imsg)\n{\n\tconst char\t*data, *home;\n\tsize_t\t\t datalen;\n\tint\t\t flags, feat;\n\tuint64_t\t longflags;\n\tchar\t\t*name;\n\n\tif (c->flags & CLIENT_IDENTIFIED)\n\t\tfatalx(\"out-of-order identify message\");\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type)\t{\n\tcase MSG_IDENTIFY_FEATURES:\n\t\tif (datalen != sizeof feat)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_FEATURES size\");\n\t\tmemcpy(&feat, data, sizeof feat);\n\t\tc->term_features |= feat;\n\t\tlog_debug(\"client %p IDENTIFY_FEATURES %s\", c,\n\t\t    tty_get_features(feat));\n\t\tbreak;\n\tcase MSG_IDENTIFY_FLAGS:\n\t\tif (datalen != sizeof flags)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_FLAGS size\");\n\t\tmemcpy(&flags, data, sizeof flags);\n\t\tc->flags |= flags;\n\t\tlog_debug(\"client %p IDENTIFY_FLAGS %#x\", c, flags);\n\t\tbreak;\n\tcase MSG_IDENTIFY_LONGFLAGS:\n\t\tif (datalen != sizeof longflags)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_LONGFLAGS size\");\n\t\tmemcpy(&longflags, data, sizeof longflags);\n\t\tc->flags |= longflags;\n\t\tlog_debug(\"client %p IDENTIFY_LONGFLAGS %#llx\", c,\n\t\t    (unsigned long long)longflags);\n\t\tbreak;\n\tcase MSG_IDENTIFY_TERM:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_TERM string\");\n\t\tif (*data == '\\0')\n\t\t\tc->term_name = xstrdup(\"unknown\");\n\t\telse\n\t\t\tc->term_name = xstrdup(data);\n\t\tlog_debug(\"client %p IDENTIFY_TERM %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_TERMINFO:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_TERMINFO string\");\n\t\tc->term_caps = xreallocarray(c->term_caps, c->term_ncaps + 1,\n\t\t    sizeof *c->term_caps);\n\t\tc->term_caps[c->term_ncaps++] = xstrdup(data);\n\t\tlog_debug(\"client %p IDENTIFY_TERMINFO %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_TTYNAME:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_TTYNAME string\");\n\t\tc->ttyname = xstrdup(data);\n\t\tlog_debug(\"client %p IDENTIFY_TTYNAME %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_CWD:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_CWD string\");\n\t\tif (access(data, X_OK) == 0)\n\t\t\tc->cwd = xstrdup(data);\n\t\telse if ((home = find_home()) != NULL)\n\t\t\tc->cwd = xstrdup(home);\n\t\telse\n\t\t\tc->cwd = xstrdup(\"/\");\n\t\tlog_debug(\"client %p IDENTIFY_CWD %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_STDIN:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_STDIN size\");\n\t\tc->fd = imsg_get_fd(imsg);\n\t\tlog_debug(\"client %p IDENTIFY_STDIN %d\", c, c->fd);\n\t\tbreak;\n\tcase MSG_IDENTIFY_STDOUT:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_STDOUT size\");\n\t\tc->out_fd = imsg_get_fd(imsg);\n\t\tlog_debug(\"client %p IDENTIFY_STDOUT %d\", c, c->out_fd);\n\t\tbreak;\n\tcase MSG_IDENTIFY_ENVIRON:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_ENVIRON string\");\n\t\tif (strchr(data, '=') != NULL)\n\t\t\tenviron_put(c->environ, data, 0);\n\t\tlog_debug(\"client %p IDENTIFY_ENVIRON %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_CLIENTPID:\n\t\tif (datalen != sizeof c->pid)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_CLIENTPID size\");\n\t\tmemcpy(&c->pid, data, sizeof c->pid);\n\t\tlog_debug(\"client %p IDENTIFY_CLIENTPID %ld\", c, (long)c->pid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (imsg->hdr.type != MSG_IDENTIFY_DONE)\n\t\treturn;\n\tc->flags |= CLIENT_IDENTIFIED;\n\n\tif (*c->ttyname != '\\0')\n\t\tname = xstrdup(c->ttyname);\n\telse\n\t\txasprintf(&name, \"client-%ld\", (long)c->pid);\n\tc->name = name;\n\tlog_debug(\"client %p name is %s\", c, c->name);\n\n#ifdef __CYGWIN__\n\tc->fd = open(c->ttyname, O_RDWR|O_NOCTTY);\n\tc->out_fd = dup(c->fd);\n#endif\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\tcontrol_start(c);\n\telse if (c->fd != -1) {\n\t\tif (tty_init(&c->tty, c) != 0) {\n\t\t\tclose(c->fd);\n\t\t\tc->fd = -1;\n\t\t} else {\n\t\t\ttty_resize(&c->tty);\n\t\t\tc->flags |= CLIENT_TERMINAL;\n\t\t}\n\t\tclose(c->out_fd);\n\t\tc->out_fd = -1;\n\t}\n\n\t/*\n\t * If this is the first client, load configuration files. Any later\n\t * clients are allowed to continue with their command even if the\n\t * config has not been loaded - they might have been run from inside it\n\t */\n\tif ((~c->flags & CLIENT_EXIT) &&\n\t     !cfg_finished &&\n\t     c == TAILQ_FIRST(&clients))\n\t\tstart_cfg();\n}\n\n/* Handle shell message. */\nstatic void\nserver_client_dispatch_shell(struct client *c)\n{\n\tconst char\t*shell;\n\n\tshell = options_get_string(global_s_options, \"default-shell\");\n\tif (!checkshell(shell))\n\t\tshell = _PATH_BSHELL;\n\tproc_send(c->peer, MSG_SHELL, -1, shell, strlen(shell) + 1);\n\n\tproc_kill_peer(c->peer);\n}\n\n/* Get client working directory. */\nconst char *\nserver_client_get_cwd(struct client *c, struct session *s)\n{\n\tconst char\t*home;\n\n\tif (!cfg_finished && cfg_client != NULL)\n\t\treturn (cfg_client->cwd);\n\tif (c != NULL && c->session == NULL && c->cwd != NULL)\n\t\treturn (c->cwd);\n\tif (s != NULL && s->cwd != NULL)\n\t\treturn (s->cwd);\n\tif (c != NULL && (s = c->session) != NULL && s->cwd != NULL)\n\t\treturn (s->cwd);\n\tif ((home = find_home()) != NULL)\n\t\treturn (home);\n\treturn (\"/\");\n}\n\n/* Get control client flags. */\nstatic uint64_t\nserver_client_control_flags(struct client *c, const char *next)\n{\n\tif (strcmp(next, \"pause-after\") == 0) {\n\t\tc->pause_age = 0;\n\t\treturn (CLIENT_CONTROL_PAUSEAFTER);\n\t}\n\tif (sscanf(next, \"pause-after=%u\", &c->pause_age) == 1) {\n\t\tc->pause_age *= 1000;\n\t\treturn (CLIENT_CONTROL_PAUSEAFTER);\n\t}\n\tif (strcmp(next, \"no-output\") == 0)\n\t\treturn (CLIENT_CONTROL_NOOUTPUT);\n\tif (strcmp(next, \"wait-exit\") == 0)\n\t\treturn (CLIENT_CONTROL_WAITEXIT);\n\treturn (0);\n}\n\n/* Set client flags. */\nvoid\nserver_client_set_flags(struct client *c, const char *flags)\n{\n\tchar\t*s, *copy, *next;\n\tuint64_t flag;\n\tint\t not;\n\n\ts = copy = xstrdup(flags);\n\twhile ((next = strsep(&s, \",\")) != NULL) {\n\t\tnot = (*next == '!');\n\t\tif (not)\n\t\t\tnext++;\n\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tflag = server_client_control_flags(c, next);\n\t\telse\n\t\t\tflag = 0;\n\t\tif (strcmp(next, \"read-only\") == 0)\n\t\t\tflag = CLIENT_READONLY;\n\t\telse if (strcmp(next, \"ignore-size\") == 0)\n\t\t\tflag = CLIENT_IGNORESIZE;\n\t\telse if (strcmp(next, \"active-pane\") == 0)\n\t\t\tflag = CLIENT_ACTIVEPANE;\n\t\telse if (strcmp(next, \"no-detach-on-destroy\") == 0)\n\t\t\tflag = CLIENT_NO_DETACH_ON_DESTROY;\n\t\tif (flag == 0)\n\t\t\tcontinue;\n\n\t\tlog_debug(\"client %s set flag %s\", c->name, next);\n\t\tif (not) {\n\t\t\tif (c->flags & CLIENT_READONLY)\n\t\t\t\tflag &= ~CLIENT_READONLY;\n\t\t\tc->flags &= ~flag;\n\t\t} else\n\t\t\tc->flags |= flag;\n\t\tif (flag == CLIENT_CONTROL_NOOUTPUT)\n\t\t\tcontrol_reset_offsets(c);\n\t}\n\tfree(copy);\n\tproc_send(c->peer, MSG_FLAGS, -1, &c->flags, sizeof c->flags);\n}\n\n/* Get client flags. This is only flags useful to show to users. */\nconst char *\nserver_client_get_flags(struct client *c)\n{\n\tstatic char\ts[256];\n\tchar\t\ttmp[32];\n\n\t*s = '\\0';\n\tif (c->flags & CLIENT_ATTACHED)\n\t\tstrlcat(s, \"attached,\", sizeof s);\n\tif (c->flags & CLIENT_FOCUSED)\n\t\tstrlcat(s, \"focused,\", sizeof s);\n\tif (c->flags & CLIENT_CONTROL)\n\t\tstrlcat(s, \"control-mode,\", sizeof s);\n\tif (c->flags & CLIENT_IGNORESIZE)\n\t\tstrlcat(s, \"ignore-size,\", sizeof s);\n\tif (c->flags & CLIENT_NO_DETACH_ON_DESTROY)\n\t\tstrlcat(s, \"no-detach-on-destroy,\", sizeof s);\n\tif (c->flags & CLIENT_CONTROL_NOOUTPUT)\n\t\tstrlcat(s, \"no-output,\", sizeof s);\n\tif (c->flags & CLIENT_CONTROL_WAITEXIT)\n\t\tstrlcat(s, \"wait-exit,\", sizeof s);\n\tif (c->flags & CLIENT_CONTROL_PAUSEAFTER) {\n\t\txsnprintf(tmp, sizeof tmp, \"pause-after=%u,\",\n\t\t    c->pause_age / 1000);\n\t\tstrlcat(s, tmp, sizeof s);\n\t}\n\tif (c->flags & CLIENT_READONLY)\n\t\tstrlcat(s, \"read-only,\", sizeof s);\n\tif (c->flags & CLIENT_ACTIVEPANE)\n\t\tstrlcat(s, \"active-pane,\", sizeof s);\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\tstrlcat(s, \"suspended,\", sizeof s);\n\tif (c->flags & CLIENT_UTF8)\n\t\tstrlcat(s, \"UTF-8,\", sizeof s);\n\tif (*s != '\\0')\n\t\ts[strlen(s) - 1] = '\\0';\n\treturn (s);\n}\n\n/* Get client window. */\nstruct client_window *\nserver_client_get_client_window(struct client *c, u_int id)\n{\n\tstruct client_window\tcw = { .window = id };\n\n\treturn (RB_FIND(client_windows, &c->windows, &cw));\n}\n\n/* Add client window. */\nstruct client_window *\nserver_client_add_client_window(struct client *c, u_int id)\n{\n\tstruct client_window\t*cw;\n\n\tcw = server_client_get_client_window(c, id);\n\tif (cw == NULL) {\n\t\tcw = xcalloc(1, sizeof *cw);\n\t\tcw->window = id;\n\t\tRB_INSERT(client_windows, &c->windows, cw);\n\t}\n\treturn (cw);\n}\n\n/* Get client active pane. */\nstruct window_pane *\nserver_client_get_pane(struct client *c)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct client_window\t*cw;\n\n\tif (s == NULL)\n\t\treturn (NULL);\n\n\tif (~c->flags & CLIENT_ACTIVEPANE)\n\t\treturn (s->curw->window->active);\n\tcw = server_client_get_client_window(c, s->curw->window->id);\n\tif (cw == NULL)\n\t\treturn (s->curw->window->active);\n\treturn (cw->pane);\n}\n\n/* Set client active pane. */\nvoid\nserver_client_set_pane(struct client *c, struct window_pane *wp)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct client_window\t*cw;\n\n\tif (s == NULL)\n\t\treturn;\n\n\tcw = server_client_add_client_window(c, s->curw->window->id);\n\tcw->pane = wp;\n\tlog_debug(\"%s pane now %%%u\", c->name, wp->id);\n}\n\n/* Remove pane from client lists. */\nvoid\nserver_client_remove_pane(struct window_pane *wp)\n{\n\tstruct client\t\t*c;\n\tstruct window\t\t*w = wp->window;\n\tstruct client_window\t*cw;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tcw = server_client_get_client_window(c, w->id);\n\t\tif (cw != NULL && cw->pane == wp) {\n\t\t\tRB_REMOVE(client_windows, &c->windows, cw);\n\t\t\tfree(cw);\n\t\t}\n\t}\n}\n\n/* Print to a client. */\nvoid\nserver_client_print(struct client *c, int parse, struct evbuffer *evb)\n{\n\tvoid\t\t\t\t*data = EVBUFFER_DATA(evb);\n\tsize_t\t\t\t\t size = EVBUFFER_LENGTH(evb);\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tchar\t\t\t\t*sanitized, *msg, *line, empty = '\\0';\n\n\tif (!parse) {\n\t\tutf8_stravisx(&msg, data, size,\n\t\t    VIS_OCTAL|VIS_CSTYLE|VIS_NOSLASH);\n\t} else {\n\t\tif (size == 0)\n\t\t\tmsg = &empty;\n\t\telse {\n\t\t\tmsg = EVBUFFER_DATA(evb);\n\t\t\tif (msg[size - 1] != '\\0')\n\t\t\t\tevbuffer_add(evb, \"\", 1);\n\t\t}\n\t}\n\tlog_debug(\"%s: %s\", __func__, msg);\n\n\tif (c == NULL)\n\t\tgoto out;\n\n\tif (c->session == NULL || (c->flags & CLIENT_CONTROL)) {\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\tsanitized = utf8_sanitize(msg);\n\t\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\t\tcontrol_write(c, \"%s\", sanitized);\n\t\t\telse\n\t\t\t\tfile_print(c, \"%s\\n\", sanitized);\n\t\t\tfree(sanitized);\n\t\t} else {\n\t\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\t\tcontrol_write(c, \"%s\", msg);\n\t\t\telse\n\t\t\t\tfile_print(c, \"%s\\n\", msg);\n\t\t}\n\t\tgoto out;\n\t}\n\n\twp = server_client_get_pane(c);\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->mode != &window_view_mode)\n\t\twindow_pane_set_mode(wp, NULL, &window_view_mode, NULL, NULL);\n\tif (parse) {\n\t\tdo {\n\t\t\tline = evbuffer_readln(evb, NULL, EVBUFFER_EOL_LF);\n\t\t\tif (line != NULL) {\n\t\t\t\twindow_copy_add(wp, 1, \"%s\", line);\n\t\t\t\tfree(line);\n\t\t\t}\n\t\t} while (line != NULL);\n\n\t\tsize = EVBUFFER_LENGTH(evb);\n\t\tif (size != 0) {\n\t\t\tline = EVBUFFER_DATA(evb);\n\t\t\twindow_copy_add(wp, 1, \"%.*s\", (int)size, line);\n\t\t}\n\t} else\n\t\twindow_copy_add(wp, 0, \"%s\", msg);\n\nout:\n\tif (!parse)\n\t\tfree(msg);\n}\n"
        },
        {
          "name": "server-fn.c",
          "type": "blob",
          "size": 10.8857421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic void\tserver_destroy_session_group(struct session *);\n\nvoid\nserver_redraw_client(struct client *c)\n{\n\tc->flags |= CLIENT_ALLREDRAWFLAGS;\n}\n\nvoid\nserver_status_client(struct client *c)\n{\n\tc->flags |= CLIENT_REDRAWSTATUS;\n}\n\nvoid\nserver_redraw_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_redraw_client(c);\n\t}\n}\n\nvoid\nserver_redraw_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_contains(s)) == NULL)\n\t\tserver_redraw_session(s);\n\telse {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\t\tserver_redraw_session(s);\n\t}\n}\n\nvoid\nserver_status_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_status_client(c);\n\t}\n}\n\nvoid\nserver_status_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_contains(s)) == NULL)\n\t\tserver_status_session(s);\n\telse {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\t\tserver_status_session(s);\n\t}\n}\n\nvoid\nserver_redraw_window(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && c->session->curw->window == w)\n\t\t\tserver_redraw_client(c);\n\t}\n}\n\nvoid\nserver_redraw_window_borders(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && c->session->curw->window == w)\n\t\t\tc->flags |= CLIENT_REDRAWBORDERS;\n\t}\n}\n\nvoid\nserver_status_window(struct window *w)\n{\n\tstruct session\t*s;\n\n\t/*\n\t * This is slightly different. We want to redraw the status line of any\n\t * clients containing this window rather than anywhere it is the\n\t * current window.\n\t */\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (session_has(s, w))\n\t\t\tserver_status_session(s);\n\t}\n}\n\nvoid\nserver_lock(void)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL)\n\t\t\tserver_lock_client(c);\n\t}\n}\n\nvoid\nserver_lock_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_lock_client(c);\n\t}\n}\n\nvoid\nserver_lock_client(struct client *c)\n{\n\tconst char\t*cmd;\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn;\n\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\tcmd = options_get_string(c->session->options, \"lock-command\");\n\tif (*cmd == '\\0' || strlen(cmd) + 1 > MAX_IMSGSIZE - IMSG_HEADER_SIZE)\n\t\treturn;\n\n\ttty_stop_tty(&c->tty);\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_SMCUP));\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_CLEAR));\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_E3));\n\n\tc->flags |= CLIENT_SUSPENDED;\n\tproc_send(c->peer, MSG_LOCK, -1, cmd, strlen(cmd) + 1);\n}\n\nvoid\nserver_kill_pane(struct window_pane *wp)\n{\n\tstruct window\t*w = wp->window;\n\n\tif (window_count_panes(w) == 1) {\n\t\tserver_kill_window(w, 1);\n\t\trecalculate_sizes();\n\t} else {\n\t\tserver_unzoom_window(w);\n\t\tserver_client_remove_pane(wp);\n\t\tlayout_close_pane(wp);\n\t\twindow_remove_pane(w, wp);\n\t\tserver_redraw_window(w);\n\t}\n}\n\nvoid\nserver_kill_window(struct window *w, int renumber)\n{\n\tstruct session\t*s, *s1;\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH_SAFE(s, sessions, &sessions, s1) {\n\t\tif (!session_has(s, w))\n\t\t\tcontinue;\n\n\t\tserver_unzoom_window(w);\n\t\twhile ((wl = winlink_find_by_window(&s->windows, w)) != NULL) {\n\t\t\tif (session_detach(s, wl)) {\n\t\t\t\tserver_destroy_session_group(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserver_redraw_session_group(s);\n\t\t}\n\n\t\tif (renumber)\n\t\t\tserver_renumber_session(s);\n\t}\n\trecalculate_sizes();\n}\n\nvoid\nserver_renumber_session(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif (options_get_number(s->options, \"renumber-windows\")) {\n\t\tif ((sg = session_group_contains(s)) != NULL) {\n\t\t\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\t\t    session_renumber_windows(s);\n\t\t} else\n\t\t\tsession_renumber_windows(s);\n\t}\n}\n\nvoid\nserver_renumber_all(void)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tserver_renumber_session(s);\n}\n\nint\nserver_link_window(struct session *src, struct winlink *srcwl,\n    struct session *dst, int dstidx, int killflag, int selectflag,\n    char **cause)\n{\n\tstruct winlink\t\t*dstwl;\n\tstruct session_group\t*srcsg, *dstsg;\n\n\tsrcsg = session_group_contains(src);\n\tdstsg = session_group_contains(dst);\n\tif (src != dst && srcsg != NULL && dstsg != NULL && srcsg == dstsg) {\n\t\txasprintf(cause, \"sessions are grouped\");\n\t\treturn (-1);\n\t}\n\n\tdstwl = NULL;\n\tif (dstidx != -1)\n\t\tdstwl = winlink_find_by_index(&dst->windows, dstidx);\n\tif (dstwl != NULL) {\n\t\tif (dstwl->window == srcwl->window) {\n\t\t\txasprintf(cause, \"same index: %d\", dstidx);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (killflag) {\n\t\t\t/*\n\t\t\t * Can't use session_detach as it will destroy session\n\t\t\t * if this makes it empty.\n\t\t\t */\n\t\t\tnotify_session_window(\"window-unlinked\", dst,\n\t\t\t    dstwl->window);\n\t\t\tdstwl->flags &= ~WINLINK_ALERTFLAGS;\n\t\t\twinlink_stack_remove(&dst->lastw, dstwl);\n\t\t\twinlink_remove(&dst->windows, dstwl);\n\n\t\t\t/* Force select/redraw if current. */\n\t\t\tif (dstwl == dst->curw) {\n\t\t\t\tselectflag = 1;\n\t\t\t\tdst->curw = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dstidx == -1)\n\t\tdstidx = -1 - options_get_number(dst->options, \"base-index\");\n\tdstwl = session_attach(dst, srcwl->window, dstidx, cause);\n\tif (dstwl == NULL)\n\t\treturn (-1);\n\n\tif (selectflag)\n\t\tsession_select(dst, dstwl->idx);\n\tserver_redraw_session_group(dst);\n\n\treturn (0);\n}\n\nvoid\nserver_unlink_window(struct session *s, struct winlink *wl)\n{\n\tif (session_detach(s, wl))\n\t\tserver_destroy_session_group(s);\n\telse\n\t\tserver_redraw_session_group(s);\n}\n\nvoid\nserver_destroy_pane(struct window_pane *wp, int notify)\n{\n\tstruct window\t\t*w = wp->window;\n\tstruct screen_write_ctx\t ctx;\n\tstruct grid_cell\t gc;\n\tint\t\t\t remain_on_exit;\n\tconst char\t\t*s;\n\tchar\t\t\t*expanded;\n\tu_int\t\t\t sx = screen_size_x(&wp->base);\n\tu_int\t\t\t sy = screen_size_y(&wp->base);\n\n\tif (wp->fd != -1) {\n#ifdef HAVE_UTEMPTER\n\t\tutempter_remove_record(wp->fd);\n#endif\n\t\tbufferevent_free(wp->event);\n\t\twp->event = NULL;\n\t\tclose(wp->fd);\n\t\twp->fd = -1;\n\t}\n\n\tremain_on_exit = options_get_number(wp->options, \"remain-on-exit\");\n\tif (remain_on_exit != 0 && (~wp->flags & PANE_STATUSREADY))\n\t\treturn;\n\tswitch (remain_on_exit) {\n\tcase 0:\n\t\tbreak;\n\tcase 2:\n\t\tif (WIFEXITED(wp->status) && WEXITSTATUS(wp->status) == 0)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tif (wp->flags & PANE_STATUSDRAWN)\n\t\t\treturn;\n\t\twp->flags |= PANE_STATUSDRAWN;\n\n\t\tgettimeofday(&wp->dead_time, NULL);\n\t\tif (notify)\n\t\t\tnotify_pane(\"pane-died\", wp);\n\n\t\ts = options_get_string(wp->options, \"remain-on-exit-format\");\n\t\tif (*s != '\\0') {\n\t\t\tscreen_write_start_pane(&ctx, wp, &wp->base);\n\t\t\tscreen_write_scrollregion(&ctx, 0, sy - 1);\n\t\t\tscreen_write_cursormove(&ctx, 0, sy - 1, 0);\n\t\t\tscreen_write_linefeed(&ctx, 1, 8);\n\t\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\n\t\t\texpanded = format_single(NULL, s, NULL, NULL, NULL, wp);\n\t\t\tformat_draw(&ctx, &gc, sx, expanded, NULL, 0);\n\t\t\tfree(expanded);\n\n\t\t\tscreen_write_stop(&ctx);\n\t\t}\n\t\twp->base.mode &= ~MODE_CURSOR;\n\n\t\twp->flags |= PANE_REDRAW;\n\t\treturn;\n\t}\n\n\tif (notify)\n\t\tnotify_pane(\"pane-exited\", wp);\n\n\tserver_unzoom_window(w);\n\tserver_client_remove_pane(wp);\n\tlayout_close_pane(wp);\n\twindow_remove_pane(w, wp);\n\n\tif (TAILQ_EMPTY(&w->panes))\n\t\tserver_kill_window(w, 1);\n\telse\n\t\tserver_redraw_window(w);\n}\n\nstatic void\nserver_destroy_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s1;\n\n\tif ((sg = session_group_contains(s)) == NULL) {\n\t\tserver_destroy_session(s);\n\t\tsession_destroy(s, 1, __func__);\n\t} else {\n\t\tTAILQ_FOREACH_SAFE(s, &sg->sessions, gentry, s1) {\n\t\t\tserver_destroy_session(s);\n\t\t\tsession_destroy(s, 1, __func__);\n\t\t}\n\t}\n}\n\nstatic struct session *\nserver_find_session(struct session *s,\n    int (*f)(struct session *, struct session *))\n{\n\tstruct session *s_loop, *s_out = NULL;\n\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (s_loop != s && (s_out == NULL || f(s_loop, s_out)))\n\t\t\ts_out = s_loop;\n\t}\n\treturn (s_out);\n}\n\nstatic int\nserver_newer_session(struct session *s_loop, struct session *s_out)\n{\n\treturn (timercmp(&s_loop->activity_time, &s_out->activity_time, >));\n}\n\nstatic int\nserver_newer_detached_session(struct session *s_loop, struct session *s_out)\n{\n\tif (s_loop->attached)\n\t\treturn (0);\n\treturn (server_newer_session(s_loop, s_out));\n}\n\nvoid\nserver_destroy_session(struct session *s)\n{\n\tstruct client\t*c;\n\tstruct session\t*s_new = NULL, *cs_new, *use_s;\n\tint\t\t detach_on_destroy;\n\n\tdetach_on_destroy = options_get_number(s->options, \"detach-on-destroy\");\n\tif (detach_on_destroy == 0)\n\t\ts_new = server_find_session(s, server_newer_session);\n\telse if (detach_on_destroy == 2)\n\t\ts_new = server_find_session(s, server_newer_detached_session);\n\telse if (detach_on_destroy == 3)\n\t\ts_new = session_previous_session(s);\n\telse if (detach_on_destroy == 4)\n\t\ts_new = session_next_session(s);\n\n\t/*\n\t * If no suitable new session was found above, then look for any\n\t * session as an alternative in case a client needs it.\n\t */\n\tif (s_new == NULL &&\n\t    (detach_on_destroy == 1 || detach_on_destroy == 2))\n\t\tcs_new = server_find_session(s, server_newer_session);\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != s)\n\t\t\tcontinue;\n\t\tuse_s = s_new;\n\t\tif (use_s == NULL && (c->flags & CLIENT_NO_DETACH_ON_DESTROY))\n\t\t\tuse_s = cs_new;\n\n\t\tc->session = NULL;\n\t\tc->last_session = NULL;\n\t\tserver_client_set_session(c, use_s);\n\t\tif (use_s == NULL)\n\t\t\tc->flags |= CLIENT_EXIT;\n\t}\n\trecalculate_sizes();\n}\n\nvoid\nserver_check_unattached(void)\n{\n\tstruct session\t\t*s;\n\tstruct session_group\t*sg;\n\n\t/*\n\t * If any sessions are no longer attached and have destroy-unattached\n\t * set, collect them.\n\t */\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (s->attached != 0)\n\t\t\tcontinue;\n\t\tswitch (options_get_number(s->options, \"destroy-unattached\")) {\n\t\tcase 0: /* off */\n\t\t\tcontinue;\n\t\tcase 1: /* on */\n\t\t\tbreak;\n\t\tcase 2: /* keep-last */\n\t\t\tsg = session_group_contains(s);\n\t\t\tif (sg == NULL || session_group_count(sg) <= 1)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 3: /* keep-group */\n\t\t\tsg = session_group_contains(s);\n\t\t\tif (sg != NULL && session_group_count(sg) == 1)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tsession_destroy(s, 1, __func__);\n\t}\n}\n\nvoid\nserver_unzoom_window(struct window *w)\n{\n\tif (window_unzoom(w, 1) == 0)\n\t\tserver_redraw_window(w);\n}\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 11.529296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Main server functions.\n */\n\nstruct clients\t\t clients;\n\nstruct tmuxproc\t\t*server_proc;\nstatic int\t\t server_fd = -1;\nstatic uint64_t\t\t server_client_flags;\nstatic int\t\t server_exit;\nstatic struct event\t server_ev_accept;\nstatic struct event\t server_ev_tidy;\n\nstruct cmd_find_state\t marked_pane;\n\nstatic u_int\t\t message_next;\nstruct message_list\t message_log;\n\ntime_t\t\t\t current_time;\n\nstatic int\tserver_loop(void);\nstatic void\tserver_send_exit(void);\nstatic void\tserver_accept(int, short, void *);\nstatic void\tserver_signal(int);\nstatic void\tserver_child_signal(void);\nstatic void\tserver_child_exited(pid_t, int);\nstatic void\tserver_child_stopped(pid_t, int);\n\n/* Set marked pane. */\nvoid\nserver_set_marked(struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tcmd_find_clear_state(&marked_pane, 0);\n\tmarked_pane.s = s;\n\tmarked_pane.wl = wl;\n\tmarked_pane.w = wl->window;\n\tmarked_pane.wp = wp;\n}\n\n/* Clear marked pane. */\nvoid\nserver_clear_marked(void)\n{\n\tcmd_find_clear_state(&marked_pane, 0);\n}\n\n/* Is this the marked pane? */\nint\nserver_is_marked(struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tif (s == NULL || wl == NULL || wp == NULL)\n\t\treturn (0);\n\tif (marked_pane.s != s || marked_pane.wl != wl)\n\t\treturn (0);\n\tif (marked_pane.wp != wp)\n\t\treturn (0);\n\treturn (server_check_marked());\n}\n\n/* Check if the marked pane is still valid. */\nint\nserver_check_marked(void)\n{\n\treturn (cmd_find_valid_state(&marked_pane));\n}\n\n/* Create server socket. */\nint\nserver_create_socket(uint64_t flags, char **cause)\n{\n\tstruct sockaddr_un\tsa;\n\tsize_t\t\t\tsize;\n\tmode_t\t\t\tmask;\n\tint\t\t\tfd, saved_errno;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sun_family = AF_UNIX;\n\tsize = strlcpy(sa.sun_path, socket_path, sizeof sa.sun_path);\n\tif (size >= sizeof sa.sun_path) {\n\t\terrno = ENAMETOOLONG;\n\t\tgoto fail;\n\t}\n\tunlink(sa.sun_path);\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto fail;\n\n\tif (flags & CLIENT_DEFAULTSOCKET)\n\t\tmask = umask(S_IXUSR|S_IXGRP|S_IRWXO);\n\telse\n\t\tmask = umask(S_IXUSR|S_IRWXG|S_IRWXO);\n\tif (bind(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {\n\t\tsaved_errno = errno;\n\t\tclose(fd);\n\t\terrno = saved_errno;\n\t\tgoto fail;\n\t}\n\tumask(mask);\n\n\tif (listen(fd, 128) == -1) {\n\t\tsaved_errno = errno;\n\t\tclose(fd);\n\t\terrno = saved_errno;\n\t\tgoto fail;\n\t}\n\tsetblocking(fd, 0);\n\n\treturn (fd);\n\nfail:\n\tif (cause != NULL) {\n\t\txasprintf(cause, \"error creating %s (%s)\", socket_path,\n\t\t    strerror(errno));\n\t}\n\treturn (-1);\n}\n\n/* Tidy up every hour. */\nstatic void\nserver_tidy_event(__unused int fd, __unused short events, __unused void *data)\n{\n    struct timeval\ttv = { .tv_sec = 3600 };\n    uint64_t\t\tt = get_timer();\n\n    format_tidy_jobs();\n\n#ifdef HAVE_MALLOC_TRIM\n    malloc_trim(0);\n#endif\n\n    log_debug(\"%s: took %llu milliseconds\", __func__,\n        (unsigned long long)(get_timer() - t));\n    evtimer_add(&server_ev_tidy, &tv);\n}\n\n/* Fork new server. */\nint\nserver_start(struct tmuxproc *client, uint64_t flags, struct event_base *base,\n    int lockfd, char *lockfile)\n{\n\tint\t\t fd;\n\tsigset_t\t set, oldset;\n\tstruct client\t*c = NULL;\n\tchar\t\t*cause = NULL;\n\tstruct timeval\t tv = { .tv_sec = 3600 };\n\n\tsigfillset(&set);\n\tsigprocmask(SIG_BLOCK, &set, &oldset);\n\n\tif (~flags & CLIENT_NOFORK) {\n\t\tif (proc_fork_and_daemon(&fd) != 0) {\n\t\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\t\t\treturn (fd);\n\t\t}\n\t}\n\tproc_clear_signals(client, 0);\n\tserver_client_flags = flags;\n\n\tif (event_reinit(base) != 0)\n\t\tfatalx(\"event_reinit failed\");\n\tserver_proc = proc_start(\"server\");\n\n\tproc_set_signals(server_proc, server_signal);\n\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\n\tif (log_get_level() > 1)\n\t\ttty_create_log();\n\tif (pledge(\"stdio rpath wpath cpath fattr unix getpw recvfd proc exec \"\n\t    \"tty ps\", NULL) != 0)\n\t\tfatal(\"pledge failed\");\n\n\tinput_key_build();\n\tutf8_update_width_cache();\n\tRB_INIT(&windows);\n\tRB_INIT(&all_window_panes);\n\tTAILQ_INIT(&clients);\n\tRB_INIT(&sessions);\n\tkey_bindings_init();\n\tTAILQ_INIT(&message_log);\n\tgettimeofday(&start_time, NULL);\n\n#ifdef HAVE_SYSTEMD\n\tserver_fd = systemd_create_socket(flags, &cause);\n#else\n\tserver_fd = server_create_socket(flags, &cause);\n#endif\n\tif (server_fd != -1)\n\t\tserver_update_socket();\n\tif (~flags & CLIENT_NOFORK)\n\t\tc = server_client_create(fd);\n\telse\n\t\toptions_set_number(global_options, \"exit-empty\", 0);\n\n\tif (lockfd >= 0) {\n\t\tunlink(lockfile);\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\n\tif (cause != NULL) {\n\t\tif (c != NULL) {\n\t\t\tc->exit_message = cause;\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", cause);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tevtimer_set(&server_ev_tidy, server_tidy_event, NULL);\n\tevtimer_add(&server_ev_tidy, &tv);\n\n\tserver_acl_init();\n\n\tserver_add_accept(0);\n\tproc_loop(server_proc, server_loop);\n\n\tjob_kill_all();\n\tstatus_prompt_save_history();\n\n\texit(0);\n}\n\n/* Server loop callback. */\nstatic int\nserver_loop(void)\n{\n\tstruct client\t*c;\n\tu_int\t\t items;\n\n\tcurrent_time = time(NULL);\n\n\tdo {\n\t\titems = cmdq_next(NULL);\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->flags & CLIENT_IDENTIFIED)\n\t\t\t\titems += cmdq_next(c);\n\t\t}\n\t} while (items != 0);\n\n\tserver_client_loop();\n\n\tif (!options_get_number(global_options, \"exit-empty\") && !server_exit)\n\t\treturn (0);\n\n\tif (!options_get_number(global_options, \"exit-unattached\")) {\n\t\tif (!RB_EMPTY(&sessions))\n\t\t\treturn (0);\n\t}\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/*\n\t * No attached clients therefore want to exit - flush any waiting\n\t * clients but don't actually exit until they've gone.\n\t */\n\tcmd_wait_for_flush();\n\tif (!TAILQ_EMPTY(&clients))\n\t\treturn (0);\n\n\tif (job_still_running())\n\t\treturn (0);\n\n\treturn (1);\n}\n\n/* Exit the server by killing all clients and windows. */\nstatic void\nserver_send_exit(void)\n{\n\tstruct client\t*c, *c1;\n\tstruct session\t*s, *s1;\n\n\tcmd_wait_for_flush();\n\n\tTAILQ_FOREACH_SAFE(c, &clients, entry, c1) {\n\t\tif (c->flags & CLIENT_SUSPENDED)\n\t\t\tserver_client_lost(c);\n\t\telse {\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t\tc->exit_type = CLIENT_EXIT_SHUTDOWN;\n\t\t}\n\t\tc->session = NULL;\n\t}\n\n\tRB_FOREACH_SAFE(s, sessions, &sessions, s1)\n\t\tsession_destroy(s, 1, __func__);\n}\n\n/* Update socket execute permissions based on whether sessions are attached. */\nvoid\nserver_update_socket(void)\n{\n\tstruct session\t*s;\n\tstatic int\t last = -1;\n\tint\t\t n, mode;\n\tstruct stat      sb;\n\n\tn = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (s->attached != 0) {\n\t\t\tn++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n != last) {\n\t\tlast = n;\n\n\t\tif (stat(socket_path, &sb) != 0)\n\t\t\treturn;\n\t\tmode = sb.st_mode & ACCESSPERMS;\n\t\tif (n != 0) {\n\t\t\tif (mode & S_IRUSR)\n\t\t\t\tmode |= S_IXUSR;\n\t\t\tif (mode & S_IRGRP)\n\t\t\t\tmode |= S_IXGRP;\n\t\t\tif (mode & S_IROTH)\n\t\t\t\tmode |= S_IXOTH;\n\t\t} else\n\t\t\tmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);\n\t\tchmod(socket_path, mode);\n\t}\n}\n\n/* Callback for server socket. */\nstatic void\nserver_accept(int fd, short events, __unused void *data)\n{\n\tstruct sockaddr_storage\t sa;\n\tsocklen_t\t\t slen = sizeof sa;\n\tint\t\t\t newfd;\n\tstruct client\t\t*c;\n\n\tserver_add_accept(0);\n\tif (!(events & EV_READ))\n\t\treturn;\n\n\tnewfd = accept(fd, (struct sockaddr *) &sa, &slen);\n\tif (newfd == -1) {\n\t\tif (errno == EAGAIN || errno == EINTR || errno == ECONNABORTED)\n\t\t\treturn;\n\t\tif (errno == ENFILE || errno == EMFILE) {\n\t\t\t/* Delete and don't try again for 1 second. */\n\t\t\tserver_add_accept(1);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"accept failed\");\n\t}\n\n\tif (server_exit) {\n\t\tclose(newfd);\n\t\treturn;\n\t}\n\tc = server_client_create(newfd);\n\tif (!server_acl_join(c)) {\n\t\tc->exit_message = xstrdup(\"access not allowed\");\n\t\tc->flags |= CLIENT_EXIT;\n\t}\n}\n\n/*\n * Add accept event. If timeout is nonzero, add as a timeout instead of a read\n * event - used to backoff when running out of file descriptors.\n */\nvoid\nserver_add_accept(int timeout)\n{\n\tstruct timeval tv = { timeout, 0 };\n\n\tif (server_fd == -1)\n\t\treturn;\n\n\tif (event_initialized(&server_ev_accept))\n\t\tevent_del(&server_ev_accept);\n\n\tif (timeout == 0) {\n\t\tevent_set(&server_ev_accept, server_fd, EV_READ, server_accept,\n\t\t    NULL);\n\t\tevent_add(&server_ev_accept, NULL);\n\t} else {\n\t\tevent_set(&server_ev_accept, server_fd, EV_TIMEOUT,\n\t\t    server_accept, NULL);\n\t\tevent_add(&server_ev_accept, &tv);\n\t}\n}\n\n/* Signal handler. */\nstatic void\nserver_signal(int sig)\n{\n\tint\tfd;\n\n\tlog_debug(\"%s: %s\", __func__, strsignal(sig));\n\tswitch (sig) {\n\tcase SIGINT:\n\tcase SIGTERM:\n\t\tserver_exit = 1;\n\t\tserver_send_exit();\n\t\tbreak;\n\tcase SIGCHLD:\n\t\tserver_child_signal();\n\t\tbreak;\n\tcase SIGUSR1:\n\t\tevent_del(&server_ev_accept);\n\t\tfd = server_create_socket(server_client_flags, NULL);\n\t\tif (fd != -1) {\n\t\t\tclose(server_fd);\n\t\t\tserver_fd = fd;\n\t\t\tserver_update_socket();\n\t\t}\n\t\tserver_add_accept(0);\n\t\tbreak;\n\tcase SIGUSR2:\n\t\tproc_toggle_log(server_proc);\n\t\tbreak;\n\t}\n}\n\n/* Handle SIGCHLD. */\nstatic void\nserver_child_signal(void)\n{\n\tint\t status;\n\tpid_t\t pid;\n\n\tfor (;;) {\n\t\tswitch (pid = waitpid(WAIT_ANY, &status, WNOHANG|WUNTRACED)) {\n\t\tcase -1:\n\t\t\tif (errno == ECHILD)\n\t\t\t\treturn;\n\t\t\tfatal(\"waitpid failed\");\n\t\tcase 0:\n\t\t\treturn;\n\t\t}\n\t\tif (WIFSTOPPED(status))\n\t\t\tserver_child_stopped(pid, status);\n\t\telse if (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tserver_child_exited(pid, status);\n\t}\n}\n\n/* Handle exited children. */\nstatic void\nserver_child_exited(pid_t pid, int status)\n{\n\tstruct window\t\t*w, *w1;\n\tstruct window_pane\t*wp;\n\n\tRB_FOREACH_SAFE(w, windows, &windows, w1) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->pid == pid) {\n\t\t\t\twp->status = status;\n\t\t\t\twp->flags |= PANE_STATUSREADY;\n\n\t\t\t\tlog_debug(\"%%%u exited\", wp->id);\n\t\t\t\twp->flags |= PANE_EXITED;\n\n\t\t\t\tif (window_pane_destroy_ready(wp))\n\t\t\t\t\tserver_destroy_pane(wp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tjob_check_died(pid, status);\n}\n\n/* Handle stopped children. */\nstatic void\nserver_child_stopped(pid_t pid, int status)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\n\tif (WSTOPSIG(status) == SIGTTIN || WSTOPSIG(status) == SIGTTOU)\n\t\treturn;\n\n\tRB_FOREACH(w, windows, &windows) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->pid == pid) {\n\t\t\t\tif (killpg(pid, SIGCONT) != 0)\n\t\t\t\t\tkill(pid, SIGCONT);\n\t\t\t}\n\t\t}\n\t}\n\tjob_check_died(pid, status);\n}\n\n/* Add to message log. */\nvoid\nserver_add_message(const char *fmt, ...)\n{\n\tstruct message_entry\t*msg, *msg1;\n\tchar\t\t\t*s;\n\tva_list\t\t\t ap;\n\tu_int\t\t\t limit;\n\n\tva_start(ap, fmt);\n\txvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"message: %s\", s);\n\n\tmsg = xcalloc(1, sizeof *msg);\n\tgettimeofday(&msg->msg_time, NULL);\n\tmsg->msg_num = message_next++;\n\tmsg->msg = s;\n\tTAILQ_INSERT_TAIL(&message_log, msg, entry);\n\n\tlimit = options_get_number(global_options, \"message-limit\");\n\tTAILQ_FOREACH_SAFE(msg, &message_log, entry, msg1) {\n\t\tif (msg->msg_num + limit >= message_next)\n\t\t\tbreak;\n\t\tfree(msg->msg);\n\t\tTAILQ_REMOVE(&message_log, msg, entry);\n\t\tfree(msg);\n\t}\n}\n"
        },
        {
          "name": "session.c",
          "type": "blob",
          "size": 16.8173828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\nstruct sessions\t\tsessions;\nu_int\t\t\tnext_session_id;\nstruct session_groups\tsession_groups = RB_INITIALIZER(&session_groups);\n\nstatic void\tsession_free(int, short, void *);\nstatic void\tsession_lock_timer(int, short, void *);\nstatic struct winlink *session_next_alert(struct winlink *);\nstatic struct winlink *session_previous_alert(struct winlink *);\nstatic void\tsession_group_remove(struct session *);\nstatic void\tsession_group_synchronize1(struct session *, struct session *);\n\nint\nsession_cmp(struct session *s1, struct session *s2)\n{\n\treturn (strcmp(s1->name, s2->name));\n}\nRB_GENERATE(sessions, session, entry, session_cmp);\n\nint\nsession_group_cmp(struct session_group *s1, struct session_group *s2)\n{\n\treturn (strcmp(s1->name, s2->name));\n}\nRB_GENERATE(session_groups, session_group, entry, session_group_cmp);\n\n/*\n * Find if session is still alive. This is true if it is still on the global\n * sessions list.\n */\nint\nsession_alive(struct session *s)\n{\n\tstruct session *s_loop;\n\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (s_loop == s)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Find session by name. */\nstruct session *\nsession_find(const char *name)\n{\n\tstruct session\ts;\n\n\ts.name = (char *) name;\n\treturn (RB_FIND(sessions, &sessions, &s));\n}\n\n/* Find session by id parsed from a string. */\nstruct session *\nsession_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '$')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (session_find_by_id(id));\n}\n\n/* Find session by id. */\nstruct session *\nsession_find_by_id(u_int id)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (s->id == id)\n\t\t\treturn (s);\n\t}\n\treturn (NULL);\n}\n\n/* Create a new session. */\nstruct session *\nsession_create(const char *prefix, const char *name, const char *cwd,\n    struct environ *env, struct options *oo, struct termios *tio)\n{\n\tstruct session\t*s;\n\n\ts = xcalloc(1, sizeof *s);\n\ts->references = 1;\n\ts->flags = 0;\n\n\ts->cwd = xstrdup(cwd);\n\n\tTAILQ_INIT(&s->lastw);\n\tRB_INIT(&s->windows);\n\n\ts->environ = env;\n\ts->options = oo;\n\n\tstatus_update_cache(s);\n\n\ts->tio = NULL;\n\tif (tio != NULL) {\n\t\ts->tio = xmalloc(sizeof *s->tio);\n\t\tmemcpy(s->tio, tio, sizeof *s->tio);\n\t}\n\n\tif (name != NULL) {\n\t\ts->name = xstrdup(name);\n\t\ts->id = next_session_id++;\n\t} else {\n\t\tdo {\n\t\t\ts->id = next_session_id++;\n\t\t\tfree(s->name);\n\t\t\tif (prefix != NULL)\n\t\t\t\txasprintf(&s->name, \"%s-%u\", prefix, s->id);\n\t\t\telse\n\t\t\t\txasprintf(&s->name, \"%u\", s->id);\n\t\t} while (RB_FIND(sessions, &sessions, s) != NULL);\n\t}\n\tRB_INSERT(sessions, &sessions, s);\n\n\tlog_debug(\"new session %s $%u\", s->name, s->id);\n\n\tif (gettimeofday(&s->creation_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tsession_update_activity(s, &s->creation_time);\n\n\treturn (s);\n}\n\n/* Add a reference to a session. */\nvoid\nsession_add_ref(struct session *s, const char *from)\n{\n\ts->references++;\n\tlog_debug(\"%s: %s %s, now %d\", __func__, s->name, from, s->references);\n}\n\n/* Remove a reference from a session. */\nvoid\nsession_remove_ref(struct session *s, const char *from)\n{\n\ts->references--;\n\tlog_debug(\"%s: %s %s, now %d\", __func__, s->name, from, s->references);\n\n\tif (s->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, session_free, s, NULL);\n}\n\n/* Free session. */\nstatic void\nsession_free(__unused int fd, __unused short events, void *arg)\n{\n\tstruct session\t*s = arg;\n\n\tlog_debug(\"session %s freed (%d references)\", s->name, s->references);\n\n\tif (s->references == 0) {\n\t\tenviron_free(s->environ);\n\t\toptions_free(s->options);\n\n\t\tfree(s->name);\n\t\tfree(s);\n\t}\n}\n\n/* Destroy a session. */\nvoid\nsession_destroy(struct session *s, int notify, const char *from)\n{\n\tstruct winlink\t*wl;\n\n\tlog_debug(\"session %s destroyed (%s)\", s->name, from);\n\n\tif (s->curw == NULL)\n\t\treturn;\n\ts->curw = NULL;\n\n\tRB_REMOVE(sessions, &sessions, s);\n\tif (notify)\n\t\tnotify_session(\"session-closed\", s);\n\n\tfree(s->tio);\n\n\tif (event_initialized(&s->lock_timer))\n\t\tevent_del(&s->lock_timer);\n\n\tsession_group_remove(s);\n\n\twhile (!TAILQ_EMPTY(&s->lastw))\n\t\twinlink_stack_remove(&s->lastw, TAILQ_FIRST(&s->lastw));\n\twhile (!RB_EMPTY(&s->windows)) {\n\t\twl = RB_ROOT(&s->windows);\n\t\tnotify_session_window(\"window-unlinked\", s, wl->window);\n\t\twinlink_remove(&s->windows, wl);\n\t}\n\n\tfree((void *)s->cwd);\n\n\tsession_remove_ref(s, __func__);\n}\n\n/* Sanitize session name. */\nchar *\nsession_check_name(const char *name)\n{\n\tchar\t*copy, *cp, *new_name;\n\n\tif (*name == '\\0')\n\t\treturn (NULL);\n\tcopy = xstrdup(name);\n\tfor (cp = copy; *cp != '\\0'; cp++) {\n\t\tif (*cp == ':' || *cp == '.')\n\t\t\t*cp = '_';\n\t}\n\tutf8_stravis(&new_name, copy, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL);\n\tfree(copy);\n\treturn (new_name);\n}\n\n/* Lock session if it has timed out. */\nstatic void\nsession_lock_timer(__unused int fd, __unused short events, void *arg)\n{\n\tstruct session\t*s = arg;\n\n\tif (s->attached == 0)\n\t\treturn;\n\n\tlog_debug(\"session %s locked, activity time %lld\", s->name,\n\t    (long long)s->activity_time.tv_sec);\n\n\tserver_lock_session(s);\n\trecalculate_sizes();\n}\n\n/* Update activity time. */\nvoid\nsession_update_activity(struct session *s, struct timeval *from)\n{\n\tstruct timeval\t tv;\n\n\tif (from == NULL)\n\t\tgettimeofday(&s->activity_time, NULL);\n\telse\n\t\tmemcpy(&s->activity_time, from, sizeof s->activity_time);\n\n\tlog_debug(\"session $%u %s activity %lld.%06d\", s->id,\n\t    s->name, (long long)s->activity_time.tv_sec,\n\t    (int)s->activity_time.tv_usec);\n\n\tif (evtimer_initialized(&s->lock_timer))\n\t\tevtimer_del(&s->lock_timer);\n\telse\n\t\tevtimer_set(&s->lock_timer, session_lock_timer, s);\n\n\tif (s->attached != 0) {\n\t\ttimerclear(&tv);\n\t\ttv.tv_sec = options_get_number(s->options, \"lock-after-time\");\n\t\tif (tv.tv_sec != 0)\n\t\t\tevtimer_add(&s->lock_timer, &tv);\n\t}\n}\n\n/* Find the next usable session. */\nstruct session *\nsession_next_session(struct session *s)\n{\n\tstruct session *s2;\n\n\tif (RB_EMPTY(&sessions) || !session_alive(s))\n\t\treturn (NULL);\n\n\ts2 = RB_NEXT(sessions, &sessions, s);\n\tif (s2 == NULL)\n\t\ts2 = RB_MIN(sessions, &sessions);\n\tif (s2 == s)\n\t\treturn (NULL);\n\treturn (s2);\n}\n\n/* Find the previous usable session. */\nstruct session *\nsession_previous_session(struct session *s)\n{\n\tstruct session *s2;\n\n\tif (RB_EMPTY(&sessions) || !session_alive(s))\n\t\treturn (NULL);\n\n\ts2 = RB_PREV(sessions, &sessions, s);\n\tif (s2 == NULL)\n\t\ts2 = RB_MAX(sessions, &sessions);\n\tif (s2 == s)\n\t\treturn (NULL);\n\treturn (s2);\n}\n\n/* Attach a window to a session. */\nstruct winlink *\nsession_attach(struct session *s, struct window *w, int idx, char **cause)\n{\n\tstruct winlink\t*wl;\n\n\tif ((wl = winlink_add(&s->windows, idx)) == NULL) {\n\t\txasprintf(cause, \"index in use: %d\", idx);\n\t\treturn (NULL);\n\t}\n\twl->session = s;\n\twinlink_set_window(wl, w);\n\tnotify_session_window(\"window-linked\", s, w);\n\n\tsession_group_synchronize_from(s);\n\treturn (wl);\n}\n\n/* Detach a window from a session. */\nint\nsession_detach(struct session *s, struct winlink *wl)\n{\n\tif (s->curw == wl &&\n\t    session_last(s) != 0 &&\n\t    session_previous(s, 0) != 0)\n\t\tsession_next(s, 0);\n\n\twl->flags &= ~WINLINK_ALERTFLAGS;\n\tnotify_session_window(\"window-unlinked\", s, wl->window);\n\twinlink_stack_remove(&s->lastw, wl);\n\twinlink_remove(&s->windows, wl);\n\n\tsession_group_synchronize_from(s);\n\n\tif (RB_EMPTY(&s->windows))\n\t\treturn (1);\n       \treturn (0);\n}\n\n/* Return if session has window. */\nint\nsession_has(struct session *s, struct window *w)\n{\n\tstruct winlink\t*wl;\n\n\tTAILQ_FOREACH(wl, &w->winlinks, wentry) {\n\t\tif (wl->session == s)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/*\n * Return 1 if a window is linked outside this session (not including session\n * groups). The window must be in this session!\n */\nint\nsession_is_linked(struct session *s, struct window *w)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_contains(s)) != NULL)\n\t\treturn (w->references != session_group_count(sg));\n\treturn (w->references != 1);\n}\n\nstatic struct winlink *\nsession_next_alert(struct winlink *wl)\n{\n\twhile (wl != NULL) {\n\t\tif (wl->flags & WINLINK_ALERTFLAGS)\n\t\t\tbreak;\n\t\twl = winlink_next(wl);\n\t}\n\treturn (wl);\n}\n\n/* Move session to next window. */\nint\nsession_next(struct session *s, int alert)\n{\n\tstruct winlink\t*wl;\n\n\tif (s->curw == NULL)\n\t\treturn (-1);\n\n\twl = winlink_next(s->curw);\n\tif (alert)\n\t\twl = session_next_alert(wl);\n\tif (wl == NULL) {\n\t\twl = RB_MIN(winlinks, &s->windows);\n\t\tif (alert && ((wl = session_next_alert(wl)) == NULL))\n\t\t\treturn (-1);\n\t}\n\treturn (session_set_current(s, wl));\n}\n\nstatic struct winlink *\nsession_previous_alert(struct winlink *wl)\n{\n\twhile (wl != NULL) {\n\t\tif (wl->flags & WINLINK_ALERTFLAGS)\n\t\t\tbreak;\n\t\twl = winlink_previous(wl);\n\t}\n\treturn (wl);\n}\n\n/* Move session to previous window. */\nint\nsession_previous(struct session *s, int alert)\n{\n\tstruct winlink\t*wl;\n\n\tif (s->curw == NULL)\n\t\treturn (-1);\n\n\twl = winlink_previous(s->curw);\n\tif (alert)\n\t\twl = session_previous_alert(wl);\n\tif (wl == NULL) {\n\t\twl = RB_MAX(winlinks, &s->windows);\n\t\tif (alert && (wl = session_previous_alert(wl)) == NULL)\n\t\t\treturn (-1);\n\t}\n\treturn (session_set_current(s, wl));\n}\n\n/* Move session to specific window. */\nint\nsession_select(struct session *s, int idx)\n{\n\tstruct winlink\t*wl;\n\n\twl = winlink_find_by_index(&s->windows, idx);\n\treturn (session_set_current(s, wl));\n}\n\n/* Move session to last used window. */\nint\nsession_last(struct session *s)\n{\n\tstruct winlink\t*wl;\n\n\twl = TAILQ_FIRST(&s->lastw);\n\tif (wl == NULL)\n\t\treturn (-1);\n\tif (wl == s->curw)\n\t\treturn (1);\n\n\treturn (session_set_current(s, wl));\n}\n\n/* Set current winlink to wl .*/\nint\nsession_set_current(struct session *s, struct winlink *wl)\n{\n\tstruct winlink\t*old = s->curw;\n\n\tif (wl == NULL)\n\t\treturn (-1);\n\tif (wl == s->curw)\n\t\treturn (1);\n\n\twinlink_stack_remove(&s->lastw, wl);\n\twinlink_stack_push(&s->lastw, s->curw);\n\ts->curw = wl;\n\tif (options_get_number(global_options, \"focus-events\")) {\n\t\tif (old != NULL)\n\t\t\twindow_update_focus(old->window);\n\t\twindow_update_focus(wl->window);\n\t}\n\twinlink_clear_flags(wl);\n\twindow_update_activity(wl->window);\n\ttty_update_window_offset(wl->window);\n\tnotify_session(\"session-window-changed\", s);\n\treturn (0);\n}\n\n/* Find the session group containing a session. */\nstruct session_group *\nsession_group_contains(struct session *target)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s;\n\n\tRB_FOREACH(sg, session_groups, &session_groups) {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry) {\n\t\t\tif (s == target)\n\t\t\t\treturn (sg);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n/* Find session group by name. */\nstruct session_group *\nsession_group_find(const char *name)\n{\n\tstruct session_group\tsg;\n\n\tsg.name = name;\n\treturn (RB_FIND(session_groups, &session_groups, &sg));\n}\n\n/* Create a new session group. */\nstruct session_group *\nsession_group_new(const char *name)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(name)) != NULL)\n\t\treturn (sg);\n\n\tsg = xcalloc(1, sizeof *sg);\n\tsg->name = xstrdup(name);\n\tTAILQ_INIT(&sg->sessions);\n\n\tRB_INSERT(session_groups, &session_groups, sg);\n\treturn (sg);\n}\n\n/* Add a session to a session group. */\nvoid\nsession_group_add(struct session_group *sg, struct session *s)\n{\n\tif (session_group_contains(s) == NULL)\n\t\tTAILQ_INSERT_TAIL(&sg->sessions, s, gentry);\n}\n\n/* Remove a session from its group and destroy the group if empty. */\nstatic void\nsession_group_remove(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_contains(s)) == NULL)\n\t\treturn;\n\tTAILQ_REMOVE(&sg->sessions, s, gentry);\n\tif (TAILQ_EMPTY(&sg->sessions)) {\n\t\tRB_REMOVE(session_groups, &session_groups, sg);\n\t\tfree((void *)sg->name);\n\t\tfree(sg);\n\t}\n}\n\n/* Count number of sessions in session group. */\nu_int\nsession_group_count(struct session_group *sg)\n{\n\tstruct session\t*s;\n\tu_int\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\tn++;\n\treturn (n);\n}\n\n/* Count number of clients attached to sessions in session group. */\nu_int\nsession_group_attached_count(struct session_group *sg)\n{\n\tstruct session\t*s;\n\tu_int\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\tn += s->attached;\n\treturn (n);\n}\n\n/* Synchronize a session to its session group. */\nvoid\nsession_group_synchronize_to(struct session *s)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*target;\n\n\tif ((sg = session_group_contains(s)) == NULL)\n\t\treturn;\n\n\ttarget = NULL;\n\tTAILQ_FOREACH(target, &sg->sessions, gentry) {\n\t\tif (target != s)\n\t\t\tbreak;\n\t}\n\tif (target != NULL)\n\t\tsession_group_synchronize1(target, s);\n}\n\n/* Synchronize a session group to a session. */\nvoid\nsession_group_synchronize_from(struct session *target)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s;\n\n\tif ((sg = session_group_contains(target)) == NULL)\n\t\treturn;\n\n\tTAILQ_FOREACH(s, &sg->sessions, gentry) {\n\t\tif (s != target)\n\t\t\tsession_group_synchronize1(target, s);\n\t}\n}\n\n/*\n * Synchronize a session with a target session. This means destroying all\n * winlinks then recreating them, then updating the current window, last window\n * stack and alerts.\n */\nstatic void\nsession_group_synchronize1(struct session *target, struct session *s)\n{\n\tstruct winlinks\t\t old_windows, *ww;\n\tstruct winlink_stack\t old_lastw;\n\tstruct winlink\t\t*wl, *wl2;\n\n\t/* Don't do anything if the session is empty (it'll be destroyed). */\n\tww = &target->windows;\n\tif (RB_EMPTY(ww))\n\t\treturn;\n\n\t/* If the current window has vanished, move to the next now. */\n\tif (s->curw != NULL &&\n\t    winlink_find_by_index(ww, s->curw->idx) == NULL &&\n\t    session_last(s) != 0 && session_previous(s, 0) != 0)\n\t\tsession_next(s, 0);\n\n\t/* Save the old pointer and reset it. */\n\tmemcpy(&old_windows, &s->windows, sizeof old_windows);\n\tRB_INIT(&s->windows);\n\n\t/* Link all the windows from the target. */\n\tRB_FOREACH(wl, winlinks, ww) {\n\t\twl2 = winlink_add(&s->windows, wl->idx);\n\t\twl2->session = s;\n\t\twinlink_set_window(wl2, wl->window);\n\t\tnotify_session_window(\"window-linked\", s, wl2->window);\n\t\twl2->flags |= wl->flags & WINLINK_ALERTFLAGS;\n\t}\n\n\t/* Fix up the current window. */\n\tif (s->curw != NULL)\n\t\ts->curw = winlink_find_by_index(&s->windows, s->curw->idx);\n\telse\n\t\ts->curw = winlink_find_by_index(&s->windows, target->curw->idx);\n\n\t/* Fix up the last window stack. */\n\tmemcpy(&old_lastw, &s->lastw, sizeof old_lastw);\n\tTAILQ_INIT(&s->lastw);\n\tTAILQ_FOREACH(wl, &old_lastw, sentry) {\n\t\twl2 = winlink_find_by_index(&s->windows, wl->idx);\n\t\tif (wl2 != NULL) {\n\t\t\tTAILQ_INSERT_TAIL(&s->lastw, wl2, sentry);\n\t\t\twl2->flags |= WINLINK_VISITED;\n\t\t}\n\t}\n\n\t/* Then free the old winlinks list. */\n\twhile (!RB_EMPTY(&old_windows)) {\n\t\twl = RB_ROOT(&old_windows);\n\t\twl2 = winlink_find_by_window_id(&s->windows, wl->window->id);\n\t\tif (wl2 == NULL)\n\t\t\tnotify_session_window(\"window-unlinked\", s, wl->window);\n\t\twinlink_remove(&old_windows, wl);\n\t}\n}\n\n/* Renumber the windows across winlinks attached to a specific session. */\nvoid\nsession_renumber_windows(struct session *s)\n{\n\tstruct winlink\t\t*wl, *wl1, *wl_new;\n\tstruct winlinks\t\t old_wins;\n\tstruct winlink_stack\t old_lastw;\n\tint\t\t\t new_idx, new_curw_idx, marked_idx = -1;\n\n\t/* Save and replace old window list. */\n\tmemcpy(&old_wins, &s->windows, sizeof old_wins);\n\tRB_INIT(&s->windows);\n\n\t/* Start renumbering from the base-index if it's set. */\n\tnew_idx = options_get_number(s->options, \"base-index\");\n\tnew_curw_idx = 0;\n\n\t/* Go through the winlinks and assign new indexes. */\n\tRB_FOREACH(wl, winlinks, &old_wins) {\n\t\twl_new = winlink_add(&s->windows, new_idx);\n\t\twl_new->session = s;\n\t\twinlink_set_window(wl_new, wl->window);\n\t\twl_new->flags |= wl->flags & WINLINK_ALERTFLAGS;\n\n\t\tif (wl == marked_pane.wl)\n\t\t\tmarked_idx = wl_new->idx;\n\t\tif (wl == s->curw)\n\t\t\tnew_curw_idx = wl_new->idx;\n\n\t\tnew_idx++;\n\t}\n\n\t/* Fix the stack of last windows now. */\n\tmemcpy(&old_lastw, &s->lastw, sizeof old_lastw);\n\tTAILQ_INIT(&s->lastw);\n\tTAILQ_FOREACH(wl, &old_lastw, sentry) {\n\t\twl->flags &= ~WINLINK_VISITED;\n\t\twl_new = winlink_find_by_window(&s->windows, wl->window);\n\t\tif (wl_new != NULL) {\n\t\t\tTAILQ_INSERT_TAIL(&s->lastw, wl_new, sentry);\n\t\t\twl_new->flags |= WINLINK_VISITED;\n\t\t}\n\t}\n\n\t/* Set the current window. */\n\tif (marked_idx != -1) {\n\t\tmarked_pane.wl = winlink_find_by_index(&s->windows, marked_idx);\n\t\tif (marked_pane.wl == NULL)\n\t\t\tserver_clear_marked();\n\t}\n\ts->curw = winlink_find_by_index(&s->windows, new_curw_idx);\n\n\t/* Free the old winlinks (reducing window references too). */\n\tRB_FOREACH_SAFE(wl, winlinks, &old_wins, wl1)\n\t\twinlink_remove(&old_wins, wl);\n}\n"
        },
        {
          "name": "spawn.c",
          "type": "blob",
          "size": 13.474609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2019 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Set up the environment and create a new window and pane or a new pane.\n *\n * We need to set up the following items:\n *\n * - history limit, comes from the session;\n *\n * - base index, comes from the session;\n *\n * - current working directory, may be specified - if it isn't it comes from\n *   either the client or the session;\n *\n * - PATH variable, comes from the client if any, otherwise from the session\n *   environment;\n *\n * - shell, comes from default-shell;\n *\n * - termios, comes from the session;\n *\n * - remaining environment, comes from the session.\n */\n\nstatic void\nspawn_log(const char *from, struct spawn_context *sc)\n{\n\tstruct session\t\t*s = sc->s;\n\tstruct winlink\t\t*wl = sc->wl;\n\tstruct window_pane\t*wp0 = sc->wp0;\n\tconst char\t\t*name = cmdq_get_name(sc->item);\n\tchar\t\t\t tmp[128];\n\n\tlog_debug(\"%s: %s, flags=%#x\", from, name, sc->flags);\n\n\tif (wl != NULL && wp0 != NULL)\n\t\txsnprintf(tmp, sizeof tmp, \"wl=%d wp0=%%%u\", wl->idx, wp0->id);\n\telse if (wl != NULL)\n\t\txsnprintf(tmp, sizeof tmp, \"wl=%d wp0=none\", wl->idx);\n\telse if (wp0 != NULL)\n\t\txsnprintf(tmp, sizeof tmp, \"wl=none wp0=%%%u\", wp0->id);\n\telse\n\t\txsnprintf(tmp, sizeof tmp, \"wl=none wp0=none\");\n\tlog_debug(\"%s: s=$%u %s idx=%d\", from, s->id, tmp, sc->idx);\n\tlog_debug(\"%s: name=%s\", from, sc->name == NULL ? \"none\" : sc->name);\n}\n\nstruct winlink *\nspawn_window(struct spawn_context *sc, char **cause)\n{\n\tstruct cmdq_item\t*item = sc->item;\n\tstruct client\t\t*c = cmdq_get_client(item);\n\tstruct session\t\t*s = sc->s;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tstruct winlink\t\t*wl;\n\tint\t\t\t idx = sc->idx;\n\tu_int\t\t\t sx, sy, xpixel, ypixel;\n\n\tspawn_log(__func__, sc);\n\n\t/*\n\t * If the window already exists, we are respawning, so destroy all the\n\t * panes except one.\n\t */\n\tif (sc->flags & SPAWN_RESPAWN) {\n\t\tw = sc->wl->window;\n\t\tif (~sc->flags & SPAWN_KILL) {\n\t\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\t\tif (wp->fd != -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wp != NULL) {\n\t\t\t\txasprintf(cause, \"window %s:%d still active\",\n\t\t\t\t    s->name, sc->wl->idx);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\n\t\tsc->wp0 = TAILQ_FIRST(&w->panes);\n\t\tTAILQ_REMOVE(&w->panes, sc->wp0, entry);\n\n\t\tlayout_free(w);\n\t\twindow_destroy_panes(w);\n\n\t\tTAILQ_INSERT_HEAD(&w->panes, sc->wp0, entry);\n\t\twindow_pane_resize(sc->wp0, w->sx, w->sy);\n\n\t\tlayout_init(w, sc->wp0);\n\t\tw->active = NULL;\n\t\twindow_set_active_pane(w, sc->wp0, 0);\n\t}\n\n\t/*\n\t * Otherwise we have no window so we will need to create one. First\n\t * check if the given index already exists and destroy it if so.\n\t */\n\tif ((~sc->flags & SPAWN_RESPAWN) && idx != -1) {\n\t\twl = winlink_find_by_index(&s->windows, idx);\n\t\tif (wl != NULL && (~sc->flags & SPAWN_KILL)) {\n\t\t\txasprintf(cause, \"index %d in use\", idx);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (wl != NULL) {\n\t\t\t/*\n\t\t\t * Can't use session_detach as it will destroy session\n\t\t\t * if this makes it empty.\n\t\t\t */\n\t\t\twl->flags &= ~WINLINK_ALERTFLAGS;\n\t\t\tnotify_session_window(\"window-unlinked\", s, wl->window);\n\t\t\twinlink_stack_remove(&s->lastw, wl);\n\t\t\twinlink_remove(&s->windows, wl);\n\n\t\t\tif (s->curw == wl) {\n\t\t\t\ts->curw = NULL;\n\t\t\t\tsc->flags &= ~SPAWN_DETACHED;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Then create a window if needed. */\n\tif (~sc->flags & SPAWN_RESPAWN) {\n\t\tif (idx == -1)\n\t\t\tidx = -1 - options_get_number(s->options, \"base-index\");\n\t\tif ((sc->wl = winlink_add(&s->windows, idx)) == NULL) {\n\t\t\txasprintf(cause, \"couldn't add window %d\", idx);\n\t\t\treturn (NULL);\n\t\t}\n\t\tdefault_window_size(sc->tc, s, NULL, &sx, &sy, &xpixel, &ypixel,\n\t\t    -1);\n\t\tif ((w = window_create(sx, sy, xpixel, ypixel)) == NULL) {\n\t\t\twinlink_remove(&s->windows, sc->wl);\n\t\t\txasprintf(cause, \"couldn't create window %d\", idx);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (s->curw == NULL)\n\t\t\ts->curw = sc->wl;\n\t\tsc->wl->session = s;\n\t\tw->latest = sc->tc;\n\t\twinlink_set_window(sc->wl, w);\n\t} else\n\t\tw = NULL;\n\tsc->flags |= SPAWN_NONOTIFY;\n\n\t/* Spawn the pane. */\n\twp = spawn_pane(sc, cause);\n\tif (wp == NULL) {\n\t\tif (~sc->flags & SPAWN_RESPAWN)\n\t\t\twinlink_remove(&s->windows, sc->wl);\n\t\treturn (NULL);\n\t}\n\n\t/* Set the name of the new window. */\n\tif (~sc->flags & SPAWN_RESPAWN) {\n\t\tfree(w->name);\n\t\tif (sc->name != NULL) {\n\t\t\tw->name = format_single(item, sc->name, c, s, NULL,\n\t\t\t    NULL);\n\t\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t\t} else\n\t\t\tw->name = default_window_name(w);\n\t}\n\n\t/* Switch to the new window if required. */\n\tif (~sc->flags & SPAWN_DETACHED)\n\t\tsession_select(s, sc->wl->idx);\n\n\t/* Fire notification if new window. */\n\tif (~sc->flags & SPAWN_RESPAWN)\n\t\tnotify_session_window(\"window-linked\", s, w);\n\n\tsession_group_synchronize_from(s);\n\treturn (sc->wl);\n}\n\nstruct window_pane *\nspawn_pane(struct spawn_context *sc, char **cause)\n{\n\tstruct cmdq_item\t *item = sc->item;\n\tstruct cmd_find_state\t *target = cmdq_get_target(item);\n\tstruct client\t\t *c = cmdq_get_client(item);\n\tstruct session\t\t *s = sc->s;\n\tstruct window\t\t *w = sc->wl->window;\n\tstruct window_pane\t *new_wp;\n\tstruct environ\t\t *child;\n\tstruct environ_entry\t *ee;\n\tchar\t\t\t**argv, *cp, **argvp, *argv0, *cwd, *new_cwd;\n\tconst char\t\t *cmd, *tmp;\n\tint\t\t\t  argc;\n\tu_int\t\t\t  idx;\n\tstruct termios\t\t  now;\n\tu_int\t\t\t  hlimit;\n\tstruct winsize\t\t  ws;\n\tsigset_t\t\t  set, oldset;\n\tkey_code\t\t  key;\n\n\tspawn_log(__func__, sc);\n\n\t/*\n\t * Work out the current working directory. If respawning, use\n\t * the pane's stored one unless specified.\n\t */\n\tif (sc->cwd != NULL) {\n\t\tcwd = format_single(item, sc->cwd, c, target->s, NULL, NULL);\n\t\tif (*cwd != '/') {\n\t\t\txasprintf(&new_cwd, \"%s/%s\", server_client_get_cwd(c,\n\t\t\t    target->s), cwd);\n\t\t\tfree(cwd);\n\t\t\tcwd = new_cwd;\n\t\t}\n\t} else if (~sc->flags & SPAWN_RESPAWN)\n\t\tcwd = xstrdup(server_client_get_cwd(c, target->s));\n\telse\n\t\tcwd = NULL;\n\n\t/*\n\t * If we are respawning then get rid of the old process. Otherwise\n\t * either create a new cell or assign to the one we are given.\n\t */\n\thlimit = options_get_number(s->options, \"history-limit\");\n\tif (sc->flags & SPAWN_RESPAWN) {\n\t\tif (sc->wp0->fd != -1 && (~sc->flags & SPAWN_KILL)) {\n\t\t\twindow_pane_index(sc->wp0, &idx);\n\t\t\txasprintf(cause, \"pane %s:%d.%u still active\",\n\t\t\t    s->name, sc->wl->idx, idx);\n\t\t\tfree(cwd);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (sc->wp0->fd != -1) {\n\t\t\tbufferevent_free(sc->wp0->event);\n\t\t\tclose(sc->wp0->fd);\n\t\t}\n\t\twindow_pane_reset_mode_all(sc->wp0);\n\t\tscreen_reinit(&sc->wp0->base);\n\t\tinput_free(sc->wp0->ictx);\n\t\tsc->wp0->ictx = NULL;\n\t\tnew_wp = sc->wp0;\n\t\tnew_wp->flags &= ~(PANE_STATUSREADY|PANE_STATUSDRAWN);\n\t} else if (sc->lc == NULL) {\n\t\tnew_wp = window_add_pane(w, NULL, hlimit, sc->flags);\n\t\tlayout_init(w, new_wp);\n\t} else {\n\t\tnew_wp = window_add_pane(w, sc->wp0, hlimit, sc->flags);\n\t\tif (sc->flags & SPAWN_ZOOM)\n\t\t\tlayout_assign_pane(sc->lc, new_wp, 1);\n\t\telse\n\t\t\tlayout_assign_pane(sc->lc, new_wp, 0);\n\t}\n\n\t/*\n\t * Now we have a pane with nothing running in it ready for the new\n\t * process. Work out the command and arguments and store the working\n\t * directory.\n\t */\n\tif (sc->argc == 0 && (~sc->flags & SPAWN_RESPAWN)) {\n\t\tcmd = options_get_string(s->options, \"default-command\");\n\t\tif (cmd != NULL && *cmd != '\\0') {\n\t\t\targc = 1;\n\t\t\targv = (char **)&cmd;\n\t\t} else {\n\t\t\targc = 0;\n\t\t\targv = NULL;\n\t\t}\n\t} else {\n\t\targc = sc->argc;\n\t\targv = sc->argv;\n\t}\n\tif (cwd != NULL) {\n\t\tfree(new_wp->cwd);\n\t\tnew_wp->cwd = cwd;\n\t}\n\n\t/*\n\t * Replace the stored arguments if there are new ones. If not, the\n\t * existing ones will be used (they will only exist for respawn).\n\t */\n\tif (argc > 0) {\n\t\tcmd_free_argv(new_wp->argc, new_wp->argv);\n\t\tnew_wp->argc = argc;\n\t\tnew_wp->argv = cmd_copy_argv(argc, argv);\n\t}\n\n\t/* Create an environment for this pane. */\n\tchild = environ_for_session(s, 0);\n\tif (sc->environ != NULL)\n\t\tenviron_copy(sc->environ, child);\n\tenviron_set(child, \"TMUX_PANE\", 0, \"%%%u\", new_wp->id);\n\n\t/*\n\t * Then the PATH environment variable. The session one is replaced from\n\t * the client if there is one because otherwise running \"tmux new\n\t * myprogram\" wouldn't work if myprogram isn't in the session's path.\n\t */\n\tif (c != NULL && c->session == NULL) { /* only unattached clients */\n\t\tee = environ_find(c->environ, \"PATH\");\n\t\tif (ee != NULL)\n\t\t\tenviron_set(child, \"PATH\", 0, \"%s\", ee->value);\n\t}\n\tif (environ_find(child, \"PATH\") == NULL)\n\t\tenviron_set(child, \"PATH\", 0, \"%s\", _PATH_DEFPATH);\n\n\t/* Then the shell. If respawning, use the old one. */\n\tif (~sc->flags & SPAWN_RESPAWN) {\n\t\ttmp = options_get_string(s->options, \"default-shell\");\n\t\tif (!checkshell(tmp))\n\t\t\ttmp = _PATH_BSHELL;\n\t\tfree(new_wp->shell);\n\t\tnew_wp->shell = xstrdup(tmp);\n\t}\n\tenviron_set(child, \"SHELL\", 0, \"%s\", new_wp->shell);\n\n\t/* Log the arguments we are going to use. */\n\tlog_debug(\"%s: shell=%s\", __func__, new_wp->shell);\n\tif (new_wp->argc != 0) {\n\t\tcp = cmd_stringify_argv(new_wp->argc, new_wp->argv);\n\t\tlog_debug(\"%s: cmd=%s\", __func__, cp);\n\t\tfree(cp);\n\t}\n\tlog_debug(\"%s: cwd=%s\", __func__, new_wp->cwd);\n\tcmd_log_argv(new_wp->argc, new_wp->argv, \"%s\", __func__);\n\tenviron_log(child, \"%s: environment \", __func__);\n\n\t/* Initialize the window size. */\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = screen_size_x(&new_wp->base);\n\tws.ws_row = screen_size_y(&new_wp->base);\n\tws.ws_xpixel = w->xpixel * ws.ws_col;\n\tws.ws_ypixel = w->ypixel * ws.ws_row;\n\n\t/* Block signals until fork has completed. */\n\tsigfillset(&set);\n\tsigprocmask(SIG_BLOCK, &set, &oldset);\n\n\t/* If the command is empty, don't fork a child process. */\n\tif (sc->flags & SPAWN_EMPTY) {\n\t\tnew_wp->flags |= PANE_EMPTY;\n\t\tnew_wp->base.mode &= ~MODE_CURSOR;\n\t\tnew_wp->base.mode |= MODE_CRLF;\n\t\tgoto complete;\n\t}\n\n\t/* Fork the new process. */\n\tnew_wp->pid = fdforkpty(ptm_fd, &new_wp->fd, new_wp->tty, NULL, &ws);\n\tif (new_wp->pid == -1) {\n\t\txasprintf(cause, \"fork failed: %s\", strerror(errno));\n\t\tnew_wp->fd = -1;\n\t\tif (~sc->flags & SPAWN_RESPAWN) {\n\t\t\tserver_client_remove_pane(new_wp);\n\t\t\tlayout_close_pane(new_wp);\n\t\t\twindow_remove_pane(w, new_wp);\n\t\t}\n\t\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\t\tenviron_free(child);\n\t\treturn (NULL);\n\t}\n\n\t/* In the parent process, everything is done now. */\n\tif (new_wp->pid != 0) {\n#if defined(HAVE_SYSTEMD) && defined(ENABLE_CGROUPS)\n\t\t/*\n\t\t * Move the child process into a new cgroup for systemd-oomd\n\t\t * isolation.\n\t\t */\n\t\tif (systemd_move_pid_to_new_cgroup(new_wp->pid, cause) < 0) {\n\t\t\tlog_debug(\"%s: moving pane to new cgroup failed: %s\",\n\t\t\t    __func__, *cause);\n\t\t\tfree (*cause);\n\t\t}\n#endif\n\t\tgoto complete;\n\t}\n\n\t/*\n\t * Child process. Change to the working directory or home if that\n\t * fails.\n\t */\n\tif (chdir(new_wp->cwd) == 0)\n\t\tenviron_set(child, \"PWD\", 0, \"%s\", new_wp->cwd);\n\telse if ((tmp = find_home()) != NULL && chdir(tmp) == 0)\n\t\tenviron_set(child, \"PWD\", 0, \"%s\", tmp);\n\telse if (chdir(\"/\") == 0)\n\t\tenviron_set(child, \"PWD\", 0, \"/\");\n\telse\n\t\tfatal(\"chdir failed\");\n\n\t/*\n\t * Update terminal escape characters from the session if available and\n\t * force VERASE to tmux's backspace.\n\t */\n\tif (tcgetattr(STDIN_FILENO, &now) != 0)\n\t\t_exit(1);\n\tif (s->tio != NULL)\n\t\tmemcpy(now.c_cc, s->tio->c_cc, sizeof now.c_cc);\n\tkey = options_get_number(global_options, \"backspace\");\n\tif (key >= 0x7f)\n\t\tnow.c_cc[VERASE] = '\\177';\n\telse\n\t\tnow.c_cc[VERASE] = key;\n#ifdef IUTF8\n\tnow.c_iflag |= IUTF8;\n#endif\n\tif (tcsetattr(STDIN_FILENO, TCSANOW, &now) != 0)\n\t\t_exit(1);\n\n\t/* Clean up file descriptors and signals and update the environment. */\n\tproc_clear_signals(server_proc, 1);\n\tclosefrom(STDERR_FILENO + 1);\n\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\tlog_close();\n\tenviron_push(child);\n\n\t/*\n\t * If given multiple arguments, use execvp(). Copy the arguments to\n\t * ensure they end in a NULL.\n\t */\n\tif (new_wp->argc != 0 && new_wp->argc != 1) {\n\t\targvp = cmd_copy_argv(new_wp->argc, new_wp->argv);\n\t\texecvp(argvp[0], argvp);\n\t\t_exit(1);\n\t}\n\n\t/*\n\t * If one argument, pass it to $SHELL -c. Otherwise create a login\n\t * shell.\n\t */\n\tcp = strrchr(new_wp->shell, '/');\n\tif (new_wp->argc == 1) {\n\t\ttmp = new_wp->argv[0];\n\t\tif (cp != NULL && cp[1] != '\\0')\n\t\t\txasprintf(&argv0, \"%s\", cp + 1);\n\t\telse\n\t\t\txasprintf(&argv0, \"%s\", new_wp->shell);\n\t\texecl(new_wp->shell, argv0, \"-c\", tmp, (char *)NULL);\n\t\t_exit(1);\n\t}\n\tif (cp != NULL && cp[1] != '\\0')\n\t\txasprintf(&argv0, \"-%s\", cp + 1);\n\telse\n\t\txasprintf(&argv0, \"-%s\", new_wp->shell);\n\texecl(new_wp->shell, argv0, (char *)NULL);\n\t_exit(1);\n\ncomplete:\n#ifdef HAVE_UTEMPTER\n\tif (~new_wp->flags & PANE_EMPTY) {\n\t\txasprintf(&cp, \"tmux(%lu).%%%u\", (long)getpid(), new_wp->id);\n\t\tutempter_add_record(new_wp->fd, cp);\n\t\tkill(getpid(), SIGCHLD);\n\t\tfree(cp);\n\t}\n#endif\n\n\tnew_wp->flags &= ~PANE_EXITED;\n\n\tsigprocmask(SIG_SETMASK, &oldset, NULL);\n\twindow_pane_set_event(new_wp);\n\n\tenviron_free(child);\n\n\tif (sc->flags & SPAWN_RESPAWN)\n\t\treturn (new_wp);\n\tif ((~sc->flags & SPAWN_DETACHED) || w->active == NULL) {\n\t\tif (sc->flags & SPAWN_NONOTIFY)\n\t\t\twindow_set_active_pane(w, new_wp, 0);\n\t\telse\n\t\t\twindow_set_active_pane(w, new_wp, 1);\n\t}\n\tif (~sc->flags & SPAWN_NONOTIFY)\n\t\tnotify_window(\"window-layout-changed\", w);\n\treturn (new_wp);\n}\n"
        },
        {
          "name": "status.c",
          "type": "blob",
          "size": 49.923828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic void\t status_message_callback(int, short, void *);\nstatic void\t status_timer_callback(int, short, void *);\n\nstatic char\t*status_prompt_find_history_file(void);\nstatic const char *status_prompt_up_history(u_int *, u_int);\nstatic const char *status_prompt_down_history(u_int *, u_int);\nstatic void\t status_prompt_add_history(const char *, u_int);\n\nstatic char\t*status_prompt_complete(struct client *, const char *, u_int);\nstatic char\t*status_prompt_complete_window_menu(struct client *,\n\t\t     struct session *, const char *, u_int, char);\n\nstruct status_prompt_menu {\n\tstruct client\t *c;\n\tu_int\t\t  start;\n\tu_int\t\t  size;\n\tchar\t\t**list;\n\tchar\t\t  flag;\n};\n\nstatic const char\t*prompt_type_strings[] = {\n\t\"command\",\n\t\"search\",\n\t\"target\",\n\t\"window-target\"\n};\n\n/* Status prompt history. */\nchar\t\t**status_prompt_hlist[PROMPT_NTYPES];\nu_int\t\t  status_prompt_hsize[PROMPT_NTYPES];\n\n/* Find the history file to load/save from/to. */\nstatic char *\nstatus_prompt_find_history_file(void)\n{\n\tconst char\t*home, *history_file;\n\tchar\t\t*path;\n\n\thistory_file = options_get_string(global_options, \"history-file\");\n\tif (*history_file == '\\0')\n\t\treturn (NULL);\n\tif (*history_file == '/')\n\t\treturn (xstrdup(history_file));\n\n\tif (history_file[0] != '~' || history_file[1] != '/')\n\t\treturn (NULL);\n\tif ((home = find_home()) == NULL)\n\t\treturn (NULL);\n\txasprintf(&path, \"%s%s\", home, history_file + 1);\n\treturn (path);\n}\n\n/* Add loaded history item to the appropriate list. */\nstatic void\nstatus_prompt_add_typed_history(char *line)\n{\n\tchar\t\t\t*typestr;\n\tenum prompt_type\t type = PROMPT_TYPE_INVALID;\n\n\ttypestr = strsep(&line, \":\");\n\tif (line != NULL)\n\t\ttype = status_prompt_type(typestr);\n\tif (type == PROMPT_TYPE_INVALID) {\n\t\t/*\n\t\t * Invalid types are not expected, but this provides backward\n\t\t * compatibility with old history files.\n\t\t */\n\t\tif (line != NULL)\n\t\t\t*(--line) = ':';\n\t\tstatus_prompt_add_history(typestr, PROMPT_TYPE_COMMAND);\n\t} else\n\t\tstatus_prompt_add_history(line, type);\n}\n\n/* Load status prompt history from file. */\nvoid\nstatus_prompt_load_history(void)\n{\n\tFILE\t*f;\n\tchar\t*history_file, *line, *tmp;\n\tsize_t\t length;\n\n\tif ((history_file = status_prompt_find_history_file()) == NULL)\n\t\treturn;\n\tlog_debug(\"loading history from %s\", history_file);\n\n\tf = fopen(history_file, \"r\");\n\tif (f == NULL) {\n\t\tlog_debug(\"%s: %s\", history_file, strerror(errno));\n\t\tfree(history_file);\n\t\treturn;\n\t}\n\tfree(history_file);\n\n\tfor (;;) {\n\t\tif ((line = fgetln(f, &length)) == NULL)\n\t\t\tbreak;\n\n\t\tif (length > 0) {\n\t\t\tif (line[length - 1] == '\\n') {\n\t\t\t\tline[length - 1] = '\\0';\n\t\t\t\tstatus_prompt_add_typed_history(line);\n\t\t\t} else {\n\t\t\t\ttmp = xmalloc(length + 1);\n\t\t\t\tmemcpy(tmp, line, length);\n\t\t\t\ttmp[length] = '\\0';\n\t\t\t\tstatus_prompt_add_typed_history(tmp);\n\t\t\t\tfree(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n}\n\n/* Save status prompt history to file. */\nvoid\nstatus_prompt_save_history(void)\n{\n\tFILE\t*f;\n\tu_int\t i, type;\n\tchar\t*history_file;\n\n\tif ((history_file = status_prompt_find_history_file()) == NULL)\n\t\treturn;\n\tlog_debug(\"saving history to %s\", history_file);\n\n\tf = fopen(history_file, \"w\");\n\tif (f == NULL) {\n\t\tlog_debug(\"%s: %s\", history_file, strerror(errno));\n\t\tfree(history_file);\n\t\treturn;\n\t}\n\tfree(history_file);\n\n\tfor (type = 0; type < PROMPT_NTYPES; type++) {\n\t\tfor (i = 0; i < status_prompt_hsize[type]; i++) {\n\t\t\tfputs(prompt_type_strings[type], f);\n\t\t\tfputc(':', f);\n\t\t\tfputs(status_prompt_hlist[type][i], f);\n\t\t\tfputc('\\n', f);\n\t\t}\n\t}\n\tfclose(f);\n\n}\n\n/* Status timer callback. */\nstatic void\nstatus_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\tstruct session\t*s = c->session;\n\tstruct timeval\t tv;\n\n\tevtimer_del(&c->status.timer);\n\n\tif (s == NULL)\n\t\treturn;\n\n\tif (c->message_string == NULL && c->prompt_string == NULL)\n\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\n\ttimerclear(&tv);\n\ttv.tv_sec = options_get_number(s->options, \"status-interval\");\n\n\tif (tv.tv_sec != 0)\n\t\tevtimer_add(&c->status.timer, &tv);\n\tlog_debug(\"client %p, status interval %d\", c, (int)tv.tv_sec);\n}\n\n/* Start status timer for client. */\nvoid\nstatus_timer_start(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (event_initialized(&c->status.timer))\n\t\tevtimer_del(&c->status.timer);\n\telse\n\t\tevtimer_set(&c->status.timer, status_timer_callback, c);\n\n\tif (s != NULL && options_get_number(s->options, \"status\"))\n\t\tstatus_timer_callback(-1, 0, c);\n}\n\n/* Start status timer for all clients. */\nvoid\nstatus_timer_start_all(void)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry)\n\t\tstatus_timer_start(c);\n}\n\n/* Update status cache. */\nvoid\nstatus_update_cache(struct session *s)\n{\n\ts->statuslines = options_get_number(s->options, \"status\");\n\tif (s->statuslines == 0)\n\t\ts->statusat = -1;\n\telse if (options_get_number(s->options, \"status-position\") == 0)\n\t\ts->statusat = 0;\n\telse\n\t\ts->statusat = 1;\n}\n\n/* Get screen line of status line. -1 means off. */\nint\nstatus_at_line(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (c->flags & (CLIENT_STATUSOFF|CLIENT_CONTROL))\n\t\treturn (-1);\n\tif (s->statusat != 1)\n\t\treturn (s->statusat);\n\treturn (c->tty.sy - status_line_size(c));\n}\n\n/* Get size of status line for client's session. 0 means off. */\nu_int\nstatus_line_size(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (c->flags & (CLIENT_STATUSOFF|CLIENT_CONTROL))\n\t\treturn (0);\n\tif (s == NULL)\n\t\treturn (options_get_number(global_s_options, \"status\"));\n\treturn (s->statuslines);\n}\n\n/* Get the prompt line number for client's session. 1 means at the bottom. */\nstatic u_int\nstatus_prompt_line_at(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (c->flags & (CLIENT_STATUSOFF|CLIENT_CONTROL))\n\t\treturn (1);\n\treturn (options_get_number(s->options, \"message-line\"));\n}\n\n/* Get window at window list position. */\nstruct style_range *\nstatus_get_range(struct client *c, u_int x, u_int y)\n{\n\tstruct status_line\t*sl = &c->status;\n\tstruct style_range\t*sr;\n\n\tif (y >= nitems(sl->entries))\n\t\treturn (NULL);\n\tTAILQ_FOREACH(sr, &sl->entries[y].ranges, entry) {\n\t\tif (x >= sr->start && x < sr->end)\n\t\t\treturn (sr);\n\t}\n\treturn (NULL);\n}\n\n/* Free all ranges. */\nstatic void\nstatus_free_ranges(struct style_ranges *srs)\n{\n\tstruct style_range\t*sr, *sr1;\n\n\tTAILQ_FOREACH_SAFE(sr, srs, entry, sr1) {\n\t\tTAILQ_REMOVE(srs, sr, entry);\n\t\tfree(sr);\n\t}\n}\n\n/* Save old status line. */\nstatic void\nstatus_push_screen(struct client *c)\n{\n\tstruct status_line *sl = &c->status;\n\n\tif (sl->active == &sl->screen) {\n\t\tsl->active = xmalloc(sizeof *sl->active);\n\t\tscreen_init(sl->active, c->tty.sx, status_line_size(c), 0);\n\t}\n\tsl->references++;\n}\n\n/* Restore old status line. */\nstatic void\nstatus_pop_screen(struct client *c)\n{\n\tstruct status_line *sl = &c->status;\n\n\tif (--sl->references == 0) {\n\t\tscreen_free(sl->active);\n\t\tfree(sl->active);\n\t\tsl->active = &sl->screen;\n\t}\n}\n\n/* Initialize status line. */\nvoid\nstatus_init(struct client *c)\n{\n\tstruct status_line\t*sl = &c->status;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < nitems(sl->entries); i++)\n\t\tTAILQ_INIT(&sl->entries[i].ranges);\n\n\tscreen_init(&sl->screen, c->tty.sx, 1, 0);\n\tsl->active = &sl->screen;\n}\n\n/* Free status line. */\nvoid\nstatus_free(struct client *c)\n{\n\tstruct status_line\t*sl = &c->status;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < nitems(sl->entries); i++) {\n\t\tstatus_free_ranges(&sl->entries[i].ranges);\n\t\tfree((void *)sl->entries[i].expanded);\n\t}\n\n\tif (event_initialized(&sl->timer))\n\t\tevtimer_del(&sl->timer);\n\n\tif (sl->active != &sl->screen) {\n\t\tscreen_free(sl->active);\n\t\tfree(sl->active);\n\t}\n\tscreen_free(&sl->screen);\n}\n\n/* Draw status line for client. */\nint\nstatus_redraw(struct client *c)\n{\n\tstruct status_line\t\t*sl = &c->status;\n\tstruct status_line_entry\t*sle;\n\tstruct session\t\t\t*s = c->session;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t lines, i, n, width = c->tty.sx;\n\tint\t\t\t\t flags, force = 0, changed = 0, fg, bg;\n\tstruct options_entry\t\t*o;\n\tunion options_value\t\t*ov;\n\tstruct format_tree\t\t*ft;\n\tchar\t\t\t\t*expanded;\n\n\tlog_debug(\"%s enter\", __func__);\n\n\t/* Shouldn't get here if not the active screen. */\n\tif (sl->active != &sl->screen)\n\t\tfatalx(\"not the active screen\");\n\n\t/* No status line? */\n\tlines = status_line_size(c);\n\tif (c->tty.sy == 0 || lines == 0)\n\t\treturn (1);\n\n\t/* Create format tree. */\n\tflags = FORMAT_STATUS;\n\tif (c->flags & CLIENT_STATUSFORCE)\n\t\tflags |= FORMAT_FORCE;\n\tft = format_create(c, NULL, FORMAT_NONE, flags);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\t/* Set up default colour. */\n\tstyle_apply(&gc, s->options, \"status-style\", ft);\n\tfg = options_get_number(s->options, \"status-fg\");\n\tif (!COLOUR_DEFAULT(fg))\n\t\tgc.fg = fg;\n\tbg = options_get_number(s->options, \"status-bg\");\n\tif (!COLOUR_DEFAULT(bg))\n\t\tgc.bg = bg;\n\tif (!grid_cells_equal(&gc, &sl->style)) {\n\t\tforce = 1;\n\t\tmemcpy(&sl->style, &gc, sizeof sl->style);\n\t}\n\n\t/* Resize the target screen. */\n\tif (screen_size_x(&sl->screen) != width ||\n\t    screen_size_y(&sl->screen) != lines) {\n\t\tscreen_resize(&sl->screen, width, lines, 0);\n\t\tchanged = force = 1;\n\t}\n\tscreen_write_start(&ctx, &sl->screen);\n\n\t/* Write the status lines. */\n\to = options_get(s->options, \"status-format\");\n\tif (o == NULL) {\n\t\tfor (n = 0; n < width * lines; n++)\n\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t} else {\n\t\tfor (i = 0; i < lines; i++) {\n\t\t\tscreen_write_cursormove(&ctx, 0, i, 0);\n\n\t\t\tov = options_array_get(o, i);\n\t\t\tif (ov == NULL) {\n\t\t\t\tfor (n = 0; n < width; n++)\n\t\t\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsle = &sl->entries[i];\n\n\t\t\texpanded = format_expand_time(ft, ov->string);\n\t\t\tif (!force &&\n\t\t\t    sle->expanded != NULL &&\n\t\t\t    strcmp(expanded, sle->expanded) == 0) {\n\t\t\t\tfree(expanded);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchanged = 1;\n\n\t\t\tfor (n = 0; n < width; n++)\n\t\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t\t\tscreen_write_cursormove(&ctx, 0, i, 0);\n\n\t\t\tstatus_free_ranges(&sle->ranges);\n\t\t\tformat_draw(&ctx, &gc, width, expanded, &sle->ranges,\n\t\t\t    0);\n\n\t\t\tfree(sle->expanded);\n\t\t\tsle->expanded = expanded;\n\t\t}\n\t}\n\tscreen_write_stop(&ctx);\n\n\t/* Free the format tree. */\n\tformat_free(ft);\n\n\t/* Return if the status line has changed. */\n\tlog_debug(\"%s exit: force=%d, changed=%d\", __func__, force, changed);\n\treturn (force || changed);\n}\n\n/* Set a status line message. */\nvoid\nstatus_message_set(struct client *c, int delay, int ignore_styles,\n    int ignore_keys, const char *fmt, ...)\n{\n\tstruct timeval\t tv;\n\tva_list\t\t ap;\n\tchar\t\t*s;\n\n\tva_start(ap, fmt);\n\txvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\tlog_debug(\"%s: %s\", __func__, s);\n\n\tif (c == NULL) {\n\t\tserver_add_message(\"message: %s\", s);\n\t\tfree(s);\n\t\treturn;\n\t}\n\n\tstatus_message_clear(c);\n\tstatus_push_screen(c);\n\tc->message_string = s;\n\tserver_add_message(\"%s message: %s\", c->name, s);\n\n\t/*\n\t * With delay -1, the display-time option is used; zero means wait for\n\t * key press; more than zero is the actual delay time in milliseconds.\n\t */\n\tif (delay == -1)\n\t\tdelay = options_get_number(c->session->options, \"display-time\");\n\tif (delay > 0) {\n\t\ttv.tv_sec = delay / 1000;\n\t\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\t\tif (event_initialized(&c->message_timer))\n\t\t\tevtimer_del(&c->message_timer);\n\t\tevtimer_set(&c->message_timer, status_message_callback, c);\n\n\t\tevtimer_add(&c->message_timer, &tv);\n\t}\n\n\tif (delay != 0)\n\t\tc->message_ignore_keys = ignore_keys;\n\tc->message_ignore_styles = ignore_styles;\n\n\tc->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_REDRAWSTATUS;\n}\n\n/* Clear status line message. */\nvoid\nstatus_message_clear(struct client *c)\n{\n\tif (c->message_string == NULL)\n\t\treturn;\n\n\tfree(c->message_string);\n\tc->message_string = NULL;\n\n\tif (c->prompt_string == NULL)\n\t\tc->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_ALLREDRAWFLAGS; /* was frozen and may have changed */\n\n\tstatus_pop_screen(c);\n}\n\n/* Clear status line message after timer expires. */\nstatic void\nstatus_message_callback(__unused int fd, __unused short event, void *data)\n{\n\tstruct client\t*c = data;\n\n\tstatus_message_clear(c);\n}\n\n/* Draw client message on status line of present else on last line. */\nint\nstatus_message_redraw(struct client *c)\n{\n\tstruct status_line\t*sl = &c->status;\n\tstruct screen_write_ctx\t ctx;\n\tstruct session\t\t*s = c->session;\n\tstruct screen\t\t old_screen;\n\tsize_t\t\t\t len;\n\tu_int\t\t\t lines, offset, messageline;\n\tstruct grid_cell\t gc;\n\tstruct format_tree\t*ft;\n\n\tif (c->tty.sx == 0 || c->tty.sy == 0)\n\t\treturn (0);\n\tmemcpy(&old_screen, sl->active, sizeof old_screen);\n\n\tlines = status_line_size(c);\n\tif (lines <= 1)\n\t\tlines = 1;\n\tscreen_init(sl->active, c->tty.sx, lines, 0);\n\n\tmessageline = status_prompt_line_at(c);\n\tif (messageline > lines - 1)\n\t\tmessageline = lines - 1;\n\n\tlen = screen_write_strlen(\"%s\", c->message_string);\n\tif (len > c->tty.sx)\n\t\tlen = c->tty.sx;\n\n\tft = format_create_defaults(NULL, c, NULL, NULL, NULL);\n\tstyle_apply(&gc, s->options, \"message-style\", ft);\n\tformat_free(ft);\n\n\tscreen_write_start(&ctx, sl->active);\n\tscreen_write_fast_copy(&ctx, &sl->screen, 0, 0, c->tty.sx, lines);\n\tscreen_write_cursormove(&ctx, 0, messageline, 0);\n\tfor (offset = 0; offset < c->tty.sx; offset++)\n\t\tscreen_write_putc(&ctx, &gc, ' ');\n\tscreen_write_cursormove(&ctx, 0, messageline, 0);\n\tif (c->message_ignore_styles)\n\t\tscreen_write_nputs(&ctx, len, &gc, \"%s\", c->message_string);\n\telse\n\t\tformat_draw(&ctx, &gc, c->tty.sx, c->message_string, NULL, 0);\n\tscreen_write_stop(&ctx);\n\n\tif (grid_compare(sl->active->grid, old_screen.grid) == 0) {\n\t\tscreen_free(&old_screen);\n\t\treturn (0);\n\t}\n\tscreen_free(&old_screen);\n\treturn (1);\n}\n\n/* Accept prompt immediately. */\nstatic enum cmd_retval\nstatus_prompt_accept(__unused struct cmdq_item *item, void *data)\n{\n\tstruct client\t*c = data;\n\n\tif (c->prompt_string != NULL) {\n\t\tc->prompt_inputcb(c, c->prompt_data, \"y\", 1);\n\t\tstatus_prompt_clear(c);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Enable status line prompt. */\nvoid\nstatus_prompt_set(struct client *c, struct cmd_find_state *fs,\n    const char *msg, const char *input, prompt_input_cb inputcb,\n    prompt_free_cb freecb, void *data, int flags, enum prompt_type prompt_type)\n{\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*tmp;\n\n\tserver_client_clear_overlay(c);\n\n\tif (fs != NULL)\n\t\tft = format_create_from_state(NULL, c, fs);\n\telse\n\t\tft = format_create_defaults(NULL, c, NULL, NULL, NULL);\n\n\tif (input == NULL)\n\t\tinput = \"\";\n\tif (flags & PROMPT_NOFORMAT)\n\t\ttmp = xstrdup(input);\n\telse\n\t\ttmp = format_expand_time(ft, input);\n\n\tstatus_message_clear(c);\n\tstatus_prompt_clear(c);\n\tstatus_push_screen(c);\n\n\tc->prompt_string = format_expand_time(ft, msg);\n\n\tif (flags & PROMPT_INCREMENTAL) {\n\t\tc->prompt_last = xstrdup(tmp);\n\t\tc->prompt_buffer = utf8_fromcstr(\"\");\n\t} else {\n\t\tc->prompt_last = NULL;\n\t\tc->prompt_buffer = utf8_fromcstr(tmp);\n\t}\n\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\n\tc->prompt_inputcb = inputcb;\n\tc->prompt_freecb = freecb;\n\tc->prompt_data = data;\n\n\tmemset(c->prompt_hindex, 0, sizeof c->prompt_hindex);\n\n\tc->prompt_flags = flags;\n\tc->prompt_type = prompt_type;\n\tc->prompt_mode = PROMPT_ENTRY;\n\n\tif (~flags & PROMPT_INCREMENTAL)\n\t\tc->tty.flags |= TTY_FREEZE;\n\tc->flags |= CLIENT_REDRAWSTATUS;\n\n\tif (flags & PROMPT_INCREMENTAL)\n\t\tc->prompt_inputcb(c, c->prompt_data, \"=\", 0);\n\n\tfree(tmp);\n\tformat_free(ft);\n\n\tif ((flags & PROMPT_SINGLE) && (flags & PROMPT_ACCEPT))\n\t\tcmdq_append(c, cmdq_get_callback(status_prompt_accept, c));\n}\n\n/* Remove status line prompt. */\nvoid\nstatus_prompt_clear(struct client *c)\n{\n\tif (c->prompt_string == NULL)\n\t\treturn;\n\n\tif (c->prompt_freecb != NULL && c->prompt_data != NULL)\n\t\tc->prompt_freecb(c->prompt_data);\n\n\tfree(c->prompt_last);\n\tc->prompt_last = NULL;\n\n\tfree(c->prompt_string);\n\tc->prompt_string = NULL;\n\n\tfree(c->prompt_buffer);\n\tc->prompt_buffer = NULL;\n\n\tfree(c->prompt_saved);\n\tc->prompt_saved = NULL;\n\n\tc->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_ALLREDRAWFLAGS; /* was frozen and may have changed */\n\n\tstatus_pop_screen(c);\n}\n\n/* Update status line prompt with a new prompt string. */\nvoid\nstatus_prompt_update(struct client *c, const char *msg, const char *input)\n{\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*tmp;\n\n\tft = format_create(c, NULL, FORMAT_NONE, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\ttmp = format_expand_time(ft, input);\n\n\tfree(c->prompt_string);\n\tc->prompt_string = format_expand_time(ft, msg);\n\n\tfree(c->prompt_buffer);\n\tc->prompt_buffer = utf8_fromcstr(tmp);\n\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\n\tmemset(c->prompt_hindex, 0, sizeof c->prompt_hindex);\n\n\tc->flags |= CLIENT_REDRAWSTATUS;\n\n\tfree(tmp);\n\tformat_free(ft);\n}\n\n/* Redraw character. Return 1 if can continue redrawing, 0 otherwise. */\nstatic int\nstatus_prompt_redraw_character(struct screen_write_ctx *ctx, u_int offset,\n    u_int pwidth, u_int *width, struct grid_cell *gc,\n    const struct utf8_data *ud)\n{\n\tu_char\tch;\n\n\tif (*width < offset) {\n\t\t*width += ud->width;\n\t\treturn (1);\n\t}\n\tif (*width >= offset + pwidth)\n\t\treturn (0);\n\t*width += ud->width;\n\tif (*width > offset + pwidth)\n\t\treturn (0);\n\n\tch = *ud->data;\n\tif (ud->size == 1 && (ch <= 0x1f || ch == 0x7f)) {\n\t\tgc->data.data[0] = '^';\n\t\tgc->data.data[1] = (ch == 0x7f) ? '?' : ch|0x40;\n\t\tgc->data.size = gc->data.have = 2;\n\t\tgc->data.width = 2;\n\t} else\n\t\tutf8_copy(&gc->data, ud);\n\tscreen_write_cell(ctx, gc);\n\treturn (1);\n}\n\n/*\n * Redraw quote indicator '^' if necessary. Return 1 if can continue redrawing,\n * 0 otherwise.\n */\nstatic int\nstatus_prompt_redraw_quote(const struct client *c, u_int pcursor,\n    struct screen_write_ctx *ctx, u_int offset, u_int pwidth, u_int *width,\n    struct grid_cell *gc)\n{\n\tstruct utf8_data\tud;\n\n\tif (c->prompt_flags & PROMPT_QUOTENEXT && ctx->s->cx == pcursor + 1) {\n\t\tutf8_set(&ud, '^');\n\t\treturn (status_prompt_redraw_character(ctx, offset, pwidth,\n\t\t    width, gc, &ud));\n\t}\n\treturn (1);\n}\n\n/* Draw client prompt on status line of present else on last line. */\nint\nstatus_prompt_redraw(struct client *c)\n{\n\tstruct status_line\t*sl = &c->status;\n\tstruct screen_write_ctx\t ctx;\n\tstruct session\t\t*s = c->session;\n\tstruct screen\t\t old_screen;\n\tu_int\t\t\t i, lines, offset, left, start, width, n;\n\tu_int\t\t\t pcursor, pwidth, promptline;\n\tstruct grid_cell\t gc;\n\tstruct format_tree\t*ft;\n\n\tif (c->tty.sx == 0 || c->tty.sy == 0)\n\t\treturn (0);\n\tmemcpy(&old_screen, sl->active, sizeof old_screen);\n\n\tlines = status_line_size(c);\n\tif (lines <= 1)\n\t\tlines = 1;\n\tscreen_init(sl->active, c->tty.sx, lines, 0);\n\n\tn = options_get_number(s->options, \"prompt-cursor-colour\");\n\tsl->active->default_ccolour = n;\n\tn = options_get_number(s->options, \"prompt-cursor-style\");\n\tscreen_set_cursor_style(n, &sl->active->default_cstyle,\n\t    &sl->active->default_mode);\n\n\tpromptline = status_prompt_line_at(c);\n\tif (promptline > lines - 1)\n\t\tpromptline = lines - 1;\n\n\tft = format_create_defaults(NULL, c, NULL, NULL, NULL);\n\tif (c->prompt_mode == PROMPT_COMMAND)\n\t\tstyle_apply(&gc, s->options, \"message-command-style\", ft);\n\telse\n\t\tstyle_apply(&gc, s->options, \"message-style\", ft);\n\tformat_free(ft);\n\n\tstart = format_width(c->prompt_string);\n\tif (start > c->tty.sx)\n\t\tstart = c->tty.sx;\n\n\tscreen_write_start(&ctx, sl->active);\n\tscreen_write_fast_copy(&ctx, &sl->screen, 0, 0, c->tty.sx, lines);\n\tscreen_write_cursormove(&ctx, 0, promptline, 0);\n\tfor (offset = 0; offset < c->tty.sx; offset++)\n\t\tscreen_write_putc(&ctx, &gc, ' ');\n\tscreen_write_cursormove(&ctx, 0, promptline, 0);\n\tformat_draw(&ctx, &gc, start, c->prompt_string, NULL, 0);\n\tscreen_write_cursormove(&ctx, start, promptline, 0);\n\n\tleft = c->tty.sx - start;\n\tif (left == 0)\n\t\tgoto finished;\n\n\tpcursor = utf8_strwidth(c->prompt_buffer, c->prompt_index);\n\tpwidth = utf8_strwidth(c->prompt_buffer, -1);\n\tif (c->prompt_flags & PROMPT_QUOTENEXT)\n\t\tpwidth++;\n\tif (pcursor >= left) {\n\t\t/*\n\t\t * The cursor would be outside the screen so start drawing\n\t\t * with it on the right.\n\t\t */\n\t\toffset = (pcursor - left) + 1;\n\t\tpwidth = left;\n\t} else\n\t\toffset = 0;\n\tif (pwidth > left)\n\t\tpwidth = left;\n\tc->prompt_cursor = start + pcursor - offset;\n\n\twidth = 0;\n\tfor (i = 0; c->prompt_buffer[i].size != 0; i++) {\n\t\tif (!status_prompt_redraw_quote(c, pcursor, &ctx, offset,\n\t\t    pwidth, &width, &gc))\n\t\t\tbreak;\n\t\tif (!status_prompt_redraw_character(&ctx, offset, pwidth,\n\t\t    &width, &gc, &c->prompt_buffer[i]))\n\t\t\tbreak;\n\t}\n\tstatus_prompt_redraw_quote(c, pcursor, &ctx, offset, pwidth, &width,\n\t    &gc);\n\nfinished:\n\tscreen_write_stop(&ctx);\n\n\tif (grid_compare(sl->active->grid, old_screen.grid) == 0) {\n\t\tscreen_free(&old_screen);\n\t\treturn (0);\n\t}\n\tscreen_free(&old_screen);\n\treturn (1);\n}\n\n/* Is this a separator? */\nstatic int\nstatus_prompt_in_list(const char *ws, const struct utf8_data *ud)\n{\n\tif (ud->size != 1 || ud->width != 1)\n\t\treturn (0);\n\treturn (strchr(ws, *ud->data) != NULL);\n}\n\n/* Is this a space? */\nstatic int\nstatus_prompt_space(const struct utf8_data *ud)\n{\n\tif (ud->size != 1 || ud->width != 1)\n\t\treturn (0);\n\treturn (*ud->data == ' ');\n}\n\n/*\n * Translate key from vi to emacs. Return 0 to drop key, 1 to process the key\n * as an emacs key; return 2 to append to the buffer.\n */\nstatic int\nstatus_prompt_translate_key(struct client *c, key_code key, key_code *new_key)\n{\n\tif (c->prompt_mode == PROMPT_ENTRY) {\n\t\tswitch (key) {\n\t\tcase 'a'|KEYC_CTRL:\n\t\tcase 'c'|KEYC_CTRL:\n\t\tcase 'e'|KEYC_CTRL:\n\t\tcase 'g'|KEYC_CTRL:\n\t\tcase 'h'|KEYC_CTRL:\n\t\tcase '\\011': /* Tab */\n\t\tcase 'k'|KEYC_CTRL:\n\t\tcase 'n'|KEYC_CTRL:\n\t\tcase 'p'|KEYC_CTRL:\n\t\tcase 't'|KEYC_CTRL:\n\t\tcase 'u'|KEYC_CTRL:\n\t\tcase 'v'|KEYC_CTRL:\n\t\tcase 'w'|KEYC_CTRL:\n\t\tcase 'y'|KEYC_CTRL:\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase KEYC_LEFT|KEYC_CTRL:\n\t\tcase KEYC_RIGHT|KEYC_CTRL:\n\t\tcase KEYC_BSPACE:\n\t\tcase KEYC_DC:\n\t\tcase KEYC_DOWN:\n\t\tcase KEYC_END:\n\t\tcase KEYC_HOME:\n\t\tcase KEYC_LEFT:\n\t\tcase KEYC_RIGHT:\n\t\tcase KEYC_UP:\n\t\t\t*new_key = key;\n\t\t\treturn (1);\n\t\tcase '\\033': /* Escape */\n\t\t\tc->prompt_mode = PROMPT_COMMAND;\n\t\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\t\treturn (0);\n\t\t}\n\t\t*new_key = key;\n\t\treturn (2);\n\t}\n\n\tswitch (key) {\n\tcase KEYC_BSPACE:\n\t\t*new_key = KEYC_LEFT;\n\t\treturn (1);\n\tcase 'A':\n\tcase 'I':\n\tcase 'C':\n\tcase 's':\n\tcase 'a':\n\t\tc->prompt_mode = PROMPT_ENTRY;\n\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\tbreak; /* switch mode and... */\n\tcase 'S':\n\t\tc->prompt_mode = PROMPT_ENTRY;\n\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\t*new_key = 'u'|KEYC_CTRL;\n\t\treturn (1);\n\tcase 'i':\n\tcase '\\033': /* Escape */\n\t\tc->prompt_mode = PROMPT_ENTRY;\n\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\treturn (0);\n\t}\n\n\tswitch (key) {\n\tcase 'A':\n\tcase '$':\n\t\t*new_key = KEYC_END;\n\t\treturn (1);\n\tcase 'I':\n\tcase '0':\n\tcase '^':\n\t\t*new_key = KEYC_HOME;\n\t\treturn (1);\n\tcase 'C':\n\tcase 'D':\n\t\t*new_key = 'k'|KEYC_CTRL;\n\t\treturn (1);\n\tcase KEYC_BSPACE:\n\tcase 'X':\n\t\t*new_key = KEYC_BSPACE;\n\t\treturn (1);\n\tcase 'b':\n\t\t*new_key = 'b'|KEYC_META;\n\t\treturn (1);\n\tcase 'B':\n\t\t*new_key = 'B'|KEYC_VI;\n\t\treturn (1);\n\tcase 'd':\n\t\t*new_key = 'u'|KEYC_CTRL;\n\t\treturn (1);\n\tcase 'e':\n\t\t*new_key = 'e'|KEYC_VI;\n\t\treturn (1);\n\tcase 'E':\n\t\t*new_key = 'E'|KEYC_VI;\n\t\treturn (1);\n\tcase 'w':\n\t\t*new_key = 'w'|KEYC_VI;\n\t\treturn (1);\n\tcase 'W':\n\t\t*new_key = 'W'|KEYC_VI;\n\t\treturn (1);\n\tcase 'p':\n\t\t*new_key = 'y'|KEYC_CTRL;\n\t\treturn (1);\n\tcase 'q':\n\t\t*new_key = 'c'|KEYC_CTRL;\n\t\treturn (1);\n\tcase 's':\n\tcase KEYC_DC:\n\tcase 'x':\n\t\t*new_key = KEYC_DC;\n\t\treturn (1);\n\tcase KEYC_DOWN:\n\tcase 'j':\n\t\t*new_key = KEYC_DOWN;\n\t\treturn (1);\n\tcase KEYC_LEFT:\n\tcase 'h':\n\t\t*new_key = KEYC_LEFT;\n\t\treturn (1);\n\tcase 'a':\n\tcase KEYC_RIGHT:\n\tcase 'l':\n\t\t*new_key = KEYC_RIGHT;\n\t\treturn (1);\n\tcase KEYC_UP:\n\tcase 'k':\n\t\t*new_key = KEYC_UP;\n\t\treturn (1);\n\tcase 'h'|KEYC_CTRL:\n\tcase 'c'|KEYC_CTRL:\n\tcase '\\n':\n\tcase '\\r':\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Paste into prompt. */\nstatic int\nstatus_prompt_paste(struct client *c)\n{\n\tstruct paste_buffer\t*pb;\n\tconst char\t\t*bufdata;\n\tsize_t\t\t\t size, n, bufsize;\n\tu_int\t\t\t i;\n\tstruct utf8_data\t*ud, *udp;\n\tenum utf8_state\t\t more;\n\n\tsize = utf8_strlen(c->prompt_buffer);\n\tif (c->prompt_saved != NULL) {\n\t\tud = c->prompt_saved;\n\t\tn = utf8_strlen(c->prompt_saved);\n\t} else {\n\t\tif ((pb = paste_get_top(NULL)) == NULL)\n\t\t\treturn (0);\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tud = udp = xreallocarray(NULL, bufsize + 1, sizeof *ud);\n\t\tfor (i = 0; i != bufsize; /* nothing */) {\n\t\t\tmore = utf8_open(udp, bufdata[i]);\n\t\t\tif (more == UTF8_MORE) {\n\t\t\t\twhile (++i != bufsize && more == UTF8_MORE)\n\t\t\t\t\tmore = utf8_append(udp, bufdata[i]);\n\t\t\t\tif (more == UTF8_DONE) {\n\t\t\t\t\tudp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ti -= udp->have;\n\t\t\t}\n\t\t\tif (bufdata[i] <= 31 || bufdata[i] >= 127)\n\t\t\t\tbreak;\n\t\t\tutf8_set(udp, bufdata[i]);\n\t\t\tudp++;\n\t\t\ti++;\n\t\t}\n\t\tudp->size = 0;\n\t\tn = udp - ud;\n\t}\n\tif (n != 0) {\n\t\tc->prompt_buffer = xreallocarray(c->prompt_buffer, size + n + 1,\n\t\t    sizeof *c->prompt_buffer);\n\t\tif (c->prompt_index == size) {\n\t\t\tmemcpy(c->prompt_buffer + c->prompt_index, ud,\n\t\t\t    n * sizeof *c->prompt_buffer);\n\t\t\tc->prompt_index += n;\n\t\t\tc->prompt_buffer[c->prompt_index].size = 0;\n\t\t} else {\n\t\t\tmemmove(c->prompt_buffer + c->prompt_index + n,\n\t\t\t    c->prompt_buffer + c->prompt_index,\n\t\t\t    (size + 1 - c->prompt_index) *\n\t\t\t    sizeof *c->prompt_buffer);\n\t\t\tmemcpy(c->prompt_buffer + c->prompt_index, ud,\n\t\t\t    n * sizeof *c->prompt_buffer);\n\t\t\tc->prompt_index += n;\n\t\t}\n\t}\n\tif (ud != c->prompt_saved)\n\t\tfree(ud);\n\treturn (1);\n}\n\n/* Finish completion. */\nstatic int\nstatus_prompt_replace_complete(struct client *c, const char *s)\n{\n\tchar\t\t\t word[64], *allocated = NULL;\n\tsize_t\t\t\t size, n, off, idx, used;\n\tstruct utf8_data\t*first, *last, *ud;\n\n\t/* Work out where the cursor currently is. */\n\tidx = c->prompt_index;\n\tif (idx != 0)\n\t\tidx--;\n\tsize = utf8_strlen(c->prompt_buffer);\n\n\t/* Find the word we are in. */\n\tfirst = &c->prompt_buffer[idx];\n\twhile (first > c->prompt_buffer && !status_prompt_space(first))\n\t\tfirst--;\n\twhile (first->size != 0 && status_prompt_space(first))\n\t\tfirst++;\n\tlast = &c->prompt_buffer[idx];\n\twhile (last->size != 0 && !status_prompt_space(last))\n\t\tlast++;\n\twhile (last > c->prompt_buffer && status_prompt_space(last))\n\t\tlast--;\n\tif (last->size != 0)\n\t\tlast++;\n\tif (last < first)\n\t\treturn (0);\n\tif (s == NULL) {\n\t\tused = 0;\n\t\tfor (ud = first; ud < last; ud++) {\n\t\t\tif (used + ud->size >= sizeof word)\n\t\t\t\tbreak;\n\t\t\tmemcpy(word + used, ud->data, ud->size);\n\t\t\tused += ud->size;\n\t\t}\n\t\tif (ud != last)\n\t\t\treturn (0);\n\t\tword[used] = '\\0';\n\t}\n\n\t/* Try to complete it. */\n\tif (s == NULL) {\n\t\tallocated = status_prompt_complete(c, word,\n\t\t    first - c->prompt_buffer);\n\t\tif (allocated == NULL)\n\t\t\treturn (0);\n\t\ts = allocated;\n\t}\n\n\t/* Trim out word. */\n\tn = size - (last - c->prompt_buffer) + 1; /* with \\0 */\n\tmemmove(first, last, n * sizeof *c->prompt_buffer);\n\tsize -= last - first;\n\n\t/* Insert the new word. */\n\tsize += strlen(s);\n\toff = first - c->prompt_buffer;\n\tc->prompt_buffer = xreallocarray(c->prompt_buffer, size + 1,\n\t    sizeof *c->prompt_buffer);\n\tfirst = c->prompt_buffer + off;\n\tmemmove(first + strlen(s), first, n * sizeof *c->prompt_buffer);\n\tfor (idx = 0; idx < strlen(s); idx++)\n\t\tutf8_set(&first[idx], s[idx]);\n\tc->prompt_index = (first - c->prompt_buffer) + strlen(s);\n\n\tfree(allocated);\n\treturn (1);\n}\n\n/* Prompt forward to the next beginning of a word. */\nstatic void\nstatus_prompt_forward_word(struct client *c, size_t size, int vi,\n    const char *separators)\n{\n\tsize_t\t\t idx = c->prompt_index;\n\tint\t\t word_is_separators;\n\n\t/* In emacs mode, skip until the first non-whitespace character. */\n\tif (!vi)\n\t\twhile (idx != size &&\n\t\t    status_prompt_space(&c->prompt_buffer[idx]))\n\t\t\tidx++;\n\n\t/* Can't move forward if we're already at the end. */\n\tif (idx == size) {\n\t\tc->prompt_index = idx;\n\t\treturn;\n\t}\n\n\t/* Determine the current character class (separators or not). */\n\tword_is_separators = status_prompt_in_list(separators,\n\t    &c->prompt_buffer[idx]) &&\n\t    !status_prompt_space(&c->prompt_buffer[idx]);\n\n\t/* Skip ahead until the first space or opposite character class. */\n\tdo {\n\t\tidx++;\n\t\tif (status_prompt_space(&c->prompt_buffer[idx])) {\n\t\t\t/* In vi mode, go to the start of the next word. */\n\t\t\tif (vi)\n\t\t\t\twhile (idx != size &&\n\t\t\t\t    status_prompt_space(&c->prompt_buffer[idx]))\n\t\t\t\t\tidx++;\n\t\t\tbreak;\n\t\t}\n\t} while (idx != size && word_is_separators == status_prompt_in_list(\n\t    separators, &c->prompt_buffer[idx]));\n\n\tc->prompt_index = idx;\n}\n\n/* Prompt forward to the next end of a word. */\nstatic void\nstatus_prompt_end_word(struct client *c, size_t size, const char *separators)\n{\n\tsize_t\t\t idx = c->prompt_index;\n\tint\t\t word_is_separators;\n\n\t/* Can't move forward if we're already at the end. */\n\tif (idx == size)\n\t\treturn;\n\n\t/* Find the next word. */\n\tdo {\n\t\tidx++;\n\t\tif (idx == size) {\n\t\t\tc->prompt_index = idx;\n\t\t\treturn;\n\t\t}\n\t} while (status_prompt_space(&c->prompt_buffer[idx]));\n\n\t/* Determine the character class (separators or not). */\n\tword_is_separators = status_prompt_in_list(separators,\n\t    &c->prompt_buffer[idx]);\n\n\t/* Skip ahead until the next space or opposite character class. */\n\tdo {\n\t\tidx++;\n\t\tif (idx == size)\n\t\t\tbreak;\n\t} while (!status_prompt_space(&c->prompt_buffer[idx]) &&\n\t    word_is_separators == status_prompt_in_list(separators,\n\t    &c->prompt_buffer[idx]));\n\n\t/* Back up to the previous character to stop at the end of the word. */\n\tc->prompt_index = idx - 1;\n}\n\n/* Prompt backward to the previous beginning of a word. */\nstatic void\nstatus_prompt_backward_word(struct client *c, const char *separators)\n{\n\tsize_t\tidx = c->prompt_index;\n\tint\tword_is_separators;\n\n\t/* Find non-whitespace. */\n\twhile (idx != 0) {\n\t\t--idx;\n\t\tif (!status_prompt_space(&c->prompt_buffer[idx]))\n\t\t\tbreak;\n\t}\n\tword_is_separators = status_prompt_in_list(separators,\n\t    &c->prompt_buffer[idx]);\n\n\t/* Find the character before the beginning of the word. */\n\twhile (idx != 0) {\n\t\t--idx;\n\t\tif (status_prompt_space(&c->prompt_buffer[idx]) ||\n\t\t    word_is_separators != status_prompt_in_list(separators,\n\t\t    &c->prompt_buffer[idx])) {\n\t\t\t/* Go back to the word. */\n\t\t\tidx++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tc->prompt_index = idx;\n}\n\n/* Handle keys in prompt. */\nint\nstatus_prompt_key(struct client *c, key_code key)\n{\n\tstruct options\t\t*oo = c->session->options;\n\tchar\t\t\t*s, *cp, prefix = '=';\n\tconst char\t\t*histstr, *separators = NULL, *keystring;\n\tsize_t\t\t\t size, idx;\n\tstruct utf8_data\t tmp;\n\tint\t\t\t keys, word_is_separators;\n\n\tif (c->prompt_flags & PROMPT_KEY) {\n\t\tkeystring = key_string_lookup_key(key, 0);\n\t\tc->prompt_inputcb(c, c->prompt_data, keystring, 1);\n\t\tstatus_prompt_clear(c);\n\t\treturn (0);\n\t}\n\tsize = utf8_strlen(c->prompt_buffer);\n\n\tif (c->prompt_flags & PROMPT_NUMERIC) {\n\t\tif (key >= '0' && key <= '9')\n\t\t\tgoto append_key;\n\t\ts = utf8_tocstr(c->prompt_buffer);\n\t\tc->prompt_inputcb(c, c->prompt_data, s, 1);\n\t\tstatus_prompt_clear(c);\n\t\tfree(s);\n\t\treturn (1);\n\t}\n\tkey &= ~KEYC_MASK_FLAGS;\n\n\tif (c->prompt_flags & (PROMPT_SINGLE|PROMPT_QUOTENEXT)) {\n\t\tif ((key & KEYC_MASK_KEY) == KEYC_BSPACE)\n\t\t\tkey = 0x7f;\n\t\telse if ((key & KEYC_MASK_KEY) > 0x7f) {\n\t\t\tif (!KEYC_IS_UNICODE(key))\n\t\t\t\treturn (0);\n\t\t\tkey &= KEYC_MASK_KEY;\n\t\t} else\n\t\t\tkey &= (key & KEYC_CTRL) ? 0x1f : KEYC_MASK_KEY;\n\t\tc->prompt_flags &= ~PROMPT_QUOTENEXT;\n\t\tgoto append_key;\n\t}\n\n\tkeys = options_get_number(c->session->options, \"status-keys\");\n\tif (keys == MODEKEY_VI) {\n\t\tswitch (status_prompt_translate_key(c, key, &key)) {\n\t\tcase 1:\n\t\t\tgoto process_key;\n\t\tcase 2:\n\t\t\tgoto append_key;\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\t}\n\nprocess_key:\n\tswitch (key) {\n\tcase KEYC_LEFT:\n\tcase 'b'|KEYC_CTRL:\n\t\tif (c->prompt_index > 0) {\n\t\t\tc->prompt_index--;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase KEYC_RIGHT:\n\tcase 'f'|KEYC_CTRL:\n\t\tif (c->prompt_index < size) {\n\t\t\tc->prompt_index++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase KEYC_HOME:\n\tcase 'a'|KEYC_CTRL:\n\t\tif (c->prompt_index != 0) {\n\t\t\tc->prompt_index = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase KEYC_END:\n\tcase 'e'|KEYC_CTRL:\n\t\tif (c->prompt_index != size) {\n\t\t\tc->prompt_index = size;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '\\011': /* Tab */\n\t\tif (status_prompt_replace_complete(c, NULL))\n\t\t\tgoto changed;\n\t\tbreak;\n\tcase KEYC_BSPACE:\n\tcase 'h'|KEYC_CTRL:\n\t\tif (c->prompt_index != 0) {\n\t\t\tif (c->prompt_index == size)\n\t\t\t\tc->prompt_buffer[--c->prompt_index].size = 0;\n\t\t\telse {\n\t\t\t\tmemmove(c->prompt_buffer + c->prompt_index - 1,\n\t\t\t\t    c->prompt_buffer + c->prompt_index,\n\t\t\t\t    (size + 1 - c->prompt_index) *\n\t\t\t\t    sizeof *c->prompt_buffer);\n\t\t\t\tc->prompt_index--;\n\t\t\t}\n\t\t\tgoto changed;\n\t\t}\n\t\tbreak;\n\tcase KEYC_DC:\n\tcase 'd'|KEYC_CTRL:\n\t\tif (c->prompt_index != size) {\n\t\t\tmemmove(c->prompt_buffer + c->prompt_index,\n\t\t\t    c->prompt_buffer + c->prompt_index + 1,\n\t\t\t    (size + 1 - c->prompt_index) *\n\t\t\t    sizeof *c->prompt_buffer);\n\t\t\tgoto changed;\n\t\t}\n\t\tbreak;\n\tcase 'u'|KEYC_CTRL:\n\t\tc->prompt_buffer[0].size = 0;\n\t\tc->prompt_index = 0;\n\t\tgoto changed;\n\tcase 'k'|KEYC_CTRL:\n\t\tif (c->prompt_index < size) {\n\t\t\tc->prompt_buffer[c->prompt_index].size = 0;\n\t\t\tgoto changed;\n\t\t}\n\t\tbreak;\n\tcase 'w'|KEYC_CTRL:\n\t\tseparators = options_get_string(oo, \"word-separators\");\n\t\tidx = c->prompt_index;\n\n\t\t/* Find non-whitespace. */\n\t\twhile (idx != 0) {\n\t\t\tidx--;\n\t\t\tif (!status_prompt_space(&c->prompt_buffer[idx]))\n\t\t\t\tbreak;\n\t\t}\n\t\tword_is_separators = status_prompt_in_list(separators,\n\t\t    &c->prompt_buffer[idx]);\n\n\t\t/* Find the character before the beginning of the word. */\n\t\twhile (idx != 0) {\n\t\t\tidx--;\n\t\t\tif (status_prompt_space(&c->prompt_buffer[idx]) ||\n\t\t\t    word_is_separators != status_prompt_in_list(\n\t\t\t    separators, &c->prompt_buffer[idx])) {\n\t\t\t\t/* Go back to the word. */\n\t\t\t\tidx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfree(c->prompt_saved);\n\t\tc->prompt_saved = xcalloc(sizeof *c->prompt_buffer,\n\t\t    (c->prompt_index - idx) + 1);\n\t\tmemcpy(c->prompt_saved, c->prompt_buffer + idx,\n\t\t    (c->prompt_index - idx) * sizeof *c->prompt_buffer);\n\n\t\tmemmove(c->prompt_buffer + idx,\n\t\t    c->prompt_buffer + c->prompt_index,\n\t\t    (size + 1 - c->prompt_index) *\n\t\t    sizeof *c->prompt_buffer);\n\t\tmemset(c->prompt_buffer + size - (c->prompt_index - idx),\n\t\t    '\\0', (c->prompt_index - idx) * sizeof *c->prompt_buffer);\n\t\tc->prompt_index = idx;\n\n\t\tgoto changed;\n\tcase KEYC_RIGHT|KEYC_CTRL:\n\tcase 'f'|KEYC_META:\n\t\tseparators = options_get_string(oo, \"word-separators\");\n\t\tstatus_prompt_forward_word(c, size, 0, separators);\n\t\tgoto changed;\n\tcase 'E'|KEYC_VI:\n\t\tstatus_prompt_end_word(c, size, \"\");\n\t\tgoto changed;\n\tcase 'e'|KEYC_VI:\n\t\tseparators = options_get_string(oo, \"word-separators\");\n\t\tstatus_prompt_end_word(c, size, separators);\n\t\tgoto changed;\n\tcase 'W'|KEYC_VI:\n\t\tstatus_prompt_forward_word(c, size, 1, \"\");\n\t\tgoto changed;\n\tcase 'w'|KEYC_VI:\n\t\tseparators = options_get_string(oo, \"word-separators\");\n\t\tstatus_prompt_forward_word(c, size, 1, separators);\n\t\tgoto changed;\n\tcase 'B'|KEYC_VI:\n\t\tstatus_prompt_backward_word(c, \"\");\n\t\tgoto changed;\n\tcase KEYC_LEFT|KEYC_CTRL:\n\tcase 'b'|KEYC_META:\n\t\tseparators = options_get_string(oo, \"word-separators\");\n\t\tstatus_prompt_backward_word(c, separators);\n\t\tgoto changed;\n\tcase KEYC_UP:\n\tcase 'p'|KEYC_CTRL:\n\t\thiststr = status_prompt_up_history(c->prompt_hindex,\n\t\t    c->prompt_type);\n\t\tif (histstr == NULL)\n\t\t\tbreak;\n\t\tfree(c->prompt_buffer);\n\t\tc->prompt_buffer = utf8_fromcstr(histstr);\n\t\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\t\tgoto changed;\n\tcase KEYC_DOWN:\n\tcase 'n'|KEYC_CTRL:\n\t\thiststr = status_prompt_down_history(c->prompt_hindex,\n\t\t    c->prompt_type);\n\t\tif (histstr == NULL)\n\t\t\tbreak;\n\t\tfree(c->prompt_buffer);\n\t\tc->prompt_buffer = utf8_fromcstr(histstr);\n\t\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\t\tgoto changed;\n\tcase 'y'|KEYC_CTRL:\n\t\tif (status_prompt_paste(c))\n\t\t\tgoto changed;\n\t\tbreak;\n\tcase 't'|KEYC_CTRL:\n\t\tidx = c->prompt_index;\n\t\tif (idx < size)\n\t\t\tidx++;\n\t\tif (idx >= 2) {\n\t\t\tutf8_copy(&tmp, &c->prompt_buffer[idx - 2]);\n\t\t\tutf8_copy(&c->prompt_buffer[idx - 2],\n\t\t\t    &c->prompt_buffer[idx - 1]);\n\t\t\tutf8_copy(&c->prompt_buffer[idx - 1], &tmp);\n\t\t\tc->prompt_index = idx;\n\t\t\tgoto changed;\n\t\t}\n\t\tbreak;\n\tcase '\\r':\n\tcase '\\n':\n\t\ts = utf8_tocstr(c->prompt_buffer);\n\t\tif (*s != '\\0')\n\t\t\tstatus_prompt_add_history(s, c->prompt_type);\n\t\tif (c->prompt_inputcb(c, c->prompt_data, s, 1) == 0)\n\t\t\tstatus_prompt_clear(c);\n\t\tfree(s);\n\t\tbreak;\n\tcase '\\033': /* Escape */\n\tcase 'c'|KEYC_CTRL:\n\tcase 'g'|KEYC_CTRL:\n\t\tif (c->prompt_inputcb(c, c->prompt_data, NULL, 1) == 0)\n\t\t\tstatus_prompt_clear(c);\n\t\tbreak;\n\tcase 'r'|KEYC_CTRL:\n\t\tif (~c->prompt_flags & PROMPT_INCREMENTAL)\n\t\t\tbreak;\n\t\tif (c->prompt_buffer[0].size == 0) {\n\t\t\tprefix = '=';\n\t\t\tfree(c->prompt_buffer);\n\t\t\tc->prompt_buffer = utf8_fromcstr(c->prompt_last);\n\t\t\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\t\t} else\n\t\t\tprefix = '-';\n\t\tgoto changed;\n\tcase 's'|KEYC_CTRL:\n\t\tif (~c->prompt_flags & PROMPT_INCREMENTAL)\n\t\t\tbreak;\n\t\tif (c->prompt_buffer[0].size == 0) {\n\t\t\tprefix = '=';\n\t\t\tfree(c->prompt_buffer);\n\t\t\tc->prompt_buffer = utf8_fromcstr(c->prompt_last);\n\t\t\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\t\t} else\n\t\t\tprefix = '+';\n\t\tgoto changed;\n\tcase 'v'|KEYC_CTRL:\n\t\tc->prompt_flags |= PROMPT_QUOTENEXT;\n\t\tbreak;\n\tdefault:\n\t\tgoto append_key;\n\t}\n\n\tc->flags |= CLIENT_REDRAWSTATUS;\n\treturn (0);\n\nappend_key:\n\tif (key <= 0x7f) {\n\t\tutf8_set(&tmp, key);\n\t\tif (key <= 0x1f || key == 0x7f)\n\t\t\ttmp.width = 2;\n\t} else if (KEYC_IS_UNICODE(key))\n\t\tutf8_to_data(key, &tmp);\n\telse\n\t\treturn (0);\n\n\tc->prompt_buffer = xreallocarray(c->prompt_buffer, size + 2,\n\t    sizeof *c->prompt_buffer);\n\n\tif (c->prompt_index == size) {\n\t\tutf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);\n\t\tc->prompt_index++;\n\t\tc->prompt_buffer[c->prompt_index].size = 0;\n\t} else {\n\t\tmemmove(c->prompt_buffer + c->prompt_index + 1,\n\t\t    c->prompt_buffer + c->prompt_index,\n\t\t    (size + 1 - c->prompt_index) *\n\t\t    sizeof *c->prompt_buffer);\n\t\tutf8_copy(&c->prompt_buffer[c->prompt_index], &tmp);\n\t\tc->prompt_index++;\n\t}\n\n\tif (c->prompt_flags & PROMPT_SINGLE) {\n\t\tif (utf8_strlen(c->prompt_buffer) != 1)\n\t\t\tstatus_prompt_clear(c);\n\t\telse {\n\t\t\ts = utf8_tocstr(c->prompt_buffer);\n\t\t\tif (c->prompt_inputcb(c, c->prompt_data, s, 1) == 0)\n\t\t\t\tstatus_prompt_clear(c);\n\t\t\tfree(s);\n\t\t}\n\t}\n\nchanged:\n\tc->flags |= CLIENT_REDRAWSTATUS;\n\tif (c->prompt_flags & PROMPT_INCREMENTAL) {\n\t\ts = utf8_tocstr(c->prompt_buffer);\n\t\txasprintf(&cp, \"%c%s\", prefix, s);\n\t\tc->prompt_inputcb(c, c->prompt_data, cp, 0);\n\t\tfree(cp);\n\t\tfree(s);\n\t}\n\treturn (0);\n}\n\n/* Get previous line from the history. */\nstatic const char *\nstatus_prompt_up_history(u_int *idx, u_int type)\n{\n\t/*\n\t * History runs from 0 to size - 1. Index is from 0 to size. Zero is\n\t * empty.\n\t */\n\n\tif (status_prompt_hsize[type] == 0 ||\n\t    idx[type] == status_prompt_hsize[type])\n\t\treturn (NULL);\n\tidx[type]++;\n\treturn (status_prompt_hlist[type][status_prompt_hsize[type] - idx[type]]);\n}\n\n/* Get next line from the history. */\nstatic const char *\nstatus_prompt_down_history(u_int *idx, u_int type)\n{\n\tif (status_prompt_hsize[type] == 0 || idx[type] == 0)\n\t\treturn (\"\");\n\tidx[type]--;\n\tif (idx[type] == 0)\n\t\treturn (\"\");\n\treturn (status_prompt_hlist[type][status_prompt_hsize[type] - idx[type]]);\n}\n\n/* Add line to the history. */\nstatic void\nstatus_prompt_add_history(const char *line, u_int type)\n{\n\tu_int\ti, oldsize, newsize, freecount, hlimit, new = 1;\n\tsize_t\tmovesize;\n\n\toldsize = status_prompt_hsize[type];\n\tif (oldsize > 0 &&\n\t    strcmp(status_prompt_hlist[type][oldsize - 1], line) == 0)\n\t\tnew = 0;\n\n\thlimit = options_get_number(global_options, \"prompt-history-limit\");\n\tif (hlimit > oldsize) {\n\t\tif (new == 0)\n\t\t\treturn;\n\t\tnewsize = oldsize + new;\n\t} else {\n\t\tnewsize = hlimit;\n\t\tfreecount = oldsize + new - newsize;\n\t\tif (freecount > oldsize)\n\t\t\tfreecount = oldsize;\n\t\tif (freecount == 0)\n\t\t\treturn;\n\t\tfor (i = 0; i < freecount; i++)\n\t\t\tfree(status_prompt_hlist[type][i]);\n\t\tmovesize = (oldsize - freecount) *\n\t\t    sizeof *status_prompt_hlist[type];\n\t\tif (movesize > 0) {\n\t\t\tmemmove(&status_prompt_hlist[type][0],\n\t\t\t    &status_prompt_hlist[type][freecount], movesize);\n\t\t}\n\t}\n\n\tif (newsize == 0) {\n\t\tfree(status_prompt_hlist[type]);\n\t\tstatus_prompt_hlist[type] = NULL;\n\t} else if (newsize != oldsize) {\n\t\tstatus_prompt_hlist[type] =\n\t\t    xreallocarray(status_prompt_hlist[type], newsize,\n\t\t\tsizeof *status_prompt_hlist[type]);\n\t}\n\n\tif (new == 1 && newsize > 0)\n\t\tstatus_prompt_hlist[type][newsize - 1] = xstrdup(line);\n\tstatus_prompt_hsize[type] = newsize;\n}\n\n/* Add to completion list. */\nstatic void\nstatus_prompt_add_list(char ***list, u_int *size, const char *s)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < *size; i++) {\n\t\tif (strcmp((*list)[i], s) == 0)\n\t\t\treturn;\n\t}\n\t*list = xreallocarray(*list, (*size) + 1, sizeof **list);\n\t(*list)[(*size)++] = xstrdup(s);\n}\n\n/* Build completion list. */\nstatic char **\nstatus_prompt_complete_list(u_int *size, const char *s, int at_start)\n{\n\tchar\t\t\t\t\t**list = NULL, *tmp;\n\tconst char\t\t\t\t**layout, *value, *cp;\n\tconst struct cmd_entry\t\t\t**cmdent;\n\tconst struct options_table_entry\t *oe;\n\tsize_t\t\t\t\t\t  slen = strlen(s), valuelen;\n\tstruct options_entry\t\t\t *o;\n\tstruct options_array_item\t\t *a;\n\tconst char\t\t\t\t *layouts[] = {\n\t\t\"even-horizontal\", \"even-vertical\",\n\t\t\"main-horizontal\", \"main-horizontal-mirrored\",\n\t\t\"main-vertical\", \"main-vertical-mirrored\", \"tiled\", NULL\n\t};\n\n\t*size = 0;\n\tfor (cmdent = cmd_table; *cmdent != NULL; cmdent++) {\n\t\tif (strncmp((*cmdent)->name, s, slen) == 0)\n\t\t\tstatus_prompt_add_list(&list, size, (*cmdent)->name);\n\t\tif ((*cmdent)->alias != NULL &&\n\t\t    strncmp((*cmdent)->alias, s, slen) == 0)\n\t\t\tstatus_prompt_add_list(&list, size, (*cmdent)->alias);\n\t}\n\to = options_get_only(global_options, \"command-alias\");\n\tif (o != NULL) {\n\t\ta = options_array_first(o);\n\t\twhile (a != NULL) {\n\t\t\tvalue = options_array_item_value(a)->string;\n\t\t\tif ((cp = strchr(value, '=')) == NULL)\n\t\t\t\tgoto next;\n\t\t\tvaluelen = cp - value;\n\t\t\tif (slen > valuelen || strncmp(value, s, slen) != 0)\n\t\t\t\tgoto next;\n\n\t\t\txasprintf(&tmp, \"%.*s\", (int)valuelen, value);\n\t\t\tstatus_prompt_add_list(&list, size, tmp);\n\t\t\tfree(tmp);\n\n\t\tnext:\n\t\t\ta = options_array_next(a);\n\t\t}\n\t}\n\tif (at_start)\n\t\treturn (list);\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (strncmp(oe->name, s, slen) == 0)\n\t\t\tstatus_prompt_add_list(&list, size, oe->name);\n\t}\n\tfor (layout = layouts; *layout != NULL; layout++) {\n\t\tif (strncmp(*layout, s, slen) == 0)\n\t\t\tstatus_prompt_add_list(&list, size, *layout);\n\t}\n\treturn (list);\n}\n\n/* Find longest prefix. */\nstatic char *\nstatus_prompt_complete_prefix(char **list, u_int size)\n{\n\tchar\t *out;\n\tu_int\t  i;\n\tsize_t\t  j;\n\n\tif (list == NULL || size == 0)\n\t\treturn (NULL);\n\tout = xstrdup(list[0]);\n\tfor (i = 1; i < size; i++) {\n\t\tj = strlen(list[i]);\n\t\tif (j > strlen(out))\n\t\t\tj = strlen(out);\n\t\tfor (; j > 0; j--) {\n\t\t\tif (out[j - 1] != list[i][j - 1])\n\t\t\t\tout[j - 1] = '\\0';\n\t\t}\n\t}\n\treturn (out);\n}\n\n/* Complete word menu callback. */\nstatic void\nstatus_prompt_menu_callback(__unused struct menu *menu, u_int idx, key_code key,\n    void *data)\n{\n\tstruct status_prompt_menu\t*spm = data;\n\tstruct client\t\t\t*c = spm->c;\n\tu_int\t\t\t\t i;\n\tchar\t\t\t\t*s;\n\n\tif (key != KEYC_NONE) {\n\t\tidx += spm->start;\n\t\tif (spm->flag == '\\0')\n\t\t\ts = xstrdup(spm->list[idx]);\n\t\telse\n\t\t\txasprintf(&s, \"-%c%s\", spm->flag, spm->list[idx]);\n\t\tif (c->prompt_type == PROMPT_TYPE_WINDOW_TARGET) {\n\t\t\tfree(c->prompt_buffer);\n\t\t\tc->prompt_buffer = utf8_fromcstr(s);\n\t\t\tc->prompt_index = utf8_strlen(c->prompt_buffer);\n\t\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\t} else if (status_prompt_replace_complete(c, s))\n\t\t\tc->flags |= CLIENT_REDRAWSTATUS;\n\t\tfree(s);\n\t}\n\n\tfor (i = 0; i < spm->size; i++)\n\t\tfree(spm->list[i]);\n\tfree(spm->list);\n}\n\n/* Show complete word menu. */\nstatic int\nstatus_prompt_complete_list_menu(struct client *c, char **list, u_int size,\n    u_int offset, char flag)\n{\n\tstruct menu\t\t\t*menu;\n\tstruct menu_item\t\t item;\n\tstruct status_prompt_menu\t*spm;\n\tu_int\t\t\t\t lines = status_line_size(c), height, i;\n\tu_int\t\t\t\t py;\n\n\tif (size <= 1)\n\t\treturn (0);\n\tif (c->tty.sy - lines < 3)\n\t\treturn (0);\n\n\tspm = xmalloc(sizeof *spm);\n\tspm->c = c;\n\tspm->size = size;\n\tspm->list = list;\n\tspm->flag = flag;\n\n\theight = c->tty.sy - lines - 2;\n\tif (height > 10)\n\t\theight = 10;\n\tif (height > size)\n\t\theight = size;\n\tspm->start = size - height;\n\n\tmenu = menu_create(\"\");\n\tfor (i = spm->start; i < size; i++) {\n\t\titem.name = list[i];\n\t\titem.key = '0' + (i - spm->start);\n\t\titem.command = NULL;\n\t\tmenu_add_item(menu, &item, NULL, c, NULL);\n\t}\n\n\tif (options_get_number(c->session->options, \"status-position\") == 0)\n\t\tpy = lines;\n\telse\n\t\tpy = c->tty.sy - 3 - height;\n\toffset += utf8_cstrwidth(c->prompt_string);\n\tif (offset > 2)\n\t\toffset -= 2;\n\telse\n\t\toffset = 0;\n\n\tif (menu_display(menu, MENU_NOMOUSE|MENU_TAB, 0, NULL, offset, py, c,\n\t    BOX_LINES_DEFAULT, NULL, NULL, NULL, NULL,\n\t    status_prompt_menu_callback, spm) != 0) {\n\t\tmenu_free(menu);\n\t\tfree(spm);\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\n/* Show complete word menu. */\nstatic char *\nstatus_prompt_complete_window_menu(struct client *c, struct session *s,\n    const char *word, u_int offset, char flag)\n{\n\tstruct menu\t\t\t *menu;\n\tstruct menu_item\t\t  item;\n\tstruct status_prompt_menu\t *spm;\n\tstruct winlink\t\t\t *wl;\n\tchar\t\t\t\t**list = NULL, *tmp;\n\tu_int\t\t\t\t  lines = status_line_size(c), height;\n\tu_int\t\t\t\t  py, size = 0;\n\n\tif (c->tty.sy - lines < 3)\n\t\treturn (NULL);\n\n\tspm = xmalloc(sizeof *spm);\n\tspm->c = c;\n\tspm->flag = flag;\n\n\theight = c->tty.sy - lines - 2;\n\tif (height > 10)\n\t\theight = 10;\n\tspm->start = 0;\n\n\tmenu = menu_create(\"\");\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (word != NULL && *word != '\\0') {\n\t\t\txasprintf(&tmp, \"%d\", wl->idx);\n\t\t\tif (strncmp(tmp, word, strlen(word)) != 0) {\n\t\t\t\tfree(tmp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(tmp);\n\t\t}\n\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tif (c->prompt_type == PROMPT_TYPE_WINDOW_TARGET) {\n\t\t\txasprintf(&tmp, \"%d (%s)\", wl->idx, wl->window->name);\n\t\t\txasprintf(&list[size++], \"%d\", wl->idx);\n\t\t} else {\n\t\t\txasprintf(&tmp, \"%s:%d (%s)\", s->name, wl->idx,\n\t\t\t    wl->window->name);\n\t\t\txasprintf(&list[size++], \"%s:%d\", s->name, wl->idx);\n\t\t}\n\t\titem.name = tmp;\n\t\titem.key = '0' + size - 1;\n\t\titem.command = NULL;\n\t\tmenu_add_item(menu, &item, NULL, c, NULL);\n\t\tfree(tmp);\n\n\t\tif (size == height)\n\t\t\tbreak;\n\t}\n\tif (size == 0) {\n\t\tmenu_free(menu);\n\t\tfree(spm);\n\t\treturn (NULL);\n\t}\n\tif (size == 1) {\n\t\tmenu_free(menu);\n\t\tif (flag != '\\0') {\n\t\t\txasprintf(&tmp, \"-%c%s\", flag, list[0]);\n\t\t\tfree(list[0]);\n\t\t} else\n\t\t\ttmp = list[0];\n\t\tfree(list);\n\t\tfree(spm);\n\t\treturn (tmp);\n\t}\n\tif (height > size)\n\t\theight = size;\n\n\tspm->size = size;\n\tspm->list = list;\n\n\tif (options_get_number(c->session->options, \"status-position\") == 0)\n\t\tpy = lines;\n\telse\n\t\tpy = c->tty.sy - 3 - height;\n\toffset += utf8_cstrwidth(c->prompt_string);\n\tif (offset > 2)\n\t\toffset -= 2;\n\telse\n\t\toffset = 0;\n\n\tif (menu_display(menu, MENU_NOMOUSE|MENU_TAB, 0, NULL, offset, py, c,\n\t    BOX_LINES_DEFAULT, NULL, NULL, NULL, NULL,\n\t    status_prompt_menu_callback, spm) != 0) {\n\t\tmenu_free(menu);\n\t\tfree(spm);\n\t\treturn (NULL);\n\t}\n\treturn (NULL);\n}\n\n/* Sort complete list. */\nstatic int\nstatus_prompt_complete_sort(const void *a, const void *b)\n{\n\tconst char\t**aa = (const char **)a, **bb = (const char **)b;\n\n\treturn (strcmp(*aa, *bb));\n}\n\n/* Complete a session. */\nstatic char *\nstatus_prompt_complete_session(char ***list, u_int *size, const char *s,\n    char flag)\n{\n\tstruct session\t*loop;\n\tchar\t\t*out, *tmp, n[11];\n\n\tRB_FOREACH(loop, sessions, &sessions) {\n\t\tif (*s == '\\0' || strncmp(loop->name, s, strlen(s)) == 0) {\n\t\t\t*list = xreallocarray(*list, (*size) + 2,\n\t\t\t    sizeof **list);\n\t\t\txasprintf(&(*list)[(*size)++], \"%s:\", loop->name);\n\t\t} else if (*s == '$') {\n\t\t\txsnprintf(n, sizeof n, \"%u\", loop->id);\n\t\t\tif (s[1] == '\\0' ||\n\t\t\t    strncmp(n, s + 1, strlen(s) - 1) == 0) {\n\t\t\t\t*list = xreallocarray(*list, (*size) + 2,\n\t\t\t\t    sizeof **list);\n\t\t\t\txasprintf(&(*list)[(*size)++], \"$%s:\", n);\n\t\t\t}\n\t\t}\n\t}\n\tout = status_prompt_complete_prefix(*list, *size);\n\tif (out != NULL && flag != '\\0') {\n\t\txasprintf(&tmp, \"-%c%s\", flag, out);\n\t\tfree(out);\n\t\tout = tmp;\n\t}\n\treturn (out);\n}\n\n/* Complete word. */\nstatic char *\nstatus_prompt_complete(struct client *c, const char *word, u_int offset)\n{\n\tstruct session\t *session;\n\tconst char\t *s, *colon;\n\tchar\t\t**list = NULL, *copy = NULL, *out = NULL;\n\tchar\t\t  flag = '\\0';\n\tu_int\t\t  size = 0, i;\n\n\tif (*word == '\\0' &&\n\t    c->prompt_type != PROMPT_TYPE_TARGET &&\n\t    c->prompt_type != PROMPT_TYPE_WINDOW_TARGET)\n\t\treturn (NULL);\n\n\tif (c->prompt_type != PROMPT_TYPE_TARGET &&\n\t    c->prompt_type != PROMPT_TYPE_WINDOW_TARGET &&\n\t    strncmp(word, \"-t\", 2) != 0 &&\n\t    strncmp(word, \"-s\", 2) != 0) {\n\t\tlist = status_prompt_complete_list(&size, word, offset == 0);\n\t\tif (size == 0)\n\t\t\tout = NULL;\n\t\telse if (size == 1)\n\t\t\txasprintf(&out, \"%s \", list[0]);\n\t\telse\n\t\t\tout = status_prompt_complete_prefix(list, size);\n\t\tgoto found;\n\t}\n\n\tif (c->prompt_type == PROMPT_TYPE_TARGET ||\n\t    c->prompt_type == PROMPT_TYPE_WINDOW_TARGET) {\n\t\ts = word;\n\t\tflag = '\\0';\n\t} else {\n\t\ts = word + 2;\n\t\tflag = word[1];\n\t\toffset += 2;\n\t}\n\n\t/* If this is a window completion, open the window menu. */\n\tif (c->prompt_type == PROMPT_TYPE_WINDOW_TARGET) {\n\t\tout = status_prompt_complete_window_menu(c, c->session, s,\n\t\t    offset, '\\0');\n\t\tgoto found;\n\t}\n\tcolon = strchr(s, ':');\n\n\t/* If there is no colon, complete as a session. */\n\tif (colon == NULL) {\n\t\tout = status_prompt_complete_session(&list, &size, s, flag);\n\t\tgoto found;\n\t}\n\n\t/* If there is a colon but no period, find session and show a menu. */\n\tif (strchr(colon + 1, '.') == NULL) {\n\t\tif (*s == ':')\n\t\t\tsession = c->session;\n\t\telse {\n\t\t\tcopy = xstrdup(s);\n\t\t\t*strchr(copy, ':') = '\\0';\n\t\t\tsession = session_find(copy);\n\t\t\tfree(copy);\n\t\t\tif (session == NULL)\n\t\t\t\tgoto found;\n\t\t}\n\t\tout = status_prompt_complete_window_menu(c, session, colon + 1,\n\t\t    offset, flag);\n\t\tif (out == NULL)\n\t\t\treturn (NULL);\n\t}\n\nfound:\n\tif (size != 0) {\n\t\tqsort(list, size, sizeof *list, status_prompt_complete_sort);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tlog_debug(\"complete %u: %s\", i, list[i]);\n\t}\n\n\tif (out != NULL && strcmp(word, out) == 0) {\n\t\tfree(out);\n\t\tout = NULL;\n\t}\n\tif (out != NULL ||\n\t    !status_prompt_complete_list_menu(c, list, size, offset, flag)) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tfree(list[i]);\n\t\tfree(list);\n\t}\n\treturn (out);\n}\n\n/* Return the type of the prompt as an enum. */\nenum prompt_type\nstatus_prompt_type(const char *type)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < PROMPT_NTYPES; i++) {\n\t\tif (strcmp(type, status_prompt_type_string(i)) == 0)\n\t\t\treturn (i);\n\t}\n\treturn (PROMPT_TYPE_INVALID);\n}\n\n/* Accessor for prompt_type_strings. */\nconst char *\nstatus_prompt_type_string(u_int type)\n{\n\tif (type >= PROMPT_NTYPES)\n\t\treturn (\"invalid\");\n\treturn (prompt_type_strings[type]);\n}\n"
        },
        {
          "name": "style.c",
          "type": "blob",
          "size": 11.8642578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2014 Tiago Cunha <tcunha@users.sourceforge.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/* Mask for bits not included in style. */\n#define STYLE_ATTR_MASK (~0)\n\n/* Default style. */\nstatic struct style style_default = {\n\t{ { { ' ' }, 0, 1, 1 }, 0, 0, 8, 8, 0, 0 },\n\t0,\n\n\t8,\n\tSTYLE_ALIGN_DEFAULT,\n\tSTYLE_LIST_OFF,\n\n\tSTYLE_RANGE_NONE, 0, \"\",\n\n\tSTYLE_WIDTH_DEFAULT, STYLE_PAD_DEFAULT,\n\n\tSTYLE_DEFAULT_BASE\n};\n\n/* Set range string. */\nstatic void\nstyle_set_range_string(struct style *sy, const char *s)\n{\n\tstrlcpy(sy->range_string, s, sizeof sy->range_string);\n}\n\n/*\n * Parse an embedded style of the form \"fg=colour,bg=colour,bright,...\".  Note\n * that this adds onto the given style, so it must have been initialized\n * already.\n */\nint\nstyle_parse(struct style *sy, const struct grid_cell *base, const char *in)\n{\n\tstruct style\tsaved;\n\tconst char\tdelimiters[] = \" ,\\n\", *errstr;\n\tchar\t\ttmp[256], *found;\n\tint\t\tvalue;\n\tsize_t\t\tend;\n\tu_int\t\tn;\n\n\tif (*in == '\\0')\n\t\treturn (0);\n\tstyle_copy(&saved, sy);\n\n\tlog_debug(\"%s: %s\", __func__, in);\n\tdo {\n\t\twhile (*in != '\\0' && strchr(delimiters, *in) != NULL)\n\t\t\tin++;\n\t\tif (*in == '\\0')\n\t\t\tbreak;\n\n\t\tend = strcspn(in, delimiters);\n\t\tif (end > (sizeof tmp) - 1)\n\t\t\tgoto error;\n\t\tmemcpy(tmp, in, end);\n\t\ttmp[end] = '\\0';\n\n\t\tlog_debug(\"%s: %s\", __func__, tmp);\n\t\tif (strcasecmp(tmp, \"default\") == 0) {\n\t\t\tsy->gc.fg = base->fg;\n\t\t\tsy->gc.bg = base->bg;\n\t\t\tsy->gc.us = base->us;\n\t\t\tsy->gc.attr = base->attr;\n\t\t\tsy->gc.flags = base->flags;\n\t\t} else if (strcasecmp(tmp, \"ignore\") == 0)\n\t\t\tsy->ignore = 1;\n\t\telse if (strcasecmp(tmp, \"noignore\") == 0)\n\t\t\tsy->ignore = 0;\n\t\telse if (strcasecmp(tmp, \"push-default\") == 0)\n\t\t\tsy->default_type = STYLE_DEFAULT_PUSH;\n\t\telse if (strcasecmp(tmp, \"pop-default\") == 0)\n\t\t\tsy->default_type = STYLE_DEFAULT_POP;\n\t\telse if (strcasecmp(tmp, \"nolist\") == 0)\n\t\t\tsy->list = STYLE_LIST_OFF;\n\t\telse if (strncasecmp(tmp, \"list=\", 5) == 0) {\n\t\t\tif (strcasecmp(tmp + 5, \"on\") == 0)\n\t\t\t\tsy->list = STYLE_LIST_ON;\n\t\t\telse if (strcasecmp(tmp + 5, \"focus\") == 0)\n\t\t\t\tsy->list = STYLE_LIST_FOCUS;\n\t\t\telse if (strcasecmp(tmp + 5, \"left-marker\") == 0)\n\t\t\t\tsy->list = STYLE_LIST_LEFT_MARKER;\n\t\t\telse if (strcasecmp(tmp + 5, \"right-marker\") == 0)\n\t\t\t\tsy->list = STYLE_LIST_RIGHT_MARKER;\n\t\t\telse\n\t\t\t\tgoto error;\n\t\t} else if (strcasecmp(tmp, \"norange\") == 0) {\n\t\t\tsy->range_type = style_default.range_type;\n\t\t\tsy->range_argument = style_default.range_type;\n\t\t\tstrlcpy(sy->range_string, style_default.range_string,\n\t\t\t    sizeof sy->range_string);\n\t\t} else if (end > 6 && strncasecmp(tmp, \"range=\", 6) == 0) {\n\t\t\tfound = strchr(tmp + 6, '|');\n\t\t\tif (found != NULL) {\n\t\t\t\t*found++ = '\\0';\n\t\t\t\tif (*found == '\\0')\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (strcasecmp(tmp + 6, \"left\") == 0) {\n\t\t\t\tif (found != NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_LEFT;\n\t\t\t\tsy->range_argument = 0;\n\t\t\t\tstyle_set_range_string(sy, \"\");\n\t\t\t} else if (strcasecmp(tmp + 6, \"right\") == 0) {\n\t\t\t\tif (found != NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_RIGHT;\n\t\t\t\tsy->range_argument = 0;\n\t\t\t\tstyle_set_range_string(sy, \"\");\n\t\t\t} else if (strcasecmp(tmp + 6, \"pane\") == 0) {\n\t\t\t\tif (found == NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tif (*found != '%' || found[1] == '\\0')\n\t\t\t\t\tgoto error;\n\t\t\t\tn = strtonum(found + 1, 0, UINT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_PANE;\n\t\t\t\tsy->range_argument = n;\n\t\t\t\tstyle_set_range_string(sy, \"\");\n\t\t\t} else if (strcasecmp(tmp + 6, \"window\") == 0) {\n\t\t\t\tif (found == NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tn = strtonum(found, 0, UINT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_WINDOW;\n\t\t\t\tsy->range_argument = n;\n\t\t\t\tstyle_set_range_string(sy, \"\");\n\t\t\t} else if (strcasecmp(tmp + 6, \"session\") == 0) {\n\t\t\t\tif (found == NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tif (*found != '$' || found[1] == '\\0')\n\t\t\t\t\tgoto error;\n\t\t\t\tn = strtonum(found + 1, 0, UINT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_SESSION;\n\t\t\t\tsy->range_argument = n;\n\t\t\t\tstyle_set_range_string(sy, \"\");\n\t\t\t} else if (strcasecmp(tmp + 6, \"user\") == 0) {\n\t\t\t\tif (found == NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tsy->range_type = STYLE_RANGE_USER;\n\t\t\t\tsy->range_argument = 0;\n\t\t\t\tstyle_set_range_string(sy, found);\n\t\t\t}\n\t\t} else if (strcasecmp(tmp, \"noalign\") == 0)\n\t\t\tsy->align = style_default.align;\n\t\telse if (end > 6 && strncasecmp(tmp, \"align=\", 6) == 0) {\n\t\t\tif (strcasecmp(tmp + 6, \"left\") == 0)\n\t\t\t\tsy->align = STYLE_ALIGN_LEFT;\n\t\t\telse if (strcasecmp(tmp + 6, \"centre\") == 0)\n\t\t\t\tsy->align = STYLE_ALIGN_CENTRE;\n\t\t\telse if (strcasecmp(tmp + 6, \"right\") == 0)\n\t\t\t\tsy->align = STYLE_ALIGN_RIGHT;\n\t\t\telse if (strcasecmp(tmp + 6, \"absolute-centre\") == 0)\n\t\t\t\tsy->align = STYLE_ALIGN_ABSOLUTE_CENTRE;\n\t\t\telse\n\t\t\t\tgoto error;\n\t\t} else if (end > 5 && strncasecmp(tmp, \"fill=\", 5) == 0) {\n\t\t\tif ((value = colour_fromstring(tmp + 5)) == -1)\n\t\t\t\tgoto error;\n\t\t\tsy->fill = value;\n\t\t} else if (end > 3 && strncasecmp(tmp + 1, \"g=\", 2) == 0) {\n\t\t\tif ((value = colour_fromstring(tmp + 3)) == -1)\n\t\t\t\tgoto error;\n\t\t\tif (*in == 'f' || *in == 'F') {\n\t\t\t\tif (value != 8)\n\t\t\t\t\tsy->gc.fg = value;\n\t\t\t\telse\n\t\t\t\t\tsy->gc.fg = base->fg;\n\t\t\t} else if (*in == 'b' || *in == 'B') {\n\t\t\t\tif (value != 8)\n\t\t\t\t\tsy->gc.bg = value;\n\t\t\t\telse\n\t\t\t\t\tsy->gc.bg = base->bg;\n\t\t\t} else\n\t\t\t\tgoto error;\n\t\t} else if (end > 3 && strncasecmp(tmp, \"us=\", 3) == 0) {\n\t\t\tif ((value = colour_fromstring(tmp + 3)) == -1)\n\t\t\t\tgoto error;\n\t\t\tif (value != 8)\n\t\t\t\tsy->gc.us = value;\n\t\t\telse\n\t\t\t\tsy->gc.us = base->us;\n\t\t} else if (strcasecmp(tmp, \"none\") == 0)\n\t\t\tsy->gc.attr = 0;\n\t\telse if (end > 2 && strncasecmp(tmp, \"no\", 2) == 0) {\n\t\t\tif ((value = attributes_fromstring(tmp + 2)) == -1)\n\t\t\t\tgoto error;\n\t\t\tsy->gc.attr &= ~value;\n\t\t} else if (end > 6 && strncasecmp(tmp, \"width=\", 6) == 0) {\n                        n = strtonum(tmp + 6, 0, UINT_MAX, &errstr);\n                        if (errstr != NULL)\n                                goto error;\n                        sy->width = (int)n;\n\t\t} else if (end > 4 && strncasecmp(tmp, \"pad=\", 4) == 0) {\n                        n = strtonum(tmp + 4, 0, UINT_MAX, &errstr);\n                        if (errstr != NULL)\n                                goto error;\n                        sy->pad = (int)n;\n\t\t} else {\n\t\t\tif ((value = attributes_fromstring(tmp)) == -1)\n\t\t\t\tgoto error;\n\t\t\tsy->gc.attr |= value;\n\t\t}\n\n\t\tin += end + strspn(in + end, delimiters);\n\t} while (*in != '\\0');\n\n\treturn (0);\n\nerror:\n\tstyle_copy(sy, &saved);\n\treturn (-1);\n}\n\n/* Convert style to a string. */\nconst char *\nstyle_tostring(struct style *sy)\n{\n\tstruct grid_cell\t*gc = &sy->gc;\n\tint\t\t\t off = 0;\n\tconst char\t\t*comma = \"\", *tmp = \"\";\n\tstatic char\t\t s[256];\n\tchar\t\t\t b[21];\n\n\t*s = '\\0';\n\n\tif (sy->list != STYLE_LIST_OFF) {\n\t\tif (sy->list == STYLE_LIST_ON)\n\t\t\ttmp = \"on\";\n\t\telse if (sy->list == STYLE_LIST_FOCUS)\n\t\t\ttmp = \"focus\";\n\t\telse if (sy->list == STYLE_LIST_LEFT_MARKER)\n\t\t\ttmp = \"left-marker\";\n\t\telse if (sy->list == STYLE_LIST_RIGHT_MARKER)\n\t\t\ttmp = \"right-marker\";\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%slist=%s\", comma,\n\t\t    tmp);\n\t\tcomma = \",\";\n\t}\n\tif (sy->range_type != STYLE_RANGE_NONE) {\n\t\tif (sy->range_type == STYLE_RANGE_LEFT)\n\t\t\ttmp = \"left\";\n\t\telse if (sy->range_type == STYLE_RANGE_RIGHT)\n\t\t\ttmp = \"right\";\n\t\telse if (sy->range_type == STYLE_RANGE_PANE) {\n\t\t\tsnprintf(b, sizeof b, \"pane|%%%u\", sy->range_argument);\n\t\t\ttmp = b;\n\t\t} else if (sy->range_type == STYLE_RANGE_WINDOW) {\n\t\t\tsnprintf(b, sizeof b, \"window|%u\", sy->range_argument);\n\t\t\ttmp = b;\n\t\t} else if (sy->range_type == STYLE_RANGE_SESSION) {\n\t\t\tsnprintf(b, sizeof b, \"session|$%u\",\n\t\t\t    sy->range_argument);\n\t\t\ttmp = b;\n\t\t} else if (sy->range_type == STYLE_RANGE_USER) {\n\t\t\tsnprintf(b, sizeof b, \"user|%s\", sy->range_string);\n\t\t\ttmp = b;\n\t\t}\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%srange=%s\", comma,\n\t\t    tmp);\n\t\tcomma = \",\";\n\t}\n\tif (sy->align != STYLE_ALIGN_DEFAULT) {\n\t\tif (sy->align == STYLE_ALIGN_LEFT)\n\t\t\ttmp = \"left\";\n\t\telse if (sy->align == STYLE_ALIGN_CENTRE)\n\t\t\ttmp = \"centre\";\n\t\telse if (sy->align == STYLE_ALIGN_RIGHT)\n\t\t\ttmp = \"right\";\n\t\telse if (sy->align == STYLE_ALIGN_ABSOLUTE_CENTRE)\n\t\t\ttmp = \"absolute-centre\";\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%salign=%s\", comma,\n\t\t    tmp);\n\t\tcomma = \",\";\n\t}\n\tif (sy->default_type != STYLE_DEFAULT_BASE) {\n\t\tif (sy->default_type == STYLE_DEFAULT_PUSH)\n\t\t\ttmp = \"push-default\";\n\t\telse if (sy->default_type == STYLE_DEFAULT_POP)\n\t\t\ttmp = \"pop-default\";\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%s%s\", comma, tmp);\n\t\tcomma = \",\";\n\t}\n\tif (sy->fill != 8) {\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%sfill=%s\", comma,\n\t\t    colour_tostring(sy->fill));\n\t\tcomma = \",\";\n\t}\n\tif (gc->fg != 8) {\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%sfg=%s\", comma,\n\t\t    colour_tostring(gc->fg));\n\t\tcomma = \",\";\n\t}\n\tif (gc->bg != 8) {\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%sbg=%s\", comma,\n\t\t    colour_tostring(gc->bg));\n\t\tcomma = \",\";\n\t}\n\tif (gc->us != 8) {\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%sus=%s\", comma,\n\t\t    colour_tostring(gc->us));\n\t\tcomma = \",\";\n\t}\n\tif (gc->attr != 0) {\n\t\txsnprintf(s + off, sizeof s - off, \"%s%s\", comma,\n\t\t    attributes_tostring(gc->attr));\n\t\tcomma = \",\";\n\t}\n        if (sy->width >= 0) {\n                xsnprintf(s + off, sizeof s - off, \"%swidth=%u\", comma,\n\t\t    sy->width);\n\t\tcomma = \",\";\n\t}\n        if (sy->pad >= 0) {\n                xsnprintf(s + off, sizeof s - off, \"%spad=%u\", comma,\n\t\t    sy->pad);\n\t\tcomma = \",\";\n\t}\n\tif (*s == '\\0')\n\t\treturn (\"default\");\n\treturn (s);\n}\n\n/* Apply a style on top of the given style. */\nvoid\nstyle_add(struct grid_cell *gc, struct options *oo, const char *name,\n    struct format_tree *ft)\n{\n\tstruct style\t\t*sy;\n\tstruct format_tree\t*ft0 = NULL;\n\n\tif (ft == NULL)\n\t\tft = ft0 = format_create(NULL, NULL, 0, FORMAT_NOJOBS);\n\n\tsy = options_string_to_style(oo, name, ft);\n\tif (sy == NULL)\n\t\tsy = &style_default;\n\tif (sy->gc.fg != 8)\n\t\tgc->fg = sy->gc.fg;\n\tif (sy->gc.bg != 8)\n\t\tgc->bg = sy->gc.bg;\n\tif (sy->gc.us != 8)\n\t\tgc->us = sy->gc.us;\n\tgc->attr |= sy->gc.attr;\n\n\tif (ft0 != NULL)\n\t\tformat_free(ft0);\n}\n\n/* Apply a style on top of the default style. */\nvoid\nstyle_apply(struct grid_cell *gc, struct options *oo, const char *name,\n    struct format_tree *ft)\n{\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\tstyle_add(gc, oo, name, ft);\n}\n\n/* Initialize style from cell. */\nvoid\nstyle_set(struct style *sy, const struct grid_cell *gc)\n{\n\tmemcpy(sy, &style_default, sizeof *sy);\n\tmemcpy(&sy->gc, gc, sizeof sy->gc);\n}\n\n/* Copy style. */\nvoid\nstyle_copy(struct style *dst, struct style *src)\n{\n\tmemcpy(dst, src, sizeof *dst);\n}\n\nvoid\nstyle_set_scrollbar_style_from_option(struct style *sb_style, struct options *oo)\n{\n\tstruct style\t*sy;\n\n\tsy = options_string_to_style(oo, \"pane-scrollbars-style\", NULL);\n\tif (sy == NULL) {\n\t\tstyle_set(sb_style, &grid_default_cell);\n\t\tsb_style->width = PANE_SCROLLBARS_DEFAULT_WIDTH;\n\t\tsb_style->pad = PANE_SCROLLBARS_DEFAULT_PADDING;\n\t\tutf8_set(&sb_style->gc.data, PANE_SCROLLBARS_CHARACTER);\n\t} else {\n\t\tstyle_copy(sb_style, sy);\n\t\tif (sb_style->width < 1)\n\t\t\tsb_style->width = PANE_SCROLLBARS_DEFAULT_WIDTH;\n\t\tif (sb_style->pad < 0)\n\t\t\tsb_style->pad = PANE_SCROLLBARS_DEFAULT_PADDING;\n\t\tutf8_set(&sb_style->gc.data, PANE_SCROLLBARS_CHARACTER);\n\t}\n}\n"
        },
        {
          "name": "tmux-protocol.h",
          "type": "blob",
          "size": 2.314453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2021 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef TMUX_PROTOCOL_H\n#define TMUX_PROTOCOL_H\n\n/* Protocol version. */\n#define PROTOCOL_VERSION 8\n\n/* Message types. */\nenum msgtype {\n\tMSG_VERSION = 12,\n\n\tMSG_IDENTIFY_FLAGS = 100,\n\tMSG_IDENTIFY_TERM,\n\tMSG_IDENTIFY_TTYNAME,\n\tMSG_IDENTIFY_OLDCWD, /* unused */\n\tMSG_IDENTIFY_STDIN,\n\tMSG_IDENTIFY_ENVIRON,\n\tMSG_IDENTIFY_DONE,\n\tMSG_IDENTIFY_CLIENTPID,\n\tMSG_IDENTIFY_CWD,\n\tMSG_IDENTIFY_FEATURES,\n\tMSG_IDENTIFY_STDOUT,\n\tMSG_IDENTIFY_LONGFLAGS,\n\tMSG_IDENTIFY_TERMINFO,\n\n\tMSG_COMMAND = 200,\n\tMSG_DETACH,\n\tMSG_DETACHKILL,\n\tMSG_EXIT,\n\tMSG_EXITED,\n\tMSG_EXITING,\n\tMSG_LOCK,\n\tMSG_READY,\n\tMSG_RESIZE,\n\tMSG_SHELL,\n\tMSG_SHUTDOWN,\n\tMSG_OLDSTDERR, /* unused */\n\tMSG_OLDSTDIN, /* unused */\n\tMSG_OLDSTDOUT, /* unused */\n\tMSG_SUSPEND,\n\tMSG_UNLOCK,\n\tMSG_WAKEUP,\n\tMSG_EXEC,\n\tMSG_FLAGS,\n\n\tMSG_READ_OPEN = 300,\n\tMSG_READ,\n\tMSG_READ_DONE,\n\tMSG_WRITE_OPEN,\n\tMSG_WRITE,\n\tMSG_WRITE_READY,\n\tMSG_WRITE_CLOSE,\n\tMSG_READ_CANCEL\n};\n\n/*\n * Message data.\n *\n * Don't forget to bump PROTOCOL_VERSION if any of these change!\n */\nstruct msg_command {\n\tint\targc;\n}; /* followed by packed argv */\n\nstruct msg_read_open {\n\tint\tstream;\n\tint\tfd;\n}; /* followed by path */\n\nstruct msg_read_data {\n\tint\tstream;\n};\n\nstruct msg_read_done {\n\tint\tstream;\n\tint\terror;\n};\n\nstruct msg_read_cancel {\n\tint\tstream;\n};\n\nstruct msg_write_open {\n\tint\tstream;\n\tint\tfd;\n\tint\tflags;\n}; /* followed by path */\n\nstruct msg_write_data {\n\tint\tstream;\n}; /* followed by data */\n\nstruct msg_write_ready {\n\tint\tstream;\n\tint\terror;\n};\n\nstruct msg_write_close {\n\tint\tstream;\n};\n\n#endif /* TMUX_PROTOCOL_H */\n"
        },
        {
          "name": "tmux.1",
          "type": "blob",
          "size": 181.0009765625,
          "content": ".\\\" $OpenBSD$\n.\\\"\n.\\\" Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n.\\\"\n.\\\" Permission to use, copy, modify, and distribute this software for any\n.\\\" purpose with or without fee is hereby granted, provided that the above\n.\\\" copyright notice and this permission notice appear in all copies.\n.\\\"\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n.\\\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n.\\\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n.\\\" WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n.\\\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n.\\\" OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n.\\\"\n.Dd $Mdocdate$\n.Dt TMUX 1\n.Os\n.Sh NAME\n.Nm tmux\n.Nd terminal multiplexer\n.Sh SYNOPSIS\n.Nm tmux\n.Bk -words\n.Op Fl 2CDlNuVv\n.Op Fl c Ar shell-command\n.Op Fl f Ar file\n.Op Fl L Ar socket-name\n.Op Fl S Ar socket-path\n.Op Fl T Ar features\n.Op Ar command Op Ar flags\n.Ek\n.Sh DESCRIPTION\n.Nm\nis a terminal multiplexer:\nit enables a number of terminals to be created, accessed, and\ncontrolled from a single screen.\n.Nm\nmay be detached from a screen\nand continue running in the background,\nthen later reattached.\n.Pp\nWhen\n.Nm\nis started, it creates a new\n.Em session\nwith a single\n.Em window\nand displays it on screen.\nA status line at the bottom of the screen\nshows information on the current session\nand is used to enter interactive commands.\n.Pp\nA session is a single collection of\n.Em pseudo terminals\nunder the management of\n.Nm .\nEach session has one or more\nwindows linked to it.\nA window occupies the entire screen\nand may be split into rectangular panes,\neach of which is a separate pseudo terminal\n(the\n.Xr pty 4\nmanual page documents the technical details of pseudo terminals).\nAny number of\n.Nm\ninstances may connect to the same session,\nand any number of windows may be present in the same session.\nOnce all sessions are killed,\n.Nm\nexits.\n.Pp\nEach session is persistent and will survive accidental disconnection\n(such as\n.Xr ssh 1\nconnection timeout) or intentional detaching (with the\n.Ql C-b d\nkey strokes).\n.Nm\nmay be reattached using:\n.Pp\n.Dl $ tmux attach\n.Pp\nIn\n.Nm ,\na session is displayed on screen by a\n.Em client\nand all sessions are managed by a single\n.Em server .\nThe server and each client are separate processes which communicate through a\nsocket in\n.Pa /tmp .\n.Pp\nThe options are as follows:\n.Bl -tag -width \"XXXXXXXXXXXX\"\n.It Fl 2\nForce\n.Nm\nto assume the terminal supports 256 colours.\nThis is equivalent to\n.Fl T Ar 256 .\n.It Fl C\nStart in control mode (see the\n.Sx CONTROL MODE\nsection).\nGiven twice\n.Xo ( Fl CC ) Xc\ndisables echo.\n.It Fl c Ar shell-command\nExecute\n.Ar shell-command\nusing the default shell.\nIf necessary, the\n.Nm\nserver will be started to retrieve the\n.Ic default-shell\noption.\nThis option is for compatibility with\n.Xr sh 1\nwhen\n.Nm\nis used as a login shell.\n.It Fl D\nDo not start the\n.Nm\nserver as a daemon.\nThis also turns the\n.Ic exit-empty\noption off.\nWith\n.Fl D ,\n.Ar command\nmay not be specified.\n.It Fl f Ar file\nSpecify an alternative configuration file.\nBy default,\n.Nm\nloads the system configuration file from\n.Pa @SYSCONFDIR@/tmux.conf ,\nif present, then looks for a user configuration file at\n.Pa \\[ti]/.tmux.conf\nor\n.Pa $XDG_CONFIG_HOME/tmux/tmux.conf .\n.Pp\nThe configuration file is a set of\n.Nm\ncommands which are executed in sequence when the server is first started.\n.Nm\nloads configuration files once when the server process has started.\nThe\n.Ic source-file\ncommand may be used to load a file later.\n.Pp\n.Nm\nshows any error messages from commands in configuration files in the first\nsession created, and continues to process the rest of the configuration file.\n.It Fl L Ar socket-name\n.Nm\nstores the server socket in a directory under\n.Ev TMUX_TMPDIR\nor\n.Pa /tmp\nif it is unset.\nThe default socket is named\n.Em default .\nThis option allows a different socket name to be specified, allowing several\nindependent\n.Nm\nservers to be run.\nUnlike\n.Fl S\na full path is not necessary: the sockets are all created in a directory\n.Pa tmux-UID\nunder the directory given by\n.Ev TMUX_TMPDIR\nor in\n.Pa /tmp .\nThe\n.Pa tmux-UID\ndirectory is created by\n.Nm\nand must not be world readable, writable or executable.\n.Pp\nIf the socket is accidentally removed, the\n.Dv SIGUSR1\nsignal may be sent to the\n.Nm\nserver process to recreate it (note that this will fail if any parent\ndirectories are missing).\n.It Fl l\nBehave as a login shell.\nThis flag currently has no effect and is for compatibility with other shells\nwhen using tmux as a login shell.\n.It Fl N\nDo not start the server even if the command would normally do so (for example\n.Ic new-session\nor\n.Ic start-server ) .\n.It Fl S Ar socket-path\nSpecify a full alternative path to the server socket.\nIf\n.Fl S\nis specified, the default socket directory is not used and any\n.Fl L\nflag is ignored.\n.It Fl T Ar features\nSet terminal features for the client.\nThis is a comma-separated list of features.\nSee the\n.Ic terminal-features\noption.\n.It Fl u\nWrite UTF-8 output to the terminal even if the first environment\nvariable of\n.Ev LC_ALL ,\n.Ev LC_CTYPE ,\nor\n.Ev LANG\nthat is set does not contain\n.Qq UTF-8\nor\n.Qq UTF8 .\n.It Fl V\nReport the\n.Nm\nversion.\n.It Fl v\nRequest verbose logging.\nLog messages will be saved into\n.Pa tmux-client-PID.log\nand\n.Pa tmux-server-PID.log\nfiles in the current directory, where\n.Em PID\nis the PID of the server or client process.\nIf\n.Fl v\nis specified twice, an additional\n.Pa tmux-out-PID.log\nfile is generated with a copy of everything\n.Nm\nwrites to the terminal.\n.Pp\nThe\n.Dv SIGUSR2\nsignal may be sent to the\n.Nm\nserver process to toggle logging between on (as if\n.Fl v\nwas given) and off.\n.It Ar command Op Ar flags\nThis specifies one of a set of commands used to control\n.Nm ,\nas described in the following sections.\nIf no commands are specified, the\n.Ic new-session\ncommand is assumed.\n.El\n.Sh DEFAULT KEY BINDINGS\n.Nm\nmay be controlled from an attached client by using a key combination of a\nprefix key,\n.Ql C-b\n(Ctrl-b) by default, followed by a command key.\n.Pp\nThe default command key bindings are:\n.Pp\n.Bl -tag -width \"XXXXXXXXXX\" -offset indent -compact\n.It C-b\nSend the prefix key (C-b) through to the application.\n.It C-o\nRotate the panes in the current window forwards.\n.It C-z\nSuspend the\n.Nm\nclient.\n.It !\nBreak the current pane out of the window.\n.It \\&\"\n.\\\" \"\nSplit the current pane into two, top and bottom.\n.It #\nList all paste buffers.\n.It $\nRename the current session.\n.It %\nSplit the current pane into two, left and right.\n.It &\nKill the current window.\n.It \\[aq]\nPrompt for a window index to select.\n.It \\&(\nSwitch the attached client to the previous session.\n.It \\&)\nSwitch the attached client to the next session.\n.It ,\nRename the current window.\n.It -\nDelete the most recently copied buffer of text.\n.It .\nPrompt for an index to move the current window.\n.It 0 to 9\nSelect windows 0 to 9.\n.It :\nEnter the\n.Nm\ncommand prompt.\n.It ;\nMove to the previously active pane.\n.It =\nChoose which buffer to paste interactively from a list.\n.It \\&?\nList all key bindings.\n.It D\nChoose a client to detach.\n.It L\nSwitch the attached client back to the last session.\n.It \\&[\nEnter copy mode to copy text or view the history.\n.It \\&]\nPaste the most recently copied buffer of text.\n.It c\nCreate a new window.\n.It d\nDetach the current client.\n.It f\nPrompt to search for text in open windows.\n.It i\nDisplay some information about the current window.\n.It l\nMove to the previously selected window.\n.It m\nMark the current pane (see\n.Ic select-pane\n.Fl m ) .\n.It M\nClear the marked pane.\n.It n\nChange to the next window.\n.It o\nSelect the next pane in the current window.\n.It p\nChange to the previous window.\n.It q\nBriefly display pane indexes.\n.It r\nForce redraw of the attached client.\n.It s\nSelect a new session for the attached client interactively.\n.It t\nShow the time.\n.It w\nChoose the current window interactively.\n.It x\nKill the current pane.\n.It z\nToggle zoom state of the current pane.\n.It {\nSwap the current pane with the previous pane.\n.It }\nSwap the current pane with the next pane.\n.It \\[ti]\nShow previous messages from\n.Nm ,\nif any.\n.It Page Up\nEnter copy mode and scroll one page up.\n.It Up, Down\n.It Left, Right\nChange to the pane above, below, to the left, or to the right of the current\npane.\n.It M-1 to M-7\nArrange panes in one of the seven preset layouts:\neven-horizontal, even-vertical,\nmain-horizontal, main-horizontal-mirrored,\nmain-vertical, main-vertical-mirrored,\nor tiled.\n.It Space\nArrange the current window in the next preset layout.\n.It M-n\nMove to the next window with a bell or activity marker.\n.It M-o\nRotate the panes in the current window backwards.\n.It M-p\nMove to the previous window with a bell or activity marker.\n.It C-Up, C-Down\n.It C-Left, C-Right\nResize the current pane in steps of one cell.\n.It M-Up, M-Down\n.It M-Left, M-Right\nResize the current pane in steps of five cells.\n.El\n.Pp\nKey bindings may be changed with the\n.Ic bind-key\nand\n.Ic unbind-key\ncommands.\n.Sh COMMAND PARSING AND EXECUTION\n.Nm\nsupports a large number of commands which can be used to control its\nbehaviour.\nEach command is named and can accept zero or more flags and arguments.\nThey may be bound to a key with the\n.Ic bind-key\ncommand or run from the shell prompt, a shell script, a configuration file or\nthe command prompt.\nFor example, the same\n.Ic set-option\ncommand run from the shell prompt, from\n.Pa \\[ti]/.tmux.conf\nand bound to a key may look like:\n.Bd -literal -offset indent\n$ tmux set-option -g status-style bg=cyan\n\nset-option -g status-style bg=cyan\n\nbind-key C set-option -g status-style bg=cyan\n.Ed\n.Pp\nHere, the command name is\n.Ql set-option ,\n.Ql Fl g\nis a flag and\n.Ql status-style\nand\n.Ql bg=cyan\nare arguments.\n.Pp\n.Nm\ndistinguishes between command parsing and execution.\nIn order to execute a command,\n.Nm\nneeds it to be split up into its name and arguments.\nThis is command parsing.\nIf a command is run from the shell, the shell parses it; from inside\n.Nm\nor from a configuration file,\n.Nm\ndoes.\nExamples of when\n.Nm\nparses commands are:\n.Bl -dash -offset indent\n.It\nin a configuration file;\n.It\ntyped at the command prompt (see\n.Ic command-prompt ) ;\n.It\ngiven to\n.Ic bind-key ;\n.It\npassed as arguments to\n.Ic if-shell\nor\n.Ic confirm-before .\n.El\n.Pp\nTo execute commands, each client has a\n.Ql command queue .\nA global command queue not attached to any client is used on startup\nfor configuration files like\n.Pa \\[ti]/.tmux.conf .\nParsed commands added to the queue are executed in order.\nSome commands, like\n.Ic if-shell\nand\n.Ic confirm-before ,\nparse their argument to create a new command which is inserted immediately\nafter themselves.\nThis means that arguments can be parsed twice or more - once when the parent\ncommand (such as\n.Ic if-shell )\nis parsed and again when it parses and executes its command.\nCommands like\n.Ic if-shell ,\n.Ic run-shell\nand\n.Ic display-panes\nstop execution of subsequent commands on the queue until something happens -\n.Ic if-shell\nand\n.Ic run-shell\nuntil a shell command finishes and\n.Ic display-panes\nuntil a key is pressed.\nFor example, the following commands:\n.Bd -literal -offset indent\nnew-session; new-window\nif-shell \"true\" \"split-window\"\nkill-session\n.Ed\n.Pp\nWill execute\n.Ic new-session ,\n.Ic new-window ,\n.Ic if-shell ,\nthe shell command\n.Xr true 1 ,\n.Ic split-window\nand\n.Ic kill-session\nin that order.\n.Pp\nThe\n.Sx COMMANDS\nsection lists the\n.Nm\ncommands and their arguments.\n.Sh PARSING SYNTAX\nThis section describes the syntax of commands parsed by\n.Nm ,\nfor example in a configuration file or at the command prompt.\nNote that when commands are entered into the shell, they are parsed by the shell\n- see for example\n.Xr ksh 1\nor\n.Xr csh 1 .\n.Pp\nEach command is terminated by a newline or a semicolon (;).\nCommands separated by semicolons together form a\n.Ql command sequence\n- if a command in the sequence encounters an error, no subsequent commands are\nexecuted.\n.Pp\nIt is recommended that a semicolon used as a command separator should be\nwritten as an individual token, for example from\n.Xr sh 1 :\n.Bd -literal -offset indent\n$ tmux neww \\\\; splitw\n.Ed\n.Pp\nOr:\n.Bd -literal -offset indent\n$ tmux neww \\[aq];\\[aq] splitw\n.Ed\n.Pp\nOr from the tmux command prompt:\n.Bd -literal -offset indent\nneww ; splitw\n.Ed\n.Pp\nHowever, a trailing semicolon is also interpreted as a command separator,\nfor example in these\n.Xr sh 1\ncommands:\n.Bd -literal -offset indent\n$ tmux neww\\e; splitw\n.Ed\n.Pp\nOr:\n.Bd -literal -offset indent\n$ tmux \\[aq]neww;\\[aq] splitw\n.Ed\n.Pp\nAs in these examples, when running tmux from the shell extra care must be taken\nto properly quote semicolons:\n.Bl -enum -offset Ds\n.It\nSemicolons that should be interpreted as a command separator\nshould be escaped according to the shell conventions.\nFor\n.Xr sh 1\nthis typically means quoted (such as\n.Ql neww \\[aq];\\[aq] splitw )\nor escaped (such as\n.Ql neww \\e\\e\\e\\e; splitw ) .\n.It\nIndividual semicolons or trailing semicolons that should be interpreted as\narguments should be escaped twice: once according to the shell conventions and\na second time for\n.Nm ;\nfor example:\n.Bd -literal -offset indent\n$ tmux neww \\[aq]foo\\e\\e;\\[aq] bar\n$ tmux neww foo\\e\\e\\e\\e; bar\n.Ed\n.It\nSemicolons that are not individual tokens or trailing another token should only\nbe escaped once according to shell conventions; for example:\n.Bd -literal -offset indent\n$ tmux neww \\[aq]foo-;-bar\\[aq]\n$ tmux neww foo-\\e\\e;-bar\n.Ed\n.El\n.Pp\nComments are marked by the unquoted # character - any remaining text after a\ncomment is ignored until the end of the line.\n.Pp\nIf the last character of a line is \\e, the line is joined with the following\nline (the \\e and the newline are completely removed).\nThis is called line continuation and applies both inside and outside quoted\nstrings and in comments, but not inside braces.\n.Pp\nCommand arguments may be specified as strings surrounded by single (\\[aq])\nquotes, double quotes (\\[dq]) or braces ({}).\n.\\\" \"\nThis is required when the argument contains any special character.\nSingle and double quoted strings cannot span multiple lines except with line\ncontinuation.\nBraces can span multiple lines.\n.Pp\nOutside of quotes and inside double quotes, these replacements are performed:\n.Bl -dash -offset indent\n.It\nEnvironment variables preceded by $ are replaced with their value from the\nglobal environment (see the\n.Sx GLOBAL AND SESSION ENVIRONMENT\nsection).\n.It\nA leading \\[ti] or \\[ti]user is expanded to the home directory of the current or\nspecified user.\n.It\n\\euXXXX or \\euXXXXXXXX is replaced by the Unicode codepoint corresponding to\nthe given four or eight digit hexadecimal number.\n.It\nWhen preceded (escaped) by a \\e, the following characters are replaced: \\ee by\nthe escape character; \\er by a carriage return; \\en by a newline; and \\et by a\ntab.\n.It\n\\eooo is replaced by a character of the octal value ooo.\nThree octal digits are required, for example \\e001.\nThe largest valid character is \\e377.\n.It\nAny other characters preceded by \\e are replaced by themselves (that is, the \\e\nis removed) and are not treated as having any special meaning - so for example\n\\e; will not mark a command sequence and \\e$ will not expand an environment\nvariable.\n.El\n.Pp\nBraces are parsed as a configuration file (so conditions such as\n.Ql %if\nare processed) and then converted into a string.\nThey are designed to avoid the need for additional escaping when passing a\ngroup of\n.Nm\ncommands as an argument (for example to\n.Ic if-shell ) .\nThese two examples produce an identical command - note that no escaping is\nneeded when using {}:\n.Bd -literal -offset indent\nif-shell true {\n    display -p \\[aq]brace-dollar-foo: }$foo\\[aq]\n}\n\nif-shell true \"display -p \\[aq]brace-dollar-foo: }\\e$foo\\[aq]\"\n.Ed\n.Pp\nBraces may be enclosed inside braces, for example:\n.Bd -literal -offset indent\nbind x if-shell \"true\" {\n    if-shell \"true\" {\n        display \"true!\"\n    }\n}\n.Ed\n.Pp\nEnvironment variables may be set by using the syntax\n.Ql name=value ,\nfor example\n.Ql HOME=/home/user .\nVariables set during parsing are added to the global environment.\nA hidden variable may be set with\n.Ql %hidden ,\nfor example:\n.Bd -literal -offset indent\n%hidden MYVAR=42\n.Ed\n.Pp\nHidden variables are not passed to the environment of processes created\nby tmux.\nSee the\n.Sx GLOBAL AND SESSION ENVIRONMENT\nsection.\n.Pp\nCommands may be parsed conditionally by surrounding them with\n.Ql %if ,\n.Ql %elif ,\n.Ql %else\nand\n.Ql %endif .\nThe argument to\n.Ql %if\nand\n.Ql %elif\nis expanded as a format (see\n.Sx FORMATS )\nand if it evaluates to false (zero or empty), subsequent text is ignored until\nthe closing\n.Ql %elif ,\n.Ql %else\nor\n.Ql %endif .\nFor example:\n.Bd -literal -offset indent\n%if \"#{==:#{host},myhost}\"\nset -g status-style bg=red\n%elif \"#{==:#{host},myotherhost}\"\nset -g status-style bg=green\n%else\nset -g status-style bg=blue\n%endif\n.Ed\n.Pp\nWill change the status line to red if running on\n.Ql myhost ,\ngreen if running on\n.Ql myotherhost ,\nor blue if running on another host.\nConditionals may be given on one line, for example:\n.Bd -literal -offset indent\n%if #{==:#{host},myhost} set -g status-style bg=red %endif\n.Ed\n.Sh COMMANDS\nThis section describes the commands supported by\n.Nm .\nMost commands accept the optional\n.Fl t\n(and sometimes\n.Fl s )\nargument with one of\n.Ar target-client ,\n.Ar target-session ,\n.Ar target-window ,\nor\n.Ar target-pane .\nThese specify the client, session, window or pane which a command should affect.\n.Pp\n.Ar target-client\nshould be the name of the client,\ntypically the\n.Xr pty 4\nfile to which the client is connected, for example either of\n.Pa /dev/ttyp1\nor\n.Pa ttyp1\nfor the client attached to\n.Pa /dev/ttyp1 .\nIf no client is specified,\n.Nm\nattempts to work out the client currently in use; if that fails, an error is\nreported.\nClients may be listed with the\n.Ic list-clients\ncommand.\n.Pp\n.Ar target-session\nis tried as, in order:\n.Bl -enum -offset Ds\n.It\nA session ID prefixed with a $.\n.It\nAn exact name of a session (as listed by the\n.Ic list-sessions\ncommand).\n.It\nThe start of a session name, for example\n.Ql mysess\nwould match a session named\n.Ql mysession .\n.It\nA\n.Xr glob 7\npattern which is matched against the session name.\n.El\n.Pp\nIf the session name is prefixed with an\n.Ql = ,\nonly an exact match is accepted (so\n.Ql =mysess\nwill only match exactly\n.Ql mysess ,\nnot\n.Ql mysession ) .\n.Pp\nIf a single session is found, it is used as the target session; multiple matches\nproduce an error.\nIf a session is omitted, the current session is used if available; if no\ncurrent session is available, the most recently used is chosen.\n.Pp\n.Ar target-window\n(or\n.Ar src-window\nor\n.Ar dst-window )\nspecifies a window in the form\n.Em session Ns \\&: Ns Em window .\n.Em session\nfollows the same rules as for\n.Ar target-session ,\nand\n.Em window\nis looked for in order as:\n.Bl -enum -offset Ds\n.It\nA special token, listed below.\n.It\nA window index, for example\n.Ql mysession:1\nis window 1 in session\n.Ql mysession .\n.It\nA window ID, such as @1.\n.It\nAn exact window name, such as\n.Ql mysession:mywindow .\n.It\nThe start of a window name, such as\n.Ql mysession:mywin .\n.It\nAs a\n.Xr glob 7\npattern matched against the window name.\n.El\n.Pp\nLike sessions, a\n.Ql =\nprefix will do an exact match only.\nAn empty window name specifies the next unused index if appropriate (for\nexample the\n.Ic new-window\nand\n.Ic link-window\ncommands)\notherwise the current window in\n.Em session\nis chosen.\n.Pp\nThe following special tokens are available to indicate particular windows.\nEach has a single-character alternative form.\n.Bl -column \"XXXXXXXXXX\" \"X\"\n.It Sy \"Token\" Ta Sy \"\" Ta Sy \"Meaning\"\n.It Li \"{start}\" Ta \"^\" Ta \"The lowest-numbered window\"\n.It Li \"{end}\" Ta \"$\" Ta \"The highest-numbered window\"\n.It Li \"{last}\" Ta \"!\" Ta \"The last (previously current) window\"\n.It Li \"{next}\" Ta \"+\" Ta \"The next window by number\"\n.It Li \"{previous}\" Ta \"-\" Ta \"The previous window by number\"\n.El\n.Pp\n.Ar target-pane\n(or\n.Ar src-pane\nor\n.Ar dst-pane )\nmay be a pane ID or takes a similar form to\n.Ar target-window\nbut with the optional addition of a period followed by a pane index or pane ID,\nfor example:\n.Ql mysession:mywindow.1 .\nIf the pane index is omitted, the currently active pane in the specified\nwindow is used.\nThe following special tokens are available for the pane index:\n.Bl -column \"XXXXXXXXXXXXXX\" \"X\"\n.It Sy \"Token\" Ta Sy \"\" Ta Sy \"Meaning\"\n.It Li \"{last}\" Ta \"!\" Ta \"The last (previously active) pane\"\n.It Li \"{next}\" Ta \"+\" Ta \"The next pane by number\"\n.It Li \"{previous}\" Ta \"-\" Ta \"The previous pane by number\"\n.It Li \"{top}\" Ta \"\" Ta \"The top pane\"\n.It Li \"{bottom}\" Ta \"\" Ta \"The bottom pane\"\n.It Li \"{left}\" Ta \"\" Ta \"The leftmost pane\"\n.It Li \"{right}\" Ta \"\" Ta \"The rightmost pane\"\n.It Li \"{top-left}\" Ta \"\" Ta \"The top-left pane\"\n.It Li \"{top-right}\" Ta \"\" Ta \"The top-right pane\"\n.It Li \"{bottom-left}\" Ta \"\" Ta \"The bottom-left pane\"\n.It Li \"{bottom-right}\" Ta \"\" Ta \"The bottom-right pane\"\n.It Li \"{up-of}\" Ta \"\" Ta \"The pane above the active pane\"\n.It Li \"{down-of}\" Ta \"\" Ta \"The pane below the active pane\"\n.It Li \"{left-of}\" Ta \"\" Ta \"The pane to the left of the active pane\"\n.It Li \"{right-of}\" Ta \"\" Ta \"The pane to the right of the active pane\"\n.El\n.Pp\nThe tokens\n.Ql +\nand\n.Ql -\nmay be followed by an offset, for example:\n.Bd -literal -offset indent\nselect-window -t:+2\n.Ed\n.Pp\nIn addition,\n.Em target-session ,\n.Em target-window\nor\n.Em target-pane\nmay consist entirely of the token\n.Ql {mouse}\n(alternative form\n.Ql = )\nto specify the session, window or pane where the most recent mouse event\noccurred (see the\n.Sx MOUSE SUPPORT\nsection)\nor\n.Ql {marked}\n(alternative form\n.Ql \\[ti] )\nto specify the marked pane (see\n.Ic select-pane\n.Fl m ) .\n.Pp\nSessions, window and panes are each numbered with a unique ID; session IDs are\nprefixed with a\n.Ql $ ,\nwindows with a\n.Ql @ ,\nand panes with a\n.Ql % .\nThese are unique and are unchanged for the life of the session, window or pane\nin the\n.Nm\nserver.\nThe pane ID is passed to the child process of the pane in the\n.Ev TMUX_PANE\nenvironment variable.\nIDs may be displayed using the\n.Ql session_id ,\n.Ql window_id ,\nor\n.Ql pane_id\nformats (see the\n.Sx FORMATS\nsection) and the\n.Ic display-message ,\n.Ic list-sessions ,\n.Ic list-windows\nor\n.Ic list-panes\ncommands.\n.Pp\n.Ar shell-command\narguments are\n.Xr sh 1\ncommands.\nThis may be a single argument passed to the shell, for example:\n.Bd -literal -offset indent\nnew-window \\[aq]vi \\[ti]/.tmux.conf\\[aq]\n.Ed\n.Pp\nWill run:\n.Bd -literal -offset indent\n/bin/sh -c \\[aq]vi \\[ti]/.tmux.conf\\[aq]\n.Ed\n.Pp\nAdditionally, the\n.Ic new-window ,\n.Ic new-session ,\n.Ic split-window ,\n.Ic respawn-window\nand\n.Ic respawn-pane\ncommands allow\n.Ar shell-command\nto be given as multiple arguments and executed directly (without\n.Ql sh -c ) .\nThis can avoid issues with shell quoting.\nFor example:\n.Bd -literal -offset indent\n$ tmux new-window vi \\[ti]/.tmux.conf\n.Ed\n.Pp\nWill run\n.Xr vi 1\ndirectly without invoking the shell.\n.Pp\n.Ar command\n.Op Ar argument ...\nrefers to a\n.Nm\ncommand, either passed with the command and arguments separately, for example:\n.Bd -literal -offset indent\nbind-key F1 set-option status off\n.Ed\n.Pp\nOr passed as a single string argument in\n.Pa .tmux.conf ,\nfor example:\n.Bd -literal -offset indent\nbind-key F1 { set-option status off }\n.Ed\n.Pp\nExample\n.Nm\ncommands include:\n.Bd -literal -offset indent\nrefresh-client -t/dev/ttyp2\n\nrename-session -tfirst newname\n\nset-option -wt:0 monitor-activity on\n\nnew-window ; split-window -d\n\nbind-key R source-file \\[ti]/.tmux.conf \\e; \\e\n\tdisplay-message \"source-file done\"\n.Ed\n.Pp\nOr from\n.Xr sh 1 :\n.Bd -literal -offset indent\n$ tmux kill-window -t :1\n\n$ tmux new-window \\e; split-window -d\n\n$ tmux new-session -d \\[aq]vi \\[ti]/.tmux.conf\\[aq] \\e; split-window -d \\e; attach\n.Ed\n.Sh CLIENTS AND SESSIONS\nThe\n.Nm\nserver manages clients, sessions, windows and panes.\nClients are attached to sessions to interact with them, either\nwhen they are created with the\n.Ic new-session\ncommand, or later with the\n.Ic attach-session\ncommand.\nEach session has one or more windows\n.Em linked\ninto it.\nWindows may be linked to multiple sessions and are made up of one or\nmore panes,\neach of which contains a pseudo terminal.\nCommands for creating, linking and otherwise manipulating windows\nare covered\nin the\n.Sx WINDOWS AND PANES\nsection.\n.Pp\nThe following commands are available to manage clients and sessions:\n.Bl -tag -width Ds\n.Tg attach\n.It Xo Ic attach-session\n.Op Fl dErx\n.Op Fl c Ar working-directory\n.Op Fl f Ar flags\n.Op Fl t Ar target-session\n.Xc\n.D1 Pq alias: Ic attach\nIf run from outside\n.Nm ,\nattach to\n.Ar target-session\nin the current terminal.\n.Ar target-session\nmust already exist - to create a new session, see the\n.Ic new-session\ncommand (with\n.Fl A\nto create or attach).\nIf used from inside, switch the currently attached session to\n.Ar target-session .\nIf\n.Fl d\nis specified, any other clients attached to the session are detached.\nIf\n.Fl x\nis given, send\n.Dv SIGHUP\nto the parent process of the client as well as\ndetaching the client, typically causing it to exit.\n.Fl f\nsets a comma-separated list of client flags.\nThe flags are:\n.Bl -tag -width Ds\n.It active-pane\nthe client has an independent active pane\n.It ignore-size\nthe client does not affect the size of other clients\n.It no-detach-on-destroy\ndo not detach the client when the session it is attached to is destroyed if\nthere are any other sessions\n.It no-output\nthe client does not receive pane output in control mode\n.It pause-after=seconds\noutput is paused once the pane is\n.Ar seconds\nbehind in control mode\n.It read-only\nthe client is read-only\n.It wait-exit\nwait for an empty line input before exiting in control mode\n.El\n.Pp\nA leading\n.Ql \\&!\nturns a flag off if the client is already attached.\n.Fl r\nis an alias for\n.Fl f\n.Ar read-only,ignore-size .\nWhen a client is read-only, only keys bound to the\n.Ic detach-client\nor\n.Ic switch-client\ncommands have any effect.\nA client with the\n.Ar active-pane\nflag allows the active pane to be selected independently of the window's active\npane used by clients without the flag.\nThis only affects the cursor position and commands issued from the client;\nother features such as hooks and styles continue to use the window's active\npane.\n.Pp\nIf no server is started,\n.Ic attach-session\nwill attempt to start it; this will fail unless sessions are created in the\nconfiguration file.\n.Pp\nThe\n.Ar target-session\nrules for\n.Ic attach-session\nare slightly adjusted: if\n.Nm\nneeds to select the most recently used session, it will prefer the most\nrecently used\n.Em unattached\nsession.\n.Pp\n.Fl c\nwill set the session working directory (used for new windows) to\n.Ar working-directory .\n.Pp\nIf\n.Fl E\nis used, the\n.Ic update-environment\noption will not be applied.\n.Tg detach\n.It Xo Ic detach-client\n.Op Fl aP\n.Op Fl E Ar shell-command\n.Op Fl s Ar target-session\n.Op Fl t Ar target-client\n.Xc\n.D1 Pq alias: Ic detach\nDetach the current client if bound to a key, the client specified with\n.Fl t ,\nor all clients currently attached to the session specified by\n.Fl s .\nThe\n.Fl a\noption kills all but the client given with\n.Fl t .\nIf\n.Fl P\nis given, send\n.Dv SIGHUP\nto the parent process of the client, typically causing it\nto exit.\nWith\n.Fl E ,\nrun\n.Ar shell-command\nto replace the client.\n.Tg has\n.It Ic has-session Op Fl t Ar target-session\n.D1 Pq alias: Ic has\nReport an error and exit with 1 if the specified session does not exist.\nIf it does exist, exit with 0.\n.It Ic kill-server\nKill the\n.Nm\nserver and clients and destroy all sessions.\n.It Xo Ic kill-session\n.Op Fl aC\n.Op Fl t Ar target-session\n.Xc\nDestroy the given session, closing any windows linked to it and no other\nsessions, and detaching all clients attached to it.\nIf\n.Fl a\nis given, all sessions but the specified one is killed.\nThe\n.Fl C\nflag clears alerts (bell, activity, or silence) in all windows linked to the\nsession.\n.Tg lsc\n.It Xo Ic list-clients\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl t Ar target-session\n.Xc\n.D1 Pq alias: Ic lsc\nList all clients attached to the server.\n.Fl F\nspecifies the format of each line and\n.Fl f\na filter.\nOnly clients for which the filter is true are shown.\nSee the\n.Sx FORMATS\nsection.\nIf\n.Ar target-session\nis specified, list only clients connected to that session.\n.Tg lscm\n.It Xo Ic list-commands\n.Op Fl F Ar format\n.Op Ar command\n.Xc\n.D1 Pq alias: Ic lscm\nList the syntax of\n.Ar command\nor - if omitted - of all commands supported by\n.Nm .\n.Tg ls\n.It Xo Ic list-sessions\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Xc\n.D1 Pq alias: Ic ls\nList all sessions managed by the server.\n.Fl F\nspecifies the format of each line and\n.Fl f\na filter.\nOnly sessions for which the filter is true are shown.\nSee the\n.Sx FORMATS\nsection.\n.Tg lockc\n.It Ic lock-client Op Fl t Ar target-client\n.D1 Pq alias: Ic lockc\nLock\n.Ar target-client ,\nsee the\n.Ic lock-server\ncommand.\n.Tg locks\n.It Ic lock-session Op Fl t Ar target-session\n.D1 Pq alias: Ic locks\nLock all clients attached to\n.Ar target-session .\n.Tg new\n.It Xo Ic new-session\n.Op Fl AdDEPX\n.Op Fl c Ar start-directory\n.Op Fl e Ar environment\n.Op Fl f Ar flags\n.Op Fl F Ar format\n.Op Fl n Ar window-name\n.Op Fl s Ar session-name\n.Op Fl t Ar group-name\n.Op Fl x Ar width\n.Op Fl y Ar height\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic new\nCreate a new session with name\n.Ar session-name .\n.Pp\nThe new session is attached to the current terminal unless\n.Fl d\nis given.\n.Ar window-name\nand\n.Ar shell-command\nare the name of and shell command to execute in the initial window.\nWith\n.Fl d ,\nthe initial size comes from the global\n.Ic default-size\noption;\n.Fl x\nand\n.Fl y\ncan be used to specify a different size.\n.Ql -\nuses the size of the current client if any.\nIf\n.Fl x\nor\n.Fl y\nis given, the\n.Ic default-size\noption is set for the session.\n.Fl f\nsets a comma-separated list of client flags (see\n.Ic attach-session ) .\n.Pp\nIf run from a terminal, any\n.Xr termios 4\nspecial characters are saved and used for new windows in the new session.\n.Pp\nThe\n.Fl A\nflag makes\n.Ic new-session\nbehave like\n.Ic attach-session\nif\n.Ar session-name\nalready exists;\nif\n.Fl A\nis given,\n.Fl D\nbehaves like\n.Fl d\nto\n.Ic attach-session ,\nand\n.Fl X\nbehaves like\n.Fl x\nto\n.Ic attach-session .\n.Pp\nIf\n.Fl t\nis given, it specifies a\n.Ic session group .\nSessions in the same group share the same set of windows - new windows are\nlinked to all sessions in the group and any windows closed removed from all\nsessions.\nThe current and previous window and any session options remain independent and\nany session in a group may be killed without affecting the others.\nThe\n.Ar group-name\nargument may be:\n.Bl -enum -width Ds\n.It\nthe name of an existing group, in which case the new session is added to that\ngroup;\n.It\nthe name of an existing session - the new session is added to the same group\nas that session, creating a new group if necessary;\n.It\nthe name for a new group containing only the new session.\n.El\n.Pp\n.Fl n\nand\n.Ar shell-command\nare invalid if\n.Fl t\nis used.\n.Pp\nThe\n.Fl P\noption prints information about the new session after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:\\&\nbut a different format may be specified with\n.Fl F .\n.Pp\nIf\n.Fl E\nis used, the\n.Ic update-environment\noption will not be applied.\n.Fl e\ntakes the form\n.Ql VARIABLE=value\nand sets an environment variable for the newly created session; it may be\nspecified multiple times.\n.Tg refresh\n.It Xo Ic refresh-client\n.Op Fl cDLRSU\n.Op Fl A Ar pane:state\n.Op Fl B Ar name:what:format\n.Op Fl C Ar size\n.Op Fl f Ar flags\n.Op Fl l Op Ar target-pane\n.Op Fl r Ar pane:report\n.Op Fl t Ar target-client\n.Op Ar adjustment\n.Xc\n.D1 Pq alias: Ic refresh\nRefresh the current client if bound to a key, or a single client if one is given\nwith\n.Fl t .\nIf\n.Fl S\nis specified, only update the client's status line.\n.Pp\nThe\n.Fl U ,\n.Fl D ,\n.Fl L\n.Fl R ,\nand\n.Fl c\nflags allow the visible portion of a window which is larger than the client\nto be changed.\n.Fl U\nmoves the visible part up by\n.Ar adjustment\nrows and\n.Fl D\ndown,\n.Fl L\nleft by\n.Ar adjustment\ncolumns and\n.Fl R\nright.\n.Fl c\nreturns to tracking the cursor automatically.\nIf\n.Ar adjustment\nis omitted, 1 is used.\nNote that the visible position is a property of the client not of the\nwindow, changing the current window in the attached session will reset\nit.\n.Pp\n.Fl C\nsets the width and height of a control mode client or of a window for a\ncontrol mode client,\n.Ar size\nmust be one of\n.Ql widthxheight\nor\n.Ql window ID:widthxheight ,\nfor example\n.Ql 80x24\nor\n.Ql @0:80x24 .\n.Fl A\nallows a control mode client to trigger actions on a pane.\nThe argument is a pane ID (with leading\n.Ql % ) ,\na colon, then one of\n.Ql on ,\n.Ql off ,\n.Ql continue\nor\n.Ql pause .\nIf\n.Ql off ,\n.Nm\nwill not send output from the pane to the client and if all clients have turned\nthe pane off, will stop reading from the pane.\nIf\n.Ql continue ,\n.Nm\nwill return to sending output to the pane if it was paused (manually or with the\n.Ar pause-after\nflag).\nIf\n.Ql pause ,\n.Nm\nwill pause the pane.\n.Fl A\nmay be given multiple times for different panes.\n.Pp\n.Fl B\nsets a subscription to a format for a control mode client.\nThe argument is split into three items by colons:\n.Ar name\nis a name for the subscription;\n.Ar what\nis a type of item to subscribe to;\n.Ar format\nis the format.\nAfter a subscription is added, changes to the format are reported with the\n.Ic %subscription-changed\nnotification, at most once a second.\nIf only the name is given, the subscription is removed.\n.Ar what\nmay be empty to check the format only for the attached session, or one of:\na pane ID such as\n.Ql %0 ;\n.Ql %*\nfor all panes in the attached session;\na window ID such as\n.Ql @0 ;\nor\n.Ql @*\nfor all windows in the attached session.\n.Pp\n.Fl f\nsets a comma-separated list of client flags, see\n.Ic attach-session .\n.Fl r\nallows a control mode client to provide information about a pane via a report\n(such as the response to OSC 10).\nThe argument is a pane ID (with a leading\n.Ql % ) ,\na colon, then a report escape sequence.\n.Pp\n.Fl l\nrequests the clipboard from the client using the\n.Xr xterm 1\nescape sequence.\nIf\n.Ar target-pane\nis given, the clipboard is sent (in encoded form), otherwise it is stored in a\nnew paste buffer.\n.Pp\n.Fl L ,\n.Fl R ,\n.Fl U\nand\n.Fl D\nmove the visible portion of the window left, right, up or down\nby\n.Ar adjustment ,\nif the window is larger than the client.\n.Fl c\nresets so that the position follows the cursor.\nSee the\n.Ic window-size\noption.\n.Tg rename\n.It Xo Ic rename-session\n.Op Fl t Ar target-session\n.Ar new-name\n.Xc\n.D1 Pq alias: Ic rename\nRename the session to\n.Ar new-name .\n.It Xo Ic server-access\n.Op Fl adlrw\n.Op Ar user\n.Xc\nChange the access or read/write permission of\n.Ar user .\nThe user running the\n.Nm\nserver (its owner) and the root user cannot be changed and are always\npermitted access.\n.Pp\n.Fl a\nand\n.Fl d\nare used to give or revoke access for the specified user.\nIf the user is already attached, the\n.Fl d\nflag causes their clients to be detached.\n.Pp\n.Fl r\nand\n.Fl w\nchange the permissions for\n.Ar user :\n.Fl r\nmakes their clients read-only and\n.Fl w\nwritable.\n.Fl l\nlists current access permissions.\n.Pp\nBy default, the access list is empty and\n.Nm\ncreates sockets with file system permissions preventing access by any user\nother than the owner (and root).\nThese permissions must be changed manually.\nGreat care should be taken not to allow access to untrusted users even\nread-only.\n.Tg showmsgs\n.It Xo Ic show-messages\n.Op Fl JT\n.Op Fl t Ar target-client\n.Xc\n.D1 Pq alias: Ic showmsgs\nShow server messages or information.\nMessages are stored, up to a maximum of the limit set by the\n.Ar message-limit\nserver option.\n.Fl J\nand\n.Fl T\nshow debugging information about jobs and terminals.\n.Tg source\n.It Xo Ic source-file\n.Op Fl Fnqv\n.Op Fl t Ar target-pane\n.Ar path ...\n.Xc\n.D1 Pq alias: Ic source\nExecute commands from one or more files specified by\n.Ar path\n(which may be\n.Xr glob 7\npatterns).\nIf\n.Fl F\nis present, then\n.Ar path\nis expanded as a format.\nIf\n.Fl q\nis given, no error will be returned if\n.Ar path\ndoes not exist.\nWith\n.Fl n ,\nthe file is parsed but no commands are executed.\n.Fl v\nshows the parsed commands and line numbers if possible.\n.Tg start\n.It Ic start-server\n.D1 Pq alias: Ic start\nStart the\n.Nm\nserver, if not already running, without creating any sessions.\n.Pp\nNote that as by default the\n.Nm\nserver will exit with no sessions, this is only useful if a session is created\nin\n.Pa \\[ti]/.tmux.conf ,\n.Ic exit-empty\nis turned off, or another command is run as part of the same command sequence.\nFor example:\n.Bd -literal -offset indent\n$ tmux start \\\\; show -g\n.Ed\n.Tg suspendc\n.It Xo Ic suspend-client\n.Op Fl t Ar target-client\n.Xc\n.D1 Pq alias: Ic suspendc\nSuspend a client by sending\n.Dv SIGTSTP\n(tty stop).\n.Tg switchc\n.It Xo Ic switch-client\n.Op Fl ElnprZ\n.Op Fl c Ar target-client\n.Op Fl t Ar target-session\n.Op Fl T Ar key-table\n.Xc\n.D1 Pq alias: Ic switchc\nSwitch the current session for client\n.Ar target-client\nto\n.Ar target-session .\nAs a special case,\n.Fl t\nmay refer to a pane (a target that contains\n.Ql \\&: ,\n.Ql \\&.\nor\n.Ql % ) ,\nto change session, window and pane.\nIn that case,\n.Fl Z\nkeeps the window zoomed if it was zoomed.\nIf\n.Fl l ,\n.Fl n\nor\n.Fl p\nis used, the client is moved to the last, next or previous session\nrespectively.\n.Fl r\ntoggles the client\n.Ic read-only\nand\n.Ic ignore-size\nflags (see the\n.Ic attach-session\ncommand).\n.Pp\nIf\n.Fl E\nis used,\n.Ic update-environment\noption will not be applied.\n.Pp\n.Fl T\nsets the client's key table; the next key from the client will be interpreted\nfrom\n.Ar key-table .\nThis may be used to configure multiple prefix keys, or to bind commands to\nsequences of keys.\nFor example, to make typing\n.Ql abc\nrun the\n.Ic list-keys\ncommand:\n.Bd -literal -offset indent\nbind-key -Ttable2 c list-keys\nbind-key -Ttable1 b switch-client -Ttable2\nbind-key -Troot   a switch-client -Ttable1\n.Ed\n.El\n.Sh WINDOWS AND PANES\nEach window displayed by\n.Nm\nmay be split into one or more\n.Em panes ;\neach pane takes up a certain area of the display and is a separate terminal.\nA window may be split into panes using the\n.Ic split-window\ncommand.\nWindows may be split horizontally (with the\n.Fl h\nflag) or vertically.\nPanes may be resized with the\n.Ic resize-pane\ncommand (bound to\n.Ql C-Up ,\n.Ql C-Down\n.Ql C-Left\nand\n.Ql C-Right\nby default), the current pane may be changed with the\n.Ic select-pane\ncommand and the\n.Ic rotate-window\nand\n.Ic swap-pane\ncommands may be used to swap panes without changing their position.\nPanes are numbered beginning from zero in the order they are created.\n.Pp\nBy default, a\n.Nm\npane permits direct access to the terminal contained in the pane.\nA pane may also be put into one of several modes:\n.Bl -dash -offset indent\n.It\nCopy mode, which permits a section of a window or its\nhistory to be copied to a\n.Em paste buffer\nfor later insertion into another window.\nThis mode is entered with the\n.Ic copy-mode\ncommand, bound to\n.Ql \\&[\nby default.\nCopied text can be pasted with the\n.Ic paste-buffer\ncommand, bound to\n.Ql \\&] .\n.It\nView mode, which is like copy mode but is entered when a command that produces\noutput, such as\n.Ic list-keys ,\nis executed from a key binding.\n.It\nChoose mode, which allows an item to be chosen from a list.\nThis may be a client, a session or window or pane, or a buffer.\nThis mode is entered with the\n.Ic choose-buffer ,\n.Ic choose-client\nand\n.Ic choose-tree\ncommands.\n.El\n.Pp\nIn copy mode an indicator is displayed in the top-right corner of the pane with\nthe current position and the number of lines in the history.\n.Pp\nCommands are sent to copy mode using the\n.Fl X\nflag to the\n.Ic send-keys\ncommand.\nWhen a key is pressed, copy mode automatically uses one of two key tables,\ndepending on the\n.Ic mode-keys\noption:\n.Ic copy-mode\nfor emacs, or\n.Ic copy-mode-vi\nfor vi.\nKey tables may be viewed with the\n.Ic list-keys\ncommand.\n.Pp\nThe following commands are supported in copy mode:\n.Bl -tag -width Ds\n.It Xo\n.Ic append-selection\n.Xc\nAppend the selection to the top paste buffer.\n.It Xo\n.Ic append-selection-and-cancel\n(vi: A)\n.Xc\nAppend the selection to the top paste buffer and exit copy mode.\n.It Xo\n.Ic back-to-indentation\n(vi: ^)\n(emacs: M-m)\n.Xc\nMove the cursor back to the indentation.\n.It Xo\n.Ic begin-selection\n(vi: Space)\n(emacs: C-Space)\n.Xc\nBegin selection.\n.It Xo\n.Ic bottom-line\n(vi: L)\n.Xc\nMove to the bottom line.\n.It Xo\n.Ic cancel\n(vi: q)\n(emacs: Escape)\n.Xc\nExit copy mode.\n.It Xo\n.Ic clear-selection\n(vi: Escape)\n(emacs: C-g)\n.Xc\nClear the current selection.\n.It Xo\n.Ic copy-end-of-line\n.Op Fl CP\n.Op Ar prefix\n.Xc\nCopy from the cursor position to the end of the line.\n.Ar prefix\nis used to name the new paste buffer.\n.It Xo\n.Ic copy-end-of-line-and-cancel\n.Op Fl CP\n.Op Ar prefix\n.Xc\nCopy from the cursor position and exit copy mode.\n.It Xo\n.Ic copy-pipe-end-of-line\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nCopy from the cursor position to the end of the line and pipe the text to\n.Ar command .\n.Ar prefix\nis used to name the new paste buffer.\n.It Xo\n.Ic copy-pipe-end-of-line-and-cancel\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nSame as\n.Ic copy-pipe-end-of-line\nbut also exit copy mode.\n.It Xo\n.Ic copy-line\n.Op Fl CP\n.Op Ar prefix\n.Xc\nCopy the entire line.\n.It Xo\n.Ic copy-line-and-cancel\n.Op Fl CP\n.Op Ar prefix\n.Xc\nCopy the entire line and exit copy mode.\n.It Xo\n.Ic copy-pipe-line\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nCopy the entire line and pipe the text to\n.Ar command .\n.Ar prefix\nis used to name the new paste buffer.\n.It Xo\n.Ic copy-pipe-line-and-cancel\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nSame as\n.Ic copy-pipe-line\nbut also exit copy mode.\n.It Xo\n.Ic copy-pipe\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nCopy the selection, clear it and pipe its text to\n.Ar command .\n.Ar prefix\nis used to name the new paste buffer.\n.It Xo\n.Ic copy-pipe-no-clear\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nSame as\n.Ic copy-pipe\nbut do not clear the selection.\n.It Xo\n.Ic copy-pipe-and-cancel\n.Op Fl CP\n.Op Ar command\n.Op Ar prefix\n.Xc\nSame as\n.Ic copy-pipe\nbut also exit copy mode.\n.It Xo\n.Ic copy-selection\n.Op Fl CP\n.Op Ar prefix\n.Xc\nCopies the current selection.\n.It Xo\n.Ic copy-selection-no-clear\n.Op Fl CP\n.Op Ar prefix\n.Xc\nSame as\n.Ic copy-selection\nbut do not clear the selection.\n.It Xo\n.Ic copy-selection-and-cancel\n.Op Fl CP\n.Op Ar prefix\n(vi: Enter)\n(emacs: M-w)\n.Xc\nCopy the current selection and exit copy mode.\n.It Xo\n.Ic cursor-down\n(vi: j)\n(emacs: Down)\n.Xc\nMove the cursor down.\n.It Xo\n.Ic cursor-down-and-cancel\n.Xc\nSame as\n.Ic cursor-down\nbut also exit copy mode if reaching the bottom.\n.It Xo\n.Ic cursor-left\n(vi: h)\n(emacs: Left)\n.Xc\nMove the cursor left.\n.It Xo\n.Ic cursor-right\n(vi: l)\n(emacs: Right)\n.Xc\nMove the cursor right.\n.It Xo\n.Ic cursor-up\n(vi: k)\n(emacs: Up)\n.Xc\nMove the cursor up.\n.It Xo\n.Ic end-of-line\n(vi: $)\n(emacs: C-e)\n.Xc\nMove the cursor to the end of the line.\n.It Xo\n.Ic goto-line\n.Ar line\n(vi: :)\n(emacs: g)\n.Xc\nMove the cursor to a specific line.\n.It Xo\n.Ic halfpage-down\n(vi: C-d)\n(emacs: M-Down)\n.Xc\nScroll down by half a page.\n.It Xo\n.Ic halfpage-down-and-cancel\n.Xc\nSame as\n.Ic halfpage-down\nbut also exit copy mode if reaching the bottom.\n.It Xo\n.Ic halfpage-up\n(vi: C-u)\n(emacs: M-Up)\n.Xc\nScroll up by half a page.\n.It Xo\n.Ic history-bottom\n(vi: G)\n(emacs: M->)\n.Xc\nScroll to the bottom of the history.\n.It Xo\n.Ic history-top\n(vi: g)\n(emacs: M-<)\n.Xc\nScroll to the top of the history.\n.It Xo\n.Ic jump-again\n(vi: ;)\n(emacs: ;)\n.Xc\nRepeat the last jump.\n.It Xo\n.Ic jump-backward\n.Ar to\n(vi: F)\n(emacs: F)\n.Xc\nJump backwards to the specified text.\n.It Xo\n.Ic jump-forward\n.Ar to\n(vi: f)\n(emacs: f)\n.Xc\nJump forward to the specified text.\n.It Xo\n.Ic jump-reverse\n(vi: ,)\n(emacs: ,)\n.Xc\nRepeat the last jump in the reverse direction (forward becomes backward and\nbackward becomes forward).\n.It Xo\n.Ic jump-to-backward\n.Ar to\n(vi: T)\n.Xc\nJump backwards, but one character less, placing the cursor on the character\nafter the target.\n.It Xo\n.Ic jump-to-forward\n.Ar to\n(vi: t)\n.Xc\nJump forward, but one character less, placing the cursor on the character\nbefore the target.\n.It Xo\n.Ic jump-to-mark\n(vi: M-x)\n(emacs: M-x)\n.Xc\nJump to the last mark.\n.It Xo\n.Ic middle-line\n(vi: M)\n(emacs: M-r)\n.Xc\nMove to the middle line.\n.It Xo\n.Ic next-matching-bracket\n(vi: %)\n(emacs: M-C-f)\n.Xc\nMove to the next matching bracket.\n.It Xo\n.Ic next-paragraph\n(vi: })\n(emacs: M-})\n.Xc\nMove to the next paragraph.\n.It Xo\n.Ic next-prompt\n.Op Fl o\n.Xc\nMove to the next prompt.\n.It Xo\n.Ic next-word\n(vi: w)\n.Xc\nMove to the next word.\n.It Xo\n.Ic next-word-end\n(vi: e)\n(emacs: M-f)\n.Xc\nMove to the end of the next word.\n.It Xo\n.Ic next-space\n(vi: W)\n.Xc\nSame as\n.Ic next-word\nbut use a space alone as the word separator.\n.It Xo\n.Ic next-space-end\n(vi: E)\n.Xc\nSame as\n.Ic next-word-end\nbut use a space alone as the word separator.\n.It Xo\n.Ic other-end\n(vi: o)\n.Xc\nSwitch at which end of the selection the cursor sits.\n.It Xo\n.Ic page-down\n(vi: C-f)\n(emacs: PageDown)\n.Xc\nScroll down by one page.\n.It Xo\n.Ic page-down-and-cancel\n.Xc\nSame as\n.Ic page-down\nbut also exit copy mode if reaching the bottom.\n.It Xo\n.Ic page-up\n(vi: C-b)\n(emacs: PageUp)\n.Xc\nScroll up by one page.\n.It Xo\n.Ic pipe\n.Op Ar command\n.Xc\nPipe the selected text to\n.Ar command\nand clear the selection.\n.It Xo\n.Ic pipe-no-clear\n.Op Ar command\n.Xc\nSame as\n.Ic pipe\nbut do not clear the selection.\n.It Xo\n.Ic pipe-and-cancel\n.Op Ar command\n.Op Ar prefix\n.Xc\nSame as\n.Ic pipe\nbut also exit copy mode.\n.It Xo\n.Ic previous-matching-bracket\n(emacs: M-C-b)\n.Xc\nMove to the previous matching bracket.\n.It Xo\n.Ic previous-paragraph\n(vi: {)\n(emacs: M-{)\n.Xc\nMove to the previous paragraph.\n.It Xo\n.Ic previous-prompt\n.Op Fl o\n.Xc\nMove to the previous prompt.\n.It Xo\n.Ic previous-word\n(vi: b)\n(emacs: M-b)\n.Xc\nMove to the previous word.\n.It Xo\n.Ic previous-space\n(vi: B)\n.Xc\nSame as\n.Ic previous-word\nbut use a space alone as the word separator.\n.It Xo\n.Ic rectangle-on\n.Xc\nTurn on rectangle selection mode.\n.It Xo\n.Ic rectangle-off\n.Xc\nTurn off rectangle selection mode.\n.It Xo\n.Ic rectangle-toggle\n(vi: v)\n(emacs: R)\n.Xc\nToggle rectangle selection mode.\n.It Xo\n.Ic refresh-from-pane\n(vi: r)\n(emacs: r)\n.Xc\nRefresh the content from the pane.\n.It Xo\n.Ic scroll-bottom\n.Xc\nScroll up until the current line is at the bottom while keeping the cursor on\nthat line.\n.It Xo\n.Ic scroll-down\n(vi: C-e)\n(emacs: C-Down)\n.Xc\nScroll down.\n.It Xo\n.Ic scroll-down-and-cancel\n.Xc\nSame as\n.Ic scroll-down\nbut also exit copy mode if the cursor reaches the bottom.\n.It Xo\n.Ic scroll-middle\n(vi: z)\n.Xc\nScroll so that the current line becomes the middle one while keeping the\ncursor on that line.\n.It Xo\n.Ic scroll-top\n.Xc\nScroll down until the current line is at the top while keeping the cursor on\nthat line.\n.It Xo\n.Ic scroll-up\n(vi: C-y)\n(emacs: C-Up)\n.Xc\nScroll up.\n.It Xo\n.Ic search-again\n(vi: n)\n(emacs: n)\n.Xc\nRepeat the last search.\n.It Xo\n.Ic search-backward\n.Ar text\n(vi: ?)\n.Xc\nSearch backwards for the specified text.\n.It Xo\n.Ic search-backward-incremental\n.Ar text\n(emacs: C-r)\n.Xc\nSearch backwards incrementally for the specified text.\nIs expected to be used with the\n.Fl i\nflag to the\n.Ic command-prompt\ncommand.\n.It Xo\n.Ic search-backward-text\n.Ar text\n.Xc\nSearch backwards for the specified plain text.\n.It Xo\n.Ic search-forward\n.Ar text\n(vi: /)\n.Xc\nSearch forward for the specified text.\n.It Xo\n.Ic search-forward-incremental\n.Ar text\n(emacs: C-s)\n.Xc\nSearch forward incrementally for the specified text.\nIs expected to be used with the\n.Fl i\nflag to the\n.Ic command-prompt\ncommand.\n.It Xo\n.Ic search-forward-text\n.Ar text\n.Xc\nSearch forward for the specified plain text.\n.It Xo\n.Ic search-reverse\n(vi: N)\n(emacs: N)\n.Xc\nRepeat the last search in the reverse direction (forward becomes backward and\nbackward becomes forward).\n.It Xo\n.Ic select-line\n(vi: V)\n.Xc\nSelect the current line.\n.It Xo\n.Ic select-word\n.Xc\nSelect the current word.\n.It Xo\n.Ic set-mark\n(vi: X)\n(emacs: X)\n.Xc\nMark the current line.\n.It Xo\n.Ic start-of-line\n(vi: 0)\n(emacs: C-a)\n.Xc\nMove the cursor to the start of the line.\n.It Xo\n.Ic stop-selection\n.Xc\nStop selecting without clearing the current selection.\n.It Xo\n.Ic toggle-position\n(vi: P)\n(emacs: P)\n.Xc\nToggle the visibility of the position indicator in the top right.\n.It Xo\n.Ic top-line\n(vi: H)\n(emacs: M-R)\n.Xc\nMove to the top line.\n.El\n.Pp\nThe search commands come in several varieties:\n.Ql search-forward\nand\n.Ql search-backward\nsearch for a regular expression;\nthe\n.Ql -text\nvariants search for a plain text string rather than a regular expression;\n.Ql -incremental\nperform an incremental search and expect to be used with the\n.Fl i\nflag to the\n.Ic command-prompt\ncommand.\n.Ql search-again\nrepeats the last search and\n.Ql search-reverse\ndoes the same but reverses the direction (forward becomes backward and backward\nbecomes forward).\n.Pp\nThe\n.Ql next-prompt\nand\n.Ql previous-prompt\nmove between shell prompts, but require the shell to emit an escape sequence\n(\\e033]133;A\\e033\\e\\e) to tell\n.Nm\nwhere the prompts are located; if the shell does not do this, these commands\nwill do nothing.\nThe\n.Fl o\nflag jumps to the beginning of the command output instead of the shell prompt.\nFinding the beginning of command output requires the shell to emit an escape\nsequence (\\e033]133;C\\e033\\e\\e) to tell tmux where the output begins.\nIf the shell does not send these escape sequences, these commands do nothing.\n.Pp\nCopy commands may take an optional buffer prefix argument which is used\nto generate the buffer name (the default is\n.Ql buffer\nso buffers are named\n.Ql buffer0 ,\n.Ql buffer1\nand so on).\nPipe commands take a command argument which is the command to which the\nselected text is piped.\n.Ql copy-pipe\nvariants also copy the selection.\nThe\n.Ql -and-cancel\nvariants of some commands exit copy mode after they have completed (for copy\ncommands) or when the cursor reaches the bottom (for scrolling commands).\n.Ql -no-clear\nvariants do not clear the selection.\nAll the copy commands can take the\n.Fl C\nand\n.Fl P\nflags.\nThe\n.Fl C\nflag suppresses setting the terminal clipboard when copying, while the\n.Fl P\nflag suppresses adding a paste buffer with the text.\n.Pp\nThe next and previous word keys skip over whitespace and treat consecutive\nruns of either word separators or other letters as words.\nWord separators can be customized with the\n.Em word-separators\nsession option.\nNext word moves to the start of the next word, next word end to the end of the\nnext word and previous word to the start of the previous word.\nThe three next and previous space keys work similarly but use a space alone as\nthe word separator.\nSetting\n.Em word-separators\nto the empty string makes next/previous word equivalent to next/previous space.\n.Pp\nThe jump commands enable quick movement within a line.\nFor instance, typing\n.Ql f\nfollowed by\n.Ql /\nwill move the cursor to the next\n.Ql /\ncharacter on the current line.\nA\n.Ql \\&;\nwill then jump to the next occurrence.\n.Pp\nCommands in copy mode may be prefaced by an optional repeat count.\nWith vi key bindings, a prefix is entered using the number keys; with\nemacs, the Alt (meta) key and a number begins prefix entry.\n.Pp\nThe synopsis for the\n.Ic copy-mode\ncommand is:\n.Bl -tag -width Ds\n.It Xo Ic copy-mode\n.Op Fl deHMqSu\n.Op Fl s Ar src-pane\n.Op Fl t Ar target-pane\n.Xc\nEnter copy mode.\n.Pp\n.Fl u\nenters copy mode and scrolls one page up and\n.Fl d\none page down.\n.Fl H\nhides the position indicator in the top right.\n.Fl q\ncancels copy mode and any other modes.\n.Pp\n.Fl M\nbegins a mouse drag (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.Fl S\nscrolls when bound to a mouse drag event; for example,\n.Ic copy-mode -Se\nis bound to\n.Ar MouseDrag1ScrollbarSlider\nby default.\n.Pp\n.Fl s\ncopies from\n.Ar src-pane\ninstead of\n.Ar target-pane .\n.Pp\n.Fl e\nspecifies that scrolling to the bottom of the history (to the visible screen)\nshould exit copy mode.\nWhile in copy mode, pressing a key other than those used for scrolling will\ndisable this behaviour.\nThis is intended to allow fast scrolling through a pane's history, for\nexample with:\n.Bd -literal -offset indent\nbind PageUp copy-mode -eu\nbind PageDown copy-mode -ed\n.Ed\n.El\n.Pp\nA number of preset arrangements of panes are available, these are called\nlayouts.\nThese may be selected with the\n.Ic select-layout\ncommand or cycled with\n.Ic next-layout\n(bound to\n.Ql Space\nby default); once a layout is chosen, panes within it may be moved and resized\nas normal.\n.Pp\nThe following layouts are supported:\n.Bl -tag -width Ds\n.It Ic even-horizontal\nPanes are spread out evenly from left to right across the window.\n.It Ic even-vertical\nPanes are spread evenly from top to bottom.\n.It Ic main-horizontal\nA large (main) pane is shown at the top of the window and the remaining panes\nare spread from left to right in the leftover space at the bottom.\nUse the\n.Em main-pane-height\nwindow option to specify the height of the top pane.\n.It Ic main-horizontal-mirrored\nThe same as\n.Ic main-horizontal\nbut mirrored so the main pane is at the bottom of the window.\n.It Ic main-vertical\nA large (main) pane is shown on the left of the window and the remaining panes\nare spread from top to bottom in the leftover space on the right.\nUse the\n.Em main-pane-width\nwindow option to specify the width of the left pane.\n.It Ic main-vertical-mirrored\nThe same as\n.Ic main-vertical\nbut mirrored so the main pane is on the right of the window.\n.It Ic tiled\nPanes are spread out as evenly as possible over the window in both rows and\ncolumns.\n.El\n.Pp\nIn addition,\n.Ic select-layout\nmay be used to apply a previously used layout - the\n.Ic list-windows\ncommand displays the layout of each window in a form suitable for use with\n.Ic select-layout .\nFor example:\n.Bd -literal -offset indent\n$ tmux list-windows\n0: ksh [159x48]\n    layout: bb62,159x48,0,0{79x48,0,0,79x48,80,0}\n$ tmux select-layout \\[aq]bb62,159x48,0,0{79x48,0,0,79x48,80,0}\\[aq]\n.Ed\n.Pp\n.Nm\nautomatically adjusts the size of the layout for the current window size.\nNote that a layout cannot be applied to a window with more panes than that\nfrom which the layout was originally defined.\n.Pp\nCommands related to windows and panes are as follows:\n.Bl -tag -width Ds\n.Tg breakp\n.It Xo Ic break-pane\n.Op Fl abdP\n.Op Fl F Ar format\n.Op Fl n Ar window-name\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-window\n.Xc\n.D1 Pq alias: Ic breakp\nBreak\n.Ar src-pane\noff from its containing window to make it the only pane in\n.Ar dst-window .\nWith\n.Fl a\nor\n.Fl b ,\nthe window is moved to the next index after or before (existing windows are\nmoved if necessary).\nIf\n.Fl d\nis given, the new window does not become the current window.\nThe\n.Fl P\noption prints information about the new window after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:#{window_index}.#{pane_index}\nbut a different format may be specified with\n.Fl F .\n.Tg capturep\n.It Xo Ic capture-pane\n.Op Fl aAepPqCJN\n.Op Fl b Ar buffer-name\n.Op Fl E Ar end-line\n.Op Fl S Ar start-line\n.Op Fl t Ar target-pane\n.Xc\n.D1 Pq alias: Ic capturep\nCapture the contents of a pane.\nIf\n.Fl p\nis given, the output goes to stdout, otherwise to the buffer specified with\n.Fl b\nor a new buffer if omitted.\nIf\n.Fl a\nis given, the alternate screen is used, and the history is not accessible.\nIf no alternate screen exists, an error will be returned unless\n.Fl q\nis given.\nIf\n.Fl e\nis given, the output includes escape sequences for text and background\nattributes.\n.Fl C\nalso escapes non-printable characters as octal \\exxx.\n.Fl T\nignores trailing positions that do not contain a character.\n.Fl N\npreserves trailing spaces at each line's end and\n.Fl J\npreserves trailing spaces and joins any wrapped lines;\n.Fl J\nimplies\n.Fl T .\n.Fl P\ncaptures only any output that the pane has received that is the beginning of an\nas-yet incomplete escape sequence.\n.Pp\n.Fl S\nand\n.Fl E\nspecify the starting and ending line numbers, zero is the first line of the\nvisible pane and negative numbers are lines in the history.\n.Ql -\nto\n.Fl S\nis the start of the history and to\n.Fl E\nthe end of the visible pane.\nThe default is to capture only the visible contents of the pane.\n.It Xo\n.Ic choose-client\n.Op Fl NryZ\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl K Ar key-format\n.Op Fl O Ar sort-order\n.Op Fl t Ar target-pane\n.Op Ar template\n.Xc\nPut a pane into client mode, allowing a client to be selected interactively from\na list.\nEach client is shown on one line.\nA shortcut key is shown on the left in brackets allowing for immediate choice,\nor the list may be navigated and an item chosen or otherwise manipulated using\nthe keys below.\n.Fl Z\nzooms the pane.\n.Fl y\ndisables any confirmation prompts.\nThe following keys may be used in client mode:\n.Bl -column \"Key\" \"Function\" -offset indent\n.It Sy \"Key\" Ta Sy \"Function\"\n.It Li \"Enter\" Ta \"Choose selected client\"\n.It Li \"Up\" Ta \"Select previous client\"\n.It Li \"Down\" Ta \"Select next client\"\n.It Li \"C-s\" Ta \"Search by name\"\n.It Li \"n\" Ta \"Repeat last search forwards\"\n.It Li \"N\" Ta \"Repeat last search backwards\"\n.It Li \"t\" Ta \"Toggle if client is tagged\"\n.It Li \"T\" Ta \"Tag no clients\"\n.It Li \"C-t\" Ta \"Tag all clients\"\n.It Li \"d\" Ta \"Detach selected client\"\n.It Li \"D\" Ta \"Detach tagged clients\"\n.It Li \"x\" Ta \"Detach and HUP selected client\"\n.It Li \"X\" Ta \"Detach and HUP tagged clients\"\n.It Li \"z\" Ta \"Suspend selected client\"\n.It Li \"Z\" Ta \"Suspend tagged clients\"\n.It Li \"f\" Ta \"Enter a format to filter items\"\n.It Li \"O\" Ta \"Change sort field\"\n.It Li \"r\" Ta \"Reverse sort order\"\n.It Li \"v\" Ta \"Toggle preview\"\n.It Li \"q\" Ta \"Exit mode\"\n.El\n.Pp\nAfter a client is chosen,\n.Ql %%\nis replaced by the client name in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"detach-client -t \\[aq]%%\\[aq]\" is used.\n.Pp\n.Fl O\nspecifies the initial sort field: one of\n.Ql name ,\n.Ql size ,\n.Ql creation\n(time),\nor\n.Ql activity\n(time).\n.Fl r\nreverses the sort order.\n.Fl f\nspecifies an initial filter: the filter is a format - if it evaluates to zero,\nthe item in the list is not shown, otherwise it is shown.\nIf a filter would lead to an empty list, it is ignored.\n.Fl F\nspecifies the format for each item in the list and\n.Fl K\na format for each shortcut key; both are evaluated once for each line.\n.Fl N\nstarts without the preview or if given twice with the larger preview.\nThis command works only if at least one client is attached.\n.It Xo\n.Ic choose-tree\n.Op Fl GNrswyZ\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl K Ar key-format\n.Op Fl O Ar sort-order\n.Op Fl t Ar target-pane\n.Op Ar template\n.Xc\nPut a pane into tree mode, where a session, window or pane may be chosen\ninteractively from a tree.\nEach session, window or pane is shown on one line.\nA shortcut key is shown on the left in brackets allowing for immediate choice,\nor the tree may be navigated and an item chosen or otherwise manipulated using\nthe keys below.\n.Fl s\nstarts with sessions collapsed and\n.Fl w\nwith windows collapsed.\n.Fl Z\nzooms the pane.\n.Fl y\ndisables any confirmation prompts.\nThe following keys may be used in tree mode:\n.Bl -column \"Key\" \"Function\" -offset indent\n.It Sy \"Key\" Ta Sy \"Function\"\n.It Li \"Enter\" Ta \"Choose selected item\"\n.It Li \"Up\" Ta \"Select previous item\"\n.It Li \"Down\" Ta \"Select next item\"\n.It Li \"+\" Ta \"Expand selected item\"\n.It Li \"-\" Ta \"Collapse selected item\"\n.It Li \"M-+\" Ta \"Expand all items\"\n.It Li \"M--\" Ta \"Collapse all items\"\n.It Li \"x\" Ta \"Kill selected item\"\n.It Li \"X\" Ta \"Kill tagged items\"\n.It Li \"<\" Ta \"Scroll list of previews left\"\n.It Li \">\" Ta \"Scroll list of previews right\"\n.It Li \"C-s\" Ta \"Search by name\"\n.It Li \"m\" Ta \"Set the marked pane\"\n.It Li \"M\" Ta \"Clear the marked pane\"\n.It Li \"n\" Ta \"Repeat last search forwards\"\n.It Li \"N\" Ta \"Repeat last search backwards\"\n.It Li \"t\" Ta \"Toggle if item is tagged\"\n.It Li \"T\" Ta \"Tag no items\"\n.It Li \"C-t\" Ta \"Tag all items\"\n.It Li \"\\&:\" Ta \"Run a command for each tagged item\"\n.It Li \"f\" Ta \"Enter a format to filter items\"\n.It Li \"H\" Ta \"Jump to the starting pane\"\n.It Li \"O\" Ta \"Change sort field\"\n.It Li \"r\" Ta \"Reverse sort order\"\n.It Li \"v\" Ta \"Toggle preview\"\n.It Li \"q\" Ta \"Exit mode\"\n.El\n.Pp\nAfter a session, window or pane is chosen, the first instance of\n.Ql %%\nand all instances of\n.Ql %1\nare replaced by the target in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"switch-client -t \\[aq]%%\\[aq]\" is used.\n.Pp\n.Fl O\nspecifies the initial sort field: one of\n.Ql index ,\n.Ql name ,\nor\n.Ql time\n(activity).\n.Fl r\nreverses the sort order.\n.Fl f\nspecifies an initial filter: the filter is a format - if it evaluates to zero,\nthe item in the list is not shown, otherwise it is shown.\nIf a filter would lead to an empty list, it is ignored.\n.Fl F\nspecifies the format for each item in the tree and\n.Fl K\na format for each shortcut key; both are evaluated once for each line.\n.Fl N\nstarts without the preview or if given twice with the larger preview.\n.Fl G\nincludes all sessions in any session groups in the tree rather than only the\nfirst.\nThis command works only if at least one client is attached.\n.It Xo\n.Ic customize-mode\n.Op Fl NZ\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl t Ar target-pane\n.Op Ar template\n.Xc\nPut a pane into customize mode, where options and key bindings may be browsed\nand modified from a list.\nOption values in the list are shown for the active pane in the current window.\n.Fl Z\nzooms the pane.\nThe following keys may be used in customize mode:\n.Bl -column \"Key\" \"Function\" -offset indent\n.It Sy \"Key\" Ta Sy \"Function\"\n.It Li \"Enter\" Ta \"Set pane, window, session or global option value\"\n.It Li \"Up\" Ta \"Select previous item\"\n.It Li \"Down\" Ta \"Select next item\"\n.It Li \"+\" Ta \"Expand selected item\"\n.It Li \"-\" Ta \"Collapse selected item\"\n.It Li \"M-+\" Ta \"Expand all items\"\n.It Li \"M--\" Ta \"Collapse all items\"\n.It Li \"s\" Ta \"Set option value or key attribute\"\n.It Li \"S\" Ta \"Set global option value\"\n.It Li \"w\" Ta \"Set window option value, if option is for pane and window\"\n.It Li \"d\" Ta \"Set an option or key to the default\"\n.It Li \"D\" Ta \"Set tagged options and tagged keys to the default\"\n.It Li \"u\" Ta \"Unset an option (set to default value if global) or unbind a key\"\n.It Li \"U\" Ta \"Unset tagged options and unbind tagged keys\"\n.It Li \"C-s\" Ta \"Search by name\"\n.It Li \"n\" Ta \"Repeat last search forwards\"\n.It Li \"N\" Ta \"Repeat last search backwards\"\n.It Li \"t\" Ta \"Toggle if item is tagged\"\n.It Li \"T\" Ta \"Tag no items\"\n.It Li \"C-t\" Ta \"Tag all items\"\n.It Li \"f\" Ta \"Enter a format to filter items\"\n.It Li \"v\" Ta \"Toggle option information\"\n.It Li \"q\" Ta \"Exit mode\"\n.El\n.Pp\n.Fl f\nspecifies an initial filter: the filter is a format - if it evaluates to zero,\nthe item in the list is not shown, otherwise it is shown.\nIf a filter would lead to an empty list, it is ignored.\n.Fl F\nspecifies the format for each item in the tree.\n.Fl N\nstarts without the option information.\nThis command works only if at least one client is attached.\n.It Xo\n.Tg displayp\n.Ic display-panes\n.Op Fl bN\n.Op Fl d Ar duration\n.Op Fl t Ar target-client\n.Op Ar template\n.Xc\n.D1 Pq alias: Ic displayp\nDisplay a visible indicator of each pane shown by\n.Ar target-client .\nSee the\n.Ic display-panes-colour\nand\n.Ic display-panes-active-colour\nsession options.\nThe indicator is closed when a key is pressed (unless\n.Fl N\nis given) or\n.Ar duration\nmilliseconds have passed.\nIf\n.Fl d\nis not given,\n.Ic display-panes-time\nis used.\nA duration of zero means the indicator stays until a key is pressed.\nWhile the indicator is on screen, a pane may be chosen with the\n.Ql 0\nto\n.Ql 9\nkeys, which will cause\n.Ar template\nto be executed as a command with\n.Ql %%\nsubstituted by the pane ID.\nThe default\n.Ar template\nis \"select-pane -t \\[aq]%%\\[aq]\".\nWith\n.Fl b ,\nother commands are not blocked from running until the indicator is closed.\n.Tg findw\n.It Xo Ic find-window\n.Op Fl iCNrTZ\n.Op Fl t Ar target-pane\n.Ar match-string\n.Xc\n.D1 Pq alias: Ic findw\nSearch for a\n.Xr glob 7\npattern or, with\n.Fl r ,\nregular expression\n.Ar match-string\nin window names, titles, and visible content (but not history).\nThe flags control matching behavior:\n.Fl C\nmatches only visible window contents,\n.Fl N\nmatches only the window name and\n.Fl T\nmatches only the window title.\n.Fl i\nmakes the search ignore case.\nThe default is\n.Fl CNT .\n.Fl Z\nzooms the pane.\n.Pp\nThis command works only if at least one client is attached.\n.Tg joinp\n.It Xo Ic join-pane\n.Op Fl bdfhv\n.Op Fl l Ar size\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 Pq alias: Ic joinp\nLike\n.Ic split-window ,\nbut instead of splitting\n.Ar dst-pane\nand creating a new pane, split it and move\n.Ar src-pane\ninto the space.\nThis can be used to reverse\n.Ic break-pane .\nThe\n.Fl b\noption causes\n.Ar src-pane\nto be joined to left of or above\n.Ar dst-pane .\n.Pp\nIf\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe marked pane is used rather than the current pane.\n.Tg killp\n.It Xo Ic kill-pane\n.Op Fl a\n.Op Fl t Ar target-pane\n.Xc\n.D1 Pq alias: Ic killp\nDestroy the given pane.\nIf no panes remain in the containing window, it is also destroyed.\nThe\n.Fl a\noption kills all but the pane given with\n.Fl t .\n.Tg killw\n.It Xo Ic kill-window\n.Op Fl a\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic killw\nKill the current window or the window at\n.Ar target-window ,\nremoving it from any sessions to which it is linked.\nThe\n.Fl a\noption kills all but the window given with\n.Fl t .\n.Tg lastp\n.It Xo Ic last-pane\n.Op Fl deZ\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic lastp\nSelect the last (previously selected) pane.\n.Fl Z\nkeeps the window zoomed if it was zoomed.\n.Fl e\nenables or\n.Fl d\ndisables input to the pane.\n.Tg last\n.It Ic last-window Op Fl t Ar target-session\n.D1 Pq alias: Ic last\nSelect the last (previously selected) window.\nIf no\n.Ar target-session\nis specified, select the last window of the current session.\n.Tg link\n.It Xo Ic link-window\n.Op Fl abdk\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 Pq alias: Ic linkw\nLink the window at\n.Ar src-window\nto the specified\n.Ar dst-window .\nIf\n.Ar dst-window\nis specified and no such window exists, the\n.Ar src-window\nis linked there.\nWith\n.Fl a\nor\n.Fl b\nthe window is moved to the next index after or before\n.Ar dst-window\n(existing windows are moved if necessary).\nIf\n.Fl k\nis given and\n.Ar dst-window\nexists, it is killed, otherwise an error is generated.\nIf\n.Fl d\nis given, the newly linked window is not selected.\n.Tg lsp\n.It Xo Ic list-panes\n.Op Fl as\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl t Ar target\n.Xc\n.D1 Pq alias: Ic lsp\nIf\n.Fl a\nis given,\n.Ar target\nis ignored and all panes on the server are listed.\nIf\n.Fl s\nis given,\n.Ar target\nis a session (or the current session).\nIf neither is given,\n.Ar target\nis a window (or the current window).\n.Fl F\nspecifies the format of each line and\n.Fl f\na filter.\nOnly panes for which the filter is true are shown.\nSee the\n.Sx FORMATS\nsection.\n.Tg lsw\n.It Xo Ic list-windows\n.Op Fl a\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl t Ar target-session\n.Xc\n.D1 Pq alias: Ic lsw\nIf\n.Fl a\nis given, list all windows on the server.\nOtherwise, list windows in the current session or in\n.Ar target-session .\n.Fl F\nspecifies the format of each line and\n.Fl f\na filter.\nOnly windows for which the filter is true are shown.\nSee the\n.Sx FORMATS\nsection.\n.Tg movep\n.It Xo Ic move-pane\n.Op Fl bdfhv\n.Op Fl l Ar size\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 Pq alias: Ic movep\nDoes the same as\n.Ic join-pane .\n.Tg movew\n.It Xo Ic move-window\n.Op Fl abrdk\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 Pq alias: Ic movew\nThis is similar to\n.Ic link-window ,\nexcept the window at\n.Ar src-window\nis moved to\n.Ar dst-window .\nWith\n.Fl r ,\nall windows in the session are renumbered in sequential order, respecting\nthe\n.Ic base-index\noption.\n.Tg neww\n.It Xo Ic new-window\n.Op Fl abdkPS\n.Op Fl c Ar start-directory\n.Op Fl e Ar environment\n.Op Fl F Ar format\n.Op Fl n Ar window-name\n.Op Fl t Ar target-window\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic neww\nCreate a new window.\nWith\n.Fl a\nor\n.Fl b ,\nthe new window is inserted at the next index after or before the specified\n.Ar target-window ,\nmoving windows up if necessary;\notherwise\n.Ar target-window\nis the new window location.\n.Pp\nIf\n.Fl d\nis given, the session does not make the new window the current window.\n.Ar target-window\nrepresents the window to be created; if the target already exists an error is\nshown, unless the\n.Fl k\nflag is used, in which case it is destroyed.\nIf\n.Fl S\nis given and a window named\n.Ar window-name\nalready exists, it is selected (unless\n.Fl d\nis also given in which case the command does nothing).\n.Pp\n.Ar shell-command\nis the command to execute.\nIf\n.Ar shell-command\nis not specified, the value of the\n.Ic default-command\noption is used.\n.Fl c\nspecifies the working directory in which the new window is created.\n.Pp\nWhen the shell command completes, the window closes.\nSee the\n.Ic remain-on-exit\noption to change this behaviour.\n.Pp\n.Fl e\ntakes the form\n.Ql VARIABLE=value\nand sets an environment variable for the newly created window; it may be\nspecified multiple times.\n.Pp\nThe\n.Ev TERM\nenvironment variable must be set to\n.Ql screen\nor\n.Ql tmux\nfor all programs running\n.Em inside\n.Nm .\nNew windows will automatically have\n.Ql TERM=screen\nadded to their environment, but care must be taken not to reset this in shell\nstart-up files or by the\n.Fl e\noption.\n.Pp\nThe\n.Fl P\noption prints information about the new window after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:#{window_index}\nbut a different format may be specified with\n.Fl F .\n.Tg nextl\n.It Ic next-layout Op Fl t Ar target-window\n.D1 Pq alias: Ic nextl\nMove a window to the next layout and rearrange the panes to fit.\n.Tg next\n.It Xo Ic next-window\n.Op Fl a\n.Op Fl t Ar target-session\n.Xc\n.D1 Pq alias: Ic next\nMove to the next window in the session.\nIf\n.Fl a\nis used, move to the next window with an alert.\n.Tg pipep\n.It Xo Ic pipe-pane\n.Op Fl IOo\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic pipep\nPipe output sent by the program in\n.Ar target-pane\nto a shell command or vice versa.\nA pane may only be connected to one command at a time, any existing pipe is\nclosed before\n.Ar shell-command\nis executed.\nThe\n.Ar shell-command\nstring may contain the special character sequences supported by the\n.Ic status-left\noption.\nIf no\n.Ar shell-command\nis given, the current pipe (if any) is closed.\n.Pp\n.Fl I\nand\n.Fl O\nspecify which of the\n.Ar shell-command\noutput streams are connected to the pane:\nwith\n.Fl I\nstdout is connected (so anything\n.Ar shell-command\nprints is written to the pane as if it were typed);\nwith\n.Fl O\nstdin is connected (so any output in the pane is piped to\n.Ar shell-command ) .\nBoth may be used together and if neither are specified,\n.Fl O\nis used.\n.Pp\nThe\n.Fl o\noption only opens a new pipe if no previous pipe exists, allowing a pipe to\nbe toggled with a single key, for example:\n.Bd -literal -offset indent\nbind-key C-p pipe-pane -o \\[aq]cat >>\\[ti]/output.#I-#P\\[aq]\n.Ed\n.Tg prevl\n.It Xo Ic previous-layout\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic prevl\nMove to the previous layout in the session.\n.Tg prev\n.It Xo Ic previous-window\n.Op Fl a\n.Op Fl t Ar target-session\n.Xc\n.D1 Pq alias: Ic prev\nMove to the previous window in the session.\nWith\n.Fl a ,\nmove to the previous window with an alert.\n.Tg renamew\n.It Xo Ic rename-window\n.Op Fl t Ar target-window\n.Ar new-name\n.Xc\n.D1 Pq alias: Ic renamew\nRename the current window, or the window at\n.Ar target-window\nif specified, to\n.Ar new-name .\n.Tg resizep\n.It Xo Ic resize-pane\n.Op Fl DLMRTUZ\n.Op Fl t Ar target-pane\n.Op Fl x Ar width\n.Op Fl y Ar height\n.Op Ar adjustment\n.Xc\n.D1 Pq alias: Ic resizep\nResize a pane, up, down, left or right by\n.Ar adjustment\nwith\n.Fl U ,\n.Fl D ,\n.Fl L\nor\n.Fl R ,\nor\nto an absolute size\nwith\n.Fl x\nor\n.Fl y .\nThe\n.Ar adjustment\nis given in lines or columns (the default is 1);\n.Fl x\nand\n.Fl y\nmay be a given as a number of lines or columns or followed by\n.Ql %\nfor a percentage of the window size (for example\n.Ql -x 10% ) .\nWith\n.Fl Z ,\nthe active pane is toggled between zoomed (occupying the whole of the window)\nand unzoomed (its normal position in the layout).\n.Pp\n.Fl M\nbegins mouse resizing (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.Pp\n.Fl T\ntrims all lines below the current cursor position and moves lines out of the\nhistory to replace them.\n.Tg resizew\n.It Xo Ic resize-window\n.Op Fl aADLRU\n.Op Fl t Ar target-window\n.Op Fl x Ar width\n.Op Fl y Ar height\n.Op Ar adjustment\n.Xc\n.D1 Pq alias: Ic resizew\nResize a window, up, down, left or right by\n.Ar adjustment\nwith\n.Fl U ,\n.Fl D ,\n.Fl L\nor\n.Fl R ,\nor\nto an absolute size\nwith\n.Fl x\nor\n.Fl y .\nThe\n.Ar adjustment\nis given in lines or cells (the default is 1).\n.Fl A\nsets the size of the largest session containing the window;\n.Fl a\nthe size of the smallest.\nThis command will automatically set\n.Ic window-size\nto manual in the window options.\n.Tg respawnp\n.It Xo Ic respawn-pane\n.Op Fl k\n.Op Fl c Ar start-directory\n.Op Fl e Ar environment\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic respawnp\nReactivate a pane in which the command has exited (see the\n.Ic remain-on-exit\nwindow option).\nIf\n.Ar shell-command\nis not given, the command used when the pane was created or last respawned is\nexecuted.\nThe pane must be already inactive, unless\n.Fl k\nis given, in which case any existing command is killed.\n.Fl c\nspecifies a new working directory for the pane.\nThe\n.Fl e\noption has the same meaning as for the\n.Ic new-window\ncommand.\n.Tg respawnw\n.It Xo Ic respawn-window\n.Op Fl k\n.Op Fl c Ar start-directory\n.Op Fl e Ar environment\n.Op Fl t Ar target-window\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic respawnw\nReactivate a window in which the command has exited (see the\n.Ic remain-on-exit\nwindow option).\nIf\n.Ar shell-command\nis not given, the command used when the window was created or last respawned is\nexecuted.\nThe window must be already inactive, unless\n.Fl k\nis given, in which case any existing command is killed.\n.Fl c\nspecifies a new working directory for the window.\nThe\n.Fl e\noption has the same meaning as for the\n.Ic new-window\ncommand.\n.Tg rotatew\n.It Xo Ic rotate-window\n.Op Fl DUZ\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic rotatew\nRotate the positions of the panes within a window, either upward (numerically\nlower) with\n.Fl U\nor downward (numerically higher).\n.Fl Z\nkeeps the window zoomed if it was zoomed.\n.Tg selectl\n.It Xo Ic select-layout\n.Op Fl Enop\n.Op Fl t Ar target-pane\n.Op Ar layout-name\n.Xc\n.D1 Pq alias: Ic selectl\nChoose a specific layout for a window.\nIf\n.Ar layout-name\nis not given, the last preset layout used (if any) is reapplied.\n.Fl n\nand\n.Fl p\nare equivalent to the\n.Ic next-layout\nand\n.Ic previous-layout\ncommands.\n.Fl o\napplies the last set layout if possible (undoes the most recent layout change).\n.Fl E\nspreads the current pane and any panes next to it out evenly.\n.Tg selectp\n.It Xo Ic select-pane\n.Op Fl DdeLlMmRUZ\n.Op Fl T Ar title\n.Op Fl t Ar target-pane\n.Xc\n.D1 Pq alias: Ic selectp\nMake pane\n.Ar target-pane\nthe active pane in its window.\nIf one of\n.Fl D ,\n.Fl L ,\n.Fl R ,\nor\n.Fl U\nis used, respectively the pane below, to the left, to the right, or above the\ntarget pane is used.\n.Fl Z\nkeeps the window zoomed if it was zoomed.\n.Fl l\nis the same as using the\n.Ic last-pane\ncommand.\n.Fl e\nenables or\n.Fl d\ndisables input to the pane.\n.Fl T\nsets the pane title.\n.Pp\n.Fl m\nand\n.Fl M\nare used to set and clear the\n.Em marked pane .\nThere is one marked pane at a time, setting a new marked pane clears the last.\nThe marked pane is the default target for\n.Fl s\nto\n.Ic join-pane ,\n.Ic move-pane ,\n.Ic swap-pane\nand\n.Ic swap-window .\n.Tg selectw\n.It Xo Ic select-window\n.Op Fl lnpT\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic selectw\nSelect the window at\n.Ar target-window .\n.Fl l ,\n.Fl n\nand\n.Fl p\nare equivalent to the\n.Ic last-window ,\n.Ic next-window\nand\n.Ic previous-window\ncommands.\nIf\n.Fl T\nis given and the selected window is already the current window,\nthe command behaves like\n.Ic last-window .\n.Tg splitw\n.It Xo Ic split-window\n.Op Fl bdfhIvPZ\n.Op Fl c Ar start-directory\n.Op Fl e Ar environment\n.Op Fl l Ar size\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Op Fl F Ar format\n.Xc\n.D1 Pq alias: Ic splitw\nCreate a new pane by splitting\n.Ar target-pane :\n.Fl h\ndoes a horizontal split and\n.Fl v\na vertical split; if neither is specified,\n.Fl v\nis assumed.\nThe\n.Fl l\noption specifies the size of the new pane in lines (for vertical split) or in\ncolumns (for horizontal split);\n.Ar size\nmay be followed by\n.Ql %\nto specify a percentage of the available space.\nThe\n.Fl b\noption causes the new pane to be created to the left of or above\n.Ar target-pane .\nThe\n.Fl f\noption creates a new pane spanning the full window height (with\n.Fl h )\nor full window width (with\n.Fl v ) ,\ninstead of splitting the active pane.\n.Fl Z\nzooms if the window is not zoomed, or keeps it zoomed if already zoomed.\n.Pp\nAn empty\n.Ar shell-command\n(\\[aq]\\[aq]) will create a pane with no command running in it.\nOutput can be sent to such a pane with the\n.Ic display-message\ncommand.\nThe\n.Fl I\nflag (if\n.Ar shell-command\nis not specified or empty)\nwill create an empty pane and forward any output from stdin to it.\nFor example:\n.Bd -literal -offset indent\n$ make 2>&1|tmux splitw -dI &\n.Ed\n.Pp\nAll other options have the same meaning as for the\n.Ic new-window\ncommand.\n.Tg swapp\n.It Xo Ic swap-pane\n.Op Fl dDUZ\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 Pq alias: Ic swapp\nSwap two panes.\nIf\n.Fl U\nis used and no source pane is specified with\n.Fl s ,\n.Ar dst-pane\nis swapped with the previous pane (before it numerically);\n.Fl D\nswaps with the next pane (after it numerically).\n.Fl d\ninstructs\n.Nm\nnot to change the active pane and\n.Fl Z\nkeeps the window zoomed if it was zoomed.\n.Pp\nIf\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe marked pane is used rather than the current pane.\n.Tg swapw\n.It Xo Ic swap-window\n.Op Fl d\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 Pq alias: Ic swapw\nThis is similar to\n.Ic link-window ,\nexcept the source and destination windows are swapped.\nIt is an error if no window exists at\n.Ar src-window .\nIf\n.Fl d\nis given, the new window does not become the current window.\n.Pp\nIf\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe window containing the marked pane is used rather than the current window.\n.Tg unlinkw\n.It Xo Ic unlink-window\n.Op Fl k\n.Op Fl t Ar target-window\n.Xc\n.D1 Pq alias: Ic unlinkw\nUnlink\n.Ar target-window .\nUnless\n.Fl k\nis given, a window may be unlinked only if it is linked to multiple sessions -\nwindows may not be linked to no sessions;\nif\n.Fl k\nis specified and the window is linked to only one session, it is unlinked and\ndestroyed.\n.El\n.Sh KEY BINDINGS\n.Nm\nallows a command to be bound to most keys, with or without a prefix key.\nWhen specifying keys, most represent themselves (for example\n.Ql A\nto\n.Ql Z ) .\nCtrl keys may be prefixed with\n.Ql C-\nor\n.Ql ^ ,\nShift keys with\n.Ql S-\nand Alt (meta) with\n.Ql M- .\nIn addition, the following special key names are accepted:\n.Em Up ,\n.Em Down ,\n.Em Left ,\n.Em Right ,\n.Em BSpace ,\n.Em BTab ,\n.Em DC\n(Delete),\n.Em End ,\n.Em Enter ,\n.Em Escape ,\n.Em F1\nto\n.Em F12 ,\n.Em Home ,\n.Em IC\n(Insert),\n.Em NPage/PageDown/PgDn ,\n.Em PPage/PageUp/PgUp ,\n.Em Space ,\nand\n.Em Tab .\nNote that to bind the\n.Ql \\&\"\nor\n.Ql \\[aq]\nkeys, quotation marks are necessary, for example:\n.Bd -literal -offset indent\nbind-key \\[aq]\"\\[aq] split-window\nbind-key \"\\[aq]\" new-window\n.Ed\n.Pp\nA command bound to the\n.Em Any\nkey will execute for all keys which do not have a more specific binding.\n.Pp\nCommands related to key bindings are as follows:\n.Bl -tag -width Ds\n.Tg bind\n.It Xo Ic bind-key\n.Op Fl nr\n.Op Fl N Ar note\n.Op Fl T Ar key-table\n.Ar key command Op Ar argument ...\n.Xc\n.D1 Pq alias: Ic bind\nBind key\n.Ar key\nto\n.Ar command .\nKeys are bound in a key table.\nBy default (without -T), the key is bound in\nthe\n.Em prefix\nkey table.\nThis table is used for keys pressed after the prefix key (for example,\nby default\n.Ql c\nis bound to\n.Ic new-window\nin the\n.Em prefix\ntable, so\n.Ql C-b c\ncreates a new window).\nThe\n.Em root\ntable is used for keys pressed without the prefix key: binding\n.Ql c\nto\n.Ic new-window\nin the\n.Em root\ntable (not recommended) means a plain\n.Ql c\nwill create a new window.\n.Fl n\nis an alias\nfor\n.Fl T Ar root .\nKeys may also be bound in custom key tables and the\n.Ic switch-client\n.Fl T\ncommand used to switch to them from a key binding.\nThe\n.Fl r\nflag indicates this key may repeat, see the\n.Ic initial-repeat-time\nand\n.Ic repeat-time\noptions.\n.Fl N\nattaches a note to the key (shown with\n.Ic list-keys\n.Fl N ) .\n.Pp\nTo view the default bindings and possible commands, see the\n.Ic list-keys\ncommand.\n.Tg lsk\n.It Xo Ic list-keys\n.Op Fl 1aN\n.Op Fl P Ar prefix-string Fl T Ar key-table\n.Op Ar key\n.Xc\n.D1 Pq alias: Ic lsk\nList key bindings.\nThere are two forms: the default lists keys as\n.Ic bind-key\ncommands;\n.Fl N\nlists only keys with attached notes and shows only the key and note for each\nkey.\n.Pp\nWith the default form, all key tables are listed by default.\n.Fl T\nlists only keys in\n.Ar key-table .\n.Pp\nWith the\n.Fl N\nform, only keys in the\n.Em root\nand\n.Em prefix\nkey tables are listed by default;\n.Fl T\nalso lists only keys in\n.Ar key-table .\n.Fl P\nspecifies a prefix to print before each key and\n.Fl 1\nlists only the first matching key.\n.Fl a\nlists the command for keys that do not have a note rather than skipping them.\n.Tg send\n.It Xo Ic send-keys\n.Op Fl FHKlMRX\n.Op Fl c Ar target-client\n.Op Fl N Ar repeat-count\n.Op Fl t Ar target-pane\n.Ar key ...\n.Xc\n.D1 Pq alias: Ic send\nSend a key or keys to a window or client.\nEach argument\n.Ar key\nis the name of the key (such as\n.Ql C-a\nor\n.Ql NPage )\nto send; if the string is not recognised as a key, it is sent as a series of\ncharacters.\nIf\n.Fl K\nis given, keys are sent to\n.Ar target-client ,\nso they are looked up in the client's key table, rather than to\n.Ar target-pane .\nAll arguments are sent sequentially from first to last.\nIf no keys are given and the command is bound to a key, then that key is used.\n.Pp\nThe\n.Fl l\nflag disables key name lookup and processes the keys as literal UTF-8\ncharacters.\nThe\n.Fl H\nflag expects each key to be a hexadecimal number for an ASCII character.\n.Pp\nThe\n.Fl R\nflag causes the terminal state to be reset.\n.Pp\n.Fl M\npasses through a mouse event (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.Pp\n.Fl X\nis used to send a command into copy mode - see\nthe\n.Sx WINDOWS AND PANES\nsection.\n.Fl N\nspecifies a repeat count and\n.Fl F\nexpands formats in arguments where appropriate.\n.It Xo Ic send-prefix\n.Op Fl 2\n.Op Fl t Ar target-pane\n.Xc\nSend the prefix key, or with\n.Fl 2\nthe secondary prefix key, to a window as if it was pressed.\n.Tg unbind\n.It Xo Ic unbind-key\n.Op Fl anq\n.Op Fl T Ar key-table\n.Ar key\n.Xc\n.D1 Pq alias: Ic unbind\nUnbind the command bound to\n.Ar key .\n.Fl n\nand\n.Fl T\nare the same as for\n.Ic bind-key .\nIf\n.Fl a\nis present, all key bindings are removed.\nThe\n.Fl q\noption prevents errors being returned.\n.El\n.Sh OPTIONS\nThe appearance and behaviour of\n.Nm\nmay be modified by changing the value of various options.\nThere are four types of option:\n.Em server options ,\n.Em session options ,\n.Em window options ,\nand\n.Em pane options .\n.Pp\nThe\n.Nm\nserver has a set of global server options which do not apply to any particular\nwindow or session or pane.\nThese are altered with the\n.Ic set-option\n.Fl s\ncommand, or displayed with the\n.Ic show-options\n.Fl s\ncommand.\n.Pp\nIn addition, each individual session may have a set of session options, and\nthere is a separate set of global session options.\nSessions which do not have a particular option configured inherit the value\nfrom the global session options.\nSession options are set or unset with the\n.Ic set-option\ncommand and may be listed with the\n.Ic show-options\ncommand.\nThe available server and session options are listed under the\n.Ic set-option\ncommand.\n.Pp\nSimilarly, a set of window options is attached to each window and a set of pane\noptions to each pane.\nPane options inherit from window options.\nThis means any pane option may be set as a window option to apply the option to\nall panes in the window without the option set, for example these commands will\nset the background colour to red for all panes except pane 0:\n.Bd -literal -offset indent\nset -w window-style bg=red\nset -pt:.0 window-style bg=blue\n.Ed\n.Pp\nThere is also a set of global window options from which any unset window or\npane options are inherited.\nWindow and pane options are altered with\n.Ic set-option\n.Fl w\nand\n.Fl p\ncommands and displayed with\n.Ic show-option\n.Fl w\nand\n.Fl p .\n.Pp\n.Nm\nalso supports user options which are prefixed with a\n.Ql \\&@ .\nUser options may have any name, so long as they are prefixed with\n.Ql \\&@ ,\nand be set to any string.\nFor example:\n.Bd -literal -offset indent\n$ tmux set -wq @foo \"abc123\"\n$ tmux show -wv @foo\nabc123\n.Ed\n.Pp\nCommands which set options are as follows:\n.Bl -tag -width Ds\n.Tg set\n.It Xo Ic set-option\n.Op Fl aFgopqsuUw\n.Op Fl t Ar target-pane\n.Ar option Ar value\n.Xc\n.D1 Pq alias: Ic set\nSet a pane option with\n.Fl p ,\na window option with\n.Fl w ,\na server option with\n.Fl s ,\notherwise a session option.\nIf the option is not a user option,\n.Fl w\nor\n.Fl s\nmay be unnecessary -\n.Nm\nwill infer the type from the option name, assuming\n.Fl w\nfor pane options.\nIf\n.Fl g\nis given, the global session or window option is set.\n.Pp\n.Fl F\nexpands formats in the option value.\nThe\n.Fl u\nflag unsets an option, so a session inherits the option from the global\noptions (or with\n.Fl g ,\nrestores a global option to the default).\n.Fl U\nunsets an option (like\n.Fl u )\nbut if the option is a pane option also unsets the option on any panes in the\nwindow.\n.Ar value\ndepends on the option and may be a number, a string, or a flag (on, off, or\nomitted to toggle).\n.Pp\nThe\n.Fl o\nflag prevents setting an option that is already set and the\n.Fl q\nflag suppresses errors about unknown or ambiguous options.\n.Pp\nWith\n.Fl a ,\nand if the option expects a string or a style,\n.Ar value\nis appended to the existing setting.\nFor example:\n.Bd -literal -offset indent\nset -g status-left \"foo\"\nset -ag status-left \"bar\"\n.Ed\n.Pp\nWill result in\n.Ql foobar .\nAnd:\n.Bd -literal -offset indent\nset -g status-style \"bg=red\"\nset -ag status-style \"fg=blue\"\n.Ed\n.Pp\nWill result in a red background\n.Em and\nblue foreground.\nWithout\n.Fl a ,\nthe result would be the default background and a blue foreground.\n.Tg show\n.It Xo Ic show-options\n.Op Fl AgHpqsvw\n.Op Fl t Ar target-pane\n.Op Ar option\n.Xc\n.D1 Pq alias: Ic show\nShow the pane options (or a single option if\n.Ar option\nis provided) with\n.Fl p ,\nthe window options with\n.Fl w ,\nthe server options with\n.Fl s ,\notherwise the session options.\nIf the option is not a user option,\n.Fl w\nor\n.Fl s\nmay be unnecessary -\n.Nm\nwill infer the type from the option name, assuming\n.Fl w\nfor pane options.\nGlobal session or window options are listed if\n.Fl g\nis used.\n.Fl v\nshows only the option value, not the name.\nIf\n.Fl q\nis set, no error will be returned if\n.Ar option\nis unset.\n.Fl H\nincludes hooks (omitted by default).\n.Fl A\nincludes options inherited from a parent set of options, such options are\nmarked with an asterisk.\n.El\n.Pp\nAvailable server options are:\n.Bl -tag -width Ds\n.It Ic backspace Ar key\nSet the key sent by\n.Nm\nfor backspace.\n.It Ic buffer-limit Ar number\nSet the number of buffers; as new buffers are added to the top of the stack,\nold ones are removed from the bottom if necessary to maintain this maximum\nlength.\n.It Xo Ic command-alias[]\n.Ar name=value\n.Xc\nThis is an array of custom aliases for commands.\nIf an unknown command matches\n.Ar name ,\nit is replaced with\n.Ar value .\nFor example, after:\n.Pp\n.Dl set -s command-alias[100] zoom=\\[aq]resize-pane -Z\\[aq]\n.Pp\nUsing:\n.Pp\n.Dl zoom -t:.1\n.Pp\nIs equivalent to:\n.Pp\n.Dl resize-pane -Z -t:.1\n.Pp\nNote that aliases are expanded when a command is parsed rather than when it is\nexecuted, so binding an alias with\n.Ic bind-key\nwill bind the expanded form.\n.It Ic codepoint-widths[] Ar string\nAn array option allowing widths of Unicode codepoints to be overridden.\nNote the new width applies to all clients.\nEach entry is of the form\n.Em codepoint=width ,\nwhere codepoint may be a UTF-8 character or an identifier of the form\n.Ql U+number\nwhere the number is a hexadecimal number.\n.It Ic copy-command Ar shell-command\nGive the command to pipe to if the\n.Ic copy-pipe\ncopy mode command is used without arguments.\n.It Ic default-terminal Ar terminal\nSet the default terminal for new windows created in this session - the\ndefault value of the\n.Ev TERM\nenvironment variable.\nFor\n.Nm\nto work correctly, this\n.Em must\nbe set to\n.Ql screen ,\n.Ql tmux\nor a derivative of them.\n.It Ic escape-time Ar time\nSet the time in milliseconds for which\n.Nm\nwaits after an escape is input to determine if it is part of a function or meta\nkey sequences.\n.It Ic editor Ar shell-command\nSet the command used when\n.Nm\nruns an editor.\n.It Xo Ic exit-empty\n.Op Ic on | off\n.Xc\nIf enabled (the default), the server will exit when there are no active\nsessions.\n.It Xo Ic exit-unattached\n.Op Ic on | off\n.Xc\nIf enabled, the server will exit when there are no attached clients.\n.It Xo Ic extended-keys\n.Op Ic on | off | always\n.Xc\nControls how modified keys (keys pressed together with Control, Meta, or Shift)\nare reported.\nThis is the equivalent of the\n.Ic modifyOtherKeys\n.Xr xterm 1\nresource.\n.Pp\nWhen set to\n.Ic on ,\nthe program inside the pane can request one of two modes: mode 1 which changes\nthe sequence for only keys which lack an existing well-known representation; or\nmode 2 which changes the sequence for all keys.\nWhen set to\n.Ic always ,\nmodes 1 and 2 can still be requested by applications, but mode 1 will be forced\ninstead of the standard mode.\nWhen set to\n.Ic off ,\nthis feature is disabled and only standard keys are reported.\n.Pp\n.Nm\nwill always request extended keys itself if the terminal supports them.\nSee also the\n.Ic extkeys\nfeature for the\n.Ic terminal-features\noption, the\n.Ic extended-keys-format\noption and the\n.Ic pane_key_mode\nvariable.\n.It Xo Ic extended-keys-format\n.Op Ic csi-u | xterm\n.Xc\nSelects one of the two possible formats for reporting modified keys to\napplications.\nThis is the equivalent of the\n.Ic formatOtherKeys\n.Xr xterm 1\nresource.\nFor example, C-S-a will be reported as\n.Ql ^[[27;6;65~\nwhen set to\n.Ic xterm ,\nand as\n.Ql ^[[65;6u\nwhen set to\n.Ic csi-u .\n.It Xo Ic focus-events\n.Op Ic on | off\n.Xc\nWhen enabled, focus events are requested from the terminal if supported and\npassed through to applications running in\n.Nm .\nAttached clients should be detached and attached again after changing this\noption.\n.It Ic history-file Ar path\nIf not empty, a file to which\n.Nm\nwill write command prompt history on exit and load it from on start.\n.It Ic input-buffer-size Ar bytes\nMaximum of bytes allowed to read in escape and control sequences.\nOnce reached, the sequence will be discarded.\n.It Ic message-limit Ar number\nSet the number of error or information messages to save in the message log for\neach client.\n.It Ic prompt-history-limit Ar number\nSet the number of history items to save in the history file for each type of\ncommand prompt.\n.It Xo Ic set-clipboard\n.Op Ic on | external | off\n.Xc\nAttempt to set the terminal clipboard content using the\n.Xr xterm 1\nescape sequence, if there is an\n.Em \\&Ms\nentry in the\n.Xr terminfo 5\ndescription (see the\n.Sx TERMINFO EXTENSIONS\nsection).\n.Pp\nIf set to\n.Ic on ,\n.Nm\nwill both accept the escape sequence to create a buffer and attempt to set\nthe terminal clipboard.\nIf set to\n.Ic external ,\n.Nm\nwill attempt to set the terminal clipboard but ignore attempts\nby applications to set\n.Nm\nbuffers.\nIf\n.Ic off ,\n.Nm\nwill neither accept the clipboard escape sequence nor attempt to set the\nclipboard.\n.Pp\nNote that this feature needs to be enabled in\n.Xr xterm 1\nby setting the resource:\n.Bd -literal -offset indent\ndisallowedWindowOps: 20,21,SetXprop\n.Ed\n.Pp\nOr changing this property from the\n.Xr xterm 1\ninteractive menu when required.\n.It Ic terminal-features[] Ar string\nSet terminal features for terminal types read from\n.Xr terminfo 5 .\n.Nm\nhas a set of named terminal features.\nEach will apply appropriate changes to the\n.Xr terminfo 5\nentry in use.\n.Pp\n.Nm\ncan detect features for a few common terminals; this option can be used to\neasily tell tmux about features supported by terminals it cannot detect.\nThe\n.Ic terminal-overrides\noption allows individual\n.Xr terminfo 5\ncapabilities to be set instead,\n.Ic terminal-features\nis intended for classes of functionality supported in a standard way but not\nreported by\n.Xr terminfo 5 .\nCare must be taken to configure this only with features the terminal actually\nsupports.\n.Pp\nThis is an array option where each entry is a colon-separated string made up\nof a terminal type pattern (matched using\n.Xr glob 7\npatterns) followed by a list of terminal features.\nThe available features are:\n.Bl -tag -width Ds\n.It 256\nSupports 256 colours with the SGR escape sequences.\n.It clipboard\nAllows setting the system clipboard.\n.It ccolour\nAllows setting the cursor colour.\n.It cstyle\nAllows setting the cursor style.\n.It extkeys\nSupports extended keys.\n.It focus\nSupports focus reporting.\n.It hyperlinks\nSupports OSC 8 hyperlinks.\n.It ignorefkeys\nIgnore function keys from\n.Xr terminfo 5\nand use the\n.Nm\ninternal set only.\n.It margins\nSupports DECSLRM margins.\n.It mouse\nSupports\n.Xr xterm 1\nmouse sequences.\n.It osc7\nSupports the OSC 7 working directory extension.\n.It overline\nSupports the overline SGR attribute.\n.It rectfill\nSupports the DECFRA rectangle fill escape sequence.\n.It RGB\nSupports RGB colour with the SGR escape sequences.\n.It sixel\nSupports SIXEL graphics.\n.It strikethrough\nSupports the strikethrough SGR escape sequence.\n.It sync\nSupports synchronized updates.\n.It title\nSupports\n.Xr xterm 1\ntitle setting.\n.It usstyle\nAllows underscore style and colour to be set.\n.El\n.It Ic terminal-overrides[] Ar string\nAllow terminal descriptions read using\n.Xr terminfo 5\nto be overridden.\nEach entry is a colon-separated string made up of a terminal type pattern\n(matched using\n.Xr glob 7\npatterns)\nand a set of\n.Em name=value\nentries.\n.Pp\nFor example, to set the\n.Ql clear\n.Xr terminfo 5\nentry to\n.Ql \\ee[H\\ee[2J\nfor all terminal types matching\n.Ql rxvt* :\n.Pp\n.Dl \"rxvt*:clear=\\ee[H\\ee[2J\"\n.Pp\nThe terminal entry value is passed through\n.Xr strunvis 3\nbefore interpretation.\n.It Ic user-keys[] Ar key\nSet list of user-defined key escape sequences.\nEach item is associated with a key named\n.Ql User0 ,\n.Ql User1 ,\nand so on.\n.Pp\nFor example:\n.Bd -literal -offset indent\nset -s user-keys[0] \"\\ee[5;30012\\[ti]\"\nbind User0 resize-pane -L 3\n.Ed\n.El\n.Pp\nAvailable session options are:\n.Bl -tag -width Ds\n.It Xo Ic activity-action\n.Op Ic any | none | current | other\n.Xc\nSet action on window activity when\n.Ic monitor-activity\nis on.\n.Ic any\nmeans activity in any window linked to a session causes a bell or message\n(depending on\n.Ic visual-activity )\nin the current window of that session,\n.Ic none\nmeans all activity is ignored (equivalent to\n.Ic monitor-activity\nbeing off),\n.Ic current\nmeans only activity in windows other than the current window are ignored and\n.Ic other\nmeans activity in the current window is ignored but not those in other windows.\n.It Ic assume-paste-time Ar milliseconds\nIf keys are entered faster than one in\n.Ar milliseconds ,\nthey are assumed to have been pasted rather than typed and\n.Nm\nkey bindings are not processed.\nThe default is one millisecond and zero disables.\n.It Ic base-index Ar index\nSet the base index from which an unused index should be searched when a new\nwindow is created.\nThe default is zero.\n.It Xo Ic bell-action\n.Op Ic any | none | current | other\n.Xc\nSet action on a bell in a window when\n.Ic monitor-bell\nis on.\nThe values are the same as those for\n.Ic activity-action .\n.It Ic default-command Ar shell-command\nSet the command used for new windows (if not specified when the window is\ncreated) to\n.Ar shell-command ,\nwhich may be any\n.Xr sh 1\ncommand.\nThe default is an empty string, which instructs\n.Nm\nto create a login shell using the value of the\n.Ic default-shell\noption.\n.It Ic default-shell Ar path\nSpecify the default shell.\nThis is used as the login shell for new windows when the\n.Ic default-command\noption is set to empty, and must be the full path of the executable.\nWhen started\n.Nm\ntries to set a default value from the first suitable of the\n.Ev SHELL\nenvironment variable, the shell returned by\n.Xr getpwuid 3 ,\nor\n.Pa /bin/sh .\nThis option should be configured when\n.Nm\nis used as a login shell.\n.It Ic default-size Ar XxY\nSet the default size of new windows when the\n.Ic window-size\noption is set to manual or when a session is created with\n.Ic new-session\n.Fl d .\nThe value is the width and height separated by an\n.Ql x\ncharacter.\nThe default is 80x24.\n.It Xo Ic destroy-unattached\n.Op Ic off | on | keep-last | keep-group\n.Xc\nIf\n.Ic on ,\ndestroy the session after the last client has detached.\nIf\n.Ic off\n(the default), leave the session orphaned.\nIf\n.Ic keep-last ,\ndestroy the session only if it is in a group and has other sessions in that\ngroup.\nIf\n.Ic keep-group ,\ndestroy the session unless it is in a group and is the only session in that\ngroup.\n.It Xo Ic detach-on-destroy\n.Op Ic off | on | no-detached | previous | next\n.Xc\nIf\n.Ic on\n(the default), the client is detached when the session it is attached to\nis destroyed.\nIf\n.Ic off ,\nthe client is switched to the most recently active of the remaining\nsessions.\nIf\n.Ic no-detached ,\nthe client is detached only if there are no detached sessions; if detached\nsessions exist, the client is switched to the most recently active.\nIf\n.Ic previous\nor\n.Ic next ,\nthe client is switched to the previous or next session in alphabetical order.\n.It Ic display-panes-active-colour Ar colour\nSet the colour used by the\n.Ic display-panes\ncommand to show the indicator for the active pane.\n.It Ic display-panes-colour Ar colour\nSet the colour used by the\n.Ic display-panes\ncommand to show the indicators for inactive panes.\n.It Ic display-panes-time Ar time\nSet the time in milliseconds for which the indicators shown by the\n.Ic display-panes\ncommand appear.\n.It Ic display-time Ar time\nSet the amount of time for which status line messages and other on-screen\nindicators are displayed.\nIf set to 0, messages and indicators are displayed until a key is pressed.\n.Ar time\nis in milliseconds.\n.It Ic history-limit Ar lines\nSet the maximum number of lines held in window history.\nThis setting applies only to new windows - existing window histories are not\nresized and retain the limit at the point they were created.\n.It Ic initial-repeat-time Ar time\nSet the time in milliseconds for the initial repeat when a key is bound with the\n.Fl r\nflag.\nThis allows multiple commands to be entered without pressing the prefix key\nagain.\nSee also the\n.Ic repeat-time\noption.\nIf\n.Ic initial-repeat-time\nis zero,\n.Ic repeat-time\nis used for the first key press.\n.It Ic key-table Ar key-table\nSet the default key table to\n.Ar key-table\ninstead of\n.Em root .\n.It Ic lock-after-time Ar number\nLock the session (like the\n.Ic lock-session\ncommand) after\n.Ar number\nseconds of inactivity.\nThe default is not to lock (set to 0).\n.It Ic lock-command Ar shell-command\nCommand to run when locking each client.\nThe default is to run\n.Xr lock 1\nwith\n.Fl np .\n.It Ic menu-style Ar style\nSet the menu style.\nSee the\n.Sx STYLES\nsection on how to specify\n.Ar style .\n.It Ic menu-selected-style Ar style\nSet the selected menu item style.\nSee the\n.Sx STYLES\nsection on how to specify\n.Ar style .\n.It Ic menu-border-style Ar style\nSet the menu border style.\nSee the\n.Sx STYLES\nsection on how to specify\n.Ar style .\n.It Ic menu-border-lines Ar type\nSet the type of characters used for drawing menu borders.\nSee\n.Ic popup-border-lines\nfor possible values for\n.Ar border-lines .\n.It Ic message-command-style Ar style\nSet status line message command style.\nThis is used for the command prompt with\n.Xr vi 1\nkeys when in command mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.It Xo Ic message-line\n.Op Ic 0 | 1 | 2 | 3 | 4\n.Xc\nSet line on which status line messages and the command prompt are shown.\n.It Ic message-style Ar style\nSet status line message style.\nThis is used for messages and for the command prompt.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.It Xo Ic mouse\n.Op Ic on | off\n.Xc\nIf on,\n.Nm\ncaptures the mouse and allows mouse events to be bound as key bindings.\nSee the\n.Sx MOUSE SUPPORT\nsection for details.\n.It Ic prefix Ar key\nSet the key accepted as a prefix key.\nIn addition to the standard keys described under\n.Sx KEY BINDINGS ,\n.Ic prefix\ncan be set to the special key\n.Ql None\nto set no prefix.\n.It Ic prefix2 Ar key\nSet a secondary key accepted as a prefix key.\nLike\n.Ic prefix ,\n.Ic prefix2\ncan be set to\n.Ql None .\n.It Ic prefix-timeout Ar time\nSet the time in milliseconds for which\n.Nm\nwaits after\n.Ic prefix\nis input before dismissing it.\nCan be set to zero to disable any timeout.\n.It Ic prompt-cursor-colour Ar colour\nSet the colour of the cursor in the command prompt.\n.It Ic prompt-cursor-style Ar style\nSet the style of the cursor in the command prompt.\nSee the\n.Ic cursor-style\noptions for available styles.\n.It Xo Ic renumber-windows\n.Op Ic on | off\n.Xc\nIf on, when a window is closed in a session, automatically renumber the other\nwindows in numerical order.\nThis respects the\n.Ic base-index\noption if it has been set.\nIf off, do not renumber the windows.\n.It Ic repeat-time Ar time\nAllow multiple commands to be entered without pressing the prefix key again\nin the specified\n.Ar time\nmilliseconds (the default is 500).\nWhether a key repeats may be set when it is bound using the\n.Fl r\nflag to\n.Ic bind-key .\nRepeat is enabled for the default keys bound to the\n.Ic resize-pane\ncommand.\nSee also the\n.Ic initial-repeat-time\noption.\n.It Xo Ic set-titles\n.Op Ic on | off\n.Xc\nAttempt to set the client terminal title using the\n.Em tsl\nand\n.Em fsl\n.Xr terminfo 5\nentries if they exist.\n.Nm\nautomatically sets these to the \\ee]0;...\\e007 sequence if\nthe terminal appears to be\n.Xr xterm 1 .\nThis option is off by default.\n.It Ic set-titles-string Ar string\nString used to set the client terminal title if\n.Ic set-titles\nis on.\nFormats are expanded, see the\n.Sx FORMATS\nsection.\n.It Xo Ic silence-action\n.Op Ic any | none | current | other\n.Xc\nSet action on window silence when\n.Ic monitor-silence\nis on.\nThe values are the same as those for\n.Ic activity-action .\n.It Xo Ic status\n.Op Ic off | on | 2 | 3 | 4 | 5\n.Xc\nShow or hide the status line or specify its size.\nUsing\n.Ic on\ngives a status line one row in height;\n.Ic 2 ,\n.Ic 3 ,\n.Ic 4\nor\n.Ic 5\nmore rows.\n.It Ic status-format[] Ar format\nSpecify the format to be used for each line of the status line.\nThe default builds the top status line from the various individual status\noptions below.\n.It Ic status-interval Ar interval\nUpdate the status line every\n.Ar interval\nseconds.\nBy default, updates will occur every 15 seconds.\nA setting of zero disables redrawing at interval.\n.It Xo Ic status-justify\n.Op Ic left | centre | right | absolute-centre\n.Xc\nSet the position of the window list in the status line: left, centre or right.\ncentre puts the window list in the relative centre of the available free space;\nabsolute-centre uses the centre of the entire horizontal space.\n.It Xo Ic status-keys\n.Op Ic vi | emacs\n.Xc\nUse vi or emacs-style\nkey bindings in the status line, for example at the command prompt.\nThe default is emacs, unless the\n.Ev VISUAL\nor\n.Ev EDITOR\nenvironment variables are set and contain the string\n.Ql vi .\n.It Ic status-left Ar string\nDisplay\n.Ar string\n(by default the session name) to the left of the status line.\n.Ar string\nwill be passed through\n.Xr strftime 3 .\nAlso see the\n.Sx FORMATS\nand\n.Sx STYLES\nsections.\n.Pp\nFor details on how the names and titles can be set see the\n.Sx \"NAMES AND TITLES\"\nsection.\n.Pp\nExamples are:\n.Bd -literal -offset indent\n#(sysctl vm.loadavg)\n#[fg=yellow,bold]#(apm -l)%%#[default] [#S]\n.Ed\n.Pp\nThe default is\n.Ql \"[#S] \" .\n.It Ic status-left-length Ar length\nSet the maximum\n.Ar length\nof the left component of the status line.\nThe default is 10.\n.It Ic status-left-style Ar style\nSet the style of the left part of the status line.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.It Xo Ic status-position\n.Op Ic top | bottom\n.Xc\nSet the position of the status line.\n.It Ic status-right Ar string\nDisplay\n.Ar string\nto the right of the status line.\nBy default, the current pane title in double quotes, the date and the time\nare shown.\nAs with\n.Ic status-left ,\n.Ar string\nwill be passed to\n.Xr strftime 3\nand character pairs are replaced.\n.It Ic status-right-length Ar length\nSet the maximum\n.Ar length\nof the right component of the status line.\nThe default is 40.\n.It Ic status-right-style Ar style\nSet the style of the right part of the status line.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.It Ic status-style Ar style\nSet status line style.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.It Ic update-environment[] Ar variable\nSet list of environment variables to be copied into the session environment\nwhen a new session is created or an existing session is attached.\nAny variables that do not exist in the source environment are set to be\nremoved from the session environment (as if\n.Fl r\nwas given to the\n.Ic set-environment\ncommand).\n.It Xo Ic visual-activity\n.Op Ic on | off | both\n.Xc\nIf on, display a message instead of sending a bell when activity occurs in a\nwindow for which the\n.Ic monitor-activity\nwindow option is enabled.\nIf set to both, a bell and a message are produced.\n.It Xo Ic visual-bell\n.Op Ic on | off | both\n.Xc\nIf on, a message is shown on a bell in a window for which the\n.Ic monitor-bell\nwindow option is enabled instead of it being passed through to the\nterminal (which normally makes a sound).\nIf set to both, a bell and a message are produced.\nAlso see the\n.Ic bell-action\noption.\n.It Xo Ic visual-silence\n.Op Ic on | off | both\n.Xc\nIf\n.Ic monitor-silence\nis enabled, prints a message after the interval has expired on a given window\ninstead of sending a bell.\nIf set to both, a bell and a message are produced.\n.It Ic word-separators Ar string\nSets the session's conception of what characters are considered word\nseparators, for the purposes of the next and previous word commands in\ncopy mode.\n.El\n.Pp\nAvailable window options are:\n.Pp\n.Bl -tag -width Ds -compact\n.It Xo Ic aggressive-resize\n.Op Ic on | off\n.Xc\nAggressively resize the chosen window.\nThis means that\n.Nm\nwill resize the window to the size of the smallest or largest session\n(see the\n.Ic window-size\noption) for which it is the current window, rather than the session to\nwhich it is attached.\nThe window may resize when the current window is changed on another\nsession; this option is good for full-screen programs which support\n.Dv SIGWINCH\nand poor for interactive programs such as shells.\n.Pp\n.It Xo Ic automatic-rename\n.Op Ic on | off\n.Xc\nControl automatic window renaming.\nWhen this setting is enabled,\n.Nm\nwill rename the window automatically using the format specified by\n.Ic automatic-rename-format .\nThis flag is automatically disabled for an individual window when a name\nis specified at creation with\n.Ic new-window\nor\n.Ic new-session ,\nor later with\n.Ic rename-window ,\nor with a terminal escape sequence.\nIt may be switched off globally with:\n.Bd -literal -offset indent\nset-option -wg automatic-rename off\n.Ed\n.Pp\n.It Ic automatic-rename-format Ar format\nThe format (see\n.Sx FORMATS )\nused when the\n.Ic automatic-rename\noption is enabled.\n.Pp\n.It Ic clock-mode-colour Ar colour\nSet clock colour.\n.Pp\n.It Xo Ic clock-mode-style\n.Op Ic 12 | 24\n.Xc\nSet clock hour format.\n.Pp\n.It Ic fill-character Ar character\nSet the character used to fill areas of the terminal unused by a window.\n.Pp\n.It Ic main-pane-height Ar height\n.It Ic main-pane-width Ar width\nSet the width or height of the main (left or top) pane in the\n.Ic main-horizontal ,\n.Ic main-horizontal-mirrored ,\n.Ic main-vertical ,\nor\n.Ic main-vertical-mirrored\nlayouts.\nIf suffixed by\n.Ql % ,\nthis is a percentage of the window size.\n.Pp\n.It Ic copy-mode-match-style Ar style\nSet the style of search matches in copy mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic copy-mode-mark-style Ar style\nSet the style of the line containing the mark in copy mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic copy-mode-current-match-style Ar style\nSet the style of the current search match in copy mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic copy-mode-position-format Ar format\nFormat of the position indicator in copy mode.\n.Pp\n.It Xo Ic mode-keys\n.Op Ic vi | emacs\n.Xc\nUse vi or emacs-style key bindings in copy mode.\nThe default is emacs, unless\n.Ev VISUAL\nor\n.Ev EDITOR\ncontains\n.Ql vi .\n.Pp\n.It Ic copy-mode-position-style Ar style\nSet the style of the position indicator in copy mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic copy-mode-selection-style Ar style\nSet the style of the selection in copy mode.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic mode-style Ar style\nSet window modes style.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Xo Ic monitor-activity\n.Op Ic on | off\n.Xc\nMonitor for activity in the window.\nWindows with activity are highlighted in the status line.\n.Pp\n.It Xo Ic monitor-bell\n.Op Ic on | off\n.Xc\nMonitor for a bell in the window.\nWindows with a bell are highlighted in the status line.\n.Pp\n.It Xo Ic monitor-silence\n.Op Ic interval\n.Xc\nMonitor for silence (no activity) in the window within\n.Ic interval\nseconds.\nWindows that have been silent for the interval are highlighted in the\nstatus line.\nAn interval of zero disables the monitoring.\n.Pp\n.It Ic other-pane-height Ar height\nSet the height of the other panes (not the main pane) in the\n.Ic main-horizontal\nand\n.Ic main-horizontal-mirrored\nlayouts.\nIf this option is set to 0 (the default), it will have no effect.\nIf both the\n.Ic main-pane-height\nand\n.Ic other-pane-height\noptions are set, the main pane will grow taller to make the other panes the\nspecified height, but will never shrink to do so.\nIf suffixed by\n.Ql % ,\nthis is a percentage of the window size.\n.Pp\n.It Ic other-pane-width Ar width\nLike\n.Ic other-pane-height ,\nbut set the width of other panes in the\n.Ic main-vertical\nand\n.Ic main-vertical-mirrored\nlayouts.\n.Pp\n.It Ic pane-active-border-style Ar style\nSet the pane border style for the currently active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\nAttributes are ignored.\n.Pp\n.It Ic pane-base-index Ar index\nLike\n.Ic base-index ,\nbut set the starting index for pane numbers.\n.Pp\n.It Ic pane-border-format Ar format\nSet the text shown in pane border status lines.\n.Pp\n.It Xo Ic pane-border-indicators\n.Op Ic off | colour | arrows | both\n.Xc\nIndicate active pane by colouring only half of the border in windows with\nexactly two panes, by displaying arrow markers, by drawing both or neither.\n.Pp\n.It Ic pane-border-lines Ar type\nSet the type of characters used for drawing pane borders.\n.Ar type\nmay be one of:\n.Bl -tag -width Ds\n.It single\nsingle lines using ACS or UTF-8 characters\n.It double\ndouble lines using UTF-8 characters\n.It heavy\nheavy lines using UTF-8 characters\n.It simple\nsimple ASCII characters\n.It number\nthe pane number\n.El\n.Pp\n.Ql double\nand\n.Ql heavy\nwill fall back to standard ACS line drawing when UTF-8 is not supported.\n.Pp\n.It Xo Ic pane-border-status\n.Op Ic off | top | bottom\n.Xc\nTurn pane border status lines off or set their position.\n.Pp\n.It Ic pane-border-style Ar style\nSet the pane border style for panes aside from the active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\nAttributes are ignored.\n.Pp\n.It Ic popup-style Ar style\nSet the popup style.\nSee the\n.Sx STYLES\nsection on how to specify\n.Ar style .\nAttributes are ignored.\n.Pp\n.It Ic popup-border-style Ar style\nSet the popup border style.\nSee the\n.Sx STYLES\nsection on how to specify\n.Ar style .\nAttributes are ignored.\n.Pp\n.It Ic popup-border-lines Ar type\nSet the type of characters used for drawing popup borders.\n.Ar type\nmay be one of:\n.Bl -tag -width Ds\n.It single\nsingle lines using ACS or UTF-8 characters (default)\n.It rounded\nvariation of single with rounded corners using UTF-8 characters\n.It double\ndouble lines using UTF-8 characters\n.It heavy\nheavy lines using UTF-8 characters\n.It simple\nsimple ASCII characters\n.It padded\nsimple ASCII space character\n.It none\nno border\n.El\n.Pp\n.Ql double\nand\n.Ql heavy\nwill fall back to standard ACS line drawing when UTF-8 is not supported.\n.Pp\n.It Xo Ic pane-scrollbars\n.Op Ic off | modal | on\n.Xc\nWhen enabled, a character based scrollbar appears on the left or right\nof each pane.\nA filled section of the scrollbar, known as the\n.Ql slider ,\nrepresents the position and size of the visible part of the pane content.\n.Pp\nIf set to\n.Ic on\nthe scrollbar is visible all the time.\nIf set to\n.Ic modal\nthe scrollbar only appears when the pane is in copy mode or view mode.\nWhen the scrollbar is visible, the pane is narrowed by the width of the\nscrollbar and the text in the pane is reflowed.\nIf set to\n.Ic modal ,\nthe pane is narrowed only when the scrollbar is visible.\n.Pp\nSee also\n.Ic pane-scrollbars-style .\n.Pp\n.It Ic pane-scrollbars-style Ar style\nSet the scrollbars style.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\nThe foreground colour is used for the slider, the background for the rest of the\nscrollbar.\nThe\n.Ar width\nattribute sets the width of the scrollbar and the\n.Ar pad\nattribute the padding between the scrollbar and the pane.\nOther attributes are ignored.\n.Pp\n.It Xo Ic pane-scrollbars-position\n.Op Ic left | right\n.Xc\nSets which side of the pane to display pane scrollbars on.\n.Pp\n.It Ic window-status-activity-style Ar style\nSet status line style for windows with an activity alert.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic window-status-bell-style Ar style\nSet status line style for windows with a bell alert.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic window-status-current-format Ar string\nLike\n.Ar window-status-format ,\nbut is the format used when the window is the current window.\n.Pp\n.It Ic window-status-current-style Ar style\nSet status line style for the currently active window.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic window-status-format Ar string\nSet the format in which the window is displayed in the status line window list.\nSee the\n.Sx FORMATS\nand\n.Sx STYLES\nsections.\n.Pp\n.It Ic window-status-last-style Ar style\nSet status line style for the last active window.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic window-status-separator Ar string\nSets the separator drawn between windows in the status line.\nThe default is a single space character.\n.Pp\n.It Ic window-status-style Ar style\nSet status line style for a single window.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Xo Ic window-size\n.Ar largest | Ar smallest | Ar manual | Ar latest\n.Xc\nConfigure how\n.Nm\ndetermines the window size.\nIf set to\n.Ar largest ,\nthe size of the largest attached session is used; if\n.Ar smallest ,\nthe size of the smallest.\nIf\n.Ar manual ,\nthe size of a new window is set from the\n.Ic default-size\noption and windows are resized automatically.\nWith\n.Ar latest ,\n.Nm\nuses the size of the client that had the most recent activity.\nSee also the\n.Ic resize-window\ncommand and the\n.Ic aggressive-resize\noption.\n.Pp\n.It Xo Ic wrap-search\n.Op Ic on | off\n.Xc\nIf this option is set, searches will wrap around the end of the pane contents.\nThe default is on.\n.El\n.Pp\nAvailable pane options are:\n.Pp\n.Bl -tag -width Ds -compact\n.It Xo Ic allow-passthrough\n.Op Ic on | off | all\n.Xc\nAllow programs in the pane to bypass\n.Nm\nusing a terminal escape sequence (\\eePtmux;...\\ee\\e\\e).\nIf set to\n.Ic on ,\npassthrough sequences will be allowed only if the pane is visible.\nIf set to\n.Ic all ,\nthey will be allowed even if the pane is invisible.\n.Pp\n.It Xo Ic allow-rename\n.Op Ic on | off\n.Xc\nAllow programs in the pane to change the window name using a terminal escape\nsequence (\\eek...\\ee\\e\\e).\n.Pp\n.It Xo Ic allow-set-title\n.Op Ic on | off\n.Xc\nAllow programs in the pane to change the title using the terminal escape\nsequences (\\ee]2;...\\ee\\e\\e or \\ee]0;...\\ee\\e\\e).\n.Pp\n.It Xo Ic alternate-screen\n.Op Ic on | off\n.Xc\nThis option configures whether programs running inside the pane may use the\nterminal alternate screen feature, which allows the\n.Em smcup\nand\n.Em rmcup\n.Xr terminfo 5\ncapabilities.\nThe alternate screen feature preserves the contents of the window when an\ninteractive application starts and restores it on exit, so that any output\nvisible before the application starts reappears unchanged after it exits.\n.Pp\n.It Ic cursor-colour Ar colour\nSet the colour of the cursor.\n.Pp\n.It Ic cursor-style Ar style\nSet the style of the cursor.\nAvailable styles are:\n.Ic default ,\n.Ic blinking-block ,\n.Ic block ,\n.Ic blinking-underline ,\n.Ic underline ,\n.Ic blinking-bar ,\n.Ic bar .\n.Pp\n.It Ic pane-colours[] Ar colour\nThe default colour palette.\nEach entry in the array defines the colour\n.Nm\nuses when the colour with that index is requested.\nThe index may be from zero to 255.\n.Pp\n.It Xo Ic remain-on-exit\n.Op Ic on | off | failed\n.Xc\nA pane with this flag set is not destroyed when the program running in it\nexits.\nIf set to\n.Ic failed ,\nthen only when the program exit status is not zero.\nThe pane may be reactivated with the\n.Ic respawn-pane\ncommand.\n.Pp\n.It Ic remain-on-exit-format Ar string\nSet the text shown at the bottom of exited panes when\n.Ic remain-on-exit\nis enabled.\n.Pp\n.It Xo Ic scroll-on-clear\n.Op Ic on | off\n.Xc\nWhen the entire screen is cleared and this option is on, scroll the contents of\nthe screen into history before clearing it.\n.Pp\n.It Xo Ic synchronize-panes\n.Op Ic on | off\n.Xc\nDuplicate input to all other panes in the same window where this option is also\non (only for panes that are not in any mode).\n.Pp\n.It Ic window-active-style Ar style\nSet the pane style when it is the active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.Pp\n.It Ic window-style Ar style\nSet the pane style.\nFor how to specify\n.Ar style ,\nsee the\n.Sx STYLES\nsection.\n.El\n.Sh HOOKS\n.Nm\nallows commands to run on various triggers, called\n.Em hooks .\nMost\n.Nm\ncommands have an\n.Em after\nhook and there are a number of hooks not associated with commands.\n.Pp\nHooks are stored as array options, members of the array are executed in\norder when the hook is triggered.\nLike options different hooks may be global or belong to a session, window or\npane.\nHooks may be configured with the\n.Ic set-hook\nor\n.Ic set-option\ncommands and displayed with\n.Ic show-hooks\nor\n.Ic show-options\n.Fl H .\nThe following two commands are equivalent:\n.Bd -literal -offset indent.\nset-hook -g pane-mode-changed[42] \\[aq]set -g status-left-style bg=red\\[aq]\nset-option -g pane-mode-changed[42] \\[aq]set -g status-left-style bg=red\\[aq]\n.Ed\n.Pp\nSetting a hook without specifying an array index clears the hook and sets the\nfirst member of the array.\n.Pp\nA command's after\nhook is run after it completes, except when the command is run as part of a hook\nitself.\nThey are named with an\n.Ql after-\nprefix.\nFor example, the following command adds a hook to select the even-vertical\nlayout after every\n.Ic split-window :\n.Bd -literal -offset indent\nset-hook -g after-split-window \"selectl even-vertical\"\n.Ed\n.Pp\nIf a command fails, the\n.Ql command-error\nhook will be fired.\nFor example, this could be used to write to a log file:\n.Bd -literal -offset indent\nset-hook -g command-error \"run-shell \\\\\"echo 'a tmux command failed' >>/tmp/log\\\\\"\"\n.Ed\n.Pp\nAll the notifications listed in the\n.Sx CONTROL MODE\nsection are hooks (without any arguments), except\n.Ic %exit .\nThe following additional hooks are available:\n.Bl -tag -width \"XXXXXXXXXXXXXXXXXXXXXX\"\n.It alert-activity\nRun when a window has activity.\nSee\n.Ic monitor-activity .\n.It alert-bell\nRun when a window has received a bell.\nSee\n.Ic monitor-bell .\n.It alert-silence\nRun when a window has been silent.\nSee\n.Ic monitor-silence .\n.It client-active\nRun when a client becomes the latest active client of its session.\n.It client-attached\nRun when a client is attached.\n.It client-detached\nRun when a client is detached\n.It client-focus-in\nRun when focus enters a client\n.It client-focus-out\nRun when focus exits a client\n.It client-resized\nRun when a client is resized.\n.It client-session-changed\nRun when a client's attached session is changed.\n.It command-error\nRun when a command fails.\n.It pane-died\nRun when the program running in a pane exits, but\n.Ic remain-on-exit\nis on so the pane has not closed.\n.It pane-exited\nRun when the program running in a pane exits.\n.It pane-focus-in\nRun when the focus enters a pane, if the\n.Ic focus-events\noption is on.\n.It pane-focus-out\nRun when the focus exits a pane, if the\n.Ic focus-events\noption is on.\n.It pane-set-clipboard\nRun when the terminal clipboard is set using the\n.Xr xterm 1\nescape sequence.\n.It session-created\nRun when a new session created.\n.It session-closed\nRun when a session closed.\n.It session-renamed\nRun when a session is renamed.\n.It window-layout-changed\nRun when a window layout is changed.\n.It window-linked\nRun when a window is linked into a session.\n.It window-renamed\nRun when a window is renamed.\n.It window-resized\nRun when a window is resized.\nThis may be after the\n.Ar client-resized\nhook is run.\n.It window-unlinked\nRun when a window is unlinked from a session.\n.El\n.Pp\nHooks are managed with these commands:\n.Bl -tag -width Ds\n.It Xo Ic set-hook\n.Op Fl agpRuw\n.Op Fl t Ar target-pane\n.Ar hook-name\n.Ar command\n.Xc\nWithout\n.Fl R ,\nsets (or with\n.Fl u\nunsets) hook\n.Ar hook-name\nto\n.Ar command .\nThe flags are the same as for\n.Ic set-option .\n.Pp\nWith\n.Fl R ,\nrun\n.Ar hook-name\nimmediately.\n.It Xo Ic show-hooks\n.Op Fl gpw\n.Op Fl t Ar target-pane\n.Xc\nShows hooks.\nThe flags are the same as for\n.Ic show-options .\n.El\n.Sh MOUSE SUPPORT\nIf the\n.Ic mouse\noption is on (the default is off),\n.Nm\nallows mouse events to be bound as keys.\nThe name of each key is made up of a mouse event (such as\n.Ql MouseUp1 )\nand a location suffix, one of the following:\n.Bl -column \"XXXXXXXXXXXXX\" -offset indent\n.It Li \"Pane\" Ta \"the contents of a pane\"\n.It Li \"Border\" Ta \"a pane border\"\n.It Li \"Status\" Ta \"the status line window list\"\n.It Li \"StatusLeft\" Ta \"the left part of the status line\"\n.It Li \"StatusRight\" Ta \"the right part of the status line\"\n.It Li \"StatusDefault\" Ta \"any other part of the status line\"\n.It Li \"ScrollbarSlider\" Ta \"the scrollbar slider\"\n.It Li \"ScrollbarUp\" Ta \"above the scrollbar slider\"\n.It Li \"ScrollbarDown\" Ta \"below the scrollbar slider\"\n.El\n.Pp\nThe following mouse events are available:\n.Bl -column \"MouseDown1\" \"MouseDrag1\" \"WheelDown\" -offset indent\n.It Li \"WheelUp\" Ta \"WheelDown\" Ta \"\"\n.It Li \"MouseDown1\" Ta \"MouseUp1\" Ta \"MouseDrag1\" Ta \"MouseDragEnd1\"\n.It Li \"MouseDown2\" Ta \"MouseUp2\" Ta \"MouseDrag2\" Ta \"MouseDragEnd2\"\n.It Li \"MouseDown3\" Ta \"MouseUp3\" Ta \"MouseDrag3\" Ta \"MouseDragEnd3\"\n.It Li \"SecondClick1\" Ta \"SecondClick2\" Ta \"SecondClick3\"\n.It Li \"DoubleClick1\" Ta \"DoubleClick2\" Ta \"DoubleClick3\"\n.It Li \"TripleClick1\" Ta \"TripleClick2\" Ta \"TripleClick3\"\n.El\n.Pp\nThe\n.Ql SecondClick\nevents are fired for the second click of a double click, even if there may be a\nthird click which will fire\n.Ql TripleClick\ninstead of\n.Ql DoubleClick .\n.Pp\nEach should be suffixed with a location, for example\n.Ql MouseDown1Status .\n.Pp\nThe special token\n.Ql {mouse}\nor\n.Ql =\nmay be used as\n.Ar target-window\nor\n.Ar target-pane\nin commands bound to mouse key bindings.\nIt resolves to the window or pane over which the mouse event took place\n(for example, the window in the status line over which button 1 was released\nfor a\n.Ql MouseUp1Status\nbinding, or the pane over which the wheel was scrolled for a\n.Ql WheelDownPane\nbinding).\n.Pp\nThe\n.Ic send-keys\n.Fl M\nflag may be used to forward a mouse event to a pane.\n.Pp\nThe default key bindings allow the mouse to be used to select and resize panes,\nto copy text and to change window using the status line.\nThese take effect if the\n.Ic mouse\noption is turned on.\n.Sh FORMATS\nCertain commands accept the\n.Fl F\nflag with a\n.Ar format\nargument.\nThis is a string which controls the output format of the command.\nFormat variables are enclosed in\n.Ql #{\nand\n.Ql } ,\nfor example\n.Ql #{session_name} .\nThe possible variables are listed in the table below, or the name of a\n.Nm\noption may be used for an option's value.\nSome variables have a shorter alias such as\n.Ql #S ;\n.Ql ##\nis replaced by a single\n.Ql # ,\n.Ql #,\nby a\n.Ql \\&,\nand\n.Ql #}\nby a\n.Ql } .\n.Pp\nConditionals are available by prefixing with\n.Ql \\&?\nand separating two alternatives with a comma;\nif the specified variable exists and is not zero, the first alternative\nis chosen, otherwise the second is used.\nFor example\n.Ql #{?session_attached,attached,not attached}\nwill include the string\n.Ql attached\nif the session is attached and the string\n.Ql not attached\nif it is unattached, or\n.Ql #{?automatic-rename,yes,no}\nwill include\n.Ql yes\nif\n.Ic automatic-rename\nis enabled, or\n.Ql no\nif not.\nConditionals can be nested arbitrarily.\nInside a conditional,\n.Ql \\&,\nand\n.Ql }\nmust be escaped as\n.Ql #,\nand\n.Ql #} ,\nunless they are part of a\n.Ql #{...}\nreplacement.\nFor example:\n.Bd -literal -offset indent\n#{?pane_in_mode,#[fg=white#,bg=red],#[fg=red#,bg=white]}#W .\n.Ed\n.Pp\nString comparisons may be expressed by prefixing two comma-separated\nalternatives by\n.Ql == ,\n.Ql != ,\n.Ql < ,\n.Ql > ,\n.Ql <=\nor\n.Ql >=\nand a colon.\nFor example\n.Ql #{==:#{host},myhost}\nwill be replaced by\n.Ql 1\nif running on\n.Ql myhost ,\notherwise by\n.Ql 0 .\n.Ql ||\nand\n.Ql &&\nevaluate to true if either or both of two comma-separated alternatives are\ntrue, for example\n.Ql #{||:#{pane_in_mode},#{alternate_on}} .\n.Pp\nAn\n.Ql m\nspecifies a\n.Xr glob 7\npattern or regular expression comparison.\nThe first argument is the pattern and the second the string to compare.\nAn optional argument specifies flags:\n.Ql r\nmeans the pattern is a regular expression instead of the default\n.Xr glob 7\npattern, and\n.Ql i\nmeans to ignore case.\nFor example:\n.Ql #{m:*foo*,#{host}}\nor\n.Ql #{m/ri:^A,MYVAR} .\nA\n.Ql C\nperforms a search for a\n.Xr glob 7\npattern or regular expression in the pane content and evaluates to zero if not\nfound, or a line number if found.\nLike\n.Ql m ,\nan\n.Ql r\nflag means search for a regular expression and\n.Ql i\nignores case.\nFor example:\n.Ql #{C/r:^Start}\n.Pp\nNumeric operators may be performed by prefixing two comma-separated alternatives\nwith an\n.Ql e\nand an operator.\nAn optional\n.Ql f\nflag may be given after the operator to use floating point numbers, otherwise\nintegers are used.\nThis may be followed by a number giving the number of decimal places to use for\nthe result.\nThe available operators are:\naddition\n.Ql + ,\nsubtraction\n.Ql - ,\nmultiplication\n.Ql * ,\ndivision\n.Ql / ,\nmodulus\n.Ql m\nor\n.Ql %\n(note that\n.Ql %\nmust be escaped as\n.Ql %%\nin formats which are also expanded by\n.Xr strftime 3 )\nand numeric comparison operators\n.Ql == ,\n.Ql != ,\n.Ql < ,\n.Ql <= ,\n.Ql >\nand\n.Ql >= .\nFor example,\n.Ql #{e|*|f|4:5.5,3}\nmultiplies 5.5 by 3 for a result with four decimal places and\n.Ql #{e|%%:7,3}\nreturns the modulus of 7 and 3.\n.Ql a\nreplaces a numeric argument by its ASCII equivalent, so\n.Ql #{a:98}\nresults in\n.Ql b .\n.Ql c\nreplaces a\n.Nm\ncolour by its six-digit hexadecimal RGB value.\n.Pp\nA limit may be placed on the length of the resultant string by prefixing it\nby an\n.Ql = ,\na number and a colon.\nPositive numbers count from the start of the string and negative from the end,\nso\n.Ql #{=5:pane_title}\nwill include at most the first five characters of the pane title, or\n.Ql #{=-5:pane_title}\nthe last five characters.\nA suffix or prefix may be given as a second argument - if provided then it is\nappended or prepended to the string if the length has been trimmed, for example\n.Ql #{=/5/...:pane_title}\nwill append\n.Ql ...\nif the pane title is more than five characters.\nSimilarly,\n.Ql p\npads the string to a given width, for example\n.Ql #{p10:pane_title}\nwill result in a width of at least 10 characters.\nA positive width pads on the left, a negative on the right.\n.Ql n\nexpands to the length of the variable and\n.Ql w\nto its width when displayed, for example\n.Ql #{n:window_name} .\n.Pp\nPrefixing a time variable with\n.Ql t:\\&\nwill convert it to a string, so if\n.Ql #{window_activity}\ngives\n.Ql 1445765102 ,\n.Ql #{t:window_activity}\ngives\n.Ql Sun Oct 25 09:25:02 2015 .\nAdding\n.Ql p (\n.Ql `t/p` )\nwill use shorter but less accurate time format for times in the past.\nA custom format may be given using an\n.Ql f\nsuffix (note that\n.Ql %\nmust be escaped as\n.Ql %%\nif the format is separately being passed through\n.Xr strftime 3 ,\nfor example in the\n.Ic status-left\noption):\n.Ql #{t/f/%%H#:%%M:window_activity} ,\nsee\n.Xr strftime 3 .\n.Pp\nThe\n.Ql b:\\&\nand\n.Ql d:\\&\nprefixes are\n.Xr basename 3\nand\n.Xr dirname 3\nof the variable respectively.\n.Ql q:\\&\nwill escape\n.Xr sh 1\nspecial characters or with a\n.Ql h\nsuffix, escape hash characters (so\n.Ql #\nbecomes\n.Ql ## ) .\n.Ql E:\\&\nwill expand the format twice, for example\n.Ql #{E:status-left}\nis the result of expanding the content of the\n.Ic status-left\noption rather than the option itself.\n.Ql T:\\&\nis like\n.Ql E:\\&\nbut also expands\n.Xr strftime 3\nspecifiers.\n.Ql S:\\& ,\n.Ql W:\\& ,\n.Ql P:\\&\nor\n.Ql L:\\&\nwill loop over each session, window, pane or client and insert the format once\nfor each.\nFor windows and panes, two comma-separated formats may be given:\nthe second is used for the current window or active pane.\nFor example, to get a list of windows formatted like the status line:\n.Bd -literal -offset indent\n#{W:#{E:window-status-format} ,#{E:window-status-current-format} }\n.Ed\n.Pp\n.Ql N:\\&\nchecks if a window (without any suffix or with the\n.Ql w\nsuffix) or a session (with the\n.Ql s\nsuffix) name exists, for example\n.Ql `N/w:foo`\nis replaced with 1 if a window named\n.Ql foo\nexists.\n.Pp\nA prefix of the form\n.Ql s/foo/bar/:\\&\nwill substitute\n.Ql foo\nwith\n.Ql bar\nthroughout.\nThe first argument may be an extended regular expression and a final argument\nmay be\n.Ql i\nto ignore case, for example\n.Ql s/a(.)/\\e1x/i:\\&\nwould change\n.Ql abABab\ninto\n.Ql bxBxbx .\nA different delimiter character may also be used, to avoid collisions with\nliteral slashes in the pattern.\nFor example,\n.Ql s|foo/|bar/|:\\&\nwill substitute\n.Ql foo/\nwith\n.Ql bar/\nthroughout.\n.Pp\nIn addition, the last line of a shell command's output may be inserted using\n.Ql #() .\nFor example,\n.Ql #(uptime)\nwill insert the system's uptime.\nWhen constructing formats,\n.Nm\ndoes not wait for\n.Ql #()\ncommands to finish; instead, the previous result from running the same command\nis used, or a placeholder if the command has not been run before.\nIf the command hasn't exited, the most recent line of output will be used, but\nthe status line will not be updated more than once a second.\nCommands are executed using\n.Pa /bin/sh\nand with the\n.Nm\nglobal environment set (see the\n.Sx GLOBAL AND SESSION ENVIRONMENT\nsection).\n.Pp\nAn\n.Ql l\nspecifies that a string should be interpreted literally and not expanded.\nFor example\n.Ql #{l:#{?pane_in_mode,yes,no}}\nwill be replaced by\n.Ql #{?pane_in_mode,yes,no} .\n.Pp\nThe following variables are available, where appropriate:\n.Bl -column \"XXXXXXXXXXXXXXXXXXX\" \"XXXXX\"\n.It Sy \"Variable name\" Ta Sy \"Alias\" Ta Sy \"Replaced with\"\n.It Li \"active_window_index\" Ta \"\" Ta \"Index of active window in session\"\n.It Li \"alternate_on\" Ta \"\" Ta \"1 if pane is in alternate screen\"\n.It Li \"alternate_saved_x\" Ta \"\" Ta \"Saved cursor X in alternate screen\"\n.It Li \"alternate_saved_y\" Ta \"\" Ta \"Saved cursor Y in alternate screen\"\n.It Li \"buffer_created\" Ta \"\" Ta \"Time buffer created\"\n.It Li \"buffer_name\" Ta \"\" Ta \"Name of buffer\"\n.It Li \"buffer_sample\" Ta \"\" Ta \"Sample of start of buffer\"\n.It Li \"buffer_size\" Ta \"\" Ta \"Size of the specified buffer in bytes\"\n.It Li \"client_activity\" Ta \"\" Ta \"Time client last had activity\"\n.It Li \"client_cell_height\" Ta \"\" Ta \"Height of each client cell in pixels\"\n.It Li \"client_cell_width\" Ta \"\" Ta \"Width of each client cell in pixels\"\n.It Li \"client_control_mode\" Ta \"\" Ta \"1 if client is in control mode\"\n.It Li \"client_created\" Ta \"\" Ta \"Time client created\"\n.It Li \"client_discarded\" Ta \"\" Ta \"Bytes discarded when client behind\"\n.It Li \"client_flags\" Ta \"\" Ta \"List of client flags\"\n.It Li \"client_height\" Ta \"\" Ta \"Height of client\"\n.It Li \"client_key_table\" Ta \"\" Ta \"Current key table\"\n.It Li \"client_last_session\" Ta \"\" Ta \"Name of the client's last session\"\n.It Li \"client_name\" Ta \"\" Ta \"Name of client\"\n.It Li \"client_pid\" Ta \"\" Ta \"PID of client process\"\n.It Li \"client_prefix\" Ta \"\" Ta \"1 if prefix key has been pressed\"\n.It Li \"client_readonly\" Ta \"\" Ta \"1 if client is read-only\"\n.It Li \"client_session\" Ta \"\" Ta \"Name of the client's session\"\n.It Li \"client_termfeatures\" Ta \"\" Ta \"Terminal features of client, if any\"\n.It Li \"client_termname\" Ta \"\" Ta \"Terminal name of client\"\n.It Li \"client_termtype\" Ta \"\" Ta \"Terminal type of client, if available\"\n.It Li \"client_tty\" Ta \"\" Ta \"Pseudo terminal of client\"\n.It Li \"client_uid\" Ta \"\" Ta \"UID of client process\"\n.It Li \"client_user\" Ta \"\" Ta \"User of client process\"\n.It Li \"client_utf8\" Ta \"\" Ta \"1 if client supports UTF-8\"\n.It Li \"client_width\" Ta \"\" Ta \"Width of client\"\n.It Li \"client_written\" Ta \"\" Ta \"Bytes written to client\"\n.It Li \"command\" Ta \"\" Ta \"Name of command in use, if any\"\n.It Li \"command_list_alias\" Ta \"\" Ta \"Command alias if listing commands\"\n.It Li \"command_list_name\" Ta \"\" Ta \"Command name if listing commands\"\n.It Li \"command_list_usage\" Ta \"\" Ta \"Command usage if listing commands\"\n.It Li \"config_files\" Ta \"\" Ta \"List of configuration files loaded\"\n.It Li \"copy_cursor_hyperlink\" Ta \"\" Ta \"Hyperlink under cursor in copy mode\"\n.It Li \"copy_cursor_line\" Ta \"\" Ta \"Line the cursor is on in copy mode\"\n.It Li \"copy_cursor_word\" Ta \"\" Ta \"Word under cursor in copy mode\"\n.It Li \"copy_cursor_x\" Ta \"\" Ta \"Cursor X position in copy mode\"\n.It Li \"copy_cursor_y\" Ta \"\" Ta \"Cursor Y position in copy mode\"\n.It Li \"current_file\" Ta \"\" Ta \"Current configuration file\"\n.It Li \"cursor_character\" Ta \"\" Ta \"Character at cursor in pane\"\n.It Li \"cursor_flag\" Ta \"\" Ta \"Pane cursor flag\"\n.It Li \"cursor_x\" Ta \"\" Ta \"Cursor X position in pane\"\n.It Li \"cursor_y\" Ta \"\" Ta \"Cursor Y position in pane\"\n.It Li \"history_bytes\" Ta \"\" Ta \"Number of bytes in window history\"\n.It Li \"history_limit\" Ta \"\" Ta \"Maximum window history lines\"\n.It Li \"history_size\" Ta \"\" Ta \"Size of history in lines\"\n.It Li \"hook\" Ta \"\" Ta \"Name of running hook, if any\"\n.It Li \"hook_client\" Ta \"\" Ta \"Name of client where hook was run, if any\"\n.It Li \"hook_pane\" Ta \"\" Ta \"ID of pane where hook was run, if any\"\n.It Li \"hook_session\" Ta \"\" Ta \"ID of session where hook was run, if any\"\n.It Li \"hook_session_name\" Ta \"\" Ta \"Name of session where hook was run, if any\"\n.It Li \"hook_window\" Ta \"\" Ta \"ID of window where hook was run, if any\"\n.It Li \"hook_window_name\" Ta \"\" Ta \"Name of window where hook was run, if any\"\n.It Li \"host\" Ta \"#H\" Ta \"Hostname of local host\"\n.It Li \"host_short\" Ta \"#h\" Ta \"Hostname of local host (no domain name)\"\n.It Li \"insert_flag\" Ta \"\" Ta \"Pane insert flag\"\n.It Li \"keypad_cursor_flag\" Ta \"\" Ta \"Pane keypad cursor flag\"\n.It Li \"keypad_flag\" Ta \"\" Ta \"Pane keypad flag\"\n.It Li \"last_window_index\" Ta \"\" Ta \"Index of last window in session\"\n.It Li \"line\" Ta \"\" Ta \"Line number in the list\"\n.It Li \"mouse_all_flag\" Ta \"\" Ta \"Pane mouse all flag\"\n.It Li \"mouse_any_flag\" Ta \"\" Ta \"Pane mouse any flag\"\n.It Li \"mouse_button_flag\" Ta \"\" Ta \"Pane mouse button flag\"\n.It Li \"mouse_hyperlink\" Ta \"\" Ta \"Hyperlink under mouse, if any\"\n.It Li \"mouse_line\" Ta \"\" Ta \"Line under mouse, if any\"\n.It Li \"mouse_sgr_flag\" Ta \"\" Ta \"Pane mouse SGR flag\"\n.It Li \"mouse_standard_flag\" Ta \"\" Ta \"Pane mouse standard flag\"\n.It Li \"mouse_status_line\" Ta \"\" Ta \"Status line on which mouse event took place\"\n.It Li \"mouse_status_range\" Ta \"\" Ta \"Range type or argument of mouse event on status line\"\n.It Li \"mouse_utf8_flag\" Ta \"\" Ta \"Pane mouse UTF-8 flag\"\n.It Li \"mouse_word\" Ta \"\" Ta \"Word under mouse, if any\"\n.It Li \"mouse_x\" Ta \"\" Ta \"Mouse X position, if any\"\n.It Li \"mouse_y\" Ta \"\" Ta \"Mouse Y position, if any\"\n.It Li \"next_session_id\" Ta \"\" Ta \"Unique session ID for next new session\"\n.It Li \"origin_flag\" Ta \"\" Ta \"Pane origin flag\"\n.It Li \"pane_active\" Ta \"\" Ta \"1 if active pane\"\n.It Li \"pane_at_bottom\" Ta \"\" Ta \"1 if pane is at the bottom of window\"\n.It Li \"pane_at_left\" Ta \"\" Ta \"1 if pane is at the left of window\"\n.It Li \"pane_at_right\" Ta \"\" Ta \"1 if pane is at the right of window\"\n.It Li \"pane_at_top\" Ta \"\" Ta \"1 if pane is at the top of window\"\n.It Li \"pane_bg\" Ta \"\" Ta \"Pane background colour\"\n.It Li \"pane_bottom\" Ta \"\" Ta \"Bottom of pane\"\n.It Li \"pane_current_command\" Ta \"\" Ta \"Current command if available\"\n.It Li \"pane_current_path\" Ta \"\" Ta \"Current path if available\"\n.It Li \"pane_dead\" Ta \"\" Ta \"1 if pane is dead\"\n.It Li \"pane_dead_signal\" Ta \"\" Ta \"Exit signal of process in dead pane\"\n.It Li \"pane_dead_status\" Ta \"\" Ta \"Exit status of process in dead pane\"\n.It Li \"pane_dead_time\" Ta \"\" Ta \"Exit time of process in dead pane\"\n.It Li \"pane_fg\" Ta \"\" Ta \"Pane foreground colour\"\n.It Li \"pane_format\" Ta \"\" Ta \"1 if format is for a pane\"\n.It Li \"pane_height\" Ta \"\" Ta \"Height of pane\"\n.It Li \"pane_id\" Ta \"#D\" Ta \"Unique pane ID\"\n.It Li \"pane_in_mode\" Ta \"\" Ta \"1 if pane is in a mode\"\n.It Li \"pane_index\" Ta \"#P\" Ta \"Index of pane\"\n.It Li \"pane_input_off\" Ta \"\" Ta \"1 if input to pane is disabled\"\n.It Li \"pane_key_mode\" Ta \"\" Ta \"Extended key reporting mode in this pane\"\n.It Li \"pane_last\" Ta \"\" Ta \"1 if last pane\"\n.It Li \"pane_left\" Ta \"\" Ta \"Left of pane\"\n.It Li \"pane_marked\" Ta \"\" Ta \"1 if this is the marked pane\"\n.It Li \"pane_marked_set\" Ta \"\" Ta \"1 if a marked pane is set\"\n.It Li \"pane_mode\" Ta \"\" Ta \"Name of pane mode, if any\"\n.It Li \"pane_path\" Ta \"\" Ta \"Path of pane (can be set by application)\"\n.It Li \"pane_pid\" Ta \"\" Ta \"PID of first process in pane\"\n.It Li \"pane_pipe\" Ta \"\" Ta \"1 if pane is being piped\"\n.It Li \"pane_right\" Ta \"\" Ta \"Right of pane\"\n.It Li \"pane_search_string\" Ta \"\" Ta \"Last search string in copy mode\"\n.It Li \"pane_start_command\" Ta \"\" Ta \"Command pane started with\"\n.It Li \"pane_start_path\" Ta \"\" Ta \"Path pane started with\"\n.It Li \"pane_synchronized\" Ta \"\" Ta \"1 if pane is synchronized\"\n.It Li \"pane_tabs\" Ta \"\" Ta \"Pane tab positions\"\n.It Li \"pane_title\" Ta \"#T\" Ta \"Title of pane (can be set by application)\"\n.It Li \"pane_top\" Ta \"\" Ta \"Top of pane\"\n.It Li \"pane_tty\" Ta \"\" Ta \"Pseudo terminal of pane\"\n.It Li \"pane_unseen_changes\" Ta \"\" Ta \"1 if there were changes in pane while in mode\"\n.It Li \"pane_width\" Ta \"\" Ta \"Width of pane\"\n.It Li \"pid\" Ta \"\" Ta \"Server PID\"\n.It Li \"rectangle_toggle\" Ta \"\" Ta \"1 if rectangle selection is activated\"\n.It Li \"scroll_position\" Ta \"\" Ta \"Scroll position in copy mode\"\n.It Li \"scroll_region_lower\" Ta \"\" Ta \"Bottom of scroll region in pane\"\n.It Li \"scroll_region_upper\" Ta \"\" Ta \"Top of scroll region in pane\"\n.It Li \"search_count\" Ta \"\" Ta \"Count of search results\"\n.It Li \"search_count_partial\" Ta \"\" Ta \"1 if search count is partial count\"\n.It Li \"search_match\" Ta \"\" Ta \"Search match if any\"\n.It Li \"search_present\" Ta \"\" Ta \"1 if search started in copy mode\"\n.It Li \"selection_active\" Ta \"\" Ta \"1 if selection started and changes with the cursor in copy mode\"\n.It Li \"selection_end_x\" Ta \"\" Ta \"X position of the end of the selection\"\n.It Li \"selection_end_y\" Ta \"\" Ta \"Y position of the end of the selection\"\n.It Li \"selection_present\" Ta \"\" Ta \"1 if selection started in copy mode\"\n.It Li \"selection_start_x\" Ta \"\" Ta \"X position of the start of the selection\"\n.It Li \"selection_start_y\" Ta \"\" Ta \"Y position of the start of the selection\"\n.It Li \"server_sessions\" Ta \"\" Ta \"Number of sessions\"\n.It Li \"session_activity\" Ta \"\" Ta \"Time of session last activity\"\n.It Li \"session_alerts\" Ta \"\" Ta \"List of window indexes with alerts\"\n.It Li \"session_attached\" Ta \"\" Ta \"Number of clients session is attached to\"\n.It Li \"session_attached_list\" Ta \"\" Ta \"List of clients session is attached to\"\n.It Li \"session_created\" Ta \"\" Ta \"Time session created\"\n.It Li \"session_format\" Ta \"\" Ta \"1 if format is for a session\"\n.It Li \"session_group\" Ta \"\" Ta \"Name of session group\"\n.It Li \"session_group_attached\" Ta \"\" Ta \"Number of clients sessions in group are attached to\"\n.It Li \"session_group_attached_list\" Ta \"\" Ta \"List of clients sessions in group are attached to\"\n.It Li \"session_group_list\" Ta \"\" Ta \"List of sessions in group\"\n.It Li \"session_group_many_attached\" Ta \"\" Ta \"1 if multiple clients attached to sessions in group\"\n.It Li \"session_group_size\" Ta \"\" Ta \"Size of session group\"\n.It Li \"session_grouped\" Ta \"\" Ta \"1 if session in a group\"\n.It Li \"session_id\" Ta \"\" Ta \"Unique session ID\"\n.It Li \"session_last_attached\" Ta \"\" Ta \"Time session last attached\"\n.It Li \"session_many_attached\" Ta \"\" Ta \"1 if multiple clients attached\"\n.It Li \"session_marked\" Ta \"\" Ta \"1 if this session contains the marked pane\"\n.It Li \"session_name\" Ta \"#S\" Ta \"Name of session\"\n.It Li \"session_path\" Ta \"\" Ta \"Working directory of session\"\n.It Li \"session_stack\" Ta \"\" Ta \"Window indexes in most recent order\"\n.It Li \"session_windows\" Ta \"\" Ta \"Number of windows in session\"\n.It Li \"socket_path\" Ta \"\" Ta \"Server socket path\"\n.It Li \"sixel_support\" Ta \"\" Ta \"1 if server has support for SIXEL\"\n.It Li \"start_time\" Ta \"\" Ta \"Server start time\"\n.It Li \"uid\" Ta \"\" Ta \"Server UID\"\n.It Li \"user\" Ta \"\" Ta \"Server user\"\n.It Li \"version\" Ta \"\" Ta \"Server version\"\n.It Li \"window_active\" Ta \"\" Ta \"1 if window active\"\n.It Li \"window_active_clients\" Ta \"\" Ta \"Number of clients viewing this window\"\n.It Li \"window_active_clients_list\" Ta \"\" Ta \"List of clients viewing this window\"\n.It Li \"window_active_sessions\" Ta \"\" Ta \"Number of sessions on which this window is active\"\n.It Li \"window_active_sessions_list\" Ta \"\" Ta \"List of sessions on which this window is active\"\n.It Li \"window_activity\" Ta \"\" Ta \"Time of window last activity\"\n.It Li \"window_activity_flag\" Ta \"\" Ta \"1 if window has activity\"\n.It Li \"window_bell_flag\" Ta \"\" Ta \"1 if window has bell\"\n.It Li \"window_bigger\" Ta \"\" Ta \"1 if window is larger than client\"\n.It Li \"window_cell_height\" Ta \"\" Ta \"Height of each cell in pixels\"\n.It Li \"window_cell_width\" Ta \"\" Ta \"Width of each cell in pixels\"\n.It Li \"window_end_flag\" Ta \"\" Ta \"1 if window has the highest index\"\n.It Li \"window_flags\" Ta \"#F\" Ta \"Window flags with # escaped as ##\"\n.It Li \"window_format\" Ta \"\" Ta \"1 if format is for a window\"\n.It Li \"window_height\" Ta \"\" Ta \"Height of window\"\n.It Li \"window_id\" Ta \"\" Ta \"Unique window ID\"\n.It Li \"window_index\" Ta \"#I\" Ta \"Index of window\"\n.It Li \"window_last_flag\" Ta \"\" Ta \"1 if window is the last used\"\n.It Li \"window_layout\" Ta \"\" Ta \"Window layout description, ignoring zoomed window panes\"\n.It Li \"window_linked\" Ta \"\" Ta \"1 if window is linked across sessions\"\n.It Li \"window_linked_sessions\" Ta \"\" Ta \"Number of sessions this window is linked to\"\n.It Li \"window_linked_sessions_list\" Ta \"\" Ta \"List of sessions this window is linked to\"\n.It Li \"window_marked_flag\" Ta \"\" Ta \"1 if window contains the marked pane\"\n.It Li \"window_name\" Ta \"#W\" Ta \"Name of window\"\n.It Li \"window_offset_x\" Ta \"\" Ta \"X offset into window if larger than client\"\n.It Li \"window_offset_y\" Ta \"\" Ta \"Y offset into window if larger than client\"\n.It Li \"window_panes\" Ta \"\" Ta \"Number of panes in window\"\n.It Li \"window_raw_flags\" Ta \"\" Ta \"Window flags with nothing escaped\"\n.It Li \"window_silence_flag\" Ta \"\" Ta \"1 if window has silence alert\"\n.It Li \"window_stack_index\" Ta \"\" Ta \"Index in session most recent stack\"\n.It Li \"window_start_flag\" Ta \"\" Ta \"1 if window has the lowest index\"\n.It Li \"window_visible_layout\" Ta \"\" Ta \"Window layout description, respecting zoomed window panes\"\n.It Li \"window_width\" Ta \"\" Ta \"Width of window\"\n.It Li \"window_zoomed_flag\" Ta \"\" Ta \"1 if window is zoomed\"\n.It Li \"wrap_flag\" Ta \"\" Ta \"Pane wrap flag\"\n.El\n.Sh STYLES\n.Nm\noffers various options to specify the colour and attributes of aspects of the\ninterface, for example\n.Ic status-style\nfor the status line.\nIn addition, embedded styles may be specified in format options, such as\n.Ic status-left ,\nby enclosing them in\n.Ql #[\nand\n.Ql \\&] .\n.Pp\nA style may be the single term\n.Ql default\nto specify the default style (which may come from an option, for example\n.Ic status-style\nin the status line) or a space\nor comma separated list of the following:\n.Bl -tag -width Ds\n.It Ic fg=colour\nSet the foreground colour.\nThe colour is one of:\n.Ic black ,\n.Ic red ,\n.Ic green ,\n.Ic yellow ,\n.Ic blue ,\n.Ic magenta ,\n.Ic cyan ,\n.Ic white ;\nif supported the bright variants\n.Ic brightred ,\n.Ic brightgreen ,\n.Ic brightyellow ;\n.Ic colour0\nto\n.Ic colour255\nfrom the 256-colour set;\n.Ic default\nfor the default colour;\n.Ic terminal\nfor the terminal default colour; or a hexadecimal RGB string such as\n.Ql #ffffff .\n.It Ic bg=colour\nSet the background colour.\n.It Ic us=colour\nSet the underscore colour.\n.It Ic none\nSet no attributes (turn off any active attributes).\n.It Xo Ic acs ,\n.Ic bright\n(or\n.Ic bold ) ,\n.Ic dim ,\n.Ic underscore ,\n.Ic blink ,\n.Ic reverse ,\n.Ic hidden ,\n.Ic italics ,\n.Ic overline ,\n.Ic strikethrough ,\n.Ic double-underscore ,\n.Ic curly-underscore ,\n.Ic dotted-underscore ,\n.Ic dashed-underscore\n.Xc\nSet an attribute.\nAny of the attributes may be prefixed with\n.Ql no\nto unset.\n.Ic acs\nis the terminal alternate character set.\n.It Xo Ic align=left\n(or\n.Ic noalign ) ,\n.Ic align=centre ,\n.Ic align=right\n.Xc\nAlign text to the left, centre or right of the available space if appropriate.\n.It Ic fill=colour\nFill the available space with a background colour if appropriate.\n.It Xo Ic list=on ,\n.Ic list=focus ,\n.Ic list=left-marker ,\n.Ic list=right-marker ,\n.Ic nolist\n.Xc\nMark the position of the various window list components in the\n.Ic status-format\noption:\n.Ic list=on\nmarks the start of the list;\n.Ic list=focus\nis the part of the list that should be kept in focus if the entire list won't\nfit in the available space (typically the current window);\n.Ic list=left-marker\nand\n.Ic list=right-marker\nmark the text to be used to mark that text has been trimmed from the left or\nright of the list if there is not enough space.\n.It Xo Ic push-default ,\n.Ic pop-default\n.Xc\nStore the current colours and attributes as the default or reset to the previous\ndefault.\nA\n.Ic push-default\naffects any subsequent use of the\n.Ic default\nterm until a\n.Ic pop-default .\nOnly one default may be pushed (each\n.Ic push-default\nreplaces the previous saved default).\n.It Xo Ic range=left ,\n.Ic range=right ,\n.Ic range=session|X ,\n.Ic range=window|X ,\n.Ic range=pane|X ,\n.Ic range=user|X ,\n.Ic norange\n.Xc\nMark a range for mouse events in the\n.Ic status-format\noption.\nWhen a mouse event occurs in the\n.Ic range=left\nor\n.Ic range=right\nrange, the\n.Ql StatusLeft\nand\n.Ql StatusRight\nkey bindings are triggered.\n.Pp\n.Ic range=session|X ,\n.Ic range=window|X\nand\n.Ic range=pane|X\nare ranges for a session, window or pane.\nThese trigger the\n.Ql Status\nmouse key with the target session, window or pane given by the\n.Ql X\nargument.\n.Ql X\nis a session ID, window index in the current session or a pane ID.\nFor these, the\n.Ic mouse_status_range\nformat variable will be set to\n.Ql session ,\n.Ql window\nor\n.Ql pane .\n.Pp\n.Ic range=user|X\nis a user-defined range; it triggers the\n.Ql Status\nmouse key.\nThe argument\n.Ql X\nwill be available in the\n.Ic mouse_status_range\nformat variable.\n.Ql X\nmust be at most 15 bytes in length.\n.El\n.Pp\nExamples are:\n.Bd -literal -offset indent\nfg=yellow bold underscore blink\nbg=black,fg=default,noreverse\n.Ed\n.Sh NAMES AND TITLES\n.Nm\ndistinguishes between names and titles.\nWindows and sessions have names, which may be used to specify them in targets\nand are displayed in the status line and various lists: the name is the\n.Nm\nidentifier for a window or session.\nOnly panes have titles.\nA pane's title is typically set by the program running inside the pane using\nan escape sequence (like it would set the\n.Xr xterm 1\nwindow title in\n.Xr X 7 ) .\nWindows themselves do not have titles - a window's title is the title of its\nactive pane.\n.Nm\nitself may set the title of the terminal in which the client is running, see\nthe\n.Ic set-titles\noption.\n.Pp\nA session's name is set with the\n.Ic new-session\nand\n.Ic rename-session\ncommands.\nA window's name is set with one of:\n.Bl -enum -width Ds\n.It\nA command argument (such as\n.Fl n\nfor\n.Ic new-window\nor\n.Ic new-session ) .\n.It\nAn escape sequence (if the\n.Ic allow-rename\noption is turned on):\n.Bd -literal -offset indent\n$ printf \\[aq]\\e033kWINDOW_NAME\\e033\\e\\e\\[aq]\n.Ed\n.It\nAutomatic renaming, which sets the name to the active command in the window's\nactive pane.\nSee the\n.Ic automatic-rename\noption.\n.El\n.Pp\nWhen a pane is first created, its title is the hostname.\nA pane's title can be set via the title setting escape sequence, for example:\n.Bd -literal -offset indent\n$ printf \\[aq]\\e033]2;My Title\\e033\\e\\e\\[aq]\n.Ed\n.Pp\nIt can also be modified with the\n.Ic select-pane\n.Fl T\ncommand.\n.Sh GLOBAL AND SESSION ENVIRONMENT\nWhen the server is started,\n.Nm\ncopies the environment into the\n.Em global environment ;\nin addition, each session has a\n.Em session environment .\nWhen a window is created, the session and global environments are merged.\nIf a variable exists in both, the value from the session environment is used.\nThe result is the initial environment passed to the new process.\n.Pp\nThe\n.Ic update-environment\nsession option may be used to update the session environment from the client\nwhen a new session is created or an old reattached.\n.Nm\nalso initialises the\n.Ev TMUX\nvariable with some internal information to allow commands to be executed\nfrom inside, and the\n.Ev TERM\nvariable with the correct terminal setting of\n.Ql screen .\n.Pp\nVariables in both session and global environments may be marked as hidden.\nHidden variables are not passed into the environment of new processes and\ninstead can only be used by tmux itself (for example in formats, see the\n.Sx FORMATS\nsection).\n.Pp\nCommands to alter and view the environment are:\n.Bl -tag -width Ds\n.Tg setenv\n.It Xo Ic set-environment\n.Op Fl Fhgru\n.Op Fl t Ar target-session\n.Ar name Op Ar value\n.Xc\n.D1 Pq alias: Ic setenv\nSet or unset an environment variable.\nIf\n.Fl g\nis used, the change is made in the global environment; otherwise, it is applied\nto the session environment for\n.Ar target-session .\nIf\n.Fl F\nis present, then\n.Ar value\nis expanded as a format.\nThe\n.Fl u\nflag unsets a variable.\n.Fl r\nindicates the variable is to be removed from the environment before starting a\nnew process.\n.Fl h\nmarks the variable as hidden.\n.Tg showenv\n.It Xo Ic show-environment\n.Op Fl hgs\n.Op Fl t Ar target-session\n.Op Ar variable\n.Xc\n.D1 Pq alias: Ic showenv\nDisplay the environment for\n.Ar target-session\nor the global environment with\n.Fl g .\nIf\n.Ar variable\nis omitted, all variables are shown.\nVariables removed from the environment are prefixed with\n.Ql - .\nIf\n.Fl s\nis used, the output is formatted as a set of Bourne shell commands.\n.Fl h\nshows hidden variables (omitted by default).\n.El\n.Sh STATUS LINE\n.Nm\nincludes an optional status line which is displayed in the bottom line of each\nterminal.\n.Pp\nBy default, the status line is enabled and one line in height (it may be\ndisabled or made multiple lines with the\n.Ic status\nsession option) and contains, from left-to-right: the name of the current\nsession in square brackets; the window list; the title of the active pane\nin double quotes; and the time and date.\n.Pp\nEach line of the status line is configured with the\n.Ic status-format\noption.\nThe default is made of three parts: configurable left and right sections (which\nmay contain dynamic content such as the time or output from a shell command,\nsee the\n.Ic status-left ,\n.Ic status-left-length ,\n.Ic status-right ,\nand\n.Ic status-right-length\noptions below), and a central window list.\nBy default, the window list shows the index, name and (if any) flag of the\nwindows present in the current session in ascending numerical order.\nIt may be customised with the\n.Ar window-status-format\nand\n.Ar window-status-current-format\noptions.\nThe flag is one of the following symbols appended to the window name:\n.Bl -column \"Symbol\" \"Meaning\" -offset indent\n.It Sy \"Symbol\" Ta Sy \"Meaning\"\n.It Li \"*\" Ta \"Denotes the current window.\"\n.It Li \"-\" Ta \"Marks the last window (previously selected).\"\n.It Li \"#\" Ta \"Window activity is monitored and activity has been detected.\"\n.It Li \"\\&!\" Ta \"Window bells are monitored and a bell has occurred in the window.\"\n.It Li \"\\[ti]\" Ta \"The window has been silent for the monitor-silence interval.\"\n.It Li \"M\" Ta \"The window contains the marked pane.\"\n.It Li \"Z\" Ta \"The window's active pane is zoomed.\"\n.El\n.Pp\nThe # symbol relates to the\n.Ic monitor-activity\nwindow option.\nThe window name is printed in inverted colours if an alert (bell, activity or\nsilence) is present.\n.Pp\nThe colour and attributes of the status line may be configured, the entire\nstatus line using the\n.Ic status-style\nsession option and individual windows using the\n.Ic window-status-style\nwindow option.\n.Pp\nThe status line is automatically refreshed at interval if it has changed, the\ninterval may be controlled with the\n.Ic status-interval\nsession option.\n.Pp\nCommands related to the status line are as follows:\n.Bl -tag -width Ds\n.Tg clearphist\n.It Xo Ic clear-prompt-history\n.Op Fl T Ar prompt-type\n.Xc\n.D1 Pq alias: Ic clearphist\nClear status prompt history for prompt type\n.Ar prompt-type .\nIf\n.Fl T\nis omitted, then clear history for all types.\nSee\n.Ic command-prompt\nfor possible values for\n.Ar prompt-type .\n.It Xo Ic command-prompt\n.Op Fl 1bFikN\n.Op Fl I Ar inputs\n.Op Fl p Ar prompts\n.Op Fl t Ar target-client\n.Op Fl T Ar prompt-type\n.Op Ar template\n.Xc\nOpen the command prompt in a client.\nThis may be used from inside\n.Nm\nto execute commands interactively.\n.Pp\nIf\n.Ar template\nis specified, it is used as the command.\nWith\n.Fl F ,\n.Ar template\nis expanded as a format.\n.Pp\nIf present,\n.Fl I\nis a comma-separated list of the initial text for each prompt.\nIf\n.Fl p\nis given,\n.Ar prompts\nis a comma-separated list of prompts which are displayed in order; otherwise\na single prompt is displayed, constructed from\n.Ar template\nif it is present, or\n.Ql \\&:\nif not.\n.Pp\nBefore the command is executed, the first occurrence of the string\n.Ql %%\nand all occurrences of\n.Ql %1\nare replaced by the response to the first prompt, all\n.Ql %2\nare replaced with the response to the second prompt, and so on for further\nprompts.\nUp to nine prompt responses may be replaced\n.Po\n.Ql %1\nto\n.Ql %9\n.Pc .\n.Ql %%%\nis like\n.Ql %%\nbut any quotation marks are escaped.\n.Pp\n.Fl 1\nmakes the prompt only accept one key press, in this case the resulting input\nis a single character.\n.Fl k\nis like\n.Fl 1\nbut the key press is translated to a key name.\n.Fl N\nmakes the prompt only accept numeric key presses.\n.Fl i\nexecutes the command every time the prompt input changes instead of when the\nuser exits the command prompt.\n.Pp\n.Fl T\ntells\n.Nm\nthe prompt type.\nThis affects what completions are offered when\n.Em Tab\nis pressed.\nAvailable types are:\n.Ql command ,\n.Ql search ,\n.Ql target\nand\n.Ql window-target .\n.Pp\nThe following keys have a special meaning in the command prompt, depending\non the value of the\n.Ic status-keys\noption:\n.Bl -column \"FunctionXXXXXXXXXXXXXXXXXXXXXXXXX\" \"viXXXX\" \"emacsX\" -offset indent\n.It Sy \"Function\" Ta Sy \"vi\" Ta Sy \"emacs\"\n.It Li \"Cancel command prompt\" Ta \"q\" Ta \"Escape\"\n.It Li \"Delete from cursor to start of word\" Ta \"\" Ta \"C-w\"\n.It Li \"Delete entire command\" Ta \"d\" Ta \"C-u\"\n.It Li \"Delete from cursor to end\" Ta \"D\" Ta \"C-k\"\n.It Li \"Execute command\" Ta \"Enter\" Ta \"Enter\"\n.It Li \"Get next command from history\" Ta \"\" Ta \"Down\"\n.It Li \"Get previous command from history\" Ta \"\" Ta \"Up\"\n.It Li \"Insert top paste buffer\" Ta \"p\" Ta \"C-y\"\n.It Li \"Look for completions\" Ta \"Tab\" Ta \"Tab\"\n.It Li \"Move cursor left\" Ta \"h\" Ta \"Left\"\n.It Li \"Move cursor right\" Ta \"l\" Ta \"Right\"\n.It Li \"Move cursor to end\" Ta \"$\" Ta \"C-e\"\n.It Li \"Move cursor to next word\" Ta \"w\" Ta \"M-f\"\n.It Li \"Move cursor to previous word\" Ta \"b\" Ta \"M-b\"\n.It Li \"Move cursor to start\" Ta \"0\" Ta \"C-a\"\n.It Li \"Transpose characters\" Ta \"\" Ta \"C-t\"\n.El\n.Pp\nWith\n.Fl b ,\nthe prompt is shown in the background and the invoking client does not exit\nuntil it is dismissed.\n.Tg confirm\n.It Xo Ic confirm-before\n.Op Fl by\n.Op Fl c Ar confirm-key\n.Op Fl p Ar prompt\n.Op Fl t Ar target-client\n.Ar command\n.Xc\n.D1 Pq alias: Ic confirm\nAsk for confirmation before executing\n.Ar command .\nIf\n.Fl p\nis given,\n.Ar prompt\nis the prompt to display; otherwise a prompt is constructed from\n.Ar command .\nIt may contain the special character sequences supported by the\n.Ic status-left\noption.\nWith\n.Fl b ,\nthe prompt is shown in the background and the invoking client does not exit\nuntil it is dismissed.\n.Fl y\nchanges the default behaviour (if Enter alone is pressed) of the prompt to\nrun the command.\n.Fl c\nchanges the confirmation key to\n.Ar confirm-key ;\nthe default is\n.Ql y .\n.Tg menu\n.It Xo Ic display-menu\n.Op Fl OM\n.Op Fl b Ar border-lines\n.Op Fl c Ar target-client\n.Op Fl C Ar starting-choice\n.Op Fl H Ar selected-style\n.Op Fl s Ar style\n.Op Fl S Ar border-style\n.Op Fl t Ar target-pane\n.Op Fl T Ar title\n.Op Fl x Ar position\n.Op Fl y Ar position\n.Ar name\n.Ar key\n.Ar command Op Ar argument ...\n.Xc\n.D1 Pq alias: Ic menu\nDisplay a menu on\n.Ar target-client .\n.Ar target-pane\ngives the target for any commands run from the menu.\n.Pp\nA menu is passed as a series of arguments: first the menu item name,\nsecond the key shortcut (or empty for none) and third the command\nto run when the menu item is chosen.\nThe name and command are formats, see the\n.Sx FORMATS\nand\n.Sx STYLES\nsections.\nIf the name begins with a hyphen (-), then the item is disabled (shown dim) and\nmay not be chosen.\nThe name may be empty for a separator line, in which case both the key and\ncommand should be omitted.\n.Pp\n.Fl b\nsets the type of characters used for drawing menu borders.\nSee\n.Ic popup-border-lines\nfor possible values for\n.Ar border-lines .\n.Pp\n.Fl H\nsets the style for the selected menu item (see\n.Sx STYLES ) .\n.Pp\n.Fl s\nsets the style for the menu and\n.Fl S\nsets the style for the menu border (see\n.Sx STYLES ) .\n.Pp\n.Fl T\nis a format for the menu title (see\n.Sx FORMATS ) .\n.Pp\n.Fl C\nsets the menu item selected by default, if the menu is not bound to a mouse key\nbinding.\n.Pp\n.Fl x\nand\n.Fl y\ngive the position of the menu.\nBoth may be a row or column number, or one of the following special values:\n.Bl -column \"XXXXX\" \"XXXX\" -offset indent\n.It Sy \"Value\" Ta Sy \"Flag\" Ta Sy \"Meaning\"\n.It Li \"C\" Ta \"Both\" Ta \"The centre of the terminal\"\n.It Li \"R\" Ta Fl x Ta \"The right side of the terminal\"\n.It Li \"P\" Ta \"Both\" Ta \"The bottom left of the pane\"\n.It Li \"M\" Ta \"Both\" Ta \"The mouse position\"\n.It Li \"W\" Ta \"Both\" Ta \"The window position on the status line\"\n.It Li \"S\" Ta Fl y Ta \"The line above or below the status line\"\n.El\n.Pp\nOr a format, which is expanded including the following additional variables:\n.Bl -column \"XXXXXXXXXXXXXXXXXXXXXXXXXX\" -offset indent\n.It Sy \"Variable name\" Ta Sy \"Replaced with\"\n.It Li \"popup_centre_x\" Ta \"Centered in the client\"\n.It Li \"popup_centre_y\" Ta \"Centered in the client\"\n.It Li \"popup_height\" Ta \"Height of menu or popup\"\n.It Li \"popup_mouse_bottom\" Ta \"Bottom of at the mouse\"\n.It Li \"popup_mouse_centre_x\" Ta \"Horizontal centre at the mouse\"\n.It Li \"popup_mouse_centre_y\" Ta \"Vertical centre at the mouse\"\n.It Li \"popup_mouse_top\" Ta \"Top at the mouse\"\n.It Li \"popup_mouse_x\" Ta \"Mouse X position\"\n.It Li \"popup_mouse_y\" Ta \"Mouse Y position\"\n.It Li \"popup_pane_bottom\" Ta \"Bottom of the pane\"\n.It Li \"popup_pane_left\" Ta \"Left of the pane\"\n.It Li \"popup_pane_right\" Ta \"Right of the pane\"\n.It Li \"popup_pane_top\" Ta \"Top of the pane\"\n.It Li \"popup_status_line_y\" Ta \"Above or below the status line\"\n.It Li \"popup_width\" Ta \"Width of menu or popup\"\n.It Li \"popup_window_status_line_x\" Ta \"At the window position in status line\"\n.It Li \"popup_window_status_line_y\" Ta \"At the status line showing the window\"\n.El\n.Pp\nEach menu consists of items followed by a key shortcut shown in brackets.\nIf the menu is too large to fit on the terminal, it is not displayed.\nPressing the key shortcut chooses the corresponding item.\nIf the mouse is enabled and the menu is opened from a mouse key binding,\nreleasing the mouse button with an item selected chooses that item and\nreleasing the mouse button without an item selected closes the menu.\n.Fl O\nchanges this behaviour so that the menu does not close when the mouse button is\nreleased without an item selected the menu is not closed and a mouse button\nmust be clicked to choose an item.\n.Pp\n.Fl M\ntells\n.Nm\nthe menu should handle mouse events; by default only menus opened from mouse\nkey bindings do so.\n.Pp\nThe following keys are available in menus:\n.Bl -column \"Key\" \"Function\" -offset indent\n.It Sy \"Key\" Ta Sy \"Function\"\n.It Li \"Enter\" Ta \"Choose selected item\"\n.It Li \"Up\" Ta \"Select previous item\"\n.It Li \"Down\" Ta \"Select next item\"\n.It Li \"q\" Ta \"Exit menu\"\n.El\n.Tg display\n.It Xo Ic display-message\n.Op Fl aIlNpv\n.Op Fl c Ar target-client\n.Op Fl d Ar delay\n.Op Fl t Ar target-pane\n.Op Ar message\n.Xc\n.D1 Pq alias: Ic display\nDisplay a message.\nIf\n.Fl p\nis given, the output is printed to stdout, otherwise it is displayed in the\n.Ar target-client\nstatus line for up to\n.Ar delay\nmilliseconds.\nIf\n.Ar delay\nis not given, the\n.Ic display-time\noption is used; a delay of zero waits for a key press.\n.Ql N\nignores key presses and closes only after the delay expires.\nIf\n.Fl l\nis given,\n.Ar message\nis printed unchanged.\nOtherwise, the format of\n.Ar message\nis described in the\n.Sx FORMATS\nsection; information is taken from\n.Ar target-pane\nif\n.Fl t\nis given, otherwise the active pane.\n.Pp\n.Fl v\nprints verbose logging as the format is parsed and\n.Fl a\nlists the format variables and their values.\n.Pp\n.Fl I\nforwards any input read from stdin to the empty pane given by\n.Ar target-pane .\n.Tg popup\n.It Xo Ic display-popup\n.Op Fl BCE\n.Op Fl b Ar border-lines\n.Op Fl c Ar target-client\n.Op Fl d Ar start-directory\n.Op Fl e Ar environment\n.Op Fl h Ar height\n.Op Fl s Ar border-style\n.Op Fl S Ar style\n.Op Fl t Ar target-pane\n.Op Fl T Ar title\n.Op Fl w Ar width\n.Op Fl x Ar position\n.Op Fl y Ar position\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic popup\nDisplay a popup running\n.Ar shell-command\non\n.Ar target-client .\nA popup is a rectangular box drawn over the top of any panes.\nPanes are not updated while a popup is present.\n.Pp\n.Fl E\ncloses the popup automatically when\n.Ar shell-command\nexits.\nTwo\n.Fl E\ncloses the popup only if\n.Ar shell-command\nexited with success.\n.Pp\n.Fl x\nand\n.Fl y\ngive the position of the popup, they have the same meaning as for the\n.Ic display-menu\ncommand.\n.Fl w\nand\n.Fl h\ngive the width and height - both may be a percentage (followed by\n.Ql % ) .\nIf omitted, half of the terminal size is used.\n.Pp\n.Fl B\ndoes not surround the popup by a border.\n.Pp\n.Fl b\nsets the type of characters used for drawing popup borders.\nWhen\n.Fl B\nis specified, the\n.Fl b\noption is ignored.\nSee\n.Ic popup-border-lines\nfor possible values for\n.Ar border-lines .\n.Pp\n.Fl s\nsets the style for the popup and\n.Fl S\nsets the style for the popup border (see\n.Sx STYLES ) .\n.Pp\n.Fl e\ntakes the form\n.Ql VARIABLE=value\nand sets an environment variable for the popup; it may be specified multiple\ntimes.\n.Pp\n.Fl T\nis a format for the popup title (see\n.Sx FORMATS ) .\n.Pp\nThe\n.Fl C\nflag closes any popup on the client.\n.Tg showphist\n.It Xo Ic show-prompt-history\n.Op Fl T Ar prompt-type\n.Xc\n.D1 Pq alias: Ic showphist\nDisplay status prompt history for prompt type\n.Ar prompt-type .\nIf\n.Fl T\nis omitted, then show history for all types.\nSee\n.Ic command-prompt\nfor possible values for\n.Ar prompt-type .\n.El\n.Sh BUFFERS\n.Nm\nmaintains a set of named\n.Em paste buffers .\nEach buffer may be either explicitly or automatically named.\nExplicitly named buffers are named when created with the\n.Ic set-buffer\nor\n.Ic load-buffer\ncommands, or by renaming an automatically named buffer with\n.Ic set-buffer\n.Fl n .\nAutomatically named buffers are given a name such as\n.Ql buffer0001 ,\n.Ql buffer0002\nand so on.\nWhen the\n.Ic buffer-limit\noption is reached, the oldest automatically named buffer is deleted.\nExplicitly named buffers are not subject to\n.Ic buffer-limit\nand may be deleted with the\n.Ic delete-buffer\ncommand.\n.Pp\nBuffers may be added using\n.Ic copy-mode\nor the\n.Ic set-buffer\nand\n.Ic load-buffer\ncommands, and pasted into a window using the\n.Ic paste-buffer\ncommand.\nIf a buffer command is used and no buffer is specified, the most\nrecently added automatically named buffer is assumed.\n.Pp\nA configurable history buffer is also maintained for each window.\nBy default, up to 2000 lines are kept; this can be altered with the\n.Ic history-limit\noption (see the\n.Ic set-option\ncommand above).\n.Pp\nThe buffer commands are as follows:\n.Bl -tag -width Ds\n.It Xo\n.Ic choose-buffer\n.Op Fl NryZ\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Op Fl K Ar key-format\n.Op Fl O Ar sort-order\n.Op Fl t Ar target-pane\n.Op Ar template\n.Xc\nPut a pane into buffer mode, where a buffer may be chosen interactively from\na list.\nEach buffer is shown on one line.\nA shortcut key is shown on the left in brackets allowing for immediate choice,\nor the list may be navigated and an item chosen or otherwise manipulated using\nthe keys below.\n.Fl Z\nzooms the pane.\n.Fl y\ndisables any confirmation prompts.\nThe following keys may be used in buffer mode:\n.Bl -column \"Key\" \"Function\" -offset indent\n.It Sy \"Key\" Ta Sy \"Function\"\n.It Li \"Enter\" Ta \"Paste selected buffer\"\n.It Li \"Up\" Ta \"Select previous buffer\"\n.It Li \"Down\" Ta \"Select next buffer\"\n.It Li \"C-s\" Ta \"Search by name or content\"\n.It Li \"n\" Ta \"Repeat last search forwards\"\n.It Li \"N\" Ta \"Repeat last search backwards\"\n.It Li \"t\" Ta \"Toggle if buffer is tagged\"\n.It Li \"T\" Ta \"Tag no buffers\"\n.It Li \"C-t\" Ta \"Tag all buffers\"\n.It Li \"p\" Ta \"Paste selected buffer\"\n.It Li \"P\" Ta \"Paste tagged buffers\"\n.It Li \"d\" Ta \"Delete selected buffer\"\n.It Li \"D\" Ta \"Delete tagged buffers\"\n.It Li \"e\" Ta \"Open the buffer in an editor\"\n.It Li \"f\" Ta \"Enter a format to filter items\"\n.It Li \"O\" Ta \"Change sort field\"\n.It Li \"r\" Ta \"Reverse sort order\"\n.It Li \"v\" Ta \"Toggle preview\"\n.It Li \"q\" Ta \"Exit mode\"\n.El\n.Pp\nAfter a buffer is chosen,\n.Ql %%\nis replaced by the buffer name in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"paste-buffer -p -b \\[aq]%%\\[aq]\" is used.\n.Pp\n.Fl O\nspecifies the initial sort field: one of\n.Ql time\n(creation),\n.Ql name\nor\n.Ql size .\n.Fl r\nreverses the sort order.\n.Fl f\nspecifies an initial filter: the filter is a format - if it evaluates to zero,\nthe item in the list is not shown, otherwise it is shown.\nIf a filter would lead to an empty list, it is ignored.\n.Fl F\nspecifies the format for each item in the list and\n.Fl K\na format for each shortcut key; both are evaluated once for each line.\n.Fl N\nstarts without the preview.\nThis command works only if at least one client is attached.\n.Tg clearhist\n.It Xo Ic clear-history\n.Op Fl H\n.Op Fl t Ar target-pane\n.Xc\n.D1 Pq alias: Ic clearhist\nRemove and free the history for the specified pane.\n.Fl H\nalso removes all hyperlinks.\n.Tg deleteb\n.It Ic delete-buffer Op Fl b Ar buffer-name\n.D1 Pq alias: Ic deleteb\nDelete the buffer named\n.Ar buffer-name ,\nor the most recently added automatically named buffer if not specified.\n.Tg lsb\n.It Xo Ic list-buffers\n.Op Fl F Ar format\n.Op Fl f Ar filter\n.Xc\n.D1 Pq alias: Ic lsb\nList the global buffers.\n.Fl F\nspecifies the format of each line and\n.Fl f\na filter.\nOnly buffers for which the filter is true are shown.\nSee the\n.Sx FORMATS\nsection.\n.It Xo Ic load-buffer\n.Op Fl w\n.Op Fl b Ar buffer-name\n.Op Fl t Ar target-client\n.Ar path\n.Xc\n.Tg loadb\n.D1 Pq alias: Ic loadb\nLoad the contents of the specified paste buffer from\n.Ar path .\nIf\n.Fl w\nis given, the buffer is also sent to the clipboard for\n.Ar target-client\nusing the\n.Xr xterm 1\nescape sequence, if possible.\nIf\n.Ar path\nis\n.Ql - ,\nthe contents are read from stdin.\n.Tg pasteb\n.It Xo Ic paste-buffer\n.Op Fl dpr\n.Op Fl b Ar buffer-name\n.Op Fl s Ar separator\n.Op Fl t Ar target-pane\n.Xc\n.D1 Pq alias: Ic pasteb\nInsert the contents of a paste buffer into the specified pane.\nIf not specified, paste into the current one.\nWith\n.Fl d ,\nalso delete the paste buffer.\nWhen output, any linefeed (LF) characters in the paste buffer are replaced with\na separator, by default carriage return (CR).\nA custom separator may be specified using the\n.Fl s\nflag.\nThe\n.Fl r\nflag means to do no replacement (equivalent to a separator of LF).\nIf\n.Fl p\nis specified, paste bracket control codes are inserted around the\nbuffer if the application has requested bracketed paste mode.\n.Tg saveb\n.It Xo Ic save-buffer\n.Op Fl a\n.Op Fl b Ar buffer-name\n.Ar path\n.Xc\n.D1 Pq alias: Ic saveb\nSave the contents of the specified paste buffer to\n.Ar path .\nThe\n.Fl a\noption appends to rather than overwriting the file.\nIf\n.Ar path\nis\n.Ql - ,\nthe contents are written to stdout.\n.It Xo Ic set-buffer\n.Op Fl aw\n.Op Fl b Ar buffer-name\n.Op Fl t Ar target-client\n.Tg setb\n.Op Fl n Ar new-buffer-name\n.Ar data\n.Xc\n.D1 Pq alias: Ic setb\nSet the contents of the specified buffer to\n.Ar data .\nIf\n.Fl w\nis given, the buffer is also sent to the clipboard for\n.Ar target-client\nusing the\n.Xr xterm 1\nescape sequence, if possible.\nThe\n.Fl a\noption appends to rather than overwriting the buffer.\nThe\n.Fl n\noption renames the buffer to\n.Ar new-buffer-name .\n.Tg showb\n.It Xo Ic show-buffer\n.Op Fl b Ar buffer-name\n.Xc\n.D1 Pq alias: Ic showb\nDisplay the contents of the specified buffer.\n.El\n.Sh MISCELLANEOUS\nMiscellaneous commands are as follows:\n.Bl -tag -width Ds\n.It Ic clock-mode Op Fl t Ar target-pane\nDisplay a large clock.\n.Tg if\n.It Xo Ic if-shell\n.Op Fl bF\n.Op Fl t Ar target-pane\n.Ar shell-command command\n.Op Ar command\n.Xc\n.D1 Pq alias: Ic if\nExecute the first\n.Ar command\nif\n.Ar shell-command\n(run with\n.Pa /bin/sh )\nreturns success or the second\n.Ar command\notherwise.\nBefore being executed,\n.Ar shell-command\nis expanded using the rules specified in the\n.Sx FORMATS\nsection, including those relevant to\n.Ar target-pane .\nWith\n.Fl b ,\n.Ar shell-command\nis run in the background.\n.Pp\nIf\n.Fl F\nis given,\n.Ar shell-command\nis not executed but considered success if neither empty nor zero (after formats\nare expanded).\n.Tg lock\n.It Ic lock-server\n.D1 Pq alias: Ic lock\nLock each client individually by running the command specified by the\n.Ic lock-command\noption.\n.Tg run\n.It Xo Ic run-shell\n.Op Fl bC\n.Op Fl c Ar start-directory\n.Op Fl d Ar delay\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Xc\n.D1 Pq alias: Ic run\nExecute\n.Ar shell-command\nusing\n.Pa /bin/sh\nor (with\n.Fl C )\na\n.Nm\ncommand in the background without creating a window.\nBefore being executed,\n.Ar shell-command\nis expanded using the rules specified in the\n.Sx FORMATS\nsection.\nWith\n.Fl b ,\nthe command is run in the background.\n.Fl d\nwaits for\n.Ar delay\nseconds before starting the command.\nIf\n.Fl c\nis given, the current working directory is set to\n.Ar start-directory .\nIf\n.Fl C\nis not given, any output to stdout is displayed in view mode (in the pane\nspecified by\n.Fl t\nor the current pane if omitted) after the command finishes.\nIf the command fails, the exit status is also displayed.\n.Tg wait\n.It Xo Ic wait-for\n.Op Fl L | S | U\n.Ar channel\n.Xc\n.D1 Pq alias: Ic wait\nWhen used without options, prevents the client from exiting until woken using\n.Ic wait-for\n.Fl S\nwith the same channel.\nWhen\n.Fl L\nis used, the channel is locked and any clients that try to lock the same\nchannel are made to wait until the channel is unlocked with\n.Ic wait-for\n.Fl U .\n.El\n.Sh EXIT MESSAGES\nWhen a\n.Nm\nclient detaches, it prints a message.\nThis may be one of:\n.Bl -tag -width Ds\n.It detached (from session ...)\nThe client was detached normally.\n.It detached and SIGHUP\nThe client was detached and its parent sent the\n.Dv SIGHUP\nsignal (for example with\n.Ic detach-client\n.Fl P ) .\n.It lost tty\nThe client's\n.Xr tty 4\nor\n.Xr pty 4\nwas unexpectedly destroyed.\n.It terminated\nThe client was killed with\n.Dv SIGTERM .\n.It too far behind\nThe client is in control mode and became unable to keep up with the data from\n.Nm .\n.It exited\nThe server exited when it had no sessions.\n.It server exited\nThe server exited when it received\n.Dv SIGTERM .\n.It server exited unexpectedly\nThe server crashed or otherwise exited without telling the client the reason.\n.El\n.Sh TERMINFO EXTENSIONS\n.Nm\nunderstands some unofficial extensions to\n.Xr terminfo 5 .\nIt is not normally necessary to set these manually, instead the\n.Ic terminal-features\noption should be used.\n.Bl -tag -width Ds\n.It Em \\&AX\nAn existing extension that tells\n.Nm\nthe terminal supports default colours.\n.It Em \\&Bidi\nTell\n.Nm\nthat the terminal supports the VTE bidirectional text extensions.\n.It Em \\&Cs , Cr\nSet the cursor colour.\nThe first takes a single string argument and is used to set the colour;\nthe second takes no arguments and restores the default cursor colour.\nIf set, a sequence such as this may be used\nto change the cursor colour from inside\n.Nm :\n.Bd -literal -offset indent\n$ printf \\[aq]\\e033]12;red\\e033\\e\\e\\[aq]\n.Ed\n.Pp\nThe colour is an\n.Xr X 7\ncolour, see\n.Xr XParseColor 3 .\n.It Em \\&Cmg, \\&Clmg, \\&Dsmg , \\&Enmg\nSet, clear, disable or enable DECSLRM margins.\nThese are set automatically if the terminal reports it is\n.Em VT420\ncompatible.\n.It Em \\&Dsbp , \\&Enbp\nDisable and enable bracketed paste.\nThese are set automatically if the\n.Em XT\ncapability is present.\n.It Em \\&Dseks , \\&Eneks\nDisable and enable extended keys.\n.It Em \\&Dsfcs , \\&Enfcs\nDisable and enable focus reporting.\nThese are set automatically if the\n.Em XT\ncapability is present.\n.It Em \\&Hls\nSet or clear a hyperlink annotation.\n.It Em \\&Nobr\nTell\n.Nm\nthat the terminal does not use bright colors for bold display.\n.It Em \\&Rect\nTell\n.Nm\nthat the terminal supports rectangle operations.\n.It Em \\&Smol\nEnable the overline attribute.\n.It Em \\&Smulx\nSet a styled underscore.\nThe single parameter is one of: 0 for no underscore, 1 for normal\nunderscore, 2 for double underscore, 3 for curly underscore, 4 for dotted\nunderscore and 5 for dashed underscore.\n.It Em \\&Setulc , \\&Setulc1, \\&ol\nSet the underscore colour or reset to the default.\n.Em Setulc\nis for RGB colours and\n.Em Setulc1\nfor ANSI or 256 colours.\nThe\n.Em Setulc\nargument is (red * 65536) + (green * 256) + blue where each is between 0\nand 255.\n.It Em \\&Ss , Se\nSet or reset the cursor style.\nIf set, a sequence such as this may be used\nto change the cursor to an underline:\n.Bd -literal -offset indent\n$ printf \\[aq]\\e033[4 q\\[aq]\n.Ed\n.Pp\nIf\n.Em Se\nis not set, \\&Ss with argument 0 will be used to reset the cursor style instead.\n.It Em \\&Swd\nSet the opening sequence for the working directory notification.\nThe sequence is terminated using the standard\n.Em fsl\ncapability.\n.It Em \\&Sxl\nIndicates that the terminal supports SIXEL.\n.It Em \\&Sync\nStart (parameter is 1) or end (parameter is 2) a synchronized update.\n.It Em \\&Tc\nIndicate that the terminal supports the\n.Ql direct colour\nRGB escape sequence (for example, \\ee[38;2;255;255;255m).\n.Pp\nIf supported, this is used for the initialize colour escape sequence (which\nmay be enabled by adding the\n.Ql initc\nand\n.Ql ccc\ncapabilities to the\n.Nm\n.Xr terminfo 5\nentry).\n.Pp\nThis is equivalent to the\n.Em RGB\n.Xr terminfo 5\ncapability.\n.It Em \\&Ms\nStore the current buffer in the host terminal's selection (clipboard).\nSee the\n.Em set-clipboard\noption above and the\n.Xr xterm 1\nman page.\n.It Em \\&XT\nThis is an existing extension capability that tmux uses to mean that the\nterminal supports the\n.Xr xterm 1\ntitle set sequences and to automatically set some of the capabilities above.\n.El\n.Sh CONTROL MODE\n.Nm\noffers a textual interface called\n.Em control mode .\nThis allows applications to communicate with\n.Nm\nusing a simple text-only protocol.\n.Pp\nIn control mode, a client sends\n.Nm\ncommands or command sequences terminated by newlines on standard input.\nEach command will produce one block of output on standard output.\nAn output block consists of a\n.Em %begin\nline followed by the output (which may be empty).\nThe output block ends with a\n.Em %end\nor\n.Em %error .\n.Em %begin\nand matching\n.Em %end\nor\n.Em %error\nhave three arguments: an integer time (as seconds from epoch), command number\nand flags (currently not used).\nFor example:\n.Bd -literal -offset indent\n%begin 1363006971 2 1\n0: ksh* (1 panes) [80x24] [layout b25f,80x24,0,0,2] @2 (active)\n%end 1363006971 2 1\n.Ed\n.Pp\nThe\n.Ic refresh-client\n.Fl C\ncommand may be used to set the size of a client in control mode.\n.Pp\nIn control mode,\n.Nm\noutputs notifications.\nA notification will never occur inside an output block.\n.Pp\nThe following notifications are defined:\n.Bl -tag -width Ds\n.It Ic %client-detached Ar client\nThe client has detached.\n.It Ic %client-session-changed Ar client session-id name\nThe client is now attached to the session with ID\n.Ar session-id ,\nwhich is named\n.Ar name .\n.It Ic %config-error Ar error\nAn error has happened in a configuration file.\n.It Ic %continue Ar pane-id\nThe pane has been continued after being paused (if the\n.Ar pause-after\nflag is set, see\n.Ic refresh-client\n.Fl A ) .\n.It Ic %exit Op Ar reason\nThe\n.Nm\nclient is exiting immediately, either because it is not attached to any session\nor an error occurred.\nIf present,\n.Ar reason\ndescribes why the client exited.\n.It Ic %extended-output Ar pane-id Ar age Ar ... \\&  : Ar value\nNew form of\n.Ic %output\nsent when the\n.Ar pause-after\nflag is set.\n.Ar age\nis the time in milliseconds for which tmux had buffered the output before it\nwas sent.\nAny subsequent arguments up until a single\n.Ql \\&:\nare for future use and should be ignored.\n.It Xo Ic %layout-change\n.Ar window-id\n.Ar window-layout\n.Ar window-visible-layout\n.Ar window-flags\n.Xc\nThe layout of a window with ID\n.Ar window-id\nchanged.\nThe new layout is\n.Ar window-layout .\nThe window's visible layout is\n.Ar window-visible-layout\nand the window flags are\n.Ar window-flags .\n.It Ic %message Ar message\nA message sent with the\n.Ic display-message\ncommand.\n.It Ic %output Ar pane-id Ar value\nA window pane produced output.\n.Ar value\nescapes non-printable characters and backslash as octal \\\\xxx.\n.It Ic %pane-mode-changed Ar pane-id\nThe pane with ID\n.Ar pane-id\nhas changed mode.\n.It Ic %paste-buffer-changed Ar name\nPaste buffer\n.Ar name\nhas been changed.\n.It Ic %paste-buffer-deleted Ar name\nPaste buffer\n.Ar name\nhas been deleted.\n.It Ic %pause Ar pane-id\nThe pane has been paused (if the\n.Ar pause-after\nflag is set).\n.It Ic %session-changed Ar session-id Ar name\nThe client is now attached to the session with ID\n.Ar session-id ,\nwhich is named\n.Ar name .\n.It Ic %session-renamed Ar name\nThe current session was renamed to\n.Ar name .\n.It Ic %session-window-changed Ar session-id Ar window-id\nThe session with ID\n.Ar session-id\nchanged its active window to the window with ID\n.Ar window-id .\n.It Ic %sessions-changed\nA session was created or destroyed.\n.It Xo Ic %subscription-changed\n.Ar name\n.Ar session-id\n.Ar window-id\n.Ar window-index\n.Ar pane-id ... \\&  :\n.Ar value\n.Xc\nThe value of the format associated with subscription\n.Ar name\nhas changed to\n.Ar value .\nSee\n.Ic refresh-client\n.Fl B .\nAny arguments after\n.Ar pane-id\nup until a single\n.Ql \\&:\nare for future use and should be ignored.\n.It Ic %unlinked-window-add Ar window-id\nThe window with ID\n.Ar window-id\nwas created but is not linked to the current session.\n.It Ic %unlinked-window-close Ar window-id\nThe window with ID\n.Ar window-id ,\nwhich is not linked to the current session, was closed.\n.It Ic %unlinked-window-renamed Ar window-id\nThe window with ID\n.Ar window-id ,\nwhich is not linked to the current session, was renamed.\n.It Ic %window-add Ar window-id\nThe window with ID\n.Ar window-id\nwas linked to the current session.\n.It Ic %window-close Ar window-id\nThe window with ID\n.Ar window-id\nclosed.\n.It Ic %window-pane-changed Ar window-id Ar pane-id\nThe active pane in the window with ID\n.Ar window-id\nchanged to the pane with ID\n.Ar pane-id .\n.It Ic %window-renamed Ar window-id Ar name\nThe window with ID\n.Ar window-id\nwas renamed to\n.Ar name .\n.El\n.Sh ENVIRONMENT\nWhen\n.Nm\nis started, it inspects the following environment variables:\n.Bl -tag -width LC_CTYPE\n.It Ev EDITOR\nIf the command specified in this variable contains the string\n.Ql vi\nand\n.Ev VISUAL\nis unset, use vi-style key bindings.\nOverridden by the\n.Ic mode-keys\nand\n.Ic status-keys\noptions.\n.It Ev HOME\nThe user's login directory.\nIf unset, the\n.Xr passwd 5\ndatabase is consulted.\n.It Ev LC_CTYPE\nThe character encoding\n.Xr locale 1 .\nIt is used for two separate purposes.\nFor output to the terminal, UTF-8 is used if the\n.Fl u\noption is given or if\n.Ev LC_CTYPE\ncontains\n.Qq UTF-8\nor\n.Qq UTF8 .\nOtherwise, only ASCII characters are written and non-ASCII characters\nare replaced with underscores\n.Pq Ql _ .\nFor input,\n.Nm\nalways runs with a UTF-8 locale.\nIf en_US.UTF-8 is provided by the operating system, it is used and\n.Ev LC_CTYPE\nis ignored for input.\nOtherwise,\n.Ev LC_CTYPE\ntells\n.Nm\nwhat the UTF-8 locale is called on the current system.\nIf the locale specified by\n.Ev LC_CTYPE\nis not available or is not a UTF-8 locale,\n.Nm\nexits with an error message.\n.It Ev LC_TIME\nThe date and time format\n.Xr locale 1 .\nIt is used for locale-dependent\n.Xr strftime 3\nformat specifiers.\n.It Ev PWD\nThe current working directory to be set in the global environment.\nThis may be useful if it contains symbolic links.\nIf the value of the variable does not match the current working\ndirectory, the variable is ignored and the result of\n.Xr getcwd 3\nis used instead.\n.It Ev SHELL\nThe absolute path to the default shell for new windows.\nSee the\n.Ic default-shell\noption for details.\n.It Ev TMUX_TMPDIR\nThe parent directory of the directory containing the server sockets.\nSee the\n.Fl L\noption for details.\n.It Ev VISUAL\nIf the command specified in this variable contains the string\n.Ql vi ,\nuse vi-style key bindings.\nOverridden by the\n.Ic mode-keys\nand\n.Ic status-keys\noptions.\n.El\n.Sh FILES\n.Bl -tag -width \"@SYSCONFDIR@/tmux.confXXX\" -compact\n.It Pa \\[ti]/.tmux.conf\n.It Pa $XDG_CONFIG_HOME/tmux/tmux.conf\n.It Pa \\[ti]/.config/tmux/tmux.conf\nDefault\n.Nm\nconfiguration file.\n.It Pa @SYSCONFDIR@/tmux.conf\nSystem-wide configuration file.\n.El\n.Sh EXAMPLES\nTo create a new\n.Nm\nsession running\n.Xr vi 1 :\n.Pp\n.Dl $ tmux new-session vi\n.Pp\nMost commands have a shorter form, known as an alias.\nFor new-session, this is\n.Ic new :\n.Pp\n.Dl $ tmux new vi\n.Pp\nAlternatively, the shortest unambiguous form of a command is accepted.\nIf there are several options, they are listed:\n.Bd -literal -offset indent\n$ tmux n\nambiguous command: n, could be: new-session, new-window, next-window\n.Ed\n.Pp\nWithin an active session, a new window may be created by typing\n.Ql C-b c\n(Ctrl\nfollowed by the\n.Ql b\nkey\nfollowed by the\n.Ql c\nkey).\n.Pp\nWindows may be navigated with:\n.Ql C-b 0\n(to select window 0),\n.Ql C-b 1\n(to select window 1), and so on;\n.Ql C-b n\nto select the next window; and\n.Ql C-b p\nto select the previous window.\n.Pp\nA session may be detached using\n.Ql C-b d\n(or by an external event such as\n.Xr ssh 1\ndisconnection) and reattached with:\n.Pp\n.Dl $ tmux attach-session\n.Pp\nTyping\n.Ql C-b \\&?\nlists the current key bindings in the current window; up and down may be used\nto navigate the list or\n.Ql q\nto exit from it.\n.Pp\nCommands to be run when the\n.Nm\nserver is started may be placed in the\n.Pa \\[ti]/.tmux.conf\nconfiguration file.\nCommon examples include:\n.Pp\nChanging the default prefix key:\n.Bd -literal -offset indent\nset-option -g prefix C-a\nunbind-key C-b\nbind-key C-a send-prefix\n.Ed\n.Pp\nTurning the status line off, or changing its colour:\n.Bd -literal -offset indent\nset-option -g status off\nset-option -g status-style bg=blue\n.Ed\n.Pp\nSetting other options, such as the default command,\nor locking after 30 minutes of inactivity:\n.Bd -literal -offset indent\nset-option -g default-command \"exec /bin/ksh\"\nset-option -g lock-after-time 1800\n.Ed\n.Pp\nCreating new key bindings:\n.Bd -literal -offset indent\nbind-key b set-option status\nbind-key / command-prompt \"split-window \\[aq]exec man %%\\[aq]\"\nbind-key S command-prompt \"new-window -n %1 \\[aq]ssh %1\\[aq]\"\n.Ed\n.Sh SEE ALSO\n.Xr pty 4\n.Sh AUTHORS\n.An Nicholas Marriott Aq Mt nicholas.marriott@gmail.com\n"
        },
        {
          "name": "tmux.c",
          "type": "blob",
          "size": 11.8388671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <langinfo.h>\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct options\t*global_options;\t/* server options */\nstruct options\t*global_s_options;\t/* session options */\nstruct options\t*global_w_options;\t/* window options */\nstruct environ\t*global_environ;\n\nstruct timeval\t start_time;\nconst char\t*socket_path;\nint\t\t ptm_fd = -1;\nconst char\t*shell_command;\n\nstatic __dead void\t usage(void);\nstatic char\t\t*make_label(const char *, char **);\n\nstatic int\t\t areshell(const char *);\nstatic const char\t*getshell(void);\n\nstatic __dead void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: %s [-2CDlNuVv] [-c shell-command] [-f file] [-L socket-name]\\n\"\n\t    \"            [-S socket-path] [-T features] [command [flags]]\\n\",\n\t    getprogname());\n\texit(1);\n}\n\nstatic const char *\ngetshell(void)\n{\n\tstruct passwd\t*pw;\n\tconst char\t*shell;\n\n\tshell = getenv(\"SHELL\");\n\tif (checkshell(shell))\n\t\treturn (shell);\n\n\tpw = getpwuid(getuid());\n\tif (pw != NULL && checkshell(pw->pw_shell))\n\t\treturn (pw->pw_shell);\n\n\treturn (_PATH_BSHELL);\n}\n\nint\ncheckshell(const char *shell)\n{\n\tif (shell == NULL || *shell != '/')\n\t\treturn (0);\n\tif (areshell(shell))\n\t\treturn (0);\n\tif (access(shell, X_OK) != 0)\n\t\treturn (0);\n\treturn (1);\n}\n\nstatic int\nareshell(const char *shell)\n{\n\tconst char\t*progname, *ptr;\n\n\tif ((ptr = strrchr(shell, '/')) != NULL)\n\t\tptr++;\n\telse\n\t\tptr = shell;\n\tprogname = getprogname();\n\tif (*progname == '-')\n\t\tprogname++;\n\tif (strcmp(ptr, progname) == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic char *\nexpand_path(const char *path, const char *home)\n{\n\tchar\t\t\t*expanded, *name;\n\tconst char\t\t*end;\n\tstruct environ_entry\t*value;\n\n\tif (strncmp(path, \"~/\", 2) == 0) {\n\t\tif (home == NULL)\n\t\t\treturn (NULL);\n\t\txasprintf(&expanded, \"%s%s\", home, path + 1);\n\t\treturn (expanded);\n\t}\n\n\tif (*path == '$') {\n\t\tend = strchr(path, '/');\n\t\tif (end == NULL)\n\t\t\tname = xstrdup(path + 1);\n\t\telse\n\t\t\tname = xstrndup(path + 1, end - path - 1);\n\t\tvalue = environ_find(global_environ, name);\n\t\tfree(name);\n\t\tif (value == NULL)\n\t\t\treturn (NULL);\n\t\tif (end == NULL)\n\t\t\tend = \"\";\n\t\txasprintf(&expanded, \"%s%s\", value->value, end);\n\t\treturn (expanded);\n\t}\n\n\treturn (xstrdup(path));\n}\n\nstatic void\nexpand_paths(const char *s, char ***paths, u_int *n, int ignore_errors)\n{\n\tconst char\t*home = find_home();\n\tchar\t\t*copy, *next, *tmp, resolved[PATH_MAX], *expanded;\n\tchar\t\t*path;\n\tu_int\t\t i;\n\n\t*paths = NULL;\n\t*n = 0;\n\n\tcopy = tmp = xstrdup(s);\n\twhile ((next = strsep(&tmp, \":\")) != NULL) {\n\t\texpanded = expand_path(next, home);\n\t\tif (expanded == NULL) {\n\t\t\tlog_debug(\"%s: invalid path: %s\", __func__, next);\n\t\t\tcontinue;\n\t\t}\n\t\tif (realpath(expanded, resolved) == NULL) {\n\t\t\tlog_debug(\"%s: realpath(\\\"%s\\\") failed: %s\", __func__,\n\t\t\t    expanded, strerror(errno));\n\t\t\tif (ignore_errors) {\n\t\t\t\tfree(expanded);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath = expanded;\n\t\t} else {\n\t\t\tpath = xstrdup(resolved);\n\t\t\tfree(expanded);\n\t\t}\n\t\tfor (i = 0; i < *n; i++) {\n\t\t\tif (strcmp(path, (*paths)[i]) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != *n) {\n\t\t\tlog_debug(\"%s: duplicate path: %s\", __func__, path);\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\t*paths = xreallocarray(*paths, (*n) + 1, sizeof *paths);\n\t\t(*paths)[(*n)++] = path;\n\t}\n\tfree(copy);\n}\n\nstatic char *\nmake_label(const char *label, char **cause)\n{\n\tchar\t\t**paths, *path, *base;\n\tu_int\t\t  i, n;\n\tstruct stat\t  sb;\n\tuid_t\t\t  uid;\n\n\t*cause = NULL;\n\tif (label == NULL)\n\t\tlabel = \"default\";\n\tuid = getuid();\n\n\texpand_paths(TMUX_SOCK, &paths, &n, 1);\n\tif (n == 0) {\n\t\txasprintf(cause, \"no suitable socket path\");\n\t\treturn (NULL);\n\t}\n\tpath = paths[0]; /* can only have one socket! */\n\tfor (i = 1; i < n; i++)\n\t\tfree(paths[i]);\n\tfree(paths);\n\n\txasprintf(&base, \"%s/tmux-%ld\", path, (long)uid);\n\tfree(path);\n\tif (mkdir(base, S_IRWXU) != 0 && errno != EEXIST) {\n\t\txasprintf(cause, \"couldn't create directory %s (%s)\", base,\n\t\t    strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (lstat(base, &sb) != 0) {\n\t\txasprintf(cause, \"couldn't read directory %s (%s)\", base,\n\t\t    strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\txasprintf(cause, \"%s is not a directory\", base);\n\t\tgoto fail;\n\t}\n\tif (sb.st_uid != uid || (sb.st_mode & TMUX_SOCK_PERM) != 0) {\n\t\txasprintf(cause, \"directory %s has unsafe permissions\", base);\n\t\tgoto fail;\n\t}\n\txasprintf(&path, \"%s/%s\", base, label);\n\tfree(base);\n\treturn (path);\n\nfail:\n\tfree(base);\n\treturn (NULL);\n}\n\nchar *\nshell_argv0(const char *shell, int is_login)\n{\n\tconst char\t*slash, *name;\n\tchar\t\t*argv0;\n\n\tslash = strrchr(shell, '/');\n\tif (slash != NULL && slash[1] != '\\0')\n\t\tname = slash + 1;\n\telse\n\t\tname = shell;\n\tif (is_login)\n\t\txasprintf(&argv0, \"-%s\", name);\n\telse\n\t\txasprintf(&argv0, \"%s\", name);\n\treturn (argv0);\n}\n\nvoid\nsetblocking(int fd, int state)\n{\n\tint mode;\n\n\tif ((mode = fcntl(fd, F_GETFL)) != -1) {\n\t\tif (!state)\n\t\t\tmode |= O_NONBLOCK;\n\t\telse\n\t\t\tmode &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, mode);\n\t}\n}\n\nuint64_t\nget_timer(void)\n{\n\tstruct timespec\tts;\n\n\t/*\n\t * We want a timestamp in milliseconds suitable for time measurement,\n\t * so prefer the monotonic clock.\n\t */\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)\n\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn ((ts.tv_sec * 1000ULL) + (ts.tv_nsec / 1000000ULL));\n}\n\nconst char *\nsig2name(int signo)\n{\n     static char\ts[11];\n\n#ifdef HAVE_SYS_SIGNAME\n     if (signo > 0 && signo < NSIG)\n\t     return (sys_signame[signo]);\n#endif\n     xsnprintf(s, sizeof s, \"%d\", signo);\n     return (s);\n}\n\nconst char *\nfind_cwd(void)\n{\n\tchar\t\t resolved1[PATH_MAX], resolved2[PATH_MAX];\n\tstatic char\t cwd[PATH_MAX];\n\tconst char\t*pwd;\n\n\tif (getcwd(cwd, sizeof cwd) == NULL)\n\t\treturn (NULL);\n\tif ((pwd = getenv(\"PWD\")) == NULL || *pwd == '\\0')\n\t\treturn (cwd);\n\n\t/*\n\t * We want to use PWD so that symbolic links are maintained,\n\t * but only if it matches the actual working directory.\n\t */\n\tif (realpath(pwd, resolved1) == NULL)\n\t\treturn (cwd);\n\tif (realpath(cwd, resolved2) == NULL)\n\t\treturn (cwd);\n\tif (strcmp(resolved1, resolved2) != 0)\n\t\treturn (cwd);\n\treturn (pwd);\n}\n\nconst char *\nfind_home(void)\n{\n\tstruct passwd\t\t*pw;\n\tstatic const char\t*home;\n\n\tif (home != NULL)\n\t\treturn (home);\n\n\thome = getenv(\"HOME\");\n\tif (home == NULL || *home == '\\0') {\n\t\tpw = getpwuid(getuid());\n\t\tif (pw != NULL)\n\t\t\thome = pw->pw_dir;\n\t\telse\n\t\t\thome = NULL;\n\t}\n\n\treturn (home);\n}\n\nconst char *\ngetversion(void)\n{\n\treturn (TMUX_VERSION);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tchar\t\t\t\t\t*path = NULL, *label = NULL;\n\tchar\t\t\t\t\t*cause, **var;\n\tconst char\t\t\t\t*s, *cwd;\n\tint\t\t\t\t\t opt, keys, feat = 0, fflag = 0;\n\tuint64_t\t\t\t\t flags = 0;\n\tconst struct options_table_entry\t*oe;\n\tu_int\t\t\t\t\t i;\n\n\tif (setlocale(LC_CTYPE, \"en_US.UTF-8\") == NULL &&\n\t    setlocale(LC_CTYPE, \"C.UTF-8\") == NULL) {\n\t\tif (setlocale(LC_CTYPE, \"\") == NULL)\n\t\t\terrx(1, \"invalid LC_ALL, LC_CTYPE or LANG\");\n\t\ts = nl_langinfo(CODESET);\n\t\tif (strcasecmp(s, \"UTF-8\") != 0 && strcasecmp(s, \"UTF8\") != 0)\n\t\t\terrx(1, \"need UTF-8 locale (LC_CTYPE) but have %s\", s);\n\t}\n\n\tsetlocale(LC_TIME, \"\");\n\ttzset();\n\n\tif (**argv == '-')\n\t\tflags = CLIENT_LOGIN;\n\n\tglobal_environ = environ_create();\n\tfor (var = environ; *var != NULL; var++)\n\t\tenviron_put(global_environ, *var, 0);\n\tif ((cwd = find_cwd()) != NULL)\n\t\tenviron_set(global_environ, \"PWD\", 0, \"%s\", cwd);\n\texpand_paths(TMUX_CONF, &cfg_files, &cfg_nfiles, 1);\n\n\twhile ((opt = getopt(argc, argv, \"2c:CDdf:lL:NqS:T:uUvV\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '2':\n\t\t\ttty_add_features(&feat, \"256\", \":,\");\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tshell_command = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags |= CLIENT_NOFORK;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (flags & CLIENT_CONTROL)\n\t\t\t\tflags |= CLIENT_CONTROLCONTROL;\n\t\t\telse\n\t\t\t\tflags |= CLIENT_CONTROL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (!fflag) {\n\t\t\t\tfflag = 1;\n\t\t\t\tfor (i = 0; i < cfg_nfiles; i++)\n\t\t\t\t\tfree(cfg_files[i]);\n\t\t\t\tcfg_nfiles = 0;\n\t\t\t}\n\t\t\tcfg_files = xreallocarray(cfg_files, cfg_nfiles + 1,\n\t\t\t    sizeof *cfg_files);\n\t\t\tcfg_files[cfg_nfiles++] = xstrdup(optarg);\n\t\t\tcfg_quiet = 0;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprintf(\"tmux %s\\n\", getversion());\n\t\t\texit(0);\n\t\tcase 'l':\n\t\t\tflags |= CLIENT_LOGIN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tfree(label);\n\t\t\tlabel = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tflags |= CLIENT_NOSTARTSERVER;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tfree(path);\n\t\t\tpath = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttty_add_features(&feat, optarg, \":,\");\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags |= CLIENT_UTF8;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tlog_add_level();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (shell_command != NULL && argc != 0)\n\t\tusage();\n\tif ((flags & CLIENT_NOFORK) && argc != 0)\n\t\tusage();\n\n\tif ((ptm_fd = getptmfd()) == -1)\n\t\terr(1, \"getptmfd\");\n\tif (pledge(\"stdio rpath wpath cpath flock fattr unix getpw sendfd \"\n\t    \"recvfd proc exec tty ps\", NULL) != 0)\n\t\terr(1, \"pledge\");\n\n\t/*\n\t * tmux is a UTF-8 terminal, so if TMUX is set, assume UTF-8.\n\t * Otherwise, if the user has set LC_ALL, LC_CTYPE or LANG to contain\n\t * UTF-8, it is a safe assumption that either they are using a UTF-8\n\t * terminal, or if not they know that output from UTF-8-capable\n\t * programs may be wrong.\n\t */\n\tif (getenv(\"TMUX\") != NULL)\n\t\tflags |= CLIENT_UTF8;\n\telse {\n\t\ts = getenv(\"LC_ALL\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = getenv(\"LC_CTYPE\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = getenv(\"LANG\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = \"\";\n\t\tif (strcasestr(s, \"UTF-8\") != NULL ||\n\t\t    strcasestr(s, \"UTF8\") != NULL)\n\t\t\tflags |= CLIENT_UTF8;\n\t}\n\n\tglobal_options = options_create(NULL);\n\tglobal_s_options = options_create(NULL);\n\tglobal_w_options = options_create(NULL);\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (oe->scope & OPTIONS_TABLE_SERVER)\n\t\t\toptions_default(global_options, oe);\n\t\tif (oe->scope & OPTIONS_TABLE_SESSION)\n\t\t\toptions_default(global_s_options, oe);\n\t\tif (oe->scope & OPTIONS_TABLE_WINDOW)\n\t\t\toptions_default(global_w_options, oe);\n\t}\n\n\t/*\n\t * The default shell comes from SHELL or from the user's passwd entry\n\t * if available.\n\t */\n\toptions_set_string(global_s_options, \"default-shell\", 0, \"%s\",\n\t    getshell());\n\n\t/* Override keys to vi if VISUAL or EDITOR are set. */\n\tif ((s = getenv(\"VISUAL\")) != NULL || (s = getenv(\"EDITOR\")) != NULL) {\n\t\toptions_set_string(global_options, \"editor\", 0, \"%s\", s);\n\t\tif (strrchr(s, '/') != NULL)\n\t\t\ts = strrchr(s, '/') + 1;\n\t\tif (strstr(s, \"vi\") != NULL)\n\t\t\tkeys = MODEKEY_VI;\n\t\telse\n\t\t\tkeys = MODEKEY_EMACS;\n\t\toptions_set_number(global_s_options, \"status-keys\", keys);\n\t\toptions_set_number(global_w_options, \"mode-keys\", keys);\n\t}\n\n\t/*\n\t * If socket is specified on the command-line with -S or -L, it is\n\t * used. Otherwise, $TMUX is checked and if that fails \"default\" is\n\t * used.\n\t */\n\tif (path == NULL && label == NULL) {\n\t\ts = getenv(\"TMUX\");\n\t\tif (s != NULL && *s != '\\0' && *s != ',') {\n\t\t\tpath = xstrdup(s);\n\t\t\tpath[strcspn(path, \",\")] = '\\0';\n\t\t}\n\t}\n\tif (path == NULL) {\n\t\tif ((path = make_label(label, &cause)) == NULL) {\n\t\t\tif (cause != NULL) {\n\t\t\t\tfprintf(stderr, \"%s\\n\", cause);\n\t\t\t\tfree(cause);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\t\tflags |= CLIENT_DEFAULTSOCKET;\n\t}\n\tsocket_path = path;\n\tfree(label);\n\n\t/* Pass control to the client. */\n\texit(client_main(osdep_event_init(), argc, argv, flags, feat));\n}\n"
        },
        {
          "name": "tmux.h",
          "type": "blob",
          "size": 108.091796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef TMUX_H\n#define TMUX_H\n\n#include <sys/time.h>\n#include <sys/uio.h>\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <termios.h>\n#include <wchar.h>\n\n#ifdef HAVE_UTEMPTER\n#include <utempter.h>\n#endif\n\n#include \"compat.h\"\n#include \"tmux-protocol.h\"\n#include \"xmalloc.h\"\n\nextern char   **environ;\n\nstruct args;\nstruct args_command_state;\nstruct client;\nstruct cmd;\nstruct cmd_find_state;\nstruct cmdq_item;\nstruct cmdq_list;\nstruct cmdq_state;\nstruct cmds;\nstruct control_state;\nstruct environ;\nstruct format_job_tree;\nstruct format_tree;\nstruct hyperlinks_uri;\nstruct hyperlinks;\nstruct input_ctx;\nstruct job;\nstruct menu_data;\nstruct mode_tree_data;\nstruct mouse_event;\nstruct options;\nstruct options_array_item;\nstruct options_entry;\nstruct screen_write_citem;\nstruct screen_write_cline;\nstruct screen_write_ctx;\nstruct session;\n\n#ifdef ENABLE_SIXEL\nstruct sixel_image;\n#endif\n\nstruct tty_ctx;\nstruct tty_code;\nstruct tty_key;\nstruct tmuxpeer;\nstruct tmuxproc;\nstruct winlink;\n\n/* Default configuration files and socket paths. */\n#ifndef TMUX_CONF\n#define TMUX_CONF \"/etc/tmux.conf:~/.tmux.conf\"\n#endif\n#ifndef TMUX_SOCK\n#define TMUX_SOCK \"$TMUX_TMPDIR:\" _PATH_TMP\n#endif\n#ifndef TMUX_SOCK_PERM\n#define TMUX_SOCK_PERM (7 /* o+rwx */)\n#endif\n#ifndef TMUX_TERM\n#define TMUX_TERM \"screen\"\n#endif\n#ifndef TMUX_LOCK_CMD\n#define TMUX_LOCK_CMD \"lock -np\"\n#endif\n\n/* Minimum layout cell size, NOT including border lines. */\n#define PANE_MINIMUM 1\n\n/* Minimum and maximum window size. */\n#define WINDOW_MINIMUM PANE_MINIMUM\n#define WINDOW_MAXIMUM 10000\n\n/* Automatic name refresh interval, in microseconds. Must be < 1 second. */\n#define NAME_INTERVAL 500000\n\n/* Default pixel cell sizes. */\n#define DEFAULT_XPIXEL 16\n#define DEFAULT_YPIXEL 32\n\n/* Attribute to make GCC check printf-like arguments. */\n#define printflike(a, b) __attribute__ ((format (printf, a, b)))\n\n/* Number of items in array. */\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n/* Alert option values. */\n#define ALERT_NONE 0\n#define ALERT_ANY 1\n#define ALERT_CURRENT 2\n#define ALERT_OTHER 3\n\n/* Visual option values. */\n#define VISUAL_OFF 0\n#define VISUAL_ON 1\n#define VISUAL_BOTH 2\n\n/* No key or unknown key. */\n#define KEYC_NONE            0x000ff000000000ULL\n#define KEYC_UNKNOWN         0x000fe000000000ULL\n\n/*\n * Base for special (that is, not Unicode) keys. An enum must be at most a\n * signed int, so these are based in the highest Unicode PUA.\n */\n#define KEYC_BASE            0x0000000010e000ULL\n#define KEYC_USER            0x0000000010f000ULL\n#define KEYC_USER_END\t     (KEYC_USER + KEYC_NUSER)\n\n/* Key modifier bits. */\n#define KEYC_META            0x00100000000000ULL\n#define KEYC_CTRL            0x00200000000000ULL\n#define KEYC_SHIFT           0x00400000000000ULL\n\n/* Key flag bits. */\n#define KEYC_LITERAL\t     0x01000000000000ULL\n#define KEYC_KEYPAD\t     0x02000000000000ULL\n#define KEYC_CURSOR\t     0x04000000000000ULL\n#define KEYC_IMPLIED_META    0x08000000000000ULL\n#define KEYC_BUILD_MODIFIERS 0x10000000000000ULL\n#define KEYC_VI\t\t     0x20000000000000ULL\n#define KEYC_SENT\t     0x40000000000000ULL\n\n/* Masks for key bits. */\n#define KEYC_MASK_MODIFIERS  0x00f00000000000ULL\n#define KEYC_MASK_FLAGS      0xff000000000000ULL\n#define KEYC_MASK_KEY        0x000fffffffffffULL\n\n/* Available user keys. */\n#define KEYC_NUSER 1000\n\n/* Is this a mouse key? */\n#define KEYC_IS_MOUSE(key) \\\n\t(((key) & KEYC_MASK_KEY) >= KEYC_MOUSE && \\\n\t ((key) & KEYC_MASK_KEY) < KEYC_BSPACE)\n\n/* Is this a Unicode key? */\n#define KEYC_IS_UNICODE(key) \\\n\t(((key) & KEYC_MASK_KEY) > 0x7f && \\\n\t (((key) & KEYC_MASK_KEY) < KEYC_BASE || \\\n\t  ((key) & KEYC_MASK_KEY) >= KEYC_BASE_END) && \\\n\t (((key) & KEYC_MASK_KEY) < KEYC_USER || \\\n\t  ((key) & KEYC_MASK_KEY) >= KEYC_USER_END))\n\n/* Is this a paste key? */\n#define KEYC_IS_PASTE(key) \\\n\t((key) == KEYC_PASTE_START || (key) == KEYC_PASTE_END)\n\n/* Multiple click timeout. */\n#define KEYC_CLICK_TIMEOUT 300\n\n/* Mouse key codes. */\n#define KEYC_MOUSE_KEY(name)\t\t    \\\n\tKEYC_ ## name ## _PANE,\t\t    \\\n\tKEYC_ ## name ## _STATUS,\t    \\\n\tKEYC_ ## name ## _STATUS_LEFT,\t    \\\n\tKEYC_ ## name ## _STATUS_RIGHT,\t    \\\n\tKEYC_ ## name ## _STATUS_DEFAULT,   \\\n\tKEYC_ ## name ## _SCROLLBAR_UP,\t    \\\n\tKEYC_ ## name ## _SCROLLBAR_SLIDER, \\\n\tKEYC_ ## name ## _SCROLLBAR_DOWN,   \\\n\tKEYC_ ## name ## _BORDER\n#define KEYC_MOUSE_STRING(name, s)\t\t\t\t      \\\n\t{ #s \"Pane\", KEYC_ ## name ## _PANE },\t\t\t      \\\n\t{ #s \"Status\", KEYC_ ## name ## _STATUS },\t\t      \\\n\t{ #s \"StatusLeft\", KEYC_ ## name ## _STATUS_LEFT },\t      \\\n\t{ #s \"StatusRight\", KEYC_ ## name ## _STATUS_RIGHT },\t      \\\n\t{ #s \"StatusDefault\", KEYC_ ## name ## _STATUS_DEFAULT },     \\\n\t{ #s \"ScrollbarUp\", KEYC_ ## name ## _SCROLLBAR_UP },         \\\n\t{ #s \"ScrollbarSlider\", KEYC_ ## name ## _SCROLLBAR_SLIDER }, \\\n\t{ #s \"ScrollbarDown\", KEYC_ ## name ## _SCROLLBAR_DOWN },     \\\n\t{ #s \"Border\", KEYC_ ## name ## _BORDER }\n\n/*\n * A single key. This can be ASCII or Unicode or one of the keys between\n * KEYC_BASE and KEYC_BASE_END.\n */\ntypedef unsigned long long key_code;\n\n/* C0 control characters */\nenum {\n\tC0_NUL,\n\tC0_SOH,\n\tC0_STX,\n\tC0_ETX,\n\tC0_EOT,\n\tC0_ENQ,\n\tC0_ASC,\n\tC0_BEL,\n\tC0_BS,\n\tC0_HT,\n\tC0_LF,\n\tC0_VT,\n\tC0_FF,\n\tC0_CR,\n\tC0_SO,\n\tC0_SI,\n\tC0_DLE,\n\tC0_DC1,\n\tC0_DC2,\n\tC0_DC3,\n\tC0_DC4,\n\tC0_NAK,\n\tC0_SYN,\n\tC0_ETB,\n\tC0_CAN,\n\tC0_EM,\n\tC0_SUB,\n\tC0_ESC,\n\tC0_FS,\n\tC0_GS,\n\tC0_RS,\n\tC0_US\n};\n\n/* Special key codes. */\nenum {\n\t/* Focus events. */\n\tKEYC_FOCUS_IN = KEYC_BASE,\n\tKEYC_FOCUS_OUT,\n\n\t/* \"Any\" key, used if not found in key table. */\n\tKEYC_ANY,\n\n\t/* Paste brackets. */\n\tKEYC_PASTE_START,\n\tKEYC_PASTE_END,\n\n\t/* Mouse keys. */\n\tKEYC_MOUSE, /* unclassified mouse event */\n\tKEYC_DRAGGING, /* dragging in progress */\n\tKEYC_DOUBLECLICK, /* double click complete */\n\tKEYC_MOUSE_KEY(MOUSEMOVE),\n\tKEYC_MOUSE_KEY(MOUSEDOWN1),\n\tKEYC_MOUSE_KEY(MOUSEDOWN2),\n\tKEYC_MOUSE_KEY(MOUSEDOWN3),\n\tKEYC_MOUSE_KEY(MOUSEDOWN6),\n\tKEYC_MOUSE_KEY(MOUSEDOWN7),\n\tKEYC_MOUSE_KEY(MOUSEDOWN8),\n\tKEYC_MOUSE_KEY(MOUSEDOWN9),\n\tKEYC_MOUSE_KEY(MOUSEDOWN10),\n\tKEYC_MOUSE_KEY(MOUSEDOWN11),\n\tKEYC_MOUSE_KEY(MOUSEUP1),\n\tKEYC_MOUSE_KEY(MOUSEUP2),\n\tKEYC_MOUSE_KEY(MOUSEUP3),\n\tKEYC_MOUSE_KEY(MOUSEUP6),\n\tKEYC_MOUSE_KEY(MOUSEUP7),\n\tKEYC_MOUSE_KEY(MOUSEUP8),\n\tKEYC_MOUSE_KEY(MOUSEUP9),\n\tKEYC_MOUSE_KEY(MOUSEUP10),\n\tKEYC_MOUSE_KEY(MOUSEUP11),\n\tKEYC_MOUSE_KEY(MOUSEDRAG1),\n\tKEYC_MOUSE_KEY(MOUSEDRAG2),\n\tKEYC_MOUSE_KEY(MOUSEDRAG3),\n\tKEYC_MOUSE_KEY(MOUSEDRAG6),\n\tKEYC_MOUSE_KEY(MOUSEDRAG7),\n\tKEYC_MOUSE_KEY(MOUSEDRAG8),\n\tKEYC_MOUSE_KEY(MOUSEDRAG9),\n\tKEYC_MOUSE_KEY(MOUSEDRAG10),\n\tKEYC_MOUSE_KEY(MOUSEDRAG11),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND1),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND2),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND3),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND6),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND7),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND8),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND9),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND10),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND11),\n\tKEYC_MOUSE_KEY(WHEELUP),\n\tKEYC_MOUSE_KEY(WHEELDOWN),\n\tKEYC_MOUSE_KEY(SECONDCLICK1),\n\tKEYC_MOUSE_KEY(SECONDCLICK2),\n\tKEYC_MOUSE_KEY(SECONDCLICK3),\n\tKEYC_MOUSE_KEY(SECONDCLICK6),\n\tKEYC_MOUSE_KEY(SECONDCLICK7),\n\tKEYC_MOUSE_KEY(SECONDCLICK8),\n\tKEYC_MOUSE_KEY(SECONDCLICK9),\n\tKEYC_MOUSE_KEY(SECONDCLICK10),\n\tKEYC_MOUSE_KEY(SECONDCLICK11),\n\tKEYC_MOUSE_KEY(DOUBLECLICK1),\n\tKEYC_MOUSE_KEY(DOUBLECLICK2),\n\tKEYC_MOUSE_KEY(DOUBLECLICK3),\n\tKEYC_MOUSE_KEY(DOUBLECLICK6),\n\tKEYC_MOUSE_KEY(DOUBLECLICK7),\n\tKEYC_MOUSE_KEY(DOUBLECLICK8),\n\tKEYC_MOUSE_KEY(DOUBLECLICK9),\n\tKEYC_MOUSE_KEY(DOUBLECLICK10),\n\tKEYC_MOUSE_KEY(DOUBLECLICK11),\n\tKEYC_MOUSE_KEY(TRIPLECLICK1),\n\tKEYC_MOUSE_KEY(TRIPLECLICK2),\n\tKEYC_MOUSE_KEY(TRIPLECLICK3),\n\tKEYC_MOUSE_KEY(TRIPLECLICK6),\n\tKEYC_MOUSE_KEY(TRIPLECLICK7),\n\tKEYC_MOUSE_KEY(TRIPLECLICK8),\n\tKEYC_MOUSE_KEY(TRIPLECLICK9),\n\tKEYC_MOUSE_KEY(TRIPLECLICK10),\n\tKEYC_MOUSE_KEY(TRIPLECLICK11),\n\n\t/* Backspace key. */\n\tKEYC_BSPACE,\n\n\t/* Function keys. */\n\tKEYC_F1,\n\tKEYC_F2,\n\tKEYC_F3,\n\tKEYC_F4,\n\tKEYC_F5,\n\tKEYC_F6,\n\tKEYC_F7,\n\tKEYC_F8,\n\tKEYC_F9,\n\tKEYC_F10,\n\tKEYC_F11,\n\tKEYC_F12,\n\tKEYC_IC,\n\tKEYC_DC,\n\tKEYC_HOME,\n\tKEYC_END,\n\tKEYC_NPAGE,\n\tKEYC_PPAGE,\n\tKEYC_BTAB,\n\n\t/* Arrow keys. */\n\tKEYC_UP,\n\tKEYC_DOWN,\n\tKEYC_LEFT,\n\tKEYC_RIGHT,\n\n\t/* Numeric keypad. */\n\tKEYC_KP_SLASH,\n\tKEYC_KP_STAR,\n\tKEYC_KP_MINUS,\n\tKEYC_KP_SEVEN,\n\tKEYC_KP_EIGHT,\n\tKEYC_KP_NINE,\n\tKEYC_KP_PLUS,\n\tKEYC_KP_FOUR,\n\tKEYC_KP_FIVE,\n\tKEYC_KP_SIX,\n\tKEYC_KP_ONE,\n\tKEYC_KP_TWO,\n\tKEYC_KP_THREE,\n\tKEYC_KP_ENTER,\n\tKEYC_KP_ZERO,\n\tKEYC_KP_PERIOD,\n\n\t/* End of special keys. */\n\tKEYC_BASE_END\n};\n\n/* Termcap codes. */\nenum tty_code_code {\n\tTTYC_ACSC,\n\tTTYC_AM,\n\tTTYC_AX,\n\tTTYC_BCE,\n\tTTYC_BEL,\n\tTTYC_BIDI,\n\tTTYC_BLINK,\n\tTTYC_BOLD,\n\tTTYC_CIVIS,\n\tTTYC_CLEAR,\n\tTTYC_CLMG,\n\tTTYC_CMG,\n\tTTYC_CNORM,\n\tTTYC_COLORS,\n\tTTYC_CR,\n\tTTYC_CS,\n\tTTYC_CSR,\n\tTTYC_CUB,\n\tTTYC_CUB1,\n\tTTYC_CUD,\n\tTTYC_CUD1,\n\tTTYC_CUF,\n\tTTYC_CUF1,\n\tTTYC_CUP,\n\tTTYC_CUU,\n\tTTYC_CUU1,\n\tTTYC_CVVIS,\n\tTTYC_DCH,\n\tTTYC_DCH1,\n\tTTYC_DIM,\n\tTTYC_DL,\n\tTTYC_DL1,\n\tTTYC_DSBP,\n\tTTYC_DSEKS,\n\tTTYC_DSFCS,\n\tTTYC_DSMG,\n\tTTYC_E3,\n\tTTYC_ECH,\n\tTTYC_ED,\n\tTTYC_EL,\n\tTTYC_EL1,\n\tTTYC_ENACS,\n\tTTYC_ENBP,\n\tTTYC_ENEKS,\n\tTTYC_ENFCS,\n\tTTYC_ENMG,\n\tTTYC_FSL,\n\tTTYC_HLS,\n\tTTYC_HOME,\n\tTTYC_HPA,\n\tTTYC_ICH,\n\tTTYC_ICH1,\n\tTTYC_IL,\n\tTTYC_IL1,\n\tTTYC_INDN,\n\tTTYC_INVIS,\n\tTTYC_KCBT,\n\tTTYC_KCUB1,\n\tTTYC_KCUD1,\n\tTTYC_KCUF1,\n\tTTYC_KCUU1,\n\tTTYC_KDC2,\n\tTTYC_KDC3,\n\tTTYC_KDC4,\n\tTTYC_KDC5,\n\tTTYC_KDC6,\n\tTTYC_KDC7,\n\tTTYC_KDCH1,\n\tTTYC_KDN2,\n\tTTYC_KDN3,\n\tTTYC_KDN4,\n\tTTYC_KDN5,\n\tTTYC_KDN6,\n\tTTYC_KDN7,\n\tTTYC_KEND,\n\tTTYC_KEND2,\n\tTTYC_KEND3,\n\tTTYC_KEND4,\n\tTTYC_KEND5,\n\tTTYC_KEND6,\n\tTTYC_KEND7,\n\tTTYC_KF1,\n\tTTYC_KF10,\n\tTTYC_KF11,\n\tTTYC_KF12,\n\tTTYC_KF13,\n\tTTYC_KF14,\n\tTTYC_KF15,\n\tTTYC_KF16,\n\tTTYC_KF17,\n\tTTYC_KF18,\n\tTTYC_KF19,\n\tTTYC_KF2,\n\tTTYC_KF20,\n\tTTYC_KF21,\n\tTTYC_KF22,\n\tTTYC_KF23,\n\tTTYC_KF24,\n\tTTYC_KF25,\n\tTTYC_KF26,\n\tTTYC_KF27,\n\tTTYC_KF28,\n\tTTYC_KF29,\n\tTTYC_KF3,\n\tTTYC_KF30,\n\tTTYC_KF31,\n\tTTYC_KF32,\n\tTTYC_KF33,\n\tTTYC_KF34,\n\tTTYC_KF35,\n\tTTYC_KF36,\n\tTTYC_KF37,\n\tTTYC_KF38,\n\tTTYC_KF39,\n\tTTYC_KF4,\n\tTTYC_KF40,\n\tTTYC_KF41,\n\tTTYC_KF42,\n\tTTYC_KF43,\n\tTTYC_KF44,\n\tTTYC_KF45,\n\tTTYC_KF46,\n\tTTYC_KF47,\n\tTTYC_KF48,\n\tTTYC_KF49,\n\tTTYC_KF5,\n\tTTYC_KF50,\n\tTTYC_KF51,\n\tTTYC_KF52,\n\tTTYC_KF53,\n\tTTYC_KF54,\n\tTTYC_KF55,\n\tTTYC_KF56,\n\tTTYC_KF57,\n\tTTYC_KF58,\n\tTTYC_KF59,\n\tTTYC_KF6,\n\tTTYC_KF60,\n\tTTYC_KF61,\n\tTTYC_KF62,\n\tTTYC_KF63,\n\tTTYC_KF7,\n\tTTYC_KF8,\n\tTTYC_KF9,\n\tTTYC_KHOM2,\n\tTTYC_KHOM3,\n\tTTYC_KHOM4,\n\tTTYC_KHOM5,\n\tTTYC_KHOM6,\n\tTTYC_KHOM7,\n\tTTYC_KHOME,\n\tTTYC_KIC2,\n\tTTYC_KIC3,\n\tTTYC_KIC4,\n\tTTYC_KIC5,\n\tTTYC_KIC6,\n\tTTYC_KIC7,\n\tTTYC_KICH1,\n\tTTYC_KIND,\n\tTTYC_KLFT2,\n\tTTYC_KLFT3,\n\tTTYC_KLFT4,\n\tTTYC_KLFT5,\n\tTTYC_KLFT6,\n\tTTYC_KLFT7,\n\tTTYC_KMOUS,\n\tTTYC_KNP,\n\tTTYC_KNXT2,\n\tTTYC_KNXT3,\n\tTTYC_KNXT4,\n\tTTYC_KNXT5,\n\tTTYC_KNXT6,\n\tTTYC_KNXT7,\n\tTTYC_KPP,\n\tTTYC_KPRV2,\n\tTTYC_KPRV3,\n\tTTYC_KPRV4,\n\tTTYC_KPRV5,\n\tTTYC_KPRV6,\n\tTTYC_KPRV7,\n\tTTYC_KRI,\n\tTTYC_KRIT2,\n\tTTYC_KRIT3,\n\tTTYC_KRIT4,\n\tTTYC_KRIT5,\n\tTTYC_KRIT6,\n\tTTYC_KRIT7,\n\tTTYC_KUP2,\n\tTTYC_KUP3,\n\tTTYC_KUP4,\n\tTTYC_KUP5,\n\tTTYC_KUP6,\n\tTTYC_KUP7,\n\tTTYC_MS,\n\tTTYC_NOBR,\n\tTTYC_OL,\n\tTTYC_OP,\n\tTTYC_RECT,\n\tTTYC_REV,\n\tTTYC_RGB,\n\tTTYC_RI,\n\tTTYC_RIN,\n\tTTYC_RMACS,\n\tTTYC_RMCUP,\n\tTTYC_RMKX,\n\tTTYC_SE,\n\tTTYC_SETAB,\n\tTTYC_SETAF,\n\tTTYC_SETAL,\n\tTTYC_SETRGBB,\n\tTTYC_SETRGBF,\n\tTTYC_SETULC,\n\tTTYC_SETULC1,\n\tTTYC_SGR0,\n\tTTYC_SITM,\n\tTTYC_SMACS,\n\tTTYC_SMCUP,\n\tTTYC_SMKX,\n\tTTYC_SMOL,\n\tTTYC_SMSO,\n\tTTYC_SMUL,\n\tTTYC_SMULX,\n\tTTYC_SMXX,\n\tTTYC_SXL,\n\tTTYC_SS,\n\tTTYC_SWD,\n\tTTYC_SYNC,\n\tTTYC_TC,\n\tTTYC_TSL,\n\tTTYC_U8,\n\tTTYC_VPA,\n\tTTYC_XT\n};\n\n/* Character classes. */\n#define WHITESPACE \"\\t \"\n\n/* Mode keys. */\n#define MODEKEY_EMACS 0\n#define MODEKEY_VI 1\n\n/* Modes. */\n#define MODE_CURSOR 0x1\n#define MODE_INSERT 0x2\n#define MODE_KCURSOR 0x4\n#define MODE_KKEYPAD 0x8\n#define MODE_WRAP 0x10\n#define MODE_MOUSE_STANDARD 0x20\n#define MODE_MOUSE_BUTTON 0x40\n#define MODE_CURSOR_BLINKING 0x80\n#define MODE_MOUSE_UTF8 0x100\n#define MODE_MOUSE_SGR 0x200\n#define MODE_BRACKETPASTE 0x400\n#define MODE_FOCUSON 0x800\n#define MODE_MOUSE_ALL 0x1000\n#define MODE_ORIGIN 0x2000\n#define MODE_CRLF 0x4000\n#define MODE_KEYS_EXTENDED 0x8000\n#define MODE_CURSOR_VERY_VISIBLE 0x10000\n#define MODE_CURSOR_BLINKING_SET 0x20000\n#define MODE_KEYS_EXTENDED_2 0x40000\n\n#define ALL_MODES 0xffffff\n#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON|MODE_MOUSE_ALL)\n#define MOTION_MOUSE_MODES (MODE_MOUSE_BUTTON|MODE_MOUSE_ALL)\n#define CURSOR_MODES (MODE_CURSOR|MODE_CURSOR_BLINKING|MODE_CURSOR_VERY_VISIBLE)\n#define EXTENDED_KEY_MODES (MODE_KEYS_EXTENDED|MODE_KEYS_EXTENDED_2)\n\n/* Mouse protocol constants. */\n#define MOUSE_PARAM_MAX 0xff\n#define MOUSE_PARAM_UTF8_MAX 0x7ff\n#define MOUSE_PARAM_BTN_OFF 0x20\n#define MOUSE_PARAM_POS_OFF 0x21\n\n/* A single UTF-8 character. */\ntypedef u_int utf8_char;\n\n/*\n * An expanded UTF-8 character. UTF8_SIZE must be big enough to hold combining\n * characters as well. It can't be more than 32 bytes without changes to how\n * characters are stored.\n */\n#define UTF8_SIZE 21\nstruct utf8_data {\n\tu_char\tdata[UTF8_SIZE];\n\n\tu_char\thave;\n\tu_char\tsize;\n\n\tu_char\twidth;\t/* 0xff if invalid */\n};\nenum utf8_state {\n\tUTF8_MORE,\n\tUTF8_DONE,\n\tUTF8_ERROR\n};\n\n/* Colour flags. */\n#define COLOUR_FLAG_256 0x01000000\n#define COLOUR_FLAG_RGB 0x02000000\n\n/* Special colours. */\n#define COLOUR_DEFAULT(c) ((c) == 8 || (c) == 9)\n\n/* Replacement palette. */\nstruct colour_palette {\n\tint\t fg;\n\tint\t bg;\n\n\tint\t*palette;\n\tint\t*default_palette;\n};\n\n/* Grid attributes. Anything above 0xff is stored in an extended cell. */\n#define GRID_ATTR_BRIGHT 0x1\n#define GRID_ATTR_DIM 0x2\n#define GRID_ATTR_UNDERSCORE 0x4\n#define GRID_ATTR_BLINK 0x8\n#define GRID_ATTR_REVERSE 0x10\n#define GRID_ATTR_HIDDEN 0x20\n#define GRID_ATTR_ITALICS 0x40\n#define GRID_ATTR_CHARSET 0x80\t/* alternative character set */\n#define GRID_ATTR_STRIKETHROUGH 0x100\n#define GRID_ATTR_UNDERSCORE_2 0x200\n#define GRID_ATTR_UNDERSCORE_3 0x400\n#define GRID_ATTR_UNDERSCORE_4 0x800\n#define GRID_ATTR_UNDERSCORE_5 0x1000\n#define GRID_ATTR_OVERLINE 0x2000\n\n/* All underscore attributes. */\n#define GRID_ATTR_ALL_UNDERSCORE \\\n\t(GRID_ATTR_UNDERSCORE|\t \\\n\t GRID_ATTR_UNDERSCORE_2| \\\n\t GRID_ATTR_UNDERSCORE_3| \\\n\t GRID_ATTR_UNDERSCORE_4| \\\n\t GRID_ATTR_UNDERSCORE_5)\n\n/* Grid flags. */\n#define GRID_FLAG_FG256 0x1\n#define GRID_FLAG_BG256 0x2\n#define GRID_FLAG_PADDING 0x4\n#define GRID_FLAG_EXTENDED 0x8\n#define GRID_FLAG_SELECTED 0x10\n#define GRID_FLAG_NOPALETTE 0x20\n#define GRID_FLAG_CLEARED 0x40\n#define GRID_FLAG_TAB 0x80\n\n/* Grid line flags. */\n#define GRID_LINE_WRAPPED 0x1\n#define GRID_LINE_EXTENDED 0x2\n#define GRID_LINE_DEAD 0x4\n#define GRID_LINE_START_PROMPT 0x8\n#define GRID_LINE_START_OUTPUT 0x10\n\n/* Grid string flags. */\n#define GRID_STRING_WITH_SEQUENCES 0x1\n#define GRID_STRING_ESCAPE_SEQUENCES 0x2\n#define GRID_STRING_TRIM_SPACES 0x4\n#define GRID_STRING_USED_ONLY 0x8\n#define GRID_STRING_EMPTY_CELLS 0x10\n\n/* Cell positions. */\n#define CELL_INSIDE 0\n#define CELL_TOPBOTTOM 1\n#define CELL_LEFTRIGHT 2\n#define CELL_TOPLEFT 3\n#define CELL_TOPRIGHT 4\n#define CELL_BOTTOMLEFT 5\n#define CELL_BOTTOMRIGHT 6\n#define CELL_TOPJOIN 7\n#define CELL_BOTTOMJOIN 8\n#define CELL_LEFTJOIN 9\n#define CELL_RIGHTJOIN 10\n#define CELL_JOIN 11\n#define CELL_OUTSIDE 12\n#define CELL_SCROLLBAR 13\n\n/* Cell borders. */\n#define CELL_BORDERS \" xqlkmjwvtun~\"\n#define SIMPLE_BORDERS \" |-+++++++++.\"\n#define PADDED_BORDERS \"             \"\n\n/* Grid cell data. */\nstruct grid_cell {\n\tstruct utf8_data\tdata;\n\tu_short\t\t\tattr;\n\tu_char\t\t\tflags;\n\tint\t\t\tfg;\n\tint\t\t\tbg;\n\tint\t\t\tus;\n\tu_int\t\t\tlink;\n};\n\n/* Grid extended cell entry. */\nstruct grid_extd_entry {\n\tutf8_char\t\tdata;\n\tu_short\t\t\tattr;\n\tu_char\t\t\tflags;\n\tint\t\t\tfg;\n\tint\t\t\tbg;\n\tint\t\t\tus;\n\tu_int\t\t\tlink;\n} __packed;\n\n/* Grid cell entry. */\nstruct grid_cell_entry {\n\tunion {\n\t\tu_int\t\toffset;\n\t\tstruct {\n\t\t\tu_char\tattr;\n\t\t\tu_char\tfg;\n\t\t\tu_char\tbg;\n\t\t\tu_char\tdata;\n\t\t} data;\n\t};\n\tu_char\t\t\tflags;\n} __packed;\n\n/* Grid line. */\nstruct grid_line {\n\tstruct grid_cell_entry\t*celldata;\n\tu_int\t\t\t cellused;\n\tu_int\t\t\t cellsize;\n\n\tstruct grid_extd_entry\t*extddata;\n\tu_int\t\t\t extdsize;\n\n\tint\t\t\t flags;\n\ttime_t\t\t\t time;\n};\n\n/* Entire grid of cells. */\nstruct grid {\n\tint\t\t\t flags;\n#define GRID_HISTORY 0x1 /* scroll lines into history */\n\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\n\tu_int\t\t\t hscrolled;\n\tu_int\t\t\t hsize;\n\tu_int\t\t\t hlimit;\n\n\tstruct grid_line\t*linedata;\n};\n\n/* Virtual cursor in a grid. */\nstruct grid_reader {\n\tstruct grid\t*gd;\n\tu_int\t\t cx;\n\tu_int\t\t cy;\n};\n\n/* Style alignment. */\nenum style_align {\n\tSTYLE_ALIGN_DEFAULT,\n\tSTYLE_ALIGN_LEFT,\n\tSTYLE_ALIGN_CENTRE,\n\tSTYLE_ALIGN_RIGHT,\n\tSTYLE_ALIGN_ABSOLUTE_CENTRE\n};\n\n/* Style list. */\nenum style_list {\n\tSTYLE_LIST_OFF,\n\tSTYLE_LIST_ON,\n\tSTYLE_LIST_FOCUS,\n\tSTYLE_LIST_LEFT_MARKER,\n\tSTYLE_LIST_RIGHT_MARKER,\n};\n\n/* Style range. */\nenum style_range_type {\n\tSTYLE_RANGE_NONE,\n\tSTYLE_RANGE_LEFT,\n\tSTYLE_RANGE_RIGHT,\n\tSTYLE_RANGE_PANE,\n\tSTYLE_RANGE_WINDOW,\n\tSTYLE_RANGE_SESSION,\n\tSTYLE_RANGE_USER\n};\nstruct style_range {\n\tenum style_range_type\t type;\n\tu_int\t\t\t argument;\n\tchar\t\t\t string[16];\n\n\tu_int\t\t\t start;\n\tu_int\t\t\t end; /* not included */\n\n\tTAILQ_ENTRY(style_range) entry;\n};\nTAILQ_HEAD(style_ranges, style_range);\n\n/* Default style width and pad. */\n#define STYLE_WIDTH_DEFAULT -1\n#define STYLE_PAD_DEFAULT -1\n\n/* Style default. */\nenum style_default_type {\n\tSTYLE_DEFAULT_BASE,\n\tSTYLE_DEFAULT_PUSH,\n\tSTYLE_DEFAULT_POP\n};\n\n/* Style option. */\nstruct style {\n\tstruct grid_cell\tgc;\n\tint\t\t\tignore;\n\n\tint\t\t\tfill;\n\tenum style_align\talign;\n\tenum style_list\t\tlist;\n\n\tenum style_range_type\trange_type;\n\tu_int\t\t\trange_argument;\n\tchar\t\t\trange_string[16];\n\n\tint\t\t\twidth;\n\tint\t\t\tpad;\n\n\tenum style_default_type\tdefault_type;\n};\n\n#ifdef ENABLE_SIXEL\n/* Image. */\nstruct image {\n\tstruct screen\t\t*s;\n\tstruct sixel_image\t*data;\n\tchar\t\t\t*fallback;\n\n\tu_int\t\t\t px;\n\tu_int\t\t\t py;\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\n\tTAILQ_ENTRY (image)\t all_entry;\n\tTAILQ_ENTRY (image)\t entry;\n};\nTAILQ_HEAD(images, image);\n#endif\n\n/* Cursor style. */\nenum screen_cursor_style {\n\tSCREEN_CURSOR_DEFAULT,\n\tSCREEN_CURSOR_BLOCK,\n\tSCREEN_CURSOR_UNDERLINE,\n\tSCREEN_CURSOR_BAR\n};\n\n/* Virtual screen. */\nstruct screen_sel;\nstruct screen_titles;\nstruct screen {\n\tchar\t\t\t\t*title;\n\tchar *path;\n\tstruct screen_titles\t\t*titles;\n\n\tstruct grid\t\t\t*grid;\t  /* grid data */\n\n\tu_int\t\t\t\t cx;\t  /* cursor x */\n\tu_int\t\t\t\t cy;\t  /* cursor y */\n\n\tenum screen_cursor_style\t cstyle;  /* cursor style */\n\tenum screen_cursor_style\t default_cstyle;\n\tint\t\t\t\t ccolour; /* cursor colour */\n\tint\t\t\t\t default_ccolour;\n\n\tu_int\t\t\t\t rupper;  /* scroll region top */\n\tu_int\t\t\t\t rlower;  /* scroll region bottom */\n\n\tint\t\t\t\t mode;\n\tint\t\t\t\t default_mode;\n\n\tu_int\t\t\t\t saved_cx;\n\tu_int\t\t\t\t saved_cy;\n\tstruct grid\t\t\t*saved_grid;\n\tstruct grid_cell\t\t saved_cell;\n\tint\t\t\t\t saved_flags;\n\n\tbitstr_t\t\t\t*tabs;\n\tstruct screen_sel\t\t*sel;\n\n#ifdef ENABLE_SIXEL\n\tstruct images\t\t\t images;\n#endif\n\n\tstruct screen_write_cline\t*write_list;\n\n\tstruct hyperlinks\t\t*hyperlinks;\n};\n\n/* Screen write context. */\ntypedef void (*screen_write_init_ctx_cb)(struct screen_write_ctx *,\n    struct tty_ctx *);\nstruct screen_write_ctx {\n\tstruct window_pane\t\t*wp;\n\tstruct screen\t\t\t*s;\n\n\tint\t\t\t\t flags;\n#define SCREEN_WRITE_SYNC 0x1\n\n\tscreen_write_init_ctx_cb\t init_ctx_cb;\n\tvoid\t\t\t\t*arg;\n\n\tstruct screen_write_citem\t*item;\n\tu_int\t\t\t\t scrolled;\n\tu_int\t\t\t\t bg;\n};\n\n/* Box border lines option. */\nenum box_lines {\n\tBOX_LINES_DEFAULT = -1,\n\tBOX_LINES_SINGLE,\n\tBOX_LINES_DOUBLE,\n\tBOX_LINES_HEAVY,\n\tBOX_LINES_SIMPLE,\n\tBOX_LINES_ROUNDED,\n\tBOX_LINES_PADDED,\n\tBOX_LINES_NONE\n};\n\n/* Pane border lines option. */\nenum pane_lines {\n\tPANE_LINES_SINGLE,\n\tPANE_LINES_DOUBLE,\n\tPANE_LINES_HEAVY,\n\tPANE_LINES_SIMPLE,\n\tPANE_LINES_NUMBER\n};\n\n/* Pane border indicator option. */\n#define PANE_BORDER_OFF 0\n#define PANE_BORDER_COLOUR 1\n#define PANE_BORDER_ARROWS 2\n#define PANE_BORDER_BOTH 3\n\n/* Mode returned by window_pane_mode function. */\n#define WINDOW_PANE_NO_MODE 0\n#define WINDOW_PANE_COPY_MODE 1\n#define WINDOW_PANE_VIEW_MODE 2\n\n/* Screen redraw context. */\nstruct screen_redraw_ctx {\n\tstruct client\t*c;\n\n\tu_int\t\t statuslines;\n\tint\t\t statustop;\n\n\tint\t\t pane_status;\n\tenum pane_lines\t pane_lines;\n\n\tint\t\t pane_scrollbars;\n\tint\t\t pane_scrollbars_pos;\n\n\tstruct grid_cell no_pane_gc;\n\tint\t\t no_pane_gc_set;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\tu_int\t\t ox;\n\tu_int\t\t oy;\n};\n\n/* Screen size. */\n#define screen_size_x(s) ((s)->grid->sx)\n#define screen_size_y(s) ((s)->grid->sy)\n#define screen_hsize(s) ((s)->grid->hsize)\n#define screen_hlimit(s) ((s)->grid->hlimit)\n\n/* Menu. */\nstruct menu_item {\n\tconst char\t*name;\n\tkey_code\t key;\n\tconst char\t*command;\n};\nstruct menu {\n\tconst char\t\t*title;\n\tstruct menu_item\t*items;\n\tu_int\t\t\t count;\n\tu_int\t\t\t width;\n};\ntypedef void (*menu_choice_cb)(struct menu *, u_int, key_code, void *);\n\n/*\n * Window mode. Windows can be in several modes and this is used to call the\n * right function to handle input and output.\n */\nstruct window_mode_entry;\nstruct window_mode {\n\tconst char\t*name;\n\tconst char\t*default_format;\n\n\tstruct screen\t*(*init)(struct window_mode_entry *,\n\t\t\t     struct cmd_find_state *, struct args *);\n\tvoid\t\t (*free)(struct window_mode_entry *);\n\tvoid\t\t (*resize)(struct window_mode_entry *, u_int, u_int);\n\tvoid\t\t (*update)(struct window_mode_entry *);\n\tvoid\t\t (*key)(struct window_mode_entry *, struct client *,\n\t\t\t     struct session *, struct winlink *, key_code,\n\t\t\t     struct mouse_event *);\n\n\tconst char\t*(*key_table)(struct window_mode_entry *);\n\tvoid\t\t (*command)(struct window_mode_entry *, struct client *,\n\t\t\t     struct session *, struct winlink *, struct args *,\n\t\t\t     struct mouse_event *);\n\tvoid\t\t (*formats)(struct window_mode_entry *,\n\t\t\t     struct format_tree *);\n};\n\n/* Active window mode. */\nstruct window_mode_entry {\n\tstruct window_pane\t\t*wp;\n\tstruct window_pane\t\t*swp;\n\n\tconst struct window_mode\t*mode;\n\tvoid\t\t\t\t*data;\n\n\tstruct screen\t\t\t*screen;\n\tu_int\t\t\t\t prefix;\n\n\tTAILQ_ENTRY(window_mode_entry)\t entry;\n};\n\n/* Offsets into pane buffer. */\nstruct window_pane_offset {\n\tsize_t\tused;\n};\n\n/* Queued pane resize. */\nstruct window_pane_resize {\n\tu_int\t\t\t\tsx;\n\tu_int\t\t\t\tsy;\n\n\tu_int\t\t\t\tosx;\n\tu_int\t\t\t\tosy;\n\n\tTAILQ_ENTRY(window_pane_resize)\tentry;\n};\nTAILQ_HEAD(window_pane_resizes, window_pane_resize);\n\n/* Child window structure. */\nstruct window_pane {\n\tu_int\t\t id;\n\tu_int\t\t active_point;\n\n\tstruct window\t*window;\n\tstruct options\t*options;\n\n\tstruct layout_cell *layout_cell;\n\tstruct layout_cell *saved_layout_cell;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t xoff;\n\tu_int\t\t yoff;\n\n\tint\t\t flags;\n#define PANE_REDRAW 0x1\n#define PANE_DROP 0x2\n#define PANE_FOCUSED 0x4\n#define PANE_VISITED 0x8\n/* 0x10 unused */\n/* 0x20 unused */\n#define PANE_INPUTOFF 0x40\n#define PANE_CHANGED 0x80\n#define PANE_EXITED 0x100\n#define PANE_STATUSREADY 0x200\n#define PANE_STATUSDRAWN 0x400\n#define PANE_EMPTY 0x800\n#define PANE_STYLECHANGED 0x1000\n#define PANE_UNSEENCHANGES 0x2000\n#define PANE_REDRAWSCROLLBAR 0x4000\n\n\tu_int\t\t sb_slider_y;\n\tu_int\t\t sb_slider_h;\n\n\tint\t\t argc;\n\tchar\t       **argv;\n\tchar\t\t*shell;\n\tchar\t\t*cwd;\n\n\tpid_t\t\t pid;\n\tchar\t\t tty[TTY_NAME_MAX];\n\tint\t\t status;\n\tstruct timeval\t dead_time;\n\n\tint\t\t fd;\n\tstruct bufferevent *event;\n\n\tstruct window_pane_offset offset;\n\tsize_t\t\t base_offset;\n\n\tstruct window_pane_resizes resize_queue;\n\tstruct event\t resize_timer;\n\n\tstruct input_ctx *ictx;\n\n\tstruct grid_cell cached_gc;\n\tstruct grid_cell cached_active_gc;\n\tstruct colour_palette palette;\n\n\tint\t\t pipe_fd;\n\tstruct bufferevent *pipe_event;\n\tstruct window_pane_offset pipe_offset;\n\n\tstruct screen\t*screen;\n\tstruct screen\t base;\n\n\tstruct screen\t status_screen;\n\tsize_t\t\t status_size;\n\n\tTAILQ_HEAD(, window_mode_entry) modes;\n\n\tchar\t\t*searchstr;\n\tint\t\t searchregex;\n\n\tint\t\t border_gc_set;\n\tstruct grid_cell border_gc;\n\n\tint\t\t control_bg;\n\tint\t\t control_fg;\n\n\tstruct style\t scrollbar_style;\n\n\tTAILQ_ENTRY(window_pane) entry;  /* link in list of all panes */\n\tTAILQ_ENTRY(window_pane) sentry; /* link in list of last visited */\n\tRB_ENTRY(window_pane) tree_entry;\n};\nTAILQ_HEAD(window_panes, window_pane);\nRB_HEAD(window_pane_tree, window_pane);\n\n/* Window structure. */\nstruct window {\n\tu_int\t\t\t id;\n\tvoid\t\t\t*latest;\n\n\tchar\t\t\t*name;\n\tstruct event\t\t name_event;\n\tstruct timeval\t\t name_time;\n\n\tstruct event\t\t alerts_timer;\n\tstruct event\t\t offset_timer;\n\n\tstruct timeval\t\t activity_time;\n\n\tstruct window_pane\t*active;\n\tstruct window_panes \t last_panes;\n\tstruct window_panes\t panes;\n\n\tint\t\t\t lastlayout;\n\tstruct layout_cell\t*layout_root;\n\tstruct layout_cell\t*saved_layout_root;\n\tchar\t\t\t*old_layout;\n\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\tu_int\t\t\t manual_sx;\n\tu_int\t\t\t manual_sy;\n\tu_int\t\t\t xpixel;\n\tu_int\t\t\t ypixel;\n\n\tu_int\t\t\t new_sx;\n\tu_int\t\t\t new_sy;\n\tu_int\t\t\t new_xpixel;\n\tu_int\t\t\t new_ypixel;\n\n\tstruct utf8_data\t*fill_character;\n\tint\t\t\t flags;\n#define WINDOW_BELL 0x1\n#define WINDOW_ACTIVITY 0x2\n#define WINDOW_SILENCE 0x4\n#define WINDOW_ZOOMED 0x8\n#define WINDOW_WASZOOMED 0x10\n#define WINDOW_RESIZE 0x20\n#define WINDOW_ALERTFLAGS (WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_SILENCE)\n\n\tint\t\t\t alerts_queued;\n\tTAILQ_ENTRY(window)\t alerts_entry;\n\n\tstruct options\t\t*options;\n\n\tu_int\t\t\t references;\n\tTAILQ_HEAD(, winlink)\t winlinks;\n\n\tRB_ENTRY(window)\t entry;\n};\nRB_HEAD(windows, window);\n\n/* Entry on local window list. */\nstruct winlink {\n\tint\t\t idx;\n\tstruct session\t*session;\n\tstruct window\t*window;\n\n\tint\t\t flags;\n#define WINLINK_BELL 0x1\n#define WINLINK_ACTIVITY 0x2\n#define WINLINK_SILENCE 0x4\n#define WINLINK_ALERTFLAGS (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_SILENCE)\n#define WINLINK_VISITED 0x8\n\n\tRB_ENTRY(winlink) entry;\n\tTAILQ_ENTRY(winlink) wentry;\n\tTAILQ_ENTRY(winlink) sentry;\n};\nRB_HEAD(winlinks, winlink);\nTAILQ_HEAD(winlink_stack, winlink);\n\n/* Window size option. */\n#define WINDOW_SIZE_LARGEST 0\n#define WINDOW_SIZE_SMALLEST 1\n#define WINDOW_SIZE_MANUAL 2\n#define WINDOW_SIZE_LATEST 3\n\n/* Pane border status option. */\n#define PANE_STATUS_OFF 0\n#define PANE_STATUS_TOP 1\n#define PANE_STATUS_BOTTOM 2\n\n/* Pane scrollbars option. */\n#define PANE_SCROLLBARS_OFF 0\n#define PANE_SCROLLBARS_MODAL 1\n#define PANE_SCROLLBARS_ALWAYS 2\n\n/* Pane scrollbars position option. */\n#define PANE_SCROLLBARS_RIGHT 0\n#define PANE_SCROLLBARS_LEFT 1\n\n/* Pane scrollbars width, padding and fill character. */\n#define PANE_SCROLLBARS_DEFAULT_PADDING 0\n#define PANE_SCROLLBARS_DEFAULT_WIDTH 1\n#define PANE_SCROLLBARS_CHARACTER ' '\n\n/* True if screen in alternate screen. */\n#define SCREEN_IS_ALTERNATE(s) ((s)->saved_grid != NULL)\n\n/* Layout direction. */\nenum layout_type {\n\tLAYOUT_LEFTRIGHT,\n\tLAYOUT_TOPBOTTOM,\n\tLAYOUT_WINDOWPANE\n};\n\n/* Layout cells queue. */\nTAILQ_HEAD(layout_cells, layout_cell);\n\n/* Layout cell. */\nstruct layout_cell {\n\tenum layout_type type;\n\n\tstruct layout_cell *parent;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t xoff;\n\tu_int\t\t yoff;\n\n\tstruct window_pane *wp;\n\tstruct layout_cells cells;\n\n\tTAILQ_ENTRY(layout_cell) entry;\n};\n\n/* Environment variable. */\nstruct environ_entry {\n\tchar\t\t*name;\n\tchar\t\t*value;\n\n\tint\t\t flags;\n#define ENVIRON_HIDDEN 0x1\n\n\tRB_ENTRY(environ_entry) entry;\n};\n\n/* Client session. */\nstruct session_group {\n\tconst char\t\t*name;\n\tTAILQ_HEAD(, session)\t sessions;\n\n\tRB_ENTRY(session_group)\t entry;\n};\nRB_HEAD(session_groups, session_group);\n\nstruct session {\n\tu_int\t\t id;\n\n\tchar\t\t*name;\n\tconst char\t*cwd;\n\n\tstruct timeval\t creation_time;\n\tstruct timeval\t last_attached_time;\n\tstruct timeval\t activity_time;\n\tstruct timeval\t last_activity_time;\n\n\tstruct event\t lock_timer;\n\n\tstruct winlink\t*curw;\n\tstruct winlink_stack lastw;\n\tstruct winlinks\t windows;\n\n\tint\t\t statusat;\n\tu_int\t\t statuslines;\n\n\tstruct options\t*options;\n\n#define SESSION_ALERTED 0x1\n\tint\t\t flags;\n\n\tu_int\t\t attached;\n\n\tstruct termios\t*tio;\n\n\tstruct environ\t*environ;\n\n\tint\t\t references;\n\n\tTAILQ_ENTRY(session) gentry;\n\tRB_ENTRY(session)    entry;\n};\nRB_HEAD(sessions, session);\n\n/* Mouse button masks. */\n#define MOUSE_MASK_BUTTONS 195\n#define MOUSE_MASK_SHIFT 4\n#define MOUSE_MASK_META 8\n#define MOUSE_MASK_CTRL 16\n#define MOUSE_MASK_DRAG 32\n#define MOUSE_MASK_MODIFIERS (MOUSE_MASK_SHIFT|MOUSE_MASK_META|MOUSE_MASK_CTRL)\n\n/* Mouse wheel type. */\n#define MOUSE_WHEEL_UP 64\n#define MOUSE_WHEEL_DOWN 65\n\n/* Mouse button type. */\n#define MOUSE_BUTTON_1 0\n#define MOUSE_BUTTON_2 1\n#define MOUSE_BUTTON_3 2\n#define MOUSE_BUTTON_6 66\n#define MOUSE_BUTTON_7 67\n#define MOUSE_BUTTON_8 128\n#define MOUSE_BUTTON_9 129\n#define MOUSE_BUTTON_10 130\n#define MOUSE_BUTTON_11 131\n\n/* Mouse helpers. */\n#define MOUSE_BUTTONS(b) ((b) & MOUSE_MASK_BUTTONS)\n#define MOUSE_WHEEL(b) \\\n\t(((b) & MOUSE_MASK_BUTTONS) == MOUSE_WHEEL_UP || \\\n\t ((b) & MOUSE_MASK_BUTTONS) == MOUSE_WHEEL_DOWN)\n#define MOUSE_DRAG(b) ((b) & MOUSE_MASK_DRAG)\n#define MOUSE_RELEASE(b) (((b) & MOUSE_MASK_BUTTONS) == 3)\n\n/* Mouse input. */\nstruct mouse_event {\n\tint\t\tvalid;\n\tint\t\tignore;\n\n\tkey_code\tkey;\n\n\tint\t\tstatusat;\n\tu_int\t\tstatuslines;\n\n\tu_int\t\tx;\n\tu_int\t\ty;\n\tu_int\t\tb;\n\n\tu_int\t\tlx;\n\tu_int\t\tly;\n\tu_int\t\tlb;\n\n\tu_int\t\tox;\n\tu_int\t\toy;\n\n\tint\t\ts;\n\tint\t\tw;\n\tint\t\twp;\n\n\tu_int\t\tsgr_type;\n\tu_int\t\tsgr_b;\n};\n\n/* Key event. */\nstruct key_event {\n\tkey_code\t\t key;\n\tstruct mouse_event\t m;\n\n\tchar\t\t\t*buf;\n\tsize_t\t\t\t len;\n};\n\n/* Terminal definition. */\nstruct tty_term {\n\tchar\t\t*name;\n\tstruct tty\t*tty;\n\tint\t\t features;\n\n\tchar\t\t acs[UCHAR_MAX + 1][2];\n\n\tstruct tty_code\t*codes;\n\n#define TERM_256COLOURS 0x1\n#define TERM_NOAM 0x2\n#define TERM_DECSLRM 0x4\n#define TERM_DECFRA 0x8\n#define TERM_RGBCOLOURS 0x10\n#define TERM_VT100LIKE 0x20\n#define TERM_SIXEL 0x40\n\tint\t\t flags;\n\n\tLIST_ENTRY(tty_term) entry;\n};\nLIST_HEAD(tty_terms, tty_term);\n\n/* Client terminal. */\nstruct tty {\n\tstruct client\t*client;\n\tstruct event\t start_timer;\n\tstruct event\t clipboard_timer;\n\ttime_t\t\t last_requests;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n        /* Cell size in pixels. */\n\tu_int\t\t xpixel;\n\tu_int\t\t ypixel;\n\n\tu_int\t\t cx;\n\tu_int\t\t cy;\n\tenum screen_cursor_style cstyle;\n\tint\t\t ccolour;\n\n        /* Properties of the area being drawn on. */\n        /* When true, the drawing area is bigger than the terminal. */\n\tint\t\t oflag;\n\tu_int\t\t oox;\n\tu_int\t\t ooy;\n\tu_int\t\t osx;\n\tu_int\t\t osy;\n\n\tint\t\t mode;\n\tint              fg;\n\tint              bg;\n\n\tu_int\t\t rlower;\n\tu_int\t\t rupper;\n\n\tu_int\t\t rleft;\n\tu_int\t\t rright;\n\n\tstruct event\t event_in;\n\tstruct evbuffer\t*in;\n\tstruct event\t event_out;\n\tstruct evbuffer\t*out;\n\tstruct event\t timer;\n\tsize_t\t\t discarded;\n\n\tstruct termios\t tio;\n\n\tstruct grid_cell cell;\n\tstruct grid_cell last_cell;\n\n#define TTY_NOCURSOR 0x1\n#define TTY_FREEZE 0x2\n#define TTY_TIMER 0x4\n#define TTY_NOBLOCK 0x8\n#define TTY_STARTED 0x10\n#define TTY_OPENED 0x20\n#define TTY_OSC52QUERY 0x40\n#define TTY_BLOCK 0x80\n#define TTY_HAVEDA 0x100 /* Primary DA. */\n#define TTY_HAVEXDA 0x200\n#define TTY_SYNCING 0x400\n#define TTY_HAVEDA2 0x800 /* Secondary DA. */\n#define TTY_WINSIZEQUERY 0x1000\n#define TTY_ALL_REQUEST_FLAGS \\\n\t(TTY_HAVEDA|TTY_HAVEDA2|TTY_HAVEXDA)\n\tint\t\t flags;\n\n\tstruct tty_term\t*term;\n\n\tu_int\t\t mouse_last_x;\n\tu_int\t\t mouse_last_y;\n\tu_int\t\t mouse_last_b;\n\tint\t\t mouse_drag_flag;\n\tint\t\t mouse_scrolling_flag;\n\tint\t\t mouse_slider_mpos;\n\n\tvoid\t\t(*mouse_drag_update)(struct client *,\n\t\t\t    struct mouse_event *);\n\tvoid\t\t(*mouse_drag_release)(struct client *,\n\t\t\t    struct mouse_event *);\n\n\tstruct event\t key_timer;\n\tstruct tty_key\t*key_tree;\n};\n\n/* Terminal command context. */\ntypedef void (*tty_ctx_redraw_cb)(const struct tty_ctx *);\ntypedef int (*tty_ctx_set_client_cb)(struct tty_ctx *, struct client *);\nstruct tty_ctx {\n\tstruct screen\t\t*s;\n\n\ttty_ctx_redraw_cb\t redraw_cb;\n\ttty_ctx_set_client_cb\t set_client_cb;\n\tvoid\t\t\t*arg;\n\n\tconst struct grid_cell\t*cell;\n\tint\t\t\t wrapped;\n\n\tu_int\t\t\t num;\n\tvoid\t\t\t*ptr;\n\tvoid\t\t\t*ptr2;\n\n\t/*\n\t * Whether this command should be sent even when the pane is not\n\t * visible (used for a passthrough sequence when allow-passthrough is\n\t * \"all\").\n\t */\n\tint\t\t\t allow_invisible_panes;\n\n\t/*\n\t * Cursor and region position before the screen was updated - this is\n\t * where the command should be applied; the values in the screen have\n\t * already been updated.\n\t */\n\tu_int\t\t\t ocx;\n\tu_int\t\t\t ocy;\n\n\tu_int\t\t\t orupper;\n\tu_int\t\t\t orlower;\n\n\t/* Target region (usually pane) offset and size. */\n\tu_int\t\t\t xoff;\n\tu_int\t\t\t yoff;\n\tu_int\t\t\t rxoff;\n\tu_int\t\t\t ryoff;\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\n\t/* The background colour used for clearing (erasing). */\n\tu_int\t\t\t bg;\n\n\t/* The default colours and palette. */\n\tstruct grid_cell\t defaults;\n\tstruct colour_palette\t*palette;\n\n\t/* Containing region (usually window) offset and size. */\n\tint\t\t\t bigger;\n\tu_int\t\t\t wox;\n\tu_int\t\t\t woy;\n\tu_int\t\t\t wsx;\n\tu_int\t\t\t wsy;\n};\n\n/* Saved message entry. */\nstruct message_entry {\n\tchar\t\t\t\t*msg;\n\tu_int\t\t\t\t msg_num;\n\tstruct timeval\t\t\t msg_time;\n\n\tTAILQ_ENTRY(message_entry)\t entry;\n};\nTAILQ_HEAD(message_list, message_entry);\n\n/* Argument type. */\nenum args_type {\n\tARGS_NONE,\n\tARGS_STRING,\n\tARGS_COMMANDS\n};\n\n/* Argument value. */\nstruct args_value {\n\tenum args_type\t\t type;\n\tunion {\n\t\tchar\t\t*string;\n\t\tstruct cmd_list\t*cmdlist;\n\t};\n\tchar\t\t\t*cached;\n\tTAILQ_ENTRY(args_value)\t entry;\n};\n\n/* Arguments set. */\nstruct args_entry;\nRB_HEAD(args_tree, args_entry);\n\n/* Arguments parsing type. */\nenum args_parse_type {\n\tARGS_PARSE_INVALID,\n\tARGS_PARSE_STRING,\n\tARGS_PARSE_COMMANDS_OR_STRING,\n\tARGS_PARSE_COMMANDS\n};\n\n/* Arguments parsing state. */\ntypedef enum args_parse_type (*args_parse_cb)(struct args *, u_int, char **);\nstruct args_parse {\n\tconst char\t*template;\n\tint\t\t lower;\n\tint\t\t upper;\n\targs_parse_cb\t cb;\n};\n\n/* Command find structures. */\nenum cmd_find_type {\n\tCMD_FIND_PANE,\n\tCMD_FIND_WINDOW,\n\tCMD_FIND_SESSION,\n};\nstruct cmd_find_state {\n\tint\t\t\t flags;\n\tstruct cmd_find_state\t*current;\n\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tint\t\t\t idx;\n};\n\n/* Command find flags. */\n#define CMD_FIND_PREFER_UNATTACHED 0x1\n#define CMD_FIND_QUIET 0x2\n#define CMD_FIND_WINDOW_INDEX 0x4\n#define CMD_FIND_DEFAULT_MARKED 0x8\n#define CMD_FIND_EXACT_SESSION 0x10\n#define CMD_FIND_EXACT_WINDOW 0x20\n#define CMD_FIND_CANFAIL 0x40\n\n/* List of commands. */\nstruct cmd_list {\n\tint\t\t references;\n\tu_int\t\t group;\n\tstruct cmds\t*list;\n};\n\n/* Command return values. */\nenum cmd_retval {\n\tCMD_RETURN_ERROR = -1,\n\tCMD_RETURN_NORMAL = 0,\n\tCMD_RETURN_WAIT,\n\tCMD_RETURN_STOP\n};\n\n/* Command parse result. */\nenum cmd_parse_status {\n\tCMD_PARSE_ERROR,\n\tCMD_PARSE_SUCCESS\n};\nstruct cmd_parse_result {\n\tenum cmd_parse_status\t status;\n\tstruct cmd_list\t\t*cmdlist;\n\tchar\t\t\t*error;\n};\nstruct cmd_parse_input {\n\tint\t\t\t flags;\n#define CMD_PARSE_QUIET 0x1\n#define CMD_PARSE_PARSEONLY 0x2\n#define CMD_PARSE_NOALIAS 0x4\n#define CMD_PARSE_VERBOSE 0x8\n#define CMD_PARSE_ONEGROUP 0x10\n\n\tconst char\t\t*file;\n\tu_int\t\t\t line;\n\n\tstruct cmdq_item\t*item;\n\tstruct client\t\t*c;\n\tstruct cmd_find_state\t fs;\n};\n\n/* Command queue flags. */\n#define CMDQ_STATE_REPEAT 0x1\n#define CMDQ_STATE_CONTROL 0x2\n#define CMDQ_STATE_NOHOOKS 0x4\n\n/* Command queue callback. */\ntypedef enum cmd_retval (*cmdq_cb) (struct cmdq_item *, void *);\n\n/* Command definition flag. */\nstruct cmd_entry_flag {\n\tchar\t\t\t flag;\n\tenum cmd_find_type\t type;\n\tint\t\t\t flags;\n};\n\n/* Command definition. */\nstruct cmd_entry {\n\tconst char\t\t*name;\n\tconst char\t\t*alias;\n\n\tstruct args_parse\t args;\n\tconst char\t\t*usage;\n\n\tstruct cmd_entry_flag\t source;\n\tstruct cmd_entry_flag\t target;\n\n#define CMD_STARTSERVER 0x1\n#define CMD_READONLY 0x2\n#define CMD_AFTERHOOK 0x4\n#define CMD_CLIENT_CFLAG 0x8\n#define CMD_CLIENT_TFLAG 0x10\n#define CMD_CLIENT_CANFAIL 0x20\n\tint\t\t flags;\n\n\tenum cmd_retval\t (*exec)(struct cmd *, struct cmdq_item *);\n};\n\n/* Status line. */\n#define STATUS_LINES_LIMIT 5\nstruct status_line_entry {\n\tchar\t\t\t*expanded;\n\tstruct style_ranges\t ranges;\n};\nstruct status_line {\n\tstruct event\t\t timer;\n\n\tstruct screen\t\t screen;\n\tstruct screen\t\t*active;\n\tint\t\t\t references;\n\n\tstruct grid_cell\t style;\n\tstruct status_line_entry entries[STATUS_LINES_LIMIT];\n};\n\n/* Prompt type. */\n#define PROMPT_NTYPES 4\nenum prompt_type {\n\tPROMPT_TYPE_COMMAND,\n\tPROMPT_TYPE_SEARCH,\n\tPROMPT_TYPE_TARGET,\n\tPROMPT_TYPE_WINDOW_TARGET,\n\tPROMPT_TYPE_INVALID = 0xff\n};\n\n/* File in client. */\ntypedef void (*client_file_cb) (struct client *, const char *, int, int,\n    struct evbuffer *, void *);\nstruct client_file {\n\tstruct client\t\t\t*c;\n\tstruct tmuxpeer\t\t\t*peer;\n\tstruct client_files\t\t*tree;\n\tint\t\t\t\t references;\n\tint\t\t\t\t stream;\n\n\tchar\t\t\t\t*path;\n\tstruct evbuffer\t\t\t*buffer;\n\tstruct bufferevent\t\t*event;\n\n\tint\t\t\t\t fd;\n\tint\t\t\t\t error;\n\tint\t\t\t\t closed;\n\n\tclient_file_cb\t\t\t cb;\n\tvoid\t\t\t\t*data;\n\n\tRB_ENTRY(client_file)\t\t entry;\n};\nRB_HEAD(client_files, client_file);\n\n/* Client window. */\nstruct client_window {\n\tu_int\t\t\t window;\n\tstruct window_pane\t*pane;\n\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\n\tRB_ENTRY(client_window)\t entry;\n};\nRB_HEAD(client_windows, client_window);\n\n/* Visible areas not obstructed by overlays. */\n#define OVERLAY_MAX_RANGES 3\nstruct overlay_ranges {\n\tu_int\tpx[OVERLAY_MAX_RANGES];\n\tu_int\tnx[OVERLAY_MAX_RANGES];\n};\n\n/* Client connection. */\ntypedef int (*prompt_input_cb)(struct client *, void *, const char *, int);\ntypedef void (*prompt_free_cb)(void *);\ntypedef void (*overlay_check_cb)(struct client*, void *, u_int, u_int, u_int,\n\t    struct overlay_ranges *);\ntypedef struct screen *(*overlay_mode_cb)(struct client *, void *, u_int *,\n\t    u_int *);\ntypedef void (*overlay_draw_cb)(struct client *, void *,\n\t    struct screen_redraw_ctx *);\ntypedef int (*overlay_key_cb)(struct client *, void *, struct key_event *);\ntypedef void (*overlay_free_cb)(struct client *, void *);\ntypedef void (*overlay_resize_cb)(struct client *, void *);\nstruct client {\n\tconst char\t\t*name;\n\tstruct tmuxpeer\t\t*peer;\n\tstruct cmdq_list\t*queue;\n\n\tstruct client_windows\t windows;\n\n\tstruct control_state\t*control_state;\n\tu_int\t\t\t pause_age;\n\n\tpid_t\t\t\t pid;\n\tint\t\t\t fd;\n\tint\t\t\t out_fd;\n\tstruct event\t\t event;\n\tint\t\t\t retval;\n\n\tstruct timeval\t\t creation_time;\n\tstruct timeval\t\t activity_time;\n\tstruct timeval\t \t last_activity_time;\n\n\tstruct environ\t\t*environ;\n\tstruct format_job_tree\t*jobs;\n\n\tchar\t\t\t*title;\n\tchar\t\t\t*path;\n\tconst char\t\t*cwd;\n\n\tchar\t\t\t*term_name;\n\tint\t\t\t term_features;\n\tchar\t\t\t*term_type;\n\tchar\t\t       **term_caps;\n\tu_int\t\t\t term_ncaps;\n\n\tchar\t\t\t*ttyname;\n\tstruct tty\t\t tty;\n\n\tsize_t\t\t\t written;\n\tsize_t\t\t\t discarded;\n\tsize_t\t\t\t redraw;\n\n\tstruct event\t\t repeat_timer;\n\n\tstruct event\t\t click_timer;\n\tu_int\t\t\t click_button;\n\tstruct mouse_event\t click_event;\n\n\tstruct status_line\t status;\n\n#define CLIENT_TERMINAL 0x1\n#define CLIENT_LOGIN 0x2\n#define CLIENT_EXIT 0x4\n#define CLIENT_REDRAWWINDOW 0x8\n#define CLIENT_REDRAWSTATUS 0x10\n#define CLIENT_REPEAT 0x20\n#define CLIENT_SUSPENDED 0x40\n#define CLIENT_ATTACHED 0x80\n#define CLIENT_EXITED 0x100\n#define CLIENT_DEAD 0x200\n#define CLIENT_REDRAWBORDERS 0x400\n#define CLIENT_READONLY 0x800\n#define CLIENT_NOSTARTSERVER 0x1000\n#define CLIENT_CONTROL 0x2000\n#define CLIENT_CONTROLCONTROL 0x4000\n#define CLIENT_FOCUSED 0x8000\n#define CLIENT_UTF8 0x10000\n#define CLIENT_IGNORESIZE 0x20000\n#define CLIENT_IDENTIFIED 0x40000\n#define CLIENT_STATUSFORCE 0x80000\n#define CLIENT_DOUBLECLICK 0x100000\n#define CLIENT_TRIPLECLICK 0x200000\n#define CLIENT_SIZECHANGED 0x400000\n#define CLIENT_STATUSOFF 0x800000\n#define CLIENT_REDRAWSTATUSALWAYS 0x1000000\n#define CLIENT_REDRAWOVERLAY 0x2000000\n#define CLIENT_CONTROL_NOOUTPUT 0x4000000\n#define CLIENT_DEFAULTSOCKET 0x8000000\n#define CLIENT_STARTSERVER 0x10000000\n#define CLIENT_REDRAWPANES 0x20000000\n#define CLIENT_NOFORK 0x40000000\n#define CLIENT_ACTIVEPANE 0x80000000ULL\n#define CLIENT_CONTROL_PAUSEAFTER 0x100000000ULL\n#define CLIENT_CONTROL_WAITEXIT 0x200000000ULL\n#define CLIENT_WINDOWSIZECHANGED 0x400000000ULL\n#define CLIENT_CLIPBOARDBUFFER 0x800000000ULL\n#define CLIENT_BRACKETPASTING 0x1000000000ULL\n#define CLIENT_ASSUMEPASTING 0x2000000000ULL\n#define CLIENT_REDRAWSCROLLBARS 0x4000000000ULL\n#define CLIENT_NO_DETACH_ON_DESTROY 0x8000000000ULL\n#define CLIENT_ALLREDRAWFLAGS\t\t\\\n\t(CLIENT_REDRAWWINDOW|\t\t\\\n\t CLIENT_REDRAWSTATUS|\t\t\\\n\t CLIENT_REDRAWSTATUSALWAYS|\t\\\n\t CLIENT_REDRAWBORDERS|\t\t\\\n\t CLIENT_REDRAWOVERLAY|\t\t\\\n\t CLIENT_REDRAWPANES|\t\t\\\n\t CLIENT_REDRAWSCROLLBARS)\n#define CLIENT_UNATTACHEDFLAGS\t\\\n\t(CLIENT_DEAD|\t\t\\\n\t CLIENT_SUSPENDED|\t\\\n\t CLIENT_EXIT)\n#define CLIENT_NODETACHFLAGS\t\\\n\t(CLIENT_DEAD|\t\t\\\n\t CLIENT_EXIT)\n#define CLIENT_NOSIZEFLAGS\t\\\n\t(CLIENT_DEAD|\t\t\\\n\t CLIENT_SUSPENDED|\t\\\n\t CLIENT_EXIT)\n\tuint64_t\t\t flags;\n\n\tenum {\n\t\tCLIENT_EXIT_RETURN,\n\t\tCLIENT_EXIT_SHUTDOWN,\n\t\tCLIENT_EXIT_DETACH\n\t}\t\t\t exit_type;\n\tenum msgtype\t\t exit_msgtype;\n\tchar\t\t\t*exit_session;\n\tchar\t\t\t*exit_message;\n\n\tstruct key_table\t*keytable;\n\tkey_code\t\t last_key;\n\n\tuint64_t\t\t redraw_panes;\n\tuint64_t\t\t redraw_scrollbars;\n\n\tint\t\t\t message_ignore_keys;\n\tint\t\t\t message_ignore_styles;\n\tchar\t\t\t*message_string;\n\tstruct event\t\t message_timer;\n\n\tchar\t\t\t*prompt_string;\n\tstruct utf8_data\t*prompt_buffer;\n\tchar\t\t\t*prompt_last;\n\tsize_t\t\t\t prompt_index;\n\tprompt_input_cb\t\t prompt_inputcb;\n\tprompt_free_cb\t\t prompt_freecb;\n\tvoid\t\t\t*prompt_data;\n\tu_int\t\t\t prompt_hindex[PROMPT_NTYPES];\n\tenum {\n\t\tPROMPT_ENTRY,\n\t\tPROMPT_COMMAND\n\t}\t\t\t prompt_mode;\n\tstruct utf8_data\t*prompt_saved;\n#define PROMPT_SINGLE 0x1\n#define PROMPT_NUMERIC 0x2\n#define PROMPT_INCREMENTAL 0x4\n#define PROMPT_NOFORMAT 0x8\n#define PROMPT_KEY 0x10\n#define PROMPT_ACCEPT 0x20\n#define PROMPT_QUOTENEXT 0x40\n\tint\t\t\t prompt_flags;\n\tenum prompt_type\t prompt_type;\n\tint\t\t\t prompt_cursor;\n\n\tstruct session\t\t*session;\n\tstruct session\t\t*last_session;\n\n\tint\t\t\t references;\n\n\tvoid\t\t\t*pan_window;\n\tu_int\t\t\t pan_ox;\n\tu_int\t\t\t pan_oy;\n\n\toverlay_check_cb\t overlay_check;\n\toverlay_mode_cb\t\t overlay_mode;\n\toverlay_draw_cb\t\t overlay_draw;\n\toverlay_key_cb\t\t overlay_key;\n\toverlay_free_cb\t\t overlay_free;\n\toverlay_resize_cb\t overlay_resize;\n\tvoid\t\t\t*overlay_data;\n\tstruct event\t\t overlay_timer;\n\n\tstruct client_files\t files;\n\tu_int\t\t\t source_file_depth;\n\n\tu_int\t\t\t*clipboard_panes;\n\tu_int\t\t\t clipboard_npanes;\n\n\tTAILQ_ENTRY(client)\t entry;\n};\nTAILQ_HEAD(clients, client);\n\n/* Control mode subscription type. */\nenum control_sub_type {\n\tCONTROL_SUB_SESSION,\n\tCONTROL_SUB_PANE,\n\tCONTROL_SUB_ALL_PANES,\n\tCONTROL_SUB_WINDOW,\n\tCONTROL_SUB_ALL_WINDOWS\n};\n\n/* Key binding and key table. */\nstruct key_binding {\n\tkey_code\t\t key;\n\tstruct cmd_list\t\t*cmdlist;\n\tconst char\t\t*note;\n\n\tint\t\t\t flags;\n#define KEY_BINDING_REPEAT 0x1\n\n\tRB_ENTRY(key_binding)\t entry;\n};\nRB_HEAD(key_bindings, key_binding);\n\nstruct key_table {\n\tconst char\t\t*name;\n\tstruct timeval\t\t activity_time;\n\tstruct key_bindings\t key_bindings;\n\tstruct key_bindings\t default_key_bindings;\n\n\tu_int\t\t\t references;\n\n\tRB_ENTRY(key_table)\t entry;\n};\nRB_HEAD(key_tables, key_table);\n\n/* Option data. */\nRB_HEAD(options_array, options_array_item);\nunion options_value {\n\tchar\t\t\t*string;\n\tlong long\t\t number;\n\tstruct style\t\t style;\n\tstruct options_array\t array;\n\tstruct cmd_list\t\t*cmdlist;\n};\n\n/* Option table entries. */\nenum options_table_type {\n\tOPTIONS_TABLE_STRING,\n\tOPTIONS_TABLE_NUMBER,\n\tOPTIONS_TABLE_KEY,\n\tOPTIONS_TABLE_COLOUR,\n\tOPTIONS_TABLE_FLAG,\n\tOPTIONS_TABLE_CHOICE,\n\tOPTIONS_TABLE_COMMAND\n};\n\n#define OPTIONS_TABLE_NONE 0\n#define OPTIONS_TABLE_SERVER 0x1\n#define OPTIONS_TABLE_SESSION 0x2\n#define OPTIONS_TABLE_WINDOW 0x4\n#define OPTIONS_TABLE_PANE 0x8\n\n#define OPTIONS_TABLE_IS_ARRAY 0x1\n#define OPTIONS_TABLE_IS_HOOK 0x2\n#define OPTIONS_TABLE_IS_STYLE 0x4\n\nstruct options_table_entry {\n\tconst char\t\t *name;\n\tconst char\t\t *alternative_name;\n\tenum options_table_type\t  type;\n\tint\t\t\t  scope;\n\tint\t\t\t  flags;\n\n\tu_int\t\t\t  minimum;\n\tu_int\t\t\t  maximum;\n\tconst char\t\t**choices;\n\n\tconst char\t\t *default_str;\n\tlong long\t\t  default_num;\n\tconst char\t\t**default_arr;\n\n\tconst char\t\t *separator;\n\tconst char\t\t *pattern;\n\n\tconst char\t\t *text;\n\tconst char\t\t *unit;\n};\n\nstruct options_name_map {\n\tconst char\t\t*from;\n\tconst char\t\t*to;\n};\n\n/* Common command usages. */\n#define CMD_TARGET_PANE_USAGE \"[-t target-pane]\"\n#define CMD_TARGET_WINDOW_USAGE \"[-t target-window]\"\n#define CMD_TARGET_SESSION_USAGE \"[-t target-session]\"\n#define CMD_TARGET_CLIENT_USAGE \"[-t target-client]\"\n#define CMD_SRCDST_PANE_USAGE \"[-s src-pane] [-t dst-pane]\"\n#define CMD_SRCDST_WINDOW_USAGE \"[-s src-window] [-t dst-window]\"\n#define CMD_SRCDST_SESSION_USAGE \"[-s src-session] [-t dst-session]\"\n#define CMD_SRCDST_CLIENT_USAGE \"[-s src-client] [-t dst-client]\"\n#define CMD_BUFFER_USAGE \"[-b buffer-name]\"\n\n/* Spawn common context. */\nstruct spawn_context {\n\tstruct cmdq_item\t *item;\n\n\tstruct session\t\t *s;\n\tstruct winlink\t\t *wl;\n\tstruct client\t\t *tc;\n\n\tstruct window_pane\t *wp0;\n\tstruct layout_cell\t *lc;\n\n\tconst char\t\t *name;\n\tchar\t\t\t**argv;\n\tint\t\t\t  argc;\n\tstruct environ\t\t *environ;\n\n\tint\t\t\t  idx;\n\tconst char\t\t *cwd;\n\n\tint\t\t\t  flags;\n#define SPAWN_KILL 0x1\n#define SPAWN_DETACHED 0x2\n#define SPAWN_RESPAWN 0x4\n#define SPAWN_BEFORE 0x8\n#define SPAWN_NONOTIFY 0x10\n#define SPAWN_FULLSIZE 0x20\n#define SPAWN_EMPTY 0x40\n#define SPAWN_ZOOM 0x80\n};\n\n/* Mode tree sort order. */\nstruct mode_tree_sort_criteria {\n\tu_int\tfield;\n\tint\treversed;\n};\n\n/* tmux.c */\nextern struct options\t*global_options;\nextern struct options\t*global_s_options;\nextern struct options\t*global_w_options;\nextern struct environ\t*global_environ;\nextern struct timeval\t start_time;\nextern const char\t*socket_path;\nextern const char\t*shell_command;\nextern int\t\t ptm_fd;\nextern const char\t*shell_command;\nint\t\t checkshell(const char *);\nvoid\t\t setblocking(int, int);\nchar \t\t*shell_argv0(const char *, int);\nuint64_t\t get_timer(void);\nconst char\t*sig2name(int);\nconst char\t*find_cwd(void);\nconst char\t*find_home(void);\nconst char\t*getversion(void);\n\n/* proc.c */\nstruct imsg;\nint\tproc_send(struct tmuxpeer *, enum msgtype, int, const void *, size_t);\nstruct tmuxproc *proc_start(const char *);\nvoid\tproc_loop(struct tmuxproc *, int (*)(void));\nvoid\tproc_exit(struct tmuxproc *);\nvoid\tproc_set_signals(struct tmuxproc *, void(*)(int));\nvoid\tproc_clear_signals(struct tmuxproc *, int);\nstruct tmuxpeer *proc_add_peer(struct tmuxproc *, int,\n\t    void (*)(struct imsg *, void *), void *);\nvoid\tproc_remove_peer(struct tmuxpeer *);\nvoid\tproc_kill_peer(struct tmuxpeer *);\nvoid\tproc_flush_peer(struct tmuxpeer *);\nvoid\tproc_toggle_log(struct tmuxproc *);\npid_t\tproc_fork_and_daemon(int *);\nuid_t\tproc_get_peer_uid(struct tmuxpeer *);\n\n/* cfg.c */\nextern int cfg_finished;\nextern struct client *cfg_client;\nextern char **cfg_files;\nextern u_int cfg_nfiles;\nextern int cfg_quiet;\nvoid\tstart_cfg(void);\nint\tload_cfg(const char *, struct client *, struct cmdq_item *,\n            struct cmd_find_state *, int, struct cmdq_item **);\nint\tload_cfg_from_buffer(const void *, size_t, const char *,\n  \t    struct client *, struct cmdq_item *, struct cmd_find_state *,\n\t    int, struct cmdq_item **);\nvoid printflike(1, 2) cfg_add_cause(const char *, ...);\nvoid\tcfg_print_causes(struct cmdq_item *);\nvoid\tcfg_show_causes(struct session *);\n\n/* paste.c */\nstruct paste_buffer;\nconst char\t*paste_buffer_name(struct paste_buffer *);\nu_int\t\t paste_buffer_order(struct paste_buffer *);\ntime_t\t\t paste_buffer_created(struct paste_buffer *);\nconst char\t*paste_buffer_data(struct paste_buffer *, size_t *);\nstruct paste_buffer *paste_walk(struct paste_buffer *);\nint\t\t paste_is_empty(void);\nstruct paste_buffer *paste_get_top(const char **);\nstruct paste_buffer *paste_get_name(const char *);\nvoid\t\t paste_free(struct paste_buffer *);\nvoid\t\t paste_add(const char *, char *, size_t);\nint\t\t paste_rename(const char *, const char *, char **);\nint\t\t paste_set(char *, size_t, const char *, char **);\nvoid\t\t paste_replace(struct paste_buffer *, char *, size_t);\nchar\t\t*paste_make_sample(struct paste_buffer *);\n\n/* format.c */\n#define FORMAT_STATUS 0x1\n#define FORMAT_FORCE 0x2\n#define FORMAT_NOJOBS 0x4\n#define FORMAT_VERBOSE 0x8\n#define FORMAT_NONE 0\n#define FORMAT_PANE 0x80000000U\n#define FORMAT_WINDOW 0x40000000U\nstruct format_tree;\nstruct format_modifier;\ntypedef void *(*format_cb)(struct format_tree *);\nvoid\t\t format_tidy_jobs(void);\nconst char\t*format_skip(const char *, const char *);\nint\t\t format_true(const char *);\nstruct format_tree *format_create(struct client *, struct cmdq_item *, int,\n\t\t     int);\nvoid\t\t format_free(struct format_tree *);\nvoid\t\t format_merge(struct format_tree *, struct format_tree *);\nstruct window_pane *format_get_pane(struct format_tree *);\nvoid printflike(3, 4) format_add(struct format_tree *, const char *,\n\t\t     const char *, ...);\nvoid\t\t format_add_tv(struct format_tree *, const char *,\n\t\t     struct timeval *);\nvoid\t\t format_add_cb(struct format_tree *, const char *, format_cb);\nvoid\t\t format_log_debug(struct format_tree *, const char *);\nvoid\t\t format_each(struct format_tree *, void (*)(const char *,\n\t\t     const char *, void *), void *);\nchar\t\t*format_pretty_time(time_t, int);\nchar\t\t*format_expand_time(struct format_tree *, const char *);\nchar\t\t*format_expand(struct format_tree *, const char *);\nchar\t\t*format_single(struct cmdq_item *, const char *,\n\t\t     struct client *, struct session *, struct winlink *,\n\t\t     struct window_pane *);\nchar\t\t*format_single_from_state(struct cmdq_item *, const char *,\n\t\t    struct client *, struct cmd_find_state *);\nchar\t\t*format_single_from_target(struct cmdq_item *, const char *);\nstruct format_tree *format_create_defaults(struct cmdq_item *, struct client *,\n\t\t     struct session *, struct winlink *, struct window_pane *);\nstruct format_tree *format_create_from_state(struct cmdq_item *,\n\t\t     struct client *, struct cmd_find_state *);\nstruct format_tree *format_create_from_target(struct cmdq_item *);\nvoid\t\t format_defaults(struct format_tree *, struct client *,\n\t\t     struct session *, struct winlink *, struct window_pane *);\nvoid\t\t format_defaults_window(struct format_tree *, struct window *);\nvoid\t\t format_defaults_pane(struct format_tree *,\n\t\t     struct window_pane *);\nvoid\t\t format_defaults_paste_buffer(struct format_tree *,\n\t\t     struct paste_buffer *);\nvoid\t\t format_lost_client(struct client *);\nchar\t\t*format_grid_word(struct grid *, u_int, u_int);\nchar\t\t*format_grid_hyperlink(struct grid *, u_int, u_int,\n\t\t     struct screen *);\nchar\t\t*format_grid_line(struct grid *, u_int);\n\n/* format-draw.c */\nvoid\t\t format_draw(struct screen_write_ctx *,\n\t\t     const struct grid_cell *, u_int, const char *,\n\t\t     struct style_ranges *, int);\nu_int\t\t format_width(const char *);\nchar\t\t*format_trim_left(const char *, u_int);\nchar\t\t*format_trim_right(const char *, u_int);\n\n/* notify.c */\nvoid\tnotify_hook(struct cmdq_item *, const char *);\nvoid\tnotify_client(const char *, struct client *);\nvoid\tnotify_session(const char *, struct session *);\nvoid\tnotify_winlink(const char *, struct winlink *);\nvoid\tnotify_session_window(const char *, struct session *, struct window *);\nvoid\tnotify_window(const char *, struct window *);\nvoid\tnotify_pane(const char *, struct window_pane *);\nvoid\tnotify_paste_buffer(const char *, int);\n\n/* options.c */\nstruct options\t*options_create(struct options *);\nvoid\t\t options_free(struct options *);\nstruct options\t*options_get_parent(struct options *);\nvoid\t\t options_set_parent(struct options *, struct options *);\nstruct options_entry *options_first(struct options *);\nstruct options_entry *options_next(struct options_entry *);\nstruct options_entry *options_empty(struct options *,\n\t\t     const struct options_table_entry *);\nstruct options_entry *options_default(struct options *,\n\t\t     const struct options_table_entry *);\nchar\t\t*options_default_to_string(const struct options_table_entry *);\nconst char\t*options_name(struct options_entry *);\nstruct options\t*options_owner(struct options_entry *);\nconst struct options_table_entry *options_table_entry(struct options_entry *);\nstruct options_entry *options_get_only(struct options *, const char *);\nstruct options_entry *options_get(struct options *, const char *);\nvoid\t\t options_array_clear(struct options_entry *);\nunion options_value *options_array_get(struct options_entry *, u_int);\nint\t\t options_array_set(struct options_entry *, u_int, const char *,\n\t\t     int, char **);\nint\t\t options_array_assign(struct options_entry *, const char *,\n\t\t     char **);\nstruct options_array_item *options_array_first(struct options_entry *);\nstruct options_array_item *options_array_next(struct options_array_item *);\nu_int\t\t options_array_item_index(struct options_array_item *);\nunion options_value *options_array_item_value(struct options_array_item *);\nint\t\t options_is_array(struct options_entry *);\nint\t\t options_is_string(struct options_entry *);\nchar\t\t*options_to_string(struct options_entry *, int, int);\nchar\t\t*options_parse(const char *, int *);\nstruct options_entry *options_parse_get(struct options *, const char *, int *,\n\t\t     int);\nchar\t\t*options_match(const char *, int *, int *);\nstruct options_entry *options_match_get(struct options *, const char *, int *,\n\t\t     int, int *);\nconst char\t*options_get_string(struct options *, const char *);\nlong long\t options_get_number(struct options *, const char *);\nstruct options_entry * printflike(4, 5) options_set_string(struct options *,\n\t\t     const char *, int, const char *, ...);\nstruct options_entry *options_set_number(struct options *, const char *,\n\t\t     long long);\nint\t\t options_scope_from_name(struct args *, int,\n\t\t     const char *, struct cmd_find_state *, struct options **,\n\t\t     char **);\nint\t\t options_scope_from_flags(struct args *, int,\n\t\t     struct cmd_find_state *, struct options **, char **);\nstruct style\t*options_string_to_style(struct options *, const char *,\n\t\t     struct format_tree *);\nint\t\t options_from_string(struct options *,\n\t\t     const struct options_table_entry *, const char *,\n\t\t     const char *, int, char **);\nint\t \t options_find_choice(const struct options_table_entry *,\n\t\t     const char *, char **);\nvoid\t\t options_push_changes(const char *);\nint\t\t options_remove_or_default(struct options_entry *, int,\n\t\t     char **);\n\n/* options-table.c */\nextern const struct options_table_entry\toptions_table[];\nextern const struct options_name_map\toptions_other_names[];\n\n/* job.c */\ntypedef void (*job_update_cb) (struct job *);\ntypedef void (*job_complete_cb) (struct job *);\ntypedef void (*job_free_cb) (void *);\n#define JOB_NOWAIT 0x1\n#define JOB_KEEPWRITE 0x2\n#define JOB_PTY 0x4\n#define JOB_DEFAULTSHELL 0x8\nstruct job\t*job_run(const char *, int, char **, struct environ *,\n\t\t     struct session *, const char *, job_update_cb,\n\t\t     job_complete_cb, job_free_cb, void *, int, int, int);\nvoid\t\t job_free(struct job *);\nint\t\t job_transfer(struct job *, pid_t *, char *, size_t);\nvoid\t\t job_resize(struct job *, u_int, u_int);\nvoid\t\t job_check_died(pid_t, int);\nint\t\t job_get_status(struct job *);\nvoid\t\t*job_get_data(struct job *);\nstruct bufferevent *job_get_event(struct job *);\nvoid\t\t job_kill_all(void);\nint\t\t job_still_running(void);\nvoid\t\t job_print_summary(struct cmdq_item *, int);\n\n/* environ.c */\nstruct environ *environ_create(void);\nvoid\tenviron_free(struct environ *);\nstruct environ_entry *environ_first(struct environ *);\nstruct environ_entry *environ_next(struct environ_entry *);\nvoid\tenviron_copy(struct environ *, struct environ *);\nstruct environ_entry *environ_find(struct environ *, const char *);\nvoid printflike(4, 5) environ_set(struct environ *, const char *, int,\n\t    const char *, ...);\nvoid\tenviron_clear(struct environ *, const char *);\nvoid\tenviron_put(struct environ *, const char *, int);\nvoid\tenviron_unset(struct environ *, const char *);\nvoid\tenviron_update(struct options *, struct environ *, struct environ *);\nvoid\tenviron_push(struct environ *);\nvoid printflike(2, 3) environ_log(struct environ *, const char *, ...);\nstruct environ *environ_for_session(struct session *, int);\n\n/* tty.c */\nvoid\ttty_create_log(void);\nint\ttty_window_bigger(struct tty *);\nint\ttty_window_offset(struct tty *, u_int *, u_int *, u_int *, u_int *);\nvoid\ttty_update_window_offset(struct window *);\nvoid\ttty_update_client_offset(struct client *);\nvoid\ttty_raw(struct tty *, const char *);\nvoid\ttty_attributes(struct tty *, const struct grid_cell *,\n\t    const struct grid_cell *, struct colour_palette *,\n\t    struct hyperlinks *);\nvoid\ttty_reset(struct tty *);\nvoid\ttty_region_off(struct tty *);\nvoid\ttty_margin_off(struct tty *);\nvoid\ttty_cursor(struct tty *, u_int, u_int);\nvoid\ttty_clipboard_query(struct tty *);\nvoid\ttty_putcode(struct tty *, enum tty_code_code);\nvoid\ttty_putcode_i(struct tty *, enum tty_code_code, int);\nvoid\ttty_putcode_ii(struct tty *, enum tty_code_code, int, int);\nvoid\ttty_putcode_iii(struct tty *, enum tty_code_code, int, int, int);\nvoid\ttty_putcode_s(struct tty *, enum tty_code_code, const char *);\nvoid\ttty_putcode_ss(struct tty *, enum tty_code_code, const char *,\n\t    const char *);\nvoid\ttty_puts(struct tty *, const char *);\nvoid\ttty_putc(struct tty *, u_char);\nvoid\ttty_putn(struct tty *, const void *, size_t, u_int);\nvoid\ttty_cell(struct tty *, const struct grid_cell *,\n\t    const struct grid_cell *, struct colour_palette *,\n\t    struct hyperlinks *);\nint\ttty_init(struct tty *, struct client *);\nvoid\ttty_resize(struct tty *);\nvoid\ttty_set_size(struct tty *, u_int, u_int, u_int, u_int);\nvoid\ttty_invalidate(struct tty *);\nvoid\ttty_start_tty(struct tty *);\nvoid\ttty_send_requests(struct tty *);\nvoid\ttty_repeat_requests(struct tty *);\nvoid\ttty_stop_tty(struct tty *);\nvoid\ttty_set_title(struct tty *, const char *);\nvoid\ttty_set_path(struct tty *, const char *);\nvoid\ttty_update_mode(struct tty *, int, struct screen *);\nvoid\ttty_draw_line(struct tty *, struct screen *, u_int, u_int, u_int,\n\t    u_int, u_int, const struct grid_cell *, struct colour_palette *);\n\n#ifdef ENABLE_SIXEL\nvoid\ttty_draw_images(struct client *, struct window_pane *, struct screen *);\n#endif\n\nvoid\ttty_sync_start(struct tty *);\nvoid\ttty_sync_end(struct tty *);\nint\ttty_open(struct tty *, char **);\nvoid\ttty_close(struct tty *);\nvoid\ttty_free(struct tty *);\nvoid\ttty_update_features(struct tty *);\nvoid\ttty_set_selection(struct tty *, const char *, const char *, size_t);\nvoid\ttty_write(void (*)(struct tty *, const struct tty_ctx *),\n\t    struct tty_ctx *);\nvoid\ttty_cmd_alignmenttest(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_cell(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_cells(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearendofline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearendofscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearstartofline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearstartofscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_deletecharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearcharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_deleteline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_insertcharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_insertline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_linefeed(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_scrollup(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_scrolldown(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_reverseindex(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_setselection(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_rawstring(struct tty *, const struct tty_ctx *);\n\n#ifdef ENABLE_SIXEL\nvoid\ttty_cmd_sixelimage(struct tty *, const struct tty_ctx *);\n#endif\n\nvoid\ttty_cmd_syncstart(struct tty *, const struct tty_ctx *);\nvoid\ttty_default_colours(struct grid_cell *, struct window_pane *);\n\n/* tty-term.c */\nextern struct tty_terms tty_terms;\nu_int\t\t tty_term_ncodes(void);\nvoid\t\t tty_term_apply(struct tty_term *, const char *, int);\nvoid\t\t tty_term_apply_overrides(struct tty_term *);\nstruct tty_term *tty_term_create(struct tty *, char *, char **, u_int, int *,\n\t\t     char **);\nvoid\t\t tty_term_free(struct tty_term *);\nint\t\t tty_term_read_list(const char *, int, char ***, u_int *,\n\t\t     char **);\nvoid\t\t tty_term_free_list(char **, u_int);\nint\t\t tty_term_has(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_string(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_string_i(struct tty_term *, enum tty_code_code, int);\nconst char\t*tty_term_string_ii(struct tty_term *, enum tty_code_code, int,\n\t\t     int);\nconst char\t*tty_term_string_iii(struct tty_term *, enum tty_code_code, int,\n\t\t     int, int);\nconst char\t*tty_term_string_s(struct tty_term *, enum tty_code_code,\n\t\t     const char *);\nconst char\t*tty_term_string_ss(struct tty_term *, enum tty_code_code,\n\t\t     const char *, const char *);\nint\t\t tty_term_number(struct tty_term *, enum tty_code_code);\nint\t\t tty_term_flag(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_describe(struct tty_term *, enum tty_code_code);\n\n/* tty-features.c */\nvoid\t\t tty_add_features(int *, const char *, const char *);\nconst char\t*tty_get_features(int);\nint\t\t tty_apply_features(struct tty_term *, int);\nvoid\t\t tty_default_features(int *, const char *, u_int);\n\n/* tty-acs.c */\nint\t\t tty_acs_needed(struct tty *);\nconst char\t*tty_acs_get(struct tty *, u_char);\nint\t\t tty_acs_reverse_get(struct tty *, const char *, size_t);\nconst struct utf8_data *tty_acs_double_borders(int);\nconst struct utf8_data *tty_acs_heavy_borders(int);\nconst struct utf8_data *tty_acs_rounded_borders(int);\n\n/* tty-keys.c */\nvoid\t\ttty_keys_build(struct tty *);\nvoid\t\ttty_keys_free(struct tty *);\nint\t\ttty_keys_next(struct tty *);\nint\t\ttty_keys_colours(struct tty *, const char *, size_t, size_t *,\n\t\t     int *, int *);\n\n/* arguments.c */\nvoid\t\t args_set(struct args *, u_char, struct args_value *, int);\nstruct args \t*args_create(void);\nstruct args\t*args_parse(const struct args_parse *, struct args_value *,\n\t\t     u_int, char **);\nstruct args\t*args_copy(struct args *, int, char **);\nvoid\t\t args_to_vector(struct args *, int *, char ***);\nstruct args_value *args_from_vector(int, char **);\nvoid\t\t args_free_value(struct args_value *);\nvoid\t\t args_free_values(struct args_value *, u_int);\nvoid\t\t args_free(struct args *);\nchar\t\t*args_print(struct args *);\nchar\t\t*args_escape(const char *);\nint\t\t args_has(struct args *, u_char);\nconst char\t*args_get(struct args *, u_char);\nu_char\t\t args_first(struct args *, struct args_entry **);\nu_char\t\t args_next(struct args_entry **);\nu_int\t\t args_count(struct args *);\nstruct args_value *args_values(struct args *);\nstruct args_value *args_value(struct args *, u_int);\nconst char\t*args_string(struct args *, u_int);\nstruct cmd_list\t*args_make_commands_now(struct cmd *, struct cmdq_item *,\n\t\t     u_int, int);\nstruct args_command_state *args_make_commands_prepare(struct cmd *,\n\t\t     struct cmdq_item *, u_int, const char *, int, int);\nstruct cmd_list *args_make_commands(struct args_command_state *, int, char **,\n\t\t     char **);\nvoid\t\t args_make_commands_free(struct args_command_state *);\nchar\t\t*args_make_commands_get_command(struct args_command_state *);\nstruct args_value *args_first_value(struct args *, u_char);\nstruct args_value *args_next_value(struct args_value *);\nlong long\t args_strtonum(struct args *, u_char, long long, long long,\n\t\t     char **);\nlong long\t args_strtonum_and_expand(struct args *, u_char, long long,\n\t\t     long long, struct cmdq_item *, char **);\nlong long\t args_percentage(struct args *, u_char, long long,\n\t\t     long long, long long, char **);\nlong long\t args_string_percentage(const char *, long long, long long,\n\t\t     long long, char **);\nlong long\t args_percentage_and_expand(struct args *, u_char, long long,\n\t\t     long long, long long, struct cmdq_item *, char **);\nlong long\t args_string_percentage_and_expand(const char *, long long,\n\t\t     long long, long long, struct cmdq_item *, char **);\n\n/* cmd-find.c */\nint\t\t cmd_find_target(struct cmd_find_state *, struct cmdq_item *,\n\t\t     const char *, enum cmd_find_type, int);\nstruct client\t*cmd_find_best_client(struct session *);\nstruct client\t*cmd_find_client(struct cmdq_item *, const char *, int);\nvoid\t\t cmd_find_clear_state(struct cmd_find_state *, int);\nint\t\t cmd_find_empty_state(struct cmd_find_state *);\nint\t\t cmd_find_valid_state(struct cmd_find_state *);\nvoid\t\t cmd_find_copy_state(struct cmd_find_state *,\n\t\t     struct cmd_find_state *);\nvoid\t\t cmd_find_from_session(struct cmd_find_state *,\n\t\t     struct session *, int);\nvoid\t\t cmd_find_from_winlink(struct cmd_find_state *,\n\t\t     struct winlink *, int);\nint\t\t cmd_find_from_session_window(struct cmd_find_state *,\n\t\t     struct session *, struct window *, int);\nint\t\t cmd_find_from_window(struct cmd_find_state *, struct window *,\n\t\t     int);\nvoid\t\t cmd_find_from_winlink_pane(struct cmd_find_state *,\n\t\t     struct winlink *, struct window_pane *, int);\nint\t\t cmd_find_from_pane(struct cmd_find_state *,\n\t\t     struct window_pane *, int);\nint\t\t cmd_find_from_client(struct cmd_find_state *, struct client *,\n\t\t     int);\nint\t\t cmd_find_from_mouse(struct cmd_find_state *,\n\t\t     struct mouse_event *, int);\nint\t\t cmd_find_from_nothing(struct cmd_find_state *, int);\n\n/* cmd.c */\nextern const struct cmd_entry *cmd_table[];\nvoid printflike(3, 4) cmd_log_argv(int, char **, const char *, ...);\nvoid\t\t cmd_prepend_argv(int *, char ***, const char *);\nvoid\t\t cmd_append_argv(int *, char ***, const char *);\nint\t\t cmd_pack_argv(int, char **, char *, size_t);\nint\t\t cmd_unpack_argv(char *, size_t, int, char ***);\nchar\t       **cmd_copy_argv(int, char **);\nvoid\t\t cmd_free_argv(int, char **);\nchar\t\t*cmd_stringify_argv(int, char **);\nchar\t\t*cmd_get_alias(const char *);\nconst struct cmd_entry *cmd_get_entry(struct cmd *);\nstruct args\t*cmd_get_args(struct cmd *);\nu_int\t\t cmd_get_group(struct cmd *);\nvoid\t\t cmd_get_source(struct cmd *, const char **, u_int *);\nstruct cmd\t*cmd_parse(struct args_value *, u_int, const char *, u_int,\n\t\t     char **);\nstruct cmd\t*cmd_copy(struct cmd *, int, char **);\nvoid\t\t cmd_free(struct cmd *);\nchar\t\t*cmd_print(struct cmd *);\nstruct cmd_list\t*cmd_list_new(void);\nstruct cmd_list\t*cmd_list_copy(struct cmd_list *, int, char **);\nvoid\t\t cmd_list_append(struct cmd_list *, struct cmd *);\nvoid\t\t cmd_list_append_all(struct cmd_list *, struct cmd_list *);\nvoid\t\t cmd_list_move(struct cmd_list *, struct cmd_list *);\nvoid\t\t cmd_list_free(struct cmd_list *);\nchar\t\t*cmd_list_print(struct cmd_list *, int);\nstruct cmd\t*cmd_list_first(struct cmd_list *);\nstruct cmd\t*cmd_list_next(struct cmd *);\nint\t\t cmd_list_all_have(struct cmd_list *, int);\nint\t\t cmd_list_any_have(struct cmd_list *, int);\nint\t\t cmd_mouse_at(struct window_pane *, struct mouse_event *,\n\t\t     u_int *, u_int *, int);\nstruct winlink\t*cmd_mouse_window(struct mouse_event *, struct session **);\nstruct window_pane *cmd_mouse_pane(struct mouse_event *, struct session **,\n\t\t     struct winlink **);\nchar\t\t*cmd_template_replace(const char *, const char *, int);\n\n/* cmd-attach-session.c */\nenum cmd_retval\t cmd_attach_session(struct cmdq_item *, const char *, int, int,\n\t\t     int, const char *, int, const char *);\n\n/* cmd-parse.c */\nstruct cmd_parse_result *cmd_parse_from_file(FILE *, struct cmd_parse_input *);\nstruct cmd_parse_result *cmd_parse_from_string(const char *,\n\t\t     struct cmd_parse_input *);\nenum cmd_parse_status cmd_parse_and_insert(const char *,\n\t\t     struct cmd_parse_input *, struct cmdq_item *,\n\t\t     struct cmdq_state *, char **);\nenum cmd_parse_status cmd_parse_and_append(const char *,\n\t\t     struct cmd_parse_input *, struct client *,\n\t\t     struct cmdq_state *, char **);\nstruct cmd_parse_result *cmd_parse_from_buffer(const void *, size_t,\n\t\t     struct cmd_parse_input *);\nstruct cmd_parse_result *cmd_parse_from_arguments(struct args_value *, u_int,\n\t\t     struct cmd_parse_input *);\n\n/* cmd-queue.c */\nstruct cmdq_state *cmdq_new_state(struct cmd_find_state *, struct key_event *,\n\t\t     int);\nstruct cmdq_state *cmdq_link_state(struct cmdq_state *);\nstruct cmdq_state *cmdq_copy_state(struct cmdq_state *,\n\t\t     struct cmd_find_state *);\nvoid\t\t  cmdq_free_state(struct cmdq_state *);\nvoid printflike(3, 4) cmdq_add_format(struct cmdq_state *, const char *,\n\t\t     const char *, ...);\nvoid\t\t  cmdq_add_formats(struct cmdq_state *, struct format_tree *);\nvoid\t\t  cmdq_merge_formats(struct cmdq_item *, struct format_tree *);\nstruct cmdq_list *cmdq_new(void);\nvoid cmdq_free(struct cmdq_list *);\nconst char\t *cmdq_get_name(struct cmdq_item *);\nstruct client\t *cmdq_get_client(struct cmdq_item *);\nstruct client\t *cmdq_get_target_client(struct cmdq_item *);\nstruct cmdq_state *cmdq_get_state(struct cmdq_item *);\nstruct cmd_find_state *cmdq_get_target(struct cmdq_item *);\nstruct cmd_find_state *cmdq_get_source(struct cmdq_item *);\nstruct key_event *cmdq_get_event(struct cmdq_item *);\nstruct cmd_find_state *cmdq_get_current(struct cmdq_item *);\nint\t\t  cmdq_get_flags(struct cmdq_item *);\nstruct cmdq_item *cmdq_get_command(struct cmd_list *, struct cmdq_state *);\n#define cmdq_get_callback(cb, data) cmdq_get_callback1(#cb, cb, data)\nstruct cmdq_item *cmdq_get_callback1(const char *, cmdq_cb, void *);\nstruct cmdq_item *cmdq_get_error(const char *);\nstruct cmdq_item *cmdq_insert_after(struct cmdq_item *, struct cmdq_item *);\nstruct cmdq_item *cmdq_append(struct client *, struct cmdq_item *);\nvoid printflike(4, 5) cmdq_insert_hook(struct session *, struct cmdq_item *,\n\t\t     struct cmd_find_state *, const char *, ...);\nvoid\t\t cmdq_continue(struct cmdq_item *);\nu_int\t\t cmdq_next(struct client *);\nstruct cmdq_item *cmdq_running(struct client *);\nvoid\t\t cmdq_guard(struct cmdq_item *, const char *, int);\nvoid printflike(2, 3) cmdq_print(struct cmdq_item *, const char *, ...);\nvoid \t\t cmdq_print_data(struct cmdq_item *, struct evbuffer *);\nvoid printflike(2, 3) cmdq_error(struct cmdq_item *, const char *, ...);\n\n/* cmd-wait-for.c */\nvoid\tcmd_wait_for_flush(void);\n\n/* client.c */\nint\tclient_main(struct event_base *, int, char **, uint64_t, int);\n\n/* key-bindings.c */\nstruct key_table *key_bindings_get_table(const char *, int);\nstruct key_table *key_bindings_first_table(void);\nstruct key_table *key_bindings_next_table(struct key_table *);\nvoid\t key_bindings_unref_table(struct key_table *);\nstruct key_binding *key_bindings_get(struct key_table *, key_code);\nstruct key_binding *key_bindings_get_default(struct key_table *, key_code);\nstruct key_binding *key_bindings_first(struct key_table *);\nstruct key_binding *key_bindings_next(struct key_table *, struct key_binding *);\nvoid\t key_bindings_add(const char *, key_code, const char *, int,\n\t     struct cmd_list *);\nvoid\t key_bindings_remove(const char *, key_code);\nvoid\t key_bindings_reset(const char *, key_code);\nvoid\t key_bindings_remove_table(const char *);\nvoid\t key_bindings_reset_table(const char *);\nvoid\t key_bindings_init(void);\nstruct cmdq_item *key_bindings_dispatch(struct key_binding *,\n\t     struct cmdq_item *, struct client *, struct key_event *,\n\t     struct cmd_find_state *);\n\n/* key-string.c */\nkey_code\t key_string_lookup_string(const char *);\nconst char\t*key_string_lookup_key(key_code, int);\n\n/* alerts.c */\nvoid\talerts_reset_all(void);\nvoid\talerts_queue(struct window *, int);\nvoid\talerts_check_session(struct session *);\n\n/* file.c */\nint\t file_cmp(struct client_file *, struct client_file *);\nRB_PROTOTYPE(client_files, client_file, entry, file_cmp);\nstruct client_file *file_create_with_peer(struct tmuxpeer *,\n\t    struct client_files *, int, client_file_cb, void *);\nstruct client_file *file_create_with_client(struct client *, int,\n\t    client_file_cb, void *);\nvoid\t file_free(struct client_file *);\nvoid\t file_fire_done(struct client_file *);\nvoid\t file_fire_read(struct client_file *);\nint\t file_can_print(struct client *);\nvoid printflike(2, 3) file_print(struct client *, const char *, ...);\nvoid printflike(2, 0) file_vprint(struct client *, const char *, va_list);\nvoid\t file_print_buffer(struct client *, void *, size_t);\nvoid printflike(2, 3) file_error(struct client *, const char *, ...);\nvoid\t file_write(struct client *, const char *, int, const void *, size_t,\n\t     client_file_cb, void *);\nstruct client_file *file_read(struct client *, const char *, client_file_cb,\n\t     void *);\nvoid\t file_cancel(struct client_file *);\nvoid\t file_push(struct client_file *);\nint\t file_write_left(struct client_files *);\nvoid\t file_write_open(struct client_files *, struct tmuxpeer *,\n\t     struct imsg *, int, int, client_file_cb, void *);\nvoid\t file_write_data(struct client_files *, struct imsg *);\nvoid\t file_write_close(struct client_files *, struct imsg *);\nvoid\t file_read_open(struct client_files *, struct tmuxpeer *, struct imsg *,\n\t     int, int, client_file_cb, void *);\nvoid\t file_write_ready(struct client_files *, struct imsg *);\nvoid\t file_read_data(struct client_files *, struct imsg *);\nvoid\t file_read_done(struct client_files *, struct imsg *);\nvoid\t file_read_cancel(struct client_files *, struct imsg *);\n\n/* server.c */\nextern struct tmuxproc *server_proc;\nextern struct clients clients;\nextern struct cmd_find_state marked_pane;\nextern struct message_list message_log;\nextern time_t current_time;\nvoid\t server_set_marked(struct session *, struct winlink *,\n\t     struct window_pane *);\nvoid\t server_clear_marked(void);\nint\t server_is_marked(struct session *, struct winlink *,\n\t     struct window_pane *);\nint\t server_check_marked(void);\nint\t server_start(struct tmuxproc *, uint64_t, struct event_base *, int,\n\t     char *);\nvoid\t server_update_socket(void);\nvoid\t server_add_accept(int);\nvoid printflike(1, 2) server_add_message(const char *, ...);\nint\t server_create_socket(uint64_t, char **);\n\n/* server-client.c */\nRB_PROTOTYPE(client_windows, client_window, entry, server_client_window_cmp);\nu_int\t server_client_how_many(void);\nvoid\t server_client_set_overlay(struct client *, u_int, overlay_check_cb,\n\t     overlay_mode_cb, overlay_draw_cb, overlay_key_cb,\n\t     overlay_free_cb, overlay_resize_cb, void *);\nvoid\t server_client_clear_overlay(struct client *);\nvoid\t server_client_overlay_range(u_int, u_int, u_int, u_int, u_int, u_int,\n\t     u_int, struct overlay_ranges *);\nvoid\t server_client_set_key_table(struct client *, const char *);\nconst char *server_client_get_key_table(struct client *);\nint\t server_client_check_nested(struct client *);\nint\t server_client_handle_key(struct client *, struct key_event *);\nstruct client *server_client_create(int);\nint\t server_client_open(struct client *, char **);\nvoid\t server_client_unref(struct client *);\nvoid\t server_client_set_session(struct client *, struct session *);\nvoid\t server_client_lost(struct client *);\nvoid\t server_client_suspend(struct client *);\nvoid\t server_client_detach(struct client *, enum msgtype);\nvoid\t server_client_exec(struct client *, const char *);\nvoid\t server_client_loop(void);\nconst char *server_client_get_cwd(struct client *, struct session *);\nvoid\t server_client_set_flags(struct client *, const char *);\nconst char *server_client_get_flags(struct client *);\nstruct client_window *server_client_get_client_window(struct client *, u_int);\nstruct client_window *server_client_add_client_window(struct client *, u_int);\nstruct window_pane *server_client_get_pane(struct client *);\nvoid\t server_client_set_pane(struct client *, struct window_pane *);\nvoid\t server_client_remove_pane(struct window_pane *);\nvoid\t server_client_print(struct client *, int, struct evbuffer *);\n\n/* server-fn.c */\nvoid\t server_redraw_client(struct client *);\nvoid\t server_status_client(struct client *);\nvoid\t server_redraw_session(struct session *);\nvoid\t server_redraw_session_group(struct session *);\nvoid\t server_status_session(struct session *);\nvoid\t server_status_session_group(struct session *);\nvoid\t server_redraw_window(struct window *);\nvoid\t server_redraw_window_borders(struct window *);\nvoid\t server_status_window(struct window *);\nvoid\t server_lock(void);\nvoid\t server_lock_session(struct session *);\nvoid\t server_lock_client(struct client *);\nvoid\t server_kill_pane(struct window_pane *);\nvoid\t server_kill_window(struct window *, int);\nvoid\t server_renumber_session(struct session *);\nvoid\t server_renumber_all(void);\nint\t server_link_window(struct session *,\n\t     struct winlink *, struct session *, int, int, int, char **);\nvoid\t server_unlink_window(struct session *, struct winlink *);\nvoid\t server_destroy_pane(struct window_pane *, int);\nvoid\t server_destroy_session(struct session *);\nvoid\t server_check_unattached(void);\nvoid\t server_unzoom_window(struct window *);\n\n/* status.c */\nextern char\t**status_prompt_hlist[];\nextern u_int\t  status_prompt_hsize[];\nvoid\t status_timer_start(struct client *);\nvoid\t status_timer_start_all(void);\nvoid\t status_update_cache(struct session *);\nint\t status_at_line(struct client *);\nu_int\t status_line_size(struct client *);\nstruct style_range *status_get_range(struct client *, u_int, u_int);\nvoid\t status_init(struct client *);\nvoid\t status_free(struct client *);\nint\t status_redraw(struct client *);\nvoid printflike(5, 6) status_message_set(struct client *, int, int, int,\n\t     const char *, ...);\nvoid\t status_message_clear(struct client *);\nint\t status_message_redraw(struct client *);\nvoid\t status_prompt_set(struct client *, struct cmd_find_state *,\n\t     const char *, const char *, prompt_input_cb, prompt_free_cb,\n\t     void *, int, enum prompt_type);\nvoid\t status_prompt_clear(struct client *);\nint\t status_prompt_redraw(struct client *);\nint\t status_prompt_key(struct client *, key_code);\nvoid\t status_prompt_update(struct client *, const char *, const char *);\nvoid\t status_prompt_load_history(void);\nvoid\t status_prompt_save_history(void);\nconst char *status_prompt_type_string(u_int);\nenum prompt_type status_prompt_type(const char *type);\n\n/* resize.c */\nvoid\t resize_window(struct window *, u_int, u_int, int, int);\nvoid\t default_window_size(struct client *, struct session *, struct window *,\n\t     u_int *, u_int *, u_int *, u_int *, int);\nvoid\t recalculate_size(struct window *, int);\nvoid\t recalculate_sizes(void);\nvoid\t recalculate_sizes_now(int);\n\n/* input.c */\n#define INPUT_BUF_DEFAULT_SIZE 1048576\nstruct input_ctx *input_init(struct window_pane *, struct bufferevent *,\n\t     struct colour_palette *);\nvoid\t input_free(struct input_ctx *);\nvoid\t input_reset(struct input_ctx *, int);\nstruct evbuffer *input_pending(struct input_ctx *);\nvoid\t input_parse_pane(struct window_pane *);\nvoid\t input_parse_buffer(struct window_pane *, u_char *, size_t);\nvoid\t input_parse_screen(struct input_ctx *, struct screen *,\n\t     screen_write_init_ctx_cb, void *, u_char *, size_t);\nvoid\t input_reply_clipboard(struct bufferevent *, const char *, size_t,\n\t     const char *);\nvoid\t input_set_buffer_size(size_t);\n\n/* input-key.c */\nvoid\t input_key_build(void);\nint\t input_key_pane(struct window_pane *, key_code, struct mouse_event *);\nint\t input_key(struct screen *, struct bufferevent *, key_code);\nint\t input_key_get_mouse(struct screen *, struct mouse_event *, u_int,\n\t     u_int, const char **, size_t *);\n\n/* colour.c */\nint\t colour_find_rgb(u_char, u_char, u_char);\nint\t colour_join_rgb(u_char, u_char, u_char);\nvoid\t colour_split_rgb(int, u_char *, u_char *, u_char *);\nint\t colour_force_rgb(int);\nconst char *colour_tostring(int);\nint\t colour_fromstring(const char *s);\nint\t colour_256toRGB(int);\nint\t colour_256to16(int);\nint\t colour_byname(const char *);\nint\t colour_parseX11(const char *);\nvoid\t colour_palette_init(struct colour_palette *);\nvoid\t colour_palette_clear(struct colour_palette *);\nvoid\t colour_palette_free(struct colour_palette *);\nint\t colour_palette_get(struct colour_palette *, int);\nint\t colour_palette_set(struct colour_palette *, int, int);\nvoid\t colour_palette_from_option(struct colour_palette *, struct options *);\n\n/* attributes.c */\nconst char *attributes_tostring(int);\nint\t attributes_fromstring(const char *);\n\n/* grid.c */\nextern const struct grid_cell grid_default_cell;\nvoid\t grid_empty_line(struct grid *, u_int, u_int);\nvoid\t grid_set_tab(struct grid_cell *, u_int);\nint\t grid_cells_equal(const struct grid_cell *, const struct grid_cell *);\nint\t grid_cells_look_equal(const struct grid_cell *,\n\t     const struct grid_cell *);\nstruct grid *grid_create(u_int, u_int, u_int);\nvoid\t grid_destroy(struct grid *);\nint\t grid_compare(struct grid *, struct grid *);\nvoid\t grid_collect_history(struct grid *);\nvoid\t grid_remove_history(struct grid *, u_int );\nvoid\t grid_scroll_history(struct grid *, u_int);\nvoid\t grid_scroll_history_region(struct grid *, u_int, u_int, u_int);\nvoid\t grid_clear_history(struct grid *);\nconst struct grid_line *grid_peek_line(struct grid *, u_int);\nvoid\t grid_get_cell(struct grid *, u_int, u_int, struct grid_cell *);\nvoid\t grid_set_cell(struct grid *, u_int, u_int, const struct grid_cell *);\nvoid\t grid_set_padding(struct grid *, u_int, u_int);\nvoid\t grid_set_cells(struct grid *, u_int, u_int, const struct grid_cell *,\n\t     const char *, size_t);\nstruct grid_line *grid_get_line(struct grid *, u_int);\nvoid\t grid_adjust_lines(struct grid *, u_int);\nvoid\t grid_clear(struct grid *, u_int, u_int, u_int, u_int, u_int);\nvoid\t grid_clear_lines(struct grid *, u_int, u_int, u_int);\nvoid\t grid_move_lines(struct grid *, u_int, u_int, u_int, u_int);\nvoid\t grid_move_cells(struct grid *, u_int, u_int, u_int, u_int, u_int);\nchar\t*grid_string_cells(struct grid *, u_int, u_int, u_int,\n\t     struct grid_cell **, int, struct screen *);\nvoid\t grid_duplicate_lines(struct grid *, u_int, struct grid *, u_int,\n\t     u_int);\nvoid\t grid_reflow(struct grid *, u_int);\nvoid\t grid_wrap_position(struct grid *, u_int, u_int, u_int *, u_int *);\nvoid\t grid_unwrap_position(struct grid *, u_int *, u_int *, u_int, u_int);\nu_int\t grid_line_length(struct grid *, u_int);\nint\t grid_in_set(struct grid *, u_int, u_int, const char *);\n\n/* grid-reader.c */\nvoid\t grid_reader_start(struct grid_reader *, struct grid *, u_int, u_int);\nvoid\t grid_reader_get_cursor(struct grid_reader *, u_int *, u_int *);\nu_int\t grid_reader_line_length(struct grid_reader *);\nint\t grid_reader_in_set(struct grid_reader *, const char *);\nvoid\t grid_reader_cursor_right(struct grid_reader *, int, int);\nvoid\t grid_reader_cursor_left(struct grid_reader *, int);\nvoid\t grid_reader_cursor_down(struct grid_reader *);\nvoid\t grid_reader_cursor_up(struct grid_reader *);\nvoid\t grid_reader_cursor_start_of_line(struct grid_reader *, int);\nvoid\t grid_reader_cursor_end_of_line(struct grid_reader *, int, int);\nvoid\t grid_reader_cursor_next_word(struct grid_reader *, const char *);\nvoid\t grid_reader_cursor_next_word_end(struct grid_reader *, const char *);\nvoid\t grid_reader_cursor_previous_word(struct grid_reader *, const char *,\n\t     int, int);\nint\t grid_reader_cursor_jump(struct grid_reader *,\n\t     const struct utf8_data *);\nint\t grid_reader_cursor_jump_back(struct grid_reader *,\n\t     const struct utf8_data *);\nvoid\t grid_reader_cursor_back_to_indentation(struct grid_reader *);\n\n/* grid-view.c */\nvoid\t grid_view_get_cell(struct grid *, u_int, u_int, struct grid_cell *);\nvoid\t grid_view_set_cell(struct grid *, u_int, u_int,\n\t     const struct grid_cell *);\nvoid\t grid_view_set_padding(struct grid *, u_int, u_int);\nvoid\t grid_view_set_cells(struct grid *, u_int, u_int,\n\t     const struct grid_cell *, const char *, size_t);\nvoid\t grid_view_clear_history(struct grid *, u_int);\nvoid\t grid_view_clear(struct grid *, u_int, u_int, u_int, u_int, u_int);\nvoid\t grid_view_scroll_region_up(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_scroll_region_down(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_insert_lines(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int,\n\t     u_int);\nvoid\t grid_view_delete_lines(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int,\n\t     u_int);\nvoid\t grid_view_insert_cells(struct grid *, u_int, u_int, u_int, u_int);\nvoid\t grid_view_delete_cells(struct grid *, u_int, u_int, u_int, u_int);\nchar\t*grid_view_string_cells(struct grid *, u_int, u_int, u_int);\n\n/* screen-write.c */\nvoid\t screen_write_make_list(struct screen *);\nvoid\t screen_write_free_list(struct screen *);\nvoid\t screen_write_start_pane(struct screen_write_ctx *,\n\t     struct window_pane *, struct screen *);\nvoid\t screen_write_start(struct screen_write_ctx *, struct screen *);\nvoid\t screen_write_start_callback(struct screen_write_ctx *, struct screen *,\n\t     screen_write_init_ctx_cb, void *);\nvoid\t screen_write_stop(struct screen_write_ctx *);\nvoid\t screen_write_reset(struct screen_write_ctx *);\nsize_t printflike(1, 2) screen_write_strlen(const char *, ...);\nint printflike(7, 8) screen_write_text(struct screen_write_ctx *, u_int, u_int,\n\t     u_int, int, const struct grid_cell *, const char *, ...);\nvoid printflike(3, 4) screen_write_puts(struct screen_write_ctx *,\n\t     const struct grid_cell *, const char *, ...);\nvoid printflike(4, 5) screen_write_nputs(struct screen_write_ctx *,\n\t     ssize_t, const struct grid_cell *, const char *, ...);\nvoid printflike(4, 0) screen_write_vnputs(struct screen_write_ctx *, ssize_t,\n\t     const struct grid_cell *, const char *, va_list);\nvoid\t screen_write_putc(struct screen_write_ctx *, const struct grid_cell *,\n\t     u_char);\nvoid\t screen_write_fast_copy(struct screen_write_ctx *, struct screen *,\n\t     u_int, u_int, u_int, u_int);\nvoid\t screen_write_hline(struct screen_write_ctx *, u_int, int, int,\n\t     enum box_lines, const struct grid_cell *);\nvoid\t screen_write_vline(struct screen_write_ctx *, u_int, int, int);\nvoid\t screen_write_menu(struct screen_write_ctx *, struct menu *, int,\n\t     enum box_lines, const struct grid_cell *, const struct grid_cell *,\n\t     const struct grid_cell *);\nvoid\t screen_write_box(struct screen_write_ctx *, u_int, u_int,\n             enum box_lines, const struct grid_cell *, const char *);\nvoid\t screen_write_preview(struct screen_write_ctx *, struct screen *, u_int,\n\t     u_int);\nvoid\t screen_write_backspace(struct screen_write_ctx *);\nvoid\t screen_write_mode_set(struct screen_write_ctx *, int);\nvoid\t screen_write_mode_clear(struct screen_write_ctx *, int);\nvoid\t screen_write_cursorup(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursordown(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursorright(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursorleft(struct screen_write_ctx *, u_int);\nvoid\t screen_write_alignmenttest(struct screen_write_ctx *);\nvoid\t screen_write_insertcharacter(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_deletecharacter(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_clearcharacter(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_insertline(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_deleteline(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_clearline(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearendofline(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearstartofline(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursormove(struct screen_write_ctx *, int, int, int);\nvoid\t screen_write_reverseindex(struct screen_write_ctx *, u_int);\nvoid\t screen_write_scrollregion(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_linefeed(struct screen_write_ctx *, int, u_int);\nvoid\t screen_write_scrollup(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_scrolldown(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_carriagereturn(struct screen_write_ctx *);\nvoid\t screen_write_clearendofscreen(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearstartofscreen(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearscreen(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearhistory(struct screen_write_ctx *);\nvoid\t screen_write_fullredraw(struct screen_write_ctx *);\nvoid\t screen_write_collect_end(struct screen_write_ctx *);\nvoid\t screen_write_collect_add(struct screen_write_ctx *,\n\t     const struct grid_cell *);\nvoid\t screen_write_cell(struct screen_write_ctx *, const struct grid_cell *);\nvoid\t screen_write_setselection(struct screen_write_ctx *, const char *,\n\t     u_char *, u_int);\nvoid\t screen_write_rawstring(struct screen_write_ctx *, u_char *, u_int,\n\t     int);\n#ifdef ENABLE_SIXEL\nvoid\t screen_write_sixelimage(struct screen_write_ctx *,\n\t     struct sixel_image *, u_int);\n#endif\nvoid\t screen_write_alternateon(struct screen_write_ctx *,\n\t     struct grid_cell *, int);\nvoid\t screen_write_alternateoff(struct screen_write_ctx *,\n\t     struct grid_cell *, int);\n\n/* screen-redraw.c */\nvoid\t screen_redraw_screen(struct client *);\nvoid\t screen_redraw_pane(struct client *, struct window_pane *, int);\n\n/* screen.c */\nvoid\t screen_init(struct screen *, u_int, u_int, u_int);\nvoid\t screen_reinit(struct screen *);\nvoid\t screen_free(struct screen *);\nvoid\t screen_reset_tabs(struct screen *);\nvoid\t screen_reset_hyperlinks(struct screen *);\nvoid\t screen_set_default_cursor(struct screen *, struct options *);\nvoid\t screen_set_cursor_style(u_int, enum screen_cursor_style *, int *);\nvoid\t screen_set_cursor_colour(struct screen *, int);\nint\t screen_set_title(struct screen *, const char *);\nvoid\t screen_set_path(struct screen *, const char *);\nvoid\t screen_push_title(struct screen *);\nvoid\t screen_pop_title(struct screen *);\nvoid\t screen_resize(struct screen *, u_int, u_int, int);\nvoid\t screen_resize_cursor(struct screen *, u_int, u_int, int, int, int);\nvoid\t screen_set_selection(struct screen *, u_int, u_int, u_int, u_int,\n\t     u_int, int, struct grid_cell *);\nvoid\t screen_clear_selection(struct screen *);\nvoid\t screen_hide_selection(struct screen *);\nint\t screen_check_selection(struct screen *, u_int, u_int);\nvoid\t screen_select_cell(struct screen *, struct grid_cell *,\n\t     const struct grid_cell *);\nvoid\t screen_alternate_on(struct screen *, struct grid_cell *, int);\nvoid\t screen_alternate_off(struct screen *, struct grid_cell *, int);\nconst char *screen_mode_to_string(int);\n\n/* window.c */\nextern struct windows windows;\nextern struct window_pane_tree all_window_panes;\nint\t\t window_cmp(struct window *, struct window *);\nRB_PROTOTYPE(windows, window, entry, window_cmp);\nint\t\t winlink_cmp(struct winlink *, struct winlink *);\nRB_PROTOTYPE(winlinks, winlink, entry, winlink_cmp);\nint\t\t window_pane_cmp(struct window_pane *, struct window_pane *);\nRB_PROTOTYPE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);\nstruct winlink\t*winlink_find_by_index(struct winlinks *, int);\nstruct winlink\t*winlink_find_by_window(struct winlinks *, struct window *);\nstruct winlink\t*winlink_find_by_window_id(struct winlinks *, u_int);\nu_int\t\t winlink_count(struct winlinks *);\nstruct winlink\t*winlink_add(struct winlinks *, int);\nvoid\t\t winlink_set_window(struct winlink *, struct window *);\nvoid\t\t winlink_remove(struct winlinks *, struct winlink *);\nstruct winlink\t*winlink_next(struct winlink *);\nstruct winlink\t*winlink_previous(struct winlink *);\nstruct winlink\t*winlink_next_by_number(struct winlink *, struct session *,\n\t\t     int);\nstruct winlink\t*winlink_previous_by_number(struct winlink *, struct session *,\n\t\t     int);\nvoid\t\t winlink_stack_push(struct winlink_stack *, struct winlink *);\nvoid\t\t winlink_stack_remove(struct winlink_stack *, struct winlink *);\nstruct window\t*window_find_by_id_str(const char *);\nstruct window\t*window_find_by_id(u_int);\nvoid\t\t window_update_activity(struct window *);\nstruct window\t*window_create(u_int, u_int, u_int, u_int);\nvoid\t\t window_pane_set_event(struct window_pane *);\nstruct window_pane *window_get_active_at(struct window *, u_int, u_int);\nstruct window_pane *window_find_string(struct window *, const char *);\nint\t\t window_has_pane(struct window *, struct window_pane *);\nint\t\t window_set_active_pane(struct window *, struct window_pane *,\n\t\t     int);\nvoid\t\t window_update_focus(struct window *);\nvoid\t\t window_pane_update_focus(struct window_pane *);\nvoid\t\t window_redraw_active_switch(struct window *,\n\t\t     struct window_pane *);\nstruct window_pane *window_add_pane(struct window *, struct window_pane *,\n\t\t     u_int, int);\nvoid\t\t window_resize(struct window *, u_int, u_int, int, int);\nvoid\t\t window_pane_send_resize(struct window_pane *, u_int, u_int);\nint\t\t window_zoom(struct window_pane *);\nint\t\t window_unzoom(struct window *, int);\nint\t\t window_push_zoom(struct window *, int, int);\nint\t\t window_pop_zoom(struct window *);\nvoid\t\t window_lost_pane(struct window *, struct window_pane *);\nvoid\t\t window_remove_pane(struct window *, struct window_pane *);\nstruct window_pane *window_pane_at_index(struct window *, u_int);\nstruct window_pane *window_pane_next_by_number(struct window *,\n\t\t\tstruct window_pane *, u_int);\nstruct window_pane *window_pane_previous_by_number(struct window *,\n\t\t\tstruct window_pane *, u_int);\nint\t\t window_pane_index(struct window_pane *, u_int *);\nu_int\t\t window_count_panes(struct window *);\nvoid\t\t window_destroy_panes(struct window *);\nstruct window_pane *window_pane_find_by_id_str(const char *);\nstruct window_pane *window_pane_find_by_id(u_int);\nint\t\t window_pane_destroy_ready(struct window_pane *);\nvoid\t\t window_pane_resize(struct window_pane *, u_int, u_int);\nint\t\t window_pane_set_mode(struct window_pane *,\n\t\t     struct window_pane *, const struct window_mode *,\n\t\t     struct cmd_find_state *, struct args *);\nvoid\t\t window_pane_reset_mode(struct window_pane *);\nvoid\t\t window_pane_reset_mode_all(struct window_pane *);\nint\t\t window_pane_key(struct window_pane *, struct client *,\n\t\t     struct session *, struct winlink *, key_code,\n\t\t     struct mouse_event *);\nvoid\t\t window_pane_paste(struct window_pane *, key_code, char *,\n\t\t     size_t);\nint\t\t window_pane_visible(struct window_pane *);\nint\t\t window_pane_exited(struct window_pane *);\nu_int\t\t window_pane_search(struct window_pane *, const char *, int,\n\t\t     int);\nconst char\t*window_printable_flags(struct winlink *, int);\nstruct window_pane *window_pane_find_up(struct window_pane *);\nstruct window_pane *window_pane_find_down(struct window_pane *);\nstruct window_pane *window_pane_find_left(struct window_pane *);\nstruct window_pane *window_pane_find_right(struct window_pane *);\nvoid\t\t window_pane_stack_push(struct window_panes *,\n\t\t     struct window_pane *);\nvoid\t\t window_pane_stack_remove(struct window_panes *,\n\t\t     struct window_pane *);\nvoid\t\t window_set_name(struct window *, const char *);\nvoid\t\t window_add_ref(struct window *, const char *);\nvoid\t\t window_remove_ref(struct window *, const char *);\nvoid\t\t winlink_clear_flags(struct winlink *);\nint\t\t winlink_shuffle_up(struct session *, struct winlink *, int);\nint\t\t window_pane_start_input(struct window_pane *,\n\t\t     struct cmdq_item *, char **);\nvoid\t\t*window_pane_get_new_data(struct window_pane *,\n\t\t     struct window_pane_offset *, size_t *);\nvoid\t\t window_pane_update_used_data(struct window_pane *,\n\t\t     struct window_pane_offset *, size_t);\nvoid\t\t window_set_fill_character(struct window *);\nvoid\t\t window_pane_default_cursor(struct window_pane *);\nint\t\t window_pane_mode(struct window_pane *);\nint\t\t window_pane_show_scrollbar(struct window_pane *, int);\n\n/* layout.c */\nu_int\t\t layout_count_cells(struct layout_cell *);\nstruct layout_cell *layout_create_cell(struct layout_cell *);\nvoid\t\t layout_free_cell(struct layout_cell *);\nvoid\t\t layout_print_cell(struct layout_cell *, const char *, u_int);\nvoid\t\t layout_destroy_cell(struct window *, struct layout_cell *,\n\t\t     struct layout_cell **);\nvoid\t\t layout_resize_layout(struct window *, struct layout_cell *,\n\t\t     enum layout_type, int, int);\nstruct layout_cell *layout_search_by_border(struct layout_cell *, u_int, u_int);\nvoid\t\t layout_set_size(struct layout_cell *, u_int, u_int, u_int,\n\t\t     u_int);\nvoid\t\t layout_make_leaf(struct layout_cell *, struct window_pane *);\nvoid\t\t layout_make_node(struct layout_cell *, enum layout_type);\nvoid\t\t layout_fix_offsets(struct window *);\nvoid\t\t layout_fix_panes(struct window *, struct window_pane *);\nvoid\t\t layout_resize_adjust(struct window *, struct layout_cell *,\n\t\t     enum layout_type, int);\nvoid\t\t layout_init(struct window *, struct window_pane *);\nvoid\t\t layout_free(struct window *);\nvoid\t\t layout_resize(struct window *, u_int, u_int);\nvoid\t\t layout_resize_pane(struct window_pane *, enum layout_type,\n\t\t     int, int);\nvoid\t\t layout_resize_pane_to(struct window_pane *, enum layout_type,\n\t\t     u_int);\nvoid\t\t layout_assign_pane(struct layout_cell *, struct window_pane *,\n\t\t     int);\nstruct layout_cell *layout_split_pane(struct window_pane *, enum layout_type,\n\t\t     int, int);\nvoid\t\t layout_close_pane(struct window_pane *);\nint\t\t layout_spread_cell(struct window *, struct layout_cell *);\nvoid\t\t layout_spread_out(struct window_pane *);\n\n/* layout-custom.c */\nchar\t\t*layout_dump(struct layout_cell *);\nint\t\t layout_parse(struct window *, const char *, char **);\n\n/* layout-set.c */\nint\t\t layout_set_lookup(const char *);\nu_int\t\t layout_set_select(struct window *, u_int);\nu_int\t\t layout_set_next(struct window *);\nu_int\t\t layout_set_previous(struct window *);\n\n/* mode-tree.c */\ntypedef void (*mode_tree_build_cb)(void *, struct mode_tree_sort_criteria *,\n\t\t\t\t   uint64_t *, const char *);\ntypedef void (*mode_tree_draw_cb)(void *, void *, struct screen_write_ctx *,\n\t     u_int, u_int);\ntypedef int (*mode_tree_search_cb)(void *, void *, const char *);\ntypedef void (*mode_tree_menu_cb)(void *, struct client *, key_code);\ntypedef u_int (*mode_tree_height_cb)(void *, u_int);\ntypedef key_code (*mode_tree_key_cb)(void *, void *, u_int);\ntypedef void (*mode_tree_each_cb)(void *, void *, struct client *, key_code);\nu_int\t mode_tree_count_tagged(struct mode_tree_data *);\nvoid\t*mode_tree_get_current(struct mode_tree_data *);\nconst char *mode_tree_get_current_name(struct mode_tree_data *);\nvoid\t mode_tree_expand_current(struct mode_tree_data *);\nvoid\t mode_tree_collapse_current(struct mode_tree_data *);\nvoid\t mode_tree_expand(struct mode_tree_data *, uint64_t);\nint\t mode_tree_set_current(struct mode_tree_data *, uint64_t);\nvoid\t mode_tree_each_tagged(struct mode_tree_data *, mode_tree_each_cb,\n\t     struct client *, key_code, int);\nvoid\t mode_tree_up(struct mode_tree_data *, int);\nint\t mode_tree_down(struct mode_tree_data *, int);\nstruct mode_tree_data *mode_tree_start(struct window_pane *, struct args *,\n\t     mode_tree_build_cb, mode_tree_draw_cb, mode_tree_search_cb,\n\t     mode_tree_menu_cb, mode_tree_height_cb, mode_tree_key_cb, void *,\n\t     const struct menu_item *, const char **, u_int, struct screen **);\nvoid\t mode_tree_zoom(struct mode_tree_data *, struct args *);\nvoid\t mode_tree_build(struct mode_tree_data *);\nvoid\t mode_tree_free(struct mode_tree_data *);\nvoid\t mode_tree_resize(struct mode_tree_data *, u_int, u_int);\nstruct mode_tree_item *mode_tree_add(struct mode_tree_data *,\n\t     struct mode_tree_item *, void *, uint64_t, const char *,\n\t     const char *, int);\nvoid\t mode_tree_draw_as_parent(struct mode_tree_item *);\nvoid\t mode_tree_no_tag(struct mode_tree_item *);\nvoid\t mode_tree_remove(struct mode_tree_data *, struct mode_tree_item *);\nvoid\t mode_tree_draw(struct mode_tree_data *);\nint\t mode_tree_key(struct mode_tree_data *, struct client *, key_code *,\n\t     struct mouse_event *, u_int *, u_int *);\nvoid\t mode_tree_run_command(struct client *, struct cmd_find_state *,\n\t     const char *, const char *);\n\n/* window-buffer.c */\nextern const struct window_mode window_buffer_mode;\n\n/* window-tree.c */\nextern const struct window_mode window_tree_mode;\n\n/* window-clock.c */\nextern const struct window_mode window_clock_mode;\nextern const char window_clock_table[14][5][5];\n\n/* window-client.c */\nextern const struct window_mode window_client_mode;\n\n/* window-copy.c */\nextern const struct window_mode window_copy_mode;\nextern const struct window_mode window_view_mode;\nvoid printflike(3, 4) window_copy_add(struct window_pane *, int, const char *,\n\t\t     ...);\nvoid printflike(3, 0) window_copy_vadd(struct window_pane *, int, const char *,\n\t\t     va_list);\nvoid\t\t window_copy_scroll(struct window_pane *, int, u_int, int);\nvoid\t\t window_copy_pageup(struct window_pane *, int);\nvoid\t\t window_copy_pagedown(struct window_pane *, int, int);\nvoid\t\t window_copy_start_drag(struct client *, struct mouse_event *);\nchar\t\t*window_copy_get_word(struct window_pane *, u_int, u_int);\nchar\t\t*window_copy_get_line(struct window_pane *, u_int);\nint\t\t window_copy_get_current_offset(struct window_pane *, u_int *,\n\t\t     u_int *);\n\n/* window-option.c */\nextern const struct window_mode window_customize_mode;\n\n/* names.c */\nvoid\t check_window_name(struct window *);\nchar\t*default_window_name(struct window *);\nchar\t*parse_window_name(const char *);\n\n/* control.c */\nvoid\tcontrol_discard(struct client *);\nvoid\tcontrol_start(struct client *);\nvoid\tcontrol_ready(struct client *);\nvoid\tcontrol_stop(struct client *);\nvoid\tcontrol_set_pane_on(struct client *, struct window_pane *);\nvoid\tcontrol_set_pane_off(struct client *, struct window_pane *);\nvoid\tcontrol_continue_pane(struct client *, struct window_pane *);\nvoid\tcontrol_pause_pane(struct client *, struct window_pane *);\nstruct window_pane_offset *control_pane_offset(struct client *,\n\t   struct window_pane *, int *);\nvoid\tcontrol_reset_offsets(struct client *);\nvoid printflike(2, 3) control_write(struct client *, const char *, ...);\nvoid\tcontrol_write_output(struct client *, struct window_pane *);\nint\tcontrol_all_done(struct client *);\nvoid\tcontrol_add_sub(struct client *, const char *, enum control_sub_type,\n    \t   int, const char *);\nvoid\tcontrol_remove_sub(struct client *, const char *);\n\n/* control-notify.c */\nvoid\tcontrol_notify_pane_mode_changed(int);\nvoid\tcontrol_notify_window_layout_changed(struct window *);\nvoid\tcontrol_notify_window_pane_changed(struct window *);\nvoid\tcontrol_notify_window_unlinked(struct session *, struct window *);\nvoid\tcontrol_notify_window_linked(struct session *, struct window *);\nvoid\tcontrol_notify_window_renamed(struct window *);\nvoid\tcontrol_notify_client_session_changed(struct client *);\nvoid\tcontrol_notify_client_detached(struct client *);\nvoid\tcontrol_notify_session_renamed(struct session *);\nvoid\tcontrol_notify_session_created(struct session *);\nvoid\tcontrol_notify_session_closed(struct session *);\nvoid\tcontrol_notify_session_window_changed(struct session *);\nvoid\tcontrol_notify_paste_buffer_changed(const char *);\nvoid\tcontrol_notify_paste_buffer_deleted(const char *);\n\n/* session.c */\nextern struct sessions sessions;\nextern struct session_groups session_groups;\nextern u_int next_session_id;\nint\tsession_cmp(struct session *, struct session *);\nRB_PROTOTYPE(sessions, session, entry, session_cmp);\nint\tsession_group_cmp(struct session_group *, struct session_group *s2);\nRB_PROTOTYPE(session_groups, session_group, entry, session_group_cmp);\nint\t\t session_alive(struct session *);\nstruct session\t*session_find(const char *);\nstruct session\t*session_find_by_id_str(const char *);\nstruct session\t*session_find_by_id(u_int);\nstruct session\t*session_create(const char *, const char *, const char *,\n\t\t     struct environ *, struct options *, struct termios *);\nvoid\t\t session_destroy(struct session *, int,\t const char *);\nvoid\t\t session_add_ref(struct session *, const char *);\nvoid\t\t session_remove_ref(struct session *, const char *);\nchar\t\t*session_check_name(const char *);\nvoid\t\t session_update_activity(struct session *, struct timeval *);\nstruct session\t*session_next_session(struct session *);\nstruct session\t*session_previous_session(struct session *);\nstruct winlink\t*session_attach(struct session *, struct window *, int,\n\t\t     char **);\nint\t\t session_detach(struct session *, struct winlink *);\nint\t\t session_has(struct session *, struct window *);\nint\t\t session_is_linked(struct session *, struct window *);\nint\t\t session_next(struct session *, int);\nint\t\t session_previous(struct session *, int);\nint\t\t session_select(struct session *, int);\nint\t\t session_last(struct session *);\nint\t\t session_set_current(struct session *, struct winlink *);\nstruct session_group *session_group_contains(struct session *);\nstruct session_group *session_group_find(const char *);\nstruct session_group *session_group_new(const char *);\nvoid\t\t session_group_add(struct session_group *, struct session *);\nvoid\t\t session_group_synchronize_to(struct session *);\nvoid\t\t session_group_synchronize_from(struct session *);\nu_int\t\t session_group_count(struct session_group *);\nu_int\t\t session_group_attached_count(struct session_group *);\nvoid\t\t session_renumber_windows(struct session *);\n\n/* utf8.c */\nenum utf8_state\t utf8_towc (const struct utf8_data *, wchar_t *);\nenum utf8_state\t utf8_fromwc(wchar_t wc, struct utf8_data *);\nint\t\t utf8_in_table(wchar_t, const wchar_t *, u_int);\nvoid\t\t utf8_update_width_cache(void);\nutf8_char\t utf8_build_one(u_char);\nenum utf8_state\t utf8_from_data(const struct utf8_data *, utf8_char *);\nvoid\t\t utf8_to_data(utf8_char, struct utf8_data *);\nvoid\t\t utf8_set(struct utf8_data *, u_char);\nvoid\t\t utf8_copy(struct utf8_data *, const struct utf8_data *);\nenum utf8_state\t utf8_open(struct utf8_data *, u_char);\nenum utf8_state\t utf8_append(struct utf8_data *, u_char);\nint\t\t utf8_isvalid(const char *);\nint\t\t utf8_strvis(char *, const char *, size_t, int);\nint\t\t utf8_stravis(char **, const char *, int);\nint\t\t utf8_stravisx(char **, const char *, size_t, int);\nchar\t\t*utf8_sanitize(const char *);\nsize_t\t\t utf8_strlen(const struct utf8_data *);\nu_int\t\t utf8_strwidth(const struct utf8_data *, ssize_t);\nstruct utf8_data *utf8_fromcstr(const char *);\nchar\t\t*utf8_tocstr(struct utf8_data *);\nu_int\t\t utf8_cstrwidth(const char *);\nchar\t\t*utf8_padcstr(const char *, u_int);\nchar\t\t*utf8_rpadcstr(const char *, u_int);\nint\t\t utf8_cstrhas(const char *, const struct utf8_data *);\n\n/* osdep-*.c */\nchar\t\t*osdep_get_name(int, char *);\nchar\t\t*osdep_get_cwd(int);\nstruct event_base *osdep_event_init(void);\n\n/* utf8-combined.c */\nint\t\t utf8_has_zwj(const struct utf8_data *);\nint\t\t utf8_is_zwj(const struct utf8_data *);\nint\t\t utf8_is_vs(const struct utf8_data *);\nint\t\t utf8_is_modifier(const struct utf8_data *);\n\n/* procname.c */\nchar   *get_proc_name(int, char *);\nchar   *get_proc_cwd(int);\n\n/* log.c */\nvoid\tlog_add_level(void);\nint\tlog_get_level(void);\nvoid\tlog_open(const char *);\nvoid\tlog_toggle(const char *);\nvoid\tlog_close(void);\nvoid printflike(1, 2) log_debug(const char *, ...);\n__dead void printflike(1, 2) fatal(const char *, ...);\n__dead void printflike(1, 2) fatalx(const char *, ...);\n\n/* menu.c */\n#define MENU_NOMOUSE 0x1\n#define MENU_TAB 0x2\n#define MENU_STAYOPEN 0x4\nstruct menu\t*menu_create(const char *);\nvoid\t\t menu_add_items(struct menu *, const struct menu_item *,\n\t\t    struct cmdq_item *, struct client *,\n\t\t    struct cmd_find_state *);\nvoid\t\t menu_add_item(struct menu *, const struct menu_item *,\n\t\t    struct cmdq_item *, struct client *,\n\t\t    struct cmd_find_state *);\nvoid\t\t menu_free(struct menu *);\nstruct menu_data *menu_prepare(struct menu *, int, int, struct cmdq_item *,\n\t\t    u_int, u_int, struct client *, enum box_lines, const char *,\n\t\t    const char *, const char *, struct cmd_find_state *,\n\t\t    menu_choice_cb, void *);\nint\t\t menu_display(struct menu *, int, int, struct cmdq_item *,\n\t\t    u_int, u_int, struct client *, enum box_lines, const char *,\n\t\t    const char *, const char *, struct cmd_find_state *,\n\t\t    menu_choice_cb, void *);\nstruct screen\t*menu_mode_cb(struct client *, void *, u_int *, u_int *);\nvoid\t\t menu_check_cb(struct client *, void *, u_int, u_int, u_int,\n\t\t    struct overlay_ranges *);\nvoid\t\t menu_draw_cb(struct client *, void *,\n\t\t    struct screen_redraw_ctx *);\nvoid\t\t menu_free_cb(struct client *, void *);\nint\t\t menu_key_cb(struct client *, void *, struct key_event *);\n\n/* popup.c */\n#define POPUP_CLOSEEXIT 0x1\n#define POPUP_CLOSEEXITZERO 0x2\n#define POPUP_INTERNAL 0x4\ntypedef void (*popup_close_cb)(int, void *);\ntypedef void (*popup_finish_edit_cb)(char *, size_t, void *);\nint\t\t popup_display(int, enum box_lines, struct cmdq_item *, u_int,\n                    u_int, u_int, u_int, struct environ *, const char *, int,\n                    char **, const char *, const char *, struct client *,\n                    struct session *, const char *, const char *,\n                    popup_close_cb, void *);\nint\t\t popup_editor(struct client *, const char *, size_t,\n\t\t    popup_finish_edit_cb, void *);\n\n/* style.c */\nint\t\t style_parse(struct style *,const struct grid_cell *,\n\t\t     const char *);\nconst char\t*style_tostring(struct style *);\nvoid\t\t style_add(struct grid_cell *, struct options *,\n\t\t     const char *, struct format_tree *);\nvoid\t\t style_apply(struct grid_cell *, struct options *,\n\t\t     const char *, struct format_tree *);\nvoid\t\t style_set(struct style *, const struct grid_cell *);\nvoid\t\t style_copy(struct style *, struct style *);\nvoid\t\t style_set_scrollbar_style_from_option(struct style *,\n\t\t     struct options *);\n\n/* spawn.c */\nstruct winlink\t*spawn_window(struct spawn_context *, char **);\nstruct window_pane *spawn_pane(struct spawn_context *, char **);\n\n/* regsub.c */\nchar\t\t*regsub(const char *, const char *, const char *, int);\n\n#ifdef ENABLE_SIXEL\n/* image.c */\nint\t\t image_free_all(struct screen *);\nstruct image\t*image_store(struct screen *, struct sixel_image *);\nint\t\t image_check_line(struct screen *, u_int, u_int);\nint\t\t image_check_area(struct screen *, u_int, u_int, u_int, u_int);\nint\t\t image_scroll_up(struct screen *, u_int);\n\n/* image-sixel.c */\n#define SIXEL_COLOUR_REGISTERS 1024\nstruct sixel_image *sixel_parse(const char *, size_t, u_int, u_int, u_int);\nvoid\t\t sixel_free(struct sixel_image *);\nvoid\t\t sixel_log(struct sixel_image *);\nvoid\t\t sixel_size_in_cells(struct sixel_image *, u_int *, u_int *);\nstruct sixel_image *sixel_scale(struct sixel_image *, u_int, u_int, u_int,\n\t\t     u_int, u_int, u_int, int);\nchar\t\t*sixel_print(struct sixel_image *, struct sixel_image *,\n\t\t     size_t *);\nstruct screen\t*sixel_to_screen(struct sixel_image *);\n#endif\n\n/* server-acl.c */\nvoid\t\t\t server_acl_init(void);\nstruct server_acl_user\t*server_acl_user_find(uid_t);\nvoid \t\t\t server_acl_display(struct cmdq_item *);\nvoid\t\t\t server_acl_user_allow(uid_t);\nvoid\t\t\t server_acl_user_deny(uid_t);\nvoid\t\t\t server_acl_user_allow_write(uid_t);\nvoid\t\t\t server_acl_user_deny_write(uid_t);\nint\t\t\t server_acl_join(struct client *);\nuid_t\t\t\t server_acl_get_uid(struct server_acl_user *);\n\n/* hyperlink.c */\nu_int\t \t\t hyperlinks_put(struct hyperlinks *, const char *,\n\t\t\t     const char *);\nint\t\t\t hyperlinks_get(struct hyperlinks *, u_int,\n\t\t\t     const char **, const char **, const char **);\nstruct hyperlinks\t*hyperlinks_init(void);\nstruct hyperlinks\t*hyperlinks_copy(struct hyperlinks *);\nvoid\t\t\t hyperlinks_reset(struct hyperlinks *);\nvoid\t\t\t hyperlinks_free(struct hyperlinks *);\n\n#endif /* TMUX_H */\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "tty-acs.c",
          "type": "blob",
          "size": 7.9921875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/* Table mapping ACS entries to UTF-8. */\nstruct tty_acs_entry {\n\tu_char\t\t key;\n\tconst char\t*string;\n};\nstatic const struct tty_acs_entry tty_acs_table[] = {\n\t{ '+', \"\\342\\206\\222\" },\t/* arrow pointing right */\n\t{ ',', \"\\342\\206\\220\" },\t/* arrow pointing left */\n\t{ '-', \"\\342\\206\\221\" },\t/* arrow pointing up */\n\t{ '.', \"\\342\\206\\223\" },\t/* arrow pointing down */\n\t{ '0', \"\\342\\226\\256\" },\t/* solid square block */\n\t{ '`', \"\\342\\227\\206\" },\t/* diamond */\n\t{ 'a', \"\\342\\226\\222\" },\t/* checker board (stipple) */\n\t{ 'b', \"\\342\\220\\211\" },\n\t{ 'c', \"\\342\\220\\214\" },\n\t{ 'd', \"\\342\\220\\215\" },\n\t{ 'e', \"\\342\\220\\212\" },\n\t{ 'f', \"\\302\\260\" },\t\t/* degree symbol */\n\t{ 'g', \"\\302\\261\" },\t\t/* plus/minus */\n\t{ 'h', \"\\342\\220\\244\" },\n\t{ 'i', \"\\342\\220\\213\" },\n\t{ 'j', \"\\342\\224\\230\" },\t/* lower right corner */\n\t{ 'k', \"\\342\\224\\220\" },\t/* upper right corner */\n\t{ 'l', \"\\342\\224\\214\" },\t/* upper left corner */\n\t{ 'm', \"\\342\\224\\224\" },\t/* lower left corner */\n\t{ 'n', \"\\342\\224\\274\" },\t/* large plus or crossover */\n\t{ 'o', \"\\342\\216\\272\" },\t/* scan line 1 */\n\t{ 'p', \"\\342\\216\\273\" },\t/* scan line 3 */\n\t{ 'q', \"\\342\\224\\200\" },\t/* horizontal line */\n\t{ 'r', \"\\342\\216\\274\" },\t/* scan line 7 */\n\t{ 's', \"\\342\\216\\275\" },\t/* scan line 9 */\n\t{ 't', \"\\342\\224\\234\" },\t/* tee pointing right */\n\t{ 'u', \"\\342\\224\\244\" },\t/* tee pointing left */\n\t{ 'v', \"\\342\\224\\264\" },\t/* tee pointing up */\n\t{ 'w', \"\\342\\224\\254\" },\t/* tee pointing down */\n\t{ 'x', \"\\342\\224\\202\" },\t/* vertical line */\n\t{ 'y', \"\\342\\211\\244\" },\t/* less-than-or-equal-to */\n\t{ 'z', \"\\342\\211\\245\" },\t/* greater-than-or-equal-to */\n\t{ '{', \"\\317\\200\" },\t\t/* greek pi */\n\t{ '|', \"\\342\\211\\240\" },\t/* not-equal */\n\t{ '}', \"\\302\\243\" },\t\t/* UK pound sign */\n\t{ '~', \"\\302\\267\" }\t\t/* bullet */\n};\n\n/* Table mapping UTF-8 to ACS entries. */\nstruct tty_acs_reverse_entry {\n\tconst char\t*string;\n\tu_char\t\t key;\n};\nstatic const struct tty_acs_reverse_entry tty_acs_reverse2[] = {\n\t{ \"\\302\\267\", '~' }\n};\nstatic const struct tty_acs_reverse_entry tty_acs_reverse3[] = {\n\t{ \"\\342\\224\\200\", 'q' },\n\t{ \"\\342\\224\\201\", 'q' },\n\t{ \"\\342\\224\\202\", 'x' },\n\t{ \"\\342\\224\\203\", 'x' },\n\t{ \"\\342\\224\\214\", 'l' },\n\t{ \"\\342\\224\\217\", 'k' },\n\t{ \"\\342\\224\\220\", 'k' },\n\t{ \"\\342\\224\\223\", 'l' },\n\t{ \"\\342\\224\\224\", 'm' },\n\t{ \"\\342\\224\\227\", 'm' },\n\t{ \"\\342\\224\\230\", 'j' },\n\t{ \"\\342\\224\\233\", 'j' },\n\t{ \"\\342\\224\\234\", 't' },\n\t{ \"\\342\\224\\243\", 't' },\n\t{ \"\\342\\224\\244\", 'u' },\n\t{ \"\\342\\224\\253\", 'u' },\n\t{ \"\\342\\224\\263\", 'w' },\n\t{ \"\\342\\224\\264\", 'v' },\n\t{ \"\\342\\224\\273\", 'v' },\n\t{ \"\\342\\224\\274\", 'n' },\n\t{ \"\\342\\225\\213\", 'n' },\n\t{ \"\\342\\225\\220\", 'q' },\n\t{ \"\\342\\225\\221\", 'x' },\n\t{ \"\\342\\225\\224\", 'l' },\n\t{ \"\\342\\225\\227\", 'k' },\n\t{ \"\\342\\225\\232\", 'm' },\n\t{ \"\\342\\225\\235\", 'j' },\n\t{ \"\\342\\225\\240\", 't' },\n\t{ \"\\342\\225\\243\", 'u' },\n\t{ \"\\342\\225\\246\", 'w' },\n\t{ \"\\342\\225\\251\", 'v' },\n\t{ \"\\342\\225\\254\", 'n' },\n};\n\n/* UTF-8 double borders. */\nstatic const struct utf8_data tty_acs_double_borders_list[] = {\n\t{ \"\", 0, 0, 0 },\n\t{ \"\\342\\225\\221\", 0, 3, 1 }, /* U+2551 */\n\t{ \"\\342\\225\\220\", 0, 3, 1 }, /* U+2550 */\n\t{ \"\\342\\225\\224\", 0, 3, 1 }, /* U+2554 */\n\t{ \"\\342\\225\\227\", 0, 3, 1 }, /* U+2557 */\n\t{ \"\\342\\225\\232\", 0, 3, 1 }, /* U+255A */\n\t{ \"\\342\\225\\235\", 0, 3, 1 }, /* U+255D */\n\t{ \"\\342\\225\\246\", 0, 3, 1 }, /* U+2566 */\n\t{ \"\\342\\225\\251\", 0, 3, 1 }, /* U+2569 */\n\t{ \"\\342\\225\\240\", 0, 3, 1 }, /* U+2560 */\n\t{ \"\\342\\225\\243\", 0, 3, 1 }, /* U+2563 */\n\t{ \"\\342\\225\\254\", 0, 3, 1 }, /* U+256C */\n\t{ \"\\302\\267\",\t  0, 2, 1 }  /* U+00B7 */\n};\n\n/* UTF-8 heavy borders. */\nstatic const struct utf8_data tty_acs_heavy_borders_list[] = {\n\t{ \"\", 0, 0, 0 },\n\t{ \"\\342\\224\\203\", 0, 3, 1 }, /* U+2503 */\n\t{ \"\\342\\224\\201\", 0, 3, 1 }, /* U+2501 */\n\t{ \"\\342\\224\\217\", 0, 3, 1 }, /* U+250F */\n\t{ \"\\342\\224\\223\", 0, 3, 1 }, /* U+2513 */\n\t{ \"\\342\\224\\227\", 0, 3, 1 }, /* U+2517 */\n\t{ \"\\342\\224\\233\", 0, 3, 1 }, /* U+251B */\n\t{ \"\\342\\224\\263\", 0, 3, 1 }, /* U+2533 */\n\t{ \"\\342\\224\\273\", 0, 3, 1 }, /* U+253B */\n\t{ \"\\342\\224\\243\", 0, 3, 1 }, /* U+2523 */\n\t{ \"\\342\\224\\253\", 0, 3, 1 }, /* U+252B */\n\t{ \"\\342\\225\\213\", 0, 3, 1 }, /* U+254B */\n\t{ \"\\302\\267\",\t  0, 2, 1 }  /* U+00B7 */\n};\n\n/* UTF-8 rounded borders. */\nstatic const struct utf8_data tty_acs_rounded_borders_list[] = {\n\t{ \"\", 0, 0, 0 },\n\t{ \"\\342\\224\\202\", 0, 3, 1 }, /* U+2502 */\n\t{ \"\\342\\224\\200\", 0, 3, 1 }, /* U+2500 */\n\t{ \"\\342\\225\\255\", 0, 3, 1 }, /* U+256D */\n\t{ \"\\342\\225\\256\", 0, 3, 1 }, /* U+256E */\n\t{ \"\\342\\225\\260\", 0, 3, 1 }, /* U+2570 */\n\t{ \"\\342\\225\\257\", 0, 3, 1 }, /* U+256F */\n\t{ \"\\342\\224\\263\", 0, 3, 1 }, /* U+2533 */\n\t{ \"\\342\\224\\273\", 0, 3, 1 }, /* U+253B */\n\t{ \"\\342\\224\\234\", 0, 3, 1 }, /* U+2524 */\n\t{ \"\\342\\224\\244\", 0, 3, 1 }, /* U+251C */\n\t{ \"\\342\\225\\213\", 0, 3, 1 }, /* U+254B */\n\t{ \"\\302\\267\",\t  0, 2, 1 }  /* U+00B7 */\n};\n\n/* Get cell border character for double style. */\nconst struct utf8_data *\ntty_acs_double_borders(int cell_type)\n{\n\treturn (&tty_acs_double_borders_list[cell_type]);\n}\n\n/* Get cell border character for heavy style. */\nconst struct utf8_data *\ntty_acs_heavy_borders(int cell_type)\n{\n\treturn (&tty_acs_heavy_borders_list[cell_type]);\n}\n\n/* Get cell border character for rounded style. */\nconst struct utf8_data *\ntty_acs_rounded_borders(int cell_type)\n{\n\treturn (&tty_acs_rounded_borders_list[cell_type]);\n}\n\nstatic int\ntty_acs_cmp(const void *key, const void *value)\n{\n\tconst struct tty_acs_entry\t*entry = value;\n\tint\t\t\t\t test = *(u_char *)key;\n\n\treturn (test - entry->key);\n}\n\nstatic int\ntty_acs_reverse_cmp(const void *key, const void *value)\n{\n\tconst struct tty_acs_reverse_entry\t*entry = value;\n\tconst char\t\t\t\t*test = key;\n\n\treturn (strcmp(test, entry->string));\n}\n\n/* Should this terminal use ACS instead of UTF-8 line drawing? */\nint\ntty_acs_needed(struct tty *tty)\n{\n\tif (tty == NULL)\n\t\treturn (0);\n\n\t/*\n\t * If the U8 flag is present, it marks whether a terminal supports\n\t * UTF-8 and ACS together.\n\t *\n\t * If it is present and zero, we force ACS - this gives users a way to\n\t * turn off UTF-8 line drawing.\n\t *\n\t * If it is nonzero, we can fall through to the default and use UTF-8\n\t * line drawing on UTF-8 terminals.\n\t */\n\tif (tty_term_has(tty->term, TTYC_U8) &&\n\t    tty_term_number(tty->term, TTYC_U8) == 0)\n\t\treturn (1);\n\n\tif (tty->client->flags & CLIENT_UTF8)\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Retrieve ACS to output as UTF-8. */\nconst char *\ntty_acs_get(struct tty *tty, u_char ch)\n{\n\tconst struct tty_acs_entry\t*entry;\n\n\t/* Use the ACS set instead of UTF-8 if needed. */\n\tif (tty_acs_needed(tty)) {\n\t\tif (tty->term->acs[ch][0] == '\\0')\n\t\t\treturn (NULL);\n\t\treturn (&tty->term->acs[ch][0]);\n\t}\n\n\t/* Otherwise look up the UTF-8 translation. */\n\tentry = bsearch(&ch, tty_acs_table, nitems(tty_acs_table),\n\t    sizeof tty_acs_table[0], tty_acs_cmp);\n\tif (entry == NULL)\n\t\treturn (NULL);\n\treturn (entry->string);\n}\n\n/* Reverse UTF-8 into ACS. */\nint\ntty_acs_reverse_get(__unused struct tty *tty, const char *s, size_t slen)\n{\n\tconst struct tty_acs_reverse_entry\t*table, *entry;\n\tu_int\t\t\t\t\t items;\n\n\tif (slen == 2) {\n\t\ttable = tty_acs_reverse2;\n\t\titems = nitems(tty_acs_reverse2);\n\t} else if (slen == 3) {\n\t\ttable = tty_acs_reverse3;\n\t\titems = nitems(tty_acs_reverse3);\n\t} else\n\t\treturn (-1);\n\tentry = bsearch(s, table, items, sizeof table[0], tty_acs_reverse_cmp);\n\tif (entry == NULL)\n\t\treturn (-1);\n\treturn (entry->key);\n}\n"
        },
        {
          "name": "tty-features.c",
          "type": "blob",
          "size": 11.4384765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2020 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(HAVE_CURSES_H)\n#include <curses.h>\n#elif defined(HAVE_NCURSES_H)\n#include <ncurses.h>\n#endif\n\n#include \"tmux.h\"\n\n/*\n * Still hardcoded:\n * - default colours (under AX or op capabilities);\n * - AIX colours (under colors >= 16);\n * - alternate escape (if terminal is VT100-like).\n *\n * Also:\n * - DECFRA uses a flag instead of capabilities;\n * - UTF-8 is a separate flag on the client; needed for unattached clients.\n */\n\n/* A named terminal feature. */\nstruct tty_feature {\n\tconst char\t\t*name;\n\tconst char *const\t*capabilities;\n\tint\t\t\t flags;\n};\n\n/* Terminal has xterm(1) title setting. */\nstatic const char *const tty_feature_title_capabilities[] = {\n\t\"tsl=\\\\E]0;\", /* should be using TS really */\n\t\"fsl=\\\\a\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_title = {\n\t\"title\",\n\ttty_feature_title_capabilities,\n\t0\n};\n\n/* Terminal has OSC 7 working directory. */\nstatic const char *const tty_feature_osc7_capabilities[] = {\n\t\"Swd=\\\\E]7;\",\n\t\"fsl=\\\\a\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_osc7 = {\n\t\"osc7\",\n\ttty_feature_osc7_capabilities,\n\t0\n};\n\n/* Terminal has mouse support. */\nstatic const char *const tty_feature_mouse_capabilities[] = {\n\t\"kmous=\\\\E[M\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_mouse = {\n\t\"mouse\",\n\ttty_feature_mouse_capabilities,\n\t0\n};\n\n/* Terminal can set the clipboard with OSC 52. */\nstatic const char *const tty_feature_clipboard_capabilities[] = {\n\t\"Ms=\\\\E]52;%p1%s;%p2%s\\\\a\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_clipboard = {\n\t\"clipboard\",\n\ttty_feature_clipboard_capabilities,\n\t0\n};\n\n/* Terminal supports OSC 8 hyperlinks. */\nstatic const char *tty_feature_hyperlinks_capabilities[] = {\n#if defined (__OpenBSD__) || (defined(NCURSES_VERSION_MAJOR) && \\\n\t(NCURSES_VERSION_MAJOR > 5 || \\\n\t(NCURSES_VERSION_MAJOR == 5 && NCURSES_VERSION_MINOR > 8)))\n\t\"*:Hls=\\\\E]8;%?%p1%l%tid=%p1%s%;;%p2%s\\\\E\\\\\\\\\",\n#endif\n\tNULL\n};\nstatic const struct tty_feature tty_feature_hyperlinks = {\n\t\"hyperlinks\",\n\ttty_feature_hyperlinks_capabilities,\n\t0\n};\n\n/*\n * Terminal supports RGB colour. This replaces setab and setaf also since\n * terminals with RGB have versions that do not allow setting colours from the\n * 256 palette.\n */\nstatic const char *const tty_feature_rgb_capabilities[] = {\n\t\"AX\",\n\t\"setrgbf=\\\\E[38;2;%p1%d;%p2%d;%p3%dm\",\n\t\"setrgbb=\\\\E[48;2;%p1%d;%p2%d;%p3%dm\",\n\t\"setab=\\\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m\",\n\t\"setaf=\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_rgb = {\n\t\"RGB\",\n\ttty_feature_rgb_capabilities,\n\tTERM_256COLOURS|TERM_RGBCOLOURS\n};\n\n/* Terminal supports 256 colours. */\nstatic const char *const tty_feature_256_capabilities[] = {\n\t\"AX\",\n\t\"setab=\\\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m\",\n\t\"setaf=\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_256 = {\n\t\"256\",\n\ttty_feature_256_capabilities,\n\tTERM_256COLOURS\n};\n\n/* Terminal supports overline. */\nstatic const char *const tty_feature_overline_capabilities[] = {\n\t\"Smol=\\\\E[53m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_overline = {\n\t\"overline\",\n\ttty_feature_overline_capabilities,\n\t0\n};\n\n/* Terminal supports underscore styles. */\nstatic const char *const tty_feature_usstyle_capabilities[] = {\n\t\"Smulx=\\\\E[4::%p1%dm\",\n\t\"Setulc=\\\\E[58::2::%p1%{65536}%/%d::%p1%{256}%/%{255}%&%d::%p1%{255}%&%d%;m\",\n\t\"Setulc1=\\\\E[58::5::%p1%dm\",\n\t\"ol=\\\\E[59m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_usstyle = {\n\t\"usstyle\",\n\ttty_feature_usstyle_capabilities,\n\t0\n};\n\n/* Terminal supports bracketed paste. */\nstatic const char *const tty_feature_bpaste_capabilities[] = {\n\t\"Enbp=\\\\E[?2004h\",\n\t\"Dsbp=\\\\E[?2004l\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_bpaste = {\n\t\"bpaste\",\n\ttty_feature_bpaste_capabilities,\n\t0\n};\n\n/* Terminal supports focus reporting. */\nstatic const char *const tty_feature_focus_capabilities[] = {\n\t\"Enfcs=\\\\E[?1004h\",\n\t\"Dsfcs=\\\\E[?1004l\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_focus = {\n\t\"focus\",\n\ttty_feature_focus_capabilities,\n\t0\n};\n\n/* Terminal supports cursor styles. */\nstatic const char *const tty_feature_cstyle_capabilities[] = {\n\t\"Ss=\\\\E[%p1%d q\",\n\t\"Se=\\\\E[2 q\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_cstyle = {\n\t\"cstyle\",\n\ttty_feature_cstyle_capabilities,\n\t0\n};\n\n/* Terminal supports cursor colours. */\nstatic const char *const tty_feature_ccolour_capabilities[] = {\n\t\"Cs=\\\\E]12;%p1%s\\\\a\",\n\t\"Cr=\\\\E]112\\\\a\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_ccolour = {\n\t\"ccolour\",\n\ttty_feature_ccolour_capabilities,\n\t0\n};\n\n/* Terminal supports strikethrough. */\nstatic const char *const tty_feature_strikethrough_capabilities[] = {\n\t\"smxx=\\\\E[9m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_strikethrough = {\n\t\"strikethrough\",\n\ttty_feature_strikethrough_capabilities,\n\t0\n};\n\n/* Terminal supports synchronized updates. */\nstatic const char *const tty_feature_sync_capabilities[] = {\n\t\"Sync=\\\\E[?2026%?%p1%{1}%-%tl%eh%;\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_sync = {\n\t\"sync\",\n\ttty_feature_sync_capabilities,\n\t0\n};\n\n/* Terminal supports extended keys. */\nstatic const char *const tty_feature_extkeys_capabilities[] = {\n\t\"Eneks=\\\\E[>4;2m\",\n\t\"Dseks=\\\\E[>4m\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_extkeys = {\n\t\"extkeys\",\n\ttty_feature_extkeys_capabilities,\n\t0\n};\n\n/* Terminal supports DECSLRM margins. */\nstatic const char *const tty_feature_margins_capabilities[] = {\n\t\"Enmg=\\\\E[?69h\",\n\t\"Dsmg=\\\\E[?69l\",\n\t\"Clmg=\\\\E[s\",\n\t\"Cmg=\\\\E[%i%p1%d;%p2%ds\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_margins = {\n\t\"margins\",\n\ttty_feature_margins_capabilities,\n\tTERM_DECSLRM\n};\n\n/* Terminal supports DECFRA rectangle fill. */\nstatic const char *const tty_feature_rectfill_capabilities[] = {\n\t\"Rect\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_rectfill = {\n\t\"rectfill\",\n\ttty_feature_rectfill_capabilities,\n\tTERM_DECFRA\n};\n\n/* Use builtin function keys only. */\nstatic const char *const tty_feature_ignorefkeys_capabilities[] = {\n\t\"kf0@\",\n\t\"kf1@\",\n\t\"kf2@\",\n\t\"kf3@\",\n\t\"kf4@\",\n\t\"kf5@\",\n\t\"kf6@\",\n\t\"kf7@\",\n\t\"kf8@\",\n\t\"kf9@\",\n\t\"kf10@\",\n\t\"kf11@\",\n\t\"kf12@\",\n\t\"kf13@\",\n\t\"kf14@\",\n\t\"kf15@\",\n\t\"kf16@\",\n\t\"kf17@\",\n\t\"kf18@\",\n\t\"kf19@\",\n\t\"kf20@\",\n\t\"kf21@\",\n\t\"kf22@\",\n\t\"kf23@\",\n\t\"kf24@\",\n\t\"kf25@\",\n\t\"kf26@\",\n\t\"kf27@\",\n\t\"kf28@\",\n\t\"kf29@\",\n\t\"kf30@\",\n\t\"kf31@\",\n\t\"kf32@\",\n\t\"kf33@\",\n\t\"kf34@\",\n\t\"kf35@\",\n\t\"kf36@\",\n\t\"kf37@\",\n\t\"kf38@\",\n\t\"kf39@\",\n\t\"kf40@\",\n\t\"kf41@\",\n\t\"kf42@\",\n\t\"kf43@\",\n\t\"kf44@\",\n\t\"kf45@\",\n\t\"kf46@\",\n\t\"kf47@\",\n\t\"kf48@\",\n\t\"kf49@\",\n\t\"kf50@\",\n\t\"kf51@\",\n\t\"kf52@\",\n\t\"kf53@\",\n\t\"kf54@\",\n\t\"kf55@\",\n\t\"kf56@\",\n\t\"kf57@\",\n\t\"kf58@\",\n\t\"kf59@\",\n\t\"kf60@\",\n\t\"kf61@\",\n\t\"kf62@\",\n\t\"kf63@\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_ignorefkeys = {\n\t\"ignorefkeys\",\n\ttty_feature_ignorefkeys_capabilities,\n\t0\n};\n\n/* Terminal has sixel capability. */\nstatic const char *const tty_feature_sixel_capabilities[] = {\n\t\"Sxl\",\n\tNULL\n};\nstatic const struct tty_feature tty_feature_sixel = {\n\t\"sixel\",\n\ttty_feature_sixel_capabilities,\n\tTERM_SIXEL\n};\n\n/* Available terminal features. */\nstatic const struct tty_feature *const tty_features[] = {\n\t&tty_feature_256,\n\t&tty_feature_bpaste,\n\t&tty_feature_ccolour,\n\t&tty_feature_clipboard,\n\t&tty_feature_hyperlinks,\n\t&tty_feature_cstyle,\n\t&tty_feature_extkeys,\n\t&tty_feature_focus,\n\t&tty_feature_ignorefkeys,\n\t&tty_feature_margins,\n\t&tty_feature_mouse,\n\t&tty_feature_osc7,\n\t&tty_feature_overline,\n\t&tty_feature_rectfill,\n\t&tty_feature_rgb,\n\t&tty_feature_sixel,\n\t&tty_feature_strikethrough,\n\t&tty_feature_sync,\n\t&tty_feature_title,\n\t&tty_feature_usstyle\n};\n\nvoid\ntty_add_features(int *feat, const char *s, const char *separators)\n{\n\tconst struct tty_feature\t *tf;\n\tchar\t\t\t\t *next, *loop, *copy;\n\tu_int\t\t\t\t  i;\n\n\tlog_debug(\"adding terminal features %s\", s);\n\n\tloop = copy = xstrdup(s);\n\twhile ((next = strsep(&loop, separators)) != NULL) {\n\t\tfor (i = 0; i < nitems(tty_features); i++) {\n\t\t\ttf = tty_features[i];\n\t\t\tif (strcasecmp(tf->name, next) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == nitems(tty_features)) {\n\t\t\tlog_debug(\"unknown terminal feature: %s\", next);\n\t\t\tbreak;\n\t\t}\n\t\tif (~(*feat) & (1 << i)) {\n\t\t\tlog_debug(\"adding terminal feature: %s\", tf->name);\n\t\t\t(*feat) |= (1 << i);\n\t\t}\n\t}\n\tfree(copy);\n}\n\nconst char *\ntty_get_features(int feat)\n{\n\tconst struct tty_feature\t*tf;\n\tstatic char\t\t\t s[512];\n\tu_int\t\t\t\t i;\n\n\t*s = '\\0';\n\tfor (i = 0; i < nitems(tty_features); i++) {\n\t\tif (~feat & (1 << i))\n\t\t\tcontinue;\n\t\ttf = tty_features[i];\n\n\t\tstrlcat(s, tf->name, sizeof s);\n\t\tstrlcat(s, \",\", sizeof s);\n\t}\n\tif (*s != '\\0')\n\t\ts[strlen(s) - 1] = '\\0';\n\treturn (s);\n}\n\nint\ntty_apply_features(struct tty_term *term, int feat)\n{\n\tconst struct tty_feature\t*tf;\n\tconst char *const\t\t*capability;\n\tu_int\t\t\t\t i;\n\n\tif (feat == 0)\n\t\treturn (0);\n\tlog_debug(\"applying terminal features: %s\", tty_get_features(feat));\n\n\tfor (i = 0; i < nitems(tty_features); i++) {\n\t\tif ((term->features & (1 << i)) || (~feat & (1 << i)))\n\t\t\tcontinue;\n\t\ttf = tty_features[i];\n\n\t\tlog_debug(\"applying terminal feature: %s\", tf->name);\n\t\tif (tf->capabilities != NULL) {\n\t\t\tcapability = tf->capabilities;\n\t\t\twhile (*capability != NULL) {\n\t\t\t\tlog_debug(\"adding capability: %s\", *capability);\n\t\t\t\ttty_term_apply(term, *capability, 1);\n\t\t\t\tcapability++;\n\t\t\t}\n\t\t}\n\t\tterm->flags |= tf->flags;\n\t}\n\tif ((term->features | feat) == term->features)\n\t\treturn (0);\n\tterm->features |= feat;\n\treturn (1);\n}\n\nvoid\ntty_default_features(int *feat, const char *name, u_int version)\n{\n\tstatic const struct {\n\t\tconst char\t*name;\n\t\tu_int\t\t version;\n\t\tconst char\t*features;\n\t} table[] = {\n#define TTY_FEATURES_BASE_MODERN_XTERM \\\n\t\"256,RGB,bpaste,clipboard,mouse,strikethrough,title\"\n\t\t{ .name = \"mintty\",\n\t\t  .features = TTY_FEATURES_BASE_MODERN_XTERM\n\t\t\t      \",ccolour,cstyle,extkeys,margins,overline,usstyle\"\n\t\t},\n\t\t{ .name = \"tmux\",\n\t\t  .features = TTY_FEATURES_BASE_MODERN_XTERM\n\t\t\t      \",ccolour,cstyle,focus,overline,usstyle,hyperlinks\"\n\t\t},\n\t\t{ .name = \"rxvt-unicode\",\n\t\t  .features = \"256,bpaste,ccolour,cstyle,mouse,title,ignorefkeys\"\n\t\t},\n\t\t{ .name = \"iTerm2\",\n\t\t  .features = TTY_FEATURES_BASE_MODERN_XTERM\n\t\t\t      \",cstyle,extkeys,margins,usstyle,sync,osc7,hyperlinks\"\n\t\t},\n\t\t{ .name = \"foot\",\n\t\t  .features = TTY_FEATURES_BASE_MODERN_XTERM\n\t\t              \",cstyle,extkeys\"\n\t\t},\n\t\t{ .name = \"XTerm\",\n\t\t  /*\n\t\t   * xterm also supports DECSLRM and DECFRA, but they can be\n\t\t   * disabled so not set it here - they will be added if\n\t\t   * secondary DA shows VT420.\n\t\t   */\n\t\t  .features = TTY_FEATURES_BASE_MODERN_XTERM\n\t\t\t      \",ccolour,cstyle,extkeys,focus\"\n\t\t}\n\t};\n\tu_int\ti;\n\n\tfor (i = 0; i < nitems(table); i++) {\n\t\tif (strcmp(table[i].name, name) != 0)\n\t\t\tcontinue;\n\t\tif (version != 0 && version < table[i].version)\n\t\t\tcontinue;\n\t\ttty_add_features(feat, table[i].features, \",\");\n\t}\n}\n"
        },
        {
          "name": "tty-keys.c",
          "type": "blob",
          "size": 42.779296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <limits.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Handle keys input from the outside terminal. tty_default_*_keys[] are a base\n * table of supported keys which are looked up in terminfo(5) and translated\n * into a ternary tree.\n */\n\nstatic void\ttty_keys_add1(struct tty_key **, const char *, key_code);\nstatic void\ttty_keys_add(struct tty *, const char *, key_code);\nstatic void\ttty_keys_free1(struct tty_key *);\nstatic struct tty_key *tty_keys_find1(struct tty_key *, const char *, size_t,\n\t\t    size_t *);\nstatic struct tty_key *tty_keys_find(struct tty *, const char *, size_t,\n\t\t    size_t *);\nstatic int\ttty_keys_next1(struct tty *, const char *, size_t, key_code *,\n\t\t    size_t *, int);\nstatic void\ttty_keys_callback(int, short, void *);\nstatic int\ttty_keys_extended_key(struct tty *, const char *, size_t,\n\t\t    size_t *, key_code *);\nstatic int\ttty_keys_mouse(struct tty *, const char *, size_t, size_t *,\n\t\t    struct mouse_event *);\nstatic int\ttty_keys_clipboard(struct tty *, const char *, size_t,\n\t\t    size_t *);\nstatic int\ttty_keys_device_attributes(struct tty *, const char *, size_t,\n\t\t    size_t *);\nstatic int\ttty_keys_device_attributes2(struct tty *, const char *, size_t,\n\t\t    size_t *);\nstatic int\ttty_keys_extended_device_attributes(struct tty *, const char *,\n\t\t    size_t, size_t *);\n\n/* A key tree entry. */\nstruct tty_key {\n\tchar\t\t ch;\n\tkey_code\t key;\n\n\tstruct tty_key\t*left;\n\tstruct tty_key\t*right;\n\n\tstruct tty_key\t*next;\n};\n\n/* Default raw keys. */\nstruct tty_default_key_raw {\n\tconst char\t       *string;\n\tkey_code\t\tkey;\n};\nstatic const struct tty_default_key_raw tty_default_raw_keys[] = {\n\t/* Application escape. */\n\t{ \"\\033O[\", '\\033' },\n\n\t/*\n\t * Numeric keypad. Just use the vt100 escape sequences here and always\n\t * put the terminal into keypad_xmit mode. Translation of numbers\n\t * mode/applications mode is done in input-keys.c.\n\t */\n\t{ \"\\033Oo\", KEYC_KP_SLASH|KEYC_KEYPAD },\n\t{ \"\\033Oj\", KEYC_KP_STAR|KEYC_KEYPAD },\n\t{ \"\\033Om\", KEYC_KP_MINUS|KEYC_KEYPAD },\n\t{ \"\\033Ow\", KEYC_KP_SEVEN|KEYC_KEYPAD },\n\t{ \"\\033Ox\", KEYC_KP_EIGHT|KEYC_KEYPAD },\n\t{ \"\\033Oy\", KEYC_KP_NINE|KEYC_KEYPAD },\n\t{ \"\\033Ok\", KEYC_KP_PLUS|KEYC_KEYPAD },\n\t{ \"\\033Ot\", KEYC_KP_FOUR|KEYC_KEYPAD },\n\t{ \"\\033Ou\", KEYC_KP_FIVE|KEYC_KEYPAD },\n\t{ \"\\033Ov\", KEYC_KP_SIX|KEYC_KEYPAD },\n\t{ \"\\033Oq\", KEYC_KP_ONE|KEYC_KEYPAD },\n\t{ \"\\033Or\", KEYC_KP_TWO|KEYC_KEYPAD },\n\t{ \"\\033Os\", KEYC_KP_THREE|KEYC_KEYPAD },\n\t{ \"\\033OM\", KEYC_KP_ENTER|KEYC_KEYPAD },\n\t{ \"\\033Op\", KEYC_KP_ZERO|KEYC_KEYPAD },\n\t{ \"\\033On\", KEYC_KP_PERIOD|KEYC_KEYPAD },\n\n\t/* Arrow keys. */\n\t{ \"\\033OA\", KEYC_UP|KEYC_CURSOR },\n\t{ \"\\033OB\", KEYC_DOWN|KEYC_CURSOR },\n\t{ \"\\033OC\", KEYC_RIGHT|KEYC_CURSOR },\n\t{ \"\\033OD\", KEYC_LEFT|KEYC_CURSOR },\n\n\t{ \"\\033[A\", KEYC_UP|KEYC_CURSOR },\n\t{ \"\\033[B\", KEYC_DOWN|KEYC_CURSOR },\n\t{ \"\\033[C\", KEYC_RIGHT|KEYC_CURSOR },\n\t{ \"\\033[D\", KEYC_LEFT|KEYC_CURSOR },\n\n\t/*\n\t * Meta arrow keys. These do not get the IMPLIED_META flag so they\n\t * don't match the xterm-style meta keys in the output tree - Escape+Up\n\t * should stay as Escape+Up and not become M-Up.\n\t */\n\t{ \"\\033\\033OA\", KEYC_UP|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033OB\", KEYC_DOWN|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033OC\", KEYC_RIGHT|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033OD\", KEYC_LEFT|KEYC_CURSOR|KEYC_META },\n\n\t{ \"\\033\\033[A\", KEYC_UP|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033[B\", KEYC_DOWN|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033[C\", KEYC_RIGHT|KEYC_CURSOR|KEYC_META },\n\t{ \"\\033\\033[D\", KEYC_LEFT|KEYC_CURSOR|KEYC_META },\n\n\t/* Other xterm keys. */\n\t{ \"\\033OH\", KEYC_HOME },\n\t{ \"\\033OF\", KEYC_END },\n\n\t{ \"\\033\\033OH\", KEYC_HOME|KEYC_META|KEYC_IMPLIED_META },\n\t{ \"\\033\\033OF\", KEYC_END|KEYC_META|KEYC_IMPLIED_META },\n\n\t{ \"\\033[H\", KEYC_HOME },\n\t{ \"\\033[F\", KEYC_END },\n\n\t{ \"\\033\\033[H\", KEYC_HOME|KEYC_META|KEYC_IMPLIED_META },\n\t{ \"\\033\\033[F\", KEYC_END|KEYC_META|KEYC_IMPLIED_META },\n\n\t/* rxvt arrow keys. */\n\t{ \"\\033Oa\", KEYC_UP|KEYC_CTRL },\n\t{ \"\\033Ob\", KEYC_DOWN|KEYC_CTRL },\n\t{ \"\\033Oc\", KEYC_RIGHT|KEYC_CTRL },\n\t{ \"\\033Od\", KEYC_LEFT|KEYC_CTRL },\n\n\t{ \"\\033[a\", KEYC_UP|KEYC_SHIFT },\n\t{ \"\\033[b\", KEYC_DOWN|KEYC_SHIFT },\n\t{ \"\\033[c\", KEYC_RIGHT|KEYC_SHIFT },\n\t{ \"\\033[d\", KEYC_LEFT|KEYC_SHIFT },\n\n\t/* rxvt function keys. */\n\t{ \"\\033[11~\", KEYC_F1 },\n\t{ \"\\033[12~\", KEYC_F2 },\n\t{ \"\\033[13~\", KEYC_F3 },\n\t{ \"\\033[14~\", KEYC_F4 },\n\t{ \"\\033[15~\", KEYC_F5 },\n\t{ \"\\033[17~\", KEYC_F6 },\n\t{ \"\\033[18~\", KEYC_F7 },\n\t{ \"\\033[19~\", KEYC_F8 },\n\t{ \"\\033[20~\", KEYC_F9 },\n\t{ \"\\033[21~\", KEYC_F10 },\n\n\t{ \"\\033[23~\", KEYC_F1|KEYC_SHIFT },\n\t{ \"\\033[24~\", KEYC_F2|KEYC_SHIFT },\n\t{ \"\\033[25~\", KEYC_F3|KEYC_SHIFT },\n\t{ \"\\033[26~\", KEYC_F4|KEYC_SHIFT },\n\t{ \"\\033[28~\", KEYC_F5|KEYC_SHIFT },\n\t{ \"\\033[29~\", KEYC_F6|KEYC_SHIFT },\n\t{ \"\\033[31~\", KEYC_F7|KEYC_SHIFT },\n\t{ \"\\033[32~\", KEYC_F8|KEYC_SHIFT },\n\t{ \"\\033[33~\", KEYC_F9|KEYC_SHIFT },\n\t{ \"\\033[34~\", KEYC_F10|KEYC_SHIFT },\n\t{ \"\\033[23$\", KEYC_F11|KEYC_SHIFT },\n\t{ \"\\033[24$\", KEYC_F12|KEYC_SHIFT },\n\n\t{ \"\\033[11^\", KEYC_F1|KEYC_CTRL },\n\t{ \"\\033[12^\", KEYC_F2|KEYC_CTRL },\n\t{ \"\\033[13^\", KEYC_F3|KEYC_CTRL },\n\t{ \"\\033[14^\", KEYC_F4|KEYC_CTRL },\n\t{ \"\\033[15^\", KEYC_F5|KEYC_CTRL },\n\t{ \"\\033[17^\", KEYC_F6|KEYC_CTRL },\n\t{ \"\\033[18^\", KEYC_F7|KEYC_CTRL },\n\t{ \"\\033[19^\", KEYC_F8|KEYC_CTRL },\n\t{ \"\\033[20^\", KEYC_F9|KEYC_CTRL },\n\t{ \"\\033[21^\", KEYC_F10|KEYC_CTRL },\n\t{ \"\\033[23^\", KEYC_F11|KEYC_CTRL },\n\t{ \"\\033[24^\", KEYC_F12|KEYC_CTRL },\n\n\t{ \"\\033[11@\", KEYC_F1|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[12@\", KEYC_F2|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[13@\", KEYC_F3|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[14@\", KEYC_F4|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[15@\", KEYC_F5|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[17@\", KEYC_F6|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[18@\", KEYC_F7|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[19@\", KEYC_F8|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[20@\", KEYC_F9|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[21@\", KEYC_F10|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[23@\", KEYC_F11|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[24@\", KEYC_F12|KEYC_CTRL|KEYC_SHIFT },\n\n\t/* Focus tracking. */\n\t{ \"\\033[I\", KEYC_FOCUS_IN },\n\t{ \"\\033[O\", KEYC_FOCUS_OUT },\n\n\t/* Paste keys. */\n\t{ \"\\033[200~\", KEYC_PASTE_START },\n\t{ \"\\033[201~\", KEYC_PASTE_END },\n\n\t/* Extended keys. */\n\t{ \"\\033[1;5Z\", '\\011'|KEYC_CTRL|KEYC_SHIFT },\n};\n\n/* Default xterm keys. */\nstruct tty_default_key_xterm {\n\tconst char\t*template;\n\tkey_code\t key;\n};\nstatic const struct tty_default_key_xterm tty_default_xterm_keys[] = {\n\t{ \"\\033[1;_P\", KEYC_F1 },\n\t{ \"\\033O1;_P\", KEYC_F1 },\n\t{ \"\\033O_P\", KEYC_F1 },\n\t{ \"\\033[1;_Q\", KEYC_F2 },\n\t{ \"\\033O1;_Q\", KEYC_F2 },\n\t{ \"\\033O_Q\", KEYC_F2 },\n\t{ \"\\033[1;_R\", KEYC_F3 },\n\t{ \"\\033O1;_R\", KEYC_F3 },\n\t{ \"\\033O_R\", KEYC_F3 },\n\t{ \"\\033[1;_S\", KEYC_F4 },\n\t{ \"\\033O1;_S\", KEYC_F4 },\n\t{ \"\\033O_S\", KEYC_F4 },\n\t{ \"\\033[15;_~\", KEYC_F5 },\n\t{ \"\\033[17;_~\", KEYC_F6 },\n\t{ \"\\033[18;_~\", KEYC_F7 },\n\t{ \"\\033[19;_~\", KEYC_F8 },\n\t{ \"\\033[20;_~\", KEYC_F9 },\n\t{ \"\\033[21;_~\", KEYC_F10 },\n\t{ \"\\033[23;_~\", KEYC_F11 },\n\t{ \"\\033[24;_~\", KEYC_F12 },\n\t{ \"\\033[1;_A\", KEYC_UP },\n\t{ \"\\033[1;_B\", KEYC_DOWN },\n\t{ \"\\033[1;_C\", KEYC_RIGHT },\n\t{ \"\\033[1;_D\", KEYC_LEFT },\n\t{ \"\\033[1;_H\", KEYC_HOME },\n\t{ \"\\033[1;_F\", KEYC_END },\n\t{ \"\\033[5;_~\", KEYC_PPAGE },\n\t{ \"\\033[6;_~\", KEYC_NPAGE },\n\t{ \"\\033[2;_~\", KEYC_IC },\n\t{ \"\\033[3;_~\", KEYC_DC },\n};\nstatic const key_code tty_default_xterm_modifiers[] = {\n\t0,\n\t0,\n\tKEYC_SHIFT,\n\tKEYC_META|KEYC_IMPLIED_META,\n\tKEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META,\n\tKEYC_CTRL,\n\tKEYC_SHIFT|KEYC_CTRL,\n\tKEYC_META|KEYC_IMPLIED_META|KEYC_CTRL,\n\tKEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL,\n\tKEYC_META|KEYC_IMPLIED_META\n};\n\n/*\n * Default terminfo(5) keys. Any keys that have builtin modifiers (that is,\n * where the key itself contains the modifiers) has the KEYC_XTERM flag set so\n * a leading escape is not treated as meta (and probably removed).\n */\nstruct tty_default_key_code {\n\tenum tty_code_code\tcode;\n\tkey_code\t\tkey;\n};\nstatic const struct tty_default_key_code tty_default_code_keys[] = {\n\t/* Function keys. */\n\t{ TTYC_KF1, KEYC_F1 },\n\t{ TTYC_KF2, KEYC_F2 },\n\t{ TTYC_KF3, KEYC_F3 },\n\t{ TTYC_KF4, KEYC_F4 },\n\t{ TTYC_KF5, KEYC_F5 },\n\t{ TTYC_KF6, KEYC_F6 },\n\t{ TTYC_KF7, KEYC_F7 },\n\t{ TTYC_KF8, KEYC_F8 },\n\t{ TTYC_KF9, KEYC_F9 },\n\t{ TTYC_KF10, KEYC_F10 },\n\t{ TTYC_KF11, KEYC_F11 },\n\t{ TTYC_KF12, KEYC_F12 },\n\n\t{ TTYC_KF13, KEYC_F1|KEYC_SHIFT },\n\t{ TTYC_KF14, KEYC_F2|KEYC_SHIFT },\n\t{ TTYC_KF15, KEYC_F3|KEYC_SHIFT },\n\t{ TTYC_KF16, KEYC_F4|KEYC_SHIFT },\n\t{ TTYC_KF17, KEYC_F5|KEYC_SHIFT },\n\t{ TTYC_KF18, KEYC_F6|KEYC_SHIFT },\n\t{ TTYC_KF19, KEYC_F7|KEYC_SHIFT },\n\t{ TTYC_KF20, KEYC_F8|KEYC_SHIFT },\n\t{ TTYC_KF21, KEYC_F9|KEYC_SHIFT },\n\t{ TTYC_KF22, KEYC_F10|KEYC_SHIFT },\n\t{ TTYC_KF23, KEYC_F11|KEYC_SHIFT },\n\t{ TTYC_KF24, KEYC_F12|KEYC_SHIFT },\n\n\t{ TTYC_KF25, KEYC_F1|KEYC_CTRL },\n\t{ TTYC_KF26, KEYC_F2|KEYC_CTRL },\n\t{ TTYC_KF27, KEYC_F3|KEYC_CTRL },\n\t{ TTYC_KF28, KEYC_F4|KEYC_CTRL },\n\t{ TTYC_KF29, KEYC_F5|KEYC_CTRL },\n\t{ TTYC_KF30, KEYC_F6|KEYC_CTRL },\n\t{ TTYC_KF31, KEYC_F7|KEYC_CTRL },\n\t{ TTYC_KF32, KEYC_F8|KEYC_CTRL },\n\t{ TTYC_KF33, KEYC_F9|KEYC_CTRL },\n\t{ TTYC_KF34, KEYC_F10|KEYC_CTRL },\n\t{ TTYC_KF35, KEYC_F11|KEYC_CTRL },\n\t{ TTYC_KF36, KEYC_F12|KEYC_CTRL },\n\n\t{ TTYC_KF37, KEYC_F1|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF38, KEYC_F2|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF39, KEYC_F3|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF40, KEYC_F4|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF41, KEYC_F5|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF42, KEYC_F6|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF43, KEYC_F7|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF44, KEYC_F8|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF45, KEYC_F9|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF46, KEYC_F10|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF47, KEYC_F11|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF48, KEYC_F12|KEYC_SHIFT|KEYC_CTRL },\n\n\t{ TTYC_KF49, KEYC_F1|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF50, KEYC_F2|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF51, KEYC_F3|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF52, KEYC_F4|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF53, KEYC_F5|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF54, KEYC_F6|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF55, KEYC_F7|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF56, KEYC_F8|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF57, KEYC_F9|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF58, KEYC_F10|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF59, KEYC_F11|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KF60, KEYC_F12|KEYC_META|KEYC_IMPLIED_META },\n\n\t{ TTYC_KF61, KEYC_F1|KEYC_META|KEYC_IMPLIED_META|KEYC_SHIFT },\n\t{ TTYC_KF62, KEYC_F2|KEYC_META|KEYC_IMPLIED_META|KEYC_SHIFT },\n\t{ TTYC_KF63, KEYC_F3|KEYC_META|KEYC_IMPLIED_META|KEYC_SHIFT },\n\n\t{ TTYC_KICH1, KEYC_IC },\n\t{ TTYC_KDCH1, KEYC_DC },\n\t{ TTYC_KHOME, KEYC_HOME },\n\t{ TTYC_KEND, KEYC_END },\n\t{ TTYC_KNP, KEYC_NPAGE },\n\t{ TTYC_KPP, KEYC_PPAGE },\n\t{ TTYC_KCBT, KEYC_BTAB },\n\n\t/* Arrow keys from terminfo. */\n\t{ TTYC_KCUU1, KEYC_UP|KEYC_CURSOR },\n\t{ TTYC_KCUD1, KEYC_DOWN|KEYC_CURSOR },\n\t{ TTYC_KCUB1, KEYC_LEFT|KEYC_CURSOR },\n\t{ TTYC_KCUF1, KEYC_RIGHT|KEYC_CURSOR },\n\n\t/* Key and modifier capabilities. */\n\t{ TTYC_KDC2, KEYC_DC|KEYC_SHIFT },\n\t{ TTYC_KDC3, KEYC_DC|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KDC4, KEYC_DC|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KDC5, KEYC_DC|KEYC_CTRL },\n\t{ TTYC_KDC6, KEYC_DC|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KDC7, KEYC_DC|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KIND, KEYC_DOWN|KEYC_SHIFT },\n\t{ TTYC_KDN2, KEYC_DOWN|KEYC_SHIFT },\n\t{ TTYC_KDN3, KEYC_DOWN|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KDN4, KEYC_DOWN|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KDN5, KEYC_DOWN|KEYC_CTRL },\n\t{ TTYC_KDN6, KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KDN7, KEYC_DOWN|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KEND2, KEYC_END|KEYC_SHIFT },\n\t{ TTYC_KEND3, KEYC_END|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KEND4, KEYC_END|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KEND5, KEYC_END|KEYC_CTRL },\n\t{ TTYC_KEND6, KEYC_END|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KEND7, KEYC_END|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KHOM2, KEYC_HOME|KEYC_SHIFT },\n\t{ TTYC_KHOM3, KEYC_HOME|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KHOM4, KEYC_HOME|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KHOM5, KEYC_HOME|KEYC_CTRL },\n\t{ TTYC_KHOM6, KEYC_HOME|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KHOM7, KEYC_HOME|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KIC2, KEYC_IC|KEYC_SHIFT },\n\t{ TTYC_KIC3, KEYC_IC|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KIC4, KEYC_IC|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KIC5, KEYC_IC|KEYC_CTRL },\n\t{ TTYC_KIC6, KEYC_IC|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KIC7, KEYC_IC|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KLFT2, KEYC_LEFT|KEYC_SHIFT },\n\t{ TTYC_KLFT3, KEYC_LEFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KLFT4, KEYC_LEFT|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KLFT5, KEYC_LEFT|KEYC_CTRL },\n\t{ TTYC_KLFT6, KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KLFT7, KEYC_LEFT|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KNXT2, KEYC_NPAGE|KEYC_SHIFT },\n\t{ TTYC_KNXT3, KEYC_NPAGE|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KNXT4, KEYC_NPAGE|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KNXT5, KEYC_NPAGE|KEYC_CTRL },\n\t{ TTYC_KNXT6, KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KNXT7, KEYC_NPAGE|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KPRV2, KEYC_PPAGE|KEYC_SHIFT },\n\t{ TTYC_KPRV3, KEYC_PPAGE|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KPRV4, KEYC_PPAGE|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KPRV5, KEYC_PPAGE|KEYC_CTRL },\n\t{ TTYC_KPRV6, KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KPRV7, KEYC_PPAGE|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KRIT2, KEYC_RIGHT|KEYC_SHIFT },\n\t{ TTYC_KRIT3, KEYC_RIGHT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KRIT4, KEYC_RIGHT|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KRIT5, KEYC_RIGHT|KEYC_CTRL },\n\t{ TTYC_KRIT6, KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KRIT7, KEYC_RIGHT|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n\t{ TTYC_KRI, KEYC_UP|KEYC_SHIFT },\n\t{ TTYC_KUP2, KEYC_UP|KEYC_SHIFT },\n\t{ TTYC_KUP3, KEYC_UP|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KUP4, KEYC_UP|KEYC_SHIFT|KEYC_META|KEYC_IMPLIED_META },\n\t{ TTYC_KUP5, KEYC_UP|KEYC_CTRL },\n\t{ TTYC_KUP6, KEYC_UP|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KUP7, KEYC_UP|KEYC_META|KEYC_IMPLIED_META|KEYC_CTRL },\n};\n\n/* Add key to tree. */\nstatic void\ntty_keys_add(struct tty *tty, const char *s, key_code key)\n{\n\tstruct tty_key\t*tk;\n\tsize_t\t\t size;\n\tconst char\t*keystr;\n\n\tkeystr = key_string_lookup_key(key, 1);\n\tif ((tk = tty_keys_find(tty, s, strlen(s), &size)) == NULL) {\n\t\tlog_debug(\"new key %s: 0x%llx (%s)\", s, key, keystr);\n\t\ttty_keys_add1(&tty->key_tree, s, key);\n\t} else {\n\t\tlog_debug(\"replacing key %s: 0x%llx (%s)\", s, key, keystr);\n\t\ttk->key = key;\n\t}\n}\n\n/* Add next node to the tree. */\nstatic void\ntty_keys_add1(struct tty_key **tkp, const char *s, key_code key)\n{\n\tstruct tty_key\t*tk;\n\n\t/* Allocate a tree entry if there isn't one already. */\n\ttk = *tkp;\n\tif (tk == NULL) {\n\t\ttk = *tkp = xcalloc(1, sizeof *tk);\n\t\ttk->ch = *s;\n\t\ttk->key = KEYC_UNKNOWN;\n\t}\n\n\t/* Find the next entry. */\n\tif (*s == tk->ch) {\n\t\t/* Move forward in string. */\n\t\ts++;\n\n\t\t/* If this is the end of the string, no more is necessary. */\n\t\tif (*s == '\\0') {\n\t\t\ttk->key = key;\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use the child tree for the next character. */\n\t\ttkp = &tk->next;\n\t} else {\n\t\tif (*s < tk->ch)\n\t\t\ttkp = &tk->left;\n\t\telse if (*s > tk->ch)\n\t\t\ttkp = &tk->right;\n\t}\n\n\t/* And recurse to add it. */\n\ttty_keys_add1(tkp, s, key);\n}\n\n/* Initialise a key tree from the table. */\nvoid\ntty_keys_build(struct tty *tty)\n{\n\tconst struct tty_default_key_raw\t*tdkr;\n\tconst struct tty_default_key_xterm\t*tdkx;\n\tconst struct tty_default_key_code\t*tdkc;\n\tu_int\t\t\t\t\t i, j;\n\tconst char\t\t\t\t*s;\n\tstruct options_entry\t\t\t*o;\n\tstruct options_array_item\t\t*a;\n\tunion options_value\t\t\t*ov;\n\tchar\t\t\t\t\t copy[16];\n\tkey_code\t\t\t\t key;\n\n\tif (tty->key_tree != NULL)\n\t\ttty_keys_free(tty);\n\ttty->key_tree = NULL;\n\n\tfor (i = 0; i < nitems(tty_default_xterm_keys); i++) {\n\t\ttdkx = &tty_default_xterm_keys[i];\n\t\tfor (j = 2; j < nitems(tty_default_xterm_modifiers); j++) {\n\t\t\tstrlcpy(copy, tdkx->template, sizeof copy);\n\t\t\tcopy[strcspn(copy, \"_\")] = '0' + j;\n\n\t\t\tkey = tdkx->key|tty_default_xterm_modifiers[j];\n\t\t\ttty_keys_add(tty, copy, key);\n\t\t}\n\t}\n\tfor (i = 0; i < nitems(tty_default_raw_keys); i++) {\n\t\ttdkr = &tty_default_raw_keys[i];\n\n\t\ts = tdkr->string;\n\t\tif (*s != '\\0')\n\t\t\ttty_keys_add(tty, s, tdkr->key);\n\t}\n\tfor (i = 0; i < nitems(tty_default_code_keys); i++) {\n\t\ttdkc = &tty_default_code_keys[i];\n\n\t\ts = tty_term_string(tty->term, tdkc->code);\n\t\tif (*s != '\\0')\n\t\t\ttty_keys_add(tty, s, tdkc->key);\n\n\t}\n\n\to = options_get(global_options, \"user-keys\");\n\tif (o != NULL) {\n\t\ta = options_array_first(o);\n\t\twhile (a != NULL) {\n\t\t\ti = options_array_item_index(a);\n\t\t\tov = options_array_item_value(a);\n\t\t\ttty_keys_add(tty, ov->string, KEYC_USER + i);\n\t\t\ta = options_array_next(a);\n\t\t}\n\t}\n}\n\n/* Free the entire key tree. */\nvoid\ntty_keys_free(struct tty *tty)\n{\n\ttty_keys_free1(tty->key_tree);\n}\n\n/* Free a single key. */\nstatic void\ntty_keys_free1(struct tty_key *tk)\n{\n\tif (tk->next != NULL)\n\t\ttty_keys_free1(tk->next);\n\tif (tk->left != NULL)\n\t\ttty_keys_free1(tk->left);\n\tif (tk->right != NULL)\n\t\ttty_keys_free1(tk->right);\n\tfree(tk);\n}\n\n/* Lookup a key in the tree. */\nstatic struct tty_key *\ntty_keys_find(struct tty *tty, const char *buf, size_t len, size_t *size)\n{\n\t*size = 0;\n\treturn (tty_keys_find1(tty->key_tree, buf, len, size));\n}\n\n/* Find the next node. */\nstatic struct tty_key *\ntty_keys_find1(struct tty_key *tk, const char *buf, size_t len, size_t *size)\n{\n\t/* If no data, no match. */\n\tif (len == 0)\n\t\treturn (NULL);\n\n\t/* If the node is NULL, this is the end of the tree. No match. */\n\tif (tk == NULL)\n\t\treturn (NULL);\n\n\t/* Pick the next in the sequence. */\n\tif (tk->ch == *buf) {\n\t\t/* Move forward in the string. */\n\t\tbuf++; len--;\n\t\t(*size)++;\n\n\t\t/* At the end of the string, return the current node. */\n\t\tif (len == 0 || (tk->next == NULL && tk->key != KEYC_UNKNOWN))\n\t\t\treturn (tk);\n\n\t\t/* Move into the next tree for the following character. */\n\t\ttk = tk->next;\n\t} else {\n\t\tif (*buf < tk->ch)\n\t\t\ttk = tk->left;\n\t\telse if (*buf > tk->ch)\n\t\t\ttk = tk->right;\n\t}\n\n\t/* Move to the next in the tree. */\n\treturn (tty_keys_find1(tk, buf, len, size));\n}\n\n/* Look up part of the next key. */\nstatic int\ntty_keys_next1(struct tty *tty, const char *buf, size_t len, key_code *key,\n    size_t *size, int expired)\n{\n\tstruct client\t\t*c = tty->client;\n\tstruct tty_key\t\t*tk, *tk1;\n\tstruct utf8_data\t ud;\n\tenum utf8_state\t\t more;\n\tutf8_char\t\t uc;\n\tu_int\t\t\t i;\n\n\tlog_debug(\"%s: next key is %zu (%.*s) (expired=%d)\", c->name, len,\n\t    (int)len, buf, expired);\n\n\t/* Is this a known key? */\n\ttk = tty_keys_find(tty, buf, len, size);\n\tif (tk != NULL && tk->key != KEYC_UNKNOWN) {\n\t\ttk1 = tk;\n\t\tdo\n\t\t\tlog_debug(\"%s: keys in list: %#llx\", c->name, tk1->key);\n\t\twhile ((tk1 = tk1->next) != NULL);\n\t\tif (tk->next != NULL && !expired)\n\t\t\treturn (1);\n\t\t*key = tk->key;\n\t\treturn (0);\n\t}\n\n\t/* Is this valid UTF-8? */\n\tmore = utf8_open(&ud, (u_char)*buf);\n\tif (more == UTF8_MORE) {\n\t\t*size = ud.size;\n\t\tif (len < ud.size) {\n\t\t\tif (!expired)\n\t\t\t\treturn (1);\n\t\t\treturn (-1);\n\t\t}\n\t\tfor (i = 1; i < ud.size; i++)\n\t\t\tmore = utf8_append(&ud, (u_char)buf[i]);\n\t\tif (more != UTF8_DONE)\n\t\t\treturn (-1);\n\n\t\tif (utf8_from_data(&ud, &uc) != UTF8_DONE)\n\t\t\treturn (-1);\n\t\t*key = uc;\n\n\t\tlog_debug(\"%s: UTF-8 key %.*s %#llx\", c->name, (int)ud.size,\n\t\t    ud.data, *key);\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/* Process window size change escape sequences. */\nstatic int\ntty_keys_winsz(struct tty *tty, const char *buf, size_t len, size_t *size)\n{\n\tstruct client\t*c = tty->client;\n\tsize_t\t\t end;\n\tchar\t\t tmp[64];\n\tu_int\t\t sx, sy, xpixel, ypixel, char_x, char_y;\n\n\t*size = 0;\n\n\t/* If we did not request this, ignore it. */\n\tif (!(tty->flags & TTY_WINSIZEQUERY))\n\t\treturn (-1);\n\n\t/* First two bytes are always \\033[. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\n\t/*\n\t * Stop at either 't' or anything that isn't a\n\t * number or ';'.\n\t */\n\tfor (end = 2; end < len && end != sizeof tmp; end++) {\n\t\tif (buf[end] == 't')\n\t\t\tbreak;\n\t\tif (!isdigit((u_char)buf[end]) && buf[end] != ';')\n\t\t\tbreak;\n\t}\n\tif (end == len)\n\t\treturn (1);\n\tif (end == sizeof tmp || buf[end] != 't')\n\t\treturn (-1);\n\n\t/* Copy to the buffer. */\n\tmemcpy(tmp, buf + 2, end - 2);\n\ttmp[end - 2] = '\\0';\n\n\t/* Try to parse the window size sequence. */\n\tif (sscanf(tmp, \"8;%u;%u\", &sy, &sx) == 2) {\n\t\t/* Window size in characters. */\n\t\ttty_set_size(tty, sx, sy, tty->xpixel, tty->ypixel);\n\n\t\t*size = end + 1;\n\t\treturn (0);\n\t} else if (sscanf(tmp, \"4;%u;%u\", &ypixel, &xpixel) == 2) {\n\t\t/* Window size in pixels. */\n\t\tchar_x = (xpixel && tty->sx) ? xpixel / tty->sx : 0;\n\t\tchar_y = (ypixel && tty->sy) ? ypixel / tty->sy : 0;\n\t\ttty_set_size(tty, tty->sx, tty->sy, char_x, char_y);\n\t\ttty_invalidate(tty);\n\n\t\ttty->flags &= ~TTY_WINSIZEQUERY;\n\t\t*size = end + 1;\n\t\treturn (0);\n\t}\n\n\tlog_debug(\"%s: unrecognized window size sequence: %s\", c->name, tmp);\n\treturn (-1);\n}\n\n\n/* Process at least one key in the buffer. Return 0 if no keys present. */\nint\ntty_keys_next(struct tty *tty)\n{\n\tstruct client\t\t*c = tty->client;\n\tstruct timeval\t\t tv;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len, size;\n\tcc_t\t\t\t bspace;\n\tint\t\t\t delay, expired = 0, n;\n\tkey_code\t\t key, onlykey;\n\tstruct mouse_event\t m = { 0 };\n\tstruct key_event\t*event;\n\n\t/* Get key buffer. */\n\tbuf = EVBUFFER_DATA(tty->in);\n\tlen = EVBUFFER_LENGTH(tty->in);\n\tif (len == 0)\n\t\treturn (0);\n\tlog_debug(\"%s: keys are %zu (%.*s)\", c->name, len, (int)len, buf);\n\n\t/* Is this a clipboard response? */\n\tswitch (tty_keys_clipboard(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this a primary device attributes response? */\n\tswitch (tty_keys_device_attributes(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this a secondary device attributes response? */\n\tswitch (tty_keys_device_attributes2(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this an extended device attributes response? */\n\tswitch (tty_keys_extended_device_attributes(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this a colours response? */\n\tswitch (tty_keys_colours(tty, buf, len, &size, &tty->fg, &tty->bg)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this a mouse key press? */\n\tswitch (tty_keys_mouse(tty, buf, len, &size, &m)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_MOUSE;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase -2:\t/* yes, but we don't care. */\n\t\tkey = KEYC_MOUSE;\n\t\tgoto discard_key;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Is this an extended key press? */\n\tswitch (tty_keys_extended_key(tty, buf, len, &size, &key)) {\n\tcase 0:\t\t/* yes */\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Check for window size query */\n\tswitch (tty_keys_winsz(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_UNKNOWN;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\nfirst_key:\n\t/* Try to lookup complete key. */\n\tn = tty_keys_next1(tty, buf, len, &key, &size, expired);\n\tif (n == 0)\t/* found */\n\t\tgoto complete_key;\n\tif (n == 1)\n\t\tgoto partial_key;\n\n\t/*\n\t * If not a complete key, look for key with an escape prefix (meta\n\t * modifier).\n\t */\n\tif (*buf == '\\033' && len > 1) {\n\t\t/* Look for a key without the escape. */\n\t\tn = tty_keys_next1(tty, buf + 1, len - 1, &key, &size, expired);\n\t\tif (n == 0) {\t/* found */\n\t\t\tif (key & KEYC_IMPLIED_META) {\n\t\t\t\t/*\n\t\t\t\t * We want the escape key as well as the xterm\n\t\t\t\t * key, because the xterm sequence implicitly\n\t\t\t\t * includes the escape (so if we see\n\t\t\t\t * \\033\\033[1;3D we know it is an Escape\n\t\t\t\t * followed by M-Left, not just M-Left).\n\t\t\t\t */\n\t\t\t\tkey = '\\033';\n\t\t\t\tsize = 1;\n\t\t\t\tgoto complete_key;\n\t\t\t}\n\t\t\tkey |= KEYC_META;\n\t\t\tsize++;\n\t\t\tgoto complete_key;\n\t\t}\n\t\tif (n == 1)\t/* partial */\n\t\t\tgoto partial_key;\n\t}\n\n\t/*\n\t * At this point, we know the key is not partial (with or without\n\t * escape). So pass it through even if the timer has not expired.\n\t */\n\tif (*buf == '\\033' && len >= 2) {\n\t\tkey = (u_char)buf[1] | KEYC_META;\n\t\tsize = 2;\n\t} else {\n\t\tkey = (u_char)buf[0];\n\t\tsize = 1;\n\t}\n\n\t/* C-Space is special. */\n\tif ((key & KEYC_MASK_KEY) == C0_NUL)\n\t\tkey = ' ' | KEYC_CTRL | (key & KEYC_META);\n\n\t/*\n\t * Check for backspace key using termios VERASE - the terminfo\n\t * kbs entry is extremely unreliable, so cannot be safely\n\t * used. termios should have a better idea.\n\t */\n\tbspace = tty->tio.c_cc[VERASE];\n\tif (bspace != _POSIX_VDISABLE && key == bspace) {\n\t\tlog_debug(\"%s: key %#llx is backspace\", c->name, key);\n\t\tkey = KEYC_BSPACE;\n\t}\n\n\t/*\n\t * Fix up all C0 control codes that don't have a dedicated key into\n\t * corresponding Ctrl keys. Convert characters in the A-Z range into\n\t * lowercase, so ^A becomes a|CTRL.\n\t */\n\tonlykey = key & KEYC_MASK_KEY;\n\tif (onlykey < 0x20 &&\n\t    onlykey != C0_HT &&\n\t    onlykey != C0_CR &&\n\t    onlykey != C0_ESC) {\n\t\tonlykey |= 0x40;\n\t\tif (onlykey >= 'A' && onlykey <= 'Z')\n\t\t\tonlykey |= 0x20;\n\t\tkey = onlykey | KEYC_CTRL | (key & KEYC_META);\n\t}\n\n\tgoto complete_key;\n\npartial_key:\n\tlog_debug(\"%s: partial key %.*s\", c->name, (int)len, buf);\n\n\t/* If timer is going, check for expiration. */\n\tif (tty->flags & TTY_TIMER) {\n\t\tif (evtimer_initialized(&tty->key_timer) &&\n\t\t    !evtimer_pending(&tty->key_timer, NULL)) {\n\t\t\texpired = 1;\n\t\t\tgoto first_key;\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/* Get the time period. */\n\tdelay = options_get_number(global_options, \"escape-time\");\n\tif (delay == 0)\n\t\tdelay = 1;\n\ttv.tv_sec = delay / 1000;\n\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\t/* Start the timer. */\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\tevtimer_set(&tty->key_timer, tty_keys_callback, tty);\n\tevtimer_add(&tty->key_timer, &tv);\n\n\ttty->flags |= TTY_TIMER;\n\treturn (0);\n\ncomplete_key:\n\tlog_debug(\"%s: complete key %.*s %#llx\", c->name, (int)size, buf, key);\n\n\t/* Remove key timer. */\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\ttty->flags &= ~TTY_TIMER;\n\n\t/* Check for focus events. */\n\tif (key == KEYC_FOCUS_OUT) {\n\t\tc->flags &= ~CLIENT_FOCUSED;\n\t\twindow_update_focus(c->session->curw->window);\n\t\tnotify_client(\"client-focus-out\", c);\n\t} else if (key == KEYC_FOCUS_IN) {\n\t\tc->flags |= CLIENT_FOCUSED;\n\t\tnotify_client(\"client-focus-in\", c);\n\t\twindow_update_focus(c->session->curw->window);\n\t}\n\n\t/* Fire the key. */\n\tif (key != KEYC_UNKNOWN) {\n\t\tevent = xcalloc(1, sizeof *event);\n\t\tevent->key = key;\n\t\tmemcpy(&event->m, &m, sizeof event->m);\n\n\t\tevent->buf = xmalloc(size);\n\t\tevent->len = size;\n\t\tmemcpy (event->buf, buf, event->len);\n\n\t\tif (!server_client_handle_key(c, event)) {\n\t\t\tfree(event->buf);\n\t\t\tfree(event);\n\t\t}\n\t}\n\n\t/* Remove data from buffer. */\n\tevbuffer_drain(tty->in, size);\n\n\treturn (1);\n\ndiscard_key:\n\tlog_debug(\"%s: discard key %.*s %#llx\", c->name, (int)size, buf, key);\n\n\t/* Remove data from buffer. */\n\tevbuffer_drain(tty->in, size);\n\n\treturn (1);\n}\n\n/* Key timer callback. */\nstatic void\ntty_keys_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\n\tif (tty->flags & TTY_TIMER) {\n\t\twhile (tty_keys_next(tty))\n\t\t\t;\n\t}\n}\n\n/*\n * Handle extended key input. This has two forms: \\033[27;m;k~ and \\033[k;mu,\n * where k is key as a number and m is a modifier. Returns 0 for success, -1\n * for failure, 1 for partial;\n */\nstatic int\ntty_keys_extended_key(struct tty *tty, const char *buf, size_t len,\n    size_t *size, key_code *key)\n{\n\tstruct client\t*c = tty->client;\n\tsize_t\t\t end;\n\tu_int\t\t number, modifiers;\n\tchar\t\t tmp[64];\n\tcc_t\t\t bspace;\n\tkey_code\t nkey, onlykey;\n\tstruct utf8_data ud;\n\tutf8_char        uc;\n\n\t*size = 0;\n\n\t/* First two bytes are always \\033[. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\n\t/*\n\t * Look for a terminator. Stop at either '~' or anything that isn't a\n\t * number or ';'.\n\t */\n\tfor (end = 2; end < len && end != sizeof tmp; end++) {\n\t\tif (buf[end] == '~')\n\t\t\tbreak;\n\t\tif (!isdigit((u_char)buf[end]) && buf[end] != ';')\n\t\t\tbreak;\n\t}\n\tif (end == len)\n\t\treturn (1);\n\tif (end == sizeof tmp || (buf[end] != '~' && buf[end] != 'u'))\n\t\treturn (-1);\n\n\t/* Copy to the buffer. */\n\tmemcpy(tmp, buf + 2, end);\n\ttmp[end] = '\\0';\n\n\t/* Try to parse either form of key. */\n\tif (buf[end] == '~') {\n\t\tif (sscanf(tmp, \"27;%u;%u\", &modifiers, &number) != 2)\n\t\t\treturn (-1);\n\t} else {\n\t\tif (sscanf(tmp ,\"%u;%u\", &number, &modifiers) != 2)\n\t\t\treturn (-1);\n\t}\n\t*size = end + 1;\n\n\t/* Store the key. */\n\tbspace = tty->tio.c_cc[VERASE];\n\tif (bspace != _POSIX_VDISABLE && number == bspace)\n\t\tnkey = KEYC_BSPACE;\n\telse\n\t\tnkey = number;\n\n\t/* Convert UTF-32 codepoint into internal representation. */\n\tif (nkey != KEYC_BSPACE && nkey & ~0x7f) {\n\t\tif (utf8_fromwc(nkey, &ud) == UTF8_DONE &&\n\t\t    utf8_from_data(&ud, &uc) == UTF8_DONE)\n\t\t\tnkey = uc;\n\t\telse\n\t\t\treturn (-1);\n\t}\n\n\t/* Update the modifiers. */\n\tif (modifiers > 0) {\n\t\tmodifiers--;\n\t\tif (modifiers & 1)\n\t\t\tnkey |= KEYC_SHIFT;\n\t\tif (modifiers & 2)\n\t\t\tnkey |= (KEYC_META|KEYC_IMPLIED_META); /* Alt */\n\t\tif (modifiers & 4)\n\t\t\tnkey |= KEYC_CTRL;\n\t\tif (modifiers & 8)\n\t\t\tnkey |= (KEYC_META|KEYC_IMPLIED_META); /* Meta */\n\t}\n\n\t/* Convert S-Tab into Backtab. */\n\tif ((nkey & KEYC_MASK_KEY) == '\\011' && (nkey & KEYC_SHIFT))\n\t\tnkey = KEYC_BTAB | (nkey & ~KEYC_MASK_KEY & ~KEYC_SHIFT);\n\n\t/*\n\t * Deal with the Shift modifier when present alone. The problem is that\n\t * in mode 2 some terminals would report shifted keys, like S-a, as\n\t * just A, and some as S-A.\n\t *\n\t * Because we need an unambiguous internal representation, and because\n\t * restoring the Shift modifier when it's missing would require knowing\n\t * the keyboard layout, and because S-A would cause a lot of issues\n\t * downstream, we choose to lose the Shift for all printable\n\t * characters.\n\t *\n\t * That still leaves some ambiguity, such as C-S-A vs. C-A, but that's\n\t * OK, and applications can handle that.\n\t */\n\tonlykey = nkey & KEYC_MASK_KEY;\n\tif (((onlykey > 0x20 && onlykey < 0x7f) ||\n\t    KEYC_IS_UNICODE(nkey)) &&\n\t    (nkey & KEYC_MASK_MODIFIERS) == KEYC_SHIFT)\n\t\tnkey &= ~KEYC_SHIFT;\n\n\tif (log_get_level() != 0) {\n\t\tlog_debug(\"%s: extended key %.*s is %llx (%s)\", c->name,\n\t\t    (int)*size, buf, nkey, key_string_lookup_key(nkey, 1));\n\t}\n\n\t*key = nkey;\n\treturn (0);\n}\n\n/*\n * Handle mouse key input. Returns 0 for success, -1 for failure, 1 for partial\n * (probably a mouse sequence but need more data), -2 if an invalid mouse\n * sequence.\n */\nstatic int\ntty_keys_mouse(struct tty *tty, const char *buf, size_t len, size_t *size,\n    struct mouse_event *m)\n{\n\tstruct client\t*c = tty->client;\n\tu_int\t\t i, x, y, b, sgr_b;\n\tu_char\t\t sgr_type, ch;\n\n\t/*\n\t * Standard mouse sequences are \\033[M followed by three characters\n\t * indicating button, X and Y, all based at 32 with 1,1 top-left.\n\t *\n\t * UTF-8 mouse sequences are similar but the three are expressed as\n\t * UTF-8 characters.\n\t *\n\t * SGR extended mouse sequences are \\033[< followed by three numbers in\n\t * decimal and separated by semicolons indicating button, X and Y. A\n\t * trailing 'M' is click or scroll and trailing 'm' release. All are\n\t * based at 0 with 1,1 top-left.\n\t */\n\n\t*size = 0;\n\tx = y = b = sgr_b = 0;\n\tsgr_type = ' ';\n\n\t/* First two bytes are always \\033[. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\n\t/*\n\t * Third byte is M in old standard (and UTF-8 extension which we do not\n\t * support), < in SGR extension.\n\t */\n\tif (buf[2] == 'M') {\n\t\t/* Read the three inputs. */\n\t\t*size = 3;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tch = (u_char)buf[(*size)++];\n\t\t\tif (i == 0)\n\t\t\t\tb = ch;\n\t\t\telse if (i == 1)\n\t\t\t\tx = ch;\n\t\t\telse\n\t\t\t\ty = ch;\n\t\t}\n\t\tlog_debug(\"%s: mouse input: %.*s\", c->name, (int)*size, buf);\n\n\t\t/* Check and return the mouse input. */\n\t\tif (b < MOUSE_PARAM_BTN_OFF ||\n\t\t    x < MOUSE_PARAM_POS_OFF ||\n\t\t    y < MOUSE_PARAM_POS_OFF)\n\t\t\treturn (-2);\n\t\tb -= MOUSE_PARAM_BTN_OFF;\n\t\tx -= MOUSE_PARAM_POS_OFF;\n\t\ty -= MOUSE_PARAM_POS_OFF;\n\t} else if (buf[2] == '<') {\n\t\t/* Read the three inputs. */\n\t\t*size = 3;\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tch = (u_char)buf[(*size)++];\n\t\t\tif (ch == ';')\n\t\t\t\tbreak;\n\t\t\tif (ch < '0' || ch > '9')\n\t\t\t\treturn (-1);\n\t\t\tsgr_b = 10 * sgr_b + (ch - '0');\n\t\t}\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tch = (u_char)buf[(*size)++];\n\t\t\tif (ch == ';')\n\t\t\t\tbreak;\n\t\t\tif (ch < '0' || ch > '9')\n\t\t\t\treturn (-1);\n\t\t\tx = 10 * x + (ch - '0');\n\t\t}\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tch = (u_char)buf[(*size)++];\n\t\t\tif (ch == 'M' || ch == 'm')\n\t\t\t\tbreak;\n\t\t\tif (ch < '0' || ch > '9')\n\t\t\t\treturn (-1);\n\t\t\ty = 10 * y + (ch - '0');\n\t\t}\n\t\tlog_debug(\"%s: mouse input (SGR): %.*s\", c->name, (int)*size,\n\t\t    buf);\n\n\t\t/* Check and return the mouse input. */\n\t\tif (x < 1 || y < 1)\n\t\t\treturn (-2);\n\t\tx--;\n\t\ty--;\n\t\tb = sgr_b;\n\n\t\t/* Type is M for press, m for release. */\n\t\tsgr_type = ch;\n\t\tif (sgr_type == 'm')\n\t\t\tb = 3;\n\n\t\t/*\n\t\t * Some terminals (like PuTTY 0.63) mistakenly send\n\t\t * button-release events for scroll-wheel button-press event.\n\t\t * Discard it before it reaches any program running inside\n\t\t * tmux.\n\t\t */\n\t\tif (sgr_type == 'm' && MOUSE_WHEEL(sgr_b))\n\t\t    return (-2);\n\t} else\n\t\treturn (-1);\n\n\t/* Fill mouse event. */\n\tm->lx = tty->mouse_last_x;\n\tm->x = x;\n\tm->ly = tty->mouse_last_y;\n\tm->y = y;\n\tm->lb = tty->mouse_last_b;\n\tm->b = b;\n\tm->sgr_type = sgr_type;\n\tm->sgr_b = sgr_b;\n\n\t/* Update last mouse state. */\n\ttty->mouse_last_x = x;\n\ttty->mouse_last_y = y;\n\ttty->mouse_last_b = b;\n\n\treturn (0);\n}\n\n/*\n * Handle OSC 52 clipboard input. Returns 0 for success, -1 for failure, 1 for\n * partial.\n */\nstatic int\ntty_keys_clipboard(struct tty *tty, const char *buf, size_t len, size_t *size)\n{\n\tstruct client\t\t*c = tty->client;\n\tstruct window_pane\t*wp;\n\tsize_t\t\t\t end, terminator = 0, needed;\n\tchar\t\t\t*copy, *out;\n\tint\t\t\t outlen;\n\tu_int\t\t\t i;\n\n\t*size = 0;\n\n\t/* First five bytes are always \\033]52;. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != ']')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\tif (buf[2] != '5')\n\t\treturn (-1);\n\tif (len == 3)\n\t\treturn (1);\n\tif (buf[3] != '2')\n\t\treturn (-1);\n\tif (len == 4)\n\t\treturn (1);\n\tif (buf[4] != ';')\n\t\treturn (-1);\n\tif (len == 5)\n\t\treturn (1);\n\n\t/* Find the terminator if any. */\n\tfor (end = 5; end < len; end++) {\n\t\tif (buf[end] == '\\007') {\n\t\t\tterminator = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (end > 5 && buf[end - 1] == '\\033' && buf[end] == '\\\\') {\n\t\t\tterminator = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (end == len)\n\t\treturn (1);\n\t*size = end + 1;\n\n\t/* Skip the initial part. */\n\tbuf += 5;\n\tend -= 5;\n\n\t/* Adjust end so that it points to the start of the terminator. */\n\tend -= terminator - 1;\n\n\t/* Get the second argument. */\n\twhile (end != 0 && *buf != ';') {\n\t\tbuf++;\n\t\tend--;\n\t}\n\tif (end == 0 || end == 1)\n\t\treturn (0);\n\tbuf++;\n\tend--;\n\n\t/* If we did not request this, ignore it. */\n\tif (~tty->flags & TTY_OSC52QUERY)\n\t\treturn (0);\n\ttty->flags &= ~TTY_OSC52QUERY;\n\tevtimer_del(&tty->clipboard_timer);\n\n\t/* It has to be a string so copy it. */\n\tcopy = xmalloc(end + 1);\n\tmemcpy(copy, buf, end);\n\tcopy[end] = '\\0';\n\n\t/* Convert from base64. */\n\tneeded = (end / 4) * 3;\n\tout = xmalloc(needed);\n\tif ((outlen = b64_pton(copy, out, len)) == -1) {\n\t\tfree(out);\n\t\tfree(copy);\n\t\treturn (0);\n\t}\n\tfree(copy);\n\n\t/* Create a new paste buffer and forward to panes. */\n\tlog_debug(\"%s: %.*s\", __func__, outlen, out);\n\tif (c->flags & CLIENT_CLIPBOARDBUFFER) {\n\t\tpaste_add(NULL, out, outlen);\n\t\tc->flags &= ~CLIENT_CLIPBOARDBUFFER;\n\t}\n\tfor (i = 0; i < c->clipboard_npanes; i++) {\n\t\twp = window_pane_find_by_id(c->clipboard_panes[i]);\n\t\tif (wp != NULL)\n\t\t\tinput_reply_clipboard(wp->event, out, outlen, \"\\033\\\\\");\n\t}\n\tfree(c->clipboard_panes);\n\tc->clipboard_panes = NULL;\n\tc->clipboard_npanes = 0;\n\n\treturn (0);\n}\n\n/*\n * Handle primary device attributes input. Returns 0 for success, -1 for\n * failure, 1 for partial.\n */\nstatic int\ntty_keys_device_attributes(struct tty *tty, const char *buf, size_t len,\n    size_t *size)\n{\n\tstruct client\t*c = tty->client;\n\tint\t\t*features = &c->term_features;\n\tu_int\t\t i, n = 0;\n\tchar\t\t tmp[128], *endptr, p[32] = { 0 }, *cp, *next;\n\n\t*size = 0;\n\tif (tty->flags & TTY_HAVEDA)\n\t\treturn (-1);\n\n\t/* First three bytes are always \\033[?. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\tif (buf[2] != '?')\n\t\treturn (-1);\n\tif (len == 3)\n\t\treturn (1);\n\n\t/* Copy the rest up to a c. */\n\tfor (i = 0; i < (sizeof tmp); i++) {\n\t\tif (3 + i == len)\n\t\t\treturn (1);\n\t\tif (buf[3 + i] == 'c')\n\t\t\tbreak;\n\t\ttmp[i] = buf[3 + i];\n\t}\n\tif (i == (sizeof tmp))\n\t\treturn (-1);\n\ttmp[i] = '\\0';\n\t*size = 4 + i;\n\n\t/* Convert all arguments to numbers. */\n\tcp = tmp;\n\twhile ((next = strsep(&cp, \";\")) != NULL) {\n\t\tp[n] = strtoul(next, &endptr, 10);\n\t\tif (*endptr != '\\0')\n\t\t\tp[n] = 0;\n\t\tif (++n == nitems(p))\n\t\t\tbreak;\n\t}\n\n\t/* Add terminal features. */\n\tswitch (p[0]) {\n\tcase 61: /* level 1 */\n\tcase 62: /* level 2 */\n\tcase 63: /* level 3 */\n\tcase 64: /* level 4 */\n\tcase 65: /* level 5 */\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tlog_debug(\"%s: DA feature: %d\", c->name, p[i]);\n\t\t\tif (p[i] == 4)\n\t\t\t\ttty_add_features(features, \"sixel\", \",\");\n\t\t\tif (p[i] == 21)\n\t\t\t\ttty_add_features(features, \"margins\", \",\");\n\t\t\tif (p[i] == 28)\n\t\t\t\ttty_add_features(features, \"rectfill\", \",\");\n\t\t}\n\t\tbreak;\n\t}\n\tlog_debug(\"%s: received primary DA %.*s\", c->name, (int)*size, buf);\n\n\ttty_update_features(tty);\n\ttty->flags |= TTY_HAVEDA;\n\n\treturn (0);\n}\n\n/*\n * Handle secondary device attributes input. Returns 0 for success, -1 for\n * failure, 1 for partial.\n */\nstatic int\ntty_keys_device_attributes2(struct tty *tty, const char *buf, size_t len,\n    size_t *size)\n{\n\tstruct client\t*c = tty->client;\n\tint\t\t*features = &c->term_features;\n\tu_int\t\t i, n = 0;\n\tchar\t\t tmp[128], *endptr, p[32] = { 0 }, *cp, *next;\n\n\t*size = 0;\n\tif (tty->flags & TTY_HAVEDA2)\n\t\treturn (-1);\n\n\t/* First three bytes are always \\033[>. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\tif (buf[2] != '>')\n\t\treturn (-1);\n\tif (len == 3)\n\t\treturn (1);\n\n\t/* Copy the rest up to a c. */\n\tfor (i = 0; i < (sizeof tmp); i++) {\n\t\tif (3 + i == len)\n\t\t\treturn (1);\n\t\tif (buf[3 + i] == 'c')\n\t\t\tbreak;\n\t\ttmp[i] = buf[3 + i];\n\t}\n\tif (i == (sizeof tmp))\n\t\treturn (-1);\n\ttmp[i] = '\\0';\n\t*size = 4 + i;\n\n\t/* Convert all arguments to numbers. */\n\tcp = tmp;\n\twhile ((next = strsep(&cp, \";\")) != NULL) {\n\t\tp[n] = strtoul(next, &endptr, 10);\n\t\tif (*endptr != '\\0')\n\t\t\tp[n] = 0;\n\t\tif (++n == nitems(p))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Add terminal features. We add DECSLRM and DECFRA for some\n\t * identification codes here, notably 64 will catch VT520, even though\n\t * we can't use level 5 from DA because of VTE.\n\t */\n\tswitch (p[0]) {\n\tcase 'M': /* mintty */\n\t\ttty_default_features(features, \"mintty\", 0);\n\t\tbreak;\n\tcase 'T': /* tmux */\n\t\ttty_default_features(features, \"tmux\", 0);\n\t\tbreak;\n\tcase 'U': /* rxvt-unicode */\n\t\ttty_default_features(features, \"rxvt-unicode\", 0);\n\t\tbreak;\n\t}\n\tlog_debug(\"%s: received secondary DA %.*s\", c->name, (int)*size, buf);\n\n\ttty_update_features(tty);\n\ttty->flags |= TTY_HAVEDA2;\n\n\treturn (0);\n}\n\n/*\n * Handle extended device attributes input. Returns 0 for success, -1 for\n * failure, 1 for partial.\n */\nstatic int\ntty_keys_extended_device_attributes(struct tty *tty, const char *buf,\n    size_t len, size_t *size)\n{\n\tstruct client\t*c = tty->client;\n\tint\t\t*features = &c->term_features;\n\tu_int\t\t i;\n\tchar\t\t tmp[128];\n\n\t*size = 0;\n\tif (tty->flags & TTY_HAVEXDA)\n\t\treturn (-1);\n\n\t/* First four bytes are always \\033P>|. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != 'P')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\tif (buf[2] != '>')\n\t\treturn (-1);\n\tif (len == 3)\n\t\treturn (1);\n\tif (buf[3] != '|')\n\t\treturn (-1);\n\tif (len == 4)\n\t\treturn (1);\n\n\t/* Copy the rest up to \\033\\. */\n\tfor (i = 0; i < (sizeof tmp) - 1; i++) {\n\t\tif (4 + i == len)\n\t\t\treturn (1);\n\t\tif (buf[4 + i - 1] == '\\033' && buf[4 + i] == '\\\\')\n\t\t\tbreak;\n\t\ttmp[i] = buf[4 + i];\n\t}\n\tif (i == (sizeof tmp) - 1)\n\t\treturn (-1);\n\ttmp[i - 1] = '\\0';\n\t*size = 5 + i;\n\n\t/* Add terminal features. */\n\tif (strncmp(tmp, \"iTerm2 \", 7) == 0)\n\t\ttty_default_features(features, \"iTerm2\", 0);\n\telse if (strncmp(tmp, \"tmux \", 5) == 0)\n\t\ttty_default_features(features, \"tmux\", 0);\n\telse if (strncmp(tmp, \"XTerm(\", 6) == 0)\n\t\ttty_default_features(features, \"XTerm\", 0);\n\telse if (strncmp(tmp, \"mintty \", 7) == 0)\n\t\ttty_default_features(features, \"mintty\", 0);\n\telse if (strncmp(tmp, \"foot(\", 5) == 0)\n\t\ttty_default_features(features, \"foot\", 0);\n\tlog_debug(\"%s: received extended DA %.*s\", c->name, (int)*size, buf);\n\n\tfree(c->term_type);\n\tc->term_type = xstrdup(tmp);\n\n\ttty_update_features(tty);\n\ttty->flags |= TTY_HAVEXDA;\n\n\treturn (0);\n}\n\n/*\n * Handle foreground or background input. Returns 0 for success, -1 for\n * failure, 1 for partial.\n */\nint\ntty_keys_colours(struct tty *tty, const char *buf, size_t len, size_t *size,\n    int *fg, int *bg)\n{\n\tstruct client\t*c = tty->client;\n\tu_int\t\t i;\n\tchar\t\t tmp[128];\n\tint\t\t n;\n\n\t*size = 0;\n\n\t/* First four bytes are always \\033]1 and 0 or 1 and ;. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != ']')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\tif (buf[2] != '1')\n\t\treturn (-1);\n\tif (len == 3)\n\t\treturn (1);\n\tif (buf[3] != '0' && buf[3] != '1')\n\t\treturn (-1);\n\tif (len == 4)\n\t\treturn (1);\n\tif (buf[4] != ';')\n\t\treturn (-1);\n\tif (len == 5)\n\t\treturn (1);\n\n\t/* Copy the rest up to \\033\\ or \\007. */\n\tfor (i = 0; i < (sizeof tmp) - 1; i++) {\n\t\tif (5 + i == len)\n\t\t\treturn (1);\n\t\tif (buf[5 + i - 1] == '\\033' && buf[5 + i] == '\\\\')\n\t\t\tbreak;\n\t\tif (buf[5 + i] == '\\007')\n\t\t\tbreak;\n\t\ttmp[i] = buf[5 + i];\n\t}\n\tif (i == (sizeof tmp) - 1)\n\t\treturn (-1);\n\tif (tmp[i - 1] == '\\033')\n\t\ttmp[i - 1] = '\\0';\n\telse\n\t\ttmp[i] = '\\0';\n\t*size = 6 + i;\n\n\tn = colour_parseX11(tmp);\n\tif (n != -1 && buf[3] == '0') {\n\t\tif (c != NULL)\n\t\t\tlog_debug(\"%s fg is %s\", c->name, colour_tostring(n));\n\t\telse\n\t\t\tlog_debug(\"fg is %s\", colour_tostring(n));\n\t\t*fg = n;\n\t} else if (n != -1) {\n\t\tif (c != NULL)\n\t\t\tlog_debug(\"%s bg is %s\", c->name, colour_tostring(n));\n\t\telse\n\t\t\tlog_debug(\"bg is %s\", colour_tostring(n));\n\t\t*bg = n;\n\t}\n\n\treturn (0);\n}\n"
        },
        {
          "name": "tty-term.c",
          "type": "blob",
          "size": 25.9912109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#if defined(HAVE_CURSES_H)\n#include <curses.h>\n#elif defined(HAVE_NCURSES_H)\n#include <ncurses.h>\n#endif\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <string.h>\n#include <term.h>\n\n#include \"tmux.h\"\n\nstatic char\t*tty_term_strip(const char *);\n\nstruct tty_terms tty_terms = LIST_HEAD_INITIALIZER(tty_terms);\n\nenum tty_code_type {\n\tTTYCODE_NONE = 0,\n\tTTYCODE_STRING,\n\tTTYCODE_NUMBER,\n\tTTYCODE_FLAG,\n};\n\nstruct tty_code {\n\tenum tty_code_type\ttype;\n\tunion {\n\t\tchar\t       *string;\n\t\tint\t\tnumber;\n\t\tint\t\tflag;\n\t} value;\n};\n\nstruct tty_term_code_entry {\n\tenum tty_code_type\ttype;\n\tconst char\t       *name;\n};\n\nstatic const struct tty_term_code_entry tty_term_codes[] = {\n\t[TTYC_ACSC] = { TTYCODE_STRING, \"acsc\" },\n\t[TTYC_AM] = { TTYCODE_FLAG, \"am\" },\n\t[TTYC_AX] = { TTYCODE_FLAG, \"AX\" },\n\t[TTYC_BCE] = { TTYCODE_FLAG, \"bce\" },\n\t[TTYC_BEL] = { TTYCODE_STRING, \"bel\" },\n\t[TTYC_BIDI] = { TTYCODE_STRING, \"Bidi\" },\n\t[TTYC_BLINK] = { TTYCODE_STRING, \"blink\" },\n\t[TTYC_BOLD] = { TTYCODE_STRING, \"bold\" },\n\t[TTYC_CIVIS] = { TTYCODE_STRING, \"civis\" },\n\t[TTYC_CLEAR] = { TTYCODE_STRING, \"clear\" },\n\t[TTYC_CLMG] = { TTYCODE_STRING, \"Clmg\" },\n\t[TTYC_CMG] = { TTYCODE_STRING, \"Cmg\" },\n\t[TTYC_CNORM] = { TTYCODE_STRING, \"cnorm\" },\n\t[TTYC_COLORS] = { TTYCODE_NUMBER, \"colors\" },\n\t[TTYC_CR] = { TTYCODE_STRING, \"Cr\" },\n\t[TTYC_CSR] = { TTYCODE_STRING, \"csr\" },\n\t[TTYC_CS] = { TTYCODE_STRING, \"Cs\" },\n\t[TTYC_CUB1] = { TTYCODE_STRING, \"cub1\" },\n\t[TTYC_CUB] = { TTYCODE_STRING, \"cub\" },\n\t[TTYC_CUD1] = { TTYCODE_STRING, \"cud1\" },\n\t[TTYC_CUD] = { TTYCODE_STRING, \"cud\" },\n\t[TTYC_CUF1] = { TTYCODE_STRING, \"cuf1\" },\n\t[TTYC_CUF] = { TTYCODE_STRING, \"cuf\" },\n\t[TTYC_CUP] = { TTYCODE_STRING, \"cup\" },\n\t[TTYC_CUU1] = { TTYCODE_STRING, \"cuu1\" },\n\t[TTYC_CUU] = { TTYCODE_STRING, \"cuu\" },\n\t[TTYC_CVVIS] = { TTYCODE_STRING, \"cvvis\" },\n\t[TTYC_DCH1] = { TTYCODE_STRING, \"dch1\" },\n\t[TTYC_DCH] = { TTYCODE_STRING, \"dch\" },\n\t[TTYC_DIM] = { TTYCODE_STRING, \"dim\" },\n\t[TTYC_DL1] = { TTYCODE_STRING, \"dl1\" },\n\t[TTYC_DL] = { TTYCODE_STRING, \"dl\" },\n\t[TTYC_DSEKS] = { TTYCODE_STRING, \"Dseks\" },\n\t[TTYC_DSFCS] = { TTYCODE_STRING, \"Dsfcs\" },\n\t[TTYC_DSBP] = { TTYCODE_STRING, \"Dsbp\" },\n\t[TTYC_DSMG] = { TTYCODE_STRING, \"Dsmg\" },\n\t[TTYC_E3] = { TTYCODE_STRING, \"E3\" },\n\t[TTYC_ECH] = { TTYCODE_STRING, \"ech\" },\n\t[TTYC_ED] = { TTYCODE_STRING, \"ed\" },\n\t[TTYC_EL1] = { TTYCODE_STRING, \"el1\" },\n\t[TTYC_EL] = { TTYCODE_STRING, \"el\" },\n\t[TTYC_ENACS] = { TTYCODE_STRING, \"enacs\" },\n\t[TTYC_ENBP] = { TTYCODE_STRING, \"Enbp\" },\n\t[TTYC_ENEKS] = { TTYCODE_STRING, \"Eneks\" },\n\t[TTYC_ENFCS] = { TTYCODE_STRING, \"Enfcs\" },\n\t[TTYC_ENMG] = { TTYCODE_STRING, \"Enmg\" },\n\t[TTYC_FSL] = { TTYCODE_STRING, \"fsl\" },\n\t[TTYC_HLS] = { TTYCODE_STRING, \"Hls\" },\n\t[TTYC_HOME] = { TTYCODE_STRING, \"home\" },\n\t[TTYC_HPA] = { TTYCODE_STRING, \"hpa\" },\n\t[TTYC_ICH1] = { TTYCODE_STRING, \"ich1\" },\n\t[TTYC_ICH] = { TTYCODE_STRING, \"ich\" },\n\t[TTYC_IL1] = { TTYCODE_STRING, \"il1\" },\n\t[TTYC_IL] = { TTYCODE_STRING, \"il\" },\n\t[TTYC_INDN] = { TTYCODE_STRING, \"indn\" },\n\t[TTYC_INVIS] = { TTYCODE_STRING, \"invis\" },\n\t[TTYC_KCBT] = { TTYCODE_STRING, \"kcbt\" },\n\t[TTYC_KCUB1] = { TTYCODE_STRING, \"kcub1\" },\n\t[TTYC_KCUD1] = { TTYCODE_STRING, \"kcud1\" },\n\t[TTYC_KCUF1] = { TTYCODE_STRING, \"kcuf1\" },\n\t[TTYC_KCUU1] = { TTYCODE_STRING, \"kcuu1\" },\n\t[TTYC_KDC2] = { TTYCODE_STRING, \"kDC\" },\n\t[TTYC_KDC3] = { TTYCODE_STRING, \"kDC3\" },\n\t[TTYC_KDC4] = { TTYCODE_STRING, \"kDC4\" },\n\t[TTYC_KDC5] = { TTYCODE_STRING, \"kDC5\" },\n\t[TTYC_KDC6] = { TTYCODE_STRING, \"kDC6\" },\n\t[TTYC_KDC7] = { TTYCODE_STRING, \"kDC7\" },\n\t[TTYC_KDCH1] = { TTYCODE_STRING, \"kdch1\" },\n\t[TTYC_KDN2] = { TTYCODE_STRING, \"kDN\" }, /* not kDN2 */\n\t[TTYC_KDN3] = { TTYCODE_STRING, \"kDN3\" },\n\t[TTYC_KDN4] = { TTYCODE_STRING, \"kDN4\" },\n\t[TTYC_KDN5] = { TTYCODE_STRING, \"kDN5\" },\n\t[TTYC_KDN6] = { TTYCODE_STRING, \"kDN6\" },\n\t[TTYC_KDN7] = { TTYCODE_STRING, \"kDN7\" },\n\t[TTYC_KEND2] = { TTYCODE_STRING, \"kEND\" },\n\t[TTYC_KEND3] = { TTYCODE_STRING, \"kEND3\" },\n\t[TTYC_KEND4] = { TTYCODE_STRING, \"kEND4\" },\n\t[TTYC_KEND5] = { TTYCODE_STRING, \"kEND5\" },\n\t[TTYC_KEND6] = { TTYCODE_STRING, \"kEND6\" },\n\t[TTYC_KEND7] = { TTYCODE_STRING, \"kEND7\" },\n\t[TTYC_KEND] = { TTYCODE_STRING, \"kend\" },\n\t[TTYC_KF10] = { TTYCODE_STRING, \"kf10\" },\n\t[TTYC_KF11] = { TTYCODE_STRING, \"kf11\" },\n\t[TTYC_KF12] = { TTYCODE_STRING, \"kf12\" },\n\t[TTYC_KF13] = { TTYCODE_STRING, \"kf13\" },\n\t[TTYC_KF14] = { TTYCODE_STRING, \"kf14\" },\n\t[TTYC_KF15] = { TTYCODE_STRING, \"kf15\" },\n\t[TTYC_KF16] = { TTYCODE_STRING, \"kf16\" },\n\t[TTYC_KF17] = { TTYCODE_STRING, \"kf17\" },\n\t[TTYC_KF18] = { TTYCODE_STRING, \"kf18\" },\n\t[TTYC_KF19] = { TTYCODE_STRING, \"kf19\" },\n\t[TTYC_KF1] = { TTYCODE_STRING, \"kf1\" },\n\t[TTYC_KF20] = { TTYCODE_STRING, \"kf20\" },\n\t[TTYC_KF21] = { TTYCODE_STRING, \"kf21\" },\n\t[TTYC_KF22] = { TTYCODE_STRING, \"kf22\" },\n\t[TTYC_KF23] = { TTYCODE_STRING, \"kf23\" },\n\t[TTYC_KF24] = { TTYCODE_STRING, \"kf24\" },\n\t[TTYC_KF25] = { TTYCODE_STRING, \"kf25\" },\n\t[TTYC_KF26] = { TTYCODE_STRING, \"kf26\" },\n\t[TTYC_KF27] = { TTYCODE_STRING, \"kf27\" },\n\t[TTYC_KF28] = { TTYCODE_STRING, \"kf28\" },\n\t[TTYC_KF29] = { TTYCODE_STRING, \"kf29\" },\n\t[TTYC_KF2] = { TTYCODE_STRING, \"kf2\" },\n\t[TTYC_KF30] = { TTYCODE_STRING, \"kf30\" },\n\t[TTYC_KF31] = { TTYCODE_STRING, \"kf31\" },\n\t[TTYC_KF32] = { TTYCODE_STRING, \"kf32\" },\n\t[TTYC_KF33] = { TTYCODE_STRING, \"kf33\" },\n\t[TTYC_KF34] = { TTYCODE_STRING, \"kf34\" },\n\t[TTYC_KF35] = { TTYCODE_STRING, \"kf35\" },\n\t[TTYC_KF36] = { TTYCODE_STRING, \"kf36\" },\n\t[TTYC_KF37] = { TTYCODE_STRING, \"kf37\" },\n\t[TTYC_KF38] = { TTYCODE_STRING, \"kf38\" },\n\t[TTYC_KF39] = { TTYCODE_STRING, \"kf39\" },\n\t[TTYC_KF3] = { TTYCODE_STRING, \"kf3\" },\n\t[TTYC_KF40] = { TTYCODE_STRING, \"kf40\" },\n\t[TTYC_KF41] = { TTYCODE_STRING, \"kf41\" },\n\t[TTYC_KF42] = { TTYCODE_STRING, \"kf42\" },\n\t[TTYC_KF43] = { TTYCODE_STRING, \"kf43\" },\n\t[TTYC_KF44] = { TTYCODE_STRING, \"kf44\" },\n\t[TTYC_KF45] = { TTYCODE_STRING, \"kf45\" },\n\t[TTYC_KF46] = { TTYCODE_STRING, \"kf46\" },\n\t[TTYC_KF47] = { TTYCODE_STRING, \"kf47\" },\n\t[TTYC_KF48] = { TTYCODE_STRING, \"kf48\" },\n\t[TTYC_KF49] = { TTYCODE_STRING, \"kf49\" },\n\t[TTYC_KF4] = { TTYCODE_STRING, \"kf4\" },\n\t[TTYC_KF50] = { TTYCODE_STRING, \"kf50\" },\n\t[TTYC_KF51] = { TTYCODE_STRING, \"kf51\" },\n\t[TTYC_KF52] = { TTYCODE_STRING, \"kf52\" },\n\t[TTYC_KF53] = { TTYCODE_STRING, \"kf53\" },\n\t[TTYC_KF54] = { TTYCODE_STRING, \"kf54\" },\n\t[TTYC_KF55] = { TTYCODE_STRING, \"kf55\" },\n\t[TTYC_KF56] = { TTYCODE_STRING, \"kf56\" },\n\t[TTYC_KF57] = { TTYCODE_STRING, \"kf57\" },\n\t[TTYC_KF58] = { TTYCODE_STRING, \"kf58\" },\n\t[TTYC_KF59] = { TTYCODE_STRING, \"kf59\" },\n\t[TTYC_KF5] = { TTYCODE_STRING, \"kf5\" },\n\t[TTYC_KF60] = { TTYCODE_STRING, \"kf60\" },\n\t[TTYC_KF61] = { TTYCODE_STRING, \"kf61\" },\n\t[TTYC_KF62] = { TTYCODE_STRING, \"kf62\" },\n\t[TTYC_KF63] = { TTYCODE_STRING, \"kf63\" },\n\t[TTYC_KF6] = { TTYCODE_STRING, \"kf6\" },\n\t[TTYC_KF7] = { TTYCODE_STRING, \"kf7\" },\n\t[TTYC_KF8] = { TTYCODE_STRING, \"kf8\" },\n\t[TTYC_KF9] = { TTYCODE_STRING, \"kf9\" },\n\t[TTYC_KHOM2] = { TTYCODE_STRING, \"kHOM\" },\n\t[TTYC_KHOM3] = { TTYCODE_STRING, \"kHOM3\" },\n\t[TTYC_KHOM4] = { TTYCODE_STRING, \"kHOM4\" },\n\t[TTYC_KHOM5] = { TTYCODE_STRING, \"kHOM5\" },\n\t[TTYC_KHOM6] = { TTYCODE_STRING, \"kHOM6\" },\n\t[TTYC_KHOM7] = { TTYCODE_STRING, \"kHOM7\" },\n\t[TTYC_KHOME] = { TTYCODE_STRING, \"khome\" },\n\t[TTYC_KIC2] = { TTYCODE_STRING, \"kIC\" },\n\t[TTYC_KIC3] = { TTYCODE_STRING, \"kIC3\" },\n\t[TTYC_KIC4] = { TTYCODE_STRING, \"kIC4\" },\n\t[TTYC_KIC5] = { TTYCODE_STRING, \"kIC5\" },\n\t[TTYC_KIC6] = { TTYCODE_STRING, \"kIC6\" },\n\t[TTYC_KIC7] = { TTYCODE_STRING, \"kIC7\" },\n\t[TTYC_KICH1] = { TTYCODE_STRING, \"kich1\" },\n\t[TTYC_KIND] = { TTYCODE_STRING, \"kind\" },\n\t[TTYC_KLFT2] = { TTYCODE_STRING, \"kLFT\" },\n\t[TTYC_KLFT3] = { TTYCODE_STRING, \"kLFT3\" },\n\t[TTYC_KLFT4] = { TTYCODE_STRING, \"kLFT4\" },\n\t[TTYC_KLFT5] = { TTYCODE_STRING, \"kLFT5\" },\n\t[TTYC_KLFT6] = { TTYCODE_STRING, \"kLFT6\" },\n\t[TTYC_KLFT7] = { TTYCODE_STRING, \"kLFT7\" },\n\t[TTYC_KMOUS] = { TTYCODE_STRING, \"kmous\" },\n\t[TTYC_KNP] = { TTYCODE_STRING, \"knp\" },\n\t[TTYC_KNXT2] = { TTYCODE_STRING, \"kNXT\" },\n\t[TTYC_KNXT3] = { TTYCODE_STRING, \"kNXT3\" },\n\t[TTYC_KNXT4] = { TTYCODE_STRING, \"kNXT4\" },\n\t[TTYC_KNXT5] = { TTYCODE_STRING, \"kNXT5\" },\n\t[TTYC_KNXT6] = { TTYCODE_STRING, \"kNXT6\" },\n\t[TTYC_KNXT7] = { TTYCODE_STRING, \"kNXT7\" },\n\t[TTYC_KPP] = { TTYCODE_STRING, \"kpp\" },\n\t[TTYC_KPRV2] = { TTYCODE_STRING, \"kPRV\" },\n\t[TTYC_KPRV3] = { TTYCODE_STRING, \"kPRV3\" },\n\t[TTYC_KPRV4] = { TTYCODE_STRING, \"kPRV4\" },\n\t[TTYC_KPRV5] = { TTYCODE_STRING, \"kPRV5\" },\n\t[TTYC_KPRV6] = { TTYCODE_STRING, \"kPRV6\" },\n\t[TTYC_KPRV7] = { TTYCODE_STRING, \"kPRV7\" },\n\t[TTYC_KRIT2] = { TTYCODE_STRING, \"kRIT\" },\n\t[TTYC_KRIT3] = { TTYCODE_STRING, \"kRIT3\" },\n\t[TTYC_KRIT4] = { TTYCODE_STRING, \"kRIT4\" },\n\t[TTYC_KRIT5] = { TTYCODE_STRING, \"kRIT5\" },\n\t[TTYC_KRIT6] = { TTYCODE_STRING, \"kRIT6\" },\n\t[TTYC_KRIT7] = { TTYCODE_STRING, \"kRIT7\" },\n\t[TTYC_KRI] = { TTYCODE_STRING, \"kri\" },\n\t[TTYC_KUP2] = { TTYCODE_STRING, \"kUP\" }, /* not kUP2 */\n\t[TTYC_KUP3] = { TTYCODE_STRING, \"kUP3\" },\n\t[TTYC_KUP4] = { TTYCODE_STRING, \"kUP4\" },\n\t[TTYC_KUP5] = { TTYCODE_STRING, \"kUP5\" },\n\t[TTYC_KUP6] = { TTYCODE_STRING, \"kUP6\" },\n\t[TTYC_KUP7] = { TTYCODE_STRING, \"kUP7\" },\n\t[TTYC_MS] = { TTYCODE_STRING, \"Ms\" },\n\t[TTYC_NOBR] = { TTYCODE_STRING, \"Nobr\" },\n\t[TTYC_OL] = { TTYCODE_STRING, \"ol\" },\n\t[TTYC_OP] = { TTYCODE_STRING, \"op\" },\n\t[TTYC_RECT] = { TTYCODE_STRING, \"Rect\" },\n\t[TTYC_REV] = { TTYCODE_STRING, \"rev\" },\n\t[TTYC_RGB] = { TTYCODE_FLAG, \"RGB\" },\n\t[TTYC_RIN] = { TTYCODE_STRING, \"rin\" },\n\t[TTYC_RI] = { TTYCODE_STRING, \"ri\" },\n\t[TTYC_RMACS] = { TTYCODE_STRING, \"rmacs\" },\n\t[TTYC_RMCUP] = { TTYCODE_STRING, \"rmcup\" },\n\t[TTYC_RMKX] = { TTYCODE_STRING, \"rmkx\" },\n\t[TTYC_SETAB] = { TTYCODE_STRING, \"setab\" },\n\t[TTYC_SETAF] = { TTYCODE_STRING, \"setaf\" },\n\t[TTYC_SETAL] = { TTYCODE_STRING, \"setal\" },\n\t[TTYC_SETRGBB] = { TTYCODE_STRING, \"setrgbb\" },\n\t[TTYC_SETRGBF] = { TTYCODE_STRING, \"setrgbf\" },\n\t[TTYC_SETULC] = { TTYCODE_STRING, \"Setulc\" },\n\t[TTYC_SETULC1] = { TTYCODE_STRING, \"Setulc1\" },\n\t[TTYC_SE] = { TTYCODE_STRING, \"Se\" },\n\t[TTYC_SXL] =  { TTYCODE_FLAG, \"Sxl\" },\n\t[TTYC_SGR0] = { TTYCODE_STRING, \"sgr0\" },\n\t[TTYC_SITM] = { TTYCODE_STRING, \"sitm\" },\n\t[TTYC_SMACS] = { TTYCODE_STRING, \"smacs\" },\n\t[TTYC_SMCUP] = { TTYCODE_STRING, \"smcup\" },\n\t[TTYC_SMKX] = { TTYCODE_STRING, \"smkx\" },\n\t[TTYC_SMOL] = { TTYCODE_STRING, \"Smol\" },\n\t[TTYC_SMSO] = { TTYCODE_STRING, \"smso\" },\n\t[TTYC_SMULX] = { TTYCODE_STRING, \"Smulx\" },\n\t[TTYC_SMUL] = { TTYCODE_STRING, \"smul\" },\n\t[TTYC_SMXX] =  { TTYCODE_STRING, \"smxx\" },\n\t[TTYC_SS] = { TTYCODE_STRING, \"Ss\" },\n\t[TTYC_SWD] = { TTYCODE_STRING, \"Swd\" },\n\t[TTYC_SYNC] = { TTYCODE_STRING, \"Sync\" },\n\t[TTYC_TC] = { TTYCODE_FLAG, \"Tc\" },\n\t[TTYC_TSL] = { TTYCODE_STRING, \"tsl\" },\n\t[TTYC_U8] = { TTYCODE_NUMBER, \"U8\" },\n\t[TTYC_VPA] = { TTYCODE_STRING, \"vpa\" },\n\t[TTYC_XT] = { TTYCODE_FLAG, \"XT\" }\n};\n\nu_int\ntty_term_ncodes(void)\n{\n\treturn (nitems(tty_term_codes));\n}\n\nstatic char *\ntty_term_strip(const char *s)\n{\n\tconst char     *ptr;\n\tstatic char\tbuf[8192];\n\tsize_t\t\tlen;\n\n\t/* Ignore strings with no padding. */\n\tif (strchr(s, '$') == NULL)\n\t\treturn (xstrdup(s));\n\n\tlen = 0;\n\tfor (ptr = s; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr == '$' && *(ptr + 1) == '<') {\n\t\t\twhile (*ptr != '\\0' && *ptr != '>')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '>')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbuf[len++] = *ptr;\n\t\tif (len == (sizeof buf) - 1)\n\t\t\tbreak;\n\t}\n\tbuf[len] = '\\0';\n\n\treturn (xstrdup(buf));\n}\n\nstatic char *\ntty_term_override_next(const char *s, size_t *offset)\n{\n\tstatic char\tvalue[8192];\n\tsize_t\t\tn = 0, at = *offset;\n\n\tif (s[at] == '\\0')\n\t\treturn (NULL);\n\n\twhile (s[at] != '\\0') {\n\t\tif (s[at] == ':') {\n\t\t\tif (s[at + 1] == ':') {\n\t\t\t\tvalue[n++] = ':';\n\t\t\t\tat += 2;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tvalue[n++] = s[at];\n\t\t\tat++;\n\t\t}\n\t\tif (n == (sizeof value) - 1)\n\t\t\treturn (NULL);\n\t}\n\tif (s[at] != '\\0')\n\t\t*offset = at + 1;\n\telse\n\t\t*offset = at;\n\tvalue[n] = '\\0';\n\treturn (value);\n}\n\nvoid\ntty_term_apply(struct tty_term *term, const char *capabilities, int quiet)\n{\n\tconst struct tty_term_code_entry\t*ent;\n\tstruct tty_code\t\t\t\t*code;\n\tsize_t                                   offset = 0;\n\tchar\t\t\t\t\t*cp, *value, *s;\n\tconst char\t\t\t\t*errstr, *name = term->name;\n\tu_int\t\t\t\t\t i;\n\tint\t\t\t\t\t n, remove;\n\n\twhile ((s = tty_term_override_next(capabilities, &offset)) != NULL) {\n\t\tif (*s == '\\0')\n\t\t\tcontinue;\n\t\tvalue = NULL;\n\n\t\tremove = 0;\n\t\tif ((cp = strchr(s, '=')) != NULL) {\n\t\t\t*cp++ = '\\0';\n\t\t\tvalue = xstrdup(cp);\n\t\t\tif (strunvis(value, cp) == -1) {\n\t\t\t\tfree(value);\n\t\t\t\tvalue = xstrdup(cp);\n\t\t\t}\n\t\t} else if (s[strlen(s) - 1] == '@') {\n\t\t\ts[strlen(s) - 1] = '\\0';\n\t\t\tremove = 1;\n\t\t} else\n\t\t\tvalue = xstrdup(\"\");\n\n\t\tif (!quiet) {\n\t\t\tif (remove)\n\t\t\t\tlog_debug(\"%s override: %s@\", name, s);\n\t\t\telse if (*value == '\\0')\n\t\t\t\tlog_debug(\"%s override: %s\", name, s);\n\t\t\telse\n\t\t\t\tlog_debug(\"%s override: %s=%s\", name, s, value);\n\t\t}\n\n\t\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\t\tent = &tty_term_codes[i];\n\t\t\tif (strcmp(s, ent->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tcode = &term->codes[i];\n\n\t\t\tif (remove) {\n\t\t\t\tcode->type = TTYCODE_NONE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (ent->type) {\n\t\t\tcase TTYCODE_NONE:\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_STRING:\n\t\t\t\tif (code->type == TTYCODE_STRING)\n\t\t\t\t\tfree(code->value.string);\n\t\t\t\tcode->value.string = xstrdup(value);\n\t\t\t\tcode->type = ent->type;\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_NUMBER:\n\t\t\t\tn = strtonum(value, 0, INT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tcode->value.number = n;\n\t\t\t\tcode->type = ent->type;\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_FLAG:\n\t\t\t\tcode->value.flag = 1;\n\t\t\t\tcode->type = ent->type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfree(value);\n\t}\n}\n\nvoid\ntty_term_apply_overrides(struct tty_term *term)\n{\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tunion options_value\t\t*ov;\n\tconst char\t\t\t*s, *acs;\n\tsize_t\t\t\t\t offset;\n\tchar\t\t\t\t*first;\n\n\t/* Update capabilities from the option. */\n\to = options_get_only(global_options, \"terminal-overrides\");\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tov = options_array_item_value(a);\n\t\ts = ov->string;\n\n\t\toffset = 0;\n\t\tfirst = tty_term_override_next(s, &offset);\n\t\tif (first != NULL && fnmatch(first, term->name, 0) == 0)\n\t\t\ttty_term_apply(term, s + offset, 0);\n\t\ta = options_array_next(a);\n\t}\n\n\t/* Log the SIXEL flag. */\n\tlog_debug(\"SIXEL flag is %d\", !!(term->flags & TERM_SIXEL));\n\n\t/* Update the RGB flag if the terminal has RGB colours. */\n\tif (tty_term_has(term, TTYC_SETRGBF) &&\n\t    tty_term_has(term, TTYC_SETRGBB))\n\t\tterm->flags |= TERM_RGBCOLOURS;\n\telse\n\t\tterm->flags &= ~TERM_RGBCOLOURS;\n\tlog_debug(\"RGBCOLOURS flag is %d\", !!(term->flags & TERM_RGBCOLOURS));\n\n\t/*\n\t * Set or clear the DECSLRM flag if the terminal has the margin\n\t * capabilities.\n\t */\n\tif (tty_term_has(term, TTYC_CMG) && tty_term_has(term, TTYC_CLMG))\n\t\tterm->flags |= TERM_DECSLRM;\n\telse\n\t\tterm->flags &= ~TERM_DECSLRM;\n\tlog_debug(\"DECSLRM flag is %d\", !!(term->flags & TERM_DECSLRM));\n\n\t/*\n\t * Set or clear the DECFRA flag if the terminal has the rectangle\n\t * capability.\n\t */\n\tif (tty_term_has(term, TTYC_RECT))\n\t\tterm->flags |= TERM_DECFRA;\n\telse\n\t\tterm->flags &= ~TERM_DECFRA;\n\tlog_debug(\"DECFRA flag is %d\", !!(term->flags & TERM_DECFRA));\n\n\t/*\n\t * Terminals without am (auto right margin) wrap at at $COLUMNS - 1\n\t * rather than $COLUMNS (the cursor can never be beyond $COLUMNS - 1).\n\t *\n\t * Terminals without xenl (eat newline glitch) ignore a newline beyond\n\t * the right edge of the terminal, but tmux doesn't care about this -\n\t * it always uses absolute only moves the cursor with a newline when\n\t * also sending a linefeed.\n\t *\n\t * This is irritating, most notably because it is painful to write to\n\t * the very bottom-right of the screen without scrolling.\n\t *\n\t * Flag the terminal here and apply some workarounds in other places to\n\t * do the best possible.\n\t */\n\tif (!tty_term_flag(term, TTYC_AM))\n\t\tterm->flags |= TERM_NOAM;\n\telse\n\t\tterm->flags &= ~TERM_NOAM;\n\tlog_debug(\"NOAM flag is %d\", !!(term->flags & TERM_NOAM));\n\n\t/* Generate ACS table. If none is present, use nearest ASCII. */\n\tmemset(term->acs, 0, sizeof term->acs);\n\tif (tty_term_has(term, TTYC_ACSC))\n\t\tacs = tty_term_string(term, TTYC_ACSC);\n\telse\n\t\tacs = \"a#j+k+l+m+n+o-p-q-r-s-t+u+v+w+x|y<z>~.\";\n\tfor (; acs[0] != '\\0' && acs[1] != '\\0'; acs += 2)\n\t\tterm->acs[(u_char) acs[0]][0] = acs[1];\n}\n\nstruct tty_term *\ntty_term_create(struct tty *tty, char *name, char **caps, u_int ncaps,\n    int *feat, char **cause)\n{\n\tstruct tty_term\t\t\t\t*term;\n\tconst struct tty_term_code_entry\t*ent;\n\tstruct tty_code\t\t\t\t*code;\n\tstruct options_entry\t\t\t*o;\n\tstruct options_array_item\t\t*a;\n\tunion options_value\t\t\t*ov;\n\tu_int\t\t\t\t\t i, j;\n\tconst char\t\t\t\t*s, *value, *errstr;\n\tsize_t\t\t\t\t\t offset, namelen;\n\tchar\t\t\t\t\t*first;\n\tint\t\t\t\t\t n;\n\n\tlog_debug(\"adding term %s\", name);\n\n\tterm = xcalloc(1, sizeof *term);\n\tterm->tty = tty;\n\tterm->name = xstrdup(name);\n\tterm->codes = xcalloc(tty_term_ncodes(), sizeof *term->codes);\n\tLIST_INSERT_HEAD(&tty_terms, term, entry);\n\n\t/* Fill in codes. */\n\tfor (i = 0; i < ncaps; i++) {\n\t\tnamelen = strcspn(caps[i], \"=\");\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\t\tvalue = caps[i] + namelen + 1;\n\n\t\tfor (j = 0; j < tty_term_ncodes(); j++) {\n\t\t\tent = &tty_term_codes[j];\n\t\t\tif (strncmp(ent->name, caps[i], namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (ent->name[namelen] != '\\0')\n\t\t\t\tcontinue;\n\n\t\t\tcode = &term->codes[j];\n\t\t\tcode->type = TTYCODE_NONE;\n\t\t\tswitch (ent->type) {\n\t\t\tcase TTYCODE_NONE:\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_STRING:\n\t\t\t\tcode->type = TTYCODE_STRING;\n\t\t\t\tcode->value.string = tty_term_strip(value);\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_NUMBER:\n\t\t\t\tn = strtonum(value, 0, INT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\tlog_debug(\"%s: %s\", ent->name, errstr);\n\t\t\t\telse {\n\t\t\t\t\tcode->type = TTYCODE_NUMBER;\n\t\t\t\t\tcode->value.number = n;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TTYCODE_FLAG:\n\t\t\t\tcode->type = TTYCODE_FLAG;\n\t\t\t\tcode->value.flag = (*value == '1');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply terminal features. */\n\to = options_get_only(global_options, \"terminal-features\");\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tov = options_array_item_value(a);\n\t\ts = ov->string;\n\n\t\toffset = 0;\n\t\tfirst = tty_term_override_next(s, &offset);\n\t\tif (first != NULL && fnmatch(first, term->name, 0) == 0)\n\t\t\ttty_add_features(feat, s + offset, \":\");\n\t\ta = options_array_next(a);\n\t}\n\n\t/* Delete curses data. */\n#if !defined(NCURSES_VERSION_MAJOR) || NCURSES_VERSION_MAJOR > 5 || \\\n    (NCURSES_VERSION_MAJOR == 5 && NCURSES_VERSION_MINOR > 6)\n\tdel_curterm(cur_term);\n#endif\n\n\t/* Apply overrides so any capabilities used for features are changed. */\n\ttty_term_apply_overrides(term);\n\n\t/* These are always required. */\n\tif (!tty_term_has(term, TTYC_CLEAR)) {\n\t\txasprintf(cause, \"terminal does not support clear\");\n\t\tgoto error;\n\t}\n\tif (!tty_term_has(term, TTYC_CUP)) {\n\t\txasprintf(cause, \"terminal does not support cup\");\n\t\tgoto error;\n\t}\n\n\t/*\n\t * If TERM has XT or clear starts with CSI then it is safe to assume\n\t * the terminal is derived from the VT100. This controls whether device\n\t * attributes requests are sent to get more information.\n\t *\n\t * This is a bit of a hack but there aren't that many alternatives.\n\t * Worst case tmux will just fall back to using whatever terminfo(5)\n\t * says without trying to correct anything that is missing.\n\t *\n\t * Also add few features that VT100-like terminals should either\n\t * support or safely ignore.\n\t */\n\ts = tty_term_string(term, TTYC_CLEAR);\n\tif (tty_term_flag(term, TTYC_XT) || strncmp(s, \"\\033[\", 2) == 0) {\n\t\tterm->flags |= TERM_VT100LIKE;\n\t\ttty_add_features(feat, \"bpaste,focus,title\", \",\");\n\t}\n\n\t/* Add RGB feature if terminal has RGB colours. */\n\tif ((tty_term_flag(term, TTYC_TC) || tty_term_has(term, TTYC_RGB)) &&\n\t    (!tty_term_has(term, TTYC_SETRGBF) ||\n\t    !tty_term_has(term, TTYC_SETRGBB)))\n\t\ttty_add_features(feat, \"RGB\", \",\");\n\n\t/* Apply the features and overrides again. */\n\tif (tty_apply_features(term, *feat))\n\t\ttty_term_apply_overrides(term);\n\n\t/* Log the capabilities. */\n\tfor (i = 0; i < tty_term_ncodes(); i++)\n\t\tlog_debug(\"%s%s\", name, tty_term_describe(term, i));\n\n\treturn (term);\n\nerror:\n\ttty_term_free(term);\n\treturn (NULL);\n}\n\nvoid\ntty_term_free(struct tty_term *term)\n{\n\tu_int\ti;\n\n\tlog_debug(\"removing term %s\", term->name);\n\n\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\tif (term->codes[i].type == TTYCODE_STRING)\n\t\t\tfree(term->codes[i].value.string);\n\t}\n\tfree(term->codes);\n\n\tLIST_REMOVE(term, entry);\n\tfree(term->name);\n\tfree(term);\n}\n\nint\ntty_term_read_list(const char *name, int fd, char ***caps, u_int *ncaps,\n    char **cause)\n{\n\tconst struct tty_term_code_entry\t*ent;\n\tint\t\t\t\t\t error, n;\n\tu_int\t\t\t\t\t i;\n\tconst char\t\t\t\t*s;\n\tchar\t\t\t\t\t tmp[11];\n\n\tif (setupterm((char *)name, fd, &error) != OK) {\n\t\tswitch (error) {\n\t\tcase 1:\n\t\t\txasprintf(cause, \"can't use hardcopy terminal: %s\",\n\t\t\t    name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\txasprintf(cause, \"missing or unsuitable terminal: %s\",\n\t\t\t    name);\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\txasprintf(cause, \"can't find terminfo database\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txasprintf(cause, \"unknown error\");\n\t\t\tbreak;\n\t\t}\n\t\treturn (-1);\n\t}\n\n\t*ncaps = 0;\n\t*caps = NULL;\n\n\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\tent = &tty_term_codes[i];\n\t\tswitch (ent->type) {\n\t\tcase TTYCODE_NONE:\n\t\t\tcontinue;\n\t\tcase TTYCODE_STRING:\n\t\t\ts = tigetstr((char *)ent->name);\n\t\t\tif (s == NULL || s == (char *)-1)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TTYCODE_NUMBER:\n\t\t\tn = tigetnum((char *)ent->name);\n\t\t\tif (n == -1 || n == -2)\n\t\t\t\tcontinue;\n\t\t\txsnprintf(tmp, sizeof tmp, \"%d\", n);\n\t\t\ts = tmp;\n\t\t\tbreak;\n\t\tcase TTYCODE_FLAG:\n\t\t\tn = tigetflag((char *)ent->name);\n\t\t\tif (n == -1)\n\t\t\t\tcontinue;\n\t\t\tif (n)\n\t\t\t\ts = \"1\";\n\t\t\telse\n\t\t\t\ts = \"0\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatalx(\"unknown capability type\");\n\t\t}\n\t\t*caps = xreallocarray(*caps, (*ncaps) + 1, sizeof **caps);\n\t\txasprintf(&(*caps)[*ncaps], \"%s=%s\", ent->name, s);\n\t\t(*ncaps)++;\n\t}\n\n#if !defined(NCURSES_VERSION_MAJOR) || NCURSES_VERSION_MAJOR > 5 || \\\n    (NCURSES_VERSION_MAJOR == 5 && NCURSES_VERSION_MINOR > 6)\n\tdel_curterm(cur_term);\n#endif\n\treturn (0);\n}\n\nvoid\ntty_term_free_list(char **caps, u_int ncaps)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ncaps; i++)\n\t\tfree(caps[i]);\n\tfree(caps);\n}\n\nint\ntty_term_has(struct tty_term *term, enum tty_code_code code)\n{\n\treturn (term->codes[code].type != TTYCODE_NONE);\n}\n\nconst char *\ntty_term_string(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (\"\");\n\tif (term->codes[code].type != TTYCODE_STRING)\n\t\tfatalx(\"not a string: %d\", code);\n\treturn (term->codes[code].value.string);\n}\n\nconst char *\ntty_term_string_i(struct tty_term *term, enum tty_code_code code, int a)\n{\n\tconst char\t*x = tty_term_string(term, code), *s;\n\n#if defined(HAVE_TIPARM_S)\n\ts = tiparm_s(1, 0, x, a);\n#elif defined(HAVE_TIPARM)\n\ts = tiparm(x, a);\n#else\n\ts = tparm((char *)x, a, 0, 0, 0, 0, 0, 0, 0, 0);\n#endif\n\tif (s == NULL) {\n\t\tlog_debug(\"could not expand %s\", tty_term_codes[code].name);\n\t\treturn (\"\");\n\t}\n\treturn (s);\n}\n\nconst char *\ntty_term_string_ii(struct tty_term *term, enum tty_code_code code, int a, int b)\n{\n\tconst char\t*x = tty_term_string(term, code), *s;\n\n#if defined(HAVE_TIPARM_S)\n\ts = tiparm_s(2, 0, x, a, b);\n#elif defined(HAVE_TIPARM)\n\ts = tiparm(x, a, b);\n#else\n\ts = tparm((char *)x, a, b, 0, 0, 0, 0, 0, 0, 0);\n#endif\n\tif (s == NULL) {\n\t\tlog_debug(\"could not expand %s\", tty_term_codes[code].name);\n\t\treturn (\"\");\n\t}\n\treturn (s);\n}\n\nconst char *\ntty_term_string_iii(struct tty_term *term, enum tty_code_code code, int a,\n    int b, int c)\n{\n\tconst char\t*x = tty_term_string(term, code), *s;\n\n#if defined(HAVE_TIPARM_S)\n\ts = tiparm_s(3, 0, x, a, b, c);\n#elif defined(HAVE_TIPARM)\n\ts = tiparm(x, a, b, c);\n#else\n\ts = tparm((char *)x, a, b, c, 0, 0, 0, 0, 0, 0);\n#endif\n\tif (s == NULL) {\n\t\tlog_debug(\"could not expand %s\", tty_term_codes[code].name);\n\t\treturn (\"\");\n\t}\n\treturn (s);\n}\n\nconst char *\ntty_term_string_s(struct tty_term *term, enum tty_code_code code, const char *a)\n{\n\tconst char\t*x = tty_term_string(term, code), *s;\n\n#if defined(HAVE_TIPARM_S)\n\ts = tiparm_s(1, 1, x, a);\n#elif defined(HAVE_TIPARM)\n\ts = tiparm(x, a);\n#else\n\ts = tparm((char *)x, (long)a, 0, 0, 0, 0, 0, 0, 0, 0);\n#endif\n\tif (s == NULL) {\n\t\tlog_debug(\"could not expand %s\", tty_term_codes[code].name);\n\t\treturn (\"\");\n\t}\n\treturn (s);\n}\n\nconst char *\ntty_term_string_ss(struct tty_term *term, enum tty_code_code code,\n    const char *a, const char *b)\n{\n\tconst char\t*x = tty_term_string(term, code), *s;\n\n#if defined(HAVE_TIPARM_S)\n\ts = tiparm_s(2, 3, x, a, b);\n#elif defined(HAVE_TIPARM)\n\ts = tiparm(x, a, b);\n#else\n\ts = tparm((char *)x, (long)a, (long)b, 0, 0, 0, 0, 0, 0, 0);\n#endif\n\tif (s == NULL) {\n\t\tlog_debug(\"could not expand %s\", tty_term_codes[code].name);\n\t\treturn (\"\");\n\t}\n\treturn (s);\n}\n\nint\ntty_term_number(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (0);\n\tif (term->codes[code].type != TTYCODE_NUMBER)\n\t\tfatalx(\"not a number: %d\", code);\n\treturn (term->codes[code].value.number);\n}\n\nint\ntty_term_flag(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (0);\n\tif (term->codes[code].type != TTYCODE_FLAG)\n\t\tfatalx(\"not a flag: %d\", code);\n\treturn (term->codes[code].value.flag);\n}\n\nconst char *\ntty_term_describe(struct tty_term *term, enum tty_code_code code)\n{\n\tstatic char\t s[256];\n\tchar\t\t out[128];\n\n\tswitch (term->codes[code].type) {\n\tcase TTYCODE_NONE:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: [missing]\",\n\t\t    code, tty_term_codes[code].name);\n\t\tbreak;\n\tcase TTYCODE_STRING:\n\t\tstrnvis(out, term->codes[code].value.string, sizeof out,\n\t\t    VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL);\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (string) %s\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    out);\n\t\tbreak;\n\tcase TTYCODE_NUMBER:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (number) %d\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    term->codes[code].value.number);\n\t\tbreak;\n\tcase TTYCODE_FLAG:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (flag) %s\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    term->codes[code].value.flag ? \"true\" : \"false\");\n\t\tbreak;\n\t}\n\treturn (s);\n}\n"
        },
        {
          "name": "tty.c",
          "type": "blob",
          "size": 77.564453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n\n#include <netinet/in.h>\n\n#include <curses.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic int\ttty_log_fd = -1;\n\nstatic void\ttty_set_italics(struct tty *);\nstatic int\ttty_try_colour(struct tty *, int, const char *);\nstatic void\ttty_force_cursor_colour(struct tty *, int);\nstatic void\ttty_cursor_pane(struct tty *, const struct tty_ctx *, u_int,\n\t\t    u_int);\nstatic void\ttty_cursor_pane_unless_wrap(struct tty *,\n\t\t    const struct tty_ctx *, u_int, u_int);\nstatic void\ttty_colours(struct tty *, const struct grid_cell *);\nstatic void\ttty_check_fg(struct tty *, struct colour_palette *,\n    \t\t    struct grid_cell *);\nstatic void\ttty_check_bg(struct tty *, struct colour_palette *,\n    \t\t    struct grid_cell *);\nstatic void\ttty_check_us(struct tty *, struct colour_palette *,\n    \t\t    struct grid_cell *);\nstatic void\ttty_colours_fg(struct tty *, const struct grid_cell *);\nstatic void\ttty_colours_bg(struct tty *, const struct grid_cell *);\nstatic void\ttty_colours_us(struct tty *, const struct grid_cell *);\n\nstatic void\ttty_region_pane(struct tty *, const struct tty_ctx *, u_int,\n\t\t    u_int);\nstatic void\ttty_region(struct tty *, u_int, u_int);\nstatic void\ttty_margin_pane(struct tty *, const struct tty_ctx *);\nstatic void\ttty_margin(struct tty *, u_int, u_int);\nstatic int\ttty_large_region(struct tty *, const struct tty_ctx *);\nstatic int\ttty_fake_bce(const struct tty *, const struct grid_cell *,\n\t\t    u_int);\nstatic void\ttty_redraw_region(struct tty *, const struct tty_ctx *);\nstatic void\ttty_emulate_repeat(struct tty *, enum tty_code_code,\n\t\t    enum tty_code_code, u_int);\nstatic void\ttty_repeat_space(struct tty *, u_int);\nstatic void\ttty_draw_pane(struct tty *, const struct tty_ctx *, u_int);\nstatic void\ttty_default_attributes(struct tty *, const struct grid_cell *,\n\t\t    struct colour_palette *, u_int, struct hyperlinks *);\nstatic int\ttty_check_overlay(struct tty *, u_int, u_int);\nstatic void\ttty_check_overlay_range(struct tty *, u_int, u_int, u_int,\n\t\t    struct overlay_ranges *);\n\n#ifdef ENABLE_SIXEL\nstatic void\ttty_write_one(void (*)(struct tty *, const struct tty_ctx *),\n\t\t    struct client *, struct tty_ctx *);\n#endif\n\n#define tty_use_margin(tty) \\\n\t(tty->term->flags & TERM_DECSLRM)\n#define tty_full_width(tty, ctx) \\\n\t((ctx)->xoff == 0 && (ctx)->sx >= (tty)->sx)\n\n#define TTY_BLOCK_INTERVAL (100000 /* 100 milliseconds */)\n#define TTY_BLOCK_START(tty) (1 + ((tty)->sx * (tty)->sy) * 8)\n#define TTY_BLOCK_STOP(tty) (1 + ((tty)->sx * (tty)->sy) / 8)\n\n#define TTY_QUERY_TIMEOUT 5\n#define TTY_REQUEST_LIMIT 30\n\nvoid\ntty_create_log(void)\n{\n\tchar\tname[64];\n\n\txsnprintf(name, sizeof name, \"tmux-out-%ld.log\", (long)getpid());\n\n\ttty_log_fd = open(name, O_WRONLY|O_CREAT|O_TRUNC, 0644);\n\tif (tty_log_fd != -1 && fcntl(tty_log_fd, F_SETFD, FD_CLOEXEC) == -1)\n\t\tfatal(\"fcntl failed\");\n}\n\nint\ntty_init(struct tty *tty, struct client *c)\n{\n\tif (!isatty(c->fd))\n\t\treturn (-1);\n\n\tmemset(tty, 0, sizeof *tty);\n\ttty->client = c;\n\n\ttty->cstyle = SCREEN_CURSOR_DEFAULT;\n\ttty->ccolour = -1;\n\ttty->fg = tty->bg = -1;\n\n\tif (tcgetattr(c->fd, &tty->tio) != 0)\n\t\treturn (-1);\n\treturn (0);\n}\n\nvoid\ntty_resize(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\tstruct winsize\t ws;\n\tu_int\t\t sx, sy, xpixel, ypixel;\n\n\tif (ioctl(c->fd, TIOCGWINSZ, &ws) != -1) {\n\t\tsx = ws.ws_col;\n\t\tif (sx == 0) {\n\t\t\tsx = 80;\n\t\t\txpixel = 0;\n\t\t} else\n\t\t\txpixel = ws.ws_xpixel / sx;\n\t\tsy = ws.ws_row;\n\t\tif (sy == 0) {\n\t\t\tsy = 24;\n\t\t\typixel = 0;\n\t\t} else\n\t\t\typixel = ws.ws_ypixel / sy;\n\n\t\tif ((xpixel == 0 || ypixel == 0) &&\n\t\t    tty->out != NULL &&\n\t\t    !(tty->flags & TTY_WINSIZEQUERY) &&\n\t\t    (tty->term->flags & TERM_VT100LIKE)) {\n\t\t\ttty_puts(tty, \"\\033[18t\\033[14t\");\n\t\t\ttty->flags |= TTY_WINSIZEQUERY;\n\t\t}\n\t} else {\n\t\tsx = 80;\n\t\tsy = 24;\n\t\txpixel = 0;\n\t\typixel = 0;\n\t}\n\tlog_debug(\"%s: %s now %ux%u (%ux%u)\", __func__, c->name, sx, sy,\n\t    xpixel, ypixel);\n\ttty_set_size(tty, sx, sy, xpixel, ypixel);\n\ttty_invalidate(tty);\n}\n\nvoid\ntty_set_size(struct tty *tty, u_int sx, u_int sy, u_int xpixel, u_int ypixel)\n{\n\ttty->sx = sx;\n\ttty->sy = sy;\n\ttty->xpixel = xpixel;\n\ttty->ypixel = ypixel;\n}\n\nstatic void\ntty_read_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\tstruct client\t*c = tty->client;\n\tconst char\t*name = c->name;\n\tsize_t\t\t size = EVBUFFER_LENGTH(tty->in);\n\tint\t\t nread;\n\n\tnread = evbuffer_read(tty->in, c->fd, -1);\n\tif (nread == 0 || nread == -1) {\n\t\tif (nread == 0)\n\t\t\tlog_debug(\"%s: read closed\", name);\n\t\telse\n\t\t\tlog_debug(\"%s: read error: %s\", name, strerror(errno));\n\t\tevent_del(&tty->event_in);\n\t\tserver_client_lost(tty->client);\n\t\treturn;\n\t}\n\tlog_debug(\"%s: read %d bytes (already %zu)\", name, nread, size);\n\n\twhile (tty_keys_next(tty))\n\t\t;\n}\n\nstatic void\ntty_timer_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\tstruct client\t*c = tty->client;\n\tstruct timeval\t tv = { .tv_usec = TTY_BLOCK_INTERVAL };\n\n\tlog_debug(\"%s: %zu discarded\", c->name, tty->discarded);\n\n\tc->flags |= CLIENT_ALLREDRAWFLAGS;\n\tc->discarded += tty->discarded;\n\n\tif (tty->discarded < TTY_BLOCK_STOP(tty)) {\n\t\ttty->flags &= ~TTY_BLOCK;\n\t\ttty_invalidate(tty);\n\t\treturn;\n\t}\n\ttty->discarded = 0;\n\tevtimer_add(&tty->timer, &tv);\n}\n\nstatic int\ntty_block_maybe(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\tsize_t\t\t size = EVBUFFER_LENGTH(tty->out);\n\tstruct timeval\t tv = { .tv_usec = TTY_BLOCK_INTERVAL };\n\n\tif (size == 0)\n\t\ttty->flags &= ~TTY_NOBLOCK;\n\telse if (tty->flags & TTY_NOBLOCK)\n\t\treturn (0);\n\n\tif (size < TTY_BLOCK_START(tty))\n\t\treturn (0);\n\n\tif (tty->flags & TTY_BLOCK)\n\t\treturn (1);\n\ttty->flags |= TTY_BLOCK;\n\n\tlog_debug(\"%s: can't keep up, %zu discarded\", c->name, size);\n\n\tevbuffer_drain(tty->out, size);\n\tc->discarded += size;\n\n\ttty->discarded = 0;\n\tevtimer_add(&tty->timer, &tv);\n\treturn (1);\n}\n\nstatic void\ntty_write_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\tstruct client\t*c = tty->client;\n\tsize_t\t\t size = EVBUFFER_LENGTH(tty->out);\n\tint\t\t nwrite;\n\n\tnwrite = evbuffer_write(tty->out, c->fd);\n\tif (nwrite == -1)\n\t\treturn;\n\tlog_debug(\"%s: wrote %d bytes (of %zu)\", c->name, nwrite, size);\n\n\tif (c->redraw > 0) {\n\t\tif ((size_t)nwrite >= c->redraw)\n\t\t\tc->redraw = 0;\n\t\telse\n\t\t\tc->redraw -= nwrite;\n\t\tlog_debug(\"%s: waiting for redraw, %zu bytes left\", c->name,\n\t\t    c->redraw);\n\t} else if (tty_block_maybe(tty))\n\t\treturn;\n\n\tif (EVBUFFER_LENGTH(tty->out) != 0)\n\t\tevent_add(&tty->event_out, NULL);\n}\n\nint\ntty_open(struct tty *tty, char **cause)\n{\n\tstruct client\t*c = tty->client;\n\n\ttty->term = tty_term_create(tty, c->term_name, c->term_caps,\n\t    c->term_ncaps, &c->term_features, cause);\n\tif (tty->term == NULL) {\n\t\ttty_close(tty);\n\t\treturn (-1);\n\t}\n\ttty->flags |= TTY_OPENED;\n\n\ttty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_BLOCK|TTY_TIMER);\n\n\tevent_set(&tty->event_in, c->fd, EV_PERSIST|EV_READ,\n\t    tty_read_callback, tty);\n\ttty->in = evbuffer_new();\n\tif (tty->in == NULL)\n\t\tfatal(\"out of memory\");\n\n\tevent_set(&tty->event_out, c->fd, EV_WRITE, tty_write_callback, tty);\n\ttty->out = evbuffer_new();\n\tif (tty->out == NULL)\n\t\tfatal(\"out of memory\");\n\n\tevtimer_set(&tty->timer, tty_timer_callback, tty);\n\n\ttty_start_tty(tty);\n\ttty_keys_build(tty);\n\n\treturn (0);\n}\n\nstatic void\ntty_start_timer_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\tstruct client\t*c = tty->client;\n\n\tlog_debug(\"%s: start timer fired\", c->name);\n\tif ((tty->flags & (TTY_HAVEDA|TTY_HAVEDA2|TTY_HAVEXDA)) == 0)\n\t\ttty_update_features(tty);\n\ttty->flags |= TTY_ALL_REQUEST_FLAGS;\n}\n\nvoid\ntty_start_tty(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\tstruct termios\t tio;\n\tstruct timeval\t tv = { .tv_sec = TTY_QUERY_TIMEOUT };\n\n\tsetblocking(c->fd, 0);\n\tevent_add(&tty->event_in, NULL);\n\n\tmemcpy(&tio, &tty->tio, sizeof tio);\n\ttio.c_iflag &= ~(IXON|IXOFF|ICRNL|INLCR|IGNCR|IMAXBEL|ISTRIP);\n\ttio.c_iflag |= IGNBRK;\n\ttio.c_oflag &= ~(OPOST|ONLCR|OCRNL|ONLRET);\n\ttio.c_lflag &= ~(IEXTEN|ICANON|ECHO|ECHOE|ECHONL|ECHOCTL|ECHOPRT|\n\t    ECHOKE|ISIG);\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(c->fd, TCSANOW, &tio) == 0)\n\t\ttcflush(c->fd, TCOFLUSH);\n\n\ttty_putcode(tty, TTYC_SMCUP);\n\n\ttty_putcode(tty, TTYC_SMKX);\n\ttty_putcode(tty, TTYC_CLEAR);\n\n\tif (tty_acs_needed(tty)) {\n\t\tlog_debug(\"%s: using capabilities for ACS\", c->name);\n\t\ttty_putcode(tty, TTYC_ENACS);\n\t} else\n\t\tlog_debug(\"%s: using UTF-8 for ACS\", c->name);\n\n\ttty_putcode(tty, TTYC_CNORM);\n\tif (tty_term_has(tty->term, TTYC_KMOUS)) {\n\t\ttty_puts(tty, \"\\033[?1000l\\033[?1002l\\033[?1003l\");\n\t\ttty_puts(tty, \"\\033[?1006l\\033[?1005l\");\n\t}\n\tif (tty_term_has(tty->term, TTYC_ENBP))\n\t\ttty_putcode(tty, TTYC_ENBP);\n\n\tevtimer_set(&tty->start_timer, tty_start_timer_callback, tty);\n\tevtimer_add(&tty->start_timer, &tv);\n\n\ttty->flags |= TTY_STARTED;\n\ttty_invalidate(tty);\n\n\tif (tty->ccolour != -1)\n\t\ttty_force_cursor_colour(tty, -1);\n\n\ttty->mouse_drag_flag = 0;\n\ttty->mouse_drag_update = NULL;\n\ttty->mouse_drag_release = NULL;\n}\n\nvoid\ntty_send_requests(struct tty *tty)\n{\n\tif (~tty->flags & TTY_STARTED)\n\t\treturn;\n\n\tif (tty->term->flags & TERM_VT100LIKE) {\n\t\tif (~tty->term->flags & TTY_HAVEDA)\n\t\t\ttty_puts(tty, \"\\033[c\");\n\t\tif (~tty->flags & TTY_HAVEDA2)\n\t\t\ttty_puts(tty, \"\\033[>c\");\n\t\tif (~tty->flags & TTY_HAVEXDA)\n\t\t\ttty_puts(tty, \"\\033[>q\");\n\t\ttty_puts(tty, \"\\033]10;?\\033\\\\\");\n\t\ttty_puts(tty, \"\\033]11;?\\033\\\\\");\n\t} else\n\t\ttty->flags |= TTY_ALL_REQUEST_FLAGS;\n\ttty->last_requests = time(NULL);\n}\n\nvoid\ntty_repeat_requests(struct tty *tty)\n{\n\ttime_t\tt = time(NULL);\n\n\tif (~tty->flags & TTY_STARTED)\n\t\treturn;\n\n\tif (t - tty->last_requests <= TTY_REQUEST_LIMIT)\n\t\treturn;\n\ttty->last_requests = t;\n\n\tif (tty->term->flags & TERM_VT100LIKE) {\n\t\ttty_puts(tty, \"\\033]10;?\\033\\\\\");\n\t\ttty_puts(tty, \"\\033]11;?\\033\\\\\");\n\t}\n}\n\nvoid\ntty_stop_tty(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\tstruct winsize\t ws;\n\n\tif (!(tty->flags & TTY_STARTED))\n\t\treturn;\n\ttty->flags &= ~TTY_STARTED;\n\n\tevtimer_del(&tty->start_timer);\n\n\tevent_del(&tty->timer);\n\ttty->flags &= ~TTY_BLOCK;\n\n\tevent_del(&tty->event_in);\n\tevent_del(&tty->event_out);\n\n\t/*\n\t * Be flexible about error handling and try not kill the server just\n\t * because the fd is invalid. Things like ssh -t can easily leave us\n\t * with a dead tty.\n\t */\n\tif (ioctl(c->fd, TIOCGWINSZ, &ws) == -1)\n\t\treturn;\n\tif (tcsetattr(c->fd, TCSANOW, &tty->tio) == -1)\n\t\treturn;\n\n\ttty_raw(tty, tty_term_string_ii(tty->term, TTYC_CSR, 0, ws.ws_row - 1));\n\tif (tty_acs_needed(tty))\n\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMACS));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_SGR0));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMKX));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_CLEAR));\n\tif (tty->cstyle != SCREEN_CURSOR_DEFAULT) {\n\t\tif (tty_term_has(tty->term, TTYC_SE))\n\t\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_SE));\n\t\telse if (tty_term_has(tty->term, TTYC_SS))\n\t\t\ttty_raw(tty, tty_term_string_i(tty->term, TTYC_SS, 0));\n\t}\n\tif (tty->ccolour != -1)\n\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_CR));\n\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_CNORM));\n\tif (tty_term_has(tty->term, TTYC_KMOUS)) {\n\t\ttty_raw(tty, \"\\033[?1000l\\033[?1002l\\033[?1003l\");\n\t\ttty_raw(tty, \"\\033[?1006l\\033[?1005l\");\n\t}\n\tif (tty_term_has(tty->term, TTYC_DSBP))\n\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_DSBP));\n\n\tif (tty->term->flags & TERM_VT100LIKE)\n\t\ttty_raw(tty, \"\\033[?7727l\");\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_DSFCS));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_DSEKS));\n\n\tif (tty_use_margin(tty))\n\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_DSMG));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMCUP));\n\n\tsetblocking(c->fd, 1);\n}\n\nvoid\ntty_close(struct tty *tty)\n{\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\ttty_stop_tty(tty);\n\n\tif (tty->flags & TTY_OPENED) {\n\t\tevbuffer_free(tty->in);\n\t\tevent_del(&tty->event_in);\n\t\tevbuffer_free(tty->out);\n\t\tevent_del(&tty->event_out);\n\n\t\ttty_term_free(tty->term);\n\t\ttty_keys_free(tty);\n\n\t\ttty->flags &= ~TTY_OPENED;\n\t}\n}\n\nvoid\ntty_free(struct tty *tty)\n{\n\ttty_close(tty);\n}\n\nvoid\ntty_update_features(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (tty_apply_features(tty->term, c->term_features))\n\t\ttty_term_apply_overrides(tty->term);\n\n\tif (tty_use_margin(tty))\n\t\ttty_putcode(tty, TTYC_ENMG);\n\tif (options_get_number(global_options, \"extended-keys\"))\n\t\ttty_puts(tty, tty_term_string(tty->term, TTYC_ENEKS));\n\tif (options_get_number(global_options, \"focus-events\"))\n\t\ttty_puts(tty, tty_term_string(tty->term, TTYC_ENFCS));\n\tif (tty->term->flags & TERM_VT100LIKE)\n\t\ttty_puts(tty, \"\\033[?7727h\");\n\n\t/*\n\t * Features might have changed since the first draw during attach. For\n\t * example, this happens when DA responses are received.\n\t */\n\tserver_redraw_client(c);\n\n\ttty_invalidate(tty);\n}\n\nvoid\ntty_raw(struct tty *tty, const char *s)\n{\n\tstruct client\t*c = tty->client;\n\tssize_t\t\t n, slen;\n\tu_int\t\t i;\n\n\tslen = strlen(s);\n\tfor (i = 0; i < 5; i++) {\n\t\tn = write(c->fd, s, slen);\n\t\tif (n >= 0) {\n\t\t\ts += n;\n\t\t\tslen -= n;\n\t\t\tif (slen == 0)\n\t\t\t\tbreak;\n\t\t} else if (n == -1 && errno != EAGAIN)\n\t\t\tbreak;\n\t\tusleep(100);\n\t}\n}\n\nvoid\ntty_putcode(struct tty *tty, enum tty_code_code code)\n{\n\ttty_puts(tty, tty_term_string(tty->term, code));\n}\n\nvoid\ntty_putcode_i(struct tty *tty, enum tty_code_code code, int a)\n{\n\tif (a < 0)\n\t\treturn;\n\ttty_puts(tty, tty_term_string_i(tty->term, code, a));\n}\n\nvoid\ntty_putcode_ii(struct tty *tty, enum tty_code_code code, int a, int b)\n{\n\tif (a < 0 || b < 0)\n\t\treturn;\n\ttty_puts(tty, tty_term_string_ii(tty->term, code, a, b));\n}\n\nvoid\ntty_putcode_iii(struct tty *tty, enum tty_code_code code, int a, int b, int c)\n{\n\tif (a < 0 || b < 0 || c < 0)\n\t\treturn;\n\ttty_puts(tty, tty_term_string_iii(tty->term, code, a, b, c));\n}\n\nvoid\ntty_putcode_s(struct tty *tty, enum tty_code_code code, const char *a)\n{\n\tif (a != NULL)\n\t\ttty_puts(tty, tty_term_string_s(tty->term, code, a));\n}\n\nvoid\ntty_putcode_ss(struct tty *tty, enum tty_code_code code, const char *a,\n    const char *b)\n{\n\tif (a != NULL && b != NULL)\n\t\ttty_puts(tty, tty_term_string_ss(tty->term, code, a, b));\n}\n\nstatic void\ntty_add(struct tty *tty, const char *buf, size_t len)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (tty->flags & TTY_BLOCK) {\n\t\ttty->discarded += len;\n\t\treturn;\n\t}\n\n\tevbuffer_add(tty->out, buf, len);\n\tlog_debug(\"%s: %.*s\", c->name, (int)len, buf);\n\tc->written += len;\n\n\tif (tty_log_fd != -1)\n\t\twrite(tty_log_fd, buf, len);\n\tif (tty->flags & TTY_STARTED)\n\t\tevent_add(&tty->event_out, NULL);\n}\n\nvoid\ntty_puts(struct tty *tty, const char *s)\n{\n\tif (*s != '\\0')\n\t\ttty_add(tty, s, strlen(s));\n}\n\nvoid\ntty_putc(struct tty *tty, u_char ch)\n{\n\tconst char\t*acs;\n\n\tif ((tty->term->flags & TERM_NOAM) &&\n\t    ch >= 0x20 && ch != 0x7f &&\n\t    tty->cy == tty->sy - 1 &&\n\t    tty->cx + 1 >= tty->sx)\n\t\treturn;\n\n\tif (tty->cell.attr & GRID_ATTR_CHARSET) {\n\t\tacs = tty_acs_get(tty, ch);\n\t\tif (acs != NULL)\n\t\t\ttty_add(tty, acs, strlen(acs));\n\t\telse\n\t\t\ttty_add(tty, &ch, 1);\n\t} else\n\t\ttty_add(tty, &ch, 1);\n\n\tif (ch >= 0x20 && ch != 0x7f) {\n\t\tif (tty->cx >= tty->sx) {\n\t\t\ttty->cx = 1;\n\t\t\tif (tty->cy != tty->rlower)\n\t\t\t\ttty->cy++;\n\n\t\t\t/*\n\t\t\t * On !am terminals, force the cursor position to where\n\t\t\t * we think it should be after a line wrap - this means\n\t\t\t * it works on sensible terminals as well.\n\t\t\t */\n\t\t\tif (tty->term->flags & TERM_NOAM)\n\t\t\t\ttty_putcode_ii(tty, TTYC_CUP, tty->cy, tty->cx);\n\t\t} else\n\t\t\ttty->cx++;\n\t}\n}\n\nvoid\ntty_putn(struct tty *tty, const void *buf, size_t len, u_int width)\n{\n\tif ((tty->term->flags & TERM_NOAM) &&\n\t    tty->cy == tty->sy - 1 &&\n\t    tty->cx + len >= tty->sx)\n\t\tlen = tty->sx - tty->cx - 1;\n\n\ttty_add(tty, buf, len);\n\tif (tty->cx + width > tty->sx) {\n\t\ttty->cx = (tty->cx + width) - tty->sx;\n\t\tif (tty->cx <= tty->sx)\n\t\t\ttty->cy++;\n\t\telse\n\t\t\ttty->cx = tty->cy = UINT_MAX;\n\t} else\n\t\ttty->cx += width;\n}\n\nstatic void\ntty_set_italics(struct tty *tty)\n{\n\tconst char\t*s;\n\n\tif (tty_term_has(tty->term, TTYC_SITM)) {\n\t\ts = options_get_string(global_options, \"default-terminal\");\n\t\tif (strcmp(s, \"screen\") != 0 && strncmp(s, \"screen-\", 7) != 0) {\n\t\t\ttty_putcode(tty, TTYC_SITM);\n\t\t\treturn;\n\t\t}\n\t}\n\ttty_putcode(tty, TTYC_SMSO);\n}\n\nvoid\ntty_set_title(struct tty *tty, const char *title)\n{\n\tif (!tty_term_has(tty->term, TTYC_TSL) ||\n\t    !tty_term_has(tty->term, TTYC_FSL))\n\t\treturn;\n\n\ttty_putcode(tty, TTYC_TSL);\n\ttty_puts(tty, title);\n\ttty_putcode(tty, TTYC_FSL);\n}\n\nvoid\ntty_set_path(struct tty *tty, const char *title)\n{\n\tif (!tty_term_has(tty->term, TTYC_SWD) ||\n\t    !tty_term_has(tty->term, TTYC_FSL))\n\t\treturn;\n\n\ttty_putcode(tty, TTYC_SWD);\n\ttty_puts(tty, title);\n\ttty_putcode(tty, TTYC_FSL);\n}\n\nstatic void\ntty_force_cursor_colour(struct tty *tty, int c)\n{\n\tu_char\tr, g, b;\n\tchar\ts[13];\n\n\tif (c != -1)\n\t\tc = colour_force_rgb(c);\n\tif (c == tty->ccolour)\n\t\treturn;\n\tif (c == -1)\n\t\ttty_putcode(tty, TTYC_CR);\n\telse {\n\t\tcolour_split_rgb(c, &r, &g, &b);\n\t\txsnprintf(s, sizeof s, \"rgb:%02hhx/%02hhx/%02hhx\", r, g, b);\n\t\ttty_putcode_s(tty, TTYC_CS, s);\n\t}\n\ttty->ccolour = c;\n}\n\nstatic int\ntty_update_cursor(struct tty *tty, int mode, struct screen *s)\n{\n\tenum screen_cursor_style\tcstyle;\n\tint\t\t\t\tccolour, changed, cmode = mode;\n\n\t/* Set cursor colour if changed. */\n\tif (s != NULL) {\n\t\tccolour = s->ccolour;\n\t\tif (s->ccolour == -1)\n\t\t\tccolour = s->default_ccolour;\n\t\ttty_force_cursor_colour(tty, ccolour);\n\t}\n\n\t/* If cursor is off, set as invisible. */\n\tif (~cmode & MODE_CURSOR) {\n\t\tif (tty->mode & MODE_CURSOR)\n\t\t\ttty_putcode(tty, TTYC_CIVIS);\n\t\treturn (cmode);\n\t}\n\n\t/* Check if blinking or very visible flag changed or style changed. */\n\tif (s == NULL)\n\t\tcstyle = tty->cstyle;\n\telse {\n\t\tcstyle = s->cstyle;\n\t\tif (cstyle == SCREEN_CURSOR_DEFAULT) {\n\t\t\tif (~cmode & MODE_CURSOR_BLINKING_SET) {\n\t\t\t\tif (s->default_mode & MODE_CURSOR_BLINKING)\n\t\t\t\t\tcmode |= MODE_CURSOR_BLINKING;\n\t\t\t\telse\n\t\t\t\t\tcmode &= ~MODE_CURSOR_BLINKING;\n\t\t\t}\n\t\t\tcstyle = s->default_cstyle;\n\t\t}\n\t}\n\n\t/* If nothing changed, do nothing. */\n\tchanged = cmode ^ tty->mode;\n\tif ((changed & CURSOR_MODES) == 0 && cstyle == tty->cstyle)\n\t\treturn (cmode);\n\n\t/*\n\t * Set cursor style. If an explicit style has been set with DECSCUSR,\n\t * set it if supported, otherwise send cvvis for blinking styles.\n\t *\n\t * If no style, has been set (SCREEN_CURSOR_DEFAULT), then send cvvis\n\t * if either the blinking or very visible flags are set.\n\t */\n\ttty_putcode(tty, TTYC_CNORM);\n\tswitch (cstyle) {\n\tcase SCREEN_CURSOR_DEFAULT:\n\t\tif (tty->cstyle != SCREEN_CURSOR_DEFAULT) {\n\t\t\tif (tty_term_has(tty->term, TTYC_SE))\n\t\t\t\ttty_putcode(tty, TTYC_SE);\n\t\t\telse\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 0);\n\t\t}\n\t\tif (cmode & (MODE_CURSOR_BLINKING|MODE_CURSOR_VERY_VISIBLE))\n\t\t\ttty_putcode(tty, TTYC_CVVIS);\n\t\tbreak;\n\tcase SCREEN_CURSOR_BLOCK:\n\t\tif (tty_term_has(tty->term, TTYC_SS)) {\n\t\t\tif (cmode & MODE_CURSOR_BLINKING)\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 1);\n\t\t\telse\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 2);\n\t\t} else if (cmode & MODE_CURSOR_BLINKING)\n\t\t\ttty_putcode(tty, TTYC_CVVIS);\n\t\tbreak;\n\tcase SCREEN_CURSOR_UNDERLINE:\n\t\tif (tty_term_has(tty->term, TTYC_SS)) {\n\t\t\tif (cmode & MODE_CURSOR_BLINKING)\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 3);\n\t\t\telse\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 4);\n\t\t} else if (cmode & MODE_CURSOR_BLINKING)\n\t\t\ttty_putcode(tty, TTYC_CVVIS);\n\t\tbreak;\n\tcase SCREEN_CURSOR_BAR:\n\t\tif (tty_term_has(tty->term, TTYC_SS)) {\n\t\t\tif (cmode & MODE_CURSOR_BLINKING)\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 5);\n\t\t\telse\n\t\t\t\ttty_putcode_i(tty, TTYC_SS, 6);\n\t\t} else if (cmode & MODE_CURSOR_BLINKING)\n\t\t\ttty_putcode(tty, TTYC_CVVIS);\n\t\tbreak;\n\t}\n\ttty->cstyle = cstyle;\n\treturn (cmode);\n }\n\nvoid\ntty_update_mode(struct tty *tty, int mode, struct screen *s)\n{\n\tstruct tty_term\t*term = tty->term;\n\tstruct client\t*c = tty->client;\n\tint\t\t changed;\n\n\tif (tty->flags & TTY_NOCURSOR)\n\t\tmode &= ~MODE_CURSOR;\n\n\tif (tty_update_cursor(tty, mode, s) & MODE_CURSOR_BLINKING)\n\t\tmode |= MODE_CURSOR_BLINKING;\n\telse\n\t\tmode &= ~MODE_CURSOR_BLINKING;\n\n\tchanged = mode ^ tty->mode;\n\tif (log_get_level() != 0 && changed != 0) {\n\t\tlog_debug(\"%s: current mode %s\", c->name,\n\t\t    screen_mode_to_string(tty->mode));\n\t\tlog_debug(\"%s: setting mode %s\", c->name,\n\t\t    screen_mode_to_string(mode));\n\t}\n\n\tif ((changed & ALL_MOUSE_MODES) && tty_term_has(term, TTYC_KMOUS)) {\n\t\t/*\n\t\t * If the mouse modes have changed, clear then all and apply\n\t\t * again. There are differences in how terminals track the\n\t\t * various bits.\n\t\t */\n\t\ttty_puts(tty, \"\\033[?1006l\\033[?1000l\\033[?1002l\\033[?1003l\");\n\t\tif (mode & ALL_MOUSE_MODES)\n\t\t\ttty_puts(tty, \"\\033[?1006h\");\n\t\tif (mode & MODE_MOUSE_ALL)\n\t\t\ttty_puts(tty, \"\\033[?1000h\\033[?1002h\\033[?1003h\");\n\t\telse if (mode & MODE_MOUSE_BUTTON)\n\t\t\ttty_puts(tty, \"\\033[?1000h\\033[?1002h\");\n\t\telse if (mode & MODE_MOUSE_STANDARD)\n\t\t\ttty_puts(tty, \"\\033[?1000h\");\n\t}\n\ttty->mode = mode;\n}\n\nstatic void\ntty_emulate_repeat(struct tty *tty, enum tty_code_code code,\n    enum tty_code_code code1, u_int n)\n{\n\tif (tty_term_has(tty->term, code))\n\t\ttty_putcode_i(tty, code, n);\n\telse {\n\t\twhile (n-- > 0)\n\t\t\ttty_putcode(tty, code1);\n\t}\n}\n\nstatic void\ntty_repeat_space(struct tty *tty, u_int n)\n{\n\tstatic char s[500];\n\n\tif (*s != ' ')\n\t\tmemset(s, ' ', sizeof s);\n\n\twhile (n > sizeof s) {\n\t\ttty_putn(tty, s, sizeof s, sizeof s);\n\t\tn -= sizeof s;\n\t}\n\tif (n != 0)\n\t\ttty_putn(tty, s, n, n);\n}\n\n/* Is this window bigger than the terminal? */\nint\ntty_window_bigger(struct tty *tty)\n{\n\tstruct client\t*c = tty->client;\n\tstruct window\t*w = c->session->curw->window;\n\n\treturn (tty->sx < w->sx || tty->sy - status_line_size(c) < w->sy);\n}\n\n/* What offset should this window be drawn at? */\nint\ntty_window_offset(struct tty *tty, u_int *ox, u_int *oy, u_int *sx, u_int *sy)\n{\n\t*ox = tty->oox;\n\t*oy = tty->ooy;\n\t*sx = tty->osx;\n\t*sy = tty->osy;\n\n\treturn (tty->oflag);\n}\n\n/* What offset should this window be drawn at? */\nstatic int\ntty_window_offset1(struct tty *tty, u_int *ox, u_int *oy, u_int *sx, u_int *sy)\n{\n\tstruct client\t\t*c = tty->client;\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp = server_client_get_pane(c);\n\tu_int\t\t\t cx, cy, lines;\n\n\tlines = status_line_size(c);\n\n\tif (tty->sx >= w->sx && tty->sy - lines >= w->sy) {\n\t\t*ox = 0;\n\t\t*oy = 0;\n\t\t*sx = w->sx;\n\t\t*sy = w->sy;\n\n\t\tc->pan_window = NULL;\n\t\treturn (0);\n\t}\n\n\t*sx = tty->sx;\n\t*sy = tty->sy - lines;\n\n\tif (c->pan_window == w) {\n\t\tif (*sx >= w->sx)\n\t\t\tc->pan_ox = 0;\n\t\telse if (c->pan_ox + *sx > w->sx)\n\t\t\tc->pan_ox = w->sx - *sx;\n\t\t*ox = c->pan_ox;\n\t\tif (*sy >= w->sy)\n\t\t\tc->pan_oy = 0;\n\t\telse if (c->pan_oy + *sy > w->sy)\n\t\t\tc->pan_oy = w->sy - *sy;\n\t\t*oy = c->pan_oy;\n\t\treturn (1);\n\t}\n\n\tif (~wp->screen->mode & MODE_CURSOR) {\n\t\t*ox = 0;\n\t\t*oy = 0;\n\t} else {\n\t\tcx = wp->xoff + wp->screen->cx;\n\t\tcy = wp->yoff + wp->screen->cy;\n\n\t\tif (cx < *sx)\n\t\t\t*ox = 0;\n\t\telse if (cx > w->sx - *sx)\n\t\t\t*ox = w->sx - *sx;\n\t\telse\n\t\t\t*ox = cx - *sx / 2;\n\n\t\tif (cy < *sy)\n\t\t\t*oy = 0;\n\t\telse if (cy > w->sy - *sy)\n\t\t\t*oy = w->sy - *sy;\n\t\telse\n\t\t\t*oy = cy - *sy / 2;\n\t}\n\n\tc->pan_window = NULL;\n\treturn (1);\n}\n\n/* Update stored offsets for a window and redraw if necessary. */\nvoid\ntty_update_window_offset(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL &&\n\t\t    c->session->curw != NULL &&\n\t\t    c->session->curw->window == w)\n\t\t\ttty_update_client_offset(c);\n\t}\n}\n\n/* Update stored offsets for a client and redraw if necessary. */\nvoid\ntty_update_client_offset(struct client *c)\n{\n\tu_int\tox, oy, sx, sy;\n\n\tif (~c->flags & CLIENT_TERMINAL)\n\t\treturn;\n\n\tc->tty.oflag = tty_window_offset1(&c->tty, &ox, &oy, &sx, &sy);\n\tif (ox == c->tty.oox &&\n\t    oy == c->tty.ooy &&\n\t    sx == c->tty.osx &&\n\t    sy == c->tty.osy)\n\t\treturn;\n\n\tlog_debug (\"%s: %s offset has changed (%u,%u %ux%u -> %u,%u %ux%u)\",\n\t    __func__, c->name, c->tty.oox, c->tty.ooy, c->tty.osx, c->tty.osy,\n\t    ox, oy, sx, sy);\n\n\tc->tty.oox = ox;\n\tc->tty.ooy = oy;\n\tc->tty.osx = sx;\n\tc->tty.osy = sy;\n\n\tc->flags |= (CLIENT_REDRAWWINDOW|CLIENT_REDRAWSTATUS);\n}\n\n/*\n * Is the region large enough to be worth redrawing once later rather than\n * probably several times now? Currently yes if it is more than 50% of the\n * pane.\n */\nstatic int\ntty_large_region(__unused struct tty *tty, const struct tty_ctx *ctx)\n{\n\treturn (ctx->orlower - ctx->orupper >= ctx->sy / 2);\n}\n\n/*\n * Return if BCE is needed but the terminal doesn't have it - it'll need to be\n * emulated.\n */\nstatic int\ntty_fake_bce(const struct tty *tty, const struct grid_cell *gc, u_int bg)\n{\n\tif (tty_term_flag(tty->term, TTYC_BCE))\n\t\treturn (0);\n\tif (!COLOUR_DEFAULT(bg) || !COLOUR_DEFAULT(gc->bg))\n\t\treturn (1);\n\treturn (0);\n}\n\n/*\n * Redraw scroll region using data from screen (already updated). Used when\n * CSR not supported, or window is a pane that doesn't take up the full\n * width of the terminal.\n */\nstatic void\ntty_redraw_region(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t\t*c = tty->client;\n\tu_int\t\t\t i;\n\n\t/*\n\t * If region is large, schedule a redraw. In most cases this is likely\n\t * to be followed by some more scrolling.\n\t */\n\tif (tty_large_region(tty, ctx)) {\n\t\tlog_debug(\"%s: %s large redraw\", __func__, c->name);\n\t\tctx->redraw_cb(ctx);\n\t\treturn;\n\t}\n\n\tfor (i = ctx->orupper; i <= ctx->orlower; i++)\n\t\ttty_draw_pane(tty, ctx, i);\n}\n\n/* Is this position visible in the pane? */\nstatic int\ntty_is_visible(__unused struct tty *tty, const struct tty_ctx *ctx, u_int px,\n    u_int py, u_int nx, u_int ny)\n{\n\tu_int\txoff = ctx->rxoff + px, yoff = ctx->ryoff + py;\n\n\tif (!ctx->bigger)\n\t\treturn (1);\n\n\tif (xoff + nx <= ctx->wox || xoff >= ctx->wox + ctx->wsx ||\n\t    yoff + ny <= ctx->woy || yoff >= ctx->woy + ctx->wsy)\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Clamp line position to visible part of pane. */\nstatic int\ntty_clamp_line(struct tty *tty, const struct tty_ctx *ctx, u_int px, u_int py,\n    u_int nx, u_int *i, u_int *x, u_int *rx, u_int *ry)\n{\n\tu_int\txoff = ctx->rxoff + px;\n\n\tif (!tty_is_visible(tty, ctx, px, py, nx, 1))\n\t\treturn (0);\n\t*ry = ctx->yoff + py - ctx->woy;\n\n\tif (xoff >= ctx->wox && xoff + nx <= ctx->wox + ctx->wsx) {\n\t\t/* All visible. */\n\t\t*i = 0;\n\t\t*x = ctx->xoff + px - ctx->wox;\n\t\t*rx = nx;\n\t} else if (xoff < ctx->wox && xoff + nx > ctx->wox + ctx->wsx) {\n\t\t/* Both left and right not visible. */\n\t\t*i = ctx->wox;\n\t\t*x = 0;\n\t\t*rx = ctx->wsx;\n\t} else if (xoff < ctx->wox) {\n\t\t/* Left not visible. */\n\t\t*i = ctx->wox - (ctx->xoff + px);\n\t\t*x = 0;\n\t\t*rx = nx - *i;\n\t} else {\n\t\t/* Right not visible. */\n\t\t*i = 0;\n\t\t*x = (ctx->xoff + px) - ctx->wox;\n\t\t*rx = ctx->wsx - *x;\n\t}\n\tif (*rx > nx)\n\t\tfatalx(\"%s: x too big, %u > %u\", __func__, *rx, nx);\n\n\treturn (1);\n}\n\n/* Clear a line. */\nstatic void\ntty_clear_line(struct tty *tty, const struct grid_cell *defaults, u_int py,\n    u_int px, u_int nx, u_int bg)\n{\n\tstruct client\t\t*c = tty->client;\n\tstruct overlay_ranges\t r;\n\tu_int\t\t\t i;\n\n\tlog_debug(\"%s: %s, %u at %u,%u\", __func__, c->name, nx, px, py);\n\n\t/* Nothing to clear. */\n\tif (nx == 0)\n\t\treturn;\n\n\t/* If genuine BCE is available, can try escape sequences. */\n\tif (c->overlay_check == NULL && !tty_fake_bce(tty, defaults, bg)) {\n\t\t/* Off the end of the line, use EL if available. */\n\t\tif (px + nx >= tty->sx && tty_term_has(tty->term, TTYC_EL)) {\n\t\t\ttty_cursor(tty, px, py);\n\t\t\ttty_putcode(tty, TTYC_EL);\n\t\t\treturn;\n\t\t}\n\n\t\t/* At the start of the line. Use EL1. */\n\t\tif (px == 0 && tty_term_has(tty->term, TTYC_EL1)) {\n\t\t\ttty_cursor(tty, px + nx - 1, py);\n\t\t\ttty_putcode(tty, TTYC_EL1);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Section of line. Use ECH if possible. */\n\t\tif (tty_term_has(tty->term, TTYC_ECH)) {\n\t\t\ttty_cursor(tty, px, py);\n\t\t\ttty_putcode_i(tty, TTYC_ECH, nx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't use an escape sequence, use spaces. Clear only the visible\n\t * bit if there is an overlay.\n\t */\n\ttty_check_overlay_range(tty, px, py, nx, &r);\n\tfor (i = 0; i < OVERLAY_MAX_RANGES; i++) {\n\t\tif (r.nx[i] == 0)\n\t\t\tcontinue;\n\t\ttty_cursor(tty, r.px[i], py);\n\t\ttty_repeat_space(tty, r.nx[i]);\n\t}\n}\n\n/* Clear a line, adjusting to visible part of pane. */\nstatic void\ntty_clear_pane_line(struct tty *tty, const struct tty_ctx *ctx, u_int py,\n    u_int px, u_int nx, u_int bg)\n{\n\tstruct client\t*c = tty->client;\n\tu_int\t\t i, x, rx, ry;\n\n\tlog_debug(\"%s: %s, %u at %u,%u\", __func__, c->name, nx, px, py);\n\n\tif (tty_clamp_line(tty, ctx, px, py, nx, &i, &x, &rx, &ry))\n\t\ttty_clear_line(tty, &ctx->defaults, ry, x, rx, bg);\n}\n\n/* Clamp area position to visible part of pane. */\nstatic int\ntty_clamp_area(struct tty *tty, const struct tty_ctx *ctx, u_int px, u_int py,\n    u_int nx, u_int ny, u_int *i, u_int *j, u_int *x, u_int *y, u_int *rx,\n    u_int *ry)\n{\n\tu_int\txoff = ctx->rxoff + px, yoff = ctx->ryoff + py;\n\n\tif (!tty_is_visible(tty, ctx, px, py, nx, ny))\n\t\treturn (0);\n\n\tif (xoff >= ctx->wox && xoff + nx <= ctx->wox + ctx->wsx) {\n\t\t/* All visible. */\n\t\t*i = 0;\n\t\t*x = ctx->xoff + px - ctx->wox;\n\t\t*rx = nx;\n\t} else if (xoff < ctx->wox && xoff + nx > ctx->wox + ctx->wsx) {\n\t\t/* Both left and right not visible. */\n\t\t*i = ctx->wox;\n\t\t*x = 0;\n\t\t*rx = ctx->wsx;\n\t} else if (xoff < ctx->wox) {\n\t\t/* Left not visible. */\n\t\t*i = ctx->wox - (ctx->xoff + px);\n\t\t*x = 0;\n\t\t*rx = nx - *i;\n\t} else {\n\t\t/* Right not visible. */\n\t\t*i = 0;\n\t\t*x = (ctx->xoff + px) - ctx->wox;\n\t\t*rx = ctx->wsx - *x;\n\t}\n\tif (*rx > nx)\n\t\tfatalx(\"%s: x too big, %u > %u\", __func__, *rx, nx);\n\n\tif (yoff >= ctx->woy && yoff + ny <= ctx->woy + ctx->wsy) {\n\t\t/* All visible. */\n\t\t*j = 0;\n\t\t*y = ctx->yoff + py - ctx->woy;\n\t\t*ry = ny;\n\t} else if (yoff < ctx->woy && yoff + ny > ctx->woy + ctx->wsy) {\n\t\t/* Both top and bottom not visible. */\n\t\t*j = ctx->woy;\n\t\t*y = 0;\n\t\t*ry = ctx->wsy;\n\t} else if (yoff < ctx->woy) {\n\t\t/* Top not visible. */\n\t\t*j = ctx->woy - (ctx->yoff + py);\n\t\t*y = 0;\n\t\t*ry = ny - *j;\n\t} else {\n\t\t/* Bottom not visible. */\n\t\t*j = 0;\n\t\t*y = (ctx->yoff + py) - ctx->woy;\n\t\t*ry = ctx->wsy - *y;\n\t}\n\tif (*ry > ny)\n\t\tfatalx(\"%s: y too big, %u > %u\", __func__, *ry, ny);\n\n\treturn (1);\n}\n\n/* Clear an area, adjusting to visible part of pane. */\nstatic void\ntty_clear_area(struct tty *tty, const struct grid_cell *defaults, u_int py,\n    u_int ny, u_int px, u_int nx, u_int bg)\n{\n\tstruct client\t*c = tty->client;\n\tu_int\t\t yy;\n\tchar\t\t tmp[64];\n\n\tlog_debug(\"%s: %s, %u,%u at %u,%u\", __func__, c->name, nx, ny, px, py);\n\n\t/* Nothing to clear. */\n\tif (nx == 0 || ny == 0)\n\t\treturn;\n\n\t/* If genuine BCE is available, can try escape sequences. */\n\tif (c->overlay_check == NULL && !tty_fake_bce(tty, defaults, bg)) {\n\t\t/* Use ED if clearing off the bottom of the terminal. */\n\t\tif (px == 0 &&\n\t\t    px + nx >= tty->sx &&\n\t\t    py + ny >= tty->sy &&\n\t\t    tty_term_has(tty->term, TTYC_ED)) {\n\t\t\ttty_cursor(tty, 0, py);\n\t\t\ttty_putcode(tty, TTYC_ED);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * On VT420 compatible terminals we can use DECFRA if the\n\t\t * background colour isn't default (because it doesn't work\n\t\t * after SGR 0).\n\t\t */\n\t\tif ((tty->term->flags & TERM_DECFRA) && !COLOUR_DEFAULT(bg)) {\n\t\t\txsnprintf(tmp, sizeof tmp, \"\\033[32;%u;%u;%u;%u$x\",\n\t\t\t    py + 1, px + 1, py + ny, px + nx);\n\t\t\ttty_puts(tty, tmp);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Full lines can be scrolled away to clear them. */\n\t\tif (px == 0 &&\n\t\t    px + nx >= tty->sx &&\n\t\t    ny > 2 &&\n\t\t    tty_term_has(tty->term, TTYC_CSR) &&\n\t\t    tty_term_has(tty->term, TTYC_INDN)) {\n\t\t\ttty_region(tty, py, py + ny - 1);\n\t\t\ttty_margin_off(tty);\n\t\t\ttty_putcode_i(tty, TTYC_INDN, ny);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If margins are supported, can just scroll the area off to\n\t\t * clear it.\n\t\t */\n\t\tif (nx > 2 &&\n\t\t    ny > 2 &&\n\t\t    tty_term_has(tty->term, TTYC_CSR) &&\n\t\t    tty_use_margin(tty) &&\n\t\t    tty_term_has(tty->term, TTYC_INDN)) {\n\t\t\ttty_region(tty, py, py + ny - 1);\n\t\t\ttty_margin(tty, px, px + nx - 1);\n\t\t\ttty_putcode_i(tty, TTYC_INDN, ny);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Couldn't use an escape sequence, loop over the lines. */\n\tfor (yy = py; yy < py + ny; yy++)\n\t\ttty_clear_line(tty, defaults, yy, px, nx, bg);\n}\n\n/* Clear an area in a pane. */\nstatic void\ntty_clear_pane_area(struct tty *tty, const struct tty_ctx *ctx, u_int py,\n    u_int ny, u_int px, u_int nx, u_int bg)\n{\n\tu_int\ti, j, x, y, rx, ry;\n\n\tif (tty_clamp_area(tty, ctx, px, py, nx, ny, &i, &j, &x, &y, &rx, &ry))\n\t\ttty_clear_area(tty, &ctx->defaults, y, ry, x, rx, bg);\n}\n\nstatic void\ntty_draw_pane(struct tty *tty, const struct tty_ctx *ctx, u_int py)\n{\n\tstruct screen\t*s = ctx->s;\n\tu_int\t\t nx = ctx->sx, i, x, rx, ry;\n\n\tlog_debug(\"%s: %s %u %d\", __func__, tty->client->name, py, ctx->bigger);\n\n\tif (!ctx->bigger) {\n\t\ttty_draw_line(tty, s, 0, py, nx, ctx->xoff, ctx->yoff + py,\n\t\t    &ctx->defaults, ctx->palette);\n\t\treturn;\n\t}\n\tif (tty_clamp_line(tty, ctx, 0, py, nx, &i, &x, &rx, &ry)) {\n\t\ttty_draw_line(tty, s, i, py, rx, x, ry, &ctx->defaults,\n\t\t    ctx->palette);\n\t}\n}\n\nstatic const struct grid_cell *\ntty_check_codeset(struct tty *tty, const struct grid_cell *gc)\n{\n\tstatic struct grid_cell\tnew;\n\tint\t\t\tc;\n\n\t/* Characters less than 0x7f are always fine, no matter what. */\n\tif (gc->data.size == 1 && *gc->data.data < 0x7f)\n\t\treturn (gc);\n\tif (gc->flags & GRID_FLAG_TAB)\n\t\treturn (gc);\n\n\t/* UTF-8 terminal and a UTF-8 character - fine. */\n\tif (tty->client->flags & CLIENT_UTF8)\n\t\treturn (gc);\n\tmemcpy(&new, gc, sizeof new);\n\n\t/* See if this can be mapped to an ACS character. */\n\tc = tty_acs_reverse_get(tty, gc->data.data, gc->data.size);\n\tif (c != -1) {\n\t\tutf8_set(&new.data, c);\n\t\tnew.attr |= GRID_ATTR_CHARSET;\n\t\treturn (&new);\n\t}\n\n\t/* Replace by the right number of underscores. */\n\tnew.data.size = gc->data.width;\n\tif (new.data.size > UTF8_SIZE)\n\t\tnew.data.size = UTF8_SIZE;\n\tmemset(new.data.data, '_', new.data.size);\n\treturn (&new);\n}\n\n/*\n * Check if a single character is obstructed by the overlay and return a\n * boolean.\n */\nstatic int\ntty_check_overlay(struct tty *tty, u_int px, u_int py)\n{\n\tstruct overlay_ranges\tr;\n\n\t/*\n\t * A unit width range will always return nx[2] == 0 from a check, even\n\t * with multiple overlays, so it's sufficient to check just the first\n\t * two entries.\n\t */\n\ttty_check_overlay_range(tty, px, py, 1, &r);\n\tif (r.nx[0] + r.nx[1] == 0)\n\t\treturn (0);\n\treturn (1);\n}\n\n/* Return parts of the input range which are visible. */\nstatic void\ntty_check_overlay_range(struct tty *tty, u_int px, u_int py, u_int nx,\n    struct overlay_ranges *r)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (c->overlay_check == NULL) {\n\t\tr->px[0] = px;\n\t\tr->nx[0] = nx;\n\t\tr->px[1] = 0;\n\t\tr->nx[1] = 0;\n\t\tr->px[2] = 0;\n\t\tr->nx[2] = 0;\n\t\treturn;\n\t}\n\n\tc->overlay_check(c, c->overlay_data, px, py, nx, r);\n}\n\nvoid\ntty_draw_line(struct tty *tty, struct screen *s, u_int px, u_int py, u_int nx,\n    u_int atx, u_int aty, const struct grid_cell *defaults,\n    struct colour_palette *palette)\n{\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_cell\t gc, last;\n\tconst struct grid_cell\t*gcp;\n\tstruct grid_line\t*gl;\n\tstruct client\t\t*c = tty->client;\n\tstruct overlay_ranges\t r;\n\tu_int\t\t\t i, j, ux, sx, width, hidden, eux, nxx;\n\tu_int\t\t\t cellsize;\n\tint\t\t\t flags, cleared = 0, wrapped = 0;\n\tchar\t\t\t buf[512];\n\tsize_t\t\t\t len;\n\n\tlog_debug(\"%s: px=%u py=%u nx=%u atx=%u aty=%u\", __func__,\n\t    px, py, nx, atx, aty);\n\tlog_debug(\"%s: defaults: fg=%d, bg=%d\", __func__, defaults->fg,\n\t    defaults->bg);\n\n\t/*\n\t * py is the line in the screen to draw.\n\t * px is the start x and nx is the width to draw.\n\t * atx,aty is the line on the terminal to draw it.\n\t */\n\n\tflags = (tty->flags & TTY_NOCURSOR);\n\ttty->flags |= TTY_NOCURSOR;\n\ttty_update_mode(tty, tty->mode, s);\n\n\ttty_region_off(tty);\n\ttty_margin_off(tty);\n\n\t/*\n\t * Clamp the width to cellsize - note this is not cellused, because\n\t * there may be empty background cells after it (from BCE).\n\t */\n\tsx = screen_size_x(s);\n\tif (nx > sx)\n\t\tnx = sx;\n\tcellsize = grid_get_line(gd, gd->hsize + py)->cellsize;\n\tif (sx > cellsize)\n\t\tsx = cellsize;\n\tif (sx > tty->sx)\n\t\tsx = tty->sx;\n\tif (sx > nx)\n\t\tsx = nx;\n\tux = 0;\n\n\tif (py == 0)\n\t\tgl = NULL;\n\telse\n\t\tgl = grid_get_line(gd, gd->hsize + py - 1);\n\tif (gl == NULL ||\n\t    (~gl->flags & GRID_LINE_WRAPPED) ||\n\t    atx != 0 ||\n\t    tty->cx < tty->sx ||\n\t    nx < tty->sx) {\n\t\tif (nx < tty->sx &&\n\t\t    atx == 0 &&\n\t\t    px + sx != nx &&\n\t\t    tty_term_has(tty->term, TTYC_EL1) &&\n\t\t    !tty_fake_bce(tty, defaults, 8) &&\n\t\t    c->overlay_check == NULL) {\n\t\t\ttty_default_attributes(tty, defaults, palette, 8,\n\t\t\t    s->hyperlinks);\n\t\t\ttty_cursor(tty, nx - 1, aty);\n\t\t\ttty_putcode(tty, TTYC_EL1);\n\t\t\tcleared = 1;\n\t\t}\n\t} else {\n\t\tlog_debug(\"%s: wrapped line %u\", __func__, aty);\n\t\twrapped = 1;\n\t}\n\n\tmemcpy(&last, &grid_default_cell, sizeof last);\n\tlen = 0;\n\twidth = 0;\n\n\tfor (i = 0; i < sx; i++) {\n\t\tgrid_view_get_cell(gd, px + i, py, &gc);\n\t\tgcp = tty_check_codeset(tty, &gc);\n\t\tif (len != 0 &&\n\t\t    (!tty_check_overlay(tty, atx + ux + width, aty) ||\n\t\t    (gcp->attr & GRID_ATTR_CHARSET) ||\n\t\t    gcp->flags != last.flags ||\n\t\t    gcp->attr != last.attr ||\n\t\t    gcp->fg != last.fg ||\n\t\t    gcp->bg != last.bg ||\n\t\t    gcp->us != last.us ||\n\t\t    gcp->link != last.link ||\n\t\t    ux + width + gcp->data.width > nx ||\n\t\t    (sizeof buf) - len < gcp->data.size)) {\n\t\t\ttty_attributes(tty, &last, defaults, palette,\n\t\t\t    s->hyperlinks);\n\t\t\tif (last.flags & GRID_FLAG_CLEARED) {\n\t\t\t\tlog_debug(\"%s: %zu cleared\", __func__, len);\n\t\t\t\ttty_clear_line(tty, defaults, aty, atx + ux,\n\t\t\t\t    width, last.bg);\n\t\t\t} else {\n\t\t\t\tif (!wrapped || atx != 0 || ux != 0)\n\t\t\t\t\ttty_cursor(tty, atx + ux, aty);\n\t\t\t\ttty_putn(tty, buf, len, width);\n\t\t\t}\n\t\t\tux += width;\n\n\t\t\tlen = 0;\n\t\t\twidth = 0;\n\t\t\twrapped = 0;\n\t\t}\n\n\t\tif (gcp->flags & GRID_FLAG_SELECTED)\n\t\t\tscreen_select_cell(s, &last, gcp);\n\t\telse\n\t\t\tmemcpy(&last, gcp, sizeof last);\n\n\t\ttty_check_overlay_range(tty, atx + ux, aty, gcp->data.width,\n\t\t    &r);\n\t\thidden = 0;\n\t\tfor (j = 0; j < OVERLAY_MAX_RANGES; j++)\n\t\t\thidden += r.nx[j];\n\t\thidden = gcp->data.width - hidden;\n\t\tif (hidden != 0 && hidden == gcp->data.width) {\n\t\t\tif (~gcp->flags & GRID_FLAG_PADDING)\n\t\t\t\tux += gcp->data.width;\n\t\t} else if (hidden != 0 || ux + gcp->data.width > nx) {\n\t\t\tif (~gcp->flags & GRID_FLAG_PADDING) {\n\t\t\t\ttty_attributes(tty, &last, defaults, palette,\n\t\t\t\t    s->hyperlinks);\n\t\t\t\tfor (j = 0; j < OVERLAY_MAX_RANGES; j++) {\n\t\t\t\t\tif (r.nx[j] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/* Effective width drawn so far. */\n\t\t\t\t\teux = r.px[j] - atx;\n\t\t\t\t\tif (eux < nx) {\n\t\t\t\t\t\ttty_cursor(tty, r.px[j], aty);\n\t\t\t\t\t\tnxx = nx - eux;\n\t\t\t\t\t\tif (r.nx[j] > nxx)\n\t\t\t\t\t\t\tr.nx[j] = nxx;\n\t\t\t\t\t\ttty_repeat_space(tty, r.nx[j]);\n\t\t\t\t\t\tux = eux + r.nx[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (gcp->attr & GRID_ATTR_CHARSET) {\n\t\t\ttty_attributes(tty, &last, defaults, palette,\n\t\t\t    s->hyperlinks);\n\t\t\ttty_cursor(tty, atx + ux, aty);\n\t\t\tfor (j = 0; j < gcp->data.size; j++)\n\t\t\t\ttty_putc(tty, gcp->data.data[j]);\n\t\t\tux += gcp->data.width;\n\t\t} else if (~gcp->flags & GRID_FLAG_PADDING) {\n\t\t\tmemcpy(buf + len, gcp->data.data, gcp->data.size);\n\t\t\tlen += gcp->data.size;\n\t\t\twidth += gcp->data.width;\n\t\t}\n\t}\n\tif (len != 0 && ((~last.flags & GRID_FLAG_CLEARED) || last.bg != 8)) {\n\t\ttty_attributes(tty, &last, defaults, palette, s->hyperlinks);\n\t\tif (last.flags & GRID_FLAG_CLEARED) {\n\t\t\tlog_debug(\"%s: %zu cleared (end)\", __func__, len);\n\t\t\ttty_clear_line(tty, defaults, aty, atx + ux, width,\n\t\t\t    last.bg);\n\t\t} else {\n\t\t\tif (!wrapped || atx != 0 || ux != 0)\n\t\t\t\ttty_cursor(tty, atx + ux, aty);\n\t\t\ttty_putn(tty, buf, len, width);\n\t\t}\n\t\tux += width;\n\t}\n\n\tif (!cleared && ux < nx) {\n\t\tlog_debug(\"%s: %u to end of line (%zu cleared)\", __func__,\n\t\t    nx - ux, len);\n\t\ttty_default_attributes(tty, defaults, palette, 8,\n\t\t    s->hyperlinks);\n\t\ttty_clear_line(tty, defaults, aty, atx + ux, nx - ux, 8);\n\t}\n\n\ttty->flags = (tty->flags & ~TTY_NOCURSOR) | flags;\n\ttty_update_mode(tty, tty->mode, s);\n}\n\n#ifdef ENABLE_SIXEL\n/* Update context for client. */\nstatic int\ntty_set_client_cb(struct tty_ctx *ttyctx, struct client *c)\n{\n\tstruct window_pane\t*wp = ttyctx->arg;\n\n\tif (c->session->curw->window != wp->window)\n\t\treturn (0);\n\tif (wp->layout_cell == NULL)\n\t\treturn (0);\n\n\t/* Set the properties relevant to the current client. */\n\tttyctx->bigger = tty_window_offset(&c->tty, &ttyctx->wox, &ttyctx->woy,\n\t    &ttyctx->wsx, &ttyctx->wsy);\n\n\tttyctx->yoff = ttyctx->ryoff = wp->yoff;\n\tif (status_at_line(c) == 0)\n\t\tttyctx->yoff += status_line_size(c);\n\n\treturn (1);\n}\n\nvoid\ntty_draw_images(struct client *c, struct window_pane *wp, struct screen *s)\n{\n\tstruct image\t*im;\n\tstruct tty_ctx\t ttyctx;\n\n\tTAILQ_FOREACH(im, &s->images, entry) {\n\t\tmemset(&ttyctx, 0, sizeof ttyctx);\n\n\t\t/* Set the client independent properties. */\n\t\tttyctx.ocx = im->px;\n\t\tttyctx.ocy = im->py;\n\n\t\tttyctx.orlower = s->rlower;\n\t\tttyctx.orupper = s->rupper;\n\n\t\tttyctx.xoff = ttyctx.rxoff = wp->xoff;\n\t\tttyctx.sx = wp->sx;\n\t\tttyctx.sy = wp->sy;\n\n\t\tttyctx.ptr = im;\n\t\tttyctx.arg = wp;\n\t\tttyctx.set_client_cb = tty_set_client_cb;\n\t\tttyctx.allow_invisible_panes = 1;\n\t\ttty_write_one(tty_cmd_sixelimage, c, &ttyctx);\n\t}\n}\n#endif\n\nvoid\ntty_sync_start(struct tty *tty)\n{\n\tif (tty->flags & TTY_BLOCK)\n\t\treturn;\n\tif (tty->flags & TTY_SYNCING)\n\t\treturn;\n\ttty->flags |= TTY_SYNCING;\n\n\tif (tty_term_has(tty->term, TTYC_SYNC)) {\n\t\tlog_debug(\"%s sync start\", tty->client->name);\n\t\ttty_putcode_i(tty, TTYC_SYNC, 1);\n\t}\n}\n\nvoid\ntty_sync_end(struct tty *tty)\n{\n\tif (tty->flags & TTY_BLOCK)\n\t\treturn;\n\tif (~tty->flags & TTY_SYNCING)\n\t\treturn;\n\ttty->flags &= ~TTY_SYNCING;\n\n\tif (tty_term_has(tty->term, TTYC_SYNC)) {\n \t\tlog_debug(\"%s sync end\", tty->client->name);\n\t\ttty_putcode_i(tty, TTYC_SYNC, 2);\n\t}\n}\n\nstatic int\ntty_client_ready(const struct tty_ctx *ctx, struct client *c)\n{\n\tif (c->session == NULL || c->tty.term == NULL)\n\t\treturn (0);\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn (0);\n\n\t/*\n\t * If invisible panes are allowed (used for passthrough), don't care if\n\t * redrawing or frozen.\n\t */\n\tif (ctx->allow_invisible_panes)\n\t\treturn (1);\n\n\tif (c->flags & CLIENT_REDRAWWINDOW)\n\t\treturn (0);\n\tif (c->tty.flags & TTY_FREEZE)\n\t\treturn (0);\n\treturn (1);\n}\n\nvoid\ntty_write(void (*cmdfn)(struct tty *, const struct tty_ctx *),\n    struct tty_ctx *ctx)\n{\n\tstruct client\t*c;\n\tint\t\t state;\n\n\tif (ctx->set_client_cb == NULL)\n\t\treturn;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (tty_client_ready(ctx, c)) {\n\t\t\tstate = ctx->set_client_cb(ctx, c);\n\t\t\tif (state == -1)\n\t\t\t\tbreak;\n\t\t\tif (state == 0)\n\t\t\t\tcontinue;\n\t\t\tcmdfn(&c->tty, ctx);\n\t\t}\n\t}\n}\n\n#ifdef ENABLE_SIXEL\n/* Only write to the incoming tty instead of every client. */\nstatic void\ntty_write_one(void (*cmdfn)(struct tty *, const struct tty_ctx *),\n    struct client *c, struct tty_ctx *ctx)\n{\n\tif (ctx->set_client_cb == NULL)\n\t\treturn;\n\tif ((ctx->set_client_cb(ctx, c)) == 1)\n\t\tcmdfn(&c->tty, ctx);\n}\n#endif\n\nvoid\ntty_cmd_insertcharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->bigger ||\n\t    !tty_full_width(tty, ctx) ||\n\t    tty_fake_bce(tty, &ctx->defaults, ctx->bg) ||\n\t    (!tty_term_has(tty->term, TTYC_ICH) &&\n\t    !tty_term_has(tty->term, TTYC_ICH1)) ||\n\t    c->overlay_check != NULL) {\n\t\ttty_draw_pane(tty, ctx, ctx->ocy);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_ICH, TTYC_ICH1, ctx->num);\n}\n\nvoid\ntty_cmd_deletecharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->bigger ||\n\t    !tty_full_width(tty, ctx) ||\n\t    tty_fake_bce(tty, &ctx->defaults, ctx->bg) ||\n\t    (!tty_term_has(tty->term, TTYC_DCH) &&\n\t    !tty_term_has(tty->term, TTYC_DCH1)) ||\n\t    c->overlay_check != NULL) {\n\t\ttty_draw_pane(tty, ctx, ctx->ocy);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ctx->num);\n}\n\nvoid\ntty_cmd_clearcharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_clear_pane_line(tty, ctx, ctx->ocy, ctx->ocx, ctx->num, ctx->bg);\n}\n\nvoid\ntty_cmd_insertline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->bigger ||\n\t    !tty_full_width(tty, ctx) ||\n\t    tty_fake_bce(tty, &ctx->defaults, ctx->bg) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    !tty_term_has(tty->term, TTYC_IL1) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_off(tty);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_IL, TTYC_IL1, ctx->num);\n\ttty->cx = tty->cy = UINT_MAX;\n}\n\nvoid\ntty_cmd_deleteline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->bigger ||\n\t    !tty_full_width(tty, ctx) ||\n\t    tty_fake_bce(tty, &ctx->defaults, ctx->bg) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    !tty_term_has(tty->term, TTYC_DL1) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_off(tty);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_DL, TTYC_DL1, ctx->num);\n\ttty->cx = tty->cy = UINT_MAX;\n}\n\nvoid\ntty_cmd_clearline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_clear_pane_line(tty, ctx, ctx->ocy, 0, ctx->sx, ctx->bg);\n}\n\nvoid\ntty_cmd_clearendofline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\tnx = ctx->sx - ctx->ocx;\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_clear_pane_line(tty, ctx, ctx->ocy, ctx->ocx, nx, ctx->bg);\n}\n\nvoid\ntty_cmd_clearstartofline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_clear_pane_line(tty, ctx, ctx->ocy, 0, ctx->ocx + 1, ctx->bg);\n}\n\nvoid\ntty_cmd_reverseindex(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->ocy != ctx->orupper)\n\t\treturn;\n\n\tif (ctx->bigger ||\n\t    (!tty_full_width(tty, ctx) && !tty_use_margin(tty)) ||\n\t    tty_fake_bce(tty, &ctx->defaults, 8) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    (!tty_term_has(tty->term, TTYC_RI) &&\n\t    !tty_term_has(tty->term, TTYC_RIN)) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_pane(tty, ctx);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->orupper);\n\n\tif (tty_term_has(tty->term, TTYC_RI))\n\t\ttty_putcode(tty, TTYC_RI);\n\telse\n\t\ttty_putcode_i(tty, TTYC_RIN, 1);\n}\n\nvoid\ntty_cmd_linefeed(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->ocy != ctx->orlower)\n\t\treturn;\n\n\tif (ctx->bigger ||\n\t    (!tty_full_width(tty, ctx) && !tty_use_margin(tty)) ||\n\t    tty_fake_bce(tty, &ctx->defaults, 8) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_pane(tty, ctx);\n\n\t/*\n\t * If we want to wrap a pane while using margins, the cursor needs to\n\t * be exactly on the right of the region. If the cursor is entirely off\n\t * the edge - move it back to the right. Some terminals are funny about\n\t * this and insert extra spaces, so only use the right if margins are\n\t * enabled.\n\t */\n\tif (ctx->xoff + ctx->ocx > tty->rright) {\n\t\tif (!tty_use_margin(tty))\n\t\t\ttty_cursor(tty, 0, ctx->yoff + ctx->ocy);\n\t\telse\n\t\t\ttty_cursor(tty, tty->rright, ctx->yoff + ctx->ocy);\n\t} else\n\t\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_putc(tty, '\\n');\n}\n\nvoid\ntty_cmd_scrollup(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct client\t*c = tty->client;\n\tu_int\t\t i;\n\n\tif (ctx->bigger ||\n\t    (!tty_full_width(tty, ctx) && !tty_use_margin(tty)) ||\n\t    tty_fake_bce(tty, &ctx->defaults, 8) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_pane(tty, ctx);\n\n\tif (ctx->num == 1 || !tty_term_has(tty->term, TTYC_INDN)) {\n\t\tif (!tty_use_margin(tty))\n\t\t\ttty_cursor(tty, 0, tty->rlower);\n\t\telse\n\t\t\ttty_cursor(tty, tty->rright, tty->rlower);\n\t\tfor (i = 0; i < ctx->num; i++)\n\t\t\ttty_putc(tty, '\\n');\n\t} else {\n\t\tif (tty->cy == UINT_MAX)\n\t\t\ttty_cursor(tty, 0, 0);\n\t\telse\n\t\t\ttty_cursor(tty, 0, tty->cy);\n\t\ttty_putcode_i(tty, TTYC_INDN, ctx->num);\n\t}\n}\n\nvoid\ntty_cmd_scrolldown(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\t\t i;\n\tstruct client\t*c = tty->client;\n\n\tif (ctx->bigger ||\n\t    (!tty_full_width(tty, ctx) && !tty_use_margin(tty)) ||\n\t    tty_fake_bce(tty, &ctx->defaults, 8) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    (!tty_term_has(tty->term, TTYC_RI) &&\n\t    !tty_term_has(tty->term, TTYC_RIN)) ||\n\t    ctx->sx == 1 ||\n\t    ctx->sy == 1 ||\n\t    c->overlay_check != NULL) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_margin_pane(tty, ctx);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->orupper);\n\n\tif (tty_term_has(tty->term, TTYC_RIN))\n\t\ttty_putcode_i(tty, TTYC_RIN, ctx->num);\n\telse {\n\t\tfor (i = 0; i < ctx->num; i++)\n\t\t\ttty_putcode(tty, TTYC_RI);\n\t}\n}\n\nvoid\ntty_cmd_clearendofscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\tpx, py, nx, ny;\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, 0, ctx->sy - 1);\n\ttty_margin_off(tty);\n\n\tpx = 0;\n\tnx = ctx->sx;\n\tpy = ctx->ocy + 1;\n\tny = ctx->sy - ctx->ocy - 1;\n\n\ttty_clear_pane_area(tty, ctx, py, ny, px, nx, ctx->bg);\n\n\tpx = ctx->ocx;\n\tnx = ctx->sx - ctx->ocx;\n\tpy = ctx->ocy;\n\n\ttty_clear_pane_line(tty, ctx, py, px, nx, ctx->bg);\n}\n\nvoid\ntty_cmd_clearstartofscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\tpx, py, nx, ny;\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, 0, ctx->sy - 1);\n\ttty_margin_off(tty);\n\n\tpx = 0;\n\tnx = ctx->sx;\n\tpy = 0;\n\tny = ctx->ocy;\n\n\ttty_clear_pane_area(tty, ctx, py, ny, px, nx, ctx->bg);\n\n\tpx = 0;\n\tnx = ctx->ocx + 1;\n\tpy = ctx->ocy;\n\n\ttty_clear_pane_line(tty, ctx, py, px, nx, ctx->bg);\n}\n\nvoid\ntty_cmd_clearscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\tpx, py, nx, ny;\n\n\ttty_default_attributes(tty, &ctx->defaults, ctx->palette, ctx->bg,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, 0, ctx->sy - 1);\n\ttty_margin_off(tty);\n\n\tpx = 0;\n\tnx = ctx->sx;\n\tpy = 0;\n\tny = ctx->sy;\n\n\ttty_clear_pane_area(tty, ctx, py, ny, px, nx, ctx->bg);\n}\n\nvoid\ntty_cmd_alignmenttest(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\ti, j;\n\n\tif (ctx->bigger) {\n\t\tctx->redraw_cb(ctx);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, &ctx->defaults, ctx->palette,\n\t    ctx->s->hyperlinks);\n\n\ttty_region_pane(tty, ctx, 0, ctx->sy - 1);\n\ttty_margin_off(tty);\n\n\tfor (j = 0; j < ctx->sy; j++) {\n\t\ttty_cursor_pane(tty, ctx, 0, j);\n\t\tfor (i = 0; i < ctx->sx; i++)\n\t\t\ttty_putc(tty, 'E');\n\t}\n}\n\nvoid\ntty_cmd_cell(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tconst struct grid_cell\t*gcp = ctx->cell;\n\tstruct screen\t\t*s = ctx->s;\n\tstruct overlay_ranges\t r;\n\tu_int\t\t\t px, py, i, vis = 0;\n\n\tpx = ctx->xoff + ctx->ocx - ctx->wox;\n\tpy = ctx->yoff + ctx->ocy - ctx->woy;\n\tif (!tty_is_visible(tty, ctx, ctx->ocx, ctx->ocy, 1, 1) ||\n\t    (gcp->data.width == 1 && !tty_check_overlay(tty, px, py)))\n\t\treturn;\n\n\t/* Handle partially obstructed wide characters. */\n\tif (gcp->data.width > 1) {\n\t\ttty_check_overlay_range(tty, px, py, gcp->data.width, &r);\n\t\tfor (i = 0; i < OVERLAY_MAX_RANGES; i++)\n\t\t\tvis += r.nx[i];\n\t\tif (vis < gcp->data.width) {\n\t\t\ttty_draw_line(tty, s, s->cx, s->cy, gcp->data.width,\n\t\t\t    px, py, &ctx->defaults, ctx->palette);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ctx->xoff + ctx->ocx - ctx->wox > tty->sx - 1 &&\n\t    ctx->ocy == ctx->orlower &&\n\t    tty_full_width(tty, ctx))\n\t\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\n\ttty_margin_off(tty);\n\ttty_cursor_pane_unless_wrap(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_cell(tty, ctx->cell, &ctx->defaults, ctx->palette,\n\t    ctx->s->hyperlinks);\n\n\tif (ctx->num == 1)\n\t\ttty_invalidate(tty);\n}\n\nvoid\ntty_cmd_cells(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct overlay_ranges\t r;\n\tu_int\t\t\t i, px, py, cx;\n\tchar\t\t\t*cp = ctx->ptr;\n\n\tif (!tty_is_visible(tty, ctx, ctx->ocx, ctx->ocy, ctx->num, 1))\n\t\treturn;\n\n\tif (ctx->bigger &&\n\t    (ctx->xoff + ctx->ocx < ctx->wox ||\n\t    ctx->xoff + ctx->ocx + ctx->num > ctx->wox + ctx->wsx)) {\n\t\tif (!ctx->wrapped ||\n\t\t    !tty_full_width(tty, ctx) ||\n\t\t    (tty->term->flags & TERM_NOAM) ||\n\t\t    ctx->xoff + ctx->ocx != 0 ||\n\t\t    ctx->yoff + ctx->ocy != tty->cy + 1 ||\n\t\t    tty->cx < tty->sx ||\n\t\t    tty->cy == tty->rlower)\n\t\t\ttty_draw_pane(tty, ctx, ctx->ocy);\n\t\telse\n\t\t\tctx->redraw_cb(ctx);\n\t\treturn;\n\t}\n\n\ttty_margin_off(tty);\n\ttty_cursor_pane_unless_wrap(tty, ctx, ctx->ocx, ctx->ocy);\n\ttty_attributes(tty, ctx->cell, &ctx->defaults, ctx->palette, ctx->s->hyperlinks);\n\n\t/* Get tty position from pane position for overlay check. */\n\tpx = ctx->xoff + ctx->ocx - ctx->wox;\n\tpy = ctx->yoff + ctx->ocy - ctx->woy;\n\n\ttty_check_overlay_range(tty, px, py, ctx->num, &r);\n\tfor (i = 0; i < OVERLAY_MAX_RANGES; i++) {\n\t\tif (r.nx[i] == 0)\n\t\t\tcontinue;\n\t\t/* Convert back to pane position for printing. */\n\t\tcx = r.px[i] - ctx->xoff + ctx->wox;\n\t\ttty_cursor_pane_unless_wrap(tty, ctx, cx, ctx->ocy);\n\t\ttty_putn(tty, cp + r.px[i] - px, r.nx[i], r.nx[i]);\n\t}\n}\n\nvoid\ntty_cmd_setselection(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_set_selection(tty, ctx->ptr2, ctx->ptr, ctx->num);\n}\n\nvoid\ntty_set_selection(struct tty *tty, const char *flags, const char *buf,\n    size_t len)\n{\n\tchar\t*encoded;\n\tsize_t\t size;\n\n\tif (~tty->flags & TTY_STARTED)\n\t\treturn;\n\tif (!tty_term_has(tty->term, TTYC_MS))\n\t\treturn;\n\n\tsize = 4 * ((len + 2) / 3) + 1; /* storage for base64 */\n\tencoded = xmalloc(size);\n\n\tb64_ntop(buf, len, encoded, size);\n\ttty->flags |= TTY_NOBLOCK;\n\ttty_putcode_ss(tty, TTYC_MS, flags, encoded);\n\n\tfree(encoded);\n}\n\nvoid\ntty_cmd_rawstring(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty->flags |= TTY_NOBLOCK;\n\ttty_add(tty, ctx->ptr, ctx->num);\n\ttty_invalidate(tty);\n}\n\n#ifdef ENABLE_SIXEL\nvoid\ntty_cmd_sixelimage(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct image\t\t*im = ctx->ptr;\n\tstruct sixel_image\t*si = im->data;\n\tstruct sixel_image\t*new;\n\tchar\t\t\t*data;\n\tsize_t\t\t\t size;\n\tu_int\t\t\t cx = ctx->ocx, cy = ctx->ocy, sx, sy;\n\tu_int\t\t\t i, j, x, y, rx, ry;\n\tint\t\t\t fallback = 0;\n\n\tif ((~tty->term->flags & TERM_SIXEL) &&\n            !tty_term_has(tty->term, TTYC_SXL))\n\t\tfallback = 1;\n\tif (tty->xpixel == 0 || tty->ypixel == 0)\n\t\tfallback = 1;\n\n\tsixel_size_in_cells(si, &sx, &sy);\n\tlog_debug(\"%s: image is %ux%u\", __func__, sx, sy);\n\tif (!tty_clamp_area(tty, ctx, cx, cy, sx, sy, &i, &j, &x, &y, &rx, &ry))\n\t\treturn;\n\tlog_debug(\"%s: clamping to %u,%u-%u,%u\", __func__, i, j, rx, ry);\n\n\tif (fallback == 1) {\n\t\tdata = xstrdup(im->fallback);\n\t\tsize = strlen(data);\n\t} else {\n\t\tnew = sixel_scale(si, tty->xpixel, tty->ypixel, i, j, rx, ry, 0);\n\t\tif (new == NULL)\n\t\t\treturn;\n\n\t\tdata = sixel_print(new, si, &size);\n\t}\n\tif (data != NULL) {\n\t\tlog_debug(\"%s: %zu bytes: %s\", __func__, size, data);\n\t\ttty_region_off(tty);\n\t\ttty_margin_off(tty);\n\t\ttty_cursor(tty, x, y);\n\n\t\ttty->flags |= TTY_NOBLOCK;\n\t\ttty_add(tty, data, size);\n\t\ttty_invalidate(tty);\n\t\tfree(data);\n\t}\n\n\tif (fallback == 0)\n\t\tsixel_free(new);\n}\n#endif\n\nvoid\ntty_cmd_syncstart(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tif (ctx->num == 0x11) {\n\t\t/*\n\t\t * This is an overlay and a command that moves the cursor so\n\t\t * start synchronized updates.\n\t\t */\n\t\ttty_sync_start(tty);\n\t} else if (~ctx->num & 0x10) {\n\t\t/*\n\t\t * This is a pane. If there is an overlay, always start;\n\t\t * otherwise, only if requested.\n\t\t */\n\t\tif (ctx->num || tty->client->overlay_draw != NULL)\n\t\t\ttty_sync_start(tty);\n\t}\n}\n\nvoid\ntty_cell(struct tty *tty, const struct grid_cell *gc,\n    const struct grid_cell *defaults, struct colour_palette *palette,\n    struct hyperlinks *hl)\n{\n\tconst struct grid_cell\t*gcp;\n\n\t/* Skip last character if terminal is stupid. */\n\tif ((tty->term->flags & TERM_NOAM) &&\n\t    tty->cy == tty->sy - 1 &&\n\t    tty->cx == tty->sx - 1)\n\t\treturn;\n\n\t/* If this is a padding character, do nothing. */\n\tif (gc->flags & GRID_FLAG_PADDING)\n\t\treturn;\n\n\t/* Check the output codeset and apply attributes. */\n\tgcp = tty_check_codeset(tty, gc);\n\ttty_attributes(tty, gcp, defaults, palette, hl);\n\n\t/* If it is a single character, write with putc to handle ACS. */\n\tif (gcp->data.size == 1) {\n\t\ttty_attributes(tty, gcp, defaults, palette, hl);\n\t\tif (*gcp->data.data < 0x20 || *gcp->data.data == 0x7f)\n\t\t\treturn;\n\t\ttty_putc(tty, *gcp->data.data);\n\t\treturn;\n\t}\n\n\t/* Write the data. */\n\ttty_putn(tty, gcp->data.data, gcp->data.size, gcp->data.width);\n}\n\nvoid\ntty_reset(struct tty *tty)\n{\n\tstruct grid_cell\t*gc = &tty->cell;\n\n\tif (!grid_cells_equal(gc, &grid_default_cell)) {\n\t\tif (gc->link != 0)\n\t\t\ttty_putcode_ss(tty, TTYC_HLS, \"\", \"\");\n\t\tif ((gc->attr & GRID_ATTR_CHARSET) && tty_acs_needed(tty))\n\t\t\ttty_putcode(tty, TTYC_RMACS);\n\t\ttty_putcode(tty, TTYC_SGR0);\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t}\n\tmemcpy(&tty->last_cell, &grid_default_cell, sizeof tty->last_cell);\n}\n\nvoid\ntty_invalidate(struct tty *tty)\n{\n\tmemcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);\n\tmemcpy(&tty->last_cell, &grid_default_cell, sizeof tty->last_cell);\n\n\ttty->cx = tty->cy = UINT_MAX;\n\ttty->rupper = tty->rleft = UINT_MAX;\n\ttty->rlower = tty->rright = UINT_MAX;\n\n\tif (tty->flags & TTY_STARTED) {\n\t\tif (tty_use_margin(tty))\n\t\t\ttty_putcode(tty, TTYC_ENMG);\n\t\ttty_putcode(tty, TTYC_SGR0);\n\n\t\ttty->mode = ALL_MODES;\n\t\ttty_update_mode(tty, MODE_CURSOR, NULL);\n\n\t\ttty_cursor(tty, 0, 0);\n\t\ttty_region_off(tty);\n\t\ttty_margin_off(tty);\n\t} else\n\t\ttty->mode = MODE_CURSOR;\n}\n\n/* Turn off margin. */\nvoid\ntty_region_off(struct tty *tty)\n{\n\ttty_region(tty, 0, tty->sy - 1);\n}\n\n/* Set region inside pane. */\nstatic void\ntty_region_pane(struct tty *tty, const struct tty_ctx *ctx, u_int rupper,\n    u_int rlower)\n{\n\ttty_region(tty, ctx->yoff + rupper - ctx->woy,\n\t    ctx->yoff + rlower - ctx->woy);\n}\n\n/* Set region at absolute position. */\nstatic void\ntty_region(struct tty *tty, u_int rupper, u_int rlower)\n{\n\tif (tty->rlower == rlower && tty->rupper == rupper)\n\t\treturn;\n\tif (!tty_term_has(tty->term, TTYC_CSR))\n\t\treturn;\n\n\ttty->rupper = rupper;\n\ttty->rlower = rlower;\n\n\t/*\n\t * Some terminals (such as PuTTY) do not correctly reset the cursor to\n\t * 0,0 if it is beyond the last column (they do not reset their wrap\n\t * flag so further output causes a line feed). As a workaround, do an\n\t * explicit move to 0 first.\n\t */\n\tif (tty->cx >= tty->sx) {\n\t\tif (tty->cy == UINT_MAX)\n\t\t\ttty_cursor(tty, 0, 0);\n\t\telse\n\t\t\ttty_cursor(tty, 0, tty->cy);\n\t}\n\n\ttty_putcode_ii(tty, TTYC_CSR, tty->rupper, tty->rlower);\n\ttty->cx = tty->cy = UINT_MAX;\n}\n\n/* Turn off margin. */\nvoid\ntty_margin_off(struct tty *tty)\n{\n\ttty_margin(tty, 0, tty->sx - 1);\n}\n\n/* Set margin inside pane. */\nstatic void\ntty_margin_pane(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_margin(tty, ctx->xoff - ctx->wox,\n\t    ctx->xoff + ctx->sx - 1 - ctx->wox);\n}\n\n/* Set margin at absolute position. */\nstatic void\ntty_margin(struct tty *tty, u_int rleft, u_int rright)\n{\n\tif (!tty_use_margin(tty))\n\t\treturn;\n\tif (tty->rleft == rleft && tty->rright == rright)\n\t\treturn;\n\n\ttty_putcode_ii(tty, TTYC_CSR, tty->rupper, tty->rlower);\n\n\ttty->rleft = rleft;\n\ttty->rright = rright;\n\n\tif (rleft == 0 && rright == tty->sx - 1)\n\t\ttty_putcode(tty, TTYC_CLMG);\n\telse\n\t\ttty_putcode_ii(tty, TTYC_CMG, rleft, rright);\n\ttty->cx = tty->cy = UINT_MAX;\n}\n\n/*\n * Move the cursor, unless it would wrap itself when the next character is\n * printed.\n */\nstatic void\ntty_cursor_pane_unless_wrap(struct tty *tty, const struct tty_ctx *ctx,\n    u_int cx, u_int cy)\n{\n\tif (!ctx->wrapped ||\n\t    !tty_full_width(tty, ctx) ||\n\t    (tty->term->flags & TERM_NOAM) ||\n\t    ctx->xoff + cx != 0 ||\n\t    ctx->yoff + cy != tty->cy + 1 ||\n\t    tty->cx < tty->sx ||\n\t    tty->cy == tty->rlower)\n\t\ttty_cursor_pane(tty, ctx, cx, cy);\n\telse\n\t\tlog_debug(\"%s: will wrap at %u,%u\", __func__, tty->cx, tty->cy);\n}\n\n/* Move cursor inside pane. */\nstatic void\ntty_cursor_pane(struct tty *tty, const struct tty_ctx *ctx, u_int cx, u_int cy)\n{\n\ttty_cursor(tty, ctx->xoff + cx - ctx->wox, ctx->yoff + cy - ctx->woy);\n}\n\n/* Move cursor to absolute position. */\nvoid\ntty_cursor(struct tty *tty, u_int cx, u_int cy)\n{\n\tstruct tty_term\t*term = tty->term;\n\tu_int\t\t thisx, thisy;\n\tint\t\t change;\n\n\tif (tty->flags & TTY_BLOCK)\n\t\treturn;\n\n\tthisx = tty->cx;\n\tthisy = tty->cy;\n\n\t/*\n\t * If in the automargin space, and want to be there, do not move.\n\t * Otherwise, force the cursor to be in range (and complain).\n\t */\n\tif (cx == thisx && cy == thisy && cx == tty->sx)\n\t\treturn;\n\tif (cx > tty->sx - 1) {\n\t\tlog_debug(\"%s: x too big %u > %u\", __func__, cx, tty->sx - 1);\n\t\tcx = tty->sx - 1;\n\t}\n\n\t/* No change. */\n\tif (cx == thisx && cy == thisy)\n\t\treturn;\n\n\t/* Currently at the very end of the line - use absolute movement. */\n\tif (thisx > tty->sx - 1)\n\t\tgoto absolute;\n\n\t/* Move to home position (0, 0). */\n\tif (cx == 0 && cy == 0 && tty_term_has(term, TTYC_HOME)) {\n\t\ttty_putcode(tty, TTYC_HOME);\n\t\tgoto out;\n\t}\n\n\t/* Zero on the next line. */\n\tif (cx == 0 && cy == thisy + 1 && thisy != tty->rlower &&\n\t    (!tty_use_margin(tty) || tty->rleft == 0)) {\n\t\ttty_putc(tty, '\\r');\n\t\ttty_putc(tty, '\\n');\n\t\tgoto out;\n\t}\n\n\t/* Moving column or row. */\n\tif (cy == thisy) {\n\t\t/*\n\t\t * Moving column only, row staying the same.\n\t\t */\n\n\t\t/* To left edge. */\n\t\tif (cx == 0 && (!tty_use_margin(tty) || tty->rleft == 0)) {\n\t\t\ttty_putc(tty, '\\r');\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One to the left. */\n\t\tif (cx == thisx - 1 && tty_term_has(term, TTYC_CUB1)) {\n\t\t\ttty_putcode(tty, TTYC_CUB1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One to the right. */\n\t\tif (cx == thisx + 1 && tty_term_has(term, TTYC_CUF1)) {\n\t\t\ttty_putcode(tty, TTYC_CUF1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Calculate difference. */\n\t\tchange = thisx - cx;\t/* +ve left, -ve right */\n\n\t\t/*\n\t\t * Use HPA if change is larger than absolute, otherwise move\n\t\t * the cursor with CUB/CUF.\n\t\t */\n\t\tif ((u_int) abs(change) > cx && tty_term_has(term, TTYC_HPA)) {\n\t\t\ttty_putcode_i(tty, TTYC_HPA, cx);\n\t\t\tgoto out;\n\t\t} else if (change > 0 &&\n\t\t    tty_term_has(term, TTYC_CUB) &&\n\t\t    !tty_use_margin(tty)) {\n\t\t\tif (change == 2 && tty_term_has(term, TTYC_CUB1)) {\n\t\t\t\ttty_putcode(tty, TTYC_CUB1);\n\t\t\t\ttty_putcode(tty, TTYC_CUB1);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttty_putcode_i(tty, TTYC_CUB, change);\n\t\t\tgoto out;\n\t\t} else if (change < 0 &&\n\t\t    tty_term_has(term, TTYC_CUF) &&\n\t\t    !tty_use_margin(tty)) {\n\t\t\ttty_putcode_i(tty, TTYC_CUF, -change);\n\t\t\tgoto out;\n\t\t}\n\t} else if (cx == thisx) {\n\t\t/*\n\t\t * Moving row only, column staying the same.\n\t\t */\n\n\t\t/* One above. */\n\t\tif (thisy != tty->rupper &&\n\t\t    cy == thisy - 1 && tty_term_has(term, TTYC_CUU1)) {\n\t\t\ttty_putcode(tty, TTYC_CUU1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One below. */\n\t\tif (thisy != tty->rlower &&\n\t\t    cy == thisy + 1 && tty_term_has(term, TTYC_CUD1)) {\n\t\t\ttty_putcode(tty, TTYC_CUD1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Calculate difference. */\n\t\tchange = thisy - cy;\t/* +ve up, -ve down */\n\n\t\t/*\n\t\t * Try to use VPA if change is larger than absolute or if this\n\t\t * change would cross the scroll region, otherwise use CUU/CUD.\n\t\t */\n\t\tif ((u_int) abs(change) > cy ||\n\t\t    (change < 0 && cy - change > tty->rlower) ||\n\t\t    (change > 0 && cy - change < tty->rupper)) {\n\t\t\t    if (tty_term_has(term, TTYC_VPA)) {\n\t\t\t\t    tty_putcode_i(tty, TTYC_VPA, cy);\n\t\t\t\t    goto out;\n\t\t\t    }\n\t\t} else if (change > 0 && tty_term_has(term, TTYC_CUU)) {\n\t\t\ttty_putcode_i(tty, TTYC_CUU, change);\n\t\t\tgoto out;\n\t\t} else if (change < 0 && tty_term_has(term, TTYC_CUD)) {\n\t\t\ttty_putcode_i(tty, TTYC_CUD, -change);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nabsolute:\n\t/* Absolute movement. */\n\ttty_putcode_ii(tty, TTYC_CUP, cy, cx);\n\nout:\n\ttty->cx = cx;\n\ttty->cy = cy;\n}\n\nstatic void\ntty_hyperlink(struct tty *tty, const struct grid_cell *gc,\n    struct hyperlinks *hl)\n{\n\tconst char\t*uri, *id;\n\n\tif (gc->link == tty->cell.link)\n\t\treturn;\n\ttty->cell.link = gc->link;\n\n\tif (hl == NULL)\n\t\treturn;\n\n\tif (gc->link == 0 || !hyperlinks_get(hl, gc->link, &uri, NULL, &id))\n\t\ttty_putcode_ss(tty, TTYC_HLS, \"\", \"\");\n\telse\n\t\ttty_putcode_ss(tty, TTYC_HLS, id, uri);\n}\n\nvoid\ntty_attributes(struct tty *tty, const struct grid_cell *gc,\n    const struct grid_cell *defaults, struct colour_palette *palette,\n    struct hyperlinks *hl)\n{\n\tstruct grid_cell\t*tc = &tty->cell, gc2;\n\tint\t\t\t changed;\n\n\t/* Copy cell and update default colours. */\n\tmemcpy(&gc2, gc, sizeof gc2);\n\tif (~gc->flags & GRID_FLAG_NOPALETTE) {\n\t\tif (gc2.fg == 8)\n\t\t\tgc2.fg = defaults->fg;\n\t\tif (gc2.bg == 8)\n\t\t\tgc2.bg = defaults->bg;\n\t}\n\n\t/* Ignore cell if it is the same as the last one. */\n\tif (gc2.attr == tty->last_cell.attr &&\n\t    gc2.fg == tty->last_cell.fg &&\n\t    gc2.bg == tty->last_cell.bg &&\n\t    gc2.us == tty->last_cell.us &&\n\t\tgc2.link == tty->last_cell.link)\n\t\treturn;\n\n\t/*\n\t * If no setab, try to use the reverse attribute as a best-effort for a\n\t * non-default background. This is a bit of a hack but it doesn't do\n\t * any serious harm and makes a couple of applications happier.\n\t */\n\tif (!tty_term_has(tty->term, TTYC_SETAB)) {\n\t\tif (gc2.attr & GRID_ATTR_REVERSE) {\n\t\t\tif (gc2.fg != 7 && !COLOUR_DEFAULT(gc2.fg))\n\t\t\t\tgc2.attr &= ~GRID_ATTR_REVERSE;\n\t\t} else {\n\t\t\tif (gc2.bg != 0 && !COLOUR_DEFAULT(gc2.bg))\n\t\t\t\tgc2.attr |= GRID_ATTR_REVERSE;\n\t\t}\n\t}\n\n\t/* Fix up the colours if necessary. */\n\ttty_check_fg(tty, palette, &gc2);\n\ttty_check_bg(tty, palette, &gc2);\n\ttty_check_us(tty, palette, &gc2);\n\n\t/*\n\t * If any bits are being cleared or the underline colour is now default,\n\t * reset everything.\n\t */\n\tif ((tc->attr & ~gc2.attr) || (tc->us != gc2.us && gc2.us == 0))\n\t\ttty_reset(tty);\n\n\t/*\n\t * Set the colours. This may call tty_reset() (so it comes next) and\n\t * may add to (NOT remove) the desired attributes.\n\t */\n\ttty_colours(tty, &gc2);\n\n\t/* Filter out attribute bits already set. */\n\tchanged = gc2.attr & ~tc->attr;\n\ttc->attr = gc2.attr;\n\n\t/* Set the attributes. */\n\tif (changed & GRID_ATTR_BRIGHT)\n\t\ttty_putcode(tty, TTYC_BOLD);\n\tif (changed & GRID_ATTR_DIM)\n\t\ttty_putcode(tty, TTYC_DIM);\n\tif (changed & GRID_ATTR_ITALICS)\n\t\ttty_set_italics(tty);\n\tif (changed & GRID_ATTR_ALL_UNDERSCORE) {\n\t\tif ((changed & GRID_ATTR_UNDERSCORE) ||\n\t\t    !tty_term_has(tty->term, TTYC_SMULX))\n\t\t\ttty_putcode(tty, TTYC_SMUL);\n\t\telse if (changed & GRID_ATTR_UNDERSCORE_2)\n\t\t\ttty_putcode_i(tty, TTYC_SMULX, 2);\n\t\telse if (changed & GRID_ATTR_UNDERSCORE_3)\n\t\t\ttty_putcode_i(tty, TTYC_SMULX, 3);\n\t\telse if (changed & GRID_ATTR_UNDERSCORE_4)\n\t\t\ttty_putcode_i(tty, TTYC_SMULX, 4);\n\t\telse if (changed & GRID_ATTR_UNDERSCORE_5)\n\t\t\ttty_putcode_i(tty, TTYC_SMULX, 5);\n\t}\n\tif (changed & GRID_ATTR_BLINK)\n\t\ttty_putcode(tty, TTYC_BLINK);\n\tif (changed & GRID_ATTR_REVERSE) {\n\t\tif (tty_term_has(tty->term, TTYC_REV))\n\t\t\ttty_putcode(tty, TTYC_REV);\n\t\telse if (tty_term_has(tty->term, TTYC_SMSO))\n\t\t\ttty_putcode(tty, TTYC_SMSO);\n\t}\n\tif (changed & GRID_ATTR_HIDDEN)\n\t\ttty_putcode(tty, TTYC_INVIS);\n\tif (changed & GRID_ATTR_STRIKETHROUGH)\n\t\ttty_putcode(tty, TTYC_SMXX);\n\tif (changed & GRID_ATTR_OVERLINE)\n\t\ttty_putcode(tty, TTYC_SMOL);\n\tif ((changed & GRID_ATTR_CHARSET) && tty_acs_needed(tty))\n\t\ttty_putcode(tty, TTYC_SMACS);\n\n\t/* Set hyperlink if any. */\n\ttty_hyperlink(tty, gc, hl);\n\n\tmemcpy(&tty->last_cell, &gc2, sizeof tty->last_cell);\n}\n\nstatic void\ntty_colours(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\n\t/* No changes? Nothing is necessary. */\n\tif (gc->fg == tc->fg && gc->bg == tc->bg && gc->us == tc->us)\n\t\treturn;\n\n\t/*\n\t * Is either the default colour? This is handled specially because the\n\t * best solution might be to reset both colours to default, in which\n\t * case if only one is default need to fall onward to set the other\n\t * colour.\n\t */\n\tif (COLOUR_DEFAULT(gc->fg) || COLOUR_DEFAULT(gc->bg)) {\n\t\t/*\n\t\t * If don't have AX, send sgr0. This resets both colours to default.\n\t\t * Otherwise, try to set the default colour only as needed.\n\t\t */\n\t\tif (!tty_term_flag(tty->term, TTYC_AX))\n\t\t\ttty_reset(tty);\n\t\telse {\n\t\t\tif (COLOUR_DEFAULT(gc->fg) && !COLOUR_DEFAULT(tc->fg)) {\n\t\t\t\ttty_puts(tty, \"\\033[39m\");\n\t\t\t\ttc->fg = gc->fg;\n\t\t\t}\n\t\t\tif (COLOUR_DEFAULT(gc->bg) && !COLOUR_DEFAULT(tc->bg)) {\n\t\t\t\ttty_puts(tty, \"\\033[49m\");\n\t\t\t\ttc->bg = gc->bg;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the foreground colour. */\n\tif (!COLOUR_DEFAULT(gc->fg) && gc->fg != tc->fg)\n\t\ttty_colours_fg(tty, gc);\n\n\t/*\n\t * Set the background colour. This must come after the foreground as\n\t * tty_colours_fg() can call tty_reset().\n\t */\n\tif (!COLOUR_DEFAULT(gc->bg) && gc->bg != tc->bg)\n\t\ttty_colours_bg(tty, gc);\n\n\t/* Set the underscore colour. */\n\tif (gc->us != tc->us)\n\t\ttty_colours_us(tty, gc);\n}\n\nstatic void\ntty_check_fg(struct tty *tty, struct colour_palette *palette,\n    struct grid_cell *gc)\n{\n\tu_char\tr, g, b;\n\tu_int\tcolours;\n\tint\tc;\n\n\t/*\n\t * Perform substitution if this pane has a palette. If the bright\n\t * attribute is set and Nobr is not present, use the bright entry in\n\t * the palette by changing to the aixterm colour\n\t */\n\tif (~gc->flags & GRID_FLAG_NOPALETTE) {\n\t\tc = gc->fg;\n\t\tif (c < 8 &&\n\t\t    gc->attr & GRID_ATTR_BRIGHT &&\n\t\t    !tty_term_has(tty->term, TTYC_NOBR))\n\t\t\tc += 90;\n\t\tif ((c = colour_palette_get(palette, c)) != -1)\n\t\t\tgc->fg = c;\n\t}\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->fg & COLOUR_FLAG_RGB) {\n\t\t/* Not a 24-bit terminal? Translate to 256-colour palette. */\n\t\tif (tty->term->flags & TERM_RGBCOLOURS)\n\t\t\treturn;\n\t\tcolour_split_rgb(gc->fg, &r, &g, &b);\n\t\tgc->fg = colour_find_rgb(r, g, b);\n\t}\n\n\t/* How many colours does this terminal have? */\n\tif (tty->term->flags & TERM_256COLOURS)\n\t\tcolours = 256;\n\telse\n\t\tcolours = tty_term_number(tty->term, TTYC_COLORS);\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->fg & COLOUR_FLAG_256) {\n\t\t/* And not a 256 colour mode? */\n\t\tif (colours < 256) {\n\t\t\tgc->fg = colour_256to16(gc->fg);\n\t\t\tif (gc->fg & 8) {\n\t\t\t\tgc->fg &= 7;\n\t\t\t\tif (colours >= 16)\n\t\t\t\t\tgc->fg += 90;\n\t\t\t\telse if (gc->fg == 0 && gc->bg == 0)\n\t\t\t\t\tgc->fg = 7;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm colour? */\n\tif (gc->fg >= 90 && gc->fg <= 97 && colours < 16) {\n\t\tgc->fg -= 90;\n\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t}\n}\n\nstatic void\ntty_check_bg(struct tty *tty, struct colour_palette *palette,\n    struct grid_cell *gc)\n{\n\tu_char\tr, g, b;\n\tu_int\tcolours;\n\tint\tc;\n\n\t/* Perform substitution if this pane has a palette. */\n\tif (~gc->flags & GRID_FLAG_NOPALETTE) {\n\t\tif ((c = colour_palette_get(palette, gc->bg)) != -1)\n\t\t\tgc->bg = c;\n\t}\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->bg & COLOUR_FLAG_RGB) {\n\t\t/* Not a 24-bit terminal? Translate to 256-colour palette. */\n\t\tif (tty->term->flags & TERM_RGBCOLOURS)\n\t\t\treturn;\n\t\tcolour_split_rgb(gc->bg, &r, &g, &b);\n\t\tgc->bg = colour_find_rgb(r, g, b);\n\t}\n\n\t/* How many colours does this terminal have? */\n\tif (tty->term->flags & TERM_256COLOURS)\n\t\tcolours = 256;\n\telse\n\t\tcolours = tty_term_number(tty->term, TTYC_COLORS);\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->bg & COLOUR_FLAG_256) {\n\t\t/*\n\t\t * And not a 256 colour mode? Translate to 16-colour\n\t\t * palette. Bold background doesn't exist portably, so just\n\t\t * discard the bold bit if set.\n\t\t */\n\t\tif (colours < 256) {\n\t\t\tgc->bg = colour_256to16(gc->bg);\n\t\t\tif (gc->bg & 8) {\n\t\t\t\tgc->bg &= 7;\n\t\t\t\tif (colours >= 16)\n\t\t\t\t\tgc->bg += 90;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm colour? */\n\tif (gc->bg >= 90 && gc->bg <= 97 && colours < 16)\n\t\tgc->bg -= 90;\n}\n\nstatic void\ntty_check_us(__unused struct tty *tty, struct colour_palette *palette,\n    struct grid_cell *gc)\n{\n\tint\tc;\n\n\t/* Perform substitution if this pane has a palette. */\n\tif (~gc->flags & GRID_FLAG_NOPALETTE) {\n\t\tif ((c = colour_palette_get(palette, gc->us)) != -1)\n\t\t\tgc->us = c;\n\t}\n\n\t/* Convert underscore colour if only RGB can be supported. */\n\tif (!tty_term_has(tty->term, TTYC_SETULC1)) {\n\t\t    if ((c = colour_force_rgb (gc->us)) == -1)\n\t\t\t    gc->us = 8;\n\t\t    else\n\t\t\t    gc->us = c;\n\t}\n}\n\nstatic void\ntty_colours_fg(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tchar\t\t\t s[32];\n\n\t/*\n\t * If the current colour is an aixterm bright colour and the new is not,\n\t * reset because some terminals do not clear bright correctly.\n\t */\n\tif (tty->cell.fg >= 90 &&\n\t    tty->cell.bg <= 97 &&\n\t    (gc->fg < 90 || gc->fg > 97))\n\t\ttty_reset(tty);\n\n\t/* Is this a 24-bit or 256-colour colour? */\n\tif (gc->fg & COLOUR_FLAG_RGB || gc->fg & COLOUR_FLAG_256) {\n\t\tif (tty_try_colour(tty, gc->fg, \"38\") == 0)\n\t\t\tgoto save;\n\t\t/* Should not get here, already converted in tty_check_fg. */\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm bright colour? */\n\tif (gc->fg >= 90 && gc->fg <= 97) {\n\t\tif (tty->term->flags & TERM_256COLOURS) {\n\t\t\txsnprintf(s, sizeof s, \"\\033[%dm\", gc->fg);\n\t\t\ttty_puts(tty, s);\n\t\t} else\n\t\t\ttty_putcode_i(tty, TTYC_SETAF, gc->fg - 90 + 8);\n\t\tgoto save;\n\t}\n\n\t/* Otherwise set the foreground colour. */\n\ttty_putcode_i(tty, TTYC_SETAF, gc->fg);\n\nsave:\n\t/* Save the new values in the terminal current cell. */\n\ttc->fg = gc->fg;\n}\n\nstatic void\ntty_colours_bg(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tchar\t\t\t s[32];\n\n\t/* Is this a 24-bit or 256-colour colour? */\n\tif (gc->bg & COLOUR_FLAG_RGB || gc->bg & COLOUR_FLAG_256) {\n\t\tif (tty_try_colour(tty, gc->bg, \"48\") == 0)\n\t\t\tgoto save;\n\t\t/* Should not get here, already converted in tty_check_bg. */\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm bright colour? */\n\tif (gc->bg >= 90 && gc->bg <= 97) {\n\t\tif (tty->term->flags & TERM_256COLOURS) {\n\t\t\txsnprintf(s, sizeof s, \"\\033[%dm\", gc->bg + 10);\n\t\t\ttty_puts(tty, s);\n\t\t} else\n\t\t\ttty_putcode_i(tty, TTYC_SETAB, gc->bg - 90 + 8);\n\t\tgoto save;\n\t}\n\n\t/* Otherwise set the background colour. */\n\ttty_putcode_i(tty, TTYC_SETAB, gc->bg);\n\nsave:\n\t/* Save the new values in the terminal current cell. */\n\ttc->bg = gc->bg;\n}\n\nstatic void\ntty_colours_us(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tu_int\t\t\t c;\n\tu_char\t\t\t r, g, b;\n\n\t/* Clear underline colour. */\n\tif (COLOUR_DEFAULT(gc->us)) {\n\t\ttty_putcode(tty, TTYC_OL);\n\t\tgoto save;\n\t}\n\n\t/*\n\t * If this is not an RGB colour, use Setulc1 if it exists, otherwise\n\t * convert.\n\t */\n\tif (~gc->us & COLOUR_FLAG_RGB) {\n\t\tc = gc->us;\n\t\tif ((~c & COLOUR_FLAG_256) && (c >= 90 && c <= 97))\n\t\t\tc -= 82;\n\t\ttty_putcode_i(tty, TTYC_SETULC1, c & ~COLOUR_FLAG_256);\n\t\treturn;\n\t}\n\n\t/*\n\t * Setulc and setal follows the ncurses(3) one argument \"direct colour\"\n\t * capability format. Calculate the colour value.\n\t */\n\tcolour_split_rgb(gc->us, &r, &g, &b);\n\tc = (65536 * r) + (256 * g) + b;\n\n\t/*\n\t * Write the colour. Only use setal if the RGB flag is set because the\n\t * non-RGB version may be wrong.\n\t */\n\tif (tty_term_has(tty->term, TTYC_SETULC))\n\t\ttty_putcode_i(tty, TTYC_SETULC, c);\n\telse if (tty_term_has(tty->term, TTYC_SETAL) &&\n\t    tty_term_has(tty->term, TTYC_RGB))\n\t\ttty_putcode_i(tty, TTYC_SETAL, c);\n\nsave:\n\t/* Save the new values in the terminal current cell. */\n\ttc->us = gc->us;\n}\n\nstatic int\ntty_try_colour(struct tty *tty, int colour, const char *type)\n{\n\tu_char\tr, g, b;\n\n\tif (colour & COLOUR_FLAG_256) {\n\t\tif (*type == '3' && tty_term_has(tty->term, TTYC_SETAF))\n\t\t\ttty_putcode_i(tty, TTYC_SETAF, colour & 0xff);\n\t\telse if (tty_term_has(tty->term, TTYC_SETAB))\n\t\t\ttty_putcode_i(tty, TTYC_SETAB, colour & 0xff);\n\t\treturn (0);\n\t}\n\n\tif (colour & COLOUR_FLAG_RGB) {\n\t\tcolour_split_rgb(colour & 0xffffff, &r, &g, &b);\n\t\tif (*type == '3' && tty_term_has(tty->term, TTYC_SETRGBF))\n\t\t\ttty_putcode_iii(tty, TTYC_SETRGBF, r, g, b);\n\t\telse if (tty_term_has(tty->term, TTYC_SETRGBB))\n\t\t\ttty_putcode_iii(tty, TTYC_SETRGBB, r, g, b);\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\nstatic void\ntty_window_default_style(struct grid_cell *gc, struct window_pane *wp)\n{\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\tgc->fg = wp->palette.fg;\n\tgc->bg = wp->palette.bg;\n}\n\nvoid\ntty_default_colours(struct grid_cell *gc, struct window_pane *wp)\n{\n\tstruct options\t\t*oo = wp->options;\n\tstruct format_tree\t*ft;\n\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\n\tif (wp->flags & PANE_STYLECHANGED) {\n\t\tlog_debug(\"%%%u: style changed\", wp->id);\n\t\twp->flags &= ~PANE_STYLECHANGED;\n\n\t\tft = format_create(NULL, NULL, FORMAT_PANE|wp->id,\n\t\t    FORMAT_NOJOBS);\n\t\tformat_defaults(ft, NULL, NULL, NULL, wp);\n\t\ttty_window_default_style(&wp->cached_active_gc, wp);\n\t\tstyle_add(&wp->cached_active_gc, oo, \"window-active-style\", ft);\n\t\ttty_window_default_style(&wp->cached_gc, wp);\n\t\tstyle_add(&wp->cached_gc, oo, \"window-style\", ft);\n\t\tformat_free(ft);\n\t}\n\n\tif (gc->fg == 8) {\n\t\tif (wp == wp->window->active && wp->cached_active_gc.fg != 8)\n\t\t\tgc->fg = wp->cached_active_gc.fg;\n\t\telse\n\t\t\tgc->fg = wp->cached_gc.fg;\n\t}\n\n\tif (gc->bg == 8) {\n\t\tif (wp == wp->window->active && wp->cached_active_gc.bg != 8)\n\t\t\tgc->bg = wp->cached_active_gc.bg;\n\t\telse\n\t\t\tgc->bg = wp->cached_gc.bg;\n\t}\n}\n\nstatic void\ntty_default_attributes(struct tty *tty, const struct grid_cell *defaults,\n    struct colour_palette *palette, u_int bg, struct hyperlinks *hl)\n{\n\tstruct grid_cell\tgc;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tgc.bg = bg;\n\ttty_attributes(tty, &gc, defaults, palette, hl);\n}\n\nstatic void\ntty_clipboard_query_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\tstruct client\t*c = tty->client;\n\n\tc->flags &= ~CLIENT_CLIPBOARDBUFFER;\n\tfree(c->clipboard_panes);\n\tc->clipboard_panes = NULL;\n\tc->clipboard_npanes = 0;\n\n\ttty->flags &= ~TTY_OSC52QUERY;\n}\n\nvoid\ntty_clipboard_query(struct tty *tty)\n{\n\tstruct timeval\t tv = { .tv_sec = TTY_QUERY_TIMEOUT };\n\n\tif ((~tty->flags & TTY_STARTED) || (tty->flags & TTY_OSC52QUERY))\n\t\treturn;\n\ttty_putcode_ss(tty, TTYC_MS, \"\", \"?\");\n\n\ttty->flags |= TTY_OSC52QUERY;\n\tevtimer_set(&tty->clipboard_timer, tty_clipboard_query_callback, tty);\n\tevtimer_add(&tty->clipboard_timer, &tv);\n}\n"
        },
        {
          "name": "utf8-combined.c",
          "type": "blob",
          "size": 2.08984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2023 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"tmux.h\"\n\n/* Has this got a zero width joiner at the end? */\nint\nutf8_has_zwj(const struct utf8_data *ud)\n{\n\tif (ud->size < 3)\n\t\treturn (0);\n\treturn (memcmp(ud->data + ud->size - 3, \"\\342\\200\\215\", 3) == 0);\n}\n\n/* Is this a zero width joiner? */\nint\nutf8_is_zwj(const struct utf8_data *ud)\n{\n\tif (ud->size != 3)\n\t\treturn (0);\n\treturn (memcmp(ud->data, \"\\342\\200\\215\", 3) == 0);\n}\n\n/* Is this a variation selector? */\nint\nutf8_is_vs(const struct utf8_data *ud)\n{\n\tif (ud->size != 3)\n\t\treturn (0);\n\treturn (memcmp(ud->data, \"\\357\\270\\217\", 3) == 0);\n}\n\n/* Is this in the modifier table? */\nint\nutf8_is_modifier(const struct utf8_data *ud)\n{\n\twchar_t\twc;\n\n\tif (utf8_towc(ud, &wc) != UTF8_DONE)\n\t\treturn (0);\n\tswitch (wc) {\n\tcase 0x1F1E6:\n\tcase 0x1F1E7:\n\tcase 0x1F1E8:\n\tcase 0x1F1E9:\n\tcase 0x1F1EA:\n\tcase 0x1F1EB:\n\tcase 0x1F1EC:\n\tcase 0x1F1ED:\n\tcase 0x1F1EE:\n\tcase 0x1F1EF:\n\tcase 0x1F1F0:\n\tcase 0x1F1F1:\n\tcase 0x1F1F2:\n\tcase 0x1F1F3:\n\tcase 0x1F1F4:\n\tcase 0x1F1F5:\n\tcase 0x1F1F6:\n\tcase 0x1F1F7:\n\tcase 0x1F1F8:\n\tcase 0x1F1F9:\n\tcase 0x1F1FA:\n\tcase 0x1F1FB:\n\tcase 0x1F1FC:\n\tcase 0x1F1FD:\n\tcase 0x1F1FE:\n\tcase 0x1F1FF:\n\tcase 0x1F3FB:\n\tcase 0x1F3FC:\n\tcase 0x1F3FD:\n\tcase 0x1F3FE:\n\tcase 0x1F3FF:\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n"
        },
        {
          "name": "utf8.c",
          "type": "blob",
          "size": 21.947265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"compat.h\"\n#include \"tmux.h\"\n\nstruct utf8_width_item {\n\twchar_t\t\t\t\twc;\n\tu_int\t\t\t\twidth;\n\tint\t\t\t\tallocated;\n\n\tRB_ENTRY(utf8_width_item)\tentry;\n};\n\nstatic int\nutf8_width_cache_cmp(struct utf8_width_item *uw1, struct utf8_width_item *uw2)\n{\n\tif (uw1->wc < uw2->wc)\n\t\treturn (-1);\n\tif (uw1->wc > uw2->wc)\n\t\treturn (1);\n\treturn (0);\n}\nRB_HEAD(utf8_width_cache, utf8_width_item);\nRB_GENERATE_STATIC(utf8_width_cache, utf8_width_item, entry,\n    utf8_width_cache_cmp);\nstatic struct utf8_width_cache utf8_width_cache =\n    RB_INITIALIZER(utf8_width_cache);\n\nstatic struct utf8_width_item utf8_default_width_cache[] = {\n\t{ .wc = 0x0261D, .width = 2 },\n\t{ .wc = 0x026F9, .width = 2 },\n\t{ .wc = 0x0270A, .width = 2 },\n\t{ .wc = 0x0270B, .width = 2 },\n\t{ .wc = 0x0270C, .width = 2 },\n\t{ .wc = 0x0270D, .width = 2 },\n\t{ .wc = 0x1F1E6, .width = 2 },\n\t{ .wc = 0x1F1E7, .width = 2 },\n\t{ .wc = 0x1F1E8, .width = 2 },\n\t{ .wc = 0x1F1E9, .width = 2 },\n\t{ .wc = 0x1F1EA, .width = 2 },\n\t{ .wc = 0x1F1EB, .width = 2 },\n\t{ .wc = 0x1F1EC, .width = 2 },\n\t{ .wc = 0x1F1ED, .width = 2 },\n\t{ .wc = 0x1F1EE, .width = 2 },\n\t{ .wc = 0x1F1EF, .width = 2 },\n\t{ .wc = 0x1F1F0, .width = 2 },\n\t{ .wc = 0x1F1F1, .width = 2 },\n\t{ .wc = 0x1F1F2, .width = 2 },\n\t{ .wc = 0x1F1F3, .width = 2 },\n\t{ .wc = 0x1F1F4, .width = 2 },\n\t{ .wc = 0x1F1F5, .width = 2 },\n\t{ .wc = 0x1F1F6, .width = 2 },\n\t{ .wc = 0x1F1F7, .width = 2 },\n\t{ .wc = 0x1F1F8, .width = 2 },\n\t{ .wc = 0x1F1F9, .width = 2 },\n\t{ .wc = 0x1F1FA, .width = 2 },\n\t{ .wc = 0x1F1FB, .width = 2 },\n\t{ .wc = 0x1F1FC, .width = 2 },\n\t{ .wc = 0x1F1FD, .width = 2 },\n\t{ .wc = 0x1F1FE, .width = 2 },\n\t{ .wc = 0x1F1FF, .width = 2 },\n\t{ .wc = 0x1F385, .width = 2 },\n\t{ .wc = 0x1F3C2, .width = 2 },\n\t{ .wc = 0x1F3C3, .width = 2 },\n\t{ .wc = 0x1F3C4, .width = 2 },\n\t{ .wc = 0x1F3C7, .width = 2 },\n\t{ .wc = 0x1F3CA, .width = 2 },\n\t{ .wc = 0x1F3CB, .width = 2 },\n\t{ .wc = 0x1F3CC, .width = 2 },\n\t{ .wc = 0x1F3FB, .width = 2 },\n\t{ .wc = 0x1F3FC, .width = 2 },\n\t{ .wc = 0x1F3FD, .width = 2 },\n\t{ .wc = 0x1F3FE, .width = 2 },\n\t{ .wc = 0x1F3FF, .width = 2 },\n\t{ .wc = 0x1F442, .width = 2 },\n\t{ .wc = 0x1F443, .width = 2 },\n\t{ .wc = 0x1F446, .width = 2 },\n\t{ .wc = 0x1F447, .width = 2 },\n\t{ .wc = 0x1F448, .width = 2 },\n\t{ .wc = 0x1F449, .width = 2 },\n\t{ .wc = 0x1F44A, .width = 2 },\n\t{ .wc = 0x1F44B, .width = 2 },\n\t{ .wc = 0x1F44C, .width = 2 },\n\t{ .wc = 0x1F44D, .width = 2 },\n\t{ .wc = 0x1F44E, .width = 2 },\n\t{ .wc = 0x1F44F, .width = 2 },\n\t{ .wc = 0x1F450, .width = 2 },\n\t{ .wc = 0x1F466, .width = 2 },\n\t{ .wc = 0x1F467, .width = 2 },\n\t{ .wc = 0x1F468, .width = 2 },\n\t{ .wc = 0x1F469, .width = 2 },\n\t{ .wc = 0x1F46B, .width = 2 },\n\t{ .wc = 0x1F46C, .width = 2 },\n\t{ .wc = 0x1F46D, .width = 2 },\n\t{ .wc = 0x1F46E, .width = 2 },\n\t{ .wc = 0x1F470, .width = 2 },\n\t{ .wc = 0x1F471, .width = 2 },\n\t{ .wc = 0x1F472, .width = 2 },\n\t{ .wc = 0x1F473, .width = 2 },\n\t{ .wc = 0x1F474, .width = 2 },\n\t{ .wc = 0x1F475, .width = 2 },\n\t{ .wc = 0x1F476, .width = 2 },\n\t{ .wc = 0x1F477, .width = 2 },\n\t{ .wc = 0x1F478, .width = 2 },\n\t{ .wc = 0x1F47C, .width = 2 },\n\t{ .wc = 0x1F481, .width = 2 },\n\t{ .wc = 0x1F482, .width = 2 },\n\t{ .wc = 0x1F483, .width = 2 },\n\t{ .wc = 0x1F485, .width = 2 },\n\t{ .wc = 0x1F486, .width = 2 },\n\t{ .wc = 0x1F487, .width = 2 },\n\t{ .wc = 0x1F48F, .width = 2 },\n\t{ .wc = 0x1F491, .width = 2 },\n\t{ .wc = 0x1F4AA, .width = 2 },\n\t{ .wc = 0x1F574, .width = 2 },\n\t{ .wc = 0x1F575, .width = 2 },\n\t{ .wc = 0x1F57A, .width = 2 },\n\t{ .wc = 0x1F590, .width = 2 },\n\t{ .wc = 0x1F595, .width = 2 },\n\t{ .wc = 0x1F596, .width = 2 },\n\t{ .wc = 0x1F645, .width = 2 },\n\t{ .wc = 0x1F646, .width = 2 },\n\t{ .wc = 0x1F647, .width = 2 },\n\t{ .wc = 0x1F64B, .width = 2 },\n\t{ .wc = 0x1F64C, .width = 2 },\n\t{ .wc = 0x1F64D, .width = 2 },\n\t{ .wc = 0x1F64E, .width = 2 },\n\t{ .wc = 0x1F64F, .width = 2 },\n\t{ .wc = 0x1F6A3, .width = 2 },\n\t{ .wc = 0x1F6B4, .width = 2 },\n\t{ .wc = 0x1F6B5, .width = 2 },\n\t{ .wc = 0x1F6B6, .width = 2 },\n\t{ .wc = 0x1F6C0, .width = 2 },\n\t{ .wc = 0x1F6CC, .width = 2 },\n\t{ .wc = 0x1F90C, .width = 2 },\n\t{ .wc = 0x1F90F, .width = 2 },\n\t{ .wc = 0x1F918, .width = 2 },\n\t{ .wc = 0x1F919, .width = 2 },\n\t{ .wc = 0x1F91A, .width = 2 },\n\t{ .wc = 0x1F91B, .width = 2 },\n\t{ .wc = 0x1F91C, .width = 2 },\n\t{ .wc = 0x1F91D, .width = 2 },\n\t{ .wc = 0x1F91E, .width = 2 },\n\t{ .wc = 0x1F91F, .width = 2 },\n\t{ .wc = 0x1F926, .width = 2 },\n\t{ .wc = 0x1F930, .width = 2 },\n\t{ .wc = 0x1F931, .width = 2 },\n\t{ .wc = 0x1F932, .width = 2 },\n\t{ .wc = 0x1F933, .width = 2 },\n\t{ .wc = 0x1F934, .width = 2 },\n\t{ .wc = 0x1F935, .width = 2 },\n\t{ .wc = 0x1F936, .width = 2 },\n\t{ .wc = 0x1F937, .width = 2 },\n\t{ .wc = 0x1F938, .width = 2 },\n\t{ .wc = 0x1F939, .width = 2 },\n\t{ .wc = 0x1F93D, .width = 2 },\n\t{ .wc = 0x1F93E, .width = 2 },\n\t{ .wc = 0x1F977, .width = 2 },\n\t{ .wc = 0x1F9B5, .width = 2 },\n\t{ .wc = 0x1F9B6, .width = 2 },\n\t{ .wc = 0x1F9B8, .width = 2 },\n\t{ .wc = 0x1F9B9, .width = 2 },\n\t{ .wc = 0x1F9BB, .width = 2 },\n\t{ .wc = 0x1F9CD, .width = 2 },\n\t{ .wc = 0x1F9CE, .width = 2 },\n\t{ .wc = 0x1F9CF, .width = 2 },\n\t{ .wc = 0x1F9D1, .width = 2 },\n\t{ .wc = 0x1F9D2, .width = 2 },\n\t{ .wc = 0x1F9D3, .width = 2 },\n\t{ .wc = 0x1F9D4, .width = 2 },\n\t{ .wc = 0x1F9D5, .width = 2 },\n\t{ .wc = 0x1F9D6, .width = 2 },\n\t{ .wc = 0x1F9D7, .width = 2 },\n\t{ .wc = 0x1F9D8, .width = 2 },\n\t{ .wc = 0x1F9D9, .width = 2 },\n\t{ .wc = 0x1F9DA, .width = 2 },\n\t{ .wc = 0x1F9DB, .width = 2 },\n\t{ .wc = 0x1F9DC, .width = 2 },\n\t{ .wc = 0x1F9DD, .width = 2 },\n\t{ .wc = 0x1FAC3, .width = 2 },\n\t{ .wc = 0x1FAC4, .width = 2 },\n\t{ .wc = 0x1FAC5, .width = 2 },\n\t{ .wc = 0x1FAF0, .width = 2 },\n\t{ .wc = 0x1FAF1, .width = 2 },\n\t{ .wc = 0x1FAF2, .width = 2 },\n\t{ .wc = 0x1FAF3, .width = 2 },\n\t{ .wc = 0x1FAF4, .width = 2 },\n\t{ .wc = 0x1FAF5, .width = 2 },\n\t{ .wc = 0x1FAF6, .width = 2 },\n\t{ .wc = 0x1FAF7, .width = 2 },\n\t{ .wc = 0x1FAF8, .width = 2 }\n};\n\nstruct utf8_item {\n\tRB_ENTRY(utf8_item)\tindex_entry;\n\tu_int\t\t\tindex;\n\n\tRB_ENTRY(utf8_item)\tdata_entry;\n\tchar\t\t\tdata[UTF8_SIZE];\n\tu_char\t\t\tsize;\n};\n\nstatic int\nutf8_data_cmp(struct utf8_item *ui1, struct utf8_item *ui2)\n{\n\tif (ui1->size < ui2->size)\n\t\treturn (-1);\n\tif (ui1->size > ui2->size)\n\t\treturn (1);\n\treturn (memcmp(ui1->data, ui2->data, ui1->size));\n}\nRB_HEAD(utf8_data_tree, utf8_item);\nRB_GENERATE_STATIC(utf8_data_tree, utf8_item, data_entry, utf8_data_cmp);\nstatic struct utf8_data_tree utf8_data_tree = RB_INITIALIZER(utf8_data_tree);\n\nstatic int\nutf8_index_cmp(struct utf8_item *ui1, struct utf8_item *ui2)\n{\n\tif (ui1->index < ui2->index)\n\t\treturn (-1);\n\tif (ui1->index > ui2->index)\n\t\treturn (1);\n\treturn (0);\n}\nRB_HEAD(utf8_index_tree, utf8_item);\nRB_GENERATE_STATIC(utf8_index_tree, utf8_item, index_entry, utf8_index_cmp);\nstatic struct utf8_index_tree utf8_index_tree = RB_INITIALIZER(utf8_index_tree);\n\nstatic int\tutf8_no_width;\nstatic u_int\tutf8_next_index;\n\n#define UTF8_GET_SIZE(uc) (((uc) >> 24) & 0x1f)\n#define UTF8_GET_WIDTH(uc) (((uc) >> 29) - 1)\n\n#define UTF8_SET_SIZE(size) (((utf8_char)(size)) << 24)\n#define UTF8_SET_WIDTH(width) ((((utf8_char)(width)) + 1) << 29)\n\n/* Get a UTF-8 item from data. */\nstatic struct utf8_item *\nutf8_item_by_data(const u_char *data, size_t size)\n{\n\tstruct utf8_item\tui;\n\n\tmemcpy(ui.data, data, size);\n\tui.size = size;\n\n\treturn (RB_FIND(utf8_data_tree, &utf8_data_tree, &ui));\n}\n\n/* Get a UTF-8 item from data. */\nstatic struct utf8_item *\nutf8_item_by_index(u_int index)\n{\n\tstruct utf8_item\tui;\n\n\tui.index = index;\n\n\treturn (RB_FIND(utf8_index_tree, &utf8_index_tree, &ui));\n}\n\n/* Find a codepoint in the cache. */\nstatic struct utf8_width_item *\nutf8_find_in_width_cache(wchar_t wc)\n{\n\tstruct utf8_width_item\tuw;\n\n\tuw.wc = wc;\n\treturn RB_FIND(utf8_width_cache, &utf8_width_cache, &uw);\n}\n\n/* Parse a single codepoint option. */\nstatic void\nutf8_add_to_width_cache(const char *s)\n{\n\tstruct utf8_width_item\t*uw, *old;\n\tchar\t\t\t*copy, *cp, *endptr;\n\tu_int\t\t\t width;\n\tconst char\t\t*errstr;\n\tstruct utf8_data\t*ud;\n\twchar_t\t\t\t wc;\n\tunsigned long long\t n;\n\n\tcopy = xstrdup(s);\n\tif ((cp = strchr(copy, '=')) == NULL) {\n\t\tfree(copy);\n\t\treturn;\n\t}\n\t*cp++ = '\\0';\n\n\twidth = strtonum(cp, 0, 2, &errstr);\n\tif (errstr != NULL) {\n\t\tfree(copy);\n\t\treturn;\n\t}\n\n\tif (strncmp(copy, \"U+\", 2) == 0) {\n\t\terrno = 0;\n\t\tn = strtoull(copy + 2, &endptr, 16);\n\t\tif (copy[2] == '\\0' ||\n\t\t    *endptr != '\\0' ||\n\t\t    n == 0 ||\n\t\t    n > WCHAR_MAX ||\n\t\t    (errno == ERANGE && n == ULLONG_MAX)) {\n\t\t\tfree(copy);\n\t\t\treturn;\n\t\t}\n\t\twc = n;\n\t} else {\n\t\tutf8_no_width = 1;\n\t\tud = utf8_fromcstr(copy);\n\t\tutf8_no_width = 0;\n\t\tif (ud[0].size == 0 || ud[1].size != 0) {\n\t\t\tfree(ud);\n\t\t\tfree(copy);\n\t\t\treturn;\n\t\t}\n#ifdef HAVE_UTF8PROC\n\t\tif (utf8proc_mbtowc(&wc, ud[0].data, ud[0].size) <= 0) {\n#else\n\t\tif (mbtowc(&wc, ud[0].data, ud[0].size) <= 0) {\n#endif\n\t\t\tfree(ud);\n\t\t\tfree(copy);\n\t\t\treturn;\n\t\t}\n\t\tfree(ud);\n\t}\n\n\tlog_debug(\"Unicode width cache: %08X=%u\", (u_int)wc, width);\n\n\tuw = xcalloc(1, sizeof *uw);\n\tuw->wc = wc;\n\tuw->width = width;\n\tuw->allocated = 1;\n\n\told = RB_INSERT(utf8_width_cache, &utf8_width_cache, uw);\n\tif (old != NULL) {\n\t\tRB_REMOVE(utf8_width_cache, &utf8_width_cache, old);\n\t\tif (old->allocated)\n\t\t\tfree(old);\n\t\tRB_INSERT(utf8_width_cache, &utf8_width_cache, uw);\n\t}\n\n\tfree(copy);\n}\n\n/* Rebuild cache of widths. */\nvoid\nutf8_update_width_cache(void)\n{\n\tstruct utf8_width_item\t\t*uw, *uw1;\n\tstruct options_entry\t\t*o;\n\tstruct options_array_item\t*a;\n\tu_int\t\t\t\t i;\n\n\tRB_FOREACH_SAFE (uw, utf8_width_cache, &utf8_width_cache, uw1) {\n\t\tRB_REMOVE(utf8_width_cache, &utf8_width_cache, uw);\n\t\tif (uw->allocated)\n\t\t\tfree(uw);\n\t}\n\n\tfor (i = 0; i < nitems(utf8_default_width_cache); i++) {\n\t\tRB_INSERT(utf8_width_cache, &utf8_width_cache,\n\t\t    &utf8_default_width_cache[i]);\n\t}\n\n\to = options_get(global_options, \"codepoint-widths\");\n\ta = options_array_first(o);\n\twhile (a != NULL) {\n\t\tutf8_add_to_width_cache(options_array_item_value(a)->string);\n\t\ta = options_array_next(a);\n\t}\n}\n\n/* Add a UTF-8 item. */\nstatic int\nutf8_put_item(const u_char *data, size_t size, u_int *index)\n{\n\tstruct utf8_item\t*ui;\n\n\tui = utf8_item_by_data(data, size);\n\tif (ui != NULL) {\n\t\t*index = ui->index;\n\t\tlog_debug(\"%s: found %.*s = %u\", __func__, (int)size, data,\n\t\t    *index);\n\t\treturn (0);\n\t}\n\n\tif (utf8_next_index == 0xffffff + 1)\n\t\treturn (-1);\n\n\tui = xcalloc(1, sizeof *ui);\n\tui->index = utf8_next_index++;\n\tRB_INSERT(utf8_index_tree, &utf8_index_tree, ui);\n\n\tmemcpy(ui->data, data, size);\n\tui->size = size;\n\tRB_INSERT(utf8_data_tree, &utf8_data_tree, ui);\n\n\t*index = ui->index;\n\tlog_debug(\"%s: added %.*s = %u\", __func__, (int)size, data, *index);\n\treturn (0);\n}\n\n/* Get UTF-8 character from data. */\nenum utf8_state\nutf8_from_data(const struct utf8_data *ud, utf8_char *uc)\n{\n\tu_int\tindex;\n\n\tif (ud->width > 2)\n\t\tfatalx(\"invalid UTF-8 width: %u\", ud->width);\n\n\tif (ud->size > UTF8_SIZE)\n\t\tgoto fail;\n\tif (ud->size <= 3) {\n\t\tindex = (((utf8_char)ud->data[2] << 16)|\n\t\t\t  ((utf8_char)ud->data[1] << 8)|\n\t\t\t  ((utf8_char)ud->data[0]));\n\t} else if (utf8_put_item(ud->data, ud->size, &index) != 0)\n\t\tgoto fail;\n\t*uc = UTF8_SET_SIZE(ud->size)|UTF8_SET_WIDTH(ud->width)|index;\n\tlog_debug(\"%s: (%d %d %.*s) -> %08x\", __func__, ud->width, ud->size,\n\t    (int)ud->size, ud->data, *uc);\n\treturn (UTF8_DONE);\n\nfail:\n\tif (ud->width == 0)\n\t\t*uc = UTF8_SET_SIZE(0)|UTF8_SET_WIDTH(0);\n\telse if (ud->width == 1)\n\t\t*uc = UTF8_SET_SIZE(1)|UTF8_SET_WIDTH(1)|0x20;\n\telse\n\t\t*uc = UTF8_SET_SIZE(1)|UTF8_SET_WIDTH(1)|0x2020;\n\treturn (UTF8_ERROR);\n}\n\n/* Get UTF-8 data from character. */\nvoid\nutf8_to_data(utf8_char uc, struct utf8_data *ud)\n{\n\tstruct utf8_item\t*ui;\n\tu_int\t\t\t index;\n\n\tmemset(ud, 0, sizeof *ud);\n\tud->size = ud->have = UTF8_GET_SIZE(uc);\n\tud->width = UTF8_GET_WIDTH(uc);\n\n\tif (ud->size <= 3) {\n\t\tud->data[2] = (uc >> 16);\n\t\tud->data[1] = ((uc >> 8) & 0xff);\n\t\tud->data[0] = (uc & 0xff);\n\t} else {\n\t\tindex = (uc & 0xffffff);\n\t\tif ((ui = utf8_item_by_index(index)) == NULL)\n\t\t\tmemset(ud->data, ' ', ud->size);\n\t\telse\n\t\t\tmemcpy(ud->data, ui->data, ud->size);\n\t}\n\n\tlog_debug(\"%s: %08x -> (%d %d %.*s)\", __func__, uc, ud->width, ud->size,\n\t    (int)ud->size, ud->data);\n}\n\n/* Get UTF-8 character from a single ASCII character. */\nu_int\nutf8_build_one(u_char ch)\n{\n\treturn (UTF8_SET_SIZE(1)|UTF8_SET_WIDTH(1)|ch);\n}\n\n/* Set a single character. */\nvoid\nutf8_set(struct utf8_data *ud, u_char ch)\n{\n\tstatic const struct utf8_data empty = { { 0 }, 1, 1, 1 };\n\n\tmemcpy(ud, &empty, sizeof *ud);\n\t*ud->data = ch;\n}\n\n/* Copy UTF-8 character. */\nvoid\nutf8_copy(struct utf8_data *to, const struct utf8_data *from)\n{\n\tu_int\ti;\n\n\tmemcpy(to, from, sizeof *to);\n\n\tfor (i = to->size; i < sizeof to->data; i++)\n\t\tto->data[i] = '\\0';\n}\n\n/* Get width of Unicode character. */\nstatic enum utf8_state\nutf8_width(struct utf8_data *ud, int *width)\n{\n\tstruct utf8_width_item\t*uw;\n\twchar_t\t\t\t wc;\n\n\tif (utf8_towc(ud, &wc) != UTF8_DONE)\n\t\treturn (UTF8_ERROR);\n\tuw = utf8_find_in_width_cache(wc);\n\tif (uw != NULL) {\n\t\t*width = uw->width;\n\t\tlog_debug(\"cached width for %08X is %d\", (u_int)wc, *width);\n\t\treturn (UTF8_DONE);\n\t}\n#ifdef HAVE_UTF8PROC\n\t*width = utf8proc_wcwidth(wc);\n\tlog_debug(\"utf8proc_wcwidth(%05X) returned %d\", (u_int)wc, *width);\n#else\n\t*width = wcwidth(wc);\n\tlog_debug(\"wcwidth(%05X) returned %d\", (u_int)wc, *width);\n\tif (*width < 0) {\n\t\t/*\n\t\t * C1 control characters are nonprintable, so they are always\n\t\t * zero width.\n\t\t */\n\t\t*width = (wc >= 0x80 && wc <= 0x9f) ? 0 : 1;\n\t}\n#endif\n\tif (*width >= 0 && *width <= 0xff)\n\t\treturn (UTF8_DONE);\n\treturn (UTF8_ERROR);\n}\n\n/* Convert UTF-8 character to wide character. */\nenum utf8_state\nutf8_towc(const struct utf8_data *ud, wchar_t *wc)\n{\n#ifdef HAVE_UTF8PROC\n\tswitch (utf8proc_mbtowc(wc, ud->data, ud->size)) {\n#else\n\tswitch (mbtowc(wc, ud->data, ud->size)) {\n#endif\n\tcase -1:\n\t\tlog_debug(\"UTF-8 %.*s, mbtowc() %d\", (int)ud->size, ud->data,\n\t\t    errno);\n\t\tmbtowc(NULL, NULL, MB_CUR_MAX);\n\t\treturn (UTF8_ERROR);\n\tcase 0:\n\t\treturn (UTF8_ERROR);\n\t}\n\tlog_debug(\"UTF-8 %.*s is %05X\", (int)ud->size, ud->data, (u_int)*wc);\n\treturn (UTF8_DONE);\n}\n\n/* Convert wide character to UTF-8 character. */\nenum utf8_state\nutf8_fromwc(wchar_t wc, struct utf8_data *ud)\n{\n\tint\tsize, width;\n\n#ifdef HAVE_UTF8PROC\n\tsize = utf8proc_wctomb(ud->data, wc);\n#else\n\tsize = wctomb(ud->data, wc);\n#endif\n\tif (size < 0) {\n\t\tlog_debug(\"UTF-8 %d, wctomb() %d\", wc, errno);\n\t\twctomb(NULL, 0);\n\t\treturn (UTF8_ERROR);\n\t}\n\tif (size == 0)\n\t\treturn (UTF8_ERROR);\n\tud->size = ud->have = size;\n\tif (utf8_width(ud, &width) == UTF8_DONE) {\n\t\tud->width = width;\n\t\treturn (UTF8_DONE);\n\t}\n\treturn (UTF8_ERROR);\n}\n\n/*\n * Open UTF-8 sequence.\n *\n * 11000010-11011111 C2-DF start of 2-byte sequence\n * 11100000-11101111 E0-EF start of 3-byte sequence\n * 11110000-11110100 F0-F4 start of 4-byte sequence\n */\nenum utf8_state\nutf8_open(struct utf8_data *ud, u_char ch)\n{\n\tmemset(ud, 0, sizeof *ud);\n\tif (ch >= 0xc2 && ch <= 0xdf)\n\t\tud->size = 2;\n\telse if (ch >= 0xe0 && ch <= 0xef)\n\t\tud->size = 3;\n\telse if (ch >= 0xf0 && ch <= 0xf4)\n\t\tud->size = 4;\n\telse\n\t\treturn (UTF8_ERROR);\n\tutf8_append(ud, ch);\n\treturn (UTF8_MORE);\n}\n\n/* Append character to UTF-8, closing if finished. */\nenum utf8_state\nutf8_append(struct utf8_data *ud, u_char ch)\n{\n\tint\twidth;\n\n\tif (ud->have >= ud->size)\n\t\tfatalx(\"UTF-8 character overflow\");\n\tif (ud->size > sizeof ud->data)\n\t\tfatalx(\"UTF-8 character size too large\");\n\n\tif (ud->have != 0 && (ch & 0xc0) != 0x80)\n\t\tud->width = 0xff;\n\n\tud->data[ud->have++] = ch;\n\tif (ud->have != ud->size)\n\t\treturn (UTF8_MORE);\n\n\tif (!utf8_no_width) {\n\t\tif (ud->width == 0xff)\n\t\t\treturn (UTF8_ERROR);\n\t\tif (utf8_width(ud, &width) != UTF8_DONE)\n\t\t\treturn (UTF8_ERROR);\n\t\tud->width = width;\n\t}\n\n\treturn (UTF8_DONE);\n}\n\n/*\n * Encode len characters from src into dst, which is guaranteed to have four\n * bytes available for each character from src (for \\abc or UTF-8) plus space\n * for \\0.\n */\nint\nutf8_strvis(char *dst, const char *src, size_t len, int flag)\n{\n\tstruct utf8_data\t ud;\n\tconst char\t\t*start = dst, *end = src + len;\n\tenum utf8_state\t\t more;\n\tsize_t\t\t\t i;\n\n\twhile (src < end) {\n\t\tif ((more = utf8_open(&ud, *src)) == UTF8_MORE) {\n\t\t\twhile (++src < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\t/* UTF-8 character finished. */\n\t\t\t\tfor (i = 0; i < ud.size; i++)\n\t\t\t\t\t*dst++ = ud.data[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Not a complete, valid UTF-8 character. */\n\t\t\tsrc -= ud.have;\n\t\t}\n\t\tif ((flag & VIS_DQ) && src[0] == '$' && src < end - 1) {\n\t\t\tif (isalpha((u_char)src[1]) ||\n\t\t\t    src[1] == '_' ||\n\t\t\t    src[1] == '{')\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = '$';\n\t\t} else if (src < end - 1)\n\t\t\tdst = vis(dst, src[0], flag, src[1]);\n\t\telse if (src < end)\n\t\t\tdst = vis(dst, src[0], flag, '\\0');\n\t\tsrc++;\n\t}\n\t*dst = '\\0';\n\treturn (dst - start);\n}\n\n/* Same as utf8_strvis but allocate the buffer. */\nint\nutf8_stravis(char **dst, const char *src, int flag)\n{\n\tchar\t*buf;\n\tint\t len;\n\n\tbuf = xreallocarray(NULL, 4, strlen(src) + 1);\n\tlen = utf8_strvis(buf, src, strlen(src), flag);\n\n\t*dst = xrealloc(buf, len + 1);\n\treturn (len);\n}\n\n/* Same as utf8_strvis but allocate the buffer. */\nint\nutf8_stravisx(char **dst, const char *src, size_t srclen, int flag)\n{\n\tchar\t*buf;\n\tint\t len;\n\n\tbuf = xreallocarray(NULL, 4, srclen + 1);\n\tlen = utf8_strvis(buf, src, srclen, flag);\n\n\t*dst = xrealloc(buf, len + 1);\n\treturn (len);\n}\n\n/* Does this string contain anything that isn't valid UTF-8? */\nint\nutf8_isvalid(const char *s)\n{\n\tstruct utf8_data ud;\n\tconst char\t*end;\n\tenum utf8_state\t more;\n\n\tend = s + strlen(s);\n\twhile (s < end) {\n\t\tif ((more = utf8_open(&ud, *s)) == UTF8_MORE) {\n\t\t\twhile (++s < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *s);\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\tcontinue;\n\t\t\treturn (0);\n\t\t}\n\t\tif (*s < 0x20 || *s > 0x7e)\n\t\t\treturn (0);\n\t\ts++;\n\t}\n\treturn (1);\n}\n\n/*\n * Sanitize a string, changing any UTF-8 characters to '_'. Caller should free\n * the returned string. Anything not valid printable ASCII or UTF-8 is\n * stripped.\n */\nchar *\nutf8_sanitize(const char *src)\n{\n\tchar\t\t*dst = NULL;\n\tsize_t\t\t n = 0;\n\tenum utf8_state\t more;\n\tstruct utf8_data ud;\n\tu_int\t\t i;\n\n\twhile (*src != '\\0') {\n\t\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\t\tif ((more = utf8_open(&ud, *src)) == UTF8_MORE) {\n\t\t\twhile (*++src != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tdst = xreallocarray(dst, n + ud.width,\n\t\t\t\t    sizeof *dst);\n\t\t\t\tfor (i = 0; i < ud.width; i++)\n\t\t\t\t\tdst[n++] = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsrc -= ud.have;\n\t\t}\n\t\tif (*src > 0x1f && *src < 0x7f)\n\t\t\tdst[n++] = *src;\n\t\telse\n\t\t\tdst[n++] = '_';\n\t\tsrc++;\n\t}\n\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\tdst[n] = '\\0';\n\treturn (dst);\n}\n\n/* Get UTF-8 buffer length. */\nsize_t\nutf8_strlen(const struct utf8_data *s)\n{\n\tsize_t\ti;\n\n\tfor (i = 0; s[i].size != 0; i++)\n\t\t/* nothing */;\n\treturn (i);\n}\n\n/* Get UTF-8 string width. */\nu_int\nutf8_strwidth(const struct utf8_data *s, ssize_t n)\n{\n\tssize_t\ti;\n\tu_int\twidth = 0;\n\n\tfor (i = 0; s[i].size != 0; i++) {\n\t\tif (n != -1 && n == i)\n\t\t\tbreak;\n\t\twidth += s[i].width;\n\t}\n\treturn (width);\n}\n\n/*\n * Convert a string into a buffer of UTF-8 characters. Terminated by size == 0.\n * Caller frees.\n */\nstruct utf8_data *\nutf8_fromcstr(const char *src)\n{\n\tstruct utf8_data\t*dst = NULL;\n\tsize_t\t\t\t n = 0;\n\tenum utf8_state\t\t more;\n\n\twhile (*src != '\\0') {\n\t\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\t\tif ((more = utf8_open(&dst[n], *src)) == UTF8_MORE) {\n\t\t\twhile (*++src != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&dst[n], *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsrc -= dst[n].have;\n\t\t}\n\t\tutf8_set(&dst[n], *src);\n\t\tn++;\n\t\tsrc++;\n\t}\n\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\tdst[n].size = 0;\n\treturn (dst);\n}\n\n/* Convert from a buffer of UTF-8 characters into a string. Caller frees. */\nchar *\nutf8_tocstr(struct utf8_data *src)\n{\n\tchar\t*dst = NULL;\n\tsize_t\t n = 0;\n\n\tfor(; src->size != 0; src++) {\n\t\tdst = xreallocarray(dst, n + src->size, 1);\n\t\tmemcpy(dst + n, src->data, src->size);\n\t\tn += src->size;\n\t}\n\tdst = xreallocarray(dst, n + 1, 1);\n\tdst[n] = '\\0';\n\treturn (dst);\n}\n\n/* Get width of UTF-8 string. */\nu_int\nutf8_cstrwidth(const char *s)\n{\n\tstruct utf8_data\ttmp;\n\tu_int\t\t\twidth;\n\tenum utf8_state\t\tmore;\n\n\twidth = 0;\n\twhile (*s != '\\0') {\n\t\tif ((more = utf8_open(&tmp, *s)) == UTF8_MORE) {\n\t\t\twhile (*++s != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&tmp, *s);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\twidth += tmp.width;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts -= tmp.have;\n\t\t}\n\t\tif (*s > 0x1f && *s != 0x7f)\n\t\t\twidth++;\n\t\ts++;\n\t}\n\treturn (width);\n}\n\n/* Pad UTF-8 string to width on the left. Caller frees. */\nchar *\nutf8_padcstr(const char *s, u_int width)\n{\n\tsize_t\t slen;\n\tchar\t*out;\n\tu_int\t n, i;\n\n\tn = utf8_cstrwidth(s);\n\tif (n >= width)\n\t\treturn (xstrdup(s));\n\n\tslen = strlen(s);\n\tout = xmalloc(slen + 1 + (width - n));\n\tmemcpy(out, s, slen);\n\tfor (i = n; i < width; i++)\n\t\tout[slen++] = ' ';\n\tout[slen] = '\\0';\n\treturn (out);\n}\n\n/* Pad UTF-8 string to width on the right. Caller frees. */\nchar *\nutf8_rpadcstr(const char *s, u_int width)\n{\n\tsize_t\t slen;\n\tchar\t*out;\n\tu_int\t n, i;\n\n\tn = utf8_cstrwidth(s);\n\tif (n >= width)\n\t\treturn (xstrdup(s));\n\n\tslen = strlen(s);\n\tout = xmalloc(slen + 1 + (width - n));\n\tfor (i = 0; i < width - n; i++)\n\t\tout[i] = ' ';\n\tmemcpy(out + i, s, slen);\n\tout[i + slen] = '\\0';\n\treturn (out);\n}\n\nint\nutf8_cstrhas(const char *s, const struct utf8_data *ud)\n{\n\tstruct utf8_data\t*copy, *loop;\n\tint\t\t\t found = 0;\n\n\tcopy = utf8_fromcstr(s);\n\tfor (loop = copy; loop->size != 0; loop++) {\n\t\tif (loop->size != ud->size)\n\t\t\tcontinue;\n\t\tif (memcmp(loop->data, ud->data, loop->size) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(copy);\n\n\treturn (found);\n}\n"
        },
        {
          "name": "window-buffer.c",
          "type": "blob",
          "size": 13.80078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2017 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic struct screen\t*window_buffer_init(struct window_mode_entry *,\n\t\t\t     struct cmd_find_state *, struct args *);\nstatic void\t\t window_buffer_free(struct window_mode_entry *);\nstatic void\t\t window_buffer_resize(struct window_mode_entry *, u_int,\n\t\t\t     u_int);\nstatic void\t\t window_buffer_update(struct window_mode_entry *);\nstatic void\t\t window_buffer_key(struct window_mode_entry *,\n\t\t\t     struct client *, struct session *,\n\t\t\t     struct winlink *, key_code, struct mouse_event *);\n\n#define WINDOW_BUFFER_DEFAULT_COMMAND \"paste-buffer -p -b '%%'\"\n\n#define WINDOW_BUFFER_DEFAULT_FORMAT \\\n\t\"#{t/p:buffer_created}: #{buffer_sample}\"\n\n#define WINDOW_BUFFER_DEFAULT_KEY_FORMAT \\\n\t\"#{?#{e|<:#{line},10},\" \\\n\t\t\"#{line}\" \\\n\t\",\" \\\n\t\t\"#{?#{e|<:#{line},36},\"\t\\\n\t        \t\"M-#{a:#{e|+:97,#{e|-:#{line},10}}}\" \\\n\t\t\",\" \\\n\t        \t\"\" \\\n\t\t\"}\" \\\n\t\"}\"\n\nstatic const struct menu_item window_buffer_menu_items[] = {\n\t{ \"Paste\", 'p', NULL },\n\t{ \"Paste Tagged\", 'P', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Tag\", 't', NULL },\n\t{ \"Tag All\", '\\024', NULL },\n\t{ \"Tag None\", 'T', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Delete\", 'd', NULL },\n\t{ \"Delete Tagged\", 'D', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Cancel\", 'q', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nconst struct window_mode window_buffer_mode = {\n\t.name = \"buffer-mode\",\n\t.default_format = WINDOW_BUFFER_DEFAULT_FORMAT,\n\n\t.init = window_buffer_init,\n\t.free = window_buffer_free,\n\t.resize = window_buffer_resize,\n\t.update = window_buffer_update,\n\t.key = window_buffer_key,\n};\n\nenum window_buffer_sort_type {\n\tWINDOW_BUFFER_BY_TIME,\n\tWINDOW_BUFFER_BY_NAME,\n\tWINDOW_BUFFER_BY_SIZE,\n};\nstatic const char *window_buffer_sort_list[] = {\n\t\"time\",\n\t\"name\",\n\t\"size\"\n};\nstatic struct mode_tree_sort_criteria *window_buffer_sort;\n\nstruct window_buffer_itemdata {\n\tconst char\t*name;\n\tu_int\t\t order;\n\tsize_t\t\t size;\n};\n\nstruct window_buffer_modedata {\n\tstruct window_pane\t\t *wp;\n\tstruct cmd_find_state\t\t  fs;\n\n\tstruct mode_tree_data\t\t *data;\n\tchar\t\t\t\t *command;\n\tchar\t\t\t\t *format;\n\tchar\t\t\t\t *key_format;\n\n\tstruct window_buffer_itemdata\t**item_list;\n\tu_int\t\t\t\t  item_size;\n};\n\nstruct window_buffer_editdata {\n\tu_int\t\t\t wp_id;\n\tchar\t\t\t*name;\n\tstruct paste_buffer\t*pb;\n};\n\nstatic struct window_buffer_itemdata *\nwindow_buffer_add_item(struct window_buffer_modedata *data)\n{\n\tstruct window_buffer_itemdata\t*item;\n\n\tdata->item_list = xreallocarray(data->item_list, data->item_size + 1,\n\t    sizeof *data->item_list);\n\titem = data->item_list[data->item_size++] = xcalloc(1, sizeof *item);\n\treturn (item);\n}\n\nstatic void\nwindow_buffer_free_item(struct window_buffer_itemdata *item)\n{\n\tfree((void *)item->name);\n\tfree(item);\n}\n\nstatic int\nwindow_buffer_cmp(const void *a0, const void *b0)\n{\n\tconst struct window_buffer_itemdata *const\t*a = a0;\n\tconst struct window_buffer_itemdata *const\t*b = b0;\n\tint\t\t\t\t\t\t result = 0;\n\n\tif (window_buffer_sort->field == WINDOW_BUFFER_BY_TIME)\n\t\tresult = (*b)->order - (*a)->order;\n\telse if (window_buffer_sort->field == WINDOW_BUFFER_BY_SIZE)\n\t\tresult = (*b)->size - (*a)->size;\n\n\t/* Use WINDOW_BUFFER_BY_NAME as default order and tie breaker. */\n\tif (result == 0)\n\t\tresult = strcmp((*a)->name, (*b)->name);\n\n\tif (window_buffer_sort->reversed)\n\t\tresult = -result;\n\treturn (result);\n}\n\nstatic void\nwindow_buffer_build(void *modedata, struct mode_tree_sort_criteria *sort_crit,\n    __unused uint64_t *tag, const char *filter)\n{\n\tstruct window_buffer_modedata\t*data = modedata;\n\tstruct window_buffer_itemdata\t*item;\n\tu_int\t\t\t\t i;\n\tstruct paste_buffer\t\t*pb;\n\tchar\t\t\t\t*text, *cp;\n\tstruct format_tree\t\t*ft;\n\tstruct session\t\t\t*s = NULL;\n\tstruct winlink\t\t\t*wl = NULL;\n\tstruct window_pane\t\t*wp = NULL;\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_buffer_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\tdata->item_list = NULL;\n\tdata->item_size = 0;\n\n\tpb = NULL;\n\twhile ((pb = paste_walk(pb)) != NULL) {\n\t\titem = window_buffer_add_item(data);\n\t\titem->name = xstrdup(paste_buffer_name(pb));\n\t\tpaste_buffer_data(pb, &item->size);\n\t\titem->order = paste_buffer_order(pb);\n\t}\n\n\twindow_buffer_sort = sort_crit;\n\tqsort(data->item_list, data->item_size, sizeof *data->item_list,\n\t    window_buffer_cmp);\n\n\tif (cmd_find_valid_state(&data->fs)) {\n\t\ts = data->fs.s;\n\t\twl = data->fs.wl;\n\t\twp = data->fs.wp;\n\t}\n\n\tfor (i = 0; i < data->item_size; i++) {\n\t\titem = data->item_list[i];\n\n\t\tpb = paste_get_name(item->name);\n\t\tif (pb == NULL)\n\t\t\tcontinue;\n\t\tft = format_create(NULL, NULL, FORMAT_NONE, 0);\n\t\tformat_defaults(ft, NULL, s, wl, wp);\n\t\tformat_defaults_paste_buffer(ft, pb);\n\n\t\tif (filter != NULL) {\n\t\t\tcp = format_expand(ft, filter);\n\t\t\tif (!format_true(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tformat_free(ft);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t}\n\n\t\ttext = format_expand(ft, data->format);\n\t\tmode_tree_add(data->data, NULL, item, item->order, item->name,\n\t\t    text, -1);\n\t\tfree(text);\n\n\t\tformat_free(ft);\n\t}\n\n}\n\nstatic void\nwindow_buffer_draw(__unused void *modedata, void *itemdata,\n    struct screen_write_ctx *ctx, u_int sx, u_int sy)\n{\n\tstruct window_buffer_itemdata\t*item = itemdata;\n\tstruct paste_buffer\t\t*pb;\n\tconst char\t\t\t*pdata, *start, *end;\n\tchar\t\t\t\t*buf = NULL;\n\tsize_t\t\t\t\t psize;\n\tu_int\t\t\t\t i, cx = ctx->s->cx, cy = ctx->s->cy;\n\n\tpb = paste_get_name(item->name);\n\tif (pb == NULL)\n\t\treturn;\n\n\tpdata = end = paste_buffer_data(pb, &psize);\n\tfor (i = 0; i < sy; i++) {\n\t\tstart = end;\n\t\twhile (end != pdata + psize && *end != '\\n')\n\t\t\tend++;\n\t\tbuf = xreallocarray(buf, 4, end - start + 1);\n\t\tutf8_strvis(buf, start, end - start,\n\t\t    VIS_OCTAL|VIS_CSTYLE|VIS_TAB);\n\t\tif (*buf != '\\0') {\n\t\t\tscreen_write_cursormove(ctx, cx, cy + i, 0);\n\t\t\tscreen_write_nputs(ctx, sx, &grid_default_cell, \"%s\",\n\t\t\t    buf);\n\t\t}\n\n\t\tif (end == pdata + psize)\n\t\t\tbreak;\n\t\tend++;\n\t}\n\tfree(buf);\n}\n\nstatic int\nwindow_buffer_search(__unused void *modedata, void *itemdata, const char *ss)\n{\n\tstruct window_buffer_itemdata\t*item = itemdata;\n\tstruct paste_buffer\t\t*pb;\n\tconst char\t\t\t*bufdata;\n\tsize_t\t\t\t\t bufsize;\n\n\tif ((pb = paste_get_name(item->name)) == NULL)\n\t\treturn (0);\n\tif (strstr(item->name, ss) != NULL)\n\t\treturn (1);\n\tbufdata = paste_buffer_data(pb, &bufsize);\n\treturn (memmem(bufdata, bufsize, ss, strlen(ss)) != NULL);\n}\n\nstatic void\nwindow_buffer_menu(void *modedata, struct client *c, key_code key)\n{\n\tstruct window_buffer_modedata\t*data = modedata;\n\tstruct window_pane\t\t*wp = data->wp;\n\tstruct window_mode_entry\t*wme;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->data != modedata)\n\t\treturn;\n\twindow_buffer_key(wme, c, NULL, NULL, key, NULL);\n}\n\nstatic key_code\nwindow_buffer_get_key(void *modedata, void *itemdata, u_int line)\n{\n\tstruct window_buffer_modedata\t*data = modedata;\n\tstruct window_buffer_itemdata\t*item = itemdata;\n\tstruct format_tree\t\t*ft;\n\tstruct session\t\t\t*s = NULL;\n\tstruct winlink\t\t\t*wl = NULL;\n\tstruct window_pane\t\t*wp = NULL;\n\tstruct paste_buffer\t\t*pb;\n\tchar\t\t\t\t*expanded;\n\tkey_code\t\t\t key;\n\n\tif (cmd_find_valid_state(&data->fs)) {\n\t\ts = data->fs.s;\n\t\twl = data->fs.wl;\n\t\twp = data->fs.wp;\n\t}\n\tpb = paste_get_name(item->name);\n\tif (pb == NULL)\n\t\treturn (KEYC_NONE);\n\n\tft = format_create(NULL, NULL, FORMAT_NONE, 0);\n\tformat_defaults(ft, NULL, NULL, 0, NULL);\n\tformat_defaults(ft, NULL, s, wl, wp);\n\tformat_defaults_paste_buffer(ft, pb);\n\tformat_add(ft, \"line\", \"%u\", line);\n\n\texpanded = format_expand(ft, data->key_format);\n\tkey = key_string_lookup_string(expanded);\n\tfree(expanded);\n\tformat_free(ft);\n\treturn (key);\n}\n\nstatic struct screen *\nwindow_buffer_init(struct window_mode_entry *wme, struct cmd_find_state *fs,\n    struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_buffer_modedata\t*data;\n\tstruct screen\t\t\t*s;\n\n\twme->data = data = xcalloc(1, sizeof *data);\n\tdata->wp = wp;\n\tcmd_find_copy_state(&data->fs, fs);\n\n\tif (args == NULL || !args_has(args, 'F'))\n\t\tdata->format = xstrdup(WINDOW_BUFFER_DEFAULT_FORMAT);\n\telse\n\t\tdata->format = xstrdup(args_get(args, 'F'));\n\tif (args == NULL || !args_has(args, 'K'))\n\t\tdata->key_format = xstrdup(WINDOW_BUFFER_DEFAULT_KEY_FORMAT);\n\telse\n\t\tdata->key_format = xstrdup(args_get(args, 'K'));\n\tif (args == NULL || args_count(args) == 0)\n\t\tdata->command = xstrdup(WINDOW_BUFFER_DEFAULT_COMMAND);\n\telse\n\t\tdata->command = xstrdup(args_string(args, 0));\n\n\tdata->data = mode_tree_start(wp, args, window_buffer_build,\n\t    window_buffer_draw, window_buffer_search, window_buffer_menu, NULL,\n\t    window_buffer_get_key, data, window_buffer_menu_items,\n\t    window_buffer_sort_list, nitems(window_buffer_sort_list), &s);\n\tmode_tree_zoom(data->data, args);\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\n\treturn (s);\n}\n\nstatic void\nwindow_buffer_free(struct window_mode_entry *wme)\n{\n\tstruct window_buffer_modedata\t*data = wme->data;\n\tu_int\t\t\t\t i;\n\n\tif (data == NULL)\n\t\treturn;\n\n\tmode_tree_free(data->data);\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_buffer_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\n\tfree(data->format);\n\tfree(data->key_format);\n\tfree(data->command);\n\n\tfree(data);\n}\n\nstatic void\nwindow_buffer_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_buffer_modedata\t*data = wme->data;\n\n\tmode_tree_resize(data->data, sx, sy);\n}\n\nstatic void\nwindow_buffer_update(struct window_mode_entry *wme)\n{\n\tstruct window_buffer_modedata\t*data = wme->data;\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n}\n\nstatic void\nwindow_buffer_do_delete(void *modedata, void *itemdata,\n    __unused struct client *c, __unused key_code key)\n{\n\tstruct window_buffer_modedata\t*data = modedata;\n\tstruct window_buffer_itemdata\t*item = itemdata;\n\tstruct paste_buffer\t\t*pb;\n\n\tif (item == mode_tree_get_current(data->data) &&\n\t    !mode_tree_down(data->data, 0)) {\n\t\t/*\n\t\t *If we were unable to select the item further down we are at\n\t\t * the end of the list. Move one element up instead, to make\n\t\t * sure that we preserve a valid selection or we risk having\n\t\t * the tree build logic reset it to the first item.\n\t\t */\n\t\tmode_tree_up(data->data, 0);\n\t}\n\n\tif ((pb = paste_get_name(item->name)) != NULL)\n\t\tpaste_free(pb);\n}\n\nstatic void\nwindow_buffer_do_paste(void *modedata, void *itemdata, struct client *c,\n    __unused key_code key)\n{\n\tstruct window_buffer_modedata\t*data = modedata;\n\tstruct window_buffer_itemdata\t*item = itemdata;\n\n\tif (paste_get_name(item->name) != NULL)\n\t\tmode_tree_run_command(c, NULL, data->command, item->name);\n}\n\nstatic void\nwindow_buffer_finish_edit(struct window_buffer_editdata *ed)\n{\n\tfree(ed->name);\n\tfree(ed);\n}\n\nstatic void\nwindow_buffer_edit_close_cb(char *buf, size_t len, void *arg)\n{\n\tstruct window_buffer_editdata\t*ed = arg;\n\tsize_t\t\t\t\t oldlen;\n\tconst char\t\t\t*oldbuf;\n\tstruct paste_buffer\t\t*pb;\n\tstruct window_pane\t\t*wp;\n\tstruct window_buffer_modedata\t*data;\n\tstruct window_mode_entry\t*wme;\n\n\tif (buf == NULL || len == 0) {\n\t\twindow_buffer_finish_edit(ed);\n\t\treturn;\n\t}\n\n\tpb = paste_get_name(ed->name);\n\tif (pb == NULL || pb != ed->pb) {\n\t\twindow_buffer_finish_edit(ed);\n\t\treturn;\n\t}\n\n\toldbuf = paste_buffer_data(pb, &oldlen);\n\tif (oldlen != '\\0' &&\n\t    oldbuf[oldlen - 1] != '\\n' &&\n\t    buf[len - 1] == '\\n')\n\t\tlen--;\n\tif (len != 0)\n\t\tpaste_replace(pb, buf, len);\n\n\twp = window_pane_find_by_id(ed->wp_id);\n\tif (wp != NULL) {\n\t\twme = TAILQ_FIRST(&wp->modes);\n\t\tif (wme->mode == &window_buffer_mode) {\n\t\t\tdata = wme->data;\n\t\t\tmode_tree_build(data->data);\n\t\t\tmode_tree_draw(data->data);\n\t\t}\n\t\twp->flags |= PANE_REDRAW;\n\t}\n\twindow_buffer_finish_edit(ed);\n}\n\nstatic void\nwindow_buffer_start_edit(struct window_buffer_modedata *data,\n    struct window_buffer_itemdata *item, struct client *c)\n{\n\tstruct paste_buffer\t\t*pb;\n\tconst char\t\t\t*buf;\n\tsize_t\t\t\t\t len;\n\tstruct window_buffer_editdata\t*ed;\n\n\tif ((pb = paste_get_name(item->name)) == NULL)\n\t\treturn;\n\tbuf = paste_buffer_data(pb, &len);\n\n\ted = xcalloc(1, sizeof *ed);\n\ted->wp_id = data->wp->id;\n\ted->name = xstrdup(paste_buffer_name(pb));\n\ted->pb = pb;\n\n\tif (popup_editor(c, buf, len, window_buffer_edit_close_cb, ed) != 0)\n\t\twindow_buffer_finish_edit(ed);\n}\n\nstatic void\nwindow_buffer_key(struct window_mode_entry *wme, struct client *c,\n    __unused struct session *s, __unused struct winlink *wl, key_code key,\n    struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_buffer_modedata\t*data = wme->data;\n\tstruct mode_tree_data\t\t*mtd = data->data;\n\tstruct window_buffer_itemdata\t*item;\n\tint\t\t\t\t finished;\n\n\tif (paste_is_empty()) {\n\t\tfinished = 1;\n\t\tgoto out;\n\t}\n\n\tfinished = mode_tree_key(mtd, c, &key, m, NULL, NULL);\n\tswitch (key) {\n\tcase 'e':\n\t\titem = mode_tree_get_current(mtd);\n\t\twindow_buffer_start_edit(data, item, c);\n\t\tbreak;\n\tcase 'd':\n\t\titem = mode_tree_get_current(mtd);\n\t\twindow_buffer_do_delete(data, item, c, key);\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase 'D':\n\t\tmode_tree_each_tagged(mtd, window_buffer_do_delete, c, key, 0);\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase 'P':\n\t\tmode_tree_each_tagged(mtd, window_buffer_do_paste, c, key, 0);\n\t\tfinished = 1;\n\t\tbreak;\n\tcase 'p':\n\tcase '\\r':\n\t\titem = mode_tree_get_current(mtd);\n\t\twindow_buffer_do_paste(data, item, c, key);\n\t\tfinished = 1;\n\t\tbreak;\n\t}\n\nout:\n\tif (finished || paste_is_empty())\n\t\twindow_pane_reset_mode(wp);\n\telse {\n\t\tmode_tree_draw(mtd);\n\t\twp->flags |= PANE_REDRAW;\n\t}\n}\n"
        },
        {
          "name": "window-client.c",
          "type": "blob",
          "size": 10.8193359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2017 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\nstatic struct screen\t*window_client_init(struct window_mode_entry *,\n\t\t\t     struct cmd_find_state *, struct args *);\nstatic void\t\t window_client_free(struct window_mode_entry *);\nstatic void\t\t window_client_resize(struct window_mode_entry *, u_int,\n\t\t\t     u_int);\nstatic void\t\t window_client_update(struct window_mode_entry *);\nstatic void\t\t window_client_key(struct window_mode_entry *,\n\t\t\t     struct client *, struct session *,\n\t\t\t     struct winlink *, key_code, struct mouse_event *);\n\n#define WINDOW_CLIENT_DEFAULT_COMMAND \"detach-client -t '%%'\"\n\n#define WINDOW_CLIENT_DEFAULT_FORMAT \\\n\t\"#{t/p:client_activity}: session #{session_name}\"\n\n#define WINDOW_CLIENT_DEFAULT_KEY_FORMAT \\\n\t\"#{?#{e|<:#{line},10},\" \\\n\t\t\"#{line}\" \\\n\t\",\" \\\n\t\t\"#{?#{e|<:#{line},36},\"\t\\\n\t        \t\"M-#{a:#{e|+:97,#{e|-:#{line},10}}}\" \\\n\t\t\",\" \\\n\t        \t\"\" \\\n\t\t\"}\" \\\n\t\"}\"\n\nstatic const struct menu_item window_client_menu_items[] = {\n\t{ \"Detach\", 'd', NULL },\n\t{ \"Detach Tagged\", 'D', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Tag\", 't', NULL },\n\t{ \"Tag All\", '\\024', NULL },\n\t{ \"Tag None\", 'T', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Cancel\", 'q', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nconst struct window_mode window_client_mode = {\n\t.name = \"client-mode\",\n\t.default_format = WINDOW_CLIENT_DEFAULT_FORMAT,\n\n\t.init = window_client_init,\n\t.free = window_client_free,\n\t.resize = window_client_resize,\n\t.update = window_client_update,\n\t.key = window_client_key,\n};\n\nenum window_client_sort_type {\n\tWINDOW_CLIENT_BY_NAME,\n\tWINDOW_CLIENT_BY_SIZE,\n\tWINDOW_CLIENT_BY_CREATION_TIME,\n\tWINDOW_CLIENT_BY_ACTIVITY_TIME,\n};\nstatic const char *window_client_sort_list[] = {\n\t\"name\",\n\t\"size\",\n\t\"creation\",\n\t\"activity\"\n};\nstatic struct mode_tree_sort_criteria *window_client_sort;\n\nstruct window_client_itemdata {\n\tstruct client\t*c;\n};\n\nstruct window_client_modedata {\n\tstruct window_pane\t\t *wp;\n\n\tstruct mode_tree_data\t\t *data;\n\tchar\t\t\t\t *format;\n\tchar\t\t\t\t *key_format;\n\tchar\t\t\t\t *command;\n\n\tstruct window_client_itemdata\t**item_list;\n\tu_int\t\t\t\t  item_size;\n};\n\nstatic struct window_client_itemdata *\nwindow_client_add_item(struct window_client_modedata *data)\n{\n\tstruct window_client_itemdata\t*item;\n\n\tdata->item_list = xreallocarray(data->item_list, data->item_size + 1,\n\t    sizeof *data->item_list);\n\titem = data->item_list[data->item_size++] = xcalloc(1, sizeof *item);\n\treturn (item);\n}\n\nstatic void\nwindow_client_free_item(struct window_client_itemdata *item)\n{\n\tserver_client_unref(item->c);\n\tfree(item);\n}\n\nstatic int\nwindow_client_cmp(const void *a0, const void *b0)\n{\n\tconst struct window_client_itemdata *const\t*a = a0;\n\tconst struct window_client_itemdata *const\t*b = b0;\n\tconst struct window_client_itemdata\t\t*itema = *a;\n\tconst struct window_client_itemdata\t\t*itemb = *b;\n\tstruct client\t\t\t\t\t*ca = itema->c;\n\tstruct client\t\t\t\t\t*cb = itemb->c;\n\tint\t\t\t\t\t\t result = 0;\n\n\tswitch (window_client_sort->field) {\n\tcase WINDOW_CLIENT_BY_SIZE:\n\t\tresult = ca->tty.sx - cb->tty.sx;\n\t\tif (result == 0)\n\t\t\tresult = ca->tty.sy - cb->tty.sy;\n\t\tbreak;\n\tcase WINDOW_CLIENT_BY_CREATION_TIME:\n\t\tif (timercmp(&ca->creation_time, &cb->creation_time, >))\n\t\t\tresult = -1;\n\t\telse if (timercmp(&ca->creation_time, &cb->creation_time, <))\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase WINDOW_CLIENT_BY_ACTIVITY_TIME:\n\t\tif (timercmp(&ca->activity_time, &cb->activity_time, >))\n\t\t\tresult = -1;\n\t\telse if (timercmp(&ca->activity_time, &cb->activity_time, <))\n\t\t\tresult = 1;\n\t\tbreak;\n\t}\n\n\t/* Use WINDOW_CLIENT_BY_NAME as default order and tie breaker. */\n\tif (result == 0)\n\t\tresult = strcmp(ca->name, cb->name);\n\n\tif (window_client_sort->reversed)\n\t\tresult = -result;\n\treturn (result);\n}\n\nstatic void\nwindow_client_build(void *modedata, struct mode_tree_sort_criteria *sort_crit,\n    __unused uint64_t *tag, const char *filter)\n{\n\tstruct window_client_modedata\t*data = modedata;\n\tstruct window_client_itemdata\t*item;\n\tu_int\t\t\t\t i;\n\tstruct client\t\t\t*c;\n\tchar\t\t\t\t*text, *cp;\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_client_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\tdata->item_list = NULL;\n\tdata->item_size = 0;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || (c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\t\tcontinue;\n\n\t\titem = window_client_add_item(data);\n\t\titem->c = c;\n\n\t\tc->references++;\n\t}\n\n\twindow_client_sort = sort_crit;\n\tqsort(data->item_list, data->item_size, sizeof *data->item_list,\n\t    window_client_cmp);\n\n\tfor (i = 0; i < data->item_size; i++) {\n\t\titem = data->item_list[i];\n\t\tc = item->c;\n\n\t\tif (filter != NULL) {\n\t\t\tcp = format_single(NULL, filter, c, NULL, NULL, NULL);\n\t\t\tif (!format_true(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t}\n\n\t\ttext = format_single(NULL, data->format, c, NULL, NULL, NULL);\n\t\tmode_tree_add(data->data, NULL, item, (uint64_t)c, c->name,\n\t\t    text, -1);\n\t\tfree(text);\n\t}\n}\n\nstatic void\nwindow_client_draw(__unused void *modedata, void *itemdata,\n    struct screen_write_ctx *ctx, u_int sx, u_int sy)\n{\n\tstruct window_client_itemdata\t*item = itemdata;\n\tstruct client\t\t\t*c = item->c;\n\tstruct screen\t\t\t*s = ctx->s;\n\tstruct window_pane\t\t*wp;\n\tu_int\t\t\t\t cx = s->cx, cy = s->cy, lines, at;\n\n\tif (c->session == NULL || (c->flags & CLIENT_UNATTACHEDFLAGS))\n\t\treturn;\n\twp = c->session->curw->window->active;\n\n\tlines = status_line_size(c);\n\tif (lines >= sy)\n\t\tlines = 0;\n\tif (status_at_line(c) == 0)\n\t\tat = lines;\n\telse\n\t\tat = 0;\n\n\tscreen_write_cursormove(ctx, cx, cy + at, 0);\n\tscreen_write_preview(ctx, &wp->base, sx, sy - 2 - lines);\n\n\tif (at != 0)\n\t\tscreen_write_cursormove(ctx, cx, cy + 2, 0);\n\telse\n\t\tscreen_write_cursormove(ctx, cx, cy + sy - 1 - lines, 0);\n\tscreen_write_hline(ctx, sx, 0, 0, BOX_LINES_DEFAULT, NULL);\n\n\tif (at != 0)\n\t\tscreen_write_cursormove(ctx, cx, cy, 0);\n\telse\n\t\tscreen_write_cursormove(ctx, cx, cy + sy - lines, 0);\n\tscreen_write_fast_copy(ctx, &c->status.screen, 0, 0, sx, lines);\n}\n\nstatic void\nwindow_client_menu(void *modedata, struct client *c, key_code key)\n{\n\tstruct window_client_modedata\t*data = modedata;\n\tstruct window_pane\t\t*wp = data->wp;\n\tstruct window_mode_entry\t*wme;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->data != modedata)\n\t\treturn;\n\twindow_client_key(wme, c, NULL, NULL, key, NULL);\n}\n\nstatic key_code\nwindow_client_get_key(void *modedata, void *itemdata, u_int line)\n{\n\tstruct window_client_modedata\t*data = modedata;\n\tstruct window_client_itemdata\t*item = itemdata;\n\tstruct format_tree\t\t*ft;\n\tchar\t\t\t\t*expanded;\n\tkey_code\t\t\t key;\n\n\tft = format_create(NULL, NULL, FORMAT_NONE, 0);\n\tformat_defaults(ft, item->c, NULL, 0, NULL);\n\tformat_add(ft, \"line\", \"%u\", line);\n\n\texpanded = format_expand(ft, data->key_format);\n\tkey = key_string_lookup_string(expanded);\n\tfree(expanded);\n\tformat_free(ft);\n\treturn (key);\n}\n\nstatic struct screen *\nwindow_client_init(struct window_mode_entry *wme,\n    __unused struct cmd_find_state *fs, struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_client_modedata\t*data;\n\tstruct screen\t\t\t*s;\n\n\twme->data = data = xcalloc(1, sizeof *data);\n\tdata->wp = wp;\n\n\tif (args == NULL || !args_has(args, 'F'))\n\t\tdata->format = xstrdup(WINDOW_CLIENT_DEFAULT_FORMAT);\n\telse\n\t\tdata->format = xstrdup(args_get(args, 'F'));\n\tif (args == NULL || !args_has(args, 'K'))\n\t\tdata->key_format = xstrdup(WINDOW_CLIENT_DEFAULT_KEY_FORMAT);\n\telse\n\t\tdata->key_format = xstrdup(args_get(args, 'K'));\n\tif (args == NULL || args_count(args) == 0)\n\t\tdata->command = xstrdup(WINDOW_CLIENT_DEFAULT_COMMAND);\n\telse\n\t\tdata->command = xstrdup(args_string(args, 0));\n\n\tdata->data = mode_tree_start(wp, args, window_client_build,\n\t    window_client_draw, NULL, window_client_menu, NULL,\n\t    window_client_get_key, data, window_client_menu_items,\n\t    window_client_sort_list, nitems(window_client_sort_list), &s);\n\tmode_tree_zoom(data->data, args);\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\n\treturn (s);\n}\n\nstatic void\nwindow_client_free(struct window_mode_entry *wme)\n{\n\tstruct window_client_modedata\t*data = wme->data;\n\tu_int\t\t\t\t i;\n\n\tif (data == NULL)\n\t\treturn;\n\n\tmode_tree_free(data->data);\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_client_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\n\tfree(data->format);\n\tfree(data->key_format);\n\tfree(data->command);\n\n\tfree(data);\n}\n\nstatic void\nwindow_client_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_client_modedata\t*data = wme->data;\n\n\tmode_tree_resize(data->data, sx, sy);\n}\n\nstatic void\nwindow_client_update(struct window_mode_entry *wme)\n{\n\tstruct window_client_modedata\t*data = wme->data;\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n}\n\nstatic void\nwindow_client_do_detach(void *modedata, void *itemdata,\n    __unused struct client *c, key_code key)\n{\n\tstruct window_client_modedata\t*data = modedata;\n\tstruct window_client_itemdata\t*item = itemdata;\n\n\tif (item == mode_tree_get_current(data->data))\n\t\tmode_tree_down(data->data, 0);\n\tif (key == 'd' || key == 'D')\n\t\tserver_client_detach(item->c, MSG_DETACH);\n\telse if (key == 'x' || key == 'X')\n\t\tserver_client_detach(item->c, MSG_DETACHKILL);\n\telse if (key == 'z' || key == 'Z')\n\t\tserver_client_suspend(item->c);\n}\n\nstatic void\nwindow_client_key(struct window_mode_entry *wme, struct client *c,\n    __unused struct session *s, __unused struct winlink *wl, key_code key,\n    struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_client_modedata\t*data = wme->data;\n\tstruct mode_tree_data\t\t*mtd = data->data;\n\tstruct window_client_itemdata\t*item;\n\tint\t\t\t\t finished;\n\n\tfinished = mode_tree_key(mtd, c, &key, m, NULL, NULL);\n\tswitch (key) {\n\tcase 'd':\n\tcase 'x':\n\tcase 'z':\n\t\titem = mode_tree_get_current(mtd);\n\t\twindow_client_do_detach(data, item, c, key);\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase 'D':\n\tcase 'X':\n\tcase 'Z':\n\t\tmode_tree_each_tagged(mtd, window_client_do_detach, c, key, 0);\n\t\tmode_tree_build(mtd);\n\t\tbreak;\n\tcase '\\r':\n\t\titem = mode_tree_get_current(mtd);\n\t\tmode_tree_run_command(c, NULL, data->command, item->c->ttyname);\n\t\tfinished = 1;\n\t\tbreak;\n\t}\n\tif (finished || server_client_how_many() == 0)\n\t\twindow_pane_reset_mode(wp);\n\telse {\n\t\tmode_tree_draw(mtd);\n\t\twp->flags |= PANE_REDRAW;\n\t}\n}\n"
        },
        {
          "name": "window-clock.c",
          "type": "blob",
          "size": 6.9052734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\nstatic struct screen *window_clock_init(struct window_mode_entry *,\n\t\t    struct cmd_find_state *, struct args *);\nstatic void\twindow_clock_free(struct window_mode_entry *);\nstatic void\twindow_clock_resize(struct window_mode_entry *, u_int, u_int);\nstatic void\twindow_clock_key(struct window_mode_entry *, struct client *,\n\t\t     struct session *, struct winlink *, key_code,\n\t\t     struct mouse_event *);\n\nstatic void\twindow_clock_timer_callback(int, short, void *);\nstatic void\twindow_clock_draw_screen(struct window_mode_entry *);\n\nconst struct window_mode window_clock_mode = {\n\t.name = \"clock-mode\",\n\n\t.init = window_clock_init,\n\t.free = window_clock_free,\n\t.resize = window_clock_resize,\n\t.key = window_clock_key,\n};\n\nstruct window_clock_mode_data {\n\tstruct screen\t        screen;\n\ttime_t\t\t\ttim;\n\tstruct event\t\ttimer;\n};\n\nconst char window_clock_table[14][5][5] = {\n\t{ { 1,1,1,1,1 }, /* 0 */\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 0,0,0,0,1 }, /* 1 */\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 2 */\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 3 */\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,0,0,0,1 }, /* 4 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 5 */\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 6 */\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 7 */\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 8 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 9 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 0,0,0,0,0 }, /* : */\n\t  { 0,0,1,0,0 },\n\t  { 0,0,0,0,0 },\n\t  { 0,0,1,0,0 },\n\t  { 0,0,0,0,0 } },\n\t{ { 1,1,1,1,1 }, /* A */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* P */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,0 },\n\t  { 1,0,0,0,0 } },\n\t{ { 1,0,0,0,1 }, /* M */\n\t  { 1,1,0,1,1 },\n\t  { 1,0,1,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 } },\n};\n\nstatic void\nwindow_clock_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window_mode_entry\t*wme = arg;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_clock_mode_data\t*data = wme->data;\n\tstruct tm\t\t\t now, then;\n\ttime_t\t\t\t\t t;\n\tstruct timeval\t\t\t tv = { .tv_sec = 1 };\n\n\tevtimer_del(&data->timer);\n\tevtimer_add(&data->timer, &tv);\n\n\tif (TAILQ_FIRST(&wp->modes) != wme)\n\t\treturn;\n\n\tt = time(NULL);\n\tgmtime_r(&t, &now);\n\tgmtime_r(&data->tim, &then);\n\tif (now.tm_min == then.tm_min)\n\t\treturn;\n\tdata->tim = t;\n\n\twindow_clock_draw_screen(wme);\n\twp->flags |= PANE_REDRAW;\n}\n\nstatic struct screen *\nwindow_clock_init(struct window_mode_entry *wme,\n    __unused struct cmd_find_state *fs, __unused struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_clock_mode_data\t*data;\n\tstruct screen\t\t\t*s;\n\tstruct timeval\t\t\t tv = { .tv_sec = 1 };\n\n\twme->data = data = xmalloc(sizeof *data);\n\tdata->tim = time(NULL);\n\n\tevtimer_set(&data->timer, window_clock_timer_callback, wme);\n\tevtimer_add(&data->timer, &tv);\n\n\ts = &data->screen;\n\tscreen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);\n\ts->mode &= ~MODE_CURSOR;\n\n\twindow_clock_draw_screen(wme);\n\n\treturn (s);\n}\n\nstatic void\nwindow_clock_free(struct window_mode_entry *wme)\n{\n\tstruct window_clock_mode_data\t*data = wme->data;\n\n\tevtimer_del(&data->timer);\n\tscreen_free(&data->screen);\n\tfree(data);\n}\n\nstatic void\nwindow_clock_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_clock_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tscreen_resize(s, sx, sy, 0);\n\twindow_clock_draw_screen(wme);\n}\n\nstatic void\nwindow_clock_key(struct window_mode_entry *wme, __unused struct client *c,\n    __unused struct session *s, __unused struct winlink *wl,\n    __unused key_code key, __unused struct mouse_event *m)\n{\n\twindow_pane_reset_mode(wme->wp);\n}\n\nstatic void\nwindow_clock_draw_screen(struct window_mode_entry *wme)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_clock_mode_data\t*data = wme->data;\n\tstruct screen_write_ctx\t \t ctx;\n\tint\t\t\t\t colour, style;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid_cell\t\t gc;\n\tchar\t\t\t\t tim[64], *ptr;\n\ttime_t\t\t\t\t t;\n\tstruct tm\t\t\t*tm;\n\tu_int\t\t\t\t i, j, x, y, idx;\n\n\tcolour = options_get_number(wp->window->options, \"clock-mode-colour\");\n\tstyle = options_get_number(wp->window->options, \"clock-mode-style\");\n\n\tscreen_write_start(&ctx, s);\n\n\tt = time(NULL);\n\ttm = localtime(&t);\n\tif (style == 0) {\n\t\tstrftime(tim, sizeof tim, \"%l:%M \", localtime(&t));\n\t\tif (tm->tm_hour >= 12)\n\t\t\tstrlcat(tim, \"PM\", sizeof tim);\n\t\telse\n\t\t\tstrlcat(tim, \"AM\", sizeof tim);\n\t} else\n\t\tstrftime(tim, sizeof tim, \"%H:%M\", tm);\n\n\tscreen_write_clearscreen(&ctx, 8);\n\n\tif (screen_size_x(s) < 6 * strlen(tim) || screen_size_y(s) < 6) {\n\t\tif (screen_size_x(s) >= strlen(tim) && screen_size_y(s) != 0) {\n\t\t\tx = (screen_size_x(s) / 2) - (strlen(tim) / 2);\n\t\t\ty = screen_size_y(s) / 2;\n\t\t\tscreen_write_cursormove(&ctx, x, y, 0);\n\n\t\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\t\tgc.flags |= GRID_FLAG_NOPALETTE;\n\t\t\tgc.fg = colour;\n\t\t\tscreen_write_puts(&ctx, &gc, \"%s\", tim);\n\t\t}\n\n\t\tscreen_write_stop(&ctx);\n\t\treturn;\n\t}\n\n\tx = (screen_size_x(s) / 2) - 3 * strlen(tim);\n\ty = (screen_size_y(s) / 2) - 3;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tgc.flags |= GRID_FLAG_NOPALETTE;\n\tgc.bg = colour;\n\tfor (ptr = tim; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr >= '0' && *ptr <= '9')\n\t\t\tidx = *ptr - '0';\n\t\telse if (*ptr == ':')\n\t\t\tidx = 10;\n\t\telse if (*ptr == 'A')\n\t\t\tidx = 11;\n\t\telse if (*ptr == 'P')\n\t\t\tidx = 12;\n\t\telse if (*ptr == 'M')\n\t\t\tidx = 13;\n\t\telse {\n\t\t\tx += 6;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tscreen_write_cursormove(&ctx, x + i, y + j, 0);\n\t\t\t\tif (window_clock_table[idx][j][i])\n\t\t\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t\t\t}\n\t\t}\n\t\tx += 6;\n\t}\n\n\tscreen_write_stop(&ctx);\n}\n"
        },
        {
          "name": "window-copy.c",
          "type": "blob",
          "size": 152.927734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <regex.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\nstruct window_copy_mode_data;\n\nstatic const char *window_copy_key_table(struct window_mode_entry *);\nstatic void\twindow_copy_command(struct window_mode_entry *, struct client *,\n\t\t    struct session *, struct winlink *, struct args *,\n\t\t    struct mouse_event *);\nstatic struct screen *window_copy_init(struct window_mode_entry *,\n\t\t    struct cmd_find_state *, struct args *);\nstatic struct screen *window_copy_view_init(struct window_mode_entry *,\n\t\t    struct cmd_find_state *, struct args *);\nstatic void\twindow_copy_free(struct window_mode_entry *);\nstatic void\twindow_copy_resize(struct window_mode_entry *, u_int, u_int);\nstatic void\twindow_copy_formats(struct window_mode_entry *,\n\t\t    struct format_tree *);\nstatic void\twindow_copy_scroll1(struct window_mode_entry *,\n\t\t    struct window_pane *wp, int, u_int, int);\nstatic void\twindow_copy_pageup1(struct window_mode_entry *, int);\nstatic int\twindow_copy_pagedown1(struct window_mode_entry *, int, int);\nstatic void\twindow_copy_next_paragraph(struct window_mode_entry *);\nstatic void\twindow_copy_previous_paragraph(struct window_mode_entry *);\nstatic void\twindow_copy_redraw_selection(struct window_mode_entry *, u_int);\nstatic void\twindow_copy_redraw_lines(struct window_mode_entry *, u_int,\n\t\t    u_int);\nstatic void\twindow_copy_redraw_screen(struct window_mode_entry *);\nstatic void\twindow_copy_write_line(struct window_mode_entry *,\n\t\t    struct screen_write_ctx *, u_int);\nstatic void\twindow_copy_write_lines(struct window_mode_entry *,\n\t\t    struct screen_write_ctx *, u_int, u_int);\nstatic char    *window_copy_match_at_cursor(struct window_copy_mode_data *);\nstatic void\twindow_copy_scroll_to(struct window_mode_entry *, u_int, u_int,\n\t\t    int);\nstatic int\twindow_copy_search_compare(struct grid *, u_int, u_int,\n\t\t    struct grid *, u_int, int);\nstatic int\twindow_copy_search_lr(struct grid *, struct grid *, u_int *,\n\t\t    u_int, u_int, u_int, int);\nstatic int\twindow_copy_search_rl(struct grid *, struct grid *, u_int *,\n\t\t    u_int, u_int, u_int, int);\nstatic int\twindow_copy_last_regex(struct grid *, u_int, u_int, u_int,\n\t\t    u_int, u_int *, u_int *, const char *, const regex_t *,\n\t\t    int);\nstatic int\twindow_copy_search_mark_at(struct window_copy_mode_data *,\n\t\t    u_int, u_int, u_int *);\nstatic char    *window_copy_stringify(struct grid *, u_int, u_int, u_int,\n\t\t    char *, u_int *);\nstatic void\twindow_copy_cstrtocellpos(struct grid *, u_int, u_int *,\n\t\t    u_int *, const char *);\nstatic int\twindow_copy_search_marks(struct window_mode_entry *,\n\t\t    struct screen *, int, int);\nstatic void\twindow_copy_clear_marks(struct window_mode_entry *);\nstatic int\twindow_copy_is_lowercase(const char *);\nstatic void\twindow_copy_search_back_overlap(struct grid *, regex_t *,\n\t\t    u_int *, u_int *, u_int *, u_int);\nstatic int\twindow_copy_search_jump(struct window_mode_entry *,\n\t\t    struct grid *, struct grid *, u_int, u_int, u_int, int, int,\n\t\t    int, int);\nstatic int\twindow_copy_search(struct window_mode_entry *, int, int);\nstatic int\twindow_copy_search_up(struct window_mode_entry *, int);\nstatic int\twindow_copy_search_down(struct window_mode_entry *, int);\nstatic void\twindow_copy_goto_line(struct window_mode_entry *, const char *);\nstatic void\twindow_copy_update_cursor(struct window_mode_entry *, u_int,\n\t\t    u_int);\nstatic void\twindow_copy_start_selection(struct window_mode_entry *);\nstatic int\twindow_copy_adjust_selection(struct window_mode_entry *,\n\t\t    u_int *, u_int *);\nstatic int\twindow_copy_set_selection(struct window_mode_entry *, int, int);\nstatic int\twindow_copy_update_selection(struct window_mode_entry *, int,\n\t\t    int);\nstatic void\twindow_copy_synchronize_cursor(struct window_mode_entry *, int);\nstatic void    *window_copy_get_selection(struct window_mode_entry *, size_t *);\nstatic void\twindow_copy_copy_buffer(struct window_mode_entry *,\n\t\t    const char *, void *, size_t, int, int);\nstatic void\twindow_copy_pipe(struct window_mode_entry *,\n\t\t    struct session *, const char *);\nstatic void\twindow_copy_copy_pipe(struct window_mode_entry *,\n\t\t    struct session *, const char *, const char *,\n\t\t    int, int);\nstatic void\twindow_copy_copy_selection(struct window_mode_entry *,\n\t\t    const char *, int, int);\nstatic void\twindow_copy_append_selection(struct window_mode_entry *);\nstatic void\twindow_copy_clear_selection(struct window_mode_entry *);\nstatic void\twindow_copy_copy_line(struct window_mode_entry *, char **,\n\t\t    size_t *, u_int, u_int, u_int);\nstatic int\twindow_copy_in_set(struct window_mode_entry *, u_int, u_int,\n\t\t    const char *);\nstatic u_int\twindow_copy_find_length(struct window_mode_entry *, u_int);\nstatic void\twindow_copy_cursor_start_of_line(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_back_to_indentation(\n\t\t    struct window_mode_entry *);\nstatic void\twindow_copy_cursor_end_of_line(struct window_mode_entry *);\nstatic void\twindow_copy_other_end(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_left(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_right(struct window_mode_entry *, int);\nstatic void\twindow_copy_cursor_up(struct window_mode_entry *, int);\nstatic void\twindow_copy_cursor_down(struct window_mode_entry *, int);\nstatic void\twindow_copy_cursor_jump(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_jump_back(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_jump_to(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_jump_to_back(struct window_mode_entry *);\nstatic void\twindow_copy_cursor_next_word(struct window_mode_entry *,\n\t\t    const char *);\nstatic void\twindow_copy_cursor_next_word_end_pos(struct window_mode_entry *,\n\t\t    const char *, u_int *, u_int *);\nstatic void\twindow_copy_cursor_next_word_end(struct window_mode_entry *,\n\t\t    const char *, int);\nstatic void\twindow_copy_cursor_previous_word_pos(struct window_mode_entry *,\n\t\t    const char *, u_int *, u_int *);\nstatic void\twindow_copy_cursor_previous_word(struct window_mode_entry *,\n\t\t    const char *, int);\nstatic void\twindow_copy_cursor_prompt(struct window_mode_entry *, int,\n\t\t    int);\nstatic void\twindow_copy_scroll_up(struct window_mode_entry *, u_int);\nstatic void\twindow_copy_scroll_down(struct window_mode_entry *, u_int);\nstatic void\twindow_copy_rectangle_set(struct window_mode_entry *, int);\nstatic void\twindow_copy_move_mouse(struct mouse_event *);\nstatic void\twindow_copy_drag_update(struct client *, struct mouse_event *);\nstatic void\twindow_copy_drag_release(struct client *, struct mouse_event *);\nstatic void\twindow_copy_jump_to_mark(struct window_mode_entry *);\nstatic void\twindow_copy_acquire_cursor_up(struct window_mode_entry *,\n\t\t    u_int, u_int, u_int, u_int, u_int);\nstatic void\twindow_copy_acquire_cursor_down(struct window_mode_entry *,\n\t\t    u_int, u_int, u_int, u_int, u_int, u_int, int);\nstatic u_int\twindow_copy_clip_width(u_int, u_int, u_int, u_int);\nstatic u_int\twindow_copy_search_mark_match(struct window_copy_mode_data *,\n\t\t    u_int , u_int, u_int, int);\n\nconst struct window_mode window_copy_mode = {\n\t.name = \"copy-mode\",\n\n\t.init = window_copy_init,\n\t.free = window_copy_free,\n\t.resize = window_copy_resize,\n\t.key_table = window_copy_key_table,\n\t.command = window_copy_command,\n\t.formats = window_copy_formats,\n};\n\nconst struct window_mode window_view_mode = {\n\t.name = \"view-mode\",\n\n\t.init = window_copy_view_init,\n\t.free = window_copy_free,\n\t.resize = window_copy_resize,\n\t.key_table = window_copy_key_table,\n\t.command = window_copy_command,\n\t.formats = window_copy_formats,\n};\n\nenum {\n\tWINDOW_COPY_OFF,\n\tWINDOW_COPY_SEARCHUP,\n\tWINDOW_COPY_SEARCHDOWN,\n\tWINDOW_COPY_JUMPFORWARD,\n\tWINDOW_COPY_JUMPBACKWARD,\n\tWINDOW_COPY_JUMPTOFORWARD,\n\tWINDOW_COPY_JUMPTOBACKWARD,\n};\n\nenum {\n\tWINDOW_COPY_REL_POS_ABOVE,\n\tWINDOW_COPY_REL_POS_ON_SCREEN,\n\tWINDOW_COPY_REL_POS_BELOW,\n};\n\nenum window_copy_cmd_action {\n\tWINDOW_COPY_CMD_NOTHING,\n\tWINDOW_COPY_CMD_REDRAW,\n\tWINDOW_COPY_CMD_CANCEL,\n};\n\nenum window_copy_cmd_clear {\n\tWINDOW_COPY_CMD_CLEAR_ALWAYS,\n\tWINDOW_COPY_CMD_CLEAR_NEVER,\n\tWINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n};\n\nstruct window_copy_cmd_state {\n\tstruct window_mode_entry\t*wme;\n\tstruct args\t\t\t*args;\n\tstruct args\t\t\t*wargs;\n\tstruct mouse_event\t\t*m;\n\n\tstruct client\t\t\t*c;\n\tstruct session\t\t\t*s;\n\tstruct winlink\t\t\t*wl;\n};\n\n/*\n * Copy mode's visible screen (the \"screen\" field) is filled from one of two\n * sources: the original contents of the pane (used when we actually enter via\n * the \"copy-mode\" command, to copy the contents of the current pane), or else\n * a series of lines containing the output from an output-writing tmux command\n * (such as any of the \"show-*\" or \"list-*\" commands).\n *\n * In either case, the full content of the copy-mode grid is pointed at by the\n * \"backing\" field, and is copied into \"screen\" as needed (that is, when\n * scrolling occurs). When copy-mode is backed by a pane, backing points\n * directly at that pane's screen structure (&wp->base); when backed by a list\n * of output-lines from a command, it points at a newly-allocated screen\n * structure (which is deallocated when the mode ends).\n */\nstruct window_copy_mode_data {\n\tstruct screen\t screen;\n\n\tstruct screen\t*backing;\n\tint\t\t backing_written; /* backing display started */\n\tstruct screen\t*writing;\n\tstruct input_ctx *ictx;\n\n\tint\t\t viewmode;\t/* view mode entered */\n\n\tu_int\t\t oy;\t\t/* number of lines scrolled up */\n\n\tu_int\t\t selx;\t\t/* beginning of selection */\n\tu_int\t\t sely;\n\n\tu_int\t\t endselx;\t/* end of selection */\n\tu_int\t\t endsely;\n\n\tenum {\n\t\tCURSORDRAG_NONE,\t/* selection is independent of cursor */\n\t\tCURSORDRAG_ENDSEL,\t/* end is synchronized with cursor */\n\t\tCURSORDRAG_SEL,\t\t/* start is synchronized with cursor */\n\t} cursordrag;\n\n\tint\t\t modekeys;\n\tenum {\n\t\tLINE_SEL_NONE,\n\t\tLINE_SEL_LEFT_RIGHT,\n\t\tLINE_SEL_RIGHT_LEFT,\n\t} lineflag;\t\t\t/* line selection mode */\n\tint\t\t rectflag;\t/* in rectangle copy mode? */\n\tint\t\t scroll_exit;\t/* exit on scroll to end? */\n\tint\t\t hide_position;\t/* hide position marker */\n\n\tenum {\n\t\tSEL_CHAR,\t\t/* select one char at a time */\n\t\tSEL_WORD,\t\t/* select one word at a time */\n\t\tSEL_LINE,\t\t/* select one line at a time */\n\t} selflag;\n\n\tconst char\t*separators;\t/* word separators */\n\n\tu_int\t\t dx;\t\t/* drag start position */\n\tu_int\t\t dy;\n\n\tu_int\t\t selrx;\t\t/* selection reset positions */\n\tu_int\t\t selry;\n\tu_int\t\t endselrx;\n\tu_int\t\t endselry;\n\n\tu_int\t\t cx;\n\tu_int\t\t cy;\n\n\tu_int\t\t lastcx; \t/* position in last line w/ content */\n\tu_int\t\t lastsx;\t/* size of last line w/ content */\n\n\tu_int\t\t mx;\t\t/* mark position */\n\tu_int\t\t my;\n\tint\t\t showmark;\n\n\tint\t\t searchtype;\n\tint\t\t searchdirection;\n\tint\t\t searchregex;\n\tchar\t\t*searchstr;\n\tu_char\t\t*searchmark;\n\tint\t\t searchcount;\n\tint\t\t searchmore;\n\tint\t\t searchall;\n\tint\t\t searchx;\n\tint\t\t searchy;\n\tint\t\t searcho;\n\tu_char\t\t searchgen;\n\n\tint\t\t timeout;\t/* search has timed out */\n#define WINDOW_COPY_SEARCH_TIMEOUT 10000\n#define WINDOW_COPY_SEARCH_ALL_TIMEOUT 200\n#define WINDOW_COPY_SEARCH_MAX_LINE 2000\n\n\tint\t\t\t jumptype;\n\tstruct utf8_data\t*jumpchar;\n\n\tstruct event\t dragtimer;\n#define WINDOW_COPY_DRAG_REPEAT_TIME 50000\n};\n\nstatic void\nwindow_copy_scroll_timer(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window_mode_entry\t*wme = arg;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct timeval\t\t\t tv = {\n\t\t.tv_usec = WINDOW_COPY_DRAG_REPEAT_TIME\n\t};\n\n\tevtimer_del(&data->dragtimer);\n\n\tif (TAILQ_FIRST(&wp->modes) != wme)\n\t\treturn;\n\n\tif (data->cy == 0) {\n\t\tevtimer_add(&data->dragtimer, &tv);\n\t\twindow_copy_cursor_up(wme, 1);\n\t} else if (data->cy == screen_size_y(&data->screen) - 1) {\n\t\tevtimer_add(&data->dragtimer, &tv);\n\t\twindow_copy_cursor_down(wme, 1);\n\t}\n}\n\nstatic struct screen *\nwindow_copy_clone_screen(struct screen *src, struct screen *hint, u_int *cx,\n    u_int *cy, int trim)\n{\n\tstruct screen\t\t*dst;\n\tconst struct grid_line\t*gl;\n\tu_int\t\t\t sy, wx, wy;\n\tint\t\t\t reflow;\n\n\tdst = xcalloc(1, sizeof *dst);\n\n\tsy = screen_hsize(src) + screen_size_y(src);\n\tif (trim) {\n\t\twhile (sy > screen_hsize(src)) {\n\t\t\tgl = grid_peek_line(src->grid, sy - 1);\n\t\t\tif (gl->cellused != 0)\n\t\t\t\tbreak;\n\t\t\tsy--;\n\t\t}\n\t}\n\tlog_debug(\"%s: target screen is %ux%u, source %ux%u\", __func__,\n\t    screen_size_x(src), sy, screen_size_x(hint),\n\t    screen_hsize(src) + screen_size_y(src));\n\tscreen_init(dst, screen_size_x(src), sy, screen_hlimit(src));\n\n\t/*\n\t * Ensure history is on for the backing grid so lines are not deleted\n\t * during resizing.\n\t */\n\tdst->grid->flags |= GRID_HISTORY;\n\tgrid_duplicate_lines(dst->grid, 0, src->grid, 0, sy);\n\n\tdst->grid->sy = sy - screen_hsize(src);\n\tdst->grid->hsize = screen_hsize(src);\n\tdst->grid->hscrolled = src->grid->hscrolled;\n\tif (src->cy > dst->grid->sy - 1) {\n\t\tdst->cx = 0;\n\t\tdst->cy = dst->grid->sy - 1;\n\t} else {\n\t\tdst->cx = src->cx;\n\t\tdst->cy = src->cy;\n\t}\n\n\tif (cx != NULL && cy != NULL) {\n\t\t*cx = dst->cx;\n\t\t*cy = screen_hsize(dst) + dst->cy;\n\t\treflow = (screen_size_x(hint) != screen_size_x(dst));\n\t}\n\telse\n\t\treflow = 0;\n\tif (reflow)\n\t\tgrid_wrap_position(dst->grid, *cx, *cy, &wx, &wy);\n\tscreen_resize_cursor(dst, screen_size_x(hint), screen_size_y(hint), 1,\n\t    0, 0);\n\tif (reflow)\n\t\tgrid_unwrap_position(dst->grid, cx, cy, wx, wy);\n\n\treturn (dst);\n}\n\nstatic struct window_copy_mode_data *\nwindow_copy_common_init(struct window_mode_entry *wme)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data;\n\tstruct screen\t\t\t*base = &wp->base;\n\n\twme->data = data = xcalloc(1, sizeof *data);\n\n\tdata->cursordrag = CURSORDRAG_NONE;\n\tdata->lineflag = LINE_SEL_NONE;\n\tdata->selflag = SEL_CHAR;\n\n\tif (wp->searchstr != NULL) {\n\t\tdata->searchtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->searchregex = wp->searchregex;\n\t\tdata->searchstr = xstrdup(wp->searchstr);\n\t} else {\n\t\tdata->searchtype = WINDOW_COPY_OFF;\n\t\tdata->searchregex = 0;\n\t\tdata->searchstr = NULL;\n\t}\n\tdata->searchx = data->searchy = data->searcho = -1;\n\tdata->searchall = 1;\n\n\tdata->jumptype = WINDOW_COPY_OFF;\n\tdata->jumpchar = NULL;\n\n\tscreen_init(&data->screen, screen_size_x(base), screen_size_y(base), 0);\n\tscreen_set_default_cursor(&data->screen, global_w_options);\n\tdata->modekeys = options_get_number(wp->window->options, \"mode-keys\");\n\n\tevtimer_set(&data->dragtimer, window_copy_scroll_timer, wme);\n\n\treturn (data);\n}\n\nstatic struct screen *\nwindow_copy_init(struct window_mode_entry *wme,\n    __unused struct cmd_find_state *fs, struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->swp;\n\tstruct window_copy_mode_data\t*data;\n\tstruct screen\t\t\t*base = &wp->base;\n\tstruct screen_write_ctx\t\t ctx;\n\tu_int\t\t\t\t i, cx, cy;\n\n\tdata = window_copy_common_init(wme);\n\tdata->backing = window_copy_clone_screen(base, &data->screen, &cx, &cy,\n\t    wme->swp != wme->wp);\n\n\tdata->cx = cx;\n\tif (cy < screen_hsize(data->backing)) {\n\t\tdata->cy = 0;\n\t\tdata->oy = screen_hsize(data->backing) - cy;\n\t} else {\n\t\tdata->cy = cy - screen_hsize(data->backing);\n\t\tdata->oy = 0;\n\t}\n\n\tdata->scroll_exit = args_has(args, 'e');\n\tdata->hide_position = args_has(args, 'H');\n\n\tif (base->hyperlinks != NULL)\n\t\tdata->screen.hyperlinks = hyperlinks_copy(base->hyperlinks);\n\tdata->screen.cx = data->cx;\n\tdata->screen.cy = data->cy;\n\tdata->mx = data->cx;\n\tdata->my = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->showmark = 0;\n\n\tscreen_write_start(&ctx, &data->screen);\n\tfor (i = 0; i < screen_size_y(&data->screen); i++)\n\t\twindow_copy_write_line(wme, &ctx, i);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy, 0);\n\tscreen_write_stop(&ctx);\n\n\treturn (&data->screen);\n}\n\nstatic struct screen *\nwindow_copy_view_init(struct window_mode_entry *wme,\n    __unused struct cmd_find_state *fs, __unused struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data;\n\tstruct screen\t\t\t*base = &wp->base;\n\tu_int\t\t\t\t sx = screen_size_x(base);\n\n\tdata = window_copy_common_init(wme);\n\tdata->viewmode = 1;\n\n\tdata->backing = xmalloc(sizeof *data->backing);\n\tscreen_init(data->backing, sx, screen_size_y(base), UINT_MAX);\n\tdata->writing = xmalloc(sizeof *data->writing);\n\tscreen_init(data->writing, sx, screen_size_y(base), 0);\n\tdata->ictx = input_init(NULL, NULL, NULL);\n\tdata->mx = data->cx;\n\tdata->my = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->showmark = 0;\n\n\treturn (&data->screen);\n}\n\nstatic void\nwindow_copy_free(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tevtimer_del(&data->dragtimer);\n\n\tfree(data->searchmark);\n\tfree(data->searchstr);\n\tfree(data->jumpchar);\n\n\tif (data->writing != NULL) {\n\t\tscreen_free(data->writing);\n\t\tfree(data->writing);\n\t}\n\tif (data->ictx != NULL)\n\t\tinput_free(data->ictx);\n\tscreen_free(data->backing);\n\tfree(data->backing);\n\n\tscreen_free(&data->screen);\n\tfree(data);\n}\n\nvoid\nwindow_copy_add(struct window_pane *wp, int parse, const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\twindow_copy_vadd(wp, parse, fmt, ap);\n\tva_end(ap);\n}\n\nstatic void\nwindow_copy_init_ctx_cb(__unused struct screen_write_ctx *ctx,\n    struct tty_ctx *ttyctx)\n{\n\tmemcpy(&ttyctx->defaults, &grid_default_cell, sizeof ttyctx->defaults);\n\tttyctx->palette = NULL;\n\tttyctx->redraw_cb = NULL;\n\tttyctx->set_client_cb = NULL;\n\tttyctx->arg = NULL;\n}\n\nvoid\nwindow_copy_vadd(struct window_pane *wp, int parse, const char *fmt, va_list ap)\n{\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*backing = data->backing;\n\tstruct screen\t\t\t*writing = data->writing;\n\tstruct screen_write_ctx\t \t writing_ctx, backing_ctx, ctx;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t old_hsize, old_cy;\n\tu_int\t\t\t\t sx = screen_size_x(backing);\n\tchar\t\t\t\t*text;\n\n\tif (parse) {\n\t\tvasprintf(&text, fmt, ap);\n\t\tscreen_write_start(&writing_ctx, writing);\n\t\tscreen_write_reset(&writing_ctx);\n\t\tinput_parse_screen(data->ictx, writing, window_copy_init_ctx_cb,\n\t\t    data, text, strlen(text));\n\t\tfree(text);\n\t}\n\n\told_hsize = screen_hsize(data->backing);\n\tscreen_write_start(&backing_ctx, backing);\n\tif (data->backing_written) {\n\t\t/*\n\t\t * On the second or later line, do a CRLF before writing\n\t\t * (so it's on a new line).\n\t\t */\n\t\tscreen_write_carriagereturn(&backing_ctx);\n\t\tscreen_write_linefeed(&backing_ctx, 0, 8);\n\t} else\n\t\tdata->backing_written = 1;\n\told_cy = backing->cy;\n\tif (parse)\n\t\tscreen_write_fast_copy(&backing_ctx, writing, 0, 0, sx, 1);\n\telse {\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\tscreen_write_vnputs(&backing_ctx, 0, &gc, fmt, ap);\n\t}\n\tscreen_write_stop(&backing_ctx);\n\n\tdata->oy += screen_hsize(data->backing) - old_hsize;\n\n\tscreen_write_start_pane(&ctx, wp, &data->screen);\n\n\t/*\n\t * If the history has changed, draw the top line.\n\t * (If there's any history at all, it has changed.)\n\t */\n\tif (screen_hsize(data->backing))\n\t\twindow_copy_redraw_lines(wme, 0, 1);\n\n\t/* Write the new lines. */\n\twindow_copy_redraw_lines(wme, old_cy, backing->cy - old_cy + 1);\n\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_copy_scroll(struct window_pane *wp, int sl_mpos, u_int my,\n    int scroll_exit)\n{\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\n\tif (wme != NULL) {\n\t\twindow_set_active_pane(wp->window, wp, 0);\n\t\twindow_copy_scroll1(wme, wp, sl_mpos, my, scroll_exit);\n\t}\n}\n\nstatic void\nwindow_copy_scroll1(struct window_mode_entry *wme, struct window_pane *wp,\n    int sl_mpos, u_int my, int scroll_exit)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t ox, oy, px, py, n, offset, size;\n\tu_int\t\t\t\t new_offset;\n\tu_int\t\t\t\t slider_height = wp->sb_slider_h;\n\tu_int\t\t\t\t sb_height = wp->sy, sb_top = wp->yoff;\n\tu_int\t\t\t\t sy = screen_size_y(data->backing);\n\tint\t\t\t\t new_slider_y, delta;\n\n\t/*\n\t * sl_mpos is where in the slider the user is dragging, mouse is\n\t * dragging this y point relative to top of slider.\n\t */\n\tif (my <= sb_top + sl_mpos) {\n\t\t/* Slider banged into top. */\n\t\tnew_slider_y = sb_top - wp->yoff;\n\t} else if (my - sl_mpos > sb_top + sb_height - slider_height) {\n\t\t/* Slider banged into bottom. */\n\t\tnew_slider_y = sb_top - wp->yoff + (sb_height - slider_height);\n\t} else {\n\t\t/* Slider is somewhere in the middle. */\n\t\tnew_slider_y = my - wp->yoff - sl_mpos + 1;\n\t}\n\n\tif (TAILQ_FIRST(&wp->modes) == NULL ||\n\t    window_copy_get_current_offset(wp, &offset, &size) == 0)\n\t\treturn;\n\n\t/*\n\t * See screen_redraw_draw_pane_scrollbar - this is the inverse of the\n\t * formula used there.\n\t */\n\tnew_offset = new_slider_y * ((float)(size + sb_height) / sb_height);\n\tdelta = (int)offset - new_offset;\n\n\t/*\n\t * Move pane view around based on delta relative to the cursor,\n\t * maintaining the selection.\n\t */\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wme, oy);\n\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\tdata->cx = data->lastcx;\n\n\tif (delta >= 0) {\n\t\tn = (u_int)delta;\n\t\tif (data->oy + n > screen_hsize(data->backing)) {\n\t\t\tdata->oy = screen_hsize(data->backing);\n\t\t\tif (data->cy < n)\n\t\t\t\tdata->cy = 0;\n\t\t\telse\n\t\t\t\tdata->cy -= n;\n\t\t} else\n\t\t\tdata->oy += n;\n\t} else {\n\t\tn = (u_int)-delta;\n\t\tif (data->oy < n) {\n\t\t\tdata->oy = 0;\n\t\t\tif (data->cy + (n - data->oy) >= sy)\n\t\t\t\tdata->cy = sy - 1;\n\t\t\telse\n\t\t\t\tdata->cy += n - data->oy;\n\t\t} else\n\t\t\tdata->oy -= n;\n\t}\n\n\t/* Don't also drag tail when dragging a scrollbar, it looks weird. */\n\tdata->cursordrag = CURSORDRAG_NONE;\n\n\tif (data->screen.sel == NULL || !data->rectflag) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wme, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wme);\n\t}\n\n\tif (scroll_exit && data->oy == 0) {\n\t\twindow_pane_reset_mode(wp);\n\t\treturn;\n\t}\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\nvoid\nwindow_copy_pageup(struct window_pane *wp, int half_page)\n{\n\twindow_copy_pageup1(TAILQ_FIRST(&wp->modes), half_page);\n}\n\nstatic void\nwindow_copy_pageup1(struct window_mode_entry *wme, int half_page)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t n, ox, oy, px, py;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wme, oy);\n\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\tdata->cx = data->lastcx;\n\n\tn = 1;\n\tif (screen_size_y(s) > 2) {\n\t\tif (half_page)\n\t\t\tn = screen_size_y(s) / 2;\n\t\telse\n\t\t\tn = screen_size_y(s) - 2;\n\t}\n\n\tif (data->oy + n > screen_hsize(data->backing)) {\n\t\tdata->oy = screen_hsize(data->backing);\n\t\tif (data->cy < n)\n\t\t\tdata->cy = 0;\n\t\telse\n\t\t\tdata->cy -= n;\n\t} else\n\t\tdata->oy += n;\n\n\tif (data->screen.sel == NULL || !data->rectflag) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wme, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wme);\n\t}\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\nvoid\nwindow_copy_pagedown(struct window_pane *wp, int half_page, int scroll_exit)\n{\n\tif (window_copy_pagedown1(TAILQ_FIRST(&wp->modes), half_page,\n\t    scroll_exit)) {\n\t\twindow_pane_reset_mode(wp);\n\t\treturn;\n\t}\n}\n\nstatic int\nwindow_copy_pagedown1(struct window_mode_entry *wme, int half_page,\n    int scroll_exit)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t n, ox, oy, px, py;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wme, oy);\n\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\tdata->cx = data->lastcx;\n\n\tn = 1;\n\tif (screen_size_y(s) > 2) {\n\t\tif (half_page)\n\t\t\tn = screen_size_y(s) / 2;\n\t\telse\n\t\t\tn = screen_size_y(s) - 2;\n\t}\n\n\tif (data->oy < n) {\n\t\tdata->oy = 0;\n\t\tif (data->cy + (n - data->oy) >= screen_size_y(data->backing))\n\t\t\tdata->cy = screen_size_y(data->backing) - 1;\n\t\telse\n\t\t\tdata->cy += n - data->oy;\n\t} else\n\t\tdata->oy -= n;\n\n\tif (data->screen.sel == NULL || !data->rectflag) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wme, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wme);\n\t}\n\n\tif (scroll_exit && data->oy == 0)\n\t\treturn (1);\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n\treturn (0);\n}\n\nstatic void\nwindow_copy_previous_paragraph(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t oy;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\twhile (oy > 0 && window_copy_find_length(wme, oy) == 0)\n\t\toy--;\n\n\twhile (oy > 0 && window_copy_find_length(wme, oy) > 0)\n\t\toy--;\n\n\twindow_copy_scroll_to(wme, 0, oy, 0);\n}\n\nstatic void\nwindow_copy_next_paragraph(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t maxy, ox, oy;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tmaxy = screen_hsize(data->backing) + screen_size_y(s) - 1;\n\n\twhile (oy < maxy && window_copy_find_length(wme, oy) == 0)\n\t\toy++;\n\n\twhile (oy < maxy && window_copy_find_length(wme, oy) > 0)\n\t\toy++;\n\n\tox = window_copy_find_length(wme, oy);\n\twindow_copy_scroll_to(wme, ox, oy, 0);\n}\n\nchar *\nwindow_copy_get_word(struct window_pane *wp, u_int x, u_int y)\n{\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->screen.grid;\n\n\treturn (format_grid_word(gd, x, gd->hsize + y));\n}\n\nchar *\nwindow_copy_get_line(struct window_pane *wp, u_int y)\n{\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->screen.grid;\n\n\treturn (format_grid_line(gd, gd->hsize + y));\n}\n\nstatic void *\nwindow_copy_cursor_hyperlink_cb(struct format_tree *ft)\n{\n\tstruct window_pane\t\t*wp = format_get_pane(ft);\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->screen.grid;\n\n\treturn (format_grid_hyperlink(gd, data->cx, gd->hsize + data->cy,\n\t    &data->screen));\n}\n\nstatic void *\nwindow_copy_cursor_word_cb(struct format_tree *ft)\n{\n\tstruct window_pane\t\t*wp = format_get_pane(ft);\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\treturn (window_copy_get_word(wp, data->cx, data->cy));\n}\n\nstatic void *\nwindow_copy_cursor_line_cb(struct format_tree *ft)\n{\n\tstruct window_pane\t\t*wp = format_get_pane(ft);\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\treturn (window_copy_get_line(wp, data->cy));\n}\n\nstatic void *\nwindow_copy_search_match_cb(struct format_tree *ft)\n{\n\tstruct window_pane\t\t*wp = format_get_pane(ft);\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\treturn (window_copy_match_at_cursor(data));\n}\n\nstatic void\nwindow_copy_formats(struct window_mode_entry *wme, struct format_tree *ft)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t hsize = screen_hsize(data->backing);\n\tstruct grid_line\t\t*gl;\n\n\tgl = grid_get_line(data->backing->grid, hsize - data->oy);\n\tformat_add(ft, \"top_line_time\", \"%llu\", (unsigned long long)gl->time);\n\n\tformat_add(ft, \"scroll_position\", \"%d\", data->oy);\n\tformat_add(ft, \"rectangle_toggle\", \"%d\", data->rectflag);\n\n\tformat_add(ft, \"copy_cursor_x\", \"%d\", data->cx);\n\tformat_add(ft, \"copy_cursor_y\", \"%d\", data->cy);\n\n\tif (data->screen.sel != NULL) {\n\t\tformat_add(ft, \"selection_start_x\", \"%d\", data->selx);\n\t\tformat_add(ft, \"selection_start_y\", \"%d\", data->sely);\n\t\tformat_add(ft, \"selection_end_x\", \"%d\", data->endselx);\n\t\tformat_add(ft, \"selection_end_y\", \"%d\", data->endsely);\n\n\t\tif (data->cursordrag != CURSORDRAG_NONE)\n\t\t\tformat_add(ft, \"selection_active\", \"1\");\n\t\telse\n\t\t\tformat_add(ft, \"selection_active\", \"0\");\n\t\tif (data->endselx != data->selx || data->endsely != data->sely)\n\t\t\tformat_add(ft, \"selection_present\", \"1\");\n\t\telse\n\t\t\tformat_add(ft, \"selection_present\", \"0\");\n\t} else {\n\t\tformat_add(ft, \"selection_active\", \"0\");\n\t\tformat_add(ft, \"selection_present\", \"0\");\n\t}\n\n\tformat_add(ft, \"search_present\", \"%d\", data->searchmark != NULL);\n\tformat_add(ft, \"search_timed_out\", \"%d\", data->timeout);\n\tif (data->searchcount != -1) {\n\t\tformat_add(ft, \"search_count\", \"%d\", data->searchcount);\n\t\tformat_add(ft, \"search_count_partial\", \"%d\", data->searchmore);\n\t}\n\tformat_add_cb(ft, \"search_match\", window_copy_search_match_cb);\n\n\tformat_add_cb(ft, \"copy_cursor_word\", window_copy_cursor_word_cb);\n\tformat_add_cb(ft, \"copy_cursor_line\", window_copy_cursor_line_cb);\n\tformat_add_cb(ft, \"copy_cursor_hyperlink\",\n\t    window_copy_cursor_hyperlink_cb);\n}\n\nstatic void\nwindow_copy_size_changed(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\tint\t\t\t\t search = (data->searchmark != NULL);\n\n\twindow_copy_clear_selection(wme);\n\twindow_copy_clear_marks(wme);\n\n\tscreen_write_start(&ctx, s);\n\twindow_copy_write_lines(wme, &ctx, 0, screen_size_y(s));\n\tscreen_write_stop(&ctx);\n\n\tif (search && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 0);\n\tdata->searchx = data->cx;\n\tdata->searchy = data->cy;\n\tdata->searcho = data->oy;\n}\n\nstatic void\nwindow_copy_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tu_int\t\t\t\t cx, cy, wx, wy;\n\tint\t\t\t\t reflow;\n\n\tscreen_resize(s, sx, sy, 0);\n\tcx = data->cx;\n\tcy = gd->hsize + data->cy - data->oy;\n\treflow = (gd->sx != sx);\n\tif (reflow)\n\t\tgrid_wrap_position(gd, cx, cy, &wx, &wy);\n\tscreen_resize_cursor(data->backing, sx, sy, 1, 0, 0);\n\tif (reflow)\n\t\tgrid_unwrap_position(gd, &cx, &cy, wx, wy);\n\n\tdata->cx = cx;\n\tif (cy < gd->hsize) {\n\t\tdata->cy = 0;\n\t\tdata->oy = gd->hsize - cy;\n\t} else {\n\t\tdata->cy = cy - gd->hsize;\n\t\tdata->oy = 0;\n\t}\n\n\twindow_copy_size_changed(wme);\n\twindow_copy_redraw_screen(wme);\n}\n\nstatic const char *\nwindow_copy_key_table(struct window_mode_entry *wme)\n{\n\tstruct window_pane\t*wp = wme->wp;\n\n\tif (options_get_number(wp->window->options, \"mode-keys\") == MODEKEY_VI)\n\t\treturn (\"copy-mode-vi\");\n\treturn (\"copy-mode\");\n}\n\nstatic int\nwindow_copy_expand_search_string(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tconst char\t\t\t*ss = args_string(cs->wargs, 0);\n\tchar\t\t\t\t*expanded;\n\n\tif (ss == NULL || *ss == '\\0')\n\t\treturn (0);\n\n\tif (args_has(cs->args, 'F')) {\n\t\texpanded = format_single(NULL, ss, NULL, NULL, NULL, wme->wp);\n\t\tif (*expanded == '\\0') {\n\t\t\tfree(expanded);\n\t\t\treturn (0);\n\t\t}\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = expanded;\n\t} else {\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = xstrdup(ss);\n\t}\n\treturn (1);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_append_selection(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct session\t\t\t*s = cs->s;\n\n\tif (s != NULL)\n\t\twindow_copy_append_selection(wme);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_append_selection_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct session\t\t\t*s = cs->s;\n\n\tif (s != NULL)\n\t\twindow_copy_append_selection(wme);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_CANCEL);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_back_to_indentation(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cursor_back_to_indentation(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_begin_selection(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct client\t\t\t*c = cs->c;\n\tstruct mouse_event\t\t*m = cs->m;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tif (m != NULL) {\n\t\twindow_copy_start_drag(c, m);\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\t}\n\n\tdata->lineflag = LINE_SEL_NONE;\n\tdata->selflag = SEL_CHAR;\n\twindow_copy_start_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_stop_selection(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->cursordrag = CURSORDRAG_NONE;\n\tdata->lineflag = LINE_SEL_NONE;\n\tdata->selflag = SEL_CHAR;\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_bottom_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->cx = 0;\n\tdata->cy = screen_size_y(&data->screen) - 1;\n\n\twindow_copy_update_selection(wme, 1, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cancel(__unused struct window_copy_cmd_state *cs)\n{\n\treturn (WINDOW_COPY_CMD_CANCEL);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_clear_selection(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_do_copy_end_of_line(struct window_copy_cmd_state *cs, int pipe,\n    int cancel)\n{\n\tstruct window_mode_entry\t *wme = cs->wme;\n\tstruct client\t\t\t *c = cs->c;\n\tstruct session\t\t\t *s = cs->s;\n\tstruct winlink\t\t\t *wl = cs->wl;\n\tstruct window_pane\t\t *wp = wme->wp;\n\tu_int\t\t\t\t  count = args_count(cs->wargs);\n\tu_int\t\t\t\t  np = wme->prefix, ocx, ocy, ooy;\n\tstruct window_copy_mode_data\t *data = wme->data;\n\tchar\t\t\t\t *prefix = NULL, *command = NULL;\n\tconst char\t\t\t *arg0 = args_string(cs->wargs, 0);\n\tconst char\t\t\t *arg1 = args_string(cs->wargs, 1);\n\tint\t\t\t\t  set_paste = !args_has(cs->wargs, 'P');\n\tint\t\t\t\t  set_clip = !args_has(cs->wargs, 'C');\n\n\tif (pipe) {\n\t\tif (count == 2)\n\t\t\tprefix = format_single(NULL, arg1, c, s, wl, wp);\n\t\tif (s != NULL && count > 0 && *arg0 != '\\0')\n\t\t\tcommand = format_single(NULL, arg0, c, s, wl, wp);\n\t} else {\n\t\tif (count == 1)\n\t\t\tprefix = format_single(NULL, arg0, c, s, wl, wp);\n\t}\n\n\tocx = data->cx;\n\tocy = data->cy;\n\tooy = data->oy;\n\n\twindow_copy_start_selection(wme);\n\tfor (; np > 1; np--)\n\t\twindow_copy_cursor_down(wme, 0);\n\twindow_copy_cursor_end_of_line(wme);\n\n\tif (s != NULL) {\n\t\tif (pipe)\n\t\t\twindow_copy_copy_pipe(wme, s, prefix, command,\n\t\t\t    set_paste, set_clip);\n\t\telse\n\t\t\twindow_copy_copy_selection(wme, prefix,\n\t\t\t    set_paste, set_clip);\n\n\t\tif (cancel) {\n\t\t\tfree(prefix);\n\t\t\tfree(command);\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t\t}\n\t}\n\twindow_copy_clear_selection(wme);\n\n\tdata->cx = ocx;\n\tdata->cy = ocy;\n\tdata->oy = ooy;\n\n\tfree(prefix);\n\tfree(command);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_end_of_line(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_end_of_line(cs, 0, 0));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_end_of_line_and_cancel(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_end_of_line(cs, 0, 1));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_end_of_line(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_end_of_line(cs, 1, 0));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_end_of_line_and_cancel(\n    struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_end_of_line(cs, 1, 1));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_do_copy_line(struct window_copy_cmd_state *cs, int pipe, int cancel)\n{\n\tstruct window_mode_entry\t *wme = cs->wme;\n\tstruct client\t\t\t *c = cs->c;\n\tstruct session\t\t\t *s = cs->s;\n\tstruct winlink\t\t\t *wl = cs->wl;\n\tstruct window_pane\t\t *wp = wme->wp;\n\tstruct window_copy_mode_data\t *data = wme->data;\n\tu_int\t\t\t\t  count = args_count(cs->wargs);\n\tu_int\t\t\t\t  np = wme->prefix, ocx, ocy, ooy;\n\tchar\t\t\t\t *prefix = NULL, *command = NULL;\n\tconst char\t\t\t *arg0 = args_string(cs->wargs, 0);\n\tconst char\t\t\t *arg1 = args_string(cs->wargs, 1);\n\tint\t\t\t\t  set_paste = !args_has(cs->wargs, 'P');\n\tint\t\t\t\t  set_clip = !args_has(cs->wargs, 'C');\n\n\tif (pipe) {\n\t\tif (count == 2)\n\t\t\tprefix = format_single(NULL, arg1, c, s, wl, wp);\n\t\tif (s != NULL && count > 0 && *arg0 != '\\0')\n\t\t\tcommand = format_single(NULL, arg0, c, s, wl, wp);\n\t} else {\n\t\tif (count == 1)\n\t\t\tprefix = format_single(NULL, arg0, c, s, wl, wp);\n\t}\n\n\tocx = data->cx;\n\tocy = data->cy;\n\tooy = data->oy;\n\n\tdata->selflag = SEL_CHAR;\n\twindow_copy_cursor_start_of_line(wme);\n\twindow_copy_start_selection(wme);\n\tfor (; np > 1; np--)\n\t\twindow_copy_cursor_down(wme, 0);\n\twindow_copy_cursor_end_of_line(wme);\n\n\tif (s != NULL) {\n\t\tif (pipe)\n\t\t\twindow_copy_copy_pipe(wme, s, prefix, command,\n\t\t\t    set_paste, set_clip);\n\t\telse\n\t\t\twindow_copy_copy_selection(wme, prefix,\n\t\t\t    set_paste, set_clip);\n\n\t\tif (cancel) {\n\t\t\tfree(prefix);\n\t\t\tfree(command);\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t\t}\n\t}\n\twindow_copy_clear_selection(wme);\n\n\tdata->cx = ocx;\n\tdata->cy = ocy;\n\tdata->oy = ooy;\n\n\tfree(prefix);\n\tfree(command);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_line(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_line(cs, 0, 0));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_line_and_cancel(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_line(cs, 0, 1));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_line(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_line(cs, 1, 0));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_line_and_cancel(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_do_copy_line(cs, 1, 1));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_selection_no_clear(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct client\t\t\t*c = cs->c;\n\tstruct session\t\t\t*s = cs->s;\n\tstruct winlink\t\t\t*wl = cs->wl;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tchar\t\t\t\t*prefix = NULL;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\tint\t\t\t\t set_paste = !args_has(cs->wargs, 'P');\n\tint\t\t\t\t set_clip = !args_has(cs->wargs, 'C');\n\n\tif (arg0 != NULL)\n\t\tprefix = format_single(NULL, arg0, c, s, wl, wp);\n\n\tif (s != NULL)\n\t\twindow_copy_copy_selection(wme, prefix, set_paste, set_clip);\n\n\tfree(prefix);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_selection(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_copy_selection_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_selection_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_copy_selection_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_CANCEL);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cursor_down(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_down(wme, 0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cursor_down_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix, cy;\n\n\tcy = data->cy;\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_down(wme, 0);\n\tif (cy == data->cy && data->oy == 0)\n\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cursor_left(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_left(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cursor_right(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--) {\n\t\twindow_copy_cursor_right(wme, data->screen.sel != NULL &&\n\t\t    data->rectflag);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\n/* Scroll line containing the cursor to the given position. */\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_to(struct window_copy_cmd_state *cs, u_int to)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t oy, delta;\n\tint\t\t\t\t scroll_up; /* >0 up, <0 down */\n\n\tscroll_up = data->cy - to;\n\tdelta = abs(scroll_up);\n\toy = screen_hsize(data->backing) - data->oy;\n\n\t/*\n\t * oy is the maximum scroll down amount, while data->oy is the maximum\n\t * scroll up amount.\n\t */\n\tif (scroll_up > 0 && data->oy >= delta) {\n\t\twindow_copy_scroll_up(wme, delta);\n\t\tdata->cy -= delta;\n\t} else if (scroll_up < 0 && oy >= delta) {\n\t\twindow_copy_scroll_down(wme, delta);\n\t\tdata->cy += delta;\n\t}\n\n\twindow_copy_update_selection(wme, 0, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\n/* Scroll line containing the cursor to the bottom. */\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_bottom(struct window_copy_cmd_state *cs)\n{\n\tstruct window_copy_mode_data\t*data = cs->wme->data;\n\tu_int\t\t\t\t bottom;\n\n\tbottom = screen_size_y(&data->screen) - 1;\n\treturn (window_copy_cmd_scroll_to(cs, bottom));\n}\n\n/* Scroll line containing the cursor to the middle. */\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_middle(struct window_copy_cmd_state *cs)\n{\n\tstruct window_copy_mode_data\t*data = cs->wme->data;\n\tu_int\t\t\t\t mid_value;\n\n\tmid_value = (screen_size_y(&data->screen) - 1) / 2;\n\treturn (window_copy_cmd_scroll_to(cs, mid_value));\n}\n\n/* Scroll line containing the cursor to the top. */\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_top(struct window_copy_cmd_state *cs)\n{\n\treturn (window_copy_cmd_scroll_to(cs, 0));\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_cursor_up(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_up(wme, 0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_end_of_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cursor_end_of_line(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_halfpage_down(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--) {\n\t\tif (window_copy_pagedown1(wme, 1, data->scroll_exit))\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_halfpage_down_and_cancel(struct window_copy_cmd_state *cs)\n{\n\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--) {\n\t\tif (window_copy_pagedown1(wme, 1, 1))\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_halfpage_up(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_pageup1(wme, 1);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_toggle_position(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->hide_position = !data->hide_position;\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_history_bottom(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing;\n\tu_int\t\t\t\t oy;\n\n\toy = screen_hsize(s) + data->cy - data->oy;\n\tif (data->lineflag == LINE_SEL_RIGHT_LEFT && oy == data->endsely)\n\t\twindow_copy_other_end(wme);\n\n\tdata->cy = screen_size_y(&data->screen) - 1;\n\tdata->cx = window_copy_find_length(wme, screen_hsize(s) + data->cy);\n\tdata->oy = 0;\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_history_top(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t oy;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tif (data->lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)\n\t\twindow_copy_other_end(wme);\n\n\tdata->cy = 0;\n\tdata->cx = 0;\n\tdata->oy = screen_hsize(data->backing);\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_again(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tswitch (data->jumptype) {\n\tcase WINDOW_COPY_JUMPFORWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPBACKWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_back(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPTOFORWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPTOBACKWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to_back(wme);\n\t\tbreak;\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_reverse(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tswitch (data->jumptype) {\n\tcase WINDOW_COPY_JUMPFORWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_back(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPBACKWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPTOFORWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to_back(wme);\n\t\tbreak;\n\tcase WINDOW_COPY_JUMPTOBACKWARD:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to(wme);\n\t\tbreak;\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_middle_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->cx = 0;\n\tdata->cy = (screen_size_y(&data->screen) - 1) / 2;\n\n\twindow_copy_update_selection(wme, 1, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_previous_matching_bracket(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing;\n\tchar\t\t\t\t open[] = \"{[(\", close[] = \"}])\";\n\tchar\t\t\t\t tried, found, start, *cp;\n\tu_int\t\t\t\t px, py, xx, n;\n\tstruct grid_cell\t\t gc;\n\tint\t\t\t\t failed;\n\n\tfor (; np != 0; np--) {\n\t\t/* Get cursor position and line length. */\n\t\tpx = data->cx;\n\t\tpy = screen_hsize(s) + data->cy - data->oy;\n\t\txx = window_copy_find_length(wme, py);\n\t\tif (xx == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get the current character. If not on a bracket, try the\n\t\t * previous. If still not, then behave like previous-word.\n\t\t */\n\t\ttried = 0;\n\tretry:\n\t\tgrid_get_cell(s->grid, px, py, &gc);\n\t\tif (gc.data.size != 1 || (gc.flags & GRID_FLAG_PADDING))\n\t\t\tcp = NULL;\n\t\telse {\n\t\t\tfound = *gc.data.data;\n\t\t\tcp = strchr(close, found);\n\t\t}\n\t\tif (cp == NULL) {\n\t\t\tif (data->modekeys == MODEKEY_EMACS) {\n\t\t\t\tif (!tried && px > 0) {\n\t\t\t\t\tpx--;\n\t\t\t\t\ttried = 1;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\twindow_copy_cursor_previous_word(wme, close, 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tstart = open[cp - close];\n\n\t\t/* Walk backward until the matching bracket is reached. */\n\t\tn = 1;\n\t\tfailed = 0;\n\t\tdo {\n\t\t\tif (px == 0) {\n\t\t\t\tif (py == 0) {\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tpy--;\n\t\t\t\t\txx = window_copy_find_length(wme, py);\n\t\t\t\t} while (xx == 0 && py > 0);\n\t\t\t\tif (xx == 0 && py == 0) {\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpx = xx - 1;\n\t\t\t} else\n\t\t\t\tpx--;\n\n\t\t\tgrid_get_cell(s->grid, px, py, &gc);\n\t\t\tif (gc.data.size == 1 &&\n\t\t\t    (~gc.flags & GRID_FLAG_PADDING)) {\n\t\t\t\tif (*gc.data.data == found)\n\t\t\t\t\tn++;\n\t\t\t\telse if (*gc.data.data == start)\n\t\t\t\t\tn--;\n\t\t\t}\n\t\t} while (n != 0);\n\n\t\t/* Move the cursor to the found location if any. */\n\t\tif (!failed)\n\t\t\twindow_copy_scroll_to(wme, px, py, 0);\n\t}\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_matching_bracket(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing;\n\tchar\t\t\t\t open[] = \"{[(\", close[] = \"}])\";\n\tchar\t\t\t\t tried, found, end, *cp;\n\tu_int\t\t\t\t px, py, xx, yy, sx, sy, n;\n\tstruct grid_cell\t\t gc;\n\tint\t\t\t\t failed;\n\tstruct grid_line\t\t*gl;\n\n\tfor (; np != 0; np--) {\n\t\t/* Get cursor position and line length. */\n\t\tpx = data->cx;\n\t\tpy = screen_hsize(s) + data->cy - data->oy;\n\t\txx = window_copy_find_length(wme, py);\n\t\tyy = screen_hsize(s) + screen_size_y(s) - 1;\n\t\tif (xx == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get the current character. If not on a bracket, try the\n\t\t * next. If still not, then behave like next-word.\n\t\t */\n\t\ttried = 0;\n\tretry:\n\t\tgrid_get_cell(s->grid, px, py, &gc);\n\t\tif (gc.data.size != 1 || (gc.flags & GRID_FLAG_PADDING))\n\t\t\tcp = NULL;\n\t\telse {\n\t\t\tfound = *gc.data.data;\n\n\t\t\t/*\n\t\t\t * In vi mode, attempt to move to previous bracket if a\n\t\t\t * closing bracket is found first. If this fails,\n\t\t\t * return to the original cursor position.\n\t\t\t */\n\t\t\tcp = strchr(close, found);\n\t\t\tif (cp != NULL && data->modekeys == MODEKEY_VI) {\n\t\t\t\tsx = data->cx;\n\t\t\t\tsy = screen_hsize(s) + data->cy - data->oy;\n\n\t\t\t\twindow_copy_scroll_to(wme, px, py, 0);\n\t\t\t\twindow_copy_cmd_previous_matching_bracket(cs);\n\n\t\t\t\tpx = data->cx;\n\t\t\t\tpy = screen_hsize(s) + data->cy - data->oy;\n\t\t\t\tgrid_get_cell(s->grid, px, py, &gc);\n\t\t\t\tif (gc.data.size == 1 &&\n\t\t\t\t    (~gc.flags & GRID_FLAG_PADDING) &&\n\t\t\t\t    strchr(close, *gc.data.data) != NULL)\n\t\t\t\t\twindow_copy_scroll_to(wme, sx, sy, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcp = strchr(open, found);\n\t\t}\n\t\tif (cp == NULL) {\n\t\t\tif (data->modekeys == MODEKEY_EMACS) {\n\t\t\t\tif (!tried && px <= xx) {\n\t\t\t\t\tpx++;\n\t\t\t\t\ttried = 1;\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\twindow_copy_cursor_next_word_end(wme, open, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* For vi, continue searching for bracket until EOL. */\n\t\t\tif (px > xx) {\n\t\t\t\tif (py == yy)\n\t\t\t\t\tcontinue;\n\t\t\t\tgl = grid_get_line(s->grid, py);\n\t\t\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (gl->cellsize > s->grid->sx)\n\t\t\t\t\tcontinue;\n\t\t\t\tpx = 0;\n\t\t\t\tpy++;\n\t\t\t\txx = window_copy_find_length(wme, py);\n\t\t\t} else\n\t\t\t\tpx++;\n\t\t\tgoto retry;\n\t\t}\n\t\tend = close[cp - open];\n\n\t\t/* Walk forward until the matching bracket is reached. */\n\t\tn = 1;\n\t\tfailed = 0;\n\t\tdo {\n\t\t\tif (px > xx) {\n\t\t\t\tif (py == yy) {\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpx = 0;\n\t\t\t\tpy++;\n\t\t\t\txx = window_copy_find_length(wme, py);\n\t\t\t} else\n\t\t\t\tpx++;\n\n\t\t\tgrid_get_cell(s->grid, px, py, &gc);\n\t\t\tif (gc.data.size == 1 &&\n\t\t\t    (~gc.flags & GRID_FLAG_PADDING)) {\n\t\t\t\tif (*gc.data.data == found)\n\t\t\t\t\tn++;\n\t\t\t\telse if (*gc.data.data == end)\n\t\t\t\t\tn--;\n\t\t\t}\n\t\t} while (n != 0);\n\n\t\t/* Move the cursor to the found location if any. */\n\t\tif (!failed)\n\t\t\twindow_copy_scroll_to(wme, px, py, 0);\n\t}\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_paragraph(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_next_paragraph(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_space(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_next_word(wme, \"\");\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_space_end(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_next_word_end(wme, \"\", 0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_word(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*separators;\n\n\tseparators = options_get_string(cs->s->options, \"word-separators\");\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_next_word(wme, separators);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_word_end(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*separators;\n\n\tseparators = options_get_string(cs->s->options, \"word-separators\");\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_next_word_end(wme, separators, 0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_other_end(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->selflag = SEL_CHAR;\n\tif ((np % 2) != 0)\n\t\twindow_copy_other_end(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_page_down(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--) {\n\t\tif (window_copy_pagedown1(wme, 0, data->scroll_exit))\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_page_down_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--) {\n\t\tif (window_copy_pagedown1(wme, 0, 1))\n\t\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_page_up(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_pageup1(wme, 0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_previous_paragraph(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_previous_paragraph(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_previous_space(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_previous_word(wme, \"\", 1);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_previous_word(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*separators;\n\n\tseparators = options_get_string(cs->s->options, \"word-separators\");\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_previous_word(wme, separators, 1);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_rectangle_on(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->lineflag = LINE_SEL_NONE;\n\twindow_copy_rectangle_set(wme, 1);\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_rectangle_off(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->lineflag = LINE_SEL_NONE;\n\twindow_copy_rectangle_set(wme, 0);\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_rectangle_toggle(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->lineflag = LINE_SEL_NONE;\n\twindow_copy_rectangle_set(wme, !data->rectflag);\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_down(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_down(wme, 1);\n\tif (data->scroll_exit && data->oy == 0)\n\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_down_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_down(wme, 1);\n\tif (data->oy == 0)\n\t\treturn (WINDOW_COPY_CMD_CANCEL);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_scroll_up(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tfor (; np != 0; np--)\n\t\twindow_copy_cursor_up(wme, 1);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_again(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (data->searchtype == WINDOW_COPY_SEARCHUP) {\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_up(wme, data->searchregex);\n\t} else if (data->searchtype == WINDOW_COPY_SEARCHDOWN) {\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_down(wme, data->searchregex);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_reverse(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (data->searchtype == WINDOW_COPY_SEARCHUP) {\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_down(wme, data->searchregex);\n\t} else if (data->searchtype == WINDOW_COPY_SEARCHDOWN) {\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_up(wme, data->searchregex);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_select_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tdata->lineflag = LINE_SEL_LEFT_RIGHT;\n\tdata->rectflag = 0;\n\tdata->selflag = SEL_LINE;\n\tdata->dx = data->cx;\n\tdata->dy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\twindow_copy_cursor_start_of_line(wme);\n\tdata->selrx = data->cx;\n\tdata->selry = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->endselry = data->selry;\n\twindow_copy_start_selection(wme);\n\twindow_copy_cursor_end_of_line(wme);\n\tdata->endselry = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->endselrx = window_copy_find_length(wme, data->endselry);\n\tfor (; np > 1; np--) {\n\t\twindow_copy_cursor_down(wme, 0);\n\t\twindow_copy_cursor_end_of_line(wme);\n\t}\n\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_select_word(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct options\t\t\t*session_options = cs->s->options;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t px, py, nextx, nexty;\n\n\tdata->lineflag = LINE_SEL_LEFT_RIGHT;\n\tdata->rectflag = 0;\n\tdata->selflag = SEL_WORD;\n\tdata->dx = data->cx;\n\tdata->dy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\tdata->separators = options_get_string(session_options,\n\t    \"word-separators\");\n\twindow_copy_cursor_previous_word(wme, data->separators, 0);\n\tpx = data->cx;\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->selrx = px;\n\tdata->selry = py;\n\twindow_copy_start_selection(wme);\n\n\t/* Handle single character words. */\n\tnextx = px + 1;\n\tnexty = py;\n\tif (grid_get_line(data->backing->grid, nexty)->flags &\n\t    GRID_LINE_WRAPPED && nextx > screen_size_x(data->backing) - 1) {\n\t\tnextx = 0;\n\t\tnexty++;\n\t}\n\tif (px >= window_copy_find_length(wme, py) ||\n\t    !window_copy_in_set(wme, nextx, nexty, WHITESPACE))\n\t\twindow_copy_cursor_next_word_end(wme, data->separators, 1);\n\telse {\n\t\twindow_copy_update_cursor(wme, px, data->cy);\n\t\tif (window_copy_update_selection(wme, 1, 1))\n\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t}\n\tdata->endselrx = data->cx;\n\tdata->endselry = screen_hsize(data->backing) + data->cy - data->oy;\n\tif (data->dy > data->endselry) {\n\t\tdata->dy = data->endselry;\n\t\tdata->dx = data->endselrx;\n\t} else if (data->dx > data->endselrx)\n\t\tdata->dx = data->endselrx;\n\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_set_mark(struct window_copy_cmd_state *cs)\n{\n\tstruct window_copy_mode_data\t*data = cs->wme->data;\n\n\tdata->mx = data->cx;\n\tdata->my = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->showmark = 1;\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_start_of_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cursor_start_of_line(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_top_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->cx = 0;\n\tdata->cy = 0;\n\n\twindow_copy_update_selection(wme, 1, 0);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_no_clear(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct client\t\t\t*c = cs->c;\n\tstruct session\t\t\t*s = cs->s;\n\tstruct winlink\t\t\t*wl = cs->wl;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tchar\t\t\t\t*command = NULL, *prefix = NULL;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\tconst char\t\t\t*arg1 = args_string(cs->wargs, 1);\n\tint\t\t\t\t set_paste = !args_has(cs->wargs, 'P');\n\tint\t\t\t\t set_clip = !args_has(cs->wargs, 'C');\n\n\tif (arg1 != NULL)\n\t\tprefix = format_single(NULL, arg1, c, s, wl, wp);\n\n\tif (s != NULL && arg0 != NULL && *arg0 != '\\0')\n\t\tcommand = format_single(NULL, arg0, c, s, wl, wp);\n\twindow_copy_copy_pipe(wme, s, prefix, command,\n\t    set_paste, set_clip);\n\tfree(command);\n\n\tfree(prefix);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_copy_pipe_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_copy_pipe_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_copy_pipe_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_CANCEL);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_pipe_no_clear(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct client\t\t\t*c = cs->c;\n\tstruct session\t\t\t*s = cs->s;\n\tstruct winlink\t\t\t*wl = cs->wl;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tchar\t\t\t\t*command = NULL;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (s != NULL && arg0 != NULL && *arg0 != '\\0')\n\t\tcommand = format_single(NULL, arg0, c, s, wl, wp);\n\twindow_copy_pipe(wme, s, command);\n\tfree(command);\n\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_pipe(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_pipe_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_pipe_and_cancel(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cmd_pipe_no_clear(cs);\n\twindow_copy_clear_selection(wme);\n\treturn (WINDOW_COPY_CMD_CANCEL);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_goto_line(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (*arg0 != '\\0')\n\t\twindow_copy_goto_line(wme, arg0);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_backward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (*arg0 != '\\0') {\n\t\tdata->jumptype = WINDOW_COPY_JUMPBACKWARD;\n\t\tfree(data->jumpchar);\n\t\tdata->jumpchar = utf8_fromcstr(arg0);\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_back(wme);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_forward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (*arg0 != '\\0') {\n\t\tdata->jumptype = WINDOW_COPY_JUMPFORWARD;\n\t\tfree(data->jumpchar);\n\t\tdata->jumpchar = utf8_fromcstr(arg0);\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump(wme);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_to_backward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (*arg0 != '\\0') {\n\t\tdata->jumptype = WINDOW_COPY_JUMPTOBACKWARD;\n\t\tfree(data->jumpchar);\n\t\tdata->jumpchar = utf8_fromcstr(arg0);\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to_back(wme);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_to_forward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\n\tif (*arg0 != '\\0') {\n\t\tdata->jumptype = WINDOW_COPY_JUMPTOFORWARD;\n\t\tfree(data->jumpchar);\n\t\tdata->jumpchar = utf8_fromcstr(arg0);\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_jump_to(wme);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_jump_to_mark(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_jump_to_mark(wme);\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_next_prompt(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cursor_prompt(wme, 1, args_has(cs->wargs, 'o'));\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_previous_prompt(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\n\twindow_copy_cursor_prompt(wme, 0, args_has(cs->wargs, 'o'));\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_backward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (!window_copy_expand_search_string(cs))\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\n\tif (data->searchstr != NULL) {\n\t\tdata->searchtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->searchregex = 1;\n\t\tdata->timeout = 0;\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_up(wme, 1);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_backward_text(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (!window_copy_expand_search_string(cs))\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\n\tif (data->searchstr != NULL) {\n\t\tdata->searchtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->searchregex = 0;\n\t\tdata->timeout = 0;\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_up(wme, 0);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_forward(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (!window_copy_expand_search_string(cs))\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\n\tif (data->searchstr != NULL) {\n\t\tdata->searchtype = WINDOW_COPY_SEARCHDOWN;\n\t\tdata->searchregex = 1;\n\t\tdata->timeout = 0;\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_down(wme, 1);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_forward_text(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t np = wme->prefix;\n\n\tif (!window_copy_expand_search_string(cs))\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\n\tif (data->searchstr != NULL) {\n\t\tdata->searchtype = WINDOW_COPY_SEARCHDOWN;\n\t\tdata->searchregex = 0;\n\t\tdata->timeout = 0;\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_search_down(wme, 0);\n\t}\n\treturn (WINDOW_COPY_CMD_NOTHING);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_backward_incremental(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\tconst char\t\t\t*ss = data->searchstr;\n\tchar\t\t\t\t prefix;\n\tenum window_copy_cmd_action\t action = WINDOW_COPY_CMD_NOTHING;\n\n\tdata->timeout = 0;\n\n\tlog_debug(\"%s: %s\", __func__, arg0);\n\n\tprefix = *arg0++;\n\tif (data->searchx == -1 || data->searchy == -1) {\n\t\tdata->searchx = data->cx;\n\t\tdata->searchy = data->cy;\n\t\tdata->searcho = data->oy;\n\t} else if (ss != NULL && strcmp(arg0, ss) != 0) {\n\t\tdata->cx = data->searchx;\n\t\tdata->cy = data->searchy;\n\t\tdata->oy = data->searcho;\n\t\taction = WINDOW_COPY_CMD_REDRAW;\n\t}\n\tif (*arg0 == '\\0') {\n\t\twindow_copy_clear_marks(wme);\n\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t}\n\tswitch (prefix) {\n\tcase '=':\n\tcase '-':\n\t\tdata->searchtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->searchregex = 0;\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = xstrdup(arg0);\n\t\tif (!window_copy_search_up(wme, 0)) {\n\t\t\twindow_copy_clear_marks(wme);\n\t\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t\t}\n\t\tbreak;\n\tcase '+':\n\t\tdata->searchtype = WINDOW_COPY_SEARCHDOWN;\n\t\tdata->searchregex = 0;\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = xstrdup(arg0);\n\t\tif (!window_copy_search_down(wme, 0)) {\n\t\t\twindow_copy_clear_marks(wme);\n\t\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (action);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_search_forward_incremental(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tconst char\t\t\t*arg0 = args_string(cs->wargs, 0);\n\tconst char\t\t\t*ss = data->searchstr;\n\tchar\t\t\t\t prefix;\n\tenum window_copy_cmd_action\t action = WINDOW_COPY_CMD_NOTHING;\n\n\tdata->timeout = 0;\n\n\tlog_debug(\"%s: %s\", __func__, arg0);\n\n\tprefix = *arg0++;\n\tif (data->searchx == -1 || data->searchy == -1) {\n\t\tdata->searchx = data->cx;\n\t\tdata->searchy = data->cy;\n\t\tdata->searcho = data->oy;\n\t} else if (ss != NULL && strcmp(arg0, ss) != 0) {\n\t\tdata->cx = data->searchx;\n\t\tdata->cy = data->searchy;\n\t\tdata->oy = data->searcho;\n\t\taction = WINDOW_COPY_CMD_REDRAW;\n\t}\n\tif (*arg0 == '\\0') {\n\t\twindow_copy_clear_marks(wme);\n\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t}\n\tswitch (prefix) {\n\tcase '=':\n\tcase '+':\n\t\tdata->searchtype = WINDOW_COPY_SEARCHDOWN;\n\t\tdata->searchregex = 0;\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = xstrdup(arg0);\n\t\tif (!window_copy_search_down(wme, 0)) {\n\t\t\twindow_copy_clear_marks(wme);\n\t\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tdata->searchtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->searchregex = 0;\n\t\tfree(data->searchstr);\n\t\tdata->searchstr = xstrdup(arg0);\n\t\tif (!window_copy_search_up(wme, 0)) {\n\t\t\twindow_copy_clear_marks(wme);\n\t\t\treturn (WINDOW_COPY_CMD_REDRAW);\n\t\t}\n\t}\n\treturn (action);\n}\n\nstatic enum window_copy_cmd_action\nwindow_copy_cmd_refresh_from_pane(struct window_copy_cmd_state *cs)\n{\n\tstruct window_mode_entry\t*wme = cs->wme;\n\tstruct window_pane\t\t*wp = wme->swp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tif (data->viewmode)\n\t\treturn (WINDOW_COPY_CMD_NOTHING);\n\n\tscreen_free(data->backing);\n\tfree(data->backing);\n\tdata->backing = window_copy_clone_screen(&wp->base, &data->screen, NULL,\n\t    NULL, wme->swp != wme->wp);\n\n\twindow_copy_size_changed(wme);\n\treturn (WINDOW_COPY_CMD_REDRAW);\n}\n\nstatic const struct {\n\tconst char\t\t\t *command;\n\tu_int\t\t\t\t  minargs;\n\tu_int\t\t\t\t  maxargs;\n\tstruct args_parse\t\t  args;\n\tenum window_copy_cmd_clear\t  clear;\n\tenum window_copy_cmd_action\t(*f)(struct window_copy_cmd_state *);\n} window_copy_cmd_table[] = {\n\t{ .command = \"append-selection\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_append_selection\n\t},\n\t{ .command = \"append-selection-and-cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_append_selection_and_cancel\n\t},\n\t{ .command = \"back-to-indentation\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_back_to_indentation\n\t},\n\t{ .command = \"begin-selection\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_begin_selection\n\t},\n\t{ .command = \"bottom-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_bottom_line\n\t},\n\t{ .command = \"cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_cancel\n\t},\n\t{ .command = \"clear-selection\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_clear_selection\n\t},\n\t{ .command = \"copy-end-of-line\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_end_of_line\n\t},\n\t{ .command = \"copy-end-of-line-and-cancel\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_end_of_line_and_cancel\n\t},\n\t{ .command = \"copy-pipe-end-of-line\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe_end_of_line\n\t},\n\t{ .command = \"copy-pipe-end-of-line-and-cancel\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe_end_of_line_and_cancel\n\t},\n\t{ .command = \"copy-line\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_line\n\t},\n\t{ .command = \"copy-line-and-cancel\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_line_and_cancel\n\t},\n\t{ .command = \"copy-pipe-line\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe_line\n\t},\n\t{ .command = \"copy-pipe-line-and-cancel\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe_line_and_cancel\n\t},\n\t{ .command = \"copy-pipe-no-clear\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_NEVER,\n\t  .f = window_copy_cmd_copy_pipe_no_clear\n\t},\n\t{ .command = \"copy-pipe\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe\n\t},\n\t{ .command = \"copy-pipe-and-cancel\",\n\t  .args = { \"CP\", 0, 2, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_pipe_and_cancel\n\t},\n\t{ .command = \"copy-selection-no-clear\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_NEVER,\n\t  .f = window_copy_cmd_copy_selection_no_clear\n\t},\n\t{ .command = \"copy-selection\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_selection\n\t},\n\t{ .command = \"copy-selection-and-cancel\",\n\t  .args = { \"CP\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_copy_selection_and_cancel\n\t},\n\t{ .command = \"cursor-down\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_cursor_down\n\t},\n\t{ .command = \"cursor-down-and-cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_cursor_down_and_cancel\n\t},\n\t{ .command = \"cursor-left\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_cursor_left\n\t},\n\t{ .command = \"cursor-right\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_cursor_right\n\t},\n\t{ .command = \"cursor-up\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_cursor_up\n\t},\n\t{ .command = \"end-of-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_end_of_line\n\t},\n\t{ .command = \"goto-line\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_goto_line\n\t},\n\t{ .command = \"halfpage-down\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_halfpage_down\n\t},\n\t{ .command = \"halfpage-down-and-cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_halfpage_down_and_cancel\n\t},\n\t{ .command = \"halfpage-up\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_halfpage_up\n\t},\n\t{ .command = \"history-bottom\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_history_bottom\n\t},\n\t{ .command = \"history-top\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_history_top\n\t},\n\t{ .command = \"jump-again\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_again\n\t},\n\t{ .command = \"jump-backward\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_backward\n\t},\n\t{ .command = \"jump-forward\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_forward\n\t},\n\t{ .command = \"jump-reverse\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_reverse\n\t},\n\t{ .command = \"jump-to-backward\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_to_backward\n\t},\n\t{ .command = \"jump-to-forward\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_jump_to_forward\n\t},\n\t{ .command = \"jump-to-mark\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_jump_to_mark\n\t},\n\t{ .command = \"next-prompt\",\n\t  .args = { \"o\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_next_prompt\n\t},\n\t{ .command = \"previous-prompt\",\n\t  .args = { \"o\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_previous_prompt\n\t},\n\t{ .command = \"middle-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_middle_line\n\t},\n\t{ .command = \"next-matching-bracket\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_next_matching_bracket\n\t},\n\t{ .command = \"next-paragraph\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_next_paragraph\n\t},\n\t{ .command = \"next-space\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_next_space\n\t},\n\t{ .command = \"next-space-end\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_next_space_end\n\t},\n\t{ .command = \"next-word\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_next_word\n\t},\n\t{ .command = \"next-word-end\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_next_word_end\n\t},\n\t{ .command = \"other-end\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_other_end\n\t},\n\t{ .command = \"page-down\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_page_down\n\t},\n\t{ .command = \"page-down-and-cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_page_down_and_cancel\n\t},\n\t{ .command = \"page-up\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_page_up\n\t},\n\t{ .command = \"pipe-no-clear\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_NEVER,\n\t  .f = window_copy_cmd_pipe_no_clear\n\t},\n\t{ .command = \"pipe\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_pipe\n\t},\n\t{ .command = \"pipe-and-cancel\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_pipe_and_cancel\n\t},\n\t{ .command = \"previous-matching-bracket\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_previous_matching_bracket\n\t},\n\t{ .command = \"previous-paragraph\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_previous_paragraph\n\t},\n\t{ .command = \"previous-space\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_previous_space\n\t},\n\t{ .command = \"previous-word\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_previous_word\n\t},\n\t{ .command = \"rectangle-on\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_rectangle_on\n\t},\n\t{ .command = \"rectangle-off\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_rectangle_off\n\t},\n\t{ .command = \"rectangle-toggle\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_rectangle_toggle\n\t},\n\t{ .command = \"refresh-from-pane\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_refresh_from_pane\n\t},\n\t{ .command = \"scroll-bottom\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_scroll_bottom\n\t},\n\t{ .command = \"scroll-down\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_scroll_down\n\t},\n\t{ .command = \"scroll-down-and-cancel\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_scroll_down_and_cancel\n\t},\n\t{ .command = \"scroll-middle\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_scroll_middle\n\t},\n\t{ .command = \"scroll-top\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_scroll_top\n\t},\n\t{ .command = \"scroll-up\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_scroll_up\n\t},\n\t{ .command = \"search-again\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_again\n\t},\n\t{ .command = \"search-backward\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_backward\n\t},\n\t{ .command = \"search-backward-text\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_backward_text\n\t},\n\t{ .command = \"search-backward-incremental\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_backward_incremental\n\t},\n\t{ .command = \"search-forward\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_forward\n\t},\n\t{ .command = \"search-forward-text\",\n\t  .args = { \"\", 0, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_forward_text\n\t},\n\t{ .command = \"search-forward-incremental\",\n\t  .args = { \"\", 1, 1, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_forward_incremental\n\t},\n\t{ .command = \"search-reverse\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_search_reverse\n\t},\n\t{ .command = \"select-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_select_line\n\t},\n\t{ .command = \"select-word\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_select_word\n\t},\n\t{ .command = \"set-mark\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_set_mark\n\t},\n\t{ .command = \"start-of-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_start_of_line\n\t},\n\t{ .command = \"stop-selection\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_ALWAYS,\n\t  .f = window_copy_cmd_stop_selection\n\t},\n\t{ .command = \"toggle-position\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_NEVER,\n\t  .f = window_copy_cmd_toggle_position\n\t},\n\t{ .command = \"top-line\",\n\t  .args = { \"\", 0, 0, NULL },\n\t  .clear = WINDOW_COPY_CMD_CLEAR_EMACS_ONLY,\n\t  .f = window_copy_cmd_top_line\n\t}\n};\n\nstatic void\nwindow_copy_command(struct window_mode_entry *wme, struct client *c,\n    struct session *s, struct winlink *wl, struct args *args,\n    struct mouse_event *m)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_cmd_state\t cs;\n\tenum window_copy_cmd_action\t action;\n\tenum window_copy_cmd_clear\t clear = WINDOW_COPY_CMD_CLEAR_NEVER;\n\tconst char\t\t\t*command;\n\tu_int\t\t\t\t i, count = args_count(args);\n\tint\t\t\t\t keys;\n\tchar\t\t\t\t*error = NULL;\n\n\tif (count == 0)\n\t\treturn;\n\tcommand = args_string(args, 0);\n\n\tif (m != NULL && m->valid && !MOUSE_WHEEL(m->b))\n\t\twindow_copy_move_mouse(m);\n\n\tcs.wme = wme;\n\tcs.args = args;\n\tcs.wargs = NULL;\n\tcs.m = m;\n\n\tcs.c = c;\n\tcs.s = s;\n\tcs.wl = wl;\n\n\taction = WINDOW_COPY_CMD_NOTHING;\n\tfor (i = 0; i < nitems(window_copy_cmd_table); i++) {\n\t\tif (strcmp(window_copy_cmd_table[i].command, command) == 0) {\n\t\t\tcs.wargs = args_parse(&window_copy_cmd_table[i].args,\n\t\t\t    args_values(args), count, &error);\n\n\t\t\tif (error != NULL) {\n\t\t\t\tfree(error);\n\t\t\t\terror = NULL;\n\t\t\t}\n\t\t\tif (cs.wargs == NULL)\n\t\t\t\tbreak;\n\n\t\t\tclear = window_copy_cmd_table[i].clear;\n\t\t\taction = window_copy_cmd_table[i].f(&cs);\n\t\t\targs_free(cs.wargs);\n\t\t\tcs.wargs = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (strncmp(command, \"search-\", 7) != 0 && data->searchmark != NULL) {\n\t\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\t\tif (clear == WINDOW_COPY_CMD_CLEAR_EMACS_ONLY &&\n\t\t    keys == MODEKEY_VI)\n\t\t\tclear = WINDOW_COPY_CMD_CLEAR_NEVER;\n\t\tif (clear != WINDOW_COPY_CMD_CLEAR_NEVER) {\n\t\t\twindow_copy_clear_marks(wme);\n\t\t\tdata->searchx = data->searchy = -1;\n\t\t}\n\t\tif (action == WINDOW_COPY_CMD_NOTHING)\n\t\t\taction = WINDOW_COPY_CMD_REDRAW;\n\t}\n\twme->prefix = 1;\n\n\tif (action == WINDOW_COPY_CMD_CANCEL)\n\t\twindow_pane_reset_mode(wp);\n\telse if (action == WINDOW_COPY_CMD_REDRAW)\n\t\twindow_copy_redraw_screen(wme);\n}\n\nstatic void\nwindow_copy_scroll_to(struct window_mode_entry *wme, u_int px, u_int py,\n    int no_redraw)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tu_int\t\t\t\t offset, gap;\n\n\tdata->cx = px;\n\n\tif (py >= gd->hsize - data->oy && py < gd->hsize - data->oy + gd->sy)\n\t\tdata->cy = py - (gd->hsize - data->oy);\n\telse {\n\t\tgap = gd->sy / 4;\n\t\tif (py < gd->sy) {\n\t\t\toffset = 0;\n\t\t\tdata->cy = py;\n\t\t} else if (py > gd->hsize + gd->sy - gap) {\n\t\t\toffset = gd->hsize;\n\t\t\tdata->cy = py - gd->hsize;\n\t\t} else {\n\t\t\toffset = py + gap - gd->sy;\n\t\t\tdata->cy = py - offset;\n\t\t}\n\t\tdata->oy = gd->hsize - offset;\n\t}\n\n\tif (!no_redraw && data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 1, 0);\n\tif (!no_redraw)\n\t\twindow_copy_redraw_screen(wme);\n}\n\nstatic int\nwindow_copy_search_compare(struct grid *gd, u_int px, u_int py,\n    struct grid *sgd, u_int spx, int cis)\n{\n\tstruct grid_cell\t gc, sgc;\n\tconst struct utf8_data\t*ud, *sud;\n\n\tgrid_get_cell(gd, px, py, &gc);\n\tud = &gc.data;\n\tgrid_get_cell(sgd, spx, 0, &sgc);\n\tsud = &sgc.data;\n\n\tif (*sud->data == '\\t' && sud->size == 1 && gc.flags & GRID_FLAG_TAB)\n\t\treturn (1);\n\n\tif (ud->size != sud->size || ud->width != sud->width)\n\t\treturn (0);\n\n\tif (cis && ud->size == 1)\n\t\treturn (tolower(ud->data[0]) == sud->data[0]);\n\n\treturn (memcmp(ud->data, sud->data, ud->size) == 0);\n}\n\nstatic int\nwindow_copy_search_lr(struct grid *gd, struct grid *sgd, u_int *ppx, u_int py,\n    u_int first, u_int last, int cis)\n{\n\tu_int\t\t\t ax, bx, px, pywrap, endline, padding;\n\tint\t\t\t matched;\n\tstruct grid_line\t*gl;\n\tstruct grid_cell\t gc;\n\n\tendline = gd->hsize + gd->sy - 1;\n\tfor (ax = first; ax < last; ax++) {\n\t\tpadding = 0;\n\t\tfor (bx = 0; bx < sgd->sx; bx++) {\n\t\t\tpx = ax + bx + padding;\n\t\t\tpywrap = py;\n\t\t\t/* Wrap line. */\n\t\t\twhile (px >= gd->sx && pywrap < endline) {\n\t\t\t\tgl = grid_get_line(gd, pywrap);\n\t\t\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\t\t\tbreak;\n\t\t\t\tpx -= gd->sx;\n\t\t\t\tpywrap++;\n\t\t\t}\n\t\t\t/* We have run off the end of the grid. */\n\t\t\tif (px - padding >= gd->sx)\n\t\t\t\tbreak;\n\n\t\t\tgrid_get_cell(gd, px, pywrap, &gc);\n\t\t\tif (gc.flags & GRID_FLAG_TAB)\n\t\t\t\tpadding += gc.data.width - 1;\n\n\t\t\tmatched = window_copy_search_compare(gd, px, pywrap,\n\t\t\t    sgd, bx, cis);\n\t\t\tif (!matched)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bx == sgd->sx) {\n\t\t\t*ppx = ax;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nwindow_copy_search_rl(struct grid *gd,\n    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last, int cis)\n{\n\tu_int\t\t\t ax, bx, px, pywrap, endline, padding;\n\tint\t\t\t matched;\n\tstruct grid_line\t*gl;\n\tstruct grid_cell\t gc;\n\n\tendline = gd->hsize + gd->sy - 1;\n\tfor (ax = last; ax > first; ax--) {\n\t\tpadding = 0;\n\t\tfor (bx = 0; bx < sgd->sx; bx++) {\n\t\t\tpx = ax - 1 + bx + padding;\n\t\t\tpywrap = py;\n\t\t\t/* Wrap line. */\n\t\t\twhile (px >= gd->sx && pywrap < endline) {\n\t\t\t\tgl = grid_get_line(gd, pywrap);\n\t\t\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\t\t\tbreak;\n\t\t\t\tpx -= gd->sx;\n\t\t\t\tpywrap++;\n\t\t\t}\n\t\t\t/* We have run off the end of the grid. */\n\t\t\tif (px - padding >= gd->sx)\n\t\t\t\tbreak;\n\n\t\t\tgrid_get_cell(gd, px, pywrap, &gc);\n\t\t\tif (gc.flags & GRID_FLAG_TAB)\n\t\t\t\tpadding += gc.data.width - 1;\n\n\t\t\tmatched = window_copy_search_compare(gd, px, pywrap,\n\t\t\t    sgd, bx, cis);\n\t\t\tif (!matched)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bx == sgd->sx) {\n\t\t\t*ppx = ax - 1;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nwindow_copy_search_lr_regex(struct grid *gd, u_int *ppx, u_int *psx, u_int py,\n    u_int first, u_int last, regex_t *reg)\n{\n\tint\t\t\teflags = 0;\n\tu_int\t\t\tendline, foundx, foundy, len, pywrap, size = 1;\n\tchar\t\t       *buf;\n\tregmatch_t\t\tregmatch;\n\tstruct grid_line       *gl;\n\n\t/*\n\t * This can happen during search if the last match was the last\n\t * character on a line.\n\t */\n\tif (first >= last)\n\t\treturn (0);\n\n\t/* Set flags for regex search. */\n\tif (first != 0)\n\t\teflags |= REG_NOTBOL;\n\n\t/* Need to look at the entire string. */\n\tbuf = xmalloc(size);\n\tbuf[0] = '\\0';\n\tbuf = window_copy_stringify(gd, py, first, gd->sx, buf, &size);\n\tlen = gd->sx - first;\n\tendline = gd->hsize + gd->sy - 1;\n\tpywrap = py;\n\twhile (buf != NULL &&\n\t    pywrap <= endline &&\n\t    len < WINDOW_COPY_SEARCH_MAX_LINE) {\n\t\tgl = grid_get_line(gd, pywrap);\n\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\tbreak;\n\t\tpywrap++;\n\t\tbuf = window_copy_stringify(gd, pywrap, 0, gd->sx, buf, &size);\n\t\tlen += gd->sx;\n\t}\n\n\tif (regexec(reg, buf, 1, &regmatch, eflags) == 0 &&\n\t    regmatch.rm_so != regmatch.rm_eo) {\n\t\tfoundx = first;\n\t\tfoundy = py;\n\t\twindow_copy_cstrtocellpos(gd, len, &foundx, &foundy,\n\t\t    buf + regmatch.rm_so);\n\t\tif (foundy == py && foundx < last) {\n\t\t\t*ppx = foundx;\n\t\t\tlen -= foundx - first;\n\t\t\twindow_copy_cstrtocellpos(gd, len, &foundx, &foundy,\n\t\t\t    buf + regmatch.rm_eo);\n\t\t\t*psx = foundx;\n\t\t\twhile (foundy > py) {\n\t\t\t\t*psx += gd->sx;\n\t\t\t\tfoundy--;\n\t\t\t}\n\t\t\t*psx -= *ppx;\n\t\t\tfree(buf);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tfree(buf);\n\t*ppx = 0;\n\t*psx = 0;\n\treturn (0);\n}\n\nstatic int\nwindow_copy_search_rl_regex(struct grid *gd, u_int *ppx, u_int *psx, u_int py,\n    u_int first, u_int last, regex_t *reg)\n{\n\tint\t\t\teflags = 0;\n\tu_int\t\t\tendline, len, pywrap, size = 1;\n\tchar\t\t       *buf;\n\tstruct grid_line       *gl;\n\n\t/* Set flags for regex search. */\n\tif (first != 0)\n\t\teflags |= REG_NOTBOL;\n\n\t/* Need to look at the entire string. */\n\tbuf = xmalloc(size);\n\tbuf[0] = '\\0';\n\tbuf = window_copy_stringify(gd, py, first, gd->sx, buf, &size);\n\tlen = gd->sx - first;\n\tendline = gd->hsize + gd->sy - 1;\n\tpywrap = py;\n\twhile (buf != NULL &&\n\t    pywrap <= endline &&\n\t    len < WINDOW_COPY_SEARCH_MAX_LINE) {\n\t\tgl = grid_get_line(gd, pywrap);\n\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\tbreak;\n\t\tpywrap++;\n\t\tbuf = window_copy_stringify(gd, pywrap, 0, gd->sx, buf, &size);\n\t\tlen += gd->sx;\n\t}\n\n\tif (window_copy_last_regex(gd, py, first, last, len, ppx, psx, buf,\n\t    reg, eflags))\n\t{\n\t\tfree(buf);\n\t\treturn (1);\n\t}\n\n\tfree(buf);\n\t*ppx = 0;\n\t*psx = 0;\n\treturn (0);\n}\n\nstatic const char *\nwindow_copy_cellstring(const struct grid_line *gl, u_int px, size_t *size,\n    int *allocated)\n{\n\tstatic struct utf8_data\t ud;\n\tstruct grid_cell_entry\t*gce;\n\tchar\t\t\t*copy;\n\n\tif (px >= gl->cellsize) {\n\t\t*size = 1;\n\t\t*allocated = 0;\n\t\treturn (\" \");\n\t}\n\n\tgce = &gl->celldata[px];\n\tif (gce->flags & GRID_FLAG_PADDING) {\n\t\t*size = 0;\n\t\t*allocated = 0;\n\t\treturn (NULL);\n\t}\n\tif (~gce->flags & GRID_FLAG_EXTENDED) {\n\t\t*size = 1;\n\t\t*allocated = 0;\n\t\treturn (&gce->data.data);\n\t}\n\tif (gce->flags & GRID_FLAG_TAB) {\n\t\t*size = 1;\n\t\t*allocated = 0;\n\t\treturn (\"\\t\");\n\t}\n\n\tutf8_to_data(gl->extddata[gce->offset].data, &ud);\n\tif (ud.size == 0) {\n\t\t*size = 0;\n\t\t*allocated = 0;\n\t\treturn (NULL);\n\t}\n\t*size = ud.size;\n\t*allocated = 1;\n\n\tcopy = xmalloc(ud.size);\n\tmemcpy(copy, ud.data, ud.size);\n\treturn (copy);\n}\n\n/* Find last match in given range. */\nstatic int\nwindow_copy_last_regex(struct grid *gd, u_int py, u_int first, u_int last,\n    u_int len, u_int *ppx, u_int *psx, const char *buf, const regex_t *preg,\n    int eflags)\n{\n\tu_int\t\tfoundx, foundy, oldx, px = 0, savepx, savesx = 0;\n\tregmatch_t\tregmatch;\n\n\tfoundx = first;\n\tfoundy = py;\n\toldx = first;\n\twhile (regexec(preg, buf + px, 1, &regmatch, eflags) == 0) {\n\t\tif (regmatch.rm_so == regmatch.rm_eo)\n\t\t\tbreak;\n\t\twindow_copy_cstrtocellpos(gd, len, &foundx, &foundy,\n\t\t    buf + px + regmatch.rm_so);\n\t\tif (foundy > py || foundx >= last)\n\t\t\tbreak;\n\t\tlen -= foundx - oldx;\n\t\tsavepx = foundx;\n\t\twindow_copy_cstrtocellpos(gd, len, &foundx, &foundy,\n\t\t    buf + px + regmatch.rm_eo);\n\t\tif (foundy > py || foundx >= last) {\n\t\t\t*ppx = savepx;\n\t\t\t*psx = foundx;\n\t\t\twhile (foundy > py) {\n\t\t\t\t*psx += gd->sx;\n\t\t\t\tfoundy--;\n\t\t\t}\n\t\t\t*psx -= *ppx;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tsavesx = foundx - savepx;\n\t\t\tlen -= savesx;\n\t\t\toldx = foundx;\n\t\t}\n\t\tpx += regmatch.rm_eo;\n\t}\n\n\tif (savesx > 0) {\n\t\t*ppx = savepx;\n\t\t*psx = savesx;\n\t\treturn (1);\n\t} else {\n\t\t*ppx = 0;\n\t\t*psx = 0;\n\t\treturn (0);\n\t}\n}\n\n/* Stringify line and append to input buffer. Caller frees. */\nstatic char *\nwindow_copy_stringify(struct grid *gd, u_int py, u_int first, u_int last,\n    char *buf, u_int *size)\n{\n\tu_int\t\t\t ax, bx, newsize = *size;\n\tconst struct grid_line\t*gl;\n\tconst char\t\t*d;\n\tsize_t\t\t\t bufsize = 1024, dlen;\n\tint\t\t\t allocated;\n\n\twhile (bufsize < newsize)\n\t\tbufsize *= 2;\n\tbuf = xrealloc(buf, bufsize);\n\n\tgl = grid_peek_line(gd, py);\n\tbx = *size - 1;\n\tfor (ax = first; ax < last; ax++) {\n\t\td = window_copy_cellstring(gl, ax, &dlen, &allocated);\n\t\tnewsize += dlen;\n\t\twhile (bufsize < newsize) {\n\t\t\tbufsize *= 2;\n\t\t\tbuf = xrealloc(buf, bufsize);\n\t\t}\n\t\tif (dlen == 1)\n\t\t\tbuf[bx++] = *d;\n\t\telse {\n\t\t\tmemcpy(buf + bx, d, dlen);\n\t\t\tbx += dlen;\n\t\t}\n\t\tif (allocated)\n\t\t\tfree((void *)d);\n\t}\n\tbuf[newsize - 1] = '\\0';\n\n\t*size = newsize;\n\treturn (buf);\n}\n\n/* Map start of C string containing UTF-8 data to grid cell position. */\nstatic void\nwindow_copy_cstrtocellpos(struct grid *gd, u_int ncells, u_int *ppx, u_int *ppy,\n    const char *str)\n{\n\tu_int\t\t\t cell, ccell, px, pywrap, pos, len;\n\tint\t\t\t match;\n\tconst struct grid_line\t*gl;\n\tconst char\t\t*d;\n\tsize_t\t\t\t dlen;\n\tstruct {\n\t\tconst char\t*d;\n\t\tsize_t\t\t dlen;\n\t\tint\t\t allocated;\n\t} *cells;\n\n\t/* Populate the array of cell data. */\n\tcells = xreallocarray(NULL, ncells, sizeof cells[0]);\n\tcell = 0;\n\tpx = *ppx;\n\tpywrap = *ppy;\n\tgl = grid_peek_line(gd, pywrap);\n\twhile (cell < ncells) {\n\t\tcells[cell].d = window_copy_cellstring(gl, px,\n\t\t    &cells[cell].dlen, &cells[cell].allocated);\n\t\tcell++;\n\t\tpx++;\n\t\tif (px == gd->sx) {\n\t\t\tpx = 0;\n\t\t\tpywrap++;\n\t\t\tgl = grid_peek_line(gd, pywrap);\n\t\t}\n\t}\n\n\t/* Locate starting cell. */\n\tcell = 0;\n\tlen = strlen(str);\n\twhile (cell < ncells) {\n\t\tccell = cell;\n\t\tpos = 0;\n\t\tmatch = 1;\n\t\twhile (ccell < ncells) {\n\t\t\tif (str[pos] == '\\0') {\n\t\t\t\tmatch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = cells[ccell].d;\n\t\t\tdlen = cells[ccell].dlen;\n\t\t\tif (dlen == 1) {\n\t\t\t\tif (str[pos] != *d) {\n\t\t\t\t\tmatch = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t} else {\n\t\t\t\tif (dlen > len - pos)\n\t\t\t\t\tdlen = len - pos;\n\t\t\t\tif (memcmp(str + pos, d, dlen) != 0) {\n\t\t\t\t\tmatch = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos += dlen;\n\t\t\t}\n\t\t\tccell++;\n\t\t}\n\t\tif (match)\n\t\t\tbreak;\n\t\tcell++;\n\t}\n\n\t/* If not found this will be one past the end. */\n\tpx = *ppx + cell;\n\tpywrap = *ppy;\n\twhile (px >= gd->sx) {\n\t\tpx -= gd->sx;\n\t\tpywrap++;\n\t}\n\n\t*ppx = px;\n\t*ppy = pywrap;\n\n\t/* Free cell data. */\n\tfor (cell = 0; cell < ncells; cell++) {\n\t\tif (cells[cell].allocated)\n\t\t\tfree((void *)cells[cell].d);\n\t}\n\tfree(cells);\n}\n\nstatic void\nwindow_copy_move_left(struct screen *s, u_int *fx, u_int *fy, int wrapflag)\n{\n\tif (*fx == 0) {\t/* left */\n\t\tif (*fy == 0) { /* top */\n\t\t\tif (wrapflag) {\n\t\t\t\t*fx = screen_size_x(s) - 1;\n\t\t\t\t*fy = screen_hsize(s) + screen_size_y(s) - 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*fx = screen_size_x(s) - 1;\n\t\t*fy = *fy - 1;\n\t} else\n\t\t*fx = *fx - 1;\n}\n\nstatic void\nwindow_copy_move_right(struct screen *s, u_int *fx, u_int *fy, int wrapflag)\n{\n\tif (*fx == screen_size_x(s) - 1) { /* right */\n\t\tif (*fy == screen_hsize(s) + screen_size_y(s) - 1) { /* bottom */\n\t\t\tif (wrapflag) {\n\t\t\t\t*fx = 0;\n\t\t\t\t*fy = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*fx = 0;\n\t\t*fy = *fy + 1;\n\t} else\n\t\t*fx = *fx + 1;\n}\n\nstatic int\nwindow_copy_is_lowercase(const char *ptr)\n{\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr != tolower((u_char)*ptr))\n\t\t\treturn (0);\n\t\t++ptr;\n\t}\n\treturn (1);\n}\n\n/*\n * Handle backward wrapped regex searches with overlapping matches. In this case\n * find the longest overlapping match from previous wrapped lines.\n */\nstatic void\nwindow_copy_search_back_overlap(struct grid *gd, regex_t *preg, u_int *ppx,\n    u_int *psx, u_int *ppy, u_int endline)\n{\n\tu_int\tendx, endy, oldendx, oldendy, px, py, sx;\n\tint\tfound = 1;\n\n\toldendx = *ppx + *psx;\n\toldendy = *ppy - 1;\n\twhile (oldendx > gd->sx - 1) {\n\t\toldendx -= gd->sx;\n\t\toldendy++;\n\t}\n\tendx = oldendx;\n\tendy = oldendy;\n\tpx = *ppx;\n\tpy = *ppy;\n\twhile (found && px == 0 && py - 1 > endline &&\n\t       grid_get_line(gd, py - 2)->flags & GRID_LINE_WRAPPED &&\n\t       endx == oldendx && endy == oldendy) {\n\t\tpy--;\n\t\tfound = window_copy_search_rl_regex(gd, &px, &sx, py - 1, 0,\n\t\t    gd->sx, preg);\n\t\tif (found) {\n\t\t\tendx = px + sx;\n\t\t\tendy = py - 1;\n\t\t\twhile (endx > gd->sx - 1) {\n\t\t\t\tendx -= gd->sx;\n\t\t\t\tendy++;\n\t\t\t}\n\t\t\tif (endx == oldendx && endy == oldendy) {\n\t\t\t\t*ppx = px;\n\t\t\t\t*ppy = py;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Search for text stored in sgd starting from position fx,fy up to endline. If\n * found, jump to it. If cis then ignore case. The direction is 0 for searching\n * up, down otherwise. If wrap then go to begin/end of grid and try again if\n * not found.\n */\nstatic int\nwindow_copy_search_jump(struct window_mode_entry *wme, struct grid *gd,\n    struct grid *sgd, u_int fx, u_int fy, u_int endline, int cis, int wrap,\n    int direction, int regex)\n{\n\tu_int\t i, px, sx, ssize = 1;\n\tint\t found = 0, cflags = REG_EXTENDED;\n\tchar\t*sbuf;\n\tregex_t\t reg;\n\n\tif (regex) {\n\t\tsbuf = xmalloc(ssize);\n\t\tsbuf[0] = '\\0';\n\t\tsbuf = window_copy_stringify(sgd, 0, 0, sgd->sx, sbuf, &ssize);\n\t\tif (cis)\n\t\t\tcflags |= REG_ICASE;\n\t\tif (regcomp(&reg, sbuf, cflags) != 0) {\n\t\t\tfree(sbuf);\n\t\t\treturn (0);\n\t\t}\n\t\tfree(sbuf);\n\t}\n\n\tif (direction) {\n\t\tfor (i = fy; i <= endline; i++) {\n\t\t\tif (regex) {\n\t\t\t\tfound = window_copy_search_lr_regex(gd,\n\t\t\t\t    &px, &sx, i, fx, gd->sx, &reg);\n\t\t\t} else {\n\t\t\t\tfound = window_copy_search_lr(gd, sgd,\n\t\t\t\t    &px, i, fx, gd->sx, cis);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t\tfx = 0;\n\t\t}\n\t} else {\n\t\tfor (i = fy + 1; endline < i; i--) {\n\t\t\tif (regex) {\n\t\t\t\tfound = window_copy_search_rl_regex(gd,\n\t\t\t\t    &px, &sx, i - 1, 0, fx + 1, &reg);\n\t\t\t\tif (found) {\n\t\t\t\t\twindow_copy_search_back_overlap(gd,\n\t\t\t\t\t    &reg, &px, &sx, &i, endline);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfound = window_copy_search_rl(gd, sgd,\n\t\t\t\t    &px, i - 1, 0, fx + 1, cis);\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfx = gd->sx - 1;\n\t\t}\n\t}\n\tif (regex)\n\t\tregfree(&reg);\n\n\tif (found) {\n\t\twindow_copy_scroll_to(wme, px, i, 1);\n\t\treturn (1);\n\t}\n\tif (wrap) {\n\t\treturn (window_copy_search_jump(wme, gd, sgd,\n\t\t    direction ? 0 : gd->sx - 1,\n\t\t    direction ? 0 : gd->hsize + gd->sy - 1, fy, cis, 0,\n\t\t    direction, regex));\n\t}\n\treturn (0);\n}\n\nstatic void\nwindow_copy_move_after_search_mark(struct window_copy_mode_data *data,\n    u_int *fx, u_int *fy, int wrapflag)\n{\n\tstruct screen  *s = data->backing;\n\tu_int\t\tat, start;\n\n\tif (window_copy_search_mark_at(data, *fx, *fy, &start) == 0 &&\n\t    data->searchmark[start] != 0) {\n\t\twhile (window_copy_search_mark_at(data, *fx, *fy, &at) == 0) {\n\t\t\tif (data->searchmark[at] != data->searchmark[start])\n\t\t\t\tbreak;\n\t\t\t/* Stop if not wrapping and at the end of the grid. */\n\t\t\tif (!wrapflag &&\n\t\t\t    *fx == screen_size_x(s) - 1 &&\n\t\t\t    *fy == screen_hsize(s) + screen_size_y(s) - 1)\n\t\t\t\tbreak;\n\n\t\t\twindow_copy_move_right(s, fx, fy, wrapflag);\n\t\t}\n\t}\n}\n\n/*\n * Search in for text searchstr. If direction is 0 then search up, otherwise\n * down.\n */\nstatic int\nwindow_copy_search(struct window_mode_entry *wme, int direction, int regex)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing, ss;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct grid\t\t\t*gd = s->grid;\n\tconst char\t\t\t*str = data->searchstr;\n\tu_int\t\t\t\t at, endline, fx, fy, start, ssx;\n\tint\t\t\t\t cis, found, keys, visible_only;\n\tint\t\t\t\t wrapflag;\n\n\tif (regex && str[strcspn(str, \"^$*+()?[].\\\\\")] == '\\0')\n\t\tregex = 0;\n\n\tdata->searchdirection = direction;\n\n\tif (data->timeout)\n\t\treturn (0);\n\n\tif (data->searchall || wp->searchstr == NULL ||\n\t    wp->searchregex != regex) {\n\t\tvisible_only = 0;\n\t\tdata->searchall = 0;\n\t} else\n\t\tvisible_only = (strcmp(wp->searchstr, str) == 0);\n\tif (visible_only == 0 && data->searchmark != NULL)\n\t\twindow_copy_clear_marks(wme);\n\tfree(wp->searchstr);\n\twp->searchstr = xstrdup(str);\n\twp->searchregex = regex;\n\n\tfx = data->cx;\n\tfy = screen_hsize(data->backing) - data->oy + data->cy;\n\n\tif ((ssx = screen_write_strlen(\"%s\", str)) == 0)\n\t\treturn (0);\n\tscreen_init(&ss, ssx, 1, 0);\n\tscreen_write_start(&ctx, &ss);\n\tscreen_write_nputs(&ctx, -1, &grid_default_cell, \"%s\", str);\n\tscreen_write_stop(&ctx);\n\n\twrapflag = options_get_number(wp->window->options, \"wrap-search\");\n\tcis = window_copy_is_lowercase(str);\n\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\n\tif (direction) {\n\t\t/*\n\t\t * Behave according to mode-keys. If it is emacs, search forward\n\t\t * leaves the cursor after the match. If it is vi, the cursor\n\t\t * remains at the beginning of the match, regardless of\n\t\t * direction, which means that we need to start the next search\n\t\t * after the term the cursor is currently on when searching\n\t\t * forward.\n\t\t */\n\t\tif (keys == MODEKEY_VI) {\n\t\t\tif (data->searchmark != NULL)\n\t\t\t\twindow_copy_move_after_search_mark(data, &fx,\n\t\t\t\t    &fy, wrapflag);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * When there are no search marks, start the\n\t\t\t\t * search after the current cursor position.\n\t\t\t\t */\n\t\t\t\twindow_copy_move_right(s, &fx, &fy, wrapflag);\n\t\t\t}\n\t\t}\n\t\tendline = gd->hsize + gd->sy - 1;\n\t} else {\n\t\twindow_copy_move_left(s, &fx, &fy, wrapflag);\n\t\tendline = 0;\n\t}\n\n\tfound = window_copy_search_jump(wme, gd, ss.grid, fx, fy, endline, cis,\n\t    wrapflag, direction, regex);\n\tif (found) {\n\t\twindow_copy_search_marks(wme, &ss, regex, visible_only);\n\t\tfx = data->cx;\n\t\tfy = screen_hsize(data->backing) - data->oy + data->cy;\n\n\t\t/*\n\t\t * When searching forward, if the cursor is not at the beginning\n\t\t * of the mark, search again.\n\t\t */\n\t\tif (direction &&\n\t\t    window_copy_search_mark_at(data, fx, fy, &at) == 0 &&\n\t\t    at > 0 &&\n\t\t    data->searchmark != NULL &&\n\t\t    data->searchmark[at] == data->searchmark[at - 1]) {\n\t\t\twindow_copy_move_after_search_mark(data, &fx, &fy,\n\t\t\t    wrapflag);\n\t\t\twindow_copy_search_jump(wme, gd, ss.grid, fx,\n\t\t\t    fy, endline, cis, wrapflag, direction,\n\t\t\t    regex);\n\t\t\tfx = data->cx;\n\t\t\tfy = screen_hsize(data->backing) - data->oy + data->cy;\n\t\t}\n\n\t\tif (direction) {\n\t\t\t/*\n\t\t\t * When in Emacs mode, position the cursor just after\n\t\t\t * the mark.\n\t\t\t */\n\t\t\tif (keys == MODEKEY_EMACS) {\n\t\t\t\twindow_copy_move_after_search_mark(data, &fx,\n\t\t\t\t    &fy, wrapflag);\n\t\t\t\tdata->cx = fx;\n\t\t\t\tdata->cy = fy - screen_hsize(data->backing) +\n\t\t\t\t    data-> oy;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * When searching backward, position the cursor at the\n\t\t\t * beginning of the mark.\n\t\t\t */\n\t\t\tif (window_copy_search_mark_at(data, fx, fy,\n\t\t\t        &start) == 0) {\n\t\t\t\twhile (window_copy_search_mark_at(data, fx, fy,\n\t\t\t\t           &at) == 0 &&\n\t\t\t\t       data->searchmark != NULL &&\n\t\t\t\t       data->searchmark[at] ==\n\t\t\t\t           data->searchmark[start]) {\n\t\t\t\t\tdata->cx = fx;\n\t\t\t\t\tdata->cy = fy -\n\t\t\t\t\t    screen_hsize(data->backing) +\n\t\t\t\t\t    data-> oy;\n\t\t\t\t\tif (at == 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\twindow_copy_move_left(s, &fx, &fy, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twindow_copy_redraw_screen(wme);\n\n\tscreen_free(&ss);\n\treturn (found);\n}\n\nstatic void\nwindow_copy_visible_lines(struct window_copy_mode_data *data, u_int *start,\n    u_int *end)\n{\n\tstruct grid\t\t*gd = data->backing->grid;\n\tconst struct grid_line\t*gl;\n\n\tfor (*start = gd->hsize - data->oy; *start > 0; (*start)--) {\n\t\tgl = grid_peek_line(gd, (*start) - 1);\n\t\tif (~gl->flags & GRID_LINE_WRAPPED)\n\t\t\tbreak;\n\t}\n\t*end = gd->hsize - data->oy + gd->sy;\n}\n\nstatic int\nwindow_copy_search_mark_at(struct window_copy_mode_data *data, u_int px,\n    u_int py, u_int *at)\n{\n\tstruct screen\t*s = data->backing;\n\tstruct grid\t*gd = s->grid;\n\n\tif (py < gd->hsize - data->oy)\n\t\treturn (-1);\n\tif (py > gd->hsize - data->oy + gd->sy - 1)\n\t\treturn (-1);\n\t*at = ((py - (gd->hsize - data->oy)) * gd->sx) + px;\n\treturn (0);\n}\n\nstatic u_int\nwindow_copy_clip_width(u_int width, u_int b, u_int sx, u_int sy)\n{\n\treturn ((b + width > sx * sy) ? (sx * sy) - b : width);\n}\n\nstatic u_int\nwindow_copy_search_mark_match(struct window_copy_mode_data *data, u_int px,\n    u_int py, u_int width, int regex)\n{\n\tstruct grid\t\t*gd = data->backing->grid;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t i, b, w = width, sx = gd->sx, sy = gd->sy;\n\n\tif (window_copy_search_mark_at(data, px, py, &b) == 0) {\n\t\twidth = window_copy_clip_width(width, b, sx, sy);\n\t\tw = width;\n\t\tfor (i = b; i < b + w; i++) {\n\t\t\tif (!regex) {\n\t\t\t\tgrid_get_cell(gd, px + (i - b), py, &gc);\n\t\t\t\tif (gc.flags & GRID_FLAG_TAB)\n\t\t\t\t\tw += gc.data.width - 1;\n\t\t\t\tw = window_copy_clip_width(w, b, sx, sy);\n\t\t\t}\n\t\t\tif (data->searchmark[i] != 0)\n\t\t\t\tcontinue;\n\t\t\tdata->searchmark[i] = data->searchgen;\n\t\t}\n\t\tif (data->searchgen == UCHAR_MAX)\n\t\t\tdata->searchgen = 1;\n\t\telse\n\t\t\tdata->searchgen++;\n\t}\n\n\treturn (w);\n}\n\nstatic int\nwindow_copy_search_marks(struct window_mode_entry *wme, struct screen *ssp,\n    int regex, int visible_only)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing, ss;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct grid\t\t\t*gd = s->grid;\n\tstruct grid_cell\t\t gc;\n\tint\t\t\t\t found, cis, stopped = 0;\n\tint\t\t\t\t cflags = REG_EXTENDED;\n\tu_int\t\t\t\t px, py, nfound = 0, width;\n\tu_int\t\t\t\t ssize = 1, start, end, sx = gd->sx;\n\tu_int\t\t\t\t sy = gd->sy;\n\tchar\t\t\t\t*sbuf;\n\tregex_t\t\t\t\t reg;\n\tuint64_t\t\t\t stop = 0, tstart, t;\n\n\tif (ssp == NULL) {\n\t\twidth = screen_write_strlen(\"%s\", data->searchstr);\n\t\tscreen_init(&ss, width, 1, 0);\n\t\tscreen_write_start(&ctx, &ss);\n\t\tscreen_write_nputs(&ctx, -1, &grid_default_cell, \"%s\",\n\t\t    data->searchstr);\n\t\tscreen_write_stop(&ctx);\n\t\tssp = &ss;\n\t} else\n\t\twidth = screen_size_x(ssp);\n\n\tcis = window_copy_is_lowercase(data->searchstr);\n\n\tif (regex) {\n\t\tsbuf = xmalloc(ssize);\n\t\tsbuf[0] = '\\0';\n\t\tsbuf = window_copy_stringify(ssp->grid, 0, 0, ssp->grid->sx,\n\t\t    sbuf, &ssize);\n\t\tif (cis)\n\t\t\tcflags |= REG_ICASE;\n\t\tif (regcomp(&reg, sbuf, cflags) != 0) {\n\t\t\tfree(sbuf);\n\t\t\treturn (0);\n\t\t}\n\t\tfree(sbuf);\n\t}\n\ttstart = get_timer();\n\n\tif (visible_only)\n\t\twindow_copy_visible_lines(data, &start, &end);\n\telse {\n\t\tstart = 0;\n\t\tend = gd->hsize + sy;\n\t\tstop = get_timer() + WINDOW_COPY_SEARCH_ALL_TIMEOUT;\n\t}\n\nagain:\n\tfree(data->searchmark);\n\tdata->searchmark = xcalloc(sx, sy);\n\tdata->searchgen = 1;\n\n\tfor (py = start; py < end; py++) {\n\t\tpx = 0;\n\t\tfor (;;) {\n\t\t\tif (regex) {\n\t\t\t\tfound = window_copy_search_lr_regex(gd,\n\t\t\t\t    &px, &width, py, px, sx, &reg);\n\t\t\t\tgrid_get_cell(gd, px + width - 1, py, &gc);\n\t\t\t\tif (gc.data.width > 2)\n\t\t\t\t\twidth += gc.data.width - 1;\n\t\t\t\tif (!found)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfound = window_copy_search_lr(gd, ssp->grid,\n\t\t\t\t    &px, py, px, sx, cis);\n\t\t\t\tif (!found)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfound++;\n\t\t\tpx += window_copy_search_mark_match(data, px, py, width,\n\t\t\t    regex);\n\t\t}\n\n\t\tt = get_timer();\n\t\tif (t - tstart > WINDOW_COPY_SEARCH_TIMEOUT) {\n\t\t\tdata->timeout = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (stop != 0 && t > stop) {\n\t\t\tstopped = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (data->timeout) {\n\t\twindow_copy_clear_marks(wme);\n\t\tgoto out;\n\t}\n\n\tif (stopped && stop != 0) {\n\t\t/* Try again but just the visible context. */\n\t\twindow_copy_visible_lines(data, &start, &end);\n\t\tstop = 0;\n\t\tgoto again;\n\t}\n\n\tif (!visible_only) {\n\t\tif (stopped) {\n\t\t\tif (nfound > 1000)\n\t\t\t\tdata->searchcount = 1000;\n\t\t\telse if (nfound > 100)\n\t\t\t\tdata->searchcount = 100;\n\t\t\telse if (nfound > 10)\n\t\t\t\tdata->searchcount = 10;\n\t\t\telse\n\t\t\t\tdata->searchcount = -1;\n\t\t\tdata->searchmore = 1;\n\t\t} else {\n\t\t\tdata->searchcount = nfound;\n\t\t\tdata->searchmore = 0;\n\t\t}\n\t}\n\nout:\n\tif (ssp == &ss)\n\t\tscreen_free(&ss);\n\tif (regex)\n\t\tregfree(&reg);\n\treturn (1);\n}\n\nstatic void\nwindow_copy_clear_marks(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tfree(data->searchmark);\n\tdata->searchmark = NULL;\n}\n\nstatic int\nwindow_copy_search_up(struct window_mode_entry *wme, int regex)\n{\n\treturn (window_copy_search(wme, 0, regex));\n}\n\nstatic int\nwindow_copy_search_down(struct window_mode_entry *wme, int regex)\n{\n\treturn (window_copy_search(wme, 1, regex));\n}\n\nstatic void\nwindow_copy_goto_line(struct window_mode_entry *wme, const char *linestr)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tconst char\t\t\t*errstr;\n\tint\t\t\t\t lineno;\n\n\tlineno = strtonum(linestr, -1, INT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn;\n\tif (lineno < 0 || (u_int)lineno > screen_hsize(data->backing))\n\t\tlineno = screen_hsize(data->backing);\n\n\tdata->oy = lineno;\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\nstatic void\nwindow_copy_match_start_end(struct window_copy_mode_data *data, u_int at,\n    u_int *start, u_int *end)\n{\n\tstruct grid\t*gd = data->backing->grid;\n\tu_int\t\t last = (gd->sy * gd->sx) - 1;\n\tu_char\t\t mark = data->searchmark[at];\n\n\t*start = *end = at;\n\twhile (*start != 0 && data->searchmark[*start] == mark)\n\t\t(*start)--;\n\tif (data->searchmark[*start] != mark)\n\t\t(*start)++;\n\twhile (*end != last && data->searchmark[*end] == mark)\n\t\t(*end)++;\n\tif (data->searchmark[*end] != mark)\n\t\t(*end)--;\n}\n\nstatic char *\nwindow_copy_match_at_cursor(struct window_copy_mode_data *data)\n{\n\tstruct grid\t*gd = data->backing->grid;\n\tstruct grid_cell gc;\n\tu_int\t\t at, start, end, cy, px, py;\n\tu_int\t\t sx = screen_size_x(data->backing);\n\tchar\t\t*buf = NULL;\n\tsize_t\t\t len = 0;\n\n\tif (data->searchmark == NULL)\n\t\treturn (NULL);\n\n\tcy = screen_hsize(data->backing) - data->oy + data->cy;\n\tif (window_copy_search_mark_at(data, data->cx, cy, &at) != 0)\n\t\treturn (NULL);\n\tif (data->searchmark[at] == 0) {\n\t\t/* Allow one position after the match. */\n\t\tif (at == 0 || data->searchmark[--at] == 0)\n\t\t\treturn (NULL);\n\t}\n\twindow_copy_match_start_end(data, at, &start, &end);\n\n\t/*\n\t * Cells will not be set in the marked array unless they are valid text\n\t * and wrapping will be taken care of, so we can just copy.\n \t */\n\tfor (at = start; at <= end; at++) {\n\t\tpy = at / sx;\n\t\tpx = at - (py * sx);\n\n\t\tgrid_get_cell(gd, px, gd->hsize + py - data->oy, &gc);\n\t\tif (gc.flags & GRID_FLAG_TAB) {\n\t\t\tbuf = xrealloc(buf, len + 2);\n\t\t\tbuf[len] = '\\t';\n\t\t\tlen++;\n\t\t} else {\n\t\t\tbuf = xrealloc(buf, len + gc.data.size + 1);\n\t\t\tmemcpy(buf + len, gc.data.data, gc.data.size);\n\t\t\tlen += gc.data.size;\n\t\t}\n\t}\n\tif (len != 0)\n\t\tbuf[len] = '\\0';\n\treturn (buf);\n}\n\nstatic void\nwindow_copy_update_style(struct window_mode_entry *wme, u_int fx, u_int fy,\n    struct grid_cell *gc, const struct grid_cell *mgc,\n    const struct grid_cell *cgc, const struct grid_cell *mkgc)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t mark, start, end, cy, cursor, current;\n\tint\t\t\t\t inv = 0, found = 0;\n\tint\t\t\t\t keys;\n\n\tif (data->showmark && fy == data->my) {\n\t\tgc->attr = mkgc->attr;\n\t\tif (fx == data->mx)\n\t\t\tinv = 1;\n\t\tif (inv) {\n\t\t\tgc->fg = mkgc->bg;\n\t\t\tgc->bg = mkgc->fg;\n\t\t}\n\t\telse {\n\t\t\tgc->fg = mkgc->fg;\n\t\t\tgc->bg = mkgc->bg;\n\t\t}\n\t}\n\n\tif (data->searchmark == NULL)\n\t\treturn;\n\n\tif (window_copy_search_mark_at(data, fx, fy, &current) != 0)\n\t\treturn;\n\tmark = data->searchmark[current];\n\tif (mark == 0)\n\t\treturn;\n\n\tcy = screen_hsize(data->backing) - data->oy + data->cy;\n\tif (window_copy_search_mark_at(data, data->cx, cy, &cursor) == 0) {\n\t\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\t\tif (cursor != 0 &&\n\t\t    keys == MODEKEY_EMACS &&\n\t\t    data->searchdirection) {\n\t\t\tif (data->searchmark[cursor - 1] == mark) {\n\t\t\t\tcursor--;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t} else if (data->searchmark[cursor] == mark)\n\t\t\tfound = 1;\n\t\tif (found) {\n\t\t\twindow_copy_match_start_end(data, cursor, &start, &end);\n\t\t\tif (current >= start && current <= end) {\n\t\t\t\tgc->attr = cgc->attr;\n\t\t\t\tif (inv) {\n\t\t\t\t\tgc->fg = cgc->bg;\n\t\t\t\t\tgc->bg = cgc->fg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgc->fg = cgc->fg;\n\t\t\t\t\tgc->bg = cgc->bg;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tgc->attr = mgc->attr;\n\tif (inv) {\n\t\tgc->fg = mgc->bg;\n\t\tgc->bg = mgc->fg;\n\t}\n\telse {\n\t\tgc->fg = mgc->fg;\n\t\tgc->bg = mgc->bg;\n\t}\n}\n\nstatic void\nwindow_copy_write_one(struct window_mode_entry *wme,\n    struct screen_write_ctx *ctx, u_int py, u_int fy, u_int nx,\n    const struct grid_cell *mgc, const struct grid_cell *cgc,\n    const struct grid_cell *mkgc)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t \t\t fx;\n\n\tscreen_write_cursormove(ctx, 0, py, 0);\n\tfor (fx = 0; fx < nx; fx++) {\n\t\tgrid_get_cell(gd, fx, fy, &gc);\n\t\tif (fx + gc.data.width <= nx) {\n\t\t\twindow_copy_update_style(wme, fx, fy, &gc, mgc, cgc,\n\t\t\t    mkgc);\n\t\t\tscreen_write_cell(ctx, &gc);\n\t\t}\n\t}\n}\n\nint\nwindow_copy_get_current_offset(struct window_pane *wp, u_int *offset,\n    u_int *size)\n{\n\tstruct window_mode_entry\t*wme = TAILQ_FIRST(&wp->modes);\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t hsize;\n\n\tif (data == NULL)\n\t\treturn (0);\n\thsize = screen_hsize(data->backing);\n\n\t*offset = hsize - data->oy;\n\t*size = hsize;\n\treturn (1);\n}\n\nstatic void\nwindow_copy_write_line(struct window_mode_entry *wme,\n    struct screen_write_ctx *ctx, u_int py)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct grid_cell\t\t gc, mgc, cgc, mkgc;\n\tu_int\t\t\t\t sx = screen_size_x(s);\n\tu_int\t\t\t\t hsize = screen_hsize(data->backing);\n\tconst char\t\t\t*value;\n\tchar\t\t\t\t*expanded;\n\tstruct format_tree\t\t*ft;\n\n\tft = format_create_defaults(NULL, NULL, NULL, NULL, wp);\n\n\tstyle_apply(&gc, oo, \"copy-mode-position-style\", ft);\n\tgc.flags |= GRID_FLAG_NOPALETTE;\n\tstyle_apply(&mgc, oo, \"copy-mode-match-style\", ft);\n\tmgc.flags |= GRID_FLAG_NOPALETTE;\n\tstyle_apply(&cgc, oo, \"copy-mode-current-match-style\", ft);\n\tcgc.flags |= GRID_FLAG_NOPALETTE;\n\tstyle_apply(&mkgc, oo, \"copy-mode-mark-style\", ft);\n\tmkgc.flags |= GRID_FLAG_NOPALETTE;\n\n\twindow_copy_write_one(wme, ctx, py, hsize - data->oy + py,\n\t    screen_size_x(s), &mgc, &cgc, &mkgc);\n\n\tif (py == 0 && s->rupper < s->rlower && !data->hide_position) {\n\t\tvalue = options_get_string(oo, \"copy-mode-position-format\");\n\t\tif (*value != '\\0') {\n\t\t\texpanded = format_expand(ft, value);\n\t\t\tif (*expanded != '\\0') {\n\t\t\t\tscreen_write_cursormove(ctx, 0, 0, 0);\n\t\t\t\tformat_draw(ctx, &gc, sx, expanded, NULL, 0);\n\t\t\t}\n\t\t\tfree(expanded);\n\t\t}\n\t}\n\n\tif (py == data->cy && data->cx == screen_size_x(s)) {\n\t\tscreen_write_cursormove(ctx, screen_size_x(s) - 1, py, 0);\n\t\tscreen_write_putc(ctx, &grid_default_cell, '$');\n\t}\n\n\tformat_free(ft);\n}\n\nstatic void\nwindow_copy_write_lines(struct window_mode_entry *wme,\n    struct screen_write_ctx *ctx, u_int py, u_int ny)\n{\n\tu_int\tyy;\n\n\tfor (yy = py; yy < py + ny; yy++)\n\t\twindow_copy_write_line(wme, ctx, py);\n}\n\nstatic void\nwindow_copy_redraw_selection(struct window_mode_entry *wme, u_int old_y)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tu_int\t\t\t\t new_y, start, end;\n\n\tnew_y = data->cy;\n\tif (old_y <= new_y) {\n\t\tstart = old_y;\n\t\tend = new_y;\n\t} else {\n\t\tstart = new_y;\n\t\tend = old_y;\n\t}\n\n\t/*\n\t * In word selection mode the first word on the line below the cursor\n\t * might be selected, so add this line to the redraw area.\n\t */\n\tif (data->selflag == SEL_WORD) {\n\t\t/* Last grid line in data coordinates. */\n\t\tif (end < gd->sy + data->oy - 1)\n\t\t\tend++;\n\t}\n\twindow_copy_redraw_lines(wme, start, end - start + 1);\n}\n\nstatic void\nwindow_copy_redraw_lines(struct window_mode_entry *wme, u_int py, u_int ny)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen_write_ctx\t \t ctx;\n\tu_int\t\t\t\t i;\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tfor (i = py; i < py + ny; i++)\n\t\twindow_copy_write_line(wme, &ctx, i);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy, 0);\n\tscreen_write_stop(&ctx);\n\n\twp->flags |= PANE_REDRAWSCROLLBAR;\n}\n\nstatic void\nwindow_copy_redraw_screen(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\twindow_copy_redraw_lines(wme, 0, screen_size_y(&data->screen));\n}\n\nstatic void\nwindow_copy_synchronize_cursor_end(struct window_mode_entry *wme, int begin,\n    int no_reset)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t xx, yy;\n\n\txx = data->cx;\n\tyy = screen_hsize(data->backing) + data->cy - data->oy;\n\tswitch (data->selflag) {\n\tcase SEL_WORD:\n\t\tif (no_reset)\n\t\t\tbreak;\n\t\tbegin = 0;\n\t\tif (data->dy > yy || (data->dy == yy && data->dx > xx)) {\n\t\t\t/* Right to left selection. */\n\t\t\twindow_copy_cursor_previous_word_pos(wme,\n\t\t\t    data->separators, &xx, &yy);\n\t\t\tbegin = 1;\n\n\t\t\t/* Reset the end. */\n\t\t\tdata->endselx = data->endselrx;\n\t\t\tdata->endsely = data->endselry;\n\t\t} else {\n\t\t\t/* Left to right selection. */\n\t\t\tif (xx >= window_copy_find_length(wme, yy) ||\n\t\t\t    !window_copy_in_set(wme, xx + 1, yy, WHITESPACE)) {\n\t\t\t\twindow_copy_cursor_next_word_end_pos(wme,\n\t\t\t\t    data->separators, &xx, &yy);\n\t\t\t}\n\n\t\t\t/* Reset the start. */\n\t\t\tdata->selx = data->selrx;\n\t\t\tdata->sely = data->selry;\n\t\t}\n\t\tbreak;\n\tcase SEL_LINE:\n\t\tif (no_reset)\n\t\t\tbreak;\n\t\tbegin = 0;\n\t\tif (data->dy > yy) {\n\t\t\t/* Right to left selection. */\n\t\t\txx = 0;\n\t\t\tbegin = 1;\n\n\t\t\t/* Reset the end. */\n\t\t\tdata->endselx = data->endselrx;\n\t\t\tdata->endsely = data->endselry;\n\t\t} else {\n\t\t\t/* Left to right selection. */\n\t\t\tif (yy < data->endselry)\n\t\t\t\tyy = data->endselry;\n\t\t\txx = window_copy_find_length(wme, yy);\n\n\t\t\t/* Reset the start. */\n\t\t\tdata->selx = data->selrx;\n\t\t\tdata->sely = data->selry;\n\t\t}\n\t\tbreak;\n\tcase SEL_CHAR:\n\t\tbreak;\n\t}\n\tif (begin) {\n\t\tdata->selx = xx;\n\t\tdata->sely = yy;\n\t} else {\n\t\tdata->endselx = xx;\n\t\tdata->endsely = yy;\n\t}\n}\n\nstatic void\nwindow_copy_synchronize_cursor(struct window_mode_entry *wme, int no_reset)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tswitch (data->cursordrag) {\n\tcase CURSORDRAG_ENDSEL:\n\t\twindow_copy_synchronize_cursor_end(wme, 0, no_reset);\n\t\tbreak;\n\tcase CURSORDRAG_SEL:\n\t\twindow_copy_synchronize_cursor_end(wme, 1, no_reset);\n\t\tbreak;\n\tcase CURSORDRAG_NONE:\n\t\tbreak;\n\t}\n}\n\nstatic void\nwindow_copy_update_cursor(struct window_mode_entry *wme, u_int cx, u_int cy)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\tu_int\t\t\t\t old_cx, old_cy;\n\n\told_cx = data->cx; old_cy = data->cy;\n\tdata->cx = cx; data->cy = cy;\n\tif (old_cx == screen_size_x(s))\n\t\twindow_copy_redraw_lines(wme, old_cy, 1);\n\tif (data->cx == screen_size_x(s))\n\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\telse {\n\t\tscreen_write_start_pane(&ctx, wp, NULL);\n\t\tscreen_write_cursormove(&ctx, data->cx, data->cy, 0);\n\t\tscreen_write_stop(&ctx);\n\t}\n}\n\nstatic void\nwindow_copy_start_selection(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\tdata->selx = data->cx;\n\tdata->sely = screen_hsize(data->backing) + data->cy - data->oy;\n\n\tdata->endselx = data->selx;\n\tdata->endsely = data->sely;\n\n\tdata->cursordrag = CURSORDRAG_ENDSEL;\n\n\twindow_copy_set_selection(wme, 1, 0);\n}\n\nstatic int\nwindow_copy_adjust_selection(struct window_mode_entry *wme, u_int *selx,\n    u_int *sely)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int \t\t\t\t sx, sy, ty;\n\tint\t\t\t\t relpos;\n\n\tsx = *selx;\n\tsy = *sely;\n\n\tty = screen_hsize(data->backing) - data->oy;\n\tif (sy < ty) {\n\t\trelpos = WINDOW_COPY_REL_POS_ABOVE;\n\t\tif (!data->rectflag)\n\t\t\tsx = 0;\n\t\tsy = 0;\n\t} else if (sy > ty + screen_size_y(s) - 1) {\n\t\trelpos = WINDOW_COPY_REL_POS_BELOW;\n\t\tif (!data->rectflag)\n\t\t\tsx = screen_size_x(s) - 1;\n\t\tsy = screen_size_y(s) - 1;\n\t} else {\n\t\trelpos = WINDOW_COPY_REL_POS_ON_SCREEN;\n\t\tsy -= ty;\n\t}\n\n\t*selx = sx;\n\t*sely = sy;\n\treturn (relpos);\n}\n\nstatic int\nwindow_copy_update_selection(struct window_mode_entry *wme, int may_redraw,\n    int no_reset)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tif (s->sel == NULL && data->lineflag == LINE_SEL_NONE)\n\t\treturn (0);\n\treturn (window_copy_set_selection(wme, may_redraw, no_reset));\n}\n\nstatic int\nwindow_copy_set_selection(struct window_mode_entry *wme, int may_redraw,\n    int no_reset)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t sx, sy, cy, endsx, endsy;\n\tint\t\t\t\t startrelpos, endrelpos;\n\tstruct format_tree\t\t*ft;\n\n\twindow_copy_synchronize_cursor(wme, no_reset);\n\n\t/* Adjust the selection. */\n\tsx = data->selx;\n\tsy = data->sely;\n\tstartrelpos = window_copy_adjust_selection(wme, &sx, &sy);\n\n\t/* Adjust the end of selection. */\n\tendsx = data->endselx;\n\tendsy = data->endsely;\n\tendrelpos = window_copy_adjust_selection(wme, &endsx, &endsy);\n\n\t/* Selection is outside of the current screen */\n\tif (startrelpos == endrelpos &&\n\t    startrelpos != WINDOW_COPY_REL_POS_ON_SCREEN) {\n\t\tscreen_hide_selection(s);\n\t\treturn (0);\n\t}\n\n\t/* Set colours and selection. */\n\tft = format_create_defaults(NULL, NULL, NULL, NULL, wp);\n\tstyle_apply(&gc, oo, \"copy-mode-selection-style\", ft);\n\tgc.flags |= GRID_FLAG_NOPALETTE;\n\tformat_free(ft);\n\tscreen_set_selection(s, sx, sy, endsx, endsy, data->rectflag,\n\t    data->modekeys, &gc);\n\n\tif (data->rectflag && may_redraw) {\n\t\t/*\n\t\t * Can't rely on the caller to redraw the right lines for\n\t\t * rectangle selection - find the highest line and the number\n\t\t * of lines, and redraw just past that in both directions\n\t\t */\n\t\tcy = data->cy;\n\t\tif (data->cursordrag == CURSORDRAG_ENDSEL) {\n\t\t\tif (sy < cy)\n\t\t\t\twindow_copy_redraw_lines(wme, sy, cy - sy + 1);\n\t\t\telse\n\t\t\t\twindow_copy_redraw_lines(wme, cy, sy - cy + 1);\n\t\t} else {\n\t\t\tif (endsy < cy) {\n\t\t\t\twindow_copy_redraw_lines(wme, endsy,\n\t\t\t\t    cy - endsy + 1);\n\t\t\t} else {\n\t\t\t\twindow_copy_redraw_lines(wme, cy,\n\t\t\t\t    endsy - cy + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (1);\n}\n\nstatic void *\nwindow_copy_get_selection(struct window_mode_entry *wme, size_t *len)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tchar\t\t\t\t*buf;\n\tsize_t\t\t\t\t off;\n\tu_int\t\t\t\t i, xx, yy, sx, sy, ex, ey, ey_last;\n\tu_int\t\t\t\t firstsx, lastex, restex, restsx, selx;\n\tint\t\t\t\t keys;\n\n\tif (data->screen.sel == NULL && data->lineflag == LINE_SEL_NONE) {\n\t\tbuf = window_copy_match_at_cursor(data);\n\t\tif (buf != NULL)\n\t\t\t*len = strlen(buf);\n\t\telse\n\t\t\t*len = 0;\n\t\treturn (buf);\n\t}\n\n\tbuf = xmalloc(1);\n\toff = 0;\n\n\t*buf = '\\0';\n\n\t/*\n\t * The selection extends from selx,sely to (adjusted) cx,cy on\n\t * the base screen.\n\t */\n\n\t/* Find start and end. */\n\txx = data->endselx;\n\tyy = data->endsely;\n\tif (yy < data->sely || (yy == data->sely && xx < data->selx)) {\n\t\tsx = xx; sy = yy;\n\t\tex = data->selx; ey = data->sely;\n\t} else {\n\t\tsx = data->selx; sy = data->sely;\n\t\tex = xx; ey = yy;\n\t}\n\n\t/* Trim ex to end of line. */\n\tey_last = window_copy_find_length(wme, ey);\n\tif (ex > ey_last)\n\t\tex = ey_last;\n\n\t/*\n\t * Deal with rectangle-copy if necessary; four situations: start of\n\t * first line (firstsx), end of last line (lastex), start (restsx) and\n\t * end (restex) of all other lines.\n\t */\n\txx = screen_size_x(s);\n\n\t/*\n\t * Behave according to mode-keys. If it is emacs, copy like emacs,\n\t * keeping the top-left-most character, and dropping the\n\t * bottom-right-most, regardless of copy direction. If it is vi, also\n\t * keep bottom-right-most character.\n\t */\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (data->rectflag) {\n\t\t/*\n\t\t * Need to ignore the column with the cursor in it, which for\n\t\t * rectangular copy means knowing which side the cursor is on.\n\t\t */\n\t\tif (data->cursordrag == CURSORDRAG_ENDSEL)\n\t\t\tselx = data->selx;\n\t\telse\n\t\t\tselx = data->endselx;\n\t\tif (selx < data->cx) {\n\t\t\t/* Selection start is on the left. */\n\t\t\tif (keys == MODEKEY_EMACS) {\n\t\t\t\tlastex = data->cx;\n\t\t\t\trestex = data->cx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlastex = data->cx + 1;\n\t\t\t\trestex = data->cx + 1;\n\t\t\t}\n\t\t\tfirstsx = selx;\n\t\t\trestsx = selx;\n\t\t} else {\n\t\t\t/* Cursor is on the left. */\n\t\t\tlastex = selx + 1;\n\t\t\trestex = selx + 1;\n\t\t\tfirstsx = data->cx;\n\t\t\trestsx = data->cx;\n\t\t}\n\t} else {\n\t\tif (keys == MODEKEY_EMACS)\n\t\t\tlastex = ex;\n\t\telse\n\t\t\tlastex = ex + 1;\n\t\trestex = xx;\n\t\tfirstsx = sx;\n\t\trestsx = 0;\n\t}\n\n\t/* Copy the lines. */\n\tfor (i = sy; i <= ey; i++) {\n\t\twindow_copy_copy_line(wme, &buf, &off, i,\n\t\t    (i == sy ? firstsx : restsx),\n\t\t    (i == ey ? lastex : restex));\n\t}\n\n\t/* Don't bother if no data. */\n\tif (off == 0) {\n\t\tfree(buf);\n\t\t*len = 0;\n\t\treturn (NULL);\n\t}\n\t /* Remove final \\n (unless at end in vi mode). */\n\tif (keys == MODEKEY_EMACS || lastex <= ey_last) {\n\t\tif (~grid_get_line(data->backing->grid, ey)->flags &\n\t\t    GRID_LINE_WRAPPED || lastex != ey_last)\n\t\t\toff -= 1;\n\t}\n\t*len = off;\n\treturn (buf);\n}\n\nstatic void\nwindow_copy_copy_buffer(struct window_mode_entry *wme, const char *prefix,\n    void *buf, size_t len, int set_paste, int set_clip)\n{\n\tstruct window_pane\t*wp = wme->wp;\n\tstruct screen_write_ctx\t ctx;\n\n\tif (set_clip &&\n\t    options_get_number(global_options, \"set-clipboard\") != 0) {\n\t\tscreen_write_start_pane(&ctx, wp, NULL);\n\t\tscreen_write_setselection(&ctx, \"\", buf, len);\n\t\tscreen_write_stop(&ctx);\n\t\tnotify_pane(\"pane-set-clipboard\", wp);\n\t}\n\n\tif (set_paste)\n\t\tpaste_add(prefix, buf, len);\n}\n\nstatic void *\nwindow_copy_pipe_run(struct window_mode_entry *wme, struct session *s,\n    const char *cmd, size_t *len)\n{\n\tvoid\t\t*buf;\n\tstruct job\t*job;\n\n\tbuf = window_copy_get_selection(wme, len);\n\tif (cmd == NULL || *cmd == '\\0')\n\t\tcmd = options_get_string(global_options, \"copy-command\");\n\tif (cmd != NULL && *cmd != '\\0') {\n\t\tjob = job_run(cmd, 0, NULL, NULL, s, NULL, NULL, NULL, NULL,\n\t\t    NULL, JOB_NOWAIT, -1, -1);\n\t\tbufferevent_write(job_get_event(job), buf, *len);\n\t}\n\treturn (buf);\n}\n\nstatic void\nwindow_copy_pipe(struct window_mode_entry *wme, struct session *s,\n    const char *cmd)\n{\n\tsize_t\tlen;\n\n\twindow_copy_pipe_run(wme, s, cmd, &len);\n}\n\nstatic void\nwindow_copy_copy_pipe(struct window_mode_entry *wme, struct session *s,\n    const char *prefix, const char *cmd, int set_paste, int set_clip)\n{\n\tvoid\t*buf;\n\tsize_t\t len;\n\n\tbuf = window_copy_pipe_run(wme, s, cmd, &len);\n\tif (buf != NULL)\n\t\twindow_copy_copy_buffer(wme, prefix, buf, len, set_paste,\n\t\t    set_clip);\n}\n\nstatic void\nwindow_copy_copy_selection(struct window_mode_entry *wme, const char *prefix,\n    int set_paste, int set_clip)\n{\n\tchar\t*buf;\n\tsize_t\t len;\n\n\tbuf = window_copy_get_selection(wme, &len);\n\tif (buf != NULL)\n\t\twindow_copy_copy_buffer(wme, prefix, buf, len, set_paste,\n\t\t    set_clip);\n}\n\nstatic void\nwindow_copy_append_selection(struct window_mode_entry *wme)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tchar\t\t\t\t*buf;\n\tstruct paste_buffer\t\t*pb;\n\tconst char\t\t\t*bufdata, *bufname = NULL;\n\tsize_t\t\t\t\t len, bufsize;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tbuf = window_copy_get_selection(wme, &len);\n\tif (buf == NULL)\n\t\treturn;\n\n\tif (options_get_number(global_options, \"set-clipboard\") != 0) {\n\t\tscreen_write_start_pane(&ctx, wp, NULL);\n\t\tscreen_write_setselection(&ctx, \"\", buf, len);\n\t\tscreen_write_stop(&ctx);\n\t\tnotify_pane(\"pane-set-clipboard\", wp);\n\t}\n\n\tpb = paste_get_top(&bufname);\n\tif (pb != NULL) {\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tbuf = xrealloc(buf, len + bufsize);\n\t\tmemmove(buf + bufsize, buf, len);\n\t\tmemcpy(buf, bufdata, bufsize);\n\t\tlen += bufsize;\n\t}\n\tif (paste_set(buf, len, bufname, NULL) != 0)\n\t\tfree(buf);\n}\n\nstatic void\nwindow_copy_copy_line(struct window_mode_entry *wme, char **buf, size_t *off,\n    u_int sy, u_int sx, u_int ex)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tstruct grid_cell\t\t gc;\n\tstruct grid_line\t\t*gl;\n\tstruct utf8_data\t\t ud;\n\tu_int\t\t\t\t i, xx, wrapped = 0;\n\tconst char\t\t\t*s;\n\n\tif (sx > ex)\n\t\treturn;\n\n\t/*\n\t * Work out if the line was wrapped at the screen edge and all of it is\n\t * on screen.\n\t */\n\tgl = grid_get_line(gd, sy);\n\tif (gl->flags & GRID_LINE_WRAPPED && gl->cellsize <= gd->sx)\n\t\twrapped = 1;\n\n\t/* If the line was wrapped, don't strip spaces (use the full length). */\n\tif (wrapped)\n\t\txx = gl->cellsize;\n\telse\n\t\txx = window_copy_find_length(wme, sy);\n\tif (ex > xx)\n\t\tex = xx;\n\tif (sx > xx)\n\t\tsx = xx;\n\n\tif (sx < ex) {\n\t\tfor (i = sx; i < ex; i++) {\n\t\t\tgrid_get_cell(gd, i, sy, &gc);\n\t\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tcontinue;\n\t\t\tif (gc.flags & GRID_FLAG_TAB)\n\t\t\t\tutf8_set(&ud, '\\t');\n\t\t\telse\n\t\t\t\tutf8_copy(&ud, &gc.data);\n\t\t\tif (ud.size == 1 && (gc.attr & GRID_ATTR_CHARSET)) {\n\t\t\t\ts = tty_acs_get(NULL, ud.data[0]);\n\t\t\t\tif (s != NULL && strlen(s) <= sizeof ud.data) {\n\t\t\t\t\tud.size = strlen(s);\n\t\t\t\t\tmemcpy(ud.data, s, ud.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*buf = xrealloc(*buf, (*off) + ud.size);\n\t\t\tmemcpy(*buf + *off, ud.data, ud.size);\n\t\t\t*off += ud.size;\n\t\t}\n\t}\n\n\t/* Only add a newline if the line wasn't wrapped. */\n\tif (!wrapped || ex != xx) {\n\t\t*buf = xrealloc(*buf, (*off) + 1);\n\t\t(*buf)[(*off)++] = '\\n';\n\t}\n}\n\nstatic void\nwindow_copy_clear_selection(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data   *data = wme->data;\n\tu_int\t\t\t\tpx, py;\n\n\tscreen_clear_selection(&data->screen);\n\n\tdata->cursordrag = CURSORDRAG_NONE;\n\tdata->lineflag = LINE_SEL_NONE;\n\tdata->selflag = SEL_CHAR;\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tpx = window_copy_find_length(wme, py);\n\tif (data->cx > px)\n\t\twindow_copy_update_cursor(wme, px, data->cy);\n}\n\nstatic int\nwindow_copy_in_set(struct window_mode_entry *wme, u_int px, u_int py,\n    const char *set)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\treturn (grid_in_set(data->backing->grid, px, py, set));\n}\n\nstatic u_int\nwindow_copy_find_length(struct window_mode_entry *wme, u_int py)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\n\treturn (grid_line_length(data->backing->grid, py));\n}\n\nstatic void\nwindow_copy_cursor_start_of_line(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_start_of_line(&gr, 1);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px, py);\n}\n\nstatic void\nwindow_copy_cursor_back_to_indentation(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_back_to_indentation(&gr);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px, py);\n}\n\nstatic void\nwindow_copy_cursor_end_of_line(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy =  hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tif (data->screen.sel != NULL && data->rectflag)\n\t\tgrid_reader_cursor_end_of_line(&gr, 1, 1);\n\telse\n\t\tgrid_reader_cursor_end_of_line(&gr, 1, 0);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_down(wme, hsize, screen_size_y(back_s),\n\t    data->oy, oldy, px, py, 0);\n}\n\nstatic void\nwindow_copy_other_end(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t selx, sely, cy, yy, hsize;\n\n\tif (s->sel == NULL && data->lineflag == LINE_SEL_NONE)\n\t\treturn;\n\n\tif (data->lineflag == LINE_SEL_LEFT_RIGHT)\n\t\tdata->lineflag = LINE_SEL_RIGHT_LEFT;\n\telse if (data->lineflag == LINE_SEL_RIGHT_LEFT)\n\t\tdata->lineflag = LINE_SEL_LEFT_RIGHT;\n\n\tswitch (data->cursordrag) {\n\t\tcase CURSORDRAG_NONE:\n\t\tcase CURSORDRAG_SEL:\n\t\t\tdata->cursordrag = CURSORDRAG_ENDSEL;\n\t\t\tbreak;\n\t\tcase CURSORDRAG_ENDSEL:\n\t\t\tdata->cursordrag = CURSORDRAG_SEL;\n\t\t\tbreak;\n\t}\n\n\tselx = data->endselx;\n\tsely = data->endsely;\n\tif (data->cursordrag == CURSORDRAG_SEL) {\n\t\tselx = data->selx;\n\t\tsely = data->sely;\n\t}\n\n\tcy = data->cy;\n\tyy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\tdata->cx = selx;\n\n\thsize = screen_hsize(data->backing);\n\tif (sely < hsize - data->oy) { /* above */\n\t\tdata->oy = hsize - sely;\n\t\tdata->cy = 0;\n\t} else if (sely > hsize - data->oy + screen_size_y(s)) { /* below */\n\t\tdata->oy = hsize - sely + screen_size_y(s) - 1;\n\t\tdata->cy = screen_size_y(s) - 1;\n\t} else\n\t\tdata->cy = cy + sely - yy;\n\n\twindow_copy_update_selection(wme, 1, 1);\n\twindow_copy_redraw_screen(wme);\n}\n\nstatic void\nwindow_copy_cursor_left(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_left(&gr, 1);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px, py);\n}\n\nstatic void\nwindow_copy_cursor_right(struct window_mode_entry *wme, int all)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_right(&gr, 1, all);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_down(wme, hsize, screen_size_y(back_s),\n\t    data->oy, oldy, px, py, 0);\n}\n\nstatic void\nwindow_copy_cursor_up(struct window_mode_entry *wme, int scroll_only)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t ox, oy, px, py;\n\tint\t\t\t\t norectsel;\n\n\tnorectsel = data->screen.sel == NULL || !data->rectflag;\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wme, oy);\n\tif (norectsel && data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\n\tif (data->lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)\n\t\twindow_copy_other_end(wme);\n\n\tif (scroll_only || data->cy == 0) {\n\t\tif (norectsel)\n\t\t\tdata->cx = data->lastcx;\n\t\twindow_copy_scroll_down(wme, 1);\n\t\tif (scroll_only) {\n\t\t\tif (data->cy == screen_size_y(s) - 1)\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t\t\telse\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 2);\n\t\t}\n\t} else {\n\t\tif (norectsel) {\n\t\t\twindow_copy_update_cursor(wme, data->lastcx,\n\t\t\t    data->cy - 1);\n\t\t} else\n\t\t\twindow_copy_update_cursor(wme, data->cx, data->cy - 1);\n\t\tif (window_copy_update_selection(wme, 1, 0)) {\n\t\t\tif (data->cy == screen_size_y(s) - 1)\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t\t\telse\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 2);\n\t\t}\n\t}\n\n\tif (norectsel) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wme, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t{\n\t\t\twindow_copy_update_cursor(wme, px, data->cy);\n\t\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t\t}\n\t}\n\n\tif (data->lineflag == LINE_SEL_LEFT_RIGHT)\n\t{\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tif (data->rectflag)\n\t\t\tpx = screen_size_x(data->backing);\n\t\telse\n\t\t\tpx = window_copy_find_length(wme, py);\n\t\twindow_copy_update_cursor(wme, px, data->cy);\n\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t}\n\telse if (data->lineflag == LINE_SEL_RIGHT_LEFT)\n\t{\n\t\twindow_copy_update_cursor(wme, 0, data->cy);\n\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_down(struct window_mode_entry *wme, int scroll_only)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t ox, oy, px, py;\n\tint\t\t\t\t norectsel;\n\n\tnorectsel = data->screen.sel == NULL || !data->rectflag;\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wme, oy);\n\tif (norectsel && data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\n\tif (data->lineflag == LINE_SEL_RIGHT_LEFT && oy == data->endsely)\n\t\twindow_copy_other_end(wme);\n\n\tif (scroll_only || data->cy == screen_size_y(s) - 1) {\n\t\tif (norectsel)\n\t\t\tdata->cx = data->lastcx;\n\t\twindow_copy_scroll_up(wme, 1);\n\t\tif (scroll_only && data->cy > 0)\n\t\t\twindow_copy_redraw_lines(wme, data->cy - 1, 2);\n\t} else {\n\t\tif (norectsel) {\n\t\t\twindow_copy_update_cursor(wme, data->lastcx,\n\t\t\t    data->cy + 1);\n\t\t} else\n\t\t\twindow_copy_update_cursor(wme, data->cx, data->cy + 1);\n\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\twindow_copy_redraw_lines(wme, data->cy - 1, 2);\n\t}\n\n\tif (norectsel) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wme, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t{\n\t\t\twindow_copy_update_cursor(wme, px, data->cy);\n\t\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t\t}\n\t}\n\n\tif (data->lineflag == LINE_SEL_LEFT_RIGHT)\n\t{\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tif (data->rectflag)\n\t\t\tpx = screen_size_x(data->backing);\n\t\telse\n\t\t\tpx = window_copy_find_length(wme, py);\n\t\twindow_copy_update_cursor(wme, px, data->cy);\n\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t}\n\telse if (data->lineflag == LINE_SEL_RIGHT_LEFT)\n\t{\n\t\twindow_copy_update_cursor(wme, 0, data->cy);\n\t\tif (window_copy_update_selection(wme, 1, 0))\n\t\t\twindow_copy_redraw_lines(wme, data->cy, 1);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_jump(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx + 1;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tif (grid_reader_cursor_jump(&gr, data->jumpchar)) {\n\t\tgrid_reader_get_cursor(&gr, &px, &py);\n\t\twindow_copy_acquire_cursor_down(wme, hsize,\n\t\t    screen_size_y(back_s), data->oy, oldy, px, py, 0);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_jump_back(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_left(&gr, 0);\n\tif (grid_reader_cursor_jump_back(&gr, data->jumpchar)) {\n\t\tgrid_reader_get_cursor(&gr, &px, &py);\n\t\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px,\n\t\t    py);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_jump_to(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx + 2;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tif (grid_reader_cursor_jump(&gr, data->jumpchar)) {\n\t\tgrid_reader_cursor_left(&gr, 1);\n\t\tgrid_reader_get_cursor(&gr, &px, &py);\n\t\twindow_copy_acquire_cursor_down(wme, hsize,\n\t\t    screen_size_y(back_s), data->oy, oldy, px, py, 0);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_jump_to_back(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_left(&gr, 0);\n\tgrid_reader_cursor_left(&gr, 0);\n\tif (grid_reader_cursor_jump_back(&gr, data->jumpchar)) {\n\t\tgrid_reader_cursor_right(&gr, 1, 0);\n\t\tgrid_reader_get_cursor(&gr, &px, &py);\n\t\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px,\n\t\t    py);\n\t}\n}\n\nstatic void\nwindow_copy_cursor_next_word(struct window_mode_entry *wme,\n    const char *separators)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy =  hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_next_word(&gr, separators);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_down(wme, hsize, screen_size_y(back_s),\n\t    data->oy, oldy, px, py, 0);\n}\n\n/* Compute the next place where a word ends. */\nstatic void\nwindow_copy_cursor_next_word_end_pos(struct window_mode_entry *wme,\n    const char *separators, u_int *ppx, u_int *ppy)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy =  hsize + data->cy - data->oy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tif (options_get_number(oo, \"mode-keys\") == MODEKEY_VI) {\n\t\tif (!grid_reader_in_set(&gr, WHITESPACE))\n\t\t\tgrid_reader_cursor_right(&gr, 0, 0);\n\t\tgrid_reader_cursor_next_word_end(&gr, separators);\n\t\tgrid_reader_cursor_left(&gr, 1);\n\t} else\n\t\tgrid_reader_cursor_next_word_end(&gr, separators);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\t*ppx = px;\n\t*ppy = py;\n}\n\n/* Move to the next place where a word ends. */\nstatic void\nwindow_copy_cursor_next_word_end(struct window_mode_entry *wme,\n    const char *separators, int no_reset)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy =  hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tif (options_get_number(oo, \"mode-keys\") == MODEKEY_VI) {\n\t\tif (!grid_reader_in_set(&gr, WHITESPACE))\n\t\t\tgrid_reader_cursor_right(&gr, 0, 0);\n\t\tgrid_reader_cursor_next_word_end(&gr, separators);\n\t\tgrid_reader_cursor_left(&gr, 1);\n\t} else\n\t\tgrid_reader_cursor_next_word_end(&gr, separators);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_down(wme, hsize, screen_size_y(back_s),\n\t    data->oy, oldy, px, py, no_reset);\n}\n\n/* Compute the previous place where a word begins. */\nstatic void\nwindow_copy_cursor_previous_word_pos(struct window_mode_entry *wme,\n    const char *separators, u_int *ppx, u_int *ppy)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, hsize;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_previous_word(&gr, separators, 0, 1);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\t*ppx = px;\n\t*ppy = py;\n}\n\n/* Move to the previous place where a word begins. */\nstatic void\nwindow_copy_cursor_previous_word(struct window_mode_entry *wme,\n    const char *separators, int already)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct window\t\t\t*w = wme->wp->window;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_reader\t\t gr;\n\tu_int\t\t\t\t px, py, oldy, hsize;\n\tint\t\t\t\t stop_at_eol;\n\n\tif (options_get_number(w->options, \"mode-keys\") == MODEKEY_EMACS)\n\t\tstop_at_eol = 1;\n\telse\n\t\tstop_at_eol = 0;\n\n\tpx = data->cx;\n\thsize = screen_hsize(back_s);\n\tpy = hsize + data->cy - data->oy;\n\toldy = data->cy;\n\n\tgrid_reader_start(&gr, back_s->grid, px, py);\n\tgrid_reader_cursor_previous_word(&gr, separators, already, stop_at_eol);\n\tgrid_reader_get_cursor(&gr, &px, &py);\n\twindow_copy_acquire_cursor_up(wme, hsize, data->oy, oldy, px, py);\n}\n\nstatic void\nwindow_copy_cursor_prompt(struct window_mode_entry *wme, int direction,\n    int start_output)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = data->backing;\n\tstruct grid\t\t\t*gd = s->grid;\n\tu_int\t\t\t\t end_line;\n\tu_int\t\t\t\t line = gd->hsize - data->oy + data->cy;\n\tint\t\t\t\t add, line_flag;\n\n\tif (start_output)\n\t\tline_flag = GRID_LINE_START_OUTPUT;\n\telse\n\t\tline_flag = GRID_LINE_START_PROMPT;\n\n\tif (direction == 0) { /* up */\n\t\tadd = -1;\n\t\tend_line = 0;\n\t} else { /* down */\n\t\tadd = 1;\n\t\tend_line = gd->hsize + gd->sy - 1;\n\t}\n\n\tif (line == end_line)\n\t\treturn;\n\tfor (;;) {\n\t\tif (line == end_line)\n\t\t\treturn;\n\t\tline += add;\n\n\t\tif (grid_get_line(gd, line)->flags & line_flag)\n\t\t\tbreak;\n\t}\n\n\tdata->cx = 0;\n\tif (line > gd->hsize) {\n\t\tdata->cy = line - gd->hsize;\n\t\tdata->oy = 0;\n\t} else {\n\t\tdata->cy = 0;\n\t\tdata->oy = gd->hsize - line;\n\t}\n\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\nstatic void\nwindow_copy_scroll_up(struct window_mode_entry *wme, u_int ny)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (data->oy < ny)\n\t\tny = data->oy;\n\tif (ny == 0)\n\t\treturn;\n\tdata->oy -= ny;\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 0, 0);\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0, 0);\n\tscreen_write_deleteline(&ctx, ny, 8);\n\twindow_copy_write_lines(wme, &ctx, screen_size_y(s) - ny, ny);\n\twindow_copy_write_line(wme, &ctx, 0);\n\tif (screen_size_y(s) > 1)\n\t\twindow_copy_write_line(wme, &ctx, 1);\n\tif (screen_size_y(s) > 3)\n\t\twindow_copy_write_line(wme, &ctx, screen_size_y(s) - 2);\n\tif (s->sel != NULL && screen_size_y(s) > ny)\n\t\twindow_copy_write_line(wme, &ctx, screen_size_y(s) - ny - 1);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy, 0);\n\tscreen_write_stop(&ctx);\n\twp->flags |= PANE_REDRAWSCROLLBAR;\n}\n\nstatic void\nwindow_copy_scroll_down(struct window_mode_entry *wme, u_int ny)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (ny > screen_hsize(data->backing))\n\t\treturn;\n\n\tif (data->oy > screen_hsize(data->backing) - ny)\n\t\tny = screen_hsize(data->backing) - data->oy;\n\tif (ny == 0)\n\t\treturn;\n\tdata->oy += ny;\n\n\tif (data->searchmark != NULL && !data->timeout)\n\t\twindow_copy_search_marks(wme, NULL, data->searchregex, 1);\n\twindow_copy_update_selection(wme, 0, 0);\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0, 0);\n\tscreen_write_insertline(&ctx, ny, 8);\n\twindow_copy_write_lines(wme, &ctx, 0, ny);\n\tif (s->sel != NULL && screen_size_y(s) > ny)\n\t\twindow_copy_write_line(wme, &ctx, ny);\n\telse if (ny == 1) /* nuke position */\n\t\twindow_copy_write_line(wme, &ctx, 1);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy, 0);\n\tscreen_write_stop(&ctx);\n\twp->flags |= PANE_REDRAWSCROLLBAR;\n}\n\nstatic void\nwindow_copy_rectangle_set(struct window_mode_entry *wme, int rectflag)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t px, py;\n\n\tdata->rectflag = rectflag;\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tpx = window_copy_find_length(wme, py);\n\tif (data->cx > px)\n\t\twindow_copy_update_cursor(wme, px, data->cy);\n\n\twindow_copy_update_selection(wme, 1, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\nstatic void\nwindow_copy_move_mouse(struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tu_int\t\t\t\t x, y;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn;\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL)\n\t\treturn;\n\tif (wme->mode != &window_copy_mode && wme->mode != &window_view_mode)\n\t\treturn;\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn;\n\n\twindow_copy_update_cursor(wme, x, y);\n}\n\nvoid\nwindow_copy_start_drag(struct client *c, struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tstruct window_copy_mode_data\t*data;\n\tu_int\t\t\t\t x, y, yg;\n\n\tif (c == NULL)\n\t\treturn;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn;\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL)\n\t\treturn;\n\tif (wme->mode != &window_copy_mode && wme->mode != &window_view_mode)\n\t\treturn;\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 1) != 0)\n\t\treturn;\n\n\tc->tty.mouse_drag_update = window_copy_drag_update;\n\tc->tty.mouse_drag_release = window_copy_drag_release;\n\n\tdata = wme->data;\n\tyg = screen_hsize(data->backing) + y - data->oy;\n\tif (x < data->selrx || x > data->endselrx || yg != data->selry)\n\t\tdata->selflag = SEL_CHAR;\n\tswitch (data->selflag) {\n\tcase SEL_WORD:\n\t\tif (data->separators != NULL) {\n\t\t\twindow_copy_update_cursor(wme, x, y);\n\t\t\twindow_copy_cursor_previous_word_pos(wme,\n\t\t\t    data->separators, &x, &y);\n\t\t\ty -= screen_hsize(data->backing) - data->oy;\n\t\t}\n\t\twindow_copy_update_cursor(wme, x, y);\n\t\tbreak;\n\tcase SEL_LINE:\n\t\twindow_copy_update_cursor(wme, 0, y);\n\t\tbreak;\n\tcase SEL_CHAR:\n\t\twindow_copy_update_cursor(wme, x, y);\n\t\twindow_copy_start_selection(wme);\n\t\tbreak;\n\t}\n\n\twindow_copy_redraw_screen(wme);\n\twindow_copy_drag_update(c, m);\n}\n\nstatic void\nwindow_copy_drag_update(struct client *c, struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tstruct window_copy_mode_data\t*data;\n\tu_int\t\t\t\t x, y, old_cx, old_cy;\n\tstruct timeval\t\t\t tv = {\n\t\t.tv_usec = WINDOW_COPY_DRAG_REPEAT_TIME\n\t};\n\n\tif (c == NULL)\n\t\treturn;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn;\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL)\n\t\treturn;\n\tif (wme->mode != &window_copy_mode && wme->mode != &window_view_mode)\n\t\treturn;\n\n\tdata = wme->data;\n\tevtimer_del(&data->dragtimer);\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn;\n\told_cx = data->cx;\n\told_cy = data->cy;\n\n\twindow_copy_update_cursor(wme, x, y);\n\tif (window_copy_update_selection(wme, 1, 0))\n\t\twindow_copy_redraw_selection(wme, old_cy);\n\tif (old_cy != data->cy || old_cx == data->cx) {\n\t\tif (y == 0) {\n\t\t\tevtimer_add(&data->dragtimer, &tv);\n\t\t\twindow_copy_cursor_up(wme, 1);\n\t\t} else if (y == screen_size_y(&data->screen) - 1) {\n\t\t\tevtimer_add(&data->dragtimer, &tv);\n\t\t\twindow_copy_cursor_down(wme, 1);\n\t\t}\n\t}\n}\n\nstatic void\nwindow_copy_drag_release(struct client *c, struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp;\n\tstruct window_mode_entry\t*wme;\n\tstruct window_copy_mode_data\t*data;\n\n\tif (c == NULL)\n\t\treturn;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL)\n\t\treturn;\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL)\n\t\treturn;\n\tif (wme->mode != &window_copy_mode && wme->mode != &window_view_mode)\n\t\treturn;\n\n\tdata = wme->data;\n\tevtimer_del(&data->dragtimer);\n}\n\nstatic void\nwindow_copy_jump_to_mark(struct window_mode_entry *wme)\n{\n\tstruct window_copy_mode_data\t*data = wme->data;\n\tu_int\t\t\t\t tmx, tmy;\n\n\ttmx = data->cx;\n\ttmy = screen_hsize(data->backing) + data->cy - data->oy;\n\tdata->cx = data->mx;\n\tif (data->my < screen_hsize(data->backing)) {\n\t\tdata->cy = 0;\n\t\tdata->oy = screen_hsize(data->backing) - data->my;\n\t} else {\n\t\tdata->cy = data->my - screen_hsize(data->backing);\n\t\tdata->oy = 0;\n\t}\n\tdata->mx = tmx;\n\tdata->my = tmy;\n\tdata->showmark = 1;\n\twindow_copy_update_selection(wme, 0, 0);\n\twindow_copy_redraw_screen(wme);\n}\n\n/* Scroll up if the cursor went off the visible screen. */\nstatic void\nwindow_copy_acquire_cursor_up(struct window_mode_entry *wme, u_int hsize,\n    u_int oy, u_int oldy, u_int px, u_int py)\n{\n\tu_int\tcy, yy, ny, nd;\n\n\tyy = hsize - oy;\n\tif (py < yy) {\n\t\tny = yy - py;\n\t\tcy = 0;\n\t\tnd = 1;\n\t} else {\n\t\tny = 0;\n\t\tcy = py - yy;\n\t\tnd = oldy - cy + 1;\n\t}\n\twhile (ny > 0) {\n\t\twindow_copy_cursor_up(wme, 1);\n\t\tny--;\n\t}\n\twindow_copy_update_cursor(wme, px, cy);\n\tif (window_copy_update_selection(wme, 1, 0))\n\t\twindow_copy_redraw_lines(wme, cy, nd);\n}\n\n/* Scroll down if the cursor went off the visible screen. */\nstatic void\nwindow_copy_acquire_cursor_down(struct window_mode_entry *wme, u_int hsize,\n    u_int sy, u_int oy, u_int oldy, u_int px, u_int py, int no_reset)\n{\n\tu_int\tcy, yy, ny, nd;\n\n\tcy = py - hsize + oy;\n\tyy = sy - 1;\n\tif (cy > yy) {\n\t\tny = cy - yy;\n\t\toldy = yy;\n\t\tnd = 1;\n\t} else {\n\t\tny = 0;\n\t\tnd = cy - oldy + 1;\n\t}\n\twhile (ny > 0) {\n\t  window_copy_cursor_down(wme, 1);\n\t  ny--;\n\t}\n\tif (cy > yy)\n\t\twindow_copy_update_cursor(wme, px, yy);\n\telse\n\t\twindow_copy_update_cursor(wme, px, cy);\n\tif (window_copy_update_selection(wme, 1, no_reset))\n\t\twindow_copy_redraw_lines(wme, oldy, nd);\n}\n"
        },
        {
          "name": "window-customize.c",
          "type": "blob",
          "size": 39.5302734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2020 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic struct screen\t*window_customize_init(struct window_mode_entry *,\n\t\t\t     struct cmd_find_state *, struct args *);\nstatic void\t\t window_customize_free(struct window_mode_entry *);\nstatic void\t\t window_customize_resize(struct window_mode_entry *,\n\t\t\t      u_int, u_int);\nstatic void\t\t window_customize_key(struct window_mode_entry *,\n\t\t\t     struct client *, struct session *,\n\t\t\t     struct winlink *, key_code, struct mouse_event *);\n\n#define WINDOW_CUSTOMIZE_DEFAULT_FORMAT \\\n\t\"#{?is_option,\" \\\n\t\t\"#{?option_is_global,,#[reverse](#{option_scope})#[default] }\" \\\n\t\t\"#[ignore]\" \\\n\t\t\"#{option_value}#{?option_unit, #{option_unit},}\" \\\n\t\",\" \\\n\t\t\"#{key}\" \\\n\t\"}\"\n\nstatic const struct menu_item window_customize_menu_items[] = {\n\t{ \"Select\", '\\r', NULL },\n\t{ \"Expand\", KEYC_RIGHT, NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Tag\", 't', NULL },\n\t{ \"Tag All\", '\\024', NULL },\n\t{ \"Tag None\", 'T', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Cancel\", 'q', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nconst struct window_mode window_customize_mode = {\n\t.name = \"options-mode\",\n\t.default_format = WINDOW_CUSTOMIZE_DEFAULT_FORMAT,\n\n\t.init = window_customize_init,\n\t.free = window_customize_free,\n\t.resize = window_customize_resize,\n\t.key = window_customize_key,\n};\n\nenum window_customize_scope {\n\tWINDOW_CUSTOMIZE_NONE,\n\tWINDOW_CUSTOMIZE_KEY,\n\tWINDOW_CUSTOMIZE_SERVER,\n\tWINDOW_CUSTOMIZE_GLOBAL_SESSION,\n\tWINDOW_CUSTOMIZE_SESSION,\n\tWINDOW_CUSTOMIZE_GLOBAL_WINDOW,\n\tWINDOW_CUSTOMIZE_WINDOW,\n\tWINDOW_CUSTOMIZE_PANE\n};\n\nenum window_customize_change {\n\tWINDOW_CUSTOMIZE_UNSET,\n\tWINDOW_CUSTOMIZE_RESET,\n};\n\nstruct window_customize_itemdata {\n\tstruct window_customize_modedata\t*data;\n\tenum window_customize_scope\t\t scope;\n\n\tchar\t\t\t\t\t*table;\n\tkey_code\t\t\t\t key;\n\n\tstruct options\t\t\t\t*oo;\n\tchar\t\t\t\t\t*name;\n\tint\t\t\t\t\t idx;\n};\n\nstruct window_customize_modedata {\n\tstruct window_pane\t\t\t *wp;\n\tint\t\t\t\t\t  dead;\n\tint\t\t\t\t\t  references;\n\n\tstruct mode_tree_data\t\t\t *data;\n\tchar\t\t\t\t\t *format;\n\tint\t\t\t\t\t  hide_global;\n\tint\t\t\t\t\t  prompt_flags;\n\n\tstruct window_customize_itemdata\t**item_list;\n\tu_int\t\t\t\t\t  item_size;\n\n\tstruct cmd_find_state\t\t\t  fs;\n\tenum window_customize_change\t\t  change;\n};\n\nstatic uint64_t\nwindow_customize_get_tag(struct options_entry *o, int idx,\n    const struct options_table_entry *oe)\n{\n\tuint64_t\toffset;\n\n\tif (oe == NULL)\n\t\treturn ((uint64_t)o);\n\toffset = ((char *)oe - (char *)options_table) / sizeof *options_table;\n\treturn ((2ULL << 62)|(offset << 32)|((idx + 1) << 1)|1);\n}\n\nstatic struct options *\nwindow_customize_get_tree(enum window_customize_scope scope,\n    struct cmd_find_state *fs)\n{\n\tswitch (scope) {\n\tcase WINDOW_CUSTOMIZE_NONE:\n\tcase WINDOW_CUSTOMIZE_KEY:\n\t\treturn (NULL);\n\tcase WINDOW_CUSTOMIZE_SERVER:\n\t\treturn (global_options);\n\tcase WINDOW_CUSTOMIZE_GLOBAL_SESSION:\n\t\treturn (global_s_options);\n\tcase WINDOW_CUSTOMIZE_SESSION:\n\t\treturn (fs->s->options);\n\tcase WINDOW_CUSTOMIZE_GLOBAL_WINDOW:\n\t\treturn (global_w_options);\n\tcase WINDOW_CUSTOMIZE_WINDOW:\n\t\treturn (fs->w->options);\n\tcase WINDOW_CUSTOMIZE_PANE:\n\t\treturn (fs->wp->options);\n\t}\n\treturn (NULL);\n}\n\nstatic int\nwindow_customize_check_item(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item, struct cmd_find_state *fsp)\n{\n\tstruct cmd_find_state\tfs;\n\n\tif (fsp == NULL)\n\t\tfsp = &fs;\n\n\tif (cmd_find_valid_state(&data->fs))\n\t\tcmd_find_copy_state(fsp, &data->fs);\n\telse\n\t\tcmd_find_from_pane(fsp, data->wp, 0);\n\treturn (item->oo == window_customize_get_tree(item->scope, fsp));\n}\n\nstatic int\nwindow_customize_get_key(struct window_customize_itemdata *item,\n    struct key_table **ktp, struct key_binding **bdp)\n{\n\tstruct key_table\t*kt;\n\tstruct key_binding\t*bd;\n\n\tkt = key_bindings_get_table(item->table, 0);\n\tif (kt == NULL)\n\t\treturn (0);\n\tbd = key_bindings_get(kt, item->key);\n\tif (bd == NULL)\n\t\treturn (0);\n\n\tif (ktp != NULL)\n\t\t*ktp = kt;\n\tif (bdp != NULL)\n\t\t*bdp = bd;\n\treturn (1);\n}\n\nstatic char *\nwindow_customize_scope_text(enum window_customize_scope scope,\n    struct cmd_find_state *fs)\n{\n\tchar\t*s;\n\tu_int\t idx;\n\n\tswitch (scope) {\n\tcase WINDOW_CUSTOMIZE_PANE:\n\t\twindow_pane_index(fs->wp, &idx);\n\t\txasprintf(&s, \"pane %u\", idx);\n\t\tbreak;\n\tcase WINDOW_CUSTOMIZE_SESSION:\n\t\txasprintf(&s, \"session %s\", fs->s->name);\n\t\tbreak;\n\tcase WINDOW_CUSTOMIZE_WINDOW:\n\t\txasprintf(&s, \"window %u\", fs->wl->idx);\n\t\tbreak;\n\tdefault:\n\t\ts = xstrdup(\"\");\n\t\tbreak;\n\t}\n\treturn (s);\n}\n\nstatic struct window_customize_itemdata *\nwindow_customize_add_item(struct window_customize_modedata *data)\n{\n\tstruct window_customize_itemdata\t*item;\n\n\tdata->item_list = xreallocarray(data->item_list, data->item_size + 1,\n\t    sizeof *data->item_list);\n\titem = data->item_list[data->item_size++] = xcalloc(1, sizeof *item);\n\treturn (item);\n}\n\nstatic void\nwindow_customize_free_item(struct window_customize_itemdata *item)\n{\n\tfree(item->table);\n\tfree(item->name);\n\tfree(item);\n}\n\nstatic void\nwindow_customize_build_array(struct window_customize_modedata *data,\n    struct mode_tree_item *top, enum window_customize_scope scope,\n    struct options_entry *o, struct format_tree *ft)\n{\n\tconst struct options_table_entry\t*oe = options_table_entry(o);\n\tstruct options\t\t\t\t*oo = options_owner(o);\n\tstruct window_customize_itemdata\t*item;\n\tstruct options_array_item\t\t*ai;\n\tchar\t\t\t\t\t*name, *value, *text;\n\tu_int\t\t\t\t\t idx;\n\tuint64_t\t\t\t\t tag;\n\n\tai = options_array_first(o);\n\twhile (ai != NULL) {\n\t\tidx = options_array_item_index(ai);\n\n\t\txasprintf(&name, \"%s[%u]\", options_name(o), idx);\n\t\tformat_add(ft, \"option_name\", \"%s\", name);\n\t\tvalue = options_to_string(o, idx, 0);\n\t\tformat_add(ft, \"option_value\", \"%s\", value);\n\n\t\titem = window_customize_add_item(data);\n\t\titem->scope = scope;\n\t\titem->oo = oo;\n\t\titem->name = xstrdup(options_name(o));\n\t\titem->idx = idx;\n\n\t\ttext = format_expand(ft, data->format);\n\t\ttag = window_customize_get_tag(o, idx, oe);\n\t\tmode_tree_add(data->data, top, item, tag, name, text, -1);\n\t\tfree(text);\n\n\t\tfree(name);\n\t\tfree(value);\n\n\t\tai = options_array_next(ai);\n\t}\n}\n\nstatic void\nwindow_customize_build_option(struct window_customize_modedata *data,\n    struct mode_tree_item *top, enum window_customize_scope scope,\n    struct options_entry *o, struct format_tree *ft,\n    const char *filter, struct cmd_find_state *fs)\n{\n\tconst struct options_table_entry\t*oe = options_table_entry(o);\n\tstruct options\t\t\t\t*oo = options_owner(o);\n\tconst char\t\t\t\t*name = options_name(o);\n\tstruct window_customize_itemdata\t*item;\n\tchar\t\t\t\t\t*text, *expanded, *value;\n\tint\t\t\t\t\t global = 0, array = 0;\n\tuint64_t\t\t\t\t tag;\n\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_HOOK))\n\t\treturn;\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY))\n\t\tarray = 1;\n\n\tif (scope == WINDOW_CUSTOMIZE_SERVER ||\n\t    scope == WINDOW_CUSTOMIZE_GLOBAL_SESSION ||\n\t    scope == WINDOW_CUSTOMIZE_GLOBAL_WINDOW)\n\t\tglobal = 1;\n\tif (data->hide_global && global)\n\t\treturn;\n\n\tformat_add(ft, \"option_name\", \"%s\", name);\n\tformat_add(ft, \"option_is_global\", \"%d\", global);\n\tformat_add(ft, \"option_is_array\", \"%d\", array);\n\n\ttext = window_customize_scope_text(scope, fs);\n\tformat_add(ft, \"option_scope\", \"%s\", text);\n\tfree(text);\n\n\tif (oe != NULL && oe->unit != NULL)\n\t\tformat_add(ft, \"option_unit\", \"%s\", oe->unit);\n\telse\n\t\tformat_add(ft, \"option_unit\", \"%s\", \"\");\n\n\tif (!array) {\n\t\tvalue = options_to_string(o, -1, 0);\n\t\tformat_add(ft, \"option_value\", \"%s\", value);\n\t\tfree(value);\n\t}\n\n\tif (filter != NULL) {\n\t\texpanded = format_expand(ft, filter);\n\t\tif (!format_true(expanded)) {\n\t\t\tfree(expanded);\n\t\t\treturn;\n\t\t}\n\t\tfree(expanded);\n\t}\n\titem = window_customize_add_item(data);\n\titem->oo = oo;\n\titem->scope = scope;\n\titem->name = xstrdup(name);\n\titem->idx = -1;\n\n\tif (array)\n\t\ttext = NULL;\n\telse\n\t\ttext = format_expand(ft, data->format);\n\ttag = window_customize_get_tag(o, -1, oe);\n\ttop = mode_tree_add(data->data, top, item, tag, name, text, 0);\n\tfree(text);\n\n\tif (array)\n\t\twindow_customize_build_array(data, top, scope, o, ft);\n}\n\nstatic void\nwindow_customize_find_user_options(struct options *oo, const char ***list,\n    u_int *size)\n{\n\tstruct options_entry\t*o;\n\tconst char\t\t*name;\n\tu_int\t\t\t i;\n\n\to = options_first(oo);\n\twhile (o != NULL) {\n\t\tname = options_name(o);\n\t\tif (*name != '@') {\n\t\t\to = options_next(o);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < *size; i++) {\n\t\t\tif (strcmp((*list)[i], name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != *size) {\n\t\t\to = options_next(o);\n\t\t\tcontinue;\n\t\t}\n\t\t*list = xreallocarray(*list, (*size) + 1, sizeof **list);\n\t\t(*list)[(*size)++] = name;\n\n\t\to = options_next(o);\n\t}\n}\n\nstatic void\nwindow_customize_build_options(struct window_customize_modedata *data,\n    const char *title, uint64_t tag,\n    enum window_customize_scope scope0, struct options *oo0,\n    enum window_customize_scope scope1, struct options *oo1,\n    enum window_customize_scope scope2, struct options *oo2,\n    struct format_tree *ft, const char *filter, struct cmd_find_state *fs)\n{\n\tstruct mode_tree_item\t\t *top;\n\tstruct options_entry\t\t *o = NULL, *loop;\n\tconst char\t\t\t**list = NULL, *name;\n\tu_int\t\t\t\t  size = 0, i;\n\tenum window_customize_scope\t  scope;\n\n\ttop = mode_tree_add(data->data, NULL, NULL, tag, title, NULL, 0);\n\tmode_tree_no_tag(top);\n\n\t/*\n\t * We get the options from the first tree, but build it using the\n\t * values from the other two. Any tree can have user options so we need\n\t * to build a separate list of them.\n\t */\n\n\twindow_customize_find_user_options(oo0, &list, &size);\n\tif (oo1 != NULL)\n\t\twindow_customize_find_user_options(oo1, &list, &size);\n\tif (oo2 != NULL)\n\t\twindow_customize_find_user_options(oo2, &list, &size);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (oo2 != NULL)\n\t\t\to = options_get(oo2, list[i]);\n\t\tif (o == NULL && oo1 != NULL)\n\t\t\to = options_get(oo1, list[i]);\n\t\tif (o == NULL)\n\t\t\to = options_get(oo0, list[i]);\n\t\tif (options_owner(o) == oo2)\n\t\t\tscope = scope2;\n\t\telse if (options_owner(o) == oo1)\n\t\t\tscope = scope1;\n\t\telse\n\t\t\tscope = scope0;\n\t\twindow_customize_build_option(data, top, scope, o, ft, filter,\n\t\t    fs);\n\t}\n\tfree(list);\n\n\tloop = options_first(oo0);\n\twhile (loop != NULL) {\n\t\tname = options_name(loop);\n\t\tif (*name == '@') {\n\t\t\tloop = options_next(loop);\n\t\t\tcontinue;\n\t\t}\n\t\tif (oo2 != NULL)\n\t\t\to = options_get(oo2, name);\n\t\telse if (oo1 != NULL)\n\t\t\to = options_get(oo1, name);\n\t\telse\n\t\t\to = loop;\n\t\tif (options_owner(o) == oo2)\n\t\t\tscope = scope2;\n\t\telse if (options_owner(o) == oo1)\n\t\t\tscope = scope1;\n\t\telse\n\t\t\tscope = scope0;\n\t\twindow_customize_build_option(data, top, scope, o, ft, filter,\n\t\t    fs);\n\t\tloop = options_next(loop);\n\t}\n}\n\nstatic void\nwindow_customize_build_keys(struct window_customize_modedata *data,\n    struct key_table *kt, struct format_tree *ft, const char *filter,\n    struct cmd_find_state *fs, u_int number)\n{\n\tstruct mode_tree_item\t\t\t*top, *child, *mti;\n\tstruct window_customize_itemdata\t*item;\n\tstruct key_binding\t\t\t*bd;\n\tchar\t\t\t\t\t*title, *text, *tmp, *expanded;\n\tconst char\t\t\t\t*flag;\n\tuint64_t\t\t\t\t tag;\n\n\ttag = (1ULL << 62)|((uint64_t)number << 54)|1;\n\n\txasprintf(&title, \"Key Table - %s\", kt->name);\n\ttop = mode_tree_add(data->data, NULL, NULL, tag, title, NULL, 0);\n\tmode_tree_no_tag(top);\n\tfree(title);\n\n\tft = format_create_from_state(NULL, NULL, fs);\n\tformat_add(ft, \"is_option\", \"0\");\n\tformat_add(ft, \"is_key\", \"1\");\n\n\tbd = key_bindings_first(kt);\n\twhile (bd != NULL) {\n\t\tformat_add(ft, \"key\", \"%s\", key_string_lookup_key(bd->key, 0));\n\t\tif (bd->note != NULL)\n\t\t\tformat_add(ft, \"key_note\", \"%s\", bd->note);\n\t\tif (filter != NULL) {\n\t\t\texpanded = format_expand(ft, filter);\n\t\t\tif (!format_true(expanded)) {\n\t\t\t\tfree(expanded);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(expanded);\n\t\t}\n\n\t\titem = window_customize_add_item(data);\n\t\titem->scope = WINDOW_CUSTOMIZE_KEY;\n\t\titem->table = xstrdup(kt->name);\n\t\titem->key = bd->key;\n\t\titem->name = xstrdup(key_string_lookup_key(item->key, 0));\n\t\titem->idx = -1;\n\n\t\texpanded = format_expand(ft, data->format);\n\t\tchild = mode_tree_add(data->data, top, item, (uint64_t)bd,\n\t\t    expanded, NULL, 0);\n\t\tfree(expanded);\n\n\t\ttmp = cmd_list_print(bd->cmdlist, 0);\n\t\txasprintf(&text, \"#[ignore]%s\", tmp);\n\t\tfree(tmp);\n\t\tmti = mode_tree_add(data->data, child, item,\n\t\t    tag|(bd->key << 3)|(0 << 1)|1, \"Command\", text, -1);\n\t\tmode_tree_draw_as_parent(mti);\n\t\tmode_tree_no_tag(mti);\n\t\tfree(text);\n\n\t\tif (bd->note != NULL)\n\t\t\txasprintf(&text, \"#[ignore]%s\", bd->note);\n\t\telse\n\t\t\ttext = xstrdup(\"\");\n\t\tmti = mode_tree_add(data->data, child, item,\n\t\t    tag|(bd->key << 3)|(1 << 1)|1, \"Note\", text, -1);\n\t\tmode_tree_draw_as_parent(mti);\n\t\tmode_tree_no_tag(mti);\n\t\tfree(text);\n\n\t\tif (bd->flags & KEY_BINDING_REPEAT)\n\t\t\tflag = \"on\";\n\t\telse\n\t\t\tflag = \"off\";\n\t\tmti = mode_tree_add(data->data, child, item,\n\t\t    tag|(bd->key << 3)|(2 << 1)|1, \"Repeat\", flag, -1);\n\t\tmode_tree_draw_as_parent(mti);\n\t\tmode_tree_no_tag(mti);\n\n\t\tbd = key_bindings_next(kt, bd);\n\t}\n\n\tformat_free(ft);\n}\n\nstatic void\nwindow_customize_build(void *modedata,\n    __unused struct mode_tree_sort_criteria *sort_crit, __unused uint64_t *tag,\n    const char *filter)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\tstruct cmd_find_state\t\t\t fs;\n\tstruct format_tree\t\t\t*ft;\n\tu_int\t\t\t\t\t i;\n\tstruct key_table\t\t\t*kt;\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_customize_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\tdata->item_list = NULL;\n\tdata->item_size = 0;\n\n\tif (cmd_find_valid_state(&data->fs))\n\t\tcmd_find_copy_state(&fs, &data->fs);\n\telse\n\t\tcmd_find_from_pane(&fs, data->wp, 0);\n\n\tft = format_create_from_state(NULL, NULL, &fs);\n\tformat_add(ft, \"is_option\", \"1\");\n\tformat_add(ft, \"is_key\", \"0\");\n\n\twindow_customize_build_options(data, \"Server Options\",\n\t    (3ULL << 62)|(OPTIONS_TABLE_SERVER << 1)|1,\n\t    WINDOW_CUSTOMIZE_SERVER, global_options,\n\t    WINDOW_CUSTOMIZE_NONE, NULL,\n\t    WINDOW_CUSTOMIZE_NONE, NULL,\n\t    ft, filter, &fs);\n\twindow_customize_build_options(data, \"Session Options\",\n\t    (3ULL << 62)|(OPTIONS_TABLE_SESSION << 1)|1,\n\t    WINDOW_CUSTOMIZE_GLOBAL_SESSION, global_s_options,\n\t    WINDOW_CUSTOMIZE_SESSION, fs.s->options,\n\t    WINDOW_CUSTOMIZE_NONE, NULL,\n\t    ft, filter, &fs);\n\twindow_customize_build_options(data, \"Window & Pane Options\",\n\t    (3ULL << 62)|(OPTIONS_TABLE_WINDOW << 1)|1,\n\t    WINDOW_CUSTOMIZE_GLOBAL_WINDOW, global_w_options,\n\t    WINDOW_CUSTOMIZE_WINDOW, fs.w->options,\n\t    WINDOW_CUSTOMIZE_PANE, fs.wp->options,\n\t    ft, filter, &fs);\n\n\tformat_free(ft);\n\tft = format_create_from_state(NULL, NULL, &fs);\n\n\ti = 0;\n\tkt = key_bindings_first_table();\n\twhile (kt != NULL) {\n\t\tif (!RB_EMPTY(&kt->key_bindings)) {\n\t\t\twindow_customize_build_keys(data, kt, ft, filter, &fs,\n\t\t\t    i);\n\t\t\tif (++i == 256)\n\t\t\t\tbreak;\n\t\t}\n\t\tkt = key_bindings_next_table(kt);\n\t}\n\n\tformat_free(ft);\n}\n\nstatic void\nwindow_customize_draw_key(__unused struct window_customize_modedata *data,\n    struct window_customize_itemdata *item, struct screen_write_ctx *ctx,\n    u_int sx, u_int sy)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tu_int\t\t\t cx = s->cx, cy = s->cy;\n\tstruct key_table\t*kt;\n\tstruct key_binding\t*bd, *default_bd;\n\tconst char\t\t*note, *period = \"\";\n\tchar\t\t\t*cmd, *default_cmd;\n\n\tif (item == NULL || !window_customize_get_key(item, &kt, &bd))\n\t\treturn;\n\n\tnote = bd->note;\n\tif (note == NULL)\n\t\tnote = \"There is no note for this key.\";\n\tif (*note != '\\0' && note[strlen (note) - 1] != '.')\n\t\tperiod = \".\";\n\tif (!screen_write_text(ctx, cx, sx, sy, 0, &grid_default_cell, \"%s%s\",\n\t    note, period))\n\t\treturn;\n\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0); /* skip line */\n\tif (s->cy >= cy + sy - 1)\n\t\treturn;\n\n\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t    &grid_default_cell, \"This key is in the %s table.\", kt->name))\n\t\treturn;\n\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t    &grid_default_cell, \"This key %s repeat.\",\n\t    (bd->flags & KEY_BINDING_REPEAT) ? \"does\" : \"does not\"))\n\t\treturn;\n\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0); /* skip line */\n\tif (s->cy >= cy + sy - 1)\n\t\treturn;\n\n\tcmd = cmd_list_print(bd->cmdlist, 0);\n\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t    &grid_default_cell, \"Command: %s\", cmd)) {\n\t\tfree(cmd);\n\t\treturn;\n\t}\n\tdefault_bd = key_bindings_get_default(kt, bd->key);\n\tif (default_bd != NULL) {\n\t\tdefault_cmd = cmd_list_print(default_bd->cmdlist, 0);\n\t\tif (strcmp(cmd, default_cmd) != 0 &&\n\t\t    !screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t\t    &grid_default_cell, \"The default is: %s\", default_cmd)) {\n\t\t\tfree(default_cmd);\n\t\t\tfree(cmd);\n\t\t\treturn;\n\t\t}\n\t\tfree(default_cmd);\n\t}\n\tfree(cmd);\n}\n\nstatic void\nwindow_customize_draw_option(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item, struct screen_write_ctx *ctx,\n    u_int sx, u_int sy)\n{\n\tstruct screen\t\t\t\t *s = ctx->s;\n\tu_int\t\t\t\t\t  cx = s->cx, cy = s->cy;\n\tint\t\t\t\t\t  idx;\n\tstruct options_entry\t\t\t *o, *parent;\n\tstruct options\t\t\t\t *go, *wo;\n\tconst struct options_table_entry\t *oe;\n\tstruct grid_cell\t\t\t  gc;\n\tconst char\t\t\t\t**choice, *text, *name;\n\tconst char\t\t\t\t *space = \"\", *unit = \"\";\n\tchar\t\t\t\t\t *value = NULL, *expanded;\n\tchar\t\t\t\t\t *default_value = NULL;\n\tchar\t\t\t\t\t  choices[256] = \"\";\n\tstruct cmd_find_state\t\t\t  fs;\n\tstruct format_tree\t\t\t *ft;\n\n\tif (!window_customize_check_item(data, item, &fs))\n\t\treturn;\n\tname = item->name;\n\tidx = item->idx;\n\n\to = options_get(item->oo, name);\n\tif (o == NULL)\n\t\treturn;\n\toe = options_table_entry(o);\n\n\tif (oe != NULL && oe->unit != NULL) {\n\t\tspace = \" \";\n\t\tunit = oe->unit;\n\t}\n\tft = format_create_from_state(NULL, NULL, &fs);\n\n\tif (oe == NULL || oe->text == NULL)\n\t\ttext = \"This option doesn't have a description.\";\n\telse\n\t\ttext = oe->text;\n\tif (!screen_write_text(ctx, cx, sx, sy, 0, &grid_default_cell, \"%s\",\n\t    text))\n\t\tgoto out;\n\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0); /* skip line */\n\tif (s->cy >= cy + sy - 1)\n\t\tgoto out;\n\n\tif (oe == NULL)\n\t\ttext = \"user\";\n\telse if ((oe->scope & (OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE)) ==\n\t    (OPTIONS_TABLE_WINDOW|OPTIONS_TABLE_PANE))\n\t\ttext = \"window and pane\";\n\telse if (oe->scope & OPTIONS_TABLE_WINDOW)\n\t\ttext = \"window\";\n\telse if (oe->scope & OPTIONS_TABLE_SESSION)\n\t\ttext = \"session\";\n\telse\n\t\ttext = \"server\";\n\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t    &grid_default_cell, \"This is a %s option.\", text))\n\t\tgoto out;\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY)) {\n\t\tif (idx != -1) {\n\t\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy),\n\t\t\t    0, &grid_default_cell,\n\t\t\t    \"This is an array option, index %u.\", idx))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy),\n\t\t\t    0, &grid_default_cell, \"This is an array option.\"))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (idx == -1)\n\t\t\tgoto out;\n\t}\n\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0); /* skip line */\n\tif (s->cy >= cy + sy - 1)\n\t\tgoto out;\n\n\tvalue = options_to_string(o, idx, 0);\n\tif (oe != NULL && idx == -1) {\n\t\tdefault_value = options_default_to_string(oe);\n\t\tif (strcmp(default_value, value) == 0) {\n\t\t\tfree(default_value);\n\t\t\tdefault_value = NULL;\n\t\t}\n\t}\n\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t    &grid_default_cell, \"Option value: %s%s%s\", value, space, unit))\n\t\tgoto out;\n\tif (oe == NULL || oe->type == OPTIONS_TABLE_STRING) {\n\t\texpanded = format_expand(ft, value);\n\t\tif (strcmp(expanded, value) != 0) {\n\t\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy),\n\t\t\t    0, &grid_default_cell, \"This expands to: %s\",\n\t\t\t    expanded))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfree(expanded);\n\t}\n\tif (oe != NULL && oe->type == OPTIONS_TABLE_CHOICE) {\n\t\tfor (choice = oe->choices; *choice != NULL; choice++) {\n\t\t\tstrlcat(choices, *choice, sizeof choices);\n\t\t\tstrlcat(choices, \", \", sizeof choices);\n\t\t}\n\t\tchoices[strlen(choices) - 2] = '\\0';\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t\t    &grid_default_cell, \"Available values are: %s\",\n\t\t    choices))\n\t\t\tgoto out;\n\t}\n\tif (oe != NULL && oe->type == OPTIONS_TABLE_COLOUR) {\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 1,\n\t\t    &grid_default_cell, \"This is a colour option: \"))\n\t\t\tgoto out;\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\tgc.fg = options_get_number(item->oo, name);\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0, &gc,\n\t\t    \"EXAMPLE\"))\n\t\t\tgoto out;\n\t}\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_STYLE)) {\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 1,\n\t\t    &grid_default_cell, \"This is a style option: \"))\n\t\t\tgoto out;\n\t\tstyle_apply(&gc, item->oo, name, ft);\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0, &gc,\n\t\t    \"EXAMPLE\"))\n\t\t\tgoto out;\n\t}\n\tif (default_value != NULL) {\n\t\tif (!screen_write_text(ctx, cx, sx, sy - (s->cy - cy), 0,\n\t\t    &grid_default_cell, \"The default is: %s%s%s\", default_value,\n\t\t    space, unit))\n\t\t\tgoto out;\n\t}\n\n\tscreen_write_cursormove(ctx, cx, s->cy + 1, 0); /* skip line */\n\tif (s->cy > cy + sy - 1)\n\t\tgoto out;\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY)) {\n\t\two = NULL;\n\t\tgo = NULL;\n\t} else {\n\t\tswitch (item->scope) {\n\t\tcase WINDOW_CUSTOMIZE_PANE:\n\t\t\two = options_get_parent(item->oo);\n\t\t\tgo = options_get_parent(wo);\n\t\t\tbreak;\n\t\tcase WINDOW_CUSTOMIZE_WINDOW:\n\t\tcase WINDOW_CUSTOMIZE_SESSION:\n\t\t\two = NULL;\n\t\t\tgo = options_get_parent(item->oo);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\two = NULL;\n\t\t\tgo = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wo != NULL && options_owner(o) != wo) {\n\t\tparent = options_get_only(wo, name);\n\t\tif (parent != NULL) {\n\t\t\tvalue = options_to_string(parent, -1 , 0);\n\t\t\tif (!screen_write_text(ctx, s->cx, sx,\n\t\t\t    sy - (s->cy - cy), 0, &grid_default_cell,\n\t\t\t    \"Window value (from window %u): %s%s%s\", fs.wl->idx,\n\t\t\t    value, space, unit))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tif (go != NULL && options_owner(o) != go) {\n\t\tparent = options_get_only(go, name);\n\t\tif (parent != NULL) {\n\t\t\tvalue = options_to_string(parent, -1 , 0);\n\t\t\tif (!screen_write_text(ctx, s->cx, sx,\n\t\t\t    sy - (s->cy - cy), 0, &grid_default_cell,\n\t\t\t    \"Global value: %s%s%s\", value, space, unit))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(value);\n\tfree(default_value);\n\tformat_free(ft);\n}\n\nstatic void\nwindow_customize_draw(void *modedata, void *itemdata,\n    struct screen_write_ctx *ctx, u_int sx, u_int sy)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\tstruct window_customize_itemdata\t*item = itemdata;\n\n\tif (item == NULL)\n\t\treturn;\n\n\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\twindow_customize_draw_key(data, item, ctx, sx, sy);\n\telse\n\t\twindow_customize_draw_option(data, item, ctx, sx, sy);\n}\n\nstatic void\nwindow_customize_menu(void *modedata, struct client *c, key_code key)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\tstruct window_pane\t\t\t*wp = data->wp;\n\tstruct window_mode_entry\t\t*wme;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->data != modedata)\n\t\treturn;\n\twindow_customize_key(wme, c, NULL, NULL, key, NULL);\n}\n\nstatic u_int\nwindow_customize_height(__unused void *modedata, __unused u_int height)\n{\n\treturn (12);\n}\n\nstatic struct screen *\nwindow_customize_init(struct window_mode_entry *wme, struct cmd_find_state *fs,\n    struct args *args)\n{\n\tstruct window_pane\t\t\t*wp = wme->wp;\n\tstruct window_customize_modedata\t*data;\n\tstruct screen\t\t\t\t*s;\n\n\twme->data = data = xcalloc(1, sizeof *data);\n\tdata->wp = wp;\n\tdata->references = 1;\n\n\tmemcpy(&data->fs, fs, sizeof data->fs);\n\n\tif (args == NULL || !args_has(args, 'F'))\n\t\tdata->format = xstrdup(WINDOW_CUSTOMIZE_DEFAULT_FORMAT);\n\telse\n\t\tdata->format = xstrdup(args_get(args, 'F'));\n\tif (args_has(args, 'y'))\n\t\tdata->prompt_flags = PROMPT_ACCEPT;\n\n\tdata->data = mode_tree_start(wp, args, window_customize_build,\n\t    window_customize_draw, NULL, window_customize_menu,\n\t    window_customize_height, NULL, data, window_customize_menu_items,\n\t    NULL, 0, &s);\n\tmode_tree_zoom(data->data, args);\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\n\treturn (s);\n}\n\nstatic void\nwindow_customize_destroy(struct window_customize_modedata *data)\n{\n\tu_int\ti;\n\n\tif (--data->references != 0)\n\t\treturn;\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_customize_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\n\tfree(data->format);\n\n\tfree(data);\n}\n\nstatic void\nwindow_customize_free(struct window_mode_entry *wme)\n{\n\tstruct window_customize_modedata *data = wme->data;\n\n\tif (data == NULL)\n\t\treturn;\n\n\tdata->dead = 1;\n\tmode_tree_free(data->data);\n\twindow_customize_destroy(data);\n}\n\nstatic void\nwindow_customize_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_customize_modedata\t*data = wme->data;\n\n\tmode_tree_resize(data->data, sx, sy);\n}\n\nstatic void\nwindow_customize_free_callback(void *modedata)\n{\n\twindow_customize_destroy(modedata);\n}\n\nstatic void\nwindow_customize_free_item_callback(void *itemdata)\n{\n\tstruct window_customize_itemdata\t*item = itemdata;\n\tstruct window_customize_modedata\t*data = item->data;\n\n\twindow_customize_free_item(item);\n\twindow_customize_destroy(data);\n}\n\nstatic int\nwindow_customize_set_option_callback(struct client *c, void *itemdata,\n    const char *s, __unused int done)\n{\n\tstruct window_customize_itemdata\t*item = itemdata;\n\tstruct window_customize_modedata\t*data = item->data;\n\tstruct options_entry\t\t\t*o;\n\tconst struct options_table_entry\t*oe;\n\tstruct options\t\t\t\t*oo = item->oo;\n\tconst char\t\t\t\t*name = item->name;\n\tchar\t\t\t\t\t*cause;\n\tint\t\t\t\t\t idx = item->idx;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (item == NULL || !window_customize_check_item(data, item, NULL))\n\t\treturn (0);\n\to = options_get(oo, name);\n\tif (o == NULL)\n\t\treturn (0);\n\toe = options_table_entry(o);\n\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY)) {\n\t\tif (idx == -1) {\n\t\t\tfor (idx = 0; idx < INT_MAX; idx++) {\n\t\t\t\tif (options_array_get(o, idx) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (options_array_set(o, idx, s, 0, &cause) != 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tif (options_from_string(oo, oe, name, s, 0, &cause) != 0)\n\t\t\tgoto fail;\n\t}\n\n\toptions_push_changes(item->name);\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n\nfail:\n\t*cause = toupper((u_char)*cause);\n\tstatus_message_set(c, -1, 1, 0, \"%s\", cause);\n\tfree(cause);\n\treturn (0);\n}\n\nstatic void\nwindow_customize_set_option(struct client *c,\n    struct window_customize_modedata *data,\n    struct window_customize_itemdata *item, int global, int pane)\n{\n\tstruct options_entry\t\t\t*o;\n\tconst struct options_table_entry\t*oe;\n\tstruct options\t\t\t\t*oo;\n\tstruct window_customize_itemdata\t*new_item;\n\tint\t\t\t\t\t flag, idx = item->idx;\n\tenum window_customize_scope\t\t scope = WINDOW_CUSTOMIZE_NONE;\n\tu_int\t\t\t\t\t choice;\n\tconst char\t\t\t\t*name = item->name, *space = \"\";\n\tchar\t\t\t\t\t*prompt, *value, *text;\n\tstruct cmd_find_state\t\t\t fs;\n\n\tif (item == NULL || !window_customize_check_item(data, item, &fs))\n\t\treturn;\n\to = options_get(item->oo, name);\n\tif (o == NULL)\n\t\treturn;\n\n\toe = options_table_entry(o);\n\tif (oe != NULL && ~oe->scope & OPTIONS_TABLE_PANE)\n\t\tpane = 0;\n\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY)) {\n\t\tscope = item->scope;\n\t\too = item->oo;\n\t} else {\n\t\tif (global) {\n\t\t\tswitch (item->scope) {\n\t\t\tcase WINDOW_CUSTOMIZE_NONE:\n\t\t\tcase WINDOW_CUSTOMIZE_KEY:\n\t\t\tcase WINDOW_CUSTOMIZE_SERVER:\n\t\t\tcase WINDOW_CUSTOMIZE_GLOBAL_SESSION:\n\t\t\tcase WINDOW_CUSTOMIZE_GLOBAL_WINDOW:\n\t\t\t\tscope = item->scope;\n\t\t\t\tbreak;\n\t\t\tcase WINDOW_CUSTOMIZE_SESSION:\n\t\t\t\tscope = WINDOW_CUSTOMIZE_GLOBAL_SESSION;\n\t\t\t\tbreak;\n\t\t\tcase WINDOW_CUSTOMIZE_WINDOW:\n\t\t\tcase WINDOW_CUSTOMIZE_PANE:\n\t\t\t\tscope = WINDOW_CUSTOMIZE_GLOBAL_WINDOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (item->scope) {\n\t\t\tcase WINDOW_CUSTOMIZE_NONE:\n\t\t\tcase WINDOW_CUSTOMIZE_KEY:\n\t\t\tcase WINDOW_CUSTOMIZE_SERVER:\n\t\t\tcase WINDOW_CUSTOMIZE_SESSION:\n\t\t\t\tscope = item->scope;\n\t\t\t\tbreak;\n\t\t\tcase WINDOW_CUSTOMIZE_WINDOW:\n\t\t\tcase WINDOW_CUSTOMIZE_PANE:\n\t\t\t\tif (pane)\n\t\t\t\t\tscope = WINDOW_CUSTOMIZE_PANE;\n\t\t\t\telse\n\t\t\t\t\tscope = WINDOW_CUSTOMIZE_WINDOW;\n\t\t\t\tbreak;\n\t\t\tcase WINDOW_CUSTOMIZE_GLOBAL_SESSION:\n\t\t\t\tscope = WINDOW_CUSTOMIZE_SESSION;\n\t\t\t\tbreak;\n\t\t\tcase WINDOW_CUSTOMIZE_GLOBAL_WINDOW:\n\t\t\t\tif (pane)\n\t\t\t\t\tscope = WINDOW_CUSTOMIZE_PANE;\n\t\t\t\telse\n\t\t\t\t\tscope = WINDOW_CUSTOMIZE_WINDOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (scope == item->scope)\n\t\t\too = item->oo;\n\t\telse\n\t\t\too = window_customize_get_tree(scope, &fs);\n\t}\n\n\tif (oe != NULL && oe->type == OPTIONS_TABLE_FLAG) {\n\t\tflag = options_get_number(oo, name);\n\t\toptions_set_number(oo, name, !flag);\n\t} else if (oe != NULL && oe->type == OPTIONS_TABLE_CHOICE) {\n\t\tchoice = options_get_number(oo, name);\n\t\tif (oe->choices[choice + 1] == NULL)\n\t\t\tchoice = 0;\n\t\telse\n\t\t\tchoice++;\n\t\toptions_set_number(oo, name, choice);\n\t} else {\n\t\ttext = window_customize_scope_text(scope, &fs);\n\t\tif (*text != '\\0')\n\t\t\tspace = \", for \";\n\t\telse if (scope != WINDOW_CUSTOMIZE_SERVER)\n\t\t\tspace = \", global\";\n\t\tif (oe != NULL && (oe->flags & OPTIONS_TABLE_IS_ARRAY)) {\n\t\t\tif (idx == -1) {\n\t\t\t\txasprintf(&prompt, \"(%s[+]%s%s) \", name, space,\n\t\t\t\t    text);\n\t\t\t} else {\n\t\t\t\txasprintf(&prompt, \"(%s[%d]%s%s) \", name, idx,\n\t\t\t\t    space, text);\n\t\t\t}\n\t\t} else\n\t\t\txasprintf(&prompt, \"(%s%s%s) \", name, space, text);\n\t\tfree(text);\n\n\t\tvalue = options_to_string(o, idx, 0);\n\n\t\tnew_item = xcalloc(1, sizeof *new_item);\n\t\tnew_item->data = data;\n\t\tnew_item->scope = scope;\n\t\tnew_item->oo = oo;\n\t\tnew_item->name = xstrdup(name);\n\t\tnew_item->idx = idx;\n\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt, value,\n\t\t    window_customize_set_option_callback,\n\t\t    window_customize_free_item_callback, new_item,\n\t\t    PROMPT_NOFORMAT, PROMPT_TYPE_COMMAND);\n\n\t\tfree(prompt);\n\t\tfree(value);\n\t}\n}\n\nstatic void\nwindow_customize_unset_option(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item)\n{\n\tstruct options_entry\t*o;\n\n\tif (item == NULL || !window_customize_check_item(data, item, NULL))\n\t\treturn;\n\n\to = options_get(item->oo, item->name);\n\tif (o == NULL)\n\t\treturn;\n\tif (item->idx != -1 && item == mode_tree_get_current(data->data))\n\t\tmode_tree_up(data->data, 0);\n\toptions_remove_or_default(o, item->idx, NULL);\n}\n\nstatic void\nwindow_customize_reset_option(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item)\n{\n\tstruct options\t\t*oo;\n\tstruct options_entry\t*o;\n\n\tif (item == NULL || !window_customize_check_item(data, item, NULL))\n\t\treturn;\n\tif (item->idx != -1)\n\t\treturn;\n\n\too = item->oo;\n\twhile (oo != NULL) {\n\t\to = options_get_only(item->oo, item->name);\n\t\tif (o != NULL)\n\t\t\toptions_remove_or_default(o, -1, NULL);\n\t\too = options_get_parent(oo);\n\t}\n}\n\nstatic int\nwindow_customize_set_command_callback(struct client *c, void *itemdata,\n    const char *s, __unused int done)\n{\n\tstruct window_customize_itemdata\t*item = itemdata;\n\tstruct window_customize_modedata\t*data = item->data;\n\tstruct key_binding\t\t\t*bd;\n\tstruct cmd_parse_result\t\t\t*pr;\n\tchar\t\t\t\t\t*error;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (item == NULL || !window_customize_get_key(item, NULL, &bd))\n\t\treturn (0);\n\n\tpr = cmd_parse_from_string(s, NULL);\n\tswitch (pr->status) {\n\tcase CMD_PARSE_ERROR:\n\t\terror = pr->error;\n\t\tgoto fail;\n\tcase CMD_PARSE_SUCCESS:\n\t\tbreak;\n\t}\n\tcmd_list_free(bd->cmdlist);\n\tbd->cmdlist = pr->cmdlist;\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n\nfail:\n\t*error = toupper((u_char)*error);\n\tstatus_message_set(c, -1, 1, 0, \"%s\", error);\n\tfree(error);\n\treturn (0);\n}\n\nstatic int\nwindow_customize_set_note_callback(__unused struct client *c, void *itemdata,\n    const char *s, __unused int done)\n{\n\tstruct window_customize_itemdata\t*item = itemdata;\n\tstruct window_customize_modedata\t*data = item->data;\n\tstruct key_binding\t\t\t*bd;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (item == NULL || !window_customize_get_key(item, NULL, &bd))\n\t\treturn (0);\n\n\tfree((void *)bd->note);\n\tbd->note = xstrdup(s);\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n}\n\nstatic void\nwindow_customize_set_key(struct client *c,\n    struct window_customize_modedata *data,\n    struct window_customize_itemdata *item)\n{\n\tkey_code\t\t\t\t key = item->key;\n\tstruct key_binding\t\t\t*bd;\n\tconst char\t\t\t\t*s;\n\tchar\t\t\t\t\t*prompt, *value;\n\tstruct window_customize_itemdata\t*new_item;\n\n\tif (item == NULL || !window_customize_get_key(item, NULL, &bd))\n\t\treturn;\n\n\ts = mode_tree_get_current_name(data->data);\n\tif (strcmp(s, \"Repeat\") == 0)\n\t\tbd->flags ^= KEY_BINDING_REPEAT;\n\telse if (strcmp(s, \"Command\") == 0) {\n\t\txasprintf(&prompt, \"(%s) \", key_string_lookup_key(key, 0));\n\t\tvalue = cmd_list_print(bd->cmdlist, 0);\n\n\t\tnew_item = xcalloc(1, sizeof *new_item);\n\t\tnew_item->data = data;\n\t\tnew_item->scope = item->scope;\n\t\tnew_item->table = xstrdup(item->table);\n\t\tnew_item->key = key;\n\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt, value,\n\t\t    window_customize_set_command_callback,\n\t\t    window_customize_free_item_callback, new_item,\n\t\t    PROMPT_NOFORMAT, PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tfree(value);\n\t} else if (strcmp(s, \"Note\") == 0) {\n\t\txasprintf(&prompt, \"(%s) \", key_string_lookup_key(key, 0));\n\n\t\tnew_item = xcalloc(1, sizeof *new_item);\n\t\tnew_item->data = data;\n\t\tnew_item->scope = item->scope;\n\t\tnew_item->table = xstrdup(item->table);\n\t\tnew_item->key = key;\n\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt,\n\t\t    (bd->note == NULL ? \"\" : bd->note),\n\t\t    window_customize_set_note_callback,\n\t\t    window_customize_free_item_callback, new_item,\n\t\t    PROMPT_NOFORMAT, PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t}\n}\n\nstatic void\nwindow_customize_unset_key(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item)\n{\n\tstruct key_table\t*kt;\n\tstruct key_binding\t*bd;\n\n\tif (item == NULL || !window_customize_get_key(item, &kt, &bd))\n\t\treturn;\n\n\tif (item == mode_tree_get_current(data->data)) {\n\t\tmode_tree_collapse_current(data->data);\n\t\tmode_tree_up(data->data, 0);\n\t}\n\tkey_bindings_remove(kt->name, bd->key);\n}\n\nstatic void\nwindow_customize_reset_key(struct window_customize_modedata *data,\n    struct window_customize_itemdata *item)\n{\n\tstruct key_table\t*kt;\n\tstruct key_binding\t*dd, *bd;\n\n\tif (item == NULL || !window_customize_get_key(item, &kt, &bd))\n\t\treturn;\n\n\tdd = key_bindings_get_default(kt, bd->key);\n\tif (dd != NULL && bd->cmdlist == dd->cmdlist)\n\t\treturn;\n\tif (dd == NULL && item == mode_tree_get_current(data->data)) {\n\t\tmode_tree_collapse_current(data->data);\n\t\tmode_tree_up(data->data, 0);\n\t}\n\tkey_bindings_reset(kt->name, bd->key);\n}\n\nstatic void\nwindow_customize_change_each(void *modedata, void *itemdata,\n    __unused struct client *c, __unused key_code key)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\tstruct window_customize_itemdata\t*item = itemdata;\n\n\tswitch (data->change) {\n\tcase WINDOW_CUSTOMIZE_UNSET:\n\t\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\twindow_customize_unset_key(data, item);\n\t\telse\n\t\t\twindow_customize_unset_option(data, item);\n\t\tbreak;\n\tcase WINDOW_CUSTOMIZE_RESET:\n\t\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\twindow_customize_reset_key(data, item);\n\t\telse\n\t\t\twindow_customize_reset_option(data, item);\n\t\tbreak;\n\t}\n\tif (item->scope != WINDOW_CUSTOMIZE_KEY)\n\t\toptions_push_changes(item->name);\n}\n\nstatic int\nwindow_customize_change_current_callback(__unused struct client *c,\n    void *modedata, const char *s, __unused int done)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\tstruct window_customize_itemdata\t*item;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (tolower((u_char) s[0]) != 'y' || s[1] != '\\0')\n\t\treturn (0);\n\n\titem = mode_tree_get_current(data->data);\n\tswitch (data->change) {\n\tcase WINDOW_CUSTOMIZE_UNSET:\n\t\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\twindow_customize_unset_key(data, item);\n\t\telse\n\t\t\twindow_customize_unset_option(data, item);\n\t\tbreak;\n\tcase WINDOW_CUSTOMIZE_RESET:\n\t\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\twindow_customize_reset_key(data, item);\n\t\telse\n\t\t\twindow_customize_reset_option(data, item);\n\t\tbreak;\n\t}\n\tif (item->scope != WINDOW_CUSTOMIZE_KEY)\n\t\toptions_push_changes(item->name);\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n}\n\nstatic int\nwindow_customize_change_tagged_callback(struct client *c, void *modedata,\n    const char *s, __unused int done)\n{\n\tstruct window_customize_modedata\t*data = modedata;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (tolower((u_char) s[0]) != 'y' || s[1] != '\\0')\n\t\treturn (0);\n\n\tmode_tree_each_tagged(data->data, window_customize_change_each, c,\n\t    KEYC_NONE, 0);\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n\n\treturn (0);\n}\n\nstatic void\nwindow_customize_key(struct window_mode_entry *wme, struct client *c,\n    __unused struct session *s, __unused struct winlink *wl, key_code key,\n    struct mouse_event *m)\n{\n\tstruct window_pane\t\t\t*wp = wme->wp;\n\tstruct window_customize_modedata\t*data = wme->data;\n\tstruct window_customize_itemdata\t*item, *new_item;\n\tint\t\t\t\t\t finished, idx;\n\tchar\t\t\t\t\t*prompt;\n\tu_int\t\t\t\t\t tagged;\n\n\titem = mode_tree_get_current(data->data);\n\tfinished = mode_tree_key(data->data, c, &key, m, NULL, NULL);\n\tif (item != (new_item = mode_tree_get_current(data->data)))\n\t\titem = new_item;\n\n\tswitch (key) {\n\tcase '\\r':\n\tcase 's':\n\t\tif (item == NULL)\n\t\t\tbreak;\n\t\tif (item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\twindow_customize_set_key(c, data, item);\n\t\telse {\n\t\t\twindow_customize_set_option(c, data, item, 0, 1);\n\t\t\toptions_push_changes(item->name);\n\t\t}\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\tcase 'w':\n\t\tif (item == NULL || item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\tbreak;\n\t\twindow_customize_set_option(c, data, item, 0, 0);\n\t\toptions_push_changes(item->name);\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\tcase 'S':\n\tcase 'W':\n\t\tif (item == NULL || item->scope == WINDOW_CUSTOMIZE_KEY)\n\t\t\tbreak;\n\t\twindow_customize_set_option(c, data, item, 1, 0);\n\t\toptions_push_changes(item->name);\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\tcase 'd':\n\t\tif (item == NULL || item->idx != -1)\n\t\t\tbreak;\n\t\txasprintf(&prompt, \"Reset %s to default? \", item->name);\n\t\tdata->references++;\n\t\tdata->change = WINDOW_CUSTOMIZE_RESET;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_customize_change_current_callback,\n\t\t    window_customize_free_callback, data,\n\t\t    PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase 'D':\n\t\ttagged = mode_tree_count_tagged(data->data);\n\t\tif (tagged == 0)\n\t\t\tbreak;\n\t\txasprintf(&prompt, \"Reset %u tagged to default? \", tagged);\n\t\tdata->references++;\n\t\tdata->change = WINDOW_CUSTOMIZE_RESET;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_customize_change_tagged_callback,\n\t\t    window_customize_free_callback, data,\n\t\t    PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase 'u':\n\t\tif (item == NULL)\n\t\t\tbreak;\n\t\tidx = item->idx;\n\t\tif (idx != -1)\n\t\t\txasprintf(&prompt, \"Unset %s[%d]? \", item->name, idx);\n\t\telse\n\t\t\txasprintf(&prompt, \"Unset %s? \", item->name);\n\t\tdata->references++;\n\t\tdata->change = WINDOW_CUSTOMIZE_UNSET;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_customize_change_current_callback,\n\t\t    window_customize_free_callback, data,\n\t\t    PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase 'U':\n\t\ttagged = mode_tree_count_tagged(data->data);\n\t\tif (tagged == 0)\n\t\t\tbreak;\n\t\txasprintf(&prompt, \"Unset %u tagged? \", tagged);\n\t\tdata->references++;\n\t\tdata->change = WINDOW_CUSTOMIZE_UNSET;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_customize_change_tagged_callback,\n\t\t    window_customize_free_callback, data,\n\t\t    PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase 'H':\n\t\tdata->hide_global = !data->hide_global;\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\t}\n\tif (finished)\n\t\twindow_pane_reset_mode(wp);\n\telse {\n\t\tmode_tree_draw(data->data);\n\t\twp->flags |= PANE_REDRAW;\n\t}\n}\n"
        },
        {
          "name": "window-tree.c",
          "type": "blob",
          "size": 31.6533203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2017 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic struct screen\t*window_tree_init(struct window_mode_entry *,\n\t\t\t     struct cmd_find_state *, struct args *);\nstatic void\t\t window_tree_free(struct window_mode_entry *);\nstatic void\t\t window_tree_resize(struct window_mode_entry *, u_int,\n\t\t\t     u_int);\nstatic void\t\t window_tree_update(struct window_mode_entry *);\nstatic void\t\t window_tree_key(struct window_mode_entry *,\n\t\t\t     struct client *, struct session *,\n\t\t\t     struct winlink *, key_code, struct mouse_event *);\n\n#define WINDOW_TREE_DEFAULT_COMMAND \"switch-client -Zt '%%'\"\n\n#define WINDOW_TREE_DEFAULT_FORMAT \\\n\t\"#{?pane_format,\" \\\n\t\t\"#{?pane_marked,#[reverse],}\" \\\n\t\t\"#{pane_current_command}#{?pane_active,*,}#{?pane_marked,M,}\" \\\n\t\t\"#{?#{&&:#{pane_title},#{!=:#{pane_title},#{host_short}}},: \\\"#{pane_title}\\\",}\" \\\n\t\",\" \\\n\t\t\"#{?window_format,\" \\\n\t\t\t\"#{?window_marked_flag,#[reverse],}\" \\\n\t\t\t\"#{window_name}#{window_flags}\" \\\n\t\t\t\"#{?#{&&:#{==:#{window_panes},1},#{&&:#{pane_title},#{!=:#{pane_title},#{host_short}}}},: \\\"#{pane_title}\\\",}\" \\\n\t\t\",\" \\\n\t\t\t\"#{session_windows} windows\" \\\n\t\t\t\"#{?session_grouped, \" \\\n\t\t\t\t\"(group #{session_group}: \" \\\n\t\t\t\t\"#{session_group_list}),\" \\\n\t\t\t\"}\" \\\n\t\t\t\"#{?session_attached, (attached),}\" \\\n\t\t\"}\" \\\n\t\"}\"\n\n#define WINDOW_TREE_DEFAULT_KEY_FORMAT \\\n\t\"#{?#{e|<:#{line},10},\" \\\n\t\t\"#{line}\" \\\n\t\",\" \\\n\t\t\"#{?#{e|<:#{line},36},\"\t\\\n\t        \t\"M-#{a:#{e|+:97,#{e|-:#{line},10}}}\" \\\n\t\t\",\" \\\n\t        \t\"\" \\\n\t\t\"}\" \\\n\t\"}\"\n\nstatic const struct menu_item window_tree_menu_items[] = {\n\t{ \"Select\", '\\r', NULL },\n\t{ \"Expand\", KEYC_RIGHT, NULL },\n\t{ \"Mark\", 'm', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Tag\", 't', NULL },\n\t{ \"Tag All\", '\\024', NULL },\n\t{ \"Tag None\", 'T', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Kill\", 'x', NULL },\n\t{ \"Kill Tagged\", 'X', NULL },\n\t{ \"\", KEYC_NONE, NULL },\n\t{ \"Cancel\", 'q', NULL },\n\n\t{ NULL, KEYC_NONE, NULL }\n};\n\nconst struct window_mode window_tree_mode = {\n\t.name = \"tree-mode\",\n\t.default_format = WINDOW_TREE_DEFAULT_FORMAT,\n\n\t.init = window_tree_init,\n\t.free = window_tree_free,\n\t.resize = window_tree_resize,\n\t.update = window_tree_update,\n\t.key = window_tree_key,\n};\n\nenum window_tree_sort_type {\n\tWINDOW_TREE_BY_INDEX,\n\tWINDOW_TREE_BY_NAME,\n\tWINDOW_TREE_BY_TIME,\n};\nstatic const char *window_tree_sort_list[] = {\n\t\"index\",\n\t\"name\",\n\t\"time\"\n};\nstatic struct mode_tree_sort_criteria *window_tree_sort;\n\nenum window_tree_type {\n\tWINDOW_TREE_NONE,\n\tWINDOW_TREE_SESSION,\n\tWINDOW_TREE_WINDOW,\n\tWINDOW_TREE_PANE,\n};\n\nstruct window_tree_itemdata {\n\tenum window_tree_type\ttype;\n\tint\t\t\tsession;\n\tint\t\t\twinlink;\n\tint\t\t\tpane;\n};\n\nstruct window_tree_modedata {\n\tstruct window_pane\t\t *wp;\n\tint\t\t\t\t  dead;\n\tint\t\t\t\t  references;\n\n\tstruct mode_tree_data\t\t *data;\n\tchar\t\t\t\t *format;\n\tchar\t\t\t\t *key_format;\n\tchar\t\t\t\t *command;\n\tint\t\t\t\t  squash_groups;\n\tint\t\t\t\t  prompt_flags;\n\n\tstruct window_tree_itemdata\t**item_list;\n\tu_int\t\t\t\t  item_size;\n\n\tconst char\t\t\t *entered;\n\n\tstruct cmd_find_state\t\t  fs;\n\tenum window_tree_type\t\t  type;\n\n\tint\t\t\t\t  offset;\n\n\tint\t\t\t\t  left;\n\tint\t\t\t\t  right;\n\tu_int\t\t\t\t  start;\n\tu_int\t\t\t\t  end;\n\tu_int\t\t\t\t  each;\n};\n\nstatic void\nwindow_tree_pull_item(struct window_tree_itemdata *item, struct session **sp,\n    struct winlink **wlp, struct window_pane **wp)\n{\n\t*wp = NULL;\n\t*wlp = NULL;\n\t*sp = session_find_by_id(item->session);\n\tif (*sp == NULL)\n\t\treturn;\n\tif (item->type == WINDOW_TREE_SESSION) {\n\t\t*wlp = (*sp)->curw;\n\t\t*wp = (*wlp)->window->active;\n\t\treturn;\n\t}\n\n\t*wlp = winlink_find_by_index(&(*sp)->windows, item->winlink);\n\tif (*wlp == NULL) {\n\t\t*sp = NULL;\n\t\treturn;\n\t}\n\tif (item->type == WINDOW_TREE_WINDOW) {\n\t\t*wp = (*wlp)->window->active;\n\t\treturn;\n\t}\n\n\t*wp = window_pane_find_by_id(item->pane);\n\tif (!window_has_pane((*wlp)->window, *wp))\n\t\t*wp = NULL;\n\tif (*wp == NULL) {\n\t\t*sp = NULL;\n\t\t*wlp = NULL;\n\t\treturn;\n\t}\n}\n\nstatic struct window_tree_itemdata *\nwindow_tree_add_item(struct window_tree_modedata *data)\n{\n\tstruct window_tree_itemdata\t*item;\n\n\tdata->item_list = xreallocarray(data->item_list, data->item_size + 1,\n\t    sizeof *data->item_list);\n\titem = data->item_list[data->item_size++] = xcalloc(1, sizeof *item);\n\treturn (item);\n}\n\nstatic void\nwindow_tree_free_item(struct window_tree_itemdata *item)\n{\n\tfree(item);\n}\n\nstatic int\nwindow_tree_cmp_session(const void *a0, const void *b0)\n{\n\tconst struct session *const\t*a = a0;\n\tconst struct session *const\t*b = b0;\n\tconst struct session\t\t*sa = *a;\n\tconst struct session\t\t*sb = *b;\n\tint\t\t\t\t result = 0;\n\n\tswitch (window_tree_sort->field) {\n\tcase WINDOW_TREE_BY_INDEX:\n\t\tresult = sa->id - sb->id;\n\t\tbreak;\n\tcase WINDOW_TREE_BY_TIME:\n\t\tif (timercmp(&sa->activity_time, &sb->activity_time, >)) {\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (timercmp(&sa->activity_time, &sb->activity_time, <)) {\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase WINDOW_TREE_BY_NAME:\n\t\tresult = strcmp(sa->name, sb->name);\n\t\tbreak;\n\t}\n\n\tif (window_tree_sort->reversed)\n\t\tresult = -result;\n\treturn (result);\n}\n\nstatic int\nwindow_tree_cmp_window(const void *a0, const void *b0)\n{\n\tconst struct winlink *const\t*a = a0;\n\tconst struct winlink *const\t*b = b0;\n\tconst struct winlink\t\t*wla = *a;\n\tconst struct winlink\t\t*wlb = *b;\n\tstruct window\t\t\t*wa = wla->window;\n\tstruct window\t\t\t*wb = wlb->window;\n\tint\t\t\t\t result = 0;\n\n\tswitch (window_tree_sort->field) {\n\tcase WINDOW_TREE_BY_INDEX:\n\t\tresult = wla->idx - wlb->idx;\n\t\tbreak;\n\tcase WINDOW_TREE_BY_TIME:\n\t\tif (timercmp(&wa->activity_time, &wb->activity_time, >)) {\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (timercmp(&wa->activity_time, &wb->activity_time, <)) {\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase WINDOW_TREE_BY_NAME:\n\t\tresult = strcmp(wa->name, wb->name);\n\t\tbreak;\n\t}\n\n\tif (window_tree_sort->reversed)\n\t\tresult = -result;\n\treturn (result);\n}\n\nstatic int\nwindow_tree_cmp_pane(const void *a0, const void *b0)\n{\n\tstruct window_pane\t**a = (struct window_pane **)a0;\n\tstruct window_pane\t**b = (struct window_pane **)b0;\n\tint\t\t\t  result;\n\tu_int\t\t\t  ai, bi;\n\n\tif (window_tree_sort->field == WINDOW_TREE_BY_TIME)\n\t\tresult = (*a)->active_point - (*b)->active_point;\n\telse {\n\t\t/*\n\t\t * Panes don't have names, so use number order for any other\n\t\t * sort field.\n\t\t */\n\t\twindow_pane_index(*a, &ai);\n\t\twindow_pane_index(*b, &bi);\n\t\tresult = ai - bi;\n\t}\n\tif (window_tree_sort->reversed)\n\t\tresult = -result;\n\treturn (result);\n}\n\nstatic void\nwindow_tree_build_pane(struct session *s, struct winlink *wl,\n    struct window_pane *wp, void *modedata, struct mode_tree_item *parent)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_tree_itemdata\t*item;\n\tchar\t\t\t\t*name, *text;\n\tu_int\t\t\t\t idx;\n\n\twindow_pane_index(wp, &idx);\n\n\titem = window_tree_add_item(data);\n\titem->type = WINDOW_TREE_PANE;\n\titem->session = s->id;\n\titem->winlink = wl->idx;\n\titem->pane = wp->id;\n\n\ttext = format_single(NULL, data->format, NULL, s, wl, wp);\n\txasprintf(&name, \"%u\", idx);\n\n\tmode_tree_add(data->data, parent, item, (uint64_t)wp, name, text, -1);\n\tfree(text);\n\tfree(name);\n}\n\nstatic int\nwindow_tree_filter_pane(struct session *s, struct winlink *wl,\n    struct window_pane *wp, const char *filter)\n{\n\tchar\t*cp;\n\tint\t result;\n\n\tif (filter == NULL)\n\t\treturn (1);\n\n\tcp = format_single(NULL, filter, NULL, s, wl, wp);\n\tresult = format_true(cp);\n\tfree(cp);\n\n\treturn (result);\n}\n\nstatic int\nwindow_tree_build_window(struct session *s, struct winlink *wl,\n    void *modedata, struct mode_tree_sort_criteria *sort_crit,\n    struct mode_tree_item *parent, const char *filter)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_tree_itemdata\t*item;\n\tstruct mode_tree_item\t\t*mti;\n\tchar\t\t\t\t*name, *text;\n\tstruct window_pane\t\t*wp, **l;\n\tu_int\t\t\t\t n, i;\n\tint\t\t\t\t expanded;\n\n\titem = window_tree_add_item(data);\n\titem->type = WINDOW_TREE_WINDOW;\n\titem->session = s->id;\n\titem->winlink = wl->idx;\n\titem->pane = -1;\n\n\ttext = format_single(NULL, data->format, NULL, s, wl, NULL);\n\txasprintf(&name, \"%u\", wl->idx);\n\n\tif (data->type == WINDOW_TREE_SESSION ||\n\t    data->type == WINDOW_TREE_WINDOW)\n\t\texpanded = 0;\n\telse\n\t\texpanded = 1;\n\tmti = mode_tree_add(data->data, parent, item, (uint64_t)wl, name, text,\n\t    expanded);\n\tfree(text);\n\tfree(name);\n\n\tif ((wp = TAILQ_FIRST(&wl->window->panes)) == NULL)\n\t\tgoto empty;\n\tif (TAILQ_NEXT(wp, entry) == NULL) {\n\t\tif (!window_tree_filter_pane(s, wl, wp, filter))\n\t\t\tgoto empty;\n\t\treturn (1);\n\t}\n\n\tl = NULL;\n\tn = 0;\n\n\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\tif (!window_tree_filter_pane(s, wl, wp, filter))\n\t\t\tcontinue;\n\t\tl = xreallocarray(l, n + 1, sizeof *l);\n\t\tl[n++] = wp;\n\t}\n\tif (n == 0)\n\t\tgoto empty;\n\n\twindow_tree_sort = sort_crit;\n\tqsort(l, n, sizeof *l, window_tree_cmp_pane);\n\n\tfor (i = 0; i < n; i++)\n\t\twindow_tree_build_pane(s, wl, l[i], modedata, mti);\n\tfree(l);\n\treturn (1);\n\nempty:\n\twindow_tree_free_item(item);\n\tdata->item_size--;\n\tmode_tree_remove(data->data, mti);\n\treturn (0);\n}\n\nstatic void\nwindow_tree_build_session(struct session *s, void *modedata,\n    struct mode_tree_sort_criteria *sort_crit, const char *filter)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_tree_itemdata\t*item;\n\tstruct mode_tree_item\t\t*mti;\n\tchar\t\t\t\t*text;\n\tstruct winlink\t\t\t*wl, **l;\n\tu_int\t\t\t\t n, i, empty;\n\tint\t\t\t\t expanded;\n\n\titem = window_tree_add_item(data);\n\titem->type = WINDOW_TREE_SESSION;\n\titem->session = s->id;\n\titem->winlink = -1;\n\titem->pane = -1;\n\n\ttext = format_single(NULL, data->format, NULL, s, NULL, NULL);\n\n\tif (data->type == WINDOW_TREE_SESSION)\n\t\texpanded = 0;\n\telse\n\t\texpanded = 1;\n\tmti = mode_tree_add(data->data, NULL, item, (uint64_t)s, s->name, text,\n\t    expanded);\n\tfree(text);\n\n\tl = NULL;\n\tn = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tl = xreallocarray(l, n + 1, sizeof *l);\n\t\tl[n++] = wl;\n\t}\n\twindow_tree_sort = sort_crit;\n\tqsort(l, n, sizeof *l, window_tree_cmp_window);\n\n\tempty = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (!window_tree_build_window(s, l[i], modedata, sort_crit, mti,\n\t\t    filter))\n\t\t\tempty++;\n\t}\n\tif (empty == n) {\n\t\twindow_tree_free_item(item);\n\t\tdata->item_size--;\n\t\tmode_tree_remove(data->data, mti);\n\t}\n\tfree(l);\n}\n\nstatic void\nwindow_tree_build(void *modedata, struct mode_tree_sort_criteria *sort_crit,\n    uint64_t *tag, const char *filter)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct session\t\t\t*s, **l;\n\tstruct session_group\t\t*sg, *current;\n\tu_int\t\t\t\t n, i;\n\n\tcurrent = session_group_contains(data->fs.s);\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_tree_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\tdata->item_list = NULL;\n\tdata->item_size = 0;\n\n\tl = NULL;\n\tn = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (data->squash_groups &&\n\t\t    (sg = session_group_contains(s)) != NULL) {\n\t\t\tif ((sg == current && s != data->fs.s) ||\n\t\t\t    (sg != current && s != TAILQ_FIRST(&sg->sessions)))\n\t\t\t\tcontinue;\n\t\t}\n\t\tl = xreallocarray(l, n + 1, sizeof *l);\n\t\tl[n++] = s;\n\t}\n\twindow_tree_sort = sort_crit;\n\tqsort(l, n, sizeof *l, window_tree_cmp_session);\n\n\tfor (i = 0; i < n; i++)\n\t\twindow_tree_build_session(l[i], modedata, sort_crit, filter);\n\tfree(l);\n\n\tswitch (data->type) {\n\tcase WINDOW_TREE_NONE:\n\t\tbreak;\n\tcase WINDOW_TREE_SESSION:\n\t\t*tag = (uint64_t)data->fs.s;\n\t\tbreak;\n\tcase WINDOW_TREE_WINDOW:\n\t\t*tag = (uint64_t)data->fs.wl;\n\t\tbreak;\n\tcase WINDOW_TREE_PANE:\n\t\tif (window_count_panes(data->fs.wl->window) == 1)\n\t\t\t*tag = (uint64_t)data->fs.wl;\n\t\telse\n\t\t\t*tag = (uint64_t)data->fs.wp;\n\t\tbreak;\n\t}\n}\n\nstatic void\nwindow_tree_draw_label(struct screen_write_ctx *ctx, u_int px, u_int py,\n    u_int sx, u_int sy, const struct grid_cell *gc, const char *label)\n{\n\tsize_t\t len;\n\tu_int\t ox, oy;\n\n\tlen = strlen(label);\n\tif (sx == 0 || sy == 1 || len > sx)\n\t\treturn;\n\tox = (sx - len + 1) / 2;\n\toy = (sy + 1) / 2;\n\n\tif (ox > 1 && ox + len < sx - 1 && sy >= 3) {\n\t\tscreen_write_cursormove(ctx, px + ox - 1, py + oy - 1, 0);\n\t\tscreen_write_box(ctx, len + 2, 3, BOX_LINES_DEFAULT, NULL,\n\t\t    NULL);\n\t}\n\tscreen_write_cursormove(ctx, px + ox, py + oy, 0);\n\tscreen_write_puts(ctx, gc, \"%s\", label);\n}\n\nstatic void\nwindow_tree_draw_session(struct window_tree_modedata *data, struct session *s,\n    struct screen_write_ctx *ctx, u_int sx, u_int sy)\n{\n\tstruct options\t\t*oo = s->options;\n\tstruct winlink\t\t*wl;\n\tstruct window\t\t*w;\n\tu_int\t\t\t cx = ctx->s->cx, cy = ctx->s->cy;\n\tu_int\t\t\t loop, total, visible, each, width, offset;\n\tu_int\t\t\t current, start, end, remaining, i;\n\tstruct grid_cell\t gc;\n\tint\t\t\t colour, active_colour, left, right;\n\tchar\t\t\t*label;\n\n\ttotal = winlink_count(&s->windows);\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tcolour = options_get_number(oo, \"display-panes-colour\");\n\tactive_colour = options_get_number(oo, \"display-panes-active-colour\");\n\n\tif (sx / total < 24) {\n\t\tvisible = sx / 24;\n\t\tif (visible == 0)\n\t\t\tvisible = 1;\n\t} else\n\t\tvisible = total;\n\n\tcurrent = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (wl == s->curw)\n\t\t\tbreak;\n\t\tcurrent++;\n\t}\n\n\tif (current < visible) {\n\t\tstart = 0;\n\t\tend = visible;\n\t} else if (current >= total - visible) {\n\t\tstart = total - visible;\n\t\tend = total;\n\t} else {\n\t\tstart = current - (visible / 2);\n\t\tend = start + visible;\n\t}\n\n\tif (data->offset < -(int)start)\n\t\tdata->offset = -(int)start;\n\tif (data->offset > (int)(total - end))\n\t\tdata->offset = (int)(total - end);\n\tstart += data->offset;\n\tend += data->offset;\n\n\tleft = (start != 0);\n\tright = (end != total);\n\tif (((left && right) && sx <= 6) || ((left || right) && sx <= 3))\n\t\tleft = right = 0;\n\tif (left && right) {\n\t\teach = (sx - 6) / visible;\n\t\tremaining = (sx - 6) - (visible * each);\n\t} else if (left || right) {\n\t\teach = (sx - 3) / visible;\n\t\tremaining = (sx - 3) - (visible * each);\n\t} else {\n\t\teach = sx / visible;\n\t\tremaining = sx - (visible * each);\n\t}\n\tif (each == 0)\n\t\treturn;\n\n\tif (left) {\n\t\tdata->left = cx + 2;\n\t\tscreen_write_cursormove(ctx, cx + 2, cy, 0);\n\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\tscreen_write_cursormove(ctx, cx, cy + sy / 2, 0);\n\t\tscreen_write_puts(ctx, &grid_default_cell, \"<\");\n\t} else\n\t\tdata->left = -1;\n\tif (right) {\n\t\tdata->right = cx + sx - 3;\n\t\tscreen_write_cursormove(ctx, cx + sx - 3, cy, 0);\n\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\tscreen_write_cursormove(ctx, cx + sx - 1, cy + sy / 2, 0);\n\t\tscreen_write_puts(ctx, &grid_default_cell, \">\");\n\t} else\n\t\tdata->right = -1;\n\n\tdata->start = start;\n\tdata->end = end;\n\tdata->each = each;\n\n\ti = loop = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (loop == end)\n\t\t\tbreak;\n\t\tif (loop < start) {\n\t\t\tloop++;\n\t\t\tcontinue;\n\t\t}\n\t\tw = wl->window;\n\n\t\tif (wl == s->curw)\n\t\t\tgc.fg = active_colour;\n\t\telse\n\t\t\tgc.fg = colour;\n\n\t\tif (left)\n\t\t\toffset = 3 + (i * each);\n\t\telse\n\t\t\toffset = (i * each);\n\t\tif (loop == end - 1)\n\t\t\twidth = each + remaining;\n\t\telse\n\t\t\twidth = each - 1;\n\n\t\tscreen_write_cursormove(ctx, cx + offset, cy, 0);\n\t\tscreen_write_preview(ctx, &w->active->base, width, sy);\n\n\t\txasprintf(&label, \" %u:%s \", wl->idx, w->name);\n\t\tif (strlen(label) > width)\n\t\t\txasprintf(&label, \" %u \", wl->idx);\n\t\twindow_tree_draw_label(ctx, cx + offset, cy, width, sy, &gc,\n\t\t    label);\n\t\tfree(label);\n\n\t\tif (loop != end - 1) {\n\t\t\tscreen_write_cursormove(ctx, cx + offset + width, cy, 0);\n\t\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\t}\n\t\tloop++;\n\n\t\ti++;\n\t}\n}\n\nstatic void\nwindow_tree_draw_window(struct window_tree_modedata *data, struct session *s,\n    struct window *w, struct screen_write_ctx *ctx, u_int sx, u_int sy)\n{\n\tstruct options\t\t*oo = s->options;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t cx = ctx->s->cx, cy = ctx->s->cy;\n\tu_int\t\t\t loop, total, visible, each, width, offset;\n\tu_int\t\t\t current, start, end, remaining, i, pane_idx;\n\tstruct grid_cell\t gc;\n\tint\t\t\t colour, active_colour, left, right;\n\tchar\t\t\t*label;\n\n\ttotal = window_count_panes(w);\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tcolour = options_get_number(oo, \"display-panes-colour\");\n\tactive_colour = options_get_number(oo, \"display-panes-active-colour\");\n\n\tif (sx / total < 24) {\n\t\tvisible = sx / 24;\n\t\tif (visible == 0)\n\t\t\tvisible = 1;\n\t} else\n\t\tvisible = total;\n\n\tcurrent = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (wp == w->active)\n\t\t\tbreak;\n\t\tcurrent++;\n\t}\n\n\tif (current < visible) {\n\t\tstart = 0;\n\t\tend = visible;\n\t} else if (current >= total - visible) {\n\t\tstart = total - visible;\n\t\tend = total;\n\t} else {\n\t\tstart = current - (visible / 2);\n\t\tend = start + visible;\n\t}\n\n\tif (data->offset < -(int)start)\n\t\tdata->offset = -(int)start;\n\tif (data->offset > (int)(total - end))\n\t\tdata->offset = (int)(total - end);\n\tstart += data->offset;\n\tend += data->offset;\n\n\tleft = (start != 0);\n\tright = (end != total);\n\tif (((left && right) && sx <= 6) || ((left || right) && sx <= 3))\n\t\tleft = right = 0;\n\tif (left && right) {\n\t\teach = (sx - 6) / visible;\n\t\tremaining = (sx - 6) - (visible * each);\n\t} else if (left || right) {\n\t\teach = (sx - 3) / visible;\n\t\tremaining = (sx - 3) - (visible * each);\n\t} else {\n\t\teach = sx / visible;\n\t\tremaining = sx - (visible * each);\n\t}\n\tif (each == 0)\n\t\treturn;\n\n\tif (left) {\n\t\tdata->left = cx + 2;\n\t\tscreen_write_cursormove(ctx, cx + 2, cy, 0);\n\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\tscreen_write_cursormove(ctx, cx, cy + sy / 2, 0);\n\t\tscreen_write_puts(ctx, &grid_default_cell, \"<\");\n\t} else\n\t\tdata->left = -1;\n\tif (right) {\n\t\tdata->right = cx + sx - 3;\n\t\tscreen_write_cursormove(ctx, cx + sx - 3, cy, 0);\n\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\tscreen_write_cursormove(ctx, cx + sx - 1, cy + sy / 2, 0);\n\t\tscreen_write_puts(ctx, &grid_default_cell, \">\");\n\t} else\n\t\tdata->right = -1;\n\n\tdata->start = start;\n\tdata->end = end;\n\tdata->each = each;\n\n\ti = loop = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (loop == end)\n\t\t\tbreak;\n\t\tif (loop < start) {\n\t\t\tloop++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wp == w->active)\n\t\t\tgc.fg = active_colour;\n\t\telse\n\t\t\tgc.fg = colour;\n\n\t\tif (left)\n\t\t\toffset = 3 + (i * each);\n\t\telse\n\t\t\toffset = (i * each);\n\t\tif (loop == end - 1)\n\t\t\twidth = each + remaining;\n\t\telse\n\t\t\twidth = each - 1;\n\n\t\tscreen_write_cursormove(ctx, cx + offset, cy, 0);\n\t\tscreen_write_preview(ctx, &wp->base, width, sy);\n\n\t\tif (window_pane_index(wp, &pane_idx) != 0)\n\t\t\tpane_idx = loop;\n\t\txasprintf(&label, \" %u \", pane_idx);\n\t\twindow_tree_draw_label(ctx, cx + offset, cy, each, sy, &gc,\n\t\t    label);\n\t\tfree(label);\n\n\t\tif (loop != end - 1) {\n\t\t\tscreen_write_cursormove(ctx, cx + offset + width, cy, 0);\n\t\t\tscreen_write_vline(ctx, sy, 0, 0);\n\t\t}\n\t\tloop++;\n\n\t\ti++;\n\t}\n}\n\nstatic void\nwindow_tree_draw(void *modedata, void *itemdata, struct screen_write_ctx *ctx,\n    u_int sx, u_int sy)\n{\n\tstruct window_tree_itemdata\t*item = itemdata;\n\tstruct session\t\t\t*sp;\n\tstruct winlink\t\t\t*wlp;\n\tstruct window_pane\t\t*wp;\n\n\twindow_tree_pull_item(item, &sp, &wlp, &wp);\n\tif (wp == NULL)\n\t\treturn;\n\n\tswitch (item->type) {\n\tcase WINDOW_TREE_NONE:\n\t\tbreak;\n\tcase WINDOW_TREE_SESSION:\n\t\twindow_tree_draw_session(modedata, sp, ctx, sx, sy);\n\t\tbreak;\n\tcase WINDOW_TREE_WINDOW:\n\t\twindow_tree_draw_window(modedata, sp, wlp->window, ctx, sx, sy);\n\t\tbreak;\n\tcase WINDOW_TREE_PANE:\n\t\tscreen_write_preview(ctx, &wp->base, sx, sy);\n\t\tbreak;\n\t}\n}\n\nstatic int\nwindow_tree_search(__unused void *modedata, void *itemdata, const char *ss)\n{\n\tstruct window_tree_itemdata\t*item = itemdata;\n\tstruct session\t\t\t*s;\n\tstruct winlink\t\t\t*wl;\n\tstruct window_pane\t\t*wp;\n\tchar\t\t\t\t*cmd;\n\tint\t\t\t\t retval;\n\n\twindow_tree_pull_item(item, &s, &wl, &wp);\n\n\tswitch (item->type) {\n\tcase WINDOW_TREE_NONE:\n\t\treturn (0);\n\tcase WINDOW_TREE_SESSION:\n\t\tif (s == NULL)\n\t\t\treturn (0);\n\t\treturn (strstr(s->name, ss) != NULL);\n\tcase WINDOW_TREE_WINDOW:\n\t\tif (s == NULL || wl == NULL)\n\t\t\treturn (0);\n\t\treturn (strstr(wl->window->name, ss) != NULL);\n\tcase WINDOW_TREE_PANE:\n\t\tif (s == NULL || wl == NULL || wp == NULL)\n\t\t\tbreak;\n\t\tcmd = osdep_get_name(wp->fd, wp->tty);\n\t\tif (cmd == NULL || *cmd == '\\0')\n\t\t\treturn (0);\n\t\tretval = (strstr(cmd, ss) != NULL);\n\t\tfree(cmd);\n\t\treturn (retval);\n\t}\n\treturn (0);\n}\n\nstatic void\nwindow_tree_menu(void *modedata, struct client *c, key_code key)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_pane\t\t*wp = data->wp;\n\tstruct window_mode_entry\t*wme;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme == NULL || wme->data != modedata)\n\t\treturn;\n\twindow_tree_key(wme, c, NULL, NULL, key, NULL);\n}\n\nstatic key_code\nwindow_tree_get_key(void *modedata, void *itemdata, u_int line)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_tree_itemdata\t*item = itemdata;\n\tstruct format_tree\t\t*ft;\n\tstruct session\t\t\t*s;\n\tstruct winlink\t\t\t*wl;\n\tstruct window_pane\t\t*wp;\n\tchar\t\t\t\t*expanded;\n\tkey_code\t\t\t key;\n\n\tft = format_create(NULL, NULL, FORMAT_NONE, 0);\n\twindow_tree_pull_item(item, &s, &wl, &wp);\n\tif (item->type == WINDOW_TREE_SESSION)\n\t\tformat_defaults(ft, NULL, s, NULL, NULL);\n\telse if (item->type == WINDOW_TREE_WINDOW)\n\t\tformat_defaults(ft, NULL, s, wl, NULL);\n\telse\n\t\tformat_defaults(ft, NULL, s, wl, wp);\n\tformat_add(ft, \"line\", \"%u\", line);\n\n\texpanded = format_expand(ft, data->key_format);\n\tkey = key_string_lookup_string(expanded);\n\tfree(expanded);\n\tformat_free(ft);\n\treturn (key);\n}\n\nstatic struct screen *\nwindow_tree_init(struct window_mode_entry *wme, struct cmd_find_state *fs,\n    struct args *args)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_tree_modedata\t*data;\n\tstruct screen\t\t\t*s;\n\n\twme->data = data = xcalloc(1, sizeof *data);\n\tdata->wp = wp;\n\tdata->references = 1;\n\n\tif (args_has(args, 's'))\n\t\tdata->type = WINDOW_TREE_SESSION;\n\telse if (args_has(args, 'w'))\n\t\tdata->type = WINDOW_TREE_WINDOW;\n\telse\n\t\tdata->type = WINDOW_TREE_PANE;\n\tmemcpy(&data->fs, fs, sizeof data->fs);\n\n\tif (args == NULL || !args_has(args, 'F'))\n\t\tdata->format = xstrdup(WINDOW_TREE_DEFAULT_FORMAT);\n\telse\n\t\tdata->format = xstrdup(args_get(args, 'F'));\n\tif (args == NULL || !args_has(args, 'K'))\n\t\tdata->key_format = xstrdup(WINDOW_TREE_DEFAULT_KEY_FORMAT);\n\telse\n\t\tdata->key_format = xstrdup(args_get(args, 'K'));\n\tif (args == NULL || args_count(args) == 0)\n\t\tdata->command = xstrdup(WINDOW_TREE_DEFAULT_COMMAND);\n\telse\n\t\tdata->command = xstrdup(args_string(args, 0));\n\tdata->squash_groups = !args_has(args, 'G');\n\tif (args_has(args, 'y'))\n\t\tdata->prompt_flags = PROMPT_ACCEPT;\n\n\tdata->data = mode_tree_start(wp, args, window_tree_build,\n\t    window_tree_draw, window_tree_search, window_tree_menu, NULL,\n\t    window_tree_get_key, data, window_tree_menu_items,\n\t    window_tree_sort_list, nitems(window_tree_sort_list), &s);\n\tmode_tree_zoom(data->data, args);\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\n\tdata->type = WINDOW_TREE_NONE;\n\n\treturn (s);\n}\n\nstatic void\nwindow_tree_destroy(struct window_tree_modedata *data)\n{\n\tu_int\ti;\n\n\tif (--data->references != 0)\n\t\treturn;\n\n\tfor (i = 0; i < data->item_size; i++)\n\t\twindow_tree_free_item(data->item_list[i]);\n\tfree(data->item_list);\n\n\tfree(data->format);\n\tfree(data->key_format);\n\tfree(data->command);\n\n\tfree(data);\n}\n\nstatic void\nwindow_tree_free(struct window_mode_entry *wme)\n{\n\tstruct window_tree_modedata *data = wme->data;\n\n\tif (data == NULL)\n\t\treturn;\n\n\tdata->dead = 1;\n\tmode_tree_free(data->data);\n\twindow_tree_destroy(data);\n}\n\nstatic void\nwindow_tree_resize(struct window_mode_entry *wme, u_int sx, u_int sy)\n{\n\tstruct window_tree_modedata\t*data = wme->data;\n\n\tmode_tree_resize(data->data, sx, sy);\n}\n\nstatic void\nwindow_tree_update(struct window_mode_entry *wme)\n{\n\tstruct window_tree_modedata\t*data = wme->data;\n\n\tmode_tree_build(data->data);\n\tmode_tree_draw(data->data);\n\tdata->wp->flags |= PANE_REDRAW;\n}\n\nstatic char *\nwindow_tree_get_target(struct window_tree_itemdata *item,\n    struct cmd_find_state *fs)\n{\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tchar\t\t\t*target;\n\n\twindow_tree_pull_item(item, &s, &wl, &wp);\n\n\ttarget = NULL;\n\tswitch (item->type) {\n\tcase WINDOW_TREE_NONE:\n\t\tbreak;\n\tcase WINDOW_TREE_SESSION:\n\t\tif (s == NULL)\n\t\t\tbreak;\n\t\txasprintf(&target, \"=%s:\", s->name);\n\t\tbreak;\n\tcase WINDOW_TREE_WINDOW:\n\t\tif (s == NULL || wl == NULL)\n\t\t\tbreak;\n\t\txasprintf(&target, \"=%s:%u.\", s->name, wl->idx);\n\t\tbreak;\n\tcase WINDOW_TREE_PANE:\n\t\tif (s == NULL || wl == NULL || wp == NULL)\n\t\t\tbreak;\n\t\txasprintf(&target, \"=%s:%u.%%%u\", s->name, wl->idx, wp->id);\n\t\tbreak;\n\t}\n\tif (target == NULL)\n\t\tcmd_find_clear_state(fs, 0);\n\telse\n\t\tcmd_find_from_winlink_pane(fs, wl, wp, 0);\n\treturn (target);\n}\n\nstatic void\nwindow_tree_command_each(void *modedata, void *itemdata, struct client *c,\n    __unused key_code key)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct window_tree_itemdata\t*item = itemdata;\n\tchar\t\t\t\t*name;\n\tstruct cmd_find_state\t\t fs;\n\n\tname = window_tree_get_target(item, &fs);\n\tif (name != NULL)\n\t\tmode_tree_run_command(c, &fs, data->entered, name);\n\tfree(name);\n}\n\nstatic enum cmd_retval\nwindow_tree_command_done(__unused struct cmdq_item *item, void *modedata)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\n\tif (!data->dead) {\n\t\tmode_tree_build(data->data);\n\t\tmode_tree_draw(data->data);\n\t\tdata->wp->flags |= PANE_REDRAW;\n\t}\n\twindow_tree_destroy(data);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nstatic int\nwindow_tree_command_callback(struct client *c, void *modedata, const char *s,\n    __unused int done)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\n\tdata->entered = s;\n\tmode_tree_each_tagged(data->data, window_tree_command_each, c,\n\t    KEYC_NONE, 1);\n\tdata->entered = NULL;\n\n\tdata->references++;\n\tcmdq_append(c, cmdq_get_callback(window_tree_command_done, data));\n\n\treturn (0);\n}\n\nstatic void\nwindow_tree_command_free(void *modedata)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\n\twindow_tree_destroy(data);\n}\n\nstatic void\nwindow_tree_kill_each(__unused void *modedata, void *itemdata,\n    __unused struct client *c, __unused key_code key)\n{\n\tstruct window_tree_itemdata\t*item = itemdata;\n\tstruct session\t\t\t*s;\n\tstruct winlink\t\t\t*wl;\n\tstruct window_pane\t\t*wp;\n\n\twindow_tree_pull_item(item, &s, &wl, &wp);\n\n\tswitch (item->type) {\n\tcase WINDOW_TREE_NONE:\n\t\tbreak;\n\tcase WINDOW_TREE_SESSION:\n\t\tif (s != NULL) {\n\t\t\tserver_destroy_session(s);\n\t\t\tsession_destroy(s, 1, __func__);\n\t\t}\n\t\tbreak;\n\tcase WINDOW_TREE_WINDOW:\n\t\tif (wl != NULL)\n\t\t\tserver_kill_window(wl->window, 0);\n\t\tbreak;\n\tcase WINDOW_TREE_PANE:\n\t\tif (wp != NULL)\n\t\t\tserver_kill_pane(wp);\n\t\tbreak;\n\t}\n}\n\nstatic int\nwindow_tree_kill_current_callback(struct client *c, void *modedata,\n    const char *s, __unused int done)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct mode_tree_data\t\t*mtd = data->data;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (tolower((u_char) s[0]) != 'y' || s[1] != '\\0')\n\t\treturn (0);\n\n\twindow_tree_kill_each(data, mode_tree_get_current(mtd), c, KEYC_NONE);\n\tserver_renumber_all();\n\n\tdata->references++;\n\tcmdq_append(c, cmdq_get_callback(window_tree_command_done, data));\n\n\treturn (0);\n}\n\nstatic int\nwindow_tree_kill_tagged_callback(struct client *c, void *modedata,\n    const char *s, __unused int done)\n{\n\tstruct window_tree_modedata\t*data = modedata;\n\tstruct mode_tree_data\t\t*mtd = data->data;\n\n\tif (s == NULL || *s == '\\0' || data->dead)\n\t\treturn (0);\n\tif (tolower((u_char) s[0]) != 'y' || s[1] != '\\0')\n\t\treturn (0);\n\n\tmode_tree_each_tagged(mtd, window_tree_kill_each, c, KEYC_NONE, 1);\n\tserver_renumber_all();\n\n\tdata->references++;\n\tcmdq_append(c, cmdq_get_callback(window_tree_command_done, data));\n\n\treturn (0);\n}\n\nstatic key_code\nwindow_tree_mouse(struct window_tree_modedata *data, key_code key, u_int x,\n    struct window_tree_itemdata *item)\n{\n\tstruct session\t\t*s;\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t loop;\n\n\tif (key != KEYC_MOUSEDOWN1_PANE)\n\t\treturn (KEYC_NONE);\n\n\tif (data->left != -1 && x <= (u_int)data->left)\n\t\treturn ('<');\n\tif (data->right != -1 && x >= (u_int)data->right)\n\t\treturn ('>');\n\n\tif (data->left != -1)\n\t\tx -= data->left;\n\telse if (x != 0)\n\t\tx--;\n\tif (x == 0 || data->end == 0)\n\t\tx = 0;\n\telse {\n\t\tx = x / data->each;\n\t\tif (data->start + x >= data->end)\n\t\t\tx = data->end - 1;\n\t}\n\n\twindow_tree_pull_item(item, &s, &wl, &wp);\n\tif (item->type == WINDOW_TREE_SESSION) {\n\t\tif (s == NULL)\n\t\t\treturn (KEYC_NONE);\n\t\tmode_tree_expand_current(data->data);\n\t\tloop = 0;\n\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\tif (loop == data->start + x)\n\t\t\t\tbreak;\n\t\t\tloop++;\n\t\t}\n\t\tif (wl != NULL)\n\t\t\tmode_tree_set_current(data->data, (uint64_t)wl);\n\t\treturn ('\\r');\n\t}\n\tif (item->type == WINDOW_TREE_WINDOW) {\n\t\tif (wl == NULL)\n\t\t\treturn (KEYC_NONE);\n\t\tmode_tree_expand_current(data->data);\n\t\tloop = 0;\n\t\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\t\tif (loop == data->start + x)\n\t\t\t\tbreak;\n\t\t\tloop++;\n\t\t}\n\t\tif (wp != NULL)\n\t\t\tmode_tree_set_current(data->data, (uint64_t)wp);\n\t\treturn ('\\r');\n\t}\n\treturn (KEYC_NONE);\n}\n\nstatic void\nwindow_tree_key(struct window_mode_entry *wme, struct client *c,\n    __unused struct session *s, __unused struct winlink *wl, key_code key,\n    struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp = wme->wp;\n\tstruct window_tree_modedata\t*data = wme->data;\n\tstruct window_tree_itemdata\t*item, *new_item;\n\tchar\t\t\t\t*name, *prompt = NULL;\n\tstruct cmd_find_state\t\t fs, *fsp = &data->fs;\n\tint\t\t\t\t finished;\n\tu_int\t\t\t\t tagged, x, y, idx;\n\tstruct session\t\t\t*ns;\n\tstruct winlink\t\t\t*nwl;\n\tstruct window_pane\t\t*nwp;\n\n\titem = mode_tree_get_current(data->data);\n\tfinished = mode_tree_key(data->data, c, &key, m, &x, &y);\n\nagain:\n\tif (item != (new_item = mode_tree_get_current(data->data))) {\n\t\titem = new_item;\n\t\tdata->offset = 0;\n\t}\n\tif (KEYC_IS_MOUSE(key) && m != NULL) {\n\t\tkey = window_tree_mouse(data, key, x, item);\n\t\tgoto again;\n\t}\n\n\tswitch (key) {\n\tcase '<':\n\t\tdata->offset--;\n\t\tbreak;\n\tcase '>':\n\t\tdata->offset++;\n\t\tbreak;\n\tcase 'H':\n\t\tmode_tree_expand(data->data, (uint64_t)fsp->s);\n\t\tmode_tree_expand(data->data, (uint64_t)fsp->wl);\n\t\tif (!mode_tree_set_current(data->data, (uint64_t)wme->wp))\n\t\t\tmode_tree_set_current(data->data, (uint64_t)fsp->wl);\n\t\tbreak;\n\tcase 'm':\n\t\twindow_tree_pull_item(item, &ns, &nwl, &nwp);\n\t\tserver_set_marked(ns, nwl, nwp);\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\tcase 'M':\n\t\tserver_clear_marked();\n\t\tmode_tree_build(data->data);\n\t\tbreak;\n\tcase 'x':\n\t\twindow_tree_pull_item(item, &ns, &nwl, &nwp);\n\t\tswitch (item->type) {\n\t\tcase WINDOW_TREE_NONE:\n\t\t\tbreak;\n\t\tcase WINDOW_TREE_SESSION:\n\t\t\tif (ns == NULL)\n\t\t\t\tbreak;\n\t\t\txasprintf(&prompt, \"Kill session %s? \", ns->name);\n\t\t\tbreak;\n\t\tcase WINDOW_TREE_WINDOW:\n\t\t\tif (nwl == NULL)\n\t\t\t\tbreak;\n\t\t\txasprintf(&prompt, \"Kill window %u? \", nwl->idx);\n\t\t\tbreak;\n\t\tcase WINDOW_TREE_PANE:\n\t\t\tif (nwp == NULL || window_pane_index(nwp, &idx) != 0)\n\t\t\t\tbreak;\n\t\t\txasprintf(&prompt, \"Kill pane %u? \", idx);\n\t\t\tbreak;\n\t\t}\n\t\tif (prompt == NULL)\n\t\t\tbreak;\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_tree_kill_current_callback, window_tree_command_free,\n\t\t    data, PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase 'X':\n\t\ttagged = mode_tree_count_tagged(data->data);\n\t\tif (tagged == 0)\n\t\t\tbreak;\n\t\txasprintf(&prompt, \"Kill %u tagged? \", tagged);\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_tree_kill_tagged_callback, window_tree_command_free,\n\t\t    data, PROMPT_SINGLE|PROMPT_NOFORMAT|data->prompt_flags,\n\t\t    PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase ':':\n\t\ttagged = mode_tree_count_tagged(data->data);\n\t\tif (tagged != 0)\n\t\t\txasprintf(&prompt, \"(%u tagged) \", tagged);\n\t\telse\n\t\t\txasprintf(&prompt, \"(current) \");\n\t\tdata->references++;\n\t\tstatus_prompt_set(c, NULL, prompt, \"\",\n\t\t    window_tree_command_callback, window_tree_command_free,\n\t\t    data, PROMPT_NOFORMAT, PROMPT_TYPE_COMMAND);\n\t\tfree(prompt);\n\t\tbreak;\n\tcase '\\r':\n\t\tname = window_tree_get_target(item, &fs);\n\t\tif (name != NULL)\n\t\t\tmode_tree_run_command(c, NULL, data->command, name);\n\t\tfinished = 1;\n\t\tfree(name);\n\t\tbreak;\n\t}\n\tif (finished)\n\t\twindow_pane_reset_mode(wp);\n\telse {\n\t\tmode_tree_draw(data->data);\n\t\twp->flags |= PANE_REDRAW;\n\t}\n}\n"
        },
        {
          "name": "window.c",
          "type": "blob",
          "size": 37.43359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <fnmatch.h>\n#include <regex.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Each window is attached to a number of panes, each of which is a pty. This\n * file contains code to handle them.\n *\n * A pane has two buffers attached, these are filled and emptied by the main\n * server poll loop. Output data is received from pty's in screen format,\n * translated and returned as a series of escape sequences and strings via\n * input_parse (in input.c). Input data is received as key codes and written\n * directly via input_key.\n *\n * Each pane also has a \"virtual\" screen (screen.c) which contains the current\n * state and is redisplayed when the window is reattached to a client.\n *\n * Windows are stored directly on a global array and wrapped in any number of\n * winlink structs to be linked onto local session RB trees. A reference count\n * is maintained and a window removed from the global list and destroyed when\n * it reaches zero.\n */\n\n/* Global window list. */\nstruct windows windows;\n\n/* Global panes tree. */\nstruct window_pane_tree all_window_panes;\nstatic u_int\tnext_window_pane_id;\nstatic u_int\tnext_window_id;\nstatic u_int\tnext_active_point;\n\nstruct window_pane_input_data {\n\tstruct cmdq_item\t*item;\n\tu_int\t\t\t wp;\n\tstruct client_file\t*file;\n};\n\nstatic struct window_pane *window_pane_create(struct window *, u_int, u_int,\n\t\t    u_int);\nstatic void\twindow_pane_destroy(struct window_pane *);\n\nRB_GENERATE(windows, window, entry, window_cmp);\nRB_GENERATE(winlinks, winlink, entry, winlink_cmp);\nRB_GENERATE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);\n\nint\nwindow_cmp(struct window *w1, struct window *w2)\n{\n\treturn (w1->id - w2->id);\n}\n\nint\nwinlink_cmp(struct winlink *wl1, struct winlink *wl2)\n{\n\treturn (wl1->idx - wl2->idx);\n}\n\nint\nwindow_pane_cmp(struct window_pane *wp1, struct window_pane *wp2)\n{\n\treturn (wp1->id - wp2->id);\n}\n\nstruct winlink *\nwinlink_find_by_window(struct winlinks *wwl, struct window *w)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, wwl) {\n\t\tif (wl->window == w)\n\t\t\treturn (wl);\n\t}\n\n\treturn (NULL);\n}\n\nstruct winlink *\nwinlink_find_by_index(struct winlinks *wwl, int idx)\n{\n\tstruct winlink\twl;\n\n\tif (idx < 0)\n\t\tfatalx(\"bad index\");\n\n\twl.idx = idx;\n\treturn (RB_FIND(winlinks, wwl, &wl));\n}\n\nstruct winlink *\nwinlink_find_by_window_id(struct winlinks *wwl, u_int id)\n{\n\tstruct winlink *wl;\n\n\tRB_FOREACH(wl, winlinks, wwl) {\n\t\tif (wl->window->id == id)\n\t\t\treturn (wl);\n\t}\n\treturn (NULL);\n}\n\nstatic int\nwinlink_next_index(struct winlinks *wwl, int idx)\n{\n\tint\ti;\n\n\ti = idx;\n\tdo {\n\t\tif (winlink_find_by_index(wwl, i) == NULL)\n\t\t\treturn (i);\n\t\tif (i == INT_MAX)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti++;\n\t} while (i != idx);\n\treturn (-1);\n}\n\nu_int\nwinlink_count(struct winlinks *wwl)\n{\n\tstruct winlink\t*wl;\n\tu_int\t\t n;\n\n\tn = 0;\n\tRB_FOREACH(wl, winlinks, wwl)\n\t\tn++;\n\n\treturn (n);\n}\n\nstruct winlink *\nwinlink_add(struct winlinks *wwl, int idx)\n{\n\tstruct winlink\t*wl;\n\n\tif (idx < 0) {\n\t\tif ((idx = winlink_next_index(wwl, -idx - 1)) == -1)\n\t\t\treturn (NULL);\n\t} else if (winlink_find_by_index(wwl, idx) != NULL)\n\t\treturn (NULL);\n\n\twl = xcalloc(1, sizeof *wl);\n\twl->idx = idx;\n\tRB_INSERT(winlinks, wwl, wl);\n\n\treturn (wl);\n}\n\nvoid\nwinlink_set_window(struct winlink *wl, struct window *w)\n{\n\tif (wl->window != NULL) {\n\t\tTAILQ_REMOVE(&wl->window->winlinks, wl, wentry);\n\t\twindow_remove_ref(wl->window, __func__);\n\t}\n\tTAILQ_INSERT_TAIL(&w->winlinks, wl, wentry);\n\twl->window = w;\n\twindow_add_ref(w, __func__);\n}\n\nvoid\nwinlink_remove(struct winlinks *wwl, struct winlink *wl)\n{\n\tstruct window\t*w = wl->window;\n\n\tif (w != NULL) {\n\t\tTAILQ_REMOVE(&w->winlinks, wl, wentry);\n\t\twindow_remove_ref(w, __func__);\n\t}\n\n\tRB_REMOVE(winlinks, wwl, wl);\n\tfree(wl);\n}\n\nstruct winlink *\nwinlink_next(struct winlink *wl)\n{\n\treturn (RB_NEXT(winlinks, wwl, wl));\n}\n\nstruct winlink *\nwinlink_previous(struct winlink *wl)\n{\n\treturn (RB_PREV(winlinks, wwl, wl));\n}\n\nstruct winlink *\nwinlink_next_by_number(struct winlink *wl, struct session *s, int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wl = RB_NEXT(winlinks, wwl, wl)) == NULL)\n\t\t\twl = RB_MIN(winlinks, &s->windows);\n\t}\n\n\treturn (wl);\n}\n\nstruct winlink *\nwinlink_previous_by_number(struct winlink *wl, struct session *s, int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wl = RB_PREV(winlinks, wwl, wl)) == NULL)\n\t\t\twl = RB_MAX(winlinks, &s->windows);\n\t}\n\n\treturn (wl);\n}\n\nvoid\nwinlink_stack_push(struct winlink_stack *stack, struct winlink *wl)\n{\n\tif (wl == NULL)\n\t\treturn;\n\n\twinlink_stack_remove(stack, wl);\n\tTAILQ_INSERT_HEAD(stack, wl, sentry);\n\twl->flags |= WINLINK_VISITED;\n}\n\nvoid\nwinlink_stack_remove(struct winlink_stack *stack, struct winlink *wl)\n{\n\tif (wl != NULL && (wl->flags & WINLINK_VISITED)) {\n\t\tTAILQ_REMOVE(stack, wl, sentry);\n\t\twl->flags &= ~WINLINK_VISITED;\n\t}\n}\n\nstruct window *\nwindow_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '@')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (window_find_by_id(id));\n}\n\nstruct window *\nwindow_find_by_id(u_int id)\n{\n\tstruct window\tw;\n\n\tw.id = id;\n\treturn (RB_FIND(windows, &windows, &w));\n}\n\nvoid\nwindow_update_activity(struct window *w)\n{\n\tgettimeofday(&w->activity_time, NULL);\n\talerts_queue(w, WINDOW_ACTIVITY);\n}\n\nstruct window *\nwindow_create(u_int sx, u_int sy, u_int xpixel, u_int ypixel)\n{\n\tstruct window\t*w;\n\n\tif (xpixel == 0)\n\t\txpixel = DEFAULT_XPIXEL;\n\tif (ypixel == 0)\n\t\typixel = DEFAULT_YPIXEL;\n\n\tw = xcalloc(1, sizeof *w);\n\tw->name = xstrdup(\"\");\n\tw->flags = 0;\n\n\tTAILQ_INIT(&w->panes);\n\tTAILQ_INIT(&w->last_panes);\n\tw->active = NULL;\n\n\tw->lastlayout = -1;\n\tw->layout_root = NULL;\n\n\tw->sx = sx;\n\tw->sy = sy;\n\tw->manual_sx = sx;\n\tw->manual_sy = sy;\n\tw->xpixel = xpixel;\n\tw->ypixel = ypixel;\n\n\tw->options = options_create(global_w_options);\n\n\tw->references = 0;\n\tTAILQ_INIT(&w->winlinks);\n\n\tw->id = next_window_id++;\n\tRB_INSERT(windows, &windows, w);\n\n\twindow_set_fill_character(w);\n\twindow_update_activity(w);\n\n\tlog_debug(\"%s: @%u create %ux%u (%ux%u)\", __func__, w->id, sx, sy,\n\t    w->xpixel, w->ypixel);\n\treturn (w);\n}\n\nstatic void\nwindow_destroy(struct window *w)\n{\n\tlog_debug(\"window @%u destroyed (%d references)\", w->id, w->references);\n\n\twindow_unzoom(w, 0);\n\tRB_REMOVE(windows, &windows, w);\n\n\tif (w->layout_root != NULL)\n\t\tlayout_free_cell(w->layout_root);\n\tif (w->saved_layout_root != NULL)\n\t\tlayout_free_cell(w->saved_layout_root);\n\tfree(w->old_layout);\n\n\twindow_destroy_panes(w);\n\n\tif (event_initialized(&w->name_event))\n\t\tevtimer_del(&w->name_event);\n\n\tif (event_initialized(&w->alerts_timer))\n\t\tevtimer_del(&w->alerts_timer);\n\tif (event_initialized(&w->offset_timer))\n\t\tevent_del(&w->offset_timer);\n\n\toptions_free(w->options);\n\tfree(w->fill_character);\n\n\tfree(w->name);\n\tfree(w);\n}\n\nint\nwindow_pane_destroy_ready(struct window_pane *wp)\n{\n\tint\tn;\n\n\tif (wp->pipe_fd != -1) {\n\t\tif (EVBUFFER_LENGTH(wp->pipe_event->output) != 0)\n\t\t\treturn (0);\n\t\tif (ioctl(wp->fd, FIONREAD, &n) != -1 && n > 0)\n\t\t\treturn (0);\n\t}\n\n\tif (~wp->flags & PANE_EXITED)\n\t\treturn (0);\n\treturn (1);\n}\n\nvoid\nwindow_add_ref(struct window *w, const char *from)\n{\n\tw->references++;\n\tlog_debug(\"%s: @%u %s, now %d\", __func__, w->id, from, w->references);\n}\n\nvoid\nwindow_remove_ref(struct window *w, const char *from)\n{\n\tw->references--;\n\tlog_debug(\"%s: @%u %s, now %d\", __func__, w->id, from, w->references);\n\n\tif (w->references == 0)\n\t\twindow_destroy(w);\n}\n\nvoid\nwindow_set_name(struct window *w, const char *new_name)\n{\n\tfree(w->name);\n\tutf8_stravis(&w->name, new_name, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL);\n\tnotify_window(\"window-renamed\", w);\n}\n\nvoid\nwindow_resize(struct window *w, u_int sx, u_int sy, int xpixel, int ypixel)\n{\n\tif (xpixel == 0)\n\t\txpixel = DEFAULT_XPIXEL;\n\tif (ypixel == 0)\n\t\typixel = DEFAULT_YPIXEL;\n\n\tlog_debug(\"%s: @%u resize %ux%u (%ux%u)\", __func__, w->id, sx, sy,\n\t    xpixel == -1 ? w->xpixel : (u_int)xpixel,\n\t    ypixel == -1 ? w->ypixel : (u_int)ypixel);\n\tw->sx = sx;\n\tw->sy = sy;\n\tif (xpixel != -1)\n\t\tw->xpixel = xpixel;\n\tif (ypixel != -1)\n\t\tw->ypixel = ypixel;\n}\n\nvoid\nwindow_pane_send_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tstruct window\t*w = wp->window;\n\tstruct winsize\t ws;\n\n\tif (wp->fd == -1)\n\t\treturn;\n\n\tlog_debug(\"%s: %%%u resize to %u,%u\", __func__, wp->id, sx, sy);\n\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = sx;\n\tws.ws_row = sy;\n\tws.ws_xpixel = w->xpixel * ws.ws_col;\n\tws.ws_ypixel = w->ypixel * ws.ws_row;\n\tif (ioctl(wp->fd, TIOCSWINSZ, &ws) == -1)\n#ifdef __sun\n\t\t/*\n\t\t * Some versions of Solaris apparently can return an error when\n\t\t * resizing; don't know why this happens, can't reproduce on\n\t\t * other platforms and ignoring it doesn't seem to cause any\n\t\t * issues.\n\t\t */\n\t\tif (errno != EINVAL && errno != ENXIO)\n#endif\n\t\tfatal(\"ioctl failed\");\n}\n\nint\nwindow_has_pane(struct window *w, struct window_pane *wp)\n{\n\tstruct window_pane\t*wp1;\n\n\tTAILQ_FOREACH(wp1, &w->panes, entry) {\n\t\tif (wp1 == wp)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nwindow_update_focus(struct window *w)\n{\n\tif (w != NULL) {\n\t\tlog_debug(\"%s: @%u\", __func__, w->id);\n\t\twindow_pane_update_focus(w->active);\n\t}\n}\n\nvoid\nwindow_pane_update_focus(struct window_pane *wp)\n{\n\tstruct client\t*c;\n\tint\t\t focused = 0;\n\n\tif (wp != NULL && (~wp->flags & PANE_EXITED)) {\n\t\tif (wp != wp->window->active)\n\t\t\tfocused = 0;\n\t\telse {\n\t\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\t\tif (c->session != NULL &&\n\t\t\t\t    c->session->attached != 0 &&\n\t\t\t\t    (c->flags & CLIENT_FOCUSED) &&\n\t\t\t\t    c->session->curw->window == wp->window &&\n\t\t\t\t    c->overlay_draw == NULL) {\n\t\t\t\t\tfocused = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!focused && (wp->flags & PANE_FOCUSED)) {\n\t\t\tlog_debug(\"%s: %%%u focus out\", __func__, wp->id);\n\t\t\tif (wp->base.mode & MODE_FOCUSON)\n\t\t\t\tbufferevent_write(wp->event, \"\\033[O\", 3);\n\t\t\tnotify_pane(\"pane-focus-out\", wp);\n\t\t\twp->flags &= ~PANE_FOCUSED;\n\t\t} else if (focused && (~wp->flags & PANE_FOCUSED)) {\n\t\t\tlog_debug(\"%s: %%%u focus in\", __func__, wp->id);\n\t\t\tif (wp->base.mode & MODE_FOCUSON)\n\t\t\t\tbufferevent_write(wp->event, \"\\033[I\", 3);\n\t\t\tnotify_pane(\"pane-focus-in\", wp);\n\t\t\twp->flags |= PANE_FOCUSED;\n\t\t} else\n\t\t\tlog_debug(\"%s: %%%u focus unchanged\", __func__, wp->id);\n\t}\n}\n\nint\nwindow_set_active_pane(struct window *w, struct window_pane *wp, int notify)\n{\n\tstruct window_pane *lastwp;\n\n\tlog_debug(\"%s: pane %%%u\", __func__, wp->id);\n\n\tif (wp == w->active)\n\t\treturn (0);\n\tlastwp = w->active;\n\n\twindow_pane_stack_remove(&w->last_panes, wp);\n\twindow_pane_stack_push(&w->last_panes, lastwp);\n\n\tw->active = wp;\n\tw->active->active_point = next_active_point++;\n\tw->active->flags |= PANE_CHANGED;\n\n\tif (options_get_number(global_options, \"focus-events\")) {\n\t\twindow_pane_update_focus(lastwp);\n\t\twindow_pane_update_focus(w->active);\n\t}\n\n\ttty_update_window_offset(w);\n\n\tif (notify)\n\t\tnotify_window(\"window-pane-changed\", w);\n\treturn (1);\n}\n\nstatic int\nwindow_pane_get_palette(struct window_pane *wp, int c)\n{\n\tif (wp == NULL)\n\t\treturn (-1);\n\treturn (colour_palette_get(&wp->palette, c));\n}\n\nvoid\nwindow_redraw_active_switch(struct window *w, struct window_pane *wp)\n{\n\tstruct grid_cell\t*gc1, *gc2;\n\tint\t\t\t c1, c2;\n\n\tif (wp == w->active)\n\t\treturn;\n\n\tfor (;;) {\n\t\t/*\n\t\t * If the active and inactive styles or palettes are different,\n\t\t * need to redraw the panes.\n\t\t */\n\t\tgc1 = &wp->cached_gc;\n\t\tgc2 = &wp->cached_active_gc;\n\t\tif (!grid_cells_look_equal(gc1, gc2))\n\t\t\twp->flags |= PANE_REDRAW;\n\t\telse {\n\t\t\tc1 = window_pane_get_palette(wp, gc1->fg);\n\t\t\tc2 = window_pane_get_palette(wp, gc2->fg);\n\t\t\tif (c1 != c2)\n\t\t\t\twp->flags |= PANE_REDRAW;\n\t\t\telse {\n\t\t\t\tc1 = window_pane_get_palette(wp, gc1->bg);\n\t\t\t\tc2 = window_pane_get_palette(wp, gc2->bg);\n\t\t\t\tif (c1 != c2)\n\t\t\t\t\twp->flags |= PANE_REDRAW;\n\t\t\t}\n\t\t}\n\t\tif (wp == w->active)\n\t\t\tbreak;\n\t\twp = w->active;\n\t}\n}\n\nstruct window_pane *\nwindow_get_active_at(struct window *w, u_int x, u_int y)\n{\n\tstruct window_pane\t*wp;\n\tint\t\t\t pane_scrollbars;\n\tu_int\t\t\t sb_pos, sb_w, xoff, sx;\n\n\tpane_scrollbars = options_get_number(w->options, \"pane-scrollbars\");\n\tsb_pos = options_get_number(w->options, \"pane-scrollbars-position\");\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\n\t\tif (pane_scrollbars == PANE_SCROLLBARS_ALWAYS ||\n\t\t    (pane_scrollbars == PANE_SCROLLBARS_MODAL &&\n\t\t     window_pane_mode(wp) != WINDOW_PANE_NO_MODE)) {\n\t\t\tsb_w = wp->scrollbar_style.width +\n\t\t\t    wp->scrollbar_style.pad;\n\t\t} else\n\t\t\tsb_w = 0;\n\n\t\tif (sb_pos == PANE_SCROLLBARS_LEFT) {\n\t\t\txoff = wp->xoff - sb_w;\n\t\t\tsx = wp->sx + sb_w;\n\t\t} else { /* sb_pos == PANE_SCROLLBARS_RIGHT */\n\t\t\txoff = wp->xoff;\n\t\t\tsx = wp->sx + sb_w;\n\t\t}\n\t\tif (x < xoff || x > xoff + sx)\n\t\t\tcontinue;\n\t\tif (y < wp->yoff || y > wp->yoff + wp->sy)\n\t\t\tcontinue;\n\t\treturn (wp);\n\t}\n\treturn (NULL);\n}\n\nstruct window_pane *\nwindow_find_string(struct window *w, const char *s)\n{\n\tu_int\tx, y, top = 0, bottom = w->sy - 1;\n\tint\tstatus;\n\n\tx = w->sx / 2;\n\ty = w->sy / 2;\n\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\tif (status == PANE_STATUS_TOP)\n\t\ttop++;\n\telse if (status == PANE_STATUS_BOTTOM)\n\t\tbottom--;\n\n\tif (strcasecmp(s, \"top\") == 0)\n\t\ty = top;\n\telse if (strcasecmp(s, \"bottom\") == 0)\n\t\ty = bottom;\n\telse if (strcasecmp(s, \"left\") == 0)\n\t\tx = 0;\n\telse if (strcasecmp(s, \"right\") == 0)\n\t\tx = w->sx - 1;\n\telse if (strcasecmp(s, \"top-left\") == 0) {\n\t\tx = 0;\n\t\ty = top;\n\t} else if (strcasecmp(s, \"top-right\") == 0) {\n\t\tx = w->sx - 1;\n\t\ty = top;\n\t} else if (strcasecmp(s, \"bottom-left\") == 0) {\n\t\tx = 0;\n\t\ty = bottom;\n\t} else if (strcasecmp(s, \"bottom-right\") == 0) {\n\t\tx = w->sx - 1;\n\t\ty = bottom;\n\t} else\n\t\treturn (NULL);\n\n\treturn (window_get_active_at(w, x, y));\n}\n\nint\nwindow_zoom(struct window_pane *wp)\n{\n\tstruct window\t\t*w = wp->window;\n\tstruct window_pane\t*wp1;\n\n\tif (w->flags & WINDOW_ZOOMED)\n\t\treturn (-1);\n\n\tif (window_count_panes(w) == 1)\n\t\treturn (-1);\n\n\tif (w->active != wp)\n\t\twindow_set_active_pane(w, wp, 1);\n\n\tTAILQ_FOREACH(wp1, &w->panes, entry) {\n\t\twp1->saved_layout_cell = wp1->layout_cell;\n\t\twp1->layout_cell = NULL;\n\t}\n\n\tw->saved_layout_root = w->layout_root;\n\tlayout_init(w, wp);\n\tw->flags |= WINDOW_ZOOMED;\n\tnotify_window(\"window-layout-changed\", w);\n\n\treturn (0);\n}\n\nint\nwindow_unzoom(struct window *w, int notify)\n{\n\tstruct window_pane\t*wp;\n\n\tif (!(w->flags & WINDOW_ZOOMED))\n\t\treturn (-1);\n\n\tw->flags &= ~WINDOW_ZOOMED;\n\tlayout_free(w);\n\tw->layout_root = w->saved_layout_root;\n\tw->saved_layout_root = NULL;\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\twp->layout_cell = wp->saved_layout_cell;\n\t\twp->saved_layout_cell = NULL;\n\t}\n\tlayout_fix_panes(w, NULL);\n\n\tif (notify)\n\t\tnotify_window(\"window-layout-changed\", w);\n\n\treturn (0);\n}\n\nint\nwindow_push_zoom(struct window *w, int always, int flag)\n{\n\tlog_debug(\"%s: @%u %d\", __func__, w->id,\n\t    flag && (w->flags & WINDOW_ZOOMED));\n\tif (flag && (always || (w->flags & WINDOW_ZOOMED)))\n\t\tw->flags |= WINDOW_WASZOOMED;\n\telse\n\t\tw->flags &= ~WINDOW_WASZOOMED;\n\treturn (window_unzoom(w, 1) == 0);\n}\n\nint\nwindow_pop_zoom(struct window *w)\n{\n\tlog_debug(\"%s: @%u %d\", __func__, w->id,\n\t    !!(w->flags & WINDOW_WASZOOMED));\n\tif (w->flags & WINDOW_WASZOOMED)\n\t\treturn (window_zoom(w->active) == 0);\n\treturn (0);\n}\n\nstruct window_pane *\nwindow_add_pane(struct window *w, struct window_pane *other, u_int hlimit,\n    int flags)\n{\n\tstruct window_pane\t*wp;\n\n\tif (other == NULL)\n\t\tother = w->active;\n\n\twp = window_pane_create(w, w->sx, w->sy, hlimit);\n\tif (TAILQ_EMPTY(&w->panes)) {\n\t\tlog_debug(\"%s: @%u at start\", __func__, w->id);\n\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\t} else if (flags & SPAWN_BEFORE) {\n\t\tlog_debug(\"%s: @%u before %%%u\", __func__, w->id, wp->id);\n\t\tif (flags & SPAWN_FULLSIZE)\n\t\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_BEFORE(other, wp, entry);\n\t} else {\n\t\tlog_debug(\"%s: @%u after %%%u\", __func__, w->id, wp->id);\n\t\tif (flags & SPAWN_FULLSIZE)\n\t\t\tTAILQ_INSERT_TAIL(&w->panes, wp, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_AFTER(&w->panes, other, wp, entry);\n\t}\n\treturn (wp);\n}\n\nvoid\nwindow_lost_pane(struct window *w, struct window_pane *wp)\n{\n\tlog_debug(\"%s: @%u pane %%%u\", __func__, w->id, wp->id);\n\n\tif (wp == marked_pane.wp)\n\t\tserver_clear_marked();\n\n\twindow_pane_stack_remove(&w->last_panes, wp);\n\tif (wp == w->active) {\n\t\tw->active = TAILQ_FIRST(&w->last_panes);\n\t\tif (w->active == NULL) {\n\t\t\tw->active = TAILQ_PREV(wp, window_panes, entry);\n\t\t\tif (w->active == NULL)\n\t\t\t\tw->active = TAILQ_NEXT(wp, entry);\n\t\t}\n\t\tif (w->active != NULL) {\n\t\t\twindow_pane_stack_remove(&w->last_panes, w->active);\n\t\t\tw->active->flags |= PANE_CHANGED;\n\t\t\tnotify_window(\"window-pane-changed\", w);\n\t\t\twindow_update_focus(w);\n\t\t}\n\t}\n}\n\nvoid\nwindow_remove_pane(struct window *w, struct window_pane *wp)\n{\n\twindow_lost_pane(w, wp);\n\n\tTAILQ_REMOVE(&w->panes, wp, entry);\n\twindow_pane_destroy(wp);\n}\n\nstruct window_pane *\nwindow_pane_at_index(struct window *w, u_int idx)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tn = options_get_number(w->options, \"pane-base-index\");\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (n == idx)\n\t\t\treturn (wp);\n\t\tn++;\n\t}\n\treturn (NULL);\n}\n\nstruct window_pane *\nwindow_pane_next_by_number(struct window *w, struct window_pane *wp, u_int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\twp = TAILQ_FIRST(&w->panes);\n\t}\n\n\treturn (wp);\n}\n\nstruct window_pane *\nwindow_pane_previous_by_number(struct window *w, struct window_pane *wp,\n    u_int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wp = TAILQ_PREV(wp, window_panes, entry)) == NULL)\n\t\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t}\n\n\treturn (wp);\n}\n\nint\nwindow_pane_index(struct window_pane *wp, u_int *i)\n{\n\tstruct window_pane\t*wq;\n\tstruct window\t\t*w = wp->window;\n\n\t*i = options_get_number(w->options, \"pane-base-index\");\n\tTAILQ_FOREACH(wq, &w->panes, entry) {\n\t\tif (wp == wq) {\n\t\t\treturn (0);\n\t\t}\n\t\t(*i)++;\n\t}\n\n\treturn (-1);\n}\n\nu_int\nwindow_count_panes(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry)\n\t\tn++;\n\treturn (n);\n}\n\nvoid\nwindow_destroy_panes(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\n\twhile (!TAILQ_EMPTY(&w->last_panes)) {\n\t\twp = TAILQ_FIRST(&w->last_panes);\n\t\twindow_pane_stack_remove(&w->last_panes, wp);\n\t}\n\n\twhile (!TAILQ_EMPTY(&w->panes)) {\n\t\twp = TAILQ_FIRST(&w->panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\twindow_pane_destroy(wp);\n\t}\n}\n\nconst char *\nwindow_printable_flags(struct winlink *wl, int escape)\n{\n\tstruct session\t*s = wl->session;\n\tstatic char\t flags[32];\n\tint\t\t pos;\n\n\tpos = 0;\n\tif (wl->flags & WINLINK_ACTIVITY) {\n\t\tflags[pos++] = '#';\n\t\tif (escape)\n\t\t\tflags[pos++] = '#';\n\t}\n\tif (wl->flags & WINLINK_BELL)\n\t\tflags[pos++] = '!';\n\tif (wl->flags & WINLINK_SILENCE)\n\t\tflags[pos++] = '~';\n\tif (wl == s->curw)\n\t\tflags[pos++] = '*';\n\tif (wl == TAILQ_FIRST(&s->lastw))\n\t\tflags[pos++] = '-';\n\tif (server_check_marked() && wl == marked_pane.wl)\n\t\tflags[pos++] = 'M';\n\tif (wl->window->flags & WINDOW_ZOOMED)\n\t\tflags[pos++] = 'Z';\n\tflags[pos] = '\\0';\n\treturn (flags);\n}\n\nstruct window_pane *\nwindow_pane_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '%')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (window_pane_find_by_id(id));\n}\n\nstruct window_pane *\nwindow_pane_find_by_id(u_int id)\n{\n\tstruct window_pane\twp;\n\n\twp.id = id;\n\treturn (RB_FIND(window_pane_tree, &all_window_panes, &wp));\n}\n\nstatic struct window_pane *\nwindow_pane_create(struct window *w, u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct window_pane\t*wp;\n\tchar\t\t\t host[HOST_NAME_MAX + 1];\n\n\twp = xcalloc(1, sizeof *wp);\n\twp->window = w;\n\twp->options = options_create(w->options);\n\twp->flags = PANE_STYLECHANGED;\n\n\twp->id = next_window_pane_id++;\n\tRB_INSERT(window_pane_tree, &all_window_panes, wp);\n\n\twp->fd = -1;\n\n\tTAILQ_INIT(&wp->modes);\n\n\tTAILQ_INIT (&wp->resize_queue);\n\n\twp->sx = sx;\n\twp->sy = sy;\n\n\twp->pipe_fd = -1;\n\n\twp->control_bg = -1;\n\twp->control_fg = -1;\n\n\tstyle_set_scrollbar_style_from_option(&wp->scrollbar_style,\n\t    wp->options);\n\n\tcolour_palette_init(&wp->palette);\n\tcolour_palette_from_option(&wp->palette, wp->options);\n\n\tscreen_init(&wp->base, sx, sy, hlimit);\n\twp->screen = &wp->base;\n\twindow_pane_default_cursor(wp);\n\n\tscreen_init(&wp->status_screen, 1, 1, 0);\n\n\tif (gethostname(host, sizeof host) == 0)\n\t\tscreen_set_title(&wp->base, host);\n\n\treturn (wp);\n}\n\nstatic void\nwindow_pane_destroy(struct window_pane *wp)\n{\n\tstruct window_pane_resize\t*r;\n\tstruct window_pane_resize\t*r1;\n\n\twindow_pane_reset_mode_all(wp);\n\tfree(wp->searchstr);\n\n\tif (wp->fd != -1) {\n#ifdef HAVE_UTEMPTER\n\t\tutempter_remove_record(wp->fd);\n#endif\n\t\tbufferevent_free(wp->event);\n\t\tclose(wp->fd);\n\t}\n\tif (wp->ictx != NULL)\n\t\tinput_free(wp->ictx);\n\n\tscreen_free(&wp->status_screen);\n\n\tscreen_free(&wp->base);\n\n\tif (wp->pipe_fd != -1) {\n\t\tbufferevent_free(wp->pipe_event);\n\t\tclose(wp->pipe_fd);\n\t}\n\n\tif (event_initialized(&wp->resize_timer))\n\t\tevent_del(&wp->resize_timer);\n\tTAILQ_FOREACH_SAFE(r, &wp->resize_queue, entry, r1) {\n\t\tTAILQ_REMOVE(&wp->resize_queue, r, entry);\n\t\tfree(r);\n\t}\n\n\tRB_REMOVE(window_pane_tree, &all_window_panes, wp);\n\n\toptions_free(wp->options);\n\tfree((void *)wp->cwd);\n\tfree(wp->shell);\n\tcmd_free_argv(wp->argc, wp->argv);\n\tcolour_palette_free(&wp->palette);\n\tfree(wp);\n}\n\nstatic void\nwindow_pane_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct window_pane\t\t*wp = data;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tstruct window_pane_offset\t*wpo = &wp->pipe_offset;\n\tsize_t\t\t\t\t size = EVBUFFER_LENGTH(evb);\n\tchar\t\t\t\t*new_data;\n\tsize_t\t\t\t\t new_size;\n\tstruct client\t\t\t*c;\n\n\tif (wp->pipe_fd != -1) {\n\t\tnew_data = window_pane_get_new_data(wp, wpo, &new_size);\n\t\tif (new_size > 0) {\n\t\t\tbufferevent_write(wp->pipe_event, new_data, new_size);\n\t\t\twindow_pane_update_used_data(wp, wpo, new_size);\n\t\t}\n\t}\n\n\tlog_debug(\"%%%u has %zu bytes\", wp->id, size);\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && (c->flags & CLIENT_CONTROL))\n\t\t\tcontrol_write_output(c, wp);\n\t}\n\tinput_parse_pane(wp);\n\tbufferevent_disable(wp->event, EV_READ);\n}\n\nstatic void\nwindow_pane_error_callback(__unused struct bufferevent *bufev,\n    __unused short what, void *data)\n{\n\tstruct window_pane *wp = data;\n\n\tlog_debug(\"%%%u error\", wp->id);\n\twp->flags |= PANE_EXITED;\n\n\tif (window_pane_destroy_ready(wp))\n\t\tserver_destroy_pane(wp, 1);\n}\n\nvoid\nwindow_pane_set_event(struct window_pane *wp)\n{\n\tsetblocking(wp->fd, 0);\n\n\twp->event = bufferevent_new(wp->fd, window_pane_read_callback,\n\t    NULL, window_pane_error_callback, wp);\n\tif (wp->event == NULL)\n\t\tfatalx(\"out of memory\");\n\twp->ictx = input_init(wp, wp->event, &wp->palette);\n\n\tbufferevent_enable(wp->event, EV_READ|EV_WRITE);\n}\n\nvoid\nwindow_pane_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tstruct window_mode_entry\t*wme;\n\tstruct window_pane_resize\t*r;\n\n\tif (sx == wp->sx && sy == wp->sy)\n\t\treturn;\n\n\tr = xmalloc(sizeof *r);\n\tr->sx = sx;\n\tr->sy = sy;\n\tr->osx = wp->sx;\n\tr->osy = wp->sy;\n\tTAILQ_INSERT_TAIL (&wp->resize_queue, r, entry);\n\n\twp->sx = sx;\n\twp->sy = sy;\n\n\tlog_debug(\"%s: %%%u resize %ux%u\", __func__, wp->id, sx, sy);\n\tscreen_resize(&wp->base, sx, sy, wp->base.saved_grid == NULL);\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme != NULL && wme->mode->resize != NULL)\n\t\twme->mode->resize(wme, sx, sy);\n}\n\nint\nwindow_pane_set_mode(struct window_pane *wp, struct window_pane *swp,\n    const struct window_mode *mode, struct cmd_find_state *fs,\n    struct args *args)\n{\n\tstruct window_mode_entry\t*wme;\n\tstruct window\t\t\t*w = wp->window;\n\n\tif (!TAILQ_EMPTY(&wp->modes) && TAILQ_FIRST(&wp->modes)->mode == mode)\n\t\treturn (1);\n\n\tTAILQ_FOREACH(wme, &wp->modes, entry) {\n\t\tif (wme->mode == mode)\n\t\t\tbreak;\n\t}\n\tif (wme != NULL) {\n\t\tTAILQ_REMOVE(&wp->modes, wme, entry);\n\t\tTAILQ_INSERT_HEAD(&wp->modes, wme, entry);\n\t} else {\n\t\twme = xcalloc(1, sizeof *wme);\n\t\twme->wp = wp;\n\t\twme->swp = swp;\n\t\twme->mode = mode;\n\t\twme->prefix = 1;\n\t\tTAILQ_INSERT_HEAD(&wp->modes, wme, entry);\n\t\twme->screen = wme->mode->init(wme, fs, args);\n\t}\n\twp->screen = wme->screen;\n\n\twp->flags |= (PANE_REDRAW|PANE_REDRAWSCROLLBAR|PANE_CHANGED);\n\tlayout_fix_panes(w, NULL);\n\n\tserver_redraw_window_borders(wp->window);\n\tserver_status_window(wp->window);\n\tnotify_pane(\"pane-mode-changed\", wp);\n\n\treturn (0);\n}\n\nvoid\nwindow_pane_reset_mode(struct window_pane *wp)\n{\n\tstruct window_mode_entry\t*wme, *next;\n\tstruct window\t\t\t*w = wp->window;\n\n\tif (TAILQ_EMPTY(&wp->modes))\n\t\treturn;\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tTAILQ_REMOVE(&wp->modes, wme, entry);\n\twme->mode->free(wme);\n\tfree(wme);\n\n\tnext = TAILQ_FIRST(&wp->modes);\n\tif (next == NULL) {\n\t\twp->flags &= ~PANE_UNSEENCHANGES;\n\t\tlog_debug(\"%s: no next mode\", __func__);\n\t\twp->screen = &wp->base;\n\t} else {\n\t\tlog_debug(\"%s: next mode is %s\", __func__, next->mode->name);\n\t\twp->screen = next->screen;\n\t\tif (next->mode->resize != NULL)\n\t\t\tnext->mode->resize(next, wp->sx, wp->sy);\n\t}\n\n\twp->flags |= (PANE_REDRAW|PANE_REDRAWSCROLLBAR|PANE_CHANGED);\n\tlayout_fix_panes(w, NULL);\n\n\tserver_redraw_window_borders(wp->window);\n\tserver_status_window(wp->window);\n\tnotify_pane(\"pane-mode-changed\", wp);\n}\n\nvoid\nwindow_pane_reset_mode_all(struct window_pane *wp)\n{\n\twhile (!TAILQ_EMPTY(&wp->modes))\n\t\twindow_pane_reset_mode(wp);\n}\n\nstatic void\nwindow_pane_copy_paste(struct window_pane *wp, char *buf, size_t len)\n{\n \tstruct window_pane\t*loop;\n\n\tTAILQ_FOREACH(loop, &wp->window->panes, entry) {\n\t\tif (loop != wp &&\n\t\t    TAILQ_EMPTY(&loop->modes) &&\n\t\t    loop->fd != -1 &&\n\t\t    (~loop->flags & PANE_INPUTOFF) &&\n\t\t    window_pane_visible(loop) &&\n\t\t    options_get_number(loop->options, \"synchronize-panes\")) {\n\t\t\tlog_debug(\"%s: %.*s\", __func__, (int)len, buf);\n\t\t\tbufferevent_write(loop->event, buf, len);\n\t\t}\n\t}\n}\n\nstatic void\nwindow_pane_copy_key(struct window_pane *wp, key_code key)\n{\n \tstruct window_pane\t*loop;\n\n\tTAILQ_FOREACH(loop, &wp->window->panes, entry) {\n\t\tif (loop != wp &&\n\t\t    TAILQ_EMPTY(&loop->modes) &&\n\t\t    loop->fd != -1 &&\n\t\t    (~loop->flags & PANE_INPUTOFF) &&\n\t\t    window_pane_visible(loop) &&\n\t\t    options_get_number(loop->options, \"synchronize-panes\"))\n\t\t\tinput_key_pane(loop, key, NULL);\n\t}\n}\n\nvoid\nwindow_pane_paste(struct window_pane *wp, key_code key, char *buf, size_t len)\n{\n\tif (!TAILQ_EMPTY(&wp->modes))\n\t\treturn;\n\n\tif (wp->fd == -1 || wp->flags & PANE_INPUTOFF)\n\t\treturn;\n\n\tif (KEYC_IS_PASTE(key) && (~wp->screen->mode & MODE_BRACKETPASTE))\n\t\treturn;\n\n\tlog_debug(\"%s: %.*s\", __func__, (int)len, buf);\n\tbufferevent_write(wp->event, buf, len);\n\n\tif (options_get_number(wp->options, \"synchronize-panes\"))\n\t\twindow_pane_copy_paste(wp, buf, len);\n}\n\nint\nwindow_pane_key(struct window_pane *wp, struct client *c, struct session *s,\n    struct winlink *wl, key_code key, struct mouse_event *m)\n{\n\tstruct window_mode_entry\t*wme;\n\n\tif (KEYC_IS_MOUSE(key) && m == NULL)\n\t\treturn (-1);\n\n\twme = TAILQ_FIRST(&wp->modes);\n\tif (wme != NULL) {\n\t\tif (wme->mode->key != NULL && c != NULL) {\n\t\t\tkey &= ~KEYC_MASK_FLAGS;\n\t\t\twme->mode->key(wme, c, s, wl, key, m);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (wp->fd == -1 || wp->flags & PANE_INPUTOFF)\n\t\treturn (0);\n\n\tif (input_key_pane(wp, key, m) != 0)\n\t\treturn (-1);\n\n\tif (KEYC_IS_MOUSE(key))\n\t\treturn (0);\n\tif (options_get_number(wp->options, \"synchronize-panes\"))\n\t\twindow_pane_copy_key(wp, key);\n\treturn (0);\n}\n\nint\nwindow_pane_visible(struct window_pane *wp)\n{\n\tif (~wp->window->flags & WINDOW_ZOOMED)\n\t\treturn (1);\n\treturn (wp == wp->window->active);\n}\n\nint\nwindow_pane_exited(struct window_pane *wp)\n{\n\treturn (wp->fd == -1 || (wp->flags & PANE_EXITED));\n}\n\nu_int\nwindow_pane_search(struct window_pane *wp, const char *term, int regex,\n    int ignore)\n{\n\tstruct screen\t*s = &wp->base;\n\tregex_t\t\t r;\n\tchar\t\t*new = NULL, *line;\n\tu_int\t\t i;\n\tint\t\t flags = 0, found;\n\tsize_t\t\t n;\n\n\tif (!regex) {\n\t\tif (ignore)\n\t\t\tflags |= FNM_CASEFOLD;\n\t\txasprintf(&new, \"*%s*\", term);\n\t} else {\n\t\tif (ignore)\n\t\t\tflags |= REG_ICASE;\n\t\tif (regcomp(&r, term, flags|REG_EXTENDED) != 0)\n\t\t\treturn (0);\n\t}\n\n\tfor (i = 0; i < screen_size_y(s); i++) {\n\t\tline = grid_view_string_cells(s->grid, 0, i, screen_size_x(s));\n\t\tfor (n = strlen(line); n > 0; n--) {\n\t\t\tif (!isspace((u_char)line[n - 1]))\n\t\t\t\tbreak;\n\t\t\tline[n - 1] = '\\0';\n\t\t}\n\t\tlog_debug(\"%s: %s\", __func__, line);\n\t\tif (!regex)\n\t\t\tfound = (fnmatch(new, line, flags) == 0);\n\t\telse\n\t\t\tfound = (regexec(&r, line, 0, NULL, 0) == 0);\n\t\tfree(line);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!regex)\n\t\tfree(new);\n\telse\n\t\tregfree(&r);\n\n\tif (i == screen_size_y(s))\n\t\treturn (0);\n\treturn (i + 1);\n}\n\n/* Get MRU pane from a list. */\nstatic struct window_pane *\nwindow_pane_choose_best(struct window_pane **list, u_int size)\n{\n\tstruct window_pane\t*next, *best;\n\tu_int\t\t\t i;\n\n\tif (size == 0)\n\t\treturn (NULL);\n\n\tbest = list[0];\n\tfor (i = 1; i < size; i++) {\n\t\tnext = list[i];\n\t\tif (next->active_point > best->active_point)\n\t\t\tbest = next;\n\t}\n\treturn (best);\n}\n\n/*\n * Find the pane directly above another. We build a list of those adjacent to\n * top edge and then choose the best.\n */\nstruct window_pane *\nwindow_pane_find_up(struct window_pane *wp)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, left, right, end, size;\n\tint\t\t\t status, found;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->yoff;\n\tif (status == PANE_STATUS_TOP) {\n\t\tif (edge == 1)\n\t\t\tedge = w->sy + 1;\n\t} else if (status == PANE_STATUS_BOTTOM) {\n\t\tif (edge == 0)\n\t\t\tedge = w->sy;\n\t} else {\n\t\tif (edge == 0)\n\t\t\tedge = w->sy + 1;\n\t}\n\n\tleft = wp->xoff;\n\tright = wp->xoff + wp->sx;\n\n\tTAILQ_FOREACH(next, &w->panes, entry) {\n\t\tif (next == wp)\n\t\t\tcontinue;\n\t\tif (next->yoff + next->sy + 1 != edge)\n\t\t\tcontinue;\n\t\tend = next->xoff + next->sx - 1;\n\n\t\tfound = 0;\n\t\tif (next->xoff < left && end > right)\n\t\t\tfound = 1;\n\t\telse if (next->xoff >= left && next->xoff <= right)\n\t\t\tfound = 1;\n\t\telse if (end >= left && end <= right)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly below another. */\nstruct window_pane *\nwindow_pane_find_down(struct window_pane *wp)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, left, right, end, size;\n\tint\t\t\t status, found;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\tstatus = options_get_number(w->options, \"pane-border-status\");\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->yoff + wp->sy + 1;\n\tif (status == PANE_STATUS_TOP) {\n\t\tif (edge >= w->sy)\n\t\t\tedge = 1;\n\t} else if (status == PANE_STATUS_BOTTOM) {\n\t\tif (edge >= w->sy - 1)\n\t\t\tedge = 0;\n\t} else {\n\t\tif (edge >= w->sy)\n\t\t\tedge = 0;\n\t}\n\n\tleft = wp->xoff;\n\tright = wp->xoff + wp->sx;\n\n\tTAILQ_FOREACH(next, &w->panes, entry) {\n\t\tif (next == wp)\n\t\t\tcontinue;\n\t\tif (next->yoff != edge)\n\t\t\tcontinue;\n\t\tend = next->xoff + next->sx - 1;\n\n\t\tfound = 0;\n\t\tif (next->xoff < left && end > right)\n\t\t\tfound = 1;\n\t\telse if (next->xoff >= left && next->xoff <= right)\n\t\t\tfound = 1;\n\t\telse if (end >= left && end <= right)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly to the left of another. */\nstruct window_pane *\nwindow_pane_find_left(struct window_pane *wp)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, top, bottom, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->xoff;\n\tif (edge == 0)\n\t\tedge = w->sx + 1;\n\n\ttop = wp->yoff;\n\tbottom = wp->yoff + wp->sy;\n\n\tTAILQ_FOREACH(next, &w->panes, entry) {\n\t\tif (next == wp)\n\t\t\tcontinue;\n\t\tif (next->xoff + next->sx + 1 != edge)\n\t\t\tcontinue;\n\t\tend = next->yoff + next->sy - 1;\n\n\t\tfound = 0;\n\t\tif (next->yoff < top && end > bottom)\n\t\t\tfound = 1;\n\t\telse if (next->yoff >= top && next->yoff <= bottom)\n\t\t\tfound = 1;\n\t\telse if (end >= top && end <= bottom)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly to the right of another. */\nstruct window_pane *\nwindow_pane_find_right(struct window_pane *wp)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, top, bottom, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL)\n\t\treturn (NULL);\n\tw = wp->window;\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->xoff + wp->sx + 1;\n\tif (edge >= w->sx)\n\t\tedge = 0;\n\n\ttop = wp->yoff;\n\tbottom = wp->yoff + wp->sy;\n\n\tTAILQ_FOREACH(next, &w->panes, entry) {\n\t\tif (next == wp)\n\t\t\tcontinue;\n\t\tif (next->xoff != edge)\n\t\t\tcontinue;\n\t\tend = next->yoff + next->sy - 1;\n\n\t\tfound = 0;\n\t\tif (next->yoff < top && end > bottom)\n\t\t\tfound = 1;\n\t\telse if (next->yoff >= top && next->yoff <= bottom)\n\t\t\tfound = 1;\n\t\telse if (end >= top && end <= bottom)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\nvoid\nwindow_pane_stack_push(struct window_panes *stack, struct window_pane *wp)\n{\n\tif (wp != NULL) {\n\t\twindow_pane_stack_remove(stack, wp);\n\t\tTAILQ_INSERT_HEAD(stack, wp, sentry);\n\t\twp->flags |= PANE_VISITED;\n\t}\n}\n\nvoid\nwindow_pane_stack_remove(struct window_panes *stack, struct window_pane *wp)\n{\n\tif (wp != NULL && (wp->flags & PANE_VISITED)) {\n\t\tTAILQ_REMOVE(stack, wp, sentry);\n\t\twp->flags &= ~PANE_VISITED;\n\t}\n}\n\n/* Clear alert flags for a winlink */\nvoid\nwinlink_clear_flags(struct winlink *wl)\n{\n\tstruct winlink\t*loop;\n\n\twl->window->flags &= ~WINDOW_ALERTFLAGS;\n\tTAILQ_FOREACH(loop, &wl->window->winlinks, wentry) {\n\t\tif ((loop->flags & WINLINK_ALERTFLAGS) != 0) {\n\t\t\tloop->flags &= ~WINLINK_ALERTFLAGS;\n\t\t\tserver_status_session(loop->session);\n\t\t}\n\t}\n}\n\n/* Shuffle window indexes up. */\nint\nwinlink_shuffle_up(struct session *s, struct winlink *wl, int before)\n{\n\tint\t idx, last;\n\n\tif (wl == NULL)\n\t\treturn (-1);\n\tif (before)\n\t\tidx = wl->idx;\n\telse\n\t\tidx = wl->idx + 1;\n\n\t/* Find the next free index. */\n\tfor (last = idx; last < INT_MAX; last++) {\n\t\tif (winlink_find_by_index(&s->windows, last) == NULL)\n\t\t\tbreak;\n\t}\n\tif (last == INT_MAX)\n\t\treturn (-1);\n\n\t/* Move everything from last - 1 to idx up a bit. */\n\tfor (; last > idx; last--) {\n\t\twl = winlink_find_by_index(&s->windows, last - 1);\n\t\tRB_REMOVE(winlinks, &s->windows, wl);\n\t\twl->idx++;\n\t\tRB_INSERT(winlinks, &s->windows, wl);\n\t}\n\n\treturn (idx);\n}\n\nstatic void\nwindow_pane_input_callback(struct client *c, __unused const char *path,\n    int error, int closed, struct evbuffer *buffer, void *data)\n{\n\tstruct window_pane_input_data\t*cdata = data;\n\tstruct window_pane\t\t*wp;\n\tu_char\t\t\t\t*buf = EVBUFFER_DATA(buffer);\n\tsize_t\t\t\t\t len = EVBUFFER_LENGTH(buffer);\n\n\twp = window_pane_find_by_id(cdata->wp);\n\tif (cdata->file != NULL && (wp == NULL || c->flags & CLIENT_DEAD)) {\n\t\tif (wp == NULL) {\n\t\t\tc->retval = 1;\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t}\n\t\tfile_cancel(cdata->file);\n\t} else if (cdata->file == NULL || closed || error != 0) {\n\t\tcmdq_continue(cdata->item);\n\t\tserver_client_unref(c);\n\t\tfree(cdata);\n\t} else\n\t\tinput_parse_buffer(wp, buf, len);\n\tevbuffer_drain(buffer, len);\n}\n\nint\nwindow_pane_start_input(struct window_pane *wp, struct cmdq_item *item,\n    char **cause)\n{\n\tstruct client\t\t\t*c = cmdq_get_client(item);\n\tstruct window_pane_input_data\t*cdata;\n\n\tif (~wp->flags & PANE_EMPTY) {\n\t\t*cause = xstrdup(\"pane is not empty\");\n\t\treturn (-1);\n\t}\n\tif (c->flags & (CLIENT_DEAD|CLIENT_EXITED))\n\t\treturn (1);\n\tif (c->session != NULL)\n\t\treturn (1);\n\n\tcdata = xmalloc(sizeof *cdata);\n\tcdata->item = item;\n\tcdata->wp = wp->id;\n\tcdata->file = file_read(c, \"-\", window_pane_input_callback, cdata);\n\tc->references++;\n\n\treturn (0);\n}\n\nvoid *\nwindow_pane_get_new_data(struct window_pane *wp,\n    struct window_pane_offset *wpo, size_t *size)\n{\n\tsize_t\tused = wpo->used - wp->base_offset;\n\n\t*size = EVBUFFER_LENGTH(wp->event->input) - used;\n\treturn (EVBUFFER_DATA(wp->event->input) + used);\n}\n\nvoid\nwindow_pane_update_used_data(struct window_pane *wp,\n    struct window_pane_offset *wpo, size_t size)\n{\n\tsize_t\tused = wpo->used - wp->base_offset;\n\n\tif (size > EVBUFFER_LENGTH(wp->event->input) - used)\n\t\tsize = EVBUFFER_LENGTH(wp->event->input) - used;\n\twpo->used += size;\n}\n\nvoid\nwindow_set_fill_character(struct window *w)\n{\n\tconst char\t\t*value;\n\tstruct utf8_data\t*ud;\n\n\tfree(w->fill_character);\n\tw->fill_character = NULL;\n\n\tvalue = options_get_string(w->options, \"fill-character\");\n\tif (*value != '\\0' && utf8_isvalid(value)) {\n\t\tud = utf8_fromcstr(value);\n\t\tif (ud != NULL && ud[0].width == 1)\n\t\t\tw->fill_character = ud;\n\t}\n}\n\nvoid\nwindow_pane_default_cursor(struct window_pane *wp)\n{\n\tscreen_set_default_cursor(wp->screen, wp->options);\n}\n\nint\nwindow_pane_mode(struct window_pane *wp)\n{\n\tif (TAILQ_FIRST(&wp->modes) != NULL) {\n\t\tif (TAILQ_FIRST(&wp->modes)->mode == &window_copy_mode)\n\t\t\treturn (WINDOW_PANE_COPY_MODE);\n\t\tif (TAILQ_FIRST(&wp->modes)->mode == &window_view_mode)\n\t\t\treturn (WINDOW_PANE_VIEW_MODE);\n\t}\n\treturn (WINDOW_PANE_NO_MODE);\n}\n\n/* Return 1 if scrollbar is or should be displayed. */\nint\nwindow_pane_show_scrollbar(struct window_pane *wp, int sb_option)\n{\n\tif (SCREEN_IS_ALTERNATE(wp->screen))\n\t\treturn (0);\n\tif (sb_option == PANE_SCROLLBARS_ALWAYS ||\n\t    (sb_option == PANE_SCROLLBARS_MODAL &&\n\t    window_pane_mode(wp) != WINDOW_PANE_NO_MODE))\n\t\treturn (1);\n\treturn (0);\n}\n"
        },
        {
          "name": "xmalloc.c",
          "type": "blob",
          "size": 3.009765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Versions of malloc and friends that check their results, and never return\n * failure (they call fatalx if they encounter an error).\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatalx(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatalx(\"xmalloc: allocating %zu bytes: %s\",\n\t\t    size, strerror(errno));\n\treturn ptr;\n}\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatalx(\"xcalloc: zero size\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatalx(\"xcalloc: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n\treturn ptr;\n}\n\nvoid *\nxrealloc(void *ptr, size_t size)\n{\n\treturn xreallocarray(ptr, 1, size);\n}\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tif (nmemb == 0 || size == 0)\n\t\tfatalx(\"xreallocarray: zero size\");\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatalx(\"xreallocarray: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n\treturn new_ptr;\n}\n\nvoid *\nxrecallocarray(void *ptr, size_t oldnmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tif (nmemb == 0 || size == 0)\n\t\tfatalx(\"xrecallocarray: zero size\");\n\tnew_ptr = recallocarray(ptr, oldnmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatalx(\"xrecallocarray: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n\treturn new_ptr;\n}\n\nchar *\nxstrdup(const char *str)\n{\n\tchar *cp;\n\n\tif ((cp = strdup(str)) == NULL)\n\t\tfatalx(\"xstrdup: %s\", strerror(errno));\n\treturn cp;\n}\n\nchar *\nxstrndup(const char *str, size_t maxlen)\n{\n\tchar *cp;\n\n\tif ((cp = strndup(str, maxlen)) == NULL)\n\t\tfatalx(\"xstrndup: %s\", strerror(errno));\n\treturn cp;\n}\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = xvasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\treturn i;\n}\n\nint\nxvasprintf(char **ret, const char *fmt, va_list ap)\n{\n\tint i;\n\n\ti = vasprintf(ret, fmt, ap);\n\n\tif (i == -1)\n\t\tfatalx(\"xasprintf: %s\", strerror(errno));\n\n\treturn i;\n}\n\nint\nxsnprintf(char *str, size_t len, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = xvsnprintf(str, len, fmt, ap);\n\tva_end(ap);\n\n\treturn i;\n}\n\nint\nxvsnprintf(char *str, size_t len, const char *fmt, va_list ap)\n{\n\tint i;\n\n\tif (len > INT_MAX)\n\t\tfatalx(\"xsnprintf: len > INT_MAX\");\n\n\ti = vsnprintf(str, len, fmt, ap);\n\n\tif (i < 0 || i >= (int)len)\n\t\tfatalx(\"xsnprintf: overflow\");\n\n\treturn i;\n}\n"
        },
        {
          "name": "xmalloc.h",
          "type": "blob",
          "size": 1.650390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Created: Mon Mar 20 22:09:17 1995 ylo\n *\n * Versions of malloc and friends that check their results, and never return\n * failure (they call fatal if they encounter an error).\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n\n#ifndef XMALLOC_H\n#define XMALLOC_H\n\n#if !defined(__bounded__)\n#define __bounded__(x, y, z)\n#endif\n\nvoid\t*xmalloc(size_t);\nvoid\t*xcalloc(size_t, size_t);\nvoid\t*xrealloc(void *, size_t);\nvoid\t*xreallocarray(void *, size_t, size_t);\nvoid\t*xrecallocarray(void *, size_t, size_t, size_t);\nchar\t*xstrdup(const char *);\nchar\t*xstrndup(const char *, size_t);\nint\t xasprintf(char **, const char *, ...)\n\t\t__attribute__((__format__ (printf, 2, 3)))\n\t\t__attribute__((__nonnull__ (2)));\nint\t xvasprintf(char **, const char *, va_list)\n\t\t__attribute__((__format__ (printf, 2, 0)))\n\t\t__attribute__((__nonnull__ (2)));\nint\t xsnprintf(char *, size_t, const char *, ...)\n\t\t__attribute__((__format__ (printf, 3, 4)))\n\t\t__attribute__((__nonnull__ (3)))\n\t\t__attribute__((__bounded__ (__string__, 1, 2)));\nint\t xvsnprintf(char *, size_t, const char *, va_list)\n\t\t__attribute__((__format__ (printf, 3, 0)))\n\t\t__attribute__((__nonnull__ (3)))\n\t\t__attribute__((__bounded__ (__string__, 1, 2)));\n\n#endif\t/* XMALLOC_H */\n"
        }
      ]
    }
  ]
}