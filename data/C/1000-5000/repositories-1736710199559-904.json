{
  "metadata": {
    "timestamp": 1736710199559,
    "page": 904,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "LemonBoy/bar",
      "stars": 1630,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "lemonbar\n*.o\n*.swp\n*~\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (C) 2012 The Lemon Man\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1669921875,
          "content": "# This snippet has been shmelessly stol^Hborrowed from thestinger's repose Makefile\nVERSION = 1.4\nGIT_DESC=$(shell test -d .git && git describe --always 2>/dev/null)\n\nifneq \"$(GIT_DESC)\" \"\"\n\tVERSION=$(GIT_DESC)\nendif\n\nCC\t?= gcc\nCFLAGS += -Wall -std=c99 -Os -DVERSION=\"\\\"$(VERSION)\\\"\" -D_GNU_SOURCE\nLDFLAGS += -lxcb -lxcb-xinerama -lxcb-randr\nCFDEBUG = -g3 -pedantic -Wall -Wunused-parameter -Wlong-long \\\n          -Wsign-conversion -Wconversion -Wimplicit-function-declaration\n\nEXEC = lemonbar\nSRCS = lemonbar.c utils.c\nOBJS = ${SRCS:.c=.o}\n\nPREFIX?=/usr\nBINDIR=${PREFIX}/bin\n\nall: ${EXEC}\n\ndoc: README.pod\n\tpod2man --section=1 --center=\"lemonbar Manual\" --name \"lemonbar\" --release=\"lemonbar $(VERSION)\" README.pod > lemonbar.1\n\n.c.o:\n\t${CC} ${CFLAGS} -o $@ -c $<\n\n${EXEC}: ${OBJS}\n\t${CC} -o ${EXEC} ${OBJS} ${LDFLAGS}\n\ndebug: ${EXEC}\ndebug: CC += ${CFDEBUG}\n\nclean:\n\trm -f ./*.o ./*.1\n\trm -f ./${EXEC}\n\ninstall: lemonbar doc\n\tinstall -D -m 755 lemonbar ${DESTDIR}${BINDIR}/lemonbar\n\tinstall -D -m 644 lemonbar.1 ${DESTDIR}${PREFIX}/share/man/man1/lemonbar.1\n\nuninstall:\n\trm -f ${DESTDIR}${BINDIR}/lemonbar\n\trm -f $(DESTDIR)$(PREFIX)/share/man/man1/lemonbar.1\n\n.PHONY: all debug clean install\n"
        },
        {
          "name": "README.pod",
          "type": "blob",
          "size": 5.673828125,
          "content": "=head1 NAME\n\nlemonbar - Featherweight lemon-scented bar\n\n=for HTML <img src=\"https://github.com/LemonBoy/bar/workflows/Does%20this%20build%20look%20infected%3F/badge.svg\">\n\n=head1 SYNOPSIS\n\nI<lemonbar> [-h | -g I<width>B<x>I<height>B<+>I<x>B<+>I<y> | -o | -b | -d | -f I<font> | -p | -n I<name> | -u I<pixel> | -B I<color> | -F I<color> | -U I<color>]\n\n=head1 DESCRIPTION\n\nB<lemonbar> (formerly known as B<bar>) is a lightweight statusbar based on XCB.\nProvides full UTF-8 support, basic formatting, RandR and Xinerama support and\nEWMH compliance without wasting your precious memory.\n\n=head1 INPUT\n\nThe data to be parsed is read from the standard input, parsing and printing the\ninput data are delayed until a newline is found.\n\n=head1 OPTIONS\n\n=over\n\n=item B<-h>\n\nDisplay the help and exit.\n\n=item B<-g> I<width>B<x>I<height>B<+>I<x>B<+>I<y>\n\nSet the window geometry. If a parameter is omitted it's filled with the default value. If the I<y> parameter is specified along with the B<-b> switch then the position is relative to the bottom of the screen.\n\n=item B<-o> I<name>\n\nSet next output to I<name>. May be used multiple times; order is significant. If any B<-o> options are given, only B<-o> specified monitors will be used. Invalid output names are silently ignored. (only supported on randr configurations at this time)\n\n=item B<-b>\n\nDock the bar at the bottom of the screen.\n\n=item B<-d>\n\nForce docking without asking the window manager. This is needed if the window manager isn't EWMH compliant.\n\n=item B<-f> I<font>\n\nSpecifies a font to use. Can be used multiple times to load more than a single\nfont.\n\n=item B<-p>\n\nMake the bar permanent, don't exit after the standard input is closed.\n\n=item B<-n> I<name>\n\nSet the WM_NAME atom value for the bar.\n\n=item B<-u> I<pixel>\n\nSets the underline width in pixels. The default is 1.\n\n=item B<-B> I<color>\n\nSet the background color of the bar. I<color> must be specified in the hex format (#aarrggbb, #rrggbb, #rgb). If no compositor such as compton or xcompmgr is running the alpha channel is silently ignored.\n\n=item B<-F> I<color>\n\nSet the foreground color of the bar. Accepts the same color formats as B<-B>.\n\n=item B<-U> I<color>\n\nSet the underline color of the bar. Accepts the same color formats as B<-B>.\n\n=back\n\n=head1 FORMATTING\n\nlemonbar provides a screenrc-inspired formatting syntax to allow full customization at runtime. Every formatting block is opened with C<%{> and closed by C<}> and accepts the following commands, the parser tries its best to handle malformed input. Use C<%%> to get a literal percent sign (C<%>).\n\n=over\n\n=item B<R>\n\nSwap the current background and foreground colors.\n\n=item B<l>\n\nAligns the following text to the left side of the screen.\n\n=item B<c>\n\nAligns the following text to the center of the screen.\n\n=item B<r>\n\nAligns the following text to the right side of the screen.\n\n=item B<O>I<width>\n\nOffset the current position by I<width> pixels in the alignment direction.\n\n=item B<B>I<color>\n\nSet the text background color. The parameter I<color> can be I<-> or a color in one of the formats mentioned before. The special value I<-> resets the color to the default one.\n\n=item B<F>I<color>\n\nSet the text foreground color. The parameter I<color> can be I<-> or a color in one of the formats mentioned before. The special value I<-> resets the color to the default one.\n\n=item B<T>I<index>\n\nSet the font used to draw the following text. The parameter I<index> can either be I<-> or the 1-based index of the slot which contains the desired font. If the parameter is I<-> lemonbar resets to the normal behavior (matching the first font that can be used for the character). If the selected font can't be used to draw a character, lemonbar will fall back to normal behavior for that character\n\n=item B<U>I<color>\n\nSet the text underline color. The parameter I<color> can be I<-> or a color in one of the formats mentioned before. The special value I<-> resets the color to the default one.\n\n=item B<A>I<button>:I<command>:\n\nCreate a clickable area starting from the current position, when the area is clicked I<command> is printed on stdout. The area is closed when a B<A> token, not followed by : is encountered.\n\nEg. I<%{A:reboot:} Click here to reboot %{A}>\n\nThe I<button> field is optional, it defaults to the left button, and it's a number ranging from 1 to 5 which maps to the left, middle, right, scroll up and scroll down movements. Your mileage may vary.\n\nNested clickable areas can trigger different commands.\n\nEg. I<%{A:reboot:}%{A3:halt:} Left click to reboot, right click to shutdown %{A}%{A}>\n\n=item B<S>I<dir>\n\nChange the monitor the bar is rendered to. I<dir> can be either\n\n=over\n\n=item B<+>/B<->\n\nNext/previous monitor.\n\n=item B<f>/B<l>\n\nFirst/last monitor.\n\n=item I<0-9>\n\nNth monitor.\n\n=item I<n>B<NAME>\n\nNamed monitor.\nEg. I<%{SnHDMI-0} This text will show up on the HDMI-0 output>\n\n=back\n\n=back\n\nB<Attribute modifiers>\n\n=over\n\n=item B<+>I<attribute>\n\nSet the attribute I<attribute> for the following text.\n\n=item B<->I<attribute>\n\nUnset the attribute I<attribute> for the following text.\n\n=item B<!>I<attribute>\n\nToggle the attribute I<attribute> for the following text.\n\n=back\n\nWhere I<attribute> is one of the following\n\n=over\n\n=item B<o>\n\nDraw a line over the text.\n\n=item B<u>\n\nDraw a line under the text.\n\n=back\n\n=head1 OUTPUT\n\nClicking on an area makes lemonbar output the command to stdout, followed by a newline, allowing the user to pipe it into a script, execute it or simply ignore it. Simple and powerful, that's it.\n\n=head1 WWW\n\nL<git repository|https://github.com/LemonBoy/bar>\n\n=head1 AUTHOR\n\n2012-2020 (C) The Lemon Man\n\nXinerama support was kindly contributed by Stebalien\n\nRandR support was kindly contributed by jvvv\n\nClickable areas support was heavily based off u-ra contribution\n"
        },
        {
          "name": "lemonbar.c",
          "type": "blob",
          "size": 46.47265625,
          "content": "// vim:sw=4:ts=4:et:\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <signal.h>\n#include <poll.h>\n#include <getopt.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <xcb/xcb.h>\n#include <xcb/xcbext.h>\n#if WITH_XINERAMA\n#include <xcb/xinerama.h>\n#endif\n#include <xcb/randr.h>\n#include \"utils.h\"\n\n// Here be dragons\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) < (b) ? (a) : (b))\n\ntypedef struct font_t {\n    xcb_font_t ptr;\n    int descent, height, width;\n    uint16_t char_max;\n    uint16_t char_min;\n    xcb_charinfo_t *width_lut;\n} font_t;\n\ntypedef struct monitor_t {\n    char *name;\n    int x, y, width, height;\n    xcb_window_t window;\n    xcb_pixmap_t pixmap;\n    struct monitor_t *prev, *next;\n} monitor_t;\n\ntypedef struct area_t {\n    unsigned begin;\n    unsigned end;\n    bool complete;\n    unsigned align;\n    unsigned button;\n    xcb_window_t window;\n    char *cmd;\n} area_t;\n\ntypedef union rgba_t {\n    struct {\n        uint8_t b;\n        uint8_t g;\n        uint8_t r;\n        uint8_t a;\n    };\n    uint32_t v;\n} rgba_t;\n\ntypedef struct area_stack_t {\n    area_t *ptr;\n    unsigned int index, alloc;\n} area_stack_t;\n\nenum {\n    ATTR_OVERL = (1<<0),\n    ATTR_UNDERL = (1<<1),\n};\n\nenum {\n    ALIGN_L = 0,\n    ALIGN_C,\n    ALIGN_R\n};\n\nenum {\n    GC_DRAW = 0,\n    GC_CLEAR,\n    GC_ATTR,\n    GC_MAX\n};\n\nstatic xcb_connection_t *c;\nstatic xcb_screen_t *scr;\nstatic xcb_gcontext_t gc[GC_MAX];\nstatic xcb_visualid_t visual;\nstatic xcb_colormap_t colormap;\nstatic monitor_t *monhead, *montail;\nstatic font_t **font_list = NULL;\nstatic int font_count = 0;\nstatic int font_index = -1;\nstatic uint32_t attrs = 0;\nstatic bool dock = false;\nstatic bool topbar = true;\nstatic int bw = -1, bh = -1, bx = 0, by = 0;\nstatic int bu = 1; // Underline height\nstatic rgba_t fgc, bgc, ugc;\nstatic rgba_t dfgc, dbgc, dugc;\nstatic area_stack_t area_stack;\n\nstatic const rgba_t BLACK = (rgba_t){ .r = 0, .g = 0, .b = 0, .a = 255 };\nstatic const rgba_t WHITE = (rgba_t){ .r = 255, .g = 255, .b = 255, .a = 255 };\n\nstatic int num_outputs = 0;\nstatic char **output_names = NULL;\n\nvoid\nupdate_gc (void)\n{\n    xcb_change_gc(c, gc[GC_DRAW], XCB_GC_FOREGROUND, (const uint32_t []){ fgc.v });\n    xcb_change_gc(c, gc[GC_CLEAR], XCB_GC_FOREGROUND, (const uint32_t []){ bgc.v });\n    xcb_change_gc(c, gc[GC_ATTR], XCB_GC_FOREGROUND, (const uint32_t []){ ugc.v });\n}\n\nvoid\nfill_rect (xcb_drawable_t d, xcb_gcontext_t _gc, int x, int y, int width, int height)\n{\n    xcb_poly_fill_rectangle(c, d, _gc, 1, (const xcb_rectangle_t []){ { x, y, width, height } });\n}\n\n// Apparently xcb cannot seem to compose the right request for this call, hence we have to do it by\n// ourselves.\n// The funcion is taken from 'wmdia' (http://wmdia.sourceforge.net/)\nxcb_void_cookie_t xcb_poly_text_16_simple(xcb_connection_t * c,\n    xcb_drawable_t drawable, xcb_gcontext_t gc, int16_t x, int16_t y,\n    uint32_t len, const uint16_t *str)\n{\n    static const xcb_protocol_request_t xcb_req = {\n        5,                // count\n        0,                // ext\n        XCB_POLY_TEXT_16, // opcode\n        1                 // isvoid\n    };\n    struct iovec xcb_parts[7];\n    uint8_t xcb_lendelta[2];\n    xcb_void_cookie_t xcb_ret;\n    xcb_poly_text_8_request_t xcb_out;\n\n    xcb_out.pad0 = 0;\n    xcb_out.drawable = drawable;\n    xcb_out.gc = gc;\n    xcb_out.x = x;\n    xcb_out.y = y;\n\n    xcb_lendelta[0] = len;\n    xcb_lendelta[1] = 0;\n\n    xcb_parts[2].iov_base = (char *)&xcb_out;\n    xcb_parts[2].iov_len = sizeof(xcb_out);\n    xcb_parts[3].iov_base = 0;\n    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;\n\n    xcb_parts[4].iov_base = xcb_lendelta;\n    xcb_parts[4].iov_len = sizeof(xcb_lendelta);\n    xcb_parts[5].iov_base = (char *)str;\n    xcb_parts[5].iov_len = len * sizeof(int16_t);\n\n    xcb_parts[6].iov_base = 0;\n    xcb_parts[6].iov_len = -(xcb_parts[4].iov_len + xcb_parts[5].iov_len) & 3;\n\n    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);\n\n    return xcb_ret;\n}\n\nint\nshift (monitor_t *mon, int x, int align, int ch_width)\n{\n    switch (align) {\n        case ALIGN_C:\n            xcb_copy_area(c, mon->pixmap, mon->pixmap, gc[GC_DRAW],\n                    mon->width / 2 - x / 2, 0,\n                    mon->width / 2 - (x + ch_width) / 2, 0,\n                    x, bh);\n            x = mon->width / 2 - (x + ch_width) / 2 + x;\n            break;\n        case ALIGN_R:\n            xcb_copy_area(c, mon->pixmap, mon->pixmap, gc[GC_DRAW],\n                    mon->width - x, 0,\n                    mon->width - x - ch_width, 0,\n                    x, bh);\n            x = mon->width - ch_width;\n            break;\n    }\n\n    // Draw the background first\n    fill_rect(mon->pixmap, gc[GC_CLEAR], x, 0, ch_width, bh);\n    return x;\n}\n\nvoid\ndraw_lines (monitor_t *mon, int x, int w)\n{\n    /* We can render both at the same time */\n    if (attrs & ATTR_OVERL)\n        fill_rect(mon->pixmap, gc[GC_ATTR], x, 0, w, bu);\n    if (attrs & ATTR_UNDERL)\n        fill_rect(mon->pixmap, gc[GC_ATTR], x, bh - bu, w, bu);\n}\n\nvoid\ndraw_shift (monitor_t *mon, int x, int align, int w)\n{\n    x = shift(mon, x, align, w);\n    draw_lines(mon, x, w);\n}\n\nint\ndraw_char (monitor_t *mon, font_t *cur_font, int x, int align, uint16_t ch)\n{\n    int ch_width = (cur_font->width_lut) ?\n        cur_font->width_lut[ch - cur_font->char_min].character_width:\n        cur_font->width;\n\n    x = shift(mon, x, align, ch_width);\n\n    // xcb accepts string in UCS-2 BE, so swap\n    ch = (ch >> 8) | (ch << 8);\n\n    // The coordinates here are those of the baseline\n    xcb_poly_text_16_simple(c, mon->pixmap, gc[GC_DRAW],\n                            x, bh / 2 + cur_font->height / 2 - cur_font->descent,\n                            1, &ch);\n\n    draw_lines(mon, x, ch_width);\n\n    return ch_width;\n}\n\nrgba_t\nparse_color (const char *str, char **end, const rgba_t def)\n{\n    int string_len;\n    char *ep;\n\n    if (!str)\n        return def;\n\n    // Reset\n    if (str[0] == '-') {\n        if (end)\n            *end = (char *)str + 1;\n\n        return def;\n    }\n\n    // Hex representation\n    if (str[0] != '#') {\n        if (end)\n            *end = (char *)str;\n\n        fprintf(stderr, \"Invalid color specified\\n\");\n        return def;\n    }\n\n    errno = 0;\n    rgba_t tmp = (rgba_t)(uint32_t)strtoul(str + 1, &ep, 16);\n\n    if (end)\n        *end = ep;\n\n    // Some error checking is definitely good\n    if (errno) {\n        fprintf(stderr, \"Invalid color specified\\n\");\n        return def;\n    }\n\n    string_len = ep - (str + 1);\n\n    switch (string_len) {\n        case 3:\n            // Expand the #rgb format into #rrggbb (aa is set to 0xff)\n            tmp.v = (tmp.v & 0xf00) * 0x1100\n                  | (tmp.v & 0x0f0) * 0x0110\n                  | (tmp.v & 0x00f) * 0x0011;\n        case 6:\n            // If the code is in #rrggbb form then assume it's opaque\n            tmp.a = 255;\n            break;\n        case 7:\n        case 8:\n            // Colors in #aarrggbb format, those need no adjustments\n            break;\n        default:\n            fprintf(stderr, \"Invalid color specified\\n\");\n            return def;\n    }\n\n    // Premultiply the alpha in\n    if (tmp.a) {\n        // The components are clamped automagically as the rgba_t is made of uint8_t\n        return (rgba_t){\n            .r = (tmp.r * tmp.a) / 255,\n            .g = (tmp.g * tmp.a) / 255,\n            .b = (tmp.b * tmp.a) / 255,\n            .a = tmp.a,\n        };\n    }\n\n    return (rgba_t)0U;\n}\n\nvoid\nset_attribute (const char modifier, const char attribute)\n{\n    uint32_t mask;\n\n    switch (attribute) {\n        case 'o': mask = ATTR_OVERL;  break;\n        case 'u': mask = ATTR_UNDERL; break;\n        default:\n            fprintf(stderr, \"Invalid attribute \\\"%c\\\" found\\n\", attribute);\n            return;\n    }\n\n    switch (modifier) {\n        case '+': attrs |=  mask; break;\n        case '-': attrs &= ~mask; break;\n        case '!': attrs ^=  mask; break;\n    }\n}\n\n\narea_t *\narea_get (xcb_window_t win, const int btn, const int x)\n{\n    // Looping backwards ensures that we get the innermost area first\n    for (int i = area_stack.index - 1; i >= 0; i--) {\n        area_t *a = &area_stack.ptr[i];\n        if (a->window == win && a->button == btn && x >= a->begin && x < a->end)\n            return a;\n    }\n    return NULL;\n}\n\nvoid\narea_shift (xcb_window_t win, const int align, int delta)\n{\n    if (align == ALIGN_L)\n        return;\n    if (align == ALIGN_C)\n        delta /= 2;\n\n    for (int i = 0; i < area_stack.index; i++) {\n        area_t *a = &area_stack.ptr[i];\n        if (a->window == win && a->align == align && !a->complete) {\n            a->begin -= delta;\n            a->end -= delta;\n        }\n    }\n}\n\nbool\narea_add (char *str, const char *optend, char **end, monitor_t *mon, const int x, const int align, const int button)\n{\n    int i;\n    char *trail;\n    area_t *a;\n\n    // A wild close area tag appeared!\n    if (*str != ':') {\n        *end = str;\n\n        // Find most recent unclosed area.\n        for (i = area_stack.index - 1; i >= 0 && !area_stack.ptr[i].complete; i--)\n            ;\n        a = &area_stack.ptr[i];\n\n        // Basic safety checks\n        if (!a->cmd || a->align != align || a->window != mon->window) {\n            fprintf(stderr, \"Invalid geometry for the clickable area\\n\");\n            return false;\n        }\n\n        const int size = x - a->begin;\n\n        switch (align) {\n            case ALIGN_L:\n                a->end = x;\n                break;\n            case ALIGN_C:\n                a->begin = mon->width / 2 - size / 2 + a->begin / 2;\n                a->end = a->begin + size;\n                break;\n            case ALIGN_R:\n                // The newest is the rightmost one\n                a->begin = mon->width - size;\n                a->end = mon->width;\n                break;\n        }\n\n        a->complete = false;\n        return true;\n    }\n\n    if (area_stack.index + 1 > area_stack.alloc) {\n        area_stack.ptr = xreallocarray(area_stack.ptr, area_stack.index + 1,\n                sizeof(area_t));\n        area_stack.alloc += 1;\n    }\n    a = &area_stack.ptr[area_stack.index++];\n\n    // Found the closing : and check if it's just an escaped one\n    for (trail = strchr(++str, ':'); trail && trail[-1] == '\\\\'; trail = strchr(trail + 1, ':'))\n        ;\n\n    // Find the trailing : and make sure it's within the formatting block, also reject empty commands\n    if (!trail || str == trail || trail > optend) {\n        *end = str;\n        return false;\n    }\n\n    *trail = '\\0';\n\n    // Sanitize the user command by unescaping all the :\n    for (char *needle = str; *needle; needle++) {\n        int delta = trail - &needle[1];\n        if (needle[0] == '\\\\' && needle[1] == ':') {\n            memmove(&needle[0], &needle[1], delta);\n            needle[delta] = 0;\n        }\n    }\n\n    // This is a pointer to the string buffer allocated in the main\n    a->cmd = str;\n    a->complete = true;\n    a->align = align;\n    a->begin = x;\n    a->window = mon->window;\n    a->button = button;\n\n    *end = trail + 1;\n\n    return true;\n}\n\nbool\nfont_has_glyph (font_t *font, const uint16_t c)\n{\n    if (c < font->char_min || c > font->char_max)\n        return false;\n\n    if (font->width_lut && font->width_lut[c - font->char_min].character_width == 0)\n        return false;\n\n    return true;\n}\n\n// returns NULL if character cannot be printed\nfont_t *\nselect_drawable_font (const uint16_t c)\n{\n    // If the user has specified a font to use, try that first.\n    if (font_index != -1 && font_has_glyph(font_list[font_index - 1], c))\n        return font_list[font_index - 1];\n\n    // If the end is reached without finding an appropriate font, return NULL.\n    // If the font can draw the character, return it.\n    for (int i = 0; i < font_count; i++) {\n        if (font_has_glyph(font_list[i], c))\n            return font_list[i];\n    }\n    return NULL;\n}\n\nint\npos_to_absolute(monitor_t *mon, int pos, int align)\n{\n    switch (align) {\n        case ALIGN_L: return pos;\n        case ALIGN_R: return mon->width - pos;\n        case ALIGN_C: return mon->width / 2 + pos / 2;\n    }\n\n    return 0;\n}\n\nvoid\nparse (char *text)\n{\n    font_t *cur_font;\n    monitor_t *cur_mon;\n    int pos_x, align, button;\n    char *p = text, *block_end, *ep;\n\n    pos_x = 0;\n    align = ALIGN_L;\n    cur_mon = monhead;\n\n    // Reset the default color set\n    bgc = dbgc;\n    fgc = dfgc;\n    ugc = dugc;\n    update_gc();\n    // Reset the default attributes\n    attrs = 0;\n\n    // Reset the stack position\n    area_stack.index = 0;\n\n    for (monitor_t *m = monhead; m != NULL; m = m->next)\n        fill_rect(m->pixmap, gc[GC_CLEAR], 0, 0, m->width, bh);\n\n    for (;;) {\n        if (*p == '\\0' || *p == '\\n')\n            return;\n\n        if (p[0] == '%' && p[1] == '{' && (block_end = strchr(p++, '}'))) {\n            p++;\n            while (p < block_end) {\n                while (isspace(*p))\n                    p++;\n\n                switch (*p++) {\n                    // Enable/disable attributes.\n                    case '+': set_attribute('+', *p++); break;\n                    case '-': set_attribute('-', *p++); break;\n                    case '!': set_attribute('!', *p++); break;\n\n                    // Reverse foreground/background color.\n                    case 'R': {\n                        rgba_t tmp = fgc;\n                        fgc = bgc;\n                        bgc = tmp;\n                        update_gc();\n                    } break;\n\n                    // Alignment specifiers.\n                    // Keep track of where we are and where we're moving to so\n                    // that underlines/overlines are correctly drawn over the\n                    // empty space.\n                    case 'l': {\n                        int left_ep = 0;\n                        int right_ep = pos_to_absolute(cur_mon, pos_x, align);\n                        draw_lines(cur_mon, left_ep, right_ep - left_ep);\n                        pos_x = 0; align = ALIGN_L;\n                    } break;\n                    case 'c': {\n                        int left_ep = pos_to_absolute(cur_mon, pos_x, align);\n                        int right_ep = cur_mon->width / 2;\n                        if (right_ep < left_ep) {\n                            int tmp = left_ep;\n                            left_ep = right_ep;\n                            right_ep = tmp;\n                        }\n                        draw_lines(cur_mon, left_ep, right_ep - left_ep);\n                        pos_x = 0; align = ALIGN_C;\n                    } break;\n                    case 'r': {\n                        int left_ep = pos_to_absolute(cur_mon, pos_x, align);\n                        int right_ep = cur_mon->width;\n                        if (right_ep < left_ep) {\n                            int tmp = left_ep;\n                            left_ep = right_ep;\n                            right_ep = tmp;\n                        }\n                        draw_lines(cur_mon, left_ep, right_ep - left_ep);\n                        pos_x = 0; align = ALIGN_R;\n                    } break;\n\n                    // Define input area.\n                    case 'A': {\n                        button = XCB_BUTTON_INDEX_1;\n                        // The range is 1-5\n                        if (isdigit(*p) && (*p > '0' && *p < '6'))\n                            button = *p++ - '0';\n                        if (!area_add(p, block_end, &p, cur_mon, pos_x, align, button))\n                            return;\n                    } break;\n\n                    // Set background/foreground/underline color.\n                    case 'B': bgc = parse_color(p, &p, dbgc); update_gc(); break;\n                    case 'F': fgc = parse_color(p, &p, dfgc); update_gc(); break;\n                    case 'U': ugc = parse_color(p, &p, dugc); update_gc(); break;\n\n                    // Set current monitor used for drawing.\n                    case 'S': {\n                        monitor_t *orig_mon = cur_mon;\n\n                        switch (*p) {\n                            case '+': // Next monitor.\n                                if (cur_mon->next) cur_mon = cur_mon->next;\n                                p += 1;\n                                break;\n                            case '-': // Previous monitor.\n                                if (cur_mon->prev) cur_mon = cur_mon->prev;\n                                p += 1;\n                                break;\n                            case 'f': // First monitor.\n                                cur_mon = monhead;\n                                p += 1;\n                                break;\n                            case 'l': // Last monitor.\n                                cur_mon = montail ? montail : monhead;\n                                p += 1;\n                                break;\n                            case 'n': { // Named monitor.\n                                const size_t name_len = block_end - (p + 1);\n                                cur_mon = monhead;\n                                while (cur_mon) {\n                                    if (cur_mon->name &&\n                                            !strncmp(cur_mon->name, p + 1, name_len) &&\n                                            cur_mon->name[name_len] == '\\0')\n                                        break;\n                                    cur_mon = cur_mon->next;\n                                }\n                                if (!cur_mon) cur_mon = orig_mon;\n                                p += 1 + name_len;\n                            } break;\n                            case '0' ... '9': // Numbered monitor.\n                                cur_mon = monhead;\n                                for (int i = 0; i != *p-'0' && cur_mon->next; i++)\n                                    cur_mon = cur_mon->next;\n                                p += 1;\n                                break;\n                            default:\n                                fprintf(stderr, \"Unknown S specifier '%c'\\n\", *p++);\n                                break;\n                        }\n\n                        if (orig_mon != cur_mon) {\n                            pos_x = 0;\n                            align = ALIGN_L;\n                        }\n                    } break;\n\n                    // Draw a N-pixel wide empty character.\n                    case 'O': {\n                        errno = 0;\n                        int w = (int) strtoul(p, &p, 10);\n                        if (errno)\n                            continue;\n\n                        draw_shift(cur_mon, pos_x, align, w);\n\n                        pos_x += w;\n                        area_shift(cur_mon->window, align, w);\n                    } break;\n\n                    case 'T': {\n                          if (*p == '-') {\n                              // Switch to automatic font selection.\n                              font_index = -1;\n                              p++;\n                          } else if (isdigit(*p)) {\n                              font_index = (int)strtoul(p, &ep, 10);\n                              // User-specified 'font_index' ∊ (0,font_count]\n                              // Otherwise just fallback to the automatic font selection\n                              if (!font_index || font_index > font_count) {\n                                  fprintf(stderr, \"Invalid font index %d\\n\", font_index);\n                                  font_index = -1;\n                              }\n                              p = ep;\n                          } else {\n                              // Swallow the invalid character and keep parsing.\n                              fprintf(stderr, \"Invalid font slot \\\"%c\\\"\\n\", *p++);\n                          }\n                    } break;\n\n                    // In case of error keep parsing after the closing }\n                    default:\n                        p = block_end;\n                }\n            }\n            // Eat the trailing }\n            p++;\n        } else { // utf-8 -> ucs-2\n            // Escaped % symbol, eat the first one\n            if (p[0] == '%' && p[1] == '%')\n                p++;\n\n            uint8_t *utf = (uint8_t *)p;\n            uint16_t ucs;\n\n            // ASCII\n            if (utf[0] < 0x80) {\n                ucs = utf[0];\n                p  += 1;\n            }\n            // Two byte utf8 sequence\n            else if ((utf[0] & 0xe0) == 0xc0) {\n                ucs = (utf[0] & 0x1f) << 6 | (utf[1] & 0x3f);\n                p += 2;\n            }\n            // Three byte utf8 sequence\n            else if ((utf[0] & 0xf0) == 0xe0) {\n                ucs = (utf[0] & 0xf) << 12 | (utf[1] & 0x3f) << 6 | (utf[2] & 0x3f);\n                p += 3;\n            }\n            // Four byte utf8 sequence\n            else if ((utf[0] & 0xf8) == 0xf0) {\n                ucs = 0xfffd;\n                p += 4;\n            }\n            // Five byte utf8 sequence\n            else if ((utf[0] & 0xfc) == 0xf8) {\n                ucs = 0xfffd;\n                p += 5;\n            }\n            // Six byte utf8 sequence\n            else if ((utf[0] & 0xfe) == 0xfc) {\n                ucs = 0xfffd;\n                p += 6;\n            }\n            // Not a valid utf-8 sequence\n            else {\n                ucs = utf[0];\n                p += 1;\n            }\n\n            cur_font = select_drawable_font(ucs);\n            if (!cur_font)\n                continue;\n\n            xcb_change_gc(c, gc[GC_DRAW] , XCB_GC_FONT, (const uint32_t []){ cur_font->ptr });\n\n            int w = draw_char(cur_mon, cur_font, pos_x, align, ucs);\n\n            pos_x += w;\n            area_shift(cur_mon->window, align, w);\n        }\n    }\n}\n\nvoid\nfont_load (const char *pattern)\n{\n    xcb_query_font_cookie_t queryreq;\n    xcb_query_font_reply_t *font_info;\n    xcb_void_cookie_t cookie;\n    xcb_font_t font;\n\n    font = xcb_generate_id(c);\n\n    cookie = xcb_open_font_checked(c, font, strlen(pattern), pattern);\n    if (xcb_request_check (c, cookie)) {\n        fprintf(stderr, \"Could not load font \\\"%s\\\"\\n\", pattern);\n        return;\n    }\n\n    font_t *ret = xcalloc(1, sizeof(font_t));\n\n    queryreq = xcb_query_font(c, font);\n    font_info = xcb_query_font_reply(c, queryreq, NULL);\n\n    ret->ptr = font;\n    ret->descent = font_info->font_descent;\n    ret->height = font_info->font_ascent + font_info->font_descent;\n    ret->width = font_info->max_bounds.character_width;\n    ret->char_max = font_info->max_byte1 << 8 | font_info->max_char_or_byte2;\n    ret->char_min = font_info->min_byte1 << 8 | font_info->min_char_or_byte2;\n\n    // Copy over the width lut as it's part of font_info\n    size_t lut_size = sizeof(xcb_charinfo_t) *\n            xcb_query_font_char_infos_length(font_info);\n    if (lut_size) {\n        ret->width_lut = xmalloc(lut_size);\n        memcpy(ret->width_lut, xcb_query_font_char_infos(font_info), lut_size);\n    }\n\n    free(font_info);\n\n    font_list = xreallocarray(font_list, font_count + 1, sizeof(font_t));\n    if (!font_list) {\n        fprintf(stderr, \"Failed to allocate %d font descriptors\", font_count + 1);\n        exit(EXIT_FAILURE);\n    }\n    font_list[font_count++] = ret;\n}\n\nenum {\n    NET_WM_WINDOW_TYPE,\n    NET_WM_WINDOW_TYPE_DOCK,\n    NET_WM_DESKTOP,\n    NET_WM_STRUT_PARTIAL,\n    NET_WM_STRUT,\n    NET_WM_STATE,\n    NET_WM_STATE_STICKY,\n    NET_WM_STATE_ABOVE,\n};\n\nvoid\nset_ewmh_atoms (void)\n{\n    const char *atom_names[] = {\n        \"_NET_WM_WINDOW_TYPE\",\n        \"_NET_WM_WINDOW_TYPE_DOCK\",\n        \"_NET_WM_DESKTOP\",\n        \"_NET_WM_STRUT_PARTIAL\",\n        \"_NET_WM_STRUT\",\n        \"_NET_WM_STATE\",\n        // Leave those at the end since are batch-set\n        \"_NET_WM_STATE_STICKY\",\n        \"_NET_WM_STATE_ABOVE\",\n    };\n    const int atoms = sizeof(atom_names)/sizeof(char *);\n    xcb_intern_atom_cookie_t atom_cookie[atoms];\n    xcb_atom_t atom_list[atoms];\n    xcb_intern_atom_reply_t *atom_reply;\n\n    // As suggested fetch all the cookies first (yum!) and then retrieve the\n    // atoms to exploit the async'ness\n    for (int i = 0; i < atoms; i++)\n        atom_cookie[i] = xcb_intern_atom(c, 0, strlen(atom_names[i]), atom_names[i]);\n\n    for (int i = 0; i < atoms; i++) {\n        atom_reply = xcb_intern_atom_reply(c, atom_cookie[i], NULL);\n        if (!atom_reply)\n            return;\n        atom_list[i] = atom_reply->atom;\n        free(atom_reply);\n    }\n\n    // Prepare the strut array\n    for (monitor_t *mon = monhead; mon; mon = mon->next) {\n        int strut[12] = {0};\n        if (topbar) {\n            strut[2] = bh;\n            strut[8] = mon->x;\n            strut[9] = mon->x + mon->width - 1;\n        } else {\n            strut[3]  = bh;\n            strut[10] = mon->x;\n            strut[11] = mon->x + mon->width - 1;\n        }\n\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_WINDOW_TYPE], XCB_ATOM_ATOM, 32, 1, &atom_list[NET_WM_WINDOW_TYPE_DOCK]);\n        xcb_change_property(c, XCB_PROP_MODE_APPEND,  mon->window, atom_list[NET_WM_STATE], XCB_ATOM_ATOM, 32, 2, &atom_list[NET_WM_STATE_STICKY]);\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_DESKTOP], XCB_ATOM_CARDINAL, 32, 1, (const uint32_t []){ -1 } );\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_STRUT_PARTIAL], XCB_ATOM_CARDINAL, 32, 12, strut);\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, atom_list[NET_WM_STRUT], XCB_ATOM_CARDINAL, 32, 4, strut);\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8, 3, \"bar\");\n        xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_CLASS, XCB_ATOM_STRING, 8, 12, \"lemonbar\\0Bar\");\n    }\n}\n\nmonitor_t *\nmonitor_new (int x, int y, int width, int height, char *name)\n{\n    monitor_t *ret;\n\n    ret = xcalloc(1, sizeof(monitor_t));\n    ret->name = name;\n    ret->x = x;\n    ret->y = (topbar ? by : height - bh - by) + y;\n    ret->width = width;\n    ret->height = height;\n    ret->next = ret->prev = NULL;\n    ret->window = xcb_generate_id(c);\n\n    int depth = (visual == scr->root_visual) ? XCB_COPY_FROM_PARENT : 32;\n    xcb_create_window(c, depth, ret->window, scr->root,\n            ret->x, ret->y, width, bh, 0,\n            XCB_WINDOW_CLASS_INPUT_OUTPUT, visual,\n            XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP,\n            (const uint32_t []){ bgc.v, bgc.v, dock, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, colormap });\n\n    ret->pixmap = xcb_generate_id(c);\n    xcb_create_pixmap(c, depth, ret->pixmap, ret->window, width, bh);\n\n    return ret;\n}\n\nvoid\nmonitor_add (monitor_t *mon)\n{\n    if (!monhead) {\n        monhead = mon;\n    } else if (!montail) {\n        montail = mon;\n        monhead->next = mon;\n        mon->prev = monhead;\n    } else {\n        mon->prev = montail;\n        montail->next = mon;\n        montail = montail->next;\n    }\n}\n\nint\nmon_sort_cb (const void *p1, const void *p2)\n{\n    const monitor_t *m1 = (monitor_t *)p1;\n    const monitor_t *m2 = (monitor_t *)p2;\n\n    if (m1->x < m2->x || m1->y + m1->height <= m2->y)\n        return -1;\n    if (m1->x > m2->x || m1->y + m1->height > m2->y)\n        return  1;\n\n    return 0;\n}\n\nvoid\nmonitor_create_chain (monitor_t *mons, const int num)\n{\n    int i;\n    int width = 0, height = 0;\n    int left = bx;\n\n    // Sort before use, but only if specific outputs were not specified on command line\n    if (!num_outputs)\n        qsort(mons, num, sizeof(monitor_t), mon_sort_cb);\n\n    for (i = 0; i < num; i++) {\n        int h = mons[i].y + mons[i].height;\n        // Accumulated width of all monitors\n        width += mons[i].width;\n        // Get height of screen from y_offset + height of lowest monitor\n        if (h >= height)\n        height = h;\n    }\n\n    if (bw < 0)\n        bw = width - bx;\n\n    // Use the first font height as all the font heights have been set to the biggest of the set\n    if (bh < 0 || bh > height)\n        bh = font_list[0]->height + bu + 2;\n\n    // Check the geometry\n    if (bx + bw > width || by + bh > height) {\n        fprintf(stderr, \"The geometry specified doesn't fit the screen!\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Left is a positive number or zero therefore monitors with zero width are excluded\n    width = bw;\n    for (i = 0; i < num; i++) {\n        if (mons[i].y + mons[i].height < by)\n            continue;\n        if (mons[i].width > left) {\n            monitor_t *mon = monitor_new(\n                    mons[i].x + left,\n                    mons[i].y,\n                    min(width, mons[i].width - left),\n                    mons[i].height,\n                    mons[i].name? xstrdup(mons[i].name) : NULL);\n\n            if (!mon)\n                break;\n\n            monitor_add(mon);\n\n            width -= mons[i].width - left;\n\n            // No need to check for other monitors\n            if (width <= 0)\n                break;\n        }\n\n        left -= mons[i].width;\n\n        if (left < 0)\n            left = 0;\n    }\n}\n\nvoid\nget_randr_monitors (void)\n{\n    xcb_randr_get_screen_resources_current_reply_t *rres_reply;\n    xcb_randr_output_t *outputs;\n    int i, j, num, valid = 0;\n\n    rres_reply = xcb_randr_get_screen_resources_current_reply(c,\n            xcb_randr_get_screen_resources_current(c, scr->root), NULL);\n\n    if (!rres_reply) {\n        fprintf(stderr, \"Failed to get current randr screen resources\\n\");\n        return;\n    }\n\n    num = xcb_randr_get_screen_resources_current_outputs_length(rres_reply);\n    outputs = xcb_randr_get_screen_resources_current_outputs(rres_reply);\n\n    // There should be at least one output\n    if (num < 1) {\n        free(rres_reply);\n        return;\n    }\n\n    // Every entry starts with a size of 0, making it invalid until we fill in\n    // the data retrieved from the Xserver.\n    monitor_t *mons = xcalloc(max(num, num_outputs), sizeof(monitor_t));\n\n    // Get all outputs\n    for (i = 0; i < num; i++) {\n        xcb_randr_get_output_info_reply_t *oi_reply;\n        xcb_randr_get_crtc_info_reply_t *ci_reply;\n\n        oi_reply = xcb_randr_get_output_info_reply(c, xcb_randr_get_output_info(c, outputs[i], XCB_CURRENT_TIME), NULL);\n\n        // Output disconnected or not attached to any CRTC ?\n        if (!oi_reply || oi_reply->crtc == XCB_NONE || oi_reply->connection != XCB_RANDR_CONNECTION_CONNECTED) {\n            free(oi_reply);\n            continue;\n        }\n\n        ci_reply = xcb_randr_get_crtc_info_reply(c,\n                xcb_randr_get_crtc_info(c, oi_reply->crtc, XCB_CURRENT_TIME), NULL);\n\n        if (!ci_reply) {\n            fprintf(stderr, \"Failed to get RandR crtc info\\n\");\n            free(rres_reply);\n            goto cleanup_mons;\n        }\n\n        int name_len = xcb_randr_get_output_info_name_length(oi_reply);\n        uint8_t *name_ptr = xcb_randr_get_output_info_name(oi_reply);\n\n        bool is_valid = true;\n\n        if (num_outputs) {\n            // Skip outputs missing from the list.\n            is_valid = false;\n            // Allocate monitors following the specified order.\n            for (j = 0; j < num_outputs; j++) {\n                // Already allocated, the list contains a duplicate.\n                if (mons[j].name)\n                    break;\n\n                if (!memcmp(output_names[j], name_ptr, name_len) &&\n                        strlen(output_names[j]) == name_len) {\n                    is_valid = true;\n                    break;\n                }\n            }\n        }\n\n        if (is_valid) {\n            char *alloc_name = xcalloc(name_len + 1, 1);\n            memcpy(alloc_name, name_ptr, name_len);\n\n            // There's no need to handle rotated screens here (see #69)\n            mons[i] = (monitor_t){ alloc_name, ci_reply->x, ci_reply->y,\n                ci_reply->width, ci_reply->height, 0, 0, NULL, NULL };\n            valid += 1;\n        }\n\n        free(oi_reply);\n        free(ci_reply);\n    }\n\n    free(rres_reply);\n\n    // Check for clones and inactive outputs\n    for (i = 0; i < num; i++) {\n        if (mons[i].width == 0)\n            continue;\n\n        for (j = 0; j < num; j++) {\n            // Does I contain J ?\n\n            if (i != j && mons[j].width) {\n                if (mons[j].x >= mons[i].x && mons[j].x + mons[j].width <= mons[i].x + mons[i].width &&\n                    mons[j].y >= mons[i].y && mons[j].y + mons[j].height <= mons[i].y + mons[i].height) {\n                    mons[j].width = 0;\n                    valid--;\n                }\n            }\n        }\n    }\n\n    if (valid > 0) {\n        monitor_t valid_mons[valid];\n        for (i = j = 0; i < num && j < valid; i++) {\n            if (mons[i].width != 0) {\n                valid_mons[j++] = mons[i];\n            }\n        }\n\n        monitor_create_chain(valid_mons, valid);\n    } else {\n        fprintf(stderr, \"No usable RandR output found\\n\");\n    }\n\ncleanup_mons:\n    for (i = 0; i < num; i++) {\n        free(mons[i].name);\n    }\n    free(mons);\n}\n\n#ifdef WITH_XINERAMA\nvoid\nget_xinerama_monitors (void)\n{\n    xcb_xinerama_query_screens_reply_t *xqs_reply;\n    xcb_xinerama_screen_info_iterator_t iter;\n    int screens;\n\n    if (num_outputs) {\n        fprintf(stderr, \"Using output names with Xinerama is not yet supported\\n\");\n        return;\n    }\n\n    xqs_reply = xcb_xinerama_query_screens_reply(c,\n            xcb_xinerama_query_screens_unchecked(c), NULL);\n\n    iter = xcb_xinerama_query_screens_screen_info_iterator(xqs_reply);\n    screens = iter.rem;\n\n    monitor_t mons[screens];\n\n    // Fetch all the screens first\n    for (int i = 0; iter.rem; i++) {\n        mons[i].name = NULL;\n        mons[i].x = iter.data->x_org;\n        mons[i].y = iter.data->y_org;\n        mons[i].width = iter.data->width;\n        mons[i].height = iter.data->height;\n        xcb_xinerama_screen_info_next(&iter);\n    }\n\n    free(xqs_reply);\n\n    monitor_create_chain(mons, screens);\n}\n#endif\n\nxcb_visualid_t\nget_visual (void)\n{\n    xcb_depth_iterator_t iter;\n\n    iter = xcb_screen_allowed_depths_iterator(scr);\n\n    // Try to find a RGBA visual\n    while (iter.rem) {\n        xcb_visualtype_t *vis = xcb_depth_visuals(iter.data);\n\n        if (iter.data->depth == 32)\n            return vis->visual_id;\n\n        xcb_depth_next(&iter);\n    }\n\n    // Fallback to the default one\n    return scr->root_visual;\n}\n\n// Parse an X-styled geometry string, we don't support signed offsets though.\nbool\nparse_geometry_string (char *str, int *tmp)\n{\n    char *p = str;\n    int i = 0, j;\n\n    if (!str || !str[0])\n        return false;\n\n    // The leading = is optional\n    if (*p == '=')\n        p++;\n\n    while (*p) {\n        // A geometry string has only 4 fields\n        if (i >= 4) {\n            fprintf(stderr, \"Invalid geometry specified\\n\");\n            return false;\n        }\n        // Move on if we encounter a 'x' or '+'\n        if (*p == 'x') {\n            if (i > 0) // The 'x' must precede '+'\n                break;\n            i++; p++; continue;\n        }\n        if (*p == '+') {\n            if (i < 1) // Stray '+', skip the first two fields\n                i = 2;\n            else\n                i++;\n            p++; continue;\n        }\n        // A digit must follow\n        if (!isdigit(*p)) {\n            fprintf(stderr, \"Invalid geometry specified\\n\");\n            return false;\n        }\n        // Try to parse the number\n        errno = 0;\n        j = strtoul(p, &p, 10);\n        if (errno) {\n            fprintf(stderr, \"Invalid geometry specified\\n\");\n            return false;\n        }\n        tmp[i] = j;\n    }\n\n    return true;\n}\n\nvoid\nparse_output_string(char *str)\n{\n    if (!str || !*str)\n        return;\n    output_names = xreallocarray(output_names, num_outputs + 1, sizeof(char*));\n    output_names[num_outputs++] = xstrdup(str);\n}\n\nvoid\nxconn (void)\n{\n    // Connect to X\n    c = xcb_connect (NULL, NULL);\n    if (xcb_connection_has_error(c)) {\n        fprintf(stderr, \"Couldn't connect to X\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Grab infos from the first screen\n    scr = xcb_setup_roots_iterator(xcb_get_setup(c)).data;\n\n    // Try to get a RGBA visual and build the colormap for that\n    visual = get_visual();\n\n    colormap = xcb_generate_id(c);\n    xcb_create_colormap(c, XCB_COLORMAP_ALLOC_NONE, colormap, scr->root, visual);\n}\n\nvoid\ninit (char *wm_name)\n{\n    // Try to load a default font\n    if (font_count == 0)\n        font_load(\"fixed\");\n\n    // We tried and failed hard, there's something wrong\n    if (!font_count)\n        exit(EXIT_FAILURE);\n\n    // To make the alignment uniform, find maximum height\n    int maxh = font_list[0]->height;\n    for (int i = 1; i < font_count; i++)\n        maxh = max(maxh, font_list[i]->height);\n\n    // Set maximum height to all fonts\n    for (int i = 0; i < font_count; i++)\n        font_list[i]->height = maxh;\n\n    // Generate a list of screens\n    const xcb_query_extension_reply_t *qe_reply;\n\n    // Initialize monitor list head and tail\n    monhead = montail = NULL;\n\n    // Check if RandR is present\n    qe_reply = xcb_get_extension_data(c, &xcb_randr_id);\n\n    if (qe_reply && qe_reply->present) {\n        get_randr_monitors();\n    }\n#if WITH_XINERAMA\n    else {\n        qe_reply = xcb_get_extension_data(c, &xcb_xinerama_id);\n\n        // Check if Xinerama extension is present and active\n        if (qe_reply && qe_reply->present) {\n            xcb_xinerama_is_active_reply_t *xia_reply;\n            xia_reply = xcb_xinerama_is_active_reply(c, xcb_xinerama_is_active(c), NULL);\n\n            if (xia_reply && xia_reply->state)\n                get_xinerama_monitors();\n\n            free(xia_reply);\n        }\n    }\n#endif\n\n    if (!monhead && num_outputs != 0) {\n        fprintf(stderr, \"Failed to find any specified outputs\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (!monhead) {\n        // If I fits I sits\n        if (bw < 0)\n            bw = scr->width_in_pixels - bx;\n\n        // Adjust the height\n        if (bh < 0 || bh > scr->height_in_pixels)\n            bh = maxh + bu + 2;\n\n        // Check the geometry\n        if (bx + bw > scr->width_in_pixels || by + bh > scr->height_in_pixels) {\n            fprintf(stderr, \"The geometry specified doesn't fit the screen!\\n\");\n            exit(EXIT_FAILURE);\n        }\n\n        // If no RandR outputs or Xinerama screens, fall back to using whole screen\n        monhead = monitor_new(0, 0, bw, scr->height_in_pixels, NULL);\n    }\n\n    if (!monhead)\n        exit(EXIT_FAILURE);\n\n    // For WM that support EWMH atoms\n    set_ewmh_atoms();\n\n    // Create the gc for drawing\n    gc[GC_DRAW] = xcb_generate_id(c);\n    xcb_create_gc(c, gc[GC_DRAW], monhead->pixmap, XCB_GC_FOREGROUND, (const uint32_t []){ fgc.v });\n\n    gc[GC_CLEAR] = xcb_generate_id(c);\n    xcb_create_gc(c, gc[GC_CLEAR], monhead->pixmap, XCB_GC_FOREGROUND, (const uint32_t []){ bgc.v });\n\n    gc[GC_ATTR] = xcb_generate_id(c);\n    xcb_create_gc(c, gc[GC_ATTR], monhead->pixmap, XCB_GC_FOREGROUND, (const uint32_t []){ ugc.v });\n\n    // Make the bar visible and clear the pixmap\n    for (monitor_t *mon = monhead; mon; mon = mon->next) {\n        fill_rect(mon->pixmap, gc[GC_CLEAR], 0, 0, mon->width, bh);\n        xcb_map_window(c, mon->window);\n\n        // Make sure that the window really gets in the place it's supposed to be\n        // Some WM such as Openbox need this\n        xcb_configure_window(c, mon->window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_STACK_MODE, (const uint32_t []){ mon->x, mon->y, XCB_STACK_MODE_BELOW });\n\n        // Set the WM_NAME atom to the user specified value\n        if (wm_name)\n            xcb_change_property(c, XCB_PROP_MODE_REPLACE, mon->window, XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8 ,strlen(wm_name), wm_name);\n    }\n\n    xcb_flush(c);\n}\n\nvoid\ncleanup (void)\n{\n    for (int i = 0; i < num_outputs; i++) {\n        free(output_names[i]);\n    }\n    free(output_names);\n\n    free(area_stack.ptr);\n\n    for (int i = 0; i < font_count; i++) {\n        xcb_close_font(c, font_list[i]->ptr);\n        free(font_list[i]->width_lut);\n        free(font_list[i]);\n    }\n    free(font_list);\n\n    while (monhead) {\n        monitor_t *next = monhead->next;\n        xcb_destroy_window(c, monhead->window);\n        xcb_free_pixmap(c, monhead->pixmap);\n        free(monhead->name);\n        free(monhead);\n        monhead = next;\n    }\n\n    xcb_free_colormap(c, colormap);\n\n    if (gc[GC_DRAW])\n        xcb_free_gc(c, gc[GC_DRAW]);\n    if (gc[GC_CLEAR])\n        xcb_free_gc(c, gc[GC_CLEAR]);\n    if (gc[GC_ATTR])\n        xcb_free_gc(c, gc[GC_ATTR]);\n    if (c)\n        xcb_disconnect(c);\n}\n\nvoid\nsighandle (int signal)\n{\n    if (signal == SIGINT || signal == SIGTERM)\n        exit(EXIT_SUCCESS);\n}\n\nint\nmain (int argc, char **argv)\n{\n    struct pollfd pollin[2] = {\n        { .fd = STDIN_FILENO, .events = POLLIN },\n        { .fd = -1          , .events = POLLIN },\n    };\n    xcb_generic_event_t *ev;\n    xcb_expose_event_t *expose_ev;\n    xcb_button_press_event_t *press_ev;\n    char input[4096] = {0, };\n    size_t input_offset = 0;\n    bool permanent = false;\n    int geom_v[4] = { -1, -1, 0, 0 };\n    int ch;\n    char *wm_name;\n\n    // Install the parachute!\n    atexit(cleanup);\n    signal(SIGINT, sighandle);\n    signal(SIGTERM, sighandle);\n\n    // B/W combo\n    dbgc = bgc = BLACK;\n    dfgc = fgc = WHITE;\n    dugc = ugc = fgc;\n\n    // A safe default\n    wm_name = NULL;\n\n    // Connect to the Xserver and initialize scr\n    xconn();\n\n    while ((ch = getopt(argc, argv, \"hg:o:bdf:a:pu:B:F:U:n:\")) != -1) {\n        switch (ch) {\n            case 'h':\n                printf (\"lemonbar version %s\\n\", VERSION);\n                printf (\"usage: %s [-h | -g | -o | -b | -d | -f | -p | -n | -u | -B | -F]\\n\"\n                        \"\\t-h Show this help\\n\"\n                        \"\\t-g Set the bar geometry {width}x{height}+{xoffset}+{yoffset}\\n\"\n                        \"\\t-o Add randr output by name\\n\"\n                        \"\\t-b Put the bar at the bottom of the screen\\n\"\n                        \"\\t-d Force docking (use this if your WM isn't EWMH compliant)\\n\"\n                        \"\\t-f Set the font name to use\\n\"\n                        \"\\t-p Don't close after the data ends\\n\"\n                        \"\\t-n Set the WM_NAME atom to the specified value for this bar\\n\"\n                        \"\\t-u Set the underline/overline height in pixels\\n\"\n                        \"\\t-B Set background color in #AARRGGBB\\n\"\n                        \"\\t-F Set foreground color in #AARRGGBB\\n\", argv[0]);\n                exit (EXIT_SUCCESS);\n            case 'g': (void)parse_geometry_string(optarg, geom_v); break;\n            case 'o': (void)parse_output_string(optarg); break;\n            case 'p': permanent = true; break;\n            case 'n': wm_name = xstrdup(optarg); break;\n            case 'b': topbar = false; break;\n            case 'd': dock = true; break;\n            case 'f': font_load(optarg); break;\n            case 'u': bu = strtoul(optarg, NULL, 10); break;\n            case 'B': dbgc = bgc = parse_color(optarg, NULL, BLACK); break;\n            case 'F': dfgc = fgc = parse_color(optarg, NULL, WHITE); break;\n            case 'U': dugc = ugc = parse_color(optarg, NULL, fgc); break;\n        }\n    }\n\n    // Initialize the stack holding the clickable areas\n    area_stack.index = 0;\n    area_stack.alloc = 10;\n    area_stack.ptr = xcalloc(10, sizeof(area_t));\n\n    // Copy the geometry values in place\n    bw = geom_v[0];\n    bh = geom_v[1];\n    bx = geom_v[2];\n    by = geom_v[3];\n\n    // Do the heavy lifting\n    init(wm_name);\n    // The string is strdup'd when the command line arguments are parsed\n    free(wm_name);\n    // Get the fd to Xserver\n    pollin[1].fd = xcb_get_file_descriptor(c);\n\n#ifdef __OpenBSD__\n    if (pledge(\"stdio rpath\", NULL) < 0) {\n        err(EXIT_FAILURE, \"pledge failed\");\n    }\n#endif\n\n    for (;;) {\n        bool redraw = false;\n\n        // If connection is in error state, then it has been shut down.\n        if (xcb_connection_has_error(c))\n            break;\n\n        if (poll(pollin, 2, -1) > 0) {\n            if (pollin[0].revents & POLLHUP) {      // No more data...\n                if (permanent) pollin[0].fd = -1;   // ...null the fd and continue polling :D\n                else break;                         // ...bail out\n            }\n            if (pollin[0].revents & POLLIN) { // New input, process it\n                while (true) {\n                    ssize_t r = read(STDIN_FILENO, input + input_offset,\n                            sizeof(input) - input_offset);\n                    if (r == 0) break;\n                    if (r < 0) {\n                        if (errno == EINTR) continue;\n                        exit(EXIT_FAILURE);\n                    }\n\n                    input_offset += r;\n\n                    // Try to find the last complete input line in the buffer.\n                    char *input_end = input + input_offset;\n                    char *last_nl = memrchr(input, '\\n', input_end - input);\n\n                    if (last_nl) {\n                        char *prev_nl = (last_nl != input) ?\n                                memrchr(input, '\\n', last_nl - 1 - input) : NULL;\n                        char *begin = prev_nl? prev_nl + 1: input;\n\n                        *last_nl = '\\0';\n\n                        parse(begin);\n                        redraw = true;\n\n                        // Move the unparsed part back to the beginning.\n                        const size_t remaining = input_end - (last_nl + 1);\n                        if (remaining != 0) memmove(input, last_nl + 1, remaining);\n                        input_offset = remaining;\n\n                        break;\n                    }\n\n                    // The input buffer is full and we haven't seen a newline\n                    // yet, discard everything and start from zero.\n                    if (sizeof(input) == input_offset) {\n                        input_offset = 0;\n                    }\n                }\n            }\n            if (pollin[1].revents & POLLIN) { // The event comes from the Xorg server\n                while ((ev = xcb_poll_for_event(c))) {\n                    expose_ev = (xcb_expose_event_t *)ev;\n\n                    switch (ev->response_type & 0x7F) {\n                        case XCB_EXPOSE:\n                            if (expose_ev->count == 0)\n                                redraw = true;\n                            break;\n                        case XCB_BUTTON_PRESS:\n                            press_ev = (xcb_button_press_event_t *)ev;\n                            {\n                                area_t *area = area_get(press_ev->event, press_ev->detail, press_ev->event_x);\n                                // Respond to the click\n                                if (area) {\n                                    (void)write(STDOUT_FILENO, area->cmd, strlen(area->cmd));\n                                    (void)write(STDOUT_FILENO, \"\\n\", 1);\n                                }\n                            }\n                            break;\n                    }\n\n                    free(ev);\n                }\n            }\n        }\n\n        if (redraw) { // Copy our temporary pixmap onto the window\n            for (monitor_t *mon = monhead; mon; mon = mon->next) {\n                xcb_copy_area(c, mon->pixmap, mon->window, gc[GC_DRAW], 0, 0, 0, 0, mon->width, bh);\n            }\n        }\n\n        xcb_flush(c);\n    }\n\n    return EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 0.9873046875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void\noom_error(const char *func)\n{\n    fprintf(stderr, \"fatal error in %s: out of memory\\n\", func);\n    // Prefer abort() over exit(1) for better debuggability.\n    abort();\n}\n\nchar*\nxstrdup(const char *s)\n{\n    char *p = strdup(s);\n    if (p == NULL) oom_error(__func__);\n    return p;\n}\n\nvoid*\nxmalloc(size_t size)\n{\n    void *p = malloc(size);\n    if (p == NULL) oom_error(__func__);\n    return p;\n}\n\nvoid*\nxcalloc(size_t nmemb, size_t size)\n{\n    void *p = calloc(nmemb, size);\n    if (p == NULL) oom_error(__func__);\n    return p;\n}\n\nvoid*\nxrealloc(void *ptr, size_t size)\n{\n    void *p = realloc(ptr, size);\n    if (p == NULL) oom_error(__func__);\n    return p;\n}\n\nvoid*\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n    size_t alloc_size;\n    void *p;\n    if (__builtin_mul_overflow(nmemb, size, &alloc_size))\n        oom_error(__func__);\n    p = realloc(ptr, alloc_size);\n    if (p == NULL) oom_error(__func__);\n    return p;\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 0.236328125,
          "content": "#ifndef UTILS_H_\n#define UTILS_H_\n\nchar* xstrdup(const char *s);\nvoid* xmalloc(size_t size);\nvoid* xcalloc(size_t nmemb, size_t size);\nvoid* xrealloc(void *ptr, size_t size);\nvoid* xreallocarray(void *ptr, size_t nmemb, size_t size);\n\n#endif\n"
        }
      ]
    }
  ]
}