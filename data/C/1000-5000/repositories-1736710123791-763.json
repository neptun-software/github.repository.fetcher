{
  "metadata": {
    "timestamp": 1736710123791,
    "page": 763,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xyb3rt/sxiv",
      "stars": 1824,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03125,
          "content": "config.h\nversion.h\n*.d\n*.o\nsxiv\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.009765625,
          "content": "version = 26\n\nsrcdir = .\nVPATH = $(srcdir)\n\nPREFIX = /usr/local\nMANPREFIX = $(PREFIX)/share/man\n\n# autoreload backend: inotify/nop\nAUTORELOAD = inotify\n\n# enable features requiring giflib (-lgif)\nHAVE_GIFLIB = 1\n\n# enable features requiring libexif (-lexif)\nHAVE_LIBEXIF = 1\n\ncflags = -std=c99 -Wall -pedantic $(CFLAGS)\ncppflags = -I. $(CPPFLAGS) -D_XOPEN_SOURCE=700 \\\n  -DHAVE_GIFLIB=$(HAVE_GIFLIB) -DHAVE_LIBEXIF=$(HAVE_LIBEXIF) \\\n  -I/usr/include/freetype2 -I$(PREFIX)/include/freetype2\n\nlib_exif_0 =\nlib_exif_1 = -lexif\nlib_gif_0 =\nlib_gif_1 = -lgif\nldlibs = $(LDLIBS) -lImlib2 -lX11 -lXft -lfontconfig \\\n  $(lib_exif_$(HAVE_LIBEXIF)) $(lib_gif_$(HAVE_GIFLIB))\n\nobjs = autoreload_$(AUTORELOAD).o commands.o image.o main.o options.o \\\n  thumbs.o util.o window.o\n\nall: sxiv\n\n.PHONY: all clean install uninstall\n.SUFFIXES:\n.SUFFIXES: .c .o\n$(V).SILENT:\n\nsxiv: $(objs)\n\t@echo \"LINK $@\"\n\t$(CC) $(LDFLAGS) -o $@ $(objs) $(ldlibs)\n\n$(objs): Makefile sxiv.h commands.lst config.h\noptions.o: version.h\nwindow.o: icon/data.h\n\n.c.o:\n\t@echo \"CC $@\"\n\t$(CC) $(cflags) $(cppflags) -c -o $@ $<\n\nconfig.h:\n\t@echo \"GEN $@\"\n\tcp $(srcdir)/config.def.h $@\n\nversion.h: Makefile .git/index\n\t@echo \"GEN $@\"\n\tv=\"$$(cd $(srcdir); git describe 2>/dev/null)\"; \\\n\techo \"#define VERSION \\\"$${v:-$(version)}\\\"\" >$@\n\n.git/index:\n\nclean:\n\trm -f *.o sxiv\n\ninstall: all\n\t@echo \"INSTALL bin/sxiv\"\n\tmkdir -p $(DESTDIR)$(PREFIX)/bin\n\tcp sxiv $(DESTDIR)$(PREFIX)/bin/\n\tchmod 755 $(DESTDIR)$(PREFIX)/bin/sxiv\n\t@echo \"INSTALL sxiv.1\"\n\tmkdir -p $(DESTDIR)$(MANPREFIX)/man1\n\tsed \"s!PREFIX!$(PREFIX)!g; s!VERSION!$(version)!g\" sxiv.1 \\\n\t\t>$(DESTDIR)$(MANPREFIX)/man1/sxiv.1\n\tchmod 644 $(DESTDIR)$(MANPREFIX)/man1/sxiv.1\n\t@echo \"INSTALL share/sxiv/\"\n\tmkdir -p $(DESTDIR)$(PREFIX)/share/sxiv/exec\n\tcp exec/* $(DESTDIR)$(PREFIX)/share/sxiv/exec/\n\tchmod 755 $(DESTDIR)$(PREFIX)/share/sxiv/exec/*\n\nuninstall:\n\t@echo \"REMOVE bin/sxiv\"\n\trm -f $(DESTDIR)$(PREFIX)/bin/sxiv\n\t@echo \"REMOVE sxiv.1\"\n\trm -f $(DESTDIR)$(MANPREFIX)/man1/sxiv.1\n\t@echo \"REMOVE share/sxiv/\"\n\trm -rf $(DESTDIR)$(PREFIX)/share/sxiv\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.5146484375,
          "content": "![sxiv](http://xyb3rt.github.io/sxiv/img/logo.png \"sxiv\")\n\n**Simple X Image Viewer**\n\nThe sole purpose of sxiv is to be the perfect image viewer for me. It is free\nsoftware so that you can use it and modify it for your needs. Please file a bug\nreport if something does not work as documented or expected. Contributions are\nwelcome but there is no guarantee that they will be incorporated.\n\n\nFeatures\n--------\n\n* Basic image operations, e.g. zooming, panning, rotating\n* Customizable key and mouse button mappings (in *config.h*)\n* Thumbnail mode: grid of selectable previews of all images\n* Ability to cache thumbnails for fast re-loading\n* Basic support for multi-frame images\n* Load all frames from GIF files and play GIF animations\n* Display image information in status bar\n\n\nScreenshots\n-----------\n\n**Image mode:**\n\n![Image](http://xyb3rt.github.io/sxiv/img/image.png \"Image mode\")\n\n**Thumbnail mode:**\n\n![Thumb](http://xyb3rt.github.io/sxiv/img/thumb.png \"Thumb mode\")\n\n\nDependencies\n------------\n\nsxiv requires the following software to be installed:\n\n  * Imlib2\n  * X11\n  * Xft\n  * freetype2\n  * fontconfig\n  * giflib (optional, disabled with `HAVE_GIFLIB=0`)\n  * libexif (optional, disabled with `HAVE_LIBEXIF=0`)\n\nPlease make sure to install the corresponding development packages in case that\nyou want to build sxiv on a distribution with separate runtime and development\npackages (e.g. *-dev on Debian).\n\n\nBuilding\n--------\n\nsxiv is built using the commands:\n\n    $ make\n    # make install\n\nPlease note, that the latter one requires root privileges.\nBy default, sxiv is installed using the prefix \"/usr/local\", so the full path\nof the executable will be \"/usr/local/bin/sxiv\".\n\nYou can install sxiv into a directory of your choice by changing the second\ncommand to:\n\n    # make PREFIX=\"/your/dir\" install\n\nThe build-time specific settings of sxiv can be found in the file *config.h*.\nPlease check and change them, so that they fit your needs.\nIf the file *config.h* does not already exist, then you have to create it with\nthe following command:\n\n    $ make config.h\n\n\nUsage\n-----\n\nPlease see the [man page](http://xyb3rt.github.io/sxiv/sxiv.1.html) for\ninformation on how to use sxiv.\n\n\nDownload & Changelog\n--------------------\n\nYou can [browse](https://github.com/xyb3rt/sxiv) the source code repository\non GitHub or get a copy using git with the following command:\n\n    git clone https://github.com/xyb3rt/sxiv.git\n\n**Stable releases**\n\n**[v26](https://github.com/xyb3rt/sxiv/archive/v26.tar.gz)**\n*(January 16, 2020)*\n\n  * Maintenance release\n\n**[v25](https://github.com/xyb3rt/sxiv/archive/v25.tar.gz)**\n*(January 26, 2019)*\n\n  * Support font fallback for missing glyphs\n  * Fix busy loop when built without inotify\n  * Use background/foreground colors from X resource database\n\n**[v24](https://github.com/xyb3rt/sxiv/archive/v24.tar.gz)**\n*(October 27, 2017)*\n\n  * Automatically reload the current image whenever it changes\n  * Support embedding into other X windows with -e (e.g. tabbed)\n  * New option -p prevents sxiv from creating cache and temporary files\n  * Simpler mouse mappings, the most basic features are accessible with the\n    mouse only (navigate, zoom, pan)\n\n**[v1.3.2](https://github.com/xyb3rt/sxiv/archive/v1.3.2.tar.gz)**\n*(December 20, 2015)*\n\n  * external key handler gets file paths on stdin, not as arguments\n  * Cache out-of-view thumbnails in the background\n  * Apply gamma correction to thumbnails\n\n**[v1.3.1](https://github.com/xyb3rt/sxiv/archive/v1.3.1.tar.gz)**\n*(November 16, 2014)*\n\n  * Fixed build error, caused by delayed config.h creation\n  * Fixed segfault when run with -c\n\n**[v1.3](https://github.com/xyb3rt/sxiv/archive/v1.3.tar.gz)**\n*(October 24, 2014)*\n\n  * Extract thumbnails from EXIF tags (requires libexif)\n  * Zoomable thumbnails, supported sizes defined in config.h\n  * Fixed build error with giflib version >= 5.1.0\n\n**[v1.2](https://github.com/xyb3rt/sxiv/archive/v1.2.tar.gz)**\n*(April 24, 2014)*\n\n  * Added external key handler, called on keys prefixed with `Ctrl-x`\n  * New keybinding `{`/`}` to change gamma (by Andr√°s Mohari)\n  * Support for slideshows, enabled with `-S` option & toggled with `s`\n  * Added application icon (created by 0ion9)\n  * Checkerboard background for alpha layer\n  * Option `-o` only prints files marked with `m` key\n  * Fixed rotation/flipping of multi-frame images (gifs)\n\n**[v1.1.1](https://github.com/xyb3rt/sxiv/archive/v1.1.1.tar.gz)**\n*(June 2, 2013)*\n\n  * Various bug fixes\n\n**[v1.1](https://github.com/xyb3rt/sxiv/archive/v1.1.tar.gz)**\n*(March 30, 2013)*\n\n  * Added status bar on bottom of window with customizable content\n  * New keyboard shortcuts `\\`/`|`: flip image vertically/horizontally\n  * New keyboard shortcut `Ctrl-6`: go to last/alternate image\n  * Added own EXIF orientation handling, removed dependency on libexif\n  * Fixed various bugs\n\n**[v1.0](https://github.com/xyb3rt/sxiv/archive/v1.0.tar.gz)**\n*(October 31, 2011)*\n\n  * Support for multi-frame images & GIF animations\n  * POSIX compliant (IEEE Std 1003.1-2001)\n\n**[v0.9](https://github.com/xyb3rt/sxiv/archive/v0.9.tar.gz)**\n*(August 17, 2011)*\n\n  * Made key and mouse mappings fully configurable in config.h\n  * Complete code refactoring\n\n**[v0.8.2](https://github.com/xyb3rt/sxiv/archive/v0.8.2.tar.gz)**\n*(June 29, 2011)*\n\n  * POSIX-compliant Makefile; compiles under NetBSD\n\n**[v0.8.1](https://github.com/xyb3rt/sxiv/archive/v0.8.1.tar.gz)**\n*(May 8, 2011)*\n\n  * Fixed fullscreen under window managers, which are not fully EWMH-compliant\n\n**[v0.8](https://github.com/xyb3rt/sxiv/archive/v0.8.tar.gz)**\n*(April 18, 2011)*\n\n  * Support for thumbnail caching\n  * Ability to run external commands (e.g. jpegtran, convert) on current image\n\n**[v0.7](https://github.com/xyb3rt/sxiv/archive/v0.7.tar.gz)**\n*(February 26, 2011)*\n\n  * Sort directory entries when using `-r` command line option\n  * Hide cursor in image mode\n  * Full functional thumbnail mode, use Return key to switch between image and\n    thumbnail mode\n\n**[v0.6](https://github.com/xyb3rt/sxiv/archive/v0.6.tar.gz)**\n*(February 16, 2011)*\n\n  * Bug fix: Correctly display filenames with umlauts in window title\n  * Basic support of thumbnails\n\n**[v0.5](https://github.com/xyb3rt/sxiv/archive/v0.5.tar.gz)**\n*(February 6, 2011)*\n\n  * New command line option: `-r`: open all images in given directories\n  * New key shortcuts: `w`: resize image to fit into window; `W`: resize window\n    to fit to image\n\n**[v0.4](https://github.com/xyb3rt/sxiv/archive/v0.4.tar.gz)**\n*(February 1, 2011)*\n\n  * New command line option: `-F`, `-g`: use fixed window dimensions and apply\n    a given window geometry\n  * New key shortcut: `r`: reload current image\n\n**[v0.3.1](https://github.com/xyb3rt/sxiv/archive/v0.3.1.tar.gz)**\n*(January 30, 2011)*\n\n  * Bug fix: Do not set setuid bit on executable when using `make install`\n  * Pan image with mouse while pressing middle mouse button\n\n**[v0.3](https://github.com/xyb3rt/sxiv/archive/v0.3.tar.gz)**\n*(January 29, 2011)*\n\n  * New command line options: `-d`, `-f`, `-p`, `-s`, `-v`, `-w`, `-Z`, `-z`\n  * More mouse mappings: Go to next/previous image with left/right click,\n    scroll image with mouse wheel (horizontally if Shift key is pressed),\n    zoom image with mouse wheel if Ctrl key is pressed\n\n**[v0.2](https://github.com/xyb3rt/sxiv/archive/v0.2.tar.gz)**\n*(January 23, 2011)*\n\n  * Bug fix: Handle window resizes correctly\n  * New keyboard shortcuts: `g`/`G`: go to first/last image; `[`/`]`: go 10\n    images back/forward\n  * Support for mouse wheel zooming (by Dave Reisner)\n  * Added fullscreen mode\n\n**[v0.1](https://github.com/xyb3rt/sxiv/archive/v0.1.tar.gz)**\n*(January 21, 2011)*\n\n  * Initial release\n\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.2900390625,
          "content": "- Load all frames from TIFF files. We have to write our own loader for this to\n  happen--just like we did for GIF images--because Imlib2 does not support\n  multiple frames. Issue #241.\n- Add support for more embedded thumbnail formats. Right now, sxiv seems to use\n  the smallest one. Issue #238.\n"
        },
        {
          "name": "autoreload_inotify.c",
          "type": "blob",
          "size": 2.646484375,
          "content": "/* Copyright 2017 Max Voit, Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/inotify.h>\n\nvoid arl_init(arl_t *arl)\n{\n\tarl->fd = inotify_init1(IN_CLOEXEC | IN_NONBLOCK);\n\tarl->wd_dir = arl->wd_file = -1;\n\tif (arl->fd == -1)\n\t\terror(0, 0, \"Could not initialize inotify, no automatic image reloading\");\n}\n\nCLEANUP void arl_cleanup(arl_t *arl)\n{\n\tif (arl->fd != -1)\n\t\tclose(arl->fd);\n\tfree(arl->filename);\n}\n\nstatic void rm_watch(int fd, int *wd)\n{\n\tif (*wd != -1) {\n\t\tinotify_rm_watch(fd, *wd);\n\t\t*wd = -1;\n\t}\n}\n\nstatic void add_watch(int fd, int *wd, const char *path, uint32_t mask)\n{\n\t*wd = inotify_add_watch(fd, path, mask);\n\tif (*wd == -1)\n\t\terror(0, errno, \"inotify: %s\", path);\n}\n\nvoid arl_setup(arl_t *arl, const char *filepath)\n{\n\tchar *base = strrchr(filepath, '/');\n\n\tif (arl->fd == -1)\n\t\treturn;\n\n\trm_watch(arl->fd, &arl->wd_dir);\n\trm_watch(arl->fd, &arl->wd_file);\n\n\tadd_watch(arl->fd, &arl->wd_file, filepath, IN_CLOSE_WRITE | IN_DELETE_SELF);\n\n\tfree(arl->filename);\n\tarl->filename = estrdup(filepath);\n\n\tif (base != NULL) {\n\t\tarl->filename[++base - filepath] = '\\0';\n\t\tadd_watch(arl->fd, &arl->wd_dir, arl->filename, IN_CREATE | IN_MOVED_TO);\n\t\tstrcpy(arl->filename, base);\n\t}\n}\n\nunion {\n\tchar d[4096]; /* aligned buffer */\n\tstruct inotify_event e;\n} buf;\n\nbool arl_handle(arl_t *arl)\n{\n\tbool reload = false;\n\tchar *ptr;\n\tconst struct inotify_event *e;\n\n\tfor (;;) {\n\t\tssize_t len = read(arl->fd, buf.d, sizeof(buf.d));\n\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tfor (ptr = buf.d; ptr < buf.d + len; ptr += sizeof(*e) + e->len) {\n\t\t\te = (const struct inotify_event*) ptr;\n\t\t\tif (e->wd == arl->wd_file && (e->mask & IN_CLOSE_WRITE)) {\n\t\t\t\treload = true;\n\t\t\t} else if (e->wd == arl->wd_file && (e->mask & IN_DELETE_SELF)) {\n\t\t\t\trm_watch(arl->fd, &arl->wd_file);\n\t\t\t} else if (e->wd == arl->wd_dir && (e->mask & (IN_CREATE | IN_MOVED_TO))) {\n\t\t\t\tif (STREQ(e->name, arl->filename))\n\t\t\t\t\treload = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn reload;\n}\n\n"
        },
        {
          "name": "autoreload_nop.c",
          "type": "blob",
          "size": 0.9267578125,
          "content": "/* Copyright 2017 Max Voit\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n\nvoid arl_init(arl_t *arl)\n{\n\tarl->fd = -1;\n}\n\nvoid arl_cleanup(arl_t *arl)\n{\n\t(void) arl;\n}\n\nvoid arl_setup(arl_t *arl, const char *filepath)\n{\n\t(void) arl;\n\t(void) filepath;\n}\n\nbool arl_handle(arl_t *arl)\n{ \n\t(void) arl;\n\treturn false;\n}\n\n"
        },
        {
          "name": "commands.c",
          "type": "blob",
          "size": 8.130859375,
          "content": "/* Copyright 2011, 2012, 2014 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _IMAGE_CONFIG\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nvoid remove_file(int, bool);\nvoid load_image(int);\nbool mark_image(int, bool);\nvoid close_info(void);\nvoid open_info(void);\nint ptr_third_x(void);\nvoid redraw(void);\nvoid reset_cursor(void);\nvoid animate(void);\nvoid slideshow(void);\nvoid set_timeout(timeout_f, int, bool);\nvoid reset_timeout(timeout_f);\n\nextern appmode_t mode;\nextern img_t img;\nextern tns_t tns;\nextern win_t win;\n\nextern fileinfo_t *files;\nextern int filecnt, fileidx;\nextern int alternate;\nextern int markcnt;\nextern int markidx;\n\nextern int prefix;\nextern bool extprefix;\n\nbool cg_quit(arg_t _)\n{\n\tunsigned int i;\n\n\tif (options->to_stdout && markcnt > 0) {\n\t\tfor (i = 0; i < filecnt; i++) {\n\t\t\tif (files[i].flags & FF_MARK)\n\t\t\t\tprintf(\"%s\\n\", files[i].name);\n\t\t}\n\t}\n\texit(EXIT_SUCCESS);\n}\n\nbool cg_switch_mode(arg_t _)\n{\n\tif (mode == MODE_IMAGE) {\n\t\tif (tns.thumbs == NULL)\n\t\t\ttns_init(&tns, files, &filecnt, &fileidx, &win);\n\t\timg_close(&img, false);\n\t\treset_timeout(reset_cursor);\n\t\tif (img.ss.on) {\n\t\t\timg.ss.on = false;\n\t\t\treset_timeout(slideshow);\n\t\t}\n\t\ttns.dirty = true;\n\t\tmode = MODE_THUMB;\n\t} else {\n\t\tload_image(fileidx);\n\t\tmode = MODE_IMAGE;\n\t}\n\treturn true;\n}\n\nbool cg_toggle_fullscreen(arg_t _)\n{\n\twin_toggle_fullscreen(&win);\n\t/* redraw after next ConfigureNotify event */\n\tset_timeout(redraw, TO_REDRAW_RESIZE, false);\n\tif (mode == MODE_IMAGE)\n\t\timg.checkpan = img.dirty = true;\n\telse\n\t\ttns.dirty = true;\n\treturn false;\n}\n\nbool cg_toggle_bar(arg_t _)\n{\n\twin_toggle_bar(&win);\n\tif (mode == MODE_IMAGE) {\n\t\tif (win.bar.h > 0)\n\t\t\topen_info();\n\t\telse\n\t\t\tclose_info();\n\t\timg.checkpan = img.dirty = true;\n\t} else {\n\t\ttns.dirty = true;\n\t}\n\treturn true;\n}\n\nbool cg_prefix_external(arg_t _)\n{\n\textprefix = true;\n\treturn false;\n}\n\nbool cg_reload_image(arg_t _)\n{\n\tif (mode == MODE_IMAGE) {\n\t\tload_image(fileidx);\n\t} else {\n\t\twin_set_cursor(&win, CURSOR_WATCH);\n\t\tif (!tns_load(&tns, fileidx, true, false)) {\n\t\t\tremove_file(fileidx, false);\n\t\t\ttns.dirty = true;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool cg_remove_image(arg_t _)\n{\n\tremove_file(fileidx, true);\n\tif (mode == MODE_IMAGE)\n\t\tload_image(fileidx);\n\telse\n\t\ttns.dirty = true;\n\treturn true;\n}\n\nbool cg_first(arg_t _)\n{\n\tif (mode == MODE_IMAGE && fileidx != 0) {\n\t\tload_image(0);\n\t\treturn true;\n\t} else if (mode == MODE_THUMB && fileidx != 0) {\n\t\tfileidx = 0;\n\t\ttns.dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool cg_n_or_last(arg_t _)\n{\n\tint n = prefix != 0 && prefix - 1 < filecnt ? prefix - 1 : filecnt - 1;\n\n\tif (mode == MODE_IMAGE && fileidx != n) {\n\t\tload_image(n);\n\t\treturn true;\n\t} else if (mode == MODE_THUMB && fileidx != n) {\n\t\tfileidx = n;\n\t\ttns.dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool cg_scroll_screen(arg_t dir)\n{\n\tif (mode == MODE_IMAGE)\n\t\treturn img_pan(&img, dir, -1);\n\telse\n\t\treturn tns_scroll(&tns, dir, true);\n}\n\nbool cg_zoom(arg_t d)\n{\n\tif (mode == MODE_THUMB)\n\t\treturn tns_zoom(&tns, d);\n\telse if (d > 0)\n\t\treturn img_zoom_in(&img);\n\telse if (d < 0)\n\t\treturn img_zoom_out(&img);\n\telse\n\t\treturn false;\n}\n\nbool cg_toggle_image_mark(arg_t _)\n{\n\treturn mark_image(fileidx, !(files[fileidx].flags & FF_MARK));\n}\n\nbool cg_reverse_marks(arg_t _)\n{\n\tint i;\n\n\tfor (i = 0; i < filecnt; i++) {\n\t\tfiles[i].flags ^= FF_MARK;\n\t\tmarkcnt += files[i].flags & FF_MARK ? 1 : -1;\n\t}\n\tif (mode == MODE_THUMB)\n\t\ttns.dirty = true;\n\treturn true;\n}\n\nbool cg_mark_range(arg_t _)\n{\n\tint d = markidx < fileidx ? 1 : -1, end, i;\n\tbool dirty = false, on = !!(files[markidx].flags & FF_MARK);\n\n\tfor (i = markidx + d, end = fileidx + d; i != end; i += d)\n\t\tdirty |= mark_image(i, on);\n\treturn dirty;\n}\n\nbool cg_unmark_all(arg_t _)\n{\n\tint i;\n\n\tfor (i = 0; i < filecnt; i++)\n\t\tfiles[i].flags &= ~FF_MARK;\n\tmarkcnt = 0;\n\tif (mode == MODE_THUMB)\n\t\ttns.dirty = true;\n\treturn true;\n}\n\nbool cg_navigate_marked(arg_t n)\n{\n\tint d, i;\n\tint new = fileidx;\n\t\n\tif (prefix > 0)\n\t\tn *= prefix;\n\td = n > 0 ? 1 : -1;\n\tfor (i = fileidx + d; n != 0 && i >= 0 && i < filecnt; i += d) {\n\t\tif (files[i].flags & FF_MARK) {\n\t\t\tn -= d;\n\t\t\tnew = i;\n\t\t}\n\t}\n\tif (new != fileidx) {\n\t\tif (mode == MODE_IMAGE) {\n\t\t\tload_image(new);\n\t\t} else {\n\t\t\tfileidx = new;\n\t\t\ttns.dirty = true;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool cg_change_gamma(arg_t d)\n{\n\tif (img_change_gamma(&img, d * (prefix > 0 ? prefix : 1))) {\n\t\tif (mode == MODE_THUMB)\n\t\t\ttns.dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool ci_navigate(arg_t n)\n{\n\tif (prefix > 0)\n\t\tn *= prefix;\n\tn += fileidx;\n\tif (n < 0)\n\t\tn = 0;\n\tif (n >= filecnt)\n\t\tn = filecnt - 1;\n\n\tif (n != fileidx) {\n\t\tload_image(n);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool ci_cursor_navigate(arg_t _)\n{\n\treturn ci_navigate(ptr_third_x() - 1);\n}\n\nbool ci_alternate(arg_t _)\n{\n\tload_image(alternate);\n\treturn true;\n}\n\nbool ci_navigate_frame(arg_t d)\n{\n\tif (prefix > 0)\n\t\td *= prefix;\n\treturn !img.multi.animate && img_frame_navigate(&img, d);\n}\n\nbool ci_toggle_animation(arg_t _)\n{\n\tbool dirty = false;\n\n\tif (img.multi.cnt > 0) {\n\t\timg.multi.animate = !img.multi.animate;\n\t\tif (img.multi.animate) {\n\t\t\tdirty = img_frame_animate(&img);\n\t\t\tset_timeout(animate, img.multi.frames[img.multi.sel].delay, true);\n\t\t} else {\n\t\t\treset_timeout(animate);\n\t\t}\n\t}\n\treturn dirty;\n}\n\nbool ci_scroll(arg_t dir)\n{\n\treturn img_pan(&img, dir, prefix);\n}\n\nbool ci_scroll_to_edge(arg_t dir)\n{\n\treturn img_pan_edge(&img, dir);\n}\n\nbool ci_drag(arg_t mode)\n{\n\tint x, y, ox, oy;\n\tfloat px, py;\n\tXEvent e;\n\n\tif ((int)(img.w * img.zoom) <= win.w && (int)(img.h * img.zoom) <= win.h)\n\t\treturn false;\n\t\n\twin_set_cursor(&win, CURSOR_DRAG);\n\n\twin_cursor_pos(&win, &x, &y);\n\tox = x;\n\toy = y;\n\n\tfor (;;) {\n\t\tif (mode == DRAG_ABSOLUTE) {\n\t\t\tpx = MIN(MAX(0.0, x - win.w*0.1), win.w*0.8) / (win.w*0.8)\n\t\t\t   * (win.w - img.w * img.zoom);\n\t\t\tpy = MIN(MAX(0.0, y - win.h*0.1), win.h*0.8) / (win.h*0.8)\n\t\t\t   * (win.h - img.h * img.zoom);\n\t\t} else {\n\t\t\tpx = img.x + x - ox;\n\t\t\tpy = img.y + y - oy;\n\t\t}\n\n\t\tif (img_pos(&img, px, py)) {\n\t\t\timg_render(&img);\n\t\t\twin_draw(&win);\n\t\t}\n\t\tXMaskEvent(win.env.dpy,\n\t\t           ButtonPressMask | ButtonReleaseMask | PointerMotionMask, &e);\n\t\tif (e.type == ButtonPress || e.type == ButtonRelease)\n\t\t\tbreak;\n\t\twhile (XCheckTypedEvent(win.env.dpy, MotionNotify, &e));\n\t\tox = x;\n\t\toy = y;\n\t\tx = e.xmotion.x;\n\t\ty = e.xmotion.y;\n\t}\n\tset_timeout(reset_cursor, TO_CURSOR_HIDE, true);\n\treset_cursor();\n\n\treturn true;\n}\n\nbool ci_set_zoom(arg_t zl)\n{\n\treturn img_zoom(&img, (prefix ? prefix : zl) / 100.0);\n}\n\nbool ci_fit_to_win(arg_t sm)\n{\n\treturn img_fit_win(&img, sm);\n}\n\nbool ci_rotate(arg_t degree)\n{\n\timg_rotate(&img, degree);\n\treturn true;\n}\n\nbool ci_flip(arg_t dir)\n{\n\timg_flip(&img, dir);\n\treturn true;\n}\n\nbool ci_toggle_antialias(arg_t _)\n{\n\timg_toggle_antialias(&img);\n\treturn true;\n}\n\nbool ci_toggle_alpha(arg_t _)\n{\n\timg.alpha = !img.alpha;\n\timg.dirty = true;\n\treturn true;\n}\n\nbool ci_slideshow(arg_t _)\n{\n\tif (prefix > 0) {\n\t\timg.ss.on = true;\n\t\timg.ss.delay = prefix * 10;\n\t\tset_timeout(slideshow, img.ss.delay * 100, true);\n\t} else if (img.ss.on) {\n\t\timg.ss.on = false;\n\t\treset_timeout(slideshow);\n\t} else {\n\t\timg.ss.on = true;\n\t}\n\treturn true;\n}\n\nbool ct_move_sel(arg_t dir)\n{\n\treturn tns_move_selection(&tns, dir, prefix);\n}\n\nbool ct_reload_all(arg_t _)\n{\n\ttns_free(&tns);\n\ttns_init(&tns, files, &filecnt, &fileidx, &win);\n\ttns.dirty = true;\n\treturn true;\n}\n\n\n#undef  G_CMD\n#define G_CMD(c) { -1, cg_##c },\n#undef  I_CMD\n#define I_CMD(c) { MODE_IMAGE, ci_##c },\n#undef  T_CMD\n#define T_CMD(c) { MODE_THUMB, ct_##c },\n\nconst cmd_t cmds[CMD_COUNT] = {\n#include \"commands.lst\"\n};\n\n"
        },
        {
          "name": "commands.lst",
          "type": "blob",
          "size": 0.6181640625,
          "content": "G_CMD(quit)\nG_CMD(switch_mode)\nG_CMD(toggle_fullscreen)\nG_CMD(toggle_bar)\nG_CMD(prefix_external)\nG_CMD(reload_image)\nG_CMD(remove_image)\nG_CMD(first)\nG_CMD(n_or_last)\nG_CMD(scroll_screen)\nG_CMD(zoom)\nG_CMD(toggle_image_mark)\nG_CMD(reverse_marks)\nG_CMD(mark_range)\nG_CMD(unmark_all)\nG_CMD(navigate_marked)\nG_CMD(change_gamma)\n\nI_CMD(navigate)\nI_CMD(cursor_navigate)\nI_CMD(alternate)\nI_CMD(navigate_frame)\nI_CMD(toggle_animation)\nI_CMD(scroll)\nI_CMD(scroll_to_edge)\nI_CMD(drag)\nI_CMD(set_zoom)\nI_CMD(fit_to_win)\nI_CMD(rotate)\nI_CMD(flip)\nI_CMD(toggle_antialias)\nI_CMD(toggle_alpha)\nI_CMD(slideshow)\n\nT_CMD(move_sel)\nT_CMD(reload_all)\n\n"
        },
        {
          "name": "config.def.h",
          "type": "blob",
          "size": 7.0947265625,
          "content": "#ifdef _WINDOW_CONFIG\n\n/* default window dimensions (overwritten via -g option): */\nenum {\n\tWIN_WIDTH  = 800,\n\tWIN_HEIGHT = 600\n};\n\n/* colors and font are configured with 'background', 'foreground' and\n * 'font' X resource properties.\n * See X(7) section Resources and xrdb(1) for more information.\n */\n\n#endif\n#ifdef _IMAGE_CONFIG\n\n/* levels (in percent) to use when zooming via '-' and '+':\n * (first/last value is used as min/max zoom level)\n */\nstatic const float zoom_levels[] = {\n\t 12.5,  25.0,  50.0,  75.0,\n\t100.0, 150.0, 200.0, 400.0, 800.0\n};\n\n/* default slideshow delay (in sec, overwritten via -S option): */\nenum { SLIDESHOW_DELAY = 5 };\n\n/* gamma correction: the user-visible ranges [-GAMMA_RANGE, 0] and\n * (0, GAMMA_RANGE] are mapped to the ranges [0, 1], and (1, GAMMA_MAX].\n * */\nstatic const double GAMMA_MAX   = 10.0;\nstatic const int    GAMMA_RANGE = 32;\n\n/* command i_scroll pans image 1/PAN_FRACTION of screen width/height */\nstatic const int PAN_FRACTION = 5;\n\n/* if false, pixelate images at zoom level != 100%,\n * toggled with 'a' key binding\n */\nstatic const bool ANTI_ALIAS = true;\n\n/* if true, use a checkerboard background for alpha layer,\n * toggled with 'A' key binding\n */\nstatic const bool ALPHA_LAYER = false;\n\n#endif\n#ifdef _THUMBS_CONFIG\n\n/* thumbnail sizes in pixels (width == height): */\nstatic const int thumb_sizes[] = { 32, 64, 96, 128, 160 };\n\n/* thumbnail size at startup, index into thumb_sizes[]: */\nstatic const int THUMB_SIZE = 3;\n\n#endif\n#ifdef _MAPPINGS_CONFIG\n\n/* keyboard mappings for image and thumbnail mode: */\nstatic const keymap_t keys[] = {\n\t/* modifiers    key               function              argument */\n\t{ 0,            XK_q,             g_quit,               None },\n\t{ 0,            XK_Return,        g_switch_mode,        None },\n\t{ 0,            XK_f,             g_toggle_fullscreen,  None },\n\t{ 0,            XK_b,             g_toggle_bar,         None },\n\t{ ControlMask,  XK_x,             g_prefix_external,    None },\n\t{ 0,            XK_g,             g_first,              None },\n\t{ 0,            XK_G,             g_n_or_last,          None },\n\t{ 0,            XK_r,             g_reload_image,       None },\n\t{ 0,            XK_D,             g_remove_image,       None },\n\t{ ControlMask,  XK_h,             g_scroll_screen,      DIR_LEFT },\n\t{ ControlMask,  XK_Left,          g_scroll_screen,      DIR_LEFT },\n\t{ ControlMask,  XK_j,             g_scroll_screen,      DIR_DOWN },\n\t{ ControlMask,  XK_Down,          g_scroll_screen,      DIR_DOWN },\n\t{ ControlMask,  XK_k,             g_scroll_screen,      DIR_UP },\n\t{ ControlMask,  XK_Up,            g_scroll_screen,      DIR_UP },\n\t{ ControlMask,  XK_l,             g_scroll_screen,      DIR_RIGHT },\n\t{ ControlMask,  XK_Right,         g_scroll_screen,      DIR_RIGHT },\n\t{ 0,            XK_plus,          g_zoom,               +1 },\n\t{ 0,            XK_KP_Add,        g_zoom,               +1 },\n\t{ 0,            XK_minus,         g_zoom,               -1 },\n\t{ 0,            XK_KP_Subtract,   g_zoom,               -1 },\n\t{ 0,            XK_m,             g_toggle_image_mark,  None },\n\t{ 0,            XK_M,             g_mark_range,         None },\n\t{ ControlMask,  XK_m,             g_reverse_marks,      None },\n\t{ ControlMask,  XK_u,             g_unmark_all,         None },\n\t{ 0,            XK_N,             g_navigate_marked,    +1 },\n\t{ 0,            XK_P,             g_navigate_marked,    -1 },\n\t{ 0,            XK_braceleft,     g_change_gamma,       -1 },\n\t{ 0,            XK_braceright,    g_change_gamma,       +1 },\n\t{ ControlMask,  XK_g,             g_change_gamma,        0 },\n\n\t{ 0,            XK_h,             t_move_sel,           DIR_LEFT },\n\t{ 0,            XK_Left,          t_move_sel,           DIR_LEFT },\n\t{ 0,            XK_j,             t_move_sel,           DIR_DOWN },\n\t{ 0,            XK_Down,          t_move_sel,           DIR_DOWN },\n\t{ 0,            XK_k,             t_move_sel,           DIR_UP },\n\t{ 0,            XK_Up,            t_move_sel,           DIR_UP },\n\t{ 0,            XK_l,             t_move_sel,           DIR_RIGHT },\n\t{ 0,            XK_Right,         t_move_sel,           DIR_RIGHT },\n\t{ 0,            XK_R,             t_reload_all,         None },\n\n\t{ 0,            XK_n,             i_navigate,           +1 },\n\t{ 0,            XK_n,             i_scroll_to_edge,     DIR_LEFT | DIR_UP },\n\t{ 0,            XK_space,         i_navigate,           +1 },\n\t{ 0,            XK_p,             i_navigate,           -1 },\n\t{ 0,            XK_p,             i_scroll_to_edge,     DIR_LEFT | DIR_UP },\n\t{ 0,            XK_BackSpace,     i_navigate,           -1 },\n\t{ 0,            XK_bracketright,  i_navigate,           +10 },\n\t{ 0,            XK_bracketleft,   i_navigate,           -10 },\n\t{ ControlMask,  XK_6,             i_alternate,          None },\n\t{ ControlMask,  XK_n,             i_navigate_frame,     +1 },\n\t{ ControlMask,  XK_p,             i_navigate_frame,     -1 },\n\t{ ControlMask,  XK_space,         i_toggle_animation,   None },\n\t{ 0,            XK_h,             i_scroll,             DIR_LEFT },\n\t{ 0,            XK_Left,          i_scroll,             DIR_LEFT },\n\t{ 0,            XK_j,             i_scroll,             DIR_DOWN },\n\t{ 0,            XK_Down,          i_scroll,             DIR_DOWN },\n\t{ 0,            XK_k,             i_scroll,             DIR_UP },\n\t{ 0,            XK_Up,            i_scroll,             DIR_UP },\n\t{ 0,            XK_l,             i_scroll,             DIR_RIGHT },\n\t{ 0,            XK_Right,         i_scroll,             DIR_RIGHT },\n\t{ 0,            XK_H,             i_scroll_to_edge,     DIR_LEFT },\n\t{ 0,            XK_J,             i_scroll_to_edge,     DIR_DOWN },\n\t{ 0,            XK_K,             i_scroll_to_edge,     DIR_UP },\n\t{ 0,            XK_L,             i_scroll_to_edge,     DIR_RIGHT },\n\t{ 0,            XK_equal,         i_set_zoom,           100 },\n\t{ 0,            XK_w,             i_fit_to_win,         SCALE_DOWN },\n\t{ 0,            XK_W,             i_fit_to_win,         SCALE_FIT },\n\t{ 0,            XK_e,             i_fit_to_win,         SCALE_WIDTH },\n\t{ 0,            XK_E,             i_fit_to_win,         SCALE_HEIGHT },\n\t{ 0,            XK_less,          i_rotate,             DEGREE_270 },\n\t{ 0,            XK_greater,       i_rotate,             DEGREE_90 },\n\t{ 0,            XK_question,      i_rotate,             DEGREE_180 },\n\t{ 0,            XK_bar,           i_flip,               FLIP_HORIZONTAL },\n\t{ 0,            XK_underscore,    i_flip,               FLIP_VERTICAL },\n\t{ 0,            XK_a,             i_toggle_antialias,   None },\n\t{ 0,            XK_A,             i_toggle_alpha,       None },\n\t{ 0,            XK_s,             i_slideshow,          None },\n};\n\n/* mouse button mappings for image mode: */\nstatic const button_t buttons[] = {\n\t/* modifiers    button            function              argument */\n\t{ 0,            1,                i_cursor_navigate,    None },\n\t{ 0,            2,                i_drag,               DRAG_ABSOLUTE },\n\t{ 0,            3,                g_switch_mode,        None },\n\t{ 0,            4,                g_zoom,               +1 },\n\t{ 0,            5,                g_zoom,               -1 },\n};\n\n#endif\n"
        },
        {
          "name": "exec",
          "type": "tree",
          "content": null
        },
        {
          "name": "icon",
          "type": "tree",
          "content": null
        },
        {
          "name": "image.c",
          "type": "blob",
          "size": 16.92578125,
          "content": "/* Copyright 2011, 2012 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _IMAGE_CONFIG\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#if HAVE_LIBEXIF\n#include <libexif/exif-data.h>\n#endif\n\n#if HAVE_GIFLIB\n#include <gif_lib.h>\nenum { DEF_GIF_DELAY = 75 };\n#endif\n\nfloat zoom_min;\nfloat zoom_max;\n\nstatic int zoomdiff(img_t *img, float z)\n{\n\treturn (int) ((img->w * z - img->w * img->zoom) + (img->h * z - img->h * img->zoom));\n}\n\nvoid img_init(img_t *img, win_t *win)\n{\n\tzoom_min = zoom_levels[0] / 100.0;\n\tzoom_max = zoom_levels[ARRLEN(zoom_levels) - 1] / 100.0;\n\n\timlib_context_set_display(win->env.dpy);\n\timlib_context_set_visual(win->env.vis);\n\timlib_context_set_colormap(win->env.cmap);\n\n\timg->im = NULL;\n\timg->win = win;\n\timg->scalemode = options->scalemode;\n\timg->zoom = options->zoom;\n\timg->zoom = MAX(img->zoom, zoom_min);\n\timg->zoom = MIN(img->zoom, zoom_max);\n\timg->checkpan = false;\n\timg->dirty = false;\n\timg->aa = ANTI_ALIAS;\n\timg->alpha = ALPHA_LAYER;\n\timg->multi.cap = img->multi.cnt = 0;\n\timg->multi.animate = options->animate;\n\timg->multi.framedelay = options->framerate > 0 ? 1000 / options->framerate : 0;\n\timg->multi.length = 0;\n\n\timg->cmod = imlib_create_color_modifier();\n\timlib_context_set_color_modifier(img->cmod);\n\timg->gamma = MIN(MAX(options->gamma, -GAMMA_RANGE), GAMMA_RANGE);\n\n\timg->ss.on = options->slideshow > 0;\n\timg->ss.delay = options->slideshow > 0 ? options->slideshow : SLIDESHOW_DELAY * 10;\n}\n\n#if HAVE_LIBEXIF\nvoid exif_auto_orientate(const fileinfo_t *file)\n{\n\tExifData *ed;\n\tExifEntry *entry;\n\tint byte_order, orientation = 0;\n\n\tif ((ed = exif_data_new_from_file(file->path)) == NULL)\n\t\treturn;\n\tbyte_order = exif_data_get_byte_order(ed);\n\tentry = exif_content_get_entry(ed->ifd[EXIF_IFD_0], EXIF_TAG_ORIENTATION);\n\tif (entry != NULL)\n\t\torientation = exif_get_short(entry->data, byte_order);\n\texif_data_unref(ed);\n\n\tswitch (orientation) {\n\t\tcase 5:\n\t\t\timlib_image_orientate(1);\n\t\tcase 2:\n\t\t\timlib_image_flip_vertical();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\timlib_image_orientate(2);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\timlib_image_orientate(1);\n\t\tcase 4:\n\t\t\timlib_image_flip_horizontal();\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\timlib_image_orientate(1);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\timlib_image_orientate(3);\n\t\t\tbreak;\n\t}\n}\n#endif\n\n#if HAVE_GIFLIB\nbool img_load_gif(img_t *img, const fileinfo_t *file)\n{\n\tGifFileType *gif;\n\tGifRowType *rows = NULL;\n\tGifRecordType rec;\n\tColorMapObject *cmap;\n\tDATA32 bgpixel, *data, *ptr;\n\tDATA32 *prev_frame = NULL;\n\tImlib_Image im;\n\tint i, j, bg, r, g, b;\n\tint x, y, w, h, sw, sh;\n\tint px, py, pw, ph;\n\tint intoffset[] = { 0, 4, 2, 1 };\n\tint intjump[] = { 8, 8, 4, 2 };\n\tint transp = -1;\n\tunsigned int disposal = 0, prev_disposal = 0;\n\tunsigned int delay = 0;\n\tbool err = false;\n\n\tif (img->multi.cap == 0) {\n\t\timg->multi.cap = 8;\n\t\timg->multi.frames = (img_frame_t*)\n\t\t                    emalloc(sizeof(img_frame_t) * img->multi.cap);\n\t}\n\timg->multi.cnt = img->multi.sel = 0;\n\timg->multi.length = 0;\n\n#if defined(GIFLIB_MAJOR) && GIFLIB_MAJOR >= 5\n\tgif = DGifOpenFileName(file->path, NULL);\n#else\n\tgif = DGifOpenFileName(file->path);\n#endif\n\tif (gif == NULL) {\n\t\terror(0, 0, \"%s: Error opening gif image\", file->name);\n\t\treturn false;\n\t}\n\tbg = gif->SBackGroundColor;\n\tsw = gif->SWidth;\n\tsh = gif->SHeight;\n\tpx = py = pw = ph = 0;\n\n\tdo {\n\t\tif (DGifGetRecordType(gif, &rec) == GIF_ERROR) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (rec == EXTENSION_RECORD_TYPE) {\n\t\t\tint ext_code;\n\t\t\tGifByteType *ext = NULL;\n\n\t\t\tDGifGetExtension(gif, &ext_code, &ext);\n\t\t\twhile (ext) {\n\t\t\t\tif (ext_code == GRAPHICS_EXT_FUNC_CODE) {\n\t\t\t\t\tif (ext[1] & 1)\n\t\t\t\t\t\ttransp = (int) ext[4];\n\t\t\t\t\telse\n\t\t\t\t\t\ttransp = -1;\n\n\t\t\t\t\tdelay = 10 * ((unsigned int) ext[3] << 8 | (unsigned int) ext[2]);\n\t\t\t\t\tdisposal = (unsigned int) ext[1] >> 2 & 0x7;\n\t\t\t\t}\n\t\t\t\text = NULL;\n\t\t\t\tDGifGetExtensionNext(gif, &ext);\n\t\t\t}\n\t\t} else if (rec == IMAGE_DESC_RECORD_TYPE) {\n\t\t\tif (DGifGetImageDesc(gif) == GIF_ERROR) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = gif->Image.Left;\n\t\t\ty = gif->Image.Top;\n\t\t\tw = gif->Image.Width;\n\t\t\th = gif->Image.Height;\n\n\t\t\trows = (GifRowType*) emalloc(h * sizeof(GifRowType));\n\t\t\tfor (i = 0; i < h; i++)\n\t\t\t\trows[i] = (GifRowType) emalloc(w * sizeof(GifPixelType));\n\t\t\tif (gif->Image.Interlace) {\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tfor (j = intoffset[i]; j < h; j += intjump[i])\n\t\t\t\t\t\tDGifGetLine(gif, rows[j], w);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < h; i++)\n\t\t\t\t\tDGifGetLine(gif, rows[i], w);\n\t\t\t}\n\n\t\t\tptr = data = (DATA32*) emalloc(sizeof(DATA32) * sw * sh);\n\t\t\tcmap = gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap;\n\t\t\tr = cmap->Colors[bg].Red;\n\t\t\tg = cmap->Colors[bg].Green;\n\t\t\tb = cmap->Colors[bg].Blue;\n\t\t\tbgpixel = 0x00ffffff & (r << 16 | g << 8 | b);\n\n\t\t\tfor (i = 0; i < sh; i++) {\n\t\t\t\tfor (j = 0; j < sw; j++) {\n\t\t\t\t\tif (i < y || i >= y + h || j < x || j >= x + w ||\n\t\t\t\t\t    rows[i-y][j-x] == transp)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prev_frame != NULL && (prev_disposal != 2 ||\n\t\t\t\t\t\t    i < py || i >= py + ph || j < px || j >= px + pw))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*ptr = prev_frame[i * sw + j];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*ptr = bgpixel;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr = cmap->Colors[rows[i-y][j-x]].Red;\n\t\t\t\t\t\tg = cmap->Colors[rows[i-y][j-x]].Green;\n\t\t\t\t\t\tb = cmap->Colors[rows[i-y][j-x]].Blue;\n\t\t\t\t\t\t*ptr = 0xffu << 24 | r << 16 | g << 8 | b;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tim = imlib_create_image_using_copied_data(sw, sh, data);\n\n\t\t\tfor (i = 0; i < h; i++)\n\t\t\t\tfree(rows[i]);\n\t\t\tfree(rows);\n\t\t\tfree(data);\n\n\t\t\tif (im == NULL) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\timlib_context_set_image(im);\n\t\t\timlib_image_set_format(\"gif\");\n\t\t\tif (transp >= 0)\n\t\t\t\timlib_image_set_has_alpha(1);\n\n\t\t\tif (disposal != 3)\n\t\t\t\tprev_frame = imlib_image_get_data_for_reading_only();\n\t\t\tprev_disposal = disposal;\n\t\t\tpx = x, py = y, pw = w, ph = h;\n\n\t\t\tif (img->multi.cnt == img->multi.cap) {\n\t\t\t\timg->multi.cap *= 2;\n\t\t\t\timg->multi.frames = (img_frame_t*)\n\t\t\t\t                    erealloc(img->multi.frames,\n\t\t\t\t                             img->multi.cap * sizeof(img_frame_t));\n\t\t\t}\n\t\t\timg->multi.frames[img->multi.cnt].im = im;\n\t\t\tdelay = img->multi.framedelay > 0 ? img->multi.framedelay : delay;\n\t\t\timg->multi.frames[img->multi.cnt].delay = delay > 0 ? delay : DEF_GIF_DELAY;\n\t\t\timg->multi.length += img->multi.frames[img->multi.cnt].delay;\n\t\t\timg->multi.cnt++;\n\t\t}\n\t} while (rec != TERMINATE_RECORD_TYPE);\n\n#if defined(GIFLIB_MAJOR) && GIFLIB_MAJOR >= 5 && GIFLIB_MINOR >= 1\n\tDGifCloseFile(gif, NULL);\n#else\n\tDGifCloseFile(gif);\n#endif\n\n\tif (err && (file->flags & FF_WARN))\n\t\terror(0, 0, \"%s: Corrupted gif file\", file->name);\n\n\tif (img->multi.cnt > 1) {\n\t\timlib_context_set_image(img->im);\n\t\timlib_free_image();\n\t\timg->im = img->multi.frames[0].im;\n\t} else if (img->multi.cnt == 1) {\n\t\timlib_context_set_image(img->multi.frames[0].im);\n\t\timlib_free_image();\n\t\timg->multi.cnt = 0;\n\t}\n\n\timlib_context_set_image(img->im);\n\n\treturn !err;\n}\n#endif /* HAVE_GIFLIB */\n\nImlib_Image img_open(const fileinfo_t *file)\n{\n\tstruct stat st;\n\tImlib_Image im = NULL;\n\n\tif (access(file->path, R_OK) == 0 &&\n\t    stat(file->path, &st) == 0 && S_ISREG(st.st_mode))\n\t{\n\t\tim = imlib_load_image(file->path);\n\t\tif (im != NULL) {\n\t\t\timlib_context_set_image(im);\n\t\t\tif (imlib_image_get_data_for_reading_only() == NULL) {\n\t\t\t\timlib_free_image();\n\t\t\t\tim = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (im == NULL && (file->flags & FF_WARN))\n\t\terror(0, 0, \"%s: Error opening image\", file->name);\n\treturn im;\n}\n\nbool img_load(img_t *img, const fileinfo_t *file)\n{\n\tconst char *fmt;\n\n\tif ((img->im = img_open(file)) == NULL)\n\t\treturn false;\n\n\timlib_image_set_changes_on_disk();\n\n#if HAVE_LIBEXIF\n\texif_auto_orientate(file);\n#endif\n\n\tif ((fmt = imlib_image_format()) != NULL) {\n#if HAVE_GIFLIB\n\t\tif (STREQ(fmt, \"gif\"))\n\t\t\timg_load_gif(img, file);\n#endif\n\t}\n\timg->w = imlib_image_get_width();\n\timg->h = imlib_image_get_height();\n\timg->checkpan = true;\n\timg->dirty = true;\n\n\treturn true;\n}\n\nCLEANUP void img_close(img_t *img, bool decache)\n{\n\tint i;\n\n\tif (img->multi.cnt > 0) {\n\t\tfor (i = 0; i < img->multi.cnt; i++) {\n\t\t\timlib_context_set_image(img->multi.frames[i].im);\n\t\t\timlib_free_image();\n\t\t}\n\t\timg->multi.cnt = 0;\n\t\timg->im = NULL;\n\t} else if (img->im != NULL) {\n\t\timlib_context_set_image(img->im);\n\t\tif (decache)\n\t\t\timlib_free_image_and_decache();\n\t\telse\n\t\t\timlib_free_image();\n\t\timg->im = NULL;\n\t}\n}\n\nvoid img_check_pan(img_t *img, bool moved)\n{\n\twin_t *win;\n\tfloat w, h, ox, oy;\n\n\twin = img->win;\n\tw = img->w * img->zoom;\n\th = img->h * img->zoom;\n\tox = img->x;\n\toy = img->y;\n\n\tif (w < win->w)\n\t\timg->x = (win->w - w) / 2;\n\telse if (img->x > 0)\n\t\timg->x = 0;\n\telse if (img->x + w < win->w)\n\t\timg->x = win->w - w;\n\tif (h < win->h)\n\t\timg->y = (win->h - h) / 2;\n\telse if (img->y > 0)\n\t\timg->y = 0;\n\telse if (img->y + h < win->h)\n\t\timg->y = win->h - h;\n\n\tif (!moved && (ox != img->x || oy != img->y))\n\t\timg->dirty = true;\n}\n\nbool img_fit(img_t *img)\n{\n\tfloat z, zw, zh;\n\n\tif (img->scalemode == SCALE_ZOOM)\n\t\treturn false;\n\n\tzw = (float) img->win->w / (float) img->w;\n\tzh = (float) img->win->h / (float) img->h;\n\n\tswitch (img->scalemode) {\n\t\tcase SCALE_WIDTH:\n\t\t\tz = zw;\n\t\t\tbreak;\n\t\tcase SCALE_HEIGHT:\n\t\t\tz = zh;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tz = MIN(zw, zh);\n\t\t\tbreak;\n\t}\n\tz = MIN(z, img->scalemode == SCALE_DOWN ? 1.0 : zoom_max);\n\n\tif (zoomdiff(img, z) != 0) {\n\t\timg->zoom = z;\n\t\timg->dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvoid img_render(img_t *img)\n{\n\twin_t *win;\n\tint sx, sy, sw, sh;\n\tint dx, dy, dw, dh;\n\tImlib_Image bg;\n\tunsigned long c;\n\n\twin = img->win;\n\timg_fit(img);\n\n\tif (img->checkpan) {\n\t\timg_check_pan(img, false);\n\t\timg->checkpan = false;\n\t}\n\n\tif (!img->dirty)\n\t\treturn;\n\n\t/* calculate source and destination offsets:\n\t *   - part of image drawn on full window, or\n\t *   - full image drawn on part of window\n\t */\n\tif (img->x <= 0) {\n\t\tsx = -img->x / img->zoom + 0.5;\n\t\tsw = win->w / img->zoom;\n\t\tdx = 0;\n\t\tdw = win->w;\n\t} else {\n\t\tsx = 0;\n\t\tsw = img->w;\n\t\tdx = img->x;\n\t\tdw = img->w * img->zoom;\n\t}\n\tif (img->y <= 0) {\n\t\tsy = -img->y / img->zoom + 0.5;\n\t\tsh = win->h / img->zoom;\n\t\tdy = 0;\n\t\tdh = win->h;\n\t} else {\n\t\tsy = 0;\n\t\tsh = img->h;\n\t\tdy = img->y;\n\t\tdh = img->h * img->zoom;\n\t}\n\n\twin_clear(win);\n\n\timlib_context_set_image(img->im);\n\timlib_context_set_anti_alias(img->aa);\n\timlib_context_set_drawable(win->buf.pm);\n\n\tif (imlib_image_has_alpha()) {\n\t\tif ((bg = imlib_create_image(dw, dh)) == NULL)\n\t\t\terror(EXIT_FAILURE, ENOMEM, NULL);\n\t\timlib_context_set_image(bg);\n\t\timlib_image_set_has_alpha(0);\n\n\t\tif (img->alpha) {\n\t\t\tint i, c, r;\n\t\t\tDATA32 col[2] = { 0xFF666666, 0xFF999999 };\n\t\t\tDATA32 * data = imlib_image_get_data();\n\n\t\t\tfor (r = 0; r < dh; r++) {\n\t\t\t\ti = r * dw;\n\t\t\t\tif (r == 0 || r == 8) {\n\t\t\t\t\tfor (c = 0; c < dw; c++)\n\t\t\t\t\t\tdata[i++] = col[!(c & 8) ^ !r];\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(&data[i], &data[(r & 8) * dw], dw * sizeof(data[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t\timlib_image_put_back_data(data);\n\t\t} else {\n\t\t\tc = win->bg.pixel;\n\t\t\timlib_context_set_color(c >> 16 & 0xFF, c >> 8 & 0xFF, c & 0xFF, 0xFF);\n\t\t\timlib_image_fill_rectangle(0, 0, dw, dh);\n\t\t}\n\t\timlib_blend_image_onto_image(img->im, 0, sx, sy, sw, sh, 0, 0, dw, dh);\n\t\timlib_context_set_color_modifier(NULL);\n\t\timlib_render_image_on_drawable(dx, dy);\n\t\timlib_free_image();\n\t\timlib_context_set_color_modifier(img->cmod);\n\t} else {\n\t\timlib_render_image_part_on_drawable_at_size(sx, sy, sw, sh, dx, dy, dw, dh);\n\t}\n\timg->dirty = false;\n}\n\nbool img_fit_win(img_t *img, scalemode_t sm)\n{\n\tfloat oz;\n\n\toz = img->zoom;\n\timg->scalemode = sm;\n\n\tif (img_fit(img)) {\n\t\timg->x = img->win->w / 2 - (img->win->w / 2 - img->x) * img->zoom / oz;\n\t\timg->y = img->win->h / 2 - (img->win->h / 2 - img->y) * img->zoom / oz;\n\t\timg->checkpan = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool img_zoom(img_t *img, float z)\n{\n\tz = MAX(z, zoom_min);\n\tz = MIN(z, zoom_max);\n\n\timg->scalemode = SCALE_ZOOM;\n\n\tif (zoomdiff(img, z) != 0) {\n\t\tint x, y;\n\n\t\twin_cursor_pos(img->win, &x, &y);\n\t\tif (x < 0 || x >= img->win->w || y < 0 || y >= img->win->h) {\n\t\t\tx = img->win->w / 2;\n\t\t\ty = img->win->h / 2;\n\t\t}\n\t\timg->x = x - (x - img->x) * z / img->zoom;\n\t\timg->y = y - (y - img->y) * z / img->zoom;\n\t\timg->zoom = z;\n\t\timg->checkpan = true;\n\t\timg->dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool img_zoom_in(img_t *img)\n{\n\tint i;\n\tfloat z;\n\n\tfor (i = 0; i < ARRLEN(zoom_levels); i++) {\n\t\tz = zoom_levels[i] / 100.0;\n\t\tif (zoomdiff(img, z) > 0)\n\t\t\treturn img_zoom(img, z);\n\t}\n\treturn false;\n}\n\nbool img_zoom_out(img_t *img)\n{\n\tint i;\n\tfloat z;\n\n\tfor (i = ARRLEN(zoom_levels) - 1; i >= 0; i--) {\n\t\tz = zoom_levels[i] / 100.0;\n\t\tif (zoomdiff(img, z) < 0)\n\t\t\treturn img_zoom(img, z);\n\t}\n\treturn false;\n}\n\nbool img_pos(img_t *img, float x, float y)\n{\n\tfloat ox, oy;\n\n\tox = img->x;\n\toy = img->y;\n\n\timg->x = x;\n\timg->y = y;\n\n\timg_check_pan(img, true);\n\n\tif (ox != img->x || oy != img->y) {\n\t\timg->dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool img_move(img_t *img, float dx, float dy)\n{\n\treturn img_pos(img, img->x + dx, img->y + dy);\n}\n\nbool img_pan(img_t *img, direction_t dir, int d)\n{\n\t/* d < 0: screen-wise\n\t * d = 0: 1/PAN_FRACTION of screen\n\t * d > 0: num of pixels\n\t */\n\tfloat x, y;\n\n\tif (d > 0) {\n\t\tx = y = MAX(1, (float) d * img->zoom);\n\t} else {\n\t\tx = img->win->w / (d < 0 ? 1 : PAN_FRACTION);\n\t\ty = img->win->h / (d < 0 ? 1 : PAN_FRACTION);\n\t}\n\n\tswitch (dir) {\n\t\tcase DIR_LEFT:\n\t\t\treturn img_move(img, x, 0.0);\n\t\tcase DIR_RIGHT:\n\t\t\treturn img_move(img, -x, 0.0);\n\t\tcase DIR_UP:\n\t\t\treturn img_move(img, 0.0, y);\n\t\tcase DIR_DOWN:\n\t\t\treturn img_move(img, 0.0, -y);\n\t}\n\treturn false;\n}\n\nbool img_pan_edge(img_t *img, direction_t dir)\n{\n\tfloat ox, oy;\n\n\tox = img->x;\n\toy = img->y;\n\n\tif (dir & DIR_LEFT)\n\t\timg->x = 0;\n\tif (dir & DIR_RIGHT)\n\t\timg->x = img->win->w - img->w * img->zoom;\n\tif (dir & DIR_UP)\n\t\timg->y = 0;\n\tif (dir & DIR_DOWN)\n\t\timg->y = img->win->h - img->h * img->zoom;\n\n\timg_check_pan(img, true);\n\n\tif (ox != img->x || oy != img->y) {\n\t\timg->dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvoid img_rotate(img_t *img, degree_t d)\n{\n\tint i, tmp;\n\tfloat ox, oy;\n\n\timlib_context_set_image(img->im);\n\timlib_image_orientate(d);\n\n\tfor (i = 0; i < img->multi.cnt; i++) {\n\t\tif (i != img->multi.sel) {\n\t\t\timlib_context_set_image(img->multi.frames[i].im);\n\t\t\timlib_image_orientate(d);\n\t\t}\n\t}\n\tif (d == DEGREE_90 || d == DEGREE_270) {\n\t\tox = d == DEGREE_90  ? img->x : img->win->w - img->x - img->w * img->zoom;\n\t\toy = d == DEGREE_270 ? img->y : img->win->h - img->y - img->h * img->zoom;\n\n\t\timg->x = oy + (img->win->w - img->win->h) / 2;\n\t\timg->y = ox + (img->win->h - img->win->w) / 2;\n\n\t\ttmp = img->w;\n\t\timg->w = img->h;\n\t\timg->h = tmp;\n\t\timg->checkpan = true;\n\t}\n\timg->dirty = true;\n}\n\nvoid img_flip(img_t *img, flipdir_t d)\n{\n\tint i;\n\tvoid (*imlib_flip_op[3])(void) = {\n\t\timlib_image_flip_horizontal,\n\t\timlib_image_flip_vertical,\n\t\timlib_image_flip_diagonal\n\t};\n\n\td = (d & (FLIP_HORIZONTAL | FLIP_VERTICAL)) - 1;\n\n\tif (d < 0 || d >= ARRLEN(imlib_flip_op))\n\t\treturn;\n\n\timlib_context_set_image(img->im);\n\timlib_flip_op[d]();\n\n\tfor (i = 0; i < img->multi.cnt; i++) {\n\t\tif (i != img->multi.sel) {\n\t\t\timlib_context_set_image(img->multi.frames[i].im);\n\t\t\timlib_flip_op[d]();\n\t\t}\n\t}\n\timg->dirty = true;\n}\n\nvoid img_toggle_antialias(img_t *img)\n{\n\timg->aa = !img->aa;\n\timlib_context_set_image(img->im);\n\timlib_context_set_anti_alias(img->aa);\n\timg->dirty = true;\n}\n\nbool img_change_gamma(img_t *img, int d)\n{\n\t/* d < 0: decrease gamma\n\t * d = 0: reset gamma\n\t * d > 0: increase gamma\n\t */\n\tint gamma;\n\tdouble range;\n\n\tif (d == 0)\n\t\tgamma = 0;\n\telse\n\t\tgamma = MIN(MAX(img->gamma + d, -GAMMA_RANGE), GAMMA_RANGE);\n\n\tif (img->gamma != gamma) {\n\t\timlib_reset_color_modifier();\n\t\tif (gamma != 0) {\n\t\t\trange = gamma <= 0 ? 1.0 : GAMMA_MAX - 1.0;\n\t\t\timlib_modify_color_modifier_gamma(1.0 + gamma * (range / GAMMA_RANGE));\n\t\t}\n\t\timg->gamma = gamma;\n\t\timg->dirty = true;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool img_frame_goto(img_t *img, int n)\n{\n\tif (n < 0 || n >= img->multi.cnt || n == img->multi.sel)\n\t\treturn false;\n\n\timg->multi.sel = n;\n\timg->im = img->multi.frames[n].im;\n\n\timlib_context_set_image(img->im);\n\timg->w = imlib_image_get_width();\n\timg->h = imlib_image_get_height();\n\timg->checkpan = true;\n\timg->dirty = true;\n\n\treturn true;\n}\n\nbool img_frame_navigate(img_t *img, int d)\n{\n\tif (img->multi.cnt == 0 || d == 0)\n\t\treturn false;\n\n\td += img->multi.sel;\n\tif (d < 0)\n\t\td = 0;\n\telse if (d >= img->multi.cnt)\n\t\td = img->multi.cnt - 1;\n\n\treturn img_frame_goto(img, d);\n}\n\nbool img_frame_animate(img_t *img)\n{\n\tif (img->multi.cnt == 0)\n\t\treturn false;\n\n\tif (img->multi.sel + 1 >= img->multi.cnt)\n\t\timg_frame_goto(img, 0);\n\telse\n\t\timg_frame_goto(img, img->multi.sel + 1);\n\timg->dirty = true;\n\treturn true;\n}\n\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 20.658203125,
          "content": "/* Copyright 2011-2013 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _MAPPINGS_CONFIG\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <locale.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <X11/keysym.h>\n#include <X11/XF86keysym.h>\n\ntypedef struct {\n\tstruct timeval when;\n\tbool active;\n\ttimeout_f handler;\n} timeout_t;\n\n/* timeout handler functions: */\nvoid redraw(void);\nvoid reset_cursor(void);\nvoid animate(void);\nvoid slideshow(void);\nvoid clear_resize(void);\n\nappmode_t mode;\narl_t arl;\nimg_t img;\ntns_t tns;\nwin_t win;\n\nfileinfo_t *files;\nint filecnt, fileidx;\nint alternate;\nint markcnt;\nint markidx;\n\nint prefix;\nbool extprefix;\n\nbool resized = false;\n\ntypedef struct {\n\tint err;\n\tchar *cmd;\n} extcmd_t;\n\nstruct {\n\textcmd_t f;\n\tint fd;\n\tunsigned int i, lastsep;\n\tpid_t pid;\n} info;\n\nstruct {\n\textcmd_t f;\n\tbool warned;\n} keyhandler;\n\ntimeout_t timeouts[] = {\n\t{ { 0, 0 }, false, redraw       },\n\t{ { 0, 0 }, false, reset_cursor },\n\t{ { 0, 0 }, false, animate      },\n\t{ { 0, 0 }, false, slideshow    },\n\t{ { 0, 0 }, false, clear_resize },\n};\n\ncursor_t imgcursor[3] = {\n\tCURSOR_ARROW, CURSOR_ARROW, CURSOR_ARROW\n};\n\nvoid cleanup(void)\n{\n\timg_close(&img, false);\n\tarl_cleanup(&arl);\n\ttns_free(&tns);\n\twin_close(&win);\n}\n\nvoid check_add_file(char *filename, bool given)\n{\n\tchar *path;\n\n\tif (*filename == '\\0')\n\t\treturn;\n\n\tif (access(filename, R_OK) < 0 ||\n\t    (path = realpath(filename, NULL)) == NULL)\n\t{\n\t\tif (given)\n\t\t\terror(0, errno, \"%s\", filename);\n\t\treturn;\n\t}\n\n\tif (fileidx == filecnt) {\n\t\tfilecnt *= 2;\n\t\tfiles = erealloc(files, filecnt * sizeof(*files));\n\t\tmemset(&files[filecnt/2], 0, filecnt/2 * sizeof(*files));\n\t}\n\n\tfiles[fileidx].name = estrdup(filename);\n\tfiles[fileidx].path = path;\n\tif (given)\n\t\tfiles[fileidx].flags |= FF_WARN;\n\tfileidx++;\n}\n\nvoid remove_file(int n, bool manual)\n{\n\tif (n < 0 || n >= filecnt)\n\t\treturn;\n\n\tif (filecnt == 1) {\n\t\tif (!manual)\n\t\t\tfprintf(stderr, \"sxiv: no more files to display, aborting\\n\");\n\t\texit(manual ? EXIT_SUCCESS : EXIT_FAILURE);\n\t}\n\tif (files[n].flags & FF_MARK)\n\t\tmarkcnt--;\n\n\tif (files[n].path != files[n].name)\n\t\tfree((void*) files[n].path);\n\tfree((void*) files[n].name);\n\n\tif (n + 1 < filecnt) {\n\t\tif (tns.thumbs != NULL) {\n\t\t\tmemmove(tns.thumbs + n, tns.thumbs + n + 1, (filecnt - n - 1) *\n\t\t\t        sizeof(*tns.thumbs));\n\t\t\tmemset(tns.thumbs + filecnt - 1, 0, sizeof(*tns.thumbs));\n\t\t}\n\t\tmemmove(files + n, files + n + 1, (filecnt - n - 1) * sizeof(*files));\n\t}\n\tfilecnt--;\n\tif (fileidx > n || fileidx == filecnt)\n\t\tfileidx--;\n\tif (alternate > n || alternate == filecnt)\n\t\talternate--;\n\tif (markidx > n || markidx == filecnt)\n\t\tmarkidx--;\n}\n\nvoid set_timeout(timeout_f handler, int time, bool overwrite)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRLEN(timeouts); i++) {\n\t\tif (timeouts[i].handler == handler) {\n\t\t\tif (!timeouts[i].active || overwrite) {\n\t\t\t\tgettimeofday(&timeouts[i].when, 0);\n\t\t\t\tTV_ADD_MSEC(&timeouts[i].when, time);\n\t\t\t\ttimeouts[i].active = true;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid reset_timeout(timeout_f handler)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRLEN(timeouts); i++) {\n\t\tif (timeouts[i].handler == handler) {\n\t\t\ttimeouts[i].active = false;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool check_timeouts(struct timeval *t)\n{\n\tint i = 0, tdiff, tmin = -1;\n\tstruct timeval now;\n\n\twhile (i < ARRLEN(timeouts)) {\n\t\tif (timeouts[i].active) {\n\t\t\tgettimeofday(&now, 0);\n\t\t\ttdiff = TV_DIFF(&timeouts[i].when, &now);\n\t\t\tif (tdiff <= 0) {\n\t\t\t\ttimeouts[i].active = false;\n\t\t\t\tif (timeouts[i].handler != NULL)\n\t\t\t\t\ttimeouts[i].handler();\n\t\t\t\ti = tmin = -1;\n\t\t\t} else if (tmin < 0 || tdiff < tmin) {\n\t\t\t\ttmin = tdiff;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (tmin > 0 && t != NULL)\n\t\tTV_SET_MSEC(t, tmin);\n\treturn tmin > 0;\n}\n\nvoid close_info(void)\n{\n\tif (info.fd != -1) {\n\t\tkill(info.pid, SIGTERM);\n\t\tclose(info.fd);\n\t\tinfo.fd = -1;\n\t}\n}\n\nvoid open_info(void)\n{\n\tint pfd[2];\n\tchar w[12], h[12];\n\n\tif (info.f.err != 0 || info.fd >= 0 || win.bar.h == 0)\n\t\treturn;\n\twin.bar.l.buf[0] = '\\0';\n\tif (pipe(pfd) < 0)\n\t\treturn;\n\tif ((info.pid = fork()) == 0) {\n\t\tclose(pfd[0]);\n\t\tdup2(pfd[1], 1);\n\t\tsnprintf(w, sizeof(w), \"%d\", img.w);\n\t\tsnprintf(h, sizeof(h), \"%d\", img.h);\n\t\texecl(info.f.cmd, info.f.cmd, files[fileidx].name, w, h, NULL);\n\t\terror(EXIT_FAILURE, errno, \"exec: %s\", info.f.cmd);\n\t}\n\tclose(pfd[1]);\n\tif (info.pid < 0) {\n\t\tclose(pfd[0]);\n\t} else {\n\t\tfcntl(pfd[0], F_SETFL, O_NONBLOCK);\n\t\tinfo.fd = pfd[0];\n\t\tinfo.i = info.lastsep = 0;\n\t}\n}\n\nvoid read_info(void)\n{\n\tssize_t i, n;\n\tchar buf[BAR_L_LEN];\n\n\twhile (true) {\n\t\tn = read(info.fd, buf, sizeof(buf));\n\t\tif (n < 0 && errno == EAGAIN)\n\t\t\treturn;\n\t\telse if (n == 0)\n\t\t\tgoto end;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\tif (info.lastsep == 0) {\n\t\t\t\t\twin.bar.l.buf[info.i++] = ' ';\n\t\t\t\t\tinfo.lastsep = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twin.bar.l.buf[info.i++] = buf[i];\n\t\t\t\tinfo.lastsep = 0;\n\t\t\t}\n\t\t\tif (info.i + 1 == win.bar.l.size)\n\t\t\t\tgoto end;\n\t\t}\n\t}\nend:\n\tinfo.i -= info.lastsep;\n\twin.bar.l.buf[info.i] = '\\0';\n\twin_draw(&win);\n\tclose_info();\n}\n\nvoid load_image(int new)\n{\n\tbool prev = new < fileidx;\n\tstatic int current;\n\n\tif (new < 0 || new >= filecnt)\n\t\treturn;\n\n\tif (win.xwin != None)\n\t\twin_set_cursor(&win, CURSOR_WATCH);\n\treset_timeout(slideshow);\n\n\tif (new != current)\n\t\talternate = current;\n\n\timg_close(&img, false);\n\twhile (!img_load(&img, &files[new])) {\n\t\tremove_file(new, false);\n\t\tif (new >= filecnt)\n\t\t\tnew = filecnt - 1;\n\t\telse if (new > 0 && prev)\n\t\t\tnew--;\n\t}\n\tfiles[new].flags &= ~FF_WARN;\n\tfileidx = current = new;\n\n\tclose_info();\n\topen_info();\n\tarl_setup(&arl, files[fileidx].path);\n\n\tif (img.multi.cnt > 0 && img.multi.animate)\n\t\tset_timeout(animate, img.multi.frames[img.multi.sel].delay, true);\n\telse\n\t\treset_timeout(animate);\n}\n\nbool mark_image(int n, bool on)\n{\n\tmarkidx = n;\n\tif (!!(files[n].flags & FF_MARK) != on) {\n\t\tfiles[n].flags ^= FF_MARK;\n\t\tmarkcnt += on ? 1 : -1;\n\t\tif (mode == MODE_THUMB)\n\t\t\ttns_mark(&tns, n, on);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid bar_put(win_bar_t *bar, const char *fmt, ...)\n{\n\tsize_t len = bar->size - (bar->p - bar->buf), n;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(bar->p, len, fmt, ap);\n\tbar->p += MIN(len, n);\n\tva_end(ap);\n}\n\n#define BAR_SEP \"  \"\n\nvoid update_info(void)\n{\n\tunsigned int i, fn, fw;\n\tconst char * mark;\n\twin_bar_t *l = &win.bar.l, *r = &win.bar.r;\n\n\t/* update bar contents */\n\tif (win.bar.h == 0)\n\t\treturn;\n\tfor (fw = 0, i = filecnt; i > 0; fw++, i /= 10);\n\tmark = files[fileidx].flags & FF_MARK ? \"* \" : \"\";\n\tl->p = l->buf;\n\tr->p = r->buf;\n\tif (mode == MODE_THUMB) {\n\t\tif (tns.loadnext < tns.end)\n\t\t\tbar_put(l, \"Loading... %0*d\", fw, tns.loadnext + 1);\n\t\telse if (tns.initnext < filecnt)\n\t\t\tbar_put(l, \"Caching... %0*d\", fw, tns.initnext + 1);\n\t\telse\n\t\t\tstrncpy(l->buf, files[fileidx].name, l->size);\n\t\tbar_put(r, \"%s%0*d/%d\", mark, fw, fileidx + 1, filecnt);\n\t} else {\n\t\tbar_put(r, \"%s\", mark);\n\t\tif (img.ss.on) {\n\t\t\tif (img.ss.delay % 10 != 0)\n\t\t\t\tbar_put(r, \"%2.1fs\" BAR_SEP, (float)img.ss.delay / 10);\n\t\t\telse\n\t\t\t\tbar_put(r, \"%ds\" BAR_SEP, img.ss.delay / 10);\n\t\t}\n\t\tif (img.gamma != 0)\n\t\t\tbar_put(r, \"G%+d\" BAR_SEP, img.gamma);\n\t\tbar_put(r, \"%3d%%\" BAR_SEP, (int) (img.zoom * 100.0));\n\t\tif (img.multi.cnt > 0) {\n\t\t\tfor (fn = 0, i = img.multi.cnt; i > 0; fn++, i /= 10);\n\t\t\tbar_put(r, \"%0*d/%d\" BAR_SEP, fn, img.multi.sel + 1, img.multi.cnt);\n\t\t}\n\t\tbar_put(r, \"%0*d/%d\", fw, fileidx + 1, filecnt);\n\t\tif (info.f.err)\n\t\t\tstrncpy(l->buf, files[fileidx].name, l->size);\n\t}\n}\n\nint ptr_third_x(void)\n{\n\tint x, y;\n\n\twin_cursor_pos(&win, &x, &y);\n\treturn MAX(0, MIN(2, (x / (win.w * 0.33))));\n}\n\nvoid redraw(void)\n{\n\tint t;\n\n\tif (mode == MODE_IMAGE) {\n\t\timg_render(&img);\n\t\tif (img.ss.on) {\n\t\t\tt = img.ss.delay * 100;\n\t\t\tif (img.multi.cnt > 0 && img.multi.animate)\n\t\t\t\tt = MAX(t, img.multi.length);\n\t\t\tset_timeout(slideshow, t, false);\n\t\t}\n\t} else {\n\t\ttns_render(&tns);\n\t}\n\tupdate_info();\n\twin_draw(&win);\n\treset_timeout(redraw);\n\treset_cursor();\n}\n\nvoid reset_cursor(void)\n{\n\tint c, i;\n\tcursor_t cursor = CURSOR_NONE;\n\n\tif (mode == MODE_IMAGE) {\n\t\tfor (i = 0; i < ARRLEN(timeouts); i++) {\n\t\t\tif (timeouts[i].handler == reset_cursor) {\n\t\t\t\tif (timeouts[i].active) {\n\t\t\t\t\tc = ptr_third_x();\n\t\t\t\t\tc = MAX(fileidx > 0 ? 0 : 1, c);\n\t\t\t\t\tc = MIN(fileidx + 1 < filecnt ? 2 : 1, c);\n\t\t\t\t\tcursor = imgcursor[c];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (tns.loadnext < tns.end || tns.initnext < filecnt)\n\t\t\tcursor = CURSOR_WATCH;\n\t\telse\n\t\t\tcursor = CURSOR_ARROW;\n\t}\n\twin_set_cursor(&win, cursor);\n}\n\nvoid animate(void)\n{\n\tif (img_frame_animate(&img)) {\n\t\tredraw();\n\t\tset_timeout(animate, img.multi.frames[img.multi.sel].delay, true);\n\t}\n}\n\nvoid slideshow(void)\n{\n\tload_image(fileidx + 1 < filecnt ? fileidx + 1 : 0);\n\tredraw();\n}\n\nvoid clear_resize(void)\n{\n\tresized = false;\n}\n\nBool is_input_ev(Display *dpy, XEvent *ev, XPointer arg)\n{\n\treturn ev->type == ButtonPress || ev->type == KeyPress;\n}\n\nvoid run_key_handler(const char *key, unsigned int mask)\n{\n\tpid_t pid;\n\tFILE *pfs;\n\tbool marked = mode == MODE_THUMB && markcnt > 0;\n\tbool changed = false;\n\tint f, i, pfd[2];\n\tint fcnt = marked ? markcnt : 1;\n\tchar kstr[32];\n\tstruct stat *oldst, st;\n\tXEvent dump;\n\n\tif (keyhandler.f.err != 0) {\n\t\tif (!keyhandler.warned) {\n\t\t\terror(0, keyhandler.f.err, \"%s\", keyhandler.f.cmd);\n\t\t\tkeyhandler.warned = true;\n\t\t}\n\t\treturn;\n\t}\n\tif (key == NULL)\n\t\treturn;\n\n\tif (pipe(pfd) < 0) {\n\t\terror(0, errno, \"pipe\");\n\t\treturn;\n\t}\n\tif ((pfs = fdopen(pfd[1], \"w\")) == NULL) {\n\t\terror(0, errno, \"open pipe\");\n\t\tclose(pfd[0]), close(pfd[1]);\n\t\treturn;\n\t}\n\toldst = emalloc(fcnt * sizeof(*oldst));\n\n\tclose_info();\n\tstrncpy(win.bar.l.buf, \"Running key handler...\", win.bar.l.size);\n\twin_draw(&win);\n\twin_set_cursor(&win, CURSOR_WATCH);\n\n\tsnprintf(kstr, sizeof(kstr), \"%s%s%s%s\",\n\t         mask & ControlMask ? \"C-\" : \"\",\n\t         mask & Mod1Mask    ? \"M-\" : \"\",\n\t         mask & ShiftMask   ? \"S-\" : \"\", key);\n\n\tif ((pid = fork()) == 0) {\n\t\tclose(pfd[1]);\n\t\tdup2(pfd[0], 0);\n\t\texecl(keyhandler.f.cmd, keyhandler.f.cmd, kstr, NULL);\n\t\terror(EXIT_FAILURE, errno, \"exec: %s\", keyhandler.f.cmd);\n\t}\n\tclose(pfd[0]);\n\tif (pid < 0) {\n\t\terror(0, errno, \"fork\");\n\t\tfclose(pfs);\n\t\tgoto end;\n\t}\n\n\tfor (f = i = 0; f < fcnt; i++) {\n\t\tif ((marked && (files[i].flags & FF_MARK)) || (!marked && i == fileidx)) {\n\t\t\tstat(files[i].path, &oldst[f]);\n\t\t\tfprintf(pfs, \"%s\\n\", files[i].name);\n\t\t\tf++;\n\t\t}\n\t}\n\tfclose(pfs);\n\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR);\n\n\tfor (f = i = 0; f < fcnt; i++) {\n\t\tif ((marked && (files[i].flags & FF_MARK)) || (!marked && i == fileidx)) {\n\t\t\tif (stat(files[i].path, &st) != 0 ||\n\t\t\t\t  memcmp(&oldst[f].st_mtime, &st.st_mtime, sizeof(st.st_mtime)) != 0)\n\t\t\t{\n\t\t\t\tif (tns.thumbs != NULL) {\n\t\t\t\t\ttns_unload(&tns, i);\n\t\t\t\t\ttns.loadnext = MIN(tns.loadnext, i);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tf++;\n\t\t}\n\t}\n\t/* drop user input events that occurred while running the key handler */\n\twhile (XCheckIfEvent(win.env.dpy, &dump, is_input_ev, NULL));\n\nend:\n\tif (mode == MODE_IMAGE) {\n\t\tif (changed) {\n\t\t\timg_close(&img, true);\n\t\t\tload_image(fileidx);\n\t\t} else {\n\t\t\topen_info();\n\t\t}\n\t}\n\tfree(oldst);\n\treset_cursor();\n\tredraw();\n}\n\n#define MODMASK(mask) ((mask) & (ShiftMask|ControlMask|Mod1Mask))\n\nvoid on_keypress(XKeyEvent *kev)\n{\n\tint i;\n\tunsigned int sh = 0;\n\tKeySym ksym, shksym;\n\tchar dummy, key;\n\tbool dirty = false;\n\n\tXLookupString(kev, &key, 1, &ksym, NULL);\n\n\tif (kev->state & ShiftMask) {\n\t\tkev->state &= ~ShiftMask;\n\t\tXLookupString(kev, &dummy, 1, &shksym, NULL);\n\t\tkev->state |= ShiftMask;\n\t\tif (ksym != shksym)\n\t\t\tsh = ShiftMask;\n\t}\n\tif (IsModifierKey(ksym))\n\t\treturn;\n\tif (ksym == XK_Escape && MODMASK(kev->state) == 0) {\n\t\textprefix = False;\n\t} else if (extprefix) {\n\t\trun_key_handler(XKeysymToString(ksym), kev->state & ~sh);\n\t\textprefix = False;\n\t} else if (key >= '0' && key <= '9') {\n\t\t/* number prefix for commands */\n\t\tprefix = prefix * 10 + (int) (key - '0');\n\t\treturn;\n\t} else for (i = 0; i < ARRLEN(keys); i++) {\n\t\tif (keys[i].ksym == ksym &&\n\t\t    MODMASK(keys[i].mask | sh) == MODMASK(kev->state) &&\n\t\t    keys[i].cmd >= 0 && keys[i].cmd < CMD_COUNT &&\n\t\t    (cmds[keys[i].cmd].mode < 0 || cmds[keys[i].cmd].mode == mode))\n\t\t{\n\t\t\tif (cmds[keys[i].cmd].func(keys[i].arg))\n\t\t\t\tdirty = true;\n\t\t}\n\t}\n\tif (dirty)\n\t\tredraw();\n\tprefix = 0;\n}\n\nvoid on_buttonpress(XButtonEvent *bev)\n{\n\tint i, sel;\n\tbool dirty = false;\n\tstatic Time firstclick;\n\n\tif (mode == MODE_IMAGE) {\n\t\tset_timeout(reset_cursor, TO_CURSOR_HIDE, true);\n\t\treset_cursor();\n\n\t\tfor (i = 0; i < ARRLEN(buttons); i++) {\n\t\t\tif (buttons[i].button == bev->button &&\n\t\t\t    MODMASK(buttons[i].mask) == MODMASK(bev->state) &&\n\t\t\t    buttons[i].cmd >= 0 && buttons[i].cmd < CMD_COUNT &&\n\t\t\t    (cmds[buttons[i].cmd].mode < 0 || cmds[buttons[i].cmd].mode == mode))\n\t\t\t{\n\t\t\t\tif (cmds[buttons[i].cmd].func(buttons[i].arg))\n\t\t\t\t\tdirty = true;\n\t\t\t}\n\t\t}\n\t\tif (dirty)\n\t\t\tredraw();\n\t} else {\n\t\t/* thumbnail mode (hard-coded) */\n\t\tswitch (bev->button) {\n\t\t\tcase Button1:\n\t\t\t\tif ((sel = tns_translate(&tns, bev->x, bev->y)) >= 0) {\n\t\t\t\t\tif (sel != fileidx) {\n\t\t\t\t\t\ttns_highlight(&tns, fileidx, false);\n\t\t\t\t\t\ttns_highlight(&tns, sel, true);\n\t\t\t\t\t\tfileidx = sel;\n\t\t\t\t\t\tfirstclick = bev->time;\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t} else if (bev->time - firstclick <= TO_DOUBLE_CLICK) {\n\t\t\t\t\t\tmode = MODE_IMAGE;\n\t\t\t\t\t\tset_timeout(reset_cursor, TO_CURSOR_HIDE, true);\n\t\t\t\t\t\tload_image(fileidx);\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfirstclick = bev->time;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Button3:\n\t\t\t\tif ((sel = tns_translate(&tns, bev->x, bev->y)) >= 0) {\n\t\t\t\t\tbool on = !(files[sel].flags & FF_MARK);\n\t\t\t\t\tXEvent e;\n\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif (sel >= 0 && mark_image(sel, on))\n\t\t\t\t\t\t\tredraw();\n\t\t\t\t\t\tXMaskEvent(win.env.dpy,\n\t\t\t\t\t\t           ButtonPressMask | ButtonReleaseMask | PointerMotionMask, &e);\n\t\t\t\t\t\tif (e.type == ButtonPress || e.type == ButtonRelease)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\twhile (XCheckTypedEvent(win.env.dpy, MotionNotify, &e));\n\t\t\t\t\t\tsel = tns_translate(&tns, e.xbutton.x, e.xbutton.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Button4:\n\t\t\tcase Button5:\n\t\t\t\tif (tns_scroll(&tns, bev->button == Button4 ? DIR_UP : DIR_DOWN,\n\t\t\t\t               (bev->state & ControlMask) != 0))\n\t\t\t\t\tredraw();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprefix = 0;\n}\n\nconst struct timespec ten_ms = {0, 10000000};\n\nvoid run(void)\n{\n\tint xfd;\n\tfd_set fds;\n\tstruct timeval timeout;\n\tbool discard, init_thumb, load_thumb, to_set;\n\tXEvent ev, nextev;\n\n\twhile (true) {\n\t\tto_set = check_timeouts(&timeout);\n\t\tinit_thumb = mode == MODE_THUMB && tns.initnext < filecnt;\n\t\tload_thumb = mode == MODE_THUMB && tns.loadnext < tns.end;\n\n\t\tif ((init_thumb || load_thumb || to_set || info.fd != -1 ||\n\t\t\t   arl.fd != -1) && XPending(win.env.dpy) == 0)\n\t\t{\n\t\t\tif (load_thumb) {\n\t\t\t\tset_timeout(redraw, TO_REDRAW_THUMBS, false);\n\t\t\t\tif (!tns_load(&tns, tns.loadnext, false, false)) {\n\t\t\t\t\tremove_file(tns.loadnext, false);\n\t\t\t\t\ttns.dirty = true;\n\t\t\t\t}\n\t\t\t\tif (tns.loadnext >= tns.end)\n\t\t\t\t\tredraw();\n\t\t\t} else if (init_thumb) {\n\t\t\t\tset_timeout(redraw, TO_REDRAW_THUMBS, false);\n\t\t\t\tif (!tns_load(&tns, tns.initnext, false, true))\n\t\t\t\t\tremove_file(tns.initnext, false);\n\t\t\t} else {\n\t\t\t\txfd = ConnectionNumber(win.env.dpy);\n\t\t\t\tFD_ZERO(&fds);\n\t\t\t\tFD_SET(xfd, &fds);\n\t\t\t\tif (info.fd != -1) {\n\t\t\t\t\tFD_SET(info.fd, &fds);\n\t\t\t\t\txfd = MAX(xfd, info.fd);\n\t\t\t\t}\n\t\t\t\tif (arl.fd != -1) {\n\t\t\t\t\tFD_SET(arl.fd, &fds);\n\t\t\t\t\txfd = MAX(xfd, arl.fd);\n\t\t\t\t}\n\t\t\t\tselect(xfd + 1, &fds, 0, 0, to_set ? &timeout : NULL);\n\t\t\t\tif (info.fd != -1 && FD_ISSET(info.fd, &fds))\n\t\t\t\t\tread_info();\n\t\t\t\tif (arl.fd != -1 && FD_ISSET(arl.fd, &fds)) {\n\t\t\t\t\tif (arl_handle(&arl)) {\n\t\t\t\t\t\t/* when too fast, imlib2 can't load the image */\n\t\t\t\t\t\tnanosleep(&ten_ms, NULL);\n\t\t\t\t\t\timg_close(&img, true);\n\t\t\t\t\t\tload_image(fileidx);\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tXNextEvent(win.env.dpy, &ev);\n\t\t\tdiscard = false;\n\t\t\tif (XEventsQueued(win.env.dpy, QueuedAlready) > 0) {\n\t\t\t\tXPeekEvent(win.env.dpy, &nextev);\n\t\t\t\tswitch (ev.type) {\n\t\t\t\t\tcase ConfigureNotify:\n\t\t\t\t\tcase MotionNotify:\n\t\t\t\t\t\tdiscard = ev.type == nextev.type;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase KeyPress:\n\t\t\t\t\t\tdiscard = (nextev.type == KeyPress || nextev.type == KeyRelease)\n\t\t\t\t\t\t          && ev.xkey.keycode == nextev.xkey.keycode;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (discard);\n\n\t\tswitch (ev.type) {\n\t\t\t/* handle events */\n\t\t\tcase ButtonPress:\n\t\t\t\ton_buttonpress(&ev.xbutton);\n\t\t\t\tbreak;\n\t\t\tcase ClientMessage:\n\t\t\t\tif ((Atom) ev.xclient.data.l[0] == atoms[ATOM_WM_DELETE_WINDOW])\n\t\t\t\t\tcmds[g_quit].func(0);\n\t\t\t\tbreak;\n\t\t\tcase ConfigureNotify:\n\t\t\t\tif (win_configure(&win, &ev.xconfigure)) {\n\t\t\t\t\tif (mode == MODE_IMAGE) {\n\t\t\t\t\t\timg.dirty = true;\n\t\t\t\t\t\timg.checkpan = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttns.dirty = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!resized) {\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t\tset_timeout(clear_resize, TO_REDRAW_RESIZE, false);\n\t\t\t\t\t\tresized = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_timeout(redraw, TO_REDRAW_RESIZE, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase KeyPress:\n\t\t\t\ton_keypress(&ev.xkey);\n\t\t\t\tbreak;\n\t\t\tcase MotionNotify:\n\t\t\t\tif (mode == MODE_IMAGE) {\n\t\t\t\t\tset_timeout(reset_cursor, TO_CURSOR_HIDE, true);\n\t\t\t\t\treset_cursor();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint fncmp(const void *a, const void *b)\n{\n\treturn strcoll(((fileinfo_t*) a)->name, ((fileinfo_t*) b)->name);\n}\n\nvoid sigchld(int sig)\n{\n\twhile (waitpid(-1, NULL, WNOHANG) > 0);\n}\n\nvoid setup_signal(int sig, void (*handler)(int sig))\n{\n\tstruct sigaction sa;\n\n\tsa.sa_handler = handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\tif (sigaction(sig, &sa, 0) == -1)\n\t\terror(EXIT_FAILURE, errno, \"signal %d\", sig);\n}\n\nint main(int argc, char **argv)\n{\n\tint i, start;\n\tsize_t n;\n\tssize_t len;\n\tchar *filename;\n\tconst char *homedir, *dsuffix = \"\";\n\tstruct stat fstats;\n\tr_dir_t dir;\n\n\tsetup_signal(SIGCHLD, sigchld);\n\tsetup_signal(SIGPIPE, SIG_IGN);\n\n\tsetlocale(LC_COLLATE, \"\");\n\n\tparse_options(argc, argv);\n\n\tif (options->clean_cache) {\n\t\ttns_init(&tns, NULL, NULL, NULL, NULL);\n\t\ttns_clean_cache(&tns);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (options->filecnt == 0 && !options->from_stdin) {\n\t\tprint_usage();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (options->recursive || options->from_stdin)\n\t\tfilecnt = 1024;\n\telse\n\t\tfilecnt = options->filecnt;\n\n\tfiles = emalloc(filecnt * sizeof(*files));\n\tmemset(files, 0, filecnt * sizeof(*files));\n\tfileidx = 0;\n\n\tif (options->from_stdin) {\n\t\tn = 0;\n\t\tfilename = NULL;\n\t\twhile ((len = getline(&filename, &n, stdin)) > 0) {\n\t\t\tif (filename[len-1] == '\\n')\n\t\t\t\tfilename[len-1] = '\\0';\n\t\t\tcheck_add_file(filename, true);\n\t\t}\n\t\tfree(filename);\n\t}\n\n\tfor (i = 0; i < options->filecnt; i++) {\n\t\tfilename = options->filenames[i];\n\n\t\tif (stat(filename, &fstats) < 0) {\n\t\t\terror(0, errno, \"%s\", filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISDIR(fstats.st_mode)) {\n\t\t\tcheck_add_file(filename, true);\n\t\t} else {\n\t\t\tif (r_opendir(&dir, filename, options->recursive) < 0) {\n\t\t\t\terror(0, errno, \"%s\", filename);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstart = fileidx;\n\t\t\twhile ((filename = r_readdir(&dir, true)) != NULL) {\n\t\t\t\tcheck_add_file(filename, false);\n\t\t\t\tfree((void*) filename);\n\t\t\t}\n\t\t\tr_closedir(&dir);\n\t\t\tif (fileidx - start > 1)\n\t\t\t\tqsort(files + start, fileidx - start, sizeof(fileinfo_t), fncmp);\n\t\t}\n\t}\n\n\tif (fileidx == 0)\n\t\terror(EXIT_FAILURE, 0, \"No valid image file given, aborting\");\n\n\tfilecnt = fileidx;\n\tfileidx = options->startnum < filecnt ? options->startnum : 0;\n\n\tfor (i = 0; i < ARRLEN(buttons); i++) {\n\t\tif (buttons[i].cmd == i_cursor_navigate) {\n\t\t\timgcursor[0] = CURSOR_LEFT;\n\t\t\timgcursor[2] = CURSOR_RIGHT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twin_init(&win);\n\timg_init(&img, &win);\n\tarl_init(&arl);\n\n\tif ((homedir = getenv(\"XDG_CONFIG_HOME\")) == NULL || homedir[0] == '\\0') {\n\t\thomedir = getenv(\"HOME\");\n\t\tdsuffix = \"/.config\";\n\t}\n\tif (homedir != NULL) {\n\t\textcmd_t *cmd[] = { &info.f, &keyhandler.f };\n\t\tconst char *name[] = { \"image-info\", \"key-handler\" };\n\n\t\tfor (i = 0; i < ARRLEN(cmd); i++) {\n\t\t\tn = strlen(homedir) + strlen(dsuffix) + strlen(name[i]) + 12;\n\t\t\tcmd[i]->cmd = (char*) emalloc(n);\n\t\t\tsnprintf(cmd[i]->cmd, n, \"%s%s/sxiv/exec/%s\", homedir, dsuffix, name[i]);\n\t\t\tif (access(cmd[i]->cmd, X_OK) != 0)\n\t\t\t\tcmd[i]->err = errno;\n\t\t}\n\t} else {\n\t\terror(0, 0, \"Exec directory not found\");\n\t}\n\tinfo.fd = -1;\n\n\tif (options->thumb_mode) {\n\t\tmode = MODE_THUMB;\n\t\ttns_init(&tns, files, &filecnt, &fileidx, &win);\n\t\twhile (!tns_load(&tns, fileidx, false, false))\n\t\t\tremove_file(fileidx, false);\n\t} else {\n\t\tmode = MODE_IMAGE;\n\t\ttns.thumbs = NULL;\n\t\tload_image(fileidx);\n\t}\n\twin_open(&win);\n\twin_set_cursor(&win, CURSOR_WATCH);\n\n\tatexit(cleanup);\n\n\tset_timeout(redraw, 25, false);\n\n\trun();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 4.4326171875,
          "content": "/* Copyright 2011 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _IMAGE_CONFIG\n#include \"config.h\"\n#include \"version.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nopt_t _options;\nconst opt_t *options = (const opt_t*) &_options;\n\nvoid print_usage(void)\n{\n\tprintf(\"usage: sxiv [-abcfhiopqrtvZ] [-A FRAMERATE] [-e WID] [-G GAMMA] \"\n\t       \"[-g GEOMETRY] [-N NAME] [-n NUM] [-S DELAY] [-s MODE] [-z ZOOM] \"\n\t       \"FILES...\\n\");\n}\n\nvoid print_version(void)\n{\n\tputs(\"sxiv \" VERSION);\n}\n\nvoid parse_options(int argc, char **argv)\n{\n\tint n, opt;\n\tchar *end, *s;\n\tconst char *scalemodes = \"dfwh\";\n\n\tprogname = strrchr(argv[0], '/');\n\tprogname = progname ? progname + 1 : argv[0];\n\n\t_options.from_stdin = false;\n\t_options.to_stdout = false;\n\t_options.recursive = false;\n\t_options.startnum = 0;\n\n\t_options.scalemode = SCALE_DOWN;\n\t_options.zoom = 1.0;\n\t_options.animate = false;\n\t_options.gamma = 0;\n\t_options.slideshow = 0;\n\t_options.framerate = 0;\n\n\t_options.fullscreen = false;\n\t_options.embed = 0;\n\t_options.hide_bar = false;\n\t_options.geometry = NULL;\n\t_options.res_name = NULL;\n\n\t_options.quiet = false;\n\t_options.thumb_mode = false;\n\t_options.clean_cache = false;\n\t_options.private_mode = false;\n\n\twhile ((opt = getopt(argc, argv, \"A:abce:fG:g:hin:N:opqrS:s:tvZz:\")) != -1) {\n\t\tswitch (opt) {\n\t\t\tcase '?':\n\t\t\t\tprint_usage();\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\tcase 'A':\n\t\t\t\tn = strtol(optarg, &end, 0);\n\t\t\t\tif (*end != '\\0' || n <= 0)\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -A: %s\", optarg);\n\t\t\t\t_options.framerate = n;\n\t\t\t\t/* fall through */\n\t\t\tcase 'a':\n\t\t\t\t_options.animate = true;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\t_options.hide_bar = true;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\t_options.clean_cache = true;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tn = strtol(optarg, &end, 0);\n\t\t\t\tif (*end != '\\0')\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -e: %s\", optarg);\n\t\t\t\t_options.embed = n;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\t_options.fullscreen = true;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tn = strtol(optarg, &end, 0);\n\t\t\t\tif (*end != '\\0')\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -G: %s\", optarg);\n\t\t\t\t_options.gamma = n;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\t_options.geometry = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tprint_usage();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'i':\n\t\t\t\t_options.from_stdin = true;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tn = strtol(optarg, &end, 0);\n\t\t\t\tif (*end != '\\0' || n <= 0)\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -n: %s\", optarg);\n\t\t\t\t_options.startnum = n - 1;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t_options.res_name = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\t_options.to_stdout = true;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\t_options.private_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t_options.quiet = true;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\t_options.recursive = true;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tn = strtof(optarg, &end) * 10;\n\t\t\t\tif (*end != '\\0' || n <= 0)\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -S: %s\", optarg);\n\t\t\t\t_options.slideshow = n;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\ts = strchr(scalemodes, optarg[0]);\n\t\t\t\tif (s == NULL || *s == '\\0' || strlen(optarg) != 1)\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -s: %s\", optarg);\n\t\t\t\t_options.scalemode = s - scalemodes;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\t_options.thumb_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'Z':\n\t\t\t\t_options.scalemode = SCALE_ZOOM;\n\t\t\t\t_options.zoom = 1.0;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tn = strtol(optarg, &end, 0);\n\t\t\t\tif (*end != '\\0' || n <= 0)\n\t\t\t\t\terror(EXIT_FAILURE, 0, \"Invalid argument for option -z: %s\", optarg);\n\t\t\t\t_options.scalemode = SCALE_ZOOM;\n\t\t\t\t_options.zoom = (float) n / 100.0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t_options.filenames = argv + optind;\n\t_options.filecnt = argc - optind;\n\n\tif (_options.filecnt == 1 && STREQ(_options.filenames[0], \"-\")) {\n\t\t_options.filenames++;\n\t\t_options.filecnt--;\n\t\t_options.from_stdin = true;\n\t}\n}\n"
        },
        {
          "name": "sxiv.1",
          "type": "blob",
          "size": 8.3681640625,
          "content": ".TH SXIV 1 sxiv\\-VERSION\n.SH NAME\nsxiv \\- Simple X Image Viewer\n.SH SYNOPSIS\n.B sxiv\n.RB [ \\-abcfhiopqrtvZ ]\n.RB [ \\-A\n.IR FRAMERATE ]\n.RB [ \\-e\n.IR WID ]\n.RB [ \\-G\n.IR GAMMA ]\n.RB [ \\-g\n.IR GEOMETRY ]\n.RB [ \\-N\n.IR NAME ]\n.RB [ \\-n\n.IR NUM ]\n.RB [ \\-S\n.IR DELAY ]\n.RB [ \\-s\n.IR MODE ]\n.RB [ \\-z\n.IR ZOOM ]\n.IR FILE ...\n.SH DESCRIPTION\nsxiv is a simple image viewer for X.\n.P\nIt has two modes of operation: image and thumbnail mode. The default is image\nmode, in which only the current image is shown. In thumbnail mode a grid of \nsmall previews is displayed, making it easy to choose an image to open.\n.P\nPlease note, that the fullscreen mode requires an EWMH/NetWM compliant window\nmanager.\n.SH OPTIONS\n.TP\n.BI \"\\-A \" FRAMERATE\nPlay animations with a constant frame rate set to\n.IR FRAMERATE .\n.TP\n.B \\-a\nPlay animations of multi-frame images.\n.TP\n.B \\-b\nDo not show info bar on bottom of window.\n.TP\n.B \\-c\nRemove all orphaned cache files from the thumbnail cache directory and exit.\n.TP\n.BI \"\\-e \" WID\nEmbed sxiv's window into window whose ID is\n.IR WID .\n.TP\n.B \\-f\nStart in fullscreen mode.\n.TP\n.BI \"\\-G \" GAMMA\nSet image gamma to GAMMA (-32..32).\n.TP\n.BI \"\\-g \" GEOMETRY\nSet window position and size. See section GEOMETRY SPECIFICATIONS of X(7) for\nmore information on GEOMETRY argument.\n.TP\n.BI \"\\-N \" NAME\nSet the resource name of sxiv's X window to NAME.\n.TP\n.BI \"\\-n \" NUM\nStart at picture number NUM.\n.TP\n.B \\-h\nPrint brief usage information to standard output and exit.\n.TP\n.B \\-i\nRead names of files to open from standard input. Also done if FILE is `-'.\n.TP\n.B \\-o\nWrite list of all marked files to standard output when quitting. In combination\nwith\n.B \\-i\nsxiv can be used as a visual filter/pipe.\n.TP\n.B \\-p\nEnable private mode, in which sxiv does not write any cache or temporary files.\n.TP\n.B \\-q\nBe quiet, disable warnings to standard error stream.\n.TP\n.B \\-r\nSearch the given directories recursively for images to view.\n.TP\n.BI \"\\-S \" DELAY\nStart in slideshow mode. Set the delay between images to\n.I DELAY\nseconds.\n.I DELAY\nmay be a floating point number.\n.TP\n.BI \"\\-s \" MODE\nSet scale mode according to MODE character. Supported modes are: [d]own, \n[f]it, [w]idth, [h]eight.\n.TP\n.B \\-t\nStart in thumbnail mode.\n.TP\n.B \\-v\nPrint version information to standard output and exit.\n.TP\n.B \\-Z\nThe same as `\\-z 100'.\n.TP\n.BI \"\\-z \" ZOOM\nSet zoom level to ZOOM percent.\n.SH KEYBOARD COMMANDS\n.SS General\nThe following keyboard commands are available in both image and thumbnail mode:\n.TP\n.BR 0 \\- 9\nPrefix the next command with a number (denoted via\n.IR count ).\n.TP\n.B q\nQuit sxiv.\n.TP\n.B Return\nSwitch to thumbnail mode / open selected image in image mode.\n.TP\n.B f\nToggle fullscreen mode.\n.TP\n.B b\nToggle visibility of info bar on bottom of window.\n.TP\n.B Ctrl-x\nSend the next key to the external key-handler. See section EXTERNAL KEY HANDLER\nfor more information.\n.TP\n.B g\nGo to the first image.\n.TP\n.B G\nGo to the last image, or image number\n.IR count .\n.TP\n.B r\nReload image.\n.TP\n.B D\nRemove current image from file list and go to next image.\n.TP\n.BR Ctrl-h \", \" Ctrl-Left\nScroll left one screen width.\n.TP\n.BR Ctrl-j \", \" Ctrl-Down\nScroll down one screen height.\n.TP\n.BR Ctrl-k \", \" Ctrl-Up\nScroll up one screen height.\n.TP\n.BR Ctrl-l \", \" Ctrl-Right\nScroll right one screen width.\n.TP\n.BR +\nZoom in.\n.TP\n.B \\-\nZoom out.\n.TP\n.B m\nMark/unmark the current image.\n.TP\n.B M\nReverse all image marks.\n.TP\n.B Ctrl-M\nRepeat last mark action on all images from the last marked/unmarked up to the\ncurrent one.\n.TP\n.B Ctrl-m\nRemove all image marks.\n.TP\n.B N\nGo\n.I count\nmarked images forward.\n.TP\n.B P\nGo\n.I count\nmarked images backward.\n.TP\n.B {\nDecrease gamma correction by\n.I count\nsteps.\n.TP\n.B }\nIncrease gamma correction by\n.I count\nsteps.\n.TP\n.B Ctrl-g\nReset gamma correction.\n.SS Thumbnail mode\nThe following keyboard commands are only available in thumbnail mode:\n.TP\n.BR h \", \" Left\nMove selection left\n.I count\ntimes.\n.TP\n.BR j \", \" Down\nMove selection down\n.I count\ntimes.\n.TP\n.BR k \", \" Up\nMove selection up\n.I count\ntimes.\n.TP\n.BR l \", \" Right\nMove selection right\n.I count\ntimes.\n.TP\n.B R\nReload all thumbnails.\n.SS Image mode\nThe following keyboard commands are only available in image mode:\n.TP\nNavigate image list:\n.TP\n.BR n \", \" Space\nGo\n.I count\nimages forward.\n.TP\n.BR p \", \" Backspace\nGo\n.I count\nimages backward.\n.TP\n.B [\nGo\n.I count\n* 10 images backward.\n.TP\n.B ]\nGo\n.I count\n* 10 images forward.\n.TP\nHandle multi-frame images:\n.TP\n.B Ctrl-n\nGo\n.I count\nframes of a multi-frame image forward.\n.TP\n.B Ctrl-p\nGo\n.I count\nframes of a multi-frame image backward.\n.TP\n.B Ctrl-Space\nPlay/stop animations of multi-frame images.\n.TP\nPanning:\n.TP\n.BR h \", \" Left\nScroll image 1/5 of window width or\n.I count\npixel left.\n.TP\n.BR j \", \" Down\nScroll image 1/5 of window height or\n.I count\npixel down.\n.TP\n.BR k \", \" Up\nScroll image 1/5 of window height or\n.I count\npixel up.\n.TP\n.BR l \", \" Right\nScroll image 1/5 of window width or\n.I count\npixel right.\n.TP\n.B H\nScroll to left image edge.\n.TP\n.B J\nScroll to bottom image edge.\n.TP\n.B K\nScroll to top image edge.\n.TP\n.B L\nScroll to right image edge.\n.TP\nZooming:\n.TP\n.B =\nSet zoom level to 100%, or\n.IR count %.\n.TP\n.B w\nSet zoom level to 100%, but fit large images into window.\n.TP\n.B W\nFit image to window.\n.TP\n.B e\nFit image to window width.\n.TP\n.B E\nFit image to window height.\n.TP\nRotation:\n.TP\n.B <\nRotate image counter-clockwise by 90 degrees.\n.TP\n.B >\nRotate image clockwise by 90 degrees.\n.TP\n.B ?\nRotate image by 180 degrees.\n.TP\nFlipping:\n.TP\n.B |\nFlip image horizontally.\n.TP\n.B _\nFlip image vertically.\n.TP\nMiscellaneous:\n.TP\n.B a\nToggle anti-aliasing.\n.TP\n.B A\nToggle visibility of alpha-channel, i.e. image transparency.\n.TP\n.B s\nToggle slideshow mode and/or set the delay between images to\n.I count\nseconds.\n.SH MOUSE COMMANDS\nThe following mouse mappings are available in image mode:\n.TP\nGeneral:\n.TP\n.B Button3\nSwitch to thumbnail mode.\n.TP\nNavigate image list:\n.TP\n.B Button1\nGo to the next image if the mouse cursor is in the right part of the window or\nto the previous image if it is in the left part.\n.TP\nPanning:\n.TP\n.B Button2\nPan the image according to the mouse cursor position in the window while\nkeeping this button pressed down.\n.TP\nZooming:\n.TP\n.B ScrollUp\nZoom in.\n.TP\n.B ScrollDown\nZoom out.\n.SH CONFIGURATION\nThe following X resources are supported:\n.TP\n.B background\nColor of the window background and bar foreground\n.TP\n.B foreground\nColor of the window foreground and bar background\n.TP\n.B font\nName of Xft bar font\n.TP\nPlease see xrdb(1) on how to change them.\n.SH STATUS BAR\nThe information displayed on the left side of the status bar can be replaced\nwith the output of a user-provided script, which is called by sxiv whenever an\nimage gets loaded. The path of this script is\n.I $XDG_CONFIG_HOME/sxiv/exec/image-info\nand the arguments given to it are: 1) path to image file, 2) image width,\n3) image height.\n.P\nThere is also an example script installed together with sxiv as\n.IR PREFIX/share/sxiv/exec/image-info .\n.SH EXTERNAL KEY HANDLER\nAdditional external keyboard commands can be defined using a handler program\nlocated in\n.IR $XDG_CONFIG_HOME/sxiv/exec/key-handler .\nThe handler is invoked by pressing\n.BR Ctrl-x .\nThe next key combo is passed as its first argument. Passed via stdin are the\nimages to act upon, one path per line: all marked images, if in thumbnail mode\nand at least one image has been marked, otherwise the current image.\nsxiv(1) will block until the handler terminates. It then checks which images\nhave been modified and reloads them.\n\nThe key combo argument has the following form: \"[C-][M-][S-]KEY\",\nwhere C/M/S indicate Ctrl/Meta(Alt)/Shift modifier states and KEY is the X\nkeysym as listed in /usr/include/X11/keysymdef.h without the \"XK_\" prefix.\n\nThere is also an example script installed together with sxiv as\n.IR PREFIX/share/sxiv/exec/key-handler .\n.SH THUMBNAIL CACHING\nsxiv stores all thumbnails under\n.IR $XDG_CACHE_HOME/sxiv/ .\n.P\nUse the command line option\n.I \\-c\nto remove all orphaned cache files. Additionally, run the following command\nafterwards inside the cache directory to remove empty subdirectories:\n.P\n.RS\nfind . \\-depth \\-type d \\-empty ! \\-name '.' \\-exec rmdir {} \\\\;\n.RE\n.SH AUTHOR\n.EX\nBert Muennich   <xyb3rt at gmail.com>\n.EE\n.SH CONTRIBUTORS\n.EX\nBastien Dejean  <nihilhill at gmail.com>\nDave Reisner    <d at falconindy.com>\nFung SzeTat     <sthorde at gmail.com>\nMax Voit        <mvdev at with-eyes.net>\n.EE\n.SH HOMEPAGE\n.EX\nhttps://github.com/xyb3rt/sxiv\n.EE\n.SH SEE ALSO\n.BR X (7),\n.BR xrdb (1)\n"
        },
        {
          "name": "sxiv.desktop",
          "type": "blob",
          "size": 0.2841796875,
          "content": "[Desktop Entry]\nType=Application\nName=sxiv\nGenericName=Image Viewer\nExec=sxiv %F\nMimeType=image/bmp;image/gif;image/jpeg;image/jpg;image/png;image/tiff;image/x-bmp;image/x-portable-anymap;image/x-portable-bitmap;image/x-portable-graymap;image/x-tga;image/x-xpixmap;\nNoDisplay=true\nIcon=sxiv\n"
        },
        {
          "name": "sxiv.h",
          "type": "blob",
          "size": 7.5146484375,
          "content": "/* Copyright 2011 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef SXIV_H\n#define SXIV_H\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <Imlib2.h>\n#include <X11/Xlib.h>\n\n/*\n * Annotation for functions called in cleanup().\n * These functions are not allowed to call error(!0, ...) or exit().\n */\n#define CLEANUP\n\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif\n\n#define ARRLEN(a) (sizeof(a) / sizeof((a)[0]))\n\n#define STREQ(s1,s2) (strcmp((s1), (s2)) == 0)\n\n#define TV_DIFF(t1,t2) (((t1)->tv_sec  - (t2)->tv_sec ) * 1000 + \\\n                        ((t1)->tv_usec - (t2)->tv_usec) / 1000)\n\n#define TV_SET_MSEC(tv,t) {             \\\n  (tv)->tv_sec  = (t) / 1000;           \\\n  (tv)->tv_usec = (t) % 1000 * 1000;    \\\n}\n\n#define TV_ADD_MSEC(tv,t) {             \\\n  (tv)->tv_sec  += (t) / 1000;          \\\n  (tv)->tv_usec += (t) % 1000 * 1000;   \\\n}\n\ntypedef enum {\n\tBO_BIG_ENDIAN,\n\tBO_LITTLE_ENDIAN\n} byteorder_t;\n\ntypedef enum {\n\tMODE_IMAGE,\n\tMODE_THUMB\n} appmode_t;\n\ntypedef enum {\n\tDIR_LEFT  = 1,\n\tDIR_RIGHT = 2,\n\tDIR_UP    = 4,\n\tDIR_DOWN  = 8\n} direction_t;\n\ntypedef enum {\n\tDEGREE_90  = 1,\n\tDEGREE_180 = 2,\n\tDEGREE_270 = 3\n} degree_t;\n\ntypedef enum {\n\tFLIP_HORIZONTAL = 1,\n\tFLIP_VERTICAL   = 2\n} flipdir_t;\n\ntypedef enum {\n\tSCALE_DOWN,\n\tSCALE_FIT,\n\tSCALE_WIDTH,\n\tSCALE_HEIGHT,\n\tSCALE_ZOOM\n} scalemode_t;\n\ntypedef enum {\n\tDRAG_RELATIVE,\n\tDRAG_ABSOLUTE\n} dragmode_t;\n\ntypedef enum {\n\tCURSOR_ARROW,\n\tCURSOR_DRAG,\n\tCURSOR_WATCH,\n\tCURSOR_LEFT,\n\tCURSOR_RIGHT,\n\tCURSOR_NONE,\n\n\tCURSOR_COUNT\n} cursor_t;\n\ntypedef enum {\n\tFF_WARN    = 1,\n\tFF_MARK    = 2,\n\tFF_TN_INIT = 4\n} fileflags_t;\n\ntypedef struct {\n\tconst char *name; /* as given by user */\n\tconst char *path; /* always absolute */\n\tfileflags_t flags;\n} fileinfo_t;\n\n/* timeouts in milliseconds: */\nenum {\n\tTO_REDRAW_RESIZE = 75,\n\tTO_REDRAW_THUMBS = 200,\n\tTO_CURSOR_HIDE   = 1200,\n\tTO_DOUBLE_CLICK  = 300\n};\n\ntypedef void (*timeout_f)(void);\n\ntypedef struct arl arl_t;\ntypedef struct img img_t;\ntypedef struct opt opt_t;\ntypedef struct tns tns_t;\ntypedef struct win win_t;\n\n\n/* autoreload.c */\n\nstruct arl {\n\tint fd;\n\tint wd_dir;\n\tint wd_file;\n\tchar *filename;\n};\n\nvoid arl_init(arl_t*);\nvoid arl_cleanup(arl_t*);\nvoid arl_setup(arl_t*, const char* /* result of realpath(3) */);\nbool arl_handle(arl_t*);\n\n\n/* commands.c */\n\ntypedef int arg_t;\ntypedef bool (*cmd_f)(arg_t);\n\n#define G_CMD(c) g_##c,\n#define I_CMD(c) i_##c,\n#define T_CMD(c) t_##c,\n\ntypedef enum {\n#include \"commands.lst\"\n\tCMD_COUNT\n} cmd_id_t;\n\ntypedef struct {\n\tint mode;\n\tcmd_f func;\n} cmd_t;\n\ntypedef struct {\n\tunsigned int mask;\n\tKeySym ksym;\n\tcmd_id_t cmd;\n\targ_t arg;\n} keymap_t;\n\ntypedef struct {\n\tunsigned int mask;\n\tunsigned int button;\n\tcmd_id_t cmd;\n\targ_t arg;\n} button_t;\n\nextern const cmd_t cmds[CMD_COUNT];\n\n\n/* image.c */\n\ntypedef struct {\n\tImlib_Image im;\n\tunsigned int delay;\n} img_frame_t;\n\ntypedef struct {\n\timg_frame_t *frames;\n\tint cap;\n\tint cnt;\n\tint sel;\n\tbool animate;\n\tint framedelay;\n\tint length;\n} multi_img_t;\n\nstruct img {\n\tImlib_Image im;\n\tint w;\n\tint h;\n\n\twin_t *win;\n\tfloat x;\n\tfloat y;\n\n\tscalemode_t scalemode;\n\tfloat zoom;\n\n\tbool checkpan;\n\tbool dirty;\n\tbool aa;\n\tbool alpha;\n\n\tImlib_Color_Modifier cmod;\n\tint gamma;\n\n\tstruct {\n\t\tbool on;\n\t\tint delay;\n\t} ss;\n\n\tmulti_img_t multi;\n};\n\nvoid img_init(img_t*, win_t*);\nbool img_load(img_t*, const fileinfo_t*);\nCLEANUP void img_close(img_t*, bool);\nvoid img_render(img_t*);\nbool img_fit_win(img_t*, scalemode_t);\nbool img_zoom(img_t*, float);\nbool img_zoom_in(img_t*);\nbool img_zoom_out(img_t*);\nbool img_pos(img_t*, float, float);\nbool img_move(img_t*, float, float);\nbool img_pan(img_t*, direction_t, int);\nbool img_pan_edge(img_t*, direction_t);\nvoid img_rotate(img_t*, degree_t);\nvoid img_flip(img_t*, flipdir_t);\nvoid img_toggle_antialias(img_t*);\nbool img_change_gamma(img_t*, int);\nbool img_frame_navigate(img_t*, int);\nbool img_frame_animate(img_t*);\n\n\n/* options.c */\n\nstruct opt {\n\t/* file list: */\n\tchar **filenames;\n\tbool from_stdin;\n\tbool to_stdout;\n\tbool recursive;\n\tint filecnt;\n\tint startnum;\n\n\t/* image: */\n\tscalemode_t scalemode;\n\tfloat zoom;\n\tbool animate;\n\tint gamma;\n\tint slideshow;\n\tint framerate;\n\n\t/* window: */\n\tbool fullscreen;\n\tbool hide_bar;\n\tlong embed;\n\tchar *geometry;\n\tchar *res_name;\n\n\t/* misc flags: */\n\tbool quiet;\n\tbool thumb_mode;\n\tbool clean_cache;\n\tbool private_mode;\n};\n\nextern const opt_t *options;\n\nvoid print_usage(void);\nvoid print_version(void);\nvoid parse_options(int, char**);\n\n\n/* thumbs.c */\n\ntypedef struct {\n\tImlib_Image im;\n\tint w;\n\tint h;\n\tint x;\n\tint y;\n} thumb_t;\n\nstruct tns {\n\tfileinfo_t *files;\n\tthumb_t *thumbs;\n\tconst int *cnt;\n\tint *sel;\n\tint initnext;\n\tint loadnext;\n\tint first, end;\n\tint r_first, r_end;\n\n\twin_t *win;\n\tint x;\n\tint y;\n\tint cols;\n\tint rows;\n\tint zl;\n\tint bw;\n\tint dim;\n\n\tbool dirty;\n};\n\nvoid tns_clean_cache(tns_t*);\nvoid tns_init(tns_t*, fileinfo_t*, const int*, int*, win_t*);\nCLEANUP void tns_free(tns_t*);\nbool tns_load(tns_t*, int, bool, bool);\nvoid tns_unload(tns_t*, int);\nvoid tns_render(tns_t*);\nvoid tns_mark(tns_t*, int, bool);\nvoid tns_highlight(tns_t*, int, bool);\nbool tns_move_selection(tns_t*, direction_t, int);\nbool tns_scroll(tns_t*, direction_t, bool);\nbool tns_zoom(tns_t*, int);\nint tns_translate(tns_t*, int, int);\n\n\n/* util.c */\n\n#include <dirent.h>\n\ntypedef struct {\n\tDIR *dir;\n\tchar *name;\n\tint d;\n\tbool recursive;\n\n\tchar **stack;\n\tint stcap;\n\tint stlen;\n} r_dir_t;\n\nextern const char *progname;\n\nvoid* emalloc(size_t);\nvoid* erealloc(void*, size_t);\nchar* estrdup(const char*);\nvoid error(int, int, const char*, ...);\nvoid size_readable(float*, const char**);\nint r_opendir(r_dir_t*, const char*, bool);\nint r_closedir(r_dir_t*);\nchar* r_readdir(r_dir_t*, bool);\nint r_mkdir(char*);\n\n\n/* window.c */\n\n#include <X11/Xutil.h>\n#include <X11/Xft/Xft.h>\n\nenum {\n\tBAR_L_LEN = 512,\n\tBAR_R_LEN = 64\n};\n\nenum {\n\tATOM_WM_DELETE_WINDOW,\n\tATOM__NET_WM_NAME,\n\tATOM__NET_WM_ICON_NAME,\n\tATOM__NET_WM_ICON,\n\tATOM__NET_WM_STATE,\n\tATOM__NET_WM_STATE_FULLSCREEN,\n\tATOM_COUNT\n};\n\ntypedef struct {\n\tDisplay *dpy;\n\tint scr;\n\tint scrw, scrh;\n\tVisual *vis;\n\tColormap cmap;\n\tint depth;\n} win_env_t;\n\ntypedef struct {\n\tsize_t size;\n\tchar *p;\n\tchar *buf;\n} win_bar_t;\n\nstruct win {\n\tWindow xwin;\n\twin_env_t env;\n\n\tXftColor bg;\n\tXftColor fg;\n\n\tint x;\n\tint y;\n\tunsigned int w;\n\tunsigned int h; /* = win height - bar height */\n\tunsigned int bw;\n\n\tstruct {\n\t\tint w;\n\t\tint h;\n\t\tPixmap pm;\n\t} buf;\n\n\tstruct {\n\t\tunsigned int h;\n\t\twin_bar_t l;\n\t\twin_bar_t r;\n\t} bar;\n};\n\nextern Atom atoms[ATOM_COUNT];\n\nvoid win_init(win_t*);\nvoid win_open(win_t*);\nCLEANUP void win_close(win_t*);\nbool win_configure(win_t*, XConfigureEvent*);\nvoid win_toggle_fullscreen(win_t*);\nvoid win_toggle_bar(win_t*);\nvoid win_clear(win_t*);\nvoid win_draw(win_t*);\nvoid win_draw_rect(win_t*, int, int, int, int, bool, int, unsigned long);\nvoid win_set_title(win_t*, const char*);\nvoid win_set_cursor(win_t*, cursor_t);\nvoid win_cursor_pos(win_t*, int*, int*);\n\n#endif /* SXIV_H */\n\n"
        },
        {
          "name": "thumbs.c",
          "type": "blob",
          "size": 13.591796875,
          "content": "/* Copyright 2011 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _THUMBS_CONFIG\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <utime.h>\n\n#if HAVE_LIBEXIF\n#include <libexif/exif-data.h>\nvoid exif_auto_orientate(const fileinfo_t*);\n#endif\nImlib_Image img_open(const fileinfo_t*);\n\nstatic char *cache_dir;\n\nchar* tns_cache_filepath(const char *filepath)\n{\n\tsize_t len;\n\tchar *cfile = NULL;\n\n\tif (*filepath != '/')\n\t\treturn NULL;\n\t\n\tif (strncmp(filepath, cache_dir, strlen(cache_dir)) != 0) {\n\t\t/* don't cache images inside the cache directory! */\n\t\tlen = strlen(cache_dir) + strlen(filepath) + 2;\n\t\tcfile = (char*) emalloc(len);\n\t\tsnprintf(cfile, len, \"%s/%s\", cache_dir, filepath + 1);\n\t}\n\treturn cfile;\n}\n\nImlib_Image tns_cache_load(const char *filepath, bool *outdated)\n{\n\tchar *cfile;\n\tstruct stat cstats, fstats;\n\tImlib_Image im = NULL;\n\n\tif (stat(filepath, &fstats) < 0)\n\t\treturn NULL;\n\n\tif ((cfile = tns_cache_filepath(filepath)) != NULL) {\n\t\tif (stat(cfile, &cstats) == 0) {\n\t\t\tif (cstats.st_mtime == fstats.st_mtime)\n\t\t\t\tim = imlib_load_image(cfile);\n\t\t\telse\n\t\t\t\t*outdated = true;\n\t\t}\n\t\tfree(cfile);\n\t}\n\treturn im;\n}\n\nvoid tns_cache_write(Imlib_Image im, const char *filepath, bool force)\n{\n\tchar *cfile, *dirend;\n\tstruct stat cstats, fstats;\n\tstruct utimbuf times;\n\tImlib_Load_Error err;\n\n\tif (options->private_mode)\n\t\treturn;\n\n\tif (stat(filepath, &fstats) < 0)\n\t\treturn;\n\n\tif ((cfile = tns_cache_filepath(filepath)) != NULL) {\n\t\tif (force || stat(cfile, &cstats) < 0 ||\n\t\t    cstats.st_mtime != fstats.st_mtime)\n\t\t{\n\t\t\tif ((dirend = strrchr(cfile, '/')) != NULL) {\n\t\t\t\t*dirend = '\\0';\n\t\t\t\tif (r_mkdir(cfile) == -1) {\n\t\t\t\t\terror(0, errno, \"%s\", cfile);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t*dirend = '/';\n\t\t\t}\n\t\t\timlib_context_set_image(im);\n\t\t\tif (imlib_image_has_alpha()) {\n\t\t\t\timlib_image_set_format(\"png\");\n\t\t\t} else {\n\t\t\t\timlib_image_set_format(\"jpg\");\n\t\t\t\timlib_image_attach_data_value(\"quality\", NULL, 90, NULL);\n\t\t\t}\n\t\t\timlib_save_image_with_error_return(cfile, &err);\n\t\t\tif (err)\n\t\t\t\tgoto end;\n\t\t\ttimes.actime = fstats.st_atime;\n\t\t\ttimes.modtime = fstats.st_mtime;\n\t\t\tutime(cfile, &times);\n\t\t}\nend:\n\t\tfree(cfile);\n\t}\n}\n\nvoid tns_clean_cache(tns_t *tns)\n{\n\tint dirlen;\n\tchar *cfile, *filename;\n\tr_dir_t dir;\n\n\tif (r_opendir(&dir, cache_dir, true) < 0) {\n\t\terror(0, errno, \"%s\", cache_dir);\n\t\treturn;\n\t}\n\n\tdirlen = strlen(cache_dir);\n\n\twhile ((cfile = r_readdir(&dir, false)) != NULL) {\n\t\tfilename = cfile + dirlen;\n\t\tif (access(filename, F_OK) < 0) {\n\t\t\tif (unlink(cfile) < 0)\n\t\t\t\terror(0, errno, \"%s\", cfile);\n\t\t}\n\t\tfree(cfile);\n\t}\n\tr_closedir(&dir);\n}\n\n\nvoid tns_init(tns_t *tns, fileinfo_t *files, const int *cnt, int *sel,\n              win_t *win)\n{\n\tint len;\n\tconst char *homedir, *dsuffix = \"\";\n\n\tif (cnt != NULL && *cnt > 0) {\n\t\ttns->thumbs = (thumb_t*) emalloc(*cnt * sizeof(thumb_t));\n\t\tmemset(tns->thumbs, 0, *cnt * sizeof(thumb_t));\n\t} else {\n\t\ttns->thumbs = NULL;\n\t}\n\ttns->files = files;\n\ttns->cnt = cnt;\n\ttns->initnext = tns->loadnext = 0;\n\ttns->first = tns->end = tns->r_first = tns->r_end = 0;\n\ttns->sel = sel;\n\ttns->win = win;\n\ttns->dirty = false;\n\n\ttns->zl = THUMB_SIZE;\n\ttns_zoom(tns, 0);\n\n\tif ((homedir = getenv(\"XDG_CACHE_HOME\")) == NULL || homedir[0] == '\\0') {\n\t\thomedir = getenv(\"HOME\");\n\t\tdsuffix = \"/.cache\";\n\t}\n\tif (homedir != NULL) {\n\t\tfree(cache_dir);\n\t\tlen = strlen(homedir) + strlen(dsuffix) + 6;\n\t\tcache_dir = (char*) emalloc(len);\n\t\tsnprintf(cache_dir, len, \"%s%s/sxiv\", homedir, dsuffix);\n\t} else {\n\t\terror(0, 0, \"Cache directory not found\");\n\t}\n}\n\nCLEANUP void tns_free(tns_t *tns)\n{\n\tint i;\n\n\tif (tns->thumbs != NULL) {\n\t\tfor (i = 0; i < *tns->cnt; i++) {\n\t\t\tif (tns->thumbs[i].im != NULL) {\n\t\t\t\timlib_context_set_image(tns->thumbs[i].im);\n\t\t\t\timlib_free_image();\n\t\t\t}\n\t\t}\n\t\tfree(tns->thumbs);\n\t\ttns->thumbs = NULL;\n\t}\n\n\tfree(cache_dir);\n\tcache_dir = NULL;\n}\n\nImlib_Image tns_scale_down(Imlib_Image im, int dim)\n{\n\tint w, h;\n\tfloat z, zw, zh;\n\n\timlib_context_set_image(im);\n\tw = imlib_image_get_width();\n\th = imlib_image_get_height();\n\tzw = (float) dim / (float) w;\n\tzh = (float) dim / (float) h;\n\tz = MIN(zw, zh);\n\tz = MIN(z, 1.0);\n\n\tif (z < 1.0) {\n\t\timlib_context_set_anti_alias(1);\n\t\tim = imlib_create_cropped_scaled_image(0, 0, w, h,\n\t\t                                       MAX(z * w, 1), MAX(z * h, 1));\n\t\tif (im == NULL)\n\t\t\terror(EXIT_FAILURE, ENOMEM, NULL);\n\t\timlib_free_image_and_decache();\n\t}\n\treturn im;\n}\n\nbool tns_load(tns_t *tns, int n, bool force, bool cache_only)\n{\n\tint maxwh = thumb_sizes[ARRLEN(thumb_sizes)-1];\n\tbool cache_hit = false;\n\tchar *cfile;\n\tthumb_t *t;\n\tfileinfo_t *file;\n\tImlib_Image im = NULL;\n\n\tif (n < 0 || n >= *tns->cnt)\n\t\treturn false;\n\tfile = &tns->files[n];\n\tif (file->name == NULL || file->path == NULL)\n\t\treturn false;\n\n\tt = &tns->thumbs[n];\n\n\tif (t->im != NULL) {\n\t\timlib_context_set_image(t->im);\n\t\timlib_free_image();\n\t\tt->im = NULL;\n\t}\n\n\tif (!force) {\n\t\tif ((im = tns_cache_load(file->path, &force)) != NULL) {\n\t\t\timlib_context_set_image(im);\n\t\t\tif (imlib_image_get_width() < maxwh &&\n\t\t\t    imlib_image_get_height() < maxwh)\n\t\t\t{\n\t\t\t\tif ((cfile = tns_cache_filepath(file->path)) != NULL) {\n\t\t\t\t\tunlink(cfile);\n\t\t\t\t\tfree(cfile);\n\t\t\t\t}\n\t\t\t\timlib_free_image_and_decache();\n\t\t\t\tim = NULL;\n\t\t\t} else {\n\t\t\t\tcache_hit = true;\n\t\t\t}\n#if HAVE_LIBEXIF\n\t\t} else if (!force && !options->private_mode) {\n\t\t\tint pw = 0, ph = 0, w, h, x = 0, y = 0;\n\t\t\tbool err;\n\t\t\tfloat zw, zh;\n\t\t\tExifData *ed;\n\t\t\tExifEntry *entry;\n\t\t\tExifContent *ifd;\n\t\t\tExifByteOrder byte_order;\n\t\t\tint tmpfd;\n\t\t\tchar tmppath[] = \"/tmp/sxiv-XXXXXX\";\n\t\t\tImlib_Image tmpim;\n\n\t\t\tif ((ed = exif_data_new_from_file(file->path)) != NULL) {\n\t\t\t\tif (ed->data != NULL && ed->size > 0 &&\n\t\t\t\t    (tmpfd = mkstemp(tmppath)) >= 0)\n\t\t\t\t{\n\t\t\t\t\terr = write(tmpfd, ed->data, ed->size) != ed->size;\n\t\t\t\t\tclose(tmpfd);\n\n\t\t\t\t\tif (!err && (tmpim = imlib_load_image(tmppath)) != NULL) {\n\t\t\t\t\t\tbyte_order = exif_data_get_byte_order(ed);\n\t\t\t\t\t\tifd = ed->ifd[EXIF_IFD_EXIF];\n\t\t\t\t\t\tentry = exif_content_get_entry(ifd, EXIF_TAG_PIXEL_X_DIMENSION);\n\t\t\t\t\t\tif (entry != NULL)\n\t\t\t\t\t\t\tpw = exif_get_long(entry->data, byte_order);\n\t\t\t\t\t\tentry = exif_content_get_entry(ifd, EXIF_TAG_PIXEL_Y_DIMENSION);\n\t\t\t\t\t\tif (entry != NULL)\n\t\t\t\t\t\t\tph = exif_get_long(entry->data, byte_order);\n\n\t\t\t\t\t\timlib_context_set_image(tmpim);\n\t\t\t\t\t\tw = imlib_image_get_width();\n\t\t\t\t\t\th = imlib_image_get_height();\n\n\t\t\t\t\t\tif (pw > w && ph > h && (pw - ph >= 0) == (w - h >= 0)) {\n\t\t\t\t\t\t\tzw = (float) pw / (float) w;\n\t\t\t\t\t\t\tzh = (float) ph / (float) h;\n\t\t\t\t\t\t\tif (zw < zh) {\n\t\t\t\t\t\t\t\tpw /= zh;\n\t\t\t\t\t\t\t\tx = (w - pw) / 2;\n\t\t\t\t\t\t\t\tw = pw;\n\t\t\t\t\t\t\t} else if (zw > zh) {\n\t\t\t\t\t\t\t\tph /= zw;\n\t\t\t\t\t\t\t\ty = (h - ph) / 2;\n\t\t\t\t\t\t\t\th = ph;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w >= maxwh || h >= maxwh) {\n\t\t\t\t\t\t\tif ((im = imlib_create_cropped_image(x, y, w, h)) == NULL)\n\t\t\t\t\t\t\t\terror(EXIT_FAILURE, ENOMEM, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\timlib_free_image_and_decache();\n\t\t\t\t\t}\n\t\t\t\t\tunlink(tmppath);\n\t\t\t\t}\n\t\t\t\texif_data_unref(ed);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (im == NULL) {\n\t\tif ((im = img_open(file)) == NULL)\n\t\t\treturn false;\n\t}\n\timlib_context_set_image(im);\n\n\tif (!cache_hit) {\n#if HAVE_LIBEXIF\n\t\texif_auto_orientate(file);\n#endif\n\t\tim = tns_scale_down(im, maxwh);\n\t\timlib_context_set_image(im);\n\t\tif (imlib_image_get_width() == maxwh || imlib_image_get_height() == maxwh)\n\t\t\ttns_cache_write(im, file->path, true);\n\t}\n\n\tif (cache_only) {\n\t\timlib_free_image_and_decache();\n\t} else {\n\t\tt->im = tns_scale_down(im, thumb_sizes[tns->zl]);\n\t\timlib_context_set_image(t->im);\n\t\tt->w = imlib_image_get_width();\n\t\tt->h = imlib_image_get_height();\n\t\ttns->dirty = true;\n\t}\n\tfile->flags |= FF_TN_INIT;\n\n\tif (n == tns->initnext)\n\t\twhile (++tns->initnext < *tns->cnt && ((++file)->flags & FF_TN_INIT));\n\tif (n == tns->loadnext && !cache_only)\n\t\twhile (++tns->loadnext < tns->end && (++t)->im != NULL);\n\n\treturn true;\n}\n\nvoid tns_unload(tns_t *tns, int n)\n{\n\tthumb_t *t;\n\n\tif (n < 0 || n >= *tns->cnt)\n\t\treturn;\n\n\tt = &tns->thumbs[n];\n\n\tif (t->im != NULL) {\n\t\timlib_context_set_image(t->im);\n\t\timlib_free_image();\n\t\tt->im = NULL;\n\t}\n}\n\nvoid tns_check_view(tns_t *tns, bool scrolled)\n{\n\tint r;\n\n\tif (tns == NULL)\n\t\treturn;\n\n\ttns->first -= tns->first % tns->cols;\n\tr = *tns->sel % tns->cols;\n\n\tif (scrolled) {\n\t\t/* move selection into visible area */\n\t\tif (*tns->sel >= tns->first + tns->cols * tns->rows)\n\t\t\t*tns->sel = tns->first + r + tns->cols * (tns->rows - 1);\n\t\telse if (*tns->sel < tns->first)\n\t\t\t*tns->sel = tns->first + r;\n\t} else {\n\t\t/* scroll to selection */\n\t\tif (tns->first + tns->cols * tns->rows <= *tns->sel) {\n\t\t\ttns->first = *tns->sel - r - tns->cols * (tns->rows - 1);\n\t\t\ttns->dirty = true;\n\t\t} else if (tns->first > *tns->sel) {\n\t\t\ttns->first = *tns->sel - r;\n\t\t\ttns->dirty = true;\n\t\t}\n\t}\n}\n\nvoid tns_render(tns_t *tns)\n{\n\tthumb_t *t;\n\twin_t *win;\n\tint i, cnt, r, x, y;\n\n\tif (!tns->dirty)\n\t\treturn;\n\n\twin = tns->win;\n\twin_clear(win);\n\timlib_context_set_drawable(win->buf.pm);\n\n\ttns->cols = MAX(1, win->w / tns->dim);\n\ttns->rows = MAX(1, win->h / tns->dim);\n\n\tif (*tns->cnt < tns->cols * tns->rows) {\n\t\ttns->first = 0;\n\t\tcnt = *tns->cnt;\n\t} else {\n\t\ttns_check_view(tns, false);\n\t\tcnt = tns->cols * tns->rows;\n\t\tif ((r = tns->first + cnt - *tns->cnt) >= tns->cols)\n\t\t\ttns->first -= r - r % tns->cols;\n\t\tif (r > 0)\n\t\t\tcnt -= r % tns->cols;\n\t}\n\tr = cnt % tns->cols ? 1 : 0;\n\ttns->x = x = (win->w - MIN(cnt, tns->cols) * tns->dim) / 2 + tns->bw + 3;\n\ttns->y = y = (win->h - (cnt / tns->cols + r) * tns->dim) / 2 + tns->bw + 3;\n\ttns->loadnext = *tns->cnt;\n\ttns->end = tns->first + cnt;\n\n\tfor (i = tns->r_first; i < tns->r_end; i++) {\n\t\tif ((i < tns->first || i >= tns->end) && tns->thumbs[i].im != NULL)\n\t\t\ttns_unload(tns, i);\n\t}\n\ttns->r_first = tns->first;\n\ttns->r_end = tns->end;\n\n\tfor (i = tns->first; i < tns->end; i++) {\n\t\tt = &tns->thumbs[i];\n\t\tif (t->im != NULL) {\n\t\t\tt->x = x + (thumb_sizes[tns->zl] - t->w) / 2;\n\t\t\tt->y = y + (thumb_sizes[tns->zl] - t->h) / 2;\n\t\t\timlib_context_set_image(t->im);\n\t\t\timlib_render_image_on_drawable_at_size(t->x, t->y, t->w, t->h);\n\t\t\tif (tns->files[i].flags & FF_MARK)\n\t\t\t\ttns_mark(tns, i, true);\n\t\t} else {\n\t\t\ttns->loadnext = MIN(tns->loadnext, i);\n\t\t}\n\t\tif ((i + 1) % tns->cols == 0) {\n\t\t\tx = tns->x;\n\t\t\ty += tns->dim;\n\t\t} else {\n\t\t\tx += tns->dim;\n\t\t}\n\t}\n\ttns->dirty = false;\n\ttns_highlight(tns, *tns->sel, true);\n}\n\nvoid tns_mark(tns_t *tns, int n, bool mark)\n{\n\tif (n >= 0 && n < *tns->cnt && tns->thumbs[n].im != NULL) {\n\t\twin_t *win = tns->win;\n\t\tthumb_t *t = &tns->thumbs[n];\n\t\tunsigned long col = win->bg.pixel;\n\t\tint x = t->x + t->w, y = t->y + t->h;\n\n\t\twin_draw_rect(win, x - 1, y + 1, 1, tns->bw, true, 1, col);\n\t\twin_draw_rect(win, x + 1, y - 1, tns->bw, 1, true, 1, col);\n\n\t\tif (mark)\n\t\t\tcol = win->fg.pixel;\n\n\t\twin_draw_rect(win, x, y, tns->bw + 2, tns->bw + 2, true, 1, col);\n\n\t\tif (!mark && n == *tns->sel)\n\t\t\ttns_highlight(tns, n, true);\n\t}\n}\n\nvoid tns_highlight(tns_t *tns, int n, bool hl)\n{\n\tif (n >= 0 && n < *tns->cnt && tns->thumbs[n].im != NULL) {\n\t\twin_t *win = tns->win;\n\t\tthumb_t *t = &tns->thumbs[n];\n\t\tunsigned long col = hl ? win->fg.pixel : win->bg.pixel;\n\t\tint oxy = (tns->bw + 1) / 2 + 1, owh = tns->bw + 2;\n\n\t\twin_draw_rect(win, t->x - oxy, t->y - oxy, t->w + owh, t->h + owh,\n\t\t              false, tns->bw, col);\n\n\t\tif (tns->files[n].flags & FF_MARK)\n\t\t\ttns_mark(tns, n, true);\n\t}\n}\n\nbool tns_move_selection(tns_t *tns, direction_t dir, int cnt)\n{\n\tint old, max;\n\n\told = *tns->sel;\n\tcnt = cnt > 1 ? cnt : 1;\n\n\tswitch (dir) {\n\t\tcase DIR_UP:\n\t\t\t*tns->sel = MAX(*tns->sel - cnt * tns->cols, *tns->sel % tns->cols);\n\t\t\tbreak;\n\t\tcase DIR_DOWN:\n\t\t\tmax = tns->cols * ((*tns->cnt - 1) / tns->cols) +\n\t\t\t      MIN((*tns->cnt - 1) % tns->cols, *tns->sel % tns->cols);\n\t\t\t*tns->sel = MIN(*tns->sel + cnt * tns->cols, max);\n\t\t\tbreak;\n\t\tcase DIR_LEFT:\n\t\t\t*tns->sel = MAX(*tns->sel - cnt, 0);\n\t\t\tbreak;\n\t\tcase DIR_RIGHT:\n\t\t\t*tns->sel = MIN(*tns->sel + cnt, *tns->cnt - 1);\n\t\t\tbreak;\n\t}\n\n\tif (*tns->sel != old) {\n\t\ttns_highlight(tns, old, false);\n\t\ttns_check_view(tns, false);\n\t\tif (!tns->dirty)\n\t\t\ttns_highlight(tns, *tns->sel, true);\n\t}\n\treturn *tns->sel != old;\n}\n\nbool tns_scroll(tns_t *tns, direction_t dir, bool screen)\n{\n\tint d, max, old;\n\n\told = tns->first;\n\td = tns->cols * (screen ? tns->rows : 1);\n\n\tif (dir == DIR_DOWN) {\n\t\tmax = *tns->cnt - tns->cols * tns->rows;\n\t\tif (*tns->cnt % tns->cols != 0)\n\t\t\tmax += tns->cols - *tns->cnt % tns->cols;\n\t\ttns->first = MIN(tns->first + d, max);\n\t} else if (dir == DIR_UP) {\n\t\ttns->first = MAX(tns->first - d, 0);\n\t}\n\n\tif (tns->first != old) {\n\t\ttns_check_view(tns, true);\n\t\ttns->dirty = true;\n\t}\n\treturn tns->first != old;\n}\n\nbool tns_zoom(tns_t *tns, int d)\n{\n\tint i, oldzl;\n\n\toldzl = tns->zl;\n\ttns->zl += -(d < 0) + (d > 0);\n\ttns->zl = MAX(tns->zl, 0);\n\ttns->zl = MIN(tns->zl, ARRLEN(thumb_sizes)-1);\n\n\ttns->bw = ((thumb_sizes[tns->zl] - 1) >> 5) + 1;\n\ttns->bw = MIN(tns->bw, 4);\n\ttns->dim = thumb_sizes[tns->zl] + 2 * tns->bw + 6;\n\n\tif (tns->zl != oldzl) {\n\t\tfor (i = 0; i < *tns->cnt; i++)\n\t\t\ttns_unload(tns, i);\n\t\ttns->dirty = true;\n\t}\n\treturn tns->zl != oldzl;\n}\n\nint tns_translate(tns_t *tns, int x, int y)\n{\n\tint n;\n\n\tif (x < tns->x || y < tns->y)\n\t\treturn -1;\n\n\tn = tns->first + (y - tns->y) / tns->dim * tns->cols +\n\t    (x - tns->x) / tns->dim;\n\tif (n >= *tns->cnt)\n\t\tn = -1;\n\n\treturn n;\n}\n"
        },
        {
          "name": "utf8.h",
          "type": "blob",
          "size": 2.28125,
          "content": "/* Branchless UTF-8 decoder\n *\n * This is free and unencumbered software released into the public domain.\n */\n#ifndef UTF8_H\n#define UTF8_H\n\n#include <stdint.h>\n\n/* Decode the next character, C, from BUF, reporting errors in E.\n *\n * Since this is a branchless decoder, four bytes will be read from the\n * buffer regardless of the actual length of the next character. This\n * means the buffer _must_ have at least three bytes of zero padding\n * following the end of the data stream.\n *\n * Errors are reported in E, which will be non-zero if the parsed\n * character was somehow invalid: invalid byte sequence, non-canonical\n * encoding, or a surrogate half.\n *\n * The function returns a pointer to the next character. When an error\n * occurs, this pointer will be a guess that depends on the particular\n * error, but it will always advance at least one byte.\n */\nstatic void *\nutf8_decode(void *buf, uint32_t *c, int *e)\n{\n    static const char lengths[] = {\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0\n    };\n    static const int masks[]  = {0x00, 0x7f, 0x1f, 0x0f, 0x07};\n    static const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};\n    static const int shiftc[] = {0, 18, 12, 6, 0};\n    static const int shifte[] = {0, 6, 4, 2, 0};\n\n    unsigned char *s = buf;\n    int len = lengths[s[0] >> 3];\n\n    /* Compute the pointer to the next character early so that the next\n     * iteration can start working on the next character. Neither Clang\n     * nor GCC figure out this reordering on their own.\n     */\n    unsigned char *next = s + len + !len;\n\n    /* Assume a four-byte character and load four bytes. Unused bits are\n     * shifted out.\n     */\n    *c  = (uint32_t)(s[0] & masks[len]) << 18;\n    *c |= (uint32_t)(s[1] & 0x3f) << 12;\n    *c |= (uint32_t)(s[2] & 0x3f) <<  6;\n    *c |= (uint32_t)(s[3] & 0x3f) <<  0;\n    *c >>= shiftc[len];\n\n    /* Accumulate the various error conditions. */\n    *e  = (*c < mins[len]) << 6; // non-canonical encoding\n    *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?\n    *e |= (*c > 0x10FFFF) << 8;  // out of range?\n    *e |= (s[1] & 0xc0) >> 2;\n    *e |= (s[2] & 0xc0) >> 4;\n    *e |= (s[3]       ) >> 6;\n    *e ^= 0x2a; // top two bits of each tail byte correct?\n    *e >>= shifte[len];\n\n    return next;\n}\n\n#endif\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 4.3271484375,
          "content": "/* Copyright 2011 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <errno.h>\n\nconst char *progname;\n\nvoid* emalloc(size_t size)\n{\n\tvoid *ptr;\n\t\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\terror(EXIT_FAILURE, errno, NULL);\n\treturn ptr;\n}\n\nvoid* erealloc(void *ptr, size_t size)\n{\n\tptr = realloc(ptr, size);\n\tif (ptr == NULL)\n\t\terror(EXIT_FAILURE, errno, NULL);\n\treturn ptr;\n}\n\nchar* estrdup(const char *s)\n{\n\tchar *d;\n\tsize_t n = strlen(s) + 1;\n\n\td = malloc(n);\n\tif (d == NULL)\n\t\terror(EXIT_FAILURE, errno, NULL);\n\tmemcpy(d, s, n);\n\treturn d;\n}\n\nvoid error(int eval, int err, const char* fmt, ...)\n{\n\tva_list ap;\n\n\tif (eval == 0 && options->quiet)\n\t\treturn;\n\n\tfflush(stdout);\n\tfprintf(stderr, \"%s: \", progname);\n\tva_start(ap, fmt);\n\tif (fmt != NULL)\n\t\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (err != 0)\n\t\tfprintf(stderr, \"%s%s\", fmt != NULL ? \": \" : \"\", strerror(err));\n\tfputc('\\n', stderr);\n\n\tif (eval != 0)\n\t\texit(eval);\n}\n\nvoid size_readable(float *size, const char **unit)\n{\n\tconst char *units[] = { \"\", \"K\", \"M\", \"G\" };\n\tint i;\n\n\tfor (i = 0; i < ARRLEN(units) && *size > 1024.0; i++)\n\t\t*size /= 1024.0;\n\t*unit = units[MIN(i, ARRLEN(units) - 1)];\n}\n\nint r_opendir(r_dir_t *rdir, const char *dirname, bool recursive)\n{\n\tif (*dirname == '\\0')\n\t\treturn -1;\n\n\tif ((rdir->dir = opendir(dirname)) == NULL) {\n\t\trdir->name = NULL;\n\t\trdir->stack = NULL;\n\t\treturn -1;\n\t}\n\n\trdir->stcap = 512;\n\trdir->stack = (char**) emalloc(rdir->stcap * sizeof(char*));\n\trdir->stlen = 0;\n\n\trdir->name = (char*) dirname;\n\trdir->d = 0;\n\trdir->recursive = recursive;\n\n\treturn 0;\n}\n\nint r_closedir(r_dir_t *rdir)\n{\n\tint ret = 0;\n\n\tif (rdir->stack != NULL) {\n\t\twhile (rdir->stlen > 0)\n\t\t\tfree(rdir->stack[--rdir->stlen]);\n\t\tfree(rdir->stack);\n\t\trdir->stack = NULL;\n\t}\n\n\tif (rdir->dir != NULL) {\n\t\tif ((ret = closedir(rdir->dir)) == 0)\n\t\t\trdir->dir = NULL;\n\t}\n\n\tif (rdir->d != 0) {\n\t\tfree(rdir->name);\n\t\trdir->name = NULL;\n\t}\n\n\treturn ret;\n}\n\nchar* r_readdir(r_dir_t *rdir, bool skip_dotfiles)\n{\n\tsize_t len;\n\tchar *filename;\n\tstruct dirent *dentry;\n\tstruct stat fstats;\n\n\twhile (true) {\n\t\tif (rdir->dir != NULL && (dentry = readdir(rdir->dir)) != NULL) {\n\t\t\tif (dentry->d_name[0] == '.') {\n\t\t\t\tif (skip_dotfiles)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dentry->d_name[1] == '\\0')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dentry->d_name[1] == '.' && dentry->d_name[2] == '\\0')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlen = strlen(rdir->name) + strlen(dentry->d_name) + 2;\n\t\t\tfilename = (char*) emalloc(len);\n\t\t\tsnprintf(filename, len, \"%s%s%s\", rdir->name,\n\t\t\t         rdir->name[strlen(rdir->name)-1] == '/' ? \"\" : \"/\",\n\t\t\t         dentry->d_name);\n\n\t\t\tif (stat(filename, &fstats) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (S_ISDIR(fstats.st_mode)) {\n\t\t\t\t/* put subdirectory on the stack */\n\t\t\t\tif (rdir->stlen == rdir->stcap) {\n\t\t\t\t\trdir->stcap *= 2;\n\t\t\t\t\trdir->stack = (char**) erealloc(rdir->stack,\n\t\t\t\t\t                                rdir->stcap * sizeof(char*));\n\t\t\t\t}\n\t\t\t\trdir->stack[rdir->stlen++] = filename;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn filename;\n\t\t}\n\t\t\n\t\tif (rdir->recursive && rdir->stlen > 0) {\n\t\t\t/* open next subdirectory */\n\t\t\tclosedir(rdir->dir);\n\t\t\tif (rdir->d != 0)\n\t\t\t\tfree(rdir->name);\n\t\t\trdir->name = rdir->stack[--rdir->stlen];\n\t\t\trdir->d = 1;\n\t\t\tif ((rdir->dir = opendir(rdir->name)) == NULL)\n\t\t\t\terror(0, errno, \"%s\", rdir->name);\n\t\t\tcontinue;\n\t\t}\n\t\t/* no more entries */\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nint r_mkdir(char *path)\n{\n\tchar c, *s = path;\n\tstruct stat st;\n\n\twhile (*s != '\\0') {\n\t\tif (*s == '/') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (; *s != '\\0' && *s != '/'; s++);\n\t\tc = *s;\n\t\t*s = '\\0';\n\t\tif (mkdir(path, 0755) == -1)\n\t\t\tif (errno != EEXIST || stat(path, &st) == -1 || !S_ISDIR(st.st_mode))\n\t\t\t\treturn -1;\n\t\t*s = c;\n\t}\n\treturn 0;\n}\n\n"
        },
        {
          "name": "window.c",
          "type": "blob",
          "size": 12.380859375,
          "content": "/* Copyright 2011-2013 Bert Muennich\n *\n * This file is part of sxiv.\n *\n * sxiv is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published\n * by the Free Software Foundation; either version 2 of the License,\n * or (at your option) any later version.\n *\n * sxiv is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with sxiv.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"sxiv.h\"\n#define _WINDOW_CONFIG\n#include \"config.h\"\n#include \"icon/data.h\"\n#include \"utf8.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n#include <X11/cursorfont.h>\n#include <X11/Xatom.h>\n#include <X11/Xresource.h>\n\n#define RES_CLASS \"Sxiv\"\n\nenum {\n\tH_TEXT_PAD = 5,\n\tV_TEXT_PAD = 1\n};\n\nstatic struct {\n\tint name;\n\tCursor icon;\n} cursors[CURSOR_COUNT] = {\n\t{ XC_left_ptr }, { XC_dotbox }, { XC_watch },\n\t{ XC_sb_left_arrow }, { XC_sb_right_arrow }\n};\n\nstatic GC gc;\n\nstatic XftFont *font;\nstatic int fontheight;\nstatic double fontsize;\nstatic int barheight;\n\nAtom atoms[ATOM_COUNT];\n\nvoid win_init_font(const win_env_t *e, const char *fontstr)\n{\n\tif ((font = XftFontOpenName(e->dpy, e->scr, fontstr)) == NULL)\n\t\terror(EXIT_FAILURE, 0, \"Error loading font '%s'\", fontstr);\n\tfontheight = font->ascent + font->descent;\n\tFcPatternGetDouble(font->pattern, FC_SIZE, 0, &fontsize);\n\tbarheight = fontheight + 2 * V_TEXT_PAD;\n}\n\nvoid win_alloc_color(const win_env_t *e, const char *name, XftColor *col)\n{\n\tif (!XftColorAllocName(e->dpy, DefaultVisual(e->dpy, e->scr),\n\t                       DefaultColormap(e->dpy, e->scr), name, col))\n\t{\n\t\terror(EXIT_FAILURE, 0, \"Error allocating color '%s'\", name);\n\t}\n}\n\nconst char* win_res(XrmDatabase db, const char *name, const char *def)\n{\n\tchar *type;\n\tXrmValue ret;\n\n\tif (db != None &&\n\t    XrmGetResource(db, name, name, &type, &ret) &&\n\t    STREQ(type, \"String\"))\n\t{\n\t\treturn ret.addr;\n\t} else {\n\t\treturn def;\n\t}\n}\n\n#define INIT_ATOM_(atom) \\\n\tatoms[ATOM_##atom] = XInternAtom(e->dpy, #atom, False);\n\nvoid win_init(win_t *win)\n{\n\twin_env_t *e;\n\tconst char *bg, *fg, *f;\n\tchar *res_man;\n\tXrmDatabase db;\n\n\tmemset(win, 0, sizeof(win_t));\n\n\te = &win->env;\n\tif ((e->dpy = XOpenDisplay(NULL)) == NULL)\n\t\terror(EXIT_FAILURE, 0, \"Error opening X display\");\n\n\te->scr = DefaultScreen(e->dpy);\n\te->scrw = DisplayWidth(e->dpy, e->scr);\n\te->scrh = DisplayHeight(e->dpy, e->scr);\n\te->vis = DefaultVisual(e->dpy, e->scr);\n\te->cmap = DefaultColormap(e->dpy, e->scr);\n\te->depth = DefaultDepth(e->dpy, e->scr);\n\n\tif (setlocale(LC_CTYPE, \"\") == NULL || XSupportsLocale() == 0)\n\t\terror(0, 0, \"No locale support\");\n\n\tXrmInitialize();\n\tres_man = XResourceManagerString(e->dpy);\n\tdb = res_man != NULL ? XrmGetStringDatabase(res_man) : None;\n\n\tf = win_res(db, RES_CLASS \".font\", \"monospace-8\");\n\twin_init_font(e, f);\n\n\tbg = win_res(db, RES_CLASS \".background\", \"white\");\n\tfg = win_res(db, RES_CLASS \".foreground\", \"black\");\n\twin_alloc_color(e, bg, &win->bg);\n\twin_alloc_color(e, fg, &win->fg);\n\n\twin->bar.l.size = BAR_L_LEN;\n\twin->bar.r.size = BAR_R_LEN;\n\t/* 3 padding bytes needed by utf8_decode */\n\twin->bar.l.buf = emalloc(win->bar.l.size + 3);\n\twin->bar.l.buf[0] = '\\0';\n\twin->bar.r.buf = emalloc(win->bar.r.size + 3);\n\twin->bar.r.buf[0] = '\\0';\n\twin->bar.h = options->hide_bar ? 0 : barheight;\n\n\tINIT_ATOM_(WM_DELETE_WINDOW);\n\tINIT_ATOM_(_NET_WM_NAME);\n\tINIT_ATOM_(_NET_WM_ICON_NAME);\n\tINIT_ATOM_(_NET_WM_ICON);\n\tINIT_ATOM_(_NET_WM_STATE);\n\tINIT_ATOM_(_NET_WM_STATE_FULLSCREEN);\n}\n\nvoid win_open(win_t *win)\n{\n\tint c, i, j, n;\n\tlong parent;\n\twin_env_t *e;\n\tXClassHint classhint;\n\tunsigned long *icon_data;\n\tXColor col;\n\tCursor *cnone = &cursors[CURSOR_NONE].icon;\n\tchar none_data[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\tPixmap none;\n\tint gmask;\n\tXSizeHints sizehints;\n\n\te = &win->env;\n\tparent = options->embed != 0 ? options->embed : RootWindow(e->dpy, e->scr);\n\n\tsizehints.flags = PWinGravity;\n\tsizehints.win_gravity = NorthWestGravity;\n\n\t/* determine window offsets, width & height */\n\tif (options->geometry == NULL)\n\t\tgmask = 0;\n\telse\n\t\tgmask = XParseGeometry(options->geometry, &win->x, &win->y,\n\t\t                       &win->w, &win->h);\n\tif ((gmask & WidthValue) != 0)\n\t\tsizehints.flags |= USSize;\n\telse\n\t\twin->w = WIN_WIDTH;\n\tif ((gmask & HeightValue) != 0)\n\t\tsizehints.flags |= USSize;\n\telse\n\t\twin->h = WIN_HEIGHT;\n\tif ((gmask & XValue) != 0) {\n\t\tif ((gmask & XNegative) != 0) {\n\t\t\twin->x += e->scrw - win->w;\n\t\t\tsizehints.win_gravity = NorthEastGravity;\n\t\t}\n\t\tsizehints.flags |= USPosition;\n\t} else {\n\t\twin->x = 0;\n\t}\n\tif ((gmask & YValue) != 0) {\n\t\tif ((gmask & YNegative) != 0) {\n\t\t\twin->y += e->scrh - win->h;\n\t\t\tsizehints.win_gravity = sizehints.win_gravity == NorthEastGravity\n\t\t\t                      ? SouthEastGravity : SouthWestGravity;\n\t\t}\n\t\tsizehints.flags |= USPosition;\n\t} else {\n\t\twin->y = 0;\n\t}\n\n\twin->xwin = XCreateWindow(e->dpy, parent,\n\t                          win->x, win->y, win->w, win->h, 0,\n\t                          e->depth, InputOutput, e->vis, 0, NULL);\n\tif (win->xwin == None)\n\t\terror(EXIT_FAILURE, 0, \"Error creating X window\");\n\n\tXSelectInput(e->dpy, win->xwin,\n\t             ButtonReleaseMask | ButtonPressMask | KeyPressMask |\n\t             PointerMotionMask | StructureNotifyMask);\n\n\tfor (i = 0; i < ARRLEN(cursors); i++) {\n\t\tif (i != CURSOR_NONE)\n\t\t\tcursors[i].icon = XCreateFontCursor(e->dpy, cursors[i].name);\n\t}\n\tif (XAllocNamedColor(e->dpy, DefaultColormap(e->dpy, e->scr), \"black\",\n\t                     &col, &col) == 0)\n\t{\n\t\terror(EXIT_FAILURE, 0, \"Error allocating color 'black'\");\n\t}\n\tnone = XCreateBitmapFromData(e->dpy, win->xwin, none_data, 8, 8);\n\t*cnone = XCreatePixmapCursor(e->dpy, none, none, &col, &col, 0, 0);\n\n\tgc = XCreateGC(e->dpy, win->xwin, 0, None);\n\n\tn = icons[ARRLEN(icons)-1].size;\n\ticon_data = emalloc((n * n + 2) * sizeof(*icon_data));\n\n\tfor (i = 0; i < ARRLEN(icons); i++) {\n\t\tn = 0;\n\t\ticon_data[n++] = icons[i].size;\n\t\ticon_data[n++] = icons[i].size;\n\n\t\tfor (j = 0; j < icons[i].cnt; j++) {\n\t\t\tfor (c = icons[i].data[j] >> 4; c >= 0; c--)\n\t\t\t\ticon_data[n++] = icon_colors[icons[i].data[j] & 0x0F];\n\t\t}\n\t\tXChangeProperty(e->dpy, win->xwin,\n\t\t                atoms[ATOM__NET_WM_ICON], XA_CARDINAL, 32,\n\t\t                i == 0 ? PropModeReplace : PropModeAppend,\n\t\t                (unsigned char *) icon_data, n);\n\t}\n\tfree(icon_data);\n\n\twin_set_title(win, \"sxiv\");\n\n\tclasshint.res_class = RES_CLASS;\n\tclasshint.res_name = options->res_name != NULL ? options->res_name : \"sxiv\";\n\tXSetClassHint(e->dpy, win->xwin, &classhint);\n\n\tXSetWMProtocols(e->dpy, win->xwin, &atoms[ATOM_WM_DELETE_WINDOW], 1);\n\n\tsizehints.width = win->w;\n\tsizehints.height = win->h;\n\tsizehints.x = win->x;\n\tsizehints.y = win->y;\n\tXSetWMNormalHints(win->env.dpy, win->xwin, &sizehints);\n\n\twin->h -= win->bar.h;\n\n\twin->buf.w = e->scrw;\n\twin->buf.h = e->scrh;\n\twin->buf.pm = XCreatePixmap(e->dpy, win->xwin,\n\t                            win->buf.w, win->buf.h, e->depth);\n\tXSetForeground(e->dpy, gc, win->bg.pixel);\n\tXFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);\n\tXSetWindowBackgroundPixmap(e->dpy, win->xwin, win->buf.pm);\n\n\tXMapWindow(e->dpy, win->xwin);\n\tXFlush(e->dpy);\n\n\tif (options->fullscreen)\n\t\twin_toggle_fullscreen(win);\n}\n\nCLEANUP void win_close(win_t *win)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRLEN(cursors); i++)\n\t\tXFreeCursor(win->env.dpy, cursors[i].icon);\n\n\tXFreeGC(win->env.dpy, gc);\n\n\tXDestroyWindow(win->env.dpy, win->xwin);\n\tXCloseDisplay(win->env.dpy);\n}\n\nbool win_configure(win_t *win, XConfigureEvent *c)\n{\n\tbool changed;\n\n\tchanged = win->w != c->width || win->h + win->bar.h != c->height;\n\n\twin->x = c->x;\n\twin->y = c->y;\n\twin->w = c->width;\n\twin->h = c->height - win->bar.h;\n\twin->bw = c->border_width;\n\n\treturn changed;\n}\n\nvoid win_toggle_fullscreen(win_t *win)\n{\n\tXEvent ev;\n\tXClientMessageEvent *cm;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = ClientMessage;\n\n\tcm = &ev.xclient;\n\tcm->window = win->xwin;\n\tcm->message_type = atoms[ATOM__NET_WM_STATE];\n\tcm->format = 32;\n\tcm->data.l[0] = 2; // toggle\n\tcm->data.l[1] = atoms[ATOM__NET_WM_STATE_FULLSCREEN];\n\n\tXSendEvent(win->env.dpy, DefaultRootWindow(win->env.dpy), False,\n\t           SubstructureNotifyMask | SubstructureRedirectMask, &ev);\n}\n\nvoid win_toggle_bar(win_t *win)\n{\n\tif (win->bar.h != 0) {\n\t\twin->h += win->bar.h;\n\t\twin->bar.h = 0;\n\t} else {\n\t\twin->bar.h = barheight;\n\t\twin->h -= win->bar.h;\n\t}\n}\n\nvoid win_clear(win_t *win)\n{\n\twin_env_t *e;\n\n\te = &win->env;\n\n\tif (win->w > win->buf.w || win->h + win->bar.h > win->buf.h) {\n\t\tXFreePixmap(e->dpy, win->buf.pm);\n\t\twin->buf.w = MAX(win->buf.w, win->w);\n\t\twin->buf.h = MAX(win->buf.h, win->h + win->bar.h);\n\t\twin->buf.pm = XCreatePixmap(e->dpy, win->xwin,\n\t\t                            win->buf.w, win->buf.h, e->depth);\n\t}\n\tXSetForeground(e->dpy, gc, win->bg.pixel);\n\tXFillRectangle(e->dpy, win->buf.pm, gc, 0, 0, win->buf.w, win->buf.h);\n}\n\n#define TEXTWIDTH(win, text, len) \\\n\twin_draw_text(win, NULL, NULL, 0, 0, text, len, 0)\n\nint win_draw_text(win_t *win, XftDraw *d, const XftColor *color, int x, int y,\n                  char *text, int len, int w)\n{\n\tint err, tw = 0;\n\tchar *t, *next;\n\tuint32_t rune;\n\tXftFont *f;\n\tFcCharSet *fccharset;\n\tXGlyphInfo ext;\n\n\tfor (t = text; t - text < len; t = next) {\n\t\tnext = utf8_decode(t, &rune, &err);\n\t\tif (XftCharExists(win->env.dpy, font, rune)) {\n\t\t\tf = font;\n\t\t} else { /* fallback font */\n\t\t\tfccharset = FcCharSetCreate();\n\t\t\tFcCharSetAddChar(fccharset, rune);\n\t\t\tf = XftFontOpen(win->env.dpy, win->env.scr, FC_CHARSET, FcTypeCharSet,\n\t\t\t                fccharset, FC_SCALABLE, FcTypeBool, FcTrue,\n\t\t\t                FC_SIZE, FcTypeDouble, fontsize, NULL);\n\t\t\tFcCharSetDestroy(fccharset);\n\t\t}\n\t\tXftTextExtentsUtf8(win->env.dpy, f, (XftChar8*)t, next - t, &ext);\n\t\ttw += ext.xOff;\n\t\tif (tw <= w) {\n\t\t\tXftDrawStringUtf8(d, color, f, x, y, (XftChar8*)t, next - t);\n\t\t\tx += ext.xOff;\n\t\t}\n\t\tif (f != font)\n\t\t\tXftFontClose(win->env.dpy, f);\n\t}\n\treturn tw;\n}\n\nvoid win_draw_bar(win_t *win)\n{\n\tint len, x, y, w, tw;\n\twin_env_t *e;\n\twin_bar_t *l, *r;\n\tXftDraw *d;\n\n\tif ((l = &win->bar.l)->buf == NULL || (r = &win->bar.r)->buf == NULL)\n\t\treturn;\n\n\te = &win->env;\n\ty = win->h + font->ascent + V_TEXT_PAD;\n\tw = win->w - 2*H_TEXT_PAD;\n\td = XftDrawCreate(e->dpy, win->buf.pm, DefaultVisual(e->dpy, e->scr),\n\t                  DefaultColormap(e->dpy, e->scr));\n\n\tXSetForeground(e->dpy, gc, win->fg.pixel);\n\tXFillRectangle(e->dpy, win->buf.pm, gc, 0, win->h, win->w, win->bar.h);\n\n\tXSetForeground(e->dpy, gc, win->bg.pixel);\n\tXSetBackground(e->dpy, gc, win->fg.pixel);\n\n\tif ((len = strlen(r->buf)) > 0) {\n\t\tif ((tw = TEXTWIDTH(win, r->buf, len)) > w)\n\t\t\treturn;\n\t\tx = win->w - tw - H_TEXT_PAD;\n\t\tw -= tw;\n\t\twin_draw_text(win, d, &win->bg, x, y, r->buf, len, tw);\n\t}\n\tif ((len = strlen(l->buf)) > 0) {\n\t\tx = H_TEXT_PAD;\n\t\tw -= 2 * H_TEXT_PAD; /* gap between left and right parts */\n\t\twin_draw_text(win, d, &win->bg, x, y, l->buf, len, w);\n\t}\n\tXftDrawDestroy(d);\n}\n\nvoid win_draw(win_t *win)\n{\n\tif (win->bar.h > 0)\n\t\twin_draw_bar(win);\n\n\tXSetWindowBackgroundPixmap(win->env.dpy, win->xwin, win->buf.pm);\n\tXClearWindow(win->env.dpy, win->xwin);\n\tXFlush(win->env.dpy);\n}\n\nvoid win_draw_rect(win_t *win, int x, int y, int w, int h, bool fill, int lw,\n                   unsigned long col)\n{\n\tXGCValues gcval;\n\n\tgcval.line_width = lw;\n\tgcval.foreground = col;\n\tXChangeGC(win->env.dpy, gc, GCForeground | GCLineWidth, &gcval);\n\n\tif (fill)\n\t\tXFillRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);\n\telse\n\t\tXDrawRectangle(win->env.dpy, win->buf.pm, gc, x, y, w, h);\n}\n\nvoid win_set_title(win_t *win, const char *title)\n{\n\tXStoreName(win->env.dpy, win->xwin, title);\n\tXSetIconName(win->env.dpy, win->xwin, title);\n\n\tXChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_NAME],\n\t                XInternAtom(win->env.dpy, \"UTF8_STRING\", False), 8,\n\t                PropModeReplace, (unsigned char *) title, strlen(title));\n\tXChangeProperty(win->env.dpy, win->xwin, atoms[ATOM__NET_WM_ICON_NAME],\n\t                XInternAtom(win->env.dpy, \"UTF8_STRING\", False), 8,\n\t                PropModeReplace, (unsigned char *) title, strlen(title));\n}\n\nvoid win_set_cursor(win_t *win, cursor_t cursor)\n{\n\tif (cursor >= 0 && cursor < ARRLEN(cursors)) {\n\t\tXDefineCursor(win->env.dpy, win->xwin, cursors[cursor].icon);\n\t\tXFlush(win->env.dpy);\n\t}\n}\n\nvoid win_cursor_pos(win_t *win, int *x, int *y)\n{\n\tint i;\n\tunsigned int ui;\n\tWindow w;\n\n\tif (!XQueryPointer(win->env.dpy, win->xwin, &w, &w, &i, &i, x, y, &ui))\n\t\t*x = *y = 0;\n}\n\n"
        }
      ]
    }
  ]
}