{
  "metadata": {
    "timestamp": 1736709993571,
    "page": 570,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "swaywm/wlroots",
      "stars": 2160,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".builds",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1865234375,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\ntrim_trailing_whitespace = true\nindent_style = tab\nindent_size = 4\n\n[*.xml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0859375,
          "content": ".clang_complete\n*.o\n*.a\nbin/\ntest/\nbuild/\nbuild-*/\nwayland-*-protocol.*\nwlr-example.ini\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 13.505859375,
          "content": "# Contributing to wlroots\n\nContributing just involves sending a pull request. You will probably be more\nsuccessful with your contribution if you visit [#sway-devel on Libera Chat]\nupfront and discuss your plans.\n\nNote: rules are made to be broken. Adjust or ignore any/all of these as you see\nfit, but be prepared to justify it to your peers.\n\n## Pull Requests\n\nIf you already have your own pull request habits, feel free to use them. If you\ndon't, however, allow me to make a suggestion: feature branches pulled from\nupstream. Try this:\n\n1. Fork wlroots\n2. `git clone git@github.com:<username>/wlroots.git && cd wlroots`\n3. `git remote add upstream https://github.com/swaywm/wlroots`\n\nYou only need to do this once. You're never going to use your fork's master\nbranch. Instead, when you start working on a feature, do this:\n\n1. `git fetch upstream`\n2. `git checkout -b add-so-and-so-feature upstream/master`\n3. Add and commit your changes\n4. `git push -u origin add-so-and-so-feature`\n5. Make a pull request from your feature branch\n\nWhen you submit your pull request, your commit log should do most of the talking\nwhen it comes to describing your changes and their motivation. In addition to\nthis, your pull request's comments will ideally include a test plan that the\nreviewers can use to (1) demonstrate the problem on master, if applicable and\n(2) verify that the problem no longer exists with your changes applied (or that\nyour new features work correctly). Document all of the edge cases you're aware\nof so we can adequately test them - then verify the test plan yourself before\nsubmitting.\n\n## Commit Log\n\nUnlike many projects using GitHub and GitLab, wlroots has a [linear, \"recipe\"\nstyle] history. This means that every commit should be small, digestible,\nstand-alone, and functional. Rather than a purely chronological commit history\nlike this:\n\n```\ndoc: final docs for view transforms\nfix tests when disabled, redo broken doc formatting\nbetter transformed-view iteration (thanks Hannah!)\ntry to catch more cases in tests\ntests: add new spline test\nfix compilation on splines\ndoc: notes on reticulating splines\ncompositor: add spline reticulation for view transforms\n```\n\nWe aim to have a clean history which only reflects the final state, broken up\ninto functional groupings:\n\n```\ncompositor: add spline reticulation for view transforms\ncompositor: new iterator for view transforms\ntests: add view-transform correctness tests\ndoc: fix formatting for view transforms\n```\n\nThis ensures that the final patch series only contains the final state,\nwithout the changes and missteps taken along the development process. A linear\nhistory eases reviewing, cherry-picking and reverting changes.\n\nIf you aren't comfortable with manipulating the Git history, have a look at\n[git-rebase.io].\n\n## Commit Messages\n\nPlease strive to write good commit messages. Here's some guidelines to follow:\n\nThe first line should be limited to 50 characters and should be a sentence that\ncompletes the thought [When applied, this commit will...] *\"Implement\ncmd_move\"* or *\"Improve performance of arrange_windows on ARM\"* or similar.\n\nThe subsequent lines should be separated from the subject line by a single\nblank line, and include optional details. In this you can give justification\nfor the change, [reference Github issues], or explain some of the subtler\ndetails of your patch. This is important because when someone finds a line of\ncode they don't understand later, they can use the `git blame` command to find\nout what the author was thinking when they wrote it. It's also easier to review\nyour pull requests if they're separated into logical commits that have good\ncommit messages and justify themselves in the extended commit description.\n\nAs a good rule of thumb, anything you might put into the pull request\ndescription on Github is probably fair game for going into the extended commit\nmessage as well.\n\nSee [How to Write a Git Commit Message] for more details.\n\n## Code Review\n\nWhen your changes are submitted for review, one or more core committers will\nlook over them. Smaller changes might be merged with little fanfare, but larger\nchanges will typically see review from several people. Be prepared to receive\nsome feedback - you may be asked to make changes to your work. Our code review\nprocess is:\n\n1. **Triage** the pull request. Do the commit messages make sense? Is a test\n   plan necessary and/or present? Add anyone as reviewers that you think should\n   be there (using the relevant GitHub feature, if you have the permissions, or\n   with an @mention if necessary).\n2. **Review** the code. Look for code style violations, naming convention\n   violations, buffer overflows, memory leaks, logic errors, non-portable code\n   (including GNU-isms), etc. For significant changes to the public API, loop in\n   a couple more people for discussion.\n3. **Execute** the test plan, if present.\n4. **Merge** the pull request when all reviewers approve.\n5. **File** follow-up tickets if appropriate.\n\n## Style Reference\n\nwlroots is written in C with a style similar to the [kernel style], but with a\nfew notable differences.\n\nTry to keep your code conforming to C11 and POSIX as much as possible, and do\nnot use GNU extensions.\n\n### Brackets\n\nBrackets always go on the same line, including in functions.\nAlways include brackets for if/while/for, even if it's a single statement.\n```c\nvoid function(void) {\n\tif (condition1) {\n\t\tdo_thing1();\n\t}\n\n\tif (condition2) {\n\t\tdo_thing2();\n\t} else {\n\t\tdo_thing3();\n\t}\n}\n```\n\n### Indentation\n\nIndentations are a single tab.\n\nFor long lines that need to be broken, the continuation line should be indented\nwith an additional tab.\nIf the line being broken is opening a new block (functions, if, while, etc.),\nthe continuation line should be indented with two tabs, so they can't be\nmisread as being part of the block.\n```c\nreally_long_function(argument1, argument2, ...,\n\targument3, argument4);\n\nif (condition1 && condition2 && ...\n\t\tcondition3 && condition4) {\n\tdo_thing();\n}\n```\n\nTry to break the line in the place which you think is the most appropriate.\n\n\n### Line Length\n\nTry to keep your lines under 80 columns, but you can go up to 100 if it\nimproves readability. Don't break lines indiscriminately, try to find nice\nbreaking points so your code is easy to read.\n\n### Names\n\nGlobal function and type names should be prefixed with `wlr_submodule_` (e.g.\n`struct wlr_output`, `wlr_output_set_cursor`).  For static functions and\ntypes local to a file, the names chosen aren't as important.  Local function\nnames shouldn't have a `wlr_` prefix.\n\nFor include guards, use the header's filename relative to include.  Uppercase\nall of the characters, and replace any invalid characters with an underscore.\n\n### Construction/Destruction Functions\n\nFor functions that are responsible for constructing and destructing an object,\nthey should be written as a pair of one of two forms:\n* `init`/`finish`: These initialize/deinitialize a type, but are **NOT**\nresponsible for allocating it. They should accept a pointer to some\npre-allocated memory (e.g. a member of a struct).\n* `create`/`destroy`: These also initialize/deinitialize, but will return a\npointer to a `malloc`ed chunk of memory, and will `free` it in `destroy`.\n\nA destruction function should always be able to accept a NULL pointer or a\nzeroed value and exit cleanly; this simplifies error handling a lot.\n\n### Error Codes\n\nFor functions not returning a value, they should return a (stdbool.h) bool to\nindicate whether they succeeded or not.\n\n### Macros\n\nTry to keep the use of macros to a minimum, especially if a function can do the\njob.  If you do need to use them, try to keep them close to where they're being\nused and `#undef` them after.\n\n### Example\n\n```c\nstruct wlr_backend *wlr_backend_autocreate(struct wl_display *display) {\n\tstruct wlr_backend *backend;\n\tif (getenv(\"WAYLAND_DISPLAY\") || getenv(\"_WAYLAND_DISPLAY\")) {\n\t\tbackend = attempt_wl_backend(display);\n\t\tif (backend) {\n\t\t\treturn backend;\n\t\t}\n\t}\n\n\tconst char *x11_display = getenv(\"DISPLAY\");\n\tif (x11_display) {\n\t\treturn wlr_x11_backend_create(display, x11_display);\n\t}\n\n\t// Attempt DRM+libinput\n\n\tstruct wlr_session *session = wlr_session_create(display);\n\tif (!session) {\n\t\twlr_log(WLR_ERROR, \"Failed to start a DRM session\");\n\t\treturn NULL;\n\t}\n\n\tint gpu = wlr_session_find_gpu(session);\n\tif (gpu == -1) {\n\t\twlr_log(WLR_ERROR, \"Failed to open DRM device\");\n\t\tgoto error_session;\n\t}\n\n\tbackend = wlr_multi_backend_create(session);\n\tif (!backend) {\n\t\tgoto error_gpu;\n\t}\n\n\tstruct wlr_backend *libinput = wlr_libinput_backend_create(display, session);\n\tif (!libinput) {\n\t\tgoto error_multi;\n\t}\n\n\tstruct wlr_backend *drm = wlr_drm_backend_create(display, session, gpu);\n\tif (!drm) {\n\t\tgoto error_libinput;\n\t}\n\n\twlr_multi_backend_add(backend, libinput);\n\twlr_multi_backend_add(backend, drm);\n\treturn backend;\n\nerror_libinput:\n\twlr_backend_destroy(libinput);\nerror_multi:\n\twlr_backend_destroy(backend);\nerror_gpu:\n\twlr_session_close_file(session, gpu);\nerror_session:\n\twlr_session_destroy(session);\n\treturn NULL;\n}\n```\n\n## Wayland protocol implementation\n\nEach protocol generally lives in a file with the same name, usually containing\nat least one struct for each interface in the protocol. For instance,\n`xdg_shell` lives in `types/wlr_xdg_shell.h` and has a `wlr_xdg_surface` struct.\n\n### Globals\n\nGlobal interfaces generally have public constructors and destructors. Their\nstruct has a field holding the `wl_global` itself, a destroy signal and a\n`wl_display` destroy listener. Example:\n\n```c\nstruct wlr_compositor {\n\tstruct wl_global *global;\n\t…\n\n\tstruct wl_listener display_destroy;\n\n\tstruct {\n\t\tstruct wl_signal new_surface;\n\t\tstruct wl_signal destroy;\n\t} events;\n};\n```\n\nWhen the destructor is called, it should emit the destroy signal, remove the\ndisplay destroy listener, destroy the `wl_global` and then destroy the struct.\nThe destructor can assume all clients and resources have been already\ndestroyed.\n\n### Resources\n\nResources are the representation of Wayland objects on the compositor side. They\ngenerally have an associated struct, called the _object struct_, stored in their\n`user_data` field.\n\nObject structs can be retrieved from resources via `wl_resource_get_data`. To\nprevent bad casts, a safe helper function checking the type of the resource is\nused:\n\n```c\nstatic const struct wl_surface_interface surface_impl;\n\nstruct wlr_surface *wlr_surface_from_resource(struct wl_resource *resource) {\n\tassert(wl_resource_instance_of(resource, &wl_surface_interface,\n\t\t&surface_impl));\n\treturn wl_resource_get_user_data(resource);\n}\n```\n\nIf a pointer to a `wl_resource` is stored, a resource destroy handler needs to\nbe registered to clean it up. libwayland will automatically destroy resources\nin an arbitrary order when a client is disconnected, the compositor must handle\nthis correctly.\n\n### Destroying resources\n\nObject structs should only be destroyed when their resource is destroyed, ie.\nin the resource destroy handler (set with `wl_resource_set_implementation`).\n\n- If the object has a destructor request: the request handler should just call\n  `wl_resource_destroy` and do nothing else. The compositor must not destroy\n  resources on its own outside the destructor request handler.\n- If the protocol specifies that an object is destroyed when an event is sent:\n  it's the only case where the compositor is allowed to send the event and then\n  call `wl_resource_destroy`. An example of this is `wl_callback`.\n\n### Inert resources\n\nSome resources can become inert in situations described in the protocol or when\nthe compositor decides to get rid of them. All requests made to inert resources\nshould be ignored, except the destructor. This is achieved by:\n\n1. When the resource becomes inert: destroy the object struct and call\n   `wl_resource_set_user_data(resource, NULL)`. Do not destroy the resource.\n2. For each request made to a resource that can be inert: add a NULL check to\n   ignore the request if the resource is inert.\n3. When the client calls the destructor request on the resource: call\n   `wl_resource_destroy(resource)` as usual.\n4. When the resource is destroyed, if the resource isn't inert, destroy the\n   object struct.\n\nExample:\n\n```c\n// Handles the destroy request\nstatic void subsurface_handle_destroy(struct wl_client *client,\n\t\tstruct wl_resource *resource) {\n\twl_resource_destroy(resource);\n}\n\n// Handles a regular request\nstatic void subsurface_set_position(struct wl_client *client,\n\t\tstruct wl_resource *resource, int32_t x, int32_t y) {\n\tstruct wlr_subsurface *subsurface = subsurface_from_resource(resource);\n\tif (subsurface == NULL) {\n\t\treturn;\n\t}\n\n\t…\n}\n\n// Destroys the wlr_subsurface struct\nstatic void subsurface_destroy(struct wlr_subsurface *subsurface) {\n\tif (subsurface == NULL) {\n\t\treturn;\n\t}\n\n\t…\n\n\twl_resource_set_user_data(subsurface->resource, NULL);\n\tfree(subsurface);\n}\n\n// Resource destroy listener\nstatic void subsurface_handle_resource_destroy(struct wl_resource *resource) {\n\tstruct wlr_subsurface *subsurface = subsurface_from_resource(resource);\n\tsubsurface_destroy(subsurface);\n}\n\n// Makes the resource inert\nstatic void subsurface_handle_surface_destroy(struct wl_listener *listener,\n\t\tvoid *data) {\n\tstruct wlr_subsurface *subsurface =\n\t\twl_container_of(listener, subsurface, surface_destroy);\n\tsubsurface_destroy(subsurface);\n}\n```\n\n[#sway-devel on Libera Chat]: https://web.libera.chat/gamja/?channels=#sway-devel\n[linear, \"recipe\" style]: https://www.bitsnbites.eu/git-history-work-log-vs-recipe/\n[git-rebase.io]: https://git-rebase.io/\n[reference Github issues]: https://help.github.com/articles/closing-issues-via-commit-messages/\n[How to Write a Git Commit Message]: https://chris.beams.io/posts/git-commit/\n[kernel style]: https://www.kernel.org/doc/Documentation/process/coding-style.rst\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0703125,
          "content": "Copyright (c) 2017, 2018 Drew DeVault\nCopyright (c) 2014 Jari Vetoniemi\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1767578125,
          "content": "# wlroots\n\n> ### ⚠️ Migrated to gitlab.freedesktop.org\n>\n> This project has [migrated to gitlab.freedesktop.org](https://gitlab.freedesktop.org/wlroots/wlroots).\n\nPluggable, composable, unopinionated modules for building a [Wayland]\ncompositor; or about 60,000 lines of code you were going to write anyway.\n\n- wlroots provides backends that abstract the underlying display and input\n  hardware, including KMS/DRM, libinput, Wayland, X11, and headless backends,\n  plus any custom backends you choose to write, which can all be created or\n  destroyed at runtime and used in concert with each other.\n- wlroots provides unopinionated, mostly standalone implementations of many\n  Wayland interfaces, both from wayland.xml and various protocol extensions.\n  We also promote the standardization of portable extensions across\n  many compositors.\n- wlroots provides several powerful, standalone, and optional tools that\n  implement components common to many compositors, such as the arrangement of\n  outputs in physical space.\n- wlroots provides an Xwayland abstraction that allows you to have excellent\n  Xwayland support without worrying about writing your own X11 window manager\n  on top of writing your compositor.\n- wlroots provides a renderer abstraction that simple compositors can use to\n  avoid writing GL code directly, but which steps out of the way when your\n  needs demand custom rendering code.\n\nwlroots implements a huge variety of Wayland compositor features and implements\nthem *right*, so you can focus on the features that make your compositor\nunique. By using wlroots, you get high performance, excellent hardware\ncompatibility, broad support for many wayland interfaces, and comfortable\ndevelopment tools - or any subset of these features you like, because all of\nthem work independently of one another and freely compose with anything you want\nto implement yourself.\n\nCheck out our [wiki] to get started with wlroots. Join our IRC channel:\n[#sway-devel on Libera Chat].\n\nwlroots is developed under the direction of the [sway] project. A variety of\n[wrapper libraries] are available for using it with your favorite programming\nlanguage.\n\n## Building\n\nInstall dependencies:\n\n* meson\n* wayland\n* wayland-protocols\n* EGL and GLESv2 (optional, for the GLES2 renderer)\n* Vulkan loader, headers and glslang (optional, for the Vulkan renderer)\n* libdrm\n* GBM\n* libinput (optional, for the libinput backend)\n* xkbcommon\n* udev\n* pixman\n* [libseat]\n\nIf you choose to enable X11 support:\n\n* xwayland (build-time only, optional at runtime)\n* libxcb\n* libxcb-render-util\n* libxcb-wm\n* libxcb-errors (optional, for improved error reporting)\n\nRun these commands:\n\n    meson build/\n    ninja -C build/\n\nInstall like so:\n\n    sudo ninja -C build/ install\n\n## Contributing\n\nSee [CONTRIBUTING.md].\n\n[Wayland]: https://wayland.freedesktop.org/\n[wiki]: https://github.com/swaywm/wlroots/wiki/Getting-started\n[#sway-devel on Libera Chat]: https://web.libera.chat/gamja/?channels=#sway-devel\n[Sway]: https://github.com/swaywm/sway\n[wrapper libraries]: https://github.com/search?q=topic%3Abindings+org%3Aswaywm&type=Repositories\n[libseat]: https://git.sr.ht/~kennylevinsen/seatd\n[CONTRIBUTING.md]: https://github.com/swaywm/wlroots/blob/master/CONTRIBUTING.md\n"
        },
        {
          "name": "backend",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 4.3271484375,
          "content": "project(\n\t'wlroots',\n\t'c',\n\tversion: '0.15.0',\n\tlicense: 'MIT',\n\tmeson_version: '>=0.58.1',\n\tdefault_options: [\n\t\t'c_std=c11',\n\t\t'warning_level=2',\n\t\t'werror=true',\n\t],\n)\n\n# When doing a major or minor release, *always* increase soversion. This isn't\n# necessary for bugfix releases. Increasing soversion is required because\n# wlroots never guarantees ABI stability -- only API stability is guaranteed\n# between minor releases.\nsoversion = 10\n\nlittle_endian = host_machine.endian() == 'little'\nbig_endian = host_machine.endian() == 'big'\n\nadd_project_arguments([\n\t'-DWLR_USE_UNSTABLE',\n\t'-DWLR_LITTLE_ENDIAN=@0@'.format(little_endian.to_int()),\n\t'-DWLR_BIG_ENDIAN=@0@'.format(big_endian.to_int()),\n], language: 'c')\n\ncc = meson.get_compiler('c')\n\nadd_project_arguments(cc.get_supported_arguments([\n\t'-Wundef',\n\t'-Wlogical-op',\n\t'-Wmissing-include-dirs',\n\t'-Wold-style-definition',\n\t'-Wpointer-arith',\n\t'-Winit-self',\n\t'-Wstrict-prototypes',\n\t'-Wimplicit-fallthrough=2',\n\t'-Wendif-labels',\n\t'-Wstrict-aliasing=2',\n\t'-Woverflow',\n\t'-Wmissing-prototypes',\n\t'-Walloca',\n\n\t'-Wno-missing-braces',\n\t'-Wno-missing-field-initializers',\n\t'-Wno-unused-parameter',\n]), language: 'c')\n\n# Compute the relative path used by compiler invocations.\nsource_root = meson.current_source_dir().split('/')\nbuild_root = meson.global_build_root().split('/')\nrelative_dir_parts = []\ni = 0\nin_prefix = true\nforeach p : build_root\n\tif i >= source_root.length() or not in_prefix or p != source_root[i]\n\t\tin_prefix = false\n\t\trelative_dir_parts += '..'\n\tendif\n\ti += 1\nendforeach\ni = 0\nin_prefix = true\nforeach p : source_root\n\tif i >= build_root.length() or not in_prefix or build_root[i] != p\n\t\tin_prefix = false\n\t\trelative_dir_parts += p\n\tendif\n\ti += 1\nendforeach\nrelative_dir = join_paths(relative_dir_parts) + '/'\n\n# Strip relative path prefixes from the code if possible, otherwise hide them.\nif cc.has_argument('-fmacro-prefix-map=/prefix/to/hide=')\n\tadd_project_arguments(\n\t\t'-fmacro-prefix-map=@0@='.format(relative_dir),\n\t\tlanguage: 'c',\n\t)\nelse\n\tadd_project_arguments(\n\t\t'-DWLR_REL_SRC_DIR=\"@0@\"'.format(relative_dir),\n\t\tlanguage: 'c',\n\t)\nendif\n\nfeatures = {\n\t'drm-backend': false,\n\t'x11-backend': false,\n\t'libinput-backend': false,\n\t'xwayland': false,\n\t'gles2-renderer': false,\n\t'vulkan-renderer': false,\n}\ninternal_features = {\n\t'xcb-errors': false,\n}\n\nwayland_project_options = ['tests=false', 'documentation=false']\nwayland_server = dependency('wayland-server',\n\tversion: '>=1.19',\n\tfallback: ['wayland', 'wayland_server_dep'],\n\tdefault_options: wayland_project_options,\n)\nwayland_client = dependency('wayland-client',\n\tfallback: ['wayland', 'wayland_client_dep'],\n\tdefault_options: wayland_project_options,\n)\n\ndrm = dependency('libdrm', version: '>=2.4.105')\ngbm = dependency('gbm', version: '>=17.1.0')\nxkbcommon = dependency('xkbcommon')\nudev = dependency('libudev')\npixman = dependency('pixman-1')\nmath = cc.find_library('m')\nrt = cc.find_library('rt')\n\nwlr_files = []\nwlr_deps = [\n\twayland_server,\n\twayland_client,\n\tdrm,\n\tgbm,\n\txkbcommon,\n\tudev,\n\tpixman,\n\tmath,\n\trt,\n]\n\nsubdir('protocol')\nsubdir('render')\n\nsubdir('backend')\nsubdir('types')\nsubdir('util')\nsubdir('xcursor')\nsubdir('xwayland')\n\nsubdir('include')\n\nforeach name, have : internal_features\n\tadd_project_arguments(\n\t\t'-DHAS_@0@=@1@'.format(name.underscorify().to_upper(), have.to_int()),\n\t\tlanguage: 'c',\n\t)\nendforeach\n\nwlr_inc = include_directories('include')\nproto_inc = include_directories('protocol')\n\nsymbols_file = 'wlroots.syms'\nsymbols_flag = '-Wl,--version-script,@0@/@1@'.format(meson.current_source_dir(), symbols_file)\nlib_wlr = library(\n\tmeson.project_name(), wlr_files,\n\tsoversion: soversion,\n\tdependencies: wlr_deps,\n\tinclude_directories: [wlr_inc, proto_inc],\n\tinstall: true,\n\tlink_args: symbols_flag,\n\tlink_depends: symbols_file,\n)\n\nwlr_vars = {}\nforeach name, have : features\n\twlr_vars += { 'have_' + name.underscorify(): have.to_string() }\nendforeach\n\nwlroots = declare_dependency(\n\tlink_with: lib_wlr,\n\tdependencies: wlr_deps,\n\tinclude_directories: wlr_inc,\n\tvariables: wlr_vars,\n)\n\nmeson.override_dependency('wlroots', wlroots)\n\nsummary(features + internal_features, bool_yn: true)\n\nif get_option('examples')\n\tsubdir('examples')\nendif\n\npkgconfig = import('pkgconfig')\npkgconfig.generate(lib_wlr,\n\tversion: meson.project_version(),\n\tfilebase: meson.project_name(),\n\tname: meson.project_name(),\n\tdescription: 'Wayland compositor library',\n\tvariables: wlr_vars,\n)\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.6875,
          "content": "option('xcb-errors', type: 'feature', value: 'auto', description: 'Use xcb-errors util library')\noption('xwayland', type: 'feature', value: 'auto', yield: true, description: 'Enable support for X11 applications')\noption('examples', type: 'boolean', value: true, description: 'Build example applications')\noption('icon_directory', description: 'Location used to look for cursors (default: ${datadir}/icons)', type: 'string', value: '')\noption('renderers', type: 'array', choices: ['auto', 'gles2', 'vulkan'], value: ['auto'], description: 'Select built-in renderers')\noption('backends', type: 'array', choices: ['auto', 'drm', 'libinput', 'x11'], value: ['auto'], description: 'Select built-in backends')\n"
        },
        {
          "name": "protocol",
          "type": "tree",
          "content": null
        },
        {
          "name": "render",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinywl",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "wlroots.syms",
          "type": "blob",
          "size": 0.044921875,
          "content": "{\n\tglobal:\n\t\twlr_*;\n\t\t_wlr_*;\n\tlocal:\n\t\t*;\n};\n"
        },
        {
          "name": "xcursor",
          "type": "tree",
          "content": null
        },
        {
          "name": "xwayland",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}