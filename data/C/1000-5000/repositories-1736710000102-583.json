{
  "metadata": {
    "timestamp": 1736710000102,
    "page": 583,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "symisc/unqlite",
      "stars": 2137,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.138671875,
          "content": "# CMake / Make / Build\n/CMakeFiles/\ncmake_install.cmake\nCMakeCache.txt\nMakefile\n\n# Binary\nlibunqlite.a\n\n# IDEs\n.idea\n.vscode\n\n# Build\n*build*\n"
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 0.3095703125,
          "content": "stages:\n  - build\n  - test\n\nbuild:linux:\n  stage: build\n  image: ubuntu:17.10\n  tags:\n    - docker\n  before_script:\n    - DEBIAN_FRONTEND=noninteractive apt-get update -y\n    - DEBIAN_FRONTEND=noninteractive apt-get install -y gcc-mingw-w64 build-essential cmake\n  script:\n    - cmake ./CMakeLists.txt\n    - make all\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.509765625,
          "content": "sudo: false\nos: linux\ndist: trusty\n\n# Language\nlanguage: cpp\n\nmatrix:\n  include:\n    # GCC 6\n    - env: UNIT_TESTS=true COMPILER=g++-6 BOOST_VERSION=default ENABLE_MEMCHECK=true\n      addons: { apt: { packages: [\"g++-6\", \"valgrind\"], sources: [\"ubuntu-toolchain-r-test\"] } }\n\n    # GCC 7\n    - env: UNIT_TESTS=true COMPILER=g++-7 BOOST_VERSION=default ENABLE_MEMCHECK=true\n      addons: { apt: { packages: [\"g++-7\", \"valgrind\"], sources: [\"ubuntu-toolchain-r-test\"] } }\n\nscript:\n  - |\n    cmake CMakeLists.txt\n    make all"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.5537109375,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n### [v1.1.8] - May 2019\n\n### Fixed\n- Minor file handle leak fixed described in [issue 74](https://github.com/symisc/unqlite/issues/74).\n### State\n- No data corruption bug found since December 2017.\n## [1.1.8] - January 2018\n\n### Fixed\n\n- Sync database first if a dirty commit has been applied.\n- Header inclusion fix.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.1357421875,
          "content": "CMAKE_MINIMUM_REQUIRED(VERSION 3.0.0)\nPROJECT(unqlite)\nINCLUDE(GNUInstallDirs)\n\n# If the user did not customize the install prefix,\n# set it to live under build so we don't inadvertently pollute /usr/local\nIF(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  SET(CMAKE_INSTALL_PREFIX \"${CMAKE_BINARY_DIR}/install\" CACHE PATH \"default install path\" FORCE)\nENDIF(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n\nOPTION(ENABLE_THREADS \"Enable threads\" OFF)\n\nIF(${ENABLE_THREADS})\n  ADD_DEFINITIONS(\"-DUNQLITE_ENABLE_THREADS\")\nENDIF(${ENABLE_THREADS})\n\nINCLUDE_DIRECTORIES(${CMAKE_CURRENT_LIST_DIR}/src)\n\nSET(HEADERS_UNQLITE\n  unqlite.h\n)\nsource_group(\"Header Files\" FILES \"${HEADERS_UNQLITE}\")\n\nSET(SOURCES_UNQLITE\n  unqlite.c\n)\nsource_group(\"Source Files\" FILES \"${SOURCES_UNQLITE}\")\n\nSET(UNQLITE_STATIC_LIB unqlite)\nADD_LIBRARY(${UNQLITE_STATIC_LIB} ${HEADERS_UNQLITE} ${SOURCES_UNQLITE})\n\nINSTALL(TARGETS ${UNQLITE_STATIC_LIB} COMPONENT devel ARCHIVE DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\nINSTALL(FILES ${HEADERS_UNQLITE} COMPONENT devel DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\")\n\ninclude(CTest)\nif (BUILD_TESTING)\n  add_subdirectory(\"example\")\nendif (BUILD_TESTING)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4072265625,
          "content": " * Copyright (C) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Symisc Systems, S.U.A.R.L [M.I.A.G Mrad Chems Eddine <chm@symisc.net>].\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY SYMISC SYSTEMS ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR\n * NON-INFRINGEMENT, ARE DISCLAIMED.  IN NO EVENT SHALL SYMISC SYSTEMS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.20703125,
          "content": "### UnQLite - An Embedded Transactional Database (Key/Value & Document Store) Engine - https://unqlite.symisc.net\n[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/symisc/unqlite/pulse) [![GitHub license](https://img.shields.io/pypi/l/Django.svg)](https://unqlite.symisc.net/licensing.html) \n\n**Release 1.1.9** (May 2024): New Homepage - https://unqlite.symisc.net\n\n**Release 1.1.9** (April 2022): Shared database (between one legit & one corrupt process) bug fix: https://github.com/symisc/unqlite/issues/137\n\nAs of January 2018 - Symisc Systems has decided to **revive the UnQLite project**. All known data corruption bugs have been fixed, and expect to see new features (LZ compression), performance improvements, etc to be pushed here.\nYou should rely for your production build on the amalgamation file and its header file available here or to be downloaded directly from https://unqlite.symisc.net/downloads.html\n\n\nUnQLite is a in-process software library which implements a self-contained, serverless, zero-configuration, transactional NoSQL database engine. UnQLite is a document store database similar to MongoDB, Redis, CouchDB etc. as well a standard Key/Value store similar to BerkeleyDB, LevelDB, etc.\n\n\nUnQLite is an embedded NoSQL (Key/Value store and Document-store) database engine. Unlike most other NoSQL databases, UnQLite does not have a separate server process. UnQLite reads and writes directly to ordinary disk files. A complete database with multiple collections, is contained in a single disk file. The database file format is cross-platform, you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures. UnQLite features includes:\n\n\n    Serverless, NoSQL database engine.\n    Transactional (ACID) database.\n    Zero configuration.\n    Single database file, does not use temporary files.\n    Cross-platform file format.\n    UnQLite is a Self-Contained C library without dependency.\n    Standard Key/Value store.\n    Document store (JSON) database via Jx9.\n    Support cursors for linear records traversal.\n    Pluggable run-time interchangeable storage engine.\n    Support for on-disk as well in-memory databases.\n    Built with a powerful disk storage engine which support O(1) lookup.\n    Thread safe and full reentrant.\n    Simple, Clean and easy to use API.\n    Support Terabyte sized databases.\n    BSD licensed product.\n    Amalgamation: All C source code for UnQLite and Jx9 are combined into a single source file.\n\n\n\nUnQLite is a self-contained C library without dependency. It requires very minimal support from external libraries or from the operating system. This makes it well suited for use in embedded devices that lack the support infrastructure of a desktop computer. This also makes UnQLite appropriate for use within applications that need to run without modification on a wide variety of computers of varying configurations.\n\nUnQLite is written in ANSI C, Thread-safe, Full reentrant, compiles unmodified and should run in most platforms including restricted embedded devices with a C compiler. UnQLite is extensively tested on Windows and UNIX systems especially Linux, FreeBSD, Oracle Solaris and Mac OS X.\n\n\nhttps://unqlite.symisc.net\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "unqlite.c",
          "type": "blob",
          "size": 1909.5390625,
          "content": "/*\r\n * Symisc UnQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2022, Symisc Systems http://unqlite.org/\r\n * Version 1.1.9\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n/*\r\n * Copyright (C) 2012, 2022 Symisc Systems, S.U.A.R.L [M.I.A.G Mrad Chems Eddine <chm@symisc.net>].\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY SYMISC SYSTEMS ``AS IS'' AND ANY EXPRESS\r\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR\r\n * NON-INFRINGEMENT, ARE DISCLAIMED.  IN NO EVENT SHALL SYMISC SYSTEMS\r\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\r\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n /* $SymiscID: unqlite.c v1.1.9 Win10 2022-04-25 03:34:11 stable <chm@symisc.net>  $ */\r\n/* This file is an amalgamation of many separate C source files from unqlite version 1.1.9\r\n * By combining all the individual C code files into this single large file, the entire code\r\n * can be compiled as a single translation unit. This allows many compilers to do optimization's\r\n * that would not be possible if the files were compiled separately. Performance improvements\r\n * are commonly seen when unqlite is compiled as a single translation unit.\r\n *\r\n * This file is all you need to compile unqlite. To use unqlite in other programs, you need\r\n * this file and the \"unqlite.h\" header file that defines the programming interface to the \r\n * unqlite engine.(If you do not have the \"unqlite.h\" header file at hand, you will find\r\n * a copy embedded within the text of this file.Search for \"Header file: <unqlite.h>\" to find\r\n * the start of the embedded unqlite.h header file.) Additional code files may be needed if\r\n * you want a wrapper to interface unqlite with your choice of programming language.\r\n * To get the official documentation, please visit http://unqlite.org/\r\n */\r\n /*\r\n  * Make the sure the following directive is defined in the amalgamation build.\r\n  */\r\n #ifndef UNQLITE_AMALGAMATION\r\n #define UNQLITE_AMALGAMATION\r\n #define JX9_AMALGAMATION\r\n /* Marker for routines not intended for external use */\r\n #define JX9_PRIVATE static\r\n #endif /* UNQLITE_AMALGAMATION */\r\n/*\r\n * Embedded header file for unqlite: <unqlite.h>\r\n */\r\n/*\r\n * ----------------------------------------------------------\r\n * File: unqlite.h\r\n * ----------------------------------------------------------\r\n */\r\n/* This file was automatically generated.  Do not edit (Except for compile time directives)! */ \r\n#ifndef _UNQLITE_H_\r\n#define _UNQLITE_H_\r\n/*\r\n * Symisc UnQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2019, Symisc Systems http://unqlite.org/\r\n * Version 1.1.9\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n/*\r\n * Copyright (C) 2012, 2019 Symisc Systems, S.U.A.R.L [M.I.A.G Mrad Chems Eddine <chm@symisc.net>].\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY SYMISC SYSTEMS ``AS IS'' AND ANY EXPRESS\r\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR\r\n * NON-INFRINGEMENT, ARE DISCLAIMED.  IN NO EVENT SHALL SYMISC SYSTEMS\r\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\r\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n /* $SymiscID: unqlite.h v1.3 Win10 2108-04-27 02:35:11 stable <chm@symisc.net>  $ */\r\n#include <stdarg.h> /* needed for the definition of va_list */\r\n/*\r\n * Compile time engine version, signature, identification in the symisc source tree\r\n * and copyright notice.\r\n * Each macro have an equivalent C interface associated with it that provide the same\r\n * information but are associated with the library instead of the header file.\r\n * Refer to [unqlite_lib_version()], [unqlite_lib_signature()], [unqlite_lib_ident()] and\r\n * [unqlite_lib_copyright()] for more information.\r\n */\r\n/*\r\n * The UNQLITE_VERSION C preprocessor macroevaluates to a string literal\r\n * that is the unqlite version in the format \"X.Y.Z\" where X is the major\r\n * version number and Y is the minor version number and Z is the release\r\n * number.\r\n */\r\n#define UNQLITE_VERSION \"1.1.9\"\r\n/*\r\n * The UNQLITE_VERSION_NUMBER C preprocessor macro resolves to an integer\r\n * with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same\r\n * numbers used in [UNQLITE_VERSION].\r\n */\r\n#define UNQLITE_VERSION_NUMBER 1001009\r\n/*\r\n * The UNQLITE_SIG C preprocessor macro evaluates to a string\r\n * literal which is the public signature of the unqlite engine.\r\n * This signature could be included for example in a host-application\r\n * generated Server MIME header as follows:\r\n *   Server: YourWebServer/x.x unqlite/x.x.x \\r\\n\r\n */\r\n#define UNQLITE_SIG \"unqlite/1.1.9\"\r\n/*\r\n * UnQLite identification in the Symisc source tree:\r\n * Each particular check-in of a particular software released\r\n * by symisc systems have an unique identifier associated with it.\r\n * This macro hold the one associated with unqlite.\r\n */\r\n#define UNQLITE_IDENT \"unqlite:29c173b1-ac2c-4b49-93ba-e600619e304e\"\r\n/*\r\n * Copyright notice.\r\n * If you have any questions about the licensing situation, please\r\n * visit http://unqlite.org/licensing.html\r\n * or contact Symisc Systems via:\r\n *   legal@symisc.net\r\n *   licensing@symisc.net\r\n *   contact@symisc.net\r\n */\r\n#define UNQLITE_COPYRIGHT \"Copyright (C) Symisc Systems, S.U.A.R.L [Mrad Chems Eddine <chm@symisc.net>] 2012-2019, http://unqlite.org/\"\r\n/* Make sure we can call this stuff from C++ */\r\n#ifdef __cplusplus\r\nextern \"C\" { \r\n#endif\r\n/* Forward declaration to public objects */\r\ntypedef struct unqlite_io_methods unqlite_io_methods;\r\ntypedef struct unqlite_kv_methods unqlite_kv_methods;\r\ntypedef struct unqlite_kv_engine unqlite_kv_engine;\r\ntypedef struct jx9_io_stream unqlite_io_stream;\r\ntypedef struct jx9_context unqlite_context;\r\ntypedef struct jx9_value unqlite_value;\r\ntypedef struct unqlite_vfs unqlite_vfs;\r\ntypedef struct unqlite_vm unqlite_vm;\r\ntypedef struct unqlite unqlite;\r\n/*\r\n * ------------------------------\r\n * Compile time directives\r\n * ------------------------------\r\n * For most purposes, UnQLite can be built just fine using the default compilation options.\r\n * However, if required, the compile-time options documented below can be used to omit UnQLite\r\n * features (resulting in a smaller compiled library size) or to change the default values\r\n * of some parameters.\r\n * Every effort has been made to ensure that the various combinations of compilation options\r\n * work harmoniously and produce a working library.\r\n *\r\n * UNQLITE_ENABLE_THREADS\r\n *  This option controls whether or not code is included in UnQLite to enable it to operate\r\n *  safely in a multithreaded environment. The default is not. All mutexing code is omitted\r\n *  and it is unsafe to use UnQLite in a multithreaded program. When compiled with the\r\n *  UNQLITE_ENABLE_THREADS directive enabled, UnQLite can be used in a multithreaded program\r\n *  and it is safe to share the same virtual machine and engine handle between two or more threads.\r\n *  The value of UNQLITE_ENABLE_THREADS can be determined at run-time using the unqlite_lib_is_threadsafe()\r\n *  interface.\r\n *  When UnQLite has been compiled with threading support then the threading mode can be altered\r\n * at run-time using the unqlite_lib_config() interface together with one of these verbs:\r\n *    UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE\r\n *    UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI\r\n *  Platforms others than Windows and UNIX systems must install their own mutex subsystem via \r\n *  unqlite_lib_config() with a configuration verb set to UNQLITE_LIB_CONFIG_USER_MUTEX.\r\n *  Otherwise the library is not threadsafe.\r\n *  Note that you must link UnQLite with the POSIX threads library under UNIX systems (i.e: -lpthread).\r\n *\r\n * Options To Omit/Enable Features\r\n *\r\n * The following options can be used to reduce the size of the compiled library by omitting optional\r\n * features. This is probably only useful in embedded systems where space is especially tight, as even\r\n * with all features included the UnQLite library is relatively small. Don't forget to tell your\r\n * compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler\r\n * to optimize for size usually has a much larger impact on library footprint than employing\r\n * any of these compile-time options.\r\n *\r\n * JX9_DISABLE_BUILTIN_FUNC\r\n *  Jx9 is shipped with more than 312 built-in functions suitable for most purposes like \r\n *  string and INI processing, ZIP extracting, Base64 encoding/decoding, JSON encoding/decoding\r\n *  and so forth.\r\n *  If this directive is enabled, then all built-in Jx9 functions are omitted from the build.\r\n *  Note that special functions such as db_create(), db_store(), db_fetch(), etc. are not omitted\r\n *  from the build and are not affected by this directive.\r\n *\r\n * JX9_ENABLE_MATH_FUNC\r\n *  If this directive is enabled, built-in math functions such as sqrt(), abs(), log(), ceil(), etc.\r\n *  are included in the build. Note that you may need to link UnQLite with the math library in same\r\n *  Linux/BSD flavor (i.e: -lm).\r\n *\r\n * JX9_DISABLE_DISK_IO\r\n *  If this directive is enabled, built-in VFS functions such as chdir(), mkdir(), chroot(), unlink(),\r\n *  sleep(), etc. are omitted from the build.\r\n *\r\n * UNQLITE_ENABLE_JX9_HASH_IO\r\n * If this directive is enabled, built-in hash functions such as md5(), sha1(), md5_file(), crc32(), etc.\r\n * are included in the build.\r\n */\r\n/* Symisc public definitions */\r\n#if !defined(SYMISC_STANDARD_DEFS)\r\n#define SYMISC_STANDARD_DEFS\r\n#if defined (_WIN32) || defined (WIN32) || defined(__MINGW32__) || defined (_MSC_VER) || defined (_WIN32_WCE)\r\n/* Windows Systems */\r\n#if !defined(__WINNT__)\r\n#define __WINNT__\r\n#endif \r\n/*\r\n * Determine if we are dealing with WindowsCE - which has a much\r\n * reduced API.\r\n */\r\n#if defined(_WIN32_WCE)\r\n#ifndef __WIN_CE__\r\n#define __WIN_CE__\r\n#endif /* __WIN_CE__ */\r\n#endif /* _WIN32_WCE */\r\n#else\r\n/*\r\n * By default we will assume that we are compiling on a UNIX systems.\r\n * Otherwise the OS_OTHER directive must be defined.\r\n */\r\n#if !defined(OS_OTHER)\r\n#if !defined(__UNIXES__)\r\n#define __UNIXES__\r\n#endif /* __UNIXES__ */\r\n#else\r\n#endif /* OS_OTHER */\r\n#endif /* __WINNT__/__UNIXES__ */\r\n#if defined(_MSC_VER) || defined(__BORLANDC__)\r\ntypedef signed __int64     sxi64; /* 64 bits(8 bytes) signed int64 */\r\ntypedef unsigned __int64   sxu64; /* 64 bits(8 bytes) unsigned int64 */\r\n#else\r\ntypedef signed long long int   sxi64; /* 64 bits(8 bytes) signed int64 */\r\ntypedef unsigned long long int sxu64; /* 64 bits(8 bytes) unsigned int64 */\r\n#endif /* _MSC_VER */\r\n/* Signature of the consumer routine */\r\ntypedef int (*ProcConsumer)(const void *, unsigned int, void *);\r\n/* Forward reference */\r\ntypedef struct SyMutexMethods SyMutexMethods;\r\ntypedef struct SyMemMethods SyMemMethods;\r\ntypedef struct SyString SyString;\r\ntypedef struct syiovec syiovec;\r\ntypedef struct SyMutex SyMutex;\r\ntypedef struct Sytm Sytm;\r\n/* Scatter and gather array. */\r\nstruct syiovec\r\n{\r\n#if defined (__WINNT__)\r\n\t/* Same fields type and offset as WSABUF structure defined one winsock2 header */\r\n\tunsigned long nLen;\r\n\tchar *pBase;\r\n#else\r\n\tvoid *pBase;\r\n\tunsigned long nLen;\r\n#endif\r\n};\r\nstruct SyString\r\n{\r\n\tconst char *zString;  /* Raw string (may not be null terminated) */\r\n\tunsigned int nByte;   /* Raw string length */\r\n};\r\n/* Time structure. */\r\nstruct Sytm\r\n{\r\n  int tm_sec;     /* seconds (0 - 60) */\r\n  int tm_min;     /* minutes (0 - 59) */\r\n  int tm_hour;    /* hours (0 - 23) */\r\n  int tm_mday;    /* day of month (1 - 31) */\r\n  int tm_mon;     /* month of year (0 - 11) */\r\n  int tm_year;    /* year + 1900 */\r\n  int tm_wday;    /* day of week (Sunday = 0) */\r\n  int tm_yday;    /* day of year (0 - 365) */\r\n  int tm_isdst;   /* is summer time in effect? */\r\n  char *tm_zone;  /* abbreviation of timezone name */\r\n  long tm_gmtoff; /* offset from UTC in seconds */\r\n};\r\n/* Convert a tm structure (struct tm *) found in <time.h> to a Sytm structure */\r\n#define STRUCT_TM_TO_SYTM(pTM, pSYTM) \\\r\n\t(pSYTM)->tm_hour = (pTM)->tm_hour;\\\r\n\t(pSYTM)->tm_min\t = (pTM)->tm_min;\\\r\n\t(pSYTM)->tm_sec\t = (pTM)->tm_sec;\\\r\n\t(pSYTM)->tm_mon\t = (pTM)->tm_mon;\\\r\n\t(pSYTM)->tm_mday = (pTM)->tm_mday;\\\r\n\t(pSYTM)->tm_year = (pTM)->tm_year + 1900;\\\r\n\t(pSYTM)->tm_yday = (pTM)->tm_yday;\\\r\n\t(pSYTM)->tm_wday = (pTM)->tm_wday;\\\r\n\t(pSYTM)->tm_isdst = (pTM)->tm_isdst;\\\r\n\t(pSYTM)->tm_gmtoff = 0;\\\r\n\t(pSYTM)->tm_zone = 0;\r\n\r\n/* Convert a SYSTEMTIME structure (LPSYSTEMTIME: Windows Systems only ) to a Sytm structure */\r\n#define SYSTEMTIME_TO_SYTM(pSYSTIME, pSYTM) \\\r\n\t (pSYTM)->tm_hour = (pSYSTIME)->wHour;\\\r\n\t (pSYTM)->tm_min  = (pSYSTIME)->wMinute;\\\r\n\t (pSYTM)->tm_sec  = (pSYSTIME)->wSecond;\\\r\n\t (pSYTM)->tm_mon  = (pSYSTIME)->wMonth - 1;\\\r\n\t (pSYTM)->tm_mday = (pSYSTIME)->wDay;\\\r\n\t (pSYTM)->tm_year = (pSYSTIME)->wYear;\\\r\n\t (pSYTM)->tm_yday = 0;\\\r\n\t (pSYTM)->tm_wday = (pSYSTIME)->wDayOfWeek;\\\r\n\t (pSYTM)->tm_gmtoff = 0;\\\r\n\t (pSYTM)->tm_isdst = -1;\\\r\n\t (pSYTM)->tm_zone = 0;\r\n\r\n/* Dynamic memory allocation methods. */\r\nstruct SyMemMethods \r\n{\r\n\tvoid * (*xAlloc)(unsigned int);          /* [Required:] Allocate a memory chunk */\r\n\tvoid * (*xRealloc)(void *, unsigned int); /* [Required:] Re-allocate a memory chunk */\r\n\tvoid   (*xFree)(void *);                 /* [Required:] Release a memory chunk */\r\n\tunsigned int  (*xChunkSize)(void *);     /* [Optional:] Return chunk size */\r\n\tint    (*xInit)(void *);                 /* [Optional:] Initialization callback */\r\n\tvoid   (*xRelease)(void *);              /* [Optional:] Release callback */\r\n\tvoid  *pUserData;                        /* [Optional:] First argument to xInit() and xRelease() */\r\n};\r\n/* Out of memory callback signature. */\r\ntypedef int (*ProcMemError)(void *);\r\n/* Mutex methods. */\r\nstruct SyMutexMethods \r\n{\r\n\tint (*xGlobalInit)(void);\t\t/* [Optional:] Global mutex initialization */\r\n\tvoid  (*xGlobalRelease)(void);\t/* [Optional:] Global Release callback () */\r\n\tSyMutex * (*xNew)(int);\t        /* [Required:] Request a new mutex */\r\n\tvoid  (*xRelease)(SyMutex *);\t/* [Optional:] Release a mutex  */\r\n\tvoid  (*xEnter)(SyMutex *);\t    /* [Required:] Enter mutex */\r\n\tint (*xTryEnter)(SyMutex *);    /* [Optional:] Try to enter a mutex */\r\n\tvoid  (*xLeave)(SyMutex *);\t    /* [Required:] Leave a locked mutex */\r\n};\r\n#if defined (_MSC_VER) || defined (__MINGW32__) ||  defined (__GNUC__) && defined (__declspec)\r\n#define SX_APIIMPORT\t__declspec(dllimport)\r\n#define SX_APIEXPORT\t__declspec(dllexport)\r\n#else\r\n#define\tSX_APIIMPORT\r\n#define\tSX_APIEXPORT\r\n#endif\r\n/* Standard return values from Symisc public interfaces */\r\n#define SXRET_OK       0      /* Not an error */\t\r\n#define SXERR_MEM      (-1)   /* Out of memory */\r\n#define SXERR_IO       (-2)   /* IO error */\r\n#define SXERR_EMPTY    (-3)   /* Empty field */\r\n#define SXERR_LOCKED   (-4)   /* Locked operation */\r\n#define SXERR_ORANGE   (-5)   /* Out of range value */\r\n#define SXERR_NOTFOUND (-6)   /* Item not found */\r\n#define SXERR_LIMIT    (-7)   /* Limit reached */\r\n#define SXERR_MORE     (-8)   /* Need more input */\r\n#define SXERR_INVALID  (-9)   /* Invalid parameter */\r\n#define SXERR_ABORT    (-10)  /* User callback request an operation abort */\r\n#define SXERR_EXISTS   (-11)  /* Item exists */\r\n#define SXERR_SYNTAX   (-12)  /* Syntax error */\r\n#define SXERR_UNKNOWN  (-13)  /* Unknown error */\r\n#define SXERR_BUSY     (-14)  /* Busy operation */\r\n#define SXERR_OVERFLOW (-15)  /* Stack or buffer overflow */\r\n#define SXERR_WILLBLOCK (-16) /* Operation will block */\r\n#define SXERR_NOTIMPLEMENTED  (-17) /* Operation not implemented */\r\n#define SXERR_EOF      (-18) /* End of input */\r\n#define SXERR_PERM     (-19) /* Permission error */\r\n#define SXERR_NOOP     (-20) /* No-op */\t\r\n#define SXERR_FORMAT   (-21) /* Invalid format */\r\n#define SXERR_NEXT     (-22) /* Not an error */\r\n#define SXERR_OS       (-23) /* System call return an error */\r\n#define SXERR_CORRUPT  (-24) /* Corrupted pointer */\r\n#define SXERR_CONTINUE (-25) /* Not an error: Operation in progress */\r\n#define SXERR_NOMATCH  (-26) /* No match */\r\n#define SXERR_RESET    (-27) /* Operation reset */\r\n#define SXERR_DONE     (-28) /* Not an error */\r\n#define SXERR_SHORT    (-29) /* Buffer too short */\r\n#define SXERR_PATH     (-30) /* Path error */\r\n#define SXERR_TIMEOUT  (-31) /* Timeout */\r\n#define SXERR_BIG      (-32) /* Too big for processing */\r\n#define SXERR_RETRY    (-33) /* Retry your call */\r\n#define SXERR_IGNORE   (-63) /* Ignore */\r\n#endif /* SYMISC_PUBLIC_DEFS */\r\n/* \r\n * Marker for exported interfaces. \r\n */\r\n#define UNQLITE_APIEXPORT SX_APIEXPORT\r\n/*\r\n * If compiling for a processor that lacks floating point\r\n * support, substitute integer for floating-point.\r\n */\r\n#ifdef UNQLITE_OMIT_FLOATING_POINT\r\ntypedef sxi64 uqlite_real;\r\n#else\r\ntypedef double unqlite_real;\r\n#endif\r\ntypedef sxi64 unqlite_int64;\r\n/* Standard UnQLite return values */\r\n#define UNQLITE_OK      SXRET_OK      /* Successful result */\r\n/* Beginning of error codes */\r\n#define UNQLITE_NOMEM    SXERR_MEM     /* Out of memory */\r\n#define UNQLITE_ABORT    SXERR_ABORT   /* Another thread have released this instance */\r\n#define UNQLITE_IOERR    SXERR_IO      /* IO error */\r\n#define UNQLITE_CORRUPT  SXERR_CORRUPT /* Corrupt pointer */\r\n#define UNQLITE_LOCKED   SXERR_LOCKED  /* Forbidden Operation */ \r\n#define UNQLITE_BUSY\t SXERR_BUSY    /* The database file is locked */\r\n#define UNQLITE_DONE\t SXERR_DONE    /* Operation done */\r\n#define UNQLITE_PERM     SXERR_PERM    /* Permission error */\r\n#define UNQLITE_NOTIMPLEMENTED SXERR_NOTIMPLEMENTED /* Method not implemented by the underlying Key/Value storage engine */\r\n#define UNQLITE_NOTFOUND SXERR_NOTFOUND /* No such record */\r\n#define UNQLITE_NOOP     SXERR_NOOP     /* No such method */\r\n#define UNQLITE_INVALID  SXERR_INVALID  /* Invalid parameter */\r\n#define UNQLITE_EOF      SXERR_EOF      /* End Of Input */\r\n#define UNQLITE_UNKNOWN  SXERR_UNKNOWN  /* Unknown configuration option */\r\n#define UNQLITE_LIMIT    SXERR_LIMIT    /* Database limit reached */\r\n#define UNQLITE_EXISTS   SXERR_EXISTS   /* Record exists */\r\n#define UNQLITE_EMPTY    SXERR_EMPTY    /* Empty record */\r\n#define UNQLITE_COMPILE_ERR (-70)       /* Compilation error */\r\n#define UNQLITE_VM_ERR      (-71)       /* Virtual machine error */\r\n#define UNQLITE_FULL        (-73)       /* Full database (unlikely) */\r\n#define UNQLITE_CANTOPEN    (-74)       /* Unable to open the database file */\r\n#define UNQLITE_READ_ONLY   (-75)       /* Read only Key/Value storage engine */\r\n#define UNQLITE_LOCKERR     (-76)       /* Locking protocol error */\r\n/* end-of-error-codes */\r\n/*\r\n * Database Handle Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure an UnQLite database handle.\r\n * These constants must be passed as the second argument to [unqlite_config()].\r\n *\r\n * Each options require a variable number of arguments.\r\n * The [unqlite_config()] interface will return UNQLITE_OK on success, any other\r\n * return value indicates failure.\r\n * For a full discussion on the configuration verbs and their expected \r\n * parameters, please refer to this page:\r\n *      http://unqlite.org/c_api/unqlite_config.html\r\n */\r\n#define UNQLITE_CONFIG_JX9_ERR_LOG         1  /* TWO ARGUMENTS: const char **pzBuf, int *pLen */\r\n#define UNQLITE_CONFIG_MAX_PAGE_CACHE      2  /* ONE ARGUMENT: int nMaxPage */\r\n#define UNQLITE_CONFIG_ERR_LOG             3  /* TWO ARGUMENTS: const char **pzBuf, int *pLen */\r\n#define UNQLITE_CONFIG_KV_ENGINE           4  /* ONE ARGUMENT: const char *zKvName */\r\n#define UNQLITE_CONFIG_DISABLE_AUTO_COMMIT 5  /* NO ARGUMENTS */\r\n#define UNQLITE_CONFIG_GET_KV_NAME         6  /* ONE ARGUMENT: const char **pzPtr */\r\n/*\r\n * UnQLite/Jx9 Virtual Machine Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the Jx9 (Via UnQLite) Virtual machine.\r\n * These constants must be passed as the second argument to the [unqlite_vm_config()] \r\n * interface.\r\n * Each options require a variable number of arguments.\r\n * The [unqlite_vm_config()] interface will return UNQLITE_OK on success, any other return\r\n * value indicates failure.\r\n * There are many options but the most important are: UNQLITE_VM_CONFIG_OUTPUT which install\r\n * a VM output consumer callback, UNQLITE_VM_CONFIG_HTTP_REQUEST which parse and register\r\n * a HTTP request and UNQLITE_VM_CONFIG_ARGV_ENTRY which populate the $argv array.\r\n * For a full discussion on the configuration verbs and their expected parameters, please\r\n * refer to this page:\r\n *      http://unqlite.org/c_api/unqlite_vm_config.html\r\n */\r\n#define UNQLITE_VM_CONFIG_OUTPUT           1  /* TWO ARGUMENTS: int (*xConsumer)(const void *pOut, unsigned int nLen, void *pUserData), void *pUserData */\r\n#define UNQLITE_VM_CONFIG_IMPORT_PATH      2  /* ONE ARGUMENT: const char *zIncludePath */\r\n#define UNQLITE_VM_CONFIG_ERR_REPORT       3  /* NO ARGUMENTS: Report all run-time errors in the VM output */\r\n#define UNQLITE_VM_CONFIG_RECURSION_DEPTH  4  /* ONE ARGUMENT: int nMaxDepth */\r\n#define UNQLITE_VM_OUTPUT_LENGTH           5  /* ONE ARGUMENT: unsigned int *pLength */\r\n#define UNQLITE_VM_CONFIG_CREATE_VAR       6  /* TWO ARGUMENTS: const char *zName, unqlite_value *pValue */\r\n#define UNQLITE_VM_CONFIG_HTTP_REQUEST     7  /* TWO ARGUMENTS: const char *zRawRequest, int nRequestLength */\r\n#define UNQLITE_VM_CONFIG_SERVER_ATTR      8  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\r\n#define UNQLITE_VM_CONFIG_ENV_ATTR         9  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\r\n#define UNQLITE_VM_CONFIG_EXEC_VALUE      10  /* ONE ARGUMENT: unqlite_value **ppValue */\r\n#define UNQLITE_VM_CONFIG_IO_STREAM       11  /* ONE ARGUMENT: const unqlite_io_stream *pStream */\r\n#define UNQLITE_VM_CONFIG_ARGV_ENTRY      12  /* ONE ARGUMENT: const char *zValue */\r\n#define UNQLITE_VM_CONFIG_EXTRACT_OUTPUT  13  /* TWO ARGUMENTS: const void **ppOut, unsigned int *pOutputLen */\r\n/*\r\n * Storage engine configuration commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the underlying storage engine (i.e Hash, B+tree, R+tree).\r\n * These constants must be passed as the first argument to [unqlite_kv_config()].\r\n * Each options require a variable number of arguments.\r\n * The [unqlite_kv_config()] interface will return UNQLITE_OK on success, any other return\r\n * value indicates failure.\r\n * For a full discussion on the configuration verbs and their expected parameters, please\r\n * refer to this page:\r\n *      http://unqlite.org/c_api/unqlite_kv_config.html\r\n */\r\n#define UNQLITE_KV_CONFIG_HASH_FUNC  1 /* ONE ARGUMENT: unsigned int (*xHash)(const void *,unsigned int) */\r\n#define UNQLITE_KV_CONFIG_CMP_FUNC   2 /* ONE ARGUMENT: int (*xCmp)(const void *,const void *,unsigned int) */\r\n/*\r\n * Global Library Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the whole library.\r\n * These constants must be passed as the first argument to [unqlite_lib_config()].\r\n *\r\n * Each options require a variable number of arguments.\r\n * The [unqlite_lib_config()] interface will return UNQLITE_OK on success, any other return\r\n * value indicates failure.\r\n * Notes:\r\n * The default configuration is recommended for most applications and so the call to\r\n * [unqlite_lib_config()] is usually not necessary. It is provided to support rare \r\n * applications with unusual needs. \r\n * The [unqlite_lib_config()] interface is not threadsafe. The application must insure that\r\n * no other [unqlite_*()] interfaces are invoked by other threads while [unqlite_lib_config()]\r\n * is running. Furthermore, [unqlite_lib_config()] may only be invoked prior to library\r\n * initialization using [unqlite_lib_init()] or [unqlite_init()] or after shutdown\r\n * by [unqlite_lib_shutdown()]. If [unqlite_lib_config()] is called after [unqlite_lib_init()]\r\n * or [unqlite_init()] and before [unqlite_lib_shutdown()] then it will return UNQLITE_LOCKED.\r\n * For a full discussion on the configuration verbs and their expected parameters, please\r\n * refer to this page:\r\n *      http://unqlite.org/c_api/unqlite_lib.html\r\n */\r\n#define UNQLITE_LIB_CONFIG_USER_MALLOC            1 /* ONE ARGUMENT: const SyMemMethods *pMemMethods */ \r\n#define UNQLITE_LIB_CONFIG_MEM_ERR_CALLBACK       2 /* TWO ARGUMENTS: int (*xMemError)(void *), void *pUserData */\r\n#define UNQLITE_LIB_CONFIG_USER_MUTEX             3 /* ONE ARGUMENT: const SyMutexMethods *pMutexMethods */ \r\n#define UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE    4 /* NO ARGUMENTS */ \r\n#define UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI     5 /* NO ARGUMENTS */ \r\n#define UNQLITE_LIB_CONFIG_VFS                    6 /* ONE ARGUMENT: const unqlite_vfs *pVfs */\r\n#define UNQLITE_LIB_CONFIG_STORAGE_ENGINE         7 /* ONE ARGUMENT: unqlite_kv_methods *pStorage */\r\n#define UNQLITE_LIB_CONFIG_PAGE_SIZE              8 /* ONE ARGUMENT: int iPageSize */\r\n/*\r\n * These bit values are intended for use in the 3rd parameter to the [unqlite_open()] interface\r\n * and in the 4th parameter to the xOpen method of the [unqlite_vfs] object.\r\n */\r\n#define UNQLITE_OPEN_READONLY         0x00000001  /* Read only mode. Ok for [unqlite_open] */\r\n#define UNQLITE_OPEN_READWRITE        0x00000002  /* Ok for [unqlite_open] */\r\n#define UNQLITE_OPEN_CREATE           0x00000004  /* Ok for [unqlite_open] */\r\n#define UNQLITE_OPEN_EXCLUSIVE        0x00000008  /* VFS only */\r\n#define UNQLITE_OPEN_TEMP_DB          0x00000010  /* VFS only */\r\n#define UNQLITE_OPEN_NOMUTEX          0x00000020  /* Ok for [unqlite_open] */\r\n#define UNQLITE_OPEN_OMIT_JOURNALING  0x00000040  /* Omit journaling for this database. Ok for [unqlite_open] */\r\n#define UNQLITE_OPEN_IN_MEMORY        0x00000080  /* An in memory database. Ok for [unqlite_open]*/\r\n#define UNQLITE_OPEN_MMAP             0x00000100  /* Obtain a memory view of the whole file. Ok for [unqlite_open] */\r\n/*\r\n * Synchronization Type Flags\r\n *\r\n * When UnQLite invokes the xSync() method of an [unqlite_io_methods] object it uses\r\n * a combination of these integer values as the second argument.\r\n *\r\n * When the UNQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only\r\n * needs to flush data to mass storage.  Inode information need not be flushed.\r\n * If the lower four bits of the flag equal UNQLITE_SYNC_NORMAL, that means to use normal\r\n * fsync() semantics. If the lower four bits equal UNQLITE_SYNC_FULL, that means to use\r\n * Mac OS X style fullsync instead of fsync().\r\n */\r\n#define UNQLITE_SYNC_NORMAL        0x00002\r\n#define UNQLITE_SYNC_FULL          0x00003\r\n#define UNQLITE_SYNC_DATAONLY      0x00010\r\n/*\r\n * File Locking Levels\r\n *\r\n * UnQLite uses one of these integer values as the second\r\n * argument to calls it makes to the xLock() and xUnlock() methods\r\n * of an [unqlite_io_methods] object.\r\n */\r\n#define UNQLITE_LOCK_NONE          0\r\n#define UNQLITE_LOCK_SHARED        1\r\n#define UNQLITE_LOCK_RESERVED      2\r\n#define UNQLITE_LOCK_PENDING       3\r\n#define UNQLITE_LOCK_EXCLUSIVE     4\r\n/*\r\n * CAPIREF: OS Interface: Open File Handle\r\n *\r\n * An [unqlite_file] object represents an open file in the [unqlite_vfs] OS interface\r\n * layer.\r\n * Individual OS interface implementations will want to subclass this object by appending\r\n * additional fields for their own use. The pMethods entry is a pointer to an\r\n * [unqlite_io_methods] object that defines methods for performing\r\n * I/O operations on the open file.\r\n*/\r\ntypedef struct unqlite_file unqlite_file;\r\nstruct unqlite_file {\r\n  const unqlite_io_methods *pMethods;  /* Methods for an open file. MUST BE FIRST */\r\n};\r\n/*\r\n * CAPIREF: OS Interface: File Methods Object\r\n *\r\n * Every file opened by the [unqlite_vfs] xOpen method populates an\r\n * [unqlite_file] object (or, more commonly, a subclass of the\r\n * [unqlite_file] object) with a pointer to an instance of this object.\r\n * This object defines the methods used to perform various operations\r\n * against the open file represented by the [unqlite_file] object.\r\n *\r\n * If the xOpen method sets the unqlite_file.pMethods element \r\n * to a non-NULL pointer, then the unqlite_io_methods.xClose method\r\n * may be invoked even if the xOpen reported that it failed.  The\r\n * only way to prevent a call to xClose following a failed xOpen\r\n * is for the xOpen to set the unqlite_file.pMethods element to NULL.\r\n *\r\n * The flags argument to xSync may be one of [UNQLITE_SYNC_NORMAL] or\r\n * [UNQLITE_SYNC_FULL]. The first choice is the normal fsync().\r\n * The second choice is a Mac OS X style fullsync. The [UNQLITE_SYNC_DATAONLY]\r\n * flag may be ORed in to indicate that only the data of the file\r\n * and not its inode needs to be synced.\r\n *\r\n * The integer values to xLock() and xUnlock() are one of\r\n *\r\n * UNQLITE_LOCK_NONE\r\n * UNQLITE_LOCK_SHARED\r\n * UNQLITE_LOCK_RESERVED\r\n * UNQLITE_LOCK_PENDING\r\n * UNQLITE_LOCK_EXCLUSIVE\r\n * \r\n * xLock() increases the lock. xUnlock() decreases the lock.\r\n * The xCheckReservedLock() method checks whether any database connection,\r\n * either in this process or in some other process, is holding a RESERVED,\r\n * PENDING, or EXCLUSIVE lock on the file. It returns true if such a lock exists\r\n * and false otherwise.\r\n * \r\n * The xSectorSize() method returns the sector size of the device that underlies\r\n * the file. The sector size is the minimum write that can be performed without\r\n * disturbing other bytes in the file.\r\n *\r\n */\r\nstruct unqlite_io_methods {\r\n  int iVersion;                 /* Structure version number (currently 1) */\r\n  int (*xClose)(unqlite_file*);\r\n  int (*xRead)(unqlite_file*, void*, unqlite_int64 iAmt, unqlite_int64 iOfst);\r\n  int (*xWrite)(unqlite_file*, const void*, unqlite_int64 iAmt, unqlite_int64 iOfst);\r\n  int (*xTruncate)(unqlite_file*, unqlite_int64 size);\r\n  int (*xSync)(unqlite_file*, int flags);\r\n  int (*xFileSize)(unqlite_file*, unqlite_int64 *pSize);\r\n  int (*xLock)(unqlite_file*, int);\r\n  int (*xUnlock)(unqlite_file*, int);\r\n  int (*xCheckReservedLock)(unqlite_file*, int *pResOut);\r\n  int (*xSectorSize)(unqlite_file*);\r\n};\r\n/*\r\n * CAPIREF: OS Interface Object\r\n *\r\n * An instance of the unqlite_vfs object defines the interface between\r\n * the UnQLite core and the underlying operating system.  The \"vfs\"\r\n * in the name of the object stands for \"Virtual File System\".\r\n *\r\n * Only a single vfs can be registered within the UnQLite core.\r\n * Vfs registration is done using the [unqlite_lib_config()] interface\r\n * with a configuration verb set to UNQLITE_LIB_CONFIG_VFS.\r\n * Note that Windows and UNIX (Linux, FreeBSD, Solaris, Mac OS X, etc.) users\r\n * does not have to worry about registering and installing a vfs since UnQLite\r\n * come with a built-in vfs for these platforms that implements most the methods\r\n * defined below.\r\n *\r\n * Clients running on exotic systems (ie: Other than Windows and UNIX systems)\r\n * must register their own vfs in order to be able to use the UnQLite library.\r\n *\r\n * The value of the iVersion field is initially 1 but may be larger in\r\n * future versions of UnQLite. \r\n *\r\n * The szOsFile field is the size of the subclassed [unqlite_file] structure\r\n * used by this VFS. mxPathname is the maximum length of a pathname in this VFS.\r\n * \r\n * At least szOsFile bytes of memory are allocated by UnQLite to hold the [unqlite_file]\r\n * structure passed as the third argument to xOpen. The xOpen method does not have to\r\n * allocate the structure; it should just fill it in. Note that the xOpen method must\r\n * set the unqlite_file.pMethods to either a valid [unqlite_io_methods] object or to NULL.\r\n * xOpen must do this even if the open fails. UnQLite expects that the unqlite_file.pMethods\r\n * element will be valid after xOpen returns regardless of the success or failure of the\r\n * xOpen call.\r\n *\r\n */\r\nstruct unqlite_vfs {\r\n  const char *zName;       /* Name of this virtual file system [i.e: Windows, UNIX, etc.] */\r\n  int iVersion;            /* Structure version number (currently 1) */\r\n  int szOsFile;            /* Size of subclassed unqlite_file */\r\n  int mxPathname;          /* Maximum file pathname length */\r\n  int (*xOpen)(unqlite_vfs*, const char *zName, unqlite_file*,unsigned int flags);\r\n  int (*xDelete)(unqlite_vfs*, const char *zName, int syncDir);\r\n  int (*xAccess)(unqlite_vfs*, const char *zName, int flags, int *pResOut);\r\n  int (*xFullPathname)(unqlite_vfs*, const char *zName,int buf_len,char *zBuf);\r\n  int (*xTmpDir)(unqlite_vfs*,char *zBuf,int buf_len);\r\n  int (*xSleep)(unqlite_vfs*, int microseconds);\r\n  int (*xCurrentTime)(unqlite_vfs*,Sytm *pOut);\r\n  int (*xGetLastError)(unqlite_vfs*, int, char *);\r\n};\r\n/*\r\n * Flags for the xAccess VFS method\r\n *\r\n * These integer constants can be used as the third parameter to\r\n * the xAccess method of an [unqlite_vfs] object.  They determine\r\n * what kind of permissions the xAccess method is looking for.\r\n * With UNQLITE_ACCESS_EXISTS, the xAccess method\r\n * simply checks whether the file exists.\r\n * With UNQLITE_ACCESS_READWRITE, the xAccess method\r\n * checks whether the named directory is both readable and writable\r\n * (in other words, if files can be added, removed, and renamed within\r\n * the directory).\r\n * The UNQLITE_ACCESS_READWRITE constant is currently used only by the\r\n * [temp_store_directory pragma], though this could change in a future\r\n * release of UnQLite.\r\n * With UNQLITE_ACCESS_READ, the xAccess method\r\n * checks whether the file is readable.  The UNQLITE_ACCESS_READ constant is\r\n * currently unused, though it might be used in a future release of\r\n * UnQLite.\r\n */\r\n#define UNQLITE_ACCESS_EXISTS    0\r\n#define UNQLITE_ACCESS_READWRITE 1   \r\n#define UNQLITE_ACCESS_READ      2 \r\n/*\r\n * The type used to represent a page number.  The first page in a file\r\n * is called page 1.  0 is used to represent \"not a page\".\r\n * A page number is an unsigned 64-bit integer.\r\n */\r\ntypedef sxu64 pgno;\r\n/*\r\n * A database disk page is represented by an instance\r\n * of the follwoing structure.\r\n */\r\ntypedef struct unqlite_page unqlite_page;\r\nstruct unqlite_page\r\n{\r\n  unsigned char *zData;       /* Content of this page */\r\n  void *pUserData;            /* Extra content */\r\n  pgno iPage;                 /* Page number for this page */\r\n};\r\n/*\r\n * UnQLite handle to the underlying Key/Value Storage Engine (See below).\r\n */\r\ntypedef void * unqlite_kv_handle;\r\n/*\r\n * UnQLite pager IO methods.\r\n *\r\n * An instance of the following structure define the exported methods of the UnQLite pager\r\n * to the underlying Key/Value storage engine.\r\n */\r\ntypedef struct unqlite_kv_io unqlite_kv_io;\r\nstruct unqlite_kv_io\r\n{\r\n\tunqlite_kv_handle  pHandle;     /* UnQLite handle passed as the first parameter to the\r\n\t\t\t\t\t\t\t\t\t * method defined below.\r\n\t\t\t\t\t\t\t\t\t */\r\n\tunqlite_kv_methods *pMethods;   /* Underlying storage engine */\r\n\t/* Pager methods */\r\n\tint (*xGet)(unqlite_kv_handle,pgno,unqlite_page **);\r\n\tint (*xLookup)(unqlite_kv_handle,pgno,unqlite_page **);\r\n\tint (*xNew)(unqlite_kv_handle,unqlite_page **);\r\n\tint (*xWrite)(unqlite_page *);\r\n\tint (*xDontWrite)(unqlite_page *);\r\n\tint (*xDontJournal)(unqlite_page *);\r\n\tint (*xDontMkHot)(unqlite_page *);\r\n\tint (*xPageRef)(unqlite_page *);\r\n\tint (*xPageUnref)(unqlite_page *);\r\n\tint (*xPageSize)(unqlite_kv_handle);\r\n\tint (*xReadOnly)(unqlite_kv_handle);\r\n\tunsigned char * (*xTmpPage)(unqlite_kv_handle);\r\n\tvoid (*xSetUnpin)(unqlite_kv_handle,void (*xPageUnpin)(void *)); \r\n\tvoid (*xSetReload)(unqlite_kv_handle,void (*xPageReload)(void *));\r\n\tvoid (*xErr)(unqlite_kv_handle,const char *);\r\n};\r\n/*\r\n * Key/Value Storage Engine Cursor Object\r\n *\r\n * An instance of a subclass of the following object defines a cursor\r\n * used to scan through a key-value storage engine.\r\n */\r\ntypedef struct unqlite_kv_cursor unqlite_kv_cursor;\r\nstruct unqlite_kv_cursor\r\n{\r\n  unqlite_kv_engine *pStore; /* Must be first */\r\n  /* Subclasses will typically add additional fields */\r\n};\r\n/*\r\n * Possible seek positions.\r\n */\r\n#define UNQLITE_CURSOR_MATCH_EXACT  1\r\n#define UNQLITE_CURSOR_MATCH_LE     2\r\n#define UNQLITE_CURSOR_MATCH_GE     3\r\n/*\r\n * Key/Value Storage Engine.\r\n *\r\n * A Key-Value storage engine is defined by an instance of the following\r\n * object.\r\n * UnQLite works with run-time interchangeable storage engines (i.e. Hash, B+Tree, R+Tree, LSM, etc.).\r\n * The storage engine works with key/value pairs where both the key\r\n * and the value are byte arrays of arbitrary length and with no restrictions on content.\r\n * UnQLite come with two built-in KV storage engine: A Virtual Linear Hash (VLH) storage\r\n * engine is used for persistent on-disk databases with O(1) lookup time and an in-memory\r\n * hash-table or Red-black tree storage engine is used for in-memory databases.\r\n * Future versions of UnQLite might add other built-in storage engines (i.e. LSM). \r\n * Registration of a Key/Value storage engine at run-time is done via [unqlite_lib_config()]\r\n * with a configuration verb set to UNQLITE_LIB_CONFIG_STORAGE_ENGINE.\r\n */\r\nstruct unqlite_kv_engine\r\n{\r\n  const unqlite_kv_io *pIo; /* IO methods: MUST be first */\r\n   /* Subclasses will typically add additional fields */\r\n};\r\n/*\r\n * Key/Value Storage Engine Virtual Method Table.\r\n *\r\n * Key/Value storage engine methods is defined by an instance of the following\r\n * object.\r\n * Registration of a Key/Value storage engine at run-time is done via [unqlite_lib_config()]\r\n * with a configuration verb set to UNQLITE_LIB_CONFIG_STORAGE_ENGINE.\r\n */\r\nstruct unqlite_kv_methods\r\n{\r\n  const char *zName; /* Storage engine name [i.e. Hash, B+tree, LSM, R-tree, Mem, etc.]*/\r\n  int szKv;          /* 'unqlite_kv_engine' subclass size */\r\n  int szCursor;      /* 'unqlite_kv_cursor' subclass size */\r\n  int iVersion;      /* Structure version, currently 1 */\r\n  /* Storage engine methods */\r\n  int (*xInit)(unqlite_kv_engine *,int iPageSize);\r\n  void (*xRelease)(unqlite_kv_engine *);\r\n  int (*xConfig)(unqlite_kv_engine *,int op,va_list ap);\r\n  int (*xOpen)(unqlite_kv_engine *,pgno);\r\n  int (*xReplace)(\r\n\t  unqlite_kv_engine *,\r\n\t  const void *pKey,int nKeyLen,\r\n\t  const void *pData,unqlite_int64 nDataLen\r\n\t  ); \r\n    int (*xAppend)(\r\n\t  unqlite_kv_engine *,\r\n\t  const void *pKey,int nKeyLen,\r\n\t  const void *pData,unqlite_int64 nDataLen\r\n\t  );\r\n  void (*xCursorInit)(unqlite_kv_cursor *);\r\n  int (*xSeek)(unqlite_kv_cursor *,const void *pKey,int nByte,int iPos); /* Mandatory */\r\n  int (*xFirst)(unqlite_kv_cursor *);\r\n  int (*xLast)(unqlite_kv_cursor *);\r\n  int (*xValid)(unqlite_kv_cursor *);\r\n  int (*xNext)(unqlite_kv_cursor *);\r\n  int (*xPrev)(unqlite_kv_cursor *);\r\n  int (*xDelete)(unqlite_kv_cursor *);\r\n  int (*xKeyLength)(unqlite_kv_cursor *,int *);\r\n  int (*xKey)(unqlite_kv_cursor *,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\r\n  int (*xDataLength)(unqlite_kv_cursor *,unqlite_int64 *);\r\n  int (*xData)(unqlite_kv_cursor *,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\r\n  void (*xReset)(unqlite_kv_cursor *);\r\n  void (*xCursorRelease)(unqlite_kv_cursor *);\r\n};\r\n/*\r\n * UnQLite journal file suffix.\r\n */\r\n#ifndef UNQLITE_JOURNAL_FILE_SUFFIX\r\n#define UNQLITE_JOURNAL_FILE_SUFFIX \"_unqlite_journal\"\r\n#endif\r\n/*\r\n * Call Context - Error Message Serverity Level.\r\n *\r\n * The following constans are the allowed severity level that can\r\n * passed as the second argument to the [unqlite_context_throw_error()] or\r\n * [unqlite_context_throw_error_format()] interfaces.\r\n * Refer to the official documentation for additional information.\r\n */\r\n#define UNQLITE_CTX_ERR       1 /* Call context error such as unexpected number of arguments, invalid types and so on. */\r\n#define UNQLITE_CTX_WARNING   2 /* Call context Warning */\r\n#define UNQLITE_CTX_NOTICE    3 /* Call context Notice */\r\n/* \r\n * C-API-REF: Please refer to the official documentation for interfaces\r\n * purpose and expected parameters. \r\n */ \r\n\r\n/* Database Engine Handle */\r\nUNQLITE_APIEXPORT int unqlite_open(unqlite **ppDB,const char *zFilename,unsigned int iMode);\r\nUNQLITE_APIEXPORT int unqlite_config(unqlite *pDb,int nOp,...);\r\nUNQLITE_APIEXPORT int unqlite_close(unqlite *pDb);\r\n\r\n/* Key/Value (KV) Store Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_kv_store(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen);\r\nUNQLITE_APIEXPORT int unqlite_kv_append(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen);\r\nUNQLITE_APIEXPORT int unqlite_kv_store_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...);\r\nUNQLITE_APIEXPORT int unqlite_kv_append_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...);\r\nUNQLITE_APIEXPORT int unqlite_kv_fetch(unqlite *pDb,const void *pKey,int nKeyLen,void *pBuf,unqlite_int64 /* in|out */*pBufLen);\r\nUNQLITE_APIEXPORT int unqlite_kv_fetch_callback(unqlite *pDb,const void *pKey,\r\n\t                    int nKeyLen,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_kv_delete(unqlite *pDb,const void *pKey,int nKeyLen);\r\nUNQLITE_APIEXPORT int unqlite_kv_config(unqlite *pDb,int iOp,...);\r\n\r\n/* Document (JSON) Store Interfaces powered by the Jx9 Scripting Language */\r\nUNQLITE_APIEXPORT int unqlite_compile(unqlite *pDb,const char *zJx9,int nByte,unqlite_vm **ppOut);\r\nUNQLITE_APIEXPORT int unqlite_compile_file(unqlite *pDb,const char *zPath,unqlite_vm **ppOut);\r\nUNQLITE_APIEXPORT int unqlite_vm_config(unqlite_vm *pVm,int iOp,...);\r\nUNQLITE_APIEXPORT int unqlite_vm_exec(unqlite_vm *pVm);\r\nUNQLITE_APIEXPORT int unqlite_vm_reset(unqlite_vm *pVm);\r\nUNQLITE_APIEXPORT int unqlite_vm_release(unqlite_vm *pVm);\r\nUNQLITE_APIEXPORT int unqlite_vm_dump(unqlite_vm *pVm, int (*xConsumer)(const void *, unsigned int, void *), void *pUserData);\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_extract_variable(unqlite_vm *pVm,const char *zVarname);\r\n\r\n/*  Cursor Iterator Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_init(unqlite *pDb,unqlite_kv_cursor **ppOut);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_release(unqlite *pDb,unqlite_kv_cursor *pCur);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_seek(unqlite_kv_cursor *pCursor,const void *pKey,int nKeyLen,int iPos);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_first_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_last_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_valid_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_next_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_prev_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_key(unqlite_kv_cursor *pCursor,void *pBuf,int *pnByte);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_key_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_data(unqlite_kv_cursor *pCursor,void *pBuf,unqlite_int64 *pnData);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_data_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_delete_entry(unqlite_kv_cursor *pCursor);\r\nUNQLITE_APIEXPORT int unqlite_kv_cursor_reset(unqlite_kv_cursor *pCursor);\r\n\r\n/* Manual Transaction Manager */\r\nUNQLITE_APIEXPORT int unqlite_begin(unqlite *pDb);\r\nUNQLITE_APIEXPORT int unqlite_commit(unqlite *pDb);\r\nUNQLITE_APIEXPORT int unqlite_rollback(unqlite *pDb);\r\n\r\n/* Utility interfaces */\r\nUNQLITE_APIEXPORT int unqlite_util_load_mmaped_file(const char *zFile,void **ppMap,unqlite_int64 *pFileSize);\r\nUNQLITE_APIEXPORT int unqlite_util_release_mmaped_file(void *pMap,unqlite_int64 iFileSize);\r\nUNQLITE_APIEXPORT int unqlite_util_random_string(unqlite *pDb,char *zBuf,unsigned int buf_size);\r\nUNQLITE_APIEXPORT unsigned int unqlite_util_random_num(unqlite *pDb);\r\n\r\n/* In-process extending interfaces */\r\nUNQLITE_APIEXPORT int unqlite_create_function(unqlite_vm *pVm,const char *zName,int (*xFunc)(unqlite_context *,int,unqlite_value **),void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_delete_function(unqlite_vm *pVm, const char *zName);\r\nUNQLITE_APIEXPORT int unqlite_create_constant(unqlite_vm *pVm,const char *zName,void (*xExpand)(unqlite_value *, void *),void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_delete_constant(unqlite_vm *pVm, const char *zName);\r\n\r\n/* On Demand Object allocation interfaces */\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_new_scalar(unqlite_vm *pVm);\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_new_array(unqlite_vm *pVm);\r\nUNQLITE_APIEXPORT int unqlite_vm_release_value(unqlite_vm *pVm,unqlite_value *pValue);\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_context_new_scalar(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_context_new_array(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT void unqlite_context_release_value(unqlite_context *pCtx,unqlite_value *pValue);\r\n\r\n/* Dynamically Typed Value Object Management Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_value_int(unqlite_value *pVal, int iValue);\r\nUNQLITE_APIEXPORT int unqlite_value_int64(unqlite_value *pVal, unqlite_int64 iValue);\r\nUNQLITE_APIEXPORT int unqlite_value_bool(unqlite_value *pVal, int iBool);\r\nUNQLITE_APIEXPORT int unqlite_value_null(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_double(unqlite_value *pVal, double Value);\r\nUNQLITE_APIEXPORT int unqlite_value_string(unqlite_value *pVal, const char *zString, int nLen);\r\nUNQLITE_APIEXPORT int unqlite_value_string_format(unqlite_value *pVal, const char *zFormat,...);\r\nUNQLITE_APIEXPORT int unqlite_value_reset_string_cursor(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_resource(unqlite_value *pVal, void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_value_release(unqlite_value *pVal);\r\n\r\n/* Foreign Function Parameter Values */\r\nUNQLITE_APIEXPORT int unqlite_value_to_int(unqlite_value *pValue);\r\nUNQLITE_APIEXPORT int unqlite_value_to_bool(unqlite_value *pValue);\r\nUNQLITE_APIEXPORT unqlite_int64 unqlite_value_to_int64(unqlite_value *pValue);\r\nUNQLITE_APIEXPORT double unqlite_value_to_double(unqlite_value *pValue);\r\nUNQLITE_APIEXPORT const char * unqlite_value_to_string(unqlite_value *pValue, int *pLen);\r\nUNQLITE_APIEXPORT void * unqlite_value_to_resource(unqlite_value *pValue);\r\nUNQLITE_APIEXPORT int unqlite_value_compare(unqlite_value *pLeft, unqlite_value *pRight, int bStrict);\r\n\r\n/* Setting The Result Of A Foreign Function */\r\nUNQLITE_APIEXPORT int unqlite_result_int(unqlite_context *pCtx, int iValue);\r\nUNQLITE_APIEXPORT int unqlite_result_int64(unqlite_context *pCtx, unqlite_int64 iValue);\r\nUNQLITE_APIEXPORT int unqlite_result_bool(unqlite_context *pCtx, int iBool);\r\nUNQLITE_APIEXPORT int unqlite_result_double(unqlite_context *pCtx, double Value);\r\nUNQLITE_APIEXPORT int unqlite_result_null(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT int unqlite_result_string(unqlite_context *pCtx, const char *zString, int nLen);\r\nUNQLITE_APIEXPORT int unqlite_result_string_format(unqlite_context *pCtx, const char *zFormat, ...);\r\nUNQLITE_APIEXPORT int unqlite_result_value(unqlite_context *pCtx, unqlite_value *pValue);\r\nUNQLITE_APIEXPORT int unqlite_result_resource(unqlite_context *pCtx, void *pUserData);\r\n\r\n/* Dynamically Typed Value Object Query Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_value_is_int(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_float(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_bool(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_string(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_null(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_numeric(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_callable(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_scalar(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_json_array(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_json_object(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_resource(unqlite_value *pVal);\r\nUNQLITE_APIEXPORT int unqlite_value_is_empty(unqlite_value *pVal);\r\n\r\n/* JSON Array/Object Management Interfaces */\r\nUNQLITE_APIEXPORT unqlite_value * unqlite_array_fetch(unqlite_value *pArray, const char *zKey, int nByte);\r\nUNQLITE_APIEXPORT int unqlite_array_walk(unqlite_value *pArray, int (*xWalk)(unqlite_value *, unqlite_value *, void *), void *pUserData);\r\nUNQLITE_APIEXPORT int unqlite_array_add_elem(unqlite_value *pArray, unqlite_value *pKey, unqlite_value *pValue);\r\nUNQLITE_APIEXPORT int unqlite_array_add_strkey_elem(unqlite_value *pArray, const char *zKey, unqlite_value *pValue);\r\nUNQLITE_APIEXPORT int unqlite_array_count(unqlite_value *pArray);\r\n\r\n/* Call Context Handling Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_context_output(unqlite_context *pCtx, const char *zString, int nLen);\r\nUNQLITE_APIEXPORT int unqlite_context_output_format(unqlite_context *pCtx,const char *zFormat, ...);\r\nUNQLITE_APIEXPORT int unqlite_context_throw_error(unqlite_context *pCtx, int iErr, const char *zErr);\r\nUNQLITE_APIEXPORT int unqlite_context_throw_error_format(unqlite_context *pCtx, int iErr, const char *zFormat, ...);\r\nUNQLITE_APIEXPORT unsigned int unqlite_context_random_num(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT int unqlite_context_random_string(unqlite_context *pCtx, char *zBuf, int nBuflen);\r\nUNQLITE_APIEXPORT void * unqlite_context_user_data(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT int unqlite_context_push_aux_data(unqlite_context *pCtx, void *pUserData);\r\nUNQLITE_APIEXPORT void * unqlite_context_peek_aux_data(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT unsigned int unqlite_context_result_buf_length(unqlite_context *pCtx);\r\nUNQLITE_APIEXPORT const char * unqlite_function_name(unqlite_context *pCtx);\r\n\r\n/* Call Context Memory Management Interfaces */\r\nUNQLITE_APIEXPORT void * unqlite_context_alloc_chunk(unqlite_context *pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease);\r\nUNQLITE_APIEXPORT void * unqlite_context_realloc_chunk(unqlite_context *pCtx,void *pChunk,unsigned int nByte);\r\nUNQLITE_APIEXPORT void unqlite_context_free_chunk(unqlite_context *pCtx,void *pChunk);\r\n\r\n/* Global Library Management Interfaces */\r\nUNQLITE_APIEXPORT int unqlite_lib_config(int nConfigOp,...);\r\nUNQLITE_APIEXPORT int unqlite_lib_init(void);\r\nUNQLITE_APIEXPORT int unqlite_lib_shutdown(void);\r\nUNQLITE_APIEXPORT int unqlite_lib_is_threadsafe(void);\r\nUNQLITE_APIEXPORT const char * unqlite_lib_version(void);\r\nUNQLITE_APIEXPORT const char * unqlite_lib_signature(void);\r\nUNQLITE_APIEXPORT const char * unqlite_lib_ident(void);\r\nUNQLITE_APIEXPORT const char * unqlite_lib_copyright(void);\r\n#ifdef __cplusplus\r\n}\r\n#endif /* __cplusplus */\r\n#endif /* _UNQLITE_H_ */\r\n/*\r\n * ----------------------------------------------------------\r\n * File: jx9.h\r\n * MD5: d23a1e182f596794001533e1d6aa16a0\r\n * ----------------------------------------------------------\r\n */\r\n/* This file was automatically generated.  Do not edit (except for compile time directive)! */ \r\n#ifndef _JX9H_\r\n#define _JX9H_\r\n/*\r\n * Symisc Jx9: A Highly Efficient Embeddable Scripting Engine Based on JSON.\r\n * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/\r\n * Version 1.7.2\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://jx9.symisc.net/\r\n */\r\n/*\r\n * Copyright (C) 2012, 2013 Symisc Systems. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * 3. Redistributions in any form must be accompanied by information on\r\n *    how to obtain complete source code for the JX9 engine and any \r\n *    accompanying software that uses the JX9 engine software.\r\n *    The source code must either be included in the distribution\r\n *    or be available for no more than the cost of distribution plus\r\n *    a nominal fee, and must be freely redistributable under reasonable\r\n *    conditions. For an executable file, complete source code means\r\n *    the source code for all modules it contains.It does not include\r\n *    source code for modules or files that typically accompany the major\r\n *    components of the operating system on which the executable file runs.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY SYMISC SYSTEMS ``AS IS'' AND ANY EXPRESS\r\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR\r\n * NON-INFRINGEMENT, ARE DISCLAIMED.  IN NO EVENT SHALL SYMISC SYSTEMS\r\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\r\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n /* $SymiscID: jx9.h v2.1 UNIX|WIN32/64 2012-09-15 09:43 stable <chm@symisc.net> $ */\r\n#include \"unqlite.h\"\r\n/*\r\n * Compile time engine version, signature, identification in the symisc source tree\r\n * and copyright notice.\r\n * Each macro have an equivalent C interface associated with it that provide the same\r\n * information but are associated with the library instead of the header file.\r\n * Refer to [jx9_lib_version()], [jx9_lib_signature()], [jx9_lib_ident()] and\r\n * [jx9_lib_copyright()] for more information.\r\n */\r\n/*\r\n * The JX9_VERSION C preprocessor macroevaluates to a string literal\r\n * that is the jx9 version in the format \"X.Y.Z\" where X is the major\r\n * version number and Y is the minor version number and Z is the release\r\n * number.\r\n */\r\n#define JX9_VERSION \"1.7.2\"\r\n/*\r\n * The JX9_VERSION_NUMBER C preprocessor macro resolves to an integer\r\n * with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same\r\n * numbers used in [JX9_VERSION].\r\n */\r\n#define JX9_VERSION_NUMBER 1007002\r\n/*\r\n * The JX9_SIG C preprocessor macro evaluates to a string\r\n * literal which is the public signature of the jx9 engine.\r\n * This signature could be included for example in a host-application\r\n * generated Server MIME header as follows:\r\n *   Server: YourWebServer/x.x Jx9/x.x.x \\r\\n\r\n */\r\n#define JX9_SIG \"Jx9/1.7.2\"\r\n/*\r\n * JX9 identification in the Symisc source tree:\r\n * Each particular check-in of a particular software released\r\n * by symisc systems have an unique identifier associated with it.\r\n * This macro hold the one associated with jx9.\r\n */\r\n#define JX9_IDENT \"jx9:d217a6e8c7f10fb35a8becb2793101fd2036aeb7\"\r\n/*\r\n * Copyright notice.\r\n * If you have any questions about the licensing situation, please\r\n * visit http://jx9.symisc.net/licensing.html\r\n * or contact Symisc Systems via:\r\n *   legal@symisc.net\r\n *   licensing@symisc.net\r\n *   contact@symisc.net\r\n */\r\n#define JX9_COPYRIGHT \"Copyright (C) Symisc Systems 2012-2013, http://jx9.symisc.net/\"\r\n\r\n/* Forward declaration to public objects */\r\ntypedef struct jx9_io_stream jx9_io_stream;\r\ntypedef struct jx9_context jx9_context;\r\ntypedef struct jx9_value jx9_value;\r\ntypedef struct jx9_vfs jx9_vfs;\r\ntypedef struct jx9_vm jx9_vm;\r\ntypedef struct jx9 jx9;\r\n\r\n#include \"unqlite.h\"\r\n\r\n#if !defined( UNQLITE_ENABLE_JX9_HASH_FUNC )\r\n#define JX9_DISABLE_HASH_FUNC\r\n#endif /* UNQLITE_ENABLE_JX9_HASH_FUNC */\r\n#ifdef UNQLITE_ENABLE_THREADS\r\n#define JX9_ENABLE_THREADS\r\n#endif /* UNQLITE_ENABLE_THREADS */\r\n/* Standard JX9 return values */\r\n#define JX9_OK      SXRET_OK      /* Successful result */\r\n/* beginning-of-error-codes */\r\n#define JX9_NOMEM   UNQLITE_NOMEM     /* Out of memory */\r\n#define JX9_ABORT   UNQLITE_ABORT   /* Foreign Function request operation abort/Another thread have released this instance */\r\n#define JX9_IO_ERR  UNQLITE_IOERR      /* IO error */\r\n#define JX9_CORRUPT UNQLITE_CORRUPT /* Corrupt pointer/Unknown configuration option */\r\n#define JX9_LOOKED  UNQLITE_LOCKED  /* Forbidden Operation */ \r\n#define JX9_COMPILE_ERR UNQLITE_COMPILE_ERR /* Compilation error */\r\n#define JX9_VM_ERR      UNQLITE_VM_ERR      /* Virtual machine error */\r\n/* end-of-error-codes */\r\n/*\r\n * If compiling for a processor that lacks floating point\r\n * support, substitute integer for floating-point.\r\n */\r\n#ifdef JX9_OMIT_FLOATING_POINT\r\ntypedef sxi64 jx9_real;\r\n#else\r\ntypedef double jx9_real;\r\n#endif\r\ntypedef sxi64 jx9_int64;\r\n/*\r\n * Engine Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the JX9 engine.\r\n * These constants must be passed as the second argument to the [jx9_config()] \r\n * interface.\r\n * Each options require a variable number of arguments.\r\n * The [jx9_config()] interface will return JX9_OK on success, any other\r\n * return value indicates failure.\r\n * For a full discussion on the configuration verbs and their expected \r\n * parameters, please refer to this page:\r\n *      http://jx9.symisc.net/c_api_func.html#jx9_config\r\n */\r\n#define JX9_CONFIG_ERR_ABORT     1  /* RESERVED FOR FUTURE USE */\r\n#define JX9_CONFIG_ERR_LOG       2  /* TWO ARGUMENTS: const char **pzBuf, int *pLen */\r\n/*\r\n * Virtual Machine Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the JX9 Virtual machine.\r\n * These constants must be passed as the second argument to the [jx9_vm_config()] \r\n * interface.\r\n * Each options require a variable number of arguments.\r\n * The [jx9_vm_config()] interface will return JX9_OK on success, any other return\r\n * value indicates failure.\r\n * There are many options but the most importants are: JX9_VM_CONFIG_OUTPUT which install\r\n * a VM output consumer callback, JX9_VM_CONFIG_HTTP_REQUEST which parse and register\r\n * a HTTP request and JX9_VM_CONFIG_ARGV_ENTRY which populate the $argv array.\r\n * For a full discussion on the configuration verbs and their expected parameters, please\r\n * refer to this page:\r\n *      http://jx9.symisc.net/c_api_func.html#jx9_vm_config\r\n */\r\n#define JX9_VM_CONFIG_OUTPUT           UNQLITE_VM_CONFIG_OUTPUT  /* TWO ARGUMENTS: int (*xConsumer)(const void *pOut, unsigned int nLen, void *pUserData), void *pUserData */\r\n#define JX9_VM_CONFIG_IMPORT_PATH      UNQLITE_VM_CONFIG_IMPORT_PATH  /* ONE ARGUMENT: const char *zIncludePath */\r\n#define JX9_VM_CONFIG_ERR_REPORT       UNQLITE_VM_CONFIG_ERR_REPORT  /* NO ARGUMENTS: Report all run-time errors in the VM output */\r\n#define JX9_VM_CONFIG_RECURSION_DEPTH  UNQLITE_VM_CONFIG_RECURSION_DEPTH  /* ONE ARGUMENT: int nMaxDepth */\r\n#define JX9_VM_OUTPUT_LENGTH           UNQLITE_VM_OUTPUT_LENGTH  /* ONE ARGUMENT: unsigned int *pLength */\r\n#define JX9_VM_CONFIG_CREATE_VAR       UNQLITE_VM_CONFIG_CREATE_VAR  /* TWO ARGUMENTS: const char *zName, jx9_value *pValue */\r\n#define JX9_VM_CONFIG_HTTP_REQUEST     UNQLITE_VM_CONFIG_HTTP_REQUEST  /* TWO ARGUMENTS: const char *zRawRequest, int nRequestLength */\r\n#define JX9_VM_CONFIG_SERVER_ATTR      UNQLITE_VM_CONFIG_SERVER_ATTR  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\r\n#define JX9_VM_CONFIG_ENV_ATTR         UNQLITE_VM_CONFIG_ENV_ATTR  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\r\n#define JX9_VM_CONFIG_EXEC_VALUE       UNQLITE_VM_CONFIG_EXEC_VALUE  /* ONE ARGUMENT: jx9_value **ppValue */\r\n#define JX9_VM_CONFIG_IO_STREAM        UNQLITE_VM_CONFIG_IO_STREAM  /* ONE ARGUMENT: const jx9_io_stream *pStream */\r\n#define JX9_VM_CONFIG_ARGV_ENTRY       UNQLITE_VM_CONFIG_ARGV_ENTRY  /* ONE ARGUMENT: const char *zValue */\r\n#define JX9_VM_CONFIG_EXTRACT_OUTPUT   UNQLITE_VM_CONFIG_EXTRACT_OUTPUT  /* TWO ARGUMENTS: const void **ppOut, unsigned int *pOutputLen */\r\n/*\r\n * Global Library Configuration Commands.\r\n *\r\n * The following set of constants are the available configuration verbs that can\r\n * be used by the host-application to configure the whole library.\r\n * These constants must be passed as the first argument to the [jx9_lib_config()] \r\n * interface.\r\n * Each options require a variable number of arguments.\r\n * The [jx9_lib_config()] interface will return JX9_OK on success, any other return\r\n * value indicates failure.\r\n * Notes:\r\n * The default configuration is recommended for most applications and so the call to\r\n * [jx9_lib_config()] is usually not necessary. It is provided to support rare \r\n * applications with unusual needs. \r\n * The [jx9_lib_config()] interface is not threadsafe. The application must insure that\r\n * no other [jx9_*()] interfaces are invoked by other threads while [jx9_lib_config()]\r\n * is running. Furthermore, [jx9_lib_config()] may only be invoked prior to library\r\n * initialization using [jx9_lib_init()] or [jx9_init()] or after shutdown\r\n * by [jx9_lib_shutdown()]. If [jx9_lib_config()] is called after [jx9_lib_init()]\r\n * or [jx9_init()] and before [jx9_lib_shutdown()] then it will return jx9LOCKED.\r\n * For a full discussion on the configuration verbs and their expected parameters, please\r\n * refer to this page:\r\n *      http://jx9.symisc.net/c_api_func.html#Global_Library_Management_Interfaces\r\n */\r\n#define JX9_LIB_CONFIG_USER_MALLOC            1 /* ONE ARGUMENT: const SyMemMethods *pMemMethods */ \r\n#define JX9_LIB_CONFIG_MEM_ERR_CALLBACK       2 /* TWO ARGUMENTS: int (*xMemError)(void *), void *pUserData */\r\n#define JX9_LIB_CONFIG_USER_MUTEX             3 /* ONE ARGUMENT: const SyMutexMethods *pMutexMethods */ \r\n#define JX9_LIB_CONFIG_THREAD_LEVEL_SINGLE    4 /* NO ARGUMENTS */ \r\n#define JX9_LIB_CONFIG_THREAD_LEVEL_MULTI     5 /* NO ARGUMENTS */ \r\n#define JX9_LIB_CONFIG_VFS                    6 /* ONE ARGUMENT: const jx9_vfs *pVfs */\r\n/*\r\n * Call Context - Error Message Serverity Level.\r\n */\r\n#define JX9_CTX_ERR      UNQLITE_CTX_ERR      /* Call context error such as unexpected number of arguments, invalid types and so on. */\r\n#define JX9_CTX_WARNING  UNQLITE_CTX_WARNING  /* Call context Warning */\r\n#define JX9_CTX_NOTICE   UNQLITE_CTX_NOTICE   /* Call context Notice */\r\n/* Current VFS structure version*/\r\n#define JX9_VFS_VERSION 2 \r\n/* \r\n * JX9 Virtual File System (VFS).\r\n *\r\n * An instance of the jx9_vfs object defines the interface between the JX9 core\r\n * and the underlying operating system. The \"vfs\" in the name of the object stands\r\n * for \"virtual file system\". The vfs is used to implement JX9 system functions\r\n * such as mkdir(), chdir(), stat(), get_user_name() and many more.\r\n * The value of the iVersion field is initially 2 but may be larger in future versions\r\n * of JX9.\r\n * Additional fields may be appended to this object when the iVersion value is increased.\r\n * Only a single vfs can be registered within the JX9 core. Vfs registration is done\r\n * using the jx9_lib_config() interface with a configuration verb set to JX9_LIB_CONFIG_VFS.\r\n * Note that Windows and UNIX (Linux, FreeBSD, Solaris, Mac OS X, etc.) users does not have to\r\n * worry about registering and installing a vfs since JX9 come with a built-in vfs for these\r\n * platforms which implement most the methods defined below.\r\n * Host-application running on exotic systems (ie: Other than Windows and UNIX systems) must\r\n * register their own vfs in order to be able to use and call JX9 system functions.\r\n * Also note that the jx9_compile_file() interface depend on the xMmap() method of the underlying\r\n * vfs which mean that this method must be available (Always the case using the built-in VFS)\r\n * in order to use this interface.\r\n * Developers wishing to implement their own vfs an contact symisc systems to obtain\r\n * the JX9 VFS C/C++ Specification manual.\r\n */\r\nstruct jx9_vfs\r\n{\r\n\tconst char *zName;  /* Underlying VFS name [i.e: FreeBSD/Linux/Windows...] */\r\n\tint iVersion;       /* Current VFS structure version [default 2] */\r\n\t/* Directory functions */\r\n\tint (*xChdir)(const char *);                     /* Change directory */\r\n\tint (*xChroot)(const char *);                    /* Change the root directory */\r\n\tint (*xGetcwd)(jx9_context *);                   /* Get the current working directory */\r\n\tint (*xMkdir)(const char *, int, int);             /* Make directory */\r\n\tint (*xRmdir)(const char *);                     /* Remove directory */\r\n\tint (*xIsdir)(const char *);                     /* Tells whether the filename is a directory */\r\n\tint (*xRename)(const char *, const char *);       /* Renames a file or directory */\r\n\tint (*xRealpath)(const char *, jx9_context *);    /* Return canonicalized absolute pathname*/\r\n\t/* Systems functions */\r\n\tint (*xSleep)(unsigned int);                     /* Delay execution in microseconds */\r\n\tint (*xUnlink)(const char *);                    /* Deletes a file */\r\n\tint (*xFileExists)(const char *);                /* Checks whether a file or directory exists */\r\n\tint (*xChmod)(const char *, int);                 /* Changes file mode */\r\n\tint (*xChown)(const char *, const char *);        /* Changes file owner */\r\n\tint (*xChgrp)(const char *, const char *);        /* Changes file group */\r\n\tjx9_int64 (*xFreeSpace)(const char *);           /* Available space on filesystem or disk partition */\r\n\tjx9_int64 (*xTotalSpace)(const char *);          /* Total space on filesystem or disk partition */\r\n\tjx9_int64 (*xFileSize)(const char *);            /* Gets file size */\r\n\tjx9_int64 (*xFileAtime)(const char *);           /* Gets last access time of file */\r\n\tjx9_int64 (*xFileMtime)(const char *);           /* Gets file modification time */\r\n\tjx9_int64 (*xFileCtime)(const char *);           /* Gets inode change time of file */\r\n\tint (*xStat)(const char *, jx9_value *, jx9_value *);   /* Gives information about a file */\r\n\tint (*xlStat)(const char *, jx9_value *, jx9_value *);  /* Gives information about a file */\r\n\tint (*xIsfile)(const char *);                    /* Tells whether the filename is a regular file */\r\n\tint (*xIslink)(const char *);                    /* Tells whether the filename is a symbolic link */\r\n\tint (*xReadable)(const char *);                  /* Tells whether a file exists and is readable */\r\n\tint (*xWritable)(const char *);                  /* Tells whether the filename is writable */\r\n\tint (*xExecutable)(const char *);                /* Tells whether the filename is executable */\r\n\tint (*xFiletype)(const char *, jx9_context *);    /* Gets file type [i.e: fifo, dir, file..] */\r\n\tint (*xGetenv)(const char *, jx9_context *);      /* Gets the value of an environment variable */\r\n\tint (*xSetenv)(const char *, const char *);       /* Sets the value of an environment variable */\r\n\tint (*xTouch)(const char *, jx9_int64, jx9_int64); /* Sets access and modification time of file */\r\n\tint (*xMmap)(const char *, void **, jx9_int64 *);  /* Read-only memory map of the whole file */\r\n\tvoid (*xUnmap)(void *, jx9_int64);                /* Unmap a memory view */\r\n\tint (*xLink)(const char *, const char *, int);     /* Create hard or symbolic link */\r\n\tint (*xUmask)(int);                              /* Change the current umask */\r\n\tvoid (*xTempDir)(jx9_context *);                 /* Get path of the temporary directory */\r\n\tunsigned int (*xProcessId)(void);                /* Get running process ID */\r\n\tint (*xUid)(void);                               /* user ID of the process */\r\n\tint (*xGid)(void);                               /* group ID of the process */\r\n\tvoid (*xUsername)(jx9_context *);                /* Running username */\r\n\tint (*xExec)(const char *, jx9_context *);        /* Execute an external program */\r\n};\r\n/* Current JX9 IO stream structure version. */\r\n#define JX9_IO_STREAM_VERSION 1 \r\n/* \r\n * Possible open mode flags that can be passed to the xOpen() routine\r\n * of the underlying IO stream device .\r\n * Refer to the JX9 IO Stream C/C++ specification manual (http://jx9.symisc.net/io_stream_spec.html)\r\n * for additional information.\r\n */\r\n#define JX9_IO_OPEN_RDONLY   0x001  /* Read-only open */\r\n#define JX9_IO_OPEN_WRONLY   0x002  /* Write-only open */\r\n#define JX9_IO_OPEN_RDWR     0x004  /* Read-write open. */\r\n#define JX9_IO_OPEN_CREATE   0x008  /* If the file does not exist it will be created */\r\n#define JX9_IO_OPEN_TRUNC    0x010  /* Truncate the file to zero length */\r\n#define JX9_IO_OPEN_APPEND   0x020  /* Append mode.The file offset is positioned at the end of the file */\r\n#define JX9_IO_OPEN_EXCL     0x040  /* Ensure that this call creates the file, the file must not exist before */\r\n#define JX9_IO_OPEN_BINARY   0x080  /* Simple hint: Data is binary */\r\n#define JX9_IO_OPEN_TEMP     0x100  /* Simple hint: Temporary file */\r\n#define JX9_IO_OPEN_TEXT     0x200  /* Simple hint: Data is textual */\r\n/*\r\n * JX9 IO Stream Device.\r\n *\r\n * An instance of the jx9_io_stream object defines the interface between the JX9 core\r\n * and the underlying stream device.\r\n * A stream is a smart mechanism for generalizing file, network, data compression\r\n * and other IO operations which share a common set of functions using an abstracted\r\n * unified interface.\r\n * A stream device is additional code which tells the stream how to handle specific\r\n * protocols/encodings. For example, the http device knows how to translate a URL\r\n * into an HTTP/1.1 request for a file on a remote server.\r\n * JX9 come with two built-in IO streams device:\r\n * The file:// stream which perform very efficient disk IO and the jx9:// stream\r\n * which is a special stream that allow access various I/O streams (See the JX9 official\r\n * documentation for more information on this stream).\r\n * A stream is referenced as: scheme://target \r\n * scheme(string) - The name of the wrapper to be used. Examples include: file, http, https, ftp, \r\n * ftps, compress.zlib, compress.bz2, and jx9. If no wrapper is specified, the function default\r\n * is used (typically file://). \r\n * target - Depends on the device used. For filesystem related streams this is typically a path\r\n * and filename of the desired file.For network related streams this is typically a hostname, often\r\n * with a path appended. \r\n * IO stream devices are registered using a call to jx9_vm_config() with a configuration verb\r\n * set to JX9_VM_CONFIG_IO_STREAM.\r\n * Currently the JX9 development team is working on the implementation of the http:// and ftp://\r\n * IO stream protocols. These devices will be available in the next major release of the JX9 engine.\r\n * Developers wishing to implement their own IO stream devices must understand and follow\r\n * The JX9 IO Stream C/C++ specification manual (http://jx9.symisc.net/io_stream_spec.html).\r\n */\r\nstruct jx9_io_stream\r\n{\r\n\tconst char *zName;                                     /* Underlying stream name [i.e: file/http/zip/jx9, ..] */\r\n\tint iVersion;                                          /* IO stream structure version [default 1]*/\r\n\tint  (*xOpen)(const char *, int, jx9_value *, void **);   /* Open handle*/\r\n\tint  (*xOpenDir)(const char *, jx9_value *, void **);    /* Open directory handle */\r\n\tvoid (*xClose)(void *);                                /* Close file handle */\r\n\tvoid (*xCloseDir)(void *);                             /* Close directory handle */\r\n\tjx9_int64 (*xRead)(void *, void *, jx9_int64);           /* Read from the open stream */         \r\n\tint (*xReadDir)(void *, jx9_context *);                 /* Read entry from directory handle */\r\n\tjx9_int64 (*xWrite)(void *, const void *, jx9_int64);    /* Write to the open stream */\r\n\tint (*xSeek)(void *, jx9_int64, int);                    /* Seek on the open stream */\r\n\tint (*xLock)(void *, int);                              /* Lock/Unlock the open stream */\r\n\tvoid (*xRewindDir)(void *);                            /* Rewind directory handle */\r\n\tjx9_int64 (*xTell)(void *);                            /* Current position of the stream  read/write pointer */\r\n\tint (*xTrunc)(void *, jx9_int64);                       /* Truncates the open stream to a given length */\r\n\tint (*xSync)(void *);                                  /* Flush open stream data */\r\n\tint (*xStat)(void *, jx9_value *, jx9_value *);          /* Stat an open stream handle */\r\n};\r\n/* \r\n * C-API-REF: Please refer to the official documentation for interfaces\r\n * purpose and expected parameters. \r\n */ \r\n/* Engine Handling Interfaces */\r\nJX9_PRIVATE int jx9_init(jx9 **ppEngine);\r\n/*JX9_PRIVATE int jx9_config(jx9 *pEngine, int nConfigOp, ...);*/\r\nJX9_PRIVATE int jx9_release(jx9 *pEngine);\r\n/* Compile Interfaces */\r\nJX9_PRIVATE int jx9_compile(jx9 *pEngine, const char *zSource, int nLen, jx9_vm **ppOutVm);\r\nJX9_PRIVATE int jx9_compile_file(jx9 *pEngine, const char *zFilePath, jx9_vm **ppOutVm);\r\n/* Virtual Machine Handling Interfaces */\r\nJX9_PRIVATE int jx9_vm_config(jx9_vm *pVm, int iConfigOp, ...);\r\n/*JX9_PRIVATE int jx9_vm_exec(jx9_vm *pVm, int *pExitStatus);*/\r\n/*JX9_PRIVATE jx9_value * jx9_vm_extract_variable(jx9_vm *pVm,const char *zVarname);*/\r\n/*JX9_PRIVATE int jx9_vm_reset(jx9_vm *pVm);*/\r\nJX9_PRIVATE int jx9_vm_release(jx9_vm *pVm);\r\n/*JX9_PRIVATE int jx9_vm_dump_v2(jx9_vm *pVm, int (*xConsumer)(const void *, unsigned int, void *), void *pUserData);*/\r\n/* In-process Extending Interfaces */\r\nJX9_PRIVATE int jx9_create_function(jx9_vm *pVm, const char *zName, int (*xFunc)(jx9_context *, int, jx9_value **), void *pUserData);\r\n/*JX9_PRIVATE int jx9_delete_function(jx9_vm *pVm, const char *zName);*/\r\nJX9_PRIVATE int jx9_create_constant(jx9_vm *pVm, const char *zName, void (*xExpand)(jx9_value *, void *), void *pUserData);\r\n/*JX9_PRIVATE int jx9_delete_constant(jx9_vm *pVm, const char *zName);*/\r\n/* Foreign Function Parameter Values */\r\nJX9_PRIVATE int jx9_value_to_int(jx9_value *pValue);\r\nJX9_PRIVATE int jx9_value_to_bool(jx9_value *pValue);\r\nJX9_PRIVATE jx9_int64 jx9_value_to_int64(jx9_value *pValue);\r\nJX9_PRIVATE double jx9_value_to_double(jx9_value *pValue);\r\nJX9_PRIVATE const char * jx9_value_to_string(jx9_value *pValue, int *pLen);\r\nJX9_PRIVATE void * jx9_value_to_resource(jx9_value *pValue);\r\nJX9_PRIVATE int jx9_value_compare(jx9_value *pLeft, jx9_value *pRight, int bStrict);\r\n/* Setting The Result Of A Foreign Function */\r\nJX9_PRIVATE int jx9_result_int(jx9_context *pCtx, int iValue);\r\nJX9_PRIVATE int jx9_result_int64(jx9_context *pCtx, jx9_int64 iValue);\r\nJX9_PRIVATE int jx9_result_bool(jx9_context *pCtx, int iBool);\r\nJX9_PRIVATE int jx9_result_double(jx9_context *pCtx, double Value);\r\nJX9_PRIVATE int jx9_result_null(jx9_context *pCtx);\r\nJX9_PRIVATE int jx9_result_string(jx9_context *pCtx, const char *zString, int nLen);\r\nJX9_PRIVATE int jx9_result_string_format(jx9_context *pCtx, const char *zFormat, ...);\r\nJX9_PRIVATE int jx9_result_value(jx9_context *pCtx, jx9_value *pValue);\r\nJX9_PRIVATE int jx9_result_resource(jx9_context *pCtx, void *pUserData);\r\n/* Call Context Handling Interfaces */\r\nJX9_PRIVATE int jx9_context_output(jx9_context *pCtx, const char *zString, int nLen);\r\n/*JX9_PRIVATE int jx9_context_output_format(jx9_context *pCtx, const char *zFormat, ...);*/\r\nJX9_PRIVATE int jx9_context_throw_error(jx9_context *pCtx, int iErr, const char *zErr);\r\nJX9_PRIVATE int jx9_context_throw_error_format(jx9_context *pCtx, int iErr, const char *zFormat, ...);\r\nJX9_PRIVATE unsigned int jx9_context_random_num(jx9_context *pCtx);\r\nJX9_PRIVATE int jx9_context_random_string(jx9_context *pCtx, char *zBuf, int nBuflen);\r\nJX9_PRIVATE void * jx9_context_user_data(jx9_context *pCtx);\r\nJX9_PRIVATE int    jx9_context_push_aux_data(jx9_context *pCtx, void *pUserData);\r\nJX9_PRIVATE void * jx9_context_peek_aux_data(jx9_context *pCtx);\r\nJX9_PRIVATE void * jx9_context_pop_aux_data(jx9_context *pCtx);\r\nJX9_PRIVATE unsigned int jx9_context_result_buf_length(jx9_context *pCtx);\r\nJX9_PRIVATE const char * jx9_function_name(jx9_context *pCtx);\r\n/* Call Context Memory Management Interfaces */\r\nJX9_PRIVATE void * jx9_context_alloc_chunk(jx9_context *pCtx, unsigned int nByte, int ZeroChunk, int AutoRelease);\r\nJX9_PRIVATE void * jx9_context_realloc_chunk(jx9_context *pCtx, void *pChunk, unsigned int nByte);\r\nJX9_PRIVATE void jx9_context_free_chunk(jx9_context *pCtx, void *pChunk);\r\n/* On Demand Dynamically Typed Value Object allocation interfaces */\r\nJX9_PRIVATE jx9_value * jx9_new_scalar(jx9_vm *pVm);\r\nJX9_PRIVATE jx9_value * jx9_new_array(jx9_vm *pVm);\r\nJX9_PRIVATE int jx9_release_value(jx9_vm *pVm, jx9_value *pValue);\r\nJX9_PRIVATE jx9_value * jx9_context_new_scalar(jx9_context *pCtx);\r\nJX9_PRIVATE jx9_value * jx9_context_new_array(jx9_context *pCtx);\r\nJX9_PRIVATE void jx9_context_release_value(jx9_context *pCtx, jx9_value *pValue);\r\n/* Dynamically Typed Value Object Management Interfaces */\r\nJX9_PRIVATE int jx9_value_int(jx9_value *pVal, int iValue);\r\nJX9_PRIVATE int jx9_value_int64(jx9_value *pVal, jx9_int64 iValue);\r\nJX9_PRIVATE int jx9_value_bool(jx9_value *pVal, int iBool);\r\nJX9_PRIVATE int jx9_value_null(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_double(jx9_value *pVal, double Value);\r\nJX9_PRIVATE int jx9_value_string(jx9_value *pVal, const char *zString, int nLen);\r\nJX9_PRIVATE int jx9_value_string_format(jx9_value *pVal, const char *zFormat, ...);\r\nJX9_PRIVATE int jx9_value_reset_string_cursor(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_resource(jx9_value *pVal, void *pUserData);\r\nJX9_PRIVATE int jx9_value_release(jx9_value *pVal);\r\n/* JSON Array/Object Management Interfaces */\r\nJX9_PRIVATE jx9_value * jx9_array_fetch(jx9_value *pArray, const char *zKey, int nByte);\r\nJX9_PRIVATE int jx9_array_walk(jx9_value *pArray, int (*xWalk)(jx9_value *, jx9_value *, void *), void *pUserData);\r\nJX9_PRIVATE int jx9_array_add_elem(jx9_value *pArray, jx9_value *pKey, jx9_value *pValue);\r\nJX9_PRIVATE int jx9_array_add_strkey_elem(jx9_value *pArray, const char *zKey, jx9_value *pValue);\r\nJX9_PRIVATE unsigned int jx9_array_count(jx9_value *pArray);\r\n/* Dynamically Typed Value Object Query Interfaces */\r\nJX9_PRIVATE int jx9_value_is_int(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_float(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_bool(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_string(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_null(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_numeric(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_callable(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_scalar(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_json_array(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_json_object(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_resource(jx9_value *pVal);\r\nJX9_PRIVATE int jx9_value_is_empty(jx9_value *pVal);\r\n/* Global Library Management Interfaces */\r\n/*JX9_PRIVATE int jx9_lib_init(void);*/\r\nJX9_PRIVATE int jx9_lib_config(int nConfigOp, ...);\r\nJX9_PRIVATE int jx9_lib_shutdown(void);\r\n/*JX9_PRIVATE int jx9_lib_is_threadsafe(void);*/\r\n/*JX9_PRIVATE const char * jx9_lib_version(void);*/\r\nJX9_PRIVATE const char * jx9_lib_signature(void);\r\n/*JX9_PRIVATE const char * jx9_lib_ident(void);*/\r\n/*JX9_PRIVATE const char * jx9_lib_copyright(void);*/\r\n\r\n#endif /* _JX9H_ */\r\n\r\n/*\r\n * ----------------------------------------------------------\r\n * File: jx9Int.h\r\n * MD5: fb8dffc8ba1425a139091aa145067e16\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.\r\n * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/\r\n * Version 1.7.2\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://jx9.symisc.net/\r\n */\r\n /* $SymiscID: jx9Int.h v1.9 FreeBSD 2012-08-13 23:25 devel <chm@symisc.net> $ */\r\n#ifndef __JX9INT_H__\r\n#define __JX9INT_H__\r\n/* Internal interface definitions for JX9. */\r\n#ifdef JX9_AMALGAMATION\r\n#ifndef JX9_PRIVATE\r\n/* Marker for routines not intended for external use */\r\n#define JX9_PRIVATE static\r\n#endif /* JX9_PRIVATE */\r\n#else\r\n#define JX9_PRIVATE\r\n#include \"jx9.h\"\r\n#endif \r\n#ifndef JX9_PI\r\n/* Value of PI */\r\n#define JX9_PI 3.1415926535898\r\n#endif\r\n/*\r\n * Constants for the largest and smallest possible 64-bit signed integers.\r\n * These macros are designed to work correctly on both 32-bit and 64-bit\r\n * compilers.\r\n */\r\n#ifndef LARGEST_INT64\r\n#define LARGEST_INT64  (0xffffffff|(((sxi64)0x7fffffff)<<32))\r\n#endif\r\n#ifndef SMALLEST_INT64\r\n#define SMALLEST_INT64 (((sxi64)-1) - LARGEST_INT64)\r\n#endif\r\n/* Forward declaration of private structures */\r\ntypedef struct jx9_foreach_info   jx9_foreach_info;\r\ntypedef struct jx9_foreach_step   jx9_foreach_step;\r\ntypedef struct jx9_hashmap_node   jx9_hashmap_node;\r\ntypedef struct jx9_hashmap        jx9_hashmap;\r\n/* Symisc Standard types */\r\n#if !defined(SYMISC_STD_TYPES)\r\n#define SYMISC_STD_TYPES\r\n#ifdef __WINNT__\r\n/* Disable nuisance warnings on Borland compilers */\r\n#if defined(__BORLANDC__)\r\n#pragma warn -rch /* unreachable code */\r\n#pragma warn -ccc /* Condition is always true or false */\r\n#pragma warn -aus /* Assigned value is never used */\r\n#pragma warn -csu /* Comparing signed and unsigned */\r\n#pragma warn -spa /* Suspicious pointer arithmetic */\r\n#endif\r\n#endif\r\ntypedef signed char        sxi8; /* signed char */\r\ntypedef unsigned char      sxu8; /* unsigned char */\r\ntypedef signed short int   sxi16; /* 16 bits(2 bytes) signed integer */\r\ntypedef unsigned short int sxu16; /* 16 bits(2 bytes) unsigned integer */\r\ntypedef int                sxi32; /* 32 bits(4 bytes) integer */\r\ntypedef unsigned int       sxu32; /* 32 bits(4 bytes) unsigned integer */\r\ntypedef long               sxptr;\r\ntypedef unsigned long      sxuptr;\r\ntypedef long               sxlong;\r\ntypedef unsigned long      sxulong;\r\ntypedef sxi32              sxofft;\r\ntypedef sxi64              sxofft64;\r\ntypedef long double\t       sxlongreal;\r\ntypedef double             sxreal;\r\n#define SXI8_HIGH       0x7F\r\n#define SXU8_HIGH       0xFF\r\n#define SXI16_HIGH      0x7FFF\r\n#define SXU16_HIGH      0xFFFF\r\n#define SXI32_HIGH      0x7FFFFFFF\r\n#define SXU32_HIGH      0xFFFFFFFF\r\n#define SXI64_HIGH      0x7FFFFFFFFFFFFFFF\r\n#define SXU64_HIGH      0xFFFFFFFFFFFFFFFF \r\n#if !defined(TRUE)\r\n#define TRUE 1\r\n#endif\r\n#if !defined(FALSE)\r\n#define FALSE 0\r\n#endif\r\n/*\r\n * The following macros are used to cast pointers to integers and\r\n * integers to pointers.\r\n */\r\n#if defined(__PTRDIFF_TYPE__)  \r\n# define SX_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))\r\n# define SX_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))\r\n#elif !defined(__GNUC__)    \r\n# define SX_INT_TO_PTR(X)  ((void*)&((char*)0)[X])\r\n# define SX_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))\r\n#else                       \r\n# define SX_INT_TO_PTR(X)  ((void*)(X))\r\n# define SX_PTR_TO_INT(X)  ((int)(X))\r\n#endif\r\n#define SXMIN(a, b)  ((a < b) ? (a) : (b))\r\n#define SXMAX(a, b)  ((a < b) ? (b) : (a))\r\n#endif /* SYMISC_STD_TYPES */\r\n/* Symisc Run-time API private definitions */\r\n#if !defined(SYMISC_PRIVATE_DEFS)\r\n#define SYMISC_PRIVATE_DEFS\r\n\r\ntypedef sxi32 (*ProcRawStrCmp)(const SyString *, const SyString *);\r\n#define SyStringData(RAW)\t((RAW)->zString)\r\n#define SyStringLength(RAW)\t((RAW)->nByte)\r\n#define SyStringInitFromBuf(RAW, ZBUF, NLEN){\\\r\n\t(RAW)->zString \t= (const char *)ZBUF;\\\r\n\t(RAW)->nByte\t= (sxu32)(NLEN);\\\r\n}\r\n#define SyStringUpdatePtr(RAW, NBYTES){\\\r\n\tif( NBYTES > (RAW)->nByte ){\\\r\n\t\t(RAW)->nByte = 0;\\\r\n\t}else{\\\r\n\t\t(RAW)->zString += NBYTES;\\\r\n\t\t(RAW)->nByte -= NBYTES;\\\r\n\t}\\\r\n}\r\n#define SyStringDupPtr(RAW1, RAW2)\\\r\n\t(RAW1)->zString = (RAW2)->zString;\\\r\n\t(RAW1)->nByte = (RAW2)->nByte;\r\n\r\n#define SyStringTrimLeadingChar(RAW, CHAR)\\\r\n\twhile((RAW)->nByte > 0 && (RAW)->zString[0] == CHAR ){\\\r\n\t\t\t(RAW)->zString++;\\\r\n\t\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringTrimTrailingChar(RAW, CHAR)\\\r\n\twhile((RAW)->nByte > 0 && (RAW)->zString[(RAW)->nByte - 1] == CHAR){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringCmp(RAW1, RAW2, xCMP)\\\r\n\t(((RAW1)->nByte == (RAW2)->nByte) ? xCMP((RAW1)->zString, (RAW2)->zString, (RAW2)->nByte) : (sxi32)((RAW1)->nByte - (RAW2)->nByte))\r\n\r\n#define SyStringCmp2(RAW1, RAW2, xCMP)\\\r\n\t(((RAW1)->nByte >= (RAW2)->nByte) ? xCMP((RAW1)->zString, (RAW2)->zString, (RAW2)->nByte) : (sxi32)((RAW2)->nByte - (RAW1)->nByte))\r\n\r\n#define SyStringCharCmp(RAW, CHAR) \\\r\n\t(((RAW)->nByte == sizeof(char)) ? ((RAW)->zString[0] == CHAR ? 0 : CHAR - (RAW)->zString[0]) : ((RAW)->zString[0] == CHAR ? 0 : (RAW)->nByte - sizeof(char)))\r\n\r\n#define SX_ADDR(PTR)    ((sxptr)PTR)\r\n#define SX_ARRAYSIZE(X) (sizeof(X)/sizeof(X[0]))\r\n#define SXUNUSED(P)\t(P = 0)\r\n#define\tSX_EMPTY(PTR)   (PTR == 0)\r\n#define SX_EMPTY_STR(STR) (STR == 0 || STR[0] == 0 )\r\ntypedef struct SyMemBackend SyMemBackend;\r\ntypedef struct SyBlob SyBlob;\r\ntypedef struct SySet SySet;\r\n/* Standard function signatures */\r\ntypedef sxi32 (*ProcCmp)(const void *, const void *, sxu32);\r\ntypedef sxi32 (*ProcPatternMatch)(const char *, sxu32, const char *, sxu32, sxu32 *);\r\ntypedef sxi32 (*ProcSearch)(const void *, sxu32, const void *, sxu32, ProcCmp, sxu32 *);\r\ntypedef sxu32 (*ProcHash)(const void *, sxu32);\r\ntypedef sxi32 (*ProcHashSum)(const void *, sxu32, unsigned char *, sxu32);\r\ntypedef sxi32 (*ProcSort)(void *, sxu32, sxu32, ProcCmp);\r\n#define MACRO_LIST_PUSH(Head, Item)\\\r\n\tItem->pNext = Head;\\\r\n\tHead = Item; \r\n#define MACRO_LD_PUSH(Head, Item)\\\r\n\tif( Head == 0 ){\\\r\n\t\tHead = Item;\\\r\n\t}else{\\\r\n\t\tItem->pNext = Head;\\\r\n\t\tHead->pPrev = Item;\\\r\n\t\tHead = Item;\\\r\n\t}\r\n#define MACRO_LD_REMOVE(Head, Item)\\\r\n\tif( Head == Item ){\\\r\n\t\tHead = Head->pNext;\\\r\n\t}\\\r\n\tif( Item->pPrev ){ Item->pPrev->pNext = Item->pNext;}\\\r\n\tif( Item->pNext ){ Item->pNext->pPrev = Item->pPrev;}\r\n/*\r\n * A generic dynamic set.\r\n */\r\nstruct SySet\r\n{\r\n\tSyMemBackend *pAllocator; /* Memory backend */\r\n\tvoid *pBase;              /* Base pointer */\t\r\n\tsxu32 nUsed;              /* Total number of used slots  */\r\n\tsxu32 nSize;              /* Total number of available slots */\r\n\tsxu32 eSize;              /* Size of a single slot */\r\n\tsxu32 nCursor;\t          /* Loop cursor */\t\r\n\tvoid *pUserData;          /* User private data associated with this container */\r\n};\r\n#define SySetBasePtr(S)           ((S)->pBase)\r\n#define SySetBasePtrJump(S, OFFT)  (&((char *)(S)->pBase)[OFFT*(S)->eSize])\r\n#define SySetUsed(S)              ((S)->nUsed)\r\n#define SySetSize(S)              ((S)->nSize)\r\n#define SySetElemSize(S)          ((S)->eSize) \r\n#define SySetCursor(S)            ((S)->nCursor)\r\n#define SySetGetAllocator(S)      ((S)->pAllocator)\r\n#define SySetSetUserData(S, DATA)  ((S)->pUserData = DATA)\r\n#define SySetGetUserData(S)       ((S)->pUserData)\r\n/*\r\n * A variable length containers for generic data.\r\n */\r\nstruct SyBlob\r\n{\r\n\tSyMemBackend *pAllocator; /* Memory backend */\r\n\tvoid   *pBlob;\t          /* Base pointer */\r\n\tsxu32  nByte;\t          /* Total number of used bytes */\r\n\tsxu32  mByte;\t          /* Total number of available bytes */\r\n\tsxu32  nFlags;\t          /* Blob internal flags, see below */\r\n};\r\n#define SXBLOB_LOCKED\t0x01\t/* Blob is locked [i.e: Cannot auto grow] */\r\n#define SXBLOB_STATIC\t0x02\t/* Not allocated from heap   */\r\n#define SXBLOB_RDONLY   0x04    /* Read-Only data */\r\n\r\n#define SyBlobFreeSpace(BLOB)\t ((BLOB)->mByte - (BLOB)->nByte)\r\n#define SyBlobLength(BLOB)\t     ((BLOB)->nByte)\r\n#define SyBlobData(BLOB)\t     ((BLOB)->pBlob)\r\n#define SyBlobCurData(BLOB)\t     ((void*)(&((char*)(BLOB)->pBlob)[(BLOB)->nByte]))\r\n#define SyBlobDataAt(BLOB, OFFT)\t ((void *)(&((char *)(BLOB)->pBlob)[OFFT]))\r\n#define SyBlobGetAllocator(BLOB) ((BLOB)->pAllocator)\r\n\r\n#ifndef SXMEM_POOL_INCR\r\n#define SXMEM_POOL_INCR\t\t\t3\r\n#endif\r\n#ifndef SXMEM_POOL_NBUCKETS\r\n#define SXMEM_POOL_NBUCKETS\t\t12\r\n#endif\r\n#define SXMEM_BACKEND_MAGIC\t0xBAC3E67D\r\n#define SXMEM_BACKEND_CORRUPT(BACKEND)\t(BACKEND == 0 || BACKEND->nMagic != SXMEM_BACKEND_MAGIC)\r\n\r\n#define SXMEM_BACKEND_RETRY\t3\r\n/* A memory backend subsystem is defined by an instance of the following structures */\r\ntypedef union SyMemHeader SyMemHeader;\r\ntypedef struct SyMemBlock SyMemBlock;\r\nstruct SyMemBlock\r\n{\r\n\tSyMemBlock *pNext, *pPrev; /* Chain of allocated memory blocks */\r\n#ifdef UNTRUST\r\n\tsxu32 nGuard;             /* magic number associated with each valid block, so we\r\n\t\t\t\t\t\t\t   * can detect misuse.\r\n\t\t\t\t\t\t\t   */\r\n#endif\r\n};\r\n/*\r\n * Header associated with each valid memory pool block.\r\n */\r\nunion SyMemHeader\r\n{\r\n\tSyMemHeader *pNext; /* Next chunk of size 1 << (nBucket + SXMEM_POOL_INCR) in the list */\r\n\tsxu32 nBucket;      /* Bucket index in aPool[] */\r\n};\r\nstruct SyMemBackend\r\n{\r\n\tconst SyMutexMethods *pMutexMethods; /* Mutex methods */\r\n\tconst SyMemMethods *pMethods;  /* Memory allocation methods */\r\n\tSyMemBlock *pBlocks;           /* List of valid memory blocks */\r\n\tsxu32 nBlock;                  /* Total number of memory blocks allocated so far */\r\n\tProcMemError xMemError;        /* Out-of memory callback */\r\n\tvoid *pUserData;               /* First arg to xMemError() */\r\n\tSyMutex *pMutex;               /* Per instance mutex */\r\n\tsxu32 nMagic;                  /* Sanity check against misuse */\r\n\tSyMemHeader *apPool[SXMEM_POOL_NBUCKETS+SXMEM_POOL_INCR]; /* Pool of memory chunks */\r\n};\r\n/* Mutex types */\r\n#define SXMUTEX_TYPE_FAST\t1\r\n#define SXMUTEX_TYPE_RECURSIVE\t2\r\n#define SXMUTEX_TYPE_STATIC_1\t3\r\n#define SXMUTEX_TYPE_STATIC_2\t4\r\n#define SXMUTEX_TYPE_STATIC_3\t5\r\n#define SXMUTEX_TYPE_STATIC_4\t6\r\n#define SXMUTEX_TYPE_STATIC_5\t7\r\n#define SXMUTEX_TYPE_STATIC_6\t8\r\n\r\n#define SyMutexGlobalInit(METHOD){\\\r\n\tif( (METHOD)->xGlobalInit ){\\\r\n\t(METHOD)->xGlobalInit();\\\r\n\t}\\\r\n}\r\n#define SyMutexGlobalRelease(METHOD){\\\r\n\tif( (METHOD)->xGlobalRelease ){\\\r\n\t(METHOD)->xGlobalRelease();\\\r\n\t}\\\r\n}\r\n#define SyMutexNew(METHOD, TYPE)\t\t\t(METHOD)->xNew(TYPE)\r\n#define SyMutexRelease(METHOD, MUTEX){\\\r\n\tif( MUTEX && (METHOD)->xRelease ){\\\r\n\t\t(METHOD)->xRelease(MUTEX);\\\r\n\t}\\\r\n}\r\n#define SyMutexEnter(METHOD, MUTEX){\\\r\n\tif( MUTEX ){\\\r\n\t(METHOD)->xEnter(MUTEX);\\\r\n\t}\\\r\n}\r\n#define SyMutexTryEnter(METHOD, MUTEX){\\\r\n\tif( MUTEX && (METHOD)->xTryEnter ){\\\r\n\t(METHOD)->xTryEnter(MUTEX);\\\r\n\t}\\\r\n}\r\n#define SyMutexLeave(METHOD, MUTEX){\\\r\n\tif( MUTEX ){\\\r\n\t(METHOD)->xLeave(MUTEX);\\\r\n\t}\\\r\n}\r\n/* Comparison, byte swap, byte copy macros */\r\n#define SX_MACRO_FAST_CMP(X1, X2, SIZE, RC){\\\r\n\tregister unsigned char *r1 = (unsigned char *)X1;\\\r\n\tregister unsigned char *r2 = (unsigned char *)X2;\\\r\n\tregister sxu32 LEN = SIZE;\\\r\n\tfor(;;){\\\r\n\t  if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\\\r\n\t  if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\\\r\n\t  if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\\\r\n\t  if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\\\r\n\t}\\\r\n\tRC = !LEN ? 0 : r1[0] - r2[0];\\\r\n}\r\n#define\tSX_MACRO_FAST_MEMCPY(SRC, DST, SIZ){\\\r\n\tregister unsigned char *xSrc = (unsigned char *)SRC;\\\r\n\tregister unsigned char *xDst = (unsigned char *)DST;\\\r\n\tregister sxu32 xLen = SIZ;\\\r\n\tfor(;;){\\\r\n\t    if( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\\\r\n\t\tif( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\\\r\n\t\tif( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\\\r\n\t\tif( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\\\r\n\t}\\\r\n}\r\n#define SX_MACRO_BYTE_SWAP(X, Y, Z){\\\r\n\tregister unsigned char *s = (unsigned char *)X;\\\r\n\tregister unsigned char *d = (unsigned char *)Y;\\\r\n\tsxu32\tZLong = Z;  \\\r\n\tsxi32 c; \\\r\n\tfor(;;){\\\r\n\t  if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\\\r\n\t  if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\\\r\n\t  if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\\\r\n\t  if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\\\r\n\t}\\\r\n}\r\n#define SX_MSEC_PER_SEC\t(1000)\t\t\t/* Millisec per seconds */\r\n#define SX_USEC_PER_SEC\t(1000000)\t\t/* Microsec per seconds */\r\n#define SX_NSEC_PER_SEC\t(1000000000)\t/* Nanosec per seconds */\r\n#endif /* SYMISC_PRIVATE_DEFS */\r\n/* Symisc Run-time API auxiliary definitions */\r\n#if !defined(SYMISC_PRIVATE_AUX_DEFS)\r\n#define SYMISC_PRIVATE_AUX_DEFS\r\n\r\ntypedef struct SyHashEntry_Pr SyHashEntry_Pr;\r\ntypedef struct SyHashEntry SyHashEntry;\r\ntypedef struct SyHash SyHash;\r\n/*\r\n * Each public hashtable entry is represented by an instance\r\n * of the following structure.\r\n */\r\nstruct SyHashEntry\r\n{\r\n\tconst void *pKey; /* Hash key */\r\n\tsxu32 nKeyLen;    /* Key length */\r\n\tvoid *pUserData;  /* User private data */\r\n};\r\n#define SyHashEntryGetUserData(ENTRY) ((ENTRY)->pUserData)\r\n#define SyHashEntryGetKey(ENTRY)      ((ENTRY)->pKey)\r\n/* Each active hashtable is identified by an instance of the following structure */\r\nstruct SyHash\r\n{\r\n\tSyMemBackend *pAllocator;         /* Memory backend */\r\n\tProcHash xHash;                   /* Hash function */\r\n\tProcCmp xCmp;                     /* Comparison function */\r\n\tSyHashEntry_Pr *pList, *pCurrent;  /* Linked list of hash entries user for linear traversal */\r\n\tsxu32 nEntry;                     /* Total number of entries */\r\n\tSyHashEntry_Pr **apBucket;        /* Hash buckets */\r\n\tsxu32 nBucketSize;                /* Current bucket size */\r\n};\r\n#define SXHASH_BUCKET_SIZE 16 /* Initial bucket size: must be a power of two */\r\n#define SXHASH_FILL_FACTOR 3\r\n/* Hash access macro */\r\n#define SyHashFunc(HASH)\t\t((HASH)->xHash)\r\n#define SyHashCmpFunc(HASH)\t\t((HASH)->xCmp)\r\n#define SyHashTotalEntry(HASH)\t((HASH)->nEntry)\r\n#define SyHashGetPool(HASH)\t\t((HASH)->pAllocator)\r\n/*\r\n * An instance of the following structure define a single context\r\n * for an Pseudo Random Number Generator.\r\n *\r\n * Nothing in this file or anywhere else in the library does any kind of\r\n * encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random\r\n * number generator) not as an encryption device.\r\n * This implementation is taken from the SQLite3 source tree.\r\n */\r\ntypedef struct SyPRNGCtx SyPRNGCtx;\r\nstruct SyPRNGCtx\r\n{\r\n    sxu8 i, j;\t\t\t\t/* State variables */\r\n    unsigned char s[256];   /* State variables */\r\n\tsxu16 nMagic;\t\t\t/* Sanity check */\r\n };\r\ntypedef sxi32 (*ProcRandomSeed)(void *, unsigned int, void *);\r\n/* High resolution timer.*/\r\ntypedef struct sytime sytime;\r\nstruct sytime\r\n{\r\n\tlong tm_sec;\t/* seconds */\r\n\tlong tm_usec;\t/* microseconds */\r\n};\r\n/* Forward declaration */\r\ntypedef struct SyStream SyStream;\r\ntypedef struct SyToken  SyToken;\r\ntypedef struct SyLex    SyLex;\r\n/*\r\n * Tokenizer callback signature.\r\n */\r\ntypedef sxi32 (*ProcTokenizer)(SyStream *, SyToken *, void *, void *);\r\n/*\r\n * Each token in the input is represented by an instance\r\n * of the following structure.\r\n */\r\nstruct SyToken\r\n{\r\n\tSyString sData;  /* Token text and length */\r\n\tsxu32 nType;     /* Token type */\r\n\tsxu32 nLine;     /* Token line number */\r\n\tvoid *pUserData; /* User private data associated with this token */\r\n};\r\n/*\r\n * During tokenization, information about the state of the input\r\n * stream is held in an instance of the following structure.\r\n */\r\nstruct SyStream\r\n{\r\n\tconst unsigned char *zInput; /* Complete text of the input */\r\n\tconst unsigned char *zText; /* Current input we are processing */\t\r\n\tconst unsigned char *zEnd; /* End of input marker */\r\n\tsxu32  nLine; /* Total number of processed lines */\r\n\tsxu32  nIgn; /* Total number of ignored tokens */\r\n\tSySet *pSet; /* Token containers */\r\n};\r\n/*\r\n * Each lexer is represented by an instance of the following structure.\r\n */\r\nstruct SyLex\r\n{\r\n\tSyStream sStream;         /* Input stream */\r\n\tProcTokenizer xTokenizer; /* Tokenizer callback */\r\n\tvoid * pUserData;         /* Third argument to xTokenizer() */\r\n\tSySet *pTokenSet;         /* Token set */\r\n};\r\n#define SyLexTotalToken(LEX)    SySetTotalEntry(&(LEX)->aTokenSet)\r\n#define SyLexTotalLines(LEX)    ((LEX)->sStream.nLine)\r\n#define SyLexTotalIgnored(LEX)  ((LEX)->sStream.nIgn)\r\n#define XLEX_IN_LEN(STREAM)     (sxu32)(STREAM->zEnd - STREAM->zText)\r\n#endif /* SYMISC_PRIVATE_AUX_DEFS */\r\n/*\r\n** Notes on UTF-8 (According to SQLite3 authors):\r\n**\r\n**   Byte-0    Byte-1    Byte-2    Byte-3    Value\r\n**  0xxxxxxx                                 00000000 00000000 0xxxxxxx\r\n**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx\r\n**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx\r\n**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx\r\n**\r\n*/\r\n/*\r\n** Assuming zIn points to the first byte of a UTF-8 character, \r\n** advance zIn to point to the first byte of the next UTF-8 character.\r\n*/\r\n#define SX_JMP_UTF8(zIn, zEnd)\\\r\n\twhile(zIn < zEnd && (((unsigned char)zIn[0] & 0xc0) == 0x80) ){ zIn++; }\r\n#define SX_WRITE_UTF8(zOut, c) {                       \\\r\n  if( c<0x00080 ){                                     \\\r\n    *zOut++ = (sxu8)(c&0xFF);                          \\\r\n  }else if( c<0x00800 ){                               \\\r\n    *zOut++ = 0xC0 + (sxu8)((c>>6)&0x1F);              \\\r\n    *zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \\\r\n  }else if( c<0x10000 ){                               \\\r\n    *zOut++ = 0xE0 + (sxu8)((c>>12)&0x0F);             \\\r\n    *zOut++ = 0x80 + (sxu8)((c>>6) & 0x3F);            \\\r\n    *zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \\\r\n  }else{                                               \\\r\n    *zOut++ = 0xF0 + (sxu8)((c>>18) & 0x07);           \\\r\n    *zOut++ = 0x80 + (sxu8)((c>>12) & 0x3F);           \\\r\n    *zOut++ = 0x80 + (sxu8)((c>>6) & 0x3F);            \\\r\n    *zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \\\r\n  }                                                    \\\r\n}\r\n/* Rely on the standard ctype */\r\n#include <ctype.h>\r\n#define SyToUpper(c) toupper(c) \r\n#define SyToLower(c) tolower(c) \r\n#define SyisUpper(c) isupper(c)\r\n#define SyisLower(c) islower(c)\r\n#define SyisSpace(c) isspace(c)\r\n#define SyisBlank(c) isspace(c)\r\n#define SyisAlpha(c) isalpha(c)\r\n#define SyisDigit(c) isdigit(c)\r\n#define SyisHex(c)\t isxdigit(c)\r\n#define SyisPrint(c) isprint(c)\r\n#define SyisPunct(c) ispunct(c)\r\n#define SyisSpec(c)\t iscntrl(c)\r\n#define SyisCtrl(c)\t iscntrl(c)\r\n#define SyisAscii(c) isascii(c)\r\n#define SyisAlphaNum(c) isalnum(c)\r\n#define SyisGraph(c)     isgraph(c)\r\n#define SyDigToHex(c)    \"0123456789ABCDEF\"[c & 0x0F] \t\t\r\n#define SyDigToInt(c)     ((c < 0xc0 && SyisDigit(c))? (c - '0') : 0 )\r\n#define SyCharToUpper(c)  ((c < 0xc0 && SyisLower(c))? SyToUpper(c) : c)\r\n#define SyCharToLower(c)  ((c < 0xc0 && SyisUpper(c))? SyToLower(c) : c)\r\n/* Remove white space/NUL byte from a raw string */\r\n#define SyStringLeftTrim(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0 && SyisSpace((RAW)->zString[0])){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t\t(RAW)->zString++;\\\r\n\t}\r\n#define SyStringLeftTrimSafe(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0 && ((RAW)->zString[0] == 0 || SyisSpace((RAW)->zString[0]))){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t\t(RAW)->zString++;\\\r\n\t}\r\n#define SyStringRightTrim(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && SyisSpace((RAW)->zString[(RAW)->nByte - 1])){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringRightTrimSafe(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && \\\r\n\t(( RAW)->zString[(RAW)->nByte - 1] == 0 || SyisSpace((RAW)->zString[(RAW)->nByte - 1]))){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n\r\n#define SyStringFullTrim(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0  && SyisSpace((RAW)->zString[0])){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t\t(RAW)->zString++;\\\r\n\t}\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && SyisSpace((RAW)->zString[(RAW)->nByte - 1])){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n#define SyStringFullTrimSafe(RAW)\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0  && \\\r\n          ( (RAW)->zString[0] == 0 || SyisSpace((RAW)->zString[0]))){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t\t(RAW)->zString++;\\\r\n\t}\\\r\n\twhile((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && \\\r\n                   ( (RAW)->zString[(RAW)->nByte - 1] == 0 || SyisSpace((RAW)->zString[(RAW)->nByte - 1]))){\\\r\n\t\t(RAW)->nByte--;\\\r\n\t}\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\n/* \r\n * An XML raw text, CDATA, tag name and son is parsed out and stored\r\n * in an instance of the following structure.\r\n */\r\ntypedef struct SyXMLRawStr SyXMLRawStr;\r\nstruct SyXMLRawStr\r\n{\r\n\tconst char *zString; /* Raw text [UTF-8 ENCODED EXCEPT CDATA] [NOT NULL TERMINATED] */\r\n\tsxu32 nByte; /* Text length */\r\n\tsxu32 nLine; /* Line number this text occurs */\r\n};\r\n/*\r\n * Event callback signatures.\r\n */\r\ntypedef sxi32 (*ProcXMLStartTagHandler)(SyXMLRawStr *, SyXMLRawStr *, sxu32, SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLTextHandler)(SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLEndTagHandler)(SyXMLRawStr *, SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLPIHandler)(SyXMLRawStr *, SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLDoctypeHandler)(SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLSyntaxErrorHandler)(const char *, int, SyToken *, void *);\r\ntypedef sxi32 (*ProcXMLStartDocument)(void *);\r\ntypedef sxi32 (*ProcXMLNameSpaceStart)(SyXMLRawStr *, SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLNameSpaceEnd)(SyXMLRawStr *, void *);\r\ntypedef sxi32 (*ProcXMLEndDocument)(void *);\r\n/* XML processing control flags */\r\n#define SXML_ENABLE_NAMESPACE\t    0x01 /* Parse XML with namespace support enbaled */\r\n#define SXML_ENABLE_QUERY\t\t    0x02 /* Not used */\t\r\n#define SXML_OPTION_CASE_FOLDING    0x04 /* Controls whether case-folding is enabled for this XML parser */\r\n#define SXML_OPTION_SKIP_TAGSTART   0x08 /* Specify how many characters should be skipped in the beginning of a tag name.*/\r\n#define SXML_OPTION_SKIP_WHITE      0x10 /* Whether to skip values consisting of whitespace characters. */\r\n#define SXML_OPTION_TARGET_ENCODING 0x20 /* Default encoding: UTF-8 */\r\n/* XML error codes */\r\nenum xml_err_code{\r\n    SXML_ERROR_NONE = 1, \r\n    SXML_ERROR_NO_MEMORY, \r\n    SXML_ERROR_SYNTAX, \r\n    SXML_ERROR_NO_ELEMENTS, \r\n    SXML_ERROR_INVALID_TOKEN, \r\n    SXML_ERROR_UNCLOSED_TOKEN, \r\n    SXML_ERROR_PARTIAL_CHAR, \r\n    SXML_ERROR_TAG_MISMATCH, \r\n    SXML_ERROR_DUPLICATE_ATTRIBUTE, \r\n    SXML_ERROR_JUNK_AFTER_DOC_ELEMENT, \r\n    SXML_ERROR_PARAM_ENTITY_REF, \r\n    SXML_ERROR_UNDEFINED_ENTITY, \r\n    SXML_ERROR_RECURSIVE_ENTITY_REF, \r\n    SXML_ERROR_ASYNC_ENTITY, \r\n    SXML_ERROR_BAD_CHAR_REF, \r\n    SXML_ERROR_BINARY_ENTITY_REF, \r\n    SXML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF, \r\n    SXML_ERROR_MISPLACED_XML_PI, \r\n    SXML_ERROR_UNKNOWN_ENCODING, \r\n    SXML_ERROR_INCORRECT_ENCODING, \r\n    SXML_ERROR_UNCLOSED_CDATA_SECTION, \r\n    SXML_ERROR_EXTERNAL_ENTITY_HANDLING\r\n};\r\n/* Each active XML SAX parser is represented by an instance \r\n * of the following structure.\r\n */\r\ntypedef struct SyXMLParser SyXMLParser;\r\nstruct SyXMLParser\r\n{\r\n\tSyMemBackend *pAllocator; /* Memory backend */\r\n\tvoid *pUserData;          /* User private data forwarded varbatim by the XML parser\r\n\t\t\t\t\t           * as the last argument to the users callbacks.\r\n\t\t\t\t\t\t       */\r\n\tSyHash hns;               /* Namespace hashtable */\r\n\tSySet sToken;             /* XML tokens */\r\n\tSyLex sLex;               /* Lexical analyzer */\r\n\tsxi32 nFlags;             /* Control flags */\r\n\t/* User callbacks */\r\n\tProcXMLStartTagHandler    xStartTag;     /* Start element handler */\r\n\tProcXMLEndTagHandler      xEndTag;       /* End element handler */\r\n\tProcXMLTextHandler        xRaw;          /* Raw text/CDATA handler   */\r\n\tProcXMLDoctypeHandler     xDoctype;      /* DOCTYPE handler */\r\n\tProcXMLPIHandler          xPi;           /* Processing instruction (PI) handler*/\r\n\tProcXMLSyntaxErrorHandler xError;        /* Error handler */\r\n\tProcXMLStartDocument      xStartDoc;     /* StartDoc handler */\r\n\tProcXMLEndDocument        xEndDoc;       /* EndDoc handler */\r\n\tProcXMLNameSpaceStart   xNameSpace;    /* Namespace declaration handler  */\r\n\tProcXMLNameSpaceEnd       xNameSpaceEnd; /* End namespace declaration handler */\r\n};\r\n/*\r\n * --------------\r\n * Archive extractor:\r\n * --------------\r\n * Each open ZIP/TAR archive is identified by an instance of the following structure.\r\n * That is, a process can open one or more archives and manipulates them in thread safe\r\n * way by simply working with pointers to the following structure.\r\n * Each entry in the archive is remembered in a hashtable.\r\n * Lookup is very fast and entry with the same name are chained together.\r\n */\r\n typedef struct SyArchiveEntry SyArchiveEntry;\r\n typedef struct SyArchive SyArchive;\r\n struct SyArchive\r\n {\r\n \tSyMemBackend\t*pAllocator; /* Memory backend */\r\n\tSyArchiveEntry *pCursor;     /* Cursor for linear traversal of archive entries */\r\n\tSyArchiveEntry *pList;       /* Pointer to the List of the loaded archive */\r\n\tSyArchiveEntry **apHash;     /* Hashtable for archive entry */\r\n\tProcRawStrCmp xCmp;          /* Hash comparison function */\r\n\tProcHash xHash;              /* Hash Function */\r\n\tsxu32 nSize;        /* Hashtable size */\r\n \tsxu32 nEntry;       /* Total number of entries in the zip/tar archive */\r\n \tsxu32 nLoaded;      /* Total number of entries loaded in memory */\r\n \tsxu32 nCentralOfft;\t/* Central directory offset(ZIP only. Otherwise Zero) */\r\n \tsxu32 nCentralSize;\t/* Central directory size(ZIP only. Otherwise Zero) */\r\n\tvoid *pUserData;    /* Upper layer private data */\r\n\tsxu32 nMagic;       /* Sanity check */\r\n\t\r\n };\r\n#define SXARCH_MAGIC\t0xDEAD635A\r\n#define SXARCH_INVALID(ARCH)            (ARCH == 0  || ARCH->nMagic != SXARCH_MAGIC)\r\n#define SXARCH_ENTRY_INVALID(ENTRY)\t    (ENTRY == 0 || ENTRY->nMagic != SXARCH_MAGIC)\r\n#define SyArchiveHashFunc(ARCH)\t        (ARCH)->xHash\r\n#define SyArchiveCmpFunc(ARCH)\t        (ARCH)->xCmp\r\n#define SyArchiveUserData(ARCH)         (ARCH)->pUserData\r\n#define SyArchiveSetUserData(ARCH, DATA) (ARCH)->pUserData = DATA\r\n/*\r\n * Each loaded archive record is identified by an instance\r\n * of the following structure.\r\n */\r\n struct SyArchiveEntry\r\n { \t\r\n \tsxu32 nByte;         /* Contents size before compression */\r\n \tsxu32 nByteCompr;    /* Contents size after compression */\r\n\tsxu32 nReadCount;    /* Read counter */\r\n \tsxu32 nCrc;          /* Contents CRC32  */\r\n \tSytm  sFmt;\t         /* Last-modification time */\r\n \tsxu32 nOfft;         /* Data offset. */\r\n \tsxu16 nComprMeth;\t /* Compression method 0 == stored/8 == deflated and so on (see appnote.txt)*/\r\n \tsxu16 nExtra;        /* Extra size if any */\r\n \tSyString sFileName;  /* entry name & length */\r\n \tsxu32 nDup;\t/* Total number of entries with the same name */\r\n\tSyArchiveEntry *pNextHash, *pPrevHash; /* Hash collision chains */\r\n \tSyArchiveEntry *pNextName;    /* Next entry with the same name */\r\n\tSyArchiveEntry *pNext, *pPrev; /* Next and previous entry in the list */\r\n\tsxu32 nHash;     /* Hash of the entry name */\r\n \tvoid *pUserData; /* User data */ \r\n\tsxu32 nMagic;    /* Sanity check */\r\n };\r\n /*\r\n * Extra flags for extending the file local header\r\n */ \r\n#define SXZIP_EXTRA_TIMESTAMP\t0x001\t/* Extended UNIX timestamp */\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\n#ifndef JX9_DISABLE_HASH_FUNC\r\n/* MD5 context */\r\ntypedef struct MD5Context MD5Context;\r\nstruct MD5Context {\r\n sxu32 buf[4];\r\n sxu32 bits[2];\r\n unsigned char in[64];\r\n};\r\n/* SHA1 context */\r\ntypedef struct SHA1Context SHA1Context;\r\nstruct SHA1Context {\r\n  unsigned int state[5];\r\n  unsigned int count[2];\r\n  unsigned char buffer[64];\r\n};\r\n#endif /* JX9_DISABLE_HASH_FUNC */\r\n/* JX9 private declaration */\r\n/*\r\n * Memory Objects.\r\n * Internally, the JX9 virtual machine manipulates nearly all JX9 values\r\n * [i.e: string, int, float, resource, object, bool, null] as jx9_values structures.\r\n * Each jx9_values struct may cache multiple representations (string, integer etc.)\r\n * of the same value.\r\n */\r\nstruct jx9_value\r\n{\r\n\tunion{\r\n\t\tjx9_real rVal;  /* Real value */\r\n\t\tsxi64 iVal;     /* Integer value */\r\n\t\tvoid *pOther;   /* Other values (Object, Array, Resource, Namespace, etc.) */\r\n\t}x;\r\n\tsxi32 iFlags;       /* Control flags (see below) */\r\n\tjx9_vm *pVm;        /* VM this instance belong */\r\n\tSyBlob sBlob;       /* String values */\r\n\tsxu32 nIdx;         /* Object index in the global pool */\r\n};\r\n/* Allowed value types.\r\n */\r\n#define MEMOBJ_STRING    0x001  /* Memory value is a UTF-8 string */\r\n#define MEMOBJ_INT       0x002  /* Memory value is an integer */\r\n#define MEMOBJ_REAL      0x004  /* Memory value is a real number */\r\n#define MEMOBJ_BOOL      0x008  /* Memory value is a boolean */\r\n#define MEMOBJ_NULL      0x020  /* Memory value is NULL */\r\n#define MEMOBJ_HASHMAP   0x040  /* Memory value is a hashmap (JSON representation of Array and Objects)  */\r\n#define MEMOBJ_RES       0x100  /* Memory value is a resource [User private data] */\r\n/* Mask of all known types */\r\n#define MEMOBJ_ALL (MEMOBJ_STRING|MEMOBJ_INT|MEMOBJ_REAL|MEMOBJ_BOOL|MEMOBJ_NULL|MEMOBJ_HASHMAP|MEMOBJ_RES) \r\n/* Scalar variables\r\n * According to the JX9 language reference manual\r\n *  Scalar variables are those containing an integer, float, string or boolean.\r\n *  Types array, object and resource are not scalar. \r\n */\r\n#define MEMOBJ_SCALAR (MEMOBJ_STRING|MEMOBJ_INT|MEMOBJ_REAL|MEMOBJ_BOOL|MEMOBJ_NULL)\r\n/*\r\n * The following macro clear the current jx9_value type and replace\r\n * it with the given one.\r\n */\r\n#define MemObjSetType(OBJ, TYPE) ((OBJ)->iFlags = ((OBJ)->iFlags&~MEMOBJ_ALL)|TYPE)\r\n/* jx9_value cast method signature */\r\ntypedef sxi32 (*ProcMemObjCast)(jx9_value *);\r\n/* Forward reference */\r\ntypedef struct jx9_output_consumer jx9_output_consumer;\r\ntypedef struct jx9_user_func jx9_user_func;\r\ntypedef struct jx9_conf jx9_conf;\r\n/*\r\n * An instance of the following structure store the default VM output \r\n * consumer and it's private data.\r\n * Client-programs can register their own output consumer callback\r\n * via the [JX9_VM_CONFIG_OUTPUT] configuration directive.\r\n * Please refer to the official documentation for more information\r\n * on how to register an output consumer callback.\r\n */\r\nstruct jx9_output_consumer\r\n{\r\n\tProcConsumer xConsumer; /* VM output consumer routine */\r\n\tvoid *pUserData;        /* Third argument to xConsumer() */\r\n\tProcConsumer xDef;      /* Default output consumer routine */\r\n\tvoid *pDefData;         /* Third argument to xDef() */\r\n};\r\n/*\r\n * JX9 engine [i.e: jx9 instance] configuration is stored in\r\n * an instance of the following structure.\r\n * Please refer to the official documentation for more information\r\n * on how to configure your jx9 engine instance.\r\n */\r\nstruct jx9_conf\r\n{\r\n\tProcConsumer xErr;   /* Compile-time error consumer callback */\r\n\tvoid *pErrData;      /* Third argument to xErr() */\r\n\tSyBlob sErrConsumer; /* Default error consumer */\r\n};\r\n/*\r\n * Signature of the C function responsible of expanding constant values.\r\n */\r\ntypedef void (*ProcConstant)(jx9_value *, void *);\r\n/*\r\n * Each registered constant [i.e: __TIME__, __DATE__, JX9_OS, INT_MAX, etc.] is stored\r\n * in an instance of the following structure.\r\n * Please refer to the official documentation for more information\r\n * on how to create/install foreign constants.\r\n */\r\ntypedef struct jx9_constant jx9_constant;\r\nstruct jx9_constant\r\n{\r\n\tSyString sName;        /* Constant name */\r\n\tProcConstant xExpand;  /* Function responsible of expanding constant value */\r\n\tvoid *pUserData;       /* Last argument to xExpand() */\r\n};\r\ntypedef struct jx9_aux_data jx9_aux_data;\r\n/*\r\n * Auxiliary data associated with each foreign function is stored\r\n * in a stack of the following structure.\r\n * Note that automatic tracked chunks are also stored in an instance\r\n * of this structure.\r\n */\r\nstruct jx9_aux_data\r\n{\r\n\tvoid *pAuxData; /* Aux data */\r\n};\r\n/* Foreign functions signature */\r\ntypedef int (*ProcHostFunction)(jx9_context *, int, jx9_value **);\r\n/*\r\n * Each installed foreign function is recored in an instance of the following\r\n * structure.\r\n * Please refer to the official documentation for more information on how \r\n * to create/install foreign functions.\r\n */\r\nstruct jx9_user_func\r\n{\r\n\tjx9_vm *pVm;              /* VM that own this instance */\r\n\tSyString sName;           /* Foreign function name */\r\n\tProcHostFunction xFunc;  /* Implementation of the foreign function */\r\n\tvoid *pUserData;          /* User private data [Refer to the official documentation for more information]*/\r\n\tSySet aAux;               /* Stack of auxiliary data [Refer to the official documentation for more information]*/\r\n};\r\n/*\r\n * The 'context' argument for an installable function. A pointer to an\r\n * instance of this structure is the first argument to the routines used\r\n * implement the foreign functions.\r\n */\r\nstruct jx9_context\r\n{\r\n\tjx9_user_func *pFunc;   /* Function information. */\r\n\tjx9_value *pRet;        /* Return value is stored here. */\r\n\tSySet sVar;             /* Container of dynamically allocated jx9_values\r\n\t\t\t\t\t\t\t * [i.e: Garbage collection purposes.]\r\n\t\t\t\t\t\t\t */\r\n\tSySet sChunk;           /* Track dynamically allocated chunks [jx9_aux_data instance]. \r\n\t\t\t\t\t\t\t * [i.e: Garbage collection purposes.]\r\n\t\t\t\t\t\t\t */\r\n\tjx9_vm *pVm;            /* Virtual machine that own this context */\r\n\tsxi32 iFlags;           /* Call flags */\r\n};\r\n/* Hashmap control flags */\r\n#define HASHMAP_JSON_OBJECT 0x001 /* Hashmap represent JSON Object*/\r\n/*\r\n * Each hashmap entry [i.e: array(4, 5, 6)] is recorded in an instance\r\n * of the following structure.\r\n */\r\nstruct jx9_hashmap_node\r\n{\r\n\tjx9_hashmap *pMap;     /* Hashmap that own this instance */\r\n\tsxi32 iType;           /* Node type */\r\n\tunion{\r\n\t\tsxi64 iKey;        /* Int key */\r\n\t\tSyBlob sKey;       /* Blob key */\r\n\t}xKey;\r\n\tsxi32 iFlags;          /* Control flags */\r\n\tsxu32 nHash;           /* Key hash value */\r\n\tsxu32 nValIdx;         /* Value stored in this node */\r\n\tjx9_hashmap_node *pNext, *pPrev;               /* Link to other entries [i.e: linear traversal] */\r\n\tjx9_hashmap_node *pNextCollide, *pPrevCollide; /* Collision chain */\r\n};\r\n/* \r\n * Each active hashmap aka array in the JX9 jargon is represented\r\n * by an instance of the following structure.\r\n */\r\nstruct jx9_hashmap\r\n{\r\n\tjx9_vm *pVm;                  /* VM that own this instance */\r\n\tjx9_hashmap_node **apBucket;  /* Hash bucket */\r\n\tjx9_hashmap_node *pFirst;     /* First inserted entry */\r\n\tjx9_hashmap_node *pLast;      /* Last inserted entry */\r\n\tjx9_hashmap_node *pCur;       /* Current entry */\r\n\tsxu32 nSize;                  /* Bucket size */\r\n\tsxu32 nEntry;                 /* Total number of inserted entries */\r\n\tsxu32 (*xIntHash)(sxi64);     /* Hash function for int_keys */\r\n\tsxu32 (*xBlobHash)(const void *, sxu32); /* Hash function for blob_keys */\r\n\tsxi32 iFlags;                 /* Hashmap control flags */\r\n\tsxi64 iNextIdx;               /* Next available automatically assigned index */\r\n\tsxi32 iRef;                   /* Reference count */\r\n};\r\n/* An instance of the following structure is the context\r\n * for the FOREACH_STEP/FOREACH_INIT VM instructions.\r\n * Those instructions are used to implement the 'foreach'\r\n * statement.\r\n * This structure is made available to these instructions\r\n * as the P3 operand. \r\n */\r\nstruct jx9_foreach_info\r\n{\r\n\tSyString sKey;      /* Key name. Empty otherwise*/\r\n\tSyString sValue;    /* Value name */\r\n\tsxi32 iFlags;       /* Control flags */\r\n\tSySet aStep;        /* Stack of steps [i.e: jx9_foreach_step instance] */\r\n};\r\nstruct jx9_foreach_step\r\n{\r\n\tsxi32 iFlags;                   /* Control flags (see below) */\r\n\t/* Iterate on this map*/\r\n\tjx9_hashmap *pMap;          /* Hashmap [i.e: array in the JX9 jargon] iteration\r\n\t\t\t\t\t\t\t\t\t * Ex: foreach(array(1, 2, 3) as $key=>$value){} \r\n\t\t\t\t\t\t\t\t\t */\r\n\t\r\n};\r\n/* Foreach step control flags */\r\n#define JX9_4EACH_STEP_KEY     0x001 /* Make Key available */\r\n/*\r\n * Each JX9 engine is identified by an instance of the following structure.\r\n * Please refer to the official documentation for more information\r\n * on how to configure your JX9 engine instance.\r\n */\r\nstruct jx9\r\n{\r\n\tSyMemBackend sAllocator;     /* Low level memory allocation subsystem */\r\n\tconst jx9_vfs *pVfs;         /* Underlying Virtual File System */\r\n\tjx9_conf xConf;              /* Configuration */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tSyMutex *pMutex;                 /* Per-engine mutex */\r\n#endif\r\n\tjx9_vm *pVms;      /* List of active VM */\r\n\tsxi32 iVm;         /* Total number of active VM */\r\n\tjx9 *pNext, *pPrev; /* List of active engines */\r\n\tsxu32 nMagic;      /* Sanity check against misuse */\r\n};\r\n/* Code generation data structures */\r\ntypedef sxi32 (*ProcErrorGen)(void *, sxi32, sxu32, const char *, ...);\r\ntypedef struct jx9_expr_node   jx9_expr_node;\r\ntypedef struct jx9_expr_op     jx9_expr_op;\r\ntypedef struct jx9_gen_state   jx9_gen_state;\r\ntypedef struct GenBlock        GenBlock;\r\ntypedef sxi32 (*ProcLangConstruct)(jx9_gen_state *);\r\ntypedef sxi32 (*ProcNodeConstruct)(jx9_gen_state *, sxi32);\r\n/*\r\n * Each supported operator [i.e: +, -, ==, *, %, >>, >=, new, etc.] is represented\r\n * by an instance of the following structure.\r\n * The JX9 parser does not use any external tools and is 100% handcoded.\r\n * That is, the JX9 parser is thread-safe , full reentrant, produce consistant \r\n * compile-time errrors and at least 7 times faster than the standard JX9 parser.\r\n */\r\nstruct jx9_expr_op\r\n{\r\n\tSyString sOp;   /* String representation of the operator [i.e: \"+\", \"*\", \"==\"...] */\r\n\tsxi32 iOp;      /* Operator ID */\r\n\tsxi32 iPrec;    /* Operator precedence: 1 == Highest */ \r\n\tsxi32 iAssoc;   /* Operator associativity (either left, right or non-associative) */ \r\n\tsxi32 iVmOp;    /* VM OP code for this operator [i.e: JX9_OP_EQ, JX9_OP_LT, JX9_OP_MUL...]*/\r\n};\r\n/*\r\n * Each expression node is parsed out and recorded\r\n * in an instance of the following structure.\r\n */\r\nstruct jx9_expr_node\r\n{\r\n\tconst jx9_expr_op *pOp;  /* Operator ID or NULL if literal, constant, variable, function or object method call */\r\n\tjx9_expr_node *pLeft;    /* Left expression tree */\r\n\tjx9_expr_node *pRight;   /* Right expression tree */\r\n\tSyToken *pStart;         /* Stream of tokens that belong to this node */\r\n\tSyToken *pEnd;           /* End of token stream */\r\n\tsxi32 iFlags;            /* Node construct flags */\r\n\tProcNodeConstruct xCode; /* C routine responsible of compiling this node */\r\n\tSySet aNodeArgs;         /* Node arguments. Only used by postfix operators [i.e: function call]*/\r\n\tjx9_expr_node *pCond;    /* Condition: Only used by the ternary operator '?:' */\r\n};\r\n/* Node Construct flags */\r\n#define EXPR_NODE_PRE_INCR 0x01 /* Pre-icrement/decrement [i.e: ++$i, --$j] node */\r\n/*\r\n * A block of instructions is recorded in an instance of the following structure.\r\n * This structure is used only during compile-time and have no meaning\r\n * during bytecode execution.\r\n */\r\nstruct GenBlock\r\n{\r\n\tjx9_gen_state *pGen;  /* State of the code generator */\r\n\tGenBlock *pParent;    /* Upper block or NULL if global */\r\n\tsxu32 nFirstInstr;    /* First instruction to execute  */\r\n\tsxi32 iFlags;         /* Block control flags (see below) */\r\n\tSySet aJumpFix;       /* Jump fixup (JumpFixup instance) */\r\n\tvoid *pUserData;      /* Upper layer private data */\r\n\t/* The following two fields are used only when compiling \r\n\t * the 'do..while()' language construct.\r\n\t */\r\n\tsxu8 bPostContinue;    /* TRUE when compiling the do..while() statement */\r\n\tSySet aPostContFix;    /* Post-continue jump fix */\r\n};\r\n/*\r\n * Code generator state is remembered in an instance of the following\r\n * structure. We put the information in this structure and pass around\r\n * a pointer to this structure, rather than pass around  all of the \r\n * information separately. This helps reduce the number of  arguments\r\n * to generator functions.\r\n * This structure is used only during compile-time and have no meaning\r\n * during bytecode execution.\r\n */\r\nstruct jx9_gen_state\r\n{\r\n\tjx9_vm *pVm;         /* VM that own this instance */\r\n\tSyHash hLiteral;     /* Constant string Literals table */\r\n\tSyHash hNumLiteral;  /* Numeric literals table */\r\n\tSyHash hVar;         /* Collected variable hashtable */\r\n\tGenBlock *pCurrent;  /* Current processed block */\r\n\tGenBlock sGlobal;    /* Global block */\r\n\tProcConsumer xErr;   /* Error consumer callback */\r\n\tvoid *pErrData;      /* Third argument to xErr() */\r\n\tSyToken *pIn;        /* Current processed token */\r\n\tSyToken *pEnd;       /* Last token in the stream */\r\n\tsxu32 nErr;          /* Total number of compilation error */\r\n};\r\n/* Forward references */\r\ntypedef struct jx9_vm_func_static_var  jx9_vm_func_static_var;\r\ntypedef struct jx9_vm_func_arg jx9_vm_func_arg;\r\ntypedef struct jx9_vm_func jx9_vm_func;\r\ntypedef struct VmFrame VmFrame;\r\n/*\r\n * Each collected function argument is recorded in an instance\r\n * of the following structure.\r\n * Note that as an extension, JX9 implements full type hinting\r\n * which mean that any function can have it's own signature.\r\n * Example:\r\n *      function foo(int $a, string $b, float $c, ClassInstance $d){}\r\n * This is how the powerful function overloading mechanism is\r\n * implemented.\r\n * Note that as an extension, JX9 allow function arguments to have\r\n * any complex default value associated with them unlike the standard\r\n * JX9 engine.\r\n * Example:\r\n *    function foo(int $a = rand() & 1023){}\r\n *    now, when foo is called without arguments [i.e: foo()] the\r\n *    $a variable (first parameter) will be set to a random number\r\n *    between 0 and 1023 inclusive.\r\n * Refer to the official documentation for more information on this\r\n * mechanism and other extension introduced by the JX9 engine.\r\n */\r\nstruct jx9_vm_func_arg\r\n{\r\n\tSyString sName;      /* Argument name */\r\n\tSySet aByteCode;     /* Compiled default value associated with this argument */\r\n\tsxu32 nType;         /* Type of this argument [i.e: array, int, string, float, object, etc.] */\r\n\tsxi32 iFlags;        /* Configuration flags */\r\n};\r\n/*\r\n * Each static variable is parsed out and remembered in an instance\r\n * of the following structure.\r\n * Note that as an extension, JX9 allow static variable have\r\n * any complex default value associated with them unlike the standard\r\n * JX9 engine.\r\n * Example:\r\n *   static $rand_str = 'JX9'.rand_str(3); // Concatenate 'JX9' with \r\n *                                         // a random three characters(English alphabet)\r\n *   dump($rand_str);\r\n *   //You should see something like this\r\n *   string(6 'JX9awt');   \r\n */\r\nstruct jx9_vm_func_static_var\r\n{\r\n\tSyString sName;   /* Static variable name */\r\n\tSySet aByteCode;  /* Compiled initialization expression  */\r\n\tsxu32 nIdx;       /* Object index in the global memory object container */\r\n};\r\n/* Function configuration flags */\r\n#define VM_FUNC_ARG_HAS_DEF  0x001 /* Argument has default value associated with it */\r\n#define VM_FUNC_ARG_IGNORE   0x002 /* Do not install argument in the current frame */\r\n/*\r\n * Each user defined function is parsed out and stored in an instance\r\n * of the following structure.\r\n * JX9 introduced some powerfull extensions to the JX9 5 programming\r\n * language like function overloading, type hinting, complex default\r\n * arguments values and many more.\r\n * Please refer to the official documentation for more information.\r\n */\r\nstruct jx9_vm_func\r\n{\r\n\tSySet aArgs;         /* Expected arguments (jx9_vm_func_arg instance) */\r\n\tSySet aStatic;       /* Static variable (jx9_vm_func_static_var instance) */\r\n\tSyString sName;      /* Function name */\r\n\tSySet aByteCode;     /* Compiled function body */\r\n\tsxi32 iFlags;        /* VM function configuration */\r\n\tSyString sSignature; /* Function signature used to implement function overloading\r\n\t\t\t\t\t\t  * (Refer to the official docuemntation for more information\r\n\t\t\t\t\t\t  *  on this powerfull feature)\r\n\t\t\t\t\t\t  */\r\n\tvoid *pUserData;     /* Upper layer private data associated with this instance */\r\n\tjx9_vm_func *pNextName; /* Next VM function with the same name as this one */\r\n};\r\n/* Forward reference */\r\ntypedef struct jx9_builtin_constant jx9_builtin_constant;\r\ntypedef struct jx9_builtin_func jx9_builtin_func;\r\n/*\r\n * Each built-in foreign function (C function) is stored in an\r\n * instance of the following structure.\r\n * Please refer to the official documentation for more information\r\n * on how to create/install foreign functions.\r\n */\r\nstruct jx9_builtin_func\r\n{\r\n\tconst char *zName;        /* Function name [i.e: strlen(), rand(), array_merge(), etc.]*/\r\n\tProcHostFunction xFunc;  /* C routine performing the computation */\r\n};\r\n/*\r\n * Each built-in foreign constant is stored in an instance\r\n * of the following structure.\r\n * Please refer to the official documentation for more information\r\n * on how to create/install foreign constants.\r\n */\r\nstruct jx9_builtin_constant\r\n{\r\n\tconst char *zName;     /* Constant name */\r\n\tProcConstant xExpand;  /* C routine responsible of expanding constant value*/\r\n};\r\n/*\r\n * A single instruction of the virtual machine has an opcode\r\n * and as many as three operands.\r\n * Each VM instruction resulting from compiling a JX9 script\r\n * is stored in an instance of the following structure.\r\n */\r\ntypedef struct VmInstr VmInstr;\r\nstruct VmInstr\r\n{\r\n\tsxu8  iOp; /* Operation to preform */\r\n\tsxi32 iP1; /* First operand */\r\n\tsxu32 iP2; /* Second operand (Often the jump destination) */\r\n\tvoid *p3;  /* Third operand (Often Upper layer private data) */\r\n};\r\n/* Forward reference */\r\ntypedef struct jx9_case_expr jx9_case_expr;\r\ntypedef struct jx9_switch jx9_switch;\r\n/*\r\n * Each compiled case block in a swicth statement is compiled\r\n * and stored in an instance of the following structure.\r\n */\r\nstruct jx9_case_expr\r\n{\r\n\tSySet aByteCode;   /* Compiled body of the case block */\r\n\tsxu32 nStart;      /* First instruction to execute */\r\n};\r\n/*\r\n * Each compiled switch statement is parsed out and stored\r\n * in an instance of the following structure.\r\n */\r\nstruct jx9_switch\r\n{\r\n\tSySet aCaseExpr;  /* Compile case block */\r\n\tsxu32 nOut;       /* First instruction to execute after this statement */\r\n\tsxu32 nDefault;   /* First instruction to execute in the default block */\r\n};\r\n/* Assertion flags */\r\n#define JX9_ASSERT_DISABLE    0x01  /* Disable assertion */\r\n#define JX9_ASSERT_WARNING    0x02  /* Issue a warning for each failed assertion */\r\n#define JX9_ASSERT_BAIL       0x04  /* Terminate execution on failed assertions */\r\n#define JX9_ASSERT_QUIET_EVAL 0x08  /* Not used */\r\n#define JX9_ASSERT_CALLBACK   0x10  /* Callback to call on failed assertions */\r\n/* \r\n * An instance of the following structure hold the bytecode instructions\r\n * resulting from compiling a JX9 script.\r\n * This structure contains the complete state of the virtual machine.\r\n */\r\nstruct jx9_vm\r\n{\r\n\tSyMemBackend sAllocator;\t/* Memory backend */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tSyMutex *pMutex;           /* Recursive mutex associated with this VM. */\r\n#endif\r\n\tjx9 *pEngine;               /* Interpreter that own this VM */\r\n\tSySet aByteCode;            /* Default bytecode container */\r\n\tSySet *pByteContainer;      /* Current bytecode container */\r\n\tVmFrame *pFrame;            /* Stack of active frames */\r\n\tSyPRNGCtx sPrng;            /* PRNG context */\r\n\tSySet aMemObj;              /* Object allocation table */\r\n\tSySet aLitObj;              /* Literals allocation table */\r\n\tjx9_value *aOps;            /* Operand stack */\r\n\tSySet aFreeObj;             /* Stack of free memory objects */\r\n\tSyHash hConstant;           /* Host-application and user defined constants container */\r\n\tSyHash hHostFunction;       /* Host-application installable functions */\r\n\tSyHash hFunction;           /* Compiled functions */\r\n\tSyHash hSuper;              /* Global variable */\r\n\tSyBlob sConsumer;           /* Default VM consumer [i.e Redirect all VM output to this blob] */\r\n\tSyBlob sWorker;             /* General purpose working buffer */\r\n\tSyBlob sArgv;               /* $argv[] collector [refer to the [getopt()] implementation for more information] */\r\n\tSySet aFiles;               /* Stack of processed files */\r\n\tSySet aPaths;               /* Set of import paths */\r\n\tSySet aIncluded;            /* Set of included files */\r\n\tSySet aIOstream;            /* Installed IO stream container */\r\n\tconst jx9_io_stream *pDefStream; /* Default IO stream [i.e: typically this is the 'file://' stream] */\r\n\tjx9_value sExec;           /* Compiled script return value [Can be extracted via the JX9_VM_CONFIG_EXEC_VALUE directive]*/\r\n\tvoid *pStdin;              /* STDIN IO stream */\r\n\tvoid *pStdout;             /* STDOUT IO stream */\r\n\tvoid *pStderr;             /* STDERR IO stream */\r\n\tint bErrReport;            /* TRUE to report all runtime Error/Warning/Notice */\r\n\tint nRecursionDepth;       /* Current recursion depth */\r\n\tint nMaxDepth;             /* Maximum allowed recusion depth */\r\n\tsxu32 nOutputLen;          /* Total number of generated output */\r\n\tjx9_output_consumer sVmConsumer; /* Registered output consumer callback */\r\n\tint iAssertFlags;          /* Assertion flags */\r\n\tjx9_value sAssertCallback; /* Callback to call on failed assertions */\r\n\tsxi32 iExitStatus;         /* Script exit status */\r\n\tjx9_gen_state sCodeGen;    /* Code generator module */\r\n\tjx9_vm *pNext, *pPrev;      /* List of active VM's */\r\n\tsxu32 nMagic;              /* Sanity check against misuse */\r\n};\r\n/*\r\n * Allowed value for jx9_vm.nMagic\r\n */\r\n#define JX9_VM_INIT   0xEA12CD72  /* VM correctly initialized */\r\n#define JX9_VM_RUN    0xBA851227  /* VM ready to execute JX9 bytecode */\r\n#define JX9_VM_EXEC   0xCDFE1DAD  /* VM executing JX9 bytecode */\r\n#define JX9_VM_STALE  0xDEAD2BAD  /* Stale VM */\r\n/*\r\n * Error codes according to the JX9 language reference manual.\r\n */\r\nenum iErrCode\r\n{\r\n\tE_ABORT             = -1,  /* deadliness error should halt script execution. */\r\n\tE_ERROR             = 1,   /* Fatal run-time errors. These indicate errors that can not be recovered \r\n\t\t\t\t\t\t\t    * from, such as a memory allocation problem. Execution of the script is\r\n\t\t\t\t\t\t\t    * halted.\r\n\t\t\t\t\t\t\t\t* The only fatal error under JX9 is an out-of-memory. All others erros\r\n\t\t\t\t\t\t\t\t* even a call to undefined function will not halt script execution.\r\n\t\t\t\t\t\t\t    */\r\n\tE_WARNING           ,   /* Run-time warnings (non-fatal errors). Execution of the script is not halted.  */\r\n\tE_PARSE             ,   /* Compile-time parse errors. Parse errors should only be generated by the parser.*/\r\n\tE_NOTICE            ,   /* Run-time notices. Indicate that the script encountered something that could \r\n\t\t\t\t\t\t\t    * indicate an error, but could also happen in the normal course of running a script. \r\n\t\t\t\t\t\t\t    */\r\n};\r\n/*\r\n * Each VM instruction resulting from compiling a JX9 script is represented\r\n * by one of the following OP codes.\r\n * The program consists of a linear sequence of operations. Each operation\r\n * has an opcode and 3 operands.Operands P1 is an integer.\r\n * Operand P2 is an unsigned integer and operand P3 is a memory address.\r\n * Few opcodes use all 3 operands.\r\n */\r\nenum jx9_vm_op {\r\n  JX9_OP_DONE =   1,   /* Done */\r\n  JX9_OP_HALT,         /* Halt */\r\n  JX9_OP_LOAD,         /* Load memory object */\r\n  JX9_OP_LOADC,        /* Load constant */\r\n  JX9_OP_LOAD_IDX,     /* Load array entry */   \r\n  JX9_OP_LOAD_MAP,     /* Load hashmap('array') */\r\n  JX9_OP_NOOP,         /* NOOP */\r\n  JX9_OP_JMP,          /* Unconditional jump */\r\n  JX9_OP_JZ,           /* Jump on zero (FALSE jump) */\r\n  JX9_OP_JNZ,          /* Jump on non-zero (TRUE jump) */\r\n  JX9_OP_POP,          /* Stack POP */ \r\n  JX9_OP_CAT,          /* Concatenation */\r\n  JX9_OP_CVT_INT,      /* Integer cast */\r\n  JX9_OP_CVT_STR,      /* String cast */\r\n  JX9_OP_CVT_REAL,     /* Float cast */\r\n  JX9_OP_CALL,         /* Function call */\r\n  JX9_OP_UMINUS,       /* Unary minus '-'*/\r\n  JX9_OP_UPLUS,        /* Unary plus '+'*/\r\n  JX9_OP_BITNOT,       /* Bitwise not '~' */\r\n  JX9_OP_LNOT,         /* Logical not '!' */\r\n  JX9_OP_MUL,          /* Multiplication '*' */\r\n  JX9_OP_DIV,          /* Division '/' */\r\n  JX9_OP_MOD,          /* Modulus '%' */\r\n  JX9_OP_ADD,          /* Add '+' */\r\n  JX9_OP_SUB,          /* Sub '-' */\r\n  JX9_OP_SHL,          /* Left shift '<<' */\r\n  JX9_OP_SHR,          /* Right shift '>>' */\r\n  JX9_OP_LT,           /* Less than '<' */\r\n  JX9_OP_LE,           /* Less or equal '<=' */\r\n  JX9_OP_GT,           /* Greater than '>' */\r\n  JX9_OP_GE,           /* Greater or equal '>=' */\r\n  JX9_OP_EQ,           /* Equal '==' */\r\n  JX9_OP_NEQ,          /* Not equal '!=' */\r\n  JX9_OP_TEQ,          /* Type equal '===' */\r\n  JX9_OP_TNE,          /* Type not equal '!==' */\r\n  JX9_OP_BAND,         /* Bitwise and '&' */\r\n  JX9_OP_BXOR,         /* Bitwise xor '^' */\r\n  JX9_OP_BOR,          /* Bitwise or '|' */\r\n  JX9_OP_LAND,         /* Logical and '&&','and' */\r\n  JX9_OP_LOR,          /* Logical or  '||','or' */\r\n  JX9_OP_LXOR,         /* Logical xor 'xor' */\r\n  JX9_OP_STORE,        /* Store Object */\r\n  JX9_OP_STORE_IDX,    /* Store indexed object */\r\n  JX9_OP_PULL,         /* Stack pull */\r\n  JX9_OP_SWAP,         /* Stack swap */\r\n  JX9_OP_YIELD,        /* Stack yield */\r\n  JX9_OP_CVT_BOOL,     /* Boolean cast */\r\n  JX9_OP_CVT_NUMC,     /* Numeric (integer, real or both) type cast */\r\n  JX9_OP_INCR,         /* Increment ++ */\r\n  JX9_OP_DECR,         /* Decrement -- */\r\n  JX9_OP_ADD_STORE,    /* Add and store '+=' */\r\n  JX9_OP_SUB_STORE,    /* Sub and store '-=' */\r\n  JX9_OP_MUL_STORE,    /* Mul and store '*=' */\r\n  JX9_OP_DIV_STORE,    /* Div and store '/=' */\r\n  JX9_OP_MOD_STORE,    /* Mod and store '%=' */\r\n  JX9_OP_CAT_STORE,    /* Cat and store '.=' */\r\n  JX9_OP_SHL_STORE,    /* Shift left and store '>>=' */\r\n  JX9_OP_SHR_STORE,    /* Shift right and store '<<=' */\r\n  JX9_OP_BAND_STORE,   /* Bitand and store '&=' */\r\n  JX9_OP_BOR_STORE,    /* Bitor and store '|=' */\r\n  JX9_OP_BXOR_STORE,   /* Bitxor and store '^=' */\r\n  JX9_OP_CONSUME,      /* Consume VM output */\r\n  JX9_OP_MEMBER,       /* Object member run-time access */\r\n  JX9_OP_UPLINK,       /* Run-Time frame link */\r\n  JX9_OP_CVT_NULL,     /* NULL cast */\r\n  JX9_OP_CVT_ARRAY,    /* Array cast */\r\n  JX9_OP_FOREACH_INIT, /* For each init */\r\n  JX9_OP_FOREACH_STEP, /* For each step */\r\n  JX9_OP_SWITCH        /* Switch operation */\r\n};\r\n/* -- END-OF INSTRUCTIONS -- */\r\n/*\r\n * Expression Operators ID.\r\n */\r\nenum jx9_expr_id {\r\n\tEXPR_OP_DOT,      /* Member access */\r\n\tEXPR_OP_DC,        /* :: */\r\n\tEXPR_OP_SUBSCRIPT, /* []: Subscripting */\r\n\tEXPR_OP_FUNC_CALL, /* func_call() */\r\n\tEXPR_OP_INCR,      /* ++ */\r\n\tEXPR_OP_DECR,      /* -- */ \r\n\tEXPR_OP_BITNOT,    /* ~ */\r\n\tEXPR_OP_UMINUS,    /* Unary minus  */\r\n\tEXPR_OP_UPLUS,     /* Unary plus */\r\n\tEXPR_OP_TYPECAST,  /* Type cast [i.e: (int), (float), (string)...] */\r\n\tEXPR_OP_ALT,       /* @ */\r\n\tEXPR_OP_INSTOF,    /* instanceof */\r\n\tEXPR_OP_LOGNOT,    /* logical not ! */\r\n\tEXPR_OP_MUL,       /* Multiplication */\r\n\tEXPR_OP_DIV,       /* division */\r\n\tEXPR_OP_MOD,       /* Modulus */\r\n\tEXPR_OP_ADD,       /* Addition */\r\n\tEXPR_OP_SUB,       /* Substraction */\r\n\tEXPR_OP_DDOT,      /* Concatenation */\r\n\tEXPR_OP_SHL,       /* Left shift */\r\n\tEXPR_OP_SHR,       /* Right shift */\r\n\tEXPR_OP_LT,        /* Less than */\r\n\tEXPR_OP_LE,        /* Less equal */\r\n\tEXPR_OP_GT,        /* Greater than */\r\n\tEXPR_OP_GE,        /* Greater equal */\r\n\tEXPR_OP_EQ,        /* Equal == */\r\n\tEXPR_OP_NE,        /* Not equal != <> */\r\n\tEXPR_OP_TEQ,       /* Type equal === */\r\n\tEXPR_OP_TNE,       /* Type not equal !== */\r\n\tEXPR_OP_SEQ,       /* String equal 'eq' */\r\n\tEXPR_OP_SNE,       /* String not equal 'ne' */\r\n\tEXPR_OP_BAND,      /* Biwise and '&' */\r\n\tEXPR_OP_REF,       /* Reference operator '&' */\r\n\tEXPR_OP_XOR,       /* bitwise xor '^' */\r\n\tEXPR_OP_BOR,       /* bitwise or '|' */\r\n\tEXPR_OP_LAND,      /* Logical and '&&','and' */\r\n\tEXPR_OP_LOR,       /* Logical or  '||','or'*/\r\n\tEXPR_OP_LXOR,      /* Logical xor 'xor' */\r\n\tEXPR_OP_QUESTY,    /* Ternary operator '?' */\r\n\tEXPR_OP_ASSIGN,    /* Assignment '=' */\r\n\tEXPR_OP_ADD_ASSIGN, /* Combined operator: += */\r\n\tEXPR_OP_SUB_ASSIGN, /* Combined operator: -= */\r\n\tEXPR_OP_MUL_ASSIGN, /* Combined operator: *= */\r\n\tEXPR_OP_DIV_ASSIGN, /* Combined operator: /= */\r\n\tEXPR_OP_MOD_ASSIGN, /* Combined operator: %= */\r\n\tEXPR_OP_DOT_ASSIGN, /* Combined operator: .= */\r\n\tEXPR_OP_AND_ASSIGN, /* Combined operator: &= */\r\n\tEXPR_OP_OR_ASSIGN,  /* Combined operator: |= */\r\n\tEXPR_OP_XOR_ASSIGN, /* Combined operator: ^= */\r\n\tEXPR_OP_SHL_ASSIGN, /* Combined operator: <<= */\r\n\tEXPR_OP_SHR_ASSIGN, /* Combined operator: >>= */\r\n\tEXPR_OP_COMMA       /* Comma expression */\r\n};\r\n/*\r\n * Lexer token codes\r\n * The following set of constants are the tokens recognized\r\n * by the lexer when processing JX9 input.\r\n * Important: Token values MUST BE A POWER OF TWO.\r\n */\r\n#define JX9_TK_INTEGER   0x0000001  /* Integer */\r\n#define JX9_TK_REAL      0x0000002  /* Real number */\r\n#define JX9_TK_NUM       (JX9_TK_INTEGER|JX9_TK_REAL) /* Numeric token, either integer or real */\r\n#define JX9_TK_KEYWORD   0x0000004 /* Keyword [i.e: while, for, if, foreach...] */\r\n#define JX9_TK_ID        0x0000008 /* Alphanumeric or UTF-8 stream */\r\n#define JX9_TK_DOLLAR    0x0000010 /* '$' Dollar sign */\r\n#define JX9_TK_OP        0x0000020 /* Operator [i.e: +, *, /...] */\r\n#define JX9_TK_OCB       0x0000040 /* Open curly brace'{' */\r\n#define JX9_TK_CCB       0x0000080 /* Closing curly brace'}' */\r\n#define JX9_TK_DOT       0x0000100 /* Dot . */\r\n#define JX9_TK_LPAREN    0x0000200 /* Left parenthesis '(' */\r\n#define JX9_TK_RPAREN    0x0000400 /* Right parenthesis ')' */\r\n#define JX9_TK_OSB       0x0000800 /* Open square bracket '[' */\r\n#define JX9_TK_CSB       0x0001000 /* Closing square bracket ']' */\r\n#define JX9_TK_DSTR      0x0002000 /* Double quoted string \"$str\" */\r\n#define JX9_TK_SSTR      0x0004000 /* Single quoted string 'str' */\r\n#define JX9_TK_NOWDOC    0x0010000 /* Nowdoc <<< */\r\n#define JX9_TK_COMMA     0x0020000 /* Comma ',' */\r\n#define JX9_TK_SEMI      0x0040000 /* Semi-colon \";\" */\r\n#define JX9_TK_BSTR      0x0080000 /* Backtick quoted string [i.e: Shell command `date`] */\r\n#define JX9_TK_COLON     0x0100000 /* single Colon ':' */\r\n#define JX9_TK_AMPER     0x0200000 /* Ampersand '&' */\r\n#define JX9_TK_EQUAL     0x0400000 /* Equal '=' */\r\n#define JX9_TK_OTHER     0x1000000 /* Other symbols */\r\n/*\r\n * JX9 keyword.\r\n * These words have special meaning in JX9. Some of them represent things which look like\r\n * functions, some look like constants, and so on, but they're not, really: they are language constructs.\r\n * You cannot use any of the following words as constants, object names, function or method names.\r\n * Using them as variable names is generally OK, but could lead to confusion. \r\n */\r\n#define JX9_TKWRD_SWITCH       1 /* switch */\r\n#define JX9_TKWRD_PRINT        2 /* print */\r\n#define JX9_TKWRD_ELIF         0x4000000 /* elseif: MUST BE A POWER OF TWO */\r\n#define JX9_TKWRD_ELSE         0x8000000 /* else:  MUST BE A POWER OF TWO */\r\n#define JX9_TKWRD_IF           3 /* if */\r\n#define JX9_TKWRD_STATIC       4 /* static */\r\n#define JX9_TKWRD_CASE         5 /* case */\r\n#define JX9_TKWRD_FUNCTION     6 /* function */\r\n#define JX9_TKWRD_CONST        7 /* const */\r\n/* The number '8' is reserved for JX9_TK_ID */\r\n#define JX9_TKWRD_WHILE        9 /* while */\r\n#define JX9_TKWRD_DEFAULT      10 /* default */\r\n#define JX9_TKWRD_AS           11 /* as */\r\n#define JX9_TKWRD_CONTINUE     12 /* continue */\r\n#define JX9_TKWRD_EXIT         13 /* exit */\r\n#define JX9_TKWRD_DIE          14 /* die */\r\n#define JX9_TKWRD_IMPORT       15 /* import */\r\n#define JX9_TKWRD_INCLUDE      16 /* include */\r\n#define JX9_TKWRD_FOR          17 /* for */\r\n#define JX9_TKWRD_FOREACH      18 /* foreach */\r\n#define JX9_TKWRD_RETURN       19 /* return */\r\n#define JX9_TKWRD_BREAK        20 /* break */\r\n#define JX9_TKWRD_UPLINK       21 /* uplink */\r\n#define JX9_TKWRD_BOOL         0x8000   /* bool:  MUST BE A POWER OF TWO */\r\n#define JX9_TKWRD_INT          0x10000  /* int:   MUST BE A POWER OF TWO */\r\n#define JX9_TKWRD_FLOAT        0x20000  /* float:  MUST BE A POWER OF TWO */\r\n#define JX9_TKWRD_STRING       0x40000  /* string: MUST BE A POWER OF TWO */\r\n\r\n/* api.c */\r\nJX9_PRIVATE sxi32 jx9EngineConfig(jx9 *pEngine, sxi32 nOp, va_list ap);\r\nJX9_PRIVATE int jx9DeleteFunction(jx9_vm *pVm,const char *zName);\r\nJX9_PRIVATE int Jx9DeleteConstant(jx9_vm *pVm,const char *zName);\r\n/* json.c function prototypes */\r\nJX9_PRIVATE int jx9JsonSerialize(jx9_value *pValue,SyBlob *pOut);\r\nJX9_PRIVATE int jx9JsonDecode(jx9_context *pCtx,const char *zJSON,int nByte);\r\n/* memobj.c function prototypes */\r\nJX9_PRIVATE sxi32 jx9MemObjDump(SyBlob *pOut, jx9_value *pObj);\r\nJX9_PRIVATE const char * jx9MemObjTypeDump(jx9_value *pVal);\r\nJX9_PRIVATE sxi32 jx9MemObjAdd(jx9_value *pObj1, jx9_value *pObj2, int bAddStore);\r\nJX9_PRIVATE sxi32 jx9MemObjCmp(jx9_value *pObj1, jx9_value *pObj2, int bStrict, int iNest);\r\nJX9_PRIVATE sxi32 jx9MemObjInitFromString(jx9_vm *pVm, jx9_value *pObj, const SyString *pVal);\r\nJX9_PRIVATE sxi32 jx9MemObjInitFromArray(jx9_vm *pVm, jx9_value *pObj, jx9_hashmap *pArray);\r\n#if 0\r\n/* Not used in the current release of the JX9 engine */\r\nJX9_PRIVATE sxi32 jx9MemObjInitFromReal(jx9_vm *pVm, jx9_value *pObj, jx9_real rVal);\r\n#endif\r\nJX9_PRIVATE sxi32 jx9MemObjInitFromInt(jx9_vm *pVm, jx9_value *pObj, sxi64 iVal);\r\nJX9_PRIVATE sxi32 jx9MemObjInitFromBool(jx9_vm *pVm, jx9_value *pObj, sxi32 iVal);\r\nJX9_PRIVATE sxi32 jx9MemObjInit(jx9_vm *pVm, jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjStringAppend(jx9_value *pObj, const char *zData, sxu32 nLen);\r\n#if 0\r\n/* Not used in the current release of the JX9 engine */\r\nJX9_PRIVATE sxi32 jx9MemObjStringFormat(jx9_value *pObj, const char *zFormat, va_list ap);\r\n#endif\r\nJX9_PRIVATE sxi32 jx9MemObjStore(jx9_value *pSrc, jx9_value *pDest);\r\nJX9_PRIVATE sxi32 jx9MemObjLoad(jx9_value *pSrc, jx9_value *pDest);\r\nJX9_PRIVATE sxi32 jx9MemObjRelease(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToNumeric(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjTryInteger(jx9_value *pObj);\r\nJX9_PRIVATE ProcMemObjCast jx9MemObjCastMethod(sxi32 iFlags);\r\nJX9_PRIVATE sxi32 jx9MemObjIsNumeric(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjIsEmpty(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToHashmap(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToString(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToNull(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToReal(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToInteger(jx9_value *pObj);\r\nJX9_PRIVATE sxi32 jx9MemObjToBool(jx9_value *pObj);\r\nJX9_PRIVATE sxi64 jx9TokenValueToInt64(SyString *pData);\r\n/* lex.c function prototypes */\r\nJX9_PRIVATE sxi32 jx9Tokenize(const char *zInput, sxu32 nLen, SySet *pOut);\r\n/* vm.c function prototypes */\r\nJX9_PRIVATE void jx9VmReleaseContextValue(jx9_context *pCtx, jx9_value *pValue);\r\nJX9_PRIVATE sxi32 jx9VmInitFuncState(jx9_vm *pVm, jx9_vm_func *pFunc, const char *zName, sxu32 nByte, \r\n\tsxi32 iFlags, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9VmInstallUserFunction(jx9_vm *pVm, jx9_vm_func *pFunc, SyString *pName);\r\nJX9_PRIVATE sxi32 jx9VmRegisterConstant(jx9_vm *pVm, const SyString *pName, ProcConstant xExpand, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9VmInstallForeignFunction(jx9_vm *pVm, const SyString *pName, ProcHostFunction xFunc, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9VmBlobConsumer(const void *pSrc, unsigned int nLen, void *pUserData);\r\nJX9_PRIVATE jx9_value * jx9VmReserveMemObj(jx9_vm *pVm,sxu32 *pIndex);\r\nJX9_PRIVATE jx9_value * jx9VmReserveConstObj(jx9_vm *pVm, sxu32 *pIndex);\r\nJX9_PRIVATE sxi32 jx9VmOutputConsume(jx9_vm *pVm, SyString *pString);\r\nJX9_PRIVATE sxi32 jx9VmOutputConsumeAp(jx9_vm *pVm, const char *zFormat, va_list ap);\r\nJX9_PRIVATE sxi32 jx9VmThrowErrorAp(jx9_vm *pVm, SyString *pFuncName, sxi32 iErr, const char *zFormat, va_list ap);\r\nJX9_PRIVATE sxi32 jx9VmThrowError(jx9_vm *pVm, SyString *pFuncName, sxi32 iErr, const char *zMessage);\r\nJX9_PRIVATE void  jx9VmExpandConstantValue(jx9_value *pVal, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9VmDump(jx9_vm *pVm, ProcConsumer xConsumer, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9VmInit(jx9_vm *pVm, jx9 *pEngine);\r\nJX9_PRIVATE sxi32 jx9VmConfigure(jx9_vm *pVm, sxi32 nOp, va_list ap);\r\nJX9_PRIVATE sxi32 jx9VmByteCodeExec(jx9_vm *pVm);\r\nJX9_PRIVATE jx9_value * jx9VmExtractVariable(jx9_vm *pVm,SyString *pVar);\r\nJX9_PRIVATE sxi32 jx9VmRelease(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9VmReset(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9VmMakeReady(jx9_vm *pVm);\r\nJX9_PRIVATE sxu32 jx9VmInstrLength(jx9_vm *pVm);\r\nJX9_PRIVATE VmInstr * jx9VmPopInstr(jx9_vm *pVm);\r\nJX9_PRIVATE VmInstr * jx9VmPeekInstr(jx9_vm *pVm);\r\nJX9_PRIVATE VmInstr *jx9VmGetInstr(jx9_vm *pVm, sxu32 nIndex);\r\nJX9_PRIVATE SySet * jx9VmGetByteCodeContainer(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9VmSetByteCodeContainer(jx9_vm *pVm, SySet *pContainer);\r\nJX9_PRIVATE sxi32 jx9VmEmitInstr(jx9_vm *pVm, sxi32 iOp, sxi32 iP1, sxu32 iP2, void *p3, sxu32 *pIndex);\r\nJX9_PRIVATE sxu32 jx9VmRandomNum(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9VmCallUserFunction(jx9_vm *pVm, jx9_value *pFunc, int nArg, jx9_value **apArg, jx9_value *pResult);\r\nJX9_PRIVATE sxi32 jx9VmCallUserFunctionAp(jx9_vm *pVm, jx9_value *pFunc, jx9_value *pResult, ...);\r\nJX9_PRIVATE sxi32 jx9VmUnsetMemObj(jx9_vm *pVm, sxu32 nObjIdx);\r\nJX9_PRIVATE void jx9VmRandomString(jx9_vm *pVm, char *zBuf, int nLen);\r\nJX9_PRIVATE int jx9VmIsCallable(jx9_vm *pVm, jx9_value *pValue);\r\nJX9_PRIVATE sxi32 jx9VmPushFilePath(jx9_vm *pVm, const char *zPath, int nLen, sxu8 bMain, sxi32 *pNew);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE const jx9_io_stream * jx9VmGetStreamDevice(jx9_vm *pVm, const char **pzDevice, int nByte);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\nJX9_PRIVATE int jx9Utf8Read(\r\n  const unsigned char *z,         /* First byte of UTF-8 character */\r\n  const unsigned char *zTerm,     /* Pretend this byte is 0x00 */\r\n  const unsigned char **pzNext    /* Write first byte past UTF-8 char here */\r\n);\r\n/* parse.c function prototypes */\r\nJX9_PRIVATE int jx9IsLangConstruct(sxu32 nKeyID);\r\nJX9_PRIVATE sxi32 jx9ExprMakeTree(jx9_gen_state *pGen, SySet *pExprNode, jx9_expr_node **ppRoot);\r\nJX9_PRIVATE sxi32 jx9GetNextExpr(SyToken *pStart, SyToken *pEnd, SyToken **ppNext);\r\nJX9_PRIVATE void jx9DelimitNestedTokens(SyToken *pIn, SyToken *pEnd, sxu32 nTokStart, sxu32 nTokEnd, SyToken **ppEnd);\r\nJX9_PRIVATE const jx9_expr_op * jx9ExprExtractOperator(SyString *pStr, SyToken *pLast);\r\nJX9_PRIVATE sxi32 jx9ExprFreeTree(jx9_gen_state *pGen, SySet *pNodeSet);\r\n/* compile.c function prototypes */\r\nJX9_PRIVATE ProcNodeConstruct jx9GetNodeHandler(sxu32 nNodeType);\r\nJX9_PRIVATE sxi32 jx9CompileLangConstruct(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileJsonArray(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileJsonObject(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileVariable(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileLiteral(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileSimpleString(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileString(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9CompileAnnonFunc(jx9_gen_state *pGen, sxi32 iCompileFlag);\r\nJX9_PRIVATE sxi32 jx9InitCodeGenerator(jx9_vm *pVm, ProcConsumer xErr, void *pErrData);\r\nJX9_PRIVATE sxi32 jx9ResetCodeGenerator(jx9_vm *pVm, ProcConsumer xErr, void *pErrData);\r\nJX9_PRIVATE sxi32 jx9GenCompileError(jx9_gen_state *pGen, sxi32 nErrType, sxu32 nLine, const char *zFormat, ...);\r\nJX9_PRIVATE sxi32 jx9CompileScript(jx9_vm *pVm, SyString *pScript, sxi32 iFlags);\r\n/* constant.c function prototypes */\r\nJX9_PRIVATE void jx9RegisterBuiltInConstant(jx9_vm *pVm);\r\n/* builtin.c function prototypes */\r\nJX9_PRIVATE void jx9RegisterBuiltInFunction(jx9_vm *pVm);\r\n/* hashmap.c function prototypes */\r\nJX9_PRIVATE jx9_hashmap * jx9NewHashmap(jx9_vm *pVm, sxu32 (*xIntHash)(sxi64), sxu32 (*xBlobHash)(const void *, sxu32));\r\nJX9_PRIVATE sxi32 jx9HashmapLoadBuiltin(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9HashmapRelease(jx9_hashmap *pMap, int FreeDS);\r\nJX9_PRIVATE void  jx9HashmapUnref(jx9_hashmap *pMap);\r\nJX9_PRIVATE sxi32 jx9HashmapLookup(jx9_hashmap *pMap, jx9_value *pKey, jx9_hashmap_node **ppNode);\r\nJX9_PRIVATE sxi32 jx9HashmapInsert(jx9_hashmap *pMap, jx9_value *pKey, jx9_value *pVal);\r\nJX9_PRIVATE sxi32 jx9HashmapUnion(jx9_hashmap *pLeft, jx9_hashmap *pRight);\r\nJX9_PRIVATE sxi32 jx9HashmapDup(jx9_hashmap *pSrc, jx9_hashmap *pDest);\r\nJX9_PRIVATE sxi32 jx9HashmapCmp(jx9_hashmap *pLeft, jx9_hashmap *pRight, int bStrict);\r\nJX9_PRIVATE void jx9HashmapResetLoopCursor(jx9_hashmap *pMap);\r\nJX9_PRIVATE jx9_hashmap_node * jx9HashmapGetNextEntry(jx9_hashmap *pMap);\r\nJX9_PRIVATE jx9_value * jx9HashmapGetNodeValue(jx9_hashmap_node *pNode);\r\nJX9_PRIVATE void jx9HashmapExtractNodeValue(jx9_hashmap_node *pNode, jx9_value *pValue, int bStore);\r\nJX9_PRIVATE void jx9HashmapExtractNodeKey(jx9_hashmap_node *pNode, jx9_value *pKey);\r\nJX9_PRIVATE void jx9RegisterHashmapFunctions(jx9_vm *pVm);\r\nJX9_PRIVATE sxi32 jx9HashmapWalk(jx9_hashmap *pMap, int (*xWalk)(jx9_value *, jx9_value *, void *), void *pUserData);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE int jx9HashmapValuesToSet(jx9_hashmap *pMap, SySet *pOut);\r\n/* builtin.c function prototypes */ \r\nJX9_PRIVATE sxi32 jx9InputFormat(int (*xConsumer)(jx9_context *, const char *, int, void *), \r\n\tjx9_context *pCtx, const char *zIn, int nByte, int nArg, jx9_value **apArg, void *pUserData, int vf);\r\nJX9_PRIVATE sxi32 jx9ProcessCsv(const char *zInput, int nByte, int delim, int encl, \r\n\tint escape, sxi32 (*xConsumer)(const char *, int, void *), void *pUserData);\r\nJX9_PRIVATE sxi32 jx9CsvConsumer(const char *zToken, int nTokenLen, void *pUserData);\r\nJX9_PRIVATE sxi32 jx9StripTagsFromString(jx9_context *pCtx, const char *zIn, int nByte, const char *zTaglist, int nTaglen);\r\nJX9_PRIVATE sxi32 jx9ParseIniString(jx9_context *pCtx, const char *zIn, sxu32 nByte, int bProcessSection);\r\n#endif\r\n/* vfs.c */\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE void * jx9StreamOpenHandle(jx9_vm *pVm, const jx9_io_stream *pStream, const char *zFile, \r\n\tint iFlags, int use_include, jx9_value *pResource, int bPushInclude, int *pNew);\r\nJX9_PRIVATE sxi32 jx9StreamReadWholeFile(void *pHandle, const jx9_io_stream *pStream, SyBlob *pOut);\r\nJX9_PRIVATE void jx9StreamCloseHandle(const jx9_io_stream *pStream, void *pHandle);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\nJX9_PRIVATE const char * jx9ExtractDirName(const char *zPath, int nByte, int *pLen);\r\nJX9_PRIVATE sxi32 jx9RegisterIORoutine(jx9_vm *pVm);\r\nJX9_PRIVATE const jx9_vfs * jx9ExportBuiltinVfs(void);\r\nJX9_PRIVATE void * jx9ExportStdin(jx9_vm *pVm);\r\nJX9_PRIVATE void * jx9ExportStdout(jx9_vm *pVm);\r\nJX9_PRIVATE void * jx9ExportStderr(jx9_vm *pVm);\r\n/* lib.c function prototypes */\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyArchiveInit(SyArchive *pArch, SyMemBackend *pAllocator, ProcHash xHash, ProcRawStrCmp xCmp);\r\nJX9_PRIVATE sxi32 SyArchiveRelease(SyArchive *pArch);\r\nJX9_PRIVATE sxi32 SyArchiveResetLoopCursor(SyArchive *pArch);\r\nJX9_PRIVATE sxi32 SyArchiveGetNextEntry(SyArchive *pArch, SyArchiveEntry **ppEntry);\r\nJX9_PRIVATE sxi32 SyZipExtractFromBuf(SyArchive *pArch, const char *zBuf, sxu32 nLen);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyBinToHexConsumer(const void *pIn, sxu32 nLen, ProcConsumer xConsumer, void *pConsumerData);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\n#ifndef JX9_DISABLE_HASH_FUNC\r\nJX9_PRIVATE sxu32 SyCrc32(const void *pSrc, sxu32 nLen);\r\nJX9_PRIVATE void MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len);\r\nJX9_PRIVATE void MD5Final(unsigned char digest[16], MD5Context *ctx);\r\nJX9_PRIVATE sxi32 MD5Init(MD5Context *pCtx);\r\nJX9_PRIVATE sxi32 SyMD5Compute(const void *pIn, sxu32 nLen, unsigned char zDigest[16]);\r\nJX9_PRIVATE void SHA1Init(SHA1Context *context);\r\nJX9_PRIVATE void SHA1Update(SHA1Context *context, const unsigned char *data, unsigned int len);\r\nJX9_PRIVATE void SHA1Final(SHA1Context *context, unsigned char digest[20]);\r\nJX9_PRIVATE sxi32 SySha1Compute(const void *pIn, sxu32 nLen, unsigned char zDigest[20]);\r\n#endif\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\nJX9_PRIVATE sxi32 SyRandomness(SyPRNGCtx *pCtx, void *pBuf, sxu32 nLen);\r\nJX9_PRIVATE sxi32 SyRandomnessInit(SyPRNGCtx *pCtx, ProcRandomSeed xSeed, void *pUserData);\r\nJX9_PRIVATE sxu32 SyBufferFormat(char *zBuf, sxu32 nLen, const char *zFormat, ...);\r\nJX9_PRIVATE sxu32 SyBlobFormatAp(SyBlob *pBlob, const char *zFormat, va_list ap);\r\nJX9_PRIVATE sxu32 SyBlobFormat(SyBlob *pBlob, const char *zFormat, ...);\r\nJX9_PRIVATE sxi32 SyProcFormat(ProcConsumer xConsumer, void *pData, const char *zFormat, ...);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE const char *SyTimeGetMonth(sxi32 iMonth);\r\nJX9_PRIVATE const char *SyTimeGetDay(sxi32 iDay);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\nJX9_PRIVATE sxi32 SyUriDecode(const char *zSrc, sxu32 nLen, ProcConsumer xConsumer, void *pUserData, int bUTF8);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyUriEncode(const char *zSrc, sxu32 nLen, ProcConsumer xConsumer, void *pUserData);\r\n#endif\r\nJX9_PRIVATE sxi32 SyLexRelease(SyLex *pLex);\r\nJX9_PRIVATE sxi32 SyLexTokenizeInput(SyLex *pLex, const char *zInput, sxu32 nLen, void *pCtxData, ProcSort xSort, ProcCmp xCmp);\r\nJX9_PRIVATE sxi32 SyLexInit(SyLex *pLex, SySet *pSet, ProcTokenizer xTokenizer, void *pUserData);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyBase64Decode(const char *zB64, sxu32 nLen, ProcConsumer xConsumer, void *pUserData);\r\nJX9_PRIVATE sxi32 SyBase64Encode(const char *zSrc, sxu32 nLen, ProcConsumer xConsumer, void *pUserData);\r\n#endif /* JX9_DISABLE_BUILTIN_FUNC */\r\nJX9_PRIVATE sxu32 SyBinHash(const void *pSrc, sxu32 nLen);\r\nJX9_PRIVATE sxi32 SyStrToReal(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyBinaryStrToInt64(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyOctalStrToInt64(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyHexStrToInt64(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyHexToint(sxi32 c);\r\nJX9_PRIVATE sxi32 SyStrToInt64(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyStrToInt32(const char *zSrc, sxu32 nLen, void *pOutVal, const char **zRest);\r\nJX9_PRIVATE sxi32 SyStrIsNumeric(const char *zSrc, sxu32 nLen, sxu8 *pReal, const char **pzTail);\r\nJX9_PRIVATE sxi32 SyHashInsert(SyHash *pHash, const void *pKey, sxu32 nKeyLen, void *pUserData);\r\nJX9_PRIVATE sxi32 SyHashForEach(SyHash *pHash, sxi32(*xStep)(SyHashEntry *, void *), void *pUserData);\r\nJX9_PRIVATE sxi32 SyHashDeleteEntry(SyHash *pHash, const void *pKey, sxu32 nKeyLen, void **ppUserData);\r\nJX9_PRIVATE SyHashEntry *SyHashGet(SyHash *pHash, const void *pKey, sxu32 nKeyLen);\r\nJX9_PRIVATE sxi32 SyHashRelease(SyHash *pHash);\r\nJX9_PRIVATE sxi32 SyHashInit(SyHash *pHash, SyMemBackend *pAllocator, ProcHash xHash, ProcCmp xCmp);\r\nJX9_PRIVATE void *SySetAt(SySet *pSet, sxu32 nIdx);\r\nJX9_PRIVATE void *SySetPop(SySet *pSet);\r\nJX9_PRIVATE void *SySetPeek(SySet *pSet);\r\nJX9_PRIVATE sxi32 SySetRelease(SySet *pSet);\r\nJX9_PRIVATE sxi32 SySetReset(SySet *pSet);\r\nJX9_PRIVATE sxi32 SySetResetCursor(SySet *pSet);\r\nJX9_PRIVATE sxi32 SySetGetNextEntry(SySet *pSet, void **ppEntry);\r\nJX9_PRIVATE sxi32 SySetAlloc(SySet *pSet, sxi32 nItem);\r\nJX9_PRIVATE sxi32 SySetPut(SySet *pSet, const void *pItem);\r\nJX9_PRIVATE sxi32 SySetInit(SySet *pSet, SyMemBackend *pAllocator, sxu32 ElemSize);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyBlobSearch(const void *pBlob, sxu32 nLen, const void *pPattern, sxu32 pLen, sxu32 *pOfft);\r\n#endif\r\nJX9_PRIVATE sxi32 SyBlobRelease(SyBlob *pBlob);\r\nJX9_PRIVATE sxi32 SyBlobReset(SyBlob *pBlob);\r\nJX9_PRIVATE sxi32 SyBlobTruncate(SyBlob *pBlob,sxu32 nNewLen);\r\nJX9_PRIVATE sxi32 SyBlobDup(SyBlob *pSrc, SyBlob *pDest);\r\nJX9_PRIVATE sxi32 SyBlobNullAppend(SyBlob *pBlob);\r\nJX9_PRIVATE sxi32 SyBlobAppend(SyBlob *pBlob, const void *pData, sxu32 nSize);\r\nJX9_PRIVATE sxi32 SyBlobReadOnly(SyBlob *pBlob, const void *pData, sxu32 nByte);\r\nJX9_PRIVATE sxi32 SyBlobInit(SyBlob *pBlob, SyMemBackend *pAllocator);\r\nJX9_PRIVATE sxi32 SyBlobInitFromBuf(SyBlob *pBlob, void *pBuffer, sxu32 nSize);\r\nJX9_PRIVATE char *SyMemBackendStrDup(SyMemBackend *pBackend, const char *zSrc, sxu32 nSize);\r\nJX9_PRIVATE void *SyMemBackendDup(SyMemBackend *pBackend, const void *pSrc, sxu32 nSize);\r\nJX9_PRIVATE sxi32 SyMemBackendRelease(SyMemBackend *pBackend);\r\nJX9_PRIVATE sxi32 SyMemBackendInitFromOthers(SyMemBackend *pBackend, const SyMemMethods *pMethods, ProcMemError xMemErr, void *pUserData);\r\nJX9_PRIVATE sxi32 SyMemBackendInit(SyMemBackend *pBackend, ProcMemError xMemErr, void *pUserData);\r\nJX9_PRIVATE sxi32 SyMemBackendInitFromParent(SyMemBackend *pBackend,const SyMemBackend *pParent);\r\n#if 0\r\n/* Not used in the current release of the JX9 engine */\r\nJX9_PRIVATE void *SyMemBackendPoolRealloc(SyMemBackend *pBackend, void *pOld, sxu32 nByte);\r\n#endif\r\nJX9_PRIVATE sxi32 SyMemBackendPoolFree(SyMemBackend *pBackend, void *pChunk);\r\nJX9_PRIVATE void *SyMemBackendPoolAlloc(SyMemBackend *pBackend, sxu32 nByte);\r\nJX9_PRIVATE sxi32 SyMemBackendFree(SyMemBackend *pBackend, void *pChunk);\r\nJX9_PRIVATE void *SyMemBackendRealloc(SyMemBackend *pBackend, void *pOld, sxu32 nByte);\r\nJX9_PRIVATE void *SyMemBackendAlloc(SyMemBackend *pBackend, sxu32 nByte);\r\nJX9_PRIVATE sxu32 SyMemcpy(const void *pSrc, void *pDest, sxu32 nLen);\r\nJX9_PRIVATE sxi32 SyMemcmp(const void *pB1, const void *pB2, sxu32 nSize);\r\nJX9_PRIVATE void SyZero(void *pSrc, sxu32 nSize);\r\nJX9_PRIVATE sxi32 SyStrnicmp(const char *zLeft, const char *zRight, sxu32 SLen);\r\nJX9_PRIVATE sxu32 Systrcpy(char *zDest, sxu32 nDestLen, const char *zSrc, sxu32 nLen);\r\n#if !defined(JX9_DISABLE_BUILTIN_FUNC) || defined(__APPLE__)\r\nJX9_PRIVATE sxi32 SyStrncmp(const char *zLeft, const char *zRight, sxu32 nLen);\r\n#endif\r\nJX9_PRIVATE sxi32 SyByteListFind(const char *zSrc, sxu32 nLen, const char *zList, sxu32 *pFirstPos);\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\nJX9_PRIVATE sxi32 SyByteFind2(const char *zStr, sxu32 nLen, sxi32 c, sxu32 *pPos);\r\n#endif\r\nJX9_PRIVATE sxi32 SyByteFind(const char *zStr, sxu32 nLen, sxi32 c, sxu32 *pPos);\r\nJX9_PRIVATE sxu32 SyStrlen(const char *zSrc);\r\n#if defined(JX9_ENABLE_THREADS)\r\nJX9_PRIVATE const SyMutexMethods *SyMutexExportMethods(void);\r\nJX9_PRIVATE sxi32 SyMemBackendMakeThreadSafe(SyMemBackend *pBackend, const SyMutexMethods *pMethods);\r\nJX9_PRIVATE sxi32 SyMemBackendDisbaleMutexing(SyMemBackend *pBackend);\r\n#endif\r\nJX9_PRIVATE void SyBigEndianPack32(unsigned char *buf,sxu32 nb);\r\nJX9_PRIVATE void SyBigEndianUnpack32(const unsigned char *buf,sxu32 *uNB);\r\nJX9_PRIVATE void SyBigEndianPack16(unsigned char *buf,sxu16 nb);\r\nJX9_PRIVATE void SyBigEndianUnpack16(const unsigned char *buf,sxu16 *uNB);\r\nJX9_PRIVATE void SyBigEndianPack64(unsigned char *buf,sxu64 n64);\r\nJX9_PRIVATE void SyBigEndianUnpack64(const unsigned char *buf,sxu64 *n64);\r\nJX9_PRIVATE sxi32 SyBlobAppendBig64(SyBlob *pBlob,sxu64 n64);\r\nJX9_PRIVATE sxi32 SyBlobAppendBig32(SyBlob *pBlob,sxu32 n32);\r\nJX9_PRIVATE sxi32 SyBlobAppendBig16(SyBlob *pBlob,sxu16 n16);\r\nJX9_PRIVATE void SyTimeFormatToDos(Sytm *pFmt,sxu32 *pOut);\r\nJX9_PRIVATE void SyDosTimeFormat(sxu32 nDosDate, Sytm *pOut);\r\n#endif /* __JX9INT_H__ */\r\n\r\n/*\r\n * ----------------------------------------------------------\r\n * File: unqliteInt.h\r\n * MD5: 325816ce05f6adbaab2c39a41875dedd\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/\r\n * Version 1.1.6\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n /* $SymiscID: unqliteInt.h v1.7 FreeBSD 2012-11-02 11:25 devel <chm@symisc.net> $ */\r\n#ifndef __UNQLITEINT_H__\r\n#define __UNQLITEINT_H__\r\n/* Internal interface definitions for UnQLite. */\r\n#ifdef UNQLITE_AMALGAMATION\r\n/* Marker for routines not intended for external use */\r\n#define UNQLITE_PRIVATE static\r\n#define JX9_AMALGAMATION\r\n#else\r\n#define UNQLITE_PRIVATE\r\n#include \"unqlite.h\"\r\n#include \"jx9Int.h\"\r\n#endif \r\n/* forward declaration */\r\ntypedef struct unqlite_db unqlite_db;\r\n/*\r\n** The following values may be passed as the second argument to\r\n** UnqliteOsLock(). The various locks exhibit the following semantics:\r\n**\r\n** SHARED:    Any number of processes may hold a SHARED lock simultaneously.\r\n** RESERVED:  A single process may hold a RESERVED lock on a file at\r\n**            any time. Other processes may hold and obtain new SHARED locks.\r\n** PENDING:   A single process may hold a PENDING lock on a file at\r\n**            any one time. Existing SHARED locks may persist, but no new\r\n**            SHARED locks may be obtained by other processes.\r\n** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.\r\n**\r\n** PENDING_LOCK may not be passed directly to UnqliteOsLock(). Instead, a\r\n** process that requests an EXCLUSIVE lock may actually obtain a PENDING\r\n** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to\r\n** UnqliteOsLock().\r\n*/\r\n#define NO_LOCK         0\r\n#define SHARED_LOCK     1\r\n#define RESERVED_LOCK   2\r\n#define PENDING_LOCK    3\r\n#define EXCLUSIVE_LOCK  4\r\n/*\r\n * UnQLite Locking Strategy (Same as SQLite3)\r\n *\r\n * The following #defines specify the range of bytes used for locking.\r\n * SHARED_SIZE is the number of bytes available in the pool from which\r\n * a random byte is selected for a shared lock.  The pool of bytes for\r\n * shared locks begins at SHARED_FIRST. \r\n *\r\n * The same locking strategy and byte ranges are used for Unix and Windows.\r\n * This leaves open the possiblity of having clients on winNT, and\r\n * unix all talking to the same shared file and all locking correctly.\r\n * To do so would require that samba (or whatever\r\n * tool is being used for file sharing) implements locks correctly between\r\n * windows and unix.  I'm guessing that isn't likely to happen, but by\r\n * using the same locking range we are at least open to the possibility.\r\n *\r\n * Locking in windows is mandatory.  For this reason, we cannot store\r\n * actual data in the bytes used for locking.  The pager never allocates\r\n * the pages involved in locking therefore.  SHARED_SIZE is selected so\r\n * that all locks will fit on a single page even at the minimum page size.\r\n * PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE\r\n * is set high so that we don't have to allocate an unused page except\r\n * for very large databases.  But one should test the page skipping logic \r\n * by setting PENDING_BYTE low and running the entire regression suite.\r\n *\r\n * Changing the value of PENDING_BYTE results in a subtly incompatible\r\n * file format.  Depending on how it is changed, you might not notice\r\n * the incompatibility right away, even running a full regression test.\r\n * The default location of PENDING_BYTE is the first byte past the\r\n * 1GB boundary.\r\n */\r\n#define PENDING_BYTE     (0x40000000)\r\n#define RESERVED_BYTE    (PENDING_BYTE+1)\r\n#define SHARED_FIRST     (PENDING_BYTE+2)\r\n#define SHARED_SIZE      510\r\n/*\r\n * The default size of a disk sector in bytes.\r\n */\r\n#ifndef UNQLITE_DEFAULT_SECTOR_SIZE\r\n#define UNQLITE_DEFAULT_SECTOR_SIZE 512\r\n#endif\r\n/*\r\n * Each open database file is managed by a separate instance\r\n * of the \"Pager\" structure.\r\n */\r\ntypedef struct Pager Pager;\r\n/*\r\n * Each database file to be accessed by the system is an instance\r\n * of the following structure.\r\n */\r\nstruct unqlite_db\r\n{\r\n\tPager *pPager;              /* Pager and Transaction manager */\r\n\tjx9 *pJx9;                  /* Jx9 Engine handle */\r\n\tunqlite_kv_cursor *pCursor; /* Database cursor for common usage */\r\n};\r\n/*\r\n * Each database connection is an instance of the following structure.\r\n */\r\nstruct unqlite\r\n{\r\n\tSyMemBackend sMem;              /* Memory allocator subsystem */\r\n\tSyBlob sErr;                    /* Error log */\r\n\tunqlite_db sDB;                 /* Storage backend */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tconst SyMutexMethods *pMethods;  /* Mutex methods */\r\n\tSyMutex *pMutex;                 /* Per-handle mutex */\r\n#endif\r\n\tunqlite_vm *pVms;                /* List of active VM */\r\n\tsxi32 iVm;                       /* Total number of active VM */\r\n\tsxi32 iFlags;                    /* Control flags (See below)  */\r\n\tunqlite *pNext,*pPrev;           /* List of active DB handles */\r\n\tsxu32 nMagic;                    /* Sanity check against misuse */\r\n};\r\n#define UNQLITE_FL_DISABLE_AUTO_COMMIT   0x001 /* Disable auto-commit on close */\r\n/*\r\n * VM control flags (Mostly related to collection handling).\r\n */\r\n#define UNQLITE_VM_COLLECTION_CREATE     0x001 /* Create a new collection */\r\n#define UNQLITE_VM_COLLECTION_EXISTS     0x002 /* Exists old collection */\r\n#define UNQLITE_VM_AUTO_LOAD             0x004 /* Auto load a collection from the vfs */\r\n/* Forward declaration */\r\ntypedef struct unqlite_col_record unqlite_col_record;\r\ntypedef struct unqlite_col unqlite_col;\r\n/*\r\n * Each an in-memory collection record is stored in an instance\r\n * of the following structure.\r\n */\r\nstruct unqlite_col_record\r\n{\r\n\tunqlite_col *pCol;                      /* Collecion this record belong */\r\n\tjx9_int64 nId;                          /* Unique record ID */\r\n\tjx9_value sValue;                       /* In-memory value of the record */\r\n\tunqlite_col_record *pNextCol,*pPrevCol; /* Collision chain */\r\n\tunqlite_col_record *pNext,*pPrev;       /* Linked list of records */\r\n};\r\n/* \r\n * Magic number to identify a valid collection on disk.\r\n */\r\n#define UNQLITE_COLLECTION_MAGIC 0x611E /* sizeof(unsigned short) 2 bytes */\r\n/*\r\n * A loaded collection is identified by an instance of the following structure.\r\n */\r\nstruct unqlite_col\r\n{\r\n\tunqlite_vm *pVm;   /* VM that own this instance */\r\n\tSyString sName;    /* ID of the collection */\r\n\tsxu32 nHash;       /* sName hash */\r\n\tjx9_value sSchema; /* Collection schema */\r\n\tsxu32 nSchemaOfft; /* Shema offset in sHeader */\r\n\tSyBlob sWorker;    /* General purpose working buffer */\r\n\tSyBlob sHeader;    /* Collection binary header */\r\n\tjx9_int64 nLastid; /* Last collection record ID */\r\n\tjx9_int64 nCurid;  /* Current record ID */\r\n\tjx9_int64 nTotRec; /* Total number of records in the collection */\r\n\tint iFlags;        /* Control flags (see below) */\r\n\tunqlite_col_record **apRecord; /* Hashtable of loaded records */\r\n\tunqlite_col_record *pList;     /* Linked list of records */\r\n\tsxu32 nRec;        /* Total number of records in apRecord[] */     \r\n\tsxu32 nRecSize;    /* apRecord[] size */\r\n\tSytm sCreation;    /* Colleation creation time */\r\n\tunqlite_kv_cursor *pCursor; /* Cursor pointing to the raw binary data */\r\n\tunqlite_col *pNext,*pPrev;  /* Next and previous collection in the chain */\r\n\tunqlite_col *pNextCol,*pPrevCol; /* Collision chain */\r\n};\r\n/*\r\n * Each unQLite Virtual Machine resulting from successful compilation of\r\n * a Jx9 script is represented by an instance of the following structure.\r\n */\r\nstruct unqlite_vm\r\n{\r\n\tunqlite *pDb;              /* Database handle that own this instance */\r\n\tSyMemBackend sAlloc;       /* Private memory allocator */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tSyMutex *pMutex;           /* Recursive mutex associated with this VM. */\r\n#endif\r\n\tunqlite_col **apCol;       /* Table of loaded collections */\r\n\tunqlite_col *pCol;         /* List of loaded collections */\r\n\tsxu32 iCol;                /* Total number of loaded collections */\r\n\tsxu32 iColSize;            /* apCol[] size  */\r\n\tjx9_vm *pJx9Vm;            /* Compiled Jx9 script*/\r\n\tunqlite_vm *pNext,*pPrev;  /* Linked list of active unQLite VM */\r\n\tsxu32 nMagic;              /* Magic number to avoid misuse */\r\n};\r\n/* \r\n * Database signature to identify a valid database image.\r\n */\r\n#define UNQLITE_DB_SIG \"unqlite\"\r\n/*\r\n * Database magic number (4 bytes).\r\n */\r\n#define UNQLITE_DB_MAGIC   0xDB7C2712\r\n/*\r\n * Maximum page size in bytes.\r\n */\r\n#ifdef UNQLITE_MAX_PAGE_SIZE\r\n# undef UNQLITE_MAX_PAGE_SIZE\r\n#endif\r\n#define UNQLITE_MAX_PAGE_SIZE 65536 /* 65K */\r\n/*\r\n * Minimum page size in bytes.\r\n */\r\n#ifdef UNQLITE_MIN_PAGE_SIZE\r\n# undef UNQLITE_MIN_PAGE_SIZE\r\n#endif\r\n#define UNQLITE_MIN_PAGE_SIZE 512\r\n/*\r\n * The default size of a database page.\r\n */\r\n#ifndef UNQLITE_DEFAULT_PAGE_SIZE\r\n# undef UNQLITE_DEFAULT_PAGE_SIZE\r\n#endif\r\n# define UNQLITE_DEFAULT_PAGE_SIZE 4096 /* 4K */\r\n/* Forward declaration */\r\ntypedef struct Bitvec Bitvec;\r\n/* Private library functions */\r\n/* api.c */\r\nUNQLITE_PRIVATE const SyMemBackend * unqliteExportMemBackend(void);\r\nUNQLITE_PRIVATE int unqliteDataConsumer(\r\n\tconst void *pOut,   /* Data to consume */\r\n\tunsigned int nLen,  /* Data length */\r\n\tvoid *pUserData     /* User private data */\r\n\t);\r\nUNQLITE_PRIVATE unqlite_kv_methods * unqliteFindKVStore(\r\n\tconst char *zName, /* Storage engine name [i.e. Hash, B+tree, LSM, etc.] */\r\n\tsxu32 nByte        /* zName length */\r\n\t);\r\nUNQLITE_PRIVATE int unqliteGetPageSize(void);\r\nUNQLITE_PRIVATE int unqliteGenError(unqlite *pDb,const char *zErr);\r\nUNQLITE_PRIVATE int unqliteGenErrorFormat(unqlite *pDb,const char *zFmt,...);\r\nUNQLITE_PRIVATE int unqliteGenOutofMem(unqlite *pDb);\r\n/* unql_vm.c */\r\nUNQLITE_PRIVATE int unqliteExistsCollection(unqlite_vm *pVm, SyString *pName);\r\nUNQLITE_PRIVATE int unqliteCreateCollection(unqlite_vm *pVm,SyString *pName);\r\nUNQLITE_PRIVATE jx9_int64 unqliteCollectionLastRecordId(unqlite_col *pCol);\r\nUNQLITE_PRIVATE jx9_int64 unqliteCollectionCurrentRecordId(unqlite_col *pCol);\r\nUNQLITE_PRIVATE int unqliteCollectionCacheRemoveRecord(unqlite_col *pCol,jx9_int64 nId);\r\nUNQLITE_PRIVATE jx9_int64 unqliteCollectionTotalRecords(unqlite_col *pCol);\r\nUNQLITE_PRIVATE void unqliteCollectionResetRecordCursor(unqlite_col *pCol);\r\nUNQLITE_PRIVATE int unqliteCollectionFetchNextRecord(unqlite_col *pCol,jx9_value *pValue);\r\nUNQLITE_PRIVATE int unqliteCollectionFetchRecordById(unqlite_col *pCol,jx9_int64 nId,jx9_value *pValue);\r\nUNQLITE_PRIVATE unqlite_col * unqliteCollectionFetch(unqlite_vm *pVm,SyString *pCol,int iFlag);\r\nUNQLITE_PRIVATE int unqliteCollectionSetSchema(unqlite_col *pCol,jx9_value *pValue);\r\nUNQLITE_PRIVATE int unqliteCollectionPut(unqlite_col *pCol,jx9_value *pValue,int iFlag);\r\nUNQLITE_PRIVATE int unqliteCollectionDropRecord(unqlite_col *pCol,jx9_int64 nId,int wr_header,int log_err);\r\nUNQLITE_PRIVATE int unqliteDropCollection(unqlite_col *pCol);\r\n/* unql_jx9.c */\r\nUNQLITE_PRIVATE int unqliteRegisterJx9Functions(unqlite_vm *pVm);\r\n/* fastjson.c */\r\nUNQLITE_PRIVATE sxi32 FastJsonEncode(\r\n\tjx9_value *pValue, /* Value to encode */\r\n\tSyBlob *pOut,      /* Store encoded value here */\r\n\tint iNest          /* Nesting limit */ \r\n\t);\r\nUNQLITE_PRIVATE sxi32 FastJsonDecode(\r\n\tconst void *pIn, /* Binary JSON  */\r\n\tsxu32 nByte,     /* Chunk delimiter */\r\n\tjx9_value *pOut, /* Decoded value */\r\n\tconst unsigned char **pzPtr,\r\n\tint iNest /* Nesting limit */\r\n\t);\r\n/* vfs.c [io_win.c, io_unix.c ] */\r\nUNQLITE_PRIVATE const unqlite_vfs * unqliteExportBuiltinVfs(void);\r\n/* mem_kv.c */\r\nUNQLITE_PRIVATE const unqlite_kv_methods * unqliteExportMemKvStorage(void);\r\n/* lhash_kv.c */\r\nUNQLITE_PRIVATE const unqlite_kv_methods * unqliteExportDiskKvStorage(void);\r\n/* os.c */\r\nUNQLITE_PRIVATE int unqliteOsRead(unqlite_file *id, void *pBuf, unqlite_int64 amt, unqlite_int64 offset);\r\nUNQLITE_PRIVATE int unqliteOsWrite(unqlite_file *id, const void *pBuf, unqlite_int64 amt, unqlite_int64 offset);\r\nUNQLITE_PRIVATE int unqliteOsTruncate(unqlite_file *id, unqlite_int64 size);\r\nUNQLITE_PRIVATE int unqliteOsSync(unqlite_file *id, int flags);\r\nUNQLITE_PRIVATE int unqliteOsFileSize(unqlite_file *id, unqlite_int64 *pSize);\r\nUNQLITE_PRIVATE int unqliteOsLock(unqlite_file *id, int lockType);\r\nUNQLITE_PRIVATE int unqliteOsUnlock(unqlite_file *id, int lockType);\r\nUNQLITE_PRIVATE int unqliteOsCheckReservedLock(unqlite_file *id, int *pResOut);\r\nUNQLITE_PRIVATE int unqliteOsSectorSize(unqlite_file *id);\r\nUNQLITE_PRIVATE int unqliteOsOpen(\r\n  unqlite_vfs *pVfs,\r\n  SyMemBackend *pAlloc,\r\n  const char *zPath, \r\n  unqlite_file **ppOut, \r\n  unsigned int flags\r\n);\r\nUNQLITE_PRIVATE int unqliteOsCloseFree(SyMemBackend *pAlloc,unqlite_file *pId);\r\nUNQLITE_PRIVATE int unqliteOsDelete(unqlite_vfs *pVfs, const char *zPath, int dirSync);\r\nUNQLITE_PRIVATE int unqliteOsAccess(unqlite_vfs *pVfs,const char *zPath,int flags,int *pResOut);\r\n/* bitmap.c */\r\nUNQLITE_PRIVATE Bitvec *unqliteBitvecCreate(SyMemBackend *pAlloc,pgno iSize);\r\nUNQLITE_PRIVATE int unqliteBitvecTest(Bitvec *p,pgno i);\r\nUNQLITE_PRIVATE int unqliteBitvecSet(Bitvec *p,pgno i);\r\nUNQLITE_PRIVATE void unqliteBitvecDestroy(Bitvec *p);\r\n/* pager.c */\r\nUNQLITE_PRIVATE int unqliteInitCursor(unqlite *pDb,unqlite_kv_cursor **ppOut);\r\nUNQLITE_PRIVATE int unqliteReleaseCursor(unqlite *pDb,unqlite_kv_cursor *pCur);\r\nUNQLITE_PRIVATE int unqlitePagerSetCachesize(Pager *pPager,int mxPage);\r\nUNQLITE_PRIVATE int unqlitePagerClose(Pager *pPager);\r\nUNQLITE_PRIVATE int unqlitePagerOpen(\r\n  unqlite_vfs *pVfs,       /* The virtual file system to use */\r\n  unqlite *pDb,            /* Database handle */\r\n  const char *zFilename,   /* Name of the database file to open */\r\n  unsigned int iFlags      /* flags controlling this file */\r\n  );\r\nUNQLITE_PRIVATE int unqlitePagerRegisterKvEngine(Pager *pPager,unqlite_kv_methods *pMethods);\r\nUNQLITE_PRIVATE unqlite_kv_engine * unqlitePagerGetKvEngine(unqlite *pDb);\r\nUNQLITE_PRIVATE int unqlitePagerBegin(Pager *pPager);\r\nUNQLITE_PRIVATE int unqlitePagerCommit(Pager *pPager);\r\nUNQLITE_PRIVATE int unqlitePagerRollback(Pager *pPager,int bResetKvEngine);\r\nUNQLITE_PRIVATE void unqlitePagerRandomString(Pager *pPager,char *zBuf,sxu32 nLen);\r\nUNQLITE_PRIVATE sxu32 unqlitePagerRandomNum(Pager *pPager);\r\n#endif /* __UNQLITEINT_H__ */\r\n/*\r\n * ----------------------------------------------------------\r\n * File: api.c\r\n * MD5: d79e8404e50dacd0ea75635c1ebe553a\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/\r\n * Version 1.1.6\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n /* $SymiscID: api.c v2.0 FreeBSD 2012-11-08 23:07 stable <chm@symisc.net> $ */\r\n#ifndef UNQLITE_AMALGAMATION\r\n#include \"unqliteInt.h\"\r\n#endif\r\n/* This file implement the public interfaces presented to host-applications.\r\n * Routines in other files are for internal use by UnQLite and should not be\r\n * accessed by users of the library.\r\n */\r\n#define UNQLITE_DB_MISUSE(DB) (DB == 0 || DB->nMagic != UNQLITE_DB_MAGIC)\r\n#define UNQLITE_VM_MISUSE(VM) (VM == 0 || VM->nMagic == JX9_VM_STALE)\r\n/* If another thread have released a working instance, the following macros\r\n * evaluates to true. These macros are only used when the library\r\n * is built with threading support enabled.\r\n */\r\n#define UNQLITE_THRD_DB_RELEASE(DB) (DB->nMagic != UNQLITE_DB_MAGIC)\r\n#define UNQLITE_THRD_VM_RELEASE(VM) (VM->nMagic == JX9_VM_STALE)\r\n/* IMPLEMENTATION: unqlite@embedded@symisc 118-09-4785 */\r\n/*\r\n * All global variables are collected in the structure named \"sUnqlMPGlobal\".\r\n * That way it is clear in the code when we are using static variable because\r\n * its name start with sUnqlMPGlobal.\r\n */\r\nstatic struct unqlGlobal_Data\r\n{\r\n\tSyMemBackend sAllocator;                /* Global low level memory allocator */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tconst SyMutexMethods *pMutexMethods;   /* Mutex methods */\r\n\tSyMutex *pMutex;                       /* Global mutex */\r\n\tsxu32 nThreadingLevel;                 /* Threading level: 0 == Single threaded/1 == Multi-Threaded \r\n\t\t\t\t\t\t\t\t\t\t    * The threading level can be set using the [unqlite_lib_config()]\r\n\t\t\t\t\t\t\t\t\t\t\t* interface with a configuration verb set to\r\n\t\t\t\t\t\t\t\t\t\t\t* UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE or \r\n\t\t\t\t\t\t\t\t\t\t\t* UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI\r\n\t\t\t\t\t\t\t\t\t\t\t*/\r\n#endif\r\n\tSySet kv_storage;                      /* Installed KV storage engines */\r\n\tint iPageSize;                         /* Default Page size */\r\n\tunqlite_vfs *pVfs;                     /* Underlying virtual file system (Vfs) */\r\n\tsxi32 nDB;                             /* Total number of active DB handles */\r\n\tunqlite *pDB;                          /* List of active DB handles */\r\n\tsxu32 nMagic;                          /* Sanity check against library misuse */\r\n}sUnqlMPGlobal = {\r\n\t{0, 0, 0, 0, 0, 0, 0, 0, {0}}, \r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t0, \r\n\t0, \r\n\t0, \r\n#endif\r\n\t{0, 0, 0, 0, 0, 0, 0 },\r\n\tUNQLITE_DEFAULT_PAGE_SIZE,\r\n\t0, \r\n\t0, \r\n\t0, \r\n\t0\r\n};\r\n#define UNQLITE_LIB_MAGIC  0xEA1495BA\r\n#define UNQLITE_LIB_MISUSE (sUnqlMPGlobal.nMagic != UNQLITE_LIB_MAGIC)\r\n/*\r\n * Supported threading level.\r\n * These options have meaning only when the library is compiled with multi-threading\r\n * support. That is, the UNQLITE_ENABLE_THREADS compile time directive must be defined\r\n * when UnQLite is built.\r\n * UNQLITE_THREAD_LEVEL_SINGLE:\r\n *  In this mode, mutexing is disabled and the library can only be used by a single thread.\r\n * UNQLITE_THREAD_LEVEL_MULTI\r\n *  In this mode, all mutexes including the recursive mutexes on [unqlite] objects\r\n *  are enabled so that the application is free to share the same database handle\r\n *  between different threads at the same time.\r\n */\r\n#define UNQLITE_THREAD_LEVEL_SINGLE 1 \r\n#define UNQLITE_THREAD_LEVEL_MULTI  2\r\n/*\r\n * Find a Key Value storage engine from the set of installed engines.\r\n * Return a pointer to the storage engine methods on success. NULL on failure.\r\n */\r\nUNQLITE_PRIVATE unqlite_kv_methods * unqliteFindKVStore(\r\n\tconst char *zName, /* Storage engine name [i.e. Hash, B+tree, LSM, etc.] */\r\n\tsxu32 nByte /* zName length */\r\n\t)\r\n{\r\n\tunqlite_kv_methods **apStore,*pEntry;\r\n\tsxu32 n,nMax;\r\n\t/* Point to the set of installed engines */\r\n\tapStore = (unqlite_kv_methods **)SySetBasePtr(&sUnqlMPGlobal.kv_storage);\r\n\tnMax = SySetUsed(&sUnqlMPGlobal.kv_storage);\r\n\tfor( n = 0 ; n < nMax; ++n ){\r\n\t\tpEntry = apStore[n];\r\n\t\tif( nByte == SyStrlen(pEntry->zName) && SyStrnicmp(pEntry->zName,zName,nByte) == 0 ){\r\n\t\t\t/* Storage engine found */\r\n\t\t\treturn pEntry;\r\n\t\t}\r\n\t}\r\n\t/* No such entry, return NULL */\r\n\treturn 0;\r\n}\r\n/*\r\n * Configure the UnQLite library.\r\n * Return UNQLITE_OK on success. Any other return value indicates failure.\r\n * Refer to [unqlite_lib_config()].\r\n */\r\nstatic sxi32 unqliteCoreConfigure(sxi32 nOp, va_list ap)\r\n{\r\n\tint rc = UNQLITE_OK;\r\n\tswitch(nOp){\r\n\t    case UNQLITE_LIB_CONFIG_PAGE_SIZE: {\r\n\t\t\t/* Default page size: Must be a power of two */\r\n\t\t\tint iPage = va_arg(ap,int);\r\n\t\t\tif( iPage >= UNQLITE_MIN_PAGE_SIZE && iPage <= UNQLITE_MAX_PAGE_SIZE ){\r\n\t\t\t\tif( !(iPage & (iPage - 1)) ){\r\n\t\t\t\t\tsUnqlMPGlobal.iPageSize = iPage;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t/* Invalid page size */\r\n\t\t\t\t\trc = UNQLITE_INVALID;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t/* Invalid page size */\r\n\t\t\t\trc = UNQLITE_INVALID;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t   }\r\n\t    case UNQLITE_LIB_CONFIG_STORAGE_ENGINE: {\r\n\t\t\t/* Install a key value storage engine */\r\n\t\t\tunqlite_kv_methods *pMethods = va_arg(ap,unqlite_kv_methods *);\r\n\t\t\t/* Make sure we are delaing with a valid methods */\r\n\t\t\tif( pMethods == 0 || SX_EMPTY_STR(pMethods->zName) || pMethods->xSeek == 0 || pMethods->xData == 0\r\n\t\t\t\t|| pMethods->xKey == 0 || pMethods->xDataLength == 0 || pMethods->xKeyLength == 0 \r\n\t\t\t\t|| pMethods->szKv < (int)sizeof(unqlite_kv_engine) ){\r\n\t\t\t\t\trc = UNQLITE_INVALID;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Install it */\r\n\t\t\trc = SySetPut(&sUnqlMPGlobal.kv_storage,(const void *)&pMethods);\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t    case UNQLITE_LIB_CONFIG_VFS:{\r\n\t\t\t/* Install a virtual file system */\r\n\t\t\tunqlite_vfs *pVfs = va_arg(ap,unqlite_vfs *);\r\n\t\t\tif( pVfs ){\r\n\t\t\t sUnqlMPGlobal.pVfs = pVfs;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\tcase UNQLITE_LIB_CONFIG_USER_MALLOC: {\r\n\t\t\t/* Use an alternative low-level memory allocation routines */\r\n\t\t\tconst SyMemMethods *pMethods = va_arg(ap, const SyMemMethods *);\r\n\t\t\t/* Save the memory failure callback (if available) */\r\n\t\t\tProcMemError xMemErr = sUnqlMPGlobal.sAllocator.xMemError;\r\n\t\t\tvoid *pMemErr = sUnqlMPGlobal.sAllocator.pUserData;\r\n\t\t\tif( pMethods == 0 ){\r\n\t\t\t\t/* Use the built-in memory allocation subsystem */\r\n\t\t\t\trc = SyMemBackendInit(&sUnqlMPGlobal.sAllocator, xMemErr, pMemErr);\r\n\t\t\t}else{\r\n\t\t\t\trc = SyMemBackendInitFromOthers(&sUnqlMPGlobal.sAllocator, pMethods, xMemErr, pMemErr);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t  }\r\n\t\tcase UNQLITE_LIB_CONFIG_MEM_ERR_CALLBACK: {\r\n\t\t\t/* Memory failure callback */\r\n\t\t\tProcMemError xMemErr = va_arg(ap, ProcMemError);\r\n\t\t\tvoid *pUserData = va_arg(ap, void *);\r\n\t\t\tsUnqlMPGlobal.sAllocator.xMemError = xMemErr;\r\n\t\t\tsUnqlMPGlobal.sAllocator.pUserData = pUserData;\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t }\t  \r\n\t\tcase UNQLITE_LIB_CONFIG_USER_MUTEX: {\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\t\t/* Use an alternative low-level mutex subsystem */\r\n\t\t\tconst SyMutexMethods *pMethods = va_arg(ap, const SyMutexMethods *);\r\n#if defined (UNTRUST)\r\n\t\t\tif( pMethods == 0 ){\r\n\t\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\t}\r\n#endif\r\n\t\t\t/* Sanity check */\r\n\t\t\tif( pMethods->xEnter == 0 || pMethods->xLeave == 0 || pMethods->xNew == 0){\r\n\t\t\t\t/* At least three criticial callbacks xEnter(), xLeave() and xNew() must be supplied */\r\n\t\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif( sUnqlMPGlobal.pMutexMethods ){\r\n\t\t\t\t/* Overwrite the previous mutex subsystem */\r\n\t\t\t\tSyMutexRelease(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex);\r\n\t\t\t\tif( sUnqlMPGlobal.pMutexMethods->xGlobalRelease ){\r\n\t\t\t\t\tsUnqlMPGlobal.pMutexMethods->xGlobalRelease();\r\n\t\t\t\t}\r\n\t\t\t\tsUnqlMPGlobal.pMutex = 0;\r\n\t\t\t}\r\n\t\t\t/* Initialize and install the new mutex subsystem */\r\n\t\t\tif( pMethods->xGlobalInit ){\r\n\t\t\t\trc = pMethods->xGlobalInit();\r\n\t\t\t\tif ( rc != UNQLITE_OK ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* Create the global mutex */\r\n\t\t\tsUnqlMPGlobal.pMutex = pMethods->xNew(SXMUTEX_TYPE_FAST);\r\n\t\t\tif( sUnqlMPGlobal.pMutex == 0 ){\r\n\t\t\t\t/*\r\n\t\t\t\t * If the supplied mutex subsystem is so sick that we are unable to\r\n\t\t\t\t * create a single mutex, there is no much we can do here.\r\n\t\t\t\t */\r\n\t\t\t\tif( pMethods->xGlobalRelease ){\r\n\t\t\t\t\tpMethods->xGlobalRelease();\r\n\t\t\t\t}\r\n\t\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tsUnqlMPGlobal.pMutexMethods = pMethods;\t\t\t\r\n\t\t\tif( sUnqlMPGlobal.nThreadingLevel == 0 ){\r\n\t\t\t\t/* Set a default threading level */\r\n\t\t\t\tsUnqlMPGlobal.nThreadingLevel = UNQLITE_THREAD_LEVEL_MULTI; \r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t   }\r\n\t\tcase UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE:\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\t\t/* Single thread mode (Only one thread is allowed to play with the library) */\r\n\t\t\tsUnqlMPGlobal.nThreadingLevel = UNQLITE_THREAD_LEVEL_SINGLE;\r\n\t\t\tjx9_lib_config(JX9_LIB_CONFIG_THREAD_LEVEL_SINGLE);\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI:\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\t\t/* Multi-threading mode (library is thread safe and database handles and virtual machines\r\n\t\t\t * may be shared between multiple threads).\r\n\t\t\t */\r\n\t\t\tsUnqlMPGlobal.nThreadingLevel = UNQLITE_THREAD_LEVEL_MULTI;\r\n\t\t\tjx9_lib_config(JX9_LIB_CONFIG_THREAD_LEVEL_MULTI);\r\n#endif\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t/* Unknown configuration option */\r\n\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\tbreak;\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_lib_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_lib_config(int nConfigOp,...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( sUnqlMPGlobal.nMagic == UNQLITE_LIB_MAGIC ){\r\n\t\t/* Library is already initialized, this operation is forbidden */\r\n\t\treturn UNQLITE_LOCKED;\r\n\t}\r\n\tva_start(ap,nConfigOp);\r\n\trc = unqliteCoreConfigure(nConfigOp,ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * Global library initialization\r\n * Refer to [unqlite_lib_init()]\r\n * This routine must be called to initialize the memory allocation subsystem, the mutex \r\n * subsystem prior to doing any serious work with the library. The first thread to call\r\n * this routine does the initialization process and set the magic number so no body later\r\n * can re-initialize the library. If subsequent threads call this  routine before the first\r\n * thread have finished the initialization process, then the subsequent threads must block \r\n * until the initialization process is done.\r\n */\r\nstatic sxi32 unqliteCoreInitialize(void)\r\n{\r\n\tconst unqlite_kv_methods *pMethods;\r\n\tconst unqlite_vfs *pVfs; /* Built-in vfs */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tconst SyMutexMethods *pMutexMethods = 0;\r\n\tSyMutex *pMaster = 0;\r\n#endif\r\n\tint rc;\r\n\t/*\r\n\t * If the library is already initialized, then a call to this routine\r\n\t * is a no-op.\r\n\t */\r\n\tif( sUnqlMPGlobal.nMagic == UNQLITE_LIB_MAGIC ){\r\n\t\treturn UNQLITE_OK; /* Already initialized */\r\n\t}\r\n\tif( sUnqlMPGlobal.pVfs == 0 ){\r\n\t\t/* Point to the built-in vfs */\r\n\t\tpVfs = unqliteExportBuiltinVfs();\r\n\t\t/* Install it */\r\n\t\tunqlite_lib_config(UNQLITE_LIB_CONFIG_VFS, pVfs);\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tif( sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_SINGLE ){\r\n\t\tpMutexMethods = sUnqlMPGlobal.pMutexMethods;\r\n\t\tif( pMutexMethods == 0 ){\r\n\t\t\t/* Use the built-in mutex subsystem */\r\n\t\t\tpMutexMethods = SyMutexExportMethods();\r\n\t\t\tif( pMutexMethods == 0 ){\r\n\t\t\t\treturn UNQLITE_CORRUPT; /* Can't happen */\r\n\t\t\t}\r\n\t\t\t/* Install the mutex subsystem */\r\n\t\t\trc = unqlite_lib_config(UNQLITE_LIB_CONFIG_USER_MUTEX, pMutexMethods);\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\treturn rc;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Obtain a static mutex so we can initialize the library without calling malloc() */\r\n\t\tpMaster = SyMutexNew(pMutexMethods, SXMUTEX_TYPE_STATIC_1);\r\n\t\tif( pMaster == 0 ){\r\n\t\t\treturn UNQLITE_CORRUPT; /* Can't happen */\r\n\t\t}\r\n\t}\r\n\t/* Lock the master mutex */\r\n\trc = UNQLITE_OK;\r\n\tSyMutexEnter(pMutexMethods, pMaster); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n\tif( sUnqlMPGlobal.nMagic != UNQLITE_LIB_MAGIC ){\r\n#endif\r\n\t\tif( sUnqlMPGlobal.sAllocator.pMethods == 0 ){\r\n\t\t\t/* Install a memory subsystem */\r\n\t\t\trc = unqlite_lib_config(UNQLITE_LIB_CONFIG_USER_MALLOC, 0); /* zero mean use the built-in memory backend */\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\t/* If we are unable to initialize the memory backend, there is no much we can do here.*/\r\n\t\t\t\tgoto End;\r\n\t\t\t}\r\n\t\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\tif( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE ){\r\n\t\t\t/* Protect the memory allocation subsystem */\r\n\t\t\trc = SyMemBackendMakeThreadSafe(&sUnqlMPGlobal.sAllocator, sUnqlMPGlobal.pMutexMethods);\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\tgoto End;\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n\t\tSySetInit(&sUnqlMPGlobal.kv_storage,&sUnqlMPGlobal.sAllocator,sizeof(unqlite_kv_methods *));\r\n\t\t/* Install the built-in Key Value storage engines */\r\n\t\tpMethods = unqliteExportMemKvStorage(); /* In-memory storage */\r\n\t\tunqlite_lib_config(UNQLITE_LIB_CONFIG_STORAGE_ENGINE,pMethods);\r\n\t\t/* Default disk key/value storage engine */\r\n\t\tpMethods = unqliteExportDiskKvStorage(); /* Disk storage */\r\n\t\tunqlite_lib_config(UNQLITE_LIB_CONFIG_STORAGE_ENGINE,pMethods);\r\n\t\t/* Default page size */\r\n\t\tif( sUnqlMPGlobal.iPageSize < UNQLITE_MIN_PAGE_SIZE ){\r\n\t\t\tunqlite_lib_config(UNQLITE_LIB_CONFIG_PAGE_SIZE,UNQLITE_DEFAULT_PAGE_SIZE);\r\n\t\t}\r\n\t\t/* Our library is initialized, set the magic number */\r\n\t\tsUnqlMPGlobal.nMagic = UNQLITE_LIB_MAGIC;\r\n\t\trc = UNQLITE_OK;\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t} /* sUnqlMPGlobal.nMagic != UNQLITE_LIB_MAGIC */\r\n#endif\r\nEnd:\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Unlock the master mutex */\r\n\tSyMutexLeave(pMutexMethods, pMaster); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\treturn rc;\r\n}\r\n/* Forward declaration */\r\nstatic int unqliteVmRelease(unqlite_vm *pVm);\r\n/*\r\n * Release a single instance of an unqlite database handle.\r\n */\r\nstatic int unqliteDbRelease(unqlite *pDb)\r\n{\r\n\tunqlite_db *pStore = &pDb->sDB;\r\n\tunqlite_vm *pVm,*pNext;\r\n\tint rc = UNQLITE_OK;\r\n\tif( (pDb->iFlags & UNQLITE_FL_DISABLE_AUTO_COMMIT) == 0 ){\r\n\t\t/* Commit any outstanding transaction */\r\n\t\trc = unqlitePagerCommit(pStore->pPager);\r\n\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t/* Rollback the transaction */\r\n\t\t\trc = unqlitePagerRollback(pStore->pPager,FALSE);\r\n\t\t}\r\n\t}else{\r\n\t\t/* Rollback any outstanding transaction */\r\n\t\trc = unqlitePagerRollback(pStore->pPager,FALSE);\r\n\t}\r\n\t/* Close the pager */\r\n\tunqlitePagerClose(pStore->pPager);\r\n\t/* Release any active VM's */\r\n\tpVm = pDb->pVms;\r\n\tfor(;;){\r\n\t\tif( pDb->iVm < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Point to the next entry */\r\n\t\tpNext = pVm->pNext;\r\n\t\tunqliteVmRelease(pVm);\r\n\t\tpVm = pNext;\r\n\t\tpDb->iVm--;\r\n\t}\r\n\t/* Release the Jx9 handle */\r\n\tjx9_release(pStore->pJx9);\r\n\t/* Set a dummy magic number */\r\n\tpDb->nMagic = 0x7250;\r\n\t/* Release the whole memory subsystem */\r\n\tSyMemBackendRelease(&pDb->sMem);\r\n\t/* Commit or rollback result */\r\n\treturn rc;\r\n}\r\n/*\r\n * Release all resources consumed by the library.\r\n * Note: This call is not thread safe. Refer to [unqlite_lib_shutdown()].\r\n */\r\nstatic void unqliteCoreShutdown(void)\r\n{\r\n\tunqlite *pDb, *pNext;\r\n\t/* Release all active databases handles */\r\n\tpDb = sUnqlMPGlobal.pDB;\r\n\tfor(;;){\r\n\t\tif( sUnqlMPGlobal.nDB < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pDb->pNext;\r\n\t\tunqliteDbRelease(pDb); \r\n\t\tpDb = pNext;\r\n\t\tsUnqlMPGlobal.nDB--;\r\n\t}\r\n\t/* Release the storage methods container */\r\n\tSySetRelease(&sUnqlMPGlobal.kv_storage);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Release the mutex subsystem */\r\n\tif( sUnqlMPGlobal.pMutexMethods ){\r\n\t\tif( sUnqlMPGlobal.pMutex ){\r\n\t\t\tSyMutexRelease(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex);\r\n\t\t\tsUnqlMPGlobal.pMutex = 0;\r\n\t\t}\r\n\t\tif( sUnqlMPGlobal.pMutexMethods->xGlobalRelease ){\r\n\t\t\tsUnqlMPGlobal.pMutexMethods->xGlobalRelease();\r\n\t\t}\r\n\t\tsUnqlMPGlobal.pMutexMethods = 0;\r\n\t}\r\n\tsUnqlMPGlobal.nThreadingLevel = 0;\r\n#endif\r\n\tif( sUnqlMPGlobal.sAllocator.pMethods ){\r\n\t\t/* Release the memory backend */\r\n\t\tSyMemBackendRelease(&sUnqlMPGlobal.sAllocator);\r\n\t}\r\n\tsUnqlMPGlobal.nMagic = 0x1764;\r\n\t/* Finally, shutdown the Jx9 library */\r\n\tjx9_lib_shutdown();\r\n}\r\n/*\r\n * [CAPIREF: unqlite_lib_init()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_lib_init(void)\r\n{\r\n\tint rc;\r\n\trc = unqliteCoreInitialize();\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_lib_shutdown()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_lib_shutdown(void)\r\n{\r\n\tif( sUnqlMPGlobal.nMagic != UNQLITE_LIB_MAGIC ){\r\n\t\t/* Already shut */\r\n\t\treturn UNQLITE_OK;\r\n\t}\r\n\tunqliteCoreShutdown();\r\n\treturn UNQLITE_OK;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_lib_is_threadsafe()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_lib_is_threadsafe(void)\r\n{\r\n\tif( sUnqlMPGlobal.nMagic != UNQLITE_LIB_MAGIC ){\r\n\t\treturn 0;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\tif( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE ){\r\n\t\t\t/* Muli-threading support is enabled */\r\n\t\t\treturn 1;\r\n\t\t}else{\r\n\t\t\t/* Single-threading */\r\n\t\t\treturn 0;\r\n\t\t}\r\n#else\r\n\treturn 0;\r\n#endif\r\n}\r\n/*\r\n *\r\n * [CAPIREF: unqlite_lib_version()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_lib_version(void)\r\n{\r\n\treturn UNQLITE_VERSION;\r\n}\r\n/*\r\n *\r\n * [CAPIREF: unqlite_lib_signature()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_lib_signature(void)\r\n{\r\n\treturn UNQLITE_SIG;\r\n}\r\n/*\r\n *\r\n * [CAPIREF: unqlite_lib_ident()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_lib_ident(void)\r\n{\r\n\treturn UNQLITE_IDENT;\r\n}\r\n/*\r\n *\r\n * [CAPIREF: unqlite_lib_copyright()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_lib_copyright(void)\r\n{\r\n\treturn UNQLITE_COPYRIGHT;\r\n}\r\n/*\r\n * Remove harmfull and/or stale flags passed to the [unqlite_open()] interface.\r\n */\r\nstatic unsigned int unqliteSanityzeFlag(unsigned int iFlags)\r\n{\r\n\tiFlags &= ~UNQLITE_OPEN_EXCLUSIVE; /* Reserved flag */\r\n\tif( iFlags & UNQLITE_OPEN_TEMP_DB ){\r\n\t\t/* Omit journaling for temporary database */\r\n\t\tiFlags |= UNQLITE_OPEN_OMIT_JOURNALING|UNQLITE_OPEN_CREATE;\r\n\t}\r\n\tif( (iFlags & (UNQLITE_OPEN_READONLY|UNQLITE_OPEN_READWRITE)) == 0 ){\r\n\t\t/* Auto-append the R+W flag */\r\n\t\tiFlags |= UNQLITE_OPEN_READWRITE;\r\n\t}\r\n\tif( iFlags & UNQLITE_OPEN_CREATE ){\r\n\t\tiFlags &= ~(UNQLITE_OPEN_MMAP|UNQLITE_OPEN_READONLY);\r\n\t\t/* Auto-append the R+W flag */\r\n\t\tiFlags |= UNQLITE_OPEN_READWRITE;\r\n\t}else{\r\n\t\tif( iFlags & UNQLITE_OPEN_READONLY ){\r\n\t\t\tiFlags &= ~UNQLITE_OPEN_READWRITE;\r\n\t\t}else if( iFlags & UNQLITE_OPEN_READWRITE ){\r\n\t\t\tiFlags &= ~UNQLITE_OPEN_MMAP;\r\n\t\t}\r\n\t}\r\n\treturn iFlags;\r\n}\r\n/*\r\n * This routine does the work of initializing a database handle on behalf\r\n * of [unqlite_open()].\r\n */\r\nstatic int unqliteInitDatabase(\r\n\tunqlite *pDB,            /* Database handle */\r\n\tSyMemBackend *pParent,   /* Master memory backend */\r\n\tconst char *zFilename,   /* Target database */\r\n\tunsigned int iFlags      /* Open flags */\r\n\t)\r\n{\r\n\tunqlite_db *pStorage = &pDB->sDB;\r\n\tint rc;\r\n\t/* Initialize the memory subsystem */\r\n\tSyMemBackendInitFromParent(&pDB->sMem,pParent);\r\n\tSyBlobInit(&pDB->sErr,&pDB->sMem);\r\n\t/* Sanitize flags */\r\n\tiFlags = unqliteSanityzeFlag(iFlags);\r\n\t/* Init the pager and the transaction manager */\r\n\trc = unqlitePagerOpen(sUnqlMPGlobal.pVfs,pDB,zFilename,iFlags);\r\n\tif( rc != UNQLITE_OK ){\r\n\t\treturn rc;\r\n\t}\r\n\t/* Allocate a new Jx9 engine handle */\r\n\trc = jx9_init(&pStorage->pJx9);\r\n\tif( rc != JX9_OK ){\r\n\t\treturn rc;\r\n\t}\r\n\treturn UNQLITE_OK;\r\n}\r\n/*\r\n * Allocate and initialize a new UnQLite Virtual Mahcine and attach it\r\n * to the compiled Jx9 script.\r\n */\r\nstatic int unqliteInitVm(unqlite *pDb,jx9_vm *pJx9Vm,unqlite_vm **ppOut)\r\n{\r\n\tunqlite_vm *pVm;\r\n\r\n\t*ppOut = 0;\r\n\t/* Allocate a new VM instance */\r\n\tpVm = (unqlite_vm *)SyMemBackendPoolAlloc(&pDb->sMem,sizeof(unqlite_vm));\r\n\tif( pVm == 0 ){\r\n\t\treturn UNQLITE_NOMEM;\r\n\t}\r\n\t/* Zero the structure */\r\n\tSyZero(pVm,sizeof(unqlite_vm));\r\n\t/* Initialize */\r\n\tSyMemBackendInitFromParent(&pVm->sAlloc,&pDb->sMem);\r\n\t/* Allocate a new collection table */\r\n\tpVm->apCol = (unqlite_col **)SyMemBackendAlloc(&pVm->sAlloc,32 * sizeof(unqlite_col *)); \r\n\tif( pVm->apCol == 0 ){\r\n\t\tgoto fail;\r\n\t}\r\n\tpVm->iColSize = 32; /* Must be a power of two */\r\n\t/* Zero the table */\r\n\tSyZero((void *)pVm->apCol,pVm->iColSize * sizeof(unqlite_col *));\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tif( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE ){\r\n\t\t /* Associate a recursive mutex with this instance */\r\n\t\t pVm->pMutex = SyMutexNew(sUnqlMPGlobal.pMutexMethods, SXMUTEX_TYPE_RECURSIVE);\r\n\t\t if( pVm->pMutex == 0 ){\r\n\t\t\t goto fail;\r\n\t\t }\r\n\t }\r\n#endif\r\n\t/* Link the VM to the list of active virtual machines */\r\n\tpVm->pJx9Vm = pJx9Vm;\r\n\tpVm->pDb = pDb;\r\n\tMACRO_LD_PUSH(pDb->pVms,pVm);\r\n\tpDb->iVm++;\r\n\t/* Register Jx9 functions */\r\n\tunqliteRegisterJx9Functions(pVm);\r\n\t/* Set the magic number */\r\n\tpVm->nMagic = JX9_VM_INIT; /* Same magic number as Jx9 */\r\n\t/* All done */\r\n\t*ppOut = pVm;\r\n\treturn UNQLITE_OK;\r\nfail:\r\n\tSyMemBackendRelease(&pVm->sAlloc);\r\n\tSyMemBackendPoolFree(&pDb->sMem,pVm);\r\n\treturn UNQLITE_NOMEM;\r\n}\r\n/*\r\n * Release an active VM.\r\n */\r\nstatic int unqliteVmRelease(unqlite_vm *pVm)\r\n{\r\n\t/* Release the Jx9 VM */\r\n\tjx9_vm_release(pVm->pJx9Vm);\r\n\t/* Release the private memory backend */\r\n\tSyMemBackendRelease(&pVm->sAlloc);\r\n\t/* Upper layer will discard this VM from the list\r\n\t * of active VM.\r\n\t */\r\n\treturn UNQLITE_OK;\r\n}\r\n/*\r\n * Return the default page size.\r\n */\r\nUNQLITE_PRIVATE int unqliteGetPageSize(void)\r\n{\r\n\tint iSize =  sUnqlMPGlobal.iPageSize;\r\n\tif( iSize < UNQLITE_MIN_PAGE_SIZE || iSize > UNQLITE_MAX_PAGE_SIZE ){\r\n\t\tiSize = UNQLITE_DEFAULT_PAGE_SIZE;\r\n\t}\r\n\treturn iSize;\r\n}\r\n/*\r\n * Generate an error message.\r\n */\r\nUNQLITE_PRIVATE int unqliteGenError(unqlite *pDb,const char *zErr)\r\n{\r\n\tint rc;\r\n\t/* Append the error message */\r\n\trc = SyBlobAppend(&pDb->sErr,(const void *)zErr,SyStrlen(zErr));\r\n\t/* Append a new line */\r\n\tSyBlobAppend(&pDb->sErr,(const void *)\"\\n\",sizeof(char));\r\n\treturn rc;\r\n}\r\n/*\r\n * Generate an error message (Printf like).\r\n */\r\nUNQLITE_PRIVATE int unqliteGenErrorFormat(unqlite *pDb,const char *zFmt,...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tva_start(ap,zFmt);\r\n\trc = SyBlobFormatAp(&pDb->sErr,zFmt,ap);\r\n\tva_end(ap);\r\n\t/* Append a new line */\r\n\tSyBlobAppend(&pDb->sErr,(const void *)\"\\n\",sizeof(char));\r\n\treturn rc;\r\n}\r\n/*\r\n * Generate an error message (Out of memory).\r\n */\r\nUNQLITE_PRIVATE int unqliteGenOutofMem(unqlite *pDb)\r\n{\r\n\tint rc;\r\n\trc = unqliteGenError(pDb,\"unQLite is running out of memory\");\r\n\treturn rc;\r\n}\r\n/*\r\n * Configure a working UnQLite database handle.\r\n */\r\nstatic int unqliteConfigure(unqlite *pDb,int nOp,va_list ap)\r\n{\r\n\tint rc = UNQLITE_OK;\r\n\tswitch(nOp){\r\n\tcase UNQLITE_CONFIG_JX9_ERR_LOG:\r\n\t\t/* Jx9 compile-time error log */\r\n\t\trc = jx9EngineConfig(pDb->sDB.pJx9,JX9_CONFIG_ERR_LOG,ap);\r\n\t\tbreak;\r\n\tcase UNQLITE_CONFIG_MAX_PAGE_CACHE: {\r\n\t\tint max_page = va_arg(ap,int);\r\n\t\t/* Maximum number of page to cache (Simple hint). */\r\n\t\trc = unqlitePagerSetCachesize(pDb->sDB.pPager,max_page);\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\tcase UNQLITE_CONFIG_ERR_LOG: {\r\n\t\t/* Database error log if any */\r\n\t\tconst char **pzPtr = va_arg(ap, const char **);\r\n\t\tint *pLen = va_arg(ap, int *);\r\n\t\tif( pzPtr == 0 ){\r\n\t\t\trc = JX9_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* NULL terminate the error-log buffer */\r\n\t\tSyBlobNullAppend(&pDb->sErr);\r\n\t\t/* Point to the error-log buffer */\r\n\t\t*pzPtr = (const char *)SyBlobData(&pDb->sErr);\r\n\t\tif( pLen ){\r\n\t\t\tif( SyBlobLength(&pDb->sErr) > 1 /* NULL '\\0' terminator */ ){\r\n\t\t\t\t*pLen = (int)SyBlobLength(&pDb->sErr);\r\n\t\t\t}else{\r\n\t\t\t\t*pLen = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t\t }\r\n\tcase UNQLITE_CONFIG_DISABLE_AUTO_COMMIT:{\r\n\t\t/* Disable auto-commit */\r\n\t\tpDb->iFlags |= UNQLITE_FL_DISABLE_AUTO_COMMIT;\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\tcase UNQLITE_CONFIG_GET_KV_NAME: {\r\n\t\t/* Name of the underlying KV storage engine */\r\n\t\tconst char **pzPtr = va_arg(ap,const char **);\r\n\t\tif( pzPtr ){\r\n\t\t\tunqlite_kv_engine *pEngine;\r\n\t\t\tpEngine = unqlitePagerGetKvEngine(pDb);\r\n\t\t\t/* Point to the name */\r\n\t\t\t*pzPtr = pEngine->pIo->pMethods->zName;\r\n\t\t}\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t }\r\n\tdefault:\r\n\t\t/* Unknown configuration option */\r\n\t\trc = UNQLITE_UNKNOWN;\r\n\t\tbreak;\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * Export the global (master) memory allocator to submodules.\r\n */\r\nUNQLITE_PRIVATE const SyMemBackend * unqliteExportMemBackend(void)\r\n{\r\n\treturn &sUnqlMPGlobal.sAllocator;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_open()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_open(unqlite **ppDB,const char *zFilename,unsigned int iMode)\r\n{\r\n\tunqlite *pHandle;\r\n\tint rc;\r\n#if defined(UNTRUST)\r\n\tif( ppDB == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t*ppDB = 0;\r\n\t/* One-time automatic library initialization */\r\n\trc = unqliteCoreInitialize();\r\n\tif( rc != UNQLITE_OK ){\r\n\t\treturn rc;\r\n\t}\r\n\t/* Allocate a new database handle */\r\n\tpHandle = (unqlite *)SyMemBackendPoolAlloc(&sUnqlMPGlobal.sAllocator, sizeof(unqlite));\r\n\tif( pHandle == 0 ){\r\n\t\treturn UNQLITE_NOMEM;\r\n\t}\r\n\t/* Zero the structure */\r\n\tSyZero(pHandle,sizeof(unqlite));\r\n\tif( iMode < 1 ){\r\n\t\t/* Assume a read-only database */\r\n\t\tiMode = UNQLITE_OPEN_READONLY|UNQLITE_OPEN_MMAP;\r\n\t}\r\n\t/* Init the database */\r\n\trc = unqliteInitDatabase(pHandle,&sUnqlMPGlobal.sAllocator,zFilename,iMode);\r\n\tif( rc != UNQLITE_OK ){\r\n\t\tgoto Release;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\tif( !(iMode & UNQLITE_OPEN_NOMUTEX) && (sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE) ){\r\n\t\t /* Associate a recursive mutex with this instance */\r\n\t\t pHandle->pMutex = SyMutexNew(sUnqlMPGlobal.pMutexMethods, SXMUTEX_TYPE_RECURSIVE);\r\n\t\t if( pHandle->pMutex == 0 ){\r\n\t\t\t rc = UNQLITE_NOMEM;\r\n\t\t\t goto Release;\r\n\t\t }\r\n\t }\r\n#endif\r\n\t/* Link to the list of active DB handles */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Enter the global mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t MACRO_LD_PUSH(sUnqlMPGlobal.pDB,pHandle);\r\n\t sUnqlMPGlobal.nDB++;\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Leave the global mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Set the magic number to identify a valid DB handle */\r\n\t pHandle->nMagic = UNQLITE_DB_MAGIC;\r\n\t/* Make the handle available to the caller */\r\n\t*ppDB = pHandle;\r\n\treturn UNQLITE_OK;\r\nRelease:\r\n\tSyMemBackendRelease(&pHandle->sMem);\r\n\tSyMemBackendPoolFree(&sUnqlMPGlobal.sAllocator,pHandle);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_config(unqlite *pDb,int nConfigOp,...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t va_start(ap, nConfigOp);\r\n\t rc = unqliteConfigure(&(*pDb),nConfigOp, ap);\r\n\t va_end(ap);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_close()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_close(unqlite *pDb)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Release the database handle */\r\n\trc = unqliteDbRelease(pDb);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t /* Release DB mutex */\r\n\t SyMutexRelease(sUnqlMPGlobal.pMutexMethods, pDb->pMutex) /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Enter the global mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Unlink from the list of active database handles */\r\n\t MACRO_LD_REMOVE(sUnqlMPGlobal.pDB, pDb);\r\n\tsUnqlMPGlobal.nDB--;\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t/* Leave the global mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel == UNQLITE_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Release the memory chunk allocated to this handle */\r\n\tSyMemBackendPoolFree(&sUnqlMPGlobal.sAllocator,pDb);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_compile()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_compile(unqlite *pDb,const char *zJx9,int nByte,unqlite_vm **ppOut)\r\n{\r\n\tjx9_vm *pVm;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) || ppOut == 0){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT;\r\n\t }\r\n#endif\r\n\t /* Compile the Jx9 script first */\r\n\t rc = jx9_compile(pDb->sDB.pJx9,zJx9,nByte,&pVm);\r\n\t if( rc == JX9_OK ){\r\n\t\t /* Allocate a new unqlite VM instance */\r\n\t\t rc = unqliteInitVm(pDb,pVm,ppOut);\r\n\t\t if( rc != UNQLITE_OK ){\r\n\t\t\t /* Release the Jx9 VM */\r\n\t\t\t jx9_vm_release(pVm);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_compile_file()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_compile_file(unqlite *pDb,const char *zPath,unqlite_vm **ppOut)\r\n{\r\n\tjx9_vm *pVm;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) || ppOut == 0){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT;\r\n\t }\r\n#endif\r\n\t /* Compile the Jx9 script first */\r\n\trc = jx9_compile_file(pDb->sDB.pJx9,zPath,&pVm);\r\n\tif( rc == JX9_OK ){\r\n\t\t/* Allocate a new unqlite VM instance */\r\n\t\trc = unqliteInitVm(pDb,pVm,ppOut);\r\n\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t/* Release the Jx9 VM */\r\n\t\t\tjx9_vm_release(pVm);\r\n\t\t}\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * Configure an unqlite virtual machine (Mostly Jx9 VM) instance.\r\n */\r\nstatic int unqliteVmConfig(unqlite_vm *pVm,sxi32 iOp,va_list ap)\r\n{\r\n\tint rc;\r\n\trc = jx9VmConfigure(pVm->pJx9Vm,iOp,ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_config(unqlite_vm *pVm,int iOp,...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t va_start(ap,iOp);\r\n\t rc = unqliteVmConfig(pVm,iOp,ap);\r\n\t va_end(ap);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_exec()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_exec(unqlite_vm *pVm)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Execute the Jx9 bytecode program */\r\n\t rc = jx9VmByteCodeExec(pVm->pJx9Vm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_release(unqlite_vm *pVm)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Release the VM */\r\n\t rc = unqliteVmRelease(pVm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave VM mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t /* Release VM mutex */\r\n\t SyMutexRelease(sUnqlMPGlobal.pMutexMethods,pVm->pMutex) /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t if( rc == UNQLITE_OK ){\r\n\t\t unqlite *pDb = pVm->pDb;\r\n\t\t /* Unlink from the list of active VM's */\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\t\t/* Acquire DB mutex */\r\n\t\t\tSyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t\t\tif( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t\t\tUNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t\t\treturn UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t\t\t}\r\n#endif\r\n\t\tMACRO_LD_REMOVE(pDb->pVms, pVm);\r\n\t\tpDb->iVm--;\r\n\t\t/* Release the memory chunk allocated to this instance */\r\n\t\tSyMemBackendPoolFree(&pDb->sMem,pVm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t\t\t/* Leave DB mutex */\r\n\t\t\tSyMutexLeave(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t }\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_reset()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_reset(unqlite_vm *pVm)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Reset the Jx9 VM */\r\n\t rc = jx9VmReset(pVm->pJx9Vm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_dump()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_dump(unqlite_vm *pVm, int (*xConsumer)(const void *, unsigned int, void *), void *pUserData)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Dump the Jx9 VM */\r\n\t rc = jx9VmDump(pVm->pJx9Vm,xConsumer,pUserData);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_extract_variable()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_vm_extract_variable(unqlite_vm *pVm,const char *zVarname)\r\n{\r\n\tunqlite_value *pValue;\r\n\tSyString sVariable;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn 0;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return 0; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Extract the target variable */\r\n\tSyStringInitFromBuf(&sVariable,zVarname,SyStrlen(zVarname));\r\n\tpValue = jx9VmExtractVariable(pVm->pJx9Vm,&sVariable);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn pValue;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_create_function()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_create_function(unqlite_vm *pVm, const char *zName,int (*xFunc)(unqlite_context *,int,unqlite_value **),void *pUserData)\r\n{\r\n\tSyString sName;\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n\tSyStringInitFromBuf(&sName, zName, SyStrlen(zName));\r\n\t/* Remove leading and trailing white spaces */\r\n\tSyStringFullTrim(&sName);\r\n\t/* Ticket 1433-003: NULL values are not allowed */\r\n\tif( sName.nByte < 1 || xFunc == 0 ){\r\n\t\treturn UNQLITE_INVALID;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Install the foreign function */\r\n\t rc = jx9VmInstallForeignFunction(pVm->pJx9Vm,&sName,xFunc,pUserData);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_delete_function()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_delete_function(unqlite_vm *pVm, const char *zName)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Unlink the foreign function */\r\n\t rc = jx9DeleteFunction(pVm->pJx9Vm,zName);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_create_constant()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_create_constant(unqlite_vm *pVm,const char *zName,void (*xExpand)(unqlite_value *, void *),void *pUserData)\r\n{\r\n\tSyString sName;\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n\tSyStringInitFromBuf(&sName, zName, SyStrlen(zName));\r\n\t/* Remove leading and trailing white spaces */\r\n\tSyStringFullTrim(&sName);\r\n\tif( sName.nByte < 1 ){\r\n\t\t/* Empty constant name */\r\n\t\treturn UNQLITE_INVALID;\r\n\t}\r\n\t/* TICKET 1433-003: NULL pointer is harmless operation */\r\n\tif( xExpand == 0 ){\r\n\t\treturn UNQLITE_INVALID;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Install the foreign constant */\r\n\t rc = jx9VmRegisterConstant(pVm->pJx9Vm,&sName,xExpand,pUserData);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_delete_constant()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_delete_constant(unqlite_vm *pVm, const char *zName)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Unlink the foreign constant */\r\n\t rc = Jx9DeleteConstant(pVm->pJx9Vm,zName);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_int(unqlite_value *pVal, int iValue)\r\n{\r\n\treturn jx9_value_int(pVal,iValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_int64(unqlite_value *pVal,unqlite_int64 iValue)\r\n{\r\n\treturn jx9_value_int64(pVal,iValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_bool(unqlite_value *pVal, int iBool)\r\n{\r\n\treturn jx9_value_bool(pVal,iBool);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_null(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_null(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_double(unqlite_value *pVal, double Value)\r\n{\r\n\treturn jx9_value_double(pVal,Value);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_string(unqlite_value *pVal, const char *zString, int nLen)\r\n{\r\n\treturn jx9_value_string(pVal,zString,nLen);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_string_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_string_format(unqlite_value *pVal, const char *zFormat,...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif((pVal->iFlags & MEMOBJ_STRING) == 0 ){\r\n\t\t/* Invalidate any prior representation */\r\n\t\tjx9MemObjRelease(pVal);\r\n\t\tMemObjSetType(pVal, MEMOBJ_STRING);\r\n\t}\r\n\tva_start(ap, zFormat);\r\n\trc = SyBlobFormatAp(&pVal->sBlob, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn UNQLITE_OK;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_reset_string_cursor()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_reset_string_cursor(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_reset_string_cursor(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_resource(unqlite_value *pVal,void *pUserData)\r\n{\r\n\treturn jx9_value_resource(pVal,pUserData);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_release(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_release(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_to_int(unqlite_value *pValue)\r\n{\r\n\treturn jx9_value_to_int(pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_to_bool(unqlite_value *pValue)\r\n{\r\n\treturn jx9_value_to_bool(pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_int64 unqlite_value_to_int64(unqlite_value *pValue)\r\n{\r\n\treturn jx9_value_to_int64(pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\ndouble unqlite_value_to_double(unqlite_value *pValue)\r\n{\r\n\treturn jx9_value_to_double(pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_value_to_string(unqlite_value *pValue, int *pLen)\r\n{\r\n\treturn jx9_value_to_string(pValue,pLen);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_to_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_value_to_resource(unqlite_value *pValue)\r\n{\r\n\treturn jx9_value_to_resource(pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_compare()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_compare(unqlite_value *pLeft, unqlite_value *pRight, int bStrict)\r\n{\r\n\treturn jx9_value_compare(pLeft,pRight,bStrict);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_int(unqlite_context *pCtx, int iValue)\r\n{\r\n\treturn jx9_result_int(pCtx,iValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_int64(unqlite_context *pCtx, unqlite_int64 iValue)\r\n{\r\n\treturn jx9_result_int64(pCtx,iValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_bool(unqlite_context *pCtx, int iBool)\r\n{\r\n\treturn jx9_result_bool(pCtx,iBool);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_double(unqlite_context *pCtx, double Value)\r\n{\r\n\treturn jx9_result_double(pCtx,Value);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_null(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_result_null(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_string(unqlite_context *pCtx, const char *zString, int nLen)\r\n{\r\n\treturn jx9_result_string(pCtx,zString,nLen);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_string_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_string_format(unqlite_context *pCtx, const char *zFormat, ...)\r\n{\r\n\tjx9_value *p;\r\n\tva_list ap;\r\n\tint rc;\r\n\tp = pCtx->pRet;\r\n\tif( (p->iFlags & MEMOBJ_STRING) == 0 ){\r\n\t\t/* Invalidate any prior representation */\r\n\t\tjx9MemObjRelease(p);\r\n\t\tMemObjSetType(p, MEMOBJ_STRING);\r\n\t}\r\n\t/* Format the given string */\r\n\tva_start(ap, zFormat);\r\n\trc = SyBlobFormatAp(&p->sBlob, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_value(unqlite_context *pCtx, unqlite_value *pValue)\r\n{\r\n\treturn jx9_result_value(pCtx,pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_result_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_result_resource(unqlite_context *pCtx, void *pUserData)\r\n{\r\n\treturn jx9_result_resource(pCtx,pUserData);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_int(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_int(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_float()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_float(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_float(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_bool(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_bool(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_string(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_string(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_null(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_null(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_numeric()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_numeric(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_numeric(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_callable()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_callable(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_callable(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_scalar(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_scalar(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_json_array()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_json_array(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_json_array(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_json_object()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_json_object(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_json_object(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_resource(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_resource(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_value_is_empty()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_value_is_empty(unqlite_value *pVal)\r\n{\r\n\treturn jx9_value_is_empty(pVal);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_array_fetch()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_array_fetch(unqlite_value *pArray, const char *zKey, int nByte)\r\n{\r\n\treturn jx9_array_fetch(pArray,zKey,nByte);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_array_walk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_array_walk(unqlite_value *pArray, int (*xWalk)(unqlite_value *, unqlite_value *, void *), void *pUserData)\r\n{\r\n\treturn jx9_array_walk(pArray,xWalk,pUserData);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_array_add_elem()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_array_add_elem(unqlite_value *pArray, unqlite_value *pKey, unqlite_value *pValue)\r\n{\r\n\treturn jx9_array_add_elem(pArray,pKey,pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_array_add_strkey_elem()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_array_add_strkey_elem(unqlite_value *pArray, const char *zKey, unqlite_value *pValue)\r\n{\r\n\treturn jx9_array_add_strkey_elem(pArray,zKey,pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_array_count()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_array_count(unqlite_value *pArray)\r\n{\r\n\treturn (int)jx9_array_count(pArray);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_new_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_vm_new_scalar(unqlite_vm *pVm)\r\n{\r\n\tunqlite_value *pValue;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn 0;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return 0; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t pValue = jx9_new_scalar(pVm->pJx9Vm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn pValue;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_new_array()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_vm_new_array(unqlite_vm *pVm)\r\n{\r\n\tunqlite_value *pValue;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn 0;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return 0; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t pValue = jx9_new_array(pVm->pJx9Vm);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn pValue;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_vm_release_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_vm_release_value(unqlite_vm *pVm,unqlite_value *pValue)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_VM_MISUSE(pVm) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t rc = jx9_release_value(pVm->pJx9Vm,pValue);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_output()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_output(unqlite_context *pCtx, const char *zString, int nLen)\r\n{\r\n\treturn jx9_context_output(pCtx,zString,nLen);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_output_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_output_format(unqlite_context *pCtx,const char *zFormat, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tva_start(ap, zFormat);\r\n\trc = jx9VmOutputConsumeAp(pCtx->pVm,zFormat, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_throw_error()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_throw_error(unqlite_context *pCtx, int iErr, const char *zErr)\r\n{\r\n\treturn jx9_context_throw_error(pCtx,iErr,zErr);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_throw_error_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_throw_error_format(unqlite_context *pCtx, int iErr, const char *zFormat, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( zFormat == 0){\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tva_start(ap, zFormat);\r\n\trc = jx9VmThrowErrorAp(pCtx->pVm, &pCtx->pFunc->sName, iErr, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_random_num()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunsigned int unqlite_context_random_num(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_random_num(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_random_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_random_string(unqlite_context *pCtx, char *zBuf, int nBuflen)\r\n{\r\n\treturn jx9_context_random_string(pCtx,zBuf,nBuflen);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_user_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_context_user_data(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_user_data(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_push_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_context_push_aux_data(unqlite_context *pCtx, void *pUserData)\r\n{\r\n\treturn jx9_context_push_aux_data(pCtx,pUserData);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_peek_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_context_peek_aux_data(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_peek_aux_data(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_pop_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_context_pop_aux_data(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_pop_aux_data(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_result_buf_length()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunsigned int unqlite_context_result_buf_length(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_result_buf_length(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_function_name()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nconst char * unqlite_function_name(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_function_name(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_new_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_context_new_scalar(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_new_scalar(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_new_array()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nunqlite_value * unqlite_context_new_array(unqlite_context *pCtx)\r\n{\r\n\treturn jx9_context_new_array(pCtx);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_release_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid unqlite_context_release_value(unqlite_context *pCtx,unqlite_value *pValue)\r\n{\r\n\tjx9_context_release_value(pCtx,pValue);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_alloc_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_context_alloc_chunk(unqlite_context *pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease)\r\n{\r\n\treturn jx9_context_alloc_chunk(pCtx,nByte,ZeroChunk,AutoRelease);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_realloc_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid * unqlite_context_realloc_chunk(unqlite_context *pCtx,void *pChunk,unsigned int nByte)\r\n{\r\n\treturn jx9_context_realloc_chunk(pCtx,pChunk,nByte);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_context_free_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nvoid unqlite_context_free_chunk(unqlite_context *pCtx,void *pChunk)\r\n{\r\n\tjx9_context_free_chunk(pCtx,pChunk);\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_store()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_store(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen)\r\n{\r\n\tunqlite_kv_engine *pEngine;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t if( pEngine->pIo->pMethods->xReplace == 0 ){\r\n\t\t /* Storage engine does not implement such method */\r\n\t\t unqliteGenError(pDb,\"xReplace() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t if( nKeyLen < 0 ){\r\n\t\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t\t }\r\n\t\t if( !nKeyLen ){\r\n\t\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t\t rc = UNQLITE_EMPTY;\r\n\t\t }else{\r\n\t\t\t /* Perform the requested operation */\r\n\t\t\t rc = pEngine->pIo->pMethods->xReplace(pEngine,pKey,nKeyLen,pData,nDataLen);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_store_fmt()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_store_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...)\r\n{\r\n\tunqlite_kv_engine *pEngine;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t if( pEngine->pIo->pMethods->xReplace == 0 ){\r\n\t\t /* Storage engine does not implement such method */\r\n\t\t unqliteGenError(pDb,\"xReplace() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t if( nKeyLen < 0 ){\r\n\t\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t\t }\r\n\t\t if( !nKeyLen ){\r\n\t\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t\t rc = UNQLITE_EMPTY;\r\n\t\t }else{\r\n\t\t\t SyBlob sWorker; /* Working buffer */\r\n\t\t\t va_list ap;\r\n\t\t\t SyBlobInit(&sWorker,&pDb->sMem);\r\n\t\t\t /* Format the data */\r\n\t\t\t va_start(ap,zFormat);\r\n\t\t\t SyBlobFormatAp(&sWorker,zFormat,ap);\r\n\t\t\t va_end(ap);\r\n\t\t\t /* Perform the requested operation */\r\n\t\t\t rc = pEngine->pIo->pMethods->xReplace(pEngine,pKey,nKeyLen,SyBlobData(&sWorker),SyBlobLength(&sWorker));\r\n\t\t\t /* Clean up */\r\n\t\t\t SyBlobRelease(&sWorker);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_append()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_append(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen)\r\n{\r\n\tunqlite_kv_engine *pEngine;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t if( pEngine->pIo->pMethods->xAppend == 0 ){\r\n\t\t /* Storage engine does not implement such method */\r\n\t\t unqliteGenError(pDb,\"xAppend() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t if( nKeyLen < 0 ){\r\n\t\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t\t }\r\n\t\t if( !nKeyLen ){\r\n\t\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t\t rc = UNQLITE_EMPTY;\r\n\t\t }else{\r\n\t\t\t /* Perform the requested operation */\r\n\t\t\t rc = pEngine->pIo->pMethods->xAppend(pEngine,pKey,nKeyLen,pData,nDataLen);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_append_fmt()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_append_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...)\r\n{\r\n\tunqlite_kv_engine *pEngine;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t if( pEngine->pIo->pMethods->xAppend == 0 ){\r\n\t\t /* Storage engine does not implement such method */\r\n\t\t unqliteGenError(pDb,\"xAppend() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t if( nKeyLen < 0 ){\r\n\t\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t\t }\r\n\t\t if( !nKeyLen ){\r\n\t\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t\t rc = UNQLITE_EMPTY;\r\n\t\t }else{\r\n\t\t\t SyBlob sWorker; /* Working buffer */\r\n\t\t\t va_list ap;\r\n\t\t\t SyBlobInit(&sWorker,&pDb->sMem);\r\n\t\t\t /* Format the data */\r\n\t\t\t va_start(ap,zFormat);\r\n\t\t\t SyBlobFormatAp(&sWorker,zFormat,ap);\r\n\t\t\t va_end(ap);\r\n\t\t\t /* Perform the requested operation */\r\n\t\t\t rc = pEngine->pIo->pMethods->xAppend(pEngine,pKey,nKeyLen,SyBlobData(&sWorker),SyBlobLength(&sWorker));\r\n\t\t\t /* Clean up */\r\n\t\t\t SyBlobRelease(&sWorker);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_fetch()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_fetch(unqlite *pDb,const void *pKey,int nKeyLen,void *pBuf,unqlite_int64 *pBufLen)\r\n{\r\n\tunqlite_kv_methods *pMethods;\r\n\tunqlite_kv_engine *pEngine;\r\n\tunqlite_kv_cursor *pCur;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t pMethods = pEngine->pIo->pMethods;\r\n\t pCur = pDb->sDB.pCursor;\r\n\t if( nKeyLen < 0 ){\r\n\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t }\r\n\t if( !nKeyLen ){\r\n\t\t  unqliteGenError(pDb,\"Empty key\");\r\n\t\t  rc = UNQLITE_EMPTY;\r\n\t }else{\r\n\t\t  /* Seek to the record position */\r\n\t\t  rc = pMethods->xSeek(pCur,pKey,nKeyLen,UNQLITE_CURSOR_MATCH_EXACT);\r\n\t }\r\n\t if( rc == UNQLITE_OK ){\r\n\t\t if( pBuf == 0 ){\r\n\t\t\t /* Data length only */\r\n\t\t\t rc = pMethods->xDataLength(pCur,pBufLen);\r\n\t\t }else{\r\n\t\t\t SyBlob sBlob;\r\n\t\t\t /* Initialize the data consumer */\r\n\t\t\t SyBlobInitFromBuf(&sBlob,pBuf,(sxu32)*pBufLen);\r\n\t\t\t /* Consume the data */\r\n\t\t\t rc = pMethods->xData(pCur,unqliteDataConsumer,&sBlob);\r\n\t\t\t /* Data length */\r\n\t\t\t *pBufLen = (unqlite_int64)SyBlobLength(&sBlob);\r\n\t\t\t /* Cleanup */\r\n\t\t\t SyBlobRelease(&sBlob);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_fetch_callback()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_fetch_callback(unqlite *pDb,const void *pKey,int nKeyLen,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData)\r\n{\r\n\tunqlite_kv_methods *pMethods;\r\n\tunqlite_kv_engine *pEngine;\r\n\tunqlite_kv_cursor *pCur;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t pMethods = pEngine->pIo->pMethods;\r\n\t pCur = pDb->sDB.pCursor;\r\n\t if( nKeyLen < 0 ){\r\n\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t }\r\n\t if( !nKeyLen ){\r\n\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t rc = UNQLITE_EMPTY;\r\n\t }else{\r\n\t\t /* Seek to the record position */\r\n\t\t rc = pMethods->xSeek(pCur,pKey,nKeyLen,UNQLITE_CURSOR_MATCH_EXACT);\r\n\t }\r\n\t if( rc == UNQLITE_OK && xConsumer ){\r\n\t\t /* Consume the data directly */\r\n\t\t rc = pMethods->xData(pCur,xConsumer,pUserData);\t \r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_delete()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_delete(unqlite *pDb,const void *pKey,int nKeyLen)\r\n{\r\n\tunqlite_kv_methods *pMethods;\r\n\tunqlite_kv_engine *pEngine;\r\n\tunqlite_kv_cursor *pCur;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t pMethods = pEngine->pIo->pMethods;\r\n\t pCur = pDb->sDB.pCursor;\r\n\t if( pMethods->xDelete == 0 ){\r\n\t\t /* Storage engine does not implement such method */\r\n\t\t unqliteGenError(pDb,\"xDelete() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t if( nKeyLen < 0 ){\r\n\t\t\t /* Assume a null terminated string and compute it's length */\r\n\t\t\t nKeyLen = SyStrlen((const char *)pKey);\r\n\t\t }\r\n\t\t if( !nKeyLen ){\r\n\t\t\t unqliteGenError(pDb,\"Empty key\");\r\n\t\t\t rc = UNQLITE_EMPTY;\r\n\t\t }else{\r\n\t\t\t /* Seek to the record position */\r\n\t\t\t rc = pMethods->xSeek(pCur,pKey,nKeyLen,UNQLITE_CURSOR_MATCH_EXACT);\r\n\t\t }\r\n\t\t if( rc == UNQLITE_OK ){\r\n\t\t\t /* Exact match found, delete the entry */\r\n\t\t\t rc = pMethods->xDelete(pCur);\r\n\t\t }\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_config(unqlite *pDb,int iOp,...)\r\n{\r\n\tunqlite_kv_engine *pEngine;\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Point to the underlying storage engine */\r\n\t pEngine = unqlitePagerGetKvEngine(pDb);\r\n\t if( pEngine->pIo->pMethods->xConfig == 0 ){\r\n\t\t /* Storage engine does not implements such method */\r\n\t\t unqliteGenError(pDb,\"xConfig() method not implemented in the underlying storage engine\");\r\n\t\t rc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{\r\n\t\t va_list ap;\r\n\t\t /* Configure the storage engine */\r\n\t\t va_start(ap,iOp);\r\n\t\t rc = pEngine->pIo->pMethods->xConfig(pEngine,iOp,ap);\r\n\t\t va_end(ap);\r\n\t }\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_init()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_init(unqlite *pDb,unqlite_kv_cursor **ppOut)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) || ppOut == 0 /* Noop */){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Allocate a new cursor */\r\n\t rc = unqliteInitCursor(pDb,ppOut);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_release(unqlite *pDb,unqlite_kv_cursor *pCur)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) || pCur == 0 /* Noop */){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Release the cursor */\r\n\t rc = unqliteReleaseCursor(pDb,pCur);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_first_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_first_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xFirst == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Seek to the first entry */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xFirst(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_last_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_last_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xLast == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Seek to the last entry */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xLast(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_valid_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_valid_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xValid == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\trc = pCursor->pStore->pIo->pMethods->xValid(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_next_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_next_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xNext == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Seek to the next entry */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xNext(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_prev_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_prev_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xPrev == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Seek to the previous entry */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xPrev(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_delete_entry()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_delete_entry(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xDelete == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Delete the entry */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xDelete(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_reset()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_reset(unqlite_kv_cursor *pCursor)\r\n{\r\n\tint rc = UNQLITE_OK;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Check if the requested method is implemented by the underlying storage engine */\r\n\tif( pCursor->pStore->pIo->pMethods->xReset == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t}else{\r\n\t\t/* Reset */\r\n\t\tpCursor->pStore->pIo->pMethods->xReset(pCursor);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_seek()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_seek(unqlite_kv_cursor *pCursor,const void *pKey,int nKeyLen,int iPos)\r\n{\r\n\tint rc = UNQLITE_OK;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\tif( nKeyLen < 0 ){\r\n\t\t/* Assume a null terminated string and compute it's length */\r\n\t\tnKeyLen = SyStrlen((const char *)pKey);\r\n\t}\r\n\tif( !nKeyLen ){\r\n\t\trc = UNQLITE_EMPTY;\r\n\t}else{\r\n\t\t/* Seek to the desired location */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xSeek(pCursor,pKey,nKeyLen,iPos);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * Default data consumer callback. That is, all retrieved is redirected to this\r\n * routine which store the output in an internal blob.\r\n */\r\nUNQLITE_PRIVATE int unqliteDataConsumer(\r\n\tconst void *pOut,   /* Data to consume */\r\n\tunsigned int nLen,  /* Data length */\r\n\tvoid *pUserData     /* User private data */\r\n\t)\r\n{\r\n\t sxi32 rc;\r\n\t /* Store the output in an internal BLOB */\r\n\t rc = SyBlobAppend((SyBlob *)pUserData, pOut, nLen);\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_data_callback()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_key_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Consume the key directly */\r\n\trc = pCursor->pStore->pIo->pMethods->xKey(pCursor,xConsumer,pUserData);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_key()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_key(unqlite_kv_cursor *pCursor,void *pBuf,int *pnByte)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\tif( pBuf == 0 ){\r\n\t\t/* Key length only */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xKeyLength(pCursor,pnByte);\r\n\t}else{\r\n\t\tSyBlob sBlob;\r\n\t\tif( (*pnByte) < 0 ){\r\n\t\t\treturn UNQLITE_CORRUPT;\r\n\t\t}\r\n\t\t/* Initialize the data consumer */\r\n\t\tSyBlobInitFromBuf(&sBlob,pBuf,(sxu32)(*pnByte));\r\n\t\t/* Consume the key */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xKey(pCursor,unqliteDataConsumer,&sBlob);\r\n\t\t /* Key length */\r\n\t\t*pnByte = SyBlobLength(&sBlob);\r\n\t\t/* Cleanup */\r\n\t\tSyBlobRelease(&sBlob);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_data_callback()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_data_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\t/* Consume the data directly */\r\n\trc = pCursor->pStore->pIo->pMethods->xData(pCursor,xConsumer,pUserData);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_kv_cursor_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_kv_cursor_data(unqlite_kv_cursor *pCursor,void *pBuf,unqlite_int64 *pnByte)\r\n{\r\n\tint rc;\r\n#ifdef UNTRUST\r\n\tif( pCursor == 0 ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#endif\r\n\tif( pBuf == 0 ){\r\n\t\t/* Data length only */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xDataLength(pCursor,pnByte);\r\n\t}else{\r\n\t\tSyBlob sBlob;\r\n\t\tif( (*pnByte) < 0 ){\r\n\t\t\treturn UNQLITE_CORRUPT;\r\n\t\t}\r\n\t\t/* Initialize the data consumer */\r\n\t\tSyBlobInitFromBuf(&sBlob,pBuf,(sxu32)(*pnByte));\r\n\t\t/* Consume the data */\r\n\t\trc = pCursor->pStore->pIo->pMethods->xData(pCursor,unqliteDataConsumer,&sBlob);\r\n\t\t/* Data length */\r\n\t\t*pnByte = SyBlobLength(&sBlob);\r\n\t\t/* Cleanup */\r\n\t\tSyBlobRelease(&sBlob);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_begin()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_begin(unqlite *pDb)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Begin the write transaction */\r\n\t rc = unqlitePagerBegin(pDb->sDB.pPager);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_commit()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_commit(unqlite *pDb)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Commit the transaction */\r\n\t rc = unqlitePagerCommit(pDb->sDB.pPager);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_rollback()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nint unqlite_rollback(unqlite *pDb)\r\n{\r\n\tint rc;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Rollback the transaction */\r\n\t rc = unqlitePagerRollback(pDb->sDB.pPager,TRUE);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_util_load_mmaped_file()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nUNQLITE_APIEXPORT int unqlite_util_load_mmaped_file(const char *zFile,void **ppMap,unqlite_int64 *pFileSize)\r\n{\r\n\tconst jx9_vfs *pVfs;\r\n\tint rc;\r\n\tif( SX_EMPTY_STR(zFile) || ppMap == 0 || pFileSize == 0){\r\n\t\t/* Sanity check */\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n\t*ppMap = 0;\r\n\t/* Extract the Jx9 Vfs */\r\n\tpVfs = jx9ExportBuiltinVfs();\r\n\t/*\r\n\t * Check if the underlying vfs implement the memory map routines\r\n\t * [i.e: mmap() under UNIX/MapViewOfFile() under windows].\r\n\t */\r\n\tif( pVfs == 0 || pVfs->xMmap == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{ \r\n\t\t /* Try to get a read-only memory view of the whole file */\r\n\t\t rc = pVfs->xMmap(zFile,ppMap,pFileSize);\r\n\t }\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_util_release_mmaped_file()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nUNQLITE_APIEXPORT int unqlite_util_release_mmaped_file(void *pMap,unqlite_int64 iFileSize)\r\n{\r\n\tconst jx9_vfs *pVfs;\r\n\tint rc = UNQLITE_OK;\r\n\tif( pMap == 0 ){\r\n\t\treturn UNQLITE_OK;\r\n\t}\r\n\t/* Extract the Jx9 Vfs */\r\n\tpVfs = jx9ExportBuiltinVfs();\r\n\tif( pVfs == 0 || pVfs->xUnmap == 0 ){\r\n\t\trc = UNQLITE_NOTIMPLEMENTED;\r\n\t }else{ \r\n\t\t pVfs->xUnmap(pMap,iFileSize);\r\n\t }\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_util_random_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nUNQLITE_APIEXPORT int unqlite_util_random_string(unqlite *pDb,char *zBuf,unsigned int buf_size)\r\n{\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn UNQLITE_CORRUPT;\r\n\t}\r\n\tif( zBuf == 0 || buf_size < 3 ){\r\n\t\t/* Buffer must be long enough to hold three bytes */\r\n\t\treturn UNQLITE_INVALID;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Generate the random string */\r\n\t unqlitePagerRandomString(pDb->sDB.pPager,zBuf,buf_size);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return UNQLITE_OK;\r\n}\r\n/*\r\n * [CAPIREF: unqlite_util_random_num()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nUNQLITE_APIEXPORT unsigned int unqlite_util_random_num(unqlite *pDb)\r\n{\r\n\tsxu32 iNum;\r\n\tif( UNQLITE_DB_MISUSE(pDb) ){\r\n\t\treturn 0;\r\n\t}\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Acquire DB mutex */\r\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \r\n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\r\n\t\t\t return 0; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /* Generate the random number */\r\n\t iNum = unqlitePagerRandomNum(pDb->sDB.pPager);\r\n#if defined(UNQLITE_ENABLE_THREADS)\r\n\t /* Leave DB mutex */\r\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return iNum;\r\n}\r\n/*\r\n * ----------------------------------------------------------\r\n * File: bitvec.c\r\n * MD5: 7e3376710d8454ebcf8c77baacca880f\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/\r\n * Version 1.1.6\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n /* $SymiscID: bitvec.c v1.0 Win7 2013-02-27 15:16 stable <chm@symisc.net> $ */\r\n#ifndef UNQLITE_AMALGAMATION\r\n#include \"unqliteInt.h\"\r\n#endif\r\n\r\n/** This file implements an object that represents a dynmaic\r\n** bitmap.\r\n**\r\n** A bitmap is used to record which pages of a database file have been\r\n** journalled during a transaction, or which pages have the \"dont-write\"\r\n** property.  Usually only a few pages are meet either condition.\r\n** So the bitmap is usually sparse and has low cardinality.\r\n*/\r\n/*\r\n * Actually, this is not a bitmap but a simple hashtable where page \r\n * number (64-bit unsigned integers) are used as the lookup keys.\r\n */\r\ntypedef struct bitvec_rec bitvec_rec;\r\nstruct bitvec_rec\r\n{\r\n\tpgno iPage;                  /* Page number */\r\n\tbitvec_rec *pNext,*pNextCol; /* Collison link */\r\n};\r\nstruct Bitvec\r\n{\r\n\tSyMemBackend *pAlloc; /* Memory allocator */\r\n\tsxu32 nRec;           /* Total number of records */\r\n\tsxu32 nSize;          /* Table size */\r\n\tbitvec_rec **apRec;   /* Record table */\r\n\tbitvec_rec *pList;    /* List of records */\r\n};\r\n/* \r\n * Allocate a new bitvec instance.\r\n*/\r\nUNQLITE_PRIVATE Bitvec * unqliteBitvecCreate(SyMemBackend *pAlloc,pgno iSize)\r\n{\r\n\tbitvec_rec **apNew;\r\n\tBitvec *p;\r\n\t\r\n\tp = (Bitvec *)SyMemBackendAlloc(pAlloc,sizeof(*p) );\r\n\tif( p == 0 ){\r\n\t\tSXUNUSED(iSize); /* cc warning */\r\n\t\treturn 0;\r\n\t}\r\n\t/* Zero the structure */\r\n\tSyZero(p,sizeof(Bitvec));\r\n\t/* Allocate a new table */\r\n\tp->nSize = 64; /* Must be a power of two */\r\n\tapNew = (bitvec_rec **)SyMemBackendAlloc(pAlloc,p->nSize * sizeof(bitvec_rec *));\r\n\tif( apNew == 0 ){\r\n\t\tSyMemBackendFree(pAlloc,p);\r\n\t\treturn 0;\r\n\t}\r\n\t/* Zero the new table */\r\n\tSyZero((void *)apNew,p->nSize * sizeof(bitvec_rec *));\r\n\t/* Fill-in */\r\n\tp->apRec = apNew;\r\n\tp->pAlloc = pAlloc;\r\n\treturn p;\r\n}\r\n/*\r\n * Check if the given page number is already installed in the table.\r\n * Return true if installed. False otherwise.\r\n */\r\nUNQLITE_PRIVATE int unqliteBitvecTest(Bitvec *p,pgno i)\r\n{  \r\n\tbitvec_rec *pRec;\r\n\t/* Point to the desired bucket */\r\n\tpRec = p->apRec[i & (p->nSize - 1)];\r\n\tfor(;;){\r\n\t\tif( pRec == 0 ){ break; }\r\n\t\tif( pRec->iPage == i ){\r\n\t\t\t/* Page found */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t/* Point to the next entry */\r\n\t\tpRec = pRec->pNextCol;\r\n\r\n\t\tif( pRec == 0 ){ break; }\r\n\t\tif( pRec->iPage == i ){\r\n\t\t\t/* Page found */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t/* Point to the next entry */\r\n\t\tpRec = pRec->pNextCol;\r\n\r\n\r\n\t\tif( pRec == 0 ){ break; }\r\n\t\tif( pRec->iPage == i ){\r\n\t\t\t/* Page found */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t/* Point to the next entry */\r\n\t\tpRec = pRec->pNextCol;\r\n\r\n\r\n\t\tif( pRec == 0 ){ break; }\r\n\t\tif( pRec->iPage == i ){\r\n\t\t\t/* Page found */\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t/* Point to the next entry */\r\n\t\tpRec = pRec->pNextCol;\r\n\t}\r\n\t/* No such entry */\r\n\treturn 0;\r\n}\r\n/*\r\n * Install a given page number in our bitmap (Actually, our hashtable).\r\n */\r\nUNQLITE_PRIVATE int unqliteBitvecSet(Bitvec *p,pgno i)\r\n{\r\n\tbitvec_rec *pRec;\r\n\tsxi32 iBuck;\r\n\t/* Allocate a new instance */\r\n\tpRec = (bitvec_rec *)SyMemBackendPoolAlloc(p->pAlloc,sizeof(bitvec_rec));\r\n\tif( pRec == 0 ){\r\n\t\treturn UNQLITE_NOMEM;\r\n\t}\r\n\t/* Zero the structure */\r\n\tSyZero(pRec,sizeof(bitvec_rec));\r\n\t/* Fill-in */\r\n\tpRec->iPage = i;\r\n\tiBuck = i & (p->nSize - 1);\r\n\tpRec->pNextCol = p->apRec[iBuck];\r\n\tp->apRec[iBuck] = pRec;\r\n\tpRec->pNext = p->pList;\r\n\tp->pList = pRec;\r\n\tp->nRec++;\r\n\tif( p->nRec >= (p->nSize * 3) && p->nRec < 100000 ){\r\n\t\t/* Grow the hashtable */\r\n\t\tsxu32 nNewSize = p->nSize << 1;\r\n\t\tbitvec_rec *pEntry,**apNew;\r\n\t\tsxu32 n;\r\n\t\tapNew = (bitvec_rec **)SyMemBackendAlloc(p->pAlloc, nNewSize * sizeof(bitvec_rec *));\r\n\t\tif( apNew ){\r\n\t\t\tsxu32 iBucket;\r\n\t\t\t/* Zero the new table */\r\n\t\t\tSyZero((void *)apNew, nNewSize * sizeof(bitvec_rec *));\r\n\t\t\t/* Rehash all entries */\r\n\t\t\tn = 0;\r\n\t\t\tpEntry = p->pList;\r\n\t\t\tfor(;;){\r\n\t\t\t\t/* Loop one */\r\n\t\t\t\tif( n >= p->nRec ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tpEntry->pNextCol = 0;\r\n\t\t\t\t/* Install in the new bucket */\r\n\t\t\t\tiBucket = pEntry->iPage & (nNewSize - 1);\r\n\t\t\t\tpEntry->pNextCol = apNew[iBucket];\r\n\t\t\t\tapNew[iBucket] = pEntry;\r\n\t\t\t\t/* Point to the next entry */\r\n\t\t\t\tpEntry = pEntry->pNext;\r\n\t\t\t\tn++;\r\n\t\t\t}\r\n\t\t\t/* Release the old table and reflect the change */\r\n\t\t\tSyMemBackendFree(p->pAlloc,(void *)p->apRec);\r\n\t\t\tp->apRec = apNew;\r\n\t\t\tp->nSize  = nNewSize;\r\n\t\t}\r\n\t}\r\n\treturn UNQLITE_OK;\r\n}\r\n/*\r\n * Destroy a bitvec instance. Reclaim all memory used.\r\n */\r\nUNQLITE_PRIVATE void unqliteBitvecDestroy(Bitvec *p)\r\n{\r\n\tbitvec_rec *pNext,*pRec = p->pList;\r\n\tSyMemBackend *pAlloc = p->pAlloc;\r\n\t\r\n\tfor(;;){\r\n\t\tif( p->nRec < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pRec->pNext;\r\n\t\tSyMemBackendPoolFree(pAlloc,(void *)pRec);\r\n\t\tpRec = pNext;\r\n\t\tp->nRec--;\r\n\r\n\t\tif( p->nRec < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pRec->pNext;\r\n\t\tSyMemBackendPoolFree(pAlloc,(void *)pRec);\r\n\t\tpRec = pNext;\r\n\t\tp->nRec--;\r\n\r\n\r\n\t\tif( p->nRec < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pRec->pNext;\r\n\t\tSyMemBackendPoolFree(pAlloc,(void *)pRec);\r\n\t\tpRec = pNext;\r\n\t\tp->nRec--;\r\n\r\n\r\n\t\tif( p->nRec < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pRec->pNext;\r\n\t\tSyMemBackendPoolFree(pAlloc,(void *)pRec);\r\n\t\tpRec = pNext;\r\n\t\tp->nRec--;\r\n\t}\r\n\tSyMemBackendFree(pAlloc,(void *)p->apRec);\r\n\tSyMemBackendFree(pAlloc,p);\r\n}\r\n/*\r\n * ----------------------------------------------------------\r\n * File: fastjson.c\r\n * MD5: 3693c0022edc7d37b65124d7aef68397\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc unQLite: An Embeddable NoSQL (Post Modern) Database Engine.\r\n * Copyright (C) 2012-2013, Symisc Systems http://unqlite.org/\r\n * Version 1.1.6\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://unqlite.org/licensing.html\r\n */\r\n /* $SymiscID: fastjson.c v1.1 FreeBSD 2012-12-05 22:52 stable <chm@symisc.net> $ */\r\n#ifndef UNQLITE_AMALGAMATION\r\n#include \"unqliteInt.h\"\r\n#endif\r\n/* JSON binary encoding, decoding and stuff like that */\r\n#ifndef UNQLITE_FAST_JSON_NEST_LIMIT\r\n#if defined(__WINNT__) || defined(__UNIXES__)\r\n#define UNQLITE_FAST_JSON_NEST_LIMIT 64 /* Nesting limit */\r\n#else\r\n#define UNQLITE_FAST_JSON_NEST_LIMIT 32 /* Nesting limit */\r\n#endif\r\n#endif /* UNQLITE_FAST_JSON_NEST_LIMIT */\r\n/* \r\n * JSON to Binary using the FastJSON implementation (BigEndian).\r\n */\r\n/*\r\n * FastJSON implemented binary token.\r\n */\r\n#define FJSON_DOC_START    1 /* { */\r\n#define FJSON_DOC_END      2 /* } */\r\n#define FJSON_ARRAY_START  3 /* [ */\r\n#define FJSON_ARRAY_END    4 /* ] */\r\n#define FJSON_COLON        5 /* : */\r\n#define FJSON_COMMA        6 /* , */\r\n#define FJSON_ID           7 /* ID + 4 Bytes length */\r\n#define FJSON_STRING       8 /* String + 4 bytes length */\r\n#define FJSON_BYTE         9 /* Byte */\r\n#define FJSON_INT64       10 /* Integer 64 + 8 bytes */\r\n#define FJSON_REAL        18 /* Floating point value + 2 bytes */\r\n#define FJSON_NULL        23 /* NULL */\r\n#define FJSON_TRUE        24 /* TRUE */\r\n#define FJSON_FALSE       25 /* FALSE */\r\n/*\r\n * Encode a Jx9 value to binary JSON.\r\n */\r\nUNQLITE_PRIVATE sxi32 FastJsonEncode(\r\n\tjx9_value *pValue, /* Value to encode */\r\n\tSyBlob *pOut,      /* Store encoded value here */\r\n\tint iNest          /* Nesting limit */ \r\n\t)\r\n{\r\n\tsxi32 iType = pValue ? pValue->iFlags : MEMOBJ_NULL;\r\n\tsxi32 rc = SXRET_OK;\r\n\tint c;\r\n\tif( iNest >= UNQLITE_FAST_JSON_NEST_LIMIT ){\r\n\t\t/* Nesting limit reached */\r\n\t\treturn SXERR_LIMIT;\r\n\t}\r\n\tif( iType & (MEMOBJ_NULL|MEMOBJ_RES) ){\r\n\t\t/*\r\n\t\t * Resources are encoded as null also.\r\n\t\t */\r\n\t\tc = FJSON_NULL;\r\n\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t}else if( iType & MEMOBJ_BOOL ){\r\n\t\tc = pValue->x.iVal ? FJSON_TRUE : FJSON_FALSE;\r\n\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t}else if( iType & MEMOBJ_STRING ){\r\n\t\tunsigned char zBuf[sizeof(sxu32)]; /* String length */\r\n\t\tc = FJSON_STRING;\r\n\t\tSyBigEndianPack32(zBuf,SyBlobLength(&pValue->sBlob));\r\n\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\tif( rc == SXRET_OK ){\r\n\t\t\trc = SyBlobAppend(pOut,(const void *)zBuf,sizeof(zBuf));\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\trc = SyBlobAppend(pOut,SyBlobData(&pValue->sBlob),SyBlobLength(&pValue->sBlob));\r\n\t\t\t}\r\n\t\t}\r\n\t}else if( iType & MEMOBJ_INT ){\r\n\t\tunsigned char zBuf[8];\r\n\t\t/* 64bit big endian integer */\r\n\t\tc = FJSON_INT64;\r\n\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\tif( rc == SXRET_OK ){\r\n\t\t\tSyBigEndianPack64(zBuf,(sxu64)pValue->x.iVal);\r\n\t\t\trc = SyBlobAppend(pOut,(const void *)zBuf,sizeof(zBuf));\r\n\t\t}\r\n\t}else if( iType & MEMOBJ_REAL ){\r\n\t\t/* Real number */\r\n\t\tc = FJSON_REAL;\r\n\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\tif( rc == SXRET_OK ){\r\n\t\t\tsxu32 iOfft = SyBlobLength(pOut);\r\n\t\t\trc = SyBlobAppendBig16(pOut,0);\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\tunsigned char *zBlob;\r\n\t\t\t\tSyBlobFormat(pOut,\"%.15g\",pValue->x.rVal);\r\n\t\t\t\tzBlob = (unsigned char *)SyBlobDataAt(pOut,iOfft);\r\n\t\t\t\tSyBigEndianPack16(zBlob,(sxu16)(SyBlobLength(pOut) - ( 2 + iOfft)));\r\n\t\t\t}\r\n\t\t}\r\n\t}else if( iType & MEMOBJ_HASHMAP ){\r\n\t\t/* A JSON object or array */\r\n\t\tjx9_hashmap *pMap = (jx9_hashmap *)pValue->x.pOther;\r\n\t\tjx9_hashmap_node *pNode;\r\n\t\tjx9_value *pEntry;\r\n\t\t/* Reset the hashmap loop cursor */\r\n\t\tjx9HashmapResetLoopCursor(pMap);\r\n\t\tif( pMap->iFlags & HASHMAP_JSON_OBJECT ){\r\n\t\t\tjx9_value sKey;\r\n\t\t\t/* A JSON object */\r\n\t\t\tc = FJSON_DOC_START; /* { */\r\n\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\tjx9MemObjInit(pMap->pVm,&sKey);\r\n\t\t\t\t/* Encode object entries */\r\n\t\t\t\twhile((pNode = jx9HashmapGetNextEntry(pMap)) != 0 ){\r\n\t\t\t\t\t/* Extract the key */\r\n\t\t\t\t\tjx9HashmapExtractNodeKey(pNode,&sKey);\r\n\t\t\t\t\t/* Encode it */\r\n\t\t\t\t\trc = FastJsonEncode(&sKey,pOut,iNest+1);\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc = FJSON_COLON;\r\n\t\t\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Extract the value */\r\n\t\t\t\t\tpEntry = jx9HashmapGetNodeValue(pNode);\r\n\t\t\t\t\t/* Encode it */\r\n\t\t\t\t\trc = FastJsonEncode(pEntry,pOut,iNest+1);\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Delimit the entry */\r\n\t\t\t\t\tc = FJSON_COMMA;\r\n\t\t\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tjx9MemObjRelease(&sKey);\r\n\t\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t\tc = FJSON_DOC_END; /* } */\r\n\t\t\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t/* A JSON array */\r\n\t\t\tc = FJSON_ARRAY_START; /* [ */\r\n\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t/* Encode array entries */\r\n\t\t\t\twhile( (pNode = jx9HashmapGetNextEntry(pMap)) != 0 ){\r\n\t\t\t\t\t/* Extract the value */\r\n\t\t\t\t\tpEntry = jx9HashmapGetNodeValue(pNode);\r\n\t\t\t\t\t/* Encode it */\r\n\t\t\t\t\trc = FastJsonEncode(pEntry,pOut,iNest+1);\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Delimit the entry */\r\n\t\t\t\t\tc = FJSON_COMMA;\r\n\t\t\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t\tc = FJSON_ARRAY_END; /* ] */\r\n\t\t\t\t\trc = SyBlobAppend(pOut,(const void *)&c,sizeof(char));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * Decode a FastJSON binary blob.\r\n */\r\nUNQLITE_PRIVATE sxi32 FastJsonDecode(\r\n\tconst void *pIn,  /* Binary JSON  */\r\n\tsxu32 nByte,      /* Chunk delimiter */\r\n\tjx9_value *pOut,  /* Decoded value */\r\n\tconst unsigned char **pzPtr,\r\n\tint iNest /* Nesting limit */\r\n\t)\r\n{\r\n\tconst unsigned char *zIn = (const unsigned char *)pIn;\r\n\tconst unsigned char *zEnd = &zIn[nByte];\r\n\tsxi32 rc = SXRET_OK;\r\n\tint c;\r\n\tif( iNest >= UNQLITE_FAST_JSON_NEST_LIMIT ){\r\n\t\t/* Nesting limit reached */\r\n\t\treturn SXERR_LIMIT;\r\n\t}\r\n\tc = zIn[0];\r\n\t/* Advance the stream cursor */\r\n\tzIn++;\r\n\t/* Process the binary token */\r\n\tswitch(c){\r\n\tcase FJSON_NULL:\r\n\t\t/* null */\r\n\t\tjx9_value_null(pOut);\r\n\t\tbreak;\r\n\tcase FJSON_FALSE:\r\n\t\t/* Boolean FALSE */\r\n\t\tjx9_value_bool(pOut,0);\r\n\t\tbreak;\r\n\tcase FJSON_TRUE:\r\n\t\t/* Boolean TRUE */\r\n\t\tjx9_value_bool(pOut,1);\r\n\t\tbreak;\r\n\tcase FJSON_INT64: {\r\n\t\t/* 64Bit integer */\r\n\t\tsxu64 iVal;\r\n\t\t/* Sanity check */\r\n\t\tif( &zIn[8] >= zEnd ){\r\n\t\t\t/* Corrupt chunk */\r\n\t\t\trc = SXERR_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tSyBigEndianUnpack64(zIn,&iVal);\r\n\t\t/* Advance the pointer */\r\n\t\tzIn += 8;\r\n\t\tjx9_value_int64(pOut,(jx9_int64)iVal);\r\n\t\tbreak;\r\n\t\t\t\t\t  }\r\n\tcase FJSON_REAL: {\r\n\t\t/* Real number */\r\n\t\tdouble iVal = 0; /* cc warning */\r\n\t\tsxu16 iLen;\r\n\t\t/* Sanity check */\r\n\t\tif( &zIn[2] >= zEnd ){\r\n\t\t\t/* Corrupt chunk */\r\n\t\t\trc = SXERR_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tSyBigEndianUnpack16(zIn,&iLen);\r\n\t\tif( &zIn[iLen] >= zEnd ){\r\n\t\t\t/* Corrupt chunk */\r\n\t\t\trc = SXERR_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzIn += 2;\r\n\t\tSyStrToReal((const char *)zIn,(sxu32)iLen,&iVal,0);\r\n\t\t/* Advance the pointer */\r\n\t\tzIn += iLen;\r\n\t\tjx9_value_double(pOut,iVal);\r\n\t\tbreak;\r\n\t\t\t\t\t }\r\n\tcase FJSON_STRING: {\r\n\t\t/* UTF-8/Binary chunk */\r\n\t\tsxu32 iLength;\r\n\t\t/* Sanity check */\r\n\t\tif( &zIn[4] >= zEnd ){\r\n\t\t\t/* Corrupt chunk */\r\n\t\t\trc = SXERR_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tSyBigEndianUnpack32(zIn,&iLength);\r\n\t\tif( &zIn[iLength] >= zEnd ){\r\n\t\t\t/* Corrupt chunk */\r\n\t\t\trc = SXERR_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzIn += 4;\r\n\t\t/* Invalidate any prior representation */\r\n\t\tif( pOut->iFlags & MEMOBJ_STRING ){\r\n\t\t\t/* Reset the string cursor */\r\n\t\t\tSyBlobReset(&pOut->sBlob);\r\n\t\t}\r\n\t\trc = jx9MemObjStringAppend(pOut,(const char *)zIn,iLength);\r\n\t\t/* Update pointer */\r\n\t\tzIn += iLength;\r\n\t\tbreak;\r\n\t\t\t\t\t   }\r\n\tcase FJSON_ARRAY_START: {\r\n\t\t/* Binary JSON array */\r\n\t\tjx9_hashmap *pMap;\r\n\t\tjx9_value sVal;\r\n\t\t/* Allocate a new hashmap */\r\n\t\tpMap = (jx9_hashmap *)jx9NewHashmap(pOut->pVm,0,0);\r\n\t\tif( pMap == 0 ){\r\n\t\t\trc = SXERR_MEM;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tjx9MemObjInit(pOut->pVm,&sVal);\r\n\t\tjx9MemObjRelease(pOut);\r\n\t\tMemObjSetType(pOut,MEMOBJ_HASHMAP);\r\n\t\tpOut->x.pOther = pMap;\r\n\t\trc = SXRET_OK;\r\n\t\tfor(;;){\r\n\t\t\t/* Jump leading binary commas */\r\n\t\t\twhile (zIn < zEnd && zIn[0] == FJSON_COMMA ){\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t\tif( zIn >= zEnd || zIn[0] == FJSON_ARRAY_END ){\r\n\t\t\t\tif( zIn < zEnd ){\r\n\t\t\t\t\tzIn++; /* Jump the trailing binary ] */\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Decode the value */\r\n\t\t\trc = FastJsonDecode((const void *)zIn,(sxu32)(zEnd-zIn),&sVal,&zIn,iNest+1);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Insert the decoded value */\r\n\t\t\trc = jx9HashmapInsert(pMap,0,&sVal);\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\tjx9MemObjRelease(pOut);\r\n\t\t}\r\n\t\tjx9MemObjRelease(&sVal);\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\tcase FJSON_DOC_START: {\r\n\t\t/* Binary JSON object */\r\n\t\tjx9_value sVal,sKey;\r\n\t\tjx9_hashmap *pMap;\r\n\t\t/* Allocate a new hashmap */\r\n\t\tpMap = (jx9_hashmap *)jx9NewHashmap(pOut->pVm,0,0);\r\n\t\tif( pMap == 0 ){\r\n\t\t\trc = SXERR_MEM;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tjx9MemObjInit(pOut->pVm,&sVal);\r\n\t\tjx9MemObjInit(pOut->pVm,&sKey);\r\n\t\tjx9MemObjRelease(pOut);\r\n\t\tMemObjSetType(pOut,MEMOBJ_HASHMAP);\r\n\t\tpOut->x.pOther = pMap;\r\n\t\trc = SXRET_OK;\r\n\t\tfor(;;){\r\n\t\t\t/* Jump leading binary commas */\r\n\t\t\twhile (zIn < zEnd && zIn[0] == FJSON_COMMA ){\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t\tif( zIn >= zEnd || zIn[0] == FJSON_DOC_END ){\r\n\t\t\t\tif( zIn < zEnd ){\r\n\t\t\t\t\tzIn++; /* Jump the trailing binary } */\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Extract the key */\r\n\t\t\trc = FastJsonDecode((const void *)zIn,(sxu32)(zEnd-zIn),&sKey,&zIn,iNest+1);\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif( zIn >= zEnd || zIn[0] != FJSON_COLON ){\r\n\t\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tzIn++; /* Jump the binary colon ':' */\r\n\t\t\tif( zIn >= zEnd ){\r\n\t\t\t\trc = UNQLITE_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Decode the value */\r\n\t\t\trc = FastJsonDecode((const void *)zIn,(sxu32)(zEnd-zIn),&sVal,&zIn,iNest+1);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Insert the key and its associated value */\r\n\t\t\trc = jx9HashmapInsert(pMap,&sKey,&sVal);\r\n\t\t\tif( rc != UNQLITE_OK ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\tjx9MemObjRelease(pOut);\r\n\t\t}\r\n\t\tjx9MemObjRelease(&sVal);\r\n\t\tjx9MemObjRelease(&sKey);\r\n\t\tbreak;\r\n\t\t\t\t\t\t  }\r\n\tdefault:\r\n\t\t/* Corrupt data */\r\n\t\trc = SXERR_CORRUPT;\r\n\t\tbreak;\r\n\t}\r\n\tif( pzPtr ){\r\n\t\t*pzPtr = zIn;\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * ----------------------------------------------------------\r\n * File: jx9_api.c\r\n * MD5: 73cba599c009cee0ff878666d0543438\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.\r\n * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/\r\n * Version 1.7.2\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://jx9.symisc.net/\r\n */\r\n /* $SymiscID: api.c v1.7 FreeBSD 2012-12-18 06:54 stable <chm@symisc.net> $ */\r\n#ifndef JX9_AMALGAMATION\r\n#include \"jx9Int.h\"\r\n#endif\r\n/* This file implement the public interfaces presented to host-applications.\r\n * Routines in other files are for internal use by JX9 and should not be\r\n * accessed by users of the library.\r\n */\r\n#define JX9_ENGINE_MAGIC 0xF874BCD7\r\n#define JX9_ENGINE_MISUSE(ENGINE) (ENGINE == 0 || ENGINE->nMagic != JX9_ENGINE_MAGIC)\r\n#define JX9_VM_MISUSE(VM) (VM == 0 || VM->nMagic == JX9_VM_STALE)\r\n/* If another thread have released a working instance, the following macros\r\n * evaluates to true. These macros are only used when the library\r\n * is built with threading support enabled which is not the case in\r\n * the default built.\r\n */\r\n#define JX9_THRD_ENGINE_RELEASE(ENGINE) (ENGINE->nMagic != JX9_ENGINE_MAGIC)\r\n#define JX9_THRD_VM_RELEASE(VM) (VM->nMagic == JX9_VM_STALE)\r\n/* IMPLEMENTATION: jx9@embedded@symisc 311-12-32 */\r\n/*\r\n * All global variables are collected in the structure named \"sJx9MPGlobal\".\r\n * That way it is clear in the code when we are using static variable because\r\n * its name start with sJx9MPGlobal.\r\n */\r\nstatic struct Jx9Global_Data\r\n{\r\n\tSyMemBackend sAllocator;                /* Global low level memory allocator */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tconst SyMutexMethods *pMutexMethods;   /* Mutex methods */\r\n\tSyMutex *pMutex;                       /* Global mutex */\r\n\tsxu32 nThreadingLevel;                 /* Threading level: 0 == Single threaded/1 == Multi-Threaded \r\n\t\t\t\t\t\t\t\t\t\t    * The threading level can be set using the [jx9_lib_config()]\r\n\t\t\t\t\t\t\t\t\t\t\t* interface with a configuration verb set to\r\n\t\t\t\t\t\t\t\t\t\t\t* JX9_LIB_CONFIG_THREAD_LEVEL_SINGLE or \r\n\t\t\t\t\t\t\t\t\t\t\t* JX9_LIB_CONFIG_THREAD_LEVEL_MULTI\r\n\t\t\t\t\t\t\t\t\t\t\t*/\r\n#endif\r\n\tconst jx9_vfs *pVfs;                    /* Underlying virtual file system */\r\n\tsxi32 nEngine;                          /* Total number of active engines */\r\n\tjx9 *pEngines;                          /* List of active engine */\r\n\tsxu32 nMagic;                           /* Sanity check against library misuse */\r\n}sJx9MPGlobal = {\r\n\t{0, 0, 0, 0, 0, 0, 0, 0, {0}}, \r\n#if defined(JX9_ENABLE_THREADS)\r\n\t0, \r\n\t0, \r\n\t0, \r\n#endif\r\n\t0, \r\n\t0, \r\n\t0, \r\n\t0\r\n};\r\n#define JX9_LIB_MAGIC  0xEA1495BA\r\n#define JX9_LIB_MISUSE (sJx9MPGlobal.nMagic != JX9_LIB_MAGIC)\r\n/*\r\n * Supported threading level.\r\n * These options have meaning only when the library is compiled with multi-threading\r\n * support.That is, the JX9_ENABLE_THREADS compile time directive must be defined\r\n * when JX9 is built.\r\n * JX9_THREAD_LEVEL_SINGLE:\r\n * In this mode, mutexing is disabled and the library can only be used by a single thread.\r\n * JX9_THREAD_LEVEL_MULTI\r\n * In this mode, all mutexes including the recursive mutexes on [jx9] objects\r\n * are enabled so that the application is free to share the same engine\r\n * between different threads at the same time.\r\n */\r\n#define JX9_THREAD_LEVEL_SINGLE 1 \r\n#define JX9_THREAD_LEVEL_MULTI  2\r\n/*\r\n * Configure a running JX9 engine instance.\r\n * return JX9_OK on success.Any other return\r\n * value indicates failure.\r\n * Refer to [jx9_config()].\r\n */\r\nJX9_PRIVATE sxi32 jx9EngineConfig(jx9 *pEngine, sxi32 nOp, va_list ap)\r\n{\r\n\tjx9_conf *pConf = &pEngine->xConf;\r\n\tint rc = JX9_OK;\r\n\t/* Perform the requested operation */\r\n\tswitch(nOp){\t\t\t\t\t\t\t\t\t \r\n\tcase JX9_CONFIG_ERR_LOG:{\r\n\t\t/* Extract compile-time error log if any */\r\n\t\tconst char **pzPtr = va_arg(ap, const char **);\r\n\t\tint *pLen = va_arg(ap, int *);\r\n\t\tif( pzPtr == 0 ){\r\n\t\t\trc = JX9_CORRUPT;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* NULL terminate the error-log buffer */\r\n\t\tSyBlobNullAppend(&pConf->sErrConsumer);\r\n\t\t/* Point to the error-log buffer */\r\n\t\t*pzPtr = (const char *)SyBlobData(&pConf->sErrConsumer);\r\n\t\tif( pLen ){\r\n\t\t\tif( SyBlobLength(&pConf->sErrConsumer) > 1 /* NULL '\\0' terminator */ ){\r\n\t\t\t\t*pLen = (int)SyBlobLength(&pConf->sErrConsumer);\r\n\t\t\t}else{\r\n\t\t\t\t*pLen = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\tcase JX9_CONFIG_ERR_ABORT:\r\n\t\t/* Reserved for future use */\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t/* Unknown configuration verb */\r\n\t\trc = JX9_CORRUPT;\r\n\t\tbreak;\r\n\t} /* Switch() */\r\n\treturn rc;\r\n}\r\n/*\r\n * Configure the JX9 library.\r\n * Return JX9_OK on success. Any other return value indicates failure.\r\n * Refer to [jx9_lib_config()].\r\n */\r\nstatic sxi32 Jx9CoreConfigure(sxi32 nOp, va_list ap)\r\n{\r\n\tint rc = JX9_OK;\r\n\tswitch(nOp){\r\n\t    case JX9_LIB_CONFIG_VFS:{\r\n\t\t\t/* Install a virtual file system */\r\n\t\t\tconst jx9_vfs *pVfs = va_arg(ap, const jx9_vfs *);\r\n\t\t\tsJx9MPGlobal.pVfs = pVfs;\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\tcase JX9_LIB_CONFIG_USER_MALLOC: {\r\n\t\t\t/* Use an alternative low-level memory allocation routines */\r\n\t\t\tconst SyMemMethods *pMethods = va_arg(ap, const SyMemMethods *);\r\n\t\t\t/* Save the memory failure callback (if available) */\r\n\t\t\tProcMemError xMemErr = sJx9MPGlobal.sAllocator.xMemError;\r\n\t\t\tvoid *pMemErr = sJx9MPGlobal.sAllocator.pUserData;\r\n\t\t\tif( pMethods == 0 ){\r\n\t\t\t\t/* Use the built-in memory allocation subsystem */\r\n\t\t\t\trc = SyMemBackendInit(&sJx9MPGlobal.sAllocator, xMemErr, pMemErr);\r\n\t\t\t}else{\r\n\t\t\t\trc = SyMemBackendInitFromOthers(&sJx9MPGlobal.sAllocator, pMethods, xMemErr, pMemErr);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t  }\r\n\t\tcase JX9_LIB_CONFIG_MEM_ERR_CALLBACK: {\r\n\t\t\t/* Memory failure callback */\r\n\t\t\tProcMemError xMemErr = va_arg(ap, ProcMemError);\r\n\t\t\tvoid *pUserData = va_arg(ap, void *);\r\n\t\t\tsJx9MPGlobal.sAllocator.xMemError = xMemErr;\r\n\t\t\tsJx9MPGlobal.sAllocator.pUserData = pUserData;\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t }\t  \r\n\t\tcase JX9_LIB_CONFIG_USER_MUTEX: {\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\t\t/* Use an alternative low-level mutex subsystem */\r\n\t\t\tconst SyMutexMethods *pMethods = va_arg(ap, const SyMutexMethods *);\r\n#if defined (UNTRUST)\r\n\t\t\tif( pMethods == 0 ){\r\n\t\t\t\trc = JX9_CORRUPT;\r\n\t\t\t}\r\n#endif\r\n\t\t\t/* Sanity check */\r\n\t\t\tif( pMethods->xEnter == 0 || pMethods->xLeave == 0 || pMethods->xNew == 0){\r\n\t\t\t\t/* At least three criticial callbacks xEnter(), xLeave() and xNew() must be supplied */\r\n\t\t\t\trc = JX9_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif( sJx9MPGlobal.pMutexMethods ){\r\n\t\t\t\t/* Overwrite the previous mutex subsystem */\r\n\t\t\t\tSyMutexRelease(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex);\r\n\t\t\t\tif( sJx9MPGlobal.pMutexMethods->xGlobalRelease ){\r\n\t\t\t\t\tsJx9MPGlobal.pMutexMethods->xGlobalRelease();\r\n\t\t\t\t}\r\n\t\t\t\tsJx9MPGlobal.pMutex = 0;\r\n\t\t\t}\r\n\t\t\t/* Initialize and install the new mutex subsystem */\r\n\t\t\tif( pMethods->xGlobalInit ){\r\n\t\t\t\trc = pMethods->xGlobalInit();\r\n\t\t\t\tif ( rc != JX9_OK ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* Create the global mutex */\r\n\t\t\tsJx9MPGlobal.pMutex = pMethods->xNew(SXMUTEX_TYPE_FAST);\r\n\t\t\tif( sJx9MPGlobal.pMutex == 0 ){\r\n\t\t\t\t/*\r\n\t\t\t\t * If the supplied mutex subsystem is so sick that we are unable to\r\n\t\t\t\t * create a single mutex, there is no much we can do here.\r\n\t\t\t\t */\r\n\t\t\t\tif( pMethods->xGlobalRelease ){\r\n\t\t\t\t\tpMethods->xGlobalRelease();\r\n\t\t\t\t}\r\n\t\t\t\trc = JX9_CORRUPT;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tsJx9MPGlobal.pMutexMethods = pMethods;\t\t\t\r\n\t\t\tif( sJx9MPGlobal.nThreadingLevel == 0 ){\r\n\t\t\t\t/* Set a default threading level */\r\n\t\t\t\tsJx9MPGlobal.nThreadingLevel = JX9_THREAD_LEVEL_MULTI; \r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t   }\r\n\t\tcase JX9_LIB_CONFIG_THREAD_LEVEL_SINGLE:\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\t\t/* Single thread mode(Only one thread is allowed to play with the library) */\r\n\t\t\tsJx9MPGlobal.nThreadingLevel = JX9_THREAD_LEVEL_SINGLE;\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase JX9_LIB_CONFIG_THREAD_LEVEL_MULTI:\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\t\t/* Multi-threading mode (library is thread safe and JX9 engines and virtual machines\r\n\t\t\t * may be shared between multiple threads).\r\n\t\t\t */\r\n\t\t\tsJx9MPGlobal.nThreadingLevel = JX9_THREAD_LEVEL_MULTI;\r\n#endif\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t/* Unknown configuration option */\r\n\t\t\trc = JX9_CORRUPT;\r\n\t\t\tbreak;\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_lib_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_lib_config(int nConfigOp, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( sJx9MPGlobal.nMagic == JX9_LIB_MAGIC ){\r\n\t\t/* Library is already initialized, this operation is forbidden */\r\n\t\treturn JX9_LOOKED;\r\n\t}\r\n\tva_start(ap, nConfigOp);\r\n\trc = Jx9CoreConfigure(nConfigOp, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * Global library initialization\r\n * Refer to [jx9_lib_init()]\r\n * This routine must be called to initialize the memory allocation subsystem, the mutex \r\n * subsystem prior to doing any serious work with the library.The first thread to call\r\n * this routine does the initialization process and set the magic number so no body later\r\n * can re-initialize the library.If subsequent threads call this  routine before the first\r\n * thread have finished the initialization process, then the subsequent threads must block \r\n * until the initialization process is done.\r\n */\r\nstatic sxi32 Jx9CoreInitialize(void)\r\n{\r\n\tconst jx9_vfs *pVfs; /* Built-in vfs */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tconst SyMutexMethods *pMutexMethods = 0;\r\n\tSyMutex *pMaster = 0;\r\n#endif\r\n\tint rc;\r\n\t/*\r\n\t * If the library is already initialized, then a call to this routine\r\n\t * is a no-op.\r\n\t */\r\n\tif( sJx9MPGlobal.nMagic == JX9_LIB_MAGIC ){\r\n\t\treturn JX9_OK; /* Already initialized */\r\n\t}\r\n\tif( sJx9MPGlobal.pVfs == 0 ){\r\n\t\t/* Point to the built-in vfs */\r\n\t\tpVfs = jx9ExportBuiltinVfs();\r\n\t\t/* Install it */\r\n\t\tjx9_lib_config(JX9_LIB_CONFIG_VFS, pVfs);\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tif( sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_SINGLE ){\r\n\t\tpMutexMethods = sJx9MPGlobal.pMutexMethods;\r\n\t\tif( pMutexMethods == 0 ){\r\n\t\t\t/* Use the built-in mutex subsystem */\r\n\t\t\tpMutexMethods = SyMutexExportMethods();\r\n\t\t\tif( pMutexMethods == 0 ){\r\n\t\t\t\treturn JX9_CORRUPT; /* Can't happen */\r\n\t\t\t}\r\n\t\t\t/* Install the mutex subsystem */\r\n\t\t\trc = jx9_lib_config(JX9_LIB_CONFIG_USER_MUTEX, pMutexMethods);\r\n\t\t\tif( rc != JX9_OK ){\r\n\t\t\t\treturn rc;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Obtain a static mutex so we can initialize the library without calling malloc() */\r\n\t\tpMaster = SyMutexNew(pMutexMethods, SXMUTEX_TYPE_STATIC_1);\r\n\t\tif( pMaster == 0 ){\r\n\t\t\treturn JX9_CORRUPT; /* Can't happen */\r\n\t\t}\r\n\t}\r\n\t/* Lock the master mutex */\r\n\trc = JX9_OK;\r\n\tSyMutexEnter(pMutexMethods, pMaster); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n\tif( sJx9MPGlobal.nMagic != JX9_LIB_MAGIC ){\r\n#endif\r\n\t\tif( sJx9MPGlobal.sAllocator.pMethods == 0 ){\r\n\t\t\t/* Install a memory subsystem */\r\n\t\t\trc = jx9_lib_config(JX9_LIB_CONFIG_USER_MALLOC, 0); /* zero mean use the built-in memory backend */\r\n\t\t\tif( rc != JX9_OK ){\r\n\t\t\t\t/* If we are unable to initialize the memory backend, there is no much we can do here.*/\r\n\t\t\t\tgoto End;\r\n\t\t\t}\r\n\t\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\tif( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE ){\r\n\t\t\t/* Protect the memory allocation subsystem */\r\n\t\t\trc = SyMemBackendMakeThreadSafe(&sJx9MPGlobal.sAllocator, sJx9MPGlobal.pMutexMethods);\r\n\t\t\tif( rc != JX9_OK ){\r\n\t\t\t\tgoto End;\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n\t\t/* Our library is initialized, set the magic number */\r\n\t\tsJx9MPGlobal.nMagic = JX9_LIB_MAGIC;\r\n\t\trc = JX9_OK;\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t} /* sJx9MPGlobal.nMagic != JX9_LIB_MAGIC */\r\n#endif\r\nEnd:\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Unlock the master mutex */\r\n\tSyMutexLeave(pMutexMethods, pMaster); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * Release an active JX9 engine and it's associated active virtual machines.\r\n */\r\nstatic sxi32 EngineRelease(jx9 *pEngine)\r\n{\r\n\tjx9_vm *pVm, *pNext;\r\n\t/* Release all active VM */\r\n\tpVm = pEngine->pVms;\r\n\tfor(;;){\r\n\t\tif( pEngine->iVm < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pVm->pNext;\r\n\t\tjx9VmRelease(pVm);\r\n\t\tpVm = pNext;\r\n\t\tpEngine->iVm--;\r\n\t}\r\n\t/* Set a dummy magic number */\r\n\tpEngine->nMagic = 0x7635;\r\n\t/* Release the private memory subsystem */\r\n\tSyMemBackendRelease(&pEngine->sAllocator); \r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Release all resources consumed by the library.\r\n * If JX9 is already shut when this routine is invoked then this\r\n * routine is a harmless no-op.\r\n * Note: This call is not thread safe. Refer to [jx9_lib_shutdown()].\r\n */\r\nstatic void JX9CoreShutdown(void)\r\n{\r\n\tjx9 *pEngine, *pNext;\r\n\t/* Release all active engines first */\r\n\tpEngine = sJx9MPGlobal.pEngines;\r\n\tfor(;;){\r\n\t\tif( sJx9MPGlobal.nEngine < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpNext = pEngine->pNext;\r\n\t\tEngineRelease(pEngine); \r\n\t\tpEngine = pNext;\r\n\t\tsJx9MPGlobal.nEngine--;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Release the mutex subsystem */\r\n\tif( sJx9MPGlobal.pMutexMethods ){\r\n\t\tif( sJx9MPGlobal.pMutex ){\r\n\t\t\tSyMutexRelease(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex);\r\n\t\t\tsJx9MPGlobal.pMutex = 0;\r\n\t\t}\r\n\t\tif( sJx9MPGlobal.pMutexMethods->xGlobalRelease ){\r\n\t\t\tsJx9MPGlobal.pMutexMethods->xGlobalRelease();\r\n\t\t}\r\n\t\tsJx9MPGlobal.pMutexMethods = 0;\r\n\t}\r\n\tsJx9MPGlobal.nThreadingLevel = 0;\r\n#endif\r\n\tif( sJx9MPGlobal.sAllocator.pMethods ){\r\n\t\t/* Release the memory backend */\r\n\t\tSyMemBackendRelease(&sJx9MPGlobal.sAllocator);\r\n\t}\r\n\tsJx9MPGlobal.nMagic = 0x1928;\t\r\n}\r\n/*\r\n * [CAPIREF: jx9_lib_shutdown()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_lib_shutdown(void)\r\n{\r\n\tif( sJx9MPGlobal.nMagic != JX9_LIB_MAGIC ){\r\n\t\t/* Already shut */\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tJX9CoreShutdown();\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_lib_signature()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE const char * jx9_lib_signature(void)\r\n{\r\n\treturn JX9_SIG;\r\n}\r\n/*\r\n * [CAPIREF: jx9_init()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_init(jx9 **ppEngine)\r\n{\r\n\tjx9 *pEngine;\r\n\tint rc;\r\n#if defined(UNTRUST)\r\n\tif( ppEngine == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#endif\r\n\t*ppEngine = 0;\r\n\t/* One-time automatic library initialization */\r\n\trc = Jx9CoreInitialize();\r\n\tif( rc != JX9_OK ){\r\n\t\treturn rc;\r\n\t}\r\n\t/* Allocate a new engine */\r\n\tpEngine = (jx9 *)SyMemBackendPoolAlloc(&sJx9MPGlobal.sAllocator, sizeof(jx9));\r\n\tif( pEngine == 0 ){\r\n\t\treturn JX9_NOMEM;\r\n\t}\r\n\t/* Zero the structure */\r\n\tSyZero(pEngine, sizeof(jx9));\r\n\t/* Initialize engine fields */\r\n\tpEngine->nMagic = JX9_ENGINE_MAGIC;\r\n\trc = SyMemBackendInitFromParent(&pEngine->sAllocator, &sJx9MPGlobal.sAllocator);\r\n\tif( rc != JX9_OK ){\r\n\t\tgoto Release;\r\n\t}\r\n//#if defined(JX9_ENABLE_THREADS)\r\n//\tSyMemBackendDisbaleMutexing(&pEngine->sAllocator);\r\n//#endif\r\n\t/* Default configuration */\r\n\tSyBlobInit(&pEngine->xConf.sErrConsumer, &pEngine->sAllocator);\r\n\t/* Install a default compile-time error consumer routine */\r\n\tpEngine->xConf.xErr = jx9VmBlobConsumer;\r\n\tpEngine->xConf.pErrData = &pEngine->xConf.sErrConsumer;\r\n\t/* Built-in vfs */\r\n\tpEngine->pVfs = sJx9MPGlobal.pVfs;\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tif( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE ){\r\n\t\t /* Associate a recursive mutex with this instance */\r\n\t\t pEngine->pMutex = SyMutexNew(sJx9MPGlobal.pMutexMethods, SXMUTEX_TYPE_RECURSIVE);\r\n\t\t if( pEngine->pMutex == 0 ){\r\n\t\t\t rc = JX9_NOMEM;\r\n\t\t\t goto Release;\r\n\t\t }\r\n\t }\r\n#endif\r\n\t/* Link to the list of active engines */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Enter the global mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\tMACRO_LD_PUSH(sJx9MPGlobal.pEngines, pEngine);\r\n\tsJx9MPGlobal.nEngine++;\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Leave the global mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Write a pointer to the new instance */\r\n\t*ppEngine = pEngine;\r\n\treturn JX9_OK;\r\nRelease:\r\n\tSyMemBackendRelease(&pEngine->sAllocator);\r\n\tSyMemBackendPoolFree(&sJx9MPGlobal.sAllocator,pEngine);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_release(jx9 *pEngine)\r\n{\r\n\tint rc;\r\n\tif( JX9_ENGINE_MISUSE(pEngine) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire engine mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_ENGINE_RELEASE(pEngine) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Release the engine */\r\n\trc = EngineRelease(&(*pEngine));\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave engine mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t /* Release engine mutex */\r\n\t SyMutexRelease(sJx9MPGlobal.pMutexMethods, pEngine->pMutex) /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Enter the global mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Unlink from the list of active engines */\r\n\tMACRO_LD_REMOVE(sJx9MPGlobal.pEngines, pEngine);\r\n\tsJx9MPGlobal.nEngine--;\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t/* Leave the global mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, sJx9MPGlobal.pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel == JX9_THREAD_LEVEL_SINGLE */\r\n#endif\r\n\t/* Release the memory chunk allocated to this engine */\r\n\tSyMemBackendPoolFree(&sJx9MPGlobal.sAllocator, pEngine);\r\n\treturn rc;\r\n}\r\n/*\r\n * Compile a raw JX9 script.\r\n * To execute a JX9 code, it must first be compiled into a bytecode program using this routine.\r\n * If something goes wrong [i.e: compile-time error], your error log [i.e: error consumer callback]\r\n * should  display the appropriate error message and this function set ppVm to null and return\r\n * an error code that is different from JX9_OK. Otherwise when the script is successfully compiled\r\n * ppVm should hold the JX9 bytecode and it's safe to call [jx9_vm_exec(), jx9_vm_reset(), etc.].\r\n * This API does not actually evaluate the JX9 code. It merely compile and prepares the JX9 script\r\n * for evaluation.\r\n */\r\nstatic sxi32 ProcessScript(\r\n\tjx9 *pEngine,          /* Running JX9 engine */\r\n\tjx9_vm **ppVm,         /* OUT: A pointer to the virtual machine */\r\n\tSyString *pScript,     /* Raw JX9 script to compile */\r\n\tsxi32 iFlags,          /* Compile-time flags */\r\n\tconst char *zFilePath  /* File path if script come from a file. NULL otherwise */\r\n\t)\r\n{\r\n\tjx9_vm *pVm;\r\n\tint rc;\r\n\t/* Allocate a new virtual machine */\r\n\tpVm = (jx9_vm *)SyMemBackendPoolAlloc(&pEngine->sAllocator, sizeof(jx9_vm));\r\n\tif( pVm == 0 ){\r\n\t\t/* If the supplied memory subsystem is so sick that we are unable to allocate\r\n\t\t * a tiny chunk of memory, there is no much we can do here. */\r\n\t\tif( ppVm ){\r\n\t\t\t*ppVm = 0;\r\n\t\t}\r\n\t\treturn JX9_NOMEM;\r\n\t}\r\n\tif( iFlags < 0 ){\r\n\t\t/* Default compile-time flags */\r\n\t\tiFlags = 0;\r\n\t}\r\n\t/* Initialize the Virtual Machine */\r\n\trc = jx9VmInit(pVm, &(*pEngine));\r\n\tif( rc != JX9_OK ){\r\n\t\tSyMemBackendPoolFree(&pEngine->sAllocator, pVm);\r\n\t\tif( ppVm ){\r\n\t\t\t*ppVm = 0;\r\n\t\t}\r\n\t\treturn JX9_VM_ERR;\r\n\t}\r\n\tif( zFilePath ){\r\n\t\t/* Push processed file path */\r\n\t\tjx9VmPushFilePath(pVm, zFilePath, -1, TRUE, 0);\r\n\t}\r\n\t/* Reset the error message consumer */\r\n\tSyBlobReset(&pEngine->xConf.sErrConsumer);\r\n\t/* Compile the script */\r\n\tjx9CompileScript(pVm, &(*pScript), iFlags);\r\n\tif( pVm->sCodeGen.nErr > 0 || pVm == 0){\r\n\t\tsxu32 nErr = pVm->sCodeGen.nErr;\r\n\t\t/* Compilation error or null ppVm pointer, release this VM */\r\n\t\tSyMemBackendRelease(&pVm->sAllocator);\r\n\t\tSyMemBackendPoolFree(&pEngine->sAllocator, pVm);\r\n\t\tif( ppVm ){\r\n\t\t\t*ppVm = 0;\r\n\t\t}\r\n\t\treturn nErr > 0 ? JX9_COMPILE_ERR : JX9_OK;\r\n\t}\r\n\t/* Prepare the virtual machine for bytecode execution */\r\n\trc = jx9VmMakeReady(pVm);\r\n\tif( rc != JX9_OK ){\r\n\t\tgoto Release;\r\n\t}\r\n\t/* Install local import path which is the current directory */\r\n\tjx9_vm_config(pVm, JX9_VM_CONFIG_IMPORT_PATH, \"./\");\r\n#if defined(JX9_ENABLE_THREADS)\r\n\tif( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE ){\r\n\t\t /* Associate a recursive mutex with this instance */\r\n\t\t pVm->pMutex = SyMutexNew(sJx9MPGlobal.pMutexMethods, SXMUTEX_TYPE_RECURSIVE);\r\n\t\t if( pVm->pMutex == 0 ){\r\n\t\t\t goto Release;\r\n\t\t }\r\n\t }\r\n#endif\r\n\t/* Script successfully compiled, link to the list of active virtual machines */\r\n\tMACRO_LD_PUSH(pEngine->pVms, pVm);\r\n\tpEngine->iVm++;\r\n\t/* Point to the freshly created VM */\r\n\t*ppVm = pVm;\r\n\t/* Ready to execute JX9 bytecode */\r\n\treturn JX9_OK;\r\nRelease:\r\n\tSyMemBackendRelease(&pVm->sAllocator);\r\n\tSyMemBackendPoolFree(&pEngine->sAllocator, pVm);\r\n\t*ppVm = 0;\r\n\treturn JX9_VM_ERR;\r\n}\r\n/*\r\n * [CAPIREF: jx9_compile()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_compile(jx9 *pEngine, const char *zSource, int nLen, jx9_vm **ppOutVm)\r\n{\r\n\tSyString sScript;\r\n\tint rc;\r\n\tif( JX9_ENGINE_MISUSE(pEngine) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\tif( zSource == 0 ){\r\n\t\t/* Empty Jx9 statement ';' */\r\n\t\tzSource = \";\";\r\n\t\tnLen = (int)sizeof(char);\r\n\t}\r\n\tif( nLen < 0 ){\r\n\t\t/* Compute input length automatically */\r\n\t\tnLen = (int)SyStrlen(zSource);\r\n\t}\r\n\tSyStringInitFromBuf(&sScript, zSource, nLen);\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire engine mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_ENGINE_RELEASE(pEngine) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Compile the script */\r\n\trc = ProcessScript(&(*pEngine),ppOutVm,&sScript,0,0);\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave engine mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t/* Compilation result */\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_compile_file()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_compile_file(jx9 *pEngine, const char *zFilePath, jx9_vm **ppOutVm)\r\n{\r\n\tconst jx9_vfs *pVfs;\r\n\tint rc;\r\n\tif( ppOutVm ){\r\n\t\t*ppOutVm = 0;\r\n\t}\r\n\trc = JX9_OK; /* cc warning */\r\n\tif( JX9_ENGINE_MISUSE(pEngine) || SX_EMPTY_STR(zFilePath) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire engine mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_ENGINE_RELEASE(pEngine) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t /*\r\n\t  * Check if the underlying vfs implement the memory map\r\n\t  * [i.e: mmap() under UNIX/MapViewOfFile() under windows] function.\r\n\t  */\r\n\t pVfs = pEngine->pVfs;\r\n\t if( pVfs == 0 || pVfs->xMmap == 0 ){\r\n\t\t /* Memory map routine not implemented */\r\n\t\t rc = JX9_IO_ERR;\r\n\t }else{\r\n\t\t void *pMapView = 0; /* cc warning */\r\n\t\t jx9_int64 nSize = 0; /* cc warning */\r\n\t\t SyString sScript;\r\n\t\t /* Try to get a memory view of the whole file */\r\n\t\t rc = pVfs->xMmap(zFilePath, &pMapView, &nSize);\r\n\t\t if( rc != JX9_OK ){\r\n\t\t\t /* Assume an IO error */\r\n\t\t\t rc = JX9_IO_ERR;\r\n\t\t }else{\r\n\t\t\t /* Compile the file */\r\n\t\t\t SyStringInitFromBuf(&sScript, pMapView, nSize);\r\n\t\t\t rc = ProcessScript(&(*pEngine), ppOutVm, &sScript,0,zFilePath);\r\n\t\t\t /* Release the memory view of the whole file */\r\n\t\t\t if( pVfs->xUnmap ){\r\n\t\t\t\t pVfs->xUnmap(pMapView, nSize);\r\n\t\t\t }\r\n\t\t }\r\n\t }\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave engine mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t/* Compilation result */\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_vm_config()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_vm_config(jx9_vm *pVm, int iConfigOp, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Confiugure the virtual machine */\r\n\tva_start(ap, iConfigOp);\r\n\trc = jx9VmConfigure(&(*pVm), iConfigOp, ap);\r\n\tva_end(ap);\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave VM mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_vm_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_vm_release(jx9_vm *pVm)\r\n{\r\n\tjx9 *pEngine;\r\n\tint rc;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\tpEngine = pVm->pEngine;\r\n\trc = jx9VmRelease(&(*pVm));\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave VM mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t /* Release VM mutex */\r\n\t SyMutexRelease(sJx9MPGlobal.pMutexMethods, pVm->pMutex) /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\tif( rc == JX9_OK ){\r\n\t\t/* Unlink from the list of active VM */\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\t\t/* Acquire engine mutex */\r\n\t\t\tSyMutexEnter(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t\t\tif( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t\t\tJX9_THRD_ENGINE_RELEASE(pEngine) ){\r\n\t\t\t\t\treturn JX9_ABORT; /* Another thread have released this instance */\r\n\t\t\t}\r\n#endif\r\n\t\tMACRO_LD_REMOVE(pEngine->pVms, pVm);\r\n\t\tpEngine->iVm--;\r\n\t\t/* Release the memory chunk allocated to this VM */\r\n\t\tSyMemBackendPoolFree(&pEngine->sAllocator, pVm);\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t\t\t/* Leave engine mutex */\r\n\t\t\tSyMutexLeave(sJx9MPGlobal.pMutexMethods, pEngine->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\t\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_create_function()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_create_function(jx9_vm *pVm, const char *zName, int (*xFunc)(jx9_context *, int, jx9_value **), void *pUserData)\r\n{\r\n\tSyString sName;\r\n\tint rc;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\tSyStringInitFromBuf(&sName, zName, SyStrlen(zName));\r\n\t/* Remove leading and trailing white spaces */\r\n\tSyStringFullTrim(&sName);\r\n\t/* Ticket 1433-003: NULL values are not allowed */\r\n\tif( sName.nByte < 1 || xFunc == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Install the foreign function */\r\n\trc = jx9VmInstallForeignFunction(&(*pVm), &sName, xFunc, pUserData); \r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave VM mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\treturn rc;\r\n}\r\nJX9_PRIVATE int jx9DeleteFunction(jx9_vm *pVm,const char *zName)\r\n{\r\n\tjx9_user_func *pFunc = 0; /* cc warning */\r\n\tint rc;\r\n\t/* Perform the deletion */\r\n\trc = SyHashDeleteEntry(&pVm->hHostFunction, (const void *)zName, SyStrlen(zName), (void **)&pFunc);\r\n\tif( rc == JX9_OK ){\r\n\t\t/* Release internal fields */\r\n\t\tSySetRelease(&pFunc->aAux);\r\n\t\tSyMemBackendFree(&pVm->sAllocator, (void *)SyStringData(&pFunc->sName));\r\n\t\tSyMemBackendPoolFree(&pVm->sAllocator, pFunc);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_create_constant()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_create_constant(jx9_vm *pVm, const char *zName, void (*xExpand)(jx9_value *, void *), void *pUserData)\r\n{\r\n\tSyString sName;\r\n\tint rc;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\tSyStringInitFromBuf(&sName, zName, SyStrlen(zName));\r\n\t/* Remove leading and trailing white spaces */\r\n\tSyStringFullTrim(&sName);\r\n\tif( sName.nByte < 1 ){\r\n\t\t/* Empty constant name */\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\t/* TICKET 1433-003: NULL pointer is harmless operation */\r\n\tif( xExpand == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Acquire VM mutex */\r\n\t SyMutexEnter(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n\t if( sJx9MPGlobal.nThreadingLevel > JX9_THREAD_LEVEL_SINGLE && \r\n\t\t JX9_THRD_VM_RELEASE(pVm) ){\r\n\t\t\t return JX9_ABORT; /* Another thread have released this instance */\r\n\t }\r\n#endif\r\n\t/* Perform the registration */\r\n\trc = jx9VmRegisterConstant(&(*pVm), &sName, xExpand, pUserData);\r\n#if defined(JX9_ENABLE_THREADS)\r\n\t /* Leave VM mutex */\r\n\t SyMutexLeave(sJx9MPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sJx9MPGlobal.nThreadingLevel != JX9_THREAD_LEVEL_MULTI */\r\n#endif\r\n\t return rc;\r\n}\r\nJX9_PRIVATE int Jx9DeleteConstant(jx9_vm *pVm,const char *zName)\r\n{\r\n\tjx9_constant *pCons;\r\n\tint rc;\r\n\t/* Query the constant hashtable */\r\n\t rc = SyHashDeleteEntry(&pVm->hConstant, (const void *)zName, SyStrlen(zName), (void **)&pCons);\r\n\t if( rc == JX9_OK ){\r\n\t\t /* Perform the deletion */\r\n\t\t SyMemBackendFree(&pVm->sAllocator, (void *)SyStringData(&pCons->sName));\r\n\t\t SyMemBackendPoolFree(&pVm->sAllocator, pCons);\r\n\t }\r\n\t return rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_new_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_value * jx9_new_scalar(jx9_vm *pVm)\r\n{\r\n\tjx9_value *pObj;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn 0;\r\n\t}\r\n\t/* Allocate a new scalar variable */\r\n\tpObj = (jx9_value *)SyMemBackendPoolAlloc(&pVm->sAllocator, sizeof(jx9_value));\r\n\tif( pObj == 0 ){\r\n\t\treturn 0;\r\n\t}\r\n\t/* Nullify the new scalar */\r\n\tjx9MemObjInit(pVm, pObj);\r\n\treturn pObj;\r\n}\r\n/*\r\n * [CAPIREF: jx9_new_array()] \r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_value * jx9_new_array(jx9_vm *pVm)\r\n{\r\n\tjx9_hashmap *pMap;\r\n\tjx9_value *pObj;\r\n\t/* Ticket 1433-002: NULL VM is harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn 0;\r\n\t}\r\n\t/* Create a new hashmap first */\r\n\tpMap = jx9NewHashmap(&(*pVm), 0, 0);\r\n\tif( pMap == 0 ){\r\n\t\treturn 0;\r\n\t}\r\n\t/* Associate a new jx9_value with this hashmap */\r\n\tpObj = (jx9_value *)SyMemBackendPoolAlloc(&pVm->sAllocator, sizeof(jx9_value));\r\n\tif( pObj == 0 ){\r\n\t\tjx9HashmapRelease(pMap, TRUE);\r\n\t\treturn 0;\r\n\t}\r\n\tjx9MemObjInitFromArray(pVm, pObj, pMap);\r\n\treturn pObj;\r\n}\r\n/*\r\n * [CAPIREF: jx9_release_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_release_value(jx9_vm *pVm, jx9_value *pValue)\r\n{\r\n\t/* Ticket 1433-002: NULL VM is a harmless operation */\r\n\tif ( JX9_VM_MISUSE(pVm) ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\tif( pValue ){\r\n\t\t/* Release the value */\r\n\t\tjx9MemObjRelease(pValue);\r\n\t\tSyMemBackendPoolFree(&pVm->sAllocator, pValue);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_to_int(jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjToInteger(pValue);\r\n\tif( rc != JX9_OK ){\r\n\t\treturn 0;\r\n\t}\r\n\treturn (int)pValue->x.iVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_to_bool(jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjToBool(pValue);\r\n\tif( rc != JX9_OK ){\r\n\t\treturn 0;\r\n\t}\r\n\treturn (int)pValue->x.iVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_int64 jx9_value_to_int64(jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjToInteger(pValue);\r\n\tif( rc != JX9_OK ){\r\n\t\treturn 0;\r\n\t}\r\n\treturn pValue->x.iVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE double jx9_value_to_double(jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjToReal(pValue);\r\n\tif( rc != JX9_OK ){\r\n\t\treturn (double)0;\r\n\t}\r\n\treturn (double)pValue->x.rVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE const char * jx9_value_to_string(jx9_value *pValue, int *pLen)\r\n{\r\n\tjx9MemObjToString(pValue);\r\n\tif( SyBlobLength(&pValue->sBlob) > 0 ){\r\n\t\tSyBlobNullAppend(&pValue->sBlob);\r\n\t\tif( pLen ){\r\n\t\t\t*pLen = (int)SyBlobLength(&pValue->sBlob);\r\n\t\t}\r\n\t\treturn (const char *)SyBlobData(&pValue->sBlob);\r\n\t}else{\r\n\t\t/* Return the empty string */\r\n\t\tif( pLen ){\r\n\t\t\t*pLen = 0;\r\n\t\t}\r\n\t\treturn \"\";\r\n\t}\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_to_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_value_to_resource(jx9_value *pValue)\r\n{\r\n\tif( (pValue->iFlags & MEMOBJ_RES) == 0 ){\r\n\t\t/* Not a resource, return NULL */\r\n\t\treturn 0;\r\n\t}\r\n\treturn pValue->x.pOther;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_compare()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_compare(jx9_value *pLeft, jx9_value *pRight, int bStrict)\r\n{\r\n\tint rc;\r\n\tif( pLeft == 0 || pRight == 0 ){\r\n\t\t/* TICKET 1433-24: NULL values is harmless operation */\r\n\t\treturn 1;\r\n\t}\r\n\t/* Perform the comparison */\r\n\trc = jx9MemObjCmp(&(*pLeft), &(*pRight), bStrict, 0);\r\n\t/* Comparison result */\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_int(jx9_context *pCtx, int iValue)\r\n{\r\n\treturn jx9_value_int(pCtx->pRet, iValue);\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_int64(jx9_context *pCtx, jx9_int64 iValue)\r\n{\r\n\treturn jx9_value_int64(pCtx->pRet, iValue);\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_bool(jx9_context *pCtx, int iBool)\r\n{\r\n\treturn jx9_value_bool(pCtx->pRet, iBool);\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_double(jx9_context *pCtx, double Value)\r\n{\r\n\treturn jx9_value_double(pCtx->pRet, Value);\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_null(jx9_context *pCtx)\r\n{\r\n\t/* Invalidate any prior representation and set the NULL flag */\r\n\tjx9MemObjRelease(pCtx->pRet);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_string(jx9_context *pCtx, const char *zString, int nLen)\r\n{\r\n\treturn jx9_value_string(pCtx->pRet, zString, nLen);\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_string_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_string_format(jx9_context *pCtx, const char *zFormat, ...)\r\n{\r\n\tjx9_value *p;\r\n\tva_list ap;\r\n\tint rc;\r\n\tp = pCtx->pRet;\r\n\tif( (p->iFlags & MEMOBJ_STRING) == 0 ){\r\n\t\t/* Invalidate any prior representation */\r\n\t\tjx9MemObjRelease(p);\r\n\t\tMemObjSetType(p, MEMOBJ_STRING);\r\n\t}\r\n\t/* Format the given string */\r\n\tva_start(ap, zFormat);\r\n\trc = SyBlobFormatAp(&p->sBlob, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_value(jx9_context *pCtx, jx9_value *pValue)\r\n{\r\n\tint rc = JX9_OK;\r\n\tif( pValue == 0 ){\r\n\t\tjx9MemObjRelease(pCtx->pRet);\r\n\t}else{\r\n\t\trc = jx9MemObjStore(pValue, pCtx->pRet);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_result_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_result_resource(jx9_context *pCtx, void *pUserData)\r\n{\r\n\treturn jx9_value_resource(pCtx->pRet, pUserData);\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_new_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_value * jx9_context_new_scalar(jx9_context *pCtx)\r\n{\r\n\tjx9_value *pVal;\r\n\tpVal = jx9_new_scalar(pCtx->pVm);\r\n\tif( pVal ){\r\n\t\t/* Record value address so it can be freed automatically\r\n\t\t * when the calling function returns. \r\n\t\t */\r\n\t\tSySetPut(&pCtx->sVar, (const void *)&pVal);\r\n\t}\r\n\treturn pVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_new_array()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_value * jx9_context_new_array(jx9_context *pCtx)\r\n{\r\n\tjx9_value *pVal;\r\n\tpVal = jx9_new_array(pCtx->pVm);\r\n\tif( pVal ){\r\n\t\t/* Record value address so it can be freed automatically\r\n\t\t * when the calling function returns. \r\n\t\t */\r\n\t\tSySetPut(&pCtx->sVar, (const void *)&pVal);\r\n\t}\r\n\treturn pVal;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_release_value()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void jx9_context_release_value(jx9_context *pCtx, jx9_value *pValue)\r\n{\r\n\tjx9VmReleaseContextValue(&(*pCtx), pValue);\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_alloc_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_context_alloc_chunk(jx9_context *pCtx, unsigned int nByte, int ZeroChunk, int AutoRelease)\r\n{\r\n\tvoid *pChunk;\r\n\tpChunk = SyMemBackendAlloc(&pCtx->pVm->sAllocator, nByte);\r\n\tif( pChunk ){\r\n\t\tif( ZeroChunk ){\r\n\t\t\t/* Zero the memory chunk */\r\n\t\t\tSyZero(pChunk, nByte);\r\n\t\t}\r\n\t\tif( AutoRelease ){\r\n\t\t\tjx9_aux_data sAux;\r\n\t\t\t/* Track the chunk so that it can be released automatically \r\n\t\t\t * upon this context is destroyed.\r\n\t\t\t */\r\n\t\t\tsAux.pAuxData = pChunk;\r\n\t\t\tSySetPut(&pCtx->sChunk, (const void *)&sAux);\r\n\t\t}\r\n\t}\r\n\treturn pChunk;\r\n}\r\n/*\r\n * Check if the given chunk address is registered in the call context\r\n * chunk container.\r\n * Return TRUE if registered.FALSE otherwise.\r\n * Refer to [jx9_context_realloc_chunk(), jx9_context_free_chunk()].\r\n */\r\nstatic jx9_aux_data * ContextFindChunk(jx9_context *pCtx, void *pChunk)\r\n{\r\n\tjx9_aux_data *aAux, *pAux;\r\n\tsxu32 n;\r\n\tif( SySetUsed(&pCtx->sChunk) < 1 ){\r\n\t\t/* Don't bother processing, the container is empty */\r\n\t\treturn 0;\r\n\t}\r\n\t/* Perform the lookup */\r\n\taAux = (jx9_aux_data *)SySetBasePtr(&pCtx->sChunk);\r\n\tfor( n = 0; n < SySetUsed(&pCtx->sChunk) ; ++n ){\r\n\t\tpAux = &aAux[n];\r\n\t\tif( pAux->pAuxData == pChunk ){\r\n\t\t\t/* Chunk found */\r\n\t\t\treturn pAux;\r\n\t\t}\r\n\t}\r\n\t/* No such allocated chunk */\r\n\treturn 0;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_realloc_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_context_realloc_chunk(jx9_context *pCtx, void *pChunk, unsigned int nByte)\r\n{\r\n\tjx9_aux_data *pAux;\r\n\tvoid *pNew;\r\n\tpNew = SyMemBackendRealloc(&pCtx->pVm->sAllocator, pChunk, nByte);\r\n\tif( pNew ){\r\n\t\tpAux = ContextFindChunk(pCtx, pChunk);\r\n\t\tif( pAux ){\r\n\t\t\tpAux->pAuxData = pNew;\r\n\t\t}\r\n\t}\r\n\treturn pNew;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_free_chunk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void jx9_context_free_chunk(jx9_context *pCtx, void *pChunk)\r\n{\r\n\tjx9_aux_data *pAux;\r\n\tif( pChunk == 0 ){\r\n\t\t/* TICKET-1433-93: NULL chunk is a harmless operation */\r\n\t\treturn;\r\n\t}\r\n\tpAux = ContextFindChunk(pCtx, pChunk);\r\n\tif( pAux ){\r\n\t\t/* Mark as destroyed */\r\n\t\tpAux->pAuxData = 0;\r\n\t}\r\n\tSyMemBackendFree(&pCtx->pVm->sAllocator, pChunk);\r\n}\r\n/*\r\n * [CAPIREF: jx9_array_fetch()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE jx9_value * jx9_array_fetch(jx9_value *pArray, const char *zKey, int nByte)\r\n{\r\n\tjx9_hashmap_node *pNode;\r\n\tjx9_value *pValue;\r\n\tjx9_value skey;\r\n\tint rc;\r\n\t/* Make sure we are dealing with a valid hashmap */\r\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn 0;\r\n\t}\r\n\tif( nByte < 0 ){\r\n\t\tnByte = (int)SyStrlen(zKey);\r\n\t}\r\n\t/* Convert the key to a jx9_value  */\r\n\tjx9MemObjInit(pArray->pVm, &skey);\r\n\tjx9MemObjStringAppend(&skey, zKey, (sxu32)nByte);\r\n\t/* Perform the lookup */\r\n\trc = jx9HashmapLookup((jx9_hashmap *)pArray->x.pOther, &skey, &pNode);\r\n\tjx9MemObjRelease(&skey);\r\n\tif( rc != JX9_OK ){\r\n\t\t/* No such entry */\r\n\t\treturn 0;\r\n\t}\r\n\t/* Extract the target value */\r\n\tpValue = (jx9_value *)SySetAt(&pArray->pVm->aMemObj, pNode->nValIdx);\r\n\treturn pValue;\r\n}\r\n/*\r\n * [CAPIREF: jx9_array_walk()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_array_walk(jx9_value *pArray, int (*xWalk)(jx9_value *pValue, jx9_value *, void *), void *pUserData)\r\n{\r\n\tint rc;\r\n\tif( xWalk == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\t/* Make sure we are dealing with a valid hashmap */\r\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\t/* Start the walk process */\r\n\trc = jx9HashmapWalk((jx9_hashmap *)pArray->x.pOther, xWalk, pUserData);\r\n\treturn rc != JX9_OK ? JX9_ABORT /* User callback request an operation abort*/ : JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_array_add_elem()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_array_add_elem(jx9_value *pArray, jx9_value *pKey, jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\t/* Make sure we are dealing with a valid hashmap */\r\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\t/* Perform the insertion */\r\n\trc = jx9HashmapInsert((jx9_hashmap *)pArray->x.pOther, &(*pKey), &(*pValue));\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_array_add_strkey_elem()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_array_add_strkey_elem(jx9_value *pArray, const char *zKey, jx9_value *pValue)\r\n{\r\n\tint rc;\r\n\t/* Make sure we are dealing with a valid hashmap */\r\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\t/* Perform the insertion */\r\n\tif( SX_EMPTY_STR(zKey) ){\r\n\t\t/* Empty key, assign an automatic index */\r\n\t\trc = jx9HashmapInsert((jx9_hashmap *)pArray->x.pOther, 0, &(*pValue));\r\n\t}else{\r\n\t\tjx9_value sKey;\r\n\t\tjx9MemObjInitFromString(pArray->pVm, &sKey, 0);\r\n\t\tjx9MemObjStringAppend(&sKey, zKey, (sxu32)SyStrlen(zKey));\r\n\t\trc = jx9HashmapInsert((jx9_hashmap *)pArray->x.pOther, &sKey, &(*pValue));\r\n\t\tjx9MemObjRelease(&sKey);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_array_count()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE unsigned int jx9_array_count(jx9_value *pArray)\r\n{\r\n\tjx9_hashmap *pMap;\r\n\t/* Make sure we are dealing with a valid hashmap */\r\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn 0;\r\n\t}\r\n\t/* Point to the internal representation of the hashmap */\r\n\tpMap = (jx9_hashmap *)pArray->x.pOther;\r\n\treturn pMap->nEntry;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_output()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_context_output(jx9_context *pCtx, const char *zString, int nLen)\r\n{\r\n\tSyString sData;\r\n\tint rc;\r\n\tif( nLen < 0 ){\r\n\t\tnLen = (int)SyStrlen(zString);\r\n\t}\r\n\tSyStringInitFromBuf(&sData, zString, nLen);\r\n\trc = jx9VmOutputConsume(pCtx->pVm, &sData);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_throw_error()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_context_throw_error(jx9_context *pCtx, int iErr, const char *zErr)\r\n{\r\n\tint rc = JX9_OK;\r\n\tif( zErr ){\r\n\t\trc = jx9VmThrowError(pCtx->pVm, &pCtx->pFunc->sName, iErr, zErr);\r\n\t}\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_throw_error_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_context_throw_error_format(jx9_context *pCtx, int iErr, const char *zFormat, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif( zFormat == 0){\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tva_start(ap, zFormat);\r\n\trc = jx9VmThrowErrorAp(pCtx->pVm, &pCtx->pFunc->sName, iErr, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_random_num()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE unsigned int jx9_context_random_num(jx9_context *pCtx)\r\n{\r\n\tsxu32 n;\r\n\tn = jx9VmRandomNum(pCtx->pVm);\r\n\treturn n;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_random_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_context_random_string(jx9_context *pCtx, char *zBuf, int nBuflen)\r\n{\r\n\tif( nBuflen < 3 ){\r\n\t\treturn JX9_CORRUPT;\r\n\t}\r\n\tjx9VmRandomString(pCtx->pVm, zBuf, nBuflen);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_user_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_context_user_data(jx9_context *pCtx)\r\n{\r\n\treturn pCtx->pFunc->pUserData;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_push_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_context_push_aux_data(jx9_context *pCtx, void *pUserData)\r\n{\r\n\tjx9_aux_data sAux;\r\n\tint rc;\r\n\tsAux.pAuxData = pUserData;\r\n\trc = SySetPut(&pCtx->pFunc->aAux, (const void *)&sAux);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_peek_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_context_peek_aux_data(jx9_context *pCtx)\r\n{\r\n\tjx9_aux_data *pAux;\r\n\tpAux = (jx9_aux_data *)SySetPeek(&pCtx->pFunc->aAux);\r\n\treturn pAux ? pAux->pAuxData : 0;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_pop_aux_data()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE void * jx9_context_pop_aux_data(jx9_context *pCtx)\r\n{\r\n\tjx9_aux_data *pAux;\r\n\tpAux = (jx9_aux_data *)SySetPop(&pCtx->pFunc->aAux);\r\n\treturn pAux ? pAux->pAuxData : 0;\r\n}\r\n/*\r\n * [CAPIREF: jx9_context_result_buf_length()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE unsigned int jx9_context_result_buf_length(jx9_context *pCtx)\r\n{\r\n\treturn SyBlobLength(&pCtx->pRet->sBlob);\r\n}\r\n/*\r\n * [CAPIREF: jx9_function_name()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE const char * jx9_function_name(jx9_context *pCtx)\r\n{\r\n\tSyString *pName;\r\n\tpName = &pCtx->pFunc->sName;\r\n\treturn pName->zString;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_int(jx9_value *pVal, int iValue)\r\n{\r\n\t/* Invalidate any prior representation */\r\n\tjx9MemObjRelease(pVal);\r\n\tpVal->x.iVal = (jx9_int64)iValue;\r\n\tMemObjSetType(pVal, MEMOBJ_INT);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_int64()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_int64(jx9_value *pVal, jx9_int64 iValue)\r\n{\r\n\t/* Invalidate any prior representation */\r\n\tjx9MemObjRelease(pVal);\r\n\tpVal->x.iVal = iValue;\r\n\tMemObjSetType(pVal, MEMOBJ_INT);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_bool(jx9_value *pVal, int iBool)\r\n{\r\n\t/* Invalidate any prior representation */\r\n\tjx9MemObjRelease(pVal);\r\n\tpVal->x.iVal = iBool ? 1 : 0;\r\n\tMemObjSetType(pVal, MEMOBJ_BOOL);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_null(jx9_value *pVal)\r\n{\r\n\t/* Invalidate any prior representation and set the NULL flag */\r\n\tjx9MemObjRelease(pVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_double()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_double(jx9_value *pVal, double Value)\r\n{\r\n\t/* Invalidate any prior representation */\r\n\tjx9MemObjRelease(pVal);\r\n\tpVal->x.rVal = (jx9_real)Value;\r\n\tMemObjSetType(pVal, MEMOBJ_REAL);\r\n\t/* Try to get an integer representation also */\r\n\tjx9MemObjTryInteger(pVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_string(jx9_value *pVal, const char *zString, int nLen)\r\n{\r\n\tif((pVal->iFlags & MEMOBJ_STRING) == 0 ){\r\n\t\t/* Invalidate any prior representation */\r\n\t\tjx9MemObjRelease(pVal);\r\n\t\tMemObjSetType(pVal, MEMOBJ_STRING);\r\n\t}\r\n\tif( zString ){\r\n\t\tif( nLen < 0 ){\r\n\t\t\t/* Compute length automatically */\r\n\t\t\tnLen = (int)SyStrlen(zString);\r\n\t\t}\r\n\t\tSyBlobAppend(&pVal->sBlob, (const void *)zString, (sxu32)nLen);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_string_format()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_string_format(jx9_value *pVal, const char *zFormat, ...)\r\n{\r\n\tva_list ap;\r\n\tint rc;\r\n\tif((pVal->iFlags & MEMOBJ_STRING) == 0 ){\r\n\t\t/* Invalidate any prior representation */\r\n\t\tjx9MemObjRelease(pVal);\r\n\t\tMemObjSetType(pVal, MEMOBJ_STRING);\r\n\t}\r\n\tva_start(ap, zFormat);\r\n\trc = SyBlobFormatAp(&pVal->sBlob, zFormat, ap);\r\n\tva_end(ap);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_reset_string_cursor()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_reset_string_cursor(jx9_value *pVal)\r\n{\r\n\t/* Reset the string cursor */\r\n\tSyBlobReset(&pVal->sBlob);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_resource(jx9_value *pVal, void *pUserData)\r\n{\r\n\t/* Invalidate any prior representation */\r\n\tjx9MemObjRelease(pVal);\r\n\t/* Reflect the new type */\r\n\tpVal->x.pOther = pUserData;\r\n\tMemObjSetType(pVal, MEMOBJ_RES);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_release()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_release(jx9_value *pVal)\r\n{\r\n\tjx9MemObjRelease(pVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_int()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_int(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_INT) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_float()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_float(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_REAL) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_bool()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_bool(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_BOOL) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_string()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_string(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_STRING) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_null()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_null(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_NULL) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_numeric()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_numeric(jx9_value *pVal)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjIsNumeric(pVal);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_callable()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_callable(jx9_value *pVal)\r\n{\r\n\tint rc;\r\n\trc = jx9VmIsCallable(pVal->pVm, pVal);\r\n\treturn rc;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_scalar()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_scalar(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_SCALAR) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_json_array()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_json_array(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_HASHMAP) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_json_object()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_json_object(jx9_value *pVal)\r\n{\r\n\tjx9_hashmap *pMap;\r\n\tif( (pVal->iFlags & MEMOBJ_HASHMAP) == 0 ){\r\n\t\treturn FALSE;\r\n\t}\r\n\tpMap = (jx9_hashmap *)pVal->x.pOther;\r\n\tif( (pMap->iFlags & HASHMAP_JSON_OBJECT) == 0 ){\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_resource()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_resource(jx9_value *pVal)\r\n{\r\n\treturn (pVal->iFlags & MEMOBJ_RES) ? TRUE : FALSE;\r\n}\r\n/*\r\n * [CAPIREF: jx9_value_is_empty()]\r\n * Please refer to the official documentation for function purpose and expected parameters.\r\n */\r\nJX9_PRIVATE int jx9_value_is_empty(jx9_value *pVal)\r\n{\r\n\tint rc;\r\n\trc = jx9MemObjIsEmpty(pVal);\r\n\treturn rc;\r\n}\r\n/*\r\n * ----------------------------------------------------------\r\n * File: jx9_builtin.c\r\n * MD5: 97ae6ddf8ded9fe14634060675e12f80\r\n * ----------------------------------------------------------\r\n */\r\n/*\r\n * Symisc JX9: A Highly Efficient Embeddable Scripting Engine Based on JSON.\r\n * Copyright (C) 2012-2013, Symisc Systems http://jx9.symisc.net/\r\n * Version 1.7.2\r\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\r\n * please contact Symisc Systems via:\r\n *       legal@symisc.net\r\n *       licensing@symisc.net\r\n *       contact@symisc.net\r\n * or visit:\r\n *      http://jx9.symisc.net/\r\n */\r\n /* $SymiscID: builtin.c v1.7 Win7 2012-12-13 00:01 stable <chm@symisc.net> $ */\r\n#ifndef JX9_AMALGAMATION\r\n#include \"jx9Int.h\"\r\n#endif\r\n/* This file implement built-in 'foreign' functions for the JX9 engine */\r\n/*\r\n * Section:\r\n *    Variable handling Functions.\r\n * Authors:\r\n *    Symisc Systems, devel@symisc.net.\r\n *    Copyright (C) Symisc Systems, http://jx9.symisc.net\r\n * Status:\r\n *    Stable.\r\n */\r\n/*\r\n * bool is_bool($var)\r\n *  Finds out whether a variable is a boolean.\r\n * Parameters\r\n *   $var: The variable being evaluated.\r\n * Return\r\n *  TRUE if var is a boolean. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_bool(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_bool(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_float($var)\r\n * bool is_real($var)\r\n * bool is_double($var)\r\n *  Finds out whether a variable is a float.\r\n * Parameters\r\n *   $var: The variable being evaluated.\r\n * Return\r\n *  TRUE if var is a float. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_float(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_float(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_int($var)\r\n * bool is_integer($var)\r\n * bool is_long($var)\r\n *  Finds out whether a variable is an integer.\r\n * Parameters\r\n *   $var: The variable being evaluated.\r\n * Return\r\n *  TRUE if var is an integer. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_int(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_int(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_string($var)\r\n *  Finds out whether a variable is a string.\r\n * Parameters\r\n *   $var: The variable being evaluated.\r\n * Return\r\n *  TRUE if var is string. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_string(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_string(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_null($var)\r\n *  Finds out whether a variable is NULL.\r\n * Parameters\r\n *   $var: The variable being evaluated.\r\n * Return\r\n *  TRUE if var is NULL. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_null(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_null(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_numeric($var)\r\n *  Find out whether a variable is NULL.\r\n * Parameters\r\n *  $var: The variable being evaluated.\r\n * Return\r\n *  True if var is numeric. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_numeric(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_numeric(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_scalar($var)\r\n *  Find out whether a variable is a scalar.\r\n * Parameters\r\n *  $var: The variable being evaluated.\r\n * Return\r\n *  True if var is scalar. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_scalar(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_scalar(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_array($var)\r\n *  Find out whether a variable is an array.\r\n * Parameters\r\n *  $var: The variable being evaluated.\r\n * Return\r\n *  True if var is an array. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_array(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_json_array(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_object($var)\r\n *  Find out whether a variable is an object.\r\n * Parameters\r\n *  $var: The variable being evaluated.\r\n * Return\r\n *  True if var is an object. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_object(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_json_object(apArg[0]);\r\n\t}\r\n\t/* Query result */\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool is_resource($var)\r\n *  Find out whether a variable is a resource.\r\n * Parameters\r\n *  $var: The variable being evaluated.\r\n * Return\r\n *  True if a resource. False otherwise.\r\n */\r\nstatic int jx9Builtin_is_resource(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 0; /* Assume false by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_resource(apArg[0]);\r\n\t}\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float floatval($var)\r\n *  Get float value of a variable.\r\n * Parameter\r\n *  $var: The variable being processed.\r\n * Return\r\n *  the float value of a variable.\r\n */\r\nstatic int jx9Builtin_floatval(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tif( nArg < 1 ){\r\n\t\t/* return 0.0 */\r\n\t\tjx9_result_double(pCtx, 0);\r\n\t}else{\r\n\t\tdouble dval;\r\n\t\t/* Perform the cast */\r\n\t\tdval = jx9_value_to_double(apArg[0]);\r\n\t\tjx9_result_double(pCtx, dval);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int intval($var)\r\n *  Get integer value of a variable.\r\n * Parameter\r\n *  $var: The variable being processed.\r\n * Return\r\n *  the int value of a variable.\r\n */\r\nstatic int jx9Builtin_intval(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tif( nArg < 1 ){\r\n\t\t/* return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t}else{\r\n\t\tsxi64 iVal;\r\n\t\t/* Perform the cast */\r\n\t\tiVal = jx9_value_to_int64(apArg[0]);\r\n\t\tjx9_result_int64(pCtx, iVal);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strval($var)\r\n *  Get the string representation of a variable.\r\n * Parameter\r\n *  $var: The variable being processed.\r\n * Return\r\n *  the string value of a variable.\r\n */\r\nstatic int jx9Builtin_strval(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tif( nArg < 1 ){\r\n\t\t/* return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t}else{\r\n\t\tconst char *zVal;\r\n\t\tint iLen = 0; /* cc -O6 warning */\r\n\t\t/* Perform the cast */\r\n\t\tzVal = jx9_value_to_string(apArg[0], &iLen);\r\n\t\tjx9_result_string(pCtx, zVal, iLen);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * bool empty($var)\r\n *  Determine whether a variable is empty.\r\n * Parameters\r\n *   $var: The variable being checked.\r\n * Return\r\n *  0 if var has a non-empty and non-zero value.1 otherwise.\r\n */\r\nstatic int jx9Builtin_empty(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint res = 1; /* Assume empty by default */\r\n\tif( nArg > 0 ){\r\n\t\tres = jx9_value_is_empty(apArg[0]);\r\n\t}\r\n\tjx9_result_bool(pCtx, res);\r\n\treturn JX9_OK;\r\n\t\r\n}\r\n#ifndef JX9_DISABLE_BUILTIN_FUNC\r\n#ifdef JX9_ENABLE_MATH_FUNC\r\n/*\r\n * Section:\r\n *    Math Functions.\r\n * Authors:\r\n *    Symisc Systems, devel@symisc.net.\r\n *    Copyright (C) Symisc Systems, http://jx9.symisc.net\r\n * Status:\r\n *    Stable.\r\n */\r\n#include <stdlib.h> /* abs */\r\n#include <math.h>\r\n/*\r\n * float sqrt(float $arg )\r\n *  Square root of the given number.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The square root of arg or the special value Nan of failure.\r\n */\r\nstatic int jx9Builtin_sqrt(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = sqrt(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float exp(float $arg )\r\n *  Calculates the exponent of e.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  'e' raised to the power of arg.\r\n */\r\nstatic int jx9Builtin_exp(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = exp(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float floor(float $arg )\r\n *  Round fractions down.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  Returns the next lowest integer value by rounding down value if necessary.\r\n */\r\nstatic int jx9Builtin_floor(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = floor(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float cos(float $arg )\r\n *  Cosine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The cosine of arg.\r\n */\r\nstatic int jx9Builtin_cos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = cos(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float acos(float $arg )\r\n *  Arc cosine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The arc cosine of arg.\r\n */\r\nstatic int jx9Builtin_acos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = acos(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float cosh(float $arg )\r\n *  Hyperbolic cosine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The hyperbolic cosine of arg.\r\n */\r\nstatic int jx9Builtin_cosh(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = cosh(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float sin(float $arg )\r\n *  Sine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The sine of arg.\r\n */\r\nstatic int jx9Builtin_sin(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = sin(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float asin(float $arg )\r\n *  Arc sine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The arc sine of arg.\r\n */\r\nstatic int jx9Builtin_asin(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = asin(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float sinh(float $arg )\r\n *  Hyperbolic sine.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The hyperbolic sine of arg.\r\n */\r\nstatic int jx9Builtin_sinh(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = sinh(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float ceil(float $arg )\r\n *  Round fractions up.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The next highest integer value by rounding up value if necessary.\r\n */\r\nstatic int jx9Builtin_ceil(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = ceil(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float tan(float $arg )\r\n *  Tangent.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The tangent of arg.\r\n */\r\nstatic int jx9Builtin_tan(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = tan(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float atan(float $arg )\r\n *  Arc tangent.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The arc tangent of arg.\r\n */\r\nstatic int jx9Builtin_atan(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = atan(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float tanh(float $arg )\r\n *  Hyperbolic tangent.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The Hyperbolic tangent of arg.\r\n */\r\nstatic int jx9Builtin_tanh(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = tanh(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float atan2(float $y, float $x)\r\n *  Arc tangent of two variable.\r\n * Parameter\r\n *  $y = Dividend parameter.\r\n *  $x = Divisor parameter.\r\n * Return\r\n *  The arc tangent of y/x in radian.\r\n */\r\nstatic int jx9Builtin_atan2(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x, y;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\ty = jx9_value_to_double(apArg[0]);\r\n\tx = jx9_value_to_double(apArg[1]);\r\n\t/* Perform the requested operation */\r\n\tr = atan2(y, x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float/int64 abs(float/int64 $arg )\r\n *  Absolute value.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The absolute value of number.\r\n */\r\nstatic int jx9Builtin_abs(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint is_float;\t\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tis_float = jx9_value_is_float(apArg[0]);\r\n\tif( is_float ){\r\n\t\tdouble r, x;\r\n\t\tx = jx9_value_to_double(apArg[0]);\r\n\t\t/* Perform the requested operation */\r\n\t\tr = fabs(x);\r\n\t\tjx9_result_double(pCtx, r);\r\n\t}else{\r\n\t\tint r, x;\r\n\t\tx = jx9_value_to_int(apArg[0]);\r\n\t\t/* Perform the requested operation */\r\n\t\tr = abs(x);\r\n\t\tjx9_result_int(pCtx, r);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float log(float $arg, [int/float $base])\r\n *  Natural logarithm.\r\n * Parameter\r\n *  $arg: The number to process.\r\n *  $base: The optional logarithmic base to use. (only base-10 is supported)\r\n * Return\r\n *  The logarithm of arg to base, if given, or the natural logarithm.\r\n * Note: \r\n *  only Natural log and base-10 log are supported. \r\n */\r\nstatic int jx9Builtin_log(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tif( nArg == 2 && jx9_value_is_numeric(apArg[1]) && jx9_value_to_int(apArg[1]) == 10 ){\r\n\t\t/* Base-10 log */\r\n\t\tr = log10(x);\r\n\t}else{\r\n\t\tr = log(x);\r\n\t}\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float log10(float $arg )\r\n *  Base-10 logarithm.\r\n * Parameter\r\n *  The number to process.\r\n * Return\r\n *  The Base-10 logarithm of the given number.\r\n */\r\nstatic int jx9Builtin_log10(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\t/* Perform the requested operation */\r\n\tr = log10(x);\r\n\t/* store the result back */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * number pow(number $base, number $exp)\r\n *  Exponential expression.\r\n * Parameter\r\n *  base\r\n *  The base to use.\r\n * exp\r\n *  The exponent.\r\n * Return\r\n *  base raised to the power of exp.\r\n *  If the result can be represented as integer it will be returned\r\n *  as type integer, else it will be returned as type float. \r\n */\r\nstatic int jx9Builtin_pow(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble r, x, y;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\ty = jx9_value_to_double(apArg[1]);\r\n\t/* Perform the requested operation */\r\n\tr = pow(x, y);\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float pi(void)\r\n *  Returns an approximation of pi. \r\n * Note\r\n *  you can use the M_PI constant which yields identical results to pi(). \r\n * Return\r\n *  The value of pi as float.\r\n */\r\nstatic int jx9Builtin_pi(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tSXUNUSED(nArg); /* cc warning */\r\n\tSXUNUSED(apArg);\r\n\tjx9_result_double(pCtx, JX9_PI);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float fmod(float $x, float $y)\r\n *  Returns the floating point remainder (modulo) of the division of the arguments. \r\n * Parameters\r\n * $x\r\n *  The dividend\r\n * $y\r\n *  The divisor\r\n * Return\r\n *  The floating point remainder of x/y.\r\n */\r\nstatic int jx9Builtin_fmod(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble x, y, r; \r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments */\r\n\t\tjx9_result_double(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract given arguments */\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\ty = jx9_value_to_double(apArg[1]);\r\n\t/* Perform the requested operation */\r\n\tr = fmod(x, y);\r\n\t/* Processing result */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * float hypot(float $x, float $y)\r\n *  Calculate the length of the hypotenuse of a right-angle triangle . \r\n * Parameters\r\n * $x\r\n *  Length of first side\r\n * $y\r\n *  Length of first side\r\n * Return\r\n *  Calculated length of the hypotenuse.\r\n */\r\nstatic int jx9Builtin_hypot(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tdouble x, y, r; \r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments */\r\n\t\tjx9_result_double(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract given arguments */\r\n\tx = jx9_value_to_double(apArg[0]);\r\n\ty = jx9_value_to_double(apArg[1]);\r\n\t/* Perform the requested operation */\r\n\tr = hypot(x, y);\r\n\t/* Processing result */\r\n\tjx9_result_double(pCtx, r);\r\n\treturn JX9_OK;\r\n}\r\n#endif /* JX9_ENABLE_MATH_FUNC */\r\n/*\r\n * float round ( float $val [, int $precision = 0 [, int $mode = JX9_ROUND_HALF_UP ]] )\r\n *  Exponential expression.\r\n * Parameter\r\n *  $val\r\n *   The value to round.\r\n * $precision\r\n *   The optional number of decimal digits to round to.\r\n * $mode\r\n *   One of JX9_ROUND_HALF_UP, JX9_ROUND_HALF_DOWN, JX9_ROUND_HALF_EVEN, or JX9_ROUND_HALF_ODD.\r\n *   (not supported).\r\n * Return\r\n *  The rounded value.\r\n */\r\nstatic int jx9Builtin_round(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint n = 0;\r\n\tdouble r;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the precision if available */\r\n\tif( nArg > 1 ){\r\n\t\tn = jx9_value_to_int(apArg[1]);\r\n\t\tif( n>30 ){\r\n\t\t\tn = 30;\r\n\t\t}\r\n\t\tif( n<0 ){\r\n\t\t\tn = 0;\r\n\t\t}\r\n\t}\r\n\tr = jx9_value_to_double(apArg[0]);\r\n\t/* If Y==0 and X will fit in a 64-bit int, \r\n     * handle the rounding directly.Otherwise \r\n\t * use our own cutsom printf [i.e:SyBufferFormat()].\r\n     */\r\n  if( n==0 && r>=0 && r<LARGEST_INT64-1 ){\r\n    r = (double)((jx9_int64)(r+0.5));\r\n  }else if( n==0 && r<0 && (-r)<LARGEST_INT64-1 ){\r\n    r = -(double)((jx9_int64)((-r)+0.5));\r\n  }else{\r\n\t  char zBuf[256];\r\n\t  sxu32 nLen;\r\n\t  nLen = SyBufferFormat(zBuf, sizeof(zBuf), \"%.*f\", n, r);\r\n\t  /* Convert the string to real number */\r\n\t  SyStrToReal(zBuf, nLen, (void *)&r, 0);\r\n  }\r\n  /* Return thr rounded value */\r\n  jx9_result_double(pCtx, r);\r\n  return JX9_OK;\r\n}\r\n/*\r\n * string dechex(int $number)\r\n *  Decimal to hexadecimal.\r\n * Parameters\r\n *  $number\r\n *   Decimal value to convert\r\n * Return\r\n *  Hexadecimal string representation of number\r\n */\r\nstatic int jx9Builtin_dechex(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iVal;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the given number */\r\n\tiVal = jx9_value_to_int(apArg[0]);\r\n\t/* Format */\r\n\tjx9_result_string_format(pCtx, \"%x\", iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string decoct(int $number)\r\n *  Decimal to Octal.\r\n * Parameters\r\n *  $number\r\n *   Decimal value to convert\r\n * Return\r\n *  Octal string representation of number\r\n */\r\nstatic int jx9Builtin_decoct(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iVal;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the given number */\r\n\tiVal = jx9_value_to_int(apArg[0]);\r\n\t/* Format */\r\n\tjx9_result_string_format(pCtx, \"%o\", iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string decbin(int $number)\r\n *  Decimal to binary.\r\n * Parameters\r\n *  $number\r\n *   Decimal value to convert\r\n * Return\r\n *  Binary string representation of number\r\n */\r\nstatic int jx9Builtin_decbin(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iVal;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the given number */\r\n\tiVal = jx9_value_to_int(apArg[0]);\r\n\t/* Format */\r\n\tjx9_result_string_format(pCtx, \"%B\", iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int64 hexdec(string $hex_string)\r\n *  Hexadecimal to decimal.\r\n * Parameters\r\n *  $hex_string\r\n *   The hexadecimal string to convert\r\n * Return\r\n *  The decimal representation of hex_string \r\n */\r\nstatic int jx9Builtin_hexdec(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zEnd;\r\n\tjx9_int64 iVal;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return -1 */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tiVal = 0;\r\n\tif( jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Extract the given string */\r\n\t\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\t\t/* Delimit the string */\r\n\t\tzEnd = &zString[nLen];\r\n\t\t/* Ignore non hex-stream */\r\n\t\twhile( zString < zEnd ){\r\n\t\t\tif( (unsigned char)zString[0] >= 0xc0 ){\r\n\t\t\t\t/* UTF-8 stream */\r\n\t\t\t\tzString++;\r\n\t\t\t\twhile( zString < zEnd && (((unsigned char)zString[0] & 0xc0) == 0x80) ){\r\n\t\t\t\t\tzString++;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif( SyisHex(zString[0]) ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t/* Ignore */\r\n\t\t\t\tzString++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( zString < zEnd ){\r\n\t\t\t/* Cast */\r\n\t\t\tSyHexStrToInt64(zString, (sxu32)(zEnd-zString), (void *)&iVal, 0);\r\n\t\t}\r\n\t}else{\r\n\t\t/* Extract as a 64-bit integer */\r\n\t\tiVal = jx9_value_to_int64(apArg[0]);\r\n\t}\r\n\t/* Return the number */\r\n\tjx9_result_int64(pCtx, iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int64 bindec(string $bin_string)\r\n *  Binary to decimal.\r\n * Parameters\r\n *  $bin_string\r\n *   The binary string to convert\r\n * Return\r\n *  Returns the decimal equivalent of the binary number represented by the binary_string argument.  \r\n */\r\nstatic int jx9Builtin_bindec(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tjx9_int64 iVal;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return -1 */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tiVal = 0;\r\n\tif( jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Extract the given string */\r\n\t\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\t\tif( nLen > 0 ){\r\n\t\t\t/* Perform a binary cast */\r\n\t\t\tSyBinaryStrToInt64(zString, (sxu32)nLen, (void *)&iVal, 0);\r\n\t\t}\r\n\t}else{\r\n\t\t/* Extract as a 64-bit integer */\r\n\t\tiVal = jx9_value_to_int64(apArg[0]);\r\n\t}\r\n\t/* Return the number */\r\n\tjx9_result_int64(pCtx, iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int64 octdec(string $oct_string)\r\n *  Octal to decimal.\r\n * Parameters\r\n *  $oct_string\r\n *   The octal string to convert\r\n * Return\r\n *  Returns the decimal equivalent of the octal number represented by the octal_string argument.  \r\n */\r\nstatic int jx9Builtin_octdec(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tjx9_int64 iVal;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return -1 */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tiVal = 0;\r\n\tif( jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Extract the given string */\r\n\t\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\t\tif( nLen > 0 ){\r\n\t\t\t/* Perform the cast */\r\n\t\t\tSyOctalStrToInt64(zString, (sxu32)nLen, (void *)&iVal, 0);\r\n\t\t}\r\n\t}else{\r\n\t\t/* Extract as a 64-bit integer */\r\n\t\tiVal = jx9_value_to_int64(apArg[0]);\r\n\t}\r\n\t/* Return the number */\r\n\tjx9_result_int64(pCtx, iVal);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string base_convert(string $number, int $frombase, int $tobase)\r\n *  Convert a number between arbitrary bases.\r\n * Parameters\r\n * $number\r\n *  The number to convert\r\n * $frombase\r\n *  The base number is in\r\n * $tobase\r\n *  The base to convert number to\r\n * Return\r\n *  Number converted to base tobase \r\n */\r\nstatic int jx9Builtin_base_convert(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint nLen, iFbase, iTobase;\r\n\tconst char *zNum;\r\n\tjx9_int64 iNum;\r\n\tif( nArg < 3 ){\r\n\t\t/* Return the empty string*/\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Base numbers */\r\n\tiFbase  = jx9_value_to_int(apArg[1]);\r\n\tiTobase = jx9_value_to_int(apArg[2]);\r\n\tif( jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Extract the target number */\r\n\t\tzNum = jx9_value_to_string(apArg[0], &nLen);\r\n\t\tif( nLen < 1 ){\r\n\t\t\t/* Return the empty string*/\r\n\t\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Base conversion */\r\n\t\tswitch(iFbase){\r\n\t\tcase 16:\r\n\t\t\t/* Hex */\r\n\t\t\tSyHexStrToInt64(zNum, (sxu32)nLen, (void *)&iNum, 0);\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t\t/* Octal */\r\n\t\t\tSyOctalStrToInt64(zNum, (sxu32)nLen, (void *)&iNum, 0);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\t/* Binary */\r\n\t\t\tSyBinaryStrToInt64(zNum, (sxu32)nLen, (void *)&iNum, 0);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t/* Decimal */\r\n\t\t\tSyStrToInt64(zNum, (sxu32)nLen, (void *)&iNum, 0);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}else{\r\n\t\tiNum = jx9_value_to_int64(apArg[0]);\r\n\t}\r\n\tswitch(iTobase){\r\n\tcase 16:\r\n\t\t/* Hex */\r\n\t\tjx9_result_string_format(pCtx, \"%qx\", iNum); /* Quad hex */\r\n\t\tbreak;\r\n\tcase 8:\r\n\t\t/* Octal */\r\n\t\tjx9_result_string_format(pCtx, \"%qo\", iNum); /* Quad octal */\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\t/* Binary */\r\n\t\tjx9_result_string_format(pCtx, \"%qB\", iNum); /* Quad binary */\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t/* Decimal */\r\n\t\tjx9_result_string_format(pCtx, \"%qd\", iNum); /* Quad decimal */\r\n\t\tbreak;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Section:\r\n *    String handling Functions.\r\n * Authors:\r\n *    Symisc Systems, devel@symisc.net.\r\n *    Copyright (C) Symisc Systems, http://jx9.symisc.net\r\n * Status:\r\n *    Stable.\r\n */\r\n/*\r\n * string substr(string $string, int $start[, int $length ])\r\n *  Return part of a string.\r\n * Parameters\r\n *  $string\r\n *   The input string. Must be one character or longer.\r\n * $start\r\n *   If start is non-negative, the returned string will start at the start'th position\r\n *   in string, counting from zero. For instance, in the string 'abcdef', the character\r\n *   at position 0 is 'a', the character at position 2 is 'c', and so forth.\r\n *   If start is negative, the returned string will start at the start'th character\r\n *   from the end of string.\r\n *   If string is less than or equal to start characters long, FALSE will be returned.\r\n * $length\r\n *   If length is given and is positive, the string returned will contain at most length\r\n *   characters beginning from start (depending on the length of string).\r\n *   If length is given and is negative, then that many characters will be omitted from\r\n *   the end of string (after the start position has been calculated when a start is negative).\r\n *   If start denotes the position of this truncation or beyond, false will be returned.\r\n *   If length is given and is 0, FALSE or NULL an empty string will be returned.\r\n *   If length is omitted, the substring starting from start until the end of the string\r\n *   will be returned. \r\n * Return\r\n *  Returns the extracted part of string, or FALSE on failure or an empty string.\r\n */\r\nstatic int jx9Builtin_substr(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zSource, *zOfft;\r\n\tint nOfft, nLen, nSrcLen;\t\r\n\tif( nArg < 2 ){\r\n\t\t/* return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzSource = jx9_value_to_string(apArg[0], &nSrcLen);\r\n\tif( nSrcLen < 1 ){\r\n\t\t/* Empty string, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tnLen = nSrcLen; /* cc warning */\r\n\t/* Extract the offset */\r\n\tnOfft = jx9_value_to_int(apArg[1]);\r\n\tif( nOfft < 0 ){\r\n\t\tzOfft = &zSource[nSrcLen+nOfft]; \r\n\t\tif( zOfft < zSource ){\r\n\t\t\t/* Invalid offset */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tnLen = (int)(&zSource[nSrcLen]-zOfft);\r\n\t\tnOfft = (int)(zOfft-zSource);\r\n\t}else if( nOfft >= nSrcLen ){\r\n\t\t/* Invalid offset */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}else{\r\n\t\tzOfft = &zSource[nOfft];\r\n\t\tnLen = nSrcLen - nOfft;\r\n\t}\r\n\tif( nArg > 2 ){\r\n\t\t/* Extract the length */\r\n\t\tnLen = jx9_value_to_int(apArg[2]);\r\n\t\tif( nLen == 0 ){\r\n\t\t\t/* Invalid length, return an empty string */\r\n\t\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}else if( nLen < 0 ){\r\n\t\t\tnLen = nSrcLen + nLen - nOfft;\r\n\t\t\tif( nLen < 1 ){\r\n\t\t\t\t/* Invalid  length */\r\n\t\t\t\tnLen = nSrcLen - nOfft;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( nLen + nOfft > nSrcLen ){\r\n\t\t\t/* Invalid length */\r\n\t\t\tnLen = nSrcLen - nOfft;\r\n\t\t}\r\n\t}\r\n\t/* Return the substring */\r\n\tjx9_result_string(pCtx, zOfft, nLen);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int substr_compare(string $main_str, string $str , int $offset[, int $length[, bool $case_insensitivity = false ]])\r\n *  Binary safe comparison of two strings from an offset, up to length characters.\r\n * Parameters\r\n *  $main_str\r\n *  The main string being compared.\r\n *  $str\r\n *   The secondary string being compared.\r\n * $offset\r\n *  The start position for the comparison. If negative, it starts counting from\r\n *  the end of the string.\r\n * $length\r\n *  The length of the comparison. The default value is the largest of the length \r\n *  of the str compared to the length of main_str less the offset.\r\n * $case_insensitivity\r\n *  If case_insensitivity is TRUE, comparison is case insensitive.\r\n * Return\r\n *  Returns < 0 if main_str from position offset is less than str, > 0 if it is greater than\r\n *  str, and 0 if they are equal. If offset is equal to or greater than the length of main_str\r\n *  or length is set and is less than 1, substr_compare() prints a warning and returns FALSE. \r\n */\r\nstatic int jx9Builtin_substr_compare(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zSource, *zOfft, *zSub;\r\n\tint nOfft, nLen, nSrcLen, nSublen;\r\n\tint iCase = 0;\r\n\tint rc;\r\n\tif( nArg < 3 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzSource = jx9_value_to_string(apArg[0], &nSrcLen);\r\n\tif( nSrcLen < 1 ){\r\n\t\t/* Empty string, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tnLen = nSrcLen; /* cc warning */\r\n\t/* Extract the substring */\r\n\tzSub = jx9_value_to_string(apArg[1], &nSublen);\r\n\tif( nSublen < 1 || nSublen > nSrcLen){\r\n\t\t/* Empty string, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the offset */\r\n\tnOfft = jx9_value_to_int(apArg[2]);\r\n\tif( nOfft < 0 ){\r\n\t\tzOfft = &zSource[nSrcLen+nOfft]; \r\n\t\tif( zOfft < zSource ){\r\n\t\t\t/* Invalid offset */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tnLen = (int)(&zSource[nSrcLen]-zOfft);\r\n\t\tnOfft = (int)(zOfft-zSource);\r\n\t}else if( nOfft >= nSrcLen ){\r\n\t\t/* Invalid offset */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}else{\r\n\t\tzOfft = &zSource[nOfft];\r\n\t\tnLen = nSrcLen - nOfft;\r\n\t}\r\n\tif( nArg > 3 ){\r\n\t\t/* Extract the length */\r\n\t\tnLen = jx9_value_to_int(apArg[3]);\r\n\t\tif( nLen < 1 ){\r\n\t\t\t/* Invalid  length */\r\n\t\t\tjx9_result_int(pCtx, 1);\r\n\t\t\treturn JX9_OK;\r\n\t\t}else if( nLen + nOfft > nSrcLen ){\r\n\t\t\t/* Invalid length */\r\n\t\t\tnLen = nSrcLen - nOfft;\r\n\t\t}\r\n\t\tif( nArg > 4 ){\r\n\t\t\t/* Case-sensitive or not */\r\n\t\t\tiCase = jx9_value_to_bool(apArg[4]);\r\n\t\t}\r\n\t}\r\n\t/* Perform the comparison */\r\n\tif( iCase ){\r\n\t\trc = SyStrnicmp(zOfft, zSub, (sxu32)nLen);\r\n\t}else{\r\n\t\trc = SyStrncmp(zOfft, zSub, (sxu32)nLen);\r\n\t}\r\n\t/* Comparison result */\r\n\tjx9_result_int(pCtx, rc);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int substr_count(string $haystack, string $needle[, int $offset = 0 [, int $length ]])\r\n *  Count the number of substring occurrences.\r\n * Parameters\r\n * $haystack\r\n *   The string to search in\r\n * $needle\r\n *   The substring to search for\r\n * $offset\r\n *  The offset where to start counting\r\n * $length (NOT USED)\r\n *  The maximum length after the specified offset to search for the substring.\r\n *  It outputs a warning if the offset plus the length is greater than the haystack length.\r\n * Return\r\n *  Toral number of substring occurrences.\r\n */\r\nstatic int jx9Builtin_substr_count(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zText, *zPattern, *zEnd;\r\n\tint nTextlen, nPatlen;\r\n\tint iCount = 0;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the haystack */\r\n\tzText = jx9_value_to_string(apArg[0], &nTextlen);\r\n\t/* Point to the neddle */\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatlen);\r\n\tif( nTextlen < 1 || nPatlen < 1 || nPatlen > nTextlen ){\r\n\t\t/* NOOP, return zero */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 2 ){\r\n\t\tint nOfft;\r\n\t\t/* Extract the offset */\r\n\t\tnOfft = jx9_value_to_int(apArg[2]);\r\n\t\tif( nOfft < 0 || nOfft > nTextlen ){\r\n\t\t\t/* Invalid offset, return zero */\r\n\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Point to the desired offset */\r\n\t\tzText = &zText[nOfft];\r\n\t\t/* Adjust length */\r\n\t\tnTextlen -= nOfft;\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zText[nTextlen];\r\n\tif( nArg > 3 ){\r\n\t\tint nLen;\r\n\t\t/* Extract the length */\r\n\t\tnLen = jx9_value_to_int(apArg[3]);\r\n\t\tif( nLen < 0 || nLen > nTextlen ){\r\n\t\t\t/* Invalid length, return 0 */\r\n\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Adjust pointer */\r\n\t\tnTextlen = nLen;\r\n\t\tzEnd = &zText[nTextlen];\r\n\t}\r\n\t/* Perform the search */\r\n\tfor(;;){\r\n\t\trc = SyBlobSearch((const void *)zText, (sxu32)(zEnd-zText), (const void *)zPattern, nPatlen, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Pattern not found, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Increment counter and update the offset */\r\n\t\tiCount++;\r\n\t\tzText += nOfft + nPatlen;\r\n\t\tif( zText >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t/* Pattern count */\r\n\tjx9_result_int(pCtx, iCount);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string chunk_split(string $body[, int $chunklen = 76 [, string $end = \"\\r\\n\" ]])\r\n *   Split a string into smaller chunks.\r\n * Parameters\r\n *  $body\r\n *   The string to be chunked.\r\n * $chunklen\r\n *   The chunk length.\r\n * $end\r\n *   The line ending sequence.\r\n * Return\r\n *  The chunked string or NULL on failure.\r\n */\r\nstatic int jx9Builtin_chunk_split(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zIn, *zEnd, *zSep = \"\\r\\n\";\r\n\tint nSepLen, nChunkLen, nLen;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Nothing to split, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* initialize/Extract arguments */\r\n\tnSepLen = (int)sizeof(\"\\r\\n\") - 1;\r\n\tnChunkLen = 76;\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tzEnd = &zIn[nLen];\r\n\tif( nArg > 1 ){\r\n\t\t/* Chunk length */\r\n\t\tnChunkLen = jx9_value_to_int(apArg[1]);\r\n\t\tif( nChunkLen < 1 ){\r\n\t\t\t/* Switch back to the default length */\r\n\t\t\tnChunkLen = 76;\r\n\t\t}\r\n\t\tif( nArg > 2 ){\r\n\t\t\t/* Separator */\r\n\t\t\tzSep = jx9_value_to_string(apArg[2], &nSepLen);\r\n\t\t\tif( nSepLen < 1 ){\r\n\t\t\t\t/* Switch back to the default separator */\r\n\t\t\t\tzSep = \"\\r\\n\";\r\n\t\t\t\tnSepLen = (int)sizeof(\"\\r\\n\") - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tif( nChunkLen > nLen ){\r\n\t\t/* Nothing to split, return the string and the separator */\r\n\t\tjx9_result_string_format(pCtx, \"%.*s%.*s\", nLen, zIn, nSepLen, zSep);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\twhile( zIn < zEnd ){\r\n\t\tif( nChunkLen > (int)(zEnd-zIn) ){\r\n\t\t\tnChunkLen = (int)(zEnd - zIn);\r\n\t\t}\r\n\t\t/* Append the chunk and the separator */\r\n\t\tjx9_result_string_format(pCtx, \"%.*s%.*s\", nChunkLen, zIn, nSepLen, zSep);\r\n\t\t/* Point beyond the chunk */\r\n\t\tzIn += nChunkLen;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string htmlspecialchars(string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $charset]])\r\n *  HTML escaping of special characters.\r\n *  The translations performed are:\r\n *   '&' (ampersand) ==> '&amp;'\r\n *   '\"' (double quote) ==> '&quot;' when ENT_NOQUOTES is not set.\r\n *   \"'\" (single quote) ==> '&#039;' only when ENT_QUOTES is set.\r\n *   '<' (less than) ==> '&lt;'\r\n *   '>' (greater than) ==> '&gt;'\r\n * Parameters\r\n *  $string\r\n *   The string being converted.\r\n * $flags\r\n *   A bitmask of one or more of the following flags, which specify how to handle quotes.\r\n *   The default is ENT_COMPAT | ENT_HTML401.\r\n *   ENT_COMPAT \tWill convert double-quotes and leave single-quotes alone.\r\n *   ENT_QUOTES \tWill convert both double and single quotes.\r\n *   ENT_NOQUOTES \tWill leave both double and single quotes unconverted.\r\n *   ENT_IGNORE \tSilently discard invalid code unit sequences instead of returning an empty string.\r\n * $charset\r\n *  Defines character set used in conversion. The default character set is ISO-8859-1. (Not used)\r\n * Return\r\n *  The escaped string or NULL on failure.\r\n */\r\nstatic int jx9Builtin_htmlspecialchars(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zCur, *zIn, *zEnd;\r\n\tint iFlags = 0x01|0x40; /* ENT_COMPAT | ENT_HTML401 */\r\n\tint nLen, c;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tzEnd = &zIn[nLen];\r\n\t/* Extract the flags if available */\r\n\tif( nArg > 1 ){\r\n\t\tiFlags = jx9_value_to_int(apArg[1]);\r\n\t\tif( iFlags < 0 ){\r\n\t\t\tiFlags = 0x01|0x40;\r\n\t\t}\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzCur = zIn;\r\n\t\twhile( zIn < zEnd && zIn[0] != '&' && zIn[0] != '\\'' && zIn[0] != '\"' && zIn[0] != '<' && zIn[0] != '>' ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Append the raw string verbatim */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zIn-zCur));\r\n\t\t}\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tc = zIn[0];\r\n\t\tif( c == '&' ){\r\n\t\t\t/* Expand '&amp;' */\r\n\t\t\tjx9_result_string(pCtx, \"&amp;\", (int)sizeof(\"&amp;\")-1);\r\n\t\t}else if( c == '<' ){\r\n\t\t\t/* Expand '&lt;' */\r\n\t\t\tjx9_result_string(pCtx, \"&lt;\", (int)sizeof(\"&lt;\")-1);\r\n\t\t}else if( c == '>' ){\r\n\t\t\t/* Expand '&gt;' */\r\n\t\t\tjx9_result_string(pCtx, \"&gt;\", (int)sizeof(\"&gt;\")-1);\r\n\t\t}else if( c == '\\'' ){\r\n\t\t\tif( iFlags & 0x02 /*ENT_QUOTES*/ ){\r\n\t\t\t\t/* Expand '&#039;' */\r\n\t\t\t\tjx9_result_string(pCtx, \"&#039;\", (int)sizeof(\"&#039;\")-1);\r\n\t\t\t}else{\r\n\t\t\t\t/* Leave the single quote untouched */\r\n\t\t\t\tjx9_result_string(pCtx, \"'\", (int)sizeof(char));\r\n\t\t\t}\r\n\t\t}else if( c == '\"' ){\r\n\t\t\tif( (iFlags & 0x04) == 0 /*ENT_NOQUOTES*/ ){\r\n\t\t\t\t/* Expand '&quot;' */\r\n\t\t\t\tjx9_result_string(pCtx, \"&quot;\", (int)sizeof(\"&quot;\")-1);\r\n\t\t\t}else{\r\n\t\t\t\t/* Leave the double quote untouched */\r\n\t\t\t\tjx9_result_string(pCtx, \"\\\"\", (int)sizeof(char));\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Ignore the unsafe HTML character */\r\n\t\tzIn++;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string htmlspecialchars_decode(string $string[, int $quote_style = ENT_COMPAT ])\r\n *  Unescape HTML entities.\r\n * Parameters\r\n *  $string\r\n *   The string to decode\r\n *  $quote_style\r\n *    The quote style. One of the following constants:\r\n *   ENT_COMPAT \tWill convert double-quotes and leave single-quotes alone (default)\r\n *   ENT_QUOTES \tWill convert both double and single quotes\r\n *   ENT_NOQUOTES \tWill leave both double and single quotes unconverted\r\n * Return\r\n *  The unescaped string or NULL on failure.\r\n */\r\nstatic int jx9Builtin_htmlspecialchars_decode(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zCur, *zIn, *zEnd;\r\n\tint iFlags = 0x01; /* ENT_COMPAT */\r\n\tint nLen, nJump;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tzEnd = &zIn[nLen];\r\n\t/* Extract the flags if available */\r\n\tif( nArg > 1 ){\r\n\t\tiFlags = jx9_value_to_int(apArg[1]);\r\n\t\tif( iFlags < 0 ){\r\n\t\t\tiFlags = 0x01;\r\n\t\t}\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzCur = zIn;\r\n\t\twhile( zIn < zEnd && zIn[0] != '&' ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Append the raw string verbatim */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zIn-zCur));\r\n\t\t}\r\n\t\tnLen = (int)(zEnd-zIn);\r\n\t\tnJump = (int)sizeof(char);\r\n\t\tif( nLen >= (int)sizeof(\"&amp;\")-1 && SyStrnicmp(zIn, \"&amp;\", sizeof(\"&amp;\")-1) == 0 ){\r\n\t\t\t/* &amp; ==> '&' */\r\n\t\t\tjx9_result_string(pCtx, \"&\", (int)sizeof(char));\r\n\t\t\tnJump = (int)sizeof(\"&amp;\")-1;\r\n\t\t}else if( nLen >= (int)sizeof(\"&lt;\")-1 && SyStrnicmp(zIn, \"&lt;\", sizeof(\"&lt;\")-1) == 0 ){\r\n\t\t\t/* &lt; ==> < */\r\n\t\t\tjx9_result_string(pCtx, \"<\", (int)sizeof(char));\r\n\t\t\tnJump = (int)sizeof(\"&lt;\")-1; \r\n\t\t}else if( nLen >= (int)sizeof(\"&gt;\")-1 && SyStrnicmp(zIn, \"&gt;\", sizeof(\"&gt;\")-1) == 0 ){\r\n\t\t\t/* &gt; ==> '>' */\r\n\t\t\tjx9_result_string(pCtx, \">\", (int)sizeof(char));\r\n\t\t\tnJump = (int)sizeof(\"&gt;\")-1; \r\n\t\t}else if( nLen >= (int)sizeof(\"&quot;\")-1 && SyStrnicmp(zIn, \"&quot;\", sizeof(\"&quot;\")-1) == 0 ){\r\n\t\t\t/* &quot; ==> '\"' */\r\n\t\t\tif( (iFlags & 0x04) == 0 /*ENT_NOQUOTES*/ ){\r\n\t\t\t\tjx9_result_string(pCtx, \"\\\"\", (int)sizeof(char));\r\n\t\t\t}else{\r\n\t\t\t\t/* Leave untouched */\r\n\t\t\t\tjx9_result_string(pCtx, \"&quot;\", (int)sizeof(\"&quot;\")-1);\r\n\t\t\t}\r\n\t\t\tnJump = (int)sizeof(\"&quot;\")-1;\r\n\t\t}else if( nLen >= (int)sizeof(\"&#039;\")-1 && SyStrnicmp(zIn, \"&#039;\", sizeof(\"&#039;\")-1) == 0 ){\r\n\t\t\t/* &#039; ==> ''' */\r\n\t\t\tif( iFlags & 0x02 /*ENT_QUOTES*/ ){\r\n\t\t\t\t/* Expand ''' */\r\n\t\t\t\tjx9_result_string(pCtx, \"'\", (int)sizeof(char));\r\n\t\t\t}else{\r\n\t\t\t\t/* Leave untouched */\r\n\t\t\t\tjx9_result_string(pCtx, \"&#039;\", (int)sizeof(\"&#039;\")-1);\r\n\t\t\t}\r\n\t\t\tnJump = (int)sizeof(\"&#039;\")-1;\r\n\t\t}else if( nLen >= (int)sizeof(char) ){\r\n\t\t\t/* expand '&' */\r\n\t\t\tjx9_result_string(pCtx, \"&\", (int)sizeof(char));\r\n\t\t}else{\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzIn += nJump;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/* HTML encoding/Decoding table \r\n * Source: Symisc RunTime API.[chm@symisc.net]\r\n */\r\nstatic const char *azHtmlEscape[] = {\r\n \t\"&lt;\", \"<\", \"&gt;\", \">\", \"&amp;\", \"&\", \"&quot;\", \"\\\"\", \"&#39;\", \"'\", \r\n\t\"&#33;\", \"!\", \"&#36;\", \"$\", \"&#35;\", \"#\", \"&#37;\", \"%\", \"&#40;\", \"(\", \r\n\t\"&#41;\", \")\", \"&#123;\", \"{\", \"&#125;\", \"}\", \"&#61;\", \"=\", \"&#43;\", \"+\", \r\n\t\"&#63;\", \"?\", \"&#91;\", \"[\", \"&#93;\", \"]\", \"&#64;\", \"@\", \"&#44;\", \",\" \r\n };\r\n/*\r\n * array get_html_translation_table(void)\r\n *  Returns the translation table used by htmlspecialchars() and htmlentities().\r\n * Parameters\r\n *  None\r\n * Return\r\n *  The translation table as an array or NULL on failure.\r\n */\r\nstatic int jx9Builtin_get_html_translation_table(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tjx9_value *pArray, *pValue;\r\n\tsxu32 n;\r\n\t/* Element value */\r\n\tpValue = jx9_context_new_scalar(pCtx);\r\n\tif( pValue == 0 ){\r\n\t\tSXUNUSED(nArg); /* cc warning */\r\n\t\tSXUNUSED(apArg);\r\n\t\t/* Return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Create a new array */\r\n\tpArray = jx9_context_new_array(pCtx);\r\n\tif( pArray == 0 ){\r\n\t\t/* Return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Make the table */\r\n\tfor( n = 0 ; n < SX_ARRAYSIZE(azHtmlEscape) ; n += 2 ){\r\n\t\t/* Prepare the value */\r\n\t\tjx9_value_string(pValue, azHtmlEscape[n], -1 /* Compute length automatically */);\r\n\t\t/* Insert the value */\r\n\t\tjx9_array_add_strkey_elem(pArray, azHtmlEscape[n+1], pValue);\r\n\t\t/* Reset the string cursor */\r\n\t\tjx9_value_reset_string_cursor(pValue);\r\n\t}\r\n\t/* \r\n\t * Return the array.\r\n\t * Don't worry about freeing memory, everything will be automatically\r\n\t * released upon we return from this function.\r\n\t */\r\n\tjx9_result_value(pCtx, pArray);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string htmlentities( string $string [, int $flags = ENT_COMPAT | ENT_HTML401]);\r\n *   Convert all applicable characters to HTML entities\r\n * Parameters\r\n * $string\r\n *   The input string.\r\n * $flags\r\n *  A bitmask of one or more of the flags (see block-comment on jx9Builtin_htmlspecialchars())\r\n * Return\r\n * The encoded string.\r\n */\r\nstatic int jx9Builtin_htmlentities(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iFlags = 0x01; /* ENT_COMPAT */\r\n\tconst char *zIn, *zEnd;\r\n\tint nLen, c;\r\n\tsxu32 n;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tzEnd = &zIn[nLen];\r\n\t/* Extract the flags if available */\r\n\tif( nArg > 1 ){\r\n\t\tiFlags = jx9_value_to_int(apArg[1]);\r\n\t\tif( iFlags < 0 ){\r\n\t\t\tiFlags = 0x01;\r\n\t\t}\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tc = zIn[0];\r\n\t\t/* Perform a linear lookup on the decoding table */\r\n\t\tfor( n = 0 ; n < SX_ARRAYSIZE(azHtmlEscape) ; n += 2 ){\r\n\t\t\tif( azHtmlEscape[n+1][0] == c ){\r\n\t\t\t\t/* Got one */\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( n < SX_ARRAYSIZE(azHtmlEscape) ){\r\n\t\t\t/* Output the safe sequence [i.e: '<' ==> '&lt;\"] */\r\n\t\t\tif( c == '\"' && (iFlags & 0x04) /*ENT_NOQUOTES*/ ){\r\n\t\t\t\t/* Expand the double quote verbatim */\r\n\t\t\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\t\t}else if(c == '\\'' && ((iFlags & 0x02 /*ENT_QUOTES*/) == 0 || (iFlags & 0x04) /*ENT_NOQUOTES*/) ){\r\n\t\t\t\t/* expand single quote verbatim */\r\n\t\t\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\t\t}else{\r\n\t\t\t\tjx9_result_string(pCtx, azHtmlEscape[n], -1/*Compute length automatically */);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t/* Output character verbatim */\r\n\t\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\t}\r\n\t\tzIn++;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string html_entity_decode(string $string [, int $quote_style = ENT_COMPAT [, string $charset = 'UTF-8' ]])\r\n *   Perform the reverse operation of html_entity_decode().\r\n * Parameters\r\n * $string\r\n *   The input string.\r\n * $flags\r\n *  A bitmask of one or more of the flags (see comment on jx9Builtin_htmlspecialchars())\r\n * Return\r\n * The decoded string.\r\n */\r\nstatic int jx9Builtin_html_entity_decode(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zCur, *zIn, *zEnd;\r\n\tint iFlags = 0x01; /* ENT_COMPAT  */\r\n\tint nLen;\r\n\tsxu32 n;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tzEnd = &zIn[nLen];\r\n\t/* Extract the flags if available */\r\n\tif( nArg > 1 ){\r\n\t\tiFlags = jx9_value_to_int(apArg[1]);\r\n\t\tif( iFlags < 0 ){\r\n\t\t\tiFlags = 0x01;\r\n\t\t}\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzCur = zIn;\r\n\t\twhile( zIn < zEnd && zIn[0] != '&' ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Append raw string verbatim */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zIn-zCur));\r\n\t\t}\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tnLen = (int)(zEnd-zIn);\r\n\t\t/* Find an encoded sequence */\r\n\t\tfor(n = 0 ; n < SX_ARRAYSIZE(azHtmlEscape) ; n += 2 ){\r\n\t\t\tint iLen = (int)SyStrlen(azHtmlEscape[n]);\r\n\t\t\tif( nLen >= iLen && SyStrnicmp(zIn, azHtmlEscape[n], (sxu32)iLen) == 0 ){\r\n\t\t\t\t/* Got one */\r\n\t\t\t\tzIn += iLen;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( n < SX_ARRAYSIZE(azHtmlEscape) ){\r\n\t\t\tint c = azHtmlEscape[n+1][0];\r\n\t\t\t/* Output the decoded character */\r\n\t\t\tif( c == '\\'' && ((iFlags & 0x02) == 0 /*ENT_QUOTES*/|| (iFlags & 0x04) /*ENT_NOQUOTES*/)  ){\r\n\t\t\t\t/* Do not process single quotes */\r\n\t\t\t\tjx9_result_string(pCtx, azHtmlEscape[n], -1);\r\n\t\t\t}else if( c == '\"' && (iFlags & 0x04) /*ENT_NOQUOTES*/ ){\r\n\t\t\t\t/* Do not process double quotes */\r\n\t\t\t\tjx9_result_string(pCtx, azHtmlEscape[n], -1);\r\n\t\t\t}else{\r\n\t\t\t\tjx9_result_string(pCtx, azHtmlEscape[n+1], -1); /* Compute length automatically */\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t/* Append '&' */\r\n\t\t\tjx9_result_string(pCtx, \"&\", (int)sizeof(char));\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strlen($string)\r\n *  return the length of the given string.\r\n * Parameter\r\n *  string: The string being measured for length.\r\n * Return\r\n *  length of the given string.\r\n */\r\nstatic int jx9Builtin_strlen(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iLen = 0;\r\n\tif( nArg > 0 ){\r\n\t\tjx9_value_to_string(apArg[0], &iLen);\r\n\t}\r\n\t/* String length */\r\n\tjx9_result_int(pCtx, iLen);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strcmp(string $str1, string $str2)\r\n *  Perform a binary safe string comparison.\r\n * Parameter\r\n *  str1: The first string\r\n *  str2: The second string\r\n * Return\r\n *  Returns < 0 if str1 is less than str2; > 0 if str1 is greater \r\n *  than str2, and 0 if they are equal.\r\n */\r\nstatic int jx9Builtin_strcmp(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *z1, *z2;\r\n\tint n1, n2;\r\n\tint res;\r\n\tif( nArg < 2 ){\r\n\t\tres = nArg == 0 ? 0 : 1;\r\n\t\tjx9_result_int(pCtx, res);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the comparison */\r\n\tz1 = jx9_value_to_string(apArg[0], &n1);\r\n\tz2 = jx9_value_to_string(apArg[1], &n2);\r\n\tres = SyStrncmp(z1, z2, (sxu32)(SXMAX(n1, n2)));\r\n\t/* Comparison result */\r\n\tjx9_result_int(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strncmp(string $str1, string $str2, int n)\r\n *  Perform a binary safe string comparison of the first n characters.\r\n * Parameter\r\n *  str1: The first string\r\n *  str2: The second string\r\n * Return\r\n *  Returns < 0 if str1 is less than str2; > 0 if str1 is greater \r\n *  than str2, and 0 if they are equal.\r\n */\r\nstatic int jx9Builtin_strncmp(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *z1, *z2;\r\n\tint res;\r\n\tint n;\r\n\tif( nArg < 3 ){\r\n\t\t/* Perform a standard comparison */\r\n\t\treturn jx9Builtin_strcmp(pCtx, nArg, apArg);\r\n\t}\r\n\t/* Desired comparison length */\r\n\tn  = jx9_value_to_int(apArg[2]);\r\n\tif( n < 0 ){\r\n\t\t/* Invalid length */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the comparison */\r\n\tz1 = jx9_value_to_string(apArg[0], 0);\r\n\tz2 = jx9_value_to_string(apArg[1], 0);\r\n\tres = SyStrncmp(z1, z2, (sxu32)n);\r\n\t/* Comparison result */\r\n\tjx9_result_int(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strcasecmp(string $str1, string $str2, int n)\r\n *  Perform a binary safe case-insensitive string comparison.\r\n * Parameter\r\n *  str1: The first string\r\n *  str2: The second string\r\n * Return\r\n *  Returns < 0 if str1 is less than str2; > 0 if str1 is greater \r\n *  than str2, and 0 if they are equal.\r\n */\r\nstatic int jx9Builtin_strcasecmp(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *z1, *z2;\r\n\tint n1, n2;\r\n\tint res;\r\n\tif( nArg < 2 ){\r\n\t\tres = nArg == 0 ? 0 : 1;\r\n\t\tjx9_result_int(pCtx, res);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the comparison */\r\n\tz1 = jx9_value_to_string(apArg[0], &n1);\r\n\tz2 = jx9_value_to_string(apArg[1], &n2);\r\n\tres = SyStrnicmp(z1, z2, (sxu32)(SXMAX(n1, n2)));\r\n\t/* Comparison result */\r\n\tjx9_result_int(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strncasecmp(string $str1, string $str2, int n)\r\n *  Perform a binary safe case-insensitive string comparison of the first n characters.\r\n * Parameter\r\n *  $str1: The first string\r\n *  $str2: The second string\r\n *  $len:  The length of strings to be used in the comparison.\r\n * Return\r\n *  Returns < 0 if str1 is less than str2; > 0 if str1 is greater \r\n *  than str2, and 0 if they are equal.\r\n */\r\nstatic int jx9Builtin_strncasecmp(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *z1, *z2;\r\n\tint res;\r\n\tint n;\r\n\tif( nArg < 3 ){\r\n\t\t/* Perform a standard comparison */\r\n\t\treturn jx9Builtin_strcasecmp(pCtx, nArg, apArg);\r\n\t}\r\n\t/* Desired comparison length */\r\n\tn  = jx9_value_to_int(apArg[2]);\r\n\tif( n < 0 ){\r\n\t\t/* Invalid length */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the comparison */\r\n\tz1 = jx9_value_to_string(apArg[0], 0);\r\n\tz2 = jx9_value_to_string(apArg[1], 0);\r\n\tres = SyStrnicmp(z1, z2, (sxu32)n);\r\n\t/* Comparison result */\r\n\tjx9_result_int(pCtx, res);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Implode context [i.e: it's private data].\r\n * A pointer to the following structure is forwarded\r\n * verbatim to the array walker callback defined below.\r\n */\r\nstruct implode_data {\r\n\tjx9_context *pCtx;    /* Call context */\r\n\tint bRecursive;       /* TRUE if recursive implode [this is a symisc eXtension] */\r\n\tconst char *zSep;     /* Arguments separator if any */\r\n\tint nSeplen;          /* Separator length */\r\n\tint bFirst;           /* TRUE if first call */\r\n\tint nRecCount;        /* Recursion count to avoid infinite loop */\r\n};\r\n/*\r\n * Implode walker callback for the [jx9_array_walk()] interface.\r\n * The following routine is invoked for each array entry passed\r\n * to the implode() function.\r\n */\r\nstatic int implode_callback(jx9_value *pKey, jx9_value *pValue, void *pUserData)\r\n{\r\n\tstruct implode_data *pData = (struct implode_data *)pUserData;\r\n\tconst char *zData;\r\n\tint nLen;\r\n\tif( pData->bRecursive && jx9_value_is_json_array(pValue) && pData->nRecCount < 32 ){\r\n\t\tif( pData->nSeplen > 0 ){\r\n\t\t\tif( !pData->bFirst ){\r\n\t\t\t\t/* append the separator first */\r\n\t\t\t\tjx9_result_string(pData->pCtx, pData->zSep, pData->nSeplen);\r\n\t\t\t}else{\r\n\t\t\t\tpData->bFirst = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Recurse */\r\n\t\tpData->bFirst = 1;\r\n\t\tpData->nRecCount++;\r\n\t\tjx9HashmapWalk((jx9_hashmap *)pValue->x.pOther, implode_callback, pData);\r\n\t\tpData->nRecCount--;\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string representation of the entry value */\r\n\tzData = jx9_value_to_string(pValue, &nLen);\r\n\tif( nLen > 0 ){\r\n\t\tif( pData->nSeplen > 0 ){\r\n\t\t\tif( !pData->bFirst ){\r\n\t\t\t\t/* append the separator first */\r\n\t\t\t\tjx9_result_string(pData->pCtx, pData->zSep, pData->nSeplen);\r\n\t\t\t}else{\r\n\t\t\t\tpData->bFirst = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tjx9_result_string(pData->pCtx, zData, nLen);\r\n\t}else{\r\n\t\tSXUNUSED(pKey); /* cc warning */\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string implode(string $glue, array $pieces, ...)\r\n * string implode(array $pieces, ...)\r\n *  Join array elements with a string.\r\n * $glue\r\n *   Defaults to an empty string. This is not the preferred usage of implode() as glue\r\n *   would be the second parameter and thus, the bad prototype would be used.\r\n * $pieces\r\n *   The array of strings to implode.\r\n * Return\r\n *  Returns a string containing a string representation of all the array elements in the same\r\n *  order, with the glue string between each element. \r\n */\r\nstatic int jx9Builtin_implode(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tstruct implode_data imp_data;\r\n\tint i = 1;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Prepare the implode context */\r\n\timp_data.pCtx = pCtx;\r\n\timp_data.bRecursive = 0;\r\n\timp_data.bFirst = 1;\r\n\timp_data.nRecCount = 0;\r\n\tif( !jx9_value_is_json_array(apArg[0]) ){\r\n\t\timp_data.zSep = jx9_value_to_string(apArg[0], &imp_data.nSeplen);\r\n\t}else{\r\n\t\timp_data.zSep = 0;\r\n\t\timp_data.nSeplen = 0;\r\n\t\ti = 0;\r\n\t}\r\n\tjx9_result_string(pCtx, \"\", 0); /* Set an empty stirng */\r\n\t/* Start the 'join' process */\r\n\twhile( i < nArg ){\r\n\t\tif( jx9_value_is_json_array(apArg[i]) ){\r\n\t\t\t/* Iterate throw array entries */\r\n\t\t\tjx9_array_walk(apArg[i], implode_callback, &imp_data);\r\n\t\t}else{\r\n\t\t\tconst char *zData;\r\n\t\t\tint nLen;\r\n\t\t\t/* Extract the string representation of the jx9 value */\r\n\t\t\tzData = jx9_value_to_string(apArg[i], &nLen);\r\n\t\t\tif( nLen > 0 ){\r\n\t\t\t\tif( imp_data.nSeplen > 0 ){\r\n\t\t\t\t\tif( !imp_data.bFirst ){\r\n\t\t\t\t\t\t/* append the separator first */\r\n\t\t\t\t\t\tjx9_result_string(pCtx, imp_data.zSep, imp_data.nSeplen);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\timp_data.bFirst = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tjx9_result_string(pCtx, zData, nLen);\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string implode_recursive(string $glue, array $pieces, ...)\r\n * Purpose\r\n *  Same as implode() but recurse on arrays.\r\n * Example:\r\n *   $a = array('usr', array('home', 'dean'));\r\n *   print implode_recursive(\"/\", $a);\r\n *   Will output\r\n *     usr/home/dean.\r\n *   While the standard implode would produce.\r\n *    usr/Array.\r\n * Parameter\r\n *  Refer to implode().\r\n * Return\r\n *  Refer to implode().\r\n */\r\nstatic int jx9Builtin_implode_recursive(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tstruct implode_data imp_data;\r\n\tint i = 1;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Prepare the implode context */\r\n\timp_data.pCtx = pCtx;\r\n\timp_data.bRecursive = 1;\r\n\timp_data.bFirst = 1;\r\n\timp_data.nRecCount = 0;\r\n\tif( !jx9_value_is_json_array(apArg[0]) ){\r\n\t\timp_data.zSep = jx9_value_to_string(apArg[0], &imp_data.nSeplen);\r\n\t}else{\r\n\t\timp_data.zSep = 0;\r\n\t\timp_data.nSeplen = 0;\r\n\t\ti = 0;\r\n\t}\r\n\tjx9_result_string(pCtx, \"\", 0); /* Set an empty stirng */\r\n\t/* Start the 'join' process */\r\n\twhile( i < nArg ){\r\n\t\tif( jx9_value_is_json_array(apArg[i]) ){\r\n\t\t\t/* Iterate throw array entries */\r\n\t\t\tjx9_array_walk(apArg[i], implode_callback, &imp_data);\r\n\t\t}else{\r\n\t\t\tconst char *zData;\r\n\t\t\tint nLen;\r\n\t\t\t/* Extract the string representation of the jx9 value */\r\n\t\t\tzData = jx9_value_to_string(apArg[i], &nLen);\r\n\t\t\tif( nLen > 0 ){\r\n\t\t\t\tif( imp_data.nSeplen > 0 ){\r\n\t\t\t\t\tif( !imp_data.bFirst ){\r\n\t\t\t\t\t\t/* append the separator first */\r\n\t\t\t\t\t\tjx9_result_string(pCtx, imp_data.zSep, imp_data.nSeplen);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\timp_data.bFirst = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tjx9_result_string(pCtx, zData, nLen);\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * array explode(string $delimiter, string $string[, int $limit ])\r\n *  Returns an array of strings, each of which is a substring of string \r\n *  formed by splitting it on boundaries formed by the string delimiter. \r\n * Parameters\r\n *  $delimiter\r\n *   The boundary string.\r\n * $string\r\n *   The input string.\r\n * $limit\r\n *   If limit is set and positive, the returned array will contain a maximum\r\n *   of limit elements with the last element containing the rest of string.\r\n *   If the limit parameter is negative, all fields except the last -limit are returned.\r\n *   If the limit parameter is zero, then this is treated as 1.\r\n * Returns\r\n *  Returns an array of strings created by splitting the string parameter\r\n *  on boundaries formed by the delimiter.\r\n *  If delimiter is an empty string (\"\"), explode() will return FALSE. \r\n *  If delimiter contains a value that is not contained in string and a negative\r\n *  limit is used, then an empty array will be returned, otherwise an array containing string\r\n *  will be returned. \r\n * NOTE:\r\n *  Negative limit is not supported.\r\n */\r\nstatic int jx9Builtin_explode(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zDelim, *zString, *zCur, *zEnd;\r\n\tint nDelim, nStrlen, iLimit;\r\n\tjx9_value *pArray;\r\n\tjx9_value *pValue;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the delimiter */\r\n\tzDelim = jx9_value_to_string(apArg[0], &nDelim);\r\n\tif( nDelim < 1 ){\r\n\t\t/* Empty delimiter, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string */\r\n\tzString = jx9_value_to_string(apArg[1], &nStrlen);\r\n\tif( nStrlen < 1 ){\r\n\t\t/* Empty delimiter, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zString[nStrlen];\r\n\t/* Create the array */\r\n\tpArray =  jx9_context_new_array(pCtx);\r\n\tpValue = jx9_context_new_scalar(pCtx);\r\n\tif( pArray == 0 || pValue == 0 ){\r\n\t\t/* Out of memory, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Set a defualt limit */\r\n\tiLimit = SXI32_HIGH;\r\n\tif( nArg > 2 ){\r\n\t\tiLimit = jx9_value_to_int(apArg[2]);\r\n\t\t if( iLimit < 0 ){\r\n\t\t\tiLimit = -iLimit;\r\n\t\t}\r\n\t\tif( iLimit == 0 ){\r\n\t\t\tiLimit = 1;\r\n\t\t}\r\n\t\tiLimit--;\r\n\t}\r\n\t/* Start exploding */\r\n\tfor(;;){\r\n\t\tif( zString >= zEnd ){\r\n\t\t\t/* No more entry to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\trc = SyBlobSearch(zString, (sxu32)(zEnd-zString), zDelim, nDelim, &nOfft);\r\n\t\tif( rc != SXRET_OK || iLimit <= (int)jx9_array_count(pArray) ){\r\n\t\t\t/* Limit reached, insert the rest of the string and break */\r\n\t\t\tif( zEnd > zString ){\r\n\t\t\t\tjx9_value_string(pValue, zString, (int)(zEnd-zString));\r\n\t\t\t\tjx9_array_add_elem(pArray, 0/* Automatic index assign*/, pValue);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Point to the desired offset */\r\n\t\tzCur = &zString[nOfft];\r\n\t\tif( zCur > zString ){\r\n\t\t\t/* Perform the store operation */\r\n\t\t\tjx9_value_string(pValue, zString, (int)(zCur-zString));\r\n\t\t\tjx9_array_add_elem(pArray, 0/* Automatic index assign*/, pValue);\r\n\t\t}\r\n\t\t/* Point beyond the delimiter */\r\n\t\tzString = &zCur[nDelim];\r\n\t\t/* Reset the cursor */\r\n\t\tjx9_value_reset_string_cursor(pValue);\r\n\t}\r\n\t/* Return the freshly created array */\r\n\tjx9_result_value(pCtx, pArray);\r\n\t/* NOTE that every allocated jx9_value will be automatically \r\n\t * released as soon we return from this foregin function.\r\n\t */\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string trim(string $str[, string $charlist ])\r\n *  Strip whitespace (or other characters) from the beginning and end of a string.\r\n * Parameters\r\n *  $str\r\n *   The string that will be trimmed.\r\n * $charlist\r\n *   Optionally, the stripped characters can also be specified using the charlist parameter.\r\n *   Simply list all characters that you want to be stripped.\r\n *   With .. you can specify a range of characters.\r\n * Returns.\r\n *  Thr processed string.\r\n */\r\nstatic int jx9Builtin_trim(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Start the trim process */\r\n\tif( nArg < 2 ){\r\n\t\tSyString sStr;\r\n\t\t/* Remove white spaces and NUL bytes */\r\n\t\tSyStringInitFromBuf(&sStr, zString, nLen);\r\n\t\tSyStringFullTrimSafe(&sStr);\r\n\t\tjx9_result_string(pCtx, sStr.zString, (int)sStr.nByte);\r\n\t}else{\r\n\t\t/* Char list */\r\n\t\tconst char *zList;\r\n\t\tint nListlen;\r\n\t\tzList = jx9_value_to_string(apArg[1], &nListlen);\r\n\t\tif( nListlen < 1 ){\r\n\t\t\t/* Return the string unchanged */\r\n\t\t\tjx9_result_string(pCtx, zString, nLen);\r\n\t\t}else{\r\n\t\t\tconst char *zEnd = &zString[nLen];\r\n\t\t\tconst char *zCur = zString;\r\n\t\t\tconst char *zPtr;\r\n\t\t\tint i;\r\n\t\t\t/* Left trim */\r\n\t\t\tfor(;;){\r\n\t\t\t\tif( zCur >= zEnd ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tzPtr = zCur;\r\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\r\n\t\t\t\t\tif( zCur < zEnd && zCur[0] == zList[i] ){\r\n\t\t\t\t\t\tzCur++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( zCur == zPtr ){\r\n\t\t\t\t\t/* No match, break immediately */\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* Right trim */\r\n\t\t\tzEnd--;\r\n\t\t\tfor(;;){\r\n\t\t\t\tif( zEnd <= zCur ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tzPtr = zEnd;\r\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\r\n\t\t\t\t\tif( zEnd > zCur && zEnd[0] == zList[i] ){\r\n\t\t\t\t\t\tzEnd--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( zEnd == zPtr ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( zCur >= zEnd ){\r\n\t\t\t\t/* Return the empty string */\r\n\t\t\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\t\t}else{\r\n\t\t\t\tzEnd++;\r\n\t\t\t\tjx9_result_string(pCtx, zCur, (int)(zEnd-zCur));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string rtrim(string $str[, string $charlist ])\r\n *  Strip whitespace (or other characters) from the end of a string.\r\n * Parameters\r\n *  $str\r\n *   The string that will be trimmed.\r\n * $charlist\r\n *   Optionally, the stripped characters can also be specified using the charlist parameter.\r\n *   Simply list all characters that you want to be stripped.\r\n *   With .. you can specify a range of characters.\r\n * Returns.\r\n *  Thr processed string.\r\n */\r\nstatic int jx9Builtin_rtrim(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Start the trim process */\r\n\tif( nArg < 2 ){\r\n\t\tSyString sStr;\r\n\t\t/* Remove white spaces and NUL bytes*/\r\n\t\tSyStringInitFromBuf(&sStr, zString, nLen);\r\n\t\tSyStringRightTrimSafe(&sStr);\r\n\t\tjx9_result_string(pCtx, sStr.zString, (int)sStr.nByte);\r\n\t}else{\r\n\t\t/* Char list */\r\n\t\tconst char *zList;\r\n\t\tint nListlen;\r\n\t\tzList = jx9_value_to_string(apArg[1], &nListlen);\r\n\t\tif( nListlen < 1 ){\r\n\t\t\t/* Return the string unchanged */\r\n\t\t\tjx9_result_string(pCtx, zString, nLen);\r\n\t\t}else{\r\n\t\t\tconst char *zEnd = &zString[nLen - 1];\r\n\t\t\tconst char *zCur = zString;\r\n\t\t\tconst char *zPtr;\r\n\t\t\tint i;\r\n\t\t\t/* Right trim */\r\n\t\t\tfor(;;){\r\n\t\t\t\tif( zEnd <= zCur ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tzPtr = zEnd;\r\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\r\n\t\t\t\t\tif( zEnd > zCur && zEnd[0] == zList[i] ){\r\n\t\t\t\t\t\tzEnd--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( zEnd == zPtr ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( zEnd <= zCur ){\r\n\t\t\t\t/* Return the empty string */\r\n\t\t\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\t\t}else{\r\n\t\t\t\tzEnd++;\r\n\t\t\t\tjx9_result_string(pCtx, zCur, (int)(zEnd-zCur));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string ltrim(string $str[, string $charlist ])\r\n *  Strip whitespace (or other characters) from the beginning and end of a string.\r\n * Parameters\r\n *  $str\r\n *   The string that will be trimmed.\r\n * $charlist\r\n *   Optionally, the stripped characters can also be specified using the charlist parameter.\r\n *   Simply list all characters that you want to be stripped.\r\n *   With .. you can specify a range of characters.\r\n * Returns.\r\n *  The processed string.\r\n */\r\nstatic int jx9Builtin_ltrim(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Start the trim process */\r\n\tif( nArg < 2 ){\r\n\t\tSyString sStr;\r\n\t\t/* Remove white spaces and NUL byte */\r\n\t\tSyStringInitFromBuf(&sStr, zString, nLen);\r\n\t\tSyStringLeftTrimSafe(&sStr);\r\n\t\tjx9_result_string(pCtx, sStr.zString, (int)sStr.nByte);\r\n\t}else{\r\n\t\t/* Char list */\r\n\t\tconst char *zList;\r\n\t\tint nListlen;\r\n\t\tzList = jx9_value_to_string(apArg[1], &nListlen);\r\n\t\tif( nListlen < 1 ){\r\n\t\t\t/* Return the string unchanged */\r\n\t\t\tjx9_result_string(pCtx, zString, nLen);\r\n\t\t}else{\r\n\t\t\tconst char *zEnd = &zString[nLen];\r\n\t\t\tconst char *zCur = zString;\r\n\t\t\tconst char *zPtr;\r\n\t\t\tint i;\r\n\t\t\t/* Left trim */\r\n\t\t\tfor(;;){\r\n\t\t\t\tif( zCur >= zEnd ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tzPtr = zCur;\r\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\r\n\t\t\t\t\tif( zCur < zEnd && zCur[0] == zList[i] ){\r\n\t\t\t\t\t\tzCur++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif( zCur == zPtr ){\r\n\t\t\t\t\t/* No match, break immediately */\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( zCur >= zEnd ){\r\n\t\t\t\t/* Return the empty string */\r\n\t\t\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\t\t}else{\r\n\t\t\t\tjx9_result_string(pCtx, zCur, (int)(zEnd-zCur));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strtolower(string $str)\r\n *  Make a string lowercase.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * Returns.\r\n *  The lowercased string.\r\n */\r\nstatic int jx9Builtin_strtolower(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zCur, *zEnd;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tzEnd = &zString[nLen];\r\n\tfor(;;){\r\n\t\tif( zString >= zEnd ){\r\n\t\t\t/* No more input, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif( (unsigned char)zString[0] >= 0xc0 ){\r\n\t\t\t/* UTF-8 stream, output verbatim */\r\n\t\t\tzCur = zString;\r\n\t\t\tzString++;\r\n\t\t\twhile( zString < zEnd && ((unsigned char)zString[0] & 0xc0) == 0x80){\r\n\t\t\t\tzString++;\r\n\t\t\t}\r\n\t\t\t/* Append UTF-8 stream */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zString-zCur));\r\n\t\t}else{\r\n\t\t\tint c = zString[0];\r\n\t\t\tif( SyisUpper(c) ){\r\n\t\t\t\tc = SyToLower(zString[0]);\r\n\t\t\t}\r\n\t\t\t/* Append character */\r\n\t\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\t\t/* Advance the cursor */\r\n\t\t\tzString++;\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strtolower(string $str)\r\n *  Make a string uppercase.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * Returns.\r\n *  The uppercased string.\r\n */\r\nstatic int jx9Builtin_strtoupper(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zCur, *zEnd;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tzEnd = &zString[nLen];\r\n\tfor(;;){\r\n\t\tif( zString >= zEnd ){\r\n\t\t\t/* No more input, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif( (unsigned char)zString[0] >= 0xc0 ){\r\n\t\t\t/* UTF-8 stream, output verbatim */\r\n\t\t\tzCur = zString;\r\n\t\t\tzString++;\r\n\t\t\twhile( zString < zEnd && ((unsigned char)zString[0] & 0xc0) == 0x80){\r\n\t\t\t\tzString++;\r\n\t\t\t}\r\n\t\t\t/* Append UTF-8 stream */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zString-zCur));\r\n\t\t}else{\r\n\t\t\tint c = zString[0];\r\n\t\t\tif( SyisLower(c) ){\r\n\t\t\t\tc = SyToUpper(zString[0]);\r\n\t\t\t}\r\n\t\t\t/* Append character */\r\n\t\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\t\t/* Advance the cursor */\r\n\t\t\tzString++;\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int ord(string $string)\r\n *  Returns the ASCII value of the first character of string.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * Returns.\r\n *  The ASCII value as an integer.\r\n */\r\nstatic int jx9Builtin_ord(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tint nLen, c;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return -1 */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return -1 */\r\n\t\tjx9_result_int(pCtx, -1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the ASCII value of the first character */\r\n\tc = zString[0];\r\n\t/* Return that value */\r\n\tjx9_result_int(pCtx, c);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string chr(int $ascii)\r\n *  Returns a one-character string containing the character specified by ascii.\r\n * Parameters\r\n *  $ascii\r\n *   The ascii code.\r\n * Returns.\r\n *  The specified character.\r\n */\r\nstatic int jx9Builtin_chr(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint c;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the ASCII value */\r\n\tc = jx9_value_to_int(apArg[0]);\r\n\t/* Return the specified character */\r\n\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Binary to hex consumer callback.\r\n * This callback is the default consumer used by the hash functions\r\n * [i.e: bin2hex(), md5(), sha1(), md5_file() ... ] defined below.\r\n */\r\nstatic int HashConsumer(const void *pData, unsigned int nLen, void *pUserData)\r\n{\r\n\t/* Append hex chunk verbatim */\r\n\tjx9_result_string((jx9_context *)pUserData, (const char *)pData, (int)nLen);\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * string bin2hex(string $str)\r\n *  Convert binary data into hexadecimal representation.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * Returns.\r\n *  Returns the hexadecimal representation of the given string.\r\n */\r\nstatic int jx9Builtin_bin2hex(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tSyBinToHexConsumer((const void *)zString, (sxu32)nLen, HashConsumer, pCtx);\r\n\treturn JX9_OK;\r\n}\r\n/* Search callback signature */\r\ntypedef sxi32 (*ProcStringMatch)(const void *, sxu32, const void *, sxu32, sxu32 *);\r\n/*\r\n * Case-insensitive pattern match.\r\n * Brute force is the default search method used here.\r\n * This is due to the fact that brute-forcing works quite\r\n * well for short/medium texts on modern hardware.\r\n */\r\nstatic sxi32 iPatternMatch(const void *pText, sxu32 nLen, const void *pPattern, sxu32 iPatLen, sxu32 *pOfft)\r\n{\r\n\tconst char *zpIn = (const char *)pPattern;\r\n\tconst char *zIn = (const char *)pText;\r\n\tconst char *zpEnd = &zpIn[iPatLen];\r\n\tconst char *zEnd = &zIn[nLen];\r\n\tconst char *zPtr, *zPtr2;\r\n\tint c, d;\r\n\tif( iPatLen > nLen ){\r\n\t\t/* Don't bother processing */\r\n\t\treturn SXERR_NOTFOUND;\r\n\t}\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tc = SyToLower(zIn[0]);\r\n\t\td = SyToLower(zpIn[0]);\r\n\t\tif( c == d ){\r\n\t\t\tzPtr   = &zIn[1];\r\n\t\t\tzPtr2  = &zpIn[1];\r\n\t\t\tfor(;;){\r\n\t\t\t\tif( zPtr2 >= zpEnd ){\r\n\t\t\t\t\t/* Pattern found */\r\n\t\t\t\t\tif( pOfft ){ *pOfft = (sxu32)(zIn-(const char *)pText); }\r\n\t\t\t\t\treturn SXRET_OK;\r\n\t\t\t\t}\r\n\t\t\t\tif( zPtr >= zEnd ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tc = SyToLower(zPtr[0]);\r\n\t\t\t\td = SyToLower(zPtr2[0]);\r\n\t\t\t\tif( c != d ){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tzPtr++; zPtr2++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tzIn++;\r\n\t}\r\n\t/* Pattern not found */\r\n\treturn SXERR_NOTFOUND;\r\n}\r\n/*\r\n * string strstr(string $haystack, string $needle[, bool $before_needle = false ])\r\n *  Find the first occurrence of a string.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $before_needle\r\n *   If TRUE, strstr() returns the part of the haystack before the first occurrence \r\n *   of the needle (excluding the needle).\r\n * Return\r\n *  Returns the portion of string, or FALSE if needle is not found.\r\n */\r\nstatic int jx9Builtin_strstr(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tProcStringMatch xPatternMatch = SyBlobSearch; /* Case-sensitive pattern match */\r\n\tconst char *zBlob, *zPattern;\r\n\tint nLen, nPatLen;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\tnOfft = 0; /* cc warning */\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\tint before = 0;\r\n\t\t/* Perform the lookup */\r\n\t\trc = xPatternMatch(zBlob, (sxu32)nLen, zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Pattern not found, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Return the portion of the string */\r\n\t\tif( nArg > 2 ){\r\n\t\t\tbefore = jx9_value_to_int(apArg[2]);\r\n\t\t}\r\n\t\tif( before ){\r\n\t\t\tjx9_result_string(pCtx, zBlob, (int)(&zBlob[nOfft]-zBlob));\r\n\t\t}else{\r\n\t\t\tjx9_result_string(pCtx, &zBlob[nOfft], (int)(&zBlob[nLen]-&zBlob[nOfft]));\r\n\t\t}\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string stristr(string $haystack, string $needle[, bool $before_needle = false ])\r\n *  Case-insensitive strstr().\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $before_needle\r\n *   If TRUE, strstr() returns the part of the haystack before the first occurrence \r\n *   of the needle (excluding the needle).\r\n * Return\r\n *  Returns the portion of string, or FALSE if needle is not found.\r\n */\r\nstatic int jx9Builtin_stristr(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tProcStringMatch xPatternMatch = iPatternMatch; /* Case-insensitive pattern match */\r\n\tconst char *zBlob, *zPattern;\r\n\tint nLen, nPatLen;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\tnOfft = 0; /* cc warning */\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\tint before = 0;\r\n\t\t/* Perform the lookup */\r\n\t\trc = xPatternMatch(zBlob, (sxu32)nLen, zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Pattern not found, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Return the portion of the string */\r\n\t\tif( nArg > 2 ){\r\n\t\t\tbefore = jx9_value_to_int(apArg[2]);\r\n\t\t}\r\n\t\tif( before ){\r\n\t\t\tjx9_result_string(pCtx, zBlob, (int)(&zBlob[nOfft]-zBlob));\r\n\t\t}else{\r\n\t\t\tjx9_result_string(pCtx, &zBlob[nOfft], (int)(&zBlob[nLen]-&zBlob[nOfft]));\r\n\t\t}\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strpos(string $haystack, string $needle [, int $offset = 0 ] )\r\n *  Returns the numeric position of the first occurrence of needle in the haystack string.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $offset\r\n *   This optional offset parameter allows you to specify which character in haystack\r\n *   to start searching. The position returned is still relative to the beginning\r\n *   of haystack.\r\n * Return\r\n *  Returns the position as an integer.If needle is not found, strpos() will return FALSE.\r\n */\r\nstatic int jx9Builtin_strpos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tProcStringMatch xPatternMatch = SyBlobSearch; /* Case-sensitive pattern match */\r\n\tconst char *zBlob, *zPattern;\r\n\tint nLen, nPatLen, nStart;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\tnOfft = 0; /* cc warning */\r\n\tnStart = 0;\r\n\t/* Peek the starting offset if available */\r\n\tif( nArg > 2 ){\r\n\t\tnStart = jx9_value_to_int(apArg[2]);\r\n\t\tif( nStart < 0 ){\r\n\t\t\tnStart = -nStart;\r\n\t\t}\r\n\t\tif( nStart >= nLen ){\r\n\t\t\t/* Invalid offset */\r\n\t\t\tnStart = 0;\r\n\t\t}else{\r\n\t\t\tzBlob += nStart;\r\n\t\t\tnLen -= nStart;\r\n\t\t}\r\n\t}\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\t/* Perform the lookup */\r\n\t\trc = xPatternMatch(zBlob, (sxu32)nLen, zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Pattern not found, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Return the pattern position */\r\n\t\tjx9_result_int64(pCtx, (jx9_int64)(nOfft+nStart));\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int stripos(string $haystack, string $needle [, int $offset = 0 ] )\r\n *  Case-insensitive strpos.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $offset\r\n *   This optional offset parameter allows you to specify which character in haystack\r\n *   to start searching. The position returned is still relative to the beginning\r\n *   of haystack.\r\n * Return\r\n *  Returns the position as an integer.If needle is not found, strpos() will return FALSE.\r\n */\r\nstatic int jx9Builtin_stripos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tProcStringMatch xPatternMatch = iPatternMatch; /* Case-insensitive pattern match */\r\n\tconst char *zBlob, *zPattern;\r\n\tint nLen, nPatLen, nStart;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\tnOfft = 0; /* cc warning */\r\n\tnStart = 0;\r\n\t/* Peek the starting offset if available */\r\n\tif( nArg > 2 ){\r\n\t\tnStart = jx9_value_to_int(apArg[2]);\r\n\t\tif( nStart < 0 ){\r\n\t\t\tnStart = -nStart;\r\n\t\t}\r\n\t\tif( nStart >= nLen ){\r\n\t\t\t/* Invalid offset */\r\n\t\t\tnStart = 0;\r\n\t\t}else{\r\n\t\t\tzBlob += nStart;\r\n\t\t\tnLen -= nStart;\r\n\t\t}\r\n\t}\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\t/* Perform the lookup */\r\n\t\trc = xPatternMatch(zBlob, (sxu32)nLen, zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Pattern not found, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Return the pattern position */\r\n\t\tjx9_result_int64(pCtx, (jx9_int64)(nOfft+nStart));\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strrpos(string $haystack, string $needle [, int $offset = 0 ] )\r\n *  Find the numeric position of the last occurrence of needle in the haystack string.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $offset\r\n *   If specified, search will start this number of characters counted from the beginning\r\n *   of the string. If the value is negative, search will instead start from that many \r\n *   characters from the end of the string, searching backwards.\r\n * Return\r\n *  Returns the position as an integer.If needle is not found, strrpos() will return FALSE.\r\n */\r\nstatic int jx9Builtin_strrpos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zStart, *zBlob, *zPattern, *zPtr, *zEnd;\r\n\tProcStringMatch xPatternMatch = SyBlobSearch; /* Case-sensitive pattern match */\r\n\tint nLen, nPatLen;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\t/* Point to the end of the pattern */\r\n\tzPtr = &zBlob[nLen - 1];\r\n\tzEnd = &zBlob[nLen];\r\n\t/* Save the starting posistion */\r\n\tzStart = zBlob;\r\n\tnOfft = 0; /* cc warning */\r\n\t/* Peek the starting offset if available */\r\n\tif( nArg > 2 ){\r\n\t\tint nStart;\r\n\t\tnStart = jx9_value_to_int(apArg[2]);\r\n\t\tif( nStart < 0 ){\r\n\t\t\tnStart = -nStart;\r\n\t\t\tif( nStart >= nLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\tnLen -= nStart;\r\n\t\t\t\tzPtr = &zBlob[nLen - 1];\r\n\t\t\t\tzEnd = &zBlob[nLen];\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( nStart >= nLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\tzBlob += nStart;\r\n\t\t\t\tnLen -= nStart;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\t/* Perform the lookup */\r\n\t\tfor(;;){\r\n\t\t\tif( zBlob >= zPtr ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trc = xPatternMatch((const void *)zPtr, (sxu32)(zEnd-zPtr), (const void *)zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t/* Pattern found, return it's position */\r\n\t\t\t\tjx9_result_int64(pCtx, (jx9_int64)(&zPtr[nOfft] - zStart));\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}\r\n\t\t\tzPtr--;\r\n\t\t}\r\n\t\t/* Pattern not found, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strripos(string $haystack, string $needle [, int $offset = 0 ] )\r\n *  Case-insensitive strrpos.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *   Search pattern (must be a string).\r\n * $offset\r\n *   If specified, search will start this number of characters counted from the beginning\r\n *   of the string. If the value is negative, search will instead start from that many \r\n *   characters from the end of the string, searching backwards.\r\n * Return\r\n *  Returns the position as an integer.If needle is not found, strrpos() will return FALSE.\r\n */\r\nstatic int jx9Builtin_strripos(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zStart, *zBlob, *zPattern, *zPtr, *zEnd;\r\n\tProcStringMatch xPatternMatch = iPatternMatch; /* Case-insensitive pattern match */\r\n\tint nLen, nPatLen;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the needle and the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tzPattern = jx9_value_to_string(apArg[1], &nPatLen);\r\n\t/* Point to the end of the pattern */\r\n\tzPtr = &zBlob[nLen - 1];\r\n\tzEnd = &zBlob[nLen];\r\n\t/* Save the starting posistion */\r\n\tzStart = zBlob;\r\n\tnOfft = 0; /* cc warning */\r\n\t/* Peek the starting offset if available */\r\n\tif( nArg > 2 ){\r\n\t\tint nStart;\r\n\t\tnStart = jx9_value_to_int(apArg[2]);\r\n\t\tif( nStart < 0 ){\r\n\t\t\tnStart = -nStart;\r\n\t\t\tif( nStart >= nLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\tnLen -= nStart;\r\n\t\t\t\tzPtr = &zBlob[nLen - 1];\r\n\t\t\t\tzEnd = &zBlob[nLen];\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( nStart >= nLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\tzBlob += nStart;\r\n\t\t\t\tnLen -= nStart;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif( nLen > 0 && nPatLen > 0 ){\r\n\t\t/* Perform the lookup */\r\n\t\tfor(;;){\r\n\t\t\tif( zBlob >= zPtr ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trc = xPatternMatch((const void *)zPtr, (sxu32)(zEnd-zPtr), (const void *)zPattern, (sxu32)nPatLen, &nOfft);\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t/* Pattern found, return it's position */\r\n\t\t\t\tjx9_result_int64(pCtx, (jx9_int64)(&zPtr[nOfft] - zStart));\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}\r\n\t\t\tzPtr--;\r\n\t\t}\r\n\t\t/* Pattern not found, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strrchr(string $haystack, mixed $needle)\r\n *  Find the last occurrence of a character in a string.\r\n * Parameters\r\n *  $haystack\r\n *   The input string.\r\n * $needle\r\n *  If needle contains more than one character, only the first is used.\r\n *  This behavior is different from that of strstr().\r\n *  If needle is not a string, it is converted to an integer and applied\r\n *  as the ordinal value of a character.\r\n * Return\r\n *  This function returns the portion of string, or FALSE if needle is not found.\r\n */\r\nstatic int jx9Builtin_strrchr(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zBlob;\r\n\tint nLen, c;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the haystack */\r\n\tzBlob = jx9_value_to_string(apArg[0], &nLen);\r\n\tc = 0; /* cc warning */\r\n\tif( nLen > 0 ){\r\n\t\tsxu32 nOfft;\r\n\t\tsxi32 rc;\r\n\t\tif( jx9_value_is_string(apArg[1]) ){\r\n\t\t\tconst char *zPattern;\r\n\t\t\tzPattern = jx9_value_to_string(apArg[1], 0); /* Never fail, so there is no need to check\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * for NULL pointer.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t */\r\n\t\t\tc = zPattern[0];\r\n\t\t}else{\r\n\t\t\t/* Int cast */\r\n\t\t\tc = jx9_value_to_int(apArg[1]);\r\n\t\t}\r\n\t\t/* Perform the lookup */\r\n\t\trc = SyByteFind2(zBlob, (sxu32)nLen, c, &nOfft);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* No such entry, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Return the string portion */\r\n\t\tjx9_result_string(pCtx, &zBlob[nOfft], (int)(&zBlob[nLen]-&zBlob[nOfft]));\r\n\t}else{\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strrev(string $string)\r\n *  Reverse a string.\r\n * Parameters\r\n *  $string\r\n *   String to be reversed.\r\n * Return\r\n *  The reversed string.\r\n */\r\nstatic int jx9Builtin_strrev(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zIn, *zEnd;\r\n\tint nLen, c;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string Return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tzEnd = &zIn[nLen - 1];\r\n\tfor(;;){\r\n\t\tif( zEnd < zIn ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Append current character */\r\n\t\tc = zEnd[0];\r\n\t\tjx9_result_string(pCtx, (const char *)&c, (int)sizeof(char));\r\n\t\tzEnd--;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string str_repeat(string $input, int $multiplier)\r\n *  Returns input repeated multiplier times.\r\n * Parameters\r\n *  $string\r\n *   String to be repeated.\r\n * $multiplier\r\n *  Number of time the input string should be repeated.\r\n *  multiplier has to be greater than or equal to 0. If the multiplier is set\r\n *  to 0, the function will return an empty string.\r\n * Return\r\n *  The repeated string.\r\n */\r\nstatic int jx9Builtin_str_repeat(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zIn;\r\n\tint nLen, nMul;\r\n\tint rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string.Return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the multiplier */\r\n\tnMul = jx9_value_to_int(apArg[1]);\r\n\tif( nMul < 1 ){\r\n\t\t/* Return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tif( nMul < 1 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Append the copy */\r\n\t\trc = jx9_result_string(pCtx, zIn, nLen);\r\n\t\tif( rc != JX9_OK ){\r\n\t\t\t/* Out of memory, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tnMul--;\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string nl2br(string $string[, bool $is_xhtml = true ])\r\n *  Inserts HTML line breaks before all newlines in a string.\r\n * Parameters\r\n *  $string\r\n *   The input string.\r\n * $is_xhtml\r\n *   Whenever to use XHTML compatible line breaks or not.\r\n * Return\r\n *  The processed string.\r\n */\r\nstatic int jx9Builtin_nl2br(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zIn, *zCur, *zEnd;\r\n\tint is_xhtml = 0;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 1 ){\r\n\t\tis_xhtml = jx9_value_to_bool(apArg[1]);\r\n\t}\r\n\tzEnd = &zIn[nLen];\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tzCur = zIn;\r\n\t\t/* Delimit the string */\r\n\t\twhile( zIn < zEnd && (zIn[0] != '\\n'&& zIn[0] != '\\r') ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Output chunk verbatim */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zIn-zCur));\r\n\t\t}\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Output the HTML line break */\r\n\t\tif( is_xhtml ){\r\n\t\t\tjx9_result_string(pCtx, \"<br>\", (int)sizeof(\"<br>\")-1);\r\n\t\t}else{\r\n\t\t\tjx9_result_string(pCtx, \"<br/>\", (int)sizeof(\"<br/>\")-1);\r\n\t\t}\r\n\t\tzCur = zIn;\r\n\t\t/* Append trailing line */\r\n\t\twhile( zIn < zEnd && (zIn[0] == '\\n'  || zIn[0] == '\\r') ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Output chunk verbatim */\r\n\t\t\tjx9_result_string(pCtx, zCur, (int)(zIn-zCur));\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Format a given string and invoke the given callback on each processed chunk.\r\n *  According to the JX9 reference manual.\r\n * The format string is composed of zero or more directives: ordinary characters\r\n * (excluding %) that are copied directly to the result, and conversion \r\n * specifications, each of which results in fetching its own parameter.\r\n * This applies to both sprintf() and printf().\r\n * Each conversion specification consists of a percent sign (%), followed by one\r\n * or more of these elements, in order:\r\n *   An optional sign specifier that forces a sign (- or +) to be used on a number.\r\n *   By default, only the - sign is used on a number if it's negative. This specifier forces\r\n *   positive numbers to have the + sign attached as well.\r\n *   An optional padding specifier that says what character will be used for padding\r\n *   the results to the right string size. This may be a space character or a 0 (zero character).\r\n *   The default is to pad with spaces. An alternate padding character can be specified by prefixing\r\n *   it with a single quote ('). See the examples below.\r\n *   An optional alignment specifier that says if the result should be left-justified or right-justified.\r\n *   The default is right-justified; a - character here will make it left-justified.\r\n *   An optional number, a width specifier that says how many characters (minimum) this conversion\r\n *   should result in.\r\n *   An optional precision specifier in the form of a period (`.') followed by an optional decimal\r\n *   digit string that says how many decimal digits should be displayed for floating-point numbers.\r\n *   When using this specifier on a string, it acts as a cutoff point, setting a maximum character\r\n *   limit to the string.\r\n *  A type specifier that says what type the argument data should be treated as. Possible types:\r\n *       % - a literal percent character. No argument is required.\r\n *       b - the argument is treated as an integer, and presented as a binary number.\r\n *       c - the argument is treated as an integer, and presented as the character with that ASCII value.\r\n *       d - the argument is treated as an integer, and presented as a (signed) decimal number.\r\n *       e - the argument is treated as scientific notation (e.g. 1.2e+2). The precision specifier stands \r\n * \t     for the number of digits after the decimal point.\r\n *       E - like %e but uses uppercase letter (e.g. 1.2E+2).\r\n *       u - the argument is treated as an integer, and presented as an unsigned decimal number.\r\n *       f - the argument is treated as a float, and presented as a floating-point number (locale aware).\r\n *       F - the argument is treated as a float, and presented as a floating-point number (non-locale aware).\r\n *       g - shorter of %e and %f.\r\n *       G - shorter of %E and %f.\r\n *       o - the argument is treated as an integer, and presented as an octal number.\r\n *       s - the argument is treated as and presented as a string.\r\n *       x - the argument is treated as an integer and presented as a hexadecimal number (with lowercase letters).\r\n *       X - the argument is treated as an integer and presented as a hexadecimal number (with uppercase letters).\r\n */\r\n/*\r\n * This implementation is based on the one found in the SQLite3 source tree.\r\n */\r\n#define JX9_FMT_BUFSIZ 1024 /* Conversion buffer size */\r\n/*\r\n** Conversion types fall into various categories as defined by the\r\n** following enumeration.\r\n*/\r\n#define JX9_FMT_RADIX       1 /* Integer types.%d, %x, %o, and so forth */\r\n#define JX9_FMT_FLOAT       2 /* Floating point.%f */\r\n#define JX9_FMT_EXP         3 /* Exponentional notation.%e and %E */\r\n#define JX9_FMT_GENERIC     4 /* Floating or exponential, depending on exponent.%g */\r\n#define JX9_FMT_SIZE        5 /* Total number of characters processed so far.%n */\r\n#define JX9_FMT_STRING      6 /* Strings.%s */\r\n#define JX9_FMT_PERCENT     7 /* Percent symbol.%% */\r\n#define JX9_FMT_CHARX       8 /* Characters.%c */\r\n#define JX9_FMT_ERROR       9 /* Used to indicate no such conversion type */\r\n/*\r\n** Allowed values for jx9_fmt_info.flags\r\n*/\r\n#define JX9_FMT_FLAG_SIGNED\t  0x01\r\n#define JX9_FMT_FLAG_UNSIGNED 0x02\r\n/*\r\n** Each builtin conversion character (ex: the 'd' in \"%d\") is described\r\n** by an instance of the following structure\r\n*/\r\ntypedef struct jx9_fmt_info jx9_fmt_info;\r\nstruct jx9_fmt_info\r\n{\r\n  char fmttype;  /* The format field code letter [i.e: 'd', 's', 'x'] */\r\n  sxu8 base;     /* The base for radix conversion */\r\n  int flags;    /* One or more of JX9_FMT_FLAG_ constants below */\r\n  sxu8 type;     /* Conversion paradigm */\r\n  char *charset; /* The character set for conversion */\r\n  char *prefix;  /* Prefix on non-zero values in alt format */\r\n};\r\n#ifndef JX9_OMIT_FLOATING_POINT\r\n/*\r\n** \"*val\" is a double such that 0.1 <= *val < 10.0\r\n** Return the ascii code for the leading digit of *val, then\r\n** multiply \"*val\" by 10.0 to renormalize.\r\n**\r\n** Example:\r\n**     input:     *val = 3.14159\r\n**     output:    *val = 1.4159    function return = '3'\r\n**\r\n** The counter *cnt is incremented each time.  After counter exceeds\r\n** 16 (the number of significant digits in a 64-bit float) '0' is\r\n** always returned.\r\n*/\r\nstatic int vxGetdigit(sxlongreal *val, int *cnt)\r\n{\r\n  sxlongreal d;\r\n  int digit;\r\n\r\n  if( (*cnt)++ >= 16 ){\r\n\t  return '0';\r\n  }\r\n  digit = (int)*val;\r\n  d = digit;\r\n   *val = (*val - d)*10.0;\r\n  return digit + '0' ;\r\n}\r\n#endif /* JX9_OMIT_FLOATING_POINT */\r\n/*\r\n * The following table is searched linearly, so it is good to put the most frequently\r\n * used conversion types first.\r\n */\r\nstatic const jx9_fmt_info aFmt[] = {\r\n  {  'd', 10, JX9_FMT_FLAG_SIGNED, JX9_FMT_RADIX, \"0123456789\", 0    }, \r\n  {  's',  0, 0, JX9_FMT_STRING,     0,                  0    }, \r\n  {  'c',  0, 0, JX9_FMT_CHARX,      0,                  0    }, \r\n  {  'x', 16, 0, JX9_FMT_RADIX,      \"0123456789abcdef\", \"x0\" }, \r\n  {  'X', 16, 0, JX9_FMT_RADIX,      \"0123456789ABCDEF\", \"X0\" }, \r\n  {  'b',  2, 0, JX9_FMT_RADIX,      \"01\",                \"b0\"}, \r\n  {  'o',  8, 0, JX9_FMT_RADIX,      \"01234567\",         \"0\"  }, \r\n  {  'u', 10, 0, JX9_FMT_RADIX,      \"0123456789\",       0    }, \r\n  {  'f',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_FLOAT,        0,    0    }, \r\n  {  'F',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_FLOAT,        0,    0    }, \r\n  {  'e',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_EXP,        \"e\",    0    }, \r\n  {  'E',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_EXP,        \"E\",    0    }, \r\n  {  'g',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_GENERIC,    \"e\",    0    }, \r\n  {  'G',  0, JX9_FMT_FLAG_SIGNED, JX9_FMT_GENERIC,    \"E\",    0    }, \r\n  {  '%',  0, 0, JX9_FMT_PERCENT,    0,                  0    }\r\n};\r\n/*\r\n * Format a given string.\r\n * The root program.  All variations call this core.\r\n * INPUTS:\r\n *   xConsumer   This is a pointer to a function taking four arguments\r\n *            1. A pointer to the call context.\r\n *            2. A pointer to the list of characters to be output\r\n *               (Note, this list is NOT null terminated.)\r\n *            3. An integer number of characters to be output.\r\n *               (Note: This number might be zero.)\r\n *            4. Upper layer private data.\r\n *   zIn       This is the format string, as in the usual print.\r\n *   apArg     This is a pointer to a list of arguments.\r\n */\r\nJX9_PRIVATE sxi32 jx9InputFormat(\r\n\tint (*xConsumer)(jx9_context *, const char *, int, void *), /* Format consumer */\r\n\tjx9_context *pCtx,  /* call context */\r\n\tconst char *zIn,    /* Format string */\r\n\tint nByte,          /* Format string length */\r\n\tint nArg,           /* Total argument of the given arguments */\r\n\tjx9_value **apArg,  /* User arguments */\r\n\tvoid *pUserData,    /* Last argument to xConsumer() */\r\n\tint vf              /* TRUE if called from vfprintf, vsprintf context */ \r\n\t)\r\n{\r\n\tchar spaces[] = \"                                                  \";\r\n#define etSPACESIZE ((int)sizeof(spaces)-1)\r\n\tconst char *zCur, *zEnd = &zIn[nByte];\r\n\tchar *zBuf, zWorker[JX9_FMT_BUFSIZ];       /* Working buffer */\r\n\tconst jx9_fmt_info *pInfo;  /* Pointer to the appropriate info structure */\r\n\tint flag_alternateform; /* True if \"#\" flag is present */\r\n\tint flag_leftjustify;   /* True if \"-\" flag is present */\r\n\tint flag_blanksign;     /* True if \" \" flag is present */\r\n\tint flag_plussign;      /* True if \"+\" flag is present */\r\n\tint flag_zeropad;       /* True if field width constant starts with zero */\r\n\tjx9_value *pArg;         /* Current processed argument */\r\n\tjx9_int64 iVal;\r\n\tint precision;           /* Precision of the current field */\r\n\tchar *zExtra;  \r\n\tint c, rc, n;\r\n\tint length;              /* Length of the field */\r\n\tint prefix;\r\n\tsxu8 xtype;              /* Conversion paradigm */\r\n\tint width;               /* Width of the current field */\r\n\tint idx;\r\n\tn = (vf == TRUE) ? 0 : 1;\r\n#define NEXT_ARG\t( n < nArg ? apArg[n++] : 0 )\r\n\t/* Start the format process */\r\n\tfor(;;){\r\n\t\tzCur = zIn;\r\n\t\twhile( zIn < zEnd && zIn[0] != '%' ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zCur < zIn ){\r\n\t\t\t/* Consume chunk verbatim */\r\n\t\t\trc = xConsumer(pCtx, zCur, (int)(zIn-zCur), pUserData);\r\n\t\t\tif( rc == SXERR_ABORT ){\r\n\t\t\t\t/* Callback request an operation abort */\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Find out what flags are present */\r\n\t\tflag_leftjustify = flag_plussign = flag_blanksign = \r\n\t\t\tflag_alternateform = flag_zeropad = 0;\r\n\t\tzIn++; /* Jump the precent sign */\r\n\t\tdo{\r\n\t\t\tc = zIn[0];\r\n\t\t\tswitch( c ){\r\n\t\t\tcase '-':   flag_leftjustify = 1;     c = 0;   break;\r\n\t\t\tcase '+':   flag_plussign = 1;        c = 0;   break;\r\n\t\t\tcase ' ':   flag_blanksign = 1;       c = 0;   break;\r\n\t\t\tcase '#':   flag_alternateform = 1;   c = 0;   break;\r\n\t\t\tcase '0':   flag_zeropad = 1;         c = 0;   break;\r\n\t\t\tcase '\\'':\r\n\t\t\t\tzIn++;\r\n\t\t\t\tif( zIn < zEnd ){\r\n\t\t\t\t\t/* An alternate padding character can be specified by prefixing it with a single quote (') */\r\n\t\t\t\t\tc = zIn[0];\r\n\t\t\t\t\tfor(idx = 0 ; idx < etSPACESIZE ; ++idx ){\r\n\t\t\t\t\t\tspaces[idx] = (char)c;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:                                       break;\r\n\t\t\t}\r\n\t\t}while( c==0 && (zIn++ < zEnd) );\r\n\t\t/* Get the field width */\r\n\t\twidth = 0;\r\n\t\twhile( zIn < zEnd && ( zIn[0] >='0' && zIn[0] <='9') ){\r\n\t\t\twidth = width*10 + (zIn[0] - '0');\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zIn < zEnd && zIn[0] == '$' ){\r\n\t\t\t/* Position specifer */\r\n\t\t\tif( width > 0 ){\r\n\t\t\t\tn = width;\r\n\t\t\t\tif( vf && n > 0 ){ \r\n\t\t\t\t\tn--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tzIn++;\r\n\t\t\twidth = 0;\r\n\t\t\tif( zIn < zEnd && zIn[0] == '0' ){\r\n\t\t\t\tflag_zeropad = 1;\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t\twhile( zIn < zEnd && ( zIn[0] >='0' && zIn[0] <='9') ){\r\n\t\t\t\twidth = width*10 + (zIn[0] - '0');\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( width > JX9_FMT_BUFSIZ-10 ){\r\n\t\t\twidth = JX9_FMT_BUFSIZ-10;\r\n\t\t}\r\n\t\t/* Get the precision */\r\n\t\tprecision = -1;\r\n\t\tif( zIn < zEnd && zIn[0] == '.' ){\r\n\t\t\tprecision = 0;\r\n\t\t\tzIn++;\r\n\t\t\twhile( zIn < zEnd && ( zIn[0] >='0' && zIn[0] <='9') ){\r\n\t\t\t\tprecision = precision*10 + (zIn[0] - '0');\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Fetch the info entry for the field */\r\n\t\tpInfo = 0;\r\n\t\txtype = JX9_FMT_ERROR;\r\n\t\tc = zIn[0];\r\n\t\tzIn++; /* Jump the format specifer */\r\n\t\tfor(idx=0; idx< (int)SX_ARRAYSIZE(aFmt); idx++){\r\n\t\t\tif( c==aFmt[idx].fmttype ){\r\n\t\t\t\tpInfo = &aFmt[idx];\r\n\t\t\t\txtype = pInfo->type;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tzBuf = zWorker; /* Point to the working buffer */\r\n\t\tlength = 0;\r\n\t\tzExtra = 0;\r\n\t\t /*\r\n\t\t  ** At this point, variables are initialized as follows:\r\n\t\t  **\r\n\t\t  **   flag_alternateform          TRUE if a '#' is present.\r\n\t\t  **   flag_plussign               TRUE if a '+' is present.\r\n\t\t  **   flag_leftjustify            TRUE if a '-' is present or if the\r\n\t\t  **                               field width was negative.\r\n\t\t  **   flag_zeropad                TRUE if the width began with 0.\r\n\t\t  **                               the conversion character.\r\n\t\t  **   flag_blanksign              TRUE if a ' ' is present.\r\n\t\t  **   width                       The specified field width.  This is\r\n\t\t  **                               always non-negative.  Zero is the default.\r\n\t\t  **   precision                   The specified precision.  The default\r\n\t\t  **                               is -1.\r\n\t\t  */\r\n\t\tswitch(xtype){\r\n\t\tcase JX9_FMT_PERCENT:\r\n\t\t\t/* A literal percent character */\r\n\t\t\tzWorker[0] = '%';\r\n\t\t\tlength = (int)sizeof(char);\r\n\t\t\tbreak;\r\n\t\tcase JX9_FMT_CHARX:\r\n\t\t\t/* The argument is treated as an integer, and presented as the character\r\n\t\t\t * with that ASCII value\r\n\t\t\t */\r\n\t\t\tpArg = NEXT_ARG;\r\n\t\t\tif( pArg == 0 ){\r\n\t\t\t\tc = 0;\r\n\t\t\t}else{\r\n\t\t\t\tc = jx9_value_to_int(pArg);\r\n\t\t\t}\r\n\t\t\t/* NUL byte is an acceptable value */\r\n\t\t\tzWorker[0] = (char)c;\r\n\t\t\tlength = (int)sizeof(char);\r\n\t\t\tbreak;\r\n\t\tcase JX9_FMT_STRING:\r\n\t\t\t/* the argument is treated as and presented as a string */\r\n\t\t\tpArg = NEXT_ARG;\r\n\t\t\tif( pArg == 0 ){\r\n\t\t\t\tlength = 0;\r\n\t\t\t}else{\r\n\t\t\t\tzBuf = (char *)jx9_value_to_string(pArg, &length);\r\n\t\t\t}\r\n\t\t\tif( length < 1 ){\r\n\t\t\t\tzBuf = \" \";\r\n\t\t\t\tlength = (int)sizeof(char);\r\n\t\t\t}\r\n\t\t\tif( precision>=0 && precision<length ){\r\n\t\t\t\tlength = precision;\r\n\t\t\t}\r\n\t\t\tif( flag_zeropad ){\r\n\t\t\t\t/* zero-padding works on strings too */\r\n\t\t\t\tfor(idx = 0 ; idx < etSPACESIZE ; ++idx ){\r\n\t\t\t\t\tspaces[idx] = '0';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase JX9_FMT_RADIX:\r\n\t\t\tpArg = NEXT_ARG;\r\n\t\t\tif( pArg == 0 ){\r\n\t\t\t\tiVal = 0;\r\n\t\t\t}else{\r\n\t\t\t\tiVal = jx9_value_to_int64(pArg);\r\n\t\t\t}\r\n\t\t\t/* Limit the precision to prevent overflowing buf[] during conversion */\r\n\t\t\tif( precision>JX9_FMT_BUFSIZ-40 ){\r\n\t\t\t\tprecision = JX9_FMT_BUFSIZ-40;\r\n\t\t\t}\r\n#if 1\r\n        /* For the format %#x, the value zero is printed \"0\" not \"0x0\".\r\n        ** I think this is stupid.*/\r\n        if( iVal==0 ) flag_alternateform = 0;\r\n#else\r\n        /* More sensible: turn off the prefix for octal (to prevent \"00\"), \r\n        ** but leave the prefix for hex.*/\r\n        if( iVal==0 && pInfo->base==8 ) flag_alternateform = 0;\r\n#endif\r\n        if( pInfo->flags & JX9_FMT_FLAG_SIGNED ){\r\n          if( iVal<0 ){ \r\n            iVal = -iVal;\r\n\t\t\t/* Ticket 1433-003 */\r\n\t\t\tif( iVal < 0 ){\r\n\t\t\t\t/* Overflow */\r\n\t\t\t\tiVal= 0x7FFFFFFFFFFFFFFF;\r\n\t\t\t}\r\n            prefix = '-';\r\n          }else if( flag_plussign )  prefix = '+';\r\n          else if( flag_blanksign )  prefix = ' ';\r\n          else                       prefix = 0;\r\n        }else{\r\n\t\t\tif( iVal<0 ){\r\n\t\t\t\tiVal = -iVal;\r\n\t\t\t\t/* Ticket 1433-003 */\r\n\t\t\t\tif( iVal < 0 ){\r\n\t\t\t\t\t/* Overflow */\r\n\t\t\t\t\tiVal= 0x7FFFFFFFFFFFFFFF;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprefix = 0;\r\n\t\t}\r\n        if( flag_zeropad && precision<width-(prefix!=0) ){\r\n          precision = width-(prefix!=0);\r\n        }\r\n        zBuf = &zWorker[JX9_FMT_BUFSIZ-1];\r\n        {\r\n          register char *cset;      /* Use registers for speed */\r\n          register int base;\r\n          cset = pInfo->charset;\r\n          base = pInfo->base;\r\n          do{                                           /* Convert to ascii */\r\n            *(--zBuf) = cset[iVal%base];\r\n            iVal = iVal/base;\r\n          }while( iVal>0 );\r\n        }\r\n        length = (int)(&zWorker[JX9_FMT_BUFSIZ-1]-zBuf);\r\n        for(idx=precision-length; idx>0; idx--){\r\n          *(--zBuf) = '0';                             /* Zero pad */\r\n        }\r\n        if( prefix ) *(--zBuf) = (char)prefix;               /* Add sign */\r\n        if( flag_alternateform && pInfo->prefix ){      /* Add \"0\" or \"0x\" */\r\n          char *pre, x;\r\n          pre = pInfo->prefix;\r\n          if( *zBuf!=pre[0] ){\r\n            for(pre=pInfo->prefix; (x=(*pre))!=0; pre++) *(--zBuf) = x;\r\n          }\r\n        }\r\n        length = (int)(&zWorker[JX9_FMT_BUFSIZ-1]-zBuf);\r\n\t\tbreak;\r\n\t\tcase JX9_FMT_FLOAT:\r\n\t\tcase JX9_FMT_EXP:\r\n\t\tcase JX9_FMT_GENERIC:{\r\n#ifndef JX9_OMIT_FLOATING_POINT\r\n\t\tlong double realvalue;\r\n\t\tint  exp;                /* exponent of real numbers */\r\n\t\tdouble rounder;          /* Used for rounding floating point values */\r\n\t\tint flag_dp;            /* True if decimal point should be shown */\r\n\t\tint flag_rtz;           /* True if trailing zeros should be removed */\r\n\t\tint flag_exp;           /* True to force display of the exponent */\r\n\t\tint nsd;                 /* Number of significant digits returned */\r\n\t\tpArg = NEXT_ARG;\r\n\t\tif( pArg == 0 ){\r\n\t\t\trealvalue = 0;\r\n\t\t}else{\r\n\t\t\trealvalue = jx9_value_to_double(pArg);\r\n\t\t}\r\n        if( precision<0 ) precision = 6;         /* Set default precision */\r\n        if( precision>JX9_FMT_BUFSIZ-40) precision = JX9_FMT_BUFSIZ-40;\r\n        if( realvalue<0.0 ){\r\n          realvalue = -realvalue;\r\n          prefix = '-';\r\n        }else{\r\n          if( flag_plussign )          prefix = '+';\r\n          else if( flag_blanksign )    prefix = ' ';\r\n          else                         prefix = 0;\r\n        }\r\n        if( pInfo->type==JX9_FMT_GENERIC && precision>0 ) precision--;\r\n        rounder = 0.0;\r\n#if 0\r\n        /* Rounding works like BSD when the constant 0.4999 is used.Wierd! */\r\n        for(idx=precision, rounder=0.4999; idx>0; idx--, rounder*=0.1);\r\n#else\r\n        /* It makes more sense to use 0.5 */\r\n        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1);\r\n#endif\r\n        if( pInfo->type==JX9_FMT_FLOAT ) realvalue += rounder;\r\n        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */\r\n        exp = 0;\r\n        if( realvalue>0.0 ){\r\n          while( realvalue>=1e8 && exp<=350 ){ realvalue *= 1e-8; exp+=8; }\r\n          while( realvalue>=10.0 && exp<=350 ){ realvalue *= 0.1; exp++; }\r\n          while( realvalue<1e-8 && exp>=-350 ){ realvalue *= 1e8; exp-=8; }\r\n          while( realvalue<1.0 && exp>=-350 ){ realvalue *= 10.0; exp--; }\r\n          if( exp>350 || exp<-350 ){\r\n            zBuf = \"NaN\";\r\n            length = 3;\r\n            break;\r\n          }\r\n        }\r\n        zBuf = zWorker;\r\n        /*\r\n        ** If the field type is etGENERIC, then convert to either etEXP\r\n        ** or etFLOAT, as appropriate.\r\n        */\r\n        flag_exp = xtype==JX9_FMT_EXP;\r\n        if( xtype!=JX9_FMT_FLOAT ){\r\n          realvalue += rounder;\r\n          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }\r\n        }\r\n        if( xtype==JX9_FMT_GENERIC ){\r\n          flag_rtz = !flag_alternateform;\r\n          if( exp<-4 || exp>precision ){\r\n            xtype = JX9_FMT_EXP;\r\n          }else{\r\n            precision = precision - exp;\r\n            xtype = JX9_FMT_FLOAT;\r\n          }\r\n        }else{\r\n          flag_rtz = 0;\r\n        }\r\n        /*\r\n        ** The \"exp+precision\" test causes output to be of type etEXP if\r\n        ** the precision is too large to fit in buf[].\r\n        */\r\n        nsd = 0;\r\n        if( xtype==JX9_FMT_FLOAT && exp+precision<JX9_FMT_BUFSIZ-30 ){\r\n          flag_dp = (precision>0 || flag_alternateform);\r\n          if( prefix ) *(zBuf++) = (char)prefix;         /* Sign */\r\n          if( exp<0 )  *(zBuf++) = '0';            /* Digits before \".\" */\r\n          else for(; exp>=0; exp--) *(zBuf++) = (char)vxGetdigit(&realvalue, &nsd);\r\n          if( flag_dp ) *(zBuf++) = '.';           /* The decimal point */\r\n          for(exp++; exp<0 && precision>0; precision--, exp++){\r\n            *(zBuf++) = '0';\r\n          }\r\n          while( (precision--)>0 ) *(zBuf++) = (char)vxGetdigit(&realvalue, &nsd);\r\n          *(zBuf--) = 0;                           /* Null terminate */\r\n          if( flag_rtz && flag_dp ){     /* Remove trailing zeros and \".\" */\r\n            while( zBuf>=zWorker && *zBuf=='0' ) *(zBuf--) = 0;\r\n            if( zBuf>=zWorker && *zBuf=='.' ) *(zBuf--) = 0;\r\n          }\r\n          zBuf++;                            /* point to next free slot */\r\n        }else{    /* etEXP or etGENERIC */\r\n          flag_dp = (precision>0 || flag_alternateform);\r\n          if( prefix ) *(zBuf++) = (char)prefix;   /* Sign */\r\n          *(zBuf++) = (char)vxGetdigit(&realvalue, &nsd);  /* First digit */\r\n          if( flag_dp ) *(zBuf++) = '.';     /* Decimal point */\r\n          while( (precision--)>0 ) *(zBuf++) = (char)vxGetdigit(&realvalue, &nsd);\r\n          zBuf--;                            /* point to last digit */\r\n          if( flag_rtz && flag_dp ){          /* Remove tail zeros */\r\n            while( zBuf>=zWorker && *zBuf=='0' ) *(zBuf--) = 0;\r\n            if( zBuf>=zWorker && *zBuf=='.' ) *(zBuf--) = 0;\r\n          }\r\n          zBuf++;                            /* point to next free slot */\r\n          if( exp || flag_exp ){\r\n            *(zBuf++) = pInfo->charset[0];\r\n            if( exp<0 ){ *(zBuf++) = '-'; exp = -exp; } /* sign of exp */\r\n            else       { *(zBuf++) = '+'; }\r\n            if( exp>=100 ){\r\n              *(zBuf++) = (char)((exp/100)+'0');                /* 100's digit */\r\n              exp %= 100;\r\n            }\r\n            *(zBuf++) = (char)(exp/10+'0');                     /* 10's digit */\r\n            *(zBuf++) = (char)(exp%10+'0');                     /* 1's digit */\r\n          }\r\n        }\r\n        /* The converted number is in buf[] and zero terminated.Output it.\r\n        ** Note that the number is in the usual order, not reversed as with\r\n        ** integer conversions.*/\r\n        length = (int)(zBuf-zWorker);\r\n        zBuf = zWorker;\r\n        /* Special case:  Add leading zeros if the flag_zeropad flag is\r\n        ** set and we are not left justified */\r\n        if( flag_zeropad && !flag_leftjustify && length < width){\r\n          int i;\r\n          int nPad = width - length;\r\n          for(i=width; i>=nPad; i--){\r\n            zBuf[i] = zBuf[i-nPad];\r\n          }\r\n          i = prefix!=0;\r\n          while( nPad-- ) zBuf[i++] = '0';\r\n          length = width;\r\n        }\r\n#else\r\n         zBuf = \" \";\r\n\t\t length = (int)sizeof(char);\r\n#endif /* JX9_OMIT_FLOATING_POINT */\r\n\t\t break;\r\n\t\t\t\t\t\t\t }\r\n\t\tdefault:\r\n\t\t\t/* Invalid format specifer */\r\n\t\t\tzWorker[0] = '?';\r\n\t\t\tlength = (int)sizeof(char);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t /*\r\n\t\t ** The text of the conversion is pointed to by \"zBuf\" and is\r\n\t\t ** \"length\" characters long.The field width is \"width\".Do\r\n\t\t ** the output.\r\n\t\t */\r\n    if( !flag_leftjustify ){\r\n      register int nspace;\r\n      nspace = width-length;\r\n      if( nspace>0 ){\r\n        while( nspace>=etSPACESIZE ){\r\n\t\t\trc = xConsumer(pCtx, spaces, etSPACESIZE, pUserData);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\treturn SXERR_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t\tnspace -= etSPACESIZE;\r\n        }\r\n        if( nspace>0 ){\r\n\t\t\trc = xConsumer(pCtx, spaces, (unsigned int)nspace, pUserData);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\treturn SXERR_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t}\r\n      }\r\n    }\r\n    if( length>0 ){\r\n\t\trc = xConsumer(pCtx, zBuf, (unsigned int)length, pUserData);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t  return SXERR_ABORT; /* Consumer routine request an operation abort */\r\n\t\t}\r\n    }\r\n    if( flag_leftjustify ){\r\n      register int nspace;\r\n      nspace = width-length;\r\n      if( nspace>0 ){\r\n        while( nspace>=etSPACESIZE ){\r\n\t\t\trc = xConsumer(pCtx, spaces, etSPACESIZE, pUserData);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\treturn SXERR_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t\tnspace -= etSPACESIZE;\r\n        }\r\n        if( nspace>0 ){\r\n\t\t\trc = xConsumer(pCtx, spaces, (unsigned int)nspace, pUserData);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\treturn SXERR_ABORT; /* Consumer routine request an operation abort */\r\n\t\t\t}\r\n\t\t}\r\n      }\r\n    }\r\n }/* for(;;) */\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * Callback [i.e: Formatted input consumer] of the sprintf function.\r\n */\r\nstatic int sprintfConsumer(jx9_context *pCtx, const char *zInput, int nLen, void *pUserData)\r\n{\r\n\t/* Consume directly */\r\n\tjx9_result_string(pCtx, zInput, nLen);\r\n\tSXUNUSED(pUserData); /* cc warning */\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string sprintf(string $format[, mixed $args [, mixed $... ]])\r\n *  Return a formatted string.\r\n * Parameters\r\n *  $format \r\n *    The format string (see block comment above)\r\n * Return\r\n *  A string produced according to the formatting string format. \r\n */\r\nstatic int jx9Builtin_sprintf(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zFormat;\r\n\tint nLen;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string format */\r\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Format the string */\r\n\tjx9InputFormat(sprintfConsumer, pCtx, zFormat, nLen, nArg, apArg, 0, FALSE);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Callback [i.e: Formatted input consumer] of the printf function.\r\n */\r\nstatic int printfConsumer(jx9_context *pCtx, const char *zInput, int nLen, void *pUserData)\r\n{\r\n\tjx9_int64 *pCounter = (jx9_int64 *)pUserData;\r\n\t/* Call the VM output consumer directly */\r\n\tjx9_context_output(pCtx, zInput, nLen);\r\n\t/* Increment counter */\r\n\t*pCounter += nLen;\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int64 printf(string $format[, mixed $args[, mixed $... ]])\r\n *  Output a formatted string.\r\n * Parameters\r\n *  $format\r\n *   See sprintf() for a description of format.\r\n * Return\r\n *  The length of the outputted string.\r\n */\r\nstatic int jx9Builtin_printf(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tjx9_int64 nCounter = 0;\r\n\tconst char *zFormat;\r\n\tint nLen;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string format */\r\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Format the string */\r\n\tjx9InputFormat(printfConsumer, pCtx, zFormat, nLen, nArg, apArg, (void *)&nCounter, FALSE);\r\n\t/* Return the length of the outputted string */\r\n\tjx9_result_int64(pCtx, nCounter);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int vprintf(string $format, array $args)\r\n *  Output a formatted string.\r\n * Parameters\r\n *  $format\r\n *   See sprintf() for a description of format.\r\n * Return\r\n *  The length of the outputted string.\r\n */\r\nstatic int jx9Builtin_vprintf(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tjx9_int64 nCounter = 0;\r\n\tconst char *zFormat;\r\n\tjx9_hashmap *pMap;\r\n\tSySet sArg;\r\n\tint nLen, n;\r\n\tif( nArg < 2 || !jx9_value_is_string(apArg[0]) || !jx9_value_is_json_array(apArg[1]) ){\r\n\t\t/* Missing/Invalid arguments, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string format */\r\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the hashmap */\r\n\tpMap = (jx9_hashmap *)apArg[1]->x.pOther;\r\n\t/* Extract arguments from the hashmap */\r\n\tn = jx9HashmapValuesToSet(pMap, &sArg);\r\n\t/* Format the string */\r\n\tjx9InputFormat(printfConsumer, pCtx, zFormat, nLen, n, (jx9_value **)SySetBasePtr(&sArg), (void *)&nCounter, TRUE);\r\n\t/* Return the length of the outputted string */\r\n\tjx9_result_int64(pCtx, nCounter);\r\n\t/* Release the container */\r\n\tSySetRelease(&sArg);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int vsprintf(string $format, array $args)\r\n *  Output a formatted string.\r\n * Parameters\r\n *  $format\r\n *   See sprintf() for a description of format.\r\n * Return\r\n *  A string produced according to the formatting string format.\r\n */\r\nstatic int jx9Builtin_vsprintf(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zFormat;\r\n\tjx9_hashmap *pMap;\r\n\tSySet sArg;\r\n\tint nLen, n;\r\n\tif( nArg < 2 || !jx9_value_is_string(apArg[0]) || !jx9_value_is_json_array(apArg[1]) ){\r\n\t\t/* Missing/Invalid arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the string format */\r\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to hashmap */\r\n\tpMap = (jx9_hashmap *)apArg[1]->x.pOther;\r\n\t/* Extract arguments from the hashmap */\r\n\tn = jx9HashmapValuesToSet(pMap, &sArg);\r\n\t/* Format the string */\r\n\tjx9InputFormat(sprintfConsumer, pCtx, zFormat, nLen, n, (jx9_value **)SySetBasePtr(&sArg), 0, TRUE);\r\n\t/* Release the container */\r\n\tSySetRelease(&sArg);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string size_format(int64 $size)\r\n *  Return a smart string represenation of the given size [i.e: 64-bit integer]\r\n *  Example:\r\n *    print size_format(1*1024*1024*1024);// 1GB\r\n *    print size_format(512*1024*1024); // 512 MB\r\n *    print size_format(file_size(/path/to/my/file_8192)); //8KB\r\n * Parameter\r\n *  $size\r\n *    Entity size in bytes.\r\n * Return\r\n *   Formatted string representation of the given size.\r\n */\r\nstatic int jx9Builtin_size_format(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\t/*Kilo*/ /*Mega*/ /*Giga*/ /*Tera*/ /*Peta*/ /*Exa*/ /*Zeta*/\r\n\tstatic const char zUnit[] = {\"KMGTPEZ\"};\r\n\tsxi32 nRest, i_32;\r\n\tjx9_int64 iSize;\r\n\tint c = -1; /* index in zUnit[] */\r\n\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing argument, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the given size */\r\n\tiSize = jx9_value_to_int64(apArg[0]);\r\n\tif( iSize < 100 /* Bytes */ ){\r\n\t\t/* Don't bother formatting, return immediately */\r\n\t\tjx9_result_string(pCtx, \"0.1 KB\", (int)sizeof(\"0.1 KB\")-1);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tfor(;;){\r\n\t\tnRest = (sxi32)(iSize & 0x3FF); \r\n\t\tiSize >>= 10;\r\n\t\tc++;\r\n\t\tif( (iSize & (~0 ^ 1023)) == 0 ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tnRest /= 100;\r\n\tif( nRest > 9 ){\r\n\t\tnRest = 9;\r\n\t}\r\n\tif( iSize > 999 ){\r\n\t\tc++;\r\n\t\tnRest = 9;\r\n\t\tiSize = 0;\r\n\t}\r\n\ti_32 = (sxi32)iSize;\r\n\t/* Format */\r\n\tjx9_result_string_format(pCtx, \"%d.%d %cB\", i_32, nRest, zUnit[c]);\r\n\treturn JX9_OK;\r\n}\r\n#if !defined(JX9_DISABLE_HASH_FUNC)\r\n/*\r\n * string md5(string $str[, bool $raw_output = false])\r\n *   Calculate the md5 hash of a string.\r\n * Parameter\r\n *  $str\r\n *   Input string\r\n * $raw_output\r\n *   If the optional raw_output is set to TRUE, then the md5 digest\r\n *   is instead returned in raw binary format with a length of 16.\r\n * Return\r\n *  MD5 Hash as a 32-character hexadecimal string.\r\n */\r\nstatic int jx9Builtin_md5(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tunsigned char zDigest[16];\r\n\tint raw_output = FALSE;\r\n\tconst void *pIn;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the input string */\r\n\tpIn = (const void *)jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 1 && jx9_value_is_bool(apArg[1])){\r\n\t\traw_output = jx9_value_to_bool(apArg[1]);\r\n\t}\r\n\t/* Compute the MD5 digest */\r\n\tSyMD5Compute(pIn, (sxu32)nLen, zDigest);\r\n\tif( raw_output ){\r\n\t\t/* Output raw digest */\r\n\t\tjx9_result_string(pCtx, (const char *)zDigest, (int)sizeof(zDigest));\r\n\t}else{\r\n\t\t/* Perform a binary to hex conversion */\r\n\t\tSyBinToHexConsumer((const void *)zDigest, sizeof(zDigest), HashConsumer, pCtx);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string sha1(string $str[, bool $raw_output = false])\r\n *   Calculate the sha1 hash of a string.\r\n * Parameter\r\n *  $str\r\n *   Input string\r\n * $raw_output\r\n *   If the optional raw_output is set to TRUE, then the md5 digest\r\n *   is instead returned in raw binary format with a length of 16.\r\n * Return\r\n *  SHA1 Hash as a 40-character hexadecimal string.\r\n */\r\nstatic int jx9Builtin_sha1(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tunsigned char zDigest[20];\r\n\tint raw_output = FALSE;\r\n\tconst void *pIn;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the input string */\r\n\tpIn = (const void *)jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 1 && jx9_value_is_bool(apArg[1])){\r\n\t\traw_output = jx9_value_to_bool(apArg[1]);\r\n\t}\r\n\t/* Compute the SHA1 digest */\r\n\tSySha1Compute(pIn, (sxu32)nLen, zDigest);\r\n\tif( raw_output ){\r\n\t\t/* Output raw digest */\r\n\t\tjx9_result_string(pCtx, (const char *)zDigest, (int)sizeof(zDigest));\r\n\t}else{\r\n\t\t/* Perform a binary to hex conversion */\r\n\t\tSyBinToHexConsumer((const void *)zDigest, sizeof(zDigest), HashConsumer, pCtx);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int64 crc32(string $str)\r\n *   Calculates the crc32 polynomial of a strin.\r\n * Parameter\r\n *  $str\r\n *   Input string\r\n * Return\r\n *  CRC32 checksum of the given input (64-bit integer).\r\n */\r\nstatic int jx9Builtin_crc32(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst void *pIn;\r\n\tsxu32 nCRC;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return 0 */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the input string */\r\n\tpIn = (const void *)jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Empty string */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Calculate the sum */\r\n\tnCRC = SyCrc32(pIn, (sxu32)nLen);\r\n\t/* Return the CRC32 as 64-bit integer */\r\n\tjx9_result_int64(pCtx, (jx9_int64)nCRC^ 0xFFFFFFFF);\r\n\treturn JX9_OK;\r\n}\r\n#endif /* JX9_DISABLE_HASH_FUNC */\r\n/*\r\n * Parse a CSV string and invoke the supplied callback for each processed xhunk.\r\n */\r\nJX9_PRIVATE sxi32 jx9ProcessCsv(\r\n\tconst char *zInput, /* Raw input */\r\n\tint nByte,  /* Input length */\r\n\tint delim,  /* Delimiter */\r\n\tint encl,   /* Enclosure */\r\n\tint escape,  /* Escape character */\r\n\tsxi32 (*xConsumer)(const char *, int, void *), /* User callback */\r\n\tvoid *pUserData /* Last argument to xConsumer() */\r\n\t)\r\n{\r\n\tconst char *zEnd = &zInput[nByte];\r\n\tconst char *zIn = zInput;\r\n\tconst char *zPtr;\r\n\tint isEnc;\r\n\t/* Start processing */\r\n\tfor(;;){\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tisEnc = 0;\r\n\t\tzPtr = zIn;\r\n\t\t/* Find the first delimiter */\r\n\t\twhile( zIn < zEnd ){\r\n\t\t\tif( zIn[0] == delim && !isEnc){\r\n\t\t\t\t/* Delimiter found, break imediately */\r\n\t\t\t\tbreak;\r\n\t\t\t}else if( zIn[0] == encl ){\r\n\t\t\t\t/* Inside enclosure? */\r\n\t\t\t\tisEnc = !isEnc;\r\n\t\t\t}else if( zIn[0] == escape ){\r\n\t\t\t\t/* Escape sequence */\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t\t/* Advance the cursor */\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zIn > zPtr ){\r\n\t\t\tint nByte = (int)(zIn-zPtr);\r\n\t\t\tsxi32 rc;\r\n\t\t\t/* Invoke the supllied callback */\r\n\t\t\tif( zPtr[0] == encl ){\r\n\t\t\t\tzPtr++;\r\n\t\t\t\tnByte-=2;\r\n\t\t\t}\r\n\t\t\tif( nByte > 0 ){\r\n\t\t\t\trc = xConsumer(zPtr, nByte, pUserData);\r\n\t\t\t\tif( rc == SXERR_ABORT ){\r\n\t\t\t\t\t/* User callback request an operation abort */\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* Ignore trailing delimiter */\r\n\t\twhile( zIn < zEnd && zIn[0] == delim ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t}\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * Default consumer callback for the CSV parsing routine defined above.\r\n * All the processed input is insereted into an array passed as the last\r\n * argument to this callback.\r\n */\r\nJX9_PRIVATE sxi32 jx9CsvConsumer(const char *zToken, int nTokenLen, void *pUserData)\r\n{\r\n\tjx9_value *pArray = (jx9_value *)pUserData;\r\n\tjx9_value sEntry;\r\n\tSyString sToken;\r\n\t/* Insert the token in the given array */\r\n\tSyStringInitFromBuf(&sToken, zToken, nTokenLen);\r\n\t/* Remove trailing and leading white spcaces and null bytes */\r\n\tSyStringFullTrimSafe(&sToken);\r\n\tif( sToken.nByte < 1){\r\n\t\treturn SXRET_OK;\r\n\t}\r\n\tjx9MemObjInitFromString(pArray->pVm, &sEntry, &sToken);\r\n\tjx9_array_add_elem(pArray, 0, &sEntry);\r\n\tjx9MemObjRelease(&sEntry);\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * array str_getcsv(string $input[, string $delimiter = ', '[, string $enclosure = '\"' [, string $escape='\\\\']]])\r\n *  Parse a CSV string into an array.\r\n * Parameters\r\n *  $input\r\n *   The string to parse.\r\n *  $delimiter\r\n *   Set the field delimiter (one character only).\r\n *  $enclosure\r\n *   Set the field enclosure character (one character only).\r\n *  $escape\r\n *   Set the escape character (one character only). Defaults as a backslash (\\)\r\n * Return\r\n *  An indexed array containing the CSV fields or NULL on failure.\r\n */\r\nstatic int jx9Builtin_str_getcsv(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zInput, *zPtr;\r\n\tjx9_value *pArray;\r\n\tint delim  = ',';   /* Delimiter */\r\n\tint encl   = '\"' ;  /* Enclosure */\r\n\tint escape = '\\\\';  /* Escape character */\r\n\tint nLen;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return NULL */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the raw input */\r\n\tzInput = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nArg > 1 ){\r\n\t\tint i;\r\n\t\tif( jx9_value_is_string(apArg[1]) ){\r\n\t\t\t/* Extract the delimiter */\r\n\t\t\tzPtr = jx9_value_to_string(apArg[1], &i);\r\n\t\t\tif( i > 0 ){\r\n\t\t\t\tdelim = zPtr[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( nArg > 2 ){\r\n\t\t\tif( jx9_value_is_string(apArg[2]) ){\r\n\t\t\t\t/* Extract the enclosure */\r\n\t\t\t\tzPtr = jx9_value_to_string(apArg[2], &i);\r\n\t\t\t\tif( i > 0 ){\r\n\t\t\t\t\tencl = zPtr[0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( nArg > 3 ){\r\n\t\t\t\tif( jx9_value_is_string(apArg[3]) ){\r\n\t\t\t\t\t/* Extract the escape character */\r\n\t\t\t\t\tzPtr = jx9_value_to_string(apArg[3], &i);\r\n\t\t\t\t\tif( i > 0 ){\r\n\t\t\t\t\t\tescape = zPtr[0];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Create our array */\r\n\tpArray = jx9_context_new_array(pCtx);\r\n\tif( pArray == 0 ){\r\n\t\tjx9_context_throw_error(pCtx, JX9_CTX_ERR, \"JX9 is running out of memory\");\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Parse the raw input */\r\n\tjx9ProcessCsv(zInput, nLen, delim, encl, escape, jx9CsvConsumer, pArray);\r\n\t/* Return the freshly created array */\r\n\tjx9_result_value(pCtx, pArray);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Extract a tag name from a raw HTML input and insert it in the given\r\n * container.\r\n * Refer to [strip_tags()].\r\n */\r\nstatic sxi32 AddTag(SySet *pSet, const char *zTag, int nByte)\r\n{\r\n\tconst char *zEnd = &zTag[nByte];\r\n\tconst char *zPtr;\r\n\tSyString sEntry;\r\n\t/* Strip tags */\r\n\tfor(;;){\r\n\t\twhile( zTag < zEnd && (zTag[0] == '<' || zTag[0] == '/' || zTag[0] == '?'\r\n\t\t\t|| zTag[0] == '!' || zTag[0] == '-' || ((unsigned char)zTag[0] < 0xc0 && SyisSpace(zTag[0]))) ){\r\n\t\t\t\tzTag++;\r\n\t\t}\r\n\t\tif( zTag >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzPtr = zTag;\r\n\t\t/* Delimit the tag */\r\n\t\twhile(zTag < zEnd ){\r\n\t\t\tif( (unsigned char)zTag[0] >= 0xc0 ){\r\n\t\t\t\t/* UTF-8 stream */\r\n\t\t\t\tzTag++;\r\n\t\t\t\tSX_JMP_UTF8(zTag, zEnd);\r\n\t\t\t}else if( !SyisAlphaNum(zTag[0]) ){\r\n\t\t\t\tbreak;\r\n\t\t\t}else{\r\n\t\t\t\tzTag++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( zTag > zPtr ){\r\n\t\t\t/* Perform the insertion */\r\n\t\t\tSyStringInitFromBuf(&sEntry, zPtr, (int)(zTag-zPtr));\r\n\t\t\tSyStringFullTrim(&sEntry);\r\n\t\t\tSySetPut(pSet, (const void *)&sEntry);\r\n\t\t}\r\n\t\t/* Jump the trailing '>' */\r\n\t\tzTag++;\r\n\t}\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * Check if the given HTML tag name is present in the given container.\r\n * Return SXRET_OK if present.SXERR_NOTFOUND otherwise.\r\n * Refer to [strip_tags()].\r\n */\r\nstatic sxi32 FindTag(SySet *pSet, const char *zTag, int nByte)\r\n{\r\n\tif( SySetUsed(pSet) > 0 ){\r\n\t\tconst char *zCur, *zEnd = &zTag[nByte];\r\n\t\tSyString sTag;\r\n\t\twhile( zTag < zEnd &&  (zTag[0] == '<' || zTag[0] == '/' || zTag[0] == '?' ||\r\n\t\t\t((unsigned char)zTag[0] < 0xc0 && SyisSpace(zTag[0]))) ){\r\n\t\t\tzTag++;\r\n\t\t}\r\n\t\t/* Delimit the tag */\r\n\t\tzCur = zTag;\r\n\t\twhile(zTag < zEnd ){\r\n\t\t\tif( (unsigned char)zTag[0] >= 0xc0 ){\r\n\t\t\t\t/* UTF-8 stream */\r\n\t\t\t\tzTag++;\r\n\t\t\t\tSX_JMP_UTF8(zTag, zEnd);\r\n\t\t\t}else if( !SyisAlphaNum(zTag[0]) ){\r\n\t\t\t\tbreak;\r\n\t\t\t}else{\r\n\t\t\t\tzTag++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSyStringInitFromBuf(&sTag, zCur, zTag-zCur);\r\n\t\t/* Trim leading white spaces and null bytes */\r\n\t\tSyStringLeftTrimSafe(&sTag);\r\n\t\tif( sTag.nByte > 0 ){\r\n\t\t\tSyString *aEntry, *pEntry;\r\n\t\t\tsxi32 rc;\r\n\t\t\tsxu32 n;\r\n\t\t\t/* Perform the lookup */\r\n\t\t\taEntry = (SyString *)SySetBasePtr(pSet);\r\n\t\t\tfor( n = 0 ; n < SySetUsed(pSet) ; ++n ){\r\n\t\t\t\tpEntry = &aEntry[n];\r\n\t\t\t\t/* Do the comparison */\r\n\t\t\t\trc = SyStringCmp(pEntry, &sTag, SyStrnicmp);\r\n\t\t\t\tif( !rc ){\r\n\t\t\t\t\treturn SXRET_OK;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* No such tag */\r\n\treturn SXERR_NOTFOUND;\r\n}\r\n/*\r\n * This function tries to return a string [i.e: in the call context result buffer]\r\n * with all NUL bytes, HTML and JX9 tags stripped from a given string.\r\n * Refer to [strip_tags()].\r\n */\r\nJX9_PRIVATE sxi32 jx9StripTagsFromString(jx9_context *pCtx, const char *zIn, int nByte, const char *zTaglist, int nTaglen)\r\n{\r\n\tconst char *zEnd = &zIn[nByte];\r\n\tconst char *zPtr, *zTag;\r\n\tSySet sSet;\r\n\t/* initialize the set of allowed tags */\r\n\tSySetInit(&sSet, &pCtx->pVm->sAllocator, sizeof(SyString));\r\n\tif( nTaglen > 0 ){\r\n\t\t/* Set of allowed tags */\r\n\t\tAddTag(&sSet, zTaglist, nTaglen);\r\n\t}\r\n\t/* Set the empty string */\r\n\tjx9_result_string(pCtx, \"\", 0);\r\n\t/* Start processing */\r\n\tfor(;;){\r\n\t\tif(zIn >= zEnd){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tzPtr = zIn;\r\n\t\t/* Find a tag */\r\n\t\twhile( zIn < zEnd && zIn[0] != '<' && zIn[0] != 0 /* NUL byte */ ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif( zIn > zPtr ){\r\n\t\t\t/* Consume raw input */\r\n\t\t\tjx9_result_string(pCtx, zPtr, (int)(zIn-zPtr));\r\n\t\t}\r\n\t\t/* Ignore trailing null bytes */\r\n\t\twhile( zIn < zEnd && zIn[0] == 0 ){\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t\tif(zIn >= zEnd){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif( zIn[0] == '<' ){\r\n\t\t\tsxi32 rc;\r\n\t\t\tzTag = zIn++;\r\n\t\t\t/* Delimit the tag */\r\n\t\t\twhile( zIn < zEnd && zIn[0] != '>' ){\r\n\t\t\t\tzIn++;\r\n\t\t\t}\r\n\t\t\tif( zIn < zEnd ){\r\n\t\t\t\tzIn++; /* Ignore the trailing closing tag */\r\n\t\t\t}\r\n\t\t\t/* Query the set */\r\n\t\t\trc = FindTag(&sSet, zTag, (int)(zIn-zTag));\r\n\t\t\tif( rc == SXRET_OK ){\r\n\t\t\t\t/* Keep the tag */\r\n\t\t\t\tjx9_result_string(pCtx, zTag, (int)(zIn-zTag));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Cleanup */\r\n\tSySetRelease(&sSet);\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * string strip_tags(string $str[, string $allowable_tags])\r\n *   Strip HTML and JX9 tags from a string.\r\n * Parameters\r\n *  $str\r\n *  The input string.\r\n * $allowable_tags\r\n *  You can use the optional second parameter to specify tags which should not be stripped. \r\n * Return\r\n *  Returns the stripped string.\r\n */\r\nstatic int jx9Builtin_strip_tags(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zTaglist = 0;\r\n\tconst char *zString;\r\n\tint nTaglen = 0;\r\n\tint nLen;\r\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\r\n\t\t/* Missing/Invalid arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the raw string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nArg > 1 && jx9_value_is_string(apArg[1]) ){\r\n\t\t/* Allowed tag */\r\n\t\tzTaglist = jx9_value_to_string(apArg[1], &nTaglen);\t\t\r\n\t}\r\n\t/* Process input */\r\n\tjx9StripTagsFromString(pCtx, zString, nLen, zTaglist, nTaglen);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * array str_split(string $string[, int $split_length = 1 ])\r\n *  Convert a string to an array.\r\n * Parameters\r\n * $str\r\n *  The input string.\r\n * $split_length\r\n *  Maximum length of the chunk.\r\n * Return\r\n *  If the optional split_length parameter is specified, the returned array\r\n *  will be broken down into chunks with each being split_length in length, otherwise\r\n *  each chunk will be one character in length. FALSE is returned if split_length is less than 1.\r\n *  If the split_length length exceeds the length of string, the entire string is returned \r\n *  as the first (and only) array element.\r\n */\r\nstatic int jx9Builtin_str_split(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zEnd;\r\n\tjx9_value *pArray, *pValue;\r\n\tint split_len;\r\n\tint nLen;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &nLen);\r\n\tif( nLen < 1 ){\r\n\t\t/* Nothing to process, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tsplit_len = (int)sizeof(char);\r\n\tif( nArg > 1 ){\r\n\t\t/* Split length */\r\n\t\tsplit_len = jx9_value_to_int(apArg[1]);\r\n\t\tif( split_len < 1 ){\r\n\t\t\t/* Invalid length, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tif( split_len > nLen ){\r\n\t\t\tsplit_len = nLen;\r\n\t\t}\r\n\t}\r\n\t/* Create the array and the scalar value */\r\n\tpArray = jx9_context_new_array(pCtx);\r\n\t/*Chunk value */\r\n\tpValue = jx9_context_new_scalar(pCtx);\r\n\tif( pValue == 0 || pArray == 0 ){\r\n\t\t/* Return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zString[nLen];\r\n\t/* Perform the requested operation */\r\n\tfor(;;){\r\n\t\tint nMax;\r\n\t\tif( zString >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tnMax = (int)(zEnd-zString);\r\n\t\tif( nMax < split_len ){\r\n\t\t\tsplit_len = nMax;\r\n\t\t}\r\n\t\t/* Copy the current chunk */\r\n\t\tjx9_value_string(pValue, zString, split_len);\r\n\t\t/* Insert it */\r\n\t\tjx9_array_add_elem(pArray, 0, pValue); /* Will make it's own copy */\r\n\t\t/* reset the string cursor */\r\n\t\tjx9_value_reset_string_cursor(pValue);\r\n\t\t/* Update position */\r\n\t\tzString += split_len;\r\n\t}\r\n\t/* \r\n\t * Return the array.\r\n\t * Don't worry about freeing memory, everything will be automatically released\r\n\t * upon we return from this function.\r\n\t */\r\n\tjx9_result_value(pCtx, pArray);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Tokenize a raw string and extract the first non-space token.\r\n * Refer to [strspn()].\r\n */\r\nstatic sxi32 ExtractNonSpaceToken(const char **pzIn, const char *zEnd, SyString *pOut)\r\n{\r\n\tconst char *zIn = *pzIn;\r\n\tconst char *zPtr;\r\n\t/* Ignore leading white spaces */\r\n\twhile( zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0]) ){\r\n\t\tzIn++;\r\n\t}\r\n\tif( zIn >= zEnd ){\r\n\t\t/* End of input */\r\n\t\treturn SXERR_EOF;\r\n\t}\r\n\tzPtr = zIn;\r\n\t/* Extract the token */\r\n\twhile( zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && !SyisSpace(zIn[0]) ){\r\n\t\tzIn++;\r\n\t}\r\n\tSyStringInitFromBuf(pOut, zPtr, zIn-zPtr);\r\n\t/* Synchronize pointers */\r\n\t*pzIn = zIn;\r\n\t/* Return to the caller */\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * Check if the given string contains only characters from the given mask.\r\n * return the longest match.\r\n * Refer to [strspn()].\r\n */\r\nstatic int LongestStringMask(const char *zString, int nLen, const char *zMask, int nMaskLen)\r\n{\r\n\tconst char *zEnd = &zString[nLen];\r\n\tconst char *zIn = zString;\r\n\tint i, c;\r\n\tfor(;;){\r\n\t\tif( zString >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Extract current character */\r\n\t\tc = zString[0];\r\n\t\t/* Perform the lookup */\r\n\t\tfor( i = 0 ; i < nMaskLen ; i++ ){\r\n\t\t\tif( c == zMask[i] ){\r\n\t\t\t\t/* Character found */\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( i >= nMaskLen ){\r\n\t\t\t/* Character not in the current mask, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Advance cursor */\r\n\t\tzString++;\r\n\t}\r\n\t/* Longest match */\r\n\treturn (int)(zString-zIn);\r\n}\r\n/*\r\n * Do the reverse operation of the previous function [i.e: LongestStringMask()].\r\n * Refer to [strcspn()].\r\n */\r\nstatic int LongestStringMask2(const char *zString, int nLen, const char *zMask, int nMaskLen)\r\n{\r\n\tconst char *zEnd = &zString[nLen];\r\n\tconst char *zIn = zString;\r\n\tint i, c;\r\n\tfor(;;){\r\n\t\tif( zString >= zEnd ){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Extract current character */\r\n\t\tc = zString[0];\r\n\t\t/* Perform the lookup */\r\n\t\tfor( i = 0 ; i < nMaskLen ; i++ ){\r\n\t\t\tif( c == zMask[i] ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( i < nMaskLen ){\r\n\t\t\t/* Character in the current mask, break immediately */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t/* Advance cursor */\r\n\t\tzString++;\r\n\t}\r\n\t/* Longest match */\r\n\treturn (int)(zString-zIn);\r\n}\r\n/*\r\n * int strspn(string $str, string $mask[, int $start[, int $length]])\r\n *  Finds the length of the initial segment of a string consisting entirely\r\n *  of characters contained within a given mask.\r\n * Parameters\r\n * $str\r\n *  The input string.\r\n * $mask\r\n *  The list of allowable characters.\r\n * $start\r\n *  The position in subject to start searching.\r\n *  If start is given and is non-negative, then strspn() will begin examining \r\n *  subject at the start'th position. For instance, in the string 'abcdef', the character\r\n *  at position 0 is 'a', the character at position 2 is 'c', and so forth.\r\n *  If start is given and is negative, then strspn() will begin examining subject at the\r\n *  start'th position from the end of subject.\r\n * $length\r\n *  The length of the segment from subject to examine.\r\n *  If length is given and is non-negative, then subject will be examined for length\r\n *  characters after the starting position.\r\n *  If lengthis given and is negative, then subject will be examined from the starting\r\n *  position up to length characters from the end of subject.\r\n * Return\r\n * Returns the length of the initial segment of subject which consists entirely of characters\r\n * in mask.\r\n */\r\nstatic int jx9Builtin_strspn(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zMask, *zEnd;\r\n\tint iMasklen, iLen;\r\n\tSyString sToken;\r\n\tint iCount = 0;\r\n\tint rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing agruments, return zero */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &iLen);\r\n\t/* Extract the mask */\r\n\tzMask = jx9_value_to_string(apArg[1], &iMasklen);\r\n\tif( iLen < 1 || iMasklen < 1 ){\r\n\t\t/* Nothing to process, return zero */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 2 ){\r\n\t\tint nOfft;\r\n\t\t/* Extract the offset */\r\n\t\tnOfft = jx9_value_to_int(apArg[2]);\r\n\t\tif( nOfft < 0 ){\r\n\t\t\tconst char *zBase = &zString[iLen + nOfft];\r\n\t\t\tif( zBase > zString ){\r\n\t\t\t\tiLen = (int)(&zString[iLen]-zBase);\r\n\t\t\t\tzString = zBase;\t\r\n\t\t\t}else{\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( nOfft >= iLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\t/* Update offset */\r\n\t\t\t\tzString += nOfft;\r\n\t\t\t\tiLen -= nOfft;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( nArg > 3 ){\r\n\t\t\tint iUserlen;\r\n\t\t\t/* Extract the desired length */\r\n\t\t\tiUserlen = jx9_value_to_int(apArg[3]);\r\n\t\t\tif( iUserlen > 0 && iUserlen < iLen ){\r\n\t\t\t\tiLen = iUserlen;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zString[iLen];\r\n\t/* Extract the first non-space token */\r\n\trc = ExtractNonSpaceToken(&zString, zEnd, &sToken);\r\n\tif( rc == SXRET_OK && sToken.nByte > 0 ){\r\n\t\t/* Compare against the current mask */\r\n\t\tiCount = LongestStringMask(sToken.zString, (int)sToken.nByte, zMask, iMasklen);\r\n\t}\r\n\t/* Longest match */\r\n\tjx9_result_int(pCtx, iCount);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * int strcspn(string $str, string $mask[, int $start[, int $length]])\r\n *  Find length of initial segment not matching mask.\r\n * Parameters\r\n * $str\r\n *  The input string.\r\n * $mask\r\n *  The list of not allowed characters.\r\n * $start\r\n *  The position in subject to start searching.\r\n *  If start is given and is non-negative, then strspn() will begin examining \r\n *  subject at the start'th position. For instance, in the string 'abcdef', the character\r\n *  at position 0 is 'a', the character at position 2 is 'c', and so forth.\r\n *  If start is given and is negative, then strspn() will begin examining subject at the\r\n *  start'th position from the end of subject.\r\n * $length\r\n *  The length of the segment from subject to examine.\r\n *  If length is given and is non-negative, then subject will be examined for length\r\n *  characters after the starting position.\r\n *  If lengthis given and is negative, then subject will be examined from the starting\r\n *  position up to length characters from the end of subject.\r\n * Return\r\n *  Returns the length of the segment as an integer.\r\n */\r\nstatic int jx9Builtin_strcspn(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zMask, *zEnd;\r\n\tint iMasklen, iLen;\r\n\tSyString sToken;\r\n\tint iCount = 0;\r\n\tint rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing agruments, return zero */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzString = jx9_value_to_string(apArg[0], &iLen);\r\n\t/* Extract the mask */\r\n\tzMask = jx9_value_to_string(apArg[1], &iMasklen);\r\n\tif( iLen < 1 ){\r\n\t\t/* Nothing to process, return zero */\r\n\t\tjx9_result_int(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( iMasklen < 1 ){\r\n\t\t/* No given mask, return the string length */\r\n\t\tjx9_result_int(pCtx, iLen);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tif( nArg > 2 ){\r\n\t\tint nOfft;\r\n\t\t/* Extract the offset */\r\n\t\tnOfft = jx9_value_to_int(apArg[2]);\r\n\t\tif( nOfft < 0 ){\r\n\t\t\tconst char *zBase = &zString[iLen + nOfft];\r\n\t\t\tif( zBase > zString ){\r\n\t\t\t\tiLen = (int)(&zString[iLen]-zBase);\r\n\t\t\t\tzString = zBase;\t\r\n\t\t\t}else{\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( nOfft >= iLen ){\r\n\t\t\t\t/* Invalid offset */\r\n\t\t\t\tjx9_result_int(pCtx, 0);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}else{\r\n\t\t\t\t/* Update offset */\r\n\t\t\t\tzString += nOfft;\r\n\t\t\t\tiLen -= nOfft;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( nArg > 3 ){\r\n\t\t\tint iUserlen;\r\n\t\t\t/* Extract the desired length */\r\n\t\t\tiUserlen = jx9_value_to_int(apArg[3]);\r\n\t\t\tif( iUserlen > 0 && iUserlen < iLen ){\r\n\t\t\t\tiLen = iUserlen;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zString[iLen];\r\n\t/* Extract the first non-space token */\r\n\trc = ExtractNonSpaceToken(&zString, zEnd, &sToken);\r\n\tif( rc == SXRET_OK && sToken.nByte > 0 ){\r\n\t\t/* Compare against the current mask */\r\n\t\tiCount = LongestStringMask2(sToken.zString, (int)sToken.nByte, zMask, iMasklen);\r\n\t}\r\n\t/* Longest match */\r\n\tjx9_result_int(pCtx, iCount);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strpbrk(string $haystack, string $char_list)\r\n *  Search a string for any of a set of characters.\r\n * Parameters\r\n *  $haystack\r\n *   The string where char_list is looked for.\r\n *  $char_list\r\n *   This parameter is case sensitive.\r\n * Return\r\n *  Returns a string starting from the character found, or FALSE if it is not found.\r\n */\r\nstatic int jx9Builtin_strpbrk(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zString, *zList, *zEnd;\r\n\tint iLen, iListLen, i, c;\r\n\tsxu32 nOfft, nMax;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the haystack and the char list */\r\n\tzString = jx9_value_to_string(apArg[0], &iLen);\r\n\tzList = jx9_value_to_string(apArg[1], &iListLen);\r\n\tif( iLen < 1 ){\r\n\t\t/* Nothing to process, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Point to the end of the string */\r\n\tzEnd = &zString[iLen];\r\n\tnOfft = nMax = SXU32_HIGH;\r\n\t/* perform the requested operation */\r\n\tfor( i = 0 ; i < iListLen ; i++ ){\r\n\t\tc = zList[i];\r\n\t\trc = SyByteFind(zString, (sxu32)iLen, c, &nMax);\r\n\t\tif( rc == SXRET_OK ){\r\n\t\t\tif( nMax < nOfft ){\r\n\t\t\t\tnOfft = nMax;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif( nOfft == SXU32_HIGH ){\r\n\t\t/* No such substring, return FALSE */\r\n\t\tjx9_result_bool(pCtx, 0);\r\n\t}else{\r\n\t\t/* Return the substring */\r\n\t\tjx9_result_string(pCtx, &zString[nOfft], (int)(zEnd-&zString[nOfft]));\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string soundex(string $str)\r\n *  Calculate the soundex key of a string.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * Return\r\n *  Returns the soundex key as a string.\r\n * Note:\r\n *  This implementation is based on the one found in the SQLite3\r\n * source tree.\r\n */\r\nstatic int jx9Builtin_soundex(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst unsigned char *zIn;\r\n\tchar zResult[8];\r\n\tint i, j;\r\n\tstatic const unsigned char iCode[] = {\r\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \r\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \r\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \r\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \r\n\t\t0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0, \r\n\t\t1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, \r\n\t\t0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0, \r\n\t\t1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, \r\n\t};\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tzIn = (unsigned char *)jx9_value_to_string(apArg[0], 0);\r\n\tfor(i=0; zIn[i] && zIn[i] < 0xc0 && !SyisAlpha(zIn[i]); i++){}\r\n\tif( zIn[i] ){\r\n\t\tunsigned char prevcode = iCode[zIn[i]&0x7f];\r\n\t\tzResult[0] = (char)SyToUpper(zIn[i]);\r\n\t\tfor(j=1; j<4 && zIn[i]; i++){\r\n\t\t\tint code = iCode[zIn[i]&0x7f];\r\n\t\t\tif( code>0 ){\r\n\t\t\t\tif( code!=prevcode ){\r\n\t\t\t\t\tprevcode = (unsigned char)code;\r\n\t\t\t\t\tzResult[j++] = (char)code + '0';\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tprevcode = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile( j<4 ){\r\n\t\t\tzResult[j++] = '0';\r\n\t\t}\r\n\t\tjx9_result_string(pCtx, zResult, 4);\r\n\t}else{\r\n\t  jx9_result_string(pCtx, \"?000\", 4);\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string wordwrap(string $str[, int $width = 75[, string $break = \"\\n\"]])\r\n *  Wraps a string to a given number of characters.\r\n * Parameters\r\n *  $str\r\n *   The input string.\r\n * $width\r\n *  The column width.\r\n * $break\r\n *  The line is broken using the optional break parameter.\r\n * Return\r\n *  Returns the given string wrapped at the specified column. \r\n */\r\nstatic int jx9Builtin_wordwrap(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tconst char *zIn, *zEnd, *zBreak;\r\n\tint iLen, iBreaklen, iChunk;\r\n\tif( nArg < 1 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the input string */\r\n\tzIn = jx9_value_to_string(apArg[0], &iLen);\r\n\tif( iLen < 1 ){\r\n\t\t/* Nothing to process, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Chunk length */\r\n\tiChunk = 75;\r\n\tiBreaklen = 0;\r\n\tzBreak = \"\"; /* cc warning */\r\n\tif( nArg > 1 ){\r\n\t\tiChunk = jx9_value_to_int(apArg[1]);\r\n\t\tif( iChunk < 1 ){\r\n\t\t\tiChunk = 75;\r\n\t\t}\r\n\t\tif( nArg > 2 ){\r\n\t\t\tzBreak = jx9_value_to_string(apArg[2], &iBreaklen);\r\n\t\t}\r\n\t}\r\n\tif( iBreaklen < 1 ){\r\n\t\t/* Set a default column break */\r\n#ifdef __WINNT__\r\n\t\tzBreak = \"\\r\\n\";\r\n\t\tiBreaklen = (int)sizeof(\"\\r\\n\")-1;\r\n#else\r\n\t\tzBreak = \"\\n\";\r\n\t\tiBreaklen = (int)sizeof(char);\r\n#endif\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tzEnd = &zIn[iLen];\r\n\tfor(;;){\r\n\t\tint nMax;\r\n\t\tif( zIn >= zEnd ){\r\n\t\t\t/* No more input to process */\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tnMax = (int)(zEnd-zIn);\r\n\t\tif( iChunk > nMax ){\r\n\t\t\tiChunk = nMax;\r\n\t\t}\r\n\t\t/* Append the column first */\r\n\t\tjx9_result_string(pCtx, zIn, iChunk); /* Will make it's own copy */\r\n\t\t/* Advance the cursor */\r\n\t\tzIn += iChunk;\r\n\t\tif( zIn < zEnd ){\r\n\t\t\t/* Append the line break */\r\n\t\t\tjx9_result_string(pCtx, zBreak, iBreaklen);\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * Check if the given character is a member of the given mask.\r\n * Return TRUE on success. FALSE otherwise.\r\n * Refer to [strtok()].\r\n */\r\nstatic int CheckMask(int c, const char *zMask, int nMasklen, int *pOfft)\r\n{\r\n\tint i;\r\n\tfor( i = 0 ; i < nMasklen ; ++i ){\r\n\t\tif( c == zMask[i] ){\r\n\t\t\tif( pOfft ){\r\n\t\t\t\t*pOfft = i;\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\treturn FALSE;\r\n}\r\n/*\r\n * Extract a single token from the input stream.\r\n * Refer to [strtok()].\r\n */\r\nstatic sxi32 ExtractToken(const char **pzIn, const char *zEnd, const char *zMask, int nMasklen, SyString *pOut)\r\n{\r\n\tconst char *zIn = *pzIn;\r\n\tconst char *zPtr;\r\n\t/* Ignore leading delimiter */\r\n\twhile( zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && CheckMask(zIn[0], zMask, nMasklen, 0) ){\r\n\t\tzIn++;\r\n\t}\r\n\tif( zIn >= zEnd ){\r\n\t\t/* End of input */\r\n\t\treturn SXERR_EOF;\r\n\t}\r\n\tzPtr = zIn;\r\n\t/* Extract the token */\r\n\twhile( zIn < zEnd ){\r\n\t\tif( (unsigned char)zIn[0] >= 0xc0 ){\r\n\t\t\t/* UTF-8 stream */\r\n\t\t\tzIn++;\r\n\t\t\tSX_JMP_UTF8(zIn, zEnd);\r\n\t\t}else{\r\n\t\t\tif( CheckMask(zIn[0], zMask, nMasklen, 0) ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tzIn++;\r\n\t\t}\r\n\t}\r\n\tSyStringInitFromBuf(pOut, zPtr, zIn-zPtr);\r\n\t/* Update the cursor */\r\n\t*pzIn = zIn;\r\n\t/* Return to the caller */\r\n\treturn SXRET_OK;\r\n}\r\n/* strtok auxiliary private data */\r\ntypedef struct strtok_aux_data strtok_aux_data;\r\nstruct strtok_aux_data\r\n{\r\n\tconst char *zDup;  /* Complete duplicate of the input */\r\n\tconst char *zIn;   /* Current input stream */\r\n\tconst char *zEnd;  /* End of input */\r\n};\r\n/*\r\n * string strtok(string $str, string $token)\r\n * string strtok(string $token)\r\n *  strtok() splits a string (str) into smaller strings (tokens), with each token\r\n *  being delimited by any character from token. That is, if you have a string like\r\n *  \"This is an example string\" you could tokenize this string into its individual\r\n *  words by using the space character as the token.\r\n *  Note that only the first call to strtok uses the string argument. Every subsequent\r\n *  call to strtok only needs the token to use, as it keeps track of where it is in \r\n *  the current string. To start over, or to tokenize a new string you simply call strtok\r\n *  with the string argument again to initialize it. Note that you may put multiple tokens\r\n *  in the token parameter. The string will be tokenized when any one of the characters in \r\n *  the argument are found. \r\n * Parameters\r\n *  $str\r\n *  The string being split up into smaller strings (tokens).\r\n * $token\r\n *  The delimiter used when splitting up str.\r\n * Return\r\n *   Current token or FALSE on EOF.\r\n */\r\nstatic int jx9Builtin_strtok(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tstrtok_aux_data *pAux;\r\n\tconst char *zMask;\r\n\tSyString sToken; \r\n\tint nMasklen;\r\n\tsxi32 rc;\r\n\tif( nArg < 2 ){\r\n\t\t/* Extract top aux data */\r\n\t\tpAux = (strtok_aux_data *)jx9_context_peek_aux_data(pCtx);\r\n\t\tif( pAux == 0 ){\r\n\t\t\t/* No aux data, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tnMasklen = 0;\r\n\t\tzMask = \"\"; /* cc warning */\r\n\t\tif( nArg > 0 ){\r\n\t\t\t/* Extract the mask */\r\n\t\t\tzMask = jx9_value_to_string(apArg[0], &nMasklen);\r\n\t\t}\r\n\t\tif( nMasklen < 1 ){\r\n\t\t\t/* Invalid mask, return FALSE */\r\n\t\t\tjx9_context_free_chunk(pCtx, (void *)pAux->zDup);\r\n\t\t\tjx9_context_free_chunk(pCtx, pAux);\r\n\t\t\t(void)jx9_context_pop_aux_data(pCtx);\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Extract the token */\r\n\t\trc = ExtractToken(&pAux->zIn, pAux->zEnd, zMask, nMasklen, &sToken);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* EOF , discard the aux data */\r\n\t\t\tjx9_context_free_chunk(pCtx, (void *)pAux->zDup);\r\n\t\t\tjx9_context_free_chunk(pCtx, pAux);\r\n\t\t\t(void)jx9_context_pop_aux_data(pCtx);\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t}else{\r\n\t\t\t/* Return the extracted token */\r\n\t\t\tjx9_result_string(pCtx, sToken.zString, (int)sToken.nByte);\r\n\t\t}\r\n\t}else{\r\n\t\tconst char *zInput, *zCur;\r\n\t\tchar *zDup;\r\n\t\tint nLen;\r\n\t\t/* Extract the raw input */\r\n\t\tzCur = zInput = jx9_value_to_string(apArg[0], &nLen);\r\n\t\tif( nLen < 1 ){\r\n\t\t\t/* Empty input, return FALSE */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\t/* Extract the mask */\r\n\t\tzMask = jx9_value_to_string(apArg[1], &nMasklen);\r\n\t\tif( nMasklen < 1 ){\r\n\t\t\t/* Set a default mask */\r\n#define TOK_MASK \" \\n\\t\\r\\f\" \r\n\t\t\tzMask = TOK_MASK;\r\n\t\t\tnMasklen = (int)sizeof(TOK_MASK) - 1;\r\n#undef TOK_MASK\r\n\t\t}\r\n\t\t/* Extract a single token */\r\n\t\trc = ExtractToken(&zInput, &zInput[nLen], zMask, nMasklen, &sToken);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Empty input */\r\n\t\t\tjx9_result_bool(pCtx, 0);\r\n\t\t\treturn JX9_OK;\r\n\t\t}else{\r\n\t\t\t/* Return the extracted token */\r\n\t\t\tjx9_result_string(pCtx, sToken.zString, (int)sToken.nByte);\r\n\t\t}\r\n\t\t/* Create our auxilliary data and copy the input */\r\n\t\tpAux = (strtok_aux_data *)jx9_context_alloc_chunk(pCtx, sizeof(strtok_aux_data), TRUE, FALSE);\r\n\t\tif( pAux ){\r\n\t\t\tnLen -= (int)(zInput-zCur);\r\n\t\t\tif( nLen < 1 ){\r\n\t\t\t\tjx9_context_free_chunk(pCtx, pAux);\r\n\t\t\t\treturn JX9_OK;\r\n\t\t\t}\r\n\t\t\t/* Duplicate input */\r\n\t\t\tzDup = (char *)jx9_context_alloc_chunk(pCtx, (unsigned int)(nLen+1), TRUE, FALSE);\r\n\t\t\tif( zDup  ){\r\n\t\t\t\tSyMemcpy(zInput, zDup, (sxu32)nLen);\r\n\t\t\t\t/* Register the aux data */\r\n\t\t\t\tpAux->zDup = pAux->zIn = zDup;\r\n\t\t\t\tpAux->zEnd = &zDup[nLen];\r\n\t\t\t\tjx9_context_push_aux_data(pCtx, pAux);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string str_pad(string $input, int $pad_length[, string $pad_string = \" \" [, int $pad_type = STR_PAD_RIGHT]])\r\n *  Pad a string to a certain length with another string\r\n * Parameters\r\n *  $input\r\n *   The input string.\r\n * $pad_length\r\n *   If the value of pad_length is negative, less than, or equal to the length of the input \r\n *   string, no padding takes place.\r\n * $pad_string\r\n *   Note:\r\n *    The pad_string WIIL NOT BE truncated if the required number of padding characters can't be evenly\r\n *    divided by the pad_string's length.\r\n * $pad_type\r\n *    Optional argument pad_type can be STR_PAD_RIGHT, STR_PAD_LEFT, or STR_PAD_BOTH. If pad_type\r\n *    is not specified it is assumed to be STR_PAD_RIGHT.\r\n * Return\r\n *  The padded string.\r\n */\r\nstatic int jx9Builtin_str_pad(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tint iLen, iPadlen, iType, i, iDiv, iStrpad, iRealPad, jPad;\r\n\tconst char *zIn, *zPad;\r\n\tif( nArg < 2 ){\r\n\t\t/* Missing arguments, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target string */\r\n\tzIn = jx9_value_to_string(apArg[0], &iLen);\r\n\t/* Padding length */\r\n\tiRealPad = iPadlen = jx9_value_to_int(apArg[1]);\r\n\tif( iPadlen > 0 ){\r\n\t\tiPadlen -= iLen;\r\n\t}\r\n\tif( iPadlen < 1  ){\r\n\t\t/* Return the string verbatim */\r\n\t\tjx9_result_string(pCtx, zIn, iLen);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\tzPad = \" \"; /* Whitespace padding */\r\n\tiStrpad = (int)sizeof(char);\r\n\tiType = 1 ; /* STR_PAD_RIGHT */\r\n\tif( nArg > 2 ){\r\n\t\t/* Padding string */\r\n\t\tzPad = jx9_value_to_string(apArg[2], &iStrpad);\r\n\t\tif( iStrpad < 1 ){\r\n\t\t\t/* Empty string */\r\n\t\t\tzPad = \" \"; /* Whitespace padding */\r\n\t\t\tiStrpad = (int)sizeof(char);\r\n\t\t}\r\n\t\tif( nArg > 3 ){\r\n\t\t\t/* Padd type */\r\n\t\t\tiType = jx9_value_to_int(apArg[3]);\r\n\t\t\tif( iType != 0 /* STR_PAD_LEFT */ && iType != 2 /* STR_PAD_BOTH */ ){\r\n\t\t\t\tiType = 1 ; /* STR_PAD_RIGHT */\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tiDiv = 1;\r\n\tif( iType == 2 ){\r\n\t\tiDiv = 2; /* STR_PAD_BOTH */\r\n\t}\r\n\t/* Perform the requested operation */\r\n\tif( iType == 0 /* STR_PAD_LEFT */ || iType == 2 /* STR_PAD_BOTH */ ){\r\n\t\tjPad = iStrpad;\r\n\t\tfor( i = 0 ; i < iPadlen/iDiv ; i += jPad ){\r\n\t\t\t/* Padding */\r\n\t\t\tif( (int)jx9_context_result_buf_length(pCtx) + iLen + jPad >= iRealPad ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tjx9_result_string(pCtx, zPad, jPad);\r\n\t\t}\r\n\t\tif( iType == 0 /* STR_PAD_LEFT */ ){\r\n\t\t\twhile( (int)jx9_context_result_buf_length(pCtx) + iLen < iRealPad ){\r\n\t\t\t\tjPad = iRealPad - (iLen + (int)jx9_context_result_buf_length(pCtx) );\r\n\t\t\t\tif( jPad > iStrpad ){\r\n\t\t\t\t\tjPad = iStrpad;\r\n\t\t\t\t}\r\n\t\t\t\tif( jPad < 1){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tjx9_result_string(pCtx, zPad, jPad);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif( iLen > 0 ){\r\n\t\t/* Append the input string */\r\n\t\tjx9_result_string(pCtx, zIn, iLen);\r\n\t}\r\n\tif( iType == 1 /* STR_PAD_RIGHT */ || iType == 2 /* STR_PAD_BOTH */ ){\r\n\t\tfor( i = 0 ; i < iPadlen/iDiv ; i += iStrpad ){\r\n\t\t\t/* Padding */\r\n\t\t\tif( (int)jx9_context_result_buf_length(pCtx) + iStrpad >= iRealPad ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tjx9_result_string(pCtx, zPad, iStrpad);\r\n\t\t}\r\n\t\twhile( (int)jx9_context_result_buf_length(pCtx) < iRealPad ){\r\n\t\t\tjPad = iRealPad - (int)jx9_context_result_buf_length(pCtx);\r\n\t\t\tif( jPad > iStrpad ){\r\n\t\t\t\tjPad = iStrpad;\r\n\t\t\t}\r\n\t\t\tif( jPad < 1){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tjx9_result_string(pCtx, zPad, jPad);\r\n\t\t}\r\n\t}\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * String replacement private data.\r\n */\r\ntypedef struct str_replace_data str_replace_data;\r\nstruct str_replace_data\r\n{\r\n\t/* The following two fields are only used by the strtr function */\r\n\tSyBlob *pWorker;         /* Working buffer */\r\n\tProcStringMatch xMatch;  /* Pattern match routine */\r\n\t/* The following two fields are only used by the str_replace function */\r\n\tSySet *pCollector;  /* Argument collector*/\r\n\tjx9_context *pCtx;  /* Call context */\r\n};\r\n/*\r\n * Remove a substring.\r\n */\r\n#define STRDEL(SRC, SLEN, OFFT, ILEN){\\\r\n\tfor(;;){\\\r\n\t\tif( OFFT + ILEN >= SLEN ) break; SRC[OFFT] = SRC[OFFT+ILEN]; ++OFFT;\\\r\n\t}\\\r\n}\r\n/*\r\n * Shift right and insert algorithm.\r\n */\r\n#define SHIFTRANDINSERT(SRC, LEN, OFFT, ENTRY, ELEN){\\\r\n\tsxu32 INLEN = LEN - OFFT;\\\r\n\tfor(;;){\\\r\n\t  if( LEN > 0 ){ LEN--; } if(INLEN < 1 ) break; SRC[LEN + ELEN] = SRC[LEN] ; --INLEN; \\\r\n\t}\\\r\n\tfor(;;){\\\r\n\t\tif(ELEN < 1)break; SRC[OFFT] = ENTRY[0]; OFFT++; ENTRY++; --ELEN;\\\r\n\t}\\\r\n} \r\n/*\r\n * Replace all occurrences of the search string at offset (nOfft) with the given \r\n * replacement string [i.e: zReplace].\r\n */\r\nstatic int StringReplace(SyBlob *pWorker, sxu32 nOfft, int nLen, const char *zReplace, int nReplen)\r\n{\r\n\tchar *zInput = (char *)SyBlobData(pWorker);\r\n\tsxu32 n, m;\r\n\tn = SyBlobLength(pWorker);\r\n\tm = nOfft;\r\n\t/* Delete the old entry */\r\n\tSTRDEL(zInput, n, m, nLen);\r\n\tSyBlobLength(pWorker) -= nLen;\r\n\tif( nReplen > 0 ){\r\n\t\tsxi32 iRep = nReplen;\r\n\t\tsxi32 rc;\r\n\t\t/*\r\n\t\t * Make sure the working buffer is big enough to hold the replacement\r\n\t\t * string.\r\n\t\t */\r\n\t\trc = SyBlobAppend(pWorker, 0/* Grow without an append operation*/, (sxu32)nReplen);\r\n\t\tif( rc != SXRET_OK ){\r\n\t\t\t/* Simply ignore any memory failure problem */\r\n\t\t\treturn SXRET_OK;\r\n\t\t}\r\n\t\t/* Perform the insertion now */\r\n\t\tzInput = (char *)SyBlobData(pWorker);\r\n\t\tn = SyBlobLength(pWorker);\r\n\t\tSHIFTRANDINSERT(zInput, n, nOfft, zReplace, iRep);\r\n\t\tSyBlobLength(pWorker) += nReplen;\r\n\t}\t\r\n\treturn SXRET_OK;\r\n}\r\n/*\r\n * String replacement walker callback.\r\n * The following callback is invoked for each array entry that hold\r\n * the replace string.\r\n * Refer to the strtr() implementation for more information.\r\n */\r\nstatic int StringReplaceWalker(jx9_value *pKey, jx9_value *pData, void *pUserData)\r\n{\r\n\tstr_replace_data *pRepData = (str_replace_data *)pUserData;\r\n\tconst char *zTarget, *zReplace;\r\n\tSyBlob *pWorker;\r\n\tint tLen, nLen;\r\n\tsxu32 nOfft;\r\n\tsxi32 rc;\r\n\t/* Point to the working buffer */\r\n\tpWorker = pRepData->pWorker;\r\n\tif( !jx9_value_is_string(pKey) ){\r\n\t\t/* Target and replace must be a string */\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the target and the replace */\r\n\tzTarget = jx9_value_to_string(pKey, &tLen);\r\n\tif( tLen < 1 ){\r\n\t\t/* Empty target, return immediately */\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Perform a pattern search */\r\n\trc = pRepData->xMatch(SyBlobData(pWorker), SyBlobLength(pWorker), (const void *)zTarget, (sxu32)tLen, &nOfft);\r\n\tif( rc != SXRET_OK ){\r\n\t\t/* Pattern not found */\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Extract the replace string */\r\n\tzReplace = jx9_value_to_string(pData, &nLen);\r\n\t/* Perform the replace process */\r\n\tStringReplace(pWorker, nOfft, tLen, zReplace, nLen);\r\n\t/* All done */\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * The following walker callback is invoked by the str_rplace() function inorder\r\n * to collect search/replace string.\r\n * This callback is invoked only if the given argument is of type array.\r\n */\r\nstatic int StrReplaceWalker(jx9_value *pKey, jx9_value *pData, void *pUserData)\r\n{\r\n\tstr_replace_data *pRep = (str_replace_data *)pUserData;\r\n\tSyString sWorker;\r\n\tconst char *zIn;\r\n\tint nByte;\r\n\t/* Extract a string representation of the given argument */\r\n\tzIn = jx9_value_to_string(pData, &nByte);\r\n\tSyStringInitFromBuf(&sWorker, 0, 0);\r\n\tif( nByte > 0 ){\r\n\t\tchar *zDup;\r\n\t\t/* Duplicate the chunk */\r\n\t\tzDup = (char *)jx9_context_alloc_chunk(pRep->pCtx, (unsigned int)nByte, FALSE, \r\n\t\t\tTRUE /* Release the chunk automatically, upon this context is destroyd */\r\n\t\t\t);\r\n\t\tif( zDup == 0 ){\r\n\t\t\t/* Ignore any memory failure problem */\r\n\t\t\tjx9_context_throw_error(pRep->pCtx, JX9_CTX_ERR, \"JX9 is running out of memory\");\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tSyMemcpy(zIn, zDup, (sxu32)nByte);\r\n\t\t/* Save the chunk */\r\n\t\tSyStringInitFromBuf(&sWorker, zDup, nByte);\r\n\t}\r\n\t/* Save for later processing */\r\n\tSySetPut(pRep->pCollector, (const void *)&sWorker);\r\n\t/* All done */\r\n\tSXUNUSED(pKey); /* cc warning */\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * mixed str_replace(mixed $search, mixed $replace, mixed $subject[, int &$count ])\r\n * mixed str_ireplace(mixed $search, mixed $replace, mixed $subject[, int &$count ])\r\n *  Replace all occurrences of the search string with the replacement string.\r\n * Parameters\r\n *  If search and replace are arrays, then str_replace() takes a value from each\r\n *  array and uses them to search and replace on subject. If replace has fewer values\r\n *  than search, then an empty string is used for the rest of replacement values.\r\n *  If search is an array and replace is a string, then this replacement string is used\r\n *  for every value of search. The converse would not make sense, though.\r\n *  If search or replace are arrays, their elements are processed first to last.\r\n * $search\r\n *  The value being searched for, otherwise known as the needle. An array may be used\r\n *  to designate multiple needles.\r\n * $replace\r\n *  The replacement value that replaces found search values. An array may be used\r\n *  to designate multiple replacements.\r\n * $subject\r\n *  The string or array being searched and replaced on, otherwise known as the haystack.\r\n *  If subject is an array, then the search and replace is performed with every entry \r\n *  of subject, and the return value is an array as well.\r\n * $count (Not used)\r\n *  If passed, this will be set to the number of replacements performed.\r\n * Return\r\n * This function returns a string or an array with the replaced values.\r\n */\r\nstatic int jx9Builtin_str_replace(jx9_context *pCtx, int nArg, jx9_value **apArg)\r\n{\r\n\tSyString sTemp, *pSearch, *pReplace;\r\n\tProcStringMatch xMatch;\r\n\tconst char *zIn, *zFunc;\r\n\tstr_replace_data sRep;\r\n\tSyBlob sWorker;\r\n\tSySet sReplace;\r\n\tSySet sSearch;\r\n\tint rep_str;\r\n\tint nByte;\r\n\tsxi32 rc;\r\n\tif( nArg < 3 ){\r\n\t\t/* Missing/Invalid arguments, return null */\r\n\t\tjx9_result_null(pCtx);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Initialize fields */\r\n\tSySetInit(&sSearch, &pCtx->pVm->sAllocator, sizeof(SyString));\r\n\tSySetInit(&sReplace, &pCtx->pVm->sAllocator, sizeof(SyString));\r\n\tSyBlobInit(&sWorker, &pCtx->pVm->sAllocator);\r\n\tSyZero(&sRep, sizeof(str_replace_data));\r\n\tsRep.pCtx = pCtx;\r\n\tsRep.pCollector = &sSearch;\r\n\trep_str = 0;\r\n\t/* Extract the subject */\r\n\tzIn = jx9_value_to_string(apArg[2], &nByte);\r\n\tif( nByte < 1 ){\r\n\t\t/* Nothing to replace, return the empty string */\r\n\t\tjx9_result_string(pCtx, \"\", 0);\r\n\t\treturn JX9_OK;\r\n\t}\r\n\t/* Copy the subject */\r\n\tSyBlobAppend(&sWorker, (const void *)zIn, (sxu32)nByte);\r\n\t/* Search string */\r\n\tif( jx9_value_is_json_array(apArg[0]) ){\r\n\t\t/* Collect search string */\r\n\t\tjx9_array_walk(apArg[0], StrReplaceWalker, &sRep);\r\n\t}else{\r\n\t\t/* Single pattern */\r\n\t\tzIn = jx9_value_to_string(apArg[0], &nByte);\r\n\t\tif( nByte < 1 ){\r\n\t\t\t/* Return the subject untouched since no search string is available */\r\n\t\t\tjx9_result_value(pCtx, apArg[2]/* Subject as thrird argument*/);\r\n\t\t\treturn JX9_OK;\r\n\t\t}\r\n\t\tSyStringInitFromBuf(&sTemp, zIn, nByte);\r\n\t\t/* Save for later processing */\r\n\t\tSySetPut(&sSearch, (const void *)&sTemp);\r\n\t}\r\n\t/* Replace string */\r\n\tif( jx9_value_is_json_array(apArg[1]) ){\r\n\t\t/* Collect replace string */\r\n\t\tsRep.pCollector = &sReplace;\r\n\t\tjx9_array_walk(apArg[1], StrReplaceWalker, &sRep);\r\n\t}else{\r\n\t\t/* Single needle */\r\n\t\tzIn = jx9_value_to_string(apArg[1], &nByte);\r\n\t\trep_str = 1;\r\n\t\tSyStringInitFromBuf(&sTemp, zIn, nByte);\r\n\t\t/* Save for later processing */\r\n\t\tSySetPut(&sReplace, (const void *)&sTemp);\r\n\t}\r\n\t/* Reset loop cursors */\r\n\tSySetResetCursor(&sSearch);\r\n\tSySetResetCursor(&sReplace);\r\n\tpReplace = pSearch = 0; /* cc warning */\r\n\tSyStringInitFromBuf(&sTemp, \"\", 0);\r\n\t/* Extract function name */\r\n\tzFunc = jx9_function_name(pCtx);\r\n\t/* Set the default pattern match routine */\r\n\txMatch = SyBlobSearch;\r\n\tif( SyStrncmp(zFunc, \"str_ireplace\", sizeof(\"str_ireplace\") - 1) ==  0 ){\r\n\t\t/* Case insensitive pattern match */\r\n\t\txMatch = iPatternMatch;\r\n\t}\r\n\t/* Start the replace process */\r\n\twhile( SXRET_OK == SySetGetNextEntry(&sSearch, (void **)&pSearch) ){\r\n\t\tsxu32 nCount, nOfft;\r\n\t\tif( pSearch->nByte <  1 ){\r\n\t\t\t/* Empty string, ignore */\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t/* Extract the replace string */\r\n\t\tif( rep_str ){\r\n\t\t\tpReplace = (SyString *)SySetPeek(&sReplace);\r\n\t\t}else{\r\n\t\t\tif( SXRET_OK != SySetGetNextEntry(&sReplace, (void **)&pReplace) ){\r\n\t\t\t\t/* Sepecial case when 'replace set' has fewer values than the search set.\r\n\t\t\t\t * An empty string is used for the rest of replacement values\r\n\t\t\t\t */\r\n\t\t\t\tpReplace = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( pReplace == 0 ){\r\n\t\t\t/* Use an empty string instead */\r\n\t\t\tpReplace = &sTemp;\r\n\t\t}\r\n\t\tnOfft = nCount = 0;\r\n\t\tfor(;;){\r\n\t\t\tif( nCount >= SyBlobLength(&sWorker) ){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Perform a pattern lookup */\r\n\t\t\trc = xMatch(SyBlobDataAt(&sWorker, nCount), SyBlobLength(&sWorker) - nCount, (const void *)pSearch->zString, \r\n\t\t\t\tpSearch->nByte, &nOfft);\r\n\t\t\tif( rc != SXRET_OK ){\r\n\t\t\t\t/* Pattern not found */\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t/* Perform the replace operation */\r\n\t\t\tStringReplace(&sWorker, nCount+nOfft, (int)pSearch->nByte, pReplace->zString, (int)pReplace->nByte);\r\n\t\t\t/* Increment offset counter */\r\n\t\t\tnCount += nOfft + pReplace->nByte;\r\n\t\t}\r\n\t}\r\n\t/* All done, clean-up the mess left behind */\r\n\tjx9_result_string(pCtx, (const char *)SyBlobData(&sWorker), (int)SyBlobLength(&sWorker));\r\n\tSySetRelease(&sSearch);\r\n\tSySetRelease(&sReplace);\r\n\tSyBlobRelease(&sWorker);\r\n\treturn JX9_OK;\r\n}\r\n/*\r\n * string strtr(string $str, string $from, string $to)\r\n * string strtr(string $str, array $replace_pairs)\r\n *  Translate characters or replace substrings.\r\n * Parameters\r\n *  $str\r\n *  The string being translated.\r\n * $from\r\n *  The string being translated to to.\r\n * $to\r\n *  The string replacing from.\r\n * $replace_pairs\r\n *  The replace_pairs parameter may be used instead o"
        },
        {
          "name": "unqlite.h",
          "type": "blob",
          "size": 47.56640625,
          "content": "/* This file was automatically generated.  Do not edit (Except for compile time directives)! */ \n#ifndef _UNQLITE_H_\n#define _UNQLITE_H_\n/* Make sure we can call this stuff from C++ */\n#ifdef __cplusplus\n extern \"C\" {\n#endif \n/*\n * Symisc UnQLite: An Embeddable NoSQL (Post Modern) Database Engine.\n * Copyright (C) 2012-2019, Symisc Systems http://unqlite.org/\n * Version 1.1.9\n * For information on licensing, redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES\n * please contact Symisc Systems via:\n *       legal@symisc.net\n *       licensing@symisc.net\n *       contact@symisc.net\n * or visit:\n *      http://unqlite.org/licensing.html\n */\n/*\n * Copyright (C) 2012, 2019 Symisc Systems, S.U.A.R.L [M.I.A.G Mrad Chems Eddine <chm@symisc.net>].\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY SYMISC SYSTEMS ``AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR\n * NON-INFRINGEMENT, ARE DISCLAIMED.  IN NO EVENT SHALL SYMISC SYSTEMS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n /* $SymiscID: unqlite.h v1.3 Win10 2108-04-27 02:35:11 stable <chm@symisc.net>  $ */\n#include <stdarg.h> /* needed for the definition of va_list */\n/*\n * Compile time engine version, signature, identification in the symisc source tree\n * and copyright notice.\n * Each macro have an equivalent C interface associated with it that provide the same\n * information but are associated with the library instead of the header file.\n * Refer to [unqlite_lib_version()], [unqlite_lib_signature()], [unqlite_lib_ident()] and\n * [unqlite_lib_copyright()] for more information.\n */\n/*\n * The UNQLITE_VERSION C preprocessor macro evaluates to a string literal\n * that is the unqlite version in the format \"X.Y.Z\" where X is the major\n * version number and Y is the minor version number and Z is the release\n * number.\n */\n#define UNQLITE_VERSION \"1.1.9\"\n/*\n * The UNQLITE_VERSION_NUMBER C preprocessor macro resolves to an integer\n * with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same\n * numbers used in [UNQLITE_VERSION].\n */\n#define UNQLITE_VERSION_NUMBER 1001009\n/*\n * The UNQLITE_SIG C preprocessor macro evaluates to a string\n * literal which is the public signature of the unqlite engine.\n * This signature could be included for example in a host-application\n * generated Server MIME header as follows:\n *   Server: YourWebServer/x.x unqlite/x.x.x \\r\\n\n */\n#define UNQLITE_SIG \"unqlite/1.1.9\"\n/*\n * UnQLite identification in the Symisc source tree:\n * Each particular check-in of a particular software released\n * by symisc systems have an unique identifier associated with it.\n * This macro hold the one associated with unqlite.\n */\n#define UNQLITE_IDENT \"unqlite:29c173b1-ac2c-4b49-93ba-e600619e304e\"\n/*\n * Copyright notice.\n * If you have any questions about the licensing situation, please\n * visit http://unqlite.org/licensing.html\n * or contact Symisc Systems via:\n *   legal@symisc.net\n *   licensing@symisc.net\n *   contact@symisc.net\n */\n#define UNQLITE_COPYRIGHT \"Copyright (C) Symisc Systems, S.U.A.R.L [Mrad Chems Eddine <chm@symisc.net>] 2012-2019, http://unqlite.org/\"\n\n/* Forward declaration to public objects */\ntypedef struct unqlite_io_methods unqlite_io_methods;\ntypedef struct unqlite_kv_methods unqlite_kv_methods;\ntypedef struct unqlite_kv_engine unqlite_kv_engine;\ntypedef struct jx9_io_stream unqlite_io_stream;\ntypedef struct jx9_context unqlite_context;\ntypedef struct jx9_value unqlite_value;\ntypedef struct unqlite_vfs unqlite_vfs;\ntypedef struct unqlite_vm unqlite_vm;\ntypedef struct unqlite unqlite;\n/*\n * ------------------------------\n * Compile time directives\n * ------------------------------\n * For most purposes, UnQLite can be built just fine using the default compilation options.\n * However, if required, the compile-time options documented below can be used to omit UnQLite\n * features (resulting in a smaller compiled library size) or to change the default values\n * of some parameters.\n * Every effort has been made to ensure that the various combinations of compilation options\n * work harmoniously and produce a working library.\n *\n * UNQLITE_ENABLE_THREADS\n *  This option controls whether or not code is included in UnQLite to enable it to operate\n *  safely in a multithreaded environment. The default is not. All mutexing code is omitted\n *  and it is unsafe to use UnQLite in a multithreaded program. When compiled with the\n *  UNQLITE_ENABLE_THREADS directive enabled, UnQLite can be used in a multithreaded program\n *  and it is safe to share the same virtual machine and engine handle between two or more threads.\n *  The value of UNQLITE_ENABLE_THREADS can be determined at run-time using the unqlite_lib_is_threadsafe()\n *  interface.\n *  When UnQLite has been compiled with threading support then the threading mode can be altered\n * at run-time using the unqlite_lib_config() interface together with one of these verbs:\n *    UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE\n *    UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI\n *  Platforms others than Windows and UNIX systems must install their own mutex subsystem via \n *  unqlite_lib_config() with a configuration verb set to UNQLITE_LIB_CONFIG_USER_MUTEX.\n *  Otherwise the library is not threadsafe.\n *  Note that you must link UnQLite with the POSIX threads library under UNIX systems (i.e: -lpthread).\n *\n * Options To Omit/Enable Features\n *\n * The following options can be used to reduce the size of the compiled library by omitting optional\n * features. This is probably only useful in embedded systems where space is especially tight, as even\n * with all features included the UnQLite library is relatively small. Don't forget to tell your\n * compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler\n * to optimize for size usually has a much larger impact on library footprint than employing\n * any of these compile-time options.\n *\n * JX9_DISABLE_BUILTIN_FUNC\n *  Jx9 is shipped with more than 312 built-in functions suitable for most purposes like \n *  string and INI processing, ZIP extracting, Base64 encoding/decoding, JSON encoding/decoding\n *  and so forth.\n *  If this directive is enabled, then all built-in Jx9 functions are omitted from the build.\n *  Note that special functions such as db_create(), db_store(), db_fetch(), etc. are not omitted\n *  from the build and are not affected by this directive.\n *\n * JX9_ENABLE_MATH_FUNC\n *  If this directive is enabled, built-in math functions such as sqrt(), abs(), log(), ceil(), etc.\n *  are included in the build. Note that you may need to link UnQLite with the math library in same\n *  Linux/BSD flavor (i.e: -lm).\n *\n * JX9_DISABLE_DISK_IO\n *  If this directive is enabled, built-in VFS functions such as chdir(), mkdir(), chroot(), unlink(),\n *  sleep(), etc. are omitted from the build.\n *\n * UNQLITE_ENABLE_JX9_HASH_IO\n * If this directive is enabled, built-in hash functions such as md5(), sha1(), md5_file(), crc32(), etc.\n * are included in the build.\n */\n/* Symisc public definitions */\n#if !defined(SYMISC_STANDARD_DEFS)\n#define SYMISC_STANDARD_DEFS\n#if defined (_WIN32) || defined (WIN32) || defined(__MINGW32__) || defined (_MSC_VER) || defined (_WIN32_WCE)\n/* Windows Systems */\n#if !defined(__WINNT__)\n#define __WINNT__\n#endif \n/*\n * Determine if we are dealing with WindowsCE - which has a much\n * reduced API.\n */\n#if defined(_WIN32_WCE)\n#ifndef __WIN_CE__\n#define __WIN_CE__\n#endif /* __WIN_CE__ */\n#endif /* _WIN32_WCE */\n#else\n/*\n * By default we will assume that we are compiling on a UNIX systems.\n * Otherwise the OS_OTHER directive must be defined.\n */\n#if !defined(OS_OTHER)\n#if !defined(__UNIXES__)\n#define __UNIXES__\n#endif /* __UNIXES__ */\n#else\n#endif /* OS_OTHER */\n#endif /* __WINNT__/__UNIXES__ */\n#if defined(_MSC_VER) || defined(__BORLANDC__)\ntypedef signed __int64     sxi64; /* 64 bits(8 bytes) signed int64 */\ntypedef unsigned __int64   sxu64; /* 64 bits(8 bytes) unsigned int64 */\n#else\ntypedef signed long long int   sxi64; /* 64 bits(8 bytes) signed int64 */\ntypedef unsigned long long int sxu64; /* 64 bits(8 bytes) unsigned int64 */\n#endif /* _MSC_VER */\n/* Signature of the consumer routine */\ntypedef int (*ProcConsumer)(const void *, unsigned int, void *);\n/* Forward reference */\ntypedef struct SyMutexMethods SyMutexMethods;\ntypedef struct SyMemMethods SyMemMethods;\ntypedef struct SyString SyString;\ntypedef struct syiovec syiovec;\ntypedef struct SyMutex SyMutex;\ntypedef struct Sytm Sytm;\n/* Scatter and gather array. */\nstruct syiovec\n{\n#if defined (__WINNT__)\n\t/* Same fields type and offset as WSABUF structure defined one winsock2 header */\n\tunsigned long nLen;\n\tchar *pBase;\n#else\n\tvoid *pBase;\n\tunsigned long nLen;\n#endif\n};\nstruct SyString\n{\n\tconst char *zString;  /* Raw string (may not be null terminated) */\n\tunsigned int nByte;   /* Raw string length */\n};\n/* Time structure. */\nstruct Sytm\n{\n  int tm_sec;     /* seconds (0 - 60) */\n  int tm_min;     /* minutes (0 - 59) */\n  int tm_hour;    /* hours (0 - 23) */\n  int tm_mday;    /* day of month (1 - 31) */\n  int tm_mon;     /* month of year (0 - 11) */\n  int tm_year;    /* year + 1900 */\n  int tm_wday;    /* day of week (Sunday = 0) */\n  int tm_yday;    /* day of year (0 - 365) */\n  int tm_isdst;   /* is summer time in effect? */\n  char *tm_zone;  /* abbreviation of timezone name */\n  long tm_gmtoff; /* offset from UTC in seconds */\n};\n/* Convert a tm structure (struct tm *) found in <time.h> to a Sytm structure */\n#define STRUCT_TM_TO_SYTM(pTM, pSYTM) \\\n\t(pSYTM)->tm_hour = (pTM)->tm_hour;\\\n\t(pSYTM)->tm_min\t = (pTM)->tm_min;\\\n\t(pSYTM)->tm_sec\t = (pTM)->tm_sec;\\\n\t(pSYTM)->tm_mon\t = (pTM)->tm_mon;\\\n\t(pSYTM)->tm_mday = (pTM)->tm_mday;\\\n\t(pSYTM)->tm_year = (pTM)->tm_year + 1900;\\\n\t(pSYTM)->tm_yday = (pTM)->tm_yday;\\\n\t(pSYTM)->tm_wday = (pTM)->tm_wday;\\\n\t(pSYTM)->tm_isdst = (pTM)->tm_isdst;\\\n\t(pSYTM)->tm_gmtoff = 0;\\\n\t(pSYTM)->tm_zone = 0;\n\n/* Convert a SYSTEMTIME structure (LPSYSTEMTIME: Windows Systems only ) to a Sytm structure */\n#define SYSTEMTIME_TO_SYTM(pSYSTIME, pSYTM) \\\n\t (pSYTM)->tm_hour = (pSYSTIME)->wHour;\\\n\t (pSYTM)->tm_min  = (pSYSTIME)->wMinute;\\\n\t (pSYTM)->tm_sec  = (pSYSTIME)->wSecond;\\\n\t (pSYTM)->tm_mon  = (pSYSTIME)->wMonth - 1;\\\n\t (pSYTM)->tm_mday = (pSYSTIME)->wDay;\\\n\t (pSYTM)->tm_year = (pSYSTIME)->wYear;\\\n\t (pSYTM)->tm_yday = 0;\\\n\t (pSYTM)->tm_wday = (pSYSTIME)->wDayOfWeek;\\\n\t (pSYTM)->tm_gmtoff = 0;\\\n\t (pSYTM)->tm_isdst = -1;\\\n\t (pSYTM)->tm_zone = 0;\n\n/* Dynamic memory allocation methods. */\nstruct SyMemMethods \n{\n\tvoid * (*xAlloc)(unsigned int);          /* [Required:] Allocate a memory chunk */\n\tvoid * (*xRealloc)(void *, unsigned int); /* [Required:] Re-allocate a memory chunk */\n\tvoid   (*xFree)(void *);                 /* [Required:] Release a memory chunk */\n\tunsigned int  (*xChunkSize)(void *);     /* [Optional:] Return chunk size */\n\tint    (*xInit)(void *);                 /* [Optional:] Initialization callback */\n\tvoid   (*xRelease)(void *);              /* [Optional:] Release callback */\n\tvoid  *pUserData;                        /* [Optional:] First argument to xInit() and xRelease() */\n};\n/* Out of memory callback signature. */\ntypedef int (*ProcMemError)(void *);\n/* Mutex methods. */\nstruct SyMutexMethods \n{\n\tint (*xGlobalInit)(void);\t\t/* [Optional:] Global mutex initialization */\n\tvoid  (*xGlobalRelease)(void);\t/* [Optional:] Global Release callback () */\n\tSyMutex * (*xNew)(int);\t        /* [Required:] Request a new mutex */\n\tvoid  (*xRelease)(SyMutex *);\t/* [Optional:] Release a mutex  */\n\tvoid  (*xEnter)(SyMutex *);\t    /* [Required:] Enter mutex */\n\tint (*xTryEnter)(SyMutex *);    /* [Optional:] Try to enter a mutex */\n\tvoid  (*xLeave)(SyMutex *);\t    /* [Required:] Leave a locked mutex */\n};\n#if defined (_MSC_VER) || defined (__MINGW32__) ||  defined (__GNUC__) && defined (__declspec)\n#define SX_APIIMPORT\t__declspec(dllimport)\n#define SX_APIEXPORT\t__declspec(dllexport)\n#else\n#define\tSX_APIIMPORT\n#define\tSX_APIEXPORT\n#endif\n/* Standard return values from Symisc public interfaces */\n#define SXRET_OK       0      /* Not an error */\t\n#define SXERR_MEM      (-1)   /* Out of memory */\n#define SXERR_IO       (-2)   /* IO error */\n#define SXERR_EMPTY    (-3)   /* Empty field */\n#define SXERR_LOCKED   (-4)   /* Locked operation */\n#define SXERR_ORANGE   (-5)   /* Out of range value */\n#define SXERR_NOTFOUND (-6)   /* Item not found */\n#define SXERR_LIMIT    (-7)   /* Limit reached */\n#define SXERR_MORE     (-8)   /* Need more input */\n#define SXERR_INVALID  (-9)   /* Invalid parameter */\n#define SXERR_ABORT    (-10)  /* User callback request an operation abort */\n#define SXERR_EXISTS   (-11)  /* Item exists */\n#define SXERR_SYNTAX   (-12)  /* Syntax error */\n#define SXERR_UNKNOWN  (-13)  /* Unknown error */\n#define SXERR_BUSY     (-14)  /* Busy operation */\n#define SXERR_OVERFLOW (-15)  /* Stack or buffer overflow */\n#define SXERR_WILLBLOCK (-16) /* Operation will block */\n#define SXERR_NOTIMPLEMENTED  (-17) /* Operation not implemented */\n#define SXERR_EOF      (-18) /* End of input */\n#define SXERR_PERM     (-19) /* Permission error */\n#define SXERR_NOOP     (-20) /* No-op */\t\n#define SXERR_FORMAT   (-21) /* Invalid format */\n#define SXERR_NEXT     (-22) /* Not an error */\n#define SXERR_OS       (-23) /* System call return an error */\n#define SXERR_CORRUPT  (-24) /* Corrupted pointer */\n#define SXERR_CONTINUE (-25) /* Not an error: Operation in progress */\n#define SXERR_NOMATCH  (-26) /* No match */\n#define SXERR_RESET    (-27) /* Operation reset */\n#define SXERR_DONE     (-28) /* Not an error */\n#define SXERR_SHORT    (-29) /* Buffer too short */\n#define SXERR_PATH     (-30) /* Path error */\n#define SXERR_TIMEOUT  (-31) /* Timeout */\n#define SXERR_BIG      (-32) /* Too big for processing */\n#define SXERR_RETRY    (-33) /* Retry your call */\n#define SXERR_IGNORE   (-63) /* Ignore */\n#endif /* SYMISC_PUBLIC_DEFS */\n/* \n * Marker for exported interfaces. \n */\n#define UNQLITE_APIEXPORT SX_APIEXPORT\n/*\n * If compiling for a processor that lacks floating point\n * support, substitute integer for floating-point.\n */\n#ifdef UNQLITE_OMIT_FLOATING_POINT\ntypedef sxi64 uqlite_real;\n#else\ntypedef double unqlite_real;\n#endif\ntypedef sxi64 unqlite_int64;\n/* Standard UnQLite return values */\n#define UNQLITE_OK      SXRET_OK      /* Successful result */\n/* Beginning of error codes */\n#define UNQLITE_NOMEM    SXERR_MEM     /* Out of memory */\n#define UNQLITE_ABORT    SXERR_ABORT   /* Another thread have released this instance */\n#define UNQLITE_IOERR    SXERR_IO      /* IO error */\n#define UNQLITE_CORRUPT  SXERR_CORRUPT /* Corrupt pointer */\n#define UNQLITE_LOCKED   SXERR_LOCKED  /* Forbidden Operation */ \n#define UNQLITE_BUSY\t SXERR_BUSY    /* The database file is locked */\n#define UNQLITE_DONE\t SXERR_DONE    /* Operation done */\n#define UNQLITE_PERM     SXERR_PERM    /* Permission error */\n#define UNQLITE_NOTIMPLEMENTED SXERR_NOTIMPLEMENTED /* Method not implemented by the underlying Key/Value storage engine */\n#define UNQLITE_NOTFOUND SXERR_NOTFOUND /* No such record */\n#define UNQLITE_NOOP     SXERR_NOOP     /* No such method */\n#define UNQLITE_INVALID  SXERR_INVALID  /* Invalid parameter */\n#define UNQLITE_EOF      SXERR_EOF      /* End Of Input */\n#define UNQLITE_UNKNOWN  SXERR_UNKNOWN  /* Unknown configuration option */\n#define UNQLITE_LIMIT    SXERR_LIMIT    /* Database limit reached */\n#define UNQLITE_EXISTS   SXERR_EXISTS   /* Record exists */\n#define UNQLITE_EMPTY    SXERR_EMPTY    /* Empty record */\n#define UNQLITE_COMPILE_ERR (-70)       /* Compilation error */\n#define UNQLITE_VM_ERR      (-71)       /* Virtual machine error */\n#define UNQLITE_FULL        (-73)       /* Full database (unlikely) */\n#define UNQLITE_CANTOPEN    (-74)       /* Unable to open the database file */\n#define UNQLITE_READ_ONLY   (-75)       /* Read only Key/Value storage engine */\n#define UNQLITE_LOCKERR     (-76)       /* Locking protocol error */\n/* end-of-error-codes */\n/*\n * Database Handle Configuration Commands.\n *\n * The following set of constants are the available configuration verbs that can\n * be used by the host-application to configure an UnQLite database handle.\n * These constants must be passed as the second argument to [unqlite_config()].\n *\n * Each options require a variable number of arguments.\n * The [unqlite_config()] interface will return UNQLITE_OK on success, any other\n * return value indicates failure.\n * For a full discussion on the configuration verbs and their expected \n * parameters, please refer to this page:\n *      http://unqlite.org/c_api/unqlite_config.html\n */\n#define UNQLITE_CONFIG_JX9_ERR_LOG         1  /* TWO ARGUMENTS: const char **pzBuf, int *pLen */\n#define UNQLITE_CONFIG_MAX_PAGE_CACHE      2  /* ONE ARGUMENT: int nMaxPage */\n#define UNQLITE_CONFIG_ERR_LOG             3  /* TWO ARGUMENTS: const char **pzBuf, int *pLen */\n#define UNQLITE_CONFIG_KV_ENGINE           4  /* ONE ARGUMENT: const char *zKvName */\n#define UNQLITE_CONFIG_DISABLE_AUTO_COMMIT 5  /* NO ARGUMENTS */\n#define UNQLITE_CONFIG_GET_KV_NAME         6  /* ONE ARGUMENT: const char **pzPtr */\n/*\n * UnQLite/Jx9 Virtual Machine Configuration Commands.\n *\n * The following set of constants are the available configuration verbs that can\n * be used by the host-application to configure the Jx9 (Via UnQLite) Virtual machine.\n * These constants must be passed as the second argument to the [unqlite_vm_config()] \n * interface.\n * Each options require a variable number of arguments.\n * The [unqlite_vm_config()] interface will return UNQLITE_OK on success, any other return\n * value indicates failure.\n * There are many options but the most important are: UNQLITE_VM_CONFIG_OUTPUT which install\n * a VM output consumer callback, UNQLITE_VM_CONFIG_HTTP_REQUEST which parse and register\n * a HTTP request and UNQLITE_VM_CONFIG_ARGV_ENTRY which populate the $argv array.\n * For a full discussion on the configuration verbs and their expected parameters, please\n * refer to this page:\n *      http://unqlite.org/c_api/unqlite_vm_config.html\n */\n#define UNQLITE_VM_CONFIG_OUTPUT           1  /* TWO ARGUMENTS: int (*xConsumer)(const void *pOut, unsigned int nLen, void *pUserData), void *pUserData */\n#define UNQLITE_VM_CONFIG_IMPORT_PATH      2  /* ONE ARGUMENT: const char *zIncludePath */\n#define UNQLITE_VM_CONFIG_ERR_REPORT       3  /* NO ARGUMENTS: Report all run-time errors in the VM output */\n#define UNQLITE_VM_CONFIG_RECURSION_DEPTH  4  /* ONE ARGUMENT: int nMaxDepth */\n#define UNQLITE_VM_OUTPUT_LENGTH           5  /* ONE ARGUMENT: unsigned int *pLength */\n#define UNQLITE_VM_CONFIG_CREATE_VAR       6  /* TWO ARGUMENTS: const char *zName, unqlite_value *pValue */\n#define UNQLITE_VM_CONFIG_HTTP_REQUEST     7  /* TWO ARGUMENTS: const char *zRawRequest, int nRequestLength */\n#define UNQLITE_VM_CONFIG_SERVER_ATTR      8  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\n#define UNQLITE_VM_CONFIG_ENV_ATTR         9  /* THREE ARGUMENTS: const char *zKey, const char *zValue, int nLen */\n#define UNQLITE_VM_CONFIG_EXEC_VALUE      10  /* ONE ARGUMENT: unqlite_value **ppValue */\n#define UNQLITE_VM_CONFIG_IO_STREAM       11  /* ONE ARGUMENT: const unqlite_io_stream *pStream */\n#define UNQLITE_VM_CONFIG_ARGV_ENTRY      12  /* ONE ARGUMENT: const char *zValue */\n#define UNQLITE_VM_CONFIG_EXTRACT_OUTPUT  13  /* TWO ARGUMENTS: const void **ppOut, unsigned int *pOutputLen */\n/*\n * Storage engine configuration commands.\n *\n * The following set of constants are the available configuration verbs that can\n * be used by the host-application to configure the underlying storage engine (i.e Hash, B+tree, R+tree).\n * These constants must be passed as the first argument to [unqlite_kv_config()].\n * Each options require a variable number of arguments.\n * The [unqlite_kv_config()] interface will return UNQLITE_OK on success, any other return\n * value indicates failure.\n * For a full discussion on the configuration verbs and their expected parameters, please\n * refer to this page:\n *      http://unqlite.org/c_api/unqlite_kv_config.html\n */\n#define UNQLITE_KV_CONFIG_HASH_FUNC  1 /* ONE ARGUMENT: unsigned int (*xHash)(const void *,unsigned int) */\n#define UNQLITE_KV_CONFIG_CMP_FUNC   2 /* ONE ARGUMENT: int (*xCmp)(const void *,const void *,unsigned int) */\n/*\n * Global Library Configuration Commands.\n *\n * The following set of constants are the available configuration verbs that can\n * be used by the host-application to configure the whole library.\n * These constants must be passed as the first argument to [unqlite_lib_config()].\n *\n * Each options require a variable number of arguments.\n * The [unqlite_lib_config()] interface will return UNQLITE_OK on success, any other return\n * value indicates failure.\n * Notes:\n * The default configuration is recommended for most applications and so the call to\n * [unqlite_lib_config()] is usually not necessary. It is provided to support rare \n * applications with unusual needs. \n * The [unqlite_lib_config()] interface is not threadsafe. The application must insure that\n * no other [unqlite_*()] interfaces are invoked by other threads while [unqlite_lib_config()]\n * is running. Furthermore, [unqlite_lib_config()] may only be invoked prior to library\n * initialization using [unqlite_lib_init()] or [unqlite_init()] or after shutdown\n * by [unqlite_lib_shutdown()]. If [unqlite_lib_config()] is called after [unqlite_lib_init()]\n * or [unqlite_init()] and before [unqlite_lib_shutdown()] then it will return UNQLITE_LOCKED.\n * For a full discussion on the configuration verbs and their expected parameters, please\n * refer to this page:\n *      http://unqlite.org/c_api/unqlite_lib.html\n */\n#define UNQLITE_LIB_CONFIG_USER_MALLOC            1 /* ONE ARGUMENT: const SyMemMethods *pMemMethods */ \n#define UNQLITE_LIB_CONFIG_MEM_ERR_CALLBACK       2 /* TWO ARGUMENTS: int (*xMemError)(void *), void *pUserData */\n#define UNQLITE_LIB_CONFIG_USER_MUTEX             3 /* ONE ARGUMENT: const SyMutexMethods *pMutexMethods */ \n#define UNQLITE_LIB_CONFIG_THREAD_LEVEL_SINGLE    4 /* NO ARGUMENTS */ \n#define UNQLITE_LIB_CONFIG_THREAD_LEVEL_MULTI     5 /* NO ARGUMENTS */ \n#define UNQLITE_LIB_CONFIG_VFS                    6 /* ONE ARGUMENT: const unqlite_vfs *pVfs */\n#define UNQLITE_LIB_CONFIG_STORAGE_ENGINE         7 /* ONE ARGUMENT: unqlite_kv_methods *pStorage */\n#define UNQLITE_LIB_CONFIG_PAGE_SIZE              8 /* ONE ARGUMENT: int iPageSize */\n/*\n * These bit values are intended for use in the 3rd parameter to the [unqlite_open()] interface\n * and in the 4th parameter to the xOpen method of the [unqlite_vfs] object.\n */\n#define UNQLITE_OPEN_READONLY         0x00000001  /* Read only mode. Ok for [unqlite_open] */\n#define UNQLITE_OPEN_READWRITE        0x00000002  /* Ok for [unqlite_open] */\n#define UNQLITE_OPEN_CREATE           0x00000004  /* Ok for [unqlite_open] */\n#define UNQLITE_OPEN_EXCLUSIVE        0x00000008  /* VFS only */\n#define UNQLITE_OPEN_TEMP_DB          0x00000010  /* VFS only */\n#define UNQLITE_OPEN_NOMUTEX          0x00000020  /* Ok for [unqlite_open] */\n#define UNQLITE_OPEN_OMIT_JOURNALING  0x00000040  /* Omit journaling for this database. Ok for [unqlite_open] */\n#define UNQLITE_OPEN_IN_MEMORY        0x00000080  /* An in memory database. Ok for [unqlite_open]*/\n#define UNQLITE_OPEN_MMAP             0x00000100  /* Obtain a memory view of the whole file. Ok for [unqlite_open] */\n/*\n * Synchronization Type Flags\n *\n * When UnQLite invokes the xSync() method of an [unqlite_io_methods] object it uses\n * a combination of these integer values as the second argument.\n *\n * When the UNQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only\n * needs to flush data to mass storage.  Inode information need not be flushed.\n * If the lower four bits of the flag equal UNQLITE_SYNC_NORMAL, that means to use normal\n * fsync() semantics. If the lower four bits equal UNQLITE_SYNC_FULL, that means to use\n * Mac OS X style fullsync instead of fsync().\n */\n#define UNQLITE_SYNC_NORMAL        0x00002\n#define UNQLITE_SYNC_FULL          0x00003\n#define UNQLITE_SYNC_DATAONLY      0x00010\n/*\n * File Locking Levels\n *\n * UnQLite uses one of these integer values as the second\n * argument to calls it makes to the xLock() and xUnlock() methods\n * of an [unqlite_io_methods] object.\n */\n#define UNQLITE_LOCK_NONE          0\n#define UNQLITE_LOCK_SHARED        1\n#define UNQLITE_LOCK_RESERVED      2\n#define UNQLITE_LOCK_PENDING       3\n#define UNQLITE_LOCK_EXCLUSIVE     4\n/*\n * CAPIREF: OS Interface: Open File Handle\n *\n * An [unqlite_file] object represents an open file in the [unqlite_vfs] OS interface\n * layer.\n * Individual OS interface implementations will want to subclass this object by appending\n * additional fields for their own use. The pMethods entry is a pointer to an\n * [unqlite_io_methods] object that defines methods for performing\n * I/O operations on the open file.\n*/\ntypedef struct unqlite_file unqlite_file;\nstruct unqlite_file {\n  const unqlite_io_methods *pMethods;  /* Methods for an open file. MUST BE FIRST */\n};\n/*\n * CAPIREF: OS Interface: File Methods Object\n *\n * Every file opened by the [unqlite_vfs] xOpen method populates an\n * [unqlite_file] object (or, more commonly, a subclass of the\n * [unqlite_file] object) with a pointer to an instance of this object.\n * This object defines the methods used to perform various operations\n * against the open file represented by the [unqlite_file] object.\n *\n * If the xOpen method sets the unqlite_file.pMethods element \n * to a non-NULL pointer, then the unqlite_io_methods.xClose method\n * may be invoked even if the xOpen reported that it failed.  The\n * only way to prevent a call to xClose following a failed xOpen\n * is for the xOpen to set the unqlite_file.pMethods element to NULL.\n *\n * The flags argument to xSync may be one of [UNQLITE_SYNC_NORMAL] or\n * [UNQLITE_SYNC_FULL]. The first choice is the normal fsync().\n * The second choice is a Mac OS X style fullsync. The [UNQLITE_SYNC_DATAONLY]\n * flag may be ORed in to indicate that only the data of the file\n * and not its inode needs to be synced.\n *\n * The integer values to xLock() and xUnlock() are one of\n *\n * UNQLITE_LOCK_NONE\n * UNQLITE_LOCK_SHARED\n * UNQLITE_LOCK_RESERVED\n * UNQLITE_LOCK_PENDING\n * UNQLITE_LOCK_EXCLUSIVE\n * \n * xLock() increases the lock. xUnlock() decreases the lock.\n * The xCheckReservedLock() method checks whether any database connection,\n * either in this process or in some other process, is holding a RESERVED,\n * PENDING, or EXCLUSIVE lock on the file. It returns true if such a lock exists\n * and false otherwise.\n * \n * The xSectorSize() method returns the sector size of the device that underlies\n * the file. The sector size is the minimum write that can be performed without\n * disturbing other bytes in the file.\n *\n */\nstruct unqlite_io_methods {\n  int iVersion;                 /* Structure version number (currently 1) */\n  int (*xClose)(unqlite_file*);\n  int (*xRead)(unqlite_file*, void*, unqlite_int64 iAmt, unqlite_int64 iOfst);\n  int (*xWrite)(unqlite_file*, const void*, unqlite_int64 iAmt, unqlite_int64 iOfst);\n  int (*xTruncate)(unqlite_file*, unqlite_int64 size);\n  int (*xSync)(unqlite_file*, int flags);\n  int (*xFileSize)(unqlite_file*, unqlite_int64 *pSize);\n  int (*xLock)(unqlite_file*, int);\n  int (*xUnlock)(unqlite_file*, int);\n  int (*xCheckReservedLock)(unqlite_file*, int *pResOut);\n  int (*xSectorSize)(unqlite_file*);\n};\n/*\n * CAPIREF: OS Interface Object\n *\n * An instance of the unqlite_vfs object defines the interface between\n * the UnQLite core and the underlying operating system.  The \"vfs\"\n * in the name of the object stands for \"Virtual File System\".\n *\n * Only a single vfs can be registered within the UnQLite core.\n * Vfs registration is done using the [unqlite_lib_config()] interface\n * with a configuration verb set to UNQLITE_LIB_CONFIG_VFS.\n * Note that Windows and UNIX (Linux, FreeBSD, Solaris, Mac OS X, etc.) users\n * does not have to worry about registering and installing a vfs since UnQLite\n * come with a built-in vfs for these platforms that implements most the methods\n * defined below.\n *\n * Clients running on exotic systems (ie: Other than Windows and UNIX systems)\n * must register their own vfs in order to be able to use the UnQLite library.\n *\n * The value of the iVersion field is initially 1 but may be larger in\n * future versions of UnQLite. \n *\n * The szOsFile field is the size of the subclassed [unqlite_file] structure\n * used by this VFS. mxPathname is the maximum length of a pathname in this VFS.\n * \n * At least szOsFile bytes of memory are allocated by UnQLite to hold the [unqlite_file]\n * structure passed as the third argument to xOpen. The xOpen method does not have to\n * allocate the structure; it should just fill it in. Note that the xOpen method must\n * set the unqlite_file.pMethods to either a valid [unqlite_io_methods] object or to NULL.\n * xOpen must do this even if the open fails. UnQLite expects that the unqlite_file.pMethods\n * element will be valid after xOpen returns regardless of the success or failure of the\n * xOpen call.\n *\n */\nstruct unqlite_vfs {\n  const char *zName;       /* Name of this virtual file system [i.e: Windows, UNIX, etc.] */\n  int iVersion;            /* Structure version number (currently 1) */\n  int szOsFile;            /* Size of subclassed unqlite_file */\n  int mxPathname;          /* Maximum file pathname length */\n  int (*xOpen)(unqlite_vfs*, const char *zName, unqlite_file*,unsigned int flags);\n  int (*xDelete)(unqlite_vfs*, const char *zName, int syncDir);\n  int (*xAccess)(unqlite_vfs*, const char *zName, int flags, int *pResOut);\n  int (*xFullPathname)(unqlite_vfs*, const char *zName,int buf_len,char *zBuf);\n  int (*xTmpDir)(unqlite_vfs*,char *zBuf,int buf_len);\n  int (*xSleep)(unqlite_vfs*, int microseconds);\n  int (*xCurrentTime)(unqlite_vfs*,Sytm *pOut);\n  int (*xGetLastError)(unqlite_vfs*, int, char *);\n};\n/*\n * Flags for the xAccess VFS method\n *\n * These integer constants can be used as the third parameter to\n * the xAccess method of an [unqlite_vfs] object.  They determine\n * what kind of permissions the xAccess method is looking for.\n * With UNQLITE_ACCESS_EXISTS, the xAccess method\n * simply checks whether the file exists.\n * With UNQLITE_ACCESS_READWRITE, the xAccess method\n * checks whether the named directory is both readable and writable\n * (in other words, if files can be added, removed, and renamed within\n * the directory).\n * The UNQLITE_ACCESS_READWRITE constant is currently used only by the\n * [temp_store_directory pragma], though this could change in a future\n * release of UnQLite.\n * With UNQLITE_ACCESS_READ, the xAccess method\n * checks whether the file is readable.  The UNQLITE_ACCESS_READ constant is\n * currently unused, though it might be used in a future release of\n * UnQLite.\n */\n#define UNQLITE_ACCESS_EXISTS    0\n#define UNQLITE_ACCESS_READWRITE 1   \n#define UNQLITE_ACCESS_READ      2 \n/*\n * The type used to represent a page number.  The first page in a file\n * is called page 1.  0 is used to represent \"not a page\".\n * A page number is an unsigned 64-bit integer.\n */\ntypedef sxu64 pgno;\n/*\n * A database disk page is represented by an instance\n * of the following structure.\n */\ntypedef struct unqlite_page unqlite_page;\nstruct unqlite_page\n{\n  unsigned char *zData;       /* Content of this page */\n  void *pUserData;            /* Extra content */\n  pgno iPage;                 /* Page number for this page */\n};\n/*\n * UnQLite handle to the underlying Key/Value Storage Engine (See below).\n */\ntypedef void * unqlite_kv_handle;\n/*\n * UnQLite pager IO methods.\n *\n * An instance of the following structure define the exported methods of the UnQLite pager\n * to the underlying Key/Value storage engine.\n */\ntypedef struct unqlite_kv_io unqlite_kv_io;\nstruct unqlite_kv_io\n{\n\tunqlite_kv_handle  pHandle;     /* UnQLite handle passed as the first parameter to the\n\t\t\t\t\t\t\t\t\t * method defined below.\n\t\t\t\t\t\t\t\t\t */\n\tunqlite_kv_methods *pMethods;   /* Underlying storage engine */\n\t/* Pager methods */\n\tint (*xGet)(unqlite_kv_handle,pgno,unqlite_page **);\n\tint (*xLookup)(unqlite_kv_handle,pgno,unqlite_page **);\n\tint (*xNew)(unqlite_kv_handle,unqlite_page **);\n\tint (*xWrite)(unqlite_page *);\n\tint (*xDontWrite)(unqlite_page *);\n\tint (*xDontJournal)(unqlite_page *);\n\tint (*xDontMkHot)(unqlite_page *);\n\tint (*xPageRef)(unqlite_page *);\n\tint (*xPageUnref)(unqlite_page *);\n\tint (*xPageSize)(unqlite_kv_handle);\n\tint (*xReadOnly)(unqlite_kv_handle);\n\tunsigned char * (*xTmpPage)(unqlite_kv_handle);\n\tvoid (*xSetUnpin)(unqlite_kv_handle,void (*xPageUnpin)(void *)); \n\tvoid (*xSetReload)(unqlite_kv_handle,void (*xPageReload)(void *));\n\tvoid (*xErr)(unqlite_kv_handle,const char *);\n};\n/*\n * Key/Value Storage Engine Cursor Object\n *\n * An instance of a subclass of the following object defines a cursor\n * used to scan through a key-value storage engine.\n */\ntypedef struct unqlite_kv_cursor unqlite_kv_cursor;\nstruct unqlite_kv_cursor\n{\n  unqlite_kv_engine *pStore; /* Must be first */\n  /* Subclasses will typically add additional fields */\n};\n/*\n * Possible seek positions.\n */\n#define UNQLITE_CURSOR_MATCH_EXACT  1\n#define UNQLITE_CURSOR_MATCH_LE     2\n#define UNQLITE_CURSOR_MATCH_GE     3\n/*\n * Key/Value Storage Engine.\n *\n * A Key-Value storage engine is defined by an instance of the following\n * object.\n * UnQLite works with run-time interchangeable storage engines (i.e. Hash, B+Tree, R+Tree, LSM, etc.).\n * The storage engine works with key/value pairs where both the key\n * and the value are byte arrays of arbitrary length and with no restrictions on content.\n * UnQLite come with two built-in KV storage engine: A Virtual Linear Hash (VLH) storage\n * engine is used for persistent on-disk databases with O(1) lookup time and an in-memory\n * hash-table or Red-black tree storage engine is used for in-memory databases.\n * Future versions of UnQLite might add other built-in storage engines (i.e. LSM). \n * Registration of a Key/Value storage engine at run-time is done via [unqlite_lib_config()]\n * with a configuration verb set to UNQLITE_LIB_CONFIG_STORAGE_ENGINE.\n */\nstruct unqlite_kv_engine\n{\n  const unqlite_kv_io *pIo; /* IO methods: MUST be first */\n   /* Subclasses will typically add additional fields */\n};\n/*\n * Key/Value Storage Engine Virtual Method Table.\n *\n * Key/Value storage engine methods is defined by an instance of the following\n * object.\n * Registration of a Key/Value storage engine at run-time is done via [unqlite_lib_config()]\n * with a configuration verb set to UNQLITE_LIB_CONFIG_STORAGE_ENGINE.\n */\nstruct unqlite_kv_methods\n{\n  const char *zName; /* Storage engine name [i.e. Hash, B+tree, LSM, R-tree, Mem, etc.]*/\n  int szKv;          /* 'unqlite_kv_engine' subclass size */\n  int szCursor;      /* 'unqlite_kv_cursor' subclass size */\n  int iVersion;      /* Structure version, currently 1 */\n  /* Storage engine methods */\n  int (*xInit)(unqlite_kv_engine *,int iPageSize);\n  void (*xRelease)(unqlite_kv_engine *);\n  int (*xConfig)(unqlite_kv_engine *,int op,va_list ap);\n  int (*xOpen)(unqlite_kv_engine *,pgno);\n  int (*xReplace)(\n\t  unqlite_kv_engine *,\n\t  const void *pKey,int nKeyLen,\n\t  const void *pData,unqlite_int64 nDataLen\n\t  ); \n    int (*xAppend)(\n\t  unqlite_kv_engine *,\n\t  const void *pKey,int nKeyLen,\n\t  const void *pData,unqlite_int64 nDataLen\n\t  );\n  void (*xCursorInit)(unqlite_kv_cursor *);\n  int (*xSeek)(unqlite_kv_cursor *,const void *pKey,int nByte,int iPos); /* Mandatory */\n  int (*xFirst)(unqlite_kv_cursor *);\n  int (*xLast)(unqlite_kv_cursor *);\n  int (*xValid)(unqlite_kv_cursor *);\n  int (*xNext)(unqlite_kv_cursor *);\n  int (*xPrev)(unqlite_kv_cursor *);\n  int (*xDelete)(unqlite_kv_cursor *);\n  int (*xKeyLength)(unqlite_kv_cursor *,int *);\n  int (*xKey)(unqlite_kv_cursor *,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\n  int (*xDataLength)(unqlite_kv_cursor *,unqlite_int64 *);\n  int (*xData)(unqlite_kv_cursor *,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\n  void (*xReset)(unqlite_kv_cursor *);\n  void (*xCursorRelease)(unqlite_kv_cursor *);\n};\n/*\n * UnQLite journal file suffix.\n */\n#ifndef UNQLITE_JOURNAL_FILE_SUFFIX\n#define UNQLITE_JOURNAL_FILE_SUFFIX \"_unqlite_journal\"\n#endif\n/*\n * Call Context - Error Message Severity Level.\n *\n * The following constants are the allowed severity level that can\n * passed as the second argument to the [unqlite_context_throw_error()] or\n * [unqlite_context_throw_error_format()] interfaces.\n * Refer to the official documentation for additional information.\n */\n#define UNQLITE_CTX_ERR       1 /* Call context error such as unexpected number of arguments, invalid types and so on. */\n#define UNQLITE_CTX_WARNING   2 /* Call context Warning */\n#define UNQLITE_CTX_NOTICE    3 /* Call context Notice */\n/* \n * C-API-REF: Please refer to the official documentation for interfaces\n * purpose and expected parameters. \n */ \n\n/* Database Engine Handle */\nUNQLITE_APIEXPORT int unqlite_open(unqlite **ppDB,const char *zFilename,unsigned int iMode);\nUNQLITE_APIEXPORT int unqlite_config(unqlite *pDb,int nOp,...);\nUNQLITE_APIEXPORT int unqlite_close(unqlite *pDb);\n\n\n/* Key/Value (KV) Store Interfaces */\nUNQLITE_APIEXPORT int unqlite_kv_store(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen);\nUNQLITE_APIEXPORT int unqlite_kv_append(unqlite *pDb,const void *pKey,int nKeyLen,const void *pData,unqlite_int64 nDataLen);\nUNQLITE_APIEXPORT int unqlite_kv_store_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...);\nUNQLITE_APIEXPORT int unqlite_kv_append_fmt(unqlite *pDb,const void *pKey,int nKeyLen,const char *zFormat,...);\nUNQLITE_APIEXPORT int unqlite_kv_fetch(unqlite *pDb,const void *pKey,int nKeyLen,void *pBuf,unqlite_int64 /* in|out */*pBufLen);\nUNQLITE_APIEXPORT int unqlite_kv_fetch_callback(unqlite *pDb,const void *pKey,\n\t                    int nKeyLen,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\nUNQLITE_APIEXPORT int unqlite_kv_delete(unqlite *pDb,const void *pKey,int nKeyLen);\nUNQLITE_APIEXPORT int unqlite_kv_config(unqlite *pDb,int iOp,...);\n\n/* Document (JSON) Store Interfaces powered by the Jx9 Scripting Language */\nUNQLITE_APIEXPORT int unqlite_compile(unqlite *pDb,const char *zJx9,int nByte,unqlite_vm **ppOut);\nUNQLITE_APIEXPORT int unqlite_compile_file(unqlite *pDb,const char *zPath,unqlite_vm **ppOut);\nUNQLITE_APIEXPORT int unqlite_vm_config(unqlite_vm *pVm,int iOp,...);\nUNQLITE_APIEXPORT int unqlite_vm_exec(unqlite_vm *pVm);\nUNQLITE_APIEXPORT int unqlite_vm_reset(unqlite_vm *pVm);\nUNQLITE_APIEXPORT int unqlite_vm_release(unqlite_vm *pVm);\nUNQLITE_APIEXPORT int unqlite_vm_dump(unqlite_vm *pVm, int (*xConsumer)(const void *, unsigned int, void *), void *pUserData);\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_extract_variable(unqlite_vm *pVm,const char *zVarname);\n\n/*  Cursor Iterator Interfaces */\nUNQLITE_APIEXPORT int unqlite_kv_cursor_init(unqlite *pDb,unqlite_kv_cursor **ppOut);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_release(unqlite *pDb,unqlite_kv_cursor *pCur);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_seek(unqlite_kv_cursor *pCursor,const void *pKey,int nKeyLen,int iPos);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_first_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_last_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_valid_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_next_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_prev_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_key(unqlite_kv_cursor *pCursor,void *pBuf,int *pnByte);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_key_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_data(unqlite_kv_cursor *pCursor,void *pBuf,unqlite_int64 *pnData);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_data_callback(unqlite_kv_cursor *pCursor,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_delete_entry(unqlite_kv_cursor *pCursor);\nUNQLITE_APIEXPORT int unqlite_kv_cursor_reset(unqlite_kv_cursor *pCursor);\n\n/* Manual Transaction Manager */\nUNQLITE_APIEXPORT int unqlite_begin(unqlite *pDb);\nUNQLITE_APIEXPORT int unqlite_commit(unqlite *pDb);\nUNQLITE_APIEXPORT int unqlite_rollback(unqlite *pDb);\n\n/* Utility interfaces */\nUNQLITE_APIEXPORT int unqlite_util_load_mmaped_file(const char *zFile,void **ppMap,unqlite_int64 *pFileSize);\nUNQLITE_APIEXPORT int unqlite_util_release_mmaped_file(void *pMap,unqlite_int64 iFileSize);\nUNQLITE_APIEXPORT int unqlite_util_random_string(unqlite *pDb,char *zBuf,unsigned int buf_size);\nUNQLITE_APIEXPORT unsigned int unqlite_util_random_num(unqlite *pDb);\n\n/* In-process extending interfaces */\nUNQLITE_APIEXPORT int unqlite_create_function(unqlite_vm *pVm,const char *zName,int (*xFunc)(unqlite_context *,int,unqlite_value **),void *pUserData);\nUNQLITE_APIEXPORT int unqlite_delete_function(unqlite_vm *pVm, const char *zName);\nUNQLITE_APIEXPORT int unqlite_create_constant(unqlite_vm *pVm,const char *zName,void (*xExpand)(unqlite_value *, void *),void *pUserData);\nUNQLITE_APIEXPORT int unqlite_delete_constant(unqlite_vm *pVm, const char *zName);\n\n/* On Demand Object allocation interfaces */\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_new_scalar(unqlite_vm *pVm);\nUNQLITE_APIEXPORT unqlite_value * unqlite_vm_new_array(unqlite_vm *pVm);\nUNQLITE_APIEXPORT int unqlite_vm_release_value(unqlite_vm *pVm,unqlite_value *pValue);\nUNQLITE_APIEXPORT unqlite_value * unqlite_context_new_scalar(unqlite_context *pCtx);\nUNQLITE_APIEXPORT unqlite_value * unqlite_context_new_array(unqlite_context *pCtx);\nUNQLITE_APIEXPORT void unqlite_context_release_value(unqlite_context *pCtx,unqlite_value *pValue);\n\n/* Dynamically Typed Value Object Management Interfaces */\nUNQLITE_APIEXPORT int unqlite_value_int(unqlite_value *pVal, int iValue);\nUNQLITE_APIEXPORT int unqlite_value_int64(unqlite_value *pVal, unqlite_int64 iValue);\nUNQLITE_APIEXPORT int unqlite_value_bool(unqlite_value *pVal, int iBool);\nUNQLITE_APIEXPORT int unqlite_value_null(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_double(unqlite_value *pVal, double Value);\nUNQLITE_APIEXPORT int unqlite_value_string(unqlite_value *pVal, const char *zString, int nLen);\nUNQLITE_APIEXPORT int unqlite_value_string_format(unqlite_value *pVal, const char *zFormat,...);\nUNQLITE_APIEXPORT int unqlite_value_reset_string_cursor(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_resource(unqlite_value *pVal, void *pUserData);\nUNQLITE_APIEXPORT int unqlite_value_release(unqlite_value *pVal);\n\n/* Foreign Function Parameter Values */\nUNQLITE_APIEXPORT int unqlite_value_to_int(unqlite_value *pValue);\nUNQLITE_APIEXPORT int unqlite_value_to_bool(unqlite_value *pValue);\nUNQLITE_APIEXPORT unqlite_int64 unqlite_value_to_int64(unqlite_value *pValue);\nUNQLITE_APIEXPORT double unqlite_value_to_double(unqlite_value *pValue);\nUNQLITE_APIEXPORT const char * unqlite_value_to_string(unqlite_value *pValue, int *pLen);\nUNQLITE_APIEXPORT void * unqlite_value_to_resource(unqlite_value *pValue);\nUNQLITE_APIEXPORT int unqlite_value_compare(unqlite_value *pLeft, unqlite_value *pRight, int bStrict);\n\n/* Setting The Result Of A Foreign Function */\nUNQLITE_APIEXPORT int unqlite_result_int(unqlite_context *pCtx, int iValue);\nUNQLITE_APIEXPORT int unqlite_result_int64(unqlite_context *pCtx, unqlite_int64 iValue);\nUNQLITE_APIEXPORT int unqlite_result_bool(unqlite_context *pCtx, int iBool);\nUNQLITE_APIEXPORT int unqlite_result_double(unqlite_context *pCtx, double Value);\nUNQLITE_APIEXPORT int unqlite_result_null(unqlite_context *pCtx);\nUNQLITE_APIEXPORT int unqlite_result_string(unqlite_context *pCtx, const char *zString, int nLen);\nUNQLITE_APIEXPORT int unqlite_result_string_format(unqlite_context *pCtx, const char *zFormat, ...);\nUNQLITE_APIEXPORT int unqlite_result_value(unqlite_context *pCtx, unqlite_value *pValue);\nUNQLITE_APIEXPORT int unqlite_result_resource(unqlite_context *pCtx, void *pUserData);\n\n/* Dynamically Typed Value Object Query Interfaces */\nUNQLITE_APIEXPORT int unqlite_value_is_int(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_float(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_bool(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_string(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_null(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_numeric(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_callable(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_scalar(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_json_array(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_json_object(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_resource(unqlite_value *pVal);\nUNQLITE_APIEXPORT int unqlite_value_is_empty(unqlite_value *pVal);\n\n/* JSON Array/Object Management Interfaces */\nUNQLITE_APIEXPORT unqlite_value * unqlite_array_fetch(unqlite_value *pArray, const char *zKey, int nByte);\nUNQLITE_APIEXPORT int unqlite_array_walk(unqlite_value *pArray, int (*xWalk)(unqlite_value *, unqlite_value *, void *), void *pUserData);\nUNQLITE_APIEXPORT int unqlite_array_add_elem(unqlite_value *pArray, unqlite_value *pKey, unqlite_value *pValue);\nUNQLITE_APIEXPORT int unqlite_array_add_strkey_elem(unqlite_value *pArray, const char *zKey, unqlite_value *pValue);\nUNQLITE_APIEXPORT int unqlite_array_count(unqlite_value *pArray);\n\n/* Call Context Handling Interfaces */\nUNQLITE_APIEXPORT int unqlite_context_output(unqlite_context *pCtx, const char *zString, int nLen);\nUNQLITE_APIEXPORT int unqlite_context_output_format(unqlite_context *pCtx,const char *zFormat, ...);\nUNQLITE_APIEXPORT int unqlite_context_throw_error(unqlite_context *pCtx, int iErr, const char *zErr);\nUNQLITE_APIEXPORT int unqlite_context_throw_error_format(unqlite_context *pCtx, int iErr, const char *zFormat, ...);\nUNQLITE_APIEXPORT unsigned int unqlite_context_random_num(unqlite_context *pCtx);\nUNQLITE_APIEXPORT int unqlite_context_random_string(unqlite_context *pCtx, char *zBuf, int nBuflen);\nUNQLITE_APIEXPORT void * unqlite_context_user_data(unqlite_context *pCtx);\nUNQLITE_APIEXPORT int unqlite_context_push_aux_data(unqlite_context *pCtx, void *pUserData);\nUNQLITE_APIEXPORT void * unqlite_context_peek_aux_data(unqlite_context *pCtx);\nUNQLITE_APIEXPORT unsigned int unqlite_context_result_buf_length(unqlite_context *pCtx);\nUNQLITE_APIEXPORT const char * unqlite_function_name(unqlite_context *pCtx);\n\n/* Call Context Memory Management Interfaces */\nUNQLITE_APIEXPORT void * unqlite_context_alloc_chunk(unqlite_context *pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease);\nUNQLITE_APIEXPORT void * unqlite_context_realloc_chunk(unqlite_context *pCtx,void *pChunk,unsigned int nByte);\nUNQLITE_APIEXPORT void unqlite_context_free_chunk(unqlite_context *pCtx,void *pChunk);\n\n/* Global Library Management Interfaces */\nUNQLITE_APIEXPORT int unqlite_lib_config(int nConfigOp,...);\nUNQLITE_APIEXPORT int unqlite_lib_init(void);\nUNQLITE_APIEXPORT int unqlite_lib_shutdown(void);\nUNQLITE_APIEXPORT int unqlite_lib_is_threadsafe(void);\nUNQLITE_APIEXPORT const char * unqlite_lib_version(void);\nUNQLITE_APIEXPORT const char * unqlite_lib_signature(void);\nUNQLITE_APIEXPORT const char * unqlite_lib_ident(void);\nUNQLITE_APIEXPORT const char * unqlite_lib_copyright(void);\n#ifdef __cplusplus\n }\n#endif\n#endif /* _UNQLITE_H_ */\n"
        },
        {
          "name": "update-md5.py",
          "type": "blob",
          "size": 4.5126953125,
          "content": "#!/usr/bin/env python2\n# -*- coding:utf-8 -*-\n#  \n#  Copyright 2013 buaa.byl@gmail.com\n#\n#\n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 2, or (at your option)\n#  any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; see the file COPYING.  If not, write to\n#  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n#\nfrom __future__ import print_function\nimport copy\nimport sys\nimport os\nimport re\nfrom hashlib import md5\n\nregex_file = re.compile(r'^[ *]+File: ([0-9a-zA-Z_.-]+)\\W*$')\nregex_md5  = re.compile(r'^[ *]+(MD5): ([0-9a-fA-F]+)\\W*$')\nregex_id   = re.compile(r'^[ *]+(ID): ([0-9a-fA-F]+)\\W*$')\n\nHEADER = '''\\\n/*\n * ----------------------------------------------------------\n * File: %(filename)s\n * %(type)s: %(hash)s\n * ----------------------------------------------------------\n */\\\n'''\n\n\ndef file_get_contents(fn):\n    f = open(fn, 'r')\n    d = f.read()\n    f.close()\n    return d\n\ndef file_put_contents(fn, d):\n    f = open(fn, 'w')\n    f.write(d)\n    f.close()\n\ndef new_info(INFO, lineno, filename, newtype, newhash):\n    info = copy.deepcopy(INFO)\n    info['lineno']  = lineno + 1\n    info['filename']= filename\n    info['type']    = newtype\n    info['oldhash'] = newhash\n    return info\n\ndef build_context(info, lines):\n    text = '\\n'.join(lines)\n    hashstr = md5(text).hexdigest()\n    info['hash']    = hashstr\n    info['range']   = (info['lineno'], info['lineno'] + len(lines) - 1)\n    info['text']    = text\n    return info\n\nif __name__ == '__main__':\n    source_fn   = sys.argv[1]\n    v = file_get_contents(source_fn)\n\n    print('parsing...', source_fn)\n    print()\n\n    INFO = {\n        'lineno'    :0,\n        'range'     :(0, ),\n        'filename'  :'',\n        'type'      :'',\n        'oldhash'   :'',\n        'hash'      :'',\n        'text'      :''\n    }\n\n    lines = v.splitlines()\n    nr_lines = len(lines)\n\n    lst_unpacked = []\n\n    lineno = 0\n    file_context = []\n\n    info = new_info(INFO, lineno, 'amalgamation.h', '', '')\n\n    while lineno < nr_lines:\n        line = lines[lineno]\n\n        if line.find('END-OF-IMPLEMENTATION:') >= 0:\n            if len(file_context) > 0:\n                lst_unpacked.append(build_context(info, file_context))\n                info = new_info(INFO, lineno, 'amalgamation.c', newtype, newhash)\n            file_context = lines[lineno:]\n            break\n\n        res = regex_file.match(line)\n        if res:\n            fn_new  = res.groups()[0]\n            line    = lines[lineno + 1]\n            res     = regex_md5.match(line)\n            if not res:\n                res = regex_id.match(line)\n            if not res:\n                file_context.append(lines[lineno])\n                lineno += 1\n                continue\n\n            newtype = res.groups()[0]\n            newhash = res.groups()[1]\n            lineno += 4\n\n            file_context.pop(-1)\n            file_context.pop(-1)\n\n            if len(file_context) > 0:\n                lst_unpacked.append(build_context(info, file_context))\n                info = new_info(INFO, lineno, fn_new, newtype, newhash)\n                file_context = []\n            continue\n\n        file_context.append(line)\n        lineno += 1\n\n    if len(file_context) > 0:\n        lst_unpacked.append(build_context(info, file_context))\n\n    for db in lst_unpacked:\n        print('%s:%d %d-%d' % (sys.argv[1], db['lineno'], db['range'][0], db['range'][1]))\n        print('File: %s' % db['filename'])\n        print('MD5 : %s %s parsed' % (db['type'], db['oldhash']))\n        print('MD5 : %s %s calculated' % (db['type'], db['hash']))\n        print()\n\n    if len(sys.argv) == 3:\n        target_dir  = sys.argv[2]\n        for db in lst_unpacked:\n            fn = os.path.join(target_dir, db['filename'])\n            file_put_contents(fn, db['text'])\n            print('wrote %s' % fn)\n        print()\n\n    l = []\n    for db in lst_unpacked:\n        if db['filename'].startswith('amalgamation'):\n            l.append(db['text'])\n        else:\n            l.append(HEADER % db)\n            l.append(db['text'])\n    l.append('')\n\n    fn = source_fn + '.__regenerate__.c'\n    print('wrote %s' % fn)\n    file_put_contents(fn, '\\n'.join(l))\n\n\n\n"
        }
      ]
    }
  ]
}