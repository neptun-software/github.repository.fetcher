{
  "metadata": {
    "timestamp": 1736710023639,
    "page": 629,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "onetrueawk/awk",
      "stars": 2040,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0732421875,
          "content": "a.out\nmaketab\nproctab.c\n*.o\nytab* \ntestdir/foo*\ntestdir/temp*\n*.pdf\n*.mail\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 11.4072265625,
          "content": "2020-07-30         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tBy fiat, we use bison for $(YACC). Trying to accommodate\n\tdifferent versions didn't work.\n\n\t* makefile: Significant cleanup. Replace all ytab* references\n\twith awkgram.tab.* and simplify definition of YACC.\n\t* .gitignore: Remove ytab* references.\n\t* b.c, lex.c, maketab.c, parse.c, run.c: Replace include of ytab.h\n\twith awkgram.tab.h.\n\t* lib.c, main.c, tran.c: Remove include of ytab.h, wasn't needed.\n\n2020-01-20         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* run.c (openfile): Set the close-on-exec flag for file\n\tand pipe redirections that aren't stdin/stdout/stderr.\n\n2020-01-06         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tMinor fixes.\n\t* b.c (replace_repeat): Turn init_q back into an int.\n\t* lex.c (string): Use \\a instead of \\007.\n\t* tran.c (catstr): Use snprintf instead of sprintf.\n\n2020-01-01         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* tran.c (syminit, arginit, envinit): Free sval member before\n\tsetting it. Thanks to valgrind.\n\t* b.c: Small formatting cleanups in several routines.\n\n2019-12-27         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* b.c (replace_repeat): Fix a bug whereby a{0,3} could match\n\tfour a's.  Thanks to Anonymous AWK fan <awkfan77@mailfence.com>\n\tfor the report. Also, minor code formatting cleanups.\n\t* testdir/T.int-expr: New file.\n\n2019-12-11         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* README: Renamed to ...\n\t* README.md: ... this. Cleaned up some as well,\n\tincluding moving to Markdown.\n\n2019-11-08         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* test/T.chem: Use $oldawk instead of hardwiring 'awk'.\n\t* test/T.lilly: Remove gawk warnings from output, improves\n\tportability.\n\n2019-10-07         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* b.c (fnematch): Change type of pbuf from unsigned char to char.\n\t* proto.h (fnematch): Ditto.\n\n2019-10-06         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* lib.c (readrec): Allow RS a regular expression. Imported\n\tthe code from the NetBSD awk.\n\t* b.c (fnematch): New function for implementing the feature.\n\t* awk.1: Updated.\n\t* main.c (version): Updated.\n\n2019-06-24         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* makefile: Revise to take into account there is no more awktest.tar,\n\tadd targets 'check' and 'test', and also 'testclean' to clean up\n\tafter test run.  Have 'clean' and 'cleaner' depend upon 'testclean'.\n\n2019-06-23         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* testdir: Extracted from awktest.tar and added to Git.\n\t* awktest.tar: Removed.\n\n2019-06-06         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* awk.1: Fix a typo, minor edits.\n\n2019-06-05         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* b.c (relex): Count parentheses and treat umatched right paren\n\tas a literal character.\n\t* awktest.tar (testdir/T.re): Added a test case.\n\t* main.c (version): Updated.\n\n2019-05-29         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* lib.c (isclvar): Remove check for additional '=' after\n\tfirst one. No longer needed.\n\n2019-01-26         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* main.c (version): Updated.\n\n2019-01-25         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* run.c (awkgetline): Check for numeric value in all getline\n\tvariants. See the numeric-getline.* files in bugs-fixed directory.\n\n2018-08-29         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* REGRESS: Check for existence of a.out. If not there, run\n\tmake.  Enable core dumps for T.arnold system status test\n\tto work on MacOS X.\n\n2018-08-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* awktest.tar (testdir/T.expr): Fix test for unary plus.\n\n2018-08-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* REGRESS: Extract tests if necessary, set PATH to include '.'.\n\t* regdir/beebe.tar (Makefile): Fix longwrds test to prefix\n\tsort with LC_ALL=C.\n\t* awktest.tar: Updated from fixed test suite, directory\n\tit extracts is now called 'testdir' to match what's in top-level\n\tREGRESS script.\n\t* regdir: Removed, as Brian wants to keep the test suite in\n\tthe tar file.\n\n2018-08-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* FIXES, lib.c, run.c, makefile, main.c: Merge from Brian's tree.\n\t* REGRESS: New file, from Brian.\n\t* awktest.tar: Restored from Brian's tree.\n\n2018-08-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* awkgram.y (UPLUS): New token. In the grammar, call op1()\n\twith it.\n\t* maketab.c (proc): Add entry for UPLUS.\n\t* run.c (arith): Handle UPLUS.\n\t* main.c (version): Updated.\n\t* bugs-fixed/unary-plus.awk, bugs-fixed/unary-plus.bad,\n\tbugs-fixed/unary-plus.ok: New files.\n\n2018-08-10         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* TODO: Updated.\n\t* awk.1: Improve use of macros, add some additional explanation\n\tin a few places, alphabetize list of variables.\n\n2018-08-08         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* awk.h (Cell): Add new field `fmt' to track xFMT value used\n\tfor a string conversion.\n\t[CONVC, CONVO]: New flag macros.\n\t* bugs-fixed/README: Updated.\n\t* bugs-fixed/string-conv.awk, bugs-fixed/string-conv.bad,\n\tbugs-fixed/string-conv.ok: New files.\n\t* main.c (version): Updated.\n\t* proto.h (flags2str): Add declaration.\n\t* tran.c (setfval): Clear CONVC and CONVO flags and set vp->fmt\n\tto NULL.\n\t(setsval): Ditto. Add large comment and new code to manage\n\tcorrect conversion of number to string based on various flags\n\tand the value of vp->fmt. The idea is to not convert again\n\tif xFMT is the same as before and we're doing the same conversion.\n\tOtherwise, clear the old flags, set the new, and reconvert.\n\t(flags2str): New function. For debug prints and for use from a debugger.\n\n2018-08-05         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tFix filename conflicts in regdir where the only difference was\n\tin letter case. This caused problems on Windows systems.\n\n\t* regdir/Compare.T1: Renamed from regdir/Compare.T.\n\t* regdir/t.delete0: Renamed from regdir/t.delete.\n\t* regdir/t.getline1: Renamed from regdir/t.getline.\n\t* regdir/t.redir1: Renamed from regdir/t.redir.\n\t* regdir/t.split1: Renamed from regdir/t.split.\n\t* regdir/t.sub0: Renamed from regdir/t.sub.\n\t* regdir/REGRESS: Adjusted.\n\n2018-08-04         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tWith scalpel, tweasers, magnifying glass and bated breath,\n\tborrow code from the NetBSD version of nawk to fix the years-old\n\tbug whereby decrementing the value of NF did not change the\n\trecord.\n\n\t* lib.c (fldbld): Set donerec to 1 when done.\n\t(setlastfld): New function.\n\t* proto.h (setlastfld): Add declaration.\n\t* run.c (copycell): Make code smarter about flags (from NetBSD code).\n\t* tran.c (setfree): New function.\n\t* tran.c (setfval): Normalize negative zero to positive zero.\n\tIf setting NF, clear donerec and call setlastfld().\n\t(setsval): Remove call to save_old_OFS().  If setting OFS, call\n\trecbld(). If setting NF, clear donerec and call setlastfld().\n\n\tAs part of the process, revert OFS-related changes of 2018-05-22:\n\n\t* awk.h (saveOFS, saveOFSlen, save_old_OFS): Remove declarations.\n\t* lib.c (recbld): Use *OFS instead of saveOFS.\n\t* run.c (saveOFS, saveOFSlen, save_old_OFS): Remove.\n\t* tran.c (syminit): Remove initialization of saveOFS and saveOFSlen.\n\n\tGeneral stuff that goes along with all this:\n\n\t* bugs-fixed/README: Updated.\n\t* bugs-fixed/decr-NF.awk, bugs-fixed/decr-NF.bad,\n\tbugs-fixed/decr-NF.ok: New files.\n\t* main.c (version): Updated.\n\t* regdir/README.TESTS: Fix awk book title.\n\t* regdir/T.misc: Revise test to match fixed code.\n\t* run.c (format): Increase size of buffer used for %a test. (Unrelated\n\tto NF or OFS, but fixes a compiler complaint.)\n\n2018-06-07         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* regdir/beebe.tar: Fix longwrds.ok so that the test will pass.\n\tThe file was incorrectly sorted.\n\n2018-06-06         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* regdir/T.lilly: Fix the bug again in the second instance\n\tof the code. Thanks to BWK for pointing this out.\n\n2018-05-31         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* regdir/T.lilly: Fix a syntax error and ordering bug\n\tin creating the 'foo' file.\n\n2018-05-23         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* awk.1: Remove standalone 'awk' at the top of file, it messed up\n\tthe formatting. Arrange built-in variable list in alphabetical\n\torder.\n\n2018-05-23         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* main.c (version): Add my email address and a date so that\n\tusers can tell this isn't straight BWK awk.\n\t* README.md: Minor updates.\n\t* TODO: Updated.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tAdd POSIX-required formats %a and %A.\n\n\t* run.c (format): Check for %a support in C library. If there,\n\tallow %a and %A as valid formats.\n\t* TODO: Updated.\n\t* bugs-fixed/README: Updated.\n\t* bugs-fixed/a-format.awk, bugs-fixed/a-format.bad,\n\tbugs-fixed/a-format.ok: New files.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* FIXES: Restored a line from a much earlier version that\n\tapparently got lost when the dates were reordered.\n\t* TODO: Updated.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* README.md: New file.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* regdir/echo.c, regdir/time.c: Minor fixes to compile without\n\twarning on current GCC / Linux.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* TODO: New file.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* makefile (gitadd, gitpush): Remove these targets. They\n\tshould not be automated and were incorrect for things that\n\twould be done regularly.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tFix nawk so that [[:blank:]] only matches space and tab instead\n\tof any whitespace character, originally made May 10, 2018.\n\tSee bugs-fixed/space.awk.\n\n\tThis appears to have been a thinko on Brian's part.\n\n\t* b.c (charclasses): Use xisblank() function for [[:blank:]].\n\t* bugs-fixed/README: Updated.\n\t* bugs-fixed/space.awk, bugs-fixed/space.bad,\n\tbugs-fixed/space.ok: New files.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* .gitignore: New file.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tFix nawk to provide reasonable exit status for system(),\n\ta la gawk, originally made March 12, 2016. See\n\tbugs-fixed/system-status.awk.\n\n\t* run.c (bltin): For FSYSTEM, use the macros defined for wait(2)\n\tto produce a reasonable exit value, instead of doing a floating-point\n\tdivision by 256.\n\t* awk.1: Document the return status values.\n\t* bugs-fixed/README: Updated.\n\t* bugs-fixed/system-status.awk, bugs-fixed/system-status.bad,\n\tbugs-fixed/system-status.ok: New files.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\tBug fix with respect to rebuilding a record, originally\n\tmade August 19, 2014. See bugs-fixed/ofs-rebuild.awk.\n\n\t* awk.h (saveOFS, saveOFSlen): Declare new variables.\n\t* lib.c (recbld): Use them when rebuilding the record.\n\t* run.c (saveOFS, saveOFSlen): Define new variables.\n\t(save_old_OFS): New function to save OFS aside.\n\t* tran.c (syminit): Initialize saveOFS and saveOFSlen.\n\t(setsval): If setting a field, call save_old_OFS().\n\t* bugs-fixed/README, bugs-fixed/ofs-rebuild.awk,\n\tbugs-fixed/ofs-rebuild.bad, bugs-fixed/ofs-rebuild.ok: New files.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* makefile (YACC): Use bison.\n\n2018-05-22         Arnold D. Robbins     <arnold@skeeve.com>\n\n\t* ChangeLog: Created.\n\t* regdir: Created. Based on contents of awktest.a.\n\t* .gitattributes: Created, to preserve CR LF in regdir/t.crlf.\n\t* awktest.a: Removed.\n\t* regdir/T.gawk, regdir/T.latin1: Updated from awktest.tar.\n\t* awktest.tar: Removed.\n"
        },
        {
          "name": "FIXES",
          "type": "blob",
          "size": 5.6240234375,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\nThis file lists all bug fixes, changes, etc., made since the \nsecond edition of the AWK book was published in September 2023.\n\nJan 05, 2025\n\tFix hex detection in is_valid_number.\n\tFix indirect field specification with non-numeric string\n\teg. $(\"foo\") in indirect. This is not illegal.\n\tThanks to Arnold Robbins.\n\nJan 01, 2025\n\tFixed openfile to not try to read from a directory.\n\tThanks to Arnold Robbins.\n\nJul 28, 2024\n\tFixed readcsvrec resize segfault when reading csv records longer\n\tthan 8k. Thanks to Ozan Yigit.\n\tmktime() added to bsd-features branch. Thanks to Todd Miller.\n\nJun 23, 2024\n\tFix signal for system-status test. Thanks to Tim van der Molen.\n\tRewrite if-else chain as switch. Thanks to Andrew Sukach.\n\nMay 27, 2024\n\tSpelling fixes and removal of unneeded prototypes and extern.\n\tThanks to Jonathan Gray.\n\nMay 4, 2024\n\tFixed a use-after-free bug with ARGV for \"delete ARGV\".\n\tAlso ENVtab is no longer global. Thanks to Benjamin Sturz\n\tfor spotting the ARGV issue and\tTodd Miller for the fix. \n\nMay 3, 2024:\n\tRemove warnings when compiling with g++. Thanks to Arnold Robbins.\n\nApr 22, 2024:\n\tFixed regex engine gototab reallocation issue that was\n\tIntroduced during the Nov 24 rewrite. Thanks to Arnold Robbins.\n\tFixed a scan bug in split in the case the separator is a single\n\tcharacter. Thanks to Oguz Ismail for spotting the issue.\n\nMar 10, 2024:\n\tFixed use-after-free bug in fnematch due to adjbuf invalidating\n\tthe pointers to buf. Thanks to github user caffe3 for spotting\n\tthe issue and providing a fix, and to Miguel Pineiro Jr.\n\tfor the alternative fix.\n\tMAX_UTF_BYTES in fnematch has been replaced with awk_mb_cur_max.\n\tthanks to Miguel Pineiro Jr.\n\nJan 22, 2024:\n\tRestore the ability to compile with g++. Thanks to\n\tArnold Robbins.\n\nDec 24, 2023:\n\tMatchop dereference after free problem fix when the first\n\targument is a function call. Thanks to Oguz Ismail Uysal.\n\tFix inconsistent handling of --csv and FS set in the\n\tcommand line. Thanks to Wilbert van der Poel.\n\tCasting changes to int for is* functions. \n\nNov 27, 2023:\n\tFix exit status of system on MacOS. Update to REGRESS.\n\tThanks to Arnold Robbins. \n\tFix inconsistent handling of -F and --csv, and loss of csv\n\tmode when FS is set. \n\t\nNov 24, 2023:\n        Fix issue #199: gototab improvements to dynamically resize the\n        table, qsort and bsearch to improve the lookup speed as the\n        table gets larger for multibyte input. Thanks to Arnold Robbins.\n\nNov 23, 2023:\n\tFix Issue #169, related to escape sequences in strings.\n\tThanks to Github user rajeevvp.\n\tFix Issue #147, reported by Github user drawkula, and fixed\n\tby Miguel Pineiro Jr.\n\nNov 20, 2023:\n\tRewrite of fnematch to fix a number of issues, including\n\textraneous output, out-of-bounds access, number of bytes\n\tto push back after a failed match etc.\n\tThanks to Miguel Pineiro Jr.\n\nNov 15, 2023:\n\tMan page edit, regression test fixes. Thanks to Arnold Robbins\n\tConsolidation of sub and gsub into dosub, removing duplicate\n\tcode. Thanks to Miguel Pineiro Jr.\n\tgcc replaced with cc everywhere.\n\nOct 30, 2023:\n\tMultiple fixes and a minor code cleanup.\n\tDisabled utf-8 for non-multibyte locales, such as C or POSIX.\n\tFixed a bad char * cast that causes incorrect results on big-endian\n\tsystems. Also fixed an out-of-bounds read for empty CCL.\n\tFixed a buffer overflow in substr with utf-8 strings.\n\tMany thanks to Todd C Miller.\n\nSep 24, 2023:\n\tfnematch and getrune have been overhauled to solve issues around\n\tunicode FS and RS. Also fixed gsub null match issue with unicode.\n\tBig thanks to Arnold Robbins.\n\nSep 12, 2023:\n\tFixed a length error in u8_byte2char that set RSTART to\n\tincorrect (cannot happen) value for EOL match(str, /$/).\n\n\n-----------------------------------------------------------------\n\n[This entry is a summary, not a precise list of changes.]\n\n\tAdded --csv option to enable processing of comma-separated\n\tvalues inputs.  When --csv is enabled, fields are separated\n\tby commas, fields may be quoted with \" double quotes, fields\n\tmay contain embedded newlines.\n\n\tIf no explicit separator argument is provided, split() uses\n\tthe setting of --csv to determine how fields are split.\n\n\tStrings may now contain UTF-8 code points (not necessarily\n\tcharacters).  Functions that operate on characters, like\n\tlength, substr, index, match, etc., use UTF-8, so the length\n\tof a string of 3 emojis is 3, not 12 as it would be if bytes\n\twere counted.\n\n\tRegular expressions are processed as UTF-8.\n\n\tUnicode literals can be written as \\u followed by one\n\tto eight hexadecimal digits.  These may appear in strings and\n\tregular expressions.\n"
        },
        {
          "name": "FIXES.1e",
          "type": "blob",
          "size": 49.091796875,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\nThis file lists all bug fixes, changes, etc., made since the AWK book\nwas sent to the printers in August 1987.\n\nSep 06, 2023:\n\tFix edge case where FS is changed on commandline. Thanks to \n\tGordon Shephard and Miguel Pineiro Jr.\n\n\tFix regular expression clobbering in the lexer, where lexer does\n\tnot make a copy of regexp literals. also makedfa memory leaks have\n\tbeen plugged. Thanks to Miguel Pineiro Jr.\n\t\nDec 15, 2022:\n\tForce hex escapes in strings to be no more than two characters,\n\tas they already are in regular expressions. This brings internal\n\tconsistency, as well as consistency with gawk. Thanks to\n\tArnold Robbins.\n\nSep 12, 2022:\n\tadjbuf minlen error (cannot be 0) in cat, resulting in NULL pbuf.\n\tdiscovered by todd miller. also use-after-free issue with\n\ttempfree in cat, thanks to Miguel Pineiro Jr and valgrind.\n\nAug 30, 2022:\n\tVarious leaks and use-after-free issues plugged/fixed.\n\tThanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.\n\nMay 23, 2022:\n\tMemory leak when assigning a string to some of the built-in\n\tvariables. allocated string erroneously marked DONTFREE.\n\tThanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.\n\nMar 14, 2022:\n\tHistoric bug: command-line \"name=value\" assignment had been\n\ttruncating its entry in ARGV. (circa 1989) Thanks to \n\tMiguel Pineiro Jr. <mpj@pineiro.cc>.\n\nMar 3, 2022:\n\tFixed file management memory leak that appears to have been\n\tthere since the files array was first initialized with stdin,\n\tstdout, and stderr (circa 1992). Thanks to Miguel Pineiro Jr.\n\t<mpj@pineiro.cc>.\n\nDecember 8, 2021:\n\tThe error handling in closefile and closeall was mangled. Long\n\tstanding warnings had been made fatal and some fatal errors went\n\tundetected. Thanks to Miguel Pineiro Jr. <mpj@pineiro.cc>.\n\nNov 03, 2021:\n        getline accesses uninitialized data after getrec()\n\treturns 0 on EOF and leaves the contents of buf unchanged.\n\tThanks to Volodymyr Gubarkov, and Todd C Miller.\n\nOct 12, 2021:\n\tThe fix for #83 changed the code to insert 2 chars, but the\n\tcall to adjbuf just above it only allows for 1 char. This can\n\tcause a heap buffer overflow.\n\nJuly 27, 2021:\n\tAs per IEEE Std 1003.1-2008, -F \"str\" is now consistent with\n\t-v FS=\"str\" when str is null. Thanks to Warner Losh.\n\nJuly 24, 2021:\n\tFix readrec's definition of a record. This fixes an issue\n\twith NetBSD's RS regular expression support that can cause\n\tan infinite read loop. Thanks to Miguel Pineiro Jr.\n\n\tFix regular expression RS ^-anchoring. RS ^-anchoring needs to\n\tknow if it is reading the first record of a file. This change\n\trestores a missing line that was overlooked when porting NetBSD's\n\tRS regex functionality. Thanks to Miguel Pineiro Jr.\n\n\tFix size computation in replace_repeat() for special case\n\tREPEAT_WITH_Q. Thanks to Todd C. Miller.\n\nFebruary 15, 2021:\n\tSmall fix so that awk will compile again with g++. Thanks to\n\tArnold Robbins.\n\nJanuary 06, 2021:\n\tFix a decision bug with trailing stuff in lib.c:is_valid_number\n\tafter recent changes. Thanks to Ozan Yigit.\n\nDecember 18, 2020:\n\tFix problems converting inf and NaN values in lib.c:is_valid_number.\n\tEnhance number to string conversion to do the right thing for\n\tNaN and inf values.  Things are now pretty much the same as in\n\tgawk.  (Found a gawk bug while we're at it.) Added a torture\n\ttest for these values.  Thanks to Arnold Robbins.  Allows closing\n\tof PR #101.\n\nDecember 15, 2020:\n\tMerge PR #99, which gets the right header for strcasecmp.\n\tThanks to GitHub user michaelforney.\n\nDecember 8, 2020:\n\tMerge PR #98: Disallow hex data. Allow only +nan, -nan,\n\t+inf, -inf (case independent) to give NaN and infinity values.\n\tImprove things so that string to double conversion is only\n\tdone once, yielding something of a speedup.  This obviate\n\tPR #95. Thanks to Arnold Robbins.\n\nDecember 3, 2020:\n\tFix to argument parsing to avoid printing spurious newlines.\n\tThanks to Todd Miller. Merges PR #97.\n\nOctober 13, 2020:\n\tAdd casts before all the calls to malloc/calloc/realloc in order\n\tto get it to compile with g++. Thanks to Arnold Robbins.\n\nAugust 16, 2020:\n\tAdditional fixes for DJGPP. Thanks to Eli Zaretskii for\n\tthe testing.\n\nAugust 7, 2020:\n\tMerge PR #93, which adds casts to (void*) for debug prints\n\tusing the %p format specifier. Thanks to GitHub user YongHaoWu\n\t(\"Chris\") for the fixes.\n\nAugust 4, 2020:\n\tIn run.c, use non-restartable multibyte routines to attain\n\tportability to DJGPP. Should fix Issue 92. Thanks to Albert Wik\n\tfor the report and to Todd Miller for the suggested fix.\n\nJuly 30, 2020:\n\tMerge PRs 88-91 which fix small bugs. Thanks to Todd Miller and\n\tTim van der Molen for the fixes.\n\n\tIn order to make life easier, we move exclusively to bison\n\tas the parser generator.\n\nJuly 2, 2020:\n\tMerge PRs 85 and 86 which fix regressions. Thanks to\n\tTim van der Molen for the fixes.\n\nJune 25, 2020:\n\tMerge PRs 82 and 84. The latter fixes issue #83. Thanks to\n\tTodd Miller and awkfan77.\n\nJune 12, 2020:\n\tClear errno before calling errcheck to avoid any spurious errors\n\tleft over from previous calls that may have set it. Thanks to\n\tTodd Miller for the fix, from PR #80.\n\n\tFix Issue #78 by allowing \\r to follow floating point numbers in\n\tlib.c:is_number. Thanks to GitHub user ajcarr for the report\n\tand to Arnold Robbins for the fix.\n\nJune 5, 2020:\n\tIn fldbld(), make sure that inputFS is set before trying to\n\tuse it. Thanks to  Steffen Nurpmeso <steffen@sdaoden.eu>\n\tfor the report.\n\nMay 5, 2020:\n\tFix checks for compilers that can handle noreturn. Thanks to\n\tGitHub user enh-google for pointing it out. Closes Issue #79.\n\nApril 16, 2020:\n\tHandle old compilers that don't support C11 (for noreturn).\n\tThanks to Arnold Robbins.\n\nApril 5, 2020:\n\tUse <stdnoreturn.h> and noreturn instead of GCC attributes.\n\tThanks to GitHub user awkfan77. Closes PR #77.\n\nFebruary 28, 2020:\n\tMore cleanups from Christos Zoulas: notably backslash continuation\n\tinside strings removes the newline and a fix for RS = \"^a\".\n\tFix for address sanitizer-found problem. Thanks to GitHub user\n\tenh-google.\n\nFebruary 19, 2020:\n\tMore small cleanups from Christos Zoulas.\n\nFebruary 18, 2020:\n\tAdditional cleanups from Christos Zoulas. It's no longer necessary\n\tto use the -y flag to bison.\n\nFebruary 6, 2020:\n\tAdditional small cleanups from Christos Zoulas. awk is now\n\ta little more robust about reporting I/O errors upon exit.\n\nJanuary 31, 2020:\n\tMerge PR #70, which avoids use of variable length arrays. Thanks\n\tto GitHub user michaelforney.  Fix issue #60 ({0} in interval\n\texpressions doesn't work).  Also get all tests working again.\n\tThanks to Arnold Robbins.\n\nJanuary 24, 2020:\n\tA number of small cleanups from Christos Zoulas.  Add the close\n\ton exec flag to files/pipes opened for redirection; courtesy of\n\tArnold Robbins.\n\nJanuary 19, 2020:\n\tIf POSIXLY_CORRECT is set in the environment, then sub and gsub\n\tuse POSIX rules for multiple backslashes.  This fixes Issue #66,\n\twhile maintaining backwards compatibility.\n\nJanuary 9, 2020:\n\tInput/output errors on closing files are now fatal instead of\n\tmere warnings. Thanks to Martijn Dekker <martijn@inlv.org>.\n\nJanuary 5, 2020:\n\tFix a bug in the concatenation of two string constants into\n\tone done in the grammar.  Fixes GitHub issue #61.  Thanks\n\tto GitHub user awkfan77 for pointing out the direction for\n\tthe fix.  New test T.concat added to the test suite.\n\tFix a few memory leaks reported by valgrind, as well.\n\nDecember 27, 2019:\n\tFix a bug whereby a{0,3} could match four a's.  Thanks to\n\t\"Anonymous AWK fan\" for the report.\n\nDecember 11, 2019:\n\tFurther printf-related fixes for 32 bit systems.\n\tThanks again to Christos Zoulas.\n\nDecember 8, 2019:\n\tFix the return value of sprintf(\"%d\") on 32 bit systems.\n\tThanks to Jim Lowe for the report and to Christos Zoulas\n\tfor the fix.\n\nNovember 10, 2019:\n\tConvert a number of Boolean integer variables into\n\tactual bools. Convert compile_time variable into an\n\tenum and simplify some of the related code.  Thanks\n\tto Arnold Robbins.\n\nNovember 8, 2019:\n\tFix from Ori Bernstein to get UTF-8 characters instead of\n\tbytes when FS = \"\".  This is currently the only bit of\n\tthe One True Awk that understands multibyte characters.\n\tFrom Arnold Robbins, apply some cleanups in the test suite.\n\nOctober 25, 2019:\n\tMore fixes and cleanups from NetBSD, courtesy of Christos\n\tZoulas. Merges PRs 54 and 55.\n\nOctober 24, 2019:\n\tImport second round of code cleanups from NetBSD. Much thanks\n\tto Christos Zoulas (GitHub user zoulasc). Merges PR 53.\n\tAdd an optimization for string concatenation, also from\n\tChristos.\n\nOctober 17, 2019:\n\tImport code cleanups from NetBSD. Much thanks to Christos\n\tZoulas (GitHub user zoulasc). Merges PR 51.\n\nOctober 6, 2019:\n\tImport code from NetBSD awk that implements RS as a regular\n\texpression.\n\nSeptember 10, 2019:\n\tFixes for various array / memory overruns found via gcc's\n\t-fsanitize=unknown. Thanks to Alexander Richardson (GitHub\n\tuser arichardson). Merges PRs 47 and 48.\n\nJuly 28, 2019:\n\tImport grammar optimization from NetBSD: Two string constants\n\tconcatenated together get turned into a single string.\n\nJuly 26, 2019:\n\tSupport POSIX-specified C-style escape sequences \"\\a\" (alarm)\n\tand \"\\v\" (vertical tab) in command line arguments and regular\n\texpressions, further to the support for them in strings added on\n\tApr 9, 1989. These now no longer match as literal \"a\" and \"v\"\n\tcharacters (as they don't on other awk implementations).\n\tThanks to Martijn Dekker.\n\nJuly 17, 2019:\n\tPull in a number of code cleanups and minor fixes from\n\tWarner Losh's bsd-ota branch.  The only user visible change\n\tis the use of random(3) as the random number generator.\n\tThanks to Warner Losh for collecting all these fixes in\n\tone easy place to get them from.\n\nJuly 16, 2019:\n\tFix field splitting to use FS value as of the time a record\n\twas read or assigned to.  Thanks to GitHub user Cody Mello (melloc)\n\tfor the fix. (Merged from his branch, via PR #42.) Updated\n\ttestdir/T.split per said PR as well.\n\nJune 24, 2019:\n\tExtract awktest.tar into testdir directory. Add some very\n\tsimple mechanics to the makefile for running the tests and\n\tfor cleaning up. No changes to awk itself.\n\nJune 17, 2019:\n\tDisallow deleting SYMTAB and its elements, which creates\n\tuse-after-free bugs. Thanks to GitHub user Cody Mello (melloc)\n\tfor the fix. (Merged from PR #43.)\n\nJune 5, 2019:\n\tAllow unmatched right parenthesis in a regular expression to\n\tbe treated literally. Fixes Issue #40. Thanks to GitHub user\n\tWarner Losh (bsdimp) for the report. Thanks to Arnold Robbins\n\tfor the fix.\n\nMay 29,2019:\n\tFix check for command line arguments to no longer require that\n\tfirst character after '=' not be another '='. Reverts change of\n\tAugust 11, 1989. Thanks to GitHub user Jamie Landeg Jones for\n\tpointing out the issue; from Issue #38.\n\nApr 7, 2019:\n\tUpdate awktest.tar(p.50) to use modern options to sort. Needed\n\tfor Android development. Thanks to GitHub user mohd-akram (Mohamed\n\tAkram).  From Issue #33.\n\nMar 12, 2019:\n\tAdded very simplistic support for cross-compiling in the\n\tmakefile.  We are NOT going to go in the direction of the\n\tautotools, though.  Thanks to GitHub user nee-san for\n\tthe basic change. (Merged from PR #34.)\n\nMar 5, 2019:\n\tAdded support for POSIX-standard interval expressions (a.k.a.\n\tbounds, a.k.a. repetition expressions) in regular expressions,\n\tbackported (via NetBSD) from Apple awk-24 (20070501).\n\tThanks to Martijn Dekker <martijn@inlv.org> for the port.\n\t(Merged from PR #30.)\n\nMar 3, 2019:\n\tMerge PRs as follows:\n\t#12: Avoid undefined behaviour when using ctype(3) functions in\n\t     relex(). Thanks to GitHub user iamleot.\n\t#31: Make getline handle numeric strings, and update FIXES. Thanks\n\t     to GitHub user Arnold Robbins (arnoldrobbins)\n\t#32: maketab: support build systems with read-only source. Thanks\n\t     to GitHub user enh.\n\nJan 25, 2019:\n\tMake getline handle numeric strings properly in all cases.\n\t(Thanks, Arnold.)\n\nJan 21, 2019:\n\tMerged a number of small fixes from GitHub pull requests.\n\tThanks to GitHub users Arnold Robbins (arnoldrobbins),\n\tCody Mello (melloc) and Christoph Junghans (junghans).\n\tPR numbers: 13-21, 23, 24, 27.\n\nOct 25, 2018:\n\tAdded test in maketab.c to prevent generating a proctab entry\n\tfor YYSTYPE_IS_DEFINED.  It was harmless but some gcc settings\n\tgenerated a warning message.  Thanks to Nan Xiao for report.\n\nAug 27, 2018:\n\tDisallow '$' in printf formats; arguments evaluated in order\n\tand printed in order.\n\n\tAdded some casts to silence warnings on debugging printfs.\n\t(Thanks, Arnold.)\n\nAug 23, 2018:\n        A long list of fixes courtesy of Arnold Robbins,\n        to whom profound thanks.\n\n        1. ofs-rebuild: OFS value used to rebuild the record was incorrect.\n        Fixed August 19, 2014. Revised fix August 2018.\n\n        2. system-status: Instead of a floating-point division by 256, use\n        the wait(2) macros to create a reasonable exit status.\n        Fixed March 12, 2016.\n\n        3. space: Use provided xisblank() function instead of ispace() for\n        matching [[:blank:]].\n\n        4. a-format: Add POSIX standard %a and %A to supported formats. Check\n        at runtime that this format is available.\n\n        5. decr-NF: Decrementing NF did not change $0. This is a decades-old\n        bug. There are interactions with the old and new value of OFS as well.\n        Most of the fix came from the NetBSD awk.\n\n        6. string-conv: String conversions of scalars were sticky.  Once a\n        conversion to string happened, even with OFMT, that value was used until\n        a new numeric value was assigned, even if OFMT differed from CONVFMT,\n        and also if CONVFMT changed.\n\n        7. unary-plus: Unary plus on a string constant returned the string.\n        Instead, it should convert the value to numeric and give that value.\n\n\tAlso added Arnold's tests for these to awktest.tar as T.arnold.\n\nAug 15, 2018:\n\tfixed mangled awktest.tar (thanks, Arnold), posted all\n\tcurrent (very minor) fixes to github / onetrueawk\n\nJun 7, 2018:\n\t(yes, a long layoff)\n\tUpdated some broken tests (beebe.tar, T.lilly)\n\t[thanks to Arnold Robbins]\n\nMar 26, 2015:\n\tbuffer overflow in error reporting; thanks to tobias ulmer\n\tand john-mark gurney for spotting it and the fix.\n\nFeb 4, 2013:\n\tcleaned up a handful of tests that didn't seem to actually\n\ttest for correct behavior: T.latin1, T.gawk.\n\nJan 5, 2013:\n\tadded ,NULL initializer to static Cells in run.c; not really\n\tneeded but cleaner.  Thanks to Michael Bombardieri.\n\nDec 20, 2012:\n\tfiddled makefile to get correct yacc and bison flags.  pick yacc\n\t(linux) or bison (mac) as necessary.\n\n\tadded  __attribute__((__noreturn__)) to a couple of lines in\n\tproto.h, to silence someone's enthusiastic checker.\n\n\tfixed obscure call by value bug in split(a[1],a) reported on\n\t9fans.  the management of temporary values is just a mess; i\n\ttook a shortcut by making an extra string copy.  thanks\n\tto paul patience and arnold robbins for passing it on and for\n\tproposed patches.\n\n\ttiny fiddle in setfval to eliminate -0 results in T.expr, which\n\thas irritated me for 20+ years.\n\nAug 10, 2011:\n\tanother fix to avoid core dump with delete(ARGV); again, many thanks\n\tto ruslan ermilov.\n\nAug 7, 2011:\n\tsplit(s, a, //) now behaves the same as split(s, a, \"\")\n\nJun 12, 2011:\n\t/pat/, \\n /pat/ {...} is now legal, though bad style to use.\n\n\tadded checks to new -v code that permits -vnospace; thanks to\n\truslan ermilov for spotting this and providing the patch.\n\n\tremoved fixed limit on number of open files; thanks to aleksey\n\tcheusov and christos zoulos.\n\n\tfixed day 1 bug that resurrected deleted elements of ARGV when\n\tused as filenames (in lib.c).\n\n\tminor type fiddles to make gcc -Wall -pedantic happier (but not\n\ttotally so); turned on -fno-strict-aliasing in makefile.\n\nMay 6, 2011:\n\tadded #ifdef for isblank.\n\tnow allows -ffoo as well as -f foo arguments.\n\t(thanks, ruslan)\n\nMay 1, 2011:\n\tafter advice from todd miller, kevin lo, ruslan ermilov,\n\tand arnold robbins, changed srand() to return the previous\n\tseed (which is 1 on the first call of srand).  the seed is\n\tan Awkfloat internally though converted to unsigned int to\n\tpass to the library srand().  thanks, everyone.\n\n\tfixed a subtle (and i hope low-probability) overflow error\n\tin fldbld, by adding space for one extra \\0.  thanks to\n\trobert bassett for spotting this one and providing a fix.\n\n\tremoved the files related to compilation on windows.  i no\n\tlonger have anything like a current windows environment, so\n\ti can't test any of it.\n\nMay 23, 2010:\n\tfixed long-standing overflow bug in run.c; many thanks to\n\tnelson beebe for spotting it and providing the fix.\n\n\tfixed bug that didn't parse -vd=1 properly; thanks to santiago\n\tvila for spotting it.\n\nFeb 8, 2010:\n\ti give up.  replaced isblank with isspace in b.c; there are\n\tno consistent header files.\n\nNov 26, 2009:\n\tfixed a long-standing issue with when FS takes effect.  a\n\tchange to FS is now noticed immediately for subsequent splits.\n\n\tchanged the name getline() to awkgetline() to avoid yet another\n\tname conflict somewhere.\n\nFeb 11, 2009:\n\ttemporarily for now defined HAS_ISBLANK, since that seems to\n\tbe the best way through the thicket.  isblank arrived in C99,\n\tbut seems to be arriving at different systems at different\n\ttimes.\n\nOct 8, 2008:\n\tfixed typo in b.c that set tmpvec wrongly.  no one had ever\n\trun into the problem, apparently.  thanks to alistair crooks.\n\nOct 23, 2007:\n\tminor fix in lib.c: increase inputFS to 100, change malloc\n\tfor fields to n+1.\n\n\tfixed memory fault caused by out of order test in setsval.\n\n\tthanks to david o'brien, freebsd, for both fixes.\n\nMay 1, 2007:\n\tfiddle in makefile to fix for BSD make; thanks to igor sobrado.\n\nMar 31, 2007:\n\tfixed some null pointer refs calling adjbuf.\n\nFeb 21, 2007:\n\tfixed a bug in matching the null RE in sub and gsub.  thanks to al aho\n\twho actually did the fix (in b.c), and to wolfgang seeberg for finding\n\tit and providing a very compact test case.\n\n\tfixed quotation in b.c; thanks to Hal Pratt and the Princeton Dante\n\tProject.\n\n\tremoved some no-effect asserts in run.c.\n\n\tfiddled maketab.c to not complain about bison-generated values.\n\n\tremoved the obsolete -V argument; fixed --version to print the\n\tversion and exit.\n\n\tfixed wording and an outright error in the usage message; thanks to igor\n\tsobrado and jason mcintyre.\n\n\tfixed a bug in -d that caused core dump if no program followed.\n\nJan 1, 2007:\n\tdropped mac.code from makefile; there are few non-MacOSX\n\tmac's these days.\n\nJan 17, 2006:\n\tsystem() not flagged as unsafe in the unadvertised -safe option.\n\tfound it while enhancing tests before shipping the ;login: article.\n\tpractice what you preach.\n\n\tremoved the 9-years-obsolete -mr and -mf flags.\n\n\tadded -version and --version options.\n\n\tcore dump on linux with BEGIN {nextfile}, now fixed.\n\n\tremoved some #ifdef's in run.c and lex.c that appear to no\n\tlonger be necessary.\n\nApr 24, 2005:\n\tmodified lib.c so that values of $0 et al are preserved in the END\n\tblock, apparently as required by posix.  thanks to havard eidnes\n\tfor the report and code.\n\nJan 14, 2005:\n\tfixed infinite loop in parsing, originally found by brian tsang.\n\tthanks to arnold robbins for a suggestion that started me\n\trethinking it.\n\nDec 31, 2004:\n\tprevent overflow of -f array in main, head off potential error in\n\tcall of SYNTAX(), test malloc return in lib.c, all with thanks to\n\ttodd miller.\n\nDec 22, 2004:\n\tcranked up size of NCHARS; coverity thinks it can be overrun with\n\tsmaller size, and i think that's right.  added some assertions to b.c\n\tto catch places where it might overrun.  the RE code is still fragile.\n\nDec 5, 2004:\n\tfixed a couple of overflow problems with ridiculous field numbers:\n\te.g., print $(2^32-1).  thanks to ruslan ermilov, giorgos keramidas\n\tand david o'brien at freebsd.org for patches.  this really should\n\tbe re-done from scratch.\n\nNov 21, 2004:\n\tfixed another 25-year-old RE bug, in split.  it's another failure\n\tto (re-)initialize.  thanks to steve fisher for spotting this and\n\tproviding a good test case.\n\nNov 22, 2003:\n\tfixed a bug in regular expressions that dates (so help me) from 1977;\n\tit's been there from the beginning.  an anchored longest match that\n\twas longer than the number of states triggered a failure to initialize\n\tthe machine properly.  many thanks to moinak ghosh for not only finding\n\tthis one but for providing a fix, in some of the most mysterious\n\tcode known to man.\n\n\tfixed a storage leak in call() that appears to have been there since\n\t1983 or so -- a function without an explicit return that assigns a\n\tstring to a parameter leaked a Cell.  thanks to moinak ghosh for\n\tspotting this very subtle one.\n\nJul 31, 2003:\n\tfixed, thanks to andrey chernov and ruslan ermilov, a bug in lex.c\n\tthat mis-handled the character 255 in input.  (it was being compared\n\tto EOF with a signed comparison.)\n\nJul 29, 2003:\n\tfixed (i think) the long-standing botch that included the beginning of\n\tline state ^ for RE's in the set of valid characters; this led to a\n\tvariety of odd problems, including failure to properly match certain\n\tregular expressions in non-US locales.  thanks to ruslan for keeping\n\tat this one.\n\nJul 28, 2003:\n\tn-th try at getting internationalization right, with thanks to volker\n\tkiefel, arnold robbins and ruslan ermilov for advice, though they\n\tshould not be blamed for the outcome.  according to posix, \".\"  is the\n\tradix character in programs and command line arguments regardless of\n\tthe locale; otherwise, the locale should prevail for input and output\n\tof numbers.  so it's intended to work that way.\n\n\ti have rescinded the attempt to use strcoll in expanding shorthands in\n\tregular expressions (cclenter).  its properties are much too\n\tsurprising; for example [a-c] matches aAbBc in locale en_US but abBcC\n\tin locale fr_CA.  i can see how this might arise by implementation\n\tbut i cannot explain it to a human user.  (this behavior can be seen\n\tin gawk as well; we're leaning on the same library.)\n\n\tthe issue appears to be that strcoll is meant for sorting, where\n\tmerging upper and lower case may make sense (though note that unix\n\tsort does not do this by default either).  it is not appropriate\n\tfor regular expressions, where the goal is to match specific\n\tpatterns of characters.  in any case, the notations [:lower:], etc.,\n\tare available in awk, and they are more likely to work correctly in\n\tmost locales.\n\n\ta moratorium is hereby declared on internationalization changes.\n\ti apologize to friends and colleagues in other parts of the world.\n\ti would truly like to get this \"right\", but i don't know what\n\tthat is, and i do not want to keep making changes until it's clear.\n\nJul 4, 2003:\n\tfixed bug that permitted non-terminated RE, as in \"awk /x\".\n\nJun 1, 2003:\n\tsubtle change to split: if source is empty, number of elems\n\tis always 0 and the array is not set.\n\nMar 21, 2003:\n\tadded some parens to isblank, in another attempt to make things\n\tinternationally portable.\n\nMar 14, 2003:\n\tthe internationalization changes, somewhat modified, are now\n\treinstated.  in theory awk will now do character comparisons\n\tand case conversions in national language, but \".\" will always\n\tbe the decimal point separator on input and output regardless\n\tof national language.  isblank(){} has an #ifndef.\n\n\tthis no longer compiles on windows: LC_MESSAGES isn't defined\n\tin vc6++.\n\n\tfixed subtle behavior in field and record splitting: if FS is\n\ta single character and RS is not empty, \\n is NOT a separator.\n\tthis tortuous reading is found in the awk book; behavior now\n\tmatches gawk and mawk.\n\nDec 13, 2002:\n\tfor the moment, the internationalization changes of nov 29 are\n\trolled back -- programs like x = 1.2 don't work in some locales,\n\tbecause the parser is expecting x = 1,2.  until i understand this\n\tbetter, this will have to wait.\n\nNov 29, 2002:\n\tmodified b.c (with tiny changes in main and run) to support\n\tlocales, using strcoll and iswhatever tests for posix character\n\tclasses.  thanks to ruslan ermilov (ru@freebsd.org) for code.\n\tthe function isblank doesn't seem to have propagated to any\n\theader file near me, so it's there explicitly.  not properly\n\ttested on non-ascii character sets by me.\n\nJun 28, 2002:\n\tmodified run/format() and tran/getsval() to do a slightly better\n\tjob on using OFMT for output from print and CONVFMT for other\n\tnumber->string conversions, as promised by posix and done by\n\tgawk and mawk.  there are still places where it doesn't work\n\tright if CONVFMT is changed; by then the STR attribute of the\n\tvariable has been irrevocably set.  thanks to arnold robbins for\n\tcode and examples.\n\n\tfixed subtle bug in format that could get core dump.  thanks to\n\tJaromir Dolecek <jdolecek@NetBSD.org> for finding and fixing.\n\tminor cleanup in run.c / format() at the same time.\n\n\tadded some tests for null pointers to debugging printf's, which\n\twere never intended for external consumption.  thanks to dave\n\tkerns (dkerns@lucent.com) for pointing this out.\n\n\tGNU compatibility: an empty regexp matches anything (thanks to\n\tdag-erling smorgrav, des@ofug.org).  subject to reversion if\n\tthis does more harm than good.\n\n\tpervasive small changes to make things more const-correct, as\n\treported by gcc's -Wwrite-strings.  as it says in the gcc manual,\n\tthis may be more nuisance than useful.  provoked by a suggestion\n\tand code from arnaud desitter, arnaud@nimbus.geog.ox.ac.uk\n\n\tminor documentation changes to note that this now compiles out\n\tof the box on Mac OS X.\n\nFeb 10, 2002:\n\tchanged types in posix chars structure to quiet solaris cc.\n\nJan 1, 2002:\n\tfflush() or fflush(\"\") flushes all files and pipes.\n\n\tlength(arrayname) returns number of elements; thanks to\n\tarnold robbins for suggestion.\n\n\tadded a makefile.win to make it easier to build on windows.\n\tbased on dan allen's buildwin.bat.\n\nNov 16, 2001:\n\tadded support for posix character class names like [:digit:],\n\twhich are not exactly shorter than [0-9] and perhaps no more\n\tportable.  thanks to dag-erling smorgrav for code.\n\nFeb 16, 2001:\n\tremoved -m option; no longer needed, and it was actually\n\tbroken (noted thanks to volker kiefel).\n\nFeb 10, 2001:\n\tfixed an appalling bug in gettok: any sequence of digits, +,-, E, e,\n\tand period was accepted as a valid number if it started with a period.\n\tthis would never have happened with the lex version.\n\n\tother 1-character botches, now fixed, include a bare $ and a\n\tbare \" at the end of the input.\n\nFeb 7, 2001:\n\tmore (const char *) casts in b.c and tran.c to silence warnings.\n\nNov 15, 2000:\n\tfixed a bug introduced in august 1997 that caused expressions\n\tlike $f[1] to be syntax errors.  thanks to arnold robbins for\n\tnoticing this and providing a fix.\n\nOct 30, 2000:\n\tfixed some nextfile bugs: not handling all cases.  thanks to\n\tarnold robbins for pointing this out.  new regressions added.\n\n\tclose() is now a function.  it returns whatever the library\n\tfclose returns, and -1 for closing a file or pipe that wasn't\n\topened.\n\nSep 24, 2000:\n\tpermit \\n explicitly in character classes; won't work right\n\tif comes in as \"[\\n]\" but ok as /[\\n]/, because of multiple\n\tprocessing of \\'s.  thanks to arnold robbins.\n\nJuly 5, 2000:\n\tminor fiddles in tran.c to keep compilers happy about uschar.\n\tthanks to norman wilson.\n\nMay 25, 2000:\n\tyet another attempt at making 8-bit input work, with another\n\tband-aid in b.c (member()), and some (uschar) casts to head\n\toff potential errors in subscripts (like isdigit).  also\n\tchanged HAT to NCHARS-2.  thanks again to santiago vila.\n\n\tchanged maketab.c to ignore apparently out of range definitions\n\tinstead of halting; new freeBSD generates one.  thanks to\n\tjon snader <jsnader@ix.netcom.com> for pointing out the problem.\n\nMay 2, 2000:\n\tfixed an 8-bit problem in b.c by making several char*'s into\n\tunsigned char*'s.  not clear i have them all yet.  thanks to\n\tSantiago Vila <sanvila@unex.es> for the bug report.\n\nApr 21, 2000:\n\tfinally found and fixed a memory leak in function call; it's\n\tbeen there since functions were added ~1983.  thanks to\n\tjon bentley for the test case that found it.\n\n\tadded test in envinit to catch environment \"variables\" with\n\tnames beginning with '='; thanks to Berend Hasselman.\n\nJul 28, 1999:\n\tadded test in defn() to catch function foo(foo), which\n\totherwise recurses until core dump.  thanks to arnold\n\trobbins for noticing this.\n\nJun 20, 1999:\n\tadded *bp in gettok in lex.c; appears possible to exit function\n\twithout terminating the string.  thanks to russ cox.\n\nJun 2, 1999:\n\tadded function stdinit() to run to initialize files[] array,\n\tin case stdin, etc., are not constants; some compilers care.\n\nMay 10, 1999:\n\treplaced the ERROR ... FATAL, etc., macros with functions\n\tbased on vprintf, to avoid problems caused by overrunning\n\tfixed-size errbuf array.  thanks to ralph corderoy for the\n\timpetus, and for pointing out a string termination bug in\n\tqstring as well.\n\nApr 21, 1999:\n\tfixed bug that caused occasional core dumps with commandline\n\tvariable with value ending in \\.  (thanks to nelson beebe for\n\tthe test case.)\n\nApr 16, 1999:\n\twith code kindly provided by Bruce Lilly, awk now parses\n\t/=/ and similar constructs more sensibly in more places.\n\tBruce also provided some helpful test cases.\n\nApr 5, 1999:\n\tchanged true/false to True/False in run.c to make it\n\teasier to compile with C++.  Added some casts on malloc\n\tand realloc to be honest about casts; ditto.  changed\n\tltype int to long in struct rrow to reduce some 64-bit\n\tcomplaints; other changes scattered throughout for the\n\tsame purpose.  thanks to Nelson Beebe for these portability\n\timprovements.\n\n\tremoved some horrible pointer-int casting in b.c and elsewhere\n\tby adding ptoi and itonp to localize the casts, which are\n\tall benign.  fixed one incipient bug that showed up on sgi\n\tin 64-bit mode.\n\n\treset lineno for new source file; include filename in error\n\tmessage.  also fixed line number error in continuation lines.\n\t(thanks to Nelson Beebe for both of these.)\n\nMar 24, 1999:\n\tNelson Beebe notes that irix 5.3 yacc dies with a bogus\n\terror; use a newer version or switch to bison, since sgi\n\tis unlikely to fix it.\n\nMar 5, 1999:\n\tchanged isnumber to is_number to avoid the problem caused by\n\tversions of ctype.h that include the name isnumber.\n\n\tdistribution now includes a script for building on a Mac,\n\tthanks to Dan Allen.\n\nFeb 20, 1999:\n\tfixed memory leaks in run.c (call) and tran.c (setfval).\n\tthanks to Stephen Nutt for finding these and providing the fixes.\n\nJan 13, 1999:\n\treplaced srand argument by (unsigned int) in run.c;\n\tavoids problem on Mac and potentially on Unix & Windows.\n\tthanks to Dan Allen.\n\n\tadded a few (int) casts to silence useless compiler warnings.\n\te.g., errorflag= in run.c jump().\n\n\tadded proctab.c to the bundle output; one less thing\n\tto have to compile out of the box.\n\n\tadded calls to _popen and _pclose to the win95 stub for\n\tpipes (thanks to Steve Adams for this helpful suggestion).\n\tseems to work, though properties are not well understood\n\tby me, and it appears that under some circumstances the\n\tpipe output is truncated.  Be careful.\n\nOct 19, 1998:\n\tfixed a couple of bugs in getrec: could fail to update $0\n\tafter a getline var; because inputFS wasn't initialized,\n\tcould split $0 on every character, a misleading diversion.\n\n\tfixed caching bug in makedfa: LRU was actually removing\n\tleast often used.\n\n\tthanks to ross ridge for finding these, and for providing\n\tgreat bug reports.\n\nMay 12, 1998:\n\tfixed potential bug in readrec: might fail to update record\n\tpointer after growing.  thanks to dan levy for spotting this\n\tand suggesting the fix.\n\nMar 12, 1998:\n\tadded -V to print version number and die.\n\n[notify dave kerns, dkerns@dacsoup.ih.lucent.com]\n\nFeb 11, 1998:\n\tsubtle silent bug in lex.c: if the program ended with a number\n\tlonger than 1 digit, part of the input would be pushed back and\n\tparsed again because token buffer wasn't terminated right.\n\texample:  awk 'length($0) > 10'.  blush.  at least i found it\n\tmyself.\n\nAug 31, 1997:\n\ts/adelete/awkdelete/: SGI uses this in malloc.h.\n\tthanks to nelson beebe for pointing this one out.\n\nAug 21, 1997:\n\tfixed some bugs in sub and gsub when replacement includes \\\\.\n\tthis is a dark, horrible corner, but at least now i believe that\n\tthe behavior is the same as gawk and the intended posix standard.\n\tthanks to arnold robbins for advice here.\n\nAug 9, 1997:\n\tsomewhat regretfully, replaced the ancient lex-based lexical\n\tanalyzer with one written in C.  it's longer, generates less code,\n\tand more portable; the old one depended too much on mysterious\n\tproperties of lex that were not preserved in other environments.\n\tin theory these recognize the same language.\n\n\tnow using strtod to test whether a string is a number, instead of\n\tthe convoluted original function.  should be more portable and\n\treliable if strtod is implemented right.\n\n\tremoved now-pointless optimization in makefile that tries to avoid\n\trecompilation when awkgram.y is changed but symbols are not.\n\n\tremoved most fixed-size arrays, though a handful remain, some\n\tof which are unchecked.  you have been warned.\n\nAug 4, 1997:\n\twith some trepidation, replaced the ancient code that managed\n\tfields and $0 in fixed-size arrays with arrays that grow on\n\tdemand.  there is still some tension between trying to make this\n\trun fast and making it clean; not sure it's right yet.\n\n\tthe ill-conceived -mr and -mf arguments are now useful only\n\tfor debugging.  previous dynamic string code removed.\n\n\tnumerous other minor cleanups along the way.\n\nJul 30, 1997:\n\tusing code provided by dan levy (to whom profuse thanks), replaced\n\tfixed-size arrays and awkward kludges by a fairly uniform mechanism\n\tto grow arrays as needed for printf, sub, gsub, etc.\n\nJul 23, 1997:\n\tfalling off the end of a function returns \"\" and 0, not 0.\n\tthanks to arnold robbins.\n\nJun 17, 1997:\n\treplaced several fixed-size arrays by dynamically-created ones\n\tin run.c; added overflow tests to some previously unchecked cases.\n\tgetline, toupper, tolower.\n\n\tgetline code is still broken in that recursive calls may wind\n\tup using the same space.  [fixed later]\n\n\tincreased RECSIZE to 8192 to push problems further over the horizon.\n\n\tadded \\r to \\n as input line separator for programs, not data.\n\tdamn CRLFs.\n\n\tmodified format() to permit explicit printf(\"%c\", 0) to include\n\ta null byte in output.  thanks to ken stailey for the fix.\n\n\tadded a \"-safe\" argument that disables file output (print >,\n\tprint >>), process creation (cmd|getline, print |, system), and\n\taccess to the environment (ENVIRON).  this is a first approximation\n\tto a \"safe\" version of awk, but don't rely on it too much.  thanks\n\tto joan feigenbaum and matt blaze for the inspiration long ago.\n\nJul 8, 1996:\n\tfixed long-standing bug in sub, gsub(/a/, \"\\\\\\\\&\"); thanks to\n\tralph corderoy.\n\nJun 29, 1996:\n\tfixed awful bug in new field splitting; didn't get all the places\n\twhere input was done.\n\nJun 28, 1996:\n\tchanged field-splitting to conform to posix definition: fields are\n\tsplit using the value of FS at the time of input; it used to be\n\tthe value when the field or NF was first referred to, a much less\n\tpredictable definition.  thanks to arnold robbins for encouragement\n\tto do the right thing.\n\nMay 28, 1996:\n\tfixed appalling but apparently unimportant bug in parsing octal\n\tnumbers in reg exprs.\n\n\texplicit hex in reg exprs now limited to 2 chars: \\xa, \\xaa.\n\nMay 27, 1996:\n\tcleaned up some declarations so gcc -Wall is now almost silent.\n\n\tmakefile now includes backup copies of ytab.c and lexyy.c in case\n\tone makes before looking; it also avoids recreating lexyy.c unless\n\treally needed.\n\n\ts/aprintf/awkprint, s/asprintf/awksprintf/ to avoid some name clashes\n\twith unwisely-written header files.\n\n\tthanks to jeffrey friedl for several of these.\n\nMay 26, 1996:\n\tan attempt to rationalize the (unsigned) char issue.  almost all\n\tinstances of unsigned char have been removed; the handful of places\n\tin b.c where chars are used as table indices have been hand-crafted.\n\tadded some latin-1 tests to the regression, but i'm not confident;\n\tnone of my compilers seem to care much.  thanks to nelson beebe for\n\tpointing out some others that do care.\n\nMay 2, 1996:\n\tremoved all register declarations.\n\n\tenhanced split(), as in gawk, etc:  split(s, a, \"\") splits s into\n\ta[1]...a[length(s)] with each character a single element.\n\n\tmade the same changes for field-splitting if FS is \"\".\n\n\tadded nextfile, as in gawk: causes immediate advance to next\n\tinput file. (thanks to arnold robbins for inspiration and code).\n\n\tsmall fixes to regexpr code:  can now handle []], [[], and\n\tvariants;  [] is now a syntax error, rather than matching\n\teverything;  [z-a] is now empty, not z.  far from complete\n\tor correct, however.  (thanks to jeffrey friedl for pointing out\n\tsome awful behaviors.)\n\nApr 29, 1996:\n\treplaced uchar by uschar everywhere; apparently some compilers\n\tusurp this name and this causes conflicts.\n\n\tfixed call to time in run.c (bltin); arg is time_t *.\n\n\treplaced horrible pointer/long punning in b.c by a legitimate\n\tunion.  should be safer on 64-bit machines and cleaner everywhere.\n\t(thanks to nelson beebe for pointing out some of these problems.)\n\n\treplaced nested comments by #if 0...#endif in run.c, lib.c.\n\n\tremoved getsval, setsval, execute macros from run.c and lib.c.\n\tmachines are 100x faster than they were when these macros were\n\tfirst used.\n\n\trevised filenames: awk.g.y => awkgram.y, awk.lx.l => awklex.l,\n\ty.tab.[ch] => ytab.[ch], lex.yy.c => lexyy.c, all in the aid of\n\tportability to nameless systems.\n\n\t\"make bundle\" now includes yacc and lex output files for recipients\n\twho don't have yacc or lex.\n\nAug 15, 1995:\n\tinitialized Cells in setsymtab more carefully; some fields\n\twere not set.  (thanks to purify, all of whose complaints i\n\tthink i now understand.)\n\n\tfixed at least one error in gsub that looked at -1-th element\n\tof an array when substituting for a null match (e.g., $).\n\n\tdelete arrayname is now legal; it clears the elements but leaves\n\tthe array, which may not be the right behavior.\n\n\tmodified makefile: my current make can't cope with the test used\n\tto avoid unnecessary yacc invocations.\n\nJul 17, 1995:\n\tadded dynamically growing strings to awk.lx.l and b.c\n\tto permit regular expressions to be much bigger.\n\tthe state arrays can still overflow.\n\nAug 24, 1994:\n\tdetect duplicate arguments in function definitions (mdm).\n\nMay 11, 1994:\n\ttrivial fix to printf to limit string size in sub().\n\nApr 22, 1994:\n\tfixed yet another subtle self-assignment problem:\n\t$1 = $2; $1 = $1 clobbered $1.\n\n\tRegression tests now use private echo, to avoid quoting problems.\n\nFeb 2, 1994:\n\tchanged error() to print line number as %d, not %g.\n\nJul 23, 1993:\n\tcosmetic changes: increased sizes of some arrays,\n\treworded some error messages.\n\n\tadded CONVFMT as in posix (just replaced OFMT in getsval)\n\n\tFILENAME is now \"\" until the first thing that causes a file\n\tto be opened.\n\nNov 28, 1992:\n\tdeleted yyunput and yyoutput from proto.h;\n\tdifferent versions of lex give these different declarations.\n\nMay 31, 1992:\n\tadded -mr N and -mf N options: more record and fields.\n\tthese really ought to adjust automatically.\n\n\tcleaned up some error messages; \"out of space\" now means\n\tmalloc returned NULL in all cases.\n\n\tchanged rehash so that if it runs out, it just returns;\n\tthings will continue to run slow, but maybe a bit longer.\n\nApr 24, 1992:\n\tremove redundant close of stdin when using -f -.\n\n\tgot rid of core dump with -d; awk -d just prints date.\n\nApr 12, 1992:\n\tadded explicit check for /dev/std(in,out,err) in redirection.\n\tunlike gawk, no /dev/fd/n yet.\n\n\tadded (file/pipe) builtin.  hard to test satisfactorily.\n\tnot posix.\n\nFeb 20, 1992:\n\trecompile after abortive changes;  should be unchanged.\n\nDec 2, 1991:\n\tdie-casting time:  converted to ansi C, installed that.\n\nNov 30, 1991:\n\tfixed storage leak in freefa, failing to recover [N]CCL.\n\tthanks to Bill Jones (jones@cs.usask.ca)\n\nNov 19, 1991:\n\tuse RAND_MAX instead of literal in builtin().\n\nNov 12, 1991:\n\tcranked up some fixed-size arrays in b.c, and added a test for\n\toverflow in penter.  thanks to mark larsen.\n\nSep 24, 1991:\n\tincreased buffer in gsub.  a very crude fix to a general problem.\n\tand again on Sep 26.\n\nAug 18, 1991:\n\tenforce variable name syntax for commandline variables: has to\n\tstart with letter or _.\n\nJul 27, 1991:\n\tallow newline after ; in for statements.\n\nJul 21, 1991:\n\tfixed so that in self-assignment like $1=$1, side effects\n\tlike recomputing $0 take place.  (this is getting subtle.)\n\nJun 30, 1991:\n\tbetter test for detecting too-long output record.\n\nJun 2, 1991:\n\tbetter defense against very long printf strings.\n\tmade break and continue illegal outside of loops.\n\nMay 13, 1991:\n\tremoved extra arg on gettemp, tempfree.  minor error message rewording.\n\nMay 6, 1991:\n\tfixed silly bug in hex parsing in hexstr().\n\tremoved an apparently unnecessary test in isnumber().\n\twarn about weird printf conversions.\n\tfixed unchecked array overwrite in relex().\n\n\tchanged for (i in array) to access elements in sorted order.\n\tthen unchanged it -- it really does run slower in too many cases.\n\tleft the code in place, commented out.\n\nFeb 10, 1991:\n\tcheck error status on all writes, to avoid banging on full disks.\n\nJan 28, 1991:\n\tawk -f - reads the program from stdin.\n\nJan 11, 1991:\n\tfailed to set numeric state on $0 in cmd|getline context in run.c.\n\nNov 2, 1990:\n\tfixed sleazy test for integrality in getsval;  use modf.\n\nOct 29, 1990:\n\tfixed sleazy buggy code in lib.c that looked (incorrectly) for\n\ttoo long input lines.\n\nOct 14, 1990:\n\tfixed the bug on p. 198 in which it couldn't deduce that an\n\targument was an array in some contexts.  replaced the error\n\tmessage in intest() by code that damn well makes it an array.\n\nOct 8, 1990:\n\tfixed horrible bug:  types and values were not preserved in\n\tsome kinds of self-assignment. (in assign().)\n\nAug 24, 1990:\n\tchanged NCHARS to 256 to handle 8-bit characters in strings\n\tpresented to match(), etc.\n\nJun 26, 1990:\n\tchanged struct rrow (awk.h) to use long instead of int for lval,\n\tsince cfoll() stores a pointer in it.  now works better when int's\n\tare smaller than pointers!\n\nMay 6, 1990:\n\tAVA fixed the grammar so that ! is uniformly of the same precedence as\n\tunary + and -.  This renders illegal some constructs like !x=y, which\n\tnow has to be parenthesized as !(x=y), and makes others work properly:\n\t!x+y is (!x)+y, and x!y is x !y, not two pattern-action statements.\n\t(These problems were pointed out by Bob Lenk of Posix.)\n\n\tAdded \\x to regular expressions (already in strings).\n\tLimited octal to octal digits; \\8 and \\9 are not octal.\n\tCentralized the code for parsing escapes in regular expressions.\n\tAdded a bunch of tests to T.re and T.sub to verify some of this.\n\nFeb 9, 1990:\n\tfixed null pointer dereference bug in main.c:  -F[nothing].  sigh.\n\n\trestored srand behavior:  it returns the current seed.\n\nJan 18, 1990:\n\tsrand now returns previous seed value (0 to start).\n\nJan 5, 1990:\n\tfix potential problem in tran.c -- something was freed,\n\tthen used in freesymtab.\n\nOct 18, 1989:\n\tanother try to get the max number of open files set with\n\trelatively machine-independent code.\n\n\tsmall fix to input() in case of multiple reads after EOF.\n\nOct 11, 1989:\n\tFILENAME is now defined in the BEGIN block -- too many old\n\tprograms broke.\n\n\t\"-\" means stdin in getline as well as on the commandline.\n\n\tadded a bunch of casts to the code to tell the truth about\n\tchar * vs. unsigned char *, a right royal pain.  added a\n\tsetlocale call to the front of main, though probably no one\n\thas it usefully implemented yet.\n\nAug 24, 1989:\n\tremoved redundant relational tests against nullnode if parse\n\ttree already had a relational at that point.\n\nAug 11, 1989:\n\tfixed bug:  commandline variable assignment has to look like\n\tvar=something.  (consider the man page for =, in file =.1)\n\n\tchanged number of arguments to functions to static arrays\n\tto avoid repeated malloc calls.\n\nAug 2, 1989:\n\trestored -F (space) separator\n\nJul 30, 1989:\n\tadded -v x=1 y=2 ... for immediate commandline variable assignment;\n\tdone before the BEGIN block for sure.  they have to precede the\n\tprogram if the program is on the commandline.\n\tModified Aug 2 to require a separate -v for each assignment.\n\nJul 10, 1989:\n\tfixed ref-thru-zero bug in environment code in tran.c\n\nJun 23, 1989:\n\tadd newline to usage message.\n\nJun 14, 1989:\n\tadded some missing ansi printf conversion letters: %i %X %E %G.\n\tno sensible meaning for h or L, so they may not do what one expects.\n\n\tmade %* conversions work.\n\n\tchanged x^y so that if n is a positive integer, it's done\n\tby explicit multiplication, thus achieving maximum accuracy.\n\t(this should be done by pow() but it seems not to be locally.)\n\tdone to x ^= y as well.\n\nJun 4, 1989:\n\tENVIRON array contains environment: if shell variable V=thing,\n\t\tENVIRON[\"V\"] is \"thing\"\n\n\tmultiple -f arguments permitted.  error reporting is naive.\n\t(they were permitted before, but only the last was used.)\n\n\tfixed a really stupid botch in the debugging macro dprintf\n\n\tfixed order of evaluation of commandline assignments to match\n\twhat the book claims:  an argument of the form x=e is evaluated\n\tat the time it would have been opened if it were a filename (p 63).\n\tthis invalidates the suggested answer to ex 4-1 (p 195).\n\n\tremoved some code that permitted -F (space) fieldseparator,\n\tsince it didn't quite work right anyway.  (restored aug 2)\n\nApr 27, 1989:\n\tLine number now accumulated correctly for comment lines.\n\nApr 26, 1989:\n\tDebugging output now includes a version date,\n\tif one compiles it into the source each time.\n\nApr 9, 1989:\n\tChanged grammar to prohibit constants as 3rd arg of sub and gsub;\n\tprevents class of overwriting-a-constant errors.  (Last one?)\n\tThis invalidates the \"banana\" example on page 43 of the book.\n\n\tAdded \\a (\"alert\"), \\v (vertical tab), \\xhhh (hexadecimal),\n\tas in ANSI, for strings.  Rescinded the sloppiness that permitted\n\tnon-octal digits in \\ooo.  Warning:  not all compilers and libraries\n\twill be able to deal with \\x correctly.\n\nJan 9, 1989:\n\tFixed bug that caused tempcell list to contain a duplicate.\n\tThe fix is kludgy.\n\nDec 17, 1988:\n\tCatches some more commandline errors in main.\n\tRemoved redundant decl of modf in run.c (confuses some compilers).\n\tWarning:  there's no single declaration of malloc, etc., in awk.h\n\tthat seems to satisfy all compilers.\n\nDec 7, 1988:\n\tAdded a bit of code to error printing to avoid printing nulls.\n\t(Not clear that it actually would.)\n\nNov 27, 1988:\n\tWith fear and trembling, modified the grammar to permit\n\tmultiple pattern-action statements on one line without\n\tan explicit separator.  By definition, this capitulation\n\tto the ghost of ancient implementations remains undefined\n\tand thus subject to change without notice or apology.\n\tDO NOT COUNT ON IT.\n\nOct 30, 1988:\n\tFixed bug in call() that failed to recover storage.\n\n\tA warning is now generated if there are more arguments\n\tin the call than in the definition (in lieu of fixing\n\tanother storage leak).\n\nOct 20, 1988:\n\tFixed %c:  if expr is numeric, use numeric value;\n\totherwise print 1st char of string value.  still\n\tdoesn't work if the value is 0 -- won't print \\0.\n\n\tAdded a few more checks for running out of malloc.\n\nOct 12, 1988:\n\tFixed bug in call() that freed local arrays twice.\n\n\tFixed to handle deletion of non-existent array right;\n\tcomplains about attempt to delete non-array element.\n\nSep 30, 1988:\n\tNow guarantees to evaluate all arguments of built-in\n\tfunctions, as in C;  the appearance is that arguments\n\tare evaluated before the function is called.  Places\n\taffected are sub (gsub was ok), substr, printf, and\n\tall the built-in arithmetic functions in bltin().\n\tA warning is generated if a bltin() is called with\n\tthe wrong number of arguments.\n\n\tThis requires changing makeprof on p167 of the book.\n\nAug 23, 1988:\n\tsetting FILENAME in BEGIN caused core dump, apparently\n\tbecause it was freeing space not allocated by malloc.\n\nJuly 24, 1988:\n\tfixed egregious error in toupper/tolower functions.\n\tstill subject to rescinding, however.\n\nJuly 2, 1988:\n\tflush stdout before opening file or pipe\n\nJuly 2, 1988:\n\tperformance bug in b.c/cgoto(): not freeing some sets of states.\n\tpartial fix only right now, and the number of states increased\n\tto make it less obvious.\n\nJune 1, 1988:\n\tcheck error status on close\n\nMay 28, 1988:\n\tsrand returns seed value it's using.\n\tsee 1/18/90\n\nMay 22, 1988:\n\tRemoved limit on depth of function calls.\n\nMay 10, 1988:\n\tFixed lib.c to permit _ in commandline variable names.\n\nMar 25, 1988:\n\tmain.c fixed to recognize -- as terminator of command-\n\tline options.  Illegal options flagged.\n\tError reporting slightly cleaned up.\n\nDec 2, 1987:\n\tNewer C compilers apply a strict scope rule to extern\n\tdeclarations within functions.  Two extern declarations in\n\tlib.c and tran.c have been moved to obviate this problem.\n\nOct xx, 1987:\n\tReluctantly added toupper and tolower functions.\n\tSubject to rescinding without notice.\n\nSep 17, 1987:\n\tError-message printer had printf(s) instead of\n\tprintf(\"%s\",s);  got core dumps when the message\n\tincluded a %.\n\nSep 12, 1987:\n\tVery long printf strings caused core dump;\n\tfixed aprintf, asprintf, format to catch them.\n\tCan still get a core dump in printf itself.\n\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1337890625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.6025390625,
          "content": "# The One True Awk\n\nThis is the version of `awk` described in _The AWK Programming Language_,\nSecond Edition, by Al Aho, Brian Kernighan, and Peter Weinberger\n(Addison-Wesley, 2024, ISBN-13 978-0138269722, ISBN-10 0138269726).\n\n## What's New? ##\n\nThis version of Awk handles UTF-8 and comma-separated values (CSV) input.\n\n### Strings ###\n\nFunctions that process strings now count Unicode code points, not bytes;\nthis affects `length`, `substr`, `index`, `match`, `split`,\n`sub`, `gsub`, and others.  Note that code\npoints are not necessarily characters.\n\nUTF-8 sequences may appear in literal strings and regular expressions.\nArbitrary characters may be included with `\\u` followed by 1 to 8 hexadecimal digits.\n\n### Regular expressions ###\n\nRegular expressions may include UTF-8 code points, including `\\u`.\n\n### CSV ###\n\nThe option `--csv` turns on CSV processing of input:\nfields are separated by commas, fields may be quoted with\ndouble-quote (`\"`) characters, quoted fields may contain embedded newlines.\nDouble-quotes in fields have to be doubled and enclosed in quoted fields.\nIn CSV mode, `FS` is ignored.\n\nIf no explicit separator argument is provided,\nfield-splitting in `split` is determined by CSV mode.\n\n## Copyright\n\nCopyright (C) Lucent Technologies 1997<br/>\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n\n## Distribution and Reporting Problems\n\nChanges, mostly bug fixes and occasional enhancements, are listed\nin `FIXES`.  If you distribute this code further, please please please\ndistribute `FIXES` with it.\n\nIf you find errors, please report them\nto the current maintainer, ozan.yigit@gmail.com.\nPlease _also_ open an issue in the GitHub issue tracker, to make\nit easy to track issues.\nThanks.\n\n## Submitting Pull Requests\n\nPull requests are welcome. Some guidelines:\n\n* Please do not use functions or facilities that are not standard (e.g.,\n`strlcpy()`, `fpurge()`).\n\n* Please run the test suite and make sure that your changes pass before\nposting the pull request. To do so:\n\n  1. Save the previous version of `awk` somewhere in your path. Call it `nawk` (for example).\n  1. Run `oldawk=nawk make check > check.out 2>&1`.\n  1. Search for `BAD` or `error` in the result. In general, look over it manually to make sure there are no errors.\n\n* Please create the pull request with a request\nto merge into the `staging` branch instead of into the `master` branch.\nThis allows us to do testing, and to make any additional edits or changes\nafter the merge but before merging to `master`.\n\n## Building\n\nThe program itself is created by\n\n\tmake\n\nwhich should produce a sequence of messages roughly like this:\n\n\tbison -d  awkgram.y\n\tawkgram.y: warning: 44 shift/reduce conflicts [-Wconflicts-sr]\n\tawkgram.y: warning: 85 reduce/reduce conflicts [-Wconflicts-rr]\n\tawkgram.y: note: rerun with option '-Wcounterexamples' to generate conflict counterexamples\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o awkgram.tab.o awkgram.tab.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o b.o b.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o main.o main.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o parse.o parse.c\n\tgcc -g -Wall -pedantic -Wcast-qual -O2 maketab.c -o maketab\n\t./maketab awkgram.tab.h >proctab.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o proctab.o proctab.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o tran.o tran.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o lib.o lib.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o run.o run.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2   -c -o lex.o lex.c\n\tgcc -g -Wall -pedantic -Wcast-qual   -O2 awkgram.tab.o b.o main.o parse.o proctab.o tran.o lib.o run.o lex.o   -lm\n\nThis produces an executable `a.out`; you will eventually want to\nmove this to some place like `/usr/bin/awk`.\n\nIf your system does not have `yacc` or `bison` (the GNU\nequivalent), you need to install one of them first.\nThe default in the `makefile` is `bison`; you will have\nto edit the `makefile` to use `yacc`.\n\nNOTE: This version uses ISO/IEC C99, as you should also.  We have\ncompiled this without any changes using `gcc -Wall` and/or local C\ncompilers on a variety of systems, but new systems or compilers\nmay raise some new complaint; reports of difficulties are\nwelcome.\n\nThis compiles without change on Macintosh OS X using `gcc` and\nthe standard developer tools.\n\nYou can also use `make CC=g++` to build with the GNU C++ compiler,\nshould you choose to do so.\n\n## A Note About Releases\n\nWe don't usually do releases.\n\n## A Note About Maintenance\n\nNOTICE! Maintenance of this program is on a ''best effort''\nbasis.  We try to get to issues and pull requests as quickly\nas we can.  Unfortunately, however, keeping this program going\nis not at the top of our priority list.\n\n#### Last Updated\n\nMon 05 Feb 2024 08:46:55 IST\n"
        },
        {
          "name": "REGRESS",
          "type": "blob",
          "size": 0.4990234375,
          "content": "#! /bin/sh\n\ncase `uname` in\nCYGWIN)\tEXE=a.exe ;;\n*)\tEXE=a.out ;;\nesac\n\nif [ ! -f $EXE ]\nthen\n\tmake || exit 1\nfi\n\nif [ -d testdir ]\nthen\n\ttrue\t# do nothing\nelif [ -f awktest.tar ]\nthen\n\techo extracting testdir\n\ttar -xpf awktest.tar\nelse\n\techo $0: No testdir directory and no awktest.tar to extract it from! >&2\n\texit 1\nfi\n\ncd testdir\npwd\nPATH=.:$PATH\nexport PATH\nif (ulimit -c unlimited > /dev/null 2>&1)\nthen\n\t# Workaround broken default on MacOS X\n\tulimit -c unlimited\nfi\n\nREGRESS\n\ncd ..\ncd bugs-fixed\nREGRESS\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.7373046875,
          "content": "Wed Jan 22 02:10:35 MST 2020\n============================\n\nHere are some things that it'd be nice to have volunteer\nhelp on.\n\n1. Rework the test suite so that it's easier to maintain\nand see exactly which tests fail:\n\tA. Extract beebe.tar into separate file and update scripts\n\tB. Split apart multiple tests into separate tests with input\n\t   and \"ok\" files for comparisons.\n\n2. Pull in more of the tests from gawk that only test standard features.\n   The beebe.tar file appears to be from sometime in the 1990s.\n\n3. Make the One True Awk valgrind clean. In particular add a\n   test suite target that runs valgrind on all the tests and\n   reports if there are any definite losses or any invalid reads\n   or writes (similar to gawk's test of this nature).\n"
        },
        {
          "name": "awk.1",
          "type": "blob",
          "size": 12.755859375,
          "content": ".de EX\n.nf\n.ft CW\n..\n.de EE\n.br\n.fi\n.ft 1\n..\n.de TF\n.IP \"\" \"\\w'\\fB\\\\$1\\ \\ \\fP'u\"\n.PD 0\n..\n.TH AWK 1\n.CT 1 files prog_other\n.SH NAME\nawk \\- pattern-directed scanning and processing language\n.SH SYNOPSIS\n.B awk\n[\n.BI \\-F\n.I fs\n|\n.B \\-\\^\\-csv\n]\n[\n.BI \\-v\n.I var=value\n]\n[\n.I 'prog'\n|\n.BI \\-f\n.I progfile\n]\n[\n.I file ...\n]\n.SH DESCRIPTION\n.I Awk\nscans each input\n.I file\nfor lines that match any of a set of patterns specified literally in\n.I prog\nor in one or more files\nspecified as\n.B \\-f\n.IR progfile .\nWith each pattern\nthere can be an associated action that will be performed\nwhen a line of a\n.I file\nmatches the pattern.\nEach line is matched against the\npattern portion of every pattern-action statement;\nthe associated action is performed for each matched pattern.\nThe file name\n.B \\-\nmeans the standard input.\nAny\n.I file\nof the form\n.I var=value\nis treated as an assignment, not a filename,\nand is executed at the time it would have been opened if it were a filename.\nThe option\n.B \\-v\nfollowed by\n.I var=value\nis an assignment to be done before\n.I prog\nis executed;\nany number of\n.B \\-v\noptions may be present.\nThe\n.B \\-F\n.I fs\noption defines the input field separator to be the regular expression\n.IR fs .\nThe\n.B \\-\\^\\-csv\noption causes\n.I awk\nto process records using (more or less) standard comma-separated values\n(CSV) format.\n.PP\nAn input line is normally made up of fields separated by white space,\nor by the regular expression\n.BR FS .\nThe fields are denoted\n.BR $1 ,\n.BR $2 ,\n\\&..., while\n.B $0\nrefers to the entire line.\nIf\n.BR FS\nis null, the input line is split into one field per character.\n.PP\nA pattern-action statement has the form:\n.IP\n.IB pattern \" { \" action \" }\n.PP\nA missing\n.BI { \" action \" }\nmeans print the line;\na missing pattern always matches.\nPattern-action statements are separated by newlines or semicolons.\n.PP\nAn action is a sequence of statements.\nA statement can be one of the following:\n.PP\n.EX\n.ta \\w'\\f(CWdelete array[expression]\\fR'u\n.RS\n.nf\n.ft CW\nif(\\fI expression \\fP)\\fI statement \\fP\\fR[ \\fPelse\\fI statement \\fP\\fR]\\fP\nwhile(\\fI expression \\fP)\\fI statement\\fP\nfor(\\fI expression \\fP;\\fI expression \\fP;\\fI expression \\fP)\\fI statement\\fP\nfor(\\fI var \\fPin\\fI array \\fP)\\fI statement\\fP\ndo\\fI statement \\fPwhile(\\fI expression \\fP)\nbreak\ncontinue\n{\\fR [\\fP\\fI statement ... \\fP\\fR] \\fP}\n\\fIexpression\\fP\t#\\fR commonly\\fP\\fI var = expression\\fP\nprint\\fR [ \\fP\\fIexpression-list \\fP\\fR] \\fP\\fR[ \\fP>\\fI expression \\fP\\fR]\\fP\nprintf\\fI format \\fP\\fR[ \\fP,\\fI expression-list \\fP\\fR] \\fP\\fR[ \\fP>\\fI expression \\fP\\fR]\\fP\nreturn\\fR [ \\fP\\fIexpression \\fP\\fR]\\fP\nnext\t#\\fR skip remaining patterns on this input line\\fP\nnextfile\t#\\fR skip rest of this file, open next, start at top\\fP\ndelete\\fI array\\fP[\\fI expression \\fP]\t#\\fR delete an array element\\fP\ndelete\\fI array\\fP\t#\\fR delete all elements of array\\fP\nexit\\fR [ \\fP\\fIexpression \\fP\\fR]\\fP\t#\\fR exit immediately; status is \\fP\\fIexpression\\fP\n.fi\n.RE\n.EE\n.DT\n.PP\nStatements are terminated by\nsemicolons, newlines or right braces.\nAn empty\n.I expression-list\nstands for\n.BR $0 .\nString constants are quoted \\&\\f(CW\"\\ \"\\fR,\nwith the usual C escapes recognized within.\nExpressions take on string or numeric values as appropriate,\nand are built using the operators\n.B + \\- * / % ^\n(exponentiation), and concatenation (indicated by white space).\nThe operators\n.B\n! ++ \\-\\- += \\-= *= /= %= ^= > >= < <= == != ?:\nare also available in expressions.\nVariables may be scalars, array elements\n(denoted\n.IB x  [ i ] \\fR)\nor fields.\nVariables are initialized to the null string.\nArray subscripts may be any string,\nnot necessarily numeric;\nthis allows for a form of associative memory.\nMultiple subscripts such as\n.B [i,j,k]\nare permitted; the constituents are concatenated,\nseparated by the value of\n.BR SUBSEP .\n.PP\nThe\n.B print\nstatement prints its arguments on the standard output\n(or on a file if\n.BI > \" file\nor\n.BI >> \" file\nis present or on a pipe if\n.BI | \" cmd\nis present), separated by the current output field separator,\nand terminated by the output record separator.\n.I file\nand\n.I cmd\nmay be literal names or parenthesized expressions;\nidentical string values in different statements denote\nthe same open file.\nThe\n.B printf\nstatement formats its expression list according to the\n.I format\n(see\n.IR printf (3)).\nThe built-in function\n.BI close( expr )\ncloses the file or pipe\n.IR expr .\nThe built-in function\n.BI fflush( expr )\nflushes any buffered output for the file or pipe\n.IR expr .\n.PP\nThe mathematical functions\n.BR atan2 ,\n.BR cos ,\n.BR exp ,\n.BR log ,\n.BR sin ,\nand\n.B sqrt\nare built in.\nOther built-in functions:\n.TF \"\\fBlength(\\fR[\\fIv\\^\\fR]\\fB)\\fR\"\n.TP\n\\fBlength(\\fR[\\fIv\\^\\fR]\\fB)\\fR\nthe length of its argument\ntaken as a string,\nnumber of elements in an array for an array argument,\nor length of\n.B $0\nif no argument.\n.TP\n.B rand()\nrandom number on [0,1).\n.TP\n\\fBsrand(\\fR[\\fIs\\^\\fR]\\fB)\\fR\nsets seed for\n.B rand\nand returns the previous seed.\n.TP\n.BI int( x\\^ )\ntruncates to an integer value.\n.TP\n\\fBsubstr(\\fIs\\fB, \\fIm\\fR [\\fB, \\fIn\\^\\fR]\\fB)\\fR\nthe\n.IR n -character\nsubstring of\n.I s\nthat begins at position\n.I m\ncounted from 1.\nIf no\n.IR n ,\nuse the rest of the string.\n.TP\n.BI index( s , \" t\" )\nthe position in\n.I s\nwhere the string\n.I t\noccurs, or 0 if it does not.\n.TP\n.BI match( s , \" r\" )\nthe position in\n.I s\nwhere the regular expression\n.I r\noccurs, or 0 if it does not.\nThe variables\n.B RSTART\nand\n.B RLENGTH\nare set to the position and length of the matched string.\n.TP\n\\fBsplit(\\fIs\\fB, \\fIa \\fR[\\fB, \\fIfs\\^\\fR]\\fB)\\fR\nsplits the string\n.I s\ninto array elements\n.IB a [1] \\fR,\n.IB a [2] \\fR,\n\\&...,\n.IB a [ n ] \\fR,\nand returns\n.IR n .\nThe separation is done with the regular expression\n.I fs\nor with the field separator\n.B FS\nif\n.I fs\nis not given.\nAn empty string as field separator splits the string\ninto one array element per character.\n.TP\n\\fBsub(\\fIr\\fB, \\fIt \\fR[, \\fIs\\^\\fR]\\fB)\nsubstitutes\n.I t\nfor the first occurrence of the regular expression\n.I r\nin the string\n.IR s .\nIf\n.I s\nis not given,\n.B $0\nis used.\n.TP\n\\fBgsub(\\fIr\\fB, \\fIt \\fR[, \\fIs\\^\\fR]\\fB)\nsame as\n.B sub\nexcept that all occurrences of the regular expression\nare replaced;\n.B sub\nand\n.B gsub\nreturn the number of replacements.\n.TP\n.BI sprintf( fmt , \" expr\" , \" ...\\fB)\nthe string resulting from formatting\n.I expr ...\naccording to the\n.IR printf (3)\nformat\n.IR fmt .\n.TP\n.BI system( cmd )\nexecutes\n.I cmd\nand returns its exit status. This will be \\-1 upon error,\n.IR cmd 's\nexit status upon a normal exit,\n256 +\n.I sig\nupon death-by-signal, where\n.I sig\nis the number of the murdering signal,\nor 512 +\n.I sig\nif there was a core dump.\n.TP\n.BI tolower( str )\nreturns a copy of\n.I str\nwith all upper-case characters translated to their\ncorresponding lower-case equivalents.\n.TP\n.BI toupper( str )\nreturns a copy of\n.I str\nwith all lower-case characters translated to their\ncorresponding upper-case equivalents.\n.PD\n.PP\nThe ``function''\n.B getline\nsets\n.B $0\nto the next input record from the current input file;\n.B getline\n.BI < \" file\nsets\n.B $0\nto the next record from\n.IR file .\n.B getline\n.I x\nsets variable\n.I x\ninstead.\nFinally,\n.IB cmd \" | getline\npipes the output of\n.I cmd\ninto\n.BR getline ;\neach call of\n.B getline\nreturns the next line of output from\n.IR cmd .\nIn all cases,\n.B getline\nreturns 1 for a successful input,\n0 for end of file, and \\-1 for an error.\n.PP\nPatterns are arbitrary Boolean combinations\n(with\n.BR \"! || &&\" )\nof regular expressions and\nrelational expressions.\nRegular expressions are as in\n.IR egrep ;\nsee\n.IR grep (1).\nIsolated regular expressions\nin a pattern apply to the entire line.\nRegular expressions may also occur in\nrelational expressions, using the operators\n.B ~\nand\n.BR !~ .\n.BI / re /\nis a constant regular expression;\nany string (constant or variable) may be used\nas a regular expression, except in the position of an isolated regular expression\nin a pattern.\n.PP\nA pattern may consist of two patterns separated by a comma;\nin this case, the action is performed for all lines\nfrom an occurrence of the first pattern\nthrough an occurrence of the second, inclusive.\n.PP\nA relational expression is one of the following:\n.IP\n.I expression matchop regular-expression\n.br\n.I expression relop expression\n.br\n.IB expression \" in \" array-name\n.br\n.BI ( expr ,\\| expr ,\\| ... \") in \" array-name\n.PP\nwhere a\n.I relop\nis any of the six relational operators in C,\nand a\n.I matchop\nis either\n.B ~\n(matches)\nor\n.B !~\n(does not match).\nA conditional is an arithmetic expression,\na relational expression,\nor a Boolean combination\nof these.\n.PP\nThe special patterns\n.B BEGIN\nand\n.B END\nmay be used to capture control before the first input line is read\nand after the last.\n.B BEGIN\nand\n.B END\ndo not combine with other patterns.\nThey may appear multiple times in a program and execute\nin the order they are read by\n.IR awk .\n.PP\nVariable names with special meanings:\n.TF FILENAME\n.TP\n.B ARGC\nargument count, assignable.\n.TP\n.B ARGV\nargument array, assignable;\nnon-null members are taken as filenames.\n.TP\n.B CONVFMT\nconversion format used when converting numbers\n(default\n.BR \"%.6g\" ).\n.TP\n.B ENVIRON\narray of environment variables; subscripts are names.\n.TP\n.B FILENAME\nthe name of the current input file.\n.TP\n.B FNR\nordinal number of the current record in the current file.\n.TP\n.B FS\nregular expression used to separate fields; also settable\nby option\n.BI \\-F fs\\fR.\n.TP\n.BR NF\nnumber of fields in the current record.\n.TP\n.B NR\nordinal number of the current record.\n.TP\n.B OFMT\noutput format for numbers (default\n.BR \"%.6g\" ).\n.TP\n.B OFS\noutput field separator (default space).\n.TP\n.B ORS\noutput record separator (default newline).\n.TP\n.B RLENGTH\nthe length of a string matched by\n.BR match .\n.TP\n.B RS\ninput record separator (default newline).\nIf empty, blank lines separate records.\nIf more than one character long,\n.B RS\nis treated as a regular expression, and records are\nseparated by text matching the expression.\n.TP\n.B RSTART\nthe start position of a string matched by\n.BR match .\n.TP\n.B SUBSEP\nseparates multiple subscripts (default 034).\n.PD\n.PP\nFunctions may be defined (at the position of a pattern-action statement) thus:\n.IP\n.B\nfunction foo(a, b, c) { ... }\n.PP\nParameters are passed by value if scalar and by reference if array name;\nfunctions may be called recursively.\nParameters are local to the function; all other variables are global.\nThus local variables may be created by providing excess parameters in\nthe function definition.\n.SH ENVIRONMENT VARIABLES\nIf\n.B POSIXLY_CORRECT\nis set in the environment, then\n.I awk\nfollows the POSIX rules for\n.B sub\nand\n.B gsub\nwith respect to consecutive backslashes and ampersands.\n.SH EXAMPLES\n.TP\n.EX\nlength($0) > 72\n.EE\nPrint lines longer than 72 characters.\n.TP\n.EX\n{ print $2, $1 }\n.EE\nPrint first two fields in opposite order.\n.PP\n.EX\nBEGIN { FS = \",[ \\et]*|[ \\et]+\" }\n      { print $2, $1 }\n.EE\n.ns\n.IP\nSame, with input fields separated by comma and/or spaces and tabs.\n.PP\n.EX\n.nf\n\t{ s += $1 }\nEND\t{ print \"sum is\", s, \" average is\", s/NR }\n.fi\n.EE\n.ns\n.IP\nAdd up first column, print sum and average.\n.TP\n.EX\n/start/, /stop/\n.EE\nPrint all lines between start/stop pairs.\n.PP\n.EX\n.nf\nBEGIN\t{\t# Simulate echo(1)\n\tfor (i = 1; i < ARGC; i++) printf \"%s \", ARGV[i]\n\tprintf \"\\en\"\n\texit }\n.fi\n.EE\n.SH SEE ALSO\n.IR grep (1),\n.IR lex (1),\n.IR sed (1)\n.br\nA. V. Aho, B. W. Kernighan, P. J. Weinberger,\n.IR \"The AWK Programming Language, Second Edition\" ,\nAddison-Wesley, 2024.  ISBN 978-0-13-826972-2, 0-13-826972-6.\n.SH BUGS\nThere are no explicit conversions between numbers and strings.\nTo force an expression to be treated as a number add 0 to it;\nto force it to be treated as a string concatenate\n\\&\\f(CW\"\"\\fP to it.\n.PP\nThe scope rules for variables in functions are a botch;\nthe syntax is worse.\n.PP\nInput is expected to be UTF-8 encoded. Other multibyte\ncharacter sets are not handled.\nHowever, in eight-bit locales,\n.I awk\ntreats each input byte as a separate character.\n.SH UNUSUAL FLOATING-POINT VALUES\n.I Awk\nwas designed before IEEE 754 arithmetic defined Not-A-Number (NaN)\nand Infinity values, which are supported by all modern floating-point\nhardware.\n.PP\nBecause\n.I awk\nuses\n.IR strtod (3)\nand\n.IR atof (3)\nto convert string values to double-precision floating-point values,\nmodern C libraries also convert strings starting with\n.B inf\nand\n.B nan\ninto infinity and NaN values respectively.  This led to strange results,\nwith something like this:\n.PP\n.EX\n.nf\necho nancy | awk '{ print $1 + 0 }'\n.fi\n.EE\n.PP\nprinting\n.B nan\ninstead of zero.\n.PP\n.I Awk\nnow follows GNU AWK, and prefilters string values before attempting\nto convert them to numbers, as follows:\n.TP\n.I \"Hexadecimal values\"\nHexadecimal values (allowed since C99) convert to zero, as they did\nprior to C99.\n.TP\n.I \"NaN values\"\nThe two strings\n.B +nan\nand\n.B \\-nan\n(case independent) convert to NaN. No others do.\n(NaNs can have signs.)\n.TP\n.I \"Infinity values\"\nThe two strings\n.B +inf\nand\n.B \\-inf\n(case independent) convert to positive and negative infinity, respectively.\nNo others do.\n"
        },
        {
          "name": "awk.h",
          "type": "blob",
          "size": 7.3701171875,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdbool.h>\n#if __STDC_VERSION__ <= 199901L\n#define noreturn\n#else\n#include <stdnoreturn.h>\n#endif\n\ntypedef double\tAwkfloat;\n\n/* unsigned char is more trouble than it's worth */\n\ntypedef\tunsigned char uschar;\n\n#define\txfree(a)\t{ free((void *)(intptr_t)(a)); (a) = NULL; }\n/*\n * We sometimes cheat writing read-only pointers to NUL-terminate them\n * and then put back the original value\n */\n#define setptr(ptr, a)\t(*(char *)(intptr_t)(ptr)) = (a)\n\n#define\tNN(p)\t((p) ? (p) : \"(null)\")\t/* guaranteed non-null for DPRINTF\n*/\n#define\tDEBUG\n#ifdef\tDEBUG\n#\tdefine\tDPRINTF(...)\tif (dbg) printf(__VA_ARGS__)\n#else\n#\tdefine\tDPRINTF(...)\n#endif\n\nextern enum compile_states {\n\tRUNNING,\n\tCOMPILING,\n\tERROR_PRINTING\n} compile_time;\n\nextern bool\tsafe;\t\t/* false => unsafe, true => safe */\n\n#define\tRECSIZE\t(8 * 1024)\t/* sets limit on records, fields, etc., etc. */\nextern int\trecsize;\t/* size of current record, orig RECSIZE */\n\nextern size_t\tawk_mb_cur_max;\t/* max size of a multi-byte character */\n\nextern char\tEMPTY[];\t/* this avoid -Wwritable-strings issues */\nextern char\t**FS;\nextern char\t**RS;\nextern char\t**ORS;\nextern char\t**OFS;\nextern char\t**OFMT;\nextern Awkfloat *NR;\nextern Awkfloat *FNR;\nextern Awkfloat *NF;\nextern char\t**FILENAME;\nextern char\t**SUBSEP;\nextern Awkfloat *RSTART;\nextern Awkfloat *RLENGTH;\n\nextern bool\tCSV;\t\t/* true for csv input */\n\nextern char\t*record;\t/* points to $0 */\nextern int\tlineno;\t\t/* line number in awk program */\nextern int\terrorflag;\t/* 1 if error has occurred */\nextern bool\tdonefld;\t/* true if record broken into fields */\nextern bool\tdonerec;\t/* true if record is valid (no fld has changed */\nextern int\tdbg;\n\nextern const char *patbeg;\t/* beginning of pattern matched */\nextern\tint\tpatlen;\t\t/* length of pattern matched.  set in b.c */\n\n/* Cell:  all information about a variable or constant */\n\ntypedef struct Cell {\n\tuschar\tctype;\t\t/* OCELL, OBOOL, OJUMP, etc. */\n\tuschar\tcsub;\t\t/* CCON, CTEMP, CFLD, etc. */\n\tchar\t*nval;\t\t/* name, for variables only */\n\tchar\t*sval;\t\t/* string value */\n\tAwkfloat fval;\t\t/* value as number */\n\tint\t tval;\t\t/* type info: STR|NUM|ARR|FCN|FLD|CON|DONTFREE|CONVC|CONVO */\n\tchar\t*fmt;\t\t/* CONVFMT/OFMT value used to convert from number */\n\tstruct Cell *cnext;\t/* ptr to next if chained */\n} Cell;\n\ntypedef struct Array {\t\t/* symbol table array */\n\tint\tnelem;\t\t/* elements in table right now */\n\tint\tsize;\t\t/* size of tab */\n\tCell\t**tab;\t\t/* hash table pointers */\n} Array;\n\n#define\tNSYMTAB\t50\t/* initial size of a symbol table */\nextern Array\t*symtab;\n\nextern Cell\t*nrloc;\t\t/* NR */\nextern Cell\t*fnrloc;\t/* FNR */\nextern Cell\t*fsloc;\t\t/* FS */\nextern Cell\t*nfloc;\t\t/* NF */\nextern Cell\t*ofsloc;\t/* OFS */\nextern Cell\t*orsloc;\t/* ORS */\nextern Cell\t*rsloc;\t\t/* RS */\nextern Cell\t*rstartloc;\t/* RSTART */\nextern Cell\t*rlengthloc;\t/* RLENGTH */\nextern Cell\t*subseploc;\t/* SUBSEP */\nextern Cell\t*symtabloc;\t/* SYMTAB */\n\n/* Cell.tval values: */\n#define\tNUM\t01\t/* number value is valid */\n#define\tSTR\t02\t/* string value is valid */\n#define DONTFREE 04\t/* string space is not freeable */\n#define\tCON\t010\t/* this is a constant */\n#define\tARR\t020\t/* this is an array */\n#define\tFCN\t040\t/* this is a function name */\n#define FLD\t0100\t/* this is a field $1, $2, ... */\n#define\tREC\t0200\t/* this is $0 */\n#define CONVC\t0400\t/* string was converted from number via CONVFMT */\n#define CONVO\t01000\t/* string was converted from number via OFMT */\n\n\n/* function types */\n#define\tFLENGTH\t1\n#define\tFSQRT\t2\n#define\tFEXP\t3\n#define\tFLOG\t4\n#define\tFINT\t5\n#define\tFSYSTEM\t6\n#define\tFRAND\t7\n#define\tFSRAND\t8\n#define\tFSIN\t9\n#define\tFCOS\t10\n#define\tFATAN\t11\n#define\tFTOUPPER 12\n#define\tFTOLOWER 13\n#define\tFFLUSH\t14\n\n/* Node:  parse tree is made of nodes, with Cell's at bottom */\n\ntypedef struct Node {\n\tint\tntype;\n\tstruct\tNode *nnext;\n\tint\tlineno;\n\tint\tnobj;\n\tstruct\tNode *narg[1];\t/* variable: actual size set by calling malloc */\n} Node;\n\n#define\tNIL\t((Node *) 0)\n\nextern Node\t*winner;\nextern Node\t*nullnode;\n\n/* ctypes */\n#define OCELL\t1\n#define OBOOL\t2\n#define OJUMP\t3\n\n/* Cell subtypes: csub */\n#define\tCFREE\t7\n#define CCOPY\t6\n#define CCON\t5\n#define CTEMP\t4\n#define CNAME\t3\n#define CVAR\t2\n#define CFLD\t1\n#define\tCUNK\t0\n\n/* bool subtypes */\n#define BTRUE\t11\n#define BFALSE\t12\n\n/* jump subtypes */\n#define JEXIT\t21\n#define JNEXT\t22\n#define\tJBREAK\t23\n#define\tJCONT\t24\n#define\tJRET\t25\n#define\tJNEXTFILE\t26\n\n/* node types */\n#define NVALUE\t1\n#define NSTAT\t2\n#define NEXPR\t3\n\n\nextern\tint\tpairstack[], paircnt;\n\n#define notlegal(n)\t(n <= FIRSTTOKEN || n >= LASTTOKEN || proctab[n-FIRSTTOKEN] == nullproc)\n#define isvalue(n)\t((n)->ntype == NVALUE)\n#define isexpr(n)\t((n)->ntype == NEXPR)\n#define isjump(n)\t((n)->ctype == OJUMP)\n#define isexit(n)\t((n)->csub == JEXIT)\n#define\tisbreak(n)\t((n)->csub == JBREAK)\n#define\tiscont(n)\t((n)->csub == JCONT)\n#define\tisnext(n)\t((n)->csub == JNEXT || (n)->csub == JNEXTFILE)\n#define\tisret(n)\t((n)->csub == JRET)\n#define isrec(n)\t((n)->tval & REC)\n#define isfld(n)\t((n)->tval & FLD)\n#define isstr(n)\t((n)->tval & STR)\n#define isnum(n)\t((n)->tval & NUM)\n#define isarr(n)\t((n)->tval & ARR)\n#define isfcn(n)\t((n)->tval & FCN)\n#define istrue(n)\t((n)->csub == BTRUE)\n#define istemp(n)\t((n)->csub == CTEMP)\n#define\tisargument(n)\t((n)->nobj == ARG)\n/* #define freeable(p)\t(!((p)->tval & DONTFREE)) */\n#define freeable(p)\t( ((p)->tval & (STR|DONTFREE)) == STR )\n\n/* structures used by regular expression matching machinery, mostly b.c: */\n\n#define NCHARS\t(1256+3)\t\t/* 256 handles 8-bit chars; 128 does 7-bit */\n\t\t\t\t/* BUG: some overflows (caught) if we use 256 */\n\t\t\t\t/* watch out in match(), etc. */\n#define\tHAT\t(NCHARS+2)\t/* matches ^ in regular expr */\n#define NSTATES\t32\n\ntypedef struct rrow {\n\tlong\tltype;\t/* long avoids pointer warnings on 64-bit */\n\tunion {\n\t\tint i;\n\t\tNode *np;\n\t\tuschar *up;\n\t\tint *rp; /* rune representation of char class */\n\t} lval;\t\t/* because Al stores a pointer in it! */\n\tint\t*lfollow;\n} rrow;\n\ntypedef struct gtte { /* gototab entry */\n\tunsigned int ch;\n\tunsigned int state;\n} gtte;\n\ntypedef struct gtt {\t/* gototab */\n\tsize_t\tallocated;\n\tsize_t\tinuse;\n\tgtte\t*entries;\n} gtt;\n\ntypedef struct fa {\n\tgtt\t*gototab;\n\tuschar\t*out;\n\tuschar\t*restr;\n\tint\t**posns;\n\tint\tstate_count;\n\tbool\tanchor;\n\tint\tuse;\n\tint\tinitstat;\n\tint\tcurstat;\n\tint\taccept;\n\tstruct\trrow re[1];\t/* variable: actual size set by calling malloc */\n} fa;\n\n\n#include \"proto.h\"\n"
        },
        {
          "name": "awkgram.y",
          "type": "blob",
          "size": 13.892578125,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n%{\n#include <stdio.h>\n#include <string.h>\n#include \"awk.h\"\n\nvoid checkdup(Node *list, Cell *item);\nint yywrap(void) { return(1); }\n\nNode\t*beginloc = 0;\nNode\t*endloc = 0;\nbool\tinfunc\t= false;\t/* = true if in arglist or body of func */\nint\tinloop\t= 0;\t/* >= 1 if in while, for, do; can't be bool, since loops can next */\nchar\t*curfname = 0;\t/* current function name */\nNode\t*arglist = 0;\t/* list of args for current function */\n%}\n\n%union {\n\tNode\t*p;\n\tCell\t*cp;\n\tint\ti;\n\tchar\t*s;\n}\n\n%token\t<i>\tFIRSTTOKEN\t/* must be first */\n%token\t<p>\tPROGRAM PASTAT PASTAT2 XBEGIN XEND\n%token\t<i>\tNL ',' '{' '(' '|' ';' '/' ')' '}' '[' ']'\n%token\t<i>\tARRAY\n%token\t<i>\tMATCH NOTMATCH MATCHOP\n%token\t<i>\tFINAL DOT ALL CCL NCCL CHAR OR STAR QUEST PLUS EMPTYRE ZERO\n%token\t<i>\tAND BOR APPEND EQ GE GT LE LT NE IN\n%token\t<i>\tARG BLTIN BREAK CLOSE CONTINUE DELETE DO EXIT FOR FUNC\n%token\t<i>\tSUB GSUB IF INDEX LSUBSTR MATCHFCN NEXT NEXTFILE\n%token\t<i>\tADD MINUS MULT DIVIDE MOD\n%token\t<i>\tASSIGN ASGNOP ADDEQ SUBEQ MULTEQ DIVEQ MODEQ POWEQ\n%token\t<i>\tPRINT PRINTF SPRINTF\n%token\t<p>\tELSE INTEST CONDEXPR\n%token\t<i>\tPOSTINCR PREINCR POSTDECR PREDECR\n%token\t<cp>\tVAR IVAR VARNF CALL NUMBER STRING\n%token\t<s>\tREGEXPR\n\n%type\t<p>\tpas pattern ppattern plist pplist patlist prarg term re\n%type\t<p>\tpa_pat pa_stat pa_stats\n%type\t<s>\treg_expr\n%type\t<p>\tsimple_stmt opt_simple_stmt stmt stmtlist\n%type\t<p>\tvar varname funcname varlist\n%type\t<p>\tfor if else while\n%type\t<i>\tdo st\n%type\t<i>\tpst opt_pst lbrace rbrace rparen comma nl opt_nl and bor\n%type\t<i>\tsubop print\n%type\t<cp>\tstring\n\n%right\tASGNOP\n%right\t'?'\n%right\t':'\n%left\tBOR\n%left\tAND\n%left\tGETLINE\n%nonassoc APPEND EQ GE GT LE LT NE MATCHOP IN '|'\n%left\tARG BLTIN BREAK CALL CLOSE CONTINUE DELETE DO EXIT FOR FUNC\n%left\tGSUB IF INDEX LSUBSTR MATCHFCN NEXT NUMBER\n%left\tPRINT PRINTF RETURN SPLIT SPRINTF STRING SUB SUBSTR\n%left\tREGEXPR VAR VARNF IVAR WHILE '('\n%left\tCAT\n%left\t'+' '-'\n%left\t'*' '/' '%'\n%left\tNOT UMINUS UPLUS\n%right\tPOWER\n%right\tDECR INCR\n%left\tINDIRECT\n%token\tLASTTOKEN\t/* must be last */\n\n%%\n\nprogram:\n\t  pas\t{ if (errorflag==0)\n\t\t\twinner = (Node *)stat3(PROGRAM, beginloc, $1, endloc); }\n\t| error\t{ yyclearin; bracecheck(); SYNTAX(\"bailing out\"); }\n\t;\n\nand:\n\t  AND | and NL\n\t;\n\nbor:\n\t  BOR | bor NL\n\t;\n\ncomma:\n\t  ',' | comma NL\n\t;\n\ndo:\n\t  DO | do NL\n\t;\n\nelse:\n\t  ELSE | else NL\n\t;\n\nfor:\n\t  FOR '(' opt_simple_stmt ';' opt_nl pattern ';' opt_nl opt_simple_stmt rparen {inloop++;} stmt\n\t\t{ --inloop; $$ = stat4(FOR, $3, notnull($6), $9, $12); }\n\t| FOR '(' opt_simple_stmt ';'  ';' opt_nl opt_simple_stmt rparen {inloop++;} stmt\n\t\t{ --inloop; $$ = stat4(FOR, $3, NIL, $7, $10); }\n\t| FOR '(' varname IN varname rparen {inloop++;} stmt\n\t\t{ --inloop; $$ = stat3(IN, $3, makearr($5), $8); }\n\t;\n\nfuncname:\n\t  VAR\t{ setfname($1); }\n\t| CALL\t{ setfname($1); }\n\t;\n\nif:\n\t  IF '(' pattern rparen\t\t{ $$ = notnull($3); }\n\t;\n\nlbrace:\n\t  '{' | lbrace NL\n\t;\n\nnl:\n\t  NL | nl NL\n\t;\n\nopt_nl:\n\t  /* empty */\t{ $$ = 0; }\n\t| nl\n\t;\n\nopt_pst:\n\t  /* empty */\t{ $$ = 0; }\n\t| pst\n\t;\n\n\nopt_simple_stmt:\n\t  /* empty */\t\t\t{ $$ = 0; }\n\t| simple_stmt\n\t;\n\npas:\n\t  opt_pst\t\t\t{ $$ = 0; }\n\t| opt_pst pa_stats opt_pst\t{ $$ = $2; }\n\t;\n\npa_pat:\n\t  pattern\t{ $$ = notnull($1); }\n\t;\n\npa_stat:\n\t  pa_pat\t\t\t{ $$ = stat2(PASTAT, $1, stat2(PRINT, rectonode(), NIL)); }\n\t| pa_pat lbrace stmtlist '}'\t{ $$ = stat2(PASTAT, $1, $3); }\n\t| pa_pat ',' opt_nl pa_pat\t\t{ $$ = pa2stat($1, $4, stat2(PRINT, rectonode(), NIL)); }\n\t| pa_pat ',' opt_nl pa_pat lbrace stmtlist '}'\t{ $$ = pa2stat($1, $4, $6); }\n\t| lbrace stmtlist '}'\t\t{ $$ = stat2(PASTAT, NIL, $2); }\n\t| XBEGIN lbrace stmtlist '}'\n\t\t{ beginloc = linkum(beginloc, $3); $$ = 0; }\n\t| XEND lbrace stmtlist '}'\n\t\t{ endloc = linkum(endloc, $3); $$ = 0; }\n\t| FUNC funcname '(' varlist rparen {infunc = true;} lbrace stmtlist '}'\n\t\t{ infunc = false; curfname=0; defn((Cell *)$2, $4, $8); $$ = 0; }\n\t;\n\npa_stats:\n\t  pa_stat\n\t| pa_stats opt_pst pa_stat\t{ $$ = linkum($1, $3); }\n\t;\n\npatlist:\n\t  pattern\n\t| patlist comma pattern\t\t{ $$ = linkum($1, $3); }\n\t;\n\nppattern:\n\t  var ASGNOP ppattern\t\t{ $$ = op2($2, $1, $3); }\n\t| ppattern '?' ppattern ':' ppattern %prec '?'\n\t \t{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }\n\t| ppattern bor ppattern %prec BOR\n\t\t{ $$ = op2(BOR, notnull($1), notnull($3)); }\n\t| ppattern and ppattern %prec AND\n\t\t{ $$ = op2(AND, notnull($1), notnull($3)); }\n\t| ppattern MATCHOP reg_expr\t{ $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); free($3); }\n\t| ppattern MATCHOP ppattern\n\t\t{ if (constnode($3)) {\n\t\t\t$$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));\n\t\t\tfree($3);\n\t\t  } else\n\t\t\t$$ = op3($2, (Node *)1, $1, $3); }\n\t| ppattern IN varname\t\t{ $$ = op2(INTEST, $1, makearr($3)); }\n\t| '(' plist ')' IN varname\t{ $$ = op2(INTEST, $2, makearr($5)); }\n\t| ppattern term %prec CAT\t{ $$ = op2(CAT, $1, $2); }\n\t| re\n\t| term\n\t;\n\npattern:\n\t  var ASGNOP pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern '?' pattern ':' pattern %prec '?'\n\t \t{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }\n\t| pattern bor pattern %prec BOR\n\t\t{ $$ = op2(BOR, notnull($1), notnull($3)); }\n\t| pattern and pattern %prec AND\n\t\t{ $$ = op2(AND, notnull($1), notnull($3)); }\n\t| pattern EQ pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern GE pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern GT pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern LE pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern LT pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern NE pattern\t\t{ $$ = op2($2, $1, $3); }\n\t| pattern MATCHOP reg_expr\t{ $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); free($3); }\n\t| pattern MATCHOP pattern\n\t\t{ if (constnode($3)) {\n\t\t\t$$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));\n\t\t\tfree($3);\n\t\t  } else\n\t\t\t$$ = op3($2, (Node *)1, $1, $3); }\n\t| pattern IN varname\t\t{ $$ = op2(INTEST, $1, makearr($3)); }\n\t| '(' plist ')' IN varname\t{ $$ = op2(INTEST, $2, makearr($5)); }\n\t| pattern '|' GETLINE var\t{\n\t\t\tif (safe) SYNTAX(\"cmd | getline is unsafe\");\n\t\t\telse $$ = op3(GETLINE, $4, itonp($2), $1); }\n\t| pattern '|' GETLINE\t\t{\n\t\t\tif (safe) SYNTAX(\"cmd | getline is unsafe\");\n\t\t\telse $$ = op3(GETLINE, (Node*)0, itonp($2), $1); }\n\t| pattern term %prec CAT\t{ $$ = op2(CAT, $1, $2); }\n\t| re\n\t| term\n\t;\n\nplist:\n\t  pattern comma pattern\t\t{ $$ = linkum($1, $3); }\n\t| plist comma pattern\t\t{ $$ = linkum($1, $3); }\n\t;\n\npplist:\n\t  ppattern\n\t| pplist comma ppattern\t\t{ $$ = linkum($1, $3); }\n\t;\n\nprarg:\n\t  /* empty */\t\t\t{ $$ = rectonode(); }\n\t| pplist\n\t| '(' plist ')'\t\t\t{ $$ = $2; }\n\t;\n\nprint:\n\t  PRINT | PRINTF\n\t;\n\npst:\n\t  NL | ';' | pst NL | pst ';'\n\t;\n\nrbrace:\n\t  '}' | rbrace NL\n\t;\n\nre:\n\t   reg_expr\n\t\t{ $$ = op3(MATCH, NIL, rectonode(), (Node*)makedfa($1, 0)); free($1); }\n\t| NOT re\t{ $$ = op1(NOT, notnull($2)); }\n\t;\n\nreg_expr:\n\t  '/' {startreg();} REGEXPR '/'\t\t{ $$ = $3; }\n\t;\n\nrparen:\n\t  ')' | rparen NL\n\t;\n\nsimple_stmt:\n\t  print prarg '|' term\t\t{\n\t\t\tif (safe) SYNTAX(\"print | is unsafe\");\n\t\t\telse $$ = stat3($1, $2, itonp($3), $4); }\n\t| print prarg APPEND term\t{\n\t\t\tif (safe) SYNTAX(\"print >> is unsafe\");\n\t\t\telse $$ = stat3($1, $2, itonp($3), $4); }\n\t| print prarg GT term\t\t{\n\t\t\tif (safe) SYNTAX(\"print > is unsafe\");\n\t\t\telse $$ = stat3($1, $2, itonp($3), $4); }\n\t| print prarg\t\t\t{ $$ = stat3($1, $2, NIL, NIL); }\n\t| DELETE varname '[' patlist ']' { $$ = stat2(DELETE, makearr($2), $4); }\n\t| DELETE varname\t\t { $$ = stat2(DELETE, makearr($2), 0); }\n\t| pattern\t\t\t{ $$ = exptostat($1); }\n\t| error\t\t\t\t{ yyclearin; SYNTAX(\"illegal statement\"); }\n\t;\n\nst:\n\t  nl\n\t| ';' opt_nl\n\t;\n\nstmt:\n\t  BREAK st\t\t{ if (!inloop) SYNTAX(\"break illegal outside of loops\");\n\t\t\t\t  $$ = stat1(BREAK, NIL); }\n\t| CONTINUE st\t\t{  if (!inloop) SYNTAX(\"continue illegal outside of loops\");\n\t\t\t\t  $$ = stat1(CONTINUE, NIL); }\n\t| do {inloop++;} stmt {--inloop;} WHILE '(' pattern ')' st\n\t\t{ $$ = stat2(DO, $3, notnull($7)); }\n\t| EXIT pattern st\t{ $$ = stat1(EXIT, $2); }\n\t| EXIT st\t\t{ $$ = stat1(EXIT, NIL); }\n\t| for\n\t| if stmt else stmt\t{ $$ = stat3(IF, $1, $2, $4); }\n\t| if stmt\t\t{ $$ = stat3(IF, $1, $2, NIL); }\n\t| lbrace stmtlist rbrace { $$ = $2; }\n\t| NEXT st\t{ if (infunc)\n\t\t\t\tSYNTAX(\"next is illegal inside a function\");\n\t\t\t  $$ = stat1(NEXT, NIL); }\n\t| NEXTFILE st\t{ if (infunc)\n\t\t\t\tSYNTAX(\"nextfile is illegal inside a function\");\n\t\t\t  $$ = stat1(NEXTFILE, NIL); }\n\t| RETURN pattern st\t{ $$ = stat1(RETURN, $2); }\n\t| RETURN st\t\t{ $$ = stat1(RETURN, NIL); }\n\t| simple_stmt st\n\t| while {inloop++;} stmt\t{ --inloop; $$ = stat2(WHILE, $1, $3); }\n\t| ';' opt_nl\t\t{ $$ = 0; }\n\t;\n\nstmtlist:\n\t  stmt\n\t| stmtlist stmt\t\t{ $$ = linkum($1, $2); }\n\t;\n\nsubop:\n\t  SUB | GSUB\n\t;\n\nstring:\n\t  STRING\n\t| string STRING\t\t{ $$ = catstr($1, $2); }\n\t;\n\nterm:\n \t  term '/' ASGNOP term\t\t{ $$ = op2(DIVEQ, $1, $4); }\n \t| term '+' term\t\t\t{ $$ = op2(ADD, $1, $3); }\n\t| term '-' term\t\t\t{ $$ = op2(MINUS, $1, $3); }\n\t| term '*' term\t\t\t{ $$ = op2(MULT, $1, $3); }\n\t| term '/' term\t\t\t{ $$ = op2(DIVIDE, $1, $3); }\n\t| term '%' term\t\t\t{ $$ = op2(MOD, $1, $3); }\n\t| term POWER term\t\t{ $$ = op2(POWER, $1, $3); }\n\t| '-' term %prec UMINUS\t\t{ $$ = op1(UMINUS, $2); }\n\t| '+' term %prec UMINUS\t\t{ $$ = op1(UPLUS, $2); }\n\t| NOT term %prec UMINUS\t\t{ $$ = op1(NOT, notnull($2)); }\n\t| BLTIN '(' ')'\t\t\t{ $$ = op2(BLTIN, itonp($1), rectonode()); }\n\t| BLTIN '(' patlist ')'\t\t{ $$ = op2(BLTIN, itonp($1), $3); }\n\t| BLTIN\t\t\t\t{ $$ = op2(BLTIN, itonp($1), rectonode()); }\n\t| CALL '(' ')'\t\t\t{ $$ = op2(CALL, celltonode($1,CVAR), NIL); }\n\t| CALL '(' patlist ')'\t\t{ $$ = op2(CALL, celltonode($1,CVAR), $3); }\n\t| CLOSE term\t\t\t{ $$ = op1(CLOSE, $2); }\n\t| DECR var\t\t\t{ $$ = op1(PREDECR, $2); }\n\t| INCR var\t\t\t{ $$ = op1(PREINCR, $2); }\n\t| var DECR\t\t\t{ $$ = op1(POSTDECR, $1); }\n\t| var INCR\t\t\t{ $$ = op1(POSTINCR, $1); }\n\t| GETLINE var LT term\t\t{ $$ = op3(GETLINE, $2, itonp($3), $4); }\n\t| GETLINE LT term\t\t{ $$ = op3(GETLINE, NIL, itonp($2), $3); }\n\t| GETLINE var\t\t\t{ $$ = op3(GETLINE, $2, NIL, NIL); }\n\t| GETLINE\t\t\t{ $$ = op3(GETLINE, NIL, NIL, NIL); }\n\t| INDEX '(' pattern comma pattern ')'\n\t\t{ $$ = op2(INDEX, $3, $5); }\n\t| INDEX '(' pattern comma reg_expr ')'\n\t\t{ SYNTAX(\"index() doesn't permit regular expressions\");\n\t\t  $$ = op2(INDEX, $3, (Node*)$5); }\n\t| '(' pattern ')'\t\t{ $$ = $2; }\n\t| MATCHFCN '(' pattern comma reg_expr ')'\n\t\t{ $$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa($5, 1)); free($5); }\n\t| MATCHFCN '(' pattern comma pattern ')'\n\t\t{ if (constnode($5)) {\n\t\t\t$$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa(strnode($5), 1));\n\t\t\tfree($5);\n\t\t  } else\n\t\t\t$$ = op3(MATCHFCN, (Node *)1, $3, $5); }\n\t| NUMBER\t\t\t{ $$ = celltonode($1, CCON); }\n\t| SPLIT '(' pattern comma varname comma pattern ')'     /* string */\n\t\t{ $$ = op4(SPLIT, $3, makearr($5), $7, (Node*)STRING); }\n\t| SPLIT '(' pattern comma varname comma reg_expr ')'    /* const /regexp/ */\n\t\t{ $$ = op4(SPLIT, $3, makearr($5), (Node*)makedfa($7, 1), (Node *)REGEXPR); free($7); }\n\t| SPLIT '(' pattern comma varname ')'\n\t\t{ $$ = op4(SPLIT, $3, makearr($5), NIL, (Node*)STRING); }  /* default */\n\t| SPRINTF '(' patlist ')'\t{ $$ = op1($1, $3); }\n\t| string\t \t\t{ $$ = celltonode($1, CCON); }\n\t| subop '(' reg_expr comma pattern ')'\n\t\t{ $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, rectonode()); free($3); }\n\t| subop '(' pattern comma pattern ')'\n\t\t{ if (constnode($3)) {\n\t\t\t$$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, rectonode());\n\t\t\tfree($3);\n\t\t  } else\n\t\t\t$$ = op4($1, (Node *)1, $3, $5, rectonode()); }\n\t| subop '(' reg_expr comma pattern comma var ')'\n\t\t{ $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, $7); free($3); }\n\t| subop '(' pattern comma pattern comma var ')'\n\t\t{ if (constnode($3)) {\n\t\t\t$$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, $7);\n\t\t\tfree($3);\n\t\t  } else\n\t\t\t$$ = op4($1, (Node *)1, $3, $5, $7); }\n\t| SUBSTR '(' pattern comma pattern comma pattern ')'\n\t\t{ $$ = op3(SUBSTR, $3, $5, $7); }\n\t| SUBSTR '(' pattern comma pattern ')'\n\t\t{ $$ = op3(SUBSTR, $3, $5, NIL); }\n\t| var\n\t;\n\nvar:\n\t  varname\n\t| varname '[' patlist ']'\t{ $$ = op2(ARRAY, makearr($1), $3); }\n\t| IVAR\t\t\t\t{ $$ = op1(INDIRECT, celltonode($1, CVAR)); }\n\t| INDIRECT term\t \t\t{ $$ = op1(INDIRECT, $2); }\n\t;\n\nvarlist:\n\t  /* nothing */\t\t{ arglist = $$ = 0; }\n\t| VAR\t\t\t{ arglist = $$ = celltonode($1,CVAR); }\n\t| varlist comma VAR\t{\n\t\t\tcheckdup($1, $3);\n\t\t\targlist = $$ = linkum($1,celltonode($3,CVAR)); }\n\t;\n\nvarname:\n\t  VAR\t\t\t{ $$ = celltonode($1, CVAR); }\n\t| ARG \t\t\t{ $$ = op1(ARG, itonp($1)); }\n\t| VARNF\t\t\t{ $$ = op1(VARNF, (Node *) $1); }\n\t;\n\n\nwhile:\n\t  WHILE '(' pattern rparen\t{ $$ = notnull($3); }\n\t;\n\n%%\n\nvoid setfname(Cell *p)\n{\n\tif (isarr(p))\n\t\tSYNTAX(\"%s is an array, not a function\", p->nval);\n\telse if (isfcn(p))\n\t\tSYNTAX(\"you can't define function %s more than once\", p->nval);\n\tcurfname = p->nval;\n}\n\nint constnode(Node *p)\n{\n\treturn isvalue(p) && ((Cell *) (p->narg[0]))->csub == CCON;\n}\n\nchar *strnode(Node *p)\n{\n\treturn ((Cell *)(p->narg[0]))->sval;\n}\n\nNode *notnull(Node *n)\n{\n\tswitch (n->nobj) {\n\tcase LE: case LT: case EQ: case NE: case GT: case GE:\n\tcase BOR: case AND: case NOT:\n\t\treturn n;\n\tdefault:\n\t\treturn op2(NE, n, nullnode);\n\t}\n}\n\nvoid checkdup(Node *vl, Cell *cp)\t/* check if name already in list */\n{\n\tchar *s = cp->nval;\n\tfor ( ; vl; vl = vl->nnext) {\n\t\tif (strcmp(s, ((Cell *)(vl->narg[0]))->nval) == 0) {\n\t\t\tSYNTAX(\"duplicate argument %s\", s);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "b.c",
          "type": "blob",
          "size": 37.1884765625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n/* lasciate ogne speranza, voi ch'intrate. */\n\n#define\tDEBUG\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"awk.h\"\n#include \"awkgram.tab.h\"\n\n#define MAXLIN 22\n\n#define type(v)\t\t(v)->nobj\t/* badly overloaded here */\n#define info(v)\t\t(v)->ntype\t/* badly overloaded here */\n#define left(v)\t\t(v)->narg[0]\n#define right(v)\t(v)->narg[1]\n#define parent(v)\t(v)->nnext\n\n#define LEAF\tcase CCL: case NCCL: case CHAR: case DOT: case FINAL: case ALL:\n#define ELEAF\tcase EMPTYRE:\t\t/* empty string in regexp */\n#define UNARY\tcase STAR: case PLUS: case QUEST:\n\n/* encoding in tree Nodes:\n\tleaf (CCL, NCCL, CHAR, DOT, FINAL, ALL, EMPTYRE):\n\t\tleft is index, right contains value or pointer to value\n\tunary (STAR, PLUS, QUEST): left is child, right is null\n\tbinary (CAT, OR): left and right are children\n\tparent contains pointer to parent\n*/\n\n\nint\t*setvec;\nint\t*tmpset;\nint\tmaxsetvec = 0;\n\nint\trtok;\t\t/* next token in current re */\nint\trlxval;\nstatic const uschar\t*rlxstr;\nstatic const uschar\t*prestr;\t/* current position in current re */\nstatic const uschar\t*lastre;\t/* origin of last re */\nstatic const uschar\t*lastatom;\t/* origin of last Atom */\nstatic const uschar\t*starttok;\nstatic const uschar \t*basestr;\t/* starts with original, replaced during\n\t\t\t\t   repetition processing */\nstatic const uschar \t*firstbasestr;\n\nstatic\tint setcnt;\nstatic\tint poscnt;\n\nconst char\t*patbeg;\nint\tpatlen;\n\n#define\tNFA\t128\t/* cache this many dynamic fa's */\nfa\t*fatab[NFA];\nint\tnfatab\t= 0;\t/* entries in fatab */\n\nextern int u8_nextlen(const char *s);\n\n\n/* utf-8 mechanism:\n\n   For most of Awk, utf-8 strings just \"work\", since they look like\n   null-terminated sequences of 8-bit bytes.\n\n   Functions like length(), index(), and substr() have to operate\n   in units of utf-8 characters.  The u8_* functions in run.c\n   handle this.\n\n   Regular expressions are more complicated, since the basic\n   mechanism of the goto table used 8-bit byte indices into the\n   gototab entries to compute the next state.  Unicode is a lot\n   bigger, so the gototab entries are now structs with a character\n   and a next state. These are sorted by code point and binary\n   searched.\n\n   Throughout the RE mechanism in b.c, utf-8 characters are\n   converted to their utf-32 value.  This mostly shows up in\n   cclenter, which expands character class ranges like a-z and now\n   alpha-omega.  The size of a gototab array is still about 256.\n   This should be dynamic, but for now things work ok for a single\n   code page of Unicode, which is the most likely case.\n\n   The code changes are localized in run.c and b.c.  I have added a\n   handful of functions to somewhat better hide the implementation,\n   but a lot more could be done.\n\n */\n\nstatic int entry_cmp(const void *l, const void *r);\nstatic int get_gototab(fa*, int, int);\nstatic int set_gototab(fa*, int, int, int);\nstatic void clear_gototab(fa*, int);\nextern int u8_rune(int *, const char *);\n\nstatic int *\nintalloc(size_t n, const char *f)\n{\n\tint *p = (int *) calloc(n, sizeof(int));\n\tif (p == NULL)\n\t\toverflo(f);\n\treturn p;\n}\n\nstatic void\nresizesetvec(const char *f)\n{\n\tif (maxsetvec == 0)\n\t\tmaxsetvec = MAXLIN;\n\telse\n\t\tmaxsetvec *= 4;\n\tsetvec = (int *) realloc(setvec, maxsetvec * sizeof(*setvec));\n\ttmpset = (int *) realloc(tmpset, maxsetvec * sizeof(*tmpset));\n\tif (setvec == NULL || tmpset == NULL)\n\t\toverflo(f);\n}\n\nstatic void\nresize_state(fa *f, int state)\n{\n\tgtt *p;\n\tuschar *p2;\n\tint **p3;\n\tint i, new_count;\n\n\tif (++state < f->state_count)\n\t\treturn;\n\n\tnew_count = state + 10; /* needs to be tuned */\n\n\tp = (gtt *) realloc(f->gototab, new_count * sizeof(gtt));\n\tif (p == NULL)\n\t\tgoto out;\n\tf->gototab = p;\n\n\tp2 = (uschar *) realloc(f->out, new_count * sizeof(f->out[0]));\n\tif (p2 == NULL)\n\t\tgoto out;\n\tf->out = p2;\n\n\tp3 = (int **) realloc(f->posns, new_count * sizeof(f->posns[0]));\n\tif (p3 == NULL)\n\t\tgoto out;\n\tf->posns = p3;\n\n\tfor (i = f->state_count; i < new_count; ++i) {\n\t\tf->gototab[i].entries = (gtte *) calloc(NCHARS, sizeof(gtte));\n\t\tif (f->gototab[i].entries == NULL)\n\t\t\tgoto out;\n\t\tf->gototab[i].allocated = NCHARS;\n\t\tf->gototab[i].inuse = 0;\n\t\tf->out[i] = 0;\n\t\tf->posns[i] = NULL;\n\t}\n\tf->state_count = new_count;\n\treturn;\nout:\n\toverflo(__func__);\n}\n\nfa *makedfa(const char *s, bool anchor)\t/* returns dfa for reg expr s */\n{\n\tint i, use, nuse;\n\tfa *pfa;\n\tstatic int now = 1;\n\n\tif (setvec == NULL) {\t/* first time through any RE */\n\t\tresizesetvec(__func__);\n\t}\n\n\tif (compile_time != RUNNING)\t/* a constant for sure */\n\t\treturn mkdfa(s, anchor);\n\tfor (i = 0; i < nfatab; i++)\t/* is it there already? */\n\t\tif (fatab[i]->anchor == anchor\n\t\t  && strcmp((const char *) fatab[i]->restr, s) == 0) {\n\t\t\tfatab[i]->use = now++;\n\t\t\treturn fatab[i];\n\t\t}\n\tpfa = mkdfa(s, anchor);\n\tif (nfatab < NFA) {\t/* room for another */\n\t\tfatab[nfatab] = pfa;\n\t\tfatab[nfatab]->use = now++;\n\t\tnfatab++;\n\t\treturn pfa;\n\t}\n\tuse = fatab[0]->use;\t/* replace least-recently used */\n\tnuse = 0;\n\tfor (i = 1; i < nfatab; i++)\n\t\tif (fatab[i]->use < use) {\n\t\t\tuse = fatab[i]->use;\n\t\t\tnuse = i;\n\t\t}\n\tfreefa(fatab[nuse]);\n\tfatab[nuse] = pfa;\n\tpfa->use = now++;\n\treturn pfa;\n}\n\nfa *mkdfa(const char *s, bool anchor)\t/* does the real work of making a dfa */\n\t\t\t\t/* anchor = true for anchored matches, else false */\n{\n\tNode *p, *p1;\n\tfa *f;\n\n\tfirstbasestr = (const uschar *) s;\n\tbasestr = firstbasestr;\n\tp = reparse(s);\n\tp1 = op2(CAT, op2(STAR, op2(ALL, NIL, NIL), NIL), p);\n\t\t/* put ALL STAR in front of reg.  exp. */\n\tp1 = op2(CAT, p1, op2(FINAL, NIL, NIL));\n\t\t/* put FINAL after reg.  exp. */\n\n\tposcnt = 0;\n\tpenter(p1);\t/* enter parent pointers and leaf indices */\n\tif ((f = (fa *) calloc(1, sizeof(fa) + poscnt * sizeof(rrow))) == NULL)\n\t\toverflo(__func__);\n\tf->accept = poscnt-1;\t/* penter has computed number of positions in re */\n\tcfoll(f, p1);\t/* set up follow sets */\n\tfreetr(p1);\n\tresize_state(f, 1);\n\tf->posns[0] = intalloc(*(f->re[0].lfollow), __func__);\n\tf->posns[1] = intalloc(1, __func__);\n\t*f->posns[1] = 0;\n\tf->initstat = makeinit(f, anchor);\n\tf->anchor = anchor;\n\tf->restr = (uschar *) tostring(s);\n\tif (firstbasestr != basestr) {\n\t\tif (basestr)\n\t\t\txfree(basestr);\n\t}\n\treturn f;\n}\n\nint makeinit(fa *f, bool anchor)\n{\n\tint i, k;\n\n\tf->curstat = 2;\n\tf->out[2] = 0;\n\tk = *(f->re[0].lfollow);\n\txfree(f->posns[2]);\n\tf->posns[2] = intalloc(k + 1,  __func__);\n\tfor (i = 0; i <= k; i++) {\n\t\t(f->posns[2])[i] = (f->re[0].lfollow)[i];\n\t}\n\tif ((f->posns[2])[1] == f->accept)\n\t\tf->out[2] = 1;\n\tclear_gototab(f, 2);\n\tf->curstat = cgoto(f, 2, HAT);\n\tif (anchor) {\n\t\t*f->posns[2] = k-1;\t/* leave out position 0 */\n\t\tfor (i = 0; i < k; i++) {\n\t\t\t(f->posns[0])[i] = (f->posns[2])[i];\n\t\t}\n\n\t\tf->out[0] = f->out[2];\n\t\tif (f->curstat != 2)\n\t\t\t--(*f->posns[f->curstat]);\n\t}\n\treturn f->curstat;\n}\n\nvoid penter(Node *p)\t/* set up parent pointers and leaf indices */\n{\n\tswitch (type(p)) {\n\tELEAF\n\tLEAF\n\t\tinfo(p) = poscnt;\n\t\tposcnt++;\n\t\tbreak;\n\tUNARY\n\t\tpenter(left(p));\n\t\tparent(left(p)) = p;\n\t\tbreak;\n\tcase CAT:\n\tcase OR:\n\t\tpenter(left(p));\n\t\tpenter(right(p));\n\t\tparent(left(p)) = p;\n\t\tparent(right(p)) = p;\n\t\tbreak;\n\tcase ZERO:\n\t\tbreak;\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"can't happen: unknown type %d in penter\", type(p));\n\t\tbreak;\n\t}\n}\n\nvoid freetr(Node *p)\t/* free parse tree */\n{\n\tswitch (type(p)) {\n\tELEAF\n\tLEAF\n\t\txfree(p);\n\t\tbreak;\n\tUNARY\n\tcase ZERO:\n\t\tfreetr(left(p));\n\t\txfree(p);\n\t\tbreak;\n\tcase CAT:\n\tcase OR:\n\t\tfreetr(left(p));\n\t\tfreetr(right(p));\n\t\txfree(p);\n\t\tbreak;\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"can't happen: unknown type %d in freetr\", type(p));\n\t\tbreak;\n\t}\n}\n\n/* in the parsing of regular expressions, metacharacters like . have */\n/* to be seen literally;  \\056 is not a metacharacter. */\n\nint hexstr(const uschar **pp, int max)\t/* find and eval hex string at pp, return new p */\n{\t\t\t/* only pick up one 8-bit byte (2 chars) */\n\tconst uschar *p;\n\tint n = 0;\n\tint i;\n\n\tfor (i = 0, p = *pp; i < max && isxdigit(*p); i++, p++) {\n\t\tif (isdigit((int) *p))\n\t\t\tn = 16 * n + *p - '0';\n\t\telse if (*p >= 'a' && *p <= 'f')\n\t\t\tn = 16 * n + *p - 'a' + 10;\n\t\telse if (*p >= 'A' && *p <= 'F')\n\t\t\tn = 16 * n + *p - 'A' + 10;\n\t}\n\t*pp = p;\n\treturn n;\n}\n\n\n\n#define isoctdigit(c) ((c) >= '0' && (c) <= '7')\t/* multiple use of arg */\n\nint quoted(const uschar **pp)\t/* pick up next thing after a \\\\ */\n\t\t\t/* and increment *pp */\n{\n\tconst uschar *p = *pp;\n\tint c;\n\n/* BUG: should advance by utf-8 char even if makes no sense */\n\n\tswitch ((c = *p++)) {\n\tcase 't':\n\t\tc = '\\t';\n\t\tbreak;\n\tcase 'n':\n\t\tc = '\\n';\n\t\tbreak;\n\tcase 'f':\n\t\tc = '\\f';\n\t\tbreak;\n\tcase 'r':\n\t\tc = '\\r';\n\t\tbreak;\n\tcase 'b':\n\t\tc = '\\b';\n\t\tbreak;\n\tcase 'v':\n\t\tc = '\\v';\n\t\tbreak;\n\tcase 'a':\n\t\tc = '\\a';\n\t\tbreak;\n\tcase '\\\\':\n\t\tc = '\\\\';\n\t\tbreak;\n\tcase 'x': /* 2 hex digits follow */\n\t\tc = hexstr(&p, 2); /* this adds a null if number is invalid */\n\t\tbreak;\n\tcase 'u': /* unicode char number up to 8 hex digits */\n\t\tc = hexstr(&p, 8);\n\t\tbreak;\n\tdefault:\n\t\tif (isoctdigit(c)) { /* \\d \\dd \\ddd */\n\t\t\tint n = c - '0';\n\t\t\tif (isoctdigit(*p)) {\n\t\t\t\tn = 8 * n + *p++ - '0';\n\t\t\t\tif (isoctdigit(*p))\n\t\t\t\t\tn = 8 * n + *p++ - '0';\n\t\t\t}\n\t\t\tc = n;\n\t\t}\n\t}\n\n\t*pp = p;\n\treturn c;\n}\n\nint *cclenter(const char *argp)\t/* add a character class */\n{\n\tint i, c, c2;\n\tint n;\n\tconst uschar *p = (const uschar *) argp;\n\tint *bp, *retp;\n\tstatic int *buf = NULL;\n\tstatic int bufsz = 100;\n\n\tif (buf == NULL && (buf = (int *) calloc(bufsz, sizeof(int))) == NULL)\n\t\tFATAL(\"out of space for character class [%.10s...] 1\", p);\n\tbp = buf;\n\tfor (i = 0; *p != 0; ) {\n\t\tn = u8_rune(&c, (const char *) p);\n\t\tp += n;\n\t\tif (c == '\\\\') {\n\t\t\tc = quoted(&p);\n\t\t} else if (c == '-' && i > 0 && bp[-1] != 0) {\n\t\t\tif (*p != 0) {\n\t\t\t\tc = bp[-1];\n\t\t\t\t/* c2 = *p++; */\n\t\t\t\tn = u8_rune(&c2, (const char *) p);\n\t\t\t\tp += n;\n\t\t\t\tif (c2 == '\\\\')\n\t\t\t\t\tc2 = quoted(&p); /* BUG: sets p, has to be u8 size */\n\t\t\t\tif (c > c2) {\t/* empty; ignore */\n\t\t\t\t\tbp--;\n\t\t\t\t\ti--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (c < c2) {\n\t\t\t\t\tif (i >= bufsz) {\n\t\t\t\t\t\tbufsz *= 2;\n\t\t\t\t\t\tbuf = (int *) realloc(buf, bufsz * sizeof(int));\n\t\t\t\t\t\tif (buf == NULL)\n\t\t\t\t\t\t\tFATAL(\"out of space for character class [%.10s...] 2\", p);\n\t\t\t\t\t\tbp = buf + i;\n\t\t\t\t\t}\n\t\t\t\t\t*bp++ = ++c;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (i >= bufsz) {\n\t\t\tbufsz *= 2;\n\t\t\tbuf = (int *) realloc(buf, bufsz * sizeof(int));\n\t\t\tif (buf == NULL)\n\t\t\t\tFATAL(\"out of space for character class [%.10s...] 2\", p);\n\t\t\tbp = buf + i;\n\t\t}\n\t\t*bp++ = c;\n\t\ti++;\n\t}\n\t*bp = 0;\n\t/* DPRINTF(\"cclenter: in = |%s|, out = |%s|\\n\", op, buf); BUG: can't print array of int */\n\t/* xfree(op);  BUG: what are we freeing here? */\n\tretp = (int *) calloc(bp-buf+1, sizeof(int));\n\tfor (i = 0; i < bp-buf+1; i++)\n\t\tretp[i] = buf[i];\n\treturn retp;\n}\n\nvoid overflo(const char *s)\n{\n\tFATAL(\"regular expression too big: out of space in %.30s...\", s);\n}\n\nvoid cfoll(fa *f, Node *v)\t/* enter follow set of each leaf of vertex v into lfollow[leaf] */\n{\n\tint i;\n\tint *p;\n\n\tswitch (type(v)) {\n\tELEAF\n\tLEAF\n\t\tf->re[info(v)].ltype = type(v);\n\t\tf->re[info(v)].lval.np = right(v);\n\t\twhile (f->accept >= maxsetvec) {\t/* guessing here! */\n\t\t\tresizesetvec(__func__);\n\t\t}\n\t\tfor (i = 0; i <= f->accept; i++)\n\t\t\tsetvec[i] = 0;\n\t\tsetcnt = 0;\n\t\tfollow(v);\t/* computes setvec and setcnt */\n\t\tp = intalloc(setcnt + 1, __func__);\n\t\tf->re[info(v)].lfollow = p;\n\t\t*p = setcnt;\n\t\tfor (i = f->accept; i >= 0; i--)\n\t\t\tif (setvec[i] == 1)\n\t\t\t\t*++p = i;\n\t\tbreak;\n\tUNARY\n\t\tcfoll(f,left(v));\n\t\tbreak;\n\tcase CAT:\n\tcase OR:\n\t\tcfoll(f,left(v));\n\t\tcfoll(f,right(v));\n\t\tbreak;\n\tcase ZERO:\n\t\tbreak;\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"can't happen: unknown type %d in cfoll\", type(v));\n\t}\n}\n\nint first(Node *p)\t/* collects initially active leaves of p into setvec */\n\t\t\t/* returns 0 if p matches empty string */\n{\n\tint b, lp;\n\n\tswitch (type(p)) {\n\tELEAF\n\tLEAF\n\t\tlp = info(p);\t/* look for high-water mark of subscripts */\n\t\twhile (setcnt >= maxsetvec || lp >= maxsetvec) {\t/* guessing here! */\n\t\t\tresizesetvec(__func__);\n\t\t}\n\t\tif (type(p) == EMPTYRE) {\n\t\t\tsetvec[lp] = 0;\n\t\t\treturn(0);\n\t\t}\n\t\tif (setvec[lp] != 1) {\n\t\t\tsetvec[lp] = 1;\n\t\t\tsetcnt++;\n\t\t}\n\t\tif (type(p) == CCL && (*(int *) right(p)) == 0)\n\t\t\treturn(0);\t\t/* empty CCL */\n\t\treturn(1);\n\tcase PLUS:\n\t\tif (first(left(p)) == 0)\n\t\t\treturn(0);\n\t\treturn(1);\n\tcase STAR:\n\tcase QUEST:\n\t\tfirst(left(p));\n\t\treturn(0);\n\tcase CAT:\n\t\tif (first(left(p)) == 0 && first(right(p)) == 0) return(0);\n\t\treturn(1);\n\tcase OR:\n\t\tb = first(right(p));\n\t\tif (first(left(p)) == 0 || b == 0) return(0);\n\t\treturn(1);\n\tcase ZERO:\n\t\treturn 0;\n\t}\n\tFATAL(\"can't happen: unknown type %d in first\", type(p));\t/* can't happen */\n\treturn(-1);\n}\n\nvoid follow(Node *v)\t/* collects leaves that can follow v into setvec */\n{\n\tNode *p;\n\n\tif (type(v) == FINAL)\n\t\treturn;\n\tp = parent(v);\n\tswitch (type(p)) {\n\tcase STAR:\n\tcase PLUS:\n\t\tfirst(v);\n\t\tfollow(p);\n\t\treturn;\n\n\tcase OR:\n\tcase QUEST:\n\t\tfollow(p);\n\t\treturn;\n\n\tcase CAT:\n\t\tif (v == left(p)) {\t/* v is left child of p */\n\t\t\tif (first(right(p)) == 0) {\n\t\t\t\tfollow(p);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\t\t/* v is right child */\n\t\t\tfollow(p);\n\t\treturn;\n\t}\n}\n\nint member(int c, int *sarg)\t/* is c in s? */\n{\n\tint *s = (int *) sarg;\n\n\twhile (*s)\n\t\tif (c == *s++)\n\t\t\treturn(1);\n\treturn(0);\n}\n\nstatic void resize_gototab(fa *f, int state)\n{\n\tsize_t new_size = f->gototab[state].allocated * 2;\n\tgtte *p = (gtte *) realloc(f->gototab[state].entries, new_size * sizeof(gtte));\n\tif (p == NULL)\n\t\toverflo(__func__);\n\n\t// need to initialize the new memory to zero\n\tsize_t orig_size = f->gototab[state].allocated;\t\t// 2nd half of new mem is this size\n\tmemset(p + orig_size, 0, orig_size * sizeof(gtte));\t// clean it out\n\n\tf->gototab[state].allocated = new_size;\t\t\t// update gototab info\n\tf->gototab[state].entries = p;\n}\n\nstatic int get_gototab(fa *f, int state, int ch) /* hide gototab implementation */\n{\n\tgtte key;\n\tgtte *item;\n\n\tkey.ch = ch;\n\tkey.state = 0;\t/* irrelevant */\n\titem = (gtte *) bsearch(& key, f->gototab[state].entries,\n\t\t\tf->gototab[state].inuse, sizeof(gtte),\n\t\t\tentry_cmp);\n\n\tif (item == NULL)\n\t\treturn 0;\n\telse\n\t\treturn item->state;\n}\n\nstatic int entry_cmp(const void *l, const void *r)\n{\n\tconst gtte *left, *right;\n\n\tleft = (const gtte *) l;\n\tright = (const gtte *) r;\n\n\treturn left->ch - right->ch;\n}\n\nstatic int set_gototab(fa *f, int state, int ch, int val) /* hide gototab implementation */\n{\n\tif (f->gototab[state].inuse == 0) {\n\t\tf->gototab[state].entries[0].ch = ch;\n\t\tf->gototab[state].entries[0].state = val;\n\t\tf->gototab[state].inuse++;\n\t\treturn val;\n\t} else if ((unsigned)ch > f->gototab[state].entries[f->gototab[state].inuse-1].ch) {\n\t\t// not seen yet, insert and return\n\t\tgtt *tab = & f->gototab[state];\n\t\tif (tab->inuse + 1 >= tab->allocated)\n\t\t\tresize_gototab(f, state);\n\n\t\tf->gototab[state].entries[f->gototab[state].inuse].ch = ch;\n\t\tf->gototab[state].entries[f->gototab[state].inuse].state = val;\n\t\tf->gototab[state].inuse++;\n\t\treturn val;\n\t} else {\n\t\t// maybe we have it, maybe we don't\n\t\tgtte key;\n\t\tgtte *item;\n\n\t\tkey.ch = ch;\n\t\tkey.state = 0;\t/* irrelevant */\n\t\titem = (gtte *) bsearch(& key, f->gototab[state].entries,\n\t\t\t\tf->gototab[state].inuse, sizeof(gtte),\n\t\t\t\tentry_cmp);\n\n\t\tif (item != NULL) {\n\t\t\t// we have it, update state and return\n\t\t\titem->state = val;\n\t\t\treturn item->state;\n\t\t}\n\t\t// otherwise, fall through to insert and reallocate.\n\t}\n\n\tgtt *tab = & f->gototab[state];\n\tif (tab->inuse + 1 >= tab->allocated)\n\t\tresize_gototab(f, state);\n\tf->gototab[state].entries[tab->inuse].ch = ch;\n\tf->gototab[state].entries[tab->inuse].state = val;\n\t++tab->inuse;\n\n\tqsort(f->gototab[state].entries,\n\t\tf->gototab[state].inuse, sizeof(gtte), entry_cmp);\n\n\treturn val; /* not used anywhere at the moment */\n}\n\nstatic void clear_gototab(fa *f, int state)\n{\n\tmemset(f->gototab[state].entries, 0,\n\t\tf->gototab[state].allocated * sizeof(gtte));\n\tf->gototab[state].inuse = 0;\n}\n\nint match(fa *f, const char *p0)\t/* shortest match ? */\n{\n\tint s, ns;\n\tint n;\n\tint rune;\n\tconst uschar *p = (const uschar *) p0;\n\n\t/* return pmatch(f, p0); does it matter whether longest or shortest? */\n\n\ts = f->initstat;\n\tassert (s < f->state_count);\n\n\tif (f->out[s])\n\t\treturn(1);\n\tdo {\n\t\t/* assert(*p < NCHARS); */\n\t\tn = u8_rune(&rune, (const char *) p);\n\t\tif ((ns = get_gototab(f, s, rune)) != 0)\n\t\t\ts = ns;\n\t\telse\n\t\t\ts = cgoto(f, s, rune);\n\t\tif (f->out[s])\n\t\t\treturn(1);\n\t\tif (*p == 0)\n\t\t\tbreak;\n\t\tp += n;\n\t} while (1);  /* was *p++ != 0 */\n\treturn(0);\n}\n\nint pmatch(fa *f, const char *p0)\t/* longest match, for sub */\n{\n\tint s, ns;\n\tint n;\n\tint rune;\n\tconst uschar *p = (const uschar *) p0;\n\tconst uschar *q;\n\n\ts = f->initstat;\n\tassert(s < f->state_count);\n\n\tpatbeg = (const char *)p;\n\tpatlen = -1;\n\tdo {\n\t\tq = p;\n\t\tdo {\n\t\t\tif (f->out[s])\t\t/* final state */\n\t\t\t\tpatlen = q-p;\n\t\t\t/* assert(*q < NCHARS); */\n\t\t\tn = u8_rune(&rune, (const char *) q);\n\t\t\tif ((ns = get_gototab(f, s, rune)) != 0)\n\t\t\t\ts = ns;\n\t\t\telse\n\t\t\t\ts = cgoto(f, s, rune);\n\n\t\t\tassert(s < f->state_count);\n\n\t\t\tif (s == 1) {\t/* no transition */\n\t\t\t\tif (patlen >= 0) {\n\t\t\t\t\tpatbeg = (const char *) p;\n\t\t\t\t\treturn(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tgoto nextin;\t/* no match */\n\t\t\t}\n\t\t\tif (*q == 0)\n\t\t\t\tbreak;\n\t\t\tq += n;\n\t\t} while (1);\n\t\tq++;  /* was *q++ */\n\t\tif (f->out[s])\n\t\t\tpatlen = q-p-1;\t/* don't count $ */\n\t\tif (patlen >= 0) {\n\t\t\tpatbeg = (const char *) p;\n\t\t\treturn(1);\n\t\t}\n\tnextin:\n\t\ts = 2;\n\t\tif (*p == 0)\n\t\t\tbreak;\n\t\tn = u8_rune(&rune, (const char *) p);\n\t\tp += n;\n\t} while (1); /* was *p++ */\n\treturn (0);\n}\n\nint nematch(fa *f, const char *p0)\t/* non-empty match, for sub */\n{\n\tint s, ns;\n        int n;\n        int rune;\n\tconst uschar *p = (const uschar *) p0;\n\tconst uschar *q;\n\n\ts = f->initstat;\n\tassert(s < f->state_count);\n\n\tpatbeg = (const char *)p;\n\tpatlen = -1;\n\twhile (*p) {\n\t\tq = p;\n\t\tdo {\n\t\t\tif (f->out[s])\t\t/* final state */\n\t\t\t\tpatlen = q-p;\n\t\t\t/* assert(*q < NCHARS); */\n\t\t\tn = u8_rune(&rune, (const char *) q);\n\t\t\tif ((ns = get_gototab(f, s, rune)) != 0)\n\t\t\t\ts = ns;\n\t\t\telse\n\t\t\t\ts = cgoto(f, s, rune);\n\t\t\tif (s == 1) {\t/* no transition */\n\t\t\t\tif (patlen > 0) {\n\t\t\t\t\tpatbeg = (const char *) p;\n\t\t\t\t\treturn(1);\n\t\t\t\t} else\n\t\t\t\t\tgoto nnextin;\t/* no nonempty match */\n\t\t\t}\n\t\t\tif (*q == 0)\n\t\t\t\tbreak;\n\t\t\tq += n;\n\t\t} while (1);\n\t\tq++;\n\t\tif (f->out[s])\n\t\t\tpatlen = q-p-1;\t/* don't count $ */\n\t\tif (patlen > 0 ) {\n\t\t\tpatbeg = (const char *) p;\n\t\t\treturn(1);\n\t\t}\n\tnnextin:\n\t\ts = 2;\n\t\tp++;\n\t}\n\treturn (0);\n}\n\n\n/*\n * NAME\n *     fnematch\n *\n * DESCRIPTION\n *     A stream-fed version of nematch which transfers characters to a\n *     null-terminated buffer. All characters up to and including the last\n *     character of the matching text or EOF are placed in the buffer. If\n *     a match is found, patbeg and patlen are set appropriately.\n *\n * RETURN VALUES\n *     false    No match found.\n *     true     Match found.\n */\n\nbool fnematch(fa *pfa, FILE *f, char **pbuf, int *pbufsize, int quantum)\n{\n\tchar *i, *j, *k, *buf = *pbuf;\n\tint bufsize = *pbufsize;\n\tint c, n, ns, s;\n\n\ts = pfa->initstat;\n\tpatlen = 0;\n\n\t/*\n\t * buf <= i <= j <= k <= buf+bufsize\n\t *\n\t * i: origin of active substring\n\t * j: current character\n\t * k: destination of the next getc\n\t */\n\n\ti = j = k = buf;\n\n\tdo {\n\t\t/*\n\t\t * Call u8_rune with at least awk_mb_cur_max ahead in\n\t\t * the buffer until EOF interferes.\n\t\t */\n\t\tif (k - j < (int)awk_mb_cur_max) {\n\t\t\tif (k + awk_mb_cur_max > buf + bufsize) {\n\t\t\t\tchar *obuf = buf;\n\t\t\t\tadjbuf((char **) &buf, &bufsize,\n\t\t\t\t    bufsize + awk_mb_cur_max,\n\t\t\t\t    quantum, 0, \"fnematch\");\n\n\t\t\t\t/* buf resized, maybe moved. update pointers */\n\t\t\t\t*pbufsize = bufsize;\n\t\t\t\tif (obuf != buf) {\n\t\t\t\t\ti = buf + (i - obuf);\n\t\t\t\t\tj = buf + (j - obuf);\n\t\t\t\t\tk = buf + (k - obuf);\n\t\t\t\t\t*pbuf = buf;\n\t\t\t\t\tif (patlen)\n\t\t\t\t\t\tpatbeg = buf + (patbeg - obuf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (n = awk_mb_cur_max ; n > 0; n--) {\n\t\t\t\t*k++ = (c = getc(f)) != EOF ? c : 0;\n\t\t\t\tif (c == EOF) {\n\t\t\t\t\tif (ferror(f))\n\t\t\t\t\t\tFATAL(\"fnematch: getc error\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tj += u8_rune(&c, j);\n\n\t\tif ((ns = get_gototab(pfa, s, c)) != 0)\n\t\t\ts = ns;\n\t\telse\n\t\t\ts = cgoto(pfa, s, c);\n\n\t\tif (pfa->out[s]) {\t/* final state */\n\t\t\tpatbeg = i;\n\t\t\tpatlen = j - i;\n\t\t\tif (c == 0)\t/* don't count $ */\n\t\t\t\tpatlen--;\n\t\t}\n\n\t\tif (c && s != 1)\n\t\t\tcontinue;  /* origin i still viable, next j */\n\t\tif (patlen)\n\t\t\tbreak;     /* best match found */\n\n\t\t/* no match at origin i, next i and start over */\n\t\ti += u8_rune(&c, i);\n\t\tif (c == 0)\n\t\t\tbreak;    /* no match */\n\t\tj = i;\n\t\ts = 2;\n\t} while (1);\n\n\tif (patlen) {\n\t\t/*\n\t\t * Under no circumstances is the last character fed to\n\t\t * the automaton part of the match. It is EOF's nullbyte,\n\t\t * or it sent the automaton into a state with no further\n\t\t * transitions available (s==1), or both. Room for a\n\t\t * terminating nullbyte is guaranteed.\n\t\t *\n\t\t * ungetc any chars after the end of matching text\n\t\t * (except for EOF's nullbyte, if present) and null\n\t\t * terminate the buffer.\n\t\t */\n\t\tdo\n\t\t\tif (*--k && ungetc(*k, f) == EOF)\n\t\t\t\tFATAL(\"unable to ungetc '%c'\", *k);\n\t\twhile (k > patbeg + patlen);\n\t\t*k = '\\0';\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\nNode *reparse(const char *p)\t/* parses regular expression pointed to by p */\n{\t\t\t/* uses relex() to scan regular expression */\n\tNode *np;\n\n\tDPRINTF(\"reparse <%s>\\n\", p);\n\tlastre = prestr = (const uschar *) p;\t/* prestr points to string to be parsed */\n\trtok = relex();\n\t/* GNU compatibility: an empty regexp matches anything */\n\tif (rtok == '\\0') {\n\t\t/* FATAL(\"empty regular expression\"); previous */\n\t\treturn(op2(EMPTYRE, NIL, NIL));\n\t}\n\tnp = regexp();\n\tif (rtok != '\\0')\n\t\tFATAL(\"syntax error in regular expression %s at %s\", lastre, prestr);\n\treturn(np);\n}\n\nNode *regexp(void)\t/* top-level parse of reg expr */\n{\n\treturn (alt(concat(primary())));\n}\n\nNode *primary(void)\n{\n\tNode *np;\n\tint savelastatom;\n\n\tswitch (rtok) {\n\tcase CHAR:\n\t\tlastatom = starttok;\n\t\tnp = op2(CHAR, NIL, itonp(rlxval));\n\t\trtok = relex();\n\t\treturn (unary(np));\n\tcase ALL:\n\t\trtok = relex();\n\t\treturn (unary(op2(ALL, NIL, NIL)));\n\tcase EMPTYRE:\n\t\trtok = relex();\n\t\treturn (unary(op2(EMPTYRE, NIL, NIL)));\n\tcase DOT:\n\t\tlastatom = starttok;\n\t\trtok = relex();\n\t\treturn (unary(op2(DOT, NIL, NIL)));\n\tcase CCL:\n\t\tnp = op2(CCL, NIL, (Node*) cclenter((const char *) rlxstr));\n\t\tlastatom = starttok;\n\t\trtok = relex();\n\t\treturn (unary(np));\n\tcase NCCL:\n\t\tnp = op2(NCCL, NIL, (Node *) cclenter((const char *) rlxstr));\n\t\tlastatom = starttok;\n\t\trtok = relex();\n\t\treturn (unary(np));\n\tcase '^':\n\t\trtok = relex();\n\t\treturn (unary(op2(CHAR, NIL, itonp(HAT))));\n\tcase '$':\n\t\trtok = relex();\n\t\treturn (unary(op2(CHAR, NIL, NIL)));\n\tcase '(':\n\t\tlastatom = starttok;\n\t\tsavelastatom = starttok - basestr; /* Retain over recursion */\n\t\trtok = relex();\n\t\tif (rtok == ')') {\t/* special pleading for () */\n\t\t\trtok = relex();\n\t\t\treturn unary(op2(CCL, NIL, (Node *) cclenter(\"\")));\n\t\t}\n\t\tnp = regexp();\n\t\tif (rtok == ')') {\n\t\t\tlastatom = basestr + savelastatom; /* Restore */\n\t\t\trtok = relex();\n\t\t\treturn (unary(np));\n\t\t}\n\t\telse\n\t\t\tFATAL(\"syntax error in regular expression %s at %s\", lastre, prestr);\n\tdefault:\n\t\tFATAL(\"illegal primary in regular expression %s at %s\", lastre, prestr);\n\t}\n\treturn 0;\t/*NOTREACHED*/\n}\n\nNode *concat(Node *np)\n{\n\tswitch (rtok) {\n\tcase CHAR: case DOT: case ALL: case CCL: case NCCL: case '$': case '(':\n\t\treturn (concat(op2(CAT, np, primary())));\n\tcase EMPTYRE:\n\t\trtok = relex();\n\t\treturn (concat(op2(CAT, op2(CCL, NIL, (Node *) cclenter(\"\")),\n\t\t\t\tprimary())));\n\t}\n\treturn (np);\n}\n\nNode *alt(Node *np)\n{\n\tif (rtok == OR) {\n\t\trtok = relex();\n\t\treturn (alt(op2(OR, np, concat(primary()))));\n\t}\n\treturn (np);\n}\n\nNode *unary(Node *np)\n{\n\tswitch (rtok) {\n\tcase STAR:\n\t\trtok = relex();\n\t\treturn (unary(op2(STAR, np, NIL)));\n\tcase PLUS:\n\t\trtok = relex();\n\t\treturn (unary(op2(PLUS, np, NIL)));\n\tcase QUEST:\n\t\trtok = relex();\n\t\treturn (unary(op2(QUEST, np, NIL)));\n\tcase ZERO:\n\t\trtok = relex();\n\t\treturn (unary(op2(ZERO, np, NIL)));\n\tdefault:\n\t\treturn (np);\n\t}\n}\n\n/*\n * Character class definitions conformant to the POSIX locale as\n * defined in IEEE P1003.1 draft 7 of June 2001, assuming the source\n * and operating character sets are both ASCII (ISO646) or supersets\n * thereof.\n *\n * Note that to avoid overflowing the temporary buffer used in\n * relex(), the expanded character class (prior to range expansion)\n * must be less than twice the size of their full name.\n */\n\n/* Because isblank doesn't show up in any of the header files on any\n * system i use, it's defined here.  if some other locale has a richer\n * definition of \"blank\", define HAS_ISBLANK and provide your own\n * version.\n * the parentheses here are an attempt to find a path through the maze\n * of macro definition and/or function and/or version provided.  thanks\n * to nelson beebe for the suggestion; let's see if it works everywhere.\n */\n\n/* #define HAS_ISBLANK */\n#ifndef HAS_ISBLANK\n\nint (xisblank)(int c)\n{\n\treturn c==' ' || c=='\\t';\n}\n\n#endif\n\nstatic const struct charclass {\n\tconst char *cc_name;\n\tint cc_namelen;\n\tint (*cc_func)(int);\n} charclasses[] = {\n\t{ \"alnum\",\t5,\tisalnum },\n\t{ \"alpha\",\t5,\tisalpha },\n#ifndef HAS_ISBLANK\n\t{ \"blank\",\t5,\txisblank },\n#else\n\t{ \"blank\",\t5,\tisblank },\n#endif\n\t{ \"cntrl\",\t5,\tiscntrl },\n\t{ \"digit\",\t5,\tisdigit },\n\t{ \"graph\",\t5,\tisgraph },\n\t{ \"lower\",\t5,\tislower },\n\t{ \"print\",\t5,\tisprint },\n\t{ \"punct\",\t5,\tispunct },\n\t{ \"space\",\t5,\tisspace },\n\t{ \"upper\",\t5,\tisupper },\n\t{ \"xdigit\",\t6,\tisxdigit },\n\t{ NULL,\t\t0,\tNULL },\n};\n\n#define REPEAT_SIMPLE\t\t0\n#define REPEAT_PLUS_APPENDED\t1\n#define REPEAT_WITH_Q\t\t2\n#define REPEAT_ZERO\t\t3\n\nstatic int\nreplace_repeat(const uschar *reptok, int reptoklen, const uschar *atom,\n\t       int atomlen, int firstnum, int secondnum, int special_case)\n{\n\tint i, j;\n\tuschar *buf = 0;\n\tint ret = 1;\n\tint init_q = (firstnum == 0);\t\t/* first added char will be ? */\n\tint n_q_reps = secondnum-firstnum;\t/* m>n, so reduce until {1,m-n} left  */\n\tint prefix_length = reptok - basestr;\t/* prefix includes first rep\t*/\n\tint suffix_length = strlen((const char *) reptok) - reptoklen;\t/* string after rep specifier\t*/\n\tint size = prefix_length +  suffix_length;\n\n\tif (firstnum > 1) {\t/* add room for reps 2 through firstnum */\n\t\tsize += atomlen*(firstnum-1);\n\t}\n\n\t/* Adjust size of buffer for special cases */\n\tif (special_case == REPEAT_PLUS_APPENDED) {\n\t\tsize++;\t\t/* for the final + */\n\t} else if (special_case == REPEAT_WITH_Q) {\n\t\tsize += init_q + (atomlen+1)* (n_q_reps-init_q);\n\t} else if (special_case == REPEAT_ZERO) {\n\t\tsize += 2;\t/* just a null ERE: () */\n\t}\n\tif ((buf = (uschar *) malloc(size + 1)) == NULL)\n\t\tFATAL(\"out of space in reg expr %.10s..\", lastre);\n\tmemcpy(buf, basestr, prefix_length);\t/* copy prefix\t*/\n\tj = prefix_length;\n\tif (special_case == REPEAT_ZERO) {\n\t\tj -= atomlen;\n\t\tbuf[j++] = '(';\n\t\tbuf[j++] = ')';\n\t}\n\tfor (i = 1; i < firstnum; i++) {\t/* copy x reps \t*/\n\t\tmemcpy(&buf[j], atom, atomlen);\n\t\tj += atomlen;\n\t}\n\tif (special_case == REPEAT_PLUS_APPENDED) {\n\t\tbuf[j++] = '+';\n\t} else if (special_case == REPEAT_WITH_Q) {\n\t\tif (init_q)\n\t\t\tbuf[j++] = '?';\n\t\tfor (i = init_q; i < n_q_reps; i++) {\t/* copy x? reps */\n\t\t\tmemcpy(&buf[j], atom, atomlen);\n\t\t\tj += atomlen;\n\t\t\tbuf[j++] = '?';\n\t\t}\n\t}\n\tmemcpy(&buf[j], reptok+reptoklen, suffix_length);\n\tj += suffix_length;\n\tbuf[j] = '\\0';\n\t/* free old basestr */\n\tif (firstbasestr != basestr) {\n\t\tif (basestr)\n\t\t\txfree(basestr);\n\t}\n\tbasestr = buf;\n\tprestr  = buf + prefix_length;\n\tif (special_case == REPEAT_ZERO) {\n\t\tprestr  -= atomlen;\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nstatic int repeat(const uschar *reptok, int reptoklen, const uschar *atom,\n\t\t  int atomlen, int firstnum, int secondnum)\n{\n\t/*\n\t   In general, the repetition specifier or \"bound\" is replaced here\n\t   by an equivalent ERE string, repeating the immediately previous atom\n\t   and appending ? and + as needed. Note that the first copy of the\n\t   atom is left in place, except in the special_case of a zero-repeat\n\t   (i.e., {0}).\n\t */\n\tif (secondnum < 0) {\t/* means {n,} -> repeat n-1 times followed by PLUS */\n\t\tif (firstnum < 2) {\n\t\t\t/* 0 or 1: should be handled before you get here */\n\t\t\tFATAL(\"internal error\");\n\t\t} else {\n\t\t\treturn replace_repeat(reptok, reptoklen, atom, atomlen,\n\t\t\t\tfirstnum, secondnum, REPEAT_PLUS_APPENDED);\n\t\t}\n\t} else if (firstnum == secondnum) {\t/* {n} or {n,n} -> simply repeat n-1 times */\n\t\tif (firstnum == 0) {\t/* {0} or {0,0} */\n\t\t\t/* This case is unusual because the resulting\n\t\t\t   replacement string might actually be SMALLER than\n\t\t\t   the original ERE */\n\t\t\treturn replace_repeat(reptok, reptoklen, atom, atomlen,\n\t\t\t\t\tfirstnum, secondnum, REPEAT_ZERO);\n\t\t} else {\t\t/* (firstnum >= 1) */\n\t\t\treturn replace_repeat(reptok, reptoklen, atom, atomlen,\n\t\t\t\t\tfirstnum, secondnum, REPEAT_SIMPLE);\n\t\t}\n\t} else if (firstnum < secondnum) {\t/* {n,m} -> repeat n-1 times then alternate  */\n\t\t/*  x{n,m}  =>  xx...x{1, m-n+1}  =>  xx...x?x?x?..x?\t*/\n\t\treturn replace_repeat(reptok, reptoklen, atom, atomlen,\n\t\t\t\t\tfirstnum, secondnum, REPEAT_WITH_Q);\n\t} else {\t/* Error - shouldn't be here (n>m) */\n\t\tFATAL(\"internal error\");\n\t}\n\treturn 0;\n}\n\nint relex(void)\t\t/* lexical analyzer for reparse */\n{\n\tint c, n;\n\tint cflag;\n\tstatic uschar *buf = NULL;\n\tstatic int bufsz = 100;\n\tuschar *bp;\n\tconst struct charclass *cc;\n\tint i;\n\tint num, m;\n\tbool commafound, digitfound;\n\tconst uschar *startreptok;\n\tstatic int parens = 0;\n\nrescan:\n\tstarttok = prestr;\n\n\tif ((n = u8_rune(&rlxval, (const char *) prestr)) > 1) {\n\t\tprestr += n;\n\t\tstarttok = prestr;\n\t\treturn CHAR;\n\t}\n\n\tswitch (c = *prestr++) {\n\tcase '|': return OR;\n\tcase '*': return STAR;\n\tcase '+': return PLUS;\n\tcase '?': return QUEST;\n\tcase '.': return DOT;\n\tcase '\\0': prestr--; return '\\0';\n\tcase '^':\n\tcase '$':\n\t\treturn c;\n\tcase '(':\n\t\tparens++;\n\t\treturn c;\n\tcase ')':\n\t\tif (parens) {\n\t\t\tparens--;\n\t\t\treturn c;\n\t\t}\n\t\t/* unmatched close parenthesis; per POSIX, treat as literal */\n\t\trlxval = c;\n\t\treturn CHAR;\n\tcase '\\\\':\n\t\trlxval = quoted(&prestr);\n\t\treturn CHAR;\n\tdefault:\n\t\trlxval = c;\n\t\treturn CHAR;\n\tcase '[':\n\t\tif (buf == NULL && (buf = (uschar *) malloc(bufsz)) == NULL)\n\t\t\tFATAL(\"out of space in reg expr %.10s..\", lastre);\n\t\tbp = buf;\n\t\tif (*prestr == '^') {\n\t\t\tcflag = 1;\n\t\t\tprestr++;\n\t\t}\n\t\telse\n\t\t\tcflag = 0;\n\t\tn = 5 * strlen((const char *) prestr)+1; /* BUG: was 2.  what value? */\n\t\tif (!adjbuf((char **) &buf, &bufsz, n, n, (char **) &bp, \"relex1\"))\n\t\t\tFATAL(\"out of space for reg expr %.10s...\", lastre);\n\t\tfor (; ; ) {\n\t\t\tif ((n = u8_rune(&rlxval, (const char *) prestr)) > 1) {\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t*bp++ = *prestr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((c = *prestr++) == '\\\\') {\n\t\t\t\t*bp++ = '\\\\';\n\t\t\t\tif ((c = *prestr++) == '\\0')\n\t\t\t\t\tFATAL(\"nonterminated character class %.20s...\", lastre);\n\t\t\t\t*bp++ = c;\n\t\t\t/* } else if (c == '\\n') { */\n\t\t\t/* \tFATAL(\"newline in character class %.20s...\", lastre); */\n\t\t\t} else if (c == '[' && *prestr == ':') {\n\t\t\t\t/* POSIX char class names, Dag-Erling Smorgrav, des@ofug.org */\n\t\t\t\tfor (cc = charclasses; cc->cc_name; cc++)\n\t\t\t\t\tif (strncmp((const char *) prestr + 1, (const char *) cc->cc_name, cc->cc_namelen) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (cc->cc_name != NULL && prestr[1 + cc->cc_namelen] == ':' &&\n\t\t\t\t    prestr[2 + cc->cc_namelen] == ']') {\n\t\t\t\t\tprestr += cc->cc_namelen + 3;\n\t\t\t\t\t/*\n\t\t\t\t\t * BUG: We begin at 1, instead of 0, since we\n\t\t\t\t\t * would otherwise prematurely terminate the\n\t\t\t\t\t * string for classes like [[:cntrl:]]. This\n\t\t\t\t\t * means that we can't match the NUL character,\n\t\t\t\t\t * not without first adapting the entire\n\t\t\t\t\t * program to track each string's length.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 1; i <= UCHAR_MAX; i++) {\n\t\t\t\t\t\tif (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, \"relex2\"))\n\t\t\t\t\t\t    FATAL(\"out of space for reg expr %.10s...\", lastre);\n\t\t\t\t\t\tif (cc->cc_func(i)) {\n\t\t\t\t\t\t\t/* escape backslash */\n\t\t\t\t\t\t\tif (i == '\\\\') {\n\t\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t*bp++ = i;\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\t*bp++ = c;\n\t\t\t} else if (c == '[' && *prestr == '.') {\n\t\t\t\tchar collate_char;\n\t\t\t\tprestr++;\n\t\t\t\tcollate_char = *prestr++;\n\t\t\t\tif (*prestr == '.' && prestr[1] == ']') {\n\t\t\t\t\tprestr += 2;\n\t\t\t\t\t/* Found it: map via locale TBD: for\n\t\t\t\t\t   now, simply return this char.  This\n\t\t\t\t\t   is sufficient to pass conformance\n\t\t\t\t\t   test awk.ex 156\n\t\t\t\t\t */\n\t\t\t\t\tif (*prestr == ']') {\n\t\t\t\t\t\tprestr++;\n\t\t\t\t\t\trlxval = collate_char;\n\t\t\t\t\t\treturn CHAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c == '[' && *prestr == '=') {\n\t\t\t\tchar equiv_char;\n\t\t\t\tprestr++;\n\t\t\t\tequiv_char = *prestr++;\n\t\t\t\tif (*prestr == '=' && prestr[1] == ']') {\n\t\t\t\t\tprestr += 2;\n\t\t\t\t\t/* Found it: map via locale TBD: for now\n\t\t\t\t\t   simply return this char. This is\n\t\t\t\t\t   sufficient to pass conformance test\n\t\t\t\t\t   awk.ex 156\n\t\t\t\t\t */\n\t\t\t\t\tif (*prestr == ']') {\n\t\t\t\t\t\tprestr++;\n\t\t\t\t\t\trlxval = equiv_char;\n\t\t\t\t\t\treturn CHAR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c == '\\0') {\n\t\t\t\tFATAL(\"nonterminated character class %.20s\", lastre);\n\t\t\t} else if (bp == buf) {\t/* 1st char is special */\n\t\t\t\t*bp++ = c;\n\t\t\t} else if (c == ']') {\n\t\t\t\t*bp++ = 0;\n\t\t\t\trlxstr = (uschar *) tostring((char *) buf);\n\t\t\t\tif (cflag == 0)\n\t\t\t\t\treturn CCL;\n\t\t\t\telse\n\t\t\t\t\treturn NCCL;\n\t\t\t} else\n\t\t\t\t*bp++ = c;\n\t\t}\n\t\tbreak;\n\tcase '{':\n\t\tif (isdigit((int) *(prestr))) {\n\t\t\tnum = 0;\t/* Process as a repetition */\n\t\t\tn = -1; m = -1;\n\t\t\tcommafound = false;\n\t\t\tdigitfound = false;\n\t\t\tstartreptok = prestr-1;\n\t\t\t/* Remember start of previous atom here ? */\n\t\t} else {        \t/* just a { char, not a repetition */\n\t\t\trlxval = c;\n\t\t\treturn CHAR;\n                }\n\t\tfor (; ; ) {\n\t\t\tif ((c = *prestr++) == '}') {\n\t\t\t\tif (commafound) {\n\t\t\t\t\tif (digitfound) { /* {n,m} */\n\t\t\t\t\t\tm = num;\n\t\t\t\t\t\tif (m < n)\n\t\t\t\t\t\t\tFATAL(\"illegal repetition expression: class %.20s\",\n\t\t\t\t\t\t\t\tlastre);\n\t\t\t\t\t\tif (n == 0 && m == 1) {\n\t\t\t\t\t\t\treturn QUEST;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t/* {n,} */\n\t\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\t\treturn STAR;\n\t\t\t\t\t\telse if (n == 1)\n\t\t\t\t\t\t\treturn PLUS;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (digitfound) { /* {n} same as {n,n} */\n\t\t\t\t\t\tn = num;\n\t\t\t\t\t\tm = num;\n\t\t\t\t\t} else {\t/* {} */\n\t\t\t\t\t\tFATAL(\"illegal repetition expression: class %.20s\",\n\t\t\t\t\t\t\tlastre);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (repeat(starttok, prestr-starttok, lastatom,\n\t\t\t\t\t   startreptok - lastatom, n, m) > 0) {\n\t\t\t\t\tif (n == 0 && m == 0) {\n\t\t\t\t\t\treturn ZERO;\n\t\t\t\t\t}\n\t\t\t\t\t/* must rescan input for next token */\n\t\t\t\t\tgoto rescan;\n\t\t\t\t}\n\t\t\t\t/* Failed to replace: eat up {...} characters\n\t\t\t\t   and treat like just PLUS */\n\t\t\t\treturn PLUS;\n\t\t\t} else if (c == '\\0') {\n\t\t\t\tFATAL(\"nonterminated character class %.20s\",\n\t\t\t\t\tlastre);\n\t\t\t} else if (isdigit(c)) {\n\t\t\t\tnum = 10 * num + c - '0';\n\t\t\t\tdigitfound = true;\n\t\t\t} else if (c == ',') {\n\t\t\t\tif (commafound)\n\t\t\t\t\tFATAL(\"illegal repetition expression: class %.20s\",\n\t\t\t\t\t\tlastre);\n\t\t\t\t/* looking for {n,} or {n,m} */\n\t\t\t\tcommafound = true;\n\t\t\t\tn = num;\n\t\t\t\tdigitfound = false; /* reset */\n\t\t\t\tnum = 0;\n\t\t\t} else {\n\t\t\t\tFATAL(\"illegal repetition expression: class %.20s\",\n\t\t\t\t\tlastre);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nint cgoto(fa *f, int s, int c)\n{\n\tint *p, *q;\n\tint i, j, k;\n\n\t/* assert(c == HAT || c < NCHARS);  BUG: seg fault if disable test */\n\twhile (f->accept >= maxsetvec) {\t/* guessing here! */\n\t\tresizesetvec(__func__);\n\t}\n\tfor (i = 0; i <= f->accept; i++)\n\t\tsetvec[i] = 0;\n\tsetcnt = 0;\n\tresize_state(f, s);\n\t/* compute positions of gototab[s,c] into setvec */\n\tp = f->posns[s];\n\tfor (i = 1; i <= *p; i++) {\n\t\tif ((k = f->re[p[i]].ltype) != FINAL) {\n\t\t\tif ((k == CHAR && c == ptoi(f->re[p[i]].lval.np))\n\t\t\t || (k == DOT && c != 0 && c != HAT)\n\t\t\t || (k == ALL && c != 0)\n\t\t\t || (k == EMPTYRE && c != 0)\n\t\t\t || (k == CCL && member(c, (int *) f->re[p[i]].lval.rp))\n\t\t\t || (k == NCCL && !member(c, (int *) f->re[p[i]].lval.rp) && c != 0 && c != HAT)) {\n\t\t\t\tq = f->re[p[i]].lfollow;\n\t\t\t\tfor (j = 1; j <= *q; j++) {\n\t\t\t\t\tif (q[j] >= maxsetvec) {\n\t\t\t\t\t\tresizesetvec(__func__);\n\t\t\t\t\t}\n\t\t\t\t\tif (setvec[q[j]] == 0) {\n\t\t\t\t\t\tsetcnt++;\n\t\t\t\t\t\tsetvec[q[j]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* determine if setvec is a previous state */\n\ttmpset[0] = setcnt;\n\tj = 1;\n\tfor (i = f->accept; i >= 0; i--)\n\t\tif (setvec[i]) {\n\t\t\ttmpset[j++] = i;\n\t\t}\n\tresize_state(f, f->curstat > s ? f->curstat : s);\n\t/* tmpset == previous state? */\n\tfor (i = 1; i <= f->curstat; i++) {\n\t\tp = f->posns[i];\n\t\tif ((k = tmpset[0]) != p[0])\n\t\t\tgoto different;\n\t\tfor (j = 1; j <= k; j++)\n\t\t\tif (tmpset[j] != p[j])\n\t\t\t\tgoto different;\n\t\t/* setvec is state i */\n\t\tif (c != HAT)\n\t\t\tset_gototab(f, s, c, i);\n\t\treturn i;\n\t  different:;\n\t}\n\n\t/* add tmpset to current set of states */\n\t++(f->curstat);\n\tresize_state(f, f->curstat);\n\tclear_gototab(f, f->curstat);\n\txfree(f->posns[f->curstat]);\n\tp = intalloc(setcnt + 1, __func__);\n\n\tf->posns[f->curstat] = p;\n\tif (c != HAT)\n\t\tset_gototab(f, s, c, f->curstat);\n\tfor (i = 0; i <= setcnt; i++)\n\t\tp[i] = tmpset[i];\n\tif (setvec[f->accept])\n\t\tf->out[f->curstat] = 1;\n\telse\n\t\tf->out[f->curstat] = 0;\n\treturn f->curstat;\n}\n\n\nvoid freefa(fa *f)\t/* free a finite automaton */\n{\n\tint i;\n\n\tif (f == NULL)\n\t\treturn;\n\tfor (i = 0; i < f->state_count; i++)\n\t\txfree(f->gototab[i].entries);\n\txfree(f->gototab);\n\tfor (i = 0; i <= f->curstat; i++)\n\t\txfree(f->posns[i]);\n\tfor (i = 0; i <= f->accept; i++) {\n\t\txfree(f->re[i].lfollow);\n\t\tif (f->re[i].ltype == CCL || f->re[i].ltype == NCCL)\n\t\t\txfree(f->re[i].lval.np);\n\t}\n\txfree(f->restr);\n\txfree(f->out);\n\txfree(f->posns);\n\txfree(f->gototab);\n\txfree(f);\n}\n"
        },
        {
          "name": "bugs-fixed",
          "type": "tree",
          "content": null
        },
        {
          "name": "lex.c",
          "type": "blob",
          "size": 13.619140625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"awk.h\"\n#include \"awkgram.tab.h\"\n\nextern YYSTYPE\tyylval;\nextern bool\tinfunc;\n\nint\tlineno\t= 1;\nint\tbracecnt = 0;\nint\tbrackcnt  = 0;\nint\tparencnt = 0;\n\ntypedef struct Keyword {\n\tconst char *word;\n\tint\tsub;\n\tint\ttype;\n} Keyword;\n\nconst Keyword keywords[] = {\t/* keep sorted: binary searched */\n\t{ \"BEGIN\",\tXBEGIN,\t\tXBEGIN },\n\t{ \"END\",\tXEND,\t\tXEND },\n\t{ \"NF\",\t\tVARNF,\t\tVARNF },\n\t{ \"atan2\",\tFATAN,\t\tBLTIN },\n\t{ \"break\",\tBREAK,\t\tBREAK },\n\t{ \"close\",\tCLOSE,\t\tCLOSE },\n\t{ \"continue\",\tCONTINUE,\tCONTINUE },\n\t{ \"cos\",\tFCOS,\t\tBLTIN },\n\t{ \"delete\",\tDELETE,\t\tDELETE },\n\t{ \"do\",\t\tDO,\t\tDO },\n\t{ \"else\",\tELSE,\t\tELSE },\n\t{ \"exit\",\tEXIT,\t\tEXIT },\n\t{ \"exp\",\tFEXP,\t\tBLTIN },\n\t{ \"fflush\",\tFFLUSH,\t\tBLTIN },\n\t{ \"for\",\tFOR,\t\tFOR },\n\t{ \"func\",\tFUNC,\t\tFUNC },\n\t{ \"function\",\tFUNC,\t\tFUNC },\n\t{ \"getline\",\tGETLINE,\tGETLINE },\n\t{ \"gsub\",\tGSUB,\t\tGSUB },\n\t{ \"if\",\t\tIF,\t\tIF },\n\t{ \"in\",\t\tIN,\t\tIN },\n\t{ \"index\",\tINDEX,\t\tINDEX },\n\t{ \"int\",\tFINT,\t\tBLTIN },\n\t{ \"length\",\tFLENGTH,\tBLTIN },\n\t{ \"log\",\tFLOG,\t\tBLTIN },\n\t{ \"match\",\tMATCHFCN,\tMATCHFCN },\n\t{ \"next\",\tNEXT,\t\tNEXT },\n\t{ \"nextfile\",\tNEXTFILE,\tNEXTFILE },\n\t{ \"print\",\tPRINT,\t\tPRINT },\n\t{ \"printf\",\tPRINTF,\t\tPRINTF },\n\t{ \"rand\",\tFRAND,\t\tBLTIN },\n\t{ \"return\",\tRETURN,\t\tRETURN },\n\t{ \"sin\",\tFSIN,\t\tBLTIN },\n\t{ \"split\",\tSPLIT,\t\tSPLIT },\n\t{ \"sprintf\",\tSPRINTF,\tSPRINTF },\n\t{ \"sqrt\",\tFSQRT,\t\tBLTIN },\n\t{ \"srand\",\tFSRAND,\t\tBLTIN },\n\t{ \"sub\",\tSUB,\t\tSUB },\n\t{ \"substr\",\tSUBSTR,\t\tSUBSTR },\n\t{ \"system\",\tFSYSTEM,\tBLTIN },\n\t{ \"tolower\",\tFTOLOWER,\tBLTIN },\n\t{ \"toupper\",\tFTOUPPER,\tBLTIN },\n\t{ \"while\",\tWHILE,\t\tWHILE },\n};\n\n#define\tRET(x)\t{ if(dbg)printf(\"lex %s\\n\", tokname(x)); return(x); }\n\nstatic int peek(void)\n{\n\tint c = input();\n\tunput(c);\n\treturn c;\n}\n\nstatic int gettok(char **pbuf, int *psz)\t/* get next input token */\n{\n\tint c, retc;\n\tchar *buf = *pbuf;\n\tint sz = *psz;\n\tchar *bp = buf;\n\n\tc = input();\n\tif (c == 0)\n\t\treturn 0;\n\tbuf[0] = c;\n\tbuf[1] = 0;\n\tif (!isalnum(c) && c != '.' && c != '_')\n\t\treturn c;\n\n\t*bp++ = c;\n\tif (isalpha(c) || c == '_') {\t/* it's a varname */\n\t\tfor ( ; (c = input()) != 0; ) {\n\t\t\tif (bp-buf >= sz)\n\t\t\t\tif (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, \"gettok\"))\n\t\t\t\t\tFATAL( \"out of space for name %.10s...\", buf );\n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\t*bp++ = c;\n\t\t\telse {\n\t\t\t\t*bp = 0;\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*bp = 0;\n\t\tretc = 'a';\t/* alphanumeric */\n\t} else {\t/* maybe it's a number, but could be . */\n\t\tchar *rem;\n\t\t/* read input until can't be a number */\n\t\tfor ( ; (c = input()) != 0; ) {\n\t\t\tif (bp-buf >= sz)\n\t\t\t\tif (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, \"gettok\"))\n\t\t\t\t\tFATAL( \"out of space for number %.10s...\", buf );\n\t\t\tif (isdigit(c) || c == 'e' || c == 'E'\n\t\t\t  || c == '.' || c == '+' || c == '-')\n\t\t\t\t*bp++ = c;\n\t\t\telse {\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*bp = 0;\n\t\tstrtod(buf, &rem);\t/* parse the number */\n\t\tif (rem == buf) {\t/* it wasn't a valid number at all */\n\t\t\tbuf[1] = 0;\t/* return one character as token */\n\t\t\tretc = (uschar)buf[0];\t/* character is its own type */\n\t\t\tunputstr(rem+1); /* put rest back for later */\n\t\t} else {\t/* some prefix was a number */\n\t\t\tunputstr(rem);\t/* put rest back for later */\n\t\t\trem[0] = 0;\t/* truncate buf after number part */\n\t\t\tretc = '0';\t/* type is number */\n\t\t}\n\t}\n\t*pbuf = buf;\n\t*psz = sz;\n\treturn retc;\n}\n\nint\tword(char *);\nint\tstring(void);\nint\tregexpr(void);\nbool\tsc\t= false;\t/* true => return a } right now */\nbool\treg\t= false;\t/* true => return a REGEXPR now */\n\nint yylex(void)\n{\n\tint c;\n\tstatic char *buf = NULL;\n\tstatic int bufsize = 5; /* BUG: setting this small causes core dump! */\n\n\tif (buf == NULL && (buf = (char *) malloc(bufsize)) == NULL)\n\t\tFATAL( \"out of space in yylex\" );\n\tif (sc) {\n\t\tsc = false;\n\t\tRET('}');\n\t}\n\tif (reg) {\n\t\treg = false;\n\t\treturn regexpr();\n\t}\n\tfor (;;) {\n\t\tc = gettok(&buf, &bufsize);\n\t\tif (c == 0)\n\t\t\treturn 0;\n\t\tif (isalpha(c) || c == '_')\n\t\t\treturn word(buf);\n\t\tif (isdigit(c)) {\n\t\t\tchar *cp = tostring(buf);\n\t\t\tdouble result;\n\n\t\t\tif (is_number(cp, & result))\n\t\t\t\tyylval.cp = setsymtab(buf, cp, result, CON|NUM, symtab);\n\t\t\telse\n\t\t\t\tyylval.cp = setsymtab(buf, cp, 0.0, STR, symtab);\n\t\t\tfree(cp);\n\t\t\t/* should this also have STR set? */\n\t\t\tRET(NUMBER);\n\t\t}\n\n\t\tyylval.i = c;\n\t\tswitch (c) {\n\t\tcase '\\n':\t/* {EOL} */\n\t\t\tlineno++;\n\t\t\tRET(NL);\n\t\tcase '\\r':\t/* assume \\n is coming */\n\t\tcase ' ':\t/* {WS}+ */\n\t\tcase '\\t':\n\t\t\tbreak;\n\t\tcase '#':\t/* #.* strip comments */\n\t\t\twhile ((c = input()) != '\\n' && c != 0)\n\t\t\t\t;\n\t\t\tunput(c);\n\t\t\t/*\n\t\t\t * Next line is a hack, it compensates for\n\t\t\t * unput's treatment of \\n.\n\t\t\t */\n\t\t\tlineno++;\n\t\t\tbreak;\n\t\tcase ';':\n\t\t\tRET(';');\n\t\tcase '\\\\':\n\t\t\tif (peek() == '\\n') {\n\t\t\t\tinput();\n\t\t\t\tlineno++;\n\t\t\t} else if (peek() == '\\r') {\n\t\t\t\tinput(); input();\t/* \\n */\n\t\t\t\tlineno++;\n\t\t\t} else {\n\t\t\t\tRET(c);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tif (peek() == '&') {\n\t\t\t\tinput(); RET(AND);\n\t\t\t} else\n\t\t\t\tRET('&');\n\t\tcase '|':\n\t\t\tif (peek() == '|') {\n\t\t\t\tinput(); RET(BOR);\n\t\t\t} else\n\t\t\t\tRET('|');\n\t\tcase '!':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = NE; RET(NE);\n\t\t\t} else if (peek() == '~') {\n\t\t\t\tinput(); yylval.i = NOTMATCH; RET(MATCHOP);\n\t\t\t} else\n\t\t\t\tRET(NOT);\n\t\tcase '~':\n\t\t\tyylval.i = MATCH;\n\t\t\tRET(MATCHOP);\n\t\tcase '<':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = LE; RET(LE);\n\t\t\t} else {\n\t\t\t\tyylval.i = LT; RET(LT);\n\t\t\t}\n\t\tcase '=':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = EQ; RET(EQ);\n\t\t\t} else {\n\t\t\t\tyylval.i = ASSIGN; RET(ASGNOP);\n\t\t\t}\n\t\tcase '>':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = GE; RET(GE);\n\t\t\t} else if (peek() == '>') {\n\t\t\t\tinput(); yylval.i = APPEND; RET(APPEND);\n\t\t\t} else {\n\t\t\t\tyylval.i = GT; RET(GT);\n\t\t\t}\n\t\tcase '+':\n\t\t\tif (peek() == '+') {\n\t\t\t\tinput(); yylval.i = INCR; RET(INCR);\n\t\t\t} else if (peek() == '=') {\n\t\t\t\tinput(); yylval.i = ADDEQ; RET(ASGNOP);\n\t\t\t} else\n\t\t\t\tRET('+');\n\t\tcase '-':\n\t\t\tif (peek() == '-') {\n\t\t\t\tinput(); yylval.i = DECR; RET(DECR);\n\t\t\t} else if (peek() == '=') {\n\t\t\t\tinput(); yylval.i = SUBEQ; RET(ASGNOP);\n\t\t\t} else\n\t\t\t\tRET('-');\n\t\tcase '*':\n\t\t\tif (peek() == '=') {\t/* *= */\n\t\t\t\tinput(); yylval.i = MULTEQ; RET(ASGNOP);\n\t\t\t} else if (peek() == '*') {\t/* ** or **= */\n\t\t\t\tinput();\t/* eat 2nd * */\n\t\t\t\tif (peek() == '=') {\n\t\t\t\t\tinput(); yylval.i = POWEQ; RET(ASGNOP);\n\t\t\t\t} else {\n\t\t\t\t\tRET(POWER);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tRET('*');\n\t\tcase '/':\n\t\t\tRET('/');\n\t\tcase '%':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = MODEQ; RET(ASGNOP);\n\t\t\t} else\n\t\t\t\tRET('%');\n\t\tcase '^':\n\t\t\tif (peek() == '=') {\n\t\t\t\tinput(); yylval.i = POWEQ; RET(ASGNOP);\n\t\t\t} else\n\t\t\t\tRET(POWER);\n\n\t\tcase '$':\n\t\t\t/* BUG: awkward, if not wrong */\n\t\t\tc = gettok(&buf, &bufsize);\n\t\t\tif (isalpha(c)) {\n\t\t\t\tif (strcmp(buf, \"NF\") == 0) {\t/* very special */\n\t\t\t\t\tunputstr(\"(NF)\");\n\t\t\t\t\tRET(INDIRECT);\n\t\t\t\t}\n\t\t\t\tc = peek();\n\t\t\t\tif (c == '(' || c == '[' || (infunc && isarg(buf) >= 0)) {\n\t\t\t\t\tunputstr(buf);\n\t\t\t\t\tRET(INDIRECT);\n\t\t\t\t}\n\t\t\t\tyylval.cp = setsymtab(buf, \"\", 0.0, STR|NUM, symtab);\n\t\t\t\tRET(IVAR);\n\t\t\t} else if (c == 0) {\t/*  */\n\t\t\t\tSYNTAX( \"unexpected end of input after $\" );\n\t\t\t\tRET(';');\n\t\t\t} else {\n\t\t\t\tunputstr(buf);\n\t\t\t\tRET(INDIRECT);\n\t\t\t}\n\n\t\tcase '}':\n\t\t\tif (--bracecnt < 0)\n\t\t\t\tSYNTAX( \"extra }\" );\n\t\t\tsc = true;\n\t\t\tRET(';');\n\t\tcase ']':\n\t\t\tif (--brackcnt < 0)\n\t\t\t\tSYNTAX( \"extra ]\" );\n\t\t\tRET(']');\n\t\tcase ')':\n\t\t\tif (--parencnt < 0)\n\t\t\t\tSYNTAX( \"extra )\" );\n\t\t\tRET(')');\n\t\tcase '{':\n\t\t\tbracecnt++;\n\t\t\tRET('{');\n\t\tcase '[':\n\t\t\tbrackcnt++;\n\t\t\tRET('[');\n\t\tcase '(':\n\t\t\tparencnt++;\n\t\t\tRET('(');\n\n\t\tcase '\"':\n\t\t\treturn string();\t/* BUG: should be like tran.c ? */\n\n\t\tdefault:\n\t\t\tRET(c);\n\t\t}\n\t}\n}\n\nextern int runetochar(char *str, int c);\n\nint string(void)\n{\n\tint c, n;\n\tchar *s, *bp;\n\tstatic char *buf = NULL;\n\tstatic int bufsz = 500;\n\n\tif (buf == NULL && (buf = (char *) malloc(bufsz)) == NULL)\n\t\tFATAL(\"out of space for strings\");\n\tfor (bp = buf; (c = input()) != '\"'; ) {\n\t\tif (!adjbuf(&buf, &bufsz, bp-buf+2, 500, &bp, \"string\"))\n\t\t\tFATAL(\"out of space for string %.10s...\", buf);\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase 0:\n\t\t\t*bp = '\\0';\n\t\t\tSYNTAX( \"non-terminated string %.10s...\", buf );\n\t\t\tif (c == 0)\t/* hopeless */\n\t\t\t\tFATAL( \"giving up\" );\n\t\t\tlineno++;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tc = input();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n': break;\n\t\t\tcase '\"': *bp++ = '\"'; break;\n\t\t\tcase 'n': *bp++ = '\\n'; break;\n\t\t\tcase 't': *bp++ = '\\t'; break;\n\t\t\tcase 'f': *bp++ = '\\f'; break;\n\t\t\tcase 'r': *bp++ = '\\r'; break;\n\t\t\tcase 'b': *bp++ = '\\b'; break;\n\t\t\tcase 'v': *bp++ = '\\v'; break;\n\t\t\tcase 'a': *bp++ = '\\a'; break;\n\t\t\tcase '\\\\': *bp++ = '\\\\'; break;\n\n\t\t\tcase '0': case '1': case '2': /* octal: \\d \\dd \\ddd */\n\t\t\tcase '3': case '4': case '5': case '6': case '7':\n\t\t\t\tn = c - '0';\n\t\t\t\tif ((c = peek()) >= '0' && c < '8') {\n\t\t\t\t\tn = 8 * n + input() - '0';\n\t\t\t\t\tif ((c = peek()) >= '0' && c < '8')\n\t\t\t\t\t\tn = 8 * n + input() - '0';\n\t\t\t\t}\n\t\t\t\t*bp++ = n;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\t/* hex  \\x0-9a-fA-F (exactly two) */\n\t\t\t    {\n\t\t\t\tint i;\n\n\t\t\t\tif (!isxdigit(peek())) {\n\t\t\t\t\tunput(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn = 0;\n\t\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t\tc = input();\n\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (isxdigit(c)) {\n\t\t\t\t\t\tc = tolower(c);\n\t\t\t\t\t\tn *= 16;\n\t\t\t\t\t\tif (isdigit(c))\n\t\t\t\t\t\t\tn += (c - '0');\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn += 10 + (c - 'a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunput(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i)\n\t\t\t\t\t*bp++ = n;\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tcase 'u':\t/* utf  \\u0-9a-fA-F (1..8) */\n\t\t\t    {\n\t\t\t\tint i;\n\n\t\t\t\tn = 0;\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tc = input();\n\t\t\t\t\tif (!isxdigit(c) || c == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tc = tolower(c);\n\t\t\t\t\tn *= 16;\n\t\t\t\t\tif (isdigit(c))\n\t\t\t\t\t\tn += (c - '0');\n\t\t\t\t\telse\n\t\t\t\t\t\tn += 10 + (c - 'a');\n\t\t\t\t}\n\t\t\t\tunput(c);\n\t\t\t\tbp += runetochar(bp, n);\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tdefault:\n\t\t\t\t*bp++ = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bp++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bp = 0;\n\ts = tostring(buf);\n\t*bp++ = ' '; *bp++ = '\\0';\n\tyylval.cp = setsymtab(buf, s, 0.0, CON|STR|DONTFREE, symtab);\n\tfree(s);\n\tRET(STRING);\n}\n\n\nstatic int binsearch(char *w, const Keyword *kp, int n)\n{\n\tint cond, low, mid, high;\n\n\tlow = 0;\n\thigh = n - 1;\n\twhile (low <= high) {\n\t\tmid = (low + high) / 2;\n\t\tif ((cond = strcmp(w, kp[mid].word)) < 0)\n\t\t\thigh = mid - 1;\n\t\telse if (cond > 0)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\treturn mid;\n\t}\n\treturn -1;\n}\n\nint word(char *w)\n{\n\tconst Keyword *kp;\n\tint c, n;\n\n\tn = binsearch(w, keywords, sizeof(keywords)/sizeof(keywords[0]));\n\tif (n != -1) {\t/* found in table */\n\t\tkp = keywords + n;\n\t\tyylval.i = kp->sub;\n\t\tswitch (kp->type) {\t/* special handling */\n\t\tcase BLTIN:\n\t\t\tif (kp->sub == FSYSTEM && safe)\n\t\t\t\tSYNTAX( \"system is unsafe\" );\n\t\t\tRET(kp->type);\n\t\tcase FUNC:\n\t\t\tif (infunc)\n\t\t\t\tSYNTAX( \"illegal nested function\" );\n\t\t\tRET(kp->type);\n\t\tcase RETURN:\n\t\t\tif (!infunc)\n\t\t\t\tSYNTAX( \"return not in function\" );\n\t\t\tRET(kp->type);\n\t\tcase VARNF:\n\t\t\tyylval.cp = setsymtab(\"NF\", \"\", 0.0, NUM, symtab);\n\t\t\tRET(VARNF);\n\t\tdefault:\n\t\t\tRET(kp->type);\n\t\t}\n\t}\n\tc = peek();\t/* look for '(' */\n\tif (c != '(' && infunc && (n=isarg(w)) >= 0) {\n\t\tyylval.i = n;\n\t\tRET(ARG);\n\t} else {\n\t\tyylval.cp = setsymtab(w, \"\", 0.0, STR|NUM|DONTFREE, symtab);\n\t\tif (c == '(') {\n\t\t\tRET(CALL);\n\t\t} else {\n\t\t\tRET(VAR);\n\t\t}\n\t}\n}\n\nvoid startreg(void)\t/* next call to yylex will return a regular expression */\n{\n\treg = true;\n}\n\nint regexpr(void)\n{\n\tint c;\n\tstatic char *buf = NULL;\n\tstatic int bufsz = 500;\n\tchar *bp;\n\n\tif (buf == NULL && (buf = (char *) malloc(bufsz)) == NULL)\n\t\tFATAL(\"out of space for reg expr\");\n\tbp = buf;\n\tfor ( ; (c = input()) != '/' && c != 0; ) {\n\t\tif (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, \"regexpr\"))\n\t\t\tFATAL(\"out of space for reg expr %.10s...\", buf);\n\t\tif (c == '\\n') {\n\t\t\t*bp = '\\0';\n\t\t\tSYNTAX( \"newline in regular expression %.10s...\", buf );\n\t\t\tunput('\\n');\n\t\t\tbreak;\n\t\t} else if (c == '\\\\') {\n\t\t\t*bp++ = '\\\\';\n\t\t\t*bp++ = input();\n\t\t} else {\n\t\t\t*bp++ = c;\n\t\t}\n\t}\n\t*bp = 0;\n\tif (c == 0)\n\t\tSYNTAX(\"non-terminated regular expression %.10s...\", buf);\n\tyylval.s = tostring(buf);\n\tunput('/');\n\tRET(REGEXPR);\n}\n\n/* low-level lexical stuff, sort of inherited from lex */\n\nchar\tebuf[300];\nchar\t*ep = ebuf;\nchar\tyysbuf[100];\t/* pushback buffer */\nchar\t*yysptr = yysbuf;\nFILE\t*yyin = NULL;\n\nint input(void)\t/* get next lexical input character */\n{\n\tint c;\n\textern char *lexprog;\n\n\tif (yysptr > yysbuf)\n\t\tc = (uschar)*--yysptr;\n\telse if (lexprog != NULL) {\t/* awk '...' */\n\t\tif ((c = (uschar)*lexprog) != 0)\n\t\t\tlexprog++;\n\t} else\t\t\t\t/* awk -f ... */\n\t\tc = pgetc();\n\tif (c == EOF)\n\t\tc = 0;\n\tif (ep >= ebuf + sizeof ebuf)\n\t\tep = ebuf;\n\t*ep = c;\n\tif (c != 0) {\n\t\tep++;\n\t}\n\treturn (c);\n}\n\nvoid unput(int c)\t/* put lexical character back on input */\n{\n\tif (c == '\\n')  \n\t\tlineno--;\n\tif (yysptr >= yysbuf + sizeof(yysbuf))\n\t\tFATAL(\"pushed back too much: %.20s...\", yysbuf);\n\t*yysptr++ = c;\n\tif (--ep < ebuf)\n\t\tep = ebuf + sizeof(ebuf) - 1;\n}\n\nvoid unputstr(const char *s)\t/* put a string back on input */\n{\n\tint i;\n\n\tfor (i = strlen(s)-1; i >= 0; i--)\n\t\tunput(s[i]);\n}\n"
        },
        {
          "name": "lib.c",
          "type": "blob",
          "size": 22.5966796875,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#define DEBUG\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <math.h>\n#include \"awk.h\"\n\nextern int u8_nextlen(const char *s);\n\nchar\tEMPTY[] = { '\\0' };\nFILE\t*infile\t= NULL;\nbool\tinnew;\t\t/* true = infile has not been read by readrec */\nchar\t*file\t= EMPTY;\nchar\t*record;\nint\trecsize\t= RECSIZE;\nchar\t*fields;\nint\tfieldssize = RECSIZE;\n\nCell\t**fldtab;\t/* pointers to Cells */\nstatic size_t\tlen_inputFS = 0;\nstatic char\t*inputFS = NULL; /* FS at time of input, for field splitting */\n\n#define\tMAXFLD\t2\nint\tnfields\t= MAXFLD;\t/* last allocated slot for $i */\n\nbool\tdonefld;\t/* true = implies rec broken into fields */\nbool\tdonerec;\t/* true = record is valid (no flds have changed) */\n\nint\tlastfld\t= 0;\t/* last used field */\nint\targno\t= 1;\t/* current input argument number */\nextern\tAwkfloat *ARGC;\n\nstatic Cell dollar0 = { OCELL, CFLD, NULL, EMPTY, 0.0, REC|STR|DONTFREE, NULL, NULL };\nstatic Cell dollar1 = { OCELL, CFLD, NULL, EMPTY, 0.0, FLD|STR|DONTFREE, NULL, NULL };\n\nvoid recinit(unsigned int n)\n{\n\tif ( (record = (char *) malloc(n)) == NULL\n\t  || (fields = (char *) malloc(n+1)) == NULL\n\t  || (fldtab = (Cell **) calloc(nfields+2, sizeof(*fldtab))) == NULL\n\t  || (fldtab[0] = (Cell *) malloc(sizeof(**fldtab))) == NULL)\n\t\tFATAL(\"out of space for $0 and fields\");\n\t*record = '\\0';\n\t*fldtab[0] = dollar0;\n\tfldtab[0]->sval = record;\n\tfldtab[0]->nval = tostring(\"0\");\n\tmakefields(1, nfields);\n}\n\nvoid makefields(int n1, int n2)\t\t/* create $n1..$n2 inclusive */\n{\n\tchar temp[50];\n\tint i;\n\n\tfor (i = n1; i <= n2; i++) {\n\t\tfldtab[i] = (Cell *) malloc(sizeof(**fldtab));\n\t\tif (fldtab[i] == NULL)\n\t\t\tFATAL(\"out of space in makefields %d\", i);\n\t\t*fldtab[i] = dollar1;\n\t\tsnprintf(temp, sizeof(temp), \"%d\", i);\n\t\tfldtab[i]->nval = tostring(temp);\n\t}\n}\n\nvoid initgetrec(void)\n{\n\tint i;\n\tchar *p;\n\n\tfor (i = 1; i < *ARGC; i++) {\n\t\tp = getargv(i); /* find 1st real filename */\n\t\tif (p == NULL || *p == '\\0') {  /* deleted or zapped */\n\t\t\targno++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isclvar(p)) {\n\t\t\tsetsval(lookup(\"FILENAME\", symtab), p);\n\t\t\treturn;\n\t\t}\n\t\tsetclvar(p);\t/* a commandline assignment before filename */\n\t\targno++;\n\t}\n\tinfile = stdin;\t\t/* no filenames, so use stdin */\n\tinnew = true;\n}\n\n/*\n * POSIX specifies that fields are supposed to be evaluated as if they were\n * split using the value of FS at the time that the record's value ($0) was\n * read.\n *\n * Since field-splitting is done lazily, we save the current value of FS\n * whenever a new record is read in (implicitly or via getline), or when\n * a new value is assigned to $0.\n */\nvoid savefs(void)\n{\n\tsize_t len;\n\tif ((len = strlen(getsval(fsloc))) < len_inputFS) {\n\t\tstrcpy(inputFS, *FS);\t/* for subsequent field splitting */\n\t\treturn;\n\t}\n\n\tlen_inputFS = len + 1;\n\tinputFS = (char *) realloc(inputFS, len_inputFS);\n\tif (inputFS == NULL)\n\t\tFATAL(\"field separator %.10s... is too long\", *FS);\n\tmemcpy(inputFS, *FS, len_inputFS);\n}\n\nstatic bool firsttime = true;\n\nint getrec(char **pbuf, int *pbufsize, bool isrecord)\t/* get next input record */\n{\t\t\t/* note: cares whether buf == record */\n\tint c;\n\tchar *buf = *pbuf;\n\tuschar saveb0;\n\tint bufsize = *pbufsize, savebufsize = bufsize;\n\n\tif (firsttime) {\n\t\tfirsttime = false;\n\t\tinitgetrec();\n\t}\n\tDPRINTF(\"RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\\n\",\n\t\t*RS, *FS, *ARGC, *FILENAME);\n\tsaveb0 = buf[0];\n\tbuf[0] = 0;\n\twhile (argno < *ARGC || infile == stdin) {\n\t\tDPRINTF(\"argno=%d, file=|%s|\\n\", argno, file);\n\t\tif (infile == NULL) {\t/* have to open a new file */\n\t\t\tfile = getargv(argno);\n\t\t\tif (file == NULL || *file == '\\0') {\t/* deleted or zapped */\n\t\t\t\targno++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isclvar(file)) {\t/* a var=value arg */\n\t\t\t\tsetclvar(file);\n\t\t\t\targno++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*FILENAME = file;\n\t\t\tDPRINTF(\"opening file %s\\n\", file);\n\t\t\tif (*file == '-' && *(file+1) == '\\0')\n\t\t\t\tinfile = stdin;\n\t\t\telse if ((infile = fopen(file, \"r\")) == NULL)\n\t\t\t\tFATAL(\"can't open file %s\", file);\n\t\t\tinnew = true;\n\t\t\tsetfval(fnrloc, 0.0);\n\t\t}\n\t\tc = readrec(&buf, &bufsize, infile, innew);\n\t\tif (innew)\n\t\t\tinnew = false;\n\t\tif (c != 0 || buf[0] != '\\0') {\t/* normal record */\n\t\t\tif (isrecord) {\n\t\t\t\tdouble result;\n\n\t\t\t\tif (freeable(fldtab[0]))\n\t\t\t\t\txfree(fldtab[0]->sval);\n\t\t\t\tfldtab[0]->sval = buf;\t/* buf == record */\n\t\t\t\tfldtab[0]->tval = REC | STR | DONTFREE;\n\t\t\t\tif (is_number(fldtab[0]->sval, & result)) {\n\t\t\t\t\tfldtab[0]->fval = result;\n\t\t\t\t\tfldtab[0]->tval |= NUM;\n\t\t\t\t}\n\t\t\t\tdonefld = false;\n\t\t\t\tdonerec = true;\n\t\t\t\tsavefs();\n\t\t\t}\n\t\t\tsetfval(nrloc, nrloc->fval+1);\n\t\t\tsetfval(fnrloc, fnrloc->fval+1);\n\t\t\t*pbuf = buf;\n\t\t\t*pbufsize = bufsize;\n\t\t\treturn 1;\n\t\t}\n\t\t/* EOF arrived on this file; set up next */\n\t\tif (infile != stdin)\n\t\t\tfclose(infile);\n\t\tinfile = NULL;\n\t\targno++;\n\t}\n\tbuf[0] = saveb0;\n\t*pbuf = buf;\n\t*pbufsize = savebufsize;\n\treturn 0;\t/* true end of file */\n}\n\nvoid nextfile(void)\n{\n\tif (infile != NULL && infile != stdin)\n\t\tfclose(infile);\n\tinfile = NULL;\n\targno++;\n}\n\nextern int readcsvrec(char **pbuf, int *pbufsize, FILE *inf, bool newflag);\n\nint readrec(char **pbuf, int *pbufsize, FILE *inf, bool newflag)\t/* read one record into buf */\n{\n\tint sep, c, isrec; // POTENTIAL BUG? isrec is a macro in awk.h\n\tchar *rr = *pbuf, *buf = *pbuf;\n\tint bufsize = *pbufsize;\n\tchar *rs = getsval(rsloc);\n\n\tif (CSV) {\n\t\tc = readcsvrec(&buf, &bufsize, inf, newflag);\n\t\tisrec = (c == EOF && rr == buf) ? false : true;\n\t} else if (*rs && rs[1]) {\n\t\tbool found;\n\n\t\tmemset(buf, 0, bufsize);\n\t\tfa *pfa = makedfa(rs, 1);\n\t\tif (newflag)\n\t\t\tfound = fnematch(pfa, inf, &buf, &bufsize, recsize);\n\t\telse {\n\t\t\tint tempstat = pfa->initstat;\n\t\t\tpfa->initstat = 2;\n\t\t\tfound = fnematch(pfa, inf, &buf, &bufsize, recsize);\n\t\t\tpfa->initstat = tempstat;\n\t\t}\n\t\tif (found)\n\t\t\tsetptr(patbeg, '\\0');\n\t\tisrec = (found == 0 && *buf == '\\0') ? false : true;\n\n\t} else {\n\t\tif ((sep = *rs) == 0) {\n\t\t\tsep = '\\n';\n\t\t\twhile ((c=getc(inf)) == '\\n' && c != EOF)\t/* skip leading \\n's */\n\t\t\t\t;\n\t\t\tif (c != EOF)\n\t\t\t\tungetc(c, inf);\n\t\t}\n\t\tfor (rr = buf; ; ) {\n\t\t\tfor (; (c=getc(inf)) != sep && c != EOF; ) {\n\t\t\t\tif (rr-buf+1 > bufsize)\n\t\t\t\t\tif (!adjbuf(&buf, &bufsize, 1+rr-buf,\n\t\t\t\t\t    recsize, &rr, \"readrec 1\"))\n\t\t\t\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n\t\t\t\t*rr++ = c;\n\t\t\t}\n\t\t\tif (*rs == sep || c == EOF)\n\t\t\t\tbreak;\n\t\t\tif ((c = getc(inf)) == '\\n' || c == EOF)\t/* 2 in a row */\n\t\t\t\tbreak;\n\t\t\tif (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr,\n\t\t\t    \"readrec 2\"))\n\t\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n\t\t\t*rr++ = '\\n';\n\t\t\t*rr++ = c;\n\t\t}\n\t\tif (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, \"readrec 3\"))\n\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n\t\t*rr = 0;\n\t\tisrec = (c == EOF && rr == buf) ? false : true;\n\t}\n\t*pbuf = buf;\n\t*pbufsize = bufsize;\n\tDPRINTF(\"readrec saw <%s>, returns %d\\n\", buf, isrec);\n\treturn isrec;\n}\n\n\n/*******************\n * loose ends here:\n *   \\r\\n should become \\n\n *   what about bare \\r?  Excel uses that for embedded newlines\n *   can't have \"\" in unquoted fields, according to RFC 4180\n*/\n\n\nint readcsvrec(char **pbuf, int *pbufsize, FILE *inf, bool newflag) /* csv can have \\n's */\n{\t\t\t/* so read a complete record that might be multiple lines */\n\tint sep, c;\n\tchar *rr = *pbuf, *buf = *pbuf;\n\tint bufsize = *pbufsize;\n\tbool in_quote = false;\n\n\tsep = '\\n'; /* the only separator; have to skip over \\n embedded in \"...\" */\n\trr = buf;\n\twhile ((c = getc(inf)) != EOF) {\n\t\tif (c == sep) {\n\t\t\tif (! in_quote)\n\t\t\t\tbreak;\n\t\t\tif (rr > buf && rr[-1] == '\\r')\t// remove \\r if was \\r\\n\n\t\t\t\trr--;\n\t\t}\n\n\t\tif (rr-buf+1 > bufsize)\n\t\t\tif (!adjbuf(&buf, &bufsize, 1+rr-buf,\n\t\t\t    recsize, &rr, \"readcsvrec 1\"))\n\t\t\t\tFATAL(\"input record `%.30s...' too long\", buf);\n\t\t*rr++ = c;\n\t\tif (c == '\"')\n\t\t\tin_quote = ! in_quote;\n \t}\n\tif (c == '\\n' && rr > buf && rr[-1] == '\\r') \t// remove \\r if was \\r\\n\n\t\trr--;\n\n\tif (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, \"readcsvrec 4\"))\n\t\tFATAL(\"input record `%.30s...' too long\", buf);\n\t*rr = 0;\n\t*pbuf = buf;\n\t*pbufsize = bufsize;\n\tDPRINTF(\"readcsvrec saw <%s>, returns %d\\n\", buf, c);\n\treturn c;\n}\n\nchar *getargv(int n)\t/* get ARGV[n] */\n{\n\tArray *ap;\n\tCell *x;\n\tchar *s, temp[50];\n\textern Cell *ARGVcell;\n\n\tap = (Array *)ARGVcell->sval;\n\tsnprintf(temp, sizeof(temp), \"%d\", n);\n\tif (lookup(temp, ap) == NULL)\n\t\treturn NULL;\n\tx = setsymtab(temp, \"\", 0.0, STR, ap);\n\ts = getsval(x);\n\tDPRINTF(\"getargv(%d) returns |%s|\\n\", n, s);\n\treturn s;\n}\n\nvoid setclvar(char *s)\t/* set var=value from s */\n{\n\tchar *e, *p;\n\tCell *q;\n\tdouble result;\n\n/* commit f3d9187d4e0f02294fb1b0e31152070506314e67 broke T.argv test */\n/* I don't understand why it was changed. */\n\n\tfor (p=s; *p != '='; p++)\n\t\t;\n\te = p;\n\t*p++ = 0;\n\tp = qstring(p, '\\0');\n\tq = setsymtab(s, p, 0.0, STR, symtab);\n\tsetsval(q, p);\n\tif (is_number(q->sval, & result)) {\n\t\tq->fval = result;\n\t\tq->tval |= NUM;\n\t}\n\tDPRINTF(\"command line set %s to |%s|\\n\", s, p);\n\tfree(p);\n\t*e = '=';\n}\n\n\nvoid fldbld(void)\t/* create fields from current record */\n{\n\t/* this relies on having fields[] the same length as $0 */\n\t/* the fields are all stored in this one array with \\0's */\n\t/* possibly with a final trailing \\0 not associated with any field */\n\tchar *r, *fr, sep;\n\tCell *p;\n\tint i, j, n;\n\n\tif (donefld)\n\t\treturn;\n\tif (!isstr(fldtab[0]))\n\t\tgetsval(fldtab[0]);\n\tr = fldtab[0]->sval;\n\tn = strlen(r);\n\tif (n > fieldssize) {\n\t\txfree(fields);\n\t\tif ((fields = (char *) malloc(n+2)) == NULL) /* possibly 2 final \\0s */\n\t\t\tFATAL(\"out of space for fields in fldbld %d\", n);\n\t\tfieldssize = n;\n\t}\n\tfr = fields;\n\ti = 0;\t/* number of fields accumulated here */\n\tif (inputFS == NULL)\t/* make sure we have a copy of FS */\n\t\tsavefs();\n\tif (!CSV && strlen(inputFS) > 1) {\t/* it's a regular expression */\n\t\ti = refldbld(r, inputFS);\n\t} else if (!CSV && (sep = *inputFS) == ' ') {\t/* default whitespace */\n\t\tfor (i = 0; ; ) {\n\t\t\twhile (*r == ' ' || *r == '\\t' || *r == '\\n')\n\t\t\t\tr++;\n\t\t\tif (*r == 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t\tif (i > nfields)\n\t\t\t\tgrowfldtab(i);\n\t\t\tif (freeable(fldtab[i]))\n\t\t\t\txfree(fldtab[i]->sval);\n\t\t\tfldtab[i]->sval = fr;\n\t\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n\t\t\tdo\n\t\t\t\t*fr++ = *r++;\n\t\t\twhile (*r != ' ' && *r != '\\t' && *r != '\\n' && *r != '\\0');\n\t\t\t*fr++ = 0;\n\t\t}\n\t\t*fr = 0;\n\t} else if (CSV) {\t/* CSV processing.  no error handling */\n\t\tif (*r != 0) {\n\t\t\tfor (;;) {\n\t\t\t\ti++;\n\t\t\t\tif (i > nfields)\n\t\t\t\t\tgrowfldtab(i);\n\t\t\t\tif (freeable(fldtab[i]))\n\t\t\t\t\txfree(fldtab[i]->sval);\n\t\t\t\tfldtab[i]->sval = fr;\n\t\t\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n\t\t\t\tif (*r == '\"' ) { /* start of \"...\" */\n\t\t\t\t\tfor (r++ ; *r != '\\0'; ) {\n\t\t\t\t\t\tif (*r == '\"' && r[1] != '\\0' && r[1] == '\"') {\n\t\t\t\t\t\t\tr += 2; /* doubled quote */\n\t\t\t\t\t\t\t*fr++ = '\"';\n\t\t\t\t\t\t} else if (*r == '\"' && (r[1] == '\\0' || r[1] == ',')) {\n\t\t\t\t\t\t\tr++; /* skip over closing quote */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*fr++ = *r++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*fr++ = 0;\n\t\t\t\t} else {\t/* unquoted field */\n\t\t\t\t\twhile (*r != ',' && *r != '\\0')\n\t\t\t\t\t\t*fr++ = *r++;\n\t\t\t\t\t*fr++ = 0;\n\t\t\t\t}\n\t\t\t\tif (*r++ == 0)\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\t}\n\t\t*fr = 0;\n\t} else if ((sep = *inputFS) == 0) {\t/* new: FS=\"\" => 1 char/field */\n\t\tfor (i = 0; *r != '\\0'; ) {\n\t\t\tchar buf[10];\n\t\t\ti++;\n\t\t\tif (i > nfields)\n\t\t\t\tgrowfldtab(i);\n\t\t\tif (freeable(fldtab[i]))\n\t\t\t\txfree(fldtab[i]->sval);\n\t\t\tn = u8_nextlen(r);\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\tbuf[j] = *r++;\n\t\t\tbuf[j] = '\\0';\n\t\t\tfldtab[i]->sval = tostring(buf);\n\t\t\tfldtab[i]->tval = FLD | STR;\n\t\t}\n\t\t*fr = 0;\n\t} else if (*r != 0) {\t/* if 0, it's a null field */\n\t\t/* subtle case: if length(FS) == 1 && length(RS > 0)\n\t\t * \\n is NOT a field separator (cf awk book 61,84).\n\t\t * this variable is tested in the inner while loop.\n\t\t */\n\t\tint rtest = '\\n';  /* normal case */\n\t\tif (strlen(*RS) > 0)\n\t\t\trtest = '\\0';\n\t\tfor (;;) {\n\t\t\ti++;\n\t\t\tif (i > nfields)\n\t\t\t\tgrowfldtab(i);\n\t\t\tif (freeable(fldtab[i]))\n\t\t\t\txfree(fldtab[i]->sval);\n\t\t\tfldtab[i]->sval = fr;\n\t\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n\t\t\twhile (*r != sep && *r != rtest && *r != '\\0')\t/* \\n is always a separator */\n\t\t\t\t*fr++ = *r++;\n\t\t\t*fr++ = 0;\n\t\t\tif (*r++ == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t*fr = 0;\n\t}\n\tif (i > nfields)\n\t\tFATAL(\"record `%.30s...' has too many fields; can't happen\", r);\n\tcleanfld(i+1, lastfld);\t/* clean out junk from previous record */\n\tlastfld = i;\n\tdonefld = true;\n\tfor (j = 1; j <= lastfld; j++) {\n\t\tdouble result;\n\n\t\tp = fldtab[j];\n\t\tif(is_number(p->sval, & result)) {\n\t\t\tp->fval = result;\n\t\t\tp->tval |= NUM;\n\t\t}\n\t}\n\tsetfval(nfloc, (Awkfloat) lastfld);\n\tdonerec = true; /* restore */\n\tif (dbg) {\n\t\tfor (j = 0; j <= lastfld; j++) {\n\t\t\tp = fldtab[j];\n\t\t\tprintf(\"field %d (%s): |%s|\\n\", j, p->nval, p->sval);\n\t\t}\n\t}\n}\n\nvoid cleanfld(int n1, int n2)\t/* clean out fields n1 .. n2 inclusive */\n{\t\t\t\t/* nvals remain intact */\n\tCell *p;\n\tint i;\n\n\tfor (i = n1; i <= n2; i++) {\n\t\tp = fldtab[i];\n\t\tif (freeable(p))\n\t\t\txfree(p->sval);\n\t\tp->sval = EMPTY,\n\t\tp->tval = FLD | STR | DONTFREE;\n\t}\n}\n\nvoid newfld(int n)\t/* add field n after end of existing lastfld */\n{\n\tif (n > nfields)\n\t\tgrowfldtab(n);\n\tcleanfld(lastfld+1, n);\n\tlastfld = n;\n\tsetfval(nfloc, (Awkfloat) n);\n}\n\nvoid setlastfld(int n)\t/* set lastfld cleaning fldtab cells if necessary */\n{\n\tif (n < 0)\n\t\tFATAL(\"cannot set NF to a negative value\");\n\tif (n > nfields)\n\t\tgrowfldtab(n);\n\n\tif (lastfld < n)\n\t    cleanfld(lastfld+1, n);\n\telse\n\t    cleanfld(n+1, lastfld);\n\n\tlastfld = n;\n}\n\nCell *fieldadr(int n)\t/* get nth field */\n{\n\tif (n < 0)\n\t\tFATAL(\"trying to access out of range field %d\", n);\n\tif (n > nfields)\t/* fields after NF are empty */\n\t\tgrowfldtab(n);\t/* but does not increase NF */\n\treturn(fldtab[n]);\n}\n\nvoid growfldtab(int n)\t/* make new fields up to at least $n */\n{\n\tint nf = 2 * nfields;\n\tsize_t s;\n\n\tif (n > nf)\n\t\tnf = n;\n\ts = (nf+1) * (sizeof (struct Cell *));  /* freebsd: how much do we need? */\n\tif (s / sizeof(struct Cell *) - 1 == (size_t)nf) /* didn't overflow */\n\t\tfldtab = (Cell **) realloc(fldtab, s);\n\telse\t\t\t\t\t/* overflow sizeof int */\n\t\txfree(fldtab);\t/* make it null */\n\tif (fldtab == NULL)\n\t\tFATAL(\"out of space creating %d fields\", nf);\n\tmakefields(nfields+1, nf);\n\tnfields = nf;\n}\n\nint refldbld(const char *rec, const char *fs)\t/* build fields from reg expr in FS */\n{\n\t/* this relies on having fields[] the same length as $0 */\n\t/* the fields are all stored in this one array with \\0's */\n\tchar *fr;\n\tint i, tempstat, n;\n\tfa *pfa;\n\n\tn = strlen(rec);\n\tif (n > fieldssize) {\n\t\txfree(fields);\n\t\tif ((fields = (char *) malloc(n+1)) == NULL)\n\t\t\tFATAL(\"out of space for fields in refldbld %d\", n);\n\t\tfieldssize = n;\n\t}\n\tfr = fields;\n\t*fr = '\\0';\n\tif (*rec == '\\0')\n\t\treturn 0;\n\tpfa = makedfa(fs, 1);\n\tDPRINTF(\"into refldbld, rec = <%s>, pat = <%s>\\n\", rec, fs);\n\ttempstat = pfa->initstat;\n\tfor (i = 1; ; i++) {\n\t\tif (i > nfields)\n\t\t\tgrowfldtab(i);\n\t\tif (freeable(fldtab[i]))\n\t\t\txfree(fldtab[i]->sval);\n\t\tfldtab[i]->tval = FLD | STR | DONTFREE;\n\t\tfldtab[i]->sval = fr;\n\t\tDPRINTF(\"refldbld: i=%d\\n\", i);\n\t\tif (nematch(pfa, rec)) {\n\t\t\tpfa->initstat = 2;\t/* horrible coupling to b.c */\n\t\t\tDPRINTF(\"match %s (%d chars)\\n\", patbeg, patlen);\n\t\t\tstrncpy(fr, rec, patbeg-rec);\n\t\t\tfr += patbeg - rec + 1;\n\t\t\t*(fr-1) = '\\0';\n\t\t\trec = patbeg + patlen;\n\t\t} else {\n\t\t\tDPRINTF(\"no match %s\\n\", rec);\n\t\t\tstrcpy(fr, rec);\n\t\t\tpfa->initstat = tempstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid recbld(void)\t/* create $0 from $1..$NF if necessary */\n{\n\tint i;\n\tchar *r, *p;\n\tchar *sep = getsval(ofsloc);\n\n\tif (donerec)\n\t\treturn;\n\tr = record;\n\tfor (i = 1; i <= *NF; i++) {\n\t\tp = getsval(fldtab[i]);\n\t\tif (!adjbuf(&record, &recsize, 1+strlen(p)+r-record, recsize, &r, \"recbld 1\"))\n\t\t\tFATAL(\"created $0 `%.30s...' too long\", record);\n\t\twhile ((*r = *p++) != 0)\n\t\t\tr++;\n\t\tif (i < *NF) {\n\t\t\tif (!adjbuf(&record, &recsize, 2+strlen(sep)+r-record, recsize, &r, \"recbld 2\"))\n\t\t\t\tFATAL(\"created $0 `%.30s...' too long\", record);\n\t\t\tfor (p = sep; (*r = *p++) != 0; )\n\t\t\t\tr++;\n\t\t}\n\t}\n\tif (!adjbuf(&record, &recsize, 2+r-record, recsize, &r, \"recbld 3\"))\n\t\tFATAL(\"built giant record `%.30s...'\", record);\n\t*r = '\\0';\n\tDPRINTF(\"in recbld inputFS=%s, fldtab[0]=%p\\n\", inputFS, (void*)fldtab[0]);\n\n\tif (freeable(fldtab[0]))\n\t\txfree(fldtab[0]->sval);\n\tfldtab[0]->tval = REC | STR | DONTFREE;\n\tfldtab[0]->sval = record;\n\n\tDPRINTF(\"in recbld inputFS=%s, fldtab[0]=%p\\n\", inputFS, (void*)fldtab[0]);\n\tDPRINTF(\"recbld = |%s|\\n\", record);\n\tdonerec = true;\n}\n\nint\terrorflag\t= 0;\n\nvoid yyerror(const char *s)\n{\n\tSYNTAX(\"%s\", s);\n}\n\nvoid SYNTAX(const char *fmt, ...)\n{\n\textern char *cmdname, *curfname;\n\tstatic int been_here = 0;\n\tva_list varg;\n\n\tif (been_here++ > 2)\n\t\treturn;\n\tfprintf(stderr, \"%s: \", cmdname);\n\tva_start(varg, fmt);\n\tvfprintf(stderr, fmt, varg);\n\tva_end(varg);\n\tfprintf(stderr, \" at source line %d\", lineno);\n\tif (curfname != NULL)\n\t\tfprintf(stderr, \" in function %s\", curfname);\n\tif (compile_time == COMPILING && cursource() != NULL)\n\t\tfprintf(stderr, \" source file %s\", cursource());\n\tfprintf(stderr, \"\\n\");\n\terrorflag = 2;\n\teprint();\n}\n\nextern int bracecnt, brackcnt, parencnt;\n\nvoid bracecheck(void)\n{\n\tint c;\n\tstatic int beenhere = 0;\n\n\tif (beenhere++)\n\t\treturn;\n\twhile ((c = input()) != EOF && c != '\\0')\n\t\tbclass(c);\n\tbcheck2(bracecnt, '{', '}');\n\tbcheck2(brackcnt, '[', ']');\n\tbcheck2(parencnt, '(', ')');\n}\n\nvoid bcheck2(int n, int c1, int c2)\n{\n\tif (n == 1)\n\t\tfprintf(stderr, \"\\tmissing %c\\n\", c2);\n\telse if (n > 1)\n\t\tfprintf(stderr, \"\\t%d missing %c's\\n\", n, c2);\n\telse if (n == -1)\n\t\tfprintf(stderr, \"\\textra %c\\n\", c2);\n\telse if (n < -1)\n\t\tfprintf(stderr, \"\\t%d extra %c's\\n\", -n, c2);\n}\n\nvoid FATAL(const char *fmt, ...)\n{\n\textern char *cmdname;\n\tva_list varg;\n\n\tfflush(stdout);\n\tfprintf(stderr, \"%s: \", cmdname);\n\tva_start(varg, fmt);\n\tvfprintf(stderr, fmt, varg);\n\tva_end(varg);\n\terror();\n\tif (dbg > 1)\t\t/* core dump if serious debugging on */\n\t\tabort();\n\texit(2);\n}\n\nvoid WARNING(const char *fmt, ...)\n{\n\textern char *cmdname;\n\tva_list varg;\n\n\tfflush(stdout);\n\tfprintf(stderr, \"%s: \", cmdname);\n\tva_start(varg, fmt);\n\tvfprintf(stderr, fmt, varg);\n\tva_end(varg);\n\terror();\n}\n\nvoid error()\n{\n\textern Node *curnode;\n\n\tfprintf(stderr, \"\\n\");\n\tif (compile_time != ERROR_PRINTING) {\n\t\tif (NR && *NR > 0) {\n\t\t\tfprintf(stderr, \" input record number %d\", (int) (*FNR));\n\t\t\tif (strcmp(*FILENAME, \"-\") != 0)\n\t\t\t\tfprintf(stderr, \", file %s\", *FILENAME);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tif (curnode)\n\t\t\tfprintf(stderr, \" source line number %d\", curnode->lineno);\n\t\telse if (lineno)\n\t\t\tfprintf(stderr, \" source line number %d\", lineno);\n\t\tif (compile_time == COMPILING && cursource() != NULL)\n\t\t\tfprintf(stderr, \" source file %s\", cursource());\n\t\tfprintf(stderr, \"\\n\");\n\t\teprint();\n\t}\n}\n\nvoid eprint(void)\t/* try to print context around error */\n{\n\tchar *p, *q;\n\tint c;\n\tstatic int been_here = 0;\n\textern char ebuf[], *ep;\n\n\tif (compile_time != COMPILING || been_here++ > 0 || ebuf == ep)\n\t\treturn;\n\tif (ebuf == ep)\n\t\treturn;\n\tp = ep - 1;\n\tif (p > ebuf && *p == '\\n')\n\t\tp--;\n\tfor ( ; p > ebuf && *p != '\\n' && *p != '\\0'; p--)\n\t\t;\n\twhile (*p == '\\n')\n\t\tp++;\n\tfprintf(stderr, \" context is\\n\\t\");\n\tfor (q=ep-1; q>=p && *q!=' ' && *q!='\\t' && *q!='\\n'; q--)\n\t\t;\n\tfor ( ; p < q; p++)\n\t\tif (*p)\n\t\t\tputc(*p, stderr);\n\tfprintf(stderr, \" >>> \");\n\tfor ( ; p < ep; p++)\n\t\tif (*p)\n\t\t\tputc(*p, stderr);\n\tfprintf(stderr, \" <<< \");\n\tif (*ep)\n\t\twhile ((c = input()) != '\\n' && c != '\\0' && c != EOF) {\n\t\t\tputc(c, stderr);\n\t\t\tbclass(c);\n\t\t}\n\tputc('\\n', stderr);\n\tep = ebuf;\n}\n\nvoid bclass(int c)\n{\n\tswitch (c) {\n\tcase '{': bracecnt++; break;\n\tcase '}': bracecnt--; break;\n\tcase '[': brackcnt++; break;\n\tcase ']': brackcnt--; break;\n\tcase '(': parencnt++; break;\n\tcase ')': parencnt--; break;\n\t}\n}\n\ndouble errcheck(double x, const char *s)\n{\n\n\tif (errno == EDOM) {\n\t\terrno = 0;\n\t\tWARNING(\"%s argument out of domain\", s);\n\t\tx = 1;\n\t} else if (errno == ERANGE) {\n\t\terrno = 0;\n\t\tWARNING(\"%s result out of range\", s);\n\t\tx = 1;\n\t}\n\treturn x;\n}\n\nint isclvar(const char *s)\t/* is s of form var=something ? */\n{\n\tconst char *os = s;\n\n\tif (!isalpha((int) *s) && *s != '_')\n\t\treturn 0;\n\tfor ( ; *s; s++)\n\t\tif (!(isalnum((int) *s) || *s == '_'))\n\t\t\tbreak;\n\treturn *s == '=' && s > os;\n}\n\n/* strtod is supposed to be a proper test of what's a valid number */\n/* appears to be broken in gcc on linux: thinks 0x123 is a valid FP number */\n/* wrong: violates 4.10.1.4 of ansi C standard */\n\n/* well, not quite. As of C99, hex floating point is allowed. so this is\n * a bit of a mess. We work around the mess by checking for a hexadecimal\n * value and disallowing it. Similarly, we now follow gawk and allow only\n * +nan, -nan, +inf, and -inf for NaN and infinity values.\n */\n\n/*\n * This routine now has a more complicated interface, the main point\n * being to avoid the double conversion of a string to double, and\n * also to convey out, if requested, the information that the numeric\n * value was a leading string or is all of the string. The latter bit\n * is used in getfval().\n */\n\nbool is_valid_number(const char *s, bool trailing_stuff_ok,\n\t\t\tbool *no_trailing, double *result)\n{\n\tdouble r;\n\tchar *ep;\n\tbool retval = false;\n\tbool is_nan = false;\n\tbool is_inf = false;\n\n\tif (no_trailing)\n\t\t*no_trailing = false;\n\n\twhile (isspace((int) *s))\n\t\ts++;\n\n\t/* no hex floating point, sorry */\n\tif (s[0] == '0' && tolower(s[1]) == 'x' && isxdigit(s[2]))\n\t\treturn false;\n\n\t/* allow +nan, -nan, +inf, -inf, any other letter, no */\n\tif (s[0] == '+' || s[0] == '-') {\n\t\tis_nan = (strncasecmp(s+1, \"nan\", 3) == 0);\n\t\tis_inf = (strncasecmp(s+1, \"inf\", 3) == 0);\n\t\tif ((is_nan || is_inf)\n\t\t    && (isspace((int) s[4]) || s[4] == '\\0'))\n\t\t\tgoto convert;\n\t\telse if (! isdigit(s[1]) && s[1] != '.')\n\t\t\treturn false;\n\t}\n\telse if (! isdigit(s[0]) && s[0] != '.')\n\t\treturn false;\n\nconvert:\n\terrno = 0;\n\tr = strtod(s, &ep);\n\tif (ep == s || errno == ERANGE)\n\t\treturn false;\n\n\tif (isnan(r) && s[0] == '-' && signbit(r) == 0)\n\t\tr = -r;\n\n\tif (result != NULL)\n\t\t*result = r;\n\n\t/*\n\t * check for trailing stuff\n\t */\n\twhile (isspace((int) *ep))\n\t\tep++;\n\n\tif (no_trailing != NULL)\n\t\t*no_trailing = (*ep == '\\0');\n\n        /* return true if found the end, or trailing stuff is allowed */\n\tretval = *ep == '\\0' || trailing_stuff_ok;\n\n\treturn retval;\n}\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 7.0244140625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\nconst char\t*version = \"version 20250107\";\n\n#define DEBUG\n#include <stdio.h>\n#include <ctype.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include \"awk.h\"\n\nextern\tchar\t**environ;\nextern\tint\tnfields;\n\nint\tdbg\t= 0;\nAwkfloat\tsrand_seed = 1;\nchar\t*cmdname;\t/* gets argv[0] for error messages */\nextern\tFILE\t*yyin;\t/* lex input file */\nchar\t*lexprog;\t/* points to program argument if it exists */\nextern\tint errorflag;\t/* non-zero if any syntax errors; set by yyerror */\nenum compile_states\tcompile_time = ERROR_PRINTING;\n\nstatic char\t**pfile;\t/* program filenames from -f's */\nstatic size_t\tmaxpfile;\t/* max program filename */\nstatic size_t\tnpfile;\t\t/* number of filenames */\nstatic size_t\tcurpfile;\t/* current filename */\n\nbool\tCSV = false;\t/* true for csv input */\n\nbool\tsafe = false;\t/* true => \"safe\" mode */\n\nsize_t\tawk_mb_cur_max = 1;\n\nstatic noreturn void fpecatch(int n\n#ifdef SA_SIGINFO\n\t, siginfo_t *si, void *uc\n#endif\n)\n{\n#ifdef SA_SIGINFO\n\tconst char *mesg = NULL;\n\n\tswitch (si->si_code) {\n\tcase FPE_INTDIV:\n\t\tmesg = \"Integer divide by zero\";\n\t\tbreak;\n\tcase FPE_INTOVF:\n\t\tmesg = \"Integer overflow\";\n\t\tbreak;\n\tcase FPE_FLTDIV:\n\t\tmesg = \"Floating point divide by zero\";\n\t\tbreak;\n\tcase FPE_FLTOVF:\n\t\tmesg = \"Floating point overflow\";\n\t\tbreak;\n\tcase FPE_FLTUND:\n\t\tmesg = \"Floating point underflow\";\n\t\tbreak;\n\tcase FPE_FLTRES:\n\t\tmesg = \"Floating point inexact result\";\n\t\tbreak;\n\tcase FPE_FLTINV:\n\t\tmesg = \"Invalid Floating point operation\";\n\t\tbreak;\n\tcase FPE_FLTSUB:\n\t\tmesg = \"Subscript out of range\";\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tmesg = \"Unknown error\";\n\t\tbreak;\n\t}\n#endif\n\tFATAL(\"floating point exception\"\n#ifdef SA_SIGINFO\n\t\t\": %s\", mesg\n#endif\n\t    );\n}\n\n/* Can this work with recursive calls?  I don't think so.\nvoid segvcatch(int n)\n{\n\tFATAL(\"segfault.  Do you have an unbounded recursive call?\", n);\n}\n*/\n\nstatic const char *\nsetfs(char *p)\n{\n\t/* wart: t=>\\t */\n\tif (p[0] == 't' && p[1] == '\\0')\n\t\treturn \"\\t\";\n\treturn p;\n}\n\nstatic char *\ngetarg(int *argc, char ***argv, const char *msg)\n{\n\tif ((*argv)[1][2] != '\\0') {\t/* arg is -fsomething */\n\t\treturn &(*argv)[1][2];\n\t} else {\t\t\t/* arg is -f something */\n\t\t(*argc)--; (*argv)++;\n\t\tif (*argc <= 1)\n\t\t\tFATAL(\"%s\", msg);\n\t\treturn (*argv)[1];\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tconst char *fs = NULL;\n\tchar *fn, *vn;\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_NUMERIC, \"C\"); /* for parsing cmdline & prog */\n\tawk_mb_cur_max = MB_CUR_MAX;\n\tcmdname = argv[0];\n\tif (argc == 1) {\n\t\tfprintf(stderr,\n\t\t  \"usage: %s [-F fs | --csv] [-v var=value] [-f progfile | 'prog'] [file ...]\\n\",\n\t\t  cmdname);\n\t\texit(1);\n\t}\n#ifdef SA_SIGINFO\n\t{\n\t\tstruct sigaction sa;\n\t\tsa.sa_sigaction = fpecatch;\n\t\tsa.sa_flags = SA_SIGINFO;\n\t\tsigemptyset(&sa.sa_mask);\n\t\t(void)sigaction(SIGFPE, &sa, NULL);\n\t}\n#else\n\t(void)signal(SIGFPE, fpecatch);\n#endif\n\t/*signal(SIGSEGV, segvcatch); experiment */\n\n\t/* Set and keep track of the random seed */\n\tsrand_seed = 1;\n\tsrandom((unsigned long) srand_seed);\n\n\tyyin = NULL;\n\tsymtab = makesymtab(NSYMTAB/NSYMTAB);\n\twhile (argc > 1 && argv[1][0] == '-' && argv[1][1] != '\\0') {\n\t\tif (strcmp(argv[1], \"-version\") == 0 || strcmp(argv[1], \"--version\") == 0) {\n\t\t\tprintf(\"awk %s\\n\", version);\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(argv[1], \"--\") == 0) {\t/* explicit end of args */\n\t\t\targc--;\n\t\t\targv++;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(argv[1], \"--csv\") == 0) {\t/* turn on csv input processing */\n\t\t\tCSV = true;\n\t\t\targc--;\n\t\t\targv++;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (argv[1][1]) {\n\t\tcase 's':\n\t\t\tif (strcmp(argv[1], \"-safe\") == 0)\n\t\t\t\tsafe = true;\n\t\t\tbreak;\n\t\tcase 'f':\t/* next argument is program filename */\n\t\t\tfn = getarg(&argc, &argv, \"no program filename\");\n\t\t\tif (npfile >= maxpfile) {\n\t\t\t\tmaxpfile += 20;\n\t\t\t\tpfile = (char **) realloc(pfile, maxpfile * sizeof(*pfile));\n\t\t\t\tif (pfile == NULL)\n\t\t\t\t\tFATAL(\"error allocating space for -f options\");\n \t\t\t}\n\t\t\tpfile[npfile++] = fn;\n \t\t\tbreak;\n\t\tcase 'F':\t/* set field separator */\n\t\t\tfs = setfs(getarg(&argc, &argv, \"no field separator\"));\n\t\t\tbreak;\n\t\tcase 'v':\t/* -v a=1 to be done NOW.  one -v for each */\n\t\t\tvn = getarg(&argc, &argv, \"no variable name\");\n\t\t\tif (isclvar(vn))\n\t\t\t\tsetclvar(vn);\n\t\t\telse\n\t\t\t\tFATAL(\"invalid -v option argument: %s\", vn);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdbg = atoi(&argv[1][2]);\n\t\t\tif (dbg == 0)\n\t\t\t\tdbg = 1;\n\t\t\tprintf(\"awk %s\\n\", version);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARNING(\"unknown option %s ignored\", argv[1]);\n\t\t\tbreak;\n\t\t}\n\t\targc--;\n\t\targv++;\n\t}\n\n\tif (CSV && (fs != NULL || lookup(\"FS\", symtab) != NULL))\n\t\tWARNING(\"danger: don't set FS when --csv is in effect\");\n\n\t/* argv[1] is now the first argument */\n\tif (npfile == 0) {\t/* no -f; first argument is program */\n\t\tif (argc <= 1) {\n\t\t\tif (dbg)\n\t\t\t\texit(0);\n\t\t\tFATAL(\"no program given\");\n\t\t}\n\t\tDPRINTF(\"program = |%s|\\n\", argv[1]);\n\t\tlexprog = argv[1];\n\t\targc--;\n\t\targv++;\n\t}\n\trecinit(recsize);\n\tsyminit();\n\tcompile_time = COMPILING;\n\targv[0] = cmdname;\t/* put prog name at front of arglist */\n\tDPRINTF(\"argc=%d, argv[0]=%s\\n\", argc, argv[0]);\n\targinit(argc, argv);\n\tif (!safe)\n\t\tenvinit(environ);\n\tyyparse();\n#if 0\n\t// Doing this would comply with POSIX, but is not compatible with\n\t// other awks and with what most users expect. So comment it out.\n\tsetlocale(LC_NUMERIC, \"\"); /* back to whatever it is locally */\n#endif\n\tif (fs)\n\t\t*FS = qstring(fs, '\\0');\n\tDPRINTF(\"errorflag=%d\\n\", errorflag);\n\tif (errorflag == 0) {\n\t\tcompile_time = RUNNING;\n\t\trun(winner);\n\t} else\n\t\tbracecheck();\n\treturn(errorflag);\n}\n\nint pgetc(void)\t\t/* get 1 character from awk program */\n{\n\tint c;\n\n\tfor (;;) {\n\t\tif (yyin == NULL) {\n\t\t\tif (curpfile >= npfile)\n\t\t\t\treturn EOF;\n\t\t\tif (strcmp(pfile[curpfile], \"-\") == 0)\n\t\t\t\tyyin = stdin;\n\t\t\telse if ((yyin = fopen(pfile[curpfile], \"r\")) == NULL)\n\t\t\t\tFATAL(\"can't open file %s\", pfile[curpfile]);\n\t\t\tlineno = 1;\n\t\t}\n\t\tif ((c = getc(yyin)) != EOF)\n\t\t\treturn c;\n\t\tif (yyin != stdin)\n\t\t\tfclose(yyin);\n\t\tyyin = NULL;\n\t\tcurpfile++;\n\t}\n}\n\nchar *cursource(void)\t/* current source file name */\n{\n\tif (npfile > 0)\n\t\treturn pfile[curpfile < npfile ? curpfile : curpfile - 1];\n\telse\n\t\treturn NULL;\n}\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 3.5673828125,
          "content": "# /****************************************************************\n# Copyright (C) Lucent Technologies 1997\n# All Rights Reserved\n#\n# Permission to use, copy, modify, and distribute this software and\n# its documentation for any purpose and without fee is hereby\n# granted, provided that the above copyright notice appear in all\n# copies and that both that the copyright notice and this\n# permission notice and warranty disclaimer appear in supporting\n# documentation, and that the name Lucent Technologies or any of\n# its entities not be used in advertising or publicity pertaining\n# to distribution of the software without specific, written prior\n# permission.\n#\n# LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n# IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n# SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n# THIS SOFTWARE.\n# ****************************************************************/\n\nCFLAGS = -fsanitize=address -O1 -g -fno-omit-frame-pointer -fno-optimize-sibling-calls\nCFLAGS = -g\nCFLAGS =\nCFLAGS = -O2\n\n# compiler options\n#CC = cc -Wall -g -Wwrite-strings\n#CC = cc -O4 -Wall -pedantic -fno-strict-aliasing\n#CC = cc -fprofile-arcs -ftest-coverage # then gcov f1.c; cat f1.c.gcov\nHOSTCC = cc -g -Wall -pedantic -Wcast-qual\n# HOSTCC = g++ -g -Wall -pedantic -Wcast-qual\nCC = $(HOSTCC)  # change this is cross-compiling.\n\n# By fiat, to make our lives easier, yacc is now defined to be bison.\n# If you want something else, you're on your own.\n# YACC = yacc -d -b awkgram\nYACC = bison -d\n\nOFILES = b.o main.o parse.o proctab.o tran.o lib.o run.o lex.o\n\nSOURCE = awk.h awkgram.tab.c awkgram.tab.h proto.h awkgram.y lex.c b.c main.c \\\n\tmaketab.c parse.c lib.c run.c tran.c proctab.c\n\nLISTING = awk.h proto.h awkgram.y lex.c b.c main.c maketab.c parse.c \\\n\tlib.c run.c tran.c\n\nSHIP = README LICENSE FIXES $(SOURCE) awkgram.tab.[ch].bak makefile  \\\n\t awk.1\n\na.out:\tawkgram.tab.o $(OFILES)\n\t$(CC) $(CFLAGS) awkgram.tab.o $(OFILES) $(ALLOC)  -lm\n\n$(OFILES):\tawk.h awkgram.tab.h proto.h\n\nawkgram.tab.c awkgram.tab.h:\tawk.h proto.h awkgram.y\n\t$(YACC) $(YFLAGS) awkgram.y\n\nproctab.c:\tmaketab\n\t./maketab awkgram.tab.h >proctab.c\n\nmaketab:\tawkgram.tab.h maketab.c\n\t$(HOSTCC) $(CFLAGS) maketab.c -o maketab\n\nbundle:\n\t@cp awkgram.tab.h awkgram.tab.h.bak\n\t@cp awkgram.tab.c awkgram.tab.c.bak\n\t@bundle $(SHIP)\n\ntar:\n\t@cp awkgram.tab.h awkgram.tab.h.bak\n\t@cp awkgram.tab.c awkgram.tab.c.bak\n\t@bundle $(SHIP) >awk.shar\n\t@tar cf awk.tar $(SHIP)\n\tgzip awk.tar\n\tls -l awk.tar.gz\n\t@zip awk.zip $(SHIP)\n\tls -l awk.zip\n\ngitadd:\n\tgit add README LICENSE FIXES \\\n           awk.h proto.h awkgram.y lex.c b.c main.c maketab.c parse.c \\\n\t   lib.c run.c tran.c \\\n\t   makefile awk.1 testdir\n\ngitpush:\n\t# only do this once:\n\t# git remote add origin https://github.com/onetrueawk/awk.git\n\tgit push -u origin master\n\nnames:\n\t@echo $(LISTING)\n\ntest check:\n\t./REGRESS\n\nclean: testclean\n\trm -f a.out *.o *.obj maketab maketab.exe *.bb *.bbg *.da *.gcov *.gcno *.gcda # proctab.c\n\ncleaner: testclean\n\trm -f a.out *.o *.obj maketab maketab.exe *.bb *.bbg *.da *.gcov *.gcno *.gcda proctab.c awkgram.tab.*\n\n# This is a bit of a band-aid until we can invest some more time\n# in the test suite.\ntestclean:\n\tcd testdir; rm -fr arnold-fixes beebe devnull echo foo* \\\n\t\tglop glop1 glop2 lilly.diff tempbig tempsmall time\n\n# For the habits of GNU maintainers:\ndistclean: cleaner\n"
        },
        {
          "name": "maketab.c",
          "type": "blob",
          "size": 5.6650390625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n/*\n * this program makes the table to link function names\n * and type indices that is used by execute() in run.c.\n * it finds the indices in awkgram.tab.h, produced by bison.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"awk.h\"\n#include \"awkgram.tab.h\"\n\nstruct xx\n{\tint token;\n\tconst char *name;\n\tconst char *pname;\n} proc[] = {\n\t{ PROGRAM, \"program\", NULL },\n\t{ BOR, \"boolop\", \" || \" },\n\t{ AND, \"boolop\", \" && \" },\n\t{ NOT, \"boolop\", \" !\" },\n\t{ NE, \"relop\", \" != \" },\n\t{ EQ, \"relop\", \" == \" },\n\t{ LE, \"relop\", \" <= \" },\n\t{ LT, \"relop\", \" < \" },\n\t{ GE, \"relop\", \" >= \" },\n\t{ GT, \"relop\", \" > \" },\n\t{ ARRAY, \"array\", NULL },\n\t{ INDIRECT, \"indirect\", \"$(\" },\n\t{ SUBSTR, \"substr\", \"substr\" },\n\t{ SUB, \"dosub\", \"sub\" },\n\t{ GSUB, \"dosub\", \"gsub\" },\n\t{ INDEX, \"sindex\", \"sindex\" },\n\t{ SPRINTF, \"awksprintf\", \"sprintf \" },\n\t{ ADD, \"arith\", \" + \" },\n\t{ MINUS, \"arith\", \" - \" },\n\t{ MULT, \"arith\", \" * \" },\n\t{ DIVIDE, \"arith\", \" / \" },\n\t{ MOD, \"arith\", \" % \" },\n\t{ UMINUS, \"arith\", \" -\" },\n\t{ UPLUS, \"arith\", \" +\" },\n\t{ POWER, \"arith\", \" **\" },\n\t{ PREINCR, \"incrdecr\", \"++\" },\n\t{ POSTINCR, \"incrdecr\", \"++\" },\n\t{ PREDECR, \"incrdecr\", \"--\" },\n\t{ POSTDECR, \"incrdecr\", \"--\" },\n\t{ CAT, \"cat\", \" \" },\n\t{ PASTAT, \"pastat\", NULL },\n\t{ PASTAT2, \"dopa2\", NULL },\n\t{ MATCH, \"matchop\", \" ~ \" },\n\t{ NOTMATCH, \"matchop\", \" !~ \" },\n\t{ MATCHFCN, \"matchop\", \"matchop\" },\n\t{ INTEST, \"intest\", \"intest\" },\n\t{ PRINTF, \"awkprintf\", \"printf\" },\n\t{ PRINT, \"printstat\", \"print\" },\n\t{ CLOSE, \"closefile\", \"closefile\" },\n\t{ DELETE, \"awkdelete\", \"awkdelete\" },\n\t{ SPLIT, \"split\", \"split\" },\n\t{ ASSIGN, \"assign\", \" = \" },\n\t{ ADDEQ, \"assign\", \" += \" },\n\t{ SUBEQ, \"assign\", \" -= \" },\n\t{ MULTEQ, \"assign\", \" *= \" },\n\t{ DIVEQ, \"assign\", \" /= \" },\n\t{ MODEQ, \"assign\", \" %= \" },\n\t{ POWEQ, \"assign\", \" ^= \" },\n\t{ CONDEXPR, \"condexpr\", \" ?: \" },\n\t{ IF, \"ifstat\", \"if(\" },\n\t{ WHILE, \"whilestat\", \"while(\" },\n\t{ FOR, \"forstat\", \"for(\" },\n\t{ DO, \"dostat\", \"do\" },\n\t{ IN, \"instat\", \"instat\" },\n\t{ NEXT, \"jump\", \"next\" },\n\t{ NEXTFILE, \"jump\", \"nextfile\" },\n\t{ EXIT, \"jump\", \"exit\" },\n\t{ BREAK, \"jump\", \"break\" },\n\t{ CONTINUE, \"jump\", \"continue\" },\n\t{ RETURN, \"jump\", \"ret\" },\n\t{ BLTIN, \"bltin\", \"bltin\" },\n\t{ CALL, \"call\", \"call\" },\n\t{ ARG, \"arg\", \"arg\" },\n\t{ VARNF, \"getnf\", \"NF\" },\n\t{ GETLINE, \"awkgetline\", \"getline\" },\n\t{ 0, \"\", \"\" },\n};\n\n#define SIZE\t(LASTTOKEN - FIRSTTOKEN + 1)\nconst char *table[SIZE];\nchar *names[SIZE];\n\nint main(int argc, char *argv[])\n{\n\tconst struct xx *p;\n\tint i, n, tok;\n\tchar c;\n\tFILE *fp;\n\tchar buf[200], name[200], def[200];\n\tenum { TOK_UNKNOWN, TOK_ENUM, TOK_DEFINE } tokentype = TOK_UNKNOWN;\n\n\tprintf(\"#include <stdio.h>\\n\");\n\tprintf(\"#include \\\"awk.h\\\"\\n\");\n\tprintf(\"#include \\\"awkgram.tab.h\\\"\\n\\n\");\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"usage: maketab YTAB_H\\n\");\n\t\texit(1);\n\t}\n\tif ((fp = fopen(argv[1], \"r\")) == NULL) {\n\t\tfprintf(stderr, \"maketab can't open %s!\\n\", argv[1]);\n\t\texit(1);\n\t}\n\tprintf(\"static const char * const printname[%d] = {\\n\", SIZE);\n\ti = 0;\n\twhile (fgets(buf, sizeof buf, fp) != NULL) {\n\t\t// 199 is sizeof(def) - 1\n\t\tif (tokentype != TOK_ENUM) {\n\t\t\tn = sscanf(buf, \"%1c %199s %199s %d\", &c, def, name,\n\t\t\t    &tok);\n\t\t\tif (n == 4 && c == '#' && strcmp(def, \"define\") == 0) {\n\t\t\t\ttokentype = TOK_DEFINE;\n\t\t\t} else if (tokentype != TOK_UNKNOWN) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (tokentype != TOK_DEFINE) {\n\t\t\t/* not a valid #define, bison uses enums now */\n\t\t\tn = sscanf(buf, \"%199s = %d,\\n\", name, &tok);\n\t\t\tif (n != 2)\n\t\t\t\tcontinue;\n\t\t\ttokentype = TOK_ENUM;\n\t\t}\n\t\tif (strcmp(name, \"YYSTYPE_IS_DECLARED\") == 0) {\n\t\t\ttokentype = TOK_UNKNOWN;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tok < FIRSTTOKEN || tok > LASTTOKEN) {\n\t\t\ttokentype = TOK_UNKNOWN;\n\t\t\t/* fprintf(stderr, \"maketab funny token %d %s ignored\\n\", tok, buf); */\n\t\t\tcontinue;\n\t\t}\n\t\tnames[tok-FIRSTTOKEN] = strdup(name);\n\t\tif (names[tok-FIRSTTOKEN] == NULL) {\n\t\t\tfprintf(stderr, \"maketab out of space copying %s\", name);\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"\\t\\\"%s\\\",\\t/* %d */\\n\", name, tok);\n\t\ti++;\n\t}\n\tprintf(\"};\\n\\n\");\n\n\tfor (p=proc; p->token!=0; p++)\n\t\ttable[p->token-FIRSTTOKEN] = p->name;\n\tprintf(\"\\nCell *(*proctab[%d])(Node **, int) = {\\n\", SIZE);\n\tfor (i=0; i<SIZE; i++)\n\t\tprintf(\"\\t%s,\\t/* %s */\\n\",\n\t\t    table[i] ? table[i] : \"nullproc\", names[i] ? names[i] : \"\");\n\tprintf(\"};\\n\\n\");\n\n\tprintf(\"const char *tokname(int n)\\n\");\t/* print a tokname() function */\n\tprintf(\"{\\n\");\n\tprintf(\"\\tstatic char buf[100];\\n\\n\");\n\tprintf(\"\\tif (n < FIRSTTOKEN || n > LASTTOKEN) {\\n\");\n\tprintf(\"\\t\\tsnprintf(buf, sizeof(buf), \\\"token %%d\\\", n);\\n\");\n\tprintf(\"\\t\\treturn buf;\\n\");\n\tprintf(\"\\t}\\n\");\n\tprintf(\"\\treturn printname[n-FIRSTTOKEN];\\n\");\n\tprintf(\"}\\n\");\n\treturn 0;\n}\n"
        },
        {
          "name": "parse.c",
          "type": "blob",
          "size": 5.0673828125,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#define DEBUG\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"awk.h\"\n#include \"awkgram.tab.h\"\n\nNode *nodealloc(size_t n)\n{\n\tNode *x;\n\n\tx = (Node *) malloc(sizeof(*x) + (n-1) * sizeof(x));\n\tif (x == NULL)\n\t\tFATAL(\"out of space in nodealloc\");\n\tx->nnext = NULL;\n\tx->lineno = lineno;\n\treturn(x);\n}\n\nNode *exptostat(Node *a)\n{\n\ta->ntype = NSTAT;\n\treturn(a);\n}\n\nNode *node1(int a, Node *b)\n{\n\tNode *x;\n\n\tx = nodealloc(1);\n\tx->nobj = a;\n\tx->narg[0]=b;\n\treturn(x);\n}\n\nNode *node2(int a, Node *b, Node *c)\n{\n\tNode *x;\n\n\tx = nodealloc(2);\n\tx->nobj = a;\n\tx->narg[0] = b;\n\tx->narg[1] = c;\n\treturn(x);\n}\n\nNode *node3(int a, Node *b, Node *c, Node *d)\n{\n\tNode *x;\n\n\tx = nodealloc(3);\n\tx->nobj = a;\n\tx->narg[0] = b;\n\tx->narg[1] = c;\n\tx->narg[2] = d;\n\treturn(x);\n}\n\nNode *node4(int a, Node *b, Node *c, Node *d, Node *e)\n{\n\tNode *x;\n\n\tx = nodealloc(4);\n\tx->nobj = a;\n\tx->narg[0] = b;\n\tx->narg[1] = c;\n\tx->narg[2] = d;\n\tx->narg[3] = e;\n\treturn(x);\n}\n\nNode *stat1(int a, Node *b)\n{\n\tNode *x;\n\n\tx = node1(a,b);\n\tx->ntype = NSTAT;\n\treturn(x);\n}\n\nNode *stat2(int a, Node *b, Node *c)\n{\n\tNode *x;\n\n\tx = node2(a,b,c);\n\tx->ntype = NSTAT;\n\treturn(x);\n}\n\nNode *stat3(int a, Node *b, Node *c, Node *d)\n{\n\tNode *x;\n\n\tx = node3(a,b,c,d);\n\tx->ntype = NSTAT;\n\treturn(x);\n}\n\nNode *stat4(int a, Node *b, Node *c, Node *d, Node *e)\n{\n\tNode *x;\n\n\tx = node4(a,b,c,d,e);\n\tx->ntype = NSTAT;\n\treturn(x);\n}\n\nNode *op1(int a, Node *b)\n{\n\tNode *x;\n\n\tx = node1(a,b);\n\tx->ntype = NEXPR;\n\treturn(x);\n}\n\nNode *op2(int a, Node *b, Node *c)\n{\n\tNode *x;\n\n\tx = node2(a,b,c);\n\tx->ntype = NEXPR;\n\treturn(x);\n}\n\nNode *op3(int a, Node *b, Node *c, Node *d)\n{\n\tNode *x;\n\n\tx = node3(a,b,c,d);\n\tx->ntype = NEXPR;\n\treturn(x);\n}\n\nNode *op4(int a, Node *b, Node *c, Node *d, Node *e)\n{\n\tNode *x;\n\n\tx = node4(a,b,c,d,e);\n\tx->ntype = NEXPR;\n\treturn(x);\n}\n\nNode *celltonode(Cell *a, int b)\n{\n\tNode *x;\n\n\ta->ctype = OCELL;\n\ta->csub = b;\n\tx = node1(0, (Node *) a);\n\tx->ntype = NVALUE;\n\treturn(x);\n}\n\nNode *rectonode(void)\t/* make $0 into a Node */\n{\n\textern Cell *literal0;\n\treturn op1(INDIRECT, celltonode(literal0, CUNK));\n}\n\nNode *makearr(Node *p)\n{\n\tCell *cp;\n\n\tif (isvalue(p)) {\n\t\tcp = (Cell *) (p->narg[0]);\n\t\tif (isfcn(cp))\n\t\t\tSYNTAX( \"%s is a function, not an array\", cp->nval );\n\t\telse if (!isarr(cp)) {\n\t\t\txfree(cp->sval);\n\t\t\tcp->sval = (char *) makesymtab(NSYMTAB);\n\t\t\tcp->tval = ARR;\n\t\t}\n\t}\n\treturn p;\n}\n\n#define PA2NUM\t50\t/* max number of pat,pat patterns allowed */\nint\tpaircnt;\t\t/* number of them in use */\nint\tpairstack[PA2NUM];\t/* state of each pat,pat */\n\nNode *pa2stat(Node *a, Node *b, Node *c)\t/* pat, pat {...} */\n{\n\tNode *x;\n\n\tx = node4(PASTAT2, a, b, c, itonp(paircnt));\n\tif (paircnt++ >= PA2NUM)\n\t\tSYNTAX( \"limited to %d pat,pat statements\", PA2NUM );\n\tx->ntype = NSTAT;\n\treturn(x);\n}\n\nNode *linkum(Node *a, Node *b)\n{\n\tNode *c;\n\n\tif (errorflag)\t/* don't link things that are wrong */\n\t\treturn a;\n\tif (a == NULL)\n\t\treturn(b);\n\telse if (b == NULL)\n\t\treturn(a);\n\tfor (c = a; c->nnext != NULL; c = c->nnext)\n\t\t;\n\tc->nnext = b;\n\treturn(a);\n}\n\nvoid defn(Cell *v, Node *vl, Node *st)\t/* turn on FCN bit in definition, */\n{\t\t\t\t\t/*   body of function, arglist */\n\tNode *p;\n\tint n;\n\n\tif (isarr(v)) {\n\t\tSYNTAX( \"`%s' is an array name and a function name\", v->nval );\n\t\treturn;\n\t}\n\tif (isarg(v->nval) != -1) {\n\t\tSYNTAX( \"`%s' is both function name and argument name\", v->nval );\n\t\treturn;\n\t}\n\n\tv->tval = FCN;\n\tv->sval = (char *) st;\n\tn = 0;\t/* count arguments */\n\tfor (p = vl; p; p = p->nnext)\n\t\tn++;\n\tv->fval = n;\n\tDPRINTF(\"defining func %s (%d args)\\n\", v->nval, n);\n}\n\nint isarg(const char *s)\t\t/* is s in argument list for current function? */\n{\t\t\t/* return -1 if not, otherwise arg # */\n\textern Node *arglist;\n\tNode *p = arglist;\n\tint n;\n\n\tfor (n = 0; p != NULL; p = p->nnext, n++)\n\t\tif (strcmp(((Cell *)(p->narg[0]))->nval, s) == 0)\n\t\t\treturn n;\n\treturn -1;\n}\n\nint ptoi(void *p)\t/* convert pointer to integer */\n{\n\treturn (int) (long) p;\t/* swearing that p fits, of course */\n}\n\nNode *itonp(int i)\t/* and vice versa */\n{\n\treturn (Node *) (long) i;\n}\n"
        },
        {
          "name": "proto.h",
          "type": "blob",
          "size": 7.056640625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\nextern\tint\tyywrap(void);\nextern\tvoid\tsetfname(Cell *);\nextern\tint\tconstnode(Node *);\nextern\tchar\t*strnode(Node *);\nextern\tNode\t*notnull(Node *);\nextern\tint\tyyparse(void);\n\nextern\tint\tyylex(void);\nextern\tvoid\tstartreg(void);\nextern\tint\tinput(void);\nextern\tvoid\tunput(int);\nextern\tvoid\tunputstr(const char *);\n\nextern\tfa\t*makedfa(const char *, bool);\nextern\tfa\t*mkdfa(const char *, bool);\nextern\tint\tmakeinit(fa *, bool);\nextern\tvoid\tpenter(Node *);\nextern\tvoid\tfreetr(Node *);\nextern\tint\tquoted(const uschar **);\nextern\tint\t*cclenter(const char *);\nextern\tnoreturn void\toverflo(const char *);\nextern\tvoid\tcfoll(fa *, Node *);\nextern\tint\tfirst(Node *);\nextern\tvoid\tfollow(Node *);\nextern\tint\tmember(int, int *);\nextern\tint\tmatch(fa *, const char *);\nextern\tint\tpmatch(fa *, const char *);\nextern\tint\tnematch(fa *, const char *);\nextern\tbool\tfnematch(fa *, FILE *, char **, int *, int);\nextern\tNode\t*reparse(const char *);\nextern\tNode\t*regexp(void);\nextern\tNode\t*primary(void);\nextern\tNode\t*concat(Node *);\nextern\tNode\t*alt(Node *);\nextern\tNode\t*unary(Node *);\nextern\tint\trelex(void);\nextern\tint\tcgoto(fa *, int, int);\nextern\tvoid\tfreefa(fa *);\n\nextern\tint\tpgetc(void);\nextern\tchar\t*cursource(void);\n\nextern\tNode\t*nodealloc(size_t);\nextern\tNode\t*exptostat(Node *);\nextern\tNode\t*node1(int, Node *);\nextern\tNode\t*node2(int, Node *, Node *);\nextern\tNode\t*node3(int, Node *, Node *, Node *);\nextern\tNode\t*node4(int, Node *, Node *, Node *, Node *);\nextern\tNode\t*stat3(int, Node *, Node *, Node *);\nextern\tNode\t*op2(int, Node *, Node *);\nextern\tNode\t*op1(int, Node *);\nextern\tNode\t*stat1(int, Node *);\nextern\tNode\t*op3(int, Node *, Node *, Node *);\nextern\tNode\t*op4(int, Node *, Node *, Node *, Node *);\nextern\tNode\t*stat2(int, Node *, Node *);\nextern\tNode\t*stat4(int, Node *, Node *, Node *, Node *);\nextern\tNode\t*celltonode(Cell *, int);\nextern\tNode\t*rectonode(void);\nextern\tNode\t*makearr(Node *);\nextern\tNode\t*pa2stat(Node *, Node *, Node *);\nextern\tNode\t*linkum(Node *, Node *);\nextern\tvoid\tdefn(Cell *, Node *, Node *);\nextern\tint\tisarg(const char *);\nextern\tconst char *tokname(int);\nextern\tCell\t*(*proctab[])(Node **, int);\nextern\tint\tptoi(void *);\nextern\tNode\t*itonp(int);\n\nextern\tvoid\tsyminit(void);\nextern\tvoid\targinit(int, char **);\nextern\tvoid\tenvinit(char **);\nextern\tArray\t*makesymtab(int);\nextern\tvoid\tfreesymtab(Cell *);\nextern\tvoid\tfreeelem(Cell *, const char *);\nextern\tCell\t*setsymtab(const char *, const char *, double, unsigned int, Array *);\nextern\tint\thash(const char *, int);\nextern\tvoid\trehash(Array *);\nextern\tCell\t*lookup(const char *, Array *);\nextern\tdouble\tsetfval(Cell *, double);\nextern\tvoid\tfunnyvar(Cell *, const char *);\nextern\tchar\t*setsval(Cell *, const char *);\nextern\tdouble\tgetfval(Cell *);\nextern\tchar\t*getsval(Cell *);\nextern\tchar\t*getpssval(Cell *);     /* for print */\nextern\tchar\t*tostring(const char *);\nextern\tchar\t*tostringN(const char *, size_t);\nextern\tchar\t*qstring(const char *, int);\nextern\tCell\t*catstr(Cell *, Cell *);\n\nextern\tvoid\trecinit(unsigned int);\nextern\tvoid\tinitgetrec(void);\nextern\tvoid\tmakefields(int, int);\nextern\tvoid\tgrowfldtab(int n);\nextern\tvoid\tsavefs(void);\nextern\tint\tgetrec(char **, int *, bool);\nextern\tvoid\tnextfile(void);\nextern\tint\treadrec(char **buf, int *bufsize, FILE *inf, bool isnew);\nextern\tchar\t*getargv(int);\nextern\tvoid\tsetclvar(char *);\nextern\tvoid\tfldbld(void);\nextern\tvoid\tcleanfld(int, int);\nextern\tvoid\tnewfld(int);\nextern\tvoid\tsetlastfld(int);\nextern\tint\trefldbld(const char *, const char *);\nextern\tvoid\trecbld(void);\nextern\tCell\t*fieldadr(int);\nextern\tvoid\tyyerror(const char *);\nextern\tvoid\tbracecheck(void);\nextern\tvoid\tbcheck2(int, int, int);\nextern\tvoid\tSYNTAX(const char *, ...)\n    __attribute__((__format__(__printf__, 1, 2)));\nextern\tnoreturn void\tFATAL(const char *, ...)\n    __attribute__((__format__(__printf__, 1, 2)));\nextern\tvoid\tWARNING(const char *, ...)\n    __attribute__((__format__(__printf__, 1, 2)));\nextern\tvoid\terror(void);\nextern\tvoid\teprint(void);\nextern\tvoid\tbclass(int);\nextern\tdouble\terrcheck(double, const char *);\nextern\tint\tisclvar(const char *);\nextern\tbool\tis_valid_number(const char *s, bool trailing_stuff_ok,\n\t\t\t\tbool *no_trailing, double *result);\n#define is_number(s, val)\tis_valid_number(s, false, NULL, val)\n\nextern\tint\tadjbuf(char **pb, int *sz, int min, int q, char **pbp, const char *what);\nextern\tvoid\trun(Node *);\nextern\tCell\t*execute(Node *);\nextern\tCell\t*program(Node **, int);\nextern\tCell\t*call(Node **, int);\nextern\tCell\t*copycell(Cell *);\nextern\tCell\t*arg(Node **, int);\nextern\tCell\t*jump(Node **, int);\nextern\tCell\t*awkgetline(Node **, int);\nextern\tCell\t*getnf(Node **, int);\nextern\tCell\t*array(Node **, int);\nextern\tCell\t*awkdelete(Node **, int);\nextern\tCell\t*intest(Node **, int);\nextern\tCell\t*matchop(Node **, int);\nextern\tCell\t*boolop(Node **, int);\nextern\tCell\t*relop(Node **, int);\nextern\tvoid\ttfree(Cell *);\nextern\tCell\t*gettemp(void);\nextern\tCell\t*indirect(Node **, int);\nextern\tCell\t*substr(Node **, int);\nextern\tCell\t*sindex(Node **, int);\nextern\tint\tformat(char **, int *, const char *, Node *);\nextern\tCell\t*awksprintf(Node **, int);\nextern\tCell\t*awkprintf(Node **, int);\nextern\tCell\t*arith(Node **, int);\nextern\tdouble\tipow(double, int);\nextern\tCell\t*incrdecr(Node **, int);\nextern\tCell\t*assign(Node **, int);\nextern\tCell\t*cat(Node **, int);\nextern\tCell\t*pastat(Node **, int);\nextern\tCell\t*dopa2(Node **, int);\nextern\tCell\t*split(Node **, int);\nextern\tCell\t*condexpr(Node **, int);\nextern\tCell\t*ifstat(Node **, int);\nextern\tCell\t*whilestat(Node **, int);\nextern\tCell\t*dostat(Node **, int);\nextern\tCell\t*forstat(Node **, int);\nextern\tCell\t*instat(Node **, int);\nextern\tCell\t*bltin(Node **, int);\nextern\tCell\t*printstat(Node **, int);\nextern\tCell\t*nullproc(Node **, int);\nextern\tFILE\t*redirect(int, Node *);\nextern\tFILE\t*openfile(int, const char *, bool *);\nextern\tconst char\t*filename(FILE *);\nextern\tCell\t*closefile(Node **, int);\nextern\tvoid\tcloseall(void);\nextern\tCell\t*dosub(Node **, int);\n\nextern\tFILE\t*popen(const char *, const char *);\nextern\tint\tpclose(FILE *);\n\nextern  const char\t*flags2str(int flags);\n"
        },
        {
          "name": "run.c",
          "type": "blob",
          "size": 58.4130859375,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#define DEBUG\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <wctype.h>\n#include <fcntl.h>\n#include <setjmp.h>\n#include <limits.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include \"awk.h\"\n#include \"awkgram.tab.h\"\n\n\nstatic void stdinit(void);\nstatic void flush_all(void);\nstatic char *wide_char_to_byte_str(int rune, size_t *outlen);\n\n#if 1\n#define tempfree(x)\tdo { if (istemp(x)) tfree(x); } while (/*CONSTCOND*/0)\n#else\nvoid tempfree(Cell *p) {\n\tif (p->ctype == OCELL && (p->csub < CUNK || p->csub > CFREE)) {\n\t\tWARNING(\"bad csub %d in Cell %d %s\",\n\t\t\tp->csub, p->ctype, p->sval);\n\t}\n\tif (istemp(p))\n\t\ttfree(p);\n}\n#endif\n\n/* do we really need these? */\n/* #ifdef _NFILE */\n/* #ifndef FOPEN_MAX */\n/* #define FOPEN_MAX _NFILE */\n/* #endif */\n/* #endif */\n/*  */\n/* #ifndef\tFOPEN_MAX */\n/* #define\tFOPEN_MAX\t40 */\t/* max number of open files */\n/* #endif */\n/*  */\n/* #ifndef RAND_MAX */\n/* #define RAND_MAX\t32767 */\t/* all that ansi guarantees */\n/* #endif */\n\njmp_buf env;\nextern\tint\tpairstack[];\nextern\tAwkfloat\tsrand_seed;\n\nNode\t*winner = NULL;\t/* root of parse tree */\nCell\t*tmps;\t\t/* free temporary cells for execution */\n\nstatic Cell\ttruecell\t={ OBOOL, BTRUE, 0, 0, 1.0, NUM, NULL, NULL };\nCell\t*True\t= &truecell;\nstatic Cell\tfalsecell\t={ OBOOL, BFALSE, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*False\t= &falsecell;\nstatic Cell\tbreakcell\t={ OJUMP, JBREAK, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jbreak\t= &breakcell;\nstatic Cell\tcontcell\t={ OJUMP, JCONT, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jcont\t= &contcell;\nstatic Cell\tnextcell\t={ OJUMP, JNEXT, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jnext\t= &nextcell;\nstatic Cell\tnextfilecell\t={ OJUMP, JNEXTFILE, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jnextfile\t= &nextfilecell;\nstatic Cell\texitcell\t={ OJUMP, JEXIT, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jexit\t= &exitcell;\nstatic Cell\tretcell\t\t={ OJUMP, JRET, 0, 0, 0.0, NUM, NULL, NULL };\nCell\t*jret\t= &retcell;\nstatic Cell\ttempcell\t={ OCELL, CTEMP, 0, EMPTY, 0.0, NUM|STR|DONTFREE, NULL, NULL };\n\nNode\t*curnode = NULL;\t/* the node being executed, for debugging */\n\n/* buffer memory management */\nint adjbuf(char **pbuf, int *psiz, int minlen, int quantum, char **pbptr,\n\tconst char *whatrtn)\n/* pbuf:    address of pointer to buffer being managed\n * psiz:    address of buffer size variable\n * minlen:  minimum length of buffer needed\n * quantum: buffer size quantum\n * pbptr:   address of movable pointer into buffer, or 0 if none\n * whatrtn: name of the calling routine if failure should cause fatal error\n *\n * return   0 for realloc failure, !=0 for success\n */\n{\n\tif (minlen > *psiz) {\n\t\tchar *tbuf;\n\t\tint rminlen = quantum ? minlen % quantum : 0;\n\t\tint boff = pbptr ? *pbptr - *pbuf : 0;\n\t\t/* round up to next multiple of quantum */\n\t\tif (rminlen)\n\t\t\tminlen += quantum - rminlen;\n\t\ttbuf = (char *) realloc(*pbuf, minlen);\n\t\tDPRINTF(\"adjbuf %s: %d %d (pbuf=%p, tbuf=%p)\\n\", whatrtn, *psiz, minlen, (void*)*pbuf, (void*)tbuf);\n\t\tif (tbuf == NULL) {\n\t\t\tif (whatrtn)\n\t\t\t\tFATAL(\"out of memory in %s\", whatrtn);\n\t\t\treturn 0;\n\t\t}\n\t\t*pbuf = tbuf;\n\t\t*psiz = minlen;\n\t\tif (pbptr)\n\t\t\t*pbptr = tbuf + boff;\n\t}\n\treturn 1;\n}\n\nvoid run(Node *a)\t/* execution of parse tree starts here */\n{\n\n\tstdinit();\n\texecute(a);\n\tcloseall();\n}\n\nCell *execute(Node *u)\t/* execute a node of the parse tree */\n{\n\tCell *(*proc)(Node **, int);\n\tCell *x;\n\tNode *a;\n\n\tif (u == NULL)\n\t\treturn(True);\n\tfor (a = u; ; a = a->nnext) {\n\t\tcurnode = a;\n\t\tif (isvalue(a)) {\n\t\t\tx = (Cell *) (a->narg[0]);\n\t\t\tif (isfld(x) && !donefld)\n\t\t\t\tfldbld();\n\t\t\telse if (isrec(x) && !donerec)\n\t\t\t\trecbld();\n\t\t\treturn(x);\n\t\t}\n\t\tif (notlegal(a->nobj))\t/* probably a Cell* but too risky to print */\n\t\t\tFATAL(\"illegal statement\");\n\t\tproc = proctab[a->nobj-FIRSTTOKEN];\n\t\tx = (*proc)(a->narg, a->nobj);\n\t\tif (isfld(x) && !donefld)\n\t\t\tfldbld();\n\t\telse if (isrec(x) && !donerec)\n\t\t\trecbld();\n\t\tif (isexpr(a))\n\t\t\treturn(x);\n\t\tif (isjump(x))\n\t\t\treturn(x);\n\t\tif (a->nnext == NULL)\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t}\n}\n\n\nCell *program(Node **a, int n)\t/* execute an awk program */\n{\t\t\t\t/* a[0] = BEGIN, a[1] = body, a[2] = END */\n\tCell *x;\n\n\tif (setjmp(env) != 0)\n\t\tgoto ex;\n\tif (a[0]) {\t\t/* BEGIN */\n\t\tx = execute(a[0]);\n\t\tif (isexit(x))\n\t\t\treturn(True);\n\t\tif (isjump(x))\n\t\t\tFATAL(\"illegal break, continue, next or nextfile from BEGIN\");\n\t\ttempfree(x);\n\t}\n\tif (a[1] || a[2])\n\t\twhile (getrec(&record, &recsize, true) > 0) {\n\t\t\tx = execute(a[1]);\n\t\t\tif (isexit(x))\n\t\t\t\tbreak;\n\t\t\ttempfree(x);\n\t\t}\n  ex:\n\tif (setjmp(env) != 0)\t/* handles exit within END */\n\t\tgoto ex1;\n\tif (a[2]) {\t\t/* END */\n\t\tx = execute(a[2]);\n\t\tif (isbreak(x) || isnext(x) || iscont(x))\n\t\t\tFATAL(\"illegal break, continue, next or nextfile from END\");\n\t\ttempfree(x);\n\t}\n  ex1:\n\treturn(True);\n}\n\nstruct Frame {\t/* stack frame for awk function calls */\n\tint nargs;\t/* number of arguments in this call */\n\tCell *fcncell;\t/* pointer to Cell for function */\n\tCell **args;\t/* pointer to array of arguments after execute */\n\tCell *retval;\t/* return value */\n};\n\n#define\tNARGS\t50\t/* max args in a call */\n\nstruct Frame *frame = NULL;\t/* base of stack frames; dynamically allocated */\nint\tnframe = 0;\t\t/* number of frames allocated */\nstruct Frame *frp = NULL;\t/* frame pointer. bottom level unused */\n\nCell *call(Node **a, int n)\t/* function call.  very kludgy and fragile */\n{\n\tstatic const Cell newcopycell = { OCELL, CCOPY, 0, EMPTY, 0.0, NUM|STR|DONTFREE, NULL, NULL };\n\tint i, ncall, ndef;\n\tint freed = 0; /* handles potential double freeing when fcn & param share a tempcell */\n\tNode *x;\n\tCell *args[NARGS], *oargs[NARGS];\t/* BUG: fixed size arrays */\n\tCell *y, *z, *fcn;\n\tchar *s;\n\n\tfcn = execute(a[0]);\t/* the function itself */\n\ts = fcn->nval;\n\tif (!isfcn(fcn))\n\t\tFATAL(\"calling undefined function %s\", s);\n\tif (frame == NULL) {\n\t\tfrp = frame = (struct Frame *) calloc(nframe += 100, sizeof(*frame));\n\t\tif (frame == NULL)\n\t\t\tFATAL(\"out of space for stack frames calling %s\", s);\n\t}\n\tfor (ncall = 0, x = a[1]; x != NULL; x = x->nnext)\t/* args in call */\n\t\tncall++;\n\tndef = (int) fcn->fval;\t\t\t/* args in defn */\n\tDPRINTF(\"calling %s, %d args (%d in defn), frp=%d\\n\", s, ncall, ndef, (int) (frp-frame));\n\tif (ncall > ndef)\n\t\tWARNING(\"function %s called with %d args, uses only %d\",\n\t\t\ts, ncall, ndef);\n\tif (ncall + ndef > NARGS)\n\t\tFATAL(\"function %s has %d arguments, limit %d\", s, ncall+ndef, NARGS);\n\tfor (i = 0, x = a[1]; x != NULL; i++, x = x->nnext) {\t/* get call args */\n\t\tDPRINTF(\"evaluate args[%d], frp=%d:\\n\", i, (int) (frp-frame));\n\t\ty = execute(x);\n\t\toargs[i] = y;\n\t\tDPRINTF(\"args[%d]: %s %f <%s>, t=%o\\n\",\n\t\t\ti, NN(y->nval), y->fval, isarr(y) ? \"(array)\" : NN(y->sval), y->tval);\n\t\tif (isfcn(y))\n\t\t\tFATAL(\"can't use function %s as argument in %s\", y->nval, s);\n\t\tif (isarr(y))\n\t\t\targs[i] = y;\t/* arrays by ref */\n\t\telse\n\t\t\targs[i] = copycell(y);\n\t\ttempfree(y);\n\t}\n\tfor ( ; i < ndef; i++) {\t/* add null args for ones not provided */\n\t\targs[i] = gettemp();\n\t\t*args[i] = newcopycell;\n\t}\n\tfrp++;\t/* now ok to up frame */\n\tif (frp >= frame + nframe) {\n\t\tint dfp = frp - frame;\t/* old index */\n\t\tframe = (struct Frame *) realloc(frame, (nframe += 100) * sizeof(*frame));\n\t\tif (frame == NULL)\n\t\t\tFATAL(\"out of space for stack frames in %s\", s);\n\t\tfrp = frame + dfp;\n\t}\n\tfrp->fcncell = fcn;\n\tfrp->args = args;\n\tfrp->nargs = ndef;\t/* number defined with (excess are locals) */\n\tfrp->retval = gettemp();\n\n\tDPRINTF(\"start exec of %s, frp=%d\\n\", s, (int) (frp-frame));\n\ty = execute((Node *)(fcn->sval));\t/* execute body */\n\tDPRINTF(\"finished exec of %s, frp=%d\\n\", s, (int) (frp-frame));\n\n\tfor (i = 0; i < ndef; i++) {\n\t\tCell *t = frp->args[i];\n\t\tif (isarr(t)) {\n\t\t\tif (t->csub == CCOPY) {\n\t\t\t\tif (i >= ncall) {\n\t\t\t\t\tfreesymtab(t);\n\t\t\t\t\tt->csub = CTEMP;\n\t\t\t\t\ttempfree(t);\n\t\t\t\t} else {\n\t\t\t\t\toargs[i]->tval = t->tval;\n\t\t\t\t\toargs[i]->tval &= ~(STR|NUM|DONTFREE);\n\t\t\t\t\toargs[i]->sval = t->sval;\n\t\t\t\t\ttempfree(t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t != y) {\t/* kludge to prevent freeing twice */\n\t\t\tt->csub = CTEMP;\n\t\t\ttempfree(t);\n\t\t} else if (t == y && t->csub == CCOPY) {\n\t\t\tt->csub = CTEMP;\n\t\t\ttempfree(t);\n\t\t\tfreed = 1;\n\t\t}\n\t}\n\ttempfree(fcn);\n\tif (isexit(y) || isnext(y))\n\t\treturn y;\n\tif (freed == 0) {\n\t\ttempfree(y);\t/* don't free twice! */\n\t}\n\tz = frp->retval;\t\t\t/* return value */\n\tDPRINTF(\"%s returns %g |%s| %o\\n\", s, getfval(z), getsval(z), z->tval);\n\tfrp--;\n\treturn(z);\n}\n\nCell *copycell(Cell *x)\t/* make a copy of a cell in a temp */\n{\n\tCell *y;\n\n\t/* copy is not constant or field */\n\n\ty = gettemp();\n\ty->tval = x->tval & ~(CON|FLD|REC);\n\ty->csub = CCOPY;\t/* prevents freeing until call is over */\n\ty->nval = x->nval;\t/* BUG? */\n\tif (isstr(x) /* || x->ctype == OCELL */) {\n\t\ty->sval = tostring(x->sval);\n\t\ty->tval &= ~DONTFREE;\n\t} else\n\t\ty->tval |= DONTFREE;\n\ty->fval = x->fval;\n\treturn y;\n}\n\nCell *arg(Node **a, int n)\t/* nth argument of a function */\n{\n\n\tn = ptoi(a[0]);\t/* argument number, counting from 0 */\n\tDPRINTF(\"arg(%d), frp->nargs=%d\\n\", n, frp->nargs);\n\tif (n+1 > frp->nargs)\n\t\tFATAL(\"argument #%d of function %s was not supplied\",\n\t\t\tn+1, frp->fcncell->nval);\n\treturn frp->args[n];\n}\n\nCell *jump(Node **a, int n)\t/* break, continue, next, nextfile, return */\n{\n\tCell *y;\n\n\tswitch (n) {\n\tcase EXIT:\n\t\tif (a[0] != NULL) {\n\t\t\ty = execute(a[0]);\n\t\t\terrorflag = (int) getfval(y);\n\t\t\ttempfree(y);\n\t\t}\n\t\tlongjmp(env, 1);\n\tcase RETURN:\n\t\tif (a[0] != NULL) {\n\t\t\ty = execute(a[0]);\n\t\t\tif ((y->tval & (STR|NUM)) == (STR|NUM)) {\n\t\t\t\tsetsval(frp->retval, getsval(y));\n\t\t\t\tfrp->retval->fval = getfval(y);\n\t\t\t\tfrp->retval->tval |= NUM;\n\t\t\t}\n\t\t\telse if (y->tval & STR)\n\t\t\t\tsetsval(frp->retval, getsval(y));\n\t\t\telse if (y->tval & NUM)\n\t\t\t\tsetfval(frp->retval, getfval(y));\n\t\t\telse\t\t/* can't happen */\n\t\t\t\tFATAL(\"bad type variable %d\", y->tval);\n\t\t\ttempfree(y);\n\t\t}\n\t\treturn(jret);\n\tcase NEXT:\n\t\treturn(jnext);\n\tcase NEXTFILE:\n\t\tnextfile();\n\t\treturn(jnextfile);\n\tcase BREAK:\n\t\treturn(jbreak);\n\tcase CONTINUE:\n\t\treturn(jcont);\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"illegal jump type %d\", n);\n\t}\n\treturn 0;\t/* not reached */\n}\n\nCell *awkgetline(Node **a, int n)\t/* get next line from specific input */\n{\t\t/* a[0] is variable, a[1] is operator, a[2] is filename */\n\tCell *r, *x;\n\textern Cell **fldtab;\n\tFILE *fp;\n\tchar *buf;\n\tint bufsize = recsize;\n\tint mode;\n\tbool newflag;\n\tdouble result;\n\n\tif ((buf = (char *) malloc(bufsize)) == NULL)\n\t\tFATAL(\"out of memory in getline\");\n\n\tfflush(stdout);\t/* in case someone is waiting for a prompt */\n\tr = gettemp();\n\tif (a[1] != NULL) {\t\t/* getline < file */\n\t\tx = execute(a[2]);\t\t/* filename */\n\t\tmode = ptoi(a[1]);\n\t\tif (mode == '|')\t\t/* input pipe */\n\t\t\tmode = LE;\t/* arbitrary flag */\n\t\tfp = openfile(mode, getsval(x), &newflag);\n\t\ttempfree(x);\n\t\tif (fp == NULL)\n\t\t\tn = -1;\n\t\telse\n\t\t\tn = readrec(&buf, &bufsize, fp, newflag);\n\t\tif (n <= 0) {\n\t\t\t;\n\t\t} else if (a[0] != NULL) {\t/* getline var <file */\n\t\t\tx = execute(a[0]);\n\t\t\tsetsval(x, buf);\n\t\t\tif (is_number(x->sval, & result)) {\n\t\t\t\tx->fval = result;\n\t\t\t\tx->tval |= NUM;\n\t\t\t}\n\t\t\ttempfree(x);\n\t\t} else {\t\t\t/* getline <file */\n\t\t\tsetsval(fldtab[0], buf);\n\t\t\tif (is_number(fldtab[0]->sval, & result)) {\n\t\t\t\tfldtab[0]->fval = result;\n\t\t\t\tfldtab[0]->tval |= NUM;\n\t\t\t}\n\t\t}\n\t} else {\t\t\t/* bare getline; use current input */\n\t\tif (a[0] == NULL)\t/* getline */\n\t\t\tn = getrec(&record, &recsize, true);\n\t\telse {\t\t\t/* getline var */\n\t\t\tn = getrec(&buf, &bufsize, false);\n\t\t\tif (n > 0) {\n\t\t\t\tx = execute(a[0]);\n\t\t\t\tsetsval(x, buf);\n\t\t\t\tif (is_number(x->sval, & result)) {\n\t\t\t\t\tx->fval = result;\n\t\t\t\t\tx->tval |= NUM;\n\t\t\t\t}\n\t\t\t\ttempfree(x);\n\t\t\t}\n\t\t}\n\t}\n\tsetfval(r, (Awkfloat) n);\n\tfree(buf);\n\treturn r;\n}\n\nCell *getnf(Node **a, int n)\t/* get NF */\n{\n\tif (!donefld)\n\t\tfldbld();\n\treturn (Cell *) a[0];\n}\n\nstatic char *\nmakearraystring(Node *p, const char *func)\n{\n\tchar *buf;\n\tint bufsz = recsize;\n\tsize_t blen;\n\n\tif ((buf = (char *) malloc(bufsz)) == NULL) {\n\t\tFATAL(\"%s: out of memory\", func);\n\t}\n\n\tblen = 0;\n\tbuf[blen] = '\\0';\n\n\tfor (; p; p = p->nnext) {\n\t\tCell *x = execute(p);\t/* expr */\n\t\tchar *s = getsval(x);\n\t\tsize_t seplen = strlen(getsval(subseploc));\n\t\tsize_t nsub = p->nnext ? seplen : 0;\n\t\tsize_t slen = strlen(s);\n\t\tsize_t tlen = blen + slen + nsub;\n\n\t\tif (!adjbuf(&buf, &bufsz, tlen + 1, recsize, 0, func)) {\n\t\t\tFATAL(\"%s: out of memory %s[%s...]\",\n\t\t\t    func, x->nval, buf);\n\t\t}\n\t\tmemcpy(buf + blen, s, slen);\n\t\tif (nsub) {\n\t\t\tmemcpy(buf + blen + slen, *SUBSEP, nsub);\n\t\t}\n\t\tbuf[tlen] = '\\0';\n\t\tblen = tlen;\n\t\ttempfree(x);\n\t}\n\treturn buf;\n}\n\nCell *array(Node **a, int n)\t/* a[0] is symtab, a[1] is list of subscripts */\n{\n\tCell *x, *z;\n\tchar *buf;\n\n\tx = execute(a[0]);\t/* Cell* for symbol table */\n\tbuf = makearraystring(a[1], __func__);\n\tif (!isarr(x)) {\n\t\tDPRINTF(\"making %s into an array\\n\", NN(x->nval));\n\t\tif (freeable(x))\n\t\t\txfree(x->sval);\n\t\tx->tval &= ~(STR|NUM|DONTFREE);\n\t\tx->tval |= ARR;\n\t\tx->sval = (char *) makesymtab(NSYMTAB);\n\t}\n\tz = setsymtab(buf, \"\", 0.0, STR|NUM, (Array *) x->sval);\n\tz->ctype = OCELL;\n\tz->csub = CVAR;\n\ttempfree(x);\n\tfree(buf);\n\treturn(z);\n}\n\nCell *awkdelete(Node **a, int n)\t/* a[0] is symtab, a[1] is list of subscripts */\n{\n\tCell *x;\n\n\tx = execute(a[0]);\t/* Cell* for symbol table */\n\tif (x == symtabloc) {\n\t\tFATAL(\"cannot delete SYMTAB or its elements\");\n\t}\n\tif (!isarr(x))\n\t\treturn True;\n\tif (a[1] == NULL) {\t/* delete the elements, not the table */\n\t\tfreesymtab(x);\n\t\tx->tval &= ~STR;\n\t\tx->tval |= ARR;\n\t\tx->sval = (char *) makesymtab(NSYMTAB);\n\t} else {\n\t\tchar *buf = makearraystring(a[1], __func__);\n\t\tfreeelem(x, buf);\n\t\tfree(buf);\n\t}\n\ttempfree(x);\n\treturn True;\n}\n\nCell *intest(Node **a, int n)\t/* a[0] is index (list), a[1] is symtab */\n{\n\tCell *ap, *k;\n\tchar *buf;\n\n\tap = execute(a[1]);\t/* array name */\n\tif (!isarr(ap)) {\n\t\tDPRINTF(\"making %s into an array\\n\", ap->nval);\n\t\tif (freeable(ap))\n\t\t\txfree(ap->sval);\n\t\tap->tval &= ~(STR|NUM|DONTFREE);\n\t\tap->tval |= ARR;\n\t\tap->sval = (char *) makesymtab(NSYMTAB);\n\t}\n\tbuf = makearraystring(a[0], __func__);\n\tk = lookup(buf, (Array *) ap->sval);\n\ttempfree(ap);\n\tfree(buf);\n\tif (k == NULL)\n\t\treturn(False);\n\telse\n\t\treturn(True);\n}\n\n\n/* ======== utf-8 code ========== */\n\n/*\n * Awk strings can contain ascii, random 8-bit items (eg Latin-1),\n * or utf-8.  u8_isutf tests whether a string starts with a valid\n * utf-8 sequence, and returns 0 if not (e.g., high bit set).\n * u8_nextlen returns length of next valid sequence, which is\n * 1 for ascii, 2..4 for utf-8, or 1 for high bit non-utf.\n * u8_strlen returns length of string in valid utf-8 sequences\n * and/or high-bit bytes.  Conversion functions go between byte\n * number and character number.\n *\n * In theory, this behaves the same as before for non-utf8 bytes.\n *\n * Limited checking! This is a potential security hole.\n */\n\n/* is s the beginning of a valid utf-8 string? */\n/* return length 1..4 if yes, 0 if no */\nint u8_isutf(const char *s)\n{\n\tint n, ret;\n\tunsigned char c;\n\n\tc = s[0];\n\tif (c < 128 || awk_mb_cur_max == 1)\n\t\treturn 1; /* what if it's 0? */\n\n\tn = strlen(s);\n\tif (n >= 2 && ((c>>5) & 0x7) == 0x6 && (s[1] & 0xC0) == 0x80) {\n\t\tret = 2; /* 110xxxxx 10xxxxxx */\n\t} else if (n >= 3 && ((c>>4) & 0xF) == 0xE && (s[1] & 0xC0) == 0x80\n\t\t\t && (s[2] & 0xC0) == 0x80) {\n\t\tret = 3; /* 1110xxxx 10xxxxxx 10xxxxxx */\n\t} else if (n >= 4 && ((c>>3) & 0x1F) == 0x1E && (s[1] & 0xC0) == 0x80\n\t\t\t && (s[2] & 0xC0) == 0x80 && (s[3] & 0xC0) == 0x80) {\n\t\tret = 4; /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n\t} else {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n/* Convert (prefix of) utf8 string to utf-32 rune. */\n/* Sets *rune to the value, returns the length. */\n/* No error checking: watch out. */\nint u8_rune(int *rune, const char *s)\n{\n\tint n, ret;\n\tunsigned char c;\n\n\tc = s[0];\n\tif (c < 128 || awk_mb_cur_max == 1) {\n\t\t*rune = c;\n\t\treturn 1;\n\t}\n\n\tn = strlen(s);\n\tif (n >= 2 && ((c>>5) & 0x7) == 0x6 && (s[1] & 0xC0) == 0x80) {\n\t\t*rune = ((c & 0x1F) << 6) | (s[1] & 0x3F); /* 110xxxxx 10xxxxxx */\n\t\tret = 2;\n\t} else if (n >= 3 && ((c>>4) & 0xF) == 0xE && (s[1] & 0xC0) == 0x80\n\t\t\t  && (s[2] & 0xC0) == 0x80) {\n\t\t*rune = ((c & 0xF) << 12) | ((s[1] & 0x3F) << 6) | (s[2] & 0x3F);\n\t\t\t/* 1110xxxx 10xxxxxx 10xxxxxx */\n\t\tret = 3;\n\t} else if (n >= 4 && ((c>>3) & 0x1F) == 0x1E && (s[1] & 0xC0) == 0x80\n\t\t\t  && (s[2] & 0xC0) == 0x80 && (s[3] & 0xC0) == 0x80) {\n\t\t*rune = ((c & 0x7) << 18) | ((s[1] & 0x3F) << 12) | ((s[2] & 0x3F) << 6) | (s[3] & 0x3F);\n\t\t\t/* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n\t\tret = 4;\n\t} else {\n\t\t*rune = c;\n\t\tret = 1;\n\t}\n\treturn ret; /* returns one byte if sequence doesn't look like utf */\n}\n\n/* return length of next sequence: 1 for ascii or random, 2..4 for valid utf8 */\nint u8_nextlen(const char *s)\n{\n\tint len;\n\n\tlen = u8_isutf(s);\n\tif (len == 0)\n\t\tlen = 1;\n\treturn len;\n}\n\n/* return number of utf characters or single non-utf bytes */\nint u8_strlen(const char *s)\n{\n\tint i, len, n, totlen;\n\tunsigned char c;\n\n\tn = strlen(s);\n\ttotlen = 0;\n\tfor (i = 0; i < n; i += len) {\n\t\tc = s[i];\n\t\tif (c < 128 || awk_mb_cur_max == 1) {\n\t\t\tlen = 1;\n\t\t} else {\n\t\t\tlen = u8_nextlen(&s[i]);\n\t\t}\n\t\ttotlen++;\n\t\tif (i > n)\n\t\t\tFATAL(\"bad utf count [%s] n=%d i=%d\\n\", s, n, i);\n\t}\n\treturn totlen;\n}\n\n/* convert utf-8 char number in a string to its byte offset */\nint u8_char2byte(const char *s, int charnum)\n{\n\tint n;\n\tint bytenum = 0;\n\n\twhile (charnum > 0) {\n\t\tn = u8_nextlen(s);\n\t\ts += n;\n\t\tbytenum += n;\n\t\tcharnum--;\n\t}\n\treturn bytenum;\n}\n\n/* convert byte offset in s to utf-8 char number that starts there */\nint u8_byte2char(const char *s, int bytenum)\n{\n\tint i, len, b;\n\tint charnum = 0; /* BUG: what origin? */\n\t/* should be 0 to match start==0 which means no match */\t\n\n\tb = strlen(s);\n\tif (bytenum > b) {\n\t\treturn -1; /* ??? */\n\t}\n\tfor (i = 0; i <= bytenum; i += len) {\n\t\tlen = u8_nextlen(s+i);\n\t\tcharnum++;\n\t}\n\treturn charnum;\n}\n\n/* runetochar() adapted from rune.c in the Plan 9 distribution */\n\nenum\n{\n\tRuneerror = 128, /* from somewhere else */\n\tRunemax = 0x10FFFF,\n\n\tBit1    = 7,\n\tBitx    = 6,\n\tBit2    = 5,\n\tBit3    = 4,\n\tBit4    = 3,\n\tBit5    = 2,\n\n\tT1      = ((1<<(Bit1+1))-1) ^ 0xFF,     /* 0000 0000 */\n\tTx      = ((1<<(Bitx+1))-1) ^ 0xFF,     /* 1000 0000 */\n\tT2      = ((1<<(Bit2+1))-1) ^ 0xFF,     /* 1100 0000 */\n\tT3      = ((1<<(Bit3+1))-1) ^ 0xFF,     /* 1110 0000 */\n\tT4      = ((1<<(Bit4+1))-1) ^ 0xFF,     /* 1111 0000 */\n\tT5      = ((1<<(Bit5+1))-1) ^ 0xFF,     /* 1111 1000 */\n\n\tRune1   = (1<<(Bit1+0*Bitx))-1,\t \t/* 0000 0000 0000 0000 0111 1111 */\n\tRune2   = (1<<(Bit2+1*Bitx))-1,\t \t/* 0000 0000 0000 0111 1111 1111 */\n\tRune3   = (1<<(Bit3+2*Bitx))-1,\t \t/* 0000 0000 1111 1111 1111 1111 */\n\tRune4   = (1<<(Bit4+3*Bitx))-1,\t \t/* 0011 1111 1111 1111 1111 1111 */\n\n\tMaskx   = (1<<Bitx)-1,\t\t  \t/* 0011 1111 */\n\tTestx   = Maskx ^ 0xFF,\t\t \t/* 1100 0000 */\n\n};\n\nint runetochar(char *str, int c)\n{\t\n\t/* one character sequence 00000-0007F => 00-7F */     \n\tif (c <= Rune1) {\n\t\tstr[0] = c;\n\t\treturn 1;\n\t}\n\t\n\t/* two character sequence 00080-007FF => T2 Tx */\n\tif (c <= Rune2) {\n\t\tstr[0] = T2 | (c >> 1*Bitx);\n\t\tstr[1] = Tx | (c & Maskx);\n\t\treturn 2;\n\t}\n\n\t/* three character sequence 00800-0FFFF => T3 Tx Tx */\n\tif (c > Runemax)\n\t\tc = Runeerror;\n\tif (c <= Rune3) {\n\t\tstr[0] = T3 |  (c >> 2*Bitx);\n\t\tstr[1] = Tx | ((c >> 1*Bitx) & Maskx);\n\t\tstr[2] = Tx |  (c & Maskx);\n\t\treturn 3;\n\t}\n\t\n\t/* four character sequence 010000-1FFFFF => T4 Tx Tx Tx */\n\tstr[0] = T4 |  (c >> 3*Bitx);\n\tstr[1] = Tx | ((c >> 2*Bitx) & Maskx);\n\tstr[2] = Tx | ((c >> 1*Bitx) & Maskx);\n\tstr[3] = Tx |  (c & Maskx);\n\treturn 4;\n}               \n\n\n/* ========== end of utf8 code =========== */\n\n\n\nCell *matchop(Node **a, int n)\t/* ~ and match() */\n{\n\tCell *x, *y, *z;\n\tchar *s, *t;\n\tint i;\n\tint cstart, cpatlen, len;\n\tfa *pfa;\n\tint (*mf)(fa *, const char *) = match, mode = 0;\n\n\tif (n == MATCHFCN) {\n\t\tmf = pmatch;\n\t\tmode = 1;\n\t}\n\tx = execute(a[1]);\t/* a[1] = target text */\n\ts = getsval(x);\n\tif (a[0] == NULL)\t/* a[1] == 0: already-compiled reg expr */\n\t\ti = (*mf)((fa *) a[2], s);\n\telse {\n\t\ty = execute(a[2]);\t/* a[2] = regular expr */\n\t\tt = getsval(y);\n\t\tpfa = makedfa(t, mode);\n\t\ti = (*mf)(pfa, s);\n\t\ttempfree(y);\n\t}\n\tz = x;\n\tif (n == MATCHFCN) {\n\t\tint start = patbeg - s + 1; /* origin 1 */\n\t\tif (patlen < 0) {\n\t\t\tstart = 0; /* not found */\n\t\t} else {\n\t\t\tcstart = u8_byte2char(s, start-1);\n\t\t\tcpatlen = 0;\n\t\t\tfor (i = 0; i < patlen; i += len) {\n\t\t\t\tlen = u8_nextlen(patbeg+i);\n\t\t\t\tcpatlen++;\n\t\t\t}\n\n\t\t\tstart = cstart;\n\t\t\tpatlen = cpatlen;\n\t\t}\n\n\t\tsetfval(rstartloc, (Awkfloat) start);\n\t\tsetfval(rlengthloc, (Awkfloat) patlen);\n\t\tx = gettemp();\n\t\tx->tval = NUM;\n\t\tx->fval = start;\n\t} else if ((n == MATCH && i == 1) || (n == NOTMATCH && i == 0))\n\t\tx = True;\n\telse\n\t\tx = False;\n\n\ttempfree(z);\n\treturn x;\n}\n\n\nCell *boolop(Node **a, int n)\t/* a[0] || a[1], a[0] && a[1], !a[0] */\n{\n\tCell *x, *y;\n\tint i;\n\n\tx = execute(a[0]);\n\ti = istrue(x);\n\ttempfree(x);\n\tswitch (n) {\n\tcase BOR:\n\t\tif (i) return(True);\n\t\ty = execute(a[1]);\n\t\ti = istrue(y);\n\t\ttempfree(y);\n\t\tif (i) return(True);\n\t\telse return(False);\n\tcase AND:\n\t\tif ( !i ) return(False);\n\t\ty = execute(a[1]);\n\t\ti = istrue(y);\n\t\ttempfree(y);\n\t\tif (i) return(True);\n\t\telse return(False);\n\tcase NOT:\n\t\tif (i) return(False);\n\t\telse return(True);\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"unknown boolean operator %d\", n);\n\t}\n\treturn 0;\t/*NOTREACHED*/\n}\n\nCell *relop(Node **a, int n)\t/* a[0 < a[1], etc. */\n{\n\tint i;\n\tCell *x, *y;\n\tAwkfloat j;\n\tbool x_is_nan, y_is_nan;\n\n\tx = execute(a[0]);\n\ty = execute(a[1]);\n\tx_is_nan = isnan(x->fval);\n\ty_is_nan = isnan(y->fval);\n\tif (x->tval&NUM && y->tval&NUM) {\n\t\tif ((x_is_nan || y_is_nan) && n != NE)\n\t\t\treturn(False);\n\t\tj = x->fval - y->fval;\n\t\ti = j<0? -1: (j>0? 1: 0);\n\t} else {\n\t\ti = strcmp(getsval(x), getsval(y));\n\t}\n\ttempfree(x);\n\ttempfree(y);\n\tswitch (n) {\n\tcase LT:\tif (i<0) return(True);\n\t\t\telse return(False);\n\tcase LE:\tif (i<=0) return(True);\n\t\t\telse return(False);\n\tcase NE:\tif (x_is_nan && y_is_nan) return(True);\n\t\t\telse if (i!=0) return(True);\n\t\t\telse return(False);\n\tcase EQ:\tif (i == 0) return(True);\n\t\t\telse return(False);\n\tcase GE:\tif (i>=0) return(True);\n\t\t\telse return(False);\n\tcase GT:\tif (i>0) return(True);\n\t\t\telse return(False);\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"unknown relational operator %d\", n);\n\t}\n\treturn 0;\t/*NOTREACHED*/\n}\n\nvoid tfree(Cell *a)\t/* free a tempcell */\n{\n\tif (freeable(a)) {\n\t\tDPRINTF(\"freeing %s %s %o\\n\", NN(a->nval), NN(a->sval), a->tval);\n\t\txfree(a->sval);\n\t}\n\tif (a == tmps)\n\t\tFATAL(\"tempcell list is curdled\");\n\ta->cnext = tmps;\n\ttmps = a;\n}\n\nCell *gettemp(void)\t/* get a tempcell */\n{\tint i;\n\tCell *x;\n\n\tif (!tmps) {\n\t\ttmps = (Cell *) calloc(100, sizeof(*tmps));\n\t\tif (!tmps)\n\t\t\tFATAL(\"out of space for temporaries\");\n\t\tfor (i = 1; i < 100; i++)\n\t\t\ttmps[i-1].cnext = &tmps[i];\n\t\ttmps[i-1].cnext = NULL;\n\t}\n\tx = tmps;\n\ttmps = x->cnext;\n\t*x = tempcell;\n\treturn(x);\n}\n\nCell *indirect(Node **a, int n)\t/* $( a[0] ) */\n{\n\tAwkfloat val;\n\tCell *x;\n\tint m;\n\n\tx = execute(a[0]);\n\tval = getfval(x);\t/* freebsd: defend against super large field numbers */\n\tif ((Awkfloat)INT_MAX < val)\n\t\tFATAL(\"trying to access out of range field %s\", x->nval);\n\tm = (int) val;\n\ttempfree(x);\n\tx = fieldadr(m);\n\tx->ctype = OCELL;\t/* BUG?  why are these needed? */\n\tx->csub = CFLD;\n\treturn(x);\n}\n\nCell *substr(Node **a, int nnn)\t\t/* substr(a[0], a[1], a[2]) */\n{\n\tint k, m, n;\n\tint mb, nb;\n\tchar *s;\n\tint temp;\n\tCell *x, *y, *z = NULL;\n\n\tx = execute(a[0]);\n\ty = execute(a[1]);\n\tif (a[2] != NULL)\n\t\tz = execute(a[2]);\n\ts = getsval(x);\n\tk = u8_strlen(s) + 1;\n\tif (k <= 1) {\n\t\ttempfree(x);\n\t\ttempfree(y);\n\t\tif (a[2] != NULL) {\n\t\t\ttempfree(z);\n\t\t}\n\t\tx = gettemp();\n\t\tsetsval(x, \"\");\n\t\treturn(x);\n\t}\n\tm = (int) getfval(y);\n\tif (m <= 0)\n\t\tm = 1;\n\telse if (m > k)\n\t\tm = k;\n\ttempfree(y);\n\tif (a[2] != NULL) {\n\t\tn = (int) getfval(z);\n\t\ttempfree(z);\n\t} else\n\t\tn = k - 1;\n\tif (n < 0)\n\t\tn = 0;\n\telse if (n > k - m)\n\t\tn = k - m;\n\t/* m is start, n is length from there */\n\tDPRINTF(\"substr: m=%d, n=%d, s=%s\\n\", m, n, s);\n\ty = gettemp();\n\tmb = u8_char2byte(s, m-1); /* byte offset of start char in s */\n\tnb = u8_char2byte(s, m-1+n);  /* byte offset of end+1 char in s */\n\n\ttemp = s[nb];\t/* with thanks to John Linderman */\n\ts[nb] = '\\0';\n\tsetsval(y, s + mb);\n\ts[nb] = temp;\n\ttempfree(x);\n\treturn(y);\n}\n\nCell *sindex(Node **a, int nnn)\t\t/* index(a[0], a[1]) */\n{\n\tCell *x, *y, *z;\n\tchar *s1, *s2, *p1, *p2, *q;\n\tAwkfloat v = 0.0;\n\n\tx = execute(a[0]);\n\ts1 = getsval(x);\n\ty = execute(a[1]);\n\ts2 = getsval(y);\n\n\tz = gettemp();\n\tfor (p1 = s1; *p1 != '\\0'; p1++) {\n\t\tfor (q = p1, p2 = s2; *p2 != '\\0' && *q == *p2; q++, p2++)\n\t\t\tcontinue;\n\t\tif (*p2 == '\\0') {\n\t\t\t/* v = (Awkfloat) (p1 - s1 + 1);\t origin 1 */\n\n\t\t   /* should be a function: used in match() as well */\n\t\t\tint i, len;\n\t\t\tv = 0;\n\t\t\tfor (i = 0; i < p1-s1+1; i += len) {\n\t\t\t\tlen = u8_nextlen(s1+i);\n\t\t\t\tv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\ttempfree(x);\n\ttempfree(y);\n\tsetfval(z, v);\n\treturn(z);\n}\n\nint has_utf8(char *s)\t/* return 1 if s contains any utf-8 (2 bytes or more) character */\n{\n\tint n;\n\n\tfor (n = 0; *s != 0; s += n) {\n\t\tn = u8_nextlen(s);\n\t\tif (n > 1)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define\tMAXNUMSIZE\t50\n\nint format(char **pbuf, int *pbufsize, const char *s, Node *a)\t/* printf-like conversions */\n{\n\tchar *fmt;\n\tchar *p, *t;\n\tconst char *os;\n\tCell *x;\n\tint flag = 0, n;\n\tint fmtwd; /* format width */\n\tint fmtsz = recsize;\n\tchar *buf = *pbuf;\n\tint bufsize = *pbufsize;\n#define FMTSZ(a)   (fmtsz - ((a) - fmt))\n#define BUFSZ(a)   (bufsize - ((a) - buf))\n\n\tstatic bool first = true;\n\tstatic bool have_a_format = false;\n\n\tif (first) {\n\t\tchar xbuf[100];\n\n\t\tsnprintf(xbuf, sizeof(xbuf), \"%a\", 42.0);\n\t\thave_a_format = (strcmp(xbuf, \"0x1.5p+5\") == 0);\n\t\tfirst = false;\n\t}\n\n\tos = s;\n\tp = buf;\n\tif ((fmt = (char *) malloc(fmtsz)) == NULL)\n\t\tFATAL(\"out of memory in format()\");\n\twhile (*s) {\n\t\tadjbuf(&buf, &bufsize, MAXNUMSIZE+1+p-buf, recsize, &p, \"format1\");\n\t\tif (*s != '%') {\n\t\t\t*p++ = *s++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*(s+1) == '%') {\n\t\t\t*p++ = '%';\n\t\t\ts += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tfmtwd = atoi(s+1);\n\t\tif (fmtwd < 0)\n\t\t\tfmtwd = -fmtwd;\n\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format2\");\n\t\tfor (t = fmt; (*t++ = *s) != '\\0'; s++) {\n\t\t\tif (!adjbuf(&fmt, &fmtsz, MAXNUMSIZE+1+t-fmt, recsize, &t, \"format3\"))\n\t\t\t\tFATAL(\"format item %.30s... ran format() out of memory\", os);\n\t\t\t/* Ignore size specifiers */\n\t\t\tif (strchr(\"hjLlqtz\", *s) != NULL) {\t/* the ansi panoply */\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isalpha((uschar)*s))\n\t\t\t\tbreak;\n\t\t\tif (*s == '$') {\n\t\t\t\tFATAL(\"'$' not permitted in awk formats\");\n\t\t\t}\n\t\t\tif (*s == '*') {\n\t\t\t\tif (a == NULL) {\n\t\t\t\t\tFATAL(\"not enough args in printf(%s)\", os);\n\t\t\t\t}\n\t\t\t\tx = execute(a);\n\t\t\t\ta = a->nnext;\n\t\t\t\tsnprintf(t - 1, FMTSZ(t - 1),\n\t\t\t\t    \"%d\", fmtwd=(int) getfval(x));\n\t\t\t\tif (fmtwd < 0)\n\t\t\t\t\tfmtwd = -fmtwd;\n\t\t\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format\");\n\t\t\t\tt = fmt + strlen(fmt);\n\t\t\t\ttempfree(x);\n\t\t\t}\n\t\t}\n\t\t*t = '\\0';\n\t\tif (fmtwd < 0)\n\t\t\tfmtwd = -fmtwd;\n\t\tadjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, \"format4\");\n\t\tswitch (*s) {\n\t\tcase 'a': case 'A':\n\t\t\tif (have_a_format)\n\t\t\t\tflag = *s;\n\t\t\telse\n\t\t\t\tflag = 'f';\n\t\t\tbreak;\n\t\tcase 'f': case 'e': case 'g': case 'E': case 'G':\n\t\t\tflag = 'f';\n\t\t\tbreak;\n\t\tcase 'd': case 'i': case 'o': case 'x': case 'X': case 'u':\n\t\t\tflag = (*s == 'd' || *s == 'i') ? 'd' : 'u';\n\t\t\t*(t-1) = 'j';\n\t\t\t*t = *s;\n\t\t\t*++t = '\\0';\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflag = 's';\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflag = 'c';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARNING(\"weird printf conversion %s\", fmt);\n\t\t\tflag = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (a == NULL)\n\t\t\tFATAL(\"not enough args in printf(%s)\", os);\n\t\tx = execute(a);\n\t\ta = a->nnext;\n\t\tn = MAXNUMSIZE;\n\t\tif (fmtwd > n)\n\t\t\tn = fmtwd;\n\t\tadjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, \"format5\");\n\t\tswitch (flag) {\n\t\tcase '?':\n\t\t\tsnprintf(p, BUFSZ(p), \"%s\", fmt);\t/* unknown, so dump it too */\n\t\t\tt = getsval(x);\n\t\t\tn = strlen(t);\n\t\t\tif (fmtwd > n)\n\t\t\t\tn = fmtwd;\n\t\t\tadjbuf(&buf, &bufsize, 1+strlen(p)+n+p-buf, recsize, &p, \"format6\");\n\t\t\tp += strlen(p);\n\t\t\tsnprintf(p, BUFSZ(p), \"%s\", t);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A':\n\t\tcase 'f':\tsnprintf(p, BUFSZ(p), fmt, getfval(x)); break;\n\t\tcase 'd':\tsnprintf(p, BUFSZ(p), fmt, (intmax_t) getfval(x)); break;\n\t\tcase 'u':\tsnprintf(p, BUFSZ(p), fmt, (uintmax_t) getfval(x)); break;\n\n\t\tcase 's': {\n\t\t\tt = getsval(x);\n\t\t\tn = strlen(t);\n\t\t\t/* if simple format or no utf-8 in the string, sprintf works */\n\t\t\tif (!has_utf8(t) || strcmp(fmt,\"%s\") == 0) {\n\t\t\t\tif (fmtwd > n)\n\t\t\t\t\tn = fmtwd;\n\t\t\t\tif (!adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, \"format7\"))\n\t\t\t\t\tFATAL(\"huge string/format (%d chars) in printf %.30s...\" \\\n\t\t\t\t\t\t\" ran format() out of memory\", n, t);\n\t\t\t\tsnprintf(p, BUFSZ(p), fmt, t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* get here if string has utf-8 chars and fmt is not plain %s */\n\t\t\t/* \"%-w.ps\", where -, w and .p are all optional */\n\t\t\t/* '0' before the w is a flag character */\n\t\t\t/* fmt points at % */\n\t\t\tint ljust = 0, wid = 0, prec = n, pad = 0;\n\t\t\tchar *f = fmt+1;\n\t\t\tif (f[0] == '-') {\n\t\t\t\tljust = 1;\n\t\t\t\tf++;\n\t\t\t}\n\t\t\t// flags '0' and '+' are recognized but skipped\n\t\t\tif (f[0] == '0') {\n\t\t\t\tf++;\n\t\t\t\tif (f[0] == '+')\n\t\t\t\t\tf++;\n\t\t\t}\n\t\t\tif (f[0] == '+') {\n\t\t\t\tf++;\n\t\t\t\tif (f[0] == '0')\n\t\t\t\t\tf++;\n\t\t\t}\n\t\t\tif (isdigit(f[0])) { /* there is a wid */\n\t\t\t\twid = strtol(f, &f, 10);\n\t\t\t}\n\t\t\tif (f[0] == '.') { /* there is a .prec */\n\t\t\t\tprec = strtol(++f, &f, 10);\n\t\t\t}\n\t\t\tif (prec > u8_strlen(t))\n\t\t\t\tprec = u8_strlen(t);\n\t\t\tpad = wid>prec ? wid - prec : 0;  // has to be >= 0\n\t\t\tint i, k, n;\n\t\t\t\n\t\t\tif (ljust) { // print prec chars from t, then pad blanks\n\t\t\t\tn = u8_char2byte(t, prec);\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t//putchar(t[k]);\n\t\t\t\t\t*p++ = t[k];\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < pad; i++) {\n\t\t\t\t\t//printf(\" \");\n\t\t\t\t\t*p++ = ' ';\n\t\t\t\t}\n\t\t\t} else { // print pad blanks, then prec chars from t\n\t\t\t\tfor (i = 0; i < pad; i++) {\n\t\t\t\t\t//printf(\" \");\n\t\t\t\t\t*p++ = ' ';\n\t\t\t\t}\n\t\t\t\tn = u8_char2byte(t, prec);\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t//putchar(t[k]);\n\t\t\t\t\t*p++ = t[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*p = 0;\n\t\t\tbreak;\n\t\t}\n\n               case 'c': {\n\t\t\t/*\n\t\t\t * If a numeric value is given, awk should just turn\n\t\t\t * it into a character and print it:\n\t\t\t *      BEGIN { printf(\"%c\\n\", 65) }\n\t\t\t * prints \"A\".\n\t\t\t *\n\t\t\t * But what if the numeric value is > 128 and\n\t\t\t * represents a valid Unicode code point?!? We do\n\t\t\t * our best to convert it back into UTF-8. If we\n\t\t\t * can't, we output the encoding of the Unicode\n\t\t\t * \"invalid character\", 0xFFFD.\n\t\t\t */\n\t\t\tif (isnum(x)) {\n\t\t\t\tint charval = (int) getfval(x);\n\n\t\t\t\tif (charval != 0) {\n\t\t\t\t\tif (charval < 128 || awk_mb_cur_max == 1)\n\t\t\t\t\t\tsnprintf(p, BUFSZ(p), fmt, charval);\n\t\t\t\t\telse {\n\t\t\t\t\t\t// possible unicode character\n\t\t\t\t\t\tsize_t count;\n\t\t\t\t\t\tchar *bs = wide_char_to_byte_str(charval, &count);\n\n\t\t\t\t\t\tif (bs == NULL)\t{ // invalid character\n\t\t\t\t\t\t\t// use unicode invalid character, 0xFFFD\n\t\t\t\t\t\t\tstatic char invalid_char[] = \"\\357\\277\\275\";\n\t\t\t\t\t\t\tbs = invalid_char;\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = bs;\n\t\t\t\t\t\tn = count;\n\t\t\t\t\t\tgoto format_percent_c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t*p++ = '\\0'; /* explicit null byte */\n\t\t\t\t\t*p = '\\0';   /* next output will start here */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt = getsval(x);\n\t\t\tn = u8_nextlen(t);\n\t\tformat_percent_c:\n\t\t\tif (n < 2) { /* not utf8 */\n\t\t\t\tsnprintf(p, BUFSZ(p), fmt, getsval(x)[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// utf8 character, almost same song and dance as for %s\n\t\t\tint ljust = 0, wid = 0, prec = n, pad = 0;\n\t\t\tchar *f = fmt+1;\n\t\t\tif (f[0] == '-') {\n\t\t\t\tljust = 1;\n\t\t\t\tf++;\n\t\t\t}\n\t\t\t// flags '0' and '+' are recognized but skipped\n\t\t\tif (f[0] == '0') {\n\t\t\t\tf++;\n\t\t\t\tif (f[0] == '+')\n\t\t\t\t\tf++;\n\t\t\t}\n\t\t\tif (f[0] == '+') {\n\t\t\t\tf++;\n\t\t\t\tif (f[0] == '0')\n\t\t\t\t\tf++;\n\t\t\t}\n\t\t\tif (isdigit(f[0])) { /* there is a wid */\n\t\t\t\twid = strtol(f, &f, 10);\n\t\t\t}\n\t\t\tif (f[0] == '.') { /* there is a .prec */\n\t\t\t\tprec = strtol(++f, &f, 10);\n\t\t\t}\n\t\t\tif (prec > 1)           // %c --> only one character\n\t\t\t\tprec = 1;\n\t\t\tpad = wid>prec ? wid - prec : 0;  // has to be >= 0\n\t\t\tint i;\n\n\t\t\tif (ljust) { // print one char from t, then pad blanks\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t*p++ = t[i];\n\t\t\t\tfor (i = 0; i < pad; i++) {\n\t\t\t\t\t//printf(\" \");\n\t\t\t\t\t*p++ = ' ';\n\t\t\t\t}\n\t\t\t} else { // print pad blanks, then prec chars from t\n\t\t\t\tfor (i = 0; i < pad; i++) {\n\t\t\t\t\t//printf(\" \");\n\t\t\t\t\t*p++ = ' ';\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t*p++ = t[i];\n\t\t\t}\n\t\t\t*p = 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tFATAL(\"can't happen: bad conversion %c in format()\", flag);\n\t\t}\n\n\t\ttempfree(x);\n\t\tp += strlen(p);\n\t\ts++;\n\t}\n\t*p = '\\0';\n\tfree(fmt);\n\tfor ( ; a; a = a->nnext) {\t\t/* evaluate any remaining args */\n\t\tx = execute(a);\n\t\ttempfree(x);\n\t}\n\t*pbuf = buf;\n\t*pbufsize = bufsize;\n\treturn p - buf;\n}\n\nCell *awksprintf(Node **a, int n)\t\t/* sprintf(a[0]) */\n{\n\tCell *x;\n\tNode *y;\n\tchar *buf;\n\tint bufsz=3*recsize;\n\n\tif ((buf = (char *) malloc(bufsz)) == NULL)\n\t\tFATAL(\"out of memory in awksprintf\");\n\ty = a[0]->nnext;\n\tx = execute(a[0]);\n\tif (format(&buf, &bufsz, getsval(x), y) == -1)\n\t\tFATAL(\"sprintf string %.30s... too long.  can't happen.\", buf);\n\ttempfree(x);\n\tx = gettemp();\n\tx->sval = buf;\n\tx->tval = STR;\n\treturn(x);\n}\n\nCell *awkprintf(Node **a, int n)\t\t/* printf */\n{\t/* a[0] is list of args, starting with format string */\n\t/* a[1] is redirection operator, a[2] is redirection file */\n\tFILE *fp;\n\tCell *x;\n\tNode *y;\n\tchar *buf;\n\tint len;\n\tint bufsz=3*recsize;\n\n\tif ((buf = (char *) malloc(bufsz)) == NULL)\n\t\tFATAL(\"out of memory in awkprintf\");\n\ty = a[0]->nnext;\n\tx = execute(a[0]);\n\tif ((len = format(&buf, &bufsz, getsval(x), y)) == -1)\n\t\tFATAL(\"printf string %.30s... too long.  can't happen.\", buf);\n\ttempfree(x);\n\tif (a[1] == NULL) {\n\t\t/* fputs(buf, stdout); */\n\t\tfwrite(buf, len, 1, stdout);\n\t\tif (ferror(stdout))\n\t\t\tFATAL(\"write error on stdout\");\n\t} else {\n\t\tfp = redirect(ptoi(a[1]), a[2]);\n\t\t/* fputs(buf, fp); */\n\t\tfwrite(buf, len, 1, fp);\n\t\tfflush(fp);\n\t\tif (ferror(fp))\n\t\t\tFATAL(\"write error on %s\", filename(fp));\n\t}\n\tfree(buf);\n\treturn(True);\n}\n\nCell *arith(Node **a, int n)\t/* a[0] + a[1], etc.  also -a[0] */\n{\n\tAwkfloat i, j = 0;\n\tdouble v;\n\tCell *x, *y, *z;\n\n\tx = execute(a[0]);\n\ti = getfval(x);\n\ttempfree(x);\n\tif (n != UMINUS && n != UPLUS) {\n\t\ty = execute(a[1]);\n\t\tj = getfval(y);\n\t\ttempfree(y);\n\t}\n\tz = gettemp();\n\tswitch (n) {\n\tcase ADD:\n\t\ti += j;\n\t\tbreak;\n\tcase MINUS:\n\t\ti -= j;\n\t\tbreak;\n\tcase MULT:\n\t\ti *= j;\n\t\tbreak;\n\tcase DIVIDE:\n\t\tif (j == 0)\n\t\t\tFATAL(\"division by zero\");\n\t\ti /= j;\n\t\tbreak;\n\tcase MOD:\n\t\tif (j == 0)\n\t\t\tFATAL(\"division by zero in mod\");\n\t\tmodf(i/j, &v);\n\t\ti = i - j * v;\n\t\tbreak;\n\tcase UMINUS:\n\t\ti = -i;\n\t\tbreak;\n\tcase UPLUS: /* handled by getfval(), above */\n\t\tbreak;\n\tcase POWER:\n\t\tif (j >= 0 && modf(j, &v) == 0.0)\t/* pos integer exponent */\n\t\t\ti = ipow(i, (int) j);\n               else {\n\t\t\terrno = 0;\n\t\t\ti = errcheck(pow(i, j), \"pow\");\n               }\n\t\tbreak;\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"illegal arithmetic operator %d\", n);\n\t}\n\tsetfval(z, i);\n\treturn(z);\n}\n\ndouble ipow(double x, int n)\t/* x**n.  ought to be done by pow, but isn't always */\n{\n\tdouble v;\n\n\tif (n <= 0)\n\t\treturn 1;\n\tv = ipow(x, n/2);\n\tif (n % 2 == 0)\n\t\treturn v * v;\n\telse\n\t\treturn x * v * v;\n}\n\nCell *incrdecr(Node **a, int n)\t\t/* a[0]++, etc. */\n{\n\tCell *x, *z;\n\tint k;\n\tAwkfloat xf;\n\n\tx = execute(a[0]);\n\txf = getfval(x);\n\tk = (n == PREINCR || n == POSTINCR) ? 1 : -1;\n\tif (n == PREINCR || n == PREDECR) {\n\t\tsetfval(x, xf + k);\n\t\treturn(x);\n\t}\n\tz = gettemp();\n\tsetfval(z, xf);\n\tsetfval(x, xf + k);\n\ttempfree(x);\n\treturn(z);\n}\n\nCell *assign(Node **a, int n)\t/* a[0] = a[1], a[0] += a[1], etc. */\n{\t\t/* this is subtle; don't muck with it. */\n\tCell *x, *y;\n\tAwkfloat xf, yf;\n\tdouble v;\n\n\ty = execute(a[1]);\n\tx = execute(a[0]);\n\tif (n == ASSIGN) {\t/* ordinary assignment */\n\t\tif (x == y && !(x->tval & (FLD|REC)) && x != nfloc)\n\t\t\t;\t/* self-assignment: leave alone unless it's a field or NF */\n\t\telse if ((y->tval & (STR|NUM)) == (STR|NUM)) {\n\t\t\tyf = getfval(y);\n\t\t\tsetsval(x, getsval(y));\n\t\t\tx->fval = yf;\n\t\t\tx->tval |= NUM;\n\t\t}\n\t\telse if (isstr(y))\n\t\t\tsetsval(x, getsval(y));\n\t\telse if (isnum(y))\n\t\t\tsetfval(x, getfval(y));\n\t\telse\n\t\t\tfunnyvar(y, \"read value of\");\n\t\ttempfree(y);\n\t\treturn(x);\n\t}\n\txf = getfval(x);\n\tyf = getfval(y);\n\tswitch (n) {\n\tcase ADDEQ:\n\t\txf += yf;\n\t\tbreak;\n\tcase SUBEQ:\n\t\txf -= yf;\n\t\tbreak;\n\tcase MULTEQ:\n\t\txf *= yf;\n\t\tbreak;\n\tcase DIVEQ:\n\t\tif (yf == 0)\n\t\t\tFATAL(\"division by zero in /=\");\n\t\txf /= yf;\n\t\tbreak;\n\tcase MODEQ:\n\t\tif (yf == 0)\n\t\t\tFATAL(\"division by zero in %%=\");\n\t\tmodf(xf/yf, &v);\n\t\txf = xf - yf * v;\n\t\tbreak;\n\tcase POWEQ:\n\t\tif (yf >= 0 && modf(yf, &v) == 0.0)\t/* pos integer exponent */\n\t\t\txf = ipow(xf, (int) yf);\n               else {\n\t\t\terrno = 0;\n\t\t\txf = errcheck(pow(xf, yf), \"pow\");\n               }\n\t\tbreak;\n\tdefault:\n\t\tFATAL(\"illegal assignment operator %d\", n);\n\t\tbreak;\n\t}\n\ttempfree(y);\n\tsetfval(x, xf);\n\treturn(x);\n}\n\nCell *cat(Node **a, int q)\t/* a[0] cat a[1] */\n{\n\tCell *x, *y, *z;\n\tint n1, n2;\n\tchar *s = NULL;\n\tint ssz = 0;\n\n\tx = execute(a[0]);\n\tn1 = strlen(getsval(x));\n\tadjbuf(&s, &ssz, n1 + 1, recsize, 0, \"cat1\");\n\tmemcpy(s, x->sval, n1);\n\n\ttempfree(x);\n\n\ty = execute(a[1]);\n\tn2 = strlen(getsval(y));\n\tadjbuf(&s, &ssz, n1 + n2 + 1, recsize, 0, \"cat2\");\n\tmemcpy(s + n1, y->sval, n2);\n\ts[n1 + n2] = '\\0';\n\n\ttempfree(y);\n\n\tz = gettemp();\n\tz->sval = s;\n\tz->tval = STR;\n\n\treturn(z);\n}\n\nCell *pastat(Node **a, int n)\t/* a[0] { a[1] } */\n{\n\tCell *x;\n\n\tif (a[0] == NULL)\n\t\tx = execute(a[1]);\n\telse {\n\t\tx = execute(a[0]);\n\t\tif (istrue(x)) {\n\t\t\ttempfree(x);\n\t\t\tx = execute(a[1]);\n\t\t}\n\t}\n\treturn x;\n}\n\nCell *dopa2(Node **a, int n)\t/* a[0], a[1] { a[2] } */\n{\n\tCell *x;\n\tint pair;\n\n\tpair = ptoi(a[3]);\n\tif (pairstack[pair] == 0) {\n\t\tx = execute(a[0]);\n\t\tif (istrue(x))\n\t\t\tpairstack[pair] = 1;\n\t\ttempfree(x);\n\t}\n\tif (pairstack[pair] == 1) {\n\t\tx = execute(a[1]);\n\t\tif (istrue(x))\n\t\t\tpairstack[pair] = 0;\n\t\ttempfree(x);\n\t\tx = execute(a[2]);\n\t\treturn(x);\n\t}\n\treturn(False);\n}\n\nCell *split(Node **a, int nnn)\t/* split(a[0], a[1], a[2]); a[3] is type */\n{\n\tCell *x = NULL, *y, *ap;\n\tconst char *s, *origs, *t;\n\tconst char *fs = NULL;\n\tchar *origfs = NULL;\n\tint sep;\n\tchar temp, num[50];\n\tint n, tempstat, arg3type;\n\tint j;\n\tdouble result;\n\n\ty = execute(a[0]);\t/* source string */\n\torigs = s = strdup(getsval(y));\n\ttempfree(y);\n\targ3type = ptoi(a[3]);\n\tif (a[2] == NULL) {\t\t/* BUG: CSV should override implicit fs but not explicit */\n\t\tfs = getsval(fsloc);\n\t} else if (arg3type == STRING) {\t/* split(str,arr,\"string\") */\n\t\tx = execute(a[2]);\n\t\tfs = origfs = strdup(getsval(x));\n\t\ttempfree(x);\n\t} else if (arg3type == REGEXPR) {\n\t\tfs = \"(regexpr)\";\t/* split(str,arr,/regexpr/) */\n\t} else {\n\t\tFATAL(\"illegal type of split\");\n\t}\n\tsep = *fs;\n\tap = execute(a[1]);\t/* array name */\n/* BUG 7/26/22: this appears not to reset array: see C1/asplit */\n\tfreesymtab(ap);\n\tDPRINTF(\"split: s=|%s|, a=%s, sep=|%s|\\n\", s, NN(ap->nval), fs);\n\tap->tval &= ~STR;\n\tap->tval |= ARR;\n\tap->sval = (char *) makesymtab(NSYMTAB);\n\n\tn = 0;\n        if (arg3type == REGEXPR && strlen((char*)((fa*)a[2])->restr) == 0) {\n\t\t/* split(s, a, //); have to arrange that it looks like empty sep */\n\t\targ3type = 0;\n\t\tfs = \"\";\n\t\tsep = 0;\n\t}\n\tif (*s != '\\0' && (strlen(fs) > 1 || arg3type == REGEXPR)) {\t/* reg expr */\n\t\tfa *pfa;\n\t\tif (arg3type == REGEXPR) {\t/* it's ready already */\n\t\t\tpfa = (fa *) a[2];\n\t\t} else {\n\t\t\tpfa = makedfa(fs, 1);\n\t\t}\n\t\tif (nematch(pfa,s)) {\n\t\t\ttempstat = pfa->initstat;\n\t\t\tpfa->initstat = 2;\n\t\t\tdo {\n\t\t\t\tn++;\n\t\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\t\t\ttemp = *patbeg;\n\t\t\t\tsetptr(patbeg, '\\0');\n\t\t\t\tif (is_number(s, & result))\n\t\t\t\t\tsetsymtab(num, s, result, STR|NUM, (Array *) ap->sval);\n\t\t\t\telse\n\t\t\t\t\tsetsymtab(num, s, 0.0, STR, (Array *) ap->sval);\n\t\t\t\tsetptr(patbeg, temp);\n\t\t\t\ts = patbeg + patlen;\n\t\t\t\tif (*(patbeg+patlen-1) == '\\0' || *s == '\\0') {\n\t\t\t\t\tn++;\n\t\t\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\t\t\t\tsetsymtab(num, \"\", 0.0, STR, (Array *) ap->sval);\n\t\t\t\t\tpfa->initstat = tempstat;\n\t\t\t\t\tgoto spdone;\n\t\t\t\t}\n\t\t\t} while (nematch(pfa,s));\n\t\t\tpfa->initstat = tempstat; \t/* bwk: has to be here to reset */\n\t\t\t\t\t\t\t/* cf gsub and refldbld */\n\t\t}\n\t\tn++;\n\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\tif (is_number(s, & result))\n\t\t\tsetsymtab(num, s, result, STR|NUM, (Array *) ap->sval);\n\t\telse\n\t\t\tsetsymtab(num, s, 0.0, STR, (Array *) ap->sval);\n  spdone:\n\t\tpfa = NULL;\n\n\t} else if (a[2] == NULL && CSV) {\t/* CSV only if no explicit separator */\n\t\tchar *newt = (char *) malloc(strlen(s)); /* for building new string; reuse for each field */\n\t\tfor (;;) {\n\t\t\tchar *fr = newt;\n\t\t\tn++;\n\t\t\tif (*s == '\"' ) { /* start of \"...\" */\n\t\t\t\tfor (s++ ; *s != '\\0'; ) {\n\t\t\t\t\tif (*s == '\"' && s[1] != '\\0' && s[1] == '\"') {\n\t\t\t\t\t\ts += 2; /* doubled quote */\n\t\t\t\t\t\t*fr++ = '\"';\n\t\t\t\t\t} else if (*s == '\"' && (s[1] == '\\0' || s[1] == ',')) {\n\t\t\t\t\t\ts++; /* skip over closing quote */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*fr++ = *s++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*fr++ = 0;\n\t\t\t} else {\t/* unquoted field */\n\t\t\t\twhile (*s != ',' && *s != '\\0')\n\t\t\t\t\t*fr++ = *s++;\n\t\t\t\t*fr++ = 0;\n\t\t\t}\n\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\t\tif (is_number(newt, &result))\n\t\t\t\tsetsymtab(num, newt, result, STR|NUM, (Array *) ap->sval);\n\t\t\telse\n\t\t\t\tsetsymtab(num, newt, 0.0, STR, (Array *) ap->sval);\n\t\t\tif (*s++ == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tfree(newt);\n\n\t} else if (!CSV && sep == ' ') { /* usual case: split on white space */\n\t\tfor (n = 0; ; ) {\n#define ISWS(c)\t((c) == ' ' || (c) == '\\t' || (c) == '\\n')\n\t\t\twhile (ISWS(*s))\n\t\t\t\ts++;\n\t\t\tif (*s == '\\0')\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tt = s;\n\t\t\tdo\n\t\t\t\ts++;\n\t\t\twhile (*s != '\\0' && !ISWS(*s));\n\t\t\ttemp = *s;\n\t\t\tsetptr(s, '\\0');\n\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\t\tif (is_number(t, & result))\n\t\t\t\tsetsymtab(num, t, result, STR|NUM, (Array *) ap->sval);\n\t\t\telse\n\t\t\t\tsetsymtab(num, t, 0.0, STR, (Array *) ap->sval);\n\t\t\tsetptr(s, temp);\n\t\t\tif (*s != '\\0')\n\t\t\t\ts++;\n\t\t}\n\n\t} else if (sep == 0) {\t/* new: split(s, a, \"\") => 1 char/elem */\n\t\tfor (n = 0; *s != '\\0'; s += u8_nextlen(s)) {\n\t\t\tchar buf[10];\n\t\t\tn++;\n\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\n\t\t\tfor (j = 0; j < u8_nextlen(s); j++) {\n\t\t\t\tbuf[j] = s[j];\n\t\t\t}\n\t\t\tbuf[j] = '\\0';\n\n\t\t\tif (isdigit((uschar)buf[0]))\n\t\t\t\tsetsymtab(num, buf, atof(buf), STR|NUM, (Array *) ap->sval);\n\t\t\telse\n\t\t\t\tsetsymtab(num, buf, 0.0, STR, (Array *) ap->sval);\n\t\t}\n\n\t} else if (*s != '\\0') {  /* some random single character */\n\t\tfor (;;) {\n\t\t\tn++;\n\t\t\tt = s;\n\t\t\twhile (*s != sep && *s != '\\0')\n\t\t\t\ts++;\n\t\t\ttemp = *s;\n\t\t\tsetptr(s, '\\0');\n\t\t\tsnprintf(num, sizeof(num), \"%d\", n);\n\t\t\tif (is_number(t, & result))\n\t\t\t\tsetsymtab(num, t, result, STR|NUM, (Array *) ap->sval);\n\t\t\telse\n\t\t\t\tsetsymtab(num, t, 0.0, STR, (Array *) ap->sval);\n\t\t\tsetptr(s, temp);\n\t\t\tif (*s++ == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\ttempfree(ap);\n\txfree(origs);\n\txfree(origfs);\n\tx = gettemp();\n\tx->tval = NUM;\n\tx->fval = n;\n\treturn(x);\n}\n\nCell *condexpr(Node **a, int n)\t/* a[0] ? a[1] : a[2] */\n{\n\tCell *x;\n\n\tx = execute(a[0]);\n\tif (istrue(x)) {\n\t\ttempfree(x);\n\t\tx = execute(a[1]);\n\t} else {\n\t\ttempfree(x);\n\t\tx = execute(a[2]);\n\t}\n\treturn(x);\n}\n\nCell *ifstat(Node **a, int n)\t/* if (a[0]) a[1]; else a[2] */\n{\n\tCell *x;\n\n\tx = execute(a[0]);\n\tif (istrue(x)) {\n\t\ttempfree(x);\n\t\tx = execute(a[1]);\n\t} else if (a[2] != NULL) {\n\t\ttempfree(x);\n\t\tx = execute(a[2]);\n\t}\n\treturn(x);\n}\n\nCell *whilestat(Node **a, int n)\t/* while (a[0]) a[1] */\n{\n\tCell *x;\n\n\tfor (;;) {\n\t\tx = execute(a[0]);\n\t\tif (!istrue(x))\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t\tx = execute(a[1]);\n\t\tif (isbreak(x)) {\n\t\t\tx = True;\n\t\t\treturn(x);\n\t\t}\n\t\tif (isnext(x) || isexit(x) || isret(x))\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t}\n}\n\nCell *dostat(Node **a, int n)\t/* do a[0]; while(a[1]) */\n{\n\tCell *x;\n\n\tfor (;;) {\n\t\tx = execute(a[0]);\n\t\tif (isbreak(x))\n\t\t\treturn True;\n\t\tif (isnext(x) || isexit(x) || isret(x))\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t\tx = execute(a[1]);\n\t\tif (!istrue(x))\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t}\n}\n\nCell *forstat(Node **a, int n)\t/* for (a[0]; a[1]; a[2]) a[3] */\n{\n\tCell *x;\n\n\tx = execute(a[0]);\n\ttempfree(x);\n\tfor (;;) {\n\t\tif (a[1]!=NULL) {\n\t\t\tx = execute(a[1]);\n\t\t\tif (!istrue(x)) return(x);\n\t\t\telse tempfree(x);\n\t\t}\n\t\tx = execute(a[3]);\n\t\tif (isbreak(x))\t\t/* turn off break */\n\t\t\treturn True;\n\t\tif (isnext(x) || isexit(x) || isret(x))\n\t\t\treturn(x);\n\t\ttempfree(x);\n\t\tx = execute(a[2]);\n\t\ttempfree(x);\n\t}\n}\n\nCell *instat(Node **a, int n)\t/* for (a[0] in a[1]) a[2] */\n{\n\tCell *x, *vp, *arrayp, *cp, *ncp;\n\tArray *tp;\n\tint i;\n\n\tvp = execute(a[0]);\n\tarrayp = execute(a[1]);\n\tif (!isarr(arrayp)) {\n\t\treturn True;\n\t}\n\ttp = (Array *) arrayp->sval;\n\ttempfree(arrayp);\n\tfor (i = 0; i < tp->size; i++) {\t/* this routine knows too much */\n\t\tfor (cp = tp->tab[i]; cp != NULL; cp = ncp) {\n\t\t\tsetsval(vp, cp->nval);\n\t\t\tncp = cp->cnext;\n\t\t\tx = execute(a[2]);\n\t\t\tif (isbreak(x)) {\n\t\t\t\ttempfree(vp);\n\t\t\t\treturn True;\n\t\t\t}\n\t\t\tif (isnext(x) || isexit(x) || isret(x)) {\n\t\t\t\ttempfree(vp);\n\t\t\t\treturn(x);\n\t\t\t}\n\t\t\ttempfree(x);\n\t\t}\n\t}\n\treturn True;\n}\n\nstatic char *nawk_convert(const char *s, int (*fun_c)(int),\n    wint_t (*fun_wc)(wint_t))\n{\n\tchar *buf      = NULL;\n\tchar *pbuf     = NULL;\n\tconst char *ps = NULL;\n\tsize_t n       = 0;\n\twchar_t wc;\n\tconst size_t sz = awk_mb_cur_max;\n\tint unused;\n\n\tif (sz == 1) {\n\t\tbuf = tostring(s);\n\n\t\tfor (pbuf = buf; *pbuf; pbuf++)\n\t\t\t*pbuf = fun_c((uschar)*pbuf);\n\n\t\treturn buf;\n\t} else {\n\t\t/* upper/lower character may be shorter/longer */\n\t\tbuf = tostringN(s, strlen(s) * sz + 1);\n\n\t\t(void) mbtowc(NULL, NULL, 0);\t/* reset internal state */\n\t\t/*\n\t\t * Reset internal state here too.\n\t\t * Assign result to avoid a compiler warning. (Casting to void\n\t\t * doesn't work.)\n\t\t * Increment said variable to avoid a different warning.\n\t\t */\n\t\tunused = wctomb(NULL, L'\\0');\n\t\tunused++;\n\n\t\tps   = s;\n\t\tpbuf = buf;\n\t\twhile (n = mbtowc(&wc, ps, sz),\n\t\t       n > 0 && n != (size_t)-1 && n != (size_t)-2)\n\t\t{\n\t\t\tps += n;\n\n\t\t\tn = wctomb(pbuf, fun_wc(wc));\n\t\t\tif (n == (size_t)-1)\n\t\t\t\tFATAL(\"illegal wide character %s\", s);\n\n\t\t\tpbuf += n;\n\t\t}\n\n\t\t*pbuf = '\\0';\n\n\t\tif (n)\n\t\t\tFATAL(\"illegal byte sequence %s\", s);\n\n\t\treturn buf;\n\t}\n}\n\n#ifdef __DJGPP__\nstatic wint_t towupper(wint_t wc)\n{\n\tif (wc >= 0 && wc < 256)\n\t\treturn toupper(wc & 0xFF);\n\n\treturn wc;\n}\n\nstatic wint_t towlower(wint_t wc)\n{\n\tif (wc >= 0 && wc < 256)\n\t\treturn tolower(wc & 0xFF);\n\n\treturn wc;\n}\n#endif\n\nstatic char *nawk_toupper(const char *s)\n{\n\treturn nawk_convert(s, toupper, towupper);\n}\n\nstatic char *nawk_tolower(const char *s)\n{\n\treturn nawk_convert(s, tolower, towlower);\n}\n\n\n\nCell *bltin(Node **a, int n)\t/* builtin functions. a[0] is type, a[1] is arg list */\n{\n\tCell *x, *y;\n\tAwkfloat u = 0;\n\tint t;\n\tAwkfloat tmp;\n\tchar *buf;\n\tNode *nextarg;\n\tFILE *fp;\n\tint status = 0;\n\tint estatus = 0;\n\n\tt = ptoi(a[0]);\n\tx = execute(a[1]);\n\tnextarg = a[1]->nnext;\n\tswitch (t) {\n\tcase FLENGTH:\n\t\tif (isarr(x))\n\t\t\tu = ((Array *) x->sval)->nelem;\t/* GROT.  should be function*/\n\t\telse\n\t\t\tu = u8_strlen(getsval(x));\n\t\tbreak;\n\tcase FLOG:\n\t\terrno = 0;\n\t\tu = errcheck(log(getfval(x)), \"log\");\n\t\tbreak;\n\tcase FINT:\n\t\tmodf(getfval(x), &u); break;\n\tcase FEXP:\n\t\terrno = 0;\n\t\tu = errcheck(exp(getfval(x)), \"exp\");\n\t\tbreak;\n\tcase FSQRT:\n\t\terrno = 0;\n\t\tu = errcheck(sqrt(getfval(x)), \"sqrt\");\n\t\tbreak;\n\tcase FSIN:\n\t\tu = sin(getfval(x)); break;\n\tcase FCOS:\n\t\tu = cos(getfval(x)); break;\n\tcase FATAN:\n\t\tif (nextarg == NULL) {\n\t\t\tWARNING(\"atan2 requires two arguments; returning 1.0\");\n\t\t\tu = 1.0;\n\t\t} else {\n\t\t\ty = execute(a[1]->nnext);\n\t\t\tu = atan2(getfval(x), getfval(y));\n\t\t\ttempfree(y);\n\t\t\tnextarg = nextarg->nnext;\n\t\t}\n\t\tbreak;\n\tcase FSYSTEM:\n\t\tfflush(stdout);\t\t/* in case something is buffered already */\n\t\testatus = status = system(getsval(x));\n\t\tif (status != -1) {\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\testatus = WEXITSTATUS(status);\n\t\t\t} else if (WIFSIGNALED(status)) {\n\t\t\t\testatus = WTERMSIG(status) + 256;\n#ifdef WCOREDUMP\n\t\t\t\tif (WCOREDUMP(status))\n\t\t\t\t\testatus += 256;\n#endif\n\t\t\t} else\t/* something else?!? */\n\t\t\t\testatus = 0;\n\t\t}\n\t\t/* else estatus was set to -1 */\n\t\tu = estatus;\n\t\tbreak;\n\tcase FRAND:\n\t\t/* random() returns numbers in [0..2^31-1]\n\t\t * in order to get a number in [0, 1), divide it by 2^31\n\t\t */\n\t\tu = (Awkfloat) random() / (0x7fffffffL + 0x1UL);\n\t\tbreak;\n\tcase FSRAND:\n\t\tif (isrec(x))\t/* no argument provided */\n\t\t\tu = time((time_t *)0);\n\t\telse\n\t\t\tu = getfval(x);\n\t\ttmp = u;\n\t\tsrandom((unsigned long) u);\n\t\tu = srand_seed;\n\t\tsrand_seed = tmp;\n\t\tbreak;\n\tcase FTOUPPER:\n\tcase FTOLOWER:\n\t\tif (t == FTOUPPER)\n\t\t\tbuf = nawk_toupper(getsval(x));\n\t\telse\n\t\t\tbuf = nawk_tolower(getsval(x));\n\t\ttempfree(x);\n\t\tx = gettemp();\n\t\tsetsval(x, buf);\n\t\tfree(buf);\n\t\treturn x;\n\tcase FFLUSH:\n\t\tif (isrec(x) || strlen(getsval(x)) == 0) {\n\t\t\tflush_all();\t/* fflush() or fflush(\"\") -> all */\n\t\t\tu = 0;\n\t\t} else if ((fp = openfile(FFLUSH, getsval(x), NULL)) == NULL)\n\t\t\tu = EOF;\n\t\telse\n\t\t\tu = fflush(fp);\n\t\tbreak;\n\tdefault:\t/* can't happen */\n\t\tFATAL(\"illegal function type %d\", t);\n\t\tbreak;\n\t}\n\ttempfree(x);\n\tx = gettemp();\n\tsetfval(x, u);\n\tif (nextarg != NULL) {\n\t\tWARNING(\"warning: function has too many arguments\");\n\t\tfor ( ; nextarg; nextarg = nextarg->nnext) {\n\t\t\ty = execute(nextarg);\n\t\t\ttempfree(y);\n\t\t}\n\t}\n\treturn(x);\n}\n\nCell *printstat(Node **a, int n)\t/* print a[0] */\n{\n\tNode *x;\n\tCell *y;\n\tFILE *fp;\n\n\tif (a[1] == NULL)\t/* a[1] is redirection operator, a[2] is file */\n\t\tfp = stdout;\n\telse\n\t\tfp = redirect(ptoi(a[1]), a[2]);\n\tfor (x = a[0]; x != NULL; x = x->nnext) {\n\t\ty = execute(x);\n\t\tfputs(getpssval(y), fp);\n\t\ttempfree(y);\n\t\tif (x->nnext == NULL)\n\t\t\tfputs(getsval(orsloc), fp);\n\t\telse\n\t\t\tfputs(getsval(ofsloc), fp);\n\t}\n\tif (a[1] != NULL)\n\t\tfflush(fp);\n\tif (ferror(fp))\n\t\tFATAL(\"write error on %s\", filename(fp));\n\treturn(True);\n}\n\nCell *nullproc(Node **a, int n)\n{\n\treturn 0;\n}\n\n\nFILE *redirect(int a, Node *b)\t/* set up all i/o redirections */\n{\n\tFILE *fp;\n\tCell *x;\n\tchar *fname;\n\n\tx = execute(b);\n\tfname = getsval(x);\n\tfp = openfile(a, fname, NULL);\n\tif (fp == NULL)\n\t\tFATAL(\"can't open file %s\", fname);\n\ttempfree(x);\n\treturn fp;\n}\n\nstruct files {\n\tFILE\t*fp;\n\tconst char\t*fname;\n\tint\tmode;\t/* '|', 'a', 'w' => LE/LT, GT */\n} *files;\n\nsize_t nfiles;\n\nstatic void stdinit(void)\t/* in case stdin, etc., are not constants */\n{\n\tnfiles = FOPEN_MAX;\n\tfiles = (struct files *) calloc(nfiles, sizeof(*files));\n\tif (files == NULL)\n\t\tFATAL(\"can't allocate file memory for %zu files\", nfiles);\n        files[0].fp = stdin;\n\tfiles[0].fname = tostring(\"/dev/stdin\");\n\tfiles[0].mode = LT;\n        files[1].fp = stdout;\n\tfiles[1].fname = tostring(\"/dev/stdout\");\n\tfiles[1].mode = GT;\n        files[2].fp = stderr;\n\tfiles[2].fname = tostring(\"/dev/stderr\");\n\tfiles[2].mode = GT;\n}\n\nFILE *openfile(int a, const char *us, bool *pnewflag)\n{\n\tconst char *s = us;\n\tsize_t i;\n\tint m;\n\tFILE *fp = NULL;\n\tstruct stat sbuf;\n\n\tif (*s == '\\0')\n\t\tFATAL(\"null file name in print or getline\");\n\n\tfor (i = 0; i < nfiles; i++)\n\t\tif (files[i].fname && strcmp(s, files[i].fname) == 0 &&\n\t\t    (a == files[i].mode || (a==APPEND && files[i].mode==GT) ||\n\t\t     a == FFLUSH)) {\n\t\t\tif (pnewflag)\n\t\t\t\t*pnewflag = false;\n\t\t\treturn files[i].fp;\n\t\t}\n\tif (a == FFLUSH)\t/* didn't find it, so don't create it! */\n\t\treturn NULL;\n\tfor (i = 0; i < nfiles; i++)\n\t\tif (files[i].fp == NULL)\n\t\t\tbreak;\n\tif (i >= nfiles) {\n\t\tstruct files *nf;\n\t\tsize_t nnf = nfiles + FOPEN_MAX;\n\t\tnf = (struct files *) realloc(files, nnf * sizeof(*nf));\n\t\tif (nf == NULL)\n\t\t\tFATAL(\"cannot grow files for %s and %zu files\", s, nnf);\n\t\tmemset(&nf[nfiles], 0, FOPEN_MAX * sizeof(*nf));\n\t\tnfiles = nnf;\n\t\tfiles = nf;\n\t}\n\n\tfflush(stdout);\t/* force a semblance of order */\n\n\t/* don't try to read or write a directory */\n\tif (a == LT || a == GT || a == APPEND)\n\t\tif (stat(s, &sbuf) == 0 && S_ISDIR(sbuf.st_mode))\n\t\t\t\treturn NULL;\n\n\tm = a;\n\tif (a == GT) {\n\t\tfp = fopen(s, \"w\");\n\t} else if (a == APPEND) {\n\t\tfp = fopen(s, \"a\");\n\t\tm = GT;\t/* so can mix > and >> */\n\t} else if (a == '|') {\t/* output pipe */\n\t\tfp = popen(s, \"w\");\n\t} else if (a == LE) {\t/* input pipe */\n\t\tfp = popen(s, \"r\");\n\t} else if (a == LT) {\t/* getline <file */\n\t\tfp = strcmp(s, \"-\") == 0 ? stdin : fopen(s, \"r\");\t/* \"-\" is stdin */\n\t} else\t/* can't happen */\n\t\tFATAL(\"illegal redirection %d\", a);\n\tif (fp != NULL) {\n\t\tfiles[i].fname = tostring(s);\n\t\tfiles[i].fp = fp;\n\t\tfiles[i].mode = m;\n\t\tif (pnewflag)\n\t\t\t*pnewflag = true;\n\t\tif (fp != stdin && fp != stdout && fp != stderr)\n\t\t\t(void) fcntl(fileno(fp), F_SETFD, FD_CLOEXEC);\n\t}\n\treturn fp;\n}\n\nconst char *filename(FILE *fp)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nfiles; i++)\n\t\tif (fp == files[i].fp)\n\t\t\treturn files[i].fname;\n\treturn \"???\";\n}\n\nCell *closefile(Node **a, int n)\n{\n \tCell *x;\n\tsize_t i;\n\tbool stat;\n\n \tx = execute(a[0]);\n \tgetsval(x);\n\tstat = true;\n \tfor (i = 0; i < nfiles; i++) {\n\t\tif (!files[i].fname || strcmp(x->sval, files[i].fname) != 0)\n\t\t\tcontinue;\n\t\tif (files[i].mode == GT || files[i].mode == '|')\n\t\t\tfflush(files[i].fp);\n\t\tif (ferror(files[i].fp)) {\n\t\t\tif ((files[i].mode == GT && files[i].fp != stderr)\n\t\t\t  || files[i].mode == '|')\n\t\t\t\tFATAL(\"write error on %s\", files[i].fname);\n\t\t\telse\n\t\t\t\tWARNING(\"i/o error occurred on %s\", files[i].fname);\n\t\t}\n\t\tif (files[i].fp == stdin || files[i].fp == stdout ||\n\t\t    files[i].fp == stderr)\n\t\t\tstat = freopen(\"/dev/null\", \"r+\", files[i].fp) == NULL;\n\t\telse if (files[i].mode == '|' || files[i].mode == LE)\n\t\t\tstat = pclose(files[i].fp) == -1;\n\t\telse\n\t\t\tstat = fclose(files[i].fp) == EOF;\n\t\tif (stat)\n\t\t\tWARNING(\"i/o error occurred closing %s\", files[i].fname);\n\t\txfree(files[i].fname);\n\t\tfiles[i].fname = NULL;\t/* watch out for ref thru this */\n\t\tfiles[i].fp = NULL;\n\t\tbreak;\n \t}\n \ttempfree(x);\n \tx = gettemp();\n\tsetfval(x, (Awkfloat) (stat ? -1 : 0));\n \treturn(x);\n}\n\nvoid closeall(void)\n{\n\tsize_t i;\n\tbool stat = false;\n\n\tfor (i = 0; i < nfiles; i++) {\n\t\tif (! files[i].fp)\n\t\t\tcontinue;\n\t\tif (files[i].mode == GT || files[i].mode == '|')\n\t\t\tfflush(files[i].fp);\n\t\tif (ferror(files[i].fp)) {\n\t\t\tif ((files[i].mode == GT && files[i].fp != stderr)\n\t\t\t  || files[i].mode == '|')\n\t\t\t\tFATAL(\"write error on %s\", files[i].fname);\n\t\t\telse\n\t\t\t\tWARNING(\"i/o error occurred on %s\", files[i].fname);\n\t\t}\n\t\tif (files[i].fp == stdin || files[i].fp == stdout ||\n\t\t    files[i].fp == stderr)\n\t\t\tcontinue;\n\t\tif (files[i].mode == '|' || files[i].mode == LE)\n\t\t\tstat = pclose(files[i].fp) == -1;\n\t\telse\n\t\t\tstat = fclose(files[i].fp) == EOF;\n\t\tif (stat)\n\t\t\tWARNING(\"i/o error occurred while closing %s\", files[i].fname);\n\t}\n}\n\nstatic void flush_all(void)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nfiles; i++)\n\t\tif (files[i].fp)\n\t\t\tfflush(files[i].fp);\n}\n\nvoid backsub(char **pb_ptr, const char **sptr_ptr);\n\nCell *dosub(Node **a, int subop)        /* sub and gsub */\n{\n\tfa *pfa;\n\tint tempstat = 0;\n\tchar *repl;\n\tCell *x;\n\n\tchar *buf = NULL;\n\tchar *pb = NULL;\n\tint bufsz = recsize;\n\n\tconst char *r, *s;\n\tconst char *start;\n\tconst char *noempty = NULL;      /* empty match disallowed here */\n\tsize_t m = 0;                    /* match count */\n\tsize_t whichm = 0;               /* which match to select, 0 = global */\n\tint mtype;                       /* match type */\n\n\tif (a[0] == NULL) {\t/* 0 => a[1] is already-compiled regexpr */\n\t\tpfa = (fa *) a[1];\n\t} else {\n\t\tx = execute(a[1]);\n\t\tpfa = makedfa(getsval(x), 1);\n\t\ttempfree(x);\n\t}\n\n\tx = execute(a[2]);\t/* replacement string */\n\trepl = tostring(getsval(x));\n\ttempfree(x);\n\n\tswitch (subop) {\n\tcase SUB:\n\t\twhichm = 1;\n\t\tx = execute(a[3]);    /* source string */\n\t\tbreak;\n\tcase GSUB:\n\t\twhichm = 0;\n\t\tx = execute(a[3]);    /* source string */\n\t\tbreak;\n\tdefault:\n\t\tFATAL(\"dosub: unrecognized subop: %d\", subop);\n\t}\n\n\tstart = getsval(x);\n\twhile (pmatch(pfa, start)) {\n\t\tif (buf == NULL) {\n\t\t\tif ((pb = buf = (char *) malloc(bufsz)) == NULL)\n\t\t\t\tFATAL(\"out of memory in dosub\");\n\t\t\ttempstat = pfa->initstat;\n\t\t\tpfa->initstat = 2;\n\t\t}\n\n\t\t/* match types */\n\t\t#define\tMT_IGNORE  0  /* unselected or invalid */\n\t\t#define MT_INSERT  1  /* selected, empty */\n\t\t#define MT_REPLACE 2  /* selected, not empty */\n\n\t\t/* an empty match just after replacement is invalid */\n\n\t\tif (patbeg == noempty && patlen == 0) {\n\t\t\tmtype = MT_IGNORE;    /* invalid, not counted */\n\t\t} else if (whichm == ++m || whichm == 0) {\n\t\t\tmtype = patlen ? MT_REPLACE : MT_INSERT;\n\t\t} else {\n\t\t\tmtype = MT_IGNORE;    /* unselected, but counted */\n\t\t}\n\n\t\t/* leading text: */\n\t\tif (patbeg > start) {\n\t\t\tadjbuf(&buf, &bufsz, (pb - buf) + (patbeg - start),\n\t\t\t\trecsize, &pb, \"dosub\");\n\t\t\ts = start;\n\t\t\twhile (s < patbeg)\n\t\t\t\t*pb++ = *s++;\n\t\t}\n\n\t\tif (mtype == MT_IGNORE)\n\t\t\tgoto matching_text;  /* skip replacement text */\n\n\t\tr = repl;\n\t\twhile (*r != 0) {\n\t\t\tadjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, \"dosub\");\n\t\t\tif (*r == '\\\\') {\n\t\t\t\tbacksub(&pb, &r);\n\t\t\t} else if (*r == '&') {\n\t\t\t\tr++;\n\t\t\t\tadjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize,\n\t\t\t\t\t&pb, \"dosub\");\n\t\t\t\tfor (s = patbeg; s < patbeg+patlen; )\n\t\t\t\t\t*pb++ = *s++;\n\t\t\t} else {\n\t\t\t\t*pb++ = *r++;\n\t\t\t}\n\t\t}\n\nmatching_text:\n\t\tif (mtype == MT_REPLACE || *patbeg == '\\0')\n\t\t\tgoto next_search;  /* skip matching text */\n\t\t\n\t\tif (patlen == 0)\n\t\t\tpatlen = u8_nextlen(patbeg);\n\t\tadjbuf(&buf, &bufsz, (pb-buf) + patlen, recsize, &pb, \"dosub\");\n\t\ts = patbeg;\n\t\twhile (s < patbeg + patlen)\n\t\t\t*pb++ = *s++;\n\nnext_search:\n\t\tstart = patbeg + patlen;\n\t\tif (m == whichm || *patbeg == '\\0')\n\t\t\tbreak;\n\t\tif (mtype == MT_REPLACE)\n\t\t\tnoempty = start;\n\n\t\t#undef MT_IGNORE\n\t\t#undef MT_INSERT\n\t\t#undef MT_REPLACE\n\t}\n\n\txfree(repl);\n\n\tif (buf != NULL) {\n\t\tpfa->initstat = tempstat;\n\n\t\t/* trailing text */\n\t\tadjbuf(&buf, &bufsz, 1+strlen(start)+pb-buf, 0, &pb, \"dosub\");\n\t\twhile ((*pb++ = *start++) != '\\0')\n\t\t\t;\n\n\t\tsetsval(x, buf);\n\t\tfree(buf);\n\t}\n\n\ttempfree(x);\n\tx = gettemp();\n\tx->tval = NUM;\n\tx->fval = m;\n\treturn x;\n}\n\nvoid backsub(char **pb_ptr, const char **sptr_ptr)\t/* handle \\\\& variations */\n{\t\t\t\t\t\t/* sptr[0] == '\\\\' */\n\tchar *pb = *pb_ptr;\n\tconst char *sptr = *sptr_ptr;\n\tstatic bool first = true;\n\tstatic bool do_posix = false;\n\n\tif (first) {\n\t\tfirst = false;\n\t\tdo_posix = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\t}\n\n\tif (sptr[1] == '\\\\') {\n\t\tif (sptr[2] == '\\\\' && sptr[3] == '&') { /* \\\\\\& -> \\& */\n\t\t\t*pb++ = '\\\\';\n\t\t\t*pb++ = '&';\n\t\t\tsptr += 4;\n\t\t} else if (sptr[2] == '&') {\t/* \\\\& -> \\ + matched */\n\t\t\t*pb++ = '\\\\';\n\t\t\tsptr += 2;\n\t\t} else if (do_posix) {\t\t/* \\\\x -> \\x */\n\t\t\tsptr++;\n\t\t\t*pb++ = *sptr++;\n\t\t} else {\t\t\t/* \\\\x -> \\\\x */\n\t\t\t*pb++ = *sptr++;\n\t\t\t*pb++ = *sptr++;\n\t\t}\n\t} else if (sptr[1] == '&') {\t/* literal & */\n\t\tsptr++;\n\t\t*pb++ = *sptr++;\n\t} else\t\t\t\t/* literal \\ */\n\t\t*pb++ = *sptr++;\n\n\t*pb_ptr = pb;\n\t*sptr_ptr = sptr;\n}\n\nstatic char *wide_char_to_byte_str(int rune, size_t *outlen)\n{\n\tstatic char buf[5];\n\tint len;\n\n\tif (rune < 0 || rune > 0x10FFFF)\n\t\treturn NULL;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tlen = 0;\n\tif (rune <= 0x0000007F) {\n\t\tbuf[len++] = rune;\n\t} else if (rune <= 0x000007FF) {\n\t\t// 110xxxxx 10xxxxxx\n\t\tbuf[len++] = 0xC0 | (rune >> 6);\n\t\tbuf[len++] = 0x80 | (rune & 0x3F);\n\t} else if (rune <= 0x0000FFFF) {\n\t\t// 1110xxxx 10xxxxxx 10xxxxxx\n\t\tbuf[len++] = 0xE0 | (rune >> 12);\n\t\tbuf[len++] = 0x80 | ((rune >> 6) & 0x3F);\n\t\tbuf[len++] = 0x80 | (rune & 0x3F);\n\n\t} else {\n\t\t// 0x00010000 - 0x10FFFF\n\t\t// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\t\tbuf[len++] = 0xF0 | (rune >> 18);\n\t\tbuf[len++] = 0x80 | ((rune >> 12) & 0x3F);\n\t\tbuf[len++] = 0x80 | ((rune >> 6) & 0x3F);\n\t\tbuf[len++] = 0x80 | (rune & 0x3F);\n\t}\n\n\t*outlen = len;\n\tbuf[len++] = '\\0';\n\n\treturn buf;\n}\n"
        },
        {
          "name": "testdir",
          "type": "tree",
          "content": null
        },
        {
          "name": "tran.c",
          "type": "blob",
          "size": 16.9697265625,
          "content": "/****************************************************************\nCopyright (C) Lucent Technologies 1997\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name Lucent Technologies or any of\nits entities not be used in advertising or publicity pertaining\nto distribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#define\tDEBUG\n#include <stdio.h>\n#include <math.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"awk.h\"\n\n#define\tFULLTAB\t2\t/* rehash when table gets this x full */\n#define\tGROWTAB 4\t/* grow table by this factor */\n\nArray\t*symtab;\t/* main symbol table */\n\nchar\t**FS;\t\t/* initial field sep */\nchar\t**RS;\t\t/* initial record sep */\nchar\t**OFS;\t\t/* output field sep */\nchar\t**ORS;\t\t/* output record sep */\nchar\t**OFMT;\t\t/* output format for numbers */\nchar\t**CONVFMT;\t/* format for conversions in getsval */\nAwkfloat *NF;\t\t/* number of fields in current record */\nAwkfloat *NR;\t\t/* number of current record */\nAwkfloat *FNR;\t\t/* number of current record in current file */\nchar\t**FILENAME;\t/* current filename argument */\nAwkfloat *ARGC;\t\t/* number of arguments from command line */\nchar\t**SUBSEP;\t/* subscript separator for a[i,j,k]; default \\034 */\nAwkfloat *RSTART;\t/* start of re matched with ~; origin 1 (!) */\nAwkfloat *RLENGTH;\t/* length of same */\n\nCell\t*fsloc;\t\t/* FS */\nCell\t*nrloc;\t\t/* NR */\nCell\t*nfloc;\t\t/* NF */\nCell\t*fnrloc;\t/* FNR */\nCell\t*ofsloc;\t/* OFS */\nCell\t*orsloc;\t/* ORS */\nCell\t*rsloc;\t\t/* RS */\nCell\t*ARGVcell;\t/* cell with symbol table containing ARGV[...] */\nCell\t*rstartloc;\t/* RSTART */\nCell\t*rlengthloc;\t/* RLENGTH */\nCell\t*subseploc;\t/* SUBSEP */\nCell\t*symtabloc;\t/* SYMTAB */\n\nCell\t*nullloc;\t/* a guaranteed empty cell */\nNode\t*nullnode;\t/* zero&null, converted into a node for comparisons */\nCell\t*literal0;\n\nextern Cell **fldtab;\n\nvoid syminit(void)\t/* initialize symbol table with builtin vars */\n{\n\tliteral0 = setsymtab(\"0\", \"0\", 0.0, NUM|STR|CON|DONTFREE, symtab);\n\t/* this is used for if(x)... tests: */\n\tnullloc = setsymtab(\"$zero&null\", \"\", 0.0, NUM|STR|CON|DONTFREE, symtab);\n\tnullnode = celltonode(nullloc, CCON);\n\n\tfsloc = setsymtab(\"FS\", \" \", 0.0, STR|DONTFREE, symtab);\n\tFS = &fsloc->sval;\n\trsloc = setsymtab(\"RS\", \"\\n\", 0.0, STR|DONTFREE, symtab);\n\tRS = &rsloc->sval;\n\tofsloc = setsymtab(\"OFS\", \" \", 0.0, STR|DONTFREE, symtab);\n\tOFS = &ofsloc->sval;\n\torsloc = setsymtab(\"ORS\", \"\\n\", 0.0, STR|DONTFREE, symtab);\n\tORS = &orsloc->sval;\n\tOFMT = &setsymtab(\"OFMT\", \"%.6g\", 0.0, STR|DONTFREE, symtab)->sval;\n\tCONVFMT = &setsymtab(\"CONVFMT\", \"%.6g\", 0.0, STR|DONTFREE, symtab)->sval;\n\tFILENAME = &setsymtab(\"FILENAME\", \"\", 0.0, STR|DONTFREE, symtab)->sval;\n\tnfloc = setsymtab(\"NF\", \"\", 0.0, NUM, symtab);\n\tNF = &nfloc->fval;\n\tnrloc = setsymtab(\"NR\", \"\", 0.0, NUM, symtab);\n\tNR = &nrloc->fval;\n\tfnrloc = setsymtab(\"FNR\", \"\", 0.0, NUM, symtab);\n\tFNR = &fnrloc->fval;\n\tsubseploc = setsymtab(\"SUBSEP\", \"\\034\", 0.0, STR|DONTFREE, symtab);\n\tSUBSEP = &subseploc->sval;\n\trstartloc = setsymtab(\"RSTART\", \"\", 0.0, NUM, symtab);\n\tRSTART = &rstartloc->fval;\n\trlengthloc = setsymtab(\"RLENGTH\", \"\", 0.0, NUM, symtab);\n\tRLENGTH = &rlengthloc->fval;\n\tsymtabloc = setsymtab(\"SYMTAB\", \"\", 0.0, ARR, symtab);\n\tfree(symtabloc->sval);\n\tsymtabloc->sval = (char *) symtab;\n}\n\nvoid arginit(int ac, char **av)\t/* set up ARGV and ARGC */\n{\n\tArray *ap;\n\tCell *cp;\n\tint i;\n\tchar temp[50];\n\n\tARGC = &setsymtab(\"ARGC\", \"\", (Awkfloat) ac, NUM, symtab)->fval;\n\tcp = setsymtab(\"ARGV\", \"\", 0.0, ARR, symtab);\n\tap = makesymtab(NSYMTAB);\t/* could be (int) ARGC as well */\n\tfree(cp->sval);\n\tcp->sval = (char *) ap;\n\tfor (i = 0; i < ac; i++) {\n\t\tdouble result;\n\n\t\tsprintf(temp, \"%d\", i);\n\t\tif (is_number(*av, & result))\n\t\t\tsetsymtab(temp, *av, result, STR|NUM, ap);\n\t\telse\n\t\t\tsetsymtab(temp, *av, 0.0, STR, ap);\n\t\tav++;\n\t}\n\tARGVcell = cp;\n}\n\nvoid envinit(char **envp)\t/* set up ENVIRON variable */\n{\n\tArray *ap;\n\tCell *cp;\n\tchar *p;\n\n\tcp = setsymtab(\"ENVIRON\", \"\", 0.0, ARR, symtab);\n\tap = makesymtab(NSYMTAB);\n\tfree(cp->sval);\n\tcp->sval = (char *) ap;\n\tfor ( ; *envp; envp++) {\n\t\tdouble result;\n\n\t\tif ((p = strchr(*envp, '=')) == NULL)\n\t\t\tcontinue;\n\t\tif( p == *envp ) /* no left hand side name in env string */\n\t\t\tcontinue;\n\t\t*p++ = 0;\t/* split into two strings at = */\n\t\tif (is_number(p, & result))\n\t\t\tsetsymtab(*envp, p, result, STR|NUM, ap);\n\t\telse\n\t\t\tsetsymtab(*envp, p, 0.0, STR, ap);\n\t\tp[-1] = '=';\t/* restore in case env is passed down to a shell */\n\t}\n}\n\nArray *makesymtab(int n)\t/* make a new symbol table */\n{\n\tArray *ap;\n\tCell **tp;\n\n\tap = (Array *) malloc(sizeof(*ap));\n\ttp = (Cell **) calloc(n, sizeof(*tp));\n\tif (ap == NULL || tp == NULL)\n\t\tFATAL(\"out of space in makesymtab\");\n\tap->nelem = 0;\n\tap->size = n;\n\tap->tab = tp;\n\treturn(ap);\n}\n\nvoid freesymtab(Cell *ap)\t/* free a symbol table */\n{\n\tCell *cp, *temp;\n\tArray *tp;\n\tint i;\n\n\tif (!isarr(ap))\n\t\treturn;\n\ttp = (Array *) ap->sval;\n\tif (tp == NULL)\n\t\treturn;\n\tfor (i = 0; i < tp->size; i++) {\n\t\tfor (cp = tp->tab[i]; cp != NULL; cp = temp) {\n\t\t\txfree(cp->nval);\n\t\t\tif (freeable(cp))\n\t\t\t\txfree(cp->sval);\n\t\t\ttemp = cp->cnext;\t/* avoids freeing then using */\n\t\t\tfree(cp);\n\t\t\ttp->nelem--;\n\t\t}\n\t\ttp->tab[i] = NULL;\n\t}\n\tif (tp->nelem != 0)\n\t\tWARNING(\"can't happen: inconsistent element count freeing %s\", ap->nval);\n\tfree(tp->tab);\n\tfree(tp);\n}\n\nvoid freeelem(Cell *ap, const char *s)\t/* free elem s from ap (i.e., ap[\"s\"] */\n{\n\tArray *tp;\n\tCell *p, *prev = NULL;\n\tint h;\n\n\ttp = (Array *) ap->sval;\n\th = hash(s, tp->size);\n\tfor (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)\n\t\tif (strcmp(s, p->nval) == 0) {\n\t\t\tif (prev == NULL)\t/* 1st one */\n\t\t\t\ttp->tab[h] = p->cnext;\n\t\t\telse\t\t\t/* middle somewhere */\n\t\t\t\tprev->cnext = p->cnext;\n\t\t\tif (freeable(p))\n\t\t\t\txfree(p->sval);\n\t\t\tfree(p->nval);\n\t\t\tfree(p);\n\t\t\ttp->nelem--;\n\t\t\treturn;\n\t\t}\n}\n\nCell *setsymtab(const char *n, const char *s, Awkfloat f, unsigned t, Array *tp)\n{\n\tint h;\n\tCell *p;\n\n\tif (n != NULL && (p = lookup(n, tp)) != NULL) {\n\t\tDPRINTF(\"setsymtab found %p: n=%s s=\\\"%s\\\" f=%g t=%o\\n\",\n\t\t\t(void*)p, NN(p->nval), NN(p->sval), p->fval, p->tval);\n\t\treturn(p);\n\t}\n\tp = (Cell *) malloc(sizeof(*p));\n\tif (p == NULL)\n\t\tFATAL(\"out of space for symbol table at %s\", n);\n\tp->nval = tostring(n);\n\tp->sval = s ? tostring(s) : tostring(\"\");\n\tp->fval = f;\n\tp->tval = t;\n\tp->csub = CUNK;\n\tp->ctype = OCELL;\n\ttp->nelem++;\n\tif (tp->nelem > FULLTAB * tp->size)\n\t\trehash(tp);\n\th = hash(n, tp->size);\n\tp->cnext = tp->tab[h];\n\ttp->tab[h] = p;\n\tDPRINTF(\"setsymtab set %p: n=%s s=\\\"%s\\\" f=%g t=%o\\n\",\n\t\t(void*)p, p->nval, p->sval, p->fval, p->tval);\n\treturn(p);\n}\n\nint hash(const char *s, int n)\t/* form hash value for string s */\n{\n\tunsigned hashval;\n\n\tfor (hashval = 0; *s != '\\0'; s++)\n\t\thashval = (*s + 31 * hashval);\n\treturn hashval % n;\n}\n\nvoid rehash(Array *tp)\t/* rehash items in small table into big one */\n{\n\tint i, nh, nsz;\n\tCell *cp, *op, **np;\n\n\tnsz = GROWTAB * tp->size;\n\tnp = (Cell **) calloc(nsz, sizeof(*np));\n\tif (np == NULL)\t\t/* can't do it, but can keep running. */\n\t\treturn;\t\t/* someone else will run out later. */\n\tfor (i = 0; i < tp->size; i++) {\n\t\tfor (cp = tp->tab[i]; cp; cp = op) {\n\t\t\top = cp->cnext;\n\t\t\tnh = hash(cp->nval, nsz);\n\t\t\tcp->cnext = np[nh];\n\t\t\tnp[nh] = cp;\n\t\t}\n\t}\n\tfree(tp->tab);\n\ttp->tab = np;\n\ttp->size = nsz;\n}\n\nCell *lookup(const char *s, Array *tp)\t/* look for s in tp */\n{\n\tCell *p;\n\tint h;\n\n\th = hash(s, tp->size);\n\tfor (p = tp->tab[h]; p != NULL; p = p->cnext)\n\t\tif (strcmp(s, p->nval) == 0)\n\t\t\treturn(p);\t/* found it */\n\treturn(NULL);\t\t\t/* not found */\n}\n\nAwkfloat setfval(Cell *vp, Awkfloat f)\t/* set float val of a Cell */\n{\n\tint fldno;\n\n\tf += 0.0;\t\t/* normalise negative zero to positive zero */\n\tif ((vp->tval & (NUM | STR)) == 0)\n\t\tfunnyvar(vp, \"assign to\");\n\tif (isfld(vp)) {\n\t\tdonerec = false;\t/* mark $0 invalid */\n\t\tfldno = atoi(vp->nval);\n\t\tif (fldno > *NF)\n\t\t\tnewfld(fldno);\n\t\tDPRINTF(\"setting field %d to %g\\n\", fldno, f);\n\t} else if (&vp->fval == NF) {\n\t\tdonerec = false;\t/* mark $0 invalid */\n\t\tsetlastfld(f);\n\t\tDPRINTF(\"setfval: setting NF to %g\\n\", f);\n\t} else if (isrec(vp)) {\n\t\tdonefld = false;\t/* mark $1... invalid */\n\t\tdonerec = true;\n\t\tsavefs();\n\t} else if (vp == ofsloc) {\n\t\tif (!donerec)\n\t\t\trecbld();\n\t}\n\tif (freeable(vp))\n\t\txfree(vp->sval); /* free any previous string */\n\tvp->tval &= ~(STR|CONVC|CONVO); /* mark string invalid */\n\tvp->fmt = NULL;\n\tvp->tval |= NUM;\t/* mark number ok */\n\tif (f == -0)  /* who would have thought this possible? */\n\t\tf = 0;\n\tDPRINTF(\"setfval %p: %s = %g, t=%o\\n\", (void*)vp, NN(vp->nval), f, vp->tval);\n\treturn vp->fval = f;\n}\n\nvoid funnyvar(Cell *vp, const char *rw)\n{\n\tif (isarr(vp))\n\t\tFATAL(\"can't %s %s; it's an array name.\", rw, vp->nval);\n\tif (vp->tval & FCN)\n\t\tFATAL(\"can't %s %s; it's a function.\", rw, vp->nval);\n\tWARNING(\"funny variable %p: n=%s s=\\\"%s\\\" f=%g t=%o\",\n\t\t(void *)vp, vp->nval, vp->sval, vp->fval, vp->tval);\n}\n\nchar *setsval(Cell *vp, const char *s)\t/* set string val of a Cell */\n{\n\tchar *t;\n\tint fldno;\n\tAwkfloat f;\n\n\tDPRINTF(\"starting setsval %p: %s = \\\"%s\\\", t=%o, r,f=%d,%d\\n\",\n\t\t(void*)vp, NN(vp->nval), s, vp->tval, donerec, donefld);\n\tif ((vp->tval & (NUM | STR)) == 0)\n\t\tfunnyvar(vp, \"assign to\");\n\tif (CSV && (vp == rsloc))\n\t\tWARNING(\"danger: don't set RS when --csv is in effect\");\n\tif (CSV && (vp == fsloc))\n\t\tWARNING(\"danger: don't set FS when --csv is in effect\");\n\tif (isfld(vp)) {\n\t\tdonerec = false;\t/* mark $0 invalid */\n\t\tfldno = atoi(vp->nval);\n\t\tif (fldno > *NF)\n\t\t\tnewfld(fldno);\n\t\tDPRINTF(\"setting field %d to %s (%p)\\n\", fldno, s, (const void*)s);\n\t} else if (isrec(vp)) {\n\t\tdonefld = false;\t/* mark $1... invalid */\n\t\tdonerec = true;\n\t\tsavefs();\n\t} else if (vp == ofsloc) {\n\t\tif (!donerec)\n\t\t\trecbld();\n\t}\n\tt = s ? tostring(s) : tostring(\"\");\t/* in case it's self-assign */\n\tif (freeable(vp))\n\t\txfree(vp->sval);\n\tvp->tval &= ~(NUM|DONTFREE|CONVC|CONVO);\n\tvp->tval |= STR;\n\tvp->fmt = NULL;\n\tDPRINTF(\"setsval %p: %s = \\\"%s (%p) \\\", t=%o r,f=%d,%d\\n\",\n\t\t(void*)vp, NN(vp->nval), t, (void*)t, vp->tval, donerec, donefld);\n\tvp->sval = t;\n\tif (&vp->fval == NF) {\n\t\tdonerec = false;\t/* mark $0 invalid */\n\t\tf = getfval(vp);\n\t\tsetlastfld(f);\n\t\tDPRINTF(\"setsval: setting NF to %g\\n\", f);\n\t}\n\n\treturn(vp->sval);\n}\n\nAwkfloat getfval(Cell *vp)\t/* get float val of a Cell */\n{\n\tif ((vp->tval & (NUM | STR)) == 0)\n\t\tfunnyvar(vp, \"read value of\");\n\tif (isfld(vp) && !donefld)\n\t\tfldbld();\n\telse if (isrec(vp) && !donerec)\n\t\trecbld();\n\tif (!isnum(vp)) {\t/* not a number */\n\t\tdouble fval;\n\t\tbool no_trailing;\n\n\t\tif (is_valid_number(vp->sval, true, & no_trailing, & fval)) {\n\t\t\tvp->fval = fval;\n\t\t\tif (no_trailing && !(vp->tval&CON))\n\t\t\t\tvp->tval |= NUM;\t/* make NUM only sparingly */\n\t\t} else\n\t\t\tvp->fval = 0.0;\n\t}\n\tDPRINTF(\"getfval %p: %s = %g, t=%o\\n\",\n\t\t(void*)vp, NN(vp->nval), vp->fval, vp->tval);\n\treturn(vp->fval);\n}\n\nstatic const char *get_inf_nan(double d)\n{\n\tif (isinf(d)) {\n\t\treturn (d < 0 ? \"-inf\" : \"+inf\");\n\t} else if (isnan(d)) {\n\t\treturn (signbit(d) != 0 ? \"-nan\" : \"+nan\");\n\t} else\n\t\treturn NULL;\n}\n\nstatic char *get_str_val(Cell *vp, char **fmt)        /* get string val of a Cell */\n{\n\tchar s[256];\n\tdouble dtemp;\n\tconst char *p;\n\n\tif ((vp->tval & (NUM | STR)) == 0)\n\t\tfunnyvar(vp, \"read value of\");\n\tif (isfld(vp) && ! donefld)\n\t\tfldbld();\n\telse if (isrec(vp) && ! donerec)\n\t\trecbld();\n\n\t/*\n\t * ADR: This is complicated and more fragile than is desirable.\n\t * Retrieving a string value for a number associates the string\n\t * value with the scalar.  Previously, the string value was\n\t * sticky, meaning if converted via OFMT that became the value\n\t * (even though POSIX wants it to be via CONVFMT). Or if CONVFMT\n\t * changed after a string value was retrieved, the original value\n\t * was maintained and used.  Also not per POSIX.\n\t *\n\t * We work around this design by adding two additional flags,\n\t * CONVC and CONVO, indicating how the string value was\n\t * obtained (via CONVFMT or OFMT) and _also_ maintaining a copy\n\t * of the pointer to the xFMT format string used for the\n\t * conversion.  This pointer is only read, **never** dereferenced.\n\t * The next time we do a conversion, if it's coming from the same\n\t * xFMT as last time, and the pointer value is different, we\n\t * know that the xFMT format string changed, and we need to\n\t * redo the conversion. If it's the same, we don't have to.\n\t *\n\t * There are also several cases where we don't do a conversion,\n\t * such as for a field (see the checks below).\n\t */\n\n\t/* Don't duplicate the code for actually updating the value */\n#define update_str_val(vp) \\\n\t{ \\\n\t\tif (freeable(vp)) \\\n\t\t\txfree(vp->sval); \\\n\t\tif ((p = get_inf_nan(vp->fval)) != NULL) \\\n\t\t\tstrcpy(s, p); \\\n\t\telse if (modf(vp->fval, &dtemp) == 0)\t/* it's integral */ \\\n\t\t\tsnprintf(s, sizeof (s), \"%.30g\", vp->fval); \\\n\t\telse \\\n\t\t\tsnprintf(s, sizeof (s), *fmt, vp->fval); \\\n\t\tvp->sval = tostring(s); \\\n\t\tvp->tval &= ~DONTFREE; \\\n\t\tvp->tval |= STR; \\\n\t}\n\n\tif (isstr(vp) == 0) {\n\t\tupdate_str_val(vp);\n\t\tif (fmt == OFMT) {\n\t\t\tvp->tval &= ~CONVC;\n\t\t\tvp->tval |= CONVO;\n\t\t} else {\n\t\t\t/* CONVFMT */\n\t\t\tvp->tval &= ~CONVO;\n\t\t\tvp->tval |= CONVC;\n\t\t}\n\t\tvp->fmt = *fmt;\n\t} else if ((vp->tval & DONTFREE) != 0 || ! isnum(vp) || isfld(vp)) {\n\t\tgoto done;\n\t} else if (isstr(vp)) {\n\t\tif (fmt == OFMT) {\n\t\t\tif ((vp->tval & CONVC) != 0\n\t\t\t    || ((vp->tval & CONVO) != 0 && vp->fmt != *fmt)) {\n\t\t\t\tupdate_str_val(vp);\n\t\t\t\tvp->tval &= ~CONVC;\n\t\t\t\tvp->tval |= CONVO;\n\t\t\t\tvp->fmt = *fmt;\n\t\t\t}\n\t\t} else {\n\t\t\t/* CONVFMT */\n\t\t\tif ((vp->tval & CONVO) != 0\n\t\t\t    || ((vp->tval & CONVC) != 0 && vp->fmt != *fmt)) {\n\t\t\t\tupdate_str_val(vp);\n\t\t\t\tvp->tval &= ~CONVO;\n\t\t\t\tvp->tval |= CONVC;\n\t\t\t\tvp->fmt = *fmt;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tDPRINTF(\"getsval %p: %s = \\\"%s (%p)\\\", t=%o\\n\",\n\t\t(void*)vp, NN(vp->nval), vp->sval, (void*)vp->sval, vp->tval);\n\treturn(vp->sval);\n}\n\nchar *getsval(Cell *vp)       /* get string val of a Cell */\n{\n      return get_str_val(vp, CONVFMT);\n}\n\nchar *getpssval(Cell *vp)     /* get string val of a Cell for print */\n{\n      return get_str_val(vp, OFMT);\n}\n\n\nchar *tostring(const char *s)\t/* make a copy of string s */\n{\n\tchar *p = strdup(s);\n\tif (p == NULL)\n\t\tFATAL(\"out of space in tostring on %s\", s);\n\treturn(p);\n}\n\nchar *tostringN(const char *s, size_t n)\t/* make a copy of string s */\n{\n\tchar *p;\n\n\tp = (char *) malloc(n);\n\tif (p == NULL)\n\t\tFATAL(\"out of space in tostring on %s\", s);\n\tstrcpy(p, s);\n\treturn(p);\n}\n\nCell *catstr(Cell *a, Cell *b) /* concatenate a and b */\n{\n\tCell *c;\n\tchar *p;\n\tchar *sa = getsval(a);\n\tchar *sb = getsval(b);\n\tsize_t l = strlen(sa) + strlen(sb) + 1;\n\tp = (char *) malloc(l);\n\tif (p == NULL)\n\t\tFATAL(\"out of space concatenating %s and %s\", sa, sb);\n\tsnprintf(p, l, \"%s%s\", sa, sb);\n\n\tl++;\t// add room for ' '\n\tchar *newbuf = (char *) malloc(l);\n\tif (newbuf == NULL)\n\t\tFATAL(\"out of space concatenating %s and %s\", sa, sb);\n\t// See string() in lex.c; a string \"xx\" is stored in the symbol\n\t// table as \"xx \".\n\tsnprintf(newbuf, l, \"%s \", p);\n\tc = setsymtab(newbuf, p, 0.0, CON|STR|DONTFREE, symtab);\n\tfree(p);\n\tfree(newbuf);\n\treturn c;\n}\n\nchar *qstring(const char *is, int delim)\t/* collect string up to next delim */\n{\n\tint c, n;\n\tconst uschar *s = (const uschar *) is;\n\tuschar *buf, *bp;\n\n\tif ((buf = (uschar *) malloc(strlen(is)+3)) == NULL)\n\t\tFATAL( \"out of space in qstring(%s)\", s);\n\tfor (bp = buf; (c = *s) != delim; s++) {\n\t\tif (c == '\\n')\n\t\t\tSYNTAX( \"newline in string %.20s...\", is );\n\t\telse if (c != '\\\\')\n\t\t\t*bp++ = c;\n\t\telse {\t/* \\something */\n\t\t\tc = *++s;\n\t\t\tif (c == 0) {\t/* \\ at end */\n\t\t\t\t*bp++ = '\\\\';\n\t\t\t\tbreak;\t/* for loop */\n\t\t\t}\n\t\t\tswitch (c) {\n\t\t\tcase '\\\\':\t*bp++ = '\\\\'; break;\n\t\t\tcase 'n':\t*bp++ = '\\n'; break;\n\t\t\tcase 't':\t*bp++ = '\\t'; break;\n\t\t\tcase 'b':\t*bp++ = '\\b'; break;\n\t\t\tcase 'f':\t*bp++ = '\\f'; break;\n\t\t\tcase 'r':\t*bp++ = '\\r'; break;\n\t\t\tcase 'v':\t*bp++ = '\\v'; break;\n\t\t\tcase 'a':\t*bp++ = '\\a'; break;\n\t\t\tdefault:\n\t\t\t\tif (!isdigit(c)) {\n\t\t\t\t\t*bp++ = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn = c - '0';\n\t\t\t\tif (isdigit(s[1])) {\n\t\t\t\t\tn = 8 * n + *++s - '0';\n\t\t\t\t\tif (isdigit(s[1]))\n\t\t\t\t\t\tn = 8 * n + *++s - '0';\n\t\t\t\t}\n\t\t\t\t*bp++ = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*bp++ = 0;\n\treturn (char *) buf;\n}\n\nconst char *flags2str(int flags)\n{\n\tstatic const struct ftab {\n\t\tconst char *name;\n\t\tint value;\n\t} flagtab[] = {\n\t\t{ \"NUM\", NUM },\n\t\t{ \"STR\", STR },\n\t\t{ \"DONTFREE\", DONTFREE },\n\t\t{ \"CON\", CON },\n\t\t{ \"ARR\", ARR },\n\t\t{ \"FCN\", FCN },\n\t\t{ \"FLD\", FLD },\n\t\t{ \"REC\", REC },\n\t\t{ \"CONVC\", CONVC },\n\t\t{ \"CONVO\", CONVO },\n\t\t{ NULL, 0 }\n\t};\n\tstatic char buf[100];\n\tint i;\n\tchar *cp = buf;\n\n\tfor (i = 0; flagtab[i].name != NULL; i++) {\n\t\tif ((flags & flagtab[i].value) != 0) {\n\t\t\tif (cp > buf)\n\t\t\t\t*cp++ = '|';\n\t\t\tstrcpy(cp, flagtab[i].name);\n\t\t\tcp += strlen(cp);\n\t\t}\n\t}\n\n\treturn buf;\n}\n"
        }
      ]
    }
  ]
}