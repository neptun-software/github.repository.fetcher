{
  "metadata": {
    "timestamp": 1736710010872,
    "page": 605,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mkirchner/linked-list-good-taste",
      "stars": 2098,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.017578125,
          "content": "*.o\nsrc/test_list\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2020 Marc Kirchner\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.0625,
          "content": "# Linked lists, pointer tricks and good taste\n\n* [Introduction](#introduction)\n* [The code](#the-code)\n   * [The CS101 version](#the-cs101-version)\n   * [A more elegant solution](#a-more-elegant-solution)\n* [How does it work?](#how-does-it-work)\n   * [Integrating the head pointer](#integrating-the-head-pointer)\n   * [Maintaining a handle](#maintaining-a-handle)\n* [Going beyond](#going-beyond)\n   * [Inserting before existing items](#inserting-before-existing-items)\n   * [Quick refactor](#quick-refactor)\n   * [Implementing insert_before()](#implementing-insert_before)\n* [Conclusion](#conclusion)\n\n\n## Introduction\n\nIn a 2016 [TED interview][ted] (14:10) Linus Torvalds speaks about what he\nconsiders *good taste* in coding. As an example, he presents two\nimplementations of item removal in singly linked lists (reproduced below).  In\norder to remove the first item from a list, one of the implementations requires\na special case, the other one does not.  Linus, obviously, prefers the latter.\n\nHis comment is:\n\n> [...] I don't want you to understand why it doesn't have the if statement.\n> But I want you to understand that sometimes you can see a problem in a\n> different way and rewrite it so that a special case goes away and becomes the\n> normal case, and that's *good code*. [...] -- L. Torvalds\n\nThe code snippets he presents are C-style pseudocode and are simple enough to\nfollow. However, as Linus mentions in the comment, the snippets lack a\nconceptual explanation and it is not immediately evident how the more elegant\nsolution actually works.\n\nThe next two sections look at the technical approach in detail and demonstrate\nhow and why the indirect addressing approach is so neat. The last section\nextends the solution from item deletion to insertion.\n\n\n## The code\n\nThe basic data structure for a singly linked list of integers is shown in\nFigure 1.\n\n<p align=\"center\">\n<img alt=\"linked list\" src=\"img/linked-list.png\" width=\"600\">\n<br />\n<b>Figure 1</b>: Singly linked list of integers.\n</p>\n\nNumbers are arbitrarily chosen integer values and arrows indicate pointers.\n`head` is a pointer of type `list_item *` and each of the boxes\nis an instance of an `list_item` struct, each with a member variable (called\n`next` in the code) of type `list_item *` that points to the next item.\n\nThe C implementation of the data structure is:\n\n```c\nstruct list_item {\n        int value;\n        struct list_item *next;\n};\ntypedef struct list_item list_item;\n\nstruct list {\n        struct list_item *head;\n};\ntypedef struct list list;\n\n```\nWe also include a (minimal) API:\n\n```c\n/* The textbook version */\nvoid remove_cs101(list *l, list_item *target);\n/* A more elegant solution */\nvoid remove_elegant(list *l, list_item *target);\n```\n\nWith that in place, let's have a look at the implementations of\n`remove_cs101()` and `remove_elegant()`. The code of these examples is true\nto the pseudocode from Linus' example and also compiles and runs.\n\n### The CS101 version\n\n<p align=\"center\">\n<img alt=\"simple data model\" src=\"img/data-model-cs101.png\" width=\"600\">\n<br />\n<b>Figure 2</b>: The conceptual model for the list data structure in the CS101 algorithm.\n</p>\n\n```c\nvoid remove_cs101(list *l, list_item *target)\n{\n        list_item *cur = l->head, *prev = NULL;\n        while (cur != target) {\n                prev = cur;\n                cur = cur->next;\n        }\n        if (prev)\n                prev->next = cur->next;\n        else\n                l->head = cur->next;\n}\n```\n\nThe standard CS101 approach makes use of two traversal pointers `cur` and\n`prev`, marking the current and previous traversal position in the list,\nrespectively.  `cur` starts at the list head `head`, and advances until the\ntarget is found.  `prev` starts at `NULL` and is subsequently updated with the\nprevious value of `cur` every time `cur` advances. After the target is found,\nthe algorithm tests if `prev` is non-`NULL`. If yes, the item is not at the\nbeginning of the list and the removal consists of re-routing the linked list\naround `cur`. If `prev` is `NULL`, `cur` is pointing to the first element in\nthe list, in which case, removal means moving the list head forward.\n\n### A more elegant solution\n\nThe more elegant version has less code and does not require a separate branch\nto deal with deletion of the first element in a list.\n\n```c\nvoid remove_elegant(list *l, list_item *target)\n{\n        list_item **p = &l->head;\n        while (*p != target)\n                p = &(*p)->next;\n        *p = target->next;\n}\n```\n\nThe code uses an indirect pointer `p` that holds the address of a pointer to a\nlist item, starting with the address of `head`.  In every iteration, that\npointer is advanced to hold the address of the pointer to the next list item,\ni.e. the address of the `next` element in the current `list_item`.\nWhen the pointer to the list item `*p` equals `target`, we exit the search\nloop and remove the item from the list.\n\n\n## How does it work?\n\nThe key insight is that using an indirect pointer `p` has two conceptual\nbenefits:\n\n1. It allows us to interpret the linked list in a way that makes the `head`\n   pointer an integral part the data structure. This eliminates the need \n   for a special case to remove the first item.\n2. It also allows us to evaluate the condition of the `while` loop without\n   having to let go of the pointer that points to `target`. This allows us to\n   modify the pointer that points to `target` and to get away with a single\n   iterator as opposed to `prev` and `cur`.\n\nLet's look each of these points in turn.\n\n### Integrating the `head` pointer\n\nThe standard model interprets the linked list as a sequence of `list_item`\ninstances. The beginning of the sequence can be accessed through a `head`\npointer. This leads to the conceptual model illustrated in Figure 2 above. The `head` pointer is\nmerely considered as a handle to access the start of the list. `prev` and `cur`\nare pointers of type `list_item *` and always point to an item or `NULL`.\n\nThe elegant implementation uses indirect addressing scheme that yields a different\nview on the data structure:\n\n<p align=\"center\">\n<img alt=\"Data model for indirect addressing\" src=\"img/data-model-indirect.png\" width=\"600\">\n<br />\n<b>Figure 3</b>: The conceptual model for the list data structure in the more\nelegant approach.\n</p>\n\nHere, `p` is of type `list_item **` and holds the address of the pointer to\nthe current list item. When we advance the pointer, we forward to the address\nof the pointer to the next list item.\n\nIn code, this translates to `p = &(*p)->next`, meaning we\n\n1. `(*p)`: dereference the address to the pointer to the current list item\n2. `->next`: dereference that pointer again and select the field that holds\n   the address of the next list item\n3. `&`: take the address of that address field (i.e. get a pointer to it)\n\nThis corresponds to an interpretation of the data structure where the list is a\na sequence of pointers to `list_item`s (cf. Figure 3).\n\n### Maintaining a handle\n\nAn additional benefit of that particular interpretation is that it supports\nediting the `next` pointer of the predecessor of the current item throughout the\nentire traversal.\n\nWith `p` holding the address of a pointer to a list item, the comparison in the\nsearch loop becomes\n\n```c\nwhile (*p != target)\n```\n\nThe search loop will exit if `*p` equals `target`, and once it does, we are\nstill able to modify `*p` since we hold its address `p`. Thus, despite\niterating the loop until we hit `target`, we still maintain a handle (the\naddress of the `next` field or the `head` pointer) that can be used to directly\nmodify the pointer that points *to* the item.\n\nThis is the reason why we can modify the incoming pointer to an item to point\nto a different location using `*p = target->next` and why we do not need `prev`\nand `cur` pointers to traverse the list for item removal.\n\n## Going beyond\n\nIt turns out that the idea behind `remove_elegant()` can be applied to yield a\nparticularly concise implementation of another function in the list API:\n`insert_before()`, i.e. inserting a given item before another one.\n\n### Inserting before existing items\n\nFirst, let's add the following declaration to the list API in `list.h`:\n\n```c\nvoid insert_before(list *l, list_item *before, list_item *item);\n```\n\nThe function will take a pointer to a list `l`, a pointer `before` to an \nitem in that list and a pointer to a new list item `item` that the function\nwill insert before `before`.\n\n### Quick refactor\n\nBefore we move on, we refactor the search loop into a separate\nfunction\n\n```c\n\nstatic inline list_item **find_indirect(list *l, list_item *target)\n{\n        list_item **p = &l->head;\n        while (*p != target)\n                p = &(*p)->next;\n        return p;\n}\n\n```\n\nand use that function in `remove_elegant()` like so\n\n```c\nvoid remove_elegant(list *l, list_item *target)\n{\n        list_item **p = find_indirect(l, target);\n        *p = target->next;\n}\n```\n\n### Implementing `insert_before()`\n\nUsing `find_indirect()`, it is straightforward to implement `insert_before()`:\n\n```c\nvoid insert_before(list *l, list_item *before, list_item *item)\n{\n        list_item **p = find_indirect(l, before);\n        *p = item;\n        item->next = before;\n}\n```\n\nA particularly beautiful outcome is that the implementation has consistent\nsemantics for the edge cases: if `before` points to the list head, the new item\nwill be inserted at the beginning of the list, if `before` is `NULL` or invalid\n(i.e. the item does not exist in `l`), the new item will be appended at the\nend.\n\n\n## Conclusion\n\nThe premise of the more elegant solution for item deletion is a single, simple\nchange: using an indirect `list_item **` pointer to iterate over the pointers\nto the list items.  Everything else flows from there: there is no need for a\nspecial case or branching and a single iterator is sufficient to find and\nremove the target item.\nIt also turns out that the same approach provides an elegant solution for item\ninsertion in general and for insertion *before* an existing item in particular.\n\nSo, going back to Linus' initial comment: is it good taste? Hard to say, but\nit's certainly a different, creative and very elegant solution to a well-known\nCS task.\n\n[ted]: https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}