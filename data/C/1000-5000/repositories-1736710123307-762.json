{
  "metadata": {
    "timestamp": 1736710123307,
    "page": 762,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sustrik/libdill",
      "stars": 1825,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6005859375,
          "content": "# Ignore all files with no extension\n*\n!*.*\n\n.deps/\n.libs/\nMakefile\nMakefile.in\naclocal.m4\nautom4te.cache/\ncompile\nconfig.guess\nconfig.h\nconfig.log\nconfig.status\nconfig.sub\nconfigure\ndepcomp\ninstall-sh\nlibdill.pc\n*.o\n*.lo\n*.la\nlibtool\nltmain.sh\nm4/*.m4\nmissing\ntest-driver\ntests/.deps/\ntests/.dirstamp\ntests/.libs/\ntests/*.log\ntests/*.trs\ntests/*.o\ntest-suite.log\ndns/.deps/\ndns/.dirstamp\nperf/.dirstamp\n*.gcno\n*.gcda\ntests/*.gcno\ntests/*.gcda\ndns/*.gcno\ndns/*.gcda\ntutorial/basics/*.o\ntutorial/basics/.dirstamp\ntutorial/protocol/*.o\ntutorial/protocol/.dirstamp\ntutorial/sockets/.dirstamp\nexamples/.dirstamp\nbuild/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 4.5400390625,
          "content": "language: c\n\nsudo: false\n\nmatrix:\n  include:\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: clang\n    env: \n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - clang\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - STATIC=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: clang\n    env: STATIC=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - clang\n  - os: osx\n    compiler: clang\n    env: \n  - os: osx\n    compiler: clang\n    env: STATIC=1\n  - os: osx\n    compiler: clang\n    env: NOTHREADS=1\n  - os: osx\n    compiler: clang\n    env:\n      - STATIC=1\n      - NOTHREADS=1\n  - os: linux\n    compiler: gcc\n    env: DIST=1\n    dist: trusty\n    sudo: true\n    before_install:\n      - sudo apt-get -qq update\n      - sudo apt-get install -y pandoc\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - POLL=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - NOTHREADS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - CENSUS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - VALGRIND=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n          - valgrind\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - STATIC=1\n      - VALGRIND=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n          - valgrind\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - NOTHREADS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - VALGRIND=1 \n      - NOTHREADS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n          - valgrind\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - POLL=1\n      - NOTHREADS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - STATIC=1\n      - NOTHREADS=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\" \n      - ARCH_FALLBACK=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n  - os: linux\n    compiler: clang\n    env: ARCH_FALLBACK=1 \n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - clang\n  - os: linux\n    compiler: gcc\n    env:\n      - MATRIX_EVAL=\"CC=gcc-7\"\n      - THREAD_FALLBACK=1\n    addons:\n      apt:\n        sources:\n          - ubuntu-toolchain-r-test\n        packages:\n          - gcc-7\n\n#\n# Travis has old version of OpenSSL. Find out how to install version 1.1.0.\n#\n# - os: linux\n#    compiler: gcc\n#    env: TLS=1\n#    addons:\n#      apt:\n#        sources:\n#          - ubuntu-toolchain-r-test\n#        packages:\n#          - gcc-7\n#  - os: osx\n#    compiler: clang\n#    env: TLS=1\n#    before_install: brew install openssl\n#\n\nbranches:\n  except:\n    - gh-pages\n\nbefore_install:\n    - eval \"${MATRIX_EVAL}\"\n\ninstall:\n  - ./autogen.sh\n  - ./configure ${STATIC+--disable-shared} ${DEBUG+--enable-debug} ${VALGRIND+--enable-valgrind} ${CENSUS+--enable-census} ${TLS+--enable-tls} ${NOTHREADS+--disable-threads} CFLAGS=\"-O3 ${POLL+-DDILL_POLL} ${ARCH_FALLBACK+-DDILL_ARCH_FALLBACK} ${THREAD_FALLBACK+-DDILL_THREAD_FALLBACK} -DDILL_SLOW_TESTS\"\n  - make V=1 ${DIST+dist}\n\nscript:\n  - test ${DIST+x} || make check\n\nafter_failure:\n  - for f in tests/*.log; do echo; echo \"${f}:\"; cat $f; done;\n  - cat test-suite.log\n\nnotifications:\n  email: false\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.1162109375,
          "content": "Full list of copyright holders:\n\nAlex Cornejo <acornejo@gmail.com>\nBent Cardan <bent@nothingsatisfies.com>\nConstantine Tarasenkov <constantine@protonmail.com>\nDamien Grassart <damien@grassart.com>\nEli Riggs <eli@rje.li>\nGonzalo Diethelm <gonzalo.diethelm@diethelm.org>*\nJean-Francois Smigielski <jf.smigielski@gmail.com>\nJim Jagielski <jimjag@gmail.com> \nJim Schimpf <jim.schimpf@gmail.com>\nJoseph deBlaquiere <jadeblaquiere@yahoo.com>\nLuca Barbato <luca.barbato@gmail.com>\nMartin Lucina <martin@lucina.net>\nMartin Sustrik <sustrik@250bpm.com>*\nMaximilian Pudelko <maximilian.pudelko@gmail.com>\nMichael Gehring <mg@ebfe.org>\nNick Desaulniers <nick@mozilla.com>\nNickolay Ilyushin <nickolay02@inbox.ru>\nNir Soffer <nsoffer@redhat.com>\nPaul Banks <banks@banksdesigns.co.uk>\nPetr Skocik <pskocik@gmail.com>\nSergey Avseyev <sergey.avseyev@gmail.com>\nTai Chi Minh Ralph Eastwood <tcmreastwood@gmail.com>*\nYue Xu <red_angelx@qq.com>\nZach Banks <zbanks@mit.edu>\n\n* Future patches by this author are submitted under the MIT/X11 license\n\nCopyrights for DNS resolution library in dns subdirectory are owned by:\nWilliam Ahern <william@25thandClement.com>\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 5.076171875,
          "content": "# CMake build system is not officially supported.\n# If you find out it's not working fix it and send a pull request.\n\ncmake_minimum_required(VERSION 3.1)\nproject(libdill VERSION 1.6 LANGUAGES C)\n\ninclude(CheckSymbolExists)\ninclude(CheckFunctionExists)\n\nfile(GLOB sources ${CMAKE_CURRENT_LIST_DIR}/*.c ${CMAKE_CURRENT_LIST_DIR}/dns/dns.c)\ninclude_directories(${PROJECT_SOURCE_DIR} \"${PROJECT_SOURCE_DIR}/dns\")\nset_source_files_properties(dns/dns.c PROPERTIES COMPILE_FLAGS -std=c99)\nadd_library(dill ${sources})\n\n# add pthread\nlist(APPEND CMAKE_REQUIRED_LIBRARIES pthread)\ntarget_link_libraries(dill pthread)\n\n# add openssl # requires libssl-dev on ubuntu\nlist(APPEND CMAKE_REQUIRED_LIBRARIES ssl crypto)\ntarget_link_libraries(dill ssl crypto)\n\n# check and enable rt if available\nlist(APPEND CMAKE_REQUIRED_LIBRARIES rt)\ncheck_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)\nif(HAVE_CLOCK_GETTIME)\n  target_link_libraries(dill rt)\nendif()\n\n# Installation (https://github.com/forexample/package-example)\n\n# Layout. This works for all platforms:\n#   * <prefix>/lib/cmake/<PROJECT-NAME>\n#   * <prefix>/lib/\n#   * <prefix>/include/\nset(config_install_dir \"lib/cmake/${PROJECT_NAME}\")\nset(include_install_dir \"include\")\n\nset(generated_dir \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\n\n# Configuration\nset(version_config \"${generated_dir}/${PROJECT_NAME}ConfigVersion.cmake\")\nset(project_config \"${generated_dir}/${PROJECT_NAME}Config.cmake\")\nset(TARGETS_EXPORT_NAME \"${PROJECT_NAME}Targets\")\nset(namespace \"${PROJECT_NAME}::\")\n\n# Include module with fuction 'write_basic_package_version_file'\ninclude(CMakePackageConfigHelpers)\n\n# Configure '<PROJECT-NAME>ConfigVersion.cmake'\n# Use:\n#   * PROJECT_VERSION\nwrite_basic_package_version_file(\n    \"${version_config}\" COMPATIBILITY SameMajorVersion\n)\n\n# Configure '<PROJECT-NAME>Config.cmake'\n# Use variables:\n#   * TARGETS_EXPORT_NAME\n#   * PROJECT_NAME\nconfigure_package_config_file(\n    \"cmake/Config.cmake.in\"\n    \"${project_config}\"\n    INSTALL_DESTINATION \"${config_install_dir}\"\n)\n\n# Targets:\n#   * <prefix>/lib/libdill.a\n#   * header location after install: <prefix>/include/libdill.h\ninstall(\n    TARGETS dill\n    EXPORT \"${TARGETS_EXPORT_NAME}\"\n    LIBRARY DESTINATION \"lib\"\n    ARCHIVE DESTINATION \"lib\"\n    RUNTIME DESTINATION \"bin\"\n    INCLUDES DESTINATION \"${include_install_dir}\"\n)\n\n# Headers:\n#   * libdill.h -> <prefix>/include/libdill.h\ninstall(\n    FILES libdill.h\n    DESTINATION \"${include_install_dir}\"\n)\n\n# Config\n#   * <prefix>/lib/cmake/libdill/libdillConfig.cmake\n#   * <prefix>/lib/cmake/libdill/libdillConfigVersion.cmake\ninstall(\n    FILES \"${project_config}\" \"${version_config}\"\n    DESTINATION \"${config_install_dir}\"\n)\n\n# Config\n#   * <prefix>/lib/cmake/libdill/libdillTargets.cmake\ninstall(\n    EXPORT \"${TARGETS_EXPORT_NAME}\"\n    NAMESPACE \"${namespace}\"\n    DESTINATION \"${config_install_dir}\"\n)\n\nset(CMAKE_REQUIRED_LIBRARIES )\n\n# check and enable stack guard and dns if available\nlist(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\n\nset(CMAKE_REQUIRED_LIBRARIES )\nset(CMAKE_REQUIRED_DEFINITIONS )\n\nadd_definitions(-DDILL_THREADS)\nadd_definitions(-DDILL_SOCKETS)\n\ncheck_function_exists(mprotect HAVE_MPROTECT)\nif(HAVE_MPROTECT)\n  add_definitions(-DHAVE_MPROTECT)\nendif()\n\ncheck_function_exists(posix_memalign HAVE_POSIX_MEMALIGN)\nif(HAVE_POSIX_MEMALIGN)\n  add_definitions(-DHAVE_POSIX_MEMALIGN)\nendif()\n\n# tests\ninclude(CTest)\nif(BUILD_TESTING)\n    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/tests)\n    set(test_files\n        tests/bundle.c\n        tests/chan.c\n        tests/choose.c\n        tests/example.c\n        tests/fd.c\n        tests/go1.c\n        tests/go2.c\n        tests/go3.c\n        tests/go4.c\n        tests/go5.c\n        tests/handle.c\n        tests/happyeyeballs.c\n        tests/http.c\n        tests/iol.c\n        tests/ipaddr.c\n        tests/ipc.c\n        tests/overload.c\n        tests/prefix.c\n        tests/rbtree.c\n        tests/signals.c\n        tests/sleep.c\n        tests/socks5.c\n        tests/suffix.c\n        tests/tcp.c\n        tests/threads.c\n        tests/threads2.c\n        tests/tls.c\n        tests/udp.c\n        tests/ws.c)\n    foreach(test_file IN LISTS test_files)\n      get_filename_component(test_name ${test_file} NAME_WE)\n      add_executable(test_${test_name} ${test_file})\n      set_target_properties(test_${test_name} PROPERTIES\n        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests\n        OUTPUT_NAME ${test_name})\n      target_link_libraries(test_${test_name} dill)\n      add_test(test_${test_name} tests/${test_name})\n    endforeach()\nendif()\n\n# perf\nif(BUILD_PERF)\n    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/perf)\n    set(perf_files\n        perf/chan.c\n        perf/choose.c\n        perf/ctxswitch.c\n        perf/go.c\n        perf/hdone.c\n        perf/timer.c\n        perf/whispers.c)\n    foreach(perf_file IN LISTS perf_files)\n      get_filename_component(perf_name ${perf_file} NAME_WE)\n      add_executable(perf_${perf_name} ${perf_file})\n      set_target_properties(perf_${perf_name} PROPERTIES\n        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/perf\n        OUTPUT_NAME ${perf_name})\n      target_link_libraries(perf_${perf_name} dill)\n    endforeach()\nendif()\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0009765625,
          "content": "\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom\nthe Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 6.646484375,
          "content": "#\n# Copyright (c) 2016 Martin Sustrik  All rights reserved.\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nACLOCAL_AMFLAGS = -I m4\n\n################################################################################\n#  libdill library                                                             #\n################################################################################\n\ndillincludedir = $(includedir)\ndillinclude_HEADERS = libdill.h libdillimpl.h\n\nlib_LTLIBRARIES = libdill.la\n\nlibdill_la_SOURCES = \\\n    chan.c \\\n    cr.h \\\n    cr.c \\\n    epoll.h.inc \\\n    epoll.c.inc \\\n    handle.h \\\n    handle.c \\\n    kqueue.h.inc \\\n    kqueue.c.inc \\\n    libdill.c \\\n    list.h \\\n    now.h \\\n    now.c \\\n    poll.h.inc \\\n    poll.c.inc \\\n    pollset.h \\\n    pollset.c \\\n    qlist.h \\\n    rbtree.h \\\n    rbtree.c \\\n    slist.h \\\n    stack.h \\\n    stack.c \\\n    ctx.h \\\n    ctx.c \\\n    utils.h \\\n    utils.c\n\nif DILL_SOCKETS\nlibdill_la_SOURCES += \\\n    bsock.c \\\n    fd.h \\\n    fd.c \\\n    happyeyeballs.c \\\n    http.c \\\n    iol.h \\\n    iol.c \\\n    ipc.c \\\n    ipaddr.c \\\n    msock.c \\\n    prefix.c \\\n    socks5.c \\\n    suffix.c \\\n    tcp.c \\\n    term.c \\\n    udp.c \\\n    ws.c \\\n    dns/dns.h \\\n    dns/dns.c\nendif\n\nif DILL_SOCKETS\nif HAVE_TLS\nlibdill_la_SOURCES += \\\n    tls.c\nendif\nendif\n\npkgconfigdir = $(libdir)/pkgconfig\npkgconfig_DATA = libdill.pc\n\nlibdill_la_LDFLAGS = \\\n    -no-undefined -version-info @DILL_LIBTOOL_VERSION@ @PTHREAD_LIBS@\n\n# Turn the source fortification in glibc off - otherwise it would panic\n# because of the stack pointer black magic in 'go' macro.\nlibdill_la_CFLAGS = \\\n    @PTHREAD_CFLAGS@ \\\n    -fvisibility=hidden\\\n    -DDILL_EXPORTS \\\n    -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0\n\n################################################################################\n#  automated tests                                                             #\n################################################################################\n\ncheck_PROGRAMS = \\\n    tests/example \\\n    tests/go1 \\\n    tests/go2 \\\n    tests/go3 \\\n    tests/go4 \\\n    tests/go5 \\\n    tests/fd \\\n    tests/handle \\\n    tests/chan \\\n    tests/choose \\\n    tests/sleep \\\n    tests/signals \\\n    tests/overload \\\n    tests/rbtree \\\n    tests/bundle\n\nif DILL_THREADS\ncheck_PROGRAMS += \\\n    tests/threads \\\n    tests/threads2\nendif\n\nif DILL_SOCKETS\ncheck_PROGRAMS += \\\n    tests/ipaddr \\\n    tests/iol \\\n    tests/tcp \\\n    tests/ipc \\\n    tests/prefix \\\n    tests/socks5 \\\n    tests/suffix \\\n    tests/udp \\\n    tests/http \\\n    tests/ws \\\n    tests/term \\\n    tests/happyeyeballs\nendif\n\nif DILL_SOCKETS\nif HAVE_TLS\ncheck_PROGRAMS += \\\n    tests/tls\nendif\nendif\n\ncheck_HEADERS = \\\n    tests/assert.h\n\nLDADD = libdill.la\n\nTESTS = $(check_PROGRAMS)\n\n################################################################################\n#  tutorials                                                                   #\n################################################################################\n\nnoinst_PROGRAMS =\n\nif DILL_SOCKETS\nnoinst_PROGRAMS += \\\n    tutorial/basics/step1 \\\n    tutorial/basics/step2 \\\n    tutorial/basics/step3 \\\n    tutorial/basics/step4 \\\n    tutorial/basics/step5 \\\n    tutorial/basics/step6 \\\n    tutorial/protocol/step1 \\\n    tutorial/protocol/step2 \\\n    tutorial/protocol/step3 \\\n    tutorial/protocol/step4 \\\n    tutorial/protocol/step5 \\\n    tutorial/protocol/step6 \\\n    tutorial/protocol/step7 \\\n    tutorial/protocol/step8 \\\n    tutorial/protocol/step9\nif HAVE_TLS\nnoinst_PROGRAMS += \\\n    tutorial/sockets/step1 \\\n    tutorial/sockets/step2 \\\n    tutorial/sockets/step3 \\\n    tutorial/sockets/step4 \\\n    tutorial/sockets/step5\nendif\nendif\n\n################################################################################\n#  examples                                                                    #\n################################################################################\n\nif DILL_SOCKETS\nnoinst_PROGRAMS += \\\n    examples/socks5proxy \\\n    examples/webapp\nendif\n\n################################################################################\n#  performance tests                                                           #\n################################################################################\n\nnoinst_PROGRAMS += \\\n    perf/go \\\n    perf/ctxswitch \\\n    perf/chan \\\n    perf/choose \\\n    perf/done \\\n    perf/whispers \\\n    perf/timer\n\n################################################################################\n#  manpage documentation generation                                            #\n################################################################################\n\nSUBDIRS=man\n\n################################################################################\n#  additional packaging-related stuff                                          #\n################################################################################\n\n#  Generate ChangeLog file from git.\n#  Also, there's no git availabe when building from the source package and\n#  thus no way to obtain package version. Therefore, package version is\n#  saved into a file when building a source package.\ndist-hook:\n\t@if test -d \"$(srcdir)/.git\"; \\\n\tthen \\\n\t\techo Creating ChangeLog; \\\n\t\tcd \"$(top_srcdir)\"; \\\n\t\t(echo '# Generated by Makefile. Do not edit.'; echo; \\\n\t\t  ./missing --run git log --decorate ) > ChangeLog.tmp; \\\n\t\tmv -f ChangeLog.tmp $(top_distdir)/ChangeLog; \\\n\t\trm -f ChangeLog.tmp; \\\n    else \\\n        cp -f ChangeLog $(top_distdir)/ChangeLog || \\\n        echo Failed to generate ChangeLog >&2; \\\n\tfi; \\\n\t$(srcdir)/package_version.sh > $(distdir)/.version\n\nEXTRA_DIST = \\\n    ./abi_version.sh \\\n    ./package_version.sh\n\nCLEANFILES = *.gcno *.gcda dns/*.gcno dns/*.gcda tests/*.gcno tests/*.gcda\n\ndistclean-local:\n\t-rm -f config.h\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.2919921875,
          "content": "# libdill: Structured Concurrency for C\n\n[![Build Status](https://travis-ci.org/sustrik/libdill.svg?branch=master)](https://travis-ci.org/sustrik/libdill)\n\n## Documentation\n\nFor the documentation check the project website:\n\nhttp://libdill.org\n\n## License\n\nLibdill is licensed under MIT/X11 license.\n"
        },
        {
          "name": "abi_version.sh",
          "type": "blob",
          "size": 1.79296875,
          "content": "#!/bin/sh\n\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nif [ ! -f libdill.h ]; then\n    echo \"abi_version.sh: error: libdill.h does not exist\" 1>&2\n    exit 1\nfi\n\nCURRENT=`egrep '^#define +DILL_VERSION_CURRENT +[0-9]+$' libdill.h`\nREVISION=`egrep '^#define +DILL_VERSION_REVISION +[0-9]+$' libdill.h`\nAGE=`egrep '^#define +DILL_VERSION_AGE +[0-9]+$' libdill.h`\n\nif [ -z \"$CURRENT\" -o -z \"$REVISION\" -o -z \"$AGE\" ]; then\n    echo \"abi_version.sh: error: could not extract version from libdill.h\" 1>&2\n    exit 1\nfi\n\nCURRENT=`echo $CURRENT | awk '{ print $3 }'`\nREVISION=`echo $REVISION | awk '{ print $3 }'`\nAGE=`echo $AGE | awk '{ print $3 }'`\n\ncase $1 in\n    -libtool)\n        printf '%s' \"$CURRENT:$REVISION:$AGE\"\n    ;;\n    *)\n        printf '%s' \"$CURRENT.$REVISION.$AGE\"\n    ;;\nesac\n\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0263671875,
          "content": "#!/bin/sh\n\nautoreconf -ifv\n"
        },
        {
          "name": "bsock.c",
          "type": "blob",
          "size": 2.4306640625,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stddef.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_bsock_type);\n\nint dill_bsend(int s, const void *buf, size_t len, int64_t deadline) {\n    struct dill_bsock_vfs *b = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!b)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return b->bsendl(b, &iol, &iol, deadline);\n}\n\nint dill_brecv(int s, void *buf, size_t len, int64_t deadline) {\n    struct dill_bsock_vfs *b = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!b)) return -1;\n    struct dill_iolist iol = {buf, len, NULL, 0};\n    return b->brecvl(b, &iol, &iol, deadline);\n}\n\nint dill_bsendl(int s, struct dill_iolist *first, struct dill_iolist *last,\n      int64_t deadline) {\n    struct dill_bsock_vfs *b = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!b)) return -1;\n    if(dill_slow(!first || !last || last->iol_next)) {\n        errno = EINVAL; return -1;}\n    return b->bsendl(b, first, last, deadline);\n}\n\nint dill_brecvl(int s, struct dill_iolist *first, struct dill_iolist *last,\n      int64_t deadline) {\n    struct dill_bsock_vfs *b = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!b)) return -1;\n    if(dill_slow((first && !last) || (!first && last) || last->iol_next)) {\n        errno = EINVAL; return -1;}\n    return b->brecvl(b, first, last, deadline);\n}\n\n"
        },
        {
          "name": "chan.c",
          "type": "blob",
          "size": 12.498046875,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cr.h\"\n#include \"ctx.h\"\n#include \"list.h\"\n#include \"utils.h\"\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n\nstruct dill_halfchan {\n    /* Table of virtual functions. */\n    struct dill_hvfs vfs;\n    /* List of clauses wanting to receive from the inbound halfchannel. */\n    struct dill_list in;\n    /* List of clauses wanting to send to the inbound halfchannel. */\n    struct dill_list out;\n    /* Whether this is the fist or the second half-channel of the channel. */\n    unsigned int index : 1;\n    /* 1 if chdone() has been called on this channel. 0 otherwise. */\n    unsigned int done : 1;\n    /* 1 if the object was created with chmake_mem(). */\n    unsigned int mem : 1;\n    /* 1 if hclose() was already called for this half-channel. */\n    unsigned int closed : 1;\n};\n\n/* Channel clause. */\nstruct dill_chanclause {\n    struct dill_clause cl;\n    /* An item in either the dill_halfchan::in or dill_halfchan::out list. */\n    struct dill_list item;\n    /* The object being passed via the channel. */\n    void *val;\n    size_t len;\n};\n\nDILL_CT_ASSERT(sizeof(struct dill_chstorage) >=\n    sizeof(struct dill_halfchan) * 2);\n\n/******************************************************************************/\n/*  Handle implementation.                                                    */\n/******************************************************************************/\n\nstatic const int dill_halfchan_type_placeholder = 0;\nconst void *dill_halfchan_type = &dill_halfchan_type_placeholder;\nstatic void *dill_halfchan_query(struct dill_hvfs *vfs, const void *type);\nstatic void dill_halfchan_close(struct dill_hvfs *vfs);\n\n/******************************************************************************/\n/*  Helpers.                                                                  */\n/******************************************************************************/\n\n/* Return the other half-channel within the same channel. */\n#define dill_halfchan_other(self) (self->index ? self - 1  : self + 1)\n\n/******************************************************************************/\n/*  Channel creation and deallocation.                                        */\n/******************************************************************************/\n\nstatic void dill_halfchan_init(struct dill_halfchan *ch, int index) {\n    ch->vfs.query = dill_halfchan_query;\n    ch->vfs.close = dill_halfchan_close;\n    dill_list_init(&ch->in);\n    dill_list_init(&ch->out);\n    ch->index = index;\n    ch->done = 0;\n    ch->mem = 1;\n    ch->closed = 0;\n}\n\nint dill_chmake_mem(struct dill_chstorage *mem, int chv[2]) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    struct dill_halfchan *ch = (struct dill_halfchan*)mem;\n    dill_halfchan_init(&ch[0], 0);\n    dill_halfchan_init(&ch[1], 1);\n    chv[0] = dill_hmake(&ch[0].vfs);\n    if(dill_slow(chv[0] < 0)) {err = errno; goto error1;}\n    chv[1] = dill_hmake(&ch[1].vfs);\n    if(dill_slow(chv[1] < 0)) {err = errno; goto error2;}\n    return 0;\nerror2:\n    /* This closes the handle but leaves everything else alone given\n       that the second handle wasn't event created. */\n    dill_hclose(chv[0]);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_chmake(int chv[2]) {\n    int err;\n    struct dill_chstorage *ch = malloc(sizeof(struct dill_chstorage));\n    if(dill_slow(!ch)) {err = ENOMEM; goto error1;}\n    int h = dill_chmake_mem(ch, chv);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    ((struct dill_halfchan*)ch)[0].mem = 0;\n    ((struct dill_halfchan*)ch)[1].mem = 0;\n    return h;\nerror2:\n    free(ch);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic void *dill_halfchan_query(struct dill_hvfs *vfs, const void *type) {\n    if(dill_fast(type == dill_halfchan_type)) return vfs;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nstatic void dill_halfchan_term(struct dill_halfchan *ch) {\n    /* Resume any remaining senders and receivers on the channel\n       with the EPIPE error. */\n    while(!dill_list_empty(&ch->in)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->in),\n            struct dill_chanclause, item);\n        dill_trigger(&chcl->cl, EPIPE);\n    }\n    while(!dill_list_empty(&ch->out)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->out),\n            struct dill_chanclause, item);\n        dill_trigger(&chcl->cl, EPIPE);\n    }\n}\n\nstatic void dill_halfchan_close(struct dill_hvfs *vfs) {\n    struct dill_halfchan *ch = (struct dill_halfchan*)vfs;\n    dill_assert(ch && !ch->closed);\n    /* If the other half of the channel is still open do nothing. */\n    if(!dill_halfchan_other(ch)->closed) {\n        ch->closed = 1;\n        return;\n    }\n    if(ch->index) ch = dill_halfchan_other(ch);\n    dill_halfchan_term(&ch[0]);\n    dill_halfchan_term(&ch[1]);\n    if(!ch->mem) free(ch);\n}\n\n/******************************************************************************/\n/*  Sending and receiving.                                                    */\n/******************************************************************************/\n\nstatic void dill_chcancel(struct dill_clause *cl) {\n    struct dill_chanclause *chcl = dill_cont(cl, struct dill_chanclause, cl);\n    dill_list_erase(&chcl->item);\n}\n\nint dill_chsend(int h, const void *val, size_t len, int64_t deadline) {\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Get the channel interface. */\n    struct dill_halfchan *ch = dill_hquery(h, dill_halfchan_type);\n    if(dill_slow(!ch)) return -1;\n    /* Sending is always done to the opposite side of the channel. */\n    ch = dill_halfchan_other(ch);   \n    /* Check if the channel is done. */\n    if(dill_slow(ch->done)) {errno = EPIPE; return -1;}\n    /* Copy the message directly to the waiting receiver, if any. */\n    if(!dill_list_empty(&ch->in)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->in),\n            struct dill_chanclause, item);\n        if(dill_slow(len != chcl->len)) {\n            dill_trigger(&chcl->cl, EMSGSIZE);\n            errno = EMSGSIZE;\n            return -1;\n        }\n        memcpy(chcl->val, val, len);\n        dill_trigger(&chcl->cl, 0);\n        return 0;\n    }\n    /* The clause is not available immediately. */\n    if(dill_slow(deadline == 0)) {errno = ETIMEDOUT; return -1;}\n    /* Let's wait. */\n    struct dill_chanclause chcl;\n    dill_list_insert(&chcl.item, &ch->out);\n    chcl.val = (void*)val;\n    chcl.len = len;\n    dill_waitfor(&chcl.cl, 0, dill_chcancel);\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 1, deadline);\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == 1)) {errno = ETIMEDOUT; return -1;}\n    if(dill_slow(errno != 0)) return -1;\n    return 0;\n}\n\nint dill_chrecv(int h, void *val, size_t len, int64_t deadline) {\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Get the channel interface. */\n    struct dill_halfchan *ch = dill_hquery(h, dill_halfchan_type);\n    if(dill_slow(!ch)) return -1;\n    /* Check whether the channel is done. */\n    if(dill_slow(ch->done)) {errno = EPIPE; return -1;}\n    /* If there's a sender waiting, copy the message directly\n       from the sender. */\n    if(!dill_list_empty(&ch->out)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->out),\n            struct dill_chanclause, item);\n        if(dill_slow(len != chcl->len)) {\n            dill_trigger(&chcl->cl, EMSGSIZE);\n            errno = EMSGSIZE;\n            return -1;\n        }\n        memcpy(val, chcl->val, len);\n        dill_trigger(&chcl->cl, 0);\n        return 0;\n    }\n    /* The clause is not immediately available. */\n    if(dill_slow(deadline == 0)) {errno = ETIMEDOUT; return -1;}\n    /* Let's wait. */\n    struct dill_chanclause chcl;\n    dill_list_insert(&chcl.item, &ch->in);\n    chcl.val = val;\n    chcl.len = len;\n    dill_waitfor(&chcl.cl, 0, dill_chcancel);\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 1, deadline);\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == 1)) {errno = ETIMEDOUT; return -1;}\n    if(dill_slow(errno != 0)) return -1;\n    return 0;\n}\n\nint dill_chdone(int h) {\n    struct dill_halfchan *ch = dill_hquery(h, dill_halfchan_type);\n    if(dill_slow(!ch)) return -1;\n    /* Done is always done to the opposite side of the channel. */\n    ch = dill_halfchan_other(ch);\n    if(ch->done) {errno = EPIPE; return -1;}\n    ch->done = 1;\n    /* Resume any remaining senders and receivers on the channel\n       with the EPIPE error. */\n    while(!dill_list_empty(&ch->in)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->in),\n            struct dill_chanclause, item);\n        dill_trigger(&chcl->cl, EPIPE);\n    }\n    while(!dill_list_empty(&ch->out)) {\n        struct dill_chanclause *chcl = dill_cont(dill_list_next(&ch->out),\n            struct dill_chanclause, item);\n        dill_trigger(&chcl->cl, EPIPE);\n    }\n    return 0;\n}\n\nint dill_choose(struct dill_chclause *clauses, int nclauses, int64_t deadline) {\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    if(dill_slow(nclauses < 0 || (nclauses != 0 && !clauses))) {\n        errno = EINVAL; return -1;}\n    int i;\n    for(i = 0; i != nclauses; ++i) {\n        struct dill_chclause *cl = &clauses[i];\n        struct dill_halfchan *ch = dill_hquery(cl->ch, dill_halfchan_type);\n        if(dill_slow(!ch)) return i;\n        if(dill_slow(cl->len > 0 && !cl->val)) {errno = EINVAL; return i;}\n        struct dill_chanclause *chcl;\n        switch(cl->op) {\n        case DILL_CHSEND:\n            ch = dill_halfchan_other(ch);\n            if(dill_slow(ch->done)) {errno = EPIPE; return i;}\n            if(dill_list_empty(&ch->in)) break;\n            chcl = dill_cont(dill_list_next(&ch->in),\n                struct dill_chanclause, item);\n            if(dill_slow(cl->len != chcl->len)) {\n                dill_trigger(&chcl->cl, EMSGSIZE);\n                errno = EMSGSIZE;\n                return i;\n            }\n            memcpy(chcl->val, cl->val, cl->len);\n            dill_trigger(&chcl->cl, 0);\n            errno = 0;\n            return i;\n        case DILL_CHRECV:\n            if(dill_slow(ch->done)) {errno = EPIPE; return i;}\n            if(dill_list_empty(&ch->out)) break;\n            chcl = dill_cont(dill_list_next(&ch->out),\n                struct dill_chanclause, item);\n            if(dill_slow(cl->len != chcl->len)) {\n                dill_trigger(&chcl->cl, EMSGSIZE);\n                errno = EMSGSIZE;\n                return i;\n            }\n            memcpy(cl->val, chcl->val, cl->len);\n            dill_trigger(&chcl->cl, 0);\n            errno = 0;\n            return i;\n        default:\n            errno = EINVAL;\n            return i;\n        } \n    }\n    /* There are no clauses immediately available. */\n    if(dill_slow(deadline == 0)) {errno = ETIMEDOUT; return -1;}\n    /* Let's wait. */\n    struct dill_chanclause chcls[nclauses];\n    for(i = 0; i != nclauses; ++i) {\n        struct dill_halfchan *ch = dill_hquery(clauses[i].ch,\n            dill_halfchan_type);\n        dill_assert(ch);\n        dill_list_insert(&chcls[i].item, clauses[i].op == DILL_CHRECV ?\n            &ch->in : &dill_halfchan_other(ch)->out);\n        chcls[i].val = clauses[i].val;\n        chcls[i].len = clauses[i].len;\n        dill_waitfor(&chcls[i].cl, i, dill_chcancel);\n    }\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, nclauses, deadline);\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == nclauses)) {errno = ETIMEDOUT; return -1;}\n    return id;\n}\n\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 8.2841796875,
          "content": "#\n# Copyright (c) 2013 Luca Barbato\n# Copyright (c) 2015 Martin Sustrik  All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\n################################################################################\n#  Start the configuration phase.                                              #\n################################################################################\n\nAC_PREREQ([2.53])\n\nAC_INIT([libdill], [m4_esyscmd([./package_version.sh])],\n   [sustrik@250bpm.com], [libdill], [http://libdill.org/])\nAC_CONFIG_SRCDIR([libdill.pc.in])\nAM_INIT_AUTOMAKE([1.6 foreign subdir-objects tar-ustar])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nAC_CANONICAL_HOST\n\n################################################################################\n#  Retrieve the versions.                                                      #\n################################################################################\n\nAC_PROG_SED\nAC_PROG_AWK\n\nDILL_ABI_VERSION=m4_esyscmd([./abi_version.sh])\nDILL_PACKAGE_VERSION=m4_esyscmd([./package_version.sh])\nDILL_LIBTOOL_VERSION=m4_esyscmd([./abi_version.sh -libtool])\n\nAC_SUBST(DILL_ABI_VERSION)\nAC_SUBST(DILL_PACKAGE_VERSION)\nAC_SUBST(DILL_LIBTOOL_VERSION)\n\nAC_MSG_NOTICE([libdill package version: $DILL_PACKAGE_VERSION])\nAC_MSG_NOTICE([libdill ABI version: $DILL_ABI_VERSION])\n\n################################################################################\n#  Check the compilers.                                                        #\n################################################################################\n\nAC_PROG_CC_C99\nAM_PROG_CC_C_O\n\n################################################################################\n#  --enable-debug                                                              #\n################################################################################\n\nAC_ARG_ENABLE([debug], [AS_HELP_STRING([--enable-debug],\n    [Enable debugging information [default=no]])])\n\nif test \"x$enable_debug\" = \"xyes\"; then\n    # Override original optimisation level - last option specified wins.\n    CFLAGS=\"$CFLAGS -g -O0\"\nfi\n\n################################################################################\n#  --enable-valgrind                                                           #\n################################################################################\n\nAC_ARG_ENABLE([valgrind], [AS_HELP_STRING([--enable-valgrind],\n    [Provide information about coroutine stacks to valgrind [default=no]])])\n\nif test \"x$enable_valgrind\" = \"xyes\"; then\n    AC_DEFINE(DILL_VALGRIND)\nfi\n\n################################################################################\n#  --enable-gcov                                                               #\n################################################################################\n\nAC_ARG_ENABLE([gcov], [AS_HELP_STRING([--enable-gcov],\n    [Enable gcov [default=no]])])\n\nif test \"x$enable_gcov\" = \"xyes\"; then\n    CFLAGS=\"$CFLAGS --coverage --no-inline -O0\"\nfi\n\n################################################################################\n#  --enable-census                                                             #\n################################################################################\n\nAC_ARG_ENABLE([census], [AS_HELP_STRING([--enable-census],\n    [Print out information about space used on coroutine stacks [default=no]])])\n\nif test \"x$enable_census\" = \"xyes\"; then\n    AC_DEFINE(DILL_CENSUS)\nfi\n\n################################################################################\n#  --disable-threads                                                           #\n################################################################################\n\nAC_ARG_ENABLE([threads], [AS_HELP_STRING([--disable-threads],\n    [Disable threading support [default=no]])])\n\nif test \"x$enable_threads\" = \"xno\"; then\n    AM_CONDITIONAL([DILL_THREADS], false)\nelse\n    PTHREAD_LIBS=error\n    PTHREAD_CFLAGS=\"\"\n    AC_CHECK_LIB([pthread], [pthread_attr_init], PTHREAD_LIBS=\"-lpthread\")\n    if test \"x$PTHREAD_LIBS\" = \"xerror\"; then\n            AC_CHECK_LIB([c_r], [pthread_attr_init], PTHREAD_LIBS=\"-lc_r\")\n    fi\n    if test \"x$PTHREAD_LIBS\" = \"xerror\"; then\n            AC_CHECK_FUNC([pthread_attr_init], PTHREAD_LIBS=\"\")\n    fi\n    if test \"x$PTHREAD_LIBS\" = \"xerror\"; then\n        AC_MSG_ERROR([no thread implementation available])\n    else\n        PTHREAD_CFLAGS=\"-pthread\"\n        AC_DEFINE(DILL_THREADS)\n        AC_DEFINE(DILL_PTHREAD)\n        AM_CONDITIONAL([DILL_THREADS], true)\n    fi\n    AC_SUBST(PTHREAD_LIBS)\n    AC_SUBST(PTHREAD_CFLAGS)\nfi\n\n################################################################################\n#  --disable-sockets                                                           #\n################################################################################\n\nAC_ARG_ENABLE([sockets], [AS_HELP_STRING([--disable-sockets],\n    [Disable socket support [default=no]])])\n\nif test \"x$enable_sockets\" = \"xno\"; then\n    AM_CONDITIONAL([DILL_SOCKETS], false)\nelse\n    AC_DEFINE(DILL_SOCKETS)\n    AM_CONDITIONAL([DILL_SOCKETS], true)\nfi\n\n################################################################################\n#  --enable-tls\n################################################################################\n\nAC_ARG_ENABLE([tls], [AS_HELP_STRING([--enable-tls],\n    [Enable TLS sockets [default=no]])])\n\nAM_CONDITIONAL([HAVE_TLS], [test \"x$enable_tls\" = xyes])\n\nif test \"x$enable_tls\" = \"xyes\"; then\n    AC_DEFINE(HAVE_TLS)\n    PKG_CHECK_MODULES([SSL], [openssl],\n        [CFLAGS=\"$CFLAGS $SSL_CFLAGS\" LIBS=\"$LIBS $SSL_LIBS\"], [\n        AC_CHECK_LIB([ssl], [SSL_ctrl ], [],\n            AC_MSG_ERROR([libssl not found; install OpenSSL]))\n        AC_CHECK_LIB([crypto], [BIO_read], [],\n            AC_MSG_ERROR([libcrypto not found; install OpenSSL]))\n    ])\nfi\n\n################################################################################\n#  Feature checks.                                                             #\n################################################################################\n\nAC_CHECK_FUNC([posix_memalign], [AC_DEFINE([HAVE_POSIX_MEMALIGN])])\nAC_CHECK_FUNC([mprotect], [AC_DEFINE([HAVE_MPROTECT])])\nAC_CHECK_LIB([rt], [clock_gettime])\nAC_CHECK_FUNCS([clock_gettime])\nAC_CHECK_LIB([socket], [socket])\nAC_CHECK_FUNCS([epoll_create], [AC_DEFINE([HAVE_EPOLL])])\nAC_CHECK_FUNCS([kqueue], [AC_DEFINE([HAVE_KQUEUE])])\n\ndnl Check if struct sockaddr contains sa_len member\nAC_CHECK_MEMBERS([struct sockaddr.sa_len], [], [], [\n# include <sys/types.h>\n# include <sys/socket.h>\n])\n\n################################################################################\n#  Libtool                                                                     #\n################################################################################\n\nLT_INIT\n\n################################################################################\n#  --enable-shared                                                             #\n################################################################################\n\nif test \"x$enable_shared\" = \"xyes\"; then\n    AC_DEFINE(DILL_SHARED)\nfi\n\n################################################################################\n#  Finish the configuration phase.                                             #\n################################################################################\n\nAC_CONFIG_MACRO_DIR([m4])\n\nAC_OUTPUT([Makefile man/Makefile libdill.pc])\ncp confdefs.h config.h\n\n"
        },
        {
          "name": "cr.c",
          "type": "blob",
          "size": 19.849609375,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#if defined DILL_VALGRIND\n#include <valgrind/valgrind.h>\n#endif\n\n#include \"cr.h\"\n#include \"pollset.h\"\n#include \"stack.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n#if defined DILL_CENSUS\n\n/* When taking the stack size census, we will keep the maximum stack size\n   in a list indexed by the go() call, i.e., by file name and line number. */\nstruct dill_census_item {\n    struct dill_slist crs;\n    const char *file;\n    int line;\n    size_t max_stack;\n};\n\n#endif\n\n/* Storage for the constant used by the go() macro. */\nvolatile void *dill_unoptimisable = NULL;\n\n/******************************************************************************/\n/*  Handle implementation.                                                    */\n/******************************************************************************/\n\nstatic const int dill_cr_type_placeholder = 0;\nstatic const void *dill_cr_type = &dill_cr_type_placeholder;\nstatic void *dill_cr_query(struct dill_hvfs *vfs, const void *type);\nstatic void dill_cr_close(struct dill_hvfs *vfs);\n\n/******************************************************************************/\n/*  Bundle.                                                                   */\n/******************************************************************************/\n\nstatic const int dill_bundle_type_placeholder = 0;\nconst void *dill_bundle_type = &dill_bundle_type_placeholder;\nstatic void *dill_bundle_query(struct dill_hvfs *vfs, const void *type);\nstatic void dill_bundle_close(struct dill_hvfs *vfs);\n\nstruct dill_bundle {\n    /* Table of virtual functions. */\n    struct dill_hvfs vfs;\n    /* List of coroutines in this bundle. */\n    struct dill_list crs;\n    /* If somebody is doing hdone() on this bundle, here's the clause\n       to trigger when all coroutines are finished. */\n    struct dill_clause *waiter;\n    /* If true, the bundle was created by bundle_mem. */\n    unsigned int mem : 1;\n};\n\nDILL_CT_ASSERT(sizeof(struct dill_bundle_storage) >=\n    sizeof(struct dill_bundle));\n\nint dill_bundle_mem(struct dill_bundle_storage *mem) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; return -1;}\n    struct dill_bundle *b = (struct dill_bundle*)mem;\n    b->vfs.query = dill_bundle_query;\n    b->vfs.close = dill_bundle_close;\n    dill_list_init(&b->crs);\n    b->waiter = NULL;\n    b->mem = 1;\n    return dill_hmake(&b->vfs);\n}\n\nint dill_bundle(void) {\n    int err;\n    struct dill_bundle *b = malloc(sizeof(struct dill_bundle));\n    if(dill_slow(!b)) {err = ENOMEM; goto error1;}\n    int h = dill_bundle_mem((struct dill_bundle_storage*)b);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    b->mem = 0;\n    return h;\nerror2:\n    free(b);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic void *dill_bundle_query(struct dill_hvfs *vfs, const void *type) {\n    if(dill_fast(type == dill_bundle_type)) return vfs;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nstatic void dill_bundle_close(struct dill_hvfs *vfs) {\n    struct dill_bundle *self = (struct dill_bundle*)vfs;\n    struct dill_list *it = &self->crs;\n    for(it = self->crs.next; it != &self->crs; it = dill_list_next(it)) {\n        struct dill_cr *cr = dill_cont(it, struct dill_cr, bundle);\n        dill_cr_close(&cr->vfs);\n    }\n    if(!self->mem) free(self);\n}\n\nint dill_bundle_wait(int h, int64_t deadline) {\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    struct dill_bundle *self = dill_hquery(h, dill_bundle_type);\n    if(dill_slow(!self)) return -1;\n    /* If there are no coroutines in the bundle succeed immediately. */\n    if(dill_list_empty(&self->crs)) return 0;\n    /* Otherwise wait for all coroutines to finish. */\n    struct dill_clause cl;\n    self->waiter = &cl;\n    dill_waitfor(&cl, 0, NULL);\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 1, deadline);\n    int id = dill_wait();\n    self->waiter = NULL;\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == 1)) {errno = ETIMEDOUT; return -1;}\n    dill_assert(id == 0);\n    return 0;\n}\n\n/******************************************************************************/\n/*  Helpers.                                                                  */\n/******************************************************************************/\n\nstatic void dill_resume(struct dill_cr *cr, int id, int err) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    cr->id = id;\n    cr->err = err;\n    dill_qlist_push(&ctx->ready, &cr->ready);\n}\n\nint dill_canblock(void) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    if(dill_slow(ctx->r->no_blocking1 || ctx->r->no_blocking2)) {\n        errno = ECANCELED; return -1;}\n    return 0;\n}\n\nint dill_no_blocking(int val) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    int old = ctx->r->no_blocking2;\n    ctx->r->no_blocking2 = val;\n    return old;\n}\n\n/******************************************************************************/\n/*  Context.                                                                  */\n/******************************************************************************/\n\nint dill_ctx_cr_init(struct dill_ctx_cr *ctx) {\n    /* This function is definitely called from the main coroutine, given that\n       it's called only once and you can't even create a different coroutine\n       without calling it. */\n    ctx->r = &ctx->main;\n    dill_qlist_init(&ctx->ready);\n    dill_rbtree_init(&ctx->timers);\n    /* We can't use now() here as the context is still being intialized. */\n    ctx->last_poll = dill_mnow();\n    /* Initialize the main coroutine. */\n    memset(&ctx->main, 0, sizeof(ctx->main));\n    ctx->main.ready.next = NULL;\n    dill_slist_init(&ctx->main.clauses);\n#if defined DILL_CENSUS\n    dill_slist_init(&ctx->census);\n#endif\n    return 0;\n}\n\nvoid dill_ctx_cr_term(struct dill_ctx_cr *ctx) {\n#if defined DILL_CENSUS\n    struct dill_slist *it;\n    for(it = dill_slist_next(&ctx->census); it != &ctx->census;\n          it = dill_slist_next(it)) {\n        struct dill_census_item *ci =\n            dill_cont(it, struct dill_census_item, crs);\n        fprintf(stderr, \"%s:%d - maximum stack size %zu B\\n\",\n            ci->file, ci->line, ci->max_stack);\n    }\n#endif\n}\n\n/******************************************************************************/\n/*  Timers.                                                                   */\n/******************************************************************************/\n\nstatic void dill_timer_cancel(struct dill_clause *cl) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    struct dill_tmclause *tmcl = dill_cont(cl, struct dill_tmclause, cl);\n    dill_rbtree_erase(&ctx->timers, &tmcl->item);\n    /* This is a safeguard. If an item isn't properly removed from the rb-tree,\n       we can spot the fact by seeing that the cr has been set to NULL. */\n    tmcl->cl.cr = NULL;\n}\n\n/* Adds a timer clause to the list of clauses being waited on. */\nvoid dill_timer(struct dill_tmclause *tmcl, int id, int64_t deadline) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    /* If the deadline is infinite, there's nothing to wait for. */\n    if(deadline < 0) return;\n    dill_rbtree_insert(&ctx->timers, deadline, &tmcl->item);\n    dill_waitfor(&tmcl->cl, id, dill_timer_cancel);\n}\n\n/******************************************************************************/\n/*  Coroutine creation and termination                                        */\n/******************************************************************************/\n\nstatic void dill_cancel(struct dill_cr *cr, int err);\n\n/* The initial part of go(). Allocates a new stack and bundle. */\nint dill_prologue(sigjmp_buf **jb, void **ptr, size_t len, int bndl,\n      const char *file, int line) {\n    int err;\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    /* Return ECANCELED if shutting down. */\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) {err = ECANCELED; goto error1;}\n    /* If bundle is not supplied by the user create one. If user supplied a\n       memory to use put the bundle at the beginning of the block. */\n    int new_bundle = bndl < 0;\n    if(new_bundle) {\n        if(*ptr) {\n            bndl = dill_bundle_mem(*ptr);\n            *ptr = ((uint8_t*)*ptr) + sizeof(struct dill_bundle_storage);\n            len -= sizeof(struct dill_bundle_storage);\n        }\n        else {\n            bndl = dill_bundle();\n        }\n        if(dill_slow(bndl < 0)) {err = errno; goto error1;}\n    }\n    struct dill_bundle *bundle = dill_hquery(bndl, dill_bundle_type);\n    if(dill_slow(!bundle)) {err = errno; goto error2;}\n    /* Allocate a stack. */\n    struct dill_cr *cr;\n    size_t stacksz;\n    if(!*ptr) {\n        cr = (struct dill_cr*)dill_allocstack(&stacksz);\n        if(dill_slow(!cr)) {err = errno; goto error2;}\n    }\n    else {\n        /* The stack is supplied by the user.\n           Align the top of the stack to a 16-byte boundary. */\n        uintptr_t top = (uintptr_t)*ptr;\n        top += len;\n        top &= ~(uintptr_t)15;\n        stacksz = top - (uintptr_t)*ptr;\n        cr = (struct dill_cr*)top;\n        if(dill_slow(stacksz < sizeof(struct dill_cr))) {\n            err = ENOMEM; goto error2;}\n    }\n#if defined DILL_CENSUS\n    /* Mark the bytes in the stack as unused. */\n    uint8_t *bottom = ((char*)cr) - stacksz;\n    int i;\n    for(i = 0; i != stacksz; ++i)\n        bottom[i] = 0xa0 + (i % 13);\n#endif\n    --cr;\n    cr->vfs.query = dill_cr_query;\n    cr->vfs.close = dill_cr_close;\n    dill_list_insert(&cr->bundle, &bundle->crs);\n    cr->ready.next = NULL;\n    dill_slist_init(&cr->clauses);\n    cr->closer = NULL;\n    cr->no_blocking1 = 0;\n    cr->no_blocking2 = 0;\n    cr->done = 0;\n    cr->mem = *ptr ? 1 : 0;\n#if defined DILL_VALGRIND\n    cr->sid = VALGRIND_STACK_REGISTER((char*)(cr + 1) - stacksz, cr);\n#endif\n#if defined DILL_CENSUS\n    /* Find the appropriate census item if it exists. It's O(n) but meh. */\n    cr->census = NULL;\n    struct dill_slist *it;\n    for(it = dill_slist_next(&ctx->census); it != &ctx->census;\n          it = dill_slist_next(it)) {\n        cr->census = dill_cont(it, struct dill_census_item, crs);\n        if(cr->census->line == line && strcmp(cr->census->file, file) == 0)\n            break;\n    }\n    /* Allocate it if it does not exist. */\n    if(it == &ctx->census) {\n        cr->census = malloc(sizeof(struct dill_census_item));\n        dill_assert(cr->census);\n        dill_slist_push(&ctx->census, &cr->census->crs);\n        cr->census->file = file;\n        cr->census->line = line;\n        cr->census->max_stack = 0;\n    }\n    cr->stacksz = stacksz - sizeof(struct dill_cr);\n#endif\n    /* Return the context of the parent coroutine to the caller so that it can\n       store its current state. It can't be done here because we are at the\n       wrong stack frame here. */\n    *jb = &ctx->r->ctx;\n    /* Add parent coroutine to the list of coroutines ready for execution. */\n    dill_resume(ctx->r, 0, 0);\n    /* Mark the new coroutine as running. */\n    *ptr = ctx->r = cr;\n    /* In case of success go() returns the handle, bundle_go() returns 0. */\n    return new_bundle ? bndl : 0;\nerror2:\n    if(new_bundle) {\n        rc = dill_hclose(bndl);\n        dill_assert(rc == 0);\n    }\nerror1:\n    errno = err;\n    return -1;\n}\n\n/* The final part of go(). Gets called when the coroutine is finished. */\nvoid dill_epilogue(void) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    /* Mark the coroutine as finished. */\n    ctx->r->done = 1;\n    /* If there's a coroutine waiting for us to finish, unblock it now. */\n    if(ctx->r->closer)\n        dill_cancel(ctx->r->closer, 0);\n    /* Deallocate the coroutine, unless, of course, it is already\n       in the process of being closed. */\n    if(!ctx->r->no_blocking1) {\n        /* If this is the last coroutine in the bundle and there's someone\n           waiting for hdone() on the bundle unblock them. */\n        if(dill_list_oneitem(&ctx->r->bundle)) {\n            struct dill_bundle *b = dill_cont(ctx->r->bundle.next,\n                struct dill_bundle, crs);\n            if(b->waiter) dill_trigger(b->waiter, 0);\n        }\n        dill_list_erase(&ctx->r->bundle);\n        dill_cr_close(&ctx->r->vfs);\n    }\n    /* With no clauses added, this call will never return. */\n    dill_assert(dill_slist_empty(&ctx->r->clauses));\n    dill_wait();\n}\n\nstatic void *dill_cr_query(struct dill_hvfs *vfs, const void *type) {\n    struct dill_cr *cr = dill_cont(vfs, struct dill_cr, vfs);\n    if(dill_fast(type == dill_cr_type)) return cr;\n    errno = ENOTSUP;\n    return NULL;\n}\n\n/* Gets called when coroutine handle is closed. */\nstatic void dill_cr_close(struct dill_hvfs *vfs) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    struct dill_cr *cr = dill_cont(vfs, struct dill_cr, vfs);\n    /* If the coroutine has already finished, we are done. */\n    if(!cr->done) {\n        /* No blocking calls from this point on. */\n        cr->no_blocking1 = 1;\n        /* Resume the coroutine if it was blocked. */\n        if(!cr->ready.next)\n            dill_cancel(cr, ECANCELED);\n        /* Wait for the coroutine to stop executing. With no clauses added,\n           the only mechanism to resume is through dill_cancel(). This is not\n           really a blocking call, although it looks like one. Given that the\n           coroutine that is being shut down is not permitted to block, we\n           should get control back pretty quickly. */\n        cr->closer = ctx->r;\n        int rc = dill_wait();\n        /* This assertion triggers when coroutine tries to close a bundle that\n           it is part of. There's no sane way to handle that so let's just\n           crash the process. */\n        dill_assert(!(rc == -1 && errno == ECANCELED));\n        dill_assert(rc == -1 && errno == 0);\n    }\n#if defined DILL_CENSUS\n    /* Find the first overwritten byte on the stack.\n       Determine stack usage based on that. */\n    uint8_t *bottom = ((uint8_t*)cr) - cr->stacksz;\n    int i;\n    for(i = 0; i != cr->stacksz; ++i) {\n        if(bottom[i] != 0xa0 + (i % 13)) {\n            /* dill_cr is located on the stack so we have to take that into\n               account. Also, it may be necessary to align the top of the stack\n               to a 16-byte boundary, so add 16 bytes to account for that. */\n            size_t used = cr->stacksz - i - sizeof(struct dill_cr) + 16;\n            if(used > cr->census->max_stack)\n                cr->census->max_stack = used;\n            break;\n        }\n    }\n#endif\n#if defined DILL_VALGRIND\n    VALGRIND_STACK_DEREGISTER(cr->sid);\n#endif\n    /* Now that the coroutine is finished, deallocate it. */\n    if(!cr->mem) dill_freestack(cr + 1);\n}\n\n/******************************************************************************/\n/*  Suspend/resume functionality.                                             */\n/******************************************************************************/\n\nvoid dill_waitfor(struct dill_clause *cl, int id,\n      void (*cancel)(struct dill_clause *cl)) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    /* Add a clause to the coroutine list of active clauses. */\n    cl->cr = ctx->r;\n    dill_slist_push(&ctx->r->clauses, &cl->item);\n    cl->id = id;\n    cl->cancel = cancel;\n}\n\nint dill_wait(void)  {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    /* Store the context of the current coroutine, if any. */\n    if(dill_setjmp(ctx->r->ctx)) {\n        /* We get here once the coroutine is resumed. */\n        dill_slist_init(&ctx->r->clauses);\n        errno = ctx->r->err;\n        return ctx->r->id;\n    }\n    /* For performance reasons, we want to avoid excessive checking of current\n       time, so we cache the value here. It will be recomputed only after\n       a blocking call. */\n    int64_t nw = dill_now();\n    /*  Wait for timeouts and external events. However, if there are ready\n       coroutines there's no need to poll for external events every time.\n       Still, we'll do it at least once a second. The external signal may\n       very well be a deadline or a user-issued command that cancels the CPU\n       intensive operation. */\n    if(dill_qlist_empty(&ctx->ready) || nw > ctx->last_poll + 1000) {\n        int block = dill_qlist_empty(&ctx->ready);\n        while(1) {\n            /* Compute the timeout for the subsequent poll. */\n            int timeout = 0;\n            if(block) {\n                if(dill_rbtree_empty(&ctx->timers))\n                    timeout = -1;\n                else {\n                    int64_t deadline = dill_cont(\n                        dill_rbtree_first(&ctx->timers),\n                        struct dill_tmclause, item)->item.val;\n                    timeout = (int) (nw >= deadline ? 0 : deadline - nw);\n                }\n            }\n            /* Wait for events. */\n            int fired = dill_pollset_poll(timeout);\n            if(timeout != 0) nw = dill_now();\n            if(dill_slow(fired < 0)) continue;\n            /* Fire all expired timers. */\n            if(!dill_rbtree_empty(&ctx->timers)) {\n                while(!dill_rbtree_empty(&ctx->timers)) {\n                    struct dill_tmclause *tmcl = dill_cont(\n                        dill_rbtree_first(&ctx->timers),\n                        struct dill_tmclause, item);\n                    if(tmcl->item.val > nw)\n                        break;\n                    dill_trigger(&tmcl->cl, ETIMEDOUT);\n                    fired = 1;\n                }\n            }\n            /* Never retry the poll when in non-blocking mode. */\n            if(!block || fired)\n                break;\n            /* If the timeout was hit but there were no expired timers,\n               do the poll again. It can happen if the timers were canceled\n               in the meantime. */\n        }\n        ctx->last_poll = nw;\n    }\n    /* There's a coroutine ready to be executed so jump to it. */\n    struct dill_slist *it = dill_qlist_pop(&ctx->ready);\n    it->next = NULL;\n    ctx->r = dill_cont(it, struct dill_cr, ready);\n    /* dill_longjmp has to be at the end of a function body, otherwise stack\n       unwinding information will be trimmed if a crash occurs in this\n       function. */\n    dill_longjmp(ctx->r->ctx);\n    return 0;\n}\n\nstatic void dill_docancel(struct dill_cr *cr, int id, int err) {\n    /* Sanity check: Make sure that the coroutine was really suspended. */\n    dill_assert(!cr->ready.next);\n    /* Remove the clauses from endpoints' lists of waiting coroutines. */\n    struct dill_slist *it;\n    for(it = dill_slist_next(&cr->clauses); it != &cr->clauses;\n          it = dill_slist_next(it)) {\n        struct dill_clause *cl = dill_cont(it, struct dill_clause, item);\n        if(cl->cancel) cl->cancel(cl);\n    }\n    /* Schedule the newly unblocked coroutine for execution. */\n    dill_resume(cr, id, err);\n}\n\nvoid dill_trigger(struct dill_clause *cl, int err) {\n    dill_docancel(cl->cr, cl->id, err);\n}\n\nstatic void dill_cancel(struct dill_cr *cr, int err) {\n    dill_docancel(cr, -1, err);\n}\n\nint dill_yield(void) {\n    struct dill_ctx_cr *ctx = &dill_getctx->cr;\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Put the current coroutine into the ready queue. */\n    dill_resume(ctx->r, 0, 0);\n    /* Suspend. */\n    return dill_wait();\n}\n\n"
        },
        {
          "name": "cr.h",
          "type": "blob",
          "size": 6.3798828125,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_CR_INCLUDED\n#define DILL_CR_INCLUDED\n\n#include <stdint.h>\n\n#include \"list.h\"\n#include \"qlist.h\"\n#include \"rbtree.h\"\n#include \"slist.h\"\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n\n/* The coroutine. The memory layout looks like this:\n   +-------------------------------------------------------------+---------+\n   |                                                      stack  | dill_cr |\n   +-------------------------------------------------------------+---------+\n   - dill_cr contains generic book-keeping info about the coroutine\n   - the stack is a standard C stack; it grows downwards (at the moment, libdill\n     doesn't support microarchitectures where stacks grow upwards)\n*/\nstruct dill_cr {\n    /* When the coroutine is ready for execution but not running yet,\n       it lives on this list (ctx->ready). 'id' is the result value to return\n       from dill_wait() when the coroutine is resumed. Additionally, errno\n       will be set to 'err'. */\n    struct dill_slist ready;\n    /* Virtual function table. */\n    struct dill_hvfs vfs;\n    int id;\n    int err;\n    /* When the coroutine is suspended 'ctx' holds the context\n       (registers and such).*/\n    sigjmp_buf ctx;\n    /* If the coroutine is blocked, here's the list of the clauses it's\n       waiting for. */\n    struct dill_slist clauses;\n    /* A list of coroutines belonging to a particular bundle. */\n    struct dill_list bundle;\n    /* There are two possible reasons to disable blocking calls.\n       1. The coroutine is being closed by its owner.\n       2. The execution is happening within the context of an hclose() call. */\n    unsigned int no_blocking1 : 1;\n    unsigned int no_blocking2 : 1;\n    /* Set when the coroutine has finished its execution. */\n    unsigned int done : 1;\n    /* If true, the coroutine was launched with go_mem. */\n    unsigned int mem : 1;\n    /* When the coroutine handle is being closed, this points to the\n       coroutine that is doing the hclose() call. */\n    struct dill_cr *closer;\n#if defined DILL_VALGRIND\n    /* Valgrind stack identifier. This way, valgrind knows which areas of\n       memory are used as stacks, and so it doesn't produce spurious warnings.\n       Well, sort of. The mechanism is not perfect, but it's still better\n       than nothing. */\n    int sid;\n#endif\n#if defined DILL_CENSUS\n    /* Census record corresponding to this coroutine. */\n    struct dill_census_item *census;\n    size_t stacksz;\n#endif\n/* Clang assumes that the client stack is aligned to 16-bytes on x86-64\n   architectures. To achieve this, we align this structure (with the added\n   benefit of a minor optimization). */\n} __attribute__((aligned(16)));\n\nstruct dill_ctx_cr {\n    /* Currently running coroutine. */\n    struct dill_cr *r;\n    /* List of coroutines ready for execution. */\n    struct dill_qlist ready;\n    /* All active timers. */\n    struct dill_rbtree timers;\n    /* Last time poll was performed. */\n    int64_t last_poll;\n    /* The main coroutine. We don't control the creation of the main coroutine's\n       stack, so we have to store this info here instead of the top of\n       the stack. */\n    struct dill_cr main;\n#if defined DILL_CENSUS\n    struct dill_slist census;\n#endif\n};\n\nstruct dill_clause {\n    /* The coroutine that owns this clause. */\n    struct dill_cr *cr;\n    /* List of the clauses the coroutine is waiting on. See dill_cr::clauses. */\n    struct dill_slist item;\n    /* Number to return from dill_wait() if this clause triggers. */\n    int id;\n    /* Function to call when this clause is canceled. */\n    void (*cancel)(struct dill_clause *cl);\n};\n\n/* Timer clause. */\nstruct dill_tmclause {\n    struct dill_clause cl;\n    /* An item in dill_ctx_cr::timers. */\n    struct dill_rbtree_item item;\n};\n\n/* File descriptor clause. */\nstruct dill_fdclause;\n\nint dill_ctx_cr_init(struct dill_ctx_cr *ctx);\nvoid dill_ctx_cr_term(struct dill_ctx_cr *ctx);\n\n/* When dill_wait() is called next time, the coroutine will wait\n   (among other clauses) on this clause. 'id' must not be negative.\n   'cancel' is a function to be called when the clause is canceled\n   without being triggered. */\nvoid dill_waitfor(struct dill_clause *cl, int id,\n    void (*cancel)(struct dill_clause *cl));\n\n/* Suspend running coroutine. Move to executing different coroutines.\n   The coroutine will be resumed once one of the clauses previously added by\n   dill_waitfor() is triggered. When that happens, all the clauses, whether\n   triggered or not, will be canceled. The function returns the ID of the\n   triggered clause or -1 on error. In either case, it sets errno to 0 indicate\n   success or non-zero value to indicate error. */\nint dill_wait(void);\n\n/* Schedule a previously suspended coroutine for execution. Keep in mind that\n   this doesn't immediately run it, it just puts it into the coroutine ready\n   queue. It will cause dill_wait() to return the id supplied in\n   dill_waitfor(). */\nvoid dill_trigger(struct dill_clause *cl, int err);\n\n/* Add a timer to the list of active clauses. */\nvoid dill_timer(struct dill_tmclause *tmcl, int id, int64_t deadline);\n\n/* Returns 0 if blocking functions are allowed.\n   Returns -1 and sets errno to ECANCELED otherwise. */\nint dill_canblock(void);\n\n/* When set to 1, blocking calls return ECANCELED.\n   Returns the old value of the flag */\nint dill_no_blocking(int val);\n\n/* Cleans cached info about the fd. */\nint dill_clean(int fd);\n\n#endif\n\n\n"
        },
        {
          "name": "ctx.c",
          "type": "blob",
          "size": 6.005859375,
          "content": "/*\n\n  Copyright (c) 2016 Tai Chi Minh Ralph Eastwood\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include \"ctx.h\"\n\nstatic void dill_ctx_init_(struct dill_ctx *ctx) {\n    dill_assert(ctx->initialized == 0);\n    ctx->initialized = 1;\n    int rc = dill_ctx_now_init(&ctx->now);\n    dill_assert(rc == 0);\n    rc = dill_ctx_cr_init(&ctx->cr);\n    dill_assert(rc == 0);\n    rc = dill_ctx_handle_init(&ctx->handle);\n    dill_assert(rc == 0);\n    rc = dill_ctx_stack_init(&ctx->stack);\n    dill_assert(rc == 0);\n    rc = dill_ctx_pollset_init(&ctx->pollset);\n    dill_assert(rc == 0);\n#if defined DILL_SOCKETS\n    rc = dill_ctx_fd_init(&ctx->fd);\n    dill_assert(rc == 0);\n#endif\n}\n\nstatic void dill_ctx_term_(struct dill_ctx *ctx) {\n    dill_assert(ctx->initialized == 1);\n#if defined DILL_SOCKETS\n    dill_ctx_fd_term(&ctx->fd);\n#endif\n    dill_ctx_pollset_term(&ctx->pollset);\n    dill_ctx_stack_term(&ctx->stack);\n    dill_ctx_handle_term(&ctx->handle);\n    dill_ctx_cr_term(&ctx->cr);\n    dill_ctx_now_term(&ctx->now);\n    ctx->initialized = 0;\n}\n\n#if !defined DILL_THREADS\n\n/* This implementation of context is used when threading is disabled, i.e.\n   when user wishes to have a single-threaded application. Context is stored\n   in a global variable which is deallocated using an atexit() function. */\n\nstruct dill_ctx dill_ctx_ = {0};\n\nstatic void dill_ctx_atexit(void) {\n    dill_ctx_term_(&dill_ctx_);\n}\n\nstruct dill_ctx *dill_ctx_init(void) {\n    dill_ctx_init_(&dill_ctx_);\n    int rc = atexit(dill_ctx_atexit);\n    dill_assert(rc == 0);\n    return &dill_ctx_;\n}\n\n#else\n\n#include <pthread.h>\n\n/* Determine whether current thread is the main thread. */\n#if defined __linux__\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <sys/syscall.h>\nstatic int dill_ismain() {\n    return syscall(SYS_gettid) == getpid();\n}\n#elif defined __OpenBSD__ || defined __FreeBSD__ || \\\n    defined __APPLE__ || defined __DragonFly__\n#if defined __FreeBSD__ || defined __OpenBSD__\n#include <pthread_np.h>\n#endif\nstatic int dill_ismain() {\n    return pthread_main_np();\n}\n#elif defined __NetBSD__\n#include <sys/lwp.h>\nstatic int dill_ismain() {\n    return _lwp_self() == 1;\n}\n#elif defined __sun\nstatic int dill_ismain() {\n    return pthread_self() == 1;\n}\n#else\n#error \"Cannot determine which thread is the main thread.\"\n#endif\n\n#if defined __GNUC__ && !defined __APPLE__ && !defined DILL_THREAD_FALLBACK\n\n/* This implementation is used if the compiler supports thread-local variables.\n   The context is stored in a thread-local variable. It uses pthread_key_create\n   to register a destructor function which cleans the context up after thread\n   exits. However, at least on Linux, the destructor is not called for the\n   main thread. Therefore, atexit() function is registered to clean the\n   main thread's context. */\n\n__thread struct dill_ctx dill_ctx_ = {0};\n\nstatic pthread_key_t dill_key;\nstatic pthread_once_t dill_keyonce = PTHREAD_ONCE_INIT;\nstatic void *dill_main = NULL;\n\nstatic void dill_ctx_term(void *ptr) {\n    struct dill_ctx *ctx = ptr;\n    dill_ctx_term_(ctx);\n    if(dill_ismain()) dill_main = NULL;\n}\n\nstatic void dill_ctx_atexit(void) {\n    if(dill_main) dill_ctx_term(dill_main);\n}\n\nstatic void dill_makekey(void) {\n    int rc = pthread_key_create(&dill_key, dill_ctx_term);\n    dill_assert(!rc);\n}\n\nstruct dill_ctx *dill_ctx_init(void) {\n    dill_ctx_init_(&dill_ctx_);\n    int rc = pthread_once(&dill_keyonce, dill_makekey);\n    dill_assert(rc == 0);\n    if(dill_ismain()) {\n        dill_main = &dill_ctx_;\n        rc = atexit(dill_ctx_atexit);\n        dill_assert(rc == 0);\n    }\n    rc = pthread_setspecific(dill_key, &dill_ctx_);\n    dill_assert(rc == 0);\n    return &dill_ctx_;\n}\n\n#else\n\n/* This is an implementation that doesn't need compiler support for thread-local\n   variables. It creates thread-specific data usin POSIX functions.\n   It uses pthread_key_create to register a destructor function which cleans\n   the context up after thread exits. However, at least on Linux, the destructor\n   is not called for the main thread. Therefore, atexit() function is registered\n   to clean the main thread's context. */\n\nstatic pthread_key_t dill_key;\nstatic pthread_once_t dill_keyonce = PTHREAD_ONCE_INIT;\nstatic void *dill_main = NULL;\n\nstatic void dill_ctx_term(void *ptr) {\n    struct dill_ctx *ctx = ptr;\n    dill_ctx_term_(ctx);\n    free(ctx);\n    if(dill_ismain()) dill_main = NULL;\n}\n\nstatic void dill_ctx_atexit(void) {\n    if(dill_main) dill_ctx_term(dill_main);\n}\n\nstatic void dill_makekey(void) {\n    int rc = pthread_key_create(&dill_key, dill_ctx_term);\n    dill_assert(!rc);\n}\n\nstruct dill_ctx *dill_getctx_(void) {\n    int rc = pthread_once(&dill_keyonce, dill_makekey);\n    dill_assert(rc == 0);\n    struct dill_ctx *ctx = pthread_getspecific(dill_key);\n    if(dill_fast(ctx)) return ctx;\n    ctx = calloc(1, sizeof(struct dill_ctx));\n    dill_assert(ctx);\n    dill_ctx_init_(ctx);\n    if(dill_ismain()) {\n        dill_main = ctx;\n        rc = atexit(dill_ctx_atexit);\n        dill_assert(rc == 0);\n    }\n    rc = pthread_setspecific(dill_key, ctx);\n    dill_assert(rc == 0);\n    return ctx;\n}\n\n#endif\n\n#endif\n\n"
        },
        {
          "name": "ctx.h",
          "type": "blob",
          "size": 1.994140625,
          "content": "/*\n\n  Copyright (c) 2016 Tai Chi Minh Ralph Eastwood\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_CTX_INCLUDED\n#define DILL_CTX_INCLUDED\n\n#include \"cr.h\"\n#include \"fd.h\"\n#include \"handle.h\"\n#include \"now.h\"\n#include \"pollset.h\"\n#include \"stack.h\"\n\nstruct dill_ctx {\n    int initialized;\n    struct dill_ctx_now now;\n    struct dill_ctx_cr cr;\n    struct dill_ctx_handle handle;\n    struct dill_ctx_stack stack;\n    struct dill_ctx_pollset pollset;\n#if defined DILL_SOCKETS\n    struct dill_ctx_fd fd;\n#endif\n};\n\nstruct dill_ctx *dill_ctx_init(void);\n\n#if !defined DILL_THREADS\n\nextern struct dill_ctx dill_ctx_;\n#define dill_getctx \\\n    (dill_fast(dill_ctx_.initialized) ? &dill_ctx_ : dill_ctx_init())\n\n#elif defined __GNUC__ && !defined __APPLE__ && !defined DILL_THREAD_FALLBACK\n\nextern __thread struct dill_ctx dill_ctx_;\n#define dill_getctx \\\n    (dill_fast(dill_ctx_.initialized) ? &dill_ctx_ : dill_ctx_init())\n\n#else\n\nstruct dill_ctx *dill_getctx_(void);\n#define dill_getctx (dill_getctx_())\n\n#endif\n\n#endif\n\n"
        },
        {
          "name": "dns",
          "type": "tree",
          "content": null
        },
        {
          "name": "epoll.c.inc",
          "type": "blob",
          "size": 8.9970703125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n#include \"pollset.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n#define DILL_ENDLIST 0xffffffff\n\n#define DILL_EPOLLSETSIZE 128\n\n/* One of these is associated with each file descriptor. */\nstruct dill_fdinfo {\n    /* A coroutines waiting to read from the fd or NULL. */\n    struct dill_fdclause *in;\n    /* A coroutines waiting to write to the fd or NULL. */\n    struct dill_fdclause *out;\n    /* Cached current state of epollset. */\n    uint32_t currevs;\n    /* 1-based index, 0 stands for \"not part of the list\", DILL_ENDLIST\n       stands for \"no more elements in the list. */\n    uint32_t next;\n    /* 1 if the file descriptor is cached. 0 otherwise. */\n    unsigned int cached : 1;\n};\n\nint dill_ctx_pollset_init(struct dill_ctx_pollset *ctx) {\n    int err;\n    /* Allocate one info per fd. */\n    ctx->nfdinfos = dill_maxfds();\n    ctx->fdinfos = calloc(ctx->nfdinfos, sizeof(struct dill_fdinfo));\n    if(dill_slow(!ctx->fdinfos)) {err = ENOMEM; goto error1;}\n    /* Changelist is empty. */\n    ctx->changelist = DILL_ENDLIST;\n    /* Create the kernel-side pollset. */\n    ctx->efd = epoll_create(1);\n    if(dill_slow(ctx->efd < 0)) {err = errno; goto error2;}\n    return 0;\nerror2:\n    free(ctx->fdinfos);\n    ctx->fdinfos = NULL;\nerror1:\n    errno = err;\n    return -1;\n}\n\nvoid dill_ctx_pollset_term(struct dill_ctx_pollset *ctx) {\n    int rc = close(ctx->efd);\n    dill_assert(rc == 0);\n    free(ctx->fdinfos);\n}\n\nstatic void dill_fdcancelin(struct dill_clause *cl) {\n    struct dill_fdinfo *fdinfo =\n        dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdinfo->in = NULL;\n    if(!fdinfo->next) {\n        struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n        fdinfo->next = ctx->changelist;\n        ctx->changelist = fdinfo - ctx->fdinfos + 1;\n    }\n}\n\nstatic void dill_fdcancelout(struct dill_clause *cl) {\n    struct dill_fdinfo *fdinfo =\n        dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdinfo->out = NULL;\n    if(!fdinfo->next) {\n        struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n        fdinfo->next = ctx->changelist;\n        ctx->changelist = fdinfo - ctx->fdinfos + 1;\n    }\n}\n\nint dill_pollset_in(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    /* If not yet cached, check whether the fd exists and if it does,\n       add it to the pollset. */\n    if(dill_slow(!fdi->cached)) {\n        struct epoll_event ev;\n#ifdef DILL_VALGRIND\n        memset(&ev.data, 0, sizeof(ev.data)); //Keep Valgrind happy\n#endif\n        ev.data.fd = fd;\n        ev.events = EPOLLIN;\n        int rc = epoll_ctl(ctx->efd, EPOLL_CTL_ADD, fd, &ev);\n        if(dill_slow(rc < 0)) {\n            if(errno == ELOOP || errno == EPERM) {errno = ENOTSUP; return -1;}\n            return -1;\n        }\n        fdi->in = NULL;\n        fdi->out = NULL;\n        fdi->currevs = EPOLLIN;\n        fdi->next = 0;\n        fdi->cached = 1;\n    }\n    if(dill_slow(fdi->in)) {errno = EBUSY; return -1;}\n    /* If the fd is not yet in the pollset, add it there. */\n    else if(!fdi->next) {\n        fdi->next = ctx->changelist;\n        ctx->changelist = fd + 1;\n    }\n    fdcl->fdinfo = fdi;\n    fdi->in = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelin);\n    return 0;\n}\n\nint dill_pollset_out(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    /* If not yet cached, check whether the fd exists and if it does,\n       add it to pollset. */\n    if(dill_slow(!fdi->cached)) {\n        struct epoll_event ev;\n#ifdef DILL_VALGRIND\n        memset(&ev.data, 0, sizeof(ev.data)); //Keep Valgrind happy\n#endif\n        ev.data.fd = fd;\n        ev.events = EPOLLOUT;\n        int rc = epoll_ctl(ctx->efd, EPOLL_CTL_ADD, fd, &ev);\n        if(dill_slow(rc < 0)) {\n            if(errno == ELOOP || errno == EPERM) {errno = ENOTSUP; return -1;}\n            return -1;\n        }\n        fdi->in = NULL;\n        fdi->out = NULL;\n        fdi->currevs = EPOLLOUT;\n        fdi->next = 0;\n        fdi->cached = 1;\n    }\n    if(dill_slow(fdi->out)) {errno = EBUSY; return -1;}\n    /* If the fd is not yet in the pollset, add it there. */\n    else if(!fdi->next) {\n        fdi->next = ctx->changelist;\n        ctx->changelist = fd + 1;\n    }\n    fdcl->fdinfo = fdi;\n    fdi->out = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelout);\n    return 0;\n}\n\nint dill_pollset_clean(int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    if(!fdi->cached) return 0;\n    /* We cannot clean an fd that someone is waiting for. */\n    if(dill_slow(fdi->in || fdi->out)) {errno = EBUSY; return -1;}\n    /* Remove the file descriptor from the pollset if it is still there. */\n    if(fdi->currevs) {\n        struct epoll_event ev;\n#ifdef DILL_VALGRIND\n        memset(&ev.data, 0, sizeof(ev.data)); //Keep Valgrind happy\n#endif\n        ev.data.fd = fd;\n        ev.events = 0;\n        int rc = epoll_ctl(ctx->efd, EPOLL_CTL_DEL, fd, &ev);\n        dill_assert(rc == 0 || errno == ENOENT);\n        fdi->currevs = 0;\n    }\n    /* If needed, remove the fd from the changelist. */\n    if(fdi->next) {\n        uint32_t *pidx = &ctx->changelist;\n        while(1) {\n            dill_assert(*pidx != 0 && *pidx != DILL_ENDLIST);\n            if(*pidx - 1 == fd) break;\n            pidx = &ctx->fdinfos[*pidx - 1].next;\n        }\n        *pidx = fdi->next;\n        fdi->next = 0;\n    }\n    /* Mark the fd as not used. */\n    fdi->cached = 0;\n    return 0;\n}\n\nint dill_pollset_poll(int timeout) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    /* Apply any changes to the pollset.\n       TODO: Use epoll_ctl_batch once available. */\n    while(ctx->changelist != DILL_ENDLIST) {\n        int fd = ctx->changelist - 1;\n        struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n        struct epoll_event ev;\n        ev.data.u64 = 0; //Keep Valgrind happy\n        ev.data.fd = fd;\n        ev.events = 0;\n        if(fdi->in)\n            ev.events |= EPOLLIN;\n        if(fdi->out)\n            ev.events |= EPOLLOUT;\n        if(fdi->currevs != ev.events) {\n            int op;\n            if(!ev.events)\n                 op = EPOLL_CTL_DEL;\n            else if(!fdi->currevs)\n                 op = EPOLL_CTL_ADD;\n            else\n                 op = EPOLL_CTL_MOD;\n            fdi->currevs = ev.events;\n            int rc = epoll_ctl(ctx->efd, op, fd, &ev);\n            dill_assert(rc == 0);\n        }\n        ctx->changelist = fdi->next;\n        fdi->next = 0;\n    }\n    /* Wait for events. */\n    struct epoll_event evs[DILL_EPOLLSETSIZE];\n    int numevs = epoll_wait(ctx->efd, evs, DILL_EPOLLSETSIZE, timeout);\n    if(numevs < 0 && errno == EINTR) return -1;\n    dill_assert(numevs >= 0);\n    /* Fire file descriptor events. */\n    int i;\n    for(i = 0; i != numevs; ++i) {\n        int fd = evs[i].data.fd;\n        struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n        /* Resume blocked coroutines. */\n        if(fdi->in && (evs[i].events & (EPOLLIN | EPOLLERR | EPOLLHUP))) {\n            dill_trigger(&fdi->in->cl, 0);\n            /* Remove the fd from the pollset if needed. */\n            if(!fdi->in && !fdi->next) {\n                fdi->next = ctx->changelist;\n                ctx->changelist = fd + 1;\n            }\n        }\n        if(fdi->out && (evs[i].events & (EPOLLOUT | EPOLLERR | EPOLLHUP))) {\n            dill_trigger(&fdi->out->cl, 0);\n            /* Remove the fd from the pollset if needed. */\n            if(!fdi->out && !fdi->next) {\n                fdi->next = ctx->changelist;\n                ctx->changelist = fd + 1;\n            }\n        }\n    }\n    /* Return 0 on timeout or 1 if at least one coroutine was resumed. */\n    return numevs > 0 ? 1 : 0;\n}\n"
        },
        {
          "name": "epoll.h.inc",
          "type": "blob",
          "size": 1.4111328125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_EPOLL_INCLUDED\n#define DILL_EPOLL_INCLUDED\n\n#include <stdint.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n\nstruct dill_fdinfo;\n\nstruct dill_fdclause {\n   struct dill_clause cl;\n   struct dill_fdinfo *fdinfo;\n\n};\n\nstruct dill_ctx_pollset {\n    int efd;\n    struct dill_fdinfo *fdinfos;\n    size_t nfdinfos;\n    uint32_t changelist;\n};\n\n#endif\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fd.c",
          "type": "blob",
          "size": 14.41796875,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"ctx.h\"\n#include \"fd.h\"\n#include \"iol.h\"\n#include \"utils.h\"\n\n#define DILL_FD_CACHESIZE 32\n#define DILL_FD_BUFSIZE 1984\n\n#if defined MSG_NOSIGNAL\n#define FD_NOSIGNAL MSG_NOSIGNAL\n#else\n#define FD_NOSIGNAL 0\n#endif\n\nint dill_ctx_fd_init(struct dill_ctx_fd *ctx) {\n    ctx->count = 0;\n    dill_slist_init(&ctx->cache);\n    return 0;\n}\n\nvoid dill_ctx_fd_term(struct dill_ctx_fd *ctx) {\n    while(1) {\n        struct dill_slist *it = dill_slist_pop(&ctx->cache);\n        if(it == &ctx->cache) break;\n        free(it);\n    }\n}\n\nstatic uint8_t *dill_fd_allocbuf(void) {\n    struct dill_ctx_fd *ctx = &dill_getctx->fd;\n    struct dill_slist *it = dill_slist_pop(&ctx->cache);\n    if(dill_fast(it != &ctx->cache)) {\n        ctx->count--;\n        return (uint8_t*)it;\n    }\n    uint8_t *p = malloc(DILL_FD_BUFSIZE);\n    if(dill_slow(!p)) {errno = ENOMEM; return NULL;}\n    return p;\n}\n\nstatic void dill_fd_freebuf(uint8_t *buf) {\n    struct dill_ctx_fd *ctx = &dill_getctx->fd;\n    if(ctx->count >= DILL_FD_CACHESIZE) {\n        free(buf);\n        return;\n    }\n    dill_slist_push(&ctx->cache, (struct dill_slist*)buf);\n    ctx->count++;\n}\n\nvoid dill_fd_initrxbuf(struct dill_fd_rxbuf *rxbuf) {\n    dill_assert(rxbuf);\n    rxbuf->len = 0;\n    rxbuf->pos = 0;\n    rxbuf->buf = NULL;\n}\n\nvoid dill_fd_termrxbuf(struct dill_fd_rxbuf *rxbuf) {\n    if(rxbuf->buf) dill_fd_freebuf(rxbuf->buf);\n}\n\nint dill_fd_unblock(int s) {\n    /* Switch to non-blocking mode. */\n    int opt = fcntl(s, F_GETFL, 0);\n    if (opt == -1)\n        opt = 0;\n    int rc = fcntl(s, F_SETFL, opt | O_NONBLOCK);\n    dill_assert(rc == 0);\n    /*  Allow re-using the same local address rapidly. */\n    opt = 1;\n    rc = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt));\n    dill_assert(rc == 0);\n    /* If possible, prevent SIGPIPE signal when writing to the connection\n        already closed by the peer. */\n#ifdef SO_NOSIGPIPE\n    opt = 1;\n    rc = setsockopt (s, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof (opt));\n    dill_assert (rc == 0 || errno == EINVAL);\n#endif\n    return 0;\n}\n\nint dill_fd_connect(int s, const struct sockaddr *addr, socklen_t addrlen,\n      int64_t deadline) {\n    /* Initiate connect. */\n    int rc = connect(s, addr, addrlen);\n    if(rc == 0) return 0;\n    if(dill_slow(errno != EINPROGRESS)) return -1;\n    /* Connect is in progress. Let's wait till it's done. */\n    rc = dill_fdout(s, deadline);\n    if(dill_slow(rc == -1)) return -1;\n    /* Retrieve the error from the socket, if any. */\n    int err = 0;\n    socklen_t errsz = sizeof(err);\n    rc = getsockopt(s, SOL_SOCKET, SO_ERROR, (void*)&err, &errsz);\n    if(dill_slow(rc != 0)) return -1;\n    if(dill_slow(err != 0)) {errno = err; return -1;}\n    return 0;\n}\n\nint dill_fd_accept(int s, struct sockaddr *addr, socklen_t *addrlen,\n      int64_t deadline) {\n    int as;\n    while(1) {\n        /* Try to accept new connection synchronously. */\n        as = accept(s, addr, addrlen);\n        if(dill_fast(as >= 0))\n            break;\n        /* If connection was aborted by the peer grab the next one. */\n        if(dill_slow(errno == ECONNABORTED)) continue;\n        /* Propagate other errors to the caller. */\n        if(dill_slow(errno != EAGAIN && errno != EWOULDBLOCK)) return -1;\n        /* Operation is in progress. Wait till new connection is available. */\n        int rc = dill_fdin(s, deadline);\n        if(dill_slow(rc < 0)) return -1;\n    }\n    int rc = dill_fd_unblock(as);\n    dill_assert(rc == 0);\n    return as;\n}\n\nint dill_fd_send(int s, struct dill_iolist *first, struct dill_iolist *last,\n      int64_t deadline) {\n    /* Make a local iovec array. */\n    /* TODO: This is dangerous, it may cause stack overflow.\n       There should probably be a on-heap per-socket buffer for that. */\n    size_t niov;\n    int rc = dill_iolcheck(first, last, &niov, NULL);\n    if(dill_slow(rc < 0)) return -1;\n    struct iovec iov[niov];\n    dill_ioltoiov(first, iov);\n    /* Message header will act as an iterator in the following loop. */\n    struct msghdr hdr;\n    memset(&hdr, 0, sizeof(hdr));\n    hdr.msg_iov = iov;\n    hdr.msg_iovlen = niov;\n    /* It is very likely that at least one byte can be sent. Therefore,\n       to improve efficiency, try to send and resort to fdout() only after\n       send failed. */\n    while(1) {\n        while(hdr.msg_iovlen && !hdr.msg_iov[0].iov_len) {\n            hdr.msg_iov++;\n            hdr.msg_iovlen--;\n        }\n        if(!hdr.msg_iovlen) return 0;\n        ssize_t sz = sendmsg(s, &hdr, FD_NOSIGNAL);\n        dill_assert(sz != 0);\n        if(sz < 0) {\n            if(dill_slow(errno != EWOULDBLOCK && errno != EAGAIN)) {\n                if(errno == EPIPE) errno = ECONNRESET;\n                return -1;\n            }\n            sz = 0;\n        }\n        /* Adjust the iovec array so that it doesn't contain data\n           that was already sent. */\n        while(sz) {\n            struct iovec *head = &hdr.msg_iov[0];\n            if(head->iov_len > sz) {\n                head->iov_base += sz;\n                head->iov_len -= sz;\n                break;\n            }\n            sz -= head->iov_len;\n            hdr.msg_iov++;\n            hdr.msg_iovlen--;\n            if(!hdr.msg_iovlen) return 0;\n        }\n        /* Wait till more data can be sent. */\n        int rc = dill_fdout(s, deadline);\n        if(dill_slow(rc < 0)) return -1;\n    }\n}\n\n/* Same as dill_fd_recv() but with no rx buffering. */\nstatic int dill_fd_recv_(int s, struct dill_iolist *first,\n      struct dill_iolist *last, int64_t deadline) {\n    /* Make a local iovec array. */\n    /* TODO: This is dangerous, it may cause stack overflow.\n       There should probably be a on-heap per-socket buffer for that. */\n    size_t niov;\n    int rc = dill_iolcheck(first, last, &niov, NULL);\n    if(dill_slow(rc < 0)) return -1;\n    struct iovec iov[niov];\n    dill_ioltoiov(first, iov);\n    /* Message header will act as an iterator in the following loop. */\n    struct msghdr hdr;\n    memset(&hdr, 0, sizeof(hdr));\n    hdr.msg_iov = iov;\n    hdr.msg_iovlen = niov;\n    while(1) {\n        ssize_t sz = recvmsg(s, &hdr, 0);\n        if(dill_slow(sz == 0)) {errno = EPIPE; return -1;}\n        if(sz < 0) {\n            if(dill_slow(errno != EWOULDBLOCK && errno != EAGAIN)) {\n                if(errno == EPIPE) errno = ECONNRESET;\n                return -1;\n            }\n            sz = 0;\n        }\n        /* Adjust the iovec array so that it doesn't contain buffers\n           that ware already filled in. */\n        while(sz) {\n            struct iovec *head = &hdr.msg_iov[0];\n            if(head->iov_len > sz) {\n                head->iov_base += sz;\n                head->iov_len -= sz;\n                break;\n            }\n            sz -= head->iov_len;\n            hdr.msg_iov++;\n            hdr.msg_iovlen--;\n            if(!hdr.msg_iovlen) return 0;\n        }\n        /* Wait for more data. */\n        int rc = dill_fdin(s, deadline);\n        if(dill_slow(rc < 0)) return -1;\n    }\n}\n\n/* Skip len bytes. If len is negative skip until error occurs. */\nstatic int dill_fd_skip(int s, ssize_t len, int64_t deadline) {\n    uint8_t buf[512];\n    while(len) {\n        size_t to_recv = len < 0 || len > sizeof(buf) ? sizeof(buf) : len;\n        struct dill_iolist iol = {buf, to_recv, NULL, 0};\n        int rc = dill_fd_recv_(s, &iol, &iol, deadline);\n        if(dill_slow(rc < 0)) return -1;\n        if(len >= 0) len -= to_recv;\n    }\n    return 0;\n}\n\n/* Copy data from rxbuf to one dill_iolist structure.\n   Returns number of bytes copied. */\nstatic size_t dill_fd_copy(struct dill_fd_rxbuf *rxbuf,\n      struct dill_iolist *iol) {\n    size_t rmn = rxbuf->len  - rxbuf->pos;\n    if(!rmn) return 0;\n    if(rmn < iol->iol_len) {\n        if(dill_fast(iol->iol_base))\n            memcpy(iol->iol_base, rxbuf->buf + rxbuf->pos, rmn);\n        rxbuf->len = 0;\n        rxbuf->pos = 0;\n        dill_fd_freebuf(rxbuf->buf);\n        rxbuf->buf = NULL;\n        return rmn;\n    }\n    if(dill_fast(iol->iol_base))\n        memcpy(iol->iol_base, rxbuf->buf + rxbuf->pos, iol->iol_len);\n    rxbuf->pos += iol->iol_len;\n    return iol->iol_len;\n}\n\nint dill_fd_recv(int s, struct dill_fd_rxbuf *rxbuf, struct dill_iolist *first,\n      struct dill_iolist *last, int64_t deadline) {\n    /* Skip all data until error occurs. */\n    if(dill_slow(!first && !last)) return dill_fd_skip(s, -1, deadline);\n    /* Fill in data from the rxbuf. */\n    size_t sz = 0;\n    if(dill_fast(rxbuf)) {\n        while(1) {\n            sz = dill_fd_copy(rxbuf, first);\n            if(sz < first->iol_len) break;\n            first = first->iol_next;\n            if(!first) return 0;\n        }\n    }\n    /* Copy the current iolist element so that we can modify it without\n       changing the original list. */\n    struct dill_iolist curr;\n    curr.iol_base = first->iol_base ? first->iol_base + sz : NULL;\n    curr.iol_len = first->iol_len - sz;\n    curr.iol_next = first->iol_next;\n    curr.iol_rsvd = 0;\n    /* Find out how much data is still missing. */\n    size_t miss = 0;\n    struct dill_iolist *it = &curr;\n    while(it) {\n        miss += it->iol_len;\n        it = it->iol_next;\n    }\n    /* If requested amount of data is larger than rx buffer avoid the copy\n       and read it directly into user's buffer. */\n    if(!rxbuf || miss > DILL_FD_BUFSIZE) {\n        // There may be NULL bufers in the list. These can't be passed to\n        // recv_(). We have to split the list and call recv_() and skip()\n        // respectively.\n        struct dill_iolist *begin = &curr;\n        struct dill_iolist *end = curr.iol_next ? last : &curr;\n        struct dill_iolist *it = begin;\n        while(1) {\n            if(dill_slow(!it->iol_len)) {\n                /* No buffer space available. Move on to the next buffer. */\n                dill_assert(it == begin);\n                goto next;\n            }\n            if(dill_slow(!it->iol_base)) {\n                /* Skip specified number of bytes. */\n                dill_assert(it == begin);\n                int rc = dill_fd_skip(s, it->iol_len, deadline);\n                goto next;\n            }\n            if(it == end || !it->iol_next->iol_base || !it->iol_next->iol_len) {\n                /* Do the actual recv syscall. */\n                struct dill_iolist *tmp = it->iol_next;\n                it->iol_next = NULL;\n                int rc = dill_fd_recv_(s, begin, it, deadline);\n                it->iol_next = tmp;\n                if(dill_slow(rc < 0)) return -1;\n                goto next;\n            }\n            /* Accumlate multiple buffers into a single syscall. */\n            it = it->iol_next;\n            continue;\nnext:\n            if(it == end) return 0;\n            it = it->iol_next;\n            begin = it;\n        }\n    }\n    /* If small amount of data is requested use rx buffer. */\n    while(1) {\n        /* Read as much data as possible to the buffer to avoid extra\n           syscalls. Do the speculative recv() first to avoid extra\n           polling. Do fdin() only after recv() fails to get data. */\n        if(!rxbuf->buf) {\n            rxbuf->buf = dill_fd_allocbuf();\n            if(dill_slow(!rxbuf->buf)) return -1;\n        }\n        ssize_t sz = recv(s, rxbuf->buf, DILL_FD_BUFSIZE, 0);\n        if(dill_slow(sz == 0)) {errno = EPIPE; return -1;}\n        if(sz < 0) {\n            if(dill_slow(errno != EWOULDBLOCK && errno != EAGAIN)) {\n                if(errno == EPIPE) errno = ECONNRESET;\n                return -1;\n            }\n            sz = 0;\n        }\n        rxbuf->len = sz;\n        rxbuf->pos = 0;\n        /* Copy the data from rxbuffer to the iolist. */\n        while(1) {\n            sz = dill_fd_copy(rxbuf, &curr);\n            if(sz < curr.iol_len) break;\n            if(!curr.iol_next) return 0;\n            curr = *curr.iol_next;\n        }\n        if(curr.iol_base) curr.iol_base += sz;\n        curr.iol_len -= sz;\n        /* Wait for more data. */\n        int rc = dill_fdin(s, deadline);\n        if(dill_slow(rc < 0)) return -1;\n    }\n}\n\nvoid dill_fd_close(int s) {\n    int rc = dill_fdclean(s);\n    dill_assert(rc == 0);\n    /* Discard any pending outbound data. If SO_LINGER option cannot\n       be set, never mind and continue anyway. */\n    struct linger lng;\n    lng.l_onoff=1;\n    lng.l_linger=0;\n    setsockopt(s, SOL_SOCKET, SO_LINGER, (void*)&lng, sizeof(lng));\n    /* We are not checking the error here. close() has inconsistent behaviour\n       and leaking a file descriptor is better than crashing the entire\n       program. */\n    close(s);\n}\n\nint dill_fd_own(int s) {\n    int n = dup(s);\n    if(dill_slow(n < 0)) return -1;\n    dill_fd_close(s);\n    return n;\n}\n\nint dill_fd_check(int s, int type, int family1, int family2, int listening) {\n    /* Check type. E.g. SOCK_STREAM vs. SOCK_DGRAM. */\n    int val;\n    socklen_t valsz = sizeof(val);\n    int rc = getsockopt(s, SOL_SOCKET, SO_TYPE, &val, &valsz);\n    if(dill_slow(rc < 0)) return -1;\n    if(dill_slow(val != type)) {errno = EINVAL; return -1;}\n    /* Check whether the socket is in listening mode.\n       Returns ENOPROTOOPT on OSX. */\n    rc = getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, &val, &valsz);\n    if(dill_slow(rc < 0 && errno != ENOPROTOOPT)) return -1;\n    if(dill_slow(rc >= 0 && val != listening)) {errno = EINVAL; return -1;}\n    /* Check family. E.g. AF_INET vs. AF_UNIX. */\n    struct sockaddr_storage ss;\n    socklen_t sssz = sizeof(ss);\n    rc = getsockname(s, (struct sockaddr*)&ss, &sssz);\n    if(dill_slow(rc < 0)) return -1;\n    if(dill_slow(ss.ss_family != family1 && ss.ss_family != family2)) {\n        errno = EINVAL; return -1;}\n    return 0;\n}\n\n"
        },
        {
          "name": "fd.h",
          "type": "blob",
          "size": 2.26953125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_FD_INCLUDED\n#define DILL_FD_INCLUDED\n\n#include <stdint.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdill.h\"\n#include \"slist.h\"\n\nstruct dill_ctx_fd {\n    int count;\n    struct dill_slist cache;\n};\n\nint dill_ctx_fd_init(struct dill_ctx_fd *ctx);\nvoid dill_ctx_fd_term(struct dill_ctx_fd *ctx);\n\nstruct dill_fd_rxbuf {\n    size_t len;\n    size_t pos;\n    uint8_t *buf;\n};\n\nvoid dill_fd_initrxbuf(\n    struct dill_fd_rxbuf *rxbuf);\nvoid dill_fd_termrxbuf(\n    struct dill_fd_rxbuf *rxbuf);\nint dill_fd_unblock(\n    int s);\nint dill_fd_connect(\n    int s,\n    const struct sockaddr *addr,\n    socklen_t addrlen,\n    int64_t deadline);\nint dill_fd_accept(\n    int s,\n    struct sockaddr *addr,\n    socklen_t *addrlen,\n    int64_t deadline);\nint dill_fd_send(\n    int s,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nint dill_fd_recv(\n    int s,\n    struct dill_fd_rxbuf *rxbuf,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nvoid dill_fd_close(\n    int s);\nint dill_fd_own(\n    int s);\nint dill_fd_check(\n    int s,\n    int type,\n    int family1,\n    int family2,\n    int listening);\n\n#endif\n\n"
        },
        {
          "name": "handle.c",
          "type": "blob",
          "size": 5.4462890625,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cr.h\"\n#include \"handle.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n\nstruct dill_handle {\n    /* Table of virtual functions. */\n    struct dill_hvfs *vfs;\n    /* Index of the next handle in the linked list of unused handles. -1 means\n       'the end of the list'. -2 means 'handle is in use'. */\n    int next;\n    /* Cache the last call to hquery. */\n    const void *type;\n    void *ptr;\n};\n\n#define DILL_CHECKHANDLE(h, err) \\\n    if(dill_slow((h) < 0 || (h) >= ctx->nhandles ||\\\n          ctx->handles[(h)].next != -2)) {\\\n        errno = EBADF; return (err);}\\\n    struct dill_handle *hndl = &ctx->handles[(h)];\n\nint dill_ctx_handle_init(struct dill_ctx_handle *ctx) {\n    ctx->handles = NULL;\n    ctx->nhandles = 0;\n    ctx->nused = 0;\n    ctx->first = -1;\n    ctx->last = -1;\n    return 0;\n}\n\nvoid dill_ctx_handle_term(struct dill_ctx_handle *ctx) {\n    free(ctx->handles);\n}\n\nint dill_hmake(struct dill_hvfs *vfs) {\n    struct dill_ctx_handle *ctx = &dill_getctx->handle;\n    if(dill_slow(!vfs || !vfs->query || !vfs->close)) {\n        errno = EINVAL; return -1;}\n    /* Returns ECANCELED if shutting down. */\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* If there's no space for the new handle, expand the array.\n       Keep at least 8 handles unused so that there's at least some rotation\n       of handle numbers even if operating close to the current limit. */\n    if(dill_slow(ctx->nhandles - ctx->nused <= 8)) {\n        /* Start with 256 handles, double the size when needed. */\n        int sz = ctx->nhandles ? ctx->nhandles * 2 : 256;\n        struct dill_handle *hndls =\n            realloc(ctx->handles, sz * sizeof(struct dill_handle));\n        if(dill_slow(!hndls)) {errno = ENOMEM; return -1;}\n        /* Add newly allocated handles to the list of unused handles. */\n        int i;\n        for(i = ctx->nhandles; i != sz - 1; ++i)\n            hndls[i].next = i + 1;\n        hndls[sz - 1].next = -1;\n        ctx->first = ctx->nhandles;\n        ctx->last = sz - 1; \n        /* Adjust the array. */\n        ctx->handles = hndls;\n        ctx->nhandles = sz;\n    }\n    /* Return first handle from the list of unused handles. */\n    int h = ctx->first;\n    ctx->first = ctx->handles[h].next;\n    if(dill_slow(ctx->first) == -1) ctx->last = -1;\n    ctx->handles[h].vfs = vfs;\n    ctx->handles[h].next = -2;\n    ctx->handles[h].type = NULL;\n    ctx->handles[h].ptr = NULL;\n    ctx->nused++;\n    return h;\n}\n\nint dill_hown(int h) {\n    struct dill_ctx_handle *ctx = &dill_getctx->handle;\n    DILL_CHECKHANDLE(h, -1);\n    /* Create a new handle for the same object. */\n    int res = dill_hmake(hndl->vfs);\n    if(dill_slow(res < 0)) {\n        int rc = dill_hclose(h);\n        dill_assert(rc == 0);\n        return -1;\n    }\n    /* In case handle array was reallocated we have to recompute the pointer. */\n    hndl = &ctx->handles[h];\n    /* Return a handle to the shared pool. */\n    hndl->ptr = NULL;\n    hndl->next = -1;\n    if(ctx->first == -1) ctx->first = h;\n    else ctx->handles[ctx->last].next = h;\n    ctx->last = h;\n    ctx->nused--;\n    return res;\n}\n\nvoid *dill_hquery(int h, const void *type) {\n    struct dill_ctx_handle *ctx = &dill_getctx->handle;\n    DILL_CHECKHANDLE(h, NULL);\n    /* Try and use the cached pointer first; otherwise do the expensive virtual\n       call.*/\n    if(dill_fast(hndl->ptr != NULL && hndl->type == type))\n        return hndl->ptr;\n    else {\n        void *ptr = hndl->vfs->query(hndl->vfs, type);\n        if(dill_slow(!ptr)) return NULL;\n        /* Update cache. */\n        hndl->type = type;\n        hndl->ptr = ptr;\n        return ptr;\n    }\n}\n\nint dill_hclose(int h) {\n    struct dill_ctx_handle *ctx = &dill_getctx->handle;\n    DILL_CHECKHANDLE(h, -1);\n    /* This will guarantee that blocking functions cannot be called anywhere\n       inside the context of the close. */\n    int old = dill_no_blocking(1);\n    /* Send the stop signal to the handle. */\n    hndl->vfs->close(hndl->vfs);\n    /* Restore the previous state. */\n    dill_no_blocking(old);\n    /* Mark the cache as invalid. */\n    hndl->ptr = NULL;\n    /* Return a handle to the shared pool. */\n    hndl->next = -1;\n    if(ctx->first == -1) ctx->first = h;\n    else ctx->handles[ctx->last].next = h;\n    ctx->last = h;\n    ctx->nused--;\n    return 0;\n}\n\n"
        },
        {
          "name": "handle.h",
          "type": "blob",
          "size": 1.568359375,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_HANDLE_INCLUDED\n#define DILL_HANDLE_INCLUDED\n\nstruct dill_handle;\n\nstruct dill_ctx_handle {\n    /* Array of handles. The size of the array is stored in 'nall'. */\n    struct dill_handle *handles;\n    int nhandles;\n    /* Number of allocated handles. */\n    int nused;\n    /* Points to the first and last item in the list of unused handles. */\n    int first;\n    int last;\n};\n\nint dill_ctx_handle_init(struct dill_ctx_handle *ctx);\nvoid dill_ctx_handle_term(struct dill_ctx_handle *ctx);\n\n#endif\n\n"
        },
        {
          "name": "happyeyeballs.c",
          "type": "blob",
          "size": 6.4736328125,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdill.h\"\n#include \"utils.h\"\n\nstatic dill_coroutine void dill_happyeyeballs_dnsquery(const char *name,\n      int port, int mode, int ch) {\n    /* Do the DNS query. Let's be reasonable and limit the number of addresses\n       to 10 per IP version. */\n    struct dill_ipaddr addrs[10];\n    int count = dill_ipaddr_remotes(addrs, 10, name, port, mode, -1);\n    if(count > 0) {\n        /* Send the results of the query to the main fuction. */\n        int i;\n        for(i = 0; i != count; ++i) {\n           int rc = dill_chsend(ch, &addrs[i], sizeof(struct dill_ipaddr), -1);\n           if(dill_slow(rc < 0 && errno == ECANCELED)) return;\n           dill_assert(rc == 0);\n        }\n    }\n    /* chdone is deliberately not being called here so that sorter doesn't\n       have to deal with closed channels. Instead we'll send 0.0.0.0 address\n       to mark the end of the results. */\n    struct dill_ipaddr addr;\n    int rc = dill_ipaddr_local(&addr, \"0.0.0.0\", 0, DILL_IPADDR_IPV4);\n    dill_assert(rc == 0);\n    rc = dill_chsend(ch, &addr, sizeof(struct dill_ipaddr), -1);\n    dill_assert(rc == 0 || errno == ECANCELED);\n}\n\nstatic dill_coroutine void dill_happyeyeballs_attempt(struct dill_ipaddr addr,\n      int ch) {\n    int conn = dill_tcp_connect(&addr, -1);\n    if(dill_slow(conn < 0)) return;\n    int rc = dill_chsend(ch, &conn, sizeof(int), -1);\n    if(dill_slow(rc < 0 && errno == ECANCELED)) {\n        rc = dill_hclose(conn);\n        dill_assert(rc == 0);\n        return;\n    }\n    dill_assert(rc == 0);\n}\n\nstatic dill_coroutine void dill_happyeyeballs_coordinator(\n      const char *name, int port, int ch) {\n    struct dill_ipaddr nulladdr;\n    int rc = dill_ipaddr_local(&nulladdr, \"0.0.0.0\", 0, DILL_IPADDR_IPV4);\n    dill_assert(rc == 0);\n    /* According to the RFC, IPv4 and IPv6 DNS queries should be done in\n       parallel. Create two coroutines and two channels to pass\n       the addresses from them. */\n    int chipv6[2];\n    struct dill_chstorage chipv6_storage;\n    rc = dill_chmake_mem(&chipv6_storage, chipv6);\n    dill_assert(rc == 0);\n    int chipv4[2];\n    struct dill_chstorage chipv4_storage;\n    rc = dill_chmake_mem(&chipv4_storage, chipv4);\n    dill_assert(rc == 0);\n    struct dill_bundle_storage bndl_storage;\n    int bndl = dill_bundle_mem(&bndl_storage);\n    dill_assert(bndl >= 0);\n    rc = dill_bundle_go(bndl, dill_happyeyeballs_dnsquery(name, port,\n        DILL_IPADDR_IPV6, chipv6[1]));\n    if(dill_slow(rc < 0 && errno == ECANCELED)) goto cancel;\n    dill_assert(rc == 0);\n    rc = dill_bundle_go(bndl, dill_happyeyeballs_dnsquery(name, port,\n        DILL_IPADDR_IPV4, chipv4[1]));\n    if(dill_slow(rc < 0 && errno == ECANCELED)) goto cancel;\n    dill_assert(rc == 0);\n    /* RFC says to wait for 50ms for IPv6 result irrespective of whether\n       IPv4 address arrives. */\n    struct dill_ipaddr addr;\n    struct dill_chclause cls[2] = {\n        {DILL_CHRECV, chipv6[0], &addr, sizeof(struct dill_ipaddr)},\n        {DILL_CHRECV, chipv4[0], &addr, sizeof(struct dill_ipaddr)}\n    };\n    rc = dill_chrecv(chipv6[0], &addr, sizeof(struct dill_ipaddr),\n        dill_now() + 50);\n    if(dill_slow(rc < 0 && errno == ECANCELED)) goto cancel;\n    int idx;\n    int64_t nw;\n    if(dill_fast(rc == 0)) {\n        idx = 0;\n        nw = dill_now();\n        goto use_address;\n    }\n    dill_assert(errno == ETIMEDOUT);\n    /* From now we can use any address. */\n    while(1) {\n        nw = dill_now();\n        idx = dill_choose(cls, 2, -1);\n        if(dill_slow(idx < 0 && errno == ECANCELED)) goto cancel;\n        dill_assert(idx >= 0 && errno == 0);\nuse_address:\n        /* Ignore 0.0.0.0 addresses. */\n        if(dill_ipaddr_equal(&addr, &nulladdr, 0)) continue;\n        /* Launch the connect attempt. */\n        rc = dill_bundle_go(bndl, dill_happyeyeballs_attempt(addr, ch));\n        if(dill_slow(rc < 0 && errno == ECANCELED)) goto cancel;\n        dill_assert(rc == 0);\n        /* Alternate between IPv4 and IPv6 addresses. */\n        if(idx == 0) {\n            int tmp = cls[0].ch;\n            cls[0].ch = cls[1].ch;\n            cls[1].ch = tmp;\n        }\n        /* Wait for 300ms before launching next connection attempt. */\n        rc = dill_msleep(nw + 300);\n        if(dill_slow(rc < 0 && errno == ECANCELED)) goto cancel;\n        dill_assert(rc == 0);\n    }\ncancel:\n    rc = dill_hclose(bndl);\n    dill_assert(rc == 0);\n    rc = dill_hclose(chipv4[0]);\n    dill_assert(rc == 0);\n    rc = dill_hclose(chipv4[1]);\n    dill_assert(rc == 0);\n    rc = dill_hclose(chipv6[0]);\n    dill_assert(rc == 0);\n    rc = dill_hclose(chipv6[1]);\n    dill_assert(rc == 0);\n}\n\nint dill_happyeyeballs_connect(const char *name, int port, int64_t deadline) {\n    int res = -1;\n    int err = 0;\n    if(dill_slow(!name || port <= 0)) {err = EINVAL; goto exit1;}\n    int chconns[2];\n    struct dill_chstorage chconns_storage;\n    int rc = dill_chmake_mem(&chconns_storage, chconns);\n    if(dill_slow(rc < 0)) {err = errno; goto exit1;}\n    int coord = dill_go(dill_happyeyeballs_coordinator(name, port, chconns[1]));\n    if(dill_slow(coord < 0)) {err = errno; goto exit2;}\n    int conn;\n    rc = dill_chrecv(chconns[0], &conn, sizeof(int), deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto exit3;}\n    res = conn;\nexit3:\n    rc = dill_hclose(coord);\n    dill_assert(rc == 0);\nexit2:\n    rc = dill_hclose(chconns[0]);\n    dill_assert(rc == 0);\n    rc = dill_hclose(chconns[1]);\n    dill_assert(rc == 0);\nexit1:\n    errno = err;\n    return res;\n}\n\n"
        },
        {
          "name": "http.c",
          "type": "blob",
          "size": 11.41015625,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_http_type);\n\nstatic void *dill_http_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_http_hclose(struct dill_hvfs *hvfs);\n\nstruct dill_http_sock {\n    struct dill_hvfs hvfs;\n    /* Underlying SUFFIX socket. */\n    int u;\n    unsigned int mem : 1;\n    struct dill_suffix_storage suffix_mem;\n    struct dill_term_storage term_mem;\n    char rxbuf[1024];\n};\n\nDILL_CHECK_STORAGE(dill_http_sock, dill_http_storage)\n\nstatic void *dill_http_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_http_sock *obj = (struct dill_http_sock*)hvfs;\n    if(type == dill_http_type) return obj;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_http_attach_mem(int s, struct dill_http_storage *mem) {\n    int err;\n    struct dill_http_sock *obj = (struct dill_http_sock*)mem;\n    if(dill_slow(!mem)) {err = EINVAL; goto error;}\n    /* Check whether underlying socket is a bytestream. */\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) {err = errno; goto error;}\n    /* Take the ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Wrap the underlying socket into SUFFIX and TERM protocol. */\n    s = dill_suffix_attach_mem(s, \"\\r\\n\", 2, &obj->suffix_mem);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    s = dill_term_attach_mem(s, NULL, 0, &obj->term_mem);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Create the object. */\n    obj->hvfs.query = dill_http_hquery;\n    obj->hvfs.close = dill_http_hclose;\n    obj->u = s;\n    obj->mem = 1;\n    /* Create the handle. */\n    int h = dill_hmake(&obj->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_http_attach(int s) {\n    int err;\n    struct dill_http_sock *obj = malloc(sizeof(struct dill_http_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_http_attach_mem(s, (struct dill_http_storage*)obj);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_http_done(int s, int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    return dill_term_done(obj->u, deadline);\n}\n\nint dill_http_detach(int s, int64_t deadline) {\n    int err = 0;\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    int u = dill_term_detach(obj->u, deadline);\n    if(dill_slow(u < 0)) {err = errno; goto error;}\n    u = dill_suffix_detach(u, deadline);\n    if(dill_slow(u < 0)) {err = errno; goto error;}\nerror:\n    if(!obj->mem) free(obj);\n    errno = err;\n    return u;\n}\n\nint dill_http_sendrequest(int s, const char *command, const char *resource,\n      int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    if (strpbrk(command, \" \\t\\n\") != NULL) {errno = EINVAL; return -1;}\n    if (strpbrk(resource, \" \\t\\n\") != NULL) {errno = EINVAL; return -1;}\n    struct dill_iolist iol[4];\n    iol[0].iol_base = (void*)command;\n    iol[0].iol_len = strlen(command);\n    iol[0].iol_next = &iol[1];\n    iol[0].iol_rsvd = 0;\n    iol[1].iol_base = (void*)\" \";\n    iol[1].iol_len = 1;\n    iol[1].iol_next = &iol[2];\n    iol[1].iol_rsvd = 0;\n    iol[2].iol_base = (void*)resource;\n    iol[2].iol_len = strlen(resource);\n    iol[2].iol_next = &iol[3];\n    iol[2].iol_rsvd = 0;\n    iol[3].iol_base = (void*)\" HTTP/1.1\";\n    iol[3].iol_len = 9;\n    iol[3].iol_next = NULL;\n    iol[3].iol_rsvd = 0;\n    return dill_msendl(obj->u, &iol[0], &iol[3], deadline);\n}\n\nint dill_http_recvrequest(int s, char *command, size_t commandlen,\n      char *resource, size_t resourcelen, int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    ssize_t sz = dill_mrecv(obj->u, obj->rxbuf, sizeof(obj->rxbuf) - 1,\n        deadline);\n    if(dill_slow(sz < 0)) return -1;\n    obj->rxbuf[sz] = 0;\n    size_t pos = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Command. */\n    size_t start = pos;\n    while(obj->rxbuf[pos] != 0 && obj->rxbuf[pos] != ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] == 0)) {errno = EPROTO; return -1;}\n    if(dill_slow(pos - start > commandlen - 1)) {errno = EMSGSIZE; return -1;}\n    memcpy(command, obj->rxbuf + start, pos - start);\n    command[pos - start] = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Resource. */\n    start = pos;\n    while(obj->rxbuf[pos] != 0 && obj->rxbuf[pos] != ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] == 0)) {errno = EPROTO; return -1;}\n    if(dill_slow(pos - start > resourcelen - 1)) {errno = EMSGSIZE; return -1;}\n    memcpy(resource, obj->rxbuf + start, pos - start);\n    resource[pos - start] = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Protocol. */\n    start = pos;\n    while(obj->rxbuf[pos] != 0 && obj->rxbuf[pos] != ' ') ++pos;\n    if(dill_slow(pos - start != 8 &&\n          memcmp(obj->rxbuf + start, \"HTTP/1.1\", 8) != 0)) {\n        errno = EPROTO; return -1;}\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] != 0)) {errno = EPROTO; return -1;}\n    return 0;\n}\n\nint dill_http_sendstatus(int s, int status, const char *reason, int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    if(dill_slow(status < 100 || status > 599)) {errno = EINVAL; return -1;}\n    char buf[4];\n    buf[0] = (status / 100) + '0';\n    status %= 100;\n    buf[1] = (status / 10) + '0';\n    status %= 10;\n    buf[2] = status + '0';\n    buf[3] = ' ';\n    struct dill_iolist iol[3];\n    iol[0].iol_base = (void*)\"HTTP/1.1 \";\n    iol[0].iol_len = 9;\n    iol[0].iol_next = &iol[1];\n    iol[0].iol_rsvd = 0;\n    iol[1].iol_base = buf;\n    iol[1].iol_len = 4;\n    iol[1].iol_next = &iol[2];\n    iol[1].iol_rsvd = 0;\n    iol[2].iol_base = (void*)reason;\n    iol[2].iol_len = strlen(reason);\n    iol[2].iol_next = NULL;\n    iol[2].iol_rsvd = 0;\n    return dill_msendl(obj->u, &iol[0], &iol[2], deadline);\n}\n\nint dill_http_recvstatus(int s, char *reason, size_t reasonlen,\n      int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    ssize_t sz = dill_mrecv(obj->u, obj->rxbuf, sizeof(obj->rxbuf) - 1,\n        deadline);\n    if(dill_slow(sz < 0)) return -1;\n    obj->rxbuf[sz] = 0;\n    size_t pos = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Protocol. */\n    size_t start = pos;\n    while(obj->rxbuf[pos] != 0 && obj->rxbuf[pos] != ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] == 0)) {errno = EPROTO; return -1;}\n    if(dill_slow(pos - start != 8 &&\n          memcmp(obj->rxbuf + start, \"HTTP/1.1\", 8) != 0)) {\n        errno = EPROTO; return -1;}\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Status code. */\n    start = pos;\n    while(obj->rxbuf[pos] != 0 && obj->rxbuf[pos] != ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] == 0)) {errno = EPROTO; return -1;}\n    if(dill_slow(pos - start != 3)) {errno = EPROTO; return -1;}\n    if(dill_slow(obj->rxbuf[start] < '0' || obj->rxbuf[start] > '9' ||\n          obj->rxbuf[start + 1] < '0' || obj->rxbuf[start + 1] > '9' ||\n          obj->rxbuf[start + 2] < '0' || obj->rxbuf[start + 2] > '9')) {\n        errno = EPROTO; return -1;}\n    int status = (obj->rxbuf[start] - '0') * 100 +\n        (obj->rxbuf[start + 1] - '0') * 10 +\n        (obj->rxbuf[start + 2] - '0');\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Reason. */\n    if(sz - pos > reasonlen - 1) {errno = EMSGSIZE; return -1;}\n    memcpy(reason, obj->rxbuf + pos, sz - pos);\n    reason[sz - pos] = 0;\n    return status;\n}\n\nint dill_http_sendfield(int s, const char *name, const char *value,\n      int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    /* Check whether name contains only valid characters. */\n    if (strpbrk(name, \"(),/:;<=>?@[\\\\]{}\\\" \\t\\n\") != NULL) {\n        errno = EINVAL; return -1;}\n    if (strlen(value) == 0) {errno = EPROTO; return -1;}\n    struct dill_iolist iol[3];\n    iol[0].iol_base = (void*)name;\n    iol[0].iol_len = strlen(name);\n    iol[0].iol_next = &iol[1];\n    iol[0].iol_rsvd = 0;\n    iol[1].iol_base = (void*)\": \";\n    iol[1].iol_len = 2;\n    iol[1].iol_next = &iol[2];\n    iol[1].iol_rsvd = 0;\n    const char *start = dill_lstrip(value, ' ');\n    const char *end = dill_rstrip(start, ' ');\n    dill_assert(start < end);\n    iol[2].iol_base = (void*)start;\n    iol[2].iol_len = end - start;\n    iol[2].iol_next = NULL;\n    iol[2].iol_rsvd = 0;\n    return dill_msendl(obj->u, &iol[0], &iol[2], deadline);\n}\n\nint dill_http_recvfield(int s, char *name, size_t namelen,\n      char *value, size_t valuelen, int64_t deadline) {\n    struct dill_http_sock *obj = dill_hquery(s, dill_http_type);\n    if(dill_slow(!obj)) return -1;\n    ssize_t sz = dill_mrecv(obj->u, obj->rxbuf, sizeof(obj->rxbuf) - 1,\n        deadline);\n    if(dill_slow(sz < 0)) return -1;\n    obj->rxbuf[sz] = 0;\n    size_t pos = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Name. */\n    size_t start = pos;\n    while(obj->rxbuf[pos] != 0 &&\n          obj->rxbuf[pos] != ' ' &&\n          obj->rxbuf[pos] != ':')\n        ++pos;\n    if(dill_slow(obj->rxbuf[pos] == 0)) {errno = EPROTO; return -1;}\n    if(dill_slow(pos - start > namelen - 1)) {errno = EMSGSIZE; return -1;}\n    memcpy(name, obj->rxbuf + start, pos - start);\n    name[pos - start] = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] != ':')) {errno = EPROTO; return -1;}\n    ++pos;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    /* Value. */\n    start = pos;\n    pos = dill_rstrip(obj->rxbuf + sz, ' ') - obj->rxbuf;\n    if(dill_slow(pos - start > valuelen - 1)) {errno = EMSGSIZE; return -1;}\n    memcpy(value, obj->rxbuf + start, pos - start);\n    value[pos - start] = 0;\n    while(obj->rxbuf[pos] == ' ') ++pos;\n    if(dill_slow(obj->rxbuf[pos] != 0)) {errno = EPROTO; return -1;}\n    return 0;\n}\n\nstatic void dill_http_hclose(struct dill_hvfs *hvfs) {\n    struct dill_http_sock *obj = (struct dill_http_sock*)hvfs;\n    if(dill_fast(obj->u >= 0)) {\n        int rc = dill_hclose(obj->u);\n        dill_assert(rc == 0);\n    }\n    if(!obj->mem) free(obj);\n}\n\n"
        },
        {
          "name": "iol.c",
          "type": "blob",
          "size": 3.369140625,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <string.h>\n\n#include \"iol.h\"\n#include \"utils.h\"\n\nint dill_iolcheck(struct iolist *first, struct iolist *last,\n      size_t *nbufs, size_t *nbytes) {\n    if(!first && !last) {\n        if(nbufs) *nbufs = 0;\n        if(nbytes) *nbytes = 0;\n        return 0;\n    }\n    if(dill_slow(!first || !last || last->iol_next)) {\n        errno = EINVAL; return -1;}\n    size_t nbf = 0, nbt = 0;\n    struct iolist *it;\n    for(it = first; it; it = it->iol_next) {\n        if(dill_slow(it->iol_rsvd || (!it->iol_next && it != last)))\n            goto error;\n        it->iol_rsvd = 1;\n        nbf++;\n        nbt += it->iol_len;\n    }\n    for(it = first; it; it = it->iol_next) it->iol_rsvd = 0;\n    if(nbufs) *nbufs = nbf;\n    if(nbytes) *nbytes = nbt;\n    return 0;\nerror:;\n    struct iolist *it2;\n    for(it2 = first; it2 != it; it2 = it2->iol_next) it->iol_rsvd = 0;\n    errno = EINVAL;\n    return -1;\n}\n\nvoid dill_ioltoiov(struct iolist *first, struct iovec *iov) {\n    while(first) {\n        iov->iov_base = first->iol_base;\n        iov->iov_len = first->iol_len;\n        ++iov;\n        first = first->iol_next;\n    }\n}\n\nint dill_ioltrim(struct iolist *first, size_t n, struct iolist *result) {\n    while(n) {\n        if(!first) return -1;\n        if(first->iol_len >= n) break;\n        n -= first->iol_len;\n        first = first->iol_next;\n    }\n    result->iol_base = first->iol_base ? ((uint8_t*)first->iol_base) + n : NULL;\n    result->iol_len = first->iol_len - n;\n    result->iol_next = first->iol_next;\n    result->iol_rsvd = 0;\n    return 0;\n}\n\nint dill_iolto(const void *src, size_t srclen, struct iolist *first) {\n    const uint8_t *p = src;\n    while(1) {\n        if(!srclen) return 0;\n        if(!first) return -1;\n        if(first->iol_len >= srclen) break;\n        if(first->iol_base) memcpy(first->iol_base, p, first->iol_len);\n        p += first->iol_len;\n        srclen -= first->iol_len;\n        first = first->iol_next; \n    }\n    if(first->iol_base) memcpy(first->iol_base, p, srclen);\n    return 0;\n}\n\nint dill_iolfrom(void *dst, size_t dstlen, struct dill_iolist *first) {\n    uint8_t *p = dst;\n    while(first) {\n        if(dstlen < first->iol_len) return -1;\n        memcpy(p, first->iol_base, first->iol_len);\n        p += first->iol_len;\n        dstlen -= first->iol_len;\n        first = first->iol_next;\n    }\n    return 0;\n}\n\n"
        },
        {
          "name": "iol.h",
          "type": "blob",
          "size": 2.359375,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_IOL_INCLUDED\n#define DILL_IOL_INCLUDED\n\n#include <sys/uio.h>\n\n#include \"libdill.h\"\n\n/* Checks whether iolist is valid. Returns 0 in case of success or -1 in case\n   of error. Fills in number of buffers in the list and overall number of bytes\n   if requested. */\nint dill_iolcheck(struct dill_iolist *first, struct dill_iolist *last,\n    size_t *nbufs, size_t *nbytes);\n\n/* Copy the iolist into an iovec. Iovec must have at least as much elements\n   as the iolist, otherwise undefined behaviour ensues. The data buffers\n   as such are not affected by this operation .*/\nvoid dill_ioltoiov(struct dill_iolist *first, struct iovec *iov);\n\n/* Trims first n bytes from the iolist. Returns the trimmed iolist. Keeps the\n   original iolist unchanged. Returns 0 in the case of success, -1 is there\n   are less than N bytes in the original iolist. */\nint dill_ioltrim(struct dill_iolist *first, size_t n,\n    struct dill_iolist *result);\n\n/* Copies supplied bytes into the iolist. Returns 0 on success, -1 if bytes\n   won't fit into the iolist. */\nint dill_iolto(const void *src, size_t srclen, struct dill_iolist *first);\n\n/* Copies supplied bytes from the iolist. Returns 0 on success, -1 is bytes\n   won't fit into the buffer. */\nint dill_iolfrom(void *dst, size_t dstlen, struct dill_iolist *first);\n\n#endif\n\n"
        },
        {
          "name": "ipaddr.c",
          "type": "blob",
          "size": 14.01953125,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#if defined __linux__\n#define _GNU_SOURCE\n#include <netdb.h>\n#include <sys/eventfd.h>\n#endif\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#if !defined __sun\n#include <ifaddrs.h>\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"dns/dns.h\"\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdill.h\"\n#include \"utils.h\"\n\n/* Make sure that both IPv4 and IPv6 address fits into ipaddr. */\nDILL_CT_ASSERT(sizeof(struct dill_ipaddr) >= sizeof(struct sockaddr_in));\nDILL_CT_ASSERT(sizeof(struct dill_ipaddr) >= sizeof(struct sockaddr_in6));\n\nstatic struct dns_resolv_conf *dill_dns_conf = NULL;\nstatic struct dns_hosts *dill_dns_hosts = NULL;\nstatic struct dns_hints *dill_dns_hints = NULL;\n\nstatic int dill_ipaddr_ipany(struct dill_ipaddr *addr, int port, int mode)\n{\n    if(dill_slow(port < 0 || port > 0xffff)) {errno = EINVAL; return -1;}\n    if (mode == 0 || mode == DILL_IPADDR_IPV4 || mode == DILL_IPADDR_PREF_IPV4) {\n        struct sockaddr_in *ipv4 = (struct sockaddr_in*)addr;\n        ipv4->sin_family = AF_INET;\n        ipv4->sin_addr.s_addr = htonl(INADDR_ANY);\n        ipv4->sin_port = htons((uint16_t)port);\n#ifdef  HAVE_STRUCT_SOCKADDR_SA_LEN\n        ipv4->sin_len = sizeof(struct sockaddr_in);\n#endif\n        return 0;\n    }\n    else {\n        struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)addr;\n        ipv6->sin6_family = AF_INET6;\n        memcpy(&ipv6->sin6_addr, &in6addr_any, sizeof(in6addr_any));\n        ipv6->sin6_port = htons((uint16_t)port);\n#ifdef  HAVE_STRUCT_SOCKADDR_SA_LEN\n        ipv6->sin6_len = sizeof(struct sockaddr_in6);\n#endif\n        return 0;\n    }\n}\n\n/* Convert literal IPv4 address to a binary one. */\nstatic int dill_ipaddr_ipv4_literal(struct dill_ipaddr *addr, const char *name,\n      int port) {\n    struct sockaddr_in *ipv4 = (struct sockaddr_in*)addr;\n    int rc = inet_pton(AF_INET, name, &ipv4->sin_addr);\n    dill_assert(rc >= 0);\n    if(dill_slow(rc != 1)) {errno = EINVAL; return -1;}\n    ipv4->sin_family = AF_INET;\n    ipv4->sin_port = htons((uint16_t)port);\n#ifdef  HAVE_STRUCT_SOCKADDR_SA_LEN\n    ipv4->sin_len = sizeof(struct sockaddr_in);\n#endif\n    return 0;\n}\n\n/* Convert literal IPv6 address to a binary one. */\nstatic int dill_ipaddr_ipv6_literal(struct dill_ipaddr *addr, const char *name,\n      int port) {\n    struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)addr;\n    int rc = inet_pton(AF_INET6, name, &ipv6->sin6_addr);\n    dill_assert(rc >= 0);\n    if(dill_slow(rc != 1)) {errno = EINVAL; return -1;}\n    ipv6->sin6_family = AF_INET6;\n    ipv6->sin6_port = htons((uint16_t)port);\n#ifdef  HAVE_STRUCT_SOCKADDR_SA_LEN\n    ipv6->sin6_len = sizeof(struct sockaddr_in6);\n#endif\n    return 0;\n}\n\n/* Convert literal IPv4 or IPv6 address to a binary one. */\nstatic int dill_ipaddr_literal(struct dill_ipaddr *addr, const char *name, int port,\n      int mode) {\n    if(dill_slow(!addr || port < 0 || port > 0xffff)) {\n        errno = EINVAL;\n        return -1;\n    }\n    int rc;\n    switch(mode) {\n    case DILL_IPADDR_IPV4:\n        return dill_ipaddr_ipv4_literal(addr, name, port);\n    case DILL_IPADDR_IPV6:\n        return dill_ipaddr_ipv6_literal(addr, name, port);\n    case 0:\n    case DILL_IPADDR_PREF_IPV4:\n        rc = dill_ipaddr_ipv4_literal(addr, name, port);\n        if(rc == 0)\n            return 0;\n        return dill_ipaddr_ipv6_literal(addr, name, port);\n    case DILL_IPADDR_PREF_IPV6:\n        rc = dill_ipaddr_ipv6_literal(addr, name, port);\n        if(rc == 0)\n            return 0;\n        return dill_ipaddr_ipv4_literal(addr, name, port);\n    default:\n        dill_assert(0);\n    }\n}\n\nint dill_ipaddr_family(const struct dill_ipaddr *addr) {\n    return ((struct sockaddr*)addr)->sa_family;\n}\n\nint dill_ipaddr_len(const struct dill_ipaddr *addr) {\n    return dill_ipaddr_family(addr) == AF_INET ?\n        sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n}\n\nconst struct sockaddr *dill_ipaddr_sockaddr(const struct dill_ipaddr *addr) {\n    return (const struct sockaddr*)addr;\n}\n\nint dill_ipaddr_port(const struct dill_ipaddr *addr) {\n    return ntohs(dill_ipaddr_family(addr) == AF_INET ?\n        ((struct sockaddr_in*)addr)->sin_port :\n        ((struct sockaddr_in6*)addr)->sin6_port);\n}\n\nvoid dill_ipaddr_setport(struct dill_ipaddr *addr, int port) {\n    if(dill_ipaddr_family(addr) == AF_INET)\n        ((struct sockaddr_in*)addr)->sin_port = htons(port);\n    else\n        ((struct sockaddr_in6*)addr)->sin6_port = htons(port);\n}\n\n/* Convert IP address from network format to ASCII dot notation. */\nconst char *dill_ipaddr_str(const struct dill_ipaddr *addr, char *ipstr) {\n    if(dill_ipaddr_family(addr) == AF_INET) {\n        return inet_ntop(AF_INET, &(((struct sockaddr_in*)addr)->sin_addr),\n            ipstr, INET_ADDRSTRLEN);\n    }\n    else {\n        return inet_ntop(AF_INET6, &(((struct sockaddr_in6*)addr)->sin6_addr),\n            ipstr, INET6_ADDRSTRLEN);\n    }\n}\n\nint dill_ipaddr_local(struct dill_ipaddr *addr, const char *name, int port,\n      int mode) {\n    if(mode == 0) mode = DILL_IPADDR_PREF_IPV4;\n    memset(addr, 0, sizeof(struct dill_ipaddr));\n    if(!name) \n        return dill_ipaddr_ipany(addr, port, mode);\n    int rc = dill_ipaddr_literal(addr, name, port, mode);\n#if defined __sun\n    return rc;\n#else\n    if(rc == 0)\n       return 0;\n    /* Address is not a literal. It must be an interface name then. */\n    struct ifaddrs *ifaces = NULL;\n    rc = getifaddrs (&ifaces);\n    dill_assert (rc == 0);\n    dill_assert (ifaces);\n    /*  Find first IPv4 and first IPv6 address. */\n    struct ifaddrs *ipv4 = NULL;\n    struct ifaddrs *ipv6 = NULL;\n    struct ifaddrs *it;\n    for(it = ifaces; it != NULL; it = it->ifa_next) {\n        if(!it->ifa_addr)\n            continue;\n        if(strcmp(it->ifa_name, name) != 0)\n            continue;\n        switch(it->ifa_addr->sa_family) {\n        case AF_INET:\n            dill_assert(!ipv4);\n            ipv4 = it;\n            break;\n        case AF_INET6:\n            dill_assert(!ipv6);\n            ipv6 = it;\n            break;\n        }\n        if(ipv4 && ipv6)\n            break;\n    }\n    /* Choose the correct address family based on mode. */\n    switch(mode) {\n    case DILL_IPADDR_IPV4:\n        ipv6 = NULL;\n        break;\n    case DILL_IPADDR_IPV6:\n        ipv4 = NULL;\n        break;\n    case 0:\n    case DILL_IPADDR_PREF_IPV4:\n        if(ipv4)\n           ipv6 = NULL;\n        break;\n    case DILL_IPADDR_PREF_IPV6:\n        if(ipv6)\n           ipv4 = NULL;\n        break;\n    default:\n        dill_assert(0);\n    }\n    if(ipv4) {\n        struct sockaddr_in *inaddr = (struct sockaddr_in*)addr;\n        memcpy(inaddr, ipv4->ifa_addr, sizeof (struct sockaddr_in));\n        inaddr->sin_port = htons(port);\n        freeifaddrs(ifaces);\n        return 0;\n    }\n    if(ipv6) {\n        struct sockaddr_in6 *inaddr = (struct sockaddr_in6*)addr;\n        memcpy(inaddr, ipv6->ifa_addr, sizeof (struct sockaddr_in6));\n        inaddr->sin6_port = htons(port);\n        freeifaddrs(ifaces);\n        return 0;\n    }\n    freeifaddrs(ifaces);\n    errno = ENODEV;\n    return -1;\n#endif\n}\n\nint dill_ipaddr_remote(struct dill_ipaddr *addr, const char *name, int port,\n      int mode, int64_t deadline) {\n    int rc = dill_ipaddr_remotes(addr, 1, name, port, mode, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    if(rc == 0) {errno = EADDRNOTAVAIL; return -1;}\n    return 0;\n}\n\nint dill_ipaddr_remotes(struct dill_ipaddr *addrs, int naddrs,\n      const char *name, int port, int mode, int64_t deadline) {\n    /* Check the arguments. */\n    if(dill_slow(!addrs || naddrs <= 0 || !name)) {errno = EINVAL; return -1;}\n    switch(mode) {\n    case 0:\n        mode = DILL_IPADDR_PREF_IPV4;\n        break;\n    case DILL_IPADDR_IPV4:\n    case DILL_IPADDR_IPV6:\n    case DILL_IPADDR_PREF_IPV4:\n    case DILL_IPADDR_PREF_IPV6:\n        break;\n    default:\n        errno = EINVAL;\n        return -1;\n    }\n    /* Name may be a IP address literal. */\n    memset(addrs, 0, sizeof(struct dill_ipaddr));\n    int rc = dill_ipaddr_literal(addrs, name, port, mode);\n    if(rc == 0) {\n        if(dill_slow(mode == DILL_IPADDR_IPV6 &&\n              dill_ipaddr_family(addrs) == AF_INET)) return 0;\n        if(dill_slow(mode == DILL_IPADDR_IPV4 &&\n              dill_ipaddr_family(addrs) == AF_INET6)) return 0;\n        return 1;\n    }\n    /* PREF modes are done in recursive fashion. */\n    if(mode == DILL_IPADDR_PREF_IPV4) {\n        int rc1 = dill_ipaddr_remotes(addrs, naddrs, name, port,\n            DILL_IPADDR_IPV4, deadline);\n        if(dill_slow(rc1 < 0)) return -1;\n        int rc2 = 0;\n        if(naddrs - rc1 > 0) {\n            rc2 = dill_ipaddr_remotes(addrs + rc1, naddrs - rc1, name, port,\n                DILL_IPADDR_IPV6, deadline);\n            if(dill_slow(rc2 < 0)) return -1;\n        }\n        return rc1 + rc2;\n    }\n    if(mode == DILL_IPADDR_PREF_IPV6) {\n        int rc1 = dill_ipaddr_remotes(addrs, naddrs, name, port,\n            DILL_IPADDR_IPV6, deadline);\n        if(dill_slow(rc1 < 0)) return -1;\n        int rc2 = 0;\n        if(naddrs - rc1 > 0) {\n            rc2 = dill_ipaddr_remotes(addrs + rc1, naddrs - rc1, name, port,\n                DILL_IPADDR_IPV4, deadline);\n            if(dill_slow(rc2 < 0)) return -1;\n        }\n        return rc1 + rc2;\n    }\n    /* We are going to do a DNS query here so load DNS config files,\n       unless they are already chached. */\n    if(dill_slow(!dill_dns_conf)) {\n        /* TODO: Maybe re-read the configuration once in a while? */\n        dill_dns_conf = dns_resconf_local(&rc);\n        if(!dill_dns_conf) {\n            errno = ENOENT;\n            return -1;\n        }\n        dill_dns_hosts = dns_hosts_local(&rc);\n        dill_assert(dill_dns_hosts);\n        dill_dns_hints = dns_hints_local(dill_dns_conf, &rc);\n        dill_assert(dill_dns_hints);\n    }\n    /* Launch the actual DNS query. */\n    struct dns_resolver *resolver = dns_res_open(dill_dns_conf,\n        dill_dns_hosts, dill_dns_hints, NULL, dns_opts(), &rc);\n    if(!resolver) {\n        if(errno == ENFILE || errno == EMFILE) {\n            return -1;\n        }\n        dill_assert(resolver);\n    }\n    dill_assert(port >= 0 && port <= 0xffff);\n    char portstr[8];\n    snprintf(portstr, sizeof(portstr), \"%d\", port);\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = PF_UNSPEC;\n    struct dns_addrinfo *ai = dns_ai_open(name, portstr,\n        mode == DILL_IPADDR_IPV4 ? DNS_T_A : DNS_T_AAAA, &hints,\n        resolver, &rc);\n    dill_assert(ai);\n    dns_res_close(resolver);\n    /* Wait for the results. */\n    int nresults = 0;\n    struct addrinfo *it = NULL;\n    while(1) {\n        rc = dns_ai_nextent(&it, ai);\n        if(rc == EAGAIN) {\n            int fd = dns_ai_pollfd(ai);\n            int events = dns_ai_events(ai);\n            dill_assert(fd >= 0);\n            int rc = (events & DNS_POLLOUT) ?\n                dill_fdout(fd, deadline) : dill_fdin(fd, deadline);\n            /* There's no guarantee that the file descriptor will be reused\n               in next iteration. We have to clean the fdwait cache here\n               to be on the safe side. */\n            int err = errno;\n            dill_fdclean(fd);\n            errno = err;\n            if(dill_slow(rc < 0)) {\n                dns_ai_close(ai);\n                return -1;\n            }\n            continue;\n        }\n        if(rc == ENOENT || (rc >= DNS_EBASE && rc <= DNS_ELAST)) break;\n        if(naddrs && mode == DILL_IPADDR_IPV4 && it->ai_family == AF_INET) {\n            struct sockaddr_in *inaddr = (struct sockaddr_in*)addrs;\n            memcpy(inaddr, it->ai_addr, sizeof (struct sockaddr_in));\n            inaddr->sin_port = htons(port);\n            addrs++;\n            naddrs--;\n            nresults++;\n        }\n        if(naddrs && mode == DILL_IPADDR_IPV6 && it->ai_family == AF_INET6) {\n            struct sockaddr_in6 *inaddr = (struct sockaddr_in6*)addrs;\n            memcpy(inaddr, it->ai_addr, sizeof (struct sockaddr_in6));\n            inaddr->sin6_port = htons(port);\n            addrs++;\n            naddrs--;\n            nresults++;\n        }\n        free(it);\n    }\n    dns_ai_close(ai);\n    return nresults;\n}\n\nint dill_ipaddr_equal(const struct dill_ipaddr *addr1,\n      const struct dill_ipaddr *addr2, int ignore_port) {\n    if(dill_ipaddr_family(addr1) != dill_ipaddr_family(addr2)) return 0;\n    switch(dill_ipaddr_family(addr1)) {\n    case AF_INET:;\n        struct sockaddr_in *inaddr1 = (struct sockaddr_in*)addr1;\n        struct sockaddr_in *inaddr2 = (struct sockaddr_in*)addr2;\n        if(inaddr1->sin_addr.s_addr != inaddr2->sin_addr.s_addr) return 0;\n        if(!ignore_port && inaddr1->sin_port != inaddr2->sin_port) return 0;\n        break;\n    case AF_INET6:;\n        struct sockaddr_in6 *in6addr1 = (struct sockaddr_in6*)addr1;\n        struct sockaddr_in6 *in6addr2 = (struct sockaddr_in6*)addr2;\n        if(memcmp(&in6addr1->sin6_addr.s6_addr,\n              &in6addr2->sin6_addr.s6_addr,\n              sizeof(in6addr1->sin6_addr.s6_addr)) != 0)\n            return 0;\n        if(!ignore_port && in6addr1->sin6_port != in6addr2->sin6_port) return 0;\n        break;\n    default:\n        dill_assert(0);\n    }\n    return 1;\n}\n\n"
        },
        {
          "name": "ipc.c",
          "type": "blob",
          "size": 19.841796875,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/un.h>\n#include <unistd.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"fd.h\"\n#include \"utils.h\"\n\nstatic int dill_ipc_resolve(const char *addr, struct sockaddr_un *su);\n\ndill_unique_id(dill_ipc_listener_type);\ndill_unique_id(dill_ipc_type);\n\n/******************************************************************************/\n/*  UNIX connection socket                                                    */\n/******************************************************************************/\n\nstatic void *dill_ipc_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_ipc_hclose(struct dill_hvfs *hvfs);\nstatic int dill_ipc_bsendl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic int dill_ipc_brecvl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_ipc_conn {\n    struct dill_hvfs hvfs;\n    struct dill_bsock_vfs bvfs;\n    int fd;\n    struct dill_fd_rxbuf rxbuf;\n    unsigned int scm_rights : 1;\n    unsigned int rbusy : 1;\n    unsigned int sbusy : 1;\n    unsigned int indone : 1;\n    unsigned int outdone : 1;\n    unsigned int inerr : 1;\n    unsigned int outerr : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_ipc_conn, dill_ipc_storage)\n\nstatic int dill_ipc_makeconn(int fd, void *mem) {\n    /* Create the object. */\n    struct dill_ipc_conn *self = (struct dill_ipc_conn*)mem;\n    self->hvfs.query = dill_ipc_hquery;\n    self->hvfs.close = dill_ipc_hclose;\n    self->bvfs.bsendl = dill_ipc_bsendl;\n    self->bvfs.brecvl = dill_ipc_brecvl;\n    self->fd = fd;\n    dill_fd_initrxbuf(&self->rxbuf);\n    self->scm_rights = 1;\n    self->rbusy = 0;\n    self->sbusy = 0;\n    self->indone = 0;\n    self->outdone = 0;\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Create the handle. */\n    return dill_hmake(&self->hvfs);\n}\n\nstatic void *dill_ipc_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_ipc_conn *self = (struct dill_ipc_conn*)hvfs;\n    if(type == dill_bsock_type) return &self->bvfs;\n    if(type == dill_ipc_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_ipc_fromfd_mem(int fd, struct dill_ipc_storage *mem) {\n    int err;\n    if(dill_slow(!mem || fd < 0)) {err = EINVAL; goto error1;}\n    /* Make sure that the supplied file descriptor is of correct type. */\n    int rc = dill_fd_check(fd, SOCK_STREAM, AF_UNIX, -1, 0);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Take ownership of the file descriptor. */\n    fd = dill_fd_own(fd);\n    if(dill_slow(fd < 0)) {err = errno; goto error1;}\n    /* Set the socket to non-blocking mode */\n    rc = dill_fd_unblock(fd);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Create the handle */\n    int h = dill_ipc_makeconn(fd, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error1;}\n    /* Return the handle */\n    return h;\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_fromfd(int fd) {\n    int err;\n    struct dill_ipc_conn *obj = malloc(sizeof(struct dill_ipc_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_ipc_fromfd_mem(fd, (struct dill_ipc_storage*)obj);\n    if (dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_connect_mem(const char *addr, struct dill_ipc_storage *mem,\n      int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Create a UNIX address out of the address string. */\n    struct sockaddr_un su;\n    int rc = dill_ipc_resolve(addr, &su);\n    if(rc < 0) {err = errno; goto error1;}\n    /* Open a socket. */\n    int s = socket(AF_UNIX, SOCK_STREAM, 0);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    rc = dill_fd_unblock(s);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Connect to the remote endpoint. */\n    rc = dill_fd_connect(s, (struct sockaddr*)&su, sizeof(su), deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Create the handle. */\n    int h = dill_ipc_makeconn(s, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    dill_fd_close(s);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_connect(const char *addr, int64_t deadline) {\n    int err;\n    struct dill_ipc_conn *obj = malloc(sizeof(struct dill_ipc_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_ipc_connect_mem(addr, (struct dill_ipc_storage*)obj, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic int dill_ipc_bsendl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ipc_conn *self = dill_cont(bvfs, struct dill_ipc_conn, bvfs);\n    if(dill_slow(self->sbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    self->sbusy = 1;\n    ssize_t sz = dill_fd_send(self->fd, first, last, deadline);\n    self->sbusy = 0;\n    if(dill_fast(sz >= 0)) return sz;\n    self->outerr = 1;\n    return -1;\n}\n\nstatic int dill_ipc_brecvl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ipc_conn *self = dill_cont(bvfs, struct dill_ipc_conn, bvfs);\n    if(dill_slow(self->rbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->indone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    self->rbusy = 1;\n    /* If we want to use SCM_RIGHTS we can't do rx buffering. */\n    int rc = dill_fd_recv(self->fd, self->scm_rights ? NULL : &self->rxbuf,\n        first, last, deadline);\n    self->rbusy = 0;\n    if(dill_fast(rc == 0)) return 0;\n    if(errno == EPIPE) self->indone = 1;\n    else self->inerr = 1;\n    return -1;\n}\n\nint dill_ipc_sendfd(int s, int fd, int64_t deadline) {\n    struct dill_ipc_conn *self = dill_hquery(s, dill_ipc_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(!self->scm_rights)) {errno = ENOTSUP; return -1;}\n    if(dill_slow(fd < 0)) {errno = EINVAL; return -1;}\n    if(dill_slow(self->sbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    struct iovec iov;\n    unsigned char buf[] = {0xcc};\n    iov.iov_base = buf;\n    iov.iov_len = 1;\n    struct msghdr msg;\n    memset(&msg, 0, sizeof (msg));\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    char control [sizeof(struct cmsghdr) + 10];\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n    struct cmsghdr *cmsg;\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    *((int*)CMSG_DATA(cmsg)) = fd;\n    msg.msg_controllen = cmsg->cmsg_len;\n    int rc = dill_fdout(self->fd, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    ssize_t sz = sendmsg(self->fd, &msg, 0);\n    if(dill_slow(sz == 0)) {self->outdone = 1; errno = EPIPE; return -1;}\n    if(dill_slow(sz < 0)) {\n       if(errno == ECONNRESET) {self->outerr = 1; return -1;}\n       dill_assert(0);\n    }\n    return 0;\n}\n\nint dill_ipc_recvfd(int s, int64_t deadline) {\n    struct dill_ipc_conn *self = dill_hquery(s, dill_ipc_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(!self->scm_rights)) {errno = ENOTSUP; return -1;}\n    if(dill_slow(self->rbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->indone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    char buf[1];\n    struct iovec iov;\n    iov.iov_base = buf;\n    iov.iov_len = sizeof(buf);\n    struct msghdr msg;\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    unsigned char control[1024];\n    msg.msg_control = control;\n    msg.msg_controllen = sizeof(control);\n    int rc = dill_fdin(self->fd, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    ssize_t sz = recvmsg(self->fd, &msg, 0);\n    if(dill_slow(sz == 0)) {self->indone = 1; errno = EPIPE; return -1;}\n    if(dill_slow(sz < 0)) {\n       if(errno == ECONNRESET) {self->outerr = 1; return -1;}\n       dill_assert(0);\n    }\n    /* Loop over the auxiliary data to find the embedded file descriptor. */\n    int fd = -1;\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);\n    while(cmsg) {\n        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type  == SCM_RIGHTS) {\n            fd = *(int*)CMSG_DATA(cmsg);\n            break;\n        }\n        cmsg = CMSG_NXTHDR(&msg, cmsg);\n    }\n    if(dill_slow(fd < 0)) {self->inerr = 1; errno = EPROTO; return -1;}\n    return fd;\n}\n\nint dill_ipc_done(int s, int64_t deadline) {\n    struct dill_ipc_conn *self = dill_hquery(s, dill_ipc_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    /* Shutdown is done asynchronously on kernel level.\n       No need to use the deadline. */\n    int rc = shutdown(self->fd, SHUT_WR);\n    if(dill_slow(rc < 0)) {\n        if(errno == ENOTCONN) {self->outerr = 1; errno = ECONNRESET; return -1;}\n        if(errno == ENOBUFS) {self->outerr = 1; errno = ENOMEM; return -1;}\n        dill_assert(0);\n    }\n    self->outdone = 1;\n    return 0;\n}\n\nint dill_ipc_close(int s, int64_t deadline) {\n    int err;\n    /* Listener socket needs no special treatment. */\n    if(dill_hquery(s, dill_ipc_listener_type)) {\n        return dill_hclose(s);\n    }\n    struct dill_ipc_conn *self = dill_hquery(s, dill_ipc_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->inerr || self->outerr)) {err = ECONNRESET; goto error;}\n    /* If not done already, flush the outbound data and start the terminal\n       handshake. */\n    if(!self->outdone) {\n        int rc = dill_ipc_done(s, deadline);\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n    }\n    /* Now we are going to read all the inbound data until we reach end of the\n       stream. That way we can be sure that the peer either received all our\n       data or consciously closed the connection without reading all of it. */\n    int rc = dill_ipc_brecvl(&self->bvfs, NULL, NULL, deadline);\n    dill_assert(rc < 0);\n    if(dill_slow(errno != EPIPE)) {err = errno; goto error;}\n    dill_ipc_hclose(&self->hvfs);\n    return 0;\nerror:\n    dill_ipc_hclose(&self->hvfs);\n    errno = err;\n    return -1;\n}\n\nstatic void dill_ipc_hclose(struct dill_hvfs *hvfs) {\n    struct dill_ipc_conn *self = (struct dill_ipc_conn*)hvfs;\n    dill_fd_close(self->fd);\n    dill_fd_termrxbuf(&self->rxbuf);\n    if(!self->mem) free(self);\n}\n\n/******************************************************************************/\n/*  UNIX listener socket                                                      */\n/******************************************************************************/\n\nstatic void *dill_ipc_listener_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_ipc_listener_hclose(struct dill_hvfs *hvfs);\n\nstruct dill_ipc_listener {\n    struct dill_hvfs hvfs;\n    int fd;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_ipc_listener, dill_ipc_listener_storage)\n\nstatic void *dill_ipc_listener_hquery(struct dill_hvfs *hvfs,\n      const void *type) {\n    struct dill_ipc_listener *self = (struct dill_ipc_listener*)hvfs;\n    if(type == dill_ipc_listener_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nstatic int dill_ipc_makelistener(int fd,\n      struct dill_ipc_listener_storage *mem) {\n    /* Create the object. */\n    struct dill_ipc_listener *self = (struct dill_ipc_listener*)mem;\n    self->hvfs.query = dill_ipc_listener_hquery;\n    self->hvfs.close = dill_ipc_listener_hclose;\n    self->fd = fd;\n    self->mem = 1;\n    /* Create the handle. */\n    return dill_hmake(&self->hvfs);\n}\n\nint dill_ipc_listener_fromfd(int fd) {\n    int err;\n    struct dill_ipc_listener *obj = malloc(sizeof(struct dill_ipc_listener));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_ipc_listener_fromfd_mem(fd,\n        (struct dill_ipc_listener_storage*)obj);\n    if (dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_listener_fromfd_mem(int fd,\n      struct dill_ipc_listener_storage *mem) {\n    int err;\n    if(dill_slow(!mem || fd < 0)) {err = EINVAL; goto error1;}\n    /* Make sure that the supplied file descriptor is of correct type. */\n    int rc = dill_fd_check(fd, SOCK_STREAM, AF_UNIX, -1, 1);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Take ownership of the file descriptor. */\n    fd = dill_fd_own(fd);\n    if(dill_slow(fd < 0)) {err = errno; goto error1;}\n    /* Set the socket to non-blocking mode */\n    rc = dill_fd_unblock(fd);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Create the handle */\n    int h = dill_ipc_makelistener(fd, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error1;}\n    /* Return the handle */\n    return h;\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_listen_mem(const char *addr, int backlog,\n      struct dill_ipc_listener_storage *mem) {\n    int err;\n    /* Create a UNIX address out of the address string. */\n    struct sockaddr_un su;\n    int rc = dill_ipc_resolve(addr, &su);\n    if(rc < 0) {err = errno; goto error1;}\n    /* Open the listening socket. */\n    int s = socket(AF_UNIX, SOCK_STREAM, 0);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    rc = dill_fd_unblock(s);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Start listening for incoming connections. */\n    rc = bind(s, (struct sockaddr*)&su, sizeof(su));\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    rc = listen(s, backlog);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    int h = dill_ipc_makelistener(s, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    close(s);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_listen(const char *addr, int backlog) {\n    int err;\n    struct dill_ipc_listener *obj = malloc(sizeof(struct dill_ipc_listener));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int ls = dill_ipc_listen_mem(addr, backlog,\n        (struct dill_ipc_listener_storage*)obj);\n    if(dill_slow(ls < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return ls;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_accept_mem(int s, struct dill_ipc_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Retrieve the listener object. */\n    struct dill_ipc_listener *lst = dill_hquery(s, dill_ipc_listener_type);\n    if(dill_slow(!lst)) {err = errno; goto error1;}\n    /* Try to get new connection in a non-blocking way. */\n    int as = dill_fd_accept(lst->fd, NULL, NULL, deadline);\n    if(dill_slow(as < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    int rc = dill_fd_unblock(as);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Create the handle. */\n    int h = dill_ipc_makeconn(as, (struct dill_ipc_conn*)mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    dill_fd_close(as);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_accept(int s, int64_t deadline) {\n    int err;\n    struct dill_ipc_conn *obj = malloc(sizeof(struct dill_ipc_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int as = dill_ipc_accept_mem(s, (struct dill_ipc_storage*)obj, deadline);\n    if(dill_slow(as < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return as;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic void dill_ipc_listener_hclose(struct dill_hvfs *hvfs) {\n    struct dill_ipc_listener *self = (struct dill_ipc_listener*)hvfs;\n    dill_fd_close(self->fd);\n    if(!self->mem) free(self);\n}\n\n/******************************************************************************/\n/*  UNIX pair                                                                 */\n/******************************************************************************/\n\nint dill_ipc_pair_mem(struct dill_ipc_pair_storage *mem, int s[2]) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Create the pair. */\n    int fds[2];\n    int rc = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\n    if(rc < 0) {err = errno; goto error1;}\n    /* Set the sockets to non-blocking mode. */\n    rc = dill_fd_unblock(fds[0]);\n    if(dill_slow(rc < 0)) {err = errno; goto error3;}\n    rc = dill_fd_unblock(fds[1]);\n    if(dill_slow(rc < 0)) {err = errno; goto error3;}\n    /* Create the handles. */\n    struct dill_ipc_conn *conns = (struct dill_ipc_conn*)mem;\n    s[0] = dill_ipc_makeconn(fds[0], &conns[0]);\n    if(dill_slow(s[0] < 0)) {err = errno; goto error3;}\n    s[1] = dill_ipc_makeconn(fds[1], &conns[1]);\n    if(dill_slow(s[1] < 0)) {err = errno; goto error4;}\n    return 0;\nerror4:\n    rc = dill_hclose(s[0]);\n    goto error2;\nerror3:\n    dill_fd_close(fds[0]);\nerror2:\n    dill_fd_close(fds[1]);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_ipc_pair(int s[2]) {\n    int err;\n    /* Create the pair. */\n    int fds[2];\n    int rc = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\n    if(rc < 0) {err = errno; goto error1;}\n    /* Set the sockets to non-blocking mode. */\n    rc = dill_fd_unblock(fds[0]);\n    if(dill_slow(rc < 0)) {err = errno; goto error3;}\n    rc = dill_fd_unblock(fds[1]);\n    if(dill_slow(rc < 0)) {err = errno; goto error3;}\n    /* Allocate the memory. */\n    struct dill_ipc_conn *conn0 = malloc(sizeof(struct dill_ipc_conn));\n    if(dill_slow(!conn0)) {err = ENOMEM; goto error3;}\n    struct dill_ipc_conn *conn1 = malloc(sizeof(struct dill_ipc_conn));\n    if(dill_slow(!conn1)) {err = ENOMEM; goto error4;}\n    /* Create the handles. */\n    s[0] = dill_ipc_makeconn(fds[0], conn0);\n    if(dill_slow(s[0] < 0)) {err = errno; goto error5;}\n    conn0->mem = 0;\n    s[1] = dill_ipc_makeconn(fds[1], conn1);\n    if(dill_slow(s[1] < 0)) {err = errno; goto error6;}\n    conn1->mem = 0;\n    return 0;\nerror6:\n    rc = dill_hclose(s[0]);\n    goto error2;\nerror5:\n    free(conn1);\nerror4:\n    free(conn0);\nerror3:\n    dill_fd_close(fds[0]);\nerror2:\n    dill_fd_close(fds[1]);\nerror1:\n    errno = err;\n    return -1;\n}\n\n/******************************************************************************/\n/*  Helpers                                                                   */\n/******************************************************************************/\n\nstatic int dill_ipc_resolve(const char *addr, struct sockaddr_un *su) {\n    dill_assert(su);\n    if(strlen(addr) >= sizeof(su->sun_path)) {errno = ENAMETOOLONG; return -1;}\n    su->sun_family = AF_UNIX;\n    strncpy(su->sun_path, addr, sizeof(su->sun_path));\n    return 0;\n}\n\n"
        },
        {
          "name": "kqueue.c.inc",
          "type": "blob",
          "size": 10.1142578125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/event.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n#include \"pollset.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n#define DILL_ENDLIST 0xffffffff\n\n#define DILL_CHNGSSIZE 128\n#define DILL_EVSSIZE 128\n\n#define FDW_IN 1\n#define FDW_OUT 2\n\nstruct dill_fdinfo {\n    struct dill_fdclause *in;\n    struct dill_fdclause *out;\n    uint16_t currevs;\n    uint16_t firing;\n    /* 1-based index, 0 stands for \"not part of the list\", DILL_ENDLIST\n       stands for \"no more elements in the list. */\n    uint32_t next;\n    /* 1 if the file descriptor is cached. 0 otherwise. */\n    unsigned int cached : 1;\n};\n\nint dill_ctx_pollset_init(struct dill_ctx_pollset *ctx) {\n    int err;\n    /* Allocate one info per fd. */\n    ctx->nfdinfos = dill_maxfds();\n    ctx->fdinfos = calloc(ctx->nfdinfos, sizeof(struct dill_fdinfo));\n    if(dill_slow(!ctx->fdinfos)) {err = ENOMEM; goto error1;}\n    /* Changelist is empty. */\n    ctx->changelist = DILL_ENDLIST;\n    /* Create kernel-side pollset. */\n    ctx->kfd = kqueue();\n    if(dill_slow(ctx->kfd < 0)) {err = errno; goto error2;}\n    return 0;\nerror2:\n    free(ctx->fdinfos);\n    ctx->fdinfos = NULL;\nerror1:\n    errno = err;\n    return -1;\n}\n\nvoid dill_ctx_pollset_term(struct dill_ctx_pollset *ctx) {\n    /* Kqueue documentation says that a kqueue descriptor won't\n       survive a fork. However, implementations seem to disagree.\n       On FreeBSD the following function succeeds. On OSX it returns\n       EACCESS. Therefore we ignore the return value. */\n    close(ctx->kfd);\n    free(ctx->fdinfos);\n}\n\nstatic void dill_fdcancelin(struct dill_clause *cl) {\n    struct dill_fdinfo *fdinfo =\n        dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdinfo->in = NULL;\n    if(!fdinfo->next) {\n        struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n        fdinfo->next = ctx->changelist;\n        ctx->changelist = fdinfo - ctx->fdinfos + 1;\n    }\n}\n\nstatic void dill_fdcancelout(struct dill_clause *cl) {\n    struct dill_fdinfo *fdinfo =\n        dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdinfo->out = NULL;\n    if(!fdinfo->next) {\n        struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n        fdinfo->next = ctx->changelist;\n        ctx->changelist = fdinfo - ctx->fdinfos + 1;\n    }\n}\n\nint dill_pollset_in(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    /* If not yet cached, check whether fd exists and if so add it\n       to pollset. */\n    if(dill_slow(!fdi->cached)) {\n        struct kevent ev;\n        EV_SET(&ev, fd, EVFILT_READ, EV_ADD, 0, 0, 0);\n        int rc = kevent(ctx->kfd, &ev, 1, NULL, 0, NULL);\n        if(dill_slow(rc < 0 && errno == EBADF)) return -1;\n        dill_assert(rc >= 0);\n        fdi->in = NULL;\n        fdi->out = NULL;\n        fdi->currevs = FDW_IN;\n        fdi->firing = 0;\n        fdi->next = 0;\n        fdi->cached = 1;\n    }\n    if(dill_slow(fdi->in)) {errno = EBUSY; return -1;}\n    /* If fd is not yet in the pollset, add it there. */\n    else if(!fdi->next) {\n        fdi->next = ctx->changelist;\n        ctx->changelist = fd + 1;\n    }\n    fdcl->fdinfo = fdi;\n    fdi->in = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelin);\n    return 0;\n}\n\nint dill_pollset_out(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    /* If not yet cached, check whether the fd exists and if it does,\n       add it to the pollset. */    \n    if(dill_slow(!fdi->cached)) {\n        struct kevent ev;\n        EV_SET(&ev, fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);\n        int rc = kevent(ctx->kfd, &ev, 1, NULL, 0, NULL);\n        if(dill_slow(rc < 0 && errno == EBADF)) return -1;\n        dill_assert(rc >= 0);\n        fdi->in = NULL;\n        fdi->out = NULL;\n        fdi->currevs = FDW_OUT;\n        fdi->firing = 0;\n        fdi->next = 0;\n        fdi->cached = 1;\n    }\n    if(dill_slow(fdi->out)) {errno = EBUSY; return -1;}\n    /* If the fd is not yet in the pollset, add it there. */\n    else if(!fdi->next) {\n        fdi->next = ctx->changelist;\n        ctx->changelist = fd + 1;\n    }\n    fdcl->fdinfo = fdi;\n    fdi->out = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelout);\n    return 0;\n}\n\nint dill_pollset_clean(int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    if(!fdi->cached) return 0;\n    /* We cannot clean an fd that someone is waiting for. */\n    if(dill_slow(fdi->in || fdi->out)) {errno = EBUSY; return -1;}\n    /* Remove the file descriptor from the pollset if it is still there. */\n    int nevs = 0;\n    struct kevent evs[2];\n    if(fdi->currevs & FDW_IN) {\n        EV_SET(&evs[nevs], fd, EVFILT_READ, EV_DELETE, 0, 0, 0);\n        ++nevs;\n    }\n    if(fdi->currevs & FDW_OUT) {\n        EV_SET(&evs[nevs], fd, EVFILT_WRITE, EV_DELETE, 0, 0, 0);\n        ++nevs;\n    }\n    if(nevs) {\n        int rc = kevent(ctx->kfd, evs, nevs, NULL, 0, NULL);\n        dill_assert(rc != -1);\n    }\n    fdi->currevs = 0;\n    /* If needed, remove the fd from the changelist. */\n    if(fdi->next) {\n        uint32_t *pidx = &ctx->changelist;\n        while(1) {\n            dill_assert(*pidx != 0 && *pidx != DILL_ENDLIST);\n            if(*pidx - 1 == fd) break;\n            pidx = &ctx->fdinfos[*pidx - 1].next;\n        }\n        *pidx = fdi->next;\n        fdi->next = 0;\n    }\n    /* Mark the fd as not used. */\n    fdi->cached = 0;\n    return 0;\n}\n\nint dill_pollset_poll(int timeout) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    /* Apply any changes to the pollset. */\n    struct kevent chngs[DILL_CHNGSSIZE];\n    int nchngs = 0;\n    while(ctx->changelist != DILL_ENDLIST) {\n        /* Flush the changes to the pollset even if there is one empty entry\n           left in the changeset. That way, we make sure that both in & out\n           associated with the next file descriptor can be filled in if we\n           choose not to flush the changes yet. */\n        if(nchngs >= DILL_CHNGSSIZE - 1) {\n            int rc = kevent(ctx->kfd, chngs, nchngs, NULL, 0, NULL);\n            dill_assert(rc != -1);\n            nchngs = 0;\n        }\n        int fd = ctx->changelist - 1;\n        struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n        if(fdi->in) {\n            if(!(fdi->currevs & FDW_IN)) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_READ, EV_ADD, 0, 0, 0);\n                fdi->currevs |= FDW_IN;\n                ++nchngs;\n            }\n        }\n        else {\n            if(fdi->currevs & FDW_IN) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_READ, EV_DELETE, 0, 0, 0);\n                fdi->currevs &= ~FDW_IN;\n                ++nchngs;\n            }\n        }\n        if(fdi->out) {\n            if(!(fdi->currevs & FDW_OUT)) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);\n                fdi->currevs |= FDW_OUT;\n                ++nchngs;\n           }\n        }\n        else {\n            if(fdi->currevs & FDW_OUT) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_WRITE, EV_DELETE, 0, 0, 0);\n                fdi->currevs &= ~FDW_OUT;\n                ++nchngs;\n            }\n        }\n        fdi->firing = 0;\n        ctx->changelist = fdi->next;\n        fdi->next = 0;\n    }\n    /* Wait for events. */\n    struct kevent evs[DILL_EVSSIZE];\n    struct timespec ts;\n    if(timeout >= 0) {\n        ts.tv_sec = timeout / 1000;\n        ts.tv_nsec = (((long)timeout) % 1000) * 1000000;\n    }\n    int nevs = kevent(ctx->kfd, chngs, nchngs, evs, DILL_EVSSIZE,\n        timeout < 0 ? NULL : &ts);\n    if(nevs < 0 && errno == EINTR) return -1;\n    dill_assert(nevs >= 0);\n    /* Join events on file descriptor basis.\n       Put all the firing fds into the changelist. */\n    int i;\n    for(i = 0; i != nevs; ++i) {\n        dill_assert(evs[i].flags != EV_ERROR);\n        int fd = (int)evs[i].ident;\n        struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n        /* Add firing event to the result list. */\n        if(evs[i].flags == EV_EOF)\n            fdi->firing |= (FDW_IN | FDW_OUT);\n        else {\n            if(evs[i].filter == EVFILT_READ)\n                fdi->firing |= FDW_IN;\n            if(evs[i].filter == EVFILT_WRITE)\n                fdi->firing |= FDW_OUT;\n        }\n        if(!fdi->next) {\n            fdi->next = ctx->changelist;\n            ctx->changelist = fd + 1;\n        }\n    }\n    /* Resume blocked coroutines. */\n    uint32_t chl = ctx->changelist;\n    while(chl != DILL_ENDLIST) {\n        int fd = chl - 1;\n        struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n        if(fdi->in && (fdi->firing & FDW_IN))\n            dill_trigger(&fdi->in->cl, 0);\n        if(fdi->out && (fdi->firing & FDW_OUT))\n            dill_trigger(&fdi->out->cl, 0);\n        fdi->firing = 0;\n        chl = fdi->next;\n    }    \n    /* Return 0 on timeout or 1 if at least one coroutine was resumed. */\n    return nevs > 0 ? 1 : 0;\n}\n\n"
        },
        {
          "name": "kqueue.h.inc",
          "type": "blob",
          "size": 1.388671875,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_KQUEUE_INCLUDED\n#define DILL_KQUEUE_INCLUDED\n\n#include \"cr.h\"\n#include \"list.h\"\n\nstruct dill_fdinfo;\n\nstruct dill_fdclause {\n   struct dill_clause cl;\n   struct dill_fdinfo *fdinfo;\n};\n\nstruct dill_ctx_pollset {\n    int kfd;\n    int nfdinfos;\n    struct dill_fdinfo *fdinfos;\n    uint32_t changelist;\n};\n\n#endif\n"
        },
        {
          "name": "libdill.c",
          "type": "blob",
          "size": 2.6953125,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stdint.h>\n\n#include \"cr.h\"\n#include \"pollset.h\"\n#include \"utils.h\"\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n\nint dill_msleep(int64_t deadline) {\n    /* Return ECANCELED if shutting down. */\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Actual waiting. */\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 1, deadline);\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    return 0;\n}\n\nint dill_fdin(int fd, int64_t deadline) {\n    /* Return ECANCELED if shutting down. */\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Start waiting for the fd. */\n    struct dill_fdclause fdcl;\n    rc = dill_pollset_in(&fdcl, 1, fd);\n    if(dill_slow(rc < 0)) return -1;\n    /* Optionally, start waiting for a timer. */\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 2, deadline);\n    /* Block. */\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == 2)) {errno = ETIMEDOUT; return -1;}\n    return 0;\n}\n\nint dill_fdout(int fd, int64_t deadline) {\n    /* Return ECANCELED if shutting down. */\n    int rc = dill_canblock();\n    if(dill_slow(rc < 0)) return -1;\n    /* Start waiting for the fd. */\n    struct dill_fdclause fdcl;\n    rc = dill_pollset_out(&fdcl, 1, fd);\n    if(dill_slow(rc < 0)) return -1;\n    /* Optionally, start waiting for a timer. */\n    struct dill_tmclause tmcl;\n    dill_timer(&tmcl, 2, deadline);\n    /* Block. */\n    int id = dill_wait();\n    if(dill_slow(id < 0)) return -1;\n    if(dill_slow(id == 2)) {errno = ETIMEDOUT; return -1;}\n    return 0;\n}\n\nint dill_fdclean(int fd) {\n    return dill_pollset_clean(fd);\n}\n\n"
        },
        {
          "name": "libdill.h",
          "type": "blob",
          "size": 34.375,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef LIBDILL_H_INCLUDED\n#define LIBDILL_H_INCLUDED\n\n#include <errno.h>\n#include <setjmp.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#if defined __linux__\n#include <alloca.h>\n#endif\n\n/******************************************************************************/\n/*  ABI versioning support                                                    */\n/******************************************************************************/\n\n/*  Don't change this unless you know exactly what you're doing and have      */\n/*  read and understood the following documents:                              */\n/*  www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html     */\n/*  www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html  */\n\n/*  The current interface version. */\n#define DILL_VERSION_CURRENT 25\n\n/*  The latest revision of the current interface. */\n#define DILL_VERSION_REVISION 0\n\n/*  How many past interface versions are still supported. */\n#define DILL_VERSION_AGE 5\n\n/******************************************************************************/\n/*  Symbol visibility                                                         */\n/******************************************************************************/\n\n#if !defined __GNUC__ && !defined __clang__\n#error \"Unsupported compiler!\"\n#endif\n\n#if DILL_NO_EXPORTS\n#define DILL_EXPORT\n#else\n#define DILL_EXPORT __attribute__ ((visibility(\"default\")))\n#endif\n\n/* Old versions of GCC don't support visibility attribute. */\n#if defined __GNUC__ && __GNUC__ < 4\n#undef DILL_EXPORT\n#define DILL_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************/\n/*  Memory alignment                                                          */\n/******************************************************************************/\n\n/* Opaque structures will violate alignments and cause crashes on certain\n   architectures\n */\n\n#if (defined __arm__) || (defined __thumb__)\n#define DILL_ALIGN __attribute__ ((aligned(__SIZEOF_POINTER__)))\n#else\n#define DILL_ALIGN\n#endif\n\n/******************************************************************************/\n/*  Helpers                                                                   */\n/******************************************************************************/\n\nDILL_EXPORT int dill_fdclean(int fd);\nDILL_EXPORT int dill_fdin(int fd, int64_t deadline);\nDILL_EXPORT int dill_fdout(int fd, int64_t deadline);\nDILL_EXPORT int64_t dill_now(void);\nDILL_EXPORT int dill_msleep(int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define fdclean dill_fdclean\n#define fdin dill_fdin\n#define fdout dill_fdout\n#define now dill_now\n#define msleep dill_msleep\n#endif\n\n/******************************************************************************/\n/*  Handles                                                                   */\n/******************************************************************************/\n\nDILL_EXPORT int dill_hown(int h);\nDILL_EXPORT int dill_hclose(int h);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define hown dill_hown\n#define hclose dill_hclose\n#endif\n\n/******************************************************************************/\n/*  Coroutines                                                                */\n/******************************************************************************/\n\n#define dill_coroutine __attribute__((noinline))\n\nDILL_EXPORT extern volatile void *dill_unoptimisable;\n\nDILL_EXPORT __attribute__((noinline)) int dill_prologue(sigjmp_buf **ctx,\n    void **ptr, size_t len, int bndl, const char *file, int line);\nDILL_EXPORT __attribute__((noinline)) void dill_epilogue(void);\n\n/* The following macros use alloca(sizeof(size_t)) because clang\n   doesn't support alloca with size zero. */\n\n/* This assembly setjmp/longjmp mechanism is in the same order as glibc and\n   musl, but glibc implements pointer mangling, which is hard to support.\n   This should be binary-compatible with musl, though. */\n\n/* Stack-switching on X86-64. */\n#if defined(__x86_64__) && !defined DILL_ARCH_FALLBACK\n#define dill_setjmp(ctx) __extension__ ({\\\n    int ret;\\\n    asm(\"lea     LJMPRET%=(%%rip), %%rcx\\n\\t\"\\\n        \"xor     %%rax, %%rax\\n\\t\"\\\n        \"mov     %%rbx, (%%rdx)\\n\\t\"\\\n        \"mov     %%rbp, 8(%%rdx)\\n\\t\"\\\n        \"mov     %%r12, 16(%%rdx)\\n\\t\"\\\n        \"mov     %%r13, 24(%%rdx)\\n\\t\"\\\n        \"mov     %%r14, 32(%%rdx)\\n\\t\"\\\n        \"mov     %%r15, 40(%%rdx)\\n\\t\"\\\n        \"mov     %%rsp, 48(%%rdx)\\n\\t\"\\\n        \"mov     %%rcx, 56(%%rdx)\\n\\t\"\\\n        \"LJMPRET%=:\\n\\t\"\\\n        : \"=a\" (ret)\\\n        : \"d\" (ctx)\\\n        : \"memory\", \"rcx\", \"rsi\", \"rdi\", \"r8\", \"r9\", \"r10\", \"r11\", \"cc\");\\\n    ret;\\\n})\n#define dill_longjmp(ctx) \\\n    asm(\"movq   56(%%rdx), %%rcx\\n\\t\"\\\n        \"movq   48(%%rdx), %%rsp\\n\\t\"\\\n        \"movq   40(%%rdx), %%r15\\n\\t\"\\\n        \"movq   32(%%rdx), %%r14\\n\\t\"\\\n        \"movq   24(%%rdx), %%r13\\n\\t\"\\\n        \"movq   16(%%rdx), %%r12\\n\\t\"\\\n        \"movq   8(%%rdx), %%rbp\\n\\t\"\\\n        \"movq   (%%rdx), %%rbx\\n\\t\"\\\n        \".cfi_def_cfa %%rdx, 0 \\n\\t\"\\\n        \".cfi_offset %%rbx, 0 \\n\\t\"\\\n        \".cfi_offset %%rbp, 8 \\n\\t\"\\\n        \".cfi_offset %%r12, 16 \\n\\t\"\\\n        \".cfi_offset %%r13, 24 \\n\\t\"\\\n        \".cfi_offset %%r14, 32 \\n\\t\"\\\n        \".cfi_offset %%r15, 40 \\n\\t\"\\\n        \".cfi_offset %%rsp, 48 \\n\\t\"\\\n        \".cfi_offset %%rip, 56 \\n\\t\"\\\n        \"jmp    *%%rcx\\n\\t\"\\\n        : : \"d\" (ctx), \"a\" (1))\n#define dill_setsp(x) \\\n    asm(\"\"::\"r\"(alloca(sizeof(size_t))));\\\n    asm volatile(\"leaq (%%rax), %%rsp\"::\"rax\"(x));\n\n/* Stack switching on X86. */\n#elif defined(__i386__) && !defined DILL_ARCH_FALLBACK\n#define dill_setjmp(ctx) __extension__ ({\\\n    int ret;\\\n    asm(\"movl   $LJMPRET%=, %%ecx\\n\\t\"\\\n        \"movl   %%ebx, (%%edx)\\n\\t\"\\\n        \"movl   %%esi, 4(%%edx)\\n\\t\"\\\n        \"movl   %%edi, 8(%%edx)\\n\\t\"\\\n        \"movl   %%ebp, 12(%%edx)\\n\\t\"\\\n        \"movl   %%esp, 16(%%edx)\\n\\t\"\\\n        \"movl   %%ecx, 20(%%edx)\\n\\t\"\\\n        \"xorl   %%eax, %%eax\\n\\t\"\\\n        \"LJMPRET%=:\\n\\t\"\\\n        : \"=a\" (ret) : \"d\" (ctx) : \"memory\");\\\n    ret;\\\n})\n#define dill_longjmp(ctx) \\\n    asm(\"movl   (%%edx), %%ebx\\n\\t\"\\\n        \"movl   4(%%edx), %%esi\\n\\t\"\\\n        \"movl   8(%%edx), %%edi\\n\\t\"\\\n        \"movl   12(%%edx), %%ebp\\n\\t\"\\\n        \"movl   16(%%edx), %%esp\\n\\t\"\\\n        \"movl   20(%%edx), %%ecx\\n\\t\"\\\n        \".cfi_def_cfa %%edx, 0 \\n\\t\"\\\n        \".cfi_offset %%ebx, 0 \\n\\t\"\\\n        \".cfi_offset %%esi, 4 \\n\\t\"\\\n        \".cfi_offset %%edi, 8 \\n\\t\"\\\n        \".cfi_offset %%ebp, 12 \\n\\t\"\\\n        \".cfi_offset %%esp, 16 \\n\\t\"\\\n        \".cfi_offset %%eip, 20 \\n\\t\"\\\n        \"jmp    *%%ecx\\n\\t\"\\\n        : : \"d\" (ctx), \"a\" (1))\n#define dill_setsp(x) \\\n    asm(\"\"::\"r\"(alloca(sizeof(size_t))));\\\n    asm volatile(\"leal (%%eax), %%esp\"::\"eax\"(x));\n\n/* Stack-switching on other microarchitectures. */\n#else\n#define dill_setjmp(ctx) sigsetjmp(ctx, 0)\n#define dill_longjmp(ctx) siglongjmp(ctx, 1)\n/* For newer GCCs, -fstack-protector breaks on this; use -fno-stack-protector.\n   Alternatively, implement a custom dill_setsp for your microarchitecture. */\n#define dill_setsp(x) \\\n    dill_unoptimisable = alloca((char*)alloca(sizeof(size_t)) - (char*)(x));\n#endif\n\n/* Statement expressions are a gcc-ism but they are also supported by clang.\n   Given that there's no other way to do this, screw other compilers for now.\n   See https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Statement-Exprs.html */\n\n/* A bug in gcc have been observed where name clash between variable in the\n   outer scope and a local variable in this macro causes the variable to\n   get weird values. To avoid that, we use fancy names (dill_*__). */ \n\n#define dill_go_(fn, ptr, len, bndl) \\\n    __extension__ ({\\\n        sigjmp_buf *dill_ctx__;\\\n        void *dill_stk__ = (ptr);\\\n        int dill_handle__ = dill_prologue(&dill_ctx__, &dill_stk__, (len),\\\n            (bndl), __FILE__, __LINE__);\\\n        if(dill_handle__ >= 0) {\\\n            if(!dill_setjmp(*dill_ctx__)) {\\\n                dill_setsp(dill_stk__);\\\n                fn;\\\n                dill_epilogue();\\\n            }\\\n        }\\\n        dill_handle__;\\\n    })\n\n#define dill_go(fn) dill_go_(fn, NULL, 0, -1)\n#define dill_go_mem(fn, ptr, len) dill_go_(fn, ptr, len, -1)\n\n#define dill_bundle_go(bndl, fn) dill_go_(fn, NULL, 0, bndl)\n#define dill_bundle_go_mem(bndl, fn, ptr, len) dill_go_(fn, ptr, len, bndl)\n\nstruct dill_bundle_storage {char _[64];} DILL_ALIGN;\n\nDILL_EXPORT int dill_bundle(void);\nDILL_EXPORT int dill_bundle_mem(struct dill_bundle_storage *mem);\nDILL_EXPORT int dill_bundle_wait(int h, int64_t deadline);\nDILL_EXPORT int dill_yield(void);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define coroutine dill_coroutine\n#define go dill_go\n#define go_mem dill_go_mem\n#define bundle_go dill_bundle_go\n#define bundle_go_mem dill_bundle_go_mem\n#define bundle_storage dill_bundle_storage\n#define bundle dill_bundle\n#define bundle_mem dill_bundle_mem\n#define bundle_wait dill_bundle_wait\n#define yield dill_yield\n#endif\n\n/******************************************************************************/\n/*  Channels                                                                  */\n/******************************************************************************/\n\n#define DILL_CHSEND 1\n#define DILL_CHRECV 2\n\nstruct dill_chclause {\n    int op;\n    int ch;\n    void *val;\n    size_t len;\n};\n\nstruct dill_chstorage {char _[144];} DILL_ALIGN;\n\nDILL_EXPORT int dill_chmake(\n    int chv[2]);\nDILL_EXPORT int dill_chmake_mem(\n    struct dill_chstorage *mem,\n    int chv[2]);\nDILL_EXPORT int dill_chsend(\n    int ch,\n    const void *val,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_chrecv(\n    int ch,\n    void *val,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_chdone(\n    int ch);\nDILL_EXPORT int dill_choose(\n    struct dill_chclause *clauses,\n    int nclauses,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define CHSEND DILL_CHSEND\n#define CHRECV DILL_CHRECV\n#define chclause dill_chclause\n#define chstorage dill_chstorage\n#define chmake dill_chmake\n#define chmake_mem dill_chmake_mem\n#define chsend dill_chsend\n#define chrecv dill_chrecv\n#define chdone dill_chdone\n#define choose dill_choose\n#endif\n\n#if !defined DILL_DISABLE_SOCKETS\n\n/******************************************************************************/\n/*  Gather/scatter list.                                                      */\n/******************************************************************************/\n\nstruct dill_iolist {\n    void *iol_base;\n    size_t iol_len;\n    struct dill_iolist *iol_next;\n    int iol_rsvd;\n};\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define iolist dill_iolist\n#endif\n\n/******************************************************************************/\n/*  Bytestream sockets.                                                       */\n/******************************************************************************/\n\nDILL_EXPORT int dill_bsend(\n    int s,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_brecv(\n    int s,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_bsendl(\n    int s,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nDILL_EXPORT int dill_brecvl(\n    int s,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define bsend dill_bsend\n#define brecv dill_brecv\n#define bsendl dill_bsendl\n#define brecvl dill_brecvl\n#endif\n\n/******************************************************************************/\n/*  Message sockets.                                                          */\n/******************************************************************************/\n\nDILL_EXPORT int dill_msend(\n    int s,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT ssize_t dill_mrecv(\n    int s,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_msendl(\n    int s,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nDILL_EXPORT ssize_t dill_mrecvl(\n    int s,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define msend dill_msend\n#define mrecv dill_mrecv\n#define msendl dill_msendl\n#define mrecvl dill_mrecvl\n#endif\n\n/******************************************************************************/\n/*  IP address resolution.                                                    */\n/******************************************************************************/\n\nstruct sockaddr;\n\n#define DILL_IPADDR_IPV4 1\n#define DILL_IPADDR_IPV6 2\n#define DILL_IPADDR_PREF_IPV4 3\n#define DILL_IPADDR_PREF_IPV6 4\n#define DILL_IPADDR_MAXSTRLEN 46\n\nstruct dill_ipaddr {char _[32];};\n\nDILL_EXPORT int dill_ipaddr_local(\n    struct dill_ipaddr *addr,\n    const char *name,\n    int port,\n    int mode);\nDILL_EXPORT int dill_ipaddr_remote(\n    struct dill_ipaddr *addr,\n    const char *name,\n    int port,\n    int mode,\n    int64_t deadline);\nDILL_EXPORT int dill_ipaddr_remotes(\n    struct dill_ipaddr *addrs,\n    int naddrs,\n    const char *name,\n    int port,\n    int mode,\n    int64_t deadline);\nDILL_EXPORT const char *dill_ipaddr_str(\n    const struct dill_ipaddr *addr,\n    char *ipstr);\nDILL_EXPORT int dill_ipaddr_family(\n    const struct dill_ipaddr *addr);\nDILL_EXPORT const struct sockaddr *dill_ipaddr_sockaddr(\n    const struct dill_ipaddr *addr);\nDILL_EXPORT int dill_ipaddr_len(\n    const struct dill_ipaddr *addr);\nDILL_EXPORT int dill_ipaddr_port(\n    const struct dill_ipaddr *addr);\nDILL_EXPORT void dill_ipaddr_setport(\n    struct dill_ipaddr *addr,\n    int port);\nDILL_EXPORT int dill_ipaddr_equal(\n    const struct dill_ipaddr *addr1,\n    const struct dill_ipaddr *addr2,\n    int ignore_port);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define IPADDR_IPV4 DILL_IPADDR_IPV4 \n#define IPADDR_IPV6 DILL_IPADDR_IPV6\n#define IPADDR_PREF_IPV4 DILL_IPADDR_PREF_IPV4 \n#define IPADDR_PREF_IPV6 DILL_IPADDR_PREF_IPV6\n#define IPADDR_MAXSTRLEN DILL_IPADDR_MAXSTRLEN\n#define ipaddr dill_ipaddr\n#define ipaddr_local dill_ipaddr_local\n#define ipaddr_remote dill_ipaddr_remote\n#define ipaddr_remotes dill_ipaddr_remotes\n#define ipaddr_str dill_ipaddr_str\n#define ipaddr_family dill_ipaddr_family\n#define ipaddr_sockaddr dill_ipaddr_sockaddr\n#define ipaddr_len dill_ipaddr_len\n#define ipaddr_port dill_ipaddr_port\n#define ipaddr_setport dill_ipaddr_setport\n#define ipaddr_equal dill_ipaddr_equal\n#endif\n\n/******************************************************************************/\n/*  TCP protocol.                                                             */\n/******************************************************************************/\n\nstruct dill_tcp_listener_storage {char _[56];} DILL_ALIGN;\n\nstruct dill_tcp_storage {char _[72];} DILL_ALIGN;\n\nDILL_EXPORT int dill_tcp_listen(\n    struct dill_ipaddr *addr,\n    int backlog);\nDILL_EXPORT int dill_tcp_listen_mem(\n    struct dill_ipaddr *addr,\n    int backlog,\n    struct dill_tcp_listener_storage *mem);\nDILL_EXPORT int dill_tcp_accept(\n    int s,\n    struct dill_ipaddr *addr,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_accept_mem(\n    int s,\n    struct dill_ipaddr *addr,\n    struct dill_tcp_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_connect(\n    const struct dill_ipaddr *addr,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_connect_mem(\n    const struct dill_ipaddr *addr,\n    struct dill_tcp_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_close(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_tcp_listener_fromfd(\n    int fd);\nDILL_EXPORT int dill_tcp_listener_fromfd_mem(\n    int fd,\n    struct dill_tcp_listener_storage *mem);\nDILL_EXPORT int dill_tcp_fromfd(\n    int fd);\nDILL_EXPORT int dill_tcp_fromfd_mem(\n    int fd,\n    struct dill_tcp_storage *mem);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define tcp_listener_storage dill_tcp_listener_storage\n#define tcp_storage dill_tcp_storage\n#define tcp_listen dill_tcp_listen\n#define tcp_listen_mem dill_tcp_listen_mem\n#define tcp_accept dill_tcp_accept\n#define tcp_accept_mem dill_tcp_accept_mem\n#define tcp_connect dill_tcp_connect\n#define tcp_connect_mem dill_tcp_connect_mem\n#define tcp_done dill_tcp_done\n#define tcp_close dill_tcp_close\n#define tcp_listener_fromfd dill_tcp_listener_fromfd\n#define tcp_listener_fromfd_mem dill_tcp_listener_fromfd_mem\n#define tcp_fromfd dill_tcp_fromfd\n#define tcp_fromfd_mem dill_tcp_fromfd_mem\n#endif\n\n/******************************************************************************/\n/*  IPC protocol.                                                            */\n/******************************************************************************/\n\nstruct dill_ipc_listener_storage {char _[24];} DILL_ALIGN;\n\nstruct dill_ipc_storage {char _[72];} DILL_ALIGN;\n\nstruct dill_ipc_pair_storage {char _[144];} DILL_ALIGN;\n\nDILL_EXPORT int dill_ipc_listen(\n    const char *addr,\n    int backlog);\nDILL_EXPORT int dill_ipc_listen_mem(\n    const char *addr,\n    int backlog,\n    struct dill_ipc_listener_storage *mem);\nDILL_EXPORT int dill_ipc_accept(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_accept_mem(\n    int s,\n    struct dill_ipc_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_connect(\n    const char *addr,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_connect_mem(\n    const char *addr,\n    struct dill_ipc_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_sendfd(\n    int s,\n    int fd,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_recvfd(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_close(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_ipc_listener_fromfd(\n    int fd);\nDILL_EXPORT int dill_ipc_listener_fromfd_mem(\n    int fd,\n    struct dill_ipc_listener_storage *mem);\nDILL_EXPORT int dill_ipc_fromfd(\n    int fd);\nDILL_EXPORT int dill_ipc_fromfd_mem(\n    int fd,\n    struct dill_ipc_storage *mem);\nDILL_EXPORT int dill_ipc_pair(\n    int s[2]);\nDILL_EXPORT int dill_ipc_pair_mem(\n    struct dill_ipc_pair_storage *mem,\n    int s[2]);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define ipc_listener_storage dill_ipc_listener_storage\n#define ipc_storage dill_ipc_storage\n#define ipc_pair_storage dill_ipc_pair_storage\n#define ipc_listen dill_ipc_listen\n#define ipc_listen_mem dill_ipc_listen_mem\n#define ipc_accept dill_ipc_accept\n#define ipc_accept_mem dill_ipc_accept_mem\n#define ipc_connect dill_ipc_connect\n#define ipc_connect_mem dill_ipc_connect_mem\n#define ipc_sendfd dill_ipc_sendfd\n#define ipc_recvfd dill_ipc_recvfd\n#define ipc_done dill_ipc_done\n#define ipc_close dill_ipc_close\n#define ipc_listener_fromfd dill_ipc_listener_fromfd\n#define ipc_listener_fromfd_mem dill_ipc_listener_fromfd_mem\n#define ipc_fromfd dill_ipc_fromfd\n#define ipc_fromfd_mem dill_ipc_fromfd_mem\n#define ipc_pair dill_ipc_pair\n#define ipc_pair_mem dill_ipc_pair_mem\n#endif\n\n/******************************************************************************/\n/*  PREFIX protocol.                                                          */\n/*  Messages are prefixed by size.                                            */\n/******************************************************************************/\n\nstruct dill_prefix_storage {char _[56];} DILL_ALIGN;\n\n#define DILL_PREFIX_BIG_ENDIAN 0\n#define DILL_PREFIX_LITTLE_ENDIAN 1\n\nDILL_EXPORT int dill_prefix_attach(\n    int s,\n    size_t hdrlen,\n    int flags);\nDILL_EXPORT int dill_prefix_attach_mem(\n    int s,\n    size_t hdrlen,\n    int flags,\n    struct dill_prefix_storage *mem);\nDILL_EXPORT int dill_prefix_detach(\n    int s);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define PREFIX_BIG_ENDIAN DILL_PREFIX_BIG_ENDIAN\n#define PREFIX_LITTLE_ENDIAN DILL_PREFIX_LITTLE_ENDIAN\n#define prefix_storage dill_prefix_storage\n#define prefix_attach dill_prefix_attach\n#define prefix_attach_mem dill_prefix_attach_mem\n#define prefix_detach dill_prefix_detach\n#endif\n\n/******************************************************************************/\n/*  SUFFIX protocol.                                                          */\n/*  Messages are suffixed by specified string of bytes.                       */\n/******************************************************************************/\n\nstruct dill_suffix_storage {char _[128];} DILL_ALIGN;\n\nDILL_EXPORT int dill_suffix_attach(\n    int s,\n    const void *suffix,\n    size_t suffixlen);\nDILL_EXPORT int dill_suffix_attach_mem(\n    int s,\n    const void *suffix,\n    size_t suffixlen,\n    struct dill_suffix_storage *mem);\nDILL_EXPORT int dill_suffix_detach(\n    int s,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define suffix_storage dill_suffix_storage\n#define suffix_attach dill_suffix_attach\n#define suffix_attach_mem dill_suffix_attach_mem\n#define suffix_detach dill_suffix_detach\n#endif\n\n/******************************************************************************/\n/*  UDP protocol.                                                             */\n/*  Each UDP packet is treated as a separate message.                         */\n/******************************************************************************/\n\nstruct dill_udp_storage {char _[72];} DILL_ALIGN;\n\nDILL_EXPORT int dill_udp_open(\n    struct dill_ipaddr *local,\n    const struct dill_ipaddr *remote);\nDILL_EXPORT int dill_udp_open_mem(\n    struct dill_ipaddr *local,\n    const struct dill_ipaddr *remote,\n    struct dill_udp_storage *mem);\nDILL_EXPORT int dill_udp_send(\n    int s,\n    const struct dill_ipaddr *addr,\n    const void *buf,\n    size_t len);\nDILL_EXPORT ssize_t dill_udp_recv(\n    int s,\n    struct dill_ipaddr *addr,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_udp_sendl(\n    int s,\n    const struct dill_ipaddr *addr,\n    struct dill_iolist *first,\n    struct dill_iolist *last);\nDILL_EXPORT ssize_t dill_udp_recvl(\n    int s,\n    struct dill_ipaddr *addr,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define udp_storage dill_udp_storage\n#define udp_open dill_udp_open\n#define udp_open_mem dill_udp_open_mem\n#define udp_send dill_udp_send\n#define udp_recv dill_udp_recv\n#define udp_sendl dill_udp_sendl\n#define udp_recvl dill_udp_recvl\n#endif\n\n/******************************************************************************/\n/*  HTTP                                                                      */\n/******************************************************************************/\n\nstruct dill_http_storage {char _[1296];} DILL_ALIGN;\n\nDILL_EXPORT int dill_http_attach(\n    int s);\nDILL_EXPORT int dill_http_attach_mem(\n    int s,\n    struct dill_http_storage *mem);\nDILL_EXPORT int dill_http_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_http_detach(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_http_sendrequest(\n    int s,\n    const char *command,\n    const char *resource,\n    int64_t deadline);\nDILL_EXPORT int dill_http_recvrequest(\n    int s,\n    char *command,\n    size_t commandlen,\n    char *resource,\n    size_t resourcelen,\n    int64_t deadline);\nDILL_EXPORT int dill_http_sendstatus(\n    int s,\n    int status,\n    const char *reason,\n    int64_t deadline);\nDILL_EXPORT int dill_http_recvstatus(\n    int s,\n    char *reason,\n    size_t reasonlen,\n    int64_t deadline);\nDILL_EXPORT int dill_http_sendfield(\n    int s,\n    const char *name,\n    const char *value,\n    int64_t deadline);\nDILL_EXPORT int dill_http_recvfield(\n    int s,\n    char *name,\n    size_t namelen,\n    char *value,\n    size_t valuelen,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define http_storage dill_http_storage\n#define http_attach dill_http_attach\n#define http_attach_mem dill_http_attach_mem\n#define http_done dill_http_done\n#define http_detach dill_http_detach\n#define http_sendrequest dill_http_sendrequest\n#define http_recvrequest dill_http_recvrequest\n#define http_sendstatus dill_http_sendstatus\n#define http_recvstatus dill_http_recvstatus\n#define http_sendfield dill_http_sendfield\n#define http_recvfield dill_http_recvfield\n#endif\n\n#if !defined DILL_DISABLE_TLS\n\n/******************************************************************************/\n/*  TLS protocol.                                                             */\n/******************************************************************************/\n\nstruct dill_tls_storage {char _[72];} DILL_ALIGN;\n\nDILL_EXPORT int dill_tls_attach_server(\n    int s,\n    const char *cert,\n    const char *pkey,\n    int64_t deadline);\nDILL_EXPORT int dill_tls_attach_server_mem(\n    int s,\n    const char *cert,\n    const char *pkey,\n    struct dill_tls_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_tls_attach_client(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_tls_attach_client_mem(\n    int s,\n    struct dill_tls_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_tls_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_tls_detach(\n    int s,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define tls_storage dill_tls_storage\n#define tls_attach_server dill_tls_attach_server\n#define tls_attach_server_mem dill_tls_attach_server_mem\n#define tls_attach_client dill_tls_attach_client\n#define tls_attach_client_mem dill_tls_attach_client_mem\n#define tls_done dill_tls_done\n#define tls_detach dill_tls_detach\n#endif\n\n/******************************************************************************/\n/*  DTLS protocol.                                                            */\n/******************************************************************************/\n\nstruct dill_dtls_storage {char _[88];} DILL_ALIGN;\n\nDILL_EXPORT int dill_dtls_attach_server(\n    int s,\n    const char *cert,\n    const char *pkey,\n    int64_t deadline);\nDILL_EXPORT int dill_dtls_attach_server_mem(\n    int s,\n    const char *cert,\n    const char *pkey,\n    struct dill_dtls_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_dtls_attach_client(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_dtls_attach_client_mem(\n    int s,\n    struct dill_dtls_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_dtls_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_dtls_detach(\n    int s,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define dtls_storage dill_dtls_storage\n#define dtls_attach_server dill_dtls_attach_server\n#define dtls_attach_server_mem dill_dtls_attach_server_mem\n#define dtls_attach_client dill_dtls_attach_client\n#define dtls_attach_client_mem dill_dtls_attach_client_mem\n#define dtls_done dill_dtls_done\n#define dtls_detach dill_dtls_detach\n#endif\n\n#endif\n\n/******************************************************************************/\n/*  WebSockets protocol.                                                      */\n/******************************************************************************/\n\nstruct dill_ws_storage {char _[176];} DILL_ALIGN;\n\n#define DILL_WS_BINARY 0\n#define DILL_WS_TEXT 1\n#define DILL_WS_NOHTTP 2\n\nDILL_EXPORT int dill_ws_attach_client(\n    int s,\n    int flags,\n    const char *resource,\n    const char *host,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_attach_client_mem(\n    int s,\n    int flags,\n    const char *resource,\n    const char *host,\n    struct dill_ws_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_attach_server(\n    int s,\n    int flags,\n    char *resource,\n    size_t resourcelen,\n    char *host,\n    size_t hostlen,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_attach_server_mem(\n    int s,\n    int flags,\n    char *resource,\n    size_t resourcelen,\n    char *host,\n    size_t hostlen,\n    struct dill_ws_storage *mem,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_send(\n    int s,\n    int flags,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT ssize_t dill_ws_recv(\n    int s,\n    int *flags,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_sendl(\n    int s,\n    int flags,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nDILL_EXPORT ssize_t dill_ws_recvl(\n    int s,\n    int *flags,\n    struct dill_iolist *first,\n    struct dill_iolist *last,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_done(\n    int s,\n    int status,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT int dill_ws_detach(\n    int s,\n    int status,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nDILL_EXPORT ssize_t dill_ws_status(\n    int s,\n    int *status,\n    void *buf,\n    size_t len);\n\n/* Helper functions for those who want to implement HTTP exchange by hand. */\n\n#define WS_KEY_SIZE 32\n\nDILL_EXPORT int dill_ws_request_key(\n    char *request_key);\nDILL_EXPORT int dill_ws_response_key(\n    const char *request_key,\n    char *response_key);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define WS_BINARY DILL_WS_BINARY\n#define WS_TEXT DILL_WS_TEXT\n#define WS_NOHTTP DILL_WS_NOHTTP\n#define ws_storage dill_ws_storage\n#define ws_attach_server dill_ws_attach_server\n#define ws_attach_server_mem dill_ws_attach_server_mem\n#define ws_attach_client dill_ws_attach_client\n#define ws_attach_client_mem dill_ws_attach_client_mem\n#define ws_send dill_ws_send\n#define ws_recv dill_ws_recv\n#define ws_sendl dill_ws_sendl\n#define ws_recvl dill_ws_recvl\n#define ws_done dill_ws_done\n#define ws_detach dill_ws_detach\n#define ws_status dill_ws_status\n#define ws_request_key dill_ws_request_key\n#define ws_response_key dill_ws_response_key\n#endif\n\n/******************************************************************************/\n/*  SOCKS5                                                                    */\n/******************************************************************************/\n\n// SOCKS5 client commands\n#define DILL_SOCKS5_CONNECT (0x01)\n#define DILL_SOCKS5_BIND (0x02)\n#define DILL_SOCKS5_UDP_ASSOCIATE (0x03)\n\n// SOCKS5 server reply codes\n#define DILL_SOCKS5_SUCCESS (0x00)\n#define DILL_SOCKS5_GENERAL_FAILURE (0x01)\n#define DILL_SOCKS5_CONNECTION_NOT_ALLOWED (0x02)\n#define DILL_SOCKS5_NETWORK_UNREACHABLE (0x03)\n#define DILL_SOCKS5_HOST_UNREACHABLE (0x04)\n#define DILL_SOCKS5_CONNECTION_REFUSED (0x05)\n#define DILL_SOCKS5_TTL_EXPIRED (0x06)\n#define DILL_SOCKS5_COMMAND_NOT_SUPPORTED (0x07)\n#define DILL_SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED (0x08)\n\n\ntypedef int dill_socks5_auth_function(const char *username,\n    const char *password);\n\nDILL_EXPORT int dill_socks5_client_connect(\n    int s, const char *username, const char *password,\n    struct dill_ipaddr *addr, int64_t deadline);\n\nDILL_EXPORT int dill_socks5_client_connectbyname(\n    int s, const char *username, const char *password, const char *hostname,\n    int port, int64_t deadline);\n\nDILL_EXPORT int dill_socks5_proxy_auth(\n    int s, dill_socks5_auth_function *auth_fn, int64_t deadline);\n\nDILL_EXPORT int dill_socks5_proxy_recvcommand(\n    int s, struct dill_ipaddr *ipaddr, int64_t deadline);\n\nDILL_EXPORT int dill_socks5_proxy_recvcommandbyname(\n    int s, char *host, int *port, int64_t deadline);\n\nDILL_EXPORT int dill_socks5_proxy_sendreply(\n    int s, int reply, struct dill_ipaddr *ipaddr, int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n\n#define socks5_client_connect dill_socks5_client_connect\n#define socks5_client_connectbyname dill_socks5_client_connectbyname\n#define socks5_proxy_auth dill_socks5_proxy_auth\n#define socks5_proxy_recvcommand dill_socks5_proxy_recvcommand\n#define socks5_proxy_recvcommandbyname dill_socks5_proxy_recvcommandbyname\n#define socks5_proxy_sendreply dill_socks5_proxy_sendreply\n\n#define SOCKS5_CONNECT DILL_SOCKS5_CONNECT\n#define SOCKS5_BIND DILL_SOCKS5_BIND\n#define SOCKS5_UDP_ASSOCIATE DILL_SOCKS5_UDP_ASSOCIATE\n\n#define SOCKS5_SUCCESS DILL_SOCKS5_SUCCESS\n#define SOCKS5_GENERAL_FAILURE DILL_SOCKS5_GENERAL_FAILURE\n#define SOCKS5_CONNECTION_NOT_ALLOWED DILL_SOCKS5_CONNECTION_NOT_ALLOWED\n#define SOCKS5_NETWORK_UNREACHABLE DILL_SOCKS5_NETWORK_UNREACHABLE\n#define SOCKS5_HOST_UNREACHABLE DILL_SOCKS5_HOST_UNREACHABLE\n#define SOCKS5_CONNECTION_REFUSED DILL_SOCKS5_CONNECTION_REFUSED\n#define SOCKS5_TTL_EXPIRED DILL_SOCKS5_TTL_EXPIRED\n#define SOCKS5_COMMAND_NOT_SUPPORTED DILL_SOCKS5_COMMAND_NOT_SUPPORTED\n#define SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED DILL_SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED\n\n#endif /* !defined DILL_DISABLE_RAW_NAMES */\n\n/******************************************************************************/\n/*  TERM protocol.                                                            */\n/*  Implementes terminal handshake on the top of any message-based protocol.  */\n/******************************************************************************/\n\nstruct dill_term_storage {char _[88];} DILL_ALIGN;\n\nDILL_EXPORT int dill_term_attach(\n    int s,\n    const void *buf,\n    size_t len);\nDILL_EXPORT int dill_term_attach_mem(\n    int s,\n    const void *buf,\n    size_t len,\n    struct dill_term_storage *mem);\nDILL_EXPORT int dill_term_done(\n    int s,\n    int64_t deadline);\nDILL_EXPORT int dill_term_detach(\n    int s,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define term_storage dill_term_storage\n#define term_attach dill_term_attach\n#define term_attach_mem dill_term_attach_mem\n#define term_done dill_term_done\n#define term_detach dill_term_detach\n#endif\n\n/******************************************************************************/\n/* Happy Eyeballs (RFC 8305).                                                 */\n/* Implements concurrent TCP connecting to the remote endpoint.               */\n/******************************************************************************/\n\nDILL_EXPORT int dill_happyeyeballs_connect(\n    const char *name,\n    int port,\n    int64_t deadline);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define happyeyeballs_connect dill_happyeyeballs_connect\n#endif\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n"
        },
        {
          "name": "libdill.pc.in",
          "type": "blob",
          "size": 0.2412109375,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nincludedir=@includedir@\n\nName: libdill\nDescription: coroutine library\nURL: http://libdill.org/\nVersion: @DILL_ABI_VERSION@\nRequires:\nLibs: -L${libdir} -ldill @LIBS@\nCflags: -I${includedir}\n"
        },
        {
          "name": "libdillimpl.h",
          "type": "blob",
          "size": 3.130859375,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef LIBDILLIMPL_H_INCLUDED\n#define LIBDILLIMPL_H_INCLUDED\n\n#include \"libdill.h\"\n\n/******************************************************************************/\n/*  Handles                                                                   */\n/******************************************************************************/\n\nstruct dill_hvfs {\n    void *(*query)(struct dill_hvfs *vfs, const void *type);\n    void (*close)(struct dill_hvfs *vfs);\n};\n\nDILL_EXPORT int dill_hmake(struct dill_hvfs *vfs);\nDILL_EXPORT void *dill_hquery(int h, const void *type);\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define hvfs dill_hvfs\n#define hmake dill_hmake\n#define hquery dill_hquery\n#endif\n\n#if !defined DILL_DISABLE_SOCKETS\n\n/******************************************************************************/\n/*  Bytestream sockets.                                                       */\n/******************************************************************************/\n\nDILL_EXPORT extern const void *dill_bsock_type;\n\nstruct dill_bsock_vfs {\n    int (*bsendl)(struct dill_bsock_vfs *vfs,\n        struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n    int (*brecvl)(struct dill_bsock_vfs *vfs,\n        struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n};\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define bsock_vfs dill_bsock_vfs\n#define bsock_type dill_bsock_type\n#endif\n\n/******************************************************************************/\n/*  Message sockets.                                                          */\n/******************************************************************************/\n\nDILL_EXPORT extern const void *dill_msock_type;\n\nstruct dill_msock_vfs {\n    int (*msendl)(struct dill_msock_vfs *vfs,\n        struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n    ssize_t (*mrecvl)(struct dill_msock_vfs *vfs,\n        struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n};\n\n#if !defined DILL_DISABLE_RAW_NAMES\n#define msock_vfs dill_msock_vfs\n#define msock_type dill_msock_type\n#endif\n\n#endif\n\n#endif\n\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 2.4619140625,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_LIST_INCLUDED\n#define DILL_LIST_INCLUDED\n\n#include \"utils.h\"\n\n/* Doubly-linked list. */\nstruct dill_list {\n    struct dill_list *next;\n    struct dill_list *prev;\n};\n\n/* Initialize the list. */\nstatic inline void dill_list_init(struct dill_list *self) {\n    self->next = self;\n    self->prev = self;\n}\n\n/* True if the list has no items except for the head. */\nstatic inline int dill_list_empty(struct dill_list *self) {\n    return self->next == self;\n}\n\n/* True if the list has only one item in addition to the head. */\nstatic inline int dill_list_oneitem(struct dill_list *self) {\n    return self->next != self && self->next == self->prev;\n}\n\n/* Returns an iterator to one past the item pointed to by 'it'. If 'it' is the\n   list itself it returns the first item of the list. At the end of\n   the list, it returns the list itself. */\n#define dill_list_next(it) ((it)->next)\n\n/* Adds the item to the list before the item pointed to by 'before'. If 'before'\n   is the list itself the item is inserted to the end of the list. */\nstatic inline void dill_list_insert(struct dill_list *item,\n      struct dill_list *before) {\n    item->next = before;\n    item->prev = before->prev;\n    before->prev->next = item;\n    before->prev = item;\n}\n\n/* Removes the item from the list. */\nstatic void dill_list_erase(struct dill_list *item) {\n    item->prev->next = item->next;\n    item->next->prev = item->prev;\n}\n\n#endif\n\n"
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "msock.c",
          "type": "blob",
          "size": 2.4677734375,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stddef.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_msock_type);\n\nint dill_msend(int s, const void *buf, size_t len, int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return m->msendl(m, &iol, &iol, deadline);\n}\n\nssize_t dill_mrecv(int s, void *buf, size_t len, int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    struct dill_iolist iol = {buf, len, NULL, 0};\n    return m->mrecvl(m, &iol, &iol, deadline);\n}\n\nint dill_msendl(int s, struct dill_iolist *first, struct dill_iolist *last,\n      int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    if(dill_slow(!first || !last || last->iol_next)) {\n        errno = EINVAL; return -1;}\n    return m->msendl(m, first, last, deadline);\n}\n\nssize_t dill_mrecvl(int s, struct dill_iolist *first, struct dill_iolist *last,\n      int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    if(dill_slow((last && last->iol_next) ||\n          (!first && last) ||\n          (first && !last))) {\n        errno = EINVAL; return -1;}\n    return m->mrecvl(m, first, last, deadline);\n}\n\n"
        },
        {
          "name": "now.c",
          "type": "blob",
          "size": 4.115234375,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stdint.h>\n#include <sys/time.h>\n#include <time.h>\n\n#if defined(__x86_64__) || defined(__i386__)\n#include <x86intrin.h>\n#endif\n\n#include \"ctx.h\"\n\nint64_t dill_mnow(void) {\n\n/* Implementation using Mach timers. */\n#if defined __APPLE__\n    static mach_timebase_info_data_t dill_mtid = {0};\n    if (dill_slow(!dill_mtid.denom))\n        mach_timebase_info(&dill_mtid);\n    uint64_t ticks = mach_absolute_time();\n    return (int64_t)(ticks * dill_mtid.numer / dill_mtid.denom / 1000000);\n#else\n\n/* Implementation using clock_gettime(). */\n#if defined CLOCK_MONOTONIC_COARSE\n    clock_t id = CLOCK_MONOTONIC_COARSE;\n#elif defined CLOCK_MONOTONIC_FAST\n    clock_t id = CLOCK_MONOTONIC_FAST;\n#elif defined CLOCK_MONOTONIC\n    clock_t id = CLOCK_MONOTONIC;\n#else\n#define DILL_dill_now_FALLBACK\n#endif\n#if !defined DILL_dill_now_FALLBACK\n    struct timespec ts;\n    int rc = clock_gettime(id, &ts);\n    dill_assert (rc == 0);\n    return ((int64_t)ts.tv_sec) * 1000 + (((int64_t)ts.tv_nsec) / 1000000);\n\n/* Implementation using gettimeofday(). This is slow and error-prone\n   (the time can jump backwards!), but it's just a last resort option. */\n#else\n    struct timeval tv;\n    int rc = gettimeofday(&tv, NULL);\n    dill_assert (rc == 0);\n    return ((int64_t)tv.tv_sec) * 1000 + (((int64_t)tv.tv_usec) / 1000);\n#endif\n\n#endif\n}\n\n/* Like now(), this function can be called only after context is initialized\n   but unlike now() it doesn't do time caching. */\nstatic int64_t dill_now_(void) {\n#if defined __APPLE__\n    struct dill_ctx_now *ctx = &dill_getctx->now;\n    uint64_t ticks = mach_absolute_time();\n    return (int64_t)(ticks * ctx->mtid.numer / ctx->mtid.denom / 1000000);\n#else\n    return dill_mnow();\n#endif\n}\n\nint64_t dill_now(void) {\n#if defined(__x86_64__) || defined(__i386__)\n    /* On x86 platforms, rdtsc instruction can be used to quickly check time\n       in form of CPU cycles. If less than 1M cycles have elapsed since the\n       last dill_now_() call we assume it's still the same millisecond and return\n       cached time. This optimization can give a huge speedup with old systems.\n       1M number is chosen is such a way that it results in getting time every\n       millisecond on 1GHz processors. On faster processors we'll query time\n       somewhat more often but the number of queries should still be\n       statistically insignificant. On slower processors we'll start losing\n       precision, e.g. on 500MHz processor we can diverge by 1ms. */\n    struct dill_ctx_now *ctx = &dill_getctx->now;\n    uint64_t tsc = __rdtsc();\n    int64_t diff = tsc - ctx->last_tsc;\n    if(diff < 0) diff = -diff;\n    if(dill_fast(diff < 1000000ULL)) return ctx->last_time;\n    ctx->last_tsc = tsc;\n    ctx->last_time = dill_now_();\n    return ctx->last_time;\n#else\n    return dill_now_();\n#endif\n}\n\nint dill_ctx_now_init(struct dill_ctx_now *ctx) {\n#if defined __APPLE__\n    mach_timebase_info(&ctx->mtid);\n#endif\n#if defined(__x86_64__) || defined(__i386__)\n    ctx->last_time = dill_mnow();\n    ctx->last_tsc = __rdtsc();\n#endif\n    return 0;\n}\n\nvoid dill_ctx_now_term(struct dill_ctx_now *ctx) {\n}\n\n"
        },
        {
          "name": "now.h",
          "type": "blob",
          "size": 1.640625,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_NOW_INCLUDED\n#define DILL_NOW_INCLUDED\n\n#include <stdint.h>\n\n#if defined __APPLE__\n#include <mach/mach_time.h>\n#endif\n\nstruct dill_ctx_now {\n#if defined __APPLE__\n    mach_timebase_info_data_t mtid;\n#endif\n#if defined(__x86_64__) || defined(__i386__)\n    int64_t last_time;\n    uint64_t last_tsc;\n#endif\n};\n\nint dill_ctx_now_init(struct dill_ctx_now *ctx);\nvoid dill_ctx_now_term(struct dill_ctx_now *ctx);\n\n/* Same as dill_now() except that it doesn't use the context.\n   I.e. it can be called before calling dill_ctx_now_init(). */\nint64_t dill_mnow(void);\n\n#endif\n\n"
        },
        {
          "name": "package_version.sh",
          "type": "blob",
          "size": 1.634765625,
          "content": "#!/bin/sh\n\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nif [ -d .git ]; then\n    #  Retrieve the version from the last git tag.\n    VER=`git describe --always | sed -e \"s:v::\"`\n    if [ x\"`git diff-index --name-only HEAD`\" != x ]; then\n        #  If the sources have been changed locally, add -dirty to the version.\n        VER=\"${VER}-dirty\"\n    fi\nelif [ -f .version ]; then\n    #  If git is not available (e.g. when building from source package)\n    #  we can extract the package version from .version file.\n    VER=`< .version`\nelse\n    #  The package version cannot be retrieved.\n    VER=\"Unknown\"\nfi\n\nprintf '%s' \"$VER\"\n\n"
        },
        {
          "name": "perf",
          "type": "tree",
          "content": null
        },
        {
          "name": "poll.c.inc",
          "type": "blob",
          "size": 8.1748046875,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n#include \"pollset.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n/*\n\n                                ctx->pollset_size\n                                        |\n  ctx->pollset                          V\n  +-------+-------+-------+-----+-------+--------------------------------+\n  | pfd 0 | pfd 1 | pfd 2 | ... | pfd N |             empty              |\n  +-------+-------+-------+-----+-------+--------------------------------+\n      ^                             ^                                    ^\n      |                             |                                    |\n     idx            +------idx------+                                    |\n      |             |                                                    |\n  +------+------+------+----------------------------------------+--------+\n  | fd=0 | fd=1 | fd=2 |                   ...                  | fd=max |\n  +------+------+------+----------------------------------------+--------+\n  ctx->fdinfos                                                           ^\n                                                                         |\n                                                                  ctx->nfdinfos\n\n*/\n\n/* Additional info about file descriptor. */\nstruct dill_fdinfo {\n    /* Index of the file descriptor in the pollset.\n       -1 means the fd is not in the pollset. */\n    int idx;\n    /* Clause waiting for in. NULL if none. */\n    struct dill_fdclause *in;\n    /* Clause waiting for out. NULL if none. */\n    struct dill_fdclause *out;\n    /* 1 is the file descriptor was used before, 0 otherwise. */\n    unsigned int cached : 1;\n};\n\nint dill_ctx_pollset_init(struct dill_ctx_pollset *ctx) {\n    int err;\n    ctx->nfdinfos = dill_maxfds();\n    /* Allocate largest possible pollset. */\n    ctx->pollset_size = 0;\n    ctx->pollset = malloc(sizeof(struct pollfd) * ctx->nfdinfos);\n    if(dill_slow(!ctx->pollset)) {err = ENOMEM; goto error1;}\n    ctx->fdinfos = malloc(sizeof(struct dill_fdinfo) * ctx->nfdinfos);\n    if(dill_slow(!ctx->fdinfos)) {err = ENOMEM; goto error2;}\n    /* Intialise fd infos. There's no fd in the pollset,\n       so set all indices to -1. */\n    int i;\n    for(i = 0; i != ctx->nfdinfos; ++i) {\n        ctx->fdinfos[i].idx = -1;\n        ctx->fdinfos[i].in = NULL;\n        ctx->fdinfos[i].out = NULL;\n        ctx->fdinfos[i].cached = 0;\n    }\n    return 0;\nerror2:\n    free(ctx->pollset);\n    ctx->pollset = NULL;\nerror1:\n    errno = err;\n    return -1;\n}\n\nvoid dill_ctx_pollset_term(struct dill_ctx_pollset *ctx) {\n    free(ctx->pollset);\n    free(ctx->fdinfos);\n}\n\nstatic void dill_fdcancelin(struct dill_clause *cl) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    struct dill_fdinfo *fdi = dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdi->in = NULL;\n    ctx->pollset[fdi->idx].events &= ~POLLIN;\n    /* fd is left in the pollset. It will be purged once the event loop\n       iterates once more. */\n}\n\nstatic void dill_fdcancelout(struct dill_clause *cl) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    struct dill_fdinfo *fdi = dill_cont(cl, struct dill_fdclause, cl)->fdinfo;\n    fdi->out = NULL;\n    ctx->pollset[fdi->idx].events &= ~POLLOUT;\n    /* fd is left in the pollset. It will be purged once the event loop\n       iterates once more. */\n}\n\nint dill_pollset_in(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    if(dill_slow(!fdi->cached)) {\n        int flags = fcntl(fd, F_GETFD);\n        if(flags < 0 && errno == EBADF) return -1;\n        dill_assert(flags >= 0);\n        fdi->cached = 1;\n    }\n    if(fdi->idx < 0) {\n        fdi->idx = ctx->pollset_size;\n        ++ctx->pollset_size;\n        ctx->pollset[fdi->idx].fd = fd;\n    }\n    if(dill_slow(fdi->in)) {errno = EBUSY; return -1;}\n    ctx->pollset[fdi->idx].events |= POLLIN;\n    fdcl->fdinfo = fdi;\n    fdi->in = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelin);\n    return 0;\n}\n\nint dill_pollset_out(struct dill_fdclause *fdcl, int id, int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    if(dill_slow(fd < 0 || fd >= ctx->nfdinfos)) {errno = EBADF; return -1;}\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    if(dill_slow(!fdi->cached)) {\n        int flags = fcntl(fd, F_GETFD);\n        if(flags < 0 && errno == EBADF) return -1;\n        dill_assert(flags >= 0);\n        fdi->cached = 1;\n    }\n    if(fdi->idx < 0) {\n        fdi->idx = ctx->pollset_size;\n        ++ctx->pollset_size;\n        ctx->pollset[fdi->idx].fd = fd;\n    }\n    if(dill_slow(fdi->out)) {errno = EBUSY; return -1;}\n    ctx->pollset[fdi->idx].events |= POLLOUT;\n    fdcl->fdinfo = fdi;\n    fdi->out = fdcl;\n    dill_waitfor(&fdcl->cl, id, dill_fdcancelout);\n    return 0;\n}\n\nint dill_pollset_clean(int fd) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    struct dill_fdinfo *fdi = &ctx->fdinfos[fd];\n    if(!fdi->cached) return 0;\n    if(dill_slow(fdi->in || fdi->out)) {errno = EBUSY; return -1;}\n    /* If the fd happens to still be in the pollset remove it. */\n    if(fdi->idx >= 0) {\n        --ctx->pollset_size;\n        if(fdi->idx != ctx->pollset_size) {\n            struct pollfd *pfd = &ctx->pollset[fdi->idx];\n            struct pollfd *lastpfd = &ctx->pollset[ctx->pollset_size];\n            *pfd = *lastpfd;\n            ctx->fdinfos[pfd->fd].idx = fdi->idx;\n        }\n        fdi->idx = -1;\n    }\n    fdi->cached = 0;\n    return 0;\n}\n\nint dill_pollset_poll(int timeout) {\n    struct dill_ctx_pollset *ctx = &dill_getctx->pollset;\n    /* Wait for events. */\n    int numevs = poll(ctx->pollset, ctx->pollset_size, timeout);\n    if(numevs < 0 && errno == EINTR) return -1;\n    dill_assert(numevs >= 0);\n    /* Fire file descriptor events as needed. */\n    int i;\n    for(i = 0; i != ctx->pollset_size; ++i) {\n        struct pollfd *pfd = &ctx->pollset[i];\n        struct dill_fdinfo *fdi = &ctx->fdinfos[pfd->fd];\n        /* Resume the blocked coroutines. */\n        if(fdi->in &&\n              pfd->revents & (POLLIN | POLLERR | POLLHUP | POLLNVAL)) {\n            pfd->events &= ~POLLIN;\n            dill_trigger(&fdi->in->cl, 0);\n        }\n        if(fdi->out && \n              pfd->revents & (POLLOUT | POLLERR | POLLHUP | POLLNVAL)) {\n            pfd->events &= ~POLLOUT;\n            dill_trigger(&fdi->out->cl, 0);\n        }\n        /* If nobody is polling for the fd remove it from the pollset. */\n        if(!pfd->events) {\n            fdi->idx = -1;\n            dill_assert(!fdi->in && !fdi->out);\n            --ctx->pollset_size;\n            /* Pollset has to be compact. Thus, unless we are removing the\n               last item from the pollset we want to move the last item\n               to the vacant slot left by the removed fd. */\n            if(i != ctx->pollset_size) {\n                struct pollfd *lastpfd = &ctx->pollset[ctx->pollset_size];\n                *pfd = *lastpfd;\n                ctx->fdinfos[pfd->fd].idx = i;\n            }\n            --i;\n        }\n    }\n    return numevs > 0;\n}\n\n"
        },
        {
          "name": "poll.h.inc",
          "type": "blob",
          "size": 1.552734375,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_POLL_INCLUDED\n#define DILL_POLL_INCLUDED\n\n#include <poll.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n\nstruct dill_fdinfo;\n\nstruct dill_fdclause {\n   struct dill_clause cl;\n   struct dill_fdinfo *fdinfo;\n};\n\nstruct dill_ctx_pollset {\n    /* Pollset, as used by poll(2). */\n    int pollset_size;\n    struct pollfd *pollset;\n    /* Info about all file descriptors.\n       File descriptors are used as indices in this array. */\n    int nfdinfos;\n    struct dill_fdinfo *fdinfos;\n};\n\n#endif\n"
        },
        {
          "name": "pollset.c",
          "type": "blob",
          "size": 1.427734375,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n/* Include the poll-mechanism-specific stuff. */\n\n/* User overloads. */\n#if defined DILL_EPOLL\n#include \"epoll.c.inc\"\n#elif defined DILL_KQUEUE\n#include \"kqueue.c.inc\"\n#elif defined DILL_POLL\n#include \"poll.c.inc\"\n/* Defaults. */\n#elif defined HAVE_EPOLL\n#include \"epoll.c.inc\"\n#elif defined HAVE_KQUEUE\n#include \"kqueue.c.inc\"\n#else\n#include \"poll.c.inc\"\n#endif\n"
        },
        {
          "name": "pollset.h",
          "type": "blob",
          "size": 2.087890625,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_POLLSET_INCLUDED\n#define DILL_POLLSET_INCLUDED\n\n/* User overloads. */\n#if defined DILL_EPOLL\n#include \"epoll.h.inc\"\n#elif defined DILL_KQUEUE\n#include \"kqueue.h.inc\"\n#elif defined DILL_POLL\n#include \"poll.h.inc\"\n/* Defaults. */\n#elif defined HAVE_EPOLL\n#include \"epoll.h.inc\"\n#elif defined HAVE_KQUEUE\n#include \"kqueue.h.inc\"\n#else\n#include \"poll.h.inc\"\n#endif\n\nint dill_ctx_pollset_init(struct dill_ctx_pollset *ctx);\nvoid dill_ctx_pollset_term(struct dill_ctx_pollset *ctx);\n\n/* Add waiting for an in event on the fd to the list of current clauses. */\nint dill_pollset_in(struct dill_fdclause *fdcl, int id, int fd);\n\n/* Add waiting for an out event on the fd to the list of current clauses. */\nint dill_pollset_out(struct dill_fdclause *fdcl, int id, int fd);\n\n/* Drop any cached info about the file descriptor. */\nint dill_pollset_clean(int fd);\n\n/* Wait for events. 'timeout' is in milliseconds. Return 0 if the timeout expired or\n  1 if at least one clause was triggered. */\nint dill_pollset_poll(int timeout);\n\n#endif\n\n"
        },
        {
          "name": "prefix.c",
          "type": "blob",
          "size": 6.6845703125,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_prefix_type);\n\nstatic void *dill_prefix_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_prefix_hclose(struct dill_hvfs *hvfs);\nstatic int dill_prefix_msendl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic ssize_t dill_prefix_mrecvl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_prefix_sock {\n    struct dill_hvfs hvfs;\n    struct dill_msock_vfs mvfs;\n    int u;\n    size_t hdrlen;\n    unsigned int bigendian : 1;\n    unsigned int inerr : 1;\n    unsigned int outerr : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_prefix_sock, dill_prefix_storage)\n\nstatic void *dill_prefix_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_prefix_sock *self = (struct dill_prefix_sock*)hvfs;\n    if(type == dill_msock_type) return &self->mvfs;\n    if(type == dill_prefix_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_prefix_attach_mem(int s, size_t hdrlen, int flags,\n      struct dill_prefix_storage *mem) {\n    int err;\n    if(dill_slow(!mem || hdrlen == 0)) {err = EINVAL; goto error;}\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Check whether underlying socket is a bytestream. */\n    void *q = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!q && errno == ENOTSUP)) {err = EPROTO; goto error;}\n    if(dill_slow(!q)) {err = errno; goto error;}\n    /* Create the object. */\n    struct dill_prefix_sock *self = (struct dill_prefix_sock*)mem;\n    self->hvfs.query = dill_prefix_hquery;\n    self->hvfs.close = dill_prefix_hclose;\n    self->mvfs.msendl = dill_prefix_msendl;\n    self->mvfs.mrecvl = dill_prefix_mrecvl;\n    self->u = s;\n    self->hdrlen = hdrlen;\n    self->bigendian = !(flags & DILL_PREFIX_LITTLE_ENDIAN);\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Create the handle. */\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_prefix_attach(int s, size_t hdrlen, int flags) {\n    int err;\n    struct dill_prefix_sock *obj = malloc(sizeof(struct dill_prefix_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_prefix_attach_mem(s, hdrlen, flags,\n        (struct dill_prefix_storage*)obj);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_prefix_detach(int s) {\n    int err;\n    struct dill_prefix_sock *self = dill_hquery(s, dill_prefix_type);\n    if(dill_slow(!self)) {err = errno; goto error;}\n    if(dill_slow(self->inerr || self->outerr)) {err = ECONNRESET; goto error;}\n    int u = self->u;\n    if(!self->mem) free(self);\n    return u;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nstatic int dill_prefix_msendl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_prefix_sock *self = dill_cont(mvfs, struct dill_prefix_sock,\n        mvfs);\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    uint8_t szbuf[self->hdrlen];\n    size_t sz = 0;\n    struct dill_iolist *it;\n    for(it = first; it; it = it->iol_next)\n        sz += it->iol_len;\n    int i;\n    for(i = 0; i != self->hdrlen; ++i) {\n        szbuf[self->bigendian ? (self->hdrlen - i - 1) : i] = sz & 0xff;\n        sz >>= 8;\n    }\n    struct dill_iolist hdr = {szbuf, sizeof(szbuf), first, 0};\n    int rc = dill_bsendl(self->u, &hdr, last, deadline);\n    if(dill_slow(rc < 0)) {self->outerr = 1; return -1;}\n    return 0;\n}\n\nstatic ssize_t dill_prefix_mrecvl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_prefix_sock *self = dill_cont(mvfs, struct dill_prefix_sock,\n        mvfs);\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    uint8_t szbuf[self->hdrlen];\n    int rc = dill_brecv(self->u, szbuf, self->hdrlen, deadline);\n    if(dill_slow(rc < 0)) {self->inerr = 1; return -1;}\n    uint64_t sz = 0;\n    int i;\n    for(i = 0; i != self->hdrlen; ++i) {\n        uint8_t c = szbuf[self->bigendian ? i : (self->hdrlen - i - 1)];\n        sz <<= 8;\n        sz |= c;\n    }\n    /* Skip the message. */\n    if(!first) {\n        rc = dill_brecv(self->u, NULL, sz, deadline);\n        if(dill_slow(rc < 0)) {self->inerr = 1; return -1;}\n        return sz;\n    }\n    /* Trim iolist to reflect the size of the message. */\n    size_t rmn = sz;\n    struct dill_iolist *it = first;\n    while(1) {\n        if(it->iol_len >= rmn) break;\n        rmn -= it->iol_len;\n        it = it->iol_next;\n        if(dill_slow(!it)) {self->inerr = 1; errno = EMSGSIZE; return -1;}\n    }\n    size_t old_len = it->iol_len;\n    struct dill_iolist *old_next = it->iol_next;\n    it->iol_len = rmn;\n    it->iol_next = NULL;\n    rc = dill_brecvl(self->u, first, last, deadline);\n    /* Get iolist to its original state. */\n    it->iol_len = old_len;\n    it->iol_next = old_next;\n    if(dill_slow(rc < 0)) {self->inerr = 1; return -1;}\n    return sz;\n}\n\nstatic void dill_prefix_hclose(struct dill_hvfs *hvfs) {\n    struct dill_prefix_sock *self = (struct dill_prefix_sock*)hvfs;\n    if(dill_fast(self->u >= 0)) {\n        int rc = dill_hclose(self->u);\n        dill_assert(rc == 0);\n    }\n    if(!self->mem) free(self);\n}\n\n"
        },
        {
          "name": "qlist.h",
          "type": "blob",
          "size": 2.1767578125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_QLIST_INCLUDED\n#define DILL_QLIST_INCLUDED\n\n#include \"slist.h\"\n#include \"utils.h\"\n\n/* Singly-linked list that's first-in-first-out, so it's actually a queue.\n   To iterate over the items, use the underlying slist. */\n\nstruct dill_qlist {\n    struct dill_slist slist;\n    struct dill_slist *last;\n};\n\n/* Initialize the list. */\nstatic inline void dill_qlist_init(struct dill_qlist *self) {\n    dill_slist_init(&self->slist);\n    self->last = &self->slist;\n}\n\n/* True if the list has no items. */\nstatic inline int dill_qlist_empty(struct dill_qlist *self) {\n    return self->slist.next == &self->slist;\n}\n\n/* Push an item to the end of the list. */\nstatic inline void dill_qlist_push(struct dill_qlist *self,\n      struct dill_slist *item) {\n    item->next = &self->slist;\n    self->last->next = item;\n    self->last = item;\n}\n\n/* Pop an item from the beginning of the list. */\nstatic inline struct dill_slist *dill_qlist_pop(struct dill_qlist *self) {\n    struct dill_slist *item = self->slist.next;\n    self->slist.next = item->next;\n    if(item == self->last) self->last = &self->slist;\n    return item;\n}\n\n#endif\n\n"
        },
        {
          "name": "rbtree.c",
          "type": "blob",
          "size": 8.0830078125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n\n/* This implementation is based on Emin Martinian's implementation of the algorithm:\n   http://web.mit.edu/~emin/Desktop/ref_to_emin/www.old/source_code/red_black_tree/index.html */\n\n#include <stddef.h>\n\n#include \"rbtree.h\"\n\nvoid dill_rbtree_init(struct dill_rbtree *self) {\n    struct dill_rbtree_item *temp;\n    temp = &self->nil;\n    temp->up = temp->left = temp->right=temp;\n    temp->red = 0;\n    temp->val = 0;\n    temp = &self->root;\n    temp->up = temp->left=temp->right = &self->nil;\n    temp->val = 0;\n    temp->red = 0;\n}\n\nstatic void dill_rbtree_lrotate(struct dill_rbtree* self,\n      struct dill_rbtree_item* x) {\n    struct dill_rbtree_item *y;\n    struct dill_rbtree_item *nil = &self->nil;\n    y = x->right;\n    x->right = y->left;\n    if(y->left != nil) y->left->up=x;\n    y->up = x->up;   \n    if(x == x->up->left) {\n        x->up->left = y;\n    } else {\n        x->up->right = y;\n    }\n    y->left = x;\n    x->up = y;\n}\n\nstatic void dill_rbtree_rrotate(struct dill_rbtree *self,\n      struct dill_rbtree_item *y) {\n    struct dill_rbtree_item *x;\n    struct dill_rbtree_item *nil = &self->nil;\n    x = y->left;\n    y->left = x->right;\n    if(nil != x->right) x->right->up = y;\n    x->up = y->up;\n    if(y == y->up->left) {\n        y->up->left = x;\n    } else {\n        y->up->right = x;\n    }\n    x->right = y;\n    y->up = x;\n}\n\nstatic void dill_rbtree_insert_help(struct dill_rbtree *self,\n      struct dill_rbtree_item *z) {\n    struct dill_rbtree_item *x;\n    struct dill_rbtree_item *y;\n    struct dill_rbtree_item *nil = &self->nil;\n    z->left = z->right = nil;\n    y = &self->root;\n    x = self->root.left;\n    while(x != nil) {\n        y=x;\n        if(x->val > z->val) { \n            x = x->left;\n        } else {\n            x = x->right;\n        }\n    }\n    z->up = y;\n    if((y == &self->root) || (y->val > z->val)) {\n        y->left = z;\n    } else {\n        y->right = z;\n    }\n}\n\nvoid dill_rbtree_insert(struct dill_rbtree *tree, int64_t val,\n      struct dill_rbtree_item *item) {\n    struct dill_rbtree_item *y;\n    struct dill_rbtree_item *x;\n    x = item;\n    x->val = val;\n    dill_rbtree_insert_help(tree, x);\n    x->red = 1;\n    while(x->up->red) {\n        if(x->up == x->up->up->left) {\n            y = x->up->up->right;\n            if(y->red) {\n                x->up->red = 0;\n                y->red = 0;\n                x->up->up->red = 1;\n                x = x->up->up;\n            } else {\n                if(x == x->up->right) {\n                    x = x->up;\n                    dill_rbtree_lrotate(tree, x);\n                }\n                x->up->red = 0;\n                x->up->up->red = 1;\n                dill_rbtree_rrotate(tree, x->up->up);\n            }\n        } else {\n            y = x->up->up->left;\n            if(y->red) {\n                x->up->red = 0;\n                y->red = 0;\n                x->up->up->red = 1;\n                x = x->up->up;\n            } else {\n                if(x == x->up->left) {\n                    x = x->up;\n                    dill_rbtree_rrotate(tree, x);\n                }\n                x->up->red = 0;\n                x->up->up->red = 1;\n                dill_rbtree_lrotate(tree, x->up->up);\n            } \n        }\n    }\n    tree->root.left->red = 0;\n}\n\nint dill_rbtree_empty(struct dill_rbtree *self) {\n    struct dill_rbtree_item* nil = &self->nil;\n    return self->root.left == nil;\n}\n\nstruct dill_rbtree_item *dill_rbtree_first(struct dill_rbtree *self) {\n    struct dill_rbtree_item* nil = &self->nil;\n    struct dill_rbtree_item *x = self->root.left;\n    if(x == nil) return NULL;\n    while(x->left != nil) x = x->left;\n    return x;\n}\n  \nstatic struct dill_rbtree_item *dill_rbtree_next_help(struct dill_rbtree *tree,\n      struct dill_rbtree_item *x) { \n    struct dill_rbtree_item *y;\n    struct dill_rbtree_item *nil = &tree->nil;\n    struct dill_rbtree_item *root = &tree->root;\n    if(nil != (y = x->right)) {\n        while(y->left != nil) {\n            y = y->left;\n        }\n        return y;\n    } else {\n        y = x->up;\n        while(x == y->right) {\n            x = y;\n            y = y->up;\n        }\n        if(y == root) return nil;\n        return y;\n    }\n}\n\nstruct dill_rbtree_item *dill_rbtree_next(struct dill_rbtree *tree,\n      struct dill_rbtree_item *x) {\n    struct dill_rbtree_item *it = dill_rbtree_next_help(tree, x);\n    if(it == &tree->nil) return NULL;\n    return it;\n}\n\nstatic void dill_rbtree_fixup(struct dill_rbtree *tree,\n      struct dill_rbtree_item *x) {\n    struct dill_rbtree_item *root = tree->root.left;\n    struct dill_rbtree_item *w;\n    while((!x->red) && (root != x)) {\n        if (x == x->up->left) {\n            w = x->up->right;\n            if(w->red) {\n                w->red = 0;\n                x->up->red = 1;\n                dill_rbtree_lrotate(tree, x->up);\n                w = x->up->right;\n            }\n            if((!w->right->red) && (!w->left->red)) {\n                w->red = 1;\n                x = x->up;\n            } else {\n                if(!w->right->red) {\n                    w->left->red = 0;\n                    w->red = 1;\n                    dill_rbtree_rrotate(tree, w);\n                    w = x->up->right;\n                }\n                w->red = x->up->red;\n                x->up->red = 0;\n                w->right->red = 0;\n                dill_rbtree_lrotate(tree, x->up);\n                x = root;\n            }\n        } else { \n            w = x->up->left;\n            if(w->red) {\n                w->red = 0;\n                x->up->red = 1;\n                dill_rbtree_rrotate(tree, x->up);\n                w = x->up->left;\n            }\n            if((!w->right->red) && (!w->left->red)) {\n                w->red = 1;\n                x = x->up;\n            } else {\n                if(!w->left->red) {\n                    w->right->red = 0;\n                    w->red = 1;\n                    dill_rbtree_lrotate(tree, w);\n                    w = x->up->left;\n                }\n                w->red = x->up->red;\n                x->up->red = 0;\n                w->left->red = 0;\n                dill_rbtree_rrotate(tree, x->up);\n                x = root;\n            }\n        }\n    }\n    x->red = 0;\n}\n\nvoid dill_rbtree_erase(struct dill_rbtree *tree, struct dill_rbtree_item *z) {\n    struct dill_rbtree_item *y;\n    struct dill_rbtree_item *x;\n    struct dill_rbtree_item *nil=&tree->nil;\n    struct dill_rbtree_item *root=&tree->root;\n    y = ((z->left == nil) || (z->right == nil)) ? z :\n        dill_rbtree_next_help(tree, z);\n    x = (y->left == nil) ? y->right : y->left;\n    if(root == (x->up = y->up)) {\n        root->left = x;\n    } else {\n        if(y == y->up->left) {\n            y->up->left = x;\n        } else {\n            y->up->right = x;\n        }\n    }\n    if(y != z) {\n        if(!(y->red)) dill_rbtree_fixup(tree, x);\n        y->left = z->left;\n        y->right = z->right;\n        y->up = z->up;\n        y->red = z->red;\n        z->left->up = z->right->up=y;\n        if(z == z->up->left) {\n            z->up->left=y; \n        } else {\n            z->up->right=y;\n        } \n    } else {\n        if(!(y->red)) dill_rbtree_fixup(tree, x);    \n    }\n}\n\n"
        },
        {
          "name": "rbtree.h",
          "type": "blob",
          "size": 2.4052734375,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_RBTREE_INCLUDED\n#define DILL_RBTREE_INCLUDED\n\n#include <stddef.h>\n#include <stdint.h>\n\nstruct dill_rbtree_item {\n    int red;\n    struct dill_rbtree_item *left;\n    struct dill_rbtree_item *right;\n    struct dill_rbtree_item *up;\n    int64_t val;\n};\n\nstruct dill_rbtree {\n    struct dill_rbtree_item root;\n    struct dill_rbtree_item nil;\n};\n\n/* Initialize the tree. */\nvoid dill_rbtree_init(struct dill_rbtree *self);\n\n/* Returns 1 if there are no items in the tree. 0 otherwise. */\nint dill_rbtree_empty(struct dill_rbtree *self);\n\n/* Insert an item into the tree & set its value to 'val' */\nvoid dill_rbtree_insert(struct dill_rbtree *self, int64_t val,\n    struct dill_rbtree_item *item);\n\n/* Remove an item from a tree. */\nvoid dill_rbtree_erase(struct dill_rbtree *self, struct dill_rbtree_item *item);\n\n/* Return an item with the lowest value. If there are no items in the tree, NULL\n   is returned. */\nstruct dill_rbtree_item *dill_rbtree_first(struct dill_rbtree *self);\n\n/* Iterate through the tree. Items are returned starting with those with\n   the lowest values and ending with those with the highest values. Items with\n   equal values are returned in no particular order. If 'it' points to the\n   last item, NULL is returned. */\nstruct dill_rbtree_item *dill_rbtree_next(struct dill_rbtree *self,\n    struct dill_rbtree_item *it);\n\n#endif\n"
        },
        {
          "name": "rfc",
          "type": "tree",
          "content": null
        },
        {
          "name": "slist.h",
          "type": "blob",
          "size": 2.2314453125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_SLIST_INCLUDED\n#define DILL_SLIST_INCLUDED\n\n#include \"utils.h\"\n\n/* A Singly-linked list that's last-in-first-out, so it's actually a stack.\n   To prevent confusion with C's call stack, we'll call it slist. */\n\nstruct dill_slist {\n    struct dill_slist *next;\n};\n\n/* Initialize the list. */\nstatic inline void dill_slist_init(struct dill_slist *self) {\n    self->next = self;\n}\n\n/* True if the list has no items. */\nstatic inline int dill_slist_empty(struct dill_slist *self) {\n    return self->next == self;\n}\n\n/* Returns the next item in the list. If 'it' is the list itself, it returns the\n   first element in the list. If there are no more elements in the list,\n   returns a pointer to the list itself. */\n#define dill_slist_next(it) ((it)->next)\n\n/* Push the item to the beginning of the list. */\nstatic inline void dill_slist_push(struct dill_slist *self,\n      struct dill_slist *item) {\n    item->next = self->next;\n    self->next = item;\n}\n\n/* Pop an item from the beginning of the list. */\nstatic inline struct dill_slist *dill_slist_pop(struct dill_slist *self) {\n    struct dill_slist *item = self->next;\n    self->next = item->next;\n    return item;\n}\n\n#endif\n\n"
        },
        {
          "name": "socks5.c",
          "type": "blob",
          "size": 20.1123046875,
          "content": "/*\n\n  Copyright (c) 2018 Joseph deBlaquiere\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\n#define RFC1928_VER (0x05)\n#define S5METH_NOAUTHREQ (0x00)\n#define S5METH_USERPASS (0x02)\n#define S5METH_NOMETHOD (0xFF) // failure case\n\n#define RFC1929_VER (0x01)\n#define S5AUTH_SUCCESS (0x00)\n#define S5AUTH_FAIL (0xFF) // actually any nonzero value denotes fail\n\n#define S5ADDR_IPV4 (1)\n#define S5ADDR_IPV6 (4)\n#define S5ADDR_NAME (3)\n\n#define S5ADDR_IPV4_SZ (4)\n#define S5ADDR_IPV6_SZ (16)\n\ntypedef struct {\n    uint8_t atyp;\n    uint8_t addr[257];\n    size_t  alen;\n    int     port;\n} _socks5_addr;\n\n#define S5REPLY_MIN (DILL_SOCKS5_SUCCESS)\n#define S5REPLY_MAX (DILL_SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED)\n\nstatic int s5_client_auth(int s, const char *username, const char *password,\n      int64_t deadline) {\n    // ensure socket is bytesstream\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) return -1;\n    // validate input, specifically user and pass, which may be NULL\n    if(username) {\n        if(strlen(username) > 255) {errno = EINVAL; return -1;}\n    }\n    if(password) {\n        if(strlen(password) > 255) {errno = EINVAL; return -1;}\n    }\n    // version identifier/method selection request\n    // client passes list of desired auth methods\n    uint8_t vims[4];\n    size_t vims_len;\n    vims[0] = RFC1928_VER;\n    vims[2] = S5METH_NOAUTHREQ;\n    vims[3] = S5METH_USERPASS;\n    // TODO: Add support for GSSAPI Auth\n    // if we don't have both username and password only request NO AUTH\n    if((!username) || (!password)) {\n        vims[1] = 1; // NMETHODS = 1 (NO AUTH)\n        vims_len = 3;\n    } else {\n        vims[1] = 2; // NMETHODS = 2 (NO AUTH or USER/PASS)\n        vims_len = 4;\n    }\n    int err = dill_bsend(s, (void *)vims, vims_len, deadline);\n    if(dill_slow(err)) return -1;\n    // version identifier/method response\n    // server responds with chosen auth method (or error)\n    uint8_t vimr[2];\n    err = dill_brecv(s, (void *)vimr, 2, deadline);\n    if(dill_slow(err)) return -1;\n    // validate VER in response\n    if(dill_slow(vimr[0] != RFC1928_VER)) {errno = EPROTO; return -1;}\n    switch(vimr[1]) {\n        case S5METH_NOAUTHREQ:\n            // proxy accepted NO AUTH REQ'D, so we're done\n            return 0;\n        case S5METH_USERPASS:\n            dill_assert(!!username);\n            dill_assert(!!password);\n            // USER/PASS AUTH - per RFC 1929\n            // max USER, PASS is 255 bytes (plus 3 bytes for VER, ULEN, PLEN)\n            uint8_t upauth[513];\n            // previously range checked, safe to cast to uint8_t\n            uint8_t ulen = (uint8_t)strlen(username);\n            uint8_t plen = (uint8_t)strlen(password);\n            upauth[0] = RFC1929_VER; // VER = 1\n            upauth[1] = ulen; // ULEN\n            strcpy((char *)(upauth + 2), username); // UNAME\n            upauth[2 + ulen] = plen; // PLEN\n            strcpy((char *)(upauth + 3 + ulen), password); // PASSWD\n            err = dill_bsend(s, (void *)upauth, 3 + ulen + plen, deadline);\n            if(dill_slow(err)) return -1;\n            uint8_t upauthr[2];\n            err = dill_brecv(s, (void *)upauthr, 2, deadline);\n            if(dill_slow(err)) return -1;\n            if(dill_slow(upauthr[0] != RFC1929_VER)) {errno = EPROTO; return -1;}\n            if(dill_slow(upauthr[1] != S5AUTH_SUCCESS)) {errno = EACCES; return -1;}\n            return 0;\n        case 0xFF:\n            errno = EACCES; return -1;\n        default:\n            // something is fishy as the proxy accepted something not requested\n            dill_assert(0);\n    }\n    return -1;\n}\n\nint dill_socks5_proxy_auth(int s, dill_socks5_auth_function *auth_fn,\n      int64_t deadline) {\n    // all responses are 2 octets\n    uint8_t resp[2];\n    // ensure socket is bytesstream\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) return -1;\n    // max version identification/message selection message is 257 octets\n    uint8_t vims[257];\n    // read first 2 octets of vims request (2nd byte is length)\n    int err = dill_brecv(s, (void *)vims, 2, deadline);\n    if(dill_slow(err)) return -1;\n    // validate VER\n    if(dill_slow(vims[0] != RFC1928_VER)) {errno = EPROTO; return -1;}\n    err = dill_brecv(s, (void *)&(vims[2]), vims[1], deadline);\n    if(dill_slow(err)) return -1;\n    int req_up = 0;\n    int req_na = 0;\n    for (int i = 0; i < vims[1]; i++) {\n        switch(vims[2+i]) {\n            case S5METH_NOAUTHREQ:\n                req_na = 1; break;\n            case S5METH_USERPASS:\n                req_up = 1; break;\n            //default:\n                // ignore methods which aren't supported by this implementation\n        }\n    }\n    if(req_na) {\n        if(!auth_fn) {\n            goto accept_noauth;\n        }\n    }\n    if((req_up) && (auth_fn)) {\n        resp[0] = RFC1928_VER;\n        resp[1] = S5METH_USERPASS;\n        err = dill_bsend(s, (void *)resp, 2, deadline);\n        if(dill_slow(err)) return -1;\n        // max size 513 (plus 1 for terminating null)\n        uint8_t authr[514];\n        // read 2 octets of RFC 1929 auth request, VER, ULEN\n        err = dill_brecv(s, (void *)authr, 2, deadline);\n        if(dill_slow(err)) return -1;\n        // VER for U/P auth is 0x01\n        if(dill_slow(authr[0] != RFC1929_VER)) {errno = EPROTO; return -1;}\n        int ulen = authr[1];\n        // read UNAME\n        err = dill_brecv(s, (void *)&(authr[2]), ulen, deadline);\n        if(dill_slow(err)) return -1;\n        // read PLEN\n        err = dill_brecv(s, (void *)&(authr[2+ulen]), 1, deadline);\n        if(dill_slow(err)) return -1;\n        int plen = authr[2+ulen];\n        // read PASSWD\n        err = dill_brecv(s, (void *)&(authr[3+ulen]), plen, deadline);\n        if(dill_slow(err)) return -1;\n        // add null terminators in place\n        authr[2+ulen] = 0x00;\n        authr[3+ulen+plen] = 0x00;\n        char *uname = (char *)&authr[2];\n        char *passwd = (char *)&authr[3+ulen];\n        // attempt to determine source address\n        if((*auth_fn)(uname, passwd)) {\n            // auth accepted based on uname, passwd, ipaddr\n            goto pwauth_success;\n        }\n        // PW auth fail\n        resp[0] = RFC1929_VER; // VER\n        resp[1] = S5AUTH_FAIL;\n        err = dill_bsend(s, (void *)resp, 2, deadline);\n        if(dill_slow(err)) return -1;\n        return -1;\n    }\n    // no compatible AUTH (auth fail)\n    resp[0] = RFC1928_VER; // VER\n    resp[1] = S5METH_NOMETHOD;\n    err = dill_bsend(s, (void *)resp, 2, deadline);\n    if(dill_slow(err)) return -1;\n    return -1;\naccept_noauth:\n    // accept NOAUTH, no further auth req'd\n    resp[0] = RFC1928_VER; // VER\n    resp[1] = S5METH_NOAUTHREQ;\n    err = dill_bsend(s, (void *)resp, 2, deadline);\n    if(dill_slow(err)) return -1;\n    return 0;\npwauth_success:\n    // accept NOAUTH, no further auth req'd\n    resp[0] = RFC1929_VER; // U/P auth VER\n    resp[1] = S5AUTH_SUCCESS;\n    err = dill_bsend(s, (void *)resp, 2, deadline);\n    if(dill_slow(err)) return -1;\n    return 0;\n}\n\n// convenience functions for handling socks5 address types\n\nstatic int s5_ipaddr_to_s5addr(_socks5_addr *s5, struct dill_ipaddr *addr) {\n    switch(dill_ipaddr_family(addr)) {\n        case AF_INET: {\n            struct sockaddr_in *ipv4 = (struct sockaddr_in*)addr;\n            s5->atyp = S5ADDR_IPV4;\n            s5->alen = sizeof(ipv4->sin_addr);\n            s5->port = dill_ipaddr_port(addr);\n            dill_assert(s5->alen == 4);\n            memcpy((void *)s5->addr, (void *)&ipv4->sin_addr, s5->alen);\n            return 0;}\n        case AF_INET6: {\n            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)addr;\n            s5->atyp = S5ADDR_IPV6;\n            s5->alen = sizeof(ipv6->sin6_addr);\n            s5->port = dill_ipaddr_port(addr);\n            dill_assert(s5->alen == 16);\n            memcpy((void *)s5->addr, (void *)&ipv6->sin6_addr, s5->alen);\n            return 0;}\n    }\n    return -1;\n}\n\nstatic int s5_s5addr_to_ipaddr(struct dill_ipaddr *addr, _socks5_addr *s5,\n      int64_t deadline) {\n    int err;\n    if((s5->port < 0) || (s5->port > 65535)) {errno = EINVAL; return -1;}\n    switch(s5->atyp){\n        case S5ADDR_IPV4:\n            // create with generic IPV4\n            err = dill_ipaddr_remote(addr, \"127.0.0.1\", s5->port,\n                DILL_IPADDR_IPV4, deadline);\n            if(err) return -1;\n            // overwrite with actual IPV4\n            struct sockaddr_in *ipv4 = (struct sockaddr_in*)addr;\n            memcpy((void *)&ipv4->sin_addr, (void *)s5->addr, s5->alen);\n            break;\n        case S5ADDR_IPV6:\n            // create with generic IPV6\n            err = dill_ipaddr_remote(addr, \"::1\", s5->port,\n                DILL_IPADDR_IPV6, deadline);\n            if(err) return -1;\n            // overwrite with actual IPV4\n            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)addr;\n            memcpy((void *)&ipv6->sin6_addr, (void *)s5->addr, s5->alen);\n            break;\n        case S5ADDR_NAME:\n            // It's a name... look it up.\n            // addr is sized to always have room for a null terminator\n            err = dill_ipaddr_remote(addr, (const char*)&(s5->addr[0]),\n                s5->port, DILL_IPADDR_PREF_IPV4, deadline);\n            if(err) return -1;\n        break;\n    }\n    return 0;\n}\n\n// command request and response packets have the same\n// variable length structure (and max length = 262)\nstatic int s5_recv_command_request_response(int s, uint8_t *conn, int64_t deadline) {\n    int err = dill_brecv(s, conn, 4, deadline);\n    if(dill_slow(err)) return -1;\n    if(conn[0] != RFC1928_VER) {errno = EPROTO; return -1;} // VER\n    // don't validate CMD/REP field, range depends on CMD or REP\n    if(conn[2] != 0x00) {errno = EPROTO; return -1;} // RSV\n    switch (conn[3]) {\n        case S5ADDR_IPV4:\n            // IPv4, read 4 byte IP + 2 bytes port\n            err = dill_brecv(s, conn + 4, 6, deadline);\n            if(dill_slow(err)) return -1;\n            break;\n        case S5ADDR_IPV6:\n            // IPv6, read 16 bytes IP + 2 bytes port\n            err = dill_brecv(s, conn + 4, 18, deadline);\n            if(dill_slow(err)) return -1;\n            break;\n        case S5ADDR_NAME:\n            // Domain name, first byte is length of string\n            err = dill_brecv(s, conn + 4, 1, deadline);\n            if(dill_slow(err)) return -1;\n            // Read string + 2 bytes for port\n            err = dill_brecv(s, conn + 5, conn[4] + 2, deadline);\n            if(dill_slow(err)) return -1;\n            break;\n        default:\n            errno = EPROTO;\n            return -1;\n    }\n    return 0;\n}\n\nstatic int s5_handle_connection_response(int s, int64_t deadline) {\n    // ensure socket is bytesstream\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) return -1;\n    // largest possible connect response = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    int err = s5_recv_command_request_response(s, conn, deadline);\n    if(err) return -1;\n    // validate REP\n    switch (conn[1]) {\n        case 0x00: // Success!\n            return 0;\n        case 0x01: // general SOCKS server failure\n            errno = EIO; break;\n        case 0x02: // connection not allowed by ruleset\n            errno = EACCES; break;\n        case 0x03: // Network unreachable\n            errno = ENETUNREACH; break;\n        case 0x04: // Host unreachable\n            errno = EHOSTUNREACH; break;\n        case 0x05: // Connection Refused\n            errno = ECONNREFUSED; break;\n        case 0x06: // TTL expired\n            errno = ETIMEDOUT; break;\n        case 0x07: // Command not supported\n            errno = EOPNOTSUPP; break;\n        case 0x08: // Address type not supported\n            errno = EAFNOSUPPORT; break;\n        default: // Unknown error code\n            errno = EPROTO;\n    }\n    return -1;\n}\n\nstatic int s5_client_connectbyname(int s, const char *hostname, int port, int64_t deadline) {\n    // ensure socket is bytesstream\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) return -1;\n    // validate input\n    if(dill_slow(!hostname)) {errno = EINVAL; return -1;}\n    if(dill_slow(strlen(hostname) > 255)) {errno = EINVAL; return -1;}\n    if((port <= 0) || (port>65535)) {errno = EINVAL; return -1;}\n    // largest possible connect request = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    size_t conn_len;\n    conn[0] = RFC1928_VER; // VER\n    conn[1] = DILL_SOCKS5_CONNECT; // CMD\n    conn[2] = 0x00; // RSV\n    struct in_addr ina4;\n    struct in6_addr ina6;\n    // if \"hostname\" is actually an IPV4/IPV6 literal, convert for proxy\n    if(inet_pton(AF_INET, hostname, &ina4) == 1) {\n        // IPv4 Address, now stored in ina4, Network Byte Order\n        conn[3] = S5ADDR_IPV4; // ATYP\n        memcpy((void *)(conn + 4), (void *)&ina4, 4);\n        conn[8] = port >> 8;\n        conn[9] = port & 0xFF;\n        conn_len = 10;\n    } else if(inet_pton(AF_INET6, hostname, &ina6) == 1) {\n        // IPv6 Address, now stored in ina6, Network Byte Order\n        conn[3] = S5ADDR_IPV6; // ATYP\n        memcpy((void *)(conn + 4), (void *)&ina6, 16);\n        conn[20] = port >> 8;\n        conn[21] = port & 0xFF;\n        conn_len = 22;\n   } else {\n        // assume a resolvable domain name\n        // previously validate to be 0 < x <= 255 bytes\n        uint8_t alen = (uint8_t)strlen(hostname);\n        conn[3] = S5ADDR_NAME; // ATYP\n        conn[4] = alen;\n        memcpy((void *)(conn+ 5), (void *)hostname, alen);\n        conn[5+alen] = port >> 8;\n        conn[6+alen] = port & 0xFF;\n        conn_len = 7 + alen;\n    }\n    int err = dill_bsend(s, conn, conn_len, deadline);\n    if(dill_slow(err)) return -1;\n    return s5_handle_connection_response(s, deadline);\n}\n\nstatic int s5_client_connect(int s, struct dill_ipaddr *ipaddr, int64_t deadline) {\n    // ensure socket is bytesstream\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) return -1;\n    // validate input\n    if(dill_slow(!ipaddr)) {errno = EINVAL; return -1;}\n    // largest possible connect request = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    conn[0] = RFC1928_VER; // VER\n    conn[1] = DILL_SOCKS5_CONNECT; // CMD\n    conn[2] = 0x00; // RSV\n    _socks5_addr s5addr;\n    int err = s5_ipaddr_to_s5addr(&s5addr, ipaddr);\n    if(dill_slow(err)) return -1;\n    conn[3] = s5addr.atyp; // ATYP;\n    int alen = s5addr.alen;\n    memcpy((void *)&conn[4], (void *)s5addr.addr, alen);\n    conn[4+alen] = s5addr.port >> 8;\n    conn[5+alen] = s5addr.port & 0xFF;\n    err = dill_bsend(s, conn, alen+6, deadline);\n    if(dill_slow(err)) return -1;\n    return s5_handle_connection_response(s, deadline);\n}\n\nint dill_socks5_proxy_recvcommand(int s, struct dill_ipaddr *ipaddr,\n      int64_t deadline) {\n    // largest possible connect request = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    int err = s5_recv_command_request_response(s, conn, deadline);\n    if(err) return -1;\n    if((conn[1] < DILL_SOCKS5_CONNECT) || (conn[1] > DILL_SOCKS5_UDP_ASSOCIATE)) {\n        errno = EPROTO ; return -1;\n    }\n    _socks5_addr s5addr;\n    s5addr.atyp = conn[3];\n    uint16_t *port = NULL;\n    switch(s5addr.atyp) {\n        case S5ADDR_IPV4:\n            memcpy((void *)&(s5addr.addr), (void *)&(conn[4]), S5ADDR_IPV4_SZ);\n            s5addr.alen = S5ADDR_IPV4_SZ;\n            port = (uint16_t *)&(conn[4 + S5ADDR_IPV4_SZ]);\n            break;\n        case S5ADDR_IPV6:\n            memcpy((void *)&(s5addr.addr), (void *)&(conn[4]), S5ADDR_IPV6_SZ);\n            s5addr.alen = S5ADDR_IPV6_SZ;\n            port = (uint16_t *)&(conn[4 + S5ADDR_IPV6_SZ]);\n            break;\n        case S5ADDR_NAME:\n            // first octet is len\n            memcpy((void *)&(s5addr.addr), (void *)&(conn[5]), conn[4]);\n            // add null terminator\n            s5addr.addr[conn[4]] = '\\x00';\n            s5addr.alen = conn[4];\n            port = (uint16_t *)&(conn[4 + 1 + conn[4]]);\n            break;\n    }\n    s5addr.port = (int)ntohs(*port);\n    err = s5_s5addr_to_ipaddr(ipaddr, &s5addr, deadline);\n    if(err) return -1;\n    return conn[1];\n}\n\nint dill_socks5_proxy_recvcommandbyname(int s, char *host, int *port,\n      int64_t deadline) {\n    // largest possible connect request = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    int err = s5_recv_command_request_response(s, conn, deadline);\n    if(err) return -1;\n    if((conn[1] < DILL_SOCKS5_CONNECT) || (conn[1] > DILL_SOCKS5_UDP_ASSOCIATE)) {\n        errno = EPROTO ; return -1;\n    }\n    uint16_t *s5port = NULL;\n    switch(conn[3]) {\n        case S5ADDR_IPV4:\n            inet_ntop(AF_INET, (void *)&(conn[4]), host, 256);\n            s5port = (uint16_t *)&(conn[4 + S5ADDR_IPV4_SZ]);\n            break;\n        case S5ADDR_IPV6:\n            inet_ntop(AF_INET6, (void *)&(conn[4]), host, 256);\n            s5port = (uint16_t *)&(conn[4 + S5ADDR_IPV6_SZ]);\n            break;\n        case S5ADDR_NAME:\n            // first octet is len\n            memcpy((void *)host, (void *)&(conn[5]), conn[4]);\n            // add null terminator\n            host[conn[4]] = '\\x00';\n            s5port = (uint16_t *)&(conn[4 + 1 + conn[4]]);\n            break;\n    }\n    *port = (int)ntohs(*s5port);\n    return conn[1];\n}\n\nint dill_socks5_proxy_sendreply(int s, int reply, struct dill_ipaddr *ipaddr,\n      int64_t deadline) {\n    if(dill_slow((reply < S5REPLY_MIN) || (reply > S5REPLY_MAX))) {\n        errno = EINVAL; return -1;\n    }\n    _socks5_addr s5addr;\n    int err = s5_ipaddr_to_s5addr(&s5addr, ipaddr);\n    if(dill_slow(err)) return -1;\n    // largest possible connect request = 255 chars for name + 7 bytes for\n    // VER, CMD, RSV, ATYP, ALEN, PORT[2]\n    uint8_t conn[262];\n    conn[0] = RFC1928_VER; // VER\n    conn[1] = reply; // CMD\n    conn[2] = 0x00; // RSV\n    conn[3] = s5addr.atyp;\n    int alen = s5addr.alen;\n    switch(s5addr.atyp) {\n        case S5ADDR_IPV4:\n            memcpy((void *)&(conn[4]), (void *)&(s5addr.addr), S5ADDR_IPV4_SZ);\n            break;\n        case S5ADDR_IPV6:\n            memcpy((void *)&(conn[4]), (void *)&(s5addr.addr), S5ADDR_IPV6_SZ);\n            break;\n        case S5ADDR_NAME:\n            conn[4] = alen;\n            memcpy((void *)&(conn[5]), (void *)&(s5addr.addr), alen);\n            alen += 1;\n            break;\n        default:\n            dill_assert(0);\n    }\n    conn[4+alen] = s5addr.port >> 8;\n    conn[5+alen] = s5addr.port & 0xFF;\n    err = dill_bsend(s, conn, alen+6, deadline);\n    if(dill_slow(err)) return -1;\n    return 0;\n}\n\nint dill_socks5_client_connect(int s, const char *username,\n      const char *password, struct dill_ipaddr *addr, int64_t deadline) {\n    int err = s5_client_auth(s, username, password, deadline);\n    if(err < 0) return -1;\n    err = s5_client_connect(s, addr, deadline);\n    if(err != 0) return -1;\n    return 0;\n}\n\nint dill_socks5_client_connectbyname(int s, const char *username,\n      const char *password, const char *hostname, int port,\n      int64_t deadline) {\n    int err = s5_client_auth(s, username, password, deadline);\n    if(err < 0) return -1;\n    err = s5_client_connectbyname(s, hostname, port, deadline);\n    if(err != 0) return -1;\n    return 0;\n}\n"
        },
        {
          "name": "stack.c",
          "type": "blob",
          "size": 5.048828125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n#include \"stack.h\"\n#include \"utils.h\"\n#include \"ctx.h\"\n\n/* The stacks are cached. The advantage of this is twofold. First, caching is\n   faster than malloc(). Second, it results in fewer calls to\n   mprotect(). */\n\n/* Stack size in bytes. */\nstatic size_t dill_stack_size = 256 * 1024;\n/* Maximum number of unused cached stacks. Must be at least 1. */\nstatic int dill_max_cached_stacks = 64;\n\n/* Returns the smallest value that's greater than val and is a multiple of unit. */\nstatic size_t dill_align(size_t val, size_t unit) {\n    return val % unit ? val + unit - val % unit : val;\n}\n\n/* Get memory page size. The query is done once. The value is cached. */\nstatic size_t dill_page_size(void) {\n    static long pgsz = 0;\n    if(dill_fast(pgsz))\n        return (size_t)pgsz;\n    pgsz = sysconf(_SC_PAGE_SIZE);\n    dill_assert(pgsz > 0);\n    return (size_t)pgsz;\n}\n\nint dill_ctx_stack_init(struct dill_ctx_stack *ctx) {\n    ctx->count = 0;\n    dill_slist_init(&ctx->cache);\n    return 0;\n}\n\nvoid dill_ctx_stack_term(struct dill_ctx_stack *ctx) {\n    /* Deallocate leftover coroutines. */\n    struct dill_slist *it;\n    while((it = dill_slist_pop(&ctx->cache)) != &ctx->cache) {\n#if (HAVE_POSIX_MEMALIGN && HAVE_MPROTECT) & !defined DILL_NOGUARD\n        void *ptr = ((uint8_t*)(it + 1)) - dill_stack_size - dill_page_size();\n        int rc = mprotect(ptr, dill_page_size(), PROT_READ|PROT_WRITE);\n        dill_assert(rc == 0);\n        free(ptr);\n#else\n        void *ptr = ((uint8_t*)(it + 1)) - dill_stack_size;\n        free(ptr);\n#endif\n    }\n}\n\nvoid *dill_allocstack(size_t *stack_size) {\n    struct dill_ctx_stack *ctx = &dill_getctx->stack;\n    if(stack_size)\n        *stack_size = dill_stack_size;\n    /* If there's a cached stack, use it. */\n    if(!dill_slist_empty(&ctx->cache)) {\n        --ctx->count;\n        return (void*)(dill_slist_pop(&ctx->cache) + 1);\n    }\n    /* Allocate a new stack. */\n    uint8_t *top;\n#if (HAVE_POSIX_MEMALIGN && HAVE_MPROTECT) & !defined DILL_NOGUARD\n    /* Allocate the stack so that it's memory-page-aligned.\n       Add one page as a stack overflow guard. */\n    size_t sz = dill_align(dill_stack_size, dill_page_size()) +\n        dill_page_size();\n    uint8_t *ptr;\n    int rc = posix_memalign((void**)&ptr, dill_page_size(), sz);\n    if(dill_slow(rc != 0)) {\n        errno = rc;\n        return NULL;\n    }\n    /* The bottom page is used as a stack guard. This way a stack overflow will\n       cause a segfault instead of randomly overwriting the heap. */\n    rc = mprotect(ptr, dill_page_size(), PROT_NONE);\n    if(dill_slow(rc != 0)) {\n        int err = errno;\n        free(ptr);\n        errno = err;\n        return NULL;\n    }\n    top = ptr + dill_page_size() + dill_stack_size;\n#else\n    /* Simple allocation without a guard page. */\n    uint8_t *ptr = malloc(dill_stack_size);\n    if(dill_slow(!ptr)) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    top = ptr + dill_stack_size;\n#endif\n    return top;\n}\n\nvoid dill_freestack(void *stack) {\n    struct dill_ctx_stack *ctx = &dill_getctx->stack;\n    struct dill_slist *item = ((struct dill_slist*)stack) - 1;\n    /* If the cache is full we will deallocate one stack from the cache.\n       We can't deallocate the stack passed to this function directly because\n       this very function can be still executing on that stack. */\n    if(ctx->count >= dill_max_cached_stacks) {\n        struct dill_slist *old = dill_slist_pop(&ctx->cache);\n        --ctx->count;\n#if (HAVE_POSIX_MEMALIGN && HAVE_MPROTECT) & !defined DILL_NOGUARD\n        void *ptr = ((uint8_t*)(old + 1)) - dill_stack_size - dill_page_size();\n        int rc = mprotect(ptr, dill_page_size(), PROT_READ|PROT_WRITE);\n        dill_assert(rc == 0);\n        free(ptr);\n#else\n        void *ptr = ((uint8_t*)(old + 1)) - dill_stack_size;\n        free(ptr);\n#endif\n    }\n    /* Put the stack into the cache. */\n    dill_slist_push(&ctx->cache, item);\n    ++ctx->count;\n}\n\n"
        },
        {
          "name": "stack.h",
          "type": "blob",
          "size": 1.90625,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_STACK_INCLUDED\n#define DILL_STACK_INCLUDED\n\n#include <stddef.h>\n\n#include \"slist.h\"\n\n/* A stack of unused coroutine stacks. This allows for extra-fast allocation\n   of a new stack. The LIFO nature of this structure minimises cache misses.\n   When the stack is cached its dill_qlist_item is placed on its top rather\n   then on the bottom. That way we minimise page misses. */\nstruct dill_ctx_stack {\n    int count;\n    struct dill_slist cache;\n};\n\nint dill_ctx_stack_init(struct dill_ctx_stack *ctx);\nvoid dill_ctx_stack_term(struct dill_ctx_stack *ctx);\n\n/* Allocates new stack. Returns pointer to the *top* of the stack.\n   For now we assume that the stack grows downwards. */\nvoid *dill_allocstack(size_t *stack_size);\n\n/* Deallocates a stack. The argument is pointer to the top of the stack. */\nvoid dill_freestack(void *stack);\n\n#endif\n"
        },
        {
          "name": "suffix.c",
          "type": "blob",
          "size": 6.8447265625,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_suffix_type);\n\nstatic void *dill_suffix_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_suffix_hclose(struct dill_hvfs *hvfs);\nstatic int dill_suffix_msendl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic ssize_t dill_suffix_mrecvl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_suffix_sock {\n    struct dill_hvfs hvfs;\n    struct dill_msock_vfs mvfs;\n    int u;\n    /* Given that we are doing one recv call per byte, let's cache the pointer\n       to bsock interface of the underlying socket to make it faster. */\n    struct dill_bsock_vfs *uvfs;\n    uint8_t buf[32];\n    uint8_t suffix[32];\n    size_t suffixlen;\n    unsigned int inerr : 1;\n    unsigned int outerr : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_suffix_sock, dill_suffix_storage)\n\nstatic void *dill_suffix_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_suffix_sock *self = (struct dill_suffix_sock*)hvfs;\n    if(type == dill_msock_type) return &self->mvfs;\n    if(type == dill_suffix_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_suffix_attach_mem(int s, const void *suffix, size_t suffixlen,\n      struct dill_suffix_storage *mem) {\n    int err;\n    if(dill_slow(!mem || !suffix || suffixlen == 0 || suffixlen > 32)) {\n        err = EINVAL; goto error;}\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Create the object. */\n    struct dill_suffix_sock *self = (struct dill_suffix_sock*)mem;\n    self->hvfs.query = dill_suffix_hquery;\n    self->hvfs.close = dill_suffix_hclose;\n    self->mvfs.msendl = dill_suffix_msendl;\n    self->mvfs.mrecvl = dill_suffix_mrecvl;\n    self->u = s;\n    self->uvfs = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!self->uvfs && errno == ENOTSUP)) {err = EPROTO; goto error;}\n    if(dill_slow(!self->uvfs)) {err = errno; goto error;}\n    memcpy(self->suffix, suffix, suffixlen);\n    self->suffixlen = suffixlen;\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Create the handle. */\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_suffix_attach(int s, const void *suffix, size_t suffixlen) {\n    int err;\n    struct dill_suffix_sock *obj = malloc(sizeof(struct dill_suffix_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_suffix_attach_mem(s, suffix, suffixlen,\n        (struct dill_suffix_storage*)obj);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_suffix_detach(int s, int64_t deadline) {\n    int err;\n    struct dill_suffix_sock *self = dill_hquery(s, dill_suffix_type);\n    if(dill_slow(!self)) {err = errno; goto error;}\n    if(dill_slow(self->inerr || self->outerr)) {err = ECONNRESET; goto error;}\n    int u = self->u;\n    if(!self->mem) free(self);\n    return u;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nstatic int dill_suffix_msendl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_suffix_sock *self = dill_cont(mvfs, struct dill_suffix_sock,\n        mvfs);\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    /* TODO: Make sure that message doesn't contain suffix sequence. */\n    struct dill_iolist iol = {self->suffix, self->suffixlen, NULL, 0};\n    last->iol_next = &iol;\n    int rc = self->uvfs->bsendl(self->uvfs, first, &iol, deadline);\n    last->iol_next = NULL;\n    if(dill_slow(rc < 0)) {self->outerr = 1; return -1;}\n    return 0;\n}\n\nstatic ssize_t dill_suffix_mrecvl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_suffix_sock *self = dill_cont(mvfs, struct dill_suffix_sock,\n        mvfs);\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    /* First fill in the temporary buffer. */\n    struct dill_iolist iol = {self->buf, self->suffixlen, NULL, 0};\n    int rc = self->uvfs->brecvl(self->uvfs, &iol, &iol, deadline);\n    if(dill_slow(rc < 0)) {self->inerr = 1; return -1;}\n    /* Read the input, character by character. */\n    iol.iol_base = self->buf + self->suffixlen - 1;\n    iol.iol_len = 1;\n    size_t sz = 0;\n    struct dill_iolist it = *first;\n    while(1) {\n        /* Check for suffix. */\n        if(memcmp(self->buf, self->suffix, self->suffixlen) == 0) break;\n        /* Ignore empty iolist items. */\n        while(first->iol_len == 0) {\n            if(!it.iol_next) {self->inerr = 1; errno = EMSGSIZE; return -1;}\n            it = *it.iol_next;\n        }\n        /* Move one character to the user's iolist. */\n        if(it.iol_base && it.iol_len > 0) {\n            ((uint8_t*)it.iol_base)[0] = self->buf[0];\n            it.iol_base = ((uint8_t*)it.iol_base) + 1;\n            it.iol_len--;\n        }\n        /* Read new character into the temporary buffer. */\n        memmove(self->buf, self->buf + 1, self->suffixlen - 1);\n        rc = self->uvfs->brecvl(self->uvfs, &iol, &iol, deadline);\n        if(dill_slow(rc < 0)) {self->inerr = 1; return -1;}\n        sz++;\n    }\n    return sz;\n}\n\nstatic void dill_suffix_hclose(struct dill_hvfs *hvfs) {\n    struct dill_suffix_sock *self = (struct dill_suffix_sock*)hvfs;\n    if(dill_fast(self->u >= 0)) {\n        int rc = dill_hclose(self->u);\n        dill_assert(rc == 0);\n    }\n    if(!self->mem) free(self);\n}\n\n"
        },
        {
          "name": "tcp.c",
          "type": "blob",
          "size": 14.291015625,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"fd.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_tcp_type);\ndill_unique_id(dill_tcp_listener_type);\n\n/******************************************************************************/\n/*  TCP connection socket                                                     */\n/******************************************************************************/\n\nstatic void *dill_tcp_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_tcp_hclose(struct dill_hvfs *hvfs);\nstatic int dill_tcp_bsendl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic int dill_tcp_brecvl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_tcp_conn {\n    struct dill_hvfs hvfs;\n    struct dill_bsock_vfs bvfs;\n    int fd;\n    struct dill_fd_rxbuf rxbuf;\n    unsigned int rbusy : 1;\n    unsigned int sbusy : 1;\n    unsigned int indone : 1;\n    unsigned int outdone: 1;\n    unsigned int inerr : 1;\n    unsigned int outerr : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_tcp_conn, dill_tcp_storage)\n\nstatic void *dill_tcp_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_tcp_conn *self = (struct dill_tcp_conn*)hvfs;\n    if(type == dill_bsock_type) return &self->bvfs;\n    if(type == dill_tcp_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nstatic int dill_tcp_makeconn(int fd, void *mem) {\n    /* Create the object. */\n    struct dill_tcp_conn *self = (struct dill_tcp_conn*)mem;\n    self->hvfs.query = dill_tcp_hquery;\n    self->hvfs.close = dill_tcp_hclose;\n    self->bvfs.bsendl = dill_tcp_bsendl;\n    self->bvfs.brecvl = dill_tcp_brecvl;\n    self->fd = fd;\n    dill_fd_initrxbuf(&self->rxbuf);\n    self->rbusy = 0;\n    self->sbusy = 0;\n    self->indone = 0;\n    self->outdone = 0;\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Create the handle. */\n    return dill_hmake(&self->hvfs);\n}\n\nint dill_tcp_fromfd_mem(int fd, struct dill_tcp_storage *mem) {\n    int err;\n    if(dill_slow(!mem || fd < 0)) {err = EINVAL; goto error1;}\n    /* Make sure that the supplied file descriptor is of correct type. */\n    int rc = dill_fd_check(fd, SOCK_STREAM, AF_INET, AF_INET6, 0);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Take ownership of the file descriptor. */\n    fd = dill_fd_own(fd);\n    if(dill_slow(fd < 0)) {err = errno; goto error1;}\n    /* Set the socket to non-blocking mode */\n    rc = dill_fd_unblock(fd);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Create the handle */\n    int h = dill_tcp_makeconn(fd, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error1;}\n    /* Return the handle */\n    return h;\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_fromfd(int fd) {\n    int err;\n    struct dill_tcp_conn *obj = malloc(sizeof(struct dill_tcp_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_tcp_fromfd_mem(fd, (struct dill_tcp_storage*)obj);\n    if (dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_connect_mem(const struct dill_ipaddr *addr,\n        struct dill_tcp_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Open a socket. */\n    int s = socket(dill_ipaddr_family(addr), SOCK_STREAM, 0);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    int rc = dill_fd_unblock(s);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Connect to the remote endpoint. */\n    rc = dill_fd_connect(s, dill_ipaddr_sockaddr(addr), dill_ipaddr_len(addr),\n        deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Create the handle. */\n    int h = dill_tcp_makeconn(s, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    dill_fd_close(s);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_connect(const struct dill_ipaddr *addr, int64_t deadline) {\n    int err;\n    struct dill_tcp_conn *obj = malloc(sizeof(struct dill_tcp_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_tcp_connect_mem(addr, (struct dill_tcp_storage*)obj, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n\n}\n\nstatic int dill_tcp_bsendl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_tcp_conn *self = dill_cont(bvfs, struct dill_tcp_conn, bvfs);\n    if(dill_slow(self->sbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    self->sbusy = 1;\n    ssize_t sz = dill_fd_send(self->fd, first, last, deadline);\n    self->sbusy = 0;\n    if(dill_fast(sz >= 0)) return sz;\n    self->outerr = 1;\n    return -1;\n}\n\nstatic int dill_tcp_brecvl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_tcp_conn *self = dill_cont(bvfs, struct dill_tcp_conn, bvfs);\n    if(dill_slow(self->rbusy)) {errno = EBUSY; return -1;}\n    if(dill_slow(self->indone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    self->rbusy = 1;\n    int rc = dill_fd_recv(self->fd, &self->rxbuf, first, last, deadline);\n    self->rbusy = 0;\n    if(dill_fast(rc == 0)) return 0;\n    if(errno == EPIPE) self->indone = 1;\n    else self->inerr = 1;\n    return -1;\n}\n\nint dill_tcp_done(int s, int64_t deadline) {\n    struct dill_tcp_conn *self = dill_hquery(s, dill_tcp_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    /* Flushing the tx buffer is done asynchronously on kernel level. */\n    int rc = shutdown(self->fd, SHUT_WR);\n    if(dill_slow(rc < 0)) {\n        if(errno == ENOTCONN) {self->outerr = 1; errno = ECONNRESET; return -1;}\n        if(errno == ENOBUFS) {self->outerr = 1; errno = ENOMEM; return -1;}\n        dill_assert(rc == 0);\n    }\n    self->outdone = 1;\n    return 0;\n}\n\nint dill_tcp_close(int s, int64_t deadline) {\n    int err;\n    /* Listener socket needs no special treatment. */\n    if(dill_hquery(s, dill_tcp_listener_type)) {\n        return dill_hclose(s);\n    }\n    struct dill_tcp_conn *self = dill_hquery(s, dill_tcp_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->inerr || self->outerr)) {err = ECONNRESET; goto error;}\n    /* If not done already, flush the outbound data and start the terminal\n       handshake. */\n    if(!self->outdone) {\n        int rc = dill_tcp_done(s, deadline);\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n    }\n    /* Now we are going to read all the inbound data until we reach end of the\n       stream. That way we can be sure that the peer either received all our\n       data or consciously closed the connection without reading all of it. */\n    int rc = dill_tcp_brecvl(&self->bvfs, NULL, NULL, deadline);\n    dill_assert(rc < 0);\n    if(dill_slow(errno != EPIPE)) {err = errno; goto error;}\n    dill_tcp_hclose(&self->hvfs);\n    return 0;\nerror:\n    dill_tcp_hclose(&self->hvfs);\n    errno = err;\n    return -1;\n}\n\nstatic void dill_tcp_hclose(struct dill_hvfs *hvfs) {\n    struct dill_tcp_conn *self = (struct dill_tcp_conn*)hvfs;\n    dill_fd_close(self->fd);\n    dill_fd_termrxbuf(&self->rxbuf);\n    if(!self->mem) free(self);\n}\n\n/******************************************************************************/\n/*  TCP listener socket                                                       */\n/******************************************************************************/\n\nstatic void *dill_tcp_listener_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_tcp_listener_hclose(struct dill_hvfs *hvfs);\n\nstruct dill_tcp_listener {\n    struct dill_hvfs hvfs;\n    int fd;\n    struct dill_ipaddr addr;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_tcp_listener, dill_tcp_listener_storage)\n\nstatic int dill_tcp_makelistener(int fd, void *mem) {\n    /* Create the object. */\n    struct dill_tcp_listener *self = (struct dill_tcp_listener*)mem;\n    self->hvfs.query = dill_tcp_listener_hquery;\n    self->hvfs.close = dill_tcp_listener_hclose;\n    self->fd = fd;\n    self->mem = 1;\n    /* Create the handle. */\n    return dill_hmake(&self->hvfs);\n}\n\nstatic void *dill_tcp_listener_hquery(struct dill_hvfs *hvfs,\n      const void *type) {\n    struct dill_tcp_listener *self = (struct dill_tcp_listener*)hvfs;\n    if(type == dill_tcp_listener_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_tcp_listener_fromfd(int fd) {\n    int err;\n    struct dill_tcp_listener *obj = malloc(sizeof(struct dill_tcp_listener));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_tcp_listener_fromfd_mem(fd,\n        (struct dill_tcp_listener_storage*)obj);\n    if (dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_listener_fromfd_mem(int fd,\n      struct dill_tcp_listener_storage *mem) {\n    int err;\n    if(dill_slow(!mem || fd < 0)) {err = EINVAL; goto error1;}\n    /* Make sure that the supplied file descriptor is of correct type. */\n    int rc = dill_fd_check(fd, SOCK_STREAM, AF_INET, AF_INET6, 1);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Take ownership of the file descriptor. */\n    fd = dill_fd_own(fd);\n    if(dill_slow(fd < 0)) {err = errno; goto error1;}\n    /* Set the socket to non-blocking mode */\n    rc = dill_fd_unblock(fd);\n    if(dill_slow(rc < 0)) {err = errno; goto error1;}\n    /* Create the handle */\n    int h = dill_tcp_makelistener(fd, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error1;}\n    /* Return the handle */\n    return h;\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_listen_mem(struct dill_ipaddr *addr, int backlog,\n      struct dill_tcp_listener_storage *mem) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Open the listening socket. */\n    int s = socket(dill_ipaddr_family(addr), SOCK_STREAM, 0);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    int rc = dill_fd_unblock(s);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Start listening for incoming connections. */\n    rc = bind(s, dill_ipaddr_sockaddr(addr), dill_ipaddr_len(addr));\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    rc = listen(s, backlog);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* If the user requested an ephemeral port,\n       retrieve the port number assigned by the OS. */\n    if(dill_ipaddr_port(addr) == 0) {\n        struct dill_ipaddr baddr;\n        socklen_t len = sizeof(struct dill_ipaddr);\n        rc = getsockname(s, (struct sockaddr*)&baddr, &len);\n        if(rc < 0) {err = errno; goto error2;}\n        dill_ipaddr_setport(addr, dill_ipaddr_port(&baddr));\n    }\n    int h = dill_tcp_makelistener(s, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    close(s);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_listen(struct dill_ipaddr *addr, int backlog) {\n    int err;\n    struct dill_tcp_listener *obj = malloc(sizeof(struct dill_tcp_listener));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int ls = dill_tcp_listen_mem(addr, backlog,\n        (struct dill_tcp_listener_storage*)obj);\n    if(dill_slow(ls < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return ls;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_accept_mem(int s, struct dill_ipaddr *addr,\n        struct dill_tcp_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Retrieve the listener object. */\n    struct dill_tcp_listener *lst = dill_hquery(s, dill_tcp_listener_type);\n    if(dill_slow(!lst)) {err = errno; goto error1;}\n    /* Try to get new connection in a non-blocking way. */\n    socklen_t addrlen = sizeof(struct dill_ipaddr);\n    int as = dill_fd_accept(lst->fd, (struct sockaddr*)addr, &addrlen,\n        deadline);\n    if(dill_slow(as < 0)) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    int rc = dill_fd_unblock(as);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Create the handle. */\n    int h = dill_tcp_makeconn(as, mem);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    dill_fd_close(as);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_tcp_accept(int s, struct dill_ipaddr *addr, int64_t deadline) {\n    int err;\n    struct dill_tcp_conn *obj = malloc(sizeof(struct dill_tcp_conn));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int as = dill_tcp_accept_mem(s, addr, (struct dill_tcp_storage*)obj,\n        deadline);\n    if(dill_slow(as < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return as;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic void dill_tcp_listener_hclose(struct dill_hvfs *hvfs) {\n    struct dill_tcp_listener *self = (struct dill_tcp_listener*)hvfs;\n    dill_fd_close(self->fd);\n    if(!self->mem) free(self);\n}\n\n"
        },
        {
          "name": "term.c",
          "type": "blob",
          "size": 6.623046875,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include <libdillimpl.h>\n#include \"iol.h\"\n#include \"utils.h\"\n\n#define DILL_MAX_TERMINATOR_LENGTH 32\n\ndill_unique_id(dill_term_type);\n\nstatic void *dill_term_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_term_hclose(struct dill_hvfs *hvfs);\nstatic int dill_term_msendl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic ssize_t dill_term_mrecvl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_term_sock {\n    struct dill_hvfs hvfs;\n    struct dill_msock_vfs mvfs;\n    int u;\n    size_t len;\n    uint8_t buf[DILL_MAX_TERMINATOR_LENGTH];\n    unsigned int indone : 1;\n    unsigned int outdone : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_term_sock, dill_term_storage)\n\nstatic void *dill_term_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_term_sock *self = (struct dill_term_sock*)hvfs;\n    if(type == dill_msock_type) return &self->mvfs;\n    if(type == dill_term_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_term_attach_mem(int s, const void *buf, size_t len,\n      struct dill_term_storage *mem) {\n    int err;\n    if(dill_slow(!mem && len > DILL_MAX_TERMINATOR_LENGTH)) {\n        err = EINVAL; goto error;}\n    if(dill_slow(len > 0 && !buf)) {err = EINVAL; goto error;}\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Check whether underlying socket is message-based. */\n    void *q = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!q && errno == ENOTSUP)) {err = EPROTO; goto error;}\n    if(dill_slow(!q)) {err = errno; goto error;}\n    /* Create the object. */\n    struct dill_term_sock *self = (struct dill_term_sock*)mem;\n    self->hvfs.query = dill_term_hquery;\n    self->hvfs.close = dill_term_hclose;\n    self->mvfs.msendl = dill_term_msendl;\n    self->mvfs.mrecvl = dill_term_mrecvl;\n    self->u = s;\n    self->len = len;\n    memcpy(self->buf, buf, len);\n    self->indone = 0;\n    self->outdone = 0;\n    self->mem = 1;\n    /* Create the handle. */\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_term_attach(int s, const void *buf, size_t len) {\n    int err;\n    struct dill_term_sock *obj = malloc(sizeof(struct dill_term_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_term_attach_mem(s, buf, len, (struct dill_term_storage*)obj);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_term_done(int s, int64_t deadline) {\n    struct dill_term_sock *self = dill_hquery(s, dill_term_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    int rc = dill_msend(self->u, self->buf, self->len, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    self->outdone = 1;\n    return 0;\n}\n\nint dill_term_detach(int s, int64_t deadline) {\n    int err;\n    struct dill_term_sock *self = dill_hquery(s, dill_term_type);\n    if(dill_slow(!self)) return -1;\n    if(!self->outdone) {\n        int rc = dill_term_done(s, deadline);\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n    }\n    if(!self->indone) {\n        while(1) {\n            struct dill_iolist iol = {NULL, SIZE_MAX, NULL, 0};\n            ssize_t sz = dill_term_mrecvl(&self->mvfs, &iol, &iol, deadline);\n            if(sz < 0) {\n                if(errno == EPIPE) break;\n                err = errno;\n                goto error;\n            }\n        }\n    }\n    int u = self->u;\n    if(!self->mem) free(self);\n    return u;\nerror:;\n    int rc = dill_hclose(s);\n    dill_assert(rc == 0);\n    errno = err;\n    return -1;\n}\n\nstatic int dill_term_msendl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_term_sock *self = dill_cont(mvfs, struct dill_term_sock, mvfs);\n    /* TODO: Check that it's not the terminal message. */\n    return dill_msendl(self->u, first, last, deadline);\n}\n\nstatic ssize_t dill_term_mrecvl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_term_sock *self = dill_cont(mvfs, struct dill_term_sock, mvfs);\n    if(self->len == 0) {\n        ssize_t sz = dill_mrecvl(self->u, first, last, deadline);\n        if(dill_slow(sz < 0)) return -1;\n        if(dill_slow(sz == 0)) {\n            self->indone = 1;\n            errno = EPIPE;\n            return -1;\n        }\n        return sz;\n    }\n    struct dill_iolist trimmed = {0};\n    int rc = dill_ioltrim(first, self->len, &trimmed);\n    uint8_t buf[self->len];\n    struct dill_iolist iol = {buf, self->len, rc < 0 ? NULL : &trimmed, 0}; \n    ssize_t sz = dill_mrecvl(self->u, &iol, rc < 0 ? &iol : last, deadline);\n    if(dill_slow(sz < 0)) return -1;\n    if(dill_slow(sz == self->len &&\n          dill_slow(memcmp(self->buf, buf, self->len) == 0))) {\n        self->indone = 1;\n        errno = EPIPE;\n        return -1;\n    }\n    dill_iolto(buf, self->len, first);\n    return sz;\n}\n\nstatic void dill_term_hclose(struct dill_hvfs *hvfs) {\n    struct dill_term_sock *self = (struct dill_term_sock*)hvfs;\n    if(dill_fast(self->u >= 0)) {\n        int rc = dill_hclose(self->u);\n        dill_assert(rc == 0);\n    }\n    if(!self->mem) free(self);\n}\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tls.c",
          "type": "blob",
          "size": 15.908203125,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"utils.h\"\n\n#define DILL_TLS_BUFSIZE 2048\n\ndill_unique_id(dill_tls_type);\n\nstruct dill_tls_sock {\n    struct dill_hvfs hvfs;\n    struct dill_bsock_vfs bvfs;\n    SSL_CTX *ctx;\n    SSL *ssl;\n    int u;\n    int64_t deadline;\n    unsigned int indone : 1;\n    unsigned int outdone: 1;\n    unsigned int inerr : 1;\n    unsigned int outerr : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_tls_sock, dill_tls_storage)\n\nstatic void dill_tls_init(void);\nstatic BIO *dill_tls_new_cbio(void *mem);\nstatic int dill_tls_followup(struct dill_tls_sock *self, int rc);\n\nstatic void *dill_tls_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_tls_hclose(struct dill_hvfs *hvfs);\nstatic int dill_tls_bsendl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic int dill_tls_brecvl(struct dill_bsock_vfs *bvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstatic void *dill_tls_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_tls_sock *self = (struct dill_tls_sock*)hvfs;\n    if(type == dill_bsock_type) return &self->bvfs;\n    if(type == dill_tls_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_tls_attach_client_mem(int s, struct dill_tls_storage *mem,\n      int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Check whether underlying socket is a bytestream. */\n    void *q = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!q && errno == ENOTSUP)) {err = EPROTO; goto error1;}\n    if(dill_slow(!q)) {err = errno; goto error1;}\n    /* Create OpenSSL connection context. */\n    dill_tls_init();\n    const SSL_METHOD *method = SSLv23_method();\n    if(dill_slow(!method)) {err = EFAULT; goto error1;}\n    SSL_CTX *ctx = SSL_CTX_new(method);\n    if(dill_slow(!ctx)) {err = EFAULT; goto error1;}\n    /* Create OpenSSL connection object. */\n    SSL *ssl = SSL_new(ctx);\n    if(dill_slow(!ssl)) {err = EFAULT; goto error2;}\n\t  SSL_set_connect_state(ssl);\n    /* Create a BIO and attach it to the connection. */\n    BIO *bio = dill_tls_new_cbio(mem);\n    if(dill_slow(!bio)) {err = errno; goto error3;}\n\t  SSL_set_bio(ssl, bio, bio);\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Create the object. */\n    struct dill_tls_sock *self = (struct dill_tls_sock*)mem;\n    self->hvfs.query = dill_tls_hquery;\n    self->hvfs.close = dill_tls_hclose;\n    self->bvfs.bsendl = dill_tls_bsendl;\n    self->bvfs.brecvl = dill_tls_brecvl;\n    self->ctx = ctx;\n    self->ssl = ssl;\n    self->u = s;\n    self->deadline = -1;\n    self->indone = 0;\n    self->outdone = 0;\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Initial handshaking. */\n    while(1) {\n        ERR_clear_error();\n        int rc = SSL_connect(ssl);\n        if(dill_tls_followup(self, rc)) break;\n        if(dill_slow(errno != 0)) {err = errno; goto error4;}\n    }\n    /* Create the handle. */\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error4;}\n    return h;\nerror4:\n    BIO_vfree(bio);\nerror3:\n    SSL_free(ssl);\nerror2:\n    SSL_CTX_free(ctx);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_tls_attach_client(int s, int64_t deadline) {\n    int err;\n    struct dill_tls_sock *obj = malloc(sizeof(struct dill_tls_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_tls_attach_client_mem(s, (struct dill_tls_storage*)obj,\n        deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_tls_attach_server_mem(int s, const char *cert, const char *pkey,\n      struct dill_tls_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    /* Check whether underlying socket is a bytestream. */\n    void *q = dill_hquery(s, dill_bsock_type);\n    if(dill_slow(!q && errno == ENOTSUP)) {err = EPROTO; goto error1;}\n    if(dill_slow(!q)) {err = errno; goto error1;}\n    /* Create OpenSSL connection context. */\n    dill_tls_init();\n    const SSL_METHOD *method = SSLv23_server_method();\n    if(dill_slow(!method)) {err = EFAULT; goto error1;}\n    SSL_CTX *ctx = SSL_CTX_new(method);\n    if(dill_slow(!ctx)) {err = EFAULT; goto error1;}\n    int rc = SSL_CTX_set_ecdh_auto(ctx, 1);\n    if(dill_slow(rc != 1)) {err = EFAULT; goto error2;}\n    rc = SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM);\n    if(dill_slow(rc <= 0)) {err = EFAULT; goto error2;}\n    rc = SSL_CTX_use_PrivateKey_file(ctx, pkey, SSL_FILETYPE_PEM);\n    if(dill_slow(rc <= 0 )) {err = EFAULT; goto error2;}\n    /* Create OpenSSL connection object. */\n    SSL *ssl = SSL_new(ctx);\n    if(dill_slow(!ssl)) {err = EFAULT; goto error2;}\n\t  SSL_set_accept_state(ssl);\n    /* Create a BIO and attach it to the connection. */\n    BIO *bio = dill_tls_new_cbio(mem);\n    if(dill_slow(!bio)) {err = errno; goto error3;}\n\t  SSL_set_bio(ssl, bio, bio);\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error1;}\n    /* Create the object. */\n    struct dill_tls_sock *self = (struct dill_tls_sock*)mem;\n    self->hvfs.query = dill_tls_hquery;\n    self->hvfs.close = dill_tls_hclose;\n    self->bvfs.bsendl = dill_tls_bsendl;\n    self->bvfs.brecvl = dill_tls_brecvl;\n    self->ctx = ctx;\n    self->ssl = ssl;\n    self->u = s;\n    self->deadline = -1;\n    self->indone = 0;\n    self->outdone = 0;\n    self->inerr = 0;\n    self->outerr = 0;\n    self->mem = 1;\n    /* Initial handshaking. */\n    while(1) {\n        ERR_clear_error();\n        rc = SSL_accept(ssl);\n        if(dill_tls_followup(self, rc)) break;\n        if(dill_slow(errno != 0)) {err = errno; goto error4;}\n    }\n    /* Create the handle. */\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error4;}\n    return h;\nerror4:\n    BIO_vfree(bio);\nerror3:\n    SSL_free(ssl);\nerror2:\n    SSL_CTX_free(ctx);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_tls_attach_server(int s, const char *cert, const char *pkey,\n      int64_t deadline) {\n    int err;\n    struct dill_tls_sock *obj = malloc(sizeof(struct dill_tls_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_tls_attach_server_mem(s, cert, pkey,\n        (struct dill_tls_storage*)obj, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_tls_done(int s, int64_t deadline) {\n    struct dill_tls_sock *self = dill_hquery(s, dill_tls_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    while(1) {\n        ERR_clear_error();\n        int rc = SSL_shutdown(self->ssl);\n        if(rc == 0) {self->outdone = 1; return 0;}\n        if(rc == 1) {self->outdone = 1; self->indone = 1; return 0;}\n        if(dill_tls_followup(self, rc)) break;\n    }\n    dill_assert(errno != 0);\n    self->outerr = 1;\n    return -1;\n}\n\nint dill_tls_detach(int s, int64_t deadline) {\n    int err;\n    struct dill_tls_sock *self = dill_hquery(s, dill_tls_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->inerr || self->outerr)) {err = ECONNRESET; goto error;}\n    /* Start terminal TLS handshake. */\n    if(!self->outdone) {\n        int rc = dill_tls_done(s, deadline);\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n    }\n    /* Wait for the handshake acknowledgement from the peer. */\n    if(!self->indone) {\n        while(1) {\n            ERR_clear_error();\n            int rc = SSL_shutdown(self->ssl);\n            if(rc == 1) break;\n            if(dill_tls_followup(self, rc)) {err = errno; goto error;}\n        }\n    }\n    int u = self->u;\n    self->u = -1;\n    dill_tls_hclose(&self->hvfs);\n    return u;\nerror:\n    dill_tls_hclose(&self->hvfs);\n    errno = err;\n    return -1;\n}\n\nstatic int dill_tls_bsendl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_tls_sock *self = dill_cont(bvfs, struct dill_tls_sock, bvfs);\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->outerr)) {errno = ECONNRESET; return -1;}\n    self->deadline = deadline;\n    struct dill_iolist *it = first;\n    while(1) {\n        uint8_t *base = it->iol_base;\n        size_t len = it->iol_len;\n        while(len > 0) {\n            ERR_clear_error();\n            int rc = SSL_write(self->ssl, base, len);\n            if(dill_tls_followup(self, rc)) {\n                if(dill_slow(errno != 0)) {\n                    self->outerr = 1;\n                    return -1;\n                }\n                base += rc;\n                len -= rc;\n            }\n        }\n        if(it == last) break;\n        it = it->iol_next;\n    }\n    return 0;\n}\n\nstatic int dill_tls_brecvl(struct dill_bsock_vfs *bvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_tls_sock *self = dill_cont(bvfs, struct dill_tls_sock, bvfs);\n    if(dill_slow(self->indone)) {errno = EPIPE; return -1;}\n    if(dill_slow(self->inerr)) {errno = ECONNRESET; return -1;}\n    self->deadline = deadline;\n    struct dill_iolist *it = first;\n    while(1) {\n        uint8_t *base = it->iol_base;\n        size_t len = it->iol_len;\n        while(1) {\n            ERR_clear_error();\n            int rc = SSL_read(self->ssl, base, len);\n            if(dill_tls_followup(self, rc)) {\n                if(dill_slow(errno != 0)) {\n                    if(errno == EPIPE) self->indone = 1;\n                    else self->inerr = 1;\n                    return -1;\n                }\n                if(rc == len) break;\n                base += rc;\n                len -= rc;\n            }\n        }\n        if(it == last) break;\n        it = it->iol_next;\n    }\n    return 0;\n}\n\nstatic void dill_tls_hclose(struct dill_hvfs *hvfs) {\n    struct dill_tls_sock *self = (struct dill_tls_sock*)hvfs;\n    SSL_free(self->ssl);\n    SSL_CTX_free(self->ctx);\n    if(dill_fast(self->u >= 0)) {\n        int rc = dill_hclose(self->u);\n        dill_assert(rc == 0);\n    }\n    if(!self->mem) free(self);\n}\n\n/******************************************************************************/\n/*  Helpers.                                                                  */\n/******************************************************************************/\n\n/* OpenSSL has huge amount of underspecified errors. It's hard to deal\n   with them in a consistent manner. Morever, you can get multiple of\n   them at the same time. There's nothing better to do than to print them to\n   the stderr and return generic EFAULT error instead. */\nstatic void dill_tls_process_errors(void) {\n    char errstr[512];\n    while(1) {\n        int err = ERR_get_error();\n        if(err == 0) break;\n        ERR_error_string_n(err, errstr, sizeof(errstr));\n        fprintf(stderr, \"SSL error: %s\\n\", errstr);\n    }\n    errno = EFAULT;\n}\n\n/* Do the follow up work after calling a SSL function.\n   Returns 0 if the SSL function has to be restarted, 1 is we are done.\n   In the latter case, error code is in errno.\n   In the case of success errno is set to zero. */\nstatic int dill_tls_followup(struct dill_tls_sock *self, int rc) {\n    int err;\n    char errstr[120];\n    int code = SSL_get_error(self->ssl, rc);\n    switch(code) {\n\t  case SSL_ERROR_NONE:\n        /* Operation finished. */\n        errno = 0;\n        return 1;\n\t  case SSL_ERROR_ZERO_RETURN:\n        /* Connection terminated by peer. */\n        errno = EPIPE;\n        return 1;\n    case SSL_ERROR_SYSCALL:\n        /* Error from our custom BIO. */\n        dill_assert(rc == -1);\n        if(errno == 0) return 0;\n        return 1;\n    case SSL_ERROR_SSL:        \n        dill_tls_process_errors();\n        return 1;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n        /* These two should never happen -- our custom BIO is blocking. */\n        dill_assert(0);\n    default:\n        /* Unexpected error. Let's at least print out current error queue\n           for debugging purposes. */\n        fprintf(stderr, \"SSL error code: %d\\n\", code);\n        dill_tls_process_errors();\n        dill_assert(0);\n    }\n}\n\n/******************************************************************************/\n/*  Custom BIO on top of a bsock.                                             */\n/******************************************************************************/\n\nstatic BIO_METHOD *dill_tls_cbio = NULL;\n\nstatic BIO *dill_tls_new_cbio(void *mem) {\n    BIO *bio = BIO_new(dill_tls_cbio);\n    if(dill_slow(!bio)) {errno = EFAULT; return NULL;}\n    BIO_set_data(bio, mem);\n    BIO_set_init(bio, 1);\n    return bio;\n}\n\nstatic int dill_tls_cbio_create(BIO *bio) {\n    return 1;\n}\n\nstatic int dill_tls_cbio_destroy(BIO *bio) {\n    return 1;\n}\n\nstatic int dill_tls_cbio_write(BIO *bio, const char *buf, int len) {\n    struct dill_tls_sock *self = (struct dill_tls_sock*)BIO_get_data(bio);\n    int rc = dill_bsend(self->u, buf, len, self->deadline);\n    if(dill_slow(rc < 0)) return -1;\n    return len;\n}\n\nstatic int dill_tls_cbio_read(BIO *bio, char *buf, int len) {\n    struct dill_tls_sock *self = (struct dill_tls_sock*)BIO_get_data(bio);\n    int rc = dill_brecv(self->u, buf, len, self->deadline);\n    if(dill_slow(rc < 0)) return -1;\n    return len;\n}\n\nstatic long dill_tls_cbio_ctrl(BIO *bio, int cmd, long larg, void *parg) {\n    switch(cmd) {\n    case BIO_CTRL_FLUSH:\n        return 1;\n    case BIO_CTRL_PUSH:\n    case BIO_CTRL_POP:\n        return 0;\n    default:\n        dill_assert(0);\n    }\n}\n\nstatic void dill_tls_term(void) {\n    BIO_meth_free(dill_tls_cbio);\n    ERR_free_strings();\n    EVP_cleanup();\n}\n\nstatic void dill_tls_init(void) {\n    static int init = 0;\n    if(dill_slow(!init)) {\n        SSL_library_init();\n        SSL_load_error_strings();\n        /* Create our own custom BIO type. */\n        int idx = BIO_get_new_index();\n        dill_tls_cbio = BIO_meth_new(idx, \"bsock\");\n        dill_assert(dill_tls_cbio);\n        int rc = BIO_meth_set_create(dill_tls_cbio, dill_tls_cbio_create);\n        dill_assert(rc == 1);\n        rc = BIO_meth_set_destroy(dill_tls_cbio, dill_tls_cbio_destroy);\n        dill_assert(rc == 1);\n        rc = BIO_meth_set_write(dill_tls_cbio, dill_tls_cbio_write);\n        dill_assert(rc == 1);\n        rc = BIO_meth_set_read(dill_tls_cbio, dill_tls_cbio_read);\n        dill_assert(rc == 1);\n        rc = BIO_meth_set_ctrl(dill_tls_cbio, dill_tls_cbio_ctrl);\n        dill_assert(rc == 1);\n        /* Deallocate the method once the process exits. */\n        rc = atexit(dill_tls_term);\n        dill_assert(rc == 0);\n        init = 1;\n    }\n}\n"
        },
        {
          "name": "tutorial",
          "type": "tree",
          "content": null
        },
        {
          "name": "udp.c",
          "type": "blob",
          "size": 9.23828125,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"fd.h\"\n#include \"iol.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_udp_type);\n\nstatic void *dill_udp_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_udp_hclose(struct dill_hvfs *hvfs);\nstatic int dill_udp_msendl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic ssize_t dill_udp_mrecvl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstruct dill_udp_sock {\n    struct dill_hvfs hvfs;\n    struct dill_msock_vfs mvfs;\n    int fd;\n    struct dill_ipaddr remote;\n    unsigned int busy : 1;\n    unsigned int hasremote : 1;\n    unsigned int mem : 1;\n};\n\nDILL_CHECK_STORAGE(dill_udp_sock, dill_udp_storage)\n\nstatic void *dill_udp_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_udp_sock *obj = (struct dill_udp_sock*)hvfs;\n    if(type == dill_msock_type) return &obj->mvfs;\n    if(type == dill_udp_type) return obj;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_udp_open_mem(struct dill_ipaddr *local,\n      const struct dill_ipaddr *remote, struct dill_udp_storage *mem) {\n    int err;\n    /* Sanity checking. */\n    if(dill_slow(!mem)) {err = EINVAL; goto error1;}\n    if(dill_slow(local && remote &&\n          dill_ipaddr_family(local) != dill_ipaddr_family(remote))) {\n        err = EINVAL; goto error1;}\n    /* Open the listening socket. */\n    int family = AF_INET;\n    if(local) family = dill_ipaddr_family(local);\n    if(remote) family = dill_ipaddr_family(remote);\n    int s = socket(family, SOCK_DGRAM, 0);\n    if(s < 0) {err = errno; goto error1;}\n    /* Set it to non-blocking mode. */\n    int rc = dill_fd_unblock(s);\n    if(dill_slow(rc < 0)) {err = errno; goto error2;}\n    /* Start listening. */\n    if(local) {\n        rc = bind(s, dill_ipaddr_sockaddr(local), dill_ipaddr_len(local));\n        if(s < 0) {err = errno; goto error2;}\n        /* Get the ephemeral port number. */\n        if(dill_ipaddr_port(local) == 0) {\n            struct dill_ipaddr baddr;\n            socklen_t len = sizeof(struct dill_ipaddr);\n            rc = getsockname(s, (struct sockaddr*)&baddr, &len);\n            if(dill_slow(rc < 0)) {err = errno; goto error2;}\n            dill_ipaddr_setport(local, dill_ipaddr_port(&baddr));\n        }\n    }\n    /* Create the object. */\n    struct dill_udp_sock *obj = (struct dill_udp_sock*)mem;\n    obj->hvfs.query = dill_udp_hquery;\n    obj->hvfs.close = dill_udp_hclose;\n    obj->mvfs.msendl = dill_udp_msendl;\n    obj->mvfs.mrecvl = dill_udp_mrecvl;\n    obj->fd = s;\n    obj->busy = 0;\n    obj->hasremote = remote ? 1 : 0;\n    obj->mem = 1;\n    if(remote) obj->remote = *remote;\n    /* Create the handle. */\n    int h = dill_hmake(&obj->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error2;}\n    return h;\nerror2:\n    dill_fd_close(s);\nerror1:\n    errno = err;\n    return -1;\n}\n\nint dill_udp_open(struct dill_ipaddr *local, const struct dill_ipaddr *remote) {\n    int err;\n    struct dill_udp_sock *obj = malloc(sizeof(struct dill_udp_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    int s = dill_udp_open_mem(local, remote, (struct dill_udp_storage*)obj);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    errno = err;\n    return -1;\n}\n\nstatic int dill_udp_sendl_(struct dill_msock_vfs *mvfs,\n      const struct dill_ipaddr *addr,\n      struct dill_iolist *first, struct dill_iolist *last) {\n    struct dill_udp_sock *obj = dill_cont(mvfs, struct dill_udp_sock, mvfs);\n    if(dill_slow(obj->busy)) {errno = EBUSY; return -1;}\n    /* If no destination IP address is provided, fall back to the stored one. */\n    const struct dill_ipaddr *dstaddr = addr;\n    if(!dstaddr) {\n        if(dill_slow(!obj->hasremote)) {errno = EINVAL; return -1;}\n        dstaddr = &obj->remote;\n    }\n    struct msghdr hdr;\n    memset(&hdr, 0, sizeof(hdr));\n    hdr.msg_name = (void*)dill_ipaddr_sockaddr(dstaddr);\n    hdr.msg_namelen = dill_ipaddr_len(dstaddr);\n    /* Make a local iovec array. */\n    /* TODO: This is dangerous, it may cause stack overflow.\n       There should probably be a on-heap per-socket buffer for that. */\n    size_t niov;\n    int rc = dill_iolcheck(first, last, &niov, NULL);\n    if(dill_slow(rc < 0)) return -1;\n    struct iovec iov[niov];\n    dill_ioltoiov(first, iov);\n    hdr.msg_iov = (struct iovec*)iov;\n    hdr.msg_iovlen = niov;\n    ssize_t sz = sendmsg(obj->fd, &hdr, 0);\n    if(dill_fast(sz >= 0)) return 0;\n    if(errno == EAGAIN || errno == EWOULDBLOCK) return 0;\n    return -1;\n}\n\nstatic ssize_t dill_udp_recvl_(struct dill_msock_vfs *mvfs,\n      struct dill_ipaddr *addr,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_udp_sock *obj = dill_cont(mvfs, struct dill_udp_sock, mvfs);\n    if(dill_slow(obj->busy)) {errno = EBUSY; return -1;}\n    struct msghdr hdr;\n    struct dill_ipaddr raddr;\n    memset(&hdr, 0, sizeof(hdr));\n    hdr.msg_name = (void*)&raddr;\n    hdr.msg_namelen = sizeof(struct dill_ipaddr);\n    /* Make a local iovec array. */\n    /* TODO: This is dangerous, it may cause stack overflow.\n       There should probably be a on-heap per-socket buffer for that. */\n    size_t niov;\n    int rc = dill_iolcheck(first, last, &niov, NULL);\n    if(dill_slow(rc < 0)) return -1;\n    struct iovec iov[niov];\n    dill_ioltoiov(first, iov);\n    hdr.msg_iov = (struct iovec*)iov;\n    hdr.msg_iovlen = niov;\n    while(1) {\n        ssize_t sz = recvmsg(obj->fd, &hdr, 0);\n        if(sz >= 0) {\n            /* If remote IP address is specified we'll silently drop all\n               packets coming from different addresses. */\n            if(obj->hasremote && !dill_ipaddr_equal(&raddr, &obj->remote, 0))\n                continue;\n            if(addr) *addr = raddr;\n            return sz;\n        }\n        if(errno != EAGAIN && errno != EWOULDBLOCK) return -1;\n        obj->busy = 1;\n        rc = dill_fdin(obj->fd, deadline);\n        obj->busy = 0;\n        if(dill_slow(rc < 0)) return -1;\n    }\n}\n\nint dill_udp_send(int s, const struct dill_ipaddr *addr,\n      const void *buf, size_t len) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return dill_udp_sendl_(m, addr, &iol, &iol);\n}\n\nssize_t dill_udp_recv(int s, struct dill_ipaddr *addr, void *buf, size_t len,\n      int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return dill_udp_recvl_(m, addr, &iol, &iol, deadline);\n}\n\nint dill_udp_sendl(int s, const struct dill_ipaddr *addr,\n      struct dill_iolist *first, struct dill_iolist *last) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    return dill_udp_sendl_(m, addr, first, last);\n}\n\nssize_t dill_udp_recvl(int s, struct dill_ipaddr *addr,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_msock_vfs *m = dill_hquery(s, dill_msock_type);\n    if(dill_slow(!m)) return -1;\n    return dill_udp_recvl_(m, addr, first, last, deadline);\n}\n\nstatic int dill_udp_msendl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    return dill_udp_sendl_(mvfs, NULL, first, last);\n}\n\nstatic ssize_t dill_udp_mrecvl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    return dill_udp_recvl_(mvfs, NULL, first, last, deadline);\n}\n\nstatic void dill_udp_hclose(struct dill_hvfs *hvfs) {\n    struct dill_udp_sock *obj = (struct dill_udp_sock*)hvfs;\n    /* We do not switch off linger here because if UDP socket was fully\n       implemented in user space, msend() would block until the packet\n       was flushed into network, thus providing some basic reliability.\n       Kernel-space implementation here, on the other hand, may queue\n       outgoing packets rather than flushing them. The effect is balanced\n       out by lingering when closing the socket. */\n    dill_fd_close(obj->fd);\n    if(!obj->mem) free(obj);\n}\n\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 10.6669921875,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n  Copyright (c) 2014 Wirebird Labs LLC.  All rights reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"utils.h\"\n\nvoid dill_print_size(char x) {\n}\n\nint dill_maxfds(void) {\n    /* Get the maximum number of file descriptors. */\n    struct rlimit rlim;\n    int rc = getrlimit(RLIMIT_NOFILE, &rlim);\n    dill_assert(rc == 0);\n    int maxfds = rlim.rlim_max;\n#if defined BSD\n    /* On newer versions of OSX, the above behaves weirdly and returns -1, \n       so use OPEN_MAX instead. */\n    if(maxfds < 0) return OPEN_MAX;\n#endif\n    return maxfds;\n}\n\nuint16_t dill_gets(const uint8_t *buf) {\n    return (((uint16_t)buf[0]) << 8) |\n           ((uint16_t)buf[1]);\n}\n\nvoid dill_puts(uint8_t *buf, uint16_t val) {\n    buf[0] = (uint8_t)(((val) >> 8) & 0xff);\n    buf[1] = (uint8_t)(val & 0xff);\n}\n\nuint32_t dill_getl(const uint8_t *buf) {\n    return (((uint32_t)buf[0]) << 24) |\n           (((uint32_t)buf[1]) << 16) |\n           (((uint32_t)buf[2]) << 8) |\n           ((uint32_t)buf[3]);\n}\n\nvoid dill_putl(uint8_t *buf, uint32_t val) {\n    buf[0] = (uint8_t)(((val) >> 24) & 0xff);\n    buf[1] = (uint8_t)(((val) >> 16) & 0xff);\n    buf[2] = (uint8_t)(((val) >> 8) & 0xff);\n    buf[3] = (uint8_t)(val & 0xff);\n}\n\nuint64_t dill_getll(const uint8_t *buf) {\n    return (((uint64_t)buf[0]) << 56) |\n           (((uint64_t)buf[1]) << 48) |\n           (((uint64_t)buf[2]) << 40) |\n           (((uint64_t)buf[3]) << 32) |\n           (((uint64_t)buf[4]) << 24) |\n           (((uint64_t)buf[5]) << 16) |\n           (((uint64_t)buf[6]) << 8) |\n           (((uint64_t)buf[7] << 0));\n}\n\nvoid dill_putll(uint8_t *buf, uint64_t val) {\n    buf[0] = (uint8_t)((val >> 56) & 0xff);\n    buf[1] = (uint8_t)((val >> 48) & 0xff);\n    buf[2] = (uint8_t)((val >> 40) & 0xff);\n    buf[3] = (uint8_t)((val >> 32) & 0xff);\n    buf[4] = (uint8_t)((val >> 24) & 0xff);\n    buf[5] = (uint8_t)((val >> 16) & 0xff);\n    buf[6] = (uint8_t)((val >> 8) & 0xff);\n    buf[7] = (uint8_t)(val & 0xff);\n}\n\nconst char *dill_lstrip(const char *string, char delim) {\n    const char *pos = string;\n    while(*pos && *pos == delim) ++pos;\n    return pos;\n}\n\nconst char *dill_rstrip(const char *string, char delim) {\n    const char *end = string + strlen(string) - 1;\n    while(end > string && *end == delim) --end;\n    return ++end;\n}\n\nint dill_random(uint8_t *buf, size_t len) {\n    static int fd = -1;\n    if(dill_slow(fd < 0)) {\n        fd = open(\"/dev/urandom\", O_RDONLY);\n        dill_assert(fd >= 0);\n    }\n    ssize_t sz = read(fd, buf, len);\n    if(dill_slow(sz < 0)) return -1;\n    dill_assert(sz == len);\n    return 0;\n}\n\nint dill_base64_decode(const char *in, size_t in_len, uint8_t *out,\n      size_t out_len) {\n    unsigned ii;\n    unsigned io;\n    unsigned rem;\n    uint32_t v;\n    uint8_t ch;\n\n    /*  Unrolled lookup of ASCII code points.\n        0xFF represents a non-base64 valid character. */\n    const uint8_t DECODEMAP[256] = {\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F,\n        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,\n        0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF,\n        0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n        0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n        0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n        0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n        0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\n    for(io = 0, ii = 0, v = 0, rem = 0; ii < in_len; ii++) {\n        if(isspace(in[ii]))\n            continue;\n        if(in[ii] == '=')\n            break;\n        ch = DECODEMAP[(int)(in[ii])];\n        /*  Discard invalid characters as per RFC 2045. */\n        if(ch == 0xFF)\n            break; \n        v = (v << 6) | ch;\n        rem += 6;\n        if (rem >= 8) {\n            rem -= 8;\n            if(io >= out_len)\n                return -1;\n            out[io++] = (v >> rem) & 255;\n        }\n    }\n    if(rem >= 8) {\n        rem -= 8;\n        if(io >= out_len)\n            return -1;\n        out[io++] = (v >> rem) & 255;\n    }\n    return io;\n}\n\nint dill_base64_encode(const uint8_t *in, size_t in_len, char *out,\n      size_t out_len) {\n    unsigned ii;\n    unsigned io;\n    unsigned rem;\n    uint32_t v;\n    uint8_t ch;\n\n    const uint8_t ENCODEMAP[64] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz\"\n        \"0123456789+/\";\n\n    for(io = 0, ii = 0, v = 0, rem = 0; ii < in_len; ii++) {\n        ch = in[ii];\n        v = (v << 8) | ch;\n        rem += 8;\n        while(rem >= 6) {\n            rem -= 6;\n            if(io >= out_len)\n                return -1;\n            out[io++] = ENCODEMAP[(v >> rem) & 63];\n        }\n    }\n    if(rem) {\n        v <<= (6 - rem);\n        if(io >= out_len)\n            return -1;\n        out[io++] = ENCODEMAP[v & 63];\n    }\n    /*  Pad to a multiple of 3. */\n    while(io & 3) {\n        if(io >= out_len)\n            return -1;\n        out[io++] = '=';\n    }\n    if(io >= out_len)\n        return -1;\n    out[io] = '\\0';\n    return io;\n}\n\n#define dill_sha1_rol32(num,bits) ((num << bits) | (num >> (32 - bits)))\n\nvoid dill_sha1_init(struct dill_sha1 *self) {\n    /*  Detect endianness. */\n    union {\n        uint32_t i;\n        char c[4];\n    } test = {0x00000001};\n    self->is_little_endian = test.c[0];\n    /*  Initial state of the hash. */\n    self->state [0] = 0x67452301;\n    self->state [1] = 0xefcdab89;\n    self->state [2] = 0x98badcfe;\n    self->state [3] = 0x10325476;\n    self->state [4] = 0xc3d2e1f0;\n    self->bytes_hashed = 0;\n    self->buffer_offset = 0;\n}\n\nstatic void dill_sha1_add(struct dill_sha1 *self, uint8_t data) {\n    uint8_t i;\n    uint32_t a, b, c, d, e, t;\n    uint8_t *const buf = (uint8_t*)self->buffer;\n    if(self->is_little_endian)\n        buf[self->buffer_offset ^ 3] = data;\n    else\n        buf[self->buffer_offset] = data;\n    self->buffer_offset++;\n    if(self->buffer_offset == DILL_SHA1_BLOCK_LEN) {\n        a = self->state[0];\n        b = self->state[1];\n        c = self->state[2];\n        d = self->state[3];\n        e = self->state[4];\n        for(i = 0; i < 80; i++) {\n            if(i >= 16) {\n                t = self->buffer[(i + 13) & 15] ^\n                    self->buffer[(i + 8) & 15] ^\n                    self->buffer[(i + 2) & 15] ^\n                    self->buffer[i & 15];\n                self->buffer[i & 15] = dill_sha1_rol32(t, 1);\n            }\n            if (i < 20)\n                t = (d ^ (b & (c ^ d))) + 0x5A827999;\n            else if(i < 40)\n                t = (b ^ c ^ d) + 0x6ED9EBA1;\n            else if(i < 60)\n                t = ((b & c) | (d & (b | c))) + 0x8F1BBCDC;\n            else\n                t = (b ^ c ^ d) + 0xCA62C1D6;\n            t += dill_sha1_rol32(a, 5) + e + self->buffer[i & 15];\n            e = d;\n            d = c;\n            c = dill_sha1_rol32(b, 30);\n            b = a;\n            a = t;\n        }\n        self->state[0] += a;\n        self->state[1] += b;\n        self->state[2] += c;\n        self->state[3] += d;\n        self->state[4] += e;\n        self->buffer_offset = 0;\n    }\n}\n\nvoid dill_sha1_hashbyte(struct dill_sha1 *self, uint8_t data) {\n    ++self->bytes_hashed;\n    dill_sha1_add(self, data);\n}\n\nuint8_t *dill_sha1_result(struct dill_sha1 *self) {\n    int i;\n    /*  Pad to complete the last block. */\n    dill_sha1_add(self, 0x80);\n    while(self->buffer_offset != 56)\n        dill_sha1_add (self, 0x00);\n    /*  Append length in the last 8 bytes. SHA-1 supports 64-bit hashes, so\n        zero-pad the top bits. Shifting to multiply by 8 as SHA-1 supports\n        bit- as well as byte-streams. */\n    dill_sha1_add(self, 0);\n    dill_sha1_add(self, 0);\n    dill_sha1_add(self, 0);\n    dill_sha1_add(self, self->bytes_hashed >> 29);\n    dill_sha1_add(self, self->bytes_hashed >> 21);\n    dill_sha1_add(self, self->bytes_hashed >> 13);\n    dill_sha1_add(self, self->bytes_hashed >> 5);\n    dill_sha1_add(self, self->bytes_hashed << 3);\n    /*  Correct byte order for little-endian systems. */\n    if(self->is_little_endian) {\n        for(i = 0; i < 5; i++) {\n            self->state[i] =\n                (((self->state[i]) << 24) & 0xFF000000) |\n                (((self->state[i]) << 8) & 0x00FF0000) |\n                (((self->state[i]) >> 8) & 0x0000FF00) |\n                (((self->state[i]) >> 24) & 0x000000FF);\n        }\n    }\n    /* 20-octet pointer to hash. */\n    return (uint8_t*)self->state;\n}\n\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 6.3115234375,
          "content": "/*\n\n  Copyright (c) 2017 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef DILL_UTILS_H_INCLUDED\n#define DILL_UTILS_H_INCLUDED\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define dill_concat(x,y) x##y\n\n/* Defines a unique identifier of type const void*. */\n#define dill_unique_id(name) \\\n    static const int dill_concat(name, ___) = 0;\\\n    const void *name = & dill_concat(name, ___);\n\n/*  Takes a pointer to a member variable and computes pointer to the structure\n    that contains it. 'type' is type of the structure, not the member. */\n#define dill_cont(ptr, type, member) \\\n    (ptr ? ((type*) (((char*) ptr) - offsetof(type, member))) : NULL)\n\n/* Compile-time assert. */\n#define DILL_CT_ASSERT_HELPER2(prefix, line) \\\n    prefix##line\n#define DILL_CT_ASSERT_HELPER1(prefix, line) \\\n    DILL_CT_ASSERT_HELPER2(prefix, line)\n#define DILL_CT_ASSERT(x) \\\n    typedef int DILL_CT_ASSERT_HELPER1(ct_assert_,__COUNTER__) [(x) ? 1 : -1];\n\n/* DILL_CHECK_STORAGE checks whether struct 'type' fits into struct 'storage'.\n   If DILL_PRINT_SIZES macro is defined it will also print the size\n   of 'type'. */\n#if defined DILL_PRINT_SIZES\n#define DILL_CHECK_STORAGE(type, storage) \\\n    static void dill_print_size_2_##type(void) { \\\n        char x[sizeof(struct type)]; \\\n        dill_print_size(&x); \\\n    } \\\n    DILL_CT_ASSERT(sizeof(struct type) <= sizeof(struct storage))\n#else\n#define DILL_CHECK_STORAGE(type, storage) \\\n    DILL_CT_ASSERT(sizeof(struct type) <= sizeof(struct storage))\n#endif\n\nvoid dill_print_size(char x);\n\n/* Optimisation hints. */\n#if defined __GNUC__ || defined __llvm__\n#define dill_fast(x) __builtin_expect(!!(x), 1)\n#define dill_slow(x) __builtin_expect(!!(x), 0)\n#else\n#define dill_fast(x) (x)\n#define dill_slow(x) (x)\n#endif\n\n/* Define our own assert. This way we are sure that it stays in place even\n   if the standard C assert would be thrown away by the compiler. It also\n   allows us to overload it as needed. */\n#define dill_assert(x) \\\n    do {\\\n        if (dill_slow(!(x))) {\\\n            fprintf(stderr, \"Assert failed: \" #x \" (%s:%d)\\n\",\\\n                __FILE__, __LINE__);\\\n            fflush(stderr);\\\n            abort();\\\n        }\\\n    } while (0)\n\n/* Workaround missing __rdtsc in Clang < 3.5 (or Clang < 6.0 on Xcode) */\n#if defined(__x86_64__) || defined(__i386__)\n#if defined __clang__\n#if (!defined(__apple_build_version__) && \\\n    ((__clang_major__ < 3) || \\\n    ((__clang_major__ == 3) && (__clang_minor__ < 5)))) || \\\n    (defined(__apple_build_version__) && (__clang_major__ < 6))\nstatic inline uint64_t __rdtsc() {\n#if defined __i386__\n    uint64_t x;\n    asm volatile (\"rdtsc\" : \"=A\" (x));\n    return x;\n#else\n    uint64_t a, d;\n    asm volatile (\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n    return (d << 32) | a;\n#endif\n}\n#endif\n#endif\n#endif\n\n/* Returns the maximum possible file descriptor number */\nint dill_maxfds(void);\n\n/* Encoding and decoding integers from network byte order. */\nuint16_t dill_gets(const uint8_t *buf);\nvoid dill_puts(uint8_t *buf, uint16_t val);\nuint32_t dill_getl(const uint8_t *buf);\nvoid dill_putl(uint8_t *buf, uint32_t val);\nuint64_t dill_getll(const uint8_t *buf);\nvoid dill_putll(uint8_t *buf, uint64_t val);\n\n/* Returns a pointer to the first character in string that is not delim. */\nconst char *dill_lstrip(const char *string, char delim);\n/* Returns a pointer after the last character in string that is not delim. */\nconst char *dill_rstrip(const char *string, char delim);\n\n/* Cryptographically random bytes. */\nint dill_random(uint8_t *buf, size_t len);\n\n/******************************************************************************/\n/* Base64 functions are based on base64.c (Public Domain) by Jon Mayo.        */\n/******************************************************************************/\n\nint dill_base64_encode(const uint8_t *in, size_t in_len,\n    char *out, size_t out_len);\nint dill_base64_decode(const char *in, size_t in_len,\n    uint8_t *out, size_t out_len);\n\n/******************************************************************************/\n/*  SHA-1 SECURITY NOTICE:                                                    */\n/*  The algorithm as designed below is not intended for general purpose use.  */\n/*  As-designed, it is a single-purpose function for this WebSocket           */\n/*  Opening Handshake. As per RFC 6455 10.8, SHA-1 usage \"doesn't depend on   */\n/*  any security properties of SHA-1, such as collision resistance or         */\n/*  resistance to the second pre-image attack (as described in [RFC4270])\".   */\n/*  Caveat emptor for uses of this function elsewhere.                        */\n/*                                                                            */\n/*  Based on sha1.c (Public Domain) by Steve Reid, these functions calculate  */\n/*  the SHA1 hash of arbitrary byte locations byte-by-byte.                   */\n/******************************************************************************/\n\n#define DILL_SHA1_HASH_LEN 20\n#define DILL_SHA1_BLOCK_LEN 64\n\nstruct dill_sha1 {\n    uint32_t buffer[DILL_SHA1_BLOCK_LEN / sizeof (uint32_t)];\n    uint32_t state[DILL_SHA1_HASH_LEN / sizeof (uint32_t)];\n    uint32_t bytes_hashed;\n    uint8_t buffer_offset;\n    uint8_t is_little_endian;\n};\n\nvoid dill_sha1_init(struct dill_sha1 *self);\nvoid dill_sha1_hashbyte(struct dill_sha1 *self, uint8_t data);\nuint8_t *dill_sha1_result(struct dill_sha1 *self);\n\n#endif\n\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        },
        {
          "name": "ws.c",
          "type": "blob",
          "size": 22.2490234375,
          "content": "/*\n\n  Copyright (c) 2018 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DILL_DISABLE_RAW_NAMES\n#include \"libdillimpl.h\"\n#include \"iol.h\"\n#include \"utils.h\"\n\ndill_unique_id(dill_ws_type);\n\nstruct dill_ws_sock {\n    struct dill_hvfs hvfs;\n    struct dill_msock_vfs mvfs;\n    int u;\n    int flags;\n    unsigned int indone : 1;\n    unsigned int outdone: 1;\n    unsigned int server : 1;\n    unsigned int mem : 1;\n    uint16_t status;\n    uint8_t msglen;\n    uint8_t msg[128];\n};\n\nDILL_CHECK_STORAGE(dill_ws_sock, dill_ws_storage)\n\nstatic void *dill_ws_hquery(struct dill_hvfs *hvfs, const void *type);\nstatic void dill_ws_hclose(struct dill_hvfs *hvfs);\nstatic int dill_ws_msendl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\nstatic ssize_t dill_ws_mrecvl(struct dill_msock_vfs *mvfs,\n    struct dill_iolist *first, struct dill_iolist *last, int64_t deadline);\n\nstatic void *dill_ws_hquery(struct dill_hvfs *hvfs, const void *type) {\n    struct dill_ws_sock *self = (struct dill_ws_sock*)hvfs;\n    if(type == dill_msock_type) return &self->mvfs;\n    if(type == dill_ws_type) return self;\n    errno = ENOTSUP;\n    return NULL;\n}\n\nint dill_ws_attach_client_mem(int s, int flags, const char *resource,\n      const char *host, struct dill_ws_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error;}\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) {err = errno; goto error;}\n    struct dill_ws_sock *self = (struct dill_ws_sock*)mem;\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    self->hvfs.query = dill_ws_hquery;\n    self->hvfs.close = dill_ws_hclose;\n    self->mvfs.msendl = dill_ws_msendl;\n    self->mvfs.mrecvl = dill_ws_mrecvl;\n    self->u = s;\n    self->flags = flags;\n    self->indone = 0;\n    self->outdone = 0;\n    self->server = 0;\n    self->mem = 1;\n    self->status = 0;\n    self->msglen = 0;\n    if(flags & DILL_WS_NOHTTP) {\n        int h = dill_hmake(&self->hvfs);\n        if(dill_slow(h < 0)) {err = errno; goto error;}\n        return h;\n    }\n    if(dill_slow(!resource || !host)) {err = EINVAL; goto error;}\n    struct dill_http_storage http_mem;\n    s = dill_http_attach_mem(s, &http_mem);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Send HTTP request. */\n    int rc = dill_http_sendrequest(s, \"GET\", resource, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Host\", host, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Upgrade\", \"websocket\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Connection\", \"Upgrade\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    char request_key[WS_KEY_SIZE];\n    rc = dill_ws_request_key(request_key);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Sec-WebSocket-Key\", request_key, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Sec-WebSocket-Version\", \"13\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    /* TODO: Protocol, Extensions? */\n    rc = dill_http_done(s, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n\n    /* Receive HTTP response from the server. */\n    char reason[256];\n    rc = dill_http_recvstatus(s, reason, sizeof(reason), deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    if(dill_slow(rc != 101)) {errno = EPROTO; return -1;}\n    int has_upgrade = 0;\n    int has_connection = 0;\n    int has_key = 0;\n    while(1) {\n        char name[256];\n        char value[256];\n        rc = dill_http_recvfield(s, name, sizeof(name), value, sizeof(value),\n            deadline);\n        if(rc < 0 && errno == EPIPE) break;\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n        if(strcasecmp(name, \"Upgrade\") == 0) {\n           if(has_upgrade || strcasecmp(value, \"websocket\") != 0) {\n               err = EPROTO; goto error;}\n           has_upgrade = 1;\n           continue;\n        }\n        if(strcasecmp(name, \"Connection\") == 0) {\n           if(has_connection || strcasecmp(value, \"Upgrade\") != 0) {\n               err = EPROTO; goto error;}\n           has_connection = 1;\n           continue;\n        }\n        if(strcasecmp(name, \"Sec-WebSocket-Accept\") == 0) {\n            if(has_key) {err = EPROTO; goto error;}\n            char response_key[WS_KEY_SIZE];\n            rc = dill_ws_response_key(request_key, response_key);\n            if(dill_slow(rc < 0)) {err = errno; goto error;}\n            if(dill_slow(strcmp(value, response_key) != 0)) {\n                err = EPROTO; goto error;}\n            has_key = 1;\n            continue;\n        }\n    }\n    if(!has_upgrade || !has_connection || !has_key) {err = EPROTO; goto error;}\n\n    s = dill_http_detach(s, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    self->u = s;\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_ws_attach_client(int s, int flags, const char *resource,\n      const char *host, int64_t deadline) {\n    int err;\n    struct dill_ws_sock *obj = malloc(sizeof(struct dill_ws_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_ws_attach_client_mem(s, flags, resource, host,\n        (struct dill_ws_storage*)obj, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nint dill_ws_attach_server_mem(int s, int flags,\n      char *resource, size_t resourcelen,\n      char *host, size_t hostlen,\n      struct dill_ws_storage *mem, int64_t deadline) {\n    int err;\n    if(dill_slow(!mem)) {err = EINVAL; goto error;}\n    if(dill_slow(!dill_hquery(s, dill_bsock_type))) {err = errno; goto error;}\n    struct dill_ws_sock *self = (struct dill_ws_sock*)mem;\n    /* Take ownership of the underlying socket. */\n    s = dill_hown(s);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    self->hvfs.query = dill_ws_hquery;\n    self->hvfs.close = dill_ws_hclose;\n    self->mvfs.msendl = dill_ws_msendl;\n    self->mvfs.mrecvl = dill_ws_mrecvl;\n    self->u = s;\n    self->flags = flags;\n    self->indone = 0;\n    self->outdone = 0;\n    self->server = 1;\n    self->mem = 1;\n    self->status = 0;\n    self->msglen = 0;\n    if(flags & DILL_WS_NOHTTP) {\n        int h = dill_hmake(&self->hvfs);\n        if(dill_slow(h < 0)) {err = errno; goto error;}\n        return h;\n    }\n    struct dill_http_storage http_mem;\n    s = dill_http_attach_mem(s, &http_mem);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    /* Receive the HTTP request from the client. */\n    char command[32];\n    int rc = dill_http_recvrequest(s, command, sizeof(command),\n        resource, resourcelen, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    if(dill_slow(strcmp(command, \"GET\") != 0)) {err = EPROTO; goto error;}\n    int has_host = 0;\n    int has_upgrade = 0;\n    int has_connection = 0;\n    int has_key = 0;\n    int has_version = 0;\n    char response_key[WS_KEY_SIZE];\n    while(1) {\n        char name[256];\n        char value[256];\n        rc = dill_http_recvfield(s, name, sizeof(name), value, sizeof(value),\n            deadline);\n        if(rc < 0 && errno == EPIPE) break;\n        if(dill_slow(rc < 0)) {err = errno; goto error;}\n        if(strcasecmp(name, \"Host\") == 0) {\n           if(has_host != 0) {err = EPROTO; goto error;}\n           /* TODO: Is this the correct error code? */\n           if(dill_slow(strlen(value) >= hostlen)) {\n               err = EMSGSIZE; goto error;}\n           strcpy(host, value);\n           has_host = 1;\n           continue;\n        }\n        if(strcasecmp(name, \"Upgrade\") == 0) {\n           if(has_upgrade || strcasecmp(value, \"websocket\") != 0) {\n               err = EPROTO; goto error;}\n           has_upgrade = 1;\n           continue;\n        }\n        if(strcasecmp(name, \"Connection\") == 0) {\n           if(has_connection || strcasecmp(value, \"Upgrade\") != 0) {\n               err = EPROTO; goto error;}\n           has_connection = 1;\n           continue;\n        }\n        if(strcasecmp(name, \"Sec-WebSocket-Key\") == 0) {\n            if(has_key) {err = EPROTO; goto error;}\n            /* Generate the key to be sent back to the client. */\n            rc = dill_ws_response_key(value, response_key);\n            if(dill_slow(rc < 0)) {err = errno; goto error;}\n            has_key = 1;\n            continue;\n        }\n        if(strcasecmp(name, \"Sec-WebSocket-Version\") == 0) {\n           if(has_version || strcasecmp(value, \"13\") != 0) {\n               err = EPROTO; goto error;}\n           has_version = 1;\n           continue;\n        }\n    }\n    if(dill_slow(!has_upgrade || !has_connection || !has_key || !has_version)) {\n        err = EPROTO; goto error;}\n\n    /* Send HTTP response back to the client. */\n    rc = dill_http_sendstatus(s, 101, \"Switching Protocols\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Upgrade\", \"websocket\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Connection\", \"Upgrade\", deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n    rc = dill_http_sendfield(s, \"Sec-WebSocket-Accept\", response_key, deadline);\n    if(dill_slow(rc < 0)) {err = errno; goto error;}\n\n    s = dill_http_detach(s, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error;}\n    self->u = s;\n    int h = dill_hmake(&self->hvfs);\n    if(dill_slow(h < 0)) {err = errno; goto error;}\n    return h;\nerror:\n    if(s >= 0) {\n        int rc = dill_hclose(s);\n        dill_assert(rc == 0);\n    }\n    errno = err;\n    return -1;\n}\n\nint dill_ws_attach_server(int s, int flags, char *resource, size_t resourcelen,\n      char *host, size_t hostlen, int64_t deadline) {\n    int err;\n    struct dill_ws_sock *obj = malloc(sizeof(struct dill_ws_sock));\n    if(dill_slow(!obj)) {err = ENOMEM; goto error1;}\n    s = dill_ws_attach_server_mem(s, flags, resource, resourcelen,\n        host, hostlen, (struct dill_ws_storage*)obj, deadline);\n    if(dill_slow(s < 0)) {err = errno; goto error2;}\n    obj->mem = 0;\n    return s;\nerror2:\n    free(obj);\nerror1:\n    if(s >= 0) dill_hclose(s);\n    errno = err;\n    return -1;\n}\n\nstatic int dill_ws_sendl_base(struct dill_msock_vfs *mvfs, uint8_t type,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_cont(mvfs, struct dill_ws_sock, mvfs);\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    size_t len;\n    int rc = dill_iolcheck(first, last, NULL, &len);\n    if(dill_slow(rc < 0)) return -1;\n    uint8_t buf[12];\n    size_t sz;\n    buf[0] = 0x80 | type;\n    if(len > 0xffff) {\n        buf[1] = 127;\n        dill_putll(buf + 2, len);\n        sz = 10;\n    }\n    else if(len > 125) {\n        buf[1] = 126;\n        dill_puts(buf + 2, len);\n        sz = 4;\n    }\n    else {\n        buf[1] = (uint8_t)len;\n        sz = 2;\n    }\n    uint8_t mask[4];\n    if(!self->server) {\n        rc = dill_random(mask, sizeof(mask));\n        if(dill_slow(rc < 0)) return -1;\n        buf[1] |= 0x80;\n        memcpy(buf + sz, mask, 4);\n        sz += 4;\n    }\n    rc = dill_bsend(self->u, buf, sz, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    /* On the server side we can send the payload as is. */\n    if(self->server) {\n        rc = dill_bsendl(self->u, first, last, deadline);\n        if(dill_slow(rc < 0)) return -1;\n        return 0;\n    }\n    /* On the client side, the payload has to be masked. */\n    size_t pos = 0;\n    while(first) {\n        size_t i;\n        for(i = 0; i != first->iol_len; ++i) {\n            uint8_t b = ((uint8_t*)first->iol_base)[i] ^\n                mask[pos++ % sizeof(mask)];\n            rc = dill_bsend(self->u, &b, 1, deadline); \n            if(dill_slow(rc < 0)) return -1;\n        }\n        first = first->iol_next;\n    }\n    return 0;\n}\n\nstatic ssize_t dill_ws_recvl_base(struct dill_msock_vfs *mvfs, int *flags,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_cont(mvfs, struct dill_ws_sock, mvfs);\n    if(dill_slow(self->indone)) {errno = EPIPE; return -1;}\n    int rc = dill_iolcheck(first, last, NULL, NULL);\n    if(dill_slow(rc < 0)) return -1;\n    size_t res = 0;\n    /* Message may consist of multiple frames. Read them one by one. */\n    struct dill_iolist it;\n    if(first) it = *first;\n    while(1) {\n        struct dill_iolist iol_msg;\n        uint8_t hdr1[2];\n        rc = dill_brecv(self->u, hdr1, sizeof(hdr1), deadline);\n        if(dill_slow(rc < 0)) return -1;\n        if(hdr1[0] & 0x70) {errno = EPROTO; return -1;}\n        int opcode = hdr1[0] & 0x0f;\n        /* TODO: Other opcodes. */\n        switch(opcode) {\n        case 0:\n            break;\n        case 1:\n            if(flags) *flags = DILL_WS_TEXT;\n            break;\n        case 2:\n            if(flags) *flags = DILL_WS_BINARY;\n            break;\n        case 8:\n            it.iol_base = &self->status;\n            it.iol_len = 2;\n            it.iol_next = &iol_msg;\n            it.iol_rsvd = 0;\n            iol_msg.iol_base = self->msg;\n            iol_msg.iol_len = sizeof(self->msg);\n            iol_msg.iol_next = NULL;\n            iol_msg.iol_rsvd = 0;\n            self->indone = 1;\n            break;\n        default:\n            errno = EPROTO;\n            return -1;\n        }\n        if(!self->server ^ !(hdr1[1] & 0x80)) {errno = EPROTO; return -1;}\n        size_t sz = hdr1[1] & 0x7f;\n        if(sz == 126) {\n            uint8_t hdr2[2];\n            rc = dill_brecv(self->u, hdr2, sizeof(hdr2), deadline);\n            if(dill_slow(rc < 0)) return -1;\n            sz = dill_gets(hdr2);\n        }\n        else if(sz == 127) {\n            uint8_t hdr2[8];\n            rc = dill_brecv(self->u, hdr2, sizeof(hdr2), deadline);\n            if(dill_slow(rc < 0)) return -1;\n            sz = dill_getll(hdr2);\n        }\n        res += sz;\n        /* Control frames cannot be fragmented or longer than 125 bytes. */\n        if(dill_slow(opcode >= 8 && (sz > 125 || !(hdr1[0] & 0x80)))) {\n            errno = EPROTO; return -1;}\n        uint8_t mask[4];\n        if(self->server) {\n            rc = dill_brecv(self->u, mask, sizeof(mask), deadline);\n            if(dill_slow(rc < 0)) return -1;\n        }\n        /* Frame may be read into multiple iolist elements. */\n        while(1) {\n            size_t toread = sz < it.iol_len ? sz : it.iol_len;\n            if(toread > 0) {\n                rc = dill_brecv(self->u, it.iol_base, toread, deadline);\n                if(dill_slow(rc < 0)) return -1;\n                if(self->server) {\n                    size_t i;\n                    for(i = 0; i != toread; ++i)\n                        ((uint8_t*)it.iol_base)[i] ^= mask[i % 4];\n                }\n            }\n            sz -= toread;\n            if(sz == 0) break;\n            if(dill_slow(!it.iol_next)) {errno = EMSGSIZE; return -1;}\n            it = *it.iol_next;\n        }\n        if(hdr1[0] & 0x80) break;\n    }\n    if(dill_slow(self->indone)) {\n        if(dill_slow(res == 1)) {errno = EPROTO; return -1;}\n        if(res >= 2) {\n           self->status = dill_gets((uint8_t*)&self->status);\n           if(dill_slow(self->status < 1000 || self->status > 4999)) {\n               errno = EPROTO; return -1;}\n           self->msglen = (uint8_t)res - 2;\n        }\n        else self->msglen = 0;\n        errno = EPIPE;\n        return -1;\n    }\n    return res;\n}\n\nint dill_ws_send(int s, int flags, const void *buf, size_t len,\n      int64_t deadline) {\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return dill_ws_sendl_base(&self->mvfs, (flags & DILL_WS_TEXT) ? 0x1 : 0x2,\n        &iol, &iol, deadline);\n}\n\nssize_t dill_ws_recv(int s, int *flags, void *buf, size_t len,\n      int64_t deadline) {\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    struct dill_iolist iol = {(void*)buf, len, NULL, 0};\n    return dill_ws_recvl_base(&self->mvfs, flags, &iol, &iol, deadline);\n}\n\nint dill_ws_sendl(int s, int flags, struct dill_iolist *first,\n      struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    return dill_ws_sendl_base(&self->mvfs, (flags & DILL_WS_TEXT) ? 0x1 : 0x2,\n        first, last, deadline);\n}\n\nssize_t dill_ws_recvl(int s, int *flags, struct dill_iolist *first,\n      struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    return dill_ws_recvl_base(&self->mvfs, flags, first, last, deadline);\n}\n\nstatic int dill_ws_msendl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_cont(mvfs, struct dill_ws_sock, mvfs);\n    return dill_ws_sendl_base(mvfs, (self->flags & DILL_WS_TEXT) ? 0x1 : 0x2,\n        first, last, deadline);\n}\n\nstatic ssize_t dill_ws_mrecvl(struct dill_msock_vfs *mvfs,\n      struct dill_iolist *first, struct dill_iolist *last, int64_t deadline) {\n    struct dill_ws_sock *self = dill_cont(mvfs, struct dill_ws_sock, mvfs);\n    int flags;\n    ssize_t sz = dill_ws_recvl_base(mvfs, &flags, first, last, deadline);\n    if(dill_slow(sz < 0)) return -1;\n    if(dill_slow((flags & DILL_WS_TEXT) != (self->flags & DILL_WS_TEXT))) {\n        errno = EPROTO; return -1;}\n    return sz;\n}\n\nint dill_ws_done(int s, int status, const void *buf, size_t len,\n      int64_t deadline) {\n    if(dill_slow((status != 0 && (status < 1000 || status > 4999)) ||\n        (!buf && len > 0))) {errno = EINVAL; return -1;}\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(self->outdone)) {errno = EPIPE; return -1;}\n    struct dill_iolist iol2 = {(void*)buf, len, NULL, 0};\n    uint8_t sbuf[2];\n    dill_puts(sbuf, status);\n    struct dill_iolist iol1 = {status ? sbuf : NULL, status ? sizeof(sbuf) : 0,\n        &iol2, 0};\n    int rc = dill_ws_sendl_base(&self->mvfs, 0x8, &iol1, &iol2, deadline);\n    if(dill_slow(rc < 0)) return -1;\n    self->outdone = 1;\n    return 0;\n}\n\nint dill_ws_detach(int s, int status, const void *buf, size_t len,\n      int64_t deadline) {\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    if(!self->outdone) {\n        int rc = dill_ws_done(s, status, buf, len, deadline);\n        if(dill_slow(rc < 0)) return -1;\n    }\n    while(1) {\n        struct dill_iolist iol = {NULL, SIZE_MAX, NULL, 0};\n        ssize_t sz = dill_ws_recvl_base(&self->mvfs, NULL, &iol, &iol,\n            deadline);\n        if(sz < 0) {\n             if(errno == EPIPE) break;\n             return -1;\n        }\n    }\n    int u = self->u;\n    if(!self->mem) free(self);\n    return u;\n}\n\nstatic void dill_ws_hclose(struct dill_hvfs *hvfs) {\n    struct dill_ws_sock *self = (struct dill_ws_sock*)hvfs;\n    int rc = dill_hclose(self->u);\n    dill_assert(rc == 0);\n    if(!self->mem) free(self);\n}\n\nssize_t dill_ws_status(int s, int *status, void *buf, size_t len) {\n    if(dill_slow(!buf && len)) {errno = EINVAL; return -1;}\n    struct dill_ws_sock *self = dill_hquery(s, dill_ws_type);\n    if(dill_slow(!self)) return -1;\n    if(dill_slow(!self->indone)) {errno = EAGAIN; return -1;}\n    if(status) *status = self->status;\n    if(buf) {\n        if(dill_slow(len < self->msglen)) {errno = EMSGSIZE; return -1;}\n        memcpy(buf, self->msg, self->msglen);\n    }\n    return self->msglen;\n}\n\n/******************************************************************************/\n/*  Helper functions.                                                         */\n/******************************************************************************/\n\nint dill_ws_request_key(char *request_key) {\n    if(dill_slow(!request_key)) {errno = EINVAL; return -1;}\n    uint8_t nonce[16];\n    int rc = dill_random(nonce, sizeof(nonce));\n    if(dill_slow(rc < 0)) return -1;\n    rc = dill_base64_encode(nonce, sizeof(nonce), request_key, WS_KEY_SIZE);\n    if(dill_slow(rc < 0)) {errno = EFAULT; return -1;}\n    return 0;\n}\n\nint dill_ws_response_key(const char *request_key, char *response_key) {\n    if(dill_slow(!request_key)) {errno = EINVAL; return -1;}\n    if(dill_slow(!response_key)) {errno = EINVAL; return -1;}\n    /* Decode the request key and check whether it's a 16-byte nonce. */\n    uint8_t nonce[16];\n    int rc = dill_base64_decode(request_key, strlen(request_key),\n        nonce, sizeof(nonce));\n    if(dill_slow(rc != sizeof(nonce))) {errno = EPROTO; return -1;}\n    /* Create the response key. */\n    struct dill_sha1 sha1;\n    dill_sha1_init(&sha1);\n    int i;\n    /* The key sent in the original request. */\n    for(i = 0; request_key[i] != 0; ++i)\n        dill_sha1_hashbyte(&sha1, request_key[i]);\n    /* RFC 6455-specified UUID. */\n    const char *uuid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n    for(i = 0; uuid[i] != 0; ++i) dill_sha1_hashbyte(&sha1, uuid[i]);\n    /* Convert the SHA1 to Base64. */\n    rc = dill_base64_encode(dill_sha1_result(&sha1), DILL_SHA1_HASH_LEN,\n        response_key, WS_KEY_SIZE);\n    if(dill_slow(rc < 0)) {errno = EFAULT; return -1;}\n    return 0;\n}\n\n"
        }
      ]
    }
  ]
}