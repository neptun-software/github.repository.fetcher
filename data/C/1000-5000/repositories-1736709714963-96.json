{
  "metadata": {
    "timestamp": 1736709714963,
    "page": 96,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sabrogden/Ditto",
      "stars": 4114,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.298828125,
          "content": "# Prerequisites\n*.d\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n*.asm\n*.tlog\n*.pdb\n*.def\n*.mk\n*.tlb\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n*.smod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n"
        },
        {
          "name": "About.cpp",
          "type": "blob",
          "size": 2.8076171875,
          "content": "// About.cpp : implementation file\n// test test test\n\n//Main branch test\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"About.h\"\n#include \"misc.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAbout property page\n\nIMPLEMENT_DYNCREATE(CAbout, CPropertyPage)\n\nCAbout::CAbout() : CPropertyPage(CAbout::IDD)\n{\n\tm_csTitle = theApp.m_Language.GetString(\"AboutTitle\", \"About\");\n\tm_psp.pszTitle = m_csTitle;\n\tm_psp.dwFlags |= PSP_USETITLE;\n\n\t//{{AFX_DATA_INIT(CAbout)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nCAbout::~CAbout()\n{\n}\n\nvoid CAbout::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAbout)\n\tDDX_Control(pDX, IDC_STATIC_LINK, m_Link);\n\tDDX_Control(pDX, IDC_HYPER_LINK, m_HyperLink);\n\tDDX_Control(pDX, IDC_LIST, m_List);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAbout, CPropertyPage)\n\t//{{AFX_MSG_MAP(CAbout)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAbout message handlers\n\nBOOL CAbout::OnInitDialog() \n{\n\tCPropertyPage::OnInitDialog();\n\n\tm_List.AddString(_T(\"Ditto\"));\n\n\tauto runningVersion = GetRunningVersion();\n\tCString cs = GetVersionString(runningVersion);\n\n\tCString csText;\n\tcsText = \"    Version \" + cs;\n#if _WIN64\n\tcsText += \" 64bit\";\n#else\n\tcsText += \" 32bit\";\n#endif\n\tm_List.AddString(csText);\n\n\tconst char *SqliteVersion = sqlite3_libversion();\n\tcsText = \"    Sqlite Version \";\n\tcsText += SqliteVersion;\n\tm_List.AddString(csText);\n\n\tcs = CGetSetOptions::GetExeFileName();;\n\tcsText = \"    Exe Path \" + cs;\n\tm_List.AddString(csText);\n\n\tcs = CGetSetOptions::GetDBPath();\n\tcsText = \"    DB Path \" + cs;\n\tm_List.AddString(csText);\n\n\tm_List.AddString(_T(\"\"));\n\n\tm_List.AddString(_T(\"Credits\"));\n\t\n\tcs = \"    Authors - Scott Brogden, sabrogden@users.sourceforge.net\";\n\tm_List.AddString(cs);\n\tcs = \"            - Kevin Edwards, ingenuus@users.sourceforge.net\";\n\tm_List.AddString(cs);\n\n\tm_List.AddString(_T(\"\"));\n\n\tm_List.AddString(_T(\"Addins\"));\n\n\t//Show what addins are loaded\n\tCStringArray arr;\n\ttheApp.m_Addins.AboutScreenText(arr);\n\tINT_PTR count = arr.GetCount();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tm_List.AddString(_T(\"    \") + arr[i]);\n\t}\n\n\tCRect rect;\n\tGetClientRect(rect);\n\t\n\trect.bottom -= 30;\n\t\n\tm_List.MoveWindow(rect);\n\n\trect.top = rect.bottom + 10;\n\trect.bottom = rect.top + 30;\n\t\n\tm_HyperLink.MoveWindow(rect);\n\n\tm_HyperLink.SetURL(_T(\"mailto:sabrogden@gmail.com\"));\n\n\trect.top = rect.bottom + 5;\n\trect.bottom = rect.top + 5;\n\tm_Link.MoveWindow(rect);\n\tm_Link.SetURL(_T(\"https://ditto-cp.sourceforge.io/\"));\n\t\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n"
        },
        {
          "name": "About.h",
          "type": "blob",
          "size": 1.181640625,
          "content": "#if !defined(AFX_ABOUT_H__02A95202_4AEF_4854_9DC0_161326D7B914__INCLUDED_)\n#define AFX_ABOUT_H__02A95202_4AEF_4854_9DC0_161326D7B914__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// About.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CAbout dialog\n\n#include \"hyperlink.h\"\n#include \"HListBox.h\"\n\nclass CAbout : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(CAbout)\n\n// Construction\npublic:\n\tCAbout();\n\t~CAbout();\n\n// Dialog Data\n\t//{{AFX_DATA(CAbout)\n\tenum { IDD = IDD_ABOUT };\n\tCHyperLink\tm_Link;\n\tCHyperLink\tm_HyperLink;\n\tCHListBox\tm_List;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generate virtual function overrides\n\t//{{AFX_VIRTUAL(CAbout)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\tCString m_csTitle;\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CAbout)\n\tvirtual BOOL OnInitDialog();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_ABOUT_H__02A95202_4AEF_4854_9DC0_161326D7B914__INCLUDED_)\n"
        },
        {
          "name": "Accels.cpp",
          "type": "blob",
          "size": 3.791015625,
          "content": "#include \"stdafx.h\"\n#include \"Accels.h\"\n#include \"HotKeys.h\"\n#include \"Options.h\"\n\nCAccels::CAccels()\n{\n\tm_handleRepeatKeys = false;\n\tm_firstMapTick = 0;\n\tm_activeFirstKey = 0;\n\tm_checkModifierKeys = true;\n}\n\n\nvoid CAccels::AddAccel(CAccel a)\n{\n\tm_multiMap.insert(pair<DWORD, CAccel>(a.Key, a));\n}\n\nvoid CAccels::AddAccel(DWORD cmd, DWORD key, DWORD key2, CString refData)\n{\n\tif ((int)key2 <= 0)\n\t{\n\t\tkey2 = 0;\n\t}\n\tCAccel a(key, cmd, key2, refData);\n\n\tm_multiMap.insert(pair<DWORD, CAccel>(key, a));\n}\n\nvoid CAccels::RemoveAll()\n{\n\tm_multiMap.clear();\n}\n\nCString CAccels::GetCmdKeyText(DWORD cmd, CString refData)\n{\n\tCString cmdShortcutText;\n\tfor (multimap<DWORD, CAccel>::iterator it = m_multiMap.begin(); it != m_multiMap.end(); ++it)\n\t{\n\t\tif (it->second.Cmd == cmd &&\n\t\t\t(refData == _T(\"\") || it->second.RefData == refData))\n\t\t{\n\t\t\tif (it->second.Key != 0)\n\t\t\t{\n\t\t\t\tcmdShortcutText = CHotKey::GetHotKeyDisplayStatic(it->second.Key);\n\t\t\t\tif (it->second.Key2 != 0)\n\t\t\t\t{\n\t\t\t\t\tCString cmdShortcutText2 = CHotKey::GetHotKeyDisplayStatic(it->second.Key2);\n\n\t\t\t\t\tif (cmdShortcutText2.GetLength() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcmdShortcutText += _T(\" - \");\n\t\t\t\t\t\tcmdShortcutText += cmdShortcutText2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\t\n\n\treturn cmdShortcutText;\n}\n\nbool CAccels::OnMsg(MSG *pMsg, CAccel &a)\n{    \n\tif((pMsg->message != WM_KEYDOWN && pMsg->message != WM_SYSKEYDOWN))\n\t{\n\t\treturn NULL;\n\t}\n\n\t// bit 30 (0x40000000) is 1 if this is NOT the first msg of the key\n\t//  i.e. auto-repeat may cause multiple msgs of the same key\n\tif((pMsg->lParam &0x40000000) && m_handleRepeatKeys == false)\n\t{\n\t\treturn NULL;\n\t}\n\n\tm_handleRepeatKeys = false;\n\n    if(!pMsg)\n    {\n        return NULL;\n    }\n\n    const BYTE vkey = LOBYTE(pMsg->wParam);\n\tBYTE mod = 0;\n\tif (m_checkModifierKeys)\n\t{\n\t\tmod = GetKeyStateModifiers();\n\t}\n    const DWORD key = ACCEL_MAKEKEY(vkey, mod);\n\n    //CString cs;\n    //cs.Format(_T(\"Key: %d, Mod: %d, vkey: %d, diff: %d\\r\\n\"), key, mod, vkey, (GetTickCount() - m_firstMapTick));\n    //OutputDebugString(cs);\n\t\t\n\tif (m_firstMapTick != 0 &&\n\t\t(GetTickCount64() - m_firstMapTick) < CGetSetOptions::m_doubleKeyStrokeTimeout)\n\t{\n\t\tpair<multimap<DWORD, CAccel>::iterator, multimap<DWORD, CAccel>::iterator> ppp;\n\t\tppp = m_multiMap.equal_range(m_activeFirstKey);\n\n\t\tfor (multimap<DWORD, CAccel>::iterator it2 = ppp.first; it2 != ppp.second; ++it2)\n\t\t{\n\t\t\tif (key == it2->second.Key2)\n\t\t\t{\n\t\t\t\ta = (*it2).second;\n\t\t\t\tm_firstMapTick = 0;\n\t\t\t\tm_activeFirstKey = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_firstMapTick = 0;\n\t\tm_activeFirstKey = 0;\n\n\t\tpair<multimap<DWORD, CAccel>::iterator, multimap<DWORD, CAccel>::iterator> ppp;\n\t\tppp = m_multiMap.equal_range(key);\n\n\t\tfor (multimap<DWORD, CAccel>::iterator it2 = ppp.first; it2 != ppp.second; ++it2)\n\t\t{\n\t\t\tif (it2->second.Key2 == 0)\n\t\t\t{\n\t\t\t\ta = (*it2).second;\n\t\t\t\t//return now as a another command could have a second key defined\n\t\t\t\t//if they don't press the second key this will be handled by a timer on the outside\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_activeFirstKey = key;\n\t\t\t\tm_firstMapTick = GetTickCount64();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (a.Cmd > 0 && m_activeFirstKey == 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\nbool CAccels::ContainsKey(int vKey)\n{\n\tCString cmdShortcutText;\n\tfor (auto it = m_multiMap.begin(); it != m_multiMap.end(); ++it)\n\t{\n\t\tif (LOBYTE(it->second.Key) == vKey || LOBYTE(it->second.Key2) == vKey)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nBYTE CAccels::GetKeyStateModifiers()\n{\n    BYTE m = 0;\n    if(GetKeyState(VK_SHIFT) &0x8000)\n    {\n        m |= HOTKEYF_SHIFT;\n    }\n    if(GetKeyState(VK_CONTROL) &0x8000)\n    {\n        m |= HOTKEYF_CONTROL;\n    }\n    if(GetKeyState(VK_MENU) &0x8000)\n    {\n        m |= HOTKEYF_ALT;\n    }\n    if(GetKeyState(VK_LWIN) &0x8000)\n    {\n        m |= HOTKEYF_EXT;\n    }\n    if(GetKeyState(VK_RWIN) &0x8000)\n    {\n        m |= HOTKEYF_EXT;\n    }\n    return m;\n}\n"
        },
        {
          "name": "Accels.h",
          "type": "blob",
          "size": 1.3388671875,
          "content": "#pragma once\n\n#include <map>\n#include \".\\Shared\\ArrayEx.h\"\n\n#define ACCEL_VKEY(key)\t\t\tLOBYTE(key)\n#define ACCEL_MOD(key)\t\t\tHIBYTE(key)\n#define ACCEL_MAKEKEY(vkey,mod) ((mod << 8) | vkey)\n\nusing namespace std;\n\nclass CAccel\n{\npublic:\n    DWORD Key;\n\tDWORD Key2;\n    DWORD Cmd;\n\tint RefId;\n\tCString RefData;\n\n    CAccel(DWORD key = 0, DWORD cmd = 0, DWORD key2 = 0, CString refData = _T(\"\"))\n    {\n        Key = key;\n\t\tKey2 = key2;\n        Cmd = cmd;\n\t\tRefId = 0;\n\t\tRefData = refData;\n    }\n};\n\n/*------------------------------------------------------------------*\\\nCAccels - Manages a set of CAccel\n\\*------------------------------------------------------------------*/\nclass CAccels\n{\npublic:\n    CAccels();\n\n    void AddAccel(CAccel a);\n\n\tvoid AddAccel(DWORD cmd, DWORD key, DWORD key2 = 0, CString refData = _T(\"\"));\n\n\tvoid RemoveAll();\n\n\tCString GetCmdKeyText(DWORD cmd, CString refData = _T(\"\"));\n\n    // handles a key's first WM_KEYDOWN or WM_SYSKEYDOWN message.\n    // it uses GetKeyState to test for modifiers.\n    // returns a pointer to the internal CAccel if it matches the given key or NULL\n    bool OnMsg(MSG *pMsg, CAccel &a);\n\n\tbool ContainsKey(int vKey);\n\n\tbool m_handleRepeatKeys;\n\tbool m_checkModifierKeys;\n\n    static BYTE GetKeyStateModifiers();\n\nprotected:\n\n\tmultimap<DWORD, CAccel> m_multiMap;\n\tDWORD m_activeFirstKey;\n\n\tULONGLONG m_firstMapTick;\n};\n"
        },
        {
          "name": "AccessToSqlite",
          "type": "tree",
          "content": null
        },
        {
          "name": "ActionEnums.cpp",
          "type": "blob",
          "size": 13.11328125,
          "content": "#include \"stdafx.h\"\r\n#include \"ActionEnums.h\"\r\n#include \"Accels.h\"\r\n#include \"Misc.h\"\r\n#include \"CP_Main.h\"\r\n\r\nActionEnums::ActionEnums()\r\n{\r\n}\r\n\r\n\r\nActionEnums::~ActionEnums()\r\n{\r\n}\r\n\r\n\r\nCString ActionEnums::EnumDescription(ActionEnumValues value)\r\n{\r\n\tCString val = _T(\"\");\r\n\r\n\tswitch (value)\r\n\t{\r\n\tcase SHOWDESCRIPTION:\r\n\t\tval = \"View Full Description\";\r\n\t\tbreak;\r\n\tcase NEXTDESCRIPTION:\r\n\t\tval = \"Next Full Description\";\r\n\t\tbreak;\r\n\tcase PREVDESCRIPTION:\r\n\t\tval = \"Previous Full Description\";\r\n\t\tbreak;\r\n\tcase SHOWMENU:\r\n\t\tval = \"Show Context Menu\";\r\n\t\tbreak;\r\n\tcase SYSTEM_MENU:\r\n\t\tval = \"Show System Context Menu\";\r\n\t\tbreak;\r\n\tcase NEWGROUP:\r\n\t\tval = \"New Group\";\r\n\t\tbreak;\r\n\tcase NEWGROUPSELECTION:\r\n\t\tval = \"New Group Selection\";\r\n\t\tbreak;\r\n\tcase TOGGLEFILELOGGING:\r\n\t\tval = \"Toggle On File Logging\";\r\n\t\tbreak;\r\n\tcase TOGGLEOUTPUTDEBUGSTRING:\r\n\t\tval = \"Toggle OutputDebugString Logging\";\r\n\t\tbreak;\r\n\tcase CLOSEWINDOW:\r\n\t\tval = \"Close Window\";\r\n\t\tbreak;\r\n\tcase NEXTTABCONTROL:\r\n\t\tval = \"NEXTTABCONTROL\";\r\n\t\tbreak;\r\n\tcase PREVTABCONTROL:\r\n\t\tval = \"PREVTABCONTROL\";\r\n\t\tbreak;\r\n\tcase SHOWGROUPS:\r\n\t\tval = \"View Groups\";\r\n\t\tbreak;\r\n\tcase NEWCLIP:\r\n\t\tval = \"New Clip\";\r\n\t\tbreak;\r\n\tcase EDITCLIP:\r\n\t\tval = \"Edit Clip\";\r\n\t\tbreak;\r\n\tcase MODIFIER_ACTVE_SELECTIONUP:\r\n\t\tval = \"MODIFIER_ACTVE_SELECTIONUP\";\r\n\t\tbreak;\r\n\tcase MODIFIER_ACTVE_SELECTIONDOWN:\r\n\t\tval = \"MODIFIER_ACTVE_SELECTIONDOWN\";\r\n\t\tbreak;\r\n\tcase MODIFIER_ACTVE_MOVEFIRST:\r\n\t\tval = \"MODIFIER_ACTVE_MOVEFIRST\";\r\n\t\tbreak;\r\n\tcase MODIFIER_ACTVE_MOVELAST:\r\n\t\tval = \"MODIFIER_ACTVE_MOVELAST\";\r\n\t\tbreak;\r\n\tcase CANCELFILTER:\r\n\t\tval = \"Cancel Filter\";\r\n\t\tbreak;\r\n\tcase HOMELIST:\r\n\t\tval = \"HOMELIST\";\r\n\t\tbreak;\r\n\tcase BACKGRROUP:\r\n\t\tval = \"Back Group\";\r\n\t\tbreak;\r\n\tcase TOGGLESHOWPERSISTANT:\r\n\t\tval = \"Toggle Show Persistent\";\r\n\t\tbreak;\r\n\tcase PASTE_SELECTED:\r\n\t\tval = \"Paste Selected\";\r\n\t\tbreak;\r\n\tcase DELETE_SELECTED:\r\n\t\tval = \"Delete Selected\";\r\n\t\tbreak;\r\n\tcase CLIP_PROPERTIES:\r\n\t\tval = \"Clip Properties\";\r\n\t\tbreak;\r\n\tcase PASTE_SELECTED_PLAIN_TEXT:\r\n\t\tval = \"Paste Selected Plain Text\";\r\n\t\tbreak;\r\n\tcase MOVE_CLIP_TO_GROUP:\r\n\t\tval = \"Move Clip To Group\";\r\n\t\tbreak;\r\n\tcase ELEVATE_PRIVlEGES:\r\n\t\tval = \"Option - Elevate Privileges\";\r\n\t\tbreak;\r\n\tcase SHOW_IN_TASKBAR:\r\n\t\tval = \"Option - Show In TaskBar\";\r\n\t\tbreak;\r\n\tcase COMPARE_SELECTED_CLIPS:\r\n\t\tval = \"Compare Selected Clips\";\r\n\t\tbreak;\r\n\tcase SELECT_LEFT_SIDE_COMPARE:\r\n\t\tval = \"Select Left File For Compare\";\r\n\t\tbreak;\r\n\tcase SELECT_RIGHT_SITE_AND_DO_COMPARE:\r\n\t\tval = \"Select Right File And Do Compare\";\r\n\t\tbreak;\r\n\tcase EXPORT_TO_TEXT_FILE:\r\n\t\tval = \"Export To Text File\";\r\n\t\tbreak;\r\n\tcase EXPORT_TO_QR_CODE:\r\n\t\tval = \"Export To QR Code\";\r\n\t\tbreak;\r\n\tcase EXPORT_TO_GOOGLE_TRANSLATE:\r\n\t\tval = \"Export To Google Translate\";\r\n\t\tbreak;\r\n\tcase EXPORT_TO_BITMAP_FILE:\r\n\t\tval = \"Export To Image File\";\r\n\t\tbreak;\r\n\tcase SAVE_CURRENT_CLIPBOARD:\r\n\t\tval = \"Save Current Clipboard\";\r\n\t\tbreak;\r\n\tcase MOVE_CLIP_UP:\r\n\t\tval = \"Move Clip Up\";\r\n\t\tbreak;\r\n\tcase MOVE_CLIP_DOWN:\r\n\t\tval = \"Move Clip Down\";\r\n\t\tbreak;\r\n\tcase MOVE_CLIP_TOP:\r\n\t\tval = \"Move Clip Top\";\r\n\t\tbreak;\r\n\tcase FILTER_ON_SELECTED_CLIP:\r\n\t\tval = \"Filter On Selected Clip\";\r\n\t\tbreak;\r\n\tcase PASTE_UPPER_CASE:\r\n\t\tval = \"Paste Upper Case\";\r\n\t\tbreak;\r\n\tcase PASTE_LOWER_CASE:\r\n\t\tval = \"Paste Lower Case\";\r\n\t\tbreak;\r\n\tcase PASTE_CAPITALiZE:\r\n\t\tval = \"Paste Capitalize\";\r\n\t\tbreak;\r\n\tcase PASTE_SENTENCE_CASE:\r\n\t\tval = \"Paste Sentence Case\";\r\n\t\tbreak;\r\n\tcase PASTE_REMOVE_LINE_FEEDS:\r\n\t\tval = \"Paste Remove Line Feeds\";\r\n\t\tbreak;\r\n\tcase PASTE_ADD_ONE_LINE_FEED:\r\n\t\tval = \"Paste Add One Line Feed\";\r\n\t\tbreak;\r\n\tcase PASTE_ADD_TWO_LINE_FEEDS:\r\n\t\tval = \"Paste Add Two Line Feeds\";\r\n\t\tbreak;\r\n\tcase PASTE_TYPOGLYCEMIA:\r\n\t\tval = \"Paste Typoglycemia\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_1:\r\n\t\tval = \"Send to friend 1\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_2:\r\n\t\tval = \"Send to friend 2\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_3:\r\n\t\tval = \"Send to friend 3\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_4:\r\n\t\tval = \"Send to friend 4\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_5:\r\n\t\tval = \"Send to friend 5\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_6:\r\n\t\tval = \"Send to friend 6\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_7:\r\n\t\tval = \"Send to friend 7\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_8:\r\n\t\tval = \"Send to friend 8\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_9:\r\n\t\tval = \"Send to friend 9\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_10:\r\n\t\tval = \"Send to friend 10\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_11:\r\n\t\tval = \"Send to friend 11\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_12:\r\n\t\tval = \"Send to friend 12\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_13:\r\n\t\tval = \"Send to friend 13\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_14:\r\n\t\tval = \"Send to friend 14\";\r\n\t\tbreak;\r\n\tcase SEND_TO_FRIEND_15:\r\n\t\tval = \"Send to friend 15\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_1:\r\n\t\tval = \"Paste Position 1\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_2:\r\n\t\tval = \"Paste Position 2\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_3:\r\n\t\tval = \"Paste Position 3\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_4:\r\n\t\tval = \"Paste Position 4\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_5:\r\n\t\tval = \"Paste Position 5\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_6:\r\n\t\tval = \"Paste Position 6\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_7:\r\n\t\tval = \"Paste Position 7\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_8:\r\n\t\tval = \"Paste Position 8\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_9:\r\n\t\tval = \"Paste Position 9\";\r\n\t\tbreak;\r\n\tcase PASTE_POSITION_10:\r\n\t\tval = \"Paste Position 10\";\r\n\t\tbreak;\r\n\tcase CONFIG_SHOW_FIRST_TEN_TEXT:\r\n\t\tval = \"Option - Show text for first ten copy hot keys\";\r\n\t\tbreak;\r\n\tcase CONFIG_SHOW_CLIP_WAS_PASTED:\r\n\t\tval = \"Option - Show indicator a clip has been pasted\";\r\n\t\tbreak;\r\n\tcase TOGGLE_LAST_GROUP_TOGGLE:\r\n\t\tval = \"Toggle Last Group Toggle\";\r\n\t\tbreak;\r\n\tcase MAKE_TOP_STICKY:\r\n\t\tval = \"Make Top Sticky Clip\";\r\n\t\tbreak;\r\n\tcase MAKE_LAST_STICKY:\r\n\t\tval = \"Make Last Sticky Clip\";\r\n\t\tbreak;\r\n\tcase REMOVE_STICKY:\r\n\t\tval = \"Remove Sticky Setting\";\r\n\t\tbreak;\r\n\tcase PASTE_ADD_CURRENT_TIME:\r\n\t\tval = \"Paste Add Current Time\";\r\n\t\tbreak;\r\n\tcase IMPORT_CLIP:\r\n\t\tval = \"Import Clip\";\r\n\t\tbreak;\r\n\tcase GLOBAl_HOTKEYS:\r\n\t\tval = \"Global HotKeys\";\r\n\t\tbreak;\r\n\tcase DELETE_CLIP_DATA:\r\n\t\tval = \"Delete Clip Data\";\r\n\t\tbreak;\r\n\tcase REPLACE_TOP_STICKY_CLIP:\r\n\t\tval = \"Replace Top Sticky Clip\";\r\n\t\tbreak;\r\n\tcase PROMPT_SEND_TO_FRIEND:\r\n\t\tval = \"Prompt send to friend\";\r\n\t\tbreak;\r\n\tcase SAVE_CF_HDROP_FIlE_DATA:\r\n\t\tval = \"Save copied file (cf_hdrop) contents into Ditto\";\r\n\t\tbreak;\r\n\tcase TOGGLE_CLIPBOARD_CONNECTION:\r\n\t\tval = \"Toggle clipboard connection\";\r\n\t\tbreak;\r\n\tcase MOVE_SELECTION_UP:\r\n\t\tval = \"Move Selection Up\";\r\n\t\tbreak;\r\n\tcase MOVE_SELECTION_DOWN:\r\n\t\tval = \"Move Selection Down\";\r\n\t\tbreak;\r\n\tcase TOGGLE_DESCRIPTION_WORD_WRAP:\r\n\t\tval = \"Toggle Description Word Wrap\";\r\n\t\tbreak;\r\n\tcase APPLY_LAST_SEARCH:\r\n\t\tval = \"Apply Last Search\";\r\n\t\tbreak;\r\n\tcase TOGGLE_SEARCH_METHOD:\r\n\t\tval = \"Toggle Search Method\";\r\n\t\tbreak;\r\n\tcase MOVE_CLIP_LAST:\r\n\t\tval = \"Move Clip Last\";\r\n\t\tbreak;\r\n\tcase PASTE_SCRIPT:\r\n\t\tval = \"Paste Script\";\r\n\t\tbreak;\r\n\tcase PASTE_DONT_MOVE_CLIP:\r\n\t\tval = \"Paste, Don't Change Clip Order\";\r\n\t\tbreak;\r\n\tcase PASTE_TRIM_WHITE_SPACE:\r\n\t\tval = \"Paste, Trim White Space\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_NONE:\r\n\t\tval = \"Set Transparency None\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_5:\r\n\t\tval = \"Set Transparency 5%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_10:\r\n\t\tval = \"Set Transparency 10%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_15:\r\n\t\tval = \"Set Transparency 15%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_20:\r\n\t\tval = \"Set Transparency 20%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_25:\r\n\t\tval = \"Set Transparency 25%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_30:\r\n\t\tval = \"Set Transparency 30%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_35:\r\n\t\tval = \"Set Transparency 35%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_40:\r\n\t\tval = \"Set Transparency 40%\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_TOGGLE:\r\n\t\tval = \"Toggle Transparency Enabled\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_INCREASE:\r\n\t\tval = \"Increase Transparency %\";\r\n\t\tbreak;\r\n\tcase TRANSPARENCY_DECREASE:\r\n\t\tval = \"Decrease Transparency %\";\r\n\t\tbreak;\r\n\tcase EMAILTO_BODY:\r\n\t\tval = \"EMail, Content In Body\";\r\n\t\tbreak;\r\n\tcase EMAILTO_ATTACH_EXPORT:\r\n\t\tval = \"EMail, Clip Export As Attachment\";\r\n\t\tbreak;\r\n\tcase EMAILTO_ATTACH_CONTENT:\r\n\t\tval = \"EMail, Content As Attachment\";\r\n\t\tbreak;\r\n\tcase GMAIL:\r\n\t\tval = \"Gmail\";\r\n\t\tbreak;\r\n\tcase SLUGIFY:\r\n\t\tval = \"Slugify\";\r\n\t\tbreak;\r\n\tcase INVERT_CASE:\r\n\t\tval = \"Invert Case\";\r\n\t\tbreak;\r\n\tcase COPY_SELECTION:\r\n\t\tval = \"Copy Selection\";\r\n\t\tbreak;\r\n\tcase FORCE_CLOSE_WINDOW:\r\n\t\tval = \"Force Close Window\";\r\n\t\tbreak;\r\n\tcase REFRESH_LIST:\r\n\t\tval = \"Refresh List\";\r\n\t\tbreak;\r\n\tcase DELETE_ALL_NON_USED_CLIPS:\r\n\t\tval = \"Delete all non used clips\";\r\n\t\tbreak;\r\n\tcase SET_DRAG_FILE_NAME:\r\n\t\tval = \"Set Drag File Name\";\r\n\t\tbreak;\r\n\tcase PASTE_CAMEL_CASE:\r\n\t\tval = \"Paste CamelCase\";\r\n\t\tbreak;\r\n\tcase PASTE_MULTI_IMAGE_HORIZONTAL:\r\n\t\tval = \"Paste Muliple Images Horizontally\";\r\n\t\tbreak;\r\n\tcase PASTE_MULTI_IMAGE_VERTICAL:\r\n\t\tval = \"Paste Muliple Images Vertically\";\r\n\t\tbreak;\r\n\t}\r\n\r\n\tCString translatedValue = theApp.m_Language.GetQuickPasteKeyboardString(value, val);\r\n\r\n\tif (translatedValue != _T(\"\"))\r\n\t{\r\n\t\treturn translatedValue;\r\n\t}\r\n\r\n\treturn val;\r\n}\r\n\r\nint ActionEnums::GetDefaultShortCutKeyA(ActionEnumValues value, int pos)\r\n{\r\n\tswitch(pos)\r\n\t{\r\n\tcase 0:\r\n\t\tswitch (value)\r\n\t\t{\r\n\t\tcase ActionEnums::SHOWDESCRIPTION:\r\n\t\t\treturn VK_F3;\r\n\t\tcase ActionEnums::NEXTDESCRIPTION:\r\n\t\t\treturn 'N';\r\n\t\tcase ActionEnums::PREVDESCRIPTION:\r\n\t\t\treturn 'P';\t\t\r\n\t\tcase ActionEnums::NEWGROUP:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_F7, HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::NEWGROUPSELECTION:\r\n\t\t\treturn VK_F7;\r\n\t\tcase ActionEnums::SHOWGROUPS:\r\n\t\t\treturn ACCEL_MAKEKEY('G', HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::NEWCLIP:\r\n\t\t\treturn ACCEL_MAKEKEY('N', HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::EDITCLIP:\r\n\t\t\treturn ACCEL_MAKEKEY('E', HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::CANCELFILTER:\r\n\t\t\treturn ACCEL_MAKEKEY('C', HOTKEYF_ALT);\r\n\t\tcase ActionEnums::TOGGLESHOWPERSISTANT:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_SPACE, HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::CLIP_PROPERTIES:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_RETURN, HOTKEYF_ALT);\r\n\t\tcase ActionEnums::PASTE_SELECTED_PLAIN_TEXT:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_RETURN, HOTKEYF_SHIFT);\r\n\t\tcase ActionEnums::COMPARE_SELECTED_CLIPS:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_F2, HOTKEYF_CONTROL);\r\n\t\tcase ActionEnums::PASTE_SELECTED:\r\n\t\t\treturn VK_RETURN;\r\n\t\tcase ActionEnums::SHOWMENU:\r\n\t\t\treturn VK_MOUSE_RIGHT_CLICK;\t\t\r\n\t\tcase PASTE_POSITION_1:\r\n\t\t\treturn ACCEL_MAKEKEY('1', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_2:\r\n\t\t\treturn ACCEL_MAKEKEY('2', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_3:\r\n\t\t\treturn ACCEL_MAKEKEY('3', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_4:\r\n\t\t\treturn ACCEL_MAKEKEY('4', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_5:\r\n\t\t\treturn ACCEL_MAKEKEY('5', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_6:\r\n\t\t\treturn ACCEL_MAKEKEY('6', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_7:\r\n\t\t\treturn ACCEL_MAKEKEY('7', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_8:\r\n\t\t\treturn ACCEL_MAKEKEY('8', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_9:\r\n\t\t\treturn ACCEL_MAKEKEY('9', HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_10:\r\n\t\t\treturn ACCEL_MAKEKEY('0', HOTKEYF_CONTROL);\r\n\t\tcase CLOSEWINDOW:\r\n\t\t\treturn VK_ESCAPE;\r\n\t\tcase FORCE_CLOSE_WINDOW:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_ESCAPE, HOTKEYF_SHIFT);\r\n\t\tcase TOGGLE_DESCRIPTION_WORD_WRAP:\r\n\t\t\treturn 'W';\r\n\t\tcase COPY_SELECTION:\r\n\t\t\treturn ACCEL_MAKEKEY('C', HOTKEYF_CONTROL);\r\n\t\tcase REFRESH_LIST:\r\n\t\t\treturn VK_F5;\r\n\t\tcase SET_DRAG_FILE_NAME:\r\n\t\t\treturn VK_F4;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tswitch (value)\r\n\t\t{\t\t\r\n\t\tcase ActionEnums::PASTE_SELECTED:\r\n\t\t\treturn VK_MOUSE_DOUBLE_CLICK;\r\n\t\tcase PASTE_POSITION_1:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD1, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_2:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD2, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_3:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD3, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_4:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD4, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_5:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD5, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_6:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD6, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_7:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD7, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_8:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD8, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_9:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD9, HOTKEYF_CONTROL);\r\n\t\tcase PASTE_POSITION_10:\r\n\t\t\treturn ACCEL_MAKEKEY(VK_NUMPAD0, HOTKEYF_CONTROL);\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\nint ActionEnums::GetDefaultShortCutKeyB(ActionEnumValues value, int pos)\r\n{\r\n\tswitch (pos)\r\n\t{\r\n\tcase 0:\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\nbool ActionEnums::UserConfigurable(ActionEnumValues value)\r\n{\r\n\tswitch (value)\r\n\t{\r\n\tcase ActionEnums::NEXTTABCONTROL:\r\n\tcase ActionEnums::PREVTABCONTROL:\r\n\tcase ActionEnums::MODIFIER_ACTVE_SELECTIONUP:\r\n\tcase ActionEnums::MODIFIER_ACTVE_SELECTIONDOWN:\r\n\tcase ActionEnums::MODIFIER_ACTVE_MOVEFIRST:\r\n\tcase ActionEnums::MODIFIER_ACTVE_MOVELAST:\r\n\tcase ActionEnums::BACKGRROUP:\r\n\tcase ActionEnums::DELETE_SELECTED:\r\n\tcase ActionEnums::TOGGLEFILELOGGING:\r\n\tcase ActionEnums::TOGGLEOUTPUTDEBUGSTRING:\r\n\tcase ActionEnums::HOMELIST:\r\n\tcase ActionEnums::PASTE_SCRIPT:\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool ActionEnums::ToolTipAction(ActionEnumValues value)\r\n{\r\n\tswitch (value)\r\n\t{\r\n\tcase ActionEnums::NEXTDESCRIPTION:\r\n\tcase ActionEnums::PREVDESCRIPTION:\r\n\tcase ActionEnums::TOGGLESHOWPERSISTANT:\r\n\tcase ActionEnums::TOGGLE_DESCRIPTION_WORD_WRAP:\r\n\tcase ActionEnums::CLOSEWINDOW:\r\n\tcase ActionEnums::SHOWDESCRIPTION:\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}"
        },
        {
          "name": "ActionEnums.h",
          "type": "blob",
          "size": 3.181640625,
          "content": "#pragma once\r\n\r\nclass ActionEnums\r\n{\r\npublic:\r\n\tActionEnums();\r\n\t~ActionEnums();\r\n\r\n\tenum ActionEnumValues\r\n\t{ \r\n\t\tFIRST_ACTION,\r\n\t\tSHOWDESCRIPTION,\r\n\t\tNEXTDESCRIPTION,\r\n\t\tPREVDESCRIPTION,\r\n\t\tSHOWMENU,\r\n\t\tNEWGROUP,\r\n\t\tNEWGROUPSELECTION,\r\n\t\tTOGGLEFILELOGGING,\r\n\t\tTOGGLEOUTPUTDEBUGSTRING,\r\n\t\tCLOSEWINDOW,\r\n\t\tNEXTTABCONTROL,\r\n\t\tPREVTABCONTROL,\r\n\t\tSHOWGROUPS,\r\n\t\tNEWCLIP,\r\n\t\tEDITCLIP,\r\n\t\tMODIFIER_ACTVE_SELECTIONUP,\r\n\t\tMODIFIER_ACTVE_SELECTIONDOWN,\r\n\t\tMODIFIER_ACTVE_MOVEFIRST,\r\n\t\tMODIFIER_ACTVE_MOVELAST,\r\n\t\tCANCELFILTER,\r\n\t\tHOMELIST,\r\n\t\tBACKGRROUP,\r\n\t\tTOGGLESHOWPERSISTANT,\r\n\t\tPASTE_SELECTED,\r\n\t\tDELETE_SELECTED,\r\n\t\tCLIP_PROPERTIES,\r\n\t\tPASTE_SELECTED_PLAIN_TEXT,\r\n\t\tMOVE_CLIP_TO_GROUP,\r\n\t\tELEVATE_PRIVlEGES,\r\n\t\tSHOW_IN_TASKBAR,\r\n\t\tCOMPARE_SELECTED_CLIPS,\r\n\t\tSELECT_LEFT_SIDE_COMPARE,\r\n\t\tSELECT_RIGHT_SITE_AND_DO_COMPARE,\r\n\t\tEXPORT_TO_TEXT_FILE,\r\n\t\tEXPORT_TO_QR_CODE,\r\n\t\tEXPORT_TO_GOOGLE_TRANSLATE,\r\n\t\tEXPORT_TO_BITMAP_FILE,\r\n\t\tSAVE_CURRENT_CLIPBOARD,\r\n\t\tMOVE_CLIP_UP,\r\n\t\tMOVE_CLIP_DOWN,\r\n\t\tMOVE_CLIP_TOP,\r\n\t\tFILTER_ON_SELECTED_CLIP,\r\n\t\tPASTE_UPPER_CASE,\r\n\t\tPASTE_LOWER_CASE,\r\n\t\tPASTE_CAPITALiZE,\r\n\t\tPASTE_SENTENCE_CASE,\r\n\t\tPASTE_REMOVE_LINE_FEEDS,\r\n\t\tPASTE_ADD_ONE_LINE_FEED,\r\n\t\tPASTE_ADD_TWO_LINE_FEEDS,\r\n\t\tPASTE_TYPOGLYCEMIA,\r\n\t\tSEND_TO_FRIEND_1,\r\n\t\tSEND_TO_FRIEND_2,\r\n\t\tSEND_TO_FRIEND_3,\r\n\t\tSEND_TO_FRIEND_4,\r\n\t\tSEND_TO_FRIEND_5,\r\n\t\tSEND_TO_FRIEND_6,\r\n\t\tSEND_TO_FRIEND_7,\r\n\t\tSEND_TO_FRIEND_8,\r\n\t\tSEND_TO_FRIEND_9,\r\n\t\tSEND_TO_FRIEND_10,\r\n\t\tSEND_TO_FRIEND_11,\r\n\t\tSEND_TO_FRIEND_12,\r\n\t\tSEND_TO_FRIEND_13,\r\n\t\tSEND_TO_FRIEND_14,\r\n\t\tSEND_TO_FRIEND_15,\r\n\t\tPASTE_POSITION_1,\r\n\t\tPASTE_POSITION_2,\r\n\t\tPASTE_POSITION_3,\r\n\t\tPASTE_POSITION_4,\r\n\t\tPASTE_POSITION_5,\r\n\t\tPASTE_POSITION_6,\r\n\t\tPASTE_POSITION_7,\r\n\t\tPASTE_POSITION_8,\r\n\t\tPASTE_POSITION_9,\r\n\t\tPASTE_POSITION_10,\r\n\t\tCONFIG_SHOW_FIRST_TEN_TEXT,\r\n\t\tCONFIG_SHOW_CLIP_WAS_PASTED,\r\n\t\tTOGGLE_LAST_GROUP_TOGGLE,\r\n\t\tMAKE_TOP_STICKY,\r\n\t\tMAKE_LAST_STICKY,\r\n\t\tREMOVE_STICKY,\r\n\t\tPASTE_ADD_CURRENT_TIME,\r\n\t\tIMPORT_CLIP,\r\n\t\tGLOBAl_HOTKEYS,\r\n\t\tDELETE_CLIP_DATA,\r\n\t\tREPLACE_TOP_STICKY_CLIP,\r\n\t\tPROMPT_SEND_TO_FRIEND,\r\n\t\tSAVE_CF_HDROP_FIlE_DATA,\r\n\t\tTOGGLE_CLIPBOARD_CONNECTION,\r\n\t\tMOVE_SELECTION_UP,\r\n\t\tMOVE_SELECTION_DOWN,\r\n\t\tTOGGLE_DESCRIPTION_WORD_WRAP,\r\n\t\tAPPLY_LAST_SEARCH,\r\n\t\tTOGGLE_SEARCH_METHOD,\r\n\t\tPASTE_SCRIPT,\r\n\t\tMOVE_CLIP_LAST,\r\n\t\tPASTE_DONT_MOVE_CLIP,\r\n\t\tPASTE_TRIM_WHITE_SPACE,\r\n\t\tTRANSPARENCY_NONE,\r\n\t\tTRANSPARENCY_5,\r\n\t\tTRANSPARENCY_10,\r\n\t\tTRANSPARENCY_15,\r\n\t\tTRANSPARENCY_20,\r\n\t\tTRANSPARENCY_25,\r\n\t\tTRANSPARENCY_30,\r\n\t\tTRANSPARENCY_35,\r\n\t\tTRANSPARENCY_40,\r\n\t\tTRANSPARENCY_TOGGLE,\r\n\t\tTRANSPARENCY_INCREASE,\r\n\t\tTRANSPARENCY_DECREASE,\r\n\t\tEMAILTO_BODY,\r\n\t\tEMAILTO_ATTACH_EXPORT,\r\n\t\tEMAILTO_ATTACH_CONTENT,\r\n\t\tGMAIL,\r\n\t\tSLUGIFY,\r\n\t\tINVERT_CASE,\r\n\t\tCOPY_SELECTION,\r\n\t\tFORCE_CLOSE_WINDOW,\r\n\t\tREFRESH_LIST,\r\n\t\tDELETE_ALL_NON_USED_CLIPS,\r\n\t\tSYSTEM_MENU,\r\n\t\tSET_DRAG_FILE_NAME,\r\n\t\tPASTE_CAMEL_CASE,\r\n\t\tPASTE_MULTI_IMAGE_HORIZONTAL,\r\n\t\tPASTE_MULTI_IMAGE_VERTICAL,\r\n\t\tASCII_TEXT_ONLY,\r\n\r\n\t\tLAST_ACTION\r\n\t};\r\n\r\n\tstatic CString EnumDescription(ActionEnumValues value);\r\n\r\n\tstatic int GetDefaultShortCutKeyA(ActionEnumValues value, int pos);\r\n\tstatic int GetDefaultShortCutKeyB(ActionEnumValues value, int pos);\r\n\tstatic bool UserConfigurable(ActionEnumValues value);\r\n\tstatic bool ToolTipAction(ActionEnumValues value);\r\n};\r\n\r\n"
        },
        {
          "name": "AddType.cpp",
          "type": "blob",
          "size": 3.9951171875,
          "content": "// AddType.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"Misc.h\"\n#include \"AddType.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddType dialog\n\n\nCAddType::CAddType(CWnd* pParent /*=NULL*/)\n\t: CDialog(CAddType::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CAddType)\n\tm_eCustomType = _T(\"\");\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CAddType::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CAddType)\n\tDDX_Control(pDX, IDC_LIST1, m_lbCandidateTypes);\n\tDDX_Text(pDX, IDC_EDIT1, m_eCustomType);\n\tDDV_MaxChars(pDX, m_eCustomType, 50);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CAddType, CDialog)\n\t//{{AFX_MSG_MAP(CAddType)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDC_RADIO_PRIMARY_TYPES, &CAddType::OnBnClickedRadioPrimaryTypes)\n\tON_BN_CLICKED(IDC_RADIO_CURRENT_TYPES, &CAddType::OnBnClickedRadioCurrentTypes)\n\tON_BN_CLICKED(IDC_RADIO_CUSTOM_TYPE, &CAddType::OnBnClickedRadioCustomType)\n\tON_BN_CLICKED(IDC_ADD_3, &CAddType::OnBnClickedAdd)\n\tON_LBN_DBLCLK(IDC_LIST1, &CAddType::OnLbnDblclkList)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddType message handlers\nBOOL CAddType::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\t\t\n\t\n\t::CheckDlgButton(m_hWnd, IDC_RADIO_CURRENT_TYPES, BST_CHECKED);\n\tOnBnClickedRadioCurrentTypes();\n\t\n\tm_lbCandidateTypes.SetFocus();\n\n\ttheApp.m_Language.UpdateOptionSupportedTypesAdd(this);\n\treturn FALSE;\n}\n\nvoid CAddType::AddCurrentClipboardTypes()\n{\n\tm_lbCandidateTypes.ResetContent();\n\n\tCOleDataObject oleData;\n\n\tif (!oleData.AttachClipboard())\n\t\treturn;\n\n\toleData.BeginEnumFormats();\n\n\tFORMATETC test;\n\n\twhile (oleData.GetNextFormat(&test))\n\t{\n\t\tBOOL b = oleData.IsDataAvailable(test.cfFormat);\n\t\tm_lbCandidateTypes.AddString(GetFormatName(test.cfFormat));\n\t}\n\n\toleData.Release();\n}\n\nvoid CAddType::AddCommonTypes()\n{\n\tm_lbCandidateTypes.ResetContent();\n\tfor (auto systemClipFormat : GetSystemClipFormats()) {\n\t\tm_lbCandidateTypes.AddString(GetFormatName(systemClipFormat));\n\t}\n\tm_lbCandidateTypes.AddString(GetFormatName(RegisterClipboardFormat(CF_RTF)));\n\tm_lbCandidateTypes.AddString(GetFormatName(RegisterClipboardFormat(CF_RTFNOOBJS)));\n\tm_lbCandidateTypes.AddString(GetFormatName(RegisterClipboardFormat(CF_RETEXTOBJ)));\n\tm_lbCandidateTypes.AddString(GetFormatName(RegisterClipboardFormat(_T(\"HTML Format\"))));\n}\n\nvoid CAddType::OnBnClickedRadioPrimaryTypes()\n{\n\tAddCommonTypes();\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_LIST1), SW_SHOW);\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_EDIT1), SW_HIDE);\n\tm_lbCandidateTypes.SetFocus();\n\tif (m_lbCandidateTypes.GetCount() > 0)\n\t{\n\t\tm_lbCandidateTypes.SetCurSel(0);\n\t\tm_lbCandidateTypes.SetSel(0);\n\t}\n}\n\nvoid CAddType::OnBnClickedRadioCurrentTypes()\n{\n\tAddCurrentClipboardTypes();\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_LIST1), SW_SHOW);\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_EDIT1), SW_HIDE);\n\tm_lbCandidateTypes.SetFocus();\n\tif (m_lbCandidateTypes.GetCount() > 0)\n\t{\n\t\tm_lbCandidateTypes.SetCurSel(0);\n\t\tm_lbCandidateTypes.SetSel(0);\n\n\t}\n}\n\nvoid CAddType::OnBnClickedRadioCustomType()\n{\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_EDIT1), SW_SHOW);\n\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_LIST1), SW_HIDE);\n\t::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT1));\n}\n\nvoid CAddType::OnBnClickedAdd()\n{\n\tm_csSelectedTypes.RemoveAll();\n\n\tif (IsDlgButtonChecked(IDC_RADIO_PRIMARY_TYPES) == BST_CHECKED ||\n\t\tIsDlgButtonChecked(IDC_RADIO_CURRENT_TYPES) == BST_CHECKED)\n\t{\n\t\tint nCount = m_lbCandidateTypes.GetSelCount();\n\t\tif (nCount)\n\t\t{\n\t\t\tCString cs;\n\t\t\tCArray<int, int> items;\n\t\t\titems.SetSize(nCount);\n\t\t\tm_lbCandidateTypes.GetSelItems(nCount, items.GetData());\n\n\t\t\tfor (int i = 0; i < nCount; i++)\n\t\t\t{\n\t\t\t\tm_lbCandidateTypes.GetText(items[i], cs);\n\t\t\t\tm_csSelectedTypes.Add(cs);\n\t\t\t}\n\t\t}\n\t}\n\telse if (IsDlgButtonChecked(IDC_RADIO_CUSTOM_TYPE) == BST_CHECKED)\n\t{\n\t\tUpdateData();\n\t\tm_csSelectedTypes.Add(m_eCustomType);\n\t}\n\n\tEndDialog(IDOK);\n}\n\n\nvoid CAddType::OnLbnDblclkList()\n{\n\tOnBnClickedAdd();\n}\n"
        },
        {
          "name": "AddType.h",
          "type": "blob",
          "size": 1.4228515625,
          "content": "#if !defined(AFX_ADDTYPE_H__783BC68A_076E_41CD_8F88_D8169D90BA55__INCLUDED_)\n#define AFX_ADDTYPE_H__783BC68A_076E_41CD_8F88_D8169D90BA55__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// AddType.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CAddType dialog\n\nclass CAddType : public CDialog\n{\n// Construction\npublic:\n\tCAddType(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CAddType)\n\tenum { IDD = IDD_ADD_TYPE };\n\tCListBox\tm_lbCandidateTypes;\n\tCString\tm_eCustomType;\n\t//}}AFX_DATA\n\n\tCStringArray m_csSelectedTypes;\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CAddType)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n\tvoid AddCommonTypes();\n\tvoid AddCurrentClipboardTypes();\n\n// Implementation\nprotected:\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CAddType)\n\tvirtual BOOL OnInitDialog();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tafx_msg void OnBnClickedRadioPrimaryTypes();\n\tafx_msg void OnBnClickedRadioCurrentTypes();\n\tafx_msg void OnBnClickedRadioCustomType();\n\tafx_msg void OnBnClickedAdd();\n\tafx_msg void OnLbnDblclkList();\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_ADDTYPE_H__783BC68A_076E_41CD_8F88_D8169D90BA55__INCLUDED_)\n"
        },
        {
          "name": "Addins",
          "type": "tree",
          "content": null
        },
        {
          "name": "AdvGeneral.cpp",
          "type": "blob",
          "size": 43.294921875,
          "content": "// AdvGeneral.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"AdvGeneral.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"ScriptEditor.h\"\r\n#include \"DimWnd.h\"\r\n\r\n\r\n// CAdvGeneral dialog\r\n\r\nIMPLEMENT_DYNAMIC(CAdvGeneral, CDialogEx)\r\n\r\nCAdvGeneral::CAdvGeneral(CWnd* pParent /*=NULL*/)\r\n\t: CDialogEx(CAdvGeneral::IDD, pParent)\r\n{\r\n\r\n}\r\n\r\nCAdvGeneral::~CAdvGeneral()\r\n{\r\n}\r\n\r\nvoid CAdvGeneral::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n\tDDX_Control(pDX, IDC_MFCPROPERTYGRID1, m_propertyGrid);\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CAdvGeneral, CDialogEx)\r\n\tON_BN_CLICKED(IDOK, &CAdvGeneral::OnBnClickedOk)\r\n\tON_WM_SIZE()\r\n\tON_BN_CLICKED(IDC_BT_COMPACT_AND_REPAIR, &CAdvGeneral::OnBnClickedBtCompactAndRepair)\r\n\tON_BN_CLICKED(IDC_BUTTON_COPY_SCRIPTS, &CAdvGeneral::OnBnClickedButtonCopyScripts)\r\n\tON_BN_CLICKED(IDC_BUTTON_PASTE_SCRIPTS, &CAdvGeneral::OnBnClickedButtonPasteScripts2)\r\n\tON_WM_GETMINMAXINFO()\r\n\tON_WM_NCLBUTTONDOWN()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CAdvGeneral message handlers\r\n\r\n#define SETTING_DESC_SIZE 1\r\n#define SETTING_SHOW_TASKBAR_ICON 2\r\n#define SETTING_SAVE_MULTI_PASTE 3\r\n#define SETTING_HIDE_ON_HOTKEY_IF_VISIBLE 4\r\n#define SETTING_PASTE_IN_ACTIVE_WINDOW 5\r\n#define SETTING_MAX_CLIP_SIZE 6\r\n#define SETTING_CLIP_SEPARATOR 7\r\n#define SETTING_ENSURE_CONNECTED 8\r\n#define SETTING_COPY_PLAY_SOUND 9\r\n#define SETTING_TEXT_FIRST_TEN 10 \r\n#define SETTING_SHOW_LEADING_WHITESPACE 11\r\n#define SETTING_LINES_PER_ROW 12\r\n#define SETTING_ENABLE_TRANSPARENCY 13\r\n#define SETTING_DRAW_THUMBNAILS 14\r\n#define SETTING_DRAW_RTF 15\r\n#define SETTING_FIND_AS_TYPE 16\r\n#define SETTING_ENSURE_WINDOW_IS_VISIBLE 17\r\n#define SETTING_SHOW_GROUP_CLIPS_IN_LIST 18\r\n#define SETTING_PROMPT_ON_DELETE 19\r\n#define SETTING_ALWAYS_SHOW_SCROLL_BAR 20\r\n#define SETTING_PASTE_AS_ADMIN 21\r\n#define SETTTING_SHOW_IN_TASKBAR 22\r\n#define SETTING_SHOW_CLIP_PASTED 23\r\n#define SETTING_DIFF_APP 24\r\n#define SETTING_TRANSPARENCY 25\r\n#define SETTING_UPDATE_ORDER_ON_PASTE 26\r\n#define SETTING_ALLOW_DUPLICATES 27\r\n#define SETTING_REGEX_FILTERING_1 28\r\n#define SETTING_REGEX_FILTERING_2 29\r\n#define SETTING_REGEX_FILTERING_3 30\r\n#define SETTING_REGEX_FILTERING_4 31\r\n#define SETTING_REGEX_FILTERING_5 32\r\n#define SETTING_REGEX_FILTERING_6 33\r\n#define SETTING_REGEX_FILTERING_7 34\r\n#define SETTING_REGEX_FILTERING_8 35\r\n#define SETTING_REGEX_FILTERING_9 36\r\n#define SETTING_REGEX_FILTERING_10 37\r\n#define SETTING_REGEX_FILTERING_11 38\r\n#define SETTING_REGEX_FILTERING_12 39\r\n#define SETTING_REGEX_FILTERING_13 40\r\n#define SETTING_REGEX_FILTERING_14 41\r\n#define SETTING_REGEX_FILTERING_15 42\r\n\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_1 43\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_2 44\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_3 45\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_4 46\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_5 47\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_6 48\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_7 49\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_8 50\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_9 51\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_10 52\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_11 53\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_12 54\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_13 55\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_14 56\r\n#define SETTING_REGEX_FILTERING_BY_PROCESS_NAME_15 57\r\n\r\n#define SETTING_SHOW_STARTUP_MESSAGE 58\r\n#define SETTING_TOOLTIP_TIMEOUT 59\r\n#define SETTING_SELECTED_INDEX 60\r\n#define SETTING_CLIPBOARD_SAVE_DELAY 61\r\n#define SETTING_SHOW_MSG_WHEN_RECEIVING_MANUAL_SENT_CLIP 62\r\n#define SETTING_MULTIPASTE_REVERSE_ORDER 63\r\n#define SETTING_DEFAULT_PASTE_STRING 64\r\n#define SETTING_DEFAULT_COPY_STRING 65\r\n#define SETTING_DEFAULT_CUT_STRING 66\r\n#define SETTING_REVERT_TO_TOP_LEVEL_GROUP 67\r\n#define SETTING_UPDATE_ORDER_ON_CTRL_C 68\r\n\r\n#define SETTING_TOOLTIP_LINES 69\r\n#define SETTING_TOOLTIP_CHARACTERS 70\r\n\r\n\r\n#define SETTING_ACTIVATE_WINDOW_DELAY 71\r\n#define SETTING_DOUBLE_KEYSTROKE_TIMEOUT 72\r\n#define SETTING_SEND_KEYS_DELAY 73\r\n#define SETTING_FIRST_TEN_HOTKEYS_START 74\r\n#define SETTING_FIRST_TEN_HOTKEYS_FONT_SIZE 75\r\n\r\n#define SETTING_OPEN_TO_GROUP_AS_ACTIVE_EXE 76\r\n#define SETTING_ADD_CF_HDROP_ON_DRAG 77\r\n#define SETTING_COPY_SAVE_DELAY 78\r\n#define SETTING_EDITOR_FONT_SIZE 79\r\n#define SETTING_MOVE_SELECTION_ON_OPEN_HOTKEY 80\r\n#define SETTING_ALOW_BACK_TO_BACK_DUPLICATES 81\r\n#define SETTING_MAINTAIN_SEARCH_VIEW 82\r\n#define SETTING_SEND_RECV_PORT 83\r\n#define SETTING_DEBUG_TO_FILE 84\r\n#define SETTING_DEBUG_TO_OUTPUT_STRING 85\r\n#define SETTING_NETWORK_BIND_IP_ADDRESS 86\r\n#define SETTING_DISABLE_FRIENDS 87\r\n#define SETTING_IGNORE_FALSE_COPIES_DELAY 88\r\n#define SETTING_REFRESH_VIEW_AFTER_PASTE 89\r\n#define SETTING_SLUGIFY_SEPARATOR 90\r\n#define SETTING_FAST_THUMBNAIL_MODE 91\r\n#define SETTING_CLIPBOARD_RESTORE_AFTER_COPY_BUFFER_DELAY 92\r\n#define SETTING_SUPPORT_ALL_TYPES 93\r\n#define SETTING_IGNORE_ANNOYING_CF_DIB 94\r\n#define SETTING_REGEX_CASE_INSENSITIVE 95\r\n#define SETTING_DRAW_COPIED_COLOR_CODE 96\r\n#define SETTING_CENTER_WINDOW_BELOW_CURSOR_CARET 97\r\n#define SETTING_TEXT_EDITOR_PATH 98\r\n#define SETTING_RTF_EDITOR_PATH 99\r\n#define SETTING_UPDATE_DESC_ON_CLIP_EDIT 100\r\n#define SETTING_QR_CODE_URL 101\r\n\r\nBOOL CAdvGeneral::OnInitDialog()\r\n{\r\n\tCDialogEx::OnInitDialog();\r\n\r\n\tHICON b = (HICON)LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME), IMAGE_ICON, 64, 64, LR_SHARED);\r\n\tSetIcon(b, TRUE);\r\n\r\n\tm_propertyGrid.ModifyStyle(0, WS_CLIPCHILDREN);\r\n\r\n\tCMFCPropertyGridProperty * pGroupTest = new CMFCPropertyGridProperty( _T( \"Ditto\" ) );\r\n\tm_propertyGrid.AddProperty(pGroupTest);\t\r\n\r\n\tm_Resize.SetParent(m_hWnd);\r\n\tm_Resize.AddControl(IDC_MFCPROPERTYGRID1, DR_SizeWidth | DR_SizeHeight);\r\n\tm_Resize.AddControl(IDOK, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDCANCEL, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_BT_COMPACT_AND_REPAIR, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_BUTTON_COPY_SCRIPTS, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_BUTTON_PASTE_SCRIPTS, DR_MoveTop);\r\n\r\n\tHDITEM hdItem;\r\n\thdItem.mask = HDI_WIDTH; // indicating cxy is width\r\n\tCDPI dpi(m_hWnd);\r\n\thdItem.cxy = dpi.Scale(325); // whatever you want the property name column width to be\r\n\tm_propertyGrid.GetHeaderCtrl().SetItem(0, &hdItem);\r\n\r\n\tm_propertyGrid.SetFont(this->GetFont());\t\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Activate window delay (100ms default)\"), (long)CGetSetOptions::SendKeysDelay(), _T(\"\"), SETTING_ACTIVATE_WINDOW_DELAY));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Add file drop when dragging clips\"), CGetSetOptions::GetAddCFHDROP_OnDrag(), SETTING_ADD_CF_HDROP_ON_DRAG);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Allow duplicates\"), CGetSetOptions::GetAllowDuplicates(), SETTING_ALLOW_DUPLICATES);\r\n\tAddTrueFalse(pGroupTest, _T(\"Allow back to back duplicates (if allowing duplicates)\"), CGetSetOptions::GetAllowBackToBackDuplicates(), SETTING_ALOW_BACK_TO_BACK_DUPLICATES);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Always show scroll bar\"), CGetSetOptions::GetShowScrollBar(), SETTING_ALWAYS_SHOW_SCROLL_BAR);\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Amount of text to save for description\"), CGetSetOptions::m_bDescTextSize, _T(\"\"), SETTING_DESC_SIZE));\r\n\tAddTrueFalse(pGroupTest, _T(\"Center window below cursor or caret\"), CGetSetOptions::GetCenterWindowBelowCursorOrCaret(), SETTING_CENTER_WINDOW_BELOW_CURSOR_CARET);\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Copy and save clipboard delay (ms)\"), (long)CGetSetOptions::GetCopyAndSveDelay(), _T(\"\"), SETTING_COPY_SAVE_DELAY));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Clipboard restore delay after copy buffer sent paste (ms, default: 750)\"), (long)(CGetSetOptions::GetDittoRestoreClipboardDelay()), _T(\"\"), SETTING_CLIPBOARD_RESTORE_AFTER_COPY_BUFFER_DELAY));\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Default paste string\"), CGetSetOptions::GetDefaultPasteString(), _T(\"\"), SETTING_DEFAULT_PASTE_STRING));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Default copy string\"), CGetSetOptions::GetDefaultCopyString(), _T(\"\"), SETTING_DEFAULT_COPY_STRING));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Default cut string\"), CGetSetOptions::GetDefaultCutString(), _T(\"\"), SETTING_DEFAULT_CUT_STRING));\r\n\t\r\n\tstatic TCHAR BASED_CODE szDiffFilter[] = _T(\"Diff Applications(*.exe)|*.exe||\");\r\n\tCMFCPropertyGridFileProperty* pDiffProp = new CMFCPropertyGridFileProperty(_T(\"Diff application path\"), TRUE, CGetSetOptions::GetDiffApp(), _T(\"exe\"), 0, szDiffFilter, (LPCTSTR)0, SETTING_DIFF_APP);\r\n\tpGroupTest->AddSubItem(pDiffProp);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Disable friends\"), !CGetSetOptions::GetAllowFriends(), SETTING_DISABLE_FRIENDS);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Display icon in system tray\"), CGetSetOptions::GetShowIconInSysTray(), SETTING_SHOW_TASKBAR_ICON);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Double shortcut keystroke timeout)\"), (long)CGetSetOptions::GetDoubleKeyStrokeTimeout(), _T(\"\"), SETTING_DOUBLE_KEYSTROKE_TIMEOUT));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Draw copied copied color code (hex #RRGGBB or rgb(r,g,b)\"), CGetSetOptions::GetDrawCopiedColorCode(), SETTING_DRAW_COPIED_COLOR_CODE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Draw RTF text in list (for RTF types) (could increase memory usage an display speed)\"), CGetSetOptions::GetDrawRTF(), SETTING_DRAW_RTF);\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Editor default font size\"), (long)CGetSetOptions::GetEditorDefaultFontSize(), _T(\"\"), SETTING_EDITOR_FONT_SIZE));\r\n\tAddTrueFalse(pGroupTest, _T(\"Elevated privileges to paste into elevated apps\"), CGetSetOptions::GetPasteAsAdmin(), SETTING_PASTE_AS_ADMIN);\r\n\tAddTrueFalse(pGroupTest, _T(\"Ensure Ditto is always connected to the clipboard\"), CGetSetOptions::GetEnsureConnectToClipboard(), SETTING_ENSURE_CONNECTED);\r\n\tAddTrueFalse(pGroupTest, _T(\"Ensure entire window is visible\"), CGetSetOptions::GetEnsureEntireWindowCanBeSeen(), SETTING_ENSURE_WINDOW_IS_VISIBLE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Fast thumbnail mode (default: true means low quality but fast. false means high quality but slow)\"), CGetSetOptions::GetFastThumbnailMode(), SETTING_FAST_THUMBNAIL_MODE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Find as you type\"), CGetSetOptions::GetFindAsYouType(), SETTING_FIND_AS_TYPE);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"First ten hot keys start index\"), (long)CGetSetOptions::GetFirstTenHotKeysStart(), _T(\"\"), SETTING_FIRST_TEN_HOTKEYS_START));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"First ten hot keys font size\"), (long)CGetSetOptions::GetFirstTenHotKeysFontSize(), _T(\"\"), SETTING_FIRST_TEN_HOTKEYS_FONT_SIZE));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Hide Ditto on hot key if Ditto is visible\"), CGetSetOptions::GetHideDittoOnHotKeyIfAlreadyShown(), SETTING_HIDE_ON_HOTKEY_IF_VISIBLE);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Ignore copies faster than (ms) (default: 500)\"), (long)CGetSetOptions::GetSaveClipDelay(), _T(\"\"), SETTING_IGNORE_FALSE_COPIES_DELAY));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Ignore annoying CF_DIB when a clip is detected as text content\"), CGetSetOptions::GetIgnoreAnnoyingCFDIB(), _T(\"Case insensitive. Recommended option is \\\"excel.exe; onenote.exe; powerpnt.exe\\\" \"), SETTING_IGNORE_ANNOYING_CF_DIB));\r\n\r\n\tpGroupTest->AddSubItem( new CMFCPropertyGridProperty(_T(\"Maximum clip size in bytes (0 for no limit)\"), CGetSetOptions::m_lMaxClipSizeInBytes, _T(\"\"), SETTING_MAX_CLIP_SIZE));\r\n\t\t\r\n\tAddTrueFalse(pGroupTest, _T(\"Maintain search view\"), CGetSetOptions::GetMaintainSearchView(), SETTING_MAINTAIN_SEARCH_VIEW);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Move selection on open hot key\"), CGetSetOptions::GetMoveSelectionOnOpenHotkey(), SETTING_MOVE_SELECTION_ON_OPEN_HOTKEY);\r\n\t\r\n\tpGroupTest->AddSubItem( new CMFCPropertyGridProperty(_T(\"Multi-paste clip separator ([LF] = line feed)\"), CGetSetOptions::GetMultiPasteSeparator(false), _T(\"\"), SETTING_CLIP_SEPARATOR));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Multi-paste in reverse order\"), CGetSetOptions::m_bMultiPasteReverse, SETTING_MULTIPASTE_REVERSE_ORDER);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Network send receive port (default: 23443)\"), (long)CGetSetOptions::GetPort(), _T(\"\"), SETTING_SEND_RECV_PORT));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Network server bind IP (default: *)\"), CGetSetOptions::GetNetworkBindIPAddress(), _T(\"\"), SETTING_NETWORK_BIND_IP_ADDRESS));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Open to group same as active exe\"), CGetSetOptions::GetOpenToGroupByActiveExe(), SETTING_OPEN_TO_GROUP_AS_ACTIVE_EXE);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"QRCode Url\"), CGetSetOptions::GetQRCodeUrl(), _T(\"\"), SETTING_QR_CODE_URL));\r\n\r\n\tstatic TCHAR BASED_CODE szFilter[] = _T(\"Sounds(*.wav)|*.wav||\");\r\n\tCMFCPropertyGridFileProperty* pFileProp = new CMFCPropertyGridFileProperty(_T(\"On copy play the sound\"), TRUE, CGetSetOptions::GetPlaySoundOnCopy(), _T(\"wav\"), 0, szFilter, (LPCTSTR)0, SETTING_COPY_PLAY_SOUND);\r\n\tpGroupTest->AddSubItem(pFileProp);\r\n\r\n\tstatic TCHAR BASED_CODE szTextEditorFilter[] = _T(\"Applications(*.exe)|*.exe||\");\r\n\tCMFCPropertyGridFileProperty* pTextEditorProp = new CMFCPropertyGridFileProperty(_T(\"Text editor path\"), TRUE, CGetSetOptions::GetTextEditorPath(), _T(\"exe\"), 0, szTextEditorFilter, (LPCTSTR)0, SETTING_TEXT_EDITOR_PATH);\r\n\tpGroupTest->AddSubItem(pTextEditorProp);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Paste clip in active window after selection\"), CGetSetOptions::GetSendPasteAfterSelection(), SETTING_PASTE_IN_ACTIVE_WINDOW);\r\n\tAddTrueFalse(pGroupTest, _T(\"Prompt when deleting clips\"), CGetSetOptions::GetPromptWhenDeletingClips(), SETTING_PROMPT_ON_DELETE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Revert to top level group on close\"), CGetSetOptions::GetRevertToTopLevelGroup(), SETTING_REVERT_TO_TOP_LEVEL_GROUP);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Refresh view after paste\"), CGetSetOptions::GetRefreshViewAfterPasting(), SETTING_REFRESH_VIEW_AFTER_PASTE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Regex case insensitive search\"), CGetSetOptions::GetRegexCaseInsensitive(), SETTING_REGEX_CASE_INSENSITIVE);\r\n\r\n\tstatic TCHAR BASED_CODE szRTFEditorFilter[] = _T(\"Applications(*.exe)|*.exe||\");\r\n\tCMFCPropertyGridFileProperty* pRTFEditorProp = new CMFCPropertyGridFileProperty(_T(\"RTF editor path\"), TRUE, CGetSetOptions::GetRTFEditorPath(), _T(\"exe\"), 0, szRTFEditorFilter, (LPCTSTR)0, SETTING_RTF_EDITOR_PATH);\r\n\tpGroupTest->AddSubItem(pRTFEditorProp);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Save clipboard delay (ms, default: 100)\"), (long)(CGetSetOptions::GetProcessDrawClipboardDelay()), _T(\"\"), SETTING_CLIPBOARD_SAVE_DELAY));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Save multi-pastes\"), CGetSetOptions::GetSaveMultiPaste(), SETTING_SAVE_MULTI_PASTE);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Selected index\"), (long)(CGetSetOptions::SelectedIndex()+1), _T(\"\"), SETTING_SELECTED_INDEX));\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Send keys delay (ms)\"), (long)CGetSetOptions::RealSendKeysDelay(), _T(\"\"), SETTING_SEND_KEYS_DELAY));\r\n\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Show clips that are in groups in main list\"), CGetSetOptions::GetShowAllClipsInMainList(), SETTING_SHOW_GROUP_CLIPS_IN_LIST);\r\n\tAddTrueFalse(pGroupTest, _T(\"Show leading whitespace\"), CGetSetOptions::GetDescShowLeadingWhiteSpace(), SETTING_SHOW_LEADING_WHITESPACE);\r\n\tAddTrueFalse(pGroupTest, _T(\"Show in taskbar\"), CGetSetOptions::GetShowInTaskBar(), SETTTING_SHOW_IN_TASKBAR);\r\n\tAddTrueFalse(pGroupTest, _T(\"Show indicator a clip has been pasted\"), CGetSetOptions::GetShowIfClipWasPasted(), SETTING_SHOW_CLIP_PASTED);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Show message that we received a manual sent clip\"), CGetSetOptions::GetShowMsgWhenReceivingManualSentClip(), SETTING_SHOW_MSG_WHEN_RECEIVING_MANUAL_SENT_CLIP);\t\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Show startup tooltip message\"), CGetSetOptions::GetShowStartupMessage(), SETTING_SHOW_STARTUP_MESSAGE);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Show text for first ten copy hot keys\"), CGetSetOptions::GetShowTextForFirstTenHotKeys(), SETTING_TEXT_FIRST_TEN);\r\n\tAddTrueFalse(pGroupTest, _T(\"Show thumbnails(for CF_DIB and PNG types) (could increase memory usage and display speed)\"), CGetSetOptions::GetDrawThumbnail(), SETTING_DRAW_THUMBNAILS);\r\n\t\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Slugify Separator (default: -)\"), CGetSetOptions::GetSlugifySeparator(), _T(\"\"), SETTING_SLUGIFY_SEPARATOR));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Support all types ignoring supported type list (default: false))\"), CGetSetOptions::GetSupportAllTypes(), SETTING_SUPPORT_ALL_TYPES);\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Text lines per clip\"), CGetSetOptions::GetLinesPerRow(), _T(\"\"), SETTING_LINES_PER_ROW));\r\n\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Tooltip display time(ms) max of 32000 (-1 default (5 seconds), 0 to turn off)\"), CGetSetOptions::m_tooltipTimeout, _T(\"\"), SETTING_TOOLTIP_TIMEOUT));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Tooltip maximum display lines\"), (long)CGetSetOptions::GetMaxToolTipLines(), _T(\"\"), SETTING_TOOLTIP_LINES));\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Tooltip display characters\"), (long)CGetSetOptions::GetMaxToolTipCharacters(), _T(\"\"), SETTING_TOOLTIP_CHARACTERS));\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Transparency enabled\"), CGetSetOptions::GetEnableTransparency(), SETTING_ENABLE_TRANSPARENCY);\r\n\tpGroupTest->AddSubItem(new CMFCPropertyGridProperty(_T(\"Transparency percentage\"), CGetSetOptions::GetTransparencyPercent(), _T(\"\"), SETTING_TRANSPARENCY));\r\n\tAddTrueFalse(pGroupTest, _T(\"Update description on clip edit\"), CGetSetOptions::GetUpdateDescWhenSavingClip(), SETTING_UPDATE_DESC_ON_CLIP_EDIT);\r\n\tAddTrueFalse(pGroupTest, _T(\"Update clip order on paste\"), CGetSetOptions::GetUpdateTimeOnPaste(), SETTING_UPDATE_ORDER_ON_PASTE);\r\n\tAddTrueFalse(pGroupTest, _T(\"Update clip Order on ctrl-c\"), CGetSetOptions::GetUpdateClipOrderOnCtrlC(), SETTING_UPDATE_ORDER_ON_CTRL_C);\r\n\r\n\tAddTrueFalse(pGroupTest, _T(\"Write debug to file\"), CGetSetOptions::GetEnableDebugLogging(), SETTING_DEBUG_TO_FILE);\r\n\tAddTrueFalse(pGroupTest, _T(\"Write debug to OutputDebugString\"), CGetSetOptions::GetEnableDebugLogging(), SETTING_DEBUG_TO_OUTPUT_STRING);\r\n\r\n\tCMFCPropertyGridProperty * regexFilterGroup = new CMFCPropertyGridProperty(_T(\"Exclude clips by Regular Expressions\"));\r\n\tm_propertyGrid.AddProperty(regexFilterGroup);\t\r\n\r\n\tCString processFilterDesc = _T(\"Process making the copy first must match this before the Regex will be applied (empty or * for all processes) (separate multiples by ;)\");\r\n\tCString regexFilterDesc = _T(\"If copied text matches this regular expression then the clip will not be saved to Ditto\");\r\n\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"1 Regex\"), CGetSetOptions::GetRegexFilter(0), regexFilterDesc, SETTING_REGEX_FILTERING_1));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"1 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(0), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_1));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"2 Regex\"), CGetSetOptions::GetRegexFilter(1), regexFilterDesc, SETTING_REGEX_FILTERING_2));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"2 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(1), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_2));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"3 Regex\"), CGetSetOptions::GetRegexFilter(2), regexFilterDesc, SETTING_REGEX_FILTERING_3));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"3 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(2), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_3));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"4 Regex\"), CGetSetOptions::GetRegexFilter(3), regexFilterDesc, SETTING_REGEX_FILTERING_4));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"4 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(3), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_4));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"5 Regex\"), CGetSetOptions::GetRegexFilter(4), regexFilterDesc, SETTING_REGEX_FILTERING_5));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"5 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(4), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_5));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"6 Regex\"), CGetSetOptions::GetRegexFilter(5), regexFilterDesc, SETTING_REGEX_FILTERING_6));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"6 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(5), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_6));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"7 Regex\"), CGetSetOptions::GetRegexFilter(6), regexFilterDesc, SETTING_REGEX_FILTERING_7));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"7 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(6), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_7));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"8 Regex\"), CGetSetOptions::GetRegexFilter(7), regexFilterDesc, SETTING_REGEX_FILTERING_8));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"8 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(7), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_8));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"9 Regex\"), CGetSetOptions::GetRegexFilter(8), regexFilterDesc, SETTING_REGEX_FILTERING_9));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"9 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(8), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_9));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"10 Regex\"), CGetSetOptions::GetRegexFilter(9), regexFilterDesc, SETTING_REGEX_FILTERING_10));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"10 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(9), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_10));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"11 Regex\"), CGetSetOptions::GetRegexFilter(10), regexFilterDesc, SETTING_REGEX_FILTERING_11));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"11 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(10), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_11));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"12 Regex\"), CGetSetOptions::GetRegexFilter(11), regexFilterDesc, SETTING_REGEX_FILTERING_12));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"12 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(11), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_12));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"13 Regex\"), CGetSetOptions::GetRegexFilter(12), regexFilterDesc, SETTING_REGEX_FILTERING_13));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"13 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(12), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_13));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"14 Regex\"), CGetSetOptions::GetRegexFilter(13), regexFilterDesc, SETTING_REGEX_FILTERING_14));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"14 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(13), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_14));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"15 Regex\"), CGetSetOptions::GetRegexFilter(14), regexFilterDesc, SETTING_REGEX_FILTERING_15));\r\n\tregexFilterGroup->AddSubItem(new CMFCPropertyGridProperty(_T(\"15 Process Name\"), CGetSetOptions::GetRegexFilterByProcessName(14), processFilterDesc, SETTING_REGEX_FILTERING_BY_PROCESS_NAME_14));\r\n\r\n\tregexFilterGroup->Expand(FALSE);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CAdvGeneral::AddTrueFalse(CMFCPropertyGridProperty * pGroupTest, CString desc, BOOL value, int settingId)\r\n{\r\n\tCString stringValue = _T(\"False\");\r\n\tif(value)\r\n\t{\r\n\t\tstringValue = _T(\"True\");\r\n\t}\r\n\r\n\tCMFCPropertyGridProperty *pCombo = new CMFCPropertyGridProperty(desc, stringValue, _T(\"\"), settingId);\r\n\tpCombo->AddOption(_T(\"True\"));\r\n\tpCombo->AddOption(_T(\"False\"));\r\n\tpCombo->AllowEdit(FALSE);\r\n\tpGroupTest->AddSubItem(pCombo);\r\n}\r\n\r\nvoid CAdvGeneral::OnBnClickedOk()\r\n{\r\n\tint topLevelCount = m_propertyGrid.GetPropertyCount();\r\n\tfor (int topLevel = 0; topLevel < topLevelCount; topLevel++)\r\n\t{\r\n\t\tint count = m_propertyGrid.GetProperty(topLevel)->GetSubItemsCount();\r\n\t\tfor (int row = 0; row < count; row++)\r\n\t\t{\r\n\t\t\tCMFCPropertyGridProperty* prop = m_propertyGrid.GetProperty(topLevel)->GetSubItem(row);\r\n\r\n\t\t\tCOleVariant i = prop->GetValue();\r\n\t\t\tLPVARIANT pNewValue = (LPVARIANT)i;\r\n\r\n\t\t\tCOleVariant iOrig = prop->GetOriginalValue();\r\n\t\t\tLPVARIANT pOrigValue = (LPVARIANT)iOrig;\r\n\r\n\t\t\tswitch ((int)prop->GetData())\r\n\t\t\t{\r\n\t\t\tcase SETTING_DESC_SIZE:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDescTextSize(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SELECTED_INDEX:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetSelectedIndex(max((pNewValue->lVal-1), 0));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_CLIPBOARD_SAVE_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetProcessDrawClipboardDelay(max(pNewValue->lVal, 0));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SHOW_TASKBAR_ICON:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowIconInSysTray(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SAVE_MULTI_PASTE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetSaveMultiPaste(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_HIDE_ON_HOTKEY_IF_VISIBLE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetHideDittoOnHotKeyIfAlreadyShown(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_PASTE_IN_ACTIVE_WINDOW:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetSendPasteAfterSelection(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_MAX_CLIP_SIZE:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetMaxClipSizeInBytes(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_CLIP_SEPARATOR:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetMultiPasteSeparator(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_ENSURE_CONNECTED:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetEnsureConnectToClipboard(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_COPY_PLAY_SOUND:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetPlaySoundOnCopy(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_TEXT_FIRST_TEN:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowTextForFirstTenHotKeys(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SHOW_LEADING_WHITESPACE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetDescShowLeadingWhiteSpace(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_LINES_PER_ROW:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetLinesPerRow(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ENABLE_TRANSPARENCY:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetEnableTransparency(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_TRANSPARENCY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tint value = 100;\r\n\t\t\t\t\tif (pNewValue->lVal <= 100 && pNewValue->lVal > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = pNewValue->lVal;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tCGetSetOptions::SetTransparencyPercent(value);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DRAW_THUMBNAILS:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetDrawThumbnail(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FAST_THUMBNAIL_MODE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetFastThumbnailMode(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DRAW_RTF:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetDrawRTF(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FIND_AS_TYPE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetFindAsYouType(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ENSURE_WINDOW_IS_VISIBLE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetEnsureEntireWindowCanBeSeen(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SHOW_GROUP_CLIPS_IN_LIST:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowAllClipsInMainList(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_PROMPT_ON_DELETE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetPromptWhenDeletingClips(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ALWAYS_SHOW_SCROLL_BAR:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowScrollBar(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_PASTE_AS_ADMIN:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetPasteAsAdmin(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTTING_SHOW_IN_TASKBAR:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowInTaskBar(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SHOW_CLIP_PASTED:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowIfClipWasPasted(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SHOW_MSG_WHEN_RECEIVING_MANUAL_SENT_CLIP:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowMsgWhenReceivingManualSentClip(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DIFF_APP:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDiffApp(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_UPDATE_ORDER_ON_PASTE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetUpdateTimeOnPaste(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_UPDATE_ORDER_ON_CTRL_C:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetUpdateClipOrderOnCtrlC(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_MULTIPASTE_REVERSE_ORDER:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetMultiPasteReverse(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ALLOW_DUPLICATES:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetAllowDuplicates(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ALOW_BACK_TO_BACK_DUPLICATES:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetAllowBackToBackDuplicates(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_REGEX_FILTERING_1:\r\n\t\t\tcase SETTING_REGEX_FILTERING_2:\r\n\t\t\tcase SETTING_REGEX_FILTERING_3:\r\n\t\t\tcase SETTING_REGEX_FILTERING_4:\r\n\t\t\tcase SETTING_REGEX_FILTERING_5:\r\n\t\t\tcase SETTING_REGEX_FILTERING_6:\r\n\t\t\tcase SETTING_REGEX_FILTERING_7:\r\n\t\t\tcase SETTING_REGEX_FILTERING_8:\r\n\t\t\tcase SETTING_REGEX_FILTERING_9:\r\n\t\t\tcase SETTING_REGEX_FILTERING_10:\r\n\t\t\tcase SETTING_REGEX_FILTERING_11:\r\n\t\t\tcase SETTING_REGEX_FILTERING_12:\r\n\t\t\tcase SETTING_REGEX_FILTERING_13:\r\n\t\t\tcase SETTING_REGEX_FILTERING_14:\r\n\t\t\tcase SETTING_REGEX_FILTERING_15:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetRegexFilter(pNewValue->bstrVal, (((int)prop->GetData()) - SETTING_REGEX_FILTERING_1));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_1:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_2:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_3:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_4:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_5:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_6:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_7:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_8:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_9:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_10:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_11:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_12:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_13:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_14:\r\n\t\t\tcase SETTING_REGEX_FILTERING_BY_PROCESS_NAME_15:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetRegexFilterByProcessName(pNewValue->bstrVal, (((int)prop->GetData()) - SETTING_REGEX_FILTERING_BY_PROCESS_NAME_1));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_SHOW_STARTUP_MESSAGE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetShowStartupMessage(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_TOOLTIP_TIMEOUT:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetToolTipTimeout(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_TOOLTIP_LINES:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetMaxToolTipLines(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_TOOLTIP_CHARACTERS:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetMaxToolTipCharacters(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_DEFAULT_PASTE_STRING:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDefaultPasteString(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DEFAULT_COPY_STRING:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDefaultCopyString(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DEFAULT_CUT_STRING:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDefaultCutString(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SLUGIFY_SEPARATOR:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetSlugifySeparator(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_REVERT_TO_TOP_LEVEL_GROUP:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetRevertToTopLevelGroup(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_ACTIVATE_WINDOW_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetSendKeysDelay(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SEND_KEYS_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetRealSendKeysDelay(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_CLIPBOARD_RESTORE_AFTER_COPY_BUFFER_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDittoRestoreClipboardDelay(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DOUBLE_KEYSTROKE_TIMEOUT:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDoubleKeyStrokeTimeout(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FIRST_TEN_HOTKEYS_START:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetFirstTenHotKeysStart(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_FIRST_TEN_HOTKEYS_FONT_SIZE:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetFirstTenHotKeysFontSize(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_OPEN_TO_GROUP_AS_ACTIVE_EXE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetOpenToGroupByActiveExe(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SETTING_ADD_CF_HDROP_ON_DRAG:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetAddCFHDROP_OnDrag(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_COPY_SAVE_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetCopyAndSveDelay(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_EDITOR_FONT_SIZE:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetEditorDefaultFontSize(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_MOVE_SELECTION_ON_OPEN_HOTKEY:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetMoveSelectionOnOpenHotkey(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_MAINTAIN_SEARCH_VIEW:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetMaintainSearchView(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SEND_RECV_PORT:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetPort(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DEBUG_TO_FILE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetEnableDebugLogging(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DEBUG_TO_OUTPUT_STRING:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetEnableOutputDebugStringLogging(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_NETWORK_BIND_IP_ADDRESS:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetNetworkBindIPAddress(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DISABLE_FRIENDS:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetAllowFriends(!val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_IGNORE_FALSE_COPIES_DELAY:\r\n\t\t\t\tif (pNewValue->lVal != pOrigValue->lVal)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetSaveClipDelay(pNewValue->lVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_REFRESH_VIEW_AFTER_PASTE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetRefreshViewAfterPasting(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_SUPPORT_ALL_TYPES:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetSupportAllTypes(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_IGNORE_ANNOYING_CF_DIB:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetIgnoreAnnoyingCFDIB(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_REGEX_CASE_INSENSITIVE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetRegexCaseInsensitive(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_DRAW_COPIED_COLOR_CODE:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetDrawCopiedColorCode(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_CENTER_WINDOW_BELOW_CURSOR_CARET:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetCenterWindowBelowCursorOrCaret(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_TEXT_EDITOR_PATH:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetTextEditorPath(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_RTF_EDITOR_PATH:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetRTFEditorPath(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_UPDATE_DESC_ON_CLIP_EDIT:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tBOOL val = wcscmp(pNewValue->bstrVal, L\"True\") == 0;\r\n\t\t\t\t\tCGetSetOptions::SetUpdateDescWhenSavingClip(val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase SETTING_QR_CODE_URL:\r\n\t\t\t\tif (wcscmp(pNewValue->bstrVal, pOrigValue->bstrVal) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetQRCodeUrl(pNewValue->bstrVal);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCDialogEx::OnOK();\r\n}\r\n\r\nvoid CAdvGeneral::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCDialogEx::OnSize(nType, cx, cy);\r\n\r\n\tif (((GetKeyState(VK_LBUTTON) & 0x100) != 0) &&\r\n\t\tm_mouseDownOnCaption == false)\r\n\t{\r\n\t\tm_Resize.MoveControls(CSize(cx, cy));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_Resize.SetParent(m_hWnd);\r\n\t}\r\n}\r\n\r\nvoid CAdvGeneral::OnBnClickedBtCompactAndRepair()\r\n{\r\n\tauto msg = theApp.m_Language.GetString(\"CompactRepairWarning\", \"Warning this can take quite a long time and require up to double the hard drive space as your current database size, Continue?\");\r\n\tint ret = MessageBox(msg, _T(\"Ditto\"), MB_YESNO);\r\n\r\n\tif (ret == IDYES)\r\n\t{\r\n\t\tCWaitCursor wait;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < 100; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint toDeleteCount = theApp.m_db.execScalar(_T(\"SELECT COUNT(clipID) FROM MainDeletes\"));\r\n\t\t\t\t\tif (toDeleteCount <= 0)\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tRemoveOldEntries(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\t\ttheApp.m_db.execDML(_T(\"PRAGMA auto_vacuum = 1\"));\r\n\t\t\ttheApp.m_db.execQuery(_T(\"VACUUM\"));\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n}\r\n\r\nvoid CAdvGeneral::OnBnClickedButtonCopyScripts()\r\n{\r\n\tCDimWnd dim(this);\r\n\r\n\tCScriptEditor e(this);\r\n\te.m_title = _T(\"Copy Scripts\");\r\n\te.m_xml.Load(CGetSetOptions::GetCopyScriptsXml());\r\n\tif (e.DoModal() == IDOK)\r\n\t{\r\n\t\tCGetSetOptions::SetCopyScriptsXml(e.m_xml.Save());\r\n\t}\r\n}\r\n\r\nvoid CAdvGeneral::OnBnClickedButtonPasteScripts2()\r\n{\r\n\tCDimWnd dim(this);\r\n\r\n\tCScriptEditor e(this);\r\n\te.m_title = _T(\"Paste Scripts\");\r\n\te.m_xml.Load(CGetSetOptions::GetPasteScriptsXml());\r\n\tif (e.DoModal() == IDOK)\r\n\t{\r\n\t\tCGetSetOptions::SetPasteScriptsXml(e.m_xml.Save());\r\n\t}\r\n}\r\n\r\nvoid CAdvGeneral::OnGetMinMaxInfo(MINMAXINFO* lpMMI)\r\n{\r\n\tlpMMI->ptMinTrackSize.x = 450;\r\n\tlpMMI->ptMinTrackSize.y = 450;\r\n\r\n\tCDialogEx::OnGetMinMaxInfo(lpMMI);\r\n}\r\n\r\nvoid CAdvGeneral::OnNcLButtonDown(UINT nHitTest, CPoint point)\r\n{\r\n\tm_mouseDownOnCaption = false;\r\n\r\n\tif (nHitTest == HTCAPTION)\r\n\t{\r\n\t\tm_mouseDownOnCaption = true;\r\n\t}\r\n\r\n\tCDialog::OnNcLButtonDown(nHitTest, point);\r\n}"
        },
        {
          "name": "AdvGeneral.h",
          "type": "blob",
          "size": 0.9404296875,
          "content": "#pragma once\n#include \"afxpropertygridctrl.h\"\n#include \"DialogResizer.h\"\n\nclass CAdvGeneral : public CDialogEx\n{\n\tDECLARE_DYNAMIC(CAdvGeneral)\n\npublic:\n\tCAdvGeneral(CWnd* pParent = NULL);   // standard constructor\n\tvirtual ~CAdvGeneral();\n\n// Dialog Data\n\tenum { IDD = IDD_ADV_OPTIONS };\n\n\tCDialogResizer m_Resize;\n\tbool m_mouseDownOnCaption;\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n\tvoid AddTrueFalse(CMFCPropertyGridProperty * pGroupTest, CString desc, BOOL value, int settingId);\n\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tCMFCPropertyGridCtrl m_propertyGrid;\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnBnClickedOk();\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnBnClickedBtCompactAndRepair();\n\tafx_msg void OnBnClickedButtonCopyScripts();\n\tafx_msg void OnBnClickedButtonPasteScripts2();\n\tafx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);\n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);\n};\n"
        },
        {
          "name": "AlphaBlend.cpp",
          "type": "blob",
          "size": 3.8349609375,
          "content": "// AlphaBlend.cpp: implementation of the CAlphaBlend class.\n//\n//////////////////////////////////////////////////////////////////////\n// By Mike Ryan (mike@codexia.com)\n// Copyright (c) 2000\n// 07.03.2000\n//\n// Free usage granted in all applications including commercial.\n// Do NOT distribute without permission from me.  I can be reached\n// at mike@codexia.com, http://www.codexia.com\n// Please feel free to email me about this class.\n//\n// NOTE:\n//\n// You will need the latest Win32 API availble at:\n// http://msdn.microsoft.com/downloads/c-frame.htm?007#/downloads/sdks/\n// in order to compile this programs.\n//\n// This will only run under Windows 2000.  It is not compatible with\n// Windows 9x or Windows NT 4.0.\n//\n// Also, you must add the following lines to the StdAfx.h at the top\n// above the #define VC_EXTRALEAN.\n//\n//\t#define _WIN32_WINNT 0x0500\n//\t#define WINVER 0x0500\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"AlphaBlend.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCAlphaBlend::CAlphaBlend()\n{\n\tm_hWnd = NULL;\n\tm_nOpacity = 0;\n\tm_bTransparent = false;\n}\n\nCAlphaBlend::~CAlphaBlend()\n{\n}\n\nCAlphaBlend::CAlphaBlend(HWND hWnd, int nOpactiy)\n{\n\tm_hWnd = NULL;\n\tm_nOpacity = 0;\n\tm_bTransparent = false;\n\n\tSetWindowHandle(hWnd);\n\tSetOpacity(nOpactiy);\n}\n\nCAlphaBlend::CAlphaBlend(CWnd *pWnd, int nOpacity)\n{\n\tm_hWnd = NULL;\n\tm_nOpacity = 0;\n\tm_bTransparent = false;\n\n\tSetWindowHandle(pWnd);\n\tSetOpacity(nOpacity);\n}\n\nBOOL CAlphaBlend::SetWindowHandle(HWND hWnd)\n{\n\tif (::IsWindow(hWnd)) m_hWnd = hWnd;\n\telse return false;\n\n\treturn true;\n}\n\nBOOL CAlphaBlend::SetWindowHandle(CWnd *pWnd)\n{\n\tif (pWnd && ::IsWindow(pWnd->GetSafeHwnd())) \n\t\tm_hWnd = pWnd->GetSafeHwnd();\n\telse \n\t\treturn false;\n\treturn true;\n}\n\nBOOL CAlphaBlend::SetOpacity(int nOpacity)\n{\n\tif (nOpacity >= 0 && nOpacity <= OPACITY_MAX)\n\t{\n\t\tm_nOpacity = nOpacity;\n\t\tif (m_bTransparent)\n\t\t{\n\t\t\t// update the transparency\n\t\t\tASSERT(::IsWindow(m_hWnd));\n\t\t\tSetLayeredWindowAttributesEx(m_hWnd, 0, m_nOpacity, LWA_ALPHA);\t\t\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nBOOL CAlphaBlend::SetLayeredWindowAttributesEx(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)\n{\n\tBOOL bRet = FALSE;\n\ttypedef BOOL (CALLBACK* fnc)(HWND, COLORREF, BYTE, DWORD);\n\tHINSTANCE DLL;\n\tfnc setLayeredWindowAttributes;\n\t\n\tDLL = LoadLibrary(_T(\"user32.dll\"));\n\tif(DLL != NULL)\n\t{\n\t\tsetLayeredWindowAttributes = (fnc)GetProcAddress(DLL,\"SetLayeredWindowAttributes\");  \n\t\t\n\t\tif(setLayeredWindowAttributes) \n\t\t{\n\t\t\tbRet = setLayeredWindowAttributes(hwnd, crKey, bAlpha, dwFlags);\n\t\t}\n\t\t\t\t\n\t\tFreeLibrary(DLL);\n\t}\n\n\treturn bRet;\n}\n\nvoid CAlphaBlend::SetTransparent(BOOL bTransparent)\n{\n\tif (bTransparent)\n\t{\n\t\t// make sure they have set it up properly\n\t\tASSERT(m_nOpacity >= 0 && m_nOpacity <= OPACITY_MAX);\n\t\tASSERT(m_hWnd && ::IsWindow(m_hWnd));\n\n\t\t// make it transparent\n\t\tlong l = GetWindowLong(m_hWnd, GWL_EXSTYLE);\n\t\tif(!(l & WS_EX_LAYERED))\n\t\t{\n\t\t\tl |= WS_EX_LAYERED;\n\t\t\tSetWindowLong(m_hWnd, GWL_EXSTYLE, l);\n\t\t}\n\n\t\tSetLayeredWindowAttributesEx(m_hWnd, 0, m_nOpacity, LWA_ALPHA);\n\n\t\tCRect r;\n\t\t::GetWindowRect(m_hWnd, r);\n\t\t::InvalidateRect(m_hWnd, r, true);\n\n\t\tm_bTransparent = true;\n\t}\n\telse\n\t{\n\t\tlong l = GetWindowLong(m_hWnd, GWL_EXSTYLE);\n\t\tif(l & WS_EX_LAYERED)\n\t\t{\n\t\t\tl ^= WS_EX_LAYERED;\n\t\t\tSetWindowLong(m_hWnd, GWL_EXSTYLE, l);\n\t\t\tCRect r;\n\t\t\t::GetWindowRect(m_hWnd, r);\n\t\t\t::InvalidateRect(m_hWnd, r, true);\n\t\t}\n\t\tm_bTransparent = false;\n\t}\n}\n\nBOOL CAlphaBlend::SetTransparent(HWND hWnd, int nOpacity, BOOL bTransparent)\n{\n\t// set members\n\tif (!SetWindowHandle(hWnd)) \n\t\treturn false;\n\n\tif (!SetOpacity(nOpacity)) \n\t\treturn false;\n\n\tSetTransparent(bTransparent);\n\n\treturn true;\n}\n"
        },
        {
          "name": "AlphaBlend.h",
          "type": "blob",
          "size": 2.0478515625,
          "content": "// AlphaBlend.h: interface for the CAlphaBlend class.\n//\n//////////////////////////////////////////////////////////////////////\n// By Mike Ryan (mike@codexia.com)\n// Copyright (c) 2000\n// 07.03.2000\n//\n// Free usage granted in all applications including commercial.\n// Do NOT distribute without permission from me.  I can be reached\n// at mike@codexia.com, http://www.codexia.com\n// Please feel free to email me about this class.\n//\n// NOTE:\n//\n// You will need the latest Win32 API availble at:\n// http://msdn.microsoft.com/downloads/c-frame.htm?007#/downloads/sdks/\n// in order to compile this programs.\n//\n// This will only run under Windows 2000.  It is not compatible with\n// Windows 9x or Windows NT 4.0.\n//\n// Also, you must add the following lines to the StdAfx.h at the top\n// above the #define VC_EXTRALEAN.\n//\n//\t#define _WIN32_WINNT 0x0500\n//\t#define WINVER 0x0500\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_ALPHABLEND_H__B453CE58_5571_48B4_BD84_3BB70D6A41A3__INCLUDED_)\n#define AFX_ALPHABLEND_H__B453CE58_5571_48B4_BD84_3BB70D6A41A3__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#define OPACITY_MAX\t\t\t255\n\nclass CAlphaBlend  \n{\npublic:\n\tCAlphaBlend();\n\tCAlphaBlend(HWND hWnd, int nOpacity=220);\n\tCAlphaBlend(CWnd *pWnd, int nOpacity=220);\n\tvirtual ~CAlphaBlend();\n\n\t//// SET DATA MEMBERS ////\n\tBOOL SetWindowHandle(HWND hWnd);\n\tBOOL SetWindowHandle(CWnd *pWnd);\n\tBOOL SetOpacity(int nOpacity=220);\n\n\t//// RUN IT ////\n\tvoid SetTransparent(BOOL bTransparent=true);\n\n\t//// FOR THOSE OF US WHO ARE LAZY ////\n\tBOOL SetTransparent(HWND hWnd, int nOpactiy=220, BOOL bTransparent=true);\n\n\t//// GET TRANSPARENT/OPACITY STATUS ////\n\tint GetOpacity(void) { return m_nOpacity; }\n\tHWND GetWindow(void) { return m_hWnd; }\n\tBOOL IsTransparent(void) { return m_bTransparent; }\n\nprotected:\n\tint m_nOpacity;\n\tHWND m_hWnd;\n\n\tBOOL m_bTransparent;\n\n\tBOOL SetLayeredWindowAttributesEx(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);\n};\n\n#endif // !defined(AFX_ALPHABLEND_H__B453CE58_5571_48B4_BD84_3BB70D6A41A3__INCLUDED_)\n"
        },
        {
          "name": "AutoSendToClientThread.cpp",
          "type": "blob",
          "size": 3.6904296875,
          "content": "#include \"stdafx.h\"\n#include \"AutoSendToClientThread.h\"\n#include \"Misc.h\"\n#include \"Options.h\"\n#include \"CP_Main.h\"\n#include \"client.h\"\n\nCAutoSendToClientThread::CAutoSendToClientThread(void)\n{\n\tm_waitTimeout = 30000;\n\tm_threadName = \"CAutoSendToClientThread\";\n\tfor(int eventEnum = 0; eventEnum < ECAUTOSENDTOCLIENTTHREADEVENTS_COUNT; eventEnum++)\n\t{\n\t\tAddEvent(eventEnum);\n\t}\n}\n\nCAutoSendToClientThread::~CAutoSendToClientThread(void)\n{\n}\n\nvoid CAutoSendToClientThread::FireSendToClient(CClipList *pClipList)\n{\n\tStart();\n\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\tif(m_threadRunning)\n\t{\n\t\tLog(_T(\"Adding clip to send to client in thread\"));\n\n\t\tPOSITION pos = pClipList->GetHeadPosition();\n\t\twhile(pos)\n\t\t{\n\t\t\tCClip *pClip = pClipList->GetNext(pos);\n\t\t\n\t\t\tm_saveClips.AddTail(pClip);\n\t\t}\n\n\t\tpClipList->RemoveAll();\n\t\t\n\t\tFireEvent(SEND_TO_CLIENTS);\n\t}\n\telse\n\t{\n\t\tLog(_T(\"Error creating thread to send to clients\"));\n\t}\n}\n\nvoid CAutoSendToClientThread::OnTimeOut(void *param)\n{\n\tStop(-1);\n}\n\nvoid CAutoSendToClientThread::OnEvent(int eventId, void *param)\n{\n\tswitch((eCAutoSendToClientThreadEvents)eventId)\n\t{\n\tcase SEND_TO_CLIENTS:\n\t\tOnSendToClient();\n\t\tbreak;\n\t}\n}\n\nvoid CAutoSendToClientThread::OnSendToClient()\n{\n\tCClipList *pLocalClips = new CClipList();\n\n\t//Save the clips locally\n\t{\n\t\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\t\tPOSITION pos;\n\t\tCClip* pClip;\n\n\t\tpos = m_saveClips.GetHeadPosition();\n\t\twhile(pos)\n\t\t{\n\t\t\tpClip = m_saveClips.GetNext(pos);\n\t\t\tpLocalClips->AddTail(pClip);\n\t\t}\n\n\t\t//pLocalClips now own, the clips\n\t\tm_saveClips.RemoveAll();\n\t}\n\n\tSendToClient(pLocalClips);\n\n\tdelete pLocalClips;\n\tpLocalClips = NULL;\n}\n\nbool CAutoSendToClientThread::SendToClient(CClipList *pClipList)\n{\n\tLogSendRecieveInfo(\"@@@@@@@@@@@@@@@ - START OF SendClientThread - @@@@@@@@@@@@@@@\");\n\n\tif(pClipList == NULL)\n\t{\n\t\tLogSendRecieveInfo(\"ERROR if(pClipList == NULL)\");\n\t\treturn FALSE;\n\t}\n\n\tINT_PTR lCount = pClipList->GetCount();\n\n\tLogSendRecieveInfo(StrF(_T(\"Start of Send ClientThread Count - %d\"), lCount));\n\n\tfor(int nClient = 0; nClient < MAX_SEND_CLIENTS; nClient++)\n\t{\n\t\tif(CGetSetOptions::m_SendClients[nClient].bSendAll && \n\t\t\tCGetSetOptions::m_SendClients[nClient].csIP.GetLength() > 0)\n\t\t{\n\t\t\tCClient client;\n\t\t\tif(client.OpenConnection(CGetSetOptions::m_SendClients[nClient].csIP) == FALSE)\n\t\t\t{\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"ERROR opening connection to %s\"), CGetSetOptions::m_SendClients[nClient].csIP));\n\n\t\t\t\tif(CGetSetOptions::m_SendClients[nClient].bShownFirstError == FALSE)\n\t\t\t\t{\n\t\t\t\t\tCString cs;\n\t\t\t\t\tcs.Format(_T(\"Error opening connection to %s\"), CGetSetOptions::m_SendClients[nClient].csIP);\n\t\t\t\t\t::SendMessage(theApp.m_MainhWnd, WM_SEND_RECIEVE_ERROR, (WPARAM)cs.GetBuffer(cs.GetLength()), 0);\n\t\t\t\t\tcs.ReleaseBuffer();\n\n\t\t\t\t\tCGetSetOptions::m_SendClients[nClient].bShownFirstError = TRUE;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//We were connected successfully show an error next time we can't connect\n\t\t\tCGetSetOptions::m_SendClients[nClient].bShownFirstError = FALSE;\n\n\t\t\tCClip* pClip;\n\t\t\tPOSITION pos;\n\t\t\tpos = pClipList->GetHeadPosition();\n\t\t\twhile(pos)\n\t\t\t{\n\t\t\t\tpClip = pClipList->GetNext(pos);\n\t\t\t\tif(pClip == NULL)\n\t\t\t\t{\n\t\t\t\t\tASSERT(FALSE);\n\t\t\t\t\tLogSendRecieveInfo(\"Error in GetNext\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Sending clip to %s\"), CGetSetOptions::m_SendClients[nClient].csIP));\n\n\t\t\t\tif(client.SendItem(pClip, false) == FALSE)\n\t\t\t\t{\n\t\t\t\t\tCString cs;\n\t\t\t\t\tcs.Format(_T(\"Error sending clip to %s\"), CGetSetOptions::m_SendClients[nClient].csIP);\n\t\t\t\t\t::SendMessage(theApp.m_MainhWnd, WM_SEND_RECIEVE_ERROR, (WPARAM)cs.GetBuffer(cs.GetLength()), 0);\n\t\t\t\t\tcs.ReleaseBuffer();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.CloseConnection();\n\t\t}\n\t}\n\n\tLogSendRecieveInfo(\"@@@@@@@@@@@@@@@ - END OF SendClientThread - @@@@@@@@@@@@@@@\");\n\n\treturn TRUE;\n}"
        },
        {
          "name": "AutoSendToClientThread.h",
          "type": "blob",
          "size": 0.578125,
          "content": "#pragma once\n\n#include \"EventThread.h\"\n#include \"Clip.h\"\n#include <afxmt.h>\n\n\nclass CAutoSendToClientThread : public CEventThread\n{\npublic:\n\tCAutoSendToClientThread(void);\n\t~CAutoSendToClientThread(void);\n\n\tenum eCAutoSendToClientThreadEvents\n\t{ \n\t\tSEND_TO_CLIENTS,\n\n\t\tECAUTOSENDTOCLIENTTHREADEVENTS_COUNT  //must be last\n\t};\n\n\tvoid FireSendToClient(CClipList *pClipList);\n\nprotected:\n\tvirtual void OnEvent(int eventId, void *param);\n\tvirtual void OnTimeOut(void *param);\n\n\tvoid OnSendToClient();\n\tbool SendToClient(CClipList *pClipList);\n\n\tCCriticalSection m_cs;\n\tCClipList m_saveClips;\n};\n\n"
        },
        {
          "name": "BitmapHelper.cpp",
          "type": "blob",
          "size": 9.9306640625,
          "content": "// BitmapHelper.cpp: implementation of the CBitmapHelper class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"BitmapHelper.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCBitmapHelper::CBitmapHelper()\n{\n\n}\n\nCBitmapHelper::~CBitmapHelper()\n{\n\n}\n\nint CBitmapHelper::GetCBitmapWidth(const CBitmap & cbm)\n{\n\tBITMAP bm;\n\tcbm.GetObject(sizeof(BITMAP),&bm);\n\treturn bm.bmWidth;\n}\n\nint CBitmapHelper::GetCBitmapHeight(const CBitmap & cbm)\n{\n\tBITMAP bm;\n\tcbm.GetObject(sizeof(BITMAP),&bm);\n\treturn bm.bmHeight;\n} \n\nBOOL CBitmapHelper::GetCBitmap(void\t*pClip2, CDC *pDC, CBitmap *pBitMap, int nMaxHeight)\n{\n\tCClipFormat\t\t*pClip = (CClipFormat *)pClip2;\n\n\tif(pClip->m_cfType != CF_DIB &&\n\t\tpClip->m_cfType != theApp.m_PNG_Format)\n\t\treturn false;\n\tif(!pBitMap)\n\t\treturn false;\n\tif (nMaxHeight < 0)\n\t\treturn false;\n\n\tGdiplus::Bitmap *gdipBitmap = pClip->CreateGdiplusBitmap();\n\tif (gdipBitmap == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tconst UINT gdipHeight = gdipBitmap->GetHeight();\n\tconst UINT gdipWidth = gdipBitmap->GetWidth();\n\tif (gdipHeight == 0 || gdipWidth == 0) \n\t{\n\t\tdelete gdipBitmap;\n\t\treturn false;\n\t}\n\n\tconst int nHeight = min(nMaxHeight, (int)gdipHeight);\n\tconst int nWidth = (nHeight * gdipWidth) / gdipHeight;\n\n\t//do the resize\n\tpBitMap->CreateCompatibleBitmap(pDC, nWidth, nHeight);\n\tASSERT(pBitMap->m_hObject != NULL);\n\n\tCDC MemDc2;\n\tMemDc2.CreateCompatibleDC(pDC);\n\n\tCBitmap* oldBitmap2 = MemDc2.SelectObject(pBitMap);\n\n\tGdiplus::Rect dest(0, 0, nWidth, nHeight);\n\tGdiplus::ImageAttributes attrs;\n\tGdiplus::Graphics graphics(MemDc2);\n\t\n\tGdiplus::InterpolationMode interpolationMode = Gdiplus::InterpolationModeHighQualityBicubic;\n\tif (CGetSetOptions::GetFastThumbnailMode())\n\t{\n\t\tinterpolationMode = Gdiplus::InterpolationModeBicubic;\n\t}\n\tgraphics.SetInterpolationMode(interpolationMode);\n\tgraphics.SetCompositingMode(Gdiplus::CompositingModeSourceOver);\n\tgraphics.SetPixelOffsetMode(Gdiplus::PixelOffsetModeHalf);\n\tgraphics.DrawImage(gdipBitmap, dest, 0, 0, gdipWidth, gdipHeight, Gdiplus::UnitPixel, &attrs);\n\n\tMemDc2.SelectObject(oldBitmap2);\n\tdelete gdipBitmap;\n\n\treturn true;\n}\n\nBOOL CBitmapHelper::GetCBitmap(CClipFormats &clips, CDC* pDC, CBitmap* pBitMap, BOOL horizontal)\n{\n\tBOOL bRet = FALSE;\n\tif (!pBitMap)\n\t\treturn bRet;\n\n\tint count = (int)clips.GetCount();\n\tint width = 0;\n\tint height = 0;\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tCClipFormat clip = clips[i];\n\n\t\tGdiplus::Bitmap* gdipBitmap = clip.CreateGdiplusBitmap();\n\n\t\tif (horizontal)\n\t\t{\n\t\t\twidth += (int)gdipBitmap->GetWidth();\n\t\t\theight = max((int)gdipBitmap->GetHeight(), height);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twidth = max((int)gdipBitmap->GetWidth(), width);\n\t\t\theight += (int)gdipBitmap->GetHeight();\n\t\t}\n\t\n\t\tdelete gdipBitmap;\n\t}\n\n\tpBitMap->CreateCompatibleBitmap(pDC, width, height);\n\tASSERT(pBitMap->m_hObject != NULL);\n\n\tCDC MemDc2;\n\tMemDc2.CreateCompatibleDC(pDC);\n\n\tCBitmap* oldBitmap2 = MemDc2.SelectObject(pBitMap);\n\n\tGdiplus::Graphics graphics(MemDc2);\n\tgraphics.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);\n\tgraphics.SetPixelOffsetMode(Gdiplus::PixelOffsetModeHalf);\n\n\tgraphics.Clear(Gdiplus::Color::White);\n\n\tint destX = 0;\n\tint destY = 0;\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tCClipFormat clip = clips[i];\n\n\t\tif (clip.m_cfType != CF_DIB &&\n\t\t\tclip.m_cfType != theApp.m_PNG_Format)\n\t\t\tcontinue;\n\t\n\t\tGdiplus::Bitmap* gdipBitmap = clip.CreateGdiplusBitmap();\n\t\tif (gdipBitmap == NULL)\n\t\t\tcontinue;\n\n\t\tconst UINT gdipHeight = gdipBitmap->GetHeight();\n\t\tconst UINT gdipWidth = gdipBitmap->GetWidth();\n\t\tif (gdipHeight == 0 || gdipWidth == 0) \n\t\t{\n\t\t\tdelete gdipBitmap;\n\t\t\tcontinue;\n\t\t}\n\n\t\tGdiplus::Rect dest(destX, destY, gdipBitmap->GetWidth(), gdipBitmap->GetHeight());\n\t\tGdiplus::ImageAttributes attrs;\n\t\tgraphics.DrawImage(gdipBitmap, dest, 0, 0, gdipBitmap->GetWidth(), gdipBitmap->GetHeight(), Gdiplus::UnitPixel, &attrs);\n\n\t\tif (horizontal)\n\t\t\tdestX += gdipBitmap->GetWidth();\n\t\telse\n\t\t\tdestY += gdipBitmap->GetHeight();\n\n\t\tdelete gdipBitmap;\n\t\tbRet = TRUE;\n\t}\n\n\tMemDc2.SelectObject(oldBitmap2);\n\n\treturn bRet;\n}\n\nWORD CBitmapHelper::PaletteSize(LPSTR lpDIB)\n{\n    // calculate the size required by the palette\n    if (IS_WIN30_DIB (lpDIB))\n        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));\n    else\n        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));\n}\n\nWORD CBitmapHelper::DIBNumColors(LPSTR lpDIB)\n{\n    WORD wBitCount;  // DIB bit count\n\n    // If this is a Windows-style DIB, the number of colors in the\n    // color table can be less than the number of bits per pixel\n    // allows for (i.e. lpbi->biClrUsed can be set to some value).\n    // If this is the case, return the appropriate value.\n    \n\n    if (IS_WIN30_DIB(lpDIB))\n    {\n        DWORD dwClrUsed;\n\n        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;\n        if (dwClrUsed)\n\n        return (WORD)dwClrUsed;\n    }\n\n    // Calculate the number of colors in the color table based on\n    // the number of bits per pixel for the DIB.\n    \n    if (IS_WIN30_DIB(lpDIB))\n        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;\n    else\n        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;\n\n    // return number of colors based on bits per pixel\n\n    switch (wBitCount)\n    {\n        case 1:\n            return 2;\n\n        case 4:\n            return 16;\n\n        case 8:\n            return 256;\n\n        default:\n            return 0;\n    }\n}\n\n\nHANDLE CBitmapHelper::hBitmapToDIB(HBITMAP hBitmap, DWORD dwCompression, HPALETTE hPal) \n{\n    BITMAP                  bm;\n    BITMAPINFOHEADER        bi;\n    LPBITMAPINFOHEADER      lpbi;\n    DWORD                   dwLen;\n    HANDLE                  hDIB;\n    HANDLE                  handle;\n    HDC                     hDC;\n\n    // The function has no arg for bitfields\n    if( dwCompression == BI_BITFIELDS )\n            return NULL;\n\n    // If a palette has not been supplied use defaul palette\n    if (hPal==NULL)\n            hPal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);\n\n    // Get bitmap information\n    (void)GetObject( hBitmap, sizeof(bm), (LPSTR)&bm );\n\n    // Initialize the bitmapinfoheader\n    bi.biSize               = sizeof(BITMAPINFOHEADER);\n    bi.biWidth              = bm.bmWidth;\n    bi.biHeight             = bm.bmHeight;\n    bi.biPlanes             = 1;\n    bi.biBitCount           = static_cast<USHORT>( bm.bmPlanes * bm.bmBitsPixel );\n    bi.biCompression        = dwCompression;\n    bi.biSizeImage          = 0;\n    bi.biXPelsPerMeter      = 0;\n    bi.biYPelsPerMeter      = 0;\n    bi.biClrUsed            = 0;\n    bi.biClrImportant       = 0;\n\n \tdwLen = bi.biSize + PaletteSize((LPSTR)&bi);\n\n    // We need a device context to get the DIB from\n    hDC = GetDC(NULL);\n    hPal = SelectPalette(hDC, hPal, FALSE);\n    (void)RealizePalette(hDC);\n\n    // Allocate enough memory to hold bitmapinfoheader and color table\n    hDIB = GlobalAlloc(GMEM_FIXED, dwLen);\n\n    if (!hDIB)\n\t{\n        (void)SelectPalette(hDC, hPal, FALSE);\n        ReleaseDC(NULL, hDC);\n        return NULL;\n    }\n\n    lpbi = (LPBITMAPINFOHEADER)hDIB;\n\n    *lpbi = bi;\n\n    // Call GetDIBits with a NULL lpBits param, so the device driver \n    // will calculate the biSizeImage field \n    (void)GetDIBits(hDC, hBitmap, 0L, (DWORD)bi.biHeight,\n                    (LPBYTE)NULL, (LPBITMAPINFO)lpbi, (DWORD)DIB_RGB_COLORS);\n\n    bi = *lpbi;\n\n    // If the driver did not fill in the biSizeImage field, then compute it\n    // Each scan line of the image is aligned on a DWORD (32bit) boundary\n    if (bi.biSizeImage == 0)\n\t{\n        bi.biSizeImage = ((((bi.biWidth * bi.biBitCount) + 31) & ~31) / 8) \n                                        * bi.biHeight;\n\n        // If a compression scheme is used the result may infact be larger\n        // Increase the size to account for this.\n        if (dwCompression != BI_RGB)\n                bi.biSizeImage = (bi.biSizeImage * 3) / 2;\n    }\n\n    // Realloc the buffer so that it can hold all the bits\n    dwLen += bi.biSizeImage;\n\thandle = GlobalReAlloc(hDIB, dwLen, GMEM_MOVEABLE);\n    if(!handle)\n\t{\n\t\tGlobalFree(hDIB);\n\n\t\t// Reselect the original palette\n\t\t(void)SelectPalette(hDC, hPal, FALSE);\n\t\tReleaseDC(NULL, hDC);\n\t\treturn NULL;\n\t}\n\t\n\thDIB = handle;\n\n    // Get the bitmap bits\n    lpbi = (LPBITMAPINFOHEADER)hDIB;\n\n    // FINALLY get the DIB\n    BOOL bGotBits = GetDIBits(hDC, hBitmap,\n                            0L,                             // Start scan line\n                            (DWORD)bi.biHeight,             // # of scan lines\n                            (LPBYTE)lpbi                    // address for bitmap bits\n                            + (bi.biSize + PaletteSize((LPSTR)&bi)),\n                            (LPBITMAPINFO)lpbi,             // address of bitmapinfo\n                            (DWORD)DIB_RGB_COLORS);         // Use RGB for color table\n\n    if( !bGotBits )\n    {\n        GlobalFree(hDIB);\n        \n        (void)SelectPalette(hDC, hPal, FALSE);\n        ReleaseDC(NULL,hDC);\n        return NULL;\n    }\n\n    (void)SelectPalette(hDC, hPal, FALSE);\n    ReleaseDC(NULL, hDC);\n    return hDIB;\n}\n\n\nbool CBitmapHelper::DrawDIB(CDC *pDC, HANDLE hData, int nLeft, int nRight, int &nWidth)\n{\n\tLPBITMAPINFO\tlpBI ;\n\tvoid*           pDIBBits;\n\t\n\tlpBI = (LPBITMAPINFO)GlobalLock(hData);\n\tif (!lpBI)\n\t\treturn false;\n\n\tint nColors = lpBI->bmiHeader.biClrUsed ? lpBI->bmiHeader.biClrUsed : 1 << lpBI->bmiHeader.biBitCount;\n\n\tif( lpBI->bmiHeader.biBitCount > 8 )\n\t{\n\t\tpDIBBits = (LPVOID)((LPDWORD)(lpBI->bmiColors + lpBI->bmiHeader.biClrUsed) + \n\t\t\t((lpBI->bmiHeader.biCompression == BI_BITFIELDS) ? 3 : 0));\n\t}\n\telse\n\t{\n\t\tpDIBBits = (LPVOID)(lpBI->bmiColors + nColors);\n\t}\n\n\t::StretchDIBits(pDC->m_hDC,\n\t\t\t\tnLeft, nRight, \n\t\t\t\tlpBI->bmiHeader.biWidth, lpBI->bmiHeader.biHeight,\n\t\t\t\t0, 0, lpBI->bmiHeader.biWidth, \n\t\t\t\tlpBI->bmiHeader.biHeight,\n\t\t\t\tpDIBBits, lpBI, DIB_PAL_COLORS, SRCCOPY);\n\n\tnWidth = lpBI->bmiHeader.biWidth;\n\n\tGlobalUnlock(hData);\n\n\treturn true;\n}"
        },
        {
          "name": "BitmapHelper.h",
          "type": "blob",
          "size": 1.0986328125,
          "content": "// BitmapHelper.h: interface for the CBitmapHelper class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_BITMAPHELPER_H__641D941B_5487_4F85_BFC1_012F2083A8B6__INCLUDED_)\n#define AFX_BITMAPHELPER_H__641D941B_5487_4F85_BFC1_012F2083A8B6__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))\n\nclass CBitmapHelper  \n{\npublic:\n\tCBitmapHelper();\n\tvirtual ~CBitmapHelper();\n\n\tstatic int\t\tGetCBitmapWidth(const CBitmap & cbm);\n\tstatic int\t\tGetCBitmapHeight(const CBitmap & cbm);\n\tstatic BOOL\t\tGetCBitmap(void\t*pClip2, CDC *pDC, CBitmap *pBitMap, int nMaxHeight);\n\tstatic BOOL\t\tGetCBitmap(CClipFormats&clips, CDC* pDC, CBitmap* pBitMap, BOOL horizontal);\n\tstatic HANDLE\thBitmapToDIB(HBITMAP hBitmap, DWORD dwCompression, HPALETTE hPal);\n\tstatic WORD\t\tPaletteSize(LPSTR lpDIB);\n\tstatic WORD\t\tDIBNumColors(LPSTR lpDIB);\n\tstatic bool\t\tDrawDIB(CDC *pDC, HANDLE hData, int nLeft, int nRight, int &nWidth);\n\n};\n\n#endif // !defined(AFX_BITMAPHELPER_H__641D941B_5487_4F85_BFC1_012F2083A8B6__INCLUDED_)\n"
        },
        {
          "name": "CF_HDropAggregator.cpp",
          "type": "blob",
          "size": 0.7294921875,
          "content": "#include \"stdafx.h\"\n#include \".\\cf_hdropaggregator.h\"\n\nCCF_HDropAggregator::CCF_HDropAggregator(void)\n{\n}\n\nCCF_HDropAggregator::~CCF_HDropAggregator(void)\n{\n}\n\nbool CCF_HDropAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tHDROP drop = (HDROP)GlobalLock((HDROP)lpData);\n\tint nNumFiles = DragQueryFile(drop, -1, NULL, 0);\n\tTCHAR file[MAX_PATH];\n\n\tfor(int nFile = 0; nFile < nNumFiles; nFile++)\n\t{\n\t\tif(DragQueryFile(drop, nFile, file, sizeof(file)) > 0)\n\t\t{\n\t\t\tm_DropFiles.AddFile(file);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nHGLOBAL CCF_HDropAggregator::GetHGlobal()\n{\n\treturn m_DropFiles.CreateCF_HDROPBuffer();\n}\n\nHGLOBAL CCF_HDropAggregator::GetHGlobalAsString()\n{\n\treturn m_DropFiles.CreateCF_HDROPBufferAsString();\n}"
        },
        {
          "name": "CF_HDropAggregator.h",
          "type": "blob",
          "size": 0.3779296875,
          "content": "#pragma once\n#include \"IClipAggregator.h\"\n#include \"FileRecieve.h\"\n\nclass CCF_HDropAggregator : public IClipAggregator\n{\npublic:\n\tCCF_HDropAggregator(void);\n\t~CCF_HDropAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\tvirtual HGLOBAL GetHGlobalAsString();\n\nprotected:\n\tCFileRecieve m_DropFiles;\n};\n"
        },
        {
          "name": "CF_TextAggregator.cpp",
          "type": "blob",
          "size": 1.4521484375,
          "content": "#include \"stdafx.h\"\n#include \".\\cf_textaggregator.h\"\n#include \"Misc.h\"\n\nCCF_TextAggregator::CCF_TextAggregator(CStringA csSepator) :\n\tm_csSeparator(csSepator)\n{\n}\n\nCCF_TextAggregator::~CCF_TextAggregator(void)\n{\n}\n\nbool CCF_TextAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tif (cfType == CF_HDROP)\n\t{\n\t\tCStringA hDropFiles = _T(\"\");\n\t\tHDROP drop = (HDROP)GlobalLock((HDROP)lpData);\n\t\tint nNumFiles = DragQueryFileA(drop, -1, NULL, 0);\n\t\tCHAR file[MAX_PATH];\n\n\t\tfor (int nFile = 0; nFile < nNumFiles; nFile++)\n\t\t{\n\t\t\tif (DragQueryFileA(drop, nFile, file, sizeof(file)) > 0)\n\t\t\t{\n\t\t\t\thDropFiles += file;\n\t\t\t\thDropFiles += \"\\r\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (hDropFiles != _T(\"\"))\n\t\t{\n\t\t\tm_csNewText += hDropFiles;\n\n\t\t\tif (nPos != nCount - 1)\n\t\t\t{\n\t\t\t\tm_csNewText += m_csSeparator;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tLPCSTR pText = (LPCSTR)lpData;\n\tif(pText == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\t//Ensure it's null terminated\n\tif(pText[nDataSize-1] != '\\0')\n\t{\n\t\tint len = 0;\n\t\tfor(len = 0; len < nDataSize && pText[len] != '\\0'; len++ )\n\t\t{\n\t\t}\n\t\t// if it is not null terminated, skip this item\n\t\tif(len >= nDataSize)\n\t\t\treturn false;\n\t}\n\n\tm_csNewText += pText;\n\t\n\tif(nPos != nCount-1)\n\t{\n\t\tm_csNewText += m_csSeparator;\n\t}\n\n\treturn true;\n}\n\nHGLOBAL CCF_TextAggregator::GetHGlobal()\n{\n\tlong lLen = m_csNewText.GetLength();\n\tHGLOBAL hGlobal = NewGlobalP(m_csNewText.GetBuffer(lLen), lLen+sizeof(char));\n\tm_csNewText.ReleaseBuffer();\n\n\treturn hGlobal;\n}\n"
        },
        {
          "name": "CF_TextAggregator.h",
          "type": "blob",
          "size": 0.3466796875,
          "content": "#pragma once\n#include \"IClipAggregator.h\"\n\nclass CCF_TextAggregator : public IClipAggregator\n{\npublic:\n\tCCF_TextAggregator(CStringA csSepator);\n\t~CCF_TextAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\nprotected:\n\tCStringA m_csSeparator;\n\tCStringA m_csNewText;\n};\n"
        },
        {
          "name": "CF_UnicodeTextAggregator.cpp",
          "type": "blob",
          "size": 1.5712890625,
          "content": "#include \"stdafx.h\"\n#include \".\\cf_unicodetextaggregator.h\"\n#include \"Misc.h\"\n\nCCF_UnicodeTextAggregator::CCF_UnicodeTextAggregator(CStringW csSeparator) :\n\tm_csSeparator(csSeparator)\n{\n}\n\nCCF_UnicodeTextAggregator::~CCF_UnicodeTextAggregator(void)\n{\n}\n\nbool CCF_UnicodeTextAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tif (cfType == CF_HDROP)\n\t{\n\t\tCString hDropFiles = _T(\"\");\n\t\tHDROP drop = (HDROP)GlobalLock((HDROP)lpData);\n\t\tint nNumFiles = DragQueryFile(drop, -1, NULL, 0);\n\t\tTCHAR file[MAX_PATH];\n\n\t\tfor (int nFile = 0; nFile < nNumFiles; nFile++)\n\t\t{\n\t\t\tif (DragQueryFile(drop, nFile, file, sizeof(file)) > 0)\n\t\t\t{\n\t\t\t\thDropFiles += file;\n\t\t\t\thDropFiles += _T(\"\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (hDropFiles != _T(\"\"))\n\t\t{\n\t\t\tm_csNewText += hDropFiles;\n\n\t\t\tif (nPos != nCount - 1)\n\t\t\t{\n\t\t\t\tm_csNewText += m_csSeparator;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tLPCWSTR pText = (LPCWSTR)lpData;\n\tif(pText == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tint stringLen = nDataSize/sizeof(wchar_t);\n\n\t//Ensure it's null terminated\n\tif(pText[stringLen-1] != '\\0')\n\t{\n\t\tint len = 0;\n\t\tfor(len = 0; len < stringLen && pText[len] != '\\0'; len++ )\n\t\t{\n\t\t}\n\t\t// if it is not null terminated, skip this item\n\t\tif(len >= stringLen)\n\t\t\treturn false;\n\t}\n\n\tm_csNewText += pText;\n\t\n\tif(nPos != nCount-1)\n\t{\n\t\tm_csNewText += m_csSeparator;\n\t}\n\n\treturn true;\n}\n\nHGLOBAL CCF_UnicodeTextAggregator::GetHGlobal()\n{\n\tlong lLen = m_csNewText.GetLength() * sizeof(wchar_t);\n\tHGLOBAL hGlobal = NewGlobalP(m_csNewText.GetBuffer(lLen), lLen+sizeof(wchar_t));\n\tm_csNewText.ReleaseBuffer();\n\n\treturn hGlobal;\n}"
        },
        {
          "name": "CF_UnicodeTextAggregator.h",
          "type": "blob",
          "size": 0.369140625,
          "content": "#pragma once\n#include \"IClipAggregator.h\"\n\nclass CCF_UnicodeTextAggregator : public IClipAggregator\n{\npublic:\n\tCCF_UnicodeTextAggregator(CStringW csSeparator);\n\t~CCF_UnicodeTextAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\nprotected:\n\tCStringW m_csSeparator;\n\tCStringW m_csNewText;\n};\n"
        },
        {
          "name": "CGdiPlusBitmap.h",
          "type": "blob",
          "size": 4.0244140625,
          "content": "#pragma once\n\nclass CGdiPlusBitmap\n{\npublic:\n\tGdiplus::Bitmap* m_pBitmap;\n\npublic:\n\tCGdiPlusBitmap()\t\t\t\t\t\t\t{ m_pBitmap = NULL; }\n\tCGdiPlusBitmap(LPCWSTR pFile)\t\t\t\t{ m_pBitmap = NULL; Load(pFile); }\n\tvirtual ~CGdiPlusBitmap()\t\t\t\t\t{ Empty(); }\n\n\tvoid Empty()\t\t\t\t\t\t\t\t{ delete m_pBitmap; m_pBitmap = NULL; }\n\n\tbool Load(LPCWSTR pFile)\n\t{\n\t\tEmpty();\n\t\tm_pBitmap = Gdiplus::Bitmap::FromFile(pFile);\n\t\treturn m_pBitmap->GetLastStatus() == Gdiplus::Ok;\n\t}\n\n\tbool Loads(LPCWSTR pFile)\n\t{\n\t\tEmpty();\n\t\tm_pBitmap = Gdiplus::Bitmap::FromFile(pFile);\n\t\treturn m_pBitmap->GetLastStatus() == Gdiplus::Ok;\n\t}\n\n\toperator Gdiplus::Bitmap*() const\t\t\t{ return m_pBitmap; }\n};\n\n\nclass CGdiPlusBitmapResource : public CGdiPlusBitmap\n{\nprotected:\n\tHGLOBAL m_hBuffer;\n\npublic:\n\tCGdiPlusBitmapResource()\t\t\t\t\t{ m_hBuffer = NULL; }\n\tCGdiPlusBitmapResource(LPCTSTR pName, LPCTSTR pType = RT_RCDATA, HMODULE hInst = NULL)\n\t\t\t\t\t\t\t\t\t\t\t\t{ m_hBuffer = NULL; Load(pName, pType, hInst); }\n\tCGdiPlusBitmapResource(UINT id, LPCTSTR pType = RT_RCDATA, HMODULE hInst = NULL)\n\t\t\t\t\t\t\t\t\t\t\t\t{ m_hBuffer = NULL; Load(id, pType, hInst); }\n\tCGdiPlusBitmapResource(UINT id, UINT type, HMODULE hInst = NULL)\n\t\t\t\t\t\t\t\t\t\t\t\t{ m_hBuffer = NULL; Load(id, type, hInst); }\n\tvirtual ~CGdiPlusBitmapResource()\t\t\t{ Empty(); }\n\n\tvoid Empty();\n\n\tbool Load(LPCTSTR pName, LPCTSTR pType = RT_RCDATA, HMODULE hInst = NULL);\n\tbool Load(UINT id, LPCTSTR pType = RT_RCDATA, HMODULE hInst = NULL)\n\t\t\t\t\t\t\t\t\t\t\t\t{ return Load(MAKEINTRESOURCE(id), pType, hInst); }\n\tbool Load(UINT id, UINT type, HMODULE hInst = NULL)\n\t\t\t\t\t\t\t\t\t\t\t\t{ return Load(MAKEINTRESOURCE(id), MAKEINTRESOURCE(type), hInst); }\n\n\tbool LoadRaw(unsigned char* bitmapData, int imageSize) \n\t{\n\t\t/*bool ret = false;\n\n\t\tCString path;\n\t\twchar_t wchPath[MAX_PATH];\n\t\tif (GetTempPathW(MAX_PATH, wchPath))\n\t\t{\n\t\tpath = wchPath;\n\t\tpath += \"qrcode.bmp\";\n\t\t}\n\n\t\tFILE* f = _wfopen(path.GetBuffer(MAX_PATH), _T(\"wb\"));\n\t\tif (f != NULL)\n\t\t{\n\t\tfwrite(bitmapData, imageSize, 1, f);\n\n\t\tfclose(f);\n\t\t}\n\n\t\tm_pBitmap = Gdiplus::Bitmap::FromFile(path);\n\t\tif (m_pBitmap)\n\t\t{ \n\t\tStatus s = m_pBitmap->GetLastStatus();\n\t\tif (m_pBitmap->GetLastStatus() != Gdiplus::Ok)\n\t\t{\n\t\tdelete m_pBitmap;\n\t\tm_pBitmap = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\tret = true;\n\t\t}\n\t\t}\n\n\t\t::DeleteFile(path);*/\n\n\t\tEmpty();\n\n\t\tm_hBuffer  = ::GlobalAlloc(GMEM_MOVEABLE, imageSize);\n\t\tif (m_hBuffer)\n\t\t{\n\t\t\tvoid* pBuffer = ::GlobalLock(m_hBuffer);\n\t\t\tif (pBuffer)\n\t\t\t{\n\t\t\t\tCopyMemory(pBuffer, bitmapData, imageSize);\n\n\t\t\t\tIStream* pStream = NULL;\n\t\t\t\tif (::CreateStreamOnHGlobal(m_hBuffer, FALSE, &pStream) == S_OK)\n\t\t\t\t{\n\t\t\t\t\tm_pBitmap = Gdiplus::Bitmap:: FromStream(pStream);\n\t\t\t\t\tpStream->Release();\n\t\t\t\t\tif (m_pBitmap)\n\t\t\t\t\t{ \n\t\t\t\t\t\tif (m_pBitmap->GetLastStatus() == Gdiplus::Ok)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\tdelete m_pBitmap;\n\t\t\t\t\t\tm_pBitmap = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t::GlobalUnlock(m_hBuffer);\n\t\t\t}\n\t\t\t::GlobalFree(m_hBuffer);\n\t\t\tm_hBuffer = NULL;\n\t\t}\n\t\treturn false;\n\n\t\t//return ret;\n\t}\n};\n\ninline\nvoid CGdiPlusBitmapResource::Empty()\n{\n\tCGdiPlusBitmap::Empty();\n\tif (m_hBuffer)\n\t{\n\t\t::GlobalUnlock(m_hBuffer);\n\t\t::GlobalFree(m_hBuffer);\n\t\tm_hBuffer = NULL;\n\t} \n}\n\ninline\nbool CGdiPlusBitmapResource::Load(LPCTSTR pName, LPCTSTR pType, HMODULE hInst)\n{\n\tEmpty();\n\n\tHRSRC hResource = ::FindResource(hInst, pName, pType);\n\tif (!hResource)\n\t\treturn false;\n\t\n\tDWORD imageSize = ::SizeofResource(hInst, hResource);\n\tif (!imageSize)\n\t\treturn false;\n\n\tconst void* pResourceData = ::LockResource(::LoadResource(hInst, hResource));\n\tif (!pResourceData)\n\t\treturn false;\n\n\tm_hBuffer  = ::GlobalAlloc(GMEM_MOVEABLE, imageSize);\n\tif (m_hBuffer)\n\t{\n\t\tvoid* pBuffer = ::GlobalLock(m_hBuffer);\n\t\tif (pBuffer)\n\t\t{\n\t\t\tCopyMemory(pBuffer, pResourceData, imageSize);\n\n\t\t\tIStream* pStream = NULL;\n\t\t\tif (::CreateStreamOnHGlobal(m_hBuffer, FALSE, &pStream) == S_OK)\n\t\t\t{\n\t\t\t\tm_pBitmap = Gdiplus::Bitmap:: FromStream(pStream);\n\t\t\t\tpStream->Release();\n\t\t\t\tif (m_pBitmap)\n\t\t\t\t{ \n\t\t\t\t\tif (m_pBitmap->GetLastStatus() == Gdiplus::Ok)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tdelete m_pBitmap;\n\t\t\t\t\tm_pBitmap = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t::GlobalUnlock(m_hBuffer);\n\t\t}\n\t\t::GlobalFree(m_hBuffer);\n\t\tm_hBuffer = NULL;\n\t}\n\treturn false;\n}\n\n"
        },
        {
          "name": "CP_Main.cpp",
          "type": "blob",
          "size": 32.4736328125,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"MainFrm.h\"\r\n#include \"Misc.h\"\r\n#include \".\\cp_main.h\"\r\n#include \"server.h\"\r\n#include \"Client.h\"\r\n#include <io.h>\r\n#include \"Path.h\"\r\n#include \"Clip_ImportExport.h\"\r\n#include \"HyperLink.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"DittoCopyBuffer.h\"\r\n#include \"SendKeys.h\"\r\n#include \"MainTableFunctions.h\"\r\n#include \"ShowTaskBarIcon.h\"\r\n#include \"NoDbFrameWnd.h\"\r\n#include <clocale>\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\nclass DittoCommandLineInfo : public CCommandLineInfo\r\n{\r\npublic:\r\n\tDittoCommandLineInfo()\r\n\t{\r\n\t\tm_bDisconnect = FALSE;\r\n\t\tm_bConnect = FALSE;\r\n\t\tm_uacPID = 0;\r\n\t\tm_bOpenWindow = FALSE;\r\n\t\tm_bCloseWindow = FALSE;\r\n\t\tm_exit = FALSE;\r\n\t\tm_plainTextPaste = FALSE;\r\n\t\tm_pasteClip = FALSE;\r\n\t\tm_clipID = -1;\r\n\t\tm_editClip = FALSE;\r\n\t\tm_restartFromRestartManager = FALSE;\r\n\t}\r\n\r\n \tvirtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast)\r\n \t{\r\n  \t\tif(bFlag)\r\n  \t\t{\r\n  \t\t\tif(STRICMP(pszParam, _T(\"Connect\")) == 0)\r\n  \t\t\t{\r\n  \t\t\t\tm_bConnect = TRUE;\r\n  \t\t\t}\r\n  \t\t\telse if(STRICMP(pszParam, _T(\"Disconnect\")) == 0)\r\n  \t\t\t{\r\n  \t\t\t\tm_bDisconnect = TRUE;\r\n  \t\t\t}\r\n\t\t\telse if(wcsncmp(pszParam, _T(\"uacpaste\"), 8) == 0)\r\n\t\t\t{\r\n\t\t\t\tCString pidCommand(pszParam);\r\n\t\t\t\tlong sep = pidCommand.ReverseFind(':');\r\n\t\t\t\tif(sep > -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString pid = pidCommand.Right(pidCommand.GetLength() - sep - 1);\r\n\t\t\t\t\tm_uacPID = ATOI(pid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if(STRICMP(pszParam, _T(\"open\")) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_bOpenWindow = TRUE;\r\n\t\t\t}\r\n\t\t\telse if(STRICMP(pszParam, _T(\"close\")) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_bCloseWindow = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (STRICMP(pszParam, _T(\"exit\")) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_exit = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (STRICMP(pszParam, _T(\"PlainTextPaste\")) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_plainTextPaste = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (_wcsnicmp(pszParam, _T(\"paste\"), 5) == 0)\r\n\t\t\t{\r\n\t\t\t\tCString pidCommand(pszParam);\r\n\t\t\t\tlong sep = pidCommand.ReverseFind(':');\r\n\t\t\t\tif (sep > -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString id = pidCommand.Right(pidCommand.GetLength() - sep - 1);\r\n\t\t\t\t\tm_clipID = ATOI(id);\r\n\t\t\t\t\tm_pasteClip = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (_wcsnicmp(pszParam, _T(\"edit\"), 4) == 0)\r\n\t\t\t{\r\n\t\t\t\tCString pidCommand(pszParam);\r\n\t\t\t\tlong sep = pidCommand.ReverseFind(':');\r\n\t\t\t\tif (sep > -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString id = pidCommand.Right(pidCommand.GetLength() - sep - 1);\r\n\t\t\t\t\tm_clipID = ATOI(id);\r\n\t\t\t\t\tm_editClip = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (_wcsnicmp(pszParam, _T(\"RestartByRestartManager\"), 23) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_restartFromRestartManager = true;\r\n\t\t\t}\r\n  \t\t}\r\n \r\n\t\tCCommandLineInfo::ParseParam(pszParam, bFlag, bLast);\r\n \t}\r\n\r\n\tBOOL m_bDisconnect;\r\n\tBOOL m_bConnect;\r\n\tBOOL m_pasteClip;\r\n\tint m_uacPID;\r\n\tint m_clipID;\r\n\tBOOL m_bCloseWindow;\r\n\tBOOL m_exit;\r\n\tBOOL m_bOpenWindow;\r\n\tBOOL m_plainTextPaste;\r\n\tBOOL m_editClip;\r\n\tBOOL m_restartFromRestartManager;\r\n};\r\n\r\nCCP_MainApp theApp;\r\n\r\nBEGIN_MESSAGE_MAP(CCP_MainApp, CWinApp)\r\n\t//{{AFX_MSG_MAP(CCP_MainApp)\r\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\r\n\t\t//    DO NOT EDIT what you see in these blocks of generated code!\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\nCCP_MainApp::CCP_MainApp()\r\n{\r\n\tm_copyReason = CopyReasonEnum::COPY_TO_UNKOWN;\r\n\tm_copyReasonStartTime = 0;\r\n\tm_activeGroupId = -1;\r\n\tm_activeGroupStartTime = 0;\r\n\tm_pUacPasteThread = NULL;\r\n\tm_bAppRunning = false;\r\n\tm_bAppExiting = false;\r\n\tm_connectOnStartup = -1;\r\n\tm_MainhWnd = NULL;\r\n\tm_pMainFrame = NULL;\r\n\tBOOL set = ::AllowSetForegroundWindow(ASFW_ANY);\r\n\r\n\tm_bShowingQuickPaste = false;\r\n\r\n\tm_GroupDefaultID = 0;\r\n\tm_GroupID = -1;\r\n\tm_GroupParentID = 0;\r\n\tm_GroupText = \"History\";\r\n\tm_FocusID = -1;\r\n\r\n\tClearOldGroupState();\r\n\r\n\tm_bAsynchronousRefreshView = true;\r\n\tm_lClipsSent = 0;\r\n\tm_lClipsRecieved = 0;\r\n\tm_oldtStartUp = COleDateTime::GetCurrentTime();\r\n\r\n\tm_bExitServerThread = false;\r\n\r\n\tm_lLastGoodIndexForNextworkPassword = -2;\r\n\r\n\tm_RTFFormat = ::RegisterClipboardFormat(_T(\"Rich Text Format\"));\r\n\tm_HTML_Format = ::RegisterClipboardFormat(_T(\"HTML Format\"));\r\n\tm_PingFormat = ::RegisterClipboardFormat(_T(\"Ditto Ping Format\"));\r\n\tm_cfIgnoreClipboard = ::RegisterClipboardFormat(_T(\"Clipboard Viewer Ignore\"));\r\n\tm_cfDelaySavingData = ::RegisterClipboardFormat(_T(\"Ditto Delay Saving Data\"));\r\n\tm_RemoteCF_HDROP = ::RegisterClipboardFormat(_T(\"Ditto Remote CF_HDROP\"));\r\n\tm_DittoFileData = ::RegisterClipboardFormat(_T(\"Ditto File Data\"));\r\n\tm_PNG_Format = GetFormatID(_T(\"PNG\"));\r\n\r\n\tm_pNoDbMainFrame = NULL;\r\n\tm_databaseOnNetworkShare = false;\r\n\r\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;\r\n}\r\n\r\nCCP_MainApp::~CCP_MainApp()\r\n{\r\n\t\r\n}\r\n\r\nBOOL CCP_MainApp::InitInstance()\r\n{\t\r\n\tINITCOMMONCONTROLSEX InitCtrls;\r\n\tInitCtrls.dwSize = sizeof(InitCtrls);\r\n\t// Set this to include all the common control classes you want to use\r\n\t// in your application.\r\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\r\n\tInitCommonControlsEx(&InitCtrls);\r\n\r\n\tAfxEnableControlContainer();\r\n\tAfxOleInit();\r\n\tAfxInitRichEditEx();\t\r\n\r\n\tGdiplus::GdiplusStartupInput gdiplusStartupInput;\r\n\tGdiplus::GdiplusStartup(&m_gdiplusToken, &gdiplusStartupInput, NULL);\r\n\r\n\tLoadLibrary(TEXT(\"MSFTEDIT.DLL\"));\r\n\r\n\tsetlocale(LC_TIME, \".OCP\"); // defines the date/time formatting\r\n\r\n\t//MessageBox(NULL, _T(\"ditto starting\"), _T(\"d\"), MB_OK);\r\n\r\n\tDittoCommandLineInfo cmdInfo;\r\n\tParseCommandLine(cmdInfo);\r\n\r\n\tCGetSetOptions::LoadSettings();\r\n\r\n\ttheApp.m_activeWnd.TrackActiveWnd(false);\r\n\r\n\tif(cmdInfo.m_uacPID > 0)\r\n\t{\r\n\t\tLog(StrF(_T(\"Startup up ditto as admin to paste to admin windows, parent process id: %d\"), cmdInfo.m_uacPID));\r\n\r\n\t\tCString mutex;\r\n\t\tmutex.Format(_T(\"DittoAdminPaste_%d\"), cmdInfo.m_uacPID);\r\n\t\tm_adminPasteMutex = CreateMutex(NULL, FALSE, mutex);\r\n\r\n\t\tm_pUacPasteThread = new CUAC_Thread(cmdInfo.m_uacPID);\r\n\t\tm_pUacPasteThread->Start();\r\n\t\tm_pUacPasteThread->WaitForThreadToExit(INT_MAX);\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (cmdInfo.m_restartFromRestartManager)\r\n\t{\r\n\t\tLog(StrF(_T(\"Ditto was restarted from restart manager\")));\r\n\t}\r\n\telse if(cmdInfo.m_strFileName.IsEmpty() == FALSE)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tCGetSetOptions::m_bEnableDebugLogging = CGetSetOptions::GetEnableDebugLogging();\r\n\r\n\t\t\tCClip_ImportExport Clip;\r\n\t\t\tCppSQLite3DB db;\r\n\t\t\tdb.open(cmdInfo.m_strFileName);\r\n\r\n\t\t\tCClip_ImportExport clip;\r\n\t\t\tif(clip.ImportFromSqliteDB(db, false, true))\r\n\t\t\t{\r\n\t\t\t\tShowCommandLineError(\"Ditto\", theApp.m_Language.GetString(\"Importing_Good\", \"Clip placed on clipboard\"));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tShowCommandLineError(\"Ditto\", theApp.m_Language.GetString(\"Error_Importing\", \"Error importing exported clip\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tASSERT(FALSE);\r\n\r\n\t\t\tCString csError;\r\n\t\t\tcsError.Format(_T(\"%s - Exception - %d - %s\"), theApp.m_Language.GetString(\"Error_Parsing\", \"Error parsing exported clip\"), e.errorCode(), e.errorMessage());\r\n\t\t\tShowCommandLineError(\"Ditto\", csError);\r\n\t\t}\t\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if(cmdInfo.m_bConnect || cmdInfo.m_bDisconnect)\r\n\t{\r\n\t\t//First get the saved hwnd and send it a message\r\n\t\t//If ditto is running then this will return 1, meaning the running ditto process\r\n\t\t//handled this message\r\n\t\t//If it didn't handle the message(ditto is not running) then startup this processes of ditto \r\n\t\t//disconnected from the clipboard\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif(hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_SET_CONNECTED, cmdInfo.m_bConnect, cmdInfo.m_bDisconnect);\r\n\t\t}\r\n\r\n\t\t//passed off to the running instance of ditto, exit this instance\r\n\t\tif(ret == 1)\r\n\t\t{\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\t\r\n\t\tif(cmdInfo.m_bConnect)\r\n\t\t{\r\n\t\t\tm_connectOnStartup = TRUE;\r\n\t\t}\r\n\t\telse if(cmdInfo.m_bDisconnect)\r\n\t\t{\r\n\t\t\tm_connectOnStartup = FALSE;\r\n\t\t}\r\n\t}\r\n\telse if(cmdInfo.m_bOpenWindow || cmdInfo.m_bCloseWindow)\r\n\t{\r\n\t\t//First get the saved hwnd and send it a message\r\n\t\t//If ditto is running then this will return 1, meaning the running ditto process\r\n\t\t//handled this message\r\n\t\t//If it didn't handle the message(ditto is not running) then startup this processes of ditto \r\n\t\t//disconnected from the clipboard\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif(hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_OPEN_CLOSE_WINDOW, cmdInfo.m_bOpenWindow, cmdInfo.m_bCloseWindow);\r\n\t\t}\r\n\r\n\t\treturn FALSE;\t\t\r\n\t}\r\n\telse if (cmdInfo.m_exit)\r\n\t{\r\n\t\t//First get the saved hwnd and send it a message\r\n\t\t//If ditto is running then this will return 1, meaning the running ditto process\r\n\t\t//handled this message\r\n\t\t//If it didn't handle the message(ditto is not running) then startup this processes of ditto \r\n\t\t//disconnected from the clipboard\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif (hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_CLOSE, NULL, NULL);\r\n\t\t}\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if (cmdInfo.m_plainTextPaste)\r\n\t{\t\t\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif (hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_PLAIN_TEXT_PASTE, NULL, NULL);\r\n\t\t}\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if (cmdInfo.m_pasteClip)\r\n\t{\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif (hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_PASTE_CLIP, cmdInfo.m_clipID, NULL);\r\n\t\t}\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n\telse if (cmdInfo.m_editClip)\r\n\t{\r\n\t\tLRESULT ret = 0;\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif (hWnd)\r\n\t\t{\r\n\t\t\tret = ::SendMessage(hWnd, WM_EDIT_CLIP, cmdInfo.m_clipID, NULL);\r\n\t\t}\r\n\r\n\t\treturn FALSE;\r\n\t}\t\t\r\n\r\n\tauto runningVersion = GetRunningVersion();\r\n\tCString cs = GetVersionString(runningVersion);\r\n\tcs.Insert(0, _T(\"InitInstance  -  Running Version - \"));\r\n\tLog(cs);\r\n\r\n\tCString csMutex(\"Ditto Is Now Running\");\r\n\tif(CGetSetOptions::GetIsPortableDitto() || CGetSetOptions::GetIsWindowsApp() || CGetSetOptions::GetIsChocolateyApp())\r\n\t{\r\n\t\tcsMutex += \" \";\r\n\t\tcsMutex += CGetSetOptions::GetExeFileName();\r\n\t}\r\n\r\n\tCWinApp::RegisterWithRestartManager(false, csMutex);\r\n\r\n\t//create mutex doesn't like slashes, remove them, it always returns NULL with them in\r\n\tcsMutex.Replace(_T(\"\\\\\"), _T(\"_\"));\r\n\r\n\tm_hMutex = CreateMutex(NULL, TRUE, csMutex);\r\n\tDWORD dwError = GetLastError();\r\n\tif(m_hMutex == NULL ||\r\n\t\tdwError == ERROR_ALREADY_EXISTS)\r\n\t{\r\n\t\tLog(StrF(_T(\"Ditto is already running, closing, mutex: %s\"), csMutex));\r\n\t\tHWND hWnd = (HWND)(LONG_PTR)CGetSetOptions::GetMainHWND();\r\n\t\tif(hWnd)\r\n\t\t\t::SendMessage(hWnd, WM_SHOW_TRAY_ICON, TRUE, TRUE);\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tLog(StrF(_T(\"Starting up ditto with mutex: %s\"), csMutex));\r\n\r\n\tCString csFile = CGetSetOptions::GetLanguageFile();\r\n\tif(m_Language.LoadLanguageFile(csFile) == false)\r\n\t{\r\n\t\tCString cs;\r\n\t\tcs.Format(_T(\"Error loading language file - %s - \\n\\n%s\"), csFile, m_Language.m_csLastError);\r\n\t\tLog(cs);\r\n\r\n\t\tm_Language.LoadLanguageFile(_T(\"English.xml\"));\r\n\t}\r\n\r\n\tm_icuString.Load();\r\n\t\r\n\tint nRet = CheckDBExists(CGetSetOptions::GetDBPath());\r\n\tif(nRet == FALSE)\r\n\t{\r\n\t\tm_pNoDbMainFrame = new CNoDbFrameWnd();\r\n\t\tm_pMainWnd = m_pNoDbMainFrame;\r\n\t\t\t\t\r\n\t\tm_pNoDbMainFrame->LoadFrame(IDR_MAINFRAME, WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL, NULL);\r\n\t\tm_pNoDbMainFrame->ShowWindow(SW_SHOW);\r\n\t\tm_pNoDbMainFrame->UpdateWindow();\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//Sleep(1000);\r\n\t\tCreateMainWnd();\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CCP_MainApp::CreateMainWnd()\r\n{\r\n\tCMainFrame* pFrame = new CMainFrame;\r\n\tm_pMainWnd = m_pMainFrame = pFrame;\r\n\r\n\tpFrame->LoadFrame(IDR_MAINFRAME, WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL, NULL);\r\n\r\n\t//removed to keep ditto from taking focus on startup\r\n\t//pFrame->ShowWindow(SW_SHOW);\r\n\t//pFrame->UpdateWindow();\r\n\r\n}\r\n\r\nvoid CCP_MainApp::CloseNoDbWindow()\r\n{\r\n\tif (m_pNoDbMainFrame != NULL)\r\n\t{\r\n\t\tm_pNoDbMainFrame->CloseWindow();\r\n\t\tdelete m_pNoDbMainFrame;\r\n\t\tm_pNoDbMainFrame = NULL;\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::AfterMainCreate()\r\n{\r\n\tm_MainhWnd = m_pMainFrame->m_hWnd;\r\n\tASSERT( ::IsWindow(m_MainhWnd) );\r\n\tCGetSetOptions::SetMainHWND((long)(LONG_PTR)m_MainhWnd);\r\n\r\n\tg_HotKeys.Init(m_MainhWnd);\r\n\r\n\t// create hotkeys here.  They are automatically deleted on exit\r\n\tm_pDittoHotKey = new CHotKey(CString(\"DittoHotKey\"), 704); //704 is ctrl-tilda\r\n\tm_pDittoHotKey2 = new CHotKey(CString(\"DittoHotKey2\"));\r\n\tm_pDittoHotKey3 = new CHotKey(CString(\"DittoHotKey3\"));\r\n\r\n\tm_pPosOne = new CHotKey(\"Position1\", 0, true);\r\n\tm_pPosTwo = new CHotKey(\"Position2\", 0, true);\r\n\tm_pPosThree = new CHotKey(\"Position3\", 0, true);\r\n\tm_pPosFour = new CHotKey(\"Position4\", 0, true);\r\n\tm_pPosFive = new CHotKey(\"Position5\", 0, true);\r\n\tm_pPosSix = new CHotKey(\"Position6\", 0, true);\r\n\tm_pPosSeven = new CHotKey(\"Position7\", 0, true);\r\n\tm_pPosEight = new CHotKey(\"Position8\", 0, true);\r\n\tm_pPosNine = new CHotKey(\"Position9\", 0, true);\r\n\tm_pPosTen = new CHotKey(\"Position10\", 0, true);\r\n\r\n\tm_pCopyBuffer1 = new CHotKey(\"CopyBufferCopyHotKey_0\", 0, true);\r\n\tm_pPasteBuffer1 = new CHotKey(\"CopyBufferPasteHotKey_0\", 0, true);\r\n\tm_pCutBuffer1 = new CHotKey(\"CopyBufferCutHotKey_0\", 0, true);\r\n\t\r\n\tm_pCopyBuffer2 = new CHotKey(\"CopyBufferCopyHotKey_1\", 0, true);\r\n\tm_pPasteBuffer2 = new CHotKey(\"CopyBufferPasteHotKey_1\", 0, true);\r\n\tm_pCutBuffer2 = new CHotKey(\"CopyBufferCutHotKey_1\", 0, true);\r\n\r\n\tm_pCopyBuffer3 = new CHotKey(\"CopyBufferCopyHotKey_2\", 0, true);\r\n\tm_pPasteBuffer3 = new CHotKey(\"CopyBufferPasteHotKey_2\", 0, true);\r\n\tm_pCutBuffer3 = new CHotKey(\"CopyBufferCutHotKey_2\", 0, true);\r\n\r\n\tm_pCopyBuffer4 = new CHotKey(\"CopyBufferCopyHotKey_3\", 0, true);\r\n\tm_pPasteBuffer4 = new CHotKey(\"CopyBufferPasteHotKey_3\", 0, true);\r\n\tm_pCutBuffer4 = new CHotKey(\"CopyBufferCutHotKey_3\", 0, true);\r\n\r\n\tm_pCopyBuffer5 = new CHotKey(\"CopyBufferCopyHotKey_4\", 0, true);\r\n\tm_pPasteBuffer5 = new CHotKey(\"CopyBufferPasteHotKey_4\", 0, true);\r\n\tm_pCutBuffer5 = new CHotKey(\"CopyBufferCutHotKey_4\", 0, true);\r\n\r\n\tm_pTextOnlyPaste = new CHotKey(\"TextOnlyPaste\", 0, true);\r\n\r\n\tm_pSaveClipboard = new CHotKey(\"SaveClipboard\", 0, false);\r\n\r\n\tm_pCopyAndSaveClipboard = new CHotKey(\"CopyAndSaveClipboard\", 0, false);\t\r\n\r\n\tm_editThread.StartWatchingFolderForChanges();\r\n\r\n\tLoadGlobalClips();\r\n\r\n\tg_HotKeys.RegisterAll();\r\n\tStartCopyThread();\r\n\tStartStopServerThread();\r\n\r\n#ifdef UNICODE\r\n\tm_Addins.LoadAll();\r\n#endif\r\n\t\r\n\tm_bAppRunning = true;\r\n}\r\n\r\nvoid CCP_MainApp::LoadGlobalClips()\r\n{\r\n\ttry\r\n\t{\r\n\t\t{\r\n\t\t\tCppSQLite3Query q = m_db.execQuery(_T(\"SELECT lID, lShortCut, mText FROM Main WHERE lShortCut > 0 AND globalShortCut = 1\"));\r\n\r\n\t\t\twhile(q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tint id = q.getIntField(_T(\"lID\"));\r\n\t\t\t\tint shortcut = q.getIntField(_T(\"lShortCut\"));\r\n\t\t\t\tCString desc = q.getStringField(_T(\"mText\"));\r\n\r\n\t\t\t\t//Constructor will add to a global list and free\r\n\t\t\t\tCHotKey* globalHotKey = new CHotKey(StrF(_T(\"GlobalClip: %d\"), id), shortcut, true, CHotKey::PASTE_OPEN_CLIP, desc);\r\n\t\t\t\tif(globalHotKey != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tglobalHotKey->m_clipId = id;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tq.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tCppSQLite3Query q2 = m_db.execQuery(_T(\"SELECT lID, MoveToGroupShortCut, mText FROM Main WHERE MoveToGroupShortCut > 0 AND GlobalMoveToGroupShortCut = 1\"));\r\n\r\n\t\t\twhile(q2.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tint id = q2.getIntField(_T(\"lID\"));\r\n\t\t\t\tint shortcut = q2.getIntField(_T(\"MoveToGroupShortCut\"));\r\n\t\t\t\tCString desc = q2.getStringField(_T(\"mText\"));\r\n\r\n\t\t\t\t//Constructor will add to a global list and free\r\n\t\t\t\tCHotKey* globalHotKey = new CHotKey(StrF(_T(\"MoveToGroup: %d\"), id), shortcut, true, CHotKey::MOVE_TO_GROUP, desc);\r\n\t\t\t\tif(globalHotKey != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tglobalHotKey->m_clipId = id;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tq2.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nvoid CCP_MainApp::StartStopServerThread()\r\n{\r\n\tif(CGetSetOptions::GetDisableRecieve() == FALSE && CGetSetOptions::GetAllowFriends())\r\n\t{\r\n\t\tAfxBeginThread(MTServerThread, m_MainhWnd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_bExitServerThread = true;\r\n\t\tclosesocket(theApp.m_sSocket);\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::StopServerThread()\r\n{\r\n\tm_bExitServerThread = true;\r\n\tclosesocket(theApp.m_sSocket);\r\n}\r\n\r\nvoid CCP_MainApp::BeforeMainClose()\r\n{\r\n\tASSERT( m_bAppRunning && !m_bAppExiting );\r\n\tm_bAppRunning = false;\r\n\tm_bAppExiting = true;\r\n\tg_HotKeys.UnregisterAll();\r\n\tStopServerThread();\r\n\tStopCopyThread();\r\n}\r\n\r\nvoid CCP_MainApp::StartCopyThread()\r\n{\r\n\tASSERT( m_MainhWnd );\r\n\tCClipTypes* pTypes = LoadTypesFromDB();\r\n\t// initialize to:\r\n\t// - m_MainhWnd = send WM_CLIPBOARD_COPIED messages to m_MainhWnd\r\n\t// - true = use Asynchronous communication (PostMessage)\r\n\t// - true = enable copying on clipboard changes\r\n\t// - pTypes = the supported types to use\r\n\tm_CopyThread.Init(CCopyConfig(m_MainhWnd, true, true, pTypes));\r\n\t\r\n\tif(m_connectOnStartup == FALSE || CGetSetOptions::GetConnectedToClipboard() == FALSE)\r\n\t{\r\n\t\tm_CopyThread.m_connectOnStartup = false;\r\n\t\tLog(StrF(_T(\"Starting Ditto up disconnected from the clipboard, commandLine: %d, saved value: %d\"), m_connectOnStartup, CGetSetOptions::GetConnectedToClipboard()));\r\n\t\tSetConnectCV(false);\r\n\t}\r\n\telse if(m_connectOnStartup == TRUE)\r\n\t{\r\n\t\tSetConnectCV(true);\r\n\t\tLog(_T(\"Starting Ditto up connected from the clipboard, passed in true from command line to start connected\"));\r\n\t}\r\n\r\n\tVERIFY(m_CopyThread.CreateThread(CREATE_SUSPENDED));\r\n\tm_CopyThread.ResumeThread();\r\n}\r\n\r\nvoid CCP_MainApp::StopCopyThread()\r\n{\r\n\tEnableCbCopy(false);\r\n\tm_CopyThread.Quit();\r\n}\r\n\r\n// returns the current Clipboard Viewer Connect state (though it might not yet\r\n//  be actually connected -- check IsClipboardViewerConnected())\r\nbool CCP_MainApp::ToggleConnectCV()\r\n{\r\n\tbool bConnect = !GetConnectCV();\r\n\tSetConnectCV(bConnect);\r\n\treturn bConnect;\r\n}\r\n\r\n// Sets a menu entry according to the current Clipboard Viewer Connection status\r\n// - the menu text indicates the available command (opposite the current state)\r\n// - a check mark appears in the rare cases that the menu text actually represents\r\n//   the current state, e.g. if we are supposed to be connected, but we somehow\r\n//   lose that connection, \"Disconnect from Clipboard\" will have a check next to it.\r\nvoid CCP_MainApp::UpdateMenuConnectCV(CMenu* pMenu, UINT nMenuID)\r\n{\r\n\tif(pMenu == NULL)\r\n\t\treturn;\r\n\r\n\tbool bConnect = theApp.GetConnectCV();\r\n\tCString cs;\r\n\r\n\tif(bConnect)\r\n\t{\r\n\t\tcs = theApp.m_Language.GetString(\"Disconnect_Clipboard\", \"Disconnect from Clipboard.\");\r\n\t\tpMenu->ModifyMenu(nMenuID, MF_BYCOMMAND, nMenuID, cs);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcs = theApp.m_Language.GetString(\"Connect_Clipboard\", \"Connect to Clipboard.\");\r\n\t\tpMenu->ModifyMenu(nMenuID, MF_BYCOMMAND, nMenuID, cs);\r\n\t}\r\n}\r\n\r\n// Allocates a new CClipTypes\r\nCClipTypes* CCP_MainApp::LoadTypesFromDB()\r\n{\r\n\tCClipTypes* pTypes = new CClipTypes;\r\n\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT TypeText FROM Types\"));\t\t\t\r\n\t\twhile(q.eof() == false)\r\n\t\t{\r\n\t\t\tpTypes->Add(GetFormatID(q.getStringField(_T(\"TypeText\"))));\r\n\r\n\t\t\tq.nextRow();\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\tif(pTypes->GetSize() <= 0)\r\n\t{\r\n\t\tpTypes->Add(CF_TEXT);\r\n\t\tpTypes->Add(RegisterClipboardFormat(CF_RTF));\r\n\t\tpTypes->Add(CF_UNICODETEXT);\r\n\t\tpTypes->Add(CF_HDROP);\r\n\t\tpTypes->Add(CF_DIB);\r\n\t\tpTypes->Add(GetFormatID(_T(\"HTML Format\")));\r\n\t\tpTypes->Add(GetFormatID(_T(\"PNG\")));\r\n\t}\r\n\r\n\treturn pTypes;\r\n}\r\n\r\nvoid CCP_MainApp::ReloadTypes()\r\n{\r\n\tCClipTypes* pTypes = LoadTypesFromDB();\r\n\r\n\tif(pTypes)\r\n\t{\r\n\t\tm_CopyThread.SetSupportedTypes(pTypes);\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::RefreshView(CopyReasonEnum::CopyReason copyReason)\r\n{\r\n\tCQPasteWnd *pWnd = QPasteWnd();\r\n\tif(pWnd)\r\n\t{\r\n\t\tif(m_bAsynchronousRefreshView)\r\n\t\t{\r\n\t\t\tpWnd->PostMessage(WM_REFRESH_VIEW, copyReason, 0);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpWnd->SendMessage(WM_REFRESH_VIEW, copyReason, 0);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::RefreshClipInUI(int clipId, int updateFlags)\r\n{\r\n\tCQPasteWnd *pWnd = QPasteWnd();\r\n\tif(pWnd)\r\n\t{\r\n\t\tif(m_bAsynchronousRefreshView)\r\n\t\t{\r\n\t\t\tpWnd->PostMessage(WM_RELOAD_CLIP_IN_UI, clipId, updateFlags);\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpWnd->SendMessage(WM_RELOAD_CLIP_IN_UI, clipId, updateFlags);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::OnPasteCompleted()\r\n{\r\n}\r\n\r\nvoid CCP_MainApp::OnCopyCompleted(long lLastID, int count, CopyReasonEnum::CopyReason copyReason)\r\n{\r\n\tif(count <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// update copy statistics\r\n\tCGetSetOptions::SetTripCopyCount(-count);\r\n\tCGetSetOptions::SetTotalCopyCount(-count);\r\n\r\n\tif(m_CopyBuffer.Active())\r\n\t{\r\n\t\tm_CopyBuffer.EndCopy(lLastID);\r\n\t}\r\n\r\n\tRefreshView(copyReason);\r\n}\r\n\r\nvoid CCP_MainApp::SaveCurrentGroupState()\r\n{\r\n\tm_oldGroupID = m_GroupID;\r\n\tm_oldGroupParentID = m_GroupParentID;\r\n\tm_oldGroupText = m_GroupText;\r\n}\r\n\r\nvoid CCP_MainApp::ClearOldGroupState()\r\n{\r\n\tm_oldGroupID = -2;\r\n\tm_oldGroupParentID = -2;\r\n\tm_oldGroupText = _T(\"\");\r\n}\r\n\r\nBOOL CCP_MainApp::TryEnterOldGroupState()\r\n{\r\n\tBOOL enteredGroup = FALSE;\r\n\r\n\tif(m_oldGroupID > -2)\r\n\t{\r\n\t\tm_GroupID = m_oldGroupID;\r\n\t\tm_GroupParentID = m_oldGroupParentID;\r\n\t\tm_GroupText = m_oldGroupText;\r\n\r\n\t\tClearOldGroupState();\r\n\r\n\t\ttheApp.RefreshView();\r\n\t\tif(QPasteWnd())\r\n\t\t\tQPasteWnd()->UpdateStatus(true);\r\n\r\n\t\tenteredGroup = TRUE;\r\n\t}\r\n\r\n\treturn enteredGroup;\r\n}\r\n\r\nBOOL CCP_MainApp::EnterGroupID(long lID, BOOL clearOldGroupState/* = TRUE*/, BOOL saveCurrentGroupState/* = FALSE*/)\r\n{\r\n\tBOOL bResult = FALSE;\r\n\r\n\tif(m_GroupID == lID)\r\n\t\treturn TRUE;\r\n\r\n\tDWORD startTick = GetTickCount();\r\n\r\n\tif(clearOldGroupState)\r\n\t{\r\n\t\tClearOldGroupState();\r\n\t}\r\n\r\n\tif(saveCurrentGroupState)\r\n\t{\r\n\t\tSaveCurrentGroupState();\r\n\t}\r\n\r\n\t// if we are switching to the parent, focus on the previous group\r\n\tif(m_GroupParentID == lID && m_GroupID > 0)\r\n\t\tm_FocusID = m_GroupID;\r\n\r\n\tswitch(lID)\r\n\t{\r\n\tcase -1:\r\n\t\tm_FocusID = -1;\r\n\t\tm_GroupID = -1;\r\n\t\tm_GroupParentID = -1;\r\n\t\tm_GroupText = \"History\";\r\n\t\tbResult = TRUE;\r\n\t\tbreak;\r\n\tdefault: // Normal Group\r\n\t\ttry\r\n\t\t{\r\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lParentID, mText, bIsGroup FROM Main WHERE lID = %d\"), lID);\r\n\t\t\tif(q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tif(q.getIntField(_T(\"bIsGroup\")) > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_GroupID = lID;\r\n\t\t\t\t\tm_GroupParentID = q.getIntField(_T(\"lParentID\"));\r\n\t\t\t\t\tm_GroupText = q.getStringField(_T(\"mText\"));\r\n\t\t\t\t\tbResult = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif(bResult)\r\n\t{\r\n\t\ttheApp.RefreshView();\r\n\t\tif(QPasteWnd())\r\n\t\t\tQPasteWnd()->UpdateStatus(true);\r\n\t}\r\n\r\n\tDWORD endTick = GetTickCount();\r\n\tif((endTick-startTick) > 150)\r\n\t\tLog(StrF(_T(\"Paste Timing EnterParentId: %d\"), endTick-startTick));\r\n\r\n\treturn bResult;\r\n}\r\n\r\n// returns a usable group id (not negative)\r\nlong CCP_MainApp::GetValidGroupID()\r\n{\r\n\treturn m_GroupID;\r\n}\r\n\r\n// sets a valid id\r\nvoid CCP_MainApp::SetGroupDefaultID(long lID)\r\n{\r\n\tif(m_GroupDefaultID == lID)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif(lID <= 0)\r\n\t{\r\n\t\tm_GroupDefaultID = 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_GroupDefaultID = lID;\r\n\t}\r\n\r\n\tif(QPasteWnd())\r\n\t{\r\n\t\tQPasteWnd()->UpdateStatus();\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::SetStatus(const TCHAR* status, bool bRepaintImmediately)\r\n{\r\n\tm_Status = status;\r\n\tif(QPasteWnd())\r\n\t{\r\n\t\tQPasteWnd()->UpdateStatus(bRepaintImmediately);\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::ShowPersistent(bool bVal)\r\n{\r\n\tCGetSetOptions::SetShowPersistent(bVal);\r\n\r\n\t// give some visual indication\r\n\tif(m_bShowingQuickPaste)\r\n\t{\r\n\t\tASSERT(QPasteWnd());\r\n\t\tQPasteWnd()->SetCaptionColorActive(CGetSetOptions::m_bShowPersistent, theApp.GetConnectCV());\r\n\t\tQPasteWnd()->RefreshNc();\r\n\t}\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CCP_MainApp message handlers\r\n\r\nint CCP_MainApp::ExitInstance() \r\n{\r\n\tLog(_T(\"ExitInstance\"));\r\n\r\n\tDeleteDittoTempFiles(FALSE);\r\n\r\n\tm_db.close();\r\n\r\n\tif(m_pUacPasteThread != NULL)\r\n\t{\r\n\t\tif(m_pUacPasteThread->ThreadWasStarted() == false)\r\n\t\t{\r\n\t\t\tm_pUacPasteThread->FireExit();\r\n\t\t}\r\n\t\tdelete m_pUacPasteThread;\r\n\t}\r\n\r\n\tGdiplus::GdiplusShutdown(m_gdiplusToken);\r\n\r\n\treturn CWinApp::ExitInstance();\r\n}\r\n\r\n// return TRUE if there is more idle processing to do\r\nBOOL CCP_MainApp::OnIdle(LONG lCount)\r\n{\r\n\t// let winapp handle its idle processing\r\n\tif(CWinApp::OnIdle(lCount))\r\n\t\treturn TRUE;\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CCP_MainApp::SetConnectCV(bool bConnect)\r\n{ \r\n\tm_CopyThread.SetConnectCV(bConnect); \r\n\tCGetSetOptions::SetConnectedToClipboard(bConnect == true);\r\n\r\n\tif(bConnect)\r\n\t{\r\n\t\tm_pMainFrame->m_trayIcon.SetIcon(IDR_MAINFRAME);\r\n\t\tm_pMainFrame->m_trayIcon.SetTooltipText(_T(\"Ditto\"));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pMainFrame->m_trayIcon.SetIcon(IDI_DITTO_NOCOPYCB);\r\n\t\tCString cs;\r\n\t\tcs = _T(\"Ditto \");\r\n\t\tcs += theApp.m_Language.GetString(\"disconnected\", \"[Disconnected]\");\r\n\t\tm_pMainFrame->m_trayIcon.SetTooltipText(cs);\r\n\t}\r\n\r\n\tif(QPasteWnd())\r\n\t{\r\n\t\tQPasteWnd()->SetCaptionColorActive(CGetSetOptions::m_bShowPersistent, theApp.GetConnectCV());\r\n\t\tQPasteWnd()->RefreshNc();\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::OnDeleteID(long lID)\r\n{\r\n\tif(QPasteWnd())\r\n\t{\r\n\t\tQPasteWnd()->PostMessage(NM_ITEM_DELETED, lID, 0);\r\n\t}\r\n}\r\n\r\nbool CCP_MainApp::ImportClips(HWND hWnd)\r\n{\r\n\tOPENFILENAME\tFileName;\r\n\tTCHAR\t\t\tszFileName[400];\r\n\tTCHAR\t\t\tszDir[400];\r\n\r\n\tmemset(&FileName, 0, sizeof(FileName));\r\n\tmemset(szFileName, 0, sizeof(szFileName));\r\n\tmemset(&szDir, 0, sizeof(szDir));\r\n\r\n\tCString csInitialDir = CGetSetOptions::GetLastImportDir();\r\n\tSTRCPY(szDir, csInitialDir);\r\n\r\n\tFileName.lStructSize = sizeof(FileName);\r\n\tFileName.lpstrTitle = _T(\"Import Clips\");\r\n\tFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;\r\n\tFileName.nMaxFile = 400;\r\n\tFileName.lpstrFile = szFileName;\r\n\tFileName.lpstrInitialDir = szDir;\r\n\tFileName.lpstrFilter = _T(\"Exported Ditto Clips (.dto)\\0*.dto\\0\\0\");\r\n\tFileName.lpstrDefExt = _T(\"dto\");\r\n\r\n\tif(GetOpenFileName(&FileName) == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tusing namespace nsPath;\r\n\tCPath path(FileName.lpstrFile);\r\n\tCString csPath = path.GetPath();\r\n\tCGetSetOptions::SetLastImportDir(csPath);\r\n\t\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3DB db;\r\n\t\tdb.open(FileName.lpstrFile);\r\n\r\n\t\tCClip_ImportExport clip;\r\n\t\tif(clip.ImportFromSqliteDB(db, true, false))\r\n\t\t{\r\n\t\t\tCShowTaskBarIcon show;\r\n\r\n\t\t\tCString cs;\r\n\t\t\t\r\n\t\t\tcs.Format(_T(\"%s %d \"), theApp.m_Language.GetString(\"Import_Successfully\", \"Successfully imported\"), clip.m_importCount);\r\n\t\t\tif(clip.m_importCount = 1)\r\n\t\t\t\tcs += theApp.m_Language.GetString(\"Clip\", \"clip\");\r\n\t\t\telse\r\n\t\t\t\tcs += theApp.m_Language.GetString(\"Clips\", \"clips\");\r\n\r\n\t\t\tMessageBox(hWnd, cs, _T(\"Ditto\"), MB_OK);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCShowTaskBarIcon show;\r\n\t\t\tMessageBox(hWnd, theApp.m_Language.GetString(\"Error_Importing\", \"Error importing exported clip\"), _T(\"Ditto\"), MB_OK);\r\n\t\t}\r\n\t}\r\n\tcatch (CppSQLite3Exception& e)\r\n\t{\r\n\t\tASSERT(FALSE);\r\n\r\n\t\tCString csError;\r\n\t\tcsError.Format(_T(\"%s - Exception - %d - %s\"), theApp.m_Language.GetString(\"Error_Parsing\", \"Error parsing exported clip\"), e.errorCode(), e.errorMessage());\r\n\t\tMessageBox(hWnd, csError, _T(\"Ditto\"), MB_OK);\r\n\t}\t\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CCP_MainApp::ShowCommandLineError(CString csTitle, CString csMessage)\r\n{\r\n\tLog(StrF(_T(\"ShowCommandLineError %s - %s\"), csTitle, csMessage));\r\n\r\n\tCToolTipEx *pErrorWnd = new CToolTipEx;\r\n\tpErrorWnd->Create(NULL);\r\n\tpErrorWnd->SetToolTipText(csTitle + \"\\n\\n\" + csMessage);\r\n\r\n\tCPoint pt;\r\n\tCRect rcScreen = DefaultMonitorRect();\r\n\tpt = rcScreen.BottomRight();\r\n\r\n\tCRect cr = pErrorWnd->GetBoundsRect();\r\n\r\n\tpt.x -= max(cr.Width()+50, 150);\r\n\tpt.y -= max(cr.Height()+50, 150);\r\n\r\n\tpErrorWnd->Show(pt);\r\n\r\n\tPumpMessageEx(pErrorWnd->m_hWnd);\r\n\t\r\n\tSleep(4000);\r\n\r\n\tpErrorWnd->DestroyWindow();\r\n}\r\n\r\nBOOL CCP_MainApp::GetClipData(long parentId, CClipFormat &Clip)\r\n{\r\n\tBOOL bRet = FALSE;\r\n\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT ooData FROM Data WHERE lParentID = %d AND strClipboardFormat = '%s'\"), parentId, GetFormatName(Clip.m_cfType));\r\n\t\tif(q.eof() == false)\r\n\t\t{\r\n\t\t\tint nDataLen = 0;\r\n\t\t\tconst unsigned char *cData = q.getBlobField(_T(\"ooData\"), nDataLen);\r\n\t\t\tif(cData != NULL)\r\n\t\t\t{\r\n\t\t\t\tClip.m_hgData = NewGlobal(nDataLen);\r\n\r\n\t\t\t\t::CopyToGlobalHP(Clip.m_hgData, (LPVOID)cData, nDataLen);\r\n\r\n\t\t\t\tbRet = TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\treturn bRet;\r\n}\r\n\r\n\r\n\r\nbool CCP_MainApp::EditItems(CClipIDs &Ids, bool bShowError, bool forceTextEdit)\r\n{\r\n\tbool ret = false;\t\r\n\t\r\n\tint lastFileCheckId = 1;\r\n\r\n\tfor (int i = 0; i < min(Ids.GetCount(), 20); i++)\r\n\t{\r\n\t\tconst int id = Ids[i];\t\t\r\n\r\n\t\tCClip clip;\r\n\t\tif (id >= 0 && clip.LoadFormats(id, true, true) == false)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"Failed to load formats for clipId: %d\"), id));\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tbool unicodeFile = false;\r\n\t\tbool asciFile = false;\r\n\t\tbool rtfFile = false;\r\n\t\tCString exePath;\r\n\t\tCString extension;\r\n\t\tif (forceTextEdit == false && clip.ContainsClipFormat(theApp.m_RTFFormat))\r\n\t\t{\r\n\t\t\textension = _T(\"rtf\");\r\n\t\t\trtfFile = true;\r\n\t\t\texePath = CGetSetOptions::GetRTFEditorPath();\r\n\t\t}\r\n\t\telse if (clip.ContainsClipFormat(CF_UNICODETEXT))\r\n\t\t{\r\n\t\t\textension = _T(\"txt\");\r\n\t\t\tunicodeFile = true;\r\n\t\t\texePath = CGetSetOptions::GetTextEditorPath();\r\n\t\t}\r\n\t\telse if (clip.ContainsClipFormat(CF_TEXT))\r\n\t\t{\r\n\t\t\textension = _T(\"txt\");\r\n\t\t\tasciFile = true;\r\n\t\t\texePath = CGetSetOptions::GetTextEditorPath();\r\n\t\t}\r\n\t\telse if (id == -1)\r\n\t\t{\r\n\t\t\textension = _T(\"txt\");\r\n\t\t\tunicodeFile = true;\r\n\t\t\texePath = CGetSetOptions::GetTextEditorPath();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tCString startingFilePath = StrF(_T(\"%sEditClip_%d.%s\"), CGetSetOptions::GetPath(PATH_EDIT_CLIPS), id, extension);\r\n\r\n\t\tif (id == -1)\r\n\t\t{\r\n\t\t\tstartingFilePath = StrF(_T(\"%sNewClip_1.%s\"), CGetSetOptions::GetPath(PATH_EDIT_CLIPS), extension);\r\n\t\t}\r\n\r\n\t\tCString savePath = startingFilePath;\r\n\r\n\t\t//for new files make a unique file name\r\n\t\tif (id < 0 &&\r\n\t\t\tFileExists(startingFilePath))\r\n\t\t{\r\n\t\t\tsavePath = _T(\"\");\r\n\r\n\t\t\tfor (int y = lastFileCheckId; y < 1000000; y++)\r\n\t\t\t{\r\n\t\t\t\tCString testFilePath = StrF(_T(\"%sNewClip_%d.%s\"), CGetSetOptions::GetPath(PATH_EDIT_CLIPS), y, extension);\r\n\r\n\t\t\t\tif (FileExists(testFilePath) == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tsavePath = testFilePath;\r\n\t\t\t\t\tlastFileCheckId = y + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_editThread.WatchFile(savePath);\r\n\r\n\t\tclip.WriteTextToFile(savePath, unicodeFile, asciFile, rtfFile, (id == -1));\r\n\r\n\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\r\n\t\tsei.fMask = SEE_MASK_NOCLOSEPROCESS;\r\n\t\tsei.lpVerb = _T(\"open\");\r\n\r\n\t\tif (exePath != _T(\"\"))\r\n\t\t{\r\n\t\t\tsei.lpFile = exePath;\r\n\t\t\tsei.lpParameters = savePath;\r\n\r\n\t\t\tLog(StrF(_T(\"Launching editor path: %s, file: %s\"), exePath, savePath));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tsei.lpFile = savePath;\r\n\r\n\t\t\tLog(StrF(_T(\"Launching editor without specific exe path, file: %s\"), savePath));\r\n\t\t}\r\n\t\t\r\n\t\tsei.nShow = SW_NORMAL;\r\n\r\n\t\tif (ShellExecuteEx(&sei) == FALSE)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"ShellExecuteEx failed, not editing clipid: %d\"), id));\r\n\t\t\tcontinue;\r\n\t\t}\t\t\r\n\r\n\t\t/*DWORD PID = GetProcessId(sei.hProcess);\r\n\r\n\t\tHANDLE hProcess = sei.hProcess;\r\n\t\tif (m_editThread.IsRunning() == false)\r\n\t\t{\r\n\t\t\tm_editThread.SubscribeToFileChanges();\r\n\t\t\tm_editThread.Start();\r\n\t\t}\r\n\r\n\t\tm_editThread.WatchFileForChange(savePath, id, hProcess);*/\r\n\r\n\t\tret = true;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CCP_MainApp::PumpMessageEx(HWND hWnd)\r\n{\r\n\tMSG KeyboardMsg;\r\n\twhile (::PeekMessage(&KeyboardMsg, hWnd, 0, 0, PM_REMOVE))\r\n\t{\r\n\t\t::TranslateMessage(&KeyboardMsg);\r\n\t\t::DispatchMessage(&KeyboardMsg);\r\n\t}\r\n}\r\n\r\nHWND CCP_MainApp::QPastehWnd() \r\n{ \r\n\tif(m_pMainFrame != NULL)\r\n\t{\r\n\t\tif(m_pMainFrame->m_quickPaste.m_pwndPaste != NULL)\r\n\t\t{\r\n\t\t\treturn m_pMainFrame->m_quickPaste.m_pwndPaste->GetSafeHwnd();\r\n\t\t}\r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n\r\nCQPasteWnd* CCP_MainApp::QPasteWnd() \r\n{ \r\n\tif(m_pMainFrame != NULL)\r\n\t{\r\n\t\treturn m_pMainFrame->m_quickPaste.m_pwndPaste; \r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n\r\nbool CCP_MainApp::UACPaste()\r\n{\r\n\tif(m_pUacPasteThread == NULL)\r\n\t{\r\n\t\tm_pUacPasteThread = new CUAC_Thread(GetCurrentProcessId());\r\n\t}\r\n\r\n\treturn m_pUacPasteThread->UACPaste();\r\n}\r\n\r\nbool CCP_MainApp::UACCopy()\r\n{\r\n\tif(m_pUacPasteThread == NULL)\r\n\t{\r\n\t\tm_pUacPasteThread = new CUAC_Thread(GetCurrentProcessId());\r\n\t}\r\n\r\n\treturn m_pUacPasteThread->UACCopy();\r\n}\r\n\r\nbool CCP_MainApp::UACCut()\r\n{\r\n\tif(m_pUacPasteThread == NULL)\r\n\t{\r\n\t\tm_pUacPasteThread = new CUAC_Thread(GetCurrentProcessId());\r\n\t}\r\n\r\n\treturn m_pUacPasteThread->UACCut();\r\n}\r\n\r\nbool CCP_MainApp::UACThreadRunning()\r\n{\r\n\tif(m_pUacPasteThread != NULL)\r\n\t{\r\n\t\treturn m_pUacPasteThread->IsRunning();\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid CCP_MainApp::RefreshShowInTaskBar()\r\n{\r\n\tif(m_pMainFrame != NULL)\r\n\t{\r\n\t\tm_pMainFrame->RefreshShowInTaskBar();\r\n\t}\r\n}\r\n\r\nvoid CCP_MainApp::SetActiveGroupId(int groupId)\r\n{\r\n\tm_activeGroupId = groupId;\r\n\tm_activeGroupStartTime = GetTickCount();\r\n}\r\n\r\nint CCP_MainApp::GetActiveGroupId()\r\n{\r\n\tint ret = -1;\r\n\tDWORD maxDiff = CGetSetOptions::GetSaveToGroupTimeoutMS();\r\n\tDWORD diff = GetTickCount() - m_activeGroupStartTime;\r\n\r\n\tif(m_activeGroupId > -1 &&\r\n\t\tdiff < maxDiff)\r\n\t{\r\n\t\tret = m_activeGroupId;\r\n\t}\r\n\r\n\tm_activeGroupId = -1;\r\n\tm_activeGroupStartTime = 0;\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CCP_MainApp::SetCopyReason(CopyReasonEnum::CopyReason copyReason)\r\n{\r\n\tm_copyReason = copyReason;\r\n\tm_copyReasonStartTime = GetTickCount();\r\n}\r\n\r\nCopyReasonEnum::CopyReason CCP_MainApp::GetCopyReason()\r\n{\r\n\tCopyReasonEnum::CopyReason ret = CopyReasonEnum::COPY_TO_UNKOWN;\r\n\tDWORD maxDiff = CGetSetOptions::GetCopyReasonTimeoutMS();\r\n\tDWORD diff = GetTickCount() - m_copyReasonStartTime;\r\n\r\n\tif(m_copyReason != CopyReasonEnum::COPY_TO_UNKOWN &&\r\n\t\tdiff < maxDiff)\r\n\t{\r\n\t\tret = m_copyReason;\r\n\t}\r\n\r\n\tm_copyReason = CopyReasonEnum::COPY_TO_UNKOWN;\r\n\tm_copyReasonStartTime = 0;\r\n\r\n\treturn ret;\r\n}"
        },
        {
          "name": "CP_Main.h",
          "type": "blob",
          "size": 5.7978515625,
          "content": "#pragma once\r\n\r\n#ifndef __AFXWIN_H__\r\n#error include 'stdafx.h' before including this file for PCH\r\n#endif\r\n\r\n#include \"resource.h\"       // main symbols\r\n#include \"Clip.h\"\r\n#include \"DatabaseUtilities.h\"\r\n#include \"Misc.h\"\r\n#include \"Options.h\"\r\n#include \"Shared/ArrayEx.h\"\r\n#include \"MainFrm.h\"\r\n#include \"ProcessPaste.h\"\r\n#include \"MultiLanguage.h\"\r\n#include \"CopyThread.h\"\r\n#include \"ClipboardSaveRestore.h\"\r\n#include \"DittoCopyBuffer.h\"\r\n#include \"sqlite\\CppSQLite3.h\"\r\n#include \"DittoAddins.h\"\r\n#include \"externalwindowtracker.h\"\r\n#include \"HotKeys.h\"\r\n#include \"UAC_Thread.h\"\r\n#include \"ICU_String.h\"\r\n#include \"ClipEditThread.h\"\r\n\r\n\r\nextern class CCP_MainApp theApp;\r\n\r\nclass CCP_MainApp : public CWinApp\r\n{\r\npublic:\r\n\tCCP_MainApp();\r\n\t~CCP_MainApp();\r\n\r\n\tCppSQLite3DB m_db;\r\n\tbool m_databaseOnNetworkShare;\r\n\r\n\tHANDLE\tm_hMutex; // for singleton app\r\n\tHANDLE m_adminPasteMutex;\r\n\t// track stages of startup / shutdown\r\n\tbool\tm_bAppRunning;\r\n\tbool\tm_bAppExiting;\r\n\tint \tm_connectOnStartup;\r\n\r\n\tbool\tm_bExitServerThread;\r\n\r\n\t// MainFrame\r\n\tHWND m_MainhWnd;\r\n\tCMainFrame* m_pMainFrame;\r\n\tCFrameWnd* m_pNoDbMainFrame;\r\n\tvoid AfterMainCreate();  // called after main window creation\r\n\tvoid BeforeMainClose();  // called before main window close\r\n\r\n// System-wide HotKeys\r\n\tCHotKey* m_pDittoHotKey; // activate ditto's qpaste window\r\n\tCHotKey* m_pDittoHotKey2; // activate ditto's qpaste window\r\n\tCHotKey* m_pDittoHotKey3; // activate ditto's qpaste window\r\n\r\n\tCHotKey* m_pPosOne;\r\n\tCHotKey* m_pPosTwo;\r\n\tCHotKey* m_pPosThree;\r\n\tCHotKey* m_pPosFour;\r\n\tCHotKey* m_pPosFive;\r\n\tCHotKey* m_pPosSix;\r\n\tCHotKey* m_pPosSeven;\r\n\tCHotKey* m_pPosEight;\r\n\tCHotKey* m_pPosNine;\r\n\tCHotKey* m_pPosTen;\r\n\r\n\tCHotKey* m_pCopyBuffer1;\r\n\tCHotKey* m_pPasteBuffer1;\r\n\tCHotKey* m_pCutBuffer1;\r\n\tCHotKey* m_pCopyBuffer2;\r\n\tCHotKey* m_pPasteBuffer2;\r\n\tCHotKey* m_pCutBuffer2;\r\n\tCHotKey* m_pCopyBuffer3;\r\n\tCHotKey* m_pPasteBuffer3;\r\n\tCHotKey* m_pCutBuffer3;\r\n\r\n\tCHotKey* m_pCopyBuffer4;\r\n\tCHotKey* m_pPasteBuffer4;\r\n\tCHotKey* m_pCutBuffer4;\r\n\r\n\tCHotKey* m_pCopyBuffer5;\r\n\tCHotKey* m_pPasteBuffer5;\r\n\tCHotKey* m_pCutBuffer5;\r\n\r\n\tCHotKey* m_pTextOnlyPaste;\r\n\tCHotKey* m_pSaveClipboard;\r\n\tCHotKey* m_pCopyAndSaveClipboard;\r\n\r\n\tExternalWindowTracker m_activeWnd;\r\n\r\n\tCClipEditThread m_editThread;\r\n\r\n\t// CopyThread and ClipViewer (Copy and Paste Management)\r\n\tCCopyThread\tm_CopyThread;\r\n\tvoid StartCopyThread();\r\n\tvoid StopCopyThread();\r\n\t// for posting messages\r\n\tHWND GetClipboardViewer() { return m_CopyThread.m_pClipboardViewer->m_hWnd; }\r\n\tbool EnableCbCopy(bool bState) { return m_CopyThread.SetCopyOnChange(bState); }\r\n\tbool IsClipboardViewerConnected() { return m_CopyThread.IsClipboardViewerConnected(); }\r\n\tbool GetConnectCV() { return m_CopyThread.GetConnectCV(); }\r\n\tvoid SetConnectCV(bool bConnect);\r\n\tbool ToggleConnectCV();\r\n\tvoid UpdateMenuConnectCV(CMenu* pMenu, UINT nMenuID);\r\n\tbool ImportClips(HWND hWnd);\r\n\tvoid LoadGlobalClips();\r\n\r\n\tvoid OnDeleteID(long lID);\r\n\tBOOL GetClipData(long lID, CClipFormat& Clip);\r\n\tbool EditItems(CClipIDs& Ids, bool bShowError, bool forceTextEdit);\r\n\r\n\tCClipTypes* LoadTypesFromDB(); // returns a \"new\" allocated object\r\n\tvoid ReloadTypes();\r\n\tvoid RefreshView(CopyReasonEnum::CopyReason copyReason = CopyReasonEnum::COPY_TO_UNKOWN); // refreshes the view if it is visible\r\n\tvoid RefreshClipInUI(int clipId, int updateFlags);\r\n\tvoid OnCopyCompleted(long lLastID, int count = 1, CopyReasonEnum::CopyReason copyReason = CopyReasonEnum::COPY_TO_UNKOWN);\r\n\tvoid OnPasteCompleted();\r\n\r\n\t// Groups\r\n\tlong\t\tm_GroupDefaultID; // new clips are saved to this group\r\n\tlong\t\tm_GroupID;        // current group\r\n\tlong\t\tm_GroupParentID;  // current group's parent\r\n\tCString\t\tm_GroupText;      // current group's description\r\n\r\n\tlong\t\tm_oldGroupID;\r\n\tlong\t\tm_oldGroupParentID;\r\n\tCString\t\tm_oldGroupText;\r\n\r\n\tvoid SaveCurrentGroupState();\r\n\tvoid ClearOldGroupState();\r\n\tBOOL TryEnterOldGroupState();\r\n\tBOOL EnterGroupID(long lID, BOOL clearOldGroupState = TRUE, BOOL saveCurrentGroupState = FALSE);\r\n\tlong GetValidGroupID(); // returns a valid id (not negative)\r\n\tvoid SetGroupDefaultID(long lID); // sets a valid id\r\n\r\n\r\n// Window States\r\n\t// the ID given focus by CQPasteWnd::FillList\r\n\tlong\tm_FocusID;\r\n\r\n\tbool\tm_bShowingQuickPaste;\r\n\tbool\tm_bRefreshView;\r\n\r\n\tCString m_Status;\r\n\tCQPasteWnd* QPasteWnd();\r\n\tHWND QPastehWnd();\r\n\tvoid SetStatus(const TCHAR* status = NULL, bool bRepaintImmediately = false);\r\n\r\n\tvoid ShowPersistent(bool bVal);\r\n\tbool\tm_bAsynchronousRefreshView;\r\n\r\n\t//Socket Info\r\n\tSOCKET\tm_sSocket;\r\n\tvoid\tStartStopServerThread();\r\n\tvoid\tStopServerThread();\r\n\r\n\tlong\tm_lClipsSent;\r\n\tlong\tm_lClipsRecieved;\r\n\r\n\tlong\tm_lLastGoodIndexForNextworkPassword;\r\n\r\n\tCLIPFORMAT m_cfIgnoreClipboard; // used by CClip::LoadFromClipboard\r\n\tCLIPFORMAT m_cfDelaySavingData;\r\n\tCLIPFORMAT m_PingFormat;\r\n\tCLIPFORMAT m_HTML_Format;\r\n\tCLIPFORMAT m_RemoteCF_HDROP;\r\n\tCLIPFORMAT m_RTFFormat;\r\n\tCLIPFORMAT m_DittoFileData;\r\n\tCLIPFORMAT m_PNG_Format;\r\n\r\n\r\n\tCOleDateTime m_oldtStartUp;\r\n\r\n\tCMultiLanguage m_Language;\r\n\r\n\tCDittoCopyBuffer m_CopyBuffer;\r\n\tvoid PumpMessageEx(HWND hWnd = NULL);\r\n\r\n\tCDittoAddins m_Addins;\r\n\r\n\tULONG_PTR m_gdiplusToken;\r\n\r\n\tbool UACPaste();\r\n\tbool UACCopy();\r\n\tbool UACCut();\r\n\tbool UACThreadRunning();\r\n\r\n\tvoid RefreshShowInTaskBar();\r\n\r\n\tvoid SetActiveGroupId(int groupId);\r\n\tint GetActiveGroupId();\r\n\r\n\tvoid SetCopyReason(CopyReasonEnum::CopyReason copyReason);\r\n\tCopyReasonEnum::CopyReason GetCopyReason();\r\n\r\n\tvoid CreateMainWnd();\r\n\tvoid CloseNoDbWindow();\r\n\r\n\tCICU_String m_icuString;\r\n\r\npublic:\r\n\tvirtual BOOL InitInstance();\r\n\tvirtual int ExitInstance();\r\n\r\n\tafx_msg void OnAppAbout();\r\n\tDECLARE_MESSAGE_MAP()\r\n\tvirtual BOOL OnIdle(LONG lCount);\r\n\r\nprotected:\r\n\tvoid ShowCommandLineError(CString csTitle, CString csMessage);\r\n\tCUAC_Thread* m_pUacPasteThread;\r\n\r\n\tint m_activeGroupId;\r\n\tDWORD m_activeGroupStartTime;\r\n\r\n\tCopyReasonEnum::CopyReason m_copyReason;\r\n\tDWORD m_copyReasonStartTime;\r\n};"
        },
        {
          "name": "CP_Main.idl",
          "type": "blob",
          "size": 0.30859375,
          "content": "// CP_Main.idl : IDL source for CP_Main\n//\n\n// This file will be processed by the MIDL tool to\n// produce the type library (CP_Main.tlb) and marshalling code.\n\nimport \"oaidl.idl\";\nimport \"ocidl.idl\";\n\n[\n\tuuid(C4B234A1-7A0C-4DA0-983D-E6ED40DEAD87),\n\tversion(1.0)\t\n]\nlibrary CP_MainLib\n{\n\timportlib(\"stdole2.tlb\");\n};\n"
        },
        {
          "name": "CP_Main.rc",
          "type": "blob",
          "size": 86.2373046875,
          "content": "// Microsoft Visual C++ generated resource script.\r\n//\r\n#include \"resource.h\"\r\n\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"afxres.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// English (United States) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\nLANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\r\n#pragma code_page(1252)\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n1 TEXTINCLUDE \r\nBEGIN\r\n    \"resource.h\\0\"\r\nEND\r\n\r\n2 TEXTINCLUDE \r\nBEGIN\r\n    \"#include \"\"afxres.h\"\"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n3 TEXTINCLUDE \r\nBEGIN\r\n    \"#define _AFX_NO_SPLITTER_RESOURCES\\r\\n\"\r\n    \"#define _AFX_NO_OLE_RESOURCES\\r\\n\"\r\n    \"#define _AFX_NO_TRACKER_RESOURCES\\r\\n\"\r\n    \"#define _AFX_NO_PROPERTY_RESOURCES\\r\\n\"\r\n    \"\\r\\n\"\r\n    \"#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\\r\\n\"\r\n    \"#ifdef _WIN32\\r\\n\"\r\n    \"LANGUAGE 9, 1\\r\\n\"\r\n    \"#pragma code_page(1252)\\r\\n\"\r\n    \"#endif //_WIN32\\r\\n\"\r\n    \"#include \"\"res\\\\CP_Main.rc2\"\"  // non-Microsoft Visual C++ edited resources\\r\\n\"\r\n    \"#include \"\"afxres.rc\"\"         // Standard components\\r\\n\"\r\n    \"#include \"\"afxprint.rc\"\"       // printing/print preview resources\\r\\n\"\r\n    \"#endif\\r\\n\"\r\n    \"\\r\\n\"\r\n    \"1 TYPELIB \"\"CP_Main.tlb\"\"\\0\"\r\nEND\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Icon\r\n//\r\n\r\n// Icon with lowest ID value placed first to ensure application icon\r\n// remains consistent on all systems.\r\nIDR_MAINFRAME           ICON                    \"res\\\\Ditto2.ico\"\r\n\r\nIDR_CP_MAITYPE          ICON                    \"res\\\\CP_MainDoc.ico\"\r\n\r\nIDI_DITTO_NOCOPYCB      ICON                    \"res\\\\Ditto2_NoCopyCb.ico\"\r\n\r\nIDI_MAINFRAME_NO_DB     ICON                    \"res\\\\Ditto2_NoDb.ico\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Bitmap\r\n//\r\n\r\nIDR_MAINFRAME           BITMAP                  \"res\\\\Toolbar.bmp\"\r\n\r\nIDB_CLOSED_FOLDER       BITMAP                  \"res\\\\bitmap1.bmp\"\r\n\r\nIDB_CLOSED_FOLDER_PRESSED BITMAP                  \"res\\\\closed_f.bmp\"\r\n\r\nIDB_CLOSED_FOLDER_FOCUSED BITMAP                  \"res\\\\bmp00001.bmp\"\r\n\r\nIDB_OPEN_FOLDER         BITMAP                  \"res\\\\bmp00002.bmp\"\r\n\r\nIDB_OPEN_FOLDER_FOCUSED BITMAP                  \"res\\\\open_fol.bmp\"\r\n\r\nIDB_OPEN_FOLDER_PRESSED BITMAP                  \"res\\\\bmp00003.bmp\"\r\n\r\nIDB_BACK                BITMAP                  \"res\\\\back.bmp\"\r\n\r\nIDB_BACK_PRESSED        BITMAP                  \"res\\\\back1.bmp\"\r\n\r\nIDB_BACK_FOCUSED        BITMAP                  \"res\\\\back2.bmp\"\r\n\r\nIDR_EDIT_WND            BITMAP                  \"res\\\\mainfram.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_NORMAL BITMAP                  \"res\\\\search_normal.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_CLOSE BITMAP                  \"res\\\\search_close.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_NORMAL_125 BITMAP                  \"res\\\\search_normal_125.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_CLOSE_125 BITMAP                  \"res\\\\search_close_125.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_CLOSE_150 BITMAP                  \"res\\\\search_close_150.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_NORMAL_150 BITMAP                  \"res\\\\search_normal_150.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_CLOSE_200 BITMAP                  \"res\\\\search_close_200.bmp\"\r\n\r\nIDB_BITMAP_SEARCH_NORMAL_200 BITMAP                  \"res\\\\search_normal_200.bmp\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Toolbar\r\n//\r\n\r\nIDR_MAINFRAME TOOLBAR 16, 15\r\nBEGIN\r\n    BUTTON      ID_FILE_NEW\r\n    BUTTON      ID_FILE_OPEN\r\n    BUTTON      ID_FILE_SAVE\r\n    SEPARATOR\r\n    BUTTON      ID_EDIT_CUT\r\n    BUTTON      ID_EDIT_COPY\r\n    BUTTON      ID_EDIT_PASTE\r\n    SEPARATOR\r\n    BUTTON      ID_FILE_PRINT\r\n    SEPARATOR\r\n    BUTTON      ID_APP_ABOUT\r\nEND\r\n\r\nIDR_EDIT_WND TOOLBAR 16, 15\r\nBEGIN\r\n    BUTTON      ID_BUTTON_NEW\r\n    SEPARATOR\r\n    BUTTON      ID_BUTTON_SAVE\r\n    BUTTON      ID_BUTTON_SAVE_ALL\r\n    SEPARATOR\r\n    BUTTON      ID_BUTTON_SAVE_CLOSE_CLIPBOARD\r\n    SEPARATOR\r\n    BUTTON      ID_BUTTON_CLOSE\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Menu\r\n//\r\n\r\nIDR_MAINFRAME MENU\r\nBEGIN\r\n    POPUP \"&File\"\r\n    BEGIN\r\n        MENUITEM \"&New\\tCtrl+N\",                ID_FILE_NEW\r\n        MENUITEM \"&Open...\\tCtrl+O\",            ID_FILE_OPEN\r\n        MENUITEM \"&Save\\tCtrl+S\",               ID_FILE_SAVE\r\n        MENUITEM \"Save &As...\",                 ID_FILE_SAVE_AS\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"&Print...\\tCtrl+P\",           ID_FILE_PRINT\r\n        MENUITEM \"Print Pre&view\",              ID_FILE_PRINT_PREVIEW\r\n        MENUITEM \"P&rint Setup...\",             ID_FILE_PRINT_SETUP\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Recent File\",                 ID_FILE_MRU_FILE1, GRAYED\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"E&xit\",                       ID_APP_EXIT\r\n    END\r\n    POPUP \"&Edit\"\r\n    BEGIN\r\n        MENUITEM \"&Undo\\tCtrl+Z\",               ID_EDIT_UNDO\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Cu&t\\tCtrl+X\",                ID_EDIT_CUT\r\n        MENUITEM \"&Copy\\tCtrl+C\",               ID_EDIT_COPY\r\n        MENUITEM \"&Paste\\tCtrl+V\",              ID_EDIT_PASTE\r\n    END\r\n    POPUP \"&View\"\r\n    BEGIN\r\n        MENUITEM \"&Toolbar\",                    ID_VIEW_TOOLBAR\r\n        MENUITEM \"&Status Bar\",                 ID_VIEW_STATUS_BAR\r\n    END\r\n    POPUP \"&Help\"\r\n    BEGIN\r\n        MENUITEM \"&About CP_Main...\",           ID_APP_ABOUT\r\n    END\r\nEND\r\n\r\nIDR_MENU MENU\r\nBEGIN\r\n    POPUP \"First\"\r\n    BEGIN\r\n        MENUITEM \"Show Quick Paste\",            ID_FIRST_SHOWQUICKPASTE\r\n        MENUITEM \"Options\",                     ID_FIRST_OPTION\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Show Startup Message\",        ID_FIRST_SHOWSTARTUPMESSAGE\r\n        MENUITEM \"Global Hot Keys\",             ID_FIRST_GLOBALHOTKEYS\r\n        MENUITEM \"Delete Clip Data\",            ID_FIRST_DELETECLIPDATA\r\n        MENUITEM \"Delete All Non Used Clips\",   ID_FIRST_DELETEALLNONUSEDCLIPS\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Backup Database\",             ID_FIRST_BACKUPDATABASE\r\n        MENUITEM \"Restore Database\",            ID_FIRST_RESTOREDATABASE\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Import Clip(s)\",              ID_FIRST_IMPORT\r\n        MENUITEM \"New Clip\",                    ID_FIRST_NEWCLIP\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Help\",                        ID_FIRST_HELP\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Connect To Clipboard\",        ID_FIRST_TOGGLECONNECTCV\r\n        MENUITEM \"Save Current Clipboard\",      ID_FIRST_SAVECURRENTCLIPBOARD\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Exit\",                        ID_FIRST_EXIT\r\n    END\r\nEND\r\n\r\nIDR_QUICK_PASTE MENU\r\nBEGIN\r\n    POPUP \"Menu\"\r\n    BEGIN\r\n        POPUP \"Groups\"\r\n        BEGIN\r\n            MENUITEM \"View Groups\",                 32819\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"New Group\",                   32811\r\n            MENUITEM \"New Group Selection\",         32812\r\n            MENUITEM \"Move to Group\",               32840\r\n            MENUITEM \"Toggle Last Group Toggle\",    ID_GROUPS_TOGGLELASTGROUP\r\n        END\r\n        POPUP \"Send To\"\r\n        BEGIN\r\n            MENUITEM \"Friend One\",                  32824\r\n            MENUITEM \"Friend Two\",                  32825\r\n            MENUITEM \"Friend Three\",                32826\r\n            MENUITEM \"Friend Fore\",                 32827\r\n            MENUITEM \"Friend Five\",                 32828\r\n            MENUITEM \"Friend Six\",                  32829\r\n            MENUITEM \"Friend Seven\",                32830\r\n            MENUITEM \"Friend Eight\",                32831\r\n            MENUITEM \"Friend Nine\",                 32832\r\n            MENUITEM \"Friend Ten\",                  32833\r\n            MENUITEM \"Friend Eleven\",               32834\r\n            MENUITEM \"Friend Twelve\",               32835\r\n            MENUITEM \"Friend Thirteen\",             32836\r\n            MENUITEM \"Friend Foreteen\",             32837\r\n            MENUITEM \"Friend Fifteen\",              32838\r\n            MENUITEM SEPARATOR\r\n        END\r\n        MENUITEM \"View Full Description\",       32793\r\n        POPUP \"Special Paste\"\r\n        BEGIN\r\n            MENUITEM \"Plain Text Only\",             32841\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"UPPER CASE\",                  ID_SPECIALPASTE_UPPERCASE\r\n            MENUITEM \"lower case\",                  ID_SPECIALPASTE_LOWERCASE\r\n            MENUITEM \"Capitalize Case\",             ID_SPECIALPASTE_CAPITALIZE\r\n            MENUITEM \"Sentence case\",               ID_SPECIALPASTE_SENTENCE\r\n            MENUITEM \"Invert Case\",                 ID_SPECIALPASTE_TOGGLECASE\r\n            MENUITEM \"Trim White Space\",            ID_SPECIALPASTE_TRIM\r\n            MENUITEM \"CamelCase\",                   ID_SPECIALPASTE_CAMELCASE\r\n            MENUITEM \"Ascii Text Only\",             ID_SPECIALPASTE_ASCIITEXTONLY\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Remove Line Feeds\",           ID_SPECIALPASTE_REMOVELINEFEEDS\r\n            MENUITEM \"Paste + One Line Feed\",       ID_SPECIALPASTE_PASTE\r\n            MENUITEM \"Paste + Two Line Feeds\",      ID_SPECIALPASTE_PASTE32919\r\n            MENUITEM \"Paste + Current Time\",        ID_SPECIALPASTE_PASTE32927\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Multiple Images Horizontally\", ID_SPECIALPASTE_MULTIPLEIMAGESHORIZONTALLY\r\n            MENUITEM \"Multiple Images Vertically\",  ID_SPECIALPASTE_MULTIPLEIMAGESVERTICALLY\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Paste, Don't Change Clip Order\", ID_SPECIALPASTE_PASTE32945\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Typoglycemia\",                ID_SPECIALPASTE_TYPOGLYCEMIA\r\n            MENUITEM \"Slugify\",                     ID_SPECIALPASTE_SLUGIFY\r\n        END\r\n        POPUP \"Compare\"\r\n        BEGIN\r\n            MENUITEM \"Select Left Text\",            ID_COMPARE_SELECTLEFTCOMPARE\r\n            MENUITEM \"Select Right Text And Compare Against Left\", ID_COMPARE_COMPAREAGAINST\r\n            MENUITEM \"Compare\",                     ID_COMPARE_COMPARE\r\n        END\r\n        MENUITEM \"Filter On Selected Clip\",     ID_MENU_FILTERON\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Delete Entry\",                32801\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Edit Clip\",                   32860\r\n        MENUITEM \"New Clip\",                    32867\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Properties\",                  32776\r\n        POPUP \"Quick Properties\"\r\n        BEGIN\r\n            MENUITEM \"Never Auto Delete\",           32820\r\n            MENUITEM \"Auto Delete\",                 32821\r\n            MENUITEM \"Remove Hot Key\",              32822\r\n            MENUITEM \"Remove Quick Paste\",          32856\r\n        END\r\n        POPUP \"Clip Order\"\r\n        BEGIN\r\n            MENUITEM \"Move To Top\",                 ID_CLIPORDER_MOVETOTOP\r\n            MENUITEM \"Move Up\",                     ID_CLIPORDER_MOVEUP\r\n            MENUITEM \"Move Down\",                   ID_CLIPORDER_MOVEDOWN\r\n            MENUITEM \"Move To Last\",                ID_CLIPORDER_MOVETOLAST\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Make Top Sticky Clip\",        ID_STICKYCLIPS_MAKETOPSTICKYCLIP\r\n            MENUITEM \"Make Last Sticky Clip\",       ID_STICKYCLIPS_MAKELASTSTICKYCLIP\r\n            MENUITEM \"Replace Top Sticky Clip\",     ID_CLIPORDER_REPLACETOPSTICKYCLIP\r\n            MENUITEM \"Remove Sticky Setting\",       ID_STICKYCLIPS_REMOVESTICKYSETTING\r\n        END\r\n        MENUITEM SEPARATOR\r\n        POPUP \"Import/Export\"\r\n        BEGIN\r\n            MENUITEM \"Import Clip(s)\",              32855\r\n            MENUITEM \"Export Clip(s)\",              32853\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"View as QRCode\",              ID_MENU_VIEWASQRCODE\r\n            MENUITEM \"Export Clip(s) to Text File(s)\", ID_EXPORT_EXPORTTOTEXTFILE\r\n            MENUITEM \"Export Clip(s) to Image File(s)\", ID_IMPORT_EXPORTCLIP_BITMAP\r\n            MENUITEM \"Export to Google Translate\",  ID_IMPORT_EXPORTTOGOOGLETRANSLATE\r\n            MENUITEM \"Import File Contents From CF_HDROP\", ID_IMPORT_IMPORTCOPIEDFILE\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"EMail, Content In Body\",      ID_IMPORT_EMAILTO\r\n            MENUITEM \"EMail, Content As Attachment\", ID_IMPORT_EMAIL_CONTENT_ATTACH\r\n            MENUITEM \"EMail, Clip Export As Attachment \", ID_IMPORT_EMAILTOASATTACHMENT\r\n            MENUITEM \"Gmail, Content In Body\",      ID_IMPORT_GMAIL\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Set Drag File Name\",          ID_IMPORT_SETDRAGFILENAME\r\n        END\r\n    END\r\nEND\r\n\r\nIDR_MENU_SEARCH MENU\r\nBEGIN\r\n    POPUP \"Menu\"\r\n    BEGIN\r\n        MENUITEM \"Search Description\",          ID_MENU_SEARCHDESCRIPTION\r\n        MENUITEM \"Search Full Text\",            ID_MENU_SEARCHFULLTEXT\r\n        MENUITEM \"Search Quick Paste\",          ID_MENU_SEARCHQUICKPASTE\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Contains Text Search\",        ID_MENU_CONTAINSTEXTSEARCHONLY\r\n        MENUITEM \"Regular Expression Search\",   ID_MENU_REGULAREXPRESSIONSEARCH\r\n        MENUITEM \"Wildcard Search\",             ID_MENU_WILDCARDSEARCH\r\n    END\r\nEND\r\n\r\nIDR_DESC_OPTIONS_MENU MENU\r\nBEGIN\r\n    POPUP \"First\"\r\n    BEGIN\r\n        MENUITEM \"Remember window position\",    ID_FIRST_REMEMBERWINDOWPOSITION\r\n        MENUITEM \"Size window to content\",      ID_FIRST_SIZEWINDOWTOCONTENT\r\n        MENUITEM \"Scale images to fit window\",  ID_FIRST_SCALEIMAGESTOFITWINDOW\r\n        MENUITEM \"Hide description window on mouse clip selection\", ID_FIRST_HIDEDESCRIPTIONWINDOWONM\r\n        MENUITEM \"Wrap Text\",                   ID_FIRST_WRAPTEXT\r\n        MENUITEM \"Always on top\",               ID_FIRST_ALWAYSONTOP\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"View as Text\",                ID_FIRST_VIEWTEXT\r\n        MENUITEM \"View as RTF\",                 ID_FIRST_VIEWRTF\r\n        MENUITEM \"View as HTML\",                ID_FIRST_VIEWHTML\r\n        MENUITEM \"View as Image\",               ID_FIRST_VIEWASIMAGE\r\n    END\r\nEND\r\n\r\nIDR_MENU_GROUPS MENU\r\nBEGIN\r\n    POPUP \"Menu\"\r\n    BEGIN\r\n        MENUITEM \"New Sub Group\",               ID_MENU_NEWGROUP32896\r\n        MENUITEM \"Delete Group\",                ID_MENU_DELETEGROUP\r\n        MENUITEM \"Properties\",                  ID_MENU_PROPERTIES32898\r\n    END\r\nEND\r\n\r\nIDR_QUICK_PASTE_SYSTEM_MENU MENU\r\nBEGIN\r\n    POPUP \"Menu\"\r\n    BEGIN\r\n        MENUITEM \"Options...\",                  32805\r\n        MENUITEM SEPARATOR\r\n        POPUP \"Search Options\"\r\n        BEGIN\r\n            MENUITEM \"Search Description\",          ID_MENU_SEARCHDESCRIPTION\r\n            MENUITEM \"Search Full Text\",            ID_MENU_SEARCHFULLTEXT\r\n            MENUITEM \"Search Quick Paste\",          ID_MENU_SEARCHQUICKPASTE\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Contains Text Search\",        ID_MENU_CONTAINSTEXTSEARCHONLY\r\n            MENUITEM \"Regular Expression Search\",   ID_MENU_REGULAREXPRESSIONSEARCH\r\n            MENUITEM \"Wildcard Search\",             ID_MENU_WILDCARDSEARCH\r\n        END\r\n        POPUP \"Quick Options\"\r\n        BEGIN\r\n            POPUP \"Lines Per Clip\"\r\n            BEGIN\r\n                MENUITEM \"1\",                           32807\r\n                MENUITEM \"2\",                           32786\r\n                MENUITEM \"3\",                           32787\r\n                MENUITEM \"4\",                           32788\r\n                MENUITEM \"5\",                           32789\r\n            END\r\n            POPUP \"Transparency\"\r\n            BEGIN\r\n                MENUITEM \"None\",                        32800\r\n                MENUITEM \"5 %\",                         32808\r\n                MENUITEM \"10 %\",                        32792\r\n                MENUITEM \"15 %\",                        32794\r\n                MENUITEM \"20 %\",                        32796\r\n                MENUITEM \"25 %\",                        32798\r\n                MENUITEM \"30 %\",                        32799\r\n                MENUITEM \"35 %\",                        ID_TRANSPARENCY_35\r\n                MENUITEM \"40 %\",                        32790\r\n                MENUITEM SEPARATOR\r\n                MENUITEM \"Increase\",                    ID_TRANSPARENCY_INCREASE\r\n                MENUITEM \"Decrease\",                    ID_TRANSPARENCY_DECREASE\r\n                MENUITEM \"Toggle Enabled\",              ID_TRANSPARENCY_TOGGLE\r\n            END\r\n            POPUP \"Positioning\"\r\n            BEGIN\r\n                MENUITEM \"At Caret\",                    32802\r\n                MENUITEM \"At Cursor\",                   32803\r\n                MENUITEM \"At Previous Position\",        32804\r\n            END\r\n            POPUP \"View Caption Bar On\"\r\n            BEGIN\r\n                MENUITEM \"Top\",                         32783\r\n                MENUITEM \"Right\",                       32780\r\n                MENUITEM \"Bottom\",                      32781\r\n                MENUITEM \"Left\",                        32782\r\n            END\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Always on Top\",               32784\r\n            MENUITEM \"Auto Roll-up\",                ID_MENU_AUTOHIDE\r\n            MENUITEM \"Select Font\",                 32844\r\n            MENUITEM SEPARATOR\r\n            MENUITEM \"Show Thumbnails\",             32845\r\n            MENUITEM \"Draw RTF Text\",               32846\r\n        END\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Show Startup Message\",        ID_FIRST_SHOWSTARTUPMESSAGE\r\n        MENUITEM \"Global Hot Keys\",             ID_MENU_GLOBALHOTKEYS32933\r\n        MENUITEM \"Delete Clip Data\",            ID_MENU_DELETECLIPDATA32934\r\n        MENUITEM \"Delete All Non Used Clips\",   ID_MENU_DELETEALLNONUSEDCLIPS\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Backup Database\",             ID_MENU_BACKUPDATABASE\r\n        MENUITEM \"Restore Database\",            ID_MENU_RESTOREDATABSAE\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Import Clip(s)\",              ID_MENU_IMPORTCLIP32935\r\n        MENUITEM \"New Clip\",                    ID_MENU_NEWCLIP32937\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Help\",                        32842\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Connect to Clipboard\",        32775\r\n        MENUITEM \"Save Current Clipboard\",      ID_MENU_SAVECURRENTCLIPBOARD\r\n        MENUITEM SEPARATOR\r\n        MENUITEM \"Exit\",                        32806\r\n    END\r\nEND\r\n\r\nIDR_MENU_NO_DB MENU\r\nBEGIN\r\n    POPUP \"First\"\r\n    BEGIN\r\n        MENUITEM \"Options\",                     ID_FIRST_OPTIONS\r\n        MENUITEM \"Exit\",                        ID_FIRST_EXIT_NO_DB\r\n    END\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Accelerator\r\n//\r\n\r\nIDR_MAINFRAME ACCELERATORS\r\nBEGIN\r\n    \"N\",            ID_FILE_NEW,            VIRTKEY, CONTROL\r\n    \"O\",            ID_FILE_OPEN,           VIRTKEY, CONTROL\r\n    \"S\",            ID_FILE_SAVE,           VIRTKEY, CONTROL\r\n    \"P\",            ID_FILE_PRINT,          VIRTKEY, CONTROL\r\n    \"Z\",            ID_EDIT_UNDO,           VIRTKEY, CONTROL\r\n    \"X\",            ID_EDIT_CUT,            VIRTKEY, CONTROL\r\n    \"C\",            ID_EDIT_COPY,           VIRTKEY, CONTROL\r\n    \"V\",            ID_EDIT_PASTE,          VIRTKEY, CONTROL\r\n    VK_BACK,        ID_EDIT_UNDO,           VIRTKEY, ALT\r\n    VK_DELETE,      ID_EDIT_CUT,            VIRTKEY, SHIFT\r\n    VK_INSERT,      ID_EDIT_COPY,           VIRTKEY, CONTROL\r\n    VK_INSERT,      ID_EDIT_PASTE,          VIRTKEY, SHIFT\r\n    VK_F6,          ID_NEXT_PANE,           VIRTKEY \r\n    VK_F6,          ID_PREV_PANE,           VIRTKEY, SHIFT\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Dialog\r\n//\r\n\r\nIDD_ABOUTBOX DIALOGEX 0, 0, 235, 55\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"About CP_Main\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    ICON            IDR_MAINFRAME,IDC_STATIC,11,17,20,20\r\n    LTEXT           \"CP_Main Version 1.0\",IDC_STATIC,40,10,119,8,SS_NOPREFIX\r\n    LTEXT           \"Copyright (C) 2002\",IDC_STATIC,40,25,119,8\r\n    DEFPUSHBUTTON   \"OK\",IDOK,178,7,50,14,WS_GROUP\r\nEND\r\n\r\nIDD_OPTIONS_UTILITIES DIALOGEX 0, 0, 241, 137\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Database\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    PUSHBUTTON      \"Compact Database\",IDC_COMPACT_DB,14,18,107,14\r\n    PUSHBUTTON      \"Repair Database\",IDC_REPAIR,14,37,107,14\r\n    EDITTEXT        IDC_PATH,16,66,198,12,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"....\",IDC_GET_PATH,214,67,14,12\r\n    LTEXT           \"Database Path:\",IDC_STATIC,14,56,50,8\r\n    LTEXT           \"Database \\r\\nPath:\",IDC_STATIC,27,87,50,25\r\nEND\r\n\r\nIDD_OPTIONS_TYPES DIALOGEX 0, 0, 285, 275\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Supported Types\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    LISTBOX         IDC_LIST1,7,7,216,261,LBS_SORT | LBS_NOINTEGRALHEIGHT | LBS_EXTENDEDSEL | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"&Add\",IDC_ADD,229,10,50,14\r\n    PUSHBUTTON      \"&Delete\",IDC_DELETE,229,30,50,14\r\nEND\r\n\r\nIDD_OPTIONS_QUICK_PASTE DIALOGEX 0, 0, 367, 280\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Quick Paste\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"Show text for first ten copy hot keys\",IDC_SHOW_TEXT_FOR_FIRST_TEN_HOT_KEYS,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,9,335,10\r\n    CONTROL         \"Show leading whitespace\",IDC_DESC_SHOW_LEADING_WHITESPACE,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,20,335,10\r\n    LTEXT           \"Text Lines per Clip\",IDC_STATIC_LINES,25,33,93,8\r\n    EDITTEXT        IDC_LINES_ROW,114,31,19,12,ES_AUTOHSCROLL\r\n    CONTROL         \"Enable Quick Paste Transparency\",IDC_TRANSPARENCY,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,46,155,10\r\n    EDITTEXT        IDC_TRANS_PERC,177,45,19,12,ES_AUTOHSCROLL\r\n    CONTROL         \"Show thumbnails (for CF_DIB types) (Could Increase Memory Usage and Display Speed)\",IDC_SHOW_THUMBNAILS,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,58,335,10\r\n    CONTROL         \"Draw RTF Text in List (for RTF types) (Could Increase Memory Usage an Display Speed)\",IDC_DRAW_RTF,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,68,335,10\r\n    CONTROL         \"Find As You Type\",IDC_CHECK_FIND_AS_YOU_TYPE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,78,335,10\r\n    CONTROL         \"Ensure Entire Window is Visible\",IDC_CHECK_ENTIRE_WINDOW_IS_VISIBLE,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,88,335,10\r\n    CONTROL         \"Show Clips That are in Groups in Main List\",IDC_CHECK_SHOW_ALL_IN_MAIN_LIST,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,98,335,10\r\n    CONTROL         \"Prompt when deleting clips\",IDC_CHECK_PROMPT_DELETE_CLIP,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,108,335,10\r\n    COMBOBOX        IDC_COMBO_THEME,59,180,130,95,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"About Theme\",IDC_BUTTON_THEME,198,180,106,12\r\n    PUSHBUTTON      \"Font\",IDC_BUTTON_FONT,18,198,143,17\r\n    PUSHBUTTON      \"Default Font\",IDC_BUTTON_DEFAULT_FAULT,164,201,70,12\r\n    CONTROL         \"At Caret\",IDC_AT_CARET,\"Button\",BS_AUTORADIOBUTTON,22,233,93,10\r\n    CONTROL         \"At Cursor\",IDC_AT_CURSOR,\"Button\",BS_AUTORADIOBUTTON,22,243,97,10\r\n    CONTROL         \"At Previous Position\",IDC_AT_PREVIOUS,\"Button\",BS_AUTORADIOBUTTON,22,253,117,10\r\n    LTEXT           \"%\",IDC_STATIC,199,45,8,12,SS_CENTERIMAGE\r\n    GROUPBOX        \"Popup Positioning\",IDC_STATIC_POPUP,10,224,138,41\r\n    LTEXT           \"Theme\",IDC_STATIC_THEME,18,180,36,12,SS_CENTERIMAGE\r\n    CONTROL         \"Always Show Scroll Bar\",IDC_CHECK_SHOW_SCROLL_BAR,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,118,335,10\r\n    CONTROL         \"Elevated privileges to paste into elevated apps\",IDC_CHECK_ELEVATE_PRIVILEGES,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,129,335,10\r\n    CONTROL         \"Show In Taskbar\",IDC_CHECK_SHOW_IN_TASKBAR,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,140,335,10\r\n    EDITTEXT        IDC_EDIT_DIFF_PATH,109,162,218,14,ES_AUTOHSCROLL\r\n    LTEXT           \"Diff Application Path\",IDC_STATIC_DIFF,25,164,80,8\r\n    PUSHBUTTON      \"...\",IDC_BUTTON_DIFF_BROWSE,332,162,17,14\r\n    CONTROL         \"Show indicator a clip has been pasted\",IDC_CHECK_SHOW_CLIP_WAS_PASTED,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,151,335,10\r\nEND\r\n\r\nIDD_OPTIONS_KEYSTROKES DIALOGEX 0, 0, 373, 278\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Keyboard Shortcuts\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,10,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_DITTO,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,10,33,14\r\n    CONTROL         \"\",IDC_HOTKEY_TEXT_ONLY,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,58,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_TEXT_ONLY,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,58,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY1,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,59,162,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,141,162,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,59,177,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,141,177,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY3,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,59,192,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,141,192,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY4,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,59,207,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN4,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,141,207,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY5,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,59,222,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN5,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,141,222,33,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY6,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,222,162,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN6,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,303,162,27,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY7,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,222,177,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN7,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,303,177,26,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY8,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,222,192,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN8,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,303,192,26,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY9,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,222,207,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN9,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,303,207,27,14\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY10,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,222,222,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN10,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,303,222,27,14\r\n    CONTROL         \"Send Paste (Otherwise it will just load the item on the clipboard)\",IDC_CHECK_SEND_PASTE,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,12,122,324,13\r\n    GROUPBOX        \"Global Hot Keys for Last Ten Items Copied\",IDC_STATIC_GROUP,7,110,359,134\r\n    LTEXT           \"Activate Ditto\",IDC_STATIC_ACTIVATE,12,10,71,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 1\",IDC_STATIC_1,9,162,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 2\",IDC_STATIC_2,9,177,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 3\",IDC_STATIC_3,9,192,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 4\",IDC_STATIC_4,9,207,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 5\",IDC_STATIC_5,9,222,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 6\",IDC_STATIC_6,174,162,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 7\",IDC_STATIC_7,174,177,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 8\",IDC_STATIC_8,174,192,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 9\",IDC_STATIC_9,174,207,42,14,SS_CENTERIMAGE\r\n    RTEXT           \"Position 10\",IDC_STATIC_10,174,222,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Check the \"\"Win\"\" Button to include the windows keyboard key in your hot key.\",IDC_STATIC_WIN,12,249,359,18\r\n    LTEXT           \"Text Only Paste\",IDC_STATIC_ACTIVATE2,12,58,71,14,SS_CENTERIMAGE\r\n    CONTROL         \"Move clips to the top of the list on paste\",IDC_CHECK_MOVE_CLIPS_ON_PASTE,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,12,134,324,13\r\n    CONTROL         \"\",IDC_HOTKEY_SAVE_CLIPBOARD,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,74,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_SAVE_CLIPBOARD,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,74,33,14\r\n    LTEXT           \"Save Current Clipboard\",IDC_STATIC_COLLECT_CLIPBOARD,12,74,77,14,SS_CENTERIMAGE\r\n    CONTROL         \"\",IDC_HOTKEY_ACTIVATE_2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,26,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_DITTO2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,26,33,14\r\n    LTEXT           \"Activate Ditto\",IDC_STATIC_ACTIVATE3,12,26,71,14,SS_CENTERIMAGE\r\n    CONTROL         \"\",IDC_HOTKEY_ACTIVATE_3,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,42,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_DITTO3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,42,33,14\r\n    LTEXT           \"Activate Ditto\",IDC_STATIC_ACTIVATE4,12,42,71,14,SS_CENTERIMAGE\r\n    CONTROL         \"Use currently selected group in Ditto's UI for last ten copies\",IDC_CHECK_USE_UI_GROUP_LAST_10,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,12,147,324,12\r\n    CONTROL         \"Send custom strokes Per Application\",IDC_STATIC_CUSTOM_KEYS,\r\n                    \"MfcLink\",WS_TABSTOP,245,8,127,13\r\n    CONTROL         \"\",IDC_HOTKEY_COPYSAVECLIPBOARD,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,128,91,80,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_COPY_SAVE_CLIPBOARD,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,210,91,33,14\r\n    LTEXT           \"Copy And Save Current Clipboard\",IDC_STATIC_COLLECT_CLIPBOARD2,12,91,111,14,SS_CENTERIMAGE\r\nEND\r\n\r\nIDD_OPTIONS_GENERAL DIALOGEX 0, 0, 375, 275\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"General\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"Start Ditto on System Startup\",IDC_START_ON_STARTUP,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,8,8,138,10\r\n    CONTROL         \"Maximum Number of Saved Copies\",IDC_MAXIMUM,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,8,25,154,10\r\n    EDITTEXT        IDC_MAX_SAVED_COPIES,164,25,27,12,ES_AUTOHSCROLL\r\n    CONTROL         \"Paste Entries Expire after\",IDC_EXPIRE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,8,41,153,10\r\n    EDITTEXT        IDC_EXPIRE_AFTER,164,40,27,12,ES_AUTOHSCROLL\r\n    COMBOBOX        IDC_COMBO_LANGUAGE,67,60,130,95,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"About Language\",IDC_BUTTON_ABOUT,207,60,106,14\r\n    EDITTEXT        IDC_PATH,67,148,283,12,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"....\",IDC_GET_PATH,354,148,14,12\r\n    LTEXT           \"Days\",IDC_STATIC_DAYS,196,40,51,12,SS_CENTERIMAGE\r\n    LTEXT           \"Language\",IDC_STATIC_LANGUAGE,9,60,36,12,SS_CENTERIMAGE\r\n    LTEXT           \"Include\",IDC_STATIC_INCLUDE_APPS,14,189,36,13,SS_CENTERIMAGE\r\n    LTEXT           \"Exclude\",IDC_STATIC_EXCLUDE_APPS,14,211,36,13,SS_CENTERIMAGE\r\n    EDITTEXT        IDC_EDIT_APP_COPY_INCLUDE,50,189,316,13,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_APP_COPY_EXCLUDE,50,211,316,13,ES_AUTOHSCROLL\r\n    GROUPBOX        \"Accepted Copy Applications (seperate by ;)\",IDC_STATIC_APP_SEP_DESC,7,176,361,55\r\n    PUSHBUTTON      \"Advanced\",IDC_BUTTON_ADVANCED,318,256,50,14\r\n    COMBOBOX        IDC_COMBO_THEME,67,82,130,95,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"About Theme\",IDC_BUTTON_THEME,207,82,106,14\r\n    PUSHBUTTON      \"Font\",IDC_BUTTON_FONT,67,125,130,14\r\n    PUSHBUTTON      \"Default Font\",IDC_BUTTON_DEFAULT_FAULT,207,125,106,14\r\n    LTEXT           \"Theme\",IDC_STATIC_THEME,9,82,36,12,SS_CENTERIMAGE\r\n    LTEXT           \"Database Path\",IDC_STATIC_DATABASE_PATH,9,147,57,13,SS_CENTERIMAGE\r\n    COMBOBOX        IDC_COMBO_POPUP_POSITION,67,104,130,95,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    LTEXT           \"Popup Position\",IDC_STATIC_POPUP_POS,9,104,51,12,SS_CENTERIMAGE\r\n    LTEXT           \"Display Font\",IDC_STATIC_FONT,9,125,51,14,SS_CENTERIMAGE\r\n    CONTROL         \"Environment Variables\",IDC_MFCLINK_ENV_VAR,\"MfcLink\",WS_TABSTOP,67,162,283,14\r\n    CONTROL         \"Privacy Policy: https://ditto-cp.sourceforge.io/PrivacyPolicy.php\",IDC_MFCLINK2,\r\n                    \"MfcLink\",WS_TABSTOP,14,257,232,14\r\nEND\r\n\r\nIDD_SELECT_DB DIALOGEX 0, 0, 276, 46\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION\r\nCAPTION \"Select Database\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    DEFPUSHBUTTON   \"OK\",IDOK,101,25,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,170,25,50,14\r\n    EDITTEXT        IDC_PATH,7,7,244,13,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"...\",IDC_SELECT,254,7,15,12\r\n    PUSHBUTTON      \"Use Default\",IDC_USE_DEFAULT,27,25,50,14\r\nEND\r\n\r\nIDD_OPTIONS_STATS DIALOGEX 0, 0, 346, 207\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Stats\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_EDIT_ALL_DATE,13,17,133,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_ALL_COPIES,65,31,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_ALL_PASTES,65,45,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_TRIP_DATE,174,17,143,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_TRIP_COPIES,222,31,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_TRIP_PASTES,222,45,52,12,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"Reset\",IDC_RESET_COUNTS,273,31,44,12\r\n    EDITTEXT        IDC_SAVED_COPIES,99,72,52,12,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"Remove All\",IDC_REMOVE_ALL,185,73,62,12\r\n    EDITTEXT        IDC_SAVED_COPY_DATA,99,86,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_LAST_STARTED,99,115,157,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_DATABASE_SIZE,99,129,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_CLIPS_SENT,99,143,52,12,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_CLIPS_RECIVED,99,157,52,12,ES_AUTOHSCROLL\r\n    LTEXT           \"Copies\",IDC_STATIC_5,174,31,45,12,SS_CENTERIMAGE\r\n    LTEXT           \"Pastes\",IDC_STATIC_6,174,45,46,12,SS_CENTERIMAGE\r\n    GROUPBOX        \"Trip Odometer\",IDC_STATIC_2,170,7,155,54\r\n    LTEXT           \"Copies\",IDC_STATIC_3,13,31,49,12,SS_CENTERIMAGE\r\n    LTEXT           \"Pastes\",IDC_STATIC_4,13,45,50,12,SS_CENTERIMAGE\r\n    GROUPBOX        \"Odometer\",IDC_STATIC_1,7,7,145,54\r\n    LTEXT           \"Saved Copies\",IDC_STATIC_7,15,72,76,12,SS_CENTERIMAGE\r\n    LTEXT           \"Saved Copy Data\",IDC_STATIC_8,15,88,80,18\r\n    LTEXT           \"Database Size\",IDC_STATIC_10,15,129,79,12,SS_CENTERIMAGE\r\n    LTEXT           \"Clips Sent\",IDC_STATIC_11,15,143,79,12,SS_CENTERIMAGE\r\n    LTEXT           \"Clips Received\",IDC_STATIC_12,15,157,79,12,SS_CENTERIMAGE\r\n    GROUPBOX        \"\",IDC_STATIC,7,63,248,47\r\n    LTEXT           \"Last Started\",IDC_STATIC_9,15,115,79,12,SS_CENTERIMAGE\r\n    LTEXT           \"Since Last Start\",IDC_STATIC_13,161,152,100,8\r\nEND\r\n\r\nIDD_ADD_TYPE DIALOGEX 0, 0, 219, 322\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Add Supported Type\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x0\r\nBEGIN\r\n    LISTBOX         IDC_LIST1,7,51,151,264,LBS_SORT | LBS_NOINTEGRALHEIGHT | LBS_EXTENDEDSEL | WS_VSCROLL | WS_TABSTOP\r\n    EDITTEXT        IDC_EDIT1,7,51,151,14,ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"Add\",IDC_ADD_3,162,51,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,162,301,50,14\r\n    CONTROL         \"Primary Clipboard Types\",IDC_RADIO_PRIMARY_TYPES,\"Button\",BS_AUTORADIOBUTTON,7,21,93,10\r\n    CONTROL         \"Current Clipboard Types\",IDC_RADIO_CURRENT_TYPES,\"Button\",BS_AUTORADIOBUTTON,7,7,93,10\r\n    CONTROL         \"Custom Clipboard Type\",IDC_RADIO_CUSTOM_TYPE,\"Button\",BS_AUTORADIOBUTTON,7,35,93,10\r\nEND\r\n\r\nIDD_COPY_PROPERTIES DIALOGEX 0, 0, 293, 289\r\nSTYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\r\nCAPTION \"Copy Properties\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"HotKey1\",IDC_HOTKEY,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,51,7,94,13\r\n    EDITTEXT        IDC_DATE,51,38,93,13,ES_AUTOHSCROLL | WS_DISABLED | NOT WS_TABSTOP\r\n    CONTROL         \"&Never Auto Delete\",IDC_NEVER_AUTO_DELETE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,149,40,105,10\r\n    COMBOBOX        IDC_COMBO1,71,91,215,128,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP\r\n    LISTBOX         IDC_COPY_DATA,7,205,279,43,LBS_SORT | LBS_NOINTEGRALHEIGHT | LBS_EXTENDEDSEL | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"Delete\",IDC_DELETE_COPY_DATA,6,251,42,12\r\n    DEFPUSHBUTTON   \"OK\",IDOK,163,268,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,236,268,50,14\r\n    LTEXT           \"Item Title\",IDC_STATIC_TITLE,7,108,168,8\r\n    LTEXT           \"Date Added\",IDC_STATIC_DATE,8,38,43,13,SS_CENTERIMAGE\r\n    LTEXT           \"Hot Key\",IDC_STATIC_HOT_KEY,7,7,35,13,SS_CENTERIMAGE\r\n    LTEXT           \"Copy Formats\",IDC_STATIC_FORMATS,7,194,226,8\r\n    LTEXT           \"Move To Group\",IDC_STATIC_MOVE_TO_GROUP,8,92,62,9\r\n    EDITTEXT        IDC_EDIT_QUICK_PASTE,71,72,215,13,ES_AUTOHSCROLL\r\n    LTEXT           \"Quick Paste Text\",IDC_STATIC_QUICK_PASTE,7,72,62,13,SS_CENTERIMAGE\r\n    CONTROL         \"Hotkey available globally\",IDC_HOT_KEY_GLOBAL,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,183,7,100,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,149,7,33,14\r\n    EDITTEXT        IDC_DATE_LAST_USED,51,54,93,13,ES_AUTOHSCROLL | WS_DISABLED | NOT WS_TABSTOP\r\n    LTEXT           \"Last Used\",IDC_STATIC_DATE2,8,54,43,13,SS_CENTERIMAGE\r\n    EDITTEXT        IDC_EDIT_PROPERTIES,7,119,279,74,ES_MULTILINE | ES_AUTOHSCROLL | ES_WANTRETURN\r\n    CONTROL         \"\",IDC_HOTKEY_MOVE_TO_GROUP,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,79,23,66,13\r\n    LTEXT           \"Save/Move To Group\",IDC_STATIC_HOT_KEY_MOVE_TO_GROUP,7,23,70,13,SS_CENTERIMAGE\r\n    CONTROL         \"Hotkey available globally\",IDC_HOT_KEY_GLOBAL_MOVE_TO_GROUP,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,183,23,100,14\r\n    CONTROL         \"Win\",IDC_CHECK_WIN_MOVE_TO_GROUP,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,149,23,33,14\r\n    LTEXT           \"Selected format MD5\",IDC_STATIC_MD5,65,250,68,14,SS_CENTERIMAGE\r\n    EDITTEXT        IDC_EDIT_MD5,139,249,147,14,ES_AUTOHSCROLL | ES_READONLY\r\nEND\r\n\r\nIDD_ABOUT DIALOGEX 0, 0, 337, 206\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"About Ditto\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x0\r\nBEGIN\r\n    LISTBOX         IDC_LIST,7,16,323,132,LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP\r\n    LTEXT           \"E-mail Scott Brogden\",IDC_HYPER_LINK,7,153,67,8\r\n    LTEXT           \"Ditto Home Page - ditto-cp.sf.net\",IDC_STATIC_LINK,7,171,104,8\r\nEND\r\n\r\nIDD_GROUP_NAME DIALOGEX 0, 0, 186, 49\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Ditto\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_NAME,7,11,172,12,ES_AUTOHSCROLL\r\n    DEFPUSHBUTTON   \"OK\",IDOK,75,28,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,129,28,50,14\r\n    LTEXT           \"Name\",IDC_STATIC,7,1,59,10\r\nEND\r\n\r\nIDD_OPTIONS_FRIENDS DIALOGEX 0, 0, 367, 275\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Friends\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_EDIT_PLACE_ON_CLIPBOARD,96,39,210,13,ES_AUTOHSCROLL\r\n    CONTROL         \"Disable Receiving Clips\",IDC_CHECK_DISABLE_FRIENDS,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,95,53,146,10\r\n    EDITTEXT        IDC_EDIT_PASSWORD,96,66,210,13,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_ADDITIONAL,95,108,210,12,ES_AUTOHSCROLL\r\n    CONTROL         \"List1\",IDC_LIST,\"SysListView32\",LVS_REPORT | WS_BORDER | WS_TABSTOP,7,186,353,72\r\n    CONTROL         \"Log Send Receive Commands\",IDC_CHECK_LOG_SEND_RECIEVE,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,7,260,353,12\r\n    LTEXT           \"If Send All Copies is selected then all copies from this computer will be sent to the other computer.  If that is not selected then it will just be in the right click menu to send a copy to that computer.\",IDC_STATIC_6,7,159,353,24\r\n    LTEXT           \"IP/Computer Names separated by commas\",IDC_STATIC_2,7,37,84,17\r\n    LTEXT           \"When you receive a sent copy if their ip or computer name is in this list then it will be put on the clipboard.  Otherwise it will be in the saved clips to use at a later time.\",IDC_STATIC_1,7,10,353,26\r\n    LTEXT           \"Network Password\",IDC_STATIC_3,7,69,79,9\r\n    LTEXT           \"If you are receiving clips from computers where your network password does not match, enter additional network passwords separated by commas\",IDC_STATIC_4,7,83,353,22\r\n    LTEXT           \"Receive Passwords\",IDC_STATIC_5,7,110,79,9\r\n    CONTROL         \"Request using IP Address\",IDC_RADIO_USE_IP,\"Button\",BS_AUTORADIOBUTTON,15,136,98,10\r\n    GROUPBOX        \"Remote Files\",IDC_STATIC_REMOTE_FILES,7,124,353,29\r\n    CONTROL         \"Request using Host Name\",IDC_RADIO_USE_HOST_NAME,\"Button\",BS_AUTORADIOBUTTON,151,136,98,10\r\nEND\r\n\r\nIDD_FRIEND_DETAILS DIALOGEX 0, 0, 203, 79\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Friend Details\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_EDIT_IP,47,20,83,13,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_DESCRIPTION,47,39,149,13,ES_AUTOHSCROLL\r\n    CONTROL         \"Send All Copies to this friend\",IDC_CHECK_SEND_ALL,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,47,7,105,10\r\n    DEFPUSHBUTTON   \"OK\",IDOK,89,58,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,146,58,50,14\r\n    LTEXT           \"IP/Name\",IDC_STATIC_1,7,23,30,8\r\n    LTEXT           \"Description\",IDC_STATIC_2,7,41,36,8\r\nEND\r\n\r\nIDD_MOVE_TO_GROUP DIALOGEX 0, 0, 254, 177\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Move to Group\"\r\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"Tree1\",IDC_TREE,\"SysTreeView32\",TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_DISABLEDRAGDROP | TVS_SHOWSELALWAYS | WS_BORDER | WS_TABSTOP,7,7,240,142\r\n    PUSHBUTTON      \"New Group\",IDC_BUTTON_NEW_GROUP,7,156,55,14\r\n    DEFPUSHBUTTON   \"OK\",IDOK,143,156,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,197,156,50,14\r\nEND\r\n\r\nIDD_DIALOG_REMOTE_FILE DIALOGEX 0, 0, 284, 110\r\nSTYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Ditto\"\r\nFONT 8, \"MS Sans Serif\", 0, 0, 0x0\r\nBEGIN\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,227,89,50,14\r\n    CONTROL         \"Progress1\",IDC_PROGRESS_FILE,\"msctls_progress32\",PBS_SMOOTH | WS_BORDER,7,78,270,9\r\n    CONTROL         \"Progress1\",IDC_PROGRESS_ALL_FILES,\"msctls_progress32\",PBS_SMOOTH | WS_BORDER,7,45,270,9\r\n    LTEXT           \"a\",IDC_STATIC_1,7,33,270,10,SS_CENTERIMAGE\r\n    LTEXT           \"\",IDC_STATIC_2,7,59,270,16,SS_CENTERIMAGE\r\n    CONTROL         \"Animate1\",IDC_FILE_COPY,\"SysAnimate32\",ACS_CENTER | ACS_TRANSPARENT | WS_TABSTOP,7,3,270,26\r\nEND\r\n\r\nIDD_OPTIONS_COPY_BUFFERS DIALOGEX 0, 0, 379, 277\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Copy Buffers\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"\",IDC_COPY_1,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,16,80,14\r\n    CONTROL         \"Win\",IDC_WIN_COPY_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,16,27,14\r\n    CONTROL         \"\",IDC_PASTE_1,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,32,80,14\r\n    CONTROL         \"Win\",IDC_WIN_PASTE_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,32,27,14\r\n    CONTROL         \"\",IDC_CUT_1,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,221,32,80,14\r\n    CONTROL         \"Win\",IDC_WIN_CUT_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,304,32,33,14\r\n    CONTROL         \"Play Sound on Copy\",IDC_PLAY_SOUND_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,177,15,80,14\r\n    CONTROL         \"\",IDC_COPY_2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,66,80,14\r\n    CONTROL         \"Win\",IDC_WIN_COPY_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,66,27,14\r\n    CONTROL         \"\",IDC_PASTE_2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,82,80,14\r\n    CONTROL         \"Win\",IDC_WIN_PASTE_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,82,27,14\r\n    CONTROL         \"\",IDC_CUT_2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,221,82,80,14\r\n    CONTROL         \"Win\",IDC_WIN_CUT_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,304,82,33,14\r\n    CONTROL         \"Play Sound on Copy\",IDC_PLAY_SOUND_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,177,66,80,14\r\n    CONTROL         \"\",IDC_COPY_3,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,116,80,14\r\n    CONTROL         \"Win\",IDC_WIN_COPY_3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,116,27,14\r\n    CONTROL         \"\",IDC_PASTE_3,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,132,80,14\r\n    CONTROL         \"Win\",IDC_WIN_PASTE_3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,132,27,14\r\n    CONTROL         \"\",IDC_CUT_3,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,221,132,80,14\r\n    CONTROL         \"Win\",IDC_WIN_CUT_3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,304,132,33,14\r\n    CONTROL         \"Play Sound on Copy\",IDC_PLAY_SOUND_3,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,177,116,80,14\r\n    LTEXT           \"Copy\",IDC_STATIC_COPY_1,19,16,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Paste\",IDC_STATIC_PASTE_1,19,32,43,14,SS_CENTERIMAGE\r\n    LTEXT           \"Cut\",IDC_STATIC_CUT_1,177,31,43,14,SS_CENTERIMAGE\r\n    GROUPBOX        \"Copy Buffer 1\",IDC_BUFFER_GROUP_1,7,7,365,47\r\n    LTEXT           \"Copy\",IDC_STATIC_COPY_2,19,66,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Paste\",IDC_STATIC_PASTE_2,19,82,43,14,SS_CENTERIMAGE\r\n    LTEXT           \"Cut\",IDC_STATIC_CUT_2,177,82,43,14,SS_CENTERIMAGE\r\n    GROUPBOX        \"Copy Buffer 2\",IDC_BUFFER_GROUP_2,7,57,365,47\r\n    LTEXT           \"Copy\",IDC_STATIC_COPY_3,19,116,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Paste\",IDC_STATIC_PASTE_3,19,132,43,14,SS_CENTERIMAGE\r\n    LTEXT           \"Cut\",IDC_STATIC_CUT_3,177,132,43,14,SS_CENTERIMAGE\r\n    GROUPBOX        \"Copy Buffer 3\",IDC_BUFFER_GROUP_3,7,107,365,50\r\n    CONTROL         \"\",IDC_COPY_4,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,169,80,14\r\n    CONTROL         \"Win\",IDC_WIN_COPY_4,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,169,27,14\r\n    CONTROL         \"\",IDC_PASTE_4,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,185,80,14\r\n    CONTROL         \"Win\",IDC_WIN_PASTE_4,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,185,27,14\r\n    CONTROL         \"\",IDC_CUT_4,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,221,185,80,14\r\n    CONTROL         \"Win\",IDC_WIN_CUT_4,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,304,185,33,14\r\n    CONTROL         \"Play Sound on Copy\",IDC_PLAY_SOUND_4,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,177,169,80,14\r\n    LTEXT           \"Copy\",IDC_STATIC_COPY_4,19,169,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Paste\",IDC_STATIC_PASTE_4,19,185,43,14,SS_CENTERIMAGE\r\n    LTEXT           \"Cut\",IDC_STATIC_CUT_4,177,185,43,14,SS_CENTERIMAGE\r\n    GROUPBOX        \"Copy Buffer 4\",IDC_BUFFER_GROUP_4,7,160,365,50\r\n    CONTROL         \"\",IDC_COPY_5,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,223,80,14\r\n    CONTROL         \"Win\",IDC_WIN_COPY_5,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,223,27,14\r\n    CONTROL         \"\",IDC_PASTE_5,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,63,239,80,14\r\n    CONTROL         \"Win\",IDC_WIN_PASTE_5,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,146,239,27,14\r\n    CONTROL         \"\",IDC_CUT_5,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,221,239,80,14\r\n    CONTROL         \"Win\",IDC_WIN_CUT_5,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,304,239,33,14\r\n    CONTROL         \"Play Sound on Copy\",IDC_PLAY_SOUND_5,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,177,223,80,14\r\n    LTEXT           \"Copy\",IDC_STATIC_COPY_5,19,223,42,14,SS_CENTERIMAGE\r\n    LTEXT           \"Paste\",IDC_STATIC_PASTE_5,19,239,43,14,SS_CENTERIMAGE\r\n    LTEXT           \"Cut\",IDC_STATIC_CUT_5,177,239,43,14,SS_CENTERIMAGE\r\n    GROUPBOX        \"Copy Buffer 5\",IDC_BUFFER_GROUP_5,7,213,365,50\r\nEND\r\n\r\nIDD_GLOBAL_CLIPS DIALOGEX 0, 0, 369, 199\r\nSTYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\r\nCAPTION \"Global Hot Keys\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    PUSHBUTTON      \"Close\",IDCANCEL,312,178,50,14\r\n    CONTROL         \"\",IDC_LIST2,\"SysListView32\",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,355,166\r\nEND\r\n\r\nIDD_DELETE_CLIP_DATA DIALOGEX 0, 0, 675, 315\r\nSTYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\r\nCAPTION \"Delete Clip Data\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,618,294,50,14\r\n    CONTROL         \"\",IDC_LIST2,\"SysListView32\",LVS_REPORT | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | LVS_OWNERDATA | WS_BORDER | WS_TABSTOP,7,105,661,185\r\n    CONTROL         \"\",IDC_TIME_CREATE_START,\"SysDateTimePick32\",DTS_RIGHTALIGN | DTS_UPDOWN | WS_DISABLED | WS_TABSTOP | 0x8,203,40,60,15\r\n    CONTROL         \"\",IDC_DATE_CREATE_START,\"SysDateTimePick32\",DTS_RIGHTALIGN | WS_DISABLED | WS_TABSTOP,147,40,53,15\r\n    COMBOBOX        IDC_COMBO_DATA_FORMAT,15,73,116,108,CBS_DROPDOWNLIST | CBS_SORT | WS_DISABLED | WS_VSCROLL | WS_TABSTOP\r\n    EDITTEXT        IDC_EDIT_CLIP_TITLE,15,39,115,17,ES_AUTOHSCROLL | WS_DISABLED\r\n    CONTROL         \"\",IDC_TIME_CREATE_END,\"SysDateTimePick32\",DTS_RIGHTALIGN | DTS_UPDOWN | WS_DISABLED | WS_TABSTOP | 0x8,348,39,59,15\r\n    CONTROL         \"\",IDC_DATE_CREATE_END,\"SysDateTimePick32\",DTS_RIGHTALIGN | WS_DISABLED | WS_TABSTOP,291,39,53,15\r\n    CONTROL         \"Title\",IDC_CHECK_CLIP_TITLE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,15,26,29,10\r\n    CONTROL         \"Create Date Range\",IDC_CHECK_CREATE_DATE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,147,26,78,10\r\n    CONTROL         \"\",IDC_TIME_USE_START,\"SysDateTimePick32\",DTS_RIGHTALIGN | DTS_UPDOWN | WS_DISABLED | WS_TABSTOP | 0x8,203,73,60,15\r\n    CONTROL         \"\",IDC_DATE_USE_START,\"SysDateTimePick32\",DTS_RIGHTALIGN | WS_DISABLED | WS_TABSTOP,147,73,53,15\r\n    CONTROL         \"\",IDC_TIME_USE_END,\"SysDateTimePick32\",DTS_RIGHTALIGN | DTS_UPDOWN | WS_DISABLED | WS_TABSTOP | 0x8,348,73,59,15\r\n    CONTROL         \"\",IDC_DATE_USE_END,\"SysDateTimePick32\",DTS_RIGHTALIGN | WS_DISABLED | WS_TABSTOP,291,73,53,15\r\n    CONTROL         \"Last Used Range\",IDC_CHECK_LAST_USE_DATE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,147,60,70,10\r\n    CONTROL         \"Format\",IDC_CHECK_DATA_FORMAT,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,15,60,39,10\r\n    PUSHBUTTON      \"Search\",IDC_BUTTON_SEARCH,607,73,50,14\r\n    LTEXT           \"Database Size:\",IDC_STATIC_DB_SIZE_TEXT,7,300,49,8\r\n    LTEXT           \"Size\",IDC_STATIC_DB_SIZE,59,300,39,8\r\n    LTEXT           \"Selected Size:\",IDC_STATIC_SELECTED_SIZE_TEXT,109,300,46,8\r\n    LTEXT           \"Size\",IDC_STATIC_SELECTED_SIZE,161,300,39,8\r\n    PUSHBUTTON      \"Delete\",IDC_BUTTON_APPLY,561,295,49,13\r\n    CTEXT           \"Each clip in Ditto is made of multiple clipboard items, all clipboard items in Ditto are listed below.\",IDC_STATIC_DESC,7,7,661,14\r\n    LTEXT           \"<  --   >\",IDC_STATIC,263,42,27,8\r\n    LTEXT           \"<  --   >\",IDC_STATIC,263,76,27,8\r\n    GROUPBOX        \"Search Options\",IDC_STATIC_GROUP_SEARCH,4,15,661,83\r\n    LTEXT           \"Selected Count:\",IDC_STATIC_SELECTED_SIZE_TEXT2,207,300,52,8\r\n    LTEXT           \"Count\",IDC_STATIC_SELECTED_COUNT,259,300,39,8\r\nEND\r\n\r\nIDD_OPTIONS_QUICK_PASTE_KEYBOARD DIALOGEX 0, 0, 375, 278\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \" \"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    CONTROL         \"\",IDC_LIST1,\"SysListView32\",LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,21,361,122\r\n    CONTROL         \"Keyboard Shortcut\",IDC_RADIO_KEYBOARD_1,\"Button\",BS_AUTORADIOBUTTON | WS_GROUP,14,205,76,10\r\n    CONTROL         \"Mouse Click\",IDC_RADIO_MOUSE_1,\"Button\",BS_AUTORADIOBUTTON,99,205,53,10\r\n    CONTROL         \"\",IDC_HOTKEY1,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,25,219,80,14\r\n    PUSHBUTTON      \"Enter Key\",IDC_BUTTON_ENTER,109,219,44,14\r\n    CONTROL         \"Shift\",IDC_CHECK_SHIFT_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,25,236,31,10\r\n    CONTROL         \"Control\",IDC_CHECK_CONTROL_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,61,236,39,10\r\n    CONTROL         \"Alt\",IDC_CHECK_ALT_1,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,105,236,25,10\r\n    CONTROL         \"Enable Second Keypress\",IDC_CHECK_ENABLE_SECOND_PRESS,\r\n                    \"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,181,180,105,10\r\n    CONTROL         \"Keyboard Shortcut\",IDC_RADIO_KEYBOARD_2,\"Button\",BS_AUTORADIOBUTTON | WS_GROUP,183,204,76,10\r\n    CONTROL         \"Mouse Click\",IDC_RADIO_MOUSE_2,\"Button\",BS_AUTORADIOBUTTON,263,204,53,10\r\n    CONTROL         \"\",IDC_HOTKEY2,\"msctls_hotkey32\",WS_BORDER | WS_TABSTOP,195,218,80,14\r\n    PUSHBUTTON      \"Enter Key\",IDC_BUTTON_ENTER2,282,218,44,14\r\n    CONTROL         \"Shift\",IDC_CHECK_SHIFT_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,195,236,31,10\r\n    CONTROL         \"Control\",IDC_CHECK_CONTROL_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,231,236,39,10\r\n    CONTROL         \"Alt\",IDC_CHECK_ALT_2,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,275,236,25,10\r\n    PUSHBUTTON      \"Assign\",IDC_ASSIGN,109,259,50,14\r\n    COMBOBOX        IDC_COMBO_ALL_ASSIGNED,8,158,253,99,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"Remove\",IDC_BUTTON_REMOVE,265,157,50,14\r\n    PUSHBUTTON      \"Add\",IDC_BUTTON_ADD,318,157,50,14\r\n    LTEXT           \"Shortcuts for selected command:\",IDC_STATIC_SHORTCUTS,8,147,106,8\r\n    GROUPBOX        \"First Keypress\",IDC_STATIC_FIRST_KEYPRESS,7,192,151,63\r\n    GROUPBOX        \"Second Keypress\",IDC_STATIC_SECOND_PRESS,172,193,169,62\r\n    COMBOBOX        IDC_MOUSE_1,25,220,68,49,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    COMBOBOX        IDC_MOUSE_2,195,218,68,49,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"Reset\",IDC_BUTTON_RESET,318,7,50,14\r\nEND\r\n\r\nIDD_DIALOG_FREIND_PROMPT DIALOGEX 0, 0, 237, 91\r\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\r\nCAPTION \"Send to Friend\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_EDIT_NAME,66,7,164,14,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_DESC,66,24,164,14,ES_AUTOHSCROLL\r\n    DEFPUSHBUTTON   \"OK\",IDOK,125,42,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,180,42,50,14\r\n    CONTROL         \"Add to \"\"Send To\"\" menu\",IDC_CHECK_SAVE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,7,44,96,10\r\n    PUSHBUTTON      \"Clear Custom Send List\",IDC_BUTTON_CLEAR,7,70,87,14,NOT WS_TABSTOP\r\n    LTEXT           \"IP or Host Name\",IDC_STATIC_FRIEND_PROMPT,7,7,53,14,SS_CENTERIMAGE\r\n    LTEXT           \"Description\",IDC_STATIC_FRIEND_DESC,7,24,53,14,SS_CENTERIMAGE\r\nEND\r\n\r\nIDD_ADV_OPTIONS DIALOGEX 0, 0, 262, 268\r\nSTYLE DS_SETFONT | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\r\nCAPTION \"Advanced Options\"\r\nFONT 10, \"Segoe UI\", 400, 0, 0x0\r\nBEGIN\r\n    DEFPUSHBUTTON   \"OK\",IDOK,147,250,50,11\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,205,249,50,12\r\n    CONTROL         \"\",IDC_MFCPROPERTYGRID1,\"MfcPropertyGrid\",0x100,7,7,248,212\r\n    PUSHBUTTON      \"Compact and Repair Database\",IDC_BT_COMPACT_AND_REPAIR,7,251,108,11\r\n    PUSHBUTTON      \"On Copy Scripts\",IDC_BUTTON_COPY_SCRIPTS,7,224,108,11\r\n    PUSHBUTTON      \"On Paste Scripts\",IDC_BUTTON_PASTE_SCRIPTS,7,237,108,11\r\nEND\r\n\r\nIDD_SCRIPT_EDITOR DIALOGEX 0, 0, 435, 324\r\nSTYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\r\nCAPTION \"Scripts\"\r\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\r\nBEGIN\r\n    EDITTEXT        IDC_EDIT_NAME,142,7,284,14,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_DESC,142,24,284,14,ES_AUTOHSCROLL\r\n    CONTROL         \"\",IDC_CHECK_ACTIVE,\"Button\",BS_AUTOCHECKBOX | WS_TABSTOP,142,42,16,10\r\n    EDITTEXT        IDC_EDIT_INPUT,100,195,265,50,ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_WANTRETURN | WS_VSCROLL | WS_HSCROLL\r\n    EDITTEXT        IDC_EDIT_OUTPUT,100,259,326,40,ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_WANTRETURN | WS_VSCROLL | WS_HSCROLL\r\n    PUSHBUTTON      \"Run\",IDC_BUTTON_RUN,371,231,55,14\r\n    DEFPUSHBUTTON   \"OK\",IDOK,321,303,50,14\r\n    PUSHBUTTON      \"Cancel\",IDCANCEL,376,303,50,14\r\n    LISTBOX         IDC_LIST_SCRIPTS,7,7,83,281,LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP\r\n    PUSHBUTTON      \"Add\",IDC_BUTTON_ADD_SCRIPT,7,303,32,14\r\n    PUSHBUTTON      \"Delete\",IDC_BUTTON_DELETE_SCRIPT,58,303,32,14\r\n    LTEXT           \"Name\",IDC_STATIC_NAME,100,7,19,14,SS_CENTERIMAGE\r\n    LTEXT           \"Desciption\",IDC_STATIC_DESC,100,24,34,14,SS_CENTERIMAGE\r\n    LTEXT           \"Sample Input\",IDC_STATIC_INPUT,100,185,43,8\r\n    LTEXT           \"Sample Output\",IDC_STATIC_OUTPUT,100,248,48,8\r\n    LTEXT           \"All function must return true/false.  Return true to cancel saving the copy or cancel the paste.\",IDC_STATIC_RETURN_DESC,100,174,326,8\r\n    LTEXT           \"Script\",IDC_STATIC_SCRIPT,100,56,30,10\r\n    LTEXT           \"Active\",IDC_STATIC_ACTIVE,100,42,21,14\r\n    CONTROL         \"ChaiScript (http://chaiscript.com/)\",IDC_MFCLINK_CHAISCRIPT,\r\n                    \"MfcLink\",WS_TABSTOP,142,54,119,10\r\n    CONTROL         \"Examples\",IDC_MFCLINK2_EXAMPLES,\"MfcLink\",WS_TABSTOP,294,54,60,10\r\n    CONTROL         \"\",IDC_RICHEDIT21,\"RichEdit20W\",WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP | 0x10c4,100,66,326,105\r\n    EDITTEXT        IDC_EDIT_ACTIVE_APP,371,196,55,14,ES_AUTOHSCROLL\r\n    EDITTEXT        IDC_EDIT_ACTIVE_APP_TITLE,371,213,55,14,ES_AUTOHSCROLL\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Version\r\n//\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\n FILEVERSION 3,24,238,2\r\n PRODUCTVERSION 3,24,238,2\r\n FILEFLAGSMASK 0x3fL\r\n#ifdef _DEBUG\r\n FILEFLAGS 0x1L\r\n#else\r\n FILEFLAGS 0x0L\r\n#endif\r\n FILEOS 0x4L\r\n FILETYPE 0x1L\r\n FILESUBTYPE 0x0L\r\nBEGIN\r\n    BLOCK \"StringFileInfo\"\r\n    BEGIN\r\n        BLOCK \"040904b0\"\r\n        BEGIN\r\n            VALUE \"FileDescription\", \"Ditto\"\r\n            VALUE \"FileVersion\", \"3.24.238.2\"\r\n            VALUE \"InternalName\", \"CP_Main\"\r\n            VALUE \"LegalCopyright\", \"Copyright (C) 2003\"\r\n            VALUE \"OriginalFilename\", \"Ditto\"\r\n            VALUE \"ProductName\", \"Ditto\"\r\n            VALUE \"ProductVersion\", \"3.24.238.2\"\r\n        END\r\n    END\r\n    BLOCK \"VarFileInfo\"\r\n    BEGIN\r\n        VALUE \"Translation\", 0x409, 1200\r\n    END\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// DESIGNINFO\r\n//\r\n\r\n#ifdef APSTUDIO_INVOKED\r\nGUIDELINES DESIGNINFO\r\nBEGIN\r\n    IDD_ABOUTBOX, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 228\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 48\r\n    END\r\n\r\n    IDD_OPTIONS_UTILITIES, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 234\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 130\r\n    END\r\n\r\n    IDD_OPTIONS_TYPES, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 278\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 268\r\n    END\r\n\r\n    IDD_OPTIONS_QUICK_PASTE, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 360\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 272\r\n    END\r\n\r\n    IDD_OPTIONS_KEYSTROKES, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 366\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 270\r\n    END\r\n\r\n    IDD_OPTIONS_GENERAL, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 368\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 270\r\n    END\r\n\r\n    IDD_SELECT_DB, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 269\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 39\r\n    END\r\n\r\n    IDD_OPTIONS_STATS, DIALOG\r\n    BEGIN\r\n    END\r\n\r\n    IDD_ADD_TYPE, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 212\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 315\r\n    END\r\n\r\n    IDD_COPY_PROPERTIES, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 286\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 282\r\n    END\r\n\r\n    IDD_ABOUT, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 330\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 199\r\n    END\r\n\r\n    IDD_GROUP_NAME, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 179\r\n        TOPMARGIN, 1\r\n        BOTTOMMARGIN, 42\r\n    END\r\n\r\n    IDD_OPTIONS_FRIENDS, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 360\r\n        TOPMARGIN, 4\r\n        BOTTOMMARGIN, 272\r\n    END\r\n\r\n    IDD_FRIEND_DETAILS, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 196\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 72\r\n    END\r\n\r\n    IDD_MOVE_TO_GROUP, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 247\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 170\r\n    END\r\n\r\n    IDD_DIALOG_REMOTE_FILE, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 277\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 103\r\n    END\r\n\r\n    IDD_OPTIONS_COPY_BUFFERS, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 372\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 270\r\n    END\r\n\r\n    IDD_GLOBAL_CLIPS, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 362\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 192\r\n    END\r\n\r\n    IDD_DELETE_CLIP_DATA, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 668\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 308\r\n    END\r\n\r\n    IDD_OPTIONS_QUICK_PASTE_KEYBOARD, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 368\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 271\r\n    END\r\n\r\n    IDD_DIALOG_FREIND_PROMPT, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 230\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 84\r\n    END\r\n\r\n    IDD_ADV_OPTIONS, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 255\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 261\r\n    END\r\n\r\n    IDD_SCRIPT_EDITOR, DIALOG\r\n    BEGIN\r\n        LEFTMARGIN, 7\r\n        RIGHTMARGIN, 426\r\n        TOPMARGIN, 7\r\n        BOTTOMMARGIN, 317\r\n    END\r\nEND\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// AVI\r\n//\r\n\r\nIDR_FILE_COPY           AVI                     \"res\\\\FILECOPY.AVI\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// PNG\r\n//\r\n\r\nIDB_OPEN_FOLDER_PNG     PNG                     \"res\\\\folder_open.png\"\r\n\r\nIDB_COG_16_16           PNG                     \"res\\\\cog_16_16.png\"\r\n\r\nIDB_OPEN_FOLDER_16_16   PNG                     \"res\\\\opened_folder_16_16.png\"\r\n\r\nIDB_OPEN_FOLDER_20_20   PNG                     \"res\\\\opened_folder_20_20.png\"\r\n\r\nIDB_OPEN_FOLDER_24_24   PNG                     \"res\\\\opened_folder_24_24.png\"\r\n\r\nIDB_OPEN_FOLDER_32_32   PNG                     \"res\\\\opened_folder_32_32.png\"\r\n\r\nIDB_COG_20_20           PNG                     \"res\\\\cog_20_20.png\"\r\n\r\nIDB_COG_24_24           PNG                     \"res\\\\cog_24_24.png\"\r\n\r\nIDB_COG_32_32           PNG                     \"res\\\\cog_32_32.png\"\r\n\r\nIDB_LEFT_ARROW_16_16    PNG                     \"res\\\\left_arrow_16_16.png\"\r\n\r\nIDB_LEFT_ARROW_20_20    PNG                     \"res\\\\left_arrow_20_20.png\"\r\n\r\nIDB_LEFT_ARROW_24_24    PNG                     \"res\\\\left_arrow_24_24.png\"\r\n\r\nIDB_LEFT_ARROW_32_32    PNG                     \"res\\\\left_arrow_32_32.png\"\r\n\r\nIDB_CLOSE_8_8           PNG                     \"res\\\\close_8_8.png\"\r\n\r\nIDB_CLOSE_10_10         PNG                     \"res\\\\close_10_10.png\"\r\n\r\nIDB_CLOSE_12_13         PNG                     \"res\\\\close_12_12.png\"\r\n\r\nIDB_CLOSE_16_16         PNG                     \"res\\\\close_16_16.png\"\r\n\r\nIDB_CHEVRON_RIGHT_8_8   PNG                     \"res\\\\chevron_right_8_8.png\"\r\n\r\nIDB_CHEVRON_RIGHT_10_10 PNG                     \"res\\\\chevron_right_10_10.png\"\r\n\r\nIDB_CHEVRON_RIGHT_12_12 PNG                     \"res\\\\chevron_right_12_12.png\"\r\n\r\nIDB_CHEVRON_RIGHT_16_16 PNG                     \"res\\\\chevron_right_16_16.png\"\r\n\r\nIDB_CHEVRON_LEFT_8_8    PNG                     \"res\\\\chevron_left_8_8.png\"\r\n\r\nIDB_CHEVRON_LEFT_10_10  PNG                     \"res\\\\chevron_left_10_10.png\"\r\n\r\nIDB_CHEVRON_LEFT_12_12  PNG                     \"res\\\\chevron_left_12_12.png\"\r\n\r\nIDB_CHEVRON_LEFT_16_16  PNG                     \"res\\\\chevron_left_16_16.png\"\r\n\r\nIDB_CHEVRON_TOP_8_8     PNG                     \"res\\\\chevron_top_8_8.png\"\r\n\r\nIDB_CHEVRON_TOP_10_10   PNG                     \"res\\\\chevron_top_10_10.png\"\r\n\r\nIDB_CHEVRON_TOP_12_12   PNG                     \"res\\\\chevron_top_12_12.png\"\r\n\r\nIDB_CHEVRON_TOP_16_16   PNG                     \"res\\\\chevron_top_16_16.png\"\r\n\r\nIDB_CHEVRON_BOTTOM_8_8  PNG                     \"res\\\\chevron_bottom_8_8.png\"\r\n\r\nIDB_CHEVRON_BOTTOM_10_10 PNG                     \"res\\\\chevron_bottom_10_10.png\"\r\n\r\nIDB_CHEVRON_BOTTOM_12_12 PNG                     \"res\\\\chevron_bottom_12_12.png\"\r\n\r\nIDB_CHEVRON_BOTTOM_16_16 PNG                     \"res\\\\chevron_bottom_16_16.png\"\r\n\r\nIDB_MAXIMIZE_8_8        PNG                     \"res\\\\maximize_8_8.png\"\r\n\r\nIDB_MAXIMIZE_10_10      PNG                     \"res\\\\maximize_10_10.png\"\r\n\r\nIDB_MAXIMIZE_12_12      PNG                     \"res\\\\maximize_12_12.png\"\r\n\r\nIDB_MAXIMIZE_16_16      PNG                     \"res\\\\maximize_16_16.png\"\r\n\r\nIDB_YELLOW_STAR_32_32   PNG                     \"res\\\\yellow_star_32_32.png\"\r\n\r\nIDB_YELLOW_STAR_24_24   PNG                     \"res\\\\yellow_star_24_24.png\"\r\n\r\nIDB_YELLOW_STAR_20_20   PNG                     \"res\\\\yellow_star_20_20.png\"\r\n\r\nIDB_YELLOW_STAR_16_16   PNG                     \"res\\\\yellow_star_16_16.png\"\r\n\r\nIDB_IN_FOLDER_32_32     PNG                     \"res\\\\in_folder_32_32.png\"\r\n\r\nIDB_IN_FOLDER_24_24     PNG                     \"res\\\\in_folder_24_24.png\"\r\n\r\nIDB_IN_FOLDER_20_20     PNG                     \"res\\\\in_folder_20_20.png\"\r\n\r\nIDB_IN_FOLDER_16_16     PNG                     \"res\\\\in_folder_16_16.png\"\r\n\r\nIDB_KEY_32_32           PNG                     \"res\\\\key_stroke_32_32.png\"\r\n\r\nIDB_KEY_24_24           PNG                     \"res\\\\key_stroke_24_24.png\"\r\n\r\nIDB_KEY_20_20           PNG                     \"res\\\\key_stroke_20_20.png\"\r\n\r\nIDB_KEY_16_16           PNG                     \"res\\\\key_stroke_16_16.png\"\r\n\r\nIDB_STICKY_32_32        PNG                     \"res\\\\Sticky_32_32.png\"\r\n\r\nIDB_STICKY_24_24        PNG                     \"res\\\\Sticky_24_24.png\"\r\n\r\nIDB_STICKY_20_20        PNG                     \"res\\\\Sticky_20_20.png\"\r\n\r\nIDB_STICKY_16_16        PNG                     \"res\\\\Sticky_16_16.png\"\r\n\r\nIDB_SYSTEM_MENU_16_16   PNG                     \"res\\\\system_menu_16_16.png\"\r\n\r\nIDB_SYSTEM_MENU_20_20   PNG                     \"res\\\\system_menu_20_20.png\"\r\n\r\nIDB_SYSTEM_MENU_24_24   PNG                     \"res\\\\system_menu_24_24.png\"\r\n\r\nIDB_SYSTEM_MENU_32_32   PNG                     \"res\\\\system_menu_32_32.png\"\r\n\r\nChevronRight_Black_16_16 PNG                     \"res\\\\ChevronRight_Black_16_16.png\"\r\n\r\nChevronRight_Black_20_20 PNG                     \"res\\\\ChevronRight_Black_20_20.png\"\r\n\r\nChevronRight_Black_24_24 PNG                     \"res\\\\ChevronRight_Black_24_24.png\"\r\n\r\nChevronRight_Black_32_32 PNG                     \"res\\\\ChevronRight_Black_32_32.png\"\r\n\r\nClose_Black_16_16       PNG                     \"res\\\\Close_Black_16_16.png\"\r\n\r\nClose_Black_20_20       PNG                     \"res\\\\Close_Black_20_20.png\"\r\n\r\nClose_Black_24_24       PNG                     \"res\\\\Close_Black_24_24.png\"\r\n\r\nClose_Black_32_32       PNG                     \"res\\\\Close_Black_32_32.png\"\r\n\r\nNewWindowIcon_24_14     PNG                     \"res\\\\NewWindowIcon_24_14.png\"\r\n\r\nsystem_menu_2_48        PNG                     \"res\\\\system_menu_2_48.png\"\r\n\r\nsystem_menu_2_36        PNG                     \"res\\\\system_menu_2_36.png\"\r\n\r\nsystem_menu_2_30        PNG                     \"res\\\\system_menu_2_30.png\"\r\n\r\nsystem_menu_2_24        PNG                     \"res\\\\system_menu_2_24.png\"\r\n\r\nopen_folder_48          PNG                     \"res\\\\open_folder_48.png\"\r\n\r\nopen_folder_36          PNG                     \"res\\\\open_folder_36.png\"\r\n\r\nopen_folder_30          PNG                     \"res\\\\open_folder_30.png\"\r\n\r\nopen_folder_24          PNG                     \"res\\\\open_folder_24.png\"\r\n\r\nChevronLeft_Black_16_16 PNG                     \"res\\\\ChevronLeft_Black_16_16.png\"\r\n\r\nChevronLeft_Black_20_20 PNG                     \"res\\\\ChevronLeft_Black_20_20.png\"\r\n\r\nChevronLeft_Black_24_24 PNG                     \"res\\\\ChevronLeft_Black_24_24.png\"\r\n\r\nChevronLeft_Black_32_32 PNG                     \"res\\\\ChevronLeft_Black_32_32.png\"\r\n\r\nNewWindowIcon_48        PNG                     \"res\\\\NewWindowIcon_48.png\"\r\n\r\nNewWindowIcon_36        PNG                     \"res\\\\NewWindowIcon_36.png\"\r\n\r\nNewWindowIcon_30        PNG                     \"res\\\\NewWindowIcon_30.png\"\r\n\r\nreturn_16               PNG                     \"res\\\\return_16.png\"\r\n\r\nreturn_20               PNG                     \"res\\\\return_20.png\"\r\n\r\nreturn_24               PNG                     \"res\\\\return_24.png\"\r\n\r\nreturn_32               PNG                     \"res\\\\return_32.png\"\r\n\r\nSearch_16               PNG                     \"res\\\\Search_16.png\"\r\n\r\nSearch_20               PNG                     \"res\\\\Search_20.png\"\r\n\r\nSearch_24               PNG                     \"res\\\\Search_24.png\"\r\n\r\nSearch_32               PNG                     \"res\\\\Search_32.png\"\r\n\r\nsearch_close_16         PNG                     \"res\\\\search_close_16.png\"\r\n\r\nminimize_16             PNG                     \"res\\\\minimize_16.png\"\r\n\r\nminimize_32             PNG                     \"res\\\\minimize_32.png\"\r\n\r\nminimize_24             PNG                     \"res\\\\minimize_24.png\"\r\n\r\nminimize_20             PNG                     \"res\\\\minimize_20.png\"\r\n\r\nmaximize_32             PNG                     \"res\\\\maximize_32.png\"\r\n\r\nmaximize_24             PNG                     \"res\\\\maximize_24.png\"\r\n\r\nmaximize_20             PNG                     \"res\\\\maximize_20.png\"\r\n\r\nreturn_28               PNG                     \"res\\\\return_28.png\"\r\n\r\nminimize_28             PNG                     \"res\\\\minimize_28.png\"\r\n\r\nmaximize_28             PNG                     \"res\\\\maximize_28.png\"\r\n\r\nChevronLeft_Black_28    PNG                     \"res\\\\ChevronLeft_Black_28.png\"\r\n\r\nChevronRight_Black_28   PNG                     \"res\\\\ChevronRight_Black_28.png\"\r\n\r\nClose_Black_28          PNG                     \"res\\\\Close_Black_28.png\"\r\n\r\nsystem_menu_2_42        PNG                     \"res\\\\system_menu_2_42.png\"\r\n\r\nopen_folder_42          PNG                     \"res\\\\open_folder_42.png\"\r\n\r\ncog_28                  PNG                     \"res\\\\cog_28.png\"\r\n\r\nSearch_28               PNG                     \"res\\\\Search_28.png\"\r\n\r\ndown_16                 PNG                     \"res\\\\down_16.png\"\r\n\r\ndown_20                 PNG                     \"res\\\\down_20.png\"\r\n\r\ndown_24                 PNG                     \"res\\\\down_24.png\"\r\n\r\ndown_28                 PNG                     \"res\\\\down_28.png\"\r\n\r\ndown_32                 PNG                     \"res\\\\down_32.png\"\r\n\r\nclose_36                PNG                     \"res\\\\close_36.png\"\r\n\r\nclose_40                PNG                     \"res\\\\close_40.png\"\r\n\r\nclose_44                PNG                     \"res\\\\close_44.png\"\r\n\r\nclose_48                PNG                     \"res\\\\close_48.png\"\r\n\r\nclose_52                PNG                     \"res\\\\close_52.png\"\r\n\r\nclose_56                PNG                     \"res\\\\close_56.png\"\r\n\r\nopen_folder_54          PNG                     \"res\\\\open_folder_54.png\"\r\n\r\nopen_folder_60          PNG                     \"res\\\\open_folder_60.png\"\r\n\r\nopen_folder_66          PNG                     \"res\\\\open_folder_66.png\"\r\n\r\nopen_folder_72          PNG                     \"res\\\\open_folder_72.png\"\r\n\r\nopen_folder_78          PNG                     \"res\\\\open_folder_78.png\"\r\n\r\nopen_folder_84          PNG                     \"res\\\\open_folder_84.png\"\r\n\r\nsystem_menu_54          PNG                     \"res\\\\system_menu_54.png\"\r\n\r\nsystem_menu_60          PNG                     \"res\\\\system_menu_60.png\"\r\n\r\nsystem_menu_66          PNG                     \"res\\\\system_menu_66.png\"\r\n\r\nsystem_menu_72          PNG                     \"res\\\\system_menu_72.png\"\r\n\r\nsystem_menu_78          PNG                     \"res\\\\system_menu_78.png\"\r\n\r\nsystem_menu_84          PNG                     \"res\\\\system_menu_84.png\"\r\n\r\nChevronLeft_Black_36    PNG                     \"res\\\\ChevronLeft_Black_36.png\"\r\n\r\nChevronLeft_Black_40    PNG                     \"res\\\\ChevronLeft_Black_40.png\"\r\n\r\nChevronLeft_Black_44    PNG                     \"res\\\\ChevronLeft_Black_44.png\"\r\n\r\nChevronLeft_Black_48    PNG                     \"res\\\\ChevronLeft_Black_48.png\"\r\n\r\nChevronLeft_Black_52    PNG                     \"res\\\\ChevronLeft_Black_52.png\"\r\n\r\nChevronLeft_Black_56    PNG                     \"res\\\\ChevronLeft_Black_56.png\"\r\n\r\nChevronRight_Black_36   PNG                     \"res\\\\ChevronRight_Black_36.png\"\r\n\r\nChevronRight_Black_40   PNG                     \"res\\\\ChevronRight_Black_40.png\"\r\n\r\nChevronRight_Black_44   PNG                     \"res\\\\ChevronRight_Black_44.png\"\r\n\r\nChevronRight_Black_48   PNG                     \"res\\\\ChevronRight_Black_48.png\"\r\n\r\nChevronRight_Black_52   PNG                     \"res\\\\ChevronRight_Black_52.png\"\r\n\r\nChevronRight_Black_56   PNG                     \"res\\\\ChevronRight_Black_56.png\"\r\n\r\nmaximize_36             PNG                     \"res\\\\maximize_36.png\"\r\n\r\nmaximize_40             PNG                     \"res\\\\maximize_40.png\"\r\n\r\nmaximize_44             PNG                     \"res\\\\maximize_44.png\"\r\n\r\nmaximize_48             PNG                     \"res\\\\maximize_48.png\"\r\n\r\nmaximize_52             PNG                     \"res\\\\maximize_52.png\"\r\n\r\nmaximize_56             PNG                     \"res\\\\maximize_56.png\"\r\n\r\nminimize_36             PNG                     \"res\\\\minimize_36.png\"\r\n\r\nminimize_40             PNG                     \"res\\\\minimize_40.png\"\r\n\r\nminimize_44             PNG                     \"res\\\\minimize_44.png\"\r\n\r\nminimize_48             PNG                     \"res\\\\minimize_48.png\"\r\n\r\nminimize_52             PNG                     \"res\\\\minimize_52.png\"\r\n\r\nminimize_56             PNG                     \"res\\\\minimize_56.png\"\r\n\r\nsearch_close_20         PNG                     \"res\\\\search_close_20.png\"\r\n\r\nsearch_close_24         PNG                     \"res\\\\search_close_24.png\"\r\n\r\nsearch_close_28         PNG                     \"res\\\\search_close_28.png\"\r\n\r\nsearch_close_32         PNG                     \"res\\\\search_close_32.png\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// AFX_DIALOG_LAYOUT\r\n//\r\n\r\nIDD_OPTIONS_QUICK_PASTE_KEYBOARD AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_QUICK_PASTE AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_ADD_TYPE AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_TYPES AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_STATS AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_KEYSTROKES AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_DIALOG_FREIND_PROMPT AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_GENERAL AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_ADV_OPTIONS AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_FRIENDS AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_SCRIPT_EDITOR AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_COPY_PROPERTIES AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_COPY_BUFFERS AFX_DIALOG_LAYOUT\r\nBEGIN\r\n    0\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// REGISTRY\r\n//\r\n\r\nIDR_CP_MAIN             REGISTRY                \"CP_Main.rgs\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Dialog Info\r\n//\r\n\r\nIDD_ADV_OPTIONS DLGINIT\r\nBEGIN\r\n    IDC_MFCPROPERTYGRID1, 0x37c, 413, 0\r\n0x4d3c, 0x4346, 0x7250, 0x706f, 0x7265, 0x7974, 0x7247, 0x6469, 0x485f, \r\n0x6165, 0x6564, 0x4372, 0x7274, 0x3e6c, 0x5254, 0x4555, 0x2f3c, 0x464d, \r\n0x5043, 0x6f72, 0x6570, 0x7472, 0x4779, 0x6972, 0x5f64, 0x6548, 0x6461, \r\n0x7265, 0x7443, 0x6c72, 0x3c3e, 0x464d, 0x5043, 0x6f72, 0x6570, 0x7472, \r\n0x4779, 0x6972, 0x5f64, 0x6544, 0x6373, 0x6972, 0x7470, 0x6f69, 0x416e, \r\n0x6572, 0x3e61, 0x5254, 0x4555, 0x2f3c, 0x464d, 0x5043, 0x6f72, 0x6570, \r\n0x7472, 0x4779, 0x6972, 0x5f64, 0x6544, 0x6373, 0x6972, 0x7470, 0x6f69, \r\n0x416e, 0x6572, 0x3e61, 0x4d3c, 0x4346, 0x7250, 0x706f, 0x7265, 0x7974, \r\n0x7247, 0x6469, 0x415f, 0x706c, 0x6168, 0x6562, 0x6974, 0x4d63, 0x646f, \r\n0x3e65, 0x4146, 0x534c, 0x3c45, 0x4d2f, 0x4346, 0x7250, 0x706f, 0x7265, \r\n0x7974, 0x7247, 0x6469, 0x415f, 0x706c, 0x6168, 0x6562, 0x6974, 0x4d63, \r\n0x646f, 0x3e65, 0x4d3c, 0x4346, 0x7250, 0x706f, 0x7265, 0x7974, 0x7247, \r\n0x6469, 0x4d5f, 0x646f, 0x6669, 0x6569, 0x5064, 0x6f72, 0x6570, 0x7472, \r\n0x6569, 0x3e73, 0x4146, 0x534c, 0x3c45, 0x4d2f, 0x4346, 0x7250, 0x706f, \r\n0x7265, 0x7974, 0x7247, 0x6469, 0x4d5f, 0x646f, 0x6669, 0x6569, 0x5064, \r\n0x6f72, 0x6570, 0x7472, 0x6569, 0x3e73, 0x4d3c, 0x4346, 0x7250, 0x706f, \r\n0x7265, 0x7974, 0x7247, 0x6469, 0x565f, 0x4453, 0x746f, 0x654e, 0x4c74, \r\n0x6f6f, 0x3e6b, 0x5254, 0x4555, 0x2f3c, 0x464d, 0x5043, 0x6f72, 0x6570, \r\n0x7472, 0x4779, 0x6972, 0x5f64, 0x5356, 0x6f44, 0x4e74, 0x7465, 0x6f4c, \r\n0x6b6f, 0x3c3e, 0x464d, 0x5043, 0x6f72, 0x6570, 0x7472, 0x4779, 0x6972, \r\n0x5f64, 0x6544, 0x6373, 0x6972, 0x7470, 0x6f69, 0x526e, 0x776f, 0x3e73, \r\n0x3c33, 0x4d2f, 0x4346, 0x7250, 0x706f, 0x7265, 0x7974, 0x7247, 0x6469, \r\n0x445f, 0x7365, 0x7263, 0x7069, 0x6974, 0x6e6f, 0x6f52, 0x7377, \"\\076\" \r\n    0\r\nEND\r\n\r\nIDD_SCRIPT_EDITOR DLGINIT\r\nBEGIN\r\n    IDC_MFCLINK_CHAISCRIPT, 0x37c, 179, 0\r\n0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x683e, 0x7474, 0x3a70, \r\n0x2f2f, 0x6863, 0x6961, 0x6373, 0x6972, 0x7470, 0x632e, 0x6d6f, 0x3c2f, \r\n0x4d2f, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x3c3e, 0x464d, 0x4c43, \r\n0x6e69, 0x5f6b, 0x7255, 0x506c, 0x6572, 0x6966, 0x3e78, 0x2f3c, 0x464d, \r\n0x4c43, 0x6e69, 0x5f6b, 0x7255, 0x506c, 0x6572, 0x6966, 0x3e78, 0x4d3c, \r\n0x4346, 0x694c, 0x6b6e, 0x545f, 0x6f6f, 0x746c, 0x7069, 0x3c3e, 0x4d2f, \r\n0x4346, 0x694c, 0x6b6e, 0x545f, 0x6f6f, 0x746c, 0x7069, 0x3c3e, 0x464d, \r\n0x4c43, 0x6e69, 0x5f6b, 0x7546, 0x6c6c, 0x6554, 0x7478, 0x6f54, 0x6c6f, \r\n0x6974, 0x3e70, 0x4146, 0x534c, 0x3c45, 0x4d2f, 0x4346, 0x694c, 0x6b6e, \r\n0x465f, 0x6c75, 0x546c, 0x7865, 0x5474, 0x6f6f, 0x746c, 0x7069, \"\\076\" \r\n    IDC_MFCLINK2_EXAMPLES, 0x37c, 206, 0\r\n0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x683e, 0x7474, 0x7370, \r\n0x2f3a, 0x672f, 0x7469, 0x7568, 0x2e62, 0x6f63, 0x2f6d, 0x6173, 0x7262, \r\n0x676f, 0x6564, 0x2f6e, 0x6944, 0x7474, 0x2f6f, 0x6977, 0x696b, 0x532f, \r\n0x7263, 0x7069, 0x6974, 0x676e, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, \r\n0x7255, 0x3e6c, 0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x7250, \r\n0x6665, 0x7869, 0x3c3e, 0x4d2f, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, \r\n0x7250, 0x6665, 0x7869, 0x3c3e, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, \r\n0x6c6f, 0x6974, 0x3e70, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, \r\n0x6c6f, 0x6974, 0x3e70, 0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x465f, 0x6c75, \r\n0x546c, 0x7865, 0x5474, 0x6f6f, 0x746c, 0x7069, 0x463e, 0x4c41, 0x4553, \r\n0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x7546, 0x6c6c, 0x6554, 0x7478, \r\n0x6f54, 0x6c6f, 0x6974, 0x3e70, \r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_GENERAL DLGINIT\r\nBEGIN\r\n    IDC_MFCLINK_ENV_VAR, 0x37c, 255, 0\r\n0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x683e, 0x7474, 0x7370, \r\n0x2f3a, 0x732f, 0x756f, 0x6372, 0x6665, 0x726f, 0x6567, 0x6e2e, 0x7465, \r\n0x702f, 0x642f, 0x7469, 0x6f74, 0x632d, 0x2f70, 0x6977, 0x696b, 0x452f, \r\n0x766e, 0x7269, 0x6e6f, 0x656d, 0x746e, 0x6156, 0x6972, 0x6261, 0x656c, \r\n0x2f73, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x7255, 0x3e6c, 0x4d3c, \r\n0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x7250, 0x6665, 0x7869, 0x3c3e, \r\n0x4d2f, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x7250, 0x6665, 0x7869, \r\n0x3c3e, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, 0x6c6f, 0x6974, 0x3e70, \r\n0x6e45, 0x6976, 0x6f72, 0x6d6e, 0x6e65, 0x2074, 0x6176, 0x6972, 0x6261, \r\n0x656c, 0x2073, 0x6e69, 0x6420, 0x7461, 0x6261, 0x7361, 0x2065, 0x6170, \r\n0x6874, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, 0x6c6f, 0x6974, \r\n0x3e70, 0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x465f, 0x6c75, 0x546c, 0x7865, \r\n0x5474, 0x6f6f, 0x746c, 0x7069, 0x543e, 0x5552, 0x3c45, 0x4d2f, 0x4346, \r\n0x694c, 0x6b6e, 0x465f, 0x6c75, 0x546c, 0x7865, 0x5474, 0x6f6f, 0x746c, \r\n0x7069, \"\\076\" \r\n    IDC_MFCLINK2, 0x37c, 206, 0\r\n0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x683e, 0x7474, 0x7370, \r\n0x2f3a, 0x642f, 0x7469, 0x6f74, 0x632d, 0x2e70, 0x6f73, 0x7275, 0x6563, \r\n0x6f66, 0x6772, 0x2e65, 0x6f69, 0x502f, 0x6972, 0x6176, 0x7963, 0x6f50, \r\n0x696c, 0x7963, 0x702e, 0x7068, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, \r\n0x7255, 0x3e6c, 0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x7250, \r\n0x6665, 0x7869, 0x3c3e, 0x4d2f, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, \r\n0x7250, 0x6665, 0x7869, 0x3c3e, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, \r\n0x6c6f, 0x6974, 0x3e70, 0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x6f54, \r\n0x6c6f, 0x6974, 0x3e70, 0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x465f, 0x6c75, \r\n0x546c, 0x7865, 0x5474, 0x6f6f, 0x746c, 0x7069, 0x463e, 0x4c41, 0x4553, \r\n0x2f3c, 0x464d, 0x4c43, 0x6e69, 0x5f6b, 0x7546, 0x6c6c, 0x6554, 0x7478, \r\n0x6f54, 0x6c6f, 0x6974, 0x3e70, \r\n    0\r\nEND\r\n\r\nIDD_OPTIONS_KEYSTROKES DLGINIT\r\nBEGIN\r\n    IDC_STATIC_CUSTOM_KEYS, 0x37c, 157, 0\r\n0x4d3c, 0x4346, 0x694c, 0x6b6e, 0x555f, 0x6c72, 0x3c3e, 0x4d2f, 0x4346, \r\n0x694c, 0x6b6e, 0x555f, 0x6c72, 0x3c3e, 0x464d, 0x4c43, 0x6e69, 0x5f6b, \r\n0x7255, 0x506c, 0x6572, 0x6966, 0x3e78, 0x2f3c, 0x464d, 0x4c43, 0x6e69, \r\n0x5f6b, 0x7255, 0x506c, 0x6572, 0x6966, 0x3e78, 0x4d3c, 0x4346, 0x694c, \r\n0x6b6e, 0x545f, 0x6f6f, 0x746c, 0x7069, 0x3c3e, 0x4d2f, 0x4346, 0x694c, \r\n0x6b6e, 0x545f, 0x6f6f, 0x746c, 0x7069, 0x3c3e, 0x464d, 0x4c43, 0x6e69, \r\n0x5f6b, 0x7546, 0x6c6c, 0x6554, 0x7478, 0x6f54, 0x6c6f, 0x6974, 0x3e70, \r\n0x4146, 0x534c, 0x3c45, 0x4d2f, 0x4346, 0x694c, 0x6b6e, 0x465f, 0x6c75, \r\n0x546c, 0x7865, 0x5474, 0x6f6f, 0x746c, 0x7069, \"\\076\" \r\n    0\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Cursor\r\n//\r\n\r\nIDC_CURSOR_ZOOM_IN      CURSOR                  \"res\\\\cursor_zoom_in.cur\"\r\n\r\nIDC_CURSOR_ZOOM_OUT     CURSOR                  \"res\\\\cursor2.cur\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// String Table\r\n//\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    IDR_MAINFRAME           \"CP_Main\\n\\nCP_Mai\\n\\n\\nCPMain.Document\\nCP_Mai Document\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    AFX_IDS_APP_TITLE       \"CP_Main\"\r\n    AFX_IDS_IDLEMESSAGE     \"Ready\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_INDICATOR_EXT        \"EXT\"\r\n    ID_INDICATOR_CAPS       \"CAP\"\r\n    ID_INDICATOR_NUM        \"NUM\"\r\n    ID_INDICATOR_SCRL       \"SCRL\"\r\n    ID_INDICATOR_OVR        \"OVR\"\r\n    ID_INDICATOR_REC        \"REC\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_FILE_NEW             \"Create a new document\\nNew\"\r\n    ID_FILE_OPEN            \"Open an existing document\\nOpen\"\r\n    ID_FILE_CLOSE           \"Close the active document\\nClose\"\r\n    ID_FILE_SAVE            \"Save the active document\\nSave\"\r\n    ID_FILE_SAVE_AS         \"Save the active document with a new name\\nSave As\"\r\n    ID_FILE_PAGE_SETUP      \"Change the printing options\\nPage Setup\"\r\n    ID_FILE_PRINT_SETUP     \"Change the printer and printing options\\nPrint Setup\"\r\n    ID_FILE_PRINT           \"Print the active document\\nPrint\"\r\n    ID_FILE_PRINT_PREVIEW   \"Display full pages\\nPrint Preview\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_APP_ABOUT            \"Display program information, version number and copyright\\nAbout\"\r\n    ID_APP_EXIT             \"Quit the application; prompts to save documents\\nExit\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_FILE_MRU_FILE1       \"Open this document\"\r\n    ID_FILE_MRU_FILE2       \"Open this document\"\r\n    ID_FILE_MRU_FILE3       \"Open this document\"\r\n    ID_FILE_MRU_FILE4       \"Open this document\"\r\n    ID_FILE_MRU_FILE5       \"Open this document\"\r\n    ID_FILE_MRU_FILE6       \"Open this document\"\r\n    ID_FILE_MRU_FILE7       \"Open this document\"\r\n    ID_FILE_MRU_FILE8       \"Open this document\"\r\n    ID_FILE_MRU_FILE9       \"Open this document\"\r\n    ID_FILE_MRU_FILE10      \"Open this document\"\r\n    ID_FILE_MRU_FILE11      \"Open this document\"\r\n    ID_FILE_MRU_FILE12      \"Open this document\"\r\n    ID_FILE_MRU_FILE13      \"Open this document\"\r\n    ID_FILE_MRU_FILE14      \"Open this document\"\r\n    ID_FILE_MRU_FILE15      \"Open this document\"\r\n    ID_FILE_MRU_FILE16      \"Open this document\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_NEXT_PANE            \"Switch to the next window pane\\nNext Pane\"\r\n    ID_PREV_PANE            \"Switch back to the previous window pane\\nPrevious Pane\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_WINDOW_SPLIT         \"Split the active window into panes\\nSplit\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_EDIT_CLEAR           \"Erase the selection\\nErase\"\r\n    ID_EDIT_CLEAR_ALL       \"Erase everything\\nErase All\"\r\n    ID_EDIT_COPY            \"Copy the selection and put it on the Clipboard\\nCopy\"\r\n    ID_EDIT_CUT             \"Cut the selection and put it on the Clipboard\\nCut\"\r\n    ID_EDIT_FIND            \"Find the specified text\\nFind\"\r\n    ID_EDIT_PASTE           \"Insert Clipboard contents\\nPaste\"\r\n    ID_EDIT_REPEAT          \"Repeat the last action\\nRepeat\"\r\n    ID_EDIT_REPLACE         \"Replace specific text with different text\\nReplace\"\r\n    ID_EDIT_SELECT_ALL      \"Select the entire document\\nSelect All\"\r\n    ID_EDIT_UNDO            \"Undo the last action\\nUndo\"\r\n    ID_EDIT_REDO            \"Redo the previously undone action\\nRedo\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_VIEW_TOOLBAR         \"Show or hide the toolbar\\nToggle ToolBar\"\r\n    ID_VIEW_STATUS_BAR      \"Show or hide the status bar\\nToggle StatusBar\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    AFX_IDS_SCSIZE          \"Change the window size\"\r\n    AFX_IDS_SCMOVE          \"Change the window position\"\r\n    AFX_IDS_SCMINIMIZE      \"Reduce the window to an icon\"\r\n    AFX_IDS_SCMAXIMIZE      \"Enlarge the window to full size\"\r\n    AFX_IDS_SCNEXTWINDOW    \"Switch to the next document window\"\r\n    AFX_IDS_SCPREVWINDOW    \"Switch to the previous document window\"\r\n    AFX_IDS_SCCLOSE         \"Close the active window and prompts to save the documents\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    AFX_IDS_SCRESTORE       \"Restore the window to normal size\"\r\n    AFX_IDS_SCTASKLIST      \"Activate Task List\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    AFX_IDS_PREVIEW_CLOSE   \"Close print preview mode\\nCancel Preview\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_BUTTON_SAVE          \"Save /t Ctrl - S\"\r\n    ID_BUTTON_SAVE_ALL      \"Save All /t Ctrl-Shift-S\"\r\nEND\r\n\r\nSTRINGTABLE\r\nBEGIN\r\n    ID_BUTTON_CLOSE         \"Close /t Escape\"\r\nEND\r\n\r\n#endif    // English (United States) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n#ifndef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 3 resource.\r\n//\r\n#define _AFX_NO_SPLITTER_RESOURCES\r\n#define _AFX_NO_OLE_RESOURCES\r\n#define _AFX_NO_TRACKER_RESOURCES\r\n#define _AFX_NO_PROPERTY_RESOURCES\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n#ifdef _WIN32\r\nLANGUAGE 9, 1\r\n#pragma code_page(1252)\r\n#endif //_WIN32\r\n#include \"res\\CP_Main.rc2\"  // non-Microsoft Visual C++ edited resources\r\n#include \"afxres.rc\"         // Standard components\r\n#include \"afxprint.rc\"       // printing/print preview resources\r\n#endif\r\n\r\n1 TYPELIB \"CP_Main.tlb\"\r\n/////////////////////////////////////////////////////////////////////////////\r\n#endif    // not APSTUDIO_INVOKED\r\n\r\n"
        },
        {
          "name": "CP_Main.rgs",
          "type": "blob",
          "size": 0.0009765625,
          "content": "\n"
        },
        {
          "name": "CP_Main.vcxproj",
          "type": "blob",
          "size": 323.4638671875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug|ARM64\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>ARM64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|x64\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|ARM64\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>ARM64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|Win32\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|x64\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <RootNamespace>CP_Main</RootNamespace>\r\n    <Keyword>MFCProj</Keyword>\r\n    <ProjectGuid>{8ECC3EF2-AF07-27B6-A773-779874943C0D}</ProjectGuid>\r\n    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n    <WholeProgramOptimization>false</WholeProgramOptimization>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseOfMfc>Dynamic</UseOfMfc>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n    <PlatformToolset>v143</PlatformToolset>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup>\r\n    <_ProjectFileVersion>10.0.21006.1</_ProjectFileVersion>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">.\\Release\\</OutDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">.\\Release\\</IntDir>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">false</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">false</LinkIncremental>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">.\\Debug\\</OutDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">.\\Debug\\</IntDir>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</LinkIncremental>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(SolutionDir)$(Configuration)64\\</OutDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(Platform)\\$(Configuration)\\</IntDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(Platform)\\$(Configuration)\\</IntDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">$(Platform)\\$(Configuration)\\Tmp\\</IntDir>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">false</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">false</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">false</LinkIncremental>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(SolutionDir)$(Configuration)\\</OutDir>\r\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(SolutionDir)$(Configuration)64\\</OutDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(Platform)\\$(Configuration)\\</IntDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(Platform)\\$(Configuration)\\</IntDir>\r\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">$(Platform)\\$(Configuration)\\Tmp\\</IntDir>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</LinkIncremental>\r\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</LinkIncremental>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" />\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" />\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Template|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Template|ARM64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Template|x64'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Template|ARM64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Template|x64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Template|ARM64'\" />\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" />\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRuleSet Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">AllRules.ruleset</CodeAnalysisRuleSet>\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n    <CodeAnalysisRules Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" />\r\n    <CodeAnalysisRuleAssemblies Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" />\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Ditto</TargetName>\r\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">Ditto</TargetName>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <IncludePath>$(IncludePath)</IncludePath>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">\r\n    <IncludePath>$(IncludePath)</IncludePath>\r\n    <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\r\n  </PropertyGroup>\r\n  <PropertyGroup Label=\"Vcpkg\">\r\n    <VcpkgEnableManifest>false</VcpkgEnableManifest>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_MBCS;AFTER_98;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <StringPooling>true</StringPooling>\r\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\Release\\CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>\r\n      <AssemblerListingLocation>.\\Release\\</AssemblerListingLocation>\r\n      <ObjectFileName>.\\Release\\</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\Release\\</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Version.lib;Shlwapi.lib;$(Configuration)\\EncryptDecrypt.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>release\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\Release\\Ditto.pdb</ProgramDatabaseFile>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\Release\\Ditto.map</MapFileName>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>wWinMainCRTStartup</EntryPointSymbol>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <MapExports>true</MapExports>\r\n      <RegisterOutput>false</RegisterOutput>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TargetEnvironment>Win32</TargetEnvironment>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Release/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>WIN64;NDEBUG;_WINDOWS;_MBCS;AFTER_98;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <StringPooling>true</StringPooling>\r\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\Release64\\CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>\r\n      <AssemblerListingLocation>.\\Release64\\</AssemblerListingLocation>\r\n      <ObjectFileName>.\\Release64\\</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\Release64\\</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Version.lib;$(Configuration)64\\EncryptDecrypt.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>release64\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\Release64\\Ditto.pdb</ProgramDatabaseFile>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\Release64\\Ditto.map</MapFileName>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>wWinMainCRTStartup</EntryPointSymbol>\r\n      <MapExports>true</MapExports>\r\n      <RegisterOutput>false</RegisterOutput>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Release/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>WIN64;NDEBUG;_WINDOWS;_MBCS;AFTER_98;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <StringPooling>true</StringPooling>\r\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\$(Platform)\\$(Configuration)\\CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>\r\n      <AssemblerListingLocation>.\\$(Platform)\\$(Configuration)\\</AssemblerListingLocation>\r\n      <ObjectFileName>.\\$(Platform)\\$(Configuration)\\</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\$(Platform)\\$(Configuration)\\</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Version.lib;$(Platform)\\$(Configuration)\\EncryptDecrypt.lib;Shlwapi.lib;zlib\\zlibstat.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>$(Platform)\\$(Configuration)\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\$(Platform)\\$(Configuration)\\Ditto.pdb</ProgramDatabaseFile>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\$(Platform)\\$(Configuration)\\Ditto.map</MapFileName>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>wWinMainCRTStartup</EntryPointSymbol>\r\n      <MapExports>true</MapExports>\r\n      <RegisterOutput>false</RegisterOutput>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Release/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_MBCS;AFTER_98;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\Debug/CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerListingLocation>.\\Debug/</AssemblerListingLocation>\r\n      <ObjectFileName>.\\Debug/</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\Debug/</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Pdh.lib;Version.lib;$(Configuration)\\EncryptDecrypt.lib;Shlwapi.lib;crypt32.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>debug\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\Debug/Ditto.pdb</ProgramDatabaseFile>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>wWinMainCRTStartup</EntryPointSymbol>\r\n      <TargetMachine>MachineX86</TargetMachine>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\Debug/Ditto.map</MapFileName>\r\n      <MapExports>true</MapExports>\r\n      <RegisterOutput>false</RegisterOutput>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TargetEnvironment>Win32</TargetEnvironment>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Debug/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_MBCS;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\Debug64/CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerListingLocation>.\\Debug64/</AssemblerListingLocation>\r\n      <ObjectFileName>.\\Debug64/</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\Debug64/</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Pdh.lib;Version.lib;$(Configuration)64\\\\EncryptDecrypt.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>debug64\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\Debug64/Ditto.pdb</ProgramDatabaseFile>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>\r\n      </EntryPointSymbol>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\Debug64/Ditto.map</MapFileName>\r\n      <MapExports>true</MapExports>\r\n      <TargetMachine>MachineX64</TargetMachine>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <RegisterOutput>false</RegisterOutput>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Debug/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_MBCS;UNICODE;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\r\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\r\n      <PrecompiledHeader>Use</PrecompiledHeader>\r\n      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>\r\n      <PrecompiledHeaderOutputFile>.\\$(Platform)\\$(Configuration)/CP_Main.pch</PrecompiledHeaderOutputFile>\r\n      <AssemblerListingLocation>.\\$(Platform)\\$(Configuration)/</AssemblerListingLocation>\r\n      <ObjectFileName>.\\$(Platform)\\$(Configuration)/</ObjectFileName>\r\n      <ProgramDataBaseFileName>.\\$(Platform)\\$(Configuration)/</ProgramDataBaseFileName>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\r\n      <CompileAs>Default</CompileAs>\r\n      <AdditionalOptions>/bigobj %(AdditionalOptions)</AdditionalOptions>\r\n      <LanguageStandard>stdcpp17</LanguageStandard>\r\n    </ClCompile>\r\n    <Link>\r\n      <AdditionalDependencies>ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;Winmm.lib;Pdh.lib;Version.lib;$(Platform)\\$(Configuration)\\EncryptDecrypt.lib;Shlwapi.lib;zlib\\zlibstat.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <OutputFile>$(Platform)\\$(Configuration)\\Ditto.exe</OutputFile>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <ProgramDatabaseFile>.\\$(Configuration)/Ditto.pdb</ProgramDatabaseFile>\r\n      <SubSystem>Windows</SubSystem>\r\n      <EntryPointSymbol>\r\n      </EntryPointSymbol>\r\n      <GenerateMapFile>true</GenerateMapFile>\r\n      <MapFileName>.\\$(Platform)\\$(Configuration)/Ditto.map</MapFileName>\r\n      <MapExports>true</MapExports>\r\n      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>\r\n      <RegisterOutput>false</RegisterOutput>\r\n    </Link>\r\n    <Midl>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MkTypLibCompatible>true</MkTypLibCompatible>\r\n      <SuppressStartupBanner>true</SuppressStartupBanner>\r\n      <TypeLibraryName>.\\CP_Main___Win32_Unicode_Debug/CP_Main.tlb</TypeLibraryName>\r\n      <HeaderFileName>\r\n      </HeaderFileName>\r\n    </Midl>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n    </ResourceCompile>\r\n    <PostBuildEvent>\r\n      <Command>\r\n      </Command>\r\n    </PostBuildEvent>\r\n    <Manifest>\r\n      <AdditionalManifestFiles>DeclareDPIAware.manifest</AdditionalManifestFiles>\r\n      <EnableDpiAwareness>PerMonitorHighDPIAware</EnableDpiAwareness>\r\n    </Manifest>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"About.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Accels.cpp\" />\r\n    <ClCompile Include=\"ActionEnums.cpp\" />\r\n    <ClCompile Include=\"AddType.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"AdvGeneral.cpp\" />\r\n    <ClCompile Include=\"AutoSendToClientThread.cpp\" />\r\n    <ClCompile Include=\"BitmapHelper.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipEditThread.cpp\" />\r\n    <ClCompile Include=\"CF_HDropAggregator.cpp\" />\r\n    <ClCompile Include=\"CF_TextAggregator.cpp\" />\r\n    <ClCompile Include=\"CF_UnicodeTextAggregator.cpp\" />\r\n    <ClCompile Include=\"ChaiScriptOnCopy.cpp\" />\r\n    <ClCompile Include=\"ChaiScriptXml.cpp\" />\r\n    <ClCompile Include=\"ConvertRTFToText.cpp\" />\r\n    <ClCompile Include=\"ImageFormatAggregator.cpp\" />\r\n    <ClCompile Include=\"Clip.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipCompare.cpp\" />\r\n    <ClCompile Include=\"ClipFormatQListCtrl.cpp\" />\r\n    <ClCompile Include=\"Clip_ImportExport.cpp\" />\r\n    <ClCompile Include=\"ClipboardSaveRestore.cpp\" />\r\n    <ClCompile Include=\"ClipboardViewer.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipIds.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ICU_String.cpp\" />\r\n    <ClCompile Include=\"ImageHelper.cpp\" />\r\n    <ClCompile Include=\"NoDbFrameWnd.cpp\" />\r\n    <ClCompile Include=\"CopyProperties.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CopyThread.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CP_Main.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CustomFriendsHelper.cpp\" />\r\n    <ClCompile Include=\"DeleteClipData.cpp\" />\r\n    <ClCompile Include=\"DimWnd.cpp\" />\r\n    <ClCompile Include=\"DittoChaiScript.cpp\" />\r\n    <ClCompile Include=\"DittoPopupWindow.cpp\" />\r\n    <ClCompile Include=\"DPI.cpp\" />\r\n    <ClCompile Include=\"DrawHTML.C\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"EditWithButton.cpp\" />\r\n    <ClCompile Include=\"EventThread.cpp\" />\r\n    <ClCompile Include=\"FriendPromptDlg.cpp\" />\r\n    <ClCompile Include=\"GdiImageDrawer.cpp\" />\r\n    <ClCompile Include=\"GdipButton.cpp\" />\r\n    <ClCompile Include=\"GlobalClips.cpp\" />\r\n    <ClCompile Include=\"HotKeys.cpp\" />\r\n    <ClCompile Include=\"ImageViewer.cpp\" />\r\n    <ClCompile Include=\"MainFrmThread.cpp\" />\r\n    <ClCompile Include=\"Md5.cpp\" />\r\n    <ClCompile Include=\"MessagePumpThread.cpp\" />\r\n    <ClCompile Include=\"MyDropTarget.cpp\" />\r\n    <ClCompile Include=\"NTray.cpp\" />\r\n    <ClCompile Include=\"Popup.cpp\" />\r\n    <ClCompile Include=\"PowerManager.cpp\" />\r\n    <ClCompile Include=\"QPasteWndThread.cpp\" />\r\n    <ClCompile Include=\"QRCodeViewer.cpp\" />\r\n    <ClCompile Include=\"QuickPasteKeyboard.cpp\" />\r\n    <ClCompile Include=\"RegExFilterHelper.cpp\" />\r\n    <ClCompile Include=\"ScriptEditor.cpp\" />\r\n    <ClCompile Include=\"ScrollHelper.cpp\" />\r\n    <ClCompile Include=\"SendMail.cpp\" />\r\n    <ClCompile Include=\"Shared\\TextConvert.cpp\" />\r\n    <ClCompile Include=\"Shared\\Tokenizer.cpp\" />\r\n    <ClCompile Include=\"ShowTaskBarIcon.cpp\" />\r\n    <ClCompile Include=\"SimpleBrowser.cpp\" />\r\n    <ClCompile Include=\"SnapWindow.cpp\" />\r\n    <ClCompile Include=\"SpecialPasteOptions.cpp\" />\r\n    <ClCompile Include=\"sqlite\\CppSQLite3.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Crc32Dynamic.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DatabaseUtilities.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoAddin.cpp\" />\r\n    <ClCompile Include=\"DittoAddins.cpp\" />\r\n    <ClCompile Include=\"DittoCopyBuffer.cpp\">\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n      <ObjectFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">$(IntDir)%(FileName)1.obj</ObjectFileName>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoWindow.cpp\" />\r\n    <ClCompile Include=\"ExternalWindowTracker.cpp\" />\r\n    <ClCompile Include=\"FileTransferProgressDlg.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FormatSQL.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FriendDetails.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupCombo.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupName.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupTree.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HListBox.cpp\" />\r\n    <ClCompile Include=\"HTMLFormatAggregator.cpp\" />\r\n    <ClCompile Include=\"MainFrm.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MainTableFunctions.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Misc.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MoveToGroupDlg.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MultiLanguage.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OleClipSource.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionFriends.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Options.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsCopyBuffers.cpp\" />\r\n    <ClCompile Include=\"OptionsGeneral.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsKeyBoard.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsQuickPaste.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsSheet.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsStats.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsTypes.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Path.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"PerfTimer.cpp\" />\r\n    <ClCompile Include=\"ProcessPaste.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ProgressWnd.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QPasteWnd.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QuickPaste.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RichTextAggregator.cpp\" />\r\n    <ClCompile Include=\"SaveAnimation.cpp\" />\r\n    <ClCompile Include=\"SendKeys.cpp\" />\r\n    <ClCompile Include=\"sqlite\\sqlite3mc_amalgamation.c\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"StdAfx.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Create</PrecompiledHeader>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">Create</PrecompiledHeader>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Create</PrecompiledHeader>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Create</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">Create</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SymbolEdit.cpp\" />\r\n    <ClCompile Include=\"SystemTray.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TabCtrl.cpp\" />\r\n    <ClCompile Include=\"Theme.cpp\" />\r\n    <ClCompile Include=\"AlphaBlend.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DialogResizer.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FormattedTextDraw.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupStatic.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HyperLink.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"NumberEdit.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QListCtrl.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RichEditCtrlEx.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SearchEditBox.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinystr.cpp\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxml.cpp\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxmlerror.cpp\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxmlparser.cpp\">\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\r\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ToolTipEx.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TrayWnd.cpp\" />\r\n    <ClCompile Include=\"UAC_Helper.cpp\" />\r\n    <ClCompile Include=\"UAC_Thread.cpp\" />\r\n    <ClCompile Include=\"WildCardMatch.cpp\" />\r\n    <ClCompile Include=\"WndEx.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Client.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FileRecieve.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FileSend.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RecieveSocket.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SendSocket.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Server.cpp\">\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Disabled</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Disabled</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <BasicRuntimeChecks Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">EnableFastChecks</BasicRuntimeChecks>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">MaxSpeed</Optimization>\r\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">MaxSpeed</Optimization>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"CP_Main.rc\">\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">_DEBUG;_AFXDLL</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">_DEBUG;_AFXDLL</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">_DEBUG;_AFXDLL</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NDEBUG;_AFXDLL</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NDEBUG;_AFXDLL</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NDEBUG;_AFXDLL</PreprocessorDefinitions>\r\n    </ResourceCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"Accels.h\" />\r\n    <ClInclude Include=\"ActionEnums.h\" />\r\n    <ClInclude Include=\"AdvGeneral.h\" />\r\n    <ClInclude Include=\"AlphaBlend.h\" />\r\n    <ClInclude Include=\"ArrayEx.h\" />\r\n    <ClInclude Include=\"AutoSendToClientThread.h\" />\r\n    <ClInclude Include=\"ClipEditThread.h\" />\r\n    <ClInclude Include=\"CGdiPlusBitmap.h\" />\r\n    <ClInclude Include=\"ChaiScriptOnCopy.h\" />\r\n    <ClInclude Include=\"ChaiScriptXml.h\" />\r\n    <ClInclude Include=\"ConvertRTFToText.h\" />\r\n    <ClInclude Include=\"ImageFormatAggregator.h\" />\r\n    <ClInclude Include=\"ClipCompare.h\" />\r\n    <ClInclude Include=\"ClipFormatQListCtrl.h\" />\r\n    <ClInclude Include=\"ICU_String.h\" />\r\n    <ClInclude Include=\"ImageHelper.h\" />\r\n    <ClInclude Include=\"NoDbFrameWnd.h\" />\r\n    <ClInclude Include=\"CustomFriendsHelper.h\" />\r\n    <ClInclude Include=\"DeleteClipData.h\" />\r\n    <ClInclude Include=\"DimWnd.h\" />\r\n    <ClInclude Include=\"DittoChaiScript.h\" />\r\n    <ClInclude Include=\"DittoPopupWindow.h\" />\r\n    <ClInclude Include=\"DPI.h\" />\r\n    <ClInclude Include=\"DrawHTML.h\" />\r\n    <ClInclude Include=\"EditWithButton.h\" />\r\n    <ClInclude Include=\"EventThread.h\" />\r\n    <ClInclude Include=\"FormattedTextDraw.h\" />\r\n    <ClInclude Include=\"FriendPromptDlg.h\" />\r\n    <ClInclude Include=\"GdiImageDrawer.h\" />\r\n    <ClInclude Include=\"GdipButton.h\" />\r\n    <ClInclude Include=\"GlobalClips.h\" />\r\n    <ClInclude Include=\"GroupStatic.h\" />\r\n    <ClInclude Include=\"HotKeys.h\" />\r\n    <ClInclude Include=\"ImageViewer.h\" />\r\n    <ClInclude Include=\"MainFrmThread.h\" />\r\n    <ClInclude Include=\"Md5.h\" />\r\n    <ClInclude Include=\"memdc.h\" />\r\n    <ClInclude Include=\"MessagePumpThread.h\" />\r\n    <ClInclude Include=\"MyDropTarget.h\" />\r\n    <ClInclude Include=\"NTray.h\" />\r\n    <ClInclude Include=\"NumberEdit.h\" />\r\n    <ClInclude Include=\"Popup.h\" />\r\n    <ClInclude Include=\"PowerManager.h\" />\r\n    <ClInclude Include=\"QListCtrl.h\" />\r\n    <ClInclude Include=\"QPasteWndThread.h\" />\r\n    <ClInclude Include=\"QRCodeViewer.h\" />\r\n    <ClInclude Include=\"QuickPasteKeyboard.h\" />\r\n    <ClInclude Include=\"RegExFilterHelper.h\" />\r\n    <ClInclude Include=\"RichEditCtrlEx.h\" />\r\n    <ClInclude Include=\"ScriptEditor.h\" />\r\n    <ClInclude Include=\"ScrollHelper.h\" />\r\n    <ClInclude Include=\"SearchEditBox.h\" />\r\n    <ClInclude Include=\"SendMail.h\" />\r\n    <ClInclude Include=\"Shared\\TextConvert.h\" />\r\n    <ClInclude Include=\"Shared\\Tokenizer.h\" />\r\n    <ClInclude Include=\"ShowTaskBarIcon.h\" />\r\n    <ClInclude Include=\"SimpleBrowser.h\" />\r\n    <ClInclude Include=\"Slugify.h\" />\r\n    <ClInclude Include=\"SnapWindow.h\" />\r\n    <ClInclude Include=\"SpecialPasteOptions.h\" />\r\n    <ClInclude Include=\"sqlite\\sqlite3mc_amalgamation.h\" />\r\n    <ClInclude Include=\"SymbolEdit.h\" />\r\n    <ClInclude Include=\"ToolTipEx.h\" />\r\n    <ClInclude Include=\"TrayWnd.h\" />\r\n    <ClInclude Include=\"UAC_Helper.h\" />\r\n    <ClInclude Include=\"UAC_Thread.h\" />\r\n    <ClInclude Include=\"WildCardMatch.h\" />\r\n    <ClInclude Include=\"WndEx.h\" />\r\n    <ClInclude Include=\"Client.h\" />\r\n    <ClInclude Include=\"FileRecieve.h\" />\r\n    <ClInclude Include=\"FileSend.h\" />\r\n    <ClInclude Include=\"RecieveSocket.h\" />\r\n    <ClInclude Include=\"SendSocket.h\" />\r\n    <ClInclude Include=\"Server.h\" />\r\n    <ClInclude Include=\"About.h\" />\r\n    <ClInclude Include=\"AddType.h\" />\r\n    <ClInclude Include=\"BitmapHelper.h\" />\r\n    <ClInclude Include=\"CF_HDropAggregator.h\" />\r\n    <ClInclude Include=\"CF_TextAggregator.h\" />\r\n    <ClInclude Include=\"CF_UnicodeTextAggregator.h\" />\r\n    <ClInclude Include=\"Clip.h\" />\r\n    <ClInclude Include=\"Clip_ImportExport.h\" />\r\n    <ClInclude Include=\"ClipboardSaveRestore.h\" />\r\n    <ClInclude Include=\"ClipboardViewer.h\" />\r\n    <ClInclude Include=\"ClipIds.h\" />\r\n    <ClInclude Include=\"CopyProperties.h\" />\r\n    <ClInclude Include=\"CopyThread.h\" />\r\n    <ClInclude Include=\"CP_Main.h\" />\r\n    <ClInclude Include=\"sqlite\\CppSQLite3.h\" />\r\n    <ClInclude Include=\"Crc32Dynamic.h\" />\r\n    <ClInclude Include=\"DatabaseUtilities.h\" />\r\n    <ClInclude Include=\"DialogResizer.h\" />\r\n    <ClInclude Include=\"DittoAddin.h\" />\r\n    <ClInclude Include=\"DittoAddins.h\" />\r\n    <ClInclude Include=\"DittoCopyBuffer.h\" />\r\n    <ClInclude Include=\"Shared\\DittoDefines.h\" />\r\n    <ClInclude Include=\"DittoWindow.h\" />\r\n    <ClInclude Include=\"ExternalWindowTracker.h\" />\r\n    <ClInclude Include=\"FileTransferProgressDlg.h\" />\r\n    <ClInclude Include=\"FormatSQL.h\" />\r\n    <ClInclude Include=\"FriendDetails.h\" />\r\n    <ClInclude Include=\"GroupCombo.h\" />\r\n    <ClInclude Include=\"GroupName.h\" />\r\n    <ClInclude Include=\"GroupTree.h\" />\r\n    <ClInclude Include=\"HListBox.h\" />\r\n    <ClInclude Include=\"HTMLFormatAggregator.h\" />\r\n    <ClInclude Include=\"HyperLink.h\" />\r\n    <ClInclude Include=\"Shared\\IAddinExports.h\" />\r\n    <ClInclude Include=\"Shared\\IClip.h\" />\r\n    <ClInclude Include=\"IClipAggregator.h\" />\r\n    <ClInclude Include=\"MainFrm.h\" />\r\n    <ClInclude Include=\"MainTableFunctions.h\" />\r\n    <ClInclude Include=\"Misc.h\" />\r\n    <ClInclude Include=\"MoveToGroupDlg.h\" />\r\n    <ClInclude Include=\"MultiLanguage.h\" />\r\n    <ClInclude Include=\"OleClipSource.h\" />\r\n    <ClInclude Include=\"OptionFriends.h\" />\r\n    <ClInclude Include=\"Options.h\" />\r\n    <ClInclude Include=\"OptionsCopyBuffers.h\" />\r\n    <ClInclude Include=\"OptionsGeneral.h\" />\r\n    <ClInclude Include=\"OptionsKeyBoard.h\" />\r\n    <ClInclude Include=\"OptionsQuickPaste.h\" />\r\n    <ClInclude Include=\"OptionsSheet.h\" />\r\n    <ClInclude Include=\"OptionsStats.h\" />\r\n    <ClInclude Include=\"OptionsTypes.h\" />\r\n    <ClInclude Include=\"Path.h\" />\r\n    <ClInclude Include=\"PerfTimer.h\" />\r\n    <ClInclude Include=\"ProcessPaste.h\" />\r\n    <ClInclude Include=\"ProgressWnd.h\" />\r\n    <ClInclude Include=\"QPasteWnd.h\" />\r\n    <ClInclude Include=\"QuickPaste.h\" />\r\n    <ClInclude Include=\"Resource.h\" />\r\n    <ClInclude Include=\"RichTextAggregator.h\" />\r\n    <ClInclude Include=\"SaveAnimation.h\" />\r\n    <ClInclude Include=\"SendKeys.h\" />\r\n    <ClInclude Include=\"ServerDefines.h\" />\r\n    <ClInclude Include=\"StdAfx.h\" />\r\n    <ClInclude Include=\"SystemTray.h\" />\r\n    <ClInclude Include=\"TabCtrl.h\" />\r\n    <ClInclude Include=\"Theme.h\" />\r\n    <ClInclude Include=\"UnicodeMacros.h\" />\r\n    <ClInclude Include=\"TinyXml\\tinystr.h\" />\r\n    <ClInclude Include=\"TinyXml\\tinyxml.h\" />\r\n    <ClInclude Include=\"RulerRichEditCtrl\\ids.h\" />\r\n    <ClInclude Include=\"RulerRichEditCtrl\\StdGrfx.h\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"CP_Main.rgs\" />\r\n    <None Include=\"packages.config\" />\r\n    <None Include=\"res\\back.bmp\" />\r\n    <None Include=\"res\\back1.bmp\" />\r\n    <None Include=\"res\\back2.bmp\" />\r\n    <None Include=\"res\\bitmap1.bmp\" />\r\n    <None Include=\"res\\bmp00001.bmp\" />\r\n    <None Include=\"res\\bmp00002.bmp\" />\r\n    <None Include=\"res\\bmp00003.bmp\" />\r\n    <None Include=\"res\\ChevronLeft_Black_16_16.png\" />\r\n    <None Include=\"res\\ChevronLeft_Black_20_20.png\" />\r\n    <None Include=\"res\\ChevronLeft_Black_24_24.png\" />\r\n    <None Include=\"res\\ChevronLeft_Black_28.png\" />\r\n    <None Include=\"res\\ChevronLeft_Black_32_32.png\" />\r\n    <None Include=\"res\\ChevronRight_Black_16_16.png\" />\r\n    <None Include=\"res\\ChevronRight_Black_20_20.png\" />\r\n    <None Include=\"res\\ChevronRight_Black_24_24.png\" />\r\n    <None Include=\"res\\ChevronRight_Black_28.png\" />\r\n    <None Include=\"res\\ChevronRight_Black_32_32.png\" />\r\n    <None Include=\"res\\chevron_right_16_16.png\" />\r\n    <None Include=\"res\\chevron_right_10_10.png\" />\r\n    <None Include=\"res\\chevron_right_12_12.png\" />\r\n    <None Include=\"res\\chevron_right_8_8.png\" />\r\n    <None Include=\"res\\chevron_left_16_16.png\" />\r\n    <None Include=\"res\\chevron_left_10_10.png\" />\r\n    <None Include=\"res\\chevron_left_12_12.png\" />\r\n    <None Include=\"res\\chevron_left_8_8.png\" />\r\n    <None Include=\"res\\chevron_top_16_16.png\" />\r\n    <None Include=\"res\\chevron_top_10_10.png\" />\r\n    <None Include=\"res\\chevron_top_12_12.png\" />\r\n    <None Include=\"res\\chevron_top_8_8.png\" />\r\n    <None Include=\"res\\chevron_bottom_16_16.png\" />\r\n    <None Include=\"res\\chevron_bottom_10_10.png\" />\r\n    <None Include=\"res\\chevron_bottom_12_12.png\" />\r\n    <None Include=\"res\\chevron_bottom_8_8.png\" />\r\n    <None Include=\"res\\closed_f.bmp\" />\r\n    <None Include=\"res\\close_10_10.png\" />\r\n    <None Include=\"res\\close_12_12.png\" />\r\n    <None Include=\"res\\close_16_16.png\" />\r\n    <None Include=\"res\\close_8_8.png\" />\r\n    <None Include=\"res\\Close_Black_16_16.png\" />\r\n    <None Include=\"res\\Close_Black_20_20.png\" />\r\n    <None Include=\"res\\Close_Black_24_24.png\" />\r\n    <None Include=\"res\\Close_Black_28.png\" />\r\n    <None Include=\"res\\Close_Black_32_32.png\" />\r\n    <None Include=\"res\\cog_16_16.png\" />\r\n    <None Include=\"res\\cog_20_20.png\" />\r\n    <None Include=\"res\\cog_22_22.png\" />\r\n    <None Include=\"res\\cog_24_24.png\" />\r\n    <None Include=\"res\\cog_28.png\" />\r\n    <None Include=\"res\\cog_32_32.png\" />\r\n    <None Include=\"res\\CP_Main.ico\" />\r\n    <None Include=\"res\\CP_Main.rc2\" />\r\n    <None Include=\"res\\CP_MainDoc.ico\" />\r\n    <None Include=\"res\\cursor1.cur\" />\r\n    <None Include=\"res\\cursor2.cur\" />\r\n    <None Include=\"res\\cursor_zoom_in.cur\" />\r\n    <None Include=\"res\\Ditto.ico\" />\r\n    <None Include=\"res\\Ditto2_NoCopyCb.ico\" />\r\n    <None Include=\"res\\DittoNew.ico\" />\r\n    <None Include=\"res\\Ditto_NoCopyCb.ico\" />\r\n    <None Include=\"res\\folder_open.png\" />\r\n    <None Include=\"res\\Hamburger_16_16.png\" />\r\n    <None Include=\"res\\Hamburger_20_20.png\" />\r\n    <None Include=\"res\\Hamburger_24_24.png\" />\r\n    <None Include=\"res\\Hamburger_32_32.png\" />\r\n    <None Include=\"res\\in_folder_16_16.png\" />\r\n    <None Include=\"res\\in_folder_20_20.png\" />\r\n    <None Include=\"res\\in_folder_24_24.png\" />\r\n    <None Include=\"res\\in_folder_32_32.png\" />\r\n    <None Include=\"res\\key_stroke_16_16.png\" />\r\n    <None Include=\"res\\key_stroke_20_20.png\" />\r\n    <None Include=\"res\\key_stroke_24_24.png\" />\r\n    <None Include=\"res\\key_stroke_32_32.png\" />\r\n    <None Include=\"res\\left-blue.png\" />\r\n    <None Include=\"res\\left_arrow_16_16.png\" />\r\n    <None Include=\"res\\left_arrow_20_20.png\" />\r\n    <None Include=\"res\\left_arrow_24_24.png\" />\r\n    <None Include=\"res\\left_arrow_32_32.png\" />\r\n    <None Include=\"res\\mainfram.bmp\" />\r\n    <None Include=\"res\\maximize_10_10.png\" />\r\n    <None Include=\"res\\maximize_12_12.png\" />\r\n    <None Include=\"res\\maximize_16_16.png\" />\r\n    <None Include=\"res\\maximize_20.png\" />\r\n    <None Include=\"res\\maximize_24.png\" />\r\n    <None Include=\"res\\maximize_28.png\" />\r\n    <None Include=\"res\\maximize_32.png\" />\r\n    <None Include=\"res\\maximize_8_8.png\" />\r\n    <None Include=\"res\\minimize_16.png\" />\r\n    <None Include=\"res\\minimize_20.png\" />\r\n    <None Include=\"res\\minimize_24.png\" />\r\n    <None Include=\"res\\minimize_28.png\" />\r\n    <None Include=\"res\\minimize_32.png\" />\r\n    <None Include=\"res\\NewWindowIcon_24_14.png\" />\r\n    <None Include=\"res\\NewWindowIcon_30.png\" />\r\n    <None Include=\"res\\NewWindowIcon_36.png\" />\r\n    <None Include=\"res\\NewWindowIcon_48.png\" />\r\n    <None Include=\"res\\Open Folder-24.png\" />\r\n    <None Include=\"res\\Open Folder-32.png\" />\r\n    <None Include=\"res\\opened_folder_16_16.png\" />\r\n    <None Include=\"res\\opened_folder_20_20.png\" />\r\n    <None Include=\"res\\opened_folder_24_24.png\" />\r\n    <None Include=\"res\\opened_folder_32_32.png\" />\r\n    <None Include=\"res\\open_fol.bmp\" />\r\n    <None Include=\"res\\Ditto2.ico\" />\r\n    <None Include=\"res\\open_folder_24.png\" />\r\n    <None Include=\"res\\open_folder_30.png\" />\r\n    <None Include=\"res\\open_folder_36.png\" />\r\n    <None Include=\"res\\open_folder_42.png\" />\r\n    <None Include=\"res\\open_folder_48.png\" />\r\n    <None Include=\"res\\return_16.png\" />\r\n    <None Include=\"res\\return_20.png\" />\r\n    <None Include=\"res\\return_24.png\" />\r\n    <None Include=\"res\\return_28.png\" />\r\n    <None Include=\"res\\return_32.png\" />\r\n    <None Include=\"res\\Search_16.png\" />\r\n    <None Include=\"res\\Search_20.png\" />\r\n    <None Include=\"res\\Search_24.png\" />\r\n    <None Include=\"res\\Search_28.png\" />\r\n    <None Include=\"res\\Search_32.png\" />\r\n    <None Include=\"res\\search_close.bmp\" />\r\n    <None Include=\"res\\search_close_125.bmp\" />\r\n    <None Include=\"res\\search_close_150.bmp\" />\r\n    <None Include=\"res\\search_close_16.png\" />\r\n    <None Include=\"res\\search_close_200.bmp\" />\r\n    <None Include=\"res\\search_normal.bmp\" />\r\n    <None Include=\"res\\search_normal_125.bmp\" />\r\n    <None Include=\"res\\search_normal_150.bmp\" />\r\n    <None Include=\"res\\search_normal_200.bmp\" />\r\n    <None Include=\"res\\shortcut.png\" />\r\n    <None Include=\"res\\Sticky_16_16.png\" />\r\n    <None Include=\"res\\Sticky_20_20.png\" />\r\n    <None Include=\"res\\Sticky_24_24.png\" />\r\n    <None Include=\"res\\Sticky_32_32.png\" />\r\n    <None Include=\"res\\system_menu_16_16.png\" />\r\n    <None Include=\"res\\system_menu_20_20.png\" />\r\n    <None Include=\"res\\system_menu_24_24.png\" />\r\n    <None Include=\"res\\system_menu_2_24.png\" />\r\n    <None Include=\"res\\system_menu_2_30.png\" />\r\n    <None Include=\"res\\system_menu_2_32_32.png\" />\r\n    <None Include=\"res\\system_menu_2_36.png\" />\r\n    <None Include=\"res\\system_menu_2_40_40.png\" />\r\n    <None Include=\"res\\system_menu_2_42.png\" />\r\n    <None Include=\"res\\system_menu_2_48.png\" />\r\n    <None Include=\"res\\system_menu_2_48_48.png\" />\r\n    <None Include=\"res\\system_menu_2_64_64.png\" />\r\n    <None Include=\"res\\system_menu_32_32.png\" />\r\n    <None Include=\"res\\Toolbar.bmp\" />\r\n    <None Include=\"res\\toolbar1.bmp\" />\r\n    <CustomBuild Include=\"RulerRichEditCtrl\\toolbar.bmp\">\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">true</ExcludedFromBuild>\r\n    </CustomBuild>\r\n    <None Include=\"res\\FILECOPY.AVI\" />\r\n    <None Include=\"res\\yellow_star_16_16.png\" />\r\n    <None Include=\"res\\yellow_star_20_20.png\" />\r\n    <None Include=\"res\\yellow_star_24_24.png\" />\r\n    <None Include=\"res\\yellow_star_32_32.png\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Manifest Include=\"DeclareDPIAware.manifest\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Midl Include=\"CP_Main.idl\">\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">false</MkTypLibCompatible>\r\n      <TargetEnvironment Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Win32</TargetEnvironment>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(ProjectName)_i.h</HeaderFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(ProjectName)_i.c</InterfaceIdentifierFileName>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</GenerateStublessProxies>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">false</MkTypLibCompatible>\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">false</MkTypLibCompatible>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">CP_Main_i.h</HeaderFileName>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">CP_Main_i.h</HeaderFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">CP_Main_i.c</InterfaceIdentifierFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">CP_Main_i.c</InterfaceIdentifierFileName>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</GenerateStublessProxies>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</GenerateStublessProxies>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">false</MkTypLibCompatible>\r\n      <TargetEnvironment Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Win32</TargetEnvironment>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">CP_Main_i.h</HeaderFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">CP_Main_i.c</InterfaceIdentifierFileName>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</GenerateStublessProxies>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">false</MkTypLibCompatible>\r\n      <MkTypLibCompatible Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">false</MkTypLibCompatible>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">CP_Main_i.h</HeaderFileName>\r\n      <HeaderFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">CP_Main_i.h</HeaderFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">CP_Main_i.c</InterfaceIdentifierFileName>\r\n      <InterfaceIdentifierFileName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">CP_Main_i.c</InterfaceIdentifierFileName>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</GenerateStublessProxies>\r\n      <GenerateStublessProxies Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">true</GenerateStublessProxies>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n      <TypeLibraryName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">$(IntDir)$(ProjectName).tlb</TypeLibraryName>\r\n    </Midl>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Image Include=\"res\\ChevronLeft_Black_36.png\" />\r\n    <Image Include=\"res\\ChevronLeft_Black_40.png\" />\r\n    <Image Include=\"res\\ChevronLeft_Black_44.png\" />\r\n    <Image Include=\"res\\ChevronLeft_Black_48.png\" />\r\n    <Image Include=\"res\\ChevronLeft_Black_52.png\" />\r\n    <Image Include=\"res\\ChevronLeft_Black_56.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_36.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_40.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_44.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_48.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_52.png\" />\r\n    <Image Include=\"res\\ChevronRight_Black_56.png\" />\r\n    <Image Include=\"res\\close_36.png\" />\r\n    <Image Include=\"res\\close_40.png\" />\r\n    <Image Include=\"res\\close_44.png\" />\r\n    <Image Include=\"res\\close_48.png\" />\r\n    <Image Include=\"res\\close_52.png\" />\r\n    <Image Include=\"res\\close_56.png\" />\r\n    <Image Include=\"res\\Ditto2_NoDb.ico\" />\r\n    <Image Include=\"res\\down_16.png\" />\r\n    <Image Include=\"res\\down_20.png\" />\r\n    <Image Include=\"res\\down_24.png\" />\r\n    <Image Include=\"res\\down_28.png\" />\r\n    <Image Include=\"res\\down_32.png\" />\r\n    <Image Include=\"res\\icon3.ico\" />\r\n    <Image Include=\"res\\maximize_36.png\" />\r\n    <Image Include=\"res\\maximize_40.png\" />\r\n    <Image Include=\"res\\maximize_44.png\" />\r\n    <Image Include=\"res\\maximize_48.png\" />\r\n    <Image Include=\"res\\maximize_512.png\" />\r\n    <Image Include=\"res\\maximize_52.png\" />\r\n    <Image Include=\"res\\maximize_56.png\" />\r\n    <Image Include=\"res\\minimize_36.png\" />\r\n    <Image Include=\"res\\minimize_40.png\" />\r\n    <Image Include=\"res\\minimize_44.png\" />\r\n    <Image Include=\"res\\minimize_48.png\" />\r\n    <Image Include=\"res\\minimize_52.png\" />\r\n    <Image Include=\"res\\minimize_56.png\" />\r\n    <Image Include=\"res\\open_folder_54.png\" />\r\n    <Image Include=\"res\\open_folder_60.png\" />\r\n    <Image Include=\"res\\open_folder_66.png\" />\r\n    <Image Include=\"res\\open_folder_72.png\" />\r\n    <Image Include=\"res\\open_folder_78.png\" />\r\n    <Image Include=\"res\\open_folder_84.png\" />\r\n    <Image Include=\"res\\search_close_20.png\" />\r\n    <Image Include=\"res\\search_close_24.png\" />\r\n    <Image Include=\"res\\search_close_28.png\" />\r\n    <Image Include=\"res\\search_close_32.png\" />\r\n    <Image Include=\"res\\system_menu_54.png\" />\r\n    <Image Include=\"res\\system_menu_60.png\" />\r\n    <Image Include=\"res\\system_menu_66.png\" />\r\n    <Image Include=\"res\\system_menu_72.png\" />\r\n    <Image Include=\"res\\system_menu_78.png\" />\r\n    <Image Include=\"res\\system_menu_84.png\" />\r\n  </ItemGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n    <Import Project=\"packages\\zlib-msvc-x86.1.2.11.8900\\build\\native\\zlib-msvc-x86.targets\" Condition=\"Exists('packages\\zlib-msvc-x86.1.2.11.8900\\build\\native\\zlib-msvc-x86.targets')\" />\r\n    <Import Project=\"packages\\zlib-msvc-x64.1.2.11.8900\\build\\native\\zlib-msvc-x64.targets\" Condition=\"Exists('packages\\zlib-msvc-x64.1.2.11.8900\\build\\native\\zlib-msvc-x64.targets')\" />\r\n  </ImportGroup>\r\n  <ProjectExtensions>\r\n    <VisualStudio>\r\n      <UserProperties RESOURCE_FILE=\"CP_Main.rc\" />\r\n    </VisualStudio>\r\n  </ProjectExtensions>\r\n  <Target Name=\"EnsureNuGetPackageBuildImports\" BeforeTargets=\"PrepareForBuild\">\r\n    <PropertyGroup>\r\n      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>\r\n    </PropertyGroup>\r\n    <Error Condition=\"!Exists('packages\\zlib-msvc-x86.1.2.11.8900\\build\\native\\zlib-msvc-x86.targets')\" Text=\"$([System.String]::Format('$(ErrorText)', 'packages\\zlib-msvc-x86.1.2.11.8900\\build\\native\\zlib-msvc-x86.targets'))\" />\r\n    <Error Condition=\"!Exists('packages\\zlib-msvc-x64.1.2.11.8900\\build\\native\\zlib-msvc-x64.targets')\" Text=\"$([System.String]::Format('$(ErrorText)', 'packages\\zlib-msvc-x64.1.2.11.8900\\build\\native\\zlib-msvc-x64.targets'))\" />\r\n  </Target>\r\n</Project>"
        },
        {
          "name": "CP_Main.vcxproj.filters",
          "type": "blob",
          "size": 44.1875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <ClCompile Include=\"sqlite\\CppSQLite3.cpp\">\r\n      <Filter>sqlite</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipboardSaveRestore.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Clip_ImportExport.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Clip.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Client.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CF_UnicodeTextAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CF_TextAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CF_HDropAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"BitmapHelper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"AutoSendToClientThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"AlphaBlend.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"AddType.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Accels.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"About.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipboardViewer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipFormatQListCtrl.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipIds.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CopyProperties.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CopyThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CP_Main.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Crc32Dynamic.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DatabaseUtilities.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DialogResizer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoAddins.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoCopyBuffer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ExternalWindowTracker.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FileRecieve.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FileSend.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FileTransferProgressDlg.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FormattedTextDraw.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FriendDetails.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupCombo.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupName.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupStatic.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GroupTree.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HListBox.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HTMLFormatAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HotKeys.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HyperLink.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MainFrm.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MainFrmThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MainTableFunctions.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MessagePumpThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MoveToGroupDlg.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MultiLanguage.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"NumberEdit.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OleClipSource.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionFriends.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Options.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsCopyBuffers.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsGeneral.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsKeyBoard.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsQuickPaste.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsSheet.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsStats.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"OptionsTypes.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Path.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"PerfTimer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Popup.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ProcessPaste.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ProgressWnd.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QListCtrl.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QPasteWnd.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QPasteWndThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QuickPaste.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RecieveSocket.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RichEditCtrlEx.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RichTextAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SaveAnimation.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SearchEditBox.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SendKeys.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SendSocket.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Server.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"StdAfx.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SystemTray.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TabCtrl.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Shared\\TextConvert.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Theme.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Shared\\Tokenizer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ToolTipEx.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"WildCardMatch.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"WndEx.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoAddin.cpp\">\r\n      <Filter>header</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoWindow.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"EventThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FormatSQL.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Misc.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ShowTaskBarIcon.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GlobalClips.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"EditWithButton.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GdipButton.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DPI.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"GdiImageDrawer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"MyDropTarget.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"UAC_Helper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"UAC_Thread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ActionEnums.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DeleteClipData.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipCompare.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QRCodeViewer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DrawHTML.C\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoPopupWindow.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TrayWnd.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SpecialPasteOptions.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ScrollHelper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"QuickPasteKeyboard.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"PowerManager.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ImageViewer.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"NTray.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinystr.cpp\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxml.cpp\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxmlerror.cpp\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"TinyXml\\tinyxmlparser.cpp\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SymbolEdit.cpp\" />\r\n    <ClCompile Include=\"ChaiScriptOnCopy.cpp\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ChaiScriptXml.cpp\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DittoChaiScript.cpp\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SimpleBrowser.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"AdvGeneral.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CustomFriendsHelper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DimWnd.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"FriendPromptDlg.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"Md5.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RegExFilterHelper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ScriptEditor.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SnapWindow.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SymbolEdit.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SendMail.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"NoDbFrameWnd.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ICU_String.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"sqlite\\sqlite3mc_amalgamation.c\">\r\n      <Filter>sqlite</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ClipEditThread.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ConvertRTFToText.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ImageHelper.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ImageFormatAggregator.cpp\">\r\n      <Filter>source</Filter>\r\n    </ClCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"sqlite\\CppSQLite3.h\">\r\n      <Filter>sqlite</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"About.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Accels.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"AddType.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"AlphaBlend.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ArrayEx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"AutoSendToClientThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"BitmapHelper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CF_HDropAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CF_TextAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CF_UnicodeTextAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Client.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Clip.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Clip_ImportExport.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipboardSaveRestore.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipboardViewer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipFormatQListCtrl.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipIds.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CopyProperties.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CopyThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CP_Main.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Crc32Dynamic.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DatabaseUtilities.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DialogResizer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoAddin.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoAddins.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoCopyBuffer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Shared\\DittoDefines.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoWindow.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"EventThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ExternalWindowTracker.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FileRecieve.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FileSend.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FileTransferProgressDlg.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FormatSQL.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FormattedTextDraw.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FriendDetails.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GroupCombo.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GroupName.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GroupStatic.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GroupTree.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HListBox.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HotKeys.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HTMLFormatAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HyperLink.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Shared\\IAddinExports.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Shared\\IClip.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"IClipAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RulerRichEditCtrl\\ids.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MainFrm.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MainFrmThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MainTableFunctions.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"memdc.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MessagePumpThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Misc.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MoveToGroupDlg.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MultiLanguage.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"NumberEdit.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OleClipSource.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionFriends.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Options.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsCopyBuffers.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsGeneral.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsKeyBoard.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsQuickPaste.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsSheet.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsStats.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"OptionsTypes.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Path.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"PerfTimer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Popup.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ProcessPaste.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ProgressWnd.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QListCtrl.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QPasteWnd.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QPasteWndThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QuickPaste.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RecieveSocket.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Resource.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RichEditCtrlEx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RichTextAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SaveAnimation.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SearchEditBox.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SendKeys.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SendSocket.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Server.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ServerDefines.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"StdAfx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RulerRichEditCtrl\\StdGrfx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SystemTray.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"TabCtrl.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Shared\\TextConvert.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Theme.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Shared\\Tokenizer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ToolTipEx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"UnicodeMacros.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"WildCardMatch.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"WndEx.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"TinyXml\\tinyxml.h\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"TinyXml\\tinystr.h\">\r\n      <Filter>tineyxml</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ShowTaskBarIcon.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GlobalClips.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"EditWithButton.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GdipButton.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CGdiPlusBitmap.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DPI.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GdiImageDrawer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"MyDropTarget.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"UAC_Thread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"UAC_Helper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ActionEnums.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DeleteClipData.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipCompare.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QRCodeViewer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DrawHTML.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoPopupWindow.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SpecialPasteOptions.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"TrayWnd.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ImageViewer.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"PowerManager.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"QuickPasteKeyboard.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ScrollHelper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"NTray.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SymbolEdit.h\" />\r\n    <ClInclude Include=\"ChaiScriptOnCopy.h\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ChaiScriptXml.h\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DittoChaiScript.h\">\r\n      <Filter>ChaiScript</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SimpleBrowser.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"AdvGeneral.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CustomFriendsHelper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DimWnd.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"FriendPromptDlg.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Md5.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RegExFilterHelper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ScriptEditor.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SnapWindow.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SymbolEdit.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SendMail.h\">\r\n      <Filter>source</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"Slugify.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"NoDbFrameWnd.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ICU_String.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"sqlite\\sqlite3mc_amalgamation.h\">\r\n      <Filter>sqlite</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ClipEditThread.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ConvertRTFToText.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ImageFormatAggregator.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ImageHelper.h\">\r\n      <Filter>header</Filter>\r\n    </ClInclude>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"CP_Main.rc\">\r\n      <Filter>res</Filter>\r\n    </ResourceCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <CustomBuild Include=\"RulerRichEditCtrl\\toolbar.bmp\">\r\n      <Filter>res</Filter>\r\n    </CustomBuild>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"res\\back.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\back1.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\back2.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\bitmap1.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\bmp00001.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\bmp00002.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\bmp00003.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\closed_f.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\CP_Main.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\CP_Main.rc2\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\CP_MainDoc.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Ditto.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Ditto_NoCopyCb.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\FILECOPY.AVI\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\mainfram.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_fol.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Toolbar.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\toolbar1.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\DittoNew.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Ditto2.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Ditto2_NoCopyCb.ico\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_close.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_normal.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\folder_open.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_close_125.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_normal_200.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_close_150.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_close_200.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_normal_125.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_normal_150.bmp\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\left-blue.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\shortcut.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_bottom_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_bottom_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_bottom_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_bottom_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_left_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_left_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_left_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_left_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_right_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_right_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_right_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_right_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_top_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_top_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_top_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\chevron_top_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\close_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\close_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\close_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\close_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_22_22.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\left_arrow_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\left_arrow_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\left_arrow_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\left_arrow_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\opened_folder_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\opened_folder_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\opened_folder_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\opened_folder_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_10_10.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_8_8.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_12_12.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\in_folder_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\in_folder_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\in_folder_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\in_folder_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\key_stroke_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\key_stroke_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\key_stroke_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\key_stroke_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Sticky_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Sticky_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Sticky_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Sticky_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\yellow_star_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\yellow_star_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\yellow_star_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\yellow_star_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"CP_Main.rgs\" />\r\n    <None Include=\"res\\Hamburger_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Hamburger_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Hamburger_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Hamburger_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronLeft_Black_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronLeft_Black_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronLeft_Black_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronLeft_Black_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronLeft_Black_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronRight_Black_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronRight_Black_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronRight_Black_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronRight_Black_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\ChevronRight_Black_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Close_Black_16_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Close_Black_20_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Close_Black_24_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Close_Black_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Close_Black_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\maximize_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\minimize_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\minimize_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\minimize_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\minimize_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\minimize_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\NewWindowIcon_24_14.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\NewWindowIcon_30.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\NewWindowIcon_36.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\NewWindowIcon_48.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Open Folder-24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Open Folder-32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_folder_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_folder_30.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_folder_36.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_folder_42.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\open_folder_48.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\return_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\return_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\return_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\return_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\return_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Search_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Search_20.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Search_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Search_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\Search_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\search_close_16.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_24.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_30.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_32_32.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_36.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_40_40.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_42.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_48.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_48_48.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\system_menu_2_64_64.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cog_28.png\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cursor1.cur\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cursor2.cur\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"res\\cursor_zoom_in.cur\">\r\n      <Filter>res</Filter>\r\n    </None>\r\n    <None Include=\"packages.config\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Filter Include=\"sqlite\">\r\n      <UniqueIdentifier>{eaee7285-53ac-40cb-bbb1-ad1b2d062d76}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"source\">\r\n      <UniqueIdentifier>{1214d206-a595-4227-bc65-0bec059e6cca}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"header\">\r\n      <UniqueIdentifier>{d16d4a45-7a56-46ac-a68b-9028c1ea8cd5}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"res\">\r\n      <UniqueIdentifier>{28deb94a-a909-4235-b9b6-b51408b11b6b}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"tineyxml\">\r\n      <UniqueIdentifier>{08b8a44d-887f-48e0-8396-e9e9f573f337}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"ChaiScript\">\r\n      <UniqueIdentifier>{13844e6c-68be-44ca-93c7-1f0b08f0b319}</UniqueIdentifier>\r\n    </Filter>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Manifest Include=\"DeclareDPIAware.manifest\">\r\n      <Filter>header</Filter>\r\n    </Manifest>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Midl Include=\"CP_Main.idl\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <Image Include=\"res\\ChevronLeft_Black_36.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronLeft_Black_40.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronLeft_Black_44.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronLeft_Black_48.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronLeft_Black_52.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronLeft_Black_56.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_36.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_40.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_44.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_48.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_52.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\ChevronRight_Black_56.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_36.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_40.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_44.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_48.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_52.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\close_56.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\down_16.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\down_20.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\down_24.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\down_28.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\down_32.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_36.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_40.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_44.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_48.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_52.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_56.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_36.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\maximize_512.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_40.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_44.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_48.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_52.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\minimize_56.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_54.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_60.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_66.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_72.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_78.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\open_folder_84.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_54.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_60.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_66.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_72.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_78.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\system_menu_84.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\icon3.ico\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\search_close_20.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\search_close_24.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\search_close_28.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\search_close_32.png\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n    <Image Include=\"res\\Ditto2_NoDb.ico\">\r\n      <Filter>res</Filter>\r\n    </Image>\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "CP_Main_10.sln",
          "type": "blob",
          "size": 7.1953125,
          "content": "Microsoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.5.33103.201\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"CP_Main\", \"CP_Main.vcxproj\", \"{8ECC3EF2-AF07-27B6-A773-779874943C0D}\"\r\n\tProjectSection(ProjectDependencies) = postProject\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958} = {F08A8736-1116-4166-AF88-CF533E41E958}\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1} = {1FA87564-F5EC-42F8-978C-E827AAB54CB1}\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95} = {CF8F6379-5340-4494-8E59-2807ADF37B95}\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500} = {E4AB8C80-F35F-451E-853B-07CEDD49E500}\r\n\tEndProjectSection\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"DittoUtil\", \"Addins\\DittoUtil\\DittoUtil.vcxproj\", \"{CF8F6379-5340-4494-8E59-2807ADF37B95}\"\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"EncryptDecrypt\", \"EncryptDecrypt\\EncryptDecrypt.vcxproj\", \"{F08A8736-1116-4166-AF88-CF533E41E958}\"\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"focus\", \"focusdll\\focus.vcxproj\", \"{E4AB8C80-F35F-451E-853B-07CEDD49E500}\"\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"FocusHighlight\", \"FocusHighlight\\FocusHighlight.vcxproj\", \"{385F3F81-896E-41EF-AE32-98D8A026588F}\"\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"ICU_Loader\", \"ICU_Loader\\ICU_Loader.vcxproj\", \"{1FA87564-F5EC-42F8-978C-E827AAB54CB1}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|ARM64 = Debug|ARM64\r\n\t\tDebug|Win32 = Debug|Win32\r\n\t\tDebug|x64 = Debug|x64\r\n\t\tRelease|ARM64 = Release|ARM64\r\n\t\tRelease|Win32 = Release|Win32\r\n\t\tRelease|x64 = Release|x64\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{8ECC3EF2-AF07-27B6-A773-779874943C0D}.Release|x64.Build.0 = Release|x64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{CF8F6379-5340-4494-8E59-2807ADF37B95}.Release|x64.Build.0 = Release|x64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{F08A8736-1116-4166-AF88-CF533E41E958}.Release|x64.Build.0 = Release|x64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{E4AB8C80-F35F-451E-853B-07CEDD49E500}.Release|x64.Build.0 = Release|x64\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Debug|x64.ActiveCfg = Debug|Win32\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{385F3F81-896E-41EF-AE32-98D8A026588F}.Release|x64.ActiveCfg = Release|Win32\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|ARM64.ActiveCfg = Debug|ARM64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|ARM64.Build.0 = Debug|ARM64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|ARM64.ActiveCfg = Release|ARM64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|ARM64.Build.0 = Release|ARM64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{1FA87564-F5EC-42F8-978C-E827AAB54CB1}.Release|x64.Build.0 = Release|x64\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {ADD68868-6B60-4589-84C4-2244AE013366}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "ChaiScriptOnCopy.cpp",
          "type": "blob",
          "size": 2.9052734375,
          "content": "#include \"stdafx.h\"\n#include \"ChaiScriptOnCopy.h\"\n#include \"Shared\\TextConvert.h\"\n\n#include \"chaiscript/chaiscript.hpp\"\n\nusing namespace chaiscript;\n\n\nChaiScriptOnCopy::ChaiScriptOnCopy()\n{\n}\n\n\nChaiScriptOnCopy::~ChaiScriptOnCopy()\n{\n}\n\nstd::string FormatCurrentTime(const std::string &format) {\n\tCTime t = CTime::GetCurrentTime();\n\tCStringA x = t.Format(format.c_str());\n\treturn x;\n}\n\nbool ChaiScriptOnCopy::ProcessScript(CDittoChaiScript &clipData, std::string script)\n{\n\tm_lastError = _T(\"\");\n\tbool continueCopy = true;\n\t \n\ttry\n\t{\n\t\tChaiScript chai;\n\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::GetClipMD5), \"GetClipMD5\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::GetClipSize), \"GetClipSize\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::GetAsciiString), \"GetAsciiString\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::SetAsciiString), \"SetAsciiString\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::GetActiveApp), \"GetActiveApp\");\n\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::GetActiveAppTitle), \"GetActiveAppTitle\");\n\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::SetMakeTopSticky), \"SetMakeTopSticky\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::SetMakeLastSticky), \"SetMakeLastSticky\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::SetReplaceTopSticky), \"SetReplaceTopSticky\");\n\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::FormatExists), \"FormatExists\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::RemoveFormat), \"RemoveFormat\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::SetParentId), \"SetParentId\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::AsciiTextMatchesRegex), \"AsciiTextMatchesRegex\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::AsciiTextReplaceRegex), \"AsciiTextReplaceRegex\");\n\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::DescriptionMatchesRegex), \"DescriptionMatchesRegex\");\n\t\tchai.add(chaiscript::fun(&CDittoChaiScript::DescriptionReplaceRegex), \"DescriptionReplaceRegex\");\n\n\t\tchai.add(chaiscript::fun(&FormatCurrentTime), \"FormatCurrentTime\");\n\n\t\tchai.add(chaiscript::var(&clipData), \"clip\");\n\n\t\t//loop over all scripts\n\t\t/*std::string script = R\"\"(\t\n\t\t\t\t\t\t\t\t\tvar md5 = clip.GetClipMD5(13)\n\t\t\t\t\t\t\t\t\treturn md5 == \"4FF8DB22A28559FB23AB9EB90523AE3E\"\n\t\t\t\t\t\t\t\t)\"\";*/\n\n\n\t\tBoxed_Value bv = chai.eval(script);\n\t\tif (chaiscript::boxed_cast<bool> (bv) == true)\n\t\t{\n\t\t\tm_lastError = _T(\"Script returned true, canceling copy\");\n\t\t\tcontinueCopy = false;\n\t\t}\n\t}\n\tcatch (const chaiscript::exception::eval_error &ee)\n\t{\n\t\tstd::string eString;\n\t\teString += ee.pretty_print();\n\n\t\tm_lastError = CTextConvert::AnsiToUnicode(eString.c_str());\n\t}\n\tcatch (std::exception &e)\n\t{\n\t\tstd::string eString;\n\t\teString += e.what();\n\n\t\tm_lastError = CTextConvert::AnsiToUnicode(eString.c_str());\n\t}\n\tcatch (CException *ex)\n\t{\n\t\tTCHAR szCause[255];\n\t\tex->GetErrorMessage(szCause, 255);\n\t\tm_lastError.Format(_T(\"ProcessScript exception: %s\"), szCause);\n\t}\n\tcatch (...)\n\t{\n\t\tm_lastError.Format(_T(\"ProcessScript exception\"));\n\t}\n\n\treturn continueCopy;\n}\n"
        },
        {
          "name": "ChaiScriptOnCopy.h",
          "type": "blob",
          "size": 0.2294921875,
          "content": "#pragma once\n\n#include \"DittoChaiScript.h\"\n#include <string>\n\nclass ChaiScriptOnCopy\n{\npublic:\n\tChaiScriptOnCopy();\n\t~ChaiScriptOnCopy();\n\n\tbool ProcessScript(CDittoChaiScript &clipData, std::string script);\n\n\tCString m_lastError;\n};\n\n"
        },
        {
          "name": "ChaiScriptXml.cpp",
          "type": "blob",
          "size": 3.318359375,
          "content": "#include \"stdafx.h\"\n#include \"ChaiScriptXml.h\"\n#include \"tinyxml\\tinyxml.h\"\n#include \"Shared\\TextConvert.h\"\n#include \"Misc.h\"\n#include \"ActionEnums.h\"\n\n\nCChaiScriptXml::CChaiScriptXml()\n{\n\tm_assignedGuidOnLoad = false;\n}\n\n\nCChaiScriptXml::~CChaiScriptXml()\n{\n}\n\nCString CChaiScriptXml::GetScript(CString name, BOOL &active)\n{\n\tCString script;\n\tfor (auto & listItem : m_list)\n\t{\n\t\tif (listItem.m_name == name)\n\t\t{\n\t\t\tactive = listItem.m_active;\n\t\t\tscript = listItem.m_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn script;\n}\n\nvoid CChaiScriptXml::Load(CString values)\n{\n\tm_assignedGuidOnLoad = false;\n\tm_list.clear();\n\t\n\tTiXmlDocument doc;\n\tCStringA xmlA = CTextConvert::UnicodeToUTF8(values);\n\tdoc.Parse(xmlA);\n\n\tTiXmlElement *ItemHeader = doc.FirstChildElement(\"ChaiScripts\");\n\n\tif (ItemHeader != NULL)\n\t{\n\t\tTiXmlElement *ItemElement = ItemHeader->FirstChildElement();\n\n\t\twhile (ItemElement)\n\t\t{\n\t\t\tCDittoChaiScriptXmlItem array_item;\n\t\t\tItemElement->Attribute(\"active\", &array_item.m_active);\n\t\t\tarray_item.m_name = ItemElement->Attribute(\"name\");\n\t\t\tarray_item.m_description = ItemElement->Attribute(\"description\");\n\t\t\tarray_item.m_script = ItemElement->Attribute(\"script\");\n\t\t\tarray_item.m_guid = ItemElement->Attribute(\"guid\");\n\t\t\tarray_item.m_version = ItemElement->Attribute(\"vesion\");\n\n\t\t\tif (array_item.m_guid == \"\")\n\t\t\t{\n\t\t\t\tarray_item.m_guid = NewGuidString();\n\t\t\t\tm_assignedGuidOnLoad = true;\n\t\t\t}\n\n\t\t\tm_list.push_back(array_item);\n\n\t\t\tItemElement = ItemElement->NextSiblingElement();\n\t\t}\n\t}\n}\n\nCString CChaiScriptXml::Save()\n{\n\tm_assignedGuidOnLoad = false;\n\tTiXmlDocument doc;\n\n\tTiXmlElement* friendOuter = new TiXmlElement(\"ChaiScripts\");\n\tdoc.LinkEndChild(friendOuter);\n\n\tfor (auto & listItem : m_list)\n\t{\n\t\tTiXmlElement* friendElement = new TiXmlElement(\"ChaiScriptItem\");\n\n\t\tfriendElement->SetAttribute(\"active\", listItem.m_active);\n\n\t\tCStringA name = CTextConvert::UnicodeToUTF8(listItem.m_name);\n\t\tfriendElement->SetAttribute(\"name\", name);\n\n\t\tCStringA desc = CTextConvert::UnicodeToUTF8(listItem.m_description);\n\t\tfriendElement->SetAttribute(\"description\", desc);\n\n\t\tCStringA script = CTextConvert::UnicodeToUTF8(listItem.m_script);\n\t\tfriendElement->SetAttribute(\"script\", script);\n\n\t\tCStringA guid = CTextConvert::UnicodeToUTF8(listItem.m_guid);\n\t\tfriendElement->SetAttribute(\"guid\", guid);\n\n\t\tCStringA version = CTextConvert::UnicodeToUTF8(listItem.m_version);\n\t\tfriendElement->SetAttribute(\"version\", version);\n\n\t\tfriendOuter->LinkEndChild(friendElement);\n\t}\n\n\tTiXmlPrinter printer;\n\tprinter.SetLineBreak(\"\");\n\tdoc.Accept(&printer);\n\tCString cs = printer.CStr();\n\n\treturn cs;\n}\n\nvoid CChaiScriptXml::AddToMenu(CMenu *pMenu, CAccels *actions)\n{\n\tif (m_list.size() > 0)\n\t{\n\t\tpMenu->AppendMenu(MF_SEPARATOR);\n\n\t\tbool addedItem = false;\n\t\tint id = 0;\n\t\tfor (auto & element : m_list)\n\t\t{\n\t\t\tif (addedItem == false)\n\t\t\t{\n\t\t\t\taddedItem = true;\n\t\t\t}\n\n\t\t\tCString cs;\n\t\t\tif (element.m_description != _T(\"\"))\n\t\t\t{\n\t\t\t\tcs.Format(_T(\"(%s) - %s\"), element.m_name, element.m_description);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcs.Format(_T(\"%s\"), element.m_name);\n\t\t\t}\n\n\t\t\tif (actions != NULL)\n\t\t\t{\n\t\t\t\tCString shortcutText = actions->GetCmdKeyText(ActionEnums::PASTE_SCRIPT, element.m_guid);\n\t\t\t\tif (shortcutText != _T(\"\"))\n\t\t\t\t{\n\t\t\t\t\tcs += \"\\t\";\n\t\t\t\t\tcs += shortcutText;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpMenu->AppendMenuW(MF_STRING, (ChaiScriptMenuStartId + id), cs);\n\t\t\tid++;\n\n\t\t\tif (id > MaxChaiScripts)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
          "name": "ChaiScriptXml.h",
          "type": "blob",
          "size": 0.6259765625,
          "content": "#pragma once\n\n#include <vector>\n#include \"Accels.h\"\n\n#define ChaiScriptMenuStartId 5001\n#define MaxChaiScripts 99\n\nclass CDittoChaiScriptXmlItem\n{\npublic:\n\tCDittoChaiScriptXmlItem()\n\t{\n\t\tm_active = FALSE;\n\t\tm_version = \"1.0.0.0\";\n\t}\n\tBOOL m_active;\n\tCString m_name;\n\tCString m_description;\n\tCString m_script;\n\tCString m_guid;\n\tCString m_version;\n};\n\nclass CChaiScriptXml\n{\npublic:\n\tCChaiScriptXml();\n\t~CChaiScriptXml();\n\n\tCString Save();\n\tvoid Load(CString values);\n\tCString GetScript(CString name, BOOL &active);\t\n\tvoid AddToMenu(CMenu *pMenu, CAccels *actions);\n\n\tstd::vector<CDittoChaiScriptXmlItem> m_list;\n\tbool m_assignedGuidOnLoad;\n};"
        },
        {
          "name": "Changes.txt",
          "type": "blob",
          "size": 10.779296875,
          "content": "04 Aug 31\n---------\n! Fixed \"Corrupted QuickPaste position when closing Ditto while minimized /\n  rolled-up\" bug.\n  . Reported By: Anthony Ford - tonyforduk 2004-08-27 14:08\n    http://sourceforge.net/forum/message.php?msg_id=2732759\n  * CWndEx::GetWindowRectEx() was not properly copying m_crFullSizeWindow\n    when m_bMinimized was true.\n\n\n04 May 30\n---------\n+ Toggle Connect to Clipboard to Connect or Disconnect the\n  Clipboard Viewer from the chain.\n  - removed \"Reconnect to Clipboad Chain\"\n\n+ focus.dll and system-wide focus tracking implementation to correct\n  mouse tray activation.\n\n+ Sending clips across a network.\n\n\n04 Jan 20\n---------\n! Fixed \"multiple repaints on first show\" bug.\n  * CQuickPaste::ShowQPasteWnd:\n    - m_pwndPaste->ShowWindow(SW_SHOW)\n      . This caused premature drawing and activation of the window.\n        It was replaced by a call to:\n    + m_pwndPaste->ShowQPasteWindow()\n    \n  * CQPasteWnd:\n    + bool m_bAllowRepaintImmediately:\n      . This acts as an override for RefreshNc's bRepaintImmediately parameter,\n        thereby stopping the status (titlebar) from being repeatedly redrawn\n        during ShowQPasteWindow.\n\n* Misc. Painting Improvements:\n  ! CWndEx::InvalidateNc(): redraw with RDW_NOCHILDREN\n    . The client area was being invalidated without this.\n  * CQListCtrl::OnEraseBkgnd(): faster when shift-scrolling.\n  * CQListCtrl::OnSelectionChange(): delayed SetStatus for faster selection.\n\n\n03 Sept 22\n----------\n+ Shared Data: Data can now be shared amongst multiple Clips.\n  + DittoDB.mdb: Main.lDataID, Data.lDataID\n  * SQL statements, e.g. INNER JOIN through Main.lID\n  \n+ Groups:\n  + DittoDB.mdb: Main.bIsGroup, Main.lParentID, Main.dOrder\n  * CCP_MainApp:\n    + long    m_GroupDefaultID; // new clips are saved to this group\n    + long    m_GroupID;        // current group\n    + long    m_GroupParentID;  // current group's parent\n    + CString m_GroupText;      // current group's description\n    +\tBOOL EnterGroupID( long lID );\n    + long GetValidGroupID(); // returns a valid id (not negative)\n    + void SetGroupDefaultID( long lID ); // sets a valid id\n\n+ Internal Clipboard for cut/copy/paste items between Groups\n  CCP_MainApp:\n  + bool      m_IC_bCopy; // true to copy the items, false to move them\n  + CClipIDs  m_IC_IDs;   // buffer\n  + void IC_Cut( ARRAY* pIDs = NULL ); // if NULL, use current QPaste selection\n  + void IC_Copy( ARRAY* pIDs = NULL ); // if NULL, use current QPaste selection\n  + void IC_Paste();\n\n+ Persistent QPasteWnd focus item\n  + CCP_MainApp: long m_FocusID; // the ID given focus by CQPasteWnd::FillList\n\t* CQPasteWnd::FillList\n\n+ Item Description: Show Leading WhiteSpace\n  + CString CMainTable::GetDisplayText()\n  * void CQPasteWnd::OnGetToolTipText()\n  * CGetSetOptions:\n    + static BOOL    m_bDescShowLeadingWhiteSpace;\n    + static void SetDescShowLeadingWhiteSpace(BOOL bVal);\n    + static BOOL GetDescShowLeadingWhiteSpace();\n\n+ QListCtrl Keys:\n  +        F7: Create a New Group\n  +   Ctrl-F7: Create a New Group of Selected Elements\n  + Backspace: Go to parent group\n  +     Enter: Enter group or paste if clip\n  +  Alt-Home: Go to History Group\n  +   Alt-End: List all top level Groups\n  +    Ctrl-X: Move selection (establishes the source)\n  +    Ctrl-C: Copy selection (establishes the source)\n  +    Ctrl-V: Paste selection (Move or Copy)\n\n\n03 Sept 14\n----------\n+ View caption on all sides (top, right, bottom, left)\n+ Roll up window by button on caption or by auto roll up (rolls up when it looses focus)\n\n\n03 Sept 10\n----------\n+ HistoryStartTop - History can be shown top-down or bottom-up\n  + CGetSetOptions::m_bHistoryStartTop, SetHistoryStartTop, GetHistoryStartTop\n  + BOOL CQPasteWnd::m_bAscending - sort ascending (true) or descending (false)\n  * OptionsQuickPaste - added checkbox\n  * CQListCtrl::\n    + BOOL m_bStartTop - start at the top (true) or the bottom (false)\n    + BOOL SetListPos( int index ) - moves cursor to a single index position\n    + int GetFirstTenNum( int index ) - convert index to number\n    + int GetFirstTenIndex( int num ) - convert number to index\n    * OnCustomdrawList() - draws FirstTen block top or bottom\n    * PreTranslateMessage() - handles FirstTen block (1-9,0) accelerators\n    \n+ CPopup - Manually display tooltips (Misc.h/.cpp)\n\n+ View Full Description by pressing F3 using CPopup\n  CQListCtrl::\n    + CPopup m_Popup\n    + OnKillFocus - removes Popup\n    * PreTranslateMessage - handles F3 key\n\n* CopyProperties\n  + CTokenizer (ASCII only) (Misc.h/.cpp)\n  * Multiple delimiter characters are used rather than a single separator string.\n  * Defaults to Focus on Description when not a NamedCopy\n  * Uses CPopup for status\n\n\n03 Sept 8\n---------\n+ static bool CDataTable::DeleteParent( long lParentID )\n  . Deletes all records in Data Table with the given \"lParentID\"\n  \n+ Show Target Name in Status (TitleBar)\n\n+ Ensure Connected to Clipboard Viewer Chain using dummy WM_DRAWCLIPBOARD\n  CClipboardViewer:\n  * OnCreate: SetTimer(TIMER_ENSURE_VIEWER_IN_CHAIN, ONE_MINUTE, 0);\n  * WM_CV_RECONNECT - force reconnect if not in chain.\n  * WM_CV_IS_CONNECTED - performs a ping of chain.\n\n+ Custom Accelerators\n  + Misc.h/.cpp: CAccel and CAccels\n  ! fixes bug \"can't use accelerators with clip IDs > 65535 (USHRT_MAX)\"\n    . this was due to win32 ACCEL only capable of handling a WORD cmd\n\n* Moved SendPaste to CCP_Main to implicitly use Target\n\n\n03 Sept 5\n---------\n+ Snap to window now works on multiple monitors\n\n\n03 Sept 4\n---------\n+ Ditto window snaps to window sides\n\n\n03 Sept 3\n---------\n+ Text Item Parser in CopyProperties - parses a CF_TEXT item into multiple\n  CF_TEXT items based upon a given separator string.\n  + CEdit m_ParseEdit\n  + CButton m_ParseButton\n  + void OnBnClickedParseButton()\n  + Misc \n    + BYTE GetEscapeChar( BYTE ch );\n    + CString RemoveEscapes( const char* str );\n\n+ CClip::AddFormat\n\n+ CClipList::AddToDB( bool bLatestTime = false, bool bShowStatus = true )\n\n* CClipFormat frees m_hgData on destruction\n\n* changed CCP_MainApp::SaveAllClips to CCP_MainApp::SaveCopyClips\n\n* changed CCP_MainApp::FixTime to CClip::MakeLatestTime()\n\n! fixed bad connect / disconnect logic in CClipboardViewer\n\n\n03 Sept 2\n---------\n+ ShowPersistent: always-on-top \"persistent show\"\n  . Toggled by double clicking the titlebar or <Ctrl>-<Space>\n  + theApp.ShowPersistent( bool bVal )\n  * required modification of Target window tracking system.\n\n+ Misc.h/.cpp\n  + Utility functions (HGLOBAL funcs, IsAppWnd, StrF)\n  + Debug functions (Log, SetThreadName)\n\n* ProcessCopy - redesigned to fix the fast copy bugs.\n  . The same source object is used for the description as is stored in the db.\n  . Actual copying from the clipboard is (usually) not interrupted.\n  + CClip - For managing a Clip (copy of the clipboard) as a single unit.\n  + CCopyThread - handles copying the clipboard when the clipboard changes and\n      safely communicating with the Main thread.\n  + CClipboardViewer - the Clipboard Viewer window (code factored out from\n      MainWnd)\n  + uses AllowDuplicates (non-sequential duplicates) flag\n\n* ProcessPaste - redesigned for delayed rendering during drag and drop and\n  immediate rendering otherwise.\n  + uses UpdateTimeOnPaste flag\n  + uses SaveMultiPaste flag\n    \n* CCP_MainApp Copy and Paste Management\n  + bool EnableCbCopy(bool bState); // copy clipboad when it changes\n  + long SaveAllClips();  // saves all clips copied by CCopyThread\n  + void ReloadTypes();   // reloads the Types Table on demand\n  + void Delayed_RemoveOldEntries( UINT delay ); // based on timer\n  + void RefreshView();   // refreshes the view if it is visible\n  + void OnCopyCompleted( long lLastID, int count = 1 );\n  + void OnPasteCompleted();\n  + void SetStatus(char*) // for displaying status in the titlebar.\n\n* Targeting the previous focus window\n  + CCP_MainApp::\n    + HWND m_hTargetWnd;\n    + HWND TargetActiveWindow();\n    + bool ActivateTarget();\n    + bool ReleaseFocus(); // activate the target only if we are foreground\n  * The foreground window is tracked rather than the focus window.\n    . I think SetFocus doesn't do anything unless the hWnd is associated\n      with our thread's message queue.  \n  + Targeting the previous focus window is handled properly when\n    Ditto is activated by:\n      1. Mouse (in CMainFrame::PreTranslateMessage) OR\n      2. HotKey (in CQuickPaste::ShowQPasteWnd)\n !! Problems with Targeting still exist when Ditto is activated by a\n    separate application (e.g. <Alt>-<Tab> or Taskbar Tray).  This may\n    eventually be fixed by using a system hook.\n    . See source comment preceding TargetActiveWindow() in CP_Main.cpp\n  \n* Streamlined <Ctrl> 0-9 Accelerators - now handled entirely in\n  CQListCtrl::PreTranslateMessage\n  - removed HACCEL m_acFirstTen in CQListCtrl\n\n* WndEx\n  ! fixed the close \"x\" button display\n  + bool SetCaptionColors( COLORREF left, COLORREF right );\n  + bool SetCaptionColorActive( bool bVal );\n\n* Startup / Shutdown \n  + CCP_MainApp::\n    + bool m_bAppRunning;\n    + bool m_bAppExiting;\n    + CMainFrame* m_pMainFrame; // for quick access\n    + void AfterMainCreate();  // called after main window creation\n    + void BeforeMainClose();  // called before main window close\n\n* CGetSetOptions  \n  + Accessible through new global g_Opt\n  + Some local flag variables so that always getting from Profile (registry)\n    is not necessary (flags loaded on construction of g_Opt).\n\n* System HotKeys - Consolidated code in order to make adding and removing\n  HotKeys programmatically easier. \n  + class CHotKey and CHotKeys (g_HotKeys) in Misc.h/.cpp\n  + CCP_MainApp\n    + CHotKey*  m_pDittoHotKey; // activate ditto's qpaste window\n    + CHotKey*  m_pCopyHotKey;  // named copy\n  . HotKey Management:\n    . Create in CCP_MainApp::AfterMainCreate()\n    . Handle in CMainFrame::OnHotKey()\n    . Control user input in OptionsKeyBoard.\n\n\n03 Aug 8\n--------\n+ Implemented Multi-Selection Paste for CF_TEXT clips by \"\\r\\n\" concatenation\n  * CQPasteWnd::OnListSelect()\n  + BOOL CProcessPaste::MultiPaste( int numIDs, int* pIDs, HWND hWnd );\n  + BOOL CProcessPaste::MultiDrag( int numIDs, int* pIDs, HWND hWnd );\n  + CString CProcessPaste::AggregateText(int numIDs, int* pIDs, UINT uiPastType, char* pSeparator);\n  + bool CopyToGlobal( HGLOBAL hGlobal, LPVOID pBuf, ULONG ulBufLen )\n  + HGLOBAL NewGlobal( LPVOID pBuf, ULONG ulBufLen )\n\n* After a delete, position caret at first item deleted.\n  * void CQPasteWnd::DeleteSelectedRows()\n\n! Fixed Error \"query too complex\" when deleting large number of Clips\n  * void CQPasteWnd::DeleteSelectedRows()\n  + static BOOL CMainTable::DeleteAllClips();\n  + static BOOL CMainTable::DeleteClip( int id );\n  + static BOOL CMainTable::DeleteClips(ARRAY &IDs); (was called DeleteRows)\n\n\n03 Aug 16\n---------\n! Perform GlobalUnlock after memcmp.\n  * CDataTable::DataEqual\n\n! Fixed \"random\" termination.\n  * CMainFrame::OnTimer: added breaks to cases of switch.\n\n\n03 Aug 11\n---------\n! Fixed string error in processcopy.cpp\n\n\nLegend:\n+ = added\n- = removed\n* = modified\n! = fixed\n. = info\n"
        },
        {
          "name": "Client.cpp",
          "type": "blob",
          "size": 9.4970703125,
          "content": "// Client.cpp: implementation of the CClient class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"Client.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"RecieveSocket.h\"\r\n#include \"FileRecieve.h\"\r\n#include \"FileTransferProgressDlg.h\"\r\n#include \"Shared/Tokenizer.h\"\r\n\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nBOOL SendToFriend(CSendToFriendInfo &Info)\r\n{\r\n\tLogSendRecieveInfo(\"@@@@@@@@@@@@@@@ - START OF Send To Friend - @@@@@@@@@@@@@@@\");\r\n\r\n\tif(Info.m_csIP == _T(\"\"))\t\r\n\t{\r\n\t\tInfo.m_csErrorText = StrF(_T(\"ERROR getting ip/host name position - %s\"), Info.m_csIP);\r\n\t\tLogSendRecieveInfo(Info.m_csErrorText);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tLogSendRecieveInfo(StrF(_T(\"Sending clip to %s\"), Info.m_csIP));\r\n\tCClient client;\r\n\r\n\tif(client.OpenConnection(Info.m_csIP) == FALSE)\r\n\t{\r\n\t\tInfo.m_csErrorText = StrF(_T(\"ERROR opening connection to %s\"), Info.m_csIP);\r\n\t\tLogSendRecieveInfo(Info.m_csErrorText);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tINT_PTR count = Info.m_pClipList->GetCount();\r\n\tint i = -1;\r\n\r\n\tCClip* pClip;\r\n\tPOSITION pos;\r\n\tpos = Info.m_pClipList->GetHeadPosition();\r\n\twhile(pos)\r\n\t{\r\n\t\tpClip = Info.m_pClipList->GetNext(pos);\r\n\t\tif(pClip == NULL)\r\n\t\t{\r\n\t\t\tASSERT(FALSE);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ti++;\r\n\r\n\t\tif(Info.m_pPopup)\r\n\t\t{\r\n\t\t\tInfo.m_pPopup->SendToolTipText(StrF(_T(\"Sending %d of %d\"), i+1, count));\r\n\t\t}\r\n\r\n\t\tMSG\tmsg;\r\n\t\twhile(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\r\n\t\t{\r\n\t\t\tTranslateMessage(&msg);\r\n\t\t\tDispatchMessage(&msg);\r\n\t\t}\r\n\r\n\t\tLogSendRecieveInfo(StrF(_T(\"Sending %d of %d clip to %s\"), i+1, count, Info.m_csIP));\r\n\r\n\t\tif(client.SendItem(pClip, Info.m_manualSend) == FALSE)\r\n\t\t{\r\n\t\t\tInfo.m_csErrorText = \"ERROR SendItem Failed\";\r\n\t\t\tLogSendRecieveInfo(Info.m_csErrorText);\r\n\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\tLogSendRecieveInfo(\"@@@@@@@@@@@@@@@ - END OF Send To Friend - @@@@@@@@@@@@@@@\");\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nCClient::CClient()\r\n{\r\n\tm_Connection = NULL;\r\n\tm_connectionPort = 0;\r\n}\r\n\r\nCClient::~CClient()\r\n{\t\t\t\r\n\tCloseConnection();\r\n}\r\n\r\nBOOL CClient::CloseConnection()\r\n{\r\n\tif(m_Connection != NULL && m_Connection != 0)\r\n\t{\r\n\t\tCSendInfo Info;\r\n\t\tm_SendSocket.SendCSendData(Info, MyEnums::EXIT);\r\n\r\n\t\tclosesocket(m_Connection);\r\n\t\tWSACleanup();\r\n\r\n\t\tm_Connection = NULL;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CClient::OpenConnection(const TCHAR* servername)\r\n{\r\n\tWSADATA wsaData;\r\n\tunsigned int addr = INADDR_NONE;\r\n\tstruct sockaddr_in server;\r\n\tint wsaret=WSAStartup(0x101,&wsaData);\r\n\tif(wsaret)\t\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - WSAStartup(0x101,&wsaData)\");\r\n\t\treturn FALSE;\r\n\t}\r\n\t\r\n\tm_Connection = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\r\n\r\n\tif(m_Connection == INVALID_SOCKET)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)\");\r\n\t\t\r\n\t\tm_Connection = NULL;\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tCString parsedServerName = servername;\r\n\tm_connectionPort = CGetSetOptions::m_lPort;\r\n\r\n\tCTokenizer tokenizer(servername, \":\");\r\n\tCString token;\r\n\tint pos = 0;\r\n\twhile (tokenizer.Next(token))\r\n\t{\r\n\t\tif (pos == 0)\r\n\t\t{\r\n\t\t\tparsedServerName = token;\r\n\t\t}\r\n\t\telse if (pos == 1)\r\n\t\t{\r\n\t\t\tm_connectionPort = ATOI(token);\r\n\t\t}\r\n\t\tpos++;\r\n\t}\r\n\r\n\tCStringA csServerNameA = CTextConvert::UnicodeToAnsi(parsedServerName);\r\n\r\n\t//11-5-06 Serge Baranov found that if we are passing in an ip then\r\n\t//don't look the name up using gethostbyname/gethostbyaddr->\r\n\t//on simple networks that don't use DNS these will fail.\r\n\t//So now only lookup the host name if they don't provide an IP.\t\r\n\taddr = inet_addr(csServerNameA);\r\n\tif(addr == INADDR_NONE)\r\n\t{\r\n\t\tstruct hostent *hp = gethostbyname(csServerNameA);\r\n\t\tif(hp != NULL)\r\n\t\t{\r\n\t\t\taddr = *(unsigned int*)hp->h_addr;\r\n\t\t}\r\n\t}\r\n\r\n\tif(addr == NULL || addr == INADDR_NONE)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"addr == NULL || addr == INADDR_NONE\");\r\n\r\n\t\tclosesocket(m_Connection);\r\n\t\tm_Connection = NULL;\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tserver.sin_addr.s_addr = addr;\r\n\tserver.sin_family = AF_INET;\r\n\tserver.sin_port = htons((u_short)m_connectionPort);\r\n\tif(connect(m_Connection, (struct sockaddr*)&server, sizeof(server)))\r\n\t{\r\n\t\tint nWhy = WSAGetLastError();\r\n\t\tLogSendRecieveInfo(StrF(_T(\"ERROR if(connect(m_Connection,(struct sockaddr*)&server,sizeof(server))) why = %d\"), nWhy));\r\n\t\tclosesocket(m_Connection);\r\n\t\tm_Connection = NULL;\r\n\t\treturn FALSE;\t\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CClient::SendItem(CClip *pClip, bool manualSend)\r\n{\r\n\tCSendInfo Info;\r\n\r\n\tInfo.m_manualSend = manualSend;\r\n\r\n\t////only send a response port if it's different than the default\r\n\tif (CGetSetOptions::m_lPort != 23443 || m_connectionPort != 23443)\r\n\t{\r\n\t\tInfo.m_respondPort = CGetSetOptions::m_lPort;\r\n\t}\r\n\r\n\t//Send all text over as UTF-8\r\n\tCStringA dest = CTextConvert::UnicodeToUTF8(GetComputerName());\r\n\tstrncpy(Info.m_cComputerName, dest, sizeof(Info.m_cComputerName));\r\n\t\r\n\tdest = CTextConvert::UnicodeToUTF8(GetIPAddress());\r\n\tstrncpy(Info.m_cIP, dest, sizeof(Info.m_cIP));\t\r\n\t\r\n\tdest = CTextConvert::UnicodeToUTF8(pClip->m_Desc);\r\n\tstrncpy(Info.m_cDesc, dest, sizeof(Info.m_cDesc));\r\n\t\r\n\t\r\n\tInfo.m_cDesc[sizeof(Info.m_cDesc)-1] = 0;\r\n\tInfo.m_cComputerName[sizeof(Info.m_cComputerName)-1] = 0;\r\n\tInfo.m_cIP[sizeof(Info.m_cIP)-1] = 0;\r\n\r\n\tm_SendSocket.SetSocket(m_Connection);\r\n\r\n\tif(m_SendSocket.SendCSendData(Info, MyEnums::START) == FALSE)\r\n\t\treturn FALSE;\r\n\t\r\n\tCClipFormat* pCF;\r\n\t\r\n\tINT_PTR count = pClip->m_Formats.GetSize();\r\n\r\n\t//For each data type\r\n\tfor(int i=0; i < count; i++)\r\n\t{\r\n\t\tpCF = &pClip->m_Formats.GetData()[i];\r\n\t\t\r\n\t\tSendClipFormat(pCF);\r\n\t}\r\n\t\r\n\tif(m_SendSocket.SendCSendData(Info, MyEnums::END) == FALSE)\r\n\t\treturn FALSE;\r\n\r\n\ttheApp.m_lClipsSent++;\r\n\t\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CClient::SendClipFormat(CClipFormat* pCF)\r\n{\r\n\tCSendInfo Info;\r\n\tLPVOID pvData = GlobalLock(pCF->m_hgData);\r\n\tINT_PTR length = GlobalSize(pCF->m_hgData);\r\n\tUCHAR* pOutput = NULL;\r\n\tint nLenOutput = 0;\r\n\tCTextConvert Convert;\r\n\tBOOL bRet = FALSE;\r\n\r\n\tLogSendRecieveInfo(StrF(_T(\"BEFORE Encrypt clip data %d\"), length));\r\n\r\n\tif(m_SendSocket.m_pEncryptor)\r\n\t{\r\n\t\tif(m_SendSocket.m_pEncryptor->Encrypt((UCHAR*)pvData, (int)length, CGetSetOptions::m_csPassword, pOutput, nLenOutput))\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(StrF(_T(\"AFTER Encrypt clip data %d\"), nLenOutput));\r\n\r\n\t\t\tInfo.m_lParameter1 = nLenOutput;\r\n\r\n\t\t\t//Send over as UTF-8\r\n\t\t\tCStringA dest = CTextConvert::UnicodeToUTF8(GetFormatName(pCF->m_cfType));\r\n\t\t\tstrncpy(Info.m_cDesc, dest, sizeof(Info.m_cDesc));\r\n\t\t\tInfo.m_cDesc[sizeof(Info.m_cDesc)-1] = 0;\r\n\t\t\t\r\n\t\t\tif(m_SendSocket.SendCSendData(Info, MyEnums::DATA_START) == FALSE)\r\n\t\t\t\treturn FALSE;\r\n\r\n\t\t\tm_SendSocket.SendExactSize((char*)pOutput, nLenOutput, false);\r\n\r\n\t\t\tm_SendSocket.m_pEncryptor->FreeBuffer(pOutput);\r\n\r\n\t\t\tbRet = TRUE;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(\"Failed to encrypt data\");\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tASSERT(!\"SendItem::Encryption not initialized\");\r\n\t\tLogSendRecieveInfo(\"SendItem::Encryption not initialized\");\t\r\n\t}\r\n\r\n\tGlobalUnlock(pCF->m_hgData);\r\n\t\r\n\tif(m_SendSocket.SendCSendData(Info, MyEnums::DATA_END) == FALSE)\r\n\t\treturn FALSE;\r\n\r\n\treturn bRet;\r\n}\r\n\r\nHGLOBAL CClient::RequestCopiedFiles(CClipFormat &HDropFormat, CString csIP, CString csComputerName)\r\n{\r\n\tCSendInfo Info;\r\n\tbool bBreak = false;\r\n\tHGLOBAL hReturn = NULL;\r\n\tCString csErrorString;\r\n\r\n\tCFileTransferProgressDlg *pProgress = new CFileTransferProgressDlg;\r\n\tif(pProgress == NULL)\r\n\t\treturn NULL;\r\n\r\n\tLogSendRecieveInfo(StrF(_T(\"************** START of requesting files from cpu %s, ip: %s **************\"), csComputerName, csIP));\r\n\r\n\tpProgress->Create(IDD_DIALOG_REMOTE_FILE);\r\n\tpProgress->ShowWindow(SW_SHOW);\r\n\tpProgress->SetMessage(StrF(_T(\"Opening Connection to %s (%s)\"), csComputerName, csIP));\r\n\tpProgress->PumpMessages();\r\n\r\n\tCString requestFrom;\r\n\tif(CGetSetOptions::GetRequestFilesUsingIP())\r\n\t{\r\n\t\trequestFrom = csIP;\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestFrom = csComputerName;\r\n\t}\r\n\r\n\tdo \r\n\t{\r\n\t\tif(OpenConnection(requestFrom) == FALSE)\r\n\t\t{\r\n\t\t\tcsErrorString.Format(_T(\"Error Opening Connection to %s (%s)\"), csComputerName, csIP);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tm_SendSocket.SetSocket(m_Connection);\r\n\t\tm_SendSocket.SetProgressBar(pProgress);\r\n\r\n\t\tif(m_SendSocket.SendCSendData(Info, MyEnums::START) == FALSE)\r\n\t\t\tbreak;\r\n\r\n\t\tif(SendClipFormat(&HDropFormat) == FALSE)\r\n\t\t{\r\n\t\t\tcsErrorString = _T(\"Error sending data request.\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(m_SendSocket.SendCSendData(Info, MyEnums::END) == FALSE)\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tpProgress->SetMessage(StrF(_T(\"Requesting Files from %s (%s)\"), csComputerName, csIP));\r\n\r\n\t\tif(m_SendSocket.SendCSendData(Info, MyEnums::REQUEST_FILES) == FALSE)\r\n\t\t\tbreak;\r\n\r\n\t\tCFileRecieve Recieve;\r\n\t\tlong lRet = Recieve.RecieveFiles(m_Connection, csIP, pProgress);\r\n\t\tif(lRet == TRUE)\r\n\t\t{\r\n\t\t\thReturn = Recieve.CreateCF_HDROPBuffer();\r\n\t\t}\r\n\t\telse if(lRet == FALSE || lRet == MD5_MISMATCH)\r\n\t\t{\r\n\t\t\tif(pProgress != NULL && pProgress->Cancelled())\r\n\t\t\t{\r\n\t\t\t\t//Don't show an error message the user canceled things\r\n\t\t\t}\r\n\t\t\telse\t\r\n\t\t\t{\r\n\t\t\t\tcsErrorString = _T(\"Error receiving files.\");\r\n\t\t\t\tif (lRet == MD5_MISMATCH)\r\n\t\t\t\t{\r\n\t\t\t\t\tcsErrorString += _T(\" MD5 Match Error.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} while(false);\r\n\r\n\tCloseConnection();\r\n\r\n\tif(hReturn == NULL && csErrorString.IsEmpty() == FALSE)\r\n\t{\r\n\t\t::SendMessage(theApp.m_MainhWnd, WM_SEND_RECIEVE_ERROR, (WPARAM)csErrorString.GetBuffer(csErrorString.GetLength()), 0);\r\n\t}\r\n\r\n\tpProgress->DestroyWindow();\r\n\r\n\tLogSendRecieveInfo(StrF(_T(\"************** END of requesting files from cpu %s, ip: %s **************************\"), csComputerName, csIP));\r\n\r\n\treturn hReturn;\r\n}\r\n"
        },
        {
          "name": "Client.h",
          "type": "blob",
          "size": 1.3408203125,
          "content": "// Client.h: interface for the CClient class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_CLIENT_H__E9B55197_85B2_4ABF_92FF_E6301F346404__INCLUDED_)\n#define AFX_CLIENT_H__E9B55197_85B2_4ABF_92FF_E6301F346404__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include \"Server.h\"\n#include \"EncryptDecrypt\\Encryption.h\"\n#include \"SendSocket.h\"\n#include \"Popup.h\"\n\nclass CSendToFriendInfo\n{\npublic:\n\tCSendToFriendInfo()\n\t{\n\t\tm_pPopup = NULL;\n\t\tm_pClipList = NULL;\n\t\tm_pPopup = NULL;\n\t\tm_manualSend = false;\n\t}\n\t~CSendToFriendInfo()\n\t{\n\t\tif(m_pClipList)\n\t\t{\n\t\t\tdelete m_pClipList;\n\t\t\tm_pClipList = NULL;\n\t\t}\n\t}\n\n\tCClipList *m_pClipList;\n\tCString m_csIP;\n\tCPopup *m_pPopup;\n\tCString m_csErrorText;\n\tbool m_manualSend;\n};\n\nclass CClient  \n{\npublic:\n\tCClient();\n\tvirtual ~CClient();\n\n\tBOOL SendItem(CClip *pClip, bool manualSend);\n\t\n\tBOOL OpenConnection(const TCHAR* servername);\n\tBOOL CloseConnection();\n\n\tHGLOBAL RequestCopiedFiles(CClipFormat &HDropFormat, CString csIP, CString csComputerName);\n\nprotected:\n\tSOCKET m_Connection;\n\tint m_connectionPort;\n\n\tCSendSocket m_SendSocket;\n\n\tBOOL SendClipFormat(CClipFormat* pCF);\n\t\nprotected:\n\t\n};\n\nBOOL SendToFriend(CSendToFriendInfo &Info);\n\nUINT  SendClientThread(LPVOID pParam);\n\n#endif // !defined(AFX_CLIENT_H__E9B55197_85B2_4ABF_92FF_E6301F346404__INCLUDED_)\n"
        },
        {
          "name": "Clip.cpp",
          "type": "blob",
          "size": 51.478515625,
          "content": "// Clip.cpp: implementations of the Clip interfaces\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"Clip.h\"\n#include \"DatabaseUtilities.h\"\n#include \"Crc32Dynamic.h\"\n#include \"sqlite\\CppSQLite3.h\"\n#include \"shared/TextConvert.h\"\n#include \"zlib/zlib.h\"\n#include \"Misc.h\"\n#include \"Md5.h\"\n#include \"ChaiScriptOnCopy.h\"\n#include \"DittoChaiScript.h\"\n#include \"ImageHelper.h\"\n\n#include <Mmsystem.h>\n#include <memory>\n\n#include \"Path.h\"\n#include <set>\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n\n/*----------------------------------------------------------------------------*\\\nCOleDataObjectEx\n\\*----------------------------------------------------------------------------*/\n\nHGLOBAL COleDataObjectEx::GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)\n{\n    HGLOBAL hGlobal = COleDataObject::GetGlobalData(cfFormat, lpFormatEtc);\n\tif(hGlobal)\n\t{\n\t\tif(!::IsValid(hGlobal))\n\t\t{\n\t\t\tLog( StrF(\n\t\t\t\t_T(\"COleDataObjectEx::GetGlobalData(\\\"%s\\\"): ERROR: Invalid (NULL) data returned.\"),\n\t\t\t\tGetFormatName(cfFormat) ) );\n\t\t\t::GlobalFree( hGlobal );\n\t\t\thGlobal = NULL;\n\t\t}\n\t\treturn hGlobal;\n\t}\n\t\n\t// The data isn't in global memory, so try getting an IStream interface to it.\n\tSTGMEDIUM stg;\n\t\n\tif(!GetData(cfFormat, &stg))\n\t{\n\t\treturn 0;\n\t}\n\t\n\tswitch(stg.tymed)\n\t{\n\tcase TYMED_HGLOBAL:\n\t\thGlobal = stg.hGlobal;\n\t\tbreak;\n\t\t\n\tcase TYMED_ISTREAM:\n\t\t{\n\t\t\tUINT            uDataSize;\n\t\t\tLARGE_INTEGER\tli;\n\t\t\tULARGE_INTEGER\tuli;\n\t\t\t\n\t\t\tli.HighPart = li.LowPart = 0;\n\t\t\t\n\t\t\tif ( SUCCEEDED( stg.pstm->Seek ( li, STREAM_SEEK_END, &uli )))\n\t\t\t{\n\t\t\t\thGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, uli.LowPart );\n\t\t\t\t\n\t\t\t\tvoid* pv = GlobalLock(hGlobal);\n\t\t\t\tstg.pstm->Seek(li, STREAM_SEEK_SET, NULL);\n\t\t\t\tHRESULT result = stg.pstm->Read(pv, uli.LowPart, (PULONG)&uDataSize);\n\t\t\t\tGlobalUnlock(hGlobal);\n\t\t\t\t\n\t\t\t\tif( FAILED(result) )\n\t\t\t\t\thGlobal = GlobalFree(hGlobal);\n\t\t\t}\n\t\t\tbreak;  // case TYMED_ISTREAM\n\t\t}\n\t} // end switch\n\t\n\tReleaseStgMedium(&stg);\n\t\n\tif(hGlobal && !::IsValid(hGlobal))\n\t{\n\t\tLog( StrF(\n\t\t\t_T(\"COleDataObjectEx::GetGlobalData(\\\"%s\\\"): ERROR: Invalid (NULL) data returned.\"),\n\t\t\tGetFormatName(cfFormat)));\n\t\t::GlobalFree(hGlobal);\n\t\thGlobal = NULL;\n\t}\n\t\n\treturn hGlobal;\n}\n\nstd::shared_ptr<CClipTypes> COleDataObjectEx::GetAvailableTypes()\n{\n\tstd::shared_ptr<CClipTypes> types = std::make_shared<CClipTypes>();\n\n\t// GetNextFormat API has a bug that cannot find avaliable formats correctly. (ex. CF_DIB)\n\t// So, Use EnumClipboardFormats API.\n\tif (!OpenClipboard(theApp.m_MainhWnd))\n\t\treturn types;\n\n\tint format = 0;\n\tdo\n\t{\n\t\tformat = EnumClipboardFormats(format);\n\t\t// Currently CF_MAX is not valid format\n\t\t// See https://learn.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats\n\t\tif (format == 0 || format == CF_MAX)\n\t\t\tcontinue;\n\t\ttypes->Add(format);\n\t} while (format != 0);\n\n\tCloseClipboard();\n\treturn types;\n}\n\n/*----------------------------------------------------------------------------*\\\nCClipFormat - holds the data of one clip format.\n\\*----------------------------------------------------------------------------*/\nCClipFormat::CClipFormat(CLIPFORMAT cfType, HGLOBAL hgData, int parentId)\n{\n\tm_cfType = cfType;\n\tm_hgData = hgData;\n\tm_autoDeleteData = true;\n\tm_parentId = parentId;\n}\n\nCClipFormat::~CClipFormat() \n{ \n\tFree(); \n}\n\nvoid CClipFormat::Clear()\n{\n\tm_cfType = 0;\n\tm_hgData = 0;\n\tm_dataId = -1;\n\tm_parentId = -1;\n}\n\nvoid CClipFormat::Free()\n{\n\tif(m_autoDeleteData && m_hgData)\n\t{\n\t\tm_hgData = ::GlobalFree( m_hgData );\n\t\tm_hgData = NULL;\n\t}\n}\n\nGdiplus::Bitmap *CClipFormat::CreateGdiplusBitmap()\n{\n\tif (this->m_cfType != CF_DIB && this->m_cfType == theApp.m_PNG_Format)\n\t\treturn NULL;\n\n\tGdiplus::Bitmap *gdipBitmap;\n\tif (this->m_cfType == theApp.m_PNG_Format)\n\t\tgdipBitmap = PNGImageHelper::GdipImageFromHGLOBAL(this->m_hgData);\n\telse\n\t\tgdipBitmap = DIBImageHelper::GdipImageFromHGLOBAL(this->m_hgData);\n\n\treturn gdipBitmap;\n}\n\n/*----------------------------------------------------------------------------*\\\nCClipFormats - holds an array of CClipFormat\n\\*----------------------------------------------------------------------------*/\n// returns a pointer to the CClipFormat in this array which matches the given type\n//  or NULL if that type doesn't exist in this array.\nCClipFormat* CClipFormats::FindFormat(UINT cfType)\n{\n\tCClipFormat* pCF;\n\tINT_PTR count = GetSize();\n\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tpCF = &ElementAt(i);\n\t\tif(pCF->m_cfType == cfType)\n\t\t\treturn pCF;\n\t}\n\treturn NULL;\n}\n\nbool CClipFormats::RemoveFormat(CLIPFORMAT cfType)\n{\n\tbool removed = false;\n\tCClipFormat* pCF;\n\tINT_PTR count = GetSize();\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tpCF = &ElementAt(i);\n\t\tif (pCF->m_cfType == cfType)\n\t\t{\n\t\t\tthis->RemoveAt(i);\n\t\t\tremoved = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn removed;\n}\n\n\n\n\n/*----------------------------------------------------------------------------*\\\nCClip - holds multiple CClipFormats and CopyClipboard() statistics\n\\*----------------------------------------------------------------------------*/\n\nDWORD CClip::m_LastAddedCRC = 0;\nint CClip::m_lastAddedID = -1;\n\nCClip::CClip() : \n\tm_id(-1), \n\tm_CRC(0),\n\tm_parentId(-1),\n\tm_dontAutoDelete(FALSE),\n\tm_shortCut(0),\n\tm_bIsGroup(FALSE),\n\tm_param1(0),\n\tm_clipOrder(0),\n\tm_stickyClipOrder(INVALID_STICKY),\n\tm_stickyClipGroupOrder(INVALID_STICKY),\n\tm_clipGroupOrder(0),\n\tm_globalShortCut(FALSE),\n\tm_moveToGroupShortCut(0),\n\tm_globalMoveToGroupShortCut(FALSE)\n{\n\tm_copyReason = CopyReasonEnum::COPY_TO_UNKOWN;\n\tm_addToDbStickyEnum = AddToDbStickyEnum::INVALID;\n}\n\nCClip::~CClip()\n{\n\tEmptyFormats();\n}\n\nvoid CClip::Clear()\n{\n\tm_id = -1;\n\tm_Time = 0;\n\tm_Desc = \"\";\n\tm_CRC = 0;\n\tm_parentId = -1;\n\tm_dontAutoDelete = FALSE;\n\tm_shortCut = 0;\n\tm_bIsGroup = FALSE;\n\tm_csQuickPaste = \"\";\n\tm_param1 = 0;\n\tm_globalShortCut = FALSE;\n\tm_moveToGroupShortCut = 0;\n\tm_globalMoveToGroupShortCut = 0;\n\t\n\tEmptyFormats();\n}\n\nconst CClip& CClip::operator=(const CClip &clip)\n{\n\tconst CClipFormat* pCF;\n\n\tm_id = clip.m_id;\n\tm_Time = clip.m_Time;\n\tm_lastPasteDate = clip.m_lastPasteDate;\n\tm_CRC = clip.m_CRC;\n\tm_parentId = clip.m_parentId;\n\tm_dontAutoDelete = clip.m_dontAutoDelete;\n\tm_shortCut = clip.m_shortCut;\n\tm_bIsGroup = clip.m_bIsGroup;\n\tm_csQuickPaste = clip.m_csQuickPaste;\n\tm_moveToGroupShortCut = clip.m_moveToGroupShortCut;\n\tm_globalMoveToGroupShortCut = clip.m_globalMoveToGroupShortCut;\n\n\tINT_PTR nCount = clip.m_Formats.GetSize();\n\t\n\tfor(int i = 0; i < nCount; i++)\n\t{\n\t\tpCF = &clip.m_Formats.GetData()[i];\n\n\t\tLPVOID pvData = GlobalLock(pCF->m_hgData);\n\t\tif(pvData)\n\t\t{\n\t\t\tAddFormat(pCF->m_cfType, pvData, (UINT)GlobalSize(pCF->m_hgData));\n\t\t}\n\t\tGlobalUnlock(pCF->m_hgData);\n\t}\n\n\t//Set this after since in could get the wrong description in AddFormat\n\tm_Desc = clip.m_Desc;\n\n\treturn *this;\n}\n\nvoid CClip::EmptyFormats()\n{\n\t// free global memory in m_Formats\n\tfor(INT_PTR i = m_Formats.GetSize()-1; i >= 0; i--)\n\t{\n\t\tm_Formats[i].Free();\n\t\tm_Formats.RemoveAt(i);\n\t}\n}\n\n// Adds a new Format to this Clip by copying the given data.\nbool CClip::AddFormat(CLIPFORMAT cfType, void* pData, UINT nLen, bool setDesc)\n{\n\tASSERT(pData && nLen);\n\tHGLOBAL hGlobal = ::NewGlobalP(pData, nLen);\n\tASSERT(hGlobal);\n\n\t// update the Clip statistics\n\tm_Time = m_Time.GetCurrentTime();\n\n\tif (setDesc)\n\t{\n\t\tif (cfType != CF_UNICODETEXT || !SetDescFromText(hGlobal, true))\n\t\t\tSetDescFromType();\n\t}\n\t\n\tCClipFormat format(cfType,hGlobal);\n\tCClipFormat *pFormat;\n\t\n\tpFormat = m_Formats.FindFormat(cfType);\n\t// if the format type already exists as part of this clip, replace the data\n\tif(pFormat)\n\t{\n\t\tpFormat->Free();\n\t\tpFormat->m_hgData = format.m_hgData;\n\t}\n\telse\n\t{\n\t\tm_Formats.Add(format);\n\t}\n\t\n\tformat.m_hgData = 0; // now owned by m_Formats\n\treturn true;\n}\n\n// Fills this CClip with the contents of the clipboard.\nint CClip::LoadFromClipboard(CClipTypes* pClipTypes, bool checkClipboardIgnore, CString activeApp, CString activeAppTitle)\n{\n\tif(pClipTypes == NULL || pClipTypes->GetSize() == 0)\n\t{\n\t\tASSERT(0); // this feature is not currently used... it is an error if it is.\n\t\tLog(_T(\"no types were given to accept, skipping this clipboard change\"));\n\t\treturn FALSE;\n\t}\n\n\tCOleDataObjectEx oleData;\n\tCClipTypes* pTypes = pClipTypes;\n\n\t// m_Formats should be empty when this is called.\n\tASSERT(m_Formats.GetSize() == 0);\n\t\n\t// If the data is supposed to be private, then return\n\tif(::IsClipboardFormatAvailable(theApp.m_cfIgnoreClipboard))\n\t{\n\t\tLog(_T(\"Clipboard ignore type is on the clipboard, skipping this clipboard change\"));\n\t\treturn FALSE;\n\t}\n\n\t//If we are saving a multi paste then delay us connecting to the clipboard\n\t//to allow the ctrl-v to do a paste\n\tif(::IsClipboardFormatAvailable(theApp.m_cfDelaySavingData))\n\t{\n\t\tLog(_T(\"Delay clipboard type is on the clipboard, delaying 1500 ms to allow ctrl-v to work\"));\n\t\tSleep(1500);\n\t}\n\t\t\n\t//Attach to the clipboard\n\tif(!oleData.AttachClipboard())\n\t{\n\t\tLog(_T(\"failed to attache to clipboard, skipping this clipboard change\"));\n\t\tASSERT(0); // does this ever happen?\n\t\treturn FALSE;\n\t}\n\t\n\toleData.EnsureClipboardObject();\n\t\n\t\n\tm_Desc = \"[Ditto Error] BAD DESCRIPTION\";\n\t\n\t// Get Description String\n\t// NOTE: We make sure that the description always corresponds to the\n\t//  data saved by using the exact same globalmem instance as the source\n\t//  for both... i.e. we only fetch the description format type once.\n\tCClipFormat cfDesc;\n\tbool bIsDescSet = false;\n\n\tcfDesc.m_cfType = CF_UNICODETEXT;\t\n\tif(oleData.IsDataAvailable(cfDesc.m_cfType))\n\t{\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tcfDesc.m_hgData = oleData.GetGlobalData(cfDesc.m_cfType);\n\t\t\tif (cfDesc.m_hgData == NULL)\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"Tried to set description from cf_unicode, data is NULL, try: %d\"), i+1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSleep(10);\n\t\t}\n\t\tbIsDescSet = SetDescFromText(cfDesc.m_hgData, true);\n\n\t\tLog(StrF(_T(\"Tried to set description from cf_unicode text, Set: %d, Desc: [%s]\"), bIsDescSet, m_Desc.Left(30)));\n\t}\n\n\tif(bIsDescSet == false)\n\t{\n\t\tcfDesc.m_cfType = CF_TEXT;\t\n\t\tif(oleData.IsDataAvailable(cfDesc.m_cfType))\n\t\t{\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tcfDesc.m_hgData = oleData.GetGlobalData(cfDesc.m_cfType);\n\t\t\t\tif (cfDesc.m_hgData == NULL)\n\t\t\t\t{\n\t\t\t\t\tLog(StrF(_T(\"Tried to set description from cf_text, data is NULL, try: %d\"), i + 1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSleep(10);\n\t\t\t}\n\n\t\t\tbIsDescSet = SetDescFromText(cfDesc.m_hgData, false);\n\n\t\t\tLog(StrF(_T(\"Tried to set description from cf_text text, Set: %d, Desc: [%s]\"), bIsDescSet, m_Desc.Left(30)));\n\t\t}\n\t}\n\n\tINT_PTR nSize;\n\tCClipFormat cf;\n\tINT_PTR numTypes = pTypes->GetSize();\n\n\tLog(StrF(_T(\"Begin enumerating over supported types, Count: %d\"), numTypes));\n\n\tfor(int i = 0; i < numTypes; i++)\n\t{\n\t\tcf.m_cfType = pTypes->ElementAt(i);\n\n\t\tif (cf.m_cfType == CF_DIB &&\n\t\t\toleData.IsDataAvailable(CF_TEXT) &&\n\t\t\tCGetSetOptions::GetIgnoreAnnoyingCFDIBSet(TRUE).count(activeApp.MakeLower()))\n\t\t{\n\t\t\tLog(StrF(_T(\"Ignore CF_DIB from %s\"), activeApp));\n\t\t\tcontinue;\n\t\t}\n\n\t\tBOOL bSuccess = false;\n\t\tLog(StrF(_T(\"Begin try and load type %s\"), GetFormatName(cf.m_cfType)));\n\t\t\n\t\t// is this the description we already fetched?\n\t\tif(cf.m_cfType == cfDesc.m_cfType)\n\t\t{\n\t\t\tcf = cfDesc;\n\t\t\tcfDesc.m_hgData = 0; // cf owns it now (to go into m_Formats)\n\t\t}\n\t\telse if(!oleData.IsDataAvailable(cf.m_cfType))\n\t\t{\n\t\t\tLog(StrF(_T(\"End of load - Data is not available for type %s\"), GetFormatName(cf.m_cfType)));\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int tries = 0; tries < 2; tries++)\n\t\t\t{\n\t\t\t\tcf.m_hgData = oleData.GetGlobalData(cf.m_cfType);\n\t\t\t\tif (cf.m_hgData != NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tLog(StrF(_T(\"Tried to get data for type: %s, data is NULL, try: %d\"), GetFormatName(cf.m_cfType), tries + 1));\n\t\t\t\tSleep(5);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cf.m_hgData)\n\t\t{\n\t\t\tnSize = GlobalSize(cf.m_hgData);\n\t\t\tif(nSize > 0)\n\t\t\t{\n\t\t\t\tif(CGetSetOptions::m_lMaxClipSizeInBytes > 0 && (int)nSize > CGetSetOptions::m_lMaxClipSizeInBytes)\n\t\t\t\t{\n\t\t\t\t\tCString cs;\n\t\t\t\t\tcs.Format(_T(\"Maximum clip size reached max size = %d, clip size = %d\"), CGetSetOptions::m_lMaxClipSizeInBytes, nSize);\n\t\t\t\t\tLog(cs);\n\n\t\t\t\t\toleData.Release();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tASSERT(::IsValid(cf.m_hgData));\n\t\t\t\t\n\t\t\t\tm_Formats.Add(cf);\n\t\t\t\tbSuccess = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tASSERT(FALSE); // a valid GlobalMem with 0 size is strange\n\t\t\t\tcf.Free();\n\t\t\t\tLog(StrF(_T(\"Data length is 0 for type %s\"), GetFormatName(cf.m_cfType)));\n\t\t\t}\n\t\t\tcf.m_hgData = 0; // m_Formats owns it now\n\t\t}\n\n\t\tLog(StrF(_T(\"End of load - type %s, Success: %d\"), GetFormatName(cf.m_cfType), bSuccess));\n\t}\n\n\tLog(StrF(_T(\"End enumerating over supported types, Count: %d\"), numTypes));\n\t\n\tm_Time = CTime::GetCurrentTime();\n\t\n\tif(!bIsDescSet)\n\t{\n\t\tSetDescFromType();\n\n\t\tLog(StrF(_T(\"Setting description from type, Desc: [%s]\"), m_Desc.Left(30)));\n\t}\n\t\n\t// if the description was in a type that is not supported,\n\t//we have to free it since it wasn't added to m_Formats\n\tif(cfDesc.m_hgData)\n\t{\n\t\tcfDesc.Free();\n\t}\n\t\n\toleData.Release();\n\t\n\tif(m_Formats.GetSize() == 0)\n\t{\n\t\tLog(_T(\"No clip types were in supported types array\"));\n\t\treturn FALSE;\n\t}\n\n\tbool calledOnCopyScript = false;\n\ttry\n\t{\n\t\tfor (auto & listItem : CGetSetOptions::m_copyScripts.m_list)\n\t\t{\n\t\t\tif (listItem.m_active)\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"Start of process copy name: %s, script: %s\"), listItem.m_name, listItem.m_script));\n\n\t\t\t\tChaiScriptOnCopy onCopy;\n\t\t\t\tCDittoChaiScript clipData(this, (LPCSTR)CTextConvert::UnicodeToAnsi(activeApp), (LPCSTR)CTextConvert::UnicodeToAnsi(activeAppTitle));\n\t\t\t\tif (onCopy.ProcessScript(clipData, (LPCSTR)CTextConvert::UnicodeToAnsi(listItem.m_script)) == false)\n\t\t\t\t{\n\t\t\t\t\tLog(StrF(_T(\"End of process copy name: %s, returned false, not saving this copy to Ditto, last Error: %s\"), listItem.m_name, onCopy.m_lastError));\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tcalledOnCopyScript = true;\n\n\t\t\t\tLog(StrF(_T(\"End of process copy name: %s, returned true, last Error: %s\"), listItem.m_name, onCopy.m_lastError));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"Script is not active, not processing name: %s, script: %s\"), listItem.m_name, listItem.m_script));\n\t\t\t}\n\t\t}\n\t}\n\tcatch (CException *ex)\n\t{\n\t\tTCHAR szCause[255];\n\t\tex->GetErrorMessage(szCause, 255);\n\t\tCString cs;\n\t\tcs.Format(_T(\"save copy exception: %s\"), szCause);\n\t\tLog(cs);\n\t}\n\tcatch (...)\n\t{\n\t\tLog(_T(\"save copy exception 2\"));\t\n\t}\n\n\t//copy script could have changed the data, make sure the description matches\n\tif (calledOnCopyScript)\n\t{\n\t\tauto uString = this->GetUnicodeTextFormat();\n\t\tif (uString != _T(\"\"))\n\t\t{\n\t\t\tif (uString.GetLength() > CGetSetOptions::m_bDescTextSize)\n\t\t\t{\n\t\t\t\tm_Desc = uString.Left(CGetSetOptions::m_bDescTextSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_Desc = uString;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto aString = this->GetCFTextTextFormat();\n\t\t\tif (aString != \"\")\n\t\t\t{\n\t\t\t\tif (aString.GetLength() > CGetSetOptions::m_bDescTextSize)\n\t\t\t\t{\n\t\t\t\t\tm_Desc = aString.Left(CGetSetOptions::m_bDescTextSize);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_Desc = aString;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetDescFromType();\n\t\t\t}\n\t\t}\n\n\t\tLog(StrF(_T(\"Called on copy script, this could change the description, regenerated desc: %s\"), m_Desc));\n\t}\n\n\tif (this->m_Desc != _T(\"\"))\n\t{\n\t\tstd::wstring stringData(this->m_Desc);\n\t\tif (CGetSetOptions::m_regexHelper.TextMatchFilters(activeApp, stringData))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nbool CClip::SetDescFromText(HGLOBAL hgData, bool unicode)\n{\n\tif(hgData == 0)\n\t\treturn false;\n\t\n\tbool bRet = false;\n\tINT_PTR bufLen = 0;\n\n\tif(unicode)\n\t{\n\t\tTCHAR* text = (TCHAR *) GlobalLock(hgData);\n\t\tbufLen = GlobalSize(hgData);\n\n\t\tm_Desc = CString(text, (int)(bufLen/(sizeof(wchar_t))));\n\t\tbRet = true;\n\t}\n\telse\n\t{\n\t\tchar* text = (char *) GlobalLock(hgData);\n\t\tbufLen = GlobalSize(hgData);\n\t\n\t\tm_Desc = CString(text, (int)bufLen);\n\t\tbRet = true;\n\t}\n\t\t\n\tif(bufLen > CGetSetOptions::m_bDescTextSize)\n\t{\n\t\tm_Desc = m_Desc.Left(CGetSetOptions::m_bDescTextSize);\n\t}\n\t\n\t//Unlock the data\n\tGlobalUnlock(hgData);\n\t\n\treturn bRet;\n}\n\nbool CClip::SetDescFromType()\n{\n\tINT_PTR size = m_Formats.GetSize();\n\tif(size <= 0)\n\t{\n\t\treturn false;\n\t}\n\n\tint nCF_HDROPIndex = -1;\n\tfor(int i = 0; i < size; i++)\n\t{\n\t\tif(m_Formats[i].m_cfType == CF_HDROP)\n\t\t{\n\t\t\tnCF_HDROPIndex = i;\n\t\t}\n\t}\n\n\tif(nCF_HDROPIndex >= 0)\n\t{\n\t\tusing namespace nsPath;\n\n\t\tHDROP drop = (HDROP)GlobalLock(m_Formats[nCF_HDROPIndex].m_hgData);\n\t\tint nNumFiles = min(5, DragQueryFile(drop, -1, NULL, 0));\n\n\t\tif(nNumFiles > 1)\n\t\t\tm_Desc = \"Copied Files - \";\n\t\telse\n\t\t\tm_Desc = \"Copied File - \";\n\n\t\tTCHAR file[MAX_PATH];\n\t\t\n\t\tfor(int nFile = 0; nFile < nNumFiles; nFile++)\n\t\t{\n\t\t\tif(DragQueryFile(drop, nFile, file, sizeof(file)) > 0)\n\t\t\t{\n\t\t\t\tCPath path(file);\n\t\t\t\tm_Desc += path.GetName();\n\t\t\t\tm_Desc += \" - \";\n\t\t\t\tm_Desc += file;\n\t\t\t\tm_Desc += \"\\n\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tGlobalUnlock(m_Formats[nCF_HDROPIndex].m_hgData);\n\t}\n\telse\n\t{\n\t\tm_Desc = GetFormatName(m_Formats[0].m_cfType);\n\t}\n\n\treturn m_Desc.GetLength() > 0;\n}\n\nbool CClip::AddToDB(bool bCheckForDuplicates)\n{\n\tbool bResult;\n\ttry\n\t{\n\t\tm_Time = CTime::GetCurrentTime().GetTime();\n\n\t\tm_CRC = GenerateCRC();\n\n\t\tif(bCheckForDuplicates &&\n\t\t\tm_parentId < 0)\n\t\t{\t\n\t\t\tint nID = FindDuplicate();\n\t\t\tif(nID >= 0)\n\t\t\t{\n\t\t\t\tMakeLatestOrder();\n\t\t\t\tMakeLatestGroupOrder();\n\n\t\t\t\tCString sql;\n\t\t\t\t\n\t\t\t\tsql.Format(_T(\"UPDATE Main SET clipOrder = %f where lID = %d;\"), \n\t\t\t\t\t\t\t\tm_clipOrder, nID);\n\n\t\t\t\tint ret = theApp.m_db.execDML(sql);\n\n\t\t\t\tint groupRet = -1;\n\n\t\t\t\tif(m_parentId > -1)\n\t\t\t\t{\n\t\t\t\t\tsql.Format(_T(\"UPDATE Main SET clipGroupOrder = %f where lID = %d;\"), \n\t\t\t\t\t\tm_clipGroupOrder, nID);\n\n\t\t\t\t\tgroupRet = theApp.m_db.execDML(sql);\n\t\t\t\t}\n\n\n\t\t\t\tm_id = nID;\n\n\t\t\t\tLog(StrF(_T(\"Found duplicate clip in db, Id: %d, ParentId: %d crc: %d, NewOrder: %f, GroupOrder %f, Ret: %d, GroupRet: %d, SQL: %s\"), \n\t\t\t\t\t\t\t\t\t\tnID, m_parentId, m_CRC, m_clipOrder, m_clipGroupOrder, ret, groupRet, sql));\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\n\tint removeStickySettingClipId = -1;\n\n\tif (m_addToDbStickyEnum == AddToDbStickyEnum::MAKE_TOP_STICKY)\n\t{\n\t\tm_stickyClipOrder = this->GetNewTopSticky(m_parentId, -1);\n\t}\n\telse if (m_addToDbStickyEnum == AddToDbStickyEnum::MAKE_LAST_STICKY)\n\t{\n\t\tm_stickyClipOrder = this->GetNewLastSticky(m_parentId, -1);\n\t}\n\telse if (m_addToDbStickyEnum == AddToDbStickyEnum::REPLACE_TOP_STICKY)\n\t{\n\t\tm_stickyClipOrder = this->GetNewTopSticky(m_parentId, -1);\n\t\tremoveStickySettingClipId = GetExistingTopStickyClipId(m_parentId);\n\t}\n\t\n\tbResult = false;\n\tif(AddToMainTable())\n\t{\t\t\n\t\tbResult = AddToDataTable();\n\t}\n\n\tif(bResult)\n\t{\n\t\tif(CGetSetOptions::m_csPlaySoundOnCopy.IsEmpty() == FALSE)\n\t\t\tPlaySound(CGetSetOptions::m_csPlaySoundOnCopy, NULL, SND_FILENAME|SND_ASYNC);\n\n\t\tif (removeStickySettingClipId > 0)\n\t\t{\n\t\t\tRemoveStickySetting(removeStickySettingClipId, m_parentId);\n\t\t}\n\t}\n\t\n\t// should be emptied by AddToDataTable\n\t//ASSERT(m_Formats.GetSize() == 0);\n\t\n\treturn bResult;\n}\n\n// if a duplicate exists, set recset to the duplicate and return true\nint CClip::FindDuplicate()\n{\n\ttry\n\t{\n\t\t//If they are allowing duplicates still check \n\t\t//the last copied item\n\t\tif(CGetSetOptions::m_bAllowDuplicates)\n\t\t{\n\t\t\tif (CGetSetOptions::m_allowBackToBackDuplicates == FALSE)\n\t\t\t{\n\t\t\t\tif (m_CRC == m_LastAddedCRC)\n\t\t\t\t\treturn m_lastAddedID;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE CRC = %d\"), m_CRC);\n\t\t\t\t\n\t\t\tif(q.eof() == false)\n\t\t\t{\n\t\t\t\treturn q.getIntField(_T(\"lID\"));\n\t\t\t}\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\t\t\n\treturn -1;\n}\n\n\n\nDWORD CClip::GenerateCRC()\n{\n\tCClipFormat* pCF;\n\tDWORD dwCRC = 0xFFFFFFFF;\n\n\tCCrc32Dynamic *pCrc32 = new CCrc32Dynamic;\n\tif(pCrc32)\n\t{\n\t\t//Generate a CRC value for all copied data\n\n\t\tINT_PTR size = m_Formats.GetSize();\n\t\tfor(int i = 0; i < size ; i++)\n\t\t{\n\t\t\tpCF = & m_Formats.ElementAt(i);\n\t\t\t\n\t\t\tconst unsigned char *Data = (const unsigned char *)GlobalLock(pCF->m_hgData);\n\t\t\tif(Data)\n\t\t\t{\n\t\t\t\tif (CGetSetOptions::GetAdjustClipsForCRC())\n\t\t\t\t{\n\t\t\t\t\t//Try and remove known things that change in rtf (word and outlook)\n\t\t\t\t\tif (pCF->m_cfType == theApp.m_RTFFormat)\n\t\t\t\t\t{\n\t\t\t\t\t\tCStringA CStringData((char*)Data);\n\n\t\t\t\t\t\t//In word and outlook I was finding that data in the \\\\datastore section was always changing, remove this for the crc check\n\t\t\t\t\t\tRemoveRTFSection(CStringData, \"{\\\\*\\\\datastore\");\n\n\t\t\t\t\t\t//In word and outlook rsid values are always changing, remove these for the crc check\n\t\t\t\t\t\tDeleteParamFromRTF(CStringData, \"\\\\rsid\", true);\n\t\t\t\t\t\tDeleteParamFromRTF(CStringData, \"\\\\insrsid\", true);\n\t\t\t\t\t\tDeleteParamFromRTF(CStringData, \"\\\\mdispDef1\", false);\n\n\t\t\t\t\t\tpCrc32->GenerateCrc32((const LPBYTE)CStringData.GetBuffer(), (DWORD)CStringData.GetLength(), dwCRC);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//i've seen examble where the text size was 10 but the data size was 20, leading to random crc values\n\t\t\t\t\t\t//try and only check the crc for the actual text\n\t\t\t\t\t\tint dataLength = (int)GlobalSize(pCF->m_hgData);\n\t\t\t\t\t\tif (pCF->m_cfType == CF_TEXT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdataLength = min(dataLength, ((int)strlen((char*)Data) + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (pCF->m_cfType == CF_UNICODETEXT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdataLength = min(dataLength, (((int)wcslen((wchar_t*)Data) + 1) * 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpCrc32->GenerateCrc32((const LPBYTE)Data, (DWORD)dataLength, dwCRC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpCrc32->GenerateCrc32((const LPBYTE)Data, (DWORD)GlobalSize(pCF->m_hgData), dwCRC);\n\t\t\t\t}\n\t\t\t}\n\t\t\tGlobalUnlock(pCF->m_hgData);\n\t\t}\n\n\t\tdwCRC = ~dwCRC;\n\n\t\tdelete pCrc32;\n\t}\n\n\treturn dwCRC;\n}\n\n// assigns m_ID\nbool CClip::AddToMainTable()\n{\n\ttry\n\t{\n\t\tm_Desc.Replace(_T(\"'\"), _T(\"''\"));\n\t\tm_csQuickPaste.Replace(_T(\"'\"), _T(\"''\"));\n\n\t\tCString cs;\n\t\tcs.Format(_T(\"INSERT into Main (lDate, mText, lShortCut, lDontAutoDelete, CRC, bIsGroup, lParentID, QuickPasteText, clipOrder, clipGroupOrder, globalShortCut, lastPasteDate, stickyClipOrder, stickyClipGroupOrder, MoveToGroupShortCut, GlobalMoveToGroupShortCut) \")\n\t\t\t\t\t\t_T(\"values(%d, '%s', %d, %d, %d, %d, %d, '%s', %f, %f, %d, %d, %f, %f, %d, %d);\"),\n\t\t\t\t\t\t\t(int)m_Time.GetTime(),\n\t\t\t\t\t\t\tm_Desc,\n\t\t\t\t\t\t\tm_shortCut,\n\t\t\t\t\t\t\tm_dontAutoDelete,\n\t\t\t\t\t\t\tm_CRC,\n\t\t\t\t\t\t\tm_bIsGroup,\n\t\t\t\t\t\t\tm_parentId,\n\t\t\t\t\t\t\tm_csQuickPaste,\n\t\t\t\t\t\t\tm_clipOrder,\n\t\t\t\t\t\t\tm_clipGroupOrder,\n\t\t\t\t\t\t\tm_globalShortCut,\n\t\t\t\t\t\t\t(int)CTime::GetCurrentTime().GetTime(),\n\t\t\t\t\t\t\tm_stickyClipOrder,\n\t\t\t\t\t\t\tm_stickyClipGroupOrder,\n\t\t\t\t\t\t\tm_moveToGroupShortCut,\n\t\t\t\t\t\t\tm_globalMoveToGroupShortCut);\n\n\t\ttheApp.m_db.execDML(cs);\n\n\t\tm_id = (long)theApp.m_db.lastRowId();\n\n\t\tLog(StrF(_T(\"Added clip to main table, Id: %d, ParentId: %d Desc: %s, Order: %f, GroupOrder: %f\"), m_id, m_parentId, m_Desc, m_clipOrder, m_clipGroupOrder));\n\n\t\tm_LastAddedCRC = m_CRC;\n\t\tm_lastAddedID = m_id;\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\t\n\treturn true;\n}\n\nbool CClip::ModifyMainTable()\n{\n\tbool bRet = false;\n\ttry\n\t{\n\t\tm_Desc.Replace(_T(\"'\"), _T(\"''\"));\n\t\tm_csQuickPaste.Replace(_T(\"'\"), _T(\"''\"));\n\n\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lShortCut = %d, \")\n\t\t\t_T(\"mText = '%s', \")\n\t\t\t_T(\"lParentID = %d, \")\n\t\t\t_T(\"lDontAutoDelete = %d, \")\n\t\t\t_T(\"QuickPasteText = '%s', \")\n\t\t\t_T(\"clipOrder = %f, \")\n\t\t\t_T(\"clipGroupOrder = %f, \")\n\t\t\t_T(\"globalShortCut = %d, \")\n\t\t\t_T(\"stickyClipOrder = %f, \")\n\t\t\t_T(\"stickyClipGroupOrder = %f, \")\n\t\t\t_T(\"MoveToGroupShortCut = %d, \")\n\t\t\t_T(\"GlobalMoveToGroupShortCut = %d \")\n\t\t\t_T(\"WHERE lID = %d;\"), \n\t\t\tm_shortCut, \n\t\t\tm_Desc, \n\t\t\tm_parentId, \n\t\t\tm_dontAutoDelete, \n\t\t\tm_csQuickPaste,\n\t\t\tm_clipOrder,\n\t\t\tm_clipGroupOrder,\n\t\t\tm_globalShortCut,\n\t\t\tm_stickyClipOrder,\n\t\t\tm_stickyClipGroupOrder,\n\t\t\tm_moveToGroupShortCut,\n\t\t\tm_globalMoveToGroupShortCut,\n\t\t\tm_id);\n\n\t\tbRet = true;\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\n\treturn bRet;\n}\n\nbool CClip::ModifyDescription()\n{\n\tbool bRet = false;\n\ttry\n\t{\n\t\tm_Desc.Replace(_T(\"'\"), _T(\"''\"));\n\n\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET mText = '%s' \")\n\t\t\t_T(\"WHERE lID = %d;\"),\n\t\t\tm_Desc,\n\t\t\tm_id);\n\n\t\tbRet = true;\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\n\t\treturn bRet;\n}\n\n// Empties m_Formats as it saves them to the Data Table.\nbool CClip::AddToDataTable()\n{\n\tCClipFormat* pCF;\n\n\ttry\n\t{\n\t\tCppSQLite3Statement stmt = theApp.m_db.compileStatement(_T(\"insert into Data values (NULL, ?, ?, ?);\"));\n\t\t\n\t\tfor(INT_PTR i = m_Formats.GetSize()-1; i >= 0 ; i--)\n\t\t{\n\t\t\tpCF = &m_Formats.ElementAt(i);\n\n\t\t\tCString formatName = GetFormatName(pCF->m_cfType);\n\t\t\tint clipSize = 0;\n\t\t\t\n\t\t\tstmt.bind(1, m_id);\n\t\t\tstmt.bind(2, formatName);\n\n\t\t\tconst unsigned char *Data = (const unsigned char *)GlobalLock(pCF->m_hgData);\n\t\t\tif(Data)\n\t\t\t{\n\t\t\t\tclipSize = (int)GlobalSize(pCF->m_hgData);\n\t\t\t\tstmt.bind(3, Data, clipSize);\n\t\t\t}\n\t\t\tGlobalUnlock(pCF->m_hgData);\n\t\t\t\n\t\t\tstmt.execDML();\n\t\t\tstmt.reset();\n\n\t\t\tpCF->m_dataId = (long)theApp.m_db.lastRowId();\n\n\t\t\tLog(StrF(_T(\"Added ClipData to DB, Id: %d, ParentId: %d Type: %s, size: %d\"), pCF->m_dataId, m_id, formatName, clipSize));\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\t\t\n\treturn true;\n}\n\nvoid CClip::MoveUp(int parentId)\n{\n\ttry\n\t{\n\t\t//In a group, not a sticky\n\t\tif(parentId > -1 && m_stickyClipGroupOrder == INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipGroupOrder FROM Main Where lParentID = %d AND stickyClipGroupOrder == -(2147483647) AND clipGroupOrder > %f ORDER BY clipGroupOrder ASC LIMIT 1\"), parentId, m_clipGroupOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idAbove = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderAbove = q.getFloatField(_T(\"clipGroupOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipGroupOrder FROM Main Where lParentID = %d AND clipGroupOrder > %f AND stickyClipGroupOrder == -(2147483647) ORDER BY clipGroupOrder ASC LIMIT 1\"), parentId, orderAbove);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{ \n\t\t\t\t\tint idTwoAbove = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoAbove = q2.getFloatField(_T(\"clipGroupOrder\"));\n\n\t\t\t\t\tm_clipGroupOrder = orderAbove + (orderTwoAbove - orderAbove) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_clipGroupOrder = orderAbove + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// main group, not a sticky\n\t\telse if(parentId <= -1 && m_stickyClipOrder == INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipOrder FROM Main Where clipOrder > %f AND stickyClipOrder == -(2147483647) ORDER BY clipOrder ASC LIMIT 1\"), m_clipOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idAbove = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderAbove = q.getFloatField(_T(\"clipOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipOrder FROM Main Where clipOrder > %f AND stickyClipOrder == -(2147483647) ORDER BY clipOrder ASC LIMIT 1\"), orderAbove);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{ \n\t\t\t\t\tint idTwoAbove = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoAbove = q2.getFloatField(_T(\"clipOrder\"));\n\n\t\t\t\t\tm_clipOrder = orderAbove + (orderTwoAbove - orderAbove) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_clipOrder = orderAbove + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//In a group, a sticky clip\n\t\telse if(parentId > -1 && m_stickyClipGroupOrder != INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipGroupOrder FROM Main Where lParentID = %d AND stickyClipGroupOrder <> -(2147483647) AND stickyClipGroupOrder > %f ORDER BY stickyClipGroupOrder ASC LIMIT 1\"), parentId, m_stickyClipGroupOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idAbove = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderAbove = q.getFloatField(_T(\"stickyClipGroupOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipGroupOrder FROM Main Where lParentID = %d AND stickyClipGroupOrder <> -(2147483647) AND stickyClipGroupOrder > %f ORDER BY stickyClipGroupOrder ASC LIMIT 1\"), parentId, orderAbove);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{\n\t\t\t\t\tint idTwoAbove = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoAbove = q2.getFloatField(_T(\"stickyClipGroupOrder\"));\n\n\t\t\t\t\tm_stickyClipGroupOrder = orderAbove + (orderTwoAbove - orderAbove) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_stickyClipGroupOrder = orderAbove + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//not in a group, a sticky clip\n\t\telse if(parentId <= -1 && m_stickyClipOrder != INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipOrder FROM Main Where stickyClipOrder <> -(2147483647) AND stickyClipOrder > %f ORDER BY stickyClipOrder ASC LIMIT 1\"), m_stickyClipOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idAbove = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderAbove = q.getFloatField(_T(\"stickyClipOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipOrder FROM Main Where stickyClipOrder <> -(2147483647) AND stickyClipOrder > %f ORDER BY stickyClipOrder ASC LIMIT 1\"), orderAbove);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{\n\t\t\t\t\tint idTwoAbove = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoAbove = q2.getFloatField(_T(\"stickyClipOrder\"));\n\n\t\t\t\t\tm_stickyClipOrder = orderAbove + (orderTwoAbove - orderAbove) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_stickyClipOrder = orderAbove + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n}\n\nvoid CClip::MoveDown(int parentId)\n{\n\ttry\n\t{\n\t\t//In a group, not a sticky\n\t\tif(parentId > -1 && m_stickyClipGroupOrder == INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipGroupOrder FROM Main Where lParentID = %d AND clipGroupOrder < %f AND stickyClipGroupOrder = -(2147483647) ORDER BY clipGroupOrder DESC LIMIT 1\"), parentId, m_clipGroupOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idBelow = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderBelow = q.getFloatField(_T(\"clipGroupOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipGroupOrder FROM Main Where lParentID = %d AND clipGroupOrder < %f AND stickyClipGroupOrder = -(2147483647) ORDER BY clipGroupOrder DESC LIMIT 1\"), parentId, orderBelow);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{ \n\t\t\t\t\tint idTwoBelow = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoBelow = q2.getFloatField(_T(\"clipGroupOrder\"));\n\n\t\t\t\t\tm_clipGroupOrder = orderBelow + (orderTwoBelow - orderBelow) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_clipGroupOrder = orderBelow - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// main group, not a sticky\n\t\telse if(parentId <= -1 && m_stickyClipOrder == INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipOrder FROM Main Where clipOrder < %f AND stickyClipOrder = -(2147483647) ORDER BY clipOrder DESC LIMIT 1\"), m_clipOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idBelow = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderBelow = q.getFloatField(_T(\"clipOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, clipOrder FROM Main Where clipOrder < %f AND stickyClipOrder = -(2147483647) ORDER BY clipOrder DESC LIMIT 1\"), orderBelow);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{ \n\t\t\t\t\tint idTwoBelow = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoBelow = q2.getFloatField(_T(\"clipOrder\"));\n\n\t\t\t\t\tm_clipOrder = orderBelow + (orderTwoBelow - orderBelow) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_clipOrder = orderBelow - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//In a group, a sticky clip\n\t\telse if(parentId > -1 && m_stickyClipGroupOrder != INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipGroupOrder FROM Main Where lParentID = %d AND stickyClipGroupOrder <> -(2147483647) AND stickyClipGroupOrder < %f ORDER BY stickyClipGroupOrder DESC LIMIT 1\"), parentId, m_stickyClipGroupOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idBelow = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderBelow = q.getFloatField(_T(\"stickyClipGroupOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipGroupOrder FROM Main Where lParentID = %d AND stickyClipGroupOrder <> -(2147483647) AND stickyClipGroupOrder < %f ORDER BY stickyClipGroupOrder DESC LIMIT 1\"), parentId, orderBelow);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{\n\t\t\t\t\tint idTwoBelow = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoBelow = q2.getFloatField(_T(\"stickyClipGroupOrder\"));\n\n\t\t\t\t\tm_stickyClipGroupOrder = orderBelow + (orderTwoBelow - orderBelow) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_stickyClipGroupOrder = orderBelow - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//not in a group, a sticky clip\n\t\telse if(parentId <= -1 && m_stickyClipOrder != INVALID_STICKY)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipOrder FROM Main Where stickyClipOrder <> -(2147483647) AND stickyClipOrder < %f ORDER BY stickyClipOrder DESC LIMIT 1\"), m_stickyClipOrder);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\tint idBelow = q.getIntField(_T(\"lID\"));\n\t\t\t\tdouble orderBelow = q.getFloatField(_T(\"stickyClipOrder\"));\n\n\t\t\t\tCppSQLite3Query q2 = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipOrder FROM Main Where stickyClipOrder <> -(2147483647) AND stickyClipOrder < %f ORDER BY stickyClipOrder DESC LIMIT 1\"), orderBelow);\n\t\t\t\tif (q2.eof() == false)\n\t\t\t\t{\n\t\t\t\t\tint idTwoBelow = q2.getIntField(_T(\"lID\"));\n\t\t\t\t\tdouble orderTwoBelow = q2.getFloatField(_T(\"stickyClipOrder\"));\n\n\t\t\t\t\tm_stickyClipOrder = orderBelow + (orderTwoBelow - orderBelow) / 2.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_stickyClipOrder = orderBelow - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n}\n\nvoid CClip::MakeStickyTop(int parentId)\n{\n\tif (parentId < 0)\n\t{\n\t\tm_stickyClipOrder = GetNewTopSticky(parentId, m_id);\n\t}\n\telse\n\t{\n\t\tm_stickyClipGroupOrder = GetNewTopSticky(parentId, m_id);\n\t}\n}\n\nvoid CClip::MakeStickyLast(int parentId)\n{\n\tif (parentId < 0)\n\t{\n\t\tm_stickyClipOrder = GetNewLastSticky(parentId, m_id);\n\t}\n\telse\n\t{\n\t\tm_stickyClipGroupOrder = GetNewLastSticky(parentId, m_id);\n\t}\n}\n\nbool CClip::RemoveStickySetting(int parentId)\n{\n\tbool reset = false;\n\tif (parentId < 0)\n\t{\n\t\tif (m_stickyClipOrder != INVALID_STICKY)\n\t\t{\n\t\t\tm_stickyClipOrder = INVALID_STICKY;\n\t\t\treset = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (m_stickyClipGroupOrder != INVALID_STICKY)\n\t\t{\n\t\t\tm_stickyClipGroupOrder = INVALID_STICKY;\n\t\t\treset = true;\n\t\t}\n\t}\n\n\treturn reset;\n}\n\nbool CClip::RemoveStickySetting(int clipId, int parentId)\n{\n\tbool reset = false;\n\tif (parentId < 0)\n\t{\n\t\tint c = theApp.m_db.execDMLEx(_T(\"UPDATE Main SET stickyClipOrder = %f WHERE lID = %d\"), (double)INVALID_STICKY, clipId);\n\t\tint y = 0;\n\t}\n\telse\n\t{\n\t\tint c = theApp.m_db.execDMLEx(_T(\"UPDATE Main SET stickyClipGroupOrder = %f WHERE lID = %d\"), (double)INVALID_STICKY, clipId);\n\t\tint y = 0;\n\t}\n\n\treturn reset;\n}\n\nint CClip::GetExistingTopStickyClipId(int parentId)\n{\n\tint existingTopClipId = -1;\n\n\ttry\n\t{\n\t\tif (parentId < 0)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT lID FROM Main WHERE stickyClipOrder <> -(2147483647) ORDER BY stickyClipOrder DESC LIMIT 1\"));\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingTopClipId = q.getIntField(_T(\"lID\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE lParentID = %d AND stickyClipGroupOrder <> -(2147483647) ORDER BY stickyClipGroupOrder DESC LIMIT 1\"), parentId);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingTopClipId = q.getIntField(_T(\"lID\"));\n\t\t\t}\n\t\t}\n\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\treturn existingTopClipId;\n}\n\ndouble CClip::GetNewTopSticky(int parentId, int clipId)\n{\n\tdouble newOrder = 1;\n\tdouble existingMaxOrder = 0;\n\tCString existingDesc = _T(\"\");\n\n\ttry\n\t{\n\t\tif (parentId < 0)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT lID, stickyClipOrder, mText FROM Main WHERE stickyClipOrder <> -(2147483647) ORDER BY stickyClipOrder DESC LIMIT 1\"));\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"stickyClipOrder\"));\n\t\t\t\texistingDesc = q.getStringField(_T(\"mText\"));\n\t\t\t\tnewOrder = existingMaxOrder + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, stickyClipGroupOrder, mText FROM Main WHERE lParentID = %d AND stickyClipGroupOrder <> -(2147483647) ORDER BY stickyClipGroupOrder DESC LIMIT 1\"), parentId);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"stickyClipGroupOrder\"));\n\t\t\t\tnewOrder = existingMaxOrder + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (newOrder == 0.0)\n\t\t\tnewOrder += 1;\n\n\t\tLog(StrF(_T(\"GetNewTopSticky, Id: %d, parentId: %d, CurrentMax: %f, CurrentDesc: %s, NewMax: %f\"), clipId, parentId, existingMaxOrder, existingDesc, newOrder));\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\treturn newOrder;\n}\n\ndouble CClip::GetNewLastSticky(int parentId, int clipId)\n{\n\tdouble newOrder = 1;\n\tdouble existingMaxOrder = 0;\n\tCString existingDesc = _T(\"\");\n\n\ttry\n\t{\n\t\tif (parentId < 0)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT stickyClipOrder, mText FROM Main WHERE stickyClipOrder <> -(2147483647) ORDER BY stickyClipOrder LIMIT 1\"));\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"stickyClipOrder\"));\n\t\t\t\texistingDesc = q.getStringField(_T(\"mText\"));\n\t\t\t\tnewOrder = existingMaxOrder - 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT stickyClipGroupOrder, mText FROM Main WHERE lParentID = %d AND stickyClipGroupOrder <> -(2147483647) ORDER BY stickyClipGroupOrder LIMIT 1\"), parentId);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"stickyClipGroupOrder\"));\n\t\t\t\tnewOrder = existingMaxOrder - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (newOrder == 0.0)\n\t\t\tnewOrder -= 1;\n\n\t\tLog(StrF(_T(\"GetNewLastSticky, Id: %d, parentId: %d, CurrentMax: %f, CurrentDesc: %s, NewMax: %f\"), clipId, parentId, existingMaxOrder, existingDesc, newOrder));\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\treturn newOrder;\n}\n\nvoid CClip::MakeLatestOrder()\n{\n\tm_clipOrder = GetNewOrder(-1, m_id);\n}\n\nvoid CClip::MakeLatestGroupOrder()\n{\n\tif(m_parentId > -1)\n\t{\n\t\tm_clipGroupOrder = GetNewOrder(m_parentId, m_id);\n\t}\n}\n\nvoid CClip::MakeLastOrder()\n{\n\tm_clipOrder = GetNewLastOrder(-1, m_id);\n}\n\nvoid CClip::MakeLastGroupOrder()\n{\n\tif (m_parentId > -1)\n\t{\n\t\tm_clipGroupOrder = GetNewLastOrder(m_parentId, m_id);\n\t}\n}\n\ndouble CClip::GetNewOrder(int parentId, int clipId)\n{\n\tdouble newOrder = 0;\n\tdouble existingMaxOrder = 0;\n\tCString existingDesc = _T(\"\");\n\n\ttry\n\t{\n\t\tif(parentId < 0)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT clipOrder, mText FROM Main ORDER BY clipOrder DESC LIMIT 1\"));\t\t\t\n\t\t\tif(q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"clipOrder\"));\n\t\t\t\texistingDesc = q.getStringField(_T(\"mText\"));\n\t\t\t\tnewOrder = existingMaxOrder + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT clipGroupOrder, mText FROM Main WHERE lParentID = %d ORDER BY clipGroupOrder DESC LIMIT 1\"), parentId);\t\t\t\n\t\t\tif(q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMaxOrder = q.getFloatField(_T(\"clipGroupOrder\"));\n\t\t\t\tnewOrder = existingMaxOrder + 1;\n\t\t\t}\n\t\t}\n\n\t\tLog(StrF(_T(\"GetNewOrder, Id: %d, parentId: %d, CurrentMax: %f, CurrentDesc: %s, NewMax: %f\"), clipId, parentId, existingMaxOrder, existingDesc, newOrder));\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\treturn newOrder;\n}\n\ndouble CClip::GetNewLastOrder(int parentId, int clipId)\n{\n\tdouble newOrder = 0;\n\tdouble existingMinOrder = 0;\n\tCString existingDesc = _T(\"\");\n\n\ttry\n\t{\n\t\tif (parentId < 0)\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT clipOrder, mText FROM Main where clipOrder notnull ORDER BY clipOrder ASC LIMIT 1\"));\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMinOrder = q.getFloatField(_T(\"clipOrder\"));\n\t\t\t\texistingDesc = q.getStringField(_T(\"mText\"));\n\t\t\t\tnewOrder = existingMinOrder - 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT clipGroupOrder, mText FROM Main WHERE lParentID = %d AND clipGroupOrder notnull ORDER BY clipGroupOrder ASC LIMIT 1\"), parentId);\n\t\t\tif (q.eof() == false)\n\t\t\t{\n\t\t\t\texistingMinOrder = q.getFloatField(_T(\"clipGroupOrder\"));\n\t\t\t\tnewOrder = existingMinOrder - 1;\n\t\t\t}\n\t\t}\n\n\t\tLog(StrF(_T(\"GetLastOrder, Id: %d, parentId: %d, CurrentMin: %f, CurrentDesc: %s, NewMax: %f\"), clipId, parentId, existingMinOrder, existingDesc, newOrder));\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\t\treturn newOrder;\n}\n\nBOOL CClip::LoadMainTable(int id)\n{\n\tbool bRet = false;\n\ttry\n\t{\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT * FROM Main WHERE lID = %d\"), id);\n\n\t\tif(q.eof() == false)\n\t\t{\n\t\t\tm_Time = q.getIntField(_T(\"lDate\"));\n\t\t\tm_Desc = q.getStringField(_T(\"mText\"));\n\t\t\tm_CRC = q.getIntField(_T(\"CRC\"));\n\t\t\tm_parentId = q.getIntField(_T(\"lParentID\"));\n\t\t\tm_dontAutoDelete = q.getIntField(_T(\"lDontAutoDelete\"));\n\t\t\tm_shortCut = q.getIntField(_T(\"lShortCut\"));\n\t\t\tm_bIsGroup = q.getIntField(_T(\"bIsGroup\"));\n\t\t\tm_csQuickPaste = q.getStringField(_T(\"QuickPasteText\"));\n\t\t\tm_clipOrder = q.getFloatField(_T(\"clipOrder\"));\n\t\t\tm_clipGroupOrder = q.getFloatField(_T(\"clipGroupOrder\"));\n\t\t\tm_globalShortCut = q.getIntField(_T(\"globalShortCut\"));\n\t\t\tm_lastPasteDate = q.getIntField(_T(\"lastPasteDate\"));\n\t\t\tm_stickyClipOrder = q.getFloatField(_T(\"stickyClipOrder\"));\n\t\t\tm_stickyClipGroupOrder = q.getFloatField(_T(\"stickyClipGroupOrder\"));\n\t\t\tm_moveToGroupShortCut = q.getIntField(_T(\"MoveToGroupShortCut\"));\n\t\t\tm_globalMoveToGroupShortCut = q.getIntField(_T(\"GlobalMoveToGroupShortCut\"));\n\n\t\t\tm_id = id;\n\n\t\t\tbRet = true;\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(FALSE)\n\n\treturn bRet;\n}\n\n// STATICS\n\n// Allocates a Global containing the requested Clip Format Data\nHGLOBAL CClip::LoadFormat(int id, UINT cfType)\n{\n\tHGLOBAL hGlobal = 0;\n\ttry\n\t{\n\t\tCString csSQL;\n\t\t\n\t\tcsSQL.Format(\n\t\t\t_T(\"SELECT Data.ooData FROM Data \")\n\t\t\t_T(\"INNER JOIN Main ON Main.lID = Data.lParentID \")\n\t\t\t_T(\"WHERE Main.lID = %d \")\n\t\t\t_T(\"AND Data.strClipBoardFormat = \\'%s\\'\"),\n\t\t\tid,\n\t\t\tGetFormatName(cfType));\n\n\t\tCppSQLite3Query q = theApp.m_db.execQuery(csSQL);\n\n\t\tif(q.eof() == false)\n\t\t{\n\t\t\tint nDataLen = 0;\n\t\t\tconst unsigned char *cData = q.getBlobField(0, nDataLen);\n\t\t\tif(cData == NULL)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\thGlobal = NewGlobalP((LPVOID)cData, nDataLen);\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\t\t\n\treturn hGlobal;\n}\n\nbool CClip::LoadFormats(int id, bool bOnlyLoad_CF_TEXT, bool includeRichTextForTextOnly)\n{\n\tDWORD startTick = GetTickCount();\n\tCClipFormat cf;\n\tHGLOBAL hGlobal = 0;\n\tm_Formats.RemoveAll();\n\n\ttry\n\t{\t\n\t\t//Open the data table for all that have the parent id\n\n\t\t//Order by Data.lID so that when generating CRC it's always in the same order as the first time\n\t\t//we generated it\n\t\tCString csSQL;\n\n\t\tCString textFilter = _T(\"\");\n\t\tif(bOnlyLoad_CF_TEXT)\n\t\t{\n\t\t\ttextFilter = _T(\"(strClipBoardFormat = 'CF_TEXT' OR strClipBoardFormat = 'CF_UNICODETEXT' OR strClipBoardFormat = 'CF_HDROP'\");\n\n\t\t\tif(includeRichTextForTextOnly)\n\t\t\t{\n\t\t\t\ttextFilter = textFilter + _T(\" OR strClipBoardFormat = 'Rich Text Format') AND \");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttextFilter = textFilter + _T(\") AND \");\n\t\t\t}\n\t\t}\n\n\t\tcsSQL.Format(\n\t\t\t_T(\"SELECT lID, lParentID, strClipBoardFormat, ooData FROM Data \")\n\t\t\t_T(\"WHERE %s lParentID = %d ORDER BY Data.lID desc\"), textFilter, id);\n\n\t\tCppSQLite3Query q = theApp.m_db.execQuery(csSQL);\n\n\t\twhile(q.eof() == false)\n\t\t{\n\t\t\tcf.m_dataId = q.getIntField(_T(\"lID\"));\n\t\t\tcf.m_parentId = q.getIntField(_T(\"lParentID\"));\n\t\t\tcf.m_cfType = GetFormatID(q.getStringField(_T(\"strClipBoardFormat\")));\n\t\t\t\n\t\t\tif(bOnlyLoad_CF_TEXT)\n\t\t\t{\n\t\t\t\tif(cf.m_cfType != CF_TEXT && \n\t\t\t\t\tcf.m_cfType != CF_UNICODETEXT &&\n\t\t\t\t\tcf.m_cfType != CF_HDROP &&\n\t\t\t\t\t(cf.m_cfType != theApp.m_RTFFormat && !includeRichTextForTextOnly))\n\t\t\t\t{\n\t\t\t\t\tq.nextRow();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nDataLen = 0;\n\t\t\tconst unsigned char *cData = q.getBlobField(_T(\"ooData\"), nDataLen);\n\t\t\tif(cData != NULL)\n\t\t\t{\n\t\t\t\thGlobal = NewGlobalP((LPVOID)cData, nDataLen);\n\t\t\t}\n\t\t\t\n\t\t\tcf.m_hgData = hGlobal;\n\t\t\tm_Formats.Add(cf);\n\n\t\t\tq.nextRow();\n\t\t}\n\n\t\t// formats owns all the data\n\t\tcf.m_hgData = 0;\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\t\t\n\tDWORD endTick = GetTickCount();\n\tif((endTick-startTick) > 150)\n\t\tLog(StrF(_T(\"Paste Timing LoadFormats: %d, ClipId: %d\"), endTick-startTick, id));\n\n\treturn m_Formats.GetSize() > 0;\n}\n\nvoid CClip::LoadTypes(int id, CClipTypes& types)\n{\n\ttypes.RemoveAll();\n\ttry\n\t{\n\t\tCString csSQL;\n\t\t// get formats for Clip \"lID\" (Main.lID) using the corresponding Main.lDataID\n\t\t\n\t\t//Order by Data.lID so that when generating CRC it's always in the same order as the first time\n\t\t//we generated it\n\t\tcsSQL.Format(\n\t\t\t_T(\"SELECT strClipBoardFormat FROM Data \")\n\t\t\t_T(\"INNER JOIN Main ON Main.lID = Data.lParentID \")\n\t\t\t_T(\"WHERE Main.lID = %d ORDER BY Data.lID desc\"), id);\n\n\t\tCppSQLite3Query q = theApp.m_db.execQuery(csSQL);\t\t\t\n\n\t\twhile(q.eof() == false)\n\t\t{\t\t\n\t\t\ttypes.Add(GetFormatID(q.getStringField(0)));\n\t\t\tq.nextRow();\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n}\n\nCStringW CClip::GetUnicodeTextFormat()\n{\n\tIClipFormat *pFormat = this->Clips()->FindFormatEx(CF_UNICODETEXT);\n\tif(pFormat != NULL)\n\t{\n\t\treturn pFormat->GetAsCString();\n\t}\n\n\treturn _T(\"\");\n}\n\nCStringA CClip::GetCFTextTextFormat()\n{\n\tIClipFormat *pFormat = this->Clips()->FindFormatEx(CF_TEXT);\n\tif(pFormat != NULL)\n\t{\n\t\treturn pFormat->GetAsCStringA();\n\t}\n\n\treturn _T(\"\");\n}\n\nCStringA CClip::GetRTFTextFormat()\n{\n\tIClipFormat* pFormat = this->Clips()->FindFormatEx(theApp.m_RTFFormat);\n\tif (pFormat != NULL)\n\t{\n\t\treturn pFormat->GetAsCStringA();\n\t}\n\n\treturn _T(\"\");\n}\n\nBOOL CClip::ContainsClipFormat(CLIPFORMAT clipFormat)\n{\n\treturn this->Clips()->FindFormatEx(clipFormat) != NULL;\n}\n\nBOOL CClip::WriteTextToFile(CString path, BOOL unicode, BOOL asci, BOOL rtf, BOOL forceUnicode)\n{\n\tBOOL ret = false;\n\n\tCFile f;\n\tif(f.Open(path, CFile::modeWrite|CFile::modeCreate))\n\t{\n\t\tCStringW w = GetUnicodeTextFormat();\n\t\tCStringA a = GetCFTextTextFormat();\n\t\tCStringA rtfA = GetRTFTextFormat();\t\t\n\n\t\tif(unicode && (w != _T(\"\") || forceUnicode))\n\t\t{\n\t\t\tstd::byte header[2];\n\t\t\theader[0] = (std::byte)0xFF;\n\t\t\theader[1] = (std::byte)0xFE;\n\t\t\tf.Write(&header, 2);\n\t\t\tf.Write(w.GetBuffer(), w.GetLength() * sizeof(wchar_t));\n\n\t\t\tret = true;\n\t\t}\n\t\telse if(asci && a != _T(\"\"))\n\t\t{\n\t\t\tf.Write(a.GetBuffer(), a.GetLength());\n\n\t\t\tret = true;\n\t\t}\n\t\telse if (rtf && rtfA != _T(\"\"))\n\t\t{\n\t\t\tf.Write(rtfA.GetBuffer(), rtfA.GetLength());\n\n\t\t\tret = true;\n\t\t}\n\n\t\tf.Close();\n\t}\n\n\treturn ret;\n}\n\nBOOL CClip::WriteTextToHtmlFile(CString path)\n{\n\tBOOL ret = false;\n\n\tCFile f;\n\tif (f.Open(path, CFile::modeWrite | CFile::modeCreate))\n\t{\n\t\tIClipFormat *pFormat = this->Clips()->FindFormatEx(theApp.m_HTML_Format);\n\t\tif (pFormat != NULL)\n\t\t{\n\t\t\tCStringA html = pFormat->GetAsCStringA();\n\n\t\t\tint pos = html.Find(\"<html\");\n\t\t\tif (pos >= 0)\n\t\t\t{\n\t\t\t\thtml = html.Mid(pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thtml = html;\n\t\t\t}\n\n\t\t\tf.Write(html.GetBuffer(), html.GetLength());\t\t\t\n\t\t}\n\n\t\tf.Close();\n\t}\n\n\treturn ret;\n}\n\nBOOL CClip::SaveFormats(CString *unicode, CStringA *asci, CStringA *rtf, BOOL updateDescription)\n{\n\tARRAY deletedData;\n\tfor (INT_PTR i = m_Formats.GetSize() - 1; i >= 0; i--)\n\t{\n\t\tdeletedData.Add(m_Formats[i].m_dataId);\n\t}\n\n\tEmptyFormats();\n\n\tif (rtf != nullptr)\n\t{\n\t\tconst int nLength = rtf->GetLength() + sizeof(char);\n\t\tAddFormat(theApp.m_RTFFormat, rtf->GetBuffer(nLength), nLength, true);\n\t}\n\n\tif (asci != nullptr)\n\t{\n\t\tconst int nLength = asci->GetLength() + sizeof(char);\n\t\tAddFormat(CF_TEXT, asci->GetBuffer(nLength), nLength, true);\n\t}\n\n\tif (unicode != nullptr)\n\t{\n\t\tconst int nLength = unicode->GetLength() * sizeof(wchar_t) + sizeof(wchar_t);\n\t\tAddFormat(CF_UNICODETEXT, unicode->GetBuffer(nLength), nLength, true);\n\t}\n\n\ttry\n\t{\n\t\tm_CRC = GenerateCRC();\n\n\t\ttheApp.m_db.execDML(_T(\"begin transaction;\"));\n\n\t\tauto count = deletedData.GetSize();\n\t\tfor (int i = 0; i < count; i++)\n\t\t{\n\t\t\tint count = theApp.m_db.execDMLEx(_T(\"DELETE FROM Data WHERE lID = %d;\"), deletedData[i]);\n\t\t}\n\n\t\tif (m_id >= 0)\n\t\t{\n\t\t\tif (updateDescription)\n\t\t\t{\n\t\t\t\tModifyDescription();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMakeLatestOrder();\n\t\t\tMakeLatestGroupOrder();\n\t\t\tAddToMainTable();\n\t\t}\n\n\t\tAddToDataTable();\n\n\t\ttheApp.m_db.execDML(_T(\"commit transaction;\"));\n\t}\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\n\n\treturn TRUE;\n}\n\nBOOL CClip::WriteImageToFile(CString path)\n{\n\tCClipFormat *bitmap = this->m_Formats.FindFormat(CF_DIB);\n\tCClipFormat *png = this->m_Formats.FindFormat(theApp.m_PNG_Format);\n\tif (!bitmap && !png) return false;\n\t\n\tstd::shared_ptr<CImage> i;\n\t// png is more closer to original\n\tif (png)\n\t\ti = PNGImageHelper::CImageFromHGLOBAL(png->m_hgData);\n\telse\n\t\ti = DIBImageHelper::CImageFromHGLOBAL(bitmap->m_hgData);\n\n\treturn i->Save(path) == S_OK;\n}\n\nbool CClip::AddFileDataToData(CString &errorMessage)\n{\n\tINT_PTR size = m_Formats.GetSize();\n\tif (size <= 0)\n\t{\n\t\terrorMessage = _T(\"No CF_HDROP formats to convert\");\n\t\treturn false;\n\t}\n\n\tbool addedFileData = false;\n\n\tint nCF_HDROPIndex = -1;\n\tint dittoDataIndex = -1;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (m_Formats[i].m_cfType == CF_HDROP)\n\t\t{\n\t\t\tnCF_HDROPIndex = i;\n\t\t}\n\t\telse if(m_Formats[i].m_cfType == theApp.m_DittoFileData)\n\t\t{\n\t\t\tdittoDataIndex = i;\n\t\t}\n\t}\t\n\n\tif (nCF_HDROPIndex < 0)\n\t{\n\t\terrorMessage = _T(\"No CF_HDROP formats to convert\");\n\t\treturn false;\n\t}\n\telse if (dittoDataIndex >= 0)\n\t{\n\t\treturn false;\n\t}\n\n\tusing namespace nsPath;\n\n\tHDROP drop = (HDROP)GlobalLock(m_Formats[nCF_HDROPIndex].m_hgData);\n\tint nNumFiles = DragQueryFile(drop, -1, NULL, 0);\n\n\tTCHAR filePath[MAX_PATH];\n\n\tCString newDesc = _T(\"File Contents - \");\n\tint maxSize = CGetSetOptions::GetMaxFileContentsSize();\n\tfor (int nFile = 0; nFile < nNumFiles; nFile++)\n\t{\n\t\tif (DragQueryFile(drop, nFile, filePath, sizeof(filePath)) == 0)\n\t\t\tcontinue;\n\n\t\tCFile file;\n\t\tCFileException ex;\n\t\tif (!file.Open(filePath, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone, &ex))\n\t\t{\n\t\t\tTCHAR szError[200];\n\t\t\tex.GetErrorMessage(szError, 200);\n\t\t\terrorMessage += StrF(_T(\"Error opening file: %s, Error: %s\\r\\n\"), filePath, szError);\n\t\t\tcontinue;\n\t\t}\n\n\t\tint fileSize = (int)file.GetLength();\n\t\tif (fileSize >= maxSize)\n\t\t{\n\t\t\tconst int MAX_FILE_SIZE_BUFFER = 255;\n\t\t\tTCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\n\t\t\tTCHAR szMaxFileSize[MAX_FILE_SIZE_BUFFER];\n\t\t\tStrFormatByteSize(fileSize, szFileSize, MAX_FILE_SIZE_BUFFER);\n\t\t\tStrFormatByteSize(maxSize, szMaxFileSize, MAX_FILE_SIZE_BUFFER);\n\n\t\t\terrorMessage += StrF(_T(\"File is to large: %s, Size: %s, Max Size: %s\\r\\n\"), filePath, szFileSize, szMaxFileSize);\n\t\t\tcontinue;\n\t\t}\n\n\t\tCString src(filePath);\n\t\tCStringA csFilePath = CTextConvert::UnicodeToUTF8(src);\n\n\t\t//data contents\n\t\t//original file<null terminator>md5<null terminator>file data\n\t\tint bufferSize = (int)fileSize + csFilePath.GetLength() + 1 + md5StringLength + 1;;\n\t\tchar* pBuffer = new char[bufferSize]();\n\t\tstrncpy(pBuffer, csFilePath, csFilePath.GetLength());\n\n\t\t//move the buffer start past the file path and md5 string\n\t\tchar* bufferStart = pBuffer + csFilePath.GetLength() + 1 + md5StringLength + 1;\n\n\t\tint readBytes = (int)file.Read(bufferStart, fileSize);\n\n\t\tCMd5 md5;\n\t\tCStringA md5String = md5.CalcMD5FromString(bufferStart, fileSize);\n\n\t\tchar* bufferMd5 = pBuffer + csFilePath.GetLength() + 1;\n\t\tstrncpy(bufferMd5, md5String, md5StringLength);\n\n\t\tAddFormat(theApp.m_DittoFileData, pBuffer, bufferSize);\n\n\t\taddedFileData = true;\n\n\t\tnewDesc += filePath;\n\t\tnewDesc += _T(\"\\n\");\n\n\t\tLog(StrF(_T(\"Saving file contents to Ditto Database, file: %s, size: %d, md5: %s\"), filePath, fileSize, md5String));\n\t}\n\n\tGlobalUnlock(m_Formats[nCF_HDROPIndex].m_hgData);\n\n\tif (!addedFileData)\n\t\treturn false;\n\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tthis->m_Formats.RemoveAt(i, 1);\n\t}\n\n\tthis->m_Desc = newDesc;\n\n\tif (this->ModifyDescription())\n\t{\n\t\tif (this->AddToDataTable() == FALSE)\n\t\t{\n\t\t\terrorMessage += _T(\"Error saving data to database.\");\n\t\t}\n\t}\n\telse\n\t{\n\t\terrorMessage += _T(\"Error saving main table to database.\");\n\t}\n\n\treturn addedFileData;\n}\n\nGdiplus::Bitmap *CClip::CreateGdiplusBitmap()\n{\n\tCClipFormat *png = this->m_Formats.FindFormat(GetFormatID(_T(\"PNG\")));\n\tif (png != NULL)\n\t\treturn png->CreateGdiplusBitmap();\n\n\tCClipFormat *dib = this->m_Formats.FindFormat(CF_DIB);\n\tif (dib != NULL)\n\t\treturn dib->CreateGdiplusBitmap();\n\n\treturn nullptr;\n}\n\n/*----------------------------------------------------------------------------*\\\nCClipList\n\\*----------------------------------------------------------------------------*/\n\nCClipList::~CClipList()\n{\n\tCClip* pClip;\n\twhile(GetCount())\n\t{\n\t\tpClip = RemoveHead();\n\t\tdelete pClip;\n\t}\n}\n\n// returns the number of clips actually saved\n// while this does empty the Format Data, it does not delete the Clips.\nint CClipList::AddToDB(bool bLatestOrder)\n{\n\tLog(_T(\"AddToDB - Start\"));\n\n\tint savedCount = 0;\n\tCClip* pClip;\n\tPOSITION pos;\n\tbool bResult;\n\t\n\tINT_PTR remaining = GetCount();\n\tpos = GetHeadPosition();\n\twhile(pos)\n\t{\n\t\tLog(StrF(_T(\"AddToDB - while(pos), Start Remaining %d\"), remaining));\n\t\tremaining--;\n\t\t\n\t\tpClip = GetNext(pos);\n\t\tASSERT(pClip);\n\t\t\n\t\tif(bLatestOrder)\n\t\t{\n\t\t\tpClip->MakeLatestOrder();\n\t\t\tpClip->MakeLatestGroupOrder();\n\t\t}\n\n\t\tbResult = pClip->AddToDB();\n\t\tif(bResult)\n\t\t{\n\t\t\tsavedCount++;\n\t\t}\n\n\t\tLog(StrF(_T(\"AddToDB - while(pos), End Remaining %d, save count: %d\"), remaining, savedCount));\n\t}\n\n\tLog(StrF(_T(\"AddToDB - Start, count: %d\"), savedCount));\n\t\n\treturn savedCount;\n}\n\nconst CClipList& CClipList::operator=(const CClipList &cliplist)\n{\n\tPOSITION pos;\n\tCClip* pClip;\n\t\n\tpos = cliplist.GetHeadPosition();\n\twhile(pos)\n\t{\n\t\tpClip = cliplist.GetNext(pos);\n\t\tASSERT(pClip);\n\n\t\tCClip *pNewClip = new CClip;\n\t\tif(pNewClip)\n\t\t{\n\t\t\t*pNewClip = *pClip;\n\t\t\t\n\t\t\tAddTail(pNewClip);\n\t\t}\n\t}\n\t\n\treturn *this;\n}\n"
        },
        {
          "name": "Clip.h",
          "type": "blob",
          "size": 7.8876953125,
          "content": "// Clip.h: classes for manage clips\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\r\n#define AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n#include <afxole.h>\r\n#include <afxtempl.h>\r\n#include <memory>\r\n#include \"tinyxml\\tinyxml.h\"\r\n#include \"Shared\\IClip.h\"\r\n#include \"Misc.h\"\r\n\r\nclass CClip;\r\nclass CCopyThread;\r\n\r\ntypedef CArray<CLIPFORMAT, CLIPFORMAT> CClipTypes;\r\n\r\n/*----------------------------------------------------------------------------*\\\r\n\tCOleDataObjectEx\r\n\\*----------------------------------------------------------------------------*/\r\nclass COleDataObjectEx : public COleDataObject\r\n{\r\npublic:\r\n\t// creates global from IStream if necessary\r\n\tHGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);\r\n\tstd::shared_ptr<CClipTypes> GetAvailableTypes();\r\n};\r\n\r\n/*----------------------------------------------------------------------------*\\\r\n\tCClipFormat - holds the data of one clip format.\r\n\\*----------------------------------------------------------------------------*/\r\nclass CClipFormat : public IClipFormat\r\n{\r\npublic:\r\n\tCLIPFORMAT m_cfType;\r\n    HGLOBAL m_hgData;\r\n\tbool m_autoDeleteData;\r\n\tint m_dataId;\r\n\tint m_parentId;\r\n\r\n\tCClipFormat(CLIPFORMAT cfType = 0, HGLOBAL hgData = 0, int parentId = -1);\r\n\t~CClipFormat();\r\n\r\n\tvoid Clear();\r\n\tvirtual void Free();\r\n\r\n\tvirtual CLIPFORMAT Type() { return m_cfType; }\r\n\tvirtual HGLOBAL Data() { return m_hgData; }\r\n\tvirtual void Type(CLIPFORMAT type) { m_cfType = type; }\r\n\tvirtual void Data(HGLOBAL data) { m_hgData = data; }\r\n\tvirtual void AutoDeleteData(bool autoDeleteData) { m_autoDeleteData = autoDeleteData; }\r\n\tvirtual bool AutoDeleteData()\t{ return m_autoDeleteData; }\r\n\r\n\tCStringA GetAsCStringA() {\r\n\t\tCStringA ret;\r\n\r\n\t\tif (m_hgData)\r\n\t\t{\r\n\t\t\tLPVOID data = GlobalLock(m_hgData);\r\n\t\t\tint size = (int)GlobalSize(m_hgData);\r\n\t\t\tif (data != NULL && size > 0)\r\n\t\t\t{\r\n\t\t\t\tret = CStringA((char *)data, size-1);\r\n\t\t\t}\r\n\r\n\t\t\tGlobalUnlock(m_hgData);\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tCString GetAsCString() {\r\n\t\tCString ret;\r\n\t\t\r\n\t\tif (m_hgData)\r\n\t\t{\r\n\t\t\tLPVOID data = GlobalLock(m_hgData);\r\n\t\t\tint size = (int)GlobalSize(m_hgData);\r\n\t\t\tif (data != NULL && size > 0)\r\n\t\t\t{\r\n\t\t\t\tret = CString((wchar_t *)data, ((size / (sizeof(wchar_t))) - 1));\r\n\t\t\t}\r\n\r\n\t\t\tGlobalUnlock(m_hgData);\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tGdiplus::Bitmap *CreateGdiplusBitmap();\r\n};\r\n\r\n/*----------------------------------------------------------------------------*\\\r\n\tCClipFormats - holds an array of CClipFormat\r\n\\*----------------------------------------------------------------------------*/\r\nclass CClipFormats : public CArray<CClipFormat,CClipFormat&>, public IClipFormats\r\n{\r\npublic:\r\n\t// returns a pointer to the CClipFormat in this array which matches the given type\r\n\t//  or NULL if that type doesn't exist in this array.\r\n\tCClipFormat* FindFormat(UINT cfType); \r\n\r\n\tvirtual int Size() { return (int)this->GetCount(); }\r\n\tvirtual IClipFormat *GetAt(int nPos) { return &this->ElementAt(nPos); }\r\n\tvirtual void DeleteAt(int nPos) { this->RemoveAt(nPos); }\r\n\tvirtual void DeleteAll() { this->RemoveAll(); }\r\n\tvirtual INT_PTR AddNew(CLIPFORMAT type, HGLOBAL data) {CClipFormat ft(type, data, -1); ft.m_autoDeleteData = false; return this->Add(ft); }\r\n\tvirtual IClipFormat *FindFormatEx(CLIPFORMAT type)\t{ return FindFormat((UINT)type); }\r\n\tvirtual bool RemoveFormat(CLIPFORMAT type);\r\n};\r\n\r\n\r\n/*----------------------------------------------------------------------------*\\\r\n\tCClip - holds multiple CClipFormats and clip statistics\r\n\t- provides static functions for manipulating a Clip as a single unit.\r\n\\*----------------------------------------------------------------------------*/\r\nclass CClip : public IClip\r\n{\r\npublic:\r\n\tCClip();\r\n\t~CClip();\r\n\tconst CClip& operator=(const CClip &clip);\r\n\r\n\tstatic DWORD m_LastAddedCRC;\r\n\tstatic int m_lastAddedID;\r\n\r\n\tint m_id;\r\n\tCClipFormats m_Formats;\r\n\tCTime m_Time;\r\n\tCString m_Desc;\r\n\tULONG m_lTotalCopySize;\r\n\tint m_parentId;\r\n\tint m_dontAutoDelete;\r\n\tint m_shortCut;\r\n\tBOOL m_bIsGroup;\r\n\tDWORD m_CRC;\r\n\tCString m_csQuickPaste;\r\n\tint m_param1;\r\n\tdouble m_clipOrder;\r\n\tdouble m_clipGroupOrder;\r\n\tdouble m_stickyClipOrder;\r\n\tdouble m_stickyClipGroupOrder;\r\n\tBOOL m_globalShortCut;\r\n\tCTime m_lastPasteDate;\r\n\tint m_moveToGroupShortCut;\r\n\tBOOL m_globalMoveToGroupShortCut;\r\n\tCopyReasonEnum::CopyReason m_copyReason;\r\n\r\n\tvirtual CString Description() { return m_Desc; }\r\n\tvirtual void Description(CString csValue) { m_Desc = csValue; }\r\n\tvirtual CTime PasteTime() { return m_Time; }\r\n\tvirtual int ID() { return m_id; }\r\n\tvirtual int Parent() { return m_parentId; }\r\n\tvirtual void Parent(int nParent) { m_parentId = nParent; }\r\n\tvirtual int DontAutoDelete() { return m_dontAutoDelete; }\r\n\tvirtual void DontAutoDelete(int Dont) { m_dontAutoDelete = Dont; }\r\n\tvirtual CString QuickPaste() { return m_csQuickPaste; }\r\n\tvirtual void QuickPaste(CString csValue) { m_csQuickPaste = csValue; }\r\n\r\n\tvirtual void SetSaveToDbSticky(AddToDbStickyEnum::AddToDbSticky option) { m_addToDbStickyEnum = option; }\r\n\r\n\tvirtual IClipFormats *Clips() { return (IClipFormats*)&m_Formats; }\r\n\r\n\tvoid Clear();\r\n\tvoid EmptyFormats();\r\n\tbool AddFormat(CLIPFORMAT cfType, void* pData, UINT nLen, bool setDesc = false);\r\n\tint LoadFromClipboard(CClipTypes* pClipTypes, bool checkClipboardIgnore = true, CString activeApp = _T(\"\"), CString activeAppTitle = _T(\"\"));\r\n\tbool SetDescFromText(HGLOBAL hgData, bool unicode);\r\n\tbool SetDescFromType();\r\n\tbool AddToDB(bool bCheckForDuplicates = true);\r\n\tbool ModifyMainTable();\r\n\tbool ModifyDescription();\t\r\n\tvoid MakeLatestOrder();\r\n\tvoid MakeLatestGroupOrder();\r\n\tvoid MakeLastOrder();\r\n\tvoid MakeLastGroupOrder();\r\n\tvoid MakeStickyTop(int parentId);\r\n\tvoid MakeStickyLast(int parentId);\r\n\tbool RemoveStickySetting(int parentId);\r\n\tBOOL LoadMainTable(int id);\r\n\tDWORD GenerateCRC();\r\n\tvoid MoveUp(int parentId);\r\n\tvoid MoveDown(int parentId);\r\n\r\n\tCStringW GetUnicodeTextFormat();\r\n\tCStringA GetCFTextTextFormat();\r\n\tCStringA GetRTFTextFormat();\r\n\r\n\tBOOL ContainsClipFormat(CLIPFORMAT clipFormat);\r\n\r\n\tBOOL WriteTextToFile(CString path, BOOL unicode, BOOL asci, BOOL rtf, BOOL forceUnicode = FALSE);\r\n\tBOOL WriteImageToFile(CString path);\r\n\tBOOL WriteTextToHtmlFile(CString path);\r\n\r\n\tBOOL SaveFormats(CString* unicode, CStringA* asci, CStringA* rtf, BOOL updateDescription);\r\n\r\n\t// Allocates a Global containing the requested Clip's Format Data\r\n\tstatic HGLOBAL LoadFormat(int id, UINT cfType);\r\n\t// Fills \"formats\" with the Data of all Formats in the db for the given Clip ID\r\n\tbool LoadFormats(int id, bool bOnlyLoad_CF_TEXT = false, bool includeRichTextForTextOnly = false);\r\n\t// Fills \"types\" with all Types in the db for the given Clip ID\r\n\tstatic void LoadTypes(int id, CClipTypes& types);\r\n\r\n\tstatic double GetNewOrder(int parentId, int clipId);\r\n\tdouble GetNewLastOrder(int parentId, int clipId);\r\n\tstatic double GetNewTopSticky(int parentId, int clipId);\r\n\tstatic double GetNewLastSticky(int parentId, int clipId);\r\n\tstatic int GetExistingTopStickyClipId(int parentId);\r\n\tstatic bool RemoveStickySetting(int clipId, int parentId);\r\n\r\n\tbool AddFileDataToData(CString &errorMessage);\r\n\r\n\tGdiplus::Bitmap *CreateGdiplusBitmap();\r\n\t\r\nprotected:\r\n\tbool AddToMainTable();\r\n\tbool AddToDataTable();\r\n\tint FindDuplicate();\r\n\r\n\tAddToDbStickyEnum::AddToDbSticky m_addToDbStickyEnum;\r\n};\r\n\r\n\r\n/*----------------------------------------------------------------------------*\\\r\n\tCClipList\r\n\\*----------------------------------------------------------------------------*/\r\n\r\nclass CClipList : public CList<CClip*,CClip*>\r\n{\r\npublic:\r\n\t~CClipList();\r\n\t// returns the number of clips actually saved\r\n\t// while this does empty the Format Data, it does not delete the Clips.\r\n\tint AddToDB( bool bLatestOrder = false);\r\n\r\n\tconst CClipList& operator=(const CClipList &cliplist);\r\n};\r\n\r\n#endif // !defined(AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\r\n"
        },
        {
          "name": "ClipCompare.cpp",
          "type": "blob",
          "size": 4.376953125,
          "content": "#include \"stdafx.h\"\r\n#include \"ClipCompare.h\"\r\n#include \"Misc.h\"\r\n#include \"Options.h\"\r\n\r\nCClipCompare::CClipCompare(void)\r\n{\r\n}\r\n\r\n\r\nCClipCompare::~CClipCompare(void)\r\n{\r\n}\r\n\r\n\r\nvoid CClipCompare::Compare(int leftId, int rightId)\r\n{\r\n\tCClip leftClip;\r\n\tif(leftClip.LoadFormats(leftId, true))\r\n\t{\r\n\t\tCClip rightClip;\r\n\t\tif(rightClip.LoadFormats(rightId, true))\r\n\t\t{\r\n\t\t\tbool saveW = true;\r\n\t\t\tbool saveA = true;\r\n\t\t\t\r\n\t\t\tif(leftClip.GetUnicodeTextFormat() == _T(\"\") || rightClip.GetUnicodeTextFormat() == _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tsaveW = false;\r\n\t\t\t}\r\n\r\n\t\t\tif(leftClip.GetCFTextTextFormat() == \"\" || rightClip.GetCFTextTextFormat() == \"\")\r\n\t\t\t{\r\n\t\t\t\tsaveA = false;\r\n\t\t\t}\r\n\r\n\t\t\tif(saveW || saveA)\r\n\t\t\t{\r\n\t\t\t\tCString leftFile = SaveToFile(leftId, &leftClip, saveW, saveA);\r\n\t\t\t\tCString rightFile = SaveToFile(rightId, &rightClip, saveW, saveA);\r\n\r\n\t\t\t\tCString params = _T(\"\");\r\n\t\t\t\tCString path = GetComparePath(params);\r\n\r\n\t\t\t\tif(path != _T(\"\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\r\n\t\t\t\t\tsei.lpFile = path;\r\n\t\t\t\t\tCString csParam;\r\n\t\t\t\t\tcsParam.Format(_T(\"%s\\\"%s\\\" \\\"%s\\\"\"), params, leftFile, rightFile);\r\n\t\t\t\t\tsei.lpParameters = csParam;\r\n\t\t\t\t\tsei.nShow = SW_NORMAL;\r\n\r\n\t\t\t\t\tLog(StrF(_T(\"Comparing two clips, left Id %d, right Id %d, Path: %s %s\"), leftId, rightId, path, csParam));\r\n\r\n\t\t\t\t\tif (!ShellExecuteEx(&sei))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"CClipCompare::Compare, No Valid compare apps, not doing compare\")));\r\n\r\n\t\t\t\t\tShellExecute(NULL, _T(\"open\"), _T(\"http://winmerge.org/\"), NULL,NULL, SW_SHOW);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\t\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"CClipCompare::Compare, did not find valid text for both passed in clips\")));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"CClipCompare::Compare, Failed to load RIGHT clip formats Id: %d\"), rightId));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"CClipCompare::Compare, Failed to load LEFT clip formats Id: %d\"), leftId));\r\n\t}\r\n}\r\n\r\nCString CClipCompare::GetComparePath(CString &params)\r\n{\r\n\tCString path = CGetSetOptions::GetDiffApp();\r\n\r\n\tif(path != _T(\"\"))\r\n\t{\r\n\t\tif (path.Find(_T(\"totalcmd.exe\")) != -1 || \r\n\t\t\tpath.Find(_T(\"totalcmd64.exe\")) != -1)\r\n\t\t{\r\n\t\t\tparams = _T(\" /S=C \");\r\n\t\t}\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files (x86)\\\\Beyond Compare 3\\\\BCompare.exe\");\r\n\tif(FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files\\\\Beyond Compare 3\\\\BCompare.exe\");\r\n\tif(FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files (x86)\\\\Beyond Compare 4\\\\BCompare.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files\\\\Beyond Compare 4\\\\BCompare.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files (x86)\\\\WinMerge\\\\WinMergeU.exe\");\r\n\tif(FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files\\\\WinMerge\\\\WinMergeU.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files (x86)\\\\Araxis\\\\Araxis Merge\\\\compare.exe\");\r\n\tif(FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files\\\\Araxis\\\\Araxis Merge\\\\compare.exe\");\r\n\tif(FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files (x86)\\\\Perforce\\\\p4merge.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"C:\\\\Program Files\\\\Perforce\\\\p4merge.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"c:\\\\Program Files\\\\totalcmd\\\\totalcmd64.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\tparams = _T(\" /S=C \");\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"c:\\\\Program Files (x86)\\\\totalcmd\\\\totalcmd.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\tparams = _T(\" /S=C \");\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"c:\\\\totalcmd\\\\totalcmd64.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\tparams = _T(\" /S=C \");\r\n\t\treturn path;\r\n\t}\r\n\r\n\tpath = _T(\"c:\\\\totalcmd\\\\totalcmd.exe\");\r\n\tif (FileExists(path))\r\n\t{\r\n\t\tparams = _T(\" /S=C \");\r\n\t\treturn path;\r\n\t}\r\n\r\n\r\n\treturn _T(\"\");\r\n}\r\n\r\nCString CClipCompare::SaveToFile(int id, CClip *pClip, bool saveW, bool SaveA)\r\n{\r\n\tCString path;\r\n\tCString pathCompare = CGetSetOptions::GetPath(PATH_CLIP_DIFF);\r\n\tCString cs;\r\n\tcs.Format(_T(\"%sditto_compare_%d.txt\"), pathCompare, id);\r\n\r\n\tif(FileExists(cs))\r\n\t{\r\n\t\tfor(int i = 0; i < 1000; i++)\r\n\t\t{\t\t\t\r\n\t\t\tcs.Format(_T(\"%sditto_compare_%d.txt\"), pathCompare, id);\r\n\t\t\tif(FileExists(cs))\r\n\t\t\t{\r\n\t\t\t\tpath = cs;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpath = cs;\r\n\t}\r\n\r\n\tif(path != _T(\"\") && \r\n\t\tpClip != NULL)\r\n\t{\r\n\t\tpClip->WriteTextToFile(path, saveW, SaveA, false);\r\n\t}\r\n\r\n\treturn path;\r\n}"
        },
        {
          "name": "ClipCompare.h",
          "type": "blob",
          "size": 0.2783203125,
          "content": "#pragma once\r\n#include \"Clip.h\"\r\n\r\nclass CClipCompare\r\n{\r\npublic:\r\n\tCClipCompare(void);\r\n\t~CClipCompare(void);\r\n\r\n\tvoid Compare(int leftId, int rightId);\r\n\r\nprotected:\r\n\tCString SaveToFile(int id, CClip *clip, bool saveW, bool SaveA);\r\n\tCString GetComparePath(CString &params);\r\n};\r\n\r\n"
        },
        {
          "name": "ClipEditThread.cpp",
          "type": "blob",
          "size": 8.8818359375,
          "content": "#include \"stdafx.h\"\n#include \"ClipEditThread.h\"\n#include \"Options.h\"\n#include \"Misc.h\"\n#include \"Clip.h\"\n#include \"CP_Main.h\"\n#include \"ConvertRTFToText.h\"\n#include \"Shared/TextConvert.h\"\n\n#define EVENT_FILE_CHANGED 1\n\n#define MAX_TIMEOUT 86400\n\nCClipEditThread::CClipEditThread()\n{\n\tm_folderHandle = INVALID_HANDLE_VALUE;\n\tm_threadName = _T(\"ClipEditTrackingThread\");\n\tm_waitTimeout = MAX_TIMEOUT;\n}\n\nCClipEditThread::~CClipEditThread()\n{\n\tClose();\n}\n\nvoid CClipEditThread::Close()\n{\n\tStop();\n\n\tif (m_folderHandle != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(m_folderHandle);\n\t\tm_folderHandle = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (m_overlapped.hEvent != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(m_overlapped.hEvent);\n\t\tm_overlapped.hEvent = INVALID_HANDLE_VALUE;\n\t}\n\n\tCString editClipFolder = CGetSetOptions::GetPath(PATH_EDIT_CLIPS);\n\tDeleteFolderFiles(editClipFolder, TRUE, CTimeSpan(7, 0, 0, 0));\n}\n\nvoid CClipEditThread::StartWatchingFolderForChanges()\n{\n\tCString editClipFolder = CGetSetOptions::GetPath(PATH_EDIT_CLIPS);\n\n\tm_folderHandle = CreateFileW(editClipFolder, FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED, NULL);\n\t\n\tm_overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\tAddEvent(EVENT_FILE_CHANGED, m_overlapped.hEvent);\t\n\n\tRefreshWatch();\t\t\n\n\tStart();\n}\n\nvoid CClipEditThread::WatchFile(CString filePath)\n{\n\tATL::CCritSecLock csLock(m_fileEditsLock.m_sect);\n\n\tnsPath::CPath path(filePath);\n\n\t//start the edit count at 0, the first edit notification is us saving the file, after that handle the file change\n\tm_fileEditStarts[path.GetName()] = CTime::GetCurrentTime();\n}\n\nvoid CClipEditThread::RefreshWatch()\n{\n\tmemset(m_fileChangeBuffer, 0, sizeof(m_fileChangeBuffer));\n\n\tDWORD bytesReturned = 0;\n\tReadDirectoryChangesW(m_folderHandle, m_fileChangeBuffer, sizeof(m_fileChangeBuffer), FALSE, \n\t\tFILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_SIZE, \n\t\t&bytesReturned, &m_overlapped, NULL);\n}\n\nvoid CClipEditThread::OnTimeOut(void* param)\n{\n\tif (m_waitTimeout == MAX_TIMEOUT)\n\t{\n\t\tCString editClipFolder = CGetSetOptions::GetPath(PATH_EDIT_CLIPS);\n\t\tDeleteFolderFiles(editClipFolder, TRUE, CTimeSpan(7, 0, 0, 0));\n\n\t\t//cleanup up the list of edits that we started, after 7 days just keeps the list from growing too large, hopefull they don't have millions of edits in 7 days\n\t\tfor (auto it = m_fileEditStarts.begin(); it != m_fileEditStarts.end();)\n\t\t{\n\t\t\tauto diff = CTime::GetCurrentTime() - it->second;\n\t\t\tif (diff.GetTotalSeconds() > (86400 * 7))\n\t\t\t{\n\t\t\t\tit = m_fileEditStarts.erase(it);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\t\t\n\t}\n\telse\n\t{\n\t\tfor (auto const& toSave : m_filesToSave)\n\t\t{\n\t\t\tCString fileName = toSave.first;\n\t\t\tCString editClipFileName = _T(\"EditClip_\");\n\t\t\tCString newClipFileName = _T(\"NewClip_\");\n\n\t\t\tif (fileName.Find(editClipFileName, 0) == 0)\n\t\t\t{\n\t\t\t\tnsPath::CPath path(fileName);\n\t\t\t\tCString idString = path.GetTitle().Mid(editClipFileName.GetLength());\n\n\t\t\t\tint id = _wtoi(idString);\n\t\t\t\tif (id > 0)\n\t\t\t\t{\n\t\t\t\t\tSaveToClip(fileName, id);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fileName.Find(newClipFileName, 0) == 0)\n\t\t\t{\n\t\t\t\tSaveToClip(fileName, -1);\n\t\t\t}\n\t\t}\n\n\t\tm_filesToSave.clear();\n\t\tm_waitTimeout = MAX_TIMEOUT;\n\t}\n}\n\nvoid CClipEditThread::OnEvent(int eventId, void* param)\n{\n\tswitch (eventId)\n\t{\n\t\tcase EVENT_FILE_CHANGED:\n\t\t{\n\t\t\tOnFileChanged();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid CClipEditThread::OnFileChanged()\n{\n\tFILE_NOTIFY_INFORMATION* pNotify = m_fileChangeBuffer;\n\tint loopCount = 0;\n\tbool fileModified = false;\n\tCString editClipFileName = _T(\"EditClip_\");\n\tCString newClipFileName = _T(\"NewClip_\");\n\n\twhile (true)\n\t{\n\t\tCString fileName(pNotify->FileName, pNotify->FileNameLength / sizeof(WCHAR));\n\t\t\t\t\n\t\t//we can't filter by the action, modify as ms word doesn't modify the file they replace it\n\t\t///so just look for anything that matches our file names\n\n\t\tif (pNotify->Action != FILE_ACTION_ADDED && pNotify->Action != FILE_ACTION_REMOVED)\n\t\t{\n\t\t\tbool addToChanges = true;\t\t\t\n\n\t\t\t{\n\t\t\t\tATL::CCritSecLock csLock(m_fileEditsLock.m_sect);\n\t\t\t\tauto exists = m_fileEditStarts.find(fileName);\n\t\t\t\tif (exists != m_fileEditStarts.end())\n\t\t\t\t{\n\t\t\t\t\tauto startEdit = m_fileEditStarts[fileName];\n\t\t\t\t\tauto diff = CTime::GetCurrentTime() - startEdit;\n\t\t\t\t\tif (diff.GetTotalSeconds() < 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLog(StrF(_T(\"%s has changed close to when we started editing the file, diff: %d, not handling change\"), fileName, diff.GetTotalSeconds()));\n\t\t\t\t\t\taddToChanges = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse //not in our list of files we initiated the change with\n\t\t\t\t{\n\t\t\t\t\tif (fileName.Find(newClipFileName, 0) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tLog(StrF(_T(\"New clip file changed: %s, this was not in Ditto list of files we initiated the change for, not handling change\"), fileName));\t\t\t\t\t\t\n\t\t\t\t\t\taddToChanges = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fileName.Find(editClipFileName, 0) == -1 && fileName.Find(newClipFileName, 0) == -1)\n\t\t\t{\n\t\t\t\taddToChanges = false;\n\t\t\t\tLog(StrF(_T(\"File %s is not a Ditto file of format EditClip or NewClip, not handling change\"), fileName));\n\t\t\t}\n\n\t\t\tif (addToChanges)\n\t\t\t{\t\t\t\t\n\t\t\t\tLog(StrF(_T(\"%s file changed, adding to list to be saved back to Ditto\"), fileName));\n\t\t\t\tm_filesToSave[fileName] = true;\n\t\t\t\tfileModified = true;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tif (pNotify->NextEntryOffset <= 0 || loopCount > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tpNotify = (FILE_NOTIFY_INFORMATION*)((BYTE*)pNotify + pNotify->NextEntryOffset);\n\n\t\tif (pNotify == nullptr)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tloopCount++;\n\t}\n\n\tRefreshWatch();\n\n\tif (fileModified)\n\t{\n\t\tm_waitTimeout = 2000;\n\t}\n}\n\nbool CClipEditThread::SaveToClip(CString filePath, int id)\n{\n\tbool savedClip = false;\n\n\tLog(StrF(_T(\"ClipFile: %s, ClipId: %d, has changed saving back to Ditto\"), filePath, id));\n\n\tif (id < 0)\n\t{\n\t\tauto exists = m_newClipIds.find(filePath);\n\t\tif (exists != m_newClipIds.end())\n\t\t{\n\t\t\tid = m_newClipIds[filePath];\n\t\t}\n\t}\n\n\tCClip clip;\n\tif (id >= 0)\n\t{\n\t\tif (clip.LoadMainTable(id) == FALSE)\n\t\t{\n\t\t\tLog(StrF(_T(\"Error loading clip id: %d, not saving\"), id));\n\t\t\treturn false;\n\t\t}\n\n\t\tclip.LoadFormats(id);\n\t}\t\t\t\n\n\tCString unicodeText;\n\tCStringA utf8Text;\n\tbool unicode = false;\n\t\n\tCString editClipFolder = CGetSetOptions::GetPath(PATH_EDIT_CLIPS);\n\tCString fullFilePath = editClipFolder + filePath;\n\t\t\t\n\tif (ReadFile(fullFilePath, unicode, unicodeText, utf8Text) == false)\n\t{\n\t\tLog(StrF(_T(\"Error reading file %s, clip id: %d, not saving\"), fullFilePath, id));\n\t\treturn false;\n\t}\n\n\tif (id < 0 &&\n\t\tunicodeText == _T(\"\") &&\n\t\tutf8Text == \"\")\n\t{\n\t\tLog(StrF(_T(\"Not saving new clip that is empty, path: %s, clip id: %d, not saving\"), fullFilePath, id));\n\t\treturn false;\n\t}\t\n\n\tnsPath::CPath path(filePath);\n\n\tBOOL modifyDescription = CGetSetOptions::GetUpdateDescWhenSavingClip();\n\n\tauto extenstion = path.GetExtension().MakeLower();\n\tif (extenstion == _T(\"txt\"))\n\t{\n\t\tif (unicode)\n\t\t{\n\t\t\tclip.SaveFormats(&unicodeText, nullptr, nullptr, modifyDescription);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunicodeText = CTextConvert::Utf8ToUnicode(utf8Text);\n\t\t\tclip.SaveFormats(&unicodeText, nullptr, nullptr, modifyDescription);\n\t\t}\n\t}\n\telse if (extenstion == _T(\"rtf\"))\n\t{\n\t\tif (GetTextFromRTF(utf8Text, unicodeText))\n\t\t{\n\t\t\tclip.SaveFormats(&unicodeText, nullptr, &utf8Text, modifyDescription);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclip.SaveFormats(nullptr, nullptr, &utf8Text, modifyDescription);\n\t\t}\n\t}\n\n\t//refresh the clip in the UI\n\tif (id == -1)\n\t{\n\t\tm_newClipIds[filePath] = clip.m_id;\n\t\ttheApp.RefreshView(CopyReasonEnum::COPY_TO_UNKOWN);\n\t}\n\telse if (id > 0)\n\t{\n\t\ttheApp.RefreshClipInUI(id, UPDATE_CLIP_DESCRIPTION);\n\t}\t\t\t\n\n\tsavedClip = true;\t\n\n\treturn savedClip;\n}\n\nbool CClipEditThread::ReadFile(CString filePath, bool &unicode, CString &unicodeText, CStringA &utf8Text)\n{\n\tCFile file;\n\tCFileException ex;\n\tif (!file.Open(filePath, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone, &ex))\n\t{\n\t\tCString error;\n\t\tex.GetErrorMessage(error.GetBufferSetLength(200), 200);\n\t\terror.ReleaseBuffer();\n\t\tlog(StrF(_T(\"LoadFormatsFromFile - Error opening file: %s, Error: %s\\r\\n\"), filePath, error));\n\t\treturn false;\n\t}\n\n\tif (file.GetLength() >= 2)\n\t{\n\t\twchar_t header;\n\t\tfile.Read(&header, sizeof(wchar_t));\n\t\tif (header == 0xFEFF)\n\t\t{\n\t\t\tunicode = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfile.SeekToBegin();\n\t\t}\n\t}\n\n\tif (unicode)\n\t{\n\t\tconst UINT bufferSize = (UINT)((file.GetLength() - 2) / 2);\n\t\tfile.Read(unicodeText.GetBufferSetLength(bufferSize), bufferSize * 2);\n\t\tunicodeText.ReleaseBuffer();\n\t}\n\telse\n\t{\n\t\tconst UINT bufferSize = (UINT)(file.GetLength());\n\t\tfile.Read(utf8Text.GetBufferSetLength(bufferSize), bufferSize);\n\t\tutf8Text.ReleaseBuffer();\n\t}\n\n\treturn true;\n}\n\nBOOL CClipEditThread::GetTextFromRTF(CStringA rtf, CString &unicodeText)\n{\n\tCConvertRTFToText cc;\n\tif (cc.Create())\n\t{\n\t\tunicodeText = cc.GetTextFromRTF(rtf);\n\t\tcc.DestroyWindow();\n\n\t\tif (rtf != \"\" && unicodeText == \"\")\n\t\t{\n\t\t\tlog(StrF(_T(\"Failed to convert rtf to text, rtf text is not empty but text is empty\")));\n\t\t}\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tlog(StrF(_T(\"Failed to create rtf to text window\")));\n\t}\t\n\n\treturn false;\n}"
        },
        {
          "name": "ClipEditThread.h",
          "type": "blob",
          "size": 0.8369140625,
          "content": "#pragma once\n#include \"EventThread.h\"\n#include \"Path.h\"\n\nclass CClipEditThread : public CEventThread\n{\npublic:\n\tCClipEditThread();\n\tvirtual ~CClipEditThread();\n\t\t\n\tvoid Close();\n\tvoid StartWatchingFolderForChanges();\n\n\tvoid WatchFile(CString filePath);\n\nprivate:\n\tvoid OnEvent(int eventId, void* param) override;\n\tvoid OnFileChanged();\n\tvoid OnTimeOut(void* param) override;\n\tbool ReadFile(CString filePath, bool& unicode, CString& unicodeText, CStringA& utf8Text);\n\tBOOL GetTextFromRTF(CStringA rtf, CString& unicodeText);\n\tvoid RefreshWatch();\n\tbool SaveToClip(CString filePath, int id);\n\t\t\n\tHANDLE m_folderHandle;\n\tFILE_NOTIFY_INFORMATION m_fileChangeBuffer[10000];\n\tOVERLAPPED m_overlapped;\n\tstd::map<CString, bool> m_filesToSave;\n\tstd::map<CString, int> m_newClipIds;\n\n\tCCriticalSection m_fileEditsLock;\n\tstd::map<CString, CTime> m_fileEditStarts;\n};\n\n"
        },
        {
          "name": "ClipFormatQListCtrl.cpp",
          "type": "blob",
          "size": 0.990234375,
          "content": "#include \"stdafx.h\"\n#include \"ClipFormatQListCtrl.h\"\n#include \"BitmapHelper.h\"\n#include \"CP_Main.h\"\n\nCClipFormatQListCtrl::CClipFormatQListCtrl(void)\n{\n\tm_counter = 0;\n\tm_clipRow = -1;\n\tm_convertedToSmallImage = false;\n}\n\nCClipFormatQListCtrl::~CClipFormatQListCtrl(void)\n{\n}\n\n\nHGLOBAL CClipFormatQListCtrl::GetDibFittingToHeight(CDC *pDc, int height)\n{\n\tif(m_cfType != CF_DIB &&\n\t\tm_cfType != theApp.m_PNG_Format)\n\t{\n\t\treturn NULL;\n\t}\n\n\tif(m_convertedToSmallImage)\n\t{\n\t\treturn m_hgData;\n\t}\n\n\tm_convertedToSmallImage = true;\n\n\tCBitmap Bitmap;\n\tif( !CBitmapHelper::GetCBitmap(this, pDc, &Bitmap, height) )\n\t{\n\t\tBitmap.DeleteObject();\n\t\t// the data is useless, so free it.\n\t\tthis->Free(); \n\t\treturn FALSE;\n\t}\n\n\tthis->m_autoDeleteData = true;\n\n\t// delete the large image data loaded from the db\n\tthis->Free();\n\n\tthis->m_autoDeleteData = false;\n\n\t//Convert the smaller bitmap back to a dib\n\tHPALETTE hPal = NULL;\n\tthis->m_hgData = CBitmapHelper::hBitmapToDIB((HBITMAP)Bitmap, BI_RGB, hPal);\n\n\treturn this->m_hgData;\n}\n"
        },
        {
          "name": "ClipFormatQListCtrl.h",
          "type": "blob",
          "size": 0.2685546875,
          "content": "#pragma once\n\n#include \"Clip.h\"\n\nclass CClipFormatQListCtrl : public CClipFormat\n{\npublic:\n\tCClipFormatQListCtrl(void);\n\t~CClipFormatQListCtrl(void);\n\n\tint m_clipRow;\n\tbool m_convertedToSmallImage;\n\tINT64 m_counter;\n\n\tHGLOBAL GetDibFittingToHeight(CDC *pDc, int height);\n};\n\n"
        },
        {
          "name": "ClipIds.cpp",
          "type": "blob",
          "size": 10.400390625,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"ClipIds.h\"\r\n#include \"tinyxml\\tinyxml.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"Clip_ImportExport.h\"\r\n#include \"CF_HDropAggregator.h\"\r\n#include \"CF_UnicodeTextAggregator.h\"\r\n#include \"CF_TextAggregator.h\"\r\n#include \"richtextaggregator.h\"\r\n#include \"htmlformataggregator.h\"\r\n#include \"Popup.h\"\r\n\r\n// allocate an HGLOBAL of the given Format Type representing these Clip IDs.\r\nHGLOBAL CClipIDs::Render(UINT cfType)\r\n{\r\n\tINT_PTR count = GetSize();\r\n\tif(count <= 0)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif(count == 1)\r\n\t{\r\n\t\treturn CClip::LoadFormat(ElementAt(0), cfType);\r\n\t}\r\n\r\n\tCStringA SepA = CTextConvert::UnicodeToAnsi(CGetSetOptions::GetMultiPasteSeparator());\r\n\tCStringW SepW = CGetSetOptions::GetMultiPasteSeparator();\r\n\r\n\tif(cfType == CF_TEXT)\r\n\t{\r\n\t\tCCF_TextAggregator CFText(SepA);\r\n\t\tif(AggregateData(CFText, CF_TEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\treturn CFText.GetHGlobal();\r\n\t\t}\r\n\t}\r\n\telse if(cfType == CF_UNICODETEXT)\r\n\t{\r\n\t\tCCF_UnicodeTextAggregator CFUnicodeText(SepW);\r\n\t\tif(AggregateData(CFUnicodeText, CF_UNICODETEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\treturn CFUnicodeText.GetHGlobal();\r\n\t\t}\r\n\t}\r\n\telse if(cfType == CF_HDROP)\r\n\t{\r\n\t\tCCF_HDropAggregator HDrop;\r\n\t\tif(AggregateData(HDrop, CF_HDROP, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\treturn HDrop.GetHGlobal();\r\n\t\t}\r\n\t}\r\n\telse if(cfType == theApp.m_HTML_Format)\r\n\t{\r\n\t\tCHTMLFormatAggregator Html(SepA);\r\n\t\tif(AggregateData(Html, theApp.m_HTML_Format, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\treturn Html.GetHGlobal();\r\n\t\t}\r\n\t}\r\n\telse if(cfType == theApp.m_RTFFormat)\r\n\t{\r\n\t\tCRichTextAggregator RichText(SepA);\r\n\t\tif(AggregateData(RichText, theApp.m_RTFFormat, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\treturn RichText.GetHGlobal();\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn NULL;\r\n}\r\n\r\nvoid CClipIDs::GetTypes(CClipTypes& types)\r\n{\r\n\tINT_PTR count = GetSize();\r\n\ttypes.RemoveAll();\r\n\r\n\tif(count == 1)\r\n\t{\r\n\t\tCClip::LoadTypes(ElementAt(0), types);\r\n\t}\r\n\telse if(count > 1)\r\n\t{\r\n\t\t//Add the types that are common across all paste ids\r\n\t\tlong lCount;\r\n\t\tCMap<CLIPFORMAT, CLIPFORMAT, long, long> RenderTypes;\r\n\r\n\t\tfor(int nIDPos = 0; nIDPos < count; nIDPos++)\r\n\t\t{\r\n\t\t\tCClipTypes CurrTypes;\r\n\t\t\tCClip::LoadTypes(ElementAt(nIDPos), CurrTypes);\r\n\r\n\t\t\tINT_PTR typeCount = CurrTypes.GetSize();\r\n\r\n\t\t\tfor(int type = 0; type < typeCount; type++)\r\n\t\t\t{\t\r\n\t\t\t\tlCount = 0;\r\n\t\t\t\tif(nIDPos == 0 || RenderTypes.Lookup(CurrTypes[type], lCount) == TRUE)\r\n\t\t\t\t{\r\n\t\t\t\t\tlCount++;\r\n\t\t\t\t\tRenderTypes.SetAt(CurrTypes[type], lCount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tCLIPFORMAT Format;\r\n\t\tPOSITION pos = RenderTypes.GetStartPosition();\r\n\t\twhile(pos)\r\n\t\t{\r\n\t\t\tRenderTypes.GetNextAssoc(pos, Format, lCount);\r\n\t\t\tif(lCount == count)\r\n\t\t\t{\r\n\t\t\t\ttypes.Add(Format);\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\r\n\t\t//If there were no common types add the first clip\r\n\t\tif(types.GetSize() <= 0)\r\n\t\t{\r\n\t\t\tCClip::LoadTypes(ElementAt(0), types);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool CClipIDs::AggregateData(IClipAggregator &Aggregator, UINT cfType, BOOL bReverse, bool textOnly)\r\n{\r\n\tCString csSQL;\r\n\tLPWSTR Text = NULL;\r\n\tint nTextSize = 0;\r\n\tINT_PTR numIDs = GetSize();\r\n\tbool bRet = false;\r\n\r\n\ttry\r\n\t{\r\n\t\tINT_PTR nIndex;\r\n\t\tfor(int i=0; i < numIDs; i++)\r\n\t\t{\r\n\t\t\tnIndex = i;\r\n\t\t\tif(bReverse)\r\n\t\t\t{\r\n\t\t\t\tnIndex = numIDs - i - 1;\r\n\t\t\t}\r\n\r\n\t\t\tCString sqlCF_HDROP = _T(\"\");\r\n\t\t\tif (textOnly &&\r\n\t\t\t\tcfType == CF_UNICODETEXT || cfType == CF_TEXT)\r\n\t\t\t{\r\n\t\t\t\tsqlCF_HDROP.Format(_T(\"OR Data.strClipBoardFormat = '%s'\"), GetFormatName(CF_HDROP));\r\n\t\t\t}\r\n\r\n\t\t\tcsSQL.Format(_T(\"SELECT * FROM Data \")\r\n\t\t\t\t_T(\"INNER JOIN Main ON Main.lID = Data.lParentID \")\r\n\t\t\t\t_T(\"WHERE (Data.strClipBoardFormat = '%s'\")\r\n\t\t\t\t_T(\" %s) \")\r\n\t\t\t\t_T(\"AND Main.lID = %d\"),\r\n\t\t\t\tGetFormatName(cfType),\r\n\t\t\t\tsqlCF_HDROP,\r\n\t\t\t\tElementAt(nIndex));\r\n\r\n\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(csSQL);\r\n\r\n\t\t\tif(q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tint nDataLen = 0;\r\n\t\t\t\tLPVOID pData = (LPVOID)q.getBlobField(_T(\"ooData\"), nDataLen);\r\n\t\t\t\tif(pData == NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(Aggregator.AddClip(pData, nDataLen, (int)i, (int)numIDs, GetFormatID(q.getStringField(_T(\"strClipBoardFormat\")))))\r\n\t\t\t\t{\r\n\t\t\t\t\tbRet |= true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbRet |= false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\tcatch(...)\r\n\t{\r\n\r\n\t}\r\n\r\n\treturn bRet;\r\n}\r\n\r\n// Blindly Moves IDs into the lParentID Group sequentially with the given order\r\nBOOL CClipIDs::MoveTo(long lParentID, double dFirst, double dIncrement)\r\n{\r\n\ttry\r\n\t{\r\n\t\tint count = (int)GetSize();\r\n\r\n\t\tLog(StrF(_T(\"MoveTo, Start, Size: %d, ParentId: %d\"), count, lParentID));\r\n\r\n\t\tfor(int i = count-1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tCString sql;\r\n\r\n\t\t\tif(lParentID > 0)\r\n\t\t\t{\r\n\t\t\t\tsql = StrF(_T(\"UPDATE Main SET lParentID = %d, clipGroupOrder = %f WHERE lID = %d AND lID <> %d;\"), \r\n\t\t\t\t\t\t\tlParentID,\r\n\t\t\t\t\t\t\tCClip::GetNewOrder(lParentID, ElementAt(i)),\r\n\t\t\t\t\t\t\tElementAt(i),\r\n\t\t\t\t\t\t\tlParentID);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tsql = StrF(_T(\"UPDATE Main SET lParentID = %d WHERE lID = %d AND lID <> %d;\"), \r\n\t\t\t\t\t\t\tlParentID,\r\n\t\t\t\t\t\t\tElementAt(i),\r\n\t\t\t\t\t\t\tlParentID);\r\n\t\t\t}\r\n\r\n\t\t\tint ret = theApp.m_db.execDMLEx(sql);\r\n\r\n\t\t\tLog(StrF(_T(\"MoveTo, Sql Ret: %d, SQL: %s\"), ret, sql));\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\t\r\n\treturn (TRUE);\r\n}\r\n\r\n// Empties this array and fills it with the elements of the given group ID\r\nBOOL CClipIDs::LoadElementsOf(int groupId)\r\n{\r\n\tSetSize(0);\r\n\t\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE lParentID = %d\"), groupId);\r\n\t\twhile(q.eof() == false)\r\n\t\t{\r\n\t\t\tAdd(q.getIntField(_T(\"lID\")));\r\n\t\t\tq.nextRow();\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\t\r\n\treturn GetSize() > 0;\r\n}\r\n\r\n// Creates copies (duplicates) of all items in this array and assigns the\r\n// lParentID of the copies to the given \"lParentID\" group.\r\n// - if lParentID <= 0, then the copies have the same parent as the source\r\n// - pCopies is filled with the corresponding duplicate IDs.\r\n// - pAddNewTable and pSeekTable are used for more efficient recursion.\r\n// - the primary overhead for recursion is one ID array per level deep.\r\n//   an alternative design would be to have one CMainTable per level deep,\r\n//   but I thought that might be too costly, so I implemented it this way.\r\n\r\nBOOL CClipIDs::CopyTo(int parentId)\r\n{\r\n\tINT_PTR count = GetSize();\r\n\tif(count == 0)\r\n\t\treturn TRUE;\r\n\t\t\r\n\ttry\r\n\t{\r\n\t\ttheApp.m_db.execDML(_T(\"begin transaction;\"));\r\n\r\n\t\tfor(int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tint nID = ElementAt(i);\r\n\r\n\t\t\tCClip clip;\r\n\r\n\t\t\tif(clip.LoadMainTable(nID))\r\n\t\t\t{\r\n\t\t\t\tif(clip.LoadFormats(nID))\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.MakeLatestOrder();\r\n\r\n\t\t\t\t\tclip.m_shortCut = 0;\r\n\t\t\t\t\tclip.m_parentId = parentId;\r\n\t\t\t\t\tclip.m_csQuickPaste = \"\";\r\n\r\n\t\t\t\t\tif(clip.AddToDB(false) == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLog(_T(\"failed to add copy to database\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttheApp.m_db.execDML(_T(\"commit transaction;\"));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\t\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CClipIDs::DeleteIDs(bool fromClipWindow, CppSQLite3DB& db)\r\n{\r\n\tCPopup status(0, 0, ::GetForegroundWindow());\r\n\tbool bAllowShow;\r\n\tbAllowShow = IsAppWnd(::GetForegroundWindow());\r\n\t\r\n\tBOOL bRet = TRUE;\r\n\tINT_PTR count = GetSize();\r\n\tint batchCount = 25;\r\n\r\n\tLog(StrF(_T(\"Begin delete clips, Count: %d from Window: %d\"), count, fromClipWindow));\r\n\t\r\n\tif(count <= 0)\r\n\t\treturn FALSE;\r\n\r\n\ttry\r\n\t{\r\n\t\tCString sql = _T(\"DELETE FROM Main where lId in(\");\r\n\t\tCString sqlIn = _T(\"\");\r\n\t\tCString workingString = _T(\"Deleting clips, building query statement\");\r\n\t\tINT_PTR startIndex = 0;\r\n\t\tINT_PTR index = 0;\r\n\r\n\t\tif(bAllowShow)\r\n\t\t{\r\n\t\t\tstatus.Show(workingString);\r\n\t\t}\r\n\r\n\t\tfor(index = 0; index < count; index++)\r\n\t\t{\r\n\t\t\tint clipId = ElementAt(index);\r\n\t\t\tif(clipId <= 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tLog(StrF(_T(\"Delete clip Id: %d\"), clipId));\r\n\r\n\t\t\tbool cont = false;\r\n\t\t\tbool bGroup = false;\r\n\t\t\t{\r\n\t\t\t\tCppSQLite3Query q = db.execQueryEx(_T(\"SELECT bIsGroup FROM Main WHERE lId = %d\"), clipId);\r\n\t\t\t\tcont = !q.eof();\r\n\t\t\t\tif(cont)\r\n\t\t\t\t{\r\n\t\t\t\t\tbGroup = q.getIntField(_T(\"bIsGroup\")) > 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(cont)\r\n\t\t\t{\t\t\t\r\n\t\t\t\tif(bGroup)\r\n\t\t\t\t{\r\n\t\t\t\t\tdb.execDMLEx(_T(\"UPDATE Main SET lParentID = -1 WHERE lParentID = %d;\"), clipId);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(sqlIn.GetLength() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tsqlIn += \", \";\r\n\t\t\t\t}\r\n\t\t\t\tsqlIn += StrF(_T(\"%d\"), clipId);\r\n\t\t\t}\r\n\r\n\t\t\tif(index > 0 && \r\n\t\t\t\t(index % batchCount) == 0)\r\n\t\t\t{\r\n\t\t\t\tif(bAllowShow)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.Show(StrF(_T(\"Deleting %d - %d of %d...\"), startIndex+1, index, count));\r\n\t\t\t\t}\r\n\t\t\t\tstartIndex = index;\r\n\r\n\t\t\t\tdb.execDMLEx(sql + sqlIn + _T(\")\"));\r\n\t\t\t\tsqlIn = \"\";\r\n\t\t\t\tbRet = TRUE;\r\n\r\n\t\t\t\tif(bAllowShow)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.Show(workingString);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif(fromClipWindow == false)\r\n\t\t\t{\r\n\t\t\t\ttheApp.OnDeleteID(clipId);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(sqlIn.GetLength() > 0)\r\n\t\t{\r\n\t\t\tif(bAllowShow)\r\n\t\t\t{\r\n\t\t\t\tstatus.Show(StrF(_T(\"Deleting %d - %d of %d...\"), startIndex+1, index, count));\r\n\t\t\t}\r\n\r\n\t\t\tdb.execDMLEx(sql + sqlIn + _T(\")\"));\r\n\t\t\tbRet = TRUE;\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(FALSE)\r\n\t\r\n\tLog(StrF(_T(\"End delete clips, Count: %d\"), count));\r\n\r\n\treturn bRet;\r\n}\r\n\r\nBOOL CClipIDs::CreateExportSqliteDB(CppSQLite3DB &db)\r\n{\r\n\tBOOL bRet = FALSE;\r\n\ttry\r\n\t{\r\n\t\tdb.execDML(_T(\"CREATE TABLE Main(\")\r\n\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t_T(\"lVersion INTEGER, \")\r\n\t\t\t_T(\"mText TEXT);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE Data(\")\r\n\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t_T(\"lParentID INTEGER, \")\r\n\t\t\t_T(\"strClipBoardFormat TEXT, \")\r\n\t\t\t_T(\"lOriginalSize INTEGER, \")\r\n\t\t\t_T(\"ooData BLOB);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE UNIQUE INDEX Main_ID on Main(lID ASC)\"));\r\n\t\tdb.execDML(_T(\"CREATE UNIQUE INDEX Data_ID on Data(lID ASC)\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TRIGGER delete_data_trigger BEFORE DELETE ON Main FOR EACH ROW\\n\")\r\n\t\t\t_T(\"BEGIN\\n\")\r\n\t\t\t_T(\"DELETE FROM Data WHERE lParentID = old.lID;\\n\")\r\n\t\t\t_T(\"END\\n\"));\r\n\r\n\t\tbRet = TRUE;\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(FALSE)\r\n\r\n\treturn bRet;\r\n}\r\n\r\nBOOL CClipIDs::Export(CString csFilePath)\r\n{    \r\n\tINT_PTR count = GetSize();\r\n\tif(count == 0)\r\n\t\treturn TRUE;\r\n\r\n\tBOOL bRet = FALSE;\r\n\r\n\tif(FileExists(csFilePath) && DeleteFile(csFilePath) == FALSE)\r\n\t{\r\n\t\tLog(StrF(_T(\"Export::Error deleting the file %s\"), csFilePath));\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\ttry\r\n\t{\t\t\r\n\t\tCppSQLite3DB db;\r\n\t\tdb.open(csFilePath);\r\n\r\n\t\tif(CreateExportSqliteDB(db) == FALSE)\r\n\t\t\treturn FALSE;\r\n\t\r\n\t\tfor(int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tint nID = ElementAt(i);\r\n\r\n\t\t\tCClip_ImportExport clip;\r\n\t\t\t\r\n\t\t\tif(clip.LoadMainTable(nID))\r\n\t\t\t{\r\n\t\t\t\tif(clip.LoadFormats(nID))\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.ExportToSqliteDB(db);\r\n\t\t\t\t\tbRet = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdb.close();\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\treturn bRet;\r\n}"
        },
        {
          "name": "ClipIds.h",
          "type": "blob",
          "size": 1.251953125,
          "content": "#pragma once\n\n#include \"IClipAggregator.h\"\n#include \"sqlite\\CppSQLite3.h\"\n\nclass CClipIDs : public CArrayEx<int>\n{\npublic:\n// PASTING FUNCTIONS\n\n\t// allocate an HGLOBAL of the given Format Type representing the Clip IDs in this array.\n\tHGLOBAL\tRender(UINT cfType);\n\t// Fills \"types\" with the Format Types corresponding to the Clip IDs in this array.\n\tvoid GetTypes(CClipTypes& types);\n\tbool AggregateData(IClipAggregator &Aggregator, UINT cfType, BOOL bReverse, bool textOnly);\n\n// MANAGEMENT FUNCTIONS\n\n\t// Blindly Moves IDs into the lParentID Group sequentially with the given order\n\t// (i.e. this does not check to see if the IDs' order conflict)\n\t// if( dIncrement < 0 ), this does not change the order\n\tBOOL MoveTo(long lParentID, double dFirst = 0, double dIncrement = -1);\n\n\t// reorders the \"lParentID\" Group, inserting before the given id.\n\t//  if the id cannot be found, this appends the IDs.\n//\tBOOL ReorderGroupInsert( long lParentID, long lInsertBeforeID = 0 );\n\n\t// Empties this array and fills it with the elements of the given group ID\n\tBOOL LoadElementsOf(int groupId);\n\n\tBOOL CopyTo(int parentId);\n\n\tBOOL DeleteIDs(bool fromClipWindow, CppSQLite3DB& db);\n\n\tBOOL Export(CString csFilePath);\n\t\nprotected:\n\tBOOL CreateExportSqliteDB(CppSQLite3DB &db);\n\nprotected:\n\t\n};"
        },
        {
          "name": "Clip_ImportExport.cpp",
          "type": "blob",
          "size": 6.9833984375,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \".\\clip_importexport.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"sqlite/CppSQLite3.h\"\r\n#include \"zlib/zlib.h\"\r\n#include \"Misc.h\"\r\n\r\n#define CURRENT_EXPORT_VERSION 1\r\n\r\nCClip_ImportExport::CClip_ImportExport(void) :\r\n\tm_importCount(0)\r\n{\r\n\r\n}\r\n\r\nCClip_ImportExport::~CClip_ImportExport(void)\r\n{\r\n}\r\n\r\nbool CClip_ImportExport::ExportToSqliteDB(CppSQLite3DB &db)\r\n{\r\n\tbool bRet = false;\r\n\ttry\r\n\t{\r\n\t\t//Add to Main Table\r\n\t\tm_Desc.Replace(_T(\"'\"), _T(\"''\"));\r\n\t\tdb.execDMLEx(_T(\"insert into Main values(NULL, %d, '%s');\"), CURRENT_EXPORT_VERSION, m_Desc);\r\n\t\tlong lId = (long)db.lastRowId();\r\n\r\n\t\t//Add to Data table\r\n\t\tCClipFormat* pCF;\r\n\t\tCppSQLite3Statement stmt = db.compileStatement(_T(\"insert into Data values (NULL, ?, ?, ?, ?);\"));\r\n\r\n\t\tfor(INT_PTR i = m_Formats.GetSize()-1; i >= 0 ; i--)\r\n\t\t{\r\n\t\t\tpCF = & m_Formats.ElementAt(i);\r\n\r\n\t\t\tstmt.bind(1, lId);\r\n\t\t\tstmt.bind(2, GetFormatName(pCF->m_cfType));\r\n\t\t\tINT_PTR originalSize = GlobalSize(pCF->m_hgData);\r\n\t\t\tstmt.bind(3, (int)originalSize);\r\n\r\n\t\t\tconst unsigned char *Data = (const unsigned char *)GlobalLock(pCF->m_hgData);\r\n\t\t\tif(Data)\r\n\t\t\t{\r\n\t\t\t\t//First compress the data\r\n\t\t\t\tINT_PTR zippedSize = compressBound((ULONG)originalSize);\r\n\t\t\t\tBytef *pZipped = new Bytef[zippedSize];\r\n\t\t\t\tif(pZipped)\r\n\t\t\t\t{\t\t\t\t\r\n\t\t\t\t\tINT_PTR zipReturn = compress(pZipped, (uLongf *)&zippedSize, (const Bytef *)Data, (ULONG)originalSize);\r\n\t\t\t\t\tif(zipReturn == Z_OK)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstmt.bind(4, pZipped, (int)zippedSize);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete []pZipped;\r\n\t\t\t\t\tpZipped = NULL;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tGlobalUnlock(pCF->m_hgData);\r\n\r\n\t\t\tstmt.execDML();\r\n\t\t\tstmt.reset();\r\n\r\n\t\t\tm_Formats.RemoveAt(i);\r\n\t\t}\r\n\r\n\t\tbRet = true;\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\r\n\r\n\treturn bRet;\r\n}\r\n\r\nbool CClip_ImportExport::ImportFromSqliteDB(CppSQLite3DB &db, bool bAddToDB, bool bPutOnClipboard)\r\n{\r\n\tbool bRet = false;\r\n\tCStringA csCF_TEXT;\r\n\tCStringW csCF_UNICODETEXT;\r\n\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = db.execQuery(_T(\"Select * from Main order by lId DESC\"));\r\n\t\twhile(q.eof() == false)\r\n\t\t{\r\n\t\t\tClear();\r\n\r\n\t\t\tint nVersion = q.getIntField(_T(\"lVersion\"));\r\n\t\t\tif(nVersion == 1)\r\n\t\t\t{\r\n\t\t\t\tif(ImportFromSqliteV1(db, q))\r\n\t\t\t\t{\r\n\t\t\t\t\tif(bAddToDB)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMakeLatestOrder();\r\n\t\t\t\t\t\tAddToDB(true);\r\n\t\t\t\t\t\tbRet = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(bPutOnClipboard)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbRet = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tm_importCount++;\r\n\r\n\t\t\t//If putting on the clipboard and there are multiple\r\n\t\t\t//then append cf_text and cf_unicodetext\r\n\t\t\tif(bPutOnClipboard)\r\n\t\t\t{\r\n\t\t\t\tAppend_CF_TEXT_AND_CF_UNICODETEXT(csCF_TEXT, csCF_UNICODETEXT);\r\n\t\t\t}\r\n\r\n\t\t\tq.nextRow();\r\n\t\t}\r\n\r\n\t\tif(bRet && bAddToDB)\r\n\t\t{\r\n\t\t\ttheApp.RefreshView();\r\n\t\t}\r\n\t\telse if(bRet && m_importCount == 1 && bPutOnClipboard)\r\n\t\t{\r\n\t\t\tPlaceFormatsOnclipboard();\r\n\t\t}\r\n\t\telse if(bRet && bPutOnClipboard)\r\n\t\t{\r\n\t\t\tPlaceCF_TEXT_AND_CF_UNICODETEXT_OnClipboard(csCF_TEXT, csCF_UNICODETEXT);\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\r\n\r\n\treturn bRet;\r\n}\r\n\r\nbool CClip_ImportExport::PlaceCF_TEXT_AND_CF_UNICODETEXT_OnClipboard(CStringA &csCF_TEXT, CStringW &csCF_UNICODETEXT)\r\n{\r\n\tbool bRet = false;\r\n\r\n\tif(OpenClipboard(theApp.m_MainhWnd))\r\n\t{\r\n\t\tEmptyClipboard();\r\n\r\n\t\tif(csCF_TEXT.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tlong lLen = csCF_TEXT.GetLength();\r\n\t\t\tHGLOBAL hGlobal = NewGlobalP(csCF_TEXT.GetBuffer(lLen), lLen+1);\r\n\t\t\tcsCF_TEXT.ReleaseBuffer();\r\n\t\t\tSetClipboardData(CF_TEXT, hGlobal);\r\n\r\n\t\t\tbRet = true;\r\n\t\t}\r\n\t\tif(csCF_UNICODETEXT.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tlong lLen = csCF_UNICODETEXT.GetLength() * sizeof(wchar_t);\r\n\t\t\tHGLOBAL hGlobal = NewGlobalP(csCF_UNICODETEXT.GetBuffer(lLen), lLen+1);\r\n\t\t\tcsCF_UNICODETEXT.ReleaseBuffer();\r\n\t\t\tSetClipboardData(CF_UNICODETEXT, hGlobal);\r\n\r\n\t\t\tbRet = true;\r\n\t\t}\r\n\r\n\t\tCloseClipboard();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(_T(\"Error opening clipboard\"));\r\n\t}\r\n\r\n\treturn bRet;\r\n}\r\n\r\nbool CClip_ImportExport::PlaceFormatsOnclipboard()\r\n{\r\n\tbool bRet = false;\r\n\r\n\tif(OpenClipboard(theApp.m_MainhWnd))\r\n\t{\r\n\t\tEmptyClipboard();\r\n\r\n\t\tINT_PTR formatCount = m_Formats.GetSize();\r\n\t\tfor(int i = 0; i < formatCount; i++)\r\n\t\t{\r\n\t\t\tCClipFormat *pCF;\r\n\t\t\tpCF = &m_Formats.ElementAt(i);\r\n\t\t\tLPVOID Data = (LPVOID)GlobalLock(pCF->m_hgData);\r\n\t\t\tif(Data)\r\n\t\t\t{\r\n\t\t\t\tHGLOBAL hGlobal = NewGlobalP(Data, GlobalSize(pCF->m_hgData));\t\t\t\r\n\t\t\t\tif(hGlobal)\r\n\t\t\t\t{\r\n\t\t\t\t\tSetClipboardData(pCF->m_cfType, hGlobal);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tGlobalUnlock(pCF->m_hgData);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tCloseClipboard();\r\n\r\n\t\tbRet = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(_T(\"PlaceFormatsOnclipboard::Error opening clipboard\"));\r\n\t}\r\n\r\n\treturn bRet;\r\n}\r\n\r\nbool CClip_ImportExport::ImportFromSqliteV1(CppSQLite3DB &db, CppSQLite3Query &qMain)\r\n{\r\n\ttry\r\n\t{\r\n\t\t//Load the Main Table\r\n\t\tm_Desc = qMain.getStringField(_T(\"mText\"));\r\n\t\tlong lID = qMain.getIntField(_T(\"lID\"));\r\n\r\n\t\t//Load the data Table\r\n\t\tCClipFormat cf;\r\n\t\tHGLOBAL hGlobal = 0;\r\n\t\tm_Formats.RemoveAll();\r\n\r\n\t\tCString csSQL;\r\n\t\tcsSQL.Format(\r\n\t\t\t_T(\"SELECT Data.* FROM Data \")\r\n\t\t\t_T(\"INNER JOIN Main ON Main.lID = Data.lParentID \")\r\n\t\t\t_T(\"WHERE Main.lID = %d ORDER BY Data.lID desc\"), lID);\r\n\r\n\t\tCppSQLite3Query qData = db.execQuery(csSQL);\r\n\t\twhile(qData.eof() == false)\r\n\t\t{\r\n\t\t\tcf.m_cfType = GetFormatID(qData.getStringField(_T(\"strClipBoardFormat\")));\r\n\t\t\tlong lOriginalSize = qData.getIntField(_T(\"lOriginalSize\"));\r\n\r\n\t\t\tint nDataLen = 0;\r\n\t\t\tconst unsigned char *cData = qData.getBlobField(_T(\"ooData\"), nDataLen);\r\n\t\t\tif(cData != NULL)\r\n\t\t\t{\r\n\t\t\t\tBytef *pUnZippedData = new Bytef[lOriginalSize];\r\n\t\t\t\tif(pUnZippedData)\r\n\t\t\t\t{\r\n\t\t\t\t\t//the data in the exported file is compressed so uncompress it now\r\n\t\t\t\t\tint nRet = uncompress(pUnZippedData, (uLongf *)&lOriginalSize, (Bytef *)cData, nDataLen);\r\n\t\t\t\t\tif(nRet == Z_OK)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcf.m_hgData = NewGlobalP(pUnZippedData, lOriginalSize);\r\n\t\t\t\t\t\tif(cf.m_hgData)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tm_Formats.Add(cf);\r\n\t\t\t\t\t\t\tcf.m_hgData = NULL; //m_format owns m_hgData now\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tLog(StrF(_T(\"Error allocating NewGlobalP size = %d\"), lOriginalSize));\r\n\t\t\t\t\t\t\tASSERT(FALSE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLog(_T(\"Error uncompressing data from zlib\"));\r\n\t\t\t\t\t\tASSERT(FALSE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete []pUnZippedData;\r\n\t\t\t\t\tpUnZippedData = NULL;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"Error allocating memory to unzip size = %d\"), lOriginalSize));\r\n\t\t\t\t\tASSERT(FALSE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tqData.nextRow();\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(false)\r\n\r\n\treturn m_Formats.GetSize() > 0;\r\n}\r\n\r\nbool CClip_ImportExport::Append_CF_TEXT_AND_CF_UNICODETEXT(CStringA &csCF_TEXT, CStringW &csCF_UNICODETEXT)\r\n{\r\n\tbool bRet = false;\r\n\tCClipFormat *pCF;\r\n\tINT_PTR count = m_Formats.GetSize();\r\n\tfor(int i = 0; i < count; i++)\r\n\t{\r\n\t\tpCF = &m_Formats.ElementAt(i);\r\n\r\n\t\tswitch(pCF->m_cfType)\r\n\t\t{\r\n\t\tcase CF_TEXT:\r\n\t\t\t{\t\r\n\t\t\t\r\n\t\t\t\tif(csCF_TEXT.IsEmpty() == FALSE)\r\n\t\t\t\t\tcsCF_TEXT += \"\\r\\n\";\r\n\r\n\t\t\t\tcsCF_TEXT += pCF->GetAsCStringA();\r\n\t\t\t\tbRet = true;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase CF_UNICODETEXT:\r\n\t\t\t{\t\r\n\t\t\t\tif(csCF_UNICODETEXT.IsEmpty() == FALSE)\r\n\t\t\t\t\tcsCF_UNICODETEXT += _T(\"\\r\\n\");\r\n\r\n\t\t\t\tcsCF_UNICODETEXT += pCF->GetAsCString();;\r\n\t\t\t\tbRet = true;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn bRet;\r\n}"
        },
        {
          "name": "Clip_ImportExport.h",
          "type": "blob",
          "size": 0.578125,
          "content": "#pragma once\n#include \"clip.h\"\n\nclass CClip_ImportExport :\tpublic CClip\n{\npublic:\n\tCClip_ImportExport(void);\n\t~CClip_ImportExport(void);\n\n\tbool ExportToSqliteDB(CppSQLite3DB &m_db);\n\tbool ImportFromSqliteDB(CppSQLite3DB &db, bool bAddToDB, bool bPutOnClipboard);\n\t\n\tint m_importCount;\n\nprotected:\n\tbool ImportFromSqliteV1(CppSQLite3DB &db, CppSQLite3Query &qMain);\n\tbool Append_CF_TEXT_AND_CF_UNICODETEXT(CStringA &csCF_TEXT, CStringW &csCF_UNICODETEXT);\n\n\tbool PlaceFormatsOnclipboard();\n\tbool PlaceCF_TEXT_AND_CF_UNICODETEXT_OnClipboard(CStringA &csCF_TEXT, CStringW &csCF_UNICODETEXT);\n};\n"
        },
        {
          "name": "ClipboardSaveRestore.cpp",
          "type": "blob",
          "size": 3.6845703125,
          "content": "#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \".\\clipboardsaverestore.h\"\n\nCClipboardSaveRestore::CClipboardSaveRestore(void)\n{\n}\n\nCClipboardSaveRestore::~CClipboardSaveRestore(void)\n{\n}\n\nbool CClipboardSaveRestore::Save(BOOL textOnly)\n{\n\tm_Clipboard.RemoveAll();\n\n\tbool bRet = false;\n\tCOleDataObjectEx oleData;\n\tCClipFormat cf;\n\n\tif(::OpenClipboard(theApp.m_MainhWnd))\n\t{\n\t\tint nFormat = EnumClipboardFormats(0);\n\t\twhile(nFormat != 0)\n\t\t{\n\t\t\tif(textOnly == false || (nFormat == CF_TEXT || nFormat == CF_UNICODETEXT || nFormat == CF_HDROP))\n\t\t\t{\n\t\t\t\tHGLOBAL hGlobal = ::GetClipboardData(nFormat);\n\t\t\t\tLPVOID pvData = GlobalLock(hGlobal);\n\t\t\t\tif(pvData)\n\t\t\t\t{\n\t\t\t\t\tINT_PTR size = GlobalSize(hGlobal);\n\t\t\t\t\tif(size > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Copy the data locally\n\t\t\t\t\t\tcf.m_hgData = NewGlobalP(pvData, size);\t\n\t\t\t\t\t\tcf.m_cfType = nFormat;\n\n\t\t\t\t\t\tm_Clipboard.Add(cf);\n\n\t\t\t\t\t\t//m_Clipboard owns the data now\n\t\t\t\t\t\tcf.m_hgData = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tGlobalUnlock(hGlobal);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnFormat = EnumClipboardFormats(nFormat);\n\t\t}\n\n\t\t::CloseClipboard();\n\t\tbRet = true;\n\t}\n\n\treturn bRet;\n}\n\nbool CClipboardSaveRestore::Restore()\n{\n\tbool bRet = false;\n\n\tif(::OpenClipboard(theApp.m_MainhWnd))\n\t{\n\t\t::EmptyClipboard();\n\n\t\tSetClipboardData(theApp.m_cfIgnoreClipboard, NewGlobalP(\"Ignore\", sizeof(\"Ignore\")));\n\n\t\tINT_PTR size = m_Clipboard.GetSize();\n\t\tfor(int nPos = 0; nPos < size; nPos++)\n\t\t{\n\t\t\tCClipFormat *pCF = &m_Clipboard.ElementAt(nPos);\n\t\t\tif(pCF && pCF->m_hgData)\n\t\t\t{\n\t\t\t\t::SetClipboardData(pCF->m_cfType, pCF->m_hgData);\n\t\t\t\tpCF->m_hgData = NULL;//clipboard now owns the data\n\t\t\t}\n\t\t}\n\n\t\tbRet = TRUE;\n\t\t::CloseClipboard();\n\t}\n\n\tm_Clipboard.RemoveAll();\n\n\tif(bRet == FALSE)\n\t{\n\t\tLog(_T(\"CClipboardSaveRestore::Restore failed to restore clipboard\"));\n\t}\n\n\treturn bRet;\n}\n\nbool CClipboardSaveRestore::RestoreTextOnly()\n{\n\tbool bRet = false;\n\n\tif(::OpenClipboard(theApp.m_MainhWnd))\n\t{\n\t\t::EmptyClipboard();\n\n\t\tSetClipboardData(theApp.m_cfIgnoreClipboard, NewGlobalP(\"Ignore\", sizeof(\"Ignore\")));\n\n\t\tbool foundText = false;\n\t\tint hDropIndex = -1;\n\n\t\tINT_PTR size = m_Clipboard.GetSize();\n\t\tfor(int pos = 0; pos < size; pos++)\n\t\t{\n\t\t\tCClipFormat *pCF = &m_Clipboard.ElementAt(pos);\n\t\t\tif(pCF && pCF->m_hgData)\n\t\t\t{\n\t\t\t\tif(pCF->m_cfType == CF_TEXT || pCF->m_cfType == CF_UNICODETEXT)\n\t\t\t\t{\n\t\t\t\t\t//Make a copy of the data we are putting on the clipboard so we can still\n\t\t\t\t\t//restore all clips later in Restore()\n\t\t\t\t\tLPVOID localData = ::GlobalLock(pCF->m_hgData);\n\n\t\t\t\t\tHGLOBAL newData = NewGlobalP(localData, ::GlobalSize(pCF->m_hgData));\t\n\t\t\t\t\t::SetClipboardData(pCF->m_cfType, newData);\n\n\t\t\t\t\t::GlobalUnlock(pCF->m_hgData);\n\n\t\t\t\t\tfoundText = true;\n\t\t\t\t}\n\t\t\t\telse if(pCF->m_cfType == CF_HDROP)\n\t\t\t\t{\n\t\t\t\t\thDropIndex = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//if we didn't place text on the clipboard and we have a hdrop then convert the hdrop to text only with contents of hdrop\n\t\tif(foundText == false &&\n\t\t\thDropIndex > -1)\n\t\t{\n\t\t\tCString hDropString;\n\t\t\tCClipFormat *pCF = &m_Clipboard.ElementAt(hDropIndex);\n\t\t\tif(pCF && pCF->m_hgData)\n\t\t\t{\n\t\t\t\tHDROP drop = (HDROP)GlobalLock(pCF->m_hgData);\n\t\t\t\tint nNumFiles = DragQueryFile(drop, -1, NULL, 0);\n\t\t\t\tTCHAR file[MAX_PATH];\n\n\t\t\t\tfor(int nFile = 0; nFile < nNumFiles; nFile++)\n\t\t\t\t{\n\t\t\t\t\tif(DragQueryFile(drop, nFile, file, sizeof(file)) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(PathIsDirectory(file) == FALSE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thDropString += file;\n\t\t\t\t\t\t\thDropString += _T(\"\\r\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tGlobalUnlock(pCF->m_hgData);\n\n\t\t\t\tHGLOBAL newData = NewGlobalP(hDropString.GetBuffer(), ((hDropString.GetLength() + 1) * sizeof(TCHAR)));\t\n\t\t\t\t::SetClipboardData(CF_UNICODETEXT, newData);\n\t\t\t}\n\t\t}\n\n\t\tbRet = TRUE;\n\t\t::CloseClipboard();\n\t}\n\n\tif(bRet == FALSE)\n\t{\n\t\tLog(_T(\"CClipboardSaveRestore::Restore failed to restore clipboard\"));\n\t}\n\n\treturn bRet;\n}"
        },
        {
          "name": "ClipboardSaveRestore.h",
          "type": "blob",
          "size": 0.26953125,
          "content": "#pragma once\n\n#include \"Clip.h\"\n\nclass CClipboardSaveRestore\n{\npublic:\n\tCClipboardSaveRestore(void);\n\t~CClipboardSaveRestore(void);\n\n\tbool Save(BOOL textOnly);\n\tbool Restore();\n\tvoid Clear()\t{ m_Clipboard.RemoveAll(); }\n\tbool RestoreTextOnly();\n\n\tCClipFormats m_Clipboard;\n};\n"
        },
        {
          "name": "ClipboardViewer.cpp",
          "type": "blob",
          "size": 9.794921875,
          "content": "// ClipboardViewer.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"ClipboardViewer.h\"\r\n#include \"Misc.h\"\r\n#include \"shared/Tokenizer.h\"\r\n#include \"WildCardMatch.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CClipboardViewer\r\n\r\nCClipboardViewer::CClipboardViewer(CCopyThread* pHandler) :\r\n\tm_hNextClipboardViewer(0),\r\n\tm_bCalling_SetClipboardViewer(false),\r\n\tm_pHandler(pHandler),\r\n\tm_bPinging(false),\r\n\tm_bIsConnected(false),\r\n\tm_bConnect(false),\r\n\tm_dwLastCopy(0),\r\n\tm_connectOnStartup(true)\r\n{\r\n\tm_activeWindowTitle = _T(\"\");\r\n\tm_activeWindow = _T(\"\");\r\n}\r\n\r\nCClipboardViewer::~CClipboardViewer()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CClipboardViewer, CWnd)\r\n\t//{{AFX_MSG_MAP(CClipboardViewer)\r\n\tON_WM_CREATE()\r\n\tON_WM_CHANGECBCHAIN()\r\n\tON_WM_DRAWCLIPBOARD()\r\n\tON_WM_TIMER()\r\n\tON_WM_DESTROY()\r\n\t//}}AFX_MSG_MAP\r\n\tON_MESSAGE(WM_SETCONNECT, OnSetConnect)\r\n\tON_MESSAGE(WM_CLIPBOARDUPDATE, OnClipboardChange)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CClipboardViewer message handlers\r\nvoid CClipboardViewer::Create()\r\n{\r\n\tCString strParentClass = AfxRegisterWndClass(0);\r\n\tCWnd::CreateEx(0, strParentClass, _T(\"Ditto Clipboard Viewer\"), 0, -1, -1, 0, 0, 0, 0);\r\n\r\n\tif(m_connectOnStartup)\r\n\t{\r\n\t\tSetConnect(true);\r\n\t}\r\n}\r\n\r\n// connects as a clipboard viewer\r\nvoid CClipboardViewer::Connect()\r\n{\r\n\tLog(_T(\"Connect to Clipboard\"));\r\n\t\r\n\tm_bCalling_SetClipboardViewer = true;\r\n\r\n\tbool useSetClipboardWnd = true;\r\n\r\n\tif(IsVista())\r\n\t{\r\n\t\tHMODULE hUser32 = LoadLibrary(_T(\"USER32.dll\"));\r\n\t\tif (hUser32) \r\n\t\t{\r\n\t\t\ttypedef BOOL (__stdcall *AddClipFormatListener)( HWND hwnd );\r\n\r\n\t\t\tAddClipFormatListener addListener = (AddClipFormatListener) GetProcAddress(hUser32, \"AddClipboardFormatListener\");\r\n\t\t\tif(addListener)\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Connecting to clipboard with function AddClipboardFormatListener\"));\r\n\t\t\t\tuseSetClipboardWnd = false;\r\n\t\t\t\taddListener(m_hWnd);\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tif(useSetClipboardWnd)\r\n\t{\r\n\t\tLog(_T(\"Connecting to clipboard with function SetClipboardViewer\"));\r\n\t\tm_hNextClipboardViewer = CWnd::SetClipboardViewer();\t\t\r\n\t}\r\n\r\n\tm_bCalling_SetClipboardViewer = false;\r\n\t\r\n\tm_bIsConnected = true;\r\n\tm_bConnect = true;\r\n\r\n\tSetEnsureConnectedTimer();\r\n}\r\n\r\nvoid CClipboardViewer::SetEnsureConnectedTimer()\r\n{\r\n\tSetTimer(TIMER_ENSURE_VIEWER_IN_CHAIN, ONE_MINUTE*5, NULL);\r\n}\r\n\r\n// disconnects as a clipboard viewer\r\nvoid CClipboardViewer::Disconnect(bool bSendPing)\r\n{\r\n\tLog(_T(\"Disconnect From Clipboard\"));\r\n\r\n\tKillTimer(TIMER_ENSURE_VIEWER_IN_CHAIN);\r\n\tbool removeOldWay = true;\r\n\r\n\tif(IsVista())\r\n\t{\r\n\t\tHMODULE hUser32 = LoadLibrary(_T(\"USER32.dll\"));\r\n\t\tif (hUser32) \r\n\t\t{\r\n\t\t\ttypedef BOOL (__stdcall *RemoveClipFormatListener)( HWND hwnd );\r\n\r\n\t\t\tRemoveClipFormatListener removeListener = (RemoveClipFormatListener) GetProcAddress(hUser32, \"RemoveClipboardFormatListener\");\r\n\t\t\tif(removeListener)\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Disconnecting from clipboard with function RemoveClipboardFormatListener\"));\r\n\t\t\t\tremoveOldWay = false;\r\n\t\t\t\tremoveListener(m_hWnd);\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tif(removeOldWay)\r\n\t{\r\n\t\tLog(_T(\"Disconnecting from clipboard with function ChangeClipboardChain\"));\r\n\r\n\t\tBOOL bRet = CWnd::ChangeClipboardChain(m_hNextClipboardViewer);\r\n\t\tif(!bRet)\r\n\t\t{\r\n\t\t\tLog(_T(\"Error disconnecting from clipboard\"));\r\n\t\t\tbRet = CWnd::ChangeClipboardChain(m_hNextClipboardViewer);\r\n\t\t\tif(!bRet)\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Error disconnecting from clipboard2\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_hNextClipboardViewer = 0;\r\n\tm_bConnect = false;\r\n\tm_bIsConnected = false;\r\n\tif(bSendPing)\r\n\t\tSendPing();\r\n}\r\n\r\nvoid CClipboardViewer::SendPing()\r\n{\r\n\tif(CGetSetOptions::m_bEnsureConnectToClipboard)\r\n\t{\r\n\t\tif(OpenClipboard())\r\n\t\t{\r\n\t\t\tm_bPinging = true;\r\n\t\t\tSetClipboardData(theApp.m_PingFormat, NewGlobalP(\"Ditto Ping\", sizeof(\"Ditto Ping\")));\r\n\t\t\tSetClipboardData(theApp.m_cfIgnoreClipboard , NewGlobalP(\"Ignore\", sizeof(\"Ignore\")));\r\n\r\n\t\t\tSetTimer(TIMER_PING, 2000, NULL);\r\n\t\t\tCloseClipboard();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CClipboardViewer::SetConnect(bool bConnect)\r\n{\r\n\tm_bConnect = bConnect;\r\n\tif(bConnect)\r\n\t{\r\n\t\tif(m_bIsConnected == false)\r\n\t\t{\r\n\t\t\tConnect();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSendPing();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tDisconnect();\r\n\t}\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CClipboardViewer message handlers\r\n\r\nint CClipboardViewer::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif(CWnd::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\t\r\n\t//Set up the clip board viewer\r\n\tif(m_connectOnStartup)\r\n\t{\r\n\t\tConnect();\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n\r\nvoid CClipboardViewer::OnDestroy()\r\n{\r\n\tDisconnect();\r\n\tCWnd::OnDestroy();\r\n}\r\n\r\nvoid CClipboardViewer::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter) \r\n{\r\n\tLog(_T(\"OnChangeCbChain\"));\r\n\t\r\n\t// If the next window is closing, repair the chain. \r\n\tif(m_hNextClipboardViewer == hWndRemove)\r\n    {\r\n\t\tm_hNextClipboardViewer = hWndAfter;\r\n    }\r\n    // Otherwise, pass the message to the next link.\r\n\telse if (m_hNextClipboardViewer != NULL)\r\n    {\r\n\t\tif(m_hNextClipboardViewer != m_hWnd)\r\n\t\t{\r\n\t\t\t::SendMessage(m_hNextClipboardViewer, WM_CHANGECBCHAIN, (WPARAM) hWndRemove, (LPARAM) hWndAfter);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_hNextClipboardViewer = NULL;\r\n\t\t}\r\n    }\r\n}\r\n\r\nLRESULT CClipboardViewer::OnClipboardChange(WPARAM wParam, LPARAM lPara)\r\n{\r\n\tLog(StrF(_T(\"OnClipboardChange - Start\")));\r\n\tOnDrawClipboard();\r\n\tLog(StrF(_T(\"OnClipboardChange - End\")));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n//Message that the clipboard data has changed\r\nvoid CClipboardViewer::OnDrawClipboard() \r\n{\r\n\tif(::IsClipboardFormatAvailable(theApp.m_PingFormat))\r\n\t{\r\n\t\tm_bPinging = false;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// don't process the event when we first attach\r\n\tif(m_pHandler && !m_bCalling_SetClipboardViewer)\r\n\t{\r\n\t\tif(m_bIsConnected)\r\n\t\t{\r\n\t\t\tif(!::IsClipboardFormatAvailable(theApp.m_cfIgnoreClipboard))\r\n\t\t\t{\r\n\t\t\t\tif(ValidActiveWnd())\r\n\t\t\t\t{          \r\n\t\t\t\t\tLog(StrF(_T(\"OnDrawClipboard:: *** SetTimer *** %d\"), GetTickCount()));\r\n\r\n\t\t\t\t\tKillTimer(TIMER_DRAW_CLIPBOARD);\r\n\t\t\t\t\tSetTimer(TIMER_DRAW_CLIPBOARD, CGetSetOptions::m_lProcessDrawClipboardDelay, NULL);\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(_T(\"Not connected, ignore clipboard change\"));\r\n\t\t}\r\n\t}\r\n\r\n\t// pass the event to the next Clipboard viewer in the chain\r\n\tif(m_hNextClipboardViewer != NULL)\r\n\t{\r\n\t\tif(m_hNextClipboardViewer != m_hWnd)\r\n\t\t{\r\n\t\t\t::SendMessage(m_hNextClipboardViewer, WM_DRAWCLIPBOARD, 0, 0);\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_hNextClipboardViewer = NULL;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool CClipboardViewer::ValidActiveWnd()\r\n{\r\n\tm_activeWindow = _T(\"\");\r\n\tm_activeWindowTitle = _T(\"\";)\r\n\r\n\tHWND owner = ::GetClipboardOwner();\r\n\tif (owner != NULL)\r\n\t{\r\n\t\tDWORD PID = 0;\r\n\t\t::GetWindowThreadProcessId(owner, &PID);\r\n\r\n\t\tif (PID != 0)\r\n\t\t{\r\n\t\t\tm_activeWindow = GetProcessName(NULL, PID);\r\n\t\t\tm_activeWindowTitle = TopLevelWindowText(PID);\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\t//L\"RuntimeBroker.exe\" is what all modern apps report as\r\n\tif (m_activeWindow == _T(\"\"))\r\n\t{\r\n\t\tHWND active = ::GetForegroundWindow();\r\n\t\tm_activeWindow = GetProcessName(active, 0);\r\n\t\tm_activeWindowTitle = GetWndText(active);\r\n\t}\r\n\r\n\tm_activeWindow = m_activeWindow.MakeLower();\r\n\r\n\tCString includeApps = CGetSetOptions::GetCopyAppInclude().MakeLower();\r\n\r\n\tLog(StrF(_T(\"INCLUDE app names: %s, Active App: %s\"), includeApps, m_activeWindow));\r\n\r\n\tbool tokenMatch = false;\r\n\r\n\tCTokenizer token(includeApps, CGetSetOptions::GetCopyAppSeparator());\r\n\tCString line;\r\n\r\n\twhile(token.Next(line))\r\n\t{\r\n\t\tif(line != \"\")\r\n\t\t{\r\n\t\t\tif(CWildCardMatch::WildMatch(line.Trim(), m_activeWindow, \"\"))\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Inlclude app names Found Match %s - %s\"), line, m_activeWindow));\r\n\r\n\t\t\t\ttokenMatch = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\t\t\t\r\n\r\n\tif(tokenMatch)\r\n\t{\r\n\t\tCString excludeApps = CGetSetOptions::GetCopyAppExclude().MakeLower();\r\n\r\n\t\tif(excludeApps != \"\")\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"EXCLUDE app names %s, Active App: %s\"), excludeApps, m_activeWindow));\r\n\r\n\t\t\tCTokenizer token2(excludeApps, CGetSetOptions::GetCopyAppSeparator());\r\n\t\t\tCString line2;\r\n\t\t\twhile(token2.Next(line2))\r\n\t\t\t{\r\n\t\t\t\tif(line2 != \"\")\r\n\t\t\t\t{\r\n\t\t\t\t\tif(CWildCardMatch::WildMatch(line2.Trim(), m_activeWindow, \"\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLog(StrF(_T(\"Exclude app names Found Match %s - %s - NOT SAVING COPY\"), line2, m_activeWindow));\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"Didn't find a match to INCLUDE match %s, NOT SAVING COPY\"), includeApps));\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CClipboardViewer::OnTimer(UINT_PTR nIDEvent) \r\n{\r\n\tswitch(nIDEvent)\r\n\t{\r\n\tcase TIMER_ENSURE_VIEWER_IN_CHAIN:\r\n\t\tSendPing();\r\n\t\tbreak;\r\n\r\n\tcase TIMER_DRAW_CLIPBOARD:\r\n\t\t{\r\n\t\t\tKillTimer(nIDEvent);\r\n\t\t\r\n\t\t\tDWORD dwNow = GetTickCount();\r\n\r\n\t\t\tif(dwNow - m_dwLastCopy > CGetSetOptions::m_dwSaveClipDelay || m_dwLastCopy > dwNow)\r\n\t\t\t{\r\n\t\t\t\tif(!::IsClipboardFormatAvailable(theApp.m_cfIgnoreClipboard))\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"OnDrawClipboard::OnTimer %d\"), dwNow));\r\n\r\n\t\t\t\t\tm_pHandler->OnClipboardChange(m_activeWindow, m_activeWindowTitle);\r\n\r\n\t\t\t\t\tm_dwLastCopy = dwNow;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Clip copy to fast difference from last copy = %d\"), (dwNow - m_dwLastCopy)));\r\n\t\t\t}\r\n\r\n\t\t\tm_activeWindow = _T(\"\");\r\n\t\t\tm_activeWindowTitle = _T(\"\");\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase TIMER_PING:\r\n\t\tKillTimer(TIMER_PING);\r\n\r\n\t\t//If we haven't received the change clipboard message then we are disconnected\r\n\t\t//if so reconnect\r\n\t\tif(m_bPinging)\r\n\t\t{\r\n\t\t\tif(m_bConnect)\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Ping Failed Reconnecting to clipboard\"));\r\n\t\t\t\tDisconnect(false);\r\n\t\t\t\tConnect();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Ping Failed but Connected set to FALSE so this is ok\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(m_bConnect)\r\n\t\t\t{\r\n\t\t\t\tm_bIsConnected = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\tCWnd::OnTimer(nIDEvent);\r\n}\r\n\r\nLRESULT CClipboardViewer::OnSetConnect(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tbool bConnect = wParam == TRUE;\r\n\tSetConnect(bConnect);\r\n\treturn TRUE;\r\n}"
        },
        {
          "name": "ClipboardViewer.h",
          "type": "blob",
          "size": 1.96875,
          "content": "#if !defined(AFX_CLIPBOARDVIEWER_H__67418FB6_6048_48FA_86D4_F412CACC41B1__INCLUDED_)\n#define AFX_CLIPBOARDVIEWER_H__67418FB6_6048_48FA_86D4_F412CACC41B1__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n\n#define TIMER_ENSURE_VIEWER_IN_CHAIN\t6\n#define TIMER_DRAW_CLIPBOARD\t\t\t7\n#define TIMER_PING\t\t\t\t\t\t8\n\nclass CClipboardViewer : public CWnd\n{\n// Construction\npublic:\n\tCClipboardViewer(CCopyThread* pHandler);\n\tvirtual ~CClipboardViewer();\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CClipboardViewer)\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvoid Create();\n\n\tHWND\tm_hNextClipboardViewer;\n\tbool\tm_bCalling_SetClipboardViewer;\n\tbool\tm_bPinging;\n\tbool\tm_bConnect;\n\tbool\tm_bIsConnected;\n\tbool\tm_connectOnStartup;\n\tCString m_activeWindow;\n\tCString m_activeWindowTitle;\n\n\t// m_pHandler->OnClipboardChange is called when the clipboard changes.\n\tCCopyThread*\tm_pHandler;\n\n\tvoid Connect();    // connects as a clipboard viewer\n\tvoid Disconnect(bool bSendPing = true); // disconnects as a clipboard viewer\n\n\tvoid SendPing();\n\n\tbool GetConnect()\t\t\t\t{ return m_bConnect; }\n\tvoid SetConnect(bool bConnect);\n\tvoid SetEnsureConnectedTimer();\n\tbool ValidActiveWnd();\n\n\tDWORD m_dwLastCopy;\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CClipboardViewer)\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnDestroy();\n\tafx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);\n\tafx_msg void OnDrawClipboard();\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\t//}}AFX_MSG\n\tafx_msg LRESULT OnSetConnect(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT CClipboardViewer::OnClipboardChange(WPARAM wParam, LPARAM lPara);\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_CLIPBOARDVIEWER_H__67418FB6_6048_48FA_86D4_F412CACC41B1__INCLUDED_)\n"
        },
        {
          "name": "ComboBoxSearch.cpp",
          "type": "blob",
          "size": 2.5048828125,
          "content": "// ComboBoxSearch.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"ComboBoxSearch.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CComboBoxSearch\n\nCComboBoxSearch::CComboBoxSearch()\n{\n\tm_bShowingDropDown = FALSE;\n}\n\nCComboBoxSearch::~CComboBoxSearch()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CComboBoxSearch, CComboBox)\n\t//{{AFX_MSG_MAP(CComboBoxSearch)\n\tON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropdown)\n\tON_CONTROL_REFLECT(CBN_SELENDCANCEL, OnSelendcancel)\n\tON_CONTROL_REFLECT(CBN_SELENDOK, OnSelendok)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CComboBoxSearch message handlers\n\nvoid CComboBoxSearch::OnDropdown() \n{\n\tm_bShowingDropDown = TRUE;\n\tSetCurSel(0);\n}\n\nvoid CComboBoxSearch::OnSelendcancel() \n{\n\tm_bShowingDropDown = FALSE;\n}\n\nvoid CComboBoxSearch::OnSelendok() \n{\n\tm_bShowingDropDown = FALSE;\n}\n\nBOOL CComboBoxSearch::PreTranslateMessage(MSG* pMsg) \n{\n\tswitch(pMsg->message) \n\t{\n\t\tcase WM_KEYDOWN:\n\t\t{\n\t\t\tif(pMsg->wParam == VK_RETURN && m_bShowingDropDown == FALSE)\n\t\t\t{\n\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\tif(pWnd)\n\t\t\t\t{\n\t\t\t\t\tif(GetCurSel() == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Add the text to the combo\n\t\t\t\t\t\tCString csText;\n\t\t\t\t\t\tGetWindowText(csText);\n\t\t\t\t\t\tint nRet = InsertString(0, csText);\n\t\t\t\t\t\tSetCurSel(nRet);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(g_Opt.m_bFindAsYouType)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(NM_SELECT, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Send a message to the parent to refill the lb from the search\n\t\t\t\t\t\tpWnd->PostMessage(CB_SEARCH, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn TRUE;\n\t\t\t}\t\n\t\t\telse if (pMsg->wParam == VK_DOWN ||\n\t\t\t\tpMsg->wParam == VK_UP ||\n\t\t\t\tpMsg->wParam == VK_F3)\n\t\t\t{\n\t\t\t\tif(g_Opt.m_bFindAsYouType)\n\t\t\t\t{\n\t\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\t\tif(pWnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tif(!m_bShowingDropDown)\n//\t\t\t\t{\n//\t\t\t\t\tShowDropDown();\n//\t\t\t\t\treturn TRUE;\n//\t\t\t\t}\n\t\t\t}\n\t\t\telse if(pMsg->wParam == 'C' && \n\t\t\t\t\tGetKeyState(VK_CONTROL) & 0x8000 ||\n\t\t\t\t\tpMsg->wParam == 'X' && \n\t\t\t\t\tGetKeyState(VK_CONTROL) & 0x8000 ||\n\t\t\t\t\tpMsg->wParam == VK_DELETE)\n\t\t\t{\n\t\t\t\tLONG lEditSel = GetEditSel();\n\t\t\t\tif(LOWORD(lEditSel) == HIWORD(lEditSel))\n\t\t\t\t{\n\t\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\t\tif(pWnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn CComboBox::PreTranslateMessage(pMsg);\n}"
        },
        {
          "name": "ComboBoxSearch.h",
          "type": "blob",
          "size": 1.19140625,
          "content": "#if !defined(AFX_COMBOBOXSEARCH_H__24A1E936_2E2A_45D5_99F8_0BDC62E3F2A9__INCLUDED_)\n#define AFX_COMBOBOXSEARCH_H__24A1E936_2E2A_45D5_99F8_0BDC62E3F2A9__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// ComboBoxSearch.h : header file\n//\n\nclass CComboBoxSearch : public CComboBox\n{\n// Construction\npublic:\n\tCComboBoxSearch();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n\tBOOL GetShowingDropDown()\t\t{ return m_bShowingDropDown;\t}\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CComboBoxSearch)\n\tpublic:\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\t//}}AFX_VIRTUAL\n\nprotected:\n\tBOOL m_bShowingDropDown;\n// Implementation\npublic:\n\tvirtual ~CComboBoxSearch();\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CComboBoxSearch)\n\tafx_msg void OnDropdown();\n\tafx_msg void OnSelendcancel();\n\tafx_msg void OnSelendok();\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_COMBOBOXSEARCH_H__24A1E936_2E2A_45D5_99F8_0BDC62E3F2A9__INCLUDED_)\n"
        },
        {
          "name": "ConvertRTFToText.cpp",
          "type": "blob",
          "size": 1.20703125,
          "content": "#include \"stdafx.h\"\n#include \"ConvertRTFToText.h\"\n#include \"Shared/TextConvert.h\"\n\n\nBOOL CConvertRTFToText::Create()\n{\n\t// Get the class name and create the window\n\tCString szClassName = AfxRegisterWndClass(CS_CLASSDC | CS_SAVEBITS, LoadCursor(NULL, IDC_ARROW));\n\n\t// Create the window - just don't show it yet.\n\tif (!CWnd::CreateEx(WS_EX_NOACTIVATE, szClassName, _T(\"\"), WS_POPUP,0, 0, 0, 0, NULL, 0, NULL))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tm_richEditTextConverter.Create(_T(\"\"), _T(\"\"), WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_NOHIDESEL | ES_AUTOHSCROLL, CRect(10, 10, 100, 200), this, 1);\n\n\treturn TRUE;\n}\n\nCString CConvertRTFToText::GetTextFromRTF(CStringA rtf)\n{\n\tm_richEditTextConverter.SetRTF(rtf);\n\n\tauto x = m_richEditTextConverter.GetRTF();\n\n\tint loops = 0;\n\tMSG msg;\n\twhile (::PeekMessage(&msg, m_hWnd, 0, 0, PM_REMOVE))\n\t{\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\n\t\tloops++;\n\t\tif (loops > 100)\n\t\t\tbreak;\n\t}\n\n\tloops = 0;\n\twhile (::PeekMessage(&msg, m_richEditTextConverter.m_hWnd, 0, 0, PM_REMOVE))\n\t{\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\n\t\tloops++;\n\t\tif (loops > 100)\n\t\t\tbreak;\n\t}\n\n\tSleep(50);\n\n\tCString text = m_richEditTextConverter.GetText();\n\n\treturn text;\n}"
        },
        {
          "name": "ConvertRTFToText.h",
          "type": "blob",
          "size": 0.197265625,
          "content": "#pragma once\n#include \"RichEditCtrlEx.h\"\n\nclass CConvertRTFToText : public CWnd\n{\npublic:\n\tBOOL Create();\n\tCString GetTextFromRTF(CStringA rtf);\n\nprivate:\n\tCRichEditCtrlEx m_richEditTextConverter;\n\n};\n\n"
        },
        {
          "name": "CopyProperties.cpp",
          "type": "blob",
          "size": 14.2041015625,
          "content": "// CopyProperties.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"CopyProperties.h\"\r\n#include \".\\copyproperties.h\"\r\n#include \"Md5.h\"\r\n#include \"Shared\\TextConvert.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CCopyProperties dialog\r\n\r\n\r\nCCopyProperties::CCopyProperties(long lCopyID, CWnd* pParent, CClip *pMemoryClip)\r\n\t: CDialog(CCopyProperties::IDD, pParent)\r\n{\r\n\tm_lCopyID = lCopyID;\r\n\tm_bDeletedData = false;\r\n\tm_bChangedText = false;\r\n\tm_bHandleKillFocus = false;\r\n\tm_bHideOnKillFocus = false;\r\n\tm_lGroupChangedTo = -1;\r\n\tm_pMemoryClip = pMemoryClip;\r\n\tm_bSetToTopMost = true;\r\n\r\n\t//{{AFX_DATA_INIT(CCopyProperties)\r\n\tm_eDate = _T(\"\");\r\n\tm_lastPasteDate = _T(\"\");\r\n\tm_bNeverAutoDelete = FALSE;\r\n\t//}}AFX_DATA_INIT\r\n}\r\n\r\n\r\nvoid CCopyProperties::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialog::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(CCopyProperties)\r\n\tDDX_Control(pDX, IDC_EDIT_QUICK_PASTE, m_QuickPasteText);\r\n\tDDX_Control(pDX, IDC_EDIT_PROPERTIES, m_description);\r\n\tDDX_Control(pDX, IDC_COMBO1, m_GroupCombo);\r\n\tDDX_Control(pDX, IDC_HOTKEY, m_HotKey);\r\n\tDDX_Control(pDX, IDC_COPY_DATA, m_lCopyData);\r\n\tDDX_Text(pDX, IDC_DATE, m_eDate);\r\n\tDDX_Text(pDX, IDC_DATE_LAST_USED, m_lastPasteDate);\r\n\tDDX_Check(pDX, IDC_NEVER_AUTO_DELETE, m_bNeverAutoDelete);\r\n\tDDX_Check(pDX, IDC_HOT_KEY_GLOBAL, m_hotKeyGlobal);\r\n\tDDX_Control(pDX, IDC_HOTKEY_MOVE_TO_GROUP, m_MoveToGrouHotKey);\r\n\tDDX_Check(pDX, IDC_HOT_KEY_GLOBAL_MOVE_TO_GROUP, m_moveToGroupHotKeyGlobal);\r\n\t//}}AFX_DATA_MAP\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CCopyProperties, CDialog)\r\n\t//{{AFX_MSG_MAP(CCopyProperties)\r\n\tON_BN_CLICKED(IDC_DELETE_COPY_DATA, OnDeleteCopyData)\r\n\tON_WM_ACTIVATE()\r\n\tON_WM_SIZE()\r\n\t//}}AFX_MSG_MAP\r\n\tON_WM_CTLCOLOR()\r\n\tON_LBN_SELCHANGE(IDC_COPY_DATA, &CCopyProperties::OnLbnSelchangeCopyData)\r\n\tON_WM_NCLBUTTONDOWN()\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CCopyProperties message handlers\r\n\r\nBOOL CCopyProperties::OnInitDialog() \r\n{\r\n\tCDialog::OnInitDialog();\r\n\r\n\t//remove the default icon in top left of window\r\n\tint extendedStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE);\r\n\tSetWindowLong(m_hWnd, GWL_EXSTYLE, extendedStyle | WS_EX_DLGMODALFRAME);\r\n\tSetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);\r\n\r\n\tm_GroupCombo.FillCombo();\r\n\r\n\ttry\r\n\t{\r\n\t\tif(m_lCopyID == -1 && m_pMemoryClip != NULL)\r\n\t\t{\r\n\t\t\tLoadDataFromCClip(*m_pMemoryClip);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(m_clip.LoadMainTable(m_lCopyID))\r\n\t\t\t{\r\n\t\t\t\tm_clip.LoadFormats(m_lCopyID);\r\n\t\t\t\tLoadDataFromCClip(m_clip);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\tUpdateData(FALSE);\r\n\r\n\tif(m_bSetToTopMost)\r\n\t\tSetWindowPos(&CWnd::wndTopMost, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);\r\n\r\n\tif(m_lCopyID == -1 && m_pMemoryClip != NULL)\r\n\t{\r\n\t\tGetDlgItem(IDOK)->SetFocus();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_description.SetFocus();\r\n\t}\r\n\t\r\n\tm_Resize.SetParent(m_hWnd);\r\n\tm_Resize.AddControl(IDC_EDIT_PROPERTIES, DR_SizeHeight | DR_SizeWidth);\r\n\tm_Resize.AddControl(IDC_STATIC_FORMATS, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_COPY_DATA, DR_MoveTop | DR_SizeWidth);\r\n\tm_Resize.AddControl(IDC_DELETE_COPY_DATA, DR_MoveTop);\r\n\tm_Resize.AddControl(IDOK, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDCANCEL, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_EDIT_QUICK_PASTE, DR_SizeWidth);\r\n\tm_Resize.AddControl(IDC_COMBO1, DR_SizeWidth);\r\n\tm_Resize.AddControl(IDC_STATIC_MD5, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_EDIT_MD5, DR_MoveTop | DR_MoveLeft);\r\n\t\r\n\ttheApp.m_Language.UpdateClipProperties(this);\r\n\r\n\tif (m_clip.ID() > 0)\r\n\t{\r\n\t\tCString text;\r\n\t\tthis->GetWindowText(text);\r\n\t\tCString newText;\r\n\t\tnewText.Format(_T(\"%s - %d\"), text, m_clip.ID());\r\n\t\tthis->SetWindowText(newText);\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CCopyProperties::LoadDataFromCClip(CClip &Clip)\r\n{\r\n\tCOleDateTime dtTime(Clip.m_Time.GetTime());\r\n\tm_eDate = dtTime.Format();\r\n\t\r\n\tCOleDateTime lastPasteDate(Clip.m_lastPasteDate.GetTime());\r\n\tm_lastPasteDate = lastPasteDate.Format();\r\n\r\n\tm_description.SetWindowText(Clip.m_Desc);\r\n\t\r\n\tif(Clip.m_dontAutoDelete)\r\n\t{\r\n\t\tm_bNeverAutoDelete = TRUE;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_bNeverAutoDelete = FALSE;\r\n\t}\r\n\r\n\tm_hotKeyGlobal = Clip.m_globalShortCut;\r\n\r\n\tm_GroupCombo.SetCurSelOnItemData(Clip.m_parentId);\r\n\r\n\tDWORD shortcut = ACCEL_MAKEKEY(LOBYTE(Clip.m_shortCut), ((HIBYTE(Clip.m_shortCut)) &~HOTKEYF_EXT));\r\n\r\n\tswitch (LOBYTE(shortcut))\r\n\t{\r\n\t\tcase VK_LEFT:\r\n\t\tcase VK_UP:\r\n\t\tcase VK_RIGHT:\r\n\t\tcase VK_DOWN: // arrow keys\r\n\t\tcase VK_PRIOR:\r\n\t\tcase VK_NEXT: // page up and page down\r\n\t\tcase VK_END:\r\n\t\tcase VK_HOME:\r\n\t\tcase VK_INSERT:\r\n\t\tcase VK_DELETE:\r\n\t\tcase VK_DIVIDE: // numpad slash\r\n\t\tcase VK_NUMLOCK:\r\n\t\t{\r\n\t\t\tshortcut = ACCEL_MAKEKEY(LOBYTE(shortcut), (HIBYTE(shortcut) | HOTKEYF_EXT));\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\tm_HotKey.SetHotKey(LOBYTE(shortcut), (HIBYTE(shortcut)));\r\n\tm_HotKey.SetRules(HKCOMB_A, 0);\r\n\tif(HIBYTE(Clip.m_shortCut) & HOTKEYF_EXT)\r\n\t{\r\n\t\t::CheckDlgButton(m_hWnd, IDC_CHECK_WIN, BST_CHECKED);\r\n\t}\r\n\r\n\tm_moveToGroupHotKeyGlobal = Clip.m_globalMoveToGroupShortCut;\r\n\r\n\tm_MoveToGrouHotKey.SetHotKey(LOBYTE(Clip.m_moveToGroupShortCut), (HIBYTE(Clip.m_moveToGroupShortCut) & ~HOTKEYF_EXT));\r\n\tm_MoveToGrouHotKey.SetRules(HKCOMB_A, 0);\r\n\tif(HIBYTE(Clip.m_moveToGroupShortCut) & HOTKEYF_EXT)\r\n\t{\r\n\t\t::CheckDlgButton(m_hWnd, IDC_CHECK_WIN_MOVE_TO_GROUP, BST_CHECKED);\r\n\t}\r\n\r\n\tm_QuickPasteText.SetWindowText(Clip.m_csQuickPaste);\r\n\r\n\tCString cs;\r\n\tCClipFormat* pCF;\r\n\tINT_PTR count = Clip.m_Formats.GetSize();\r\n\tfor(int i = 0; i < count; i++)\r\n\t{\r\n\t\tpCF = &Clip.m_Formats.GetData()[i];\r\n\t\tif(pCF)\r\n\t\t{\r\n\t\t\tcs.Format(_T(\"%s, %d\"), GetFormatName(pCF->m_cfType), GlobalSize(pCF->m_hgData));\r\n\t\t\tint nIndex = m_lCopyData.AddString(cs);\r\n\t\t\t\r\n\t\t\tif(m_lCopyID == -1 && pCF->m_dataId == -1)\r\n\t\t\t\tm_lCopyData.SetItemData(nIndex, i);\r\n\t\t\telse\r\n\t\t\t\tm_lCopyData.SetItemData(nIndex, pCF->m_dataId);\r\n\t\t}\r\n\t}\r\n\t\r\n\tint selectedRow = m_lCopyData.GetCount()-1;\r\n\tif(selectedRow >= 0 && selectedRow < m_lCopyData.GetCount())\r\n\t{\r\n\t\tm_lCopyData.SetSel(selectedRow);\r\n\t\tm_lCopyData.SetCurSel(selectedRow);\r\n\t\tm_lCopyData.SetCaretIndex(selectedRow);\r\n\t\tm_lCopyData.SetAnchorIndex(selectedRow);\r\n\t}\r\n\r\n\t//show the selected data md5\r\n\tOnLbnSelchangeCopyData();\r\n\t\r\n\tif(Clip.m_bIsGroup == FALSE)\r\n\t{\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_HOT_KEY_MOVE_TO_GROUP), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY_MOVE_TO_GROUP), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_WIN_MOVE_TO_GROUP), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOT_KEY_GLOBAL_MOVE_TO_GROUP), SW_HIDE);\r\n\r\n\t\tCRect anchorRect;\r\n\t\t::GetWindowRect(::GetDlgItem(m_hWnd, IDC_STATIC_HOT_KEY_MOVE_TO_GROUP), &anchorRect);\r\n\t\tScreenToClient(&anchorRect);\r\n\t\t\r\n\r\n\t\tHWND hwnd = ::GetTopWindow(this->GetSafeHwnd());\r\n\t\t// while we have a valid hwnd, \r\n\t\t// loop through all child windows\r\n\t\twhile (hwnd)\r\n\t\t{\r\n\t\t\tCRect rect;\r\n\t\t\t::GetWindowRect(hwnd, &rect);\r\n\t\t\tScreenToClient(&rect);\r\n\r\n\t\t\tif(rect.top > anchorRect.bottom)\r\n\t\t\t{\r\n\t\t\t\t::MoveWindow(hwnd, rect.left, \r\n\t\t\t\t\trect.top - (anchorRect.Height()+4), rect.Width(), \r\n\t\t\t\t\trect.Height(), TRUE);\r\n\t\t\t}\r\n\r\n\t\t\t// do something with the hwnd\r\n\t\t\t// and get the next child control's hwnd\r\n\t\t\thwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT);\r\n\t\t}\r\n\r\n\t\tCRect rect2;\r\n\t\t::GetWindowRect(m_hWnd, &rect2);\r\n\r\n\t\t::MoveWindow(m_hWnd, rect2.left, \r\n\t\t\t\trect2.top, rect2.Width(), \r\n\t\t\t\trect2.Height() - (anchorRect.Height()+4), TRUE);\r\n\t}\r\n}\r\n\r\nvoid CCopyProperties::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \r\n{\r\n\tCDialog::OnActivate(nState, pWndOther, bMinimized);\r\n\r\n\tif (nState == WA_INACTIVE)\r\n\t{\r\n\t\tif(m_bHideOnKillFocus)\r\n\t\t{\r\n\t\t\tif(!m_bHandleKillFocus)\r\n\t\t\t{\r\n\t\t\t\tEndDialog(-1);\r\n\t\t\t\tm_bHandleKillFocus = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (nState == WA_ACTIVE)\r\n\t{\r\n\t\tSetFocus();\r\n\t\t::SetForegroundWindow(m_hWnd);\r\n\t}\r\n\r\n}\r\nvoid CCopyProperties::OnOK() \r\n{\r\n\tUpdateData();\r\n\r\n\ttry\r\n\t{\r\n\t\tif(m_lCopyID == -1 && m_pMemoryClip != NULL)\r\n\t\t{\r\n\t\t\tLoadDataIntoCClip(*m_pMemoryClip);\r\n\r\n\t\t\tm_DeletedData.SortDescending();\r\n\t\t\tINT_PTR count = m_DeletedData.GetSize();\r\n\t\t\tfor(int i = 0; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tm_pMemoryClip->m_Formats.RemoveAt(m_DeletedData[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCClip clip;\r\n\t\t\tif(clip.LoadMainTable(m_lCopyID))\r\n\t\t\t{\r\n\t\t\t\tLoadDataIntoCClip(clip);\r\n\r\n\t\t\t\tif(CheckGlobalHotKey(clip) == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(MessageBox(_T(\"Error registering global hot key\\n\\nContinue?\"), _T(\"\"), MB_YESNO|MB_ICONWARNING) == IDNO)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(CheckMoveToGroupGlobalHotKey(clip) == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(MessageBox(_T(\"Error registering global move to group hot key\\n\\nContinue?\"), _T(\"\"), MB_YESNO|MB_ICONWARNING) == IDNO)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(clip.ModifyMainTable())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(m_bDeletedData)\r\n\t\t\t\t\t{    \r\n\t\t\t\t\t\tDeleteFormats(m_lCopyID, m_DeletedData);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_bHandleKillFocus = true;\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\tCDialog::OnOK();\r\n}\r\n\r\nBOOL CCopyProperties::CheckGlobalHotKey(CClip &clip)\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\tif(clip.m_globalShortCut)\r\n\t{\r\n\t\tret = g_HotKeys.ValidateClip(clip.m_id, clip.m_shortCut, clip.m_Desc, CHotKey::PASTE_OPEN_CLIP);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tg_HotKeys.Remove(clip.m_id, CHotKey::PASTE_OPEN_CLIP);\r\n\t\tret = TRUE;\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nBOOL CCopyProperties::CheckMoveToGroupGlobalHotKey(CClip &clip)\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\tif(clip.m_globalMoveToGroupShortCut)\r\n\t{\r\n\t\tret = g_HotKeys.ValidateClip(clip.m_id, clip.m_moveToGroupShortCut, clip.m_Desc, CHotKey::MOVE_TO_GROUP);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tg_HotKeys.Remove(clip.m_id, CHotKey::MOVE_TO_GROUP);\r\n\t\tret = TRUE;\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CCopyProperties::LoadDataIntoCClip(CClip &Clip)\r\n{\r\n\tlong lHotKey = m_HotKey.GetHotKey();\r\n\r\n\tshort sKeyKode = LOBYTE(m_HotKey.GetHotKey());\r\n\tshort sModifers = (HIBYTE(m_HotKey.GetHotKey())) & ~HOTKEYF_EXT;\r\n\r\n\tif(sKeyKode && ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_WIN))\r\n\t{\r\n\t\tsModifers |= HOTKEYF_EXT;\r\n\t}\r\n\r\n\tClip.m_shortCut = MAKEWORD(sKeyKode, sModifers); \r\n\r\n\tlong moveToGroupHotKey = m_MoveToGrouHotKey.GetHotKey();\r\n\r\n\tshort moveToGroupKeyKode = LOBYTE(m_MoveToGrouHotKey.GetHotKey());\r\n\tshort moveToGroupModifers = HIBYTE(m_MoveToGrouHotKey.GetHotKey());\r\n\r\n\tif(moveToGroupKeyKode && ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_WIN_MOVE_TO_GROUP))\r\n\t{\r\n\t\tmoveToGroupModifers |= HOTKEYF_EXT;\r\n\t}\r\n\r\n\tClip.m_moveToGroupShortCut = MAKEWORD(moveToGroupKeyKode, moveToGroupModifers); \r\n\r\n\t//remove any others that have the same hot key\r\n\tif(Clip.m_shortCut > 0)\r\n\t{\r\n\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lShortCut = 0 where lShortCut = %d AND lID <> %d;\"), Clip.m_shortCut, m_lCopyID);\r\n\t}\r\n\r\n\tif(Clip.m_moveToGroupShortCut > 0)\r\n\t{\r\n\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET MoveToGroupShortCut = 0 where MoveToGroupShortCut = %d AND lID <> %d;\"), Clip.m_shortCut, m_lCopyID);\r\n\t}\r\n\r\n\tm_description.GetWindowText(Clip.m_Desc);\r\n\r\n\tm_QuickPasteText.GetWindowText(Clip.m_csQuickPaste);\t\r\n\r\n\tClip.m_parentId = m_GroupCombo.GetItemDataFromCursel();\r\n\r\n\t//If we are going from no group to a group or the\r\n\t//don't auto delete check box is checked\r\n\tif(m_bNeverAutoDelete)\r\n\t{\r\n\t\tClip.m_dontAutoDelete = (int)CTime::GetCurrentTime().GetTime();\r\n\t}\r\n\telse if(m_bNeverAutoDelete == FALSE)\r\n\t{\r\n\t\tClip.m_dontAutoDelete = FALSE;\r\n\t}\r\n\r\n\tClip.m_globalShortCut = m_hotKeyGlobal;\r\n\r\n\tClip.m_globalMoveToGroupShortCut = m_moveToGroupHotKeyGlobal;\r\n}\r\n\r\nvoid CCopyProperties::OnDeleteCopyData() \r\n{\r\n\tint nCount = m_lCopyData.GetSelCount();\r\n\tif(nCount)\r\n\t{\r\n\t\tm_bDeletedData = true;\r\n\r\n\t\t//Get the selected indexes\r\n\t\tARRAY items;\r\n\t\titems.SetSize(nCount);\r\n\t\tm_lCopyData.GetSelItems(nCount, items.GetData()); \r\n\r\n\t\titems.SortDescending();\r\n\r\n\t\t//Get the selected itemdata\r\n\t\tfor(int i = 0; i < nCount; i++)\r\n\t\t{\r\n\t\t\tint row = items[i];\r\n\t\t\tm_DeletedData.Add((int)m_lCopyData.GetItemData(row));\r\n\t\t\tm_lCopyData.DeleteString(row);\r\n\r\n\t\t\tint newRow = row-1;\r\n\t\t\tif(newRow < 0)\r\n\t\t\t{\r\n\t\t\t\tnewRow = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif(newRow >= 0 && newRow < m_lCopyData.GetCount())\r\n\t\t\t{\r\n\t\t\t\tm_lCopyData.SetSel(newRow);\r\n\t\t\t\tm_lCopyData.SetCurSel(newRow);\r\n\t\t\t\tm_lCopyData.SetCaretIndex(newRow);\r\n\t\t\t\tm_lCopyData.SetAnchorIndex(newRow);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n}\r\n\r\nvoid CCopyProperties::OnCancel() \r\n{\r\n\tm_bHandleKillFocus = true;\r\n\t\t\r\n\tCDialog::OnCancel();\r\n}\r\n\r\nvoid CCopyProperties::OnSize(UINT nType, int cx, int cy) \r\n{\r\n\tCDialog::OnSize(nType, cx, cy);\r\n\t\r\n\tif (((GetKeyState(VK_LBUTTON) & 0x100) != 0) &&\r\n\t\tm_mouseDownOnCaption == false)\r\n\t{\r\n\t\tm_Resize.MoveControls(CSize(cx, cy));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_Resize.SetParent(m_hWnd);\r\n\t}\r\n}\r\n\r\nHBRUSH CCopyProperties::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\r\n{\r\n\tHBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);\r\n\r\n\t// TODO:  Change any attributes of the DC here\r\n\r\n\t// TODO:  Return a different brush if the default is not desired\r\n\treturn hbr;\r\n}\r\n\r\n\r\nvoid CCopyProperties::OnLbnSelchangeCopyData()\r\n{\r\n\tint selCount = m_lCopyData.GetSelCount();\r\n\tif (selCount > 0)\r\n\t{\r\n\t\tm_bDeletedData = true;\r\n\r\n\t\t//Get the selected indexes\r\n\t\tARRAY items;\r\n\t\titems.SetSize(selCount);\r\n\t\tm_lCopyData.GetSelItems(selCount, items.GetData());\r\n\r\n\t\titems.SortDescending();\r\n\r\n\t\tfor (int i = 0; i < selCount; i++)\r\n\t\t{\r\n\t\t\tint row = items[i];\r\n\t\t\tint itemData = (int)m_lCopyData.GetItemData(row);\r\n\r\n\t\t\tCClip *pClip = NULL;\r\n\t\t\tif (m_lCopyID == -1 && m_pMemoryClip != NULL)\r\n\t\t\t{\r\n\t\t\t\tpClip = m_pMemoryClip;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpClip = &m_clip;\r\n\t\t\t}\r\n\r\n\t\t\tif (pClip != NULL)\r\n\t\t\t{\r\n\t\t\t\tCClipFormat* pCF;\r\n\t\t\t\tINT_PTR dataCount = pClip->m_Formats.GetSize();\r\n\t\t\t\tfor (int i = 0; i < dataCount; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tpCF = &pClip->m_Formats.GetData()[i];\r\n\t\t\t\t\tif (pCF)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (pCF->m_dataId == itemData)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tCMd5 md5;\r\n\t\t\t\t\t\t\tmd5.MD5Init();\r\n\r\n\t\t\t\t\t\t\tSIZE_T size = ::GlobalSize(pCF->Data());\r\n\t\t\t\t\t\t\tvoid* pv = GlobalLock(pCF->Data());\r\n\t\t\t\t\t\t\tif (pv != NULL)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmd5.MD5Update((unsigned char*)pv, (unsigned int)size);\r\n\r\n\t\t\t\t\t\t\t\tGlobalUnlock(pCF->Data());\r\n\r\n\t\t\t\t\t\t\t\tCStringA md5String = md5.MD5FinalToString();\r\n\r\n\t\t\t\t\t\t\t\tthis->SetDlgItemText(IDC_EDIT_MD5, CTextConvert::AnsiToUnicode(md5String));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid CCopyProperties::OnNcLButtonDown(UINT nHitTest, CPoint point)\r\n{\r\n\tm_mouseDownOnCaption = false;\r\n\r\n\tif (nHitTest == HTCAPTION)\r\n\t{\r\n\t\tm_mouseDownOnCaption = true;\r\n\t}\r\n\r\n\tCDialog::OnNcLButtonDown(nHitTest, point);\r\n}\r\n"
        },
        {
          "name": "CopyProperties.h",
          "type": "blob",
          "size": 2.591796875,
          "content": "#include \"afxwin.h\"\n#if !defined(AFX_COPYPROPERTIES_H__129FE1CD_D305_487A_B88C_BB01CD9C1BB7__INCLUDED_)\n#define AFX_COPYPROPERTIES_H__129FE1CD_D305_487A_B88C_BB01CD9C1BB7__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// CopyProperties.h : header file\n//\n\n#include \"GroupCombo.h\"\n#include \"RichEditCtrlEx.h\"\n#include \"DialogResizer.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// CCopyProperties dialog\n\nclass CCopyProperties : public CDialog\n{\n// Construction\npublic:\n\tCCopyProperties(long lCopyID, CWnd* pParent = NULL, CClip *pMemoryClip = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CCopyProperties)\n\tenum { IDD = IDD_COPY_PROPERTIES };\n\tCEdit\tm_QuickPasteText;\n\tCEdit m_description;\n\tCGroupCombo\tm_GroupCombo;\n\tCHotKeyCtrl\tm_HotKey;\n\tCHotKeyCtrl\tm_MoveToGrouHotKey;\n\tCListBox\tm_lCopyData;\n\tCString\tm_eDate;\n\tCString m_lastPasteDate;\n\tBOOL\tm_bNeverAutoDelete;\n\tBOOL m_hotKeyGlobal;\n\tBOOL m_moveToGroupHotKeyGlobal;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CCopyProperties)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\npublic:\n\tbool m_bChangedText;\n\tlong m_lGroupChangedTo;\n\tvoid SetHideOnKillFocus(bool bVal)\t{ m_bHideOnKillFocus = bVal; }\n\tvoid SetHandleKillFocus(bool bVal)\t{ m_bHandleKillFocus = bVal; }\n\tvoid SetToTopMost(bool bVal)\t\t{ m_bSetToTopMost = bVal; }\n\n// Implementation\nprotected:\n\n\tlong m_lCopyID;\n\tARRAY m_DeletedData;\n\tbool m_bDeletedData;\n\tbool m_bHideOnKillFocus;\n\tCDialogResizer m_Resize;\n\tbool m_bInGroup;\n\tbool m_bHandleKillFocus;\n\tbool m_bSetToTopMost;\n\tCClip *m_pMemoryClip;\n\tCBrush m_brush;\n\tCClip m_clip;\n\tbool m_mouseDownOnCaption;\n\n\tvoid LoadDataIntoCClip(CClip &Clip);\n\tvoid LoadDataFromCClip(CClip &Clip);\n\tBOOL CheckGlobalHotKey(CClip &clip);\n\tBOOL CheckMoveToGroupGlobalHotKey(CClip &clip);\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CCopyProperties)\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnOK();\n\tafx_msg void OnDeleteCopyData();\n\tvirtual void OnCancel();\n\tafx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\n\tafx_msg void OnLbnSelchangeCopyData();\n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_COPYPROPERTIES_H__129FE1CD_D305_487A_B88C_BB01CD9C1BB7__INCLUDED_)\n"
        },
        {
          "name": "CopyThread.cpp",
          "type": "blob",
          "size": 5.7744140625,
          "content": "// CopyThread.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"CopyThread.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CCopyThread\n\nIMPLEMENT_DYNCREATE(CCopyThread, CWinThread)\n\nCCopyThread::CCopyThread():\n\tm_bQuit(false),\n\tm_bConfigChanged(false),\n\tm_pClipboardViewer(NULL),\n\tm_connectOnStartup(true)\n{\n\tm_bAutoDelete = false;\n}\n\nCCopyThread::~CCopyThread()\n{\n\tm_LocalConfig.DeleteTypes();\n\tm_SharedConfig.DeleteTypes();\n\tdelete m_pClipboardViewer;\n}\n\nBOOL CCopyThread::InitInstance()\n{\n\tm_pClipboardViewer = new CClipboardViewer(this);\n\tm_pClipboardViewer->m_connectOnStartup = m_connectOnStartup;\n\n\t// the window is created within this thread and therefore uses its message queue\n\tm_pClipboardViewer->Create();\n\n\treturn TRUE;\n}\n\nint CCopyThread::ExitInstance()\n{\n\tm_pClipboardViewer->Disconnect(false);\n\n\treturn CWinThread::ExitInstance();\n}\n\n// Called within Copy Thread:\nvoid CCopyThread::OnClipboardChange(CString activeWindow, CString activeWindowTitle)\n{\n\tLog(_T(\"OnClipboardChange - Start\"));\n\n\tSyncConfig(); // synchronize with the main thread's copy configuration\n\t\n\t// if we are told not to copy on change, then we have nothing to do.\n\tif(!m_LocalConfig.m_bCopyOnChange)\n\t\treturn;\n\t\n\tint groupId = theApp.GetActiveGroupId();\n\tif(groupId > -1)\n\t{\n\t\tLog(StrF(_T(\"LoadFromClipboard - loading clips into groupId: %d\"), groupId));\n\t}\n\t\n\tCClip* pClip = new CClip;\n\tpClip->m_copyReason = theApp.GetCopyReason();\n\n\tCOleDataObjectEx oleData;\n\tCClipTypes* pSupportedTypes = m_LocalConfig.m_pSupportedTypes;\n\n\t// If we are copying from a Ditto Buffer or use advanced option\n\t// then save all to the database, so when we paste this it will paste \n\t// just like you were using Ctrl-V\n\tstd::shared_ptr<CClipTypes> availableTypes;\n\tif (theApp.m_CopyBuffer.Active() || CGetSetOptions::GetSupportAllTypes())\n\t{\n\t\tavailableTypes = oleData.GetAvailableTypes();\n\t\tpSupportedTypes = availableTypes.get();\n\t}\n\n\tLog(_T(\"LoadFromClipboard - Before\"));\n\tint bResult = pClip->LoadFromClipboard(pSupportedTypes, true, activeWindow, activeWindowTitle);\n\tLog(_T(\"LoadFromClipboard - After\"));\n\n\tif(bResult == FALSE)\n\t{\n\t\tDWORD delay = CGetSetOptions::GetNoFormatsRetryDelay();\n\t\tif(delay > 0)\n\t\t{\n\t\t\tLog(StrF(_T(\"LoadFromClipboard didn't find any clips to save, sleeping %dms, then trying again\"), delay));\n\t\t\tSleep(delay);\n\n\t\t\tLog(_T(\"LoadFromClipboard #2 - Before\"));\n\t\t\tbResult = pClip->LoadFromClipboard(pSupportedTypes, activeWindow);\n\t\t\tLog(_T(\"LoadFromClipboard #2 - After\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog(_T(\"LoadFromClipboard didn't find any clips to save, retry setting is not set, not retrying\"));\n\t\t}\n\t}\n\n\tpSupportedTypes = NULL;\n\t\n\tif(bResult != TRUE)\n\t{\n\t\tdelete pClip;\n\t\treturn; // error\n\t}\n\n\tif(pClip != NULL &&\n\t\tgroupId > -1)\n\t{\n\t\tpClip->m_parentId = groupId;\n\t}\n\t\n\tif(m_LocalConfig.m_bAsyncCopy)\n\t\t::PostMessage(m_LocalConfig.m_hClipHandler, WM_CLIPBOARD_COPIED, (WPARAM)pClip, 0);\n\telse\n\t\t::SendMessage(m_LocalConfig.m_hClipHandler, WM_CLIPBOARD_COPIED, (WPARAM)pClip, 0);\n\n\tLog(_T(\"OnClipboardChange - End\"));\n}\n\nvoid CCopyThread::SyncConfig()\n{\n\t// atomic read\n\tif(m_bConfigChanged)\n\t{\n\t\tCClipTypes* pTypes = NULL;\n\t\t\n\t\tATL::CCritSecLock csLock(m_cs.m_sect);\n\t\t\n\t\tpTypes = m_LocalConfig.m_pSupportedTypes;\n\t\t\n\t\tm_LocalConfig = m_SharedConfig;\n\t\t\n\t\t// NULL means that it shouldn't have been sync'ed\n\t\tif( m_SharedConfig.m_pSupportedTypes == NULL )\n\t\t{\t// let m_LocalConfig keep its types\n\t\t\tm_LocalConfig.m_pSupportedTypes = pTypes; // undo sync\n\t\t\tpTypes = NULL; // nothing to delete\n\t\t}\n\t\telse\n\t\t\tm_SharedConfig.m_pSupportedTypes = NULL; // now owned by LocalConfig\n\t\t\n\t\t// delete old types\n\t\tif( pTypes )\n\t\t{\n\t\t\tdelete pTypes;\n\t\t}\n\t}\n}\n\nbool CCopyThread::IsClipboardViewerConnected()\n{\n\treturn m_pClipboardViewer->m_bIsConnected;\n}\n\nbool CCopyThread::GetConnectCV()\n{\n\treturn m_pClipboardViewer->GetConnect();\n}\n\nvoid CCopyThread::SetConnectCV(bool bConnect)\n{\n\tif(m_pClipboardViewer != NULL && m_pClipboardViewer->m_hWnd != NULL)\n\t{\n\t\t::SendMessage( m_pClipboardViewer->m_hWnd, WM_SETCONNECT, bConnect, 0 );\n\t}\n}\n\nvoid CCopyThread::SetSupportedTypes( CClipTypes* pTypes )\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tif(m_SharedConfig.m_pSupportedTypes)\n\t{\n\t\tdelete m_SharedConfig.m_pSupportedTypes;\n\t}\n\n\tm_SharedConfig.m_pSupportedTypes = pTypes;\n\tm_bConfigChanged = true;\n}\n\nHWND CCopyThread::SetClipHandler(HWND hWnd)\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tHWND hRet = m_SharedConfig.m_hClipHandler;\n\tm_SharedConfig.m_hClipHandler = hWnd;\n\tm_bConfigChanged = (hRet != hWnd);\n\n\treturn hRet;\n}\nHWND CCopyThread::GetClipHandler()\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tHWND hRet = m_SharedConfig.m_hClipHandler;\n\n\treturn hRet;\n}\nbool CCopyThread::SetCopyOnChange(bool bVal)\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tbool bRet = m_SharedConfig.m_bCopyOnChange;\n\tm_SharedConfig.m_bCopyOnChange = bVal;\n\tm_bConfigChanged = (bRet != bVal);\n\n\treturn bRet;\n}\nbool CCopyThread::GetCopyOnChange()\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tbool bRet = m_SharedConfig.m_bCopyOnChange;\n\n\treturn bRet;\n}\nbool CCopyThread::SetAsyncCopy(bool bVal)\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tbool bRet = m_SharedConfig.m_bAsyncCopy;\n\tm_SharedConfig.m_bAsyncCopy = bVal;\n\tm_bConfigChanged = (bRet != bVal);\n\n\treturn bRet;\n}\nbool CCopyThread::GetAsyncCopy()\n{\n\tATL::CCritSecLock csLock(m_cs.m_sect);\n\n\tbool bRet = m_SharedConfig.m_bAsyncCopy;\n\n\treturn bRet;\n}\n\nvoid CCopyThread::Init(CCopyConfig cfg)\n{\n\tASSERT(m_LocalConfig.m_pSupportedTypes == NULL);\n\tm_LocalConfig = m_SharedConfig = cfg;\n\t// let m_LocalConfig own the m_pSupportedTypes\n\tm_SharedConfig.m_pSupportedTypes = NULL;\n}\n\nbool CCopyThread::Quit()\n{\n\tm_bQuit = true;\n\tm_pClipboardViewer->PostMessage( WM_QUIT );\n\treturn CWinThread::PostThreadMessage( WM_QUIT, NULL, NULL ) != FALSE;\n}"
        },
        {
          "name": "CopyThread.h",
          "type": "blob",
          "size": 2.3544921875,
          "content": "#pragma once\n\n#include \"ClipboardViewer.h\"\n#include <afxmt.h>\n\nstruct CCopyConfig\n{\npublic:\n\t// WM_CLIPBOARD_COPIED is sent to this window when a copy is made.\n\tHWND        m_hClipHandler;\n\t// true to use PostMessage (asynchronous)\n\t// false to use SendMessage (synchronous)\n\tbool        m_bAsyncCopy;\n\t// true to create a copy of the clipboard contents when it changes\n\t// false to ignore changes in the clipboard\n\tbool        m_bCopyOnChange;\n\t// the supported types which are copied from the clipboard when it changes.\n\tCClipTypes* m_pSupportedTypes; // ONLY accessed from CopyThread\n\n\tCCopyConfig( HWND hClipHandler = NULL,\n\t             bool bAsyncCopy = false,\n\t\t\t\t bool bCopyOnChange = false,\n\t\t\t\t CClipTypes* pSupportedTypes = NULL )\n\t{\n\t\tm_hClipHandler = hClipHandler;\n\t\tm_bAsyncCopy = bAsyncCopy;\n\t\tm_bCopyOnChange = bCopyOnChange;\n\t\tm_pSupportedTypes = pSupportedTypes;\n\t}\n\n\tvoid DeleteTypes()\n\t{\n\t\tif( m_pSupportedTypes )\n\t\t{\n\t\t\tdelete m_pSupportedTypes;\n\t\t\tm_pSupportedTypes = NULL;\n\t\t}\n\t}\n};\n\nclass CCopyThread : public CWinThread\n{\n\tDECLARE_DYNCREATE(CCopyThread)\npublic:\n\tCCopyThread();\n\tvirtual ~CCopyThread();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n\tbool m_bQuit;\n\tbool m_connectOnStartup;\n\n\tCCriticalSection m_cs;\n\n\t// CopyThread Local (accessed from this CopyThread)\n\t// window owned by this thread which handles clipboard viewer messages\n\tCClipboardViewer*   m_pClipboardViewer; // permanent during lifetime of thread\n\tCCopyConfig         m_LocalConfig;\n\n\t// Called within Copy Thread:\n\tvoid OnClipboardChange(CString activeWindow, CString activeWindowTitle); // called by ClipboardViewer\n\tvoid SyncConfig(); // safely syncs m_LocalConfig with m_SharedConfig\n\n// Shared (use thread-safe access functions below)\n\tCCopyConfig         m_SharedConfig; \n\tbool                m_bConfigChanged; // true if m_SharedConfig was changed.\n\n\t// Called within Main thread:\n\tbool IsClipboardViewerConnected();\n\tbool GetConnectCV();\n\tvoid SetConnectCV(bool bConnect);\n\n\tvoid SetSupportedTypes(CClipTypes* pTypes); // CopyThread will own pTypes\n\tHWND SetClipHandler(HWND hWnd); // returns previous value\n\tHWND GetClipHandler();\n\tbool SetCopyOnChange(bool bVal); // returns previous value\n\tbool GetCopyOnChange();\n\tbool SetAsyncCopy(bool bVal); // returns previous value\n\tbool GetAsyncCopy();\n\n\tvoid Init(CCopyConfig cfg);\n\tbool Quit();\n\n\tvirtual BOOL InitInstance();\n\tvirtual int ExitInstance();\n};\n"
        },
        {
          "name": "Crc32Dynamic.cpp",
          "type": "blob",
          "size": 1.3193359375,
          "content": "#include \"stdafx.h\"\n#include \"Crc32Dynamic.h\"\n//#include <fstream.h>\n\nCCrc32Dynamic::CCrc32Dynamic() : m_pdwCrc32Table(NULL)\n{\n\tInit();\n}\n\nCCrc32Dynamic::~CCrc32Dynamic()\n{\n\tFree();\n}\n\nvoid CCrc32Dynamic::Init()\n{\n\t// This is the official polynomial used by CRC32 in PKZip.\n\t// Often times the polynomial shown reversed as 0x04C11DB7.\n\tDWORD dwPolynomial = 0xEDB88320;\n\tint i, j;\n\n\tFree();\n\tm_pdwCrc32Table = new DWORD[256];\n\n\tDWORD dwCrc;\n\tfor(i = 0; i < 256; i++)\n\t{\n\t\tdwCrc = i;\n\t\tfor(j = 8; j > 0; j--)\n\t\t{\n\t\t\tif(dwCrc & 1)\n\t\t\t\tdwCrc = (dwCrc >> 1) ^ dwPolynomial;\n\t\t\telse\n\t\t\t\tdwCrc >>= 1;\n\t\t}\n\t\tm_pdwCrc32Table[i] = dwCrc;\n\t}\n}\n\nvoid CCrc32Dynamic::Free()\n{\n\tdelete m_pdwCrc32Table;\n\tm_pdwCrc32Table = NULL;\n}\n\ninline void CCrc32Dynamic::CalcCrc32(const BYTE byte, DWORD &dwCrc32) const\n{\n\tdwCrc32 = ((dwCrc32) >> 8) ^ m_pdwCrc32Table[(byte) ^ ((dwCrc32) & 0x000000FF)];\n}\n\nDWORD CCrc32Dynamic::GenerateCrc32(const LPBYTE lpbArray, DWORD dSize, DWORD &dwCrc32)\n{\n\tDWORD dwErrorCode = NO_ERROR;\n\n//\tdwCrc32 = 0xFFFFFFFF;\n\n\ttry\n\t{\n\t\t// Is the table initialized?\n\t\tif(m_pdwCrc32Table == NULL)\n\t\t\tthrow 0;\n\n\t\tfor(DWORD i = 0; i < dSize; i++)\n\t\t{\n\t\t\tCalcCrc32(lpbArray[i], dwCrc32);\n\t\t}\n\t}\n\tcatch(...)\n\t{\n\t\t// An unknown exception happened, or the table isn't initialized\n\t\tdwErrorCode = ERROR_CRC;\n\t}\n\n//\tdwCrc32 = ~dwCrc32;\n\n\treturn dwErrorCode;\n}\n\n"
        },
        {
          "name": "Crc32Dynamic.h",
          "type": "blob",
          "size": 0.3349609375,
          "content": "#ifndef _CRC32DYNAMIC_H_\n#define _CRC32DYNAMIC_H_\n\nclass CCrc32Dynamic\n{\npublic:\n\tCCrc32Dynamic();\n\tvirtual ~CCrc32Dynamic();\n\n\tDWORD GenerateCrc32(const LPBYTE lpbArray, DWORD dSize, DWORD &dwCrc32);\n\nprotected:\n\tinline void CalcCrc32(const BYTE byte, DWORD &dwCrc32) const;\n\t\n\tvoid Init();\n\tvoid Free();\n\n\tDWORD *m_pdwCrc32Table;\n};\n\n#endif\n"
        },
        {
          "name": "CustomFriendsHelper.cpp",
          "type": "blob",
          "size": 3.021484375,
          "content": "#include \"stdafx.h\"\r\n#include \"CustomFriendsHelper.h\"\r\n#include \"CP_Main.h\"\r\n#include \"Shared\\Tokenizer.h\"\r\n#include \"Shared\\TextConvert.h\"\r\n\r\n\r\nCCustomFriendsHelper::CCustomFriendsHelper()\r\n{\r\n}\r\n\r\n\r\nCCustomFriendsHelper::~CCustomFriendsHelper()\r\n{\r\n}\r\n\r\nvoid CCustomFriendsHelper::Load()\r\n{\r\n\tm_list.clear();\r\n\r\n\tCString oldValues = CGetSetOptions::GetCustomSendToList();\r\n\r\n\tTiXmlDocument doc;\r\n\tCStringA xmlA = CTextConvert::UnicodeToUTF8(oldValues);\r\n\tdoc.Parse(xmlA);\r\n\r\n\tTiXmlElement *ItemHeader = doc.FirstChildElement(\"CustomFriends\");\r\n\r\n\tif (ItemHeader != NULL)\r\n\t{\r\n\t\tTiXmlElement *ItemElement = ItemHeader->FirstChildElement();\r\n\r\n\t\twhile (ItemElement)\r\n\t\t{\r\n\t\t\tName_Desc array_item;\r\n\t\t\tarray_item.m_name = ItemElement->Attribute(\"name\");\r\n\t\t\tarray_item.m_desc = ItemElement->Attribute(\"desc\");\r\n\t\t\t\r\n\t\t\tm_list.push_back(array_item);\r\n\r\n\t\t\tItemElement = ItemElement->NextSiblingElement();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CCustomFriendsHelper::Save()\r\n{\r\n\t/*CString values = _T(\"\");\r\n\r\n\tint count = m_list.size();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tCString lineValue = m_list[i];\r\n\t\tvalues += _T(\",\");\r\n\t\tvalues += lineValue;\r\n\t}*/\r\n\r\n\tTiXmlDocument doc;\r\n\r\n\tTiXmlElement* friendOuter = new TiXmlElement(\"CustomFriends\");\r\n\tdoc.LinkEndChild(friendOuter);\r\n\r\n\tfor (auto & listItem : m_list)\r\n\t{\r\n\t\tTiXmlElement* friendElement = new TiXmlElement(\"Friend\");\r\n\r\n\t\tCStringA nameA = CTextConvert::UnicodeToUTF8(listItem.m_name);\r\n\t\tfriendElement->SetAttribute(\"name\",  nameA);\r\n\r\n\t\tCStringA descA = CTextConvert::UnicodeToUTF8(listItem.m_desc);\r\n\t\tfriendElement->SetAttribute(\"desc\", descA);\r\n\r\n\t\tfriendOuter->LinkEndChild(friendElement);\r\n\t}\r\n\t\r\n\tTiXmlPrinter printer;\r\n\tprinter.SetLineBreak(\"\");\r\n\tdoc.Accept(&printer);\r\n\tCString cs = printer.CStr();\r\n\r\n\tCGetSetOptions::SetCustomSendToList(cs);\r\n}\r\n\r\nvoid CCustomFriendsHelper::AddToMenu(CMenu *pMenu)\r\n{\r\n\tbool addedItem = false;\r\n\tint id = 0;\r\n\tfor (auto & element : m_list) \r\n\t{\r\n\t\tif (addedItem == false)\r\n\t\t{\r\n\t\t\taddedItem = true;\r\n\t\t}\r\n\r\n\t\tCString cs;\r\n\t\tif (element.m_desc != _T(\"\"))\r\n\t\t{\r\n\t\t\tcs.Format(_T(\"(%s) - %s\"), element.m_name, element.m_desc);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcs.Format(_T(\"%s\"), element.m_name);\r\n\t\t}\r\n\r\n\t\tpMenu->AppendMenuW(MF_STRING, (CustomFriendStartId + id), cs);\r\n\t\tid++;\r\n\t}\r\n\r\n\tif (addedItem)\r\n\t{\r\n\t\tpMenu->AppendMenu(MF_SEPARATOR);\r\n\t}\r\n\t\r\n\tpMenu->AppendMenuW(MF_STRING, (CustomFriendStartId + PromptForCustom), theApp.m_Language.GetString(\"prompt_for_name\", \"Prompt For Name\"));\r\n}\r\n\r\nvoid CCustomFriendsHelper::Add(CString item, CString desc)\r\n{\r\n\tint count = (int)m_list.size();\r\n\tif (count < MaxCustomFriends)\r\n\t{\r\n\t\tName_Desc array_item;\r\n\t\tarray_item.m_name = item;\r\n\t\tarray_item.m_desc = desc;\r\n\t\tm_list.push_back(array_item);\r\n\t\tSave();\r\n\t}\r\n}\r\n\r\nCString CCustomFriendsHelper::GetSendTo(int id, bool &showDlg)\r\n{\r\n\tint index = id - CustomFriendStartId;\r\n\tif (index >= 0 && index < m_list.size())\r\n\t{\r\n\t\treturn m_list[index].m_name;\r\n\t}\r\n\r\n\tif (index == PromptForCustom)\r\n\t{\r\n\t\tshowDlg = true;\r\n\t}\r\n\r\n\treturn _T(\"\");\r\n}\r\n\r\nvoid CCustomFriendsHelper::ClearList()\r\n{\r\n\tm_list.clear();\r\n\tthis->Save();\r\n}"
        },
        {
          "name": "CustomFriendsHelper.h",
          "type": "blob",
          "size": 0.48046875,
          "content": "#pragma once\n\n#include <vector>\n\n#define CustomFriendStartId 4001\n#define MaxCustomFriends 99\n#define PromptForCustom 100\n\nclass CCustomFriendsHelper\n{\npublic:\n\tCCustomFriendsHelper();\n\t~CCustomFriendsHelper();\n\t\n\tvoid Add(CString item, CString desc);\n\tvoid Load();\n\tvoid Save();\n\tvoid AddToMenu(CMenu *pMenu);\n\tCString GetSendTo(int id, bool &showDlg);\n\tvoid ClearList();\n\nprotected:\n\n\tclass Name_Desc\n\t{\n\tpublic:\n\t\tCString m_name;\n\t\tCString m_desc;\n\t};\n\n\tstd::vector<Name_Desc> m_list;\n};\n\n"
        },
        {
          "name": "DIBAPI.H",
          "type": "blob",
          "size": 5.2958984375,
          "content": "/*    PortTool v2.2     dibapi.h          */\n\n/*\n *  dibapi.h\n *\n *  ** Win32 Version **\n *\n *  Copyright 1991-1998 Microsoft Corporation. All rights reserved\n *\n *  Header file for Device-Independent Bitmap (DIB) API.  Provides\n *  function prototypes and constants for the following functions:\n *\n *  BitmapToDIB()        - Creates a DIB from a bitmap\n *  ChangeBitmapFormat() - Changes a bitmap to a specified DIB format\n *  ChangeDIBFormat()    - Changes a DIB's BPP and/or compression format\n *  CopyScreenToBitmap() - Copies entire screen to a standard Bitmap\n *  CopyScreenToDIB()    - Copies entire screen to a DIB\n *  CopyWindowToBitmap() - Copies a window to a standard Bitmap\n *  CopyWindowToDIB()    - Copies a window to a DIB\n *  CreateDIBPalette()   - Creates a palette from a DIB\n *  CreateDIB()          - Creates a new DIB\n *  DestroyDIB()         - Deletes DIB when finished using it\n *  DIBError()           - Displays message box with error message\n *  DIBHeight()          - Gets the DIB height\n *  DIBNumColors()       - Calculates number of colors in the DIB's color table\n *  DIBToBitmap()        - Creates a bitmap from a DIB\n *  DIBWidth()           - Gets the DIB width\n *  FindDIBBits()        - Sets pointer to the DIB bits\n *  GetSystemPalette()   - Gets the current palette\n *  LoadDIB()            - Loads a DIB from a file\n *  PaintBitmap()        - Displays standard bitmap in the specified DC\n *  PaintDIB()           - Displays DIB in the specified DC\n *  PalEntriesOnDevice() - Gets the number of palette entries\n *  PaletteSize()        - Calculates the buffer size required by a palette\n *  PrintDIB()           - Prints the specified DIB\n *  PrintScreen()        - Prints the entire screen\n *  PrintWindow()        - Prints all or part of a window\n *  SaveDIB()            - Saves the specified dib in a file\n *\n * See the file DIBAPI.TXT for more information about these functions.\n *\n */\n\n\n/* Handle to a DIB */\n#define HDIB HANDLE\n\n\n/* Print Area selection */\n#define PW_WINDOW        1\n#define PW_CLIENT        2\n\n\n/* Print Options selection */\n#define PW_BESTFIT       1\n#define PW_STRETCHTOPAGE 2\n#define PW_SCALE         3\n\n/* DIB Macros*/\n\n// WIDTHBYTES performs DWORD-aligning of DIB scanlines.  The \"bits\"\n// parameter is the bit count for the scanline (biWidth * biBitCount),\n// and this macro returns the number of DWORD-aligned bytes needed \n// to hold those bits.\n\n#ifndef __AMVIDEO__\n#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)\n#endif\n\n/* Error constants */\nenum {\n      ERR_MIN = 0,                     // All error #s >= this value\n      ERR_NOT_DIB = 0,                 // Tried to load a file, NOT a DIB!\n      ERR_MEMORY,                      // Not enough memory!\n      ERR_READ,                        // Error reading file!\n      ERR_LOCK,                        // Error on a GlobalLock()!\n      ERR_OPEN,                        // Error opening a file!\n      ERR_CREATEPAL,                   // Error creating palette.\n      ERR_GETDC,                       // Couldn't get a DC.\n      ERR_CREATEDDB,                   // Error create a DDB.\n      ERR_STRETCHBLT,                  // StretchBlt() returned failure.\n      ERR_STRETCHDIBITS,               // StretchDIBits() returned failure.\n      ERR_SETDIBITSTODEVICE,           // SetDIBitsToDevice() failed.\n      ERR_STARTDOC,                    // Error calling StartDoc().\n      ERR_NOGDIMODULE,                 // Couldn't find GDI module in memory.\n      ERR_SETABORTPROC,                // Error calling SetAbortProc().\n      ERR_STARTPAGE,                   // Error calling StartPage().\n      ERR_NEWFRAME,                    // Error calling NEWFRAME escape.\n      ERR_ENDPAGE,                     // Error calling EndPage().\n      ERR_ENDDOC,                      // Error calling EndDoc().\n      ERR_SETDIBITS,                   // Error calling SetDIBits().\n      ERR_FILENOTFOUND,                // Error opening file in GetDib()\n      ERR_INVALIDHANDLE,               // Invalid Handle\n      ERR_DIBFUNCTION,                 // Error on call to DIB function\n      ERR_MAX                          // All error #s < this value\n     };\n\n\n\n/* Function prototypes */\n\nHDIB BitmapToDIB (HBITMAP hBitmap, HPALETTE hPal);\nHDIB ChangeBitmapFormat (HBITMAP\thBitmap,\n                                   WORD     wBitCount,\n                                   DWORD    dwCompression,\n                                   HPALETTE hPal);\nHDIB ChangeDIBFormat (HDIB hDIB, WORD wBitCount,\n                                DWORD dwCompression);\nHBITMAP CopyScreenToBitmap (LPRECT);\nHDIB CopyScreenToDIB (LPRECT);\nHBITMAP CopyWindowToBitmap (HWND, WORD);\nHDIB CopyWindowToDIB (HWND, WORD);\nHPALETTE CreateDIBPalette (HDIB);\nHDIB CreateDIB(DWORD, DWORD, WORD);\nWORD DestroyDIB (HDIB);\nvoid DIBError (int ErrNo);\nDWORD DIBHeight (LPSTR lpDIB);\nWORD DIBNumColors (LPSTR lpDIB);\nHBITMAP DIBToBitmap (HDIB hDIB, HPALETTE hPal);\nDWORD DIBWidth (LPSTR lpDIB);\nLPSTR FindDIBBits (LPSTR lpDIB);\nHPALETTE GetSystemPalette (void);\nHDIB LoadDIB (LPSTR);\nBOOL PaintBitmap (HDC, LPRECT, HBITMAP, LPRECT, HPALETTE);\nBOOL PaintDIB (HDC, LPRECT, HDIB, LPRECT, HPALETTE);\nint PalEntriesOnDevice (HDC hDC);\nWORD PaletteSize (LPSTR lpDIB);\nWORD PrintDIB (HDIB, WORD, WORD, WORD, LPSTR);\nWORD PrintScreen (LPRECT, WORD, WORD, WORD, LPSTR);\nWORD PrintWindow (HWND, WORD, WORD, WORD, WORD, LPSTR);\nWORD SaveDIB (HDIB, LPSTR);\n"
        },
        {
          "name": "DIBUTIL.CPP",
          "type": "blob",
          "size": 33.568359375,
          "content": "//**********************************************************************\n//\n//  dibutil.c\n//\n//  Source file for Device-Independent Bitmap (DIB) API.  Provides\n//  the following functions:\n//\n//  CreateDIB()         - Creates new DIB\n//  FindDIBBits()       - Sets pointer to the DIB bits\n//  DIBWidth()          - Gets the width of the DIB\n//  DIBHeight()         - Gets the height of the DIB\n//  PaletteSize()       - Calculates the buffer size required by a palette\n//  DIBNumColors()      - Calculates number of colors in the DIB's color table\n//  CreateDIBPalette()  - Creates a palette from a DIB\n//  DIBToBitmap()       - Creates a bitmap from a DIB\n//  BitmapToDIB()       - Creates a DIB from a bitmap\n//  PalEntriesOnDevice()- Gets the number of palette entries of a device\n//  GetSystemPalette()  - Returns a handle to the current system palette\n//  AllocRoomForDIB()   - Allocates memory for a DIB\n//  ChangeDIBFormat()   - Changes a DIB's BPP and/or compression format\n//  ChangeBitmapFormat()- Changes a bitmap to a DIB with specified BPP and\n//                        compression format\n//\n// Written by Microsoft Product Support Services, Developer Support.\n// Copyright 1991-1998 Microsoft Corporation. All rights reserved.\n//**********************************************************************\n\n#define     STRICT      // enable strict type checking\n\n#include \"stdafx.h\"\n#include <assert.h>\n#include \"dibapi.h\"\n#include \"dibutil.h\"\n#include <stdio.h>\n\n\n/*************************************************************************\n *\n * CreateDIB()\n *\n * Parameters:\n *\n * DWORD dwWidth    - Width for new bitmap, in pixels\n * DWORD dwHeight   - Height for new bitmap \n * WORD  wBitCount  - Bit Count for new DIB (1, 4, 8, or 24)\n *\n * Return Value:\n *\n * HDIB             - Handle to new DIB\n *\n * Description:\n *\n * This function allocates memory for and initializes a new DIB by\n * filling in the BITMAPINFOHEADER, allocating memory for the color\n * table, and allocating memory for the bitmap bits.  As with all\n * HDIBs, the header, colortable and bits are all in one contiguous\n * memory block.  This function is similar to the CreateBitmap() \n * Windows API.\n *\n * The colortable and bitmap bits are left uninitialized (zeroed) in the\n * returned HDIB.\n *\n *\n ************************************************************************/\n\nHDIB CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)\n{\n    BITMAPINFOHEADER    bi;             // bitmap header\n    LPBITMAPINFOHEADER  lpbi;           // pointer to BITMAPINFOHEADER\n    DWORD               dwLen;          // size of memory block\n    HDIB                hDIB;\n    DWORD               dwBytesPerLine; // Number of bytes per scanline\n\n\n    // Make sure bits per pixel is valid\n\n    if (wBitCount <= 1)\n        wBitCount = 1;\n    else if (wBitCount <= 4)\n        wBitCount = 4;\n    else if (wBitCount <= 8)\n        wBitCount = 8;\n    else if (wBitCount <= 24)\n        wBitCount = 24;\n    else\n        wBitCount = 4;  // set default value to 4 if parameter is bogus\n\n    // initialize BITMAPINFOHEADER\n\n    bi.biSize = sizeof(BITMAPINFOHEADER);\n    bi.biWidth = dwWidth;         // fill in width from parameter\n    bi.biHeight = dwHeight;       // fill in height from parameter\n    bi.biPlanes = 1;              // must be 1\n    bi.biBitCount = wBitCount;    // from parameter\n    bi.biCompression = BI_RGB;    \n    bi.biSizeImage = 0;           // 0's here mean \"default\"\n    bi.biXPelsPerMeter = 0;\n    bi.biYPelsPerMeter = 0;\n    bi.biClrUsed = 0;\n    bi.biClrImportant = 0;\n\n    // calculate size of memory block required to store the DIB.  This\n    // block should be big enough to hold the BITMAPINFOHEADER, the color\n    // table, and the bits\n\n    dwBytesPerLine = WIDTHBYTES(wBitCount * dwWidth);\n    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + (dwBytesPerLine * dwHeight);\n\n    // alloc memory block to store our bitmap\n\n    hDIB = GlobalAlloc(GHND, dwLen);\n\n    // major bummer if we couldn't get memory block\n\n    if (!hDIB)\n        return NULL;\n\n    // lock memory and get pointer to it\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);\n\n    // use our bitmap info structure to fill in first part of\n    // our DIB with the BITMAPINFOHEADER\n\n    *lpbi = bi;\n\n    // Since we don't know what the colortable and bits should contain,\n    // just leave these blank.  Unlock the DIB and return the HDIB.\n\n    GlobalUnlock(hDIB);\n\n    //return handle to the DIB\n\n    return hDIB;\n}\n\n\n/*************************************************************************\n *\n * FindDIBBits()\n *\n * Parameter:\n *\n * LPSTR lpDIB      - pointer to packed-DIB memory block\n *\n * Return Value:\n *\n * LPSTR            - pointer to the DIB bits\n *\n * Description:\n *\n * This function calculates the address of the DIB's bits and returns a\n * pointer to the DIB bits.\n *\n ************************************************************************/\n\nLPSTR FindDIBBits(LPSTR lpDIB)\n{\n   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));\n}\n\n\n/*************************************************************************\n *\n * DIBWidth()\n *\n * Parameter:\n *\n * LPSTR lpDIB      - pointer to packed-DIB memory block\n *\n * Return Value:\n *\n * DWORD            - width of the DIB\n *\n * Description:\n *\n * This function gets the width of the DIB from the BITMAPINFOHEADER\n * width field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER\n * width field if it is an OS/2-style DIB.\n *\n ************************************************************************/\n\n\nDWORD DIBWidth(LPSTR lpDIB)\n{\n    LPBITMAPINFOHEADER   lpbmi;  // pointer to a Win 3.0-style DIB\n    LPBITMAPCOREHEADER   lpbmc;  // pointer to an OS/2-style DIB\n\n    // point to the header (whether Win 3.0 and OS/2)\n\n    lpbmi = (LPBITMAPINFOHEADER)lpDIB;\n    lpbmc = (LPBITMAPCOREHEADER)lpDIB;\n\n    // return the DIB width if it is a Win 3.0 DIB\n\n    if (lpbmi->biSize == sizeof(BITMAPINFOHEADER))\n        return lpbmi->biWidth;\n    else  // it is an OS/2 DIB, so return its width\n        return (DWORD)lpbmc->bcWidth;\n}\n\n\n/*************************************************************************\n *\n * DIBHeight()\n *\n * Parameter:\n *\n * LPSTR lpDIB      - pointer to packed-DIB memory block\n *\n * Return Value:\n *\n * DWORD            - height of the DIB\n *\n * Description:\n *\n * This function gets the height of the DIB from the BITMAPINFOHEADER\n * height field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER\n * height field if it is an OS/2-style DIB.\n *\n ************************************************************************/\n\nDWORD DIBHeight(LPSTR lpDIB)\n{\n   LPBITMAPINFOHEADER   lpbmi;  // pointer to a Win 3.0-style DIB\n   LPBITMAPCOREHEADER   lpbmc;  // pointer to an OS/2-style DIB\n\n   // point to the header (whether OS/2 or Win 3.0\n\n   lpbmi = (LPBITMAPINFOHEADER)lpDIB;\n   lpbmc = (LPBITMAPCOREHEADER)lpDIB;\n\n    // return the DIB height if it is a Win 3.0 DIB\n    if (lpbmi->biSize == sizeof(BITMAPINFOHEADER))\n        return lpbmi->biHeight;\n    else  // it is an OS/2 DIB, so return its height\n        return (DWORD)lpbmc->bcHeight;\n}\n\n\n/*************************************************************************\n *\n * PaletteSize()\n *\n * Parameter:\n *\n * LPSTR lpDIB      - pointer to packed-DIB memory block\n *\n * Return Value:\n *\n * WORD             - size of the color palette of the DIB\n *\n * Description:\n *\n * This function gets the size required to store the DIB's palette by\n * multiplying the number of colors by the size of an RGBQUAD (for a\n * Windows 3.0-style DIB) or by the size of an RGBTRIPLE (for an OS/2-\n * style DIB).\n *\n ************************************************************************/\n\nWORD PaletteSize(LPSTR lpDIB)\n{\n    // calculate the size required by the palette\n    if (IS_WIN30_DIB (lpDIB))\n        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));\n    else\n        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));\n}\n\n\n/*************************************************************************\n *\n * DIBNumColors()\n *\n * Parameter:\n *\n * LPSTR lpDIB      - pointer to packed-DIB memory block\n *\n * Return Value:\n *\n * WORD             - number of colors in the color table\n *\n * Description:\n *\n * This function calculates the number of colors in the DIB's color table\n * by finding the bits per pixel for the DIB (whether Win3.0 or OS/2-style\n * DIB). If bits per pixel is 1: colors=2, if 4: colors=16, if 8: colors=256,\n * if 24, no colors in color table.\n *\n ************************************************************************/\n\nWORD DIBNumColors(LPSTR lpDIB)\n{\n    WORD wBitCount;  // DIB bit count\n\n    // If this is a Windows-style DIB, the number of colors in the\n    // color table can be less than the number of bits per pixel\n    // allows for (i.e. lpbi->biClrUsed can be set to some value).\n    // If this is the case, return the appropriate value.\n    \n\n    if (IS_WIN30_DIB(lpDIB))\n    {\n        DWORD dwClrUsed;\n\n        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;\n        if (dwClrUsed)\n\n        return (WORD)dwClrUsed;\n    }\n\n    // Calculate the number of colors in the color table based on\n    // the number of bits per pixel for the DIB.\n    \n    if (IS_WIN30_DIB(lpDIB))\n        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;\n    else\n        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;\n\n    // return number of colors based on bits per pixel\n\n    switch (wBitCount)\n    {\n        case 1:\n            return 2;\n\n        case 4:\n            return 16;\n\n        case 8:\n            return 256;\n\n        default:\n            return 0;\n    }\n}\n\n\n/*************************************************************************\n *\n * CreateDIBPalette()\n *\n * Parameter:\n *\n * HDIB hDIB        - specifies the DIB\n *\n * Return Value:\n *\n * HPALETTE         - specifies the palette\n *\n * Description:\n *\n * This function creates a palette from a DIB by allocating memory for the\n * logical palette, reading and storing the colors from the DIB's color table\n * into the logical palette, creating a palette from this logical palette,\n * and then returning the palette's handle. This allows the DIB to be\n * displayed using the best possible colors (important for DIBs with 256 or\n * more colors).\n *\n ************************************************************************/\n\nHPALETTE CreateDIBPalette(HDIB hDIB)\n{\n    LPLOGPALETTE        lpPal;          // pointer to a logical palette\n    HANDLE              hLogPal;        // handle to a logical palette\n    HPALETTE            hPal = NULL;    // handle to a palette\n    int                 i, wNumColors;  // loop index, number of colors in color table\n    LPSTR               lpbi;           // pointer to packed-DIB\n    LPBITMAPINFO        lpbmi;          // pointer to BITMAPINFO structure (Win3.0)\n    LPBITMAPCOREINFO    lpbmc;          // pointer to BITMAPCOREINFO structure (OS/2)\n    BOOL                bWinStyleDIB;   // Win3.0 DIB?\n\n    // if handle to DIB is invalid, return NULL\n\n    if (!hDIB)\n        return NULL;\n\n    // lock DIB memory block and get a pointer to it\n\n    lpbi = (LPSTR)GlobalLock(hDIB);\n\n    // get pointer to BITMAPINFO (Win 3.0)\n\n    lpbmi = (LPBITMAPINFO)lpbi;\n\n    // get pointer to BITMAPCOREINFO (OS/2 1.x)\n\n    lpbmc = (LPBITMAPCOREINFO)lpbi;\n\n    // get the number of colors in the DIB \n\n    wNumColors = DIBNumColors(lpbi);\n\n    // is this a Win 3.0 DIB?\n\n    bWinStyleDIB = IS_WIN30_DIB(lpbi);\n    if (wNumColors)\n    {\n        // allocate memory block for logical palette\n\n        hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) +\n                sizeof(PALETTEENTRY) * wNumColors);\n\n        // if not enough memory, clean up and return NULL\n\n        if (!hLogPal)\n        {\n            GlobalUnlock(hDIB);\n            return NULL;\n        }\n\n        // lock memory block and get pointer to it\n\n        lpPal = (LPLOGPALETTE)GlobalLock(hLogPal);\n\n        // set version and number of palette entries\n\n        lpPal->palVersion = PALVERSION;\n        lpPal->palNumEntries = wNumColors;\n\n        // store RGB triples (if Win 3.0 DIB) or RGB quads (if OS/2 DIB)\n        // into palette\n        \n        for (i = 0; i < wNumColors; i++)\n        {\n            if (bWinStyleDIB)\n            {\n                lpPal->palPalEntry[i].peRed = lpbmi->bmiColors[i].rgbRed;\n                lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;\n                lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;\n                lpPal->palPalEntry[i].peFlags = 0;\n            }\n            else\n            {\n                lpPal->palPalEntry[i].peRed = lpbmc->bmciColors[i].rgbtRed;\n                lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;\n                lpPal->palPalEntry[i].peBlue = lpbmc->bmciColors[i].rgbtBlue;\n                lpPal->palPalEntry[i].peFlags = 0;\n            }\n        }\n\n        // create the palette and get handle to it\n\n        hPal = CreatePalette(lpPal);\n\n        // if error getting handle to palette, clean up and return NULL\n\n        if (!hPal)\n        {\n            GlobalUnlock(hLogPal);\n            GlobalFree(hLogPal);\n            return NULL;\n        }\n    }\n\n    // clean up \n\n    GlobalUnlock(hLogPal);\n    GlobalFree(hLogPal);\n    GlobalUnlock(hDIB);\n\n    // return handle to DIB's palette\n    return hPal;\n}\n\n\n/*************************************************************************\n *\n * DIBToBitmap()\n *\n * Parameters:\n *\n * HDIB hDIB        - specifies the DIB to convert\n *\n * HPALETTE hPal    - specifies the palette to use with the bitmap\n *\n * Return Value:\n *\n * HBITMAP          - identifies the device-dependent bitmap\n *\n * Description:\n *\n * This function creates a bitmap from a DIB using the specified palette.\n * If no palette is specified, default is used.\n *\n * NOTE:\n *\n * The bitmap returned from this funciton is always a bitmap compatible\n * with the screen (e.g. same bits/pixel and color planes) rather than\n * a bitmap with the same attributes as the DIB.  This behavior is by\n * design, and occurs because this function calls CreateDIBitmap to\n * do its work, and CreateDIBitmap always creates a bitmap compatible\n * with the hDC parameter passed in (because it in turn calls\n * CreateCompatibleBitmap).\n *\n * So for instance, if your DIB is a monochrome DIB and you call this\n * function, you will not get back a monochrome HBITMAP -- you will\n * get an HBITMAP compatible with the screen DC, but with only 2\n * colors used in the bitmap.\n *\n * If your application requires a monochrome HBITMAP returned for a\n * monochrome DIB, use the function SetDIBits().\n *\n * Also, the DIBpassed in to the function is not destroyed on exit. This\n * must be done later, once it is no longer needed.\n *\n ************************************************************************/\n\nHBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal)\n{\n    LPSTR       lpDIBHdr, lpDIBBits;  // pointer to DIB header, pointer to DIB bits\n    HBITMAP     hBitmap;            // handle to device-dependent bitmap\n    HDC         hDC;                    // handle to DC\n    HPALETTE    hOldPal = NULL;    // handle to a palette\n\n    // if invalid handle, return NULL \n\n    if (!hDIB)\n        return NULL;\n\n    // lock memory block and get a pointer to it\n\n    lpDIBHdr = (LPSTR)GlobalLock(hDIB);\n\n    // get a pointer to the DIB bits\n\n    lpDIBBits = FindDIBBits(lpDIBHdr);\n\n    // get a DC \n\n    hDC = GetDC(NULL);\n    if (!hDC)\n    {\n        // clean up and return NULL\n\n        GlobalUnlock(hDIB);\n        return NULL;\n    }\n\n    // select and realize palette\n\n    if (hPal)\n        hOldPal = SelectPalette(hDC, hPal, FALSE);\n\n    RealizePalette(hDC);\n\n    // create bitmap from DIB info. and bits\n    hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)lpDIBHdr, CBM_INIT,\n            lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS);\n\n    // restore previous palette\n    if (hOldPal)\n        SelectPalette(hDC, hOldPal, FALSE);\n\n    // clean up\n    ReleaseDC(NULL, hDC);\n    GlobalUnlock(hDIB);\n\n    // return handle to the bitmap\n    return hBitmap;\n}\n\n\n/*************************************************************************\n *\n * BitmapToDIB()\n *\n * Parameters:\n *\n * HBITMAP hBitmap  - specifies the bitmap to convert\n *\n * HPALETTE hPal    - specifies the palette to use with the bitmap\n *\n * Return Value:\n *\n * HDIB             - identifies the device-dependent bitmap\n *\n * Description:\n *\n * This function creates a DIB from a bitmap using the specified palette.\n *\n ************************************************************************/\n\nHDIB BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal)\n{\n    BITMAP              bm;         // bitmap structure\n    BITMAPINFOHEADER    bi;         // bitmap header\n    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER\n    DWORD               dwLen;      // size of memory block\n    HANDLE              hDIB, h;    // handle to DIB, temp handle\n    HDC                 hDC;        // handle to DC\n    WORD                biBits;     // bits per pixel\n\n    // check if bitmap handle is valid\n\n    if (!hBitmap)\n        return NULL;\n\n    // fill in BITMAP structure, return NULL if it didn't work\n\n    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm))\n        return NULL;\n\n    // if no palette is specified, use default palette\n\n    if (hPal == NULL)\n        hPal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);\n\n    // calculate bits per pixel\n\n    biBits = bm.bmPlanes * bm.bmBitsPixel;\n\n    // make sure bits per pixel is valid\n\n    if (biBits <= 1)\n        biBits = 1;\n    else if (biBits <= 4)\n        biBits = 4;\n    else if (biBits <= 8)\n        biBits = 8;\n    else if (biBits <= 24)\n        biBits = 24;\n\telse\n\t\tbiBits = 32;\n\n    // initialize BITMAPINFOHEADER\n\n    bi.biSize = sizeof(BITMAPINFOHEADER);\n    bi.biWidth = bm.bmWidth;\n    bi.biHeight = bm.bmHeight;\n    bi.biPlanes = 1;\n    bi.biBitCount = biBits;\n    bi.biCompression = BI_RGB;\n    bi.biSizeImage = 0;\n    bi.biXPelsPerMeter = 0;\n    bi.biYPelsPerMeter = 0;\n    bi.biClrUsed = 0;\n    bi.biClrImportant = 0;\n\n    // calculate size of memory block required to store BITMAPINFO\n\n    dwLen = bi.biSize + PaletteSize((LPSTR)&bi);\n\n    // get a DC\n\n    hDC = GetDC(NULL);\n\n    // select and realize our palette\n\n    hPal = SelectPalette(hDC, hPal, FALSE);\n    RealizePalette(hDC);\n\n    // alloc memory block to store our bitmap\n\n    hDIB = GlobalAlloc(GHND, dwLen);\n\n    // if we couldn't get memory block\n\n    if (!hDIB)\n    {\n      // clean up and return NULL\n\n      SelectPalette(hDC, hPal, TRUE);\n      RealizePalette(hDC);\n      ReleaseDC(NULL, hDC);\n      return NULL;\n    }\n\n    // lock memory and get pointer to it\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);\n\n    /// use our bitmap info. to fill BITMAPINFOHEADER\n\n    *lpbi = bi;\n\n    // call GetDIBits with a NULL lpBits param, so it will calculate the\n    // biSizeImage field for us    \n\n    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi,\n        DIB_RGB_COLORS);\n\n    // get the info. returned by GetDIBits and unlock memory block\n\n    bi = *lpbi;\n    GlobalUnlock(hDIB);\n\n    // if the driver did not fill in the biSizeImage field, make one up \n    if (bi.biSizeImage == 0)\n        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;\n\n    // realloc the buffer big enough to hold all the bits\n\n    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage;\n\n    if (h = GlobalReAlloc(hDIB, dwLen, 0))\n        hDIB = h;\n    else\n    {\n        // clean up and return NULL\n\n        GlobalFree(hDIB);\n        hDIB = NULL;\n        SelectPalette(hDC, hPal, TRUE);\n        RealizePalette(hDC);\n        ReleaseDC(NULL, hDC);\n        return NULL;\n    }\n\n    // lock memory block and get pointer to it */\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);\n\n    // call GetDIBits with a NON-NULL lpBits param, and actualy get the\n    // bits this time\n\n    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi +\n            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi,\n            DIB_RGB_COLORS) == 0)\n    {\n        // clean up and return NULL\n\n        GlobalUnlock(hDIB);\n        hDIB = NULL;\n        SelectPalette(hDC, hPal, TRUE);\n        RealizePalette(hDC);\n        ReleaseDC(NULL, hDC);\n        return NULL;\n    }\n\n    bi = *lpbi;\n\n    // clean up \n    GlobalUnlock(hDIB);\n    SelectPalette(hDC, hPal, TRUE);\n    RealizePalette(hDC);\n    ReleaseDC(NULL, hDC);\n\n    // return handle to the DIB\n    return hDIB;\n}\n\n\n/*************************************************************************\n *\n * PalEntriesOnDevice()\n *\n * Parameter:\n *\n * HDC hDC          - device context\n *\n * Return Value:\n *\n * int              - number of palette entries on device\n *\n * Description:\n *\n * This function gets the number of palette entries on the specified device\n *\n ************************************************************************/\n\nint PalEntriesOnDevice(HDC hDC)\n{\n    int nColors;  // number of colors\n\n    // Find out the number of colors on this device.\n    \n    nColors = (1 << (GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES)));\n\n    assert(nColors);\n    return nColors;\n}\n\n\n/*************************************************************************\n *\n * GetSystemPalette()\n *\n * Parameters:\n *\n * None\n *\n * Return Value:\n *\n * HPALETTE         - handle to a copy of the current system palette\n *\n * Description:\n *\n * This function returns a handle to a palette which represents the system\n * palette.  The system RGB values are copied into our logical palette using\n * the GetSystemPaletteEntries function.  \n *\n ************************************************************************/\n\nHPALETTE GetSystemPalette(void)\n{\n    HDC hDC;                // handle to a DC\n    static HPALETTE hPal = NULL;   // handle to a palette\n    HANDLE hLogPal;         // handle to a logical palette\n    LPLOGPALETTE lpLogPal;  // pointer to a logical palette\n    int nColors;            // number of colors\n\n    // Find out how many palette entries we want.\n\n    hDC = GetDC(NULL);\n\n    if (!hDC)\n        return NULL;\n\n    nColors = PalEntriesOnDevice(hDC);   // Number of palette entries\n\n    // Allocate room for the palette and lock it.\n\n    hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + nColors *\n            sizeof(PALETTEENTRY));\n\n    // if we didn't get a logical palette, return NULL\n\n    if (!hLogPal)\n        return NULL;\n\n    // get a pointer to the logical palette\n\n    lpLogPal = (LPLOGPALETTE)GlobalLock(hLogPal);\n\n    // set some important fields\n\n    lpLogPal->palVersion = PALVERSION;\n    lpLogPal->palNumEntries = nColors;\n\n    // Copy the current system palette into our logical palette\n\n    GetSystemPaletteEntries(hDC, 0, nColors,\n            (LPPALETTEENTRY)(lpLogPal->palPalEntry));\n\n    // Go ahead and create the palette.  Once it's created,\n    // we no longer need the LOGPALETTE, so free it.    \n\n    hPal = CreatePalette(lpLogPal);\n\n    // clean up\n\n    GlobalUnlock(hLogPal);\n    GlobalFree(hLogPal);\n    ReleaseDC(NULL, hDC);\n\n    return hPal;\n}\n\n\n/*************************************************************************\n *\n * AllocRoomForDIB()\n *\n * Parameters:\n *\n * BITMAPINFOHEADER - bitmap info header stucture\n *\n * HBITMAP          - handle to the bitmap\n *\n * Return Value:\n *\n * HDIB             - handle to memory block\n *\n * Description:\n *\n *  This routine takes a BITMAPINOHEADER, and returns a handle to global\n *  memory which can contain a DIB with that header.  It also initializes\n *  the header portion of the global memory.  GetDIBits() is used to determine\n *  the amount of room for the DIB's bits.  The total amount of memory\n *  needed = sizeof(BITMAPINFOHEADER) + size of color table + size of bits.\n *\n ************************************************************************/\n\nHANDLE AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap)\n{\n    DWORD               dwLen;\n    HANDLE              hDIB;\n    HDC                 hDC;\n    LPBITMAPINFOHEADER  lpbi;\n    HANDLE              hTemp;\n\n    // Figure out the size needed to hold the BITMAPINFO structure\n    // (which includes the BITMAPINFOHEADER and the color table).\n\n    dwLen = bi.biSize + PaletteSize((LPSTR) &bi);\n    hDIB  = GlobalAlloc(GHND,dwLen);\n\n    // Check that DIB handle is valid\n\n    if (!hDIB)\n        return NULL;\n\n    // Set up the BITMAPINFOHEADER in the newly allocated global memory,\n    // then call GetDIBits() with lpBits = NULL to have it fill in the\n    // biSizeImage field for us.\n\n    lpbi  = (LPBITMAPINFOHEADER)GlobalLock(hDIB);\n    *lpbi = bi;\n\n    hDC   = GetDC(NULL);\n\n    GetDIBits(hDC, hBitmap, 0, (UINT) bi.biHeight, NULL, (LPBITMAPINFO)lpbi,\n            DIB_RGB_COLORS);\n    ReleaseDC(NULL, hDC);\n\n    // If the driver did not fill in the biSizeImage field,\n    // fill it in -- NOTE: this is a bug in the driver!\n    \n    if (lpbi->biSizeImage == 0)\n        lpbi->biSizeImage = WIDTHBYTES((DWORD)lpbi->biWidth *\n                lpbi->biBitCount) * lpbi->biHeight;\n\n    // Get the size of the memory block we need\n\n    dwLen = lpbi->biSize + PaletteSize((LPSTR) &bi) + lpbi->biSizeImage;\n\n    // Unlock the memory block\n\n    GlobalUnlock(hDIB);\n\n    // ReAlloc the buffer big enough to hold all the bits \n\n    if (hTemp = GlobalReAlloc(hDIB,dwLen,0))\n        return hTemp;\n    else\n    {\n        // Else free memory block and return failure\n\n        GlobalFree(hDIB);\n        return NULL;\n    }\n}\n\n\n/*************************************************************************\n *\n * ChangeDIBFormat()\n *\n * Parameter:\n *\n * HDIB             - handle to packed-DIB in memory\n *\n * WORD             - desired bits per pixel\n *\n * DWORD            - desired compression format\n *\n * Return Value:\n *\n * HDIB             - handle to the new DIB if successful, else NULL\n *\n * Description:\n *\n * This function will convert the bits per pixel and/or the compression\n * format of the specified DIB. Note: If the conversion was unsuccessful,\n * we return NULL. The original DIB is left alone. Don't use code like the\n * following:\n *\n *    hMyDIB = ChangeDIBFormat(hMyDIB, 8, BI_RLE4);\n *\n * The conversion will fail, but hMyDIB will now be NULL and the original\n * DIB will now hang around in memory. We could have returned the old\n * DIB, but we wanted to allow the programmer to check whether this\n * conversion succeeded or failed.\n *\n ************************************************************************/\n\nHDIB ChangeDIBFormat(HDIB hDIB, WORD wBitCount, DWORD dwCompression)\n{\n    HDC                hDC;             // Handle to DC\n    HBITMAP            hBitmap;         // Handle to bitmap\n    BITMAP             Bitmap;          // BITMAP data structure\n    BITMAPINFOHEADER   bi;              // Bitmap info header\n    LPBITMAPINFOHEADER lpbi;            // Pointer to bitmap info\n    HDIB               hNewDIB = NULL;  // Handle to new DIB\n    HPALETTE           hPal, hOldPal;   // Handle to palette, prev pal\n    WORD               DIBBPP, NewBPP;  // DIB bits per pixel, new bpp\n    DWORD              DIBComp, NewComp;// DIB compression, new compression\n\n    // Check for a valid DIB handle\n\n    if (!hDIB)\n        return NULL;\n\n    // Get the old DIB's bits per pixel and compression format\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);\n    DIBBPP = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;\n    DIBComp = ((LPBITMAPINFOHEADER)lpbi)->biCompression;\n    GlobalUnlock(hDIB);\n\n    // Validate wBitCount and dwCompression\n    // They must match correctly (i.e., BI_RLE4 and 4 BPP or\n    // BI_RLE8 and 8BPP, etc.) or we return failure\n    if (wBitCount == 0)\n    {\n        NewBPP = DIBBPP;\n        if ((dwCompression == BI_RLE4 && NewBPP == 4) ||\n                (dwCompression == BI_RLE8 && NewBPP == 8) ||\n                (dwCompression == BI_RGB))\n            NewComp = dwCompression;\n        else\n            return NULL;\n    }\n    else if (wBitCount == 1 && dwCompression == BI_RGB)\n    {\n        NewBPP = wBitCount;\n        NewComp = BI_RGB;\n    }\n    else if (wBitCount == 4)\n    {\n        NewBPP = wBitCount;\n        if (dwCompression == BI_RGB || dwCompression == BI_RLE4)\n            NewComp = dwCompression;\n        else\n            return NULL;\n    }\n    else if (wBitCount == 8)\n    {\n        NewBPP = wBitCount;\n        if (dwCompression == BI_RGB || dwCompression == BI_RLE8)\n            NewComp = dwCompression;\n        else\n            return NULL;\n    }\n    else if (wBitCount == 24 && dwCompression == BI_RGB)\n    {\n        NewBPP = wBitCount;\n        NewComp = BI_RGB;\n    }\n    else\n        return NULL;\n\n    // Save the old DIB's palette\n\n    hPal = CreateDIBPalette(hDIB);\n    if (!hPal)\n        return NULL;\n\n    // Convert old DIB to a bitmap\n\n    hBitmap = DIBToBitmap(hDIB, hPal);\n    if (!hBitmap)\n    {\n        DeleteObject(hPal);\n        return NULL;\n    }\n\n    // Get info about the bitmap\n    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap);\n\n    // Fill in the BITMAPINFOHEADER appropriately\n\n    bi.biSize               = sizeof(BITMAPINFOHEADER);\n    bi.biWidth              = Bitmap.bmWidth;\n    bi.biHeight             = Bitmap.bmHeight;\n    bi.biPlanes             = 1;\n    bi.biBitCount           = NewBPP;\n    bi.biCompression        = NewComp;\n    bi.biSizeImage          = 0;\n    bi.biXPelsPerMeter      = 0;\n    bi.biYPelsPerMeter      = 0;\n    bi.biClrUsed            = 0;\n    bi.biClrImportant       = 0;\n\n    // Go allocate room for the new DIB\n\n    hNewDIB = AllocRoomForDIB(bi, hBitmap);\n    if (!hNewDIB)\n        return NULL;\n\n    // Get a pointer to the new DIB\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB);\n\n    // Get a DC and select/realize our palette in it\n\n    hDC  = GetDC(NULL);\n    hOldPal = SelectPalette(hDC, hPal, FALSE);\n    RealizePalette(hDC);\n\n    // Call GetDIBits and get the new DIB bits\n\n    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi->biHeight,\n            (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi),\n            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS))\n    {\n        GlobalUnlock(hNewDIB);\n        GlobalFree(hNewDIB);\n        hNewDIB = NULL;\n    }\n\n    // Clean up and return\n\n    SelectPalette(hDC, hOldPal, TRUE);\n    RealizePalette(hDC);\n    ReleaseDC(NULL, hDC);\n\n    // Unlock the new DIB's memory block\n    if (hNewDIB)\n        GlobalUnlock(hNewDIB);\n\n    DeleteObject(hBitmap);\n    DeleteObject(hPal);\n\n    return hNewDIB;\n}\n\n\n/*************************************************************************\n *\n * ChangeBitmapFormat()\n *\n * Parameter:\n *\n * HBITMAP          - handle to a bitmap\n *\n * WORD             - desired bits per pixel\n *\n * DWORD            - desired compression format\n *\n * HPALETTE         - handle to palette\n *\n * Return Value:\n *\n * HDIB             - handle to the new DIB if successful, else NULL\n *\n * Description:\n *\n * This function will convert a bitmap to the specified bits per pixel\n * and compression format. The bitmap and it's palette will remain\n * after calling this function.\n *\n ************************************************************************/\n\nHDIB ChangeBitmapFormat(HBITMAP hBitmap, WORD wBitCount, DWORD dwCompression,\n        HPALETTE hPal)\n{\n    HDC                hDC;          // Screen DC\n    HDIB               hNewDIB=NULL; // Handle to new DIB\n    BITMAP             Bitmap;       // BITMAP data structure\n    BITMAPINFOHEADER   bi;           // Bitmap info. header\n    LPBITMAPINFOHEADER lpbi;         // Pointer to bitmap header\n    HPALETTE           hOldPal=NULL; // Handle to palette\n    WORD               NewBPP;       // New bits per pixel\n    DWORD              NewComp;      // New compression format\n\n    // Check for a valid bitmap handle\n\n    if (!hBitmap)\n        return NULL;\n\n    // Validate wBitCount and dwCompression\n    // They must match correctly (i.e., BI_RLE4 and 4 BPP or\n    // BI_RLE8 and 8BPP, etc.) or we return failure\n    \n    if (wBitCount == 0)\n    {\n        NewComp = dwCompression;\n        if (NewComp == BI_RLE4)\n            NewBPP = 4;\n        else if (NewComp == BI_RLE8)\n            NewBPP = 8;\n        else // Not enough info */\n            return NULL;\n    }\n    else if (wBitCount == 1 && dwCompression == BI_RGB)\n    {\n        NewBPP = wBitCount;\n        NewComp = BI_RGB;\n    }\n    else if (wBitCount == 4)\n    {\n        NewBPP = wBitCount;\n        if (dwCompression == BI_RGB || dwCompression == BI_RLE4)\n            NewComp = dwCompression;\n        else\n            return NULL;\n    }\n    else if (wBitCount == 8)\n    {\n        NewBPP = wBitCount;\n        if (dwCompression == BI_RGB || dwCompression == BI_RLE8)\n            NewComp = dwCompression;\n        else\n            return NULL;\n    }\n    else if (wBitCount == 24 && dwCompression == BI_RGB)\n    {\n        NewBPP = wBitCount;\n        NewComp = BI_RGB;\n    }\n    else\n        return NULL;\n\n    // Get info about the bitmap\n\n    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap);\n\n    // Fill in the BITMAPINFOHEADER appropriately\n\n    bi.biSize               = sizeof(BITMAPINFOHEADER);\n    bi.biWidth              = Bitmap.bmWidth;\n    bi.biHeight             = Bitmap.bmHeight;\n    bi.biPlanes             = 1;\n    bi.biBitCount           = NewBPP;\n    bi.biCompression        = NewComp;\n    bi.biSizeImage          = 0;\n    bi.biXPelsPerMeter      = 0;\n    bi.biYPelsPerMeter      = 0;\n    bi.biClrUsed            = 0;\n    bi.biClrImportant       = 0;\n\n    // Go allocate room for the new DIB\n\n    hNewDIB = AllocRoomForDIB(bi, hBitmap);\n    if (!hNewDIB)\n        return NULL;\n\n    // Get a pointer to the new DIB\n\n    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB);\n\n    // If we have a palette, get a DC and select/realize it\n\n    if (hPal)\n    {\n        hDC  = GetDC(NULL);\n        hOldPal = SelectPalette(hDC, hPal, FALSE);\n        RealizePalette(hDC);\n    }\n\n    // Call GetDIBits and get the new DIB bits\n\n    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi->biHeight, (LPSTR)lpbi +\n            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi,\n            DIB_RGB_COLORS))\n    {\n        GlobalUnlock(hNewDIB);\n        GlobalFree(hNewDIB);\n        hNewDIB = NULL;\n    }\n\n    // Clean up and return\n\n    if (hOldPal)\n    {\n        SelectPalette(hDC, hOldPal, TRUE);\n        RealizePalette(hDC);\n        ReleaseDC(NULL, hDC);\n    }\n\n    // Unlock the new DIB's memory block\n\n    if (hNewDIB)\n        GlobalUnlock(hNewDIB);\n\n    return hNewDIB;\n}\n"
        },
        {
          "name": "DIBUTIL.H",
          "type": "blob",
          "size": 0.6904296875,
          "content": "/*    PortTool v2.2     dibutil.h          */\n\n/*\n *  dibutil.h\n *\n *  Copyright 1991-1998 Microsoft Corporation. All rights reserved.\n *\n *  Header file for Device-Independent Bitmap (DIB) API.  Provides\n *  function prototypes and constants for the following functions:\n *\n *  AllocRoomForDIB()   - Allocates memory for a DIB\n *\n */\n\n\n/* DIB constants */\n#define PALVERSION   0x300\n\n/* DIB macros */\n#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))\n#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)\n#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)\n\n/* function prototypes */\nHANDLE          AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap);\n"
        },
        {
          "name": "DPI.cpp",
          "type": "blob",
          "size": 0.0380859375,
          "content": "#include \"stdafx.h\"\n#include \"DPI.h\"\n\n\n"
        },
        {
          "name": "DPI.h",
          "type": "blob",
          "size": 1.958984375,
          "content": "#pragma once\n#include <ShellScalingAPI.h>\n\n// Definition: relative pixel = 1 pixel at 96 DPI and scaled based on actual DPI.\nclass CDPI\n{\npublic:\n\tCDPI(HWND hwnd = NULL) : m_Initialized(false), m_dpi(96)\n\t{\n\t\tm_hWnd = hwnd;\n\t}\n\n\tvoid Update(int dpi) { m_dpi = dpi;  m_Initialized = true; }\n\n\t// Get screen DPI.\n\tint GetDPI() { Init(); return m_dpi; }\n\n\t// Convert between raw pixels and relative pixels.\n\tint Scale(int x) { Init(); return MulDiv(x, m_dpi, 96); }\n\tint UnScale(int x) { Init(); return MulDiv(x, 96, m_dpi); }\n\t\n\t// Invalidate any cached metrics.\n\tvoid Invalidate() { m_Initialized = false; }\n\n\tvoid SetHwnd(HWND hwnd) { m_hWnd = hwnd; m_Initialized = false; Init(); }\n\nprivate:\n\tvoid Init()\n\t{\n\t\tif (m_Initialized == false)\n\t\t{\n\t\t\tif (m_hWnd != NULL)\n\t\t\t{\n\t\t\t\tHMODULE hUser32 = LoadLibrary(_T(\"USER32.dll\"));\r\n\t\t\t\tif (hUser32)\r\n\t\t\t\t{\r\n\t\t\t\t\t//windows 10\r\n\t\t\t\t\ttypedef UINT(__stdcall *GetDpiForWindow)(HWND hwnd);\r\n\t\t\t\t\tGetDpiForWindow getDpi = (GetDpiForWindow)GetProcAddress(hUser32, \"GetDpiForWindow\");\r\n\t\t\t\t\tif (getDpi)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint dpi = getDpi(m_hWnd);\r\n\t\t\t\t\t\tthis->Update(dpi);\r\n\t\t\t\t\t\tm_Initialized = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//windows 8\r\n\t\t\t\t\t\tauto monitor = MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);\r\n\t\t\t\t\t\tHMODULE shCore = LoadLibrary(_T(\"Shcore.dll\"));\r\n\t\t\t\t\t\tif (shCore)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttypedef HRESULT(__stdcall *GetDpiForMonitor)(HMONITOR, UINT, UINT*, UINT*);\r\n\t\t\t\t\t\t\tGetDpiForMonitor monDpi = (GetDpiForMonitor)GetProcAddress(shCore, \"GetDpiForMonitor\");\r\n\t\t\t\t\t\t\tif (monDpi)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tUINT x = 0;\r\n\t\t\t\t\t\t\t\tUINT y = 0;\r\n\t\t\t\t\t\t\t\tmonDpi(monitor, MDT_EFFECTIVE_DPI, &x, &y);\r\n\r\n\t\t\t\t\t\t\t\tthis->Update(x);\r\n\t\t\t\t\t\t\t\tm_Initialized = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m_Initialized == false)\n\t\t\t{\n\t\t\t\tHDC hdc = GetDC(m_hWnd);\n\t\t\t\tif (hdc)\n\t\t\t\t{\n\t\t\t\t\tm_dpi = GetDeviceCaps(hdc, LOGPIXELSX);\n\t\t\t\t\tReleaseDC(NULL, hdc);\n\t\t\t\t\tm_Initialized = true;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\nprivate:\n\tbool m_Initialized;\n\tint m_dpi;\n\tHWND m_hWnd;\n};\n"
        },
        {
          "name": "DataTable.cpp",
          "type": "blob",
          "size": 5.271484375,
          "content": "// DataTable.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"DataTable.h\"\n#include \"DatabaseUtilities.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CDataTable\n\nIMPLEMENT_DYNAMIC(CDataTable, CDaoRecordset)\n\nCDataTable::CDataTable(CDaoDatabase* pdb)\n:CDaoRecordset(pdb)\n{\n\t//{{AFX_FIELD_INIT(CDataTable)\n\tm_lID = 0;\n\tm_lDataID = 0;\n\tm_strClipBoardFormat = _T(\"\");\n\tm_nFields = 4;\n\t//}}AFX_FIELD_INIT\n\tm_nDefaultType = dbOpenDynaset;\n}\n\n\nCString CDataTable::GetDefaultDBName()\n{\n\treturn GetDBName();\n}\n\nCString CDataTable::GetDefaultSQL()\n{\n\treturn _T(\"[Data]\");\n}\n\nvoid CDataTable::DoFieldExchange(CDaoFieldExchange* pFX)\n{\n\t//{{AFX_FIELD_MAP(CDataTable)\n\tpFX->SetFieldType(CDaoFieldExchange::outputColumn);\n\tDFX_Long(pFX, _T(\"[lID]\"), m_lID);\n\tDFX_Long(pFX, _T(\"[lDataID]\"), m_lDataID);\n\tDFX_Text(pFX, _T(\"[strClipBoardFormat]\"), m_strClipBoardFormat);\n\tDFX_LongBinary(pFX, _T(\"[ooData]\"), m_ooData);\n\t//}}AFX_FIELD_MAP\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CDataTable Member Functions\n\n// assigns the new autoincr ID to m_lID\nvoid CDataTable::AddNew()\n{\n\tCDaoRecordset::AddNew();\n\t// get the new, automatically assigned ID\n\tCOleVariant varID;\n\tGetFieldValue(\"lID\", varID);\n\tm_lID = varID.lVal;\n}\n\n\n// caller must free\n// takes m_ooData's HGLOBAL (do not update recset after calling this)\n// This should be faster than making a copy, but is this SAFE ??\nHGLOBAL CDataTable::TakeData()\n{\n\t// if there is nothing to take\n\tif( m_ooData.m_hData == 0 || m_ooData.m_dwDataLength == 0 )\n\t\treturn 0;\n\t\n\t// Unlock the handle that was locked by DaoLongBinaryAllocCallback()\n\t//  (through DFX_LongBinary()).\n\t::GlobalUnlock( m_ooData.m_hData );\n\t\n\t// we have to do a realloc in order to make the hGlobal m_dwDataLength\n\tHGLOBAL hGlobal = ::GlobalReAlloc(m_ooData.m_hData, m_ooData.m_dwDataLength, GMEM_MOVEABLE );\n\tif( !hGlobal || ::GlobalSize(hGlobal) == 0 )\n\t{\n\t\tTRACE0( GetErrorString(::GetLastError()) );\n\t\t//::_RPT0( _CRT_WARN, GetErrorString(::GetLastError()) );\n\t\tASSERT(FALSE);\n\t}\n\t// no longer valid\n\tm_ooData.m_hData = 0;\n\tm_ooData.m_dwDataLength = 0;\n\treturn hGlobal;\n}\n\n// this takes ownership of hgData, freeing m_ooData if necessary\n// This should be faster than making a copy, but is this SAFE?\n// looks like it is safe based upon:\n// http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support/kb/articles/q152/5/33.asp&NoWebContent=1\n// http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support/kb/articles/q119/7/65.asp&NoWebContent=1\nBOOL CDataTable::ReplaceData( HGLOBAL hgData, UINT len )\n{\n\t// make sure the given HGLOBAL is valid.\n\tif( hgData != NULL )\n\t{\n\t\tVERIFY( len > 0 );\n\t\tUINT size = ::GlobalSize( hgData );\n\t\tVERIFY( size >= len );\n\t\tVERIFY( IsValid(hgData) );\n\t}\n\telse\n\t\tVERIFY( len == 0 );\n\t\n\t// free the old HGLOBAL\n\tif( m_ooData.m_hData )\n\t\t::GlobalFree( m_ooData.m_hData );\n\t\n\tm_ooData.m_hData = hgData;\n\tm_ooData.m_dwDataLength = len;\n\t\n\t//Set the fields dirty\n\tSetFieldDirty(&m_ooData);\n\tSetFieldNull(&m_ooData,FALSE);\n\t\n\treturn TRUE;\n}\n\n// copies hgData into m_ooData\nBOOL CDataTable::SetData( HGLOBAL hgData, UINT size )\n{\n\tUINT unSize = (size < 0)? ::GlobalSize(hgData) : size;\n\t\n\t//Reallocate m_ooData.m_hData\n\tif(m_ooData.m_hData)\n\t\tm_ooData.m_hData = ::GlobalReAlloc(m_ooData.m_hData, unSize, GMEM_MOVEABLE);\n\telse\n\t\tm_ooData.m_hData = ::GlobalAlloc(GHND, unSize);\n\t\n\tm_ooData.m_dwDataLength = unSize;\n\t\n\t::CopyToGlobalHH( m_ooData.m_hData, hgData, unSize );\n\t\n\t//Set the fields dirty\n\tSetFieldDirty(&m_ooData);\n\tSetFieldNull(&m_ooData,FALSE);\n\t\n\treturn TRUE;\n}\n\n// allocates a new copy of the data\nHGLOBAL CDataTable::LoadData()\n{\n\tHGLOBAL hGlobal;\n\tULONG ulBufLen = m_ooData.m_dwDataLength; //Retrieve size of array\n\t\n\tif( ulBufLen == 0 || m_ooData.m_hData == 0 )\n\t\treturn 0;\n\t\n\thGlobal = NewGlobalH( m_ooData.m_hData, ulBufLen );\n\t\n\treturn hGlobal;\n}\n\nvoid CDataTable::CopyRec( CDataTable& src )\n{\n\tm_strClipBoardFormat = src.m_strClipBoardFormat;\n\tSetData( src.m_ooData.m_hData, src.m_ooData.m_dwDataLength );\n}\n\nBOOL CDataTable::DeleteAll()\n{\n\tBOOL bRet = FALSE;\n\ttry\n\t{\n\t\ttheApp.EnsureOpenDB();\n\t\ttheApp.m_pDatabase->Execute(\"DELETE * FROM Data\", dbFailOnError);\n\t\tbRet = TRUE;\n\t}\n\tcatch(CDaoException* e)\n\t{\n\t\tAfxMessageBox(e->m_pErrorInfo->m_strDescription);\n\t\te->Delete();\n\t}\n\t\n\treturn bRet;\n}\n\nvoid CDataTable::Open(LPCTSTR lpszFormat,...) \n{\n\tm_pDatabase = theApp.EnsureOpenDB();\n\t\n\tCString csText;\n\tva_list vlist;\n\t\n\tASSERT(AfxIsValidString(lpszFormat));\n\tva_start(vlist,lpszFormat);\n\tcsText.FormatV(lpszFormat,vlist);\n\tva_end(vlist);\n\t\n\tCDaoRecordset::Open(AFX_DAO_USE_DEFAULT_TYPE, csText, 0);\n}\n\nvoid CDataTable::Open(int nOpenType, LPCTSTR lpszSql, int nOptions) \n{\n\tm_pDatabase = theApp.EnsureOpenDB();\n\t\n\tCDaoRecordset::Open(nOpenType, lpszSql, nOptions);\n}\n\nBOOL CDataTable::DataEqual(HGLOBAL hgData)\n{\n\treturn ::CompareGlobalHH( hgData, m_ooData.m_hData, m_ooData.m_dwDataLength ) == 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CDataTable diagnostics\n\n#ifdef _DEBUG\nvoid CDataTable::AssertValid() const\n{\n\tCDaoRecordset::AssertValid();\n}\n\nvoid CDataTable::Dump(CDumpContext& dc) const\n{\n\tCDaoRecordset::Dump(dc);\n}\n#endif //_DEBUG\n"
        },
        {
          "name": "DataTable.h",
          "type": "blob",
          "size": 1.8583984375,
          "content": "#if !defined(AFX_DATATABLE_H__B70F6A02_C464_4FFE_91E8_E7F59765178F__INCLUDED_)\n#define AFX_DATATABLE_H__B70F6A02_C464_4FFE_91E8_E7F59765178F__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// DataTable.h : header file\n//\n\nclass CDataTable : public CDaoRecordset\n{\npublic:\n\tCDataTable(CDaoDatabase* pDatabase = NULL);\n\tDECLARE_DYNAMIC(CDataTable)\n\n// Field/Param Data\n\t//{{AFX_FIELD(CDataTable, CDaoRecordset)\n\tlong\tm_lID;\n\tlong\tm_lDataID;\n\tCString\tm_strClipBoardFormat;\n\tCLongBinary\tm_ooData;\n\t//}}AFX_FIELD\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CDataTable)\n\tpublic:\n\tvirtual CString GetDefaultDBName();\t\t// Default database name\n\tvirtual CString GetDefaultSQL();\t\t// Default SQL for Recordset\n\tvirtual void DoFieldExchange(CDaoFieldExchange* pFX);  // RFX support\n\tvirtual void Open(int nOpenType = AFX_DAO_USE_DEFAULT_TYPE, LPCTSTR lpszSql = NULL, int nOptions = 0);\n\t//}}AFX_VIRTUAL\npublic:\n\tvoid AddNew(); // assigns the new autoincr ID to m_lID\n\n\t// caller owns the returned HGLOBAL\n\t// takes m_ooData's HGLOBAL (do NOT update recset after calling this)\n\tHGLOBAL TakeData();\n\t// this takes ownership of hgData, freeing m_ooData if necessary\n\tBOOL ReplaceData( HGLOBAL hgData, UINT len );\n\n\t// copies hgData into m_ooData\n\t// if size < 0, ::GlobalSize(hgData) is used\n\tBOOL SetData(HGLOBAL hgData, UINT size = -1); \n\tHGLOBAL LoadData(); // allocates a new copy of the data\n\n\tBOOL DeleteAll();\n\tvoid Open(LPCTSTR lpszFormat,...);\n\tBOOL DataEqual(HGLOBAL hgData);\n\n\tvoid CopyRec( CDataTable& src );\n\n// Implementation\n#ifdef _DEBUG\n\tvirtual void AssertValid() const;\n\tvirtual void Dump(CDumpContext& dc) const;\n#endif\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_DATATABLE_H__B70F6A02_C464_4FFE_91E8_E7F59765178F__INCLUDED_)\n"
        },
        {
          "name": "DatabaseUtilities.cpp",
          "type": "blob",
          "size": 30.4033203125,
          "content": "// DatabaseUtilites.cpp: implementation of the CDatabaseUtilites class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"DatabaseUtilities.h\"\r\n#include \"ProcessPaste.h\"\r\n#include <io.h>\r\n#include \"Path.h\"\r\n#include \"zlib/zlib.h\"\r\n#include \"Shared/TextConvert.h\"\r\nusing namespace nsPath;\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nBOOL CreateBackup(CString csPath)\r\n{\r\n\tCString csOriginal;\r\n\tint count = 0;\r\n\t// create a backup of the existing database\r\n\tdo\r\n\t{\r\n\t\tcount++;\r\n\t\tcsOriginal = csPath + StrF(_T(\".%03d\"), count);\r\n\t\t// in case of some weird infinite loop\r\n\t\tif( count > 50 )\r\n\t\t{\r\n\t\t\tASSERT(0);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t} while( !::CopyFile(csPath, csOriginal, TRUE));\r\n\t\r\n\treturn TRUE;\r\n}\r\n\r\nCString GetDBName()\r\n{\r\n\treturn CGetSetOptions::GetDBPath();\r\n}\r\n\r\nCString GetOLDDefaultDBName()\r\n{\r\n\tCString csDefaultPath;\r\n\tLPMALLOC pMalloc;\r\n\r\n\tif(SUCCEEDED(::SHGetMalloc(&pMalloc))) \r\n\t{ \r\n\t\tLPITEMIDLIST pidlPrograms;\r\n\r\n\t\tSHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidlPrograms);\r\n\r\n\t\tTCHAR string[MAX_PATH];\r\n\t\tSHGetPathFromIDList(pidlPrograms, string);\r\n\r\n\t\tpMalloc->Free(pidlPrograms);\r\n\t\tpMalloc->Release();\r\n\r\n\t\tcsDefaultPath = string;\t\t\r\n\t\tcsDefaultPath += \"\\\\Ditto\\\\\";\r\n\r\n\t\tcsDefaultPath += \"DittoDB.mdb\";\r\n\t}\r\n\r\n\treturn csDefaultPath;\r\n}\r\n\r\nCString GetDefaultDBName()\r\n{\r\n\tCString csDefaultPath = _T(\"c:\\\\program files\\\\Ditto\\\\\");\r\n\t\r\n\t//If portable then default to the running path\r\n\tif(CGetSetOptions::GetIsPortableDitto())\r\n\t{\r\n\t\tcsDefaultPath.Empty();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcsDefaultPath = CGetSetOptions::GetAppDataPath();\r\n\t}\r\n\r\n\tCString csTempName = csDefaultPath + \"Ditto.db\";\r\n\tint i = 1;\r\n\twhile(FileExists(csTempName))\r\n\t{\r\n\t\tcsTempName.Format(_T(\"%sDitto_%d.db\"), csDefaultPath, i);\r\n\t\ti++;\r\n\t}\r\n\tcsDefaultPath = csTempName;\r\n\t\r\n\treturn csDefaultPath;\r\n}\r\n\r\nBOOL CheckDBExists(CString csDBPath)\r\n{\r\n\tCPath path(csDBPath);\r\n\r\n\t//If this is the first time running this version then convert the old database to the new db\r\n\tif(csDBPath.IsEmpty())\r\n\t{\r\n\t\tcsDBPath = GetDefaultDBName();\r\n\t\tCGetSetOptions::SetDBPath(csDBPath);\t\t\r\n\t}\r\n\r\n\tBOOL bRet = FALSE;\r\n\tif(FileExists(csDBPath) == FALSE)\r\n\t{\r\n\t\t//if the database is on a shared drive, network share or anything other than C:\\ than don't create a new db\r\n\t\t//Ditto will wait until that drive is available\r\n\t\tint len = 0;\r\n\t\tauto rootType = path.GetRootType(&len);\r\n\t\tauto driveLetter = path.GetDriveLetter();\r\n\r\n\t\tif (rootType == ERootType::rtServerShare ||\r\n\t\t\t((rootType == ERootType::rtDriveCur || rootType == rtDriveRoot) && driveLetter >= 'A' && driveLetter != 'C'))\r\n\t\t{\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\t//first try and create create a db at the same path that was selectd\r\n\t\tbRet = CreateDB(csDBPath);\r\n\r\n\t\t//if that didn't work then go back to the default location\r\n\t\tif (FileExists(csDBPath) == FALSE)\r\n\t\t{\r\n\t\t\tcsDBPath = GetDefaultDBName();\r\n\r\n\t\t\tnsPath::CPath FullPath(csDBPath);\r\n\t\t\tCString csPath = FullPath.GetPath().GetStr();\r\n\t\t\tif (csPath.IsEmpty() == false && FileExists(csDBPath) == FALSE)\r\n\t\t\t{\r\n\t\t\t\tCreateDirectory(csPath, NULL);\r\n\t\t\t}\r\n\r\n\t\t\tCGetSetOptions::SetDBPath(csDBPath);\r\n\r\n\t\t\tbRet = CreateDB(csDBPath);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(ValidDB(csDBPath) == FALSE)\r\n\t\t{\t\t\r\n\t\t\t//Db existed but was bad\r\n\t\t\tCString csMarkAsBad;\r\n\t\t\t\r\n\t\t\tcsMarkAsBad = csDBPath;\r\n\t\t\tcsMarkAsBad.Replace(_T(\".\"), _T(\"_BAD.\"));\r\n\t\t\t\r\n\t\t\tCString csPath = GetDefaultDBName();\r\n\t\t\t\r\n\t\t\tCString cs;\r\n\t\t\tcs.Format(_T(\"%s \\\"%s\\\",\\n\")\r\n\t\t\t\t_T(\"%s \\\"%s\\\",\\n\")\r\n\t\t\t\t_T(\"%s,\\n\")\r\n\t\t\t\t_T(\"\\\"%s\\\"\"),\r\n\t\t\t\ttheApp.m_Language.GetString(\"Database_Format\", \"Unrecognized Database Format\"),\r\n\t\t\t\tcsDBPath, \r\n\t\t\t\ttheApp.m_Language.GetString(\"File_Renamed\", \"the file will be renamed\"),\r\n\t\t\t\tcsMarkAsBad, \r\n\t\t\t\ttheApp.m_Language.GetString(\"New_Database\", \"and a new database will be created\"),\r\n\t\t\t\tcsPath);\r\n\t\t\t\r\n\t\t\tAfxMessageBox(cs);\r\n\t\t\t\r\n\t\t\tCFile::Rename(csDBPath, csMarkAsBad);\r\n\r\n\t\t\tcsDBPath = csPath;\r\n\t\t\t\r\n\t\t\tbRet = CreateDB(csDBPath);\r\n\r\n\t\t\tCGetSetOptions::SetDBPath(csDBPath);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbRet = TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tif(bRet)\r\n\t{\r\n\t\tbRet = OpenDatabase(csDBPath);\r\n\t}\r\n\t\r\n\treturn bRet;\r\n}\r\n\r\nBOOL IsDatabaseOpen()\r\n{\r\n\treturn theApp.m_db.IsDatabaseOpen();\r\n}\r\n\r\nBOOL OpenDatabase(CString dbPath)\r\n{\r\n\ttry\r\n\t{\r\n\t\tCPath path(dbPath);\r\n\r\n\t\tint len = 0;\r\n\t\tauto rootType = path.GetRootType(&len);\r\n\t\tauto driveLetter = path.GetDriveLetter();\r\n\r\n\t\ttheApp.m_databaseOnNetworkShare = false;\r\n\t\tif (rootType == ERootType::rtServerShare ||\r\n\t\t\t((rootType == ERootType::rtDriveCur || rootType == rtDriveRoot) && driveLetter >= 'A' && driveLetter != 'C'))\r\n\t\t{\r\n\t\t\ttheApp.m_databaseOnNetworkShare = true;\r\n\t\t}\r\n\t\t\r\n\r\n\t\ttheApp.m_db.close();\r\n\t\ttheApp.m_db.open(dbPath);\r\n\r\n\t\ttheApp.m_db.setBusyTimeout(CGetSetOptions::GetDbTimeout());\r\n\t\ttheApp.m_db.SetRegexCaseInsensitive(CGetSetOptions::GetRegexCaseInsensitive());\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nvoid ReOrderStickyClips(int parentID, CppSQLite3DB &db)\r\n{\r\n\ttry\r\n\t{\r\n\t\tLog(StrF(_T(\"Start of ReOrderStickyClips, ParentId %d\"), parentID));\r\n\r\n\t\t//groups where created with 0 in these fields, fix them up if they are 0\r\n\t\tif(parentID == -1)\r\n\t\t{\r\n\t\t\tdb.execDMLEx(_T(\"Update Main Set stickyClipOrder = -(2147483647) where bIsGroup = 1 AND stickyClipOrder = 0\"));\r\n\t\t\tdb.execDMLEx(_T(\"Update Main Set stickyClipGroupOrder = -(2147483647) where bIsGroup = 1 AND stickyClipGroupOrder = 0\"));\t\t\t\r\n\t\t}\r\n\r\n\t\tCppSQLite3Query qGroup = db.execQueryEx(_T(\"SELECT lID, mText FROM Main WHERE bIsGroup = 1 AND lParentID = %d\"), parentID);\r\n\r\n\t\tif (qGroup.eof() == false)\r\n\t\t{\r\n\t\t\twhile (!qGroup.eof())\r\n\t\t\t{\r\n\t\t\t\t//Get all sticky clips at the top level or group\r\n\t\t\t\tCString sql = StrF(_T(\"SELECT lID FROM Main WHERE stickyClipOrder <> -(2147483647) AND lParentID = %d ORDER BY stickyClipOrder DESC\"), parentID);\r\n\t\t\t\tif (parentID > -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tsql = StrF(_T(\"SELECT lID FROM Main WHERE stickyClipGroupOrder <> -(2147483647) AND lParentID = %d ORDER BY stickyClipGroupOrder DESC\"), parentID);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tCppSQLite3Query qSticky = db.execQueryEx(sql);\r\n\r\n\t\t\t\tint order = 1;\r\n\r\n\t\t\t\tif (qSticky.eof() == false)\r\n\t\t\t\t{\r\n\t\t\t\t\twhile (!qSticky.eof())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//set the new order\r\n\t\t\t\t\t\tif (parentID > -1)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdb.execDMLEx(_T(\"Update Main Set stickyClipGroupOrder = %d where lID = %d\"), order, qSticky.getIntField(_T(\"lID\")));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdb.execDMLEx(_T(\"Update Main Set stickyClipOrder = %d where lID = %d\"), order, qSticky.getIntField(_T(\"lID\")));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tqSticky.nextRow();\r\n\t\t\t\t\t\torder--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\r\n\r\n\t\t\t\tReOrderStickyClips(qGroup.getIntField(_T(\"lID\")), db);\r\n\r\n\t\t\t\tqGroup.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tLog(StrF(_T(\"End of ReOrderStickyClips, ParentId %d\"), parentID));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nBOOL ValidDB(CString csPath, BOOL bUpgrade)\r\n{\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3DB db;\r\n\t\tdb.open(csPath);\r\n\t\t\r\n\t\tdb.execQuery(_T(\"SELECT lID, lDate, mText, lShortCut, lDontAutoDelete, \")\r\n\t\t\t\t\t\t\t\t_T(\"CRC, bIsGroup, lParentID, QuickPasteText \")\r\n\t\t\t\t\t\t\t\t_T(\"FROM Main\"));\r\n\r\n\t\tdb.execQuery(_T(\"SELECT lID, lParentID, strClipBoardFormat, ooData FROM Data\"));\r\n\r\n\t\tdb.execQuery(_T(\"SELECT lID, TypeText FROM Types\"));\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"DROP TRIGGER delete_data_trigger\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"DROP TRIGGER delete_copy_buffer_trigger\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\t//This was added later so try to add each time and catch the exception here\r\n \t\ttry\r\n \t\t{\r\n\t\t\tdb.execDML(_T(\"CREATE TRIGGER delete_data_trigger BEFORE DELETE ON Main FOR EACH ROW\\n\")\r\n\t\t\t\t_T(\"BEGIN\\n\")\r\n\t\t\t\t\t_T(\"INSERT INTO MainDeletes VALUES(old.lID, datetime('now'));\\n\")\r\n\t\t\t\t_T(\"END\\n\"));\r\n \t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n \t\t\te.errorCode();\r\n \t\t}\r\n\r\n\t\t//This was added later so try to add each time and catch the exception here\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT lID, lClipID, lCopyBuffer FROM CopyBuffers\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\r\n\t\t\tdb.execDML(_T(\"CREATE TABLE CopyBuffers(\")\r\n\t\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t\t_T(\"lClipID INTEGER,\")\r\n\t\t\t\t_T(\"lCopyBuffer INTEGER)\"));\r\n\t\t}\r\n\r\n\t\t//This was added later so try to add each time and catch the exception here\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT clipId FROM MainDeletes\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\r\n\t\t\tdb.execDML(_T(\"CREATE TABLE MainDeletes(\")\r\n\t\t\t\t_T(\"clipID INTEGER,\")\r\n\t\t\t\t_T(\"modifiedDate)\"));\r\n\r\n\t\t\tdb.execDML(_T(\"CREATE TRIGGER MainDeletes_delete_data_trigger BEFORE DELETE ON MainDeletes FOR EACH ROW\\n\")\r\n\t\t\t\t_T(\"BEGIN\\n\")\r\n\t\t\t\t_T(\"DELETE FROM CopyBuffers WHERE lClipID = old.clipID;\\n\")\r\n\t\t\t\t_T(\"DELETE FROM Data WHERE lParentID = old.clipID;\\n\")\r\n\t\t\t\t_T(\"END\\n\"));\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"CREATE INDEX Main_ParentId on Main(lParentID DESC)\"));\r\n\t\t\tdb.execDML(_T(\"CREATE INDEX Main_IsGroup on Main(bIsGroup DESC)\"));\r\n\t\t\tdb.execDML(_T(\"CREATE INDEX Main_ShortCut on Main(lShortCut DESC)\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT clipOrder, clipGroupOrder FROM Main\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD clipOrder REAL\"));\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD clipGroupOrder REAL\"));\r\n\r\n\t\t\tdb.execDML(_T(\"Update Main set clipOrder = lDate, clipGroupOrder = lDate\"));\r\n\r\n\t\t\tdb.execDML(_T(\"CREATE INDEX Main_ClipOrder on Main(clipOrder DESC)\"));\r\n\t\t\tdb.execDML(_T(\"CREATE INDEX Main_ClipGroupOrder on Main(clipGroupOrder DESC)\"));\r\n\r\n\t\t\tdb.execDML(_T(\"DROP INDEX Main_Date\"));\r\n\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT globalShortCut FROM Main\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD globalShortCut INTEGER\"));\r\n\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT lastPasteDate FROM Main\"));\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD lastPasteDate INTEGER\"));\r\n\t\t\tdb.execDML(_T(\"Update Main set lastPasteDate = lDate\"));\r\n\t\t\tdb.execDMLEx(_T(\"Update Main set lastPasteDate = %d where lastPasteDate <= 0\"), (int)CTime::GetCurrentTime().GetTime());\r\n\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT stickyClipOrder FROM Main\"));\r\n\t\t}\r\n\t\tcatch (CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD stickyClipOrder REAL\"));\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD stickyClipGroupOrder REAL\"));\r\n\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\t\t\t\r\n\t\t\tCppSQLite3Query q = db.execQuery(_T(\"PRAGMA index_info(Main_NoGroup);\"));\r\n\t\t\tint count = 0;\r\n\t\t\twhile (q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\t\t\t\tq.nextRow();\r\n\t\t\t}\r\n\r\n\t\t\tif(count == 0)\r\n\t\t\t{\r\n\t\t\t\tdb.execDML(_T(\"Update Main set stickyClipOrder = -(2147483647) where stickyClipOrder IS NULL;\"));\r\n\t\t\t\tdb.execDML(_T(\"Update Main set stickyClipGroupOrder = -(2147483647) where stickyClipGroupOrder IS NULL;\"));\r\n\t\t\t\tdb.execDML(_T(\"Update Main set stickyClipOrder = -(2147483647) where stickyClipOrder = 0;\"));\r\n\t\t\t\tdb.execDML(_T(\"Update Main set stickyClipGroupOrder = -(2147483647) where stickyClipGroupOrder = 0;\"));\r\n\r\n\t\t\t\tdb.execDML(_T(\"CREATE INDEX Main_NoGroup ON Main(bIsGroup ASC, stickyClipOrder DESC, clipOrder DESC);\"));\r\n\t\t\t\tdb.execDML(_T(\"CREATE INDEX Main_InGroup ON Main(lParentId ASC, bIsGroup ASC, stickyClipGroupOrder DESC, clipGroupOrder DESC);\"));\r\n\t\t\t\tdb.execDML(_T(\"CREATE INDEX Data_ParentId_Format ON Data(lParentID COLLATE BINARY ASC, strClipBoardFormat COLLATE NOCASE ASC);\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdb.execQuery(_T(\"SELECT MoveToGroupShortCut FROM Main\"));\r\n\t\t\tdb.execQuery(_T(\"SELECT GlobalMoveToGroupShortCut FROM Main\"));\t\t\t\r\n\t\t}\r\n\t\tcatch(CppSQLite3Exception& e)\r\n\t\t{\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD MoveToGroupShortCut INTEGER\"));\r\n\t\t\tdb.execDML(_T(\"ALTER TABLE Main ADD GlobalMoveToGroupShortCut INTEGER\"));\t\t\t\r\n\r\n\t\t\te.errorCode();\r\n\t\t}\r\n\r\n\t\tdb.execDML(_T(\"DROP INDEX IF EXISTS Main_NoGroup\"));\r\n\t\tdb.execDML(_T(\"DROP INDEX IF EXISTS Main_InGroup\"));\r\n\t\tdb.execDML(_T(\"DROP INDEX IF EXISTS Main_ShortCut\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_TopLevelParentID ON Main(lParentId ASC, stickyClipOrder DESC, bIsGroup ASC, clipOrder DESC);\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_TopLevel ON Main(stickyClipOrder DESC, bIsGroup ASC, clipOrder DESC);\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_InGroup2 ON Main(lParentId ASC, stickyClipGroupOrder DESC, bIsGroup ASC, clipGroupOrder DESC);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_ShortCut2 on Main(lShortCut DESC, globalShortCut DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_MoveToGroup on Main(MoveToGroupShortCut DESC, GlobalMoveToGroupShortCut DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_CRC on Main(CRC ASC)\"));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(FALSE)\r\n\r\n\treturn TRUE;                                                     \r\n}\r\n\r\nBOOL BackupDB(CString dbPath, CString backupPath)\r\n{\r\n\tCRect r = DefaultMonitorRect();\r\n\tCPopup status((r.right - 500), r.bottom - 100, ::GetForegroundWindow());\r\n\r\n\tCString msg = theApp.m_Language.GetString(\"BackupDbMsg\", \"Backing up database\");\r\n\r\n\tstatus.Show(StrF(_T(\"Ditto - %s - %s\"), msg, backupPath));\r\n\r\n\tBOOL ret = FALSE;\r\n\r\n\tLog(StrF(_T(\"Start backing up db, from: %s to %s\"), dbPath, backupPath));\r\n\r\n\tCString errorMessage = _T(\"\");\r\n\r\n\ttry\r\n\t{\r\n\t\tCFile file;\r\n\t\tCFileException ex;\r\n\t\tif(file.Open(dbPath, CFile::modeRead|CFile::typeBinary|CFile::shareDenyNone, &ex))\r\n\t\t{\r\n\t\t\tULONGLONG fileSize = file.GetLength();\r\n\t\t\tULONGLONG totalReadSize = 0;\r\n\t\t\tint percentageComplete = 0;\r\n\t\t\tUINT readBytes = 0;\r\n\t\t\tchar *pBuffer = new char[65536];\r\n\t\t\tif(pBuffer != NULL)\r\n\t\t\t{\r\n\t\t\t\tgzFile f = gzopen(CTextConvert::UnicodeToAnsi(backupPath), \"w\");\r\n\t\t\t\t\r\n\t\t\t\tif(f != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treadBytes = file.Read(pBuffer, 65536);\r\n\t\t\t\t\t\tgzwrite(f, pBuffer, readBytes);\r\n\t\t\t\t\t\ttotalReadSize+= readBytes;\r\n\r\n\t\t\t\t\t\tint percent = (int)((totalReadSize * 100) / fileSize);\r\n\t\t\t\t\t\tif(percent != percentageComplete)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tpercentageComplete = percent;\r\n\t\t\t\t\t\t\tLog(StrF(_T(\"backing up db percent done: %d\"), percentageComplete));\r\n\r\n\t\t\t\t\t\t\tstatus.Show(StrF(_T(\"Ditto - %02d%% %s - %s\"), percentageComplete, msg, backupPath));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}while(readBytes >= 65536);\r\n\r\n\t\t\t\t\tgzclose(f);\r\n\r\n\t\t\t\t\tret = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfile.Close();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTCHAR szCause[255];\r\n\t\t\tex.GetErrorMessage(szCause, 255);\r\n\t\t\terrorMessage = szCause;\r\n\t\t}\r\n\t}\r\n\tcatch(...)\r\n\t{\r\n\r\n\t}\r\n\r\n\tif (errorMessage != _T(\"\"))\r\n\t{\r\n\t\tCString cs;\r\n\t\tcs.Format(_T(\"Restore ERROR: %s\"), errorMessage);\r\n\t\t::SendMessage(theApp.m_MainhWnd, WM_SHOW_ERROR_MSG, (WPARAM)cs.GetBuffer(cs.GetLength()), 0);\r\n\t\tcs.ReleaseBuffer();\r\n\t}\r\n\t\r\n\tLog(StrF(_T(\"Done restoring db, from: %s, errors: %s\"), backupPath, errorMessage));\r\n\r\n\treturn ret;\r\n}\r\n\r\nBOOL RestoreDB(CString backupPath)\r\n{\r\n\tCRect r = DefaultMonitorRect();\r\n\tCPopup status((r.right - 500), r.bottom - 100, ::GetForegroundWindow());\r\n\r\n\tCString msg = theApp.m_Language.GetString(\"RestoreDbMsg\", \"Restoring database\");\r\n\tstatus.Show(StrF(_T(\"Ditto - %s - %s\"), msg, backupPath));\r\n\r\n\tBOOL ret = FALSE;\r\n\r\n\tLog(StrF(_T(\"Start restoring db, from: %s\"), backupPath));\r\n\r\n\tCString errorMessage = _T(\"\");\r\n\r\n\tusing namespace nsPath;\r\n\tCPath backupPathPath(backupPath);\r\n\r\n\tCString tempPath = CGetSetOptions::GetPath(PATH_RESTORE_TEMP);\r\n\t\r\n\ttempPath += backupPathPath.GetName();\r\n\r\n\ttry\r\n\t{\r\n\t\tgzFile f = gzopen(CTextConvert::UnicodeToAnsi(backupPath), \"r\");\r\n\t\tif (f != NULL)\r\n\t\t{\r\n\t\t\tCFile file;\r\n\t\t\tCFileException ex;\r\n\t\t\tif (file.Open(tempPath, CFile::bufferWrite | CFile::modeCreate, &ex))\r\n\t\t\t{\r\n\t\t\t\tULONGLONG totalReadSize = 0;\r\n\t\t\t\tint readBytes = 0;\r\n\t\t\t\tchar *pBuffer = new char[65536];\r\n\t\t\t\tint percentageComplete = 0;\r\n\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\treadBytes = gzread(f, pBuffer, 65536);\r\n\t\t\t\t\tfile.Write(pBuffer, readBytes);\r\n\r\n\t\t\t\t\ttotalReadSize += readBytes;\r\n\r\n\t\t\t\t\tLog(StrF(_T(\"restoring db uncompressed bytes read: %d\"), readBytes));\r\n\r\n\t\t\t\t} while (readBytes >= 65536);\r\n\r\n\t\t\t\tfile.Close();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//errorMessage.Format(_T(\"Failed to open temp file %s, exception: %s\"), tempPath, ex.GetErrorMessage());\r\n\t\t\t}\r\n\r\n\t\t\tgzclose(f);\r\n\r\n\t\t\tif (ValidDB(tempPath, true))\r\n\t\t\t{\r\n\t\t\t\tCString defaultDbPath = GetDefaultDBName();\r\n\t\t\t\tCPath defaultDbPathPath(defaultDbPath);\r\n\r\n\t\t\t\tCString path = defaultDbPathPath.GetPath();\r\n\r\n\t\t\t\tbackupPathPath.RenameExtension(_T(\"db\"));\r\n\t\t\t\tCString newFullPath = path + backupPathPath.GetName();\r\n\r\n\t\t\t\tint i = 1;\r\n\t\t\t\twhile (FileExists(newFullPath))\r\n\t\t\t\t{\r\n\t\t\t\t\tnewFullPath.Format(_T(\"%s%s_%d.db\"), path, backupPathPath.GetTitle(), i);\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (MoveFile(tempPath, newFullPath))\r\n\t\t\t\t{\r\n\t\t\t\t\tCGetSetOptions::SetDBPath(newFullPath);\r\n\t\t\t\t\tOpenDatabase(newFullPath);\r\n\r\n\t\t\t\t\tret = TRUE;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\terrorMessage.Format(_T(\"Failed to copy file %s to %s\"), tempPath, newFullPath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\terrorMessage.Format(_T(\"Unpacked database is not a valid Ditto database\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\terrorMessage.Format(_T(\"Failed to open file %s\"), tempPath);\r\n\t\t}\r\n\t}\r\n\tcatch (CFileException* pEx)\r\n\t{\r\n\t\tTCHAR cause[255];\r\n\t\tpEx->GetErrorMessage(cause, 255);\r\n\t\terrorMessage.Format(_T(\"Exception: %s\"), cause);\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n\t\terrorMessage.Format(_T(\"Exception: ... catch\"));\r\n\t}\r\n\r\n\tif (errorMessage != _T(\"\"))\r\n\t{\r\n\t\tCString cs;\r\n\t\tcs.Format(_T(\"Restore ERROR: %s\"), errorMessage);\r\n\t\t::SendMessage(theApp.m_MainhWnd, WM_SHOW_ERROR_MSG, (WPARAM)cs.GetBuffer(cs.GetLength()), 0);\r\n\t\tcs.ReleaseBuffer();\r\n\t}\r\n\r\n\tLog(StrF(_T(\"Done restoring db, from: %s, error: %s\"), backupPath, errorMessage));\r\n\r\n\ttheApp.RefreshView();\r\n\r\n\treturn ret;\r\n}\r\n\r\nBOOL CreateDB(CString csFile)\r\n{\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3DB db;\r\n\t\tdb.open(csFile);\r\n\t\t\r\n\t\tdb.execDML(_T(\"PRAGMA auto_vacuum = 1\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE Main(\")\r\n\t\t\t\t\t\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t\t\t\t\t\t_T(\"lDate INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"mText TEXT, \")\r\n\t\t\t\t\t\t\t\t_T(\"lShortCut INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"lDontAutoDelete INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"CRC INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"bIsGroup INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"lParentID INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"QuickPasteText TEXT, \")\r\n\t\t\t\t\t\t\t\t_T(\"clipOrder REAL, \")\r\n\t\t\t\t\t\t\t\t_T(\"clipGroupOrder REAL, \")\r\n\t\t\t\t\t\t\t\t_T(\"globalShortCut INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"lastPasteDate INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"stickyClipOrder REAL, \")\r\n\t\t\t\t\t\t\t\t_T(\"stickyClipGroupOrder REAL, \")\r\n\t\t\t\t\t\t\t\t_T(\"MoveToGroupShortCut INTEGER, \")\r\n\t\t\t\t\t\t\t\t_T(\"GlobalMoveToGroupShortCut INTEGER);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE Data(\")\r\n\t\t\t\t\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t\t\t\t\t_T(\"lParentID INTEGER, \")\r\n\t\t\t\t\t\t\t_T(\"strClipBoardFormat TEXT, \")\r\n\t\t\t\t\t\t\t_T(\"ooData BLOB);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE Types(\")\r\n\t\t\t\t\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t\t\t\t\t_T(\"TypeText TEXT);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE UNIQUE INDEX Main_ID on Main(lID ASC)\"));\r\n\t\tdb.execDML(_T(\"CREATE UNIQUE INDEX Data_ID on Data(lID ASC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX Main_ClipOrder on Main(clipOrder DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX Main_ClipGroupOrder on Main(clipGroupOrder DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX Main_ParentId on Main(lParentID DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX Main_IsGroup on Main(bIsGroup DESC)\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TRIGGER delete_data_trigger BEFORE DELETE ON Main FOR EACH ROW\\n\")\r\n\t\t\t_T(\"BEGIN\\n\")\r\n\t\t\t\t_T(\"INSERT INTO MainDeletes VALUES(old.lID, datetime('now'));\\n\")\r\n\t\t\t_T(\"END\\n\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE CopyBuffers(\")\r\n\t\t\t_T(\"lID INTEGER PRIMARY KEY AUTOINCREMENT, \")\r\n\t\t\t_T(\"lClipID INTEGER, \")\r\n\t\t\t_T(\"lCopyBuffer INTEGER)\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TABLE MainDeletes(\")\r\n\t\t\t_T(\"clipID INTEGER,\")\r\n\t\t\t_T(\"modifiedDate)\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE TRIGGER MainDeletes_delete_data_trigger BEFORE DELETE ON MainDeletes FOR EACH ROW\\n\")\r\n\t\t\t_T(\"BEGIN\\n\")\r\n\t\t\t\t_T(\"DELETE FROM CopyBuffers WHERE lClipID = old.clipID;\\n\")\r\n\t\t\t\t_T(\"DELETE FROM Data WHERE lParentID = old.clipID;\\n\")\r\n\t\t\t_T(\"END\\n\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE INDEX Data_ParentId_Format ON Data(lParentID COLLATE BINARY ASC, strClipBoardFormat COLLATE NOCASE ASC);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_TopLevelParentID ON Main(lParentId ASC, stickyClipOrder DESC, bIsGroup ASC, clipOrder DESC);\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_TopLevel ON Main(stickyClipOrder DESC, bIsGroup ASC, clipOrder DESC);\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_InGroup2 ON Main(lParentId ASC, stickyClipGroupOrder DESC, bIsGroup ASC, clipGroupOrder DESC);\"));\r\n\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_ShortCut2 on Main(lShortCut DESC, globalShortCut DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_MoveToGroup on Main(MoveToGroupShortCut DESC, GlobalMoveToGroupShortCut DESC)\"));\r\n\t\tdb.execDML(_T(\"CREATE INDEX IF NOT EXISTS Main_CRC on Main(CRC ASC)\"));\r\n\r\n\t\tdb.close();\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(FALSE)\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CompactDatabase()\r\n{\r\n//\tif(!theApp.CloseDB())\r\n//\t\treturn FALSE;\r\n//\r\n//\tCString csDBName = GetDBName();\r\n//\tCString csTempDBName = csDBName;\r\n//\tcsTempDBName.Replace(\".mdb\", \"TempDBName.mdb\");\r\n//\t\r\n//\t//Compact the database\t\t\t\r\n//\ttry\r\n//\t{\r\n//\t\tCDaoWorkspace::CompactDatabase(csDBName, csTempDBName);//, dbLangGeneral, 0, \"andrew\");//DATABASE_PASSWORD);\r\n//\t}\r\n//\tcatch(CDaoException* e)\r\n//\t{\r\n//\t\tAfxMessageBox(e->m_pErrorInfo->m_strDescription);\r\n//\t\tDeleteFile(csTempDBName);\r\n//\t\te->Delete();\r\n//\t\treturn FALSE;\r\n//\t}\r\n//\tcatch(CMemoryException* e) \r\n//\t{\r\n//\t\tAfxMessageBox(\"Memory Exception\");\r\n//\t\tDeleteFile(csTempDBName);\r\n//\t\te->Delete();\r\n//\t\treturn FALSE;\r\n//\t}\r\n//\t\r\n//\t//Since compacting the database creates a new db delete the old one and replace it\r\n//\t//with the compacted db\r\n//\tif(DeleteFile(csDBName))\r\n//\t{\r\n//\t\ttry\r\n//\t\t{\r\n//\t\t\tCFile::Rename(csTempDBName, csDBName);\r\n//\t\t}\r\n//\t\tcatch(CFileException *e)\r\n//\t\t{\r\n//\t\t\te->ReportError();\r\n//\t\t\te->Delete();\r\n//\t\t\treturn FALSE;\r\n//\t\t}\r\n//\t}\r\n//\telse\r\n//\t\tAfxMessageBox(\"Error Compacting Database\");\r\n\t\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL RepairDatabase()\r\n{\r\n//\tif(!theApp.CloseDB())\r\n//\t\treturn FALSE;\r\n\t\r\n//\ttry\r\n//\t{\r\n//\t\tCDaoWorkspace::RepairDatabase(GetDBName());\r\n//\t}\r\n//\tcatch(CDaoException *e)\r\n//\t{\r\n//\t\tAfxMessageBox(e->m_pErrorInfo->m_strDescription);\r\n//\t\te->Delete();\r\n//\t\treturn FALSE;\r\n//\t}\r\n\t\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL RemoveOldEntries(bool checkIdleTime)\r\n{\r\n\tLog(StrF(_T(\"Beginning of RemoveOldEntries MaxEntries: %d - Keep days: %d\"), CGetSetOptions::GetMaxEntries(), CGetSetOptions::GetExpiredEntries()));\r\n\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3DB db;\r\n\t\tCString csDbPath = CGetSetOptions::GetDBPath();\r\n\t\tdb.open(csDbPath);\r\n\r\n\t\tif(CGetSetOptions::GetCheckForMaxEntries())\r\n\t\t{\r\n\t\t\tlong lMax = CGetSetOptions::GetMaxEntries();\r\n\t\t\tif(lMax >= 0)\r\n\t\t\t{\r\n\t\t\t\tCClipIDs IDs;\r\n\t\t\t\tint clipId;\r\n\t\t\t\t\r\n\t\t\t\tCppSQLite3Query q = db.execQueryEx(_T(\"SELECT lID, lShortCut, lParentID, lDontAutoDelete, stickyClipOrder, stickyClipGroupOrder FROM Main WHERE bIsGroup = 0 ORDER BY clipOrder DESC LIMIT -1 OFFSET %d\"), lMax);\r\n\t\t\t\twhile(q.eof() == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tint shortcut = q.getIntField(_T(\"lShortCut\"));\r\n\t\t\t\t\tint dontDelete = q.getIntField(_T(\"lDontAutoDelete\"));\r\n\t\t\t\t\tint parentId = q.getIntField(_T(\"lParentID\"));\r\n\t\t\t\t\tdouble stickyClipOrder = q.getFloatField(_T(\"stickyClipOrder\"));\r\n\t\t\t\t\tdouble stickyClipGroupOrder = q.getFloatField(_T(\"stickyClipGroupOrder\"));\r\n\r\n\t\t\t\t\t//Only delete entries that have no shortcut and don't have the flag set and aren't in groups and \r\n\t\t\t\t\tif(shortcut == 0 && \r\n\t\t\t\t\t\tdontDelete == 0 &&\r\n\t\t\t\t\t\tparentId <= 0 &&\r\n\t\t\t\t\t\tstickyClipOrder == -(2147483647) &&\r\n\t\t\t\t\t\tstickyClipGroupOrder == -(2147483647))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclipId = q.getIntField(_T(\"lID\"));\r\n\t\t\t\t\t\tIDs.Add(clipId);\r\n\t\t\t\t\t\tLog(StrF(_T(\"From MaxEntries - Deleting Id: %d\"), clipId));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tq.nextRow();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(IDs.GetCount() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tIDs.DeleteIDs(false, db);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(CGetSetOptions::GetCheckForExpiredEntries())\r\n\t\t{\r\n\t\t\tlong lExpire = CGetSetOptions::GetExpiredEntries();\r\n\t\t\t\r\n\t\t\tif(lExpire)\r\n\t\t\t{\r\n\t\t\t\tCTime now = CTime::GetCurrentTime();\r\n\t\t\t\tnow -= CTimeSpan(lExpire, 0, 0, 0);\r\n\t\t\t\t\r\n\t\t\t\tCClipIDs IDs;\r\n\t\t\t\t\r\n\t\t\t\tCppSQLite3Query q = db.execQueryEx(_T(\"SELECT lID FROM Main \")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"WHERE lastPasteDate < %d AND \")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"bIsGroup = 0 AND lShortCut = 0 AND lParentID <= 0 AND lDontAutoDelete = 0 AND stickyClipOrder = -(2147483647) AND stickyClipGroupOrder = -(2147483647)\"), (int)now.GetTime());\r\n\r\n\t\t\t\twhile(q.eof() == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tIDs.Add(q.getIntField(_T(\"lID\")));\r\n\r\n\t\t\t\t\tLog(StrF(_T(\"From Clips Expire - Deleting Id: %d\"), q.getIntField(_T(\"lID\"))));\r\n\r\n\t\t\t\t\tq.nextRow();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(IDs.GetCount() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tIDs.DeleteIDs(false, db);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint toDeleteCount = db.execScalar(_T(\"SELECT COUNT(clipID) FROM MainDeletes\"));\r\n\r\n\t\tLog(StrF(_T(\"Before Deleting emptied out data, count: %d, Idle Seconds: %f\"), toDeleteCount, IdleSeconds()));\r\n\r\n\t\t//Only delete 1 at a time, was finding that it was taking a long time to delete clips, locking the db and causing other queries\r\n\t\t//to lock up\r\n\t\tCppSQLite3Query q = db.execQueryEx(_T(\"SELECT * FROM MainDeletes LIMIT %d\"), CGetSetOptions::GetMainDeletesDeleteCount());\r\n\t\tint deleteCount = 0;\r\n\r\n\t\twhile(q.eof() == false)\r\n\t\t{\r\n\t\t\tdouble idleSeconds = IdleSeconds();\r\n\t\t\tif(checkIdleTime == false || idleSeconds > CGetSetOptions::GetIdleSecondsBeforeDelete())\r\n\t\t\t{\r\n\t\t\t\t//delete any data items sitting out there that the main table data was deleted\r\n\t\t\t\t//this was done to speed up deleted from the main table\r\n\t\t\t\tdeleteCount = db.execDMLEx(_T(\"DELETE FROM MainDeletes WHERE clipID=%d\"), q.getIntField(_T(\"clipID\")));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Computer has not been idle long enough to delete clips, Min Idle: %d, current Idle: %d\"), \r\n\t\t\t\t\t\t\t\t\t\t\t\tCGetSetOptions::GetIdleSecondsBeforeDelete(), idleSeconds));\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tq.nextRow();\r\n\t\t}\t\t\r\n\r\n\t\ttoDeleteCount = db.execScalar(_T(\"SELECT COUNT(clipID) FROM MainDeletes\"));\r\n\r\n\t\tLog(StrF(_T(\"After Deleting emptied out data rows, Count: %d, toDelete: %d\"), deleteCount, toDeleteCount));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\r\n\tLog(_T(\"End of RemoveOldEntries\"));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL DeleteNonUsedClips(bool fromAppWindow)\r\n{\r\n\tLog(_T(\"Start of delete all non used clips\"));\r\n\tCClipIDs IDs;\r\n\r\n\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE bIsGroup = 0 AND lShortCut = 0 AND lParentID <= 0 AND lDontAutoDelete = 0 AND stickyClipOrder = -(2147483647) AND stickyClipGroupOrder = -(2147483647)\"));\r\n\r\n\twhile (q.eof() == false)\r\n\t{\r\n\t\tIDs.Add(q.getIntField(_T(\"lID\")));\r\n\r\n\t\tLog(StrF(_T(\"From Clips DeleteNonUsedClips - Deleting Id: %d\"), q.getIntField(_T(\"lID\"))));\r\n\r\n\t\tq.nextRow();\r\n\t}\r\n\r\n\tint clipsDeleted = (int)IDs.GetCount();\r\n\tint deletedTableCount = 0;\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tIDs.DeleteIDs(fromAppWindow, theApp.m_db);\r\n\r\n\t\tdeletedTableCount = theApp.m_db.execDMLEx(_T(\"DELETE FROM MainDeletes\"));\r\n\t}\r\n\r\n\tLog(StrF(_T(\"End of delete all non used clips, clips deleted: %d, delete table delted: %d\"), clipsDeleted, deletedTableCount));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL EnsureDirectory(CString csPath)\r\n{\r\n\tTCHAR drive[_MAX_DRIVE];\r\n\tTCHAR dir[_MAX_DIR];\r\n\tTCHAR fname[_MAX_FNAME];\r\n\tTCHAR ext[_MAX_EXT];\r\n\t\r\n\tSPLITPATH(csPath, drive, dir, fname, ext);\r\n\t\r\n\tCString csDir(drive);\r\n\tcsDir += dir;\r\n\t\r\n\tif(FileExists(csDir) == FALSE)\r\n\t{\r\n\t\tif(CreateDirectory(csDir, NULL))\r\n\t\t\treturn TRUE;\r\n\t}\r\n\telse\r\n\t\treturn TRUE;\r\n\t\r\n\treturn FALSE;\r\n}\r\n\r\n// BOOL RunZippApp(CString csCommandLine)\r\n// {\r\n// \tCString csLocalPath = GETENV(_T(\"U3_HOST_EXEC_PATH\"));\r\n// \tFIX_CSTRING_PATH(csLocalPath);\r\n// \r\n// \tCString csZippApp = GETENV(_T(\"U3_DEVICE_EXEC_PATH\"));\r\n// \tFIX_CSTRING_PATH(csZippApp);\r\n// \tcsZippApp += \"7za.exe\";\r\n// \r\n// \tcsZippApp += \" \";\r\n// \tcsZippApp += csCommandLine;\r\n// \r\n// \tLog(csZippApp);\r\n// \r\n// \tSTARTUPINFO\t\t\tStartupInfo;\r\n// \tPROCESS_INFORMATION\tProcessInformation;\r\n// \r\n// \tZeroMemory(&StartupInfo, sizeof(StartupInfo));\r\n// \tStartupInfo.cb = sizeof(StartupInfo);\r\n// \tZeroMemory(&ProcessInformation, sizeof(ProcessInformation));\r\n// \r\n// \tStartupInfo.dwFlags = STARTF_USESHOWWINDOW;\r\n// \tStartupInfo.wShowWindow = SW_HIDE;\r\n// \r\n// \tBOOL bRet = CreateProcess(NULL, csZippApp.GetBuffer(csZippApp.GetLength()), NULL, NULL, FALSE,\r\n// \t\t\tCREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS, NULL, csLocalPath,\r\n// \t\t\t&StartupInfo, &ProcessInformation);\r\n// \r\n// \tif(bRet)\r\n// \t{\r\n// \t\tWaitForSingleObject(ProcessInformation.hProcess, INFINITE);\r\n// \r\n// \t\tDWORD dwExitCode;\r\n// \t\tGetExitCodeProcess(ProcessInformation.hProcess, &dwExitCode);\r\n// \r\n// \t\tCString cs;\r\n// \t\tcs.Format(_T(\"Exit code from unzip = %d\"), dwExitCode);\r\n// \t\tLog(cs);\r\n// \r\n// \t\tif(dwExitCode != 0)\r\n// \t\t{\r\n// \t\t\tbRet = FALSE;\r\n// \t\t}\r\n// \t}\r\n// \telse\r\n// \t{\r\n// \t\tbRet = FALSE;\r\n// \t\tLog(_T(\"Create Process Failed\"));\r\n// \t}\r\n// \r\n// \tcsZippApp.ReleaseBuffer();\r\n// \r\n// \treturn bRet;\r\n// }\r\n\r\n// BOOL CopyDownDatabase()\r\n// {\r\n// \tBOOL bRet = FALSE;\r\n// \r\n// \tCString csZippedPath = GETENV(_T(\"U3_APP_DATA_PATH\"));\r\n// \tFIX_CSTRING_PATH(csZippedPath);\r\n// \t\r\n// \tCString csUnZippedPath = csZippedPath;\r\n// \tcsUnZippedPath += \"Ditto.db\";\r\n// \r\n// \tcsZippedPath += \"Ditto.7z\";\r\n// \t\r\n// \tCString csLocalPath = GETENV(_T(\"U3_HOST_EXEC_PATH\"));\r\n// \tFIX_CSTRING_PATH(csLocalPath);\r\n// \r\n// \tif(FileExists(csZippedPath))\r\n// \t{\r\n// \t\tCString csCommandLine;\r\n// \r\n// \t\t//e = extract\r\n// \t\t//surround command line arguments with quotes\r\n// \t\t//-aoa = overight files with extracted files\r\n// \r\n// \t\tcsCommandLine += \"e \";\r\n// \t\tcsCommandLine += \"\\\"\";\r\n// \t\tcsCommandLine += csZippedPath;\r\n// \t\tcsCommandLine += \"\\\"\";\r\n// \t\tcsCommandLine += \" -o\";\r\n// \t\tcsCommandLine += \"\\\"\";\r\n// \t\tcsCommandLine += csLocalPath;\r\n// \t\tcsCommandLine += \"\\\"\";\r\n// \t\tcsCommandLine += \" -aoa\";\r\n// \r\n// \t\tbRet = RunZippApp(csCommandLine);\r\n// \r\n// \t\tcsLocalPath += \"Ditto.db\";\r\n// \t}\r\n// \telse if(FileExists(csUnZippedPath))\r\n// \t{\r\n// \t\tcsLocalPath += \"Ditto.db\";\r\n// \t\tbRet = CopyFile(csUnZippedPath, csLocalPath, FALSE);\r\n// \t}\r\n// \r\n// \tif(FileExists(csLocalPath) == FALSE)\r\n// \t{\r\n// \t\tLog(_T(\"Failed to copy files from device zip file\"));\r\n// \t}\r\n// \r\n// \tCGetSetOptions::nLastDbWriteTime = GetLastWriteTime(csLocalPath);\r\n// \r\n// \treturn bRet;\r\n// }\r\n\r\n//BOOL CopyUpDatabase()\r\n//{\r\n//\tCStringA csZippedPath = \"C:\\\\\";//getenv(\"U3_APP_DATA_PATH\");\r\n//\tFIX_CSTRING_PATH(csZippedPath);\r\n//\tcsZippedPath += \"Ditto.zip\";\r\n\r\n//\tCStringA csLocalPath = GetDBName();//getenv(\"U3_HOST_EXEC_PATH\");\r\n//\t//FIX_CSTRING_PATH(csLocalPath);\r\n//\t//csLocalPath += \"Ditto.db\";\r\n//\r\n//\tCZipper Zip;\r\n//\r\n//\tif(Zip.OpenZip(csZippedPath))\r\n//\t{\r\n//\t\tZip.AddFileToZip(csLocalPath);\r\n//\t}\r\n//\r\n//\treturn TRUE;\r\n//}"
        },
        {
          "name": "DatabaseUtilities.h",
          "type": "blob",
          "size": 1.2392578125,
          "content": "// DatabaseUtilites.h: interface for the CDatabaseUtilites class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(AFX_DATABASEUTILITES_H__039F53EB_228F_4640_8009_3D2B1FF435D4__INCLUDED_)\r\n#define AFX_DATABASEUTILITES_H__039F53EB_228F_4640_8009_3D2B1FF435D4__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n\r\n#include \"DittoPopupWindow.h\"\r\n#include \"sqlite/CppSQLite3.h\"\r\n\r\n#define DEFAULT_DB_NAME \"Ditto.db\"\r\n#define ERROR_OPENING_DATABASE\t2\r\n\r\nBOOL CreateBackup(CString csPath);\r\nCString GetDBName();\r\nCString GetDefaultDBName();\r\nBOOL OpenDatabase(CString csDB);\r\nBOOL IsDatabaseOpen();\r\n\r\nBOOL CheckDBExists(CString csDBPath);\r\nBOOL ValidDB(CString csPath, BOOL bUpgrade=TRUE);\r\nBOOL CreateDB(CString csPath);\r\n\r\nBOOL CompactDatabase();\r\nBOOL RepairDatabase();\r\nBOOL RemoveOldEntries(bool checkIdleTime);\r\nBOOL DeleteNonUsedClips(bool fromAppWindow);\r\n\r\nBOOL EnsureDirectory(CString csPath);\r\n\r\nBOOL BackupDB(CString dbPath, CString backupPath);\r\nBOOL RestoreDB(CString backupPath);\r\n\r\nvoid ReOrderStickyClips(int parentID, CppSQLite3DB &db);\r\n\r\n//BOOL CopyDownDatabase();\r\n//BOOL CopyUpDatabase();\r\n\r\n#endif // !defined(AFX_DATABASEUTILITES_H__039F53EB_228F_4640_8009_3D2B1FF435D4__INCLUDED_)\r\n"
        },
        {
          "name": "Debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "DeclareDPIAware.manifest",
          "type": "blob",
          "size": 0.60546875,
          "content": "<assembly manifestVersion=\"1.0\" xmlns=\"urn:schemas-microsoft-com:asm.v1\" xmlns:asmv3=\"urn:schemas-microsoft-com:asm.v3\">\n \n  <asmv3:application>\n    <asmv3:windowsSettings>\n      <dpiAware xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\">true/pm</dpiAware>\n      <!-- fallback for Windows 7 and 8 -->\n      <dpiAwareness xmlns=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">permonitorv2,permonitor</dpiAwareness>\n      <!-- falls back to per-monitor if per-monitor v2 is not supported -->\n      \n      <!-- enables GDI DPI scaling -->\n    </asmv3:windowsSettings>\n  </asmv3:application>\n</assembly>"
        },
        {
          "name": "DeleteClipData.cpp",
          "type": "blob",
          "size": 22.1083984375,
          "content": "// DeleteClipData.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"DeleteClipData.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"Misc.h\"\r\n#include \"ProgressWnd.h\"\r\n#include <algorithm>\r\n\r\n\r\n// CDeleteClipData dialog\r\n\r\nIMPLEMENT_DYNAMIC(CDeleteClipData, CDialog)\r\n\r\nCDeleteClipData::CDeleteClipData(CWnd* pParent /*=NULL*/)\r\n\t: CDialog(CDeleteClipData::IDD, pParent)\r\n\t, m_clipTitle(_T(\"\"))\r\n\t, m_filterByClipTitle(FALSE)\r\n\t, m_filterByCreatedDate(FALSE)\r\n\t, m_filterByLastUsedDate(FALSE)\r\n\t, m_filterByClipboardFormat(FALSE)\r\n\t, m_createdDateStart(COleDateTime::GetCurrentTime())\r\n\t, m_createdDateEnd(COleDateTime::GetCurrentTime())\r\n\t, m_createdTimeStart(COleDateTime::GetCurrentTime())\r\n\t, m_createdTimeEnd(COleDateTime::GetCurrentTime())\r\n\t, m_usedTimeStart(COleDateTime::GetCurrentTime())\r\n\t, m_usedTimeEnd(COleDateTime::GetCurrentTime())\r\n\t, m_usedDateStart(COleDateTime::GetCurrentTime())\r\n\t, m_usedDateEnd(COleDateTime::GetCurrentTime())\r\n\t, m_databaseSize(_T(\"\"))\r\n\t, m_selectedSize(_T(\"\"))\r\n\t, m_selectedCount(_T(\"\"))\r\n{\r\n\tm_applyingDelete = false;\r\n\tm_cancelDelete = false;\r\n\r\n}\r\n\r\nCDeleteClipData::~CDeleteClipData()\r\n{\r\n}\r\n\r\nvoid CDeleteClipData::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialog::DoDataExchange(pDX);\r\n\tDDX_Control(pDX, IDC_LIST2, m_List);\r\n\tDDX_Text(pDX, IDC_EDIT_CLIP_TITLE, m_clipTitle);\r\n\tDDX_Check(pDX, IDC_CHECK_CLIP_TITLE, m_filterByClipTitle);\r\n\tDDX_Check(pDX, IDC_CHECK_CREATE_DATE, m_filterByCreatedDate);\r\n\tDDX_Check(pDX, IDC_CHECK_LAST_USE_DATE, m_filterByLastUsedDate);\r\n\tDDX_Check(pDX, IDC_CHECK_DATA_FORMAT, m_filterByClipboardFormat);\r\n\tDDX_Control(pDX, IDC_COMBO_DATA_FORMAT, m_clipboardFomatCombo);\r\n\tDDX_DateTimeCtrl(pDX, IDC_DATE_CREATE_START, m_createdDateStart);\r\n\tDDX_DateTimeCtrl(pDX, IDC_DATE_CREATE_END, m_createdDateEnd);\r\n\tDDX_DateTimeCtrl(pDX, IDC_TIME_CREATE_START, m_createdTimeStart);\r\n\tDDX_DateTimeCtrl(pDX, IDC_TIME_CREATE_END, m_createdTimeEnd);\r\n\tDDX_DateTimeCtrl(pDX, IDC_TIME_USE_START, m_usedTimeStart);\r\n\tDDX_DateTimeCtrl(pDX, IDC_TIME_USE_END, m_usedTimeEnd);\r\n\tDDX_DateTimeCtrl(pDX, IDC_DATE_USE_START, m_usedDateStart);\r\n\tDDX_DateTimeCtrl(pDX, IDC_DATE_USE_END, m_usedDateEnd);\r\n\tDDX_Text(pDX, IDC_STATIC_DB_SIZE, m_databaseSize);\r\n\tDDX_Text(pDX, IDC_STATIC_SELECTED_SIZE, m_selectedSize);\r\n\tDDX_Text(pDX, IDC_STATIC_SELECTED_COUNT, m_selectedCount);\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CDeleteClipData, CDialog)\r\n\tON_WM_CLOSE()\r\n\tON_WM_SIZE()\r\n\tON_WM_NCDESTROY()\r\n\tON_BN_CLICKED(IDC_BUTTON_SEARCH, &CDeleteClipData::OnBnClickedButtonSearch)\r\n\tON_NOTIFY(LVN_KEYDOWN, IDC_LIST2, &CDeleteClipData::OnLvnKeydownList2)\r\n\tON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST2, &CDeleteClipData::OnLvnItemchangedList2)\r\n\tON_NOTIFY(HDN_GETDISPINFO, 0, &CDeleteClipData::OnHdnGetdispinfoList2)\r\n\tON_NOTIFY(LVN_GETDISPINFO, IDC_LIST2, &CDeleteClipData::OnLvnGetdispinfoList2)\r\n\tON_BN_CLICKED(IDC_CHECK_CLIP_TITLE, &CDeleteClipData::OnBnClickedCheckClipTitle)\r\n\tON_BN_CLICKED(IDC_BUTTON_APPLY, &CDeleteClipData::OnBnClickedButtonApply)\r\n\tON_BN_CLICKED(IDCANCEL, &CDeleteClipData::OnBnClickedCancel)\r\n\tON_WM_TIMER()\r\n\tON_BN_CLICKED(IDC_CHECK_CREATE_DATE, &CDeleteClipData::OnBnClickedCheckCreateDate)\r\n\tON_BN_CLICKED(IDC_CHECK_LAST_USE_DATE, &CDeleteClipData::OnBnClickedCheckLastUseDate)\r\n\tON_BN_CLICKED(IDC_CHECK_DATA_FORMAT, &CDeleteClipData::OnBnClickedCheckDataFormat)\r\n\tON_NOTIFY(HDN_ITEMCLICK, 0, &CDeleteClipData::OnLvnColumnclickList2)\r\n\r\nEND_MESSAGE_MAP()\r\n\r\nBOOL CDeleteClipData::OnInitDialog()\r\n{\r\n\tCDialog::OnInitDialog();\r\n\r\n\ttheApp.m_Language.UpdateDeleteClipData(this);\r\n\r\n\tm_Resize.SetParent(m_hWnd);\r\n\tm_Resize.AddControl(IDC_LIST2, DR_SizeHeight | DR_SizeWidth);\r\n\tm_Resize.AddControl(IDCANCEL, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_BUTTON_APPLY, DR_MoveTop | DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_STATIC_TO_DELETE_TEXT, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_STATIC_TO_DELETE_SIZE, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_STATIC_SELECTED_SIZE, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_STATIC_SELECTED_SIZE_TEXT, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_STATIC_DB_SIZE, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_STATIC_DB_SIZE_TEXT, DR_MoveTop);\r\n\tm_Resize.AddControl(IDC_BUTTON_SEARCH, DR_MoveLeft);\r\n\tm_Resize.AddControl(IDC_STATIC_GROUP_SEARCH, DR_SizeWidth);\r\n\r\n\tInitListCtrlCols();\r\n\r\n\tSetTimer(1, 500, 0);\r\n\r\n\tSetDbSize();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CDeleteClipData::SetDbSize()\r\n{\r\n\t__int64 size = FileSize(GetDBName());\r\n\r\n\tconst int MAX_FILE_SIZE_BUFFER = 255;\r\n\tTCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\r\n\tStrFormatByteSize(size, szFileSize, MAX_FILE_SIZE_BUFFER);\r\n\r\n\tm_databaseSize = szFileSize;\r\n\tUpdateData(0);\r\n}\r\n\r\nvoid CDeleteClipData::InitListCtrlCols()\r\n{\r\n\tm_List.SetExtendedStyle(LVS_EX_FULLROWSELECT);\r\n\r\n\tm_List.InsertColumn(0, theApp.m_Language.GetDeleteClipDataString(\"Title\", \"Title\"), LVCFMT_LEFT, 350);\r\n\tm_List.InsertColumn(1, theApp.m_Language.GetDeleteClipDataString(\"QuickPasteText\", \"Quick Paste Text\"), LVCFMT_LEFT, 200);\r\n\tm_List.InsertColumn(2, theApp.m_Language.GetDeleteClipDataString(\"Created\", \"Created\"), LVCFMT_LEFT, 150);\r\n\tm_List.InsertColumn(3, theApp.m_Language.GetDeleteClipDataString(\"LastUsed\", \"Last Used\"), LVCFMT_LEFT, 150);\r\n\tm_List.InsertColumn(4, theApp.m_Language.GetDeleteClipDataString(\"Format\", \"Format\"), LVCFMT_LEFT, 150);\r\n\tm_List.InsertColumn(5, theApp.m_Language.GetDeleteClipDataString(\"DataSize\", \"Data Size\"), LVCFMT_LEFT, 100);\r\n}\r\n\r\nvoid CDeleteClipData::LoadItems()\r\n{\r\n\tCWaitCursor wait;\r\n\tm_data.clear();\t\r\n\tm_filteredOut.clear();\r\n\r\n\tif (m_clipboardFomatCombo.GetCount() == 0)\r\n\t{\r\n\t\tCppSQLite3Query qFormats = theApp.m_db.execQueryEx(_T(\"select DISTINCT(strClipBoardFormat) from Data\"));\r\n\t\twhile (qFormats.eof() == false)\r\n\t\t{\r\n\t\t\tCString format = qFormats.getStringField(_T(\"strClipBoardFormat\"));\r\n\t\t\tm_clipboardFomatCombo.AddString(format);\r\n\r\n\t\t\tqFormats.nextRow();\r\n\t\t}\r\n\t}\r\n\r\n\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT Main.lID, Main.mText, Main.lDate, Main.lastPasteDate, Main.QuickPasteText, Data.lID AS DataID, Data.strClipBoardFormat, length(Data.ooData) AS DataLength \")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"FROM Data \")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"INNER JOIN Main on Main.lID = Data.lParentID \")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"ORDER BY length(ooData) DESC\"));\r\n\r\n\tint row = 0;\r\n\twhile (q.eof() == false)\r\n\t{\r\n\t\tCDeleteData data;\r\n\t\tdata.m_lID = q.getIntField(_T(\"lID\"));\r\n\t\tdata.m_Desc = q.getStringField(_T(\"mText\"));\r\n\t\tdata.m_createdDateTime = q.getIntField(_T(\"lDate\"));\r\n\t\tdata.m_lastUsedDateTime = q.getIntField(_T(\"lastPasteDate\"));\r\n\t\tdata.m_clipboardFormat = q.getStringField(_T(\"strClipBoardFormat\"));\r\n\t\tdata.m_dataSize = q.getIntField(_T(\"DataLength\"));\r\n\t\tdata.m_DatalID = q.getIntField(_T(\"DataID\"));\r\n\t\tdata.m_quickPasteText = q.getStringField(_T(\"QuickPasteText\"));\r\n\r\n\t\tm_data.push_back(data);\r\n\r\n\t\trow++;\r\n\r\n\t\tq.nextRow();\t\t\r\n\t}\r\n\r\n\tm_List.SetItemCountEx(row, 0);\r\n}\r\n\r\n//void CDeleteClipData::AddRow(CppSQLite3Query& q, int row)\r\n//{\r\n//\tLVITEM lvi;\r\n//\r\n//\tlvi.mask = LVIF_TEXT;\r\n//\tlvi.iItem = row;\t\r\n//\r\n//\tlvi.iSubItem = 0;\r\n//\tlvi.pszText = (LPTSTR) (LPCTSTR) (q.getStringField(_T(\"mText\")));\r\n//\tm_List.InsertItem(&lvi);\r\n//\r\n//\tCTime created = q.getIntField(_T(\"lDate\"));\r\n//\tCOleDateTime dtTime(created.GetTime());\r\n//\t\r\n//\tCTime pasted = q.getIntField(_T(\"lastPasteDate\"));\r\n//\tCOleDateTime dtPastedTime(pasted.GetTime());\r\n//\r\n//\tm_List.SetItemText(row, 1, dtTime.Format());\r\n//\tm_List.SetItemText(row, 2, dtPastedTime.Format());\r\n//\tm_List.SetItemText(row, 3, q.getStringField(_T(\"strClipBoardFormat\")));\r\n//\r\n//\tint dataLength = q.getIntField(_T(\"DataLength\"));\r\n//\r\n//\tconst int MAX_FILE_SIZE_BUFFER = 255;\r\n//\tTCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\r\n//\tStrFormatByteSize(dataLength, szFileSize, MAX_FILE_SIZE_BUFFER);\r\n//\r\n//\tm_List.SetItemText(row, 4, szFileSize);\r\n//\r\n//\tm_List.SetItemData(row, ));\r\n//}\r\n\r\nvoid CDeleteClipData::SetNotifyWnd(HWND hWnd)\r\n{\r\n\tm_hWndParent = hWnd;\r\n}\r\n\r\nvoid CDeleteClipData::OnClose()\r\n{\r\n\tif (m_applyingDelete)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDestroyWindow();\r\n}\r\n\r\nvoid CDeleteClipData::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCDialog::OnSize(nType, cx, cy);\r\n\r\n\tm_Resize.MoveControls(CSize(cx, cy));\r\n}\r\n\r\nvoid CDeleteClipData::OnNcDestroy()\r\n{\r\n\tCDialog::OnNcDestroy();\r\n\t::PostMessage(m_hWndParent, WM_DELETE_CLIPS_CLOSED, 0, 0);\r\n}\r\n\r\n// CDeleteClipData message handlers\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedButtonSearch()\r\n{\r\n\tFilterItems();\r\n}\r\n\r\nvoid CDeleteClipData::FilterItems()\r\n{\r\n\tUpdateData();\r\n\r\n\t//First search the already filtered text, see if we need to add them back in\r\n\tstd::vector<int> filteredRowsToDelete;\r\n\tstd::vector<CDeleteData> addBackIn;\r\n\tINT_PTR count = m_filteredOut.size();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tCDeleteData data = m_filteredOut[i];\r\n\r\n\t\tif (MatchesFilter(&data))\r\n\t\t{\r\n\t\t\taddBackIn.push_back(data);\r\n\t\t\tfilteredRowsToDelete.push_back(i);\r\n\t\t}\r\n\t}\r\n\r\n\t//next search the main list\r\n\tstd::vector<int> rowsToDelete;\r\n\tcount = m_data.size();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tCDeleteData data = m_data[i];\r\n\r\n\t\tif(MatchesFilter(&data) == false)\r\n\t\t{\r\n\t\t\tm_filteredOut.push_back(data);\r\n\t\t\trowsToDelete.push_back(i);\r\n\t\t}\r\n\t}\r\n\r\n\t//Add back in the filtered out ones that now match\r\n\tcount = addBackIn.size();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tCDeleteData data = addBackIn[i];\r\n\t\tm_data.push_back(data);\r\n\t}\r\n\r\n\tint toSelect = -1;\r\n\r\n\t//Remove from the main list the ones that don't match\r\n\tcount = rowsToDelete.size();\r\n\tfor (INT_PTR i = count - 1; i >= 0; i--)\r\n\t{\r\n\t\tint row = rowsToDelete[i];\r\n\t\ttoSelect = row;\r\n\r\n\t\tm_data.erase(m_data.begin() + row);\r\n\t}\r\n\r\n\t//Remove the rows that were filtered out but now match\r\n\tcount = filteredRowsToDelete.size();\r\n\tfor (INT_PTR i = count - 1; i >= 0; i--)\r\n\t{\r\n\t\tint row = filteredRowsToDelete[i];\r\n\t\tm_filteredOut.erase(m_filteredOut.begin() + row);\r\n\t}\r\n\r\n\tif (toSelect > -1)\r\n\t{\r\n\t\tm_List.SetItemState(toSelect, LVIS_SELECTED, LVIS_SELECTED);\r\n\t}\r\n\t\r\n\tm_List.SetItemCountEx((int)m_data.size(), 0);\r\n}\r\n\r\nbool CDeleteClipData::MatchesFilter(CDeleteData *pdata)\r\n{\r\n\tif(m_filterByClipTitle &&\r\n\t\tm_clipTitle != _T(\"\") &&\r\n\t\tpdata->m_Desc != _T(\"\"))\r\n\t{\r\n\t\tif(pdata->m_Desc.MakeLower().Find(m_clipTitle.MakeLower()) == -1)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (m_filterByCreatedDate)\r\n\t{\t\t\r\n\t\tCTime dateStart = CTime(m_createdDateStart.GetYear(), m_createdDateStart.GetMonth(), m_createdDateStart.GetDay(), m_createdTimeStart.GetHour(), m_createdTimeStart.GetMinute(), m_createdTimeStart.GetSecond());\r\n\t\tCTime dateEnd = CTime(m_createdDateEnd.GetYear(), m_createdDateEnd.GetMonth(), m_createdDateEnd.GetDay(), m_createdTimeEnd.GetHour(), m_createdTimeEnd.GetMinute(), m_createdTimeEnd.GetSecond());\r\n\r\n\t\tif (pdata->m_createdDateTime >= dateStart && pdata->m_createdDateTime <= dateEnd)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (m_filterByLastUsedDate)\r\n\t{\r\n\t\tCTime dateStart = CTime(m_usedDateStart.GetYear(), m_usedDateStart.GetMonth(), m_usedDateStart.GetDay(), m_usedTimeStart.GetHour(), m_usedTimeStart.GetMinute(), m_usedTimeStart.GetSecond());\r\n\t\tCTime dateEnd = CTime(m_usedDateEnd.GetYear(), m_usedDateEnd.GetMonth(), m_usedDateEnd.GetDay(), m_usedTimeEnd.GetHour(), m_usedTimeEnd.GetMinute(), m_usedTimeEnd.GetSecond());\r\n\r\n\t\tif (pdata->m_lastUsedDateTime >= dateStart && pdata->m_lastUsedDateTime <= dateEnd)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (m_filterByClipboardFormat)\r\n\t{\r\n\t\tCString str1;\r\n\t\tint n = m_clipboardFomatCombo.GetLBTextLen(m_clipboardFomatCombo.GetCurSel());\r\n\t\tm_clipboardFomatCombo.GetLBText(m_clipboardFomatCombo.GetCurSel(), str1.GetBuffer(n));\r\n\t\tstr1.ReleaseBuffer();\r\n\r\n\t\tif (pdata->m_clipboardFormat == str1)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CDeleteClipData::OnLvnKeydownList2(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMLVKEYDOWN pLVKeyDow = reinterpret_cast<LPNMLVKEYDOWN>(pNMHDR);\r\n\t// TODO: Add your control notification handler code here\r\n\r\n\tswitch(pLVKeyDow->wVKey)\r\n\t{\r\n\tcase VK_DELETE:\r\n\t\tthis->ApplyDelete();\r\n\t\tbreak;\r\n\t}\r\n\t*pResult = 0;\r\n}\r\n\r\nvoid CDeleteClipData::OnLvnItemchangedList2(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);\r\n\t\r\n\tPOSITION pos = m_List.GetFirstSelectedItemPosition();\r\n\t__int64 selectedDataSize = 0;\r\n\tint selectedCount = 0;\r\n\r\n\tif (pos != NULL)\r\n\t{\r\n\t\twhile (pos)\r\n\t\t{\r\n\t\t\tINT_PTR row = m_List.GetNextSelectedItem(pos);\r\n\r\n\t\t\tif(row >= 0 && row < (INT_PTR)m_data.size())\r\n\t\t\t{\r\n\t\t\t\tselectedDataSize += m_data[row].m_dataSize;\r\n\t\t\t\tselectedCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst int MAX_FILE_SIZE_BUFFER = 255;\r\n\tTCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\r\n\tStrFormatByteSize(selectedDataSize, szFileSize, MAX_FILE_SIZE_BUFFER);\r\n\r\n\tm_selectedSize = szFileSize;\r\n\r\n\tCString count;\r\n\tcount.Format(_T(\"%d\"), selectedCount);\r\n\r\n\tm_selectedCount = count;\r\n\r\n\tUpdateData(0);\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnHdnGetdispinfoList2(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMHDDISPINFO pDispInfo = reinterpret_cast<LPNMHDDISPINFO>(pNMHDR);\t\r\n\t\r\n\tif (pDispInfo->mask &LVIF_TEXT)\r\n\t{\r\n\t\tswitch (pDispInfo->iItem)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnLvnGetdispinfoList2(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tNMLVDISPINFO *pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);\r\n\tif (pDispInfo->item.mask & LVIF_TEXT)\r\n\t{\r\n\t\tif (pDispInfo->item.iItem >= 0 && pDispInfo->item.iItem < m_data.size())\r\n\t\t{\r\n\t\t\tswitch (pDispInfo->item.iSubItem)\r\n\t\t\t{\r\n\t\t\t\tcase 0:\r\n\t\t\t\t{\r\n\t\t\t\t\t  lstrcpyn(pDispInfo->item.pszText, m_data[pDispInfo->item.iItem].m_Desc, pDispInfo->item.cchTextMax);\r\n\t\t\t\t\t  pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 1:\r\n\t\t\t\t{\r\n\t\t\t\t\tlstrcpyn(pDispInfo->item.pszText, m_data[pDispInfo->item.iItem].m_quickPasteText, pDispInfo->item.cchTextMax);\r\n\t\t\t\t\tpDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t{\r\n\t\t\t\t\t  COleDateTime dtTime(m_data[pDispInfo->item.iItem].m_createdDateTime.GetTime());\r\n\t\t\t\t\t  lstrcpyn(pDispInfo->item.pszText, dtTime.Format(), pDispInfo->item.cchTextMax);\r\n\t\t\t\t\t  pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t{\t\r\n\t\t\t\t\t  COleDateTime dtTime(m_data[pDispInfo->item.iItem].m_lastUsedDateTime.GetTime());\r\n\t\t\t\t\t  lstrcpyn(pDispInfo->item.pszText, dtTime.Format(), pDispInfo->item.cchTextMax);\r\n\t\t\t\t\t  pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 4:\r\n\t\t\t\t{\r\n\t\t\t\t\t  lstrcpyn(pDispInfo->item.pszText, m_data[pDispInfo->item.iItem].m_clipboardFormat, pDispInfo->item.cchTextMax);\r\n\t\t\t\t\t  pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 5:\r\n\t\t\t\t{\r\n\t\t\t\t\t  const int MAX_FILE_SIZE_BUFFER = 255;\r\n\t\t\t\t\t  TCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\r\n\t\t\t\t\t  StrFormatByteSize(m_data[pDispInfo->item.iItem].m_dataSize, szFileSize, MAX_FILE_SIZE_BUFFER);\r\n\r\n\t\t\t\t\t  lstrcpyn(pDispInfo->item.pszText, szFileSize, pDispInfo->item.cchTextMax);\r\n\t\t\t\t\t  pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\\0';\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedCheckClipTitle()\r\n{\r\n\tUpdateData();\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CLIP_TITLE), m_filterByClipTitle);\t\r\n\t::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT_CLIP_TITLE));\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedButtonApply()\r\n{\r\n\tApplyDelete();\r\n}\r\n\r\nvoid CDeleteClipData::ApplyDelete()\r\n{\r\n\tif (m_applyingDelete)\r\n\t\treturn;\r\n\r\n\tif (MessageBox(_T(\"Delete selected items?  This cannot be undone!\"), _T(\"\"), MB_YESNO | MB_ICONWARNING) == IDYES)\r\n\t{\r\n\t\tm_List.EnableWindow(FALSE);\r\n\t\tm_applyingDelete = true;\r\n\t\tm_cancelDelete = false;\r\n\r\n\t\tCWaitCursor wait;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDML(_T(\"PRAGMA auto_vacuum = 2\"));\r\n\r\n\t\t\tPOSITION pos = m_List.GetFirstSelectedItemPosition();\r\n\t\t\tstd::vector<int> rowsToDelete;\r\n\r\n\t\t\tif (pos != NULL)\r\n\t\t\t{\r\n\t\t\t\twhile (pos)\r\n\t\t\t\t{\r\n\t\t\t\t\tint row = m_List.GetNextSelectedItem(pos);\r\n\t\t\t\t\trowsToDelete.push_back(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tCProgressWnd progress;\r\n\t\t\tprogress.Create(this, _T(\"Deleting clip items\"), TRUE);\r\n\t\t\tprogress.SetRange(0, (int)rowsToDelete.size() + 4);\r\n\t\t\tprogress.SetText(_T(\"Deleting selected items\"));\r\n\t\t\tprogress.SetStep(1);\r\n\r\n\t\t\tINT_PTR count = rowsToDelete.size();\r\n\t\t\tfor (INT_PTR i = count - 1; i >= 0; i--)\r\n\t\t\t{\r\n\t\t\t\tprogress.PeekAndPump();\r\n\t\t\t\tif (m_cancelDelete || progress.Cancelled())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tprogress.StepIt();\r\n\r\n\t\t\t\tint row = rowsToDelete[i];\r\n\r\n\t\t\t\tCDeleteData data = m_data[row];\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\t//Sleep(100);\r\n\t\t\t\t\tint deleteCount = theApp.m_db.execDMLEx(_T(\"DELETE FROM Data where lID = %d\"), data.m_DatalID);\r\n\r\n\t\t\t\t\t//If there are no more children for this clip then delete the parent\r\n\t\t\t\t\tint parentDeleteCount = theApp.m_db.execDMLEx(_T(\"DELETE FROM Main where lID IN \")\r\n\t\t\t\t\t\t_T(\"(\")\r\n\t\t\t\t\t\t_T(\"SELECT Main.lID \")\r\n\t\t\t\t\t\t_T(\"FROM Main \")\r\n\t\t\t\t\t\t_T(\"LEFT OUTER JOIN Data on Data.lParentID = Main.lID \")\r\n\t\t\t\t\t\t_T(\"WHERE bIsGroup = 0 AND Main.lID = %d \")\r\n\t\t\t\t\t\t_T(\"Group by Main.lID \")\r\n\t\t\t\t\t\t_T(\"having Count(Data.lID) = 0 \")\r\n\t\t\t\t\t\t_T(\")\"), data.m_lID);\r\n\r\n\t\t\t\t\tm_data.erase(m_data.begin() + row);\r\n\t\t\t\t}\r\n\t\t\t\tCATCH_SQLITE_EXCEPTION\r\n\t\t\t}\r\n\r\n\t\t\tprogress.StepIt();\r\n\t\t\tprogress.SetText(_T(\"Shrinking database\"));\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tfor(int i = 0; i < 100; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint toDeleteCount = theApp.m_db.execScalar(_T(\"SELECT COUNT(clipID) FROM MainDeletes\"));\r\n\t\t\t\t\tif(toDeleteCount <= 0)\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tRemoveOldEntries(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\t\ttheApp.m_db.execDML(_T(\"PRAGMA auto_vacuum = 1\"));\r\n\t\t\ttheApp.m_db.execQuery(_T(\"VACUUM\"));\r\n\t\t\t\r\n\t\t\tprogress.StepIt();\r\n\t\t\tprogress.SetText(_T(\"Refreshing database size\"));\r\n\r\n\t\t\tSetDbSize();\r\n\t\t\t\r\n\t\t\tprogress.StepIt();\r\n\t\t\tprogress.SetText(_T(\"Reloading list\"));\r\n\r\n\t\t\t//LoadItems();\r\n\t\t\t\r\n\t\t\tprogress.StepIt();\r\n\t\t\tprogress.SetText(_T(\"Applying filter\"));\r\n\t\t\t\r\n\t\t\tFilterItems();\r\n\r\n\t\t\tm_List.SetItemCountEx((int)m_data.size(), 0);\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\tm_applyingDelete = false;\r\n\t\tm_List.EnableWindow();\r\n\t}\r\n}\r\n\r\nvoid CDeleteClipData::OnBnClickedCancel()\r\n{\r\n\tif (m_applyingDelete)\r\n\t{\r\n\t\tm_cancelDelete = true;\r\n\t\treturn;\r\n\t}\r\n\tDestroyWindow();\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\tswitch(nIDEvent)\r\n\t{\r\n\tcase 1:\r\n\t\tLoadItems();\r\n\t\tKillTimer(1);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tCDialog::OnTimer(nIDEvent);\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedCheckCreateDate()\r\n{\r\n\tUpdateData();\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_DATE_CREATE_START), m_filterByCreatedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_TIME_CREATE_START), m_filterByCreatedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_DATE_CREATE_END), m_filterByCreatedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_TIME_CREATE_END), m_filterByCreatedDate);\r\n\t::SetFocus(::GetDlgItem(m_hWnd, IDC_DATE_CREATE_START));\t\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedCheckLastUseDate()\r\n{\r\n\tUpdateData();\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_DATE_USE_START), m_filterByLastUsedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_TIME_USE_START), m_filterByLastUsedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_DATE_USE_END), m_filterByLastUsedDate);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_TIME_USE_END), m_filterByLastUsedDate);\r\n\t::SetFocus(::GetDlgItem(m_hWnd, IDC_DATE_USE_START));\r\n}\r\n\r\n\r\nvoid CDeleteClipData::OnBnClickedCheckDataFormat()\r\n{\r\n\tUpdateData();\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_DATA_FORMAT), m_filterByClipboardFormat);\r\n\t::SetFocus(::GetDlgItem(m_hWnd, IDC_COMBO_DATA_FORMAT));\r\n}\r\n\r\nstatic bool SortByTitleDesc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_Desc > a2.m_Desc;\r\n}\r\n\r\nstatic bool SortByQuickPaste(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_quickPasteText > a2.m_quickPasteText;\r\n}\r\n\r\nstatic bool SortByCreatedDateDesc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_createdDateTime > a2.m_createdDateTime;\r\n}\r\n\r\nstatic bool SortByLastUsedDateDesc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_lastUsedDateTime > a2.m_lastUsedDateTime;\r\n}\r\n\r\nstatic bool SortByFormatDesc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_clipboardFormat > a2.m_clipboardFormat;\r\n}\r\n\r\nstatic bool SortByDataSizeDesc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_dataSize > a2.m_dataSize;\r\n}\r\n\r\nstatic bool SortByTitleAsc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_Desc < a2.m_Desc;\r\n}\r\n\r\nstatic bool SortByCreatedDateAsc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_createdDateTime < a2.m_createdDateTime;\r\n}\r\n\r\nstatic bool SortByLastUsedDateAsc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_lastUsedDateTime < a2.m_lastUsedDateTime;\r\n}\r\n\r\nstatic bool SortByFormatAsc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_clipboardFormat < a2.m_clipboardFormat;\r\n}\r\n\r\nstatic bool SortByDataSizeAsc(const CDeleteData& a1, const CDeleteData& a2)\r\n{\r\n\treturn a1.m_dataSize < a2.m_dataSize;\r\n}\r\n\r\nbool desc = true;\r\nvoid CDeleteClipData::OnLvnColumnclickList2(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tHD_NOTIFY *phdn = (HD_NOTIFY *)pNMHDR;\r\n\r\n\tswitch (phdn->iItem)\r\n\t{\r\n\tcase 0:\r\n\t\tif(desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByTitleDesc);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByTitleAsc);\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tif (desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByQuickPaste);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByQuickPaste);\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tif(desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByCreatedDateDesc);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByCreatedDateAsc);\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tif(desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByLastUsedDateDesc);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByLastUsedDateAsc);\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tif(desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByFormatDesc);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByFormatAsc);\r\n\t\tbreak;\r\n\tcase 5:\r\n\t\tif(desc)\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByDataSizeDesc);\r\n\t\telse\r\n\t\t\tstd::sort(m_data.begin(), m_data.end(), SortByDataSizeAsc);\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\tdesc = !desc;\r\n\r\n\tm_List.SetItemCountEx((int)m_data.size(), 0);\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nBOOL CDeleteClipData::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\tif (pMsg->message == WM_KEYDOWN)\r\n\t{\r\n\t\tif (pMsg->wParam == VK_RETURN)\r\n\t\t{\r\n\t\t\tFilterItems();\r\n\t\t\treturn TRUE;                // Do not process further\r\n\t\t}\r\n\t}\r\n\r\n\treturn CDialog::PreTranslateMessage(pMsg);\r\n}\r\n"
        },
        {
          "name": "DeleteClipData.h",
          "type": "blob",
          "size": 2.673828125,
          "content": "#pragma once\r\n\r\n#include \"DialogResizer.h\"\r\n#include \"ShowTaskBarIcon.h\"\r\n#include \"afxwin.h\"\r\n#include \"ATLComTime.h\"\r\n#include <vector>\r\n#include \"afxcmn.h\"\r\n\r\n// CDeleteClipData dialog\r\n\r\nclass CDeleteData\r\n{\r\npublic:\r\n\tCDeleteData() :\r\n\t\tm_lID(-1),\r\n\t\tm_dataSize(0)\r\n\t{\r\n\t}\r\n\r\n\tlong m_lID;\r\n\tlong m_DatalID;\r\n\tCString m_Desc;\r\n\tCTime m_createdDateTime;\r\n\tCTime m_lastUsedDateTime;\r\n\tCString m_clipboardFormat;\r\n\tDWORD m_dataSize;\r\n\tCString m_quickPasteText;\r\n};\r\n\t\r\n\t\r\n\t\r\nclass CDeleteClipData : public CDialog\r\n{\r\n\tDECLARE_DYNAMIC(CDeleteClipData)\r\n\r\npublic:\r\n\tCDeleteClipData(CWnd* pParent = NULL);   // standard constructor\r\n\tvirtual ~CDeleteClipData();\r\n\r\n\tvoid SetNotifyWnd(HWND hWnd);\r\n\r\n// Dialog Data\r\n\tenum { IDD = IDD_DELETE_CLIP_DATA };\r\n\r\nprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\r\n\r\n\tDECLARE_MESSAGE_MAP()\r\n\t\t\r\n\r\n\tCDialogResizer m_Resize;\r\n\tCListCtrl\tm_List;\r\n\tHWND m_hWndParent;\r\n\tCShowTaskBarIcon m_showTaskbar;\r\n\tstd::vector<CDeleteData> m_data;\r\n\tstd::vector<CDeleteData> m_toDelete;\r\n\tstd::vector<CDeleteData> m_filteredOut;\r\n\tbool m_applyingDelete;\r\n\tbool m_cancelDelete;\r\n\r\n\r\n\tvoid InitListCtrlCols();\r\n\tvirtual BOOL OnInitDialog();\r\n\r\n\tvoid SetDbSize();\r\n\r\n\tafx_msg void OnClose();\r\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\r\n\tafx_msg void OnNcDestroy();\r\n\tvoid LoadItems();\r\n\tvoid FilterItems();\r\n\tbool MatchesFilter(CDeleteData *pdata);\r\n\tvoid ApplyDelete();\r\n\r\npublic:\r\n\tCString m_clipTitle;\r\n\tBOOL m_filterByClipTitle;\r\n\tBOOL m_filterByCreatedDate;\r\n\tBOOL m_filterByLastUsedDate;\r\n\tBOOL m_filterByClipboardFormat;\r\n\tCComboBox m_clipboardFomatCombo;\r\n\tCOleDateTime m_createdDateStart;\r\n\tCOleDateTime m_createdDateEnd;\r\n\tCOleDateTime m_createdTimeStart;\r\n\tCOleDateTime m_createdTimeEnd;\r\n\tCOleDateTime m_usedTimeStart;\r\n\tCOleDateTime m_usedTimeEnd;\r\n\tCOleDateTime m_usedDateStart;\r\n\tCOleDateTime m_usedDateEnd;\r\n\tafx_msg void OnBnClickedButtonSearch();\r\n\tafx_msg void OnLvnKeydownList2(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnLvnItemchangedList2(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnHdnGetdispinfoList2(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnLvnGetdispinfoList2(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tCString m_databaseSize;\r\n\tCString m_selectedSize;\r\n\tCString m_selectedCount;\r\n\tCString m_toDeleteSize;\r\n\tafx_msg void OnBnClickedCheckClipTitle();\r\n\tafx_msg void OnBnClickedButtonApply();\r\n\tafx_msg void OnBnClickedCancel();\r\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\r\n\tafx_msg void OnBnClickedCheckCreateDate();\r\n\tafx_msg void OnBnClickedCheckLastUseDate();\r\n\tafx_msg void OnBnClickedCheckDataFormat();\r\n\tafx_msg void OnLvnColumnclickList2(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\r\n};\r\n"
        },
        {
          "name": "DialogResizer.cpp",
          "type": "blob",
          "size": 2.166015625,
          "content": "// DialogResizer.cpp: implementation of the CDialogResizer class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"DialogResizer.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\n\nCDialogResizer::CDialogResizer()\n{\n\n}\n\nCDialogResizer::~CDialogResizer()\n{\n\n}\n\nvoid CDialogResizer::SetParent(HWND hWndParent)\n{\n\tm_hWndParent = hWndParent;\n\tCRect cr;\n\tGetClientRect(m_hWndParent, cr);\n\n\tm_DlgSize.cx = cr.Width();\n\tm_DlgSize.cy = cr.Height();\n}\n\nvoid CDialogResizer::AddControl(int nControlID, int nFlags)\n{\n\tHWND hWnd = GetDlgItem(m_hWndParent, nControlID);\n\tif(hWnd)\n\t\tAddControl(hWnd, nFlags);\n}\n\nvoid CDialogResizer::AddControl(HWND hWnd, int nFlags)\n{\n\tCDR_Data data;\n\tdata.m_hWnd = hWnd;\n\tdata.m_nFlags = nFlags;\n\n\n\tm_Controls.Add(data);\n}\n\nvoid CDialogResizer::MoveControls(CSize csNewSize)\n{\n\tint nDeltaX = csNewSize.cx - m_DlgSize.cx;\n\tint nDeltaY = csNewSize.cy - m_DlgSize.cy;\n\n\tif(nDeltaX == 0 && nDeltaY == 0)\n\t\treturn;\n\n\tm_DlgSize = csNewSize;\n\n\tINT_PTR nCount = m_Controls.GetSize();\n\tCRect rc;\n\tCRect rcParent;\n\n\tGetClientRect(m_hWndParent, rcParent);\n\n\tfor(int i = 0; i < nCount; i++)\n\t{\n\t\tCDR_Data data = m_Controls[i];\n\n\t\tGetWindowRect(data.m_hWnd, rc);\n\t\tMapWindowPoints(GetDesktopWindow(),  m_hWndParent, (LPPOINT)&rc, 2 );\n\t\t\n\t\t//\n\t\t//\tAdjust the window horizontally\n\t\tif( data.m_nFlags & DR_MoveLeft )\n\t\t{\n\t\t\trc.left += nDeltaX;\n\t\t\trc.right += nDeltaX;\n\t\t}\n\n\t\t//\n\t\t//\tAdjust the window vertically\n\t\tif( data.m_nFlags & DR_MoveTop )\n\t\t{\n\t\t\trc.top += nDeltaY;\n\t\t\trc.bottom += nDeltaY;\n\t\t}\n\n\t\t//\n\t\t//\tSize the window horizontally\n\t\tif( data.m_nFlags & DR_SizeWidth )\n\t\t{\n\t\t\trc.right += nDeltaX;\n\t\t}\n\n\t\t//\tSize the window vertically\n\t\tif( data.m_nFlags & DR_SizeHeight )\n\t\t{\n\t\t\trc.bottom += nDeltaY;\n\t\t}\n\n\t\t::SetWindowPos(data.m_hWnd, NULL, rc.left, rc.top, rc.Width(), rc.Height(), SWP_NOACTIVATE | SWP_NOZORDER);\n\t}\n\n\t::RedrawWindow(m_hWndParent, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);\n}\n"
        },
        {
          "name": "DialogResizer.h",
          "type": "blob",
          "size": 1.0185546875,
          "content": "// DialogResizer.h: interface for the CDialogResizer class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_DIALOGRESIZER_H__DA9AF3FF_C6CC_4D70_965A_4216A0EC9E75__INCLUDED_)\n#define AFX_DIALOGRESIZER_H__DA9AF3FF_C6CC_4D70_965A_4216A0EC9E75__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include <afxtempl.h>\n\n#define DR_MoveLeft\t\t\t 1\n#define DR_MoveTop\t\t\t 2\n#define DR_SizeWidth\t\t 4\n#define DR_SizeHeight\t\t 8\n\nclass CDialogResizer  \n{\npublic:\n\tCDialogResizer();\n\tvirtual ~CDialogResizer();\n\nprotected:\n\tclass CDR_Data\n\t{\n\tpublic:\n\t\tCDR_Data()\n\t\t{\t\t\t\n\t\t\tm_nFlags = 0;\n\t\t}\n\t\tHWND m_hWnd;\n\t\tint m_nFlags;\n\t};\n\npublic:\n\tvoid MoveControls(CSize csNewSize);\n\n\tvoid AddControl(int nControlID, int nFlags);\n\tvoid AddControl(HWND hWnd, int nFlags);\n\n\tvoid SetParent(HWND hWndParent);\n\nprotected:\n\n\tCArray< CDR_Data, CDR_Data > m_Controls;\n\tCSize m_DlgSize;\n\tHWND m_hWndParent;\n\nprotected:\n};\n\n#endif // !defined(AFX_DIALOGRESIZER_H__DA9AF3FF_C6CC_4D70_965A_4216A0EC9E75__INCLUDED_)\n"
        },
        {
          "name": "DimWnd.cpp",
          "type": "blob",
          "size": 1.154296875,
          "content": "#include \"stdafx.h\"\n#include \"DimWnd.h\"\n\nBEGIN_MESSAGE_MAP(CDimWnd, CFrameWnd)\n\tON_WM_ERASEBKGND()\nEND_MESSAGE_MAP()\n\n\nCDimWnd::CDimWnd(CWnd *pParent)\n{\n\n\t// Don't do anything if the main frame doesn't appear to be there,\n\t// or if there is already dimming happening.\n\tif (pParent != NULL)\n\t{\n\t\t// Get the client area of the window to dim.\n\t\tCRect rc;\n\t\tpParent->GetWindowRect(&rc);\n\n\t\t// Create a layered window for transparency, with no caption/border.\n\t\tCreateEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW, NULL, TEXT(\"\"),\n\t\t\tWS_POPUP, rc.left, rc.top, rc.Width(), rc.Height(),\n\t\t\tpParent->GetSafeHwnd(), NULL);\n\n\t\t// Bring in front of main window.\n\t\tBringWindowToTop();\n\n\t\t// Apply 25% opacity\n\t\tSetLayeredWindowAttributes(RGB(0, 0, 0), 64, LWA_ALPHA);\n\n\t\t// Show the dimmer window\n\t\tShowWindow(SW_SHOW);\n\t}\n}\n\nCDimWnd::~CDimWnd()\n{\n}\n\nBOOL CDimWnd::OnEraseBkgnd(CDC* pDC)\n{\n\t// Fill with black\n\tCBrush backBrush(RGB(0, 0, 0));\n\tCBrush* pOldBrush = pDC->SelectObject(&backBrush);\n\n\tCRect rect;\n\tpDC->GetClipBox(&rect);     // Erase the area needed\n\tpDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY);\n\n\tpDC->SelectObject(pOldBrush);\n\treturn TRUE;\n}"
        },
        {
          "name": "DimWnd.h",
          "type": "blob",
          "size": 0.1591796875,
          "content": "#pragma once\nclass CDimWnd : public CFrameWnd\n{\npublic:\n\tCDimWnd(CWnd *pParent);\n\tBOOL OnEraseBkgnd(CDC* pDC);\n\n\t~CDimWnd();\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n"
        },
        {
          "name": "DittoAddin.cpp",
          "type": "blob",
          "size": 2.5517578125,
          "content": "#include \"stdafx.h\"\n#include \"DittoAddin.h\"\n#include \"Misc.h\"\n#include \"shared/TextConvert.h\"\n\nCDittoAddin::CDittoAddin() :\n\tm_hModule(NULL)\n{\n}\n\nCDittoAddin::~CDittoAddin()\n{\n\tCleanup();\n}\n\nbool CDittoAddin::DoLoad(LPCTSTR lpszDllName, CDittoInfo DittoInfo)\n{\n\tbool bLoaded = false;\n\tm_csLastError.Empty();\n\tCleanup();\n\n\tif(lpszDllName)\n\t{\n\t\t_tcscpy(m_DllName, lpszDllName);\n\n\t\tm_hModule = ::LoadLibrary(lpszDllName);\n\n\t\tif( m_hModule )\n\t\t{\n\t\t\tbool (__cdecl *DittoAddin)(const CDittoInfo&, CDittoAddinInfo&);\n\t\t\tDittoAddin = (bool(__cdecl*)(const CDittoInfo&, CDittoAddinInfo&))GetProcAddress(m_hModule, \"DittoAddin\");\n\t\t\tif(DittoAddin)\n\t\t\t{\n\t\t\t\tbLoaded = DittoAddin(DittoInfo, m_DittoAddinInfo);\n\t\t\t\tif(bLoaded)\n\t\t\t\t{\n\t\t\t\t\tm_SupportedFunctions = (bool(__cdecl*)(const CDittoInfo&, FunctionType,std::vector<CFunction>&))GetProcAddress(m_hModule, \"SupportedFunctions\");\n\t\t\t\t\tSupportedFunctions(DittoInfo, eFuncType_PRE_PASTE, m_PrePasteFunctions);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_csLastError.Format((_T(\"Ditto Addin - DittoAddin return false, not loading Addin\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_csLastError.Format((_T(\"Ditto Addin - Failed to Get Function DittoAddin\")));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_csLastError.Format((_T(\"Ditto Addin - Failed to load library on Addin %s\"), lpszDllName));\n\t\t}\n\t}\n\n\treturn bLoaded;\n}\n\nvoid CDittoAddin::Cleanup()\n{\n\tif(m_hModule)\n\t{\n\t\t// release resources to the dll\n\t\t::FreeLibrary(m_hModule);\n\t\tm_hModule = NULL;\n\t}\n}\n\nbool CDittoAddin::SupportedFunctions(const CDittoInfo &DittoInfo, FunctionType type, std::vector<CFunction> &Functions)\n{\n\tbool bRet = false;\n\tm_csLastError.Empty();\n\n\tif(m_SupportedFunctions != NULL)\n\t{\n\t\tbRet = m_SupportedFunctions(DittoInfo, type, Functions);\n\t\tif(bRet)\n\t\t{\n\t\t\tINT_PTR nCount = Functions.size();\n\t\t\tfor(int i = 0; i < nCount; i++)\n\t\t\t{\n\t\t\t\tCFunction func = Functions[i];\n\t\t\t\tLog(StrF(_T(\"Ditto Addin - Supported Function Display: %s, Function: %s, Desc: %s\"), func.m_csDisplayName, CTextConvert::AnsiToUnicode(func.m_csFunction), func.m_csDetailDescription));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_csLastError = _T(\"Ditto Addin - m_SupportedFunctions returned false\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_csLastError = _T(\"Ditto Addin - m_SupportedFunctions is null, not call function load supported functions\");\n\t}\n\n\treturn bRet;\n}\n\nbool CDittoAddin::PrePasteFunction(const CDittoInfo &DittoInfo, CStringA Function, IClip *pClip)\n{\n\tbool (__cdecl *PrePasteFunc)(const CDittoInfo &, IClip*);\n\n\tPrePasteFunc = (bool(__cdecl*)(const CDittoInfo &, IClip*))GetProcAddress(m_hModule, Function);\n\tif(PrePasteFunc)\n\t{\n\t\treturn PrePasteFunc(DittoInfo, pClip);\n\t}\n\n\treturn false;\n}\n"
        },
        {
          "name": "DittoAddin.h",
          "type": "blob",
          "size": 0.921875,
          "content": "#pragma once\n\n#include \"Shared\\DittoDefines.h\"\n#include \"Shared\\IClip.h\"\n#include <vector>\n\nclass CDittoAddin\n{\npublic:\n\tCDittoAddin();\n\tvirtual ~CDittoAddin();\n\n\tbool DoLoad(LPCTSTR lpszDllName, CDittoInfo DittoInfo);\n\n\tstd::vector<CFunction> m_PrePasteFunctions;\n\tbool PrePasteFunction(const CDittoInfo &DittoInfo, CStringA Function, IClip *pClip);\n\n\tCString DisplayName() { return m_DittoAddinInfo.m_Name; }\n\tint Version() { return m_DittoAddinInfo.m_AddinVersion; }\n\tint PrivateVersion() { return m_DittoAddinInfo.PrivateVersion(); }\n\tCString LastError()\t{ return m_csLastError; }\n\nprotected:\n\tTCHAR m_DllName[MAX_PATH];\n\tHMODULE m_hModule;\n\tCDittoAddinInfo m_DittoAddinInfo;\n\tCString m_csLastError;\n\t\nprotected:\n\tvoid Cleanup();\n\n\tbool (__cdecl *m_SupportedFunctions)(const CDittoInfo&, FunctionType,std::vector<CFunction>&);\n\tbool SupportedFunctions(const CDittoInfo &DittoInfo, FunctionType type, std::vector<CFunction> &Functions);\t\n};\n"
        },
        {
          "name": "DittoAddins.cpp",
          "type": "blob",
          "size": 4.021484375,
          "content": "#include \"stdafx.h\"\n#include \".\\dittoaddins.h\"\n#include \"misc.h\"\n#include \"CP_Main.h\"\n\nCDittoAddins::CDittoAddins(void)\n{\n}\n\nCDittoAddins::~CDittoAddins(void)\n{\n\tUnloadAll();\n}\n\nbool CDittoAddins::UnloadAll()\n{\n\tLog(StrF(_T(\"Ditto Addin - Unloading all addins Count: %d\"), m_Addins.size()));\n\n\tINT_PTR count = m_Addins.size();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tCDittoAddin *pAddin = m_Addins[i];\n\t\tif(pAddin)\n\t\t{\n\t\t\tdelete pAddin;\n\t\t\tpAddin = NULL;\n\t\t}\n\t}\n\n\tm_Addins.clear();\n\n\treturn true;\n}\n\nbool CDittoAddins::LoadAll()\n{\n\tCDittoInfo DittoInfo;\n\tLoadDittoInfo(DittoInfo);\n\n\tCString csDir = CGetSetOptions::GetPath(PATH_ADDINS);\n\n\tCFileFind find;\n\tBOOL bCont = find.FindFile(csDir + _T(\"*.dll\"));\n\n\twhile(bCont)\n\t{\n\t\tbCont = find.FindNextFile();\n\n\t\tLog(StrF(_T(\"Ditto Addin - Trying to load addin file %s\"), find.GetFilePath()));\n\n\t\tCDittoAddin *pAddin = new CDittoAddin;\n\t\tif(pAddin->DoLoad(find.GetFilePath(), DittoInfo))\n\t\t{\n\t\t\tLog(StrF(_T(\"Ditto Addin - Success, loaded addin: %s\"), find.GetFilePath()));\n\t\t\tm_Addins.push_back(pAddin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog(StrF(_T(\"Ditto Addin - Failed loading Adding Error: %s\"), pAddin->LastError()));\n\n\t\t\tdelete pAddin;\n\t\t\tpAddin = NULL;\n\t\t}\n\t}\n\n\treturn m_Addins.size() > 0;\n}\n\nbool CDittoAddins::AddPrePasteAddinsToMenu(CMenu *pMenu)\n{\n\tbool bRet = false;\n\n\tm_FunctionMap.RemoveAll();\n\tint nMenuId = 3000;\n\n\tHMENU AllAddinsMenu = ::CreateMenu();\n\n\tINT_PTR count = m_Addins.size();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tCDittoAddin *pAddin = m_Addins[i];\n\t\tif(pAddin)\n\t\t{\n\t\t\tINT_PTR subCount = pAddin->m_PrePasteFunctions.size();\n\t\t\tif(subCount > 1)\n\t\t\t{\n\t\t\t\tHMENU AddinMenu = ::CreateMenu();\n\t\t\t\tfor(int x = 0; x < subCount; x++)\n\t\t\t\t{\n\t\t\t\t\t::AppendMenu(AddinMenu, MF_ENABLED, nMenuId, pAddin->m_PrePasteFunctions[x].m_csDisplayName);\n\n\t\t\t\t\tCFunctionLookup lookup;\n\t\t\t\t\tlookup.m_csFunctionName = pAddin->m_PrePasteFunctions[x].m_csFunction;\n\t\t\t\t\tlookup.m_pAddin = pAddin;\n\t\t\t\t\tm_FunctionMap.SetAt(nMenuId, lookup);\n\t\t\t\t\tnMenuId++;\n\t\t\t\t}\n\n\t\t\t\t::AppendMenu(AllAddinsMenu, MF_ENABLED|MF_POPUP, (UINT_PTR)AddinMenu, pAddin->DisplayName());\n\t\t\t\tbRet = true;\n\t\t\t}\n\t\t\telse if(subCount == 1)\n\t\t\t{\n\t\t\t\t//If there is only 1 function for this add in then just show one menu with addin name - function\n\t\t\t\tCFunctionLookup lookup;\n\t\t\t\tlookup.m_csFunctionName = pAddin->m_PrePasteFunctions[0].m_csFunction;\n\t\t\t\tlookup.m_pAddin = pAddin;\n\t\t\t\tm_FunctionMap.SetAt(nMenuId, lookup);\n\n\t\t\t\tCString menuName;\n\t\t\t\tmenuName.Format(_T(\"%s - %s\"), pAddin->DisplayName(), pAddin->m_PrePasteFunctions[0].m_csDisplayName);\n\n\t\t\t\t::AppendMenu(AllAddinsMenu, MF_ENABLED, nMenuId, menuName);\n\t\t\t\tbRet = true;\n\t\t\t\tnMenuId++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(bRet)\n\t{\n\t\tpMenu->InsertMenu(17, MF_BYPOSITION | MF_SEPARATOR);\n\t\tpMenu->InsertMenu(18, MF_BYPOSITION|MF_ENABLED|MF_STRING|MF_POPUP, (UINT_PTR)AllAddinsMenu, theApp.m_Language.GetString(\"Add_Ins\", \"Add-Ins\"));\n\t}\n\n\treturn bRet;\n}\n\nbool CDittoAddins::CallPrePasteFunction(int Id, IClip *pClip)\n{\n\tbool bRet = false;\n\tCFunctionLookup func;\n\tif(m_FunctionMap.Lookup(Id, func))\n\t{\n\t\tCDittoInfo DittoInfo;\n\t\tLoadDittoInfo(DittoInfo);\n\n\t\tbRet = func.m_pAddin->PrePasteFunction(DittoInfo, func.m_csFunctionName, pClip);\n\t}\n\n\treturn bRet;\n}\n\nvoid CDittoAddins::LoadDittoInfo(CDittoInfo &DittoInfo)\n{\n\tDittoInfo.m_csDatabasePath = CGetSetOptions::GetDBPath();\n\tDittoInfo.m_csLanguageCode = theApp.m_Language.GetLangCode();\t\n\tDittoInfo.m_csSqliteVersion = sqlite3_libversion();\n\tDittoInfo.m_hWndDitto = theApp.QPastehWnd();\n}\n\nvoid CDittoAddins::AboutScreenText(CStringArray &arr)\n{\n\tINT_PTR count = m_Addins.size();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tCDittoAddin *pAddin = m_Addins[i];\n\t\tif(pAddin)\n\t\t{\n\t\t\tCString csLine;\n\t\t\tcsLine.Format(_T(\"%s Ver: %d, Ver2: %d\"), pAddin->DisplayName(), pAddin->Version(), pAddin->PrivateVersion());\n\t\t\tarr.Add(csLine);\n\t\t\tINT_PTR subCount = pAddin->m_PrePasteFunctions.size();\n\t\t\tfor(int x = 0; x < subCount; x++)\n\t\t\t{\n\t\t\t\tCString csLine2;\n\t\t\t\tcsLine2.Format(_T(\"    %s (%s)\"), pAddin->m_PrePasteFunctions[x].m_csDisplayName, pAddin->m_PrePasteFunctions[x].m_csDetailDescription);\n\t\t\t\tarr.Add(csLine2);\n\t\t\t}\n\t\t\tarr.Add(\"\");\n\t\t}\n\t}\n}"
        },
        {
          "name": "DittoAddins.h",
          "type": "blob",
          "size": 0.626953125,
          "content": "#pragma once\n\n#include \"DittoAddin.h\"\n#include <vector>\n#include <afxtempl.h>\n\nclass CDittoAddins\n{\npublic:\n\tCDittoAddins(void);\n\t~CDittoAddins(void);\n\n\tbool LoadAll();\n\tbool UnloadAll();\n\n\tbool Loaded()\t{ return m_Addins.size() > 0; }\n\n\tbool AddPrePasteAddinsToMenu(CMenu *pMenu);\n\tbool CallPrePasteFunction(int Id, IClip *pClip);\n\tvoid AboutScreenText(CStringArray &arr);\n\nprotected:\n\tstd::vector<CDittoAddin*> m_Addins;\n\n\tclass CFunctionLookup\n\t{\n\tpublic:\n\t\tCDittoAddin *m_pAddin;\n\t\tCStringA m_csFunctionName;\n\t};\n\n\tCMap<int, int, CFunctionLookup, CFunctionLookup> m_FunctionMap;\n\nprotected:\n\tvoid LoadDittoInfo(CDittoInfo &DittoInfo);\n};\n"
        },
        {
          "name": "DittoChaiScript.cpp",
          "type": "blob",
          "size": 5.052734375,
          "content": "#include \"stdafx.h\"\n#include \"DittoChaiScript.h\"\n#include \"Shared\\TextConvert.h\"\n#include \"Md5.h\"\n#include \"Misc.h\"\n#include \"CP_Main.h\"\n#include \"Shared\\TextConvert.h\"\n\n#include <regex>\n\nCDittoChaiScript::CDittoChaiScript(IClip *pClip, std::string activeApp, std::string activeAppTitle)\n{\n\tm_pClip = pClip;\n\tm_activeApp = activeApp;\n\tm_activeAppTitle = activeAppTitle;\n}\n\n\nCDittoChaiScript::~CDittoChaiScript()\n{\n}\n\nstd::wstring CDittoChaiScript::GetUnicodeString()\n{\n\tstd::wstring s = _T(\"\");\n\tif (m_pClip)\n\t{\n\t\tIClipFormat* pFormat = m_pClip->Clips()->FindFormatEx(CF_UNICODETEXT);\n\t\tif (pFormat)\n\t\t{\n\t\t\ts = pFormat->GetAsCString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts = CTextConvert::AnsiToUnicode(GetAsciiString().c_str());\n\t\t}\n\t}\n\n\treturn s;\n}\n\nvoid CDittoChaiScript::SetUnicodeString(std::wstring stringVal)\n{\n\tif (m_pClip)\n\t{\n\t\tm_pClip->Clips()->DeleteAll();\n\n\t\tHGLOBAL hGlobal = ::NewGlobalP((LPVOID)stringVal.c_str(), (stringVal.size() + 1) * 2);\n\t\tASSERT(hGlobal);\n\n\t\tm_pClip->Clips()->AddNew(CF_UNICODETEXT, hGlobal);\n\t}\n}\n\nstd::string CDittoChaiScript::GetAsciiString()\n{\n\tstd::string s = \"\";\n\tif (m_pClip)\n\t{\n\t\tIClipFormat* pFormat = m_pClip->Clips()->FindFormatEx(CF_TEXT);\n\t\tif (pFormat)\n\t\t{\n\t\t\ts = pFormat->GetAsCStringA();\n\t\t}\n\t}\n\n\treturn s;\n}\n\nvoid CDittoChaiScript::SetAsciiString(std::string stringVal)\n{\n\tif (m_pClip)\n\t{\n\t\tm_pClip->Clips()->DeleteAll();\n\n\t\tHGLOBAL hGlobal = ::NewGlobalP((LPVOID)stringVal.c_str(), stringVal.size()+1);\n\t\tASSERT(hGlobal);\n\n\t\tm_pClip->Clips()->AddNew(CF_TEXT, hGlobal);\n\t}\n}\n\n\n\nstd::string CDittoChaiScript::GetClipMD5(std::string clipboardFormat)\n{\n\tCMd5 md5;\n\tmd5.MD5Init();\n\n\tstd::string md5String;\n\n\tif (m_pClip)\n\t{\n\t\tint formatId = GetFormatID(CTextConvert::AnsiToUnicode(clipboardFormat.c_str()));\n\n\t\tIClipFormat *pFormat = m_pClip->Clips()->FindFormatEx(formatId);\n\t\tif (pFormat)\n\t\t{\n\t\t\tSIZE_T size = ::GlobalSize(pFormat->Data());\n\t\t\tvoid* pv = GlobalLock(pFormat->Data());\n\t\t\tif (pv != NULL)\n\t\t\t{\t\t\t\t\n\t\t\t\tmd5.MD5Update((unsigned char*)pv, (unsigned int)size);\n\n\t\t\t\tGlobalUnlock(pFormat->Data());\n\n\t\t\t\tmd5String = md5.MD5FinalToString();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn md5String;\n}\n\nSIZE_T CDittoChaiScript::GetClipSize(std::string clipboardFormat)\n{\n\tSIZE_T size = 0;\n\tif (m_pClip)\n\t{\n\t\tint formatId = GetFormatID(CTextConvert::AnsiToUnicode(clipboardFormat.c_str()));\n\n\t\tIClipFormat *pFormat = m_pClip->Clips()->FindFormatEx(formatId);\n\t\tif (pFormat)\n\t\t{\n\t\t\tsize = ::GlobalSize(pFormat->Data());\n\t\t}\n\t}\n\n\treturn size;\n}\n\nBOOL CDittoChaiScript::FormatExists(std::string clipboardFormat)\n{\n\tBOOL exists = FALSE;\n\tif (m_pClip)\n\t{\n\t\tint formatId = GetFormatID(CTextConvert::AnsiToUnicode(clipboardFormat.c_str()));\n\n\t\tIClipFormat *pFormat = m_pClip->Clips()->FindFormatEx(formatId);\n\t\tif (pFormat)\n\t\t{\n\t\t\texists = TRUE;\n\t\t}\n\t}\n\n\treturn exists;\n}\n\nBOOL CDittoChaiScript::RemoveFormat(std::string clipboardFormat)\n{\n\tBOOL removed = FALSE;\n\tif (m_pClip)\n\t{\n\t\tint formatId = GetFormatID(CTextConvert::AnsiToUnicode(clipboardFormat.c_str()));\n\n\t\tif (m_pClip->Clips()->RemoveFormat(formatId))\n\t\t{\n\t\t\tremoved = TRUE;\n\t\t}\n\t}\n\n\treturn removed;\n}\n\nBOOL CDittoChaiScript::SetParentId(int parentId)\n{\n\tBOOL set = FALSE;\n\tif (m_pClip)\n\t{\t\t\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE lID = %d\"), parentId);\n\t\tif (q.eof() == false)\n\t\t{\n\t\t\tm_pClip->Parent(parentId);\t\t\n\n\t\t\tset = TRUE;\n\t\t}\n\t}\n\n\treturn set;\n}\n\nBOOL CDittoChaiScript::AsciiTextMatchesRegex(std::string regex)\n{\n\tBOOL matches = false;\n\n\tstd::wstring unicode = GetUnicodeString();\n\tstd::wregex integer(CTextConvert::AnsiToUnicode(regex.c_str()));\n\tif (regex_match(unicode, integer))\n\t{\n\t\tmatches = true;\n\t}\n\treturn matches;\n}\n\nvoid CDittoChaiScript::AsciiTextReplaceRegex(std::string regex, std::string replaceWith)\n{\n\tCStringA utf8 = CTextConvert::UnicodeToUTF8(GetUnicodeString().c_str());\n\tstd::regex integer(regex.c_str());\n\n\tCStringA newUtf8 = std::regex_replace(utf8.GetBuffer(), integer, replaceWith).c_str();\n\tif (utf8 != newUtf8)\n\t{\n\t\tCString uni = CTextConvert::Utf8ToUnicode(newUtf8).GetBuffer();\n\t\tSetUnicodeString(uni.GetBuffer());\n\t\tSetAsciiString(CTextConvert::UnicodeToAnsi(uni).GetBuffer());\n\t}\n}\n\n\nvoid CDittoChaiScript::SetMakeTopSticky()\n{\n\tm_pClip->SetSaveToDbSticky(AddToDbStickyEnum::MAKE_LAST_STICKY);\n}\n\nvoid CDittoChaiScript::SetMakeLastSticky()\n{\n\tm_pClip->SetSaveToDbSticky(AddToDbStickyEnum::MAKE_LAST_STICKY);\n}\n\nvoid CDittoChaiScript::SetReplaceTopSticky()\n{\n\tm_pClip->SetSaveToDbSticky(AddToDbStickyEnum::REPLACE_TOP_STICKY);\n}\n\nBOOL CDittoChaiScript::DescriptionMatchesRegex(std::string regex)\n{\n\tBOOL matches = false;\n\n\tif (m_pClip)\n\t{\n\t\tstd::wstring unicode = m_pClip->Description();\n\t\tstd::wregex integer(CTextConvert::AnsiToUnicode(regex.c_str()));\n\t\tif (regex_match(unicode, integer))\n\t\t{\n\t\t\tmatches = true;\n\t\t}\n\t}\n\n\treturn matches;\n}\n\nvoid CDittoChaiScript::DescriptionReplaceRegex(std::string regex, std::string replaceWith)\n{\r\n\tif (m_pClip)\n\t{\n\t\tCStringA utf8 = CTextConvert::UnicodeToUTF8(m_pClip->Description());\n\t\tstd::regex integer(regex.c_str());\n\n\t\tauto newAscii = std::regex_replace(utf8.GetBuffer(), integer, replaceWith);\n\n\t\tm_pClip->Description(CTextConvert::Utf8ToUnicode(newAscii.c_str()).GetBuffer());\n\t}\n}"
        },
        {
          "name": "DittoChaiScript.h",
          "type": "blob",
          "size": 1.111328125,
          "content": "#pragma once\n\n#include \"shared/IClip.h\"\n#include <string>\n\n\nclass CDittoChaiScript\n{\npublic:\n\tCDittoChaiScript(IClip *pClip, std::string activeApp, std::string activeAppTitle);\n\t~CDittoChaiScript();\n\n\tIClip *m_pClip;\n\tstd::string m_activeApp;\n\tstd::string m_activeAppTitle;\n\n\tstd::string GetAsciiString();\n\tvoid SetAsciiString(std::string stringVal);\n\n\tstd::wstring CDittoChaiScript::GetUnicodeString();\n\tvoid SetUnicodeString(std::wstring stringVal);\n\n\tstd::string GetClipMD5(std::string clipboardFormat);\n\tSIZE_T GetClipSize(std::string clipboardFormat);\n\n\tstd::string GetActiveApp() { return m_activeApp; }\n\tstd::string GetActiveAppTitle() { return m_activeAppTitle; }\n\n\tBOOL RemoveFormat(std::string clipboardFormat);\n\tBOOL FormatExists(std::string clipboardFormat);\n\tBOOL SetParentId(int parentId);\n\tBOOL AsciiTextMatchesRegex(std::string regex);\n\tvoid AsciiTextReplaceRegex(std::string regex, std::string replaceWith);\n\n\tBOOL DescriptionMatchesRegex(std::string regex);\n\tvoid DescriptionReplaceRegex(std::string regex, std::string replaceWith);\n\n\tvoid SetMakeTopSticky();\n\tvoid SetMakeLastSticky();\n\tvoid SetReplaceTopSticky();\n};\n\n"
        },
        {
          "name": "DittoCopyBuffer.cpp",
          "type": "blob",
          "size": 5.453125,
          "content": "#include \"stdafx.h\"\n#include \".\\dittocopybuffer.h\"\n#include \"CP_Main.h\"\n#include <Mmsystem.h> //play sound\n\n\nCDittoCopyBuffer::CDittoCopyBuffer() :\n\tm_ActiveTimer(TRUE, TRUE),\n\tm_RestoreTimer(TRUE, TRUE),\n\tm_Pasting(TRUE, TRUE)\n{\n\tm_bActive = false;\n\tm_dwLastPaste = 0;\n}\n\nCDittoCopyBuffer::~CDittoCopyBuffer(void)\n{\n}\n\n\nbool CDittoCopyBuffer::StartCopy(long lCopyBuffer, bool bCut)\n{\n\tLog(StrF(_T(\"Start of Ditto Copy buffer = %d\"), lCopyBuffer));\n\n\t//Tell the timer thread to exit\n\tm_ActiveTimer.SetEvent();\n\t//Make sure the end copy thread has exited\n\tEndRestoreThread();\n\n\tif(m_SavedClipboard.Save(FALSE))\n\t{\n\t\tif(bCut)\n\t\t{\n\t\t\ttheApp.m_activeWnd.SendCut();\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttheApp.m_activeWnd.SendCopy(CopyReasonEnum::COPY_TO_BUFFER);\n\t\t}\n\n\t\t//Create a thread to track if they have copied anything, if thread has exited before they have\n\t\t//copied something then the copy buffer copy is canceled\n\t\tAfxBeginThread(CDittoCopyBuffer::StartCopyTimer, (LPVOID)this, THREAD_PRIORITY_LOWEST);\n\n\t\tm_bActive = true;\n\t\tm_lCurrentDittoBuffer = lCopyBuffer;\n\t}\n\telse\n\t{\n\t\tLog(_T(\"Start of Ditto Failed to save buffer\"));\n\t}\n\n\treturn true;\n}\n\nUINT CDittoCopyBuffer::StartCopyTimer(LPVOID pParam)\n{\n\tCDittoCopyBuffer *pBuffer = (CDittoCopyBuffer*)pParam;\n\tif(pBuffer)\n\t{\n\t\tpBuffer->m_ActiveTimer.ResetEvent();\n\n\t\tDWORD dRes = WaitForSingleObject(pBuffer->m_ActiveTimer, 1500);\n\t\tif(dRes == WAIT_TIMEOUT)\n\t\t{\n\t\t\tpBuffer->m_SavedClipboard.Clear();\n\t\t\tpBuffer->m_bActive = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool CDittoCopyBuffer::EndCopy(long lID)\n{\n\tif(m_lCurrentDittoBuffer < 0 || m_lCurrentDittoBuffer >= 10)\n\t{\n\t\tLog(_T(\"tried to save copy buffer but copy buffer is empty\"));\n\t\treturn false;\n\t}\n\n\tif(m_bActive == false)\n\t{\n\t\tLog(_T(\"Current buffer is not active can't save copy buffer to db\"));\n\t\treturn false;\n\t}\n\n\tm_ActiveTimer.SetEvent();\n\tm_bActive = false;\n\n\tLog(StrF(_T(\"Start - Ditto EndCopy buffer = %d\"), m_lCurrentDittoBuffer));\n\n\tbool bRet = false;\n\n\t//put the data that we stored at the start of this action back on the standard clipboard\n\tm_SavedClipboard.Restore();\n\t\n\tif(PutClipOnDittoCopyBuffer(lID, m_lCurrentDittoBuffer))\n\t{\n\t\tLog(StrF(_T(\"Ditto end copy, saved clip successfully Clip ID = %d\"), lID));\t\n\n\t\tbRet = true;\n\t}\n\telse\n\t{\n\t\tLog(StrF(_T(\"Ditto end copy, ERROR associating clip to Copy buffer ID = %d\"), lID));\n\t}\n\n\treturn bRet;\n}\n\nbool CDittoCopyBuffer::PutClipOnDittoCopyBuffer(long lClipId, long lBuffer)\n{\n\ttry\n\t{\n\t\t//enclose in brackets so the query closes before we update below\n\t\t{\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM CopyBuffers WHERE lCopyBuffer = %d\"), lBuffer);\n\t\t\tif(q.eof())\n\t\t\t{\n\t\t\t\ttheApp.m_db.execDMLEx(_T(\"INSERT INTO CopyBuffers VALUES(NULL, -1, %d);\"), lBuffer);\n\t\t\t}\n\t\t}\n\n\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE CopyBuffers SET lClipID = %d WHERE lCopyBuffer = %d\"), lClipId, lBuffer);\n\n\t\tCCopyBufferItem Item;\n\t\tCGetSetOptions::GetCopyBufferItem(lBuffer, Item);\n\t\tif(Item.m_bPlaySoundOnCopy)\n\t\t{\n\t\t\tPlaySound(_T(\"ding.wav\"), NULL, SND_FILENAME|SND_ASYNC);\n\t\t}\n\n\t\treturn true;\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\treturn false;\n}\n\nbool CDittoCopyBuffer::PastCopyBuffer(long lCopyBuffer)\n{\n\t//Can't paste while another is still active\n\tif(WaitForSingleObject(m_Pasting, 1) == WAIT_TIMEOUT)\n\t{\n\t\tLog(_T(\"Copy Buffer pasted to fast\"));\n\t\treturn false;\n\t}\n\n\tm_RestoreTimer.ResetEvent();\n\tm_Pasting.ResetEvent();\n\tbool bRet = false;\n\n\tLog(StrF(_T(\"Start - PastCopyBuffer buffer = %d\"), m_lCurrentDittoBuffer));\n\n\ttry\n\t{\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT Main.lID FROM Main \")\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"INNER JOIN CopyBuffers ON CopyBuffers.lClipID = Main.lID \")\n\t\t\t\t\t\t\t\t\t\t\t\t\t_T(\"WHERE CopyBuffers.lCopyBuffer = %d\"), lCopyBuffer);\n\n\t\tif(q.eof() == false)\n\t\t{\n\t\t\tm_pClipboard = new CClipboardSaveRestoreCopyBuffer;\n\t\t\tif(m_pClipboard)\n\t\t\t{\n\t\t\t\t//Save the clipboard, \n\t\t\t\t//then put the new data on the clipboard\n\t\t\t\t//then send a paste\n\t\t\t\t//then wait a little and restore the original clipboard data\n\t\t\t\tif(m_pClipboard->Save(false))\n\t\t\t\t{\n\t\t\t\t\ttheApp.m_pMainFrame->PasteOrShowGroup(q.getIntField(_T(\"lID\")), -1, FALSE, TRUE, false);\n\n\t\t\t\t\tm_pClipboard->m_lRestoreDelay = CGetSetOptions::GetDittoRestoreClipboardDelay();\n\n\t\t\t\t\tLog(StrF(_T(\"PastCopyBuffer sent paste, starting thread to restore clipboard, Delay = %d\"), m_pClipboard->m_lRestoreDelay));\n\n\t\t\t\t\tAfxBeginThread(CDittoCopyBuffer::DelayRestoreClipboard, (LPVOID)this, THREAD_PRIORITY_LOWEST);\n\n\t\t\t\t\tbRet = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog(_T(\"PastCopyBuffer failed to save clipboard\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tCATCH_SQLITE_EXCEPTION\n\n\tif(bRet == false)\n\t\tm_Pasting.SetEvent();\n\n\treturn bRet;\n}\n\nvoid CDittoCopyBuffer::EndRestoreThread()\n{\n\t//Tell the thread to stop waiting and restore the clipboard\n\tm_RestoreTimer.SetEvent();\n\n\t//make sure it's ended\n\tWaitForSingleObject(m_Pasting, 5000);\n}\n\nUINT CDittoCopyBuffer::DelayRestoreClipboard(LPVOID pParam)\n{\n\tCDittoCopyBuffer *pBuffer = (CDittoCopyBuffer*)pParam;\n\tif(pBuffer)\n\t{\n\t\tCClipboardSaveRestoreCopyBuffer *pLocalClipboard = pBuffer->m_pClipboard;\n\n\t\tDWORD dRes = WaitForSingleObject(pBuffer->m_RestoreTimer, pLocalClipboard->m_lRestoreDelay);\n\n\t\tif(GetKeyState(VK_SHIFT) & 0x8000)\n\t\t{\n\t\t\tLog(_T(\"Shift key is down not restoring clipboard, custom Buffer on normal clipboard\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pLocalClipboard->Restore())\n\t\t\t{\n\t\t\t\tLog(_T(\"CDittoCopyBuffer::DelayRestoreClipboard Successfully\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(_T(\"CDittoCopyBuffer::DelayRestoreClipboard Failed to restore\"));\n\t\t\t}\n\t\t}\n\n\t\tdelete pLocalClipboard;\n\t\tpLocalClipboard = NULL;\n\n\t\tpBuffer->m_Pasting.SetEvent();\n\t}\n\n\treturn TRUE;\n}"
        },
        {
          "name": "DittoCopyBuffer.h",
          "type": "blob",
          "size": 0.892578125,
          "content": "#pragma once\n\n#include \"ClipboardSaveRestore.h\"\n#include \"afxmt.h\"\n\nclass CClipboardSaveRestoreCopyBuffer : public CClipboardSaveRestore\n{\npublic:\n\tCClipboardSaveRestoreCopyBuffer()\n\t{\n\t\tm_lRestoreDelay = 0;\n\t}\n\tlong m_lRestoreDelay;\n};\n\nclass CDittoCopyBuffer\n{\npublic:\n\tCDittoCopyBuffer();\n\t~CDittoCopyBuffer(void);\n\n\tbool Active()\t{ return m_bActive; }\n\tbool StartCopy(long lCopyBuffer, bool bCut = false);\n\tbool EndCopy(long lID);\n\tbool PastCopyBuffer(long lCopyBuffer);\n\n\tstatic bool PutClipOnDittoCopyBuffer(long lClipId, long lBuffer);\n\tstatic UINT DelayRestoreClipboard(LPVOID pParam);\n\tstatic UINT StartCopyTimer(LPVOID pParam);\n\nprotected:\n\tvoid EndRestoreThread();\n\nprotected:\n\tlong m_lCurrentDittoBuffer;\n\tCClipboardSaveRestore m_SavedClipboard;\n\tbool m_bActive;\n\tDWORD m_dwLastPaste;\n\tCEvent m_ActiveTimer;\n\tCEvent m_RestoreTimer;\n\tCEvent m_Pasting;\n\tCClipboardSaveRestoreCopyBuffer *m_pClipboard;\n};\n"
        },
        {
          "name": "DittoDropTarget.cpp",
          "type": "blob",
          "size": 1.3056640625,
          "content": "// DittoDropTarget.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"DittoDropTarget.h\"\n#include \".\\dittodroptarget.h\"\n\n\n// CDittoDropTarget\n\nIMPLEMENT_DYNAMIC(CDittoDropTarget, COleDropTarget)\nCDittoDropTarget::CDittoDropTarget()\n{\n\tm_pTarget = NULL;\n}\n\nCDittoDropTarget::~CDittoDropTarget()\n{\n}\n\nBEGIN_MESSAGE_MAP(CDittoDropTarget, COleDropTarget)\nEND_MESSAGE_MAP()\n\nBOOL CDittoDropTarget::OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point)\n{\n\tif(m_pTarget)\n\t\treturn m_pTarget->Drop(pDataObject, dropEffect, point);\n\n\treturn COleDropTarget::OnDrop(pWnd, pDataObject, dropEffect, point);\n}\n\n\nDROPEFFECT CDittoDropTarget::OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\n{\n\tif(m_pTarget)\n\t\treturn m_pTarget->DragEnter(pDataObject, dwKeyState, point);\n\n\treturn COleDropTarget::OnDragEnter(pWnd, pDataObject, dwKeyState, point);\n}\n\nvoid CDittoDropTarget::OnDragLeave(CWnd* pWnd)\n{\n\tif(m_pTarget)\n\t\treturn m_pTarget->DragLeave();\n\n\tCOleDropTarget::OnDragLeave(pWnd);\n}\n\nDROPEFFECT CDittoDropTarget::OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\n{\n\tif(m_pTarget)\n\t\treturn m_pTarget->DragOver(pDataObject, dwKeyState, point);\n\n\treturn COleDropTarget::OnDragOver(pWnd, pDataObject, dwKeyState, point);\n}\n"
        },
        {
          "name": "DittoDropTarget.h",
          "type": "blob",
          "size": 1.0390625,
          "content": "\n#pragma once\n\n\n// CDittoDropTarget command target\n\nclass IDittoDropTarget\n{\npublic:\n\tvirtual DROPEFFECT DragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) = 0;\n\tvirtual DROPEFFECT DragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) = 0;\n\tvirtual void DragLeave(void) = 0;\n\tvirtual BOOL Drop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point) = 0;\n};\n\n\nclass CDittoDropTarget : public COleDropTarget\n{\n\tDECLARE_DYNAMIC(CDittoDropTarget)\n\npublic:\n\tCDittoDropTarget();\n\tvirtual ~CDittoDropTarget();\n\n\tvoid SetDropTarget(IDittoDropTarget *pTarget) { m_pTarget = pTarget; }\n\nprotected:\n\tIDittoDropTarget *m_pTarget;\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n\npublic:\n\tvirtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\n\tvirtual void OnDragLeave(CWnd* pWnd);\n\tvirtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\n\tvirtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);\n};\n\n\n"
        },
        {
          "name": "DittoPopupWindow.cpp",
          "type": "blob",
          "size": 2.953125,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"DittoPopupWindow.h\"\r\n\r\n\r\nCDittoPopupWindow::CDittoPopupWindow()\r\n{\r\n\tm_groupId = -1;\r\n}\r\n\r\n\r\nCDittoPopupWindow::~CDittoPopupWindow()\r\n{\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CDittoPopupWindow, CWndEx)\r\n\tON_WM_CREATE()\r\n\tON_WM_SIZE()\r\n\tON_WM_CTLCOLOR()\r\n\tON_WM_LBUTTONUP()\r\nEND_MESSAGE_MAP()\r\n\r\nint CDittoPopupWindow::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CWndEx::OnCreate(lpCreateStruct) == -1)\r\n\t{\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tCWndEx::SetCaptionOn(CAPTION_TOP, false, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\t\t\r\n\tm_font.CreateFont(-m_DittoWindow.m_dpi.Scale(12), 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"MS Sans Serif\"));\r\n\tm_textLabel.Create(_T(\"test\"), WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), this);\r\n\tm_textLabel.SetFont(&m_font);\r\n\t\r\n\r\n\tm_progressWnd.Create(WS_CHILD|PBS_SMOOTH, CRect(0, 0, 0, 0), this, 2);\r\n\r\n\tm_progressWnd.SetRange(0, 100);\r\n\r\n\tSetWindowText(_T(\"Running Ditto Updates\"));\r\n\r\n\t//m_textLabel.SetWindowText(_T(\"test\"));\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CDittoPopupWindow::UpdateText(CString text)\r\n{\r\n\tm_textLabel.SetWindowText(text);\r\n\r\n\tCRect rect;\r\n\tm_textLabel.GetWindowRect(&rect);\r\n\tScreenToClient(&rect);\r\n\tInvalidateRect(&rect);\r\n\tUpdateWindow();\r\n\r\n\tPumpMessages();\r\n}\r\n\r\n\r\nvoid CDittoPopupWindow::SetProgressBarPercent(int percent)\r\n{\r\n\tif(::IsWindowVisible(m_progressWnd.m_hWnd) == FALSE)\r\n\t{\r\n\t\tm_progressWnd.ShowWindow(SW_SHOW);\r\n\r\n\t\tCRect size;\r\n\t\tGetClientRect(size);\r\n\t\tDoSize(size.Width(), size.Height());\r\n\t}\r\n\tm_progressWnd.SetPos(percent);\r\n\tPumpMessages();\r\n}\r\n\r\nvoid CDittoPopupWindow::HideProgressBar()\r\n{\r\n\tm_progressWnd.ShowWindow(SW_HIDE);\r\n\tPumpMessages();\r\n\r\n\tCRect size;\r\n\tGetClientRect(size);\r\n\tDoSize(size.Width(), size.Height());\r\n}\r\n\r\nvoid CDittoPopupWindow::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCWndEx::OnSize(nType, cx, cy);\r\n\tDoSize(cx, cy);\t\r\n}\r\n\r\nvoid CDittoPopupWindow::DoSize(int cx, int cy)\r\n{\r\n\tif(m_textLabel.m_hWnd != NULL)\r\n\t{\r\n\t\tint bottom = 0;\r\n\t\tif(::IsWindowVisible(m_progressWnd.m_hWnd))\r\n\t\t{\r\n\t\t\tbottom = 50;\r\n\t\t}\r\n\t\tm_textLabel.MoveWindow(10, 10, cx-20, cy-bottom);\r\n\t\tthis->Invalidate();\r\n\t}\r\n\r\n\tif(m_progressWnd.m_hWnd != NULL)\r\n\t{\r\n\t\tm_progressWnd.MoveWindow(10, cy-40, cx-20, 30);\r\n\t}\t\r\n}\r\n\r\nHBRUSH CDittoPopupWindow::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\r\n{\r\n\tif (pWnd->GetDlgCtrlID() == 0xffff)\r\n\t{\r\n\t\tpDC->SetBkMode(TRANSPARENT);\r\n\t\treturn reinterpret_cast<HBRUSH>(::GetStockObject(NULL_BRUSH));\r\n\t}\r\n\telse\r\n\t\treturn CWndEx::OnCtlColor(pDC, pWnd, nCtlColor);\r\n}\r\n\r\nvoid CDittoPopupWindow::PumpMessages()\r\n{\r\n\tint nLoops = 0;\r\n\tMSG msg;\r\n\twhile (::PeekMessage(&msg, m_hWnd, 0, 0, PM_REMOVE))\r\n\t{\r\n\t\tTranslateMessage(&msg);\r\n\t\tDispatchMessage(&msg);\r\n\r\n\t\tnLoops++;\r\n\t\tif (nLoops > 100)\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid CDittoPopupWindow::OnLButtonUp(UINT nFlags, CPoint point)\r\n{\r\n\tif(m_groupId > 0)\r\n\t{\r\n\t\tCWnd *pParent = this->GetParent();\r\n\t\tif(pParent)\r\n\t\t{\r\n\t\t\tpParent->PostMessageW(WM_SHOW_DITTO_GROUP, m_groupId, 0);\r\n\t\t}\r\n\t}\r\n}"
        },
        {
          "name": "DittoPopupWindow.h",
          "type": "blob",
          "size": 0.6767578125,
          "content": "#pragma once\n#include \"WndEx.h\"\n\nclass CDittoPopupWindow : public CWndEx\n{\npublic:\n\tCDittoPopupWindow();\n\t~CDittoPopupWindow();\n\n\tvoid UpdateText(CString text);\n\tvoid SetProgressBarPercent(int percent);\n\tvoid HideProgressBar();\n\n\tvoid SetCopyToGroupId(int groupId) { m_groupId = groupId; }\n\t\nprotected:\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\n\tafx_msg void OnLButtonUp(UINT nFlags, CPoint point);\n\n\n\tCStatic m_textLabel;\n\tCProgressCtrl m_progressWnd;\n\tCFont m_font;\n\tint m_groupId;\n\n\tvoid PumpMessages();\n\n\tvoid DoSize(int cx, int cy);\n};\n\n"
        },
        {
          "name": "DittoSetup",
          "type": "tree",
          "content": null
        },
        {
          "name": "DittoWindow.cpp",
          "type": "blob",
          "size": 26.126953125,
          "content": "#include \"stdafx.h\"\r\n#include \".\\dittowindow.h\"\r\n#include \"CP_Main.h\"\r\n#include \"Options.h\"\r\n#include <ShellScalingAPI.h>\r\n\r\nCDittoWindow::CDittoWindow(void)\r\n{\r\n\tm_captionBorderWidth = m_dpi.Scale(25);\r\n\r\n\tm_borderSize = 2;\r\n\tm_bMouseOverChevron = false;\r\n\tm_bMouseDownOnChevron = false;\r\n\tm_bMouseDownOnClose = false;\r\n\tm_bMouseOverClose = false;\r\n\tm_bMouseDownOnMinimize = false;\r\n\tm_bMouseOverMinimize = false;\r\n\tm_bMouseDownOnMaximize = false;\r\n\tm_bMouseOverMaximize = false;\r\n\tm_bDrawClose = true;\r\n\tm_bDrawChevron = true;\r\n\tm_bDrawMaximize = true;\r\n\tm_bDrawMinimize = true;\r\n\tm_bMinimized = false;\r\n\tm_crCloseBT.SetRectEmpty();\r\n\tm_crChevronBT.SetRectEmpty();\r\n\tm_crMaximizeBT.SetRectEmpty();\r\n\tm_crMinimizeBT.SetRectEmpty();\r\n\tm_CaptionColorLeft = RGB(255, 255, 255);\r\n\tm_CaptionColorRight = RGB(204, 204, 204);\r\n\tm_CaptionTextColor = RGB(191, 191, 191);\r\n\tm_border = RGB(204, 204, 204);\r\n\tm_sendWMClose = true;\r\n\tm_customWindowTitle = _T(\"\");\r\n\tm_useCustomWindowTitle = false;\r\n\tm_buttonDownOnCaption = false;\r\n\tm_crFullSizeWindow.SetRectEmpty();\t\r\n\tm_captionPosition = CAPTION_RIGHT;\r\n\t\r\n}\r\n\r\nCDittoWindow::~CDittoWindow(void)\r\n{\r\n}\r\n\r\nvoid CDittoWindow::DoCreate(CWnd *pWnd)\r\n{\r\n\tm_dpi.SetHwnd(pWnd->m_hWnd);\r\n\t\r\n\r\n\tm_VertFont.CreateFont(-m_dpi.Scale(19), 0, -900, 0, 400, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\t\t\t\t\t\tOUT_DEFAULT_PRECIS,\tCLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, \r\n\t\t\t\t\t\t\tDEFAULT_PITCH|FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tm_HorFont.CreateFont(-m_dpi.Scale(19), 0, 0, 0, 500, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\t\t\t\t\tOUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\r\n\t\t\t\t\t\tDEFAULT_PITCH|FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tSetTitleTextHeight(pWnd);\r\n\t\r\n\tm_closeButton.LoadStdImageDPI(m_dpi.GetDPI(), Close_Black_16_16, Close_Black_20_20, Close_Black_24_24, Close_Black_28, Close_Black_32_32, _T(\"PNG\"), close_36, close_40, close_44, close_48, close_52, close_56);\r\n\tm_chevronRightButton.LoadStdImageDPI(m_dpi.GetDPI(), ChevronRight_Black_16_16, ChevronRight_Black_20_20, ChevronRight_Black_24_24, ChevronRight_Black_28, ChevronRight_Black_32_32, _T(\"PNG\"), ChevronRight_Black_36, ChevronRight_Black_40, ChevronRight_Black_44, ChevronRight_Black_48, ChevronRight_Black_52, ChevronRight_Black_56);\r\n\tm_chevronLeftButton.LoadStdImageDPI(m_dpi.GetDPI(), ChevronLeft_Black_16_16, ChevronLeft_Black_20_20, ChevronLeft_Black_24_24, ChevronLeft_Black_28, ChevronLeft_Black_32_32, _T(\"PNG\"), ChevronLeft_Black_36, ChevronLeft_Black_40, ChevronLeft_Black_44, ChevronLeft_Black_48, ChevronLeft_Black_52, ChevronLeft_Black_56);\r\n\tm_maximizeButton.LoadStdImageDPI(m_dpi.GetDPI(), IDB_MAXIMIZE_16_16, maximize_20, maximize_24, maximize_28, maximize_32, _T(\"PNG\"), maximize_36, maximize_40, maximize_44, maximize_48, maximize_52, maximize_56);\r\n\tm_minimizeButton.LoadStdImageDPI(m_dpi.GetDPI(), minimize_16, minimize_20, minimize_24, minimize_28, minimize_32, _T(\"PNG\"), minimize_36, minimize_40, minimize_44, minimize_48, minimize_52, minimize_56);\r\n\t//m_windowIcon.LoadStdImageDPI(NewWindowIcon_24_14, NewWindowIcon_30, NewWindowIcon_36, NewWindowIcon_48, _T(\"PNG\"));\r\n}\r\n\r\nvoid CDittoWindow::DoNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)\r\n{\r\n\t//Decrease the client area\t\r\n\tif (m_captionPosition == CAPTION_LEFT)\r\n\t\tlpncsp->rgrc[0].left += m_captionBorderWidth;\r\n\telse\r\n\t\tlpncsp->rgrc[0].left += m_borderSize;\r\n\r\n\tif (m_captionPosition == CAPTION_TOP)\r\n\t\tlpncsp->rgrc[0].top += m_captionBorderWidth;\r\n\telse\r\n\t\tlpncsp->rgrc[0].top += m_borderSize;\r\n\r\n\tif (m_captionPosition == CAPTION_RIGHT)\r\n\t\tlpncsp->rgrc[0].right -= m_captionBorderWidth;\r\n\telse\r\n\t\tlpncsp->rgrc[0].right -= m_borderSize;\r\n\r\n\tif (m_captionPosition == CAPTION_BOTTOM)\r\n\t\tlpncsp->rgrc[0].bottom -= m_captionBorderWidth;\r\n\telse\r\n\t\tlpncsp->rgrc[0].bottom -= m_borderSize;\r\n}\r\n\r\nUINT CDittoWindow::DoNcHitTest(CWnd *pWnd, CPoint point) \r\n{\r\n\tCRect crWindow;\r\n\tpWnd->GetWindowRect(crWindow);\r\n\r\n\tif(crWindow.PtInRect(point) == false)\r\n\t{\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tint x = point.x - crWindow.left;\r\n\tint y = point.y - crWindow.top;\r\n\r\n\tCPoint myLocal(x, y);\r\n\r\n\t//http://stackoverflow.com/questions/521147/the-curious-problem-of-the-missing-wm-nclbuttonup-message-when-a-window-isnt-ma\r\n\t//workaround for l button up not coming after a lbutton down\r\n\tif (m_crCloseBT.PtInRect(myLocal) ||\r\n\t\tm_crChevronBT.PtInRect(myLocal) ||\r\n\t\tm_crMinimizeBT.PtInRect(myLocal) ||\r\n\t\tm_crMaximizeBT.PtInRect(myLocal))\r\n\t{\r\n\t\treturn HTBORDER;;\r\n\t}\r\n\r\n\tif(m_bMinimized == false)\r\n\t{\r\n\t\tif ((point.y < crWindow.top + m_borderSize * 4) &&\r\n\t\t\t(point.x < crWindow.left + m_borderSize * 4))\r\n\t\t\treturn HTTOPLEFT;\r\n\t\telse if ((point.y < crWindow.top + m_borderSize * 4) &&\r\n\t\t\t(point.x > crWindow.right - m_borderSize * 4))\r\n\t\t\treturn HTTOPRIGHT;\r\n\t\telse if ((point.y > crWindow.bottom - m_borderSize * 4) &&\r\n\t\t\t(point.x > crWindow.right - m_borderSize * 4))\r\n\t\t\treturn HTBOTTOMRIGHT;\r\n\t\telse if ((point.y > crWindow.bottom - m_borderSize * 4) &&\r\n\t\t\t(point.x < crWindow.left + m_borderSize * 4))\r\n\t\t\treturn HTBOTTOMLEFT;\r\n\t}\r\n\r\n\tif((((m_captionPosition == CAPTION_TOP) || (m_captionPosition == CAPTION_BOTTOM)) &&\r\n\t\t(m_bMinimized)) == false)\r\n\t{\r\n\t\tif (point.y < crWindow.top + m_borderSize * 2)\r\n\t\t\treturn HTTOP;\r\n\t\tif (point.y > crWindow.bottom - m_borderSize * 2)\r\n\t\t\treturn HTBOTTOM;\r\n\t}\r\n\r\n\tif((((m_captionPosition == CAPTION_LEFT) || (m_captionPosition == CAPTION_RIGHT)) &&\r\n\t\t(m_bMinimized)) == false)\r\n\t{\r\n\t\tif (point.x > crWindow.right - m_borderSize * 2)\r\n\t\t\treturn HTRIGHT;\r\n\t\tif (point.x < crWindow.left + m_borderSize * 2)\r\n\t\t\treturn HTLEFT;\r\n\t}\r\n\r\n\tif (m_captionPosition == CAPTION_RIGHT)\r\n\t{\r\n\t\tif (point.x > crWindow.right - m_captionBorderWidth)\r\n\t\t\treturn HTCAPTION;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_BOTTOM)\r\n\t{\r\n\t\tif(point.y > crWindow.bottom - m_captionBorderWidth)\r\n\t\t\treturn HTCAPTION;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_LEFT)\r\n\t{\r\n\t\tif (point.x < crWindow.left + m_captionBorderWidth)\r\n\t\t\treturn HTCAPTION;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_TOP)\r\n\t{\r\n\t\tif (point.y < crWindow.top + m_captionBorderWidth)\r\n\t\t\treturn HTCAPTION;\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\nint CDittoWindow::IndexToPos(int index, bool horizontal)\r\n{\r\n\tswitch (index)\r\n\t{\r\n\tcase 0:\r\n\t\tif (horizontal)\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(24);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(8);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tif (horizontal)\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(48);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(32);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 2:\r\n\r\n\t\tif (horizontal)\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(72);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(56);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tif (horizontal)\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(96);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(80);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tif (horizontal)\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(104);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_dpi.Scale(104);\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CDittoWindow::DoNcPaint(CWnd *pWnd)\r\n{\r\n\tCWindowDC dc(pWnd);\r\n\r\n\tCRect rcFrame;\r\n\tpWnd->GetWindowRect(rcFrame);\r\n\tpWnd->ScreenToClient(rcFrame);\r\n\r\n\tCRect rc;\r\n\tpWnd->GetClientRect(rc);\r\n\tpWnd->ClientToScreen(rc);\r\n\r\n\tlong lWidth = rcFrame.Width();\r\n\r\n\t// Draw the window border\r\n\tCRect rcBorder(0, 0, lWidth, rcFrame.Height());\r\n\r\n\tint border = m_dpi.Scale(2);\r\n\tint widthHeight = m_dpi.Scale(16);\r\n\r\n\tfor (int x = 0; x < border; x++)\r\n\t{\r\n\t\tdc.Draw3dRect(rcBorder, m_border, m_border);\r\n\t\trcBorder.DeflateRect(1, 1, 1, 1);\r\n\t}\r\n\r\n\tint iconArea = 0;\r\n\tint index = 0;\r\n\tint closeIndex = 0;\r\n\tint chevronIndex = 0;\r\n\tint minIndex = 0;\r\n\tint maxIndex = 0;\r\n\r\n\tif (m_bDrawClose)\r\n\t{\r\n\t\ticonArea += m_dpi.Scale(32);\r\n\t\tcloseIndex = index++;\r\n\t}\r\n\tif (m_bDrawChevron)\r\n\t{\r\n\t\ticonArea += m_dpi.Scale(32);\r\n\t\tchevronIndex = index++;\r\n\t}\r\n\tif (m_bDrawMaximize)\r\n\t{\r\n\t\ticonArea += m_dpi.Scale(32);\r\n\t\tmaxIndex = index++;\r\n\t}\r\n\tif (m_bDrawMinimize)\r\n\t{\r\n\t\ticonArea += m_dpi.Scale(32);\r\n\t\tminIndex = index++;\r\n\t}\r\n\t\r\n\tCRect leftRect;\r\n\tCRect rightRect;\r\n\tCRect textRect;\t\r\n\r\n\tBOOL bVertical = FALSE;\r\n\tif(m_captionPosition == CAPTION_RIGHT)\r\n\t{\r\n\t\trightRect.SetRect(rcBorder.right - (m_captionBorderWidth - border), rcBorder.top, rcBorder.right, rcBorder.top + IndexToPos(index, false));\r\n\t\tleftRect.SetRect(rcBorder.right - (m_captionBorderWidth - border), rcBorder.top + IndexToPos(index, false), rcBorder.right, rcBorder.bottom);\r\n\t\t\r\n\t\ttextRect.SetRect(rcBorder.right, rightRect.bottom + m_dpi.Scale(10), rcBorder.right - m_captionBorderWidth, rcBorder.bottom - m_dpi.Scale(1));\r\n\r\n\t\tint left = rightRect.left;\r\n\t\tint right = rightRect.right;\r\n\r\n\t\tint top = IndexToPos(closeIndex, false);\r\n\t\tm_crCloseBT.SetRect(left, top, right, top+ widthHeight);\r\n\r\n\t\ttop = IndexToPos(chevronIndex, false);\r\n\t\tm_crChevronBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\ttop = IndexToPos(maxIndex, false);\r\n\t\tm_crMaximizeBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\ttop = IndexToPos(minIndex, false);\r\n\t\tm_crMinimizeBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\r\n\t\tm_crWindowIconBT.SetRect(rcBorder.right - m_dpi.Scale(24), rcBorder.bottom - m_dpi.Scale(28), rcBorder.right - m_dpi.Scale(2), rcBorder.bottom);\r\n\r\n\t\tbVertical = TRUE;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_LEFT)\r\n\t{\r\n\t\trightRect.SetRect(rcBorder.left, rcBorder.top, rcBorder.left + m_captionBorderWidth - border, rcBorder.top + IndexToPos(index, false));\r\n\t\tleftRect.SetRect(rcBorder.left, rcBorder.top + IndexToPos(index, false), rcBorder.left + m_captionBorderWidth - border, rcBorder.bottom);\r\n\r\n\t\ttextRect.SetRect(rcBorder.left + m_captionBorderWidth - m_dpi.Scale(0), rightRect.bottom + m_dpi.Scale(10), rcBorder.left - m_dpi.Scale(5), rcBorder.bottom - m_dpi.Scale(1));\r\n\r\n\t\tint left = rightRect.left;\r\n\t\tint right = rightRect.right;\r\n\r\n\t\tint top = IndexToPos(closeIndex, false);\r\n\t\tm_crCloseBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\ttop = IndexToPos(chevronIndex, false);\r\n\t\tm_crChevronBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\ttop = IndexToPos(maxIndex, false);\r\n\t\tm_crMaximizeBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\ttop = IndexToPos(minIndex, false);\r\n\t\tm_crMinimizeBT.SetRect(left, top, right, top + widthHeight);\r\n\r\n\t\tm_crWindowIconBT.SetRect(rcBorder.left + m_dpi.Scale(0), rcBorder.bottom - m_dpi.Scale(28), rcBorder.left + m_dpi.Scale(25), rcBorder.bottom);\r\n\r\n\t\tbVertical = TRUE;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_TOP)\r\n\t{\r\n\t\tleftRect.SetRect(rcBorder.left, rcBorder.top, rcBorder.right - IndexToPos(index-1, true)- m_dpi.Scale(8), m_captionBorderWidth);\r\n\t\trightRect.SetRect(leftRect.right, rcBorder.top, rcBorder.right, m_captionBorderWidth);\r\n\r\n\t\ttextRect.SetRect(leftRect.right, leftRect.top, leftRect.right, leftRect.bottom);\r\n\r\n\t\tint top = rightRect.top;\r\n\t\tint bottom = rightRect.bottom;\r\n\r\n\t\tint left = rcBorder.right - IndexToPos(closeIndex, true);\r\n\t\tm_crCloseBT.SetRect(left, top, left + widthHeight, bottom);\r\n\r\n\t\tleft = rcBorder.right - IndexToPos(chevronIndex, true);\r\n\t\tm_crChevronBT.SetRect(left, top, left + widthHeight, bottom);\r\n\t\t\r\n\t\tleft = rcBorder.right - IndexToPos(maxIndex, true);\r\n\t\tm_crMaximizeBT.SetRect(left, top, left + widthHeight, bottom);\r\n\t\t\r\n\t\tleft = rcBorder.right - IndexToPos(minIndex, true);\r\n\t\tm_crMinimizeBT.SetRect(left, top, left + widthHeight, bottom);\r\n\t\t\t\tleft = rcBorder.left + m_dpi.Scale(10);\r\n\t\tm_crWindowIconBT.SetRect(left, top, left + m_dpi.Scale(24), bottom);\r\n\t\t\r\n\t\tbVertical = FALSE;\r\n\t}\r\n\tif (m_captionPosition == CAPTION_BOTTOM)\r\n\t{\r\n\t\tleftRect.SetRect(rcBorder.left, rcBorder.bottom- m_captionBorderWidth - border, rcBorder.right - IndexToPos(index - 1, true) - m_dpi.Scale(8), rcBorder.bottom);\r\n\t\trightRect.SetRect(leftRect.right, rcBorder.bottom - m_captionBorderWidth - border, rcBorder.right, rcBorder.bottom);\r\n\r\n\t\ttextRect.SetRect(leftRect.right, leftRect.top, leftRect.right, leftRect.bottom);\r\n\r\n\t\tint top = rightRect.top;\r\n\t\tint bottom = rightRect.bottom;\r\n\r\n\t\tint left = rcBorder.right - IndexToPos(closeIndex, true);\r\n\t\tm_crCloseBT.SetRect(left, top, left + widthHeight, bottom);\r\n\r\n\t\tleft = rcBorder.right - IndexToPos(chevronIndex, true);\r\n\t\tm_crChevronBT.SetRect(left, top, left+ widthHeight, bottom);\r\n\r\n\t\tleft = rcBorder.right - IndexToPos(maxIndex, true);\r\n\t\tm_crMaximizeBT.SetRect(left, top, left + widthHeight, bottom);\r\n\r\n\t\tleft = rcBorder.right - IndexToPos(minIndex, true);\r\n\t\tm_crMinimizeBT.SetRect(left, top, left + widthHeight, bottom);\r\n\r\n\t\tleft = rcBorder.left + m_dpi.Scale(10);\r\n\t\tm_crWindowIconBT.SetRect(left, top, left + m_dpi.Scale(24), bottom);\r\n\r\n\t\tbVertical = FALSE;\r\n\t}\r\n\r\n\r\n\tHBRUSH leftColor = CreateSolidBrush(m_CaptionColorLeft);\r\n\tHBRUSH rightColor = CreateSolidBrush(m_CaptionColorRight);\t\r\n\r\n\t::FillRect(dc, &leftRect, leftColor);\r\n\t::FillRect(dc, &rightRect, rightColor);\r\n\r\n\tDeleteObject(leftColor);\r\n\tDeleteObject(rightColor);\r\n\r\n\r\n\tint nOldBKMode = dc.SetBkMode(TRANSPARENT);\r\n\tCOLORREF oldColor = dc.SetTextColor(m_CaptionTextColor);\r\n\r\n\tCFont *pOldFont = NULL;\r\n\tif (bVertical)\r\n\t\tpOldFont = dc.SelectObject(&m_VertFont);\r\n\telse\r\n\t\tpOldFont = dc.SelectObject(&m_HorFont);\r\n\r\n\tCString csText = m_customWindowTitle;\r\n\tif (m_useCustomWindowTitle == false)\r\n\t{\r\n\t\tpWnd->GetWindowText(csText);\r\n\t}\r\n\r\n\tint flags = DT_SINGLELINE;\r\n\tif (bVertical == false)\r\n\t{\r\n\t\tCRect size(0, 0, 0, 0);\r\n\t\tdc.DrawText(csText, size, DT_CALCRECT);\r\n\t\ttextRect.left = textRect.right - size.Width() - m_dpi.Scale(10);\r\n\r\n\t\tflags |= DT_VCENTER;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCRect size(0, 0, 0, 0);\r\n\t\tdc.DrawText(csText, size, DT_CALCRECT| DT_SINGLELINE);\r\n\r\n\t\tint rectWidth = textRect.left - textRect.right;\r\n\t\tint offset = rectWidth / 2 - m_titleTextHeight / 2;\r\n\t\t//textRect.right += 30;\r\n\t\t//I don't understand where the 4 is coming from but it's always 4 pixals from the right so adjust for this\r\n\t\ttextRect.left -= (offset - m_dpi.Scale(4));\t\t\r\n\r\n\t\tint k = 0;\r\n\t}\r\n\r\n\tdc.DrawText(csText, textRect, flags);\r\n\r\n\tdc.SelectObject(pOldFont);\r\n\tdc.SetBkMode(nOldBKMode);\r\n\r\n\tDrawWindowIcon(dc, pWnd);\r\n\tDrawChevronBtn(dc, pWnd);\r\n\tDrawCloseBtn(dc, pWnd);\r\n\tDrawMaximizeBtn(dc, pWnd);\r\n\tDrawMinimizeBtn(dc, pWnd);\r\n}\r\n\r\nvoid CDittoWindow::DrawChevronBtn(CWindowDC &dc, CWnd *pWnd)\r\n{\r\n\tif(m_bDrawChevron == false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\t\r\n\tif(this->m_bMinimized)\r\n\t{\r\n\t\tm_chevronLeftButton.Draw(&dc, m_dpi, pWnd, m_crChevronBT, m_bMouseOverChevron, m_bMouseDownOnChevron);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_chevronRightButton.Draw(&dc, m_dpi, pWnd, m_crChevronBT, m_bMouseOverChevron, m_bMouseDownOnChevron);\r\n\t}\r\n}\r\n\r\nvoid CDittoWindow::DrawWindowIcon(CWindowDC &dc, CWnd *pWnd)\r\n{\r\n\t//m_windowIcon.Draw(&dc, pWnd, m_crWindowIconBT.left, m_crWindowIconBT.top, false, false);\r\n}\r\n\r\nvoid CDittoWindow::DrawCloseBtn(CWindowDC &dc, CWnd *pWnd)\r\n{\r\n\tif(m_bDrawClose == false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tm_closeButton.Draw(&dc, m_dpi, pWnd, m_crCloseBT, m_bMouseOverClose, m_bMouseDownOnClose);\r\n}\r\n\r\nvoid CDittoWindow::DrawMinimizeBtn(CWindowDC &dc, CWnd *pWnd)\r\n{\r\n\tif(m_bDrawMinimize == false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_minimizeButton.Draw(&dc, m_dpi, pWnd, m_crMinimizeBT, m_bMouseOverMinimize, m_bMouseDownOnMinimize);\r\n}\r\n\r\nvoid CDittoWindow::DrawMaximizeBtn(CWindowDC &dc, CWnd *pWnd)\r\n{\r\n\tif(m_bDrawMaximize == false)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_maximizeButton.Draw(&dc, m_dpi, pWnd, m_crMaximizeBT, m_bMouseOverMaximize, m_bMouseDownOnMaximize);\r\n}\r\n\r\nint CDittoWindow::DoNcLButtonDown(CWnd *pWnd, UINT nHitTest, CPoint point) \r\n{\r\n\tswitch (nHitTest)\r\n\t{\r\n\tcase HTCAPTION:\r\n\t\tm_buttonDownOnCaption = true;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tm_buttonDownOnCaption = false;\r\n\t}\r\n\r\n\tint buttonPressed = 0;\r\n\t//ReleaseCapture();\r\n\tCPoint clPoint(point);\r\n\tpWnd->ScreenToClient(&clPoint);\r\n\r\n\tif (m_captionPosition == CAPTION_LEFT)\r\n\t{\r\n\t\tclPoint.x += m_captionBorderWidth;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tclPoint.x += m_borderSize;\r\n\t}\r\n\r\n\tif (m_captionPosition == CAPTION_TOP)\r\n\t{\r\n\t\tclPoint.y += m_captionBorderWidth;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tclPoint.y += m_borderSize;\r\n\t}\t\r\n\r\n\tif(m_crCloseBT.PtInRect(clPoint))\r\n\t{\r\n\t\tm_bMouseDownOnClose = true;\r\n\t\t//InvalidateRect(pWnd->m_hWnd, m_crCloseBT, TRUE);\r\n\t\t//pWnd->InvalidateRect(m_crCloseBT);\r\n\t\t//pWnd->UpdateWindow();\r\n\t\t//DoNcPaint(pWnd);\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t\tbuttonPressed = BUTTON_CLOSE;\r\n\t}\r\n\telse if(m_crChevronBT.PtInRect(clPoint))\r\n\t{\r\n\t\tm_bMouseDownOnChevron = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t\tbuttonPressed = BUTTON_CHEVRON;\r\n\t}\r\n\telse if(m_crMinimizeBT.PtInRect(clPoint))\r\n\t{\r\n\t\tm_bMouseDownOnMinimize = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t\tbuttonPressed = BUTTON_MINIMIZE;\r\n\t}\r\n\telse if(m_crMaximizeBT.PtInRect(clPoint))\r\n\t{\r\n\t\tm_bMouseDownOnMaximize = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t\tbuttonPressed = BUTTON_MAXIMIZE;\r\n\t}\r\n\telse if(m_bMinimized)\r\n\t{\r\n\t\t//MinMaxWindow(FORCE_MAX);\r\n\t}\r\n\r\n\treturn buttonPressed;\r\n}\r\n\r\nlong CDittoWindow::DoNcLButtonUp(CWnd *pWnd, UINT nHitTest, CPoint point) \r\n{\r\n\tm_buttonDownOnCaption = false;\r\n\r\n\tCRect crWindow;\r\n\tpWnd->GetWindowRect(crWindow);\r\n\r\n\tCPoint localPoint(point.x - crWindow.left, point.y - crWindow.top);\r\n\r\n\tlong lRet = 0;\r\n\tif(m_bMouseDownOnClose)\r\n\t{\r\n\t\tm_bMouseDownOnClose = false;\r\n\t\tm_bMouseOverClose = false;\r\n\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t\t\r\n\t\tif(m_crCloseBT.PtInRect(localPoint))\r\n\t\t{\r\n\t\t\tif(m_sendWMClose)\r\n\t\t\t{\r\n\t\t\t\tpWnd->SendMessage(WM_CLOSE, 0, 0);\r\n\t\t\t}\r\n\t\t\tlRet = BUTTON_CLOSE;\r\n\t\t}\r\n\t}\r\n\telse if(m_bMouseDownOnChevron)\r\n\t{\r\n\t\tm_bMouseDownOnChevron = false;\r\n\t\tm_bMouseOverChevron = false;\r\n\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\r\n\t\tif(m_crChevronBT.PtInRect(localPoint))\r\n\t\t{\r\n\t\t\tlRet = BUTTON_CHEVRON;\r\n\t\t}\r\n\t}\r\n\telse if(m_bMouseDownOnMinimize)\r\n\t{\r\n\t\tm_bMouseDownOnMinimize = false;\r\n\t\tm_bMouseOverMinimize = false;\r\n\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\r\n\t\tif(m_crMinimizeBT.PtInRect(localPoint))\r\n\t\t{\r\n\t\t\tpWnd->ShowWindow(SW_MINIMIZE);\r\n\t\t\tlRet = BUTTON_MINIMIZE;\r\n\t\t}\r\n\t}\r\n\telse if(m_bMouseDownOnMaximize)\r\n\t{\r\n\t\tm_bMouseDownOnMaximize = false;\r\n\t\tm_bMouseOverMaximize = false;\r\n\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\r\n\t\tif(m_crMaximizeBT.PtInRect(localPoint))\r\n\t\t{\r\n\t\t\tif(pWnd->GetStyle() & WS_MAXIMIZE)\r\n\t\t\t\tpWnd->ShowWindow(SW_RESTORE);\r\n\t\t\telse\r\n\t\t\t\tpWnd->ShowWindow(SW_SHOWMAXIMIZED);\r\n\r\n\t\t\tlRet = BUTTON_MAXIMIZE;\r\n\t\t}\r\n\t}\r\n\r\n\treturn lRet;\r\n}\r\n\r\nvoid CDittoWindow::DoNcMouseMove(CWnd *pWnd, UINT nHitTest, CPoint point) \r\n{\r\n\treturn;\r\n\tCRect crWindow;\r\n\tpWnd->GetWindowRect(crWindow);\r\n\r\n\tCPoint localPoint(point.x - crWindow.left, point.y - crWindow.top);\r\n\r\n\tif(m_crCloseBT.PtInRect(localPoint))\r\n\t{\r\n\t\tm_bMouseOverClose = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\telse if(m_bMouseOverClose)\r\n\t{\r\n\t\tm_bMouseOverClose = false;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\r\n\tif(m_crChevronBT.PtInRect(localPoint))\r\n\t{\r\n\t\tm_bMouseOverChevron = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\telse if(m_bMouseOverChevron)\r\n\t{\r\n\t\tm_bMouseOverChevron = false;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\r\n\tif(m_crMinimizeBT.PtInRect(localPoint))\r\n\t{\r\n\t\tm_bMouseOverMinimize = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\telse if(m_bMouseOverMinimize)\r\n\t{\r\n\t\tm_bMouseOverMinimize = false;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\r\n\tif(m_crMaximizeBT.PtInRect(localPoint))\r\n\t{\r\n\t\tm_bMouseOverMaximize = true;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n\telse if(m_bMouseOverMaximize)\r\n\t{\r\n\t\tm_bMouseOverMaximize = false;\r\n\t\tRedrawWindow(pWnd->m_hWnd, NULL, NULL, RDW_FRAME | RDW_INVALIDATE);\r\n\t}\r\n}\r\n\r\nbool CDittoWindow::DoPreTranslateMessage(MSG* pMsg) \r\n{\r\n\treturn true;\r\n}\r\n\r\nvoid CDittoWindow::SetCaptionOn(CWnd *pWnd, int nPos, bool bOnstartup, int captionSize, int captionFontSize)\r\n{\r\n\tm_captionFontSize = captionFontSize;\r\n\r\n\tm_VertFont.DeleteObject();\r\n\tm_VertFont.CreateFont(-m_dpi.Scale(captionFontSize), 0, -900, 0, 400, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,\r\n\t\tDEFAULT_PITCH | FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tm_HorFont.DeleteObject();\r\n\tm_HorFont.CreateFont(-m_dpi.Scale(captionFontSize), 0, 0, 0, 500, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,\r\n\t\tDEFAULT_PITCH | FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tSetTitleTextHeight(pWnd);\r\n\r\n\tm_captionPosition = nPos;\r\n\r\n\tint oldWidth = m_captionBorderWidth;\r\n\tm_captionBorderWidth = m_dpi.Scale(captionSize);\t\r\n\t\t\r\n\tif(!bOnstartup)\r\n\t{\r\n\t\tpWnd->SetWindowPos(NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);\r\n\t}\r\n\r\n\tpWnd->Invalidate();\r\n\tpWnd->RedrawWindow();\r\n\r\n\tif (oldWidth != m_captionBorderWidth)\r\n\t{\r\n\t\t::SetWindowPos(pWnd->m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\r\n\t}\r\n}\r\n\r\nvoid CDittoWindow::SetTitleTextHeight(CWnd *pWnd)\r\n{\r\n\tCWindowDC dc(pWnd);\r\n\tCFont *pOldFont = dc.SelectObject(&m_HorFont);\r\n\tCRect size(0, 0, 0, 0);\r\n\tdc.DrawText(_T(\"W\"), size, DT_CALCRECT);\r\n\tm_titleTextHeight = size.Height();\r\n\tdc.SelectObject(pOldFont);\r\n}\r\n\r\nbool CDittoWindow::SetCaptionColors(COLORREF left, COLORREF right, COLORREF border)\r\n{\r\n\tm_CaptionColorLeft = left;\r\n\tm_CaptionColorRight = right;\r\n\tm_border = border;\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CDittoWindow::SetCaptionTextColor(COLORREF color)\r\n{\r\n\tm_CaptionTextColor = color;\r\n}\r\n\r\nvoid CDittoWindow::MinMaxWindow(CWnd *pWnd, long lOption)\r\n{\r\n\tif ((m_bMinimized) && (lOption == FORCE_MIN))\r\n\t\treturn;\r\n\r\n\tif ((m_bMinimized == false) && (lOption == FORCE_MAX))\r\n\t\treturn;\r\n\r\n\tif (m_captionPosition == CAPTION_RIGHT)\r\n\t{\r\n\t\tif (m_bMinimized == false)\r\n\t\t{\r\n\t\t\tpWnd->GetWindowRect(m_crFullSizeWindow);\r\n\t\t\tpWnd->MoveWindow(m_crFullSizeWindow.right - m_captionBorderWidth,\r\n\t\t\t\tm_crFullSizeWindow.top, m_captionBorderWidth,\r\n\t\t\t\tm_crFullSizeWindow.Height());\r\n\t\t\tm_bMinimized = true;\r\n\t\t\tm_TimeMinimized = COleDateTime::GetCurrentTime();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCRect cr;\r\n\t\t\tpWnd->GetWindowRect(cr);\r\n\t\t\tpWnd->MoveWindow(cr.right - m_crFullSizeWindow.Width(),\r\n\t\t\t\tcr.top, m_crFullSizeWindow.Width(), cr.Height());\r\n\r\n\t\t\tm_crFullSizeWindow.SetRectEmpty();\r\n\t\t\tm_bMinimized = false;\r\n\t\t\tm_TimeMaximized = COleDateTime::GetCurrentTime();\r\n\t\t\t::SetForegroundWindow(pWnd->GetSafeHwnd());\r\n\t\t}\r\n\t}\r\n\tif (m_captionPosition == CAPTION_LEFT)\r\n\t{\r\n\t\tif (m_bMinimized == false)\r\n\t\t{\r\n\t\t\tpWnd->GetWindowRect(m_crFullSizeWindow);\r\n\t\t\tpWnd->MoveWindow(m_crFullSizeWindow.left,\r\n\t\t\t\tm_crFullSizeWindow.top, m_captionBorderWidth,\r\n\t\t\t\tm_crFullSizeWindow.Height());\r\n\t\t\tm_bMinimized = true;\r\n\t\t\tm_TimeMinimized = COleDateTime::GetCurrentTime();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCRect cr;\r\n\t\t\tpWnd->GetWindowRect(cr);\r\n\t\t\tpWnd->MoveWindow(cr.left, cr.top,\r\n\t\t\t\tm_crFullSizeWindow.Width(), cr.Height());\r\n\r\n\t\t\tm_crFullSizeWindow.SetRectEmpty();\r\n\t\t\tm_bMinimized = false;\r\n\t\t\tm_TimeMaximized = COleDateTime::GetCurrentTime();\r\n\t\t\t::SetForegroundWindow(pWnd->GetSafeHwnd());\r\n\t\t}\r\n\t}\r\n\tif (m_captionPosition == CAPTION_TOP)\r\n\t{\r\n\t\tif (m_bMinimized == false)\r\n\t\t{\r\n\t\t\tpWnd->GetWindowRect(m_crFullSizeWindow);\r\n\t\t\tpWnd->MoveWindow(m_crFullSizeWindow.left,\r\n\t\t\t\tm_crFullSizeWindow.top,\r\n\t\t\t\tm_crFullSizeWindow.Width(),\r\n\t\t\t\tm_captionBorderWidth);\r\n\t\t\tm_bMinimized = true;\r\n\t\t\tm_TimeMinimized = COleDateTime::GetCurrentTime();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCRect cr;\r\n\t\t\tpWnd->GetWindowRect(cr);\r\n\t\t\tpWnd->MoveWindow(cr.left, cr.top,\r\n\t\t\t\tcr.Width(), m_crFullSizeWindow.Height());\r\n\r\n\t\t\tm_crFullSizeWindow.SetRectEmpty();\r\n\t\t\tm_bMinimized = false;\r\n\t\t\tm_TimeMaximized = COleDateTime::GetCurrentTime();\r\n\t\t\t::SetForegroundWindow(pWnd->GetSafeHwnd());\r\n\t\t}\r\n\t}\r\n\tif (m_captionPosition == CAPTION_BOTTOM)\r\n\t{\r\n\t\tif (m_bMinimized == false)\r\n\t\t{\r\n\t\t\tpWnd->GetWindowRect(m_crFullSizeWindow);\r\n\t\t\tpWnd->MoveWindow(m_crFullSizeWindow.left,\r\n\t\t\t\tm_crFullSizeWindow.bottom - m_captionBorderWidth,\r\n\t\t\t\tm_crFullSizeWindow.Width(),\r\n\t\t\t\tm_captionBorderWidth);\r\n\t\t\tm_bMinimized = true;\r\n\t\t\tm_TimeMinimized = COleDateTime::GetCurrentTime();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCRect cr;\r\n\t\t\tpWnd->GetWindowRect(cr);\r\n\t\t\tpWnd->MoveWindow(cr.left,\r\n\t\t\t\tcr.bottom - m_crFullSizeWindow.Height(),\r\n\t\t\t\tcr.Width(), m_crFullSizeWindow.Height());\r\n\r\n\t\t\tm_crFullSizeWindow.SetRectEmpty();\r\n\t\t\tm_bMinimized = false;\r\n\t\t\tm_TimeMaximized = COleDateTime::GetCurrentTime();\r\n\t\t\t::SetForegroundWindow(pWnd->GetSafeHwnd());\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CDittoWindow::OnDpiChanged(CWnd *pParent, int dpi)\r\n{\r\n\tm_dpi.Update(dpi);\r\n\r\n\tm_captionBorderWidth = m_dpi.Scale(25);\r\n\tm_borderSize = m_dpi.Scale(2);\r\n\r\n\tm_VertFont.DeleteObject();\r\n\tm_HorFont.DeleteObject();\r\n\r\n\tm_VertFont.CreateFont(-m_dpi.Scale(m_captionFontSize), 0, -900, 0, 400, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,\r\n\t\tDEFAULT_PITCH | FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tm_HorFont.CreateFont(-m_dpi.Scale(m_captionFontSize), 0, 0, 0, 500, FALSE, FALSE, 0, DEFAULT_CHARSET,\r\n\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,\r\n\t\tDEFAULT_PITCH | FF_SWISS, _T(\"Segoe UI\"));\r\n\r\n\tm_closeButton.Reset();\r\n\tm_closeButton.LoadStdImageDPI(m_dpi.GetDPI(), Close_Black_16_16, Close_Black_20_20, Close_Black_24_24, Close_Black_28, Close_Black_32_32, _T(\"PNG\"), close_36, close_40, close_44, close_48, close_52, close_56);\r\n\r\n\tm_chevronRightButton.Reset();\r\n\tm_chevronRightButton.LoadStdImageDPI(m_dpi.GetDPI(), ChevronRight_Black_16_16, ChevronRight_Black_20_20, ChevronRight_Black_24_24, ChevronRight_Black_28, ChevronRight_Black_32_32, _T(\"PNG\"), ChevronRight_Black_36, ChevronRight_Black_40, ChevronRight_Black_44, ChevronRight_Black_48, ChevronRight_Black_52, ChevronRight_Black_56);\r\n\t\r\n\tm_chevronLeftButton.Reset();\r\n\tm_chevronLeftButton.LoadStdImageDPI(m_dpi.GetDPI(), ChevronLeft_Black_16_16, ChevronLeft_Black_20_20, ChevronLeft_Black_24_24, ChevronLeft_Black_28, ChevronLeft_Black_32_32, _T(\"PNG\"), ChevronLeft_Black_36, ChevronLeft_Black_40, ChevronLeft_Black_44, ChevronLeft_Black_48, ChevronLeft_Black_52, ChevronLeft_Black_56);\r\n\r\n\tm_maximizeButton.Reset();\r\n\tm_maximizeButton.LoadStdImageDPI(m_dpi.GetDPI(), IDB_MAXIMIZE_16_16, maximize_20, maximize_24, maximize_28, maximize_32, _T(\"PNG\"), maximize_36, maximize_40, maximize_44, maximize_48, maximize_52, maximize_56);\r\n\r\n\tm_minimizeButton.Reset();\r\n\tm_minimizeButton.LoadStdImageDPI(m_dpi.GetDPI(), minimize_16, minimize_20, minimize_24, minimize_28, minimize_32, _T(\"PNG\"), minimize_36, minimize_40, minimize_44, minimize_48, minimize_52, minimize_56);\r\n\r\n\tSetTitleTextHeight(pParent);\r\n\r\n\t/*pParent->SetWindowPos(NULL, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);\r\n\r\n\tpParent->Invalidate();\r\n\tpParent->RedrawWindow();*/\r\n\r\n\t//::SetWindowPos(pParent->m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\r\n}"
        },
        {
          "name": "DittoWindow.h",
          "type": "blob",
          "size": 2.4814453125,
          "content": "#pragma once\r\n\r\n#include \"GdipButton.h\"\r\n#include \"GdiImageDrawer.h\"\r\n#include \"DPI.h\"\r\n\r\n#define BUTTON_CLOSE 1\r\n#define BUTTON_CHEVRON 2\r\n#define BUTTON_MINIMIZE 3\r\n#define BUTTON_MAXIMIZE 4\r\n\r\nclass CDittoWindow\r\n{\r\npublic:\r\n\tCDittoWindow(void);\r\n\t~CDittoWindow(void);\r\n\r\n\tvoid DoNcPaint(CWnd *pWnd);\r\n\tvoid DrawChevronBtn(CWindowDC &dc, CWnd *pWnd);\r\n\tvoid DrawCloseBtn(CWindowDC &dc, CWnd *pWnd);\r\n\tvoid DrawMaximizeBtn(CWindowDC &dc, CWnd *pWnd);\r\n\tvoid DrawMinimizeBtn(CWindowDC &dc, CWnd *pWnd);\r\n\tvoid DrawWindowIcon(CWindowDC &dc, CWnd *pWnd);\r\n\r\n\tvoid DoCreate(CWnd *pWnd);\r\n\tvoid DoNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);\r\n\tUINT DoNcHitTest(CWnd *pWnd, CPoint point);\r\n\tlong DoNcLButtonUp(CWnd *pWnd, UINT nHitTest, CPoint point);\r\n\tint DoNcLButtonDown(CWnd *pWnd, UINT nHitTest, CPoint point);\r\n\tvoid DoNcMouseMove(CWnd *pWnd, UINT nHitTest, CPoint point) ;\r\n\tbool DoPreTranslateMessage(MSG* pMsg);\r\n\tvoid SetCaptionOn(CWnd *pWnd, int nPos, bool bOnstartup, int captionSize, int captionFontSize);\r\n\tbool SetCaptionColors(COLORREF left, COLORREF right, COLORREF border);\r\n\tvoid SetCaptionTextColor(COLORREF color);\r\n\tvoid MinMaxWindow(CWnd *pWnd, long lOption);\r\n\tvoid SetTitleTextHeight(CWnd *pWnd);\r\n\tint IndexToPos(int index, bool horizontal);\r\n\tvoid OnDpiChanged(CWnd *pWnd, int dpi);\r\n\t\r\n\tbool m_bDrawClose;\r\n\tbool m_sendWMClose;\r\n\tbool m_bDrawChevron;\r\n\tbool m_bDrawMaximize;\r\n\tbool m_bDrawMinimize;\r\n\r\n\tCRect m_crCloseBT;\r\n\tCRect m_crChevronBT;\r\n\tCRect m_crMaximizeBT;\r\n\tCRect m_crMinimizeBT;\r\n\tCRect m_crWindowIconBT;\r\n\r\n\tCFont m_VertFont;\r\n\tCFont m_HorFont;\r\n\r\n\tbool m_bMinimized;\r\n\r\n\tbool m_bMouseDownOnChevron;\r\n\tbool m_bMouseOverChevron;\r\n\tbool m_bMouseDownOnClose;\r\n\tbool m_bMouseOverClose;\r\n\tbool m_bMouseDownOnMinimize;\r\n\tbool m_bMouseOverMinimize;\r\n\tbool m_bMouseDownOnMaximize;\r\n\tbool m_bMouseOverMaximize;\r\n\r\n\tCOLORREF m_CaptionColorLeft;\r\n\tCOLORREF m_CaptionColorRight;\r\n\tCOLORREF m_CaptionTextColor;\r\n\tCOLORREF m_border;\r\n\t\r\n\tCGdiImageDrawer m_closeButton;\r\n\tCGdiImageDrawer m_chevronRightButton;\r\n\tCGdiImageDrawer m_chevronLeftButton;\r\n\tCGdiImageDrawer m_maximizeButton;\r\n\tCGdiImageDrawer m_minimizeButton;\r\n\t//CGdiImageDrawer m_windowIcon;\r\n\r\n\tCString m_customWindowTitle;\r\n\tbool m_useCustomWindowTitle;\r\n\r\n\tint m_captionBorderWidth;\r\n\tint m_captionFontSize;\r\n\r\n\tint m_captionPosition;\r\n\tint m_borderSize;\r\n\r\n\tint m_titleTextHeight;\r\n\r\n\tbool m_buttonDownOnCaption;\r\n\r\n\tCRect m_crFullSizeWindow;\r\n\tCOleDateTime m_TimeMinimized;\r\n\tCOleDateTime m_TimeMaximized;\r\n\r\n\r\n\tCDPI m_dpi;\r\n};\r\n"
        },
        {
          "name": "DrawHTML.C",
          "type": "blob",
          "size": 10.6728515625,
          "content": "/* DrawHTML()\n * Drop-in replacement for DrawText() supporting a tiny subset of HTML.\n */\n#include <windows.h>\n#include <tchar.h>\n#include <assert.h>\n\n//use unprintable characters so it doesn't find copied html to convert\n\n#define ENDFLAG   0x100\nenum { tNONE, tB, tBR, tFONT, tI, tP, tSUB, tSUP, tU, tNUMTAGS };\nstruct\n{\n\tchar *mnemonic;\n\tshort token, param, block;\n} Tags[] = {\n  { NULL,         tNONE, 0, 0},\n  { _T(\"\\x04\"),   tFONT, 1, 0 },\n  { _T(\"\\x05\"),   tBR,   0, 1 },\n  /*{ _T(\"b\"),      tB,    0, 0},\n  { _T(\"br\"),     tBR,   0, 1},\n  { _T(\"em\"),     tI,    0, 0},\n  { _T(\"font\"),   tFONT, 1, 0},\n  { _T(\"i\"),      tI,    0, 0},\n  { _T(\"p\"),      tP,    0, 1},\n  { _T(\"strong\"), tB,    0, 0},\n  { _T(\"sub\"),    tSUB,  0, 0},\n  { _T(\"sup\"),    tSUP,  0, 0},\n  { _T(\"u\"),      tU,    0, 0},*/\n};\n\nstatic int GetToken(LPCTSTR *String, int *Size, int *TokenLength, BOOL *WhiteSpace)\n{\n\tLPCTSTR Start, EndToken;\n\tint Length, EntryWhiteSpace, Index, IsEndTag;\n\n\tassert(String != NULL && *String != NULL);\n\tassert(Size != NULL);\n\tStart = *String;\n\n\t/* check for leading white space, then skip it */\n\tif (WhiteSpace != NULL)\n\t{\n\t\tEntryWhiteSpace = *WhiteSpace;\n\t\t*WhiteSpace = EntryWhiteSpace || _istspace(*Start);\n\t}\n\telse\n\t{\n\t\tEntryWhiteSpace = FALSE;\n\t} /* if */\n\twhile (*Size > 0 && _istspace(*Start))\n\t{\n\t\tStart++;\n\t\t*Size -= 1;\n\t} /* if */\n\tif (*Size <= 0)\n\t\treturn -1;  /* no printable text left */\n\n\tEndToken = Start;\n\tLength = 0;\n\tIsEndTag = 0;\n\tif (*EndToken == _T('\\x01'))\n\t{\n\t\t/* might be a HTML tag, check */\n\t\tEndToken++;\n\t\tLength++;\n\t\tif (Length < *Size && *EndToken == _T('\\x03'))\n\t\t{\n\t\t\tIsEndTag = ENDFLAG;\n\t\t\tEndToken++;\n\t\t\tLength++;\n\t\t} /* if */\n\t\twhile (Length < *Size && !_istspace(*EndToken)\n\t\t\t&& *EndToken != _T('\\x01') && *EndToken != _T('\\x02'))\n\t\t{\n\t\t\tEndToken++;\n\t\t\tLength++;\n\t\t} /* while */\n\t\tfor (Index = sizeof Tags / sizeof Tags[0] - 1; Index > 0; Index--)\n\t\t\tif (!_tcsnicmp(Start + (IsEndTag ? 2 : 1), Tags[Index].mnemonic,\n\t\t\t\t_tcslen(Tags[Index].mnemonic)))\n\t\t\t\tbreak;\n\t\tif (Index > 0)\n\t\t{\n\t\t\t/* so it is a tag, see whether to accept parameters */\n\t\t\tif (Tags[Index].param && !IsEndTag)\n\t\t\t{\n\t\t\t\twhile (Length < *Size\n\t\t\t\t\t&& *EndToken != _T('\\x01') && *EndToken != _T('\\x02'))\n\t\t\t\t{\n\t\t\t\t\tEndToken++;\n\t\t\t\t\tLength++;\n\t\t\t\t} /* while */\n\t\t\t}\n\t\t\telse if (*EndToken != _T('\\x02'))\n\t\t\t{\n\t\t\t\t/* no parameters, then '>' must follow the tag */\n\t\t\t\tIndex = 0;\n\t\t\t} /* if */\n\t\t\tif (WhiteSpace != NULL && Tags[Index].block)\n\t\t\t\t*WhiteSpace = FALSE;\n\t\t} /* if */\n\t\tif (*EndToken == _T('\\x02'))\n\t\t{\n\t\t\tEndToken++;\n\t\t\tLength++;\n\t\t} /* if */\n\t\t/* skip trailing white space in some circumstances */\n\t\tif (Index > 0 && (Tags[Index].block || EntryWhiteSpace))\n\t\t{\n\t\t\twhile (Length < *Size && _istspace(*EndToken))\n\t\t\t{\n\t\t\t\tEndToken++;\n\t\t\t\tLength++;\n\t\t\t} /* while */\n\t\t} /* if */\n\n\t}\n\telse\n\t{\n\t\t/* normal word (no tag) */\n\t\tIndex = 0;\n\t\twhile (Length < *Size && !_istspace(*EndToken) && *EndToken != _T('\\x01'))\n\t\t{\n\t\t\tEndToken++;\n\t\t\tLength++;\n\t\t} /* while */\n\t} /* if */\n\n\tif (TokenLength != NULL)\n\t\t*TokenLength = Length;\n\t*Size -= Length;\n\t*String = Start;\n\treturn Tags[Index].token | IsEndTag;\n}\n\nstatic int HexDigit(TCHAR ch)\n{\n\tif (ch >= _T('0') && ch <= _T('9'))\n\t\treturn ch - _T('0');\n\tif (ch >= _T('A') && ch <= _T('F'))\n\t\treturn ch - _T('A') + 10;\n\tif (ch >= _T('a') && ch <= _T('f'))\n\t\treturn ch - _T('a') + 10;\n\treturn 0;\n}\n\nstatic COLORREF ParseColor(LPCTSTR String)\n{\n\tint Red, Green, Blue;\n\n\tif (*String == _T('\\'') || *String == _T('\"'))\n\t\tString++;\n\tif (*String == _T('#'))\n\t\tString++;\n\tRed = (HexDigit(String[0]) << 4) | HexDigit(String[1]);\n\tGreen = (HexDigit(String[2]) << 4) | HexDigit(String[3]);\n\tBlue = (HexDigit(String[4]) << 4) | HexDigit(String[5]);\n\treturn RGB(Red, Green, Blue);\n}\n\n#define STACKSIZE   8\nstatic COLORREF stack[STACKSIZE];\nstatic int stacktop;\n\nstatic BOOL PushColor(HDC hdc, COLORREF clr)\n{\n\tif (stacktop < STACKSIZE)\n\t\tstack[stacktop++] = GetTextColor(hdc);\n\tSetTextColor(hdc, clr);\n\treturn TRUE;\n}\n\nstatic BOOL PopColor(HDC hdc)\n{\n\tCOLORREF clr;\n\tBOOL okay = (stacktop > 0);\n\n\tif (okay)\n\t\tclr = stack[--stacktop];\n\telse\n\t\tclr = stack[0];\n\tSetTextColor(hdc, clr);\n\treturn okay;\n}\n\n\n#define FV_BOLD        0x01\n#define FV_ITALIC      (FV_BOLD << 1)\n#define FV_UNDERLINE   (FV_ITALIC << 1)\n#define FV_SUPERSCRIPT (FV_UNDERLINE << 1)\n#define FV_SUBSCRIPT   (FV_SUPERSCRIPT << 1)\n#define FV_NUMBER      (FV_SUBSCRIPT << 1)\n\nstatic HFONT GetFontVariant(HDC hdc, HFONT hfontSource, int Styles)\n{\n\tLOGFONT logFont = { 0 };\n\n\tSelectObject(hdc, (HFONT)GetStockObject(SYSTEM_FONT));\n\tif (!GetObject(hfontSource, sizeof logFont, &logFont))\n\t\treturn NULL;\n\n\t/* set parameters, create new font */\n\tlogFont.lfWeight = (Styles & FV_BOLD) ? FW_BOLD : FW_NORMAL;\n\tlogFont.lfItalic = (BYTE)(Styles & FV_ITALIC) != 0;\n\tlogFont.lfUnderline = (BYTE)(Styles & FV_UNDERLINE) != 0;\n\tif (Styles & (FV_SUPERSCRIPT | FV_SUBSCRIPT))\n\t\tlogFont.lfHeight = logFont.lfHeight * 7 / 10;\n\treturn CreateFontIndirect(&logFont);\n}\n\n#if defined __cplusplus\nextern \"C\"\n#endif\nint __stdcall DrawHTML(\n\tHDC     hdc,        // handle of device context\n\tLPCTSTR lpString,   // address of string to draw\n\tint     nCount,     // string length, in characters\n\tLPRECT  lpRect,     // address of structure with formatting dimensions\n\tUINT    uFormat     // text-drawing flags\n)\n{\n\tLPCTSTR Start;\n\tint Left, Top, MaxWidth, MinWidth, Height, MaxHeight;\n\tint SavedDC;\n\tint Tag, TokenLength;\n\tHFONT hfontBase, hfontSpecial[FV_NUMBER];\n\tint Styles, CurStyles;\n\tSIZE size;\n\tint Index, LineHeight;\n\tPOINT CurPos;\n\tint WidthOfSPace, XPos;\n\tBOOL WhiteSpace;\n\tRECT rc;\n\n\tif (hdc == NULL || lpString == NULL)\n\t\treturn 0;\n\tif (nCount < 0)\n\t\tnCount = _tcslen(lpString);\n\n\tMaxHeight = INT_MAX;\n\n\tif (lpRect != NULL)\n\t{\n\t\tLeft = lpRect->left;\n\t\tTop = lpRect->top;\n\t\tMaxWidth = lpRect->right - lpRect->left;\n\t\tMaxHeight = lpRect->bottom - lpRect->top;\n\t}\n\telse\n\t{\n\t\tGetCurrentPositionEx(hdc, &CurPos);\n\t\tLeft = CurPos.x;\n\t\tTop = CurPos.y;\n\t\tMaxWidth = GetDeviceCaps(hdc, HORZRES) - Left;\n\t} /* if */\n\tif (MaxWidth < 0)\n\t\tMaxWidth = 0;\n\n\t/* toggle flags we do not support */\n\tuFormat &= ~(DT_CENTER | DT_RIGHT | DT_TABSTOP);\n\tuFormat |= (DT_LEFT | DT_NOPREFIX);\n\n\t/* get the \"default\" font from the DC */\n\tSavedDC = SaveDC(hdc);\n\thfontBase = SelectObject(hdc, (HFONT)GetStockObject(SYSTEM_FONT));\n\tSelectObject(hdc, hfontBase);\n\t/* clear the other fonts, they are created \"on demand\" */\n\tfor (Index = 0; Index < FV_NUMBER; Index++)\n\t\thfontSpecial[Index] = NULL;\n\thfontSpecial[0] = hfontBase;\n\tStyles = 0; /* assume the active font is normal weight, roman, non-underlined */\n\n\t/* get font height (use characters with ascender and descender);\n\t * we make the assumption here that changing the font style will\n\t * not change the font height\n\t */\n\tGetTextExtentPoint32(hdc, _T(\"y\"), 2, &size);\n\tLineHeight = size.cy;\n\n\t/* run through the string, word for word */\n\tXPos = 0;\n\tMinWidth = 0;\n\tstacktop = 0;\n\tCurStyles = -1; /* force a select of the proper style */\n\tHeight = 0;\n\tWhiteSpace = FALSE;\n\n\tStart = lpString;\n\tfor (;; )\n\t{\n\t\tTag = GetToken(&Start, &nCount, &TokenLength, &WhiteSpace);\n\t\tif (Tag < 0)\n\t\t\tbreak;\n\t\tswitch (Tag & ~ENDFLAG)\n\t\t{\n\t\tcase tP:\n\t\t\tif ((Tag & ENDFLAG) == 0 && (uFormat & DT_SINGLELINE) == 0)\n\t\t\t{\n\t\t\t\tif (Start != lpString)\n\t\t\t\t\tHeight += 3 * LineHeight / 2;\n\t\t\t\tXPos = 0;\n\t\t\t} /* if */\n\t\t\tbreak;\n\t\tcase tBR:\n\t\t\tif ((Tag & ENDFLAG) == 0 && (uFormat & DT_SINGLELINE) == 0)\n\t\t\t{\n\t\t\t\tHeight += LineHeight;\n\t\t\t\tXPos = 0;\n\t\t\t} /* if */\n\t\t\tbreak;\n\t\tcase tB:\n\t\t\tStyles = (Tag & ENDFLAG) ? Styles & ~FV_BOLD : Styles | FV_BOLD;\n\t\t\tbreak;\n\t\tcase tI:\n\t\t\tStyles = (Tag & ENDFLAG) ? Styles & ~FV_ITALIC : Styles | FV_ITALIC;\n\t\t\tbreak;\n\t\tcase tU:\n\t\t\tStyles = (Tag & ENDFLAG) ? Styles & ~FV_UNDERLINE : Styles | FV_UNDERLINE;\n\t\t\tbreak;\n\t\tcase tSUB:\n\t\t\tStyles = (Tag & ENDFLAG) ? Styles & ~FV_SUBSCRIPT : Styles | FV_SUBSCRIPT;\n\t\t\tbreak;\n\t\tcase tSUP:\n\t\t\tStyles = (Tag & ENDFLAG) ? Styles & ~FV_SUPERSCRIPT : Styles | FV_SUPERSCRIPT;\n\t\t\tbreak;\n\t\tcase tFONT:\n\t\t\tif ((Tag & ENDFLAG) == 0)\n\t\t\t{\n\t\t\t\tif (_tcsnicmp(Start + 3, _T(\"color=\"), 6) == 0)\n\t\t\t\t\tPushColor(hdc, ParseColor(Start + 9));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPopColor(hdc);\n\t\t\t} /* if */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (Tag == (tNONE | ENDFLAG))\n\t\t\t\tbreak;\n\t\t\tif (CurStyles != Styles)\n\t\t\t{\n\t\t\t\tif (hfontSpecial[Styles] == NULL)\n\t\t\t\t\thfontSpecial[Styles] = GetFontVariant(hdc, hfontBase, Styles);\n\t\t\t\tCurStyles = Styles;\n\t\t\t\tSelectObject(hdc, hfontSpecial[Styles]);\n\t\t\t\t/* get the width of a space character (for word spacing) */\n\t\t\t\tGetTextExtentPoint32(hdc, _T(\" \"), 1, &size);\n\t\t\t\tWidthOfSPace = size.cx;\n\t\t\t} /* if */\n\t\t\t/* check word length, check whether to wrap around */\n\t\t\tGetTextExtentPoint32(hdc, Start, TokenLength, &size);\n\t\t\tif (size.cx > MaxWidth)\n\t\t\t\tMaxWidth = size.cx;   /* must increase width: long non-breakable word */\n\t\t\tif (WhiteSpace)\n\t\t\t\tXPos += WidthOfSPace;\n\t\t\tif (XPos + size.cx > MaxWidth && WhiteSpace)\n\t\t\t{\n\t\t\t\tif ((uFormat & DT_WORDBREAK) != 0)\n\t\t\t\t{\n\t\t\t\t\t/* word wrap */\n\t\t\t\t\tHeight += LineHeight;\n\t\t\t\t\tXPos = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* no word wrap, must increase the width */\n\t\t\t\t\tMaxWidth = XPos + size.cx;\n\t\t\t\t} /* if */\n\t\t\t} /* if */\n\t\t\t/* output text (unless DT_CALCRECT is set) */\n\t\t\tif ((uFormat & DT_CALCRECT) == 0)\n\t\t\t{\n\t\t\t\t/* handle negative heights, too (suggestion of \"Sims\")  */\n\t\t\t\tif (Top < 0)\n\t\t\t\t\tSetRect(&rc, Left + XPos, Top - Height,\n\t\t\t\t\t\tLeft + MaxWidth, Top - (Height + LineHeight));\n\t\t\t\telse\n\t\t\t\t\tSetRect(&rc, Left + XPos, Top + Height,\n\t\t\t\t\t\tLeft + MaxWidth, Top + Height + LineHeight);\n\n\t\t\t\t/* reposition subscript text to align below the baseline */\n\t\t\t\tDrawText(hdc, Start, TokenLength, &rc,\n\t\t\t\t\tuFormat | ((Styles & FV_SUBSCRIPT) ? DT_BOTTOM | DT_SINGLELINE : 0));\n\n\t\t\t\t/* for the underline style, the spaces between words should be\n\t\t\t\t * underlined as well\n\t\t\t\t */\n\t\t\t\tif (WhiteSpace && (Styles & FV_UNDERLINE) && XPos >= WidthOfSPace)\n\t\t\t\t{\n\t\t\t\t\tif (Top < 0)\n\t\t\t\t\t\tSetRect(&rc, Left + XPos - WidthOfSPace, Top - Height,\n\t\t\t\t\t\t\tLeft + XPos, Top - (Height + LineHeight));\n\t\t\t\t\telse\n\t\t\t\t\t\tSetRect(&rc, Left + XPos - WidthOfSPace, Top + Height,\n\t\t\t\t\t\t\tLeft + XPos, Top + Height + LineHeight);\n\t\t\t\t\tDrawText(hdc, \" \", 1, &rc, uFormat);\n\t\t\t\t} /* if */\n\t\t\t} /* if */\n\t\t\t/* update current position */\n\t\t\tXPos += size.cx;\n\t\t\tif (XPos > MinWidth)\n\t\t\t\tMinWidth = XPos;\n\t\t\tWhiteSpace = FALSE;\n\t\t} /* if */\n\n\t\tif ((Height + LineHeight) >= MaxHeight)\n\t\t\tbreak;\n\n\t\tStart += TokenLength;\n\t} /* for */\n\n\tRestoreDC(hdc, SavedDC);\n\tfor (Index = 1; Index < FV_NUMBER; Index++) /* do not erase hfontSpecial[0] */\n\t\tif (hfontSpecial[Index] != NULL)\n\t\t\tDeleteObject(hfontSpecial[Index]);\n\n\t/* store width and height back into the lpRect structure */\n\tif ((uFormat & DT_CALCRECT) != 0 && lpRect != NULL)\n\t{\n\t\tlpRect->right = lpRect->left + MinWidth;\n\t\tif (lpRect->top < 0)\n\t\t\tlpRect->bottom = lpRect->top - (Height + LineHeight);\n\t\telse\n\t\t\tlpRect->bottom = lpRect->top + Height + LineHeight;\n\t} /* if */\n\n\treturn Height;\n}\n"
        },
        {
          "name": "DrawHTML.h",
          "type": "blob",
          "size": 0.5458984375,
          "content": "/* DrawHTML()\n * Drop-in replacement for DrawText() supporting a tiny subset of HTML.\n */\n\n#if defined __cplusplus\nextern \"C\"\n#endif\nint __stdcall DrawHTML(\n                       HDC     hdc,        // handle of device context\n                       LPCTSTR lpString,   // address of string to draw\n                       int     nCount,     // string length, in characters\n                       LPRECT  lpRect,     // address of structure with formatting dimensions\n                       UINT    uFormat     // text-drawing flags\n                      );\n"
        },
        {
          "name": "EditWithButton.cpp",
          "type": "blob",
          "size": 8.021484375,
          "content": "// EditWithButton.cpp : implementation file\r\n//\r\n\r\n//DISCLAIMER:\r\n//The code in this project is Copyright (C) 2006 by Gautam Jain. You have the right to\r\n//use and distribute the code in any way you see fit as long as this paragraph is included\r\n//with the distribution. No warranties or claims are made as to the validity of the\r\n//information and code contained herein, so use it at your own risk.\r\n\r\n#include \"stdafx.h\"\r\n#include \"EditWithButton.h\"\r\n#include \"cp_main.h\"\r\n\r\n\r\nIMPLEMENT_DYNAMIC(CEditWithButton, CEdit)\r\n\r\nCEditWithButton::CEditWithButton()\r\n{\r\n\tm_iButtonClickedMessageId = NM_CANCEL_SEARCH;\r\n\tm_bButtonExistsAlways = FALSE;\r\n\r\n\tm_rcEditArea.SetRect(0, 0, 0, 0);\r\n}\r\n\r\nCEditWithButton::~CEditWithButton()\r\n{\r\n\tm_bmpEmptyEdit.DeleteObject();\r\n\tm_bmpFilledEdit.DeleteObject();\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CEditWithButton, CEdit)\r\n\tON_MESSAGE(WM_SETFONT, OnSetFont)\r\n\tON_WM_SIZE()\r\n\tON_WM_ERASEBKGND()\r\n\tON_WM_CHAR()\r\n\tON_WM_KEYDOWN()\r\n\tON_WM_LBUTTONUP()\r\n\tON_WM_SETCURSOR()\r\n\tON_WM_CREATE()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CEditWithButton message handlers\r\n\r\nvoid CEditWithButton::PreSubclassWindow()\r\n{\r\n\t// We must have a multiline edit\r\n\t// to be able to set the edit rect\r\n\tASSERT(GetStyle() & ES_MULTILINE);\r\n\r\n\tResizeWindow();\r\n}\r\n\r\nBOOL CEditWithButton::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\t// TODO: Add your specialized code here and/or call the base class\r\n\t// Intercept Ctrl + Z (Undo), Ctrl + X (Cut), Ctrl + C (Copy), Ctrl + V (Paste) and Ctrl + A (Select All)\r\n\t// before CEdit base class gets a hold of them.\r\n\tif (pMsg->message == WM_KEYDOWN && \r\n\t\tCONTROL_PRESSED)\r\n\t{\r\n\t\tswitch (pMsg->wParam)\r\n\t\t{\r\n\t\tcase 'Z':\r\n\t\t\tUndo();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'X':\r\n\t\t\tCut();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'C':\r\n\t\t\tCopy();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'V':\r\n\t\t\tPaste();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'A':\r\n\t\t\tSetSel(0, -1);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tswitch(pMsg->message) \r\n\t{\r\n\tcase WM_KEYDOWN:\r\n\t\t{\r\n\t\t\tif(pMsg->wParam == VK_RETURN)\r\n\t\t\t{\r\n\t\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\t\tif(pWnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(CGetSetOptions::m_bFindAsYouType)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpWnd->SendMessage(NM_SEARCH_ENTER_PRESSED, 0, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//Send a message to the parent to refill the lb from the search\r\n\t\t\t\t\t\tpWnd->PostMessage(CB_SEARCH, 0, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\t\r\n\t\t\telse if (pMsg->wParam == VK_DOWN ||\r\n\t\t\t\t\tpMsg->wParam == VK_UP ||\r\n\t\t\t\t\tpMsg->wParam == VK_F3 ||\r\n\t\t\t\t\tpMsg->wParam == VK_PRIOR ||\r\n\t\t\t\t\tpMsg->wParam == VK_NEXT)\r\n\t\t\t{\r\n\t\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\t\tif(pWnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn CEdit::PreTranslateMessage(pMsg);\r\n}\r\n\r\nBOOL CEditWithButton::SetBitmaps(UINT iEmptyEdit, UINT iFilledEdit)\r\n{\r\n\tBITMAP bmpInfo;\r\n\r\n\t//delete if already loaded.. just in case\r\n\tm_bmpEmptyEdit.DeleteObject();\r\n\tm_bmpFilledEdit.DeleteObject();\r\n\r\n\tm_bmpEmptyEdit.LoadBitmap(iEmptyEdit);\r\n\tm_bmpFilledEdit.LoadBitmap(iFilledEdit);\r\n\t\r\n\tm_bmpEmptyEdit.GetBitmap(&bmpInfo);\r\n\tm_sizeEmptyBitmap.SetSize(bmpInfo.bmWidth,bmpInfo.bmHeight);\r\n\t\r\n\tm_bmpFilledEdit.GetBitmap(&bmpInfo);\r\n\tm_sizeFilledBitmap.SetSize(bmpInfo.bmWidth,bmpInfo.bmHeight);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n//client area\r\nvoid CEditWithButton::SetButtonArea(CRect rcButtonArea)\r\n{\r\n\tm_rcButtonArea = rcButtonArea;\r\n}\r\n\r\nvoid CEditWithButton::ResizeWindow()\r\n{\r\n\tif (!::IsWindow(m_hWnd)) return;\r\n\r\n\t//proceed only if edit area is set\r\n\tif (m_rcBorder == CRect(0,0,0,0)) \r\n\t\treturn;\r\n\r\n\tCRect r;\r\n\tGetWindowRect(r);\r\n\tScreenToClient(r);\r\n\r\n\tSetWindowPos(&wndTop, 0, 0, r.Width(), r.Height(), SWP_NOMOVE|SWP_NOZORDER);\r\n\r\n\tm_rcEditArea.left = r.left + m_rcBorder.left;\r\n\tm_rcEditArea.top = r.top + m_rcBorder.top;\r\n\tm_rcEditArea.right = r.right -= m_rcBorder.right;\r\n\tm_rcEditArea.bottom = r.bottom -= m_rcBorder.bottom;\r\n\t\r\n\tSetRect(&m_rcEditArea);\r\n}\r\n\r\n//set edit area may be called before creating the edit control\r\n//especially when using the CEdit::Create method\r\n//or after creating the edit control in CEdit::DoDataExchange\r\n//we call ResizeWindow once in SetEditArea and once in PreSubclassWindow\r\nBOOL CEditWithButton::SetBorder(CRect rcEditArea)\r\n{\r\n\tm_rcBorder = rcEditArea;\r\n\r\n\tResizeWindow();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CEditWithButton::SetButtonExistsAlways(BOOL bButtonExistsAlways)\r\n{\r\n\tm_bButtonExistsAlways = bButtonExistsAlways;\r\n}\r\n\r\nBOOL CEditWithButton::OnEraseBkgnd(CDC* pDC)\r\n{\r\n\t// Get the size of the bitmap\r\n\tCDC dcMemory;\r\n    CSize sizeBitmap;\r\n\tCBitmap* pOldBitmap = NULL;\r\n\tint iTextLength = GetWindowTextLength();\r\n\r\n\tCRect size;\r\n\tGetWindowRect(size);\r\n    \r\n\tif (iTextLength == 0)\r\n\t{\r\n\t\tsizeBitmap = m_sizeEmptyBitmap;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsizeBitmap = m_sizeFilledBitmap;\r\n\t}\r\n\r\n    // Create an in-memory DC compatible with the\r\n    // display DC we're using to paint\r\n    dcMemory.CreateCompatibleDC(pDC);\r\n\r\n\tif (iTextLength == 0)\r\n\t{\r\n\t\t// Select the bitmap into the in-memory DC\r\n\t\tpOldBitmap = dcMemory.SelectObject(&m_bmpEmptyEdit);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Select the bitmap into the in-memory DC\r\n\t\tpOldBitmap = dcMemory.SelectObject(&m_bmpFilledEdit);\r\n\t}\r\n\r\n    // Copy the bits from the in-memory DC into the on-\r\n    // screen DC to actually do the painting. Use the centerpoint\r\n    // we computed for the target offset.\r\n    pDC->BitBlt(0,0, 50, sizeBitmap.cy, &dcMemory, \r\n        0, 0, SRCCOPY);\r\n\r\n\tfor(int i = 50; i < size.Width()-50; i++)\r\n\t{\r\n\t\tpDC->BitBlt(i, 0, 1, sizeBitmap.cy, &dcMemory, \r\n\t\t\t50, 0, SRCCOPY);\r\n\t}\r\n\r\n\tpDC->BitBlt(size.Width()-50, 0, 50, sizeBitmap.cy, &dcMemory, \r\n\t\tsizeBitmap.cx-50, 0, SRCCOPY);\r\n\r\n    dcMemory.SelectObject(pOldBitmap);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CEditWithButton::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)\r\n{\r\n\t//this will draw the background again\r\n\t//so that the button will be drawn if the text exists\r\n\r\n\tInvalidateRect(NULL);\r\n\r\n\tCEdit::OnKeyDown(nChar, nRepCnt, nFlags);\r\n}\r\n\r\nvoid CEditWithButton::OnLButtonUp(UINT nFlags, CPoint point)\r\n{\r\n\t//if the button is clicked then send message to the\r\n\t//owner.. the owner need not be parent\r\n\t//you can set the owner using the CWnd::SetOwner method\r\n\tCRect crClose;\r\n\tGetWindowRect(crClose);\r\n\tScreenToClient(crClose);\r\n\r\n\r\n\tint left = crClose.right - (m_sizeFilledBitmap.cx - m_rcButtonArea.left);\r\n\tint right = crClose.right - (m_sizeFilledBitmap.cx - m_rcButtonArea.right);\r\n\r\n\tcrClose.top = m_rcButtonArea.top;\r\n\tcrClose.bottom = m_rcButtonArea.bottom;\r\n\tcrClose.left = left;\r\n\tcrClose.right = right;\r\n\r\n\tif (crClose.PtInRect(point))\r\n\t{\r\n\t\t//it is assumed that when the text is not typed in the\r\n\t\t//edit control, the button will not be visible\r\n\t\t//but you can override this by setting \r\n\t\t//the m_bButtonExistsAlways to TRUE\r\n\t\tif ( (GetWindowTextLength() > 0) || m_bButtonExistsAlways)\r\n\t\t{\r\n\t\t\tCWnd *pOwner = GetOwner();\r\n\t\t\tif (pOwner)\r\n\t\t\t{\r\n\t\t\t\tpOwner->SendMessage(m_iButtonClickedMessageId, 0, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tCEdit::OnLButtonUp(nFlags, point);\r\n}\r\n\r\n\r\n//by default, when the mouse moves over the edit control\r\n//the system shows the I-beam cursor. However we want to\r\n//show the arrow cursor when it is over the Non-Edit area\r\n//where the button and icon is displayed\r\n//here is the code to do this\r\nBOOL CEditWithButton::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)\r\n{\r\n\tCPoint pntCursor;\r\n\tGetCursorPos(&pntCursor);\r\n\tScreenToClient(&pntCursor);\r\n\r\n\tCRect edit;\r\n\tGetWindowRect(edit);\r\n\tScreenToClient(edit);\r\n\tedit.left += m_rcBorder.left;\r\n\tedit.top += m_rcBorder.top;\r\n\tedit.right -= m_rcBorder.right;\r\n\tedit.bottom -= m_rcBorder.bottom;\r\n\r\n\t//if mouse is not in the edit area then\r\n\t//show arrow cursor\r\n\tif (!edit.PtInRect(pntCursor))\r\n\t{\r\n\t\tSetCursor(AfxGetApp()->LoadStandardCursor(MAKEINTRESOURCE(IDC_ARROW)));\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn CEdit::OnSetCursor(pWnd, nHitTest, message);\r\n}\r\n\r\nint CEditWithButton::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CEdit::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\r\n\tResizeWindow();\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\nLRESULT CEditWithButton::OnSetFont( WPARAM wParam, LPARAM lParam )\r\n{\r\n\tDefWindowProc(WM_SETFONT, wParam, lParam);\r\n\r\n\tResizeWindow();\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CEditWithButton::OnSize(UINT nType, int cx, int cy) \r\n{\r\n\tCEdit::OnSize(nType, cx, cy);\r\n\r\n\tResizeWindow();\r\n}\r\n\r\n"
        },
        {
          "name": "EditWithButton.h",
          "type": "blob",
          "size": 1.46875,
          "content": "#pragma once\n\n//DISCLAIMER:\n//The code in this project is Copyright (C) 2006 by Gautam Jain. You have the right to\n//use and distribute the code in any way you see fit as long as this paragraph is included\n//with the distribution. No warranties or claims are made as to the validity of the\n//information and code contained herein, so use it at your own risk.\n\n\n// CEditWithButton\n\nclass CEditWithButton : public CEdit\n{\n\tDECLARE_DYNAMIC(CEditWithButton)\n\nprotected:\n\tCBitmap m_bmpEmptyEdit;\n\tCBitmap m_bmpFilledEdit;\n\tCSize   m_sizeEmptyBitmap;\n\tCSize   m_sizeFilledBitmap;\n\tCRect\tm_rcEditArea;\n\tCRect\tm_rcBorder;\n\tCRect\tm_rcButtonArea;\n\tBOOL\tm_bButtonExistsAlways;\n\tUINT\tm_iButtonClickedMessageId;\n\npublic:\n\tBOOL SetBitmaps(UINT iEmptyEdit, UINT iFilledEdit);\n\tvoid SetButtonArea(CRect rcButtonArea);\n\tBOOL SetBorder(CRect rcEditArea);\n\tvoid SetButtonExistsAlways(BOOL bButtonExistsAlways);\n\n\tCEditWithButton();\n\tvirtual ~CEditWithButton();\n\tvirtual void PreSubclassWindow( );\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\nprotected:\n\n\tvoid ResizeWindow();\n\n\n\tDECLARE_MESSAGE_MAP()\npublic:\n\t\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\tafx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);\n\tafx_msg void OnLButtonUp(UINT nFlags, CPoint point);\n\tafx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam); // Maps to WM_SETFONT\n};"
        },
        {
          "name": "EditWnd.h",
          "type": "blob",
          "size": 0.9716796875,
          "content": "#pragma once\n\n#include \"DittoRulerRichEditCtrl.h\"\n#include \"TabCtrl.h\"\n#include \"ClipIds.h\"\n\nclass CEditWnd : public CWnd\n{\n\tDECLARE_DYNAMIC(CEditWnd)\n\npublic:\n\tCEditWnd();\n\tvirtual ~CEditWnd();\n\n\tbool EditIds(CClipIDs &Ids);\n\tbool CloseEdits(bool bPrompt);\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n\n\tCTabCtrlEx m_Tabs;\n\tCToolBar m_ToolBar;\n\tCToolTipCtrl m_ToolTip;\n\tstd::vector<CDittoRulerRichEditCtrl*> m_Edits;\n\tCButton m_cbUpdateDescription;\n\tCFont m_Font;\n\tlong m_lLastSaveID;\n\nprotected:\n\tvoid MoveControls();\n\tint IsIDAlreadyInEdit(int id, bool bSetFocus);\n\tbool AddItem(int id);\n\tbool DoSave();\n\tbool DoSaveItem(int index);\n\npublic:\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnSave();\n\tafx_msg void OnDestroy();\n\tafx_msg void OnSaveAll();\n\tafx_msg void OnClose();\n\tafx_msg void OnNew();\n\tafx_msg void OnSaveCloseClipboard();\n\tafx_msg void OnSetFocus(CWnd* pOldWnd);\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n};\n\n\n"
        },
        {
          "name": "EncryptDecrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "EventThread.cpp",
          "type": "blob",
          "size": 6.318359375,
          "content": "#include \"StdAfx.h\"\n#include \"EventThread.h\"\n#include \"Misc.h\"\n\n#define EXIT_EVENT -1\n#define REBUILD_EVENTS -2\n\nCEventThread::CEventThread(void)\n{\n\tm_hEvt = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tm_waitTimeout = INFINITE;\n\tm_threadRunning = false;\n\tm_exitThread = false;\n\tm_threadWasStarted = false;\n\n\tAddEvent(EXIT_EVENT);\n\tAddEvent(REBUILD_EVENTS);\n}\n\nCEventThread::~CEventThread(void)\n{\n\tStop();\n\n\tfor(EventMapType::iterator it = m_eventMap.begin(); it != m_eventMap.end(); it++)\n\t{\n\t\tCloseHandle(it->first);\n\t}\n}\n\nUINT CEventThread::EventThreadFnc(void* thisptr) \n{\n\tCEventThread *threadClass = (CEventThread*)thisptr;\n\tthreadClass->RunThread();\n\treturn 0;\n}\n\nvoid CEventThread::AddEvent(int eventId)\n{\n\tHANDLE handle = CreateEvent(NULL, FALSE, FALSE, _T(\"\"));\n\n\t{\n\t\tATL::CCritSecLock csLock(m_lock.m_sect);\n\t\tm_eventMap[handle] = eventId;\n\t}\n\n\tif (m_threadRunning)\n\t{\n\t\tFireEvent(REBUILD_EVENTS);\n\t}\n}\n\nvoid CEventThread::AddEvent(int eventId, HANDLE handle)\n{\n\t{\n\t\tATL::CCritSecLock csLock(m_lock.m_sect);\n\t\tm_eventMap[handle] = eventId;\n\t}\n\n\tif (m_threadRunning)\n\t{\n\t\tFireEvent(REBUILD_EVENTS);\n\t}\n}\n\nvoid CEventThread::AddEvent(int eventId, CString name)\n{\n\t//handle creating events cross users/cross process\n\t//https://stackoverflow.com/questions/29976596/shared-global-event-between-a-service-user-mode-processes-doesnt-work\n\tSECURITY_DESCRIPTOR sd;\n\tInitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);\n\tSetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);\n\n\tSECURITY_ATTRIBUTES sa = { 0 };\n\tsa.nLength = sizeof(sa);\n\tsa.bInheritHandle = FALSE;\n\tsa.lpSecurityDescriptor = &sd;\n\n\tHANDLE handle = CreateEvent(&sa, FALSE, FALSE, name);\n\n\t{\n\t\tATL::CCritSecLock csLock(m_lock.m_sect);\n\t\tm_eventMap[handle] = eventId;\n\t}\n\n\tif (m_threadRunning)\n\t{\n\t\tFireEvent(REBUILD_EVENTS);\n\t}\n}\n\nbool CEventThread::FireEvent(int eventId)\n{\n\tHANDLE eventHandle = GetHandle(eventId);\n\tif(eventHandle != nullptr)\n\t{\n\t\tSetEvent(eventHandle);\n\t\treturn true;\n\t}\t\n\n\treturn false;\n}\n\nbool CEventThread::UndoFireEvent(int eventId)\n{\n\tHANDLE eventHandle = GetHandle(eventId);\n\tif (eventHandle != nullptr)\n\t{\n\t\tResetEvent(eventHandle);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nHANDLE CEventThread::GetHandle(int eventId)\n{\t\n\tATL::CCritSecLock csLock(m_lock.m_sect);\n\tfor (auto it = m_eventMap.begin(); it != m_eventMap.end(); it++)\n\t{\n\t\tif (it->second == eventId)\n\t\t{\n\t\t\treturn it->first;\n\t\t}\n\t}\n\n\treturn nullptr;\n}\n\nbool CEventThread::RemoveEvent(int eventId)\n{\n\tATL::CCritSecLock csLock(m_lock.m_sect);\n\tfor (auto it = m_eventMap.begin(); it != m_eventMap.end(); it++)\n\t{\n\t\tif (it->second == eventId)\n\t\t{\n\t\t\tif (m_threadRunning)\n\t\t\t{\n\t\t\t\tFireEvent(REBUILD_EVENTS);\n\t\t\t}\n\n\t\t\tCloseHandle(it->first);\n\t\t\tm_eventMap.erase(it);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid CEventThread::Start(void *param) \n{\n\tif(m_threadRunning == false)\n\t{\n\t\tResetEvent(m_hEvt);\n\t\tm_exitThread = false;\n\t\tm_param = param;\n\t\tm_thread = (HANDLE)_beginthreadex(NULL, 0, EventThreadFnc, this, 0, &m_threadID);\n\n\t\t// now wait until the thread is up and really running\n\t\tWaitForSingleObject(m_hEvt, 1000);\n\t}\n\telse\n\t{\n\t\tUndoFireEvent(EXIT_EVENT);\n\t}\n}\n\nvoid CEventThread::WaitForThreadToExit(int waitTime)\n{\n\tWaitForSingleObject(m_hEvt, waitTime);\n}\n\nvoid CEventThread::Stop(int waitTime) \n{\n\tLog(StrF(_T(\"Start of CEventThread::Stop(int waitTime) %d - Name: %s\"), waitTime, m_threadName));\n\n\tif(m_threadRunning)\n\t{\n\t\tm_exitThread = true;\t\n\t\tFireEvent(EXIT_EVENT);\n\n\t\tif(waitTime > 0)\n\t\t{\n\t\t\tif (WAIT_OBJECT_0 != WaitForSingleObject(m_hEvt, waitTime))\n\t\t\t{\n\t\t\t\tLog(_T(\"Start of TerminateThread CEventThread::Stop(int waitTime) \"));\n\t\t\t\tTerminateThread(m_thread, 0);\n\t\t\t\tLog(_T(\"End of TerminateThread CEventThread::Stop(int waitTime) \"));\n\t\t\t\tm_threadRunning = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tLog(StrF(_T(\"End of CEventThread::Stop(int waitTime) %d - Name: %s\"), waitTime, m_threadName));\n};\n\nvoid CEventThread::GetHandleVector(std::vector<HANDLE> &handles)\n{\n\tATL::CCritSecLock csLock(m_lock.m_sect);\n\thandles.clear();\n\tfor (auto it = m_eventMap.begin(); it != m_eventMap.end(); it++)\n\t{\n\t\tif (it->first != 0)\n\t\t{\n\t\t\thandles.push_back(it->first);\n\t\t}\n\t}\n}\n\nvoid CEventThread::CheckForRebuildHandleVector(std::vector<HANDLE>& handles)\n{\n\tATL::CCritSecLock csLock(m_lock.m_sect);\n\tfor (auto it = m_eventMap.begin(); it != m_eventMap.end(); it++)\n\t{\n\t\tif (it->second == REBUILD_EVENTS)\n\t\t{\n\t\t\tDWORD result = WaitForSingleObject(it->first, 0);\n\t\t\tif (result == WAIT_OBJECT_0)\n\t\t\t{\n\t\t\t\tGetHandleVector(handles);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid CEventThread::RunThread()\n{\n\tLog(StrF(_T(\"Start of CEventThread::RunThread() Name: %s\"), m_threadName));\n\n\tm_threadRunning = true;\n\tm_threadWasStarted = true;\n\tstd::vector<HANDLE> handles;\n\n\tGetHandleVector(handles);\n\n\tSetEvent(m_hEvt);\n\tResetEvent(m_hEvt);\n\n\twhile(m_exitThread == false)\n\t{\n\t\tCheckForRebuildHandleVector(handles);\n\n\t\tDWORD event = WaitForMultipleObjects((DWORD)handles.size(), handles.data(), FALSE, m_waitTimeout);\n\n\t\tif(event == WAIT_FAILED)\n\t\t{\n\t\t\tconst DWORD errorMessageId = GetLastError();\n\t\t\tLPSTR messageBuffer = nullptr;\n\t\t\tsize_t size = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, errorMessageId, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, nullptr);\n\n\t\t\tCString message(messageBuffer, (int)size);\n\n\t\t\tLocalFree(messageBuffer);\n\n\t\t\tLog(StrF(_T(\"CEventThread::RunThread() Error, error: %s - Name %s\"), message, m_threadName));\n\n\t\t\tSleep(1000);\n\t\t}\n\t\telse if(event == WAIT_TIMEOUT)\n\t\t{\n\t\t\tOnTimeOut(m_param);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int handleIndex = event - WAIT_OBJECT_0;\n\t\t\tif (handleIndex < 0 || handleIndex >= handles.size())\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"CEventThread::RunThread() Error, Invalid handle index, index: %d, size: %d - Name %s\"), handleIndex, handles.size(), m_threadName));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tHANDLE firedHandle = handles[handleIndex];\n\t\t\tconst int eventId = m_eventMap[firedHandle];\n\t\t\tif(eventId == EXIT_EVENT)\n\t\t\t{\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eventId == REBUILD_EVENTS)\n\t\t\t{\n\t\t\t\tGetHandleVector(handles);\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"Start of CEventThread::RunThread() - OnEvent %d - Name %s\"), eventId, m_threadName));\n\t\t\t\tOnEvent(eventId, m_param);\n\t\t\t\tLog(StrF(_T(\"End of CEventThread::RunThread() - OnEvent %d - Name: %s\"), eventId, m_threadName));\n\t\t\t}\n\t\t}\n\t}\n\n\tUndoFireEvent(EXIT_EVENT);\n\n\tSetEvent(m_hEvt);\n\n\tLog(StrF(_T(\"End of CEventThread::RunThread() Name: %s\"), m_threadName));\n\n\tm_threadRunning = false;\n}\n"
        },
        {
          "name": "EventThread.h",
          "type": "blob",
          "size": 1.2470703125,
          "content": "#pragma once\n\n#include <vector>\n#include <map>\n\ntypedef std::map<HANDLE, int> EventMapType;\n\nclass CEventThread\n{\npublic:\n\tCEventThread(void);\n\t~CEventThread(void);\n\n\tstatic unsigned int __stdcall EventThreadFnc(void* thisptr);\n\nprotected:\n\tvirtual void OnEvent(int eventId, void *param)\t{ return; }\n\tvirtual void OnTimeOut(void *param) { return; }\n\tvoid RunThread();\n\tbool UndoFireEvent(int eventId);\n\tHANDLE GetHandle(int eventId);\n\tbool RemoveEvent(int eventId);\n\n\tUINT m_threadID;\n\tHANDLE m_thread;\n\tHANDLE m_hEvt;\n\tEventMapType m_eventMap;\n\tbool m_exitThread;\n\tbool m_threadRunning;\n\tbool m_threadWasStarted;\n\tvoid *m_param;\n\tint m_waitTimeout;\n\tCString m_threadName;\n\tCCriticalSection m_lock;\n\npublic:\n\tvoid Start(void *param = NULL);\n\tvoid Stop(int waitTime = 5000); \n\tvoid AddEvent(int eventId);\n\tvoid AddEvent(int eventId, CString name);\n\tvoid AddEvent(int eventId, HANDLE handle);\n\tbool FireEvent(int eventId);\n\tbool IsCancelled() { return m_exitThread; }\n\tvoid CancelThread() { m_exitThread = true; }\n\tbool IsRunning() { return m_threadRunning; }\n\tbool ThreadWasStarted() { return m_threadWasStarted; }\n\tvoid WaitForThreadToExit(int waitTime);\n\tvoid GetHandleVector(std::vector<HANDLE> &handles);\n\tvoid CheckForRebuildHandleVector(std::vector<HANDLE>& handles);\n};\n\n"
        },
        {
          "name": "ExternalWindowTracker.cpp",
          "type": "blob",
          "size": 12.4423828125,
          "content": "#include \"stdafx.h\"\r\n#include \"externalwindowtracker.h\"\r\n#include \"Misc.h\"\r\n#include \"SendKeys.h\"\r\n#include \"Options.h\"\r\n#include \"CP_Main.h\"\r\n#include \"UAC_Helper.h\"\r\n\r\nExternalWindowTracker::ExternalWindowTracker(void)\r\n{\r\n\tm_activeWnd = NULL;\r\n\tm_focusWnd = NULL;\r\n\tm_dittoHasFocus = false;\r\n\tm_desktopHasFocus = false;\r\n\r\n\tm_AccessibleObjectFromWindow = NULL;\r\n\tm_hOleacc = LoadLibrary(_T(\"oleacc.dll\"));\r\n\tif (m_hOleacc)\r\n\t{\r\n\t\tm_AccessibleObjectFromWindow = (AccessibleObjectFromWindow)GetProcAddress(m_hOleacc, \"AccessibleObjectFromWindow\");\r\n\t}\r\n}\r\n\r\nExternalWindowTracker::~ExternalWindowTracker(void)\r\n{\r\n\tif (m_hOleacc)\r\n\t{\r\n\t\tFreeLibrary(m_hOleacc);\r\n\t\tm_hOleacc = NULL;\r\n\t\tm_AccessibleObjectFromWindow = NULL;\r\n\t}\r\n}\r\n\r\n\r\nbool ExternalWindowTracker::TrackActiveWnd(bool force)\r\n{\r\n\tif(force == false && IdleSeconds() < (CGetSetOptions::GetMinIdleTimeBeforeTrackFocus() / 1000.0))\r\n\t{\r\n\t\tLog(StrF(_T(\"Not Idle for long enough, IdleTime: %f, MinIdle %f\"), IdleSeconds(), (CGetSetOptions::GetMinIdleTimeBeforeTrackFocus() / 1000.0)));\r\n\t\treturn false;\r\n\t}\r\n\r\n\tm_desktopHasFocus = false;\r\n\tBOOL fromHook = true;\r\n\tHWND newFocus = NULL;\r\n\tHWND newActive = ::GetForegroundWindow();\r\n\r\n\tif(CGetSetOptions::GetUseGuiThreadInfoForFocus())\r\n\t{\r\n\t\tGUITHREADINFO guiThreadInfo;\r\n\t\tguiThreadInfo.cbSize = sizeof(GUITHREADINFO);\r\n\t\tDWORD OtherThreadID = GetWindowThreadProcessId(newActive, NULL);\r\n\t\tif(GetGUIThreadInfo(OtherThreadID, &guiThreadInfo))\r\n\t\t{\r\n\t\t\tnewFocus = guiThreadInfo.hwndFocus;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(AttachThreadInput(GetWindowThreadProcessId(newActive, NULL), GetCurrentThreadId(), TRUE))\r\n\t\t{\r\n\t\t\tnewFocus = GetFocus();\r\n\t\t\tAttachThreadInput(GetWindowThreadProcessId(newActive, NULL), GetCurrentThreadId(), FALSE);\r\n\t\t}\r\n\t}\r\n\r\n\tif(newFocus == 0 && newActive != 0)\r\n\t{\r\n\t\tnewFocus = newActive;\r\n\t}\r\n\telse if(newActive == 0 && newFocus != 0)\r\n\t{\r\n\t\tnewActive = newFocus;\r\n\t}\r\n\r\n\tif(newFocus == 0 || !IsWindow(newFocus) || newActive == 0 || !IsWindow(newActive))\r\n\t{\r\n\t\tLog(_T(\"TargetActiveWindow values invalid\"));\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif(NotifyTrayhWnd(newActive) || NotifyTrayhWnd(newFocus))\r\n\t{\r\n\t\tLog(_T(\"TargetActiveWindow shell tray icon has active\"));\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif(IsAppWnd(newFocus) || IsAppWnd(newActive))\r\n\t{\r\n\t\tif(m_dittoHasFocus == false)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"Ditto has focus - Active: %s (%d), Focus: %s (%d), FromHook %d\"), WndName(m_activeWnd), m_activeWnd, WndName(m_focusWnd), m_focusWnd, fromHook));\r\n\t\t}\r\n\r\n\t\tm_dittoHasFocus = true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTCHAR cName[MAX_PATH];\r\n\tGetClassName(newActive, cName, _countof(cName));\r\n\tCString className(cName);\r\n\tif (className == _T(\"Progman\"))\r\n\t{\r\n\t\tm_desktopHasFocus = true;\r\n\t}\r\n\r\n\tm_focusWnd = newFocus;\r\n\tm_activeWnd = newActive;\r\n\tm_dittoHasFocus = false;\r\n\r\n\tif(theApp.QPasteWnd())\r\n\t\ttheApp.QPasteWnd()->UpdateStatus(true);\r\n\r\n\tLog(StrF(_T(\"TargetActiveWindow Active: %s (%d), Focus: %s (%d), FromHook %d, IdleTime: %f\"), WndName(m_activeWnd), m_activeWnd, WndName(m_focusWnd), m_focusWnd, fromHook, IdleSeconds()));\r\n\r\n\treturn true;\r\n}\r\n\r\nbool ExternalWindowTracker::WaitForActiveWnd(HWND activeWnd, int timeout)\r\n{\r\n\tDWORD start = GetTickCount();\r\n\twhile(((int)(GetTickCount() - start)) < timeout)\r\n\t{\r\n\t\tif(::GetForegroundWindow() == activeWnd)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"found focus wait %d\"), GetTickCount()-start));\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tSleep(0);\r\n\t\tActivateTarget();\r\n\t}\r\n\r\n\tLog(_T(\"Didn't find focus\"));\r\n\treturn false;\r\n}\r\n\r\nvoid ExternalWindowTracker::ActivateFocus(const HWND activeHwnd, const HWND focushWnd)\r\n{\r\n\tCString csApp = GetProcessName(m_activeWnd);\r\n\tLog(StrF(_T(\"SetFocus - AppName: %s, Active: %d, Focus: %d\"), csApp, m_activeWnd, m_focusWnd));\r\n\r\n\tif (focushWnd != NULL) \r\n\t{\r\n\t\tAttachThreadInput(GetWindowThreadProcessId(activeHwnd, NULL), GetCurrentThreadId(), TRUE);\r\n\t\tif (GetFocus() != focushWnd) \r\n\t\t{\r\n\t\t\tSetFocus(focushWnd);\r\n\t\t}\r\n\t\tAttachThreadInput(GetWindowThreadProcessId(activeHwnd, NULL), GetCurrentThreadId(), FALSE);\r\n\t}\r\n}\r\n\r\nbool ExternalWindowTracker::NotifyTrayhWnd(HWND hWnd)\r\n{\r\n\tHWND hParent = hWnd;\r\n\r\n\tint nCount = 0;\r\n\r\n\twhile(hParent != NULL)\r\n\t{\r\n\t\tTCHAR className[100];\r\n\t\tGetClassName(hParent, className, (sizeof(className) / sizeof(TCHAR)));\r\n\r\n\t\tif((STRCMP(className, _T(\"Shell_TrayWnd\")) == 0) || \r\n\t\t\t(STRCMP(className, _T(\"NotifyIconOverflowWindow\")) == 0) ||\r\n\t\t\t(STRCMP(className, _T(\"TrayNotifyWnd\")) == 0))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\thParent = ::GetParent(hParent);\r\n\t\tif(hParent == NULL)\r\n\t\t\tbreak;\r\n\r\n\t\tnCount++;\r\n\t\tif(nCount > 100)\r\n\t\t{\r\n\t\t\tLog(_T(\"GetTargetName reached maximum search depth of 100\"));\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool ExternalWindowTracker::ActivateTarget()\r\n{\r\n\tLog(StrF(_T(\"Activate Target - Active: %d, Focus: %d\"), m_activeWnd, m_focusWnd));\r\n\r\n\tif (IsIconic(m_activeWnd))\r\n\t{\r\n\t\tShowWindow(m_activeWnd, SW_RESTORE);\r\n\t}\r\n\r\n\t// Save specified timeout period...\r\n\tPVOID timeoutMS = 0;\r\n\tSystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, &timeoutMS, 0);\r\n\t// ... then set it to zero to disable it\r\n\tSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, (PVOID)0, 0);\r\n\r\n\t//If we are doing this and we are not the current foreground window then attach to the current bef \r\n\t//setting the focus window\r\n\t//this shouldn't happen that much, most of the time we are the foreground window\r\n\tbool detach = false;\r\n\tDWORD foreGroundProcessId = GetWindowThreadProcessId(::GetForegroundWindow(), NULL);\r\n\tif(foreGroundProcessId != GetCurrentThreadId())\r\n\t{\r\n\t\tLog(_T(\"Attach to process, calling set foreground from non forground window\"));\r\n\t\tif(AttachThreadInput(foreGroundProcessId, GetCurrentThreadId(), TRUE))\r\n\t\t{\r\n\t\t\tdetach = true;\r\n\t\t}\r\n\t}\r\n\r\n\tBringWindowToTop(m_activeWnd);\r\n\tSetForegroundWindow(m_activeWnd);\r\n\t\r\n\tif(detach)\r\n\t{\r\n\t\tAttachThreadInput(foreGroundProcessId, GetCurrentThreadId(), FALSE);\r\n\t}\r\n\r\n\t//check to see if this app should set focus\r\n\t//this is off by default\r\n\tCString csApp = GetProcessName(m_activeWnd);\r\n\tif(CGetSetOptions::GetSetFocusToApp(csApp))\r\n\t{\r\n\t\tActivateFocus(m_activeWnd, m_focusWnd);\r\n\t}\r\n\r\n\tSystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, (PVOID)timeoutMS, 0);\r\n\r\n\t//Sleep(250);\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid ExternalWindowTracker::SendPaste(bool activateTarget)\r\n{\r\n\tHWND activeWnd = m_activeWnd;\r\n\r\n\tCSendKeys send;\r\n\tsend.AllKeysUp();\r\n\r\n\tif(activateTarget)\r\n\t{\r\n\t\tDWORD startTick = GetTickCount();\r\n\r\n\t\tActivateTarget();\r\n\t\ttheApp.PumpMessageEx();\r\n\t\tWaitForActiveWnd(activeWnd, max(25, CGetSetOptions::WaitForActiveWndTimeout()));\r\n\t\r\n\t\tDWORD endTick = GetTickCount();\r\n\t\tif((endTick-startTick) > 150)\r\n\t\t\tLog(StrF(_T(\"Paste Timing Send Paste around activate Target: %d\"), endTick-startTick));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tactiveWnd = ::GetForegroundWindow();\r\n\t}\r\n\r\n\tCString csPasteToApp = GetProcessName(activeWnd);\r\n\tCString csPasteString = CGetSetOptions::GetPasteString(csPasteToApp);\r\n\tDWORD delay = CGetSetOptions::SendKeysDelay();\r\n\tDWORD sendKeysDelay = CGetSetOptions::RealSendKeysDelay();\r\n\r\n\tm_dittoHasFocus = false;\r\n\tLog(StrF(_T(\"Sending paste to app %s key stroke: %s, SeDelay: %d\"), csPasteToApp, csPasteString, delay));\r\n\r\n\tbool pasteAsAdmin = false;\r\n\r\n\tif (CGetSetOptions::GetPasteAsAdmin())\r\n\t{\r\n\t\tpasteAsAdmin = CUAC_Helper::PasteAsAdmin(activeWnd);\r\n\t}\r\n\r\n\t//can't run an elevated app when running windows app\r\n\tif(CGetSetOptions::GetIsWindowsApp() == FALSE &&\r\n\t\tpasteAsAdmin &&\r\n\t\ttheApp.UACThreadRunning() == false)\r\n\t{\r\n\t\tLog(StrF(_T(\"Passing paste off to uac aware app\")));\r\n\t\tif (theApp.UACPaste() == false)\r\n\t\t{\r\n\t\t\tpasteAsAdmin = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (pasteAsAdmin == false)\r\n\t{\r\n\t\tif(activateTarget)\r\n\t\t{\r\n\t\t\tSleep(delay);\r\n\t\t}\r\n\t\tsend.SetKeyDownDelay(sendKeysDelay);\r\n\t\tsend.SendKeys(csPasteString, true);\r\n\t}\r\n\r\n\tLog(_T(\"Post sending paste\"));\r\n}\r\n\r\nvoid ExternalWindowTracker::SendCopy(CopyReasonEnum::CopyReason copyReason)\r\n{\r\n\tCSendKeys send;\r\n\tsend.AllKeysUp();\r\n\r\n\tHWND activeWnd = GetForegroundWindow();\r\n\r\n\tCString csToApp = GetProcessName(activeWnd);\r\n\tCString csString = CGetSetOptions::GetCopyString(csToApp);\r\n\tDWORD delay = CGetSetOptions::SendKeysDelay();\r\n\tDWORD SendKeysDelay = CGetSetOptions::RealSendKeysDelay();\r\n\r\n\tSleep(delay);\r\n\r\n\ttheApp.PumpMessageEx();\r\n\r\n\tLog(StrF(_T(\"Sending copy to app %s key stroke: %s, Delay: %d\"), csToApp, csString, delay));\r\n\r\n\tbool pasteAsAdmin = false;\r\n\r\n\tif (CGetSetOptions::GetPasteAsAdmin())\r\n\t{\r\n\t\tpasteAsAdmin = CUAC_Helper::PasteAsAdmin(activeWnd);\r\n\t}\r\n\r\n\t//can't run an elevated app when running windows app\r\n\tif(CGetSetOptions::GetIsWindowsApp() == FALSE &&\r\n\t\tpasteAsAdmin &&\r\n\t\ttheApp.UACThreadRunning() == false)\r\n\t{\r\n\t\tLog(StrF(_T(\"Passing copy off to uac aware app\")));\r\n\t\tif (theApp.UACCopy() == false)\r\n\t\t{\r\n\t\t\tpasteAsAdmin = false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pasteAsAdmin == false)\r\n\t{\r\n\t\t//give the app some time to take focus before sending paste\r\n\t\tSleep(delay);\r\n\t\tsend.SetKeyDownDelay(SendKeysDelay);\r\n\r\n\t\ttheApp.SetCopyReason(copyReason);\r\n\r\n\t\tsend.SendKeys(csString, true);\r\n\t}\t\r\n\r\n\tLog(_T(\"Post sending copy\"));\r\n}\r\n\r\n// sends Ctrl-X to the TargetWnd\r\nvoid ExternalWindowTracker::SendCut()\r\n{\r\n\tCSendKeys send;\r\n\tsend.AllKeysUp();\r\n\r\n\tCString csToApp = GetProcessName(m_activeWnd);\r\n\tCString csString = CGetSetOptions::GetCutString(csToApp);\r\n\tDWORD delay = CGetSetOptions::SendKeysDelay();\r\n\tDWORD sendKeysDelay = CGetSetOptions::RealSendKeysDelay();\r\n\r\n\tSleep(delay);\r\n\r\n\ttheApp.PumpMessageEx();\r\n\t  \r\n\tLog(StrF(_T(\"Sending cut to app %s key stroke: %s, Delay: %d\"), csToApp, csString, delay));\r\n\r\n\r\n\tbool pasteAsAdmin = false;\r\n\r\n\tif (CGetSetOptions::GetPasteAsAdmin())\r\n\t{\r\n\t\tpasteAsAdmin = CUAC_Helper::PasteAsAdmin(m_activeWnd);\r\n\t}\r\n\r\n\t//can't run an elevated app when running windows app\r\n\tif(CGetSetOptions::GetIsWindowsApp() == FALSE &&\r\n\t\tpasteAsAdmin &&\r\n\t\ttheApp.UACThreadRunning() == false)\r\n\t{\r\n\t\tLog(StrF(_T(\"Passing copy off to uac aware app\")));\r\n\t\tif (theApp.UACCut() == false)\r\n\t\t{\r\n\t\t\tpasteAsAdmin = false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pasteAsAdmin == false)\r\n\t{\r\n\t\t//give the app some time to take focus before sending paste\r\n\t\tSleep(delay);\r\n\t\tsend.SetKeyDownDelay(sendKeysDelay);\r\n\r\n\t\tsend.SendKeys(csString, true);\r\n\t}\t\t\r\n\r\n\tLog(_T(\"Post sending cut\"));\r\n}\r\n\r\nCString ExternalWindowTracker::ActiveWndName() \r\n{\r\n\treturn WndName(m_activeWnd);\r\n}\r\n\r\nCString ExternalWindowTracker::WndName(HWND hWnd) \r\n{\r\n\tTCHAR cWindowText[200];\r\n\tHWND hParent = hWnd;   \r\n\r\n\t::GetWindowText(hParent, cWindowText, 100);\r\n\r\n\tint nCount = 0;\r\n\r\n\twhile(STRLEN(cWindowText) <= 0)\r\n\t{\r\n\t\thParent = ::GetParent(hParent);\r\n\t\tif(hParent == NULL)\r\n\t\t\tbreak;\r\n\r\n\t\t::GetWindowText(hParent, cWindowText, 100);\r\n\r\n\t\tnCount++;\r\n\t\tif(nCount > 100)\r\n\t\t{\r\n\t\t\tLog(_T(\"GetTargetName reached maximum search depth of 100\"));\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn cWindowText; \r\n}\r\n\r\nbool ExternalWindowTracker::ReleaseFocus()\r\n{\r\n\tif( IsAppWnd(::GetForegroundWindow()) )\r\n\t{\r\n\t\treturn ActivateTarget();\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nCPoint ExternalWindowTracker::FocusCaret()\r\n{\r\n\tCPoint pt(-1, -1);\r\n\r\n\tif(!m_activeWnd || !m_focusWnd)\r\n\t\treturn pt;\r\n\r\n\t//first try getting the caret position using IAccessible object\r\n\tif (m_AccessibleObjectFromWindow)\r\n\t{\r\n\t\t{\r\n\t\t\tIAccessible* pIAccessible = NULL;\r\n\t\t\tHRESULT hr = m_AccessibleObjectFromWindow(m_activeWnd, OBJID_CARET, __uuidof(IAccessible), (void**)&pIAccessible);\r\n\t\t\tif (hr == S_OK)\r\n\t\t\t{\r\n\t\t\t\tlong left = 0, top = 0, width = 0, height = 0;\r\n\t\t\t\tVARIANT varCaret;\r\n\t\t\t\tvarCaret.vt = VT_I4;\r\n\t\t\t\tvarCaret.lVal = CHILDID_SELF;\r\n\t\t\t\thr = pIAccessible->accLocation(&left, &top, &width, &height, varCaret);\r\n\t\t\t\tpIAccessible->Release();\r\n\t\t\t\tif (hr == S_OK && left != 0 && top != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// calculate offset of caret by Accessible \r\n\t\t\t\t\tpt.SetPoint(left + width, top + 20);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (pt.x != -1 && pt.y != -1)\r\n\t\treturn pt;\r\n\r\n\t//next try GetGUIThreadInfo\r\n\tGUITHREADINFO guiThreadInfo;\r\n\tguiThreadInfo.cbSize = sizeof(GUITHREADINFO);\r\n\tDWORD OtherThreadID = GetWindowThreadProcessId(m_activeWnd, NULL);\r\n\tif(GetGUIThreadInfo(OtherThreadID, &guiThreadInfo))\r\n\t{\r\n\t\tCRect rc(guiThreadInfo.rcCaret);\r\n\t\tif(rc.IsRectEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tpt = rc.BottomRight();\r\n\t\t\t::ClientToScreen(m_focusWnd, &pt);\r\n\t\t}\r\n\t}\r\n\tif(pt.x != -1 && pt.y != -1)\r\n\t\treturn pt;\r\n\r\n\t//last try attatching to there thread\r\n\tDWORD currentThreadId = GetCurrentThreadId();\r\n\tif(AttachThreadInput(OtherThreadID, currentThreadId, TRUE))\r\n\t{\r\n\t\tBOOL ok = GetCaretPos(&pt);\r\n\t\tif(ok && (pt.x != 0 && pt.y != 0))\r\n\t\t{\r\n\t\t\t::ClientToScreen(m_focusWnd, &pt);\r\n\t\t\tif (pt.y != 0 && pt.x != 0)\r\n\t\t\t{\r\n\t\t\t\t// calculate offset of caret by GetCaretPos\r\n\t\t\t\tpt.y += 20;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpt.x = -1;\r\n\t\t\t\tpt.y = -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpt.x = -1;\r\n\t\t\tpt.y = -1;\r\n\t\t}\r\n\r\n\t\tAttachThreadInput(OtherThreadID, currentThreadId, FALSE);\r\n\t}\r\n\r\n\treturn pt;\r\n}\r\n"
        },
        {
          "name": "ExternalWindowTracker.h",
          "type": "blob",
          "size": 1.072265625,
          "content": "#pragma once\n\n#include \"Misc.h\"\n\nclass ExternalWindowTracker\n{\npublic:\n\tExternalWindowTracker(void);\n\t~ExternalWindowTracker(void);\n\n\tHWND ActiveWnd() const { return m_activeWnd; }\n\tHWND FocusWnd() const { return m_focusWnd; }\n\tbool DittoHasFocus() const { return m_dittoHasFocus; }\n\tbool DesktopHasFocus() const { return m_desktopHasFocus; }\n\n\tCString ActiveWndName();\n\tCString WndName(HWND hWnd);\n\tbool TrackActiveWnd(bool force);\n\tbool ActivateTarget();\n\tbool ReleaseFocus();\n\tCPoint FocusCaret();\n\n\tvoid SendPaste(bool activateTarget);\n\tvoid SendCut();\n\tvoid SendCopy(CopyReasonEnum::CopyReason copyReason);\n\n\tbool NotifyTrayhWnd(HWND hWnd);\n\nprotected:\n\ttypedef HRESULT(__stdcall *AccessibleObjectFromWindow)(_In_ HWND hwnd, _In_ DWORD dwId, _In_ REFIID riid, _Outptr_ void** ppvObject);\n\n\tHWND m_activeWnd;\n\tHWND m_focusWnd;\n\tbool m_dittoHasFocus;\n\tbool m_desktopHasFocus;\n\tHMODULE m_hOleacc;\n\tAccessibleObjectFromWindow m_AccessibleObjectFromWindow;\n\t\nprotected:\n\tbool WaitForActiveWnd(HWND hwndToHaveFocus, int timeout);\n\tvoid ActivateFocus(const HWND active_wnd, const HWND focus_wnd);\n};\n"
        },
        {
          "name": "FileRecieve.cpp",
          "type": "blob",
          "size": 7.361328125,
          "content": "#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"FileRecieve.h\"\n#include \"RecieveSocket.h\"\n#include \"shared/TextConvert.h\"\n#include \"Path.h\"\n#include \"UnicodeMacros.h\"\n#include \"Md5.h\"\n\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\nCFileRecieve::CFileRecieve()\n{\n\tm_pProgress = NULL;\n}\n\nCFileRecieve::~CFileRecieve()\n{\n}\n\nlong CFileRecieve::RecieveFiles(SOCKET sock, CString csIP, CFileTransferProgressDlg *pProgress)\n{\n\tCSendInfo Info;\n\tBOOL bBreak = false;\n\tBOOL lRet = FALSE;\n\tint nNumFiles = 0;\n\tint nFilesRecieved = 0;\n\tCString lastMd5;\n\n\tm_pProgress = pProgress;\n\tm_csReceivingFromIP = csIP;\n\tm_Sock.SetSocket(sock);\n\tm_Sock.SetProgressBar(pProgress);\n\n\twhile(true)\n\t{\n\t\tif(m_Sock.RecieveCSendInfo(&Info) == FALSE)\n\t\t\tbreak;\n\n\t\tswitch(Info.m_Type)\n\t\t{\n\t\tcase MyEnums::START:\n\t\t\tnNumFiles = Info.m_lParameter1;\n\t\t\tif(m_pProgress != NULL)\n\t\t\t{\n\t\t\t\tm_pProgress->SetNumFiles(nNumFiles);\n\t\t\t}\n\t\t\tLogSendRecieveInfo(StrF(_T(\"Start receiving files File Count: %d\"), nNumFiles));\n\t\t\tbreak;\n\t\tcase MyEnums::DATA_START:\n\t\t{\n\t\t\tCString csFileName = CTextConvert::Utf8ToUnicode(Info.m_cDesc);\n\t\t\tnFilesRecieved++;\n\n\t\t\tif(m_pProgress != NULL)\n\t\t\t{\n\t\t\t\tm_pProgress->StepAllFiles();\n\t\t\t\tm_pProgress->SetMessage(StrF(_T(\"Copying File %d of %d\"), nFilesRecieved, nNumFiles));\n\t\t\t\tm_pProgress->SetFileMessage(StrF(_T(\"Copying %s\"), csFileName));\n\t\t\t\tm_pProgress->PumpMessages();\n\t\t\t\tif(m_pProgress->Cancelled())\n\t\t\t\t{\n\t\t\t\t\tlRet = USER_CANCELED;\n\t\t\t\t\tbBreak = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tULONG lFileSize = (ULONG)Info.m_lParameter1;\n\n\t\t\tLogSendRecieveInfo(StrF(_T(\"START of receiving the file %s, size: %d, File %d of %d\"), csFileName, lFileSize, nFilesRecieved, nNumFiles));\n\n\t\t\tlong lRecieveRet = RecieveFileData(lFileSize, csFileName, lastMd5);\n\t\t\tif(lRecieveRet == USER_CANCELED)\n\t\t\t{\n\t\t\t\tlRet = USER_CANCELED;\n\t\t\t\tbBreak = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(lRecieveRet == FALSE)\n\t\t\t{\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Error receiving the file %s\"), csFileName));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"END of receiving the file %s, size: %d\"), csFileName, lFileSize));\n\t\t\t\tlRet = TRUE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase MyEnums::DATA_END:\n\t\t{\n\t\t\tif (Info.m_lParameter1 != 0 &&\n\t\t\t\tInfo.m_lParameter2 != 0 &&\n\t\t\t\tm_RecievedFiles.GetCount() > 0)\n\t\t\t{\n\t\t\t\tbool md5Error = false;\n\t\t\t\tCString fileName = m_RecievedFiles[m_RecievedFiles.GetCount() - 1];\n\n\t\t\t\tif (strlen(Info.m_md5) > 0 &&\n\t\t\t\t\tCGetSetOptions::GetCheckMd5OnFileTransfers())\n\t\t\t\t{\n\t\t\t\t\tCMd5 md5;\n\t\t\t\t\tCStringA localMd5 = lastMd5;\n\t\t\t\t\tCStringA remoteMd5 = Info.m_md5;\n\n\t\t\t\t\tif (localMd5 != remoteMd5)\n\t\t\t\t\t{\n\t\t\t\t\t\tlRet = MD5_MISMATCH;\n\t\t\t\t\t\tbBreak = true;\n\t\t\t\t\t\tmd5Error = true;\n\t\t\t\t\t\t::DeleteFile(fileName);\n\n\t\t\t\t\t\tLogSendRecieveInfo(StrF(_T(\"MD5 ERROR Receiving data_end for file: %s, local md5: %s remote md5: %s\"), fileName, CTextConvert::AnsiToUnicode(localMd5), CTextConvert::AnsiToUnicode(remoteMd5)));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Receiving data_end for file: %s, MD5 MATCH local md5: %s remote md5: %s\"), fileName, CTextConvert::AnsiToUnicode(localMd5), CTextConvert::AnsiToUnicode(remoteMd5)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Not checking mdf on file transfer, either setting is off or md5 is not sent, md5 Passed In: %s, setting to check: %d\"), CTextConvert::AnsiToUnicode(Info.m_md5), CGetSetOptions::GetCheckMd5OnFileTransfers()));\n\t\t\t\t}\n\n\t\t\t\tif (md5Error == false)\n\t\t\t\t{\n\t\t\t\t\tFILETIME lastWriteTime;\n\t\t\t\t\tlastWriteTime.dwLowDateTime = Info.m_lParameter1;\n\t\t\t\t\tlastWriteTime.dwHighDateTime = Info.m_lParameter2;\n\n\t\t\t\t\tHANDLE filename = CreateFile(fileName, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\t\t\t\tif (filename != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tSetFileTime(filename, NULL, NULL, &lastWriteTime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\t\tcase MyEnums::END:\n\t\t\tbBreak = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tLogSendRecieveInfo(\"::ERROR unknown action type exiting\");\n\t\t\tbBreak = true;\n\t\t}\n\n\t\tif(bBreak || theApp.m_bAppExiting)\n\t\t\tbreak;\n\t}\n\n\treturn lRet;\n}\n\nlong CFileRecieve::RecieveFileData(ULONG lFileSize, CString csFileName, CString &md5String)\n{\n\tCString csFile = CGetSetOptions::GetPath(PATH_REMOTE_FILES);\n\tCreateDirectory(csFile, NULL);\n\n\tcsFile += nsPath::ReplaceInvalid(m_csReceivingFromIP) + \"\\\\\";\n\n\tCreateDirectory(csFile, NULL);\n\t\n\tnsPath::CPath path(csFileName);\n\tcsFile += path.GetName();\n\n\tCFile File;\n\tCFileException ex;\n\tif(File.Open(csFile, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary, &ex) == FALSE)\n\t{\n\t\tTCHAR szError[200];\n\t\tex.GetErrorMessage(szError, 200);\n\t\tLogSendRecieveInfo(StrF(_T(\"Error opening file in RequestCopiedFiles, error: %s\"), szError));\n\n\t\treturn FALSE;\n\t}\n\t\n\tULONG lBytesRead = 0;\n\tlong lBytesNeeded = 0;\n\tint nPercent = 0;\n\tint nPrevPercent = 0;\n\tCMd5 md5;\n\tmd5.MD5Init();\n\n\tchar *pBuffer = new char[CHUNK_WRITE_SIZE];\n\tif(pBuffer == NULL)\n\t{\n\t\tLogSendRecieveInfo(\"Error creating buffer in RequestCopiedFiles\");\n\t\treturn FALSE;\n\t}\n\n\tBOOL calcMd5 = CGetSetOptions::GetCheckMd5OnFileTransfers();\n\n\tBOOL bRet = FALSE;\n\twhile(true)\n\t{\n\t\tlBytesNeeded = CHUNK_WRITE_SIZE;\n\t\tif(lFileSize - lBytesRead < CHUNK_WRITE_SIZE)\n\t\t\tlBytesNeeded = lFileSize - lBytesRead;\n\n\t\tif(m_Sock.RecieveExactSize(pBuffer, lBytesNeeded) == FALSE)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tFile.Write(pBuffer, lBytesNeeded);\n\n\t\tif (calcMd5)\n\t\t{\n\t\t\tmd5.MD5Update((unsigned char*)pBuffer, lBytesNeeded);\n\t\t}\n\n\t\tlBytesRead += lBytesNeeded;\n\n\t\tif(lBytesRead >= lFileSize)\n\t\t{\n\t\t\tm_pProgress->SetSingleFilePos(100);\n\t\t\tbRet = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(lBytesNeeded > 0)\n\t\t{\n\t\t\tnPercent = (int)((lBytesRead / (double)lFileSize) * 100);\n\t\t\tif((nPercent - nPrevPercent) > 5)\n\t\t\t{\n\t\t\t\tm_pProgress->SetSingleFilePos(nPercent);\n\t\t\t\tm_pProgress->PumpMessages();\n\t\t\t\tif(m_pProgress->Cancelled())\n\t\t\t\t{\n\t\t\t\t\tbRet = USER_CANCELED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnPrevPercent = nPercent;\n\t\t\t}\n\t\t}\n\t}\n\n\tFile.Close();\n\n\tmd5String = md5.MD5FinalToString();\n\n\tif(bRet)\n\t{\n\t\tm_RecievedFiles.Add(csFile);\n\t}\n\n\tdelete []pBuffer;\n\tpBuffer = NULL;\n\n\treturn bRet;\n}\n\nHGLOBAL CFileRecieve::CreateCF_HDROPBufferAsString()\n{\n\tCString data;\n\tint nFileArraySize = (int) m_RecievedFiles.GetSize();\n\tfor (int i = 0; i < nFileArraySize; i++)\n\t{\n\t\tdata += m_RecievedFiles[i];\n\t\tdata += _T(\"\\r\\n\");\n\t}\n\n\tHGLOBAL hReturn = NewGlobalP(data.GetBuffer(), (data.GetLength() + 1)*sizeof(TCHAR));\n\n\treturn hReturn;\n}\n\nHGLOBAL CFileRecieve::CreateCF_HDROPBuffer()\n{\n\tint nFileArraySize = (int)m_RecievedFiles.GetSize();\n\tif(nFileArraySize <= 0)\n\t{\n\t\tLogSendRecieveInfo(_T(\"Recieved files array is empty not creating cf_hdrop structure\"));\n\t\treturn NULL;\n\t}\n\n\tTCHAR *pBuff = NULL;\n\tint\t nBuffSize = 0;\n\n\tfor(int i = 0; i < nFileArraySize; i++)\n\t{\n\t\tnBuffSize += m_RecievedFiles[i].GetLength()+1;\n\t}\n\n\t// Add 1 extra for the final null char,\n\t// and the size of the DROPFILES struct.\n\tnBuffSize = sizeof(DROPFILES) + (sizeof(TCHAR) * (nBuffSize + 1));\n\n\tpBuff = new TCHAR[nBuffSize];\n\n\tZeroMemory(pBuff, nBuffSize);\n\t((DROPFILES*)pBuff)->pFiles = sizeof(DROPFILES);\n\t((DROPFILES*)pBuff)->fWide = TRUE;\n\n\tTCHAR* pCurrent = (TCHAR*)(LPBYTE(pBuff) + sizeof(DROPFILES));\n\n\tfor(int n = 0; n < nFileArraySize; n++)\n\t{\n\t\tSTRCPY(pCurrent, (LPCTSTR)m_RecievedFiles[n]);\n\n\t\tLogSendRecieveInfo(StrF(_T(\"CreateCF_HDROPBuffer adding the file '%s' to local cf_hdrop structure\"), pCurrent));\n\n\t\tpCurrent += m_RecievedFiles[n].GetLength(); \n\t\t*pCurrent = 0;\n\t\tpCurrent++;\n\t}\n\n\tHGLOBAL hReturn = NewGlobalP(pBuff, nBuffSize);\n\n\tdelete []pBuff;\n\tpBuff = NULL;\n\n\treturn hReturn;\n}"
        },
        {
          "name": "FileRecieve.h",
          "type": "blob",
          "size": 0.6435546875,
          "content": "#pragma once\n\n#include \"RecieveSocket.h\"\n#include \"FileTransferProgressDlg.h\"\n\n#define USER_CANCELED -2\n#define MD5_MISMATCH -3\n\nclass CFileRecieve\n{\npublic:\n\tCFileRecieve();\n\tvirtual ~CFileRecieve();\n\n\tlong RecieveFiles(SOCKET sock, CString csIP, CFileTransferProgressDlg *pProgress);\n\t\n\tHGLOBAL CreateCF_HDROPBuffer();\n\n\tHGLOBAL CreateCF_HDROPBufferAsString();\n\n\tvoid AddFile(CString csFile)\t{ m_RecievedFiles.Add(csFile); }\n\nprotected:\n\tlong RecieveFileData(ULONG lFileSize, CString csFileName, CString &md5String);\n\nprotected:\n\tCRecieveSocket m_Sock;\n\tCString m_csReceivingFromIP;\n\tCStringArray m_RecievedFiles;\n\tCFileTransferProgressDlg *m_pProgress;\n};\n"
        },
        {
          "name": "FileSend.cpp",
          "type": "blob",
          "size": 4.3466796875,
          "content": "// FileSend.cpp: implementation of the CFileSend class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"FileSend.h\"\r\n#include \"Server.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"Md5.h\"\r\n\r\n#include <shlwapi.h>\r\n\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//using namespace nsPath;\r\n\r\n\r\nCFileSend::CFileSend()\r\n{\r\n\r\n}\r\n\r\nCFileSend::~CFileSend()\r\n{\r\n\r\n}\r\n\r\nBOOL CFileSend::SendClientFiles(SOCKET sock, CClipList *pClipList)\r\n{\r\n\tif(!pClipList || pClipList->GetCount() <= 0)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"::ERROR SendClientFiles called either pClipList was null or empty\");\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tm_Send.SetSocket(sock);\r\n\r\n\tCSendInfo Info;\r\n\tBOOL bRet = FALSE;\r\n\r\n\tCStringArray CopyFiles;\r\n\r\n\tCClipFormat *pFormat = GetCF_HDROP_Data(pClipList);\r\n\tif(pFormat)\r\n\t{\r\n\t\tHDROP drop = (HDROP)GlobalLock(pFormat->m_hgData);\r\n \t\tint nNumFiles = DragQueryFile(drop, -1, NULL, 0);\r\n \t\tTCHAR file[MAX_PATH];\r\n\r\n \t\tfor(int nFile = 0; nFile < nNumFiles; nFile++)\r\n \t\t{\r\n \t\t\tif(DragQueryFile(drop, nFile, file, sizeof(file)) > 0)\r\n \t\t\t{\r\n\t\t\t\tif(PathIsDirectory(file) == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tCopyFiles.Add(file);\r\n\t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n\r\n\t\tGlobalUnlock(pFormat->m_hgData);\r\n\t}\r\n\r\n\tInfo.m_lParameter1 = (long)CopyFiles.GetSize();\r\n\tif(Info.m_lParameter1 > 0)\r\n\t{\r\n\t\tif(m_Send.SendCSendData(Info, MyEnums::START))\r\n\t\t{\r\n\t\t\tfor(int nFile = 0; nFile < Info.m_lParameter1; nFile++)\r\n\t\t\t{\r\n\t\t\t\tSendFile(CopyFiles[nFile]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tif(m_Send.SendCSendData(Info, MyEnums::END))\r\n\t\t\tbRet = TRUE;\r\n\t\r\n\treturn bRet;\r\n}\r\n\r\nCClipFormat* CFileSend::GetCF_HDROP_Data(CClipList *pClipList)\r\n{\r\n\tCClip* pClip;\r\n\tCClipFormat* pCF;\r\n\tPOSITION pos;\r\n\t\r\n\tpos = pClipList->GetHeadPosition();\r\n\twhile(pos)\r\n\t{\r\n\t\tpClip = pClipList->GetNext(pos);\r\n\t\tif(pClip)\r\n\t\t{\r\n\t\t\tpCF = pClip->m_Formats.FindFormat(CF_HDROP);\r\n\t\t\tif(pCF)\r\n\t\t\t\treturn pCF;\r\n\t\t}\r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n \r\nBOOL CFileSend::SendFile(CString csFile)\r\n{\r\n\tCFile file;\r\n\tBOOL bRet = FALSE;\r\n\tCSendInfo Info;\r\n\t\r\n\tchar *pBuffer = new char[CHUNK_WRITE_SIZE];\r\n\tif(pBuffer == NULL)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"Error creating buffer to send file over in\");\r\n\t\treturn FALSE;\r\n\t}\r\n\t\r\n\ttry\r\n\t{\r\n\t\tCFileException ex;\r\n\t\tif(file.Open(csFile, CFile::modeRead|CFile::typeBinary|CFile::shareDenyNone, &ex))\r\n\t\t{\r\n\t\t\tCStringA dest = CTextConvert::UnicodeToUTF8(csFile);\r\n\t\t\tstrncpy(Info.m_cDesc, dest, sizeof(Info.m_cDesc));\r\n\t\t\tInfo.m_cDesc[sizeof(Info.m_cDesc)-1] = 0;\t\t\t\r\n\r\n\t\t\tInfo.m_lParameter1 = (long)file.GetLength();\r\n\t\t\tif(m_Send.SendCSendData(Info, MyEnums::DATA_START))\r\n\t\t\t{\r\n\t\t\t\tlong lReadBytes = 0;\r\n\t\t\t\tBOOL bError = FALSE;\r\n\t\t\t\tCMd5 md5;\r\n\t\t\t\tmd5.MD5Init();\r\n\r\n\t\t\t\tBOOL calcMd5 = CGetSetOptions::GetCheckMd5OnFileTransfers();\r\n\r\n\t\t\t\tDWORD d = GetTickCount();\r\n\t\t\t\t\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tlReadBytes = file.Read(pBuffer, CHUNK_WRITE_SIZE);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(m_Send.SendExactSize(pBuffer, lReadBytes, false) == FALSE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLogSendRecieveInfo(\"Error sending SendExactSize in SendFile\");\r\n\t\t\t\t\t\tbError = TRUE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (calcMd5)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmd5.MD5Update((unsigned char *)pBuffer, lReadBytes);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}while(lReadBytes >= CHUNK_WRITE_SIZE);\r\n\t\t\t\t\r\n\t\t\t\tDWORD end = GetTickCount() - d;\r\n\r\n\t\t\t\tif(bError == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tInfo.m_lParameter1 = 0;\r\n\t\t\t\t\tInfo.m_lParameter2 = 0;\r\n\r\n\t\t\t\t\tFILETIME creationTime;\r\n\t\t\t\t\tFILETIME lastAccessTime;\r\n\t\t\t\t\tFILETIME lastWriteTime;\r\n\r\n\t\t\t\t\tif (GetFileTime(file, &creationTime, &lastAccessTime, &lastWriteTime))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tInfo.m_lParameter1 = lastWriteTime.dwLowDateTime;\r\n\t\t\t\t\t\tInfo.m_lParameter2 = lastWriteTime.dwHighDateTime;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tCStringA csMd5 = md5.MD5FinalToString();\r\n\t\t\t\t\tstrncpy(Info.m_md5, csMd5, sizeof(Info.m_md5));\r\n\r\n\t\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Sending data_end for file: %s, md5: %s\"), csFile, CTextConvert::AnsiToUnicode(csMd5)));\r\n\r\n\t\t\t\t\tif(m_Send.SendCSendData(Info, MyEnums::DATA_END))\r\n\t\t\t\t\t\tbRet = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTCHAR szError[100];\r\n\t\t\tex.GetErrorMessage(szError, 100);\r\n\t\t\tLogSendRecieveInfo(StrF(_T(\"Error opening file in Send file, error: %s\"), szError));\r\n\t\t}\r\n\t}\r\n\tcatch(CFileException *e)\r\n\t{\r\n\t\tTCHAR szError[100];\r\n\t\te->GetErrorMessage(szError, 100);\r\n\t\tLogSendRecieveInfo(StrF(_T(\"Exception - Error in Send file, error: %s\"), szError));\r\n\t}\r\n\t\r\n\tdelete []pBuffer;\r\n\tpBuffer = NULL;\r\n\t\r\n\treturn bRet;\r\n}"
        },
        {
          "name": "FileSend.h",
          "type": "blob",
          "size": 0.2900390625,
          "content": "#pragma once\n\n#include \"SendSocket.h\"\n\nclass CFileSend  \n{\npublic:\n\tCFileSend();\n\tvirtual ~CFileSend();\n\n\tBOOL SendClientFiles(SOCKET sock, CClipList *pClipList);\n\nprotected:\n\tCClipFormat* GetCF_HDROP_Data(CClipList *pClipList);\n\tBOOL SendFile(CString csFile);\n\nprotected:\n\tCSendSocket m_Send;\n};\n"
        },
        {
          "name": "FileTransferProgressDlg.cpp",
          "type": "blob",
          "size": 2.6884765625,
          "content": "// FileTransferProgressDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"FileTransferProgressDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CFileTransferProgressDlg dialog\n\n\nCFileTransferProgressDlg::CFileTransferProgressDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CFileTransferProgressDlg::IDD, pParent)\n{\n\tm_bCancelled = false;\n}\n\nvoid CFileTransferProgressDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CFileTransferProgressDlg)\n\tDDX_Control(pDX, IDC_FILE_COPY, m_FileCopy);\n\tDDX_Control(pDX, IDCANCEL, m_m_CancelButton);\n\tDDX_Control(pDX, IDC_PROGRESS_FILE, m_ProgressSingleFile);\n\tDDX_Control(pDX, IDC_PROGRESS_ALL_FILES, m_ProgressAllFiles);\n\tDDX_Control(pDX, IDC_STATIC_1, m_Message);\n\tDDX_Control(pDX, IDC_STATIC_2, m_CopyingFile);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CFileTransferProgressDlg, CDialog)\n\t//{{AFX_MSG_MAP(CFileTransferProgressDlg)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFileTransferProgressDlg message handlers\n\nvoid CFileTransferProgressDlg::PostNcDestroy() \n{\n\tCDialog::PostNcDestroy();\n\n\tdelete this;\n}\n\nBOOL CFileTransferProgressDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\tm_FileCopy.Open(IDR_FILE_COPY);\n\tm_FileCopy.Play(0, -1, -1);\n\t\n\tSetNumFiles(0);\n\n\t::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_SHOWWINDOW);\n\n\treturn TRUE;\n}\n\nvoid CFileTransferProgressDlg::OnCancel() \n{\n\tm_bCancelled = true;\n}\n\nvoid CFileTransferProgressDlg::SetMessage(CString &cs)\n{\n\tm_Message.SetWindowText(cs);\n}\n\nCString CFileTransferProgressDlg::GetMessage()\n{\n\tCString cs;\n\tm_Message.GetWindowText(cs);\n\treturn cs;\n}\n\nvoid CFileTransferProgressDlg::SetFileMessage(CString &cs)\n{\n\tm_CopyingFile.SetWindowText(cs);\n}\n\nvoid CFileTransferProgressDlg::SetNumFiles(int nFiles)\n{\n\tm_ProgressAllFiles.SetRange32(0, nFiles);\n\tm_ProgressAllFiles.SetStep(1);\n\tm_ProgressAllFiles.SetPos(0);\n\n\tm_ProgressSingleFile.SetRange32(0, 100);\n\tm_ProgressSingleFile.SetStep(1);\n\tm_ProgressSingleFile.SetPos(0);\n}\n\nvoid CFileTransferProgressDlg::ResetSingleFileProgress()\n{\n\tm_ProgressSingleFile.SetPos(0);\n}\n\nvoid CFileTransferProgressDlg::StepAllFiles()\n{\n\tm_ProgressAllFiles.StepIt();\n}\n\nvoid CFileTransferProgressDlg::SetSingleFilePos(int nPos)\n{\n\tm_ProgressSingleFile.SetPos(nPos);\n}\n\nvoid CFileTransferProgressDlg::PumpMessages()\n{\n\tint nLoops = 0;\n\tMSG msg;\n    while(::PeekMessage(&msg, m_hWnd, 0, 0, PM_REMOVE)) \n    {\n        TranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\n\t\tnLoops++;\n\t\tif(nLoops > 100)\n\t\t\tbreak;\n    }\n}\n"
        },
        {
          "name": "FileTransferProgressDlg.h",
          "type": "blob",
          "size": 1.77734375,
          "content": "#if !defined(AFX_FILETRANSFERPROGRESSDLG_H__B7CD7263_7AA2_44C1_BF85_31021FB23D85__INCLUDED_)\n#define AFX_FILETRANSFERPROGRESSDLG_H__B7CD7263_7AA2_44C1_BF85_31021FB23D85__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// FileTransferProgressDlg.h : header file\n//\n#include \"Resource.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// CFileTransferProgressDlg dialog\n\nclass CFileTransferProgressDlg : public CDialog\n{\n// Construction\npublic:\n\tCFileTransferProgressDlg(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CFileTransferProgressDlg)\n\tenum { IDD = IDD_DIALOG_REMOTE_FILE };\n\tCAnimateCtrl\tm_FileCopy;\n\tCButton\tm_m_CancelButton;\n\tCProgressCtrl\tm_ProgressSingleFile;\n\tCProgressCtrl\tm_ProgressAllFiles;\n\tCStatic\tm_Message;\n\tCStatic\tm_CopyingFile;\n\t//}}AFX_DATA\n\n\tvoid SetMessage(CString &cs);\n\tCString GetMessage();\n\tvoid SetFileMessage(CString &cs);\n\n\tvoid SetNumFiles(int nFiles);\n\tvoid StepAllFiles();\n\tvoid SetSingleFilePos(int nPos);\n\tvoid ResetSingleFileProgress();\n\n\tbool Cancelled()\t{ return m_bCancelled; }\n\n\tvoid PumpMessages();\n\n\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CFileTransferProgressDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\tvirtual void PostNcDestroy();\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\tbool m_bCancelled;\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CFileTransferProgressDlg)\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnCancel();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_FILETRANSFERPROGRESSDLG_H__B7CD7263_7AA2_44C1_BF85_31021FB23D85__INCLUDED_)\n"
        },
        {
          "name": "FocusHighlight",
          "type": "tree",
          "content": null
        },
        {
          "name": "FormatSQL.cpp",
          "type": "blob",
          "size": 3.212890625,
          "content": "// FormatSQL.cpp: implementation of the CFormatSQL class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"FormatSQL.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCFormatSQL::CFormatSQL()\n{\n\n}\n\nCFormatSQL::~CFormatSQL()\n{\n\n}\n\nvoid CFormatSQL::Parse(CString cs)\n{\n\t//Replace all single ' with a double '\n\tcs.Replace(_T(\"'\"), _T(\"''\"));\n\n\tif(CGetSetOptions::GetSimpleTextSearch() ||\n\t\tCGetSetOptions::GetRegExTextSearch())\n\t{\n\t\teSpecialTypes invalid = eINVALID;\n\t\tAddToSQL(cs, invalid, invalid);\n\t\treturn;\n\t}\n\n\tcs.Replace(_T(\"[\"), _T(\" \"));\n\tcs.Replace(_T(\"]\"), _T(\" \"));\n\n\tcs.Replace(_T(\"*\"), _T(\"%\"));\n\n\tint nLength = cs.GetLength();\n\n\tCString csCurrentWord;\n\tbool bInQuotes = false;\n\teSpecialTypes eNotValue = eINVALID;\n\teSpecialTypes eOrValue = eAND;\n\n\tfor(int i = 0; i < nLength; i++)\n\t{\n\t\tswitch(cs[i])\n\t\t{\n\t\tcase '\"':\n\t\t\tbInQuotes = !bInQuotes;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif(bInQuotes == false)\n\t\t\t{\n\t\t\t\teSpecialTypes sp = ConvetToKey(csCurrentWord);\n\t\t\t\tswitch(sp)\n\t\t\t\t{\n\t\t\t\tcase eNOT:\n\t\t\t\t\teNotValue = sp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase eOR:\n\t\t\t\tcase eAND:\n\t\t\t\t\teOrValue = sp;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAddToSQL(csCurrentWord, eNotValue, eOrValue);\n\t\t\t\t}\n\t\t\t\tcsCurrentWord = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcsCurrentWord += cs[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcsCurrentWord += cs[i];\n\t\t}\n\t}\n\n\tif(csCurrentWord.GetLength() > 0)\n\t\tAddToSQL(csCurrentWord, eNotValue, eOrValue);\n}\n\nCFormatSQL::eSpecialTypes CFormatSQL::ConvetToKey(CString cs)\n{\n\tcs.MakeUpper();\n\n\tif(cs == \"NOT\" || \n\t\tcs == \"!\")\n\t{\n\t\treturn eNOT;\n\t}\n\telse if(cs == \"OR\")\n\t{\n\t\treturn eOR;\n\t}\n\telse if(cs == \"AND\")\n\t{\n\t\treturn eAND;\n\t}\n\n\treturn eINVALID;\n}\n\nCString CFormatSQL::GetKeyWordString(eSpecialTypes eKeyWord)\n{\n\tswitch(eKeyWord)\n\t{\n\tcase eNOT:\n\t\treturn \" NOT \";\n\tcase eAND:\n\t\treturn \" AND \";\n\tcase eOR:\n\t\treturn \" OR \";\n\tcase eINVALID:\n\t\treturn \" \";\n\t}\n\n\treturn \" \";\n}\n\nbool CFormatSQL::AddToSQL(CString cs, eSpecialTypes &eNOTValue, eSpecialTypes &eORValue)\n{\n\tCString csThisSQL;\n\tcs.TrimLeft();\n\tcs.TrimRight();\n\n\tif (CGetSetOptions::GetRegExTextSearch())\n\t{\n\t\tcsThisSQL.Format(_T(\"%s REGEXP \\'%s\\'\"), m_csVariable, cs);\n\t}\n\telse if (CGetSetOptions::GetSimpleTextSearch())\n\t{\n\t\tif (m_csVariable.Find(_T(\"%\")))\n\t\t{\n\t\t\tCString local(cs);\n\t\t\tlocal.Replace(_T(\"%\"), _T(\"\\\\%\"));\n\t\t\t\n\t\t\t//escape the % character, https://www.sqlitetutorial.net/sqlite-like/\n\t\t\tcsThisSQL.Format(_T(\"%s LIKE \\'%%%s%%\\' ESCAPE \\'\\\\\\'\"), m_csVariable, local);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcsThisSQL.Format(_T(\"%s LIKE \\'%%%s%%\\'\"), m_csVariable, cs);\n\t\t}\n\t}\n\telse if (cs.Find(_T(\"%\")) < 0)\n\t{\n\t\tcsThisSQL.Format(_T(\"%s%sLIKE \\'%%%s%%\\'\"), m_csVariable, GetKeyWordString(eNOTValue), cs);\n\t}\n\telse\n\t{\n\t\tCString local(cs);\n\t\tlocal.Replace(_T(\"%\"), _T(\"\\\\%\"));\n\t\tcsThisSQL.Format(_T(\"%s%sLIKE \\'%%%s%%\\' ESCAPE \\'\\\\\\'\"), m_csVariable, GetKeyWordString(eNOTValue), local);\n\t}\n\n\tif(m_csWhere.GetLength() > 0)\n\t{\n\t\tm_csWhere += GetKeyWordString(eORValue) + csThisSQL;\n\t}\n\telse\n\t{\n\t\tm_csWhere = csThisSQL;\n\t}\n\n\teNOTValue = eINVALID;\n\teORValue = eAND;\n\n\treturn true;\n}\n"
        },
        {
          "name": "FormatSQL.h",
          "type": "blob",
          "size": 0.912109375,
          "content": "// FormatSQL.h: interface for the CFormatSQL class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_FORMATSQL_H__3D7AC79C_FDD8_4948_B7CD_601FB513F208__INCLUDED_)\n#define AFX_FORMATSQL_H__3D7AC79C_FDD8_4948_B7CD_601FB513F208__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\nclass CFormatSQL  \n{\npublic:\n\tCFormatSQL();\n\tvirtual ~CFormatSQL();\n\n\tvoid Parse(CString cs);\n\n\tCString GetSQLString()\t\t\t\t{ return _T(\"(\") + m_csWhere + _T(\")\"); }\n\tvoid\tSetVariable(CString cs)\t\t{ m_csVariable = cs;}\n\nprotected:\n\tCString m_csWhere;\n\tCString m_csVariable;\n\tenum eSpecialTypes{eINVALID, eNOT, eAND, eOR};\n\t\n\n\tbool AddToSQL(CString cs, eSpecialTypes &eNOTValue, eSpecialTypes &eORValue);\n\tCFormatSQL::eSpecialTypes ConvetToKey(CString cs);\n\tCString GetKeyWordString(eSpecialTypes eKeyWord);\n};\n\n#endif // !defined(AFX_FORMATSQL_H__3D7AC79C_FDD8_4948_B7CD_601FB513F208__INCLUDED_)\n"
        },
        {
          "name": "FormattedTextDraw.cpp",
          "type": "blob",
          "size": 9.86328125,
          "content": "// Feel free to use this code in your own applications.\r\n// The Author does not guarantee anything about this code.\r\n// Author : Yves Maurer\r\n\r\n// FormattedTextDraw.cpp : Implementation of CFormattedTextDraw\r\n#include \"stdafx.h\"\r\n#include \"FormattedTextDraw.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CallBack functions\r\n\r\nDWORD CALLBACK EditStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)\r\n{\r\n\tPCOOKIE pCookie = (PCOOKIE) dwCookie;\r\n\r\n\tif(pCookie->dwSize - pCookie->dwCount < (DWORD) cb)\r\n\t\t*pcb = pCookie->dwSize - pCookie->dwCount;\r\n\telse\r\n\t\t*pcb = cb;\r\n\r\n\tCopyMemory(pbBuff, pCookie->bstrText, *pcb);\r\n\tpCookie->dwCount += *pcb;\r\n\r\n\treturn 0;\t//\tcallback succeeded - no errors\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CFormattedTextDraw\r\n\r\nHRESULT CFormattedTextDraw::get_RTFText(BSTR *pVal)\r\n{\r\n\t*pVal = SysAllocStringLen(m_RTFText, SysStringLen(m_RTFText));\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::put_RTFText(BSTR newVal)\r\n{\r\n\tHRESULT hr;\r\n\tlong    len;\r\n\tLRESULT lResult = 0;\r\n\tEDITSTREAM editStream;\r\n\r\n\tif (m_RTFText != NULL)\r\n\t\tSysFreeString(m_RTFText);\r\n\tlen = SysStringLen(newVal);\r\n\tm_RTFText = SysAllocStringLen(newVal, len);\r\n\r\n\tif (!m_spTextServices) \r\n\t\treturn S_FALSE;\r\n\r\n\tm_editCookie.bstrText = (BSTR) malloc(len + 1);\r\n\tWideCharToMultiByte(CP_ACP, 0, m_RTFText, len, (char *) m_editCookie.bstrText, len, NULL, NULL);\r\n\tm_editCookie.dwSize = lstrlenA((LPSTR) m_editCookie.bstrText);\r\n\tm_editCookie.dwCount = 0;\r\n\r\n\teditStream.dwCookie = (DWORD_PTR) &m_editCookie;\r\n\teditStream.dwError = 0;\r\n\teditStream.pfnCallback = EditStreamInCallback;\r\n\thr = m_spTextServices->TxSendMessage(EM_STREAMIN, (WPARAM)(SF_RTF | SF_UNICODE), (LPARAM)&editStream, &lResult);\r\n\r\n\tfree(m_editCookie.bstrText);\r\n\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::Draw(void *hdcDraw, RECT *prc)\r\n{\r\n\tif (!m_spTextServices) \r\n\t\treturn S_FALSE;\r\n\r\n\tm_spTextServices->TxDraw(\r\n\t    DVASPECT_CONTENT,  \t\t// Draw Aspect\r\n\t\t0,\t\t\t\t\t\t// Lindex\r\n\t\tNULL,\t\t\t\t\t// Info for drawing optimization\r\n\t\tNULL,\t\t\t\t\t// target device information\r\n\t\t(HDC) hdcDraw,\t\t\t\t// Draw device HDC\r\n\t\tNULL,\t\t\t \t   \t// Target device HDC\r\n\t\t(RECTL *) prc,\t\t\t// Bounding client rectangle\r\n\t\tNULL,\t\t\t\t\t// Clipping rectangle for metafiles\r\n\t\t(RECT *) NULL,\t\t\t// Update rectangle\r\n\t\tNULL, \t   \t\t\t\t// Call back function\r\n\t\tNULL,\t\t\t\t\t// Call back parameter\r\n\t\tTXTVIEW_INACTIVE);\t\t// What view of the object could be TXTVIEW_ACTIVE\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::Create()\r\n{\r\n\treturn CreateTextServicesObject();\r\n}\r\n\r\nHRESULT CFormattedTextDraw::get_NaturalWidth(long Height, long *pVal)\r\n{\r\n\tlong lWidth;\r\n\tSIZEL szExtent;\r\n\tHDC\thdcDraw;\r\n\r\n\tif (!m_spTextServices)\r\n\t\treturn S_FALSE;\r\n\r\n\thdcDraw = GetDC(NULL);\r\n\tszExtent.cy = Height;\r\n\tszExtent.cx = 10000;\r\n\tlWidth = 10000;\r\n\tm_spTextServices->TxGetNaturalSize(DVASPECT_CONTENT, \r\n\t\thdcDraw, \r\n\t\tNULL,\r\n\t\tNULL,\r\n\t\tTXTNS_FITTOCONTENT,\r\n\t\t&szExtent,\r\n\t\t&lWidth,\r\n\t\t&Height);\r\n\r\n\tReleaseDC(NULL, hdcDraw);\r\n\t*pVal = lWidth;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::get_NaturalHeight(long Width, long *pVal)\r\n{\r\n\tlong lHeight;\r\n\tSIZEL szExtent;\r\n\tHDC\thdcDraw;\r\n\r\n\tif (!m_spTextServices)\r\n\t\treturn S_FALSE;\r\n\r\n\thdcDraw = GetDC(NULL);\r\n\tszExtent.cx = Width;\r\n\tszExtent.cy = 10000;\r\n\tlHeight = 10000;\r\n\tm_spTextServices->TxGetNaturalSize(DVASPECT_CONTENT, \r\n\t\thdcDraw, \r\n\t\tNULL,\r\n\t\tNULL,\r\n\t\tTXTNS_FITTOCONTENT,\r\n\t\t&szExtent,\r\n\t\t&Width,\r\n\t\t&lHeight);\r\n\r\n\tReleaseDC(NULL, hdcDraw);\r\n\t*pVal = lHeight;\r\n\treturn S_OK;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// ITextHost functions\r\nHDC CFormattedTextDraw::TxGetDC()\r\n{\r\n\treturn NULL;\r\n}\r\n\r\nINT CFormattedTextDraw::TxReleaseDC(HDC hdc)\r\n{\r\n\treturn 1;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxShowScrollBar(INT fnBar, BOOL fShow)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxEnableScrollBar(INT fuSBFlags, INT fuArrowflags)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxSetScrollPos(INT fnBar, INT nPos, BOOL fRedraw)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CFormattedTextDraw::TxInvalidateRect(LPCRECT prc, BOOL fMode)\r\n{\r\n}\r\n\r\nvoid CFormattedTextDraw::TxViewChange(BOOL fUpdate)\r\n{\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxShowCaret(BOOL fShow)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxSetCaretPos(INT x, INT y)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxSetTimer(UINT idTimer, UINT uTimeout)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CFormattedTextDraw::TxKillTimer(UINT idTimer)\r\n{\r\n}\r\n\r\nvoid CFormattedTextDraw::TxScrollWindowEx(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)\r\n{\r\n}\r\n\r\nvoid CFormattedTextDraw::TxSetCapture(BOOL fCapture)\r\n{\r\n}\r\n\r\nvoid CFormattedTextDraw::TxSetFocus()\r\n{\r\n}\r\n\r\nvoid CFormattedTextDraw::TxSetCursor(HCURSOR hcur, BOOL fText)\r\n{\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxScreenToClient(LPPOINT lppt)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL CFormattedTextDraw::TxClientToScreen(LPPOINT lppt)\r\n{\r\n\treturn FALSE;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxActivate(LONG * plOldState)\r\n{\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxDeactivate(LONG lNewState)\r\n{\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetClientRect(LPRECT prc)\r\n{\r\n\t*prc = m_rcClient;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetViewInset(LPRECT prc)\r\n{\r\n\t*prc = m_rcViewInset;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::TxGetCharFormat(const CHARFORMATW **ppCF)\r\n{\r\n\t*ppCF = m_pCF;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetParaFormat(const PARAFORMAT **ppPF)\r\n{\r\n\t*ppPF = &m_PF;\r\n\treturn S_OK;\r\n}\r\n\r\nCOLORREF CFormattedTextDraw::TxGetSysColor(int nIndex)\r\n{\r\n\treturn GetSysColor(nIndex);\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetBackStyle(TXTBACKSTYLE *pstyle)\r\n{\r\n\t*pstyle = TXTBACK_TRANSPARENT;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetMaxLength(DWORD *plength)\r\n{\r\n\t*plength = m_dwMaxLength;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetScrollBars(DWORD *pdwScrollBar)\r\n{\r\n\t*pdwScrollBar = m_dwScrollbar;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetPasswordChar(TCHAR *pch)\r\n{\r\n\treturn S_FALSE;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetAcceleratorPos(LONG *pcp)\r\n{\r\n\t*pcp = -1;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetExtent(LPSIZEL lpExtent)\r\n{\r\n\treturn E_NOTIMPL;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::OnTxCharFormatChange(const CHARFORMATW * pcf)\r\n{\r\n\tmemcpy(m_pCF, pcf, pcf->cbSize);\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::OnTxParaFormatChange(const PARAFORMAT * ppf)\r\n{\r\n\tmemcpy(&m_PF, ppf, ppf->cbSize);\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits)\r\n{\r\n\t*pdwBits = m_dwPropertyBits;\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxNotify(DWORD iNotify, void *pv)\r\n{\r\n\treturn S_OK;\r\n}\r\n\r\nHIMC CFormattedTextDraw::TxImmGetContext()\r\n{\r\n\treturn NULL;\r\n}\r\n\r\nvoid CFormattedTextDraw::TxImmReleaseContext(HIMC himc)\r\n{\r\n}\r\n\r\nHRESULT\tCFormattedTextDraw::TxGetSelectionBarWidth(LONG *lSelBarWidth)\r\n{\r\n\t*lSelBarWidth = 100;\r\n\treturn S_OK;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// custom functions\r\n\r\nHRESULT CFormattedTextDraw::CharFormatFromHFONT(CHARFORMAT2W* pCF, HFONT hFont)\r\n// Takes an HFONT and fills in a CHARFORMAT2W structure with the corresponding info\r\n{\r\n\r\n\tHWND hWnd;\r\n\tLOGFONT lf;\r\n\tHDC hDC;\r\n\tLONG yPixPerInch;\r\n\r\n\t// Get LOGFONT for default font\r\n\tif (!hFont)\r\n\t\thFont = (HFONT) GetStockObject(SYSTEM_FONT);\r\n\r\n\t// Get LOGFONT for passed hfont\r\n\tif (!GetObject(hFont, sizeof(LOGFONT), &lf))\r\n\t\treturn E_FAIL;\r\n\r\n\t// Set CHARFORMAT structure\r\n\tmemset(pCF, 0, sizeof(CHARFORMAT2W));\r\n\tpCF->cbSize = sizeof(CHARFORMAT2W);\r\n\r\n\thWnd = GetDesktopWindow();\r\n\thDC = GetDC(hWnd);\r\n\tyPixPerInch = GetDeviceCaps(hDC, LOGPIXELSY);\r\n\tpCF->yHeight = -lf.lfHeight * LY_PER_INCH / yPixPerInch;\r\n\tReleaseDC(hWnd, hDC);\r\n\r\n\tpCF->yOffset = 0;\r\n\tpCF->crTextColor = 0;\r\n\r\n\tpCF->dwEffects = CFM_EFFECTS | CFE_AUTOBACKCOLOR;\r\n\tpCF->dwEffects &= ~(CFE_PROTECTED | CFE_LINK | CFE_AUTOCOLOR);\r\n\r\n\tif(lf.lfWeight < FW_BOLD)\r\n\t\tpCF->dwEffects &= ~CFE_BOLD;\r\n\r\n\tif(!lf.lfItalic)\r\n\t\tpCF->dwEffects &= ~CFE_ITALIC;\r\n\r\n\tif(!lf.lfUnderline)\r\n\t\tpCF->dwEffects &= ~CFE_UNDERLINE;\r\n\r\n\tif(!lf.lfStrikeOut)\r\n\t\tpCF->dwEffects &= ~CFE_STRIKEOUT;\r\n\r\n\tpCF->dwMask = CFM_ALL | CFM_BACKCOLOR | CFM_STYLE;\r\n\tpCF->bCharSet = lf.lfCharSet;\r\n\tpCF->bPitchAndFamily = lf.lfPitchAndFamily;\r\n\r\n#ifdef UNICODE\r\n\twcscpy(pCF->szFaceName, lf.lfFaceName);\r\n#else\r\n\tMultiByteToWideChar(CP_ACP, 0, lf.lfFaceName, LF_FACESIZE, pCF->szFaceName, LF_FACESIZE);\r\n#endif\r\n\r\n\treturn S_OK;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::InitDefaultCharFormat()\r\n{\r\n\treturn CharFormatFromHFONT(m_pCF, NULL);\r\n}\r\n\r\nHRESULT CFormattedTextDraw::InitDefaultParaFormat()\r\n{\r\n\tmemset(&m_PF, 0, sizeof(PARAFORMAT2));\r\n\tm_PF.cbSize = sizeof(PARAFORMAT2);\r\n\tm_PF.dwMask = PFM_ALL;\r\n\tm_PF.wAlignment = PFA_LEFT;\r\n\tm_PF.cTabCount = 1;\r\n\tm_PF.rgxTabs[0] = lDefaultTab;\r\n\treturn S_OK;\r\n}\r\n\r\n//https://connect.microsoft.com/VisualStudio/feedback/details/551071/the-6-0a-sdk-is-missing-riched20-lib-for-x64\r\nHRESULT CreateRichEdit(ITextHost *pTextHost, IUnknown **ppUnk)\r\n{\r\n\tHRESULT hr = -1;\r\n\tPCreateTextServices TextServicesProc = NULL;\r\n\tHMODULE hmod = LoadLibrary(_T(\"msftedit.dll\"));\r\n\tif (hmod) \r\n\t{\r\n\t\tTextServicesProc = (PCreateTextServices)GetProcAddress(hmod, \"CreateTextServices\");\r\n\t\tif (TextServicesProc)\r\n\t\t{\r\n\t\t\thr = TextServicesProc(NULL, pTextHost, ppUnk);\r\n\t\t}\r\n\t}\r\n\r\n\treturn hr;\r\n}\r\n\r\nHRESULT CFormattedTextDraw::CreateTextServicesObject()\r\n{\r\n\tHRESULT hr = S_OK;\r\n\t\r\n\tIUnknown *spUnk;\r\n\thr = CreateRichEdit(static_cast<ITextHost*>(this), &spUnk);\r\n\tif (hr == S_OK) \r\n\t{\r\n\t\thr = spUnk->QueryInterface(IID_ITextServicesEx, (void**)&m_spTextServices);\r\n\t\thr = spUnk->QueryInterface(IID_ITextDocument, (void**)&m_spTextDocument);\r\n\t\tspUnk->Release();\r\n\t}\r\n\r\n\treturn hr;\r\n}\r\n\r\n"
        },
        {
          "name": "FormattedTextDraw.h",
          "type": "blob",
          "size": 5.927734375,
          "content": "// Feel free to use this code in your own applications.\n// The Author does not guarantee anything about this code.\n// Author : Yves Maurer\n\n// FormattedTextDraw.h : Declaration of the CFormattedTextDraw\n\n#ifndef __FORMATTEDTEXTDRAW_H_\n#define __FORMATTEDTEXTDRAW_H_\n\n#include \"resource.h\"       // main symbols\n\n// be sure to link this project with riched20.lib\n#include <richedit.h>\n#include <textserv.h>\n\n#ifndef LY_PER_INCH\n#define LY_PER_INCH   1440\n#define HOST_BORDER 0\n#endif\n\ntypedef struct tagCOOKIE\n{\n\tBSTR\tbstrText;\n\tDWORD\tdwSize;\n\tDWORD\tdwCount;\n} COOKIE, *PCOOKIE;\n\n// These definitions might give you problems.  If they do, open your\n// textserv.h and comment the following lines out. They are right at the top\n// EXTERN_C const IID IID_ITextServices;\n// EXTERN_C const IID IID_ITextHost;\n\nconst IID IID_ITextServicesEx = { // 8d33f740-cf58-11ce-a89d-00aa006cadc5\n    0x8d33f740,\n    0xcf58,\n    0x11ce,\n    {0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}\n };\n\n//const IID IID_ITextHosts = { // c5bdd8d0-d26e-11ce-a89e-00aa006cadc5\n//    0xc5bdd8d0,\n//    0xd26e,\n//    0x11ce,\n//    {0xa8, 0x9e, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}\n//  };\n\n/////////////////////////////////////////////////////////////////////////////\n// IFormatttedTextDraw\ninterface IFormattedTextDraw\n{\npublic:\n\tvirtual ~IFormattedTextDraw() {};\n\tvirtual HRESULT get_NaturalHeight(long Width, /*[out, retval]*/ long *pVal) = 0;\n\tvirtual HRESULT get_NaturalWidth(long Height, /*[out, retval]*/ long *pVal) = 0;\n\tvirtual HRESULT Create() = 0;\n\tvirtual HRESULT Draw(void *hdcDraw, RECT *prc) = 0;\n\tvirtual HRESULT get_RTFText(/*[out, retval]*/ BSTR *pVal) = 0;\n\tvirtual HRESULT put_RTFText(/*[in]*/ BSTR newVal) = 0;\n\n// COM-like functions\n    virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\n    virtual ULONG STDMETHODCALLTYPE Release(void) = 0;\n};\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CFormattedTextDraw\nclass CFormattedTextDraw : \n\tpublic ITextHost,\n\tpublic IFormattedTextDraw\n{\npublic:\n\tCFormattedTextDraw()\n\t{\n\t\tHDC hdcScreen;\n\n\t\tm_RTFText = NULL;\n\n\t\thdcScreen = GetDC(NULL);\n\t\tnPixelsPerInchX = GetDeviceCaps(hdcScreen, LOGPIXELSX);\n\t\tnPixelsPerInchY = GetDeviceCaps(hdcScreen, LOGPIXELSY);\n\t\tReleaseDC(NULL, hdcScreen);\n\n\t\tSetRectEmpty(&m_rcClient);\n\t\tSetRectEmpty(&m_rcViewInset);\n\n\t\tm_pCF = (CHARFORMAT2W*) malloc(sizeof(CHARFORMAT2W));\n\n\t\tInitDefaultCharFormat();\n\t\tInitDefaultParaFormat();\n\t\tm_spTextServices = NULL;\n\t\tm_spTextDocument = NULL;\n\n\t\tm_dwPropertyBits = TXTBIT_RICHTEXT | TXTBIT_MULTILINE | TXTBIT_WORDWRAP | TXTBIT_USECURRENTBKG;\n\t\tm_dwScrollbar = 0;\n\t\tm_dwMaxLength = INFINITE;\n\t}\n\n\t~CFormattedTextDraw()\n\t{\n\t\tif (m_RTFText != NULL)\n\t\t\tSysFreeString(m_RTFText);\n\n\t\tfree(m_pCF);\n\t\tif (m_spTextServices != NULL)\n\t\t\tm_spTextServices->Release();\n\t\tif (m_spTextDocument != NULL)\n\t\t\tm_spTextDocument->Release();\n\t}\n\n// Minimal COM functionality\n    HRESULT STDMETHODCALLTYPE QueryInterface( \n        /* [in] */ REFIID riid,\n        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)\n\t{\n\t\t*ppvObject = NULL;\n\t\treturn S_FALSE;\n\t}\n    \n    ULONG STDMETHODCALLTYPE AddRef(void)\n\t{\n\t\treturn 0;\n\t}\n    \n    ULONG STDMETHODCALLTYPE Release(void)\n\t{\n\t\treturn 0;\n\t}\n\n// IFormattedTextDraw\npublic:\n\tHRESULT get_NaturalHeight(long Width, /*[out, retval]*/ long *pVal);\n\tHRESULT get_NaturalWidth(long Height, /*[out, retval]*/ long *pVal);\n\tHRESULT Create();\n\tHRESULT Draw(void *hdcDraw, RECT *prc);\n\tHRESULT get_RTFText(/*[out, retval]*/ BSTR *pVal);\n\tHRESULT put_RTFText(/*[in]*/ BSTR newVal);\n\n// ITextHost\n\tHDC TxGetDC();\n\tINT TxReleaseDC(HDC hdc);\n\tBOOL TxShowScrollBar(INT fnBar, BOOL fShow);\n\tBOOL TxEnableScrollBar(INT fuSBFlags, INT fuArrowflags);\n\tBOOL TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw);\n\tBOOL TxSetScrollPos(INT fnBar, INT nPos, BOOL fRedraw);\n\tvoid TxInvalidateRect(LPCRECT prc, BOOL fMode);\n\tvoid TxViewChange(BOOL fUpdate);\n\tBOOL TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight);\n\tBOOL TxShowCaret(BOOL fShow);\n\tBOOL TxSetCaretPos(INT x, INT y);\n\tBOOL TxSetTimer(UINT idTimer, UINT uTimeout);\n\tvoid TxKillTimer(UINT idTimer);\n\tvoid TxScrollWindowEx(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll);\n\tvoid TxSetCapture(BOOL fCapture);\n\tvoid TxSetFocus();\n\tvoid TxSetCursor(HCURSOR hcur, BOOL fText);\n\tBOOL TxScreenToClient(LPPOINT lppt);\n\tBOOL TxClientToScreen(LPPOINT lppt);\n\tHRESULT\tTxActivate(LONG * plOldState);\n\tHRESULT\tTxDeactivate(LONG lNewState);\n\tHRESULT\tTxGetClientRect(LPRECT prc);\n\tHRESULT\tTxGetViewInset(LPRECT prc);\n\tHRESULT TxGetCharFormat(const CHARFORMATW **ppCF);\n\tHRESULT\tTxGetParaFormat(const PARAFORMAT **ppPF);\n\tCOLORREF TxGetSysColor(int nIndex);\n\tHRESULT\tTxGetBackStyle(TXTBACKSTYLE *pstyle);\n\tHRESULT\tTxGetMaxLength(DWORD *plength);\n\tHRESULT\tTxGetScrollBars(DWORD *pdwScrollBar);\n\tHRESULT\tTxGetPasswordChar(TCHAR *pch);\n\tHRESULT\tTxGetAcceleratorPos(LONG *pcp);\n\tHRESULT\tTxGetExtent(LPSIZEL lpExtent);\n\tHRESULT OnTxCharFormatChange(const CHARFORMATW * pcf);\n\tHRESULT\tOnTxParaFormatChange(const PARAFORMAT * ppf);\n\tHRESULT\tTxGetPropertyBits(DWORD dwMask, DWORD *pdwBits);\n\tHRESULT\tTxNotify(DWORD iNotify, void *pv);\n\tHIMC TxImmGetContext();\n\tvoid TxImmReleaseContext(HIMC himc);\n\tHRESULT\tTxGetSelectionBarWidth(LONG *lSelBarWidth);\n\n// Custom functions\n\tHRESULT CharFormatFromHFONT(CHARFORMAT2W* pCF, HFONT hFont);\n\tHRESULT InitDefaultCharFormat();\n\tHRESULT InitDefaultParaFormat();\n\tHRESULT CreateTextServicesObject();\n\n// Variables\n\tRECT\t\t\tm_rcClient;\t\t\t// Client Rect\n\tRECT\t\t\tm_rcViewInset;\t\t// view rect inset\n\tSIZEL\t\t\tm_sizelExtent;\t\t// Extent array\n\n\tint\t\t\t\tnPixelsPerInchX;    // Pixels per logical inch along width\n\tint\t\t\t\tnPixelsPerInchY;    // Pixels per logical inch along height\n\n\tCHARFORMAT2W\t*m_pCF;\n\tPARAFORMAT2\t\tm_PF;\n\tDWORD\t\t\tm_dwScrollbar;\t\t// Scroll bar style\n\tDWORD\t\t\tm_dwPropertyBits;\t// Property bits\n\tDWORD\t\t\tm_dwMaxLength;\n\tCOOKIE\t\t\tm_editCookie;\n\n\tITextServices\t*m_spTextServices;\n\tITextDocument\t*m_spTextDocument;\n\tBSTR\t\t\tm_RTFText;\n};\n\n#endif //__FORMATTEDTEXTDRAW_H_\n"
        },
        {
          "name": "FriendDetails.cpp",
          "type": "blob",
          "size": 1.435546875,
          "content": "// FriendDetails.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"FriendDetails.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CFriendDetails dialog\n\n\nCFriendDetails::CFriendDetails(CWnd* pParent /*=NULL*/)\n\t: CDialog(CFriendDetails::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CFriendDetails)\n\tm_checkSendAll = FALSE;\n\tm_csDescription = _T(\"\");\n\tm_csIP = _T(\"\");\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CFriendDetails::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CFriendDetails)\n\tDDX_Check(pDX, IDC_CHECK_SEND_ALL, m_checkSendAll);\n\tDDX_Text(pDX, IDC_EDIT_DESCRIPTION, m_csDescription);\n\tDDX_Text(pDX, IDC_EDIT_IP, m_csIP);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CFriendDetails, CDialog)\n\t//{{AFX_MSG_MAP(CFriendDetails)\n\t\t// NOTE: the ClassWizard will add message map macros here\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CFriendDetails message handlers\n\nBOOL CFriendDetails::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tUpdateData(FALSE);\n\n\ttheApp.m_Language.UpdateOptionFriendsDetail(this);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CFriendDetails::OnOK() \n{\n\tUpdateData();\n\t\n\tCDialog::OnOK();\n}\n"
        },
        {
          "name": "FriendDetails.h",
          "type": "blob",
          "size": 1.2255859375,
          "content": "#if !defined(AFX_FRIENDDETAILS_H__EE25569D_E112_4F70_BDB3_6AD778477A73__INCLUDED_)\n#define AFX_FRIENDDETAILS_H__EE25569D_E112_4F70_BDB3_6AD778477A73__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// FriendDetails.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CFriendDetails dialog\n\nclass CFriendDetails : public CDialog\n{\n// Construction\npublic:\n\tCFriendDetails(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CFriendDetails)\n\tenum { IDD = IDD_FRIEND_DETAILS };\n\tBOOL\tm_checkSendAll;\n\tCString\tm_csDescription;\n\tCString\tm_csIP;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CFriendDetails)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CFriendDetails)\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnOK();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_FRIENDDETAILS_H__EE25569D_E112_4F70_BDB3_6AD778477A73__INCLUDED_)\n"
        },
        {
          "name": "FriendPromptDlg.cpp",
          "type": "blob",
          "size": 2.2783203125,
          "content": "// FriendPromptDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"FriendPromptDlg.h\"\n#include \"afxdialogex.h\"\n#include \"Shared\\Tokenizer.h\"\n\n\n// CFriendPromptDlg dialog\n\nIMPLEMENT_DYNAMIC(CFriendPromptDlg, CDialogEx)\n\nCFriendPromptDlg::CFriendPromptDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogEx(IDD_DIALOG_FREIND_PROMPT, pParent)\n{\n\tm_save = false;\n\tm_clearList = false;\n}\n\nCFriendPromptDlg::~CFriendPromptDlg()\n{\n}\n\nvoid CFriendPromptDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_EDIT_NAME, m_textBox);\n\tDDX_Control(pDX, IDC_EDIT_DESC, m_description);\n}\n\n\nBEGIN_MESSAGE_MAP(CFriendPromptDlg, CDialogEx)\n\tON_BN_CLICKED(IDOK, &CFriendPromptDlg::OnBnClickedOk)\n\tON_WM_SIZE()\n\tON_WM_CTLCOLOR()\n\tON_BN_CLICKED(IDCANCEL, &CFriendPromptDlg::OnBnClickedCancel)\n\tON_BN_CLICKED(IDC_BUTTON_CLEAR, &CFriendPromptDlg::OnBnClickedButtonClear)\nEND_MESSAGE_MAP()\n\nvoid CFriendPromptDlg::OnBnClickedOk()\n{\n\tm_textBox.GetWindowTextW(m_name);\n\tm_description.GetWindowTextW(m_desc);\n\n\tif (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_SAVE) == BST_CHECKED)\n\t{\n\t\tm_save = true;\n\t}\n\n\tCDialogEx::OnOK();\n}\n\nBOOL CFriendPromptDlg::OnInitDialog()\n{\n\tCDialogEx::OnInitDialog();\n\n\t::SendMessage(this->m_hWnd, WM_SETICON, 0, NULL);\n\n\tm_brush.CreateSolidBrush(RGB(255, 255, 255)); // color white brush \n\n\t//remove the default icon in top left of window\n\tint extendedStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE);\n\tSetWindowLong(m_hWnd, GWL_EXSTYLE, extendedStyle | WS_EX_DLGMODALFRAME);\n\tSetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE |\tSWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);\n\n\t::CheckDlgButton(m_hWnd, IDC_CHECK_SAVE, BST_CHECKED);\n\n\tm_textBox.SetFocus();\n\t\n\treturn FALSE;\n}\n\nvoid CFriendPromptDlg::OnSize(UINT nType, int cx, int cy)\n{\n\tCDialogEx::OnSize(nType, cx, cy);\n}\n\nHBRUSH CFriendPromptDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\n{\n\tHBRUSH hbr = CDialogEx::OnCtlColor(pDC, pWnd, nCtlColor);\n\n\t// TODO:  Change any attributes of the DC here\n\n\t// TODO:  Return a different brush if the default is not desired\n\treturn hbr;\n\n\t//return m_brush;\n}\n\n\nvoid CFriendPromptDlg::OnBnClickedCancel()\n{\n\t// TODO: Add your control notification handler code here\n\tCDialogEx::OnCancel();\n}\n\n\nvoid CFriendPromptDlg::OnBnClickedButtonClear()\n{\n\tm_clearList = true;\n\tCDialogEx::OnOK();\n}\n"
        },
        {
          "name": "FriendPromptDlg.h",
          "type": "blob",
          "size": 0.9921875,
          "content": "#pragma once\n#include \"afxwin.h\"\n#include \"DialogResizer.h\"\n\n// CFriendPromptDlg dialog\n\nclass CFriendPromptDlg : public CDialogEx\n{\n\tDECLARE_DYNAMIC(CFriendPromptDlg)\n\npublic:\n\tCFriendPromptDlg(CWnd* pParent = NULL);   // standard constructor\n\tvirtual ~CFriendPromptDlg();\n\n// Dialog Data\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_DIALOG_FREIND_PROMPT };\n#endif\n\tCString GetName() { return m_name; }\n\tCString GetDesc() { return m_desc; }\n\tbool GetSave() { return m_save; }\n\tbool GetClearList() { return m_clearList; }\n\nprotected:\n\n\tCString m_name;\n\tCString m_desc;\n\tCBrush m_brush;\n\tbool m_save;\n\tbool m_clearList;\n\n\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tafx_msg void OnBnClickedOk();\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\n\tCEdit m_textBox;\n\tafx_msg void OnBnClickedCancel();\n\tCEdit m_description;\n\tafx_msg void OnBnClickedButtonClear();\n};\n"
        },
        {
          "name": "GdiImageDrawer.cpp",
          "type": "blob",
          "size": 3.404296875,
          "content": "#include \"stdafx.h\"\n#include \"GdiImageDrawer.h\"\n#include \"MemDC.h\"\n#include \"CP_Main.h\"\n\nCGdiImageDrawer::CGdiImageDrawer()\n{\n\tm_pStdImage = NULL;\n}\n\nCGdiImageDrawer::~CGdiImageDrawer()\n{\n\tdelete m_pStdImage;\n}\n\nvoid CGdiImageDrawer::Reset()\n{\n\tdelete m_pStdImage;\n\tm_pStdImage = NULL;\n\n}\n\nBOOL CGdiImageDrawer::LoadStdImage(UINT id, LPCTSTR pType)\n{\n\tm_pStdImage = new CGdiPlusBitmapResource;\n\treturn m_pStdImage->Load(id, pType);\n}\n\nBOOL CGdiImageDrawer::LoadRaw(unsigned char* bitmapData, int imageSize)\n{\n\tm_pStdImage = new CGdiPlusBitmapResource;\n\treturn m_pStdImage->LoadRaw(bitmapData, imageSize);\n}\n\nBOOL CGdiImageDrawer::LoadStdImageDPI(int dpi, UINT id96, UINT id120, UINT id144, UINT id168, UINT id192, LPCTSTR pType, UINT id225, UINT id250, UINT id275, UINT id300, UINT id325, UINT id350)\n{\n\tBOOL ret = FALSE;\n\n\tif (dpi >= 336 && id350 != 0)\n\t{\n\t\tret = LoadStdImage(id350, pType);\n\t}\n\telse if (dpi >= 312 && id325 != 0)\n\t{\n\t\tret = LoadStdImage(id325, pType);\n\t}\n\telse if (dpi >= 288 && id300 != 0)\n\t{\n\t\tret = LoadStdImage(id300, pType);\n\t}\n\telse if (dpi >= 264 && id275 != 0)\n\t{\n\t\tret = LoadStdImage(id275, pType);\n\t}\n\telse if (dpi >= 240 && id250 != 0)\n\t{\n\t\tret = LoadStdImage(id250, pType);\n\t}\n\telse if (dpi >= 216 && id225 != 0)\n\t{\n\t\tret = LoadStdImage(id225, pType);\n\t}\n\telse if (dpi >= 192)\n\t{\n\t\tret = LoadStdImage(id192, pType);\n\t}\n\telse if (dpi >= 168)\n\t{\n\t\tret = LoadStdImage(id168, pType);\n\t}\n\telse if (dpi >= 144)\n\t{\n\t\tret = LoadStdImage(id144, pType);\n\t}\n\telse if (dpi >= 120)\n\t{\n\t\tret = LoadStdImage(id120, pType);\n\t}\n\telse\n\t{\n\t\tret = LoadStdImage(id96, pType);\n\t}\n\n\treturn ret;\n}\n\nvoid CGdiImageDrawer::Draw(CDC* pScreenDC, CDPI &dpi, CWnd *pWnd, CRect rc, bool mouseHover, bool mouseDown)\n{\n\tint width = m_pStdImage->m_pBitmap->GetWidth();\n\tint height = m_pStdImage->m_pBitmap->GetHeight();\n\n\tint x = rc.left + (rc.Width() / 2) - (width / 2);\n\tint y = rc.top + (rc.Height() / 2) - (height / 2);\n\n\tDraw(pScreenDC, dpi, pWnd, x, y, mouseHover, mouseDown);\n}\n\nvoid CGdiImageDrawer::Draw(CDC* pScreenDC, CDPI &dpi, CWnd *pWnd, int posX, int posY, bool mouseHover, bool mouseDown, int forceWidth, int forceHeight)\n{\n\tint width = m_pStdImage->m_pBitmap->GetWidth();\n\tif (forceWidth != INT_MAX)\n\t\twidth = forceWidth;\n\tint height = m_pStdImage->m_pBitmap->GetHeight();\n\tif (forceHeight != INT_MAX)\n\t\theight = forceHeight;\n\n\tCRect rectWithBorder(posX, posY, posX + width, posY + height);\n\t\n\tCDC dcBk;\n\tCBitmap bmp;\n\tCClientDC clDC(pWnd);\n\t\t\n\t//Copy the background over the entire area\n\tdcBk.CreateCompatibleDC(&clDC);\n\tbmp.CreateCompatibleBitmap(&clDC, 1, 1);\n\tdcBk.SelectObject(&bmp);\n\tdcBk.BitBlt(0, 0, 1, 1, &clDC, rectWithBorder.left-1, rectWithBorder.top, SRCCOPY);\n\t\n\tbmp.DeleteObject();\t\t\n\n\t//Draw the png file\n\tif (mouseDown)\n\t{\n\t\tint one = dpi.Scale(1);\n\t\tposX += one;\n\t\tposY += one;\n\t}\n\n\t//ImageAttributes ia;\n\t//\n\n\t//ColorMap blackToRed;\n\t//blackToRed.oldColor = Color(255, 110, 114, 122);  // black\n\t//blackToRed.newColor = Color(255, 255, 0, 0);// red\n\t//ia.SetRemapTable(1, &blackToRed);\n\n\tGdiplus::Graphics graphics(pScreenDC->m_hDC);\n\tgraphics.DrawImage(*m_pStdImage, posX, posY, width, height);\t\n\n\t//RectF grect; grect.X = posX, grect.Y = posY; grect.Width = width; grect.Height = height;\n\t//graphics.DrawImage(*m_pStdImage, grect, 0, 0, width, height, UnitPixel, &ia);\n\n\n\t//If we are hoving over then draw the border\n\t//if(mouseHover && mouseDown == false)\n\t//{\n\t//\tpScreenDC->Draw3dRect(rectWithBorder, RGB(255, 255, 255), RGB(255, 255, 255));\n\t//}\n}"
        },
        {
          "name": "GdiImageDrawer.h",
          "type": "blob",
          "size": 0.9814453125,
          "content": "#pragma once\n\n#include \"CGdiPlusBitmap.h\"\n#include \"DPI.h\"\n\nclass CGdiImageDrawer\n{\npublic:\n\tCGdiImageDrawer();\n\t~CGdiImageDrawer();\n\n\tBOOL LoadStdImage(UINT id, LPCTSTR pType);\n\tBOOL LoadStdImageDPI(int dpi, UINT id96, UINT id120, UINT id144, UINT id168, UINT id192, LPCTSTR pType, UINT id225 = 0, UINT id250 = 0, UINT id275 = 0, UINT id300 = 0, UINT id325 = 0, UINT id350 = 0);\n\tvoid Draw(CDC* pScreenDC, CDPI &dpi, CWnd *pWnd, int posX, int posY, bool mouseHover, bool mouseDown, int forceWidth = INT_MAX, int forceHeight = INT_MAX);\n\tvoid Draw(CDC* pScreenDC, CDPI &dpi, CWnd *pWnd, CRect rc, bool mouseHover, bool mouseDown);\n\tBOOL LoadRaw(unsigned char* bitmapData, int imageSize);\n\n\tUINT ImageWidth() { return m_pStdImage->m_pBitmap->GetWidth(); }\n\tUINT ImageHeight() { return m_pStdImage->m_pBitmap->GetHeight(); }\n\n\tvoid Reset();\n\nprotected:\n\tCGdiPlusBitmapResource* m_pStdImage;\n\t//CDC*\tm_pCurBtn;\t\t// current pointer to one of the above\n\t//CDC\t\tm_dcStd;\t\t// standard button\n\n\t//CDC m_dcBk;\n};\n\n"
        },
        {
          "name": "GdipButton.cpp",
          "type": "blob",
          "size": 18.8974609375,
          "content": "//\n// GdipButton.cpp : Version 1.0 - see article at CodeProject.com\n//\n// Author:  Darren Sessions\n//          \n//\n// Description:\n//     GdipButton is a CButton derived control that uses GDI+ \n//     to support alternate image formats\n//\n// History\n//     Version 1.0 - 2008 June 10\n//     - Initial public release\n//\n// License:\n//     This software is released under the Code Project Open License (CPOL),\n//     which may be found here:  http://www.codeproject.com/info/eula.aspx\n//     You are free to use this software in any way you like, except that you \n//     may not sell this source code.\n//\n//     This software is provided \"as is\" with no expressed or implied warranty.\n//     I accept no liability for any damage or loss of business that this \n//     software may cause.\n//\n///////////////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"GdipButton.h\"\n\n#include \"CGdiPlusBitmap.h\"\n#include \"MemDC.h\"\n#include \"CP_Main.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CGdipButton\n\nCGdipButton::CGdipButton()\n{\n\tm_pStdImage = NULL;\n\tm_pAltImage = NULL;\n\n\tm_bHaveBitmaps = FALSE;\n\tm_bHaveAltImage = FALSE;\n\n\tm_pCurBtn = NULL;\n\n\tm_bIsDisabled = FALSE;\n\tm_bIsToggle = FALSE;\n\n\tm_bIsHovering = FALSE;\n\tm_bIsTracking = FALSE;\n\n\tm_nCurType = STD_TYPE;\n\n\tm_pToolTip = NULL;\n\n}\n\nCGdipButton::~CGdipButton()\n{\n\tif(m_pStdImage) delete m_pStdImage;\n\tif(m_pAltImage) delete m_pAltImage;\n\tif(m_pToolTip)\tdelete m_pToolTip;\n}\n\n\nBEGIN_MESSAGE_MAP(CGdipButton, CButton)\n\t//{{AFX_MSG_MAP(CGdipButton)\n\tON_WM_DRAWITEM()\n\tON_WM_ERASEBKGND()\n\tON_WM_CTLCOLOR_REFLECT()\n\tON_WM_MOUSEMOVE()\n\tON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)\n\tON_MESSAGE(WM_MOUSEHOVER, OnMouseHover)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\nBOOL CGdipButton::LoadStdImageDPI(int dpi, UINT id96, UINT id120, UINT id144, UINT id168, UINT id192, LPCTSTR pType, UINT id225, UINT id250, UINT id275, UINT id300, UINT id325, UINT id350)\n{\n\tBOOL ret = FALSE;\n\n\tif (dpi >= 336 && id350 != 0)\n\t{\n\t\tret = LoadStdImage(id350, pType);\n\t}\n\telse if (dpi >= 312 && id325 != 0)\n\t{\n\t\tret = LoadStdImage(id325, pType);\n\t}\n\telse if (dpi >= 288 && id300 != 0)\n\t{\n\t\tret = LoadStdImage(id300, pType);\n\t}\n\telse if (dpi >= 264 && id275 != 0)\n\t{\n\t\tret = LoadStdImage(id275, pType);\n\t}\n\telse if (dpi >= 240 && id250 != 0)\n\t{\n\t\tret = LoadStdImage(id250, pType);\n\t}\n\telse if (dpi >= 216 && id225 != 0)\n\t{\n\t\tret = LoadStdImage(id225, pType);\n\t}\n\telse if (dpi >= 192)\n\t{\n\t\tret = LoadStdImage(id192, pType);\n\t}\n\telse if (dpi >= 168)\n\t{\n\t\tret = LoadStdImage(id168, pType);\n\t}\n\telse if (dpi >= 144)\n\t{\n\t\tret = LoadStdImage(id144, pType);\n\t}\n\telse if (dpi >= 120)\n\t{\n\t\tret = LoadStdImage(id120, pType);\n\t}\n\telse\n\t{\n\t\tret = LoadStdImage(id96, pType);\n\t}\n\n\treturn ret;\n}\n\n//=============================================================================\n//\n// LoadStdImage()\n//\n// Purpose:     The LoadStdImage() Loads the image for the button.  This \n//\t\t\t\tfunction must be called at a minimum or the button wont do \n//\t\t\t\tanything.\n//\n// Parameters:  \n//\t\t[IN]\tid\n//\t\t\t\tresource id, one of the resources already imported with the \n//\t\t\t\tresource editor, usually begins with IDR_  \n//\n//\t\t[IN]\tpType\n//\t\t\t\tpointer to string describing the resource type\n//\t\t\t\t\n// Returns:     BOOL\n//\t\t\t\tNon zero if successful, otherwise zero\n//\n//=============================================================================\nBOOL CGdipButton::LoadStdImage(UINT id, LPCTSTR pType)\n{\n\tm_pStdImage = new CGdiPlusBitmapResource;\n\treturn m_pStdImage->Load(id, pType);\n}\n\nvoid CGdipButton::Reset()\n{\n\tdelete m_pStdImage;\n\tm_pStdImage = NULL;\n\tdelete m_pAltImage;\n\tm_pAltImage = NULL;\n\tdelete m_pToolTip;\n\tm_pToolTip = NULL;\n\n\tm_bHaveBitmaps = FALSE;\n\tm_bHaveAltImage = FALSE;\n\n\tm_dcStd.DeleteDC();\n\tm_dcStdP.DeleteDC();\n\tm_dcStdH.DeleteDC();\n\tm_dcBk.DeleteDC();\n}\n\nvoid CGdipButton::Test(CString c)\n{\n\tm_pStdImage = new CGdiPlusBitmapResource;\n\tm_pStdImage->Loads(c);\n}\n\n//=============================================================================\n//\n// LoadAltImage()\n//\n// Purpose:     The LoadAltImage() Loads the altername image for the button.  \n//\t\t\t\tThis function call is optional\n// Parameters:  \n//\t\t[IN]\tid\n//\t\t\t\tresource id, one of the resources already imported with the \n//\t\t\t\tresource editor, usually begins with IDR_  \n//\n//\t\t[IN]\tpType\n//\t\t\t\tpointer to string describing the resource type\n//\t\t\t\t\n// Returns:     BOOL\n//\t\t\t\tNon zero if successful, otherwise zero\n//\n//=============================================================================\nBOOL CGdipButton::LoadAltImage(UINT id, LPCTSTR pType)\n{\n\tm_bHaveAltImage = TRUE;\n\tm_pAltImage = new CGdiPlusBitmapResource;\n\treturn (m_pAltImage->Load(id, pType));\n}\n\n\n//=============================================================================\n//\n//\tThe framework calls this member function when a child control is about to \n//\tbe drawn.  All the bitmaps are created here on the first call. Every thing\n//\tis done with a memory DC except the background, which get's it's information \n//\tfrom the parent. The background is needed for transparent portions of PNG \n//\timages. An always on top app (such as Task Manager) that is in the way can \n//\tcause it to get an incorrect background.  To avoid this, the parent should \n//\tcall the SetBkGnd function with a memory DC when it creates the background.\n//\t\t\t\t\n//=============================================================================\nHBRUSH CGdipButton::CtlColor(CDC* pScreenDC, UINT nCtlColor) \n{\n\tif(!m_bHaveBitmaps)\n\t{\n\t\tif(!m_pStdImage)\n\t\t{\n\t\t\treturn NULL; // Load the standard image with LoadStdImage()\n\t\t}\n\n\t\tCBitmap bmp, *pOldBitmap;\n\n\t\tCRect rect;\n\t\tGetClientRect(rect);\n\n\t\t// do everything with mem dc\n\t\tCMemDCEx pDC(pScreenDC, rect);\n\n\t\tGdiplus::Graphics graphics(pDC->m_hDC);\n\n\t\t// background\n\t\tif (m_dcBk.m_hDC == NULL)\n\t\t{\n\n\t\t\tCRect rect1;\n\t\t\tCClientDC clDC(GetParent());\n\t\t\tGetWindowRect(rect1);\n\t\t\tGetParent()->ScreenToClient(rect1);\n\n\t\t\tm_dcBk.CreateCompatibleDC(&clDC);\n\t\t\tbmp.CreateCompatibleBitmap(&clDC, rect.Width(), rect.Height());\n\t\t\tpOldBitmap = m_dcBk.SelectObject(&bmp);\n\t\t\tm_dcBk.BitBlt(0, 0, rect.Width(), rect.Height(), &clDC, rect1.left, rect1.top, SRCCOPY);\n\t\t\tbmp.DeleteObject();\n\t\t}\n\n\t\t// standard image\n\t\tif (m_dcStd.m_hDC == NULL)\n\t\t{\n\t\t\tPaintBk(pDC);\n\n\t\t\t/*graphics.DrawImage(*m_pStdImage, 0, 0);\n\t\t\n\t\t\tm_dcStd.CreateCompatibleDC(pDC);\n\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\tpOldBitmap = m_dcStd.SelectObject(&bmp);\n\t\t\tm_dcStd.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\tbmp.DeleteObject();*/\n\n\t\t\tfloat width = (float)m_pStdImage->m_pBitmap->GetWidth();\n\t\t\tfloat height = (float)m_pStdImage->m_pBitmap->GetHeight();\n\n\t\t\tRectF grect; grect.X = 0, grect.Y = 0; grect.Width = width; grect.Height = height;\n\n\t\t\tgraphics.DrawImage(*m_pStdImage, grect, 0, 0, width, height, UnitPixel);\n\n\t\t\tm_dcStd.CreateCompatibleDC(pDC);\n\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\tpOldBitmap = m_dcStd.SelectObject(&bmp);\n\t\t\tm_dcStd.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\tbmp.DeleteObject();\n\n\t\t\t// standard image pressed\n\t\t\tif (m_dcStdP.m_hDC == NULL)\n\t\t\t{\n\t\t\t\tPaintBk(pDC);\n\n\t\t\t\t//graphics.DrawImage(*m_pStdImage, 1, 1);\n\n\t\t\t\t//m_dcStdP.CreateCompatibleDC(pDC);\n\t\t\t\t//bmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\t//pOldBitmap = m_dcStdP.SelectObject(&bmp);\n\t\t\t\t//m_dcStdP.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\t//bmp.DeleteObject();\n\n\t\t\t\tfloat width = (float)m_pStdImage->m_pBitmap->GetWidth();\n\t\t\t\tfloat height = (float)m_pStdImage->m_pBitmap->GetHeight();\n\n\t\t\t\tRectF grect; grect.X = 0, grect.Y = 0; grect.Width = width; grect.Height = height;\n\n\t\t\t\tgraphics.DrawImage(*m_pStdImage, grect, -1, -1, width, height, UnitPixel);\n\n\t\t\t\tm_dcStdP.CreateCompatibleDC(pDC);\n\t\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\tpOldBitmap = m_dcStdP.SelectObject(&bmp);\n\t\t\t\tm_dcStdP.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\tbmp.DeleteObject();\n\t\t\t}\n\n\t\t\t// standard image hot\n\t\t\tif(m_dcStdH.m_hDC == NULL)\n\t\t\t{\n\t\t\t\tPaintBk(pDC);\n\n\t\t\t\tColorMatrix HotMat = {\t1.05f, 0.00f, 0.00f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 1.05f, 0.00f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 1.05f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 0.00f, 1.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.05f, 0.05f, 0.05f, 0.00f, 1.00f\t};\n\n\t\t\t\tImageAttributes ia;\n\t\t\t\tia.SetColorMatrix(&HotMat);\n\n\t\t\t\tfloat width = (float)m_pStdImage->m_pBitmap->GetWidth();\n\t\t\t\tfloat height = (float)m_pStdImage->m_pBitmap->GetHeight();\n\n\t\t\t\tRectF grect; grect.X=0, grect.Y=0; grect.Width = width; grect.Height = height;\n\n\t\t\t\tgraphics.DrawImage(*m_pStdImage, grect, 0, 0, width, height, UnitPixel, &ia);\n\n\t\t\t\tm_dcStdH.CreateCompatibleDC(pDC);\n\t\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\tpOldBitmap = m_dcStdH.SelectObject(&bmp);\n\t\t\t\tm_dcStdH.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\tbmp.DeleteObject();\n\t\t\t}\n\n\t\t\t// grayscale image\n\t\t\tif(m_dcGS.m_hDC == NULL)\n\t\t\t{\n\t\t\t\tPaintBk(pDC);\n\n\t\t\t\tColorMatrix GrayMat = {\t0.30f, 0.30f, 0.30f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.59f, 0.59f, 0.59f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.11f, 0.11f, 0.11f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 0.00f, 1.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 0.00f, 0.00f, 1.00f\t};\n\n\t\t\t\tImageAttributes ia;\n\t\t\t\tia.SetColorMatrix(&GrayMat);\n\n\t\t\t\tfloat width = (float)m_pStdImage->m_pBitmap->GetWidth();\n\t\t\t\tfloat height = (float)m_pStdImage->m_pBitmap->GetHeight();\n\n\t\t\t\tRectF grect; grect.X=0, grect.Y=0; grect.Width = width; grect.Height = height;\n\n\t\t\t\tgraphics.DrawImage(*m_pStdImage, grect, 0, 0, width, height, UnitPixel, &ia);\n\n\t\t\t\tm_dcGS.CreateCompatibleDC(pDC);\n\t\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\tpOldBitmap = m_dcGS.SelectObject(&bmp);\n\t\t\t\tm_dcGS.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\tbmp.DeleteObject();\n\t\t\t}\n\t\t}\n\n\t\t// alternate image\n\t\tif( (m_dcAlt.m_hDC == NULL) && m_bHaveAltImage )\n\t\t{\n\t\t\tPaintBk(pDC);\n\n\t\t\tgraphics.DrawImage(*m_pAltImage, 0, 0);\n\t\t\n\t\t\tm_dcAlt.CreateCompatibleDC(pDC);\n\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\tpOldBitmap = m_dcAlt.SelectObject(&bmp);\n\t\t\tm_dcAlt.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\tbmp.DeleteObject();\n\n\t\t\t// alternate image pressed\n\t\t\tif( (m_dcAltP.m_hDC == NULL) && m_bHaveAltImage )\n\t\t\t{\n\t\t\t\tPaintBk(pDC);\n\n\t\t\t\tgraphics.DrawImage(*m_pAltImage, 1, 1);\n\t\t\t\n\t\t\t\tm_dcAltP.CreateCompatibleDC(pDC);\n\t\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\tpOldBitmap = m_dcAltP.SelectObject(&bmp);\n\t\t\t\tm_dcAltP.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\tbmp.DeleteObject();\n\t\t\t}\n\n\t\t\t// alternate image hot\n\t\t\tif(m_dcAltH.m_hDC == NULL)\n\t\t\t{\n\t\t\t\tPaintBk(pDC);\n\n\t\t\t\tColorMatrix HotMat = {\t1.05f, 0.00f, 0.00f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 1.05f, 0.00f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 1.05f, 0.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.00f, 0.00f, 0.00f, 1.00f, 0.00f,\n\t\t\t\t\t\t\t\t\t\t0.05f, 0.05f, 0.05f, 0.00f, 1.00f\t};\n\n\t\t\t\tImageAttributes ia;\n\t\t\t\tia.SetColorMatrix(&HotMat);\n\n\t\t\t\tfloat width = (float)m_pStdImage->m_pBitmap->GetWidth();\n\t\t\t\tfloat height = (float)m_pStdImage->m_pBitmap->GetHeight();\n\n\t\t\t\tRectF grect; grect.X=0, grect.Y=0; grect.Width = width; grect.Height = height;\n\n\t\t\t\tgraphics.DrawImage(*m_pAltImage, grect, 0, 0, width, height, UnitPixel, &ia);\n\n\t\t\t\tm_dcAltH.CreateCompatibleDC(pDC);\n\t\t\t\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\t\t\t\tpOldBitmap = m_dcAltH.SelectObject(&bmp);\n\t\t\t\tm_dcAltH.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, 0, 0, SRCCOPY);\n\t\t\t\tbmp.DeleteObject();\n\t\t\t}\n\t\t}\n\n\t\tif(m_pCurBtn == NULL)\n\t\t{\n\t\t\tm_pCurBtn = &m_dcStd;\n\t\t}\n\n\t\tm_bHaveBitmaps = TRUE;\n\t}\n\n\treturn NULL;\n}\n\n//=============================================================================\n// paint the background\n//=============================================================================\nvoid CGdipButton::PaintBk(CDC *pDC)\n{\n\tCRect rect;\n\tGetClientRect(rect);\n\tpDC->BitBlt(0, 0, rect.Width(), rect.Height(), &m_dcBk, 0, 0, SRCCOPY);\n}\n\n//=============================================================================\n// paint the bitmap currently pointed to with m_pCurBtn\n//=============================================================================\nvoid CGdipButton::PaintBtn(CDC *pDC)\n{\n\tCRect rect;\n\tGetClientRect(rect);\n\tpDC->BitBlt(0, 0, rect.Width(), rect.Height(), m_pCurBtn, 0, 0, SRCCOPY);\n}\n\n//=============================================================================\n// enables the toggle mode\n// returns if it doesn't have the alternate image\n//=============================================================================\nvoid CGdipButton::EnableToggle(BOOL bEnable)\n{\n\tif(!m_bHaveAltImage) return;\n\n\tm_bIsToggle = bEnable; \n\n\t// this actually makes it start in the std state since toggle is called before paint\n\tif(bEnable)\tm_pCurBtn = &m_dcAlt;\n\telse\t\tm_pCurBtn = &m_dcStd;\n\n}\n\n//=============================================================================\n// sets the image type and disabled state then repaints\n//=============================================================================\nvoid CGdipButton::SetImage(int type)\n{\n\tm_nCurType = type;\n\n\t(type == DIS_TYPE) ? m_bIsDisabled = TRUE : m_bIsDisabled = FALSE;\n\n\tInvalidate();\n}\n\n//=============================================================================\n// set the control to owner draw\n//=============================================================================\nvoid CGdipButton::PreSubclassWindow()\n{\n\t// Set control to owner draw\n\tModifyStyle(0, BS_OWNERDRAW, SWP_FRAMECHANGED);\n\n\tCButton::PreSubclassWindow();\n}\n\n//=============================================================================\n// disable double click \n//=============================================================================\nBOOL CGdipButton::PreTranslateMessage(MSG* pMsg) \n{\n\tif (pMsg->message == WM_LBUTTONDBLCLK)\n\t\tpMsg->message = WM_LBUTTONDOWN;\n\n\tif (m_pToolTip != NULL)\n\t{\n\t\tif (::IsWindow(m_pToolTip->m_hWnd))\n\t\t{\n\t\t\tm_pToolTip->RelayEvent(pMsg);\t\t\n\t\t}\n\t}\n\n\treturn CButton::PreTranslateMessage(pMsg);\n}\n\n\n//=============================================================================\n// overide the erase function\n//=============================================================================\nBOOL CGdipButton::OnEraseBkgnd(CDC* pDC) \n{\n\treturn TRUE;\n}\n\n//=============================================================================\n// Paint the button depending on the state of the mouse\n//=============================================================================\nvoid CGdipButton::DrawItem(LPDRAWITEMSTRUCT lpDIS) \n{\n\tCDC* pDC = CDC::FromHandle(lpDIS->hDC);\n\n\t// handle disabled state\n\tif(m_bIsDisabled)\n\t{\n\t\tm_pCurBtn = &m_dcGS;\n\t\tPaintBtn(pDC);\n\t\treturn;\n\t}\n\n\tBOOL bIsPressed = (lpDIS->itemState & ODS_SELECTED);\n\n\t// handle toggle button\n\tif(m_bIsToggle && bIsPressed)\n\t{\n\t\t(m_nCurType == STD_TYPE) ? m_nCurType = ALT_TYPE : m_nCurType = STD_TYPE;\n\t}\n\n\tif(bIsPressed)\n\t{\n\t\tif(m_nCurType == STD_TYPE)\n\t\t\tm_pCurBtn = &m_dcStdP;\n\t\telse\n\t\t\tm_pCurBtn = &m_dcAltP;\n\t}\n\telse if(m_bIsHovering)\n\t{\n\n\t\tif(m_nCurType == STD_TYPE)\n\t\t\tm_pCurBtn = &m_dcStdH;\n\t\telse\n\t\t\tm_pCurBtn = &m_dcAltH;\n\t}\n\telse\n\t{\n\t\tif(m_nCurType == STD_TYPE)\n\t\t\tm_pCurBtn = &m_dcStd;\n\t\telse\n\t\t\tm_pCurBtn = &m_dcAlt;\n\t}\n\n\t// paint the button\n\tPaintBtn(pDC);\n}\n\n//=============================================================================\nLRESULT CGdipButton::OnMouseHover(WPARAM wparam, LPARAM lparam) \n//=============================================================================\n{\n\tm_bIsHovering = TRUE;\n\tInvalidate();\n\tDeleteToolTip();\n\n\t// Create a new Tooltip with new Button Size and Location\n\tSetToolTipText(m_tooltext);\n\n\tif (m_pToolTip != NULL)\n\t{\n\t\tif (::IsWindow(m_pToolTip->m_hWnd))\n\t\t{\n\t\t\t//Display ToolTip\n\t\t\tm_pToolTip->Update();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n//=============================================================================\nLRESULT CGdipButton::OnMouseLeave(WPARAM wparam, LPARAM lparam)\n//=============================================================================\n{\n\tm_bIsTracking = FALSE;\n\tm_bIsHovering = FALSE;\n\tInvalidate();\n\treturn 0;\n}\n\n//=============================================================================\nvoid CGdipButton::OnMouseMove(UINT nFlags, CPoint point) \n//=============================================================================\n{\n\tif (!m_bIsTracking)\n\t{\n\t\tTRACKMOUSEEVENT tme;\n\t\ttme.cbSize = sizeof(tme);\n\t\ttme.hwndTrack = m_hWnd;\n\t\ttme.dwFlags = TME_LEAVE|TME_HOVER;\n\t\ttme.dwHoverTime = 1;\n\t\tm_bIsTracking = _TrackMouseEvent(&tme);\n\t}\n\t\n\tCButton::OnMouseMove(nFlags, point);\n}\n\n//=============================================================================\n//\t\n//\tCall this member function with a memory DC from the code that paints \n//\tthe parents background.  Passing the screen DC defeats the purpose of \n//  using this function.\n//\n//=============================================================================\nvoid CGdipButton::SetBkGnd(CDC* pDC)\n{\n\tCRect rect, rectS;\n\tCBitmap bmp, *pOldBitmap;\n\n\tGetClientRect(rect);\n\tGetWindowRect(rectS);\n\tGetParent()->ScreenToClient(rectS);\n\n\tm_dcBk.DeleteDC();\n\n\tm_dcBk.CreateCompatibleDC(pDC);\n\tbmp.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());\n\tpOldBitmap = m_dcBk.SelectObject(&bmp);\n\tm_dcBk.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, rectS.left, rectS.top, SRCCOPY);\n\tbmp.DeleteObject();\n}\n\n\n//=============================================================================\n// Set the tooltip with a string resource\n//=============================================================================\nvoid CGdipButton::SetToolTipText(UINT nId, BOOL bActivate)\n{\n\t// load string resource\n\tm_tooltext.LoadString(nId);\n\n\t// If string resource is not empty\n\tif (m_tooltext.IsEmpty() == FALSE)\n\t{\n\t\tSetToolTipText(m_tooltext, bActivate);\n\t}\n\n}\n\n//=============================================================================\n// Set the tooltip with a CString\n//=============================================================================\nvoid CGdipButton::SetToolTipText(CString spText, BOOL bActivate)\n{\n\t// We cannot accept NULL pointer\n\tif (spText.IsEmpty()) return;\n\n\t// Initialize ToolTip\n\tInitToolTip();\n\tm_tooltext = spText;\n\n\t// If there is no tooltip defined then add it\n\tif (m_pToolTip->GetToolCount() == 0)\n\t{\n\t\tCRect rectBtn; \n\t\tGetClientRect(rectBtn);\n\t\tm_pToolTip->AddTool(this, m_tooltext, rectBtn, 1);\n\t}\n\n\t// Set text for tooltip\n\tm_pToolTip->UpdateTipText(m_tooltext, this, 1);\n\tm_pToolTip->SetDelayTime(2000);\n\tm_pToolTip->Activate(bActivate);\n}\n\n//=============================================================================\nvoid CGdipButton::InitToolTip()\n//=============================================================================\n{\n\tif (m_pToolTip == NULL)\n\t{\n\t\tm_pToolTip = new CToolTipCtrl;\n\t\t// Create ToolTip control\n\t\tm_pToolTip->Create(this);\n\t\tm_pToolTip->Activate(TRUE);\n\t}\n} \n\n//=============================================================================\nvoid CGdipButton::DeleteToolTip()\n//=============================================================================\n{\n\t// Destroy Tooltip incase the size of the button has changed.\n\tif (m_pToolTip != NULL)\n\t{\n\t\tdelete m_pToolTip;\n\t\tm_pToolTip = NULL;\n\t}\n}\n\n"
        },
        {
          "name": "GdipButton.h",
          "type": "blob",
          "size": 3.3740234375,
          "content": "//\n// GdipButton.h : Version 1.0 - see article at CodeProject.com\n//\n// Author:  Darren Sessions\n//          \n//\n// Description:\n//     GdipButton is a CButton derived control that uses GDI+ \n//     to support alternate image formats\n//\n// History\n//     Version 1.0 - 2008 June 10\n//     - Initial public release\n//\n// License:\n//     This software is released under the Code Project Open License (CPOL),\n//     which may be found here:  http://www.codeproject.com/info/eula.aspx\n//     You are free to use this software in any way you like, except that you \n//     may not sell this source code.\n//\n//     This software is provided \"as is\" with no expressed or implied warranty.\n//     I accept no liability for any damage or loss of business that this \n//     software may cause.\n//\n///////////////////////////////////////////////////////////////////////////////\n\n#pragma once\n\n// GdipButton.h : header file\n//\n\nclass CGdiPlusBitmapResource;\n/////////////////////////////////////////////////////////////////////////////\n// CGdipButton window\n\nclass CGdipButton : public CButton\n{\npublic:\n\n\tCGdipButton();\n\tvirtual ~CGdipButton();\n\n\t// image types\n\tenum\t{\n\t\t\t\tSTD_TYPE\t= 0,\n\t\t\t\tALT_TYPE,\n\t\t\t\tDIS_TYPE\n\t\t\t};\n\n\t// sets the image type\n\tvoid SetImage(int type);\n\n\tvoid CGdipButton::Test(CString c);\n\tBOOL LoadAltImage(UINT id, LPCTSTR pType);\n\tBOOL LoadStdImage(UINT id, LPCTSTR pType);\n\n\tBOOL LoadStdImageDPI(int dpi, UINT id96, UINT id120, UINT id144, UINT id168, UINT id192, LPCTSTR pType, UINT id225 = 0, UINT id250 = 0, UINT id275 = 0, UINT id300 = 0, UINT id325 = 0, UINT id350 = 0);\n\n\t// if false, disables the press state and uses grayscale image if it exists\n\tvoid EnableButton(BOOL bEnable = TRUE) { m_bIsDisabled = !bEnable; }\n\n\t// in toggle mode each press toggles between std and alt images\n\tvoid EnableToggle(BOOL bEnable = TRUE);\n\n\t// return the enable/disable state\n\tBOOL IsDisabled(void) {return (m_bIsDisabled == TRUE); }\n\n\tvoid SetBkGnd(CDC* pDC);\n\n\tvoid SetToolTipText(CString spText, BOOL bActivate = TRUE);\n\tvoid SetToolTipText(UINT nId, BOOL bActivate = TRUE);\n\tvoid SetHorizontal(bool ImagesAreLaidOutHorizontally = FALSE);\n\tvoid DeleteToolTip();\n\n\tvoid Reset();\n\n\nprotected:\n\n\tvoid PaintBk(CDC* pDC);\n\tvoid PaintBtn(CDC* pDC);\n\n\tBOOL\tm_bHaveAltImage;\n\tBOOL\tm_bHaveBitmaps;\n\n\tBOOL\tm_bIsDisabled;\n\tBOOL\tm_bIsToggle;\n\tBOOL\tm_bIsHovering;\n\tBOOL\tm_bIsTracking;\n\n\tint\t\tm_nCurType;\n\n\tCGdiPlusBitmapResource* m_pAltImage;\n\tCGdiPlusBitmapResource* m_pStdImage;\n\n\tCString\t\t\tm_tooltext;\n\tCToolTipCtrl*\tm_pToolTip;\n\t\n\tvoid\tInitToolTip();\n\n\tvirtual void PreSubclassWindow();\n\tvirtual void DrawItem(LPDRAWITEMSTRUCT /*lpDrawItemStruct*/);\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\n\t//{{AFX_MSG(CGdipButton)\n\tafx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\tafx_msg void OnMouseMove(UINT nFlags, CPoint point);\n\tafx_msg LRESULT OnMouseLeave(WPARAM wparam, LPARAM lparam);\n\tafx_msg LRESULT OnMouseHover(WPARAM wparam, LPARAM lparam) ;\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n\nprivate:\n\n\tCDC\t\tm_dcBk;\t\t\t// button background\n\t\n\tCDC\t\tm_dcStd;\t\t// standard button\n\tCDC\t\tm_dcStdP;\t\t// standard button pressed\n\tCDC\t\tm_dcStdH;\t\t// standard button hot\n\n\tCDC\t\tm_dcAlt;\t\t// alternate button\n\tCDC\t\tm_dcAltP;\t\t// alternate button pressed\n\tCDC\t\tm_dcAltH;\t\t// alternate button hot\n\n\tCDC\t\tm_dcGS;\t\t\t// grayscale button (does not have a hot or pressed state)\n\n\tCDC*\tm_pCurBtn;\t\t// current pointer to one of the above\n\n};\n"
        },
        {
          "name": "GlobalClips.cpp",
          "type": "blob",
          "size": 3.72265625,
          "content": "// GlobalClips.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"GlobalClips.h\"\n#include \"afxdialogex.h\"\n#include \"CopyProperties.h\"\n\n\n// GlobalClips dialog\n\nIMPLEMENT_DYNAMIC(GlobalClips, CDialogEx)\n\nGlobalClips::GlobalClips(CWnd* pParent /*=NULL*/)\n\t: CDialogEx(GlobalClips::IDD, pParent)\n{\n\n}\n\nGlobalClips::~GlobalClips()\n{\n}\n\nvoid GlobalClips::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_LIST2, m_List);\n}\n\n\nBEGIN_MESSAGE_MAP(GlobalClips, CDialogEx)\n\tON_WM_CLOSE()\n\tON_WM_SIZE()\n\tON_WM_NCDESTROY()\nEND_MESSAGE_MAP()\n\nBOOL GlobalClips::OnInitDialog()\n{\n\tCDialogEx::OnInitDialog();\n\n\ttheApp.m_Language.UpdateGlobalHotKeys(this);\n\n\tm_Resize.SetParent(m_hWnd);\n\tm_Resize.AddControl(IDC_LIST2, DR_SizeHeight | DR_SizeWidth);\n\tm_Resize.AddControl(IDCANCEL, DR_MoveTop | DR_MoveLeft);\n\n\tInitListCtrlCols();\n\n\tLoadItems();\n\n\treturn TRUE;\n}\n\nvoid GlobalClips::LoadItems()\n{\n\tm_List.DeleteAllItems();\n\n\t// Use the LV_ITEM structure to insert the items\n\tLVITEM lvi;\n\tCString strItem;\n\tint count = (int)g_HotKeys.GetCount();\n\n\tint row = 0;\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tCHotKey *pHotKey = g_HotKeys[i];\n\n\t\tif(pHotKey->m_Key <= 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Insert the first item\n\t\tlvi.mask =  LVIF_TEXT;\n\t\tlvi.iItem = row;\n\n\t\tstrItem = pHotKey->m_Name;\n\n\t\tif(pHotKey->m_clipId > 0)\n\t\t{\n\t\t\tstrItem = pHotKey->m_description;\n\n\t\t\tif(pHotKey->m_hkType == CHotKey::PASTE_OPEN_CLIP)\n\t\t\t{\n\t\t\t\tstrItem.Insert(0, theApp.m_Language.GetGlobalHotKeyString(\"(Clip)\", \"(Clip) \"));\n\t\t\t}\n\t\t\telse if(pHotKey->m_hkType == CHotKey::MOVE_TO_GROUP)\n\t\t\t{\n\t\t\t\tstrItem.Insert(0, _T(\"(Move To Group) \"));\n\t\t\t}\n\t\t}\n\n\t\tlvi.iSubItem = 0;\n\t\tlvi.pszText = (LPTSTR)(LPCTSTR)(strItem);\n\t\tm_List.InsertItem(&lvi);\n\n\t\tstrItem = pHotKey->GetHotKeyDisplay();\n\t\tm_List.SetItemText(row, 1, strItem);\n\n\t\tstrItem = theApp.m_Language.GetGlobalHotKeyString(\"Error\", \"Error\");\n\t\tif(pHotKey->IsRegistered())\n\t\t{\n\t\t\tstrItem = theApp.m_Language.GetGlobalHotKeyString(\"Yes\", \"Yes\");\n\t\t}\n\n\t\tm_List.SetItemText(row, 2, strItem);\n\n\t\tm_List.SetItemData(row, pHotKey->m_globalId);\n\n\t\trow++;\n\t}\n}\n\nvoid GlobalClips::InitListCtrlCols()\n{\n\tm_List.SetExtendedStyle(LVS_EX_FULLROWSELECT);\n\t\n\tm_List.InsertColumn(0, theApp.m_Language.GetGlobalHotKeyString(\"Description\", \"Description\"), LVCFMT_LEFT, 200);\n\tm_List.InsertColumn(1, theApp.m_Language.GetGlobalHotKeyString(\"HotKey\", \"Hot Key\"), LVCFMT_LEFT, 100);\n\tm_List.InsertColumn(2, theApp.m_Language.GetGlobalHotKeyString(\"Registered\", \"Registered\"), LVCFMT_LEFT, 100);\n}\n\nvoid GlobalClips::SetNotifyWnd(HWND hWnd)\n{\n\tm_hWndParent = hWnd;\n}\n\nvoid GlobalClips::OnClose()\n{\n\tDestroyWindow();\n}\n\nvoid GlobalClips::OnCancel()\n{\n\tDestroyWindow();\n}\n\nvoid GlobalClips::OnSize(UINT nType, int cx, int cy)\n{\n\tCDialogEx::OnSize(nType, cx, cy);\n\n\tm_Resize.MoveControls(CSize(cx, cy));\n}\n\n//void GlobalClips::OnBnClickedButtonRefresh()\n//{\n//\tLoadItems();\n//}\n//\n//void GlobalClips::OnNMDblclkList2(NMHDR *pNMHDR, LRESULT *pResult)\n//{\n//\tLPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\n//\t// TODO: Add your control notification handler code here\n//\n//\tint id = (int)m_List.GetItemData(pNMItemActivate->iItem);\n//\n//\tint count = (int)g_HotKeys.GetCount();\n//\n//\tint row = 0;\n//\tfor (int i = 0; i < count; i++)\n//\t{\n//\t\tCHotKey *pHotKey = g_HotKeys[i];\n//\n//\t\tif(pHotKey->m_globalId == id)\n//\t\t{\n//\t\t\tif(pHotKey->m_clipId > 0)\n//\t\t\t{\n//\t\t\t\tCCopyProperties props(pHotKey->m_clipId, this);\n//\t\t\t\tprops.SetToTopMost(false);\n//\t\t\t\tINT_PTR doModalRet = props.DoModal();\n//\n//\t\t\t\tif(doModalRet == IDOK)\n//\t\t\t\t{\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\telse\n//\t\t\t{\n//\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n//\t}\n//\t\n//\t*pResult = 0;\n//}\n\nvoid GlobalClips::OnNcDestroy()\n{\n\tCDialogEx::OnNcDestroy();\n\t::PostMessage(m_hWndParent, WM_GLOBAL_CLIPS_CLOSED, 0, 0);\n}\n"
        },
        {
          "name": "GlobalClips.h",
          "type": "blob",
          "size": 0.744140625,
          "content": "#pragma once\n\n#include \"DialogResizer.h\"\n#include \"ShowTaskBarIcon.h\"\n// GlobalClips dialog\n\nclass GlobalClips : public CDialogEx\n{\n\tDECLARE_DYNAMIC(GlobalClips)\n\npublic:\n\tGlobalClips(CWnd* pParent = NULL);   // standard constructor\n\tvirtual ~GlobalClips();\n\n// Dialog Data\n\tenum { IDD = IDD_GLOBAL_CLIPS };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\tvoid InitListCtrlCols();\n\tvirtual void OnCancel();\n\tvoid LoadItems();\n\n\tCDialogResizer m_Resize;\n\tCListCtrl\tm_List;\n\tHWND m_hWndParent;\n\tCShowTaskBarIcon m_showTaskbar;\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tvoid SetNotifyWnd(HWND hWnd);\n\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnClose();\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnNcDestroy();\n};\n"
        },
        {
          "name": "GroupCombo.cpp",
          "type": "blob",
          "size": 1.8720703125,
          "content": "// GroupCombo.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"GroupCombo.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupCombo\n\nCGroupCombo::CGroupCombo()\n{\n\tm_lSkipGroupID = -1;\n}\n\nCGroupCombo::~CGroupCombo()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CGroupCombo, CComboBox)\n\t//{{AFX_MSG_MAP(CGroupCombo)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupCombo message handlers\n\nvoid CGroupCombo::FillCombo()\n{\n\tResetContent();\n\n\tint nIndex = AddString(_T(\"-No Group-\"));\n\tSetItemData(nIndex, -1);\n\n\tFillCombo(-1, 1);\n}\n\nvoid CGroupCombo::FillCombo(long lParentID, long lSpaces)\n{\n\ttry\n\t{\t\t\t\n\t\tint nIndex;\n\t\tCString csSpaces;\n\n\t\tfor(int i = 0; i < lSpaces; i++)\n\t\t{\n\t\t\tcsSpaces += \"---\";\n\t\t}\n\n\t\t//First time through\n\t\tif(lSpaces > 0)\n\t\t{\n\t\t\tcsSpaces += \" \";\n\t\t\t//ResetContent();\n\t\t}\n\n\t\tlSpaces++;\n\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, mText FROM Main WHERE bIsGroup = 1 AND lParentID = %d\"), lParentID);\n\t\t\t\n\t\tif(q.eof() == false)\n\t\t{\n\t\t\twhile(!q.eof())\n\t\t\t{\n\t\t\t\tif(q.getIntField(_T(\"lID\")) != m_lSkipGroupID)\n\t\t\t\t{\n\t\t\t\t\tnIndex = AddString(csSpaces + q.getStringField(_T(\"mText\")));\n\t\t\t\t\tSetItemData(nIndex, q.getIntField(_T(\"lID\")));\n\n\t\t\t\t\tFillCombo(q.getIntField(_T(\"lID\")), lSpaces);\n\t\t\t\t}\n\n\t\t\t\tq.nextRow();\n\t\t\t}\n\t\t}\n\t}\t\t\n\tCATCH_SQLITE_EXCEPTION\t\n}\n\nBOOL CGroupCombo::SetCurSelOnItemData(long lItemData)\n{\n\tlong lCount = GetCount();\n\n\tfor(int i = 0; i < lCount; i++)\n\t{\n\t\tif(GetItemData(i) == lItemData)\n\t\t{\n\t\t\tSetCurSel(i);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\tSetCurSel(-1);\n\n\treturn FALSE;\n}\n\nint CGroupCombo::GetItemDataFromCursel()\n{\n\tint nCursel = GetCurSel();\n\treturn (int)GetItemData(nCursel);\n}"
        },
        {
          "name": "GroupCombo.h",
          "type": "blob",
          "size": 1.2490234375,
          "content": "#if !defined(AFX_GROUPCOMBO_H__42D00360_95BE_49B5_AA39_E3B37CFCFF5B__INCLUDED_)\n#define AFX_GROUPCOMBO_H__42D00360_95BE_49B5_AA39_E3B37CFCFF5B__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// GroupCombo.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupCombo window\n\nclass CGroupCombo : public CComboBox\n{\n// Construction\npublic:\n\tCGroupCombo();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CGroupCombo)\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~CGroupCombo();\n\n\tvoid FillCombo();\n\tvoid FillCombo(long lParentID, long lSpaces);\n\tBOOL SetCurSelOnItemData(long lItemData);\n\tint GetItemDataFromCursel();\n\n\tlong m_lSkipGroupID;\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CGroupCombo)\n\t\t// NOTE - the ClassWizard will add and remove member functions here.\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_GROUPCOMBO_H__42D00360_95BE_49B5_AA39_E3B37CFCFF5B__INCLUDED_)\n"
        },
        {
          "name": "GroupName.cpp",
          "type": "blob",
          "size": 1.0458984375,
          "content": "// GroupName.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"GroupName.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupName dialog\n\n\nCGroupName::CGroupName(CWnd* pParent /*=NULL*/)\n\t: CDialog(CGroupName::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CGroupName)\n\tm_csName = _T(\"\");\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CGroupName::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CGroupName)\n\tDDX_Text(pDX, IDC_NAME, m_csName);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CGroupName, CDialog)\n\t//{{AFX_MSG_MAP(CGroupName)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupName message handlers\n\nvoid CGroupName::OnOK() \n{\n\tUpdateData(TRUE);\n\t\n\tCDialog::OnOK();\n}\n\nBOOL CGroupName::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\n\tCWnd *pWnd = GetDlgItem(IDC_NAME);\n\tif(pWnd)\n\t\tpWnd->SetFocus();\n\t\t\n\treturn FALSE;\n}\n"
        },
        {
          "name": "GroupName.h",
          "type": "blob",
          "size": 1.1376953125,
          "content": "#if !defined(AFX_GROUPNAME_H__C0A39EC3_DC62_43FF_A9BF_9AC3E356C498__INCLUDED_)\n#define AFX_GROUPNAME_H__C0A39EC3_DC62_43FF_A9BF_9AC3E356C498__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// GroupName.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupName dialog\n\nclass CGroupName : public CDialog\n{\n// Construction\npublic:\n\tCGroupName(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CGroupName)\n\tenum { IDD = IDD_GROUP_NAME };\n\tCString\tm_csName;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CGroupName)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CGroupName)\n\tvirtual void OnOK();\n\tvirtual BOOL OnInitDialog();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_GROUPNAME_H__C0A39EC3_DC62_43FF_A9BF_9AC3E356C498__INCLUDED_)\n"
        },
        {
          "name": "GroupStatic.cpp",
          "type": "blob",
          "size": 3.4990234375,
          "content": "// GroupStatic.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"GroupStatic.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CGroupStatic\r\n\r\nCGroupStatic::CGroupStatic()\r\n{\r\n\tm_dwTextColor = 0;\r\n\tm_dwBkColor = RGB(255, 255, 255);\r\n\tm_toggleCursorToHand = false;\r\n\tm_pFont = NULL;\r\n}\r\n\r\nCGroupStatic::~CGroupStatic()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CGroupStatic, CStatic)\r\n\t//{{AFX_MSG_MAP(CGroupStatic)\r\n\tON_WM_SETCURSOR()\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CGroupStatic message handlers\r\n\r\nBOOL CGroupStatic::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult) \r\n{  \r\n#ifndef WIN32\r\n      return CStatic::OnChildNotify(message, wParam, lParam, pLResult);\r\n#else\r\n   // If not setting static control color, do default processing\r\n   if( message != WM_CTLCOLORSTATIC )\r\n      return CStatic::OnChildNotify(message, wParam, lParam, pLResult);\r\n\r\n   HDC hdcChild = (HDC)wParam;\r\n\r\n   // Set the foreground color\r\n   ::SetTextColor( hdcChild, m_dwTextColor );\r\n\r\n   // If a background color is pre-determined\r\n   if(m_dwBkColor != -1)\r\n   {  \r\n      ::SetBkMode(hdcChild, TRANSPARENT);\r\n      ::SetBkColor(hdcChild, m_dwBkColor);  \r\n\t   m_brush.DeleteObject();\r\n\t   m_brush.CreateSolidBrush(m_dwBkColor);\r\n      *pLResult = (LRESULT)(m_brush.GetSafeHandle());\r\n   }\r\n   else\r\n   {\r\n   // Determine the current background color based on my parent window\r\n      static COLORREF clrPrevValid = -1;\r\n      HWND hParent = ::GetParent(m_hWnd);\r\n      HDC  hParentDc = ::GetDC(hParent);\r\n\r\n      // Get the color based on the 0, 0 reference\r\n      COLORREF clrParentBkground = ::GetPixel(hParentDc, 0, 0);\r\n      ::ReleaseDC(hParent, hParentDc);\r\n\r\n      // If found (not off of the screen or under another window)\r\n      // set my current color to it\r\n      if(clrParentBkground == -1)\r\n      {  clrParentBkground = clrPrevValid;  }\r\n      else\r\n      {  clrPrevValid = clrParentBkground;  }\r\n\r\n      // If either the current, or previous color found was not valid\r\n      // allow to perform default processing\r\n      if(clrParentBkground == -1)\r\n      {  return FALSE;  }\r\n\r\n\r\n      // Set the background mode to transparent\r\n      ::SetBkMode(hdcChild, TRANSPARENT);\r\n\r\n      // Set the background color and brush based on my parent's color\r\n      ::SetBkColor(hdcChild, clrParentBkground);  \r\n\t   m_brush.DeleteObject();\r\n\t   m_brush.CreateSolidBrush(clrParentBkground);\r\n      *pLResult = (LRESULT)(m_brush.GetSafeHandle());\r\n   }\r\n\r\n   // Return TRUE to indicate that the message was handled\r\n   return TRUE;\r\n#endif\r\n}\r\n\r\n\r\n/*************************************************************************\r\n*\r\n*************************************************************************/\r\nvoid CGroupStatic::SetFont( int nPointSize, LPCTSTR lpszFaceName, CDC* pDC )\r\n{\r\n   // If a font has been allocated, delete it\r\n   if( m_pFont )\r\n      delete m_pFont;\r\n\r\n   m_pFont = new CFont;\r\n\r\n   // Create a font using the given attributes\r\n   m_pFont->CreatePointFont( nPointSize, lpszFaceName, pDC );\r\n\r\n   // Set the window's current font to the specified font\r\n   CStatic::SetFont( m_pFont );\r\n}\r\n\r\nBOOL CGroupStatic::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) \r\n{\r\n\tif (m_toggleCursorToHand)\r\n\t{\r\n\t\tHCURSOR h = ::LoadCursor(NULL, IDC_HAND);\r\n\t\t::SetCursor(h);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn FALSE;\r\n}"
        },
        {
          "name": "GroupStatic.h",
          "type": "blob",
          "size": 1.7451171875,
          "content": "#if !defined(AFX_GROUPSTATIC_H__C7039DB6_84EE_4622_8054_6DBA48FA21A9__INCLUDED_)\n#define AFX_GROUPSTATIC_H__C7039DB6_84EE_4622_8054_6DBA48FA21A9__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// GroupStatic.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CGroupStatic window\n\nclass CGroupStatic : public CStatic\n{\n// Construction\npublic:\n\tCGroupStatic();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n\tvoid SetTextColor( COLORREF color )\t\t{ m_dwTextColor = color;\t}\n\tvoid SetBkColor( COLORREF color )\t\t{ m_dwBkColor = color;\t\t}\n\tvoid SetFont( int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL );\n\tvoid SetFont(CFont *pFont)\t\t\t\t{ CStatic::SetFont(pFont);\t\t}\n\tvoid SetToggleCursor(bool toggle)\t\t{ m_toggleCursorToHand = toggle; }\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CGroupStatic)\n\tpublic:\n\tvirtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~CGroupStatic();\n\nprotected:\n\tCOLORREF m_dwTextColor;\n\tCOLORREF m_dwBkColor;\n\tCFont*   m_pFont;\n\tCBrush   m_brush;\n\tCString  m_strBuff;        // Holds the static controls contents before & after the control is displayed\n\tbool m_toggleCursorToHand;\n\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CGroupStatic)\n\tafx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_GROUPSTATIC_H__C7039DB6_84EE_4622_8054_6DBA48FA21A9__INCLUDED_)\n"
        },
        {
          "name": "GroupTree.cpp",
          "type": "blob",
          "size": 9.177734375,
          "content": "// GroupTree.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"GroupTree.h\"\r\n#include \"ActionEnums.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CGroupTree\r\n\r\nCGroupTree::CGroupTree()\r\n{\r\n\tm_bHide = true;\r\n\tm_selectedFolderID = -1;\r\n\tm_bSendAllready = false;\r\n\tm_showRightClickMenu = false;\t\r\n}\r\n\r\nCGroupTree::~CGroupTree()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CGroupTree, CTreeCtrl)\r\n\t//{{AFX_MSG_MAP(CGroupTree)\r\n\tON_WM_CREATE()\r\n\tON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)\r\n\tON_NOTIFY_REFLECT(NM_RCLICK, OnRclickQuickPaste)\r\n\tON_WM_KILLFOCUS()\r\n\tON_WM_ACTIVATE()\r\n\tON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)\r\n\tON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)\r\n\tON_WM_RBUTTONDOWN()\r\n\t//}}AFX_MSG_MAP\r\n\tON_COMMAND(ID_MENU_NEWGROUP32896, &CGroupTree::OnMenuNewgroup32896)\r\n\tON_COMMAND(ID_MENU_DELETEGROUP, &CGroupTree::OnMenuDeletegroup)\r\n\tON_COMMAND(ID_MENU_PROPERTIES32898, &CGroupTree::OnMenuProperties32898)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_NEWGROUP32896, &CGroupTree::OnUpdateMenuNewgroup32896)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_DELETEGROUP, &CGroupTree::OnUpdateMenuDeletegroup)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_PROPERTIES32898, &CGroupTree::OnUpdateMenuProperties32898)\r\n\tON_WM_INITMENUPOPUP() \r\nEND_MESSAGE_MAP()\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CGroupTree message handlers\r\n\r\nBOOL CGroupTree::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) \r\n{\r\n\t// TODO: Add your specialized code here and/or call the base class\r\n\t\r\n\treturn CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);\r\n}\r\n\r\nint CGroupTree::OnCreate(LPCREATESTRUCT lpCreateStruct) \r\n{\r\n\tif (CTreeCtrl::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\r\n\tCImageList iml;\r\n\timl.Create(18, 16, ILC_COLOR | ILC_MASK, 0, 1);\r\n\r\n\tm_bmClosedFolder.LoadBitmap(IDB_CLOSED_FOLDER);\r\n\timl.Add(&m_bmClosedFolder, RGB(255, 0, 0));\r\n\r\n\tm_bmOpenFolder.LoadBitmap(IDB_CLOSED_FOLDER);\r\n\timl.Add(&m_bmOpenFolder, RGB(255, 0, 0));\r\n\t\r\n\r\n\tSetImageList(&iml, TVSIL_NORMAL);\r\n\timl.Detach();\r\n\r\n\tm_actions.AddAccel(ActionEnums::NEWGROUP, ACCEL_MAKEKEY(VK_F7, HOTKEYF_CONTROL));\r\n\tm_actions.AddAccel(ActionEnums::CLIP_PROPERTIES, ACCEL_MAKEKEY(VK_RETURN, HOTKEYF_ALT));\r\n\tm_actions.AddAccel(ActionEnums::DELETE_SELECTED, VK_DELETE);\r\n\r\n\t\r\n\r\n\treturn 0;\r\n}\r\n\r\nBOOL CGroupTree::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\tif(CheckActions(pMsg))\r\n\t{\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn CTreeCtrl::PreTranslateMessage(pMsg);\r\n}\r\n\r\nbool CGroupTree::CheckActions(MSG * pMsg) \r\n{\r\n\tbool ret = false;\r\n\tCAccel a;\r\n\r\n\tif (m_actions.OnMsg(pMsg, a))\r\n\t{\r\n\t\tret = DoAction(a.Cmd);\r\n\t}   \r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CGroupTree::DoAction(DWORD actionId)\r\n{\r\n\tbool ret = false;\r\n\r\n\tswitch (actionId)\r\n\t{\r\n\tcase ActionEnums::NEWGROUP:\r\n\t\tret = DoActionNewGroup();\r\n\t\tbreak;\r\n\tcase ActionEnums::DELETE_SELECTED:\r\n\t\tret = DoActionDeleteSelected();\r\n\t\tbreak;\r\n\tcase ActionEnums::CLIP_PROPERTIES:\r\n\t\tret = DoActionClipProperties();\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CGroupTree::DoActionNewGroup()\r\n{\r\n\tHTREEITEM hItem = GetSelectedItem();\r\n\tif (hItem)\r\n\t{\r\n\t\tint id = (int) GetItemData(hItem);\r\n\t\t::PostMessage(m_NotificationWnd, NM_NEW_GROUP, id, 0);\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CGroupTree::DoActionDeleteSelected()\r\n{\r\n\tHTREEITEM hItem = GetSelectedItem();\r\n\tif (hItem)\r\n\t{\r\n\t\tint id = (int) GetItemData(hItem);\r\n\t\tif (id >= 0)\r\n\t\t{\r\n\t\t\t::PostMessage(m_NotificationWnd, NM_DELETE_ID, id, 0);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CGroupTree::DoActionClipProperties()\r\n{\r\n\tHTREEITEM hItem = GetSelectedItem();\r\n\tif (hItem)\r\n\t{\r\n\t\tint id = (int) GetItemData(hItem);\r\n\t\tif (id >= 0)\r\n\t\t{\r\n\t\t\t::PostMessage(m_NotificationWnd, NM_SHOW_PROPERTIES, id, 0);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid CGroupTree::FillTree()\r\n{\t\r\n\tthis->SetBkColor(CGetSetOptions::m_Theme.GroupTreeBG());\r\n\tthis->SetTextColor(CGetSetOptions::m_Theme.GroupTreeText());\r\n\r\n\tDeleteAllItems();\r\n\tm_bSendAllready = false;\r\n\r\n\tHTREEITEM hItem = InsertItem(_T(\"-No Group-\"), TVI_ROOT);\r\n\tSetItemData(hItem, -1);\r\n\r\n\tSetItemState(hItem, TVIS_EXPANDED, TVIS_EXPANDED);\r\n\r\n\tif(m_selectedFolderID < 0)\r\n\t\tSelectItem(hItem);\r\n\t\r\n\tFillTree(-1, hItem);\r\n}\r\n\r\n\r\nvoid CGroupTree::FillTree(int parentID, HTREEITEM hParent)\r\n{\t\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, mText FROM Main WHERE bIsGroup = 1 AND lParentID = %d\"), parentID);\r\n\t\t\t\r\n\t\tif(q.eof() == false)\r\n\t\t{\r\n\t\t\tHTREEITEM hItem;\r\n\r\n\t\t\twhile(!q.eof())\r\n\t\t\t{\r\n\t\t\t\tif(q.getIntField(_T(\"lID\")) == m_selectedFolderID)\r\n\t\t\t\t{\r\n\t\t\t\t\thItem = InsertItem(q.getStringField(_T(\"mText\")), 1, 1, hParent);\r\n\t\t\t\t\tSelectItem(hItem);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\t\t\t\t\r\n\t\t\t\t\thItem = InsertItem(q.getStringField(_T(\"mText\")), 0, 0, hParent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tSetItemData(hItem, q.getIntField(_T(\"lID\")));\r\n\t\t\t\t\r\n\t\t\t\tFillTree(q.getIntField(_T(\"lID\")), hItem);\r\n\r\n\t\t\t\tq.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\t\r\n\tCATCH_SQLITE_EXCEPTION\t\r\n}\r\n\r\nvoid CGroupTree::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) \r\n{\r\n\tNM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;\r\n\t// TODO: Add your control notification handler code here\r\n\t\r\n//\tif(m_bHide == true)\r\n//\t{\t\r\n//\t\t::SendMessage(m_NotificationWnd, NM_GROUP_TREE_MESSAGE, GetItemData(pNMTreeView->itemNew.hItem), 0);\r\n//\t}\r\n\t\r\n\t//*pResult = 0;\r\n}\r\n\r\nvoid CGroupTree::OnKillFocus(CWnd* pNewWnd) \r\n{\r\n\tCTreeCtrl::OnKillFocus(pNewWnd);\r\n}\r\n\r\nvoid CGroupTree::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \r\n{\r\n\tCTreeCtrl::OnActivate(nState, pWndOther, bMinimized);\r\n\t\r\n\tif(m_bHide)\r\n\t{\r\n\t\tif (nState == WA_INACTIVE)\r\n\t\t{\t\t\r\n\t\t\tSendToParent(-1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CGroupTree::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) \r\n{\r\n\tHTREEITEM hItem =  GetNextItem(TVI_ROOT, TVGN_CARET);\r\n\tif(hItem)\r\n\t\tSendToParent((int)GetItemData(hItem));\r\n\t\t\t\r\n\t*pResult = 1;\r\n}\r\n\r\nint CGroupTree::GetSelectedTree()\r\n{\r\n\tHTREEITEM hItem =  GetNextItem(TVI_ROOT, TVGN_CARET);\r\n\tif(hItem)\r\n\t\treturn (int)GetItemData(hItem);\r\n\r\n\treturn -1;\r\n}\r\n\r\nvoid CGroupTree::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) \r\n{\r\n\tTV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;\r\n\t\r\n\tswitch(pTVKeyDown->wVKey)\r\n\t{\r\n\tcase VK_RETURN:\r\n\t{\t\r\n\t\tHTREEITEM hItem =  GetNextItem(TVI_ROOT, TVGN_CARET);\r\n\t\tif(hItem)\r\n\t\t\tSendToParent((int)GetItemData(hItem));\r\n\t\t\r\n\t\tbreak;\r\n\t}\r\n\tcase VK_ESCAPE:\r\n\t{\t\r\n\t\tSendToParent(-1);\r\n\t\tbreak;\r\n\t}\t\r\n\t}\r\n\t\r\n\t*pResult = 1;\r\n}\r\n\r\n\r\nvoid CGroupTree::SendToParent(int parentId)\r\n{\r\n\tif(m_bSendAllready == false)\r\n\t{\r\n\t\tm_bSendAllready = true;\r\n\t\t::PostMessage(m_NotificationWnd, NM_GROUP_TREE_MESSAGE, parentId, 0);\r\n\t}\r\n}\r\n\r\nbool CGroupTree::AddNode(CString csText, int id)\r\n{\r\n\tHTREEITEM hItem;\r\n\r\n\tHTREEITEM hParent =  GetNextItem(TVI_ROOT, TVGN_CARET);\r\n\tif(hParent == NULL)\r\n\t\treturn false;\r\n\t\t\r\n\thItem = InsertItem(csText, 1, 1, hParent);\r\n\tSelectItem(hItem);\r\n\r\n\tSetItemData(hItem, id);\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CGroupTree::OnRButtonDown(UINT nFlags, CPoint point)\r\n{\r\n\tUINT nHitFlags = 0;\r\n\tHTREEITEM hClickedItem = HitTest(point, &nHitFlags);\r\n\r\n\tif (nHitFlags&TVHT_ONITEM)\r\n\t\tif (GetSelectedCount() < 2)\r\n\t\t\tSelectItem(hClickedItem);\r\n\r\n\tCTreeCtrl::OnRButtonDown(nFlags, point);\r\n}\r\n\r\nUINT CGroupTree::GetSelectedCount() const\r\n{\r\n\t// Only visible items should be selected!\r\n\tUINT uCount = 0;\r\n\tfor (HTREEITEM hItem = GetRootItem(); hItem != NULL; hItem = GetNextVisibleItem(hItem))\r\n\t\tif (GetItemState(hItem, TVIS_SELECTED) & TVIS_SELECTED)\r\n\t\t\tuCount++;\r\n\r\n\treturn uCount;\r\n}\r\n\r\nvoid CGroupTree::OnRclickQuickPaste(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tif (m_showRightClickMenu == false)\r\n\t{\r\n\t\t*pResult = 0;\r\n\t\treturn;\r\n\t}\r\n\tPOINT pp;\r\n\tCMenu cmPopUp;\r\n\tCMenu *cmSubMenu = NULL;\r\n\r\n\tGetCursorPos(&pp);\r\n\tif (cmPopUp.LoadMenu(IDR_MENU_GROUPS) != 0)\r\n\t{\r\n\t\tcmSubMenu = cmPopUp.GetSubMenu(0);\r\n\t\tif (!cmSubMenu)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttheApp.m_Language.UpdateGroupsRightClickMenu(cmSubMenu);\r\n\t\t\r\n\t\tcmSubMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, pp.x, pp.y, this, NULL);\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\nvoid CGroupTree::OnMenuNewgroup32896()\r\n{\r\n\tDoAction(ActionEnums::NEWGROUP);\r\n}\r\n\r\n\r\nvoid CGroupTree::OnMenuDeletegroup()\r\n{\r\n\tDoAction(ActionEnums::DELETE_SELECTED);\r\n}\r\n\r\nvoid CGroupTree::OnMenuProperties32898()\r\n{\r\n\tDoAction(ActionEnums::CLIP_PROPERTIES);\r\n}\r\n\r\nvoid CGroupTree::OnUpdateMenuNewgroup32896(CCmdUI *pCmdUI)\r\n{\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::NEWGROUP);\r\n}\r\n\r\nvoid CGroupTree::OnUpdateMenuDeletegroup(CCmdUI *pCmdUI)\r\n{\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::DELETE_SELECTED);\t\r\n}\r\n\r\nvoid CGroupTree::OnUpdateMenuProperties32898(CCmdUI *pCmdUI)\r\n{\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::CLIP_PROPERTIES);\t\r\n}\r\n\r\nvoid CGroupTree::UpdateMenuShortCut(CCmdUI *pCmdUI, DWORD action)\r\n{\r\n\tif(pCmdUI == NULL ||\r\n\t\tpCmdUI->m_pMenu == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tCString cs;\r\n\tpCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, cs, MF_BYCOMMAND);\r\n\tCString shortcutText = m_actions.GetCmdKeyText(action);\r\n\tif(shortcutText != _T(\"\") &&\r\n\t\tcs.Find(\"\\t\" + shortcutText) < 0)\r\n\t{\r\n\t\tcs += \"\\t\";\r\n\t\tcs += shortcutText;\r\n\t\tpCmdUI->SetText(cs);\r\n\t}\r\n}\r\n\r\nvoid CGroupTree::OnInitMenuPopup(CMenu *pPopupMenu, UINT nIndex,BOOL bSysMenu)\r\n{\r\n\tOnInitMenuPopupEx(pPopupMenu, nIndex, bSysMenu, this);\r\n}"
        },
        {
          "name": "GroupTree.h",
          "type": "blob",
          "size": 2.966796875,
          "content": "#if !defined(AFX_GROUPTREE_H__A1F01358_5440_45A8_B402_3F32F46FCAA5__INCLUDED_)\r\n#define AFX_GROUPTREE_H__A1F01358_5440_45A8_B402_3F32F46FCAA5__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n// GroupTree.h : header file\r\n//\r\n#include \"Accels.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CGroupTree window\r\n\r\nclass CGroupTree : public CTreeCtrl\r\n{\r\n// Construction\r\npublic:\r\n\tCGroupTree();\r\n\r\n// Attributes\r\npublic:\r\n\r\n// Operations\r\npublic:\r\n\tvoid FillTree();\r\n\tvoid SetNotificationWndEx(HWND hWnd)\t{ m_NotificationWnd = hWnd;\t}\r\n\tbool m_bHide;\r\n\tint m_selectedFolderID;\r\n\tint GetSelectedTree();\r\n\tbool AddNode(CString csText, int id);\r\n\tbool m_showRightClickMenu;\r\n\r\nprotected:\r\n\tvoid FillTree(int parentId, HTREEITEM hParent);\r\n\tvoid SendToParent(int parentId);\r\n\tUINT GetSelectedCount() const;\r\n\tbool CheckActions(MSG * pMsg);\r\n\tbool DoAction(DWORD actionId);\r\n\tbool DoActionNewGroup();\r\n\tbool DoActionDeleteSelected();\r\n\tbool DoActionClipProperties();\r\n\tvoid UpdateMenuShortCut(CCmdUI *pCmdUI, DWORD action);\r\n\r\n\tHWND m_NotificationWnd;\r\n\tCBitmap m_bmOpenFolder;\r\n\tCBitmap m_bmClosedFolder;\r\n\tbool m_bSendAllready;\r\n\tCAccels m_actions;\r\n\r\n// Overrides\r\n\t// ClassWizard generated virtual function overrides\r\n\t//{{AFX_VIRTUAL(CGroupTree)\r\n\tpublic:\r\n\tvirtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);\r\n\tvirtual BOOL PreTranslateMessage(MSG *pMsg);\r\n\t//}}AFX_VIRTUAL\r\n\r\n// Implementation\r\npublic:\r\n\tvirtual ~CGroupTree();\r\n\r\n\t// Generated message map functions\r\nprotected:\r\n\t//{{AFX_MSG(CGroupTree)\r\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\r\n\tafx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tafx_msg void OnKillFocus(CWnd* pNewWnd);\r\n\tafx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);\r\n\tafx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tafx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tafx_msg void OnRclickQuickPaste(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnRButtonDown(UINT nFlags, CPoint point);\r\n\t//}}AFX_MSG\r\n\r\n\tDECLARE_MESSAGE_MAP()\r\n\t// Generated OLE dispatch map functions\r\n\t//{{AFX_DISPATCH(CGroupTree)\r\n\t\t// NOTE - the ClassWizard will add and remove member functions here.\r\n\t//}}AFX_DISPATCH\r\npublic:\r\n\tafx_msg void OnMenuNewgroup32896();\r\n\tafx_msg void OnMenuDeletegroup();\r\n\tafx_msg void OnMenuProperties32898();\r\n\tafx_msg void OnUpdateMenuNewgroup32896(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateMenuDeletegroup(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateMenuProperties32898(CCmdUI *pCmdUI);\r\n\tafx_msg void OnInitMenuPopup(CMenu *pPopupMenu, UINT nIndex,BOOL bSysMenu);\r\n};\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n#endif // !defined(AFX_GROUPTREE_H__A1F01358_5440_45A8_B402_3F32F46FCAA5__INCLUDED_)\r\n"
        },
        {
          "name": "GroupWnd.cpp",
          "type": "blob",
          "size": 4.3701171875,
          "content": "// GroupWnd.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"GroupWnd.h\"\n#include \".\\groupwnd.h\"\n\n\n// CGroupWnd\n#define ID_TRANPARENCY 100\n\nIMPLEMENT_DYNAMIC(CGroupWnd, CMagneticWnd)\nCGroupWnd::CGroupWnd()\n{\n\tm_lSelectedGroup = -1;\n\tm_hwndNotify = NULL;\n}\n\nCGroupWnd::~CGroupWnd()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CGroupWnd, CMagneticWnd)\n\tON_WM_SIZE()\n\tON_WM_CREATE()\n\tON_WM_NCCALCSIZE()\n\tON_WM_NCPAINT()\n\tON_WM_NCHITTEST()\n\tON_WM_NCLBUTTONDOWN()\n\tON_WM_NCLBUTTONUP()\n\tON_WM_NCMOUSEMOVE()\n\tON_COMMAND(ID_BUTTON_REFRESH_GROUP, OnRefresh)\n\tON_COMMAND(ID_BUTTON_PIN, OnPin)\n\tON_COMMAND(ID_BUTTON_NEW_GROUP, OnNewGroup)\n\tON_WM_CLOSE()\n\tON_WM_KEYDOWN()\n\tON_WM_DESTROY()\n\tON_WM_ACTIVATE()\nEND_MESSAGE_MAP()\n\nint CGroupWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)\n{\n\tif (CMagneticWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\n\tm_DittoWindow.DoCreate(this);\n\tm_DittoWindow.m_bDrawChevron = false;\n\tm_DittoWindow.m_bDrawMaximize = false;\n\tm_DittoWindow.m_bDrawMinimize = false;\n\tm_DittoWindow.SetCaptionColors(::GetSysColor(COLOR_ACTIVECAPTION), ::GetSysColor(COLOR_GRADIENTACTIVECAPTION));\n\tm_DittoWindow.SetCaptionOn(this, CAPTION_TOP, true);\n\n\tm_Tree.Create(_T(\"SysTreeView32\"), NULL, WS_BORDER|WS_VISIBLE|WS_CHILD|TVS_HASLINES|TVS_LINESATROOT|TVS_HASBUTTONS, CRect(0,0,0,0), this, 1);\n\n\tm_Tree.SetSelectedGroup(m_lSelectedGroup);\n\tm_Tree.SetNotificationWndEx(m_hwndNotify);\n\n\tm_ToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS);\n\tm_ToolBar.LoadToolBar(IDR_TOOLBAR_GROUP);\n\n\tMoveControls();\n\n\treturn 0;\n}\n\nvoid CGroupWnd::OnSize(UINT nType, int cx, int cy)\n{\n\tCMagneticWnd::OnSize(nType, cx, cy);\n\n\tm_DittoWindow.DoSetRegion(this);\n\n\tMoveControls();\n}\n\nvoid CGroupWnd::MoveControls()\n{\n\tif(::IsWindow(m_Tree.GetSafeHwnd()))\n\t{\n\t\tCRect cr;\n\t\tGetClientRect(cr);\n\n\t\tm_Tree.MoveWindow(cr.left, cr.top, cr.Width(), cr.Height() - 30);\n\t\tm_ToolBar.MoveWindow(cr.left, cr.bottom - 30, 70, 30, TRUE);\n\t}\n}\n\nvoid CGroupWnd::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) \n{\n\tCMagneticWnd::OnNcCalcSize(bCalcValidRects, lpncsp);\n\n\tm_DittoWindow.DoNcCalcSize(bCalcValidRects, lpncsp);\n}\n\nvoid CGroupWnd::OnNcPaint()\n{\n\tm_DittoWindow.DoNcPaint(this);\t\n}\n\nUINT CGroupWnd::OnNcHitTest(CPoint point) \n{\n\tUINT Ret = m_DittoWindow.DoNcHitTest(this, point);\n\tif(Ret == -1)\n\t\treturn CMagneticWnd::OnNcHitTest(point);\n\n\treturn Ret;\n}\nvoid CGroupWnd::OnNcLButtonDown(UINT nHitTest, CPoint point)\n{\n\tm_DittoWindow.DoNcLButtonDown(this, nHitTest, point);\n\n\tCMagneticWnd::OnNcLButtonDown(nHitTest, point);\n}\n\nvoid CGroupWnd::OnNcLButtonUp(UINT nHitTest, CPoint point)\n{\n\tif(m_DittoWindow.DoNcLButtonUp(this, nHitTest, point) > 0)\n\t\treturn;\n\n\tCMagneticWnd::OnNcLButtonUp(nHitTest, point);\n}\n\nvoid CGroupWnd::OnNcMouseMove(UINT nHitTest, CPoint point)\n{\n\tm_DittoWindow.DoNcMouseMove(this, nHitTest, point);\n\n\tCMagneticWnd::OnNcMouseMove(nHitTest, point);\n}\n\nBOOL CGroupWnd::PreTranslateMessage(MSG* pMsg)\n{\n\tm_DittoWindow.DoPreTranslateMessage(pMsg);\n\n\tif(pMsg->message == WM_KEYDOWN && pMsg->hwnd == m_Tree.m_hWnd)\n\t{\n\t\tif(pMsg->wParam == VK_ESCAPE)\n\t\t{\n\t\t\tOnClose();\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn CMagneticWnd::PreTranslateMessage(pMsg);\n}\n\nvoid CGroupWnd::OnRefresh()\n{\n\tm_Tree.SetSelectedGroup(m_Tree.GetSelectedGroup());\n\tm_Tree.FillTree();\n}\n\nvoid CGroupWnd::OnPin()\n{\n\tg_Opt.SetGroupWndPinned(!g_Opt.m_bGroupWndPinned);\n}\n\nvoid CGroupWnd::OnNewGroup()\n{\n\tHTREEITEM hItem = m_Tree.AddNode(\"\", NEW_GROUP_ID);\n\tif(hItem != NULL)\n\t\tm_Tree.EditLabel(hItem);\n}\n\nvoid CGroupWnd::RefreshTree(long lSelectedGroup) \n{ \n\tm_lSelectedGroup = lSelectedGroup; \n\tm_Tree.FillTree(); \n}\nvoid CGroupWnd::OnClose()\n{\n\tShowWindow(SW_HIDE);\n\t::SetFocus(m_hwndNotify);\n}\n\nvoid CGroupWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)\n{\n\tif(nChar == VK_ESCAPE)\n\t{\n\t\tOnClose();\n\t\treturn;\n\t}\n\n\tCMagneticWnd::OnKeyDown(nChar, nRepCnt, nFlags);\n}\n\nvoid CGroupWnd::OnDestroy()\n{\n\tCMagneticWnd::OnDestroy();\n}\n\nvoid CGroupWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) \n{\n\tCWnd::OnActivate(nState, pWndOther, bMinimized);\n\n\tif (nState == WA_INACTIVE)\n\t{\n\t\tHWND hNew = ::GetForegroundWindow();\n\t\tDWORD OtherThreadID = GetWindowThreadProcessId(hNew, NULL);\n\t\tDWORD ThisThreadID = GetWindowThreadProcessId(m_hWnd, NULL);\n\n\t\tif(OtherThreadID != ThisThreadID)\n\t\t{\n\t\t\t::PostMessage(m_hwndNotify, NM_GROUP_TREE_MESSAGE, -1, TRUE);\n\t\t}\n\t\telse if(OtherThreadID == ThisThreadID && g_Opt.m_bGroupWndPinned == false)\n\t\t{\n\t\t\tOnClose();\n\t\t}\n\t}\n}"
        },
        {
          "name": "GroupWnd.h",
          "type": "blob",
          "size": 1.419921875,
          "content": "#pragma once\n\n\n#include \"DittoWindow.h\"\n#include \"GroupTree.h\"\n#include \"MagneticWnd.h\"\n#include \"AlphaBlend.h\"\n\nclass CGroupWnd : public CMagneticWnd\n{\n\tDECLARE_DYNAMIC(CGroupWnd)\n\npublic:\n\tCGroupWnd();\n\tvirtual ~CGroupWnd();\n\nprotected:\n\tCDittoWindow m_DittoWindow;\n\tCGroupTree m_Tree;\n\tlong m_lSelectedGroup;\n\tHWND m_hwndNotify;\n\tCToolBar m_ToolBar;\n\tCSliderCtrl m_Transparency;\n\tCAlphaBlend\tm_Alpha;\n\n\tvoid MoveControls();\n\npublic:\n\tvoid SetNotifyWnd(HWND hWnd)\t\t{ m_hwndNotify = hWnd; m_Tree.SetNotificationWndEx(hWnd); }\n\tvoid SetSelectedGroup(long lGroup)\t{ m_lSelectedGroup = lGroup; }\n\tvoid RefreshTree(long lSelectedGroup);\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\tafx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcPaint();\n\tafx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);\n\tafx_msg UINT OnNcHitTest(CPoint point);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tvoid OnRefresh();\n\tvoid OnPin();\n\tvoid OnNewGroup();\n\tafx_msg void OnClose();\n\tafx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);\n\tafx_msg void OnDestroy();\n\tvoid OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);\n};\n\n\n"
        },
        {
          "name": "HListBox.cpp",
          "type": "blob",
          "size": 1.9130859375,
          "content": "#include \"stdafx.h\"\n#include \"HListBox.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CHListBox\n\nCHListBox::CHListBox()\n{\n width = 0;\n}\n\nCHListBox::~CHListBox()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CHListBox, CListBox)\n\t//{{AFX_MSG_MAP(CHListBox)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CHListBox message handlers\nvoid CHListBox::updateWidth(LPCTSTR s)\n    {\n     CClientDC dc(this);\n     CFont * f = CListBox::GetFont();\n     dc.SelectObject(f);\n     CSize sz = dc.GetTextExtent(s, (int)_tcslen(s));\n     sz.cx += 3 * ::GetSystemMetrics(SM_CXBORDER);\n     if(sz.cx > width)\n\t { /* extend */\n\t  width = sz.cx;\n\t  CListBox::SetHorizontalExtent(width);\n\t } /* extend */\n    }\n\nint CHListBox::AddString(LPCTSTR s)\n    {\n     int result = CListBox::AddString(s);\n     if(result < 0)\n\t return result;\n     updateWidth(s);\n     return result;\n    }\n\nint CHListBox::InsertString(int i, LPCTSTR s)\n    {\n     int result = CListBox::InsertString(i, s);\n     if(result < 0)\n\t return result;\n     updateWidth(s);\n     return result;\n    }\n\nvoid CHListBox::ResetContent()\n    {\n     CListBox::ResetContent();\n     width = 0;\n    }\n\nint CHListBox::DeleteString(int n)\n    {\n     int result = CListBox::DeleteString(n);\n     if(result < 0)\n\t return result;\n     CClientDC dc(this);\n\n     CFont * f = CListBox::GetFont();\n     dc.SelectObject(f);\n\n     width = 0;\n     for(int i = 0; i < CListBox::GetCount(); i++)\n\t { /* scan strings */\n\t  CString s;\n\t  CListBox::GetText(i, s);\n\t  CSize sz = dc.GetTextExtent(s);\n          sz.cx += 3 * ::GetSystemMetrics(SM_CXBORDER);\n\t  if(sz.cx > width)\n\t      width = sz.cx;\n\t } /* scan strings */\n     CListBox::SetHorizontalExtent(width);\n     return result;\n    }\n"
        },
        {
          "name": "HListBox.h",
          "type": "blob",
          "size": 1.23828125,
          "content": "#if !defined(AFX_HLISTBOX_H__346C3917_14BC_11D5_A025_006067718D04__INCLUDED_)\n#define AFX_HLISTBOX_H__346C3917_14BC_11D5_A025_006067718D04__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// HListBox.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CHListBox window\n\nclass CHListBox : public CListBox\n{\n// Construction\npublic:\n\tCHListBox();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n    int AddString(LPCTSTR s);\n    int InsertString(int i, LPCTSTR s);\n    void ResetContent();\n    int DeleteString(int i);\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CHListBox)\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~CHListBox();\n\n\t// Generated message map functions\nprotected:\n        void updateWidth(LPCTSTR s);\n\tint width;\n\t//{{AFX_MSG(CHListBox)\n\t\t// NOTE - the ClassWizard will add and remove member functions here.\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_HLISTBOX_H__346C3917_14BC_11D5_A025_006067718D04__INCLUDED_)\n"
        },
        {
          "name": "HTMLFormatAggregator.cpp",
          "type": "blob",
          "size": 4.9306640625,
          "content": "#include \"stdafx.h\"\n#include \".\\htmlformataggregator.h\"\n#include \"Misc.h\"\n#include \"shared/Tokenizer.h\"\n\nCHTMLFormatAggregator::CHTMLFormatAggregator(CStringA csSepator) :\n\tm_csSeparator(csSepator)\n{\n\t//Remove the first line feed\n//\tif(m_csSeparator.GetLength() > 1 && m_csSeparator[0] == '\\r' && m_csSeparator[1] == '\\n')\n//\t{\n//\t\tm_csSeparator.Delete(0);\n//\t\tm_csSeparator.Delete(0);\n//\t}\n\n\tm_csSeparator.Replace(\"\\r\\n\", \"<br>\");\n}\n\nCHTMLFormatAggregator::~CHTMLFormatAggregator(void)\n{\n}\n\nbool CHTMLFormatAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tLPSTR pText = (LPSTR)lpData;\n\tif(pText == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\t//Ensure it's null terminated\n\tif(pText[nDataSize-1] != '\\0')\n\t{\n\t\tpText[nDataSize-1] = NULL;\n\t}\n\n\tCHTMFormatStruct HtmlData;\n\tif(HtmlData.GetData(pText))\n\t{\n\t\tm_csNewText += HtmlData.GetFragment();\n\n\t\tif(m_csSourceURL.IsEmpty())\n\t\t\tm_csSourceURL = HtmlData.GetURL();\n\t\tif(m_csVersion.IsEmpty())\n\t\t\tm_csVersion = HtmlData.GetVersion();\n\n\t\tif(nPos != nCount-1)\n\t\t{\n\t\t\tm_csNewText += m_csSeparator;\n\t\t}\n\t}\t\n\n\treturn true;\n}\n\nHGLOBAL CHTMLFormatAggregator::GetHGlobal()\n{\n\tCHTMFormatStruct HtmlData;\n\tHtmlData.SetFragment(m_csNewText);\n\tHtmlData.SetURL(m_csSourceURL);\n\tHtmlData.SetVersion(m_csVersion);\n\n\tCStringA csHtmlFormat;\n\tHtmlData.Serialize(csHtmlFormat);\n\n\tlong lLen = csHtmlFormat.GetLength();\n\tHGLOBAL hGlobal = NewGlobalP(csHtmlFormat.GetBuffer(lLen), lLen+sizeof(char));\n\tcsHtmlFormat.ReleaseBuffer();\n\n\treturn hGlobal;\n}\n\nbool CHTMFormatStruct::GetData(LPCSTR HTML)\n{\n\tCTokenizer Tokenizer(HTML, \"\\r\\n\");\n\tCString Token;\n\twhile(Tokenizer.Next(Token))\n\t{\n\t\tCTokenizer ItemTokenizer(Token, \":\");\n\t\tCString csParam;\n\t\tItemTokenizer.Next(csParam);\n\t\tCString csValue = ItemTokenizer.Tail();\n\n\t\tif(csParam == \"Version\")\n\t\t{\n\t\t\tm_csVersion = csValue;\n\t\t}\n\t\telse if(csParam == \"StartHTML\")\n\t\t{\n\t\t\tm_lStartHTML = ATOI(csValue);\n\t\t}\n\t\telse if(csParam == \"EndHTML\")\n\t\t{\n\t\t\tm_lEndHTML = ATOI(csValue);\n\t\t}\n\t\telse if(csParam == \"StartFragment\")\n\t\t{\n\t\t\tm_lStartFragment = ATOI(csValue);\n\t\t}\n\t\telse if(csParam == \"EndFragment\")\n\t\t{\n\t\t\tm_lEndFragment = ATOI(csValue);\n\t\t}\n\t\telse if(csParam == \"SourceURL\")\n\t\t{\n\t\t\tm_csSourceURL = csValue;\n\t\t\tbreak;\n\t\t}\n\t\telse if(csParam.Left(5) == \"<html\")\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(m_lStartFragment >= 0 && m_lEndFragment >= 0 && m_lStartFragment < m_lEndFragment)\n\t{\n\t\tm_csFragment = Tokenizer.m_cs.Mid(m_lStartFragment, m_lEndFragment-m_lStartFragment);\n\t\tm_csFragment = m_csFragment.Trim();\n\t}\n\n\tif(m_csFragment.IsEmpty())\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool CHTMFormatStruct::Serialize(CStringA &csHTMLFormat)\n{\n\t//Build a structure just like this\n// Version:0.9\n// StartHTML:00000244\n// EndHTML:00000338\n// StartFragment:00000278\n// StartFragment:00000302\n// SourceURL:http://www.google.com/search?hl=en&client=firefox-a&channel=s&rls=org.mozilla%3Aen-US%3Aofficial&hs=oIx&q=c%2B%2B+interface&btnG=Search\n// <html><body>\n// <!--StartFragment--><font size=\"-1\">e</font><!--EndFragment-->\n// </body>\n// </html>\n\n\n\tCStringA csVersionText(\"Version:\");\n\tCStringA csStartHTMLText(\"StartHTML:\");\n\tCStringA csEndHTMLText(\"EndHTML:\");\n\tCStringA csStartFragmentText(\"StartFragment:\");\n\tCStringA csEndFragmentText(\"EndFragment:\");\n\tCStringA csSourceURLText(\"SourceURL:\");\n\tCStringA csStartFragmentMarkerText(\"<!--StartFragment-->\");\n\tCStringA csEndFragmentMarkerText(\"<!--EndFragment-->\");\n\tCStringA csStartHTML(\"<html><body>\");\n\tCStringA csEndHTML(\"</body>\\r\\n</html>\");\n\tlong lNumberCharacters = 8;\n\n\t//+2 is for the line feeds\n\n\tlong lCurrentPos = csVersionText.GetLength() + m_csVersion.GetLength() + 2 +\n\t\t\t\t\t\tcsStartHTMLText.GetLength() + lNumberCharacters + 2 +\n\t\t\t\t\t\tcsEndHTMLText.GetLength() + lNumberCharacters + 2 +\n\t\t\t\t\t\tcsStartFragmentText.GetLength() + lNumberCharacters + 2 +\n\t\t\t\t\t\tcsEndFragmentText.GetLength() + lNumberCharacters + 2 +\n\t\t\t\t\t\tcsSourceURLText.GetLength() + m_csSourceURL.GetLength() + 2;\n\n\tm_lStartHTML = lCurrentPos;\n\n\tlCurrentPos += csStartHTMLText.GetLength() + 2 + \n\t\t\t\t\tcsStartFragmentMarkerText.GetLength() + 2;\n\tm_lStartFragment = lCurrentPos;\n\n\tlCurrentPos += m_csFragment.GetLength();\n\tm_lEndFragment = lCurrentPos;\n\n\tlCurrentPos += csEndFragmentMarkerText.GetLength() + 2 +\n\t\t\t\t\tcsEndHTML.GetLength();\n\tm_lEndHTML = lCurrentPos;\n\n\n\tcsHTMLFormat = csVersionText + m_csVersion + \"\\r\\n\";\n\n\tCStringA csFormat;\n\tcsFormat.Format(\"%s%08d\\r\\n\", csStartHTMLText, m_lStartHTML);\n\tcsHTMLFormat += csFormat;\n\n\tcsFormat.Format(\"%s%08d\\r\\n\", csEndHTMLText, m_lEndHTML);\n\tcsHTMLFormat += csFormat;\n\n\tcsFormat.Format(\"%s%08d\\r\\n\", csStartFragmentText, m_lStartFragment);\n\tcsHTMLFormat += csFormat;\n\n\tcsFormat.Format(\"%s%08d\\r\\n\", csEndFragmentText, m_lEndFragment);\n\tcsHTMLFormat += csFormat;\n\n\tcsFormat.Format(\"%s%s\\r\\n\", csSourceURLText, m_csSourceURL);\n\tcsHTMLFormat += csFormat;\n\n\tcsFormat.Format(\"%s\\r\\n%s\", csStartHTML, csStartFragmentMarkerText);\n\tcsHTMLFormat += csFormat;\n\n\tcsHTMLFormat += m_csFragment;\n\n\tcsFormat.Format(\"%s\\r\\n%s\", csEndFragmentMarkerText, csEndHTML);\n\tcsHTMLFormat += csFormat;\n\n\treturn true;\n}"
        },
        {
          "name": "HTMLFormatAggregator.h",
          "type": "blob",
          "size": 1.1142578125,
          "content": "#pragma once\n#include \"IClipAggregator.h\"\n\nclass CHTMLFormatAggregator : public IClipAggregator\n{\npublic:\n\tCHTMLFormatAggregator(CStringA csSepator);\n\t~CHTMLFormatAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\nprotected:\n\tCStringA m_csSeparator;\n\tCStringA m_csNewText;\n\tCStringA m_csSourceURL;\n\tCStringA m_csVersion;\n};\n\nclass CHTMFormatStruct\n{\npublic:\n\tCHTMFormatStruct()\n\t{\n\t\tm_lStartHTML = 0;\n\t\tm_lEndHTML = 0;\n\t\tm_lStartFragment = 0;\n\t\tm_lEndFragment = 0;\n\t}\n\n\tbool GetData(LPCSTR HTML);\n\tbool Serialize(CStringA &csHTMLFormat);\n\n\tconst CStringA &GetFragment() { return m_csFragment; }\n\tconst CStringA &GetURL()\t  { return m_csSourceURL; }\n\tconst CStringA &GetVersion()  { return m_csVersion; }\n\n\tvoid SetFragment(const CStringA &cs){ m_csFragment = cs; }\n\tvoid SetURL(const CStringA &cs)\t\t{ m_csSourceURL = cs; }\n\tvoid SetVersion(const CStringA &cs)\t{ m_csVersion = cs; }\n\nprotected:\n\tCStringA m_csVersion;\n\tlong m_lStartHTML;\n\tlong m_lEndHTML;\n\tlong m_lStartFragment;\n\tlong m_lEndFragment;\n\tCStringA m_csSourceURL;\n\tCStringA m_csFragment;\n};\n"
        },
        {
          "name": "Help",
          "type": "tree",
          "content": null
        },
        {
          "name": "HotKeys.cpp",
          "type": "blob",
          "size": 8.6162109375,
          "content": "#include \"stdafx.h\"\n#include \"HotKeys.h\"\n#include \"Options.h\"\n#include \"Misc.h\"\n#include \"SendKeys.h\"\n#include \"Accels.h\"\n\nCHotKeys g_HotKeys;\n\nint CHotKey::m_nextId = 0;\n\nCHotKey::CHotKey(CString name, DWORD defKey, bool bUnregOnShowDitto, HotKeyType hkType, CString description) \n\t: m_Name(name), \n\tm_description(description),\n\tm_bIsRegistered(false), \n\tm_bUnRegisterOnShowDitto(bUnregOnShowDitto),\n\tm_clipId(0)\n{\n\tm_Atom = ::GlobalAddAtom(StrF(_T(\"%s_%d\"), m_Name, hkType));\n\tASSERT(m_Atom);\n\tm_Key = (DWORD)CGetSetOptions::GetProfileLong(m_Name, (long) defKey);\n\tm_globalId = m_nextId;\n\tm_nextId++;\n\tm_hkType = hkType;\n\tg_HotKeys.Add(this);\n}\n\nCHotKey::~CHotKey()\n{\n\tUnregister();\n\t::GlobalDeleteAtom(m_Atom);\n}\n\nCString CHotKey::GetHotKeyDisplay()\n{\n\treturn GetHotKeyDisplayStatic(m_Key);\n}\n\nCString CHotKey::GetHotKeyDisplayStatic(DWORD dwHotKey)\n{\n\tWORD vk = LOBYTE(dwHotKey);\n\tCString keyDisplay;\n\tUINT modifiers = GetModifier(HIBYTE(dwHotKey));\n\tif(modifiers & MOD_SHIFT)\n\t{\n\t\tkeyDisplay += _T(\"Shift + \");\n\t}\n\n\tif(modifiers & MOD_CONTROL)\n\t{\n\t\tkeyDisplay += _T(\"Ctrl + \");\n\t}\n\n\tif(modifiers & MOD_ALT)\n\t{\n\t\tkeyDisplay += _T(\"Alt + \");\n\t}\n\n\tif(modifiers & MOD_WIN)\n\t{\n\t\tkeyDisplay += _T(\"Win + \");\n\t}\n\n\tswitch (vk)\n\t{\n\tcase VK_MOUSE_CLICK:\n\t\tkeyDisplay += \"Click\";\n\t\tbreak;\n\tcase VK_MOUSE_DOUBLE_CLICK:\n\t\tkeyDisplay += \"Double Click\";\n\t\tbreak;\n\tcase VK_MOUSE_RIGHT_CLICK:\n\t\tkeyDisplay += \"Right Click\";\n\t\tbreak;\n\tcase VK_MOUSE_MIDDLE_CLICK:\n\t\tkeyDisplay += \"Middle Click\";\n\t\tbreak;\n\tdefault:\n\t\tkeyDisplay += GetVirKeyName(vk);\n\t\tbreak;\n\t}\t\n\n\treturn keyDisplay;\n}\n\n//http://www.ffuts.org/blog/mapvirtualkey-getkeynametext-and-a-story-of-how-to/\nCString CHotKey::GetVirKeyName(unsigned int virtualKey)\n{\n\tunsigned int scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);\n\n\t// because MapVirtualKey strips the extended bit for some keys\n\tswitch (virtualKey)\n\t{\n\tcase VK_LEFT: \n\tcase VK_UP: \n\tcase VK_RIGHT: \n\tcase VK_DOWN: // arrow keys\n\tcase VK_PRIOR: \n\tcase VK_NEXT: // page up and page down\n\tcase VK_END: \n\tcase VK_HOME:\n\tcase VK_INSERT: \n\tcase VK_DELETE:\n\tcase VK_DIVIDE: // numpad slash\n\tcase VK_NUMLOCK:\n\t\t{\n\t\t\tscanCode |= 0x100; // set extended bit\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twchar_t keyName[50];\n\tif (GetKeyNameText(scanCode << 16, keyName, sizeof(keyName)) != 0)\n\t{\n\t\treturn keyName;\n\t}\n\telse\n\t{\n\t\treturn \"[Error]\";\n\t}\n}\n\nUINT CHotKey::GetModifier(DWORD dwHotKey)\n{\n\tUINT uMod = 0;\n\n\tif(dwHotKey & HOTKEYF_SHIFT)   \n\t\tuMod |= MOD_SHIFT;\n\tif(dwHotKey & HOTKEYF_CONTROL) \n\t\tuMod |= MOD_CONTROL;\n\tif(dwHotKey & HOTKEYF_ALT)     \n\t\tuMod |= MOD_ALT;\n\tif(dwHotKey & HOTKEYF_EXT)     \n\t\tuMod |= MOD_WIN;\n\n\treturn uMod;\n}\n\nvoid CHotKey::SetKey( DWORD key, bool bSave )\n{\n\tif(m_Key == key)\n\t{\n\t\treturn;\n\t}\n\n\tif(m_bIsRegistered)\n\t\tUnregister();\n\tm_Key = key;\n\tif(bSave)\n\t\tSaveKey();\n}\n\nvoid CHotKey::LoadKey()\n{\n\tSetKey((DWORD) CGetSetOptions::GetProfileLong(m_Name, 0));\n}\n\nbool CHotKey::SaveKey()\n{\n\tif(m_clipId <= 0)\n\t{\n\t\treturn CGetSetOptions::SetProfileLong( m_Name, (long) m_Key ) != FALSE;\n\t}\n\n\n\treturn false;\n}\n\nBOOL CHotKey::ValidateHotKey(DWORD dwHotKey)\n{\n\tATOM id = ::GlobalAddAtom(_T(\"HK_VALIDATE\"));\n\tBOOL bResult = ::RegisterHotKey( g_HotKeys.m_hWnd,\n\t\tid,\n\t\tGetModifier(HIBYTE(dwHotKey)),\n\t\tLOBYTE(dwHotKey) );\n\n\tif(bResult)\n\t\t::UnregisterHotKey(g_HotKeys.m_hWnd, id);\n\n\t::GlobalDeleteAtom(id);\n\n\treturn bResult;\n}\n\nvoid CHotKey::CopyFromCtrl(CHotKeyCtrl& ctrl, HWND hParent, int nWindowsCBID) \n{ \n\tlong lHotKey = ctrl.GetHotKey();\n\n\tshort sKeyKode = LOBYTE(lHotKey);\n\tshort sModifers = ((HIBYTE(lHotKey)) & ~HOTKEYF_EXT);\n\n\tif(lHotKey && ::IsDlgButtonChecked(hParent, nWindowsCBID))\n\t{\n\t\tsModifers |= HOTKEYF_EXT;\n\t}\n\n\tSetKey(MAKEWORD(sKeyKode, sModifers)); \n}\n\nvoid CHotKey::CopyToCtrl(CHotKeyCtrl& ctrl, HWND hParent, int nWindowsCBID)\n{\n\tDWORD shortcut = ACCEL_MAKEKEY(LOBYTE(m_Key), ((HIBYTE(m_Key)) &~HOTKEYF_EXT));\n\n\tswitch (LOBYTE(shortcut))\n\t{\n\t\tcase VK_LEFT:\n\t\tcase VK_UP:\n\t\tcase VK_RIGHT:\n\t\tcase VK_DOWN: // arrow keys\n\t\tcase VK_PRIOR:\n\t\tcase VK_NEXT: // page up and page down\n\t\tcase VK_END:\n\t\tcase VK_HOME:\n\t\tcase VK_INSERT:\n\t\tcase VK_DELETE:\n\t\tcase VK_DIVIDE: // numpad slash\n\t\tcase VK_NUMLOCK:\n\t\t{\n\t\t\tshortcut = ACCEL_MAKEKEY(LOBYTE(shortcut), (HIBYTE(shortcut) | HOTKEYF_EXT));\n\t\t}\n\t\tbreak;\n\t}\n\n\tlong lModifiers = HIBYTE(shortcut);\n\tlong keys = LOBYTE(shortcut);\n\n\tctrl.SetHotKey((WORD)keys, (WORD)lModifiers); \n\n\tlong originalModifiers = HIBYTE(m_Key);\n\tif(originalModifiers & HOTKEYF_EXT)\n\t{\n\t\t::CheckDlgButton(hParent, nWindowsCBID, BST_CHECKED);\n\t}\n}\n\nbool CHotKey::Register()\n{\n\tif(m_Key)\n\t{\n\t\tif(m_bIsRegistered == false)\n\t\t{\n\t\t\tASSERT(g_HotKeys.m_hWnd);\n\t\t\tm_bIsRegistered = ::RegisterHotKey(g_HotKeys.m_hWnd,\n\t\t\t\tm_Atom,\n\t\t\t\tGetModifier(),\n\t\t\t\tLOBYTE(m_Key) ) == TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_bIsRegistered = false;\n\t}\n\n\treturn m_bIsRegistered;\n}\nbool CHotKey::Unregister(bool bOnShowingDitto)\n{\n\tif(!m_bIsRegistered)\n\t\treturn true;\n\n\tif(bOnShowingDitto)\n\t{\n\t\tif(m_bUnRegisterOnShowDitto == false)\n\t\t\treturn true;\n\t}\n\n\tif(m_Key)\n\t{\n\t\tASSERT(g_HotKeys.m_hWnd);\n\t\tif(::UnregisterHotKey( g_HotKeys.m_hWnd, m_Atom))\n\t\t{\n\t\t\tm_bIsRegistered = false;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog(_T(\"Unregister FAILED!\"));\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_bIsRegistered = false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nCHotKeys::CHotKeys() : m_hWnd(NULL) \n{\n\n}\n\nCHotKeys::~CHotKeys()\n{\n\tCHotKey* pHotKey;\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tpHotKey = ElementAt(i);\n\t\tif(pHotKey)\n\t\t{\n\t\t\tdelete pHotKey;\n\t\t}\n\t}\n}\n\nINT_PTR CHotKeys::Find(CHotKey* pHotKey)\n{\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tif(pHotKey == ElementAt(i))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nbool CHotKeys::Remove(CHotKey* pHotKey)\n{\n\tINT_PTR i = Find(pHotKey);\n\tif(i >= 0)\n\t{\n\t\tRemoveAt(i);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool CHotKeys::Remove(int clipId, CHotKey::HotKeyType hkType)\n{\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tif(ElementAt(i) != NULL && \n\t\t\tElementAt(i)->m_clipId == clipId &&\n\t\t\tElementAt(i)->m_hkType == hkType)\n\t\t{\n\t\t\tCHotKey *pKey = ElementAt(i);\n\n\t\t\tRemoveAt(i);\n\n\t\t\tdelete pKey;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nBOOL CHotKeys::ValidateClip(int clipId, DWORD key, CString desc, CHotKey::HotKeyType hkType)\n{\n\tCHotKey *pKey = NULL;\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tif(ElementAt(i) != NULL && \n\t\t\tElementAt(i)->m_clipId == clipId &&\n\t\t\tElementAt(i)->m_hkType == hkType)\n\t\t{\n\t\t\tpKey = ElementAt(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(pKey == NULL)\n\t{\n\t\tpKey = new CHotKey(desc, key, true, hkType);\n\t}\n\t   \n\tBOOL ret = FALSE;\n\n\tif(pKey != NULL)\n\t{\n\t\tpKey->m_Key = key;\n\t\tpKey->m_Name = desc;\n\t\tpKey->m_clipId = clipId;\n\n\t\tret = CHotKey::ValidateHotKey(key);\n\t}\n\n\treturn ret;\n}\n\nvoid CHotKeys::LoadAllKeys()\n{\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tElementAt(i)->LoadKey();\n\t}\n}\n\nvoid CHotKeys::SaveAllKeys()\n{\n\tINT_PTR count = GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tElementAt(i)->SaveKey();\n\t}\n}\n\nvoid CHotKeys::RegisterAll(bool bMsgOnError)\n{\n\tCString str;\n\tCHotKey* pHotKey;\n\tINT_PTR count = GetSize();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tpHotKey = ElementAt(i);\n\t\tif(!pHotKey->Register() && pHotKey->m_Key > 0)\n\t\t{\n\t\t\tstr =  \"Error Registering \";\n\t\t\tstr += pHotKey->GetName();\n\t\t\tLog(str);\n\t\t\tif(bMsgOnError)\n\t\t\t\tAfxMessageBox(str);\n\t\t}\n\t}\n}\n\nvoid CHotKeys::UnregisterAll(bool bMsgOnError, bool bOnShowDitto)\n{\n\tCString str;\n\tCHotKey* pHotKey;\n\tINT_PTR count = GetSize();\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tpHotKey = ElementAt(i);\n\t\tif(!pHotKey->Unregister(bOnShowDitto))\n\t\t{\n\t\t\tstr = \"Error Unregistering \";\n\t\t\tstr += pHotKey->GetName();\n\t\t\tLog(str);\n\t\t\tif(bMsgOnError)\n\t\t\t\tAfxMessageBox(str);\n\t\t}\n\t}\n}\n\nvoid CHotKeys::GetKeys(ARRAY& keys)\n{\n\tINT_PTR count = GetSize();\n\tkeys.SetSize(count);\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tkeys[i] = ElementAt(i)->GetKey();\n\t}\n}\n\n// caution! this alters hotkeys based upon corresponding indexes\nvoid CHotKeys::SetKeys(ARRAY& keys, bool bSave)\n{\n\tINT_PTR count = GetSize();\n\tASSERT(count == keys.GetSize());\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tElementAt(i)->SetKey(keys[(INT)i], bSave);\n\t}\n}\n\nbool CHotKeys::FindFirstConflict(ARRAY& keys, INT_PTR* pX, INT_PTR* pY)\n{\n\tbool bConflict = false;\n\tINT_PTR i, j;\n\tINT_PTR count = keys.GetSize();\n\tDWORD key;\n\tfor(i = 0; i < count && !bConflict; i++)\n\t{\n\t\tkey = keys.ElementAt(i);\n\t\t// only check valid keys\n\t\tif(key == 0)\n\t\t\tcontinue;\n\n\t\t// scan the array for a duplicate\n\t\tfor(j = i+1; j < count; j++ )\n\t\t{\n\t\t\tif(keys.ElementAt(j) == key)\n\t\t\t{\n\t\t\t\tbConflict = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(bConflict)\n\t{\n\t\tif(pX)\n\t\t\t*pX = i-1;\n\t\tif(pY)\n\t\t\t*pY = j;\n\t}\n\n\treturn bConflict;\n}\n\n// if true, pX and pY (if valid) are set to the indexes of the conflicting hotkeys.\nbool CHotKeys::FindFirstConflict(INT_PTR* pX, INT_PTR* pY)\n{\n\tARRAY keys;\n\tGetKeys(keys);\n\treturn FindFirstConflict(keys, pX, pY);\n}\n"
        },
        {
          "name": "HotKeys.h",
          "type": "blob",
          "size": 2.3505859375,
          "content": "#pragma once\n\n#include \"Shared/ArrayEx.h\"\n\nclass CHotKey\n{\npublic:\n\tenum HotKeyType\n\t{ \n\t\tPASTE_OPEN_CLIP,\n\t\tMOVE_TO_GROUP\n\t};\n\n\tCString\tm_Name;\n\tCString m_description;\n\tATOM\tm_Atom;\n\tDWORD\tm_Key; //704 is ctrl-tilda\n\tbool\tm_bIsRegistered;\n\tbool\tm_bUnRegisterOnShowDitto;\n\tint\t\tm_clipId;\n\tint\t\tm_globalId;\n\tHotKeyType m_hkType;\n\tstatic int m_nextId;\n\t\n\tCHotKey( CString name, DWORD defKey = 0, bool bUnregOnShowDitto = false, HotKeyType hkType = PASTE_OPEN_CLIP, CString description = _T(\"\"));\n\t~CHotKey();\n\n\tbool\tIsRegistered() { return m_bIsRegistered; }\n\tCString GetName()      { return m_Name; }\n\tDWORD   GetKey()       { return m_Key; }\n\tCString GetHotKeyDisplay();\n\t\n\tvoid SetKey( DWORD key, bool bSave = false );\n\t// profile\n\tvoid LoadKey();\n\tbool SaveKey();\n\n\tvoid CopyFromCtrl(CHotKeyCtrl& ctrl, HWND hParent, int nWindowsCBID);\n\tvoid CopyToCtrl(CHotKeyCtrl& ctrl, HWND hParent, int nWindowsCBID);\n\n\tUINT GetModifier() { return GetModifier(HIBYTE(m_Key)); }\n\n\tbool Register();\n\tbool Unregister(bool bOnShowingDitto = false);\n\n\tstatic BOOL ValidateHotKey(DWORD dwHotKey);\n\tstatic UINT GetModifier(DWORD dwHotKey);\n\tstatic CString GetHotKeyDisplayStatic(DWORD dwHotKey);\n\tstatic CString GetVirKeyName(unsigned int virtualKey);\n};\n\n\n/*------------------------------------------------------------------*\\\n\tCHotKeys - Manages system-wide hotkeys\n\\*------------------------------------------------------------------*/\n\nclass CHotKeys : public CArray<CHotKey*,CHotKey*>\n{\npublic:\n\tHWND\tm_hWnd;\n\n\tCHotKeys();\n\t~CHotKeys();\n\n\tvoid Init( HWND hWnd ) { m_hWnd = hWnd; }\n\n\tINT_PTR Find( CHotKey* pHotKey );\n\tbool Remove( CHotKey* pHotKey ); // pHotKey is NOT deleted.\n\n\tbool Remove(int clipId, CHotKey::HotKeyType hkType);\n\n\tBOOL ValidateClip(int clipId, DWORD key, CString desc, CHotKey::HotKeyType hkType);\n\n\t// profile load / save\n\tvoid LoadAllKeys();\n\tvoid SaveAllKeys();\n\n\tvoid RegisterAll(bool bMsgOnError = false);\n\tvoid UnregisterAll(bool bMsgOnError = false, bool bOnShowDitto = false);\n\n\tvoid GetKeys( ARRAY& keys );\n\tvoid SetKeys( ARRAY& keys, bool bSave = false ); // caution! this alters hotkeys based upon corresponding indexes\n\n\tstatic bool FindFirstConflict( ARRAY& keys, INT_PTR* pX = NULL, INT_PTR* pY = NULL );\n\t// if true, pX and pY (if valid) are set to the index of the conflicting hotkeys.\n\tbool FindFirstConflict( INT_PTR* pX = NULL, INT_PTR* pY = NULL );\n};\n\nextern CHotKeys g_HotKeys;"
        },
        {
          "name": "HyperLink.cpp",
          "type": "blob",
          "size": 12.4375,
          "content": "// HyperLink.cpp : implementation file\n//\n// HyperLink static control. Will open the default browser with the given URL\n// when the user clicks on the link.\n//\n// Copyright (C) 1997, 1998 Chris Maunder\n// All rights reserved. May not be sold for profit.\n//\n// Thanks to Pl K. Tnder for auto-size and window caption changes.\n//\n// \"GotoURL\" function by Stuart Patterson\n// As seen in the August, 1997 Windows Developer's Journal.\n// Copyright 1997 by Miller Freeman, Inc. All rights reserved.\n// Modified by Chris Maunder to use TCHARs instead of chars.\n//\n// \"Default hand cursor\" from Paul DiLascia's Jan 1998 MSJ article.\n//\n\n#include \"stdafx.h\"\n#include \"HyperLink.h\"\n#include \"shared/TextConvert.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define TOOLTIP_ID 1\n\n/////////////////////////////////////////////////////////////////////////////\n// CHyperLink\n\nCHyperLink::CHyperLink()\n{\n    m_hLinkCursor       = NULL;                 // No cursor as yet\n    m_crLinkColour      = RGB(  0,   0, 238);   // Blue\n    m_crVisitedColour   = RGB( 85,  26, 139);   // Purple\n    m_crHoverColour     = ::GetSysColor(COLOR_HIGHLIGHT);\n    m_bOverControl      = FALSE;                // Cursor not yet over control\n    m_bVisited          = FALSE;                // Hasn't been visited yet.\n    m_bUnderline        = TRUE;                 // Underline the link?\n    m_bAdjustToFit      = TRUE;                 // Resize the window to fit the text?\n    m_strURL.Empty();\n}\n\nCHyperLink::~CHyperLink()\n{\n    m_Font.DeleteObject();\n}\n\nBEGIN_MESSAGE_MAP(CHyperLink, CStatic)\n    //{{AFX_MSG_MAP(CHyperLink)\n    ON_CONTROL_REFLECT(STN_CLICKED, OnClicked)\n    ON_WM_CTLCOLOR_REFLECT()\n    ON_WM_SETCURSOR()\n    ON_WM_MOUSEMOVE()\n    //}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CHyperLink message handlers\n\nBOOL CHyperLink::PreTranslateMessage(MSG* pMsg) \n{\n    m_ToolTip.RelayEvent(pMsg);\n    return CStatic::PreTranslateMessage(pMsg);\n}\n\nvoid CHyperLink::OnClicked()\n{\n    int result = (int)GotoURL(m_strURL, SW_SHOW);\n    m_bVisited = (result > HINSTANCE_ERROR);\n    if (!m_bVisited) {\n        MessageBeep(MB_ICONEXCLAMATION);     // Unable to follow link\n        ReportError(result);\n    } else \n        SetVisited();                        // Repaint to show visited colour\n}\n\nHBRUSH CHyperLink::CtlColor(CDC* pDC, UINT nCtlColor) \n{\n    ASSERT(nCtlColor == CTLCOLOR_STATIC);\n\n    if (m_bOverControl)\n        pDC->SetTextColor(m_crHoverColour);\n    else if (m_bVisited)\n        pDC->SetTextColor(m_crVisitedColour);\n    else\n        pDC->SetTextColor(m_crLinkColour);\n\n    // transparent text.\n    pDC->SetBkMode(TRANSPARENT);\n    return (HBRUSH)GetStockObject(NULL_BRUSH);\n}\n\nvoid CHyperLink::OnMouseMove(UINT nFlags, CPoint point) \n{\n    CStatic::OnMouseMove(nFlags, point);\n\n    if (m_bOverControl)        // Cursor is currently over control\n    {\n        CRect rect;\n        GetClientRect(rect);\n\n        if (!rect.PtInRect(point))\n        {\n            m_bOverControl = FALSE;\n            ReleaseCapture();\n            RedrawWindow();\n            return;\n        }\n    }\n    else                      // Cursor has just moved over control\n    {\n        m_bOverControl = TRUE;\n        RedrawWindow();\n        SetCapture();\n    }\n}\n\nBOOL CHyperLink::OnSetCursor(CWnd* /*pWnd*/, UINT /*nHitTest*/, UINT /*message*/) \n{\n    if (m_hLinkCursor)\n    {\n        ::SetCursor(m_hLinkCursor);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nvoid CHyperLink::PreSubclassWindow() \n{\n    // We want to get mouse clicks via STN_CLICKED\n    DWORD dwStyle = GetStyle();\n    ::SetWindowLong(GetSafeHwnd(), GWL_STYLE, dwStyle | SS_NOTIFY);\n    \n    // Set the URL as the window text\n    if (m_strURL.IsEmpty())\n        GetWindowText(m_strURL);\n\n    // Check that the window text isn't empty. If it is, set it as the URL.\n    CString strWndText;\n    GetWindowText(strWndText);\n    if (strWndText.IsEmpty()) {\n        ASSERT(!m_strURL.IsEmpty());    // Window and URL both NULL. DUH!\n        SetWindowText(m_strURL);\n    }\n\n    // Create the font\n    LOGFONT lf;\n    GetFont()->GetLogFont(&lf);\n    lf.lfUnderline = m_bUnderline;\n    m_Font.CreateFontIndirect(&lf);\n    SetFont(&m_Font);\n\n    PositionWindow();        // Adjust size of window to fit URL if necessary\n    SetDefaultCursor();      // Try and load up a \"hand\" cursor\n\n    // Create the tooltip\n    CRect rect; \n    GetClientRect(rect);\n    m_ToolTip.Create(this);\n    m_ToolTip.AddTool(this, m_strURL, rect, TOOLTIP_ID);\n\n    CStatic::PreSubclassWindow();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CHyperLink operations\n\nvoid CHyperLink::SetURL(CString strURL)\n{\n    m_strURL = strURL;\n\n    if (::IsWindow(GetSafeHwnd())) {\n        PositionWindow();\n        m_ToolTip.UpdateTipText(strURL, this, TOOLTIP_ID);\n    }\n}\n\nCString CHyperLink::GetURL() const\n{ \n    return m_strURL;   \n}\n\nvoid CHyperLink::SetColours(COLORREF crLinkColour, COLORREF crVisitedColour,\n                            COLORREF crHoverColour /* = -1 */) \n{ \n    m_crLinkColour    = crLinkColour; \n    m_crVisitedColour = crVisitedColour;\n\n\tif (crHoverColour == -1)\n\t\tm_crHoverColour = ::GetSysColor(COLOR_HIGHLIGHT);\n\telse\n\t\tm_crHoverColour = crHoverColour;\n\n    if (::IsWindow(m_hWnd))\n        Invalidate(); \n}\n\nCOLORREF CHyperLink::GetLinkColour() const\n{ \n    return m_crLinkColour; \n}\n\nCOLORREF CHyperLink::GetVisitedColour() const\n{\n    return m_crVisitedColour; \n}\n\nCOLORREF CHyperLink::GetHoverColour() const\n{\n    return m_crHoverColour;\n}\n\nvoid CHyperLink::SetVisited(BOOL bVisited /* = TRUE */) \n{ \n    m_bVisited = bVisited; \n\n    if (::IsWindow(GetSafeHwnd()))\n        Invalidate(); \n}\n\nBOOL CHyperLink::GetVisited() const\n{ \n    return m_bVisited; \n}\n\nvoid CHyperLink::SetLinkCursor(HCURSOR hCursor)\n{ \n    m_hLinkCursor = hCursor;\n    if (m_hLinkCursor == NULL)\n        SetDefaultCursor();\n}\n\nHCURSOR CHyperLink::GetLinkCursor() const\n{\n    return m_hLinkCursor;\n}\n\nvoid CHyperLink::SetUnderline(BOOL bUnderline /* = TRUE */)\n{\n    m_bUnderline = bUnderline;\n\n    if (::IsWindow(GetSafeHwnd()))\n    {\n        LOGFONT lf;\n        GetFont()->GetLogFont(&lf);\n        lf.lfUnderline = m_bUnderline;\n\n        m_Font.DeleteObject();\n        m_Font.CreateFontIndirect(&lf);\n        SetFont(&m_Font);\n\n        Invalidate(); \n    }\n}\n\nBOOL CHyperLink::GetUnderline() const\n{ \n    return m_bUnderline; \n}\n\nvoid CHyperLink::SetAutoSize(BOOL bAutoSize /* = TRUE */)\n{\n    m_bAdjustToFit = bAutoSize;\n\n    if (::IsWindow(GetSafeHwnd()))\n        PositionWindow();\n}\n\nBOOL CHyperLink::GetAutoSize() const\n{ \n    return m_bAdjustToFit; \n}\n\n\n// Move and resize the window so that the window is the same size\n// as the hyperlink text. This stops the hyperlink cursor being active\n// when it is not directly over the text. If the text is left justified\n// then the window is merely shrunk, but if it is centred or right\n// justified then the window will have to be moved as well.\n//\n// Suggested by Pl K. Tnder \n\nvoid CHyperLink::PositionWindow()\n{\n    if (!::IsWindow(GetSafeHwnd()) || !m_bAdjustToFit) \n        return;\n\n    // Get the current window position\n    CRect rect;\n    GetWindowRect(rect);\n\n    CWnd* pParent = GetParent();\n    if (pParent)\n        pParent->ScreenToClient(rect);\n\n    // Get the size of the window text\n    CString strWndText;\n    GetWindowText(strWndText);\n\n    CDC* pDC = GetDC();\n    CFont* pOldFont = pDC->SelectObject(&m_Font);\n    CSize Extent = pDC->GetTextExtent(strWndText);\n    pDC->SelectObject(pOldFont);\n    ReleaseDC(pDC);\n\n    // Get the text justification via the window style\n    DWORD dwStyle = GetStyle();\n\n    // Recalc the window size and position based on the text justification\n    if (dwStyle & SS_CENTERIMAGE)\n        rect.DeflateRect(0, (rect.Height() - Extent.cy)/2);\n    else\n        rect.bottom = rect.top + Extent.cy;\n\n    if (dwStyle & SS_CENTER)   \n        rect.DeflateRect((rect.Width() - Extent.cx)/2, 0);\n    else if (dwStyle & SS_RIGHT) \n        rect.left  = rect.right - Extent.cx;\n    else // SS_LEFT = 0, so we can't test for it explicitly \n        rect.right = rect.left + Extent.cx;\n\n    // Move the window\n    SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CHyperLink implementation\n\n// The following appeared in Paul DiLascia's Jan 1998 MSJ articles.\n// It loads a \"hand\" cursor from the winhlp32.exe module\nvoid CHyperLink::SetDefaultCursor()\n{\n    if (m_hLinkCursor == NULL)                // No cursor handle - load our own\n    {\n        // Get the windows directory\n        CString strWndDir;\n        GetWindowsDirectory(strWndDir.GetBuffer(MAX_PATH), MAX_PATH);\n        strWndDir.ReleaseBuffer();\n\n        strWndDir += _T(\"\\\\winhlp32.exe\");\n        // This retrieves cursor #106 from winhlp32.exe, which is a hand pointer\n        HMODULE hModule = LoadLibrary(strWndDir);\n        if (hModule) {\n            HCURSOR hHandCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106));\n            if (hHandCursor)\n                m_hLinkCursor = CopyCursor(hHandCursor);\n        }\n        FreeLibrary(hModule);\n    }\n}\n\nLONG CHyperLink::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)\n{\n    HKEY hkey;\n    LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);\n\n    if (retval == ERROR_SUCCESS) {\n        long datasize = MAX_PATH;\n        TCHAR data[MAX_PATH];\n        RegQueryValue(hkey, NULL, data, &datasize);\n        lstrcpy(retdata,data);\n        RegCloseKey(hkey);\n    }\n\n    return retval;\n}\n\nvoid CHyperLink::ReportError(int nError)\n{\n    CString str;\n    switch (nError) {\n        case 0:                       str = \"The operating system is out\\nof memory or resources.\"; break;\n        case SE_ERR_PNF:              str = \"The specified path was not found.\"; break;\n        case SE_ERR_FNF:              str = \"The specified file was not found.\"; break;\n        case ERROR_BAD_FORMAT:        str = \"The .EXE file is invalid\\n(non-Win32 .EXE or error in .EXE image).\"; break;\n        case SE_ERR_ACCESSDENIED:     str = \"The operating system denied\\naccess to the specified file.\"; break;\n        case SE_ERR_ASSOCINCOMPLETE:  str = \"The filename association is\\nincomplete or invalid.\"; break;\n        case SE_ERR_DDEBUSY:          str = \"The DDE transaction could not\\nbe completed because other DDE transactions\\nwere being processed.\"; break;\n        case SE_ERR_DDEFAIL:          str = \"The DDE transaction failed.\"; break;\n        case SE_ERR_DDETIMEOUT:       str = \"The DDE transaction could not\\nbe completed because the request timed out.\"; break;\n        case SE_ERR_DLLNOTFOUND:      str = \"The specified dynamic-link library was not found.\"; break;\n        case SE_ERR_NOASSOC:          str = \"There is no application associated\\nwith the given filename extension.\"; break;\n        case SE_ERR_OOM:              str = \"There was not enough memory to complete the operation.\"; break;\n        case SE_ERR_SHARE:            str = \"A sharing violation occurred. \";\n        default:                      str.Format(_T(\"Unknown Error (%d) occurred.\"), nError); break;\n    }\n    str = \"Unable to open hyperlink:\\n\\n\" + str;\n    AfxMessageBox(str, MB_ICONEXCLAMATION | MB_OK);\n}\n\nHINSTANCE CHyperLink::GotoURL(LPCTSTR url, int showcmd)\n{\n    TCHAR key[MAX_PATH + MAX_PATH];\n\n    // First try ShellExecute()\n    HINSTANCE result = ShellExecute(NULL, _T(\"open\"), url, NULL,NULL, showcmd);\n\n    // If it failed, get the .htm regkey and lookup the program\n    if ((UINT)result <= HINSTANCE_ERROR) {\n\n        if (GetRegKey(HKEY_CLASSES_ROOT, _T(\".htm\"), key) == ERROR_SUCCESS) {\n            lstrcat(key, _T(\"\\\\shell\\\\open\\\\command\"));\n\n            if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS) {\n                TCHAR *pos;\n                pos = _tcsstr(key, _T(\"\\\"%1\\\"\"));\n                if (pos == NULL) {                     // No quotes found\n                    pos = STRSTR(key, _T(\"%1\"));       // Check for %1, without quotes \n                    if (pos == NULL)                   // No parameter at all...\n                        pos = key+lstrlen(key)-1;\n                    else\n                        *pos = '\\0';                   // Remove the parameter\n                }\n                else\n                    *pos = '\\0';                       // Remove the parameter\n\n                lstrcat(pos, _T(\" \"));\n                lstrcat(pos, url);\n\t\t\t\t\n\t\t\t\tCStringA keyA = CTextConvert::UnicodeToAnsi(key);\n                result = (HINSTANCE)WinExec(keyA, showcmd);\n            }\n        }\n    }\n\n    return result;\n}\n"
        },
        {
          "name": "HyperLink.h",
          "type": "blob",
          "size": 3.1533203125,
          "content": "// HyperLink.h : header file\n//\n//\n// HyperLink static control. Will open the default browser with the given URL\n// when the user clicks on the link.\n//\n// Copyright Chris Maunder, 1997\n// Feel free to use and distribute. May not be sold for profit. \n\n#if !defined(AFX_HYPERLINK_H__D1625061_574B_11D1_ABBA_00A0243D1382__INCLUDED_)\n#define AFX_HYPERLINK_H__D1625061_574B_11D1_ABBA_00A0243D1382__INCLUDED_\n\n#if _MSC_VER >= 1000\n#pragma once\n#endif // _MSC_VER >= 1000\n\n/////////////////////////////////////////////////////////////////////////////\n// CHyperLink window\n\nclass CHyperLink : public CStatic\n{\n// Construction/destruction\npublic:\n    CHyperLink();\n    virtual ~CHyperLink();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n    void SetURL(CString strURL);\n    CString GetURL() const;\n\n    void SetColours(COLORREF crLinkColour, COLORREF crVisitedColour, \n                    COLORREF crHoverColour = -1);\n    COLORREF GetLinkColour() const;\n    COLORREF GetVisitedColour() const;\n    COLORREF GetHoverColour() const;\n\n    void SetVisited(BOOL bVisited = TRUE);\n    BOOL GetVisited() const;\n\n    void SetLinkCursor(HCURSOR hCursor);\n    HCURSOR GetLinkCursor() const;\n\n    void SetUnderline(BOOL bUnderline = TRUE);\n    BOOL GetUnderline() const;\n\n    void SetAutoSize(BOOL bAutoSize = TRUE);\n    BOOL GetAutoSize() const;\n\n\tstatic HINSTANCE GotoURL(LPCTSTR url, int showcmd);\n\n// Overrides\n    // ClassWizard generated virtual function overrides\n    //{{AFX_VIRTUAL(CHyperLink)\n    public:\n    virtual BOOL PreTranslateMessage(MSG* pMsg);\n    protected:\n    virtual void PreSubclassWindow();\n    //}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n    void ReportError(int nError);\n    static LONG GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata);\n    void PositionWindow();\n    void SetDefaultCursor();\n\n// Protected attributes\nprotected:\n    COLORREF m_crLinkColour, m_crVisitedColour;     // Hyperlink colours\n    COLORREF m_crHoverColour;                       // Hover colour\n    BOOL     m_bOverControl;                        // cursor over control?\n    BOOL     m_bVisited;                            // Has it been visited?\n    BOOL     m_bUnderline;                          // underline hyperlink?\n    BOOL     m_bAdjustToFit;                        // Adjust window size to fit text?\n    CString  m_strURL;                              // hyperlink URL\n    CFont    m_Font;                                // Underline font if necessary\n    HCURSOR  m_hLinkCursor;                         // Cursor for hyperlink\n    CToolTipCtrl m_ToolTip;                         // The tooltip\n\n    // Generated message map functions\nprotected:\n    //{{AFX_MSG(CHyperLink)\n    afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);\n    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);\n    afx_msg void OnMouseMove(UINT nFlags, CPoint point);\n    //}}AFX_MSG\n    afx_msg void OnClicked();\n    DECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Developer Studio will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_HYPERLINK_H__D1625061_574B_11D1_ABBA_00A0243D1382__INCLUDED_)\n"
        },
        {
          "name": "ICU_Loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "ICU_String.cpp",
          "type": "blob",
          "size": 2.6015625,
          "content": "#include \"stdafx.h\"\r\n#include \"ICU_String.h\"\r\n#include \"Misc.h\"\r\n\r\n\r\nCICU_String::CICU_String()\r\n{\r\n\tm_dllHandle = NULL;\r\n\tu_isUUppercase = NULL;\r\n\tu_tolower = NULL;\r\n\tu_toupper = NULL;\r\n\tu_strToLower = NULL;\r\n\tu_strToUpper = NULL;\r\n}\r\n\r\nCICU_String::~CICU_String()\r\n{\r\n\tif (m_dllHandle)\r\n\t{\r\n\t\t::FreeLibrary(m_dllHandle);\r\n\t\tm_dllHandle = NULL;\r\n\t}\r\n}\r\n\r\nbool CICU_String::Load()\r\n{\r\n\tbool loaded = false;\r\n\tm_dllHandle = ::LoadLibrary(_T(\"icu.dll\"));\r\n\tif (m_dllHandle != NULL)\r\n\t{\r\n\t\tu_isUUppercase = (bool(__cdecl*)(wchar_t c))GetProcAddress(m_dllHandle, \"u_isUUppercase\");\r\n\t\tu_tolower = (wchar_t(__cdecl*)(wchar_t c))GetProcAddress(m_dllHandle, \"u_tolower\");\r\n\t\tu_toupper = (wchar_t(__cdecl*)(wchar_t c))GetProcAddress(m_dllHandle, \"u_toupper\");\r\n\t\tu_strToLower = (int(__cdecl*)(wchar_t* dest, int destCapacity, const wchar_t* src, int srcLength, const char* locale, int* pErrorCode))GetProcAddress(m_dllHandle, \"u_strToLower\");\r\n\t\tu_strToUpper = (int(__cdecl*)(wchar_t* dest, int destCapacity, const wchar_t* src, int srcLength, const char* locale, int* pErrorCode))GetProcAddress(m_dllHandle, \"u_strToUpper\");\r\n\r\n\t\tLog(_T(\"Loaded icu.dll, this will be used for upper/lower case calls\"));\r\n\r\n\t\tloaded = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"Error loading icu.dll, LastError: %d\"), ::GetLastError()));\r\n\t}\r\n\r\n\treturn loaded;\r\n}\r\n\r\nbool CICU_String::IsUpperEx(wchar_t c)\r\n{\r\n\tif (m_dllHandle == NULL || u_tolower == NULL)\r\n\t{\r\n\t\treturn ::isupper(c);\r\n\t}\r\n\r\n\treturn u_isUUppercase(c);\r\n}\r\n\r\nwchar_t CICU_String::ToLowerEx(wchar_t c)\r\n{\r\n\tif (m_dllHandle == NULL || u_tolower == NULL)\r\n\t{\r\n\t\treturn ::tolower(c);\r\n\t}\r\n\r\n\treturn u_tolower(c);\r\n}\r\n\r\nwchar_t CICU_String::ToUpperEx(wchar_t c)\r\n{\r\n\tif (m_dllHandle == NULL || u_tolower == NULL)\r\n\t{\r\n\t\treturn ::toupper(c);\r\n\t}\r\n\r\n\treturn u_toupper(c);\r\n}\r\n\r\nCString CICU_String::ToLowerStringEx(CString source)\r\n{\r\n\tif (m_dllHandle == NULL || u_tolower == NULL)\r\n\t{\r\n\t\treturn CString(source).MakeLower();\r\n\t}\r\n\r\n\tCString dest;\r\n\r\n\tint length = source.GetLength();\r\n\tint errorCode = 0;\r\n\tu_strToLower(dest.GetBufferSetLength((int)(length * 1.2)), (int)(length * 1.2), source.GetBuffer(), length, NULL, &errorCode);\r\n\r\n\tsource.ReleaseBuffer();\r\n\tdest.ReleaseBuffer();\r\n\r\n\treturn dest;\r\n}\r\n\r\nCString CICU_String::ToUpperStringEx(CString source)\r\n{\r\n\tif (m_dllHandle == NULL || u_tolower == NULL)\r\n\t{\r\n\t\treturn CString(source).MakeUpper();\r\n\t}\r\n\r\n\tCString dest;\r\n\r\n\tint length = source.GetLength();\r\n\tint errorCode = 0;\r\n\tu_strToUpper(dest.GetBufferSetLength((int)(length * 1.2)), (int)(length * 1.2), source.GetBuffer(), length, NULL, &errorCode);\r\n\r\n\tsource.ReleaseBuffer();\r\n\tdest.ReleaseBuffer();\r\n\r\n\treturn dest;\r\n}"
        },
        {
          "name": "ICU_String.h",
          "type": "blob",
          "size": 0.7177734375,
          "content": "#pragma once\r\nclass CICU_String\r\n{\r\npublic:\r\n\r\n\tCICU_String();\r\n\tvirtual ~CICU_String();\r\n\r\n\tbool Load();\r\n\r\n\tbool IsUpperEx(wchar_t c);\r\n\twchar_t ToLowerEx(wchar_t c);\r\n\twchar_t ToUpperEx(wchar_t c);\r\n\r\n\tCString ToLowerStringEx(CString source);\r\n\tCString ToUpperStringEx(CString source);\r\n\r\nprivate:\r\n\r\n\tHMODULE m_dllHandle;\r\n\r\n\tbool(__cdecl* u_isUUppercase)(wchar_t c);\r\n\twchar_t(__cdecl* u_tolower)(wchar_t c);\r\n\twchar_t(__cdecl* u_toupper)(wchar_t c);\r\n\r\n\tint(__cdecl* u_strToLower)(wchar_t* dest, int destCapacity, const wchar_t* src, int srcLength, const char* locale, int* pErrorCode);\r\n\tint(__cdecl* u_strToUpper)(wchar_t* dest, int destCapacity, const wchar_t* src, int srcLength, const char* locale, int* pErrorCode);\r\n};\r\n\r\n"
        },
        {
          "name": "IClipAggregator.h",
          "type": "blob",
          "size": 0.171875,
          "content": "#pragma once\n\nclass IClipAggregator\n{\npublic:\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType) = 0;\n\tvirtual HGLOBAL GetHGlobal() = 0;\n};\n"
        },
        {
          "name": "ImageFormatAggregator.cpp",
          "type": "blob",
          "size": 1.1025390625,
          "content": "#include \"stdafx.h\"\n#include \".\\ImageFormatAggregator.h\"\n#include \"Misc.h\"\n#include \"shared/Tokenizer.h\"\n#include \"BitmapHelper.h\"\n\nCImageFormatAggregator::CImageFormatAggregator(BOOL horizontally)\n{\n\tm_horizontally = horizontally;\n}\n\nCImageFormatAggregator::~CImageFormatAggregator(void)\n{\n}\n\nbool CImageFormatAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tHGLOBAL hGlobal = ::NewGlobalP(lpData, nDataSize);\n\t\n\tCClipFormat data(cfType, hGlobal);\n\t//m_images owns the data now\n\tdata.AutoDeleteData(false);\n\n\tm_images.Add(data);\n\n\treturn true;\n}\n\nHGLOBAL CImageFormatAggregator::GetHGlobal()\n{\n\tCBitmap bitmap;\n\tif (CBitmapHelper::GetCBitmap(m_images, CDC::FromHandle(GetDC(GetActiveWindow())), &bitmap, m_horizontally) == FALSE)\n\t{\n\t\tbitmap.DeleteObject();\n\t\treturn NULL;\n\t}\n\n\tint count = (int)m_images.GetCount();\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tCClipFormat clip = m_images[i];\n\t\tclip.AutoDeleteData(true);\n\t\tclip.Free();\n\t}\n\n\tHPALETTE hPal = NULL;\n\tauto returnHGlobal = CBitmapHelper::hBitmapToDIB((HBITMAP)bitmap, BI_RGB, hPal);\n\n\tbitmap.DeleteObject();\n\n\treturn returnHGlobal;\n}"
        },
        {
          "name": "ImageFormatAggregator.h",
          "type": "blob",
          "size": 0.3935546875,
          "content": "#pragma once\n#include \"stdafx.h\"\n#include \"IClipAggregator.h\"\n#include \"Clip.h\"\n\nclass CImageFormatAggregator : public IClipAggregator\n{\npublic:\n\tCImageFormatAggregator(BOOL horizontally);\n\t~CImageFormatAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\nprotected:\n\tCClipFormats m_images;\n\tBOOL m_horizontally;\n};\n\n"
        },
        {
          "name": "ImageHelper.cpp",
          "type": "blob",
          "size": 0.658203125,
          "content": "#include \"stdafx.h\"\n#include \"ImageHelper.h\"\n\nvoid DIBImageHelper::prependStream(IStream* pIStream, LPVOID pvData, ULONG size)\n{\n\tBITMAPINFO* lpBI = (BITMAPINFO*)pvData;\n\n\tint nPaletteEntries = 1 << lpBI->bmiHeader.biBitCount;\n\tif (lpBI->bmiHeader.biBitCount > 8)\n\t\tnPaletteEntries = 0;\n\telse if (lpBI->bmiHeader.biClrUsed != 0)\n\t\tnPaletteEntries = lpBI->bmiHeader.biClrUsed;\n\n\tBITMAPFILEHEADER BFH;\n\tmemset(&BFH, 0, sizeof(BITMAPFILEHEADER));\n\tBFH.bfType = 'MB';\n\tBFH.bfSize = sizeof(BITMAPFILEHEADER) + size;\n\tBFH.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + nPaletteEntries * sizeof(RGBQUAD);\n\tpIStream->Write(&BFH, sizeof(BITMAPFILEHEADER), NULL);\n}"
        },
        {
          "name": "ImageHelper.h",
          "type": "blob",
          "size": 1.4541015625,
          "content": "#include \"stdafx.h\"\n#include \"Misc.h\"\n#include <memory>\n\ntemplate <class Concrete, class GdipImage>\nclass ImageHelper abstract\n{\npublic:\n\tstatic GdipImage* GdipImageFromHGLOBAL(HGLOBAL hGlobal) {\n\t\tIStream* pIStream = StreamFromHGLOBAL(hGlobal);\n\t\tif (!pIStream)\n\t\t\treturn NULL;\n\n\t\tGdipImage* gdipImage = GdipImage::FromStream(pIStream);\n\t\tpIStream->Release();\n\t\treturn gdipImage;\n\t};\n\tstatic std::shared_ptr<CImage> CImageFromHGLOBAL(HGLOBAL hGlobal) {\n\t\tIStream* pIStream = StreamFromHGLOBAL(hGlobal);\n\t\tif (!pIStream)\n\t\t\treturn NULL;\n\n\t\tstd::shared_ptr<CImage> cImage = std::make_shared<CImage>();\n\t\tcImage->Load(pIStream);\n\t\tpIStream->Release();\n\n\t\treturn cImage;\n\t};\n\tstatic IStream* StreamFromHGLOBAL(HGLOBAL hGlobal) {\n\t\tif (!hGlobal)\n\t\t\treturn NULL;\n\n\t\tIStream* pIStream = NULL;\n\t\tif (CreateStreamOnHGlobal(NULL, TRUE, (LPSTREAM*)&pIStream) != S_OK)\n\t\t\treturn NULL;\n\n\t\tLPVOID pvData = GlobalLock(hGlobal);\n\t\tULONG size = (ULONG)GlobalSize(hGlobal);\n\n\t\tConcrete::prependStream(pIStream, pvData, size);\n\n\t\tpIStream->Write(pvData, size, NULL);\n\t\tGlobalUnlock(hGlobal);\n\n\t\treturn pIStream;\n\t};\n};\n\nclass BitmapImageHelper : public ImageHelper<BitmapImageHelper, Gdiplus::Bitmap>\n{\npublic:\n\tstatic void prependStream(IStream* pIStream, LPVOID pvData, ULONG size) {};\n};\n\nclass PNGImageHelper : public BitmapImageHelper\n{\n};\n\nclass DIBImageHelper : public ImageHelper<DIBImageHelper, Gdiplus::Bitmap>\n{\npublic:\n\tstatic void prependStream(IStream* pIStream, LPVOID pvData, ULONG size);\n};"
        },
        {
          "name": "ImageViewer.cpp",
          "type": "blob",
          "size": 11.3759765625,
          "content": "// ImageViewer.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"ImageViewer.h\"\r\n#include \"BitmapHelper.h\"\r\n#include \"memdc.h\"\r\n\r\n\r\n// CImageViewer\r\n\r\nIMPLEMENT_DYNAMIC(CImageViewer, CWnd)\r\n\r\nCImageViewer::CImageViewer()\r\n{\r\n\tm_scrollHelper.AttachWnd(this);\r\n\tm_hoveringOverImage = false;\r\n\tm_pGdiplusBitmap = NULL;\r\n\tm_scale = 1;\r\n}\r\n\r\nCImageViewer::~CImageViewer()\r\n{\r\n\tdelete m_pGdiplusBitmap;\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CImageViewer, CWnd)\r\n\tON_WM_HSCROLL()\r\n\tON_WM_VSCROLL()\r\n\tON_WM_MOUSEWHEEL()\r\n\tON_WM_PAINT()\r\n\tON_WM_SIZE()\r\n\tON_WM_SETCURSOR()\r\n\tON_WM_LBUTTONUP()\r\n\tON_WM_MOUSEHWHEEL()\r\n\tON_WM_ERASEBKGND()\r\n\tON_MESSAGE(WM_GESTURE, &CImageViewer::OnGesture)\r\n\tON_MESSAGE(WM_GESTURENOTIFY, &CImageViewer::OnGestureNotify)\r\nEND_MESSAGE_MAP()\r\n\r\nBOOL CImageViewer::Create(CWnd* pParent)\r\n{\r\n\tBOOL bSuccess;\r\n\r\n\t// Register window class\r\n\tCString csClassName = AfxRegisterWndClass(CS_OWNDC | CS_HREDRAW | CS_VREDRAW,\r\n\t\tLoadCursor(NULL, IDC_ARROW),\r\n\t\tCBrush(::GetSysColor(COLOR_BTNFACE)));\r\n\r\n\r\n\r\n\t// If no parent supplied then try and get a pointer to it anyway\r\n\tif (!pParent)\r\n\t\tpParent = AfxGetMainWnd();\r\n\r\n\t// Create popup window\r\n\t//bSuccess = CreateEx(WS_EX_DLGMODALFRAME|WS_EX_TOPMOST, // Extended style\r\n\tbSuccess = CreateEx(0,\r\n\t\tcsClassName,                       // Classname\r\n\t\t_T(\"\"),                          // Title\r\n\t\tWS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL,     // style\r\n\t\t0, 0,                               // position - updated soon.\r\n\t\t390, 130,                           // Size - updated soon\r\n\t\tpParent->GetSafeHwnd(),            // handle to parent\r\n\t\t0,                                 // No menu\r\n\t\tNULL);\r\n\tif (!bSuccess) return FALSE;\r\n\r\n\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CImageViewer::UpdateBitmapSize(bool setScale)\r\n{\r\n\tif (m_pGdiplusBitmap != NULL)\r\n\t{\r\n\t\tif (setScale)\r\n\t\t{\r\n\t\t\tBOOL newScaleImage = CGetSetOptions::GetScaleImagesToDescWindow();\r\n\t\t\tif (newScaleImage)\r\n\t\t\t{\r\n\t\t\t\tCRect rect;\r\n\t\t\t\tGetClientRect(rect);\r\n\r\n\t\t\t\tSCROLLINFO si;\r\n\t\t\t\tif (this->GetScrollInfo(SB_HORZ, &si) && si.nPage > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tint cxSB = ::GetSystemMetrics(SM_CXVSCROLL);\r\n\t\t\t\t\trect.right += cxSB;\r\n\t\t\t\t\tint cySB = ::GetSystemMetrics(SM_CYHSCROLL);\r\n\t\t\t\t\trect.bottom += cySB;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdouble w = m_pGdiplusBitmap->GetWidth();\r\n\t\t\t\tif (w > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_scale = rect.Width() / w;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_scale = 1;\r\n\t\t\t}\r\n\r\n\t\t\tm_scrollHelper.ScrollToOrigin(true, true);\r\n\t\t}\r\n\r\n\t\tm_scrollHelper.AttachWnd(this);\t\t\r\n\t\tm_scrollHelper.SetDisplaySize(m_pGdiplusBitmap->GetWidth(), m_pGdiplusBitmap->GetHeight(), m_scale);\t\t\r\n\r\n\t\tthis->GetParent()->PostMessage(WM_REFRESH_FOOTER, 0, 0);\r\n\t}\r\n}\r\n\r\nvoid CImageViewer::OnPaint()\r\n{\r\n\tCPaintDC dc(this); // device context for painting\r\n\r\n\tCMemDCEx memDC(&dc);\r\n\r\n\tCRect rect;\r\n\tGetClientRect(rect);\t\r\n\r\n\tCBrush  Brush, *pOldBrush;\r\n\tBrush.CreateSolidBrush(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\r\n\tpOldBrush = memDC.SelectObject(&Brush);\r\n\r\n\tmemDC.FillRect(&rect, &Brush);\r\n\r\n\tif (m_pGdiplusBitmap)\r\n\t{\r\n\t\tint width = m_pGdiplusBitmap->GetWidth();\r\n\t\tint height = m_pGdiplusBitmap->GetHeight();\r\n\t\t\r\n\t\tGdiplus::ImageAttributes attrs;\r\n\t\tCSize s = m_scrollHelper.GetScrollPos();\r\n\r\n\t\tGdiplus::Graphics graphics(memDC);\r\n\t\tgraphics.SetInterpolationMode(Gdiplus::InterpolationModeHighQualityBicubic);\r\n\t\tgraphics.SetPixelOffsetMode(Gdiplus::PixelOffsetModeHalf);\r\n\r\n\t\tGdiplus::Rect dest((int)0, (int)0, (int)rect.Width(), (int)rect.Height());\r\n\r\n\t\tint nW = (int)(rect.Width() * (1 / m_scale));\r\n\t\tint nH = (int)(rect.Height() * (1 / m_scale));\r\n\r\n\t\tgraphics.DrawImage(m_pGdiplusBitmap, dest, s.cx, s.cy, nW, nH, Gdiplus::UnitPixel, &attrs);\r\n\r\n\t\t//OutputDebugString(StrF(_T(\"OnPaint, Width: %d, New Width: %d\\r\\n\"), rect.Width(), (int)nW));\r\n\t}\r\n\t\r\n\tmemDC.SelectObject(pOldBrush);\r\n}\r\n\r\n\r\nvoid CImageViewer::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\r\n{\r\n\t//OutputDebugString(_T(\"OnHScroll\\r\\n\"));\r\n\tm_scrollHelper.OnHScroll(nSBCode, nPos, pScrollBar);\r\n}\r\n\r\nvoid CImageViewer::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\r\n{\r\n\t//OutputDebugString(_T(\"OnVScroll\\r\\n\"));\r\n\tm_scrollHelper.OnVScroll(nSBCode, nPos, pScrollBar);\r\n}\r\n\r\nBOOL CImageViewer::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)\r\n{\r\n\tOutputDebugString(_T(\"OnMouseWheel\\r\\n\"));\r\n\r\n\tif (nFlags == MK_CONTROL)\r\n\t{\r\n\t\tthis->LockWindowUpdate();\r\n\t\tCPoint delta;\r\n\t\tdouble oldScale = m_scale;\r\n\r\n\t\tif (zDelta > 0)\r\n\t\t{\r\n\t\t\tm_scale += .1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_scale -= .1;\r\n\t\t}\r\n\r\n\t\tm_scale = max(m_scale, 0.01);\r\n\r\n\t\t::ScreenToClient(m_hWnd, &pt);\r\n\t\tUpdateBitmapSize(false);\r\n\r\n\t\tif (oldScale > 0 && m_scale > 0)\r\n\t\t{\r\n\t\t\tdelta.x = round((pt.x * (1 / oldScale)) - (pt.x * (1 / m_scale)));\r\n\t\t\tdelta.y = round((pt.y * (1 / oldScale)) - (pt.y * (1 / m_scale)));\r\n\r\n\t\t\tm_scrollHelper.Update(delta);\r\n\t\t}\r\n\r\n\t\tthis->Invalidate();\r\n\r\n\t\tthis->UnlockWindowUpdate();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tBOOL wasScrolled = m_scrollHelper.OnMouseWheel(nFlags, zDelta, pt);\r\n\t\treturn wasScrolled;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CImageViewer::OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt)\r\n{\r\n\tOutputDebugString(_T(\"OnMouseHWheel\\r\\n\"));\r\n\r\n\tBOOL wasScrolled = m_scrollHelper.OnMouseHWheel(nFlags, -zDelta, pt);\r\n\r\n\tCWnd::OnMouseHWheel(nFlags, zDelta, pt);\r\n}\r\n\r\nvoid CImageViewer::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCWnd::OnSize(nType, cx, cy);\r\n\tm_scrollHelper.OnSize(nType, cx, cy);\r\n}\r\n\r\nBOOL CImageViewer::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)\r\n{\r\n\tif (this->m_pGdiplusBitmap &&\r\n\t\tpWnd->m_hWnd == this->m_hWnd &&\r\n\t\tnHitTest == HTCLIENT)\r\n\t{\r\n\t\tif (CGetSetOptions::GetScaleImagesToDescWindow())\r\n\t\t{\r\n\t\t\t::SetCursor(AfxGetApp()->LoadCursor(IDC_CURSOR_ZOOM_IN));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t::SetCursor(AfxGetApp()->LoadCursor(IDC_CURSOR_ZOOM_OUT));\r\n\t\t}\r\n\r\n\t\tm_hoveringOverImage = true;\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tm_hoveringOverImage = false;\r\n\r\n\treturn CWnd::OnSetCursor(pWnd, nHitTest, message);\r\n}\r\n\r\n\r\nvoid CImageViewer::OnLButtonUp(UINT nFlags, CPoint point)\r\n{\r\n\tif (this->m_pGdiplusBitmap &&\r\n\t\tm_hoveringOverImage)\r\n\t{\r\n\t\tCGetSetOptions::SetScaleImagesToDescWindow(!CGetSetOptions::GetScaleImagesToDescWindow());\r\n\t\t\r\n\t\tUpdateBitmapSize(true);\r\n\t\t\r\n\t\tInvalidate();\r\n\r\n\t\t\r\n\t\treturn;\r\n\t}\r\n\r\n\tCWnd::OnLButtonUp(nFlags, point);\r\n}\r\n\r\nBOOL CImageViewer::OnEraseBkgnd(CDC* pDC)\r\n{\r\n\t//OutputDebugString(_T(\"image viewer OnEraseBkgnd\\r\\n\"));\r\n\t//return CWnd::OnEraseBkgnd(pDC);\r\n\treturn FALSE;\r\n}\r\n\r\nLRESULT CImageViewer::OnGesture(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCPoint ptZoomCenter;\r\n\tdouble k;\r\n\tGESTUREINFO gi;\r\n\r\n\tZeroMemory(&gi, sizeof(GESTUREINFO));\r\n\r\n\tgi.cbSize = sizeof(GESTUREINFO);\r\n\r\n\tBOOL bResult = GetGestureInfo((HGESTUREINFO)lParam, &gi);\r\n\tBOOL bHandled = FALSE;\r\n\r\n\tif (bResult) {\r\n\t\t// now interpret the gesture\r\n\t\tswitch (gi.dwID) {\r\n\t\tcase GID_ZOOM:\r\n\t\t\t//OutputDebugString(_T(\"zoom\\r\\n\"));\r\n\t\t\t// Code for zooming goes here     \r\n\t\t\tbHandled = TRUE;\r\n\r\n\t\t\tswitch (gi.dwFlags)\r\n\t\t\t{\r\n\t\t\tcase GF_BEGIN:\r\n\t\t\t\tm_dwArguments = LODWORD(gi.ullArguments);\r\n\t\t\t\tm_ptFirst.x = gi.ptsLocation.x;\r\n\t\t\t\tm_ptFirst.y = gi.ptsLocation.y;\r\n\t\t\t\t::ScreenToClient(m_hWnd, &m_ptFirst);\r\n\t\t\t\tOutputDebugString(_T(\"zoom start\\r\\n\"));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GF_END:\r\n\t\t\t\tOutputDebugString(_T(\"zoom end\\r\\n\"));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// We read here the second point of the gesture. This is middle point between \r\n\t\t\t\t// fingers in this new position.\r\n\t\t\t\tm_ptSecond.x = gi.ptsLocation.x;\r\n\t\t\t\tm_ptSecond.y = gi.ptsLocation.y;\r\n\t\t\t\t::ScreenToClient(m_hWnd, &m_ptSecond);\r\n\r\n\t\t\t\t// We have to calculate zoom center point \r\n\t\t\t\tptZoomCenter.x = (m_ptFirst.x + m_ptSecond.x) / 2;\r\n\t\t\t\tptZoomCenter.y = (m_ptFirst.y + m_ptSecond.y) / 2;\r\n\r\n\t\t\t\t// The zoom factor is the ratio between the new and the old distance. \r\n\t\t\t\t// The new distance between two fingers is stored in gi.ullArguments \r\n\t\t\t\t// (lower DWORD) and the old distance is stored in _dwArguments.\r\n\t\t\t\tk = (double)(LODWORD(gi.ullArguments)) / (double)(m_dwArguments);\r\n\r\n\t\t\t\t// Now we process zooming in/out of the object\r\n\t\t\t\t//ProcessZoom(k, ptZoomCenter.x, ptZoomCenter.y);\r\n\r\n\t\t\t\t//m_scrollHelper.Update(ptZoomCenter);\r\n\r\n\t\t\t\tCString cs;\r\n\t\t\t\tcs.Format(_T(\"ZOOM k: %f, x: %d, y: %d\\r\\n\"), k, ptZoomCenter.x, ptZoomCenter.y);\r\n\t\t\t\tOutputDebugString(cs);\r\n\r\n\t\t\t\t//InvalidateRect(hWnd, NULL, TRUE);\r\n\r\n\t\t\t\t// Now we have to store new information as a starting information \r\n\t\t\t\t// for the next step in this gesture.\r\n\t\t\t\tm_ptFirst = m_ptSecond;\r\n\t\t\t\t//m_dwArguments = LODWORD(gi.ullArguments);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase GID_PAN:\r\n\t\t\t//OutputDebugString(_T(\"pan\\r\\n\"));\r\n\t\t\t// Code for panning goes here\r\n\t\t\tbHandled = TRUE;\r\n\t\t\tswitch (gi.dwFlags)\r\n\t\t\t{\r\n\t\t\tcase GF_BEGIN:\r\n\t\t\t\tm_ptFirst.x = gi.ptsLocation.x;\r\n\t\t\t\tm_ptFirst.y = gi.ptsLocation.y;\r\n\t\t\t\t::ScreenToClient(m_hWnd, &m_ptFirst);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// We read the second point of this gesture. It is a middle point\r\n\t\t\t\t// between fingers in this new position\r\n\t\t\t\tm_ptSecond.x = gi.ptsLocation.x;\r\n\t\t\t\tm_ptSecond.y = gi.ptsLocation.y;\r\n\t\t\t\t::ScreenToClient(m_hWnd, &m_ptSecond);\r\n\r\n\t\t\t\tint xDiff = m_ptSecond.x - m_ptFirst.x;\r\n\r\n\t\t\t\tint yDiff = m_ptSecond.y - m_ptFirst.y;\r\n\r\n\t\t\t\tm_scrollHelper.Update(CPoint(-xDiff, -yDiff));\r\n\r\n\t\t\t\t//CString cs;\r\n\t\t\t\t//cs.Format(_T(\"x: %d, y: %d\\r\\n\"), xDiff, yDiff);\r\n\t\t\t\t//OutputDebugString(cs);\r\n\r\n\t\t\t\t// We apply move operation of the object\r\n\t\t\t\t//ProcessMove(_ptSecond.x - _ptFirst.x, _ptSecond.y - _ptFirst.y);\r\n\r\n\t\t\t\t//InvalidateRect(hWnd, NULL, TRUE);\r\n\r\n\t\t\t\t// We have to copy second point into first one to prepare\r\n\t\t\t\t// for the next step of this gesture.\r\n\t\t\t\tm_ptFirst = m_ptSecond;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t\tbreak;\r\n\t\tcase GID_ROTATE:\r\n\t\t\tOutputDebugString(_T(\"rotate\\r\\n\"));\r\n\t\t\t// Code for rotation goes here\r\n\t\t\tbHandled = TRUE;\r\n\t\t\tbreak;\r\n\t\tcase GID_TWOFINGERTAP:\r\n\t\t\tOutputDebugString(_T(\"two finger\\r\\n\"));\r\n\t\t\t// Code for two-finger tap goes here\r\n\t\t\tbHandled = TRUE;\r\n\t\t\tbreak;\r\n\t\tcase GID_PRESSANDTAP:\r\n\t\t\tOutputDebugString(_T(\"press and tap\\r\\n\"));\r\n\t\t\t// Code for roll over goes here\r\n\t\t\tbHandled = TRUE;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tOutputDebugString(_T(\"default\\r\\n\"));\r\n\t\t\t// A gesture was not recognized\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tDWORD dwErr = GetLastError();\r\n\t\tif (dwErr > 0) {\r\n\t\t\tOutputDebugString(_T(\"error\\r\\n\"));\r\n\t\t\t//MessageBoxW(hWnd, L\"Error!\", L\"Could not retrieve a GESTUREINFO structure.\", MB_OK);\r\n\t\t}\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nLRESULT CImageViewer::OnGestureNotify(WPARAM wParam, LPARAM lParam)\r\n{\r\n\t// This is the right place to define the list of gestures that this\r\n\t\t\t// application will support. By populating GESTURECONFIG structure \r\n\t\t\t// and calling SetGestureConfig function. We can choose gestures \r\n\t\t\t// that we want to handle in our application. In this app we\r\n\t\t\t// decide to handle all gestures.\r\n\tGESTURECONFIG gc = {\r\n\t\t0,              // gesture ID\r\n\t\tGC_ALLGESTURES,\r\n\t\t//GC_PAN | GC_PAN_WITH_SINGLE_FINGER_VERTICALLY | GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY | GC_PAN_WITH_GUTTER | GC_PAN_WITH_INERTIA, // settings related to gesture ID that are to be \r\n\t\t\t\t\t\t// turned on\r\n\t\t0               // settings related to gesture ID that are to be \r\n\t\t\t\t\t\t// turned off\r\n\t};\r\n\r\n\tBOOL bResult = ::SetGestureConfig(\r\n\t\tm_hWnd,                 // window for which configuration is specified  \r\n\t\t0,                    // reserved, must be 0\r\n\t\t1,                    // count of GESTURECONFIG structures\r\n\t\t&gc,                  // array of GESTURECONFIG structures, dwIDs will be processed in the\r\n\t\t\t\t\t\t\t  // order specified and repeated occurances will overwrite previous ones\r\n\t\tsizeof(GESTURECONFIG) // sizeof(GESTURECONFIG)\r\n\t);\r\n\r\n\treturn TRUE;\r\n}\r\n"
        },
        {
          "name": "ImageViewer.h",
          "type": "blob",
          "size": 1.134765625,
          "content": "#pragma once\r\n\r\n#include \"ScrollHelper.h\"\r\n#include \"Clip.h\"\r\n\r\n\r\n\r\nclass CImageViewer : public CWnd\r\n{\r\n\tDECLARE_DYNAMIC(CImageViewer)\r\n\r\npublic:\r\n\tCImageViewer();\r\n\tvirtual ~CImageViewer();\r\n\r\n\tGdiplus::Bitmap *m_pGdiplusBitmap;\r\n\tCScrollHelper m_scrollHelper;\r\n\r\n\tvoid UpdateBitmapSize(bool setScale);\r\n\r\n\tBOOL Create(CWnd* pParent);\r\n\r\n\tbool m_hoveringOverImage;\r\n\r\n\r\n\tCPoint m_ptFirst;\r\n\tCPoint m_ptSecond;\r\n\tDWORD m_dwArguments;\r\n\r\n\tdouble m_scale;\r\n\r\nprotected:\r\n\tDECLARE_MESSAGE_MAP()\r\n\r\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\r\n\tafx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\r\n\tafx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);\r\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\r\n\tafx_msg void OnPaint();\r\npublic:\r\n\tafx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);\r\n\tafx_msg void OnLButtonUp(UINT nFlags, CPoint point);\r\n\tafx_msg void OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt);\r\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\r\n\tafx_msg LRESULT OnGesture(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnGestureNotify(WPARAM wParam, LPARAM lParam);\r\n};\r\n\r\n\r\n"
        },
        {
          "name": "MagneticWnd.cpp",
          "type": "blob",
          "size": 3.5439453125,
          "content": "#include \"stdafx.h\"\n#include \".\\magneticwnd.h\"\n\nbool bDoChange = true;\n\nCMagneticWnd::CMagneticWnd()\n{\n\tm_bMovedAttachedWnd = false;\n\tm_crLastMove.SetRectEmpty();\n\tm_bHandleWindowPosChanging = true;\n}\n\nCMagneticWnd::~CMagneticWnd()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CMagneticWnd, CWnd)\n\tON_WM_MOVE()\n\tON_WM_WINDOWPOSCHANGING()\nEND_MESSAGE_MAP()\n\nvoid CMagneticWnd::OnMove(int x, int y) \n{\n\tCWnd::OnMove(x, y);\n\n\tif(m_bMovedAttachedWnd)\n\t{\n\t\tCRect crThis;\n\t\tCRect crAttached;\n\t\tlong lDiff = 0;\n\n\t\tGetWindowRect(crThis);\n\n\t\tfor(std::vector<CMagneticWnd*>::iterator Iter = m_AttachedWnd.begin(); Iter != m_AttachedWnd.end(); Iter++)\n\t\t{\n\t\t\tCMagneticWnd *pAttachedWnd = *Iter;\n\t\t\tif(pAttachedWnd)\n\t\t\t{\n\t\t\t\tif(m_crLastMove.IsRectEmpty() == FALSE)\n\t\t\t\t{\n\t\t\t\t\tpAttachedWnd->GetWindowRect(crAttached);\n\n\t\t\t\t\tlong lXDiff = crThis.left - m_crLastMove.left;\n\t\t\t\t\tlong lYDiff = crThis.bottom - m_crLastMove.bottom;\n\n\t\t\t\t\tcrAttached.left += lXDiff;\n\t\t\t\t\tcrAttached.right += lXDiff;\n\t\t\t\t\tcrAttached.top += lYDiff;\n\t\t\t\t\tcrAttached.bottom += lYDiff;\n\n\t\t\t\t\tpAttachedWnd->MoveMagneticWWnd(crAttached);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_crLastMove = crThis;\n\t}\n}\n\nvoid CMagneticWnd::MoveMagneticWWnd(LPCRECT lpRect, BOOL bRepaint)\n{\n\tm_bHandleWindowPosChanging = false;\n\tMoveWindow(lpRect, bRepaint);\n\tm_bHandleWindowPosChanging = true;\n}\n\n\nvoid CMagneticWnd::OnWindowPosChanging(WINDOWPOS* lpwndpos)\n{\n\tCWnd::OnWindowPosChanging(lpwndpos);\n\n\tif(m_bHandleWindowPosChanging == false)\n\t\treturn;\n\n\tfor(std::vector<CMagneticWnd*>::iterator Iter = m_SnapToWnds.begin(); Iter != m_SnapToWnds.end(); Iter++)\n\t{\n\t\tCMagneticWnd *pOtherWnd = *Iter;\n\n\t\tif(pOtherWnd != NULL && \n\t\t\tthis->IsWindowVisible() && \n\t\t\tpOtherWnd->IsWindowVisible() &&\n\t\t\tlpwndpos->x != 0 && lpwndpos->y != 0 && lpwndpos->cx != 0 && lpwndpos->cy != 0)\n\t\t{\n\t\t\tif(m_bMovedAttachedWnd && (IsWindowAttached(pOtherWnd)))\n\t\t\t\tcontinue;\n\n\t\t\tCRect rectParent;\n\t\t\tpOtherWnd->GetWindowRect(rectParent);\n\t\t\tbool bAttached = false;\n\n\t\t\t// Snap left edge\n\t\t\tif(abs(lpwndpos->x - rectParent.right) <= 15)\n\t\t\t{\n\t\t\t\tlpwndpos->x = rectParent.right;\n\t\t\t\tbAttached = true;\n\t\t\t}\n\n\t\t\t// Snap right edge\n\t\t\tif (abs(lpwndpos->x + lpwndpos->cx - rectParent.left) <= 15)\n\t\t\t{\n\t\t\t\tlpwndpos->x = rectParent.left - lpwndpos->cx;\n\t\t\t\tbAttached = true;\n\t\t\t}\n\n\t\t\t// Snap to the bottom\n\t\t\tif (abs(lpwndpos->y + lpwndpos->cy - rectParent.top) <= 15)\n\t\t\t{\n\t\t\t\tlpwndpos->y = rectParent.top - lpwndpos->cy;\n\t\t\t\tbAttached = true;\n\t\t\t} \n\n\t\t\t// Snap the top\n\t\t\tif (abs(lpwndpos->y - rectParent.bottom) <= 15)\n\t\t\t{\n\t\t\t\tlpwndpos->y = rectParent.bottom;\n\t\t\t\tbAttached = true;\n\t\t\t}\n\n\t\t\tpOtherWnd->SetWindowAttached(this, bAttached);\n\t\t\tSetWindowAttached(pOtherWnd, bAttached);\n\n\t\t\tif(m_bMovedAttachedWnd)\n\t\t\t{\n\t\t\t\tm_crLastMove.left = lpwndpos->x;\n\t\t\t\tm_crLastMove.top = lpwndpos->y;\n\t\t\t\tm_crLastMove.right = lpwndpos->x + lpwndpos->cx;\n\t\t\t\tm_crLastMove.bottom = lpwndpos->y + lpwndpos->cy;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CMagneticWnd::SetWindowAttached(CMagneticWnd *pOtherWnd, bool bAttach)\n{\n\tbool bFound = false;\n\tfor(std::vector<CMagneticWnd*>::iterator Iter = m_AttachedWnd.begin(); Iter != m_AttachedWnd.end(); Iter++)\n\t{\n\t\tCMagneticWnd *pAttachedWnd = *Iter;\n\t\tif(pAttachedWnd == pOtherWnd)\n\t\t{\n\t\t\tbFound = true;\n\t\t\tif(bAttach == false)\n\t\t\t{\n\t\t\t\tm_AttachedWnd.erase(Iter);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(bAttach && bFound == false)\n\t{\n\t\tm_AttachedWnd.push_back(pOtherWnd);\n\t}\n}\n\nbool CMagneticWnd::IsWindowAttached(CMagneticWnd *pWnd)\n{\n\tfor(std::vector<CMagneticWnd*>::iterator Iter = m_AttachedWnd.begin(); Iter != m_AttachedWnd.end(); Iter++)\n\t{\n\t\tCMagneticWnd *pAttachedWnd = *Iter;\n\t\tif(pAttachedWnd == pWnd)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        },
        {
          "name": "MagneticWnd.h",
          "type": "blob",
          "size": 0.7265625,
          "content": "#pragma once\n\n#include <vector>\n\nclass CMagneticWnd : public CWnd\n{\npublic:\n\tCMagneticWnd(void);\n\t~CMagneticWnd(void);\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);\n\tafx_msg void OnMove(int x, int y);\n\n\tstd::vector<CMagneticWnd*> m_SnapToWnds;\n\tstd::vector<CMagneticWnd*> m_AttachedWnd;\n\tbool m_bMovedAttachedWnd;\n\tCRect m_crLastMove;\n\tbool m_bHandleWindowPosChanging;\n\npublic:\n\tvoid AddWindowToSnapTo(CMagneticWnd *pWnd)\t{ m_SnapToWnds.push_back(pWnd); }\n\tvoid SetWindowAttached(CMagneticWnd *pOther, bool bAttache);\n\tbool IsWindowAttached(CMagneticWnd *pWnd);\n\tvoid MoveMagneticWWnd(LPCRECT lpRect, BOOL bRepaint = TRUE);\n\n\tvoid SetMoveAttachedWnds(bool bMove)\t{ m_bMovedAttachedWnd = bMove; }\n};\n"
        },
        {
          "name": "MainFrm.cpp",
          "type": "blob",
          "size": 41.1650390625,
          "content": "// MainFrm.cpp : implementation of the CMainFrame class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"MainFrm.h\"\r\n#include \"afxole.h\"\r\n#include \"Misc.h\"\r\n#include \"CopyProperties.h\"\r\n#include \".\\mainfrm.h\"\r\n#include \"HyperLink.h\"\r\n#include \"tinyxml\\tinyxml.h\"\r\n#include \"Path.h\"\r\n#include \"DittoCopyBuffer.h\"\r\n#include \"HotKeys.h\"\r\n#include \"GlobalClips.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"DeleteClipData.h\"\r\n#include \"DatabaseUtilities.h\"\r\n\r\n#ifdef _DEBUG\r\n    #define new DEBUG_NEW\r\n    #undef THIS_FILE\r\n    static char THIS_FILE[] = __FILE__;\r\n#endif \r\n\r\n#define WM_ICON_NOTIFY\t\t\tWM_APP+10\r\n#define MYWM_NOTIFYICON (WM_USER+1)\r\n#define WM_TRAYNOTIFY WM_USER + 100\r\n\t\r\nIMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)\r\n\r\nBEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)\r\n\t//{{AFX_MSG_MAP(CMainFrame)\r\n\tON_WM_CREATE()\r\n\tON_COMMAND(ID_FIRST_OPTION, OnFirstOption)\r\n\tON_COMMAND(ID_FIRST_EXIT, OnFirstExit)\r\n\tON_WM_TIMER()\r\n\tON_COMMAND(ID_FIRST_SHOWQUICKPASTE, OnFirstShowquickpaste)\r\n\tON_COMMAND(ID_FIRST_TOGGLECONNECTCV, OnFirstToggleConnectCV)\r\n\tON_UPDATE_COMMAND_UI(ID_FIRST_TOGGLECONNECTCV, OnUpdateFirstToggleConnectCV)\r\n\tON_COMMAND(ID_FIRST_HELP, OnFirstHelp)\r\n\t//}}AFX_MSG_MAP\r\n\tON_MESSAGE(WM_HOTKEY, OnHotKey)\r\n\tON_MESSAGE(WM_SHOW_TRAY_ICON, OnShowTrayIcon)\r\n\tON_MESSAGE(WM_CLIPBOARD_COPIED, OnClipboardCopied)\r\n\tON_WM_CLOSE()\r\n\tON_MESSAGE(WM_ADD_TO_DATABASE_FROM_SOCKET, OnAddToDatabaseFromSocket)\r\n\tON_MESSAGE(WM_SEND_RECIEVE_ERROR, OnErrorOnSendRecieve)\r\n\tON_MESSAGE(WM_SHOW_ERROR_MSG, OnErrorMsg)\r\n\tON_COMMAND(ID_FIRST_IMPORT, OnFirstImport)\r\n\tON_WM_DESTROY()\r\n\tON_COMMAND(ID_FIRST_NEWCLIP, OnFirstNewclip)\r\n\tON_MESSAGE(WM_SET_CONNECTED, OnSetConnected)\r\n\tON_MESSAGE(WM_OPEN_CLOSE_WINDOW, OnOpenCloseWindow)\r\n\tON_MESSAGE(WM_LOAD_ClIP_ON_CLIPBOARD, OnLoadClipOnClipboard)\r\n\tON_COMMAND(ID_FIRST_GLOBALHOTKEYS, &CMainFrame::OnFirstGlobalhotkeys)\r\n\tON_MESSAGE(WM_GLOBAL_CLIPS_CLOSED, OnGlobalClipsClosed)\r\n\tON_MESSAGE(WM_OPTIONS_CLOSED, OnOptionsClosed)\r\n\tON_MESSAGE(WM_SHOW_OPTIONS, OnShowOptions)\r\n\tON_COMMAND(ID_FIRST_DELETECLIPDATA, &CMainFrame::OnFirstDeleteclipdata)\r\n\tON_MESSAGE(WM_DELETE_CLIPS_CLOSED, OnDeleteClipDataClosed)\r\n\tON_COMMAND(ID_FIRST_SAVECURRENTCLIPBOARD, &CMainFrame::OnFirstSavecurrentclipboard)\r\n\tON_MESSAGE(WM_SAVE_CLIPBOARD, &CMainFrame::OnSaveClipboardMessage)\r\n\tON_MESSAGE(WM_READD_TASKBAR_ICON, OnReAddTaskBarIcon)\r\n\tON_MESSAGE(WM_REOPEN_DATABASE, &CMainFrame::OnReOpenDatabase)\r\n\tON_MESSAGE(WM_SHOW_MSG_WINDOW, &CMainFrame::OnShowMsgWindow)\r\n\tON_MESSAGE(WM_SHOW_DITTO_GROUP, &CMainFrame::OnShowDittoGroup)\r\n\tON_COMMAND(ID_FIRST_FIXUPSTICKYCLIPORDER, &CMainFrame::OnFirstFixupstickycliporder)\r\n\tON_MESSAGE(WM_DISPLAYCHANGE, &CMainFrame::OnResolutionChange)\r\n\tON_MESSAGE(WM_TRAYNOTIFY, &CMainFrame::OnTrayNotification)\r\n\tON_MESSAGE(WM_PLAIN_TEXT_PASTE, &CMainFrame::OnPlainTextPaste)\r\n\tON_WM_WININICHANGE()\r\n\tON_COMMAND(ID_FIRST_SHOWSTARTUPMESSAGE, &CMainFrame::OnFirstShowstartupmessage)\r\n\tON_UPDATE_COMMAND_UI(ID_FIRST_SHOWSTARTUPMESSAGE, &CMainFrame::OnUpdateFirstShowstartupmessage)\r\n\tON_COMMAND(ID_FIRST_BACKUPDATABASE, &CMainFrame::OnFirstBackupdatabase)\r\n\tON_COMMAND(ID_FIRST_RESTOREDATABASE, &CMainFrame::OnFirstRestoredatabase)\r\n\tON_MESSAGE(WM_BACKUP_DB, OnBackupDb)\r\n\tON_MESSAGE(WM_RESTORE_DB, OnRestoreDb)\r\n\tON_COMMAND(ID_FIRST_DELETEALLNONUSEDCLIPS, &CMainFrame::OnFirstDeleteallnonusedclips)\r\n\tON_MESSAGE(WM_PASTE_CLIP, OnPasteClip)\r\n\tON_MESSAGE(WM_EDIT_CLIP, OnEditClip)\r\n\r\n\tON_WM_SETFOCUS()\r\nEND_MESSAGE_MAP()\r\n\r\n\tstatic UINT indicators[] = \r\n{\r\n\tID_SEPARATOR,  // status line indicator\r\n\tID_INDICATOR_CAPS, ID_INDICATOR_NUM, ID_INDICATOR_SCRL, \r\n};\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CMainFrame construction/destruction\r\n\r\nCMainFrame::CMainFrame()\r\n{\r\n    m_keyStateModifiers = 0;\r\n    m_startKeyStateTime = 0;\r\n    m_bMovedSelectionMoveKeyState = false;\r\n    m_keyModifiersTimerCount = 0;\r\n\tm_pGlobalClips = NULL;\r\n\tm_pOptions = NULL;\r\n\tm_pDeleteClips = NULL;\r\n\tm_doubleClickGroupId = -1;\r\n\tm_doubleClickGroupStartTime = 0;\r\n}\r\n\r\nCMainFrame::~CMainFrame()\r\n{\r\n    CGetSetOptions::SetMainHWND(0);\r\n}\r\n\r\nint CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n    if(CFrameWnd::OnCreate(lpCreateStruct) ==  - 1)\r\n    {\r\n        return  - 1;\r\n    }\r\n\r\n\tm_PowerManager.Start(m_hWnd);\r\n\r\n    ////Center the main window so message boxes are in the center\r\n    CRect rcScreen = DefaultMonitorRect();\r\n    CPoint cpCenter = rcScreen.CenterPoint();\r\n    MoveWindow(cpCenter.x, cpCenter.x,  1,  1);\r\n\r\n\tm_startupScreenWidth = GetScreenWidth();\r\n\tm_startupScreenHeight = GetScreenHeight();\r\n\r\n    //Then set the main window to transparent so it's never shown\r\n    //if it is shown then only the task tray icon\r\n    //m_Transparency.SetTransparent(m_hWnd, 0, true);\r\n\r\n    SetWindowText(_T(\"\"));\r\n\r\n    Log(_T(\"Setting polling timer to track focus\"));\r\n    SetTimer(ACTIVE_WINDOW_TIMER, CGetSetOptions::FocusWndTimerTimeout(), 0);\r\n\r\n\tSetTimer(READ_RANDOM_DB_FILE, CGetSetOptions::ReadRandomFileInterval() * 1000, 0);\r\n\r\n    SetWindowText(_T(\"Ditto\"));\r\n\t\r\n\tm_trayIcon.Create(this, IDR_MENU, _T(\"Ditto\"), CTrayNotifyIcon::LoadIcon(IDR_MAINFRAME), WM_TRAYNOTIFY, 0, 1);\r\n\tm_trayIcon.SetDefaultMenuItem(ID_FIRST_SHOWQUICKPASTE, FALSE);\t    \r\n\r\n\t//removed to keep Ditto from taking focus on start\r\n    //m_trayIcon.MinimiseToTray(this);\r\n\r\n\tif (CGetSetOptions::GetShowStartupMessage())\r\n\t{\r\n\t\tCString msg = theApp.m_Language.GetString(_T(\"StartupMsg\"), _T(\"Ditto is running minimized, Ditto can be opened by hot keys or by clicking the task tray icon\"));\r\n\t\tm_trayIcon.SetBalloonDetails(msg, _T(\"Ditto\"), CTrayNotifyIcon::BalloonStyle::Info, CGetSetOptions::GetBalloonTimeout());\r\n\t}\r\n\r\n\ttheApp.m_Language.UpdateTrayIconRightClickMenu(&m_trayIcon.GetMenu());\r\n\t\r\n    //Only if in release\r\n    #ifndef _DEBUG\r\n        {\r\n            //If not showing the icon show it for 40 seconds so they can get to the option\r\n            //in case they can't remember the hot keys or something like that\r\n            if(!(CGetSetOptions::GetShowIconInSysTray()))\r\n            {\r\n                SetTimer(HIDE_ICON_TIMER, 40000, 0);\r\n            }\r\n        }\r\n    #endif \r\n\r\n    //SetTimer(CLOSE_WINDOW_TIMER, ONE_HOUR*24, 0);\r\n\tSetTimer(REMOVE_OLD_TEMP_FILES, ONE_HOUR * 6, 0);\r\n    SetTimer(REMOVE_OLD_ENTRIES_TIMER, ONE_MINUTE*15, 0);\r\n\tSetTimer(CLOSE_NO_DB_WINDOW_TIMER, 10000, 0);\r\n\r\n\t//found on some computers GetTickCount gettickcount returns a smaller value than other, can't explain\r\n\t//check here to see if we need to make an adjustment\r\n\tIdleSeconds();\r\n\r\n    m_ulCopyGap = CGetSetOptions::GetCopyGap();\r\n\r\n    theApp.AfterMainCreate();\r\n\r\n    m_thread.Start(this);\r\n\r\n    return 0;\r\n}\r\n\r\nLRESULT CMainFrame::OnPlainTextPaste(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tDoTextOnlyPaste();\r\n\treturn 1;\r\n}\r\n\r\nLRESULT CMainFrame::OnTrayNotification(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (WM_MOUSEFIRST <= LOWORD(lParam) && LOWORD(lParam) <= WM_MOUSELAST)\r\n\t{\r\n\t\ttheApp.m_activeWnd.TrackActiveWnd(true);\r\n\t}\r\n\r\n\t//click on balloon\r\n\tif (lParam == 0x405)\r\n\t{\r\n\t\tSetTimer(DELAYED_SHOW_DITTO_TIMER, 100, NULL);\t\t\r\n\t}\r\n\t\r\n\tm_trayIcon.OnTrayNotification(wParam, lParam);\r\n\treturn 0L;\r\n}\r\n\r\nBOOL CMainFrame::PreCreateWindow(CREATESTRUCT &cs)\r\n{\r\n    if(cs.hMenu != NULL)\r\n    {\r\n        ::DestroyMenu(cs.hMenu); // delete menu if loaded\r\n        cs.hMenu = NULL; // no menu for this window\r\n    }\r\n\r\n    if(!CFrameWnd::PreCreateWindow(cs))\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    WNDCLASS wc;\r\n    wc.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;\r\n    wc.lpfnWndProc = AfxWndProc;\r\n    wc.cbClsExtra = 0;\r\n    wc.cbWndExtra = 0;\r\n    wc.hInstance = AfxGetInstanceHandle();\r\n    wc.hIcon = NULL;\r\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n    wc.lpszMenuName = NULL;\r\n    wc.lpszClassName = _T(\"Ditto\");\r\n\r\n    // Create the QPaste window class\r\n    if(!AfxRegisterClass(&wc))\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    cs.lpszClass = wc.lpszClassName;\r\n\r\n    return TRUE;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CMainFrame diagnostics\r\n\r\n#ifdef _DEBUG\r\n    void CMainFrame::AssertValid()const\r\n    {\r\n        CFrameWnd::AssertValid();\r\n    }\r\n\r\n    void CMainFrame::Dump(CDumpContext &dc)const\r\n    {\r\n        CFrameWnd::Dump(dc);\r\n    }\r\n\r\n#endif //_DEBUG\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CMainFrame message handlers\r\n\r\n\r\n\r\n\r\nvoid CMainFrame::OnFirstExit()\r\n{\r\n    this->SendMessage(WM_CLOSE, 0, 0);\r\n}\r\n\r\nLRESULT CMainFrame::OnHotKey(WPARAM wParam, LPARAM lParam)\r\n{\r\n    if(theApp.m_pDittoHotKey && wParam == theApp.m_pDittoHotKey->m_Atom ||\r\n\t\ttheApp.m_pDittoHotKey2 && wParam == theApp.m_pDittoHotKey2->m_Atom ||\r\n\t\ttheApp.m_pDittoHotKey3 && wParam == theApp.m_pDittoHotKey3->m_Atom)\r\n    {\r\n        //If they still have the shift/ctrl keys down\r\n        if(m_keyStateModifiers != 0 && m_quickPaste.IsWindowVisibleEx())\r\n        {\r\n            Log(_T(\"On Show Ditto HotKey, key state modifiers are still down, moving selection\"));\r\n\r\n            if(m_bMovedSelectionMoveKeyState == false)\r\n            {\r\n                Log(_T(\"Setting flag m_bMovedSelectionMoveKeyState to true, will paste when modifier keys are up\"));\r\n            }\r\n\r\n            m_quickPaste.MoveSelection(true);\r\n            m_bMovedSelectionMoveKeyState = true;\r\n        }\r\n        else if(CGetSetOptions::m_HideDittoOnHotKeyIfAlreadyShown && m_quickPaste.IsWindowTopLevel() && CGetSetOptions::GetShowPersistent() == FALSE)\r\n        {\r\n            Log(_T(\"On Show Ditto HotKey, window is already visible, hiding window\"));\r\n            m_quickPaste.HideQPasteWnd();\r\n        }\r\n        else\r\n        {\r\n            Log(_T(\"On Show Ditto HotKey, showing window\"));\r\n\r\n\t\t\tStartKeyModifierTimer();\r\n\r\n\t\t\tShowQPasteWithActiveWindowCheck();\r\n        }\r\n\r\n        //KillTimer(CLOSE_WINDOW_TIMER);\r\n        //SetTimer(CLOSE_WINDOW_TIMER, ONE_HOUR *24, 0);\r\n    }\r\n    else if(theApp.m_pPosOne && wParam == theApp.m_pPosOne->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 1 hot key\"));\r\n        DoFirstTenPositionsPaste(0);\r\n    }\r\n    else if(theApp.m_pPosTwo && wParam == theApp.m_pPosTwo->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 2 hot key\"));\r\n        DoFirstTenPositionsPaste(1);\r\n    }\r\n    else if(theApp.m_pPosThree && wParam == theApp.m_pPosThree->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 3 hot key\"));\r\n        DoFirstTenPositionsPaste(2);\r\n    }\r\n    else if(theApp.m_pPosFour && wParam == theApp.m_pPosFour->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 4 hot key\"));\r\n        DoFirstTenPositionsPaste(3);\r\n    }\r\n    else if(theApp.m_pPosFive && wParam == theApp.m_pPosFive->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 5 hot key\"));\r\n        DoFirstTenPositionsPaste(4);\r\n    }\r\n    else if(theApp.m_pPosSix && wParam == theApp.m_pPosSix->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 6 hot key\"));\r\n        DoFirstTenPositionsPaste(5);\r\n    }\r\n    else if(theApp.m_pPosSeven && wParam == theApp.m_pPosSeven->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 7 hot key\"));\r\n        DoFirstTenPositionsPaste(6);\r\n    }\r\n    else if(theApp.m_pPosEight && wParam == theApp.m_pPosEight->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 8 hot key\"));\r\n        DoFirstTenPositionsPaste(7);\r\n    }\r\n    else if(theApp.m_pPosNine && wParam == theApp.m_pPosNine->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 9 hot key\"));\r\n        DoFirstTenPositionsPaste(8);\r\n    }\r\n    else if(theApp.m_pPosTen && wParam == theApp.m_pPosTen->m_Atom)\r\n    {\r\n        Log(_T(\"Pos 10 hot key\"));\r\n        DoFirstTenPositionsPaste(9);\r\n    }\r\n    else if(theApp.m_pCopyBuffer1 && wParam == theApp.m_pCopyBuffer1->m_Atom)\r\n    {\r\n        Log(_T(\"Copy buffer 1 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(0);\r\n    }\r\n    else if(theApp.m_pPasteBuffer1 && wParam == theApp.m_pPasteBuffer1->m_Atom)\r\n    {\r\n        Log(_T(\"Paste buffer 1 hot key\"));\r\n        theApp.m_CopyBuffer.PastCopyBuffer(0);\r\n    }\r\n    else if(theApp.m_pCutBuffer1 && wParam == theApp.m_pCutBuffer1->m_Atom)\r\n    {\r\n        Log(_T(\"Cut buffer 1 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(0, true);\r\n    }\r\n    else if(theApp.m_pCopyBuffer2 && wParam == theApp.m_pCopyBuffer2->m_Atom)\r\n    {\r\n        Log(_T(\"Copy buffer 2 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(1);\r\n    }\r\n    else if(theApp.m_pPasteBuffer2 && wParam == theApp.m_pPasteBuffer2->m_Atom)\r\n    {\r\n        Log(_T(\"Paste buffer 2 hot key\"));\r\n        theApp.m_CopyBuffer.PastCopyBuffer(1);\r\n    }\r\n    else if(theApp.m_pCutBuffer2 && wParam == theApp.m_pCutBuffer2->m_Atom)\r\n    {\r\n        Log(_T(\"Cut buffer 2 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(1, true);\r\n    }\r\n    else if(theApp.m_pCopyBuffer3 && wParam == theApp.m_pCopyBuffer3->m_Atom)\r\n    {\r\n        Log(_T(\"Copy buffer 3 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(2);\r\n    }\r\n    else if(theApp.m_pPasteBuffer3 && wParam == theApp.m_pPasteBuffer3->m_Atom)\r\n    {\r\n        Log(_T(\"Paste buffer 3 hot key\"));\r\n        theApp.m_CopyBuffer.PastCopyBuffer(2);\r\n    }\r\n    else if(theApp.m_pCutBuffer3 && wParam == theApp.m_pCutBuffer3->m_Atom)\r\n    {\r\n        Log(_T(\"Cut buffer 3 hot key\"));\r\n        theApp.m_CopyBuffer.StartCopy(2, true);\r\n    }\r\n\telse if (theApp.m_pCopyBuffer4 && wParam == theApp.m_pCopyBuffer4->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Copy buffer 4 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.StartCopy(3);\r\n\t}\r\n\telse if (theApp.m_pPasteBuffer4 && wParam == theApp.m_pPasteBuffer4->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Paste buffer 4 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.PastCopyBuffer(3);\r\n\t}\r\n\telse if (theApp.m_pCutBuffer4 && wParam == theApp.m_pCutBuffer4->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Cut buffer 4 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.StartCopy(3, true);\r\n\t}\r\n\telse if (theApp.m_pCopyBuffer5 && wParam == theApp.m_pCopyBuffer5->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Copy buffer 5 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.StartCopy(4);\r\n\t\t}\r\n\telse if (theApp.m_pPasteBuffer5 && wParam == theApp.m_pPasteBuffer5->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Paste buffer 5 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.PastCopyBuffer(4);\r\n\t}\r\n\telse if (theApp.m_pCutBuffer5 && wParam == theApp.m_pCutBuffer5->m_Atom)\r\n\t{\r\n\t\tLog(_T(\"Cut buffer 5 hot key\"));\r\n\t\ttheApp.m_CopyBuffer.StartCopy(4, true);\r\n\t}\r\n\telse if(theApp.m_pTextOnlyPaste && wParam == theApp.m_pTextOnlyPaste->m_Atom)\r\n\t{\r\n\t\tDoTextOnlyPaste();\r\n\t}\r\n\telse if(theApp.m_pSaveClipboard && wParam == theApp.m_pSaveClipboard->m_Atom)\r\n\t{\r\n\t\tOnFirstSavecurrentclipboard();\r\n\t}\r\n\telse if (theApp.m_pCopyAndSaveClipboard && wParam == theApp.m_pCopyAndSaveClipboard->m_Atom)\r\n\t{\r\n\t\tLog(StrF(_T(\"START of copy and save clipboard, sending copy\")));\r\n\r\n\t\ttheApp.m_activeWnd.SendCopy(CopyReasonEnum::COPY_TO_UNKOWN);\r\n\r\n\t\tint delay = CGetSetOptions::GetCopyAndSveDelay();\r\n\t\tLog(StrF(_T(\"Copy and save clipboard, sending copy, delaying %dms before saving clipboard\"), delay));\r\n\t\tSleep(delay);\r\n\r\n\t\tLog(StrF(_T(\"Copy and save clipboard, saving clipboard\")));\r\n\t\tOnFirstSavecurrentclipboard();\r\n\r\n\t\tLog(StrF(_T(\"END of copy and save clipboard\")));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor(int i = 0; i < g_HotKeys.GetCount(); i++)\r\n\t\t{\r\n\t\t\tif(g_HotKeys[i] != NULL && \r\n\t\t\t\tg_HotKeys[i]->m_Atom == wParam && \r\n\t\t\t\tg_HotKeys[i]->m_clipId > 0)\r\n\t\t\t{\r\n\t\t\t\tif(g_HotKeys[i]->m_hkType == CHotKey::PASTE_OPEN_CLIP)\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"Pasting clip from global shortcut, clipId: %d\"), g_HotKeys[i]->m_clipId));\r\n\t\t\t\t\tPasteOrShowGroup(g_HotKeys[i]->m_clipId, -1, FALSE, TRUE, false);\r\n\t\t\t\t}\r\n\t\t\t\telse if(g_HotKeys[i]->m_hkType == CHotKey::MOVE_TO_GROUP)\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"Global hot key to save clip to group Id: %d, Sending copy to save selection to this group\"), g_HotKeys[i]->m_clipId));\r\n\r\n\t\t\t\t\tKillTimer(GROUP_DOUBLE_CLICK);\r\n\t\t\t\t\tm_doubleClickGroupId = -1;\r\n\t\t\t\t\tm_doubleClickGroupStartTime = 0;\r\n\r\n\t\t\t\t\ttheApp.SetActiveGroupId(g_HotKeys[i]->m_clipId);\r\n\t\t\t\t\ttheApp.m_activeWnd.SendCopy(CopyReasonEnum::COPY_TO_GROUP);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n    return TRUE;\r\n}\r\n\r\nvoid CMainFrame::ShowQPasteWithActiveWindowCheck()\r\n{\r\n\t//Before we show our window find the current focused window for paste into\r\n\ttheApp.m_activeWnd.TrackActiveWnd(true);\r\n\r\n\tif (CGetSetOptions::GetOpenToGroupByActiveExe() &&\r\n\t\ttheApp.m_activeWnd.ActiveWnd() != NULL)\r\n\t{\r\n\t\tCString exeName = GetProcessName(theApp.m_activeWnd.ActiveWnd());\r\n\t\tif (exeName != _T(\"\"))\r\n\t\t{\r\n\t\t\ttheApp.TryEnterOldGroupState();\r\n\t\t\tCString query = StrF(_T(\"SELECT lID FROM Main WHERE bIsGroup = 1 AND mText = '%s' COLLATE NOCASE\"), exeName);\r\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(query);\r\n\t\t\tif (q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tint groupId = q.getIntField(_T(\"lID\"));\r\n\t\t\t\t//this will revert back to the old group on hide of ditto\r\n\t\t\t\ttheApp.EnterGroupID(groupId, TRUE, TRUE);\r\n\r\n\t\t\t\tLog(StrF(_T(\"Opening Ditto to Group based on found group name, name: %s, GroupId: %d\"), exeName, groupId));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttheApp.TryEnterOldGroupState();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_quickPaste.ShowQPasteWnd(this, false, true, FALSE);\r\n}\r\n\r\nvoid CMainFrame::DoTextOnlyPaste()\r\n{\r\n\tCClipboardSaveRestore textOnlyPaste;\r\n\r\n\tLog(_T(\"Text Only paste, saving clipboard to be restored later\"));\r\n\ttextOnlyPaste.Save(TRUE);\r\n\r\n\tLog(_T(\"Text Only paste, Add cf_text or cf_unicodetext to clipboard\"));\r\n\ttextOnlyPaste.RestoreTextOnly();\r\n\r\n\tDWORD pasteDelay = CGetSetOptions::GetTextOnlyPasteDelay();\r\n\r\n\tLog(StrF(_T(\"Text Only paste, delaying %d ms before sending paste\"), pasteDelay));\r\n\r\n\tSleep(pasteDelay);\r\n\r\n\tLog(_T(\"Text Only paste, Sending paste\"));\r\n\ttheApp.m_activeWnd.SendPaste(false);\r\n\r\n\tLog(_T(\"Text Only paste, Post sending paste\"));\r\n}\r\n\r\nvoid CMainFrame::DoFirstTenPositionsPaste(int nPos)\r\n{\r\n    try\r\n\t{\r\n\t\tCString csSort = _T(\"\");\r\n\t\tCString strFilter = _T(\"\");\r\n\t\tbool pastedFromGroup = false;\r\n\r\n\t\tif (theApp.m_GroupID < 0 ||\r\n\t\t\tCGetSetOptions::GetUseUISelectedGroupForLastTenCopies() == FALSE)\r\n\t\t{\r\n\t\t\t//do not change this this directly relates to the views in the Main table\r\n\t\t\tcsSort = \"Main.bIsGroup ASC, \"\r\n\t\t\t\t\"Main.stickyClipOrder DESC, \"\r\n\t\t\t\t\"Main.clipOrder DESC\";\r\n\r\n\t\t\tif (CGetSetOptions::m_bShowAllClipsInMainList)\r\n\t\t\t{\r\n\t\t\t\tif (CGetSetOptions::GetShowGroupsInMainList())\r\n\t\t\t\t{\r\n\t\t\t\t\t//found to be slower on large databases\r\n\t\t\t\t\tstrFilter = \"((Main.bIsGroup = 1 AND Main.lParentID = -1) OR Main.bIsGroup = 0)\";\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstrFilter = \"(Main.bIsGroup = 0)\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstrFilter = \"((Main.bIsGroup = 1 AND Main.lParentID = -1) OR (Main.bIsGroup = 0 AND Main.lParentID = -1))\";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpastedFromGroup = true;\r\n\r\n\t\t\t//do not change this this directly relates to the views in the Main table\r\n\t\t\tcsSort = \"Main.bIsGroup ASC, \"\r\n\t\t\t\t\"Main.stickyClipGroupOrder DESC, \"\r\n\t\t\t\t\"Main.clipGroupOrder DESC\";\r\n\t\t\t\r\n\t\t\tif (theApp.m_GroupID >= 0)\r\n\t\t\t{\r\n\t\t\t\tstrFilter.Format(_T(\"Main.lParentID = %d\"), theApp.m_GroupID);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tCString query = StrF(_T(\"SELECT lID, bIsGroup FROM Main WHERE %s ORDER BY %s LIMIT 1 OFFSET %d\"), strFilter, csSort, nPos);\r\n\r\n\t\tLog(StrF(_T(\"Doing Last Ten Paste, Index: %d Query: %s\"), nPos, query));\r\n\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(query);\r\n\r\n        if(q.eof() == false)\r\n        {\r\n\t\t\tPasteOrShowGroup(q.getIntField(_T(\"lID\")), CGetSetOptions::GetMoveClipsOnGlobal10(), false, CGetSetOptions::m_bSendPasteOnFirstTenHotKeys, pastedFromGroup);\r\n        }\r\n    }\r\n    CATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nvoid CMainFrame::StartKeyModifierTimer()\r\n{\r\n\tif (CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tm_keyModifiersTimerCount = 0;\r\n\t\tm_bMovedSelectionMoveKeyState = false;\r\n\t\tm_startKeyStateTime = GetTickCount();\r\n\t\tm_keyStateModifiers = CAccels::GetKeyStateModifiers();\r\n\t\tSetTimer(KEY_STATE_MODIFIERS, 50, NULL);\r\n\t}\r\n}\r\n\r\nvoid CMainFrame::PasteOrShowGroup(int dbId, BOOL updateClipTime, BOOL activeTarget, BOOL sendPaste, bool pastedFromGroup)\r\n{\r\n\ttry\r\n\t{\r\n\t\tbool isGroup = false;\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT bIsGroup FROM Main WHERE lID = %d\"), dbId);\r\n\t\tif(q.eof() == false)\r\n\t\t{\r\n\t\t\tif(q.getIntField(_T(\"bIsGroup\")) > 0)\r\n\t\t\t{\r\n\t\t\t\tisGroup = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(isGroup)\r\n\t\t{\r\n\t\t\tDWORD maxDiff = (DWORD)CGetSetOptions::GetGroupDoubleClickTimeMS();\r\n\t\t\tDWORD diff = GetTickCount() - m_doubleClickGroupStartTime;\t\t\r\n\r\n\t\t\tif(m_doubleClickGroupId == dbId &&\r\n\t\t\t\tdiff < maxDiff)\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Second Press of group hot key, group Id: %d, Sending copy to save selection to this group\"), dbId));\r\n\t\t\t\t\r\n\t\t\t\tKillTimer(GROUP_DOUBLE_CLICK);\r\n\t\t\t\tm_doubleClickGroupId = -1;\r\n\t\t\t\tm_doubleClickGroupStartTime = 0;\r\n\r\n\t\t\t\ttheApp.SetActiveGroupId(dbId);\r\n\t\t\t\ttheApp.m_activeWnd.SendCopy(CopyReasonEnum::COPY_TO_GROUP);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_doubleClickGroupId = dbId;\r\n\t\t\t\tm_doubleClickGroupStartTime = GetTickCount();\r\n\r\n\t\t\t\tint doubleClickTime = CGetSetOptions::GetGroupDoubleClickTimeMS();\r\n\r\n\t\t\t\tSetTimer(GROUP_DOUBLE_CLICK, doubleClickTime, 0);\r\n\r\n\t\t\t\tLog(StrF(_T(\"First Press of group hot key, group Id: %d, timeout: %d\"), dbId, doubleClickTime));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tKillTimer(GROUP_DOUBLE_CLICK);\r\n\t\t\tm_doubleClickGroupId = -1;\r\n\t\t\tm_doubleClickGroupStartTime = 0;\r\n\r\n\t\t\tBOOL bItWas = CGetSetOptions::m_bUpdateTimeOnPaste;\r\n\t\t\tif (updateClipTime != -1)\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\tCGetSetOptions::m_bUpdateTimeOnPaste = updateClipTime;\r\n\t\t\t}\r\n\r\n\t\t\tCProcessPaste paste;\r\n\t\t\tpaste.m_pastedFromGroup = pastedFromGroup;\r\n\t\t\tpaste.GetClipIDs().Add(dbId);\r\n\r\n\t\t\tif (activeTarget != -1)\r\n\t\t\t{\r\n\t\t\t\tpaste.m_bActivateTarget = activeTarget ? true : false;;\r\n\t\t\t}\r\n\r\n\t\t\tif (sendPaste != -1)\r\n\t\t\t{\r\n\t\t\t\tpaste.m_bSendPaste = sendPaste ? true : false;\r\n\t\t\t}\r\n\t\t\tpaste.DoPaste();\r\n\t\t\ttheApp.OnPasteCompleted();\r\n\r\n\t\t\tif (updateClipTime != -1)\r\n\t\t\t{\r\n\t\t\t\tCGetSetOptions::m_bUpdateTimeOnPaste = bItWas;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nvoid CMainFrame::DoDittoCopyBufferPaste(int nCopyBuffer)\r\n{\r\n    try\r\n    {\r\n        CppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID FROM Main WHERE CopyBuffer = %d\"), nCopyBuffer);\r\n\r\n        if(q.eof() == false)\r\n        {\r\n            //Don't move these to the top\r\n            BOOL bItWas = CGetSetOptions::m_bUpdateTimeOnPaste;\r\n            CGetSetOptions::m_bUpdateTimeOnPaste = FALSE;\r\n\r\n            CProcessPaste paste;\r\n            paste.GetClipIDs().Add(q.getIntField(_T(\"lID\")));\r\n            paste.m_bActivateTarget = false;\r\n            paste.DoPaste();\r\n            theApp.OnPasteCompleted();\r\n\r\n            CGetSetOptions::m_bUpdateTimeOnPaste = bItWas;\r\n        }\r\n    }\r\n    CATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nvoid CMainFrame::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n    switch(nIDEvent)\r\n    {\r\n        case HIDE_ICON_TIMER:\r\n            {\r\n\t\t\t\tm_trayIcon.Hide();\r\n                KillTimer(nIDEvent);\r\n            }\r\n\t\t\tbreak;\r\n\r\n        case CLOSE_WINDOW_TIMER:\r\n            {\r\n                //m_quickPaste.CloseQPasteWnd();\r\n            }\r\n\t\t\tbreak;\r\n\r\n        case REMOVE_OLD_ENTRIES_TIMER:\r\n\t\t\t{\r\n                m_thread.FireDeleteEntries();\r\n            }\r\n\t\t\tbreak;\r\n\r\n\t\tcase REMOVE_OLD_TEMP_FILES:\r\n\t\t\t{\r\n            \tm_thread.FireRemoveTempFiles();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n        case KEY_STATE_MODIFIERS:\r\n            m_keyModifiersTimerCount++;\r\n            if(m_keyStateModifiers != 0)\r\n            {\r\n                BYTE keyState = CAccels::GetKeyStateModifiers();\r\n                //Have they release the key state modifiers yet(ctrl, shift, alt)\r\n                if((m_keyStateModifiers &keyState) == 0)\r\n                {\r\n                    KillTimer(KEY_STATE_MODIFIERS);\r\n                    long waitTime = (long)(GetTickCount() - m_startKeyStateTime);\r\n\r\n                    if(m_bMovedSelectionMoveKeyState || m_keyModifiersTimerCount > CGetSetOptions::GetKeyStateWaitTimerCount())\r\n                    {\r\n                        Log(StrF(_T(\"Timer KEY_STATE_MODIFIERS timeout count hit(%d), count (%d), time (%d), Move Selection from Modifer (%d) sending paste\"), CGetSetOptions::GetKeyStateWaitTimerCount(), m_keyModifiersTimerCount, waitTime, m_bMovedSelectionMoveKeyState));\r\n                        m_quickPaste.OnKeyStateUp();\r\n                    }\r\n                    else\r\n                    {\r\n                        Log(StrF(_T(\"Timer KEY_STATE_MODIFIERS count NOT hit(%d), count (%d) time (%d)\"), CGetSetOptions::GetKeyStateWaitTimerCount(), m_keyModifiersTimerCount, waitTime));\r\n                        m_quickPaste.SetKeyModiferState(false);\r\n                    }\r\n\r\n                    m_keyStateModifiers = 0;\r\n                    m_keyModifiersTimerCount = 0;\r\n                    m_bMovedSelectionMoveKeyState = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                KillTimer(KEY_STATE_MODIFIERS);\r\n            }\r\n            break;\r\n\r\n        case ACTIVE_WINDOW_TIMER:\r\n\t\t\t{\r\n\t\t\t\tif(theApp.m_bShowingQuickPaste)\r\n\t\t\t\t{\r\n\t\t\t\t\ttheApp.m_activeWnd.TrackActiveWnd(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase READ_RANDOM_DB_FILE:\r\n\t\t\t{\r\n\t\t\t\tm_thread.FireReadDbFile();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase GROUP_DOUBLE_CLICK:\r\n\t\t\t{\r\n\t\t\t\tKillTimer(GROUP_DOUBLE_CLICK);\t\t\t\r\n\r\n\t\t\t\tLog(StrF(_T(\"Processing single click of groupId %d in timer, opening ditto to this group\"), m_doubleClickGroupId));\r\n\r\n\t\t\t\tDWORD maxDiff = (DWORD)(CGetSetOptions::GetGroupDoubleClickTimeMS() * 1.5);\r\n\t\t\t\tDWORD diff = GetTickCount() - m_doubleClickGroupStartTime;\t\t\t\t\t\r\n\r\n\t\t\t\tif(diff < maxDiff)\r\n\t\t\t\t{\t\t\t\t\t\r\n\t\t\t\t\tif(m_doubleClickGroupId > -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (theApp.EnterGroupID(m_doubleClickGroupId, FALSE, TRUE))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttheApp.m_activeWnd.TrackActiveWnd(true);\r\n\t\t\t\t\t\t\tStartKeyModifierTimer();\r\n\t\t\t\t\t\t\tm_quickPaste.ShowQPasteWnd(this, false, true, FALSE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\t\r\n\t\t\t\t\tLog(StrF(_T(\"Something happened and we didn't process the group timer in time, Id: %d, Diff ms: %d, maxDiff: %d\"), m_doubleClickGroupId, diff, maxDiff));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_doubleClickGroupId = -1;\r\n\t\t\t\tm_doubleClickGroupStartTime = 0;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase SCREEN_RESOLUTION_CHANGED:\r\n\t\t\t{\r\n\t\t\t\tKillTimer(SCREEN_RESOLUTION_CHANGED);\r\n\t\t\t\tm_quickPaste.OnScreenResolutionChange();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase DELAYED_SHOW_DITTO_TIMER:\r\n\t\t{\r\n\t\t\tKillTimer(DELAYED_SHOW_DITTO_TIMER);\r\n\t\t\tm_quickPaste.ShowQPasteWnd(this, false, false, FALSE);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\t\tcase SET_WINDOWS_THEME_TIMER:\r\n\t\t{\r\n\t\t\tKillTimer(SET_WINDOWS_THEME_TIMER);\r\n\t\t\tauto theme = CGetSetOptions::GetTheme();\r\n\t\t\tif (theme == _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tCGetSetOptions::m_Theme.Load(theme);\r\n\r\n\t\t\t\tauto visible = m_quickPaste.IsWindowVisibleEx();\r\n\t\t\t\tm_quickPaste.CloseQPasteWnd();\r\n\r\n\t\t\t\tif (visible)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_quickPaste.ShowQPasteWnd(this, true, false, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\t\tcase CLOSE_NO_DB_WINDOW_TIMER:\r\n\t\t\tKillTimer(CLOSE_NO_DB_WINDOW_TIMER);\r\n\t\t\ttheApp.CloseNoDbWindow();\r\n\t\t\tbreak;\r\n\r\n    }\r\n\r\n    CFrameWnd::OnTimer(nIDEvent);\r\n}\r\n\r\nLRESULT CMainFrame::OnShowTrayIcon(WPARAM wParam, LPARAM lParam)\r\n{\r\n    if(lParam)\r\n    {\r\n        if(!m_trayIcon.IsHidden())\r\n        {\r\n            KillTimer(HIDE_ICON_TIMER);\r\n            SetTimer(HIDE_ICON_TIMER, 40000, 0);\r\n        }\r\n    }\r\n\r\n    if(wParam)\r\n    {\r\n\t\tm_trayIcon.Show();\r\n    }\r\n    else\r\n    {\r\n        m_trayIcon.Hide();\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnFirstShowquickpaste()\r\n{\r\n    m_quickPaste.ShowQPasteWnd(this, false, false, FALSE);\r\n}\r\n\r\nvoid CMainFrame::OnFirstToggleConnectCV()\r\n{\r\n    theApp.ToggleConnectCV();\r\n}\r\n\r\nvoid CMainFrame::OnUpdateFirstToggleConnectCV(CCmdUI *pCmdUI)\r\n{\r\n    theApp.UpdateMenuConnectCV(pCmdUI->m_pMenu, ID_FIRST_TOGGLECONNECTCV);\r\n}\r\n\r\nLRESULT CMainFrame::OnClipboardCopied(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tLog(_T(\"Start of function OnClipboardCopied, adding clip to thread for processing\"));\r\n\r\n\tCClip *pClip = (CClip*)wParam;\r\n\tif(pClip != NULL)\r\n\t{\r\n\t\tm_thread.AddClipToSave(pClip);\r\n\t} \r\n    \r\n    Log(_T(\"End of function OnClipboardCopied\"));\t\r\n    return TRUE;\r\n}\r\n\r\nBOOL CMainFrame::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\t//forward the mouse wheel onto the window under the cursor\r\n\t//normally windows only sends it to the window with focus, bypass this\r\n\tif ((pMsg->message == WM_MOUSEWHEEL || pMsg->message == WM_MOUSEHWHEEL) &&\r\n\t\t::GetCapture() == nullptr)\r\n\t{\r\n\t\tPOINT mouse;\r\n\t\tGetCursorPos(&mouse);\r\n\t\tHWND hwndFromPoint = ::WindowFromPoint(mouse);\r\n\r\n\t\tif (pMsg->hwnd != hwndFromPoint)\r\n\t\t{\r\n\t\t\tDWORD winProcessId = 0;\r\n\t\t\t::GetWindowThreadProcessId(hwndFromPoint, &winProcessId);\r\n\t\t\tif (winProcessId == ::GetCurrentProcessId()) //no-fail!\r\n\t\t\t{\r\n\t\t\t\tpMsg->hwnd = hwndFromPoint;\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t\t\tpMsg->message = WM_MOUSEHWHEEL;\r\n\t}\r\n\r\n    return CFrameWnd::PreTranslateMessage(pMsg);\r\n}\r\n\r\nvoid CMainFrame::OnClose()\r\n{\r\n    CloseAllOpenDialogs();\r\n\r\n    Log(_T(\"OnClose - before stop MainFrm thread\"));\r\n    m_thread.Stop();\r\n    Log(_T(\"OnClose - after stop MainFrm thread\"));\r\n\r\n    theApp.BeforeMainClose();\r\n\r\n\tm_PowerManager.Close();\r\n\r\n    CFrameWnd::OnClose();\r\n}\r\n\r\nbool CMainFrame::CloseAllOpenDialogs()\r\n{\r\n    bool bRet = false;\r\n    DWORD dwordProcessId;\r\n    DWORD dwordChildWindowProcessId;\r\n    GetWindowThreadProcessId(this->m_hWnd, &dwordProcessId);\r\n    ASSERT(dwordProcessId);\r\n\r\n    CWnd *pTempWnd = GetDesktopWindow()->GetWindow(GW_CHILD);\r\n    while((pTempWnd = pTempWnd->GetWindow(GW_HWNDNEXT)) != NULL)\r\n    {\r\n        if(pTempWnd->GetSafeHwnd() == NULL)\r\n        {\r\n            break;\r\n        }\r\n\r\n        GetWindowThreadProcessId(pTempWnd->GetSafeHwnd(), &dwordChildWindowProcessId);\r\n        if(dwordChildWindowProcessId == dwordProcessId)\r\n        {\r\n            TCHAR szTemp[100];\r\n            GetClassName(pTempWnd->GetSafeHwnd(), szTemp, 100);\r\n\r\n            // #32770 is class name for dialogs so don't process the message if it is a dialog\r\n            if(STRCMP(szTemp, _T(\"#32770\")) == 0)\r\n            {\r\n                pTempWnd->SendMessage(WM_CLOSE, 0, 0);\r\n                bRet = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    MSG msg;\r\n    while(PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))\r\n    {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    return bRet;\r\n}\r\n\r\nLRESULT CMainFrame::OnLoadClipOnClipboard(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCClip *pClip = (CClip*)wParam;\r\n    if(pClip == NULL)\r\n    {\r\n        LogSendRecieveInfo(\"---------ERROR OnLoadClipOnClipboard pClip == NULL\");\r\n        return FALSE;\r\n    }\r\n\r\n    if(pClip)\r\n    {\r\n\t\tCProcessPaste paste;\r\n\t\tpaste.m_bSendPaste = false;\r\n\t\tpaste.m_bActivateTarget = false;\r\n\t\tpaste.m_pasteOptions.m_delayRenderLockout = GetTickCount();\r\n\r\n\t\tLogSendRecieveInfo(\"---------OnLoadClipOnClipboard - Before PutFormats on clipboard\");\r\n\r\n\t\tpaste.m_pOle->PutFormatOnClipboard(&pClip->m_Formats);\r\n\t\tpaste.m_pOle->CacheGlobalData(theApp.m_cfIgnoreClipboard, NewGlobalP(\"Ignore\", sizeof(\"Ignore\")));\r\n\r\n\t\tLogSendRecieveInfo(\"---------OnLoadClipOnClipboard - After PutFormats on clipboard\");\r\n\r\n\t\tLogSendRecieveInfo(StrF(_T(\"---------OnLoadClipOnClipboard - Setting clip id: %d on ole clipboard\"), pClip->m_id));\r\n\t\tpaste.GetClipIDs().Add(pClip->m_id);\r\n\t\tpaste.DoPaste();\r\n\r\n\t\tLogSendRecieveInfo(StrF(_T(\"---------OnLoadClipOnClipboard - After paste clip id: %d on ole clipboard\"), pClip->m_id));\r\n\t}\r\n\r\n\tdelete pClip;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnAddToDatabaseFromSocket(WPARAM wParam, LPARAM lParam)\r\n{\r\n    CClipList *pClipList = (CClipList*)wParam;\r\n    if(pClipList == NULL)\r\n    {\r\n        LogSendRecieveInfo(\"---------OnAddToDatabaseFromSocket - ERROR pClipList == NULL\");\r\n        return FALSE;\r\n    }\r\n\r\n    DWORD flags = (DWORD)lParam;\r\n    if(flags & REMOTE_CLIP_ADD_TO_CLIPBOARD)\r\n    {\r\n        CClip *pClip = pClipList->GetTail();\r\n        if(pClip)\r\n        {\r\n\t\t\tLogSendRecieveInfo(\"OnAddToDatabaseFromSocket - Adding clip from socket setting clip to be put on clipboard\");\r\n\t\t\tpClip->m_param1 |= REMOTE_CLIP_ADD_TO_CLIPBOARD;\r\n\t\t}\r\n    }\r\n\r\n\tif (flags & REMOTE_CLIP_MANUAL_SEND)\r\n\t{\r\n\t\tCClip *pClip = pClipList->GetTail();\r\n\t\tif (pClip)\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(\"OnAddToDatabaseFromSocket - Adding clip from socket setting clip was a manual send from other side\");\r\n\t\t\tpClip->m_param1 |= REMOTE_CLIP_MANUAL_SEND;\r\n\t\t}\r\n\t}\r\n\r\n\tm_thread.AddRemoteClipToSave(pClipList);\r\n\r\n\tdelete pClipList;\r\n\r\n    return TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnErrorOnSendRecieve(WPARAM wParam, LPARAM lParam)\r\n{\r\n    CString csNewText = (TCHAR*)wParam;\r\n\r\n    ShowErrorMessage(_T(\"Ditto - Send/Receive Error\"), csNewText);\r\n\r\n    return TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnErrorMsg(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCString csNewText = (TCHAR*)wParam;\r\n\r\n\tShowErrorMessage(_T(\"Ditto\"), csNewText);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nCString WndName(HWND hParent)\r\n{\r\n    TCHAR cWindowText[200];\r\n\r\n    ::GetWindowText(hParent, cWindowText, 100);\r\n\r\n    int nCount = 0;\r\n\r\n    while(STRLEN(cWindowText) <= 0)\r\n    {\r\n        hParent = ::GetParent(hParent);\r\n        if(hParent == NULL)\r\n        {\r\n            break;\r\n        }\r\n\r\n        ::GetWindowText(hParent, cWindowText, 100);\r\n\r\n        nCount++;\r\n        if(nCount > 100)\r\n        {\r\n            Log(_T(\"GetTargetName reached maximum search depth of 100\"));\r\n            break;\r\n        }\r\n    }\r\n\r\n    return cWindowText;\r\n}\r\n\r\nvoid CMainFrame::OnFirstHelp()\r\n{\r\n    CHyperLink::GotoURL(_T(\"https://github.com/sabrogden/Ditto/wiki\"), SW_SHOW);\r\n}\r\n\r\nvoid CMainFrame::ShowErrorMessage(CString csTitle, CString csMessage)\r\n{\r\n    Log(StrF(_T(\"ShowErrorMessage %s - %s\"), csTitle, csMessage));\r\n\tm_trayIcon.SetBalloonDetails(csMessage, csTitle, CTrayNotifyIcon::BalloonStyle::Error, CGetSetOptions::GetBalloonTimeout());\r\n}\r\n\r\nvoid CMainFrame::OnFirstImport()\r\n{\r\n    theApp.ImportClips(theApp.m_MainhWnd);\r\n}\r\n\r\nLRESULT CMainFrame::OnSetConnected(WPARAM wParam, LPARAM lParam)\r\n{\r\n    if(wParam)\r\n    {\r\n        theApp.SetConnectCV(true);\t\t\r\n    }\r\n    else if(lParam)\r\n    {\r\n        theApp.SetConnectCV(false);\t\t\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnOpenCloseWindow(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif(wParam)\r\n\t{\r\n\t\tStartKeyModifierTimer();\r\n\t\tShowQPasteWithActiveWindowCheck();\r\n\t}\r\n\telse if(lParam)\r\n\t{\r\n\t\tm_quickPaste.HideQPasteWnd();\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnDestroy()\r\n{\r\n    CFrameWnd::OnDestroy();\r\n}\r\n\r\nvoid CMainFrame::OnFirstNewclip()\r\n{\r\n    CClipIDs IDs;\r\n    IDs.Add( - 1);\r\n    theApp.EditItems(IDs, true, true);\r\n}\r\n\r\nvoid CMainFrame::OnFirstOption()\r\n{\r\n\tif(m_pOptions != NULL)\r\n\t{\r\n\t\t::SetForegroundWindow(m_pOptions->m_hWnd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pOptions = new COptionsSheet(_T(\"\"));\r\n\r\n\t\tif(m_pOptions != NULL)\r\n\t\t{\r\n\t\t\t((COptionsSheet*)m_pOptions)->SetNotifyWnd(m_hWnd);\r\n\t\t\tm_pOptions->Create();\r\n\t\t\tm_pOptions->ShowWindow(SW_SHOW);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CMainFrame::OnFirstGlobalhotkeys()\r\n{\r\n\tif(m_pGlobalClips != NULL)\r\n\t{\r\n\t\t::SetForegroundWindow(m_pGlobalClips->m_hWnd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pGlobalClips = new GlobalClips();\r\n\r\n\t\tCAlphaBlend tran;\r\n\t\ttran.SetTransparent(m_hWnd, 0, 1);\r\n\r\n\t\tif(m_pGlobalClips != NULL)\r\n\t\t{\r\n\t\t\t((GlobalClips*)m_pGlobalClips)->SetNotifyWnd(m_hWnd);\r\n\t\t\tm_pGlobalClips->Create(IDD_GLOBAL_CLIPS, NULL);\r\n\t\t\tm_pGlobalClips->ShowWindow(SW_SHOW);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nLRESULT CMainFrame::OnShowOptions(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tOnFirstOption();\r\n\treturn 0;\r\n}\r\n\r\nLRESULT CMainFrame::OnOptionsClosed(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tBOOL themeChanged = (BOOL)wParam;\r\n\tm_trayIcon.MinimiseToTray(this);\r\n\tCAlphaBlend tran;\r\n\ttran.SetTransparent(m_hWnd, 255, 0);\r\n\r\n\tdelete m_pOptions;\r\n\tm_pOptions = NULL;\r\n\r\n\tif (themeChanged)\r\n\t{\r\n\t\tCGetSetOptions::m_Theme.Load(CGetSetOptions::GetTheme());\r\n\r\n\t\tm_quickPaste.CloseQPasteWnd();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (m_quickPaste.m_pwndPaste != NULL)\r\n\t\t{\r\n\t\t\tm_quickPaste.m_pwndPaste->PostMessage(NM_POST_OPTIONS_WINDOW);\r\n\t\t}\r\n\t}\r\n\r\n\tm_trayIcon.SetMenu(NULL, IDR_MENU);\r\n\ttheApp.m_Language.UpdateTrayIconRightClickMenu(&m_trayIcon.GetMenu());\r\n\r\n\tif (CGetSetOptions::GetShowIconInSysTray())\r\n\t{\r\n\t\tm_trayIcon.Show();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_trayIcon.Hide();\r\n\t}\r\n\t\r\n\r\n\treturn 0;\r\n}\r\n\r\nLRESULT CMainFrame::OnGlobalClipsClosed(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_trayIcon.MinimiseToTray(this);\r\n\tCAlphaBlend tran;\r\n\ttran.SetTransparent(m_hWnd, 255, 0);\r\n\r\n\tdelete m_pGlobalClips;\r\n\tm_pGlobalClips = NULL;\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CMainFrame::RefreshShowInTaskBar()\r\n{\r\n\tBOOL windowVisible = m_quickPaste.IsWindowVisibleEx();\r\n\r\n\tm_quickPaste.CloseQPasteWnd();\r\n\r\n\tif (windowVisible)\r\n\t{\r\n\t\tm_quickPaste.ShowQPasteWnd(this, true, false, true);\r\n\t}\r\n}\r\n\r\nLRESULT CMainFrame::OnDeleteClipDataClosed(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_trayIcon.MinimiseToTray(this);\r\n\tCAlphaBlend tran;\r\n\ttran.SetTransparent(m_hWnd, 255, 0);\r\n\r\n\tdelete m_pDeleteClips;\r\n\tm_pDeleteClips = NULL;\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CMainFrame::OnFirstDeleteclipdata()\r\n{\r\n\t//this->ShowWindow(SW_HIDE);\r\n\tif (m_pDeleteClips != NULL)\r\n\t{\r\n\t\t::SetForegroundWindow(m_pDeleteClips->m_hWnd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pDeleteClips = new CDeleteClipData();\r\n\r\n\t\tCAlphaBlend tran;\r\n\t\ttran.SetTransparent(m_hWnd, 0, 1);\r\n\r\n\t\tif (m_pDeleteClips != NULL)\r\n\t\t{\r\n\t\t\t((CDeleteClipData*) m_pDeleteClips)->SetNotifyWnd(m_hWnd);\r\n\t\t\tm_pDeleteClips->Create(IDD_DELETE_CLIP_DATA, NULL);\r\n\t\t\tm_pDeleteClips->ShowWindow(SW_SHOW);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nLRESULT CMainFrame::OnSaveClipboardMessage(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tOnFirstSavecurrentclipboard();\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnFirstSavecurrentclipboard()\r\n{\r\n\tLog(_T(\"Start Saving the current clipboard to the database\"));\r\n\tCClip* pClip = new CClip;\r\n\tif(pClip)\r\n\t{\r\n\t\tCClipTypes* pTypes = theApp.LoadTypesFromDB();\r\n\t\tif(pTypes)\r\n\t\t{\r\n\t\t\tif(pClip->LoadFromClipboard(pTypes, false, _T(\"\")))\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Loaded clips from the clipboard, sending message to save to the db\"));\r\n\t\t\t\t::PostMessage(m_hWnd, WM_CLIPBOARD_COPIED, (WPARAM)pClip, 0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLog(_T(\"Failed to load clips from the clipboard, not saving to db\"));\r\n\t\t\t\tdelete pClip;\r\n\t\t\t\tpClip = NULL;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(_T(\"Failed to load supported types from the db, not saving to the db\"));\r\n\t\t}\r\n\t}\r\n\tLog(_T(\"Start Saving the current clipboard to the database\"));\r\n}\r\n\r\nLRESULT CMainFrame::OnReAddTaskBarIcon(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif(CGetSetOptions::GetShowIconInSysTray())\r\n\t{\r\n\t\tm_trayIcon.SetIcon(CTrayNotifyIcon::LoadIcon(IDR_MAINFRAME));\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnReOpenDatabase(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tLog(StrF(_T(\"OnReOpenDatabase, Start closing and reopening database Delay: %d\"), CGetSetOptions::GetWindowsResumeDelayReOpenDbMS()));\r\n\r\n\ttry \r\n\t{\r\n\t\tSleep(CGetSetOptions::GetWindowsResumeDelayReOpenDbMS());\r\n\t\tm_quickPaste.CloseQPasteWnd();\r\n\t\ttheApp.m_db.close();\r\n\t\tOpenDatabase(CGetSetOptions::GetDBPath());\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\tLog(StrF(_T(\"OnReOpenDatabase, End closing and reopening database Delay: %d\"), CGetSetOptions::GetWindowsResumeDelayReOpenDbMS()));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnShowMsgWindow(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCString *pMsg = (CString*)wParam;\r\n\tint clipId = (int)lParam;\r\n\r\n\tm_trayIcon.SetBalloonDetails(pMsg->GetBuffer(), _T(\"Ditto\"), CTrayNotifyIcon::BalloonStyle::Info, CGetSetOptions::GetBalloonTimeout());\r\n\r\n\tdelete pMsg;\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnShowDittoGroup(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tint groupId = (int)wParam;\r\n\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT bIsGroup FROM Main WHERE lID = %d\"), groupId);\r\n\tif(q.eof() == false)\r\n\t{\r\n\t\tif(q.getIntField(_T(\"bIsGroup\")) > 0)\r\n\t\t{\r\n\t\t\tPasteOrShowGroup(groupId, FALSE, FALSE, FALSE, false);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnFirstFixupstickycliporder()\r\n{\r\n\tReOrderStickyClips(-1, theApp.m_db);\r\n}\r\n\r\nLRESULT CMainFrame::OnResolutionChange(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (m_startupScreenWidth != GetScreenWidth() ||\r\n\t\tm_startupScreenHeight != GetScreenHeight())\r\n\t{\r\n\t\tm_startupScreenWidth = GetScreenWidth();\r\n\t\tm_startupScreenHeight = GetScreenHeight();\r\n\r\n\t\tSetTimer(SCREEN_RESOLUTION_CHANGED, 1000, NULL);\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnWinIniChange(LPCTSTR lpszSection)\r\n{\r\n\tCFrameWnd::OnWinIniChange(lpszSection);\r\n\r\n\tif (lpszSection != NULL &&\r\n\t\twcscmp(lpszSection, L\"ImmersiveColorSet\") == 0)\r\n\t{\r\n\t\tLog(StrF(_T(\"OnWinIniChange %s, setting timer to 1000ms to change theme\"), lpszSection));\r\n\t\tKillTimer(SET_WINDOWS_THEME_TIMER);\r\n\t\tSetTimer(SET_WINDOWS_THEME_TIMER, 1000, NULL);\r\n\t}\r\n}\r\n\r\n\r\nvoid CMainFrame::OnFirstShowstartupmessage()\r\n{\r\n\tBOOL existing = CGetSetOptions::GetShowStartupMessage();\r\n\tCGetSetOptions::SetShowStartupMessage(!existing);\r\n}\r\n\r\n\r\nvoid CMainFrame::OnUpdateFirstShowstartupmessage(CCmdUI *pCmdUI)\r\n{\r\n\tif (pCmdUI == NULL ||\r\n\t\tpCmdUI->m_pMenu == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetShowStartupMessage())\r\n\t{\r\n\t\tpCmdUI->m_pMenu->CheckMenuItem(ID_FIRST_SHOWSTARTUPMESSAGE, MF_CHECKED);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpCmdUI->m_pMenu->CheckMenuItem(ID_FIRST_SHOWSTARTUPMESSAGE, MF_UNCHECKED);\r\n\t}\r\n}\r\n\r\n\r\nvoid CMainFrame::OnFirstBackupdatabase()\r\n{\r\n\tBackupDbPrompt(m_hWnd);\r\n}\r\n\r\nvoid CMainFrame::OnFirstRestoredatabase()\r\n{\r\n\tRestoreDbPrompt(m_hWnd);\r\n}\r\n\r\nLRESULT CMainFrame::OnBackupDb(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tOnFirstBackupdatabase();\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnRestoreDb(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tOnFirstRestoredatabase();\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnFirstDeleteallnonusedclips()\r\n{\r\n\tint nRet = MessageBox(theApp.m_Language.GetString(\"Delete_All_Non_Used_Clips\", \"Delete all clips that are not groups, in groups, marked as never auto delete, has a shortcut key or marked as sticky.\\r\\n\\r\\nThis cannot be undone.\"), _T(\"Ditto\"), MB_YESNO | MB_TOPMOST);\r\n\tif (nRet == IDNO)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tDeleteNonUsedClips(false);\r\n\r\n\ttheApp.RefreshView();\r\n}\r\n\r\nLRESULT CMainFrame::OnPasteClip(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tPasteOrShowGroup((int)wParam, TRUE, FALSE, TRUE, false);\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CMainFrame::OnEditClip(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCClipIDs IDs;\r\n\tIDs.Add((int)wParam);\r\n\r\n\tbool textOnly = false;\r\n\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t{\r\n\t\ttextOnly = true;\r\n\t}\r\n\r\n\ttheApp.EditItems(IDs, true, textOnly);\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CMainFrame::OnSetFocus(CWnd* pOldWnd)\r\n{\r\n\tCFrameWnd::OnSetFocus(pOldWnd);\r\n\r\n\t//int nRet = MessageBox(_T(\"focused\"), _T(\"Ditto\"), MB_YESNO | MB_TOPMOST);\r\n\r\n\t// TODO: Add your message handler code here\r\n}\r\n"
        },
        {
          "name": "MainFrm.h",
          "type": "blob",
          "size": 5.6259765625,
          "content": "#pragma once\r\n\r\n//#include \"SystemTray.h\"\r\n#include \"QuickPaste.h\"\r\n#include \"ToolTipEx.h\"\r\n#include \"MainFrmThread.h\"\r\n#include \"ClipboardSaveRestore.h\"\r\n#include \"PowerManager.h\"\r\n#include \"DittoPopupWindow.h\"\r\n#include \"NTray.h\"\r\n\r\n#define CLOSE_WINDOW_TIMER\t\t\t\t1\t\r\n#define HIDE_ICON_TIMER\t\t\t\t\t2\r\n#define REMOVE_OLD_ENTRIES_TIMER\t\t3\r\n#define REMOVE_OLD_TEMP_FILES\t\t\t6\r\n#define END_DITTO_BUFFER_CLIPBOARD_TIMER\t7\r\n#define KEY_STATE_MODIFIERS\t\t\t\t8\r\n#define ACTIVE_WINDOW_TIMER\t\t\t\t9\r\n#define TEXT_ONLY_PASTE\t\t\t\t\t11\r\n#define READ_RANDOM_DB_FILE\t\t\t\t12\r\n#define GROUP_DOUBLE_CLICK\t\t\t\t13\r\n#define CLOSE_POPUP_MSG_WND\t\t\t\t14\r\n#define SCREEN_RESOLUTION_CHANGED\t\t15\r\n#define DELAYED_SHOW_DITTO_TIMER\t\t16\r\n#define SET_WINDOWS_THEME_TIMER\t\t\t17\r\n#define CLOSE_NO_DB_WINDOW_TIMER        18\r\n\r\nclass CMainFrame: public CFrameWnd\r\n{\r\npublic:\r\n    CMainFrame();\r\nprotected:\r\n    DECLARE_DYNAMIC(CMainFrame)\r\n\r\n    // Attributes\r\npublic:\r\n\r\n    // Operations\r\npublic:\r\n\r\n    BOOL ResetKillDBTimer();\r\n\r\n    // Overrides\r\n    // ClassWizard generated virtual function overrides\r\n    //{{AFX_VIRTUAL(CMainFrame)\r\npublic:\r\n    virtual BOOL PreCreateWindow(CREATESTRUCT &cs);\r\n    //\tvirtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);\r\n    //}}AFX_VIRTUAL\r\n\r\n    // Implementation\r\npublic:\r\n    virtual ~CMainFrame();\r\n    #ifdef _DEBUG\r\n        virtual void AssertValid()const;\r\n        virtual void Dump(CDumpContext &dc)const;\r\n    #endif \r\n\r\n    CQuickPaste m_quickPaste;\r\n    //CSystemTray m_TrayIcon;\r\n\tCTrayNotifyIcon m_trayIcon;\r\n    ULONG m_ulCopyGap;\r\n    CString m_csKeyboardPaste;\r\n    CAlphaBlend m_Transparency;\r\n    BYTE m_keyStateModifiers;\r\n    DWORD m_startKeyStateTime;\r\n    bool m_bMovedSelectionMoveKeyState;\r\n    short m_keyModifiersTimerCount;\r\n    HWND m_tempFocusWnd;\r\n    CMainFrmThread m_thread;\r\n\tCDialog *m_pGlobalClips;\r\n\tCDialog *m_pDeleteClips;\r\n\tCPropertySheet *m_pOptions;\r\n\tint m_doubleClickGroupId;\r\n\tDWORD m_doubleClickGroupStartTime;\r\n\tCPowerManager m_PowerManager;\r\n\tint m_startupScreenWidth;\r\n\tint m_startupScreenHeight;\r\n    CRichEditCtrlEx m_richEditTextConverter;\r\n\r\n    void DoDittoCopyBufferPaste(int nCopyBuffer);\r\n    void DoFirstTenPositionsPaste(int nPos);\r\n\tvoid PasteOrShowGroup(int dbId, BOOL updateClipTime, BOOL activeTarget, BOOL sendPaste, bool pastedFromGroup);\r\n\r\n\tvoid StartKeyModifierTimer();\r\n\r\n\tbool PasteQuickPasteEntry(CString csQuickPaste);\r\n    bool SaveQuickPasteEntry(CString csQuickPaste, CClipList *pClipList);\r\n    void ShowErrorMessage(CString csTitle, CString csMessage);\r\n    bool CloseAllOpenDialogs();\r\n\tvoid DoTextOnlyPaste();\r\n\tvoid RefreshShowInTaskBar();\r\n\r\n    void ShowEditWnd(CClipIDs &Ids);\r\n\r\n\r\n    // Generated message map functions\r\nprotected:\r\n    //{{AFX_MSG(CMainFrame)\r\n    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\r\n    afx_msg void OnFirstOption();\r\n    afx_msg void OnFirstExit();\r\n    afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);\r\n    afx_msg void OnDrawClipboard();\r\n    afx_msg void OnTimer(UINT_PTR nIDEvent);\r\n    afx_msg void OnFirstShowquickpaste();\r\n    afx_msg void OnFirstToggleConnectCV();\r\n    afx_msg void OnUpdateFirstToggleConnectCV(CCmdUI *pCmdUI);\r\n    afx_msg void OnFirstHelp();\r\n    //}}AFX_MSG\r\n    afx_msg LRESULT OnHotKey(WPARAM wParam, LPARAM lParam);\r\n\tvoid ShowQPasteWithActiveWindowCheck();\r\n    afx_msg LRESULT OnShowTrayIcon(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnClipboardCopied(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnAddToDatabaseFromSocket(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnErrorOnSendRecieve(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnErrorMsg(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnSetConnected(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnOpenCloseWindow(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnLoadClipOnClipboard(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnGlobalClipsClosed(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnDeleteClipDataClosed(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnOptionsClosed(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnShowOptions(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnSaveClipboardMessage(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnReAddTaskBarIcon(WPARAM wParam, LPARAM lParam);\r\nDECLARE_MESSAGE_MAP()public:\r\n    virtual BOOL PreTranslateMessage(MSG *pMsg);\r\n    afx_msg void OnClose();\r\n    afx_msg void OnFirstImport();\r\n    afx_msg void OnDestroy();\r\n    afx_msg void OnFirstNewclip();\r\n\tafx_msg void OnFirstGlobalhotkeys();\r\n\tafx_msg void OnFirstDeleteclipdata();\r\n\tafx_msg void OnFirstSavecurrentclipboard();\r\n\tafx_msg LRESULT OnReOpenDatabase(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnShowMsgWindow(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnShowDittoGroup(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnFirstFixupstickycliporder();\r\n\tafx_msg LRESULT OnResolutionChange(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnTrayNotification(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnPlainTextPaste(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnWinIniChange(LPCTSTR lpszSection);\r\n\tafx_msg void OnFirstShowstartupmessage();\r\n\tafx_msg void OnUpdateFirstShowstartupmessage(CCmdUI *pCmdUI);\r\n\tafx_msg void OnFirstBackupdatabase();\r\n\tafx_msg void OnFirstRestoredatabase();\r\n\tafx_msg LRESULT OnRestoreDb(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnBackupDb(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnFirstDeleteallnonusedclips();\r\n    afx_msg LRESULT OnPasteClip(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnEditClip(WPARAM wParam, LPARAM lParam);\r\n    afx_msg void OnSetFocus(CWnd* pOldWnd);\r\n};\r\n"
        },
        {
          "name": "MainFrmThread.cpp",
          "type": "blob",
          "size": 5.8662109375,
          "content": "#include \"stdafx.h\"\r\n#include \"MainFrmThread.h\"\r\n#include \"DatabaseUtilities.h\"\r\n#include \"Options.h\"\r\n#include \"Misc.h\"\r\n#include \"cp_main.h\"\r\n\r\nCMainFrmThread::CMainFrmThread(void)\r\n{\r\n\tm_threadName = \"CMainFrmThread\";\r\n    for(int eventEnum = 0; eventEnum < ECMAINFRMTHREADEVENTS_COUNT; eventEnum++)\r\n    {\r\n        AddEvent(eventEnum);\r\n    }\r\n}\r\n\r\nCMainFrmThread::~CMainFrmThread(void)\r\n{\r\n\r\n}\r\n\r\nvoid CMainFrmThread::AddClipToSave(CClip *pClip)\r\n{\r\n\tATL::CCritSecLock csLock(m_cs.m_sect);\r\n\r\n\tLog(_T(\"Adding clip to thread for save to db\"));\r\n\tm_saveClips.AddTail(pClip);\r\n\tFireEvent(SAVE_CLIPS);\r\n}\r\n\r\nvoid CMainFrmThread::AddRemoteClipToSave(CClipList *pClipList)\r\n{\r\n\tATL::CCritSecLock csLock(m_cs.m_sect);\r\n\r\n\tLog(_T(\"Adding REMOTE clip to thread for save to db\"));\r\n\t\r\n\tPOSITION pos = pClipList->GetHeadPosition();\r\n\twhile(pos)\r\n\t{\r\n\t\tCClip *pClip = pClipList->GetNext(pos);\r\n\t\tm_saveRemoteClips.AddTail(pClip);\r\n\t}\r\n\r\n\t//local cliplist now owns the clip memory\r\n\tpClipList->RemoveAll();\r\n\t\r\n\tFireEvent(SAVE_REMOTE_CLIPS);\r\n}\r\n\r\nvoid CMainFrmThread::OnEvent(int eventId, void *param)\r\n{\r\n    switch((eCMainFrmThreadEvents)eventId)\r\n    {\r\n        case DELETE_ENTRIES:\r\n            OnDeleteEntries();\r\n            break;\r\n        case REMOVE_TEMP_FILES:\r\n            OnRemoveTempFiles();\r\n            break;\r\n\t\tcase SAVE_CLIPS:\r\n\t\t\tOnSaveClips();\r\n\t\t\tbreak;\r\n\t\tcase SAVE_REMOTE_CLIPS:\r\n\t\t\tOnSaveRemoteClips();\r\n\t\t\tbreak;\r\n\t\tcase READ_DB_FILE:\r\n\t\t\tOnReadDbFile();\r\n\t\t\tbreak;\r\n    }\r\n}\r\n\r\n//try and keep our db file in windows cache by randomly reading some data\r\n//not sure if this does what i think it does but looking into issues with slow access on large dbs\r\nvoid CMainFrmThread::OnReadDbFile()\r\n{\r\n\tdouble idle = IdleSeconds();\r\n\r\n\tif (idle < CGetSetOptions::ReadRandomFileIdleMin())\r\n\t{\r\n\t\tCString dbFile = CGetSetOptions::GetDBPath();\r\n\t\t__int64 dbSize = FileSize(dbFile);\r\n\r\n\t\tsrand((UINT)time(NULL));\r\n\r\n\t\tint random = rand() % (dbSize - 1024) + 1;\r\n\r\n\t\tCFile f;\r\n\t\tif (f.Open(dbFile, CFile::modeRead | CFile::shareDenyNone))\r\n\t\t{\r\n\t\t\tf.Seek(random, 0);\r\n\t\t\tchar data[1024];\r\n\t\t\tf.Read(&data, 1024);\r\n\r\n\t\t\tf.Close();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CMainFrmThread::OnDeleteEntries()\r\n{\r\n    RemoveOldEntries(true);\r\n}\r\n\r\nvoid CMainFrmThread::OnRemoveTempFiles()\r\n{\r\n\tDeleteDittoTempFiles(TRUE);\r\n}\r\n\r\nvoid CMainFrmThread::OnSaveClips()\r\n{\r\n\tCClipList *pLocalClips = new CClipList();\r\n\r\n\tCopyReasonEnum::CopyReason copyReason = CopyReasonEnum::COPY_TO_UNKOWN;\r\n\r\n\t//Save the clips locally\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_cs.m_sect);\r\n\r\n\t\tPOSITION pos;\r\n\t\tCClip* pClip;\r\n\r\n\t\tpos = m_saveClips.GetHeadPosition();\r\n\t\twhile(pos)\r\n\t\t{\r\n\t\t\tpClip = m_saveClips.GetNext(pos);\r\n\t\t\tcopyReason = pClip->m_copyReason;\r\n\t\t\tpLocalClips->AddTail(pClip);\r\n\t\t}\r\n\r\n\t\t//pLocalClips now own, the clips\r\n\t\tm_saveClips.RemoveAll();\r\n\t}\r\n\r\n\tLog(_T(\"SaveCopyClips Before AddToDb\")); \r\n\r\n\tint count = pLocalClips->AddToDB(true);\r\n\r\n\tLog(StrF(_T(\"SaveCopyclips After AddToDb, Count: %d\"), count));\r\n\r\n\tif(count > 0)\r\n\t{\r\n\t\tint Id = pLocalClips->GetTail()->m_id;\r\n\r\n\t\tLog(StrF(_T(\"SaveCopyclips After AddToDb, Id: %d Before OnCopyCopyCompleted\"), Id));\r\n\r\n\t\ttheApp.OnCopyCompleted(Id, count, copyReason);\r\n\r\n\t\tLog(StrF(_T(\"SaveCopyclips After AddToDb, Id: %d After OnCopyCopyCompleted\"), Id));\r\n\r\n\t\tif (pLocalClips->GetTail()->m_copyReason == CopyReasonEnum::COPY_TO_GROUP &&\r\n\t\t\tCGetSetOptions::GetShowMsgWndOnCopyToGroup())\r\n\t\t{\r\n\t\t\tCString groupName;\r\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT mText FROM Main WHERE lID = %d\"), pLocalClips->GetTail()->m_parentId);\r\n\t\t\tif (q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tgroupName = q.getStringField(0);\r\n\t\t\t}\r\n\r\n\t\t\tCString *pMsg = new CString();\r\n\t\t\tpMsg->Format(_T(\"Saved new clip \\\"%s\\\"\\r\\ndirectly to the group \\\"%s\\\"\"), pLocalClips->GetTail()->m_Desc.Left(35), groupName);\r\n\r\n\t\t\ttheApp.m_pMainFrame->PostMessageW(WM_SHOW_MSG_WINDOW, (WPARAM) pMsg, pLocalClips->GetTail()->m_parentId);\r\n\t\t}\r\n\t\r\n\t\tif(CGetSetOptions::m_lAutoSendClientCount > 0)\r\n\t\t{\r\n\t\t\tm_sendToClientThread.FireSendToClient(pLocalClips);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tdelete pLocalClips;\r\n}\r\n\r\nvoid CMainFrmThread::OnSaveRemoteClips()\r\n{\r\n\tLogSendRecieveInfo(\"---------Start of OnSaveRemoteClips\");\r\n\r\n\tCClipList *pLocalClips = new CClipList();\r\n\r\n\t//Save the clips locally\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_cs.m_sect);\r\n\r\n\t\tPOSITION pos;\r\n\t\tCClip* pClip;\r\n\r\n\t\tpos = m_saveRemoteClips.GetHeadPosition();\r\n\t\twhile(pos)\r\n\t\t{\r\n\t\t\tpClip = m_saveRemoteClips.GetNext(pos);\r\n\t\t\tpLocalClips->AddTail(pClip);\r\n\t\t}\r\n\r\n\t\t//pLocalClips now own, the clips\r\n\t\tm_saveRemoteClips.RemoveAll();\r\n\t}\r\n\r\n\tLogSendRecieveInfo(\"---------OnSaveRemoteClips - Before AddToDB\");\r\n\r\n\tint count = pLocalClips->AddToDB(true);\r\n\r\n\tLogSendRecieveInfo(\"---------OnSaveRemoteClips - After AddToDB\");\r\n\r\n\t//are we supposed to add this clip to the clipboard\r\n\tCClip *pLastClip = pLocalClips->GetTail();\r\n\tif (CGetSetOptions::GetShowMsgWhenReceivingManualSentClip())\r\n\t{\r\n\t\tif (pLastClip && (pLastClip->m_param1 & REMOTE_CLIP_MANUAL_SEND))\r\n\t\t{\r\n\t\t\tCString *pMsg = new CString();\r\n\r\n\t\t\t//baloon message can only show 254 characters\r\n\t\t\tpMsg->Format(_T(\"Received remote clip\\r\\n\\r\\n%s\"), pLastClip->m_Desc.Left(225));\r\n\r\n\t\t\ttheApp.m_pMainFrame->PostMessageW(WM_SHOW_MSG_WINDOW, (WPARAM)pMsg, pLocalClips->GetTail()->m_parentId);\r\n\t\t}\r\n\t}\r\n\r\n\tif(pLastClip && (pLastClip->m_param1 & REMOTE_CLIP_ADD_TO_CLIPBOARD))\r\n\t{\r\n\t\tLogSendRecieveInfo(\"---------OnSaveRemoteClips - Before Posting msg to main thread to set clipboard\");\r\n\r\n\t\t//set the clipboard on the main thread, i was having a problem with setting the clipboard on a thread\r\n\t\t//guess it needs to be set on the main thread\r\n\t\t//main window will clear this memory\r\n\t\tPostMessage(theApp.m_MainhWnd, WM_LOAD_ClIP_ON_CLIPBOARD, (LPARAM)pLastClip, 0);\r\n\r\n\t\tLogSendRecieveInfo(\"---------OnSaveRemoteClips - After Posting msg to main thread to set clipboard\");\r\n\r\n\t\tpLocalClips->RemoveTail();\r\n\t}\t\r\n\r\n\ttheApp.RefreshView();\r\n\r\n\tdelete pLocalClips;\r\n\r\n\tLogSendRecieveInfo(\"---------End of OnSaveRemoteClips\");\r\n}"
        },
        {
          "name": "MainFrmThread.h",
          "type": "blob",
          "size": 0.9814453125,
          "content": "#pragma once\n#include \"EventThread.h\"\n#include \"Clip.h\"\n#include \"AutoSendToClientThread.h\"\n#include <afxmt.h>\n\nclass CMainFrmThread : public CEventThread\n{\npublic:\n    CMainFrmThread(void);\n    ~CMainFrmThread(void);\n\n    enum eCMainFrmThreadEvents\n    {\n        DELETE_ENTRIES, \n        REMOVE_TEMP_FILES, \n\t\tSAVE_CLIPS,\n\t\tSAVE_REMOTE_CLIPS,\n\t\tREAD_DB_FILE,\n\n        ECMAINFRMTHREADEVENTS_COUNT  //must be last\n    };\n\n    void FireDeleteEntries() { FireEvent(DELETE_ENTRIES); }\n    void FireRemoveTempFiles() { FireEvent(REMOVE_TEMP_FILES); }\n\tvoid FireReadDbFile() { FireEvent(READ_DB_FILE); }\n\n\tvoid AddClipToSave(CClip *pClip);\n\tvoid AddRemoteClipToSave(CClipList *pClipList);\n\nprotected:\n    virtual void OnEvent(int eventId, void *param);\n\n    void OnDeleteEntries();\n    void OnRemoveTempFiles();\n\tvoid OnSaveClips();\n\tvoid OnSaveRemoteClips();\n\tvoid OnReadDbFile();\n\n\tCCriticalSection m_cs;\n\tCClipList m_saveClips;\n\tCClipList m_saveRemoteClips;\n\tCAutoSendToClientThread m_sendToClientThread;\n};\n"
        },
        {
          "name": "MainTable.cpp",
          "type": "blob",
          "size": 5.9873046875,
          "content": "// MainTable.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"MainTable.h\"\n#include \"DatabaseUtilities.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMainTable\n\nIMPLEMENT_DYNAMIC(CMainTable, CDaoRecordset)\n\nCMainTable::CMainTable(CDaoDatabase* pdb)\n\t: CDaoRecordset(pdb)\n{\n\t//{{AFX_FIELD_INIT(CMainTable)\n\tm_lID = 0;\n\tm_lDate = 0;\n\tm_strText = _T(\"\");\n\tm_lShortCut = 0;\n\tm_lDontAutoDelete = 0;\n\tm_lTotalCopySize = 0;\n\n\tm_bIsGroup = FALSE;\n\tm_lParentID = 0;\n\tm_dOrder = 0;\n\tm_lDataID = 0;\n\n\tm_nFieldCount = m_nFields = 10;\n\t//}}AFX_FIELD_INIT\n\tm_nDefaultType = dbOpenDynaset;\n\tm_bBindFields = true;\n}\n\nCString CMainTable::GetDefaultDBName()\n{\n\treturn GetDBName();\n}\n\nCString CMainTable::GetDefaultSQL()\n{\n\treturn _T(\"[Main]\");\n}\n\nvoid CMainTable::DoFieldExchange(CDaoFieldExchange* pFX)\n{\n\t// make sure this isn't called when we aren't using bound fields\n\tVERIFY( m_bBindFields == true );\n\n\t//{{AFX_FIELD_MAP(CMainTable)\n\tpFX->SetFieldType(CDaoFieldExchange::outputColumn);\n\tDFX_Long(pFX, _T(\"[lID]\"), m_lID);\n\tDFX_Long(pFX, _T(\"[lDate]\"), m_lDate);\n\tDFX_Text(pFX, _T(\"[mText]\"), m_strText);\n\tDFX_Long(pFX, _T(\"[lShortCut]\"), m_lShortCut);\n\tDFX_Long(pFX, _T(\"[lDontAutoDelete]\"), m_lDontAutoDelete);\n\tDFX_Long(pFX, _T(\"[lTotalCopySize]\"), m_lTotalCopySize);\n\t// GROUPS\n\tDFX_Bool(pFX, _T(\"[bIsGroup]\"), m_bIsGroup);\n\tDFX_Long(pFX, _T(\"[lParentID]\"), m_lParentID);\n\tDFX_Double(pFX, _T(\"[dOrder]\"), m_dOrder);\n\t// sharing data\n\tDFX_Long(pFX, _T(\"[lDataID]\"), m_lDataID);\n\t//}}AFX_FIELD_MAP\n}\n\nvoid CMainTable::Open(int nOpenType , LPCTSTR lpszSql , int nOptions)\n{\n\tm_pDatabase = theApp.EnsureOpenDB();\n\tOnQuery();\n\tCDaoRecordset::Open(nOpenType, lpszSql, nOptions);\n}\n\nvoid CMainTable::Requery()\n{\n\tOnQuery();\n\tCDaoRecordset::Requery();\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CMainTable member functions\n\nCString CMainTable::GetDisplayText( int nMaxLines )\n{\nCString text = m_strText;\n\t// assign tabs to 2 spaces (rather than the default 8)\n\ttext.Replace(\"\\t\", \"  \");\n\n\tif( g_Opt.m_bDescShowLeadingWhiteSpace )\n\t\treturn text;\n\t// else, remove the leading indent from every line.\n\n\t// get the lines\nCString token;\nCStringArray tokens;\nCTokenizer tokenizer(text,\"\\r\\n\");\n\tfor( int nLines=0; nLines < nMaxLines && tokenizer.Next(token); nLines++ )\n\t{\n\t\ttokens.Add( token );\n\t}\n\n\t// remove each line's indent\nchar chFirst;\nCString line;\nint count = tokens.GetSize();\n\ttext = \"\";\n\tfor( int i=0; i < count; i++ )\n\t{\n\t\tline = tokens.ElementAt(i);\n\t\tchFirst = line.GetAt(0);\n\t\tif( chFirst == ' ' || chFirst == '\\t' )\n\t\t{\n\t\t\ttext += \" \"; // show indication that the line is modified\n\t\t\tline.TrimLeft();\n\t\t\ttext += line;\n\t\t}\n\t\telse\n\t\t\ttext += line;\n\t\ttext += \"\\n\";\n\t}\n\n\treturn text;\n}\n\n// assigns the new autoincr ID to m_lID\nvoid CMainTable::AddNew()\n{\n\tCDaoRecordset::AddNew();\n\t// get the new, automatically assigned ID\nCOleVariant varID;\n\tGetFieldValue(\"lID\", varID);\n\tm_lID = varID.lVal;\n}\n\nvoid CMainTable::OnQuery()\n{\n}\n\nbool CMainTable::SetBindFields(bool bVal)\n{\nbool bOld = m_bBindFields;\n\n\tm_bBindFields = bVal;\n\n\tif(m_bBindFields)\n\t\tm_nFields = m_nFieldCount;\n\telse\n\t\tm_nFields = 0;\n\n\treturn bOld;\n}\n\n// copies the current source record to this current record\nvoid CMainTable::CopyRec(CMainTable& source)\n{\n//\tm_lID = source.m_lID;\n\tm_lDate = source.m_lDate;\n\tm_strText = source.m_strText;\n//\tm_lShortCut = source.m_lShortCut; // don't copy the shortcut\n\tm_lDontAutoDelete = source.m_lDontAutoDelete;\n\tm_lTotalCopySize = source.m_lTotalCopySize;\n\tm_lDataID = source.m_lDataID;\n\n\tm_bIsGroup = source.m_bIsGroup;\n\tm_lParentID = source.m_lParentID;\n\tm_dOrder = source.m_dOrder;\n}\n\n// makes a new copy of the current record and moves to the copy record\nvoid CMainTable::NewCopyRec()\n{\n\tif( IsBOF() || IsEOF() )\n\t\treturn;\n\nCMainTable temp;\n\ttemp.CopyRec( *this ); // temporary copy\n\tAddNew(); // overridden to fetch the autoincr lID\n\tCopyRec( temp );\n\tUpdate();\n}\n\n// only deletes from Main\nBOOL CMainTable::DeleteAll()\n{\n\tBOOL bRet = FALSE;\n\ttry\n\t{\n\t\ttheApp.EnsureOpenDB();\n\t\ttheApp.m_pDatabase->Execute(\"DELETE * FROM Main\", dbFailOnError);\n\t\tbRet = TRUE;\n\t}\n\tcatch(CDaoException* e)\n\t{\n\t\tAfxMessageBox(e->m_pErrorInfo->m_strDescription);\n\t\te->Delete();\n\t}\n\n\treturn bRet;\n}\n\nvoid CMainTable::LoadAcceleratorKeys( CAccels& accels )\n{\n\tCMainTable recset;\n\n\ttry\n\t{\n\t\trecset.Open(\"SELECT * FROM Main WHERE lShortCut > 0\");\n\t\t\n\t\tCAccel a;\n\t\twhile(!recset.IsEOF())\n\t\t{\n\t\t\ta.Cmd = recset.m_lID;\n\t\t\ta.Key = recset.m_lShortCut;\n\t\t\taccels.AddAccel(a);\n\n\t\t\trecset.MoveNext();\n\t\t}\n\t}\n\tcatch(CDaoException* e)\n\t{\n\t\te->Delete();\n\t}\n}\n\n/*\n//HACCEL CMainTable::LoadAcceleratorKeys()\n//{\n//\tCMainTable recset;\n//\n//\ttry\n//\t{\n//\t\trecset.Open(\"SELECT * FROM Main WHERE lShortCut > 0\");\n//\t\t\n//\t\tCArray<ACCEL, ACCEL> keys;\n//\n//\t\twhile(!recset.IsEOF())\n//\t\t{\n//\t\t\tACCEL me;\n//\t\t\tme.cmd = (USHORT)recset.m_lID;\n//\t\t\tme.fVirt = 0;\n//\t\t\tif( HIBYTE(recset.m_lShortCut) & HOTKEYF_SHIFT )   me.fVirt |= FSHIFT;\n//\t\t\tif( HIBYTE(recset.m_lShortCut) & HOTKEYF_CONTROL ) me.fVirt |= FCONTROL;\n//\t\t\tif( HIBYTE(recset.m_lShortCut) & HOTKEYF_ALT )     me.fVirt |= FALT;\t\n//\t\t\tme.fVirt |= FVIRTKEY;\n//\t\t\tme.key = LOBYTE(recset.m_lShortCut);\n//\n//\t\t\tkeys.Add(me);\n//\n//\t\t\trecset.MoveNext();\n//\t\t}\n//\n//\t\tif(keys.GetSize() > 0)\n//\t\t\treturn CreateAcceleratorTable(keys.GetData(), keys.GetSize());\n//\t}\n//\tcatch(CDaoException* e)\n//\t{\n//\t\te->Delete();\n//\t}\n//\n//\treturn NULL;\n//}\n*/\n\nvoid CMainTable::Open(LPCTSTR lpszFormat,...) \n{\n\tm_pDatabase = theApp.EnsureOpenDB();\n\n\tCString csText;\n\tva_list vlist;\n\n\tASSERT(AfxIsValidString(lpszFormat));\n\tva_start(vlist,lpszFormat);\n\tcsText.FormatV(lpszFormat,vlist);\n\tva_end(vlist);\n\t\n\tOpen(AFX_DAO_USE_DEFAULT_TYPE, csText, 0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CMainTable diagnostics\n\n#ifdef _DEBUG\nvoid CMainTable::AssertValid() const\n{\n\tCDaoRecordset::AssertValid();\n}\n\nvoid CMainTable::Dump(CDumpContext& dc) const\n{\n\tCDaoRecordset::Dump(dc);\n}\n#endif //_DEBUG\n"
        },
        {
          "name": "MainTable.h",
          "type": "blob",
          "size": 1.998046875,
          "content": "#if !defined(AFX_MAINTABLE_H__F5CFB0A6_A6E1_4C55_A685_AB5F1A0FCF53__INCLUDED_)\n#define AFX_MAINTABLE_H__F5CFB0A6_A6E1_4C55_A685_AB5F1A0FCF53__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n#include \"ArrayEx.h\"\n#include \"Misc.h\"\n\nclass CMainTable : public CDaoRecordset\n{\npublic:\n\tCMainTable(CDaoDatabase* pDatabase = NULL);\n\tDECLARE_DYNAMIC(CMainTable)\n\n\n// Field/Param Data\n\t//{{AFX_FIELD(CMainTable, CDaoRecordset)\n\tlong\tm_lID;\n\tlong\tm_lDate;\n\tCString\tm_strText;\n\tlong\tm_lShortCut;\n\tlong\tm_lDontAutoDelete;\n\tlong\tm_lTotalCopySize;\n\n\tBOOL\tm_bIsGroup;\n\tlong\tm_lParentID;\n\tdouble\tm_dOrder;\n\tlong\tm_lDataID;\n\t//}}AFX_FIELD\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CMainTable)\n\tpublic:\n\tvirtual CString GetDefaultDBName();\t\t// Default database name\n\tvirtual CString GetDefaultSQL();\t\t// Default SQL for Recordset\n\tvirtual void DoFieldExchange(CDaoFieldExchange* pFX);  // RFX support\n\tvirtual void Open(int nOpenType = AFX_DAO_USE_DEFAULT_TYPE, LPCTSTR lpszSql = NULL, int nOptions = 0);\n\tvirtual void Requery();\n\t//}}AFX_VIRTUAL\n\npublic:\n\tCString GetDisplayText( int nMaxLines );\n\tvoid AddNew(); // assigns the new autoincr ID to m_lID\n\tvoid OnQuery();\n\n\tint\t\tm_nFieldCount;\n\tbool\tm_bBindFields;\n\tbool SetBindFields(bool bVal);\n\n//\tlong GetID();\n\n//\tint\t\tm_nCurPos;\n//\tlong\tm_lCurID; // used to validate m_nCurPos\n\n\t// copies the current source record to this current record\n\tvoid CopyRec( CMainTable& source );\n\t// makes a new copy of the current record and moves to the copy record\n\tvoid NewCopyRec();\n\n\t// ONLY deletes from Main\n\tstatic BOOL DeleteAll();\n\t\n\tstatic void LoadAcceleratorKeys( CAccels& accels );\n\tvoid Open(LPCTSTR lpszFormat,...);\n\n// Implementation\n#ifdef _DEBUG\n\tvirtual void AssertValid() const;\n\tvirtual void Dump(CDumpContext& dc) const;\n#endif\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_MAINTABLE_H__F5CFB0A6_A6E1_4C55_A685_AB5F1A0FCF53__INCLUDED_)\n"
        },
        {
          "name": "MainTableFunctions.cpp",
          "type": "blob",
          "size": 2.4521484375,
          "content": "// MainTableFunctions.cpp: implementation of the CMainTableFunctions class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"MainTableFunctions.h\"\r\n#include \"shared/Tokenizer.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nCMainTableFunctions::CMainTableFunctions()\r\n{\r\n\r\n}\r\n\r\nCMainTableFunctions::~CMainTableFunctions()\r\n{\r\n\r\n}\r\n\r\nvoid CMainTableFunctions::LoadAcceleratorKeys(CAccels& accels, CppSQLite3DB &db)\r\n{\r\n\ttry\r\n\t{\r\n\t\t{\r\n\t\t\tCppSQLite3Query q = db.execQuery(_T(\"SELECT lID, lShortCut FROM Main WHERE lShortCut > 0\"));\r\n\t\t\r\n\t\t\tCAccel a;\r\n\t\t\twhile(q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\ta.Cmd = q.getIntField(_T(\"lID\"));\r\n\t\t\t\ta.Key = q.getIntField(_T(\"lShortCut\"));\r\n\t\t\t\ta.RefId = CHotKey::PASTE_OPEN_CLIP;\r\n\t\t\t\r\n\t\t\t\taccels.AddAccel(a);\r\n\r\n\t\t\t\tq.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tCppSQLite3Query q2 = db.execQuery(_T(\"SELECT lID, MoveToGroupShortCut FROM Main WHERE MoveToGroupShortCut > 0\"));\r\n\r\n\t\t\tCAccel a2;\r\n\t\t\twhile(q2.eof() == false)\r\n\t\t\t{\r\n\t\t\t\ta2.Cmd = q2.getIntField(_T(\"lID\"));\r\n\t\t\t\ta2.Key = q2.getIntField(_T(\"MoveToGroupShortCut\"));\r\n\t\t\t\ta2.RefId = CHotKey::MOVE_TO_GROUP;\r\n\r\n\t\t\t\taccels.AddAccel(a2);\r\n\r\n\t\t\t\tq2.nextRow();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nCString CMainTableFunctions::GetDisplayText(int nMaxLines, const CString &OrigText)\r\n{\r\n\tCString text = OrigText;\r\n\t// assign tabs to 2 spaces (rather than the default 8)\r\n\ttext.Replace(_T(\"\\t\"), _T(\"  \"));\r\n\r\n\tif(CGetSetOptions::m_bDescShowLeadingWhiteSpace)\r\n\t\treturn text;\r\n\t// else, remove the leading indent from every line.\r\n\r\n\t// get the lines\r\n\tCString token;\r\n\tCStringArray tokens;\r\n\tCTokenizer tokenizer(text, \"\\r\\n\");\r\n\tfor(int nLines=0; nLines < 100 && tokenizer.Next(token); nLines++)\r\n\t{\r\n\t\ttokens.Add(token);\r\n\t}\r\n\r\n\t// remove each line's indent\r\n\tTCHAR chFirst;\r\n\tCString line;\r\n\tINT_PTR count = tokens.GetSize();\r\n\ttext = _T(\"\");\r\n\tfor(int i=0; i < count; i++)\r\n\t{\r\n\t\tline = tokens.ElementAt(i);\r\n\t\tchFirst = line.GetAt(0);\r\n\t\tif(chFirst == ' ' || chFirst == '\\t')\r\n\t\t{\r\n\t\t\ttext += _T(\" \"); // show indication that the line is modified\r\n\t\t\tline.TrimLeft();\r\n\t\t\ttext += line;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ttext += line;\r\n\t\t}\r\n\r\n\t\tif (i != count - 1)\r\n\t\t{\r\n\t\t\ttext += _T(\"\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\treturn text;\r\n}"
        },
        {
          "name": "MainTableFunctions.h",
          "type": "blob",
          "size": 0.6943359375,
          "content": "// MainTableFunctions.h: interface for the CMainTableFunctions class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_MAINTABLEFUNCTIONS_H__3AE1D19B_D68D_48E7_80CA_AB62B0447883__INCLUDED_)\n#define AFX_MAINTABLEFUNCTIONS_H__3AE1D19B_D68D_48E7_80CA_AB62B0447883__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\nclass CMainTableFunctions  \n{\npublic:\n\tCMainTableFunctions();\n\tvirtual ~CMainTableFunctions();\n\n\tstatic void LoadAcceleratorKeys(CAccels& accels, CppSQLite3DB &db);\n\tstatic CString GetDisplayText(int nMaxLines, const CString &OrigText);\n};\n\n#endif // !defined(AFX_MAINTABLEFUNCTIONS_H__3AE1D19B_D68D_48E7_80CA_AB62B0447883__INCLUDED_)\n"
        },
        {
          "name": "Md5.cpp",
          "type": "blob",
          "size": 8.884765625,
          "content": "#include \"Stdafx.h\"\n#include \".\\md5.h\"\n\nCMd5::CMd5()\n{\n\t// don't alloc buffer here, only on request\n\tmp_s8ReadBuffer = 0;\n}\n\nCMd5::~CMd5()\n{\n\tFreeBuffer();\n}\n\nvoid CMd5::FreeBuffer()\n{\n\tif(mp_s8ReadBuffer) \n\t\tdelete mp_s8ReadBuffer;\n}\n\n/*********************************************************************\n//\n//         calculate MD5 from a file of any size (also size = 0)\n//         returns \"\" on file error\n//\n/********************************************************************/\n\nchar* CMd5::CalcMD5FromFile(const TCHAR *s8_Path)\n{\n\tif(!mp_s8ReadBuffer) \n\t{\n\t\tmp_s8ReadBuffer = new char[_ReadBufSize];\n\t}\n\n\tMD5Init();\n\n\t// ++++++++++++ Read file block by block +++++++++++\n\n\tHANDLE h_File = CreateFile(s8_Path, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\n\tif (h_File == INVALID_HANDLE_VALUE)\n\t\treturn \"\";\n\n\tint s32_Size = GetFileSize(h_File, 0);\n\n\twhile (s32_Size > 0)\n\t{\n\t\tunsigned long u32_Read = 0;\n\t\tif (!ReadFile(h_File, mp_s8ReadBuffer, _ReadBufSize, &u32_Read, 0))\n\t\t{\n\t\t\tCloseHandle(h_File);\n\t\t\treturn \"\";\n\t\t}\n\n\t\tMD5Update((unsigned char*)mp_s8ReadBuffer, u32_Read);\n\n\t\ts32_Size -= u32_Read;\n\t};\n\n\tCloseHandle(h_File);\n\n\t// ++++++++++++ Signature --> String +++++++++++\n\n\treturn MD5FinalToString();\n}\n\n\n/*********************************************************************\n//\n//                calculate MD5 from a string\n//\n/********************************************************************/\nchar* CMd5::CalcMD5FromString(const char *s8_Input, int len)\n{\n\tMD5Init();\n\tMD5Update((unsigned char*)s8_Input, len);\n\n\treturn MD5FinalToString();\n}\n\n\n/*********************************************************************\n//\n//                           Calculation functions\n//\n/*********************************************************************\n/*\n* Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n* initialization constants.\n*/\nvoid CMd5::MD5Init()\n{\n\tctx.buf[0] = 0x67452301;\n\tctx.buf[1] = 0xefcdab89;\n\tctx.buf[2] = 0x98badcfe;\n\tctx.buf[3] = 0x10325476;\n\n\tctx.bits[0] = 0;\n\tctx.bits[1] = 0;\n}\n\n/*\n* Update context to reflect the concatenation of another buffer full\n* of bytes.\n*/\nvoid CMd5::MD5Update(unsigned char *buf, unsigned len)\n{\n\tunsigned long t;\n\n\t/* Update bitcount */\n\n\tt = ctx.bits[0];\n\tif ((ctx.bits[0] = t + ((unsigned long) len << 3)) < t)\n\t\tctx.bits[1]++;  /* Carry from low to high */\n\tctx.bits[1] += len >> 29;\n\n\tt = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */\n\n\t/* Handle any leading odd-sized chunks */\n\n\tif (t) \n\t{\n\t\tunsigned char *p = (unsigned char *) ctx.in + t;\n\n\t\tt = 64 - t;\n\t\tif (len < t) {\n\t\t\tmemcpy(p, buf, len);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(p, buf, t);\n\t\tCMd5::byteReverse(ctx.in, 16);\n\t\tMD5Transform(ctx.buf, (unsigned long *) ctx.in);\n\t\tbuf += t;\n\t\tlen -= t;\n\t}\n\t/* Process data in 64-byte chunks */\n\n\twhile (len >= 64) \n\t{\n\t\tmemcpy(ctx.in, buf, 64);\n\t\tCMd5::byteReverse(ctx.in, 16);\n\t\tMD5Transform(ctx.buf, (unsigned long *) ctx.in);\n\t\tbuf += 64;\n\t\tlen -= 64;\n\t}\n\n\t/* Handle any remaining bytes of data. */\n\n\tmemcpy(ctx.in, buf, len);\n}\n\n/*\n* Convert signature to CString\n*/\nchar* CMd5::MD5FinalToString()\n{\n\tunsigned char signature[16];\n\tMD5Final(signature);\n\n\tms8_MD5[0] = 0;\n\tchar s8_Temp[5];\n\tfor (int i=0; i<16; i++) \n\t{\n\t\tsprintf(s8_Temp, \"%02X\", signature[i]);\n\t\tstrcat(ms8_MD5, s8_Temp);\n\t}\n\n\treturn ms8_MD5;\n}\n\n\n/*\n* Final wrapup - pad to 64-byte boundary with the bit pattern \n* 1 0* (64-bit count of bits processed, MSB-first)\n*/\nvoid CMd5::MD5Final(unsigned char digest[16])\n{\n\tunsigned count;\n\tunsigned char *p;\n\n\t/* Compute number of bytes mod 64 */\n\tcount = (ctx.bits[0] >> 3) & 0x3F;\n\n\t/* Set the first char of padding to 0x80.  This is safe since there is\n\talways at least one byte free */\n\tp = ctx.in + count;\n\t*p++ = 0x80;\n\n\t/* Bytes of padding needed to make 64 bytes */\n\tcount = 64 - 1 - count;\n\n\t/* Pad out to 56 mod 64 */\n\tif(count < 8) \n\t{\n\t\t/* Two lots of padding:  Pad the first block to 64 bytes */\n\t\tmemset(p, 0, count);\n\t\tCMd5::byteReverse(ctx.in, 16);\n\t\tMD5Transform(ctx.buf, (unsigned long *) ctx.in);\n\n\t\t/* Now fill the next block with 56 bytes */\n\t\tmemset(ctx.in, 0, 56);\n\t} \n\telse \n\t{\n\t\t/* Pad block to 56 bytes */\n\t\tmemset(p, 0, count - 8);\n\t}\n\tCMd5::byteReverse(ctx.in, 14);\n\n\t/* Append length in bits and transform */\n\t((unsigned long *) ctx.in)[14] = ctx.bits[0];\n\t((unsigned long *) ctx.in)[15] = ctx.bits[1];\n\n\tMD5Transform(ctx.buf, (unsigned long *) ctx.in);\n\tCMd5::byteReverse((unsigned char *) ctx.buf, 4);\n\tmemcpy(digest, ctx.buf, 16);\n\tmemset(&ctx, 0, sizeof(MD5Context));        /* In case it's sensitive */\n}\n\n\n/* The four core functions - F1 is optimized somewhat */\n\n/* #define F1(x, y, z) (x & y | ~x & z) */\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n/* This is the central step in the MD5 algorithm. */\n#define MD5STEP(f, w, x, y, z, data, s) \\\n\t( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n/*\n* The core of the MD5 algorithm, this alters an existing MD5 hash to\n* reflect the addition of 16 longwords of new data.  MD5Update blocks\n* the data and converts bytes into longwords for this routine.\n*/\nvoid CMd5::MD5Transform(unsigned long buf[4], unsigned long in[16])\n{\n\tregister unsigned long a, b, c, d;\n\n\ta = buf[0];\n\tb = buf[1];\n\tc = buf[2];\n\td = buf[3];\n\n\tMD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n\tMD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n\tMD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n\tMD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n\tMD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n\tMD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n\tMD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n\tMD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n\tMD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n\tMD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n\tMD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n\tMD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n\tMD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n\tMD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n\tMD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n\tMD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n\tMD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n\tMD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n\tMD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n\tMD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n\tMD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n\tMD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n\tMD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n\tMD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n\tMD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n\tMD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n\tMD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n\tMD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n\tMD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n\tMD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n\tMD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n\tMD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n\tMD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n\tMD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n\tMD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n\tMD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n\tMD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n\tMD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n\tMD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n\tMD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n\tMD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n\tMD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n\tMD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n\tMD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n\tMD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n\tMD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n\tMD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n\tMD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n\tMD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n\tMD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n\tMD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n\tMD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n\tMD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n\tMD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n\tMD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n\tMD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n\tMD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n\tMD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n\tMD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n\tMD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n\tMD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n\tMD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n\tMD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n\tMD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n\tbuf[0] += a;\n\tbuf[1] += b;\n\tbuf[2] += c;\n\tbuf[3] += d;\n}\n\n#ifdef sgi\n#define HIGHFIRST\n#endif\n\n#ifdef sun\n#define HIGHFIRST\n#endif\n\n\n#ifndef HIGHFIRST\nvoid CMd5::byteReverse(unsigned char *buf, unsigned longs)  \n{\n\t// Nothing\n}\n#else\n// Note: this code is harmless on little-endian machines.\nvoid CMd5::byteReverse(unsigned char *buf, unsigned longs)\n{\n\tunsigned long t;\n\tdo \n\t{\n\t\tt = (unsigned long) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n\t\t\t((unsigned) buf[1] << 8 | buf[0]);\n\t\t*(unsigned long *) buf = t;\n\t\tbuf += 4;\n\t} while (--longs);\n}\n#endif"
        },
        {
          "name": "Md5.h",
          "type": "blob",
          "size": 0.6826171875,
          "content": "#pragma once\n\n#define _ReadBufSize 1000000\n#define md5StringLength 32\n\nclass CMd5  \n{\npublic:\n\tchar* CalcMD5FromString(const char *s8_Input, int len);\n\tchar* CalcMD5FromFile(const TCHAR *s8_Path);\n\n\tvoid MD5Init();\n\tvoid MD5Update(unsigned char *buf, unsigned len);\n\tchar* MD5FinalToString();\n\n\tvoid FreeBuffer();\n\tCMd5();\n\tvirtual ~CMd5();\n\nprivate:\n\tstruct MD5Context \n\t{\n\t\tunsigned long buf[4];\n\t\tunsigned long bits[2];\n\t\tunsigned char in[64];\n\t};\n\t\t\n\tvoid MD5Final (unsigned char digest[16]);\n\tvoid MD5Transform(unsigned long buf[4], unsigned long in[16]);\n\tvoid byteReverse (unsigned char *buf, unsigned longs);\n\n\tchar *mp_s8ReadBuffer;\n\tMD5Context ctx;\n\tchar   ms8_MD5[40]; // Output buffer\n};"
        },
        {
          "name": "MessagePumpThread.cpp",
          "type": "blob",
          "size": 1.4990234375,
          "content": "#include \"StdAfx.h\"\n#include \"MessagePumpThread.h\"\n\n\nCMessagePumpThread::CMessagePumpThread(void)\n{\n}\n\n\nCMessagePumpThread::~CMessagePumpThread(void)\n{\n}\n\nUINT CMessagePumpThread::MessagePumpThread(void* thisptr) \n{\n\tCMessagePumpThread *threadClass = (CMessagePumpThread*)thisptr;\n\tthreadClass->RunMessagePump();\n\treturn 0;\n}\n\nvoid CMessagePumpThread::Start() \n{\n\tm_hEvt = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n\tm_thread = _beginthreadex(NULL, 0, MessagePumpThread, this, 0, &m_threadID);\n\tif (0 == m_thread)\n\t{\n\t\tthrow \"Could not create thread\";\n\t}\n\n\t// now wait until the thread is up and really running\n\tif (WAIT_OBJECT_0 != WaitForSingleObject(m_hEvt, 10000L))\t// 10 seconds\n\t{\n\t\tthrow \"Timeout waiting for thread to start\";\n\t}\n}\n\nvoid CMessagePumpThread::Stop() \n{\n\tPostThreadMessage(m_threadID, WM_QUIT, 0, 0L);\n\tif (WAIT_OBJECT_0 != WaitForSingleObject(m_hEvt, 10000L))\n\t{\n\t\tthrow \"Timeout waiting for thread to stop\";\n\t}\n};\n\nvoid CMessagePumpThread::PostMsg(UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tPostThreadMessage(m_threadID, msg, wParam, lParam);\n}\n\nvoid CMessagePumpThread::RunMessagePump()\n{\n\tMSG msg;\n\n\t// create the message queue\n\tPeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);\n\n\t// we're far enough to let the creator know we're running\n\tSetEvent(m_hEvt);\n\n\twhile(true)\n\t{\n\t\tBOOL bRet = GetMessage(&msg, NULL, 0, 0);\n\t\tif (0 >= bRet) // just read the specs, it's a \"MickeySoft BOOL\" and can be TRUE, FALSE or -1 (right on)\n\t\t{\n\t\t\tSetEvent(m_hEvt);\n\t\t\tbreak;\t\n\t\t}\n\n\t\tTakeMsg(msg.message, msg.wParam, msg.lParam);\n\t}\n}\n"
        },
        {
          "name": "MessagePumpThread.h",
          "type": "blob",
          "size": 0.5234375,
          "content": "#pragma once\n\nclass CMessagePumpThread\n{\npublic:\n\tCMessagePumpThread(void);\n\t~CMessagePumpThread(void);\n\n\tstatic unsigned int __stdcall MessagePumpThread(void* thisptr);\n\nprotected:\n\tvirtual void TakeMsg(UINT msg, WPARAM wParam, LPARAM lParam)\t{ return; }\n\tvoid RunMessagePump();\n\n\tUINT m_threadID;\n\tuintptr_t m_thread;\n\tHANDLE m_hEvt;\n\npublic:\n\tvoid Start();\n\tvoid Stop(); \n\tvoid PostMsg(UINT msg, WPARAM wParam, LPARAM lParam);\n\n\tUINT getThreadID() const { return m_threadID; }\n\tuintptr_t getThread() const { return m_thread; }\n};\n\n\n\n"
        },
        {
          "name": "Misc.cpp",
          "type": "blob",
          "size": 40.130859375,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"Misc.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"AlphaBlend.h\"\r\n#include \"Tlhelp32.h\"\r\n#include <Wininet.h>\r\n#include <sys/types.h>  \r\n#include <sys/stat.h> \r\n#include \"Path.h\"\r\n#include <regex>\r\n#include <vector>\r\n\r\nCString GetIPAddress()\r\n{\r\n\tWORD wVersionRequested;\r\n    WSADATA wsaData;\r\n    char name[255];\r\n    CString IP;\r\n\tPHOSTENT hostinfo;\r\n\twVersionRequested = MAKEWORD(2,0);\r\n\t\r\n\tif (WSAStartup(wVersionRequested, &wsaData)==0)\r\n\t{\r\n\t\tif(gethostname(name, sizeof(name))==0)\r\n\t\t{\r\n\t\t\tif((hostinfo=gethostbyname(name)) != NULL)\r\n\t\t\t{\r\n\t\t\t\tIP = inet_ntoa(*(struct in_addr*)* hostinfo->h_addr_list);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tWSACleanup();\r\n\t} \r\n\tIP.MakeUpper();\r\n\r\n\treturn IP;\r\n}\r\n\r\nCString GetComputerName()\r\n{\r\n\tTCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1] = _T(\"\");\r\n\tDWORD Size=MAX_COMPUTERNAME_LENGTH+1;\r\n\tGetComputerName(ComputerName, &Size);\r\n\r\n\tCString cs(ComputerName);\r\n\tcs.MakeUpper();\r\n\r\n\treturn cs;\r\n}\r\n\r\nvoid AppendToFile(const TCHAR* fn, const TCHAR* msg)\r\n{\r\n#ifdef _UNICODE\r\n\tFILE *file = _wfopen(fn, _T(\"a\"));\r\n#else\r\n\tFILE *file = fopen(fn, _T(\"a\"));\r\n#endif\r\n\r\n\tASSERT( file );\r\n\r\n\tif(file != NULL)\r\n\t{\r\n\t\t#ifdef _UNICODE\r\n\t\t\tfwprintf(file, _T(\"%s\"), msg);\r\n\t\t#else\r\n\t\t\tfprintf(file, _T(\"%s\"),msg);\r\n\t\t#endif\r\n\r\n\t\tfclose(file);\t\r\n\t}\r\n}\r\n\r\nvoid log(const TCHAR* msg, bool bFromSendRecieve, CString csFile, long lLine)\r\n{\r\n\tASSERT(AfxIsValidString(msg));\r\n\r\n\tSYSTEMTIME st;\r\n\tGetLocalTime(&st);\r\n\t\r\n\tCString\tcsText;\r\n\tcsText.Format(_T(\"[%d/%d/%d %02d:%02d:%02d.%03d - \"), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\r\n\r\n\tCString csFileLine;\r\n\tcsFile = GetFileName(csFile);\r\n\tcsFileLine.Format(_T(\"%s %d] \"), csFile, lLine);\r\n\tcsText += csFileLine;\r\n\t\r\n\tcsText += msg;\r\n\tcsText += \"\\n\";\r\n\r\n#ifndef _DEBUG\r\n\tif(CGetSetOptions::m_outputDebugStringLogging)\r\n#endif\r\n\t{\r\n\t\tOutputDebugString(csText);\r\n\t}\r\n\r\n#ifndef _DEBUG\r\n\tif(!bFromSendRecieve)\r\n\t{\r\n\t\tif(!CGetSetOptions::m_bEnableDebugLogging)\r\n\t\t\treturn;\r\n\t}\r\n#endif\r\n\t\r\n\tCString csExeFile = CGetSetOptions::GetPath(PATH_LOG_FILE);\r\n\tcsExeFile += \"Ditto.log\";\r\n\r\n\tAppendToFile(csExeFile, csText);\r\n}\r\n\r\nvoid logsendrecieveinfo(CString cs, CString csFile, long lLine)\r\n{\r\n\tif(CGetSetOptions::m_bLogSendReceiveErrors)\r\n\t\tlog(cs, true, csFile, lLine);\r\n}\r\n\r\nCString GetErrorString( int err )\r\n{\r\n\tCString str;\r\n\tLPVOID lpMsgBuf;\r\n\t\r\n\t::FormatMessage( \r\n\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\r\n\t\tNULL,\r\n\t\terr,\r\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\r\n\t\t(LPTSTR) &lpMsgBuf,\r\n\t\t0,\r\n\t\tNULL \r\n\t\t);\r\n\tstr = (LPCTSTR) lpMsgBuf;\r\n\t// Display the string.\r\n\t//  ::MessageBox( NULL, lpMsgBuf, \"GetLastError\", MB_OK|MB_ICONINFORMATION );\r\n\t::LocalFree( lpMsgBuf );\r\n\treturn str;\r\n}\r\n\r\nint g_funnyGetTickCountAdjustment = -1;\r\n\r\ndouble IdleSeconds()\r\n{\r\n\tLASTINPUTINFO info; \r\n\tinfo.cbSize = sizeof(info);\r\n\tGetLastInputInfo(&info);   \r\n\tDWORD currentTick  = GetTickCount();\r\n\r\n\tif(g_funnyGetTickCountAdjustment == -1)\r\n\t{\r\n\t\tif(currentTick < info.dwTime)\r\n\t\t{\r\n\t\t\tg_funnyGetTickCountAdjustment = 1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tg_funnyGetTickCountAdjustment = 0; \r\n\t\t}\t\t\r\n\t}\r\n\t\r\n\tif(g_funnyGetTickCountAdjustment == 1 || g_funnyGetTickCountAdjustment == 2)\r\n\t{\r\n\t\t//Output message the first time\r\n\t\tif(g_funnyGetTickCountAdjustment == 1)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"Adjusting time of get tickcount by: %d, on startup we found GetTickCount to be less than last input\"), CGetSetOptions::GetFunnyTickCountAdjustment()));\r\n\t\t\tg_funnyGetTickCountAdjustment = 2;\r\n\t\t}\r\n\t\tcurrentTick += CGetSetOptions::GetFunnyTickCountAdjustment();\r\n\t}\r\n\r\n\tdouble idleSeconds = (currentTick - info.dwTime)/1000.0;\r\n\r\n\treturn idleSeconds;\r\n}\r\n\r\nCString StrF(const TCHAR * pszFormat, ...)\r\n{\r\n\tASSERT( AfxIsValidString( pszFormat ) );\r\n\tCString str;\r\n\tva_list argList;\r\n\tva_start( argList, pszFormat );\r\n\tstr.FormatV( pszFormat, argList );\r\n\tva_end( argList );\r\n\treturn str;\r\n}\r\n\r\nBYTE GetEscapeChar( BYTE ch )\r\n{\r\n\tswitch(ch)\r\n\t{\r\n\tcase '\\'':\treturn '\\''; // Single quotation mark (') = 39 or 0x27\r\n\tcase '\\\"':\treturn '\\\"'; // Double quotation mark (\") = 34 or 0x22\r\n\tcase '?':\treturn '\\?'; // Question mark (?) = 63 or 0x3f\r\n\tcase '\\\\':\treturn '\\\\'; // Backslash (\\) = 92 or 0x5c\r\n\tcase 'a':\treturn '\\a'; // Alert (BEL) = 7\r\n\tcase 'b':\treturn '\\b'; // Backspace (BS) = 8\r\n\tcase 'f':\treturn '\\f'; // Formfeed (FF) = 12 or 0x0c\r\n\tcase 'n':\treturn '\\n'; // Newline (NL or LF) = 10 or 0x0a\r\n\tcase 'r':\treturn '\\r'; // Carriage Return (CR) = 13 or 0x0d\r\n\tcase 't':\treturn '\\t'; // Horizontal tab (HT) = 9\r\n\tcase 'v':\treturn '\\v'; // Vertical tab (VT) = 11 or 0x0b\r\n\tcase '0':\treturn '\\0'; // Null character (NUL) = 0\r\n\t}\r\n\treturn 0; // invalid\r\n}\r\n\r\nCString RemoveEscapes( const TCHAR* str )\r\n{\r\n\tASSERT( str );\r\n\tCString ret;\r\n\tTCHAR* pSrc = (TCHAR*) str;\r\n\tTCHAR* pDest = ret.GetBuffer((int)STRLEN(pSrc));\r\n\tTCHAR* pStart = pDest;\r\n\twhile( *pSrc != '\\0' )\r\n\t{\r\n\t\tif( *pSrc == '\\\\' )\r\n\t\t{\r\n\t\t\tpSrc++;\r\n\t\t\t*pDest = GetEscapeChar((BYTE)pSrc );\r\n\t\t}\r\n\t\telse\r\n\t\t\t*pDest = *pSrc;\r\n\t\tpSrc++;\r\n\t\tpDest++;\r\n\t}\r\n\tret.ReleaseBuffer((int)(pDest - pStart));\r\n\treturn ret;\r\n}\r\n\r\nCString GetWndText(HWND hWnd)\r\n{\r\n\tTCHAR cWindowText[200];\r\n\tHWND hParent = hWnd;\r\n\r\n\t::GetWindowText(hParent, cWindowText, 100);\r\n\r\n\tint nCount = 0;\r\n\r\n\twhile (STRLEN(cWindowText) <= 0)\r\n\t{\r\n\t\thParent = ::GetParent(hParent);\r\n\t\tif (hParent == NULL)\r\n\t\t\tbreak;\r\n\r\n\t\t::GetWindowText(hParent, cWindowText, 100);\r\n\r\n\t\tnCount++;\r\n\t\tif (nCount > 100)\r\n\t\t{\r\n\t\t\tLog(_T(\"GetTargetName reached maximum search depth of 100\"));\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn cWindowText;\r\n}\r\n\r\nCString TopLevelWindowText(DWORD pid)\r\n{\r\n\tstd::pair<CString, DWORD> params = { _T(\"\"), pid };\r\n\r\n\t// Enumerate the windows using a lambda to process each window\r\n\tBOOL bResult = EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL\r\n\t{\r\n\t\tauto pParams = (std::pair<CString, DWORD>*)(lParam);\r\n\r\n\t\tDWORD processId;\r\n\t\tif (GetWindowThreadProcessId(hwnd, &processId) &&\r\n\t\t\tprocessId == pParams->second &&\r\n\t\t\t::GetWindow(hwnd, GW_OWNER) == 0)\r\n\t\t{\r\n\t\t\tTCHAR cWindowText[500];\r\n\t\t\t::GetWindowText(hwnd, cWindowText, 500);\r\n\r\n\t\t\tif (STRLEN(cWindowText) > 0)\r\n\t\t\t{\r\n\t\t\t\tpParams->first = cWindowText;\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Continue enumerating\r\n\t\treturn TRUE;\r\n\t}, (LPARAM)&params);\r\n\r\n\treturn params.first;\r\n}\r\n\r\nbool IsAppWnd( HWND hWnd )\r\n{\r\n\tDWORD dwMyPID = ::GetCurrentProcessId();\r\n\tDWORD dwTestPID;\r\n\t::GetWindowThreadProcessId( hWnd, &dwTestPID );\r\n\treturn dwMyPID == dwTestPID;\r\n}\r\n\r\n/*----------------------------------------------------------------------------*\\\r\nGlobal Memory Helper Functions\r\n\\*----------------------------------------------------------------------------*/\r\n\r\n// make sure the given HGLOBAL is valid.\r\nBOOL IsValid(HGLOBAL hGlobal)\r\n{\r\n\tvoid* pvData = ::GlobalLock(hGlobal);\r\n\t::GlobalUnlock(hGlobal);\r\n\treturn (pvData != NULL);\r\n}\r\n\r\n// asserts if hDest isn't big enough\r\nvoid CopyToGlobalHP(HGLOBAL hDest, LPVOID pBuf, SIZE_T ulBufLen)\r\n{\r\n\tASSERT(hDest && pBuf && ulBufLen);\r\n\tLPVOID pvData = GlobalLock(hDest);\r\n\tASSERT(pvData);\r\n\tSIZE_T size = GlobalSize(hDest);\r\n\tASSERT(size >= ulBufLen);\t// assert if hDest isn't big enough\r\n\tmemcpy(pvData, pBuf, ulBufLen);\r\n\tGlobalUnlock(hDest);\r\n}\r\n\r\nvoid CopyToGlobalHH(HGLOBAL hDest, HGLOBAL hSource, SIZE_T ulBufLen)\r\n{\r\n\tASSERT(hDest && hSource && ulBufLen);\r\n\tLPVOID pvData = GlobalLock(hSource);\r\n\tASSERT(pvData );\r\n\tSIZE_T size = GlobalSize(hSource);\r\n\tASSERT(size >= ulBufLen);\t// assert if hSource isn't big enough\r\n\tCopyToGlobalHP(hDest, pvData, ulBufLen);\r\n\tGlobalUnlock(hSource);\r\n}\r\n\r\n\r\nHGLOBAL NewGlobalP(LPVOID pBuf, SIZE_T nLen)\r\n{\r\n\tASSERT(pBuf && nLen);\r\n\tHGLOBAL hDest = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, nLen);\r\n\tASSERT(hDest );\r\n\tCopyToGlobalHP(hDest, pBuf, nLen);\r\n\treturn hDest;\r\n}\r\n\r\nHGLOBAL NewGlobal(SIZE_T nLen)\r\n{\r\n\tASSERT(nLen);\r\n\tHGLOBAL hDest = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, nLen);\r\n\treturn hDest;\r\n}\r\n\r\nHGLOBAL NewGlobalH(HGLOBAL hSource, SIZE_T nLen)\r\n{\r\n\tASSERT(hSource && nLen);\r\n\tLPVOID pvData = GlobalLock(hSource);\r\n\tHGLOBAL hDest = NewGlobalP(pvData, nLen);\r\n\tGlobalUnlock(hSource);\r\n\treturn hDest;\r\n}\r\n\r\nint CompareGlobalHP(HGLOBAL hLeft, LPVOID pBuf, SIZE_T ulBufLen)\r\n{\r\n\tASSERT(hLeft && pBuf && ulBufLen);\r\n\r\n\tLPVOID pvData = GlobalLock(hLeft);\r\n\t\r\n\tASSERT(pvData);\r\n\tASSERT(ulBufLen <= GlobalSize(hLeft));\r\n\r\n\tint result = memcmp(pvData, pBuf, ulBufLen);\r\n\t\r\n\tGlobalUnlock(hLeft);\r\n\r\n\treturn result;\r\n}\r\n\r\nint CompareGlobalHH( HGLOBAL hLeft, HGLOBAL hRight, SIZE_T ulBufLen)\r\n{\r\n\tASSERT(hLeft && hRight && ulBufLen);\r\n\tASSERT(ulBufLen <= GlobalSize(hRight));\r\n\tLPVOID pvData = GlobalLock(hRight);\r\n\tASSERT(pvData);\r\n\tint result = CompareGlobalHP(hLeft, pvData, ulBufLen);\r\n\tGlobalUnlock(hLeft);\r\n\treturn result;\r\n}\r\n\r\n// https://learn.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats\r\nstd::vector<CLIPFORMAT> GetSystemClipFormats()\r\n{\r\n\tstd::vector<CLIPFORMAT> v = {\r\n\t\tCF_TEXT,\r\n\t\tCF_BITMAP,\r\n\t\tCF_METAFILEPICT,\r\n\t\tCF_SYLK,\r\n\t\tCF_DIF,\r\n\t\tCF_TIFF,\r\n\t\tCF_OEMTEXT,\r\n\t\tCF_DIB,\r\n\t\tCF_PALETTE,\r\n\t\tCF_PENDATA,\r\n\t\tCF_RIFF,\r\n\t\tCF_WAVE,\r\n\t\tCF_UNICODETEXT,\r\n\t\tCF_ENHMETAFILE,\r\n\t\tCF_HDROP,\r\n\t\tCF_LOCALE,\r\n\t\tCF_OWNERDISPLAY,\r\n\t\tCF_DSPTEXT,\r\n\t\tCF_DSPBITMAP,\r\n\t\tCF_DSPMETAFILEPICT,\r\n\t\tCF_DSPENHMETAFILE\r\n\t};\r\n\r\n\treturn v;\r\n}\r\n\r\n//Do not change these these are stored in the database\r\nCLIPFORMAT GetFormatID(LPCTSTR cbName)\r\n{\r\n\tif(STRCMP(cbName, _T(\"CF_TEXT\")) == 0)\r\n\t\treturn CF_TEXT;\r\n\telse if(STRCMP(cbName, _T(\"CF_METAFILEPICT\")) == 0)\r\n\t\treturn CF_METAFILEPICT;\r\n\telse if(STRCMP(cbName, _T(\"CF_SYLK\")) == 0)\r\n\t\treturn CF_SYLK;\r\n\telse if(STRCMP(cbName, _T(\"CF_DIF\")) == 0)\r\n\t\treturn CF_DIF;\r\n\telse if(STRCMP(cbName, _T(\"CF_TIFF\")) == 0)\r\n\t\treturn CF_TIFF;\r\n\telse if(STRCMP(cbName, _T(\"CF_OEMTEXT\")) == 0)\r\n\t\treturn CF_OEMTEXT;\r\n\telse if(STRCMP(cbName, _T(\"CF_DIB\")) == 0)\r\n\t\treturn CF_DIB;\r\n\telse if(STRCMP(cbName, _T(\"CF_PALETTE\")) == 0)\r\n\t\treturn CF_PALETTE;\r\n\telse if(STRCMP(cbName, _T(\"CF_PENDATA\")) == 0)\r\n\t\treturn CF_PENDATA;\r\n\telse if(STRCMP(cbName, _T(\"CF_RIFF\")) == 0)\r\n\t\treturn CF_RIFF;\r\n\telse if(STRCMP(cbName, _T(\"CF_WAVE\")) == 0)\r\n\t\treturn CF_WAVE;\r\n\telse if(STRCMP(cbName, _T(\"CF_UNICODETEXT\")) == 0)\r\n\t\treturn CF_UNICODETEXT;\r\n\telse if(STRCMP(cbName, _T(\"CF_ENHMETAFILE\")) == 0)\r\n\t\treturn CF_ENHMETAFILE;\r\n\telse if(STRCMP(cbName, _T(\"CF_HDROP\")) == 0)\r\n\t\treturn CF_HDROP;\r\n\telse if(STRCMP(cbName, _T(\"CF_LOCALE\")) == 0)\r\n\t\treturn CF_LOCALE;\r\n\telse if(STRCMP(cbName, _T(\"CF_OWNERDISPLAY\")) == 0)\r\n\t\treturn CF_OWNERDISPLAY;\r\n\telse if(STRCMP(cbName, _T(\"CF_DSPTEXT\")) == 0)\r\n\t\treturn CF_DSPTEXT;\r\n\telse if(STRCMP(cbName, _T(\"CF_DSPBITMAP\")) == 0)\r\n\t\treturn CF_DSPBITMAP;\r\n\telse if(STRCMP(cbName, _T(\"CF_DSPMETAFILEPICT\")) == 0)\r\n\t\treturn CF_DSPMETAFILEPICT;\r\n\telse if(STRCMP(cbName, _T(\"CF_DSPENHMETAFILE\")) == 0)\r\n\t\treturn CF_DSPENHMETAFILE;\r\n\t\r\n\t\r\n\treturn ::RegisterClipboardFormat(cbName);\r\n}\r\n\r\n//Do not change these these are stored in the database\r\nCString GetFormatName(CLIPFORMAT cbType)\r\n{\r\n\tswitch(cbType)\r\n\t{\r\n\tcase CF_TEXT:\r\n\t\treturn _T(\"CF_TEXT\");\r\n\tcase CF_BITMAP:\r\n\t\treturn _T(\"CF_BITMAP\");\r\n\tcase CF_METAFILEPICT:\r\n\t\treturn _T(\"CF_METAFILEPICT\");\r\n\tcase CF_SYLK:\r\n\t\treturn _T(\"CF_SYLK\");\r\n\tcase CF_DIF:\r\n\t\treturn _T(\"CF_DIF\");\r\n\tcase CF_TIFF:\r\n\t\treturn _T(\"CF_TIFF\");\r\n\tcase CF_OEMTEXT:\r\n\t\treturn _T(\"CF_OEMTEXT\");\r\n\tcase CF_DIB:\r\n\t\treturn _T(\"CF_DIB\");\r\n\tcase CF_PALETTE:\r\n\t\treturn _T(\"CF_PALETTE\");\r\n\tcase CF_PENDATA:\r\n\t\treturn _T(\"CF_PENDATA\");\r\n\tcase CF_RIFF:\r\n\t\treturn _T(\"CF_RIFF\");\r\n\tcase CF_WAVE:\r\n\t\treturn _T(\"CF_WAVE\");\r\n\tcase CF_UNICODETEXT:\r\n\t\treturn _T(\"CF_UNICODETEXT\");\r\n\tcase CF_ENHMETAFILE:\r\n\t\treturn _T(\"CF_ENHMETAFILE\");\r\n\tcase CF_HDROP:\r\n\t\treturn _T(\"CF_HDROP\");\r\n\tcase CF_LOCALE:\r\n\t\treturn _T(\"CF_LOCALE\");\r\n\tcase CF_OWNERDISPLAY:\r\n\t\treturn _T(\"CF_OWNERDISPLAY\");\r\n\tcase CF_DSPTEXT:\r\n\t\treturn _T(\"CF_DSPTEXT\");\r\n\tcase CF_DSPBITMAP:\r\n\t\treturn _T(\"CF_DSPBITMAP\");\r\n\tcase CF_DSPMETAFILEPICT:\r\n\t\treturn _T(\"CF_DSPMETAFILEPICT\");\r\n\tcase CF_DSPENHMETAFILE:\r\n\t\treturn _T(\"CF_DSPENHMETAFILE\");\r\n\tdefault:\r\n\t\t//Not a default type get the name from the clipboard\r\n\t\tif (cbType != 0)\r\n\t\t{\r\n\t\t\tTCHAR szFormat[256];\r\n            GetClipboardFormatName(cbType, szFormat, 256);\r\n\t\t\treturn szFormat;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\treturn \"ERROR\";\r\n}\r\n\r\nCString GetFilePath(CString csFileName)\r\n{\r\n\tlong lSlash = csFileName.ReverseFind('\\\\');\r\n\t\r\n\tif(lSlash > -1)\r\n\t{\r\n\t\tcsFileName = csFileName.Left(lSlash + 1);\r\n\t}\r\n\t\r\n\treturn csFileName;\r\n}\r\n\r\nCString GetFileName(CString csFileName)\r\n{\r\n\tlong lSlash = csFileName.ReverseFind('\\\\');\r\n\tif(lSlash > -1)\r\n\t{\r\n\t\tcsFileName = csFileName.Right(csFileName.GetLength() - lSlash - 1);\r\n\t}\r\n\r\n\treturn csFileName;\r\n}\r\n\r\n\r\n/****************************************************************************************************\r\nBOOL CALLBACK MyMonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)\r\n***************************************************************************************************/\r\ntypedef struct\r\n{\r\n\tlong\tlFlags;\t\t\t\t// Flags\r\n\tLPRECT\tpVirtualRect;\t\t// Ptr to rect that receives the results, or the src of the monitor search method\r\n\tint\t\tiMonitor;\t\t\t// Ndx to the mointor to look at, -1 for all, -or- result of the monitor search method\r\n\tint\t\tnMonitorCount;\t\t// Total number of monitors found, -1 for monitor search method\r\n}\tMONITOR_ENUM_PARAM;\r\n#define\tMONITOR_SEARCH_METOHD\t0x00000001\r\nBOOL CALLBACK MyMonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)\r\n{\r\n\t// Typecast param\r\n\tMONITOR_ENUM_PARAM* pParam = (MONITOR_ENUM_PARAM*)dwData;\r\n\tif(pParam)\r\n\t{\r\n\t\t// If a dest rect was passed\r\n\t\tif(pParam->pVirtualRect)\r\n\t\t{\r\n\t\t\t// If MONITOR_SEARCH_METOHD then we are being asked for the index of the monitor\r\n\t\t\t// that the rect falls inside of\r\n\t\t\tif(pParam->lFlags & MONITOR_SEARCH_METOHD)\r\n\t\t\t{\r\n\t\t\t\tif(\t(pParam->pVirtualRect->right\t< lprcMonitor->left)\t||\r\n\t\t\t\t\t(pParam->pVirtualRect->left\t\t> lprcMonitor->right)\t||\r\n\t\t\t\t\t(pParam->pVirtualRect->bottom\t< lprcMonitor->top)\t\t||\r\n\t\t\t\t\t(pParam->pVirtualRect->top\t\t> lprcMonitor->bottom))\r\n\t\t\t\t{\r\n\t\t\t\t\t// Nothing\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// This is the one\r\n\t\t\t\t\tpParam->iMonitor = pParam->nMonitorCount;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Stop the enumeration\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif(pParam->iMonitor == pParam->nMonitorCount)\r\n\t\t\t\t{\r\n\t\t\t\t\t*pParam->pVirtualRect = *lprcMonitor;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tif(pParam->iMonitor == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpParam->pVirtualRect->left = min(pParam->pVirtualRect->left, lprcMonitor->left);\r\n\t\t\t\t\t\tpParam->pVirtualRect->top = min(pParam->pVirtualRect->top, lprcMonitor->top);\r\n\t\t\t\t\t\tpParam->pVirtualRect->right = max(pParam->pVirtualRect->right, lprcMonitor->right);\r\n\t\t\t\t\t\tpParam->pVirtualRect->bottom = max(pParam->pVirtualRect->bottom, lprcMonitor->bottom);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Up the count if necessary\r\n\t\tpParam->nMonitorCount++;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nint GetScreenWidth(void)\r\n{\r\n\tOSVERSIONINFO OS_Version_Info;\r\n\tDWORD dwPlatform = 0;\r\n\t\r\n\tif(GetVersionEx(&OS_Version_Info) != 0)\r\n\t{\r\n\t\tdwPlatform = OS_Version_Info.dwPlatformId;\r\n\t}\r\n\t\r\n\tif(dwPlatform == VER_PLATFORM_WIN32_NT)\r\n\t{\r\n\t\tint width, height;\r\n\t\t\r\n\t\twidth = GetSystemMetrics(SM_CXSCREEN);\r\n\t\theight = GetSystemMetrics(SM_CYSCREEN);\r\n\t\tswitch(width)\r\n\t\t{\r\n\t\tdefault:\r\n\t\tcase 640:\r\n\t\tcase 800:\r\n\t\tcase 1024:\r\n\t\t\treturn(width);\r\n\t\tcase 1280:\r\n\t\t\tif(height == 480)\r\n\t\t\t{\r\n\t\t\t\treturn(width / 2);\r\n\t\t\t}\r\n\t\t\treturn(width);\r\n\t\tcase 1600:\r\n\t\t\tif(height == 600)\r\n\t\t\t{\r\n\t\t\t\treturn(width / 2);\r\n\t\t\t}\r\n\t\t\treturn(width);\r\n\t\tcase 2048:\r\n\t\t\tif(height == 768)\r\n\t\t\t{\r\n\t\t\t\treturn(width / 2);\r\n\t\t\t}\r\n\t\t\treturn(width);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn(GetSystemMetrics(SM_CXVIRTUALSCREEN));\r\n\t}\r\n}\r\n\r\nint GetScreenHeight(void)\r\n{\r\n\tOSVERSIONINFO OS_Version_Info;\r\n\tDWORD dwPlatform = 0;\r\n\t\r\n\tif(GetVersionEx(&OS_Version_Info) != 0)\r\n\t{\r\n\t\tdwPlatform = OS_Version_Info.dwPlatformId;\r\n\t}\r\n\t\r\n\tif(dwPlatform == VER_PLATFORM_WIN32_NT)\r\n\t{\r\n\t\tint width, height;\r\n\t\t\r\n\t\twidth = GetSystemMetrics(SM_CXSCREEN);\r\n\t\theight = GetSystemMetrics(SM_CYSCREEN);\r\n\t\tswitch(height)\r\n\t\t{\r\n\t\tdefault:\r\n\t\tcase 480:\r\n\t\tcase 600:\r\n\t\tcase 768:\r\n\t\t\treturn(height);\r\n\t\tcase 960:\r\n\t\t\tif(width == 640)\r\n\t\t\t{\r\n\t\t\t\treturn(height / 2);\r\n\t\t\t}\r\n\t\t\treturn(height);\r\n\t\tcase 1200:\r\n\t\t\tif(width == 800)\r\n\t\t\t{\r\n\t\t\t\treturn(height / 2);\r\n\t\t\t}\r\n\t\t\treturn(height);\r\n\t\tcase 1536:\r\n\t\t\tif(width == 1024)\r\n\t\t\t{\r\n\t\t\t\treturn(height / 2);\r\n\t\t\t}\r\n\t\t\treturn(height);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn(GetSystemMetrics(SM_CYVIRTUALSCREEN));\r\n\t}\r\n}\r\n\r\n/*------------------------------------------------------------------*\\\r\nID based Globals\r\n\\*------------------------------------------------------------------*/\r\n\r\nlong NewGroupID(int parentID, CString text)\r\n{\r\n\tlong lID=0;\r\n\tCTime time;\r\n\ttime = CTime::GetCurrentTime();\r\n\t\r\n\ttry\r\n\t{\r\n\t\t//sqlite doesn't like single quotes ' replace them with double ''\r\n\t\tif(text.IsEmpty())\r\n\t\t\ttext = time.Format(\"NewGroup %y/%m/%d %H:%M:%S\");\r\n\t\ttext.Replace(_T(\"'\"), _T(\"''\"));\r\n\r\n\t\tCString cs;\r\n\r\n\t\tcs.Format(_T(\"insert into Main (lDate, mText, lDontAutoDelete, bIsGroup, lParentID, stickyClipOrder, stickyClipGroupOrder) values(%d, '%s', %d, 1, %d, -(2147483647), -(2147483647));\"),\r\n\t\t\t\t\t\t\t(int)time.GetTime(),\r\n\t\t\t\t\t\t\ttext,\r\n\t\t\t\t\t\t\t(int)time.GetTime(),\r\n\t\t\t\t\t\t\tparentID);\r\n\r\n\t\ttheApp.m_db.execDML(cs);\r\n\r\n\t\tlID = (long)theApp.m_db.lastRowId();\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION_AND_RETURN(0)\r\n\t\r\n\treturn lID;\r\n}\r\n\r\nBOOL DeleteAllIDs()\r\n{\r\n\ttry\r\n\t{\r\n\t\ttheApp.m_db.execDML(_T(\"DELETE FROM Data;\"));\r\n\t\ttheApp.m_db.execDML(_T(\"DELETE FROM Main;\"));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL DeleteFormats(int parentID, ARRAY& formatIDs)\r\n{\t\r\n\tif(formatIDs.GetSize() <= 0)\r\n\t\treturn TRUE;\r\n\t\t\r\n\ttry\r\n\t{\r\n\t\t//Delete the requested data formats\r\n\t\tINT_PTR count = formatIDs.GetSize();\r\n\t\tfor(int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tint count = theApp.m_db.execDMLEx(_T(\"DELETE FROM Data WHERE lID = %d;\"), formatIDs[i]);\r\n\t\t}\r\n\r\n\t\tCClip clip;\r\n\t\tif(clip.LoadFormats(parentID))\r\n\t\t{\r\n\t\t\tDWORD CRC = clip.GenerateCRC();\r\n\r\n\t\t\t//Update the main table with new size\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET CRC = %d WHERE lID = %d\"), CRC, parentID);\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\t\r\n\treturn TRUE;\r\n}\r\n\r\nCRect CenterRect(CRect startingRect)\r\n{\r\n\tCRect crMonitor;\r\n\r\n\tHMONITOR monitorHandle = MonitorFromPoint(startingRect.TopLeft(), MONITOR_DEFAULTTONEAREST);\r\n\tif (monitorHandle == NULL)\r\n\t{\r\n\t\tmonitorHandle = MonitorFromPoint(startingRect.TopLeft(), MONITOR_DEFAULTTOPRIMARY);\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t\t}\r\n\t}\r\n\r\n\treturn CenterRectFromRect(startingRect, crMonitor);\r\n}\r\n\r\nCRect CenterRectFromRect(CRect startingRect, CRect outerRect)\r\n{\r\n\tCPoint center = outerRect.CenterPoint();\r\n\r\n\tCRect centerRect;\r\n\r\n\tcenterRect.left = center.x - (startingRect.Width() / 2);\r\n\tcenterRect.top = center.y - (startingRect.Height() / 2);\r\n\tcenterRect.right = centerRect.left + startingRect.Width();\r\n\tcenterRect.bottom = centerRect.top + startingRect.Height();\r\n\r\n\treturn centerRect;\r\n}\r\n\r\nCRect DefaultMonitorRect()\r\n{\r\n\tCRect crMonitor;\r\n\tCRect invalidRect(INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);\r\n\tHMONITOR monitorHandle = MonitorFromPoint(invalidRect.TopLeft(), MONITOR_DEFAULTTOPRIMARY);\r\n\tMONITORINFO lpmi;\r\n\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t{\r\n\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t}\r\n\r\n\treturn crMonitor;\r\n}\r\n\r\nCRect MonitorRectFromRect(CRect rect)\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\tCRect crMonitor;\r\n\r\n\tHMONITOR monitorHandle = MonitorFromPoint(rect.TopLeft(), MONITOR_DEFAULTTONEAREST);\r\n\tif (monitorHandle == NULL)\r\n\t{\r\n\t\tmonitorHandle = MonitorFromPoint(rect.TopLeft(), MONITOR_DEFAULTTOPRIMARY);\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t\t}\r\n\t}\r\n\r\n\treturn crMonitor;\r\n}\r\n\r\nBOOL EnsureWindowVisible(CRect *pcrRect)\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\tCRect crMonitor;\r\n\r\n\tHMONITOR monitorHandle = MonitorFromRect(pcrRect, MONITOR_DEFAULTTONEAREST);\r\n\tif (monitorHandle == NULL)\r\n\t{\r\n\t\tmonitorHandle = MonitorFromRect(pcrRect, MONITOR_DEFAULTTOPRIMARY);\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\r\n\t\t\t*pcrRect = CenterRectFromRect(*pcrRect, crMonitor);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMONITORINFO lpmi;\r\n\t\tlpmi.cbSize = sizeof(MONITORINFO);\r\n\t\tif (GetMonitorInfo(monitorHandle, &lpmi))\r\n\t\t{\r\n\t\t\tcrMonitor.CopyRect(&lpmi.rcWork);\r\n\t\t}\r\n\t}\t\r\n\r\n\tbool movedLeft = false;\r\n\t//Validate the left\r\n\tlong lDiff = pcrRect->left - crMonitor.left;\r\n\tif (lDiff < 0)\r\n\t{\r\n\t\tpcrRect->left += abs(lDiff);\r\n\t\tpcrRect->right += abs(lDiff);\r\n\t\tret = TRUE;\r\n\t\tmovedLeft = true;\r\n\t}\r\n\r\n\t//Right side\r\n\tlDiff = pcrRect->right - crMonitor.right;\r\n\tif (lDiff > 0)\r\n\t{\r\n\t\tif (movedLeft == false)\r\n\t\t{\r\n\t\t\tpcrRect->left -= abs(lDiff);\r\n\t\t}\r\n\t\tpcrRect->right -= abs(lDiff);\r\n\t\tret = TRUE;\r\n\t}\r\n\r\n\tbool movedTop = false;\r\n\t//Top\r\n\tlDiff = pcrRect->top - crMonitor.top;\r\n\tif (lDiff < 0)\r\n\t{\r\n\t\tpcrRect->top += abs(lDiff);\r\n\t\tpcrRect->bottom += abs(lDiff);\r\n\t\tret = TRUE;\r\n\t\tmovedTop = true;\r\n\t}\r\n\r\n\t//Bottom\r\n\tlDiff = pcrRect->bottom - crMonitor.bottom;\r\n\tif (lDiff > 0)\r\n\t{\r\n\t\tif (movedTop == false)\r\n\t\t{\r\n\t\t\tpcrRect->top -= abs(lDiff);\r\n\t\t}\r\n\t\tpcrRect->bottom -= abs(lDiff);\r\n\t\tret = TRUE;\r\n\t}\t\r\n\r\n\treturn ret;\r\n}\r\n\r\n__int64 GetLastWriteTime(const CString &csFile)\r\n{\r\n\t__int64 nLastWrite = 0;\r\n\tCFileFind finder;\r\n\tBOOL bResult = finder.FindFile(csFile);\r\n\r\n\tif (bResult)\r\n\t{\r\n\t\tfinder.FindNextFile();\r\n\r\n\t\tFILETIME ft;\r\n\t\tfinder.GetLastWriteTime(&ft);\r\n\r\n\t\tmemcpy(&nLastWrite, &ft, sizeof(ft));\r\n\t}\r\n\r\n\treturn nLastWrite;\r\n}\r\n\r\ntypedef struct \r\n{\r\n\tDWORD ownerpid;\r\n\tDWORD childpid;\r\n} windowinfo;\r\n\r\nBOOL CALLBACK EnumChildWindowsCallback(HWND hWnd, LPARAM lp) \r\n{\r\n\twindowinfo* info = (windowinfo*)lp;\r\n\tDWORD pid = 0;\r\n\tGetWindowThreadProcessId(hWnd, &pid);\r\n\tif (pid != info->ownerpid) \r\n\t\tinfo->childpid = pid;\r\n\treturn TRUE;\r\n}\r\n\r\nCString UWP_AppName(HWND active_window, DWORD ownerpid)\r\n{\r\n\tCString uwpAppName;\r\n\twindowinfo info = { 0 };\r\n\tinfo.ownerpid = ownerpid;\r\n\tinfo.childpid = info.ownerpid;\r\n\tEnumChildWindows(active_window, EnumChildWindowsCallback, (LPARAM)&info);\r\n\tHANDLE active_process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, info.childpid);\r\n\tif (active_process != NULL)\r\n\t{\r\n\t\tWCHAR image_name[MAX_PATH] = { 0 };\r\n\t\tDWORD bufsize = MAX_PATH;\r\n\t\tQueryFullProcessImageName(active_process, 0, image_name, &bufsize);\r\n\t\tCloseHandle(active_process);\r\n\r\n\t\tnsPath::CPath path(image_name);\r\n\t\tuwpAppName = path.GetName();\r\n\t}\r\n\r\n\treturn uwpAppName;\r\n}\r\n\r\nCString GetProcessName(HWND hWnd, DWORD processId) \r\n{\r\n\tDWORD startTick = GetTickCount();\r\n\r\n\tCString\tstrProcessName;\r\n\tDWORD Id = processId;\r\n\tif (Id == 0)\r\n\t{\t\t\r\n\t\tGetWindowThreadProcessId(hWnd, &Id);\r\n\t}\r\n\r\n\tHANDLE active_process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, Id);\r\n\tif (active_process != NULL)\r\n\t{\r\n\t\tWCHAR image_name[MAX_PATH] = { 0 };\r\n\t\tDWORD bufsize = MAX_PATH;\r\n\t\tQueryFullProcessImageName(active_process, 0, image_name, &bufsize);\r\n\t\tCloseHandle(active_process);\r\n\r\n\t\tnsPath::CPath path(image_name);\r\n\t\tstrProcessName = path.GetName();\r\n\t}\r\n\r\n\tif (strProcessName == _T(\"\"))\r\n\t{\r\n\t\tLog(StrF(_T(\"failed to get process name from open process, LastError: %d, looping over process names to find process\"), GetLastError()));\r\n\r\n\t\tPROCESSENTRY32 processEntry = { 0 };\r\n\r\n\t\tHANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\r\n\t\tprocessEntry.dwSize = sizeof(PROCESSENTRY32);\r\n\r\n\t\tif (Process32First(hSnapShot, &processEntry))\r\n\t\t{\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tif (processEntry.th32ProcessID == Id)\r\n\t\t\t\t{\r\n\t\t\t\t\tstrProcessName = processEntry.szExeFile;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} while (Process32Next(hSnapShot, &processEntry));\r\n\t\t}\r\n\r\n\t\tCloseHandle(hSnapShot);\r\n\t}\r\n\r\n\t//uwp apps are wrapped in another app called, if this has focus then try and find the child uwp process\r\n\tif (strProcessName == _T(\"ApplicationFrameHost.exe\"))\r\n\t{\r\n\t\tstrProcessName = UWP_AppName(hWnd, Id);\r\n\t}\r\n\r\n\tDWORD endTick = GetTickCount();\r\n\tDWORD diff = endTick - startTick;\r\n\tif(diff > 5)\r\n\t{\r\n\t\tLog(StrF(_T(\"GetProcessName Time (ms): %d, pid: %d, name: %s\"), endTick-startTick, Id, strProcessName));\r\n\t}\r\n\r\n\treturn strProcessName;\r\n}\r\n\r\nBOOL IsVista()\r\n{\r\n\tOSVERSIONINFO osver;\r\n\r\n\tosver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );\r\n\r\n\tif (::GetVersionEx( &osver ) && \r\n\t\tosver.dwPlatformId == VER_PLATFORM_WIN32_NT && \r\n\t\t(osver.dwMajorVersion >= 6 ) )\r\n\t{\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nbool IsRunningLimited()\r\n{\r\n\tLPCTSTR pszSubKey = _T(\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System\");\r\n\tLPCTSTR pszValue = _T(\"EnableLUA\");\r\n\tDWORD dwType = 0;\r\n\tDWORD dwValue = 0;\r\n\tDWORD dwValueSize = sizeof(DWORD);\r\n\r\n\tif(ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, pszSubKey, pszValue, &dwType, &dwValue, &dwValueSize))\r\n\t{\r\n\t\t//failed to read the reg key, either it's not there or we don't have access to the registry\r\n\t\t//If we are vista then assume we don't have access and we are running as a limited app\r\n\t\t//otherwise we are xp and the reg key probably doesn't exist and we are not a limited running app\r\n\t\tif(IsVista())\r\n\t\t{\r\n\t\t\tOutputDebugString(_T(\"Ditto - Failed to read registry entry finding UAC, Running as limited application\"));\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tif(dwValue == 1)\r\n\t{\r\n\t\tOutputDebugString(_T(\"Ditto - UAC ENABLED, Running as limited application\"));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tOutputDebugString(_T(\"Ditto - Running as standard application\"));\t\r\n\treturn false;\r\n}\r\n\r\nvoid DeleteDittoTempFiles(BOOL checkFileLastAccess)\r\n{\r\n\tCString csDir = CGetSetOptions::GetPath(PATH_REMOTE_FILES);\r\n\tif (FileExists(csDir))\r\n\t{\r\n\t\tDeleteFolderFiles(csDir, checkFileLastAccess, CTimeSpan(0, 1, 0, 0));\r\n\t}\r\n\r\n\tcsDir = CGetSetOptions::GetPath(PATH_DRAG_FILES);\r\n\tif (FileExists(csDir))\r\n\t{\r\n\t\tDeleteFolderFiles(csDir, checkFileLastAccess, CTimeSpan(0, 1, 0, 0));\r\n\t}\r\n\r\n\tcsDir = CGetSetOptions::GetPath(PATH_CLIP_DIFF);\r\n\tif (FileExists(csDir))\r\n\t{\r\n\t\tDeleteFolderFiles(csDir, checkFileLastAccess, CTimeSpan(0, 1, 0, 0));\r\n\t}\r\n}\r\n\r\nvoid DeleteFolderFiles(CString csDir, BOOL checkFileLastAccess, CTimeSpan lastAccessOffset)\r\n{\r\n\tif (csDir.Find(_T(\"\\\\ReceivedFiles\\\\\")) == -1 && csDir.Find(_T(\"\\\\DragFiles\\\\\")) == -1 && csDir.Find(_T(\"ClipCompare\")) == -1 && csDir.Find(_T(\"EditClips\")) == -1)\r\n\t\treturn;\r\n\r\n\tLog(StrF(_T(\"Deleting files in Folder %s Check Last Access %d\"), csDir, checkFileLastAccess));\r\n\r\n\tFIX_CSTRING_PATH(csDir);\r\n\r\n\tCTime ctOld = CTime::GetCurrentTime();\r\n\tCTime ctFile;\r\n\tctOld -= lastAccessOffset;\r\n\r\n\tCFileFind Find;\r\n\r\n\tCString csFindString;\r\n\tcsFindString.Format(_T(\"%s*.*\"), csDir);\r\n\r\n\tBOOL bFound = Find.FindFile(csFindString);\r\n\twhile(bFound)\r\n\t{\r\n\t\tbFound = Find.FindNextFile();\r\n\r\n\t\tif(Find.IsDots())\r\n\t\t\tcontinue;\r\n\r\n\t\tif(checkFileLastAccess &&\r\n\t\t\tFind.GetLastAccessTime(ctFile))\r\n\t\t{\r\n\t\t\t//Delete the remote copied file if it hasn't been used for the last day\r\n\t\t\tif(ctFile < ctOld)\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Deleting temp file %s\"), Find.GetFilePath()));\r\n\t\t\t\tDeleteFile(Find.GetFilePath());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"Deleting temp file %s\"), Find.GetFilePath()));\r\n\t\t\tDeleteFile(Find.GetFilePath());\r\n\t\t}\r\n\t}\r\n}\r\n\r\n__int64 FileSize(const TCHAR *fileName)\r\n{\r\n\tstruct _stat64  buf;\r\n\tif (_wstat64((wchar_t const*)fileName, &buf) != 0)\r\n\t\treturn -1; // error, could use errno to find out more\r\n\r\n\treturn buf.st_size;\r\n}\r\n\r\nint FindNoCaseAndInsert(CString& mainStr, CString& findStr, CString preInsert, CString postInsert, int linesPerRow)\r\n{\r\n\tint replaceCount = 0;\r\n\r\n\t//Prevent infinite loop when user tries to replace nothing.\r\n\tif (findStr != \"\")\r\n\t{\r\n\t\tint oldLen = findStr.GetLength();\r\n\r\n\t\tint foundPos = 0;\r\n\t\tint startFindPos = 0;\r\n\t\tint newPos = 0;\r\n\t\tint insertedLength = 0;\r\n\r\n\t\tint firstFindPos = 0;\r\n\r\n\t\tCString mainLow(theApp.m_icuString.ToLowerStringEx(mainStr));\t\t\r\n\t\tCString findLow(theApp.m_icuString.ToLowerStringEx(findStr));\r\n\t\tfindLow.MakeLower();\r\n\t\t\r\n\t\tint preLength = preInsert.GetLength();\r\n\t\tint postLength = postInsert.GetLength();\r\n\r\n\t\tint x = mainLow.Find(findLow, 0);\r\n\t\t\r\n\t\twhile(TRUE)\r\n\t\t{\r\n\t\t\tfoundPos = mainLow.Find(findLow, startFindPos);\r\n\t\t\tif (foundPos < 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tif (replaceCount == 0)\r\n\t\t\t{\r\n\t\t\t\tfirstFindPos = foundPos + preLength;\r\n\t\t\t}\r\n\r\n\t\t\tnewPos = foundPos + insertedLength;\r\n\r\n\t\t\tmainStr.Insert(newPos, preInsert);\r\n\t\t\tmainStr.Insert(newPos + preLength + oldLen, postInsert);\r\n\r\n\t\t\tstartFindPos = foundPos + oldLen;\r\n\r\n\t\t\tinsertedLength += preLength + postLength;\r\n\r\n\t\t\treplaceCount++;\r\n\r\n\t\t\t//safety check, make sure we don't look forever\r\n\t\t\tif (replaceCount > 100)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tstartFindPos = 0;\r\n\t\tint line = 0;\r\n\t\tint prevLinePos = 0;\r\n\t\tint prevPrevLinePos = 0;\r\n\r\n\t\twhile (TRUE)\r\n\t\t{\r\n\t\t\tfoundPos = mainStr.Find(_T(\"\\n\"), startFindPos);\r\n\t\t\tif (foundPos < 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tif (firstFindPos < foundPos)\r\n\t\t\t{\r\n\t\t\t\tif (line > linesPerRow - 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tint lineStart = prevLinePos;\r\n\t\t\t\t\tif (linesPerRow > 1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlineStart = prevPrevLinePos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmainStr = _T(\"... \") + mainStr.Mid(lineStart + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\tstartFindPos = foundPos + 1;\r\n\t\t\tprevPrevLinePos = prevLinePos;\r\n\t\t\tprevLinePos = foundPos;\r\n\r\n\t\t\tline++;\r\n\r\n\t\t\t//safety check, make sure we don't look forever\r\n\t\t\tif (line > 1000)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(replaceCount > 0)\r\n\t\t{\r\n\t\t\t//use unprintable characters so it doesn't find copied html to convert\r\n\t\t\tmainStr.Replace(_T(\"\\r\\n\"), _T(\"\\x01\\x05\\x02\"));\r\n\t\t\tint l = mainStr.Replace(_T(\"\\r\"), _T(\"\\x01\\x05\\x02\"));\r\n\t\t\tint m = mainStr.Replace(_T(\"\\n\"), _T(\"\\x01\\x05\\x02\"));\r\n\t\t}\r\n\t}\r\n\r\n\treturn replaceCount;\r\n}\r\n\r\nvoid OnInitMenuPopupEx(CMenu *pPopupMenu, UINT nIndex, BOOL bSysMenu, CWnd *pWnd)\r\n{\r\n\tASSERT(pPopupMenu != NULL);\r\n\t// Check the enabled state of various menu items.\r\n\r\n\tCCmdUI state;\r\n\tstate.m_pMenu = pPopupMenu;\r\n\tASSERT(state.m_pOther == NULL);\r\n\tASSERT(state.m_pParentMenu == NULL);\r\n\r\n\t// Determine if menu is popup in top-level menu and set m_pOther to\r\n\t// it if so (m_pParentMenu == NULL indicates that it is secondary popup).\r\n\tHMENU hParentMenu;\r\n\tif (AfxGetThreadState()->m_hTrackingMenu == pPopupMenu->m_hMenu)\r\n\t{\r\n\t\tstate.m_pParentMenu = pPopupMenu;    // Parent == child for tracking popup.\r\n\t}\r\n\telse if ((hParentMenu = ::GetMenu(pWnd->m_hWnd)) != NULL)\r\n\t{\r\n\t\tCWnd* pParent = pWnd;\r\n\t\t// Child windows don't have menus--need to go to the top!\r\n\t\tif (pParent != NULL &&\r\n\t\t\t(hParentMenu = ::GetMenu(pParent->m_hWnd)) != NULL)\r\n\t\t{\r\n\t\t\tint nIndexMax = ::GetMenuItemCount(hParentMenu);\r\n\t\t\tfor (int nIndex = 0; nIndex < nIndexMax; nIndex++)\r\n\t\t\t{\r\n\t\t\t\tif (::GetSubMenu(hParentMenu, nIndex) == pPopupMenu->m_hMenu)\r\n\t\t\t\t{\r\n\t\t\t\t\t// When popup is found, m_pParentMenu is containing menu.\r\n\t\t\t\t\tstate.m_pParentMenu = CMenu::FromHandle(hParentMenu);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstate.m_nIndexMax = pPopupMenu->GetMenuItemCount();\r\n\tfor (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;\r\n\t\tstate.m_nIndex++)\r\n\t{\r\n\t\tstate.m_nID = pPopupMenu->GetMenuItemID(state.m_nIndex);\r\n\t\tif (state.m_nID == 0)\r\n\t\t\tcontinue; // Menu separator or invalid cmd - ignore it.\r\n\r\n\t\tASSERT(state.m_pOther == NULL);\r\n\t\tASSERT(state.m_pMenu != NULL);\r\n\t\tif (state.m_nID == (UINT)-1)\r\n\t\t{\r\n\t\t\t// Possibly a popup menu, route to first item of that popup.\r\n\t\t\tstate.m_pSubMenu = pPopupMenu->GetSubMenu(state.m_nIndex);\r\n\t\t\tif (state.m_pSubMenu == NULL ||\r\n\t\t\t\t(state.m_nID = state.m_pSubMenu->GetMenuItemID(0)) == 0 ||\r\n\t\t\t\tstate.m_nID == (UINT)-1)\r\n\t\t\t{\r\n\t\t\t\tcontinue;       // First item of popup can't be routed to.\r\n\t\t\t}\r\n\t\t\tstate.DoUpdate(pWnd, TRUE);   // Popups are never auto disabled.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Normal menu item.\r\n\t\t\t// Auto enable/disable if frame window has m_bAutoMenuEnable\r\n\t\t\t// set and command is _not_ a system command.\r\n\t\t\tstate.m_pSubMenu = NULL;\r\n\t\t\tstate.DoUpdate(pWnd, FALSE);\r\n\t\t}\r\n\r\n\t\t// Adjust for menu deletions and additions.\r\n\t\tUINT nCount = pPopupMenu->GetMenuItemCount();\r\n\t\tif (nCount < state.m_nIndexMax)\r\n\t\t{\r\n\t\t\tstate.m_nIndex -= (state.m_nIndexMax - nCount);\r\n\t\t\twhile (state.m_nIndex < nCount &&\r\n\t\t\t\tpPopupMenu->GetMenuItemID(state.m_nIndex) == state.m_nID)\r\n\t\t\t{\r\n\t\t\t\tstate.m_nIndex++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstate.m_nIndexMax = nCount;\r\n\t}\r\n} \r\n\r\nCString InternetEncode(CString text)\r\n{\r\n\tCString ret = _T(\"\");\r\n\tLPTSTR lpOutputBuffer = new TCHAR[1];\r\n\tDWORD dwSize = 1;\r\n\tBOOL fRes = ::InternetCanonicalizeUrl(text, lpOutputBuffer, &dwSize, ICU_BROWSER_MODE);\r\n\tDWORD dwError = ::GetLastError();\r\n\tif (!fRes && dwError == ERROR_INSUFFICIENT_BUFFER)\r\n\t{\r\n\t\tdelete lpOutputBuffer;\r\n\t\tlpOutputBuffer = new TCHAR[dwSize];\r\n\t\tfRes = ::InternetCanonicalizeUrl(text, lpOutputBuffer, &dwSize, ICU_BROWSER_MODE);\r\n\t\tif (fRes)\r\n\t\t{\r\n\t\t\tret = lpOutputBuffer;\r\n\t\t\t//lpOutputBuffer has decoded url\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//failed to decode\r\n\t\t}\r\n\t\tif (lpOutputBuffer != NULL)\r\n\t\t{\r\n\t\t\tdelete [] lpOutputBuffer;\r\n\t\t\tlpOutputBuffer = NULL;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//some other error OR the input string url is just 1 char and was successfully decoded\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid DeleteParamFromRTF(CStringA &test, CStringA find, bool searchForTrailingDigits)\r\n{\r\n\tint start = 0;\r\n\r\n\twhile (start >= 0)\r\n\t{\r\n\t\tstart = test.Find(find, start);\r\n\t\tif (start >= 0)\r\n\t\t{\r\n\t\t\tif (start > 0)\r\n\t\t\t{\r\n\t\t\t\t//leave it if the preceding character is \\\\, i was seeing the double slash if the actual text contained slash\r\n\t\t\t\tif (test[start - 1] == '\\\\')\r\n\t\t\t\t{\r\n\t\t\t\t\tstart++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint end = -1;\t\r\n\t\t\tint innerStart = start + find.GetLength();\r\n\r\n\t\t\tif (searchForTrailingDigits)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = innerStart; i < test.GetLength(); i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (isdigit(test[i]) == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tend = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend = innerStart;\r\n\t\t\t}\r\n\r\n\t\t\tif (end > 0)\r\n\t\t\t{\r\n\t\t\t\tif (searchForTrailingDigits == false ||\r\n\t\t\t\t\tend != innerStart)\r\n\t\t\t\t{\r\n\t\t\t\t\ttest.Delete(start, (end - start));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstart++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool RemoveRTFSection(CStringA &str, CStringA section)\r\n{\r\n\tbool removedSection = false;\r\n\r\n\tint start2 = str.Find(section, 0);\r\n\tint end2 = 0;\r\n\tif (start2 >= 0)\r\n\t{\r\n\t\tint in = 0;\r\n\t\tfor (int pos = start2+1; pos < str.GetLength(); pos++)\r\n\t\t{\r\n\t\t\tif (str[pos] == '{')\r\n\t\t\t{\r\n\t\t\t\tin++;\r\n\t\t\t}\r\n\r\n\t\t\tif (str[pos] == '}')\r\n\t\t\t{\r\n\t\t\t\tif (in > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tin--;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tend2 = pos;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (end2 > start2)\r\n\t\t{\r\n\t\t\tstr.Delete(start2, (end2 - start2) + 1);\r\n\t\t\tremovedSection = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn removedSection;\r\n}\r\n\r\nCString NewGuidString()\r\n{\r\n\tCString guidString;\r\n\r\n\tGUID guid;\r\n\tCoCreateGuid(&guid);\r\n\tguidString.Format(_T(\"%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX\"),\r\n\t\tguid.Data1, guid.Data2, guid.Data3,\r\n\t\tguid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],\r\n\t\tguid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);\r\n\r\n\treturn guidString;\r\n}\r\n\r\nCString FolderPath(int folderId)\r\n{\r\n\tCString folder = _T(\"\");\r\n\tif (folderId > 0)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tCStringArray arr;\r\n\t\t\tfor (int i = 0; i < 100; i++)\r\n\t\t\t{\r\n\t\t\t\tCppSQLite3Query parent = theApp.m_db.execQueryEx(_T(\"SELECT lID, mText, lParentID FROM Main WHERE lID = %d\"), folderId);\r\n\t\t\t\tif (parent.eof() == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tarr.Add(parent.getStringField(_T(\"mText\")));\r\n\t\t\t\t\tfolderId = parent.getIntField(_T(\"lParentID\"));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfolder = _T(\"Group Path: \\\\\");\r\n\t\t\tfor (int folderPos = arr.GetCount() - 1; folderPos >= 0; folderPos--)\r\n\t\t\t{\r\n\t\t\t\tfolder += _T(\"\\\\\");\r\n\t\t\t\tfolder += arr[folderPos];\r\n\t\t\t}\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n\r\n\treturn folder;\r\n}\r\n\r\nBOOL DarkAppWindows10Setting()\r\n{\r\n\tBOOL darkMode = false;\r\n\tHKEY hkKey;\r\n\tlong lResult = ::RegOpenKeyEx(HKEY_CURRENT_USER, _T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\"), NULL, KEY_READ, &hkKey);\r\n\tif (lResult == ERROR_SUCCESS)\r\n\t{\r\n\t\tDWORD buffer;\r\n\t\tDWORD len = sizeof(buffer);\r\n\t\tDWORD type;\r\n\r\n\t\tlResult = ::RegQueryValueEx(hkKey, _T(\"AppsUseLightTheme\"), 0, &type, (LPBYTE)&buffer, &len);\r\n\r\n\t\tif (lResult == ERROR_SUCCESS)\r\n\t\t{\r\n\t\t\tdarkMode = (buffer == 0);\r\n\t\t}\r\n\r\n\t\tRegCloseKey(hkKey);\r\n\t}\r\n\r\n\treturn darkMode;\r\n}\r\n\r\nDWORD Windows10AccentColor()\r\n{\r\n\tDWORD color = -1;\r\n\tBOOL darkMode = false;\r\n\tHKEY hkKey;\r\n\tlong lResult = ::RegOpenKeyEx(HKEY_CURRENT_USER, _T(\"Software\\\\Microsoft\\\\Windows\\\\DWM\"), NULL, KEY_READ, &hkKey);\r\n\tif (lResult == ERROR_SUCCESS)\r\n\t{\r\n\t\tDWORD buffer;\r\n\t\tDWORD len = sizeof(buffer);\r\n\t\tDWORD type;\r\n\r\n\t\tlResult = ::RegQueryValueEx(hkKey, _T(\"ColorizationColor\"), 0, &type, (LPBYTE)&buffer, &len);\r\n\r\n\t\tif (lResult == ERROR_SUCCESS)\r\n\t\t{\r\n\t\t\tcolor = buffer;\r\n\t\t}\r\n\r\n\t\tRegCloseKey(hkKey);\r\n\t}\r\n\r\n\treturn color;\r\n}\r\n\r\nBOOL Windows10ColorTitleBar()\r\n{\r\n\tBOOL colorTitleBar = FALSE;\r\n\tBOOL darkMode = false;\r\n\tHKEY hkKey;\r\n\tlong lResult = ::RegOpenKeyEx(HKEY_CURRENT_USER, _T(\"Software\\\\Microsoft\\\\Windows\\\\DWM\"), NULL, KEY_READ, &hkKey);\r\n\tif (lResult == ERROR_SUCCESS)\r\n\t{\r\n\t\tDWORD buffer;\r\n\t\tDWORD len = sizeof(buffer);\r\n\t\tDWORD type;\r\n\r\n\t\tlResult = ::RegQueryValueEx(hkKey, _T(\"ColorPrevalence\"), 0, &type, (LPBYTE)&buffer, &len);\r\n\r\n\t\tif (lResult == ERROR_SUCCESS)\r\n\t\t{\r\n\t\t\tcolorTitleBar = (buffer == 1);\r\n\t\t}\r\n\r\n\t\tRegCloseKey(hkKey);\r\n\t}\r\n\r\n\treturn colorTitleBar;\r\n}\r\n\r\nBOOL RestoreDbPrompt(HWND hwnd)\r\n{\r\n\tBOOL ret = false;\r\n\r\n\tOPENFILENAME ofn;\r\n\tTCHAR szFile[400];\r\n\tTCHAR szDir[400];\r\n\r\n\tmemset(&szFile, 0, sizeof(szFile));\r\n\tmemset(szDir, 0, sizeof(szDir));\r\n\tmemset(&ofn, 0, sizeof(ofn));\r\n\r\n\tofn.lStructSize = sizeof(OPENFILENAME);\r\n\tofn.hwndOwner = hwnd;\r\n\tofn.lpstrFile = szFile;\r\n\tofn.nMaxFile = sizeof(szFile);\r\n\tofn.lpstrFilter = _T(\"Ditto database backups (.zdb)\\0*.zdb\\0\\0\");\r\n\tofn.nFilterIndex = 1;\r\n\tofn.lpstrFileTitle = NULL;\r\n\tofn.nMaxFileTitle = 0;\r\n\t//ofn.lpstrInitialDir = szDir;\r\n\tofn.lpstrDefExt = _T(\"zdb\");\r\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;\r\n\r\n\tif (GetOpenFileName(&ofn))\r\n\t{\r\n\t\tCWaitCursor wait;\r\n\r\n\t\tCString dbPath = CGetSetOptions::GetDBPath();\r\n\t\tCString backupPath(ofn.lpstrFile);\r\n\t\tret = RestoreDB(backupPath);\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nBOOL BackupDbPrompt(HWND hwnd)\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\tOPENFILENAME ofn;\r\n\tTCHAR szFile[400];\r\n\tTCHAR szDir[400];\r\n\r\n\tmemset(&szFile, 0, sizeof(szFile));\r\n\tmemset(szDir, 0, sizeof(szDir));\r\n\tmemset(&ofn, 0, sizeof(ofn));\r\n\r\n\tofn.lStructSize = sizeof(OPENFILENAME);\r\n\tofn.hwndOwner = hwnd;\r\n\tofn.lpstrFile = szFile;\r\n\tofn.nMaxFile = sizeof(szFile);\r\n\tofn.lpstrFilter = _T(\"Ditto database backups (.zdb)\\0*.zdb\\0\\0\");\r\n\tofn.nFilterIndex = 1;\r\n\tofn.lpstrFileTitle = NULL;\r\n\tofn.nMaxFileTitle = 0;\r\n\t//ofn.lpstrInitialDir = szDir;\r\n\tofn.lpstrDefExt = _T(\"zdb\");\r\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;\r\n\r\n\tif (GetSaveFileName(&ofn))\r\n\t{\r\n\t\tCWaitCursor wait;\r\n\r\n\t\tCString dbPath = CGetSetOptions::GetDBPath();\r\n\t\tCString backupPath(ofn.lpstrFile);\r\n\t\tret = BackupDB(dbPath, backupPath);\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nint WordCount(const CString &text)\r\n{\r\n\t#define OUT 0\r\n\t#define IN 1\r\n\r\n\tint state = OUT;\r\n\tunsigned wc = 0; // word count\r\n\r\n\t// Scan all characters one by one\r\n\tfor(int pos = 0; pos < text.GetLength(); pos++)\t\r\n\t{\r\n\t\tauto str = text[pos];\r\n\t\t\r\n\t\tif (str == ' ' || str == '\\r' || str == '\\n' || str == '\\t')\r\n\t\t{\r\n\t\t\tstate = OUT;\r\n\t\t}\r\n\t\telse if (state == OUT)\r\n\t\t{\r\n\t\t\tstate = IN;\r\n\t\t\twc++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn wc;\r\n}\r\n\r\nCString GetVersionString(VersionInfo version)\r\n{\r\n\tCString csLine;\r\n\tcsLine.Format(_T(\"%02i.%02i.%02i.%02i\"),\r\n\t\tversion.Major,\r\n\t\tversion.Minor,\r\n\t\tversion.Revision,\r\n\t\tversion.Build);\r\n\r\n\treturn csLine;\r\n}\r\n\r\nVersionInfo GetRunningVersion()\r\n{\r\n\tVersionInfo verInfo;\r\n\tCString csFileName = CGetSetOptions::GetExeFileName();\r\n\r\n\tDWORD dwSize, dwHandle;\r\n\tLPBYTE lpData;\r\n\tUINT iBuffSize;\r\n\tVS_FIXEDFILEINFO* lpFFI;\r\n\r\n\tdwSize = GetFileVersionInfoSize(csFileName.GetBuffer(csFileName.GetLength()), &dwHandle);\r\n\r\n\tif (dwSize != 0)\r\n\t{\r\n\t\tcsFileName.ReleaseBuffer();\r\n\t\tif ((lpData = (unsigned char*)malloc(dwSize)) != NULL)\r\n\t\t{\r\n\t\t\tif (GetFileVersionInfo(csFileName.GetBuffer(csFileName.GetLength()), dwHandle, dwSize, lpData) != 0)\r\n\t\t\t{\r\n\t\t\t\tif (VerQueryValue(lpData, _T(\"\\\\\"), (LPVOID*)&lpFFI, &iBuffSize) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (iBuffSize > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tverInfo.Major = (lpFFI->dwProductVersionMS >> 16) & 0xffff;\r\n\t\t\t\t\t\tverInfo.Minor = (lpFFI->dwProductVersionMS >> 0) & 0xffff;\r\n\t\t\t\t\t\tverInfo.Revision = (lpFFI->dwProductVersionLS >> 16) & 0xffff;\r\n\t\t\t\t\t\tverInfo.Build = (lpFFI->dwProductVersionLS >> 0) & 0xffff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(lpData);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(verInfo);\r\n}"
        },
        {
          "name": "Misc.h",
          "type": "blob",
          "size": 7.0126953125,
          "content": "\r\n#if !defined(AFX_CP_GUI_GLOBALS__FBCDED09_A6F2_47EB_873F_50A746EBC86B__INCLUDED_)\r\n#define AFX_CP_GUI_H__FBCDED09_A6F2_47EB_873F_50A746EBC86B__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n\r\n#include \"Shared/ArrayEx.h\"\r\n#include <vector>\r\n\r\n#define VK_MOUSE_CLICK 0x01\r\n#define VK_MOUSE_DOUBLE_CLICK 0x02\r\n#define VK_MOUSE_RIGHT_CLICK 0x03\r\n#define VK_MOUSE_MIDDLE_CLICK 0x04\r\n\r\n#define UPDATE_AFTER_PASTE_SELECT_CLIP 0x1\r\n#define UPDATE_CLIP_DESCRIPTION 0x2\r\n\r\n#define REMOTE_CLIP_ADD_TO_CLIPBOARD 0x1\r\n#define REMOTE_CLIP_MANUAL_SEND 0x2\r\n\r\n\r\n//Handle foreign keyboards pressing ALT_GR (right alt), this simulates a control press\r\n//http://compgroups.net/comp.os.programmer.win32/alt-gr-key-and-left-ctrl/2840252\r\n#define CONTROL_PRESSED ((::GetKeyState(VK_CONTROL) & 0x8000) && (((GetKeyState(VK_RMENU) < 0) && (GetKeyState(VK_LCONTROL) < 0)) == FALSE))\r\n\r\n#define ONE_MINUTE\t\t\t\t60000\r\n#define ONE_HOUR\t\t\t\t3600000\r\n#define ONE_DAY\t\t\t\t\t86400000\r\n\r\nclass CopyReasonEnum\r\n{\r\npublic:\r\n\tenum CopyReason\r\n\t{ \r\n\t\tCOPY_TO_UNKOWN,\r\n\t\tCOPY_TO_GROUP,\r\n\t\tCOPY_TO_BUFFER,\r\n\t\tCOPY_FROM_TOOLTIP\r\n\t};\r\n};\r\n\r\n#define INVALID_STICKY\t-(2147483647)\r\n\r\n#define CATCH_SQLITE_EXCEPTION\t\t\\\r\n\tcatch (CppSQLite3Exception& e)\t\\\r\n    {\t\t\t\t\t\t\t\t\\\r\n\t\tLog(StrF(_T(\"SQLITE Exception %d - %s\"), e.errorCode(), e.errorMessage()));\t\\\r\n\t\tASSERT(FALSE);\t\t\t\t\\\r\n    }\t\t\t\t\t\t\t\t\\\r\n\r\n#define CATCH_SQLITE_EXCEPTION_AND_RETURN(bRet)\t\t\\\r\n\tcatch (CppSQLite3Exception& e)\t\\\r\n    {\t\t\t\t\t\t\t\t\\\r\n\t\tLog(StrF(_T(\"SQLITE Exception %d - %s\"), e.errorCode(), e.errorMessage()));\t\\\r\n\t\tASSERT(FALSE);\t\t\t\t\\\r\n\t\treturn bRet;\t\t\t\t\\\r\n    }\t\t\t\t\t\t\t\t\\\r\n\t\r\n#define\tFIX_PATH(strPath) \\\r\n{ \\\r\n\tif (strPath[strlen(strPath)-1] != '\\\\' && strPath[strlen(strPath)-1] != '/') \\\r\n\tstrcat(strPath, \"\\\\\"); \\\r\n}\r\n\r\n#define\tFIX_CSTRING_PATH(csPath) \\\r\n{ \\\r\n\tif(csPath.IsEmpty() == FALSE && csPath.GetAt(csPath.GetLength()-1) != '\\\\' && csPath.GetAt(csPath.GetLength()-1) != '/') \\\r\n\tcsPath += \"\\\\\"; \\\r\n}\r\n\r\n#include \"DatabaseUtilities.h\"\r\n\r\nCString GetIPAddress();\r\nCString GetComputerName();\r\n\r\n#define FUNC\t\t__FUNCTION__\r\n#define FUNCSIG\t\t__FUNCSIG__\r\nvoid AppendToFile(const TCHAR* fn, const TCHAR *msg);\r\n#define Log(msg) log(msg, false, __FILE__, __LINE__)\r\nvoid log(const TCHAR* msg, bool bFromSendRecieve = false, CString csFile = _T(\"\"), long lLine = -1);\r\nCString GetErrorString(int err);\r\n\r\ndouble IdleSeconds();\r\n\r\n#define LogSendRecieveInfo(cs) logsendrecieveinfo(cs, __FILE__, __LINE__);\r\nvoid logsendrecieveinfo(CString cs, CString csFile = _T(\"\"), long lLine = -1);\r\n\r\n// Utility Functions\r\nCString StrF(const TCHAR * pszFormat, ...);\r\n// called after determining that the preceding character is a backslash\r\nBYTE GetEscapeChar( BYTE ch );\r\nCString RemoveEscapes( const TCHAR* str );\r\n\r\nCString GetWndText( HWND hWnd );\r\n// returns true if the given window is owned by this process\r\nbool IsAppWnd( HWND hWnd );\r\n\r\n// Global Memory Helper Functions\r\nBOOL IsValid(HGLOBAL hGlobal);\r\nvoid CopyToGlobalHP(HGLOBAL hDest, LPVOID pBuf, SIZE_T ulBufLen);\r\nvoid CopyToGlobalHH(HGLOBAL hDest, HGLOBAL hSource, SIZE_T ulBufLen);\r\nHGLOBAL NewGlobalP(LPVOID pBuf, SIZE_T nLen);\r\nHGLOBAL NewGlobalH(HGLOBAL hSource, SIZE_T nLen);\r\nHGLOBAL NewGlobal(SIZE_T nLen);\r\nint CompareGlobalHP(HGLOBAL hLeft, LPVOID pBuf, SIZE_T ulBufLen);\r\nint CompareGlobalHH(HGLOBAL hLeft, HGLOBAL hRight, SIZE_T ulBufLen);\r\n\r\nBOOL EncryptString(CString &csString, UCHAR*& pOutput, int &nLenOutput);\r\nBOOL DecryptString(UCHAR *pData, int nLenIn, UCHAR*& pOutput, int &nLenOutput);\r\n\r\nint GetScreenWidth();\r\nint GetScreenHeight();\r\n\r\nstd::vector<CLIPFORMAT> GetSystemClipFormats();\r\nCLIPFORMAT GetFormatID(LPCTSTR cbName);\r\nCString GetFormatName(CLIPFORMAT cbType);\r\nBOOL PreTranslateGuiDll(MSG *pMsg);\r\n\r\nCString GetFilePath(CString csFullPath);\r\nCString GetFileName(CString csFileName);\r\n\r\nBOOL EnsureWindowVisible(CRect *pcrRect);\r\n\r\nCRect DefaultMonitorRect();\r\nCRect MonitorRectFromRect(CRect rect);\r\n\r\nCRect CenterRect(CRect startingRect);\r\nCRect CenterRectFromRect(CRect startingRect, CRect outerRect);\r\n\r\n__int64 GetLastWriteTime(const CString &csFile);\r\n\r\n\r\n//Message to the main window to show icon or not\r\n#define WM_SHOW_TRAY_ICON\t\tWM_USER + 200\r\n#define WM_SETCONNECT\t\t\tWM_USER + 201\r\n#define WM_CV_IS_CONNECTED\t\tWM_USER + 202\r\n#define WM_CLOSE_APP\t\t\tWM_USER + 204\r\n#define WM_REFRESH_VIEW\t\t\tWM_USER + 205\r\n#define WM_CLIPBOARD_COPIED\t\tWM_USER + 206\r\n#define WM_ADD_TO_DATABASE_FROM_SOCKET\t\tWM_USER + 207\r\n#define WM_SEND_RECIEVE_ERROR\tWM_USER + 208\r\n#define WM_FOCUS_CHANGED\t\tWM_USER + 209\r\n#define WM_CV_GETCONNECT\t\tWM_USER + 211\r\n#define WM_EDIT_WND_CLOSING\t\tWM_USER\t+ 212\r\n#define WM_SET_CONNECTED\t\tWM_USER\t+ 213\r\n#define WM_LOAD_ClIP_ON_CLIPBOARD\t\tWM_USER\t+ 214\r\n//defined in tray icon #define WM_CUSTOMIZE_TRAY_MENU\tWM_USER + 215\r\n//defined in tray icon #define WM_TRAY_MENU_MOUSE_MOVE\tWM_USER + 216\r\n#define WM_RELOAD_CLIP_IN_UI\tWM_USER\t+ 217\r\n#define WM_GLOBAL_CLIPS_CLOSED\tWM_USER\t+ 218\r\n#define WM_OPTIONS_CLOSED\tWM_USER\t+ 219\r\n#define WM_SHOW_OPTIONS\tWM_USER\t+ 220\r\n#define WM_DELETE_CLIPS_CLOSED\tWM_USER\t+ 221\r\n#define WM_OPEN_CLOSE_WINDOW WM_USER + 222\r\n#define WM_SAVE_CLIPBOARD WM_USER + 223\r\n#define WM_READD_TASKBAR_ICON WM_USER + 224\r\n#define WM_REOPEN_DATABASE WM_USER + 225\r\n#define WM_SHOW_MSG_WINDOW WM_USER + 226\r\n#define WM_SHOW_DITTO_GROUP WM_USER + 227\r\n#define WM_PLAIN_TEXT_PASTE WM_USER + 228\r\n#define WM_SHOW_ERROR_MSG\tWM_USER + 229\r\n#define WM_RESTORE_DB\tWM_USER + 230\r\n#define WM_BACKUP_DB\tWM_USER + 231\r\n#define WM_REFRESH_FOOTER WM_USER + 232\r\n#define WM_PASTE_CLIP WM_USER + 233\r\n#define WM_EDIT_CLIP WM_USER + 234\r\n\r\n\r\n#if !defined(_BITSET_)\r\n#\tinclude <bitset>\r\n#endif // !defined(_BITSET_)\r\n\r\nlong NewGroupID(int parentID = 0, CString text = \"\");\r\nBOOL DeleteAllIDs();\r\nBOOL DeleteFormats(int parentID, ARRAY& formatIDs);\r\n\r\n__inline BOOL FileExists(LPCTSTR pszFile)\r\n{ \r\n\treturn (GetFileAttributes(pszFile) != 0xffffffff); \r\n}\r\n\r\nbool IsRunningLimited();\r\nBOOL IsVista();\r\n\r\nvoid DeleteDittoTempFiles(BOOL checkFileLastAccess);\r\nvoid DeleteFolderFiles(CString csDir, BOOL checkFileLastAccess, CTimeSpan lastAccessOffset);\r\n\r\n__int64 FileSize(const TCHAR *fileName);\r\n\r\nint FindNoCaseAndInsert(CString& mainStr, CString& findStr, CString preInsert, CString postInsert, int linesPerRow);\r\n\r\nvoid OnInitMenuPopupEx(CMenu *pPopupMenu, UINT nIndex, BOOL bSysMenu, CWnd *pWnd);\r\n\r\nCString InternetEncode(CString text);\r\n\r\nCString GetProcessName(HWND hWnd, DWORD processId = 0);\r\n\r\nvoid DeleteParamFromRTF(CStringA &test, CStringA find, bool searchForTrailingDigits);\r\n\r\nbool RemoveRTFSection(CStringA &str, CStringA section);\r\n\r\nCString NewGuidString();\r\n\r\nCString FolderPath(int folderId);\r\n\r\nCString TopLevelWindowText(DWORD pid);\r\n\r\nBOOL DarkAppWindows10Setting();\r\nDWORD Windows10AccentColor();\r\nBOOL Windows10ColorTitleBar();\r\n\r\nBOOL BackupDbPrompt(HWND hwnd);\r\nBOOL RestoreDbPrompt(HWND hwnd);\r\n\r\nint WordCount(const CString& text);\r\n\r\nclass VersionInfo\r\n{\r\npublic:\r\n\tint Major;\r\n\tint Minor;\r\n\tint Revision;\r\n\tint Build;\r\n};\r\n\r\nVersionInfo GetRunningVersion();\r\nCString GetVersionString(VersionInfo version);\r\n\r\n#endif // !defined(AFX_CP_GUI_GLOBALS__FBCDED09_A6F2_47EB_873F_50A746EBC86B__INCLUDED_)\r\n"
        },
        {
          "name": "MoveToGroupDlg.cpp",
          "type": "blob",
          "size": 2.1669921875,
          "content": "// MoveToGroupDlg.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"MoveToGroupDlg.h\"\n#include \"GroupName.h\"\n#include \"ProcessPaste.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CMoveToGroupDlg dialog\n\n\nCMoveToGroupDlg::CMoveToGroupDlg(CWnd* pParent /*=NULL*/)\n\t: CDialog(CMoveToGroupDlg::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CMoveToGroupDlg)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tm_nSelectedGroup = -1;\n}\n\n\nvoid CMoveToGroupDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CMoveToGroupDlg)\n\tDDX_Control(pDX, IDC_TREE, m_Tree);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CMoveToGroupDlg, CDialog)\n\t//{{AFX_MSG_MAP(CMoveToGroupDlg)\n\tON_WM_SIZE()\n\tON_BN_CLICKED(IDC_BUTTON_NEW_GROUP, OnButtonNewGroup)\n\t//}}AFX_MSG_MAP\n\tON_MESSAGE(NM_GROUP_TREE_MESSAGE, OnTreeSelect)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CMoveToGroupDlg message handlers\n\nBOOL CMoveToGroupDlg::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tm_Tree.m_selectedFolderID = m_nSelectedGroup;\n\tm_Tree.SetNotificationWndEx(m_hWnd);\n\tm_Tree.FillTree();\n\n\ttheApp.m_Language.UpdateMoveToGroups(this);\n\t\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nLRESULT CMoveToGroupDlg::OnTreeSelect(WPARAM wParam, LPARAM lParam)\n{\n\tint nID = (int)wParam;\n\tif(nID != 0)\n\t{\n\t\tm_nSelectedGroup = nID;\n\t\tOnOK();\n\t}\n\telse\n\t{\n\t\tOnCancel();\n\t}\n\n\treturn TRUE;\n}\n\nvoid CMoveToGroupDlg::OnOK() \n{\n\tm_nSelectedGroup = m_Tree.GetSelectedTree();\n\t\n\tCDialog::OnOK();\n}\n\nvoid CMoveToGroupDlg::OnSize(UINT nType, int cx, int cy) \n{\n\tCDialog::OnSize(nType, cx, cy);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\nvoid CMoveToGroupDlg::OnButtonNewGroup() \n{\n\tCGroupName Name;\n\tif(Name.DoModal() != IDOK)\n\t\treturn;\n\t\t\n\tCString csName = Name.m_csName;\n\t\n\tlong lID = NewGroupID(m_Tree.GetSelectedTree(), csName);\n\tif(lID >= 0)\n\t{\n\t\tm_Tree.AddNode(csName, lID);\n\t}\n\n\tm_Tree.SetFocus();\n}\n"
        },
        {
          "name": "MoveToGroupDlg.h",
          "type": "blob",
          "size": 1.4658203125,
          "content": "#if !defined(AFX_MOVETOGROUPDLG_H__0F42AFA2_0097_489B_B014_3815E7327940__INCLUDED_)\n#define AFX_MOVETOGROUPDLG_H__0F42AFA2_0097_489B_B014_3815E7327940__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// MoveToGroupDlg.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CMoveToGroupDlg dialog\n\nclass CMoveToGroupDlg : public CDialog\n{\n// Construction\npublic:\n\tCMoveToGroupDlg(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CMoveToGroupDlg)\n\tenum { IDD = IDD_MOVE_TO_GROUP };\n\tCGroupTree\tm_Tree;\n\t//}}AFX_DATA\n\n\tint GetSelectedGroup()\t\t\t\t{ return m_nSelectedGroup; }\n\tvoid SetSlectedGroup(int nGroup)\t{ m_nSelectedGroup = nGroup; }\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CMoveToGroupDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\tint m_nSelectedGroup;\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CMoveToGroupDlg)\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnOK();\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnButtonNewGroup();\n\t//}}AFX_MSG\n\tLRESULT OnTreeSelect(WPARAM wParam, LPARAM lParam);\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_MOVETOGROUPDLG_H__0F42AFA2_0097_489B_B014_3815E7327940__INCLUDED_)\n"
        },
        {
          "name": "MultiLanguage.cpp",
          "type": "blob",
          "size": 12.7216796875,
          "content": "// MultiLanguage.cpp: implementation of the CMultiLanguage class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"MultiLanguage.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"shared/TextConvert.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nCMultiLanguage::CMultiLanguage()\r\n{\r\n\tm_csAuthor = \"\";\r\n\tm_csLangCode = \"\";\r\n\tm_lFileVersion = 0;\r\n\tm_bOnlyGetHeader = false;\r\n}\r\n\r\nCMultiLanguage::~CMultiLanguage()\r\n{\r\n\tClearArrays();\r\n}\r\n\r\nvoid CMultiLanguage::ClearArrays()\r\n{\r\n\tm_csAuthor = \"\";\r\n\tm_csLangCode = \"\";\r\n\tm_lFileVersion = 0;\r\n\tm_bOnlyGetHeader = false;\r\n\r\n\tClearArray(m_RightClickMenu);\r\n\tClearArray(m_GroupsRightClickMenu);\r\n\tClearArray(m_ClipProperties);\r\n\tClearArray(m_OptionsGeneral);\r\n\tClearArray(m_OptionsSupportedTypes);\r\n\tClearArray(m_OptionsShortcuts);\r\n\tClearArray(m_OptionsQuickPaste);\r\n\tClearArray(m_OptionsQuickPasteKeyboard);\r\n\tClearArray(m_OptionsFriends);\r\n\tClearArray(m_OptionsFriendsDetail);\r\n\tClearArray(m_OptionsStats);\r\n\tClearArray(m_OptionsSupportedTypesAdd);\r\n\tClearArray(m_MoveToGroups);\r\n\tClearArray(m_TrayIconRightClickMenu);\r\n\tClearArray(m_OptionsSheet);\r\n\tClearArray(m_OptionsCopyBuffers);\r\n\tClearArray(m_GlobalHotKeys);\r\n\r\n\tClearMap(m_StringMap);\r\n}\r\n\r\nvoid CMultiLanguage::ClearArray(LANGUAGE_ARRAY &Array)\r\n{\r\n\tINT_PTR size = Array.GetSize();\r\n\tfor(int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = Array[i];\r\n\r\n\t\tdelete plItem;\r\n\t\tplItem = NULL;\r\n\t}\r\n\tArray.RemoveAll();\r\n}\r\n\r\nvoid CMultiLanguage::ClearMap(LANGUAGE_MAP &Map)\r\n{\r\n\tPOSITION pos = Map.GetStartPosition();\r\n\r\n\tCLangItem *plItem;\r\n\tCString csKey;\r\n\r\n\twhile(pos)\r\n\t{\r\n\t\tMap.GetNextAssoc(pos, csKey, plItem);\r\n\r\n\t\tif(plItem)\r\n\t\t{\r\n\t\t\tdelete plItem;\r\n\t\t\tplItem = NULL;\r\n\t\t}\r\n\t}\r\n\r\n\tMap.RemoveAll();\r\n}\r\n\r\nCString CMultiLanguage::GetString(CString csID, CString csDefault)\r\n{\r\n\tCLangItem *pItem;\r\n\t\r\n\tif(m_StringMap.Lookup(csID, pItem) == FALSE)\r\n\t{\r\n\t\treturn csDefault;\r\n\t}\r\n\r\n\tif(pItem->m_csForeignLang.GetLength() <= 0)\r\n\t\treturn csDefault;\r\n\r\n\treturn pItem->m_csForeignLang;\r\n}\r\n\r\nCString CMultiLanguage::GetGlobalHotKeyString(CString csID, CString csDefault)\r\n{\r\n\tINT_PTR size = m_GlobalHotKeys.GetSize();\r\n\tfor(int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = m_GlobalHotKeys[i];\r\n\t\tif(plItem->m_csID == csID)\r\n\t\t{\r\n\t\t\treturn plItem->m_csForeignLang;\r\n\t\t}\r\n\t}\r\n\r\n\treturn csDefault;\r\n}\r\n\r\nCString CMultiLanguage::GetDeleteClipDataString(CString csID, CString csDefault)\r\n{\r\n\tINT_PTR size = m_DeleteClipData.GetSize();\r\n\tfor(int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = m_DeleteClipData[i];\r\n\t\tif(plItem->m_csID == csID)\r\n\t\t{\r\n\t\t\treturn plItem->m_csForeignLang;\r\n\t\t}\r\n\t}\r\n\r\n\treturn csDefault;\r\n}\r\n\r\nCString CMultiLanguage::GetQuickPasteKeyboardString(int id, CString csDefault)\r\n{\r\n\tINT_PTR size = m_OptionsQuickPasteKeyboard.GetSize();\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = m_OptionsQuickPasteKeyboard[i];\r\n\t\tif (plItem->m_nID == id)\r\n\t\t{\r\n\t\t\treturn plItem->m_csForeignLang;\r\n\t\t}\r\n\t}\r\n\r\n\treturn csDefault;\r\n}\r\n\r\nbool CMultiLanguage::UpdateRightClickMenu(CMenu *pMenu)\r\n{\r\n\treturn UpdateMenuToLanguage(pMenu, m_RightClickMenu);\r\n}\r\n\r\nbool CMultiLanguage::UpdateGroupsRightClickMenu(CMenu *pMenu)\r\n{\r\n\treturn UpdateMenuToLanguage(pMenu, m_GroupsRightClickMenu);\r\n}\r\n\r\nbool CMultiLanguage::UpdateTrayIconRightClickMenu(CMenu *pMenu)\r\n{\r\n\treturn UpdateMenuToLanguage(pMenu, m_TrayIconRightClickMenu);\r\n}\r\n\r\nbool CMultiLanguage::UpdateClipProperties(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_ClipProperties);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionGeneral(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsGeneral);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionSupportedTypes(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsSupportedTypes);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionShortcuts(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsShortcuts);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionQuickPaste(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsQuickPaste);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionQuickPasteKeyboard(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsQuickPasteKeyboard);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionFriends(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsFriends);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionFriendsDetail(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsFriendsDetail);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionStats(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsStats);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionSupportedTypesAdd(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsSupportedTypesAdd);\r\n}\r\n\r\nbool CMultiLanguage::UpdateMoveToGroups(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_MoveToGroups);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionsSheet(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsSheet);\r\n}\r\n\r\nbool CMultiLanguage::UpdateOptionCopyBuffers(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_OptionsCopyBuffers);\r\n}\r\n\r\nbool CMultiLanguage::UpdateGlobalHotKeys(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_GlobalHotKeys);\r\n}\r\n\r\nbool CMultiLanguage::UpdateDeleteClipData(CWnd *pParent)\r\n{\r\n\treturn UpdateWindowToLanguage(pParent, m_DeleteClipData);\r\n}\r\n\r\nbool CMultiLanguage::UpdateMenuToLanguage(CMenu *pMenu, LANGUAGE_ARRAY &Array)\r\n{\r\n\tINT_PTR size = Array.GetSize();\r\n\tfor(int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = Array[i];\r\n\r\n\t\tif(plItem->m_csForeignLang.GetLength() > 0)\r\n\t\t{\r\n\t\t\tif(plItem->m_nID > 0)\r\n\t\t\t{\r\n\t\t\t\tpMenu->ModifyMenu(plItem->m_nID, MF_BYCOMMAND, plItem->m_nID, plItem->m_csForeignLang);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//If an item doesn't have a menu id then its a group menu\r\n\t\t\t\t//just search for the text and update the text with the foreign text\r\n\t\t\t\tint nMenuPos;\r\n\t\t\t\tCMenu *pNewMenu = GetMenuPos(pMenu, plItem->m_csEnglishLang, nMenuPos);\r\n\t\t\t\tif(pNewMenu)\r\n\t\t\t\t{\r\n\t\t\t\t\tpNewMenu->ModifyMenu(nMenuPos, MF_BYPOSITION, -1, plItem->m_csForeignLang);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CMultiLanguage::UpdateWindowToLanguage(CWnd *pParent, LANGUAGE_ARRAY &Array)\r\n{\r\n\tINT_PTR size = Array.GetSize();\r\n\tfor(int i = 0; i < size; i++)\r\n\t{\r\n\t\tCLangItem *plItem = Array[i];\r\n\r\n\t\tif(plItem->m_csForeignLang.GetLength() > 0)\r\n\t\t{\r\n\t\t\tif(plItem->m_nID > 0)\r\n\t\t\t{\r\n\t\t\t\tCWnd *pWnd = pParent->GetDlgItem(plItem->m_nID);\r\n\t\t\t\tif(pWnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tpWnd->SetWindowText(plItem->m_csForeignLang);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//If item id is -1 then set the title for the dialog\r\n\t\t\telse if(plItem->m_nID == -1)\r\n\t\t\t{\r\n\t\t\t\tpParent->SetWindowText(plItem->m_csForeignLang);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\nCMenu * CMultiLanguage::GetMenuPos(CMenu *pMenu, const CString &csLookingForMenuText, int &nMenuPos, bool returnChildIfOne)\r\n{\r\n\tCMenu *pSubMenu;\r\n\tCString csMenuText;\r\n\r\n\tint nCount = pMenu->GetMenuItemCount();\r\n\tfor(int i = 0; i < nCount; i++)\r\n\t{\r\n\t\tpMenu->GetMenuString(i, csMenuText, MF_BYPOSITION);\r\n\r\n\t\tif(csMenuText == csLookingForMenuText)\r\n\t\t{\r\n\t\t\tnMenuPos = i;\r\n\t\t\tif (returnChildIfOne)\r\n\t\t\t{\r\n\t\t\t\tpSubMenu = pMenu->GetSubMenu(i);\r\n\t\t\t\tif (pSubMenu != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn pSubMenu;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn pMenu;\r\n\t\t}\r\n\r\n\t\tpSubMenu = pMenu->GetSubMenu(i);\r\n\t\tif(pSubMenu)\r\n\t\t{\r\n\t\t\tCMenu *pMenuReturn = GetMenuPos(pSubMenu, csLookingForMenuText, nMenuPos, returnChildIfOne);\r\n\t\t\tif(pMenuReturn)\r\n\t\t\t\treturn pMenuReturn;\r\n\t\t}\r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n\r\nbool CMultiLanguage::LoadLanguageFile(CString csFile)\r\n{\r\n\tm_csLastError = \"\";\r\n\t\r\n\tCString csPath = CGetSetOptions::GetPath(PATH_LANGUAGE);\r\n\tcsPath += csFile;\r\n\tcsPath += \".xml\";\r\n\r\n\tClearArrays();\r\n\r\n\tif(csFile.GetLength() <= 0)\r\n\t{\r\n\t\tm_csLastError = \"Language file is blank\";\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTiXmlDocument doc;\r\n\tif(!doc.LoadFile(csPath.GetBuffer()))\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Error loading file %s - reason = %s, Line: %d, column: %d\"), csFile, CTextConvert::AnsiToUnicode(doc.ErrorDesc()), doc.ErrorRow(), doc.ErrorCol());\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTiXmlElement *ItemHeader = doc.FirstChildElement(\"Ditto_Language_File\");\r\n\tif(!ItemHeader)\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Error finding the section Ditto_Language_File\"));\r\n\t\tASSERT(!m_csLastError);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString csVersion = ItemHeader->Attribute(\"Version\");\r\n\tm_lFileVersion = ATOI(csVersion);\r\n\tm_csAuthor = ItemHeader->Attribute(\"Author\");\r\n\tm_csNotes = ItemHeader->Attribute(\"Notes\");\r\n\tm_csLangCode = ItemHeader->Attribute(\"LanguageCode\");\r\n\r\n\tif(m_bOnlyGetHeader)\r\n\t\treturn true;\r\n\r\n\tbool bRet = LoadSection(*ItemHeader, m_RightClickMenu, \"Ditto_Right_Click_Menu\");\r\n\tbRet = LoadSection(*ItemHeader, m_GroupsRightClickMenu, \"Ditto_Groups_Right_Click_Menu\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsGeneral, \"Ditto_Options_General\");\r\n\tbRet = LoadSection(*ItemHeader, m_ClipProperties, \"Ditto_Clip_Properties\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsSupportedTypes, \"Ditto_Options_Supported_Types\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsShortcuts, \"Ditto_Options_Shortcuts\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsQuickPaste, \"Ditto_Options_Quick_Paste\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsQuickPasteKeyboard, \"Ditto_Options_Quick_Paste_Keyboard\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsFriends, \"Ditto_Options_Friends\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsFriendsDetail, \"Ditto_Options_Friends_Detail\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsStats, \"Ditto_Options_Stats\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsSupportedTypesAdd, \"Ditto_Options_Supported_Types_Add\");\r\n\tbRet = LoadSection(*ItemHeader, m_MoveToGroups, \"Ditto_Move_To_Groups\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsSheet, \"Ditto_Options_Sheet\");\r\n\tbRet = LoadSection(*ItemHeader, m_TrayIconRightClickMenu, \"Ditto_Tray_Icon_Menu\");\r\n\tbRet = LoadSection(*ItemHeader, m_OptionsCopyBuffers, \"Ditto_Options_CopyBuffers\");\r\n\tbRet = LoadSection(*ItemHeader, m_GlobalHotKeys, \"Ditto_GlobalHotKeys\");\r\n\tbRet = LoadSection(*ItemHeader, m_DeleteClipData, \"Ditto_DeleteClipData\");\r\n\t\r\n\tbRet = LoadStringTableSection(*ItemHeader, m_StringMap, \"Ditto_String_Table\");\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CMultiLanguage::LoadSection(TiXmlNode &doc, LANGUAGE_ARRAY &Array, CString csSection)\r\n{\r\n\tCStringA csSectionA = CTextConvert::UnicodeToAnsi(csSection);\r\n\tTiXmlNode *node = doc.FirstChild(csSectionA);\r\n\tif(!node)\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Error finding the section %s\"), csSection);\r\n\t\t//ASSERT(!m_csLastError);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTiXmlNode* ForeignNode;\r\n\tCString csID;\r\n\tCString csLineFeed(\"\\n\");\r\n\t\t\r\n\tTiXmlElement *ItemElement = node->FirstChildElement();\r\n\r\n\t//load all items for this section\r\n\t//they look like\r\n\t//<Item English_Text = \"Use Ctrl - Num\" ID= \"32777\"></Item>\r\n\twhile(ItemElement)\r\n\t{\r\n \t\tForeignNode = ItemElement->FirstChild();\r\n \t\tif(ForeignNode)\r\n \t\t{\r\n\t\t\tCLangItem *plItem = new CLangItem;\r\n\t\t\tif(plItem)\r\n\t\t\t{\r\n\t\t\t\tplItem->m_csEnglishLang = ItemElement->Attribute(\"English_Text\");\r\n\t\t\t\tcsID = ItemElement->Attribute(\"ID\");\r\n\t\t\t\tplItem->m_nID = ATOI(csID);\r\n\t\t\t\tif(plItem->m_nID == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tplItem->m_csID = csID;\r\n\t\t\t\t}\r\n \t\t\t\t\r\n\t\t\t\tLPCSTR Value = ForeignNode->Value();\r\n\t\t\t\tplItem->m_csForeignLang = CTextConvert::Utf8ToUnicode(Value);\r\n\r\n\t\t\t\t//Replace the literal \"\\n\" with line feeds\r\n \t\t\t\tplItem->m_csForeignLang.Replace(_T(\"\\\\n\"), csLineFeed);\r\n\r\n\t\t\t\tArray.Add(plItem);\r\n\t\t\t}\r\n \t\t}\t\t\r\n\r\n\t\tItemElement = ItemElement->NextSiblingElement();\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n\r\nbool CMultiLanguage::LoadStringTableSection(TiXmlNode &doc, LANGUAGE_MAP &Map, CString csSection)\r\n{\r\n\tCStringA csSectionA = CTextConvert::UnicodeToAnsi(csSection);\r\n\tTiXmlNode *node = doc.FirstChild(csSectionA);\r\n\tif(!node)\r\n\t{\r\n\t\tCString cs;\r\n\t\tcs.Format(_T(\"Error finding the section %s\"), csSection);\r\n\t\tASSERT(!cs);\r\n\t\tLog(cs);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString csLineFeed(\"\\n\");\r\n\tTiXmlNode* ForeignNode;\r\n\t\t\r\n\tTiXmlElement *ItemElement = node->FirstChildElement();\r\n\r\n\t//load all items for this section\r\n\t//they look like\r\n\t//<Item English_Text = \"Use Ctrl - Num\" ID= \"32777\"></Item>\r\n\twhile(ItemElement)\r\n\t{\r\n\t\tCLangItem *plItem = new CLangItem;\r\n\r\n\t\tplItem->m_csEnglishLang = ItemElement->Attribute(\"English_Text\");\r\n\t\tplItem->m_csID = ItemElement->Attribute(\"ID\");\r\n\r\n\t\tForeignNode = ItemElement->FirstChild();\r\n\t\tif(ForeignNode) \r\n\t\t{\r\n\t\t\tLPCSTR Value = ForeignNode->Value();\r\n\t\t\tplItem->m_csForeignLang = CTextConvert::Utf8ToUnicode(Value);\r\n\r\n\t\t\t//Replace the literal \"\\n\" with line feeds\r\n\t\t\tplItem->m_csForeignLang.Replace(_T(\"\\\\n\"), csLineFeed);\r\n\t\t}\r\n\r\n\t\tMap.SetAt(plItem->m_csID, plItem);\r\n\r\n\t\tItemElement = ItemElement->NextSiblingElement();\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n"
        },
        {
          "name": "MultiLanguage.h",
          "type": "blob",
          "size": 3.67578125,
          "content": "// MultiLanguage.h: interface for the CMultiLanguage class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(AFX_MULTILANGUAGE_H__DA57BA64_C421_4368_9498_1EFCE49A5C52__INCLUDED_)\r\n#define AFX_MULTILANGUAGE_H__DA57BA64_C421_4368_9498_1EFCE49A5C52__INCLUDED_\r\n\r\n#include \"tinyxml\\Tinyxml.h\"\r\n#include \"tinyxml\\tinystr.h\"\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n\r\nclass CLangItem\r\n{\r\npublic:\r\n\tCLangItem()\r\n\t{\r\n\t\tm_nID = -1;\r\n\t\tm_csEnglishLang = \"\";\r\n\t\tm_csForeignLang = \"\";\r\n\t\tm_csID = \"\";\r\n\t}\r\n\tint m_nID;\r\n\tCString m_csID;\r\n\tCString m_csEnglishLang;\r\n\tCString m_csForeignLang;\r\n};\r\n\r\ntypedef CArray<CLangItem*, CLangItem*> LANGUAGE_ARRAY;\r\n\r\ntypedef CMap<CString, LPCTSTR, CLangItem*, CLangItem*> LANGUAGE_MAP;\r\n\r\nclass CMultiLanguage  \r\n{\r\npublic:\r\n\tCMultiLanguage();\r\n\tvirtual ~CMultiLanguage();\r\n\r\n\tbool LoadLanguageFile(CString csFile);\r\n\r\n\tbool UpdateRightClickMenu(CMenu *pMenu);\r\n\tbool UpdateGroupsRightClickMenu(CMenu *pMenu);\r\n\tbool UpdateTrayIconRightClickMenu(CMenu *pMenu);\r\n\r\n\tbool UpdateClipProperties(CWnd *pParent);\r\n\tbool UpdateOptionGeneral(CWnd *pParent);\r\n\tbool UpdateOptionSupportedTypes(CWnd *pParent);\r\n\tbool UpdateOptionShortcuts(CWnd *pParent);\r\n\tbool UpdateOptionQuickPaste(CWnd *pParent);\r\n\tbool UpdateOptionQuickPasteKeyboard(CWnd *pParent);\r\n\tbool UpdateOptionFriends(CWnd *pParent);\r\n\tbool UpdateOptionFriendsDetail(CWnd *pParent);\r\n\tbool UpdateOptionStats(CWnd *pParent);\r\n\tbool UpdateOptionSupportedTypesAdd(CWnd *pParent);\r\n\tbool UpdateMoveToGroups(CWnd *pParent);\r\n\tbool UpdateOptionsSheet(CWnd *pParent);\r\n\tbool UpdateOptionCopyBuffers(CWnd *pParent);\r\n\tbool UpdateGlobalHotKeys(CWnd *pParent);\r\n\tbool UpdateDeleteClipData(CWnd *pParent);\r\n\r\n\tCString GetGlobalHotKeyString(CString csID, CString csDefault);\r\n\tCString GetDeleteClipDataString(CString csID, CString csDefault);\r\n\tCString GetQuickPasteKeyboardString(int id, CString csDefault);\r\n\r\n\tCString GetString(CString csID, CString csDefault);\r\n\r\n\tCString GetAuthor()\t{ return m_csAuthor;\t\t}\r\n\tlong\tGetVersion(){ return m_lFileVersion;\t}\r\n\tCString GetNotes()\t{ return m_csNotes;\t\t\t}\r\n\tCString GetLangCode() { return m_csLangCode;\t}\r\n\r\n\tvoid\tSetOnlyGetHeader(bool bVal)\t{ m_bOnlyGetHeader = true;\t}\r\n\tstatic CMenu* GetMenuPos(CMenu *pMenu, const CString &csLookingForMenuText, int &nMenuPos, bool returnChildIfOne = FALSE);\r\n\r\n\tCString m_csLastError;\r\n\r\nprotected:\r\n\tLANGUAGE_ARRAY m_RightClickMenu;\r\n\tLANGUAGE_ARRAY m_GroupsRightClickMenu;\r\n\tLANGUAGE_ARRAY m_TrayIconRightClickMenu;\r\n\tLANGUAGE_ARRAY m_ClipProperties;\r\n\tLANGUAGE_ARRAY m_OptionsGeneral;\r\n\tLANGUAGE_ARRAY m_OptionsSupportedTypes;\r\n\tLANGUAGE_ARRAY m_OptionsShortcuts;\r\n\tLANGUAGE_ARRAY m_OptionsQuickPaste;\r\n\tLANGUAGE_ARRAY m_OptionsQuickPasteKeyboard;\r\n\tLANGUAGE_ARRAY m_OptionsFriends;\r\n\tLANGUAGE_ARRAY m_OptionsFriendsDetail;\r\n\tLANGUAGE_ARRAY m_OptionsStats;\r\n\tLANGUAGE_ARRAY m_OptionsSupportedTypesAdd;\r\n\tLANGUAGE_ARRAY m_MoveToGroups;\r\n\tLANGUAGE_ARRAY m_OptionsSheet;\r\n\tLANGUAGE_ARRAY m_OptionsCopyBuffers;\r\n\tLANGUAGE_ARRAY m_GlobalHotKeys;\r\n\tLANGUAGE_ARRAY m_DeleteClipData;\r\n\r\n\tLANGUAGE_MAP\tm_StringMap;\r\n\r\n\tCString m_csAuthor;\r\n\tCString m_csNotes;\r\n\tlong\tm_lFileVersion;\r\n\tCString m_csLangCode;\r\n\r\n\tbool\tm_bOnlyGetHeader;\r\n\r\nprotected:\r\n\tbool LoadSection(TiXmlNode &doc, LANGUAGE_ARRAY &Array, CString csSection);\r\n\tbool LoadStringTableSection(TiXmlNode &doc, LANGUAGE_MAP &Map, CString csSection);\r\n\r\n\tbool UpdateMenuToLanguage(CMenu *pMenu, LANGUAGE_ARRAY &Array);\r\n\tbool UpdateWindowToLanguage(CWnd *pParent, LANGUAGE_ARRAY &Array);\r\n\r\n\r\n\tvoid ClearArrays();\r\n\tvoid ClearArray(LANGUAGE_ARRAY &Array);\r\n\tvoid ClearMap(LANGUAGE_MAP &Map);\r\n};\r\n\r\n#endif // !defined(AFX_MULTILANGUAGE_H__DA57BA64_C421_4368_9498_1EFCE49A5C52__INCLUDED_)\r\n"
        },
        {
          "name": "MyDropTarget.cpp",
          "type": "blob",
          "size": 0.8359375,
          "content": "#include \"stdafx.h\"\n#include \"MyDropTarget.h\"\n#include \"QPasteWnd.h\"\n\n\nCMyDropTarget::CMyDropTarget(CWnd *pMainWnd)\n{\n\tm_pParent = pMainWnd;\n}\n\nCMyDropTarget::~CMyDropTarget()\n{\n\n}\n\nDROPEFFECT CMyDropTarget::OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\n{\n\treturn ((CQPasteWnd*) m_pParent)->OnDragEnter(pDataObject, dwKeyState, point);\n}\n\nDROPEFFECT CMyDropTarget::OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\n{\n\treturn ((CQPasteWnd*) m_pParent)->OnDragOver(pDataObject, dwKeyState, point);\n}\n\nBOOL CMyDropTarget::OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point)\n{\n\treturn ((CQPasteWnd*) m_pParent)->OnDrop(pDataObject, dropEffect, point);\n}\n\nvoid CMyDropTarget::OnDragLeave(CWnd* pWnd)\n{\n\treturn ((CQPasteWnd*) m_pParent)->OnDragLeave();\n}\n\n"
        },
        {
          "name": "MyDropTarget.h",
          "type": "blob",
          "size": 0.486328125,
          "content": "#pragma once\n#include \"afxole.h\"\n\nclass CMyDropTarget : public COleDropTarget\n{\npublic:\n\tDROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\n\tDROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\n\tBOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);\n\tvoid OnDragLeave(CWnd* pWnd);\n\n\tCMyDropTarget(CWnd *pMainWnd);\n\tvirtual ~CMyDropTarget();\n\nprivate:\n\tCWnd *m_pParent;\n};\n\n"
        },
        {
          "name": "NTray.cpp",
          "type": "blob",
          "size": 55.36328125,
          "content": "/*\nModule : NTray.cpp\nPurpose: implementation for a MFC class to encapsulate Shell_NotifyIcon\nCreated: PJN / 14-05-1997\nHistory: PJN / 25-11-1997 Addition of the following\n                          1. HideIcon(), ShowIcon() & MoveToExtremeRight() \n                          2. Support for animated tray icons\n         PJN / 23-06-1998 Class now supports the new Taskbar Creation Notification \n                          message which comes with IE 4. This allows the tray icon\n                          to be recreated whenever the explorer restarts (Crashes!!)\n         PJN / 22-07-1998 1. Code now compiles cleanly at warning level 4\n                          2. Code is now UNICODE enabled + build configurations are provided\n                          3. The documentation for the class has been updated\n         PJN / 27-01-1999 1. Code first tries to load a 16*16 icon before loading the 32*32\n                          version. This removes the blurryness which was previously occuring\n         PJN / 28-01-1999 1. Fixed a number of level 4 warnings which were occurring.\n         PJN / 09-05-1999 1. Fixed a problem as documented in KB article \"PRB: Menus for \n                          Notification Icons Do Not Work Correctly\", Article ID: Q135788 \n         PJN / 15-05-1999 1. Now uses the author's hookwnd class. This prevents the need to \n                          create the two hidden windows namely CTrayRessurectionWnd and\n                          CTrayTimerWnd\n                          2. Code now compiles cleanly at warning level 4\n                          3. General code tidy up and rearrangement\n                          4. Added numerous ASSERT's to improve the code's robustness\n                          5. Added functions to allow context menu to be customized\n         PJN / 01-01-2001 1. Now includes copyright message in the source code and documentation. \n                          2. Fixed problem where the window does not get focus after double clicking \n                          on the tray icon\n                          3. Now fully supports the Windows 2000 balloon style tooltips\n                          4. Fixed a off by one problem in some of the ASSERT's\n                          5. Fixed problems with Unicode build configurations\n                          6. Provided Win2k specific build configurations\n         PJN / 10-02-2001 1. Now fully supports creation of 2 tray icons at the same time\n         PJN / 13-06-2001 1. Now removes windows hook upon call to RemoveIcon\n         PJN / 26-08-2001 1. Fixed memory leak in RemoveIcon.\n                          2. Fixed GPF in RemoveIcon by removing call to Unhook\n         PJN / 28-08-2001 1. Added support for direct access to the System Tray's HDC. This allows\n                          you to generate an icon for the tray on the fly using GDI calls. The idea\n                          came from the article by Jeff Heaton in the April issue of WDJ. Also added\n                          are overriden Create methods to allow you to easily costruct a dynamic\n                          tray icon given a BITMAP instead of an ICON.\n         PJN / 21-03-2003 1. Fixed icon resource leaks in SetIcon(LPCTSTR lpIconName) and \n                          SetIcon(UINT nIDResource). Thanks to Egor Pervouninski for reporting this.\n                          2. Fixed unhooking of the tray icon when the notification window is being\n                          closed.\n         PJN / 31-03-2003 1. Now uses V1.05 of my Hookwnd class\n         PJN / 02-04-2003 1. Now uses v1.06 of my Hookwnd class\n                          2. Fixed a bug in the sample app for this class where the hooks should\n                          have been created as global instances rather than as member variables of\n                          the mainframe window. This ensures that the hooks remain valid even after\n                          calling DefWindowProc on the mainframe.\n         PJN / 23-07-2004 1. Minor update to remove unnecessary include of \"resource.h\"\n         PJN / 03-03-2006 1. Updated copyright details.\n                          2. Updated the documentation to use the same style as the web site.\n                          3. Did a spell check of the documentation.        \n                          4. Fixed some issues when the code is compiled using /Wp64. Please note that\n                          to support this the code now requires a recentish Platform SDK to be installed\n                          if the code is compiled with Visual C++ 6.\n                          5. Replaced all calls to ZeroMemory with memset.\n                          6. Fixed an issue where SetBalloonDetails was not setting the cbSize parameter.\n                          Thanks to Enrique Granda for reporting this issue.\n                          7. Added support for NIIF_USER and NIIF_NONE flags.\n                          8. Now includes support for NIM_NIMSETVERSION via SetVersion. In addition this\n                          is now automatically set in the Create() calls if the Win2k boolean parameter\n                          is set.\n                          9. Removed derivation from CObject as it was not really needed.\n                          10. Now includes support for NIM_SETFOCUS\n                          11. Added support for NIS_HIDDEN via the ShowIcon and HideIcon methods.\n                          12. Added support for NIIF_NOSOUND\n         PJN / 27-06-2006 1. Code now uses new C++ style casts rather than old style C casts where necessary.\n                          2. The class framework now requires the Platform SDK if compiled using VC 6.  \n                          3. Updated the logic of the ASSERTs which validate the various string lengths.\n                          4. Fixed a bug in CTrayNotifyIcon::SetFocus() where the cbSize value was not being\n                          set correctly.\n                          5. CTrayIconHooker class now uses ATL's CWindowImpl class in preference to the author's\n                          CHookWnd class. This does mean that for MFC only client projects, you will need to add\n                          ATL support to your project.\n                          6. Optimized CTrayIconHooker constructor code\n                          7. Updated code to compile cleanly using VC 2005. Thanks to \"Itamar\" for prompting this\n                          update.\n                          8. Addition of a CTRAYNOTIFYICON_EXT_CLASS and CTRAYNOTIFYICON_EXT_API macros which makes \n                          the class easier to use in an extension dll.\n                          9. Made CTrayNotifyIcon destructor virtual\n         PJN / 03-07-2005 1. Fixed a bug where the HideIcon functionality did not work on Windows 2000. This was \n                          related to how the cbSize member of the NOTIFYICONDATA structure was initialized. The code\n                          now dynamically determines the correct size to set at runtime according to the instructions\n                          provided by the MSDN documentation for this structure. As a result of this, all \"bWin2k\" \n                          parameters which were previously exposed via CTrayNotifyIcon have now been removed as there\n                          is no need for them. Thanks to Edwin Geng for reporting this important bug. Client code will\n                          still need to intelligently make decisions on what is supported by the OS. For example balloon\n                          tray icons are only supported on Shell v5 (nominally Windows 2000 or later). CTrayNotifyIcon\n                          will ASSERT if for example calls are made to it to create a balloon tray icon on operating \n                          systems < Windows 2000.\n         PJN / 04-07-2006 1. Fixed a bug where the menu may pop up a second time after a menu item is chosen on \n                          Windows 2000. The problem was tracked down to the code in CTrayNotifyIcon::OnTrayNotification. \n                          During testing of this bug, I was unable to get a workable solution using the new shell \n                          messages of WM_CONTEXTMENU, NIN_KEYSELECT & NIN_SELECT on Windows 2000 and Windows XP. \n                          This means that the code in CTrayNotifyIcon::OnTrayNotification uses the old way of handling \n                          notifications (WM_RBUTTDOWN*). This does mean that by default, client apps which use the \n                          CTrayNotifyIcon class will not support the new keyboard and mouse semantics for tray icons\n                          (IMHO this is no big loss!). Client code is of course free to handle their own notifications. \n                          If you go down this route then I would advise you to thoroughly test your application on \n                          Windows 2000 and Windows XP as my testing has shown that there is significant differences in \n                          how tray icons handle their messaging on these 2 operating systems. Thanks to Edwin Geng for \n                          reporting this issue.\n                          2. Class now displays the menu based on the current message's screen coordinates, rather than\n                          the current cursor screen coordinates.\n                          3. Fixed bug in sample app where if the about dialog is already up and it is reactivated \n                          from the tray menu, it did not bring itself into the foreground\n         PJN / 06-07-2006 1. Reverted the change made for v1.53 where the screen coordinates used to show the context \n                          menu use the current message's screen coordinates. Instead the pre v1.53 mechanism which \n                          uses the current cursor's screen coordinates is now used. Thanks to Itamar Syn-Hershko for \n                          reporting this issue.\n         PJN / 19-07-2006 1. The default menu item can now be customized via SetDefaultMenuItem and \n                          GetDefaultMenuItem. Thanks to Mikhail Bykanov for suggesting this nice update.\n                          2. Optimized CTrayNotifyIcon constructor code\n         PJN / 19-08-2005 1. Updated the code to operate independent of MFC if so desired. This requires WTL which is an\n                          open source library extension for ATL to provide UI support along the lines of MFC. Thanks to \n                          zhiguo zhao for providing this very nice addition.\n         PJN / 15-09-2006 1. Fixed a bug where WM_DESTROY messages were not been handled correctly for the top level window\n                          which the CTrayIconHooker class subclasses in order to handle the tray resurrection message,\n                          the animation timers and auto destroying of the icons when the top level window is destroyed. \n                          Thanks to Edward Livingston for reporting this bug.\n                          2. Fixed a bug where the tray icons were not being recreated correctly when we receive the \n                          \"TaskbarCreated\" when Explorer is restarted. Thanks to Nuno Esculcas for reporting this bug.\n                          3. Split the functionality of hiding versus deleting and showing versus creating of the tray\n                          icon into 4 separate functions, namely Delete(), Create(), Hide() and Show(). Note that Hide \n                          and Show functionality is only available on Shell v5 or later.\n                          4. Fixed an issue with recreation of tray icons which use a dynamic icon created from a bitmap\n                          (through the use of BitmapToIcon).\n                          5. CTrayNotifyIcon::LoadIconResource now loads up an icon as a shared icon resource using \n                          LoadImage. This should avoid resource leaks using this function.\n         PJN / 15-06-2007 1. Updated copyright messages.\n                          2. If the code detects that MFC is not included in the project, the code uses the standard\n                          preprocessor define \"_CSTRING_NS\" to declare the string class to use rather than explicitly \n                          using WTL::CString. Thanks to Krzysztof Suszka for reporting this issue.\n                          3. Updated sample app to compile cleanly on VC 2005.\n                          4. Addition of a \"BOOL bShow\" to all the Create methods. This allows you to create an icon \n                          without actually showing it. This avoids the flicker which previously occurred if you created \n                          the icon and then immediately hid the icon. Thanks to Krzysztof Suszka for providing this \n                          suggestion.\n                          5. Demo app now initially creates the first icon as hidden for demonstration purposes.\n                          6. Added support for NIIF_LARGE_ICON. This Vista only feature allows you to create a large \n                          balloon icon.\n                          7. Added support for NIF_REALTIME. This Vista only flag allows you to specify not to bother \n                          showing the balloon if it is delayed due to the presence of an existing balloon.\n                          8. Added support for NOTIFYICONDATA::hBalloonIcon. This Vista only feature allows you to \n                          create a user specified balloon icon which is different to the actual tray icon.\n                          9. LoadIconResource method now includes support for loading large icons and has been renamed\n                          to simply LoadIcon. Also two overridden versions of this method have been provided which allow\n                          the hInstance resource ID to be specified to load the icon from.\n                          10. Reworked the internal code to CTrayNotifyIcon which detects the shell version.\n                          11. Updated the tray icon text in the demo app to better demonstrate the features of the class.\n                          12. Updated the WTL sample to be consistent with the MFC sample code\n                          13. Updated comments in documentation about usage of the Platform SDK.\n         PJN / 13-10-2007 1. Subclassing of the top level window is now not down internally by the CTrayNotifyIcon class\n                          using the CTrayIconHooker class. Instead now a hidden top level window is created for each tray \n                          icon you create and these look after handling the tray resurrection and animated icon timer\n                          messages. This refactoring of the internals of the class now also fixes a bug where an application\n                          which creates multiples tray icons would only get one icon recreated when the tray resurrection\n                          message was received. Thanks to Steven Dwyer for prompting this update. \n                          2. Updated the MFC sample app to correctly initialize ATL for VC 6\n         PJN / 12-03-2008 1. Updated copyright details\n                          2. Fixed a bug in SetBalloonDetails where the code did not set the flag NIF_ICON if a user defined\n                          icon was being set. Thanks to \"arni\" for reporting this bug. \n                          3. Updated the sample app to clean compile on VC 2008\n         PJN / 22-06-2008 1. Code now compiles cleanly using Code Analysis (/analyze)\n                          2. Updated code to compile correctly using _ATL_CSTRING_EXPLICIT_CONSTRUCTORS define\n                          3. Removed VC 6 style AppWizard comments from the code.\n                          4. The code now only supports VC 2005 or later. \n         PJN / 10-04-2010 1. Updated copyright details.\n                          2. Updated the project settings to more modern default values.\n                          3. Updated the WTL version of LoadIcon to use the more modern ModuleHelper class from WTL to get \n                          the resource instance. Thanks to \"Yarp\" for reporting this issue.\n                          4. The class now has support for the Windows 7 \"NIIF_RESPECT_QUIET_TIME\" flag. This value can be\n                          set via the new \"bQuietTime\" parameter to the Create method.\n                          5. Updated the code which does version detection of the Shell version\n         PJN / 10-07-2010 1. Updated the sample app to compile cleanly on VS 2010.\n                          2. Fixed a bug in CTrayNotifyIcon::Delete where the code would ASSERT if the tray notify icon was\n                          never actually created. Thanks to \"trophim\" for reporting this bug.\n         PJN / 06-11-2010 1. Minor update to code in SetTooltipText to code which handles unreferenced variable compiler \n                          warning\n                          2. Implemented a GetTooltipMaxSize method which reports the maximum size which the tooltip can be\n                          for a tray icon. Thanks to Geert van Horrik for this nice addition\n                          3. All places which copy text to the underlying NOTIFYICONDATA now use the _TRUNCATE parameter in \n                          their call to the Safe CRT runtime. This change in behaviour means that client apps will no longer\n                          crash if they supply data larger than this Windows structure can accommadate. Thanks to Geert van \n                          Horrik for prompting this update.\n                          4. All calls to sizeof(struct)/sizeof(first element) have been replaced with _countof\n                          5. Fixed a linker error when compiling the WTL sample app in release mode.\n         PJN / 26-11-2010 1. Minor update to use DBG_UNREFERENCED_LOCAL_VARIABLE macro. Thanks to Jukka Ojanen for prompting this \n                          update.\n         PJN / 27-04-2016 1. Updated copyright details.\n                          2. Updated the code to clean compile on VC 2012 - VC 2015.\n                          3. Removed support for CTRAYNOTIFYICON_NOWIN2K preprocessor macro\n                          4. Removed various redefines of ShellApi.h constants from the code\n                          5. Added SAL annotations to all the code.\n                          6. Reworked the definition of the string class to now use a typedef internal to the CTrayNotifyIcon \n                          class.\n                          7. Updated CTrayNotifyIcon::OnTrayNotification to handle NOTIFYICON_VERSION_4 style notifications.\n                          8. Reworked the internal storage of the animation icons to use ATL::CHeapPtr\n\nCopyright (c) 1997 - 2016 by PJ Naughter (Web: www.naughter.com, Email: pjna@naughter.com)\n\nAll rights reserved.\n\nCopyright / Usage Details:\n\nYou are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) \nwhen your product is released in binary form. You are allowed to modify the source code in any way you want \nexcept you cannot modify the copyright details at the top of each module. If you want to distribute source \ncode with your application, then you are only allowed to distribute versions released by the author. This is \nto maintain a single distribution point for the source code. \n\n*/\n\n\n/////////////////////////////////  Includes  //////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"NTray.h\"\n#ifndef _INC_SHELLAPI\n#pragma message(\"To avoid this message, please put ShellApi.h in your pre compiled header (normally stdafx.h)\")\n#include <ShellApi.h>\n#endif //#ifndef _INC_SHELLAPI\n\n\n/////////////////////////////////  Macros /////////////////////////////////////\n\n#ifdef _AFX\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif //#ifdef _DEBUG\n#endif //#ifdef _AFX\n\n#ifndef NIF_REALTIME\n#define NIF_REALTIME 0x00000040\n#endif //#ifndef NIF_REALTIME\n\n#ifndef NIIF_LARGE_ICON\n#define NIIF_LARGE_ICON 0x00000020\n#endif //#ifndef NIIF_LARGE_ICON\n\n#ifndef NIIF_RESPECT_QUIET_TIME\n#define NIIF_RESPECT_QUIET_TIME 0x00000080\n#endif //#ifndef NIIF_RESPECT_QUIET_TIME\n\n\n///////////////////////////////// Implementation //////////////////////////////\n\nconst UINT wm_TaskbarCreated = RegisterWindowMessage(_T(\"TaskbarCreated\"));\n\nCTrayNotifyIcon::CTrayNotifyIcon() : m_bCreated(FALSE),\n                                     m_bHidden(FALSE),\n                                     m_pNotificationWnd(NULL),\n                                     m_bDefaultMenuItemByPos(TRUE),\n                                     m_nDefaultMenuItem(0),\n                                     m_hDynamicIcon(NULL),\n                                     m_ShellVersion(Version4), //Assume version 4 of the shell\n                                     m_nNumIcons(0),\n                                     m_nTimerID(0),\n                                     m_nCurrentIconIndex(0),\n                                     m_nTooltipMaxSize(-1)\n{\n  typedef HRESULT (CALLBACK DLLGETVERSION)(DLLVERSIONINFO*);\n  typedef DLLGETVERSION* LPDLLGETVERSION;\n\n  //Try to get the details with DllGetVersion\n  HMODULE hShell32 = GetModuleHandle(_T(\"SHELL32.DLL\"));\n  if (hShell32 != NULL)\n  {\n    LPDLLGETVERSION lpfnDllGetVersion = reinterpret_cast<LPDLLGETVERSION>(GetProcAddress(hShell32, \"DllGetVersion\"));\n    if (lpfnDllGetVersion != NULL)\n    {\n      DLLVERSIONINFO vinfo;\n      vinfo.cbSize = sizeof(DLLVERSIONINFO);\n      if (SUCCEEDED(lpfnDllGetVersion(&vinfo)))\n      {\n        if ((vinfo.dwMajorVersion > 6) || (vinfo.dwMajorVersion == 6 && vinfo.dwMinorVersion > 0))\n          m_ShellVersion = Version7;\n        else if (vinfo.dwMajorVersion == 6)\n        {\n          if (vinfo.dwBuildNumber >= 6000)\n            m_ShellVersion = VersionVista;\n          else\n            m_ShellVersion = Version6;\n        }\n        else if (vinfo.dwMajorVersion >= 5)\n          m_ShellVersion = Version5;\n      }\n    }\n  }\n\n  memset(&m_NotifyIconData, 0, sizeof(m_NotifyIconData));\n  m_NotifyIconData.cbSize = GetNOTIFYICONDATASizeForOS();\n}\n\nCTrayNotifyIcon::~CTrayNotifyIcon()\n{\n  //Delete the tray icon\n  Delete(TRUE);\n  \n  //Free up any dynamic icon we may have\n  if (m_hDynamicIcon != NULL)\n  {\n    DestroyIcon(m_hDynamicIcon);\n    m_hDynamicIcon = NULL;\n  }\n}\n\nBOOL CTrayNotifyIcon::Delete(_In_ BOOL bCloseHelperWindow)\n{\n  //What will be the return value from this function (assume the best)\n  BOOL bSuccess = TRUE;\n\n  if (m_bCreated)\n  {\n    m_NotifyIconData.uFlags = 0;\n    bSuccess = Shell_NotifyIcon(NIM_DELETE, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n    m_bCreated = FALSE;\n  }\n  \n  //Close the helper window if requested to do so\n  if (bCloseHelperWindow && IsWindow())\n    SendMessage(WM_CLOSE);\n  \n  return bSuccess;\n}\n\nBOOL CTrayNotifyIcon::Create(_In_ BOOL bShow)\n{\n  m_NotifyIconData.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;\n  \n  if (!bShow)\n  {\n    ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n    m_NotifyIconData.uFlags |= NIF_STATE;\n    m_NotifyIconData.dwState = NIS_HIDDEN;\n    m_NotifyIconData.dwStateMask = NIS_HIDDEN;\n  }\n  \n  BOOL bSuccess = Shell_NotifyIcon(NIM_ADD, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n  if (bSuccess)\n  {\n    m_bCreated = TRUE;\n    \n    if (!bShow)\n      m_bHidden = TRUE;\n  }\n  return bSuccess;\n}\n\nBOOL CTrayNotifyIcon::Hide()\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n//  ATLASSERT(!m_bHidden); //Only makes sense to hide the icon if it is not already hidden\n\n  m_NotifyIconData.uFlags = NIF_STATE;\n  m_NotifyIconData.dwState = NIS_HIDDEN;\n  m_NotifyIconData.dwStateMask = NIS_HIDDEN; \n  BOOL bSuccess = Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n  if (bSuccess)\n    m_bHidden = TRUE;\n  return bSuccess;\n}\n\nBOOL CTrayNotifyIcon::Show()\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n//  ATLASSERT(m_bHidden); //Only makes sense to show the icon if it has been previously hidden\n  ATLASSERT(m_bCreated);\n\n  m_NotifyIconData.uFlags = NIF_STATE;\n  m_NotifyIconData.dwState = 0;\n  m_NotifyIconData.dwStateMask = NIS_HIDDEN;\n  BOOL bSuccess = Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n  if (bSuccess)\n    m_bHidden = FALSE;\n  return bSuccess;\n}\n\nvoid CTrayNotifyIcon::SetMenu(_In_ HMENU hMenu, UINT menuId)\n{\n  m_Menu.DestroyMenu();\n\n  if (menuId != 0)\n  {\n\t  if (!m_Menu.LoadMenu(menuId))\n\t  {\n\t\t  ATLASSERT(FALSE);\n\t\t  return;\n\t  }\n  }\n  else\n  {\n\t  m_Menu.Attach(hMenu);\n  }\n\n#ifdef _AFX\n  CMenu* pSubMenu = m_Menu.GetSubMenu(0);\n  ATLASSUME(pSubMenu != NULL); //Your menu resource has been designed incorrectly\n    \n  //Make the specified menu item the default (bold font)\n  pSubMenu->SetDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#else\n  CMenuHandle subMenu = m_Menu.GetSubMenu(0);\n  ATLASSERT(subMenu.IsMenu()); //Your menu resource has been designed incorrectly\n\n  //Make the specified menu item the default (bold font)\n  subMenu.SetMenuDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#endif //#ifdef _AFX\n}\n\nCMenu& CTrayNotifyIcon::GetMenu()\n{\n  return m_Menu;\n}\n\nvoid CTrayNotifyIcon::SetDefaultMenuItem(_In_ UINT uItem, _In_ BOOL fByPos)\n{ \n  m_nDefaultMenuItem = uItem; \n  m_bDefaultMenuItemByPos = fByPos; \n\n  //Also update in the live menu if it is present\n  if (m_Menu.operator HMENU())\n  {\n  #ifdef _AFX\n    CMenu* pSubMenu = m_Menu.GetSubMenu(0);\n    ATLASSUME(pSubMenu != NULL); //Your menu resource has been designed incorrectly\n\n    pSubMenu->SetDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n  #else\n    CMenuHandle subMenu = m_Menu.GetSubMenu(0);\n    ATLASSERT(subMenu.IsMenu()); //Your menu resource has been designed incorrectly\n    \n    subMenu.SetMenuDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n  #endif //#ifdef _AFX\n  }\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Validate our parameters\n  ATLASSUME((pNotifyWnd != NULL) && ::IsWindow(pNotifyWnd->operator HWND()));\n#ifdef _DEBUG\n  if (m_ShellVersion >= Version5) //If on Shell v5 or higher, then use the larger size tooltip\n  {\n    NOTIFYICONDATA_2 dummy;\n    ATLASSERT(_tcslen(pszTooltipText) < _countof(dummy.szTip));\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  }\n  else\n  {\n    NOTIFYICONDATA_1 dummy;\n    ATLASSERT(_tcslen(pszTooltipText) < _countof(dummy.szTip));\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  }\n#endif //#ifdef _DEBUG\n  ATLASSERT(hIcon != NULL); \n  ATLASSERT(nNotifyMessage >= WM_USER); //Make sure we avoid conflict with other messages\n\n  //Load up the menu resource which is to be used as the context menu\n  if (!m_Menu.LoadMenu(uMenuID == 0 ? uID : uMenuID))\n  {\n    ATLASSERT(FALSE);\n    return FALSE;\n  }\n#ifdef _AFX\n  CMenu* pSubMenu = m_Menu.GetSubMenu(0);\n  if (pSubMenu == NULL) \n  {\n    ATLASSERT(FALSE); //Your menu resource has been designed incorrectly\n    return FALSE;\n  }\n  //Make the specified menu item the default (bold font)\n  pSubMenu->SetDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#else\n  CMenuHandle subMenu = m_Menu.GetSubMenu(0);\n  if (!subMenu.IsMenu())\n  {\n    ATLASSERT(FALSE); //Your menu resource has been designed incorrectly\n    return FALSE;\n  }\n  subMenu.SetMenuDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#endif //#ifdef _AFX\n\n  //Create the helper window\n  if (!CreateHelperWindow())\n    return FALSE;\n\n  //Call the Shell_NotifyIcon function\n  m_pNotificationWnd = pNotifyWnd;\n  m_NotifyIconData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\n  m_NotifyIconData.hWnd = pNotifyWnd->operator HWND();\n  m_NotifyIconData.uID = uID;\n  m_NotifyIconData.uCallbackMessage = nNotifyMessage;\n  m_NotifyIconData.hIcon = hIcon;\n  _tcsncpy_s(m_NotifyIconData.szTip, _countof(m_NotifyIconData.szTip), pszTooltipText, _TRUNCATE);\n\n  if (!bShow)\n  {\n    ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n    m_NotifyIconData.uFlags |= NIF_STATE;\n    m_NotifyIconData.dwState = NIS_HIDDEN;\n    m_NotifyIconData.dwStateMask = NIS_HIDDEN;\n  }\n  m_bCreated = Shell_NotifyIcon(NIM_ADD, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n  if (m_bCreated)\n  {\n    if (!bShow)\n      m_bHidden = TRUE;\n    \n    //Turn on Shell v5 style behaviour if supported\n    if (m_ShellVersion >= Version5)\n      SetVersion(NOTIFYICON_VERSION);\n  }\n  \n  return m_bCreated;\n}\n\nBOOL CTrayNotifyIcon::SetVersion(_In_ UINT uVersion)\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n\n  //Call the Shell_NotifyIcon function\n  m_NotifyIconData.uVersion = uVersion;\n  return Shell_NotifyIcon(NIM_SETVERSION, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nHICON CTrayNotifyIcon::BitmapToIcon(_In_ CBitmap* pBitmap)\n{\n  //Validate our parameters\n  ATLASSUME(pBitmap != NULL);\n\n  //Get the width and height of a small icon\n  int w = GetSystemMetrics(SM_CXSMICON);\n  int h = GetSystemMetrics(SM_CYSMICON);\n\n  //Create a 0 mask\n  int nMaskSize = h*(w/8);\n  ATL::CHeapPtr<BYTE> pMask;\n  if (!pMask.Allocate(nMaskSize))\n    return NULL;\n  memset(pMask.m_pData, 0, nMaskSize);\n\n  //Create a mask bitmap\n  CBitmap maskBitmap;\n#ifdef _AFX\n  BOOL bSuccess = maskBitmap.CreateBitmap(w, h, 1, 1, pMask.m_pData);\n#else\n  maskBitmap.CreateBitmap(w, h, 1, 1, pMask.m_pData);\n  BOOL bSuccess = !maskBitmap.IsNull();\n#endif //#ifdef _AFX\n\n  //Handle the error\n  if (!bSuccess)\n    return NULL;\n\n  //Create an ICON base on the bitmap just created\n  ICONINFO iconInfo;\n  iconInfo.fIcon = TRUE;\n  iconInfo.xHotspot = 0;\n  iconInfo.yHotspot = 0;\n  iconInfo.hbmMask = maskBitmap;\n  iconInfo.hbmColor = *pBitmap; \n  return CreateIconIndirect(&iconInfo); \n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Convert the bitmap to an Icon\n  if (m_hDynamicIcon != NULL)\n    DestroyIcon(m_hDynamicIcon);\n  m_hDynamicIcon = BitmapToIcon(pBitmap);\n\n  //Pass the buck to the other function to do the work\n  return Create(pNotifyWnd, uID, pszTooltipText, m_hDynamicIcon, nNotifyMessage, uMenuID, bShow);\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Validate our parameters\n  ATLASSUME(phIcons != NULL);\n  ATLASSERT(nNumIcons >= 2); //must be using at least 2 icons if you are using animation\n  ATLASSERT(dwDelay);\n\n  //let the normal Create function do its stuff\n  BOOL bSuccess = Create(pNotifyWnd, uID, pszTooltipText, phIcons[0], nNotifyMessage, uMenuID, bShow);\n  if (bSuccess)\n  {\n    //Start the animation\n    bSuccess = StartAnimation(phIcons, nNumIcons, dwDelay);\n  }\n\n  return bSuccess;\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Validate our parameters\n  ATLASSUME((pNotifyWnd != NULL) && ::IsWindow(pNotifyWnd->operator HWND()));\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n#ifdef _DEBUG\n  NOTIFYICONDATA_2 dummy;\n  ATLASSERT(_tcslen(pszTooltipText) < _countof(dummy.szTip));\n  ATLASSERT(_tcslen(pszBalloonText) < _countof(dummy.szInfo));\n  ATLASSERT(_tcslen(pszBalloonCaption) < _countof(dummy.szInfoTitle));\n  ATLASSERT(hIcon); \n  ATLASSERT(nNotifyMessage >= WM_USER); //Make sure we avoid conflict with other messages\n  DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n#endif //#ifdef _DEBUG\n\n  //Load up the menu resource which is to be used as the context menu\n  if (!m_Menu.LoadMenu(uMenuID == 0 ? uID : uMenuID))\n  {\n    ATLASSERT(FALSE);\n    return FALSE;\n  }\n#ifdef _AFX\n  CMenu* pSubMenu = m_Menu.GetSubMenu(0);\n  if (pSubMenu == NULL) \n  {\n    ATLASSERT(FALSE); //Your menu resource has been designed incorrectly\n    return FALSE;\n  }\n  //Make the specified menu item the default (bold font)\n  pSubMenu->SetDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#else\n  CMenuHandle subMenu = m_Menu.GetSubMenu(0);\n  if (!subMenu.IsMenu()) \n  {\n    ATLASSERT(FALSE); //Your menu resource has been designed incorrectly\n    return FALSE;\n  }\n  //Make the specified menu item the default (bold font)\n  subMenu.SetMenuDefaultItem(m_nDefaultMenuItem, m_bDefaultMenuItemByPos);\n#endif //#ifdef _AFX\n\n  //Create the helper window\n  if (!CreateHelperWindow())\n    return FALSE;\n\n  //Call the Shell_NotifyIcon function\n  m_pNotificationWnd = pNotifyWnd;\n  m_NotifyIconData.hWnd = pNotifyWnd->operator HWND();\n  m_NotifyIconData.uID = uID;\n  m_NotifyIconData.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP | NIF_INFO;\n  m_NotifyIconData.uCallbackMessage = nNotifyMessage;\n  m_NotifyIconData.hIcon = hIcon;\n  _tcsncpy_s(m_NotifyIconData.szTip, _countof(m_NotifyIconData.szTip), pszTooltipText, _TRUNCATE);\n  _tcsncpy_s(m_NotifyIconData.szInfo, _countof(m_NotifyIconData.szInfo), pszBalloonText, _TRUNCATE);\n  _tcsncpy_s(m_NotifyIconData.szInfoTitle, _countof(m_NotifyIconData.szInfoTitle), pszBalloonCaption, _TRUNCATE);\n  m_NotifyIconData.uTimeout = nTimeout;\n  switch (style)\n  {\n    case Warning:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_WARNING;\n      break;\n    }\n    case Error:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_ERROR;\n      break;\n    }\n    case Info:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_INFO;\n      break;\n    }\n    case None:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_NONE;\n      break;\n    }\n    case User:\n    {\n      if (hBalloonIcon != NULL)\n      {\n        ATLASSERT(m_ShellVersion >= VersionVista);\n        m_NotifyIconData.hBalloonIcon = hBalloonIcon;\n      }\n      else\n      {\n        ATLASSERT(hIcon != NULL); //You forget to provide a user icon\n      }\n      m_NotifyIconData.dwInfoFlags = NIIF_USER;\n      break;\n    }\n    default:\n    {\n      ATLASSERT(FALSE);\n      break;\n    }\n  }\n  if (bNoSound)\n    m_NotifyIconData.dwInfoFlags |= NIIF_NOSOUND;\n  if (bLargeIcon)\n  {\n    ATLASSERT(m_ShellVersion >= VersionVista); //Only supported on Vista Shell\n    m_NotifyIconData.dwInfoFlags |= NIIF_LARGE_ICON;\n  }\n  if (bRealtime)\n  {\n    ATLASSERT(m_ShellVersion >= VersionVista); //Only supported on Vista Shell\n    m_NotifyIconData.uFlags |= NIF_REALTIME;\n  }\n  if (!bShow)\n  {\n    ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n    m_NotifyIconData.uFlags |= NIF_STATE;\n    m_NotifyIconData.dwState = NIS_HIDDEN;\n    m_NotifyIconData.dwStateMask = NIS_HIDDEN;\n  }\n  if (bQuietTime)\n  {\n    ATLASSERT(m_ShellVersion >= Version7); //Only supported on Windows 7 Shell\n    m_NotifyIconData.dwInfoFlags |= NIIF_RESPECT_QUIET_TIME;\n  }\n  \n  m_bCreated = Shell_NotifyIcon(NIM_ADD, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n  if (m_bCreated)\n  {\n    if (!bShow)\n      m_bHidden = TRUE;\n  \n    //Turn on Shell v5 tray icon behaviour\n    SetVersion(NOTIFYICON_VERSION);\n  }\n\n  return m_bCreated;\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Convert the bitmap to an ICON\n  if (m_hDynamicIcon != NULL)\n    DestroyIcon(m_hDynamicIcon);\n  m_hDynamicIcon = BitmapToIcon(pBitmap);\n\n  //Pass the buck to the other function to do the work\n  return Create(pNotifyWnd, uID, pszTooltipText, pszBalloonText, pszBalloonCaption, nTimeout, style, m_hDynamicIcon, nNotifyMessage, uMenuID, bNoSound, bLargeIcon, bRealtime, hBalloonIcon, bQuietTime, bShow);\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#else\nBOOL CTrayNotifyIcon::Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_opt_ HICON hBalloonIcon, _In_ BOOL bQuietTime, _In_ BOOL bShow)\n#endif //#ifdef _AFX\n{\n  //Validate our parameters\n  ATLASSUME(phIcons != NULL);\n  ATLASSERT(nNumIcons >= 2); //must be using at least 2 icons if you are using animation\n  ATLASSERT(dwDelay);\n\n  //let the normal Create function do its stuff\n  BOOL bSuccess = Create(pNotifyWnd, uID, pszTooltipText, pszBalloonText, pszBalloonCaption, nTimeout, style, phIcons[0], nNotifyMessage, uMenuID, bNoSound, bLargeIcon, bRealtime, hBalloonIcon, bQuietTime, bShow);\n  if (bSuccess)\n  {\n    //Start the animation\n    bSuccess = StartAnimation(phIcons, nNumIcons, dwDelay);\n  }\n\n  return bSuccess;\n}\n\nBOOL CTrayNotifyIcon::SetBalloonDetails(_In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ BalloonStyle style, _In_ UINT nTimeout, _In_ HICON hUserIcon, _In_ BOOL bNoSound, _In_ BOOL bLargeIcon, _In_ BOOL bRealtime, _In_ HICON hBalloonIcon)\n{\n  if (!m_bCreated)\n    return FALSE;\n\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n#ifdef _DEBUG\n  NOTIFYICONDATA_2 dummy;\n  ATLASSERT(_tcslen(pszBalloonText) < _countof(dummy.szInfo));\n  ATLASSERT(_tcslen(pszBalloonCaption) < _countof(dummy.szInfoTitle));\n  DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n#endif //#ifdef _DEBUG\n\n  //Call the Shell_NotifyIcon function\n  m_NotifyIconData.uFlags = NIF_INFO;\n  _tcsncpy_s(m_NotifyIconData.szInfo, _countof(m_NotifyIconData.szInfo), pszBalloonText, _TRUNCATE);\n  _tcsncpy_s(m_NotifyIconData.szInfoTitle, _countof(m_NotifyIconData.szInfoTitle), pszBalloonCaption, _TRUNCATE);\n  m_NotifyIconData.uTimeout = nTimeout;\n  switch (style)\n  {\n    case Warning:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_WARNING;\n      break;\n    }\n    case Error:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_ERROR;\n      break;\n    }\n    case Info:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_INFO;\n      break;\n    }\n    case None:\n    {\n      m_NotifyIconData.dwInfoFlags = NIIF_NONE;\n      break;\n    }\n    case User:\n    {\n      if (hBalloonIcon != NULL)\n      {\n        ATLASSERT(m_ShellVersion >= VersionVista);\n        m_NotifyIconData.hBalloonIcon = hBalloonIcon;\n      }\n      else\n      {\n        ATLASSERT(hUserIcon != NULL); //You forget to provide a user icon\n        m_NotifyIconData.uFlags |= NIF_ICON;\n        m_NotifyIconData.hIcon = hUserIcon;\n      }\n        \n      m_NotifyIconData.dwInfoFlags = NIIF_USER;\n      break;\n    }\n    default:\n    {\n      ATLASSERT(FALSE);\n      break;\n    }\n  }\n  if (bNoSound)\n    m_NotifyIconData.dwInfoFlags |= NIIF_NOSOUND;\n  if (bLargeIcon)\n    m_NotifyIconData.dwInfoFlags |= NIIF_LARGE_ICON;\n  if (bRealtime)\n    m_NotifyIconData.uFlags |= NIF_REALTIME;\n\n  return Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nCTrayNotifyIcon::String CTrayNotifyIcon::GetBalloonText() const\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n\n  String sText;\n  if (m_bCreated)\n    sText = m_NotifyIconData.szInfo;\n\n  return sText;\n}\n\nCTrayNotifyIcon::String CTrayNotifyIcon::GetBalloonCaption() const\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n\n  String sText;\n  if (m_bCreated)\n    sText = m_NotifyIconData.szInfoTitle;\n\n  return sText;\n}\n\nUINT CTrayNotifyIcon::GetBalloonTimeout() const\n{\n  //Validate our parameters\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or later\n\n  UINT nTimeout = 0;\n  if (m_bCreated)\n    nTimeout = m_NotifyIconData.uTimeout;\n\n  return nTimeout;\n}\n\nBOOL CTrayNotifyIcon::SetTooltipText(_In_ LPCTSTR pszTooltipText)\n{\n  if (!m_bCreated)\n    return FALSE;\n\n  if (m_ShellVersion >= Version5) //Allow the larger size tooltip text if on Shell v5 or later\n  {\n  #ifdef _DEBUG\n    NOTIFYICONDATA_2 dummy;\n    ATLASSERT(_tcslen(pszTooltipText) < _countof(dummy.szTip));\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  #endif //#ifdef _DEBUG\n  }\n  else \n  {\n  #ifdef _DEBUG\n    NOTIFYICONDATA_1 dummy;\n    ATLASSERT(_tcslen(pszTooltipText) < _countof(dummy.szTip));\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  #endif //#ifdef _DEBUG\n  }\n\n  //Call the Shell_NotifyIcon function\n  m_NotifyIconData.uFlags = NIF_TIP;\n  _tcsncpy_s(m_NotifyIconData.szTip, _countof(m_NotifyIconData.szTip), pszTooltipText, _TRUNCATE);\n  return Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nBOOL CTrayNotifyIcon::SetTooltipText(_In_ UINT nID)\n{\n  String sToolTipText;\n  if (!sToolTipText.LoadString(nID))\n    return FALSE;\n\n  //Let the other version of the function handle the rest\n  return SetTooltipText(sToolTipText);\n}\n\nint\tCTrayNotifyIcon::GetTooltipMaxSize()\n{\n  //Return the cached value if we have one\n  if (m_nTooltipMaxSize != -1) \n    return m_nTooltipMaxSize;\n\n  //Otherwise calculate the maximum based on the shell version\n  if (m_ShellVersion >= Version5)\n  {\n    NOTIFYICONDATA_2 dummy;\n    m_nTooltipMaxSize = _countof(dummy.szTip) - 1; //The -1 is to allow size for the NULL terminator\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  }\n  else\n  {\n    NOTIFYICONDATA_1 dummy;\n    m_nTooltipMaxSize = _countof(dummy.szTip) - 1; //The -1 is to allow size for the NULL terminator\n    DBG_UNREFERENCED_LOCAL_VARIABLE(dummy);\n  }\n\n  return m_nTooltipMaxSize;\n}\n\nBOOL CTrayNotifyIcon::SetIcon(_In_ CBitmap* pBitmap)\n{\n  //Convert the bitmap to an ICON\n  if (m_hDynamicIcon != NULL)\n    DestroyIcon(m_hDynamicIcon);\n  m_hDynamicIcon = BitmapToIcon(pBitmap);\n\n  //Pass the buck to the other function to do the work\n  return SetIcon(m_hDynamicIcon);\n}\n\nBOOL CTrayNotifyIcon::SetIcon(_In_ HICON hIcon)\n{\n  //Validate our parameters\n  ATLASSERT(hIcon != NULL);\n\n  if (!m_bCreated)\n    return FALSE;\n\n  //Since we are going to use one icon, stop any animation\n  StopAnimation();\n\n  //Call the Shell_NotifyIcon function\n  m_NotifyIconData.uFlags = NIF_ICON;\n  m_NotifyIconData.hIcon = hIcon;\n  return Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nBOOL CTrayNotifyIcon::SetIcon(_In_ LPCTSTR lpIconName)\n{\n  return SetIcon(LoadIcon(lpIconName));\n}\n\nBOOL CTrayNotifyIcon::SetIcon(_In_ UINT nIDResource)\n{\n  return SetIcon(LoadIcon(nIDResource));\n}\n\nBOOL CTrayNotifyIcon::SetStandardIcon(_In_ LPCTSTR lpIconName)\n{\n  return SetIcon(::LoadIcon(NULL, lpIconName));\n}\n\nBOOL CTrayNotifyIcon::SetStandardIcon(_In_ UINT nIDResource)\n{\n  return SetIcon(::LoadIcon(NULL, MAKEINTRESOURCE(nIDResource)));\n}\n\nBOOL CTrayNotifyIcon::SetIcon(_In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay)\n{\n  //Validate our parameters\n  ATLASSERT(nNumIcons >= 2); //must be using at least 2 icons if you are using animation\n  ATLASSUME(phIcons != NULL);\n  ATLASSERT(dwDelay);\n\n  if (!SetIcon(phIcons[0]))\n    return FALSE;\n\n  //Start the animation\n  return StartAnimation(phIcons, nNumIcons, dwDelay);\n}\n\nHICON CTrayNotifyIcon::LoadIcon(_In_ HINSTANCE hInstance, _In_ LPCTSTR lpIconName, _In_ BOOL bLargeIcon)\n{\n  return static_cast<HICON>(::LoadImage(hInstance, lpIconName, IMAGE_ICON, bLargeIcon ? GetSystemMetrics(SM_CXICON) : GetSystemMetrics(SM_CXSMICON), bLargeIcon ? GetSystemMetrics(SM_CYICON) : GetSystemMetrics(SM_CYSMICON), LR_SHARED));\n}\n\nHICON CTrayNotifyIcon::LoadIcon(_In_ HINSTANCE hInstance, _In_ UINT nIDResource, _In_ BOOL bLargeIcon)\n{\n  return LoadIcon(hInstance, MAKEINTRESOURCE(nIDResource), bLargeIcon);\n}\n\nHICON CTrayNotifyIcon::LoadIcon(_In_ LPCTSTR lpIconName, _In_ BOOL bLargeIcon)\n{\n#ifdef _AFX\n  return LoadIcon(AfxGetResourceHandle(), lpIconName, bLargeIcon);\n#else\n  return LoadIcon(ModuleHelper::GetResourceInstance(), lpIconName, bLargeIcon);\n#endif //#ifdef _AFX\n}\n\nHICON CTrayNotifyIcon::LoadIcon(_In_ UINT nIDResource, _In_ BOOL bLargeIcon)\n{\n  return LoadIcon(MAKEINTRESOURCE(nIDResource), bLargeIcon);\n}\n\n#ifdef _AFX\nBOOL CTrayNotifyIcon::SetNotificationWnd(_In_ CWnd* pNotifyWnd)\n#else\nBOOL CTrayNotifyIcon::SetNotificationWnd(_In_ CWindow* pNotifyWnd)\n#endif //#ifdef _AFX\n{\n  //Validate our parameters\n  ATLASSUME((pNotifyWnd != NULL) && ::IsWindow(pNotifyWnd->operator HWND()));\n\n  if (!m_bCreated)\n    return FALSE;\n\n  //Call the Shell_NotifyIcon function\n  m_pNotificationWnd = pNotifyWnd;\n  m_NotifyIconData.hWnd = pNotifyWnd->operator HWND();\n  m_NotifyIconData.uFlags = 0;\n  return Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nCTrayNotifyIcon::String CTrayNotifyIcon::GetTooltipText() const\n{\n  String sText;\n  if (m_bCreated)\n    sText = m_NotifyIconData.szTip;\n\n  return sText;\n}\n\nHICON CTrayNotifyIcon::GetIcon() const\n{\n  HICON hIcon = NULL;\n  if (m_bCreated)\n  {\n    if (UsingAnimatedIcon())\n      hIcon = GetCurrentAnimationIcon();\n    else\n      hIcon = m_NotifyIconData.hIcon;\n  }\n\n  return hIcon;\n}\n\n#ifdef _AFX\nCWnd* CTrayNotifyIcon::GetNotificationWnd() const\n#else\nCWindow* CTrayNotifyIcon::GetNotificationWnd() const\n#endif //#ifdef _AFX\n{\n  return m_pNotificationWnd;\n}\n\nBOOL CTrayNotifyIcon::SetFocus()\n{\n  ATLASSERT(m_ShellVersion >= Version5); //Only supported on Shell v5 or greater\n\n  //Call the Shell_NotifyIcon function\n  return Shell_NotifyIcon(NIM_SETFOCUS, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nLRESULT CTrayNotifyIcon::OnTrayNotification(WPARAM wParam, LPARAM lParam)\n{\n  BOOL bShowMenu = FALSE;\n  BOOL bDoubleClick = FALSE;\n  BOOL bSingleClick = FALSE;\n  UINT nIconID = 0;\n  if ((m_NotifyIconData.uVersion == 0) || (m_ShellVersion >= Version5))\n  {\n    nIconID = static_cast<UINT>(wParam);\n    bShowMenu = (lParam == WM_RBUTTONUP);\n    bDoubleClick = (lParam == WM_LBUTTONDBLCLK);\n\tbSingleClick = (lParam == WM_LBUTTONUP);\n  }\n  else\n  {\n    nIconID = HIWORD(lParam);\n    bShowMenu = (LOWORD(lParam) == WM_CONTEXTMENU);\n    bDoubleClick = (LOWORD(lParam) == WM_LBUTTONDBLCLK);\n\tbSingleClick = (LOWORD(lParam) == WM_LBUTTONUP);\n  }\n\n  //Return quickly if its not for this tray icon\n  if (nIconID != m_NotifyIconData.uID)\n    return 0L;\n\n  //Show the context menu or handle the double click\n  if (bShowMenu || bDoubleClick || bSingleClick)\n  {\n  #ifdef _AFX\n    CMenu* pSubMenu = m_Menu.GetSubMenu(0);\n    ATLASSUME(pSubMenu != NULL); //Your menu resource has been designed incorrectly\n  #else\n    CMenuHandle subMenu = m_Menu.GetSubMenu(0);\n    ATLASSERT(subMenu.IsMenu());\n  #endif //#ifdef _AFX\n  \n    if (bShowMenu)\n    {\n      CPoint ptCursor;\n      GetCursorPos(&ptCursor);\n      ::SetForegroundWindow(m_NotifyIconData.hWnd);  \n    #ifdef _AFX\n      ::TrackPopupMenu(pSubMenu->m_hMenu, TPM_LEFTBUTTON, ptCursor.x, ptCursor.y, 0, m_NotifyIconData.hWnd, NULL);\n    #else\n      ::TrackPopupMenu(subMenu, TPM_LEFTBUTTON, ptCursor.x, ptCursor.y, 0, m_NotifyIconData.hWnd, NULL);\n    #endif //#ifdef _AFX\n      ::PostMessage(m_NotifyIconData.hWnd, WM_NULL, 0, 0);\n    }\n    else if (bDoubleClick || bSingleClick) //double click received, the default action is to execute first menu item \n    {\n      ::SetForegroundWindow(m_NotifyIconData.hWnd);\n    #ifdef _AFX\n      UINT nDefaultItem = pSubMenu->GetDefaultItem(GMDI_GOINTOPOPUPS, FALSE);\n    #else\n      UINT nDefaultItem = subMenu.GetMenuDefaultItem(FALSE, GMDI_GOINTOPOPUPS);\n    #endif //#ifdef _AFX\n      if (nDefaultItem != -1)\n        ::SendMessage(m_NotifyIconData.hWnd, WM_COMMAND, nDefaultItem, 0);\n    }\n  }\n\n  return 1; // handled\n}\n\nBOOL CTrayNotifyIcon::GetDynamicDCAndBitmap(_In_ CDC* pDC, _In_ CBitmap* pBitmap)\n{\n  //Validate our parameters\n  ATLASSUME(pDC != NULL);\n  ATLASSUME(pBitmap != NULL);\n\n  //Get the HWND for the desktop\n#ifdef _AFX\n  CWnd* pWndScreen = CWnd::GetDesktopWindow();\n  if (pWndScreen == NULL)\n    return FALSE;\n#else\n  CWindow WndScreen(::GetDesktopWindow());\n  if (!WndScreen.IsWindow())\n    return FALSE;\n#endif //#ifdef _AFX\n\n  //Get the desktop HDC to create a compatible bitmap from\n#ifdef _AFX\n  CDC* pDCScreen = pWndScreen->GetDC();\n  if (pDCScreen == NULL)\n    return FALSE;\n#else\n  CDC DCScreen(WndScreen.GetDC());\n  if (DCScreen.IsNull())\n    return FALSE;\n#endif //#ifdef _AFX\n\n  //Get the width and height of a small icon\n  int w = GetSystemMetrics(SM_CXSMICON);\n  int h = GetSystemMetrics(SM_CYSMICON);\n\n  //Create an off-screen bitmap that the dynamic tray icon \n  //can be drawn into (Compatible with the desktop DC)\n#ifdef _AFX\n  BOOL bSuccess = pBitmap->CreateCompatibleBitmap(pDCScreen, w, h);\n#else\n  BOOL bSuccess = (pBitmap->CreateCompatibleBitmap(DCScreen.operator HDC(), w, h) != NULL);\n#endif //#ifdef _AFX\n  if (!bSuccess)\n  {\n  #ifdef _AFX\n    pWndScreen->ReleaseDC(pDCScreen);\n  #else\n    WndScreen.ReleaseDC(DCScreen);\n  #endif //#ifdef _AFX\n    return FALSE;\n  }\n\n  //Get a HDC to the newly created off-screen bitmap\n#ifdef _AFX\n  bSuccess = pDC->CreateCompatibleDC(pDCScreen);\n#else\n  bSuccess = (pDC->CreateCompatibleDC(DCScreen.operator HDC()) != NULL);\n#endif //#ifdef _AFX\n  if (!bSuccess)\n  {\n  //Release the Screen DC now that we are finished with it\n  #ifdef _AFX\n    pWndScreen->ReleaseDC(pDCScreen);\n  #else\n    WndScreen.ReleaseDC(DCScreen);\n  #endif //#ifdef _AFX\n\n    //Free up the bitmap now that we are finished with it\n    pBitmap->DeleteObject();\n\n    return FALSE;\n  }\n\n  //Select the bitmap into the offscreen DC\n#ifdef _AFX\n  pDC->SelectObject(pBitmap);\n#else\n  pDC->SelectBitmap(pBitmap->operator HBITMAP());\n#endif //#ifdef _AFX\n\n  //Release the Screen DC now that we are finished with it\n#ifdef _AFX\n  pWndScreen->ReleaseDC(pDCScreen);\n#else\n  WndScreen.ReleaseDC(DCScreen);\n#endif //#ifdef _AFX\n\n  return TRUE;\n}\n\nDWORD CTrayNotifyIcon::GetNOTIFYICONDATASizeForOS()\n{\n  //What will be the return value from this function\n  DWORD dwSize = sizeof(NOTIFYICONDATA_1);\n\n  switch (m_ShellVersion)\n  {\n    case Version7: //Deliberate fallthrough\n    case VersionVista:\n    {\n      dwSize = sizeof(NOTIFYICONDATA_4);\n      break;\n    }\n    case Version6:\n    {\n      dwSize = sizeof(NOTIFYICONDATA_3);\n      break;\n    }\n    case Version5:\n    {\n      dwSize = sizeof(NOTIFYICONDATA_2);\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n  \n  return dwSize;\n}\n\nBOOL CTrayNotifyIcon::StartAnimation(_In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay)\n{\n  //Validate our parameters\n  ATLASSERT(nNumIcons >= 2);  //must be using at least 2 icons if you are using animation\n  ATLASSUME(phIcons != NULL); //array of icon handles must be valid\n  ATLASSERT(dwDelay);         //must be non zero timer interval\n\n  //Stop the animation if already started  \n  StopAnimation();\n\n  //Hive away all the values locally\n  ATLASSERT(m_Icons.m_pData == NULL);\n  if (!m_Icons.Allocate(nNumIcons))\n    return FALSE;\n  ATLASSUME(m_Icons.m_pData != NULL);\n  for (int i=0; i<nNumIcons; i++)\n    m_Icons.m_pData[i] = phIcons[i];\n  m_nNumIcons = nNumIcons;\n\n  //Start up the timer \n  m_nTimerID = SetTimer(m_NotifyIconData.uID, dwDelay);\n\n  return TRUE;\n}\n\nvoid CTrayNotifyIcon::StopAnimation()\n{\n  //Kill the timer\n  if (m_nTimerID)\n  {\n    if (::IsWindow(m_hWnd))\n      KillTimer(m_nTimerID);\n    m_nTimerID = 0;\n  }\n \n  //Free up the memory\n  if (m_Icons.m_pData != NULL)\n    m_Icons.Free();\n\n  //Reset the other animation related variables\n  m_nCurrentIconIndex = 0;\n  m_nNumIcons = 0;\n}\n\nBOOL CTrayNotifyIcon::UsingAnimatedIcon() const\n{\n  return (m_nNumIcons != 0);\n}\n\nHICON CTrayNotifyIcon::GetCurrentAnimationIcon() const \n{ \n  //Valiate our parameters\n  ATLASSERT(UsingAnimatedIcon());\n  ATLASSUME(m_Icons.m_pData != NULL);\n  \n  return m_Icons.m_pData[m_nCurrentIconIndex];\n}\n\nBOOL CTrayNotifyIcon::ProcessWindowMessage(_In_ HWND /*hWnd*/, _In_ UINT nMsg, _In_ WPARAM wParam, _In_ LPARAM lParam, _Inout_ LRESULT& lResult, _In_ DWORD /*dwMsgMapID*/)\n{\n  lResult = 0;\n  BOOL bHandled = FALSE;\n\n  if (nMsg == wm_TaskbarCreated)\n  {\n    lResult = OnTaskbarCreated(wParam, lParam);\n    bHandled = TRUE;\n  }\n  else if ((nMsg == WM_TIMER) && (wParam == m_NotifyIconData.uID))\n  {\n    OnTimer(m_NotifyIconData.uID); \n    bHandled = TRUE;\n  }\n  else if (nMsg == WM_DESTROY)\n  {\n    OnDestroy();\n    bHandled = TRUE;\n  }\n\n  return bHandled;\n}\n\nvoid CTrayNotifyIcon::OnDestroy()\n{\n  StopAnimation();\n}\n\nLRESULT CTrayNotifyIcon::OnTaskbarCreated(WPARAM /*wParam*/, LPARAM /*lParam*/)\n{\n  //Refresh the tray icon if necessary\n  BOOL bShowing = IsShowing();\n  Delete(FALSE);\n  Create(bShowing);\n  \n  return 0;\n}\n\n#ifdef _DEBUG\nvoid CTrayNotifyIcon::OnTimer(UINT_PTR nIDEvent)\n#else\nvoid CTrayNotifyIcon::OnTimer(UINT_PTR /*nIDEvent*/)\n#endif //#ifdef _DEBUG\n{\n  //Validate our parameters\n  ATLASSERT(nIDEvent == m_nTimerID);\n  ATLASSUME(m_Icons.m_pData != NULL);\n\n  //increment the icon index\n  ++m_nCurrentIconIndex;\n  m_nCurrentIconIndex = m_nCurrentIconIndex % m_nNumIcons;\n\n  //update the tray icon\n  m_NotifyIconData.uFlags = NIF_ICON;\n  m_NotifyIconData.hIcon = m_Icons.m_pData[m_nCurrentIconIndex];\n  Shell_NotifyIcon(NIM_MODIFY, reinterpret_cast<PNOTIFYICONDATA>(&m_NotifyIconData));\n}\n\nBOOL CTrayNotifyIcon::CreateHelperWindow()\n{\n  //Let the base class do its thing\n  return (CWindowImpl<CTrayNotifyIcon>::Create(NULL, CWindow::rcDefault, _T(\"CTrayNotifyIcon Helper Window\"), WS_OVERLAPPEDWINDOW) != NULL);\n}\n\nCTrayWnd  CTrayNotifyIcon::m_wndInvisible;\n\nBOOL CTrayNotifyIcon::RemoveTaskbarIcon(CWnd* pWnd)\n{\n\tLPCTSTR pstrOwnerClass = AfxRegisterWndClass(0);\n\n\t// Create static invisible window\n\tif (!::IsWindow(m_wndInvisible.m_hWnd))\n\t{\n\t\tif (!m_wndInvisible.CreateEx(0, pstrOwnerClass, _T(\"\"), WS_POPUP,\n\t\t\tCW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n\t\t\tNULL, 0))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tpWnd->SetParent(&m_wndInvisible);\n\n\treturn TRUE;\n}\n\nvoid CTrayNotifyIcon::MinimiseToTray(CWnd* pWnd)\n{\n\tRemoveTaskbarIcon(pWnd);\n\tpWnd->ModifyStyle(WS_VISIBLE, 0);\n}\n\nvoid CTrayNotifyIcon::MaximiseFromTray(CWnd* pWnd)\n{\n\tpWnd->SetParent(NULL);\n\n\tpWnd->ModifyStyle(0, WS_VISIBLE);\n\tpWnd->RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_FRAME |\n\t\tRDW_INVALIDATE | RDW_ERASE);\n\n\t// Move focus away and back again to ensure taskbar icon is recreated\n\tif (::IsWindow(m_wndInvisible.m_hWnd))\n\t\tm_wndInvisible.SetActiveWindow();\n\tpWnd->SetActiveWindow();\n\tpWnd->SetForegroundWindow();\n}"
        },
        {
          "name": "NTray.h",
          "type": "blob",
          "size": 12.2041015625,
          "content": "/*\nModule : NTray.h\nPurpose: Interface for a MFC class to encapsulate Shell_NotifyIcon\nCreated: PJN / 14-05-1997\n\nCopyright (c) 1997 - 2016 by PJ Naughter (Web: www.naughter.com, Email: pjna@naughter.com)\n\nAll rights reserved.\n\nCopyright / Usage Details:\n\nYou are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) \nwhen your product is released in binary form. You are allowed to modify the source code in any way you want \nexcept you cannot modify the copyright details at the top of each module. If you want to distribute source \ncode with your application, then you are only allowed to distribute versions released by the author. This is \nto maintain a single distribution point for the source code. \n\n*/\n\n\n/////////////////////////// Macros / Defines ///////////////////////////\n\n#pragma once\n\n#ifndef _NTRAY_H__\n#define _NTRAY_H__\n\n#ifndef CTRAYNOTIFYICON_EXT_CLASS\n#define CTRAYNOTIFYICON_EXT_CLASS\n#endif //#ifndef CTRAYNOTIFYICON_EXT_CLASS\n\n#ifndef _In_\n#define _In_\n#endif //#ifndef _In_\n\n#ifndef _In_opt_\n#define _In_opt_\n#endif //#ifndef _In_opt_\n\n#ifndef _Out_\n#define _Out_\n#endif //#ifndef _Out_\n\n#ifndef _Inout_\n#define _Inout_\n#endif //#ifndef _Inout_\n\n#ifndef __ATLWIN_H__\n#pragma message(\"CTrayNotifyIcon as of v1.51 requires ATL support to implement its functionality. If your project is MFC only, then you need to update it to include ATL support\")\n#endif //#ifndef __ATLWIN_H__\n\n#ifndef _AFX\n#ifndef __ATLMISC_H__\n#pragma message(\"To avoid this message, please put atlmisc.h (part of WTL) in your pre compiled header (normally stdafx.h)\")\n#include <atlmisc.h> //If you do want to use CTrayNotifyIcon independent of MFC, then you need to download and install WTL from http://sourceforge.net/projects/wtl\n#endif //#ifndef __ATLMISC_H__\n#endif //#ifndef _AFX\n\n#include \"TrayWnd.h\"\n\n\n/////////////////////////// Classes ///////////////////////////////////////////\n\n//the actual tray notification class wrapper\nclass CTRAYNOTIFYICON_EXT_CLASS CTrayNotifyIcon : public CWindowImpl<CTrayNotifyIcon>\n{\npublic:\n//Enums / Typedefs\n #ifndef _AFX\n  typedef _CSTRING_NS::CString String;\n#else\n  typedef CString String;\n#endif //#ifndef _AFX\n\n  enum BalloonStyle\n  {\n    Warning,\n    Error,\n    Info,\n    None,\n    User\n  };\n\n  //We use our own definitions of the NOTIFYICONDATA structs so that\n  //we can use all the functionality without requiring client code to \n  //define _WIN32_IE >= 0x500\n  typedef struct _NOTIFYICONDATA_1 //The version of the structure supported by Shell v4\n  {\n    DWORD cbSize;\n    HWND hWnd;\n    UINT uID;\n    UINT uFlags;\n    UINT uCallbackMessage;\n    HICON hIcon;\n    TCHAR szTip[64];\n  } NOTIFYICONDATA_1;\n\n  typedef struct _NOTIFYICONDATA_2 //The version of the structure supported by Shell v5\n  {\n    DWORD cbSize;\n    HWND hWnd;\n    UINT uID;\n    UINT uFlags;\n    UINT uCallbackMessage;\n    HICON hIcon;\n    TCHAR szTip[128];\n    DWORD dwState;\n    DWORD dwStateMask;\n    TCHAR szInfo[256];\n    union \n    {\n      UINT uTimeout;\n      UINT uVersion;\n    } DUMMYUNIONNAME;\n    TCHAR szInfoTitle[64];\n    DWORD dwInfoFlags;\n  } NOTIFYICONDATA_2;\n\n  typedef struct _NOTIFYICONDATA_3 //The version of the structure supported by Shell v6\n  {\n    DWORD cbSize;\n    HWND hWnd;\n    UINT uID;\n    UINT uFlags;\n    UINT uCallbackMessage;\n    HICON hIcon;\n    TCHAR szTip[128];\n    DWORD dwState;\n    DWORD dwStateMask;\n    TCHAR szInfo[256];\n    union \n    {\n      UINT uTimeout;\n      UINT uVersion;\n    } DUMMYUNIONNAME;\n    TCHAR szInfoTitle[64];\n    DWORD dwInfoFlags;\n    GUID guidItem;\n  } NOTIFYICONDATA_3;\n\n  typedef struct _NOTIFYICONDATA_4 //The version of the structure supported by Shell v7\n  {\n    DWORD cbSize;\n    HWND hWnd;\n    UINT uID;\n    UINT uFlags;\n    UINT uCallbackMessage;\n    HICON hIcon;\n    TCHAR szTip[128];\n    DWORD dwState;\n    DWORD dwStateMask;\n    TCHAR szInfo[256];\n    union \n    {\n      UINT uTimeout;\n      UINT uVersion;\n    } DUMMYUNIONNAME;\n    TCHAR szInfoTitle[64];\n    DWORD dwInfoFlags;\n    GUID guidItem;\n    HICON hBalloonIcon;\n  } NOTIFYICONDATA_4;\n\n  DECLARE_WND_CLASS(_T(\"TrayNotifyIconClass\"))\n\n\n//Constructors / Destructors\n  CTrayNotifyIcon();\n  virtual ~CTrayNotifyIcon();\n\n//Create the tray icon\n#ifdef _AFX\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWnd* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n#else\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON hIcon, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ CBitmap* pBitmap, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n  BOOL Create(_In_ CWindow* pNotifyWnd, _In_ UINT uID, _In_ LPCTSTR pszTooltipText, _In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ UINT nTimeout, _In_ BalloonStyle style, _In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay, _In_ UINT nNotifyMessage, _In_ UINT uMenuID = 0, _In_ BOOL bNoSound = FALSE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_opt_ HICON hBalloonIcon = NULL, _In_ BOOL bQuietTime = FALSE, _In_ BOOL bShow = TRUE);\n#endif //#ifdef _AFX\n\n  BOOL RemoveTaskbarIcon(CWnd* pWnd);\n  void MinimiseToTray(CWnd* pWnd);\n  void MaximiseFromTray(CWnd* pWnd);\n\n//Sets or gets the Tooltip text\n  BOOL   SetTooltipText(_In_ LPCTSTR pszTooltipText);\n  BOOL   SetTooltipText(_In_ UINT nID);\n  String GetTooltipText() const;\n  int\t   GetTooltipMaxSize();\n\n//Sets or gets the icon displayed\n  BOOL SetIcon(_In_ HICON hIcon);\n  BOOL SetIcon(_In_ CBitmap* pBitmap);\n  BOOL SetIcon(_In_ LPCTSTR lpIconName);\n  BOOL SetIcon(_In_ UINT nIDResource);\n  BOOL SetIcon(_In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay);\n  BOOL SetStandardIcon(_In_ LPCTSTR lpIconName);\n  BOOL SetStandardIcon(_In_ UINT nIDResource);\n  HICON GetIcon() const;\n  BOOL UsingAnimatedIcon() const;\n\n//Sets or gets the window to send notification messages to\n#ifdef _AFX\n  BOOL SetNotificationWnd(_In_ CWnd* pNotifyWnd);\n  CWnd* GetNotificationWnd() const;\n#else\n  BOOL SetNotificationWnd(_In_ CWindow* pNotifyWnd);\n  CWindow* GetNotificationWnd() const;\n#endif //#ifdef _AFX\n\n//Modification of the tray icons\n  BOOL Delete(_In_ BOOL bCloseHelperWindow = TRUE);\n  BOOL Create(_In_ BOOL bShow = TRUE);\n  BOOL Hide();\n  BOOL Show();\n\n//Dynamic tray icon support\n  HICON BitmapToIcon(_In_ CBitmap* pBitmap);\n  static BOOL GetDynamicDCAndBitmap(_In_ CDC* pDC, _In_ CBitmap* pBitmap);\n\n//Modification of the menu to use as the context menu\n  void SetMenu(_In_ HMENU hMenu, UINT menuId);\n  CMenu& GetMenu();\n  void SetDefaultMenuItem(_In_ UINT uItem, _In_ BOOL fByPos);\n  void GetDefaultMenuItem(_Out_ UINT& uItem, _Out_ BOOL& fByPos) { uItem = m_nDefaultMenuItem; fByPos = m_bDefaultMenuItemByPos; };\n\n//Default handler for tray notification message\n  virtual LRESULT OnTrayNotification(WPARAM uID, LPARAM lEvent);\n\n//Status information\n  BOOL IsShowing() const { return !IsHidden(); };\n  BOOL IsHidden() const { return m_bHidden; };\n\n//Sets or gets the Balloon style tooltip settings\n  BOOL         SetBalloonDetails(_In_ LPCTSTR pszBalloonText, _In_ LPCTSTR pszBalloonCaption, _In_ BalloonStyle style, _In_ UINT nTimeout, _In_ HICON hUserIcon = NULL, _In_ BOOL bNoSound = TRUE, _In_ BOOL bLargeIcon = FALSE, _In_ BOOL bRealtime = FALSE, _In_ HICON hBalloonIcon = NULL);\n  String       GetBalloonText() const;\n  String       GetBalloonCaption() const;\n  BalloonStyle GetBalloonStyle() const;\n  UINT         GetBalloonTimeout() const;\n\n//Other functionality\n  BOOL SetVersion(_In_ UINT uVersion);\n  BOOL SetFocus();\n\n//Helper functions to load tray icon from resources\n  static HICON LoadIcon(_In_ LPCTSTR lpIconName, _In_ BOOL bLargeIcon = FALSE);\n  static HICON LoadIcon(_In_ UINT nIDResource, _In_ BOOL bLargeIcon = FALSE);\n  static HICON LoadIcon(_In_ HINSTANCE hInstance, _In_ LPCTSTR lpIconName, _In_ BOOL bLargeIcon = FALSE);\n  static HICON LoadIcon(_In_ HINSTANCE hInstance, _In_ UINT nIDResource, _In_ BOOL bLargeIcon = FALSE);\n\nprotected:\n//Methods\n  BOOL         CreateHelperWindow();\n  BOOL         StartAnimation(_In_ HICON* phIcons, _In_ int nNumIcons, _In_ DWORD dwDelay);\n  void         StopAnimation();\n  HICON        GetCurrentAnimationIcon() const;\n  virtual BOOL ProcessWindowMessage(_In_ HWND hWnd, _In_ UINT nMsg, _In_ WPARAM wParam, _In_ LPARAM lParam, _Inout_ LRESULT& lResult, _In_ DWORD dwMsgMapID);\n  LRESULT      OnTaskbarCreated(WPARAM wParam, LPARAM lParam);\n  void         OnTimer(UINT_PTR nIDEvent);\n  void         OnDestroy();\n  DWORD        GetNOTIFYICONDATASizeForOS();\n\n  static CTrayWnd  m_wndInvisible;\n\n//Enums\n  enum ShellVersion\n  {\n    Version4     = 0, //PreWin2k\n    Version5     = 1, //Win2k\n    Version6     = 2, //XP\n    VersionVista = 3, //Vista\n    Version7     = 4, //Windows7\n  };\n\n//Member variables\n  NOTIFYICONDATA_4     m_NotifyIconData;\n  BOOL                 m_bCreated;\n  BOOL                 m_bHidden;\n#ifdef _AFX\n  CWnd*                m_pNotificationWnd;\n#else\n  CWindow*             m_pNotificationWnd;\n#endif //#ifdef _AFX\n  CMenu                m_Menu;\n  UINT                 m_nDefaultMenuItem;\n  BOOL                 m_bDefaultMenuItemByPos;\n  ShellVersion         m_ShellVersion;\n  HICON                m_hDynamicIcon; //Our cached copy of the last icon created with BitmapToIcon\n  ATL::CHeapPtr<HICON> m_Icons;\n  int                  m_nNumIcons;\n  UINT_PTR             m_nTimerID;\n  int                  m_nCurrentIconIndex;\n  int                  m_nTooltipMaxSize;\n};\n\n#endif //#ifndef _NTRAY_H__\n"
        },
        {
          "name": "NoDbFrameWnd.cpp",
          "type": "blob",
          "size": 3.8876953125,
          "content": "#include \"stdafx.h\"\r\n#include \"NoDbFrameWnd.h\"\r\n#include \"resource.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"DatabaseUtilities.h\"\r\n#include \"Options.h\"\r\n#include \"CP_Main.h\"\r\n#include \"Misc.h\"\r\n\r\n#define WM_TRAYNOTIFY WM_USER + 100\r\n\r\n#define TIMER_OPEN_DB 1\r\n#define TIMER_ERROR_MSG 2\r\n\r\nBEGIN_MESSAGE_MAP(CNoDbFrameWnd, CFrameWnd)\r\n\tON_WM_CREATE()\r\n\tON_COMMAND(ID_FIRST_OPTIONS, &CNoDbFrameWnd::OnFirstOptions)\r\n\tON_COMMAND(ID_FIRST_EXIT_NO_DB, &CNoDbFrameWnd::OnFirstExitNoDb)\r\n\tON_MESSAGE(WM_TRAYNOTIFY, &CNoDbFrameWnd::OnTrayNotification)\r\n\tON_MESSAGE(WM_OPTIONS_CLOSED, OnOptionsClosed)\r\n\tON_WM_TIMER()\r\n\tON_WM_HOTKEY()\r\nEND_MESSAGE_MAP()\r\n\r\nCNoDbFrameWnd::CNoDbFrameWnd()\r\n{\r\n\tm_pOptions = NULL;\r\n\tm_pDittoHotKey = NULL;\r\n\tm_pDittoHotKey2 = NULL;\r\n\tm_pDittoHotKey3 = NULL;\r\n}\r\n\r\nint CNoDbFrameWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CFrameWnd::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\r\n\t////Center the main window so message boxes are in the center\r\n\tCRect rcScreen = DefaultMonitorRect();\r\n\tCPoint cpCenter = rcScreen.CenterPoint();\r\n\tMoveWindow(cpCenter.x, cpCenter.x, 1, 1);\r\n\r\n\tSetWindowText(_T(\"Ditto\"));\r\n\r\n\tm_trayIcon.Create(this, IDR_MENU_NO_DB, _T(\"Ditto\"), CTrayNotifyIcon::LoadIcon(IDI_MAINFRAME_NO_DB), WM_TRAYNOTIFY, 0, 1);\r\n\tm_trayIcon.SetDefaultMenuItem(ID_FIRST_OPTIONS, FALSE);\r\n\tm_trayIcon.MinimiseToTray(this);\r\n\r\n\tSetTimer(TIMER_OPEN_DB, 15000, NULL);\r\n\tSetTimer(TIMER_ERROR_MSG, 180000, NULL);\r\n\r\n\tg_HotKeys.Init(m_hWnd);\r\n\r\n\tm_pDittoHotKey = new CHotKey(CString(\"DittoHotKey\"), 704); //704 is ctrl-tilda\r\n\tm_pDittoHotKey2 = new CHotKey(CString(\"DittoHotKey2\"));\r\n\tm_pDittoHotKey3 = new CHotKey(CString(\"DittoHotKey3\"));\r\n\r\n\tg_HotKeys.RegisterAll();\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CNoDbFrameWnd::OnFirstOptions()\r\n{\r\n\tif (m_pOptions != NULL)\r\n\t{\r\n\t\t::SetForegroundWindow(m_pOptions->m_hWnd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pOptions = new COptionsSheet(_T(\"\"));\r\n\r\n\t\tif (m_pOptions != NULL)\r\n\t\t{\r\n\t\t\t((COptionsSheet*)m_pOptions)->SetNotifyWnd(m_hWnd);\r\n\t\t\tm_pOptions->Create();\r\n\t\t\tm_pOptions->ShowWindow(SW_SHOW);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CNoDbFrameWnd::OnFirstExitNoDb()\r\n{\r\n\tthis->SendMessage(WM_CLOSE, 0, 0);\r\n}\r\n\r\nLRESULT CNoDbFrameWnd::OnTrayNotification(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_trayIcon.OnTrayNotification(wParam, lParam);\r\n\treturn 0L;\r\n}\r\n\r\nvoid CNoDbFrameWnd::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\tswitch (nIDEvent)\r\n\t{\r\n\tcase TIMER_OPEN_DB:\r\n\t\tTryOpenDatabase();\r\n\t\tbreak;\r\n\tcase TIMER_ERROR_MSG:\r\n\t\tKillTimer(TIMER_ERROR_MSG);\r\n\t\tShowNoDbMessage();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tCFrameWnd::OnTimer(nIDEvent);\r\n}\r\n\r\nvoid CNoDbFrameWnd::ShowNoDbMessage()\r\n{\r\n\tCString msg = theApp.m_Language.GetString(_T(\"StartupNoDbMsg\"), _T(\"Ditto was unable to open its database, waiting until it can be opened. Update the path in Options if needed. Path: \"));\r\n\tmsg += StrF(_T(\" %s\"), CGetSetOptions::GetDBPath());\r\n\tm_trayIcon.SetBalloonDetails(msg, _T(\"Ditto\"), CTrayNotifyIcon::BalloonStyle::Info, CGetSetOptions::GetBalloonTimeout());\r\n}\r\n\r\nvoid CNoDbFrameWnd::TryOpenDatabase()\r\n{\r\n\tif (IsDatabaseOpen() ||\r\n\t\tCheckDBExists(CGetSetOptions::GetDBPath()))\r\n\t{\r\n\t\tg_HotKeys.Remove(m_pDittoHotKey);\r\n\t\tdelete m_pDittoHotKey;\r\n\t\tm_pDittoHotKey = NULL;\r\n\r\n\t\tg_HotKeys.Remove(m_pDittoHotKey2);\r\n\t\tdelete m_pDittoHotKey2;\r\n\t\tm_pDittoHotKey2 = NULL;\r\n\r\n\t\tg_HotKeys.Remove(m_pDittoHotKey3);\r\n\t\tdelete m_pDittoHotKey3;\r\n\t\tm_pDittoHotKey3 = NULL;\r\n\r\n\t\tKillTimer(TIMER_OPEN_DB);\r\n\t\tKillTimer(TIMER_ERROR_MSG);\r\n\t\tm_trayIcon.Hide();\r\n\r\n\t\ttheApp.CreateMainWnd();\r\n\t}\r\n}\r\n\r\nLRESULT CNoDbFrameWnd::OnOptionsClosed(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tdelete m_pOptions;\r\n\tm_pOptions = NULL;\r\n\r\n\tTryOpenDatabase();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CNoDbFrameWnd::OnHotKey(UINT nHotKeyId, UINT nKey1, UINT nKey2)\r\n{\r\n\tif (m_pDittoHotKey && nHotKeyId == m_pDittoHotKey->m_Atom ||\r\n\t\tm_pDittoHotKey2 && nHotKeyId == m_pDittoHotKey2->m_Atom ||\r\n\t\tm_pDittoHotKey3 && nHotKeyId == m_pDittoHotKey3->m_Atom)\r\n\t{\r\n\t\tShowNoDbMessage();\r\n\t}\r\n\r\n\tCFrameWnd::OnHotKey(nHotKeyId, nKey1, nKey2);\r\n}\r\n"
        },
        {
          "name": "NoDbFrameWnd.h",
          "type": "blob",
          "size": 0.8271484375,
          "content": "#pragma once\r\n#include <afxwin.h>\r\n#include \"NTray.h\"\r\n#include \"HotKeys.h\"\r\n\r\nclass CNoDbFrameWnd : public CFrameWnd\r\n{\r\npublic:\r\n\tDECLARE_MESSAGE_MAP()\r\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\r\n\r\npublic:\r\n\tCNoDbFrameWnd();\r\n\r\n\tCTrayNotifyIcon m_trayIcon;\r\n\tCPropertySheet* m_pOptions;\r\n\tCHotKey* m_pDittoHotKey; // activate ditto's qpaste window\r\n\tCHotKey* m_pDittoHotKey2; // activate ditto's qpaste window\r\n\tCHotKey* m_pDittoHotKey3; // activate ditto's qpaste window\r\n\r\n\tafx_msg void OnFirstOptions();\r\n\tafx_msg void OnFirstExitNoDb();\r\n\tafx_msg LRESULT OnTrayNotification(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\r\n\tvoid ShowNoDbMessage();\r\n\tvoid TryOpenDatabase();\r\n\tLRESULT OnOptionsClosed(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnHotKey(UINT nHotKeyId, UINT nKey1, UINT nKey2);\r\n};\r\n\r\n"
        },
        {
          "name": "NumberEdit.cpp",
          "type": "blob",
          "size": 1.8095703125,
          "content": "// NumberEdit.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"NumberEdit.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CNumberEdit\n\nCNumberEdit::CNumberEdit()\n{\n\tm_dMax = LONG_MAX;\n}\n\nCNumberEdit::~CNumberEdit()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CNumberEdit, CEdit)\n\t//{{AFX_MSG_MAP(CNumberEdit)\n\tON_WM_CHAR()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CNumberEdit message handlers\n\nvoid CNumberEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) \n{\n\t//Only allow the number 0 - 9 and a the backspace to go through\n\tif(((nChar < '0') || (nChar > '9')) && (nChar != VK_BACK))\n\t\treturn;\n\n\tCString csText;\n\tGetWindowText(csText);\n\n\t//Save this if the validate fails then these get set back\n\tint nStartChar, nEndChar;\n\tGetSel(nStartChar, nEndChar);\n\n\t//Set the new number\n\tCEdit::OnChar(nChar, nRepCnt, nFlags);\n\t\n\t//If its not valid set it back to the old number\n\tif(!ValidateNumber(GetNumberD()))\n\t{\n\t\tSetWindowText(csText);\n\t\tSetSel(nStartChar, nEndChar);\n\t}\n}\n\nBOOL CNumberEdit::ValidateNumber(double dNumber)\n{\n\tif(dNumber > m_dMax)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nlong CNumberEdit::GetNumber()\n{\n\tCString csText;\n\tGetWindowText(csText);\n\t\n\treturn ATOL(csText);\n}\n\ndouble CNumberEdit::GetNumberD()\n{\n\tCString csText;\n\tGetWindowText(csText);\n\n#ifdef _UNICODE\t\t\t\t\n\tTCHAR *pEnd;\n\tdouble d = _tcstod(csText, &pEnd);\n#else\n\tdouble d = atof(csText);\n#endif\n\n\treturn d;\n}\n\nBOOL CNumberEdit::SetNumber(long lNumber)\n{\n\t//Check if its a good number\n\tif(!ValidateNumber(lNumber))\n\t{\n\t\tMessageBeep(0);\n\t\treturn FALSE;\n\t}\n\n\t//Its good\n\tCString csText;\n\tcsText.Format(_T(\"%d\"), lNumber);\n\tSetWindowText(csText);\n\n\treturn TRUE;\n}\n\n"
        },
        {
          "name": "NumberEdit.h",
          "type": "blob",
          "size": 1.322265625,
          "content": "#if !defined(AFX_NUMBEREDIT_H__C68189CB_8445_4009_8F29_34645AEBD9C5__INCLUDED_)\n#define AFX_NUMBEREDIT_H__C68189CB_8445_4009_8F29_34645AEBD9C5__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// NumberEdit.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CNumberEdit window\n\nclass CNumberEdit : public CEdit\n{\n// Construction\npublic:\n\tCNumberEdit();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CNumberEdit)\n\t//}}AFX_VIRTUAL\n\npublic:\n\tdouble GetNumberD();\n\tlong GetNumber();\n\tBOOL SetNumber(long lNumber);\n\t\n\tvoid SetMaxNumber(long lMax)\t\t{ m_dMax = lMax;\t\t}\n\tlong GetMaxNumber()\t\t\t\t\t{ return (long)m_dMax;\t}\n\t\nprotected:\n\tBOOL ValidateNumber(double dNumber);\n\n\tdouble m_dMax;\n\n// Implementation\npublic:\n\tvirtual ~CNumberEdit();\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CNumberEdit)\n\tafx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_NUMBEREDIT_H__C68189CB_8445_4009_8F29_34645AEBD9C5__INCLUDED_)\n"
        },
        {
          "name": "OleClipSource.cpp",
          "type": "blob",
          "size": 31.427734375,
          "content": "#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"OleClipSource.h\"\n#include \"shared/TextConvert.h\"\n#include \"CF_HDropAggregator.h\"\n#include \"CF_UnicodeTextAggregator.h\"\n#include \"CF_TextAggregator.h\"\n#include \"richtextaggregator.h\"\n#include \"htmlformataggregator.h\"\n#include \"Shared\\Tokenizer.h\"\n#include <random>\n#include \"Client.h\"\n#include \"Path.h\"\n#include \"Md5.h\"\n#include \"DittoChaiScript.h\"\n#include \"ChaiScriptOnCopy.h\"\n#include \"Slugify.h\"\n#include \"ImageFormatAggregator.h\"\n\n/*------------------------------------------------------------------*\\\nCOleClipSource\n\\*------------------------------------------------------------------*/\n//IMPLEMENT_DYNAMIC(COleClipSource, COleDataSource)\nCOleClipSource::COleClipSource()\n{\n\tm_bLoadedFormats = false;\n\tm_convertToHDROPOnDelayRender = false;\n}\n\nCOleClipSource::~COleClipSource()\n{\n\t\n}\n\nBOOL COleClipSource::DoDelayRender()\n{\n\tCClipTypes types;\n\tm_ClipIDs.GetTypes(types);\n\n\tbool foundHDrop = false;\n\t\n\tINT_PTR count = types.GetSize();\n\tfor(int i=0; i < count; i++)\n\t{\n\t\tif (m_pasteOptions.m_dragDropFilesOnly)\n\t\t{\n\t\t\tif (types[i] == CF_HDROP)\n\t\t\t{\n\t\t\t\tDelayRenderData(types[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDelayRenderData(types[i]);\n\t\t}\n\n\t\tif (types[i] == CF_HDROP)\n\t\t{\n\t\t\tfoundHDrop = true;\n\t\t}\n\t}\n\n\tif (m_pasteOptions.m_placeCF_HDROP_OnDrag &&\n\t\tfoundHDrop == false)\n\t{\n\t\tDelayRenderData(CF_HDROP);\n\t\tm_convertToHDROPOnDelayRender = true;\n\t}\n\n\treturn count > 0;\n}\n\nBOOL COleClipSource::DoImmediateRender()\n{\n\tif(m_bLoadedFormats)\n\t\treturn TRUE;\n\n\tm_bLoadedFormats = true;\n\n\tif(m_pasteOptions.m_pPasteFormats != NULL)\n\t{\n\t\treturn PutFormatOnClipboard(m_pasteOptions.m_pPasteFormats) > 0;\n\t}\n\t\n\tINT_PTR count = m_ClipIDs.GetSize();\n\tif(count <= 0)\n\t\treturn 0;\n\t\n\tCClip clip;\n\n\tif(count > 1)\n\t{\n\t\tif (m_pasteOptions.m_pasteImagesHorizontal ||\n\t\t\tm_pasteOptions.m_pasteImagesVertically)\n\t\t{\n\t\t\tCImageFormatAggregator bigImage(m_pasteOptions.m_pasteImagesHorizontal);\n\t\t\tif (m_ClipIDs.AggregateData(bigImage, CF_DIB, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t{\n\t\t\t\tCClipFormat cf(CF_DIB, bigImage.GetHGlobal());\n\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCStringA SepA = CTextConvert::UnicodeToAnsi(CGetSetOptions::GetMultiPasteSeparator());\n\t\t\tCCF_TextAggregator CFText(SepA);\n\t\t\tif (m_ClipIDs.AggregateData(CFText, CF_TEXT, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t{\n\t\t\t\tCClipFormat cf(CF_TEXT, CFText.GetHGlobal());\n\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t}\n\n\t\t\tCStringW SepW = CGetSetOptions::GetMultiPasteSeparator();\n\t\t\tCCF_UnicodeTextAggregator CFUnicodeText(SepW);\n\t\t\tif (m_ClipIDs.AggregateData(CFUnicodeText, CF_UNICODETEXT, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t{\n\t\t\t\tCClipFormat cf(CF_UNICODETEXT, CFUnicodeText.GetHGlobal());\n\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t}\n\n\t\t\tif (m_pasteOptions.LimitFormatsToText() == false)\n\t\t\t{\n\t\t\t\tCCF_HDropAggregator HDrop;\n\t\t\t\tif (m_ClipIDs.AggregateData(HDrop, CF_HDROP, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t\t{\n\t\t\t\t\tCClipFormat cf(CF_HDROP, HDrop.GetHGlobal());\n\t\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t\t}\n\n\t\t\t\tCRichTextAggregator RichText(SepA);\n\t\t\t\tif (m_ClipIDs.AggregateData(RichText, theApp.m_RTFFormat, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t\t{\n\t\t\t\t\tCClipFormat cf(theApp.m_RTFFormat, RichText.GetHGlobal());\n\t\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t\t}\n\n\t\t\t\tCHTMLFormatAggregator Html(SepA);\n\t\t\t\tif (m_ClipIDs.AggregateData(Html, theApp.m_HTML_Format, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t\t\t{\n\t\t\t\t\tCClipFormat cf(theApp.m_HTML_Format, Html.GetHGlobal());\n\t\t\t\t\tclip.m_Formats.Add(cf);\n\t\t\t\t\t//clip.m_Formats now owns the global data\n\t\t\t\t\tcf.m_autoDeleteData = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count >= 1 && clip.m_Formats.GetCount() == 0)\n\t{\n\t\tclip.LoadFormats(m_ClipIDs[0], m_pasteOptions.LimitFormatsToText(), m_pasteOptions.IncludeRTFForTextOnly());\n\t}\n\n\tif (m_pasteOptions.LimitFormatsToText())\n\t{\n\t\tPlainTextFilter(clip);\n\t}\n\n\tif(m_pasteOptions.m_pasteUpperCase ||\n\t\tm_pasteOptions.m_pasteLowerCase)\n\t{\n\t\tDoUpperLowerCase(clip, m_pasteOptions.m_pasteUpperCase);\n\t}\n\telse if(m_pasteOptions.m_pasteCapitalize)\n\t{\n\t\tCapitalize(clip);\n\t}\n\telse if(m_pasteOptions.m_pasteSentenceCase)\n\t{\n\t\tSentenceCase(clip);\n\t}\n\telse if(m_pasteOptions.m_pasteRemoveLineFeeds)\n\t{\n\t\tRemoveLineFeeds(clip);\n\t}\n\telse if(m_pasteOptions.m_pasteAddOneLineFeed)\n\t{\n\t\tAddLineFeeds(clip, 1);\n\t}\n\telse if (m_pasteOptions.m_pasteAddTwoLineFeeds)\n\t{\n\t\tAddLineFeeds(clip, 2);\n\t}\n\telse if (m_pasteOptions.m_pasteTypoglycemia)\n\t{\n\t\tTypoglycemia(clip);\n\t}\n\telse if (m_pasteOptions.m_pasteAddingDateTime)\n\t{\n\t\tAddDateTime(clip);\n\t}\n\telse if (m_pasteOptions.m_trimWhiteSpace)\n\t{\n\t\tTrimWhiteSpace(clip);\n\t}\n\telse if (m_pasteOptions.m_pasteSlugify)\n\t{\n\t\tSlugify(clip);\n\t}\n\telse if (m_pasteOptions.m_invertCase)\n\t{\n\t\tInvertCase(clip);\n\t}\n\telse if (m_pasteOptions.m_pasteCamelCase)\n\t{\n\t\tCamelCase(clip);\n\t}\n\telse if (m_pasteOptions.m_pasteAsciiOnly)\n\t{\n\t\tAsciiOnly(clip);\n\t}\n\t\n\tSaveDittoFileDataToFile(clip);\n\n\tif (m_pasteOptions.m_pasteScriptGuid != _T(\"\"))\n\t{\n\t\tfor (auto & element : CGetSetOptions::m_pasteScripts.m_list)\n\t\t{\n\t\t\tif (element.m_guid == m_pasteOptions.m_pasteScriptGuid)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tLog(StrF(_T(\"Start of paste script name: %s, script: %s\"), element.m_name, element.m_script));\n\n\t\t\t\t\tChaiScriptOnCopy onPaste;\n\t\t\t\t\tCDittoChaiScript clipData(&clip, \"\", \"\");\n\t\t\t\t\tif (onPaste.ProcessScript(clipData, (LPCSTR)CTextConvert::UnicodeToAnsi(element.m_script)) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tLog(StrF(_T(\"End of paste script name: %s, returned false, not saving this copy to Ditto, last Error: %s\"), element.m_name, onPaste.m_lastError));\n\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tLog(StrF(_T(\"End of paste script name: %s, returned true, last Error: %s\"), element.m_name, onPaste.m_lastError));\n\t\t\t\t}\n\t\t\t\tcatch (CException *ex)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szCause[255];\n\t\t\t\t\tex->GetErrorMessage(szCause, 255);\n\t\t\t\t\tCString cs;\n\t\t\t\t\tcs.Format(_T(\"chai script paste exception: %s\"), szCause);\n\t\t\t\t\tLog(cs);\n\t\t\t\t}\n\t\t\t\tcatch (...)\n\t\t\t\t{\n\t\t\t\t\tLog(_T(\"chai script paste exception 2\"));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn PutFormatOnClipboard(&clip.m_Formats) > 0;\n}\n\nvoid COleClipSource::DoUpperLowerCase(CClip &clip, bool upper)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\t\t\n\t\tCString cs = unicodeTextFormat->GetAsCString();\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\t\t\t\t\n\t\tCString val;\n\t\tif (upper)\n\t\t{\n\t\t\tval = theApp.m_icuString.ToUpperStringEx(cs);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval = theApp.m_icuString.ToLowerStringEx(cs);\n\t\t}\n\t\t\n\t\tlong lLen = val.GetLength();\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(lLen), ((lLen+1) * sizeof(wchar_t)));\n\t\tval.ReleaseBuffer();\n\n\t\tunicodeTextFormat->Data(hGlobal);\t\t\n\t}\n\n\tIClipFormat *asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\t\t\n\t\tCString val;\n\t\tif (upper)\n\t\t{\n\t\t\tval = cs.MakeUpper();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval = cs.MakeLower();\n\t\t}\n\n\t\tlong lLen = val.GetLength();\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(lLen), lLen + sizeof(char));\n\t\tval.ReleaseBuffer();\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::InvertCase(CClip &clip)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\t\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tconst int len = cs.GetLength();\n\t\tif (len > 0)\n\t\t{\n\t\t\twchar_t* pText = cs.GetBuffer();\n\t\t\t\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\twchar_t item = pText[i];\n\t\t\t\tif (theApp.m_icuString.IsUpperEx(item))\n\t\t\t\t{\n\t\t\t\t\tpText[i] = theApp.m_icuString.ToLowerEx(item);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpText[i] = theApp.m_icuString.ToUpperEx(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(cs.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\tIClipFormat *asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\n\t\tlong len = cs.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tchar * pText = cs.GetBuffer();\n\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tchar item = pText[i];\n\t\t\t\tif (::isupper(item))\n\t\t\t\t{\n\t\t\t\t\tpText[i] = ::tolower(item);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpText[i] = ::toupper(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(cs.GetBuffer(), (len + 1));\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::CamelCase(CClip& clip)\n{\n\tIClipFormat* unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tconst int len = cs.GetLength();\n\t\tif (len > 0)\n\t\t{\n\t\t\twchar_t* pText = cs.GetBuffer();\n\n\t\t\tbool setCapital = false;\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\twchar_t item = pText[i];\n\t\t\t\tif (item == ' ')\n\t\t\t\t{\n\t\t\t\t\tsetCapital = true;\n\t\t\t\t}\n\t\t\t\telse if (setCapital || i == 0)\n\t\t\t\t{\n\t\t\t\t\tif (theApp.m_icuString.IsUpperEx(item) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tpText[i] = theApp.m_icuString.ToUpperEx(item);\n\t\t\t\t\t}\n\t\t\t\t\tsetCapital = false;\n\t\t\t\t}\n\t\t\t\telse if (theApp.m_icuString.IsUpperEx(item))\n\t\t\t\t{\n\t\t\t\t\tpText[i] = theApp.m_icuString.ToLowerEx(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs.ReleaseBuffer();\n\n\t\tcs.Remove(' ');\n\n\t\tHGLOBAL hGlobal = NewGlobalP(cs.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\tIClipFormat* asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\n\t\tlong len = cs.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tchar* pText = cs.GetBuffer();\n\n\t\t\tbool setCapital = false;\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tchar item = pText[i];\n\t\t\t\tif (item == ' ')\n\t\t\t\t{\n\t\t\t\t\tsetCapital = true;\n\t\t\t\t}\n\t\t\t\telse if (setCapital || i == 0)\n\t\t\t\t{\n\t\t\t\t\tif (::isupper(item) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tpText[i] = ::toupper(item);\n\t\t\t\t\t}\n\t\t\t\t\tsetCapital = false;\n\t\t\t\t}\n\t\t\t\telse if(::isupper(item))\n\t\t\t\t{\n\t\t\t\t\tpText[i] = ::tolower(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs.ReleaseBuffer();\n\t\tcs.Remove(' ');\n\n\t\tHGLOBAL hGlobal = NewGlobalP(cs.GetBuffer(), (len + 1));\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::Capitalize(CClip &clip)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\t\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tCString val = theApp.m_icuString.ToLowerStringEx(cs);\n\t\tlong len = val.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\twchar_t * pText = val.GetBuffer();\n\t\t\t\n\t\t\tpText[0] = theApp.m_icuString.ToUpperEx(pText[0]);\n\t\t\tbool capitalize = false;\n\t\t\t\n\t\t\tfor (int i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\twchar_t item = pText[i];\n\t\t\t\tif (item == ' ')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = true;\n\t\t\t\t}\n\t\t\t\telse if (capitalize)\n\t\t\t\t{\n\t\t\t\t\tpText[i] = theApp.m_icuString.ToUpperEx(item);\n\t\t\t\t\tcapitalize = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tval.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\t//my change\n\t//test\n\t//second test\n\n\tIClipFormat *asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\n\t\tCStringA val = cs.MakeLower();\n\t\tlong len = val.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tchar * pText = val.GetBuffer();\n\n\t\t\tpText[0] = toupper(pText[0]);\n\t\t\tbool capitalize = false;\n\n\t\t\tfor (int i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tchar item = pText[i];\n\t\t\t\tif (item == ' ')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = true;\n\t\t\t\t}\n\t\t\t\telse if (capitalize)\n\t\t\t\t{\n\t\t\t\t\tpText[i] = toupper(item);\n\t\t\t\t\tcapitalize = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tval.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(), (len + 1));\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::SentenceCase(CClip &clip)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tCString val = theApp.m_icuString.ToLowerStringEx(cs);;\n\t\tlong len = val.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\twchar_t * pText = val.GetBuffer();\n\n\t\t\tpText[0] = theApp.m_icuString.ToUpperEx(pText[0]);\n\t\t\tbool capitalize = false;\n\n\t\t\tfor (int i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\twchar_t item = pText[i];\n\t\t\t\tif (item == '.' ||\n\t\t\t\t\titem == '!' ||\n\t\t\t\t\titem == '?')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = true;\n\t\t\t\t}\n\t\t\t\telse if (capitalize && item != ' ')\n\t\t\t\t{\n\t\t\t\t\tpText[i] = theApp.m_icuString.ToUpperEx(item);\n\t\t\t\t\tcapitalize = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tval.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\tIClipFormat *asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\n\t\tCStringA val = cs.MakeLower();\n\t\tlong len = val.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tchar * pText = val.GetBuffer();\n\n\t\t\tpText[0] = toupper(pText[0]);\n\t\t\tbool capitalize = false;\n\n\t\t\tfor (int i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tchar item = pText[i];\n\t\t\t\tif (item == '.' ||\n\t\t\t\t\titem == '!' ||\n\t\t\t\t\titem == '?')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = true;\n\t\t\t\t}\n\t\t\t\telse if (capitalize && item != ' ')\n\t\t\t\t{\n\t\t\t\t\tpText[i] = toupper(item);\n\t\t\t\t\tcapitalize = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tval.ReleaseBuffer();\n\n\t\tHGLOBAL hGlobal = NewGlobalP(val.GetBuffer(), (len + 1));\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::AsciiOnly(CClip& clip)\n{\n\tIClipFormat* unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\n\t\tCString newString;\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\t\t\n\t\tlong len = cs.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\twchar_t item = cs[i];\n\t\t\t\tif (item >= 0x00 && item <= 0x7F)\n\t\t\t\t{\n\t\t\t\t\tnewString += item;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(newString.GetBuffer(), ((newString.GetLength() + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\tIClipFormat* asciiTextFormat = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (asciiTextFormat != NULL)\n\t{\n\t\tCStringA cs(asciiTextFormat->GetAsCStringA());\n\t\tCStringA newString;\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tasciiTextFormat->Free();\n\t\t\t\t\n\t\tlong len = cs.GetLength();\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tchar item = cs[i];\n\t\t\t\tif (item >= 0x00 && item <= 0x7F)\n\t\t\t\t{\n\t\t\t\t\tnewString += item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(newString.GetBuffer(), (newString.GetLength() + 1));\n\n\t\tasciiTextFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::PlainTextFilter(CClip &clip)\n{\n\tbool foundText = false;\n\tINT_PTR hDropIndex = -1;\n\tINT_PTR\tcount = clip.m_Formats.GetCount();\n\tfor (INT_PTR i = 0; i < count; i++)\n\t{\n\t\tCClipFormat *pCF = &clip.m_Formats.ElementAt(i);\n\n\t\tif (pCF->m_cfType == CF_TEXT ||\n\t\t\tpCF->m_cfType == CF_UNICODETEXT)\n\t\t{\n\t\t\tfoundText = true;\n\t\t}\n\t\telse if (pCF->m_cfType == CF_HDROP)\n\t\t{\n\t\t\thDropIndex = i;\n\t\t}\n\t}\n\n\tif (foundText &&\n\t\thDropIndex > -1)\n\t{\n\t\tclip.m_Formats.RemoveAt(hDropIndex);\n\t}\n\telse if (foundText == false &&\n\t\thDropIndex > -1)\n\t{\n\t\tCCF_HDropAggregator HDrop;\n\t\tif (m_ClipIDs.AggregateData(HDrop, CF_HDROP, CGetSetOptions::m_bMultiPasteReverse, m_pasteOptions.LimitFormatsToText()))\n\t\t{\n\t\t\tclip.m_Formats.RemoveAt(hDropIndex);\n\n\t\t\tCClipFormat format(CF_UNICODETEXT, HDrop.GetHGlobalAsString());\n\t\t\tclip.m_Formats.Add(format);\n\t\t\tformat.m_autoDeleteData = false; //owned by m_DelayRenderedFormats\t\t\t\n\t\t}\n\t}\n}\n\nvoid COleClipSource::RemoveLineFeeds(CClip &clip)\n{\n\tIClipFormat *pUnicodeText = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (pUnicodeText != NULL)\n\t{\t\t\n\t\tCStringW string(pUnicodeText->GetAsCString());\n\t\t\n\t\tpUnicodeText->Free();\n\n\t\tint count = string.Replace(_T(\"\\r\\n\"), _T(\" \"));\n\t\tcount = string.Replace(_T(\"\\r\"), _T(\" \"));\n\t\tcount = string.Replace(_T(\"\\n\"), _T(\" \"));\n\t\t\t\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1) * sizeof(wchar_t)));\n\n\t\tpUnicodeText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pAsciiText = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (pAsciiText != NULL)\n\t{\n\t\tCStringA string(pAsciiText->GetAsCStringA());\n\n\t\tpAsciiText->Free();\n\n\t\tint count = string.Replace(\"\\r\\n\", \" \");\n\t\tcount = string.Replace(\"\\r\", \" \");\n\t\tcount = string.Replace(\"\\n\", \" \");\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpAsciiText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pRTFFormat = clip.m_Formats.FindFormatEx(theApp.m_RTFFormat);\n\tif (pRTFFormat != NULL)\n\t{\n\t\tCStringA string(pRTFFormat->GetAsCStringA());\n\t\t\n\t\tpRTFFormat->Free();\n\n\t\tint count = string.Replace(\"\\\\par\\r\\n\", \" \");\n\t\tint count2 = string.Replace(\"\\\\par \", \" \");\n\t\tint count3 = string.Replace(\"\\\\line \", \" \");\n\t\t\t\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpRTFFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::AddLineFeeds(CClip &clip, int count)\n{\n\tIClipFormat *pUnicodeText = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (pUnicodeText != NULL)\n\t{\t\t\n\t\tCStringW string(pUnicodeText->GetAsCString());\n\t\t\n\t\tpUnicodeText->Free();\n\n\t\tfor(int i = 0; i < count; i++)\n\t\t{\n\t\t\tstring += _T(\"\\r\\n\");\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1) * sizeof(wchar_t)));\n\n\t\tpUnicodeText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pAsciiText = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (pAsciiText != NULL)\n\t{\t\t\n\t\tCStringA string(pAsciiText->GetAsCStringA());\n\n\t\tpAsciiText->Free();\n\n\t\tfor (int i = 0; i < count; i++)\n\t\t{\n\t\t\tstring += \"\\r\\n\";\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpAsciiText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pRTFFormat = clip.m_Formats.FindFormatEx(theApp.m_RTFFormat);\n\tif (pRTFFormat != NULL)\n\t{\n\t\tCStringA string(pRTFFormat->GetAsCStringA());\n\t\t\t\n\t\tpRTFFormat->Free();\n\n\t\tfor (int i = 0; i < count; i++)\n\t\t{\n\t\t\tint pos = string.ReverseFind('}');\n\t\t\tif (pos >= 0)\n\t\t\t{\n\t\t\t\tint count = string.Insert(pos, \"\\\\par\\r\\n\");\n\t\t\t}\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpRTFFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::AddDateTime(CClip &clip)\n{\n\tIClipFormat *pUnicodeText = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (pUnicodeText != NULL)\n\t{\n\t\tCStringW string(pUnicodeText->GetAsCString());\n\t\tpUnicodeText->Free();\n\n\t\tstring += _T(\"\\r\\n\");\n\n\t\tCOleDateTime now(COleDateTime::GetCurrentTime());\n\t\tstring += now.Format();\t\t\t\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1) * sizeof(wchar_t)));\n\n\t\tpUnicodeText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pAsciiText = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (pAsciiText != NULL)\n\t{\n\t\tCStringA string(pAsciiText->GetAsCStringA());\n\t\tpAsciiText->Free();\n\n\t\tstring += \"\\r\\n\\r\\n\";\n\n\t\tCOleDateTime now(COleDateTime::GetCurrentTime());\n\t\tstring += CTextConvert::UnicodeToAnsi(now.Format());\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpAsciiText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pRTFFormat = clip.m_Formats.FindFormatEx(theApp.m_RTFFormat);\n\tif (pRTFFormat != NULL)\n\t{\n\t\tCStringA string(pRTFFormat->GetAsCStringA());\n\n\t\tpRTFFormat->Free();\n\t\t\t\n\t\tint pos = string.ReverseFind('}');\n\t\tif (pos >= 0)\n\t\t{\n\t\t\tstring += _T(\"\\r\\n\\r\\n\");\n\n\t\t\tCOleDateTime now(COleDateTime::GetCurrentTime());\n\t\t\t\t\n\t\t\tCStringA insert;\n\t\t\tinsert.Format(\"\\\\par\\r\\n\\\\par\\r\\n%s\", CTextConvert::UnicodeToAnsi(now.Format()));\n\n\t\t\tint count = string.Insert(pos, insert);\n\t\t}\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpRTFFormat->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::TrimWhiteSpace(CClip &clip)\n{\n\tIClipFormat *pUnicodeText = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (pUnicodeText != NULL)\n\t{\t\t\n\t\tCStringW string(pUnicodeText->GetAsCString());\n\n\t\tpUnicodeText->Free();\n\n\t\tstring = string.Trim();\n\t\tstring = string.Trim(_T(\"\\t\"));\n\t\tstring = string.Trim(_T(\"\\r\"));\n\t\tstring = string.Trim(_T(\"\\n\"));\t\t\t\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1) * sizeof(wchar_t)));\n\n\t\tpUnicodeText->Data(hGlobal);\n\t}\n\n\tIClipFormat *pAsciiText = clip.m_Formats.FindFormatEx(CF_TEXT);\n\tif (pAsciiText != NULL)\n\t{\t\t\n\t\tCStringA string(pAsciiText->GetAsCStringA());\n\t\t\t\t\n\t\tpAsciiText->Free();\n\n\t\tstring = string.Trim();\n\t\tstring = string.Trim(\"\\t\");\n\t\tstring = string.Trim(\"\\r\");\n\t\tstring = string.Trim(\"\\n\");\n\n\t\tHGLOBAL hGlobal = NewGlobalP(string.GetBuffer(), ((string.GetLength() + 1)));\n\n\t\tpAsciiText->Data(hGlobal);\n\t}\n}\n\nvoid COleClipSource::SaveDittoFileDataToFile(CClip &clip)\n{\n\tCFileRecieve hDrpData;\n\tCClipFormat* pCF;\n\tint hDropIndex = -1;\n\tbool savedFile = false;\n\tINT_PTR\tcount = clip.m_Formats.GetSize();\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tpCF = &clip.m_Formats.ElementAt(i);\n\n\t\tif (pCF->m_cfType == theApp.m_DittoFileData)\n\t\t{\n\t\t\tIClipFormat *dittoFileData = &clip.m_Formats.ElementAt(i);\n\t\t\tif (dittoFileData == NULL) \n\t\t\t\tcontinue;\n\n\t\t\tHGLOBAL data = dittoFileData->Data();\n\t\t\tchar * stringData = (char *)GlobalLock(data);\n\n\t\t\t//original source is store in the first string ending in the null terminator\n\t\t\tCStringA src(stringData);\n\t\t\tstringData += src.GetLength() + 1;\n\n\t\t\tCStringA originalMd5(stringData);\n\t\t\tstringData += originalMd5.GetLength() + 1;\n\n\t\t\tint dataSize = (int)GlobalSize(data) - (src.GetLength() + 1) - (originalMd5.GetLength() + 1);\n\n\t\t\tCMd5 calcMd5;\n\t\t\tCStringA md5String = calcMd5.CalcMD5FromString(stringData, dataSize);\n\n\t\t\tCString unicodeFilePath = CTextConvert::Utf8ToUnicode(src);\n\n\t\t\tCString unicodeMd5 = CTextConvert::Utf8ToUnicode(md5String);\n\n\t\t\tLog(StrF(_T(\"Saving file contents from Ditto, original file: %s, size: %d, md5: %s\"), unicodeFilePath, dataSize, unicodeMd5));\n\n\t\t\tif (md5String != originalMd5)\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"MD5 ERROR, file: %s, original md5: %s, calc md5: %s\"), unicodeFilePath, originalMd5, md5String));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusing namespace nsPath;\n\t\t\tCPath path(unicodeFilePath);\n\t\t\tCString fileName = path.GetName();\n\n\t\t\tCString newFilePath = CGetSetOptions::GetPath(PATH_DRAG_FILES);\n\t\t\tnewFilePath += fileName;\n\n\t\t\tCFile f;\n\t\t\tif (f.Open(newFilePath, CFile::modeWrite | CFile::modeCreate))\n\t\t\t{\n\t\t\t\tf.Write(stringData, dataSize);\n\n\t\t\t\tf.Close();\n\n\t\t\t\tsavedFile = true;\n\t\t\t\thDrpData.AddFile(newFilePath);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"Error saving file: %s\"), unicodeFilePath));\n\t\t\t}\n\n\t\t}\n\t\telse if (pCF->m_cfType == CF_HDROP)\n\t\t{\n\t\t\thDropIndex = i;\n\t\t}\n\t}\n\t\n\tif (savedFile)\n\t{\n\t\tif (hDropIndex >= 0)\n\t\t{\n\t\t\tclip.m_Formats.RemoveAt(hDropIndex);\n\t\t}\n\n\t\tCClipFormat cf(CF_HDROP, hDrpData.CreateCF_HDROPBuffer());\n\t\tclip.m_Formats.Add(cf);\n\n\t\t//clip.m_Formats now owns the global data\n\t\tcf.m_autoDeleteData = false;\n\t}\n}\n\nvoid COleClipSource::Typoglycemia(CClip &clip)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\t\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tCString newString;\n\t\t\n\t\t\n\t\tCTokenizer token(cs, _T(' '));\n\t\tCString word;\n\n\t\twhile (token.Next(word))\n\t\t{\n\t\t\tif(word.GetLength() > 3)\n\t\t\t{\n\t\t\t\tint end = word.GetLength();\n\t\t\t\t\n\t\t\t\tfor (int i = end-1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tif(word[i] == _T('.') ||\n\t\t\t\t\t\tword[i] == _T('!') ||\n\t\t\t\t\t\tword[i] == _T('?'))\n\t\t\t\t\t{\n\t\t\t\t\t\tend--;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (end > 3)\n\t\t\t\t{\n\t\t\t\t\tstd::uniform_int_distribution<int> dist(1, end - 2);\n\t\t\t\t\tstd::random_device rd;\n\n\t\t\t\t\tfor (int i = 1; i < end - 1; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint newPos = dist(rd);\n\n\t\t\t\t\t\tCString cs;\n\t\t\t\t\t\tcs.Format(_T(\"pos: %d, rnd: %d\\r\\n\"), i, newPos);\n\t\t\t\t\t\tOutputDebugString(cs);\n\n\t\t\t\t\t\tTCHAR temp = word.GetAt(i);\n\t\t\t\t\t\tword.SetAt(i, word.GetAt(newPos));\n\t\t\t\t\t\tword.SetAt(newPos, temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewString += word;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewString += word;\n\t\t\t}\n\n\t\t\tnewString += _T(' ');\n\t\t}\n\n\t\t\n\t\tlong len = newString.GetLength();\n\t\tHGLOBAL hGlobal = NewGlobalP(newString.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n\n\t\n}\n\nINT_PTR COleClipSource::PutFormatOnClipboard(CClipFormats *pFormats)\n{\n\tLog(_T(\"Start of put format on clipboard\"));\n\n\tCClipFormat* pCF;\n\tINT_PTR\tcount = pFormats->GetSize();\n\tbool bDelayedRenderCF_HDROP = false;\n\tbool dittoFileData = false;\n\tINT_PTR i = 0;\n\n\t//see if the html format is in the list\n\t//if it is the list we will not paste CF_TEXT\n\tfor(i = 0; i < count; i++)\n\t{\n\t\tpCF = &pFormats->ElementAt(i);\n\n\t\tif(pCF->m_cfType == theApp.m_RemoteCF_HDROP)\n\t\t{\n\t\t\tbDelayedRenderCF_HDROP = true;\n\t\t}\n\n\t\tif (pCF->m_cfType == theApp.m_DittoFileData)\n\t\t{\n\t\t\tdittoFileData = true;\n\n\t\t\t//save file data\n\t\t\t//adjust hdrop\n\t\t}\n\t}\n\n\tfor(i = 0; i < count; i++)\n\t{\n\t\tpCF = &pFormats->ElementAt(i);\n\n\t\tif(bDelayedRenderCF_HDROP)\n\t\t{\n\t\t\tif(pCF->m_cfType == CF_HDROP)\n\t\t\t{\n\t\t\t\tLogSendRecieveInfo(\"Added delayed cf_hdrop to clipboard\");\n\t\t\t\tDelayRenderData(pCF->m_cfType);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tLog(StrF(_T(\"Setting clipboard type: %s to the clipboard\"), GetFormatName(pCF->m_cfType)));\n\n\t\tCacheGlobalData(pCF->m_cfType, pCF->m_hgData);\n\t\tpCF->m_hgData = 0; // OLE owns it now\n\t}\n\n\tpFormats->RemoveAll();\n\n\tm_bLoadedFormats = true;\n\n\tLog(_T(\"End of put format on clipboard\"));\n\n\treturn count;\n}  \n\nBOOL COleClipSource::OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal)\n{\n\tstatic bool bInHere = false;\n\n\tif(bInHere)\n\t{\n\t\treturn FALSE;\n\t}\n\tbInHere = true;\n\n\tHGLOBAL hData = NULL;\n\n\tCClipFormat *pFind = m_DelayRenderedFormats.FindFormat(lpFormatEtc->cfFormat);\n\n\tif(pFind)\n\t{\n\t\tif(pFind->m_hgData)\n\t\t{\n\t\t\thData = NewGlobalH(pFind->m_hgData, GlobalSize(pFind->m_hgData));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (m_pasteOptions.m_delayRenderLockout > 0 &&\n\t\t\t(GetTickCount() - m_pasteOptions.m_delayRenderLockout) < (DWORD)CGetSetOptions::GetDelayRenderLockout())\n\t\t{\n\t\t\tbInHere = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tLogSendRecieveInfo(\"Delayed Render, getting data from remote machine\");\n\n\t\tCClip clip;\n\n\t\tif(m_ClipIDs.GetCount() > 0)\n\t\t{\n\t\t\tclip.LoadFormats(m_ClipIDs[0]);\n\n\t\t\tCClipFormat *pDittoDelayCF_HDROP = clip.m_Formats.FindFormat(theApp.m_RemoteCF_HDROP);\n\t\t\tCClipFormat *pCF_HDROP = clip.m_Formats.FindFormat(CF_HDROP);\n\n\t\t\tif(pDittoDelayCF_HDROP && pCF_HDROP)\n\t\t\t{\n\t\t\t\tCDittoCF_HDROP *pData = (CDittoCF_HDROP*)GlobalLock(pDittoDelayCF_HDROP->m_hgData);\n\t\t\t\tif(pData)\n\t\t\t\t{\n\t\t\t\t\tCString csComputerName;\n\t\t\t\t\tCString csIP;\n\n\t\t\t\t\tcsIP = CTextConvert::Utf8ToUnicode(pData->m_cIP);\n\t\t\t\t\tcsComputerName = CTextConvert::Utf8ToUnicode(pData->m_cComputerName);\n\t\t\t\t\t\n\t\t\t\t\tGlobalUnlock(pDittoDelayCF_HDROP->m_hgData);\n\n\t\t\t\t\tCString ipPort = csIP;\n\t\t\t\t\tif (pData->respondPort > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tipPort.Format(_T(\"%s:%d\"), csIP, pData->respondPort);\n\t\t\t\t\t}\n\n\t\t\t\t\tCString namePort = csComputerName;\n\t\t\t\t\tif (pData->respondPort > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnamePort.Format(_T(\"%s:%d\"), csComputerName, pData->respondPort);\n\t\t\t\t\t}\n\n\t\t\t\t\tCClient cl;\n\t\t\t\t\thData = cl.RequestCopiedFiles(*pCF_HDROP, ipPort, namePort);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thData = m_ClipIDs.Render(lpFormatEtc->cfFormat);\n\n\t\t\t\tif (m_convertToHDROPOnDelayRender &&\n\t\t\t\t\thData == NULL && \n\t\t\t\t\tlpFormatEtc->cfFormat == CF_HDROP)\n\t\t\t\t{\n\t\t\t\t\thData = ConvertToFileDrop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Add to a cache of already rendered data\n\t\t//Windows seems to call this function multiple times\n\t\t//so only the first time do we need to go get the data\n\t\tHGLOBAL hCopy = NULL;\n\t\tif(hData)\n\t\t{\n\t\t\thCopy = NewGlobalH(hData, GlobalSize(hData));\n\t\t}\n\n\t\tCClipFormat format(lpFormatEtc->cfFormat, hCopy);\t\t\n\t\tm_DelayRenderedFormats.Add(format);\n\t\tformat.m_autoDeleteData = false; //owned by m_DelayRenderedFormats\n\t}\n\n\tBOOL bRet = FALSE;\n\tif(hData)\n\t{\n\t\t// if phGlobal is null, we can just give the allocated mem\n\t\t// else, our data must fit within the GlobalSize(*phGlobal)\n\t\tif(*phGlobal == 0)\n\t\t{\n\t\t\t*phGlobal = hData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSIZE_T len = min(::GlobalSize(*phGlobal), ::GlobalSize(hData));\n\t\t\tif(len)\n\t\t\t{\n\t\t\t\tCopyToGlobalHH(*phGlobal, hData, len);\n\t\t\t}\n\t\t\t::GlobalFree(hData);\n\t\t}\n\t\tbRet = TRUE;\n\t}\n\n\tbInHere = false;\n\n\treturn bRet;\n}\n\nHGLOBAL COleClipSource::ConvertToFileDrop()\n{\n\tCString path = CGetSetOptions::GetPath(PATH_DRAG_FILES);\t\n\tCreateDirectory(path, NULL);\n\n\tCFileRecieve fileList;\n\n\tint dragId = CGetSetOptions::GetDragId();\n\tint origDragId = dragId;\n\n\tauto customDragName = CGetSetOptions::GetTempDragFileName();\n\tif (customDragName != _T(\"\"))\n\t{\n\t\tdragId = 1;\n\t}\n\n\tfor (int i = 0; i < m_ClipIDs.GetCount(); i++)\n\t{\n\t\tCClip fileClip;\n\t\tfileClip.LoadFormats(m_ClipIDs[i]);\n\n\t\tCClipFormat *unicodeText = fileClip.m_Formats.FindFormat(CF_UNICODETEXT);\n\t\tif (unicodeText)\n\t\t{\n\t\t\tCString name = _T(\"text\");\n\t\t\tCString file;\n\t\t\tif (customDragName != _T(\"\"))\n\t\t\t{\n\t\t\t\tname = customDragName;\n\t\t\t\tfile.Format(_T(\"%s%s.txt\"), path, name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\t\t\t\n\t\t\t\tfile.Format(_T(\"%s%s_%d.txt\"), path, name, dragId++);\n\t\t\t}\n\n\t\t\tfileClip.WriteTextToFile(file, TRUE, FALSE, FALSE);\n\t\t\tfileList.AddFile(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tCClipFormat *asciiText = fileClip.m_Formats.FindFormat(CF_TEXT);\n\t\tif (asciiText)\n\t\t{\n\t\t\tCString name = _T(\"text\");\n\t\t\tCString file;\n\t\t\tif (customDragName != _T(\"\"))\n\t\t\t{\n\t\t\t\tname = customDragName;\n\t\t\t\tfile.Format(_T(\"%s%s.txt\"), path, name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfile.Format(_T(\"%s%s_%d.txt\"), path, name, dragId++);\n\t\t\t}\n\n\t\t\tfileClip.WriteTextToFile(file, FALSE, TRUE, FALSE);\n\t\t\tfileList.AddFile(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tCClipFormat *png = fileClip.m_Formats.FindFormat(theApp.m_PNG_Format);\n\t\tCClipFormat *bitmap = fileClip.m_Formats.FindFormat(CF_DIB);\n\t\tif (bitmap != NULL ||\n\t\t\tpng != NULL)\n\t\t{\n\t\t\tCString name = _T(\"image\");\n\t\t\tCString file;\n\t\t\tif (customDragName != _T(\"\"))\n\t\t\t{\n\t\t\t\tname = customDragName;\n\t\t\t\tfile.Format(_T(\"%s%s.png\"), path, name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfile.Format(_T(\"%s%s_%d.png\"), path, name, dragId++);\n\t\t\t}\n\n\t\t\tif (fileClip.WriteImageToFile(file))\n\t\t\t{\n\t\t\t\tfileList.AddFile(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(customDragName == _T(\"\") &&\n\t\tdragId != origDragId)\n\t{\n\t\tCGetSetOptions::SetDragId(dragId);\n\t}\n\n\tHGLOBAL hData = fileList.CreateCF_HDROPBuffer();\n\n\treturn hData;\n}\n\nvoid COleClipSource::Slugify(CClip &clip)\n{\n\tIClipFormat *unicodeTextFormat = clip.m_Formats.FindFormatEx(CF_UNICODETEXT);\n\tif (unicodeTextFormat != NULL)\n\t{\n\t\tCString cs(unicodeTextFormat->GetAsCString());\t\n\n\t\t//free the old text we are going to replace it below with an upper case version\n\t\tunicodeTextFormat->Free();\n\n\t\tCString newString = slugify(cs.GetString(), CGetSetOptions::GetSlugifySeparator().GetString()).c_str();\n\n\t\tlong len = newString.GetLength();\n\t\tHGLOBAL hGlobal = NewGlobalP(newString.GetBuffer(), ((len + 1) * sizeof(wchar_t)));\n\n\t\tunicodeTextFormat->Data(hGlobal);\n\t}\n}"
        },
        {
          "name": "OleClipSource.h",
          "type": "blob",
          "size": 1.2744140625,
          "content": "#pragma once\r\n\r\n#include \"ClipIds.h\"\r\n#include \"SpecialPasteOptions.h\"\r\n\r\n/*------------------------------------------------------------------*\\\r\n\tCOleClipSource\r\n\\*------------------------------------------------------------------*/\r\nclass COleClipSource : public COleDataSource\r\n{\r\n\t//DECLARE_DYNAMIC(COleClipSource)\r\n\r\npublic:\r\n\tCClipIDs\tm_ClipIDs;\r\n\tbool\t\tm_bLoadedFormats;\r\n\tCSpecialPasteOptions m_pasteOptions;\r\n\r\n\tCOleClipSource();\r\n\tvirtual ~COleClipSource();\r\n\r\n\tBOOL DoDelayRender();\r\n\tBOOL DoImmediateRender();\r\n\r\n\tvoid PlainTextFilter(CClip &clip);\r\n\r\n\tINT_PTR PutFormatOnClipboard(CClipFormats *pFormats);\r\n\r\npublic:\r\n\tvirtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);\r\n\r\nprotected:\r\n\tCClipFormats m_DelayRenderedFormats;\r\n\tbool m_convertToHDROPOnDelayRender;\r\n\r\n\tvoid DoUpperLowerCase(CClip &clip, bool upper);\r\n\tvoid Capitalize(CClip &clip);\r\n\tvoid SentenceCase(CClip &clip);\r\n\tvoid RemoveLineFeeds(CClip &clip);\r\n\tvoid AddLineFeeds(CClip &clip, int count);\r\n\tvoid Typoglycemia(CClip &clip);\r\n\tHGLOBAL ConvertToFileDrop();\r\n\tvoid AddDateTime(CClip &clip);\r\n\tvoid SaveDittoFileDataToFile(CClip &clip);\r\n\tvoid TrimWhiteSpace(CClip &clip);\r\n\tvoid Slugify(CClip &clip);\r\n\tvoid InvertCase(CClip &clip);\r\n\tvoid CamelCase(CClip& clip);\r\n\tvoid AsciiOnly(CClip& clip);\r\n};"
        },
        {
          "name": "OptionFriends.cpp",
          "type": "blob",
          "size": 7.2119140625,
          "content": "// OptionFriends.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"OptionFriends.h\"\n#include \"FriendDetails.h\"\n#include \"DimWnd.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define EMPTRY_STRING \"----\"\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionFriends property page\n\nIMPLEMENT_DYNCREATE(COptionFriends, CPropertyPage)\n\nCOptionFriends::COptionFriends() : CPropertyPage(COptionFriends::IDD)\n{\n\tm_csTitle = theApp.m_Language.GetString(\"FriendsTitle\", \"Friends\");\n\tm_psp.pszTitle = m_csTitle;\n\tm_psp.dwFlags |= PSP_USETITLE; \n\n\t//{{AFX_DATA_INIT(COptionFriends)\n\tm_PlaceOnClipboard = _T(\"\");\n\tm_csPassword = _T(\"\");\n\tm_csAdditionalPasswords = _T(\"\");\n\t//}}AFX_DATA_INIT\n}\n\nCOptionFriends::~COptionFriends()\n{\n}\n\nvoid COptionFriends::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(COptionFriends)\n\tDDX_Control(pDX, IDC_CHECK_DISABLE_FRIENDS, m_bDisableRecieve);\n\tDDX_Control(pDX, IDC_CHECK_LOG_SEND_RECIEVE, m_SendRecieve);\n\tDDX_Control(pDX, IDC_LIST, m_List);\n\tDDX_Text(pDX, IDC_EDIT_PLACE_ON_CLIPBOARD, m_PlaceOnClipboard);\n\tDDX_Text(pDX, IDC_EDIT_PASSWORD, m_csPassword);\n\tDDX_Text(pDX, IDC_EDIT_ADDITIONAL, m_csAdditionalPasswords);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(COptionFriends, CPropertyPage)\n\t//{{AFX_MSG_MAP(COptionFriends)\n\tON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)\n\tON_NOTIFY(LVN_KEYDOWN, IDC_LIST, OnKeydownList)\n\tON_BN_CLICKED(IDC_CHECK_DISABLE_FRIENDS, OnCheckDisableFriends)\n\t//}}AFX_MSG_MAP \nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionFriends message handlers\n\n\nBOOL COptionFriends::OnInitDialog() \n{\n\tCPropertyPage::OnInitDialog();\n\n\tm_pParent = (COptionsSheet *)GetParent();\n\t\n\tm_List.SetExtendedStyle(LVS_EX_FULLROWSELECT);\n\tInitListCtrlCols();\n\n\tInsertItems();\n\n\tm_SendRecieve.SetCheck(CGetSetOptions::GetLogSendReceiveErrors());\n\tm_bDisableRecieve.SetCheck(CGetSetOptions::GetDisableRecieve());\n\n\tm_PlaceOnClipboard = CGetSetOptions::m_csIPListToPutOnClipboard;\n\tm_csPassword = CGetSetOptions::m_csPassword;\n\tm_csAdditionalPasswords = CGetSetOptions::GetExtraNetworkPassword(false);\n\n\tif(CGetSetOptions::GetRequestFilesUsingIP())\n\t{\n\t\t::CheckDlgButton(m_hWnd, IDC_RADIO_USE_IP, BST_CHECKED);\n\t}\n\telse\n\t{\n\t\t::CheckDlgButton(m_hWnd, IDC_RADIO_USE_HOST_NAME, BST_CHECKED);\n\t}\n\n\tUpdateData(FALSE);\n\n\ttheApp.m_Language.UpdateOptionFriends(this);\n\t\t\n\treturn FALSE;\n}\n\nBOOL COptionFriends::OnApply() \n{\n\tCSendClients client;\n\tfor (int i = 0; i < MAX_SEND_CLIENTS; i++)\n\t{\n\t\tif(m_List.GetItemText(i, 1) == \"X\")\n\t\t\tclient.bSendAll = TRUE;\n\t\telse\n\t\t\tclient.bSendAll = FALSE;\n\n\t\tclient.csIP = m_List.GetItemText(i, 2);\n\t\tif(client.csIP == EMPTRY_STRING)\n\t\t\tclient.csIP = \"\";\n\t\t\n\t\tclient.csDescription = m_List.GetItemText(i, 3);\n\t\tif(client.csDescription == EMPTRY_STRING)\n\t\t\tclient.csDescription = \"\";\n\n\t\tCGetSetOptions::SetSendClients(client, i);\n\t}\n\n\tCGetSetOptions::SetNetworkPassword(m_csPassword);\n\tCGetSetOptions::SetLogSendReceiveErrors(m_SendRecieve.GetCheck());\n\n\tCGetSetOptions::SetDisableRecieve(m_bDisableRecieve.GetCheck());\n\ttheApp.StartStopServerThread();\n\n\tUpdateData();\n\n\tCGetSetOptions::SetListToPutOnClipboard(m_PlaceOnClipboard);\n\tCGetSetOptions::SetNetworkPassword(m_csPassword);\n\tCGetSetOptions::GetClientSendCount();\n\n\tCGetSetOptions::SetExtraNetworkPassword(m_csAdditionalPasswords);\n\t//get get to refill the array extra passwords\n\tCGetSetOptions::GetExtraNetworkPassword(true);\n\n\tif(::IsDlgButtonChecked(m_hWnd, IDC_RADIO_USE_IP) == BST_CHECKED)\n\t{\n\t\tCGetSetOptions::SetRequestFilesUsingIP(TRUE);\n\t}\n\telse if(::IsDlgButtonChecked(m_hWnd, IDC_RADIO_USE_HOST_NAME) == BST_CHECKED)\n\t{\n\t\tCGetSetOptions::SetRequestFilesUsingIP(FALSE);\n\t}\n\t\n\treturn CPropertyPage::OnApply();\n}\n\n\nvoid COptionFriends::InitListCtrlCols()\n{\n\t// Insert some columns\n\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_LEFT, 25);\n\n\tm_List.InsertColumn(1, theApp.m_Language.GetString(\"Send_All_Copies\", \"Send All Copies\"), LVCFMT_LEFT, 90);\n\tm_List.InsertColumn(2, theApp.m_Language.GetString(\"IP_Name\", \"IP/Name\"), LVCFMT_LEFT, 135);\n\tm_List.InsertColumn(3, theApp.m_Language.GetString(\"Descriptions\", \"Descriptions\"), LVCFMT_LEFT, 157);\n}\n\nvoid COptionFriends::InsertItems()\n{\n\t// Delete the current contents\n\tm_List.DeleteAllItems();\n\n\t// Use the LV_ITEM structure to insert the items\n\tLVITEM lvi;\n\tCString strItem;\n\tfor (int i = 0; i < MAX_SEND_CLIENTS; i++)\n\t{\n\t\t// Insert the first item\n\t\tlvi.mask =  LVIF_TEXT;\n\t\n\t\tlvi.iItem = i;\n\n//-------------------------------------------------------------------\n\n\t\tstrItem.Format(_T(\"%d\"), i+1);\n\n\t\tlvi.iSubItem = 0;\n\t\tlvi.pszText = (LPTSTR)(LPCTSTR)(strItem);\n\t\tm_List.InsertItem(&lvi);\n\n//-------------------------------------------------------------------\n\t\tif(CGetSetOptions::m_SendClients[i].bSendAll)\n\t\t\tstrItem = \"X\";\n\t\telse\n\t\t\tstrItem = EMPTRY_STRING;\n\n\t\tm_List.SetItemText(i, 1, strItem);\n\n//-------------------------------------------------------------------\n\n\t\tstrItem = CGetSetOptions::m_SendClients[i].csIP;\n\t\tif(CGetSetOptions::m_SendClients[i].csIP.GetLength() <= 0)\n\t\t{\n\t\t\tstrItem = EMPTRY_STRING;\n\t\t}\n\n\t\tm_List.SetItemText(i, 2, strItem);\n\n//-------------------------------------------------------------------\n\n\t\tstrItem = CGetSetOptions::m_SendClients[i].csDescription;\n\t\tif(CGetSetOptions::m_SendClients[i].csDescription.GetLength() <= 0)\n\t\t{\n\t\t\tstrItem = EMPTRY_STRING;\n\t\t}\n\t\t\n\t\tm_List.SetItemText(i, 3, strItem);\n\t}\n}\n\nvoid COptionFriends::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\tPOSITION pos = m_List.GetFirstSelectedItemPosition();\n\tif(pos)\n\t{\n\t\tint nItem = m_List.GetNextSelectedItem(pos);\n\n\t\tEditItem(nItem);\n\t}\n\t\n\t*pResult = 0;\n}\n\nBOOL COptionFriends::EditItem(int nItem)\n{\n\tCDimWnd dim(this->GetParent());\n\n\tCFriendDetails dlg(this);\n\n\tif(m_List.GetItemText(nItem, 1) == \"X\")\n\t\tdlg.m_checkSendAll = TRUE;\n\telse\n\t\tdlg.m_checkSendAll = FALSE;\n\n\tdlg.m_csIP = m_List.GetItemText(nItem, 2);\n\tif(dlg.m_csIP == EMPTRY_STRING)\n\t\tdlg.m_csIP = \"\";\n\tdlg.m_csDescription = m_List.GetItemText(nItem, 3);\n\tif(dlg.m_csDescription == EMPTRY_STRING)\n\t\tdlg.m_csDescription = \"\";\n\n\tif(dlg.DoModal() == IDOK)\n\t{\n\t\tif(dlg.m_checkSendAll)\n\t\t{\n\t\t\tm_List.SetItemText(nItem, 1, _T(\"X\"));\n\t\t}\n\t\telse\n\t\t\tm_List.SetItemText(nItem, 1, _T(\"\"));\n\n\t\tm_List.SetItemText(nItem, 2, dlg.m_csIP);\n\t\tm_List.SetItemText(nItem, 3, dlg.m_csDescription);\n\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nvoid COptionFriends::OnKeydownList(NMHDR* pNMHDR, LRESULT* pResult) \n{\n\tLV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;\n\n\tswitch (pLVKeyDow->wVKey)\n\t{\n\tcase VK_DELETE:\n\t\t{\n\t\t\tPOSITION pos = m_List.GetFirstSelectedItemPosition();\n\t\t\tif(pos)\n\t\t\t{\n\t\t\t\tint nItem = m_List.GetNextSelectedItem(pos);\n\t\t\t\tm_List.SetItemText(nItem, 1, _T(EMPTRY_STRING));\n\t\t\t\tm_List.SetItemText(nItem, 2, _T(EMPTRY_STRING));\n\t\t\t\tm_List.SetItemText(nItem, 3, _T(EMPTRY_STRING));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VK_RETURN:\n\t\t{\n\t\t\tPOSITION pos = m_List.GetFirstSelectedItemPosition();\n\t\t\tif(pos)\n\t\t\t{\n\t\t\t\tint nItem = m_List.GetNextSelectedItem(pos);\n\t\t\t\tEditItem(nItem);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t\n\t\n\t*pResult = 0;\n}\n\nvoid COptionFriends::OnCheckDisableFriends() \n{\n\tif(m_bDisableRecieve.GetCheck() == BST_CHECKED)\n\t\tGetDlgItem(IDC_EDIT_PLACE_ON_CLIPBOARD)->EnableWindow(FALSE);\n\telse\n\t\tGetDlgItem(IDC_EDIT_PLACE_ON_CLIPBOARD)->EnableWindow(TRUE);\n}\n"
        },
        {
          "name": "OptionFriends.h",
          "type": "blob",
          "size": 1.6474609375,
          "content": "#if !defined(AFX_OPTIONFRIENDS_H__E44847C3_54CA_4053_9647_349405B64DF9__INCLUDED_)\n#define AFX_OPTIONFRIENDS_H__E44847C3_54CA_4053_9647_349405B64DF9__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// OptionFriends.h : header file\n//\n#include \"OptionsSheet.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionFriends dialog\n\nclass COptionFriends : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(COptionFriends)\n\n// Construction\npublic:\n\tCOptionFriends();\n\t~COptionFriends();\n\n// Dialog Data\n\t//{{AFX_DATA(COptionFriends)\n\tenum { IDD = IDD_OPTIONS_FRIENDS };\n\tCButton\tm_bDisableRecieve;\n\tCButton\tm_SendRecieve;\n\tCListCtrl\tm_List;\n\tCString\tm_PlaceOnClipboard;\n\tCString\tm_csPassword;\n\tCString\tm_csAdditionalPasswords;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generate virtual function overrides\n\t//{{AFX_VIRTUAL(COptionFriends)\n\tpublic:\n\tvirtual BOOL OnApply();\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\tvoid InitListCtrlCols();\n\tvoid InsertItems();\n\tBOOL EditItem(int nItem);\n\n\tCString m_csTitle;\n\tCOptionsSheet *m_pParent;\n\t\n\t// Generated message map functions\n\t//{{AFX_MSG(COptionFriends)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);\n\tafx_msg void OnKeydownList(NMHDR* pNMHDR, LRESULT* pResult);\n\tafx_msg void OnCheckDisableFriends();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_OPTIONFRIENDS_H__E44847C3_54CA_4053_9647_349405B64DF9__INCLUDED_)\n"
        },
        {
          "name": "Options.cpp",
          "type": "blob",
          "size": 75.6044921875,
          "content": "#include \"stdafx.h\"\r\n#include \"Options.h\"\r\n#include \"AlphaBlend.h\"\r\n#include \"Misc.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"sqlite\\CppSQLite3.h\"\r\n#include \"Path.h\"\r\n#include \"CP_Main.h\"\r\n#include \"ActionEnums.h\"\r\n#include \"Shared/Tokenizer.h\"\r\n#include <set>\r\n#include <Wincrypt.h>\r\n\r\nusing namespace nsPath;\r\n\r\nUINT WritePrivateProfileInt(LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nValue, LPCTSTR lpFileName)\r\n{\r\n\t// Locals\r\n\tTCHAR\tszBuff[25];\r\n\r\n\t// Format\r\n\tSPRINTF(szBuff, _T(\"%d\"), nValue);\r\n\r\n\t// Write\r\n\treturn WritePrivateProfileString(lpAppName, lpKeyName, szBuff, lpFileName);\r\n}\r\n\r\nlong CGetSetOptions::m_nLinesPerRow;\r\nBOOL CGetSetOptions::m_bUseCtrlNumAccel;\r\nBOOL CGetSetOptions::m_bAllowDuplicates;\r\nBOOL CGetSetOptions::m_bUpdateTimeOnPaste;\r\nBOOL CGetSetOptions::m_bSaveMultiPaste;\r\nBOOL CGetSetOptions::m_bShowPersistent;\r\nlong CGetSetOptions::m_bDescTextSize;\r\nBOOL CGetSetOptions::m_bDescShowLeadingWhiteSpace;\r\nBOOL CGetSetOptions::m_bAllwaysShowDescription;\r\nlong CGetSetOptions::m_bDoubleClickingOnCaptionDoes;\r\nBOOL CGetSetOptions::m_bPrompForNewGroupName;\r\nBOOL CGetSetOptions::m_bSendPasteOnFirstTenHotKeys;\r\nCSendClients CGetSetOptions::m_SendClients[MAX_SEND_CLIENTS];\r\nlong CGetSetOptions::m_lAutoSendClientCount;\r\nCString CGetSetOptions::m_csIPListToPutOnClipboard;\r\nBOOL CGetSetOptions::m_bLogSendReceiveErrors;\r\nBOOL CGetSetOptions::m_HideDittoOnHotKeyIfAlreadyShown;\r\nlong CGetSetOptions::m_lPort;\r\nBOOL CGetSetOptions::m_bDrawThumbnail;\r\nBOOL CGetSetOptions::m_bDrawCopiedColorCode;\r\nBOOL CGetSetOptions::m_centerWindowBelowCursorOrCaret;\r\nBOOL CGetSetOptions::m_bFastThumbnailMode;\r\nCStringA CGetSetOptions::m_csPassword;\r\nBOOL CGetSetOptions::m_bDrawRTF;\r\nBOOL CGetSetOptions::m_bMultiPasteReverse;\r\nCString CGetSetOptions::m_csPlaySoundOnCopy;\r\nCStringArray CGetSetOptions::m_csNetworkPasswordArray;\r\nBOOL CGetSetOptions::m_bSendPasteMessageAfterSelection;\r\nBOOL CGetSetOptions::m_bFindAsYouType;\r\nBOOL CGetSetOptions::m_bEnsureEntireWindowCanBeSeen;\r\nBOOL CGetSetOptions::m_bShowAllClipsInMainList;\r\nlong CGetSetOptions::m_lMaxClipSizeInBytes;\r\nDWORD CGetSetOptions::m_dwSaveClipDelay;\r\nlong CGetSetOptions::m_lProcessDrawClipboardDelay;\r\nBOOL CGetSetOptions::m_bEnableDebugLogging;\r\nBOOL CGetSetOptions::m_bEnsureConnectToClipboard;\r\nBOOL CGetSetOptions::m_outputDebugStringLogging;\r\nbool CGetSetOptions::m_bInConversion = false;\r\nbool CGetSetOptions::m_bFromIni = false;\r\nbool CGetSetOptions::m_portable = false;\r\nbool CGetSetOptions::m_windowsApp = false;\r\nbool CGetSetOptions::m_chocolateyApp = false;\r\nCString CGetSetOptions::m_csIniFileName;\r\n__int64 CGetSetOptions::nLastDbWriteTime = 0;\r\nCTheme CGetSetOptions::m_Theme;\r\nBOOL CGetSetOptions::m_showScrollBar = false;\r\nBOOL CGetSetOptions::m_bShowAlwaysOnTopWarning = TRUE;\r\nCRegExFilterHelper CGetSetOptions::m_regexHelper;\r\nCString CGetSetOptions::m_ignoreAnnoyingCFDIB = \"\";\r\nCChaiScriptXml CGetSetOptions::m_copyScripts;\r\nCChaiScriptXml CGetSetOptions::m_pasteScripts;\r\nlong CGetSetOptions::m_tooltipTimeout;\r\nBOOL CGetSetOptions::m_cleanRTFBeforeDrawing = TRUE;\r\nint CGetSetOptions::m_doubleKeyStrokeTimeout = 350;\r\nint CGetSetOptions::m_firstTenHotKeysStart = 1;\r\nint CGetSetOptions::m_firstTenHotKeysFontSize = 5;\r\nBOOL CGetSetOptions::m_moveSelectionOnOpenHotkey = TRUE;\r\nBOOL CGetSetOptions::m_allowBackToBackDuplicates = FALSE;\r\nBOOL CGetSetOptions::m_maintainSearchView = FALSE;\r\nCString CGetSetOptions::m_tempDragFileName = \"\";\r\nCTime CGetSetOptions::m_tempDragFileNameSetTime;\r\nBOOL CGetSetOptions::m_refreshViewAfterPasting = TRUE;\r\nBOOL CGetSetOptions::m_supportAllTypes = FALSE;\r\n\r\n\r\nCGetSetOptions::CGetSetOptions()\r\n{\r\n\t//DATA_BLOB DataIn;\r\n\t//DATA_BLOB DataOut;\r\n\t//DATA_BLOB DataVerify;\r\n\t//BYTE* pbDataInput = (BYTE*)\"Hello world of data protection.\";\r\n\t//DWORD cbDataInput = strlen((char*)pbDataInput) + 1;\r\n\t//DataIn.pbData = pbDataInput;\r\n\t//DataIn.cbData = cbDataInput;\r\n\t//CRYPTPROTECT_PROMPTSTRUCT PromptStruct;\r\n\t//LPWSTR pDescrOut = NULL;\r\n\r\n\t//CRYPTPROTECT_LOCAL_MACHINE\r\n\r\n\t////-------------------------------------------------------------------\r\n\t////  Begin processing.\r\n\r\n\t//printf(\"The data to be encrypted is: %s\\n\", pbDataInput);\r\n\r\n\t////-------------------------------------------------------------------\r\n\t////  Initialize PromptStruct.\r\n\r\n\t////ZeroMemory(&PromptStruct, sizeof(PromptStruct));\r\n\t////PromptStruct.cbSize = sizeof(PromptStruct);\r\n\t////PromptStruct.dwPromptFlags = CRYPTPROTECT_PROMPT_ON_PROTECT;\r\n\t////PromptStruct.szPrompt = L\"This is a user prompt.\";\r\n\r\n\t////-------------------------------------------------------------------\r\n\t////  Begin protect phase.\r\n\r\n\t//if (CryptProtectData(\r\n\t//\t&DataIn,\r\n\t//\tL\"This is the description string.\", // A description string. \r\n\t//\tNULL,                               // Optional entropy\r\n\t//\t// not used.\r\n\t//\tNULL,                               // Reserved.\r\n\t//\tNULL,                      // Pass a PromptStruct.\r\n\t//\t0,\r\n\t//\t&DataOut))\r\n\t//{\r\n\t//\tprintf(\"The encryption phase worked. \\n\");\r\n\t//}\r\n\t//else\r\n\t//{\r\n\t//\t//MyHandleError(\"Encryption error!\");\r\n\t//}\r\n\r\n\t//if (CryptUnprotectData(\r\n\t//\t&DataOut,\r\n\t//\t&pDescrOut,\r\n\t//\tNULL,                 // Optional entropy\r\n\t//\tNULL,                 // Reserved\r\n\t//\tNULL,        // Optional PromptStruct\r\n\t//\t0,\r\n\t//\t&DataVerify))\r\n\t//{\r\n\t//\tprintf(\"The decrypted data is: %s\\n\", DataVerify.pbData);\r\n\t//\tprintf(\"The description of the data was: %S\\n\", pDescrOut);\r\n\t//}\r\n\t//else\r\n\t//{\r\n\t//\t//MyHandleError(\"Decryption error!\");\r\n\t//}\r\n\t////-------------------------------------------------------------------\r\n\t//// At this point, memcmp could be used to compare DataIn.pbData and \r\n\t//// DataVerify.pbDate for equality. If the two functions worked\r\n\t//// correctly, the two byte strings are identical. \r\n\r\n\t////-------------------------------------------------------------------\r\n\t////  Clean up.\r\n\r\n\t//LocalFree(pDescrOut);\r\n\t//LocalFree(DataOut.pbData);\r\n\t//LocalFree(DataVerify.pbData);\r\n // End of main\r\n}\r\n\r\nCGetSetOptions::~CGetSetOptions()\r\n{\r\n\r\n}\r\n\r\nvoid CGetSetOptions::LoadSettings()\r\n{\r\n\tCString exeDir = CGetSetOptions::GetExeFileName();\r\n\texeDir = GetFilePath(exeDir);\r\n\tFIX_CSTRING_PATH(exeDir);\r\n\r\n\tCString windowsAppFile = exeDir + _T(\"WindowsApp\");\r\n\tCString chocolateyAppFile = exeDir + _T(\"chocolatey\");\r\n\tif (FileExists(windowsAppFile))\r\n\t{\r\n\t\tm_windowsApp = true;\r\n\t\tm_bFromIni = true;\r\n\t\t//always use the ini file in the app data folder for windows store\r\n\t\tm_csIniFileName = GetIniFileName(false);\r\n\t}\r\n\telse if (FileExists(chocolateyAppFile))\r\n\t{\r\n\t\tm_chocolateyApp = true;\r\n\t\tm_bFromIni = true;\r\n\t\t//always use the ini file in the app data folder for chocolatey portable\r\n\t\tm_csIniFileName = GetIniFileName(false);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_csIniFileName = GetIniFileName(true);\r\n\r\n\t\tCString portable = GetFilePath(m_csIniFileName);\r\n\t\tportable += _T(\"portable\");\r\n\t\tif (FileExists(portable))\r\n\t\t{\r\n\t\t\tm_portable = true;\r\n\t\t}\r\n\r\n\t\t//first check if ini file is in app directory\r\n\t\tif (m_portable || FileExists(m_csIniFileName))\r\n\t\t{\r\n\t\t\tm_bFromIni = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//next check if it's in app data\r\n\t\t\tm_csIniFileName = GetIniFileName(false);\r\n\t\t\tif (FileExists(m_csIniFileName))\r\n\t\t\t{\r\n\t\t\t\tm_bFromIni = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif(m_bFromIni)\r\n\t{\r\n\t\tCString csPath = GetFilePath(m_csIniFileName);\r\n\t\tif(FileExists(csPath) == FALSE)\r\n\t\t\tCreateDirectory(csPath, NULL);\r\n\r\n\t\t//create the ini file as unicode, this way we can save unicode string to the ini file\r\n\t\t//http://www.codeproject.com/Articles/9071/Using-Unicode-in-INI-files\r\n\t\tCreateIniFile(m_csIniFileName);\r\n\t}\r\n\r\n\t/*CString cs = GetDBPath();\r\n\tSetDBPath(_T(\"some path\"));\r\n\tCString cs2 = GetDBPath();*/\r\n\r\n\r\n\tGetSetCurrentDirectory();\r\n\r\n\t//First time we run, set some defaults\r\n\tif (GetDBPath() == _T(\"\") &&\r\n\t\tGetTotalCopyCount() == 0)\r\n\t{\r\n\t\tSetCheckForMaxEntries(TRUE);\r\n\t\tSetSimpleTextSearch(TRUE);\r\n\t}\t\r\n\r\n\tm_nLinesPerRow = GetLinesPerRow();\r\n\tm_bUseCtrlNumAccel = GetUseCtrlNumForFirstTenHotKeys();\r\n\tm_bAllowDuplicates = GetAllowDuplicates();\r\n\tm_bUpdateTimeOnPaste = GetUpdateTimeOnPaste();\r\n\tm_bSaveMultiPaste = GetSaveMultiPaste();\r\n\tm_bShowPersistent = GetShowPersistent();\r\n\tm_bDescTextSize = GetDescTextSize();\r\n\tm_bDescShowLeadingWhiteSpace = GetDescShowLeadingWhiteSpace();\r\n\tm_bAllwaysShowDescription = GetAllwaysShowDescription();\r\n\tm_bDoubleClickingOnCaptionDoes = GetDoubleClickingOnCaptionDoes();\r\n\tm_bPrompForNewGroupName = GetPrompForNewGroupName();\r\n\tm_bSendPasteOnFirstTenHotKeys = GetSendPasteOnFirstTenHotKeys();\r\n\tm_csIPListToPutOnClipboard = GetListToPutOnClipboard();\r\n\tm_bLogSendReceiveErrors = GetLogSendReceiveErrors();\r\n\tm_HideDittoOnHotKeyIfAlreadyShown = GetHideDittoOnHotKeyIfAlreadyShown();\r\n\tm_lPort = GetPort();\r\n\tm_bDrawThumbnail = GetDrawThumbnail();\r\n\tm_bDrawCopiedColorCode = GetDrawCopiedColorCode();\r\n\tm_centerWindowBelowCursorOrCaret = GetCenterWindowBelowCursorOrCaret();\r\n\tm_bFastThumbnailMode = GetFastThumbnailMode();\r\n\tm_csPassword = GetNetworkPassword();\r\n\tm_bDrawRTF = GetDrawRTF();\r\n\tm_bMultiPasteReverse = GetMultiPasteReverse();\r\n\tm_csPlaySoundOnCopy = GetPlaySoundOnCopy();\r\n\tm_bSendPasteMessageAfterSelection = GetSendPasteAfterSelection();\r\n\tm_bFindAsYouType = GetFindAsYouType();\r\n\tm_bEnsureEntireWindowCanBeSeen = GetEnsureEntireWindowCanBeSeen();\r\n\tm_bShowAllClipsInMainList = GetShowAllClipsInMainList();\r\n\tm_lMaxClipSizeInBytes = GetMaxClipSizeInBytes();\r\n\tm_dwSaveClipDelay = GetSaveClipDelay();\r\n\tm_lProcessDrawClipboardDelay = GetProcessDrawClipboardDelay();\r\n\tm_bEnableDebugLogging = GetEnableDebugLogging();\r\n\tm_outputDebugStringLogging = GetEnableOutputDebugStringLogging();\r\n\tm_bEnsureConnectToClipboard = GetEnsureConnectToClipboard();\r\n\tm_showScrollBar = GetShowScrollBar();\r\n\tm_bShowAlwaysOnTopWarning = GetShowAlwaysOnTopWarning();\r\n\tm_ignoreAnnoyingCFDIB = GetIgnoreAnnoyingCFDIB();\r\n\tm_doubleKeyStrokeTimeout = GetDoubleKeyStrokeTimeout();\r\n\tm_firstTenHotKeysStart = GetFirstTenHotKeysStart();\r\n\tm_firstTenHotKeysFontSize = GetFirstTenHotKeysFontSize();\r\n\tm_moveSelectionOnOpenHotkey = GetMoveSelectionOnOpenHotkey();\r\n\tm_allowBackToBackDuplicates = GetAllowBackToBackDuplicates();\r\n\tm_maintainSearchView = GetMaintainSearchView();\r\n\r\n\tGetExtraNetworkPassword(true);\r\n\r\n\tfor(int i = 0; i < MAX_SEND_CLIENTS; i++)\r\n\t{\r\n\t\tGetSendClients(i);\r\n\t}\r\n\r\n\tfor (int i = 0; i < MAX_REGEX_FILTERS; i++)\r\n\t{\r\n\t\tCRegExFilterData data;\r\n\t\tdata.m_regEx = GetRegexFilter(i);\r\n\t\tdata.m_processFilters = GetRegexFilterByProcessName(i);\r\n\t\tm_regexHelper.Add(i, data);\r\n\t}\r\n\r\n\tGetClientSendCount();\r\n\r\n\tm_Theme.Load(GetTheme());\r\n\r\n\tm_copyScripts.Load(GetCopyScriptsXml());\r\n\tif (m_copyScripts.m_assignedGuidOnLoad)\r\n\t{\r\n\t\tSetCopyScriptsXml(m_copyScripts.Save());\r\n\t}\r\n\tm_pasteScripts.Load(GetPasteScriptsXml());\r\n\tif (m_pasteScripts.m_assignedGuidOnLoad)\r\n\t{\r\n\t\tSetPasteScriptsXml(m_pasteScripts.Save());\r\n\t}\r\n\r\n\tm_tooltipTimeout = GetToolTipTimeout();\r\n}\r\n\r\nvoid CGetSetOptions::CreateIniFile(CString path)\r\n{\r\n\tif (!::PathFileExists(path))\r\n\t{\r\n\t\t// UTF16-LE BOM(FFFE)\r\n\t\tWORD wBOM = 0xFEFF;\r\n\t\tDWORD NumberOfBytesWritten;\r\n\r\n\t\tHANDLE hFile = ::CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\t\t::WriteFile(hFile, &wBOM, sizeof(WORD), &NumberOfBytesWritten, NULL);\r\n\t\r\n\t\t//LPTSTR pszSectionB = _T(\"[StringTable]\"); // section name with bracket \r\n\t\t//::WriteFile(hFile, pszSectionB, (_tcslen(pszSectionB) + 1)*(sizeof(TCHAR)), &NumberOfBytesWritten, NULL);\r\n\r\n\t\t::CloseHandle(hFile);\r\n\t}\r\n}\r\n\r\nvoid CGetSetOptions::ConverSettingsToIni()\r\n{\r\n\tm_bInConversion = true;\r\n\r\n\tCSize sz;\r\n\tCPoint pt;\r\n\r\n\tGetQuickPasteSize(sz);\r\n\tSetQuickPasteSize(sz);\r\n\t\r\n\tGetQuickPastePoint(pt);\r\n\tSetQuickPastePoint(pt);\r\n\r\n\tSetShowIconInSysTray(GetShowIconInSysTray());\r\n\tSetRunOnStartUp(GetRunOnStartUp());\r\n\tSetEnableTransparency(GetEnableTransparency());\r\n\tSetTransparencyPercent(GetTransparencyPercent());\r\n\tSetLinesPerRow(GetLinesPerRow());\r\n\tSetQuickPastePosition(GetQuickPastePosition());\r\n\tSetCopyGap(GetCopyGap());\r\n\tSetDBPath(GetDBPath());\r\n\tSetCheckForMaxEntries(GetCheckForMaxEntries());\r\n\tSetCheckForExpiredEntries(GetCheckForExpiredEntries());\r\n\tSetMaxEntries(GetMaxEntries());\r\n\tSetExpiredEntries(GetExpiredEntries());\r\n\tSetTripCopyCount(GetTripCopyCount());\r\n\tSetTripPasteCount(GetTripPasteCount());\r\n\tSetTripDate(GetTripDate());\r\n\tSetTotalCopyCount(GetTotalCopyCount());\r\n\tSetTotalPasteCount(GetTotalPasteCount());\r\n\tSetTotalDate(GetTotalDate());\r\n\tSetUpdateFilePath(GetUpdateFilePath());\r\n\tSetUpdateInstallPath(GetUpdateInstallPath());\t\r\n\tSetLastUpdate(GetLastUpdate());\r\n\tSetCheckForUpdates(GetCheckForUpdates());\r\n\tSetUseCtrlNumForFirstTenHotKeys(GetUseCtrlNumForFirstTenHotKeys());\r\n\tSetAllowDuplicates(GetAllowDuplicates());\r\n\tSetUpdateTimeOnPaste(GetUpdateTimeOnPaste());\r\n\tSetSaveMultiPaste(GetSaveMultiPaste());\r\n\tSetShowPersistent(GetShowPersistent());\r\n\tSetShowTextForFirstTenHotKeys(GetShowTextForFirstTenHotKeys());\r\n\tSetMainHWND(GetMainHWND());\r\n\tSetCaptionPos(GetCaptionPos());\r\n\tSetAutoHide(GetAutoHide());\r\n\tSetDescTextSize(GetDescTextSize());\r\n\tSetDescShowLeadingWhiteSpace(GetDescShowLeadingWhiteSpace());\r\n\tSetAllwaysShowDescription(GetAllwaysShowDescription());\r\n\tSetDoubleClickingOnCaptionDoes(GetDoubleClickingOnCaptionDoes());\r\n\tSetPrompForNewGroupName(GetPrompForNewGroupName());\r\n\tSetSendPasteOnFirstTenHotKeys(GetSendPasteOnFirstTenHotKeys());\r\n\r\n\tfor(int i = 0; i < MAX_SEND_CLIENTS; i++)\r\n\t{\r\n\t\tGetSendClients(i);\r\n\t\tSetSendClients(m_SendClients[i], i);\r\n\t}\r\n\r\n\tSetListToPutOnClipboard(GetListToPutOnClipboard());\r\n\tSetLogSendReceiveErrors(GetLogSendReceiveErrors());\r\n\tSetHideDittoOnHotKeyIfAlreadyShown(GetHideDittoOnHotKeyIfAlreadyShown());\r\n\tSetPort(GetPort());\r\n\tSetDisableRecieve(GetDisableRecieve());\r\n\r\n\tLOGFONT font;\r\n\tGetFont(font);\r\n\tSetFont(font);\r\n\r\n\tSetDrawThumbnail(GetDrawThumbnail());\t\r\n\r\n\tCStringA PassA = GetNetworkPassword();\r\n\tCString PassW = PassA;\r\n\tSetNetworkPassword(PassW);\r\n\r\n\tSetDrawRTF(GetDrawRTF());\r\n\tSetMultiPasteReverse(GetMultiPasteReverse());\r\n\tSetPlaySoundOnCopy(GetPlaySoundOnCopy());\r\n\tSetSendPasteAfterSelection(GetSendPasteAfterSelection());\r\n\tSetFindAsYouType(GetFindAsYouType());\r\n\tSetEnsureEntireWindowCanBeSeen(GetEnsureEntireWindowCanBeSeen());\r\n\tSetShowAllClipsInMainList(GetShowAllClipsInMainList());\r\n\tSetExtraNetworkPassword(GetExtraNetworkPassword(false));\r\n\tSetMaxClipSizeInBytes(GetMaxClipSizeInBytes());\r\n\tSetLanguageFile(GetLanguageFile());\r\n\tSetSaveClipDelay(GetSaveClipDelay());\r\n\tSetProcessDrawClipboardDelay(GetProcessDrawClipboardDelay());\r\n\tSetEnableDebugLogging(GetEnableDebugLogging());\r\n\tSetEnsureConnectToClipboard(GetEnsureConnectToClipboard());\r\n\tSetPromptWhenDeletingClips(GetPromptWhenDeletingClips());\r\n\tSetLastImportDir(GetLastImportDir());\r\n\tSetLastExportDir(GetLastExportDir());\r\n\tSetUpdateDescWhenSavingClip(GetUpdateDescWhenSavingClip());\r\n\r\n\tm_bInConversion = false;\r\n}\r\n\r\nCString CGetSetOptions::GetIniFileName(bool bLocalIniFile)\r\n{\r\n\tCString csPath = _T(\"c:\\\\program files\\\\Ditto\\\\\");\r\n\t\r\n\tif(bLocalIniFile)\r\n\t{\r\n\t\tcsPath = GetFilePath(GetExeFileName());\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcsPath = GetAppDataPath();\r\n\t}\r\n\r\n\tcsPath += \"Ditto.Settings\";\r\n\r\n\treturn csPath;\r\n}\r\n\r\nCString CGetSetOptions::GetAppDataPath()\r\n{\r\n\tCString csPath;\r\n\tLPMALLOC pMalloc;\r\n\r\n\tif (GetIsWindowsApp())\r\n\t{\r\n\t\tif (SUCCEEDED(::SHGetMalloc(&pMalloc)))\r\n\t\t{\r\n\t\t\tLPITEMIDLIST pidlPrograms;\r\n\r\n\t\t\tSHGetSpecialFolderLocation(NULL, CSIDL_LOCAL_APPDATA, &pidlPrograms);\r\n\r\n\t\t\tTCHAR string[MAX_PATH];\r\n\t\t\tSHGetPathFromIDList(pidlPrograms, string);\r\n\r\n\t\t\tpMalloc->Free(pidlPrograms);\r\n\t\t\tpMalloc->Release();\r\n\r\n\t\t\tcsPath = string;\r\n\t\t}\r\n\t\tFIX_CSTRING_PATH(csPath);\r\n\t\tcsPath += \"Ditto_WindowsApp\\\\\";\r\n\t}\r\n\telse if (GetIsChocolateyApp())\r\n\t{\r\n\t\tif (SUCCEEDED(::SHGetMalloc(&pMalloc)))\r\n\t\t{\r\n\t\t\tLPITEMIDLIST pidlPrograms;\r\n\r\n\t\t\tSHGetSpecialFolderLocation(NULL, CSIDL_LOCAL_APPDATA, &pidlPrograms);\r\n\r\n\t\t\tTCHAR string[MAX_PATH];\r\n\t\t\tSHGetPathFromIDList(pidlPrograms, string);\r\n\r\n\t\t\tpMalloc->Free(pidlPrograms);\r\n\t\t\tpMalloc->Release();\r\n\r\n\t\t\tcsPath = string;\r\n\t\t}\r\n\t\tFIX_CSTRING_PATH(csPath);\r\n\t\tcsPath += \"Ditto_ChocolateyApp\\\\\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (SUCCEEDED(::SHGetMalloc(&pMalloc)))\r\n\t\t{\r\n\t\t\tLPITEMIDLIST pidlPrograms;\r\n\r\n\t\t\tSHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidlPrograms);\r\n\r\n\t\t\tTCHAR string[MAX_PATH];\r\n\t\t\tSHGetPathFromIDList(pidlPrograms, string);\r\n\r\n\t\t\tpMalloc->Free(pidlPrograms);\r\n\t\t\tpMalloc->Release();\r\n\r\n\t\t\tcsPath = string;\r\n\t\t}\r\n\t\tFIX_CSTRING_PATH(csPath);\r\n\t\tcsPath += \"Ditto\\\\\";\r\n\t}\r\n\r\n\treturn csPath;\r\n}\r\n\r\nCString CGetSetOptions::GetTempFilePath()\r\n{\r\n\tCString csPath;\r\n\r\n\twchar_t wchPath[MAX_PATH];\r\n\tif (GetTempPathW(MAX_PATH, wchPath))\r\n\t{\r\n\t\tcsPath = wchPath;\r\n\t\tcsPath += _T(\"Ditto\\\\\");\r\n\t\tCreateDirectory(csPath, NULL);\r\n\t}\r\n\r\n\treturn csPath;\r\n}\r\n\r\nlong CGetSetOptions::GetResolutionProfileLong(CString csName, long lDefaultValue, CString csNewPath)\r\n{\r\n\tCString resName;\r\n\tresName.Format(_T(\"(%dx%d)_%s\"), GetScreenWidth(), GetScreenHeight(), csName);\r\n\r\n\tlong value = GetProfileLong(resName, INT_MIN, csNewPath);\r\n\r\n\tif(value == INT_MIN)\r\n\t{\r\n\t\tvalue = GetProfileLong(csName, lDefaultValue, csNewPath);\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\nBOOL CGetSetOptions::SetResolutionProfileLong(CString csName, long lValue)\r\n{\r\n\tCString resName;\r\n\tresName.Format(_T(\"(%dx%d)_%s\"), GetScreenWidth(), GetScreenHeight(), csName);\r\n\r\n\treturn SetProfileLong(resName, lValue);\r\n}\r\n\r\nlong CGetSetOptions::GetProfileLong(CString csName, long lDefaultValue, CString csNewPath)\r\n{\r\n\tif(m_bFromIni && !m_bInConversion)\r\n\t{\r\n\t\tCString csApp(_T(\"Ditto\"));\r\n\r\n\t\tif(csNewPath.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tcsApp = csNewPath;\r\n\t\t}\r\n\r\n\t\treturn GetPrivateProfileInt(csApp, csName, lDefaultValue, m_csIniFileName);\r\n\t}\r\n\r\n\tCString csPath(_T(REG_PATH));\r\n\tif(csNewPath.IsEmpty() == FALSE)\r\n\t{\r\n\t\tcsPath += \"\\\\\" + csNewPath;\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\r\n\tlong lResult = RegOpenKeyEx(HKEY_CURRENT_USER, csPath, NULL, KEY_READ, &hkKey);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn lDefaultValue;\r\n\r\n\tDWORD buffer;\r\n\tDWORD len =  sizeof(buffer);\r\n\tDWORD type;\r\n\r\n\tlResult = ::RegQueryValueEx(hkKey, csName, 0, &type, (LPBYTE)&buffer, &len);\r\n\r\n\tRegCloseKey(hkKey);\r\n\r\n\tif(lResult == ERROR_SUCCESS)\r\n\t\treturn (long)buffer;\r\n\r\n\treturn lDefaultValue;\r\n}\r\n\r\nCString CGetSetOptions::GetProfileString(CString csName, CString csDefault, CString csNewPath, int maxSize)\r\n{\r\n\tCString returnString;\r\n\tDWORD dwBufLen = 0;\r\n\r\n\tif(m_bFromIni && !m_bInConversion)\r\n\t{\r\n\t\tCString csApp(_T(\"Ditto\"));\r\n\r\n\t\tif(csNewPath.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tcsApp = csNewPath;\r\n\t\t}\r\n\r\n\t\tbool doBreak = false;\r\n\t\tdwBufLen = 10000;\r\n\t\tbool setMaxSize = false;\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tif (maxSize > -1 && maxSize < dwBufLen)\r\n\t\t\t{\r\n\t\t\t\tdwBufLen = maxSize;\r\n\t\t\t\tsetMaxSize = true;\r\n\t\t\t}\r\n\r\n\t\t\tTCHAR *szString = new TCHAR[dwBufLen];\r\n\t\t\tZeroMemory(szString, dwBufLen);\r\n\r\n\t\t\tDWORD readLength = GetPrivateProfileString(csApp, csName, csDefault, szString, dwBufLen, m_csIniFileName);\r\n\r\n\t\t\tif (setMaxSize ||\r\n\t\t\t\treadLength < (dwBufLen - 1))\r\n\t\t\t{\r\n\t\t\t\treturnString = szString;\r\n\t\t\t\tdoBreak = true; //delay break so we can delete the string\r\n\t\t\t}\r\n\r\n\t\t\tdelete[] szString;\r\n\t\t\tdwBufLen = dwBufLen * 2;\r\n\r\n\t\t\tif (doBreak)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn returnString;\r\n\t}\r\n\r\n\tCString csPath(_T(REG_PATH));\r\n\tif(csNewPath.IsEmpty() == FALSE)\r\n\t{\r\n\t\tcsPath += \"\\\\\" + csNewPath;\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\tlong lResult = RegOpenKeyEx(HKEY_CURRENT_USER, csPath, NULL, KEY_READ, &hkKey);\r\n\r\n\tif (lResult == ERROR_SUCCESS)\r\n\t{\r\n\t\tlResult = ::RegQueryValueEx(hkKey, csName, NULL, NULL, NULL, &dwBufLen);\r\n\r\n\t\tif (lResult == ERROR_SUCCESS &&\r\n\t\t\tdwBufLen > 0)\r\n\t\t{\r\n\t\t\tif (maxSize > -1 && maxSize < dwBufLen)\r\n\t\t\t{\r\n\t\t\t\tdwBufLen = maxSize;\r\n\t\t\t}\r\n\r\n\t\t\tdwBufLen++;\r\n\t\t\tTCHAR *szString = new TCHAR[dwBufLen];\r\n\t\t\tZeroMemory(szString, dwBufLen);\r\n\r\n\t\t\tlResult = ::RegQueryValueEx(hkKey, csName, NULL, NULL, (LPBYTE)szString, &dwBufLen);\r\n\r\n\t\t\treturnString = szString;\r\n\t\t\tdelete[] szString;\r\n\t\t}\r\n\r\n\t\tRegCloseKey(hkKey);\r\n\t}\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn csDefault;\r\n\r\n\treturn returnString;\r\n}\r\n\r\nBOOL CGetSetOptions::SetProfileLong(CString csName, long lValue)\r\n{\r\n\tif(m_bFromIni)\r\n\t{\r\n\t\treturn WritePrivateProfileInt(_T(\"Ditto\"), csName, lValue, m_csIniFileName);\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\tDWORD dWord;\r\n\tlong lResult = RegCreateKeyEx(HKEY_CURRENT_USER, _T(REG_PATH), NULL, \r\n\t\tNULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, \r\n\t\tNULL, &hkKey, &dWord);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn FALSE;\r\n\r\n\tDWORD val = (DWORD)lValue;\r\n\tlResult = ::RegSetValueEx(hkKey, csName, 0, REG_DWORD, (LPBYTE)&val, sizeof(DWORD));\r\n\r\n\tRegCloseKey(hkKey);\r\n\r\n\treturn lResult == ERROR_SUCCESS;\r\n}\r\n\r\nBOOL CGetSetOptions::SetProfileString(CString csName, CString csValue)\r\n{\r\n\tif(m_bFromIni)\r\n\t{\r\n\t\treturn WritePrivateProfileString(_T(\"Ditto\"), csName, csValue, m_csIniFileName);\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\tDWORD dWord;\r\n\tlong lResult = RegCreateKeyEx(HKEY_CURRENT_USER, _T(REG_PATH), NULL, \r\n\t\tNULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, \r\n\t\tNULL, &hkKey, &dWord);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn FALSE;\r\n\r\n\t::RegSetValueEx(hkKey, csName, NULL, REG_SZ,\r\n\t\t(BYTE*)(LPCTSTR)csValue, csValue.GetLength()*sizeof(TCHAR));\r\n\r\n\tRegCloseKey(hkKey);\r\n\r\n\treturn lResult == ERROR_SUCCESS;\r\n}\r\n\r\nBOOL CGetSetOptions::SetProfileData(CString csName, LPVOID lpData, DWORD dwLength)\r\n{\r\n\tif(m_bFromIni)\r\n\t{\r\n\t\tASSERT(!\"SetProfileData not supported in .ini settings\");\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\tDWORD dWord;\r\n\tlong lResult = RegCreateKeyEx(HKEY_CURRENT_USER, _T(REG_PATH), NULL, \r\n\t\tNULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, \r\n\t\tNULL, &hkKey, &dWord);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn FALSE;\r\n\r\n\t::RegSetValueEx(hkKey, csName, NULL, REG_BINARY,\r\n\t\t(BYTE*)lpData, dwLength);\r\n\r\n\tRegCloseKey(hkKey);\r\n\r\n\treturn lResult == ERROR_SUCCESS;\r\n}\r\n\r\nBOOL CGetSetOptions::GetProfileFont(CString csSection, LOGFONT &font)\r\n{\r\n\tfont.lfHeight = GetPrivateProfileInt(csSection, _T(\"Height\"), 0, m_csIniFileName);\r\n\tfont.lfWidth = GetPrivateProfileInt(csSection, _T(\"Width\"), 0, m_csIniFileName);\r\n\tfont.lfEscapement = GetPrivateProfileInt(csSection, _T(\"Escapement\"), 0, m_csIniFileName);\r\n\tfont.lfOrientation = GetPrivateProfileInt(csSection, _T(\"Orientation\"), 0, m_csIniFileName);\r\n\tfont.lfWeight = GetPrivateProfileInt(csSection, _T(\"Weight\"), 0, m_csIniFileName);\r\n\tfont.lfItalic = GetPrivateProfileInt(csSection, _T(\"Italic\"), 0, m_csIniFileName);\r\n\tfont.lfUnderline = GetPrivateProfileInt(csSection, _T(\"Underline\"), 0, m_csIniFileName);\r\n\tfont.lfStrikeOut = GetPrivateProfileInt(csSection, _T(\"StrikeOut\"), 0, m_csIniFileName);\r\n\tfont.lfCharSet = GetPrivateProfileInt(csSection, _T(\"CharSet\"), 0, m_csIniFileName);\r\n\tfont.lfOutPrecision = GetPrivateProfileInt(csSection, _T(\"OutPrecision\"), 0, m_csIniFileName);\r\n\tfont.lfClipPrecision = GetPrivateProfileInt(csSection, _T(\"ClipPrecision\"), 0, m_csIniFileName);\r\n\tfont.lfQuality = GetPrivateProfileInt(csSection, _T(\"Quality\"), 0, m_csIniFileName);\r\n\tfont.lfPitchAndFamily = GetPrivateProfileInt(csSection, _T(\"PitchAndFamily\"), 0, m_csIniFileName);\r\n\tGetPrivateProfileString(csSection, _T(\"FaceName\"), _T(\"\"), font.lfFaceName, sizeof(font.lfFaceName), m_csIniFileName);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CGetSetOptions::SetProfileFont(CString csSection, LOGFONT &font)\r\n{\r\n\tWritePrivateProfileInt(csSection, _T(\"Height\"), font.lfHeight, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Width\"), font.lfWidth, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Escapement\"), font.lfEscapement, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Orientation\"), font.lfOrientation, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Weight\"), font.lfWeight, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Italic\"), font.lfItalic, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Underline\"), font.lfUnderline, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"StrikeOut\"), font.lfStrikeOut, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"CharSet\"), font.lfCharSet, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"OutPrecision\"), font.lfOutPrecision, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"ClipPrecision\"), font.lfClipPrecision, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"Quality\"), font.lfQuality, m_csIniFileName);\r\n\tWritePrivateProfileInt(csSection, _T(\"PitchAndFamily\"), font.lfPitchAndFamily, m_csIniFileName);\r\n\tWritePrivateProfileString(csSection, _T(\"FaceName\"), font.lfFaceName, m_csIniFileName);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLPVOID CGetSetOptions::GetProfileData(CString csName, DWORD &dwLength)\r\n{\r\n\tif(m_bFromIni && !m_bInConversion)\r\n\t{\r\n\t\tASSERT(!\"GetProfileData not supported in .ini settings\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tHKEY hkKey;\r\n\r\n\tlong lResult = RegOpenKeyEx(HKEY_CURRENT_USER, _T(REG_PATH),\r\n\t\tNULL, KEY_READ, &hkKey);\r\n\r\n\tlResult = ::RegQueryValueEx(hkKey , csName, NULL, NULL, NULL, &dwLength);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn NULL;\r\n\r\n\tLPVOID lpVoid = new BYTE[dwLength];\r\n\r\n\tlResult = ::RegQueryValueEx(hkKey , csName, NULL, NULL, (LPBYTE)lpVoid, &dwLength);\r\n\r\n\tRegCloseKey(hkKey);\r\n\r\n\tif(lResult != ERROR_SUCCESS)\r\n\t\treturn NULL;\r\n\r\n\treturn lpVoid;\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowIconInSysTray() \r\n{\r\n\treturn GetProfileLong(\"ShowIconInSystemTray\", TRUE);\r\n}\r\n\r\nBOOL CGetSetOptions::SetShowIconInSysTray(BOOL bShow) \r\n{\r\n\treturn SetProfileLong(\"ShowIconInSystemTray\", bShow);\r\n}\r\n\r\nBOOL CGetSetOptions::SetEnableTransparency(BOOL bCheck)\r\n{\r\n\treturn SetProfileLong(\"EnableTransparency\", bCheck);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEnableTransparency()\r\n{\r\n\treturn GetProfileLong(\"EnableTransparency\", FALSE);\r\n}\r\n\r\nBOOL CGetSetOptions::SetTransparencyPercent(long lPercent)\r\n{\r\n\tif(lPercent > OPACITY_MAX)\r\n\t\tlPercent = OPACITY_MAX;\r\n\tif(lPercent < 0)\r\n\t\tlPercent = 0;\r\n\r\n\treturn SetProfileLong(\"TransparencyPercent\", lPercent);\r\n}\r\n\r\nlong CGetSetOptions::GetTransparencyPercent()\r\n{\r\n\tlong lValue = GetProfileLong(\"TransparencyPercent\", 14);\r\n\r\n\tif(lValue > OPACITY_MAX) lValue = OPACITY_MAX;\r\n\tif(lValue < 0) lValue = 0;\r\n\r\n\treturn lValue;\r\n}\r\n\r\nBOOL CGetSetOptions::SetLinesPerRow(long lLines)\r\n{\r\n\tm_nLinesPerRow = lLines;\r\n\treturn SetProfileLong(\"LinesPerRow\", lLines);\r\n}\r\n\r\nlong CGetSetOptions::GetLinesPerRow()\r\n{\r\n\treturn GetProfileLong(\"LinesPerRow\", 2);\r\n}\r\n\r\nBOOL CGetSetOptions::GetRunOnStartUp()\r\n{\r\n\tHKEY hkRun;\r\n\r\n\tLONG nResult = RegOpenKeyEx(HKEY_CURRENT_USER,\r\n\t\t_T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"),\r\n\t\tNULL, KEY_READ, &hkRun);\r\n\r\n\tif(nResult != ERROR_SUCCESS)\r\n\t\treturn FALSE;\r\n\r\n\tnResult = RegQueryValueEx(hkRun, GetAppName(), NULL, NULL, NULL, NULL);\r\n\tRegCloseKey(hkRun);\r\n\treturn nResult == ERROR_SUCCESS;\r\n}\r\n\r\nvoid CGetSetOptions::SetRunOnStartUp(BOOL bRun)\r\n{\r\n\tHKEY hkRun;\r\n\tLONG nResult = RegOpenKeyEx(HKEY_CURRENT_USER,\r\n\t\t_T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"),\r\n\t\tNULL, KEY_ALL_ACCESS, &hkRun);\r\n\r\n\tif(nResult != ERROR_SUCCESS)\r\n\t\treturn;\r\n\r\n\tif(bRun)\r\n\t{\r\n\t\tCString sExeName = GetExeFileName();\r\n\t\t::RegSetValueEx(hkRun, GetAppName(), NULL, REG_SZ,\r\n\t\t\t(BYTE*)(LPCTSTR)sExeName, sExeName.GetLength()*sizeof(TCHAR));\r\n\t} \r\n\telse \r\n\t{\r\n\t\t::RegDeleteValue(hkRun, GetAppName());\r\n\t}\r\n\r\n\t::RegCloseKey(hkRun);\r\n}\r\n\r\nCString CGetSetOptions::GetExeFileName()\r\n{\r\n\tCString sExeName;\r\n\tGetModuleFileName(NULL, sExeName.GetBuffer(_MAX_PATH),_MAX_PATH);\r\n\tsExeName.ReleaseBuffer();\r\n\treturn sExeName;\r\n}\r\n\r\nCString CGetSetOptions::GetAppName()\r\n{\r\n\treturn \"Ditto\";\r\n}\r\n\r\nBOOL CGetSetOptions::SetQuickPastePosition(long lPosition)\r\n{\r\n\treturn SetProfileLong(\"ShowQuickPastePosition\", lPosition);\r\n}\r\n\r\nlong CGetSetOptions::GetQuickPastePosition()\r\n{\r\n\treturn GetProfileLong(\"ShowQuickPastePosition\", POS_AT_CARET);\r\n}\r\n\r\nBOOL CGetSetOptions::SetQuickPasteSize(CSize size)\r\n{\r\n\tBOOL bRet = SetResolutionProfileLong(\"QuickPasteCX\", size.cx);\r\n\tbRet = SetResolutionProfileLong(\"QuickPasteCY\", size.cy);\r\n\r\n\treturn bRet;\r\n}\r\n\r\nvoid CGetSetOptions::GetQuickPasteSize(CSize &size)\r\n{\t\r\n\tsize.cx = GetResolutionProfileLong(\"QuickPasteCX\", 300);\r\n\tsize.cy = GetResolutionProfileLong(\"QuickPasteCY\", 300);\r\n\tif(size.cx <= 0 && size.cy <= 0)\r\n\t{\r\n\t\tsize.cx = 300;\r\n\t\tsize.cy = 300;\r\n\t}\r\n}\r\n\r\nBOOL CGetSetOptions::SetQuickPastePoint(CPoint point)\r\n{\r\n\tBOOL bRet = SetResolutionProfileLong(\"QuickPasteX\", point.x);\r\n\tbRet = SetResolutionProfileLong(\"QuickPasteY\", point.y);\r\n\r\n\treturn bRet;\r\n}\r\n\r\nvoid CGetSetOptions::GetQuickPastePoint(CPoint &point)\r\n{\r\n\tpoint.x = GetResolutionProfileLong(\"QuickPasteX\", 300);\r\n\tpoint.y = GetResolutionProfileLong(\"QuickPasteY\", 300);\r\n}\r\n\r\nlong CGetSetOptions::GetCopyGap()\r\n{\r\n\treturn GetProfileLong(\"CopyGap\", 150);\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyGap(long lGap)\r\n{\r\n\tSetProfileLong(\"CopyGap\", lGap);\r\n}\r\n\r\nBOOL CGetSetOptions::SetDBPathOld(CString csPath)\r\n{\r\n\treturn SetProfileString(\"DBPath\", csPath);\r\n}\r\n\r\nCString CGetSetOptions::GetDBPathOld()\r\n{\r\n\treturn GetProfileString(\"DBPath\", \"\");\r\n}\r\n\r\nBOOL CGetSetOptions::SetDBPath(CString csPath)\r\n{\r\n\treturn SetProfileString(\"DBPath3\", csPath);\r\n}\r\n\r\nCString CGetSetOptions::ResolvePath(CString path)\r\n{\r\n\tCString dest;\r\n\tint newSize = max(path.GetLength() * 10, 1000);\r\n\r\n\t//path = _T(\"some string %COMPUTERNAME% test\");\r\n\r\n\tExpandEnvironmentStrings(path, dest.GetBuffer(newSize), newSize);\r\n\tdest.ReleaseBuffer();\r\n\r\n\treturn dest;\r\n}\r\n\r\nCString CGetSetOptions::GetDBPath(bool resolvePath)\r\n{\r\n\tCString csDBPath;\r\n\tcsDBPath = GetProfileString(\"DBPath3\", \"\");\r\n\r\n\tif (resolvePath)\r\n\t{\r\n\t\tcsDBPath = ResolvePath(csDBPath);\r\n\t}\r\n\r\n\treturn csDBPath;\r\n}\r\n\r\nvoid CGetSetOptions::SetCheckForMaxEntries(BOOL bVal)\r\n{\r\n\tSetProfileLong(\"CheckForMaxEntries\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetCheckForMaxEntries()\r\n{\r\n\tBOOL bDefault = FALSE;\r\n\tif(GetIsPortableDitto())\r\n\t\tbDefault = TRUE;\r\n\r\n\treturn GetProfileLong(\"CheckForMaxEntries\", bDefault);\r\n}\r\n\r\nvoid CGetSetOptions::SetCheckForExpiredEntries(BOOL bVal)\r\n{\r\n\tSetProfileLong(\"CheckForExpiredEntries\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetCheckForExpiredEntries()\r\n{\r\n\treturn GetProfileLong(\"CheckForExpiredEntries\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaxEntries(long lVal)\r\n{\r\n\tSetProfileLong(\"MaxEntries\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetMaxEntries()\r\n{\r\n\tlong lMax = 500;\r\n\tif(GetIsPortableDitto())\r\n\t\tlMax = 100;\r\n\treturn GetProfileLong(\"MaxEntries\", lMax);\r\n}\r\n\r\nvoid CGetSetOptions::SetExpiredEntries(long lVal)\r\n{\r\n\tSetProfileLong(\"ExpiredEntries\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetExpiredEntries()\r\n{\r\n\treturn GetProfileLong(\"ExpiredEntries\", 5);\r\n}\r\n\r\nvoid CGetSetOptions::SetTripCopyCount(long lVal)\r\n{\r\n\t// negative means a relative offset\r\n\tif(lVal < 0)\r\n\t\tlVal = GetTripCopyCount() - lVal; // add the absolute value\r\n\r\n\tif(GetTripDate() == 0)\r\n\t\tSetTripDate(-1);\r\n\r\n\tSetProfileLong(\"TripCopies\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetTripCopyCount()\r\n{\r\n\treturn GetProfileLong(\"TripCopies\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetTripPasteCount(long lVal)\r\n{\r\n\t// negative means a relative offset\r\n\tif(lVal < 0)\r\n\t\tlVal = GetTripPasteCount() - lVal; // add the absolute value\r\n\r\n\tif(GetTripDate() == 0)\r\n\t\tSetTripDate(-1);\r\n\r\n\tSetProfileLong(\"TripPastes\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetTripPasteCount()\r\n{\r\n\treturn GetProfileLong(\"TripPastes\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetTripDate(long lDate)\r\n{\r\n\tif(lDate == -1)\r\n\t\tlDate = (long)CTime::GetCurrentTime().GetTime();\r\n\r\n\tSetProfileLong(\"TripDate\", lDate);\r\n}\r\n\r\nlong CGetSetOptions::GetTripDate()\r\n{\r\n\treturn GetProfileLong(\"TripDate\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetTotalCopyCount(long lVal)\r\n{\r\n\t// negative means a relative offset\r\n\tif(lVal < 0)\r\n\t\tlVal = GetTotalCopyCount() - lVal; // add the absolute value\r\n\r\n\tif(GetTotalDate() == 0)\r\n\t\tSetTotalDate(-1);\r\n\r\n\tSetProfileLong(\"TotalCopies\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetTotalCopyCount()\r\n{\r\n\treturn GetProfileLong(\"TotalCopies\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetTotalPasteCount(long lVal)\r\n{\r\n\t// negative means a relative offset\r\n\tif(lVal < 0)\r\n\t\tlVal = GetTotalPasteCount() - lVal; // add the absolute value\r\n\r\n\tif(GetTotalDate() == 0)\r\n\t\tSetTotalDate(-1);\r\n\r\n\tSetProfileLong(\"TotalPastes\", lVal);\r\n}\r\n\r\nlong CGetSetOptions::GetTotalPasteCount()\r\n{\r\n\treturn GetProfileLong(\"TotalPastes\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetTotalDate(long lDate)\r\n{\r\n\tif(lDate == -1)\r\n\t\tlDate = (long)CTime::GetCurrentTime().GetTime();\r\n\r\n\tSetProfileLong(\"TotalDate\", lDate);\r\n}\r\n\r\nlong CGetSetOptions::GetTotalDate()\r\n{\r\n\treturn GetProfileLong(\"TotalDate\", 0);\r\n}\r\n\r\nCString\tCGetSetOptions::GetUpdateFilePath()\t\t\t\r\n{ \r\n\treturn GetProfileString(\"UpdateFilePath\", \"\");\t\r\n}\r\nBOOL CGetSetOptions::SetUpdateFilePath(CString cs)\t\r\n{ \r\n\treturn SetProfileString(\"UpdateFilePath\", cs);\t\r\n}\r\n\r\nCString\tCGetSetOptions::GetUpdateInstallPath()\t\t\t\r\n{ \r\n\treturn GetProfileString(\"UpdateInstallPath\", \"\");\t\r\n}\r\nBOOL CGetSetOptions::SetUpdateInstallPath(CString cs)\t\r\n{ \r\n\treturn SetProfileString(\"UpdateInstallPath\", cs);\t\r\n}\r\n\r\nlong CGetSetOptions::GetLastUpdate()\t\t\t\r\n{ \r\n\treturn GetProfileLong(\"LastUpdateDay\", 0);\t\t\r\n}\r\nlong CGetSetOptions::SetLastUpdate(long lValue)\t\r\n{ \r\n\treturn SetProfileLong(\"LastUpdateDay\", lValue);\t\r\n}\r\n\r\nBOOL CGetSetOptions::GetCheckForUpdates()\t\t\t\t\r\n{ \r\n\treturn GetProfileLong(\"CheckForUpdates\", TRUE);\t\r\n}\r\nBOOL CGetSetOptions::SetCheckForUpdates(BOOL bCheck)\t\r\n{ \r\n\treturn SetProfileLong(\"CheckForUpdates\", bCheck);\t\r\n}\r\n\r\nvoid CGetSetOptions::SetUseCtrlNumForFirstTenHotKeys(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"UseCtrlNumForFirstTenHotKeys\", bVal);\t\r\n\tm_bUseCtrlNumAccel = bVal;\t\r\n}\r\nBOOL CGetSetOptions::GetUseCtrlNumForFirstTenHotKeys()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"UseCtrlNumForFirstTenHotKeys\", 0); \r\n}\r\n\r\nvoid CGetSetOptions::SetAllowDuplicates(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"AllowDuplicates\", bVal); \r\n\tm_bAllowDuplicates = bVal; \r\n}\r\nBOOL CGetSetOptions::GetAllowDuplicates()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"AllowDuplicates\", 0); \r\n}\r\n\r\nvoid CGetSetOptions::SetUpdateTimeOnPaste(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"UpdateTimeOnPaste\", bVal); \r\n\tm_bUpdateTimeOnPaste = bVal; \r\n}\r\nBOOL CGetSetOptions::GetUpdateTimeOnPaste()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"UpdateTimeOnPaste\", TRUE); \r\n}\r\n\r\nvoid CGetSetOptions::SetSaveMultiPaste(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"SaveMultiPaste\", bVal); \r\n\tm_bSaveMultiPaste = bVal; \r\n}\r\nBOOL CGetSetOptions::GetSaveMultiPaste()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"SaveMultiPaste\", 0); \r\n}\r\n\r\nvoid CGetSetOptions::SetShowPersistent(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"ShowPersistent\", bVal); \r\n\tm_bShowPersistent = bVal; \r\n}\r\nBOOL CGetSetOptions::GetShowPersistent()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"ShowPersistent\", 0); \r\n}\r\n\r\nvoid CGetSetOptions::SetShowTextForFirstTenHotKeys(BOOL bVal)\t\r\n{\t\r\n\tSetProfileLong(\"ShowTextForFirstTenHotKeys\", bVal);\t\t\t\r\n}\r\nBOOL CGetSetOptions::GetShowTextForFirstTenHotKeys()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"ShowTextForFirstTenHotKeys\", TRUE);\t\r\n}\r\n\r\nvoid CGetSetOptions::SetMainHWND(long lhWnd)\t\r\n{\t\r\n\tSetProfileLong(\"MainhWnd\", lhWnd);\t\t\r\n}\r\nlong CGetSetOptions::GetMainHWND()\t\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"MainhWnd\", 0);\t\r\n}\r\n\r\nvoid CGetSetOptions::SetCaptionPos(long lPos)\t\r\n{\t\r\n\tSetProfileLong(\"CaptionPos\", lPos);\t\t\t\t\t\r\n}\r\nlong CGetSetOptions::GetCaptionPos()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"CaptionPos\", CAPTION_RIGHT);\t\r\n}\r\n\r\nvoid CGetSetOptions::SetAutoHide(BOOL bAutoHide)\r\n{\t\r\n\tSetProfileLong(\"AutoHide\", bAutoHide);\t\t\t\t\t\r\n}\r\nBOOL CGetSetOptions::GetAutoHide()\t\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"AutoHide\", FALSE);\t\t\t\t\r\n}\r\n\r\nvoid CGetSetOptions::SetDescTextSize(long lSize)\r\n{\t\r\n\tSetProfileLong(\"DescTextSize\", lSize); \r\n\tm_bDescTextSize = lSize; \r\n}\r\nlong CGetSetOptions::GetDescTextSize()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"DescTextSize\", 500); \r\n}\r\n\r\nvoid CGetSetOptions::SetDescShowLeadingWhiteSpace(BOOL bVal)\r\n{ \r\n\tSetProfileLong(\"DescShowLeadingWhiteSpace\", bVal); \r\n\tm_bDescShowLeadingWhiteSpace = bVal; \r\n}\r\nBOOL CGetSetOptions::GetDescShowLeadingWhiteSpace()         \r\n{ \r\n\treturn GetProfileLong(\"DescShowLeadingWhiteSpace\", FALSE); \r\n}\r\n\r\nvoid CGetSetOptions::SetAllwaysShowDescription(long bShow)\t\r\n{\t\r\n\tSetProfileLong(\"AllwaysShowDescription\", bShow); \r\n\tm_bAllwaysShowDescription = bShow; \r\n}\r\nBOOL CGetSetOptions::GetAllwaysShowDescription()\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"AllwaysShowDescription\", FALSE); \r\n}\r\n\r\nvoid CGetSetOptions::SetDoubleClickingOnCaptionDoes(long lOption)\t\r\n{\t\r\n\tSetProfileLong(\"DoubleClickingOnCaptionDoes\", lOption); \r\n\tm_bDoubleClickingOnCaptionDoes = lOption; \r\n}\r\nlong CGetSetOptions::GetDoubleClickingOnCaptionDoes()\t\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"DoubleClickingOnCaptionDoes\", TOGGLES_ALLWAYS_ON_TOP); \r\n}\r\n\r\nvoid CGetSetOptions::SetPrompForNewGroupName(BOOL bOption)\t\r\n{\t\r\n\tSetProfileLong(\"PrompForNewGroupName\", bOption); \r\n\tm_bPrompForNewGroupName = bOption; \r\n}\r\nBOOL CGetSetOptions::GetPrompForNewGroupName()\t\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"PrompForNewGroupName\", TRUE); \r\n}\r\n\r\nvoid CGetSetOptions::SetSendPasteOnFirstTenHotKeys(BOOL bOption)\t\r\n{\t\r\n\tSetProfileLong(\"SendPasteOnFirstTenHotKeys\", bOption); \r\n\tm_bSendPasteOnFirstTenHotKeys = bOption; \r\n}\r\nBOOL CGetSetOptions::GetSendPasteOnFirstTenHotKeys()\t\t\t\t\r\n{\t\r\n\treturn GetProfileLong(\"SendPasteOnFirstTenHotKeys\", TRUE); \r\n}\r\n\r\nvoid CGetSetOptions::SetSendClients(CSendClients Client, int nPos)\r\n{\r\n\tCString cs;\r\n\r\n\tcs.Format(_T(\"sendclient_ip_%d\"), nPos);\r\n\tSetProfileString(cs, Client.csIP);\r\n\r\n\tcs.Format(_T(\"sendclient_autosend_%d\"), nPos);\r\n\tSetProfileLong(cs, Client.bSendAll);\r\n\r\n\tcs.Format(_T(\"sendclient_description_%d\"), nPos);\r\n\tSetProfileString(cs, Client.csDescription);\r\n\r\n\tClient.bShownFirstError = m_SendClients[nPos].bShownFirstError;\r\n\r\n\tm_SendClients[nPos] = Client;\r\n}\r\n\r\nCSendClients CGetSetOptions::GetSendClients(int nPos)\r\n{\r\n\tCSendClients Client;\r\n\r\n\tCString cs;\r\n\r\n\tcs.Format(_T(\"sendclient_ip_%d\"), nPos);\r\n\tClient.csIP = GetProfileString(cs, \"\");\r\n\r\n\tcs.Format(_T(\"sendclient_autosend_%d\"), nPos);\r\n\tClient.bSendAll = GetProfileLong(cs, FALSE);\r\n\r\n\tcs.Format(_T(\"sendclient_description_%d\"), nPos);\r\n\tClient.csDescription = GetProfileString(cs, \"\");\r\n\r\n\tm_SendClients[nPos] = Client;\r\n\r\n\treturn Client;\r\n}\r\n\r\nvoid CGetSetOptions::GetClientSendCount()\r\n{\r\n\tm_lAutoSendClientCount = 0;\r\n\tfor(int i = 0; i < MAX_SEND_CLIENTS; i++)\r\n\t{\r\n\t\tif(m_SendClients[i].csIP.GetLength() > 0)\r\n\t\t{\r\n\t\t\tif(m_SendClients[i].bSendAll)\r\n\t\t\t\tm_lAutoSendClientCount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nCString\tCGetSetOptions::GetListToPutOnClipboard()\t\t\t\r\n{ \r\n\tCString cs = GetProfileString(\"ListToPutOnClipboard\", \"\");\r\n\tcs.MakeUpper();\r\n\treturn cs;\r\n}\r\nBOOL CGetSetOptions::SetListToPutOnClipboard(CString cs)\t\r\n{ \r\n\tcs.MakeUpper();\r\n\tm_csIPListToPutOnClipboard = cs;\r\n\treturn SetProfileString(\"ListToPutOnClipboard\", cs); \r\n\r\n}\r\n\r\nvoid CGetSetOptions::SetLogSendReceiveErrors(BOOL bOption)\r\n{\r\n\tm_bLogSendReceiveErrors = bOption;\r\n\r\n\tSetProfileLong(\"LogSendReceiveErrors\", bOption);\r\n}\r\n\r\nBOOL CGetSetOptions::GetLogSendReceiveErrors()\r\n{\r\n\treturn GetProfileLong(\"LogSendReceiveErrors\", FALSE);\r\n}\r\n\r\nBOOL CGetSetOptions::GetHideDittoOnHotKeyIfAlreadyShown()\r\n{\r\n\treturn GetProfileLong(\"HideDittoOnHotKeyIfAlreadyShown\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetHideDittoOnHotKeyIfAlreadyShown(BOOL bVal)\r\n{\r\n\tm_HideDittoOnHotKeyIfAlreadyShown = bVal;\r\n\r\n\tSetProfileLong(\"HideDittoOnHotKeyIfAlreadyShown\", bVal);\r\n}\r\n\r\nvoid CGetSetOptions::SetPort(long lPort)\r\n{\r\n\tm_lPort = lPort;\r\n\tSetProfileLong(\"SendRecvPort\", lPort);\r\n}\r\n\r\nlong CGetSetOptions::GetPort()\r\n{\r\n\treturn GetProfileLong(\"SendRecvPort\", 23443);\r\n}\r\n\r\nBOOL CGetSetOptions::GetDisableRecieve()\r\n{\r\n\tBOOL bDefault = FALSE;\r\n\tif(GetIsPortableDitto())\r\n\t\tbDefault = TRUE;\r\n\r\n\tif(GetIsWindowsApp())\r\n\t\tbDefault = TRUE;\r\n\r\n\treturn GetProfileLong(\"DisableRecieve\", bDefault);\r\n}\r\n\r\nvoid CGetSetOptions::SetDisableRecieve(BOOL bVal)\r\n{\r\n\tSetProfileLong(\"DisableRecieve\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetFont(LOGFONT &font)\r\n{\r\n\tif(m_bFromIni && !m_bInConversion)\r\n\t{\r\n\t\tGetProfileFont(\"DisplayFont6\", font);\r\n\r\n\t\t//Return true if there is a font name\r\n\t\t//other wise load the default font below\r\n\t\tif(font.lfFaceName[0] != 0)\r\n\t\t{\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tDWORD dwLength = 0;\r\n\t\tLPVOID lpVoid = GetProfileData(\"DisplayFont6\", dwLength);\r\n\t\tif(lpVoid)\r\n\t\t{\r\n\t\t\tif(sizeof(font) == dwLength)\r\n\t\t\t{\r\n\t\t\t\tmemcpy(&font, lpVoid, dwLength);\r\n\t\t\t\tdelete[] lpVoid;\r\n\t\t\t\tlpVoid = NULL;\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tASSERT(!\"invalid font struct size\");\r\n\t\t\t}\r\n\r\n\t\t\tdelete[] lpVoid;\r\n\t\t\tlpVoid = NULL;\r\n\t\t}\r\n\t}\r\n\r\n\tZeroMemory(&font, sizeof(font));\r\n\tfont.lfHeight = -13;\r\n\tfont.lfWeight = 400;\r\n\tfont.lfCharSet = 1;\r\n\tSTRCPY(font.lfFaceName, _T(\"Segoe UI\"));\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CGetSetOptions::SetFont(LOGFONT &font)\r\n{\r\n\tif(m_bFromIni)\r\n\t{\r\n\t\tSetProfileFont(\"DisplayFont6\", font);\r\n\t}\r\n\telse\r\n\t{\t\r\n\t\tSetProfileData(\"DisplayFont6\", &font, sizeof(LOGFONT));\r\n\t}\r\n}\r\n\r\nvoid CGetSetOptions::SetDrawThumbnail(long bDraw)\r\n{\r\n\tSetProfileLong(\"DrawThumbnail\", bDraw); \r\n\tm_bDrawThumbnail = bDraw;\r\n}\r\n\r\nBOOL CGetSetOptions::GetDrawThumbnail()\r\n{\r\n\tBOOL bDrawThumbnails = TRUE;\r\n\r\n\treturn GetProfileLong(\"DrawThumbnail\", bDrawThumbnails);\r\n}\r\n\r\nvoid CGetSetOptions::SetFastThumbnailMode(BOOL thumbnailDrawMode)\r\n{\r\n\tSetProfileLong(\"FastThumbnailMode\", thumbnailDrawMode); \r\n\tm_bFastThumbnailMode = thumbnailDrawMode;\r\n}\r\n\r\nBOOL CGetSetOptions::GetFastThumbnailMode()\r\n{\r\n\treturn GetProfileLong(\"FastThumbnailMode\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetExtraNetworkPassword(CString csPassword)\r\n{\r\n\tSetProfileString(\"NetworkExtraPassword\", csPassword);\r\n}\r\n\r\nCString CGetSetOptions::GetExtraNetworkPassword(bool bFillArray)\r\n{\r\n\tCString cs = GetProfileString(\"NetworkExtraPassword\", \"\");\r\n\r\n\tif(bFillArray)\r\n\t{\r\n\t\tm_csNetworkPasswordArray.RemoveAll();\r\n\r\n\t\tTCHAR seps[]   = _T(\",\");\r\n\t\tTCHAR *token;\r\n\r\n\t\tTCHAR *pString = cs.GetBuffer(cs.GetLength());\r\n\r\n\t\t/* Establish string and get the first token: */\r\n\t\ttoken = STRTOK(pString, seps);\r\n\t\twhile(token != NULL)\r\n\t\t{\r\n\t\t\tCString cs(token);\r\n\t\t\tcs.TrimLeft();\r\n\t\t\tcs.TrimRight();\r\n\r\n\t\t\tm_csNetworkPasswordArray.Add(cs);\r\n\r\n\t\t\t// Get next token\r\n\t\t\ttoken = STRTOK(NULL, seps);\r\n\t\t}\r\n\r\n\t\tcs.ReleaseBuffer();\r\n\t}\r\n\r\n\treturn cs;\r\n}\r\n\r\nvoid CGetSetOptions::SetNetworkPassword(CString csPassword)\r\n{\r\n\tm_csPassword = CTextConvert::UnicodeToUTF8(csPassword);\r\n\tSetProfileString(\"NetworkStringPassword\", csPassword);\r\n}\r\n\r\nCStringA CGetSetOptions::GetNetworkPassword()\r\n{\r\n\tCString cs = GetProfileString(\"NetworkStringPassword\", \"LetMeIn\");\r\n\tCStringA csReturn = CTextConvert::UnicodeToUTF8(cs);\r\n\treturn csReturn;\r\n}\r\n\r\nvoid CGetSetOptions::SetDrawRTF(long bDraw)\r\n{\r\n\tSetProfileLong(\"DrawRTF\", bDraw); \r\n\tm_bDrawRTF = bDraw;\r\n}\r\n\r\nBOOL CGetSetOptions::GetDrawRTF()\r\n{\r\n\treturn GetProfileLong(\"DrawRTF\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetMultiPasteReverse(BOOL bVal)\r\n{\r\n\tSetProfileLong(\"MultiPasteReverse\", bVal); \r\n\tm_bMultiPasteReverse = bVal;\r\n}\r\n\r\nBOOL CGetSetOptions::GetMultiPasteReverse()\r\n{\r\n\treturn GetProfileLong(\"MultiPasteReverse\", TRUE); \r\n}\r\n\r\nvoid CGetSetOptions::SetPlaySoundOnCopy(CString cs)\r\n{\r\n\tm_csPlaySoundOnCopy = cs;\r\n\r\n\tSetProfileString(\"PlaySoundOnCopy\", cs);\r\n}\r\n\r\nCString CGetSetOptions::GetPlaySoundOnCopy()\r\n{\r\n\treturn GetProfileString(\"PlaySoundOnCopy\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetSendPasteAfterSelection(BOOL bVal)\r\n{\r\n\tm_bSendPasteMessageAfterSelection = bVal;\r\n\r\n\tSetProfileLong(\"SendPasteMessageAfterSelection\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSendPasteAfterSelection()\r\n{\r\n\treturn GetProfileLong(\"SendPasteMessageAfterSelection\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetFindAsYouType(BOOL bVal)\r\n{\r\n\tm_bFindAsYouType = bVal;\r\n\tSetProfileLong(\"FindAsYouType\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetFindAsYouType()\r\n{\r\n\treturn GetProfileLong(\"FindAsYouType\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetEnsureEntireWindowCanBeSeen(BOOL bVal)\r\n{\r\n\tm_bEnsureEntireWindowCanBeSeen = bVal;\r\n\tSetProfileLong(\"EnsureEntireWindowCanBeSeen\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEnsureEntireWindowCanBeSeen()\r\n{\r\n\treturn GetProfileLong(\"EnsureEntireWindowCanBeSeen\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowAllClipsInMainList(BOOL bVal)\r\n{\r\n\tm_bShowAllClipsInMainList = bVal;\r\n\tSetProfileLong(\"ShowAllClipsInMainList\", bVal);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowAllClipsInMainList()\r\n{\r\n\treturn GetProfileLong(\"ShowAllClipsInMainList\", TRUE);\r\n}\r\n\r\nlong CGetSetOptions::GetMaxClipSizeInBytes()\r\n{\r\n\treturn GetProfileLong(\"MaxClipSizeInBytes\", 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaxClipSizeInBytes(long lSize)\r\n{\r\n\tm_lMaxClipSizeInBytes = lSize;\r\n\tSetProfileLong(\"MaxClipSizeInBytes\", lSize);\r\n}\r\n\r\nCString CGetSetOptions::GetLanguageFile()\r\n{\r\n\treturn GetProfileString(\"LanguageFile\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetLanguageFile(CString csLanguage)\r\n{\r\n\tSetProfileString(\"LanguageFile\", csLanguage);\r\n}\r\n\r\nULONG CGetSetOptions::GetSaveClipDelay()\r\n{\r\n\treturn (ULONG)GetProfileLong(\"SaveClipDelay\", 500);\r\n}\r\n\r\nvoid CGetSetOptions::SetSaveClipDelay(DWORD dwDelay)\r\n{\r\n\tm_dwSaveClipDelay = dwDelay;\r\n\tSetProfileLong(\"SaveClipDelay\", dwDelay);\r\n}\r\n\r\nlong CGetSetOptions::GetProcessDrawClipboardDelay()\r\n{\r\n\treturn GetProfileLong(\"ProcessDrawClipboardDelay\", 100);\r\n}\r\n\r\nvoid CGetSetOptions::SetProcessDrawClipboardDelay(long lDelay)\r\n{\r\n\tm_lProcessDrawClipboardDelay = lDelay;\r\n\tSetProfileLong(\"ProcessDrawClipboardDelay\", lDelay);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEnableDebugLogging()\r\n{\r\n\treturn GetProfileLong(\"EnableDebugLogging\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetEnableDebugLogging(BOOL bEnable)\r\n{\r\n\tm_bEnableDebugLogging = bEnable;\r\n\tSetProfileLong(\"EnableDebugLogging\", bEnable);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEnableOutputDebugStringLogging()\r\n{\r\n\treturn GetProfileLong(\"EnableOutputDebugStringLogging\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetEnableOutputDebugStringLogging(BOOL bEnable)\r\n{\r\n\tm_outputDebugStringLogging = bEnable;\r\n\tSetProfileLong(\"EnableOutputDebugStringLogging\", bEnable);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEnsureConnectToClipboard()\r\n{\r\n\treturn GetProfileLong(\"EnsureConnected2\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetEnsureConnectToClipboard(BOOL bSet)\r\n{\r\n\tm_bEnsureConnectToClipboard = bSet;\r\n\tSetProfileLong(\"EnsureConnected2\", bSet);\r\n}\r\n\r\nBOOL CGetSetOptions::GetPromptWhenDeletingClips()\r\n{\r\n\treturn GetProfileLong(\"PromptWhenDeletingClips\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetPromptWhenDeletingClips(BOOL bSet)\r\n{\r\n\tSetProfileLong(\"PromptWhenDeletingClips\", bSet);\r\n}\r\n\r\nCString CGetSetOptions::GetLastImportDir()\r\n{\r\n\treturn GetProfileString(\"LastImportDir\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetLastImportDir(CString csDir)\r\n{\r\n\tSetProfileString(\"LastImportDir\", csDir);\r\n}\r\n\r\nCString CGetSetOptions::GetLastExportDir()\r\n{\r\n\treturn GetProfileString(\"LastExportDir\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetLastExportDir(CString csDir)\r\n{\r\n\tSetProfileString(\"LastExportDir\", csDir);\r\n}\r\n\r\nBOOL CGetSetOptions::GetUpdateDescWhenSavingClip()\r\n{\r\n\treturn GetProfileLong(\"UpdateDescWhenSaving\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetUpdateDescWhenSavingClip(BOOL bSet)\r\n{\r\n\tSetProfileLong(\"UpdateDescWhenSaving\", bSet);\r\n}\r\n\r\nCString CGetSetOptions::GetPath(long lPathID)\r\n{\r\n\tCString csDir = CGetSetOptions::GetExeFileName();\r\n\tcsDir = GetFilePath(csDir);\r\n\tFIX_CSTRING_PATH(csDir);\r\n\r\n\t//U3_APP_DATA_PATH    -\t<U3_DEVICE_PATH>\\System\\Apps\\{app_unique_id}\\Data\r\n\t//U3_HOST_EXEC_PATH\t  - %APPDATA%\\U3\\{device_serial_number}\\{app_unique_id}\\Exec\r\n\t//U3_DEVICE_EXEC_PATH -\t<U3_DEVICE_PATH>\\System\\Apps\\{app_unique_id}\\Exec\r\n\r\n\tswitch(lPathID)\r\n\t{\r\n\tcase PATH_HELP:\r\n\t\tcsDir += \"Help\\\\\";\r\n\t\tbreak;\r\n\t\r\n\tcase PATH_LANGUAGE:\r\n\t\tcsDir += \"language\\\\\";\r\n\t\tbreak;\r\n\r\n\tcase PATH_THEMES:\r\n\t\tcsDir += \"Themes\\\\\";\r\n\t\tbreak;\r\n\r\n\tcase PATH_LOG_FILE:if(CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\tcsDir = GetAppDataPath();\t\t\r\n\r\n\t\tbreak;\r\n\r\n\tcase PATH_ADDINS:\r\n\t\tcsDir += \"Addins\\\\\";\t\t\r\n\t\tbreak;\r\n\r\n\tcase PATH_REMOTE_FILES:\r\n\t\tif (CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\t{\r\n\t\t\tcsDir = GetTempFilePath();\t\t\t\r\n\t\t}\r\n\t\tcsDir += \"ReceivedFiles\\\\\";\r\n\t\tbreak;\r\n\r\n\tcase PATH_DRAG_FILES:\r\n\t\tif (CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\t{\r\n\t\t\tcsDir = GetTempFilePath();\r\n\t\t}\r\n\t\tcsDir += \"DragFiles\\\\\";\r\n\t\tbreak;\r\n\r\n\tcase PATH_CLIP_DIFF:\r\n\t\tif (CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\t{\r\n\t\t\tcsDir = GetTempFilePath();\r\n\t\t}\r\n\t\tcsDir += _T(\"ClipCompare\\\\\");\r\n\t\tbreak;\r\n\r\n\tcase PATH_RESTORE_TEMP:\r\n\t\tif (CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\t{\r\n\t\t\tcsDir = GetTempFilePath();\r\n\t\t}\r\n\t\tcsDir += _T(\"RestoreDb\\\\\");\r\n\t\tbreak;\r\n\r\n\tcase PATH_EDIT_CLIPS:\r\n\t\tif (CGetSetOptions::GetIsPortableDitto() == false)\r\n\t\t{\r\n\t\t\tcsDir = GetTempFilePath();\r\n\t\t}\r\n\t\tcsDir += _T(\"EditClips\\\\\");\r\n\t\tbreak;\r\n\r\n\t}\r\n\r\n\tCreateDirectory(csDir, NULL);\r\n\r\n\treturn csDir;\r\n}\r\n\r\nlong CGetSetOptions::GetDittoRestoreClipboardDelay()\r\n{\r\n\treturn GetProfileLong(\"RestoreClipboardDelay\", 750);\r\n\r\n}\r\nvoid CGetSetOptions::SetDittoRestoreClipboardDelay(long lDelay)\r\n{\r\n\tSetProfileLong(\"RestoreClipboardDelay\", lDelay);\r\n}\r\n\r\nvoid CGetSetOptions::GetCopyBufferItem(int nPos, CCopyBufferItem &Item)\r\n{\r\n\tItem.m_lCopyHotKey = GetProfileLong(StrF(_T(\"CopyBufferCopyHotKey_%d\"), nPos), 0);\r\n\tItem.m_lPasteHotKey = GetProfileLong(StrF(_T(\"CopyBufferPasteHotKey_%d\"), nPos), 0);\r\n\tItem.m_lCutHotKey = GetProfileLong(StrF(_T(\"CopyBufferCutHotKey_%d\"), nPos), 0);\r\n\tItem.m_bPlaySoundOnCopy = GetProfileLong(StrF(_T(\"CopyBufferPlaySound_%d\"), nPos), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyBufferItem(int nPos, CCopyBufferItem &Item)\r\n{\r\n\tSetProfileLong(StrF(_T(\"CopyBufferCopyHotKey_%d\"), nPos), Item.m_lCopyHotKey);\r\n\tSetProfileLong(StrF(_T(\"CopyBufferPasteHotKey_%d\"), nPos), Item.m_lPasteHotKey);\r\n\tSetProfileLong(StrF(_T(\"CopyBufferCutHotKey_%d\"), nPos), Item.m_lCutHotKey);\r\n\tSetProfileLong(StrF(_T(\"CopyBufferPlaySound_%d\"), nPos), Item.m_bPlaySoundOnCopy);\r\n}\r\n\r\nCString CGetSetOptions::GetMultiPasteSeparator(bool bConvertToLineFeeds)\r\n{\r\n\tCString csSep = GetProfileString(_T(\"MultiPasteSeparator\"), _T(\"[LF]\"));\r\n\tif(bConvertToLineFeeds)\r\n\t{\r\n\t\tCString csLineFeed(_T(\"\\r\\n\"));\r\n\t\tcsSep.Replace(_T(\"[LF]\"), csLineFeed);\r\n\t\tcsSep.Replace(_T(\"[lf]\"), csLineFeed);\r\n\t}\r\n\r\n\treturn csSep;\r\n}\r\n\r\nvoid CGetSetOptions::SetMultiPasteSeparator(CString csSep)\r\n{\r\n\tSetProfileString(_T(\"MultiPasteSeparator\"), csSep);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSetCurrentDirectory()\r\n{\r\n\tif(m_portable)\r\n\t{\r\n\t\tCString csExePath = GetFilePath(GetExeFileName());\r\n\t\tFIX_CSTRING_PATH(csExePath);\r\n\t\t::SetCurrentDirectory(csExePath);\r\n\t}\r\n\r\n\treturn m_portable == true;\r\n}\r\n\r\nbool CGetSetOptions::GetIsPortableDitto()\r\n{\r\n\treturn m_portable;\r\n}\r\n\r\nbool CGetSetOptions::GetIsWindowsApp()\r\n{\r\n\treturn m_windowsApp;\r\n}\r\n\r\nbool CGetSetOptions::GetIsChocolateyApp()\r\n{\r\n\treturn m_chocolateyApp;\r\n}\r\n\r\nCString CGetSetOptions::GetPasteString(CString csAppName)\r\n{\r\n\tCString csString = GetProfileString(csAppName, _T(\"\"), _T(\"PasteStrings\"));\r\n\tif (csString.IsEmpty())\r\n\t{\r\n\t\treturn GetDefaultPasteString();\r\n\t}\r\n\r\n\treturn csString;\r\n}\r\n\r\nCString CGetSetOptions::GetDefaultPasteString()\r\n{\r\n\t//ascii value for v\r\n\t//for other language keyboards v gets converted to something else so send the base ascii value\r\n\treturn GetProfileString(_T(\"DefaultPasteString\"), _T(\"^{VKEY86}\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetDefaultPasteString(CString val)\r\n{\r\n\tSetProfileString(_T(\"DefaultPasteString\"), val);\r\n}\r\n\r\nCString CGetSetOptions::GetCopyString(CString csAppName)\r\n{\r\n\tCString csString = GetProfileString(csAppName, _T(\"\"), _T(\"CopyStrings\"));\r\n\tif(csString.IsEmpty())\r\n\t\treturn GetDefaultCopyString();\r\n\r\n\treturn csString;\r\n}\r\n\r\nCString CGetSetOptions::GetDefaultCopyString()\r\n{\r\n\t//ascii value for c\r\n\t//for other language keyboards c gets converted to something else so send the base ascii value\r\n\treturn GetProfileString(_T(\"DefaultCopyString\"), _T(\"^{VKEY67}\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetDefaultCopyString(CString val)\r\n{\r\n\tSetProfileString(_T(\"DefaultCopyString\"), val);\r\n}\r\n\r\nCString CGetSetOptions::GetCutString(CString csAppName)\r\n{\r\n\tCString csString = GetProfileString(csAppName, _T(\"\"), _T(\"CutStrings\"));\r\n\tif(csString.IsEmpty())\r\n\t\treturn GetDefaultCutString();\r\n\r\n\treturn csString;\r\n}\r\n\r\nCString CGetSetOptions::GetDefaultCutString()\r\n{\r\n\t//ascii value for x\r\n\t//for other language keyboards x gets converted to something else so send the base ascii value\r\n\treturn GetProfileString(_T(\"DefaultCutString\"), _T(\"^{VKEY88}\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetDefaultCutString(CString val)\r\n{\r\n\tSetProfileString(_T(\"DefaultCutString\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetEditWordWrap()\r\n{\r\n\treturn GetProfileLong(_T(\"EditWordWrap\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetEditWordWrap(BOOL bSet)\r\n{\r\n\tSetProfileLong(_T(\"EditWordWrap\"), bSet);\r\n}\r\n\r\nvoid CGetSetOptions::SetAllowFriends(BOOL val)\r\n{\r\n\tSetProfileLong(\"AllowFriends\", val);\r\n}\r\n\r\nbool CGetSetOptions::GetAllowFriends()\r\n{\r\n\treturn (GetProfileLong(\"AllowFriends\", TRUE) == TRUE);\r\n}\r\n\r\nlong CGetSetOptions::GetAutoMaxDelay()\r\n{\r\n\treturn GetProfileLong(_T(\"AutoMaxDelaySeconds\"), 2);\r\n}\r\n\r\nvoid CGetSetOptions::SetAutoMaxDelay(long lDelay)\r\n{\r\n\tSetProfileLong(_T(\"AutoMaxDelaySeconds\"), lDelay);\r\n}\r\n\r\nvoid CGetSetOptions::SetTheme(CString csTheme)\r\n{\r\n\tSetProfileString(_T(\"Theme2\"), csTheme);\r\n}\r\n\r\nCString CGetSetOptions::GetTheme()\r\n{\r\n\treturn GetProfileString(_T(\"Theme2\"), \"\");\r\n}\r\n\r\nlong CGetSetOptions::GetKeyStateWaitTimerCount()\r\n{\r\n\treturn GetProfileLong(_T(\"KeyStateWaitTimerCount\"), 20);\r\n}\r\n\r\nlong CGetSetOptions::GetKeyStatePasteDelay()\r\n{\r\n\treturn GetProfileLong(_T(\"KeyStatePasteDelay\"), 200);\r\n}\r\n\r\nDWORD CGetSetOptions::GetDittoHotKey()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"DittoHotKey\"), 704);\r\n}\r\n\r\nDWORD CGetSetOptions::SendKeysDelay()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"SendKeysDelay\"), 100);\r\n}\r\n\r\nvoid CGetSetOptions::SetSendKeysDelay(DWORD val)\r\n{\r\n\tSetProfileLong(_T(\"SendKeysDelay\"), val);\r\n}\r\n\r\nDWORD CGetSetOptions::RealSendKeysDelay()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"RealSendKeysDelay\"), 10);\r\n}\r\n\r\nvoid CGetSetOptions::SetRealSendKeysDelay(DWORD val)\r\n{\r\n\tSetProfileLong(_T(\"RealSendKeysDelay\"), val);\r\n}\r\n\r\nDWORD CGetSetOptions::WaitForActiveWndTimeout()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"WaitForActiveWndTimeout\"), 500);\r\n}\r\n\r\nDWORD CGetSetOptions::FocusChangedDelay()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"FocusChangedDelay\"), 100);\r\n}\r\n\r\nDWORD CGetSetOptions::FocusWndTimerTimeout()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"FocusWndTimerTimeout\"), 2000);\r\n}\r\n\r\nBOOL CGetSetOptions::GetConnectedToClipboard()\r\n{\r\n\treturn GetProfileLong(\"ConnectedToClipboard\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetConnectedToClipboard(BOOL val)\r\n{\r\n\tSetProfileLong(\"ConnectedToClipboard\", val);\r\n}\r\n\r\nDWORD CGetSetOptions::GetTextOnlyRestoreDelay()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"TextOnlyRestoreDelay\"), 2000);\r\n}\r\n\r\nDWORD CGetSetOptions::GetTextOnlyPasteDelay()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"TextOnlyPasteDelay\"), 0);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSetFocusToApp(CString csAppName)\r\n{\r\n\tCString focusCheck;\r\n\tfocusCheck = \"SetFocus_\";\r\n\tfocusCheck += csAppName;\r\n\treturn GetProfileLong(focusCheck, FALSE);\r\n}\r\n\r\nDWORD CGetSetOptions::SelectedIndex()\r\n{\r\n\treturn (DWORD)GetProfileLong(_T(\"SelectedIndex\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetSelectedIndex(int val)\r\n{\r\n\tSetProfileLong(_T(\"SelectedIndex\"), val);\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyAppInclude(CString csAppName)\r\n{\r\n\tSetProfileString(_T(\"CopyAppInclude\"), csAppName);\r\n}\r\n\r\nCString CGetSetOptions::GetCopyAppInclude()\r\n{\r\n\tCString includeApp = GetProfileString(_T(\"CopyAppInclude\"), \"*\");\r\n\tif(includeApp == \"\")\r\n\t{\r\n\t\tincludeApp = \"*\";\r\n\t}\r\n\r\n\treturn includeApp;\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyAppExclude(CString csAppName)\r\n{\r\n\tSetProfileString(_T(\"CopyAppExclude\"), csAppName);\r\n}\r\n\r\nCString CGetSetOptions::GetCopyAppExclude()\r\n{\r\n\treturn GetProfileString(_T(\"CopyAppExclude\"), \"\");\r\n}\r\n\r\nCString CGetSetOptions::GetCopyAppSeparator()\r\n{\r\n\treturn GetProfileString(_T(\"CopyAppSeparator\"), \";\");\r\n}\r\n\r\nDWORD CGetSetOptions::GetNoFormatsRetryDelay()\r\n{\r\n\treturn GetProfileLong(_T(\"NoFormatsRetryDelay\"), 200);\r\n}\r\n\r\nDWORD CGetSetOptions::GetMainDeletesDeleteCount()\r\n{  \r\n\treturn GetProfileLong(_T(\"MainDeletesDeleteCount\"), 100);\r\n}\r\n\r\nDWORD CGetSetOptions::GetIdleSecondsBeforeDelete()\r\n{  \r\n\treturn GetProfileLong(_T(\"IdleSecondsBeforeDelete\"), 60*10);\r\n}\r\n\r\nDWORD CGetSetOptions::GetDbTimeout()\r\n{  \r\n\treturn GetProfileLong(_T(\"DbTimeout\"), 5000);\r\n}\r\n\r\nDWORD CGetSetOptions::GetFunnyTickCountAdjustment()\r\n{  \r\n\treturn GetProfileLong(_T(\"FunnyTickCountAdjustment\"), 300001);\r\n}\r\n\r\nDWORD CGetSetOptions::GetMinIdleTimeBeforeTrackFocus()\r\n{\r\n\treturn GetProfileLong(_T(\"MinIdleTimeBeforeTrackFocus\"), 100);\r\n}\r\n\r\nDWORD CGetSetOptions::GetTimeBeforeExpandWindow()\r\n{\r\n\treturn GetProfileLong(_T(\"TimeBeforeExpandWindow\"), 250);\r\n}\r\n\r\nDWORD CGetSetOptions::GetUseGuiThreadInfoForFocus()\r\n{\r\n\treturn GetProfileLong(_T(\"UseGuiThreadInfoForFocus\"), 1);\r\n}\r\n\r\nvoid CGetSetOptions::SetSearchDescription(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"SearchDescription\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSearchDescription()\r\n{\r\n\treturn GetProfileLong(_T(\"SearchDescription\"), 1);\r\n}\r\n\r\nvoid CGetSetOptions::SetSearchFullText(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"SearchFullText\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSearchFullText()\r\n{\r\n\treturn GetProfileLong(_T(\"SearchFullText\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetSearchQuickPaste(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"SearchQuickPaste\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSearchQuickPaste()\r\n{\r\n\treturn GetProfileLong(_T(\"SearchQuickPaste\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetSimpleTextSearch(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"SimpleTextSearch\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSimpleTextSearch()\r\n{\r\n\treturn GetProfileLong(_T(\"SimpleTextSearch\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetRegExTextSearch(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"RegExTextSearch\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetRegExTextSearch()\r\n{\r\n\treturn GetProfileLong(_T(\"RegExTextSearch\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetMoveClipsOnGlobal10(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"MoveClipsOnGlobal10\"), val);\r\n}\r\nBOOL CGetSetOptions::GetMoveClipsOnGlobal10()\r\n{\r\n\treturn GetProfileLong(_T(\"MoveClipsOnGlobal10\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowScrollBar(BOOL val)\r\n{\r\n\tm_showScrollBar = val;\r\n\tSetProfileLong(_T(\"ShowScrollBar\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowScrollBar()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowScrollBar\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetPasteAsAdmin(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"PasteAsAdmin\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetPasteAsAdmin()\r\n{\r\n\treturn GetProfileLong(_T(\"PasteAsAdmin\"), 1);\r\n}\r\n\r\nvoid CGetSetOptions::SetRememberDescPos(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"RememberDescPos\"), val);\r\n}\r\nBOOL CGetSetOptions::GetRememberDescPos()\r\n{\r\n\treturn GetProfileLong(_T(\"RememberDescPos\"), FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetSizeDescWindowToContent(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"SizeDescWindowToContent\"), val);\r\n}\r\nBOOL CGetSetOptions::GetSizeDescWindowToContent()\r\n{\r\n\treturn GetProfileLong(_T(\"SizeDescWindowToContent\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetScaleImagesToDescWindow(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"ScaleImagesToDescWindow\"), val);\r\n}\r\nBOOL CGetSetOptions::GetScaleImagesToDescWindow()\r\n{\r\n\treturn GetProfileLong(_T(\"ScaleImagesToDescWindow\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetDescWndPoint(CPoint point)\r\n{\r\n\tSetResolutionProfileLong(\"DescWndX\", point.x);\r\n\tSetResolutionProfileLong(\"DescWndY\", point.y);\r\n}\r\n\r\nvoid CGetSetOptions::GetDescWndPoint(CPoint &point)\r\n{\r\n\tpoint.x = GetResolutionProfileLong(\"DescWndX\", 100);\r\n\tpoint.y = GetResolutionProfileLong(\"DescWndY\", 100);\r\n}\r\n\r\nvoid CGetSetOptions::GetDescWndSize(CSize &size)\r\n{\r\n\tsize.cx = GetResolutionProfileLong(\"DescWndCX\", 300);\r\n\tsize.cy = GetResolutionProfileLong(\"DescWndCY\", 300);\r\n\tif(size.cx <= 0 && size.cy <= 0)\r\n\t{\r\n\t\tsize.cx = 300;\r\n\t\tsize.cy = 300;\r\n\t}\r\n}\r\n\r\nvoid CGetSetOptions::SetDescWndSize(CSize size)\r\n{\r\n\tSetResolutionProfileLong(\"DescWndCX\", size.cx);\r\n\tSetResolutionProfileLong(\"DescWndCY\", size.cy);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowInTaskBar(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"ShowInTaskBar\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowInTaskBar()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowInTaskBar\"), FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetDiffApp(CString val)\r\n{\r\n\tSetProfileString(_T(\"DiffApp\"), val);\r\n}\r\n\r\nCString\tCGetSetOptions::GetDiffApp()\r\n{\r\n\treturn GetProfileString(_T(\"DiffApp\"), _T(\"\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetQRCodeBorderPixels(int val)\r\n{\r\n\tSetProfileLong(_T(\"QRCodeBorderPixels\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetQRCodeBorderPixels()\r\n{\r\n\treturn GetProfileLong(_T(\"QRCodeBorderPixels\"), 30);\r\n}\r\n\r\nCString\tCGetSetOptions::GetTranslateUrl()\r\n{\r\n\treturn GetProfileString(_T(\"TranslateUrl\"), _T(\"https://translate.google.com/?text=%s\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetNetworkReadTimeoutMS(int val)\r\n{\r\n\tSetProfileLong(_T(\"NetworkReadTimeoutMS\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetNetworkReadTimeoutMS()\r\n{\r\n\treturn GetProfileLong(_T(\"NetworkReadTimeoutMS\"), 30000);\r\n}\r\n\r\nvoid CGetSetOptions::SetRequestFilesUsingIP(int val)\r\n{\r\n\tSetProfileLong(_T(\"RequestFilesUsingIP\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetRequestFilesUsingIP()\r\n{\r\n\treturn GetProfileLong(_T(\"RequestFilesUsingIP\"), 0);\r\n}\r\n\r\nint CGetSetOptions::ReadRandomFileInterval()\r\n{\r\n\treturn GetProfileLong(_T(\"ReadRandomFileInterval\"), 60);\r\n}\r\n\r\nint CGetSetOptions::ReadRandomFileIdleMin()\r\n{\r\n\treturn GetProfileLong(_T(\"ReadRandomFileIdleMin\"), 30);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowGroupsInMainList()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowGroupsInMainList\"), 0);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowGroupsInMainList(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"ShowGroupsInMainList\"), val);\r\n}\r\n\r\nvoid CGetSetOptions::SetGroupDoubleClickTimeMS(int val)\r\n{\r\n\tSetProfileLong(_T(\"GroupDoubleClickTimeMS\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetGroupDoubleClickTimeMS()\r\n{\r\n\treturn GetProfileLong(_T(\"GroupDoubleClickTimeMS\"), 500);\r\n}\r\n\r\nvoid CGetSetOptions::SetSaveToGroupTimeoutMS(int val)\r\n{\r\n\tSetProfileLong(_T(\"SaveToGroupTimeoutMS\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetSaveToGroupTimeoutMS()\r\n{\r\n\treturn GetProfileLong(_T(\"SaveToGroupTimeoutMS\"), 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyReasonTimeoutMS(int val)\r\n{\r\n\tSetProfileLong(_T(\"CopyReasonTimeoutMS\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetCopyReasonTimeoutMS()\r\n{\r\n\treturn GetProfileLong(_T(\"CopyReasonTimeoutMS\"), 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetWindowsResumeDelayReOpenDbMS(int val)\r\n{\r\n\tSetProfileLong(_T(\"WindowsResumeDelayReOpenDbMS\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetWindowsResumeDelayReOpenDbMS()\r\n{\r\n\treturn GetProfileLong(_T(\"WindowsResumeDelayReOpenDbMS\"), 2000);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowMsgWndOnCopyToGroup()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowMsgWndOnCopyToGroup\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowMsgWndOnCopyToGroup(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"ShowMsgWndOnCopyToGroup\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetActionShortCutA(DWORD action, int pos, CString refData)\r\n{\r\n\tCString actionText;\r\n\tif (refData != _T(\"\"))\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%s_%d_A\"), action, refData, pos);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%d_A\"), action, pos);\r\n\t}\r\n\tint ret = GetProfileLong(actionText, -1);\r\n\tif (ret == -1)\r\n\t{\r\n\t\tret = ActionEnums::GetDefaultShortCutKeyA((ActionEnums::ActionEnumValues)action, pos);\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CGetSetOptions::SetActionShortCutA(int action, DWORD shortcut, int pos, CString refData)\r\n{\r\n\tCString actionText;\r\n\tif (refData != _T(\"\"))\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%s_%d_A\"), action, refData, pos);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%d_A\"), action, pos);\r\n\t}\r\n\tSetProfileLong(actionText, shortcut);\r\n}\r\n\r\nint CGetSetOptions::GetActionShortCutB(DWORD action, int pos, CString refData)\r\n{\r\n\tCString actionText;\r\n\tif (refData != _T(\"\"))\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%s_%d_B\"), action, refData, pos);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%d_B\"), action, pos);\r\n\t}\r\n\tint ret = GetProfileLong(actionText, -1);\r\n\tif (ret == -1)\r\n\t{\r\n\t\tret = ActionEnums::GetDefaultShortCutKeyB((ActionEnums::ActionEnumValues)action, pos);\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CGetSetOptions::SetActionShortCutB(int action, DWORD shortcut, int pos, CString refData)\r\n{\r\n\tCString actionText;\r\n\tif (refData != _T(\"\"))\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%s_%d_B\"), action, refData, pos);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tactionText.Format(_T(\"QP_ShortCut_%d_%d_B\"), action, pos);\r\n\t}\r\n\tSetProfileLong(actionText, shortcut);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowAlwaysOnTopWarning()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowAlwaysOnTopWarning\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowAlwaysOnTopWarning(BOOL show)\r\n{\r\n\tm_bShowAlwaysOnTopWarning = show;\r\n\tSetProfileLong(_T(\"ShowAlwaysOnTopWarning\"), show);\r\n}\r\n\r\nBOOL CGetSetOptions::GetUseIPFromAccept()\r\n{\r\n\treturn GetProfileLong(_T(\"UseIPFromAccept\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetUseIPFromAccept(BOOL useAccept)\r\n{\r\n\tSetProfileLong(_T(\"UseIPFromAccept\"), useAccept);\r\n}\r\n\r\nint CGetSetOptions::GetDragId()\r\n{\r\n\treturn GetProfileLong(_T(\"DragId\"), 1);\r\n}\r\n\r\nvoid CGetSetOptions::SetDragId(int id)\r\n{\r\n\tSetProfileLong(_T(\"DragId\"), id);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowIfClipWasPasted()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowIfClipWasPasted\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowIfClipWasPasted(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"ShowIfClipWasPasted\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetLastGroupToggle()\r\n{\r\n\treturn GetProfileLong(_T(\"LastGroupToggle\"), -2);\r\n}\r\n\r\nvoid CGetSetOptions::SetLastGroupToggle(int val)\r\n{\r\n\tSetProfileLong(_T(\"LastGroupToggle\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetMouseClickHidesDescription()\r\n{\r\n\treturn GetProfileLong(_T(\"MouseClickHidesDescription\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetMouseClickHidesDescription(int val)\r\n{\r\n\tSetProfileLong(_T(\"MouseClickHidesDescription\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetWrapDescriptionText()\r\n{\r\n\treturn GetProfileLong(_T(\"WrapDescriptionText\"), FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetWrapDescriptionText(int val)\r\n{\r\n\tSetProfileLong(_T(\"WrapDescriptionText\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetUseUISelectedGroupForLastTenCopies()\r\n{\r\n\treturn GetProfileLong(_T(\"UseUISelectedGroupForLastTenCopies\"), FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetUseUISelectedGroupForLastTenCopies(int val)\r\n{\r\n\tSetProfileLong(_T(\"UseUISelectedGroupForLastTenCopies\"), val);\r\n}\r\n\r\n\r\nint CGetSetOptions::GetDelayRenderLockout()\r\n{\r\n\treturn GetProfileLong(_T(\"DelayRenderLockout\"), 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetDelayRenderLockout(int val)\r\n{\r\n\tSetProfileLong(_T(\"DelayRenderLockout\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetAdjustClipsForCRC()\r\n{\r\n\treturn GetProfileLong(_T(\"AdjustClipsForCRC\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetAdjustClipsForCRC(int val)\r\n{\r\n\tSetProfileLong(_T(\"AdjustClipsForCRC\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetCheckMd5OnFileTransfers()\r\n{\r\n\treturn GetProfileLong(_T(\"CheckMd5OnFileTransfers\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetCheckMd5OnFileTransfers(int val)\r\n{\r\n\tSetProfileLong(_T(\"CheckMd5OnFileTransfers\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetBalloonTimeout()\r\n{\r\n\treturn GetProfileLong(_T(\"BalloonTimeout\"), 2500);\r\n}\r\n\r\nvoid CGetSetOptions::SetBalloonTimeout(int val)\r\n{\r\n\tSetProfileLong(_T(\"BalloonTimeout\"), val);\r\n}\r\n\r\nvoid CGetSetOptions::SetCustomSendToList(CString val)\r\n{\r\n\tSetProfileString(_T(\"CustomSendToList2\"), val);\r\n}\r\n\r\nCString\tCGetSetOptions::GetCustomSendToList()\r\n{\r\n\treturn GetProfileString(\"CustomSendToList2\", \"\");\r\n}\r\n\r\nint CGetSetOptions::GetMaxFileContentsSize()\r\n{\r\n\treturn GetProfileLong(_T(\"MaxFileContentsSize\"), 64000000);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaxFileContentsSize(int val)\r\n{\r\n\tSetProfileLong(_T(\"MaxFileContentsSize\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetErrorMsgPopupTimeout()\r\n{\r\n\treturn GetProfileLong(_T(\"ErrorMsgPopupTimeout\"), 3500);\r\n}\r\n\r\nvoid CGetSetOptions::SetErrorMsgPopupTimeout(int val)\r\n{\r\n\tSetProfileLong(_T(\"ErrorMsgPopupTimeout\"), val);\r\n}\r\n\r\nvoid CGetSetOptions::SetRegexFilter(CString val, int pos)\r\n{\r\n\tCString cs;\r\n\tcs.Format(_T(\"RegexFilter_%d\"), pos);\r\n\r\n\tm_regexHelper.SetRegEx(pos, std::wstring(val));\r\n\r\n\tSetProfileString(cs, val);\r\n}\r\n\r\nCString\tCGetSetOptions::GetRegexFilter(int pos)\r\n{\r\n\tCString cs;\r\n\tcs.Format(_T(\"RegexFilter_%d\"), pos);\r\n\treturn GetProfileString(cs, \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetRegexFilterByProcessName(CString val, int pos)\r\n{\r\n\tCString cs;\r\n\tcs.Format(_T(\"RegexFilterByProcessName_%d\"), pos);\r\n\r\n\tm_regexHelper.SetProcessFilter(pos, val);\r\n\r\n\tSetProfileString(cs, val);\r\n}\r\n\r\nCString\tCGetSetOptions::GetRegexFilterByProcessName(int pos)\r\n{\r\n\tCString cs;\r\n\tcs.Format(_T(\"RegexFilterByProcessName_%d\"), pos);\r\n\treturn GetProfileString(cs, \"\");\r\n}\r\n\r\nBOOL CGetSetOptions::GetOpenToGroupByActiveExe()\r\n{\r\n\treturn GetProfileLong(_T(\"OpenToGroupByActiveExe\"), FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetOpenToGroupByActiveExe(int val)\r\n{\r\n\tSetProfileLong(_T(\"OpenToGroupByActiveExe\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowStartupMessage()\r\n{\r\n\treturn GetProfileLong(_T(\"ShowStartupMessage\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowStartupMessage(int val)\r\n{\r\n\tSetProfileLong(_T(\"ShowStartupMessage\"), val);\r\n}\r\n\r\nCString CGetSetOptions::GetCopyScriptsXml()\r\n{\r\n\treturn GetProfileString(\"CopyScriptsXml\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyScriptsXml(CString val)\r\n{\r\n\tm_copyScripts.Load(val);\r\n\tSetProfileString(_T(\"CopyScriptsXml\"), val);\r\n}\r\n\r\nCString CGetSetOptions::GetPasteScriptsXml()\r\n{\r\n\treturn GetProfileString(\"PasteScriptsXml\", \"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetPasteScriptsXml(CString val)\r\n{\r\n\tm_pasteScripts.Load(val);\r\n\tSetProfileString(_T(\"PasteScriptsXml\"), val);\r\n}\r\n\r\nlong CGetSetOptions::GetToolTipTimeout()\r\n{\r\n\treturn GetProfileLong(\"ToolTipTimeout\", -1);\r\n}\r\n\r\nvoid CGetSetOptions::SetToolTipTimeout(long val)\r\n{\r\n\tm_tooltipTimeout = val;\r\n\tSetProfileLong(\"ToolTipTimeout\", val);\r\n}\r\n\r\nCString CGetSetOptions::GetPastSearchXml()\r\n{\r\n\t//max this out at 1000, this should be more than the allowed length in SymbolEdit.cpp\r\n\t//had reports of this being really large and causing memory issues, this will prevent us from this\r\n\treturn GetProfileString(\"PastSearchXml\", \"\", \"\", 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetPastSearchXml(CString val)\r\n{\r\n\tSetProfileString(_T(\"PastSearchXml\"), val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetShowMsgWhenReceivingManualSentClip()\r\n{\r\n\treturn GetProfileLong(\"ShowMsgWhenReceivingManualSentClip\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetShowMsgWhenReceivingManualSentClip(BOOL val)\r\n{\r\n\tSetProfileLong(\"ShowMsgWhenReceivingManualSentClip\", val);\r\n}\r\n\r\n\r\nBOOL CGetSetOptions::GetCleanRTFBeforeDrawing()\r\n{\r\n\treturn GetProfileLong(\"CleanRTFBeforeDrawing\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetCleanRTFBeforeDrawing(BOOL val)\r\n{\r\n\tm_cleanRTFBeforeDrawing = true;\r\n\tSetProfileLong(\"CleanRTFBeforeDrawing\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetDisableExpireClipsConfig()\r\n{\r\n\treturn GetProfileLong(\"DisableExpireClipsConfig\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetDisableExpireClipsConfig(BOOL val)\r\n{\r\n\tSetProfileLong(\"DisableExpireClipsConfig\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetRevertToTopLevelGroup()\r\n{\r\n\treturn GetProfileLong(\"RevertToTopLevelGroup\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetRevertToTopLevelGroup(BOOL val)\r\n{\r\n\tSetProfileLong(\"RevertToTopLevelGroup\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetUpdateClipOrderOnCtrlC()\r\n{\r\n\treturn GetProfileLong(\"UpdateClipOrderOnCtrlC\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetUpdateClipOrderOnCtrlC(BOOL val)\r\n{\r\n\tSetProfileLong(\"UpdateClipOrderOnCtrlC\", val);\r\n}\r\n\r\nint CGetSetOptions::GetMaxToolTipLines()\r\n{\r\n\treturn GetProfileLong(\"MaxToolTipLines\", 30);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaxToolTipLines(int val)\r\n{\r\n\tSetProfileLong(\"MaxToolTipLines\", val);\r\n}\r\n\r\nint CGetSetOptions::GetMaxToolTipCharacters()\r\n{\r\n\treturn GetProfileLong(\"MaxToolTipCharacters\", 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaxToolTipCharacters(int val)\r\n{\r\n\tSetProfileLong(\"MaxToolTipCharacters\", val);\r\n}\r\n\r\nint CGetSetOptions::GetDoubleKeyStrokeTimeout()\r\n{\r\n\treturn GetProfileLong(\"DoubleKeyStrokeTimeout\", 350);\r\n}\r\n\r\nvoid CGetSetOptions::SetDoubleKeyStrokeTimeout(int val)\r\n{\r\n\tm_doubleKeyStrokeTimeout = val;\r\n\tSetProfileLong(\"DoubleKeyStrokeTimeout\", val);\r\n}\r\n\r\nint CGetSetOptions::GetFirstTenHotKeysStart()\r\n{\r\n\treturn GetProfileLong(\"FirstTenHotKeysStart\", 1);\r\n}\r\n\r\nvoid CGetSetOptions::SetFirstTenHotKeysStart(int val)\r\n{\r\n\tm_firstTenHotKeysStart = val;\r\n\tSetProfileLong(\"FirstTenHotKeysStart\", val);\r\n}\r\n\r\nint CGetSetOptions::GetFirstTenHotKeysFontSize()\r\n{\r\n\treturn GetProfileLong(\"FirstTenHotKeysFontSize\", 5);\r\n}\r\n\r\nvoid CGetSetOptions::SetFirstTenHotKeysFontSize(int val)\r\n{\r\n\tm_firstTenHotKeysFontSize = val;\r\n\tSetProfileLong(\"FirstTenHotKeysFontSize\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetAddCFHDROP_OnDrag()\r\n{\r\n\treturn GetProfileLong(_T(\"AddCFHDROP_OnDrag\"), TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetAddCFHDROP_OnDrag(BOOL val)\r\n{\r\n\tSetProfileLong(_T(\"AddCFHDROP_OnDrag\"), val);\r\n}\r\n\r\nint CGetSetOptions::GetCopyAndSveDelay()\r\n{\r\n\treturn GetProfileLong(\"CopyAndSveDelay\", 1000);\r\n}\r\n\r\nvoid CGetSetOptions::SetCopyAndSveDelay(int val)\r\n{\r\n\tSetProfileLong(\"CopyAndSveDelay\", val);\r\n}\r\n\r\nint CGetSetOptions::GetEditorDefaultFontSize()\r\n{\r\n\treturn GetProfileLong(\"EditorDefaultFontSize\", 14);\r\n}\r\n\r\nvoid CGetSetOptions::SetEditorDefaultFontSize(int val)\r\n{\r\n\tSetProfileLong(\"EditorDefaultFontSize\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetMoveSelectionOnOpenHotkey()\r\n{\r\n\treturn GetProfileLong(\"MoveSelectionOnOpenHotkey\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetMoveSelectionOnOpenHotkey(BOOL val)\r\n{\r\n\tm_moveSelectionOnOpenHotkey = val;\r\n\tSetProfileLong(\"MoveSelectionOnOpenHotkey\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetAllowBackToBackDuplicates()\r\n{\r\n\treturn GetProfileLong(\"AllowBackToBackDuplicates\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetAllowBackToBackDuplicates(BOOL val)\r\n{\r\n\tm_allowBackToBackDuplicates = val;\r\n\tSetProfileLong(\"AllowBackToBackDuplicates\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetMaintainSearchView()\r\n{\r\n\treturn GetProfileLong(\"MaintainSearchView\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetMaintainSearchView(BOOL val)\r\n{\r\n\tm_maintainSearchView = val;\r\n\tSetProfileLong(\"MaintainSearchView\", val);\r\n}\r\n\r\nCString CGetSetOptions::GetNetworkBindIPAddress()\r\n{\r\n\treturn GetProfileString(\"NetworkBindIPAddress\", \"*\");\r\n}\r\n\r\nvoid CGetSetOptions::SetNetworkBindIPAddress(CString val)\r\n{\r\n\tSetProfileString(\"NetworkBindIPAddress\", val);\r\n}\r\n\r\nCString CGetSetOptions::GetTempDragFileName()\r\n{\r\n\tauto diff = CTime::GetCurrentTime() - m_tempDragFileNameSetTime;\r\n\tif (diff.GetTotalSeconds() < 60 * 2)\r\n\t{\r\n\t\treturn m_tempDragFileName;\r\n\t}\r\n\r\n\treturn _T(\"\");\r\n}\r\n\r\nvoid CGetSetOptions::SetTempDragFileName(CString val)\r\n{\r\n\tm_tempDragFileName = val;\r\n\tm_tempDragFileNameSetTime = CTime::GetCurrentTime();\r\n}\r\n\r\nBOOL CGetSetOptions::GetRefreshViewAfterPasting()\r\n{\r\n\treturn GetProfileLong(\"RefreshViewAfterPasting\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetRefreshViewAfterPasting(BOOL val)\r\n{\r\n\tm_refreshViewAfterPasting = val;\r\n\tSetProfileLong(\"RefreshViewAfterPasting\", val);\r\n}\r\n\r\n\r\nCString CGetSetOptions::GetSlugifySeparator()\r\n{\r\n\treturn GetProfileString(\"SlugifySeparator\", _T(\"-\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetSlugifySeparator(CString val)\r\n{\r\n\tSetProfileString(\"SlugifySeparator\", val);\r\n}\r\n\r\nBOOL CGetSetOptions::GetSupportAllTypes()\r\n{\r\n\treturn GetProfileLong(\"SupportAllTypes\", FALSE);\r\n}\r\n\r\nvoid CGetSetOptions::SetSupportAllTypes(BOOL val)\r\n{\r\n\tm_refreshViewAfterPasting = val;\r\n\tSetProfileLong(\"SupportAllTypes\", val);\r\n}\r\n\r\nCString CGetSetOptions::GetIgnoreAnnoyingCFDIB(BOOL useCache)\r\n{\r\n\tif (useCache)\r\n\t\treturn m_ignoreAnnoyingCFDIB;\r\n\telse\r\n\t\treturn GetProfileString(\"IgnoreAnnoyingCFDIB\", _T(\"\"));\r\n}\r\n\r\nvoid CGetSetOptions::SetIgnoreAnnoyingCFDIB(CString val)\r\n{\r\n\tm_ignoreAnnoyingCFDIB = val;\r\n\tSetProfileString(\"IgnoreAnnoyingCFDIB\", val);\r\n}\r\n\r\nset<CString> CGetSetOptions::GetIgnoreAnnoyingCFDIBSet(BOOL useCache)\r\n{\r\n\tCString rawString = CGetSetOptions::GetIgnoreAnnoyingCFDIB(useCache);\r\n\tset<CString> processSet;\r\n\tCTokenizer token(rawString, _T(\";\"));\r\n\tCString process;\r\n\twhile (token.Next(process))\r\n\t{\r\n\t\tif (process == \"\")\r\n\t\t\tcontinue;\r\n\t\tprocessSet.insert(process.MakeLower());\r\n\t}\r\n\r\n\treturn processSet;\r\n}\r\n\r\nBOOL CGetSetOptions::GetRegexCaseInsensitive()\r\n{\r\n\treturn GetProfileLong(\"RegexCaseInsensitive\", TRUE);\r\n}\r\n\r\nvoid CGetSetOptions::SetRegexCaseInsensitive(BOOL val)\r\n{\r\n\tSetProfileLong(\"RegexCaseInsensitive\", val);\r\n}\r\n\r\nvoid CGetSetOptions::SetDrawCopiedColorCode(long bDraw)\r\n{\r\n\tSetProfileLong(\"DrawCopiedColorCode\", bDraw);\r\n\tm_bDrawCopiedColorCode = bDraw;\r\n}\r\n\r\nBOOL CGetSetOptions::GetDrawCopiedColorCode()\r\n{\r\n\tBOOL drawCopiedColorCode = TRUE;\r\n\treturn GetProfileLong(\"DrawCopiedColorCode\", drawCopiedColorCode);\r\n}\r\n\r\nvoid CGetSetOptions::SetCenterWindowBelowCursorOrCaret(BOOL center)\r\n{\r\n\tSetProfileLong(\"CenterWindowBelowCursorOrCaret\", center);\r\n\tm_centerWindowBelowCursorOrCaret = center;\r\n}\r\n\r\nBOOL CGetSetOptions::GetCenterWindowBelowCursorOrCaret()\r\n{\r\n\tBOOL centerWindowBelowCursorOrCaret = FALSE;\r\n\treturn GetProfileLong(\"CenterWindowBelowCursorOrCaret\", centerWindowBelowCursorOrCaret);\r\n}\r\n\r\nBOOL CGetSetOptions::SetTextEditorPath(CString path)\r\n{\r\n\treturn SetProfileString(\"TextEditorPath\", path);\r\n}\r\n\r\nCString CGetSetOptions::GetTextEditorPath()\r\n{\r\n\treturn GetProfileString(\"TextEditorPath\", _T(\"\"));\r\n}\r\n\r\nBOOL CGetSetOptions::SetRTFEditorPath(CString path)\r\n{\r\n\treturn SetProfileString(\"RTFEditorPath\", path);\r\n}\r\n\r\nCString CGetSetOptions::GetRTFEditorPath()\r\n{\r\n\treturn GetProfileString(\"RTFEditorPath\", _T(\"\"));\r\n}\r\n\r\nBOOL CGetSetOptions::SetQRCodeUrl(CString path)\r\n{\r\n\treturn SetProfileString(\"QRCodeUrl\", path);\r\n}\r\n\r\nCString CGetSetOptions::GetQRCodeUrl()\r\n{\r\n\tauto defaultUrl = _T(\"https://zxing.org/w/chart?cht=qr&chs=500x500&chl=\");\r\n\tauto url = GetProfileString(\"QRCodeUrl\", defaultUrl);\r\n\tif (url == _T(\"\"))\r\n\t{\r\n\t\turl = defaultUrl;\r\n\t}\r\n\r\n\treturn url;\r\n}"
        },
        {
          "name": "Options.h",
          "type": "blob",
          "size": 20.7509765625,
          "content": "#pragma once\r\n\r\n#include \"Theme.h\"\r\n#include \"RegExFilterHelper.h\"\r\n#include \"ChaiScriptXml.h\"\r\n#include <set>\r\n\r\n#define MAX_SEND_CLIENTS\t15\r\nclass CSendClients\r\n{\r\npublic:\r\n\tCSendClients()\r\n\t{\r\n\t\tbSendAll = FALSE;\r\n\t\tbShownFirstError = FALSE;\r\n\t}\r\n\tBOOL bSendAll;\r\n\tCString csIP;\r\n\tCString csDescription;\r\n\tBOOL bShownFirstError;\r\n};\r\n\r\n#define MAX_COPY_BUFFER\t3\r\nclass CCopyBufferItem\r\n{\r\npublic:\r\n\tCCopyBufferItem()\r\n\t{\r\n\t\tm_lCopyHotKey = -1;\r\n\t\tm_lPasteHotKey = -1;\r\n\t\tm_lCutHotKey = -1;\r\n\t\tm_bPlaySoundOnCopy = FALSE;\r\n\t}\r\n\tlong m_lCopyHotKey;\r\n\tlong m_lPasteHotKey;\r\n\tlong m_lCutHotKey;\r\n\tBOOL m_bPlaySoundOnCopy;\r\n};\r\n\r\n#define REG_PATH\t\t\t\t\t\"Software\\\\Ditto\"\r\n\r\n#define POS_AT_CARET\t1\r\n#define POS_AT_CURSOR\t2\r\n#define POS_AT_PREVIOUS\t3\r\n\r\n#define CAPTION_RIGHT\t1\r\n#define CAPTION_BOTTOM\t2\r\n#define CAPTION_LEFT\t3\r\n#define CAPTION_TOP\t\t4\r\n\r\n#define TOGGLES_ALLWAYS_ON_TOP\t\t\t\t1\r\n#define TOGGLES_ALLWAYS_SHOW_DESCRIPTION\t2\r\n#define\tROLLES_UP_WINDOW\t\t\t\t\t3\r\n\r\n#define PATH_HELP\t\t\t0\r\n#define PATH_REMOTE_FILES\t1\r\n#define PATH_LOG_FILE\t\t2\r\n#define PATH_LANGUAGE\t\t3\r\n#define PATH_THEMES\t\t\t8\r\n#define PATH_ADDINS\t\t\t9\r\n#define PATH_DRAG_FILES\t\t10\r\n#define PATH_CLIP_DIFF\t\t11\r\n#define PATH_RESTORE_TEMP\t12\r\n#define PATH_EDIT_CLIPS\t\t13\r\n\r\nclass CGetSetOptions\r\n{\r\npublic:\r\n\tCGetSetOptions();\r\n\tvirtual ~CGetSetOptions();\r\n\r\n\tstatic bool m_bFromIni;\r\n\tstatic CString m_csIniFileName;\r\n\tstatic bool m_bInConversion;\r\n\tstatic CTheme m_Theme;\r\n\tstatic bool m_portable;\r\n\tstatic bool m_windowsApp;\r\n\tstatic bool m_chocolateyApp;\r\n\r\n\tstatic void LoadSettings();\r\n\tstatic CString GetIniFileName(bool bLocalIniFile);\r\n\tstatic void ConverSettingsToIni();\r\n\tstatic CString GetAppDataPath();\r\n\tstatic CString GetTempFilePath();\r\n\tstatic void CreateIniFile(CString path);\r\n\r\n\tstatic CString GetExeFileName();\r\n\tstatic CString GetAppName();\r\n\r\n\tstatic BOOL GetShowIconInSysTray();\r\n\tstatic BOOL SetShowIconInSysTray(BOOL bShow);\r\n\r\n\tstatic BOOL GetRunOnStartUp();\r\n\tstatic void SetRunOnStartUp(BOOL bRun);\r\n\r\n\tstatic BOOL SetProfileFont(CString csSection, LOGFONT &font);\r\n\tstatic BOOL GetProfileFont(CString csSection, LOGFONT &font);\r\n\r\n\tstatic long GetResolutionProfileLong(CString csName, long lDefaultValue, CString csNewPath = _T(\"\"));\r\n\tstatic BOOL SetResolutionProfileLong(CString csName, long lValue);\r\n\r\n\tstatic BOOL SetProfileLong(CString csName, long lValue);\r\n\tstatic long GetProfileLong(CString csName, long lDefaultValue = -1, CString csNewPath = _T(\"\"));\r\n\r\n\tstatic CString GetProfileString(CString csName, CString csDefault, CString csNewPath = _T(\"\"), int maxSize = -1);\r\n\tstatic BOOL\tSetProfileString(CString csName, CString csValue);\r\n\r\n\tstatic LPVOID GetProfileData(CString csName, DWORD &dwLength);\r\n\tstatic BOOL\tSetProfileData(CString csName, LPVOID lpData, DWORD dwLength);\r\n\r\n\tstatic BOOL SetQuickPasteSize(CSize size);\r\n\tstatic void GetQuickPasteSize(CSize &size);\r\n\r\n\tstatic BOOL SetQuickPastePoint(CPoint point);\r\n\tstatic void GetQuickPastePoint(CPoint &point);\r\n\r\n\tstatic BOOL SetEnableTransparency(BOOL bCheck);\r\n\tstatic BOOL GetEnableTransparency();\r\n\r\n\tstatic BOOL SetTransparencyPercent(long lPercent);\r\n\tstatic long GetTransparencyPercent();\r\n\r\n\tstatic long m_nLinesPerRow;\r\n\tstatic BOOL SetLinesPerRow(long lLines);\r\n\tstatic long GetLinesPerRow();\r\n\r\n\tstatic BOOL SetQuickPastePosition(long lPosition);\r\n\tstatic long GetQuickPastePosition();\r\n\r\n\tstatic long GetCopyGap();\r\n\tstatic void SetCopyGap(long lGap);\r\n\r\n\tstatic BOOL SetDBPath(CString csPath);\r\n\tstatic CString GetDBPath(bool resolvePath = true);\r\n\tstatic CString ResolvePath(CString path);\r\n\r\n\tstatic BOOL SetDBPathOld(CString csPath);\r\n\tstatic CString GetDBPathOld();\r\n\r\n\tstatic void SetCheckForMaxEntries(BOOL bVal);\r\n\tstatic BOOL GetCheckForMaxEntries();\r\n\r\n\tstatic void SetCheckForExpiredEntries(BOOL bVal);\r\n\tstatic BOOL GetCheckForExpiredEntries();\r\n\r\n\tstatic void SetMaxEntries(long lVal);\r\n\tstatic long GetMaxEntries();\r\n\r\n\tstatic void SetExpiredEntries(long lVal);\r\n\tstatic long GetExpiredEntries();\r\n\r\n\tstatic void SetTripCopyCount(long lVal);\r\n\tstatic long GetTripCopyCount();\r\n\r\n\tstatic void SetTripPasteCount(long lVal);\r\n\tstatic long GetTripPasteCount();\r\n\r\n\tstatic void SetTripDate(long lDate);\r\n\tstatic long GetTripDate();\r\n\r\n\tstatic void SetTotalCopyCount(long lVal);\r\n\tstatic long GetTotalCopyCount();\r\n\r\n\tstatic void SetTotalPasteCount(long lVal);\r\n\tstatic long GetTotalPasteCount();\r\n\r\n\tstatic void SetTotalDate(long lDate);\r\n\tstatic long GetTotalDate();\r\n\r\n\tstatic CString\tGetUpdateFilePath();\r\n\tstatic BOOL\t\tSetUpdateFilePath(CString cs);\r\n\r\n\tstatic CString\tGetUpdateInstallPath();\r\n\tstatic BOOL\t\tSetUpdateInstallPath(CString cs);\r\n\r\n\tstatic long\t\tGetLastUpdate();\r\n\tstatic long\t\tSetLastUpdate(long lValue);\r\n\r\n\tstatic BOOL\t\tGetCheckForUpdates();\r\n\tstatic BOOL\t\tSetCheckForUpdates(BOOL bCheck);\r\n\r\n\tstatic BOOL\t\tm_bUseCtrlNumAccel;\r\n\tstatic void\t\tSetUseCtrlNumForFirstTenHotKeys(BOOL bVal);\r\n\tstatic BOOL\t\tGetUseCtrlNumForFirstTenHotKeys();\r\n\r\n\tstatic BOOL\t\tm_bAllowDuplicates;\r\n\tstatic void\t\tSetAllowDuplicates(BOOL bVal);\r\n\tstatic BOOL\t\tGetAllowDuplicates();\r\n\r\n\tstatic BOOL\t\tm_bUpdateTimeOnPaste;\r\n\tstatic void\t\tSetUpdateTimeOnPaste(BOOL bVal);\r\n\tstatic BOOL\t\tGetUpdateTimeOnPaste();\r\n\r\n\tstatic BOOL\t\tm_bSaveMultiPaste;\r\n\tstatic void\t\tSetSaveMultiPaste(BOOL bVal);\r\n\tstatic BOOL\t\tGetSaveMultiPaste();\r\n\r\n\tstatic BOOL\t\tm_bShowPersistent;\r\n\tstatic void\t\tSetShowPersistent(BOOL bVal);\r\n\tstatic BOOL\t\tGetShowPersistent();\r\n\r\n\tstatic void\t\tSetShowTextForFirstTenHotKeys(BOOL bVal);\r\n\tstatic BOOL\t\tGetShowTextForFirstTenHotKeys();\r\n\r\n\tstatic void\t\tSetMainHWND(long lhWnd);\r\n\tstatic long\t\tGetMainHWND();\r\n\r\n\tstatic void\t\tSetCaptionPos(long lPos);\r\n\tstatic long\t\tGetCaptionPos();\r\n\r\n\tstatic void\t\tSetAutoHide(BOOL bAutoHide);\r\n\tstatic BOOL\t\tGetAutoHide();\r\n\r\n\tstatic long\t\tm_bDescTextSize;\r\n\tstatic void\t\tSetDescTextSize(long lSize);\r\n\tstatic long\t\tGetDescTextSize();\r\n\r\n\tstatic BOOL\t\tm_bDescShowLeadingWhiteSpace;\r\n\tstatic void\t\tSetDescShowLeadingWhiteSpace(BOOL bVal);\r\n\tstatic BOOL\t\tGetDescShowLeadingWhiteSpace();\r\n\r\n\tstatic BOOL\t\tm_bAllwaysShowDescription;\r\n\tstatic void\t\tSetAllwaysShowDescription(long bShow);\r\n\tstatic BOOL\t\tGetAllwaysShowDescription();\r\n\r\n\tstatic long\t\tm_bDoubleClickingOnCaptionDoes;\r\n\tstatic void\t\tSetDoubleClickingOnCaptionDoes(long lOption);\r\n\tstatic long\t\tGetDoubleClickingOnCaptionDoes();\r\n\r\n\tstatic BOOL\t\tm_bPrompForNewGroupName;\r\n\tstatic void\t\tSetPrompForNewGroupName(BOOL bOption);\r\n\tstatic BOOL\t\tGetPrompForNewGroupName();\r\n\r\n\tstatic BOOL\t\tm_bSendPasteOnFirstTenHotKeys;\r\n\tstatic void\t\tSetSendPasteOnFirstTenHotKeys(BOOL bOption);\r\n\tstatic BOOL\t\tGetSendPasteOnFirstTenHotKeys();\r\n\r\n\tstatic CSendClients m_SendClients[MAX_SEND_CLIENTS];\r\n\tstatic long\t\tm_lAutoSendClientCount;\r\n\tstatic void\t\tGetClientSendCount();\r\n\tstatic void\t\tSetSendClients(CSendClients Client, int nPos);\r\n\tstatic CSendClients\t\tGetSendClients(int nPos);\r\n\r\n\tstatic CString m_csIPListToPutOnClipboard;\r\n\tstatic CString\tGetListToPutOnClipboard();\r\n\tstatic BOOL\t\tSetListToPutOnClipboard(CString cs);\r\n\r\n\tstatic BOOL\t\tm_bLogSendReceiveErrors;\r\n\tstatic void\t\tSetLogSendReceiveErrors(BOOL bOption);\r\n\tstatic BOOL\t\tGetLogSendReceiveErrors();\r\n\r\n\tstatic BOOL\t\tm_HideDittoOnHotKeyIfAlreadyShown;\r\n\tstatic BOOL\t\tGetHideDittoOnHotKeyIfAlreadyShown();\r\n\tstatic void\t\tSetHideDittoOnHotKeyIfAlreadyShown(BOOL bVal);\r\n\r\n\tstatic long\t\tm_lPort;\r\n\tstatic void\t\tSetPort(long lPort);\r\n\tstatic long\t\tGetPort();\r\n\r\n\tstatic BOOL\t\tGetDisableRecieve();\r\n\tstatic void\t\tSetDisableRecieve(BOOL bVal);\r\n\r\n\tstatic BOOL\t\tGetFont(LOGFONT &font);\r\n\tstatic void\t\tSetFont(LOGFONT &font);\r\n\r\n\tstatic BOOL\t\tm_bDrawThumbnail;\r\n\tstatic void\t\tSetDrawThumbnail(long bDraw);\r\n\tstatic BOOL\t\tGetDrawThumbnail();\r\n\r\n\tstatic BOOL\t\tm_bFastThumbnailMode;\r\n\tstatic void\t\tSetFastThumbnailMode(BOOL bval);\r\n\tstatic BOOL\t\tGetFastThumbnailMode();\r\n\r\n\tstatic CStringA\tm_csPassword;\r\n\tstatic void\t\tSetNetworkPassword(CString csPassword);\r\n\tstatic CStringA\tGetNetworkPassword();\r\n\r\n\tstatic BOOL\t\tm_bDrawRTF;\r\n\tstatic void\t\tSetDrawRTF(long bDraw);\r\n\tstatic BOOL\t\tGetDrawRTF();\r\n\r\n\tstatic BOOL\t\tm_bMultiPasteReverse;\r\n\tstatic void\t\tSetMultiPasteReverse(BOOL bVal);\r\n\tstatic BOOL\t\tGetMultiPasteReverse();\r\n\r\n\tstatic CString\tm_csPlaySoundOnCopy;\r\n\tstatic void\t\tSetPlaySoundOnCopy(CString cs);\r\n\tstatic CString\tGetPlaySoundOnCopy();\r\n\r\n\tstatic BOOL\t\tm_bSendPasteMessageAfterSelection;\r\n\tstatic void\t\tSetSendPasteAfterSelection(BOOL bVal);\r\n\tstatic BOOL\t\tGetSendPasteAfterSelection();\r\n\r\n\tstatic BOOL\t\tm_bFindAsYouType;\r\n\tstatic void\t\tSetFindAsYouType(BOOL bVal);\r\n\tstatic BOOL\t\tGetFindAsYouType();\r\n\r\n\tstatic BOOL\t\tm_bEnsureEntireWindowCanBeSeen;\r\n\tstatic void\t\tSetEnsureEntireWindowCanBeSeen(BOOL bVal);\r\n\tstatic BOOL\t\tGetEnsureEntireWindowCanBeSeen();\r\n\r\n\tstatic BOOL\t\tm_bShowAllClipsInMainList;\r\n\tstatic void\t\tSetShowAllClipsInMainList(BOOL bVal);\r\n\tstatic BOOL\t\tGetShowAllClipsInMainList();\r\n\r\n\tstatic void\t\tSetExtraNetworkPassword(CString csPassword);\r\n\tstatic CString\tGetExtraNetworkPassword(bool bFillArray);\r\n\r\n\tstatic long\t\tm_lMaxClipSizeInBytes;\r\n\tstatic long\t\tGetMaxClipSizeInBytes();\r\n\tstatic void\t\tSetMaxClipSizeInBytes(long lSize);\r\n\r\n\tstatic CString\tGetLanguageFile();\r\n\tstatic void\t\tSetLanguageFile(CString csLanguage);\r\n\r\n\tstatic DWORD\tm_dwSaveClipDelay;\r\n\tstatic ULONG\tGetSaveClipDelay();\r\n\tstatic void\t\tSetSaveClipDelay(DWORD dwDelay);\r\n\r\n\tstatic long\t\tm_lProcessDrawClipboardDelay;\r\n\tstatic long\t\tGetProcessDrawClipboardDelay();\r\n\tstatic void\t\tSetProcessDrawClipboardDelay(long lDelay);\r\n\r\n\tstatic BOOL\t\tm_bEnableDebugLogging;\r\n\tstatic BOOL\t\tGetEnableDebugLogging();\r\n\tstatic void\t\tSetEnableDebugLogging(BOOL bEnable);\r\n\r\n\tstatic BOOL\t\tm_bEnsureConnectToClipboard;\r\n\tstatic BOOL\t\tGetEnsureConnectToClipboard();\r\n\tstatic void\t\tSetEnsureConnectToClipboard(BOOL bSet);\r\n\r\n\tstatic BOOL\t\tGetPromptWhenDeletingClips();\r\n\tstatic void\t\tSetPromptWhenDeletingClips(BOOL bSet);\r\n\r\n\tstatic CString\tGetLastImportDir();\r\n\tstatic void\t\tSetLastImportDir(CString csDir);\r\n\r\n\tstatic CString\tGetLastExportDir();\r\n\tstatic void\t\tSetLastExportDir(CString csDir);\r\n\r\n\tstatic BOOL\t\tGetUpdateDescWhenSavingClip();\r\n\tstatic void\t\tSetUpdateDescWhenSavingClip(BOOL bSet);\r\n\r\n\tstatic BOOL\t\tm_outputDebugStringLogging;\r\n\tstatic BOOL\t\tGetEnableOutputDebugStringLogging();\r\n\tstatic void\t\tSetEnableOutputDebugStringLogging(BOOL bSet);\r\n\r\n\tstatic CStringArray m_csNetworkPasswordArray;\r\n\r\n\tstatic CString  GetPath(long lPathID);\r\n\r\n\tstatic __int64\tnLastDbWriteTime;\r\n\r\n\tstatic long\t\tGetDittoRestoreClipboardDelay();\r\n\tstatic void\t\tSetDittoRestoreClipboardDelay(long lDelay);\r\n\r\n\tstatic void\t\tGetCopyBufferItem(int nPos, CCopyBufferItem &Item);\r\n\tstatic void\t\tSetCopyBufferItem(int nPos, CCopyBufferItem &Item);\r\n\r\n\tstatic CString  GetMultiPasteSeparator(bool bConvertToLineFeeds = true);\r\n\tstatic void\t\tSetMultiPasteSeparator(CString csSep);\r\n\r\n\tstatic BOOL\t\tGetSetCurrentDirectory();\r\n\r\n\tstatic CString GetPasteString(CString csAppName);\r\n\r\n\tstatic CString GetDefaultPasteString();\r\n\tstatic void SetDefaultPasteString(CString val);\r\n\r\n\tstatic CString GetCopyString(CString csAppName);\r\n\tstatic CString GetDefaultCopyString();\r\n\tstatic void SetDefaultCopyString(CString val);\r\n\r\n\tstatic CString GetCutString(CString csAppName);\r\n\tstatic CString GetDefaultCutString();\r\n\tstatic void SetDefaultCutString(CString val);\r\n\r\n\tstatic BOOL\tGetEditWordWrap();\r\n\tstatic void\tSetEditWordWrap(BOOL bSet);\r\n\r\n\tstatic void SetAllowFriends(BOOL val);\r\n\tstatic bool GetAllowFriends();\r\n\r\n\tstatic bool\t\tGetIsPortableDitto();\r\n\tstatic bool\t\tGetIsWindowsApp();\r\n\tstatic bool\t\tGetIsChocolateyApp();\r\n\r\n\tstatic long\t\tGetAutoMaxDelay();\r\n\tstatic void\t\tSetAutoMaxDelay(long lDelay);\r\n\r\n\tstatic void SetTheme(CString csTheme);\r\n\tstatic CString GetTheme();\r\n\r\n\tstatic long\t\tGetKeyStateWaitTimerCount();\r\n\tstatic long\t\tGetKeyStatePasteDelay();\r\n\r\n\tstatic DWORD\tGetDittoHotKey();\r\n\t\r\n\tstatic DWORD\tSendKeysDelay();\r\n\tstatic void\t\tSetSendKeysDelay(DWORD val);\r\n\r\n\tstatic DWORD\tRealSendKeysDelay();\r\n\tstatic void\t\tSetRealSendKeysDelay(DWORD val);\r\n\r\n\tstatic DWORD\tWaitForActiveWndTimeout();\r\n\tstatic DWORD\tFocusChangedDelay();\r\n\tstatic DWORD\tFocusWndTimerTimeout();\r\n\r\n\tstatic BOOL\t\tGetConnectedToClipboard();\r\n\tstatic void\t\tSetConnectedToClipboard(BOOL val);\r\n\r\n\tstatic DWORD\tGetTextOnlyRestoreDelay();\r\n\tstatic DWORD \tGetTextOnlyPasteDelay();\r\n\r\n\tstatic BOOL\t\tGetSetFocusToApp(CString csAppName);\r\n\r\n\tstatic DWORD\tSelectedIndex();\r\n\tstatic void\t\tSetSelectedIndex(int val);\r\n\r\n\tstatic void\t\tSetCopyAppInclude(CString csAppName);\r\n\tstatic CString  GetCopyAppInclude();\r\n\r\n\tstatic void\t\tSetCopyAppExclude(CString csAppName);\r\n\tstatic CString  GetCopyAppExclude();\r\n\r\n\tstatic CString  GetCopyAppSeparator();\r\n\r\n\tstatic DWORD\tGetNoFormatsRetryDelay();\r\n\r\n\tstatic DWORD\tGetMainDeletesDeleteCount();\r\n\r\n\tstatic DWORD\tGetIdleSecondsBeforeDelete();\r\n\r\n\tstatic DWORD\tGetDbTimeout();\r\n\r\n\tstatic DWORD\tGetFunnyTickCountAdjustment();\r\n\r\n\tstatic DWORD\tGetMinIdleTimeBeforeTrackFocus();\r\n\r\n\tstatic DWORD\tGetTimeBeforeExpandWindow();\r\n\r\n\tstatic DWORD\tGetUseGuiThreadInfoForFocus();\r\n\r\n\tstatic void\t\tSetSearchDescription(BOOL val);\r\n\tstatic BOOL\t\tGetSearchDescription();\r\n\r\n\tstatic void\t\tSetSearchFullText(BOOL val);\r\n\tstatic BOOL\t\tGetSearchFullText();\r\n\r\n\tstatic void\t\tSetSearchQuickPaste(BOOL val);\r\n\tstatic BOOL\t\tGetSearchQuickPaste();\r\n\r\n\tstatic void\t\tSetSimpleTextSearch(BOOL val);\r\n\tstatic BOOL\t\tGetSimpleTextSearch();\r\n\r\n\tstatic void\t\tSetMoveClipsOnGlobal10(BOOL val);\r\n\tstatic BOOL\t\tGetMoveClipsOnGlobal10();\r\n\r\n\tstatic void\t\tSetShowScrollBar(BOOL val);\r\n\tstatic BOOL\t\tGetShowScrollBar();\r\n\tstatic BOOL\t\tm_showScrollBar;\r\n\r\n\tstatic void\t\tSetPasteAsAdmin(BOOL val);\r\n\tstatic BOOL\t\tGetPasteAsAdmin();\r\n\r\n\tstatic void\t\tSetRememberDescPos(BOOL val);\r\n\tstatic BOOL\t\tGetRememberDescPos();\r\n\r\n\tstatic void\t\tSetSizeDescWindowToContent(BOOL val);\r\n\tstatic BOOL\t\tGetSizeDescWindowToContent();\r\n\r\n\tstatic void\t\tSetScaleImagesToDescWindow(BOOL val);\r\n\tstatic BOOL\t\tGetScaleImagesToDescWindow();\r\n\r\n\tstatic void\t\tSetDescWndPoint(CPoint point);\r\n\tstatic void\t\tGetDescWndPoint(CPoint &point);\r\n\r\n\tstatic void\t\tSetDescWndSize(CSize size);\r\n\tstatic void\t\tGetDescWndSize(CSize &size);\r\n\r\n\tstatic void\t\tSetShowInTaskBar(BOOL val);\r\n\tstatic BOOL\t\tGetShowInTaskBar();\r\n\r\n\tstatic void\t\tSetDiffApp(CString val);\r\n\tstatic CString\tGetDiffApp();\r\n\r\n\tstatic void\t\tSetQRCodeBorderPixels(int val);\r\n\tstatic int\tGetQRCodeBorderPixels();\r\n\r\n\tstatic BOOL GetRegExTextSearch();\r\n\tstatic void SetRegExTextSearch(BOOL val);\r\n\r\n\tstatic CString GetTranslateUrl();\r\n\r\n\tstatic void SetNetworkReadTimeoutMS(int val);\r\n\tstatic int GetNetworkReadTimeoutMS();\r\n\r\n\tstatic void SetRequestFilesUsingIP(int val);\r\n\tstatic int GetRequestFilesUsingIP();\r\n\r\n\tstatic int ReadRandomFileInterval();\r\n\tstatic int ReadRandomFileIdleMin();\r\n\r\n\tstatic BOOL GetShowGroupsInMainList();\r\n\tstatic void SetShowGroupsInMainList(BOOL val);\r\n\r\n\tstatic void SetGroupDoubleClickTimeMS(int val);\r\n\tstatic int GetGroupDoubleClickTimeMS();\r\n\r\n\tstatic void SetSaveToGroupTimeoutMS(int val);\r\n\tstatic int GetSaveToGroupTimeoutMS();\r\n\r\n\tstatic void SetCopyReasonTimeoutMS(int val);\r\n\tstatic int GetCopyReasonTimeoutMS();\r\n\r\n\tstatic void SetWindowsResumeDelayReOpenDbMS(int val);\r\n\tstatic int GetWindowsResumeDelayReOpenDbMS();\r\n\r\n\tstatic BOOL GetShowMsgWndOnCopyToGroup();\r\n\tstatic void SetShowMsgWndOnCopyToGroup(BOOL val);\r\n\r\n\tstatic int GetActionShortCutA(DWORD action, int pos, CString refData = _T(\"\"));\r\n\tstatic void SetActionShortCutA(int action, DWORD shortcut, int pos, CString refData = _T(\"\"));\r\n\r\n\tstatic int GetActionShortCutB(DWORD action, int pos, CString refData = _T(\"\"));\r\n\tstatic void SetActionShortCutB(int action, DWORD shortcut, int pos, CString refData = _T(\"\"));\r\n\r\n\tstatic BOOL\tm_bShowAlwaysOnTopWarning;\r\n\tstatic BOOL GetShowAlwaysOnTopWarning();\r\n\tstatic void SetShowAlwaysOnTopWarning(BOOL show);\r\n\t\r\n\tstatic BOOL GetUseIPFromAccept();\r\n\tstatic void SetUseIPFromAccept(BOOL useAccept);\r\n\r\n\tstatic int GetDragId();\r\n\tstatic void SetDragId(int id);\r\n\r\n\tstatic BOOL GetShowIfClipWasPasted();\r\n\tstatic void SetShowIfClipWasPasted(BOOL val);\r\n\r\n\tstatic int GetLastGroupToggle();\r\n\tstatic void SetLastGroupToggle(int val);\r\n\r\n\tstatic BOOL GetMouseClickHidesDescription();\r\n\tstatic void SetMouseClickHidesDescription(int val);\r\n\r\n\tstatic BOOL GetWrapDescriptionText();\r\n\tstatic void SetWrapDescriptionText(int val);\r\n\r\n\tstatic BOOL GetUseUISelectedGroupForLastTenCopies();\r\n\tstatic void SetUseUISelectedGroupForLastTenCopies(int val);\r\n\r\n\tstatic int GetDelayRenderLockout();\r\n\tstatic void SetDelayRenderLockout(int val);\r\n\r\n\tstatic BOOL GetAdjustClipsForCRC();\r\n\tstatic void SetAdjustClipsForCRC(int val);\r\n\r\n\tstatic BOOL GetCheckMd5OnFileTransfers();\r\n\tstatic void SetCheckMd5OnFileTransfers(int val);\r\n\r\n\tstatic int GetBalloonTimeout();\r\n\tstatic void SetBalloonTimeout(int val);\r\n\r\n\tstatic void\t\tSetCustomSendToList(CString val);\r\n\tstatic CString\tGetCustomSendToList();\r\n\r\n\tstatic int GetMaxFileContentsSize();\r\n\tstatic void SetMaxFileContentsSize(int val);\r\n\r\n\tstatic int GetErrorMsgPopupTimeout();\r\n\tstatic void SetErrorMsgPopupTimeout(int val);\r\n\r\n\tstatic CRegExFilterHelper m_regexHelper;\r\n\tstatic void\t\tSetRegexFilter(CString val, int pos);\r\n\tstatic CString\tGetRegexFilter(int pos);\r\n\r\n\tstatic void SetRegexFilterByProcessName(CString val, int pos);\r\n\tstatic CString GetRegexFilterByProcessName(int pos);\r\n\r\n\tstatic BOOL GetOpenToGroupByActiveExe();\r\n\tstatic void SetOpenToGroupByActiveExe(int val);\r\n\r\n\tstatic BOOL GetShowStartupMessage();\r\n\tstatic void SetShowStartupMessage(int val);\r\n\r\n\tstatic CChaiScriptXml m_copyScripts;\r\n\tstatic CString GetCopyScriptsXml();\r\n\tstatic void SetCopyScriptsXml(CString val);\r\n\r\n\tstatic CChaiScriptXml m_pasteScripts;\r\n\tstatic CString GetPasteScriptsXml();\r\n\tstatic void SetPasteScriptsXml(CString val);\r\n\r\n\tstatic long m_tooltipTimeout;\r\n\tstatic long GetToolTipTimeout();\r\n\tstatic void SetToolTipTimeout(int long);\r\n\r\n\tstatic CString GetPastSearchXml();\r\n\tstatic void SetPastSearchXml(CString val);\r\n\r\n\tstatic BOOL GetShowMsgWhenReceivingManualSentClip();\r\n\tstatic void SetShowMsgWhenReceivingManualSentClip(BOOL val);\r\n\r\n\tstatic BOOL m_cleanRTFBeforeDrawing;\r\n\tstatic BOOL GetCleanRTFBeforeDrawing();\r\n\tstatic void SetCleanRTFBeforeDrawing(BOOL val);\r\n\r\n\tstatic BOOL GetDisableExpireClipsConfig();\r\n\tstatic void SetDisableExpireClipsConfig(BOOL val);\r\n\r\n\tstatic BOOL GetRevertToTopLevelGroup();\r\n\tstatic void SetRevertToTopLevelGroup(BOOL val);\r\n\r\n\tstatic BOOL GetUpdateClipOrderOnCtrlC();\r\n\tstatic void SetUpdateClipOrderOnCtrlC(BOOL val);\r\n\r\n\tstatic int GetMaxToolTipLines();\r\n\tstatic void SetMaxToolTipLines(int val);\r\n\r\n\tstatic int GetMaxToolTipCharacters();\r\n\tstatic void SetMaxToolTipCharacters(int val);\r\n\r\n\tstatic int m_doubleKeyStrokeTimeout;\r\n\tstatic int GetDoubleKeyStrokeTimeout();\r\n\tstatic void SetDoubleKeyStrokeTimeout(int val);\r\n\r\n\tstatic int m_firstTenHotKeysStart;\r\n\tstatic int GetFirstTenHotKeysStart();\r\n\tstatic void SetFirstTenHotKeysStart(int val);\r\n\r\n\tstatic int m_firstTenHotKeysFontSize;\r\n\tstatic int GetFirstTenHotKeysFontSize();\r\n\tstatic void SetFirstTenHotKeysFontSize(int val);\r\n\r\n\tstatic BOOL GetAddCFHDROP_OnDrag();\r\n\tstatic void SetAddCFHDROP_OnDrag(BOOL val);\r\n\r\n\tstatic int GetCopyAndSveDelay();\r\n\tstatic void SetCopyAndSveDelay(int val);\r\n\r\n\tstatic int GetEditorDefaultFontSize();\r\n\tstatic void SetEditorDefaultFontSize(int val);\r\n\r\n\tstatic BOOL m_moveSelectionOnOpenHotkey;\r\n\tstatic BOOL GetMoveSelectionOnOpenHotkey();\r\n\tstatic void SetMoveSelectionOnOpenHotkey(BOOL val);\r\n\r\n\tstatic BOOL m_allowBackToBackDuplicates;\r\n\tstatic BOOL GetAllowBackToBackDuplicates();\r\n\tstatic void SetAllowBackToBackDuplicates(BOOL val);\r\n\r\n\tstatic BOOL m_maintainSearchView;\r\n\tstatic BOOL GetMaintainSearchView();\r\n\tstatic void SetMaintainSearchView(BOOL val);\r\n\r\n\tstatic CString GetNetworkBindIPAddress();\r\n\tstatic void SetNetworkBindIPAddress(CString val);\r\n\r\n\tstatic CString m_tempDragFileName;\r\n\tstatic CTime m_tempDragFileNameSetTime;\r\n\tstatic CString GetTempDragFileName();\r\n\tstatic void SetTempDragFileName(CString val);\r\n\r\n\tstatic BOOL m_refreshViewAfterPasting;\r\n\tstatic BOOL GetRefreshViewAfterPasting();\r\n\tstatic void SetRefreshViewAfterPasting(BOOL val);\r\n\r\n\tstatic CString GetSlugifySeparator();\r\n\tstatic void SetSlugifySeparator(CString val);\r\n\r\n\tstatic BOOL m_supportAllTypes;\r\n\tstatic BOOL GetSupportAllTypes();\r\n\tstatic void SetSupportAllTypes(BOOL val);\r\n\r\n\tstatic CString GetIgnoreAnnoyingCFDIB(BOOL useCache = FALSE);\r\n\tstatic CString m_ignoreAnnoyingCFDIB;\r\n\tstatic void SetIgnoreAnnoyingCFDIB(CString val);\r\n\tstatic set<CString> GetIgnoreAnnoyingCFDIBSet(BOOL useCache = FALSE);\r\n\r\n\tstatic BOOL GetRegexCaseInsensitive();\r\n\tstatic void SetRegexCaseInsensitive(BOOL val);\r\n\r\n\tstatic BOOL\t\tm_bDrawCopiedColorCode;\r\n\tstatic void\t\tSetDrawCopiedColorCode(long bDraw);\r\n\tstatic BOOL\t\tGetDrawCopiedColorCode();\r\n\r\n\r\n\tstatic BOOL m_centerWindowBelowCursorOrCaret;\r\n\tstatic void SetCenterWindowBelowCursorOrCaret(BOOL center);\r\n\tstatic BOOL GetCenterWindowBelowCursorOrCaret();\r\n\r\n\tstatic BOOL SetTextEditorPath(CString path);\r\n\tstatic CString GetTextEditorPath();\r\n\r\n\tstatic BOOL SetRTFEditorPath(CString path);\r\n\tstatic CString GetRTFEditorPath();\r\n\r\n\tstatic BOOL SetQRCodeUrl(CString path);\r\n\tstatic CString GetQRCodeUrl();\r\n};\r\n\r\n// global for easy access and for initialization of fast access variables\r\nextern CGetSetOptions g_Opt; "
        },
        {
          "name": "OptionsCopyBuffers.cpp",
          "type": "blob",
          "size": 5.5947265625,
          "content": "// OptionsCopyBuffers.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"OptionsCopyBuffers.h\"\n\n\n// COptionsCopyBuffers dialog\n\nIMPLEMENT_DYNCREATE(COptionsCopyBuffers, CPropertyPage)\n\nCOptionsCopyBuffers::COptionsCopyBuffers() : CPropertyPage(COptionsCopyBuffers::IDD)\n{\n\tm_csTitle = theApp.m_Language.GetString(\"CopyBuffers\", \"Copy Buffers\");\n\tm_psp.pszTitle = m_csTitle;\n\tm_psp.dwFlags |= PSP_USETITLE; \n}\n\nCOptionsCopyBuffers::~COptionsCopyBuffers()\n{\n}\n\nvoid COptionsCopyBuffers::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_COPY_1, m_CopyBuffer1);\n\tDDX_Control(pDX, IDC_PASTE_1, m_PasteBuffer1);\n\tDDX_Control(pDX, IDC_CUT_1, m_CutBuffer1);\n\tDDX_Control(pDX, IDC_COPY_2, m_CopyBuffer2);\n\tDDX_Control(pDX, IDC_PASTE_2, m_PasteBuffer2);\n\tDDX_Control(pDX, IDC_CUT_2, m_CutBuffer2);\n\tDDX_Control(pDX, IDC_COPY_3, m_CopyBuffer3);\n\tDDX_Control(pDX, IDC_PASTE_3, m_PasteBuffer3);\n\tDDX_Control(pDX, IDC_CUT_3, m_CutBuffer3);\n\n\tDDX_Control(pDX, IDC_COPY_4, m_CopyBuffer4);\n\tDDX_Control(pDX, IDC_PASTE_4, m_PasteBuffer4);\n\tDDX_Control(pDX, IDC_CUT_4, m_CutBuffer4);\n\n\tDDX_Control(pDX, IDC_COPY_5, m_CopyBuffer5);\n\tDDX_Control(pDX, IDC_PASTE_5, m_PasteBuffer5);\n\tDDX_Control(pDX, IDC_CUT_5, m_CutBuffer5);\n}\n\n\nBEGIN_MESSAGE_MAP(COptionsCopyBuffers, CPropertyPage)\nEND_MESSAGE_MAP()\n\nBOOL COptionsCopyBuffers::OnInitDialog()\n{\n\tCPropertyPage::OnInitDialog();\n\n\tCCopyBufferItem Item;\n\t\n\tCGetSetOptions::GetCopyBufferItem(0, Item);\n\ttheApp.m_pCopyBuffer1->CopyToCtrl(m_CopyBuffer1, m_hWnd, IDC_WIN_COPY_1);\n\ttheApp.m_pPasteBuffer1->CopyToCtrl(m_PasteBuffer1, m_hWnd, IDC_WIN_PASTE_1);\n\ttheApp.m_pCutBuffer1->CopyToCtrl(m_CutBuffer1, m_hWnd, IDC_WIN_CUT_1);\n\tCheckDlgButton(IDC_PLAY_SOUND_1, Item.m_bPlaySoundOnCopy);\n\n\tCGetSetOptions::GetCopyBufferItem(1, Item);\n\ttheApp.m_pCopyBuffer2->CopyToCtrl(m_CopyBuffer2, m_hWnd, IDC_WIN_COPY_2);\n\ttheApp.m_pPasteBuffer2->CopyToCtrl(m_PasteBuffer2, m_hWnd, IDC_WIN_PASTE_2);\n\ttheApp.m_pCutBuffer2->CopyToCtrl(m_CutBuffer2, m_hWnd, IDC_WIN_CUT_2);\n\tCheckDlgButton(IDC_PLAY_SOUND_2, Item.m_bPlaySoundOnCopy);\n\n\tCGetSetOptions::GetCopyBufferItem(2, Item);\n\ttheApp.m_pCopyBuffer3->CopyToCtrl(m_CopyBuffer3, m_hWnd, IDC_WIN_COPY_3);\n\ttheApp.m_pPasteBuffer3->CopyToCtrl(m_PasteBuffer3, m_hWnd, IDC_WIN_PASTE_3);\n\ttheApp.m_pCutBuffer3->CopyToCtrl(m_CutBuffer3, m_hWnd, IDC_WIN_CUT_3);\n\tCheckDlgButton(IDC_PLAY_SOUND_3, Item.m_bPlaySoundOnCopy);\n\n\tCGetSetOptions::GetCopyBufferItem(3, Item);\n\ttheApp.m_pCopyBuffer4->CopyToCtrl(m_CopyBuffer4, m_hWnd, IDC_WIN_COPY_4);\n\ttheApp.m_pPasteBuffer4->CopyToCtrl(m_PasteBuffer4, m_hWnd, IDC_WIN_PASTE_4);\n\ttheApp.m_pCutBuffer4->CopyToCtrl(m_CutBuffer4, m_hWnd, IDC_WIN_CUT_4);\n\tCheckDlgButton(IDC_PLAY_SOUND_4, Item.m_bPlaySoundOnCopy);\n\n\tCGetSetOptions::GetCopyBufferItem(4, Item);\n\ttheApp.m_pCopyBuffer5->CopyToCtrl(m_CopyBuffer5, m_hWnd, IDC_WIN_COPY_5);\n\ttheApp.m_pPasteBuffer5->CopyToCtrl(m_PasteBuffer5, m_hWnd, IDC_WIN_PASTE_5);\n\ttheApp.m_pCutBuffer5->CopyToCtrl(m_CutBuffer5, m_hWnd, IDC_WIN_CUT_5);\n\tCheckDlgButton(IDC_PLAY_SOUND_5, Item.m_bPlaySoundOnCopy);\n\n\ttheApp.m_Language.UpdateOptionCopyBuffers(this);\n\n\treturn TRUE;\n}\n\nBOOL COptionsCopyBuffers::OnApply()\n{\n\tARRAY keys;\n\tg_HotKeys.GetKeys(keys); // save old keys just in case new ones are invalid\n\n\ttheApp.m_pCopyBuffer1->CopyFromCtrl(m_CopyBuffer1, m_hWnd, IDC_WIN_COPY_1);\n\ttheApp.m_pPasteBuffer1->CopyFromCtrl(m_PasteBuffer1, m_hWnd, IDC_WIN_PASTE_1);\n\ttheApp.m_pCutBuffer1->CopyFromCtrl(m_CutBuffer1, m_hWnd, IDC_WIN_CUT_1);\n\n\ttheApp.m_pCopyBuffer2->CopyFromCtrl(m_CopyBuffer2, m_hWnd, IDC_WIN_COPY_2);\n\ttheApp.m_pPasteBuffer2->CopyFromCtrl(m_PasteBuffer2, m_hWnd, IDC_WIN_PASTE_2);\n\ttheApp.m_pCutBuffer2->CopyFromCtrl(m_CutBuffer2, m_hWnd, IDC_WIN_CUT_2);\n\n\ttheApp.m_pCopyBuffer3->CopyFromCtrl(m_CopyBuffer3, m_hWnd, IDC_WIN_COPY_3);\n\ttheApp.m_pPasteBuffer3->CopyFromCtrl(m_PasteBuffer3, m_hWnd, IDC_WIN_PASTE_3);\n\ttheApp.m_pCutBuffer3->CopyFromCtrl(m_CutBuffer3, m_hWnd, IDC_WIN_CUT_3);\n\n\ttheApp.m_pCopyBuffer4->CopyFromCtrl(m_CopyBuffer4, m_hWnd, IDC_WIN_COPY_4);\n\ttheApp.m_pPasteBuffer4->CopyFromCtrl(m_PasteBuffer4, m_hWnd, IDC_WIN_PASTE_4);\n\ttheApp.m_pCutBuffer4->CopyFromCtrl(m_CutBuffer4, m_hWnd, IDC_WIN_CUT_4);\n\n\ttheApp.m_pCopyBuffer5->CopyFromCtrl(m_CopyBuffer5, m_hWnd, IDC_WIN_COPY_5);\n\ttheApp.m_pPasteBuffer5->CopyFromCtrl(m_PasteBuffer5, m_hWnd, IDC_WIN_PASTE_5);\n\ttheApp.m_pCutBuffer5->CopyFromCtrl(m_CutBuffer5, m_hWnd, IDC_WIN_CUT_5);\n\n\tCCopyBufferItem Item;\n\tCGetSetOptions::GetCopyBufferItem(0, Item);\n\tItem.m_bPlaySoundOnCopy = IsDlgButtonChecked(IDC_PLAY_SOUND_1);\n\tCGetSetOptions::SetCopyBufferItem(0, Item);\n\n\tCGetSetOptions::GetCopyBufferItem(1, Item);\n\tItem.m_bPlaySoundOnCopy = IsDlgButtonChecked(IDC_PLAY_SOUND_2);\n\tCGetSetOptions::SetCopyBufferItem(1, Item);\n\n\tCGetSetOptions::GetCopyBufferItem(2, Item);\n\tItem.m_bPlaySoundOnCopy = IsDlgButtonChecked(IDC_PLAY_SOUND_3);\n\tCGetSetOptions::SetCopyBufferItem(2, Item);\n\n\tCGetSetOptions::GetCopyBufferItem(3, Item);\n\tItem.m_bPlaySoundOnCopy = IsDlgButtonChecked(IDC_PLAY_SOUND_4);\n\tCGetSetOptions::SetCopyBufferItem(3, Item);\n\n\tCGetSetOptions::GetCopyBufferItem(4, Item);\n\tItem.m_bPlaySoundOnCopy = IsDlgButtonChecked(IDC_PLAY_SOUND_5);\n\tCGetSetOptions::SetCopyBufferItem(4, Item);\n\n\tINT_PTR x;\n\tINT_PTR y;\n\tARRAY NewKeys;\n\tg_HotKeys.GetKeys(NewKeys);\n\n\tif(g_HotKeys.FindFirstConflict(NewKeys, &x, &y))\n\t{\n\t\tCString str =  g_HotKeys.ElementAt(x)->GetName();\n\t\tstr += \" and \";\n\t\tstr += g_HotKeys.ElementAt(y)->GetName();\n\t\tstr += \" cannot be the same.\";\n\t\tMessageBox(str);\n\t\tg_HotKeys.SetKeys(keys); // restore the original values\n\t\treturn FALSE;\n\t}\n\n\tg_HotKeys.SaveAllKeys();\n\tg_HotKeys.RegisterAll(true);\n\n\treturn CPropertyPage::OnApply();\n}\n\n"
        },
        {
          "name": "OptionsCopyBuffers.h",
          "type": "blob",
          "size": 0.9482421875,
          "content": "#pragma once\n#include \"afxcmn.h\"\n\n\n// COptionsCopyBuffers dialog\n\nclass COptionsCopyBuffers : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(COptionsCopyBuffers)\n\npublic:\n\tCOptionsCopyBuffers();\n\t~COptionsCopyBuffers();\n\n// Dialog Data\n\tenum { IDD = IDD_OPTIONS_COPY_BUFFERS };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n\tCString m_csTitle;\n\n\t// Generated message map functions\n\t//{{AFX_MSG(COptionsCopyBuffers)\n\tvirtual BOOL OnInitDialog();\n\tvirtual BOOL OnApply();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tCHotKeyCtrl m_CopyBuffer1;\n\tCHotKeyCtrl m_PasteBuffer1;\n\tCHotKeyCtrl m_CutBuffer1;\n\tCHotKeyCtrl m_CopyBuffer2;\n\tCHotKeyCtrl m_PasteBuffer2;\n\tCHotKeyCtrl m_CutBuffer2;\n\tCHotKeyCtrl m_CopyBuffer3;\n\tCHotKeyCtrl m_PasteBuffer3;\n\tCHotKeyCtrl m_CutBuffer3;\n\tCHotKeyCtrl m_CopyBuffer4;\n\tCHotKeyCtrl m_PasteBuffer4;\n\tCHotKeyCtrl m_CutBuffer4;\n\tCHotKeyCtrl m_CopyBuffer5;\n\tCHotKeyCtrl m_PasteBuffer5;\n\tCHotKeyCtrl m_CutBuffer5;\n};\n"
        },
        {
          "name": "OptionsGeneral.cpp",
          "type": "blob",
          "size": 15.931640625,
          "content": "\t// OptionsGeneral.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"OptionsGeneral.h\"\n#include <io.h>\n#include <Mmsystem.h> //play sound\n#include \"Path.h\"\n#include \"AdvGeneral.h\"\n#include \"DimWnd.h\"\n#include \"HyperLink.h\"\n\nusing namespace nsPath;\n\n#define DEFAULT_THEME _T(\"(Ditto)\")\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsGeneral property page\n\nIMPLEMENT_DYNCREATE(COptionsGeneral, CPropertyPage)\n\nCOptionsGeneral::COptionsGeneral() : CPropertyPage(COptionsGeneral::IDD)\n{\n\tm_csTitle = theApp.m_Language.GetString(\"GeneralTitle\", \"General\");\n\tm_psp.pszTitle = m_csTitle;\n\tm_psp.dwFlags |= PSP_USETITLE; \n\n\tmemset(&m_LogFont, 0, sizeof(LOGFONT));\n\n\t//{{AFX_DATA_INIT(COptionsGeneral)\n\t//}}AFX_DATA_INIT\n}\n\nCOptionsGeneral::~COptionsGeneral()\n{\n}\n\nvoid COptionsGeneral::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(COptionsGeneral)\n\t//DDX_Control(pDX, IDC_ENSURE, m_EnsureConnected);\n\t//\tDDX_Control(pDX, IDC_EDIT_SAVE_DELAY, m_SaveDelay);\n\tDDX_Control(pDX, IDC_COMBO_LANGUAGE, m_cbLanguage);\n\tDDX_Control(pDX, IDC_PATH, m_ePath);\n\tDDX_Control(pDX, IDC_EXPIRE_AFTER, m_eExpireAfter);\n\tDDX_Control(pDX, IDC_MAX_SAVED_COPIES, m_eMaxSavedCopies);\n\tDDX_Control(pDX, IDC_EXPIRE, m_btExpire);\n\tDDX_Control(pDX, IDC_START_ON_STARTUP, m_btRunOnStartup);\n\tDDX_Control(pDX, IDC_EDIT_APP_COPY_INCLUDE, m_copyAppInclude);\n\tDDX_Control(pDX, IDC_EDIT_APP_COPY_EXCLUDE, m_copyAppExclude);\n\tDDX_Control(pDX, IDC_MAXIMUM, m_btMaximumCheck);\n\t//}}AFX_DATA_MAP\n\tDDX_Control(pDX, IDC_COMBO_THEME, m_cbTheme);\n\tDDX_Control(pDX, IDC_BUTTON_FONT, m_btFont);\n\tDDX_Control(pDX, IDC_BUTTON_DEFAULT_FAULT, m_btDefaultButton);\n\tDDX_Control(pDX, IDC_COMBO_POPUP_POSITION, m_popupPositionCombo);\n\tDDX_Control(pDX, IDC_MFCLINK_ENV_VAR, m_envVarLink);\n}\n\n\nBEGIN_MESSAGE_MAP(COptionsGeneral, CPropertyPage)\n\t//{{AFX_MSG_MAP(COptionsGeneral)\n\tON_BN_CLICKED(IDC_GET_PATH, OnGetPath)\n\tON_BN_CLICKED(IDC_BUTTON_ABOUT, OnButtonAbout)\n\t//}}AFX_MSG_MAP\n\tON_BN_CLICKED(IDC_BUTTON_ADVANCED, &COptionsGeneral::OnBnClickedButtonAdvanced)\n\tON_WM_CTLCOLOR()\n\tON_BN_CLICKED(IDC_BUTTON_THEME, &COptionsGeneral::OnBnClickedButtonTheme)\n\tON_BN_CLICKED(IDC_BUTTON_DEFAULT_FAULT, &COptionsGeneral::OnBnClickedButtonDefaultFault)\n\tON_BN_CLICKED(IDC_BUTTON_FONT, &COptionsGeneral::OnBnClickedButtonFont)\n\tON_EN_CHANGE(IDC_PATH, &COptionsGeneral::OnEnChangePath)\n\tON_BN_CLICKED(IDC_MAXIMUM, &COptionsGeneral::OnClickedMaximumEntries)\n\tON_BN_CLICKED(IDC_EXPIRE, &COptionsGeneral::OnClickedExpireEntries)\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsGeneral message handlers\n\nBOOL COptionsGeneral::OnInitDialog() \n{\n\tCPropertyPage::OnInitDialog();\n\n\tCString url = _T(\"https://github.com/sabrogden/Ditto/wiki/Environment-Variables\");\n\n\tm_brush.CreateSolidBrush(RGB(251, 251, 251));\n\t\n\tm_pParent = (COptionsSheet *)GetParent();\n\n#ifndef _DEBUG\n\n\tif (CGetSetOptions::GetIsWindowsApp())\n\t{\n\t\tm_btRunOnStartup.SetCheck(BST_CHECKED);\n\t\tGetDlgItem(IDC_START_ON_STARTUP)->EnableWindow(FALSE);\n\t}\n\telse\n\t{\n\t\tm_btRunOnStartup.SetCheck(CGetSetOptions::GetRunOnStartUp());\n\t}\n#endif\n\n\tm_btMaximumCheck.SetCheck(CGetSetOptions::GetCheckForMaxEntries());\n\tif (CGetSetOptions::GetCheckForMaxEntries() == FALSE)\n\t{\n\t\tm_eMaxSavedCopies.EnableWindow(FALSE);\t\t\n\t}\n\tm_btExpire.SetCheck(CGetSetOptions::GetCheckForExpiredEntries());\n\tif (CGetSetOptions::GetCheckForExpiredEntries() == FALSE)\n\t{\n\t\tm_eExpireAfter.EnableWindow(FALSE);\n\t}\n\tm_eExpireAfter.SetNumber(CGetSetOptions::GetExpiredEntries());\n\tm_eMaxSavedCopies.SetNumber(CGetSetOptions::GetMaxEntries());\n\n\tif(CGetSetOptions::GetDisableExpireClipsConfig())\n\t{\n\t\tm_btMaximumCheck.EnableWindow(FALSE);\n\t\tm_btExpire.EnableWindow(FALSE);\n\t\tm_eExpireAfter.EnableWindow(FALSE);\n\t\tm_eMaxSavedCopies.EnableWindow(FALSE);\n\t}\n\n\tm_copyAppInclude.SetWindowText(CGetSetOptions::GetCopyAppInclude());\n\tm_copyAppExclude.SetWindowText(CGetSetOptions::GetCopyAppExclude());\n\n\t\n\tCGetSetOptions::GetFont(m_LogFont);\t\n\n\tCString cs;\n\tcs.Format(_T(\"Font - %s (%d)\"), m_LogFont.lfFaceName, GetFontSize(m_hWnd, m_LogFont));\n\tm_btFont.SetWindowText(cs);\n\n\tFillThemes();\n\tFillLanguages();\n\n\tint caretPos = m_popupPositionCombo.AddString(theApp.m_Language.GetString(\"AtCaret\", \"At Caret\"));\n\tm_popupPositionCombo.SetItemData(caretPos, POS_AT_CARET);\n\n\tint cursorPos = m_popupPositionCombo.AddString(theApp.m_Language.GetString(\"AtCursor\", \"At Cursor\"));\n\tm_popupPositionCombo.SetItemData(cursorPos, POS_AT_CURSOR);\n\n\tint prevPos = m_popupPositionCombo.AddString(theApp.m_Language.GetString(\"AtPreviousPosition\", \"At Previous Position\"));\n\tm_popupPositionCombo.SetItemData(prevPos, POS_AT_PREVIOUS);\n\n\tswitch (CGetSetOptions::GetQuickPastePosition())\n\t{\n\tcase POS_AT_CARET:\n\t\tm_popupPositionCombo.SetCurSel(caretPos);\n\t\tbreak;\n\tcase POS_AT_CURSOR:\n\t\tm_popupPositionCombo.SetCurSel(cursorPos);\n\t\tbreak;\n\tcase POS_AT_PREVIOUS:\n\t\tm_popupPositionCombo.SetCurSel(prevPos);\n\t\tbreak;\n\tdefault:\n\t\tm_popupPositionCombo.SetCurSel(cursorPos);\n\t}\n\n\tUpdateData(FALSE);\n\n\ttheApp.m_Language.UpdateOptionGeneral(this);\n\n\t//move after we translate so the en change gets called and we update with the correct translated value for environment variable\n\tCString csPath = CGetSetOptions::GetDBPath(false);\n\tm_ePath.SetWindowText(csPath);\n\n\treturn TRUE;\n}\n\n#define NO_MATCH\t-2\n#define FOUND_MATCH\t-1\n\nvoid COptionsGeneral::FillLanguages()\n{\n\tCString csFile = CGetSetOptions::GetPath(PATH_LANGUAGE);\n\tcsFile += \"*.xml\";\n\n\tCString csLanguage = CGetSetOptions::GetLanguageFile();\n\n\tCFileFind find;\n\tBOOL bCont = find.FindFile(csFile);\n\tint nEnglishIndex = NO_MATCH;\n\n\twhile(bCont)\n\t{\n\t\tbCont = find.FindNextFile();\n\t\tint nIndex = m_cbLanguage.AddString(find.GetFileTitle());\n\n\t\tif(find.GetFileTitle() == csLanguage)\n\t\t{\n\t\t\tnEnglishIndex = -1;\n\t\t\tm_cbLanguage.SetCurSel(nIndex);\n\t\t}\n\t\telse if(find.GetFileTitle() == _T(\"English\"))\n\t\t{\n\t\t\tif(nEnglishIndex == NO_MATCH)\n\t\t\t\tnEnglishIndex = nIndex;\n\t\t}\n\t}\n\n\tif(nEnglishIndex >= 0)\n\t{\n\t\tm_cbLanguage.SetCurSel(nEnglishIndex);\n\t}\n}\n\nBOOL COptionsGeneral::OnApply()\n{\n\tUpdateData();\n\n#ifndef _DEBUG\n\n\tif (CGetSetOptions::GetIsWindowsApp() == FALSE)\n\t{\n\t\tCGetSetOptions::SetRunOnStartUp(m_btRunOnStartup.GetCheck());\n\t}\n#endif\n\n\tCGetSetOptions::SetCheckForMaxEntries(m_btMaximumCheck.GetCheck());\n\tCGetSetOptions::SetCheckForExpiredEntries(m_btExpire.GetCheck());\n\tCGetSetOptions::SetMaxEntries(m_eMaxSavedCopies.GetNumber());\n\tCGetSetOptions::SetExpiredEntries(m_eExpireAfter.GetNumber());\n\t\n\tCString stringVal;\n\n\tm_copyAppInclude.GetWindowText(stringVal);\n\tCGetSetOptions::SetCopyAppInclude(stringVal);\n\tm_copyAppExclude.GetWindowText(stringVal);\n\tCGetSetOptions::SetCopyAppExclude(stringVal);\n\n\tCString csLanguage;\n\tif(m_cbLanguage.GetCurSel() >= 0)\n\t{\n\t\tm_cbLanguage.GetLBText(m_cbLanguage.GetCurSel(), csLanguage);\n\t\tCGetSetOptions::SetLanguageFile(csLanguage);\n\t}\n\t\n\tif(csLanguage.IsEmpty() == FALSE)\n\t{\n\t\tif(!theApp.m_Language.LoadLanguageFile(csLanguage))\n\t\t{\n\t\t\tCString cs;\n\t\t\tcs.Format(_T(\"Error loading language file - %s - \\n\\n%s\"), csLanguage, theApp.m_Language.m_csLastError);\n\n\t\t\tMessageBox(cs, _T(\"Ditto\"), MB_OK);\n\t\t}\n\t}\n\n\tCString toSavePath;\n\tm_ePath.GetWindowText(toSavePath);\n\tCString resolvedPath = CGetSetOptions::ResolvePath(toSavePath);\n\n\tbool bOpenNewDatabase = false;\n\n\tif(resolvedPath.IsEmpty() == FALSE)\n\t{\n\t\tif(FileExists(resolvedPath) == FALSE)\n\t\t{\n\t\t\tCString cs;\n\t\t\tcs.Format(_T(\"The database %s does not exist.\\n\\nCreate a new database?\"), resolvedPath);\n\n\t\t\tif(MessageBox(cs, _T(\"Ditto\"), MB_YESNO) == IDYES)\n\t\t\t{\n\t\t\t\t// -- create a new one\n\t\t\t\tif(CreateDB(resolvedPath))\n\t\t\t\t{\n\t\t\t\t\tbOpenNewDatabase = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tMessageBox(_T(\"Error Creating Database\"));\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ValidDB(resolvedPath) == FALSE)\n\t\t\t{\n\t\t\t\tMessageBox(_T(\"Invalid Database\"), _T(\"Ditto\"), MB_OK);\n\t\t\t\tm_ePath.SetFocus();\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbOpenNewDatabase = true;\n\t\t\t}\n\t\t}\n\n\t\tif(bOpenNewDatabase)\n\t\t{\n\t\t\tCGetSetOptions::SetDBPath(toSavePath);\n\n\t\t\tif(OpenDatabase(resolvedPath) == FALSE)\n\t\t\t{\n\t\t\t\tMessageBox(_T(\"Error Opening new database\"), _T(\"Ditto\"), MB_OK);\n\t\t\t\tm_ePath.SetFocus();\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttheApp.RefreshView();\n\t\t\t}\n\t\t}\n\t}\n\n\tCGetSetOptions::SetQuickPastePosition((int)m_popupPositionCombo.GetItemData(m_popupPositionCombo.GetCurSel()));\n\n\tif (m_LogFont.lfWeight != 0)\n\t{\n\t\tCGetSetOptions::SetFont(m_LogFont);\n\t}\n\n\tCString currentTheme = CGetSetOptions::GetTheme();\n\n\tCString csTheme = _T(\"\");\n\tif (m_cbTheme.GetCurSel() >= 0)\n\t{\n\t\tif (m_cbTheme.GetItemData(m_cbTheme.GetCurSel()) == 1)\n\t\t{\n\t\t\tm_cbTheme.GetLBText(m_cbTheme.GetCurSel(), csTheme);\t\t\t\n\t\t\tCGetSetOptions::SetTheme(csTheme);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCGetSetOptions::SetTheme(\"\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tCGetSetOptions::SetTheme(\"\");\n\t}\n\n\tif (currentTheme != csTheme)\n\t{\n\t\tm_pParent->m_themeChanged = TRUE;\n\t}\n\t\n\treturn CPropertyPage::OnApply();\n}\n\nBOOL COptionsGeneral::OnSetActive() \n{\t\n\treturn CPropertyPage::OnSetActive();\n}\n\n//void COptionsGeneral::OnSetDbPath() \n//{\n//\tif(m_btSetDatabasePath.GetCheck() == BST_CHECKED)\n//\t{\n//\t\tm_ePath.EnableWindow(TRUE);\n//\t\tm_btGetPath.EnableWindow(TRUE);\n//\t}\n//\telse\n//\t{\n//\t\tm_ePath.EnableWindow(FALSE);\n//\t\tm_btGetPath.EnableWindow(FALSE);\n//\t}\t\n//}\n\nvoid COptionsGeneral::OnGetPath() \n{\n\tOPENFILENAME\tFileName;\n\tTCHAR\t\t\tszFileName[400];\n\tTCHAR\t\t\tszDir[400];\n\n\tmemset(&FileName, 0, sizeof(FileName));\n\tmemset(szFileName, 0, sizeof(szFileName));\n\tmemset(&szDir, 0, sizeof(szDir));\n\tFileName.lStructSize = sizeof(FileName);\n\tFileName.lpstrTitle = _T(\"Open Database\");\n\tFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;\n\tFileName.nMaxFile = 400;\n\tFileName.lpstrFile = szFileName;\n\tFileName.lpstrInitialDir = szDir;\n\tFileName.lpstrFilter = _T(\"Ditto Databases (*.db; *.mdb)\\0*.db;*.mdb\\0\\0\");\n\tFileName.lpstrDefExt = _T(\"db\");\n\tFileName.hwndOwner = m_hWnd;\n\n\tif(GetOpenFileName(&FileName) == 0)\n\t\treturn;\n\n\tCString csPath(FileName.lpstrFile);\n\tif(FileExists(csPath))\n\t{\n\t\tif(ValidDB(csPath) == FALSE)\n\t\t{\n\t\t\tMessageBox(_T(\"Invalid Database\"), _T(\"Ditto\"), MB_OK);\n\t\t\tm_ePath.SetFocus();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_ePath.SetWindowText(csPath);\t\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_ePath.SetWindowText(csPath);\n\t}\n}\n\nvoid COptionsGeneral::OnButtonAbout() \n{\n\tCDimWnd dim(this->GetParent());\n\n\tCMultiLanguage Lang;\n\n\tCString csLanguage;\n\tm_cbLanguage.GetLBText(m_cbLanguage.GetCurSel(), csLanguage);\n\n\tLang.SetOnlyGetHeader(true);\n\t\t\n\tif(Lang.LoadLanguageFile(csLanguage))\n\t{\n\t\tCString csMessage;\n\n\t\tcsMessage.Format(_T(\"Language -  %s\\n\")\n\t\t\t\t\t\t _T(\"Version -   %d\\n\")\n\t\t\t\t\t\t _T(\"Author -   %s\\n\")\n\t\t\t\t\t\t _T(\"Notes -   %s\"), csLanguage, \n\t\t\t\t\t\t\t\t\t   Lang.GetVersion(), \n\t\t\t\t\t\t\t\t\t   Lang.GetAuthor(), \n\t\t\t\t\t\t\t\t\t   Lang.GetNotes());\n\n\t\tMessageBox(csMessage, _T(\"Ditto\"), MB_OK);\n\t}\n\telse\n\t{\n\t\tCString csError;\n\t\tcsError.Format(_T(\"Error loading language file - %s - reason = \"), csLanguage, Lang.m_csLastError);\n\n\t\tMessageBox(csError, _T(\"Ditto\"), MB_OK);\n\t}\n}\n\nvoid COptionsGeneral::OnBnClickedButtonAdvanced()\n{\n\tCDimWnd dim(this->GetParent());\n\n\tCAdvGeneral adv(this);\n\tadv.DoModal();\n}\n\n\nHBRUSH COptionsGeneral::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\n{\n\tHBRUSH hbr = CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);\n\n\t\n\n\tswitch(nCtlColor)\n\t{\n\tcase CTLCOLOR_DLG:     // dialog \n\tcase CTLCOLOR_STATIC:  // static, checkbox, read-only edit, etc.\n\t\t//pDC->SetBkColor(RGB(251, 251, 251));\n\t\t//hbr = m_brush;\n\t\tbreak;\n\t}\n\treturn hbr;\n}\n\nvoid COptionsGeneral::FillThemes()\n{\n\tCString csFile = CGetSetOptions::GetPath(PATH_THEMES);\n\tcsFile += \"*.xml\";\n\n\tCString csTheme = CGetSetOptions::GetTheme();\n\t\n\tm_cbTheme.Clear();\n\n\tint windowsSettingIndex = m_cbTheme.AddString(theApp.m_Language.GetString(\"FollowWindowsTheme\", \"(Follow windows light/dark themes)\"));\n\t\t\n\t\t//_T(\"(Follow windows light/dark themes)\"));\n\tm_cbTheme.SetItemData(windowsSettingIndex, 0);\n\n\tCFileFind find;\n\tBOOL bCont = find.FindFile(csFile);\n\tbool bSetCurSel = false;\n\n\twhile (bCont)\n\t{\n\t\tbCont = find.FindNextFile();\n\n\t\tCTheme theme;\n\t\tif (theme.Load(find.GetFileTitle(), true, false))\n\t\t{\n\t\t\tif (theme.FileVersion() >= 2 && theme.FileVersion() < 100)\n\t\t\t{\n\t\t\t\tint nIndex = m_cbTheme.AddString(find.GetFileTitle());\n\t\t\t\tm_cbTheme.SetItemData(nIndex, 1);\n\n\t\t\t\tif (find.GetFileTitle() == csTheme)\n\t\t\t\t{\n\t\t\t\t\tm_cbTheme.SetCurSel(nIndex);\n\t\t\t\t\tbSetCurSel = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint nIndex = m_cbTheme.AddString(DEFAULT_THEME);\n\tm_cbTheme.SetItemData(nIndex, 1);\n\tif (csTheme == DEFAULT_THEME)\n\t{\n\t\tm_cbTheme.SetCurSel(nIndex);\n\t\tbSetCurSel = true;\n\t}\n\n\tif (bSetCurSel == false)\n\t{\n\t\tint count = m_cbTheme.GetCount();\n\t\tfor (int i = 0; i < count; i++)\n\t\t{\n\t\t\tif (m_cbTheme.GetItemData(i) == 0)\n\t\t\t{\n\t\t\t\tm_cbTheme.SetCurSel(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid COptionsGeneral::OnBnClickedButtonTheme()\n{\n\tCDimWnd dim(this->GetParent());\n\tCTheme theme;\n\n\tCString csTheme;\n\tm_cbTheme.GetLBText(m_cbTheme.GetCurSel(), csTheme);\n\n\tif (m_cbTheme.GetItemData(m_cbTheme.GetCurSel()) == 0)\n\t\treturn;\n\n\tif (csTheme == DEFAULT_THEME)\n\t\treturn;\n\n\tif (theme.Load(csTheme, true, false))\n\t{\n\t\tCString csMessage;\n\n\t\tcsMessage.Format(_T(\"Theme -  %s\\n\")\n\t\t\t_T(\"Version -   %d\\n\")\n\t\t\t_T(\"Author -   %s\\n\")\n\t\t\t_T(\"Notes -   %s\"), csTheme,\n\t\t\ttheme.FileVersion(),\n\t\t\ttheme.Author(),\n\t\t\ttheme.Notes());\n\n\t\tMessageBox(csMessage, _T(\"Ditto\"), MB_OK);\n\t}\n\telse\n\t{\n\t\tCString csError;\n\t\tcsError.Format(_T(\"Error loading theme file - %s - reason = \"), csTheme, theme.LastError());\n\n\t\tMessageBox(csError, _T(\"Ditto\"), MB_OK);\n\t}\n}\n\n\nvoid COptionsGeneral::OnBnClickedButtonDefaultFault()\n{\n\tmemset(&m_LogFont, 0, sizeof(m_LogFont));\n\n\tm_LogFont.lfHeight = -13;\n\tm_LogFont.lfWeight = 400;\n\tm_LogFont.lfCharSet = 1;\n\tSTRCPY(m_LogFont.lfFaceName, _T(\"Segoe UI\"));\n\t\t\n\tCString cs;\n\tcs.Format(_T(\"Font - %s (%d)\"), m_LogFont.lfFaceName, GetFontSize(m_hWnd, m_LogFont));\n\tm_btFont.SetWindowText(cs);\t\n}\n\nint COptionsGeneral::GetFontSize(HWND hWnd, const LOGFONT& lf)\n{\n\t//font is saved un scaled, so scale it with the default values to get the font size\n\tint nFontSize = -::MulDiv(lf.lfHeight, 72, 96);\n\t\n\treturn nFontSize;\n}\n\nvoid COptionsGeneral::OnBnClickedButtonFont()\n{\n\t//don't pass in an hwnd so it uses GetDeviceCaps to get the dpi, system not per monitor\n\tCDPI dpi;\n\n\tm_LogFont.lfHeight = dpi.Scale(m_LogFont.lfHeight);\n\n\tCFontDialog dlg(&m_LogFont, (CF_TTONLY | CF_SCREENFONTS), 0, this);\n\tif (dlg.DoModal() == IDOK)\n\t{\n\t\tmemcpy(&m_LogFont, dlg.m_cf.lpLogFont, sizeof(LOGFONT));\n\n\t\t//save the font unscaled, we will scale it per monitor later\n\t\tm_LogFont.lfHeight = dpi.UnScale(m_LogFont.lfHeight);\n\t\t\n\t\tCString cs;\n\t\tcs.Format(_T(\"Font - %s (%d)\"), m_LogFont.lfFaceName, GetFontSize(m_hWnd, m_LogFont));\n\t\tm_btFont.SetWindowText(cs);\n\t}\n}\n\n\n//void COptionsGeneral::OnNMClickSyslinkEnvVarInfo(NMHDR *pNMHDR, LRESULT *pResult)\n//{\n//\tCString url = _T(\"https:////sourceforge.net//p//ditto-cp//wiki//EnvironmentVariables//\");\n//\n//\tCHyperLink::GotoURL(url, SW_SHOW);\n//\n//\t*pResult = 0;\n//}\n//\n//\n//void COptionsGeneral::OnEnChangePath()\n//{\n//\t// TODO:  If this is a RICHEDIT control, the control will not\n//\t// send this notification unless you override the CPropertyPage::OnInitDialog()\n//\t// function and call CRichEditCtrl().SetEventMask()\n//\t// with the ENM_CHANGE flag ORed into the mask.\n//\n//\t// TODO:  Add your control notification handler code here\n//}\n\n\nvoid COptionsGeneral::OnEnChangePath()\n{\n\tif (m_originalEnvVariables == _T(\"\"))\n\t{\n\t\tm_envVarLink.GetWindowText(m_originalEnvVariables);\n\t}\n\n\tCString toSavePath;\n\tm_ePath.GetWindowText(toSavePath);\n\n\tif (toSavePath.Find(_T(\"%\")) >= 0)\n\t{\n\t\tCString resolvedPath = CGetSetOptions::ResolvePath(toSavePath);\n\t\tm_envVarLink.SetWindowText(resolvedPath);\t\t\n\t}\n\telse\n\t{\t\t\n\t\tm_envVarLink.SetWindowText(m_originalEnvVariables);\n\t}\t\t\n}\n\n\nvoid COptionsGeneral::OnClickedMaximumEntries()\n{\n\tif (m_btMaximumCheck.GetCheck() == BST_CHECKED)\n\t{\n\t\tm_eMaxSavedCopies.EnableWindow(TRUE);\n\t}\n\telse\n\t{\n\t\tm_eMaxSavedCopies.EnableWindow(FALSE);\n\t}\n}\n\n\nvoid COptionsGeneral::OnClickedExpireEntries()\n{\n\tif (m_btExpire.GetCheck() == BST_CHECKED)\n\t{\n\t\tm_eExpireAfter.EnableWindow(TRUE);\n\t}\n\telse\n\t{\n\t\tm_eExpireAfter.EnableWindow(FALSE);\n\t}\n}\n"
        },
        {
          "name": "OptionsGeneral.h",
          "type": "blob",
          "size": 2.8310546875,
          "content": "#if !defined(AFX_OPTIONSGENERAL_H__A13ABBF6_7636_4426_9A31_0189D4CA8F2F__INCLUDED_)\r\n#define AFX_OPTIONSGENERAL_H__A13ABBF6_7636_4426_9A31_0189D4CA8F2F__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n// OptionsGeneral.h : header file\r\n//\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"NumberEdit.h\"\r\n#include \"afxwin.h\"\r\n#include \"HyperLink.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsGeneral dialog\r\n\r\nclass COptionsGeneral : public CPropertyPage\r\n{\r\n\tDECLARE_DYNCREATE(COptionsGeneral)\r\n\r\n// Construction\r\npublic:\r\n\tCOptionsGeneral();\r\n\t~COptionsGeneral();\r\n\r\n// Dialog Data\r\n\t//{{AFX_DATA(COptionsGeneral)\r\n\tenum { IDD = IDD_OPTIONS_GENERAL };\r\n\t//CButton\tm_EnsureConnected;\r\n\tCNumberEdit\tm_SaveDelay;\r\n\tCComboBox m_cbLanguage;\r\n\tCEdit m_MaxClipSize;\r\n\tCButton\tm_btSendPasteMessage;\r\n\tCButton\tm_btHideDittoOnHotKey;\r\n\tCNumberEdit\tm_DescTextSize;\r\n\tCEdit m_ePath;\r\n\tCNumberEdit\tm_eExpireAfter;\r\n\tCNumberEdit\tm_eMaxSavedCopies;\r\n\tCButton\tm_btMaximumCheck;\r\n\tCButton\tm_btExpire;\r\n\tCButton m_btShowIconInSysTray;\r\n\tCButton\tm_btRunOnStartup;\r\n\tCButton m_btSaveMultiPaste;\r\n\tCString\tm_csPlaySound;\r\n\tCEdit m_ClipSeparator;\r\n\tCEdit m_copyAppInclude;\r\n\tCEdit m_copyAppExclude;\r\n\tCMFCLinkCtrl m_envVarLink;\r\n\t \r\n\t//}}AFX_DATA\r\n\r\n\r\n// Overrides\r\n\t// ClassWizard generate virtual function overrides\r\n\t//{{AFX_VIRTUAL(COptionsGeneral)\r\n\tpublic:\r\n\tvirtual BOOL OnSetActive();\r\n\tprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\r\n\tvirtual BOOL OnApply();\r\n\t//}}AFX_VIRTUAL\r\n\r\n// Implementation\r\nprotected:\r\n\t\r\n\tCOptionsSheet *m_pParent;\r\n\tCString m_csTitle;\r\n\tCBrush m_brush;\r\n\tLOGFONT m_LogFont;\r\n\tCFont m_envVarFont;\r\n\tCString m_originalEnvVariables;\r\n\t\r\n\tvoid FillThemes();\t\r\n\tvoid FillLanguages();\r\n\tint GetFontSize(HWND hWnd, const LOGFONT& lf);\r\n\r\n\t// Generated message map functions\r\n\t//{{AFX_MSG(COptionsGeneral)\r\n\tvirtual BOOL OnInitDialog();\r\n\tafx_msg void OnGetPath();\r\n\tafx_msg void OnButtonAbout();\r\n\t//}}AFX_MSG\r\n\tDECLARE_MESSAGE_MAP()\r\n\r\npublic:\r\n\tafx_msg void OnBnClickedButtonAdvanced();\r\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\r\n\tafx_msg void OnBnClickedButtonTheme();\r\n\tafx_msg void OnBnClickedButtonDefaultFault();\r\n\tafx_msg void OnBnClickedButtonFont();\r\n\tCComboBox m_cbTheme;\r\n\tCButton m_btFont;\r\n\tCButton m_btDefaultButton;\r\n\tCComboBox m_popupPositionCombo;\r\n\t//afx_msg void OnNMClickSyslinkEnvVarInfo(NMHDR *pNMHDR, LRESULT *pResult);\r\n\t//afx_msg void OnEnChangePath();\r\n\tafx_msg void OnEnChangePath();\r\n\tafx_msg void OnClickedMaximumEntries();\r\n\tafx_msg void OnClickedExpireEntries();\r\n};\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n#endif // !defined(AFX_OPTIONSGENERAL_H__A13ABBF6_7636_4426_9A31_0189D4CA8F2F__INCLUDED_)\r\n"
        },
        {
          "name": "OptionsKeyBoard.cpp",
          "type": "blob",
          "size": 6.271484375,
          "content": "// OptionsKeyBoard.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsKeyBoard.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsKeyBoard property page\r\n\r\nIMPLEMENT_DYNCREATE(COptionsKeyBoard, CPropertyPage)\r\n\r\nCOptionsKeyBoard::COptionsKeyBoard() : CPropertyPage(COptionsKeyBoard::IDD)\r\n{\r\n\tm_csTitle = theApp.m_Language.GetString(\"KeyboardShortcutsTitle\", \"Keyboard Shortcuts\");\r\n\tm_psp.pszTitle = m_csTitle;\r\n\tm_psp.dwFlags |= PSP_USETITLE;\r\n\t\r\n\t//{{AFX_DATA_INIT(COptionsKeyBoard)\r\n\t//}}AFX_DATA_INIT\r\n}\r\n\r\nCOptionsKeyBoard::~COptionsKeyBoard()\r\n{\r\n}\r\n\r\nvoid COptionsKeyBoard::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCPropertyPage::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(COptionsKeyBoard)\r\n\tDDX_Control(pDX, IDC_CHECK_SEND_PASTE, m_btSendPaste);\r\n\tDDX_Control(pDX, IDC_CHECK_USE_UI_GROUP_LAST_10, m_UseUiGroupForLastTen);\r\n\tDDX_Control(pDX, IDC_HOTKEY9, m_Nine);\r\n\tDDX_Control(pDX, IDC_HOTKEY8, m_Eight);\r\n\tDDX_Control(pDX, IDC_HOTKEY7, m_Seven);\r\n\tDDX_Control(pDX, IDC_HOTKEY6, m_Six);\r\n\tDDX_Control(pDX, IDC_HOTKEY5, m_Five);\r\n\tDDX_Control(pDX, IDC_HOTKEY4, m_Four);\r\n\tDDX_Control(pDX, IDC_HOTKEY3, m_Three);\r\n\tDDX_Control(pDX, IDC_HOTKEY2, m_Two);\r\n\tDDX_Control(pDX, IDC_HOTKEY10, m_Ten);\r\n\tDDX_Control(pDX, IDC_HOTKEY1, m_One);\r\n\tDDX_Control(pDX, IDC_HOTKEY, m_HotKey);\r\n\tDDX_Control(pDX, IDC_HOTKEY_ACTIVATE_2, m_HotKey2);\r\n\tDDX_Control(pDX, IDC_HOTKEY_ACTIVATE_3, m_HotKey3);\r\n\tDDX_Control(pDX, IDC_HOTKEY_TEXT_ONLY, m_TextOnlyKey);\r\n\t//}}AFX_DATA_MAP\r\n\tDDX_Control(pDX, IDC_STATIC_CUSTOM_KEYS, m_CustomeKeysHelp);\r\n\tDDX_Control(pDX, IDC_CHECK_MOVE_CLIPS_ON_PASTE, m_btMoveClipOnGlobal10);\r\n\tDDX_Control(pDX, IDC_HOTKEY_SAVE_CLIPBOARD, m_saveClipboardHotKey);\r\n\tDDX_Control(pDX, IDC_HOTKEY_COPYSAVECLIPBOARD, m_copyAndSaveClipboardCtrl);\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(COptionsKeyBoard, CPropertyPage)\r\n\t//{{AFX_MSG_MAP(COptionsKeyBoard)\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsKeyBoard message handlers\r\n\r\nBOOL COptionsKeyBoard::OnInitDialog() \r\n{\r\n\tCPropertyPage::OnInitDialog();\r\n\r\n\tm_CustomeKeysHelp.SetURL(_T(\"https://github.com/sabrogden/Ditto/wiki/Custom-Key-Strokes\"));\r\n\r\n\tm_pParent = (COptionsSheet *)GetParent();\r\n\r\n\ttheApp.m_pDittoHotKey->CopyToCtrl(m_HotKey, m_hWnd, IDC_CHECK_WIN_DITTO);\r\n\ttheApp.m_pDittoHotKey2->CopyToCtrl(m_HotKey2, m_hWnd, IDC_CHECK_WIN_DITTO2);\r\n\ttheApp.m_pDittoHotKey3->CopyToCtrl(m_HotKey3, m_hWnd, IDC_CHECK_WIN_DITTO3);\r\n\r\n\ttheApp.m_pPosOne->CopyToCtrl(m_One, m_hWnd, IDC_CHECK_WIN1);\r\n\ttheApp.m_pPosTwo->CopyToCtrl(m_Two, m_hWnd, IDC_CHECK_WIN2);\r\n\ttheApp.m_pPosThree->CopyToCtrl(m_Three, m_hWnd, IDC_CHECK_WIN3);\r\n\ttheApp.m_pPosFour->CopyToCtrl(m_Four, m_hWnd, IDC_CHECK_WIN4);\r\n\ttheApp.m_pPosFive->CopyToCtrl(m_Five, m_hWnd, IDC_CHECK_WIN5);\r\n\ttheApp.m_pPosSix->CopyToCtrl(m_Six, m_hWnd, IDC_CHECK_WIN6);\r\n\ttheApp.m_pPosSeven->CopyToCtrl(m_Seven, m_hWnd, IDC_CHECK_WIN7);\r\n\ttheApp.m_pPosEight->CopyToCtrl(m_Eight, m_hWnd, IDC_CHECK_WIN8);\r\n\ttheApp.m_pPosNine->CopyToCtrl(m_Nine, m_hWnd, IDC_CHECK_WIN9);\r\n\ttheApp.m_pPosTen->CopyToCtrl(m_Ten, m_hWnd, IDC_CHECK_WIN10);\r\n\ttheApp.m_pTextOnlyPaste->CopyToCtrl(m_TextOnlyKey, m_hWnd, IDC_CHECK_WIN_TEXT_ONLY);\r\n\ttheApp.m_pSaveClipboard->CopyToCtrl(m_saveClipboardHotKey, m_hWnd, IDC_CHECK_WIN_SAVE_CLIPBOARD);\r\n\ttheApp.m_pCopyAndSaveClipboard->CopyToCtrl(m_copyAndSaveClipboardCtrl, m_hWnd, IDC_CHECK_WIN_COPY_SAVE_CLIPBOARD);\r\n\r\n\r\n\t//Unregister hotkeys and Reregister them on cancel or ok\r\n\tg_HotKeys.UnregisterAll();\r\n\r\n\tm_btSendPaste.SetCheck(CGetSetOptions::m_bSendPasteOnFirstTenHotKeys);\r\n\tm_UseUiGroupForLastTen.SetCheck(CGetSetOptions::GetUseUISelectedGroupForLastTenCopies());\r\n\r\n\tm_btMoveClipOnGlobal10.SetCheck(CGetSetOptions::GetMoveClipsOnGlobal10());\r\n\r\n\tm_HotKey.SetFocus();\r\n\r\n\ttheApp.m_Language.UpdateOptionShortcuts(this);\t\r\n\t\t\r\n\treturn FALSE;\r\n}\r\n\r\nLRESULT COptionsKeyBoard::OnWizardNext() \r\n{\r\n\treturn CPropertyPage::OnWizardNext();\r\n}\r\n\r\nBOOL COptionsKeyBoard::OnWizardFinish() \r\n{\r\n\treturn CPropertyPage::OnWizardFinish();\r\n}\r\n\r\nBOOL COptionsKeyBoard::OnApply()\r\n{\r\n\tCGetSetOptions::SetSendPasteOnFirstTenHotKeys(m_btSendPaste.GetCheck());\r\n\tCGetSetOptions::SetMoveClipsOnGlobal10(m_btMoveClipOnGlobal10.GetCheck());\r\n\tCGetSetOptions::SetUseUISelectedGroupForLastTenCopies(m_UseUiGroupForLastTen.GetCheck());\r\n\t\t\t\t\t\r\n\tINT_PTR x,y;\r\n\tCString str;\r\n\tARRAY keys;\r\n\t\r\n\tg_HotKeys.GetKeys( keys ); // save old keys just in case new ones are invalid\r\n\t\r\n\ttheApp.m_pDittoHotKey->CopyFromCtrl(m_HotKey, m_hWnd, IDC_CHECK_WIN_DITTO);\r\n\ttheApp.m_pDittoHotKey2->CopyFromCtrl(m_HotKey2, m_hWnd, IDC_CHECK_WIN_DITTO2);\r\n\ttheApp.m_pDittoHotKey3->CopyFromCtrl(m_HotKey3, m_hWnd, IDC_CHECK_WIN_DITTO3);\r\n\t\r\n\ttheApp.m_pPosOne->CopyFromCtrl(m_One, m_hWnd, IDC_CHECK_WIN1);\r\n\ttheApp.m_pPosTwo->CopyFromCtrl(m_Two, m_hWnd, IDC_CHECK_WIN2);\r\n\ttheApp.m_pPosThree->CopyFromCtrl(m_Three, m_hWnd, IDC_CHECK_WIN3);\r\n\ttheApp.m_pPosFour->CopyFromCtrl(m_Four, m_hWnd, IDC_CHECK_WIN4);\r\n\ttheApp.m_pPosFive->CopyFromCtrl(m_Five, m_hWnd, IDC_CHECK_WIN5);\r\n\ttheApp.m_pPosSix->CopyFromCtrl(m_Six, m_hWnd, IDC_CHECK_WIN6);\r\n\ttheApp.m_pPosSeven->CopyFromCtrl(m_Seven, m_hWnd, IDC_CHECK_WIN7);\r\n\ttheApp.m_pPosEight->CopyFromCtrl(m_Eight, m_hWnd, IDC_CHECK_WIN8);\r\n\ttheApp.m_pPosNine->CopyFromCtrl(m_Nine, m_hWnd, IDC_CHECK_WIN9);\r\n\ttheApp.m_pPosTen->CopyFromCtrl(m_Ten, m_hWnd, IDC_CHECK_WIN10);\r\n\ttheApp.m_pTextOnlyPaste->CopyFromCtrl(m_TextOnlyKey, m_hWnd, IDC_CHECK_WIN_TEXT_ONLY);\r\n\ttheApp.m_pSaveClipboard->CopyFromCtrl(m_saveClipboardHotKey, m_hWnd, IDC_CHECK_WIN_SAVE_CLIPBOARD);\r\n\ttheApp.m_pCopyAndSaveClipboard->CopyFromCtrl(m_copyAndSaveClipboardCtrl, m_hWnd, IDC_CHECK_WIN_COPY_SAVE_CLIPBOARD);\r\n\r\n\tARRAY NewKeys;\r\n\tg_HotKeys.GetKeys(NewKeys);\r\n\t\r\n\tif(g_HotKeys.FindFirstConflict(NewKeys, &x, &y))\r\n\t{\r\n\t\tstr =  g_HotKeys.ElementAt(x)->GetName();\r\n\t\tstr += \" and \";\r\n\t\tstr += g_HotKeys.ElementAt(y)->GetName();\r\n\t\tstr += \" cannot be the same.\";\r\n\t\tMessageBox(str);\r\n\t\tg_HotKeys.SetKeys(keys); // restore the original values\r\n\t\treturn FALSE;\r\n\t}\r\n\t\r\n\tg_HotKeys.SaveAllKeys();\r\n\tg_HotKeys.RegisterAll(true);\r\n\t\r\n\treturn CPropertyPage::OnApply();\r\n}\r\n\r\nvoid COptionsKeyBoard::OnCancel() \r\n{\r\n\tg_HotKeys.RegisterAll( true );\r\n\tCPropertyPage::OnCancel();\r\n}\r\n"
        },
        {
          "name": "OptionsKeyBoard.h",
          "type": "blob",
          "size": 2.1416015625,
          "content": "#if !defined(AFX_OPTIONSKEYBOARD_H__3E1A060F_019B_4117_8C53_15326D1ABFAE__INCLUDED_)\r\n#define AFX_OPTIONSKEYBOARD_H__3E1A060F_019B_4117_8C53_15326D1ABFAE__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n// OptionsKeyBoard.h : header file\r\n//\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"afxwin.h\"\r\n#include \"HyperLink.h\"\r\n#include \"afxcmn.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsKeyBoard dialog\r\n\r\nclass COptionsKeyBoard : public CPropertyPage\r\n{\r\n\tDECLARE_DYNCREATE(COptionsKeyBoard)\r\n\r\n// Construction\r\npublic:\r\n\tCOptionsKeyBoard();\r\n\t~COptionsKeyBoard();\r\n\r\n// Dialog Data\r\n\t//{{AFX_DATA(COptionsKeyBoard)\r\n\tenum { IDD = IDD_OPTIONS_KEYSTROKES };\r\n\tCButton\tm_btSendPaste;\r\n\tCButton\tm_UseUiGroupForLastTen;\r\n\tCButton\tm_btMoveClipOnGlobal10;\r\n\tCHotKeyCtrl\tm_Nine;\r\n\tCHotKeyCtrl\tm_Eight;\r\n\tCHotKeyCtrl\tm_Seven;\r\n\tCHotKeyCtrl\tm_Six;\r\n\tCHotKeyCtrl\tm_Five;\r\n\tCHotKeyCtrl\tm_Four;\r\n\tCHotKeyCtrl\tm_Three;\r\n\tCHotKeyCtrl\tm_Two;\r\n\tCHotKeyCtrl\tm_Ten;\r\n\tCHotKeyCtrl\tm_One;\r\n\tCHotKeyCtrl\tm_HotKey;\r\n\tCHotKeyCtrl\tm_HotKey2;\r\n\tCHotKeyCtrl\tm_HotKey3;\r\n\tCHotKeyCtrl m_TextOnlyKey;\r\n\tCHotKeyCtrl m_copyAndSaveClipboardCtrl;\r\n\t//}}AFX_DATA\r\n\r\n\r\n// Overrides\r\n\t// ClassWizard generate virtual function overrides\r\n\t//{{AFX_VIRTUAL(COptionsKeyBoard)\r\n\tpublic:\r\n\tvirtual LRESULT OnWizardNext();\r\n\tvirtual BOOL OnWizardFinish();\r\n\tvirtual BOOL OnApply();\r\n\tvirtual void OnCancel();\r\n\tprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\r\n\t//}}AFX_VIRTUAL\r\n\r\n// Implementation\r\nprotected:\r\n//\tBOOL RegisterHotKey(WORD wHotKey);\r\n//\tBOOL ValidateHotKey(WORD wHotKey);\r\n\r\n\tCOptionsSheet *m_pParent;\r\n\tCString m_csTitle;\r\n\r\n\t// Generated message map functions\r\n\t//{{AFX_MSG(COptionsKeyBoard)\r\n\tvirtual BOOL OnInitDialog();\r\n\t//}}AFX_MSG\r\n\tDECLARE_MESSAGE_MAP()\r\n\r\npublic:\r\n\tCMFCLinkCtrl m_CustomeKeysHelp;\r\n\tCHotKeyCtrl m_saveClipboardHotKey;\r\n};\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n#endif // !defined(AFX_OPTIONSKEYBOARD_H__3E1A060F_019B_4117_8C53_15326D1ABFAE__INCLUDED_)\r\n"
        },
        {
          "name": "OptionsQuickPaste.cpp",
          "type": "blob",
          "size": 10.1376953125,
          "content": "// OptionsQuickPaste.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsQuickPaste.h\"\r\n#include \".\\optionsquickpaste.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n#define DEFAULT_THEME _T(\"(Default)\")\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsQuickPaste property page\r\n\r\nIMPLEMENT_DYNCREATE(COptionsQuickPaste, CPropertyPage)\r\n\r\nCOptionsQuickPaste::COptionsQuickPaste() : CPropertyPage(COptionsQuickPaste::IDD)\r\n{\r\n\tm_csTitle = theApp.m_Language.GetString(\"QuickPasteTitle\", \"Quick Paste\");\r\n\tm_psp.pszTitle = m_csTitle;\r\n\tm_psp.dwFlags |= PSP_USETITLE; \r\n\r\n\t//{{AFX_DATA_INIT(COptionsQuickPaste)\r\n\t\t// NOTE: the ClassWizard will add member initialization here\r\n\t//}}AFX_DATA_INIT\r\n\r\n\tmemset(&m_LogFont, 0, sizeof(LOGFONT));\r\n}\r\n\r\nCOptionsQuickPaste::~COptionsQuickPaste()\r\n{\r\n\tm_Font.DeleteObject();\r\n}\r\n\r\nvoid COptionsQuickPaste::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCPropertyPage::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(COptionsQuickPaste)\r\n\tDDX_Control(pDX, IDC_CHECK_ENTIRE_WINDOW_IS_VISIBLE, m_EnsureEntireWindowVisible);\r\n\tDDX_Control(pDX, IDC_CHECK_SHOW_ALL_IN_MAIN_LIST, m_ShowAllInMainList);\r\n\tDDX_Control(pDX, IDC_CHECK_FIND_AS_YOU_TYPE, m_FindAsYouType);\r\n\tDDX_Control(pDX, IDC_DRAW_RTF, m_btDrawRTF);\r\n\tDDX_Control(pDX, IDC_SHOW_THUMBNAILS, m_btShowThumbnails);\r\n\tDDX_Control(pDX, IDC_BUTTON_DEFAULT_FAULT, m_btDefaultButton);\r\n\tDDX_Control(pDX, IDC_BUTTON_FONT, m_btFont);\r\n\tDDX_Control(pDX, IDC_SHOW_TEXT_FOR_FIRST_TEN_HOT_KEYS, m_btShowText);\r\n\tDDX_Control(pDX, IDC_LINES_ROW, m_eLinesPerRow);\r\n\tDDX_Control(pDX, IDC_TRANS_PERC, m_eTransparencyPercent);\r\n\tDDX_Control(pDX, IDC_TRANSPARENCY, m_btEnableTransparency);\r\n\tDDX_Control(pDX, IDC_DESC_SHOW_LEADING_WHITESPACE, m_btDescShowLeadingWhiteSpace);\r\n\t//}}AFX_DATA_MAP\r\n\tDDX_Control(pDX, IDC_CHECK_PROMPT_DELETE_CLIP, m_PromptForDelete);\r\n\tDDX_Control(pDX, IDC_COMBO_THEME, m_cbTheme);\r\n\tDDX_Control(pDX, IDC_CHECK_SHOW_SCROLL_BAR, m_alwaysShowScrollBar);\r\n\tDDX_Control(pDX, IDC_CHECK_ELEVATE_PRIVILEGES, m_elevatedPrivileges);\r\n\tDDX_Control(pDX, IDC_CHECK_SHOW_IN_TASKBAR, m_showInTaskBar);\r\n\tDDX_Control(pDX, IDC_EDIT_DIFF_PATH, m_diffPathEditBox);\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(COptionsQuickPaste, CPropertyPage)\r\n\t//{{AFX_MSG_MAP(COptionsQuickPaste)\r\n\tON_BN_CLICKED(IDC_BUTTON_FONT, OnButtonFont)\r\n\tON_BN_CLICKED(IDC_BUTTON_DEFAULT_FAULT, OnButtonDefaultFault)\r\n\t//}}AFX_MSG_MAP\r\n\tON_BN_CLICKED(IDC_BUTTON_THEME, OnBnClickedButtonTheme)\r\n\tON_BN_CLICKED(IDC_BUTTON_DIFF_BROWSE, &COptionsQuickPaste::OnBnClickedButtonDiffBrowse)\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsQuickPaste message handlers\r\n\r\nBOOL COptionsQuickPaste::OnInitDialog() \r\n{\r\n\tCPropertyPage::OnInitDialog();\r\n\r\n\tm_pParent = (COptionsSheet *)GetParent();\r\n\t\r\n\tm_btEnableTransparency.SetCheck(CGetSetOptions::GetEnableTransparency());\r\n\tm_eTransparencyPercent.SetNumber(CGetSetOptions::GetTransparencyPercent());\r\n\tm_eLinesPerRow.SetNumber(CGetSetOptions::GetLinesPerRow());\r\n\tm_alwaysShowScrollBar.SetCheck(CGetSetOptions::GetShowScrollBar());\r\n\tm_btShowThumbnails.SetCheck(CGetSetOptions::m_bDrawThumbnail);\r\n\tm_btDrawRTF.SetCheck(CGetSetOptions::m_bDrawRTF);\r\n\r\n\tm_EnsureEntireWindowVisible.SetCheck(CGetSetOptions::m_bEnsureEntireWindowCanBeSeen);\r\n\tm_ShowAllInMainList.SetCheck(CGetSetOptions::m_bShowAllClipsInMainList);\r\n\tm_FindAsYouType.SetCheck(CGetSetOptions::m_bFindAsYouType);\r\n\r\n\tif(CGetSetOptions::GetQuickPastePosition() == POS_AT_CARET)\r\n\t\tCheckDlgButton(IDC_AT_CARET, BST_CHECKED);\r\n\telse if(CGetSetOptions::GetQuickPastePosition() == POS_AT_CURSOR)\r\n\t\tCheckDlgButton(IDC_AT_CURSOR, BST_CHECKED);\r\n\telse if(CGetSetOptions::GetQuickPastePosition() == POS_AT_PREVIOUS)\r\n\t\tCheckDlgButton(IDC_AT_PREVIOUS, BST_CHECKED);\r\n\r\n\tm_btDescShowLeadingWhiteSpace.SetCheck(CGetSetOptions::m_bDescShowLeadingWhiteSpace);\r\n\r\n\tm_btShowText.SetCheck(CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\tm_PromptForDelete.SetCheck(CGetSetOptions::GetPromptWhenDeletingClips());\r\n\tm_elevatedPrivileges.SetCheck(CGetSetOptions::GetPasteAsAdmin());\r\n\tm_showInTaskBar.SetCheck(CGetSetOptions::GetShowInTaskBar());\r\n\r\n\tif(CGetSetOptions::GetFont(m_LogFont))\r\n\t{\t\t\r\n\t\tm_Font.CreateFontIndirect(&m_LogFont);\r\n\t\tm_btFont.SetFont(&m_Font);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCFont *ft =\tm_btFont.GetFont();\r\n\t\tft->GetLogFont(&m_LogFont);\r\n\t}\r\n\r\n\tm_diffPathEditBox.SetWindowText(CGetSetOptions::GetDiffApp());\r\n\r\n\tCString cs;\r\n\tcs.Format(_T(\"Font - %s\"), m_LogFont.lfFaceName);\r\n\tm_btFont.SetWindowText(cs);\r\n\r\n\tif (CGetSetOptions::GetShowIfClipWasPasted())\r\n\t\tCheckDlgButton(IDC_CHECK_SHOW_CLIP_WAS_PASTED, BST_CHECKED);\r\n\r\n\tFillThemes();\r\n\r\n\ttheApp.m_Language.UpdateOptionQuickPaste(this);\r\n\t\t\r\n\treturn FALSE;\r\n}\r\n\r\nBOOL COptionsQuickPaste::OnApply() \r\n{\r\n\tCGetSetOptions::SetEnableTransparency(m_btEnableTransparency.GetCheck());\r\n\tCGetSetOptions::SetTransparencyPercent(m_eTransparencyPercent.GetNumber());\r\n\tCGetSetOptions::SetLinesPerRow(m_eLinesPerRow.GetNumber());\r\n\tCGetSetOptions::SetShowScrollBar(m_alwaysShowScrollBar.GetCheck());\r\n\t\r\n\tif(IsDlgButtonChecked(IDC_AT_CARET))\r\n\t\tCGetSetOptions::SetQuickPastePosition(POS_AT_CARET);\r\n\telse if(IsDlgButtonChecked(IDC_AT_CURSOR))\r\n\t\tCGetSetOptions::SetQuickPastePosition(POS_AT_CURSOR);\r\n\telse if(IsDlgButtonChecked(IDC_AT_PREVIOUS))\r\n\t\tCGetSetOptions::SetQuickPastePosition(POS_AT_PREVIOUS);\r\n\r\n\tCGetSetOptions::SetDescShowLeadingWhiteSpace(m_btDescShowLeadingWhiteSpace.GetCheck());\r\n\tCGetSetOptions::SetShowTextForFirstTenHotKeys(m_btShowText.GetCheck());\r\n\tCGetSetOptions::SetDrawThumbnail(m_btShowThumbnails.GetCheck());\r\n\tCGetSetOptions::SetDrawRTF(m_btDrawRTF.GetCheck());\r\n\tCGetSetOptions::SetEnsureEntireWindowCanBeSeen(m_EnsureEntireWindowVisible.GetCheck());\r\n\tCGetSetOptions::SetShowAllClipsInMainList(m_ShowAllInMainList.GetCheck());\r\n\tCGetSetOptions::SetFindAsYouType(m_FindAsYouType.GetCheck());\r\n\tCGetSetOptions::SetPromptWhenDeletingClips(m_PromptForDelete.GetCheck());\r\n\tCGetSetOptions::SetPasteAsAdmin(m_elevatedPrivileges.GetCheck());\r\n\r\n\tBOOL prevValue = CGetSetOptions::GetShowInTaskBar();\r\n\tCGetSetOptions::SetShowInTaskBar(m_showInTaskBar.GetCheck());\r\n\tif(CGetSetOptions::GetShowInTaskBar() != prevValue)\r\n\t{\r\n\t\ttheApp.RefreshShowInTaskBar();\r\n\t}\r\n\t\r\n\tif(m_LogFont.lfWeight != 0)\r\n\t{\r\n\t\tCGetSetOptions::SetFont(m_LogFont);\r\n\t}\r\n\r\n\tCString currentTheme = CGetSetOptions::GetTheme();\r\n\r\n\tCString csTheme;\r\n\tif(m_cbTheme.GetCurSel() >= 0)\r\n\t{\r\n\t\tm_cbTheme.GetLBText(m_cbTheme.GetCurSel(), csTheme);\r\n\t\tif (csTheme == DEFAULT_THEME)\r\n\t\t{\r\n\t\t\tCGetSetOptions::SetTheme(\"\");\r\n\t\t\tcsTheme = _T(\"\");\r\n\t\t}\r\n\t\telse\r\n\t\t\tCGetSetOptions::SetTheme(csTheme);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCGetSetOptions::SetTheme(\"\");\r\n\t}\r\n\r\n\tif (currentTheme != csTheme)\r\n\t{\r\n\t\tm_pParent->m_themeChanged = TRUE;\r\n\t}\r\n\r\n\tCString diffPath;\r\n\tm_diffPathEditBox.GetWindowText(diffPath);\r\n\tCGetSetOptions::SetDiffApp(diffPath);\r\n\r\n\tif (IsDlgButtonChecked(IDC_CHECK_SHOW_CLIP_WAS_PASTED))\r\n\t\tCGetSetOptions::SetShowIfClipWasPasted(TRUE);\r\n\telse\r\n\t\tCGetSetOptions::SetShowIfClipWasPasted(FALSE);\r\n\t\r\n\treturn CPropertyPage::OnApply();\r\n}\r\n\r\nvoid COptionsQuickPaste::OnButtonFont() \r\n{\r\n\tCFontDialog dlg(&m_LogFont, (CF_TTONLY | CF_SCREENFONTS), 0, this);\r\n\tif(dlg.DoModal() == IDOK)\r\n\t{\t\r\n\t\tm_Font.DeleteObject();\r\n\r\n\t\tmemcpy(&m_LogFont, dlg.m_cf.lpLogFont, sizeof(LOGFONT));\t\t\r\n\r\n\t\tm_Font.CreateFontIndirect(&m_LogFont);\r\n\r\n\t\tm_btFont.SetFont(&m_Font);\r\n\r\n\t\tCString cs;\r\n\t\tcs.Format(_T(\"Font - %s\"), m_LogFont.lfFaceName);\r\n\t\tm_btFont.SetWindowText(cs);\r\n\t}\r\n}\r\n\r\nvoid COptionsQuickPaste::OnButtonDefaultFault() \r\n{\r\n\tCFont *ft =\tm_btDefaultButton.GetFont();\r\n\tft->GetLogFont(&m_LogFont);\r\n\r\n\tmemset(&m_LogFont, 0, sizeof(m_LogFont));\r\n\r\n\tm_LogFont.lfHeight = -10;\r\n\tm_LogFont.lfWeight = 400;\r\n\tm_LogFont.lfCharSet = 1;\r\n\tSTRCPY(m_LogFont.lfFaceName, _T(\"Segoe UI\"));\r\n\r\n\tm_Font.DeleteObject();\r\n\tm_Font.CreateFontIndirect(&m_LogFont);\r\n\r\n\tm_btFont.SetFont(&m_Font);\r\n\r\n\tCString cs;\r\n\tcs.Format(_T(\"Font - %s\"), m_LogFont.lfFaceName);\r\n\tm_btFont.SetWindowText(cs);\r\n}\t\r\n\r\nvoid COptionsQuickPaste::FillThemes()\r\n{\r\n\tCString csFile = CGetSetOptions::GetPath(PATH_THEMES);\r\n\tcsFile += \"*.xml\";\r\n\r\n\tCString csTheme = CGetSetOptions::GetTheme();\r\n\r\n\tCFileFind find;\r\n\tBOOL bCont = find.FindFile(csFile);\r\n\tbool bSetCurSel = false;\r\n\r\n\twhile(bCont)\r\n\t{\r\n\t\tbCont = find.FindNextFile();\r\n\r\n\t\tCTheme theme;\r\n\t\tif (theme.Load(find.GetFileTitle(), true, false))\r\n\t\t{\r\n\t\t\tif (theme.FileVersion() >= 2 && theme.FileVersion() < 100)\r\n\t\t\t{\r\n\t\t\t\tint nIndex = m_cbTheme.AddString(find.GetFileTitle());\r\n\r\n\t\t\t\tif (find.GetFileTitle() == csTheme)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_cbTheme.SetCurSel(nIndex);\r\n\t\t\t\t\tbSetCurSel = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tint nIndex = m_cbTheme.AddString(DEFAULT_THEME);\r\n\tif(bSetCurSel == false)\r\n\t{\r\n\t\tm_cbTheme.SetCurSel(nIndex);\r\n\t}\r\n}\r\n\r\nvoid COptionsQuickPaste::OnBnClickedButtonTheme()\r\n{\r\n\tCTheme theme;\r\n\r\n\tCString csTheme;\r\n\tm_cbTheme.GetLBText(m_cbTheme.GetCurSel(), csTheme);\r\n\r\n\tif(csTheme == DEFAULT_THEME)\r\n\t\treturn;\r\n\t\r\n\tif(theme.Load(csTheme, true, false))\r\n\t{\r\n\t\tCString csMessage;\r\n\r\n\t\tcsMessage.Format(_T(\"Theme -  %s\\n\")\r\n\t\t\t_T(\"Version -   %d\\n\")\r\n\t\t\t_T(\"Author -   %s\\n\")\r\n\t\t\t_T(\"Notes -   %s\"), csTheme, \r\n\t\t\ttheme.FileVersion(), \r\n\t\t\ttheme.Author(), \r\n\t\t\ttheme.Notes());\r\n\r\n\t\tMessageBox(csMessage, _T(\"Ditto\"), MB_OK);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCString csError;\r\n\t\tcsError.Format(_T(\"Error loading theme file - %s - reason = \"), csTheme, theme.LastError());\r\n\r\n\t\tMessageBox(csError, _T(\"Ditto\"), MB_OK);\r\n\t}\r\n}\r\n\r\n\r\nvoid COptionsQuickPaste::OnBnClickedButtonDiffBrowse()\r\n{\r\n\tOPENFILENAME\tFileName;\r\n\tTCHAR\t\t\tszFileName[400];\r\n\tTCHAR\t\t\tszDir[400];\r\n\r\n\tmemset(&FileName, 0, sizeof(FileName));\r\n\tmemset(szFileName, 0, sizeof(szFileName));\r\n\tmemset(&szDir, 0, sizeof(szDir));\r\n\tFileName.lStructSize = sizeof(FileName);\r\n\tFileName.lpstrTitle = _T(\"Diff Application\");\r\n\tFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;\r\n\tFileName.nMaxFile = 400;\r\n\tFileName.lpstrFile = szFileName;\r\n\tFileName.lpstrInitialDir = szDir;\r\n\tFileName.lpstrFilter = _T(\"*.exe\");\r\n\tFileName.lpstrDefExt = _T(\"\");\r\n\tFileName.hwndOwner = m_hWnd;\r\n\r\n\tif(GetOpenFileName(&FileName) == 0)\r\n\t\treturn;\r\n\r\n\tCString csPath(FileName.lpstrFile);\r\n\r\n\tm_diffPathEditBox.SetWindowText(csPath);\r\n}\r\n"
        },
        {
          "name": "OptionsQuickPaste.h",
          "type": "blob",
          "size": 2.1689453125,
          "content": "#if !defined(AFX_OPTIONSQUICKPASTE_H__69465009_2717_4BD5_BFFC_8CD537732050__INCLUDED_)\r\n#define AFX_OPTIONSQUICKPASTE_H__69465009_2717_4BD5_BFFC_8CD537732050__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n// OptionsQuickPaste.h : header file\r\n#include \"NumberEdit.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"afxwin.h\"\r\n//\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsQuickPaste dialog\r\n\r\nclass COptionsQuickPaste : public CPropertyPage\r\n{\r\n\tDECLARE_DYNCREATE(COptionsQuickPaste)\r\n\r\n// Construction\r\npublic:\r\n\tCOptionsQuickPaste();\r\n\t~COptionsQuickPaste();\r\n\r\n// Dialog Data\r\n\t//{{AFX_DATA(COptionsQuickPaste)\r\n\tenum { IDD = IDD_OPTIONS_QUICK_PASTE };\r\n\tCButton\tm_EnsureEntireWindowVisible;\r\n\tCButton\tm_ShowAllInMainList;\r\n\tCButton\tm_FindAsYouType;\r\n\tCButton\tm_btDrawRTF;\r\n\tCButton\tm_btShowThumbnails;\r\n\tCButton\tm_btDefaultButton;\r\n\tCButton\tm_btFont;\r\n\tCButton\tm_btShowText;\r\n\tCNumberEdit\tm_eLinesPerRow;\r\n\tCNumberEdit\tm_eTransparencyPercent;\r\n\tCButton\tm_btEnableTransparency;\r\n\tCButton m_btDescShowLeadingWhiteSpace;\r\n\t//}}AFX_DATA\r\n\r\n\r\n// Overrides\r\n\t// ClassWizard generate virtual function overrides\r\n\t//{{AFX_VIRTUAL(COptionsQuickPaste)\r\n\tpublic:\r\n\tvirtual BOOL OnApply();\r\n\tprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\r\n\t//}}AFX_VIRTUAL\r\nprotected:\r\n\tCOptionsSheet *m_pParent;\r\n\r\n\tCFont m_Font;\r\n\tLOGFONT m_LogFont;\r\n\tCString m_csTitle;\r\n\r\n\tvoid FillThemes();\r\n\r\n\r\n// Implementation\r\nprotected:\r\n\t// Generated message map functions\r\n\t//{{AFX_MSG(COptionsQuickPaste)\r\n\tvirtual BOOL OnInitDialog();\r\n\tafx_msg void OnButtonFont();\r\n\tafx_msg void OnButtonDefaultFault();\r\n\t//}}AFX_MSG\r\n\tDECLARE_MESSAGE_MAP()\r\n\r\npublic:\r\n\tCButton m_PromptForDelete;\r\n\tCButton m_elevatedPrivileges;\r\n\tCButton m_showInTaskBar;\r\n\tCComboBox m_cbTheme;\r\n\tafx_msg void OnBnClickedButtonTheme();\r\n\tCButton m_alwaysShowScrollBar;\r\n\tCEdit m_diffPathEditBox;\r\n\tafx_msg void OnBnClickedButtonDiffBrowse();\r\n};\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n#endif // !defined(AFX_OPTIONSQUICKPASTE_H__69465009_2717_4BD5_BFFC_8CD537732050__INCLUDED_)\r\n"
        },
        {
          "name": "OptionsSheet.cpp",
          "type": "blob",
          "size": 3.20703125,
          "content": "// OptionsSheet.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsSheet.h\"\r\n#include \"OptionsKeyBoard.h\"\r\n#include \"OptionsGeneral.h\"\r\n#include \"OptionsQuickPaste.h\"\r\n#include \"OptionsStats.h\"\r\n#include \"OptionsTypes.h\"\r\n#include \"About.h\"\r\n#include \"OptionFriends.h\"\r\n#include \"OptionsCopyBuffers.h\"\r\n#include \"Misc.h\"\r\n#include \"QuickPasteKeyboard.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif \r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsSheet\r\n\r\nIMPLEMENT_DYNAMIC(COptionsSheet, CPropertySheet)\r\n\r\nCOptionsSheet::COptionsSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)\r\n\t:CPropertySheet(pszCaption, pParentWnd, iSelectPage)\r\n{\r\n\tm_themeChanged = FALSE;\r\n\tm_pKeyBoardOptions = NULL;\r\n\tm_pGeneralOptions = NULL;\r\n\t//m_pQuickPasteOptions = NULL;\r\n\tm_pCopyBuffers = NULL;\r\n\tm_pStats = NULL;\r\n\tm_pTypes = NULL;\r\n\tm_pAbout = NULL;\r\n\tm_pFriends = NULL;\r\n\tm_pCopyBuffers = NULL;\r\n\tm_pQuickPasteShortCuts = NULL;\r\n\t\r\n\tm_pUtilites = NULL;\r\n\tm_hWndParent = NULL;\r\n\r\n\tEnableStackedTabs(TRUE);\r\n\r\n\tm_pGeneralOptions = new COptionsGeneral;\r\n\tm_pKeyBoardOptions = new COptionsKeyBoard;\r\n\t//m_pQuickPasteOptions = new COptionsQuickPaste;\r\n\tm_pQuickPasteShortCuts = new CQuickPasteKeyboard;\r\n\r\n\tm_pCopyBuffers = new COptionsCopyBuffers;\r\n\tm_pStats = new COptionsStats;\r\n\tm_pTypes = new COptionsTypes;\r\n\tm_pAbout = new CAbout;\r\n\r\n\tAddPage(m_pGeneralOptions);\r\n\tAddPage(m_pTypes);\r\n\tAddPage(m_pKeyBoardOptions);\r\n\tAddPage(m_pCopyBuffers);\r\n\t//AddPage(m_pQuickPasteOptions);\r\n\tAddPage(m_pQuickPasteShortCuts);\r\n\tif(CGetSetOptions::GetAllowFriends())\r\n\t{\r\n\t\tm_pFriends = new COptionFriends;\r\n\t\tAddPage(m_pFriends);\r\n\t}\r\n\tAddPage(m_pStats);\r\n\tAddPage(m_pAbout);\r\n\r\n\t\r\n}\r\n\r\nCOptionsSheet::~COptionsSheet()\r\n{\r\n\tdelete m_pGeneralOptions;\r\n\tdelete m_pKeyBoardOptions;\r\n\t//delete m_pQuickPasteOptions;\r\n\tdelete m_pCopyBuffers;\r\n\tdelete m_pStats;\r\n\tdelete m_pTypes;\r\n\tdelete m_pAbout;\t\r\n\tdelete m_pFriends;\r\n\tdelete m_pUtilites;\r\n\tdelete m_pQuickPasteShortCuts;\t\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(COptionsSheet, CPropertySheet)\r\n\t//{{AFX_MSG_MAP(COptionsSheet)\r\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\r\n\tON_WM_DESTROY()\r\n\tON_WM_NCDESTROY()\r\n\t//ON_WM_CLOSE()\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsSheet message handlers\r\n\r\nvoid COptionsSheet::OnDestroy()\r\n{\r\n\tCPropertySheet::OnDestroy();\r\n}\r\n\r\nvoid COptionsSheet::SetNotifyWnd(HWND hWnd)\r\n{\r\n\tm_hWndParent = hWnd;\r\n}\r\n\r\nBOOL COptionsSheet::OnInitDialog() \r\n{\r\n\tm_bModeless = FALSE;   \r\n\tm_nFlags |= WF_CONTINUEMODAL;\r\n\r\n\tHICON b = (HICON)LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME), IMAGE_ICON, 64, 64, LR_SHARED);\r\n\tSetIcon(b, TRUE);\r\n\r\n\tBOOL bResult = CPropertySheet::OnInitDialog();\r\n\r\n\tSetWindowText(_T(\"Options\"));\r\n\r\n\ttheApp.m_Language.UpdateOptionsSheet(this);\r\n\r\n\t::ShowWindow(::GetDlgItem(m_hWnd, ID_APPLY_NOW), SW_HIDE);\r\n\r\n\tm_bModeless = TRUE;\r\n\tm_nFlags &= ~WF_CONTINUEMODAL;\r\n\r\n\treturn bResult;\r\n}\r\n\r\nvoid COptionsSheet::OnNcDestroy()\r\n{\r\n\tCPropertySheet::OnNcDestroy();\r\n\t::PostMessage(m_hWndParent, WM_OPTIONS_CLOSED, m_themeChanged, 0);\r\n}\r\n"
        },
        {
          "name": "OptionsSheet.h",
          "type": "blob",
          "size": 1.7431640625,
          "content": "#if !defined(AFX_OPTIONSSHEET_H__D8A13849_DBC6_4CD6_A981_E572ECDC2E94__INCLUDED_)\n#define AFX_OPTIONSSHEET_H__D8A13849_DBC6_4CD6_A981_E572ECDC2E94__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// OptionsSheet.h : header file\n//\n//#include \"ShowTaskBarIcon.h\"\n\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsSheet\n\nclass COptionsSheet : public CPropertySheet\n{\n\tDECLARE_DYNAMIC(COptionsSheet)\n\n// Construction\npublic:\n\tCOptionsSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);\n\n\tvoid SetNotifyWnd(HWND hWnd);\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n\tBOOL m_themeChanged;\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(COptionsSheet)\n\tpublic:\n\tvirtual BOOL OnInitDialog();\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~COptionsSheet();\n\n\t// Generated message map functions\nprotected:\n\n\tHWND m_hWndParent;\n\n\tCPropertyPage *m_pKeyBoardOptions;\n\tCPropertyPage *m_pGeneralOptions;\n\tCPropertyPage *m_pQuickPasteOptions;\n\tCPropertyPage *m_pUtilites;\n\tCPropertyPage *m_pStats;\n\tCPropertyPage *m_pTypes;\n\tCPropertyPage *m_pAbout;\n\tCPropertyPage *m_pFriends;\n\tCPropertyPage *m_pCopyBuffers;\n\tCPropertyPage *m_pQuickPasteShortCuts;\n\n\t//CShowTaskBarIcon m_taskBar;\n\n\n\t//{{AFX_MSG(COptionsSheet)\n\t\t// NOTE - the ClassWizard will add and remove member functions here.\n\tafx_msg void OnDestroy();\n\tafx_msg void OnNcDestroy();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_OPTIONSSHEET_H__D8A13849_DBC6_4CD6_A981_E572ECDC2E94__INCLUDED_)\n"
        },
        {
          "name": "OptionsStats.cpp",
          "type": "blob",
          "size": 4.259765625,
          "content": "// OptionsStats.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"OptionsStats.h\"\r\n#include \"ProcessPaste.h\"\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsStats dialog\r\n\r\nIMPLEMENT_DYNCREATE(COptionsStats, CPropertyPage)\r\n\r\nCOptionsStats::COptionsStats()\r\n\t: CPropertyPage(COptionsStats::IDD)\r\n{\r\n\tm_csTitle = theApp.m_Language.GetString(\"StatsTitle\", \"Stats\");\r\n\tm_psp.pszTitle = m_csTitle;\r\n\tm_psp.dwFlags |= PSP_USETITLE; \r\n\r\n\t//{{AFX_DATA_INIT(COptionsStats)\r\n\tm_eAllCopies = _T(\"\");\r\n\tm_eAllPastes = _T(\"\");\r\n\tm_eAllDate = _T(\"\");\r\n\tm_eTripCopies = _T(\"\");\r\n\tm_eTripDate = _T(\"\");\r\n\tm_eTripPastes = _T(\"\");\r\n\tm_eSavedCopies = _T(\"\");\r\n\tm_eSavedCopyData = _T(\"\");\r\n\tm_eDatabaseSize = _T(\"\");\r\n\tm_eClipsSent = _T(\"\");\r\n\tm_eClipsRecieved = _T(\"\");\r\n\tm_eLastStarted = _T(\"\");\r\n\t//}}AFX_DATA_INIT\r\n}\r\n\r\n\r\nvoid COptionsStats::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCPropertyPage::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(COptionsStats)\r\n\tDDX_Text(pDX, IDC_ALL_COPIES, m_eAllCopies);\r\n\tDDX_Text(pDX, IDC_ALL_PASTES, m_eAllPastes);\r\n\tDDX_Text(pDX, IDC_EDIT_ALL_DATE, m_eAllDate);\r\n\tDDX_Text(pDX, IDC_TRIP_COPIES, m_eTripCopies);\r\n\tDDX_Text(pDX, IDC_TRIP_DATE, m_eTripDate);\r\n\tDDX_Text(pDX, IDC_TRIP_PASTES, m_eTripPastes);\r\n\tDDX_Text(pDX, IDC_SAVED_COPIES, m_eSavedCopies);\r\n\tDDX_Text(pDX, IDC_SAVED_COPY_DATA, m_eSavedCopyData);\r\n\tDDX_Text(pDX, IDC_DATABASE_SIZE, m_eDatabaseSize);\r\n\tDDX_Text(pDX, IDC_CLIPS_SENT, m_eClipsSent);\r\n\tDDX_Text(pDX, IDC_CLIPS_RECIVED, m_eClipsRecieved);\r\n\tDDX_Text(pDX, IDC_LAST_STARTED, m_eLastStarted);\r\n\t//}}AFX_DATA_MAP\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(COptionsStats, CPropertyPage)\r\n\t//{{AFX_MSG_MAP(COptionsStats)\r\n\tON_BN_CLICKED(IDC_RESET_COUNTS, OnResetCounts)\r\n\tON_BN_CLICKED(IDC_REMOVE_ALL, OnRemoveAll)\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsStats message handlers\r\n\r\n\r\nBOOL COptionsStats::OnInitDialog() \r\n{\r\n\tCPropertyPage::OnInitDialog();\r\n\r\n\tCOleDateTime time((time_t) CGetSetOptions::GetTotalDate());\r\n\tm_eAllDate = time.Format();\r\n\r\n\tm_eAllCopies.Format(_T(\"%d\"), CGetSetOptions::GetTotalCopyCount());\r\n\tm_eAllPastes.Format(_T(\"%d\"), CGetSetOptions::GetTotalPasteCount());\r\n\r\n\tCOleDateTime time2((time_t)CGetSetOptions::GetTripDate());\r\n\tm_eTripDate = time2.Format();\r\n\tm_eTripCopies.Format(_T(\"%d\"), CGetSetOptions::GetTripCopyCount());\r\n\tm_eTripPastes.Format(_T(\"%d\"), CGetSetOptions::GetTripPasteCount());\r\n\r\n\tm_eClipsSent.Format(_T(\"%d\"), theApp.m_lClipsSent);\r\n\tm_eClipsRecieved.Format(_T(\"%d\"), theApp.m_lClipsRecieved);\r\n\tm_eLastStarted = theApp.m_oldtStartUp.Format();\t\r\n\r\n\tCOleDateTimeSpan span = COleDateTime::GetCurrentTime() - theApp.m_oldtStartUp;\r\n\tCString csSpan;\r\n\tcsSpan.Format(_T(\"  -  %d.%d.%d (D.H.M)\"), (long)span.GetTotalDays(), span.GetHours(), span.GetMinutes());\r\n\tm_eLastStarted += csSpan;\r\n\r\n\ttry\r\n\t{\r\n\t\tm_eSavedCopies.Format(_T(\"%d\"), theApp.m_db.execScalar(_T(\"SELECT COUNT(lID) FROM Main\")));\r\n\t\tm_eSavedCopyData.Format(_T(\"%d\"), theApp.m_db.execScalar(_T(\"SELECT COUNT(lID) FROM Data\")));\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\r\n\t__int64 size = FileSize(GetDBName());\t\t\t\r\n\r\n\tconst int MAX_FILE_SIZE_BUFFER = 255;\r\n\tTCHAR szFileSize[MAX_FILE_SIZE_BUFFER];\r\n\tStrFormatByteSize(size, szFileSize, MAX_FILE_SIZE_BUFFER);\r\n\r\n\tm_eDatabaseSize = szFileSize;\r\n\r\n\tUpdateData(FALSE);\r\n\r\n\ttheApp.m_Language.UpdateOptionStats(this);\r\n\t\t\r\n\treturn TRUE;\r\n}\r\n\r\nvoid COptionsStats::OnResetCounts() \r\n{\r\n\tCGetSetOptions::SetTripCopyCount(0);\r\n\tCGetSetOptions::SetTripPasteCount(0);\r\n\tCGetSetOptions::SetTripDate(0);\r\n\r\n\tm_eTripDate.Empty();\r\n\tm_eTripCopies.Empty();\r\n\tm_eTripPastes.Empty();\r\n\r\n\tUpdateData(FALSE);\r\n}\r\n\r\nvoid COptionsStats::OnRemoveAll() \r\n{\r\n\tif(MessageBox(theApp.m_Language.GetString(\"Remove_All\", \"This will remove all Copy Entries!\\n\\nContinue?\"), _T(\"Warning\"), MB_YESNO) == IDYES)\r\n\t{\r\n\t\tif( DeleteAllIDs() )\r\n\t\t{\r\n\t\t\tm_eSavedCopies.Empty();\r\n\t\t\tm_eSavedCopyData.Empty();\r\n\r\n\t\t\tstruct _stat buf;\r\n\t\t\tint nResult;\r\n\t\t\tnResult = STAT(GetDBName(), &buf);\r\n\t\t\tif(nResult == 0)\r\n\t\t\t\tm_eDatabaseSize.Format(_T(\"%d KB\"), (buf.st_size/1024));\r\n\r\n\t\t\tUpdateData(FALSE);\r\n\t\t}\r\n\t}\r\n}\r\n"
        },
        {
          "name": "OptionsStats.h",
          "type": "blob",
          "size": 1.5126953125,
          "content": "#if !defined(AFX_OPTIONSSTATS_H__5F6FFD2C_E563_4166_8294_A0CBBD17403B__INCLUDED_)\n#define AFX_OPTIONSSTATS_H__5F6FFD2C_E563_4166_8294_A0CBBD17403B__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// OptionsStats.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsStats dialog\n\nclass COptionsStats : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(COptionsStats)\n\n// Construction\npublic:\n\tCOptionsStats();   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(COptionsStats)\n\tenum { IDD = IDD_OPTIONS_STATS };\n\tCString\tm_eAllCopies;\n\tCString\tm_eAllPastes;\n\tCString\tm_eAllDate;\n\tCString\tm_eTripCopies;\n\tCString\tm_eTripDate;\n\tCString\tm_eTripPastes;\n\tCString\tm_eSavedCopies;\n\tCString\tm_eSavedCopyData;\n\tCString\tm_eDatabaseSize;\n\tCString\tm_eClipsSent;\n\tCString\tm_eClipsRecieved;\n\tCString\tm_eLastStarted;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(COptionsStats)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\tCString m_csTitle;\n\n\t// Generated message map functions\n\t//{{AFX_MSG(COptionsStats)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnResetCounts();\n\tafx_msg void OnRemoveAll();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_OPTIONSSTATS_H__5F6FFD2C_E563_4166_8294_A0CBBD17403B__INCLUDED_)\n"
        },
        {
          "name": "OptionsTypes.cpp",
          "type": "blob",
          "size": 3.4501953125,
          "content": "// OptionsTypes.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"OptionsTypes.h\"\r\n#include \"Shared/ArrayEx.h\"\r\n#include \"DimWnd.h\"\r\n#include \"Misc.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsTypes property page\r\n\r\nIMPLEMENT_DYNCREATE(COptionsTypes, CPropertyPage)\r\n\r\nCOptionsTypes::COptionsTypes() : CPropertyPage(COptionsTypes::IDD)\r\n{\r\n\tm_csTitle = theApp.m_Language.GetString(\"SupportedTypesTitle\", \"Supported Types\");\r\n\tm_psp.pszTitle = m_csTitle;\r\n\tm_psp.dwFlags |= PSP_USETITLE; \r\n\r\n\t//{{AFX_DATA_INIT(COptionsTypes)\r\n\t//}}AFX_DATA_INIT\r\n\r\n\tm_bSave = false;\r\n}\r\n\r\nCOptionsTypes::~COptionsTypes()\r\n{\r\n}\r\n\r\nvoid COptionsTypes::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCPropertyPage::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(COptionsTypes)\r\n\tDDX_Control(pDX, IDC_LIST1, m_List);\r\n\t//}}AFX_DATA_MAP\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(COptionsTypes, CPropertyPage)\r\n\t//{{AFX_MSG_MAP(COptionsTypes)\r\n\tON_BN_CLICKED(IDC_DELETE, OnDelete)\r\n\tON_BN_CLICKED(IDC_ADD, OnAdd)\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// COptionsTypes message handlers\r\n\r\nBOOL COptionsTypes::OnApply() \r\n{\r\n\tif(m_bSave)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDML(_T(\"DELETE FROM Types;\"));\r\n\r\n\t\t\tCString csText;\r\n\t\t\tint nCount = m_List.GetCount();\r\n\t\t\tfor(int i = 0; i < nCount; i++)\r\n\t\t\t{\r\n\t\t\t\tm_List.GetText(i, csText);\r\n\r\n\t\t\t\ttheApp.m_db.execDMLEx(_T(\"INSERT INTO Types VALUES(NULL, '%s');\"), csText);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\t// refresh our local cache\r\n\t\ttheApp.ReloadTypes();\r\n\t}\r\n\t\r\n\treturn CPropertyPage::OnApply();\r\n}\r\n\r\nBOOL COptionsTypes::OnInitDialog() \r\n{\r\n\tCPropertyPage::OnInitDialog();\r\n\r\n\ttry\r\n\t{\r\n\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT TypeText FROM Types\"));\r\n\t\tif(q.eof())\r\n\t\t{\r\n\t\t\tm_List.AddString(_T(\"CF_TEXT\"));\r\n\t\t\tm_List.AddString(GetFormatName(RegisterClipboardFormat(CF_RTF)));\r\n\t\t\tm_List.AddString(_T(\"CF_UNICODETEXT\"));\r\n\t\t\tm_List.AddString(_T(\"CF_HDROP\"));\r\n\t\t\tm_List.AddString(_T(\"CF_DIB\"));\r\n\t\t\tm_List.AddString(GetFormatName(GetFormatID(_T(\"HTML Format\"))));\r\n\t\t\tm_List.AddString(GetFormatName(GetFormatID(_T(\"PNG\"))));\r\n\t\t}\r\n\r\n\t\twhile(q.eof() == false)\r\n\t\t{\r\n\t\t\tm_List.AddString(q.getStringField(0));\r\n\r\n\t\t\tq.nextRow();\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\t\r\n\tm_List.SetFocus();\r\n\r\n\ttheApp.m_Language.UpdateOptionSupportedTypes(this);\r\n\t\r\n\treturn FALSE;\r\n}\r\n\r\nvoid COptionsTypes::OnDelete() \r\n{\r\n\tint nCount = m_List.GetSelCount();\r\n\tif(nCount)\r\n\t{\r\n\t\tm_bSave = true;\r\n\t\tCArrayEx<int> items;\r\n\t\titems.SetSize(nCount);\r\n\t\tm_List.GetSelItems(nCount, items.GetData()); \r\n\t\titems.SortDescending();\r\n\r\n\t\tfor(int i = 0; i < nCount; i++)\r\n\t\t\tm_List.DeleteString(items[i]);\r\n\t}\r\n}\r\n\r\n#include \"AddType.h\"\r\nvoid COptionsTypes::OnAdd() \r\n{\r\n\tCDimWnd dim(this->GetParent());\r\n\tCAddType add(this);\r\n\r\n\tif(add.DoModal() == IDOK)\r\n\t{\r\n\t\tINT_PTR nCount = add.m_csSelectedTypes.GetSize();\r\n\t\tif(nCount)\r\n\t\t{\r\n\t\t\tm_bSave = true;\r\n\t\t\tfor(int i = 0; i < nCount; i++)\r\n\t\t\t{\r\n\t\t\t\tif(TextAllReadyThere(add.m_csSelectedTypes[i]) == FALSE)\r\n\t\t\t\t\tm_List.AddString(add.m_csSelectedTypes[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n}\r\n\r\nBOOL COptionsTypes::TextAllReadyThere(const CString &cs)\r\n{\r\n\tCString csThere;\r\n\tint nCount = m_List.GetCount();\r\n\r\n\tfor(int i = 0; i < nCount; i++)\r\n\t{\r\n\t\tm_List.GetText(i, csThere);\r\n\t\tif(cs == csThere)\r\n\t\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n"
        },
        {
          "name": "OptionsTypes.h",
          "type": "blob",
          "size": 1.3203125,
          "content": "#if !defined(AFX_OPTIONSTYPES_H__3E35B866_595F_41CA_8654_E4F8E39B1D81__INCLUDED_)\n#define AFX_OPTIONSTYPES_H__3E35B866_595F_41CA_8654_E4F8E39B1D81__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// OptionsTypes.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsTypes dialog\n\nclass COptionsTypes : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(COptionsTypes)\n\n// Construction\npublic:\n\tCOptionsTypes();\n\t~COptionsTypes();\n\n// Dialog Data\n\t//{{AFX_DATA(COptionsTypes)\n\tenum { IDD = IDD_OPTIONS_TYPES };\n\tCListBox\tm_List;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generate virtual function overrides\n\t//{{AFX_VIRTUAL(COptionsTypes)\n\tpublic:\n\tvirtual BOOL OnApply();\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\tbool m_bSave;\n\tCString m_csTitle;\n\tBOOL TextAllReadyThere(const CString &cs);\n\n\n\t// Generated message map functions\n\t//{{AFX_MSG(COptionsTypes)\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnDelete();\n\tafx_msg void OnAdd();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_OPTIONSTYPES_H__3E35B866_595F_41CA_8654_E4F8E39B1D81__INCLUDED_)\n"
        },
        {
          "name": "OptionsUtilities.cpp",
          "type": "blob",
          "size": 2.3564453125,
          "content": "// OptionsUtilities.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"OptionsUtilities.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsUtilities property page\n\nIMPLEMENT_DYNCREATE(COptionsUtilities, CPropertyPage)\n\nCOptionsUtilities::COptionsUtilities() : CPropertyPage(COptionsUtilities::IDD)\n{\n\t//{{AFX_DATA_INIT(COptionsUtilities)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n}\n\nCOptionsUtilities::~COptionsUtilities()\n{\n}\n\nvoid COptionsUtilities::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(COptionsUtilities)\n\tDDX_Control(pDX, IDC_PATH, m_ePath);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(COptionsUtilities, CPropertyPage)\n\t//{{AFX_MSG_MAP(COptionsUtilities)\n\tON_BN_CLICKED(IDC_COMPACT_DB, OnCompactDB)\n\tON_BN_CLICKED(IDC_REPAIR, OnRepair)\n\tON_BN_CLICKED(IDC_GET_PATH, OnGetPath)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsUtilities message handlers\n\nvoid COptionsUtilities::OnCompactDB() \n{\n\tCompactDatabase();\n}\n\nBOOL COptionsUtilities::OnApply() \n{\n\tCString csPath;\n\tm_ePath.GetWindowText(csPath);\n\n\tCString csOldPath = CGetSetOptions::GetDBPath(FALSE);\n\n\tif(csOldPath != csPath)\n\t{\n\t\tCGetSetOptions::SetDBPath(csPath);\n\t}\n\t\t\n\treturn CPropertyPage::OnApply();\n}\n\nBOOL COptionsUtilities::OnInitDialog() \n{\n\tCPropertyPage::OnInitDialog();\n\t\n\tm_ePath.SetWindowText(CGetSetOptions::GetDBPath(FALSE));\n\t\t\n\treturn TRUE;\n}\n\nvoid COptionsUtilities::OnRepair() \n{\n\tRepairDatabase();\n}\n\nvoid COptionsUtilities::OnGetPath() \n{\n\tOPENFILENAME\tFileName;\n\n\tTCHAR\tszFileName[400];\n\tTCHAR\tszDir[400];\n\n\tmemset(&FileName, 0, sizeof(FileName));\n\tmemset(szFileName, 0, sizeof(szFileName));\n\tmemset(&szDir, 0, sizeof(szDir));\n\n\tFileName.lStructSize = sizeof(FileName);\n\n\t\n\tFileName.lpstrTitle = _T(\"Open Database\");\n\tFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;\n\tFileName.nMaxFile = 400;\n\tFileName.lpstrFile = szFileName;\n\tFileName.lpstrInitialDir = szDir;\n\tFileName.lpstrFilter = _T(\"Database Files (.MDB)\\0*.mdb\");\n\tFileName.lpstrDefExt = _T(\"mdb\");\n\n\tif(GetOpenFileName(&FileName) == 0)\n\t\treturn;\n\n\tCString\tcsPath(FileName.lpstrFile);\n\t\n\tm_ePath.SetWindowText(csPath);\t\t\n}\n"
        },
        {
          "name": "OptionsUtilities.h",
          "type": "blob",
          "size": 1.322265625,
          "content": "#if !defined(AFX_OPTIONSUTILITIES_H__094B311D_3C47_43A8_A254_A009E3F0A75D__INCLUDED_)\n#define AFX_OPTIONSUTILITIES_H__094B311D_3C47_43A8_A254_A009E3F0A75D__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// OptionsUtilities.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// COptionsUtilities dialog\n\nclass COptionsUtilities : public CPropertyPage\n{\n\tDECLARE_DYNCREATE(COptionsUtilities)\n\n// Construction\npublic:\n\tCOptionsUtilities();\n\t~COptionsUtilities();\n\n// Dialog Data\n\t//{{AFX_DATA(COptionsUtilities)\n\tenum { IDD = IDD_OPTIONS_UTILITIES };\n\tCEdit\tm_ePath;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generate virtual function overrides\n\t//{{AFX_VIRTUAL(COptionsUtilities)\n\tpublic:\n\tvirtual BOOL OnApply();\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\t// Generated message map functions\n\t//{{AFX_MSG(COptionsUtilities)\n\tafx_msg void OnCompactDB();\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnRepair();\n\tafx_msg void OnGetPath();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_OPTIONSUTILITIES_H__094B311D_3C47_43A8_A254_A009E3F0A75D__INCLUDED_)\n"
        },
        {
          "name": "Path.cpp",
          "type": "blob",
          "size": 60.5859375,
          "content": "// ==================================================================\n// \n//  Path.cpp   \n//  \n//  Created:       20.06.2004\n//\n//  Copyright (C) Peter Hauptmann\n//              \n// ------------------------------------------------------------------\n/// \n/// for copyright & disclaimer see accompanying Path.h\n/// \n/// \\page pgChangeLog Change Log\n/// \n/// June 20, 2004:  Initial release\n/// \n/// June 22, 2004   \n///     - \\c fixed: nsPath::CPath::MakeSystemFolder implements unmake correctly \n///     - \\c added: nsPath::CPath::MakeSystemFolder and nsPath::CPath::SearchOnPath \n///       set the windows error code to zero if the function succeeds (thanks Hans Dietrich)\n///     - \\c fixed: nsPath::CPath compiles correctly with warning level -W4\n/// \n/// Mar 3, 2005\n///     - fixed eppAutoQuote bug in GetStr (thanks Stlan)\n///     - Added: \n///         - \\ref nsPath::FromRegistry \"FromRegistry\"\n///         - \\ref nsPath::CPath::ToRegistry \"ToRegistry\"\n///         - \\ref nsPath::CPath::GetRootType, \"GetRootType\"\n///         - \\ref nsPath::CPath::GetRoot \"GetRoot\" has a new implementation\n///         - \\ref nsPath::CPath::MakeAbsolute \"MakeAbsolute\"\n///         - \\ref nsPath::CPath::MakeRelative \"MakeRelative\"\n///         - \\ref nsPath::CPath::MakeFullPath \"MakeFullPath\"\n///         - \\ref nsPath::CPath::EnvUnexpandRoot \"EnvUnexpandRoot\"\n///         - \\ref nsPath::CPath::EnvUnexpandDefaultRoots \"EnvUnexpandDefaultRoots\"\n///     - \\b Breaking \\b Changes (sorry)\n///         - GetRoot -> ShellGetRoot (to distinct from extended GetRoot implementation)\n///         - GetFileName --> GetName (consistency)\n///         - GetFileTitle --> GetTitle (consistency)\n///         - made the creation functions independent functions in the nsPath namespace\n///           (they are well tugged away in the namespace so conflicts are easy to avoid) \n/// \n/// Mar 17, 2005\n///     - fixed bug in GetFileName (now: GetName): If the path ends in a backslash,\n///       GetFileName did return the entire path instead of an empty string. (thanks woodland)\n/// \n/// Aug 21, 2005\n///     - fixed bug in GetStr(): re-quoting wasn't applied (doh!)\n///     - fixed incompatibility with CStlString\n///     - Added IsDot, IsDotDot, IsDotty (better names?)\n///     - Added IsValid, ReplaceInvalid\n///     - Added SplitRoot\n///     - \n///        \n/// \n///\n// ------ Main Page --------------------\n/// @mainpage\n/// \n/// \\ref pgDisclaimer, \\ref pgChangeLog (recent changes August 2005, \\b breaking \\b changes Mar 2005)\n///\n///\t\\par Introduction\n///\n/// \\ref nsPath::CPath \"CPath\" is a helper class to make manipulating file system path strings easier. \n/// It is complementedby a few non-class functions (see nsPath namespace documentation)\n/// \n/// CPath is based on the Shell Lightweight Utility API, but modifies / and extends this functionality\n/// (and removes some quirks). It requires CString (see below why, and why this is not too bad).\n/// \n/// \\par Main Features:\n/// \n/// CPath acts as a string class with special \"understanding\" and operations for path strings.\n/// \n/// \\code CPath path(\"c:\\\\temp\"); \\endcode\n/// constructs a path string, and does some default cleanup (trimming white space, removing quotes, etc.)\n/// The cleanup can be customized (see \\ref nsPath::CPath::CPath \"CPath Constructor\", \n///  \\ref nsPath::EPathCleanup \"EPathCleanup\"). You can pass an ANSI or UNICODE string.\n/// \n/// \\code path = path & \"file.txt\"; \\endcode\n/// Appends \"foo\" to the path, making sure that the two segments are separated by exactly one backslash\n/// no matter if the parts end/begin with a backslash.\n/// \n/// The following functions give you access to the individual elements of the path:\n/// \n///  - \\ref nsPath::CPath::GetRoot \"GetRoot\"\n///  - \\ref nsPath::CPath::GetPath \"GetPath\"\n///  - \\ref nsPath::CPath::GetName \"GetName\"\n///  - \\ref nsPath::CPath::GetTitle \"GetTitle\"\n///  - \\ref nsPath::CPath::GetExtension \"GetExtension\"\n/// \n/// \\code CString s = path.GetStr() \\endcode\n/// returns a CString that is cleaned up again (re-quoted if necessary, etc). GetBStr() returns an _bstr_t\n/// with the same features (that automatically casts to either ANSI or UNICODE).\n/// To retrieve the unmodified CPath string, you can rely on the \\c operator \\c LPCTSTR \n/// \n/// There's much more - see the full nsPath documentation for details!\n/// \n///\t@sa MSDN library: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/shlwapi/path/pathappend.asp\n/// \n/// \\par Why not CPathT ?\n///  -# the class is intended for a VC6 project that won't move to VC7 to soon\n///  -# CPathT contains the same quirks that made me almost give up on the Shell Helper functions. \n///  -# I wanted the class to have additional features (such as the & operator, and automatic cleanup)\n/// \n/// \\par Why CString ?\n///  -# The CString implementation provides a known performance (due to the guaranteed reference counted \"copy \n///     on write\" implementation). I consider this preferrable over the weaker guarantees made b STL, especially\n///     when designing a  \"convenient\" class interface.\n///  -# CString's ref counting mechanism is automatically reused by CPath, constructing a CPath from a CString\n///     does not involve a copy operation.\n///  -# CString is widely availble independent of MFC (WTL, custom implementations, \"extract\" macros are\n///     available, and VC7 makes CString part of the ATL)\n/// \n/// \\note if you want to port to STL, it's probably easier to use a vector<TCHAR> instead of std:string \n///   to hold the data internally\n/// \n/// \\par Why _bstr_t ?\n/// To make implementation easier, the class internally works with \"application native\" strings (that is, \n/// TCHAR strings - which are either ANSI or UNICODE depending on a compile setting). GetBStr provides\n/// conversion to ANSI or UNICODE, whichever is required.\\n\n/// An independent implementation would return a temporary object with cast operators to LPCSTR and LPWSTR \n/// - BUT _bstr_t does exactly that (admittedly, with some overhead). \n/// \n\n\n#include \"stdafx.h\"\n#include \"Path.h\"\n\n#include <shlwapi.h>    // Link to Shell Helper API\n#pragma comment(lib, \"shlwapi.lib\")\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n\nnamespace nsPath\n{\n\n/// contains helper classes for nsPath namespace\n/// \nnamespace nsDetail\n{\n// ==================================================================\n//  CStringLock\n// ------------------------------------------------------------------\n// \n// Helper class for CString::GetBuffer and CString::ReleaseBuffer\n// \\todo: consider moving to common utility \n// \\todo: additional debug verification on release\n//\nclass CStringLock\n{\npublic:\n    CString * m_string;\n    LPTSTR    m_buffer;\n\n    static LPTSTR NullBuffer;\n\npublic:\n    CStringLock(CString & s) : m_string(&s)\n    {\n        m_buffer = m_string->GetBuffer(0);\n        // fixes an incompatibility with CStdString, see \"NullBuffer\" in .cpp \n        if (!s.GetLength())\n            m_buffer = NullBuffer; \n    }\n\n    CStringLock(CString & s, int minChars) : m_string(&s)\n    {\n        m_buffer = m_string->GetBuffer(minChars);\n\n        // fixes an incompatibility with CStdString, see \"NullBuffer\" in .cpp \n        if (!s.GetLength() && !minChars)\n            m_buffer = NullBuffer; \n\n    }\n\n    operator LPTSTR() { return m_buffer; }\n\n    void Release(int newLen = -1)\n    {\n        if (m_string)\n        {\n            m_string->ReleaseBuffer(newLen);\n            m_string = NULL;\n            m_buffer = NULL;\n        }\n    }\n\n    ~CStringLock()  { Release(); }\n\n};\n\n\n\n/// CStdString incompatibility:\n/// http://www.codeproject.com/string/stdstring.asp\n/// If the contained string is empty, CStdString.GetBuffer returns a pointer to a constant\n/// empty string, which may cause an access violation when I write the terminating zero\n/// (which is in my understanding implicitely allowed the way I read the MSDN docs)\n/// Solution: we return a pointer to another buffer\nTCHAR NullBufferData[1] = { 0 };\nLPTSTR CStringLock::NullBuffer = NullBufferData;\n\n\n// Helper class for Close-On-Return HKEY\n// \\todo migrate template class \nclass CAutoHKEY\n{\nprivate:\n    CAutoHKEY const & operator =(CAutoHKEY const & ); // not implemented\n    CAutoHKEY(CAutoHKEY const &);   // not implemented\n\nprotected:\n    HKEY    key;\n\npublic:\n    CAutoHKEY() : key(0) {}\n    CAutoHKEY(HKEY key_) : key(key_) {}\n   ~CAutoHKEY()          { Close(); }\n\n    void Close()\n    {\n        if (key) \n        {\n            RegCloseKey(key); \n            key = 0;\n        }\n    }\n\n   HKEY * OutArg()\n   {\n       Close();\n       return &key;\n   }\n\n   operator HKEY() const { return key; }\n\n}; // CAutoHKEY\n\n/// Reads an environment variable into a CString\nCString GetEnvVar(LPCTSTR envVar)\n{\n    SetLastError(0);\n\n    // get length of buffer\n    DWORD result = GetEnvironmentVariable(envVar, _T(\"\"), 0);\n    if (!result)\n        return CString();\n\n    CString s;\n    result = GetEnvironmentVariable(envVar, CStringLock(s, result), result);\n    return s;\n}\n\n\n/// Replace path root with environment variable\n/// If the beginning of \\c s matches the value of the environment variable %envVar%,\n/// it is replaced with the %envVar% value\n/// (e.g. \"C:\\Windows\" with \"%windir%\"\n/// \\param s [CString &, in/out]: the string to modify\n/// \\param envVar [LPCTSTR]: name of the environment variable\n/// \\returns true if s was modified, false otherwise.\nbool EnvUnsubstRoot(CString & s, LPCTSTR envVar)\n{\n    // get environment value string\n    CString envValue = GetEnvVar(envVar);\n    if (!envValue.GetLength())\n        return false;\n\n    if (s.GetLength() >= envValue.GetLength() && \n        _tcsnicmp(s, envValue, envValue.GetLength())==0)\n    {\n        CString modified = CString('%');\n        modified += envVar;\n        modified += '%';\n        modified += s.Mid(envValue.GetLength());\n        s = modified;\n        return true;\n    }\n    return false;\n}\n    \n} // namespace nsPath::nsDetail\n\n\nusing namespace nsDetail;\n\nconst TCHAR Backslash = '\\\\';\n\n\n// ==============================================\n//  Trim\n// ----------------------------------------------\n/// Trims whitespaces from left and right side. \n/// \\param s [CString]: String to modify in-place.\nvoid Trim(CString & string)\n{\n    if (_istspace(GetFirstChar(string)))\n        string.TrimLeft();\n\n    if (_istspace(GetLastChar(string)))\n        string.TrimRight();\n}\n\n\n\n// ==================================================================\n//  GetDriveLetter(ch)\n// ------------------------------------------------------------------\n/// checks if the specified letter \\c ch is a drive letter, and casts it to uppercase\n/// \n/// \\returns [TCHAR]: if \\c is a valid drive letter (A..Z, or a..z), returns the drive letter\n///     cast to uppercase (A..Z). >Otherwise, returns 0\nTCHAR GetDriveLetter(TCHAR ch)\n{\n    if ( (ch >= 'A' && ch <= 'Z'))\n        return ch;\n\n    if (ch >= 'a' && ch <= 'z')\n            return (TCHAR) (ch - 'a' + 'A');\n\n    return 0;\n}\n\n\n// ==================================================================\n//  GetDriveLetter(string)\n// ------------------------------------------------------------------\n/// returnd the drive letter of a path.\n/// The drive letter returned is always uppercase ('A'.`'Z'). \n/// \\param s [LPCTSTR]: the path string\n/// \\returns [TCHAR]: the drive letter, converted to uppercase, if the path starts with an \n///                     X: drive specification. Otherwise, returns 0\n// \nTCHAR GetDriveLetter(LPCTSTR s)\n{\n    if (s == NULL || *s == 0 || s[1] != ':')\n        return 0;\n\n    return GetDriveLetter(s[0]);\n}\n\n\n\n// ==================================================================\n//  QuoteSpaces\n// ------------------------------------------------------------------\n///\n/// Quotes the string if it is not already quoted, and contains spaces\n/// see also MSDN: \\c PathQuoteSpaces\n/// \\note If the string is already quoted, an additional pair of quotes is added.\n/// \\param str [CString const &]: path string to add quotes to\n/// \\returns [CString]: path string with quotes added if required\n// \nCString QuoteSpaces(CString const & str)\n{\n    // preserve refcounting if no changes will be made\n    if (str.Find(' ')>=0)  // if the string contains any spaces...\n    {\n        CString copy(str);\n        CStringLock buffer(copy, copy.GetLength() + 2);\n        PathQuoteSpaces(buffer);\n        buffer.Release();\n        return copy;\n    }\n\n    return str; // unmodified\n}\n\n\n\n/// helper function for GetRootType\ninline ERootType GRT_Return(ERootType type, int len, int * pLen)\n{\n   if (pLen)\n      *pLen = len;\n   return type;\n}\n\n// ==================================================================\n//  GetRootType\n// ------------------------------------------------------------------\n/// \n/// returns the type of the path root, and it's length.\n/// For supported root types, see \\ref nsPath::ERootType \"ERootType\" enumeration\n/// \n/// \\param path [LPCTSTR]: The path to analyze\n/// \\param pLen [int *, out]: if not NULL, receives the length of the root part (in characters)\n/// \\param greedy [bool=true]: Affects len and type of the following root types:\n///     - \\c \"\\\\server\\share\" : with greedy=true, it is treated as one \\c rtServerShare root,\n///       otherwise, it is treated as \\c rtServer root\n///     \n/// \\returns [ERootType]: type of the root element \n///         \n/// \nERootType GetRootType(LPCTSTR path, int * pLen, bool greedy)\n{\n//   ERootType   type = rtNoRoot;\n//   int len = 0;\n\n   const TCHAR * invalidChars = _T(\"\\\\/:*/\\\"<>|\");\n   const TCHAR bk = '\\\\';\n\n   if (!path || !*path)\n      return GRT_Return(rtNoRoot, 0, pLen);\n\n   // drive spec\n   if (_istalpha(*path) && path[1] == ':')\n   {\n      if (path[2] == bk) { return GRT_Return(rtDriveRoot, 3, pLen); }\n      else               { return GRT_Return(rtDriveCur, 2, pLen); }\n   }\n\n   // anything starting with two backslashes\n   if (path[0] == bk && path[1] == bk)\n   {\n      // UNC long path?\n      if (path[2] == '?' && path[3] == bk)\n      {\n         int extraLen = 0;\n         GetRootType(path+4, &extraLen) ;\n         return GRT_Return(rtLongPath, 4 + extraLen, pLen);\n      }\n\n      // position of next backslash or colon\n      int len = 2 + (int)_tcscspn(path+2, invalidChars);\n      TCHAR const * end = path+len;\n\n      // server only, no backslash\n      if (*end == 0) \n         return GRT_Return(rtServerOnly, len, pLen);\n\n      // server only, terminated with backslash\n      if (*end == bk && end[1] == 0) \n         return GRT_Return(rtServerOnly, len+1, pLen); \n\n      // server, backslash, and more...\n      if (*end == bk)\n      {\n          if (!greedy)  // return server only\n              return GRT_Return(rtServer, len, pLen);\n\n         len += 1 + (int)_tcscspn(end+1, invalidChars);\n         end = path + len;\n\n         // server, share, no backslash\n         if (*end == 0) \n            return GRT_Return(rtServerShare, len, pLen); \n\n         // server, share, backslash\n         if (*end == '\\\\') \n            return GRT_Return(rtServerShare, len+1, pLen);\n      }\n      // fall through to other tests\n   }\n\n   int len = (int)_tcscspn(path, invalidChars);\n   TCHAR const * end = path + len;\n\n   // (pseudo) protocol:\n   if (len > 0 && *end == ':')\n   {\n      if (end[1] == '/' && end[2] == '/') \n         return GRT_Return(rtProtocol, len+3, pLen);\n      else \n         return GRT_Return(rtPseudoProtocol, len+1, pLen); \n   }\n\n   return GRT_Return(rtNoRoot, 0, pLen);\n}\n\n\n\n\n\n// ==================================================================\n//  CPath::Trim\n// ------------------------------------------------------------------\n/// \n/// removes leading and trailing spaces.\n// \nCPath &  CPath::Trim()\n{\n    nsPath::Trim(m_path);\n    return *this;\n}\n\n// ==================================================================\n//  CPath::Unquote\n// ------------------------------------------------------------------\n/// \n/// removes (double) quotes from around the string\n// \nCPath & CPath::Unquote()\n{\n    if (GetFirstChar(m_path) == '\"' && GetLastChar(m_path) == '\"')\n        m_path = m_path.Mid(1, m_path.GetLength()-2);\n    return *this;\n}\n\n// ==================================================================\n//  CPath::Canonicalize\n// ------------------------------------------------------------------\n///\n/// Collapses \"\\\\..\\\\\" and \"\\\\.\\\\\" path parts.\n/// see also MSDN: PathCanonicalize\n/// \\note\n/// PathCanonicalize works strange on relative paths like \"..\\\\..\\\\x\" -\n/// it is changed to \"\\x\", which is clearly not correct. SearchAndQualify is affected\n/// by the same problem\n/// \\todo handle this separately?\n/// \n/// \\par Implementation Differences\n/// \\c PathCanonicalize does turn an empty path into a single backspace.\n/// CPath::Canonicalize does not modify an empty path.\n// \nCPath & CPath::Canonicalize()\n{\n    if (!m_path.GetLength())  // PathCanonicalize turns an empty path into \"\\\\\" - I don't want this..\n        return *this;\n\n    if (m_path.Find(_T(\"\\\\.\"))>=0)\n    {\n        CString target = m_path;  // PathCanonicalize requires a copy to work with\n        CStringLock buffer(target, m_path.GetLength()+2); // might add a backslash sometimes !\n        PathCanonicalize(buffer, m_path);\n        buffer.Release();\n        m_path = target;\n    }\n\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::ShrinkXXLPath\n// ------------------------------------------------------------------\n///\n/// Removes an \"Extra long file name\" specification\n/// Unicode API allows pathes longer than MAX_PATH, if they start with \"\\\\\\\\?\\\\\". This function\n/// removes such a specification if present. See also MSDN: \"File Name Conventions\".\n// \nCPath & CPath::ShrinkXXLPath()\n{\n    if (m_path.GetLength() >= 6 &&   // at least 6 chars for [\\\\?\\C:]\n        _tcsncmp(m_path, _T(\"\\\\\\\\?\\\\\"), 4) == 0)\n    {\n        LPCTSTR path = m_path;\n\n        if (nsPath::GetDriveLetter(path[4]) != 0 && path[5] == ':')\n            m_path = m_path.Mid(4);\n\n        else if (m_path.GetLength() >= 8)  // at least 8 chars for [\\\\?\\UNC\\]\n        {\n            if (_tcsnicmp(path + 4, _T(\"UNC\\\\\"), 4) == 0)\n            {\n                // remove chars [2]..[7]\n                int len = m_path.GetLength() - 8; // \n                CStringLock buffer(m_path);\n                memmove(buffer+2, buffer+8, len * sizeof(TCHAR));\n                buffer.Release(len+2);\n            }\n\n        }\n    }\n\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::Assign\n// ------------------------------------------------------------------\n/// \n/// Assigns a string to the path object, optionally applying cleanup of the path name\n///\n/// \\param str [CString const &]: The string to assign to the path\n/// \\param cleanup [DWORD, default = epc_Default]: operations to apply to the path\n/// \\returns [CPath &]: reference to the path object itself\n/// \n/// see CPath::Clean for a description of the cleanup options\n// \nCPath & CPath::Assign(CString const & str, DWORD cleanup)\n{\n    m_path = str;\n    Clean(cleanup);\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::MakePretty\n// ------------------------------------------------------------------\n///\n/// Turns an all-uppercase path to all -lowercase. A path containing any lowercase \n/// character is not modified.\n/// (This is Microsoft#s idea of prettyfying a path. I don't know what to say)\n/// \nCPath & CPath::MakePretty()\n{\n    CStringLock buffer(m_path);\n    PathMakePretty(buffer);\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::Clean\n// ------------------------------------------------------------------\n///\n/// Applies multiple \"path cleanup\" operations\n/// \n/// \\param cleanup [DWORD]: a combination of zero or more nsPath::EPathCleanup flags (see below)\n/// \\returns [CPath &]: a reference to the path object\n/// \n/// The following cleanup operations are defined:\n///     - \\c epcRemoveArgs: call PathRemoveArgs to remove arguments\n///     - \\c epcRemoveIconLocation: call to PathParseIconLocation to remove icon location\n///     - \\c \\b epcTrim: trim leading and trailing whitespaces\n///     - \\c \\b epcUnquote: remove quotes \n///     - \\c \\b epcTrimInQuote: trim whitespaces again after unqouting.\n///     - \\c \\b epcCanonicalize: collapse \"\\\\.\\\\\" and \"\\\\..\\\\\" segments\n///     - \\c \\b epcRemoveXXL: remove an \"\\\\\\\\?\\\\\" prefix for path lengths exceeding \\c MAX_PATH\n///     - \\c epcSlashToBackslash: (not implemented)  change forward slashes to back slashes (does not modify a \"xyz://\" protocol root)\n///     - \\c epcMakePretty: applies PathMakePretty\n///     - \\c epcRemoveArgs: remove command line arguments\n///     - \\c epcRemoveIconLocation: remove icon location number\n///     - \\c \\b epcExpandEnvStrings: Expand environment strings\n/// \n/// This function is called by most assignment constructors and assignment operators, using\n/// the \\c epc_Default cleanup options (typically those set in bold above, but check the enum \n/// documentation in case I forgot to update this one).\n/// \n/// Constructors and Assignment operators that take a string (\\c LPCTSTR, \\c LPCTSTR, \\c CString) call\n/// this function. Copy or assignment from another \\c CPath object does not call this function.\n/// \n/// \n//\nCPath & CPath::Clean(DWORD cleanup)\n{\n    if (cleanup & epcRemoveArgs)\n    {\n       // remove leading spaces, otherwise PathRemoveArgs considers everything a space\n       if (cleanup & epcTrim)\n          m_path.TrimLeft();  \n       \n        PathRemoveArgs(CStringLock(m_path));\n    }\n\n    if (cleanup & epcRemoveIconLocation)\n        PathParseIconLocation(CStringLock(m_path));\n\n\n    if (cleanup & epcTrim)\n        Trim();\n\n    if (cleanup & epcUnquote)\n    {\n        Unquote();\n        if (cleanup & epcTrimInQuote)\n            Trim();\n    }\n\n    if (cleanup & epcExpandEnvStrings)\n        ExpandEnvStrings();\n\n    if (cleanup & epcCanonicalize)\n        Canonicalize();\n\n    if (cleanup & epcRemoveXXL)\n        ShrinkXXLPath();\n\n    if (cleanup & epcSlashToBackslash)\n       m_path.Replace('/', '\\\\');\n\n    if (cleanup & epcMakePretty)\n        MakePretty();\n\n    return *this;\n}\n\n\n// Extractors\nCString CPath::GetStr(DWORD packing) const\n{\n    CString str = m_path;\n\n//    _ASSERTE(!(packing & eppAutoXXL));   // TODO\n\n    if (packing & eppAutoQuote)\n        str = QuoteSpaces(str);\n\n    if (packing & eppBackslashToSlash)\n        str.Replace('\\\\', '/');  // TODO: suport server-share and protocol correctly\n\n    return str;\n}\n\n\n_bstr_t CPath::GetBStr(DWORD packing) const\n{\n    return _bstr_t( GetStr(packing).operator LPCTSTR());\n}\n\n\n\n// ==================================================================\n//  Constructors \n// ------------------------------------------------------------------\n// \nCPath::CPath(LPCSTR path) : m_path(path)    \n{ \n    Clean();\n}\n\nCPath::CPath(LPCWSTR path) : m_path(path)\n{\n    Clean();\n}\n\nCPath::CPath(CString const & path) : m_path(path)\n{\n    Clean();\n}\n\nCPath::CPath(CPath const & path) : m_path(path.m_path) {}  // we assume it is already cleaned\n\n\nCPath::CPath(CString const & path,DWORD cleanup) : m_path(path)\n{\n    Clean(cleanup);\n}\n\n\n// ==================================================================\n//  Assignment\n// ------------------------------------------------------------------\n// \nCPath & CPath::operator=(LPCSTR rhs)\n{\n#ifndef _UNICODE    // avoidf self-assignment\n    if (rhs == m_path.operator LPCTSTR())\n        return *this;\n#endif\n    m_path = rhs;\n    Clean();\n    return *this;\n}\n\nCPath & CPath::operator=(LPCWSTR rhs)\n{\n#ifdef _UNICODE // avoid self-assignment\n    if (rhs == m_path.operator LPCTSTR())\n        return *this;\n#endif\n    m_path = rhs;\n    Clean();\n    return *this;\n}\n\nCPath & CPath::operator=(CString const & rhs)\n{\n    // our own test for self-assignment, so we can skip CClean in this case\n    if (rhs.operator LPCTSTR() == m_path.operator LPCTSTR())\n        return *this;\n    m_path = rhs;\n    Clean();\n    return *this;\n}\n\nCPath & CPath::operator=(CPath const & rhs)\n{\n    if (rhs.m_path.operator LPCTSTR() == m_path.operator LPCTSTR())\n        return *this;\n\n    m_path = rhs;\n    return *this;\n}\n\n\n\n\n// ==================================================================\n//  CPath::operator &=\n// ------------------------------------------------------------------\n///\n/// appends a path segment, making sure it is separated by exactly one backslash\n/// \\returns reference to the modified \\c CPath instance.\n// \nCPath & CPath::operator &=(LPCTSTR rhs)\n{\n    return CPath::Append(rhs);\n}\n\n\n// ==================================================================\n//  CPath::AddBackslash\n// ------------------------------------------------------------------\n///\n/// makes sure the contained path is terminated with a backslash\n/// \\returns [CPath &]: reference to the modified path\n/// see also: \\c PathAddBackslash Shell Lightweight Utility API\n// \nCPath & CPath::AddBackslash()\n{\n    if (GetLastChar(m_path) != Backslash)\n    {\n        CStringLock buffer(m_path, m_path.GetLength()+1);\n        PathAddBackslash(buffer);\n    }\n    return *this;\n}\n\n// ==================================================================\n//  CPath::RemoveBackslash\n// ------------------------------------------------------------------\n///\n/// If the path ends with a backslash, it is removed.\n/// \\returns [CPath &]: a reference to the modified path.\n// \nCPath & CPath::RemoveBackslash()\n{\n    if (GetLastChar(m_path) == Backslash)\n    {\n        CStringLock buffer(m_path, m_path.GetLength()+1);\n        PathRemoveBackslash(buffer);\n    }\n    return *this;\n}\n\n// ==================================================================\n//  CPath::Append\n// ------------------------------------------------------------------\n///\n/// Concatenates two paths\n/// \\par Differences to \\c PathAddBackslash:\n/// Unlike \\c PathAddBackslash, \\c CPath::Append appends a single backslash if rhs is empty (and\n/// the path does not already end with a backslash)\n/// \n/// \\param rhs [LPCTSTR]: the path component to append\n/// \\returns [CPath &]: reference to \\c *this\n// \nCPath & CPath::Append(LPCTSTR rhs)\n{\n    if (rhs == NULL || *rhs == '\\0')\n    {\n        AddBackslash();\n    }\n    else\n    {\n        int rhsLen = rhs ? (int)_tcslen(rhs) : 0;\n        CStringLock buffer(m_path, m_path.GetLength()+rhsLen+1);\n        PathAppend(buffer, rhs);\n    }\n    return *this;\n}\n\n\n\n// ==================================================================\n//  CPath::ShellGetRoot\n// ------------------------------------------------------------------\n///\n/// Retrieves the Root of the path, as returned by \\c PathSkipRoot.\n/// \n/// \\note For a more detailed (but \"hand-made\") implementation see GetRoot and GetRootType.\n/// \n/// The functionality of \\c PathSkipRoot is pretty much limited:\n///     - Drives (\"C:\\\\\" but not \"C:\")\n///     - UNC Shares (\"\\\\\\\\server\\\\share\\\\\", but neither \"\\\\\\\\server\" nor \"\\\\\\\\server\\\\share\")\n///     - UNC long drive (\"\\\\\\\\?\\\\C:\\\\\")\n/// \n/// \\returns [CString]: the rot part of the string\n/// \nCString CPath::ShellGetRoot() const\n{\n    LPCTSTR path = m_path;\n    LPCTSTR rootEnd = PathSkipRoot(path);\n\n    if (rootEnd == NULL)\n        return CString();\n\n    return m_path.Left((int)(rootEnd - path));\n}\n\n\n// ==================================================================\n//  GetRootType\n// ------------------------------------------------------------------\n/// \n/// returns the type of the root, and it's length.\n/// For supported tpyes, see \\ref nsPath::ERootType \"ERootType\".\n/// see also \\ref nsPath::GetRootType\n/// \nERootType CPath::GetRootType(int * len, bool greedy) const\n{\n   return nsPath::GetRootType(m_path, len, greedy);\n}\n\n// ==================================================================\n//  GetRoot\n// ------------------------------------------------------------------\n/// \n/// \\param rt [ERootType * =NULL]: if given, receives the type of the root segment.\n/// \\return [CString]: the root, as a string.\n/// \n/// For details which root types are supported, and how the length is calculated, see\n/// \\ref nsPath::ERootType \"ERootType\" and \\ref nsPath::GetRootType\n/// \nCString CPath::GetRoot(ERootType * rt, bool greedy) const\n{\n   int len = 0;\n   ERootType rt_ = nsPath::GetRootType(m_path, &len, greedy);\n   if (rt)\n      *rt = rt_;\n   return m_path.Left(len);\n}\n\n\n// ==================================================================\n//  CPath::SplitRoot\n// ------------------------------------------------------------------\n///\n/// removes and returns the root element from the contained path\n/// You can call SplitRoot repeatedly to retrieve the path segments in order\n/// \n/// \\param rt [ERootType * =NULL] if not NULL, receives the type of the root element\n///     note: the root element type can be recognized correctly only for the first segment\n/// \\returns [CString]: the root element of the original path\n/// \\par Side Effects: root element removed from contained path\n/// \nCString CPath::SplitRoot(ERootType * rt)\n{\n    CString head;\n \n   if (!m_path.GetLength())\n      return head;\n\n   int rootLen = 0;\n   ERootType rt_ = nsPath::GetRootType(m_path, &rootLen, false);\n   if (rt)\n       *rt = rt_;\n\n    if (rt_ == rtNoRoot) // not a typical root element\n    {\n        int start = 0;\n        if (GetFirstChar(m_path) == '\\\\') // skip leading backslash (double backslas handled before)\n            ++start;\n\n        int ipos = m_path.Find('\\\\', start);\n        if (ipos < 0)\n        {\n            head = start ? m_path.Mid(start) : m_path;\n            m_path.Empty();\n        }\n        else\n        {\n            head = m_path.Mid(start, ipos-start);\n            m_path = m_path.Mid(ipos+1);\n        }\n    }\n    else\n    {\n        head = m_path.Left(rootLen);\n\n        if (rootLen < m_path.GetLength() && m_path[rootLen] == '\\\\')\n            ++rootLen;\n        m_path = m_path.Mid(rootLen);\n    }\n\n    return head;\n}\n\n\n\n// ==================================================================\n//  CPath::GetPath\n// ------------------------------------------------------------------\n///\n/// returns the path (without file name and extension)\n/// \\param includeRoot [bool=true]: if \\c true (default), the root is included in the retuerned path.\n/// \\returns [CPath]: the path, excluding file name and \n/// \\par Implementation:\n///     Uses \\c PathFindFileName, and \\c PathSkipRoot\n/// \\todo\n///     - in \"c:\\\\temp\\\\\", \\c PathFindFileName considers \"temp\\\\\" to be a file name and returns\n///       \"c:\\\\\" only. This is clearly not my idea of a path\n///     - when Extending \\c CPath::GetRoot, this function should be adjusted as well\n/// \n// \nCPath CPath::GetPath(bool includeRoot ) const\n{\n    LPCTSTR path = m_path;\n    LPCTSTR fileName = PathFindFileName(path);\n    if (fileName == NULL) // seems to find something in any way!\n        fileName = path + m_path.GetLength();\n\n    LPCTSTR rootEnd = includeRoot ? NULL : PathSkipRoot(path);\n\n    CPath ret;\n    if (rootEnd == NULL)  // NULL if root should be included, or no root is found\n        return m_path.Left((int)(fileName-path));\n    else\n        return m_path.Mid((int)(rootEnd-path), (int)(fileName-rootEnd));\n}\n\n// ==================================================================\n//  CPath::GetName\n// ------------------------------------------------------------------\n///\n/// \\returns [CString]: the file name of the path\n/// \\par Differences to \\c PathFindFileName:\n/// \\c PathFindFileName, always treats the last path segment as file name, even if it ends with a backslash.\n/// \\c GetName treats such a string as not containing a file name\\n\n/// \\b Example: for \"c:\\\\temp\\\\\", \\c PathFindFileName finds \"temp\\\\\" as file name. \\c GetName returns\n/// an empty string.\nCString CPath::GetName() const\n{\n    // fix treating final path segments as file name\n    if (GetLastChar(m_path) == '\\\\')\n        return CString();\n\n    LPCTSTR path = m_path;\n    LPCTSTR fileName = PathFindFileName(path);\n    if (fileName == NULL)\n        return CString();\n\n    return m_path.Mid((int)(fileName-path));\n}\n\n// ==================================================================\n//  CPath::GetTitle\n// ------------------------------------------------------------------\n///\n/// \\returns [CString]: the file title, without path or extension\n// \nCString CPath::GetTitle() const\n{\n    LPCTSTR path = m_path;\n    LPCTSTR fileName = PathFindFileName(path);\n    LPCTSTR ext      = PathFindExtension(path);\n\n    if (fileName == NULL)\n        return CString();\n\n    if (ext == NULL)\n        return m_path.Mid((int)(fileName-path));\n\n    return m_path.Mid((int)(fileName-path), (int)(ext-fileName));\n\n\n}\n\n// ==================================================================\n//  CPath::GetExtension\n// ------------------------------------------------------------------\n///\n/// \\returns [CString]: file extension\n/// \\par Differences to \\c PathFindExtension\n/// Unlike \\c PathFindExtension, the period is not included in the extension string\n// \nCString CPath::GetExtension() const\n{\n    LPCTSTR path = m_path;\n    LPCTSTR ext      = PathFindExtension(path);\n\n    if (ext == NULL)\n        return CString();\n\n    if (*ext == '.')        // skip \".\"\n        ++ext;\n\n    return m_path.Mid((int)(ext-path));\n}\n\n\n\n\n// ==================================================================\n//  CPath::AddExtension\n// ------------------------------------------------------------------\n///\n/// Appends the specified extension to the path. The path remains unmodified if it already contains\n/// an extension (that is, the part behind the last backslash contains a period)\n/// \\par Difference to \\c PathAddExtension\n/// Unlike CPath::AddExtension adds a period, if \\c extension does not start with one\n/// \\param extension [LPCTSTR]: the extension to append\n/// \\param len [int, default=-1]: (optional) length of \\c extension in characters, not counting the\n///     terminating zero. This argument is only for avoiding a call to _tcslen if the caller already\n///     knows the length of the string. The string still needs to be zero-terminated and contain exactly \n///     \\c len characters. \n/// \\returns [CPath &]: reference to the modified Path object\n// \nCPath & CPath::AddExtension(LPCTSTR extension, int len)\n{\n    if (!extension)\n        return AddExtension(_T(\"\"), 0);\n\n    if (*extension != '.')\n    {\n        CString s = CString('.') + extension;\n        return AddExtension( s, s.GetLength());\n    }\n\n    if (len < 0)\n        return AddExtension(extension, (int)_tcslen(extension));\n\n    int totalLen = m_path.GetLength() + len;  // already counts the period\n\n    PathAddExtension(CStringLock(m_path, totalLen), extension);\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::RemoveExtension\n// ------------------------------------------------------------------\n///\n/// Removes the extension of the path, if it has any.\n/// \\returns [CPath &]: reference to the modified path object\n// \nCPath& CPath::RemoveExtension()\n{\n    PathRemoveExtension(CStringLock(m_path));\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::RenameExtension\n// ------------------------------------------------------------------\n///\n/// Replaces an existing extension with the new given extension.\n/// If the path has no extension, it is appended.\n/// \\par Difference  to \\c PathRenameExtension:\n/// Unlike PathRenameExtension, \\c newExt needs not start with a period.\n/// \\param newExt [LPCTSTR ]: newextension\n/// \\returns [CPath &]: reference to the modified path string\n// \nCPath & CPath::RenameExtension(LPCTSTR newExt)\n{\n    if (newExt == NULL || *newExt != '.')\n    {\n        RemoveExtension();\n        return AddExtension(newExt);\n    }\n\n    int maxLen = m_path.GetLength() + (int)_tcslen(newExt) + 1;\n    PathRenameExtension(CStringLock(m_path, maxLen), newExt);\n    return *this;\n}\n\n\n// ==================================================================\n//  ::RemoveFileSpec\n// ------------------------------------------------------------------\n///\n/// Removes the file specification (amd extension) from the path.\n/// \\returns [CPath &]: a reference to the modified path object\n// \nCPath & CPath::RemoveFileSpec()\n{\n    PathRemoveFileSpec(CStringLock(m_path));\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::SplitArgs\n// ------------------------------------------------------------------\n///\n/// (static) Separates a path string from command line arguments\n/// \n/// \\param path_args [CString const &]: the path string with additional command line arguments\n/// \\param args [CString *, out]: if not \\c NULL, receives the arguments separated from the path\n/// \\param cleanup [DWORD, = epc_Default]: the \"cleanup\" treatment to apply to the path, see \\c CPath::Clean\n/// \\returns [CPath]: a new path without the arguments\n// \nCPath SplitArgs(CString const & path_args, CString * args, DWORD cleanup)\n{\n   CString pathWithArgs = path_args;\n\n   // when \"trim\" is given, trim left spaces, so PathRemoveArgsworks correctly and returns \n   // the path part with the correct length\n   if (cleanup & epcTrim)\n      pathWithArgs.TrimLeft();\n\n    // assign with only removing the arguments\n    CPath path(pathWithArgs, epcRemoveArgs);\n\n    // cut non-argument part away from s\n    if (args)\n    {\n        *args = pathWithArgs.Mid(path.GetLength());\n        args->TrimLeft();\n    }\n\n    // now, clean the contained string (last since it might shorten the path string)\n    path.Clean(cleanup &~ epcRemoveArgs);\n\n    return path;\n}\n\n\n// ==================================================================\n//  CPath::SplitIconLocation\n// ------------------------------------------------------------------\n/// \n/// (static) Splits a path string containing an icon location into path and icon index\n///\n/// \\param path_icon [CString const &]: the string containing an icon location\n/// \\param pIcon [int *, NULL]: if not NULL, receives the icon index \n/// \\param cleanup [DWORD, epc_Default]: additional cleanup to apply to the returned path\n/// \\returns [CPath]: the path contained in \\c path_icon (without the icon location)\n// \nCPath SplitIconLocation(CString const & path_icon, int * pIcon, DWORD cleanup)\n{\n    CString strpath = path_icon;\n    int icon = PathParseIconLocation( CStringLock(strpath) );\n    if (pIcon)\n        *pIcon = icon;\n\n    return CPath(strpath, cleanup & ~epcRemoveIconLocation);\n}\n\n\n// ==================================================================\n//  CPath::BuildRoot\n// ------------------------------------------------------------------\n///\n/// (static) Creates a root path from a drive index (0..25)\n/// \\param driveNumber [int]: Number of the drive, 0 == 'A', etc.\n/// \\returns [CPath]: a path consisitng only of a drive root\n// \nCPath BuildRoot(int driveNumber)\n{\n    CString strDriveRoot;\n    ::PathBuildRoot(CStringLock(strDriveRoot, 3), driveNumber);\n    return CPath(strDriveRoot, 0);\n}\n\n\n\n// ==================================================================\n//  CPath::GetModuleFileName\n// ------------------------------------------------------------------\n///\n/// Returns the path of the dspecified module handle\n/// Path is limited to \\c MAX_PATH characters\n/// see Win32: GetModuleFileName for more information\n/// \\param module [HMODULE =NULL ]: DLL module handle, or NULL for path to exe\n/// \\returns [CPath]: path to the specified module, or to the application exe if \\c module==NULL.\n///         If an error occurs, the function returrns an empty string. \n///         Call \\c GetLastError() for more information.\n/// \nCPath GetModuleFileName(HMODULE module)\n{\n    CString path;\n    DWORD ok = ::GetModuleFileName(module, CStringLock(path, MAX_PATH), MAX_PATH+1);\n    if (ok == 0)\n        return CPath();\n    return CPath(path);\n}\n\n\n\n// ==================================================================\n//  CPath::GetCurrentDirectory\n// ------------------------------------------------------------------\n///\n/// \\returns [CPath]: the current directory, se Win32: \\c GetCurrentDirectory.\n/// \\remarks\n/// If an error occurs the function returns an empty string. More information is available\n/// through \\c GetLastError.\n/// \nCPath GetCurrentDirectory()\n{\n    CString path;\n    CStringLock buffer(path, MAX_PATH);\n    DWORD chars = ::GetCurrentDirectory(MAX_PATH+1, buffer);\n    buffer.Release(chars);\n    return CPath(path);\n}\n\n\n// ==================================================================\n//  CPath::GetCommonPrefix\n// ------------------------------------------------------------------\n///\n/// Returns the common prefix of this path and the given other path,\n/// e.g. for \"c:\\temp\\foo\\foo.txt\" and \"c:\\temp\\bar\\bar.txt\", it returns\n/// \"c:\\temp\".\n/// \\param secondPath [LPCTSTR]: the path to compare to\n/// \\returns [CPath]: a new path, containing the part that is identical\n// \nCPath CPath::GetCommonPrefix(LPCTSTR secondPath)\n{\n    CString prefix;\n    PathCommonPrefix(m_path, secondPath, CStringLock(prefix, m_path.GetLength()));\n    return CPath(prefix, 0);\n\n\n}\n\n\n\n// ==================================================================\n//  CPath::GetDriveNumber\n// ------------------------------------------------------------------\n///\n/// \\returns [int]: the driver number (0..25 for A..Z), or -1 if the \n///     path does not start with a drive letter\n// \nint CPath::GetDriveNumber()\n{\n    return PathGetDriveNumber(m_path);\n}\n\n// ==================================================================\n//  CPath::GetDriveLetter\n// ------------------------------------------------------------------\n///\n/// \\returns [TCHAR]: the drive letter in uppercase, or 0\n// \nTCHAR CPath::GetDriveLetter()\n{\n    int driveNum = GetDriveNumber();\n    if (driveNum < 0)\n        return 0;\n    return (TCHAR)(driveNum + 'A');\n}\n\n\n// ==================================================================\n//  CPath::RelativePathTo\n// ------------------------------------------------------------------\n///\n/// Determines a relative path from the contained path to the specified \\c pathTo\n/// \\par Difference to \\c PathRelativeTo:\n///  - instead of a file attributes value, you specify a flag (this is a probelm only\n///     if the function supports other attribues than FILE_ATTRIBUTE_DIRECTORY in the future)\n///  - no flag / attribute is specified for the destination (it does not seem to make a difference)\n/// \\param pathTo [LPCTSTR]: the target path or drive\n/// \\param srcIsDir [bool =false]: determines whether the current path is as a directory or a file\n/// \\returns [CPath]: a relative path from this to \\c pathTo\n// \nCPath CPath::RelativePathTo(LPCTSTR pathTo,bool srcIsDir)\n{\n    CString path;\n    if (!pathTo)\n        return CPath();\n\n    // maximum length estimate: \n    // going up to the root of a path like \"c:\\a\\b\\c\\d\\e\", and then append the entire to path\n    int maxLen = 3*m_path.GetLength() / 2 +1  + (int)_tcslen(pathTo); \n\n    PathRelativePathTo( CStringLock(path, maxLen), \n                        m_path, \n                        srcIsDir ? FILE_ATTRIBUTE_DIRECTORY : 0,\n                        pathTo, 0);\n\n    return CPath(path, 0);\n}\n\n\n// ==================================================================\n//  MakeRelative\n// ------------------------------------------------------------------\n/// \n/// Of the path contained is below \\c basePath, it is made relative.\n/// Otherwise, it remains unmodified. \n/// \n/// Unlike RelativePathTo, the path is made relative only if the base path\n/// matches completely, and does not generate \"..\" elements.\n/// \n/// \\return [bool] true if the path was modified, false otherwise.\n/// \nbool CPath::MakeRelative(CPath const & basePath)\n{\n   CPath basePathBS = basePath;\n   basePathBS.AddBackslash(); // add backslash so that \"c:\\a\" is not a base path for \"c:\\alqueida\\files\"\n\n   if (m_path.GetLength() > basePathBS.GetLength())\n   {\n      if (0 == _tcsnicmp(basePathBS, m_path, basePathBS.GetLength()))\n      {\n         m_path = m_path.Mid(basePathBS.GetLength());\n         return true;\n      }\n   }\n   return false;\n}\n\n// ==================================================================\n//  MakeAbsolute\n// ------------------------------------------------------------------\n/// \n/// If the contained path is relative, it is prefixed by \\c basePath.\n/// Otherwise it remains unmodified.\n/// \n/// Use: as anti-MakeRelative.\n/// \nbool CPath::MakeAbsolute(CPath const & basePath)\n{\n   if (IsRelative())\n   {\n      m_path = basePath & m_path;\n      return true;\n   }\n   return false;\n}\n\n\n\n\n// ==================================================================\n//  CPath::MatchSpec\n// ------------------------------------------------------------------\n///\n/// Checks if the path matches a certain specification\n/// \\param spec [LPCTSTR]: File specification (like \"*.txt\")\n/// \\returns [bool]: true if the path matches the specification\n// \nbool CPath::MatchSpec(LPCTSTR spec)\n{\n    return PathMatchSpec(m_path, spec) != 0;\n}\n\n\n\n// ==================================================================\n//  CPath::ExpandEnvStrings\n// ------------------------------------------------------------------\n///\n/// replaces environment string references with their current value.\n/// See MSDN: \\c ExpandEnvironmentStrings for more information\n/// \\returns [CPath &]: reference to the modified path\n// \nCPath & CPath::ExpandEnvStrings()\n{\n    CString target;\n\n    DWORD len = m_path.GetLength();\n\n    DWORD required = ExpandEnvironmentStrings(\n                m_path,\n                CStringLock(target, len), len+1);\n\n    if (required > len+1)\n        ExpandEnvironmentStrings(\n                m_path,\n                CStringLock(target, required), required+1);\n\n    m_path = CPath(target, 0);\n    return *this;\n}\n\n\n// ==================================================================\n//  CPath::GetCompactStr\n// ------------------------------------------------------------------\n///\n/// Inserts ellipses so the path fits into the specified number of pixels\n/// See also SMDN: \\c PathCompactPath \n/// \\param dc [HDC]: device context where the path is displayed\n/// \\param dx [UINT]: number of pixels where to display\n/// \\param eppFlags [DWORD, =0]: combination of \\c EPathPacking flags indicating how to prepare the path\n/// \\returns [CString]: path string prepared for display\n// \nCString CPath::GetCompactStr(HDC dc,UINT dx, DWORD eppFlags)\n{\n    CString ret = GetStr(eppFlags);\n\tPathCompactPath(dc, CStringLock(ret), dx);\n    return ret;\n}\n\n// ==================================================================\n//  CPath::GetCompactStr\n// ------------------------------------------------------------------\n///\n/// Inserts ellipses so the path does not exceed the given number of characters\n/// \\param cchMax [UINT]: maximum number of characters\n/// \\param eppFlags [DWORD, =0]: combination of \\c EPathPacking flags indicating how to prepare the path\n/// \\param flags [DWORD, =0]: reserved, must be 0\n/// \\returns [CString]: path string prepared for display\n// \nCString CPath::GetCompactStr(UINT cchMax,DWORD flags, DWORD eppFlags )\n{\n    CString cleanPath = GetStr(eppFlags);\n    CString ret;\n\n    PathCompactPathEx(CStringLock(ret, cleanPath.GetLength()), cleanPath, cchMax, flags);\n    return ret;\n}\n\n// ==================================================================\n//  CPath::SetDlgItem\n// ------------------------------------------------------------------\n///\n/// Sets the text of a child control of a window or dialog, \n/// PathCompactPath to make it fit\n/// \n/// \\param dlg [HWND]: the window handle of the parent window\n/// \\param dlgCtrlID [UINT]: ID of the child control\n/// \\param eppFlags [DWORD, =0]: combination of \\c EPathPacking flags indicating how to prepare the path\n/// \\returns [void]:\n// \nvoid CPath::SetDlgItem(HWND dlg,UINT dlgCtrlID, DWORD eppFlags)\n{\n    CString cleanPath = GetStr(eppFlags);\n    PathSetDlgItemPath(dlg, dlgCtrlID, cleanPath);\n}\n\n\n// ==================================================================\n//  ::SearchAndQualify\n// ------------------------------------------------------------------\n///\n/// Searches for the given file on the search path. If it exists in the search path, \n/// it is qualified with the full path of the first occurence found. Otherwise, it is \n/// qualified with the current path. An absolute file paths remains unchanged. \n/// \n/// \\note\n/// SearchAndQualify seems to be affected by the same problem\n/// as \\ref nsPath::CPath::Canonicalize \"Canonicalize\" : a path like \"..\\\\..\\\\x\" \n/// is changed to \"\\\\x\", which is clearly not correct (IMHO).\n/// \\n\n/// compare also: \\ref nsPath::CPath::FindOnPath \"FindOnPath\":\n/// FindOnPath allows to specify custom directories to be searched before the search path, and\n/// behaves differently in some cases.\n/// If the file is not found on the search path, \\c FindOnPath leaves the file name unchanged.\n/// SearchAndQualify qualifies the path with the current directory in this case\n/// \n// \nCPath & CPath::SearchAndQualify()\n{\n    if (!m_path.GetLength())\n        return *this;\n\n    CString qualified;\n    DWORD len = m_path.GetLength();\n    while (qualified.GetLength() == 0)\n    {\n        PathSearchAndQualify(m_path, CStringLock(qualified, len), len+1);\n        len *= 2;\n    }\n    m_path = qualified;\n    return *this;\n}\n\n\n\n// ==================================================================\n//  CPath::FindOnPath\n// ------------------------------------------------------------------\n///\n/// Similar to SearchAndQualify, but \n/// \\note\n///  -# the return value of PathFindOnPath does \\b not indicate whether the file\n///     exisits, that's why we don't return it either. If you want to check if the file\n///     really is there use \\c FileExists\n///  -# PathFindOnPath does not check for string overflow. Documentation recommends to use a buffer\n///     of length MAX_PATH. I don't trust it to be fail safe in case a path plus the string\n///     exceeds this length (note that the file would not be found in this case - but the shell\n///     API might be tempted to build the string inside the buffer)\\n\n///     If you don't need the \"additional Dirs\" functionality, it is recommended to use\n///     SearchAndQualify instead\n/// \n/// \\param additionalDirs [LPCTSTR *, = NULL]: Additional NULL-terminated array of directories \n///                                            to search first\n/// \\returns [CPath &]: a reference to the fully qualified file path\n/// \n/// \\par error handling:\n///   If the function succeeds, \\c GetLastError returns 0. Otherwise, \\c GetLastError returns a Win32 error code.\n/// \nCPath & CPath::FindOnPath(LPCTSTR * additionalDirs)\n{\n    DWORD len = m_path.GetLength() + 1 + MAX_PATH;\n    bool ok = PathFindOnPath(CStringLock(m_path, len), additionalDirs) != 0;\n    if (ok)\n       SetLastError(0);\n    return *this;\n}\n\n\n\n\n// ==================================================================\n//  CPath::Exists\n// ------------------------------------------------------------------\n///\n/// \\returns [bool]: true if the file exists on the file system, false otherwise.\n// \nbool CPath::Exists() const\n{\n    return PathFileExists(m_path) != 0;\n}\n\n// ==================================================================\n//  CPath::IsDirectory\n// ------------------------------------------------------------------\n///\n/// \\returns [bool]: true if the contained path specifies a directory \n///                  that exists on the file system\n// \nbool CPath::IsDirectory() const\n{\n    return PathIsDirectory(m_path) != 0;\n}\n\n\n// ==================================================================\n//  CPath::IsSystemFolder\n// ------------------------------------------------------------------\n///\n/// \\param  attrib [DWORD, default = FILE_ATTRIBUTE_SYSTEM]: the attributes that \n///                 identify a system folder\n/// \\returns [bool]: true if the specified path exists and is a system folder\n// \nbool CPath::IsSystemFolder(DWORD attrib) const\n{\n    return PathIsSystemFolder(m_path, attrib) != 0;\n}\n\n// ==================================================================\n//  CPath::MakeSystemFolder\n// ------------------------------------------------------------------\n///\n/// \\param make [bool, default=true]: true to set the \"System Folder\" state, false to reset it\n/// \\par error handling:\n///  If the function succeeds, \\c GetLastError returns 0. Otherwise, \\c GetLastError returns a Win32 error code.\n// \nCPath & CPath::MakeSystemFolder(bool make)\n{\n   bool ok = make ? PathMakeSystemFolder(m_path) != 0 : PathUnmakeSystemFolder(m_path) != 0;\n   if (ok) \n      SetLastError(0);\n   return *this;\n}\n\n\n// ==================================================================\n//  MakeFullPath\n// ------------------------------------------------------------------\n/// \n/// Makes a absolute path from a relative path, using the current working directory.\n/// \n/// If the path is already absolute, it is not changed.\n/// \nCPath & CPath::MakeFullPath()\n{\n   if (!IsRelative())\n      return *this;\n\n   LPTSTR dummy = NULL;\n   DWORD chars = GetFullPathName(m_path, 0, NULL, &dummy);\n   _ASSERTE(chars > 0);\n\n   CString fullStr;\n   chars = GetFullPathName(m_path, chars, CStringLock(fullStr, chars), &dummy);\n   m_path = fullStr;\n   return *this;\n}\n\n\n\n// ==================================================================\n//  CPath::GetAttributes\n// ------------------------------------------------------------------\n///\n/// \\returns [DWORD]: the file attributes of the specified path or file, or -1 if it \n///                   does not exist.\n// \nDWORD CPath::GetAttributes()\n{\n    return ::GetFileAttributes(m_path);\n\t// \n}\n\n// ==================================================================\n//  CPath::GetAttributes\n// ------------------------------------------------------------------\n///\n/// retrives the \\c GetFileExInfoStandard File Attribute information\n/// \n/// \\param fad [WIN32_FILE_ATTRIBUTE_DATA &, out]: receives the extended file attribute\n///     information (like size, timestamps) for the specified file\n/// \\returns [bool]: true if the file is found and the query was successful, false otherwise\n// \nbool CPath::GetAttributes(WIN32_FILE_ATTRIBUTE_DATA & fad)\n{\n    ZeroMemory(&fad, sizeof(fad));\n    return ::GetFileAttributesEx(m_path, GetFileExInfoStandard, &fad) != 0;\n}\n\n\n// ==================================================================\n//  CPath::EnvUnexpandRoot\n// ------------------------------------------------------------------\n///\n/// replaces path start with matching environment variable\n/// If the path starts with the value of the environment variable %envVar%,\n/// The beginning of the path is replaced with the environment variable.\n/// \n/// e.g. when specifying \"WinDir\" as \\c envVar, \"C:\\\\Windows\\\\foo.dll\" is replaced by\n/// \"%WINDIR%\\foo.dll\"\n/// \n/// \\param envVar [LPCTSTR]: environment variable to check \n/// \\returns \\c true if the path was modified.\n/// \n/// If the environment variable does not exist, or the value of the environment variable\n/// does not match the beginning of the path, the path is unmodified and the function returns \n/// false.\n/// \nbool CPath::EnvUnexpandRoot(LPCTSTR envVar)\n{\n    return nsDetail::EnvUnsubstRoot(m_path, envVar);\n}\n\n// ==================================================================\n//  CPath::EnvUnexpandDefaultRoots\n// ------------------------------------------------------------------\n///\n/// Tries to replace the path root with a matching environment variable.\n/// \n/// \n/// Checks a set of default environment variables, if they match the beginning of the path.\n/// If one of them matches, the beginning of the path is replaced with the environment\n/// variable specification, and the function returns true.\n/// Otherwise, the path remains unmodified and the function returns false.\n/// \n/// see EnvUnexpandRoot for details.\n/// \nbool CPath::EnvUnexpandDefaultRoots()\n{\n    // note: Order is important\n    return EnvUnexpandRoot(_T(\"APPDATA\")) ||\n           EnvUnexpandRoot(_T(\"USERPROFILE\")) ||\n           EnvUnexpandRoot(_T(\"ALLUSERSPROFILE\")) ||\n           EnvUnexpandRoot(_T(\"ProgramFiles\")) ||\n           EnvUnexpandRoot(_T(\"SystemRoot\")) ||\n           EnvUnexpandRoot(_T(\"WinDir\")) ||\n           EnvUnexpandRoot(_T(\"SystemDrive\"));\n}\n\n\n// ==================================================================\n//  CPath::FromRegistry\n// ------------------------------------------------------------------\n/// \n/// Reads a path string from the registry.\n/// \\param baseKey [HKEY]: base key for registry path\n/// \\param subkey [LPCTSTR]: registry path\n/// \\param name [LPCTSTR] name of the value\n/// \\returns [CPath]: a path string read from the specified location\n/// \n/// If the path is stored as REG_EXPAND_SZ, environment strings are expanded.\n/// Otherwise, the string remains unmodified.\n/// \n/// \\par Error Handling:\n///   If an error occurs, the return value is an empty string, and GetLastError() returns the respective\n///   error code. In particular, if the registry value exists but does not contain a string, GetLastError()\n///   returns ERROR_INVALID_DATA\n///   \\n\\n\n///   If the function succeeds, GetLastError() returns zero.\n/// \n/// See also nsPath::ToRegistry\n///             \nCPath FromRegistry(HKEY baseKey, LPCTSTR subkey, LPCTSTR name)\n{\n   SetLastError(0);\n\n   CAutoHKEY key;\n   DWORD ok = RegOpenKeyEx(baseKey, subkey, 0, KEY_READ, key.OutArg());\n   if (ok != ERROR_SUCCESS)\n   {\n       SetLastError(ok);\n       return CPath();\n   }\n\n   DWORD len = 256;\n   DWORD type = 0;\n\n   CString path;\n\n   do \n   {\n       CStringLock buffer(path, len);\n       if (!buffer)\n       {\n           SetLastError(ERROR_OUTOFMEMORY);\n           return CPath();\n       }\n\n       DWORD size = (len+1) * sizeof(TCHAR); // size includes terminating zero\n       ok = RegQueryValueEx(key, name, NULL, &type, \n                            (LPBYTE) buffer.operator LPTSTR(), &size );\n\n       // read successfully:\n       if (ok == ERROR_SUCCESS)\n       {\n           if (type != REG_SZ && type != REG_EXPAND_SZ)\n           {\n               SetLastError(ERROR_INVALID_DATA);\n               return CPath();\n           }\n           break; // accept string\n       }\n\n       // buffer to small\n       if (ok == ERROR_MORE_DATA)\n       {\n           len = (size + sizeof(TCHAR) - 1) / sizeof(TCHAR);\n           continue;\n       }\n\n       // otherwise, an error occured\n       SetLastError(ok);\n       return CPath();\n   } while(1);\n\n   DWORD cleanup = epc_Default;\n   if (type == REG_SZ)\n       cleanup &= ~epcExpandEnvStrings;\n   else\n       cleanup |= epcExpandEnvStrings; // on by default, but I might change my mind..\n\n   return CPath(path, cleanup);\n}\n\n\n\n\n\n// ==================================================================\n//  CPath::ToRegistry\n// ------------------------------------------------------------------\n///\n/// Writes the path to the registry\n/// \n/// \\param baseKey: root of registry path\n/// \\param subkey: registry path where to store\n/// \\param name: name to store the key under\n/// \\param replaceEnv [bool=true]: If true (default), environment strings will be replaced\n///     with environment variables, and the string is stored as REG_EXPAND_SZ. \n///     Otherwise, the string is stored unmodified as REG_SZ.\n/// \n/// See also nsPath::FromRegistry\n/// \nlong CPath::ToRegistry(HKEY baseKey,LPCTSTR subkey,LPCTSTR name,bool replaceEnv)\n{\n    CAutoHKEY key;\n    DWORD ok = RegCreateKeyEx(baseKey, subkey, NULL, NULL, 0, KEY_WRITE, NULL, key.OutArg(), NULL);\n    if (ok != ERROR_SUCCESS)\n        return ok;\n\n    CString path;\n    if (replaceEnv)\n    { \n        CPath ptemp = path;\n        ptemp.EnvUnexpandDefaultRoots();\n        path = ptemp.GetStr();\n    }\n    else\n        path = GetStr();\n\n    ok = RegSetValueEx(key, name, 0, replaceEnv ? REG_EXPAND_SZ : REG_SZ,\n                        (BYTE *) path.operator LPCTSTR(), \n                        (path.GetLength()+1) * sizeof(TCHAR) );\n    return ok;\n}\n\n\n\n// ==================================================================\n//  IsDot, IsDotDot, IsDotty\n// ------------------------------------------------------------------\n///\nbool CPath::IsDot() const \n{ \n    return m_path.GetLength() == 1 && m_path[0] == '.';\n}\n\nbool CPath::IsDotDot() const\n{\n    return m_path.GetLength() == 2 && m_path[0] == '.' && m_path[1] == '.';\n}\n\nbool CPath::IsDotty() const\n{\n    return IsDot() || IsDotDot();\n}\n\n\nconst LPCTSTR InvalidChars_Windows =\n\t_T(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\")\n\t_T(\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F\")\n\t_T(\"\\\\/:*?\\\"<>|\");\n\n\n\n// ==================================================================\n//  IsValid\n// ------------------------------------------------------------------\n/// \n/// returns true if the path satisfies Windows naming conventions\n///\nbool CPath::IsValid() const\n{\n    if (!m_path.GetLength()) return false;\n    if (m_path.FindOneOf(InvalidChars_Windows) >= 0) return false;\n    if (GetLastChar(m_path) == '.') // may not end in '.', except \".\" and \"..\"\n    {\n        if (m_path.GetLength() > 2 || m_path[0] != '.')\n            return false;\n    }\n    return true;\n}\n\n\n\n\n// ==================================================================\n//  ReplaceInvalid\n// ------------------------------------------------------------------\n/// \n/// replaces all invalid file name characters  inc \\c s with \\c replaceChar\n/// This is helpful when generating names based on user input\n/// \nCString ReplaceInvalid(CString const & str, TCHAR replaceChar)\n{\n    if (!str.GetLength() || CPath(str).IsDotty())\n        return str;\n\n    CString s = str;\n\n    for(int i=0; i<s.GetLength(); ++i)\n    {\n        TCHAR ch = s.GetAt(i);\n        if (_tcschr(InvalidChars_Windows, ch))\n            s.SetAt(i, replaceChar);\n    }\n\n    // last one may not be a dot\n    int len = s.GetLength();\n    if (s[len-1] == '.')\n        s.SetAt(len-1, replaceChar);\n    return s;\n}\n\n\n\n// ==================================================================\n\n} // namespace nsPath\n\n\n\n"
        },
        {
          "name": "Path.h",
          "type": "blob",
          "size": 14.2890625,
          "content": "// ==================================================================\n// \n//  Path.h   \n//  \n//  Created:       03.03.2005\n//\n//  Copyright (C) Peter Hauptmann\n//              \n// ------------------------------------------------------------------\n// \n/// \\page pgDisclaimer Copyright & Disclaimer\n/// \n/// Copyright (C) 2004-2005 Peter Hauptmann\n///     all rights reserved\n/// more info: http://www.codeproject.com/phShellPath.asp\n/// Please contact the author with improvements / modifications.\n/// \n/// Redistribution and use in source and binary forms, with or without\n/// modification, are permitted under the following conditions: \n///     - Redistribution of source must retain the copyright above, \n///       and the disclaimer below.\n///     - Modifications to the source should be marked clearly, to be \n///       distinguishable from the original sources.\n/// \n/// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n/// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n/// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n/// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n/// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n/// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n/// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n/// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n/// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n/// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n/// SUCH DAMAGE.\n/// \n\n\n#ifndef FILE_PH_PATH_H_200506202_INCLUDED_\n#define FILE_PH_PATH_H_200506202_INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif\n\n\n#include <comdef.h> // for _bstr_t extractor only, can be removed if you don't need CPath::GetBStr()\n#include \"shlwapi.h\"\n\n\n#pragma once\n\n\n\n\n\n/// The nsPath namespace contains the CPath class and global helper functions.\nnamespace nsPath\n{\n\n// ---------------- DECLARATIONS --------------------------------------------\n\n    // ----- CString Helpers ---------\nvoid  Trim(CString & s);                    \nTCHAR GetFirstChar(CString const & s);      ///< returns the first char of the string, or 0 if the string length is 0.\nTCHAR GetLastChar(CString const & s);       ///< returns the last char of the string, or 0 if the string length is 0.\n\n\nTCHAR GetDriveLetter(TCHAR ch);\nTCHAR GetDriveLetter(LPCTSTR s);\n\nCString QuoteSpaces(CString const & str);\n\n\n// ==================================================================\n//  ERootType\n// ------------------------------------------------------------------\n/// \n/// Recognized root types for a path. \n/// see nsPath::GetRootType \"GetRootType\" for more.\n/// \n/// \\c len refers to the rootLen parameter optionally returned by \\c GetRootType.\n/// \nenum ERootType\n{\n   rtNoRoot       =  0,    ///< no, or unknown root (\\c len = 0)\n   rtDriveRoot    =  1,    ///< a drive specification with backslash (\"C:\\\", \\c len = 3)\n   rtDriveCur     =  2,    ///< a drive specification without backslash (\"C:\", \\c len = 2)\n//   rtPathRoot     =  3,    ///< a path root, i.e. staring with a single backslash (nyi, \\c len = 1)\n   rtLongPath     =  4,    ///< a UNC long path specification (e.g. \"\\\\?\\C:\\\", \\c len is length of path root + 4),  no distinction for \"root / current\" is made\n   rtServerOnly   =  5,    ///< a server only specification (e.g. \"\\\\fileserv\" or \"\\\\fileserv\\\", \\c len is the string length)\n   rtServerShare  =  6,    ///< server + share specification (\"\\\\server\\share\", \\c len includes the backslash after share if given)\n   rtProtocol     =  7,    ///< protocol, (\"http://\", \\c len includes the \"://\" part)\n   rtPseudoProtocol = 8,   ///< pseudo protocol (no slahes) (\"mailto:\", \\c len includes the colon)\n   rtServer         = 9,    ///< server with share following (for GetRootType(_,_,greedy=false)\n};\n\nERootType GetRootType(LPCTSTR path, int * pLen, bool greedy = true); \n\n\n\n// ==================================================================\n//  nsPath::EPathCleanup\n// ------------------------------------------------------------------\n/// Flags for nsPath::CPath::Cleanup\n///\nenum EPathCleanup\n{\n    epcTrim             =   1,      ///< trim outer whitespace\n    epcUnquote          =   2,      ///< remove single or double quotes\n    epcTrimInQuote      =   4,      ///< trim whitespaces inside quotes\n    epcCanonicalize     =   8,      ///< Canonicalize (collapse \"\\\\..\\\\\" and \"\\\\.\\\\\")\n    epcRemoveXXL        =   16,     ///< Remove \"\\\\\\\\?\\\\\" and \"\\\\\\\\?\\\\UNC\\\\\" markers\n    epcSlashToBackslash = 32,   ///< replace forward slashes with backslashes\n    epcMakePretty       =   64,     ///< Windows' idea of a pretty path\n    epcRemoveArgs       =  128,     ///< calls PathRemoveArgs (before trimming/unquoting)\n    epcRemoveIconLocation = 256,    ///< Remove Icon location from the path\n    epcExpandEnvStrings   = 512,    ///< Expand environment strings\n\n    epc_Default = epcTrim | \n                  epcUnquote | \n                  epcTrimInQuote | \n                  epcCanonicalize | \n                  epcRemoveXXL |\n                  epcExpandEnvStrings, ///< default for CTors and Assignment operators\n};\n\n\n// ==================================================================\n//  nsPath::EPathPacking\n// ------------------------------------------------------------------\n/// \n/// Flags for nsPath::CPath::GetStr\n/// \\note \n/// eppAutoQuote was ignored in Version 1.2 and before. \n/// It is fixed since V.1.3 (August 2005), /// but was removed from \n/// epp_Default for backward compatibility\n///\nenum EPathPacking\n{\n    eppAutoQuote        =   1,      ///< Quote the path if it contains spaces\n    eppAutoXXL          =   2,      ///< If path length is > MAX_PATH, use \"\\\\\\\\?\\\\\" syntax\n    eppBackslashToSlash =   4,      ///< turn backslashes into forward slashes\n\n    epp_Default = eppAutoXXL,       \n};\n\n\n\n\n// ==================================================================\n//  nsPath::CPath\n// ------------------------------------------------------------------\n/// \n/// \n///\nclass CPath\n{\nprotected:\n    CString     m_path;\n    void        CAssign(CString const & src);\n\npublic:\n\n    //@{ \\name Construction\n    CPath()                     {}\n    CPath(LPCSTR path);             ///< Assigns \\c path. CPath::Clean(epc_Default) is called for cleanup\n    CPath(LPCWSTR path);            ///< Assigns \\c path. CPath::Clean(epc_Default) is called for cleanup\n    CPath(CString const & path);    ///< Assigns \\c path  CPath::Clean(epc_Default) is called for cleanup\n    CPath(CPath const & path);      ///< Assigns \\c path to the path. Does \\b not modify the assigned path!\n    CPath(CString const & path, DWORD cleanup); ///< Assigns \\c path, using custom cleanup options (see CPath::Clean)\n    //@}\n\n\n    //@{ \\name Assignment\n    CPath & operator=(LPCSTR rhs);  ///< Assigns \\c path, and calls CPath::Clean(epc_Default)\n    CPath & operator=(LPCWSTR rhs); ///< Assigns \\c path, and calls CPath::Clean(epc_Default)\n\n    CPath & operator=(CString const & rhs); ///< Assigns \\c path, and calls CPath::Clean(epc_Default)\n    CPath & operator=(CPath const & rhs);   ///< Assigns \\c path Does \\b not call CPath::Clean!\n    CPath & Assign(CString const & str, DWORD cleanup = epc_Default);\n    //@}\n\n    //@{ \\name Miscellaneous Query\n    operator LPCTSTR () const   { return m_path.operator LPCTSTR(); } \n    int      GetLength() const  { return m_path.GetLength(); }  ///< returns the length of the path, in characters\n    //@}\n\n    //@{ \\name Path concatenation\n    CPath & operator &=(LPCTSTR rhs);   \n    CPath & Append(LPCTSTR appendix);\n    CPath & AddBackslash();\n    CPath & RemoveBackslash();\n    //@}\n\n    //@{ \\name Splitting into Path Segments\n    CString ShellGetRoot() const; \n    CPath   GetPath(bool includeRoot  = true) const;\n    CString GetName() const;\n    CString GetTitle() const;\n    CString GetExtension() const;\n    ERootType GetRootType(int * len = 0, bool greedy = true) const;\n    CString GetRoot(ERootType * rt = NULL, bool greedy = true) const;\n    CString SplitRoot(ERootType * rt = NULL);\n    int     GetDriveNumber();\n    TCHAR   GetDriveLetter();\n    //@}\n\n    //@{ \\name  Add / Modify / Remove parts\n    CPath & AddExtension(LPCTSTR extension, int len = -1);\n    CPath & RemoveExtension();\n    CPath & RenameExtension(LPCTSTR newExt);\n    CPath & RemoveFileSpec();\n    //@}\n\n\n    //@{ \\name Cleanup\n    CPath & Trim();\n    CPath & Unquote();\n    CPath & Canonicalize();\n    CPath & ShrinkXXLPath();\n    CPath & MakePretty();\n    CPath & Clean(DWORD cleanup = epc_Default);\n    //@}\n\n\n    //@{ \\name Extractors (with special \"packing\")\n    CString GetStr(DWORD packing = epp_Default) const;\n    _bstr_t GetBStr(DWORD packing = epp_Default) const;\n    //@}\n    \n    //@{ \\name Static checking (not accessing file system, see also GetRootType)\n    bool    IsValid() const;\n\n    bool    IsDot() const;\n    bool    IsDotDot() const;\n    bool    IsDotty() const;    // IsDot || IsDotDot\n\n    bool    MatchSpec(LPCTSTR spec);\n    bool    IsContentType(LPCTSTR contentType)  { return 0 != ::PathIsContentType(m_path, contentType); } ///< compare content type registered for this file, see also MSDN: PathIsContentType\n    bool    IsFileSpec()                { return 0 != ::PathIsFileSpec(m_path);         } ///< true if path does not contain backslash, see MSDN: PathIsFileSpec\n    bool    IsPrefix(LPCTSTR prefix)    { return 0 != ::PathIsPrefix(m_path, prefix);   } ///< checks if the path starts with a prefix like \"C:\\\\\", see MSDN: PathIsPrefix\n    bool    IsRelative()                { return 0 != ::PathIsRelative(m_path);         } ///< returns true if the path is relative, see MSDN: PathIsRelative\n    bool    IsRoot()                    { return 0 != ::PathIsRoot(m_path);             } ///< returns true if path is a directory root, see MSDN: PathIsRoot\n    bool    IsSameRoot(LPCTSTR other)   { return 0 != ::PathIsSameRoot(m_path, other);  } ///< returns true if the path has the same root as \\c otherPath, see MSDN: IsSameRoot\n\n    bool    IsUNC()                     { return 0 != ::PathIsUNC(m_path);              } ///< returns true if the path is a UNC specification, see MSDN: PathIsUNC\n    bool    IsUNCServer()               { return 0 != ::PathIsUNCServer(m_path);        } ///< returns true if the path is a UNC server specification, see MSDN: PathIsUNCServer\n    bool    IsUNCServerShare()          { return 0 != ::PathIsUNCServerShare(m_path);   } ///< returns true if the path is a UNC server + share specification, see MSDN: PathIsUNCServerShare\n    bool    IsURL()                     { return 0 != ::PathIsURL(m_path);              } ///< returns true if the path is an URL, see MSDN: PathIsURL\n\n//  bool    IsHTMLFile()                { return 0 != ::PathIsHTMLFile(m_path);         } ///< (missing?) true if content type registered for this file is HTML, see MSDN: PathIsHTMLFile\n//  bool    IsLFNFileSpec()             { return 0 != ::PathISLFNFileSpec(m_path);      } ///< (missing?) true if file is not a 8.3 file, see MSDN: PathIsLFNFileSpec\n//  bool    IsNetworkPath()             { return 0 != ::PathIsNetworkPath(m_path);      } ///< (missing?) returns true if the path is on a network,  see MSDN: PathIsNetworkPath\n\n    //@}\n\n\n    //@{ \\name Relative Paths\n    CPath   GetCommonPrefix(LPCTSTR secondPath);\n    CPath   RelativePathTo(LPCTSTR pathTo, bool srcIsDir = true);\n    bool    MakeRelative(CPath const & basePath);\n    bool    MakeAbsolute(CPath const & basePath);\n    //@}\n\n    //@{ \\name Dialog control operations\n    CString GetCompactStr(HDC dc, UINT dx, DWORD eppFlags = 0);\n    CString GetCompactStr(UINT cchMax, DWORD eppFlags = 0, DWORD flags = 0);\n    void    SetDlgItem(HWND dlg, UINT dlgCtrlID, DWORD eppFlags = 0);\n    //@}\n\n\n    //@{ \\name File System / Environment-Dependent operations\n    CPath & SearchAndQualify();\n    CPath & FindOnPath(LPCTSTR * additionalDirs = 0);\n    bool    Exists() const;\n    bool    IsDirectory() const;\n    bool    IsSystemFolder(DWORD attrib = FILE_ATTRIBUTE_SYSTEM) const;\n    CPath & MakeSystemFolder(bool make = true);\n    DWORD   GetAttributes();\n    bool    GetAttributes(WIN32_FILE_ATTRIBUTE_DATA & fad);\n    CPath & MakeFullPath(); \n    CPath & ExpandEnvStrings();\n    bool    EnvUnexpandRoot(LPCTSTR envVar);\n    bool    EnvUnexpandDefaultRoots();\n    long    ToRegistry(HKEY baseKey, LPCTSTR subkey, LPCTSTR name, bool replaceEnv = true);\n    //@}\n\n\n\n    \n\n// TODO: Shell 5.0 support\n// V5:    CPath & UnexpandEnvStrings();\n// V5:    LPCTSTR FindSuffixArray(LPCTSTR suffixes, int numSuffixes);\n// V5:    void    PathUndecorate();\n// V5:    CPath PathCreateFromURL(LPCTSTR path, DWORD dwReserved = 0);\n// V5:    bool    IsDirectoryEmpty() const;\n// might be useful for later extensions: PathGetCharType\n\n\n};\n\n// creation functions:\nCPath SplitArgs(CString const & path_args, CString * args = NULL, DWORD cleanup = epc_Default);\nCPath SplitIconLocation(CString const & path_icon, int * pIcon = NULL, DWORD cleanup = epc_Default);\nCPath BuildRoot(int driveNumber);\nCPath GetModuleFileName(HMODULE module = NULL);\nCPath GetCurrentDirectory();\nCPath FromRegistry(HKEY baseKey, LPCTSTR subkey, LPCTSTR name);\n\n\nCString ReplaceInvalid(CString const & str, TCHAR replaceChar = '_');\n\n\n// concatenation \n\ninline CPath operator & (CPath const & lhs, LPCTSTR rhs) { CPath ret = lhs; ret &= rhs; return ret; }\n\n\n\n\n\n\n\n// ---------------- INLIME IMPLEMENTATIONS ----------------------------------\n\n// ==============================================\n// GetFirstChar\n// ----------------------------------------------\n/// \\return [TCHAR]: the first char of the string, or 0 if the string length is 0.\n/// \\note The implementation takes care that the string is not copied when there are no spaces.\ninline TCHAR GetFirstChar(CString const & s)\n{\n    if (s.GetLength() == 0)\n        return 0;\n    else\n        return s[0];\n}\n\n// ==============================================\n// GetLastChar\n// ----------------------------------------------\n/// \\return [TCHAR]: the last character in the string, or 0 if the string length is 0.\n/// \\par Note\n/// \\b MBCS: if the string ends with a Multibyte character, this \n/// function returns the lead byte of the multibyte sequence.\ninline TCHAR GetLastChar(CString const & s)\n{\n    LPCTSTR pstr = s;\n    LPCTSTR pLastChar = _tcsdec(pstr, pstr + s.GetLength());\n    if (pLastChar == NULL)\n        return 0;\n    else \n        return *pLastChar;\n}\n\n\n\n\n\n} // namespace nsPath\n\n\n\n\n#endif // FILE_PH_PATH_H_200506202_INCLUDED_\n"
        },
        {
          "name": "PerfTimer.cpp",
          "type": "blob",
          "size": 0.9599609375,
          "content": "// CPerfTimer - a simple Win32 performance counter wrapper\n// by Dean Wyant dwyant@mindspring.com\n\n#include \"stdafx.h\"\n#include \"PerfTimer.h\"\n\n// Declare and initialize static member vars that get set only once and never change\n__int64 CPerfTimer::m_Freq = 0; \n__int64 CPerfTimer::m_Adjust = 0; \n\n// All functions defined inline for speed. After all, the performance counter is \n// supposed to be able to time very short events fairly accurately.\n\n\n\nBOOL CPerfTimer::IsSupported()\n{ // Returns FALSE if performance counter not supported.\n  // Call after constructing at least one CPerfTimer\n  return (m_Freq > 1);\n}\n\nconst double CPerfTimer::Resolution()   \n{ // Returns timer resolution in seconds\n  return 1.0/(double)m_Freq; \n}\n\nconst double CPerfTimer::Resolutionms() \n{ // Returns timer resolution in milliseconds\n  return 1000.0/(double)m_Freq; \n}\n\nconst double CPerfTimer::Resolutionus() \n{ // Returns timer resolution in microseconds\n  return 1000000.0/(double)m_Freq; \n}\n\n\n\n"
        },
        {
          "name": "PerfTimer.h",
          "type": "blob",
          "size": 9.4970703125,
          "content": "// CPerfTimer - a simple Win32 performance counter wrapper\n// by Dean Wyant dwyant@mindspring.com\n\n/*\n\n  This class is simple to use. Just declare a variable(s) as type CPerfTimer,\n  call Start() to start timimg and call Stop() to stop timimg. You can pause a\n  timer by calling Stop() and then you can call Start() to resume. Retrieve the\n  elapsed time by calling an Elapsed..() function. Assignment, addition, \n  subtraction and comparison are supported. There are a few information calls\n  available also. All calls except Start and Stop can be performed on a timer\n  without stopping it.\n  \n*/\n\n#ifndef __PERFTIMER_H__\n#define __PERFTIMER_H__\n\nclass CPerfTimer\n{\npublic:\n  CPerfTimer(BOOL bStart = FALSE) {Init(bStart);}\n\n  CPerfTimer(const CPerfTimer& Src); \n\n  virtual ~CPerfTimer() {;}\n\n  void Start(BOOL bReset = FALSE);   // Start from current value or optionally from 0\n  void Stop();                       // Stop timing. Use Start afterwards to continue.\n \n  BOOL IsRunning();                  // Returns FALSE if stopped.\n  \n  BOOL IsSupported();                // Returns FALSE if performance counter not supported.\n                                     // Call after constructing at least one CPerfTimer\n\n  const double Resolution();         // Returns timer resolution in seconds\n  const double Resolutionms();       // Returns timer resolution in milliseconds\n  const double Resolutionus();       // Returns timer resolution in microseconds\n  \n  const double Elapsed();            // Returns elapsed time in seconds\n  const double Elapsedms();          // Returns elapsed time in milliseconds \n  const double Elapsedus();          // Returns elapsed time in microseconds\n\n  const CPerfTimer& operator=(const CPerfTimer& Src); // Assignment operator \n\n  // Math operators\n  CPerfTimer operator+(const CPerfTimer& Src) const;\n\tCPerfTimer operator-(const CPerfTimer& Src) const;\n\tconst CPerfTimer& operator+=(const CPerfTimer& Src);\n\tconst CPerfTimer& operator-=(const CPerfTimer& Src);\n  // For time in seconds\n  CPerfTimer operator+(const double Secs) const;\n\tCPerfTimer operator-(const double Secs) const;\n\tconst CPerfTimer& operator+=(const double Secs);\n\tconst CPerfTimer& operator-=(const double Secs);\n\n  // Boolean comparison operators\n\tBOOL operator<(const CPerfTimer& Src);\n\tBOOL operator>(const CPerfTimer& Src);\n\tBOOL operator<=(const CPerfTimer& Src);\n\tBOOL operator>=(const CPerfTimer& Src);\n  // For time in seconds\n  BOOL operator<(const double Secs);\n\tBOOL operator>(const double Secs);\n\tBOOL operator<=(const double Secs);\n\tBOOL operator>=(const double Secs);\n\n  virtual void Lock() const {;}     // Override for thread safe operation\n  virtual void Unlock() const {;}     // Override for thread safe operation\nprotected:\n  void Init(BOOL bStart);\n  void Copy(const CPerfTimer& Src);\n\nprivate:\n  __int64 m_Start;\n  static __int64 m_Freq;   // does not change while system is running\n  static __int64 m_Adjust; // Adjustment time it takes to Start and Stop\n};\n\nclass CPerfTimerT : public CPerfTimer\n{ // You only need to use types of this class if a timer is going to be shared between threads\npublic:\n  CPerfTimerT(BOOL bStart = FALSE)\n  {\n    m_hMutex = CreateMutex(NULL, FALSE, _T(\"\"));\n    Init(bStart);\n  }\n\n  CPerfTimerT(const CPerfTimerT& Src) \n  { \n    m_hMutex = CreateMutex(NULL,FALSE,_T(\"\"));\n    Copy(Src); \n  }\n\n  CPerfTimerT(const CPerfTimer& Src) \n  { \n    m_hMutex = CreateMutex(NULL,FALSE,_T(\"\"));\n    Copy(Src); \n  }\n\n  virtual ~CPerfTimerT() \n  { CloseHandle(m_hMutex); }\n\n  const CPerfTimerT& operator=(const CPerfTimerT& Src) // Assignment operator \n  {\n    Copy(Src);\n    return *this; \n  }\n \n  virtual void Lock() const { WaitForSingleObject(m_hMutex,10000); }   \n  virtual void Unlock() const { ReleaseMutex(m_hMutex); }   \nprivate:\n  HANDLE m_hMutex;\n};\n\ninline void CPerfTimer::Init(BOOL bStart)\n{\n  if (!m_Freq) \n  { // Initialization should only run once\n    QueryPerformanceFrequency((LARGE_INTEGER *)&m_Freq); \n    if (!m_Freq)\n      m_Freq = 1; // Timer will be useless but will not cause divide by zero\n    m_Start = 0; \n    m_Adjust = 0; \n    Start();            // Time a Stop\n    Stop(); \n    m_Adjust = m_Start;\n  }\n  // This is the only part that normally runs\n  m_Start = 0; \n  if (bStart)\n    Start(); \n}\n\ninline CPerfTimer::CPerfTimer(const CPerfTimer& Src)  \n{\n  Copy(Src);\n}\n\ninline void CPerfTimer::Copy(const CPerfTimer& Src)\n{\n  if (&Src == this) \n    return; // avoid deadlock if someone tries to copy it to itself\n  Src.Lock();\n  Lock();\n  m_Start = Src.m_Start; \n  Unlock();\n  Src.Unlock();\n}\n\ninline void CPerfTimer::Start(BOOL bReset) \n{ // Start from current value or optionally from 0\n  __int64 i;\n  QueryPerformanceCounter((LARGE_INTEGER *)&i);\n  Lock();\n  if ((!bReset) && (m_Start < 0))\n    m_Start += i;   // We are starting with an accumulated time\n  else \n    m_Start = i;    // Starting from 0\n  Unlock();\n} \n\ninline void CPerfTimer::Stop() \n{ // Stop timing. Use Start afterwards to continue\n  Lock();\n  if (m_Start <= 0)\n  {\n    Unlock();\n    return;          // Was not running\n  }\n  __int64 i;\n  QueryPerformanceCounter((LARGE_INTEGER *)&i); \n  m_Start += -i;          // Stopped timer keeps elapsed timer ticks as a negative \n  if (m_Start < m_Adjust) // Do not overflow\n    m_Start -= m_Adjust;  // Adjust for time timer code takes to run\n  else \n    m_Start = 0;          // Stop must have been called directly after Start\n  Unlock();\n} \n\ninline BOOL CPerfTimer::IsRunning() \n{ // Returns FALSE if stopped.\n  Lock();\n  BOOL bRet = (m_Start > 0); // When < 0, holds elpased clicks\n  Unlock();\n  return bRet;   \n}\n inline const double CPerfTimer::Elapsed()\n{ // Returns elapsed time in seconds\n  CPerfTimer Result(*this);\n  Result.Stop();\n  return (double)(-Result.m_Start)/(double)m_Freq; \n}\n\ninline const double CPerfTimer::Elapsedms() \n{ // Returns elapsed time in milliseconds\n  CPerfTimer Result(*this);\n  Result.Stop();\n  return (-Result.m_Start*1000.0)/(double)m_Freq; \n}\n\ninline const double CPerfTimer::Elapsedus() \n{ // Returns elapsed time in microseconds\n  CPerfTimer Result(*this);\n  Result.Stop();\n  return (-Result.m_Start * 1000000.0)/(double)m_Freq; \n}\n\n\n// Assignment operator\ninline const CPerfTimer& CPerfTimer::operator=(const CPerfTimer& Src) \n{\n  Copy(Src);\n  return *this; \n}\n\n\n// Math operators\ninline CPerfTimer CPerfTimer::operator+(const CPerfTimer& Src) const\n{\n  CPerfTimer Result(*this);\n  Result += Src; \n  return Result; \n}\n\ninline CPerfTimer CPerfTimer::operator-(const CPerfTimer& Src) const\n{\n  CPerfTimer Result(*this);\n  Result -= Src; \n  return Result; \n}\n\ninline const CPerfTimer& CPerfTimer::operator+=(const CPerfTimer& Src)\n{\n  CPerfTimer SrcStop(Src);  // Temp is necessary in case Src is not stopped\n  SrcStop.Stop();\n  Lock();\n  m_Start += SrcStop.m_Start;\n  Unlock();\n  return *this; \n}\n\ninline const CPerfTimer& CPerfTimer::operator-=(const CPerfTimer& Src)\n{\n  CPerfTimer SrcStop(Src);  // Temp is necessary in case Src is not stopped\n  SrcStop.Stop();\n  Lock();\n  m_Start -= SrcStop.m_Start; \n  Unlock();\n  return *this; \n}\n\n// For time in seconds\ninline CPerfTimer CPerfTimer::operator+(const double Secs) const\n{\n  CPerfTimer Result(*this);\n  Result += Secs; \n  return Result; \n}\n\ninline CPerfTimer CPerfTimer::operator-(const double Secs) const\n{\n  CPerfTimer Result(*this);\n  Result += Secs; \n  return Result; \n}\n\ninline const CPerfTimer& CPerfTimer::operator+=(const double Secs)\n{\n  Lock();\n  m_Start -= (__int64)(Secs*(double)m_Freq);\n  Unlock();\n  return *this; \n}\n\ninline const CPerfTimer& CPerfTimer::operator-=(const double Secs)\n{\n  Lock();\n  m_Start += (__int64)(Secs*(double)m_Freq);\n  Unlock();\n  return *this; \n}\n\n\n\n// Boolean comparison operators\ninline BOOL CPerfTimer::operator<(const CPerfTimer& Src)\n{ \n  BOOL bRet; \n  CPerfTimer Temp(Src);\n  Lock();\n  if (m_Start <= 0)\n  {\n    Temp.Stop();\n    bRet = (m_Start > Temp.m_Start); \n    Unlock();\n    return bRet;\n  }\n  else\n  if (Temp.m_Start > 0)\n  {\n    bRet = (m_Start < Temp.m_Start); \n    Unlock();\n    return bRet;\n  }\n  else\n  {\n    Unlock();\n    CPerfTimer ThisStop(*this);\n    ThisStop.Stop();\n    return (ThisStop.m_Start > Temp.m_Start); \n  }\n}\n\ninline BOOL CPerfTimer::operator>(const CPerfTimer& Src)\n{ \n  BOOL bRet; \n  CPerfTimer Temp(Src);\n  Lock();\n  if (m_Start <= 0)\n  {\n    Temp.Stop();\n    bRet = (m_Start < Temp.m_Start); \n    Unlock();\n    return bRet;\n  }\n  else\n  if (Temp.m_Start > 0)\n  {\n    bRet = (m_Start > Temp.m_Start); \n    Unlock();\n    return bRet;\n  }\n  else\n  {\n    Unlock();\n    CPerfTimer ThisStop(*this);\n    ThisStop.Stop();\n    return (ThisStop.m_Start < Temp.m_Start); \n  }\n}\n\ninline BOOL CPerfTimer::operator<=(const CPerfTimer& Src)\n{ \n  return !(*this > Src);\n}\n\ninline BOOL CPerfTimer::operator>=(const CPerfTimer& Src)\n{ \n  return !(*this < Src);\n}\n\n// For time in seconds\ninline BOOL CPerfTimer::operator<(const double Secs)\n{ \n  BOOL bRet; \n  Lock();\n  if (m_Start <= 0)\n  {\n    bRet = (m_Start > (__int64)(-Secs*(double)m_Freq)); \n    Unlock();\n    return bRet;\n  }\n  else\n  {\n    Unlock();\n    CPerfTimer ThisStop(*this);\n    ThisStop.Stop();\n    return (ThisStop.m_Start > (__int64)(-Secs*(double)m_Freq)); \n  }\n}\n\ninline BOOL CPerfTimer::operator>(const double Secs)\n{ \n  BOOL bRet; \n  Lock();\n  if (m_Start <= 0)\n  {\n    bRet = (m_Start < (__int64)(-Secs*(double)m_Freq)); \n    Unlock();\n    return bRet;\n  }\n  else\n  {\n    Unlock();\n    CPerfTimer ThisStop(*this);\n    ThisStop.Stop();\n    return (ThisStop.m_Start < (__int64)(-Secs*(double)m_Freq)); \n  }\n}\n\ninline BOOL CPerfTimer::operator<=(const double Secs)\n{ \n  return !(*this > Secs);\n}\n\ninline BOOL CPerfTimer::operator>=(const double Secs)\n{ \n  return !(*this < Secs);\n}\n\n\n#endif //__PERFTIMER_H__"
        },
        {
          "name": "Popup.cpp",
          "type": "blob",
          "size": 5.275390625,
          "content": "//feature x 2\n#include \"stdafx.h\"\n#include \"Popup.h\"\n#include \"Misc.h\"\n\n//feature x\n//test\n\nvoid InitToolInfo( TOOLINFO& ti )\n{\n\t//main branch change\n\t// INITIALIZE MEMBERS OF THE TOOLINFO STRUCTURE\n\tti.cbSize = TTTOOLINFO_V1_SIZE;\n\tti.uFlags = TTF_ABSOLUTE | TTF_TRACK;\n\tti.hwnd = NULL;\n\tti.hinst = NULL;\n\tti.uId = 0; // CPopup only uses uid 0\n\tti.lpszText = NULL;\n\t// ToolTip control will cover the whole window\n\tti.rect.left = 0;\n\tti.rect.top = 0;\n\tti.rect.right = 0;\n\tti.rect.bottom = 0;\n}\n\n/*------------------------------------------------------------------*\\\nCPopup - a tooltip that pops up manually (when Show is called).\n- technique learned from codeproject \"ToolTipZen\" by \"Zarembo Maxim\"\n\\*------------------------------------------------------------------*/\n\nCPopup::CPopup()\n{\n\tInit();\n}\n\n// HWND_TOP\nCPopup::CPopup( int x, int y, HWND hWndPosRelativeTo, HWND hWndInsertAfter )\n{\n\tInit();\n\tm_hWndPosRelativeTo = hWndPosRelativeTo;\n\tm_hWndInsertAfter = hWndInsertAfter;\n\tSetPos( CPoint(x,y) );\n}\n\nCPopup::~CPopup()\n{\n\tHide();\n\tif( m_bOwnTT && ::IsWindow(m_hTTWnd) )\n\t\t::DestroyWindow( m_hTTWnd );\n}\n\nvoid CPopup::Init()\n{\n\t// initialize variables\n\tm_bOwnTT = false;\n\tm_hTTWnd = NULL;\n\tm_bIsShowing = false;\n\tm_bAllowShow = true; // used by AllowShow()\n\t\n\tm_Pos.x = m_Pos.y = 0;\n\tm_bTop = true;\n\tm_bLeft = true;\n\tm_bCenterX = false;\n\tm_bCenterY = false;\n\tm_hWndPosRelativeTo = NULL;\n\t\n\tm_ScreenMaxX = GetSystemMetrics(SM_CXVIRTUALSCREEN);\n\tm_ScreenMaxY = GetSystemMetrics(SM_CYVIRTUALSCREEN);\n\t\n\tm_hWndInsertAfter = HWND_TOP; //HWND_TOPMOST\n\t\n\tSetTTWnd();\n}\n\nvoid CPopup::SetTTWnd( HWND hTTWnd, TOOLINFO* pTI )\n{\n\tif( pTI )\n\t\tm_TI = *pTI;\n\telse\n\t\tInitToolInfo( m_TI );\n\t\n\tif( m_bOwnTT && ::IsWindow(m_hTTWnd) )\n\t{\n\t\tif( !::IsWindow(hTTWnd) )\n\t\t\treturn; // we would have to recreate the one that already exists\n\t\t::DestroyWindow( m_hTTWnd );\n\t}\n\t\n\tm_hTTWnd = hTTWnd;\n\tif( ::IsWindow(m_hTTWnd) )\n\t{\n\t\tm_bOwnTT = false;\n\t\t// if our uid tooltip already exists, get the data, else add it.\n\t\tif( ! ::SendMessage(m_hTTWnd, TTM_GETTOOLINFO, 0, (LPARAM)(LPTOOLINFO) &m_TI) )\n\t\t\t::SendMessage(m_hTTWnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &m_TI);\n\t}\n\telse\n\t{\n\t\tm_bOwnTT = true;\n\t\tCreateToolTip();\n\t}\n}\n\nvoid CPopup::CreateToolTip()\n{\n\tif( m_hTTWnd != NULL )\n\t\treturn;\n\t\n\t// CREATE A TOOLTIP WINDOW\n\tm_hTTWnd = CreateWindowEx(\n\t\tWS_EX_TOPMOST,\n\t\tTOOLTIPS_CLASS,\n\t\tNULL,\n\t\tTTS_NOPREFIX | TTS_ALWAYSTIP,\t\t\n\t\tCW_USEDEFAULT,\n\t\tCW_USEDEFAULT,\n\t\tCW_USEDEFAULT,\n\t\tCW_USEDEFAULT,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL\n\t\t);\n\tm_bOwnTT = true;\n\t\n\t// SEND AN ADDTOOL MESSAGE TO THE TOOLTIP CONTROL WINDOW\n\t::SendMessage(m_hTTWnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &m_TI);\n}\n\nvoid CPopup::SetTimeout( int timeout )\n{\n\tif( m_hTTWnd == NULL )\n\t\treturn;\n\t::SendMessage(m_hTTWnd, TTM_SETDELAYTIME, TTDT_AUTOMATIC, timeout);\n}\n\nvoid CPopup::SetPos( CPoint& pos )\n{\n\tm_Pos = pos;\n}\n\nvoid CPopup::SetPosInfo( bool bTop, bool bCenterY, bool bLeft, bool bCenterX )\n{\n\tm_bTop = bTop;\n\tm_bCenterY = bCenterY;\n\tm_bLeft = bLeft;\n\tm_bCenterX = bCenterX;\n}\n\nvoid CPopup::AdjustPos( CPoint& pos )\n{\n\tCRect rel(0,0,0,0);\n\tCRect rect(0,0,0,0);\n\t\n\t//\t::SendMessage(m_hTTWnd, TTM_ADJUSTRECT, TRUE, (LPARAM)&rect);\n\t::GetWindowRect(m_hTTWnd,&rect);\n\t\n\tif( ::IsWindow(m_hWndPosRelativeTo) )\n\t\t::GetWindowRect(m_hWndPosRelativeTo, &rel);\n\t\n\t// move the rect to the relative origin\n\trect.bottom = rect.Height() + rel.top;\n\trect.top = rel.top;\n\trect.right = rect.Width() + rel.left;\n\trect.left = rel.left;\n\t\n\t// adjust the y position\n\trect.OffsetRect( 0, pos.y - (m_bCenterY? rect.Height()/2: (m_bTop? 0: rect.Height())) );\n\tif( rect.bottom > m_ScreenMaxY )\n\t\trect.OffsetRect( 0, m_ScreenMaxY - rect.bottom );\n\t\n\t// adjust the x position\n\trect.OffsetRect( pos.x - (m_bCenterX? rect.Width()/2: (m_bLeft? 0: rect.Width())), 0 );\n\tif( rect.right > m_ScreenMaxX )\n\t\trect.OffsetRect( m_ScreenMaxX - rect.right, 0 );\n\t\n\tpos.x = rect.left;\n\tpos.y = rect.top;\n}\n\nvoid CPopup::SendToolTipText( CString text )\n{\n\tm_csToolTipText = text;\n\t\n\t//Replace the tabs with spaces, the tooltip didn't like the \\t s\n\ttext.Replace(_T(\"\\t\"), _T(\"  \"));\n\tm_TI.lpszText = (LPTSTR) (LPCTSTR) text;\n\t\n\t// this allows \\n and \\r to be interpreted correctly\n\t::SendMessage(m_hTTWnd, TTM_SETMAXTIPWIDTH, 0, 500);\n\t// set the text\n\t::SendMessage(m_hTTWnd, TTM_SETTOOLINFO, 0, (LPARAM) (LPTOOLINFO) &m_TI);\n}\n\nvoid CPopup::Show( CString text, CPoint pos, bool bAdjustPos )\n{\n\tif( m_hTTWnd == NULL )\n\t\treturn;\n\n\tm_csToolTipText = text;\n\t\n\tif( !m_bIsShowing )\n\t\t::SendMessage(m_hTTWnd, TTM_TRACKPOSITION, 0, (LPARAM)(DWORD) MAKELONG(-10000,-10000));\n\t\n\tSendToolTipText( text );\n\t::SendMessage(m_hTTWnd, TTM_TRACKACTIVATE, true, (LPARAM)(LPTOOLINFO) &m_TI);\n\tif( bAdjustPos )\n\t\tAdjustPos(pos);\n\t// set the position\n\t::SendMessage(m_hTTWnd, TTM_TRACKPOSITION, 0, (LPARAM)(DWORD) MAKELONG(pos.x,pos.y));\n\t\n\t// make sure the tooltip will be on top.\n\t::SetWindowPos( m_hTTWnd, m_hWndInsertAfter, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE );\n\t\n\tm_bIsShowing = true;\n}\n\nvoid CPopup::Show( CString text )\n{ \n\tm_csToolTipText = text;\n\tShow( text, m_Pos ); \n}\n\nvoid CPopup::AllowShow( CString text )\n{\n\tm_csToolTipText = text;\n\t\n\tif( m_bAllowShow )\n\t\tShow( text, m_Pos );\n}\n\nvoid CPopup::Hide()\n{\n\tif( m_hTTWnd == NULL )\n\t\treturn;\n\t// deactivate if it is currently activated\n\t::SendMessage(m_hTTWnd, TTM_TRACKACTIVATE, FALSE, (LPARAM)(LPTOOLINFO) &m_TI);\n\tm_bIsShowing = false;\n}"
        },
        {
          "name": "Popup.h",
          "type": "blob",
          "size": 1.5888671875,
          "content": "#pragma once\n/*------------------------------------------------------------------*\\\n\tCPopup - a tooltip that pops up manually (when Show is called).\n\t- technique learned from codeproject \"ToolTipZen\" by \"Zarembo Maxim\"\n\\*------------------------------------------------------------------*/\n\nvoid InitToolInfo( TOOLINFO& ti ); // initializes toolinfo with uid 0\n\nclass CPopup\n{\npublic:\n\tbool m_bOwnTT;\n\n\tHWND m_hTTWnd; // handle to the ToolTip control\n\tTOOLINFO m_TI; // struct specifying info about tool in ToolTip control\n\n\tbool m_bIsShowing;\n\n\tbool m_bTop;  // true if m_Pos.x is the top, false if the bottom\n\tbool m_bLeft; // true if m_Pos.y is the left, false if the right\n\tbool m_bCenterY; // true if m_Pos is the y center, false if corner\n\tbool m_bCenterX; // true if m_Pos is the x center, false if corner\n\tHWND m_hWndPosRelativeTo;\n\tCPoint m_Pos;\n\n\tint m_ScreenMaxX;\n\tint m_ScreenMaxY;\n\n\tHWND m_hWndInsertAfter;\n\n\tbool m_bAllowShow; // used by SafeShow to determine whether to show or not\n\n\tCString m_csToolTipText;\n\n\tCPopup();\n\tCPopup( int x, int y, HWND hWndPosRelativeTo = NULL, HWND hWndInsertAfter = HWND_TOP );\n\t~CPopup();\n\n\tvoid Init();\n\tvoid SetTTWnd( HWND hTTWnd = NULL, TOOLINFO* pTI = NULL );\n\tvoid CreateToolTip();\n\n\tvoid SetTimeout( int timeout );\n\n\tvoid AdjustPos( CPoint& pos );\n\tvoid SetPos( CPoint& pos );\n\tvoid SetPosInfo( bool bTop, bool bCenterY, bool bLeft, bool bCenterX );\n\n\tvoid SendToolTipText( CString text );\n\n\tvoid Show( CString text, CPoint pos, bool bAdjustPos = true );\n\tvoid Show( CString text );\n\tvoid AllowShow( CString text ); // only shows if m_bAllowShow is true\n\n\tvoid Hide();\n};\n\n"
        },
        {
          "name": "PowerManager.cpp",
          "type": "blob",
          "size": 2.095703125,
          "content": "#include \"stdafx.h\"\r\n#include \"PowerManager.h\"\r\n#include \"Misc.h\"\r\n\r\nstatic HWND s_notifyHwnd;\r\nstatic ULONG PowerChanged(PVOID Context, ULONG Type, PVOID Setting);\r\n\r\nULONG PowerChanged(PVOID Context, ULONG Type, PVOID Setting)\r\n{\r\n\t//a\r\n\t//b\r\n\t//c\r\n\tCString cs;\r\n\tcs.Format(_T(\"PowerChanged Type %d\"), Type);\r\n\tLog(cs);\r\n\r\n\tif(Type == PBT_APMRESUMEAUTOMATIC)\r\n\t{\r\n\t\t//had reports of the main window not showing clips after resuming (report was from a vmware vm), catch the resuming callback from windows\r\n\t\t//and close and reopen the database\r\n\t\tLog(_T(\"windows is RESUMING, sending message to main window to close and reopen the database/qpastewnd\"));\r\n\t\t::PostMessage(s_notifyHwnd, WM_REOPEN_DATABASE, 0, 0);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n\r\nCPowerManager::CPowerManager()\r\n{\r\n\tm_registrationHandle = 0;\r\n}\r\n\r\n\r\nCPowerManager::~CPowerManager(void)\r\n{\r\n}\r\n\r\n\r\nvoid CPowerManager::Start(HWND hWnd)\r\n{\r\n\ts_notifyHwnd = hWnd;\r\n\r\n\tHMODULE powrprof = LoadLibrary( _T(\"powrprof.dll\") );\r\n\tif( powrprof != NULL )\r\n\t{\r\n\t\tDWORD (_stdcall*PowerRegisterSuspendResumeNotification)(_In_ DWORD,_In_ HANDLE,_Out_ PHPOWERNOTIFY);\n\t\tPowerRegisterSuspendResumeNotification = (DWORD(_stdcall*)(_In_ DWORD,_In_ HANDLE,_Out_ PHPOWERNOTIFY))GetProcAddress(powrprof, \"PowerRegisterSuspendResumeNotification\");\n\t\tif(PowerRegisterSuspendResumeNotification)\n\t\t{\r\n\t\t\tstatic _DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS testCallback = {PowerChanged, nullptr};\r\n\r\n\t\t\tPowerRegisterSuspendResumeNotification(DEVICE_NOTIFY_CALLBACK, &testCallback, &m_registrationHandle); \r\n\t\t}\r\n\r\n\t\t::FreeLibrary(powrprof);\r\n\t}\r\n}\r\n\r\nvoid CPowerManager::Close()\r\n{\t\r\n\tif(m_registrationHandle != 0)\r\n\t{\r\n\t\tHMODULE powrprof = LoadLibrary( _T(\"powrprof.dll\") );\r\n\t\tif( powrprof != NULL )\r\n\t\t{\r\n\t\t\tDWORD (_stdcall*PowerUnregisterSuspendResumeNotification)(_Inout_ PHPOWERNOTIFY);\n\t\t\tPowerUnregisterSuspendResumeNotification = (DWORD(_stdcall*)(_Inout_ PHPOWERNOTIFY))GetProcAddress(powrprof, \"PowerUnregisterSuspendResumeNotification\");\n\t\t\tif(PowerUnregisterSuspendResumeNotification)\n\t\t\t{\r\n\t\t\t\tPowerUnregisterSuspendResumeNotification(&m_registrationHandle); \r\n\t\t\t}\r\n\r\n\t\t\t::FreeLibrary(powrprof);\r\n\t\t}\r\n\t}\r\n}"
        },
        {
          "name": "PowerManager.h",
          "type": "blob",
          "size": 0.6689453125,
          "content": "#pragma once\n\n#define DEVICE_NOTIFY_CALLBACK 2\n\ntypedef\n\tULONG\n\tDEVICE_NOTIFY_CALLBACK_ROUTINE (\n\t_In_opt_ PVOID Context,\n\t_In_ ULONG Type,\n\t_In_ PVOID Setting\n\t);\ntypedef DEVICE_NOTIFY_CALLBACK_ROUTINE* PDEVICE_NOTIFY_CALLBACK_ROUTINE;\n\ntypedef struct _DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS {\n\tPDEVICE_NOTIFY_CALLBACK_ROUTINE Callback;\n\tPVOID Context;\n} DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS, *PDEVICE_NOTIFY_SUBSCRIBE_PARAMETERS;\n\ntypedef  PVOID           HPOWERNOTIFY;\ntypedef  HPOWERNOTIFY   *PHPOWERNOTIFY;\n\nclass CPowerManager\n{\npublic:\n\tCPowerManager();\n\t~CPowerManager(void);\n\n\tvoid Start(HWND hWnd);\n\tvoid CPowerManager::Close();\n\nprotected:\n\tHPOWERNOTIFY m_registrationHandle;\n};\n\n"
        },
        {
          "name": "ProcessCopy.cpp",
          "type": "blob",
          "size": 29.2978515625,
          "content": "// ProcessCopy.cpp: implementation of the CProcessCopy class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"ProcessCopy.h\"\n#include \"DatabaseUtilities.h\"\n#include \".\\processcopy.h\"\n\n#include <Mmsystem.h>\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n\n/*----------------------------------------------------------------------------*\\\nCOleDataObjectEx\n\\*----------------------------------------------------------------------------*/\n\nHGLOBAL COleDataObjectEx::GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)\n{\n    HGLOBAL hGlobal = COleDataObject::GetGlobalData(cfFormat, lpFormatEtc);\n\tif( hGlobal )\n\t{\n\t\tif( !::IsValid(hGlobal) )\n\t\t{\n\t\t\tLOG( StrF(\n\t\t\t\t\"COleDataObjectEx::GetGlobalData(\\\"%s\\\"): ERROR: Invalid (NULL) data returned.\",\n\t\t\t\tGetFormatName(cfFormat) ) );\n\t\t\t::GlobalFree( hGlobal );\n\t\t\thGlobal = NULL;\n\t\t}\n\t\treturn hGlobal;\n\t}\n\t\n\t// The data isn't in global memory, so try getting an IStream interface to it.\n\tSTGMEDIUM stg;\n\t\n\tif( !GetData(cfFormat, &stg) )\n\t{\n\t\treturn 0;\n\t}\n\t\n\tswitch(stg.tymed)\n\t{\n\tcase TYMED_HGLOBAL:\n\t\thGlobal = stg.hGlobal;\n\t\tbreak;\n\t\t\n\tcase TYMED_ISTREAM:\n\t\t{\n\t\t\tUINT            uDataSize;\n\t\t\tLARGE_INTEGER\tli;\n\t\t\tULARGE_INTEGER\tuli;\n\t\t\t\n\t\t\tli.HighPart = li.LowPart = 0;\n\t\t\t\n\t\t\tif ( SUCCEEDED( stg.pstm->Seek ( li, STREAM_SEEK_END, &uli )))\n\t\t\t{\n\t\t\t\thGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, uli.LowPart );\n\t\t\t\t\n\t\t\t\tvoid* pv = GlobalLock(hGlobal);\n\t\t\t\tstg.pstm->Seek(li, STREAM_SEEK_SET, NULL);\n\t\t\t\tHRESULT result = stg.pstm->Read(pv, uli.LowPart, (PULONG)&uDataSize);\n\t\t\t\tGlobalUnlock(hGlobal);\n\t\t\t\t\n\t\t\t\tif( FAILED(result) )\n\t\t\t\t\thGlobal = GlobalFree(hGlobal);\n\t\t\t}\n\t\t\tbreak;  // case TYMED_ISTREAM\n\t\t}\n\t} // end switch\n\t\n\tReleaseStgMedium(&stg);\n\t\n\tif( hGlobal && !::IsValid(hGlobal) )\n\t{\n\t\tLOG( StrF(\n\t\t\t\"COleDataObjectEx::GetGlobalData(\\\"%s\\\"): ERROR: Invalid (NULL) data returned.\",\n\t\t\tGetFormatName(cfFormat) ) );\n\t\t::GlobalFree( hGlobal );\n\t\thGlobal = NULL;\n\t}\n\t\n\treturn hGlobal;\n}\n\n/*----------------------------------------------------------------------------*\\\nCClipFormat - holds the data of one clip format.\n\\*----------------------------------------------------------------------------*/\nCClipFormat::CClipFormat(CLIPFORMAT cfType, HGLOBAL hgData)\n{\n\tm_cfType = cfType;\n\tm_hgData = hgData;\n\tbDeleteData = true;\n}\n\nCClipFormat::~CClipFormat() \n{ \n\tFree(); \n}\n\nvoid CClipFormat::Clear()\n{\n\tm_cfType = 0;\n\tm_hgData = 0;\n}\n\nvoid CClipFormat::Free()\n{\n\tif(bDeleteData)\n\t{\n\t\tif(m_hgData)\n\t\t{\n\t\t\tm_hgData = ::GlobalFree( m_hgData );\n\t\t\tm_hgData = NULL;\n\t\t}\n\t}\n}\n\n\n\n/*----------------------------------------------------------------------------*\\\nCClipFormats - holds an array of CClipFormat\n\\*----------------------------------------------------------------------------*/\n// returns a pointer to the CClipFormat in this array which matches the given type\n//  or NULL if that type doesn't exist in this array.\nCClipFormat* CClipFormats::FindFormat( UINT cfType )\n{\n\tCClipFormat* pCF;\n\tint count = GetSize();\n\tfor( int i=0; i < count; i++ )\n\t{\n\t\tpCF = &ElementAt(i);\n\t\tif( pCF->m_cfType == cfType )\n\t\t\treturn pCF;\n\t}\n\treturn NULL;\n}\n\n\n/*----------------------------------------------------------------------------*\\\nCClip - holds multiple CClipFormats and CopyClipboard() statistics\n\\*----------------------------------------------------------------------------*/\n\nCClip::CClip() : \nm_ID(0), \nm_DataID(0), \nm_lTotalCopySize(0)\n{\n}\n\nCClip::~CClip()\n{\n\tEmptyFormats();\n}\n\nvoid CClip::Clear()\n{\n\tm_ID = 0;\n\tm_Time = 0;\n\tm_Desc = \"\";\n\tm_lTotalCopySize = 0;\n\tm_DataID = 0;\n\tEmptyFormats();\n}\n\nconst CClip& CClip::operator=(const CClip &clip)\n{\n\tconst CClipFormat* pCF;\n\n\tm_ID = clip.m_ID;\n\tm_DataID = clip.m_DataID;\n\tm_Time = clip.m_Time;\n\tm_lTotalCopySize = clip.m_lTotalCopySize;\n\n\tint nCount = clip.m_Formats.GetSize();\n\t\n\tfor(int i = 0; i < nCount; i++)\n\t{\n\t\tpCF = &clip.m_Formats.GetData()[i];\n\n\t\tLPVOID pvData = GlobalLock(pCF->m_hgData);\n\t\tif(pvData)\n\t\t{\n\t\t\tAddFormat(pCF->m_cfType, pvData, GlobalSize(pCF->m_hgData));\n\t\t}\n\t\tGlobalUnlock(pCF->m_hgData);\n\t}\n\n\t//Set this after since in could get the wrong description in AddFormat\n\tm_Desc = clip.m_Desc;\n\n\treturn *this;\n}\n\nvoid CClip::EmptyFormats()\n{\n\t// free global memory in m_Formats\n\tfor( int i = m_Formats.GetSize()-1; i >= 0; i-- )\n\t{\n\t\tm_Formats[i].Free();\n\t\tm_Formats.RemoveAt( i );\n\t}\n}\n\n// Adds a new Format to this Clip by copying the given data.\nbool CClip::AddFormat( CLIPFORMAT cfType, void* pData, UINT nLen )\n{\n\tASSERT( pData && nLen );\n\tHGLOBAL hGlobal = ::NewGlobalP( pData, nLen );\n\tASSERT( hGlobal );\n\t// update the Clip statistics\n\tm_Time = m_Time.GetCurrentTime();\n\tm_lTotalCopySize += nLen;\n\tif( !SetDescFromText( hGlobal ) )\n\t\tSetDescFromType();\n\t\n\tCClipFormat format(cfType,hGlobal);\n\tCClipFormat *pFormat;\n\t\n\tpFormat = m_Formats.FindFormat(cfType);\n\t// if the format type already exists as part of this clip, replace the data\n\tif( pFormat )\n\t{\n\t\tpFormat->Free();\n\t\tpFormat->m_hgData = format.m_hgData;\n\t}\n\telse\n\t\tm_Formats.Add(format);\n\t\n\tformat.m_hgData = 0; // now owned by m_Formats\n\treturn true;\n}\n\n#define EXIT_LoadFromClipboard(ret)\t{ oleData.Release(); g_bCopyingClipboard = false; return(ret); }\nbool g_bCopyingClipboard = false; // for debugging reentrance\n// Fills this CClip with the contents of the clipboard.\nbool CClip::LoadFromClipboard( CClipTypes* pClipTypes )\n{\n\tCOleDataObjectEx oleData;\n\tCClipTypes defaultTypes;\n\tCClipTypes* pTypes = pClipTypes;\n\t\n\t//ASSERT( !g_bCopyingClipboard );\n\t// For some reason, this can actually happen with *very* fast copies.\n\t// This is probably due to the OLE functions processing messages.\n\t// This *might* be able to be avoided by directly using the win32 Clipboard API\n\t// If this does happen, we just ignore the request by returning failure.\n\tif( g_bCopyingClipboard )\n\t\treturn false;\n\t\n\tg_bCopyingClipboard = true;\n\t\n\t// m_Formats should be empty when this is called.\n\tASSERT( m_Formats.GetSize() == 0 );\n\t\n\t// If the data is supposed to be private, then return\n\tif( ::IsClipboardFormatAvailable( theApp.m_cfIgnoreClipboard ) )\n\t\tEXIT_LoadFromClipboard( false );\n\t\n\t//Attach to the clipboard\n\tif( !oleData.AttachClipboard() )\n\t{\n\t\tASSERT(0); // does this ever happen?\n\t\tEXIT_LoadFromClipboard(false);\n\t}\n\t\n\toleData.EnsureClipboardObject();\n\t\n\t// if no types were given, get only the first (most important) type.\n\t//  (subsequent types could be synthetic due to automatic type conversions)\n\tif( pTypes == NULL || pTypes->GetSize() == 0 )\n\t{\n\t\tASSERT(0); // this feature is not currently used... it is an error if it is.\n\t\t\n\t\tFORMATETC formatEtc;\n\t\toleData.BeginEnumFormats();\n\t\toleData.GetNextFormat(&formatEtc);\n\t\tdefaultTypes.Add( formatEtc.cfFormat );\n\t\tpTypes = &defaultTypes;\n\t}\n\t\n\t// reset copy stats\n\tm_lTotalCopySize = 0;\n\tm_Desc = \"[Ditto Error] BAD DESCRIPTION\";\n\t\n\t// Get Description String\n\t// NOTE: We make sure that the description always corresponds to the\n\t//  data saved by using the exact same globalmem instance as the source\n\t//  for both... i.e. we only fetch the description format type once.\n\tCClipFormat cfDesc;\n\tbool bIsDescSet = false;\n\tcfDesc.m_cfType = CF_TEXT;\n\tif( oleData.IsDataAvailable( cfDesc.m_cfType ) )\n\t{\n\t\tcfDesc.m_hgData = oleData.GetGlobalData( cfDesc.m_cfType );\n\t\tbIsDescSet = SetDescFromText( cfDesc.m_hgData );\n\t}\n\t\n\t// Get global data for each supported type on the clipboard\n\tUINT nSize;\n\tCClipFormat cf;\n\tint numTypes = pTypes->GetSize();\n\tfor(int i = 0; i < numTypes; i++)\n\t{\n\t\tcf.m_cfType = pTypes->ElementAt(i);\n\t\t\n\t\t// is this the description we already fetched?\n\t\tif( cf.m_cfType == cfDesc.m_cfType )\n\t\t{\n\t\t\tcf = cfDesc;\n\t\t\tcfDesc.m_hgData = 0; // cf owns it now (to go into m_Formats)\n\t\t}\n\t\telse if( !oleData.IsDataAvailable(cf.m_cfType) )\n\t\t\tcontinue;\n\t\telse\n\t\t\tcf.m_hgData = oleData.GetGlobalData( cf.m_cfType );\n\t\t\n\t\tif( cf.m_hgData )\n\t\t{\n\t\t\tnSize = GlobalSize( cf.m_hgData );\n\t\t\tif( nSize > 0 )\n\t\t\t{\n\t\t\t\tif(g_Opt.m_lMaxClipSizeInBytes > 0 &&\n\t\t\t\t\tnSize > g_Opt.m_lMaxClipSizeInBytes)\n\t\t\t\t{\n\t\t\t\t\tCString cs;\n\t\t\t\t\tcs.Format(\"Maximum clip size reached max size = %d, clip size = %d\", g_Opt.m_lMaxClipSizeInBytes, nSize);\n\t\t\t\t\tLog(cs);\n\n\t\t\t\t\tEXIT_LoadFromClipboard(false);\n\t\t\t\t}\n\n\t\t\t\tASSERT( ::IsValid(cf.m_hgData) );\n\t\t\t\tm_Formats.Add( cf );\n\t\t\t\tm_lTotalCopySize += nSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tASSERT(FALSE); // a valid GlobalMem with 0 size is strange\n\t\t\t\tcf.Free();\n\t\t\t}\n\t\t\tcf.m_hgData = 0; // m_Formats owns it now\n\t\t}\n\t}\n\t\n\tm_Time = CTime::GetCurrentTime();\n\t\n\tif( !bIsDescSet )\n\t\tSetDescFromType();\n\t\n\t// if the description was in a type that is not supported,\n\t//\twe have to free it since it wasn't added to m_Formats\n\tif( cfDesc.m_hgData )\n\t\tcfDesc.Free();\n\t\n\tif( m_Formats.GetSize() == 0 )\n\t\tEXIT_LoadFromClipboard( false );\n\t\n\tEXIT_LoadFromClipboard( true );\n}\n\nbool CClip::SetDescFromText( HGLOBAL hgData )\n{\n\tif( hgData == 0 )\n\t\treturn false;\n\t\n\tbool bRet = false;\n\tchar* text = (char *) GlobalLock(hgData);\n\tlong ulBufLen = GlobalSize(hgData);\n\t\n\tASSERT( text != NULL );\n\t\n\tif( ulBufLen > g_Opt.m_bDescTextSize )\n\t\tulBufLen = g_Opt.m_bDescTextSize;\n\t\n\tif( ulBufLen > 0 )\n\t{\n\t\tchar* buf = m_Desc.GetBuffer(ulBufLen);\n\t\tmemcpy(buf, text, ulBufLen); // in most cases, last char == null\n\t\tbuf[ulBufLen-1] = '\\0'; // just in case not null terminated\n\t\tm_Desc.ReleaseBuffer(); // scans for the null\n\t\tbRet = m_Desc.GetLength() > 0;\n\t}\n\t\n\t//Unlock the data\n\tGlobalUnlock(hgData);\n\t\n\treturn bRet;\n}\n\nbool CClip::SetDescFromType()\n{\n\tif( m_Formats.GetSize() <= 0 )\n\t\treturn false;\n\tm_Desc = GetFormatName( m_Formats[0].m_cfType );\n\treturn m_Desc.GetLength() > 0;\n}\n\nbool CClip::AddToDB( bool bCheckForDuplicates )\n{\n\tbool bResult;\n\ttry\n\t{\n\t\tif( bCheckForDuplicates )\n\t\t{\n\t\t\tCMainTable recset;\n\t\t\t\n\t\t\tif( FindDuplicate( recset, g_Opt.m_bAllowDuplicates ) )\n\t\t\t{\n\t\t\t\tm_ID = recset.m_lID;\n\t\t\t\trecset.Edit();\n\t\t\t\trecset.m_lDate = (long) m_Time.GetTime(); // update the copy Time\n\t\t\t\trecset.Update();\n\t\t\t\trecset.Close();\n\t\t\t\tEmptyFormats(); // delete this clip's data from memory.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif( recset.IsOpen() )\n\t\t\t\trecset.Close();\n\t\t}\n\t}\n\tCATCHDAO\n\t\t\n\t// AddToDataTable must go first in order to assign m_DataID\n\tbResult = AddToDataTable() && AddToMainTable();\n\n\tif(bResult)\n\t{\n\t\tif(g_Opt.m_csPlaySoundOnCopy.GetLength() > 0)\n\t\t\tPlaySound(g_Opt.m_csPlaySoundOnCopy, NULL, SND_FILENAME|SND_ASYNC);\n\t}\n\t\n\t// should be emptied by AddToDataTable\n\tASSERT( m_Formats.GetSize() == 0 );\n\t\n\treturn bResult;\n}\n\n//bool CClip::CheckForMaxSize()\n//{\n//\ttry\n//\t{\n//\t\tCClipFormat* pCF;\n//\t\t\n//\t\tfor( int i = m_Formats.GetSize()-1; i >= 0 ; i-- )\n//\t\t{\n//\t\t\tpCF = &m_Formats.ElementAt(i);\n//\t\n//\t\t\tLPVOID pvData = GlobalLock(pCF->m_hgData);\n//\t\t\tif(pvData)\n//\t\t\t{\n//\t\t\t\tGlobalSize(pCF->m_hgData)\n//\t\t\t}\n//\t\t\tGlobalUnlock(pCF->m_hgData);\n//\t\n//\t\t}\n//\t}\n//\tCATCHDAO\n//\t\t\n//\treturn false;\n//}\n\n// if a duplicate exists, set recset to the duplicate and return true\nbool CClip::FindDuplicate( CMainTable& recset, BOOL bCheckLastOnly )\n{\n\tASSERT( m_lTotalCopySize > 0 );\n\ttry\n\t{\n\t\trecset.m_strSort = \"lDate DESC\";\n\t\t\n\t\tif( bCheckLastOnly )\n\t\t{\n\t\t\trecset.Open(\"SELECT * FROM Main\");\n\t\t\tif(recset.IsEOF())\n\t\t\t\treturn false;\n\t\t\trecset.MoveFirst();\n\t\t\t// if an entry exists and they are the same size and the format data matches\n\t\t\tif( !recset.IsBOF() && !recset.IsEOF() &&\n\t\t\t\tm_lTotalCopySize == recset.m_lTotalCopySize &&\n\t\t\t\t(CompareFormatDataTo(recset.m_lDataID) == 0) )\n\t\t\t{\treturn true; }\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Look for any other entries that have the same size\n\t\trecset.Open(\"SELECT * FROM Main WHERE lTotalCopySize = %d\", m_lTotalCopySize);\n\t\twhile( !recset.IsEOF() )\n\t\t{\n\t\t\t//if there is any then look if it is an exact match\n\t\t\tif( CompareFormatDataTo(recset.m_lDataID) == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\trecset.MoveNext();\n\t\t}\n\t}\n\tCATCHDAO\n\t\t\n\t\treturn false;\n}\n\nint CClip::CompareFormatDataTo( long lDataID )\n{\n\tint nRet = 0;\n\tint nRecs=0, nFormats=0;\n\tCClipFormat* pFormat = NULL;\n\ttry\n\t{\n\t\tCDataTable recset;\n\t\trecset.Open(\"SELECT * FROM Data WHERE lDataID = %d\", lDataID);\n\t\t\n\t\tif( !recset.IsBOF() && !recset.IsEOF() )\n\t\t{\n\t\t\t// Verify the same number of saved types\n\t\t\trecset.MoveLast();\n\t\t\tnRecs = recset.GetRecordCount();\n\t\t}\n\t\tnFormats = m_Formats.GetSize();\n\t\tnRet = nFormats - nRecs;\n\t\tif( nRet != 0 || nRecs == 0 )\n\t\t{\trecset.Close();\treturn nRet; }\n\t\t\n\t\t// For each format type in the db\n\t\t\n\t\tfor( recset.MoveFirst(); !recset.IsEOF(); recset.MoveNext() )\n\t\t{\n\t\t\tpFormat = m_Formats.FindFormat( GetFormatID(recset.m_strClipBoardFormat) );\n\t\t\t\n\t\t\t// Verify the format exists\n\t\t\tif( !pFormat )\n\t\t\t{\trecset.Close(); return -1; }\n\t\t\t\n\t\t\t// Compare the size\n\t\t\tnRet = ::GlobalSize(pFormat->m_hgData) - recset.m_ooData.m_dwDataLength;\n\t\t\tif( nRet != 0 )\n\t\t\t{\trecset.Close(); return nRet; }\n\t\t\t\n\t\t\t// Binary compare\n\t\t\tnRet = CompareGlobalHH( recset.m_ooData.m_hData,\n\t\t\t\tpFormat->m_hgData,\n\t\t\t\trecset.m_ooData.m_dwDataLength );\n\t\t\tif( nRet != 0 )\n\t\t\t{\trecset.Close(); return nRet; }\n\t\t}\n\t\trecset.Close();\n\t}\n\tCATCHDAO\n\t\t\n\t\treturn 0;\n}\n\n// assigns m_ID\nbool CClip::AddToMainTable()\n{\n\tlong lDate;\n\ttry\n\t{\n\t\tCMainTable recset;\n\t\t\n\t\t//\t\trecset.m_strSort = \"lDate DESC\";\n\t\trecset.Open(\"SELECT * FROM Main\");\n\t\t\n\t\tlDate = (long) m_Time.GetTime();\n\t\t\n\t\trecset.AddNew();  // overridden to set m_lID to the new autoincr number\n\t\t\n\t\tm_ID = recset.m_lID;\n\t\t\n\t\trecset.m_lDate = lDate;\n\t\trecset.m_strText = m_Desc;\n\t\trecset.m_lTotalCopySize = m_lTotalCopySize;\n\t\t\n\t\trecset.m_bIsGroup = FALSE;\n\t\trecset.m_lParentID = theApp.m_GroupDefaultID;\n\t\t\n\t\tVERIFY( m_DataID > 0 ); // AddToDataTable must be called first to assign this\n\t\trecset.m_lDataID = m_DataID;\n\t\t\n\t\trecset.Update();\n\t\t\n\t\t//\t\trecset.SetBookmark( recset.GetLastModifiedBookmark() );\n\t\t//\t\tm_ID = recset.m_lID;\n\t\t\n\t\trecset.Close();\n\t}\n\tcatch(CDaoException* e)\n\t{\n\t\tASSERT(FALSE);\n\t\te->Delete();\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\n// Empties m_Formats as it saves them to the Data Table.\nbool CClip::AddToDataTable()\n{\n\tVERIFY( m_DataID <= 0 ); // this func will assign m_DataID\n\ttry\n\t{\n\t\tCClipFormat* pCF;\n\t\tCDataTable recset;\n\t\trecset.Open(dbOpenTable,\"Data\");\n\t\t\n\t\tfor( int i = m_Formats.GetSize()-1; i >= 0 ; i-- )\n\t\t{\n\t\t\tpCF = & m_Formats.ElementAt(i);\n\t\t\t\n\t\t\trecset.AddNew(); // overridden to assign new autoincr ID to m_lID\n\t\t\t\n\t\t\tif( m_DataID <= 0 )\n\t\t\t{\n\t\t\t\tVERIFY( recset.m_lID > 0 );\n\t\t\t\tm_DataID = recset.m_lID;\n\t\t\t}\n\t\t\t\n\t\t\trecset.m_lDataID = m_DataID;\n\t\t\trecset.m_strClipBoardFormat = GetFormatName( pCF->m_cfType );\n\t\t\t// the recset takes ownership of the HGLOBAL\n\t\t\trecset.ReplaceData( pCF->m_hgData, GlobalSize(pCF->m_hgData) );\n\t\t\t\n\t\t\trecset.Update();\n\t\t\t\n\t\t\tm_Formats.RemoveAt( i ); // the recset now owns the global\n\t\t}\n\t\t\n\t\trecset.Close();\n\t\treturn true;\n\t}\n\tCATCHDAO\n\t\t\n\t\treturn false;\n}\n\n// changes m_Time to be later than the latest clip entry in the db\n// ensures that pClip's time is not older than the last clip added\n// old times can happen on fast copies (<1 sec).\nvoid CClip::MakeLatestTime()\n{\n\tlong lDate;\n\ttry\n\t{\n\t\tCMainTable recset;\n\t\t\n\t\trecset.m_strSort = \"lDate DESC\";\n\t\trecset.Open(\"SELECT * FROM Main\");\n\t\tif(!recset.IsEOF())\n\t\t{\n\t\t\trecset.MoveFirst();\n\t\t\t\n\t\t\tlDate = (long) m_Time.GetTime();\n\t\t\tif( lDate <= recset.m_lDate )\n\t\t\t{\n\t\t\t\tlDate = recset.m_lDate + 1;\n\t\t\t\tm_Time = lDate;\n\t\t\t}\n\t\t}\n\t\trecset.Close();\n\t}\n\tCATCHDAO\n}\n\n// STATICS\n\n// Allocates a Global containing the requested Clip Format Data\nHGLOBAL CClip::LoadFormat( long lID, UINT cfType )\n{\n\tHGLOBAL hGlobal = 0;\n\ttry\n\t{\n\t\tCDataTable recset;\n\t\tCString csSQL;\n\t\t\n\t\tcsSQL.Format(\n\t\t\t\"SELECT Data.* FROM Data \"\n\t\t\t\"INNER JOIN Main ON Main.lDataID = Data.lDataID \"\n\t\t\t\"WHERE Main.lID = %d \"\n\t\t\t\"AND Data.strClipBoardFormat = \\'%s\\'\",\n\t\t\tlID,\n\t\t\tGetFormatName(cfType));\n\t\t\n\t\trecset.Open(AFX_DAO_USE_DEFAULT_TYPE, csSQL);\n\t\t\n\t\tif( !recset.IsBOF() && !recset.IsEOF() )\n\t\t{\n\t\t\t// create a new HGLOBAL duplicate\n\t\t\thGlobal = NewGlobalH( recset.m_ooData.m_hData, recset.m_ooData.m_dwDataLength );\n\t\t\t// XOR take the recset's HGLOBAL... is this SAFE??\n\t\t\t//\t\t\thGlobal = recset.TakeData();\n\t\t\tif( !hGlobal || ::GlobalSize(hGlobal) == 0 )\n\t\t\t{\n\t\t\t\tTRACE0( GetErrorString(::GetLastError()) );\n\t\t\t\t//::_RPT0( _CRT_WARN, GetErrorString(::GetLastError()) );\n\t\t\t\tASSERT(FALSE);\n\t\t\t}\n\t\t}\n\t\t\n\t\trecset.Close();\n\t}\n\tCATCHDAO\n\t\t\n\t\treturn hGlobal;\n}\n\nbool CClip::LoadFormats( long lID, CClipFormats& formats, bool bOnlyLoad_CF_TEXT)\n{\n\tCClipFormat cf;\n\tHGLOBAL hGlobal = 0;\n\t\n\tformats.RemoveAll();\n\t\n\ttry\n\t{\n\t\tCDataTable recset;\n\t\t\n\t\t//Open the data table for all that have the parent id\n\t\tCString csSQL;\n\t\tcsSQL.Format(\n\t\t\t\"SELECT Data.* FROM Data \"\n\t\t\t\"INNER JOIN Main ON Main.lDataID = Data.lDataID \"\n\t\t\t\"WHERE Main.lID = %d\", lID);\n\t\t\n\t\trecset.Open(AFX_DAO_USE_DEFAULT_TYPE, csSQL);\n\t\t\n\t\twhile( !recset.IsEOF() )\n\t\t{\n\t\t\tcf.m_cfType = GetFormatID( recset.m_strClipBoardFormat );\n\t\t\t\n\t\t\tif(bOnlyLoad_CF_TEXT)\n\t\t\t{\n\t\t\t\tif(cf.m_cfType != CF_TEXT)\n\t\t\t\t{\n\t\t\t\t\trecset.MoveNext();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// create a new HGLOBAL duplicate\n\t\t\thGlobal = NewGlobalH( recset.m_ooData.m_hData, recset.m_ooData.m_dwDataLength );\n\t\t\t// XOR take the recset's HGLOBAL... is this SAFE??\n\t\t\t//\t\t\thGlobal = recset.TakeData();\n\t\t\tif( !hGlobal || ::GlobalSize(hGlobal) == 0 )\n\t\t\t{\n\t\t\t\tTRACE0( GetErrorString(::GetLastError()) );\n\t\t\t\t//::_RPT0( _CRT_WARN, GetErrorString(::GetLastError()) );\n\t\t\t\tASSERT(FALSE);\n\t\t\t}\n\t\t\t\n\t\t\tcf.m_hgData = hGlobal;\n\t\t\tformats.Add( cf );\n\t\t\trecset.MoveNext();\n\t\t}\n\t\tcf.m_hgData = 0; // formats owns all the data\n\t\t\n\t\trecset.Close();\n\t}\n\tCATCHDAO\n\t\t\n\t\treturn formats.GetSize() > 0;\n}\n\nvoid CClip::LoadTypes( long lID, CClipTypes& types )\n{\n\ttypes.RemoveAll();\n\ttry\n\t{\n\t\tCDataTable recset;\n\t\tCString csSQL;\n\t\t// get formats for Clip \"lID\" (Main.lID) using the corresponding Main.lDataID\n\t\tcsSQL.Format(\n\t\t\t\"SELECT Data.* FROM Data \"\n\t\t\t\"INNER JOIN Main ON Main.lDataID = Data.lDataID \"\n\t\t\t\"WHERE Main.lID = %d\", lID);\n\t\t\n\t\trecset.Open(AFX_DAO_USE_DEFAULT_TYPE, csSQL);\n\t\t\n\t\twhile( !recset.IsEOF() )\n\t\t{\n\t\t\ttypes.Add( GetFormatID( recset.m_strClipBoardFormat ) );\n\t\t\trecset.MoveNext();\n\t\t}\n\t\t\n\t\trecset.Close();\n\t}\n\tCATCHDAO\n}\n\n\n/*----------------------------------------------------------------------------*\\\nCClipList\n\\*----------------------------------------------------------------------------*/\n\nCClipList::~CClipList()\n{\n\tCClip* pClip;\n\twhile( GetCount() )\n\t{\n\t\tpClip = RemoveHead();\n\t\tDELETE_PTR( pClip );\n\t}\n}\n\n// returns the number of clips actually saved\n// while this does empty the Format Data, it does not delete the Clips.\nint CClipList::AddToDB( bool bLatestTime, bool bShowStatus )\n{\n\tint savedCount = 0;\n\tint nRemaining = 0;\n\tCClip* pClip;\n\tPOSITION pos;\n\tbool bResult;\n\t\n\tnRemaining = GetCount();\n\tpos = GetHeadPosition();\n\twhile( pos )\n\t{\n\t\tif( bShowStatus )\n\t\t{\n\t\t\ttheApp.SetStatus( StrF(\"%d\",nRemaining), true );\n\t\t\tnRemaining--;\n\t\t}\n\t\t\n\t\tpClip = GetNext( pos );\n\t\tASSERT( pClip );\n\t\t\n\t\tif( bLatestTime )\n\t\t\tpClip->MakeLatestTime();\n\t\t\n\t\tbResult = pClip->AddToDB();\n\t\tif( bResult )\n\t\t\tsavedCount++;\n\t}\n\t\n\tif( bShowStatus )\n\t\ttheApp.SetStatus(NULL, true);\n\t\n\treturn savedCount;\n}\n\nconst CClipList& CClipList::operator=(const CClipList &cliplist)\n{\n\tPOSITION pos;\n\tCClip* pClip;\n\t\n\tpos = cliplist.GetHeadPosition();\n\twhile(pos)\n\t{\n\t\tpClip = cliplist.GetNext(pos);\n\t\tASSERT(pClip);\n\n\t\tCClip *pNewClip = new CClip;\n\t\tif(pNewClip)\n\t\t{\n\t\t\t*pNewClip = *pClip;\n\t\t\t\n\t\t\tAddTail(pNewClip);\n\t\t}\n\t}\n\t\n\treturn *this;\n}\n\n\n/*----------------------------------------------------------------------------*\\\nCClipboardViewer\n\\*----------------------------------------------------------------------------*/\n\nIMPLEMENT_DYNAMIC(CClipboardViewer, CWnd)\n\nBEGIN_MESSAGE_MAP(CClipboardViewer, CWnd)\n//{{AFX_MSG_MAP(CClipboardViewer)\nON_WM_CREATE()\nON_WM_CHANGECBCHAIN()\nON_WM_DRAWCLIPBOARD()\nON_WM_TIMER()\n//}}AFX_MSG_MAP\nON_MESSAGE(WM_CV_GETCONNECT, OnCVGetConnect)\nON_MESSAGE(WM_CV_SETCONNECT, OnCVSetConnect)\nON_MESSAGE(WM_CV_IS_CONNECTED, OnCVIsConnected)\nON_WM_DESTROY()\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CClipboardViewer construction/destruction\n\nCClipboardViewer::CClipboardViewer( CCopyThread* pHandler )\n{\n\tm_hNextClipboardViewer = 0;\n\tm_bCalling_SetClipboardViewer = false;\n\tm_lReconectCount = 0;\n\tm_bIsConnected = false;\n\tm_bConnect = false;\n\tm_pHandler = pHandler;\n\tASSERT(m_pHandler);\n\tm_bPinging = false;\n\tm_bPingSuccess = false;\n}\n\nCClipboardViewer::~CClipboardViewer()\n{\n}\n\nvoid CClipboardViewer::Create()\n{\n\tCString strParentClass = AfxRegisterWndClass(0);\n\tCWnd::CreateEx(0, strParentClass, \"Ditto Clipboard Viewer\", 0, -1, -1, 0, 0, 0, 0);\n\n\tSetConnect( true );\n}\n\n// connects as a clipboard viewer\nvoid CClipboardViewer::Connect()\n{\n//\tif( m_bIsConnected )\n//\t\treturn;\n\n\tASSERT( ::IsWindow(m_hWnd) );\n\n\t//Set up the clip board viewer\n\tm_bCalling_SetClipboardViewer = true;\n\tm_hNextClipboardViewer = CWnd::SetClipboardViewer();\n\tm_bCalling_SetClipboardViewer = false;\n\tm_bIsConnected = SendPing();\n\n\t// verify that we are in the chain every minute\n\tSetTimer(TIMER_ENSURE_VIEWER_IN_CHAIN, ONE_MINUTE, 0);\n}\n\n// disconnects as a clipboard viewer\nvoid CClipboardViewer::Disconnect()\n{\n//\tif( !m_bIsConnected )\n//\t\treturn;\n\n\tASSERT( ::IsWindow(m_hWnd) );\n\n\tKillTimer(TIMER_ENSURE_VIEWER_IN_CHAIN);\n\n\tCWnd::ChangeClipboardChain( m_hNextClipboardViewer );\n\tm_hNextClipboardViewer = 0;\n\tm_bIsConnected = false;\n}\n\nbool CClipboardViewer::SendPing()\n{\n\tHWND hWnd;\n\tbool bResult = false;\n\t\n\thWnd = ::GetClipboardViewer();\n\t// if there is a chain\n\tif( ::IsWindow(hWnd) )\n\t{\n\t\tm_bPingSuccess = false;\n\t\tm_bPinging = true;\n\t\t::SendMessage( hWnd, WM_DRAWCLIPBOARD, 0, 0 );\n\t\tm_bPinging = false;\n\t\tbResult = m_bPingSuccess;\n\t}\n\t\n\tm_bIsConnected = bResult;\n\t\n\treturn bResult;\n}\n\nbool CClipboardViewer::EnsureConnected()\n{\n\tif( !SendPing() )\n\t\tConnect();\n\t\n\treturn m_bIsConnected;\n}\n\n// puts format \"Clipboard Viewer Ignore\" on the clipboard\nvoid CClipboardViewer::SetCVIgnore()\n{\n\tif( ::OpenClipboard( m_hWnd ) )\n\t{\n\t\t::SetClipboardData( theApp.m_cfIgnoreClipboard, NULL );\n\t\t::CloseClipboard();\n\t}\n}\n\nvoid CClipboardViewer::SetConnect( bool bConnect )\n{\n\tm_bConnect = bConnect;\n\tif( m_bConnect )\n\t\tEnsureConnected();\n\telse\n\t\tDisconnect();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CClipboardViewer message handlers\n\nint CClipboardViewer::OnCreate(LPCREATESTRUCT lpCreateStruct)\n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t//Set up the clip board viewer\n\tConnect();\n\t\n\treturn 0;\n}\n\nvoid CClipboardViewer::OnDestroy()\n{\n\tDisconnect();\n\tCWnd::OnDestroy();\n}\n\nvoid CClipboardViewer::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter) \n{\n\t// If the next window is closing, repair the chain. \n\tif(m_hNextClipboardViewer == hWndRemove)\n    {\n\t\tm_hNextClipboardViewer = hWndAfter;\n    }\n    // Otherwise, pass the message to the next link.\n\telse if (m_hNextClipboardViewer != NULL)\n    {\n\t\tif(m_hNextClipboardViewer != m_hWnd)\n\t\t{\n\t\t\t::SendMessage ( m_hNextClipboardViewer, WM_CHANGECBCHAIN, \n\t\t\t\t(WPARAM) hWndRemove, (LPARAM) hWndAfter );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_hNextClipboardViewer = NULL;\n\t\t}\n    }\n}\n\n//Message that the clipboard data has changed\nvoid CClipboardViewer::OnDrawClipboard() \n{\n\tif( m_bPinging )\n\t{\n\t\tm_bPingSuccess = true;\n\t\treturn;\n\t}\n\t\n\tif((GetTickCount() - m_lLastCopy) > g_Opt.m_lSaveClipDelay)\n\t{\n\t\t// don't process the event when we first attach\n\t\tif( m_pHandler && !m_bCalling_SetClipboardViewer )\n\t\t{\n\t\t\tif( !::IsClipboardFormatAvailable( theApp.m_cfIgnoreClipboard ) )\n\t\t\t\tm_pHandler->OnClipboardChange();\n\t\t}\n\t}\n\telse\n\t{\n\t\tCString cs;\n\t\tcs.Format(\"Clip copy to fast difference from last copy = %d\", (GetTickCount() - m_lLastCopy));\n\t\tLog(cs);\n\t}\n\t\n\t// pass the event to the next Clipboard viewer in the chain\n\tif( m_hNextClipboardViewer != NULL )\n\t{\n\t\tif(m_hNextClipboardViewer != m_hWnd)\n\t\t{\n\t\t\t::SendMessage(m_hNextClipboardViewer, WM_DRAWCLIPBOARD, 0, 0);\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_hNextClipboardViewer = NULL;\n\t\t}\n\t}\n}\n\nvoid CClipboardViewer::OnTimer(UINT nIDEvent) \n{\n\tswitch(nIDEvent)\n\t{\n\tcase TIMER_ENSURE_VIEWER_IN_CHAIN:\n\t\tEnsureConnected();\n\t\tbreak;\n\t}\n\t\n\tCWnd::OnTimer(nIDEvent);\n}\n\nLRESULT CClipboardViewer::OnCVGetConnect(WPARAM wParam, LPARAM lParam)\n{\n\treturn GetConnect();\n}\n\nLRESULT CClipboardViewer::OnCVSetConnect(WPARAM wParam, LPARAM lParam)\n{\n\tSetConnect( wParam != FALSE ); // convert to bool\n\treturn TRUE;\n}\n\nLRESULT CClipboardViewer::OnCVIsConnected(WPARAM wParam, LPARAM lParam)\n{\n\treturn SendPing();\n}\n\n/*----------------------------------------------------------------------------*\\\nCCopyConfig\n\\*----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------*\\\nCCopyThread\n\\*----------------------------------------------------------------------------*/\n\nIMPLEMENT_DYNCREATE(CCopyThread, CWinThread)\n\nCCopyThread::CCopyThread()\n{\n\tm_bQuit = false;\n\tm_bAutoDelete = false;\n\t\n\tm_bConfigChanged = false;\n\tm_pClips = new CClipList;\n\tm_pClipboardViewer = new CClipboardViewer(this);\n\t::InitializeCriticalSection(&m_CS);\n}\n\nCCopyThread::~CCopyThread()\n{\n\tm_LocalConfig.DeleteTypes();\n\tm_SharedConfig.DeleteTypes();\n\tDELETE_PTR( m_pClipboardViewer );\n\tif( m_pClips )\n\t\tASSERT( m_pClips->GetCount() == 0 );\n\tDELETE_PTR( m_pClips );\n\t::DeleteCriticalSection(&m_CS);\n}\n\n// perform and per-thread initialization here\nBOOL CCopyThread::InitInstance()\n{\n\tASSERT( ::GetCurrentThreadId() == m_nThreadID );\n\tSetThreadName(m_nThreadID, \"COPY\");\n\t// the window is created within this thread and therefore uses its message queue\n\tm_pClipboardViewer->Create();\n\treturn TRUE;\n}\n\n// perform any per-thread cleanup here\nint CCopyThread::ExitInstance()\n{\n\tASSERT( m_bQuit );  // make sure we intended to quit\n\tm_pClipboardViewer->Disconnect();\n\treturn CWinThread::ExitInstance();\n}\n\n// Called within Copy Thread:\nvoid CCopyThread::OnClipboardChange()\n{\n\tSyncConfig(); // synchronize with the main thread's copy configuration\n\t\n\t// if we are told not to copy on change, then we have nothing to do.\n\tif( !m_LocalConfig.m_bCopyOnChange )\n\t\treturn;\n\t\n\tCClip* pClip = new CClip;\n\tbool bResult = pClip->LoadFromClipboard( m_LocalConfig.m_pSupportedTypes );\n\t\n\tif( !bResult )\n\t{\n\t\tdelete pClip;\n\t\treturn; // error\n\t}\n\t\n\tAddToClips(\tpClip );\n\t\n\tif( m_LocalConfig.m_bAsyncCopy )\n\t\t::PostMessage(m_LocalConfig.m_hClipHandler, WM_CLIPBOARD_COPIED, (WPARAM)pClip, 0);\n\telse\n\t\t::SendMessage(m_LocalConfig.m_hClipHandler, WM_CLIPBOARD_COPIED, (WPARAM)pClip, 0);\n\t\n}\n\nvoid CCopyThread::SyncConfig()\n{\n\t// atomic read\n\tif( m_bConfigChanged )\n\t{\n\t\tCClipTypes* pTypes = NULL;\n\t\tHold();\n\t\t\n\t\tpTypes = m_LocalConfig.m_pSupportedTypes;\n\t\t\n\t\tm_LocalConfig = m_SharedConfig;\n\t\t\n\t\t// NULL means that it shouldn't have been sync'ed\n\t\tif( m_SharedConfig.m_pSupportedTypes == NULL )\n\t\t{\t// let m_LocalConfig keep its types\n\t\t\tm_LocalConfig.m_pSupportedTypes = pTypes; // undo sync\n\t\t\tpTypes = NULL; // nothing to delete\n\t\t}\n\t\telse\n\t\t\tm_SharedConfig.m_pSupportedTypes = NULL; // now owned by LocalConfig\n\t\t\n\t\tRelease();\n\t\t// delete old types\n\t\tif( pTypes )\n\t\t\tdelete pTypes;\n\t}\n}\n\nvoid CCopyThread::AddToClips( CClip* pClip )\n{\n\tHold();\n\tif( !m_pClips )\n\t\tm_pClips = new CClipList;\n\tm_pClips->AddTail( pClip ); // m_pClips now owns pClip\n\tRelease();\n}\n\n// Shared (use thread-safe access functions below)\n// Called within Main thread:\nbool CCopyThread::IsClipboardViewerConnected()\n{\n\tASSERT( m_pClipboardViewer && m_pClipboardViewer->m_hWnd );\n\treturn ::SendMessage( m_pClipboardViewer->m_hWnd, WM_CV_IS_CONNECTED, 0, 0 ) != FALSE;\n}\n\nbool CCopyThread::GetConnectCV()\n{\n\tASSERT( m_pClipboardViewer && m_pClipboardViewer->m_hWnd );\n\treturn ::SendMessage( m_pClipboardViewer->m_hWnd, WM_CV_GETCONNECT, 0, 0 ) != FALSE;\n}\n\nvoid CCopyThread::SetConnectCV( bool bConnect )\n{\n\tASSERT( m_pClipboardViewer && m_pClipboardViewer->m_hWnd );\n\t::SendMessage( m_pClipboardViewer->m_hWnd, WM_CV_SETCONNECT, bConnect, 0 );\n}\n\nCClipList* CCopyThread::GetClips()\n{\n\tCClipList* pRet;\n\tCClipList* pClips = new CClipList;\n\tHold();\n\tpRet = m_pClips;\n\tm_pClips = pClips;\n\tRelease();\n\treturn pRet;\n}\nvoid CCopyThread::SetSupportedTypes( CClipTypes* pTypes )\n{\n\tCClipTypes* pTemp;\n\tHold();\n\tpTemp = m_SharedConfig.m_pSupportedTypes;\n\tm_SharedConfig.m_pSupportedTypes = pTypes;\n\tm_bConfigChanged = true;\n\tRelease();\n    if( pTemp )\n\t\tdelete pTemp;\n}\nHWND CCopyThread::SetClipHandler( HWND hWnd )\n{\n\tHWND hRet;\n\tHold();\n\thRet = m_SharedConfig.m_hClipHandler;\n\tm_SharedConfig.m_hClipHandler = hWnd;\n\tm_bConfigChanged = (hRet != hWnd);\n\tRelease();\n\treturn hRet;\n}\nHWND CCopyThread::GetClipHandler()\n{\n\tHWND hRet;\n\tHold();\n\thRet = m_SharedConfig.m_hClipHandler;\n\tRelease();\n\treturn hRet;\n}\nbool CCopyThread::SetCopyOnChange( bool bVal )\n{\n\tbool bRet;\n\tHold();\n\tbRet = m_SharedConfig.m_bCopyOnChange;\n\tm_SharedConfig.m_bCopyOnChange = bVal;\n\tm_bConfigChanged = (bRet != bVal);\n\tRelease();\n\treturn bRet;\n}\nbool CCopyThread::GetCopyOnChange()\n{\n\tbool bRet;\n\tHold();\n\tbRet = m_SharedConfig.m_bCopyOnChange;\n\tRelease();\n\treturn bRet;\n}\nbool CCopyThread::SetAsyncCopy( bool bVal )\n{\n\tbool bRet;\n\tHold();\n\tbRet = m_SharedConfig.m_bAsyncCopy;\n\tm_SharedConfig.m_bAsyncCopy = bVal;\n\tm_bConfigChanged = (bRet != bVal);\n\tRelease();\n\treturn bRet;\n}\nbool CCopyThread::GetAsyncCopy()\n{\n\tbool bRet;\n\tHold();\n\tbRet = m_SharedConfig.m_bAsyncCopy;\n\tRelease();\n\treturn bRet;\n}\n\nvoid CCopyThread::Init( CCopyConfig cfg )\n{\n\tASSERT( m_LocalConfig.m_pSupportedTypes == NULL );\n\tm_LocalConfig = m_SharedConfig = cfg;\n\t// let m_LocalConfig own the m_pSupportedTypes\n\tm_SharedConfig.m_pSupportedTypes = NULL;\n}\n\nbool CCopyThread::Quit()\n{\n\tm_bQuit = true;\n\tm_pClipboardViewer->PostMessage( WM_QUIT );\n\treturn CWinThread::PostThreadMessage( WM_QUIT, NULL, NULL ) != FALSE;\n}\n\n\nBEGIN_MESSAGE_MAP(CCopyThread, CWinThread)\nEND_MESSAGE_MAP()\n\n// CCopyThread message handlers\n\n\n\n/*----------------------------------------------------------------------------*\\\nCProcessCopy\n\\*----------------------------------------------------------------------------*/\n\nCProcessCopy::CProcessCopy()\n{\n}\n\nCProcessCopy::~CProcessCopy()\n{\n}\n\n\n"
        },
        {
          "name": "ProcessCopy.h",
          "type": "blob",
          "size": 9.419921875,
          "content": "// ProcessCopy.h: classes for saving the clipboard to db\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\n#define AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n#include <afxole.h>\n#include <afxtempl.h>\n#include \"MainTable.h\"\n\nclass CClip;\nclass CCopyThread;\n\ntypedef CArray<CLIPFORMAT, CLIPFORMAT> CClipTypes;\n\n/*----------------------------------------------------------------------------*\\\n\tCOleDataObjectEx\n\\*----------------------------------------------------------------------------*/\nclass COleDataObjectEx : public COleDataObject\n{\npublic:\n\t// creates global from IStream if necessary\n\tHGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);\n};\n\n/*----------------------------------------------------------------------------*\\\n\tCClipFormat - holds the data of one clip format.\n\\*----------------------------------------------------------------------------*/\nclass CClipFormat\n{\npublic:\n\tCLIPFORMAT\tm_cfType;\n    HGLOBAL\t\tm_hgData;\n\tbool\t\tbDeleteData;\n\n\tCClipFormat(CLIPFORMAT cfType = 0, HGLOBAL hgData = 0);\n\t~CClipFormat();\n\n\tvoid Clear();\n\tvoid Free();\n};\n\n/*----------------------------------------------------------------------------*\\\n\tCClipFormats - holds an array of CClipFormat\n\\*----------------------------------------------------------------------------*/\nclass CClipFormats : public CArray<CClipFormat,CClipFormat&>\n{\npublic:\n\t// returns a pointer to the CClipFormat in this array which matches the given type\n\t//  or NULL if that type doesn't exist in this array.\n\tCClipFormat* FindFormat( UINT cfType ); \n};\n\n\n/*----------------------------------------------------------------------------*\\\n\tCClip - holds multiple CClipFormats and clip statistics\n\t- provides static functions for manipulating a Clip as a single unit.\n\\*----------------------------------------------------------------------------*/\nclass CClip\n{\npublic:\n\tlong\t\t\tm_ID; // 0 if it hasn't yet been saved or is unknown\n\tlong\t\t\tm_DataID;\n\tCClipFormats\tm_Formats; // actual format data\n\n\tconst CClip& operator=(const CClip &clip);\n\n\t// statistics assigned by LoadFromClipboard\n\tCTime\tm_Time;\t // time copied from clipboard\n\tCString m_Desc;\n\tULONG\tm_lTotalCopySize;\n\n\tCClip();\n\t~CClip();\n\n\tvoid Clear();\n\tvoid EmptyFormats();\n\t\n\t// Adds a new Format to this Clip by copying the given data.\n\tbool AddFormat( CLIPFORMAT cfType, void* pData, UINT nLen );\n\t// Fills this CClip with the contents of the clipboard.\n\tbool LoadFromClipboard( CClipTypes* pClipTypes );\n\tbool SetDescFromText( HGLOBAL hgData );\n\tbool SetDescFromType();\n\n\t// Immediately save this clip to the db (empties m_Formats due to AddToDataTable).\n\tbool AddToDB( bool bCheckForDuplicates = true );\n\tbool AddToMainTable(); // assigns m_ID\n\tbool AddToDataTable(); // Empties m_Formats as it saves them to the Data Table.\n\n\t// if a duplicate exists, set recset to the duplicate and return true\n\tbool FindDuplicate( CMainTable& recset, BOOL bCheckLastOnly = FALSE );\n\tint  CompareFormatDataTo( long lDataID );\n\n\t// changes m_Time to be later than the latest clip entry in the db\n\tvoid MakeLatestTime();\n\n// STATICS\n\t// Allocates a Global containing the requested Clip's Format Data\n\tstatic HGLOBAL LoadFormat( long lID, UINT cfType );\n\t// Fills \"formats\" with the Data of all Formats in the db for the given Clip ID\n\tstatic bool LoadFormats( long lID, CClipFormats& formats, bool bOnlyLoad_CF_TEXT = false);\n\t// Fills \"types\" with all Types in the db for the given Clip ID\n\tstatic void LoadTypes( long lID, CClipTypes& types);\n};\n\n\n/*----------------------------------------------------------------------------*\\\n\tCClipList\n\\*----------------------------------------------------------------------------*/\n\nclass CClipList : public CList<CClip*,CClip*>\n{\npublic:\n\t~CClipList();\n\t// returns the number of clips actually saved\n\t// while this does empty the Format Data, it does not delete the Clips.\n\tint AddToDB( bool bLatestTime = false, bool bShowStatus = true );\n\n\tconst CClipList& operator=(const CClipList &cliplist);\n};\n\n\n/*----------------------------------------------------------------------------*\\\n\tCClipboardViewer\n\\*----------------------------------------------------------------------------*/\n\n#define TIMER_ENSURE_VIEWER_IN_CHAIN\t6\n\nclass CClipboardViewer : public CWnd\n{\nprotected: \n\tDECLARE_DYNAMIC(CClipboardViewer)\n\npublic:\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CMainFrame)\n\t//}}AFX_VIRTUAL\n\n// Implementation\n\tCClipboardViewer( CCopyThread* pHandler );\n\tvirtual ~CClipboardViewer();\n\n\tvoid Create();\n\n\tHWND\tm_hNextClipboardViewer;\n\tbool\tm_bCalling_SetClipboardViewer;\n\tlong\tm_lReconectCount;\n\tbool\tm_bIsConnected;  // a cache of the last known state\n\tbool\tm_bConnect; // the user's requested state for the viewer.\n\t// m_bConnect and m_bIsConnected can differ if, e.g., we want to stay\n\t//  connected, but are dropped from the chain for some unknown reason.\n\n\t// m_pHandler->OnClipboardChange is called when the clipboard changes.\n\tCCopyThread*\tm_pHandler;\n\n\tvoid Connect();    // connects as a clipboard viewer\n\tvoid Disconnect(); // disconnects as a clipboard viewer\n\n\tbool\tm_bPinging;\n\tbool\tm_bPingSuccess;\n\tbool SendPing(); // returns true if we are in the chain\n\tbool EnsureConnected(); // pings and connects if ping fails\n\tvoid SetCVIgnore(); // puts format \"Clipboard Viewer Ignore\" on the clipboard\n\n\tbool GetConnect() { return m_bConnect; }\n\tvoid SetConnect( bool bConnect );\n\n\tlong m_lLastCopy;\n// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CMainFrame)\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnDestroy();\n\tafx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);\n\tafx_msg void OnDrawClipboard();\n\tafx_msg void OnTimer(UINT nIDEvent);\n\t//}}AFX_MSG\n\tafx_msg LRESULT OnCVGetConnect(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnCVSetConnect(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnCVIsConnected(WPARAM wParam, LPARAM lParam);\n\tDECLARE_MESSAGE_MAP()\n};\n\n\n/*----------------------------------------------------------------------------*\\\n\tCCopyConfig - used with CCopyThread for efficient inter-thread communication\n\\*----------------------------------------------------------------------------*/\n\nstruct CCopyConfig\n{\npublic:\n\t// WM_CLIPBOARD_COPIED is sent to this window when a copy is made.\n\tHWND        m_hClipHandler;\n\t// true to use PostMessage (asynchronous)\n\t// false to use SendMessage (synchronous)\n\tbool        m_bAsyncCopy;\n\t// true to create a copy of the clipboard contents when it changes\n\t// false to ignore changes in the clipboard\n\tbool        m_bCopyOnChange;\n\t// the supported types which are copied from the clipboard when it changes.\n\tCClipTypes* m_pSupportedTypes; // ONLY accessed from CopyThread\n\n\tCCopyConfig( HWND hClipHandler = NULL,\n\t             bool bAsyncCopy = false,\n\t\t\t\t bool bCopyOnChange = false,\n\t\t\t\t CClipTypes* pSupportedTypes = NULL )\n\t{\n\t\tm_hClipHandler = hClipHandler;\n\t\tm_bAsyncCopy = bAsyncCopy;\n\t\tm_bCopyOnChange = bCopyOnChange;\n\t\tm_pSupportedTypes = pSupportedTypes;\n\t}\n\n\tvoid DeleteTypes()\n\t{\n\t\tif( m_pSupportedTypes )\n\t\t{\n\t\t\tdelete m_pSupportedTypes;\n\t\t\tm_pSupportedTypes = NULL;\n\t\t}\n\t}\n};\n\n/*----------------------------------------------------------------------------*\\\n\tCCopyThread\n\\*----------------------------------------------------------------------------*/\n\nclass CCopyThread : public CWinThread\n{\n\tDECLARE_DYNCREATE(CCopyThread)\n\npublic:\n//protected:\n\tCCopyThread();           // protected constructor used by dynamic creation\n\tvirtual ~CCopyThread();\n\npublic:\n\tbool m_bQuit;\n\n\tvirtual BOOL InitInstance();\n\tvirtual int ExitInstance();\n\n\t// critical section is held whenever shared data is changed \n\tCRITICAL_SECTION\t\tm_CS;\n\tvoid Hold()\t\t{ ::EnterCriticalSection(&m_CS); }\n\tvoid Release()\t{ ::LeaveCriticalSection(&m_CS); }\n\n// CopyThread Local (accessed from this CopyThread)\n\t// window owned by this thread which handles clipboard viewer messages\n\tCClipboardViewer*   m_pClipboardViewer; // permanent during lifetime of thread\n\tCCopyConfig         m_LocalConfig;\n\n\t// Called within Copy Thread:\n\tvoid OnClipboardChange(); // called by ClipboardViewer\n\tvoid SyncConfig(); // safely syncs m_LocalConfig with m_SharedConfig\n\tvoid AddToClips( CClip* pClip ); // after this, pClip is owned by m_pClips\n\n// Shared (use thread-safe access functions below)\n\tCCopyConfig         m_SharedConfig; \n\tbool                m_bConfigChanged; // true if m_SharedConfig was changed.\n\tCClipList*          m_pClips; // snapshots of the clipboard when it changed.\n\n\t// Called within Main thread:\n\tbool IsClipboardViewerConnected();\n\tbool GetConnectCV();\n\tvoid SetConnectCV( bool bConnect );\n\n\tCClipList* GetClips(); // caller owns the returned CClipList\n\tvoid SetSupportedTypes( CClipTypes* pTypes ); // CopyThread will own pTypes\n\tHWND SetClipHandler( HWND hWnd ); // returns previous value\n\tHWND GetClipHandler();\n\tbool SetCopyOnChange( bool bVal ); // returns previous value\n\tbool GetCopyOnChange();\n\tbool SetAsyncCopy( bool bVal ); // returns previous value\n\tbool GetAsyncCopy();\n\n// Main thread\n\tvoid Init( CCopyConfig cfg );\n\tbool Quit();\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\n\n/*----------------------------------------------------------------------------*\\\n\tCProcessCopy\n\\*----------------------------------------------------------------------------*/\nclass CProcessCopy\n{\npublic:\n\tCProcessCopy();\n\tvirtual ~CProcessCopy();\n};\n\n#endif // !defined(AFX_PROCESSCOPY_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\n"
        },
        {
          "name": "ProcessPaste.cpp",
          "type": "blob",
          "size": 6.84375,
          "content": "#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"ProcessPaste.h\"\r\n#include \"ClipIds.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\nCProcessPaste::CProcessPaste()\r\n{\r\n\tm_pOle = new COleClipSource;\r\n\tm_bSendPaste = true;\r\n\tm_bActivateTarget = true;\r\n\tm_pastedFromGroup = false;\r\n}\r\n\r\nCProcessPaste::~CProcessPaste()\r\n{\t\r\n\tdelete m_pOle;\r\n}\r\n\r\nBOOL CProcessPaste::DoPaste()\r\n{\r\n\tBOOL ret = FALSE;\r\n\r\n\ttry\r\n\t{\r\n\t\tm_pOle->m_pasteOptions = m_pasteOptions;\r\n\t\tif (!m_pOle->DoImmediateRender())\r\n\t\t{\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\t// MarkAsPasted() must be done first since it makes use of\r\n\t\t//  m_pOle->m_ClipIDs and m_pOle is inaccessible after\r\n\t\t//  SetClipboard is called.\r\n\t\tMarkAsPasted(m_pasteOptions.m_updateClipOrder);\r\n\r\n\t\t// Ignore the clipboard change that we will cause IF:\r\n\t\t// 1) we are pasting a single element, since the element is already\r\n\t\t//    in the db and its lDate was updated by MarkAsPasted().\r\n\t\t// OR\r\n\t\t// 2) we are pasting multiple, but CGetSetOptions::m_bSaveMultiPaste is false\r\n\t\tif (GetClipIDs().GetSize() == 1 || !CGetSetOptions::m_bSaveMultiPaste)\r\n\t\t{\r\n\t\t\tm_pOle->CacheGlobalData(theApp.m_cfIgnoreClipboard, NewGlobalP(\"Ignore\", sizeof(\"Ignore\")));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_pOle->CacheGlobalData(theApp.m_cfDelaySavingData, NewGlobalP(\"Delay\", sizeof(\"Delay\")));\r\n\t\t}\r\n\r\n\t\tm_pOle->SetClipboard(); // m_pOle is now managed by the OLE clipboard\r\n\r\n\t\tif (m_bSendPaste)\r\n\t\t{\r\n\t\t\tLog(_T(\"Sending Paste to active window\"));\r\n\t\t\ttheApp.m_activeWnd.SendPaste(m_bActivateTarget);\r\n\t\t}\r\n\t\telse if (m_bActivateTarget)\r\n\t\t{\r\n\t\t\tLog(_T(\"Activating active window\"));\r\n\t\t\ttheApp.m_activeWnd.ActivateTarget();\r\n\t\t}\r\n\r\n\t\tret = TRUE;\r\n\t\r\n\t}\r\n\tcatch (CException *ex)\r\n\t{\r\n\t\tTCHAR szCause[255];\r\n\t\tex->GetErrorMessage(szCause, 255);\r\n\t\tm_lastErrorMessage.Format(_T(\"Paste exception: %s\"), szCause);\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\tcatch (...) \r\n\t{\r\n\t\tm_lastErrorMessage = _T(\"Paste generic exception\");\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\r\n\t// The Clipboard now owns the allocated memory\r\n\t// and will delete this data object\r\n\t// when new data is put on the Clipboard\r\n\tm_pOle = NULL; // m_pOle should not be accessed past this point\r\n\r\n\treturn ret;\r\n}\r\n\r\nBOOL CProcessPaste::DoDrag()\r\n{\r\n\tBOOL ret = FALSE;\r\n\ttry\r\n\t{\r\n\t\tm_pOle->m_pasteOptions = m_pasteOptions;\r\n\t\tm_pOle->DoDelayRender();\r\n\t\tDROPEFFECT de = m_pOle->DoDragDrop(DROPEFFECT_COPY);\r\n\t\tif (de != DROPEFFECT_NONE)\r\n\t\t{\r\n\t\t\tMarkAsPasted(m_pasteOptions.m_updateClipOrder);\r\n\t\t\tret = TRUE;\r\n\t\t}\t\t\r\n\t}\r\n\tcatch (CException *ex)\r\n\t{\r\n\t\tTCHAR szCause[255];\r\n\t\tex->GetErrorMessage(szCause, 255);\r\n\t\tm_lastErrorMessage.Format(_T(\"Drag drop exception: %s\"), szCause);\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n\t\tm_lastErrorMessage = _T(\"Drag drop generic exception\");\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\r\n\ttry\r\n\t{\r\n\t\t//from https://www.codeproject.com/Articles/886711/Drag-Drop-Images-and-Drop-Descriptions-for-MFC-App\r\n\t\t//You may have noted the InternalRelease() function call.This is required here to delete the object.While it is possible to use \r\n\t\t//delete or create the object on the stack with Drag & Drop operations, it is not recommended to do so.\r\n\t\tm_pOle->InternalRelease();\r\n\t}\r\n\tcatch (CException *ex)\r\n\t{\r\n\t\tTCHAR szCause[255];\r\n\t\tex->GetErrorMessage(szCause, 255);\r\n\t\tm_lastErrorMessage.Format(_T(\"Drag drop exception 2: %s\"), szCause);\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n\t\tm_lastErrorMessage = _T(\"Drag drop generic exception 2\");\r\n\t\tLog(m_lastErrorMessage);\r\n\t}\r\n\r\n\t// The Clipboard now owns the allocated memory\r\n\t// and will delete this data object\r\n\t// when new data is put on the Clipboard\r\n\tm_pOle = NULL; // m_pOle should not be accessed past this point\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CProcessPaste::MarkAsPasted(bool updateClipOrder)\r\n{\r\n\tLog(_T(\"start of MarkAsPasted\"));\r\n\r\n\tCClipIDs& clips = GetClipIDs();\r\n\t\r\n\tCGetSetOptions::SetTripPasteCount(-1);\r\n\tCGetSetOptions::SetTotalPasteCount(-1);\r\n\r\n\tMarkAsPastedData* pData = new MarkAsPastedData();\r\n\tfor (int i = 0; i < clips.GetCount(); i++)\r\n\t{\r\n\t\tpData->ids.Add(clips.ElementAt(i));\r\n\t}\r\n\tpData->pastedFromGroup = m_pastedFromGroup;\r\n\tpData->updateClipOrder = updateClipOrder;\r\n\r\n\t//Moved to a thread because when running from from U3 devices the write is time consuming\r\n\tAfxBeginThread(CProcessPaste::MarkAsPastedThread, (LPVOID)pData, THREAD_PRIORITY_LOWEST);\r\n\r\n\tLog(_T(\"End of MarkAsPasted\"));\r\n}\r\n\r\nUINT CProcessPaste::MarkAsPastedThread(LPVOID pParam)\r\n{\r\n\tDWORD startTick = GetTickCount();\r\n\r\n\tstatic CEvent UpdateTimeEvent(TRUE, TRUE, _T(\"Ditto_Update_Clip_Time\"), NULL);\r\n\tUpdateTimeEvent.ResetEvent();\r\n\r\n\tLog(_T(\"Start of MarkAsPastedThread\"));\r\n\r\n\tBOOL bRet = FALSE;\r\n\tint clipId = 0;\r\n\r\n\ttry\r\n\t{\r\n\t\tint refreshFlags = 0;\r\n\r\n\t\tMarkAsPastedData* pData = (MarkAsPastedData*)pParam;\r\n\t\tif(pData)\r\n\t\t{\r\n\t\t\tint clipCount = (int)pData->ids.GetCount();\r\n\r\n\t\t\tif(CGetSetOptions::m_bUpdateTimeOnPaste && \r\n\t\t\t\tpData->updateClipOrder &&\r\n\t\t\t\tclipCount == 1)\r\n\t\t\t{\r\n\t\t\t\tif (CGetSetOptions::m_refreshViewAfterPasting)\r\n\t\t\t\t{\r\n\t\t\t\t\trefreshFlags |= UPDATE_AFTER_PASTE_SELECT_CLIP;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int i = 0; i < clipCount; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint id = pData->ids.ElementAt(i);\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (pData->pastedFromGroup)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT clipGroupOrder FROM Main ORDER BY clipGroupOrder DESC LIMIT 1\"));\r\n\r\n\t\t\t\t\t\t\tif (q.eof() == false)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdouble latestDate = q.getFloatField(_T(\"clipGroupOrder\"));\r\n\t\t\t\t\t\t\t\tlatestDate += 1;\r\n\r\n\t\t\t\t\t\t\t\tLog(StrF(_T(\"Setting clipId: %d, GroupOrder: %f\"), id, latestDate));\r\n\r\n\t\t\t\t\t\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET clipGroupOrder = %f where lID = %d;\"), latestDate, id);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(_T(\"SELECT clipOrder FROM Main ORDER BY clipOrder DESC LIMIT 1\"));\r\n\r\n\t\t\t\t\t\t\tif (q.eof() == false)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdouble latestDate = q.getFloatField(_T(\"clipOrder\"));\r\n\t\t\t\t\t\t\t\tlatestDate += 1;\r\n\r\n\t\t\t\t\t\t\t\tLog(StrF(_T(\"Setting clipId: %d, order: %f\"), id, latestDate));\r\n\r\n\t\t\t\t\t\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET clipOrder = %f where lID = %d;\"), latestDate, id);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tCATCH_SQLITE_EXCEPTION\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < clipCount; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tint id = pData->ids.ElementAt(i);\r\n\t\t\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lastPasteDate = %d where lID = %d;\"), (int)CTime::GetCurrentTime().GetTime(), id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\t\tfor (int i = 0; i < clipCount; i++)\r\n\t\t\t{\r\n\t\t\t\tint id = pData->ids.ElementAt(i);\r\n\r\n\t\t\t\ttheApp.RefreshClipInUI(id, refreshFlags);\r\n\t\t\t\tbreak;\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\tdelete pData;\r\n\t\t\tbRet = TRUE;\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\tLog(_T(\"End of MarkAsPastedThread\"));\r\n\r\n\tDWORD endTick = GetTickCount();\r\n\tif((endTick-startTick) > 350)\r\n\t\tLog(StrF(_T(\"Paste Timing MarkAsPastedThread: %d, ClipId: %d\"), endTick-startTick, clipId));\r\n\r\n\tUpdateTimeEvent.SetEvent();\r\n\treturn bRet;\r\n}"
        },
        {
          "name": "ProcessPaste.h",
          "type": "blob",
          "size": 1.2080078125,
          "content": "// ProcessPaste.h: interface for the CProcessCopy class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_PROCESSPASTE_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\n#define AFX_PROCESSPASTE_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include \"Shared/ArrayEx.h\"\n#include \"Clip.h\"\n#include \"ClipIds.h\"\n#include \"OleClipSource.h\"\n#include \"SpecialPasteOptions.h\"\n\n/*------------------------------------------------------------------*\\\n\tCProcessPaste\n\\*------------------------------------------------------------------*/\nclass CProcessPaste\n{\npublic:\n\tCOleClipSource*\tm_pOle;\n\tbool m_bSendPaste;\n\tbool m_bActivateTarget;\n\tCSpecialPasteOptions m_pasteOptions;\n\tbool m_pastedFromGroup;\n\tCString m_lastErrorMessage;\n\n\tstruct MarkAsPastedData \n\t{\n\t\tCClipIDs ids;\n\t\tbool pastedFromGroup;\n\t\tbool updateClipOrder;\n\t};\n\t\n\tCProcessPaste();\n\t~CProcessPaste();\n\n\tCClipIDs& GetClipIDs() { return m_pOle->m_ClipIDs; }\n\n\tBOOL DoPaste();\n\tBOOL DoDrag();\n\n\tvoid MarkAsPasted(bool updateClipOrder);\n\tstatic UINT MarkAsPastedThread(LPVOID pParam);\n};\n\n#endif // !defined(AFX_PROCESSPASTE_H__185CBB6F_4B63_4397_8FF9_E18D777DA506__INCLUDED_)\n"
        },
        {
          "name": "ProgressWnd.cpp",
          "type": "blob",
          "size": 12.0341796875,
          "content": "#include \"stdafx.h\"\n#include \"ProgressWnd.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define IDC_CANCEL   10\n#define IDC_TEXT     11\n#define IDC_PROGRESS 12\n\nLPCTSTR szSection = _T(\"Settings\");   \nLPCTSTR szEntryX  = _T(\"X\");\nLPCTSTR szEntryY  = _T(\"Y\");\n\n#define _CRT_NON_CONFORMING_SWPRINTFS 1\n\n/////////////////////////////////////////////////////////////////////////////\n// CProgressWnd\n\nCProgressWnd::CProgressWnd()\n{\n    CommonConstruct();\n}\n\nCProgressWnd::CProgressWnd(CWnd* pParent, LPCTSTR pszTitle, BOOL bSmooth /* = FALSE */)\n{\n    CommonConstruct();\n    m_strTitle = pszTitle;\n\n    Create(pParent, pszTitle, bSmooth);\n}\n\nvoid CProgressWnd::CommonConstruct()\n{\n    m_nNumTextLines  = 4;\n    m_nPrevPos       = 0;\n    m_nPrevPercent   = 0;\n    m_nStep          = 1;\n    m_nMinValue      = 0;\n    m_nMaxValue      = 100;\n\n    m_strTitle       = _T(\"Progress\");\n    m_strCancelLabel = _T(\" Cancel \");\n    m_bCancelled     = FALSE;\n    m_bModal         = FALSE;\n\n    m_bPersistantPosition = TRUE;   // saves and restores position automatically\n}\n\nCProgressWnd::~CProgressWnd()\n{\n    DestroyWindow();\n}\n\nBOOL CProgressWnd::Create(CWnd* pParent, LPCTSTR pszTitle, BOOL bSmooth /* = FALSE */)\n{\n    BOOL bSuccess;\n\n\tm_strTitle = pszTitle;\n    // Register window class\n    CString csClassName = AfxRegisterWndClass(CS_OWNDC|CS_HREDRAW|CS_VREDRAW,\n                                              ::LoadCursor(NULL, IDC_APPSTARTING),\n                                              CBrush(::GetSysColor(COLOR_BTNFACE)));\n\n    // Get the system window message font for use in the cancel button and text area\n    NONCLIENTMETRICS ncm;\n    ncm.cbSize = sizeof(NONCLIENTMETRICS);\n    VERIFY(SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0));\n    m_font.CreateFontIndirect(&(ncm.lfMessageFont)); \n\n    // If no parent supplied then try and get a pointer to it anyway\n    if (!pParent)\n        pParent = AfxGetMainWnd();\n\n    // Create popup window\n    //bSuccess = CreateEx(WS_EX_DLGMODALFRAME|WS_EX_TOPMOST, // Extended style\n\tbSuccess = CreateEx(WS_EX_DLGMODALFRAME,\n                        csClassName,                       // Classname\n                        pszTitle,                          // Title\n                        WS_POPUP|WS_BORDER|WS_CAPTION,     // style\n                        0,0,                               // position - updated soon.\n                        390,130,                           // Size - updated soon\n                        pParent->GetSafeHwnd(),            // handle to parent\n                        0,                                 // No menu\n                        NULL);    \n    if (!bSuccess) return FALSE;\n\n    // Now create the controls\n    CRect TempRect(0,0,10,10);\n\n    bSuccess = m_Text.Create(_T(\"\"), WS_CHILD|WS_VISIBLE|SS_NOPREFIX|SS_LEFTNOWORDWRAP,\n                             TempRect, this, IDC_TEXT);\n    if (!bSuccess) return FALSE;\n\n    DWORD dwProgressStyle = WS_CHILD|WS_VISIBLE;\n#ifdef PBS_SMOOTH    \n    if (bSmooth)\n       dwProgressStyle |= PBS_SMOOTH;\n#endif\n    bSuccess = m_wndProgress.Create(dwProgressStyle,TempRect, this, IDC_PROGRESS);\n    if (!bSuccess) return FALSE;\n\n    bSuccess = m_CancelButton.Create(m_strCancelLabel, \n                                   WS_CHILD|WS_VISIBLE|WS_TABSTOP| BS_PUSHBUTTON, \n                                     TempRect, this, IDC_CANCEL);\n    if (!bSuccess) return FALSE;\n\n    m_CancelButton.SetFont(&m_font, TRUE);\n    m_Text.SetFont(&m_font, TRUE);\n\n    // Resize the whole thing according to the number of text lines, desired window\n    // width and current font.\n    SetWindowSize(m_nNumTextLines, 390);\n\n    // Center and show window\n    if (m_bPersistantPosition)\n        GetPreviousSettings();\n    else\n        CenterWindow();\n\n    Show();\n\n    return TRUE;\n}\n\nBOOL CProgressWnd::GoModal(LPCTSTR pszTitle /*=_T(\"Progress\")\"*/, BOOL bSmooth /*=FALSE*/)\n{\n    CWnd *pMainWnd = AfxGetMainWnd();\n\n    if (!::IsWindow(m_hWnd) && !Create(pMainWnd, pszTitle, bSmooth))\n        return FALSE;\n\n    // Disable main window\n    if (pMainWnd)\n        pMainWnd->EnableWindow(FALSE);\n\n    // Re-enable this window\n    EnableWindow(TRUE);\n\n    m_bModal = TRUE;\n\n    return TRUE;\n}\n    \nvoid CProgressWnd::SetWindowSize(int nNumTextLines, int nWindowWidth /*=390*/)\n{\n    int nMargin = 10;\n    CSize EdgeSize(::GetSystemMetrics(SM_CXEDGE), ::GetSystemMetrics(SM_CYEDGE));\n\n    CRect TextRect, CancelRect, ProgressRect;\n    CSize CancelSize;\n\n    // Set up a default size for the text area in case things go wrong\n    TextRect.SetRect(nMargin,nMargin, nWindowWidth-2*nMargin, 100+2*nMargin);\n\n    // Get DrawText to tell us how tall the text area will be (while we're at\n    // it, we'll see how big the word \"Cancel\" is)\n    CDC* pDC = GetDC();\n    if (pDC) {\n        CFont* pOldFont = pDC->SelectObject(&m_font);\n        CString str = _T(\"M\");\n        for (int i = 0; i < nNumTextLines-1; i++) str += _T(\"\\nM\");\n        pDC->DrawText(str, TextRect, DT_CALCRECT|DT_NOCLIP|DT_NOPREFIX);\n        TextRect.right = TextRect.left + nWindowWidth;\n        CancelSize = pDC->GetTextExtent(m_strCancelLabel + _T(\"  \")) +\n                                             CSize(EdgeSize.cx*4, EdgeSize.cy*3);\n        pDC->SelectObject(pOldFont);\n        ReleaseDC(pDC);\n    }\n    \n    // Work out how big (and where) the cancel button should be\n    CancelRect.SetRect(TextRect.right-CancelSize.cx, TextRect.bottom+nMargin, \n                       TextRect.right, TextRect.bottom+nMargin + CancelSize.cy);\n\n\n    // Work out how big (and where) the progress control should be\n    ProgressRect.SetRect(TextRect.left, CancelRect.top + EdgeSize.cy, \n                         CancelRect.left-nMargin, CancelRect.bottom - EdgeSize.cy);\n\n\n    // Resize the main window to fit the controls\n    CSize ClientSize(nMargin + TextRect.Width() + nMargin,\n                     nMargin + TextRect.Height() + nMargin + CancelRect.Height() + nMargin);\n\n    CRect WndRect, ClientRect;\n    GetWindowRect(WndRect); GetClientRect(ClientRect);\n    WndRect.right = WndRect.left + WndRect.Width()-ClientRect.Width()+ClientSize.cx;\n    WndRect.bottom = WndRect.top + WndRect.Height()-ClientRect.Height()+ClientSize.cy;\n    MoveWindow(WndRect);\n\n    // Now reposition the controls...\n    m_wndProgress.MoveWindow(ProgressRect);\n    m_CancelButton.MoveWindow(CancelRect);\n    m_Text.MoveWindow(TextRect);\n}\n\nvoid CProgressWnd::Clear() \n{ \n    SetText(_T(\"\"));\n    SetPos(0);\n    m_bCancelled = FALSE; \n    m_nPrevPos = 0;\n\n    if (::IsWindow(GetSafeHwnd()))\n        UpdateWindow();\n}\n\nvoid CProgressWnd::Hide()  \n{ \n    if (!::IsWindow(GetSafeHwnd())) \n        return;\n\n    if (IsWindowVisible())\n    {\n        ShowWindow(SW_HIDE);\n        ModifyStyle(WS_VISIBLE, 0);\n    }\n}\n\nvoid CProgressWnd::Show()  \n{ \n    if (!::IsWindow(GetSafeHwnd()))\n        return;\n\n    if (!IsWindowVisible())\n    {\n        ModifyStyle(0, WS_VISIBLE);\n        ShowWindow(SW_SHOWNA);\n        RedrawWindow(NULL,NULL,RDW_ERASE|RDW_FRAME|RDW_INVALIDATE);\n    }\n}\n\nvoid CProgressWnd::SetRange(int nLower, int nUpper, int nStep /* = 1 */)    \n{\n    if (!::IsWindow(GetSafeHwnd())) \n        return;\n\n #ifdef PBM_SETRANGE32\n    ASSERT(-0x7FFFFFFF <= nLower && nLower <= 0x7FFFFFFF);\n    ASSERT(-0x7FFFFFFF <= nUpper && nUpper <= 0x7FFFFFFF);\n    m_wndProgress.SendMessage(PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper);\n#else\n    ASSERT(0 <= nLower && nLower <= 65535);\n    ASSERT(0 <= nUpper && nUpper <= 65535);\n    m_wndProgress.SetRange(nLower, nUpper);\n#endif\n\n    m_nMaxValue = nUpper;\n    m_nMinValue = nLower;\n    m_nStep     = nStep;\n\n    m_wndProgress.SetStep(nStep);\n}\n\nint CProgressWnd::OffsetPos(int nPos)\n{ \n    if (!::IsWindow(GetSafeHwnd())) \n        return m_nPrevPos;\n\n    Show();\n\n    return SetPos(m_nPrevPos + nPos);  \n}\n\nint CProgressWnd::StepIt()                \n{\n    if (!::IsWindow(GetSafeHwnd())) \n        return m_nPrevPos;\n\n    Show();\n\n    return SetPos(m_nPrevPos + m_nStep); \n}\n\nint CProgressWnd::SetStep(int nStep)\n{\n    int nOldStep = m_nStep;\n    m_nStep = nStep;\n    if (!::IsWindow(GetSafeHwnd())) \n        return nOldStep;\n\n    return m_wndProgress.SetStep(nStep); \n}\n\nint CProgressWnd::SetPos(int nPos)                    \n{\n#ifdef PBM_SETRANGE32\n    ASSERT(-0x7FFFFFFF <= nPos && nPos <= 0x7FFFFFFF);\n#else\n    ASSERT(0 <= nPos && nPos <= 65535);\n#endif\n\n    if (!::IsWindow(GetSafeHwnd())) \n        return m_nPrevPos;\n\n    Show();\n\n    CString strTitle;\n//  int nPercentage;\n    \n    m_nPrevPos = nPos;\n\n//    if (m_nMaxValue > m_nMinValue)\n//        nPercentage = (nPos*100)/(m_nMaxValue - m_nMinValue);\n//    else\n//        nPercentage = 0;\n\n//    if (nPercentage != m_nPrevPercent) \n//    {\n//        m_nPrevPercent = nPercentage;\n//        strTitle.Format(_T(\"%s [%d%%]\"),m_strTitle,nPercentage);\n\t\tstrTitle.Format(_T(\"%s\"),m_strTitle);\n        SetWindowText(strTitle);\n//    }\n    return m_wndProgress.SetPos(nPos);        \n}\n\nvoid CProgressWnd::SetText(LPCTSTR fmt, ...)\n{\n    if (!::IsWindow(GetSafeHwnd())) \n        return;\n\n    va_list args;\n    TCHAR buffer[512];\n\n    va_start(args, fmt);\n    _vstprintf(buffer, fmt, args);\n    va_end(args);\n\n    m_Text.SetWindowText(buffer);\n}\n\nBEGIN_MESSAGE_MAP(CProgressWnd, CWnd)\n    //{{AFX_MSG_MAP(CProgressWnd)\n    ON_WM_ERASEBKGND()\n\t//}}AFX_MSG_MAP\n    ON_BN_CLICKED(IDC_CANCEL, OnCancel)\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CProgressWnd message handlers\n\nBOOL CProgressWnd::OnEraseBkgnd(CDC* pDC) \n{\n    // Fill background with Catchment background colour\n    CBrush backBrush(GetSysColor(COLOR_BTNFACE));\n    CBrush* pOldBrush = pDC->SelectObject(&backBrush);\n    CRect rect;\n    pDC->GetClipBox(&rect);     // Erase the area needed\n    pDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY);\n    pDC->SelectObject(pOldBrush);\n\n    return TRUE;\n}\n\nvoid CProgressWnd::OnCancel() \n{\n    m_bCancelled = TRUE;\n    Hide();\n\n    if (m_bModal)\n        SendMessage(WM_CLOSE);\n\n    CWnd *pWnd = AfxGetMainWnd();\n    if (pWnd && ::IsWindow(pWnd->m_hWnd))\n        pWnd->SetForegroundWindow();\n}\n\n\nBOOL CProgressWnd::DestroyWindow() \n{\n    if (m_bPersistantPosition)\n        SaveCurrentSettings();\n\n    if (m_bModal)\n    {\n        m_bModal = FALSE;\n        CWnd *pMainWnd = AfxGetMainWnd();\n\n        if (pMainWnd)\n            pMainWnd->EnableWindow(TRUE);\n    }\n\t\n\treturn CWnd::DestroyWindow();\n}\n\nvoid CProgressWnd::PeekAndPump(BOOL bCancelOnESCkey /*= TRUE*/)\n{\n    if (m_bModal && ::GetFocus() != m_hWnd)\n        SetFocus();\n\n    MSG msg;\n    while (!m_bCancelled && ::PeekMessage(&msg, NULL,0,0,PM_NOREMOVE)) \n    {\n        if (bCancelOnESCkey && (msg.message == WM_CHAR) && (msg.wParam == VK_ESCAPE))\n            OnCancel();\n\n        // Cancel button disabled if modal, so we fake it.\n        if (m_bModal && (msg.message == WM_LBUTTONUP))\n        {\n            CRect rect;\n            m_CancelButton.GetWindowRect(rect);\n            if (rect.PtInRect(msg.pt))\n                OnCancel();\n        }\n  \n        if (!AfxGetApp()->PumpMessage()) \n        {\n            ::PostQuitMessage(0);\n            return;\n        } \n    }\n}\n\n// Retores the previous window size from the registry\nvoid CProgressWnd::GetPreviousSettings()\n{\n    int x = AfxGetApp()->GetProfileInt(szSection, szEntryX, -1);\n    int y = AfxGetApp()->GetProfileInt(szSection, szEntryY, -1);\n\n    if (x >= 0 && x < GetSystemMetrics(SM_CXSCREEN) &&\n        y >= 0 && y < GetSystemMetrics(SM_CYSCREEN))\n    {\n        SetWindowPos(NULL, x,y, 0,0, SWP_NOSIZE|SWP_NOZORDER);\n    }\n    else\n        CenterWindow();\n}\n\n// Saves the current window position registry\nvoid CProgressWnd::SaveCurrentSettings()\n{   \n    if (!IsWindow(m_hWnd))\n        return;\n\n    CRect rect;\n    GetWindowRect(rect);\n\n    AfxGetApp()->WriteProfileInt(szSection, szEntryX, rect.left);\n    AfxGetApp()->WriteProfileInt(szSection, szEntryY, rect.top);\n}\n\nvoid CProgressWnd::HideCancel()\n{\n\tm_CancelButton.ShowWindow(SW_HIDE);\n\tUpdateData(FALSE);\n}\n\nvoid CProgressWnd::ShowCancel()\n{\n\tm_CancelButton.ShowWindow(SW_SHOW);\n\tUpdateData(FALSE);\n}\n\nvoid CProgressWnd::SetTitleText(CString csTitle)\n{\n\tm_strTitle = csTitle;\n\t\n\tCString title;\n\ttitle.Format(_T(\"%s\"),m_strTitle);\n\t\n\tSetWindowText(title);\n}"
        },
        {
          "name": "ProgressWnd.h",
          "type": "blob",
          "size": 2.28515625,
          "content": "#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\nclass CProgressWnd : public CWnd\n{\n// Construction/Destruction\npublic:\n    CProgressWnd();\n    CProgressWnd(CWnd* pParent, LPCTSTR pszTitle, BOOL bSmooth = FALSE);\n    virtual ~CProgressWnd();\n\n    BOOL Create(CWnd* pParent, LPCTSTR pszTitle, BOOL bSmooth = FALSE);\n    BOOL GoModal(LPCTSTR pszTitle =_T(\"Progress\"), BOOL bSmooth = FALSE);\n\nprotected:\n    void CommonConstruct();\n\n// Operations\npublic:\n    void SetRange(int nLower, int nUpper, int nStep = 1);\n                                                    // Set range and step size\n    int OffsetPos(int nPos);                        // Same as CProgressCtrl\n    int StepIt();                                   //    \"\n    int SetStep(int nStep);                         //    \"\n    int SetPos(int nPos);                           //    \"\n\n    void SetText(LPCTSTR fmt, ...);                 // Set text in text area\n\n    void Clear();                                   // Clear text, reset bar\n    void Hide();                                    // Hide window\n    void Show();                                    // Show window\n\tvoid HideCancel();\n\tvoid ShowCancel();\n\tint\t GetPos() const\t\t{ return m_nPrevPos;\t}\n\n    BOOL Cancelled() { return m_bCancelled; }       // Was \"Cancel\" hit?\n\n\tvoid SetWindowSize(int nNumTextLines, int nWindowWidth = 390);\n\n    void PeekAndPump(BOOL bCancelOnESCkey = TRUE);  // Message pumping for modal operation   \n\n\tvoid SetTitleText(CString csTitle);\n    \n// Implementation\nprotected:\n    void GetPreviousSettings();\n    void SaveCurrentSettings();\n\nprotected:\n    BOOL m_bCancelled;\n    BOOL m_bModal;\n    BOOL m_bPersistantPosition;\n    int  m_nPrevPos, m_nPrevPercent;\n    int  m_nStep;\n    int  m_nMaxValue, m_nMinValue;\n    int  m_nNumTextLines;\n\n    CStatic       m_Text;\n    CProgressCtrl m_wndProgress;\n    CButton       m_CancelButton;\n    CString       m_strTitle,\n                  m_strCancelLabel;\n    CFont         m_font;\n\n\n// Overrides\n    // ClassWizard generated virtual function overrides\n    //{{AFX_VIRTUAL(CProgressWnd)\n\tpublic:\n\tvirtual BOOL DestroyWindow();\n\t//}}AFX_VIRTUAL\n\n// Generated message map functions\nprotected:\n    //{{AFX_MSG(CProgressWnd)\n    afx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\t//}}AFX_MSG\n    afx_msg void OnCancel();\n    DECLARE_MESSAGE_MAP()\n};"
        },
        {
          "name": "QListCtrl.cpp",
          "type": "blob",
          "size": 41.208984375,
          "content": "// QListCtrl.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"QListCtrl.h\"\r\n#include \"ProcessPaste.h\"\r\n#include \"BitmapHelper.h\"\r\n#include \"MainTableFunctions.h\"\r\n#include \"DittoCopyBuffer.h\"\r\n#include <atlbase.h>\r\n#include \"DrawHTML.h\"\r\n#include \"Shared\\TextConvert.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n#define ROW_BOTTOM_BORDER\t\t4\r\n#define ROW_LEFT_BORDER\t\t\t3\r\n#define COLOR_SHADOW\t\t\tRGB(245, 245, 245)\r\n#define DUMMY_COL_WIDTH\t\t\t2\r\n\r\n#define TIMER_SHOW_PROPERTIES\t1\r\n#define TIMER_HIDE_SCROL\t2\r\n#define TIMER_SHOW_SCROLL\t3\r\n\r\n#define VALID_TOOLTIP (m_pToolTip && ::IsWindow(m_pToolTip->m_hWnd))\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CQListCtrl\r\n\r\nCQListCtrl::CQListCtrl()\r\n{\r\n\tm_pchTip = NULL;\r\n\tm_pwchTip = NULL;\r\n\tm_linesPerRow = 1;\r\n\tm_windowDpi = NULL;\r\n\tm_SmallFont = NULL;\r\n\tm_pToolTip = NULL;\r\n\tm_pFormatter = NULL;\r\n\tm_allSelected = false;\r\n\tm_rowHeight = 50;\r\n\tm_mouseOverScrollAreaStart = 0;\r\n\tm_showIfClipWasPasted = TRUE;\r\n\tm_bShowTextForFirstTenHotKeys = true;\r\n\tm_pToolTipActions = NULL;\r\n}\r\n\r\nCQListCtrl::~CQListCtrl()\r\n{\r\n\tif (m_pchTip != NULL)\r\n\t\tdelete m_pchTip;\r\n\r\n\tif (m_pwchTip != NULL)\r\n\t\tdelete m_pwchTip;\r\n\r\n\tif (m_SmallFont)\r\n\t\t::DeleteObject(m_SmallFont);\r\n\r\n\tm_Font.DeleteObject();\r\n\r\n\tm_boldFont.DeleteObject();\r\n\r\n\tif (m_pFormatter)\r\n\t{\r\n\t\tdelete m_pFormatter;\r\n\t\tm_pFormatter = NULL;\r\n\t}\r\n\r\n\tDeleteObject(m_SmallFont);\r\n}\r\n\r\n// returns the position 1-10 if the index is in the FirstTen block else -1\r\nint CQListCtrl::GetFirstTenNum(int index)\r\n{\r\n\t// set firstTenNum to the first ten number (1-10) corresponding to the given index\r\n\tint firstTenNum = -1; // -1 means that nItem is not in the FirstTen block.\r\n\tint count = GetItemCount();\r\n\r\n\tif (0 <= index && index <= 9)\r\n\t{\r\n\t\tfirstTenNum = index + CGetSetOptions::m_firstTenHotKeysStart;\r\n\t\tfirstTenNum = firstTenNum % 10;\r\n\t}\r\n\r\n\treturn firstTenNum;\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CQListCtrl, CListCtrl)\r\n\t//{{AFX_MSG_MAP(CQListCtrl)\r\n\tON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)\r\n\tON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomdrawList)\r\n\tON_WM_MOUSEMOVE()\r\n\tON_WM_SYSKEYDOWN()\r\n\tON_WM_ERASEBKGND()\r\n\tON_WM_CREATE()\r\n\tON_WM_HSCROLL()\r\n\tON_WM_TIMER()\r\n\tON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnSelectionChange)\r\n\tON_WM_VSCROLL()\r\n\tON_WM_WINDOWPOSCHANGED()\r\n\t//}}AFX_MSG_MAP\r\n\tON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnToolTipText)\r\n\tON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnToolTipText)\r\n\tON_WM_KILLFOCUS()\r\n\tON_WM_MEASUREITEM_REFLECT()\r\n\tON_WM_MOUSEHWHEEL()\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CQListCtrl message handlers\r\n\r\nvoid CQListCtrl::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)\r\n{\r\n\tLV_KEYDOWN* pLVKeyDown = (LV_KEYDOWN*)pNMHDR;\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\nDROPEFFECT CQListCtrl::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\r\n{\r\n\treturn DROPEFFECT_COPY;\r\n}\r\n\r\nvoid CQListCtrl::GetSelectionIndexes(ARRAY &arr)\r\n{\r\n\tarr.RemoveAll();\r\n\r\n\tPOSITION pos = GetFirstSelectedItemPosition();\r\n\twhile (pos)\r\n\t{\r\n\t\tarr.Add(GetNextSelectedItem(pos));\r\n\t}\r\n}\r\n\r\nbool CQListCtrl::PutSelectedItemOnDittoCopyBuffer(long lBuffer)\r\n{\r\n\tbool bRet = false;\r\n\tARRAY arr;\r\n\tGetSelectionItemData(arr);\r\n\tINT_PTR nCount = arr.GetSize();\r\n\tif (nCount > 0 && arr[0])\r\n\t{\r\n\t\tCDittoCopyBuffer::PutClipOnDittoCopyBuffer(arr[0], lBuffer);\r\n\t\tbRet = true;\r\n\t}\r\n\r\n\treturn bRet;\r\n}\r\n\r\nvoid CQListCtrl::GetSelectionItemData(ARRAY &arr)\r\n{\r\n\tDWORD dwData;\r\n\tint i;\r\n\tarr.RemoveAll();\r\n\tPOSITION pos = GetFirstSelectedItemPosition();\r\n\twhile (pos)\r\n\t{\r\n\t\ti = GetNextSelectedItem(pos);\r\n\t\tdwData = GetItemData(i);\r\n\t\tarr.Add(dwData);\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::RemoveAllSelection()\r\n{\r\n\tPOSITION pos = GetFirstSelectedItemPosition();\r\n\twhile (pos)\r\n\t{\r\n\t\tSetSelection(GetNextSelectedItem(pos), FALSE);\r\n\t}\r\n}\r\n\r\nBOOL CQListCtrl::SetSelection(int nRow, BOOL bSelect)\r\n{\r\n\tif (bSelect)\r\n\t\treturn SetItemState(nRow, LVIS_SELECTED, LVIS_SELECTED);\r\n\telse\r\n\t\treturn SetItemState(nRow, ~LVIS_SELECTED, LVIS_SELECTED);\r\n}\r\n\r\nBOOL CQListCtrl::SetText(int nRow, int nCol, CString cs)\r\n{\r\n\treturn SetItemText(nRow, nCol, cs);\r\n}\r\n\r\nBOOL CQListCtrl::SetCaret(int nRow, BOOL bFocus)\r\n{\r\n\tif (bFocus)\r\n\t\treturn SetItemState(nRow, LVIS_FOCUSED, LVIS_FOCUSED);\r\n\telse\r\n\t\treturn SetItemState(nRow, ~LVIS_FOCUSED, LVIS_FOCUSED);\r\n}\r\n\r\nlong CQListCtrl::GetCaret()\r\n{\r\n\treturn GetNextItem(-1, LVNI_FOCUSED);\r\n}\r\n\r\n// moves the caret to the given index, selects it, and ensures it is visible.\r\nBOOL CQListCtrl::SetListPos(int index)\r\n{\r\n\tif (index < 0 || index >= GetItemCount())\r\n\t\treturn FALSE;\r\n\r\n\tRemoveAllSelection();\r\n\tSetCaret(index);\r\n\tSetSelection(index);\r\n\tListView_SetSelectionMark(m_hWnd, index);\r\n\tEnsureVisible(index, FALSE);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CQListCtrl::SetFormattedText(int nRow, int nCol, LPCTSTR lpszFormat, ...)\r\n{\r\n\tCString csText;\r\n\tva_list vlist;\r\n\r\n\tASSERT(AfxIsValidString(lpszFormat));\r\n\tva_start(vlist, lpszFormat);\r\n\tcsText.FormatV(lpszFormat, vlist);\r\n\tva_end(vlist);\r\n\r\n\treturn SetText(nRow, nCol, csText);\r\n}\r\n\r\nvoid CQListCtrl::SetNumberOfLinesPerRow(int nLines, bool force)\r\n{\r\n\tif (m_linesPerRow != nLines ||\r\n\t\tforce)\r\n\t{\r\n\t\tm_linesPerRow = nLines;\r\n\r\n\t\tCRect rc;\r\n\t\tGetWindowRect(&rc);\r\n\t\tWINDOWPOS wp;\r\n\t\twp.hwnd = m_hWnd;\r\n\t\twp.cx = rc.Width();\r\n\t\twp.cy = rc.Height();\r\n\t\twp.flags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER;\r\n\t\tSendMessage(WM_WINDOWPOSCHANGED, 0, (LPARAM)&wp);\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)\r\n{\r\n\tTEXTMETRIC tm;\r\n\tHDC hDC = ::GetDC(NULL);\r\n\tCFont* pFont = GetFont();\r\n\tHFONT hFontOld = (HFONT)SelectObject(hDC, pFont->GetSafeHandle());\r\n\tGetTextMetrics(hDC, &tm);\r\n\tif (m_windowDpi != NULL)\r\n\t{\r\n\t\tlpMeasureItemStruct->itemHeight = ((tm.tmHeight + tm.tmExternalLeading) * m_linesPerRow) + m_windowDpi->Scale(ROW_BOTTOM_BORDER);\r\n\t\tm_rowHeight = lpMeasureItemStruct->itemHeight;\r\n\t}\r\n\tSelectObject(hDC, hFontOld);\r\n\t::ReleaseDC(NULL, hDC);\r\n}\r\n\r\nvoid CQListCtrl::OnCustomdrawList(NMHDR* pNMHDR, LRESULT* pResult)\r\n{\r\n\tNMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>(pNMHDR);\r\n\r\n\t*pResult = 0;\r\n\r\n\t// Request item-specific notifications if this is the\r\n\t// beginning of the paint cycle.\r\n\tif (CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage)\r\n\t{\r\n\t\t*pResult = CDRF_NOTIFYITEMDRAW;\r\n\t}\r\n\telse if (CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage)\r\n\t{\r\n\t\tLVITEM   rItem;\r\n\t\tint      nItem = static_cast<int>(pLVCD->nmcd.dwItemSpec);\r\n\t\tCDC*     pDC = CDC::FromHandle(pLVCD->nmcd.hdc);\r\n\t\tCOLORREF crBkgnd;\r\n\t\tBOOL     bListHasFocus;\r\n\t\tCRect    rcItem;\r\n\r\n\t\tbListHasFocus = (GetSafeHwnd() == ::GetFocus());\r\n\r\n\t\t// Get the image index and selected/focused state of the\r\n\t\t// item being drawn.\r\n\t\tZeroMemory(&rItem, sizeof(LVITEM));\r\n\t\trItem.mask = LVIF_STATE;\r\n\t\trItem.iItem = nItem;\r\n\t\trItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;\r\n\t\tGetItem(&rItem);\r\n\r\n\t\t// Get the rect that bounds the text label.\r\n\t\tGetItemRect(nItem, rcItem, LVIR_SELECTBOUNDS);\r\n\r\n\t\tCOLORREF OldColor = -1;\r\n\t\tint nOldBKMode = -1;\r\n\r\n\t\tCString csText;\r\n\t\tLPTSTR lpszText = csText.GetBufferSetLength(CGetSetOptions::m_bDescTextSize);\r\n\t\tGetItemText(nItem, 0, lpszText, CGetSetOptions::m_bDescTextSize);\r\n\t\tcsText.ReleaseBuffer();\r\n\r\n\t\t// extract symbols\r\n\t\tCString strSymbols;\r\n\t\tint nSymEnd = csText.Find('|');\r\n\t\tif (nSymEnd >= 0)\r\n\t\t{\r\n\t\t\tstrSymbols = csText.Left(nSymEnd);\r\n\t\t\tcsText = csText.Mid(nSymEnd + 1);\r\n\t\t}\r\n\r\n\t\t// Draw the background of the list item.  Colors are selected \r\n\t\t// according to the item's state.\r\n\t\tif (rItem.state & LVIS_SELECTED)\r\n\t\t{\r\n\t\t\tif (bListHasFocus)\r\n\t\t\t{\r\n\t\t\t\tcrBkgnd = CGetSetOptions::m_Theme.ListBoxSelectedBG();\r\n\t\t\t\tOldColor = pDC->SetTextColor(CGetSetOptions::m_Theme.ListBoxSelectedText());\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcrBkgnd = CGetSetOptions::m_Theme.ListBoxSelectedNoFocusBG();\r\n\t\t\t\tOldColor = pDC->SetTextColor(CGetSetOptions::m_Theme.ListBoxSelectedNoFocusText());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//Shade alternating Rows\r\n\t\t\tif ((nItem % 2) == 0)\r\n\t\t\t{\r\n\t\t\t\tcrBkgnd = CGetSetOptions::m_Theme.ListBoxOddRowsBG();\r\n\t\t\t\tOldColor = pDC->SetTextColor(CGetSetOptions::m_Theme.ListBoxOddRowsText());\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcrBkgnd = CGetSetOptions::m_Theme.ListBoxEvenRowsBG();\r\n\t\t\t\tOldColor = pDC->SetTextColor(CGetSetOptions::m_Theme.ListBoxEvenRowsText());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpDC->FillSolidRect(rcItem, crBkgnd);\r\n\t\tnOldBKMode = pDC->SetBkMode(TRANSPARENT);\r\n\r\n\t\tCRect rcText = rcItem;\r\n\t\trcText.left += m_windowDpi->Scale(ROW_LEFT_BORDER);\r\n\t\trcText.top += m_windowDpi->Scale(1);\r\n\t\trcText.bottom -= m_windowDpi->Scale(1);\r\n\r\n\t\tif (m_showIfClipWasPasted &&\r\n\t\t\tstrSymbols.GetLength() > 0 &&\r\n\t\t\tstrSymbols.Find(_T(\"<pasted>\")) >= 0) //clip was pasted from ditto \r\n\t\t{\r\n\t\t\tCRect pastedRect(rcItem);\r\n\t\t\tpastedRect.left++;\r\n\t\t\tpastedRect.right = pastedRect.left + m_windowDpi->Scale(2);\r\n\r\n\t\t\tpDC->FillSolidRect(pastedRect, CGetSetOptions::m_Theme.ClipPastedColor());\r\n\t\t}\r\n\r\n\t\t// set firstTenNum to the first ten number (1-10) corresponding to\r\n\t\t//  the current nItem.\r\n\t\t// -1 means that nItem is not in the FirstTen block.\r\n\t\tint firstTenNum = GetFirstTenNum(nItem);\r\n\r\n\t\tif (m_bShowTextForFirstTenHotKeys && firstTenNum >= 0)\r\n\t\t{\r\n\t\t\trcText.left += m_windowDpi->Scale(12);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\trcText.left += m_windowDpi->Scale(3);\r\n\t\t}\r\n\r\n\t\tbool drawInGroupIcon = true;\r\n\t\t// if we are inside a group, don't display the \"in group\" flag\r\n\t\tif (theApp.m_GroupID > 0)\r\n\t\t{\r\n\t\t\tint nFlag = strSymbols.Find(_T(\"<ingroup>\"));\r\n\t\t\tif (nFlag >= 0)\r\n\t\t\t\tdrawInGroupIcon = false;\r\n\t\t}\r\n\r\n\t\tDrawCopiedColorCode(csText, rcText, pDC);\r\n\r\n\t\tDrawBitMap(nItem, rcText, pDC, csText);\r\n\r\n\t\t// draw the symbol box\r\n\t\tif (strSymbols.GetLength() > 0)\r\n\t\t{\r\n\t\t\tif (strSymbols.Find(_T(\"<group>\")) >= 0) //group \r\n\t\t\t{\r\n\t\t\t\tm_groupFolder.Draw(pDC, *m_windowDpi, this, rcText.left, rcText.top, false, false);\r\n\t\t\t\trcText.left += m_groupFolder.ImageWidth() + m_windowDpi->Scale(2);\r\n\t\t\t}\r\n\t\t\tif (strSymbols.Find(_T(\"<noautodelete>\")) >= 0) //don't auto delete\r\n\t\t\t{\r\n\t\t\t\tm_dontDeleteImage.Draw(pDC, *m_windowDpi, this, rcText.left, rcText.top, false, false);\r\n\t\t\t\trcText.left += m_dontDeleteImage.ImageWidth() + m_windowDpi->Scale(2);\r\n\t\t\t}\r\n\t\t\tif (strSymbols.Find(_T(\"<shortcut>\")) >= 0) // has shortcut\r\n\t\t\t{\r\n\t\t\t\tm_shortCutImage.Draw(pDC, *m_windowDpi, this, rcText.left, rcText.top, false, false);\r\n\t\t\t\trcText.left += m_shortCutImage.ImageWidth() + m_windowDpi->Scale(2);\r\n\t\t\t}\r\n\t\t\tif (drawInGroupIcon &&\r\n\t\t\t\tstrSymbols.Find(_T(\"<ingroup>\")) >= 0) // in group\r\n\t\t\t{\r\n\t\t\t\tm_inFolderImage.Draw(pDC, *m_windowDpi, this, rcText.left, rcText.top, false, false);\r\n\t\t\t\trcText.left += m_inFolderImage.ImageWidth() + m_windowDpi->Scale(2);\r\n\t\t\t}\r\n\t\t\tif (strSymbols.Find(_T(\"<qpastetext>\")) >= 0) // has quick paste text\r\n\t\t\t{\r\n\t\t\t}\r\n\t\t\tif (strSymbols.Find(_T(\"<sticky>\")) >= 0) //sticky clip\r\n\t\t\t{\r\n\t\t\t\tm_stickyImage.Draw(pDC, *m_windowDpi, this, rcText.left, rcText.top, false, false);\r\n\t\t\t\trcText.left += m_stickyImage.ImageWidth() + m_windowDpi->Scale(2);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (DrawRtfText(nItem, rcText, pDC) == FALSE)\r\n\t\t{\r\n\t\t\tauto highlightColor = CGetSetOptions::m_Theme.SearchTextHighlight();\r\n\t\t\t//use unprintable characters so it doesn't find copied html to convert\r\n\t\t\tif (m_searchText.GetLength() > 0 &&\r\n\t\t\t\tFindNoCaseAndInsert(csText, m_searchText, StrF(_T(\"\\x01\\x04 color='#%02x%02x%02x'\\x02\"), GetRValue(highlightColor), GetGValue(highlightColor), GetBValue(highlightColor)), _T(\"\\x01\\x03\\x04\\x02\"), m_linesPerRow) > 0)\r\n\t\t\t{\r\n\t\t\t\tDrawHTML(pDC->m_hDC, csText, csText.GetLength(), rcText, DT_VCENTER | DT_EXPANDTABS | DT_NOPREFIX);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpDC->DrawText(csText, rcText, DT_VCENTER | DT_EXPANDTABS | DT_NOPREFIX);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Draw a focus rect around the item if necessary.\r\n\t\t//if(bListHasFocus && (rItem.state & LVIS_FOCUSED))\r\n\t\t//\tpDC->DrawFocusRect(rcItem);\r\n\r\n\t\tif (m_bShowTextForFirstTenHotKeys && firstTenNum >= 0)\r\n\t\t{\r\n\t\t\tCString cs;\r\n\t\t\tif (firstTenNum == 10)\r\n\t\t\t\tcs = \"0\";\r\n\t\t\telse\r\n\t\t\t\tcs.Format(_T(\"%d\"), firstTenNum);\r\n\r\n\t\t\tCRect crClient;\r\n\r\n\t\t\tGetWindowRect(crClient);\r\n\t\t\tScreenToClient(crClient);\r\n\r\n\t\t\tCRect crHotKey = rcItem;\r\n\r\n\t\t\tint extraFromClipWasPaste = 0;\r\n\t\t\tif (m_showIfClipWasPasted)\r\n\t\t\t\textraFromClipWasPaste = 3;\r\n\r\n\t\t\tcrHotKey.right = crHotKey.left + m_windowDpi->Scale(11);\r\n\t\t\tcrHotKey.left += m_windowDpi->Scale(1 + extraFromClipWasPaste);\r\n\t\t\tcrHotKey.top += m_windowDpi->Scale(1 + extraFromClipWasPaste);\r\n\r\n\t\t\tHFONT hOldFont = (HFONT)pDC->SelectObject(m_SmallFont);\r\n\t\t\tCOLORREF localOldTextColor = pDC->SetTextColor(CGetSetOptions::m_Theme.ListSmallQuickPasteIndexColor());\r\n\r\n\t\t\tCPen pen(PS_SOLID, 0, CGetSetOptions::m_Theme.ListSmallQuickPasteIndexColor());\r\n\t\t\tCPen* pOldPen = pDC->SelectObject(&pen);\r\n\r\n\t\t\tpDC->DrawText(cs, crHotKey, DT_BOTTOM);\r\n\r\n\t\t\tpDC->MoveTo(CPoint(rcItem.left + m_windowDpi->Scale(8 + extraFromClipWasPaste), rcItem.top));\r\n\t\t\tpDC->LineTo(CPoint(rcItem.left + m_windowDpi->Scale(8 + extraFromClipWasPaste), rcItem.bottom));\r\n\r\n\t\t\tpDC->SelectObject(hOldFont);\r\n\t\t\tpDC->SetTextColor(localOldTextColor);\r\n\t\t\tpDC->SelectObject(pOldPen);\r\n\t\t}\r\n\r\n\t\t// restore the previous values\t\t\r\n\t\tif (OldColor > -1)\r\n\t\t\tpDC->SetTextColor(OldColor);\r\n\r\n\t\tif (nOldBKMode > -1)\r\n\t\t\tpDC->SetBkMode(nOldBKMode);\r\n\r\n\t\t*pResult = CDRF_SKIPDEFAULT;    // We've painted everything.\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::DrawCopiedColorCode(CString& csText, CRect& rcText, CDC* pDC)\r\n{\r\n\tif (CGetSetOptions::m_bDrawCopiedColorCode == FALSE)\r\n\t\treturn;\r\n\r\n\tCString trimmedText = CString(csText).Trim(L'').Trim().Trim('#');\r\n\r\n\t//draw hex color copied like #FF0000, FF0000, FF0000 other text with a space before other text\r\n\tif (trimmedText.GetLength() == 6 ||\r\n\t\ttrimmedText.Find(' ') == 6)\r\n\t{\r\n\t\tint r, g, b;\r\n\t\tint scanRet = swscanf(trimmedText, _T(\"%02x%02x%02x\"), &r, &g, &b);\r\n\t\tif (scanRet == 3)\r\n\t\t{\r\n\t\t\tCRect pastedRect(rcText);\r\n\t\t\tpastedRect.right = pastedRect.left + m_windowDpi->Scale(rcText.Height());\r\n\r\n\t\t\tpDC->FillSolidRect(pastedRect, COLORREF(RGB(r, g, b)));\r\n\r\n\t\t\trcText.left += m_windowDpi->Scale(rcText.Height());\r\n\t\t\trcText.left += m_windowDpi->Scale(ROW_LEFT_BORDER);\r\n\t\t}\r\n\t}\r\n\r\n\t// draw rgb color copied like 255,0,0 and rgb(255,0,0)\r\n\tint firstCommaPos = trimmedText.Find(',');\r\n\tif (firstCommaPos >= 0)\r\n\t{\r\n\t\tint secondCommaPos = trimmedText.Find(',', firstCommaPos+1);\r\n\t\tif (secondCommaPos)\r\n\t\t{\r\n\t\t\tint noThirdCommaPos = trimmedText.Find(',', secondCommaPos+1);\r\n\t\t\t\r\n\t\t\tif (noThirdCommaPos < 0)\r\n\t\t\t{\r\n\t\t\t\tint r, g, b;\r\n\t\t\t\tCString noRGB = trimmedText.MakeLower().Trim(_T(\"rgb(\")).Trim(')');\r\n\t\t\t\tint scanRet = swscanf(noRGB, _T(\"%d,%d,%d\"), &r, &g, &b);\r\n\t\t\t\tif (scanRet == 3)\r\n\t\t\t\t{\r\n\t\t\t\t\tCRect pastedRect(rcText);\r\n\t\t\t\t\tpastedRect.right = pastedRect.left + m_windowDpi->Scale(rcText.Height());\r\n\r\n\t\t\t\t\tpDC->FillSolidRect(pastedRect, COLORREF(RGB(r, g, b)));\r\n\r\n\t\t\t\t\trcText.left += m_windowDpi->Scale(rcText.Height());\r\n\t\t\t\t\trcText.left += m_windowDpi->Scale(ROW_LEFT_BORDER);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBOOL CQListCtrl::DrawRtfText(int nItem, CRect &crRect, CDC *pDC)\r\n{\r\n\tif (CGetSetOptions::m_bDrawRTF == FALSE)\r\n\t\treturn FALSE;\r\n\r\n\tBOOL bRet = FALSE;\r\n\r\n\tCClipFormat* pThumbnail = GetItem_CF_RTF_ClipFormat(nItem);\r\n\tif (pThumbnail == NULL)\r\n\t\treturn FALSE;\r\n\r\n\t// if there's no data, then we're done.\r\n\tif (pThumbnail->m_hgData == NULL)\r\n\t\treturn FALSE;\r\n\r\n\tif (m_pFormatter == NULL)\r\n\t{\r\n\t\tm_pFormatter = new CFormattedTextDraw;\r\n\t\tm_pFormatter->Create();\r\n\t}\r\n\r\n\tif (m_rtfFormater.m_hWnd == NULL)\r\n\t{\r\n\t\tm_rtfFormater.Create(_T(\"\"), _T(\"\"), WS_CHILD | WS_VSCROLL |\r\n\t\t\tWS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_NOHIDESEL |\r\n\t\t\tES_AUTOHSCROLL, CRect(0, 0, 0, 0), this, -1);\r\n\t}\r\n\r\n\tif (m_pFormatter)\r\n\t{\r\n\t\t//somehow ms word places crazy rtf text onto the clipboard and our draw routine doesn't handle that\r\n\t\t//pass the rtf text into a richtext control and get it out and the contorl will clean  the rtf so our routine can draw it\r\n\t\tm_rtfFormater.SetRTF(pThumbnail->GetAsCStringA());\r\n\t\tCString betterRTF = m_rtfFormater.GetRTF();\r\n\r\n\t\tCComBSTR bStr(betterRTF);\r\n\t\tm_pFormatter->put_RTFText(bStr);\r\n\r\n\t\tm_pFormatter->Draw(pDC->m_hDC, crRect);\r\n\r\n\t\tbRet = TRUE;\r\n\t}\r\n\r\n\treturn bRet;\r\n}\r\n\r\n// DrawBitMap loads a DIB from the DB, draws a crRect thumbnail of the image\r\n//  to pDC and caches that thumbnail as a DIB in m_ThumbNails[ ItemID ].\r\n// ALL items are cached in m_ThumbNails (those without images are cached with NULL m_hgData)\r\nBOOL CQListCtrl::DrawBitMap(int nItem, CRect &crRect, CDC *pDC, const CString &csDescription)\r\n{\r\n\tif (CGetSetOptions::m_bDrawThumbnail == FALSE)\r\n\t\treturn FALSE;\r\n\r\n\tCClipFormatQListCtrl *format = GetItem_CF_DIB_ClipFormat(nItem);\r\n\tif (format != NULL)\r\n\t{\r\n\t\tHGLOBAL smallImage = format->GetDibFittingToHeight(pDC, crRect.Height());\r\n\t\tif (smallImage != NULL)\r\n\t\t{\r\n\t\t\t//Will return the width of the bitmap in nWidth\r\n\t\t\tint nWidth = 0;\r\n\t\t\tif (CBitmapHelper::DrawDIB(pDC, smallImage, crRect.left, crRect.top, nWidth))\r\n\t\t\t{\r\n\t\t\t\t// adjust the rect so other information can be drawn next to the thumbnail\r\n\t\t\t\tcrRect.left += nWidth + 3;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (csDescription.Find(_T(\"CF_DIB\")) == 0)\r\n\t{\r\n\t\tcrRect.left += crRect.Height();\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQListCtrl::RefreshVisibleRows()\r\n{\r\n\tint nTopIndex = GetTopIndex();\r\n\tint nLastIndex = nTopIndex + GetCountPerPage();\r\n\tRedrawItems(nTopIndex, nLastIndex);\r\n}\r\n\r\nvoid CQListCtrl::RefreshRow(int row)\r\n{\r\n\tRedrawItems(row, row);\r\n}\r\n\r\nvoid CQListCtrl::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)\r\n{\r\n\tCListCtrl::OnSysKeyDown(nChar, nRepCnt, nFlags);\r\n}\r\n\r\nBOOL CQListCtrl::OnEraseBkgnd(CDC* pDC)\r\n{\r\n\r\n\tCRect rect;\r\n\tGetClientRect(&rect);\r\n\tCBrush myBrush(CGetSetOptions::m_Theme.MainWindowBG());    // dialog background color\r\n\tCBrush *pOld = pDC->SelectObject(&myBrush);\r\n\tBOOL bRes = pDC->PatBlt(0, 0, rect.Width(), rect.Height(), PATCOPY);\r\n\tpDC->SelectObject(pOld);    // restore old brush\r\n\treturn bRes;                       // CDialog::OnEraseBkgnd(pDC);\r\n\r\n\t// Simply returning TRUE seems OK since we do custom item\r\n\t//\tpainting.  However, there is a pixel buffer around the\r\n\t//\tborder of this control (not within the item rects)\r\n\t//\twhich becomes visually corrupt if it is not erased.\r\n\r\n\t// In most cases, I do not notice the erasure, so I have kept\r\n\t//\tthe call to CListCtrl::OnEraseBkgnd(pDC);\r\n\r\n\t// However, for some reason, bulk erasure is very noticeable when\r\n\t//\tshift-scrolling the page to select a block of items, so\r\n\t//\tI made a special case for that:\r\n\t//if(GetSelectedCount() >= 2)\r\n\t//\treturn TRUE;\r\n\t//return CListCtrl::OnEraseBkgnd(pDC);\r\n}\r\n\r\nBOOL CQListCtrl::OnToolTipText(UINT id, NMHDR * pNMHDR, LRESULT * pResult)\r\n{\r\n\t// need to handle both ANSI and UNICODE versions of the message\r\n\tTOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;\r\n\tTOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;\r\n\tCString strTipText;\r\n\r\n\tUINT_PTR nID = pNMHDR->idFrom;\r\n\r\n\tif (nID == 0)\t  \t// Notification in NT from automatically\r\n\t\treturn FALSE;   \t// created tooltip\r\n\r\n\t::SendMessage(pNMHDR->hwndFrom, TTM_SETMAXTIPWIDTH, 0, 500);\r\n\r\n\tif (CGetSetOptions::m_tooltipTimeout > 0)\r\n\t{\r\n\t\t::SendMessage(pNMHDR->hwndFrom, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM(CGetSetOptions::m_tooltipTimeout, 0));\r\n\t}\r\n\r\n\t// Use Item's name as the tool tip. Change this for something different.\r\n\t// Like use its file size, etc.\r\n\tGetToolTipText((int)nID - 1, strTipText);\r\n\r\n\t//Replace the tabs with spaces, the tooltip didn't like the \\t s\r\n\tstrTipText.Replace(_T(\"\\t\"), _T(\"  \"));\r\n\r\n\tint nLength = strTipText.GetLength() + 2;\r\n\r\n#ifndef _UNICODE\r\n\tif (pNMHDR->code == TTN_NEEDTEXTA)\r\n\t{\r\n\t\tif (m_pchTip != NULL)\r\n\t\t\tdelete m_pchTip;\r\n\r\n\t\tm_pchTip = new TCHAR[nLength];\r\n\t\tlstrcpyn(m_pchTip, strTipText, nLength - 1);\r\n\t\tm_pchTip[nLength - 1] = 0;\r\n\t\tpTTTW->lpszText = (WCHAR*)m_pchTip;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (m_pwchTip != NULL)\r\n\t\t\tdelete m_pwchTip;\r\n\r\n\t\tm_pwchTip = new WCHAR[nLength];\r\n\t\t_mbstowcsz(m_pwchTip, strTipText, nLength - 1);\r\n\t\tm_pwchTip[nLength - 1] = 0; // end of text\r\n\t\tpTTTW->lpszText = (WCHAR*)m_pwchTip;\r\n\t}\r\n#else\r\n\tif (pNMHDR->code == TTN_NEEDTEXTA)\r\n\t{\r\n\t\tif (m_pchTip != NULL)\r\n\t\t\tdelete m_pchTip;\r\n\r\n\t\tm_pchTip = new TCHAR[nLength];\r\n\t\tSTRNCPY(m_pchTip, strTipText, nLength - 1);\r\n\t\tm_pchTip[nLength - 1] = 0; // end of text\r\n\t\tpTTTW->lpszText = (LPTSTR)m_pchTip;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (m_pwchTip != NULL)\r\n\t\t\tdelete m_pwchTip;\r\n\r\n\t\tm_pwchTip = new WCHAR[nLength];\r\n\t\tlstrcpyn(m_pwchTip, strTipText, nLength - 1);\r\n\t\tm_pwchTip[nLength - 1] = 0;\r\n\t\tpTTTW->lpszText = (LPTSTR)m_pwchTip;\r\n\t}\r\n#endif\r\n\t*pResult = 0;\r\n\r\n\treturn TRUE;    // message was handled\r\n}\r\n\r\nINT_PTR CQListCtrl::OnToolHitTest(CPoint point, TOOLINFO * pTI) const\r\n{\r\n\tCRect rect;\r\n\tGetClientRect(&rect);\r\n\tif (rect.PtInRect(point))\r\n\t{\r\n\t\tif (GetItemCount())\r\n\t\t{\r\n\t\t\tint nTopIndex = GetTopIndex();\r\n\t\t\tint nBottomIndex = nTopIndex + GetCountPerPage();\r\n\t\t\tif (nBottomIndex > GetItemCount()) nBottomIndex = GetItemCount();\r\n\t\t\tfor (int nIndex = nTopIndex; nIndex <= nBottomIndex; nIndex++)\r\n\t\t\t{\r\n\t\t\t\tGetItemRect(nIndex, rect, LVIR_BOUNDS);\r\n\t\t\t\tif (rect.PtInRect(point))\r\n\t\t\t\t{\r\n\t\t\t\t\tpTI->hwnd = m_hWnd;\r\n\t\t\t\t\tpTI->uId = (UINT)(nIndex + 1);\r\n\t\t\t\t\tpTI->lpszText = LPSTR_TEXTCALLBACK;\r\n\t\t\t\t\tpTI->rect = rect;\r\n\t\t\t\t\tpTI->uFlags = TTF_TRANSPARENT;\r\n\t\t\t\t\treturn pTI->uId;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\nint CQListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CListCtrl::OnCreate(lpCreateStruct) == -1)\r\n\t\treturn -1;\r\n\r\n\tif (CGetSetOptions::m_tooltipTimeout > 0 ||\r\n\t\tCGetSetOptions::m_tooltipTimeout == -1)\r\n\t{\r\n\t\tEnableToolTips();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEnableToolTips(FALSE);\r\n\t}\r\n\r\n\t//m_pToolTip = new CToolTipEx;\r\n\t//m_pToolTip->Create(this);\r\n\r\n\t//m_pToolTip->SetNotifyWnd(GetParent());\r\n\r\n\treturn 0;\r\n}\r\n\r\nBOOL CQListCtrl::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\tCAccel a;\r\n\tif (m_Accels.OnMsg(pMsg, a))\r\n\t{\r\n\t\tswitch (a.Cmd)\r\n\t\t{\r\n\t\tcase COPY_BUFFER_HOT_KEY_1_ID:\r\n\t\t\tPutSelectedItemOnDittoCopyBuffer(0);\r\n\t\t\tbreak;\r\n\t\tcase COPY_BUFFER_HOT_KEY_2_ID:\r\n\t\t\tPutSelectedItemOnDittoCopyBuffer(1);\r\n\t\t\tbreak;\r\n\t\tcase COPY_BUFFER_HOT_KEY_3_ID:\r\n\t\t\tPutSelectedItemOnDittoCopyBuffer(2);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tif (a.RefId == CHotKey::PASTE_OPEN_CLIP)\r\n\t\t\t{\r\n\t\t\t\tGetParent()->SendMessage(NM_SELECT_DB_ID, a.Cmd, 0);\r\n\t\t\t}\r\n\t\t\telse if (a.RefId == CHotKey::MOVE_TO_GROUP)\r\n\t\t\t{\r\n\t\t\t\tGetParent()->SendMessage(NM_MOVE_TO_GROUP, a.Cmd, 0);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tif (m_pToolTip->OnMsg(pMsg))\r\n\t\t\treturn TRUE;\r\n\t}\r\n\r\n\tswitch (pMsg->message)\r\n\t{\r\n\tcase WM_KEYDOWN:\r\n\t\tif (HandleKeyDown(pMsg->wParam, pMsg->lParam))\r\n\t\t\treturn TRUE;\r\n\t\tbreak; // end case WM_KEYDOWN\r\n\tcase WM_MOUSEWHEEL:\r\n\t\tbreak;\r\n\r\n\tcase WM_VSCROLL:\r\n\t\tASSERT(FALSE);\r\n\t\tbreak;\r\n\t} // end switch(pMsg->message)\r\n\r\n\treturn CListCtrl::PreTranslateMessage(pMsg);\r\n}\r\n\r\nBOOL CQListCtrl::HandleKeyDown(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tMSG Msg;\r\n\t\tMsg.lParam = lParam;\r\n\t\tMsg.wParam = wParam;\r\n\t\tMsg.message = WM_KEYDOWN;\r\n\t\tif (m_pToolTip->OnMsg(&Msg))\r\n\t\t\treturn TRUE;\r\n\t}\r\n\r\n\tWPARAM vk = wParam;\r\n\r\n\tswitch (vk)\r\n\t{\r\n\tcase 'A': // Ctrl-A = Select All\r\n\t\tif (CONTROL_PRESSED)\r\n\t\t{\r\n\t\t\tint nCount = GetItemCount();\r\n\t\t\tfor (int i = 0; i < nCount; i++)\r\n\t\t\t{\r\n\t\t\t\tSetSelection(i);\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase VK_HOME:\r\n\r\n\t\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t\t{\r\n\t\t\tint pos = (int)GetFirstSelectedItemPosition();\r\n\t\t\tif (pos >= 0 && pos < GetItemCount())\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < pos; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tSetSelection(i, (i == 0));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSetListPos(0);\r\n\t\t}\r\n\t\tbreak;\r\n\t} // end switch(vk)\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nbool CQListCtrl::PostEventLoadedCheckDescription(int updatedRow)\r\n{\r\n\tbool loadedClip = false;\r\n\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tint toolTipClipId = m_pToolTip->GetClipId();\r\n\t\tint toolTipClipRow = m_pToolTip->GetClipRow();\r\n\r\n\t\tif (toolTipClipRow >= 0)\r\n\t\t{\r\n\t\t\tlog(StrF(_T(\"PostEventLoadedCheckDescription refreshRow: %d tt_row: %d tt_id: %d\"), updatedRow, toolTipClipRow, toolTipClipId));\r\n\t\t}\r\n\r\n\t\t//We tried to show the clip but we didn't have the id yet, it was loaded in a thread, now it's being updated\r\n\t\t//see if we need to show this rows description\r\n\t\tif (toolTipClipId <= 0 &&\r\n\t\t\ttoolTipClipRow == updatedRow &&\r\n\t\t\t::IsWindow(m_toolTipHwnd))\r\n\t\t{\r\n\t\t\tShowFullDescription(false, true);\r\n\t\t\tloadedClip = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn loadedClip;\r\n}\r\n\r\nbool CQListCtrl::ShowFullDescription(bool bFromAuto, bool fromNextPrev)\r\n{\r\n\tif (this->GetSelectedCount() == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tint clipRow = this->GetCaret();\r\n\tint clipId = this->GetItemData(clipRow);\r\n\r\n\tlog(StrF(_T(\"Show full description row: %d id: %d\"), clipRow, clipId));\r\n\r\n\tif (VALID_TOOLTIP &&\r\n\t\tclipId > 0 &&\r\n\t\tm_pToolTip->GetClipId() == clipId &&\r\n\t\t::IsWindow(m_toolTipHwnd))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tint nItem = GetCaret();\r\n\tCRect rc, crWindow;\r\n\tGetWindowRect(&crWindow);\r\n\tGetItemRect(nItem, rc, LVIR_BOUNDS);\r\n\tClientToScreen(rc);\r\n\r\n\tCPoint pt;\r\n\r\n\tif (CGetSetOptions::GetRememberDescPos())\r\n\t{\r\n\t\tCGetSetOptions::GetDescWndPoint(pt);\r\n\t}\r\n\telse if (bFromAuto == false)\r\n\t{\r\n\t\tpt = CPoint(rc.left, rc.bottom);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpt = CPoint((crWindow.left + (crWindow.right - crWindow.left) / 2), rc.bottom);\r\n\t}\r\n\r\n\tCString csDescription;\r\n\tGetToolTipText(nItem, csDescription);\r\n\r\n\tif (m_pToolTip == NULL ||\r\n\t\t//fromNextPrev == false ||\r\n\t\t::IsWindow(m_toolTipHwnd) == FALSE)\r\n\t{\r\n\t\tif (m_pToolTip != NULL)\r\n\t\t{\r\n\t\t\tm_pToolTip->DestroyWindow();\r\n\t\t}\r\n\r\n\t\tm_pToolTip = new CToolTipEx;\r\n\t\tm_pToolTip->Create(this);\r\n\t\tm_toolTipHwnd = m_pToolTip->GetSafeHwnd();\r\n\t\tm_pToolTip->SetNotifyWnd(GetParent());\r\n\t}\r\n\telse if (VALID_TOOLTIP)\r\n\t{\r\n\t\tif (fromNextPrev)\r\n\t\t{\r\n\t\t\tCRect r;\r\n\t\t\tm_pToolTip->GetWindowRectEx(r);\r\n\t\t\tpt = r.TopLeft();\r\n\t\t}\r\n\r\n\t\tm_pToolTip->SetGdiplusBitmap(NULL);\r\n\t\tm_pToolTip->SetRTFText(\"\");\r\n\t\tm_pToolTip->SetToolTipText(_T(\"\"));\r\n\t\tm_pToolTip->SetFolderPath(_T(\"\"));\r\n\t}\r\n\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tm_pToolTip->SetTooltipActions(m_pToolTipActions);\r\n\t\tm_pToolTip->SetClipId(clipId);\r\n\t\tm_pToolTip->SetClipRow(clipRow);\r\n\t\tm_pToolTip->SetSearchText(m_searchText);\r\n\t\tLOGFONT lf;\r\n\t\tm_Font.GetLogFont(&lf);\r\n\t\tlf.lfHeight = m_windowDpi->UnScale(lf.lfHeight);\r\n\t\tm_pToolTip->SetLogFont(&lf, FALSE);\r\n\r\n\t\tm_pToolTip->SetClipData(_T(\"\"));\r\n\t\tm_pToolTip->SetToolTipText(_T(\"\"));\r\n\t\tm_pToolTip->SetRTFText(\"\");\r\n\t\tbool bSetPlainText = false;\r\n\r\n\t\tCClipFormat Clip;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, lDate, lastPasteDate, lDontAutoDelete, QuickPasteText, lShortCut, globalShortCut, stickyClipOrder, stickyClipGroupOrder, lParentID FROM Main WHERE lID = %d\"), clipId);\r\n\t\t\tif (q.eof() == false)\r\n\t\t\t{\r\n\t\t\t\tCString clipData;\r\n\t\t\t\tCOleDateTime time((time_t)q.getIntField(_T(\"lDate\")));\r\n\t\t\t\tclipData += \"Added: \" + time.Format();\r\n\r\n\t\t\t\tCOleDateTime modified((time_t)q.getIntField(_T(\"lastPasteDate\")));\r\n\t\t\t\tclipData += _T(\" | Last Used: \") + modified.Format();\r\n\r\n\t\t\t\tif (q.getIntField(_T(\"lDontAutoDelete\")) > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += _T(\" | Never Auto Delete\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tCString csQuickPaste = q.getStringField(_T(\"QuickPasteText\"));\r\n\t\t\t\tif (csQuickPaste.IsEmpty() == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += _T(\" | Quick Paste = \");\r\n\t\t\t\t\tclipData += csQuickPaste;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint shortCut = q.getIntField(_T(\"lShortCut\"));\r\n\t\t\t\tif (shortCut > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += _T(\" | \");\r\n\t\t\t\t\tclipData += CHotKey::GetHotKeyDisplayStatic(shortCut);\r\n\r\n\t\t\t\t\tBOOL globalShortCut = q.getIntField(_T(\"globalShortCut\"));\r\n\t\t\t\t\tif (globalShortCut)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclipData += _T(\" - Global Shortcut Key\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tint sticky = q.getIntField(_T(\"stickyClipGroupOrder\"));\r\n\t\t\t\t\tif (sticky != INVALID_STICKY)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclipData += _T(\" | \");\r\n\t\t\t\t\t\tclipData += _T(\" - Sticky In Group\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tint sticky = q.getIntField(_T(\"stickyClipOrder\"));\r\n\t\t\t\t\tif (sticky != INVALID_STICKY)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclipData += _T(\" | \");\r\n\t\t\t\t\t\tclipData += _T(\" - Sticky\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint parentId = q.getIntField(_T(\"lParentID\"));\r\n\t\t\t\tif (parentId > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString folder = FolderPath(parentId);\r\n\r\n\t\t\t\t\tm_pToolTip->SetFolderPath(folder);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_pToolTip->SetClipData(clipData);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\tClip.m_cfType = CF_UNICODETEXT;\r\n\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t{\r\n\t\t\tm_pToolTip->SetToolTipText(Clip.GetAsCString());\r\n\t\t\tbSetPlainText = true;\t\t\r\n\r\n\t\t\tClip.Free();\r\n\t\t\tClip.Clear();\r\n\t\t}\r\n\r\n\t\tif (bSetPlainText == false)\r\n\t\t{\r\n\t\t\tClip.m_cfType = CF_TEXT;\r\n\t\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t\t{\t\r\n\t\t\t\tCString cs(Clip.GetAsCStringA());\r\n\r\n\t\t\t\tm_pToolTip->SetToolTipText(cs);\r\n\t\t\t\tbSetPlainText = true;\r\n\r\n\t\t\t\tClip.Free();\r\n\t\t\t\tClip.Clear();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (bSetPlainText == false)\r\n\t\t{\r\n\t\t\tm_pToolTip->SetToolTipText(csDescription);\r\n\t\t}\r\n\r\n\t\tClip.m_cfType = RegisterClipboardFormat(CF_RTF);\r\n\r\n\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t{\r\n\t\t\tm_pToolTip->SetRTFText(Clip.GetAsCStringA());\r\n\t\t\r\n\t\t\tClip.Free();\r\n\t\t\tClip.Clear();\r\n\t\t}\r\n\r\n\t\tm_pToolTip->SetHtmlText(_T(\"\"));\r\n\t\tClip.m_cfType = GetFormatID(_T(\"HTML Format\"));\r\n\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t{\r\n\t\t\tCString html = CTextConvert::Utf8ToUnicode(Clip.GetAsCStringA());\r\n\t\t\tm_pToolTip->SetHtmlText(html);\t\t\r\n\r\n\t\t\tClip.Free();\r\n\t\t\tClip.Clear();\r\n\t\t}\r\n\r\n\t\tClip.m_cfType = CF_DIB;\r\n\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t{\r\n\t\t\tm_pToolTip->SetGdiplusBitmap(Clip.CreateGdiplusBitmap());\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tClip.m_cfType = theApp.m_PNG_Format;\r\n\t\t\tif (GetClipData(nItem, Clip) && Clip.m_hgData)\r\n\t\t\t{\r\n\t\t\t\tm_pToolTip->SetGdiplusBitmap(Clip.CreateGdiplusBitmap());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_pToolTip->Show(pt);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CQListCtrl::GetToolTipText(int nItem, CString &csText)\r\n{\r\n\tCWnd* pParent = GetParent();\r\n\tif (pParent && (pParent->GetSafeHwnd() != NULL))\r\n\t{\r\n\t\tCQListToolTipText info;\r\n\t\tmemset(&info, 0, sizeof(info));\r\n\t\tinfo.hdr.code = NM_GETTOOLTIPTEXT;\r\n\t\tinfo.hdr.hwndFrom = GetSafeHwnd();\r\n\t\tinfo.hdr.idFrom = GetDlgCtrlID();\r\n\t\tinfo.lItem = nItem;\r\n\t\t//plus 100 for extra info - shortcut and such\r\n\t\tint maxCharacters = CGetSetOptions::GetMaxToolTipCharacters();\r\n\t\tinfo.cchTextMax = min(maxCharacters, CGetSetOptions::m_bDescTextSize) + 200;\r\n\t\tinfo.pszText = csText.GetBufferSetLength(info.cchTextMax);\r\n\r\n\t\tpParent->SendMessage(WM_NOTIFY, (WPARAM)info.hdr.idFrom, (LPARAM)&info);\r\n\r\n\t\tcsText.ReleaseBuffer();\r\n\t}\r\n}\r\n\r\nBOOL CQListCtrl::GetClipData(int nItem, CClipFormat &Clip)\r\n{\r\n\treturn theApp.GetClipData(GetItemData(nItem), Clip);\r\n}\r\n\r\nDWORD CQListCtrl::GetItemData(int nItem)\r\n{\r\n\tif ((GetStyle() & LVS_OWNERDATA))\r\n\t{\r\n\t\tCWnd* pParent = GetParent();\r\n\t\tif (pParent && (pParent->GetSafeHwnd() != NULL))\r\n\t\t{\r\n\t\t\tLV_DISPINFO info;\r\n\t\t\tmemset(&info, 0, sizeof(info));\r\n\t\t\tinfo.hdr.code = LVN_GETDISPINFO;\r\n\t\t\tinfo.hdr.hwndFrom = GetSafeHwnd();\r\n\t\t\tinfo.hdr.idFrom = GetDlgCtrlID();\r\n\r\n\t\t\tinfo.item.iItem = nItem;\r\n\t\t\tinfo.item.lParam = -1;\r\n\t\t\tinfo.item.mask = LVIF_PARAM;\r\n\r\n\t\t\tpParent->SendMessage(WM_NOTIFY, (WPARAM)info.hdr.idFrom, (LPARAM)&info);\r\n\r\n\t\t\treturn (DWORD)info.item.lParam;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (DWORD)CListCtrl::GetItemData(nItem);\r\n}\r\n\r\nCClipFormatQListCtrl* CQListCtrl::GetItem_CF_DIB_ClipFormat(int nItem)\r\n{\r\n\tCClipFormatQListCtrl *format = NULL;\r\n\r\n\tCWnd* pParent = GetParent();\r\n\tif (pParent && (pParent->GetSafeHwnd() != NULL))\r\n\t{\r\n\t\tLV_DISPINFO info;\r\n\t\tmemset(&info, 0, sizeof(info));\r\n\t\tinfo.hdr.code = LVN_GETDISPINFO;\r\n\t\tinfo.hdr.hwndFrom = GetSafeHwnd();\r\n\t\tinfo.hdr.idFrom = GetDlgCtrlID();\r\n\r\n\t\tinfo.item.iItem = nItem;\r\n\t\tinfo.item.lParam = NULL;\r\n\t\tinfo.item.mask = LVIF_CF_DIB;\r\n\r\n\t\tpParent->SendMessage(WM_NOTIFY, (WPARAM)info.hdr.idFrom, (LPARAM)&info);\r\n\r\n\t\tif (info.item.lParam != NULL)\r\n\t\t{\r\n\t\t\tformat = (CClipFormatQListCtrl *)info.item.lParam;\r\n\t\t}\r\n\t}\r\n\r\n\treturn format;\r\n}\r\n\r\nCClipFormatQListCtrl* CQListCtrl::GetItem_CF_RTF_ClipFormat(int nItem)\r\n{\r\n\tCClipFormatQListCtrl *format = NULL;\r\n\r\n\tCWnd* pParent = GetParent();\r\n\tif (pParent && (pParent->GetSafeHwnd() != NULL))\r\n\t{\r\n\t\tLV_DISPINFO info;\r\n\t\tmemset(&info, 0, sizeof(info));\r\n\t\tinfo.hdr.code = LVN_GETDISPINFO;\r\n\t\tinfo.hdr.hwndFrom = GetSafeHwnd();\r\n\t\tinfo.hdr.idFrom = GetDlgCtrlID();\r\n\r\n\t\tinfo.item.iItem = nItem;\r\n\t\tinfo.item.lParam = NULL;\r\n\t\tinfo.item.mask = LVIF_CF_RICHTEXT;\r\n\r\n\t\tpParent->SendMessage(WM_NOTIFY, (WPARAM)info.hdr.idFrom, (LPARAM)&info);\r\n\r\n\t\tif (info.item.lParam != NULL)\r\n\t\t{\r\n\t\t\tformat = (CClipFormatQListCtrl *)info.item.lParam;\r\n\t\t}\r\n\t}\r\n\r\n\treturn format;\r\n}\r\n\r\nvoid CQListCtrl::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\r\n{\r\n\tCListCtrl::OnHScroll(nSBCode, nPos, pScrollBar);\r\n}\r\n\r\nvoid CQListCtrl::DestroyAndCreateAccelerator(BOOL bCreate, CppSQLite3DB &db)\r\n{\r\n\tm_Accels.RemoveAll();\r\n\r\n\tif (bCreate)\r\n\t{\r\n\t\tCMainTableFunctions::LoadAcceleratorKeys(m_Accels, db);\r\n\r\n\t\tLoadDittoCopyBufferHotkeys();\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::LoadDittoCopyBufferHotkeys()\r\n{\r\n\tCCopyBufferItem Item;\r\n\tCAccel a;\r\n\r\n\tCGetSetOptions::GetCopyBufferItem(0, Item);\r\n\tif (Item.m_lCopyHotKey > 0)\r\n\t{\r\n\t\ta.Cmd = COPY_BUFFER_HOT_KEY_1_ID;\r\n\t\ta.Key = Item.m_lCopyHotKey;\r\n\t\tm_Accels.AddAccel(a);\r\n\t}\r\n\r\n\tCGetSetOptions::GetCopyBufferItem(1, Item);\r\n\tif (Item.m_lCopyHotKey > 0)\r\n\t{\r\n\t\ta.Cmd = COPY_BUFFER_HOT_KEY_2_ID;\r\n\t\ta.Key = Item.m_lCopyHotKey;\r\n\t\tm_Accels.AddAccel(a);\r\n\t}\r\n\r\n\tCGetSetOptions::GetCopyBufferItem(2, Item);\r\n\tif (Item.m_lCopyHotKey > 0)\r\n\t{\r\n\t\ta.Cmd = COPY_BUFFER_HOT_KEY_3_ID;\r\n\t\ta.Key = Item.m_lCopyHotKey;\r\n\t\tm_Accels.AddAccel(a);\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::OnKillFocus(CWnd* pNewWnd)\r\n{\r\n\tCListCtrl::OnKillFocus(pNewWnd);\r\n\r\n\t//if(FocusOnToolTip() == FALSE)\r\n\t\t//m_pToolTip->Hide();\r\n}\r\n\r\nHWND CQListCtrl::GetToolTipHWnd()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t\treturn m_pToolTip->GetSafeHwnd();\r\n\r\n\treturn NULL;\r\n}\r\n\r\nBOOL CQListCtrl::SetItemCountEx(int iCount, DWORD dwFlags /* = 0 */)\r\n{\r\n\treturn CListCtrl::SetItemCountEx(iCount, dwFlags);\r\n}\r\n\r\nvoid CQListCtrl::OnSelectionChange(NMHDR* pNMHDR, LRESULT* pResult)\r\n{\r\n\tNMLISTVIEW *pnmv = (NMLISTVIEW *)pNMHDR;\r\n\r\n\tif ((pnmv->uNewState == 3) ||\r\n\t\t(pnmv->uNewState == 1))\r\n\t{\r\n\t\tif (VALID_TOOLTIP &&\r\n\t\t\t::IsWindowVisible(m_pToolTip->m_hWnd))\r\n\t\t{\r\n\t\t\tthis->ShowFullDescription(false, true);\r\n\t\t}\r\n\t\tif (CGetSetOptions::m_bAllwaysShowDescription)\r\n\t\t{\r\n\t\t\tKillTimer(TIMER_SHOW_PROPERTIES);\r\n\t\t\tSetTimer(TIMER_SHOW_PROPERTIES, 300, NULL);\r\n\t\t}\r\n\t\tif (GetSelectedCount() > 0)\r\n\t\t\ttheApp.SetStatus(NULL, FALSE);\r\n\t}\r\n\r\n\tif (GetSelectedCount() == this->GetItemCount())\r\n\t{\r\n\t\tif (m_allSelected == false)\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"List box Select All\")));\r\n\r\n\t\t\tGetParent()->SendMessage(NM_ALL_SELECTED, 0, 0);\r\n\t\t\tm_allSelected = true;\r\n\t\t}\r\n\t}\r\n\telse if (m_allSelected == true)\r\n\t{\r\n\t\tLog(StrF(_T(\"List box REMOVED Select All\")));\r\n\t\tm_allSelected = false;\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\t//http://support.microsoft.com/kb/200054\r\n\t//OnTimer() Is Not Called Repeatedly for a List Control\r\n\tbool callBase = true;\r\n\r\n\tswitch (nIDEvent)\r\n\t{\r\n\tcase TIMER_SHOW_PROPERTIES:\r\n\t{\r\n\t\tif (theApp.m_bShowingQuickPaste)\r\n\t\t\tShowFullDescription(true);\r\n\t\tKillTimer(TIMER_SHOW_PROPERTIES);\r\n\r\n\t\tcallBase = false;\r\n\t}\r\n\tbreak;\r\n\r\n\tcase TIMER_HIDE_SCROL:\r\n\t{\r\n\t\tCPoint cursorPos;\r\n\t\tGetCursorPos(&cursorPos);\r\n\r\n\t\tCRect crWindow;\r\n\t\tthis->GetWindowRect(&crWindow);\r\n\r\n\r\n\r\n\t\t//check and see if they moved out of the scroll area\r\n\t\t//If they did tell our parent so\r\n\t\tif (MouseInScrollBarArea(crWindow, cursorPos) == false)\r\n\t\t{\r\n\t\t\tStopHideScrollBarTimer();\r\n\t\t}\r\n\r\n\t\tcallBase = false;\r\n\t}\r\n\tbreak;\r\n\r\n\tcase TIMER_SHOW_SCROLL:\r\n\t{\r\n\t\tCPoint cursorPos;\r\n\t\tGetCursorPos(&cursorPos);\r\n\r\n\t\tCRect crWindow;\r\n\t\tthis->GetWindowRect(&crWindow);\r\n\r\n\t\t//Adjust for the v-scroll bar being off of the screen\r\n\t\tcrWindow.right -= m_windowDpi->Scale(GetSystemMetrics(SM_CXVSCROLL));\r\n\t\tcrWindow.bottom -= m_windowDpi->Scale(::GetSystemMetrics(SM_CXHSCROLL));\r\n\r\n\t\t//Check and see if we are still in the cursor area\r\n\t\tif (MouseInScrollBarArea(crWindow, cursorPos))\r\n\t\t{\r\n\t\t\tm_timerToHideScrollAreaSet = true;\r\n\t\t\tGetParent()->SendMessage(NM_SHOW_HIDE_SCROLLBARS, 1, 0);\r\n\r\n\t\t\t//Start looking to hide the scroll bars\r\n\t\t\tSetTimer(TIMER_HIDE_SCROL, 1000, NULL);\r\n\t\t}\r\n\r\n\t\tKillTimer(TIMER_SHOW_SCROLL);\r\n\r\n\t\tcallBase = false;\r\n\t}\r\n\tbreak;\r\n\t}\r\n\r\n\tif (callBase)\r\n\t{\r\n\t\tCListCtrl::OnTimer(nIDEvent);\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::SetLogFont(LOGFONT &font)\r\n{\r\n\tm_Font.DeleteObject();\r\n\tm_boldFont.DeleteObject();\r\n\r\n\tm_Font.CreateFontIndirect(&font);\r\n\tfont.lfWeight = 600;\r\n\tm_boldFont.CreateFontIndirect(&font);\r\n\r\n\tSetFont(&m_Font);\r\n}\r\n\r\nvoid CQListCtrl::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\r\n{\r\n\tCListCtrl::OnVScroll(nSBCode, nPos, pScrollBar);\r\n}\r\n\r\nBOOL CQListCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult)\r\n{\r\n\tNMLVCACHEHINT* pcachehint = NULL;\r\n\r\n\tif (message == WM_NOTIFY)\r\n\t{\r\n\t\tNMHDR* phdr = (NMHDR*)lParam;\r\n\r\n\t\tswitch (phdr->code)\r\n\t\t{\r\n\t\tcase LVN_ODCACHEHINT:\r\n\t\t\tpcachehint = (NMLVCACHEHINT*)phdr;\r\n\r\n\t\t\tGetParent()->SendMessage(NM_FILL_REST_OF_LIST, pcachehint->iFrom, pcachehint->iTo);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\treturn CListCtrl::OnChildNotify(message, wParam, lParam, pLResult);\r\n}\r\n\r\nBOOL CQListCtrl::OnItemDeleted(long lID)\r\n{\r\n\tBOOL bRet2 = m_RTFData.RemoveKey(lID);\r\n\r\n\treturn (bRet2);\r\n}\r\n\r\nvoid CQListCtrl::OnMouseMove(UINT nFlags, CPoint point)\r\n{\r\n\tif (CGetSetOptions::m_showScrollBar == FALSE)\r\n\t{\r\n\t\tCPoint cursorPos;\r\n\t\tGetCursorPos(&cursorPos);\r\n\r\n\t\tCRect crWindow;\r\n\t\tthis->GetWindowRect(&crWindow);\r\n\t\tScreenToClient(&crWindow);\r\n\r\n\t\tcrWindow.right -= m_windowDpi->Scale(::GetSystemMetrics(SM_CXVSCROLL));\r\n\t\tcrWindow.bottom -= m_windowDpi->Scale(::GetSystemMetrics(SM_CXHSCROLL));\r\n\r\n\t\tif (MouseInScrollBarArea(crWindow, point))\r\n\t\t{\r\n\t\t\tif ((GetTickCount() - m_mouseOverScrollAreaStart) > 500)\r\n\t\t\t{\r\n\t\t\t\tSetTimer(TIMER_SHOW_SCROLL, 500, NULL);\r\n\r\n\t\t\t\tm_mouseOverScrollAreaStart = GetTickCount();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (m_timerToHideScrollAreaSet)\r\n\t\t\t{\r\n\t\t\t\tStopHideScrollBarTimer();\r\n\t\t\t}\r\n\t\t\tKillTimer(TIMER_SHOW_SCROLL);\r\n\t\t}\r\n\t}\r\n\r\n\tCListCtrl::OnMouseMove(nFlags, point);\r\n}\r\n\r\nbool CQListCtrl::MouseInScrollBarArea(CRect crWindow, CPoint point)\r\n{\r\n\tCRect crRight(crWindow);\r\n\tCRect crBottom(crWindow);\r\n\r\n\tcrRight.left = crRight.right - m_windowDpi->Scale(::GetSystemMetrics(SM_CXVSCROLL));\r\n\tcrBottom.top = crBottom.bottom - m_windowDpi->Scale(::GetSystemMetrics(SM_CYHSCROLL));\r\n\r\n\t/*CString cs;\r\n\tcs.Format(_T(\"point.x: %d, Width: %d, Height: %d\\n\"), point.x, crWindow.Width(), crWindow.Height());\r\n\tOutputDebugString(cs);*/\r\n\r\n\tif (crRight.PtInRect(point) || crBottom.PtInRect(point))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid CQListCtrl::StopHideScrollBarTimer()\r\n{\r\n\tGetParent()->SendMessage(NM_SHOW_HIDE_SCROLLBARS, 0, 0);\r\n\r\n\tm_timerToHideScrollAreaSet = false;\r\n\tKillTimer(TIMER_HIDE_SCROL);\r\n}\r\n\r\nvoid CQListCtrl::SetSearchText(CString text)\r\n{\r\n\tm_searchText = text;\r\n}\r\n\r\nvoid CQListCtrl::HidePopup(bool checkShowPersistant)\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tif (checkShowPersistant == false ||\r\n\t\t\tm_pToolTip->GetShowPersistant() == false)\r\n\t\t{\r\n\t\t\tm_pToolTip->Hide();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBOOL CQListCtrl::IsToolTipWindowVisible()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\treturn ::IsWindowVisible(m_toolTipHwnd);\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CQListCtrl::ToggleToolTipShowPersistant()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tm_pToolTip->ToggleShowPersistant();\r\n\t}\r\n}\r\n\r\nbool CQListCtrl::ToggleToolTipWordWrap()\r\n{\r\n\tbool didWordWrap = false;\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tdidWordWrap = m_pToolTip->ToggleWordWrap();\r\n\t}\r\n\r\n\treturn didWordWrap;\r\n}\r\n\r\n\r\nBOOL CQListCtrl::IsToolTipWindowFocus()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\treturn ::GetFocus() == m_toolTipHwnd ||\r\n\t\t\t::GetParent(::GetFocus()) == m_toolTipHwnd;\r\n\t}\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nbool CQListCtrl::IsToolTipShowPersistant()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\treturn m_pToolTip->GetShowPersistant();\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid CQListCtrl::DoToolTipSearch()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\treturn m_pToolTip->DoSearch();\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::HideToolTip()\r\n{\r\n\tif (VALID_TOOLTIP)\r\n\t{\r\n\t\tm_pToolTip->Hide();\r\n\t}\r\n}\r\n\r\nvoid CQListCtrl::OnDpiChanged()\r\n{\r\n\tSetDpiInfo(m_windowDpi);\r\n}\r\n\r\nvoid CQListCtrl::SetDpiInfo(CDPI *dpi)\r\n{\r\n\tm_windowDpi = dpi;\r\n\r\n\tm_groupFolder.Reset();\r\n\tm_groupFolder.LoadStdImageDPI(m_windowDpi->GetDPI(), IDB_OPEN_FOLDER_16_16, IDB_OPEN_FOLDER_20_20, IDB_OPEN_FOLDER_24_24, IDB_OPEN_FOLDER_24_24, IDB_OPEN_FOLDER_32_32, _T(\"PNG\"));\r\n\r\n\tm_dontDeleteImage.Reset();\r\n\tm_dontDeleteImage.LoadStdImageDPI(m_windowDpi->GetDPI(), IDB_YELLOW_STAR_16_16, IDB_YELLOW_STAR_20_20, IDB_YELLOW_STAR_24_24, IDB_YELLOW_STAR_24_24, IDB_YELLOW_STAR_32_32, _T(\"PNG\"));\r\n\r\n\tm_inFolderImage.Reset();\r\n\tm_inFolderImage.LoadStdImageDPI(m_windowDpi->GetDPI(), IDB_IN_FOLDER_16_16, IDB_IN_FOLDER_20_20, IDB_IN_FOLDER_24_24, IDB_IN_FOLDER_24_24, IDB_IN_FOLDER_32_32, _T(\"PNG\"));\r\n\r\n\tm_shortCutImage.Reset();\r\n\tm_shortCutImage.LoadStdImageDPI(m_windowDpi->GetDPI(), IDB_KEY_16_16, IDB_KEY_20_20, IDB_KEY_24_24, IDB_KEY_24_24, IDB_KEY_32_32, _T(\"PNG\"));\r\n\r\n\tm_stickyImage.Reset();\r\n\tm_stickyImage.LoadStdImageDPI(m_windowDpi->GetDPI(), IDB_STICKY_16_16, IDB_STICKY_20_20, IDB_STICKY_24_24, IDB_STICKY_24_24, IDB_STICKY_32_32, _T(\"PNG\"));\r\n\r\n\tDeleteObject(m_SmallFont);\r\n\r\n\tCreateSmallFont();\r\n}\r\n\r\nvoid CQListCtrl::CreateSmallFont()\r\n{\r\n\tLOGFONT lf;\r\n\r\n\tlf.lfHeight = -MulDiv(CGetSetOptions::GetFirstTenHotKeysFontSize(), m_windowDpi->GetDPI(), 72);\r\n\tlf.lfWidth = 0;\r\n\tlf.lfEscapement = 0;\r\n\tlf.lfOrientation = 0;\r\n\tlf.lfWeight = FW_LIGHT;\r\n\tlf.lfItalic = FALSE;\r\n\tlf.lfUnderline = FALSE;\r\n\tlf.lfStrikeOut = FALSE;\r\n\tlf.lfCharSet = ANSI_CHARSET;\r\n\tlf.lfOutPrecision = OUT_STRING_PRECIS;\r\n\tlf.lfClipPrecision = CLIP_STROKE_PRECIS;\r\n\tlf.lfQuality = DEFAULT_QUALITY;\r\n\tlf.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE;\r\n\tlstrcpy(lf.lfFaceName, _T(\"Small Font\"));\r\n\r\n\tm_SmallFont = ::CreateFontIndirect(&lf);\r\n}\r\n\r\nvoid CQListCtrl::OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt)\r\n{\r\n\tif (zDelta < 0)\r\n\t{\r\n\t\tthis->SendMessage(WM_HSCROLL, SB_LINERIGHT, NULL);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis->SendMessage(WM_HSCROLL, SB_LINELEFT, NULL);\r\n\t}\r\n\r\n\t//CListCtrl::OnMouseHWheel(nFlags, zDelta, pt);\r\n}\r\n"
        },
        {
          "name": "QListCtrl.h",
          "type": "blob",
          "size": 7.12109375,
          "content": " #if !defined(AFX_QLISTCTRL_H__30BEB04A_4B97_4943_BB73_C5128E66B4ED__INCLUDED_)\r\n#define AFX_QLISTCTRL_H__30BEB04A_4B97_4943_BB73_C5128E66B4ED__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n// QListCtrl.h : header file\r\n//\r\n#include \"Shared/ArrayEx.h\"\r\n#include \"ToolTipEx.h\"\r\n#include \"FormattedTextDraw.h\"\r\n#include \"sqlite/CppSQLite3.h\"\r\n#include \"ClipFormatQListCtrl.h\"\r\n#include \"Accels.h\"\r\n#include \"GdiImageDrawer.h\"\r\n#include \"DPI.h\"\r\n\r\n#define NM_SEARCH_ENTER_PRESSED\t\tWM_USER+0x100\r\n#define NM_RIGHT\t\t\t\t\tWM_USER+0x101\r\n#define NM_LEFT\t\t\t\t\t\tWM_USER+0x102\r\n#define NM_END\t\t\t\t\t\tWM_USER+0x103\r\n#define NM_DELETE\t\t\t\t\tWM_USER+0x104\r\n#define NM_PROPERTIES\t\t\t\tWM_USER+0x105\r\n#define NM_LBUTTONDOWN\t\t\t\tWM_USER+0x106\r\n#define NM_GETTOOLTIPTEXT\t        WM_USER+0x107\r\n#define NM_SELECT_DB_ID\t\t        WM_USER+0x108\r\n#define NM_GROUP_TREE_MESSAGE       WM_USER+0x110\r\n#define CB_SEARCH\t\t\t\t\tWM_USER+0x112\r\n#define CB_UPDOWN\t\t\t\t\tWM_USER+0x113\r\n#define NM_INACTIVE_TOOLTIPWND\t\tWM_USER+0x114\r\n#define NM_FILL_REST_OF_LIST\t\tWM_USER+0x115\r\n\r\n#define NM_SET_LIST_COUNT\t\t\tWM_USER+0x116\r\n#define NM_ITEM_DELETED\t\t\t\tWM_USER+0x118\r\n#define NM_ALL_SELECTED\t\t\t\tWM_USER+0x119\r\n#define NM_REFRESH_ROW\t\t\t\tWM_USER+0x120\r\n#define NM_REFRESH_ROW_EXTRA_DATA\tWM_USER+0x121\r\n#define NM_SHOW_HIDE_SCROLLBARS\t\tWM_USER+0x122\r\n#define NM_CANCEL_SEARCH\t\t\tWM_USER+0x123\r\n#define NM_POST_OPTIONS_WINDOW\t\tWM_USER+0x124\r\n#define NM_SHOW_PROPERTIES\t\t\tWM_USER+0x125\r\n#define NM_NEW_GROUP\t\t\t\tWM_USER+0x126\r\n#define NM_DELETE_ID\t\t\t\tWM_USER+0x127\r\n#define NM_MOVE_TO_GROUP\t\t\tWM_USER+0x128\r\n#define NM_FOCUS_ON_SEARCH\t\t\tWM_USER+0x129\r\n#define NM_COPY_CLIP\t\t\t\tWM_USER+0x130\r\n\r\n\r\n\r\n#define COPY_BUFFER_HOT_KEY_1_ID\t-100\r\n#define COPY_BUFFER_HOT_KEY_2_ID\t-101\r\n#define COPY_BUFFER_HOT_KEY_3_ID\t-102\r\n\r\n#define LVIF_CF_DIB 0x10000000\r\n#define LVIF_CF_RICHTEXT 0x10000000\r\n\r\n\r\n//#define NM_LIST_CUT\t\t\t        WM_USER+0x111\r\n//#define NM_LIST_COPY\t\t        WM_USER+0x112\r\n//#define NM_LIST_PASTE\t\t        WM_USER+0x113\r\n\r\nclass CQListToolTipText\r\n{\r\npublic:\r\n\tNMHDR hdr;\r\n\tlong lItem;\r\n\tLPTSTR pszText; \r\n\tint cchTextMax; \r\n};\r\n\r\n\r\n\r\ntypedef CMap<long, long, CClipFormat, CClipFormat&> CMapIDtoCF;\r\n\r\nclass CQListCtrl : public CListCtrl\r\n{\r\n// Construction\r\npublic:\r\n\tCQListCtrl();\r\n\r\n// Attributes\r\npublic:\r\n\r\n// Operations\r\npublic:\r\n\r\n// Overrides\r\n\t// ClassWizard generated virtual function overrides\r\n\t//{{AFX_VIRTUAL(CQListCtrl)\r\n\tpublic:\r\n\tvirtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO * pTI) const;\r\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\r\n\tvirtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);\r\n\t//}}AFX_VIRTUAL\r\n\r\n// Implementation\r\npublic:\r\n\tvirtual ~CQListCtrl();\r\n\r\n\tBOOL\tm_bShowTextForFirstTenHotKeys;\r\n\t// returns the position 1-10 if the index is in the FirstTen block else -1\r\n\tint GetFirstTenNum( int index );\r\n\r\n\tvoid SetNumberOfLinesPerRow(int nLines, bool force);\r\n\tvoid GetSelectionIndexes(ARRAY &arr);\r\n\tvoid GetSelectionItemData(ARRAY &arr);\r\n\tvoid RefreshVisibleRows();\r\n\tvoid RefreshRow(int row);\r\n\tvoid RemoveAllSelection();\r\n\tBOOL SetSelection(int nRow, BOOL bSelect = TRUE);\r\n\tBOOL SetText(int nRow, int nCol, CString cs);\r\n\tBOOL SetFormattedText(int nRow, int nCol, LPCTSTR lpszFormat,...);\r\n\tBOOL SetCaret(int nRow, BOOL bFocus = TRUE);\r\n\tlong GetCaret();\r\n\t// moves the caret to the given index, selects it, and ensures it is visible.\r\n\tBOOL SetListPos(int index);\r\n\tbool PutSelectedItemOnDittoCopyBuffer(long lBuffer);\r\n\r\n\tvirtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\r\n\r\n\tDWORD GetItemData(int nItem);\r\n\tCClipFormatQListCtrl* GetItem_CF_DIB_ClipFormat(int nItem);\r\n\tCClipFormatQListCtrl* GetItem_CF_RTF_ClipFormat(int nItem);\r\n\tvoid GetToolTipText(int nItem, CString &csText);\r\n\r\n\tvoid SetShowTextForFirstTenHotKeys(BOOL bVal)\t{ m_bShowTextForFirstTenHotKeys = bVal;\t}\r\n\tvoid SetShowIfClipWasPasted(BOOL val) { m_showIfClipWasPasted = val; }\r\n\r\n\tvoid DestroyAndCreateAccelerator(BOOL bCreate, CppSQLite3DB &db);\r\n\r\n\tbool PostEventLoadedCheckDescription(int updatedRow);\r\n\tbool ShowFullDescription(bool bFromAuto = false, bool fromNextPrev = false);\r\n\tBOOL SetItemCountEx(int iCount, DWORD dwFlags = 0);\r\n\r\n\tvoid HidePopup(bool checkShowPersistant);\r\n\tvoid ToggleToolTipShowPersistant();\r\n\tbool ToggleToolTipWordWrap();\r\n\tvoid SetTooltipActions(CAccels *pToolTipActions) { m_pToolTipActions = pToolTipActions; }\r\n\tbool IsToolTipShowPersistant();\r\n\tvoid DoToolTipSearch();\r\n\tvoid HideToolTip();\r\n\r\n\tvoid SetLogFont(LOGFONT &font);\r\n\r\n\tHWND GetToolTipHWnd();\r\n\r\n\tBOOL HandleKeyDown(WPARAM wParam, LPARAM lParam);\r\n\r\n\tBOOL OnItemDeleted(long lID);\r\n\r\n\tBOOL IsToolTipWindowVisible();\r\n\tBOOL IsToolTipWindowFocus();\r\n\r\n\tint GetRowHeight() { return m_rowHeight; }\r\n\r\n\tvoid SetSearchText(CString text);\r\n\r\n\tvoid SetDpiInfo(CDPI *dpi);\r\n\r\n\tvoid CreateSmallFont();\r\n\r\n\tvoid OnDpiChanged();\r\n\t\r\n\tvoid LoadCopyOrCutToClipboard();\r\n\r\nprotected:\r\n\tBOOL GetClipData(int nItem, CClipFormat &Clip);\r\n\tBOOL DrawBitMap(int nItem, CRect &crRect, CDC *pDC, const CString &csDescription);\r\n\tvoid LoadDittoCopyBufferHotkeys();\r\n\tbool MouseInScrollBarArea(CRect crWindow, CPoint point);\r\n\tBOOL DrawRtfText(int nItem, CRect &crRect, CDC *pDC);\r\n\tvoid StopHideScrollBarTimer();\r\n\t\t\r\n\tWCHAR *m_pwchTip;\r\n\tTCHAR *m_pchTip;\r\n\tHFONT m_SmallFont;\r\n\tCAccels\tm_Accels;\r\n\tCMapIDtoCF m_RTFData;\r\n\tCToolTipEx *m_pToolTip;\r\n\tHWND m_toolTipHwnd;\r\n\tCFont m_Font;\r\n\tCFont m_boldFont;\r\n\tIFormattedTextDraw *m_pFormatter;\r\n\tbool m_allSelected;\r\n\tint m_linesPerRow;\r\n\tDWORD m_mouseOverScrollAreaStart;\r\n\tbool m_timerToHideScrollAreaSet;\r\n\tCGdiImageDrawer m_groupFolder;\r\n\tCGdiImageDrawer m_dontDeleteImage;\r\n\tCGdiImageDrawer m_inFolderImage;\r\n\tCGdiImageDrawer m_shortCutImage;\r\n\tCGdiImageDrawer m_stickyImage;\r\n\tint m_rowHeight;\r\n\tCString m_searchText;\r\n\tBOOL m_showIfClipWasPasted;\r\n\tCAccels *m_pToolTipActions;\r\n\tCRichEditCtrlEx m_rtfFormater;\r\n\tCDPI *m_windowDpi;\r\n\r\n\r\n\t// Generated message map functions\r\nprotected:\r\n\t//{{AFX_MSG(CQListCtrl)\r\n\tafx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tafx_msg void OnCustomdrawList(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tvoid DrawCopiedColorCode(CString& csText, CRect& rcText, CDC* pDC);\r\n\tafx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);\r\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\r\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\r\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\r\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\r\n\tafx_msg void OnSelectionChange(NMHDR* pNMHDR, LRESULT* pResult);\r\n\tafx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\r\n\t//}}AFX_MSG\r\n\tafx_msg BOOL OnToolTipText(UINT id, NMHDR * pNMHDR, LRESULT * pResult);\r\n\tafx_msg void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);\r\n\tafx_msg void OnMouseMove(UINT nFlags, CPoint point);\r\n\tDECLARE_MESSAGE_MAP()\r\npublic:\r\n\tafx_msg void OnKillFocus(CWnd* pNewWnd);\r\n\tafx_msg void OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt);\r\n};\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n#endif // !defined(AFX_QLISTCTRL_H__30BEB04A_4B97_4943_BB73_C5128E66B4ED__INCLUDED_)\r\n"
        },
        {
          "name": "QPasteWnd.cpp",
          "type": "blob",
          "size": 186.3759765625,
          "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check it.\r\n// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"QPasteWnd.h\"\r\n#include \"ProcessPaste.h\"\r\n#include \"CopyProperties.h\"\r\n#include \"GroupName.h\"\r\n#include \".\\qpastewnd.h\"\r\n#include \"MoveToGroupDlg.h\"\r\n#include \"HyperLink.h\"\r\n#include \"FormatSQL.h\"\r\n#include \"MainTableFunctions.h\"\r\n#include \"Path.h\"\r\n#include \"ActionEnums.h\"\r\n#include <algorithm>\r\n#include \"ClipCompare.h\"\r\n#include \"Misc.h\"\r\n#include \"FriendPromptDlg.h\"\r\n#include \"DimWnd.h\"\r\n#include \"client.h\"\r\n#include \"SendMail.h\"\r\n#include \"CF_UnicodeTextAggregator.h\"\r\n#include \"CF_TextAggregator.h\"\r\n#include \"htmlformataggregator.h\"\r\n#include \"shared/Tokenizer.h\"\r\n#include <signal.h>\r\n\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif \r\n\r\n#define QPASTE_TITLE\t\t\t\"Ditto\"\r\n\r\n#define ID_LIST_HEADER\t\t\t0x201\r\n#define ID_EDIT_SEARCH\t\t\t0x202\r\n#define ID_CANCEL\t\t\t\t0x203\r\n#define ID_GROUP_TEXT\t\t\t0x204\r\n#define ID_SHOW_GROUPS_BOTTOM\t0x205\r\n#define ID_SHOW_GROUPS_TOP\t\t0x206\r\n#define ID_BACK_BUTTON\t\t\t0x207\r\n#define ID_SEARCH_DESCRIPTION_BUTTON 0x208\r\n#define ON_TOP_WARNING 0x209\r\n#define ID_SYSTEM_BUTTON\t\t0x210\r\n#define ID_NO_SEARCH_RESULTS\t0x211\r\n\r\n\r\n#define QPASTE_WIDTH\t\t\t200\r\n#define QPASTE_HEIGHT\t\t\t200\r\n\r\n#define TIMER_FILL_CACHE\t\t1\r\n#define TIMER_DO_SEARCH\t\t\t2\r\n#define TIMER_PASTE_FROM_MODIFER\t3\r\n#define TIMER_ERROR_MSG\t\t\t4\r\n#define TIMER_DRAG_HIDE_WINDOW\t6\r\n#define TIMER_DO_ACTION\t7\r\n\r\n#define THREAD_DO_QUERY\t\t\t\t0\r\n#define THREAD_EXIT_THREAD\t\t\t1\r\n#define THREAD_FILL_ACCELERATORS\t2\r\n#define THREAD_DESTROY_ACCELERATORS\t3\r\n#define THREAD_LOAD_ITEMS\t\t\t4\r\n#define THREAD_LOAD_EXTRA_DATA\t\t5\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CQPasteWnd\r\n\r\nCQPasteWnd::CQPasteWnd()\r\n{\r\n\tm_Title = QPASTE_TITLE;\r\n\tm_bHideWnd = true;\r\n\tm_strSQLSearch = \"\";\r\n\tm_strSearch = \"\";\r\n\tm_bHandleSearchTextChange = true;\r\n\tm_bModifersMoveActive = false;\r\n\tm_showScrollBars = false;\r\n\tm_leftSelectedCompareId = 0;\r\n\tm_extraDataCounter = 0;\r\n\tm_noSearchResults = false;\r\n\tm_lastDbWrite = 0;\r\n\tm_pendingRefresh = false;\r\n\tm_lastNonActiveMouseMove = 0;\r\n}\r\n\r\nCQPasteWnd::~CQPasteWnd()\r\n{\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CQPasteWnd, CWndEx)\r\n\t//{{AFX_MSG_MAP(CQPasteWnd)\r\n\tON_WM_ERASEBKGND()\r\n\tON_WM_CREATE()\r\n\tON_WM_SIZE()\r\n\tON_WM_SETFOCUS()\r\n\tON_WM_KILLFOCUS()\r\n\tON_WM_ACTIVATE()\r\n\tON_COMMAND(ID_MENU_LINESPERROW_1, OnMenuLinesperrow1)\r\n\tON_COMMAND(ID_MENU_LINESPERROW_2, OnMenuLinesperrow2)\r\n\tON_COMMAND(ID_MENU_LINESPERROW_3, OnMenuLinesperrow3)\r\n\tON_COMMAND(ID_MENU_LINESPERROW_4, OnMenuLinesperrow4)\r\n\tON_COMMAND(ID_MENU_LINESPERROW_5, OnMenuLinesperrow5)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_10, OnMenuTransparency10)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_15, OnMenuTransparency15)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_20, OnMenuTransparency20)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_25, OnMenuTransparency25)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_30, OnMenuTransparency30)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_40, OnMenuTransparency40)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_5, OnMenuTransparency5)\r\n\tON_COMMAND(ID_MENU_TRANSPARENCY_NONE, OnMenuTransparencyNone)\r\n\tON_COMMAND(ID_MENU_DELETE, OnMenuDelete)\r\n\tON_COMMAND(ID_MENU_POSITIONING_ATCARET, OnMenuPositioningAtcaret)\r\n\tON_COMMAND(ID_MENU_POSITIONING_ATCURSOR, OnMenuPositioningAtcursor)\r\n\tON_COMMAND(ID_MENU_POSITIONING_ATPREVIOUSPOSITION, OnMenuPositioningAtpreviousposition)\r\n\tON_COMMAND(ID_MENU_OPTIONS, OnMenuOptions)\r\n\tON_COMMAND(ID_MENU_EXITPROGRAM, OnMenuExitprogram)\r\n\tON_COMMAND(ID_MENU_TOGGLECONNECTCV, OnMenuToggleConnectCV)\r\n\tON_COMMAND(ID_MENU_PROPERTIES, OnMenuProperties)\r\n\tON_WM_CLOSE()\r\n\tON_NOTIFY(LVN_BEGINDRAG, ID_LIST_HEADER, OnBegindrag)\r\n\tON_WM_SYSKEYDOWN()\r\n\tON_NOTIFY(LVN_GETDISPINFO, ID_LIST_HEADER, GetDispInfo)\r\n\tON_NOTIFY(LVN_ODFINDITEM, ID_LIST_HEADER, OnFindItem)\r\n\tON_COMMAND(ID_MENU_FIRSTTENHOTKEYS_USECTRLNUM, OnMenuFirsttenhotkeysUsectrlnum)\r\n\tON_COMMAND(ID_MENU_FIRSTTENHOTKEYS_SHOWHOTKEYTEXT, OnMenuFirsttenhotkeysShowhotkeytext)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_ALLWAYSSHOWDESCRIPTION, OnMenuQuickoptionsAllwaysshowdescription)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSONTOP, OnMenuQuickoptionsDoubleclickingoncaptionTogglesalwaysontop)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_ROLLUPWINDOW, OnMenuQuickoptionsDoubleclickingoncaptionRollupwindow)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSSHOWDESCRIPTION, OnMenuQuickoptionsDoubleclickingoncaptionTogglesshowdescription)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_PROMPTFORNEWGROUPNAMES, OnMenuQuickoptionsPromptfornewgroupnames)\r\n\tON_BN_CLICKED(ID_SHOW_GROUPS_BOTTOM, OnShowGroupsBottom)\r\n\tON_BN_CLICKED(ID_SHOW_GROUPS_TOP, OnShowGroupsTop)\r\n\tON_COMMAND(ID_MENU_VIEWGROUPS, OnMenuViewgroups)\r\n\tON_COMMAND(ID_MENU_QUICKPROPERTIES_SETTONEVERAUTODELETE, OnMenuQuickpropertiesSettoneverautodelete)\r\n\tON_COMMAND(ID_MENU_QUICKPROPERTIES_AUTODELETE, OnMenuQuickpropertiesAutodelete)\r\n\tON_COMMAND(ID_MENU_QUICKPROPERTIES_REMOVEHOTKEY, OnMenuQuickpropertiesRemovehotkey)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_EIGHT, OnMenuSenttoFriendEight)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_ELEVEN, OnMenuSenttoFriendEleven)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_FIFTEEN, OnMenuSenttoFriendFifteen)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_FIVE, OnMenuSenttoFriendFive)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_FORE, OnMenuSenttoFriendFore)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_FORETEEN, OnMenuSenttoFriendForeteen)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_NINE, OnMenuSenttoFriendNine)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_SEVEN, OnMenuSenttoFriendSeven)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_SIX, OnMenuSenttoFriendSix)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_TEN, OnMenuSenttoFriendTen)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_THIRTEEN, OnMenuSenttoFriendThirteen)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_THREE, OnMenuSenttoFriendThree)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_TWELVE, OnMenuSenttoFriendTwelve)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIEND_TWO, OnMenuSenttoFriendTwo)\r\n\tON_COMMAND(ID_MENU_SENTTO_FRIENDONE, OnMenuSenttoFriendone)\r\n\tON_COMMAND(ID_MENU_SENTTO_PROMPTFORIP, OnMenuSenttoPromptforip)\r\n\tON_COMMAND(ID_MENU_GROUPS_MOVETOGROUP, OnMenuGroupsMovetogroup)\r\n\tON_COMMAND(ID_MENU_PASTEPLAINTEXTONLY, OnMenuPasteplaintextonly)\r\n\tON_COMMAND(ID_MENU_HELP, OnMenuHelp)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_FONT, OnMenuQuickoptionsFont)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_SHOWTHUMBNAILS, OnMenuQuickoptionsShowthumbnails)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_DRAWRTFTEXT, OnMenuQuickoptionsDrawrtftext)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_PASTECLIPAFTERSELECTION, OnMenuQuickoptionsPasteclipafterselection)\r\n\tON_EN_CHANGE(ID_EDIT_SEARCH, OnSearchEditChange)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_FINDASYOUTYPE, OnMenuQuickoptionsFindasyoutype)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_ENSUREENTIREWINDOWISVISIBLE, OnMenuQuickoptionsEnsureentirewindowisvisible)\r\n\tON_COMMAND(ID_MENU_QUICKOPTIONS_SHOWCLIPSTHATAREINGROUPSINMAINLIST, OnMenuQuickoptionsShowclipsthatareingroupsinmainlist)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_NEWGROUP, OnUpdateMenuNewgroup)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_NEWGROUPSELECTION, OnUpdateMenuNewgroupselection)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_ALLWAYSONTOP, OnUpdateMenuAllwaysontop)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_VIEWFULLDESCRIPTION, OnUpdateMenuViewfulldescription)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_VIEWGROUPS, OnUpdateMenuViewgroups)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_PASTEPLAINTEXTONLY, OnUpdateMenuPasteplaintextonly)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_DELETE, OnUpdateMenuDelete)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_PROPERTIES, OnUpdateMenuProperties)\r\n\tON_COMMAND(ID_QUICKOPTIONS_PROMPTTODELETECLIP, OnPromptToDeleteClip)\r\n\tON_COMMAND(ID_STICKYCLIPS_MAKETOPSTICKYCLIP, OnMakeTopStickyClip)\r\n\tON_COMMAND(ID_STICKYCLIPS_MAKELASTSTICKYCLIP, OnMakeLastStickyClip)\r\n\tON_COMMAND(ID_STICKYCLIPS_REMOVESTICKYSETTING, OnRemoveSticky)\r\n\tON_COMMAND(ID_QUICKOPTIONS_ELEVATEPREVILEGESTOPASTEINTOELEVATEDAPPS, OnElevateAppToPasteIntoElevatedApp)\r\n\r\n\tON_WM_DESTROY()\r\n\r\n\t//}}AFX_MSG_MAP\r\n\tON_MESSAGE(NM_SEARCH_ENTER_PRESSED, OnSearchEnterKeyPressed)\r\n\tON_MESSAGE(NM_COPY_CLIP, OnCopyClip)\r\n\tON_MESSAGE(NM_END, OnListEnd)\r\n\tON_MESSAGE(CB_SEARCH, OnSearch)\r\n\tON_MESSAGE(NM_DELETE, OnDelete)\r\n\tON_NOTIFY(NM_GETTOOLTIPTEXT, ID_LIST_HEADER, OnGetToolTipText)\r\n\tON_MESSAGE(NM_SELECT_DB_ID, OnListSelect_DB_ID)\r\n\tON_MESSAGE(WM_REFRESH_VIEW, OnRefreshView)\r\n\tON_MESSAGE(WM_RELOAD_CLIP_IN_UI, OnReloadClipInUI)\r\n\tON_WM_NCLBUTTONDBLCLK()\r\n\tON_WM_WINDOWPOSCHANGING()\r\n\tON_COMMAND(ID_VIEWCAPTIONBARON_RIGHT, OnViewcaptionbaronRight)\r\n\tON_COMMAND(ID_VIEWCAPTIONBARON_BOTTOM, OnViewcaptionbaronBottom)\r\n\tON_COMMAND(ID_VIEWCAPTIONBARON_LEFT, OnViewcaptionbaronLeft)\r\n\tON_COMMAND(ID_VIEWCAPTIONBARON_TOP, OnViewcaptionbaronTop)\r\n\tON_COMMAND(ID_MENU_AUTOHIDE, OnMenuAutohide)\r\n\tON_COMMAND(ID_MENU_VIEWFULLDESCRIPTION, OnMenuViewfulldescription)\r\n\tON_COMMAND(ID_MENU_ALLWAYSONTOP, OnMenuAllwaysontop)\r\n\tON_COMMAND(ID_MENU_NEWGROUP, OnMenuNewGroup)\r\n\tON_COMMAND(ID_MENU_NEWGROUPSELECTION, OnMenuNewGroupSelection)\r\n\tON_MESSAGE(NM_GROUP_TREE_MESSAGE, OnGroupTreeMessage)\r\n\tON_COMMAND(ID_BACK_BUTTON, OnBackButton)\r\n\tON_COMMAND(ID_SYSTEM_BUTTON, OnSystemButton)\r\n\tON_MESSAGE(CB_UPDOWN, OnUpDown)\r\n\tON_MESSAGE(NM_INACTIVE_TOOLTIPWND, OnToolTipWndInactive)\r\n\tON_MESSAGE(NM_SET_LIST_COUNT, OnSetListCount)\r\n\tON_MESSAGE(NM_REFRESH_ROW, OnRefeshRow)\r\n\tON_MESSAGE(NM_ITEM_DELETED, OnItemDeleted)\r\n\tON_WM_TIMER()\r\n\tON_COMMAND(ID_MENU_EXPORT, OnMenuExport)\r\n\tON_COMMAND(ID_MENU_IMPORT, OnMenuImport)\r\n\tON_COMMAND(ID_QUICKPROPERTIES_REMOVEQUICKPASTE, OnQuickpropertiesRemovequickpaste)\r\n\tON_COMMAND(ID_MENU_EDITITEM, OnMenuEdititem)\r\n\tON_COMMAND(ID_MENU_NEWCLIP, OnMenuNewclip)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_EDITITEM, OnUpdateMenuEdititem)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_NEWCLIP, OnUpdateMenuNewclip)\r\n\tON_WM_CTLCOLOR_REFLECT()\r\n\tON_COMMAND_RANGE(3000, 4000, OnAddinSelect)\r\n\tON_MESSAGE(NM_ALL_SELECTED, OnSelectAll)\r\n\tON_MESSAGE(NM_SHOW_HIDE_SCROLLBARS, OnShowHideScrollBar)\r\n\tON_MESSAGE(NM_CANCEL_SEARCH, OnCancelFilter)\r\n\tON_MESSAGE(NM_POST_OPTIONS_WINDOW, OnPostOptions)\r\n\tON_COMMAND(ID_MENU_SEARCHDESCRIPTION, OnMenuSearchDescription)\r\n\tON_COMMAND(ID_MENU_SEARCHFULLTEXT, OnMenuSearchFullText)\r\n\tON_COMMAND(ID_MENU_SEARCHQUICKPASTE, OnMenuSearchQuickPaste)\r\n\tON_COMMAND(ID_MENU_CONTAINSTEXTSEARCHONLY, OnMenuSimpleTextSearch)\r\n\t//ON_WM_CTLCOLOR()\r\n\t//ON_WM_ERASEBKGND()\r\n\t//ON_WM_PAINT()\r\n\tON_COMMAND(ID_QUICKOPTIONS_SHOWINTASKBAR, &CQPasteWnd::OnQuickoptionsShowintaskbar)\r\n\tON_COMMAND(ID_MENU_VIEWASQRCODE, &CQPasteWnd::OnMenuViewasqrcode)\r\n\tON_COMMAND(ID_EXPORT_EXPORTTOTEXTFILE, &CQPasteWnd::OnExportExporttotextfile)\r\n\tON_COMMAND(ID_COMPARE_COMPARE, &CQPasteWnd::OnCompareCompare)\r\n\tON_COMMAND(ID_COMPARE_SELECTLEFTCOMPARE, &CQPasteWnd::OnCompareSelectleftcompare)\r\n\tON_COMMAND(ID_COMPARE_COMPAREAGAINST, &CQPasteWnd::OnCompareCompareagainst)\r\n\tON_UPDATE_COMMAND_UI(ID_COMPARE_COMPARE, &CQPasteWnd::OnUpdateCompareCompare)\r\n\tON_MESSAGE(NM_SHOW_PROPERTIES, OnShowProperties)\r\n\tON_MESSAGE(NM_NEW_GROUP, OnNewGroup)\r\n\tON_MESSAGE(NM_DELETE_ID, OnDeleteId)\r\n\tON_COMMAND(ID_MENU_REGULAREXPRESSIONSEARCH, &CQPasteWnd::OnMenuRegularexpressionsearch)\r\n\r\n\tON_COMMAND(ID_IMPORT_EXPORTTOGOOGLETRANSLATE, &CQPasteWnd::OnImportExporttogoogletranslate)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_EXPORTTOGOOGLETRANSLATE, &CQPasteWnd::OnUpdateImportExporttogoogletranslate)\r\n\tON_COMMAND(ID_IMPORT_EXPORTCLIP_BITMAP, &CQPasteWnd::OnImportExportclipBitmap)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_EXPORTCLIP_BITMAP, &CQPasteWnd::OnUpdateImportExportclipBitmap)\r\n\r\n\tON_COMMAND(ID_MENU_WILDCARDSEARCH, &CQPasteWnd::OnMenuWildcardsearch)\r\n\r\n\tON_COMMAND(ID_MENU_SAVECURRENTCLIPBOARD, &CQPasteWnd::OnMenuSavecurrentclipboard)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_SAVECURRENTCLIPBOARD, &CQPasteWnd::OnUpdateMenuSavecurrentclipboard)\r\n\tON_MESSAGE(NM_MOVE_TO_GROUP, OnListMoveSelectionToGroup)\r\n\tON_COMMAND(ID_CLIPORDER_MOVEUP, &CQPasteWnd::OnCliporderMoveup)\r\n\tON_UPDATE_COMMAND_UI(ID_CLIPORDER_MOVEUP, &CQPasteWnd::OnUpdateCliporderMoveup)\r\n\tON_COMMAND(ID_CLIPORDER_MOVEDOWN, &CQPasteWnd::OnCliporderMovedown)\r\n\tON_UPDATE_COMMAND_UI(ID_CLIPORDER_MOVEDOWN, &CQPasteWnd::OnUpdateCliporderMovedown)\r\n\tON_COMMAND(ID_CLIPORDER_MOVETOTOP, &CQPasteWnd::OnCliporderMovetotop)\r\n\tON_UPDATE_COMMAND_UI(ID_CLIPORDER_MOVETOTOP, &CQPasteWnd::OnUpdateCliporderMovetotop)\r\n\tON_COMMAND(ID_MENU_FILTERON, &CQPasteWnd::OnMenuFilteron)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_FILTERON, &CQPasteWnd::OnUpdateMenuFilteron)\r\n\tON_BN_CLICKED(ON_TOP_WARNING, OnAlwaysOnTopClicked)\r\n\t//ON_WM_CTLCOLOR()\r\n\tON_COMMAND(ID_SPECIALPASTE_UPPERCASE, &CQPasteWnd::OnSpecialpasteUppercase)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_UPPERCASE, &CQPasteWnd::OnUpdateSpecialpasteUppercase)\r\n\tON_COMMAND(ID_SPECIALPASTE_LOWERCASE, &CQPasteWnd::OnSpecialpasteLowercase)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_LOWERCASE, &CQPasteWnd::OnUpdateSpecialpasteLowercase)\r\n\tON_COMMAND(ID_SPECIALPASTE_CAPITALIZE, &CQPasteWnd::OnSpecialpasteCapitalize)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_CAPITALIZE, &CQPasteWnd::OnUpdateSpecialpasteCapitalize)\r\n\tON_COMMAND(ID_SPECIALPASTE_SENTENCE, &CQPasteWnd::OnSpecialpasteSentence)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_SENTENCE, &CQPasteWnd::OnUpdateSpecialpasteSentence)\r\n\tON_COMMAND(ID_SPECIALPASTE_REMOVELINEFEEDS, &CQPasteWnd::OnSpecialpasteRemovelinefeeds)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_REMOVELINEFEEDS, &CQPasteWnd::OnUpdateSpecialpasteRemovelinefeeds)\r\n\tON_COMMAND(ID_SPECIALPASTE_PASTE, &CQPasteWnd::OnSpecialpastePaste)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_PASTE, &CQPasteWnd::OnUpdateSpecialpastePaste)\r\n\tON_COMMAND(ID_SPECIALPASTE_PASTE32919, &CQPasteWnd::OnSpecialpastePaste32919)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_PASTE32919, &CQPasteWnd::OnUpdateSpecialpastePaste32919)\r\n\tON_COMMAND(ID_SPECIALPASTE_TYPOGLYCEMIA, &CQPasteWnd::OnSpecialpasteTypoglycemia)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_TYPOGLYCEMIA, &CQPasteWnd::OnUpdateSpecialpasteTypoglycemia)\r\n\tON_NOTIFY(NM_CLICK, ID_LIST_HEADER, &CQPasteWnd::OnNMClickList1)\r\n\tON_NOTIFY(NM_DBLCLK, ID_LIST_HEADER, &CQPasteWnd::OnNMDblclkList1)\r\n\tON_NOTIFY(NM_RCLICK, ID_LIST_HEADER, &CQPasteWnd::OnNMRClickList1)\r\n\tON_NOTIFY(NM_RDBLCLK, ID_LIST_HEADER, &CQPasteWnd::OnNMRDblclkList1)\r\n\tON_COMMAND(ID_QUICKOPTIONS_SHOWTEXTFORFIRSTTENCOPYHOTKEYS, &CQPasteWnd::OnQuickoptionsShowtextforfirsttencopyhotkeys)\r\n\tON_UPDATE_COMMAND_UI(ID_QUICKOPTIONS_SHOWTEXTFORFIRSTTENCOPYHOTKEYS, &CQPasteWnd::OnUpdateQuickoptionsShowtextforfirsttencopyhotkeys)\r\n\tON_COMMAND(ID_QUICKOPTIONS_SHOWINDICATORACLIPHASBEENPASTED, &CQPasteWnd::OnQuickoptionsShowindicatoracliphasbeenpasted)\r\n\tON_UPDATE_COMMAND_UI(ID_QUICKOPTIONS_SHOWINDICATORACLIPHASBEENPASTED, &CQPasteWnd::OnUpdateQuickoptionsShowindicatoracliphasbeenpasted)\r\n\tON_COMMAND(ID_GROUPS_TOGGLELASTGROUP, &CQPasteWnd::OnGroupsTogglelastgroup)\r\n\tON_UPDATE_COMMAND_UI(ID_GROUPS_TOGGLELASTGROUP, &CQPasteWnd::OnUpdateGroupsTogglelastgroup)\r\n\tON_UPDATE_COMMAND_UI(ID_STICKYCLIPS_MAKETOPSTICKYCLIP, &CQPasteWnd::OnUpdateStickyclipsMaketopstickyclip)\r\n\tON_UPDATE_COMMAND_UI(ID_STICKYCLIPS_MAKELASTSTICKYCLIP, &CQPasteWnd::OnUpdateStickyclipsMakelaststickyclip)\r\n\tON_UPDATE_COMMAND_UI(ID_STICKYCLIPS_REMOVESTICKYSETTING, &CQPasteWnd::OnUpdateStickyclipsRemovestickysetting)\r\n\tON_COMMAND(ID_SPECIALPASTE_PASTE32927, &CQPasteWnd::OnSpecialpastePaste32927)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_PASTE32927, &CQPasteWnd::OnUpdateSpecialpastePaste32927)\r\n\tON_COMMAND(ID_MENU_GLOBALHOTKEYS32933, &CQPasteWnd::OnMenuGlobalhotkeys32933)\r\n\tON_COMMAND(ID_MENU_DELETECLIPDATA32934, &CQPasteWnd::OnMenuDeleteclipdata32934)\r\n\tON_COMMAND(ID_MENU_IMPORTCLIP32935, &CQPasteWnd::OnMenuImportclip32935)\r\n\tON_COMMAND(ID_MENU_NEWCLIP32937, &CQPasteWnd::OnMenuNewclip32937)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_IMPORTCLIP32935, &CQPasteWnd::OnUpdateMenuImportclip32935)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_NEWCLIP32937, &CQPasteWnd::OnUpdateMenuNewclip32937)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_GLOBALHOTKEYS32933, &CQPasteWnd::OnUpdateMenuGlobalhotkeys32933)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_DELETECLIPDATA32934, &CQPasteWnd::OnUpdateMenuDeleteclipdata32934)\r\n\tON_MESSAGE(NM_FOCUS_ON_SEARCH, OnSearchFocused)\r\n\tON_COMMAND(ID_CLIPORDER_REPLACETOPSTICKYCLIP, &CQPasteWnd::OnCliporderReplacetopstickyclip)\r\n\tON_UPDATE_COMMAND_UI(ID_CLIPORDER_REPLACETOPSTICKYCLIP, &CQPasteWnd::OnUpdateCliporderReplacetopstickyclip)\r\n\tON_COMMAND(ID_SENDTO_PROMPTFORNAME, &CQPasteWnd::OnSendtoPromptforname)\r\n\tON_UPDATE_COMMAND_UI(ID_SENDTO_PROMPTFORNAME, &CQPasteWnd::OnUpdateSendtoPromptforname)\r\n\tON_COMMAND(ID_IMPORT_IMPORTCOPIEDFILE, &CQPasteWnd::OnImportImportcopiedfile)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_IMPORTCOPIEDFILE, &CQPasteWnd::OnUpdateImportImportcopiedfile)\r\n\tON_UPDATE_COMMAND_UI(32775, &CQPasteWnd::OnUpdate32775)\r\n\tON_COMMAND_RANGE(CustomFriendStartId, (CustomFriendStartId + MaxCustomFriends + 1), OnCustomSendToFriend)\r\n\tON_COMMAND_RANGE(ChaiScriptMenuStartId, (ChaiScriptMenuStartId + MaxChaiScripts + 1), OnChaiScriptPaste)\r\n\tON_MESSAGE(WM_DPICHANGED, OnDpiChanged)\r\n\tON_COMMAND(ID_CLIPORDER_MOVETOLAST, &CQPasteWnd::OnCliporderMovetolast)\r\n\tON_UPDATE_COMMAND_UI(ID_CLIPORDER_MOVETOLAST, &CQPasteWnd::OnUpdateCliporderMovetolast)\r\n\tON_COMMAND(ID_SPECIALPASTE_PASTE32945, &CQPasteWnd::OnSpecialpastePasteDontUpdateOrder)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_PASTE32945, &CQPasteWnd::OnUpdateOnSpecialPasteDontUpdateOrder)\r\n\tON_COMMAND(ID_SPECIALPASTE_TRIM, &CQPasteWnd::OnSpecialpasteTrim)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_TRIM, &CQPasteWnd::OnUpdateSpecialpasteTrim)\r\n\tON_COMMAND(ID_TRANSPARENCY_INCREASE, &CQPasteWnd::OnTransparencyIncrease)\r\n\tON_UPDATE_COMMAND_UI(ID_TRANSPARENCY_INCREASE, &CQPasteWnd::OnUpdateTransparencyIncrease)\r\n\tON_COMMAND(ID_TRANSPARENCY_DECREASE, &CQPasteWnd::OnTransparencyDecrease)\r\n\tON_UPDATE_COMMAND_UI(ID_TRANSPARENCY_DECREASE, &CQPasteWnd::OnUpdateTransparencyDecrease)\r\n\tON_COMMAND(ID_TRANSPARENCY_TOGGLE, &CQPasteWnd::OnTransparencyToggle)\r\n\tON_UPDATE_COMMAND_UI(ID_TRANSPARENCY_TOGGLE, &CQPasteWnd::OnUpdateTransparencyToggle)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_NONE, &CQPasteWnd::OnUpdateTransparencyNone)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_5, &CQPasteWnd::OnUpdateTransparency5)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_10, &CQPasteWnd::OnUpdateTransparency10)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_15, &CQPasteWnd::OnUpdateTransparency15)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_20, &CQPasteWnd::OnUpdateTransparency20)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_25, &CQPasteWnd::OnUpdateTransparency25)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_30, &CQPasteWnd::OnUpdateTransparency30)\r\n\tON_UPDATE_COMMAND_UI(ID_TRANSPARENCY_35, &CQPasteWnd::OnUpdateTransparency35)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_TRANSPARENCY_40, &CQPasteWnd::OnUpdateTransparency40)\r\n\tON_COMMAND(ID_TRANSPARENCY_35, &CQPasteWnd::OnTransparency35)\r\n\tON_COMMAND(ID_IMPORT_EMAILTO, &CQPasteWnd::OnImportEmailto)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_EMAILTO, &CQPasteWnd::OnUpdateImportEmailto)\r\n\tON_COMMAND(ID_IMPORT_GMAIL, &CQPasteWnd::OnImportGmail)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_GMAIL, &CQPasteWnd::OnUpdateImportGmail)\r\n\tON_COMMAND(ID_IMPORT_EMAILTOASATTACHMENT, &CQPasteWnd::OnImportEmailtoasattachment)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_EMAILTOASATTACHMENT, &CQPasteWnd::OnUpdateImportEmailtoasattachment)\r\n\tON_COMMAND(ID_SPECIALPASTE_SLUGIFY, &CQPasteWnd::OnSpecialpasteSlugify)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_SLUGIFY, &CQPasteWnd::OnUpdateSpecialpasteSlugify)\r\n\tON_COMMAND(ID_IMPORT_EMAIL_CONTENT_ATTACH, &CQPasteWnd::OnImportEmailContentAttach)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_EMAIL_CONTENT_ATTACH, &CQPasteWnd::OnUpdateImportEmailContentAttach)\r\n\tON_COMMAND(ID_SPECIALPASTE_TOGGLECASE, &CQPasteWnd::OnSpecialpasteTogglecase)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_TOGGLECASE, &CQPasteWnd::OnUpdateSpecialpasteTogglecase)\r\n\tON_COMMAND(ID_FIRST_SHOWSTARTUPMESSAGE, &CQPasteWnd::OnFirstShowstartupmessage)\r\n\r\n\tON_COMMAND(ID_MENU_RESTOREDATABSAE, &CQPasteWnd::OnFirstRestoreDb)\r\n\tON_COMMAND(ID_MENU_BACKUPDATABASE, &CQPasteWnd::OnFirstBackupDb)\r\n\tON_COMMAND(ID_MENU_DELETEALLNONUSEDCLIPS, &CQPasteWnd::OnMenuDeleteallnonusedclips)\r\n\tON_UPDATE_COMMAND_UI(ID_MENU_DELETEALLNONUSEDCLIPS, &CQPasteWnd::OnUpdateMenuDeleteallnonusedclips)\r\n\tON_COMMAND(ID_IMPORT_SETDRAGFILENAME, &CQPasteWnd::OnImportSetdragfilename)\r\n\tON_UPDATE_COMMAND_UI(ID_IMPORT_SETDRAGFILENAME, &CQPasteWnd::OnUpdateImportSetdragfilename)\r\n\tON_COMMAND(ID_SPECIALPASTE_CAMELCASE, &CQPasteWnd::OnSpecialpasteCamelcase)\r\n\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_CAMELCASE, &CQPasteWnd::OnUpdateSpecialpasteCamelcase)\r\n\r\n\t\tON_COMMAND(ID_SPECIALPASTE_MULTIPLEIMAGESHORIZONTALLY, &CQPasteWnd::OnSpecialpasteMultipleImagesHorz)\r\n\t\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_MULTIPLEIMAGESHORIZONTALLY, &CQPasteWnd::OnUpdateSpecialpasteMultipleImagesHorz)\r\n\r\n\t\tON_COMMAND(ID_SPECIALPASTE_MULTIPLEIMAGESVERTICALLY, &CQPasteWnd::OnSpecialpasteMultipleImagesVert)\r\n\t\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_MULTIPLEIMAGESVERTICALLY, &CQPasteWnd::OnUpdateSpecialpasteMultipleImagesVert)\r\n\r\n\t\tON_COMMAND(ID_SPECIALPASTE_ASCIITEXTONLY, &CQPasteWnd::OnSpecialpasteAsciitextonly)\r\n\t\tON_UPDATE_COMMAND_UI(ID_SPECIALPASTE_ASCIITEXTONLY, &CQPasteWnd::OnUpdateSpecialpasteAsciitextonly)\r\n\t\tEND_MESSAGE_MAP()\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CQPasteWnd message handlers\r\n\r\nHBRUSH CQPasteWnd::CtlColor(CDC *pDC, UINT nCtlColor)\r\n{\r\n\tpDC->SetBkMode(TRANSPARENT);\r\n\tpDC->SetBkColor(RGB(255, 0, 0));\r\n\r\n\treturn (HBRUSH)GetStockObject(NULL_BRUSH);\r\n}\r\n\r\nBOOL CQPasteWnd::Create(CRect rect, CWnd *pParentWnd)\r\n{\r\n\treturn CWndEx::Create(rect, pParentWnd);\r\n}\r\n\r\nint CQPasteWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)\r\n{\r\n\tif (CWndEx::OnCreate(lpCreateStruct) == -1)\r\n\t{\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tHICON b = (HICON)LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME), IMAGE_ICON, 64, 64, LR_SHARED);\r\n\tSetIcon(b, TRUE);\r\n\r\n\t//BOOL b = this->Register(this);\r\n\r\n\tSetWindowText(_T(QPASTE_TITLE));\r\n\r\n\tm_search.Create(WS_TABSTOP | WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL, CRect(0, 0, 0, 0), this, ID_EDIT_SEARCH);\r\n\tm_search.SetDpiInfo(&m_DittoWindow.m_dpi);\r\n\tm_search.SetPromptText(theApp.m_Language.GetString(_T(\"Search\"), _T(\"Search\")));\r\n\t::SHAutoComplete(m_search.m_hWnd, SHACF_AUTOSUGGEST_FORCE_OFF);\r\n\tSetSearchImages();\r\n\tm_search.LoadPastSearches(CGetSetOptions::GetPastSearchXml());\r\n\r\n\tCRect rcEditArea(m_DittoWindow.m_dpi.Scale(4), m_DittoWindow.m_dpi.Scale(2), m_DittoWindow.m_dpi.Scale(20), m_DittoWindow.m_dpi.Scale(2));\r\n\t//m_search.SetBorder(rcEditArea);\r\n\r\n\tCRect rcCloseArea(m_DittoWindow.m_dpi.Scale(85), m_DittoWindow.m_dpi.Scale(3), m_DittoWindow.m_dpi.Scale(99), m_DittoWindow.m_dpi.Scale(15));\r\n\t//m_search.SetButtonArea(rcCloseArea);\r\n\r\n\t// Create the header control\r\n\tif (!m_lstHeader.Create(WS_TABSTOP | WS_CHILD | WS_VISIBLE | LVS_NOCOLUMNHEADER | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_OWNERDATA | LVS_OWNERDRAWFIXED, CRect(0, 0, 0, 0), this, ID_LIST_HEADER))\r\n\t{\r\n\t\tASSERT(FALSE);\r\n\t\treturn -1;\r\n\t}\r\n\tm_lstHeader.SetDpiInfo(&m_DittoWindow.m_dpi);\r\n\tm_lstHeader.ShowWindow(SW_SHOW);\r\n\r\n\t((CWnd*)&m_GroupTree)->CreateEx(NULL, _T(\"SysTreeView32\"), NULL, TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS, CRect(0, 0, 100, 100), this, 0);\r\n\tm_GroupTree.ModifyStyle(WS_CAPTION | WS_TABSTOP, 0);\r\n\r\n\tm_GroupTree.SetNotificationWndEx(m_hWnd);\r\n\tm_GroupTree.ShowWindow(SW_HIDE);\r\n\tm_GroupTree.m_showRightClickMenu = true;\r\n\r\n\tm_ShowGroupsFolderBottom.Create(NULL, WS_CHILD | BS_OWNERDRAW | WS_TABSTOP, CRect(0, 0, 0, 0), this, ID_SHOW_GROUPS_BOTTOM);\r\n\t//m_ShowGroupsFolderBottom.LoadBitmaps(IDB_CLOSED_FOLDER, IDB_CLOSED_FOLDER_PRESSED, IDB_CLOSED_FOLDER_FOCUSED);\r\n\tm_ShowGroupsFolderBottom.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), open_folder_24, open_folder_30, open_folder_36, open_folder_42, open_folder_48, _T(\"PNG\"), open_folder_54, open_folder_60, open_folder_66, open_folder_72, open_folder_78, open_folder_84);\r\n\tm_ShowGroupsFolderBottom.ShowWindow(SW_SHOW);\r\n\tm_ShowGroupsFolderBottom.SetToolTipText(theApp.m_Language.GetString(_T(\"GroupsTooltip\"), _T(\"Groups\")));\r\n\tm_ShowGroupsFolderBottom.ModifyStyle(WS_TABSTOP, 0);\r\n\r\n\tm_BackButton.Create(NULL, WS_CHILD | BS_OWNERDRAW | WS_TABSTOP, CRect(0, 0, 0, 0), this, ID_BACK_BUTTON);\r\n\tm_BackButton.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), return_16, return_20, return_24, return_28, return_32, _T(\"PNG\"));\r\n\tm_BackButton.ModifyStyle(WS_TABSTOP, 0);\r\n\tm_BackButton.ShowWindow(SW_SHOW);\r\n\r\n\tm_systemMenu.Create(NULL, WS_CHILD | BS_OWNERDRAW | WS_TABSTOP, CRect(0, 0, 0, 0), this, ID_SYSTEM_BUTTON);\r\n\tm_systemMenu.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), system_menu_2_24, system_menu_2_30, system_menu_2_36, system_menu_2_42, system_menu_2_48, _T(\"PNG\"), system_menu_54, system_menu_60, system_menu_66, system_menu_72, system_menu_78, system_menu_84);\r\n\tm_systemMenu.ModifyStyle(WS_TABSTOP, 0);\r\n\tm_systemMenu.ShowWindow(SW_SHOW);\r\n\r\n\tm_stGroup.Create(_T(\"\"), WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), this, ID_GROUP_TEXT);\r\n\r\n\t//Set the z-order\r\n\tm_lstHeader.SetWindowPos(this, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);\r\n\tm_search.SetWindowPos(&m_lstHeader, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);\r\n\tm_ShowGroupsFolderBottom.SetWindowPos(&m_search, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);\r\n\r\n\t//LVS_EX_FLATSB\r\n\tm_lstHeader.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);\r\n\r\n\t// Create the columns\r\n\tif (m_lstHeader.InsertColumn(0, _T(\"\"), LVCFMT_LEFT, 2500, 0) != 0)\r\n\t{\r\n\t\tASSERT(FALSE);\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tm_Alpha.SetWindowHandle(m_hWnd);\r\n\r\n\tCString onTopMsg = theApp.m_Language.GetString(_T(\"TurnOfAlwaysOntop\"), _T(\"Always on Top Enabled\"));\r\n\tCString shortcutText = m_actions.GetCmdKeyText(ActionEnums::TOGGLESHOWPERSISTANT);\r\n\tif (shortcutText != _T(\"\") &&\r\n\t\tshortcutText.Find(\"\\t\" + shortcutText) < 0)\r\n\t{\r\n\t\tonTopMsg += \"\\t(\";\r\n\t\tonTopMsg += shortcutText;\r\n\t\tonTopMsg += \")\";\r\n\t}\r\n\r\n\tm_alwaysOnToWarningStatic.Create(onTopMsg, WS_CHILD | SS_CENTERIMAGE | SS_NOTIFY, CRect(0, 0, 0, 0), this, ON_TOP_WARNING);\r\n\tm_alwaysOnToWarningStatic.SetBkColor(COLORREF(RGB(255, 255, 0)));\r\n\tm_alwaysOnToWarningStatic.SetTextColor(COLORREF(RGB(0, 0, 255)));\r\n\tm_alwaysOnToWarningStatic.SetToggleCursor(true);\r\n\tm_alwaysOnToWarningStatic.SetFont(&m_groupFont);\r\n\r\n\tm_noSearchResultsStatic.Create(onTopMsg, WS_CHILD, CRect(0, 0, 0, 0), this, ID_NO_SEARCH_RESULTS);\r\n\r\n\tm_popupMsg.m_hWndPosRelativeTo = m_hWnd;\r\n\r\n\tUpdateFont();\r\n\r\n\tm_thread.Start(this);\r\n\tm_extraDataThread.Start(this);\r\n\r\n\tLoadShortcuts();\r\n\r\n\tInvalidateNc();\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid CQPasteWnd::LoadShortcuts()\r\n{\r\n\tm_modifierKeyActions.RemoveAll();\r\n\r\n\tm_modifierKeyActions.m_checkModifierKeys = false;\r\n\tm_modifierKeyActions.AddAccel(ActionEnums::MODIFIER_ACTVE_SELECTIONUP, VK_UP);\r\n\tm_modifierKeyActions.AddAccel(ActionEnums::MODIFIER_ACTVE_SELECTIONDOWN, VK_DOWN);\r\n\tm_modifierKeyActions.AddAccel(ActionEnums::MODIFIER_ACTVE_MOVEFIRST, VK_HOME);\r\n\tm_modifierKeyActions.AddAccel(ActionEnums::MODIFIER_ACTVE_MOVELAST, VK_END);\r\n\r\n\tm_actions.RemoveAll();\r\n\tm_toolTipActions.RemoveAll();\r\n\r\n\tm_actions.AddAccel(ActionEnums::NEXTTABCONTROL, VK_TAB);\r\n\tm_actions.AddAccel(ActionEnums::PREVTABCONTROL, ACCEL_MAKEKEY(VK_TAB, HOTKEYF_CONTROL));\r\n\tm_actions.AddAccel(ActionEnums::BACKGRROUP, VK_BACK);\r\n\tm_actions.AddAccel(ActionEnums::DELETE_SELECTED, VK_DELETE);\r\n\r\n\tm_actions.AddAccel(ActionEnums::HOMELIST, VK_HOME);\r\n\tm_actions.AddAccel(ActionEnums::SHOWMENU, VK_APPS);\r\n\tm_actions.AddAccel(ActionEnums::SYSTEM_MENU, ACCEL_MAKEKEY(VK_APPS, HOTKEYF_CONTROL));\r\n\r\n\tm_search.SetLastSearchAccel(CAccel(0, ActionEnums::APPLY_LAST_SEARCH, 0));\r\n\r\n\tfor (DWORD i = ActionEnums::FIRST_ACTION + 1; i < ActionEnums::LAST_ACTION; i++)\r\n\t{\r\n\t\tActionEnums::ActionEnumValues action = (ActionEnums::ActionEnumValues) i;\r\n\r\n\t\tif (ActionEnums::UserConfigurable(action))\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tint a = CGetSetOptions::GetActionShortCutA(action, i);\r\n\t\t\t\tif (a > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tint b = CGetSetOptions::GetActionShortCutB(action, i);\r\n\t\t\t\t\tm_actions.AddAccel(action, a, b);\r\n\r\n\t\t\t\t\t//always add a shift variation to show description F3 so it will search backwards in the text search\r\n\t\t\t\t\tif (action == ActionEnums::SHOWDESCRIPTION)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint shift = HOTKEYF_SHIFT;\r\n\t\t\t\t\t\tif ((HIBYTE(a) & HOTKEYF_SHIFT))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tshift = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tm_actions.AddAccel(action, ACCEL_MAKEKEY(LOBYTE(a), shift), b);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (action == ActionEnums::APPLY_LAST_SEARCH)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_search.SetLastSearchAccel(CAccel(a, action, b));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (ActionEnums::ToolTipAction(action))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_toolTipActions.AddAccel(action, a, b);\r\n\r\n\t\t\t\t\t\tif (action == ActionEnums::SHOWDESCRIPTION)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tint shift = HOTKEYF_SHIFT;\r\n\t\t\t\t\t\t\tif ((HIBYTE(a) & HOTKEYF_SHIFT))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tshift = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tm_toolTipActions.AddAccel(action, ACCEL_MAKEKEY(LOBYTE(a), shift), b);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (auto & element : CGetSetOptions::m_pasteScripts.m_list)\r\n\t{\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tint a = CGetSetOptions::GetActionShortCutA(ActionEnums::PASTE_SCRIPT, i, element.m_guid);\r\n\t\t\tif (a > 0)\r\n\t\t\t{\r\n\t\t\t\tint b = CGetSetOptions::GetActionShortCutB(ActionEnums::PASTE_SCRIPT, i, element.m_guid);\r\n\t\t\t\tm_actions.AddAccel(ActionEnums::PASTE_SCRIPT, a, b, element.m_guid);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_actions.AddAccel(ActionEnums::TOGGLEFILELOGGING, ACCEL_MAKEKEY('D', HOTKEYF_CONTROL), ACCEL_MAKEKEY('F', HOTKEYF_CONTROL));\r\n\tm_actions.AddAccel(ActionEnums::TOGGLEOUTPUTDEBUGSTRING, ACCEL_MAKEKEY('D', HOTKEYF_CONTROL), ACCEL_MAKEKEY('O', HOTKEYF_CONTROL));\r\n\r\n\tm_lstHeader.SetTooltipActions(&m_toolTipActions);\r\n}\r\n\r\nvoid CQPasteWnd::SetSearchImages()\r\n{\r\n\t//int iSourceImageDPIToUse = 96; // We will assume 96 by default.\r\n\r\n\t//if (m_DittoWindow.m_dpi.GetDPI() > 144) \r\n\t//\tiSourceImageDPIToUse = 192;\r\n\t//else if (m_DittoWindow.m_dpi.GetDPI() > 120) \r\n\t//\tiSourceImageDPIToUse = 144;\r\n\t//else if (m_DittoWindow.m_dpi.GetDPI() > 96) \r\n\t//\tiSourceImageDPIToUse = 120;\r\n\r\n\t//// Now select the right resource to load.\r\n\t//switch(iSourceImageDPIToUse)\r\n\t//{\r\n\t//case 120: \r\n\t//\tm_search.SetBitmaps(IDB_BITMAP_SEARCH_NORMAL_125, IDB_BITMAP_SEARCH_CLOSE_125);\r\n\t//\tbreak;\r\n\t//case 144: \r\n\t//\tm_search.SetBitmaps(IDB_BITMAP_SEARCH_NORMAL_150, IDB_BITMAP_SEARCH_CLOSE_150);\r\n\t//\tbreak;\r\n\t//case 192: \r\n\t//\tm_search.SetBitmaps(IDB_BITMAP_SEARCH_NORMAL_200, IDB_BITMAP_SEARCH_CLOSE_200);\r\n\t//\tbreak;\t\t\t\t\t\t\r\n\t//default: // default to 96 DPI\r\n\t//\tm_search.SetBitmaps(IDB_BITMAP_SEARCH_NORMAL, IDB_BITMAP_SEARCH_CLOSE);\r\n\t//\tbreak;\r\n\t//}\r\n}\r\n\r\nvoid CQPasteWnd::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCWndEx::OnSize(nType, cx, cy);\r\n\r\n\tif (!IsWindow(m_lstHeader.m_hWnd))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_popupMsg.Hide();\r\n\r\n\tMoveControls();\r\n}\r\n\r\nvoid CQPasteWnd::MoveControls()\r\n{\r\n\tCRect crRect;\r\n\tGetClientRect(crRect);\r\n\tint cx = crRect.Width();\r\n\tint cy = crRect.Height();\r\n\r\n\t//Hide the two pixels of space at the top, not sure where this is coming from\r\n\tint topOfListBox = 0;\r\n\r\n\tif (theApp.m_GroupID > 0)\r\n\t{\r\n\t\tm_stGroup.ShowWindow(SW_SHOW);\r\n\t\tm_BackButton.ShowWindow(SW_SHOW);\r\n\r\n\t\tm_BackButton.MoveWindow(m_DittoWindow.m_dpi.Scale(2), m_DittoWindow.m_dpi.Scale(2), m_DittoWindow.m_dpi.Scale(16), m_DittoWindow.m_dpi.Scale(16));\r\n\t\tm_stGroup.MoveWindow(m_DittoWindow.m_dpi.Scale(24), m_DittoWindow.m_dpi.Scale(2), cx - m_DittoWindow.m_dpi.Scale(20), m_DittoWindow.m_dpi.Scale(16));\r\n\r\n\t\ttopOfListBox = m_DittoWindow.m_dpi.Scale(20);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_BackButton.ShowWindow(SW_HIDE);\r\n\t\tm_stGroup.ShowWindow(SW_HIDE);\r\n\t}\r\n\r\n\tint searchRowStart = 33;\r\n\r\n\t/*if(CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\tsearchRowStart = 41;\r\n\t}*/\r\n\r\n\tint nWidth = cx;\r\n\tint listBoxBottomOffset = m_DittoWindow.m_dpi.Scale(searchRowStart);\r\n\r\n\tint extraSize = 0;\r\n\r\n\tif (m_showScrollBars == false &&\r\n\t\tCGetSetOptions::m_showScrollBar == false)\r\n\t{\r\n\t\textraSize = m_DittoWindow.m_dpi.Scale(::GetSystemMetrics(SM_CXVSCROLL));\r\n\r\n\t\tCRgn rgnRect;\r\n\t\tCRect r;\r\n\t\tm_lstHeader.GetWindowRect(&r);\r\n\r\n\t\trgnRect.CreateRectRgn(0, 0, cx, (cy - listBoxBottomOffset - topOfListBox) + 1);\r\n\r\n\t\tm_lstHeader.SetWindowRgn(rgnRect, TRUE);\r\n\t}\r\n\r\n\r\n\tif (m_noSearchResults &&\r\n\t\tm_strSearch != _T(\"\"))\r\n\t{\r\n\t\tm_lstHeader.ShowWindow(SW_HIDE);\r\n\t\tm_noSearchResultsStatic.ShowWindow(SW_SHOW);\r\n\r\n\t\tauto border = m_DittoWindow.m_dpi.Scale(10);\r\n\t\tm_noSearchResultsStatic.MoveWindow(border, topOfListBox + border, cx - border, cy - listBoxBottomOffset - topOfListBox + 1 - border);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_lstHeader.ShowWindow(SW_SHOW);\r\n\t\tm_noSearchResultsStatic.ShowWindow(SW_HIDE);\r\n\r\n\t\tm_lstHeader.MoveWindow(0, topOfListBox, cx + extraSize, cy - listBoxBottomOffset - topOfListBox + extraSize + 1);\r\n\t}\r\n\tm_search.MoveWindow(m_DittoWindow.m_dpi.Scale(34), cy - m_DittoWindow.m_dpi.Scale(searchRowStart - 5), cx - m_DittoWindow.m_dpi.Scale(70), m_DittoWindow.m_dpi.Scale(25));\r\n\r\n\tm_systemMenu.MoveWindow(cx - m_DittoWindow.m_dpi.Scale(30), cy - m_DittoWindow.m_dpi.Scale(28), m_DittoWindow.m_dpi.Scale(24), m_DittoWindow.m_dpi.Scale(24));\r\n\r\n\tm_ShowGroupsFolderBottom.MoveWindow(m_DittoWindow.m_dpi.Scale(4), cy - m_DittoWindow.m_dpi.Scale(28), m_DittoWindow.m_dpi.Scale(24), m_DittoWindow.m_dpi.Scale(24));\r\n\r\n\t/*if (CGetSetOptions::m_bShowPersistent &&\r\n\t\tCGetSetOptions::m_bShowAlwaysOnTopWarning)\r\n\t{\r\n\t\tm_alwaysOnToWarningStatic.ShowWindow(SW_SHOW);\r\n\t\tm_alwaysOnToWarningStatic.MoveWindow(m_DittoWindow.m_dpi.Scale(2), cy - m_DittoWindow.m_dpi.Scale(18), cx - m_DittoWindow.m_dpi.Scale(4), m_DittoWindow.m_dpi.Scale(17));\r\n\t}\r\n\telse*/\r\n\t{\r\n\t\tm_alwaysOnToWarningStatic.ShowWindow(SW_HIDE);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnSetFocus(CWnd *pOldWnd)\r\n{\r\n\tCWndEx::OnSetFocus(pOldWnd);\r\n\r\n\tif (::IsWindow(m_lstHeader.m_hWnd))\r\n\t{\r\n\t\tm_lstHeader.SetFocus();\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnKillFocus(CWnd *pOldWnd)\r\n{\r\n\tCWndEx::OnKillFocus(pOldWnd);\r\n}\r\n\r\nvoid CQPasteWnd::OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized)\r\n{\r\n\tCWndEx::OnActivate(nState, pWndOther, bMinimized);\r\n\r\n\tif (m_bHideWnd == false || (m_lstHeader.GetToolTipHWnd() != NULL && m_lstHeader.GetToolTipHWnd() == pWndOther->GetSafeHwnd()))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tLog(StrF(_T(\"CQPasteWnd::OnActivate, nState: %d, Other: %d, Minimized: %d\"), nState, pWndOther, bMinimized));\r\n\r\n\tif (nState == WA_INACTIVE)\r\n\t{\r\n\t\tSaveWindowSize();\r\n\r\n\t\tm_bModifersMoveActive = false;\r\n\r\n\t\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t\t{\r\n\t\t\tHideQPasteWindow(false);\r\n\t\t}\r\n\t\telse if (CGetSetOptions::GetAutoHide())\r\n\t\t{\r\n\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t}\r\n\r\n\t\t//re register the global hot keys for the last ten\r\n\t\tif (theApp.m_bAppExiting == false)\r\n\t\t{\r\n\t\t\tg_HotKeys.RegisterAll();\r\n\t\t}\r\n\r\n\t\tm_lstHeader.HidePopup(true);\r\n\t}\r\n\telse if (nState == WA_ACTIVE || nState == WA_CLICKACTIVE)\r\n\t{\r\n\t\tif (bMinimized == FALSE)\r\n\t\t{\r\n\t\t\tif (theApp.m_bShowingQuickPaste == false)\r\n\t\t\t{\r\n\t\t\t\tBOOL fillList = FALSE;\r\n\t\t\t\tif (m_listItems.size() == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tfillList = TRUE;\r\n\t\t\t\t}\r\n\t\t\t\telse if(theApp.m_databaseOnNetworkShare)\r\n\t\t\t\t{\r\n\t\t\t\t\t__int64 lastWrite = GetLastWriteTime(CGetSetOptions::GetDBPath());\r\n\t\t\t\t\tif (lastWrite > m_lastDbWrite)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_lastDbWrite = lastWrite;\r\n\t\t\t\t\t\tfillList = TRUE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tShowQPasteWindow(fillList);\r\n\t\t\t}\r\n\r\n\t\t\t//Unregister the global hot keys for the last ten copies\r\n\t\t\tg_HotKeys.UnregisterAll(false, true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBOOL CQPasteWnd::HideQPasteWindow(bool releaseFocus, BOOL clearSearchData)\r\n{\r\n\tif (clearSearchData = -1)\r\n\t{\r\n\t\tif ((CGetSetOptions::m_maintainSearchView || CGetSetOptions::m_refreshViewAfterPasting == false) &&\r\n\t\t\tm_strSearch != _T(\"\"))\r\n\t\t{\r\n\t\t\tLog(_T(\"Currently searching for something and setting to maintain search view is enabled, not refreshing\"));\r\n\t\t\tclearSearchData = FALSE;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tclearSearchData = TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tLog(_T(\"Start of HideQPasteWindow\"));\r\n\tDWORD startTick = GetTickCount();\r\n\r\n\tif (!theApp.m_bShowingQuickPaste)\r\n\t{\r\n\t\tLog(_T(\"End of HideQPasteWindow, !theApp.m_bShowingQuickPaste\"));\r\n\t}\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tm_bStopQuery = true;\r\n\t}\r\n\r\n\ttheApp.m_bShowingQuickPaste = false;\r\n\r\n\t//needs to be before we hide our window - inorder to set focus to another window we need to be the foreground window\r\n\t//http://msdn.microsoft.com/en-us/library/windows/desktop/ms632668%28v=vs.85%29.aspx\r\n\tif (releaseFocus)\r\n\t{\r\n\t\ttheApp.m_activeWnd.ReleaseFocus();\r\n\t}\r\n\r\n\tKillTimer(TIMER_FILL_CACHE);\r\n\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\tm_popupMsg.Hide();\r\n\r\n\t//Save the size\r\n\tSaveWindowSize();\r\n\r\n\tif (CGetSetOptions::GetShowInTaskBar())\r\n\t{\r\n\t\tShowWindow(SW_MINIMIZE);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tShowWindow(SW_HIDE);\r\n\t}\r\n\r\n\tif (clearSearchData == TRUE)\r\n\t{\r\n\t\t//Reset the selection in the search combo\r\n\t\tm_bHandleSearchTextChange = false;\r\n\t\tm_search.SetWindowText(_T(\"\"));\r\n\t\tm_bHandleSearchTextChange = true;\r\n\r\n\t\tif (m_strSQLSearch.IsEmpty() == FALSE || m_pendingRefresh)\r\n\t\t{\r\n\t\t\t{\r\n\t\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\t\t\tm_bStopQuery = true;\r\n\t\t\t}\r\n\r\n\t\t\t//Wait for the thread to stop fill the cache so we can clear it\r\n\t\t\tWaitForSingleObject(m_thread.m_SearchingEvent, 5000);\r\n\r\n\t\t\t{\r\n\t\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\t\t\tm_listItems.clear();\r\n\t\t\t\tm_lstHeader.SetItemCountEx(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (theApp.m_GroupID > 0 &&\r\n\t\tCGetSetOptions::GetRevertToTopLevelGroup())\r\n\t{\r\n\t\ttheApp.EnterGroupID(-1);\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttheApp.TryEnterOldGroupState();\r\n\t}\r\n\r\n\tm_pendingRefresh = false;\r\n\r\n\tDWORD endTick = GetTickCount();\r\n\tif ((endTick - startTick) > 150)\r\n\t\tLog(StrF(_T(\"Paste Timing HideQPasteWindow: %d\"), endTick - startTick));\r\n\r\n\tLog(StrF(_T(\"End of HideQPasteWindow, ItemCount: %d\"), m_listItems.size()));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::SaveWindowSize()\r\n{\r\n\tif (this->IsIconic() == FALSE)\r\n\t{\r\n\t\tCRect rect;\r\n\t\tGetWindowRectEx(&rect);\r\n\t\tCSize s = rect.Size();\r\n\t\tCGetSetOptions::SetQuickPasteSize(CSize(m_DittoWindow.m_dpi.UnScale(s.cx), m_DittoWindow.m_dpi.UnScale(s.cy)));\r\n\t\tCGetSetOptions::SetQuickPastePoint(rect.TopLeft());\r\n\t}\r\n}\r\n\r\nBOOL CQPasteWnd::ShowQPasteWindow(BOOL bFillList)\r\n{\r\n\ttheApp.m_bShowingQuickPaste = true;\r\n\r\n\tLog(StrF(_T(\"Start - ShowQPasteWindow - Fill List: %d, array count: %d\"), bFillList, m_listItems.size()));\r\n\r\n\t//Ensure we have the latest theme file, this checks the last write time so it doesn't read the file each time\r\n\tCGetSetOptions::m_Theme.Load(CGetSetOptions::GetTheme(), false, true);\r\n\r\n\tSetCaptionColorActive(CGetSetOptions::m_bShowPersistent, theApp.GetConnectCV());\r\n\tSetCaptionOn(CGetSetOptions::GetCaptionPos(), true, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\r\n\tUpdateStatus();\r\n\r\n\tm_bHideWnd = true;\r\n\r\n\tSetCurrentTransparency();\r\n\r\n\tm_lstHeader.SetNumberOfLinesPerRow(CGetSetOptions::GetLinesPerRow(), false);\r\n\tm_lstHeader.SetShowTextForFirstTenHotKeys(CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\tm_lstHeader.SetShowIfClipWasPasted(CGetSetOptions::GetShowIfClipWasPasted());\r\n\r\n\tif (bFillList)\r\n\t{\r\n\t\tFillList();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMoveControls();\r\n\t}\r\n\r\n\t// always on top... for persistent showing (CGetSetOptions::m_bShowPersistent)\r\n\t// SHOWWINDOW was also integrated into this function rather than calling it separately\r\n\tif (CGetSetOptions::GetShowPersistent())\r\n\t{\r\n\t\t::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);\r\n\t}\r\n\r\n\t//SetKeyModiferState(true);\r\n\r\n\tLog(StrF(_T(\"END - ShowQPasteWindow - Fill List: %d, array count: %d\"), bFillList, m_listItems.size()));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nbool CQPasteWnd::Add(const CString &csHeader, const CString &csText, int nID)\r\n{\r\n\tint nNewIndex;\r\n\r\n\tif ((nNewIndex = m_lstHeader.InsertItem(m_lstHeader.GetItemCount(), csHeader)) == -1)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tm_lstHeader.SetItemData(nNewIndex, nID);\r\n\r\n\treturn true;\r\n}\r\n\r\nBOOL CQPasteWnd::OpenID(int id, CSpecialPasteOptions pasteOptions)\r\n{\r\n\tLog(StrF(_T(\"Start OpenId, Id: %d, Only CF_TEXT: %s\"), id, pasteOptions.ToString()));\r\n\r\n\tif (pasteOptions.m_pPasteFormats == NULL)\r\n\t{\r\n\t\tif (theApp.EnterGroupID(id, FALSE, FALSE))\r\n\t\t{\r\n\t\t\tLog(_T(\"Entered group\"));\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\t// else, it is a clip, so paste it\r\n\tCProcessPaste paste;\r\n\r\n\tpaste.m_bSendPaste = CGetSetOptions::m_bSendPasteMessageAfterSelection == TRUE ? true : false;\r\n\tpaste.m_pasteOptions = pasteOptions;\r\n\tpaste.m_pastedFromGroup = (theApp.m_GroupID > 0);\r\n\r\n\tpaste.GetClipIDs().Add(id);\r\n\r\n\tif (paste.DoPaste())\r\n\t{\r\n\t\ttheApp.OnPasteCompleted();\r\n\r\n\t\tif (CGetSetOptions::m_bSendPasteMessageAfterSelection == FALSE)\r\n\t\t{\r\n\t\t\ttheApp.m_activeWnd.ActivateTarget();\r\n\t\t}\r\n\r\n\t\tif (CGetSetOptions::m_bShowPersistent && CGetSetOptions::GetAutoHide())\r\n\t\t{\r\n\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCString errorMessage;\r\n\t\terrorMessage.Format(_T(\"Paste Error - %s\"), paste.m_lastErrorMessage);\r\n\t\tm_popupMsg.Show(errorMessage, CPoint(0, 0), true);\r\n\t\tSetTimer(TIMER_ERROR_MSG, CGetSetOptions::GetErrorMsgPopupTimeout(), NULL);\r\n\t}\r\n\r\n\tLog(StrF(_T(\"End OpenId, Id: %d, Only CF_TEXT: %s\"), id, pasteOptions.ToString()));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CQPasteWnd::OpenSelection(CSpecialPasteOptions pasteOptions)\r\n{\r\n\tLog(_T(\"Start Open Selection\"));\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tif (count <= 0)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (count == 1)\r\n\t{\r\n\t\treturn OpenID(IDs[0], pasteOptions);\r\n\t}\r\n\r\n\tCProcessPaste paste;\r\n\r\n\tpaste.m_bSendPaste = CGetSetOptions::m_bSendPasteMessageAfterSelection == TRUE ? true : false;\r\n\tpaste.m_pasteOptions = pasteOptions;\r\n\tpaste.m_pastedFromGroup = (theApp.m_GroupID > 0);\r\n\r\n\r\n\tpaste.GetClipIDs().Copy(IDs);\r\n\tif (paste.DoPaste())\r\n\t{\r\n\t\ttheApp.OnPasteCompleted();\r\n\r\n\t\tif (CGetSetOptions::m_bSendPasteMessageAfterSelection == FALSE)\r\n\t\t{\r\n\t\t\ttheApp.m_activeWnd.ActivateTarget();\r\n\t\t}\r\n\r\n\t\tif (CGetSetOptions::m_bShowPersistent && CGetSetOptions::GetAutoHide())\r\n\t\t{\r\n\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCString errorMessage;\r\n\t\terrorMessage.Format(_T(\"Paste Error - %s\"), paste.m_lastErrorMessage);\r\n\t\tm_popupMsg.Show(errorMessage, CPoint(0, 0), true);\r\n\t\tSetTimer(TIMER_ERROR_MSG, CGetSetOptions::GetErrorMsgPopupTimeout(), NULL);\r\n\t}\r\n\r\n\tLog(_T(\"End Open Selection\"));\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL CQPasteWnd::OpenIndex(int item)\r\n{\r\n\tif (item >= m_lstHeader.GetItemCount())\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tCSpecialPasteOptions pasteOptions;\r\n\treturn OpenID(m_lstHeader.GetItemData(item), pasteOptions);\r\n}\r\n\r\nBOOL CQPasteWnd::NewGroup(bool bGroupSelection, int parentId)\r\n{\r\n\tCGroupName Name;\r\n\tCString csName(\"\");\r\n\r\n\tif (CGetSetOptions::m_bPrompForNewGroupName)\r\n\t{\r\n\t\tm_bHideWnd = false;\r\n\r\n\t\tCDimWnd dimmer(this);\r\n\r\n\t\tINT_PTR nRet = Name.DoModal();\r\n\r\n\t\tm_bHideWnd = true;\r\n\r\n\t\tif (nRet == IDOK)\r\n\t\t{\r\n\t\t\tcsName = Name.m_csName;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tint id = NewGroupID(parentId, csName);\r\n\r\n\tif (id <= 0)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tif (!bGroupSelection)\r\n\t{\r\n\t\ttheApp.m_FocusID = id; // focus on the new group\r\n\t\tFillList();\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tIDs.MoveTo(id);\r\n\ttheApp.EnterGroupID(id);\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnListSelect_DB_ID(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tOpenID((int)wParam, pasteOptions);\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnListMoveSelectionToGroup(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tint groupId = (int)wParam;\r\n\tif (groupId >= -1)\r\n\t{\r\n\t\tCClipIDs IDs;\r\n\t\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\t\tIDs.MoveTo(groupId);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnCopyClip(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tDoCopySelection();\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnSearchEnterKeyPressed(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tMSG msg;\r\n\tmsg.lParam = 0;\r\n\tmsg.wParam = VK_RETURN;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnListEnd(WPARAM wParam, LPARAM lParam)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnReloadClipInUI(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tBOOL foundClip = FALSE;\r\n\tint clipId = (int)wParam;\r\n\tint updateFlags = (int)lParam;\r\n\r\n\tif (CGetSetOptions::m_maintainSearchView &&\r\n\t\tm_strSearch != _T(\"\") &&\r\n\t\tupdateFlags & UPDATE_AFTER_PASTE_SELECT_CLIP)\r\n\t{\r\n\t\tLog(_T(\"Currently searching for something and setting to maintain search view is enabled, not refreshing clip order\"));\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tDWORD startTick = GetTickCount();\t\r\n\r\n\ttheApp.m_FocusID = -1;\r\n\r\n\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT clipOrder, clipGroupOrder, lastPasteDate, mText FROM Main WHERE lID = %d\"), clipId);\r\n\tif (q.eof() == false)\r\n\t{\r\n\t\tdouble order = q.getFloatField(_T(\"clipOrder\"));\r\n\t\tdouble orderGroup = q.getFloatField(_T(\"clipGroupOrder\"));\r\n\t\tint lastPasted = q.getIntField(_T(\"lastPasteDate\"));\r\n\t\tCString description = q.getStringField(_T(\"mText\"));\r\n\r\n\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\twhile (iter != m_listItems.end())\r\n\t\t{\r\n\t\t\tif (iter->m_lID == clipId)\r\n\t\t\t{\r\n\t\t\t\tif (updateFlags & UPDATE_AFTER_PASTE_SELECT_CLIP)\r\n\t\t\t\t{\r\n\t\t\t\t\titer->m_datePasted = lastPasted;\r\n\r\n\t\t\t\t\tif (iter->m_clipOrder != order || iter->m_clipGroupOrder != orderGroup)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titer->m_clipOrder = order;\r\n\t\t\t\t\t\titer->m_clipGroupOrder = orderGroup;\r\n\r\n\t\t\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfoundClip = TRUE;\r\n\r\n\t\t\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t\t\t\tSelectFocusID();\r\n\t\t\t\t}\r\n\t\t\t\telse if (updateFlags & UPDATE_CLIP_DESCRIPTION)\r\n\t\t\t\t{\r\n\t\t\t\t\titer->m_Desc = description;\r\n\r\n\t\t\t\t\tfoundClip = TRUE;\r\n\r\n\t\t\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\titer++;\r\n\t\t}\r\n\t}\r\n\r\n\tDWORD endTick = GetTickCount();\r\n\tif ((endTick - startTick) > 150)\r\n\t\tLog(StrF(_T(\"Paste Timing OnReloadClipInUI: %d, ClipId: %d\"), endTick - startTick, clipId));\r\n\r\n\treturn foundClip;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnRefreshView(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tMSG msg;\r\n\t// remove all additional refresh view messages from the queue\r\n\twhile (::PeekMessage(&msg, m_hWnd, WM_REFRESH_VIEW, WM_REFRESH_VIEW, PM_REMOVE)) {}\r\n\r\n\tif (theApp.m_bShowingQuickPaste)\r\n\t{\r\n\t\tCopyReasonEnum::CopyReason copyReason = (CopyReasonEnum::CopyReason)wParam;\r\n\t\tif (copyReason == CopyReasonEnum::COPY_FROM_TOOLTIP)\r\n\t\t{\r\n\t\t\tm_pendingRefresh = true;\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\tLog(_T(\"OnRefreshView - Start\"));\r\n\tCString action;\r\n\r\n\ttheApp.m_FocusID = -1;\r\n\r\n\tm_bHandleSearchTextChange = false;\r\n\r\n\tm_search.SetWindowText(_T(\"\"));\r\n\tm_bHandleSearchTextChange = true;\r\n\r\n\tif (theApp.m_bShowingQuickPaste)\r\n\t{\r\n\t\tFillList(_T(\"\"));\r\n\t\taction = _T(\"Filled List\");\t\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//Wait for the thread to stop fill the cache so we can clear it\r\n\t\tWaitForSingleObject(m_thread.m_SearchingEvent, 5000);\r\n\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\t\tm_listItems.clear();\r\n\t\t}\r\n\r\n\t\tm_lstHeader.SetItemCountEx(0);\r\n\t\tUpdateStatus();\r\n\r\n\t\taction = _T(\"Cleared Items\");\r\n\t}\r\n\r\n\tLog(StrF(_T(\"OnRefreshView - End - Count: %d, Action: %s\"), m_listItems.size(), action));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::RefreshNc()\r\n{\r\n\tif (!theApp.m_bShowingQuickPaste)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tInvalidateNc();\r\n}\r\n\r\nvoid CQPasteWnd::UpdateStatus(bool bRepaintImmediately)\r\n{\r\n\tCString title = m_Title;\r\n\r\n\tif (CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\ttitle = (StrF(_T(\"%s %s\"), _T(QPASTE_TITLE), theApp.m_Language.GetString(\"top_window\", \"[Always on top]\")));\r\n\t}\r\n\r\n\tif (theApp.IsClipboardViewerConnected() == FALSE)\r\n\t{\r\n\t\ttitle += _T(\" \");\r\n\t\ttitle += theApp.m_Language.GetString(\"disconnected\", \"[Disconnected]\");\r\n\t}\r\n\r\n\tCString cs;\r\n\tcs.Format(_T(\" - %d/%d\"), m_lstHeader.GetSelectedCount(), m_lstHeader.GetItemCount());\r\n\ttitle += cs;\r\n\r\n\tif (theApp.m_Status != \"\")\r\n\t{\r\n\t\ttitle += \" [ \";\r\n\t\ttitle += theApp.m_Status;\r\n\t\ttitle += \" ] - \";\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttitle += \" - \";\r\n\t}\r\n\r\n\tif (::IsWindow(theApp.m_activeWnd.ActiveWnd()))\r\n\t{\r\n\t\ttitle += theApp.m_activeWnd.ActiveWndName();\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttitle += theApp.m_Language.GetString(\"No_Target\", \"No target\");\r\n\t}\r\n\r\n\tSetToolTipText(title);\r\n\r\n\tCString windowTitle = _T(QPASTE_TITLE);\r\n\r\n\tif (CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\twindowTitle += StrF(_T(\" %s\"), theApp.m_Language.GetString(\"top_window\", \"[Always on top]\"));\r\n\t}\r\n\r\n\tif (theApp.IsClipboardViewerConnected() == FALSE)\r\n\t{\r\n\t\twindowTitle += StrF(_T(\" %s\"), theApp.m_Language.GetString(\"disconnected\", \"[Disconnected]\"));\r\n\t}\r\n\r\n\tSetCustomWindowTitle(windowTitle);\r\n}\r\n\r\nBOOL CQPasteWnd::FillList(CString csSQLSearch)\r\n{\r\n\tKillTimer(TIMER_DO_SEARCH);\r\n\t\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\tLog(StrF(_T(\"Start Fill List - %s\"), csSQLSearch));\r\n\r\n\tm_lstHeader.SetSearchText(csSQLSearch);\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\tm_bStopQuery = true;\r\n\t}\r\n\r\n\tCString strFilter;\r\n\tCString strParentFilter;\r\n\tCString csSort;\r\n\r\n\t// History Groupiter->m_stickyClipGroupOrder = clip.m_stickyClipGroupOrder;\r\n\tif (theApp.m_GroupID < 0)\r\n\t{\r\n\t\t//do not change this this directly relates to the views in the Main table\r\n\t\tcsSort = \"Main.stickyClipOrder DESC, \"\r\n\t\t\t\"Main.bIsGroup ASC, \"\t\t\t\r\n\t\t\t\"Main.clipOrder DESC\";\r\n\r\n\t\tif (CGetSetOptions::m_bShowAllClipsInMainList)\r\n\t\t{\r\n\t\t\tif (CGetSetOptions::GetShowGroupsInMainList())\r\n\t\t\t{\r\n\t\t\t\t//found to be slower on large databases\r\n\t\t\t\tstrFilter = \"((Main.bIsGroup = 1 AND Main.lParentID = -1) OR Main.bIsGroup = 0)\";\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstrFilter = \"(Main.bIsGroup = 0)\";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstrFilter = \"((Main.bIsGroup = 1 AND Main.lParentID = -1) OR (Main.bIsGroup = 0 AND Main.lParentID = -1))\";\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\t// it's some other group\r\n\t{\r\n\t\t//do not change this this directly relates to the views in the Main table\r\n\t\tcsSort = \"Main.stickyClipGroupOrder DESC, \"\r\n\t\t\t\"Main.bIsGroup ASC, \"\t\t\t\r\n\t\t\t\"Main.clipGroupOrder DESC\";\r\n\r\n\t\t//Main.stickyClipGroupOrder DESC, Main.clipGroupOrder DESC\";//\r\n\r\n\t\tif (theApp.m_GroupID >= 0)\r\n\t\t{\r\n\t\t\tstrFilter.Format(_T(\"Main.lParentID = %d\"), theApp.m_GroupID);\r\n\t\t\tstrParentFilter = strFilter;\r\n\t\t}\r\n\r\n\t\tm_stGroup.SetWindowText(theApp.m_GroupText);\r\n\t}\r\n\r\n\tCRect crRect;\r\n\tGetClientRect(crRect);\r\n\r\n\tCString csSQL;\r\n\tCString dataJoin;\r\n\tCString IsDistinct = _T(\"\");\r\n\r\n\tCString sqlSearch = \"\";\r\n\r\n\tif (csSQLSearch == \"\")\r\n\t{\r\n\t\tm_strSQLSearch = \"\";\r\n\t\tm_strSearch = \"\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCFormatSQL descriptionFormat;\r\n\t\tCString descriptionSql;\r\n\t\tCFormatSQL quickPasteFormat;\r\n\t\tCString quickPasteSql;\r\n\t\tCFormatSQL fullTextFormat;\r\n\t\tCString fullTextSql;\r\n\r\n\t\t//If other are off then always search the description\r\n\t\tif (CGetSetOptions::GetSearchDescription() ||\r\n\t\t\t(CGetSetOptions::GetSearchFullText() == FALSE && CGetSetOptions::GetSearchQuickPaste() == FALSE))\r\n\t\t{\r\n\t\t\tdescriptionFormat.SetVariable(\"Main.mText\");\r\n\r\n\t\t\tdescriptionFormat.Parse(csSQLSearch);\r\n\t\t\tdescriptionSql = descriptionFormat.GetSQLString();\r\n\t\t}\r\n\r\n\t\tif (csSQLSearch.Left(3) == _T(\"/q \") ||\r\n\t\t\tcsSQLSearch.Left(3) == _T(\"\\\\q \") ||\r\n\t\t\tCGetSetOptions::GetSearchQuickPaste())\r\n\t\t{\r\n\t\t\tquickPasteFormat.SetVariable(\"Main.QuickPasteText\");\r\n\r\n\t\t\tif (csSQLSearch.Left(3) == _T(\"/q \") ||\r\n\t\t\t\tcsSQLSearch.Left(3) == _T(\"\\\\q \"))\r\n\t\t\t{\r\n\t\t\t\tcsSQLSearch = csSQLSearch.Mid(3);\r\n\t\t\t}\r\n\r\n\t\t\tquickPasteFormat.Parse(csSQLSearch);\r\n\t\t\tquickPasteSql = quickPasteFormat.GetSQLString();\r\n\t\t}\r\n\r\n\t\tif (csSQLSearch.Left(3) == _T(\"/f \") ||\r\n\t\t\tcsSQLSearch.Left(3) == _T(\"\\\\f \") ||\r\n\t\t\tCGetSetOptions::GetSearchFullText())\r\n\t\t{\r\n\t\t\tdataJoin = _T(\"INNER JOIN Data on Data.lParentID = Main.lID\");\r\n\r\n\t\t\tif (csSQLSearch.Left(3) == _T(\"/f \") ||\r\n\t\t\t\tcsSQLSearch.Left(3) == _T(\"\\\\f \"))\r\n\t\t\t{\r\n\t\t\t\tcsSQLSearch = csSQLSearch.Mid(3);\r\n\t\t\t}\r\n\r\n\t\t\tfullTextFormat.SetVariable(\"Data.ooData\");\r\n\t\t\tfullTextFormat.Parse(csSQLSearch);\r\n\t\t\tfullTextSql = fullTextFormat.GetSQLString();\r\n\r\n\t\t\tfullTextSql.Insert(1, _T(\"Data.strClipBoardFormat = 'CF_UNICODETEXT' AND \"));\r\n\r\n\t\t\t//If we are also search for other text make sure we only get one entry, including the data rows will cause multiple rows to be returned\r\n\t\t\tif (descriptionSql != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tIsDistinct = _T(\"DISTINCT\");\r\n\t\t\t}\r\n\r\n\t\t\tif (quickPasteSql != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tIsDistinct = _T(\"DISTINCT\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstrFilter = _T(\"(\");\r\n\r\n\t\tif (descriptionSql != _T(\"\"))\r\n\t\t{\r\n\t\t\tstrFilter += descriptionSql;\r\n\t\t}\r\n\r\n\t\tif (quickPasteSql != _T(\"\"))\r\n\t\t{\r\n\t\t\tif (descriptionSql != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tstrFilter += _T(\" OR \");\r\n\t\t\t}\r\n\r\n\t\t\tstrFilter += quickPasteSql;\r\n\t\t}\r\n\r\n\t\tif (fullTextSql != _T(\"\"))\r\n\t\t{\r\n\t\t\tif (descriptionSql != _T(\"\") ||\r\n\t\t\t\tquickPasteSql != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tstrFilter += _T(\" OR \");\r\n\t\t\t}\r\n\r\n\t\t\tstrFilter += fullTextSql;\r\n\t\t}\r\n\r\n\t\tstrFilter += _T(\")\");\r\n\r\n\t\tif (strParentFilter.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tstrFilter += \" AND \";\r\n\t\t\tstrFilter += strParentFilter;\r\n\t\t}\r\n\r\n\t\tm_strSQLSearch = strFilter;\r\n\t\tm_strSearch = csSQLSearch;\r\n\t}\r\n\r\n\tCString sql;\r\n\tCString countSql;\r\n\r\n\t//Format the count and select sql queries for the thread\r\n\tcountSql.Format(_T(\"SELECT COUNT(%s Main.lID) FROM Main %s where %s\"), IsDistinct, dataJoin, strFilter);\r\n\r\n\tsql.Format(_T(\"SELECT %s Main.lID, Main.mText, Main.lParentID, Main.lDontAutoDelete, \")\r\n\t\t_T(\"Main.lShortCut, Main.bIsGroup, Main.QuickPasteText, Main.clipOrder, Main.clipGroupOrder, \")\r\n\t\t_T(\"Main.stickyClipOrder, Main.stickyClipGroupOrder, Main.lDate, Main.lastPasteDate FROM Main %s \")\r\n\t\t_T(\"where %s order by %s\"), IsDistinct, dataJoin, strFilter, csSort);\r\n\t\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\tm_listItems.clear();\r\n\t}\r\n\r\n\tm_noSearchResults = false;\r\n\tm_lstHeader.SetItemCount(0);\r\n\tm_lstHeader.RefreshVisibleRows();\r\n\r\n\tCPoint loadItem(-1, m_lstHeader.GetCountPerPage() + 2);\r\n\tm_loadItems.push_back(loadItem);\r\n\t\r\n\tm_thread.SetSearchSql(sql, countSql);\r\n\tm_thread.FireLoadItems(true);\r\n\r\n\tMoveControls();\r\n\r\n\tcountSql.Replace(_T(\"%\"), _T(\"%%\"));\r\n\tsql.Replace(_T(\"%\"), _T(\"%%\"));\r\n\tLog(StrF(_T(\"Start Fill List - Count SQL: %s, Query SQL: %s\"), countSql, sql));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::ShowRightClickMenu()\r\n{\r\n\tPOINT pp;\r\n\tCMenu cmPopUp;\r\n\tCMenu *cmSubMenu = NULL;\r\n\r\n\tGetCursorPos(&pp);\r\n\tif (cmPopUp.LoadMenu(IDR_QUICK_PASTE) != 0)\r\n\t{\r\n\t\tcmSubMenu = cmPopUp.GetSubMenu(0);\r\n\t\tif (!cmSubMenu)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint nItem = m_lstHeader.GetCaret();\r\n\r\n\t\tCRect rc;\r\n\t\tm_lstHeader.GetItemRect(nItem, rc, LVIR_BOUNDS);\r\n\t\tClientToScreen(rc);\r\n\r\n\t\tif (rc.PtInRect(pp) == FALSE)\r\n\t\t{\r\n\t\t\tpp.x = rc.left;\r\n\t\t\tpp.y = rc.bottom;\r\n\t\t}\r\n\r\n\t\ttheApp.m_Addins.AddPrePasteAddinsToMenu(cmSubMenu);\r\n\r\n\t\tSetFriendChecks(cmSubMenu);\r\n\r\n\t\tCString specialPaste(\"Special Paste\");\r\n\t\tint nPos = -1;\r\n\t\tCMenu *sendToMenu = CMultiLanguage::GetMenuPos(cmSubMenu, specialPaste, nPos, TRUE);\r\n\t\tif (sendToMenu != NULL)\r\n\t\t{\r\n\t\t\tCGetSetOptions::m_pasteScripts.AddToMenu(sendToMenu, &m_actions);\r\n\t\t}\r\n\r\n\t\ttheApp.m_Language.UpdateRightClickMenu(cmSubMenu);\r\n\r\n\t\tcmSubMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, pp.x, pp.y, this, NULL);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::SetFriendChecks(CMenu *pMenu)\r\n{\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIENDONE, 0);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_TWO, 1);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_THREE, 2);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_FORE, 3);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_FIVE, 4);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_SIX, 5);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_SEVEN, 6);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_EIGHT, 7);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_NINE, 8);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_TEN, 9);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_ELEVEN, 10);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_TWELVE, 11);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_THIRTEEN, 12);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_FORETEEN, 13);\r\n\tSetSendToMenu(pMenu, ID_MENU_SENTTO_FRIEND_FIFTEEN, 14);\r\n\r\n\tif (CGetSetOptions::GetAllowFriends() == false)\r\n\t{\r\n\t\tCString csText(\"Send To\");\r\n\t\tint nPos = -1;\r\n\t\tCMultiLanguage::GetMenuPos(pMenu, csText, nPos);\r\n\t\tif (nPos >= 0)\r\n\t\t{\r\n\t\t\tpMenu->DeleteMenu(nPos, MF_BYPOSITION);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCString csText(\"Send To\");\r\n\t\tint nPos = -1;\r\n\t\tCMenu *sendToMenu = CMultiLanguage::GetMenuPos(pMenu, csText, nPos, TRUE);\r\n\r\n\t\tif (sendToMenu != NULL)\r\n\t\t{\r\n\t\t\tm_customFriendsHelper.Load();\r\n\t\t\tm_customFriendsHelper.AddToMenu(sendToMenu);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::SetMenuChecks(CMenu *pMenu)\r\n{\r\n\t//Set the transparency Check\r\n\tif (!CGetSetOptions::GetEnableTransparency())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_TRANSPARENCY_NONE, MF_CHECKED);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint nTrans = CGetSetOptions::GetTransparencyPercent();\r\n\t\tint nCheckID = -1;\r\n\t\tswitch (nTrans)\r\n\t\t{\r\n\t\tcase 5:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_5;\r\n\t\t\tbreak;\r\n\t\tcase 10:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_10;\r\n\t\t\tbreak;\r\n\t\tcase 15:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_15;\r\n\t\t\tbreak;\r\n\t\tcase 20:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_20;\r\n\t\t\tbreak;\r\n\t\tcase 25:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_25;\r\n\t\t\tbreak;\r\n\t\tcase 30:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_30;\r\n\t\t\tbreak;\r\n\t\tcase 35:\r\n\t\t\tnCheckID = ID_TRANSPARENCY_35;\r\n\t\t\tbreak;\r\n\t\tcase 40:\r\n\t\t\tnCheckID = ID_MENU_TRANSPARENCY_40;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (nCheckID >= 0)\r\n\t\t{\r\n\t\t\tpMenu->CheckMenuItem(nCheckID, MF_CHECKED);\r\n\t\t}\r\n\t}\r\n\r\n\t//Set the lines per row check\r\n\tint nLinesPerRow = CGetSetOptions::GetLinesPerRow();\r\n\tint nCheckID = -1;\r\n\tswitch (nLinesPerRow)\r\n\t{\r\n\tcase 1:\r\n\t\tnCheckID = ID_MENU_LINESPERROW_1;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tnCheckID = ID_MENU_LINESPERROW_2;\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tnCheckID = ID_MENU_LINESPERROW_3;\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tnCheckID = ID_MENU_LINESPERROW_4;\r\n\t\tbreak;\r\n\tcase 5:\r\n\t\tnCheckID = ID_MENU_LINESPERROW_5;\r\n\t\tbreak;\r\n\t}\r\n\tif (nCheckID >= 0)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(nCheckID, MF_CHECKED);\r\n\t}\r\n\r\n\t//Set the position check\r\n\tint nPosition = CGetSetOptions::GetQuickPastePosition();\r\n\tnCheckID = -1;\r\n\tswitch (nPosition)\r\n\t{\r\n\tcase POS_AT_CARET:\r\n\t\tnCheckID = ID_MENU_POSITIONING_ATCARET;\r\n\t\tbreak;\r\n\tcase POS_AT_CURSOR:\r\n\t\tnCheckID = ID_MENU_POSITIONING_ATCURSOR;\r\n\t\tbreak;\r\n\tcase POS_AT_PREVIOUS:\r\n\t\tnCheckID = ID_MENU_POSITIONING_ATPREVIOUSPOSITION;\r\n\t\tbreak;\r\n\t}\r\n\tif (nCheckID >= 0)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(nCheckID, MF_CHECKED);\r\n\t}\r\n\r\n\ttheApp.UpdateMenuConnectCV(pMenu, ID_MENU_TOGGLECONNECTCV);\r\n\r\n\tif (CGetSetOptions::GetShowTextForFirstTenHotKeys())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_FIRSTTENHOTKEYS_SHOWHOTKEYTEXT, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetUseCtrlNumForFirstTenHotKeys())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_FIRSTTENHOTKEYS_USECTRLNUM, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_ALLWAYSONTOP, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetAutoHide())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_AUTOHIDE, MF_CHECKED);\r\n\t}\r\n\r\n\tswitch (CGetSetOptions::GetCaptionPos())\r\n\t{\r\n\tcase 1:\r\n\t\tpMenu->CheckMenuItem(ID_VIEWCAPTIONBARON_RIGHT, MF_CHECKED);\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tpMenu->CheckMenuItem(ID_VIEWCAPTIONBARON_BOTTOM, MF_CHECKED);\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tpMenu->CheckMenuItem(ID_VIEWCAPTIONBARON_LEFT, MF_CHECKED);\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tpMenu->CheckMenuItem(ID_VIEWCAPTIONBARON_TOP, MF_CHECKED);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetAllwaysShowDescription())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_ALLWAYSSHOWDESCRIPTION, MF_CHECKED);\r\n\t}\r\n\r\n\tswitch (CGetSetOptions::GetDoubleClickingOnCaptionDoes())\r\n\t{\r\n\tcase TOGGLES_ALLWAYS_ON_TOP:\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSONTOP, MF_CHECKED);\r\n\t\tbreak;\r\n\tcase TOGGLES_ALLWAYS_SHOW_DESCRIPTION:\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSSHOWDESCRIPTION, MF_CHECKED);\r\n\t\tbreak;\r\n\tcase ROLLES_UP_WINDOW:\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_ROLLUPWINDOW, MF_CHECKED);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bPrompForNewGroupName)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_PROMPTFORNEWGROUPNAMES, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bDrawThumbnail)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_SHOWTHUMBNAILS, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bDrawRTF)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_DRAWRTFTEXT, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bSendPasteMessageAfterSelection)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_PASTECLIPAFTERSELECTION, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bFindAsYouType)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_FINDASYOUTYPE, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bEnsureEntireWindowCanBeSeen)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_ENSUREENTIREWINDOWISVISIBLE, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::m_bShowAllClipsInMainList)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_QUICKOPTIONS_SHOWCLIPSTHATAREINGROUPSINMAINLIST, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetPromptWhenDeletingClips())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_QUICKOPTIONS_PROMPTTODELETECLIP, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetPasteAsAdmin())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_QUICKOPTIONS_ELEVATEPREVILEGESTOPASTEINTOELEVATEDAPPS, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetShowInTaskBar())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_QUICKOPTIONS_SHOWINTASKBAR, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetShowTextForFirstTenHotKeys())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_QUICKOPTIONS_SHOWTEXTFORFIRSTTENCOPYHOTKEYS, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetShowIfClipWasPasted())\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_QUICKOPTIONS_SHOWINDICATORACLIPHASBEENPASTED, MF_CHECKED);\r\n\t}\r\n\r\n\tif (CGetSetOptions::GetSearchDescription())\r\n\t\tpMenu->CheckMenuItem(ID_MENU_SEARCHDESCRIPTION, MF_CHECKED);\r\n\r\n\tif (CGetSetOptions::GetSearchFullText())\r\n\t\tpMenu->CheckMenuItem(ID_MENU_SEARCHFULLTEXT, MF_CHECKED);\r\n\r\n\tif (CGetSetOptions::GetSearchQuickPaste())\r\n\t\tpMenu->CheckMenuItem(ID_MENU_SEARCHQUICKPASTE, MF_CHECKED);\r\n\r\n\tif (CGetSetOptions::GetSimpleTextSearch())\r\n\t\tpMenu->CheckMenuItem(ID_MENU_CONTAINSTEXTSEARCHONLY, MF_CHECKED);\r\n\r\n\tif (CGetSetOptions::GetRegExTextSearch())\r\n\t\tpMenu->CheckMenuItem(ID_MENU_REGULAREXPRESSIONSEARCH, MF_CHECKED);\r\n\r\n\tif (CGetSetOptions::GetSimpleTextSearch() == FALSE &&\r\n\t\tCGetSetOptions::GetRegExTextSearch() == FALSE)\r\n\t{\r\n\t\tpMenu->CheckMenuItem(ID_MENU_WILDCARDSEARCH, MF_CHECKED);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::SetSendToMenu(CMenu *pMenu, int nMenuID, int nArrayPos)\r\n{\r\n\tif (CGetSetOptions::m_SendClients[nArrayPos].csIP.GetLength() > 0)\r\n\t{\r\n\t\tCString cs;\r\n\t\tif (CGetSetOptions::m_SendClients[nArrayPos].csDescription != _T(\"\"))\r\n\t\t{\r\n\t\t\tcs.Format(_T(\"(%s) - %s\"), CGetSetOptions::m_SendClients[nArrayPos].csIP, CGetSetOptions::m_SendClients[nArrayPos].csDescription);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcs.Format(_T(\"%s\"), CGetSetOptions::m_SendClients[nArrayPos].csIP);\r\n\t\t}\r\n\t\tpMenu->ModifyMenu(nMenuID, MF_BYCOMMAND, nMenuID, cs);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpMenu->DeleteMenu(nMenuID, MF_BYCOMMAND);\r\n\t}\r\n}\r\n\r\nLRESULT CQPasteWnd::OnSearch(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tFillList(csText);\r\n\r\n\tm_lstHeader.SetFocus();\r\n\r\n\tMoveControls();\r\n\r\n\tm_search.SetSel(-1, 0);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n//Menu Stuff\r\n///////////////////////////////////////////////////////////////////////\r\nvoid CQPasteWnd::OnMenuLinesperrow1()\r\n{\r\n\tSetLinesPerRow(1, false, true);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuLinesperrow2()\r\n{\r\n\tSetLinesPerRow(2, false, true);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuLinesperrow3()\r\n{\r\n\tSetLinesPerRow(3, false, true);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuLinesperrow4()\r\n{\r\n\tSetLinesPerRow(4, false, true);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuLinesperrow5()\r\n{\r\n\tSetLinesPerRow(5, false, true);\r\n}\r\n\r\nvoid CQPasteWnd::SetLinesPerRow(int lines, bool force, bool resetListCount)\r\n{\r\n\tARRAY Indexs;\r\n\tint listCount = 0;\r\n\r\n\tif (resetListCount)\r\n\t{\r\n\t\t//save and restore state, list box seems to pain funny (gap at header) if items are not reset\r\n\t\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\t\tif (Indexs.GetCount() <= 0)\r\n\t\t{\r\n\t\t\tIndexs.Add(0);\r\n\t\t}\r\n\t\tlistCount = m_lstHeader.GetItemCount();\r\n\t\tm_lstHeader.SetItemCountEx(0);\r\n\t}\r\n\r\n\tCGetSetOptions::SetLinesPerRow(lines);\r\n\tm_lstHeader.SetNumberOfLinesPerRow(lines, force);\r\n\r\n\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\tm_cf_dibCache.clear();\r\n\tm_cf_NO_dibCache.clear();\r\n\tm_cf_rtfCache.clear();\r\n\tm_cf_NO_rtfCache.clear();\r\n\r\n\tif (resetListCount)\r\n\t{\r\n\t\tm_lstHeader.SetItemCountEx(listCount);\r\n\t\tm_lstHeader.SetListPos(Indexs[0]);\r\n\t\tm_lstHeader.RefreshVisibleRows();\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuDelete()\r\n{\r\n\tDeleteSelectedRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuPositioningAtcaret()\r\n{\r\n\tCGetSetOptions::SetQuickPastePosition(POS_AT_CARET);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuPositioningAtcursor()\r\n{\r\n\tCGetSetOptions::SetQuickPastePosition(POS_AT_CURSOR);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuPositioningAtpreviousposition()\r\n{\r\n\tCGetSetOptions::SetQuickPastePosition(POS_AT_PREVIOUS);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuOptions()\r\n{\r\n\ttheApp.m_pMainFrame->SendMessage(WM_SHOW_OPTIONS, 0, 0);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuExitprogram()\r\n{\r\n\t::SendMessage(theApp.m_MainhWnd, WM_CLOSE, 0, 0);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuToggleConnectCV()\r\n{\r\n\tthis->DoAction(ActionEnums::TOGGLE_CLIPBOARD_CONNECTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdate32775(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TOGGLE_CLIPBOARD_CONNECTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuProperties()\r\n{\r\n\tthis->DoAction(ActionEnums::CLIP_PROPERTIES);\r\n}\r\n\r\nvoid CQPasteWnd::UpdateFont()\r\n{\r\n\tLOGFONT lf;\r\n\tCGetSetOptions::GetFont(lf);\r\n\tlf.lfHeight = m_DittoWindow.m_dpi.Scale(lf.lfHeight);\r\n\tm_lstHeader.SetLogFont(lf);\r\n\r\n\tm_SearchFont.DeleteObject();\r\n\tm_SearchFont.CreateFont(-m_DittoWindow.m_dpi.Scale(15), 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"Segoe UI\"));\r\n\tm_search.SetFont(&m_SearchFont);\r\n\tm_search.SetPromptFont(m_SearchFont);\r\n\r\n\tm_GroupTree.SetFont(&m_SearchFont);\r\n\r\n\tm_groupFont.DeleteObject();\r\n\tm_groupFont.CreateFont(-m_DittoWindow.m_dpi.Scale(12), 0, 0, 0, 400, 0, 1, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"Segoe UI\"));\r\n\tm_stGroup.SetFont(&m_groupFont);\r\n\tm_stGroup.SetBkColor(CGetSetOptions::m_Theme.MainWindowBG());\r\n\tm_stGroup.SetTextColor(CGetSetOptions::m_Theme.ListBoxEvenRowsText());\r\n\r\n\tm_noSearchResultsStatic.SetBkColor(CGetSetOptions::m_Theme.MainWindowBG());\r\n\tm_noSearchResultsStatic.SetTextColor(CGetSetOptions::m_Theme.ListBoxEvenRowsText());\r\n\tm_noSearchResultsStatic.SetFont(&m_SearchFont);\r\n\r\n\tm_lstHeader.CreateSmallFont();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuFirsttenhotkeysUsectrlnum()\r\n{\r\n\tCGetSetOptions::SetUseCtrlNumForFirstTenHotKeys(!CGetSetOptions::GetUseCtrlNumForFirstTenHotKeys());\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuFirsttenhotkeysShowhotkeytext()\r\n{\r\n\tCGetSetOptions::SetShowTextForFirstTenHotKeys(!CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\tm_lstHeader.SetShowTextForFirstTenHotKeys(CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnViewcaptionbaronRight()\r\n{\r\n\tSetCaptionOn(CAPTION_RIGHT, false, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\tCGetSetOptions::SetCaptionPos(CAPTION_RIGHT);\r\n}\r\n\r\nvoid CQPasteWnd::OnViewcaptionbaronBottom()\r\n{\r\n\tSetCaptionOn(CAPTION_BOTTOM, false, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\tCGetSetOptions::SetCaptionPos(CAPTION_BOTTOM);\r\n}\r\n\r\nvoid CQPasteWnd::OnViewcaptionbaronLeft()\r\n{\r\n\tSetCaptionOn(CAPTION_LEFT, false, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\tCGetSetOptions::SetCaptionPos(CAPTION_LEFT);\r\n}\r\n\r\nvoid CQPasteWnd::OnViewcaptionbaronTop()\r\n{\r\n\tSetCaptionOn(CAPTION_TOP, false, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\tCGetSetOptions::SetCaptionPos(CAPTION_TOP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuAutohide()\r\n{\r\n\tbool bAutoHide = !CGetSetOptions::GetAutoHide();\r\n\tCGetSetOptions::SetAutoHide(bAutoHide);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuViewfulldescription()\r\n{\r\n\tthis->DoAction(ActionEnums::SHOWDESCRIPTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuAllwaysontop()\r\n{\r\n\tthis->DoAction(ActionEnums::TOGGLESHOWPERSISTANT);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuNewGroup()\r\n{\r\n\tthis->DoAction(ActionEnums::NEWGROUP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuNewGroupSelection()\r\n{\r\n\tthis->DoAction(ActionEnums::NEWGROUPSELECTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsAllwaysshowdescription()\r\n{\r\n\tCGetSetOptions::SetAllwaysShowDescription(!CGetSetOptions::m_bAllwaysShowDescription);\r\n\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsDoubleclickingoncaptionTogglesalwaysontop()\r\n{\r\n\tCGetSetOptions::SetDoubleClickingOnCaptionDoes(TOGGLES_ALLWAYS_ON_TOP);\r\n\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsDoubleclickingoncaptionRollupwindow()\r\n{\r\n\tCGetSetOptions::SetDoubleClickingOnCaptionDoes(ROLLES_UP_WINDOW);\r\n\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsDoubleclickingoncaptionTogglesshowdescription()\r\n{\r\n\tCGetSetOptions::SetDoubleClickingOnCaptionDoes(TOGGLES_ALLWAYS_SHOW_DESCRIPTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsPromptfornewgroupnames()\r\n{\r\n\tCGetSetOptions::SetPrompForNewGroupName(!CGetSetOptions::m_bPrompForNewGroupName);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuViewgroups()\r\n{\r\n\tthis->DoAction(ActionEnums::SHOWGROUPS);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickpropertiesSettoneverautodelete()\r\n{\r\n\tCWaitCursor wait;\r\n\tARRAY IDs;\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lDontAutoDelete = %d where lID = %d;\"), (int)CTime::GetCurrentTime().GetTime(), IDs[i]);\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tcount = Indexs.GetSize();\r\n\t\tfor (int row = 0; row < count; row++)\r\n\t\t{\r\n\t\t\tif (Indexs[row] < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tm_listItems[Indexs[row]].m_bDontAutoDelete = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickpropertiesAutodelete()\r\n{\r\n\tCWaitCursor wait;\r\n\tARRAY IDs;\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lDontAutoDelete = 0 where lID = %d;\"), IDs[i]);\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\tcount = Indexs.GetSize();\r\n\t\tfor (int row = 0; row < count; row++)\r\n\t\t{\r\n\t\t\tif (Indexs[row] < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tm_listItems[Indexs[row]].m_bDontAutoDelete = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickpropertiesRemovehotkey()\r\n{\r\n\tCWaitCursor wait;\r\n\tARRAY IDs;\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET lShortCut = 0, globalShortCut = 0 where lID = %d;\"), IDs[i]);\r\n\t\t\tg_HotKeys.Remove(IDs[i], CHotKey::PASTE_OPEN_CLIP);\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET MoveToGroupShortCut = 0, GlobalMoveToGroupShortCut = 0 where lID = %d;\"), IDs[i]);\r\n\t\t\tg_HotKeys.Remove(IDs[i], CHotKey::MOVE_TO_GROUP);\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tcount = Indexs.GetSize();\r\n\t\tfor (int row = 0; row < count; row++)\r\n\t\t{\r\n\t\t\tif (Indexs[row] < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tm_listItems[Indexs[row]].m_bHasShortCut = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnQuickpropertiesRemovequickpaste()\r\n{\r\n\tCWaitCursor wait;\r\n\tARRAY IDs;\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\ttheApp.m_db.execDMLEx(_T(\"UPDATE Main SET QuickPasteText = '' where lID = %d;\"), IDs[i]);\r\n\t\t}\r\n\t\tCATCH_SQLITE_EXCEPTION\r\n\t}\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tcount = Indexs.GetSize();\r\n\t\tfor (int row = 0; row < count; row++)\r\n\t\t{\r\n\t\t\tif (Indexs[row] < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tm_listItems[Indexs[row]].m_QuickPaste.Empty();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendFifteen()\r\n{\r\n\tSendToFriendbyPos(14, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendForeteen()\r\n{\r\n\tSendToFriendbyPos(13, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendThirteen()\r\n{\r\n\tSendToFriendbyPos(12, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendTwelve()\r\n{\r\n\tSendToFriendbyPos(11, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendEleven()\r\n{\r\n\tSendToFriendbyPos(10, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendTen()\r\n{\r\n\tSendToFriendbyPos(9, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendNine()\r\n{\r\n\tSendToFriendbyPos(8, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendEight()\r\n{\r\n\tSendToFriendbyPos(7, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendSeven()\r\n{\r\n\tSendToFriendbyPos(6, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendSix()\r\n{\r\n\tSendToFriendbyPos(5, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendFive()\r\n{\r\n\tSendToFriendbyPos(4, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendFore()\r\n{\r\n\tSendToFriendbyPos(3, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendThree()\r\n{\r\n\tSendToFriendbyPos(2, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendTwo()\r\n{\r\n\tSendToFriendbyPos(1, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoFriendone()\r\n{\r\n\tSendToFriendbyPos(0, _T(\"\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSenttoPromptforip()\r\n{\r\n\t// TODO: Add your command handler code here\r\n\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuGroupsMovetogroup()\r\n{\r\n\tthis->DoAction(ActionEnums::MOVE_CLIP_TO_GROUP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuPasteplaintextonly()\r\n{\r\n\tthis->DoAction(ActionEnums::PASTE_SELECTED_PLAIN_TEXT);\r\n}\r\n\r\nvoid CQPasteWnd::OnPromptToDeleteClip()\r\n{\r\n\tCGetSetOptions::SetPromptWhenDeletingClips(!CGetSetOptions::GetPromptWhenDeletingClips());\r\n}\r\n\r\nvoid CQPasteWnd::OnMakeTopStickyClip()\r\n{\r\n\tthis->DoAction(ActionEnums::MAKE_TOP_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnMakeLastStickyClip()\r\n{\r\n\tthis->DoAction(ActionEnums::MAKE_LAST_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnRemoveSticky()\r\n{\r\n\tthis->DoAction(ActionEnums::REMOVE_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateStickyclipsMaketopstickyclip(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MAKE_TOP_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateStickyclipsMakelaststickyclip(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MAKE_LAST_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateStickyclipsRemovestickysetting(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::REMOVE_STICKY);\r\n}\r\n\r\nvoid CQPasteWnd::OnElevateAppToPasteIntoElevatedApp()\r\n{\r\n\tthis->DoAction(ActionEnums::ELEVATE_PRIVlEGES);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuExport()\r\n{\r\n\tCClipIDs IDs;\r\n\tINT_PTR lCount = m_lstHeader.GetSelectedCount();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tlCount = IDs.GetSize();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tOPENFILENAME ofn;\r\n\tTCHAR szFile[400];\r\n\tTCHAR szDir[400];\r\n\r\n\tmemset(&szFile, 0, sizeof(szFile));\r\n\tmemset(szDir, 0, sizeof(szDir));\r\n\tmemset(&ofn, 0, sizeof(ofn));\r\n\r\n\tCString csInitialDir = CGetSetOptions::GetLastImportDir();\r\n\tSTRCPY(szDir, csInitialDir);\r\n\r\n\tofn.lStructSize = sizeof(OPENFILENAME);\r\n\tofn.hwndOwner = m_hWnd;\r\n\tofn.lpstrFile = szFile;\r\n\tofn.nMaxFile = sizeof(szFile);\r\n\tofn.lpstrFilter = _T(\"Exported Ditto Clips (.dto)\\0*.dto\\0\\0\");\r\n\tofn.nFilterIndex = 1;\r\n\tofn.lpstrFileTitle = NULL;\r\n\tofn.nMaxFileTitle = 0;\r\n\tofn.lpstrInitialDir = szDir;\r\n\tofn.lpstrDefExt = _T(\"dto\");\r\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;\r\n\r\n\tm_bHideWnd = false;\r\n\r\n\tif (GetSaveFileName(&ofn))\r\n\t{\r\n\t\tusing namespace nsPath;\r\n\t\tCPath path(ofn.lpstrFile);\r\n\t\tCString csPath = path.GetPath();\r\n\t\tCGetSetOptions::SetLastExportDir(csPath);\r\n\r\n\t\tCString csFile(ofn.lpstrFile);\r\n\t\tIDs.Export(csFile);\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuImport()\r\n{\r\n\tm_bHideWnd = false;\r\n\ttheApp.ImportClips(m_hWnd);\r\n\tm_bHideWnd = true;\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuHelp()\r\n{\r\n\tCHyperLink::GotoURL(_T(\"https://github.com/sabrogden/Ditto/wiki\"), SW_SHOW);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsFont()\r\n{\r\n\tm_bHideWnd = false;\r\n\r\n\tCDimWnd dimmer(this);\r\n\r\n\tCFont *pFont = m_lstHeader.GetFont();\r\n\tLOGFONT lf;\r\n\tpFont->GetLogFont(&lf);\r\n\r\n\tlf.lfHeight = m_DittoWindow.m_dpi.UnScale(lf.lfHeight);\r\n\r\n\tCFontDialog dlg(&lf);\r\n\tif (dlg.DoModal() == IDOK)\r\n\t{\r\n\t\tCGetSetOptions::SetFont(*dlg.m_cf.lpLogFont);\r\n\t\t(*dlg.m_cf.lpLogFont).lfHeight = m_DittoWindow.m_dpi.Scale((*dlg.m_cf.lpLogFont).lfHeight);\r\n\t\tm_lstHeader.SetLogFont(*dlg.m_cf.lpLogFont);\r\n\t\tthis->SetLinesPerRow(CGetSetOptions::GetLinesPerRow(), true, true);\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsShowthumbnails()\r\n{\r\n\tCGetSetOptions::SetDrawThumbnail(!CGetSetOptions::m_bDrawThumbnail);\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsDrawrtftext()\r\n{\r\n\tCGetSetOptions::SetDrawRTF(!CGetSetOptions::m_bDrawRTF);\r\n\tm_lstHeader.RefreshVisibleRows();\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsPasteclipafterselection()\r\n{\r\n\tCGetSetOptions::SetSendPasteAfterSelection(!CGetSetOptions::m_bSendPasteMessageAfterSelection);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsFindasyoutype()\r\n{\r\n\tCGetSetOptions::SetFindAsYouType(!CGetSetOptions::m_bFindAsYouType);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsEnsureentirewindowisvisible()\r\n{\r\n\tCGetSetOptions::SetEnsureEntireWindowCanBeSeen(!CGetSetOptions::m_bEnsureEntireWindowCanBeSeen);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuQuickoptionsShowclipsthatareingroupsinmainlist()\r\n{\r\n\tCGetSetOptions::SetShowAllClipsInMainList(!CGetSetOptions::m_bShowAllClipsInMainList);\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\tFillList(csText);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuEdititem()\r\n{\r\n\tthis->DoAction(ActionEnums::EDITCLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuNewclip()\r\n{\r\n\tthis->DoAction(ActionEnums::NEWCLIP);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n//END END Menu Stuff\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\r\nBOOL CQPasteWnd::SendToFriendbyPos(int nPos, CString override_IP_Host)\r\n{\r\n\tif (CGetSetOptions::GetAllowFriends() == false)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tCWaitCursor wait;\r\n\r\n\tm_bHideWnd = false;\r\n\r\n\tCClipIDs IDs;\r\n\tINT_PTR count = m_lstHeader.GetSelectedCount();\r\n\tif (count <= 0)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tcount = IDs.GetSize();\r\n\tif (count <= 0)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tCSendToFriendInfo Info;\r\n\r\n\tBOOL bRet = FALSE;\r\n\r\n\ttry\r\n\t{\r\n\t\tInfo.m_manualSend = true;\r\n\t\tInfo.m_csIP = override_IP_Host;\r\n\t\tif (Info.m_csIP == _T(\"\"))\r\n\t\t{\r\n\t\t\tInfo.m_csIP = CGetSetOptions::m_SendClients[nPos].csIP;\r\n\t\t}\r\n\r\n\t\tif (Info.m_csIP != _T(\"\"))\r\n\t\t{\r\n\t\t\tCPopup Popup(0, 0, m_hWnd);\r\n\t\t\tPopup.Show(StrF(_T(\"Sending clip to %s\"), Info.m_csIP));\r\n\r\n\t\t\tInfo.m_pPopup = &Popup;\r\n\r\n\t\t\tInfo.m_pClipList = new CClipList;\r\n\t\t\tfor (int i = 0; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT mText FROM Main WHERE lID = %d\"), IDs[i]);\r\n\t\t\t\tif (q.eof() == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tCClip *pClip = new CClip;\r\n\t\t\t\t\tif (pClip)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpClip->LoadFormats(IDs[i]);\r\n\t\t\t\t\t\tpClip->m_Desc = q.getStringField(0);\r\n\t\t\t\t\t\tpClip->m_id = IDs[i];\r\n\t\t\t\t\t\tInfo.m_pClipList->AddTail(pClip);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (SendToFriend(Info) == FALSE)\r\n\t\t\t{\r\n\t\t\t\tMessageBox(StrF(_T(\"Error Sending data to %s\\n\\n%s\"), Info.m_csIP, Info.m_csErrorText), _T(\"Ditto\"), MB_OK | MB_TOPMOST);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbRet = TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\tm_bHideWnd = true;\r\n\r\n\treturn bRet;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnDelete(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tDeleteSelectedRows();\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::DeleteSelectedRows()\r\n{\r\n\tif (CGetSetOptions::GetPromptWhenDeletingClips())\r\n\t{\r\n\t\tbool bStartValue = m_bHideWnd;\r\n\t\tm_bHideWnd = false;\r\n\r\n\t\tint nRet = MessageBox(theApp.m_Language.GetString(\"Delete_Clip\", \"Delete Selected Clips?\"), _T(\"Ditto\"), MB_OKCANCEL | MB_TOPMOST);\r\n\r\n\t\tm_bHideWnd = bStartValue;\r\n\r\n\t\tif (nRet != IDOK)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tCClipIDs IDs;\r\n\tARRAY Indexs;\r\n\r\n\tif (m_lstHeader.GetSelectedCount() == 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tDeleteClips(IDs, Indexs);\r\n}\r\n\r\nbool CQPasteWnd::DeleteClips(CClipIDs &IDs, ARRAY &Indexs)\r\n{\r\n\tPOSITION pos = m_lstHeader.GetFirstSelectedItemPosition();\r\n\tint nFirstSel = m_lstHeader.GetNextSelectedItem(pos);\r\n\r\n\tIDs.DeleteIDs(true, theApp.m_db);\r\n\r\n\tIndexs.SortDescending();\r\n\tINT_PTR count = Indexs.GetSize();\r\n\r\n\tint erasedCount = 0;\r\n\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tif (Indexs[i] < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tRemoveFromImageRtfCache(Indexs[i]);\r\n\t\t\t\tg_HotKeys.Remove(m_lstHeader.GetItemData(Indexs[i]), CHotKey::PASTE_OPEN_CLIP);\r\n\r\n\t\t\t\tm_listItems.erase(m_listItems.begin() + Indexs[i]);\r\n\t\t\t\terasedCount++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tCClip::m_LastAddedCRC = 0;\r\n\r\n\tm_extraDataThread.FireLoadAccelerators();\r\n\r\n\tm_lstHeader.SetItemCountEx(m_lstHeader.GetItemCount() - erasedCount);\r\n\r\n\t// if there are no items after the one we deleted, then select the last one.\r\n\tif (nFirstSel >= m_lstHeader.GetItemCount())\r\n\t{\r\n\t\tnFirstSel = m_lstHeader.GetItemCount() - 1;\r\n\t}\r\n\r\n\tm_lstHeader.SetListPos(nFirstSel);\r\n\tUpdateStatus();\r\n\r\n\tif (m_lstHeader.IsToolTipWindowVisible())\r\n\t{\r\n\t\tm_lstHeader.ShowFullDescription(false, true);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CQPasteWnd::RemoveFromImageRtfCache(int id)\r\n{\r\n\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\tCF_DibTypeMap::iterator iterDib = m_cf_dibCache.find(m_lstHeader.GetItemData(id));\r\n\tif (iterDib != m_cf_dibCache.end())\r\n\t{\r\n\t\tm_cf_dibCache.erase(iterDib);\r\n\t}\r\n\r\n\tCF_NoDibTypeMap::iterator iterNoDib = m_cf_NO_dibCache.find(m_lstHeader.GetItemData(id));\r\n\tif (iterNoDib != m_cf_NO_dibCache.end())\r\n\t{\r\n\t\tm_cf_NO_dibCache.erase(iterNoDib);\r\n\t}\r\n\r\n\tCF_DibTypeMap::iterator iterRtf = m_cf_rtfCache.find(m_lstHeader.GetItemData(id));\r\n\tif (iterRtf != m_cf_rtfCache.end())\r\n\t{\r\n\t\tm_cf_rtfCache.erase(iterRtf);\r\n\t}\r\n\r\n\tCF_NoDibTypeMap::iterator iterNoRtf = m_cf_NO_rtfCache.find(m_lstHeader.GetItemData(id));\r\n\tif (iterNoRtf != m_cf_NO_rtfCache.end())\r\n\t{\r\n\t\tm_cf_NO_rtfCache.erase(iterNoRtf);\r\n\t}\r\n}\r\n\r\nCString CQPasteWnd::LoadDescription(int nItem)\r\n{\r\n\tif (nItem < 0 || nItem >= m_lstHeader.GetItemCount())\r\n\t{\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tCString cs;\r\n\ttry\r\n\t{\r\n\t\tint id = m_lstHeader.GetItemData(nItem);\r\n\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT mText FROM Main WHERE lID = %d\"), id);\r\n\t\tif (q.eof() == false)\r\n\t\t{\r\n\t\t\tcs = q.getStringField(0);\r\n\t\t}\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\treturn cs;\r\n}\r\n\r\nvoid CQPasteWnd::MoveSelection(bool down, bool requireModifersActive)\r\n{\r\n\tif (m_bModifersMoveActive || requireModifersActive == false)\r\n\t{\r\n\t\tARRAY arr;\r\n\t\tm_lstHeader.GetSelectionIndexes(arr);\r\n\t\tif (arr.GetCount() > 0)\r\n\t\t{\r\n\t\t\tint index = arr[0];\r\n\r\n\t\t\tif (down)\r\n\t\t\t{\r\n\t\t\t\tif (index < m_lstHeader.GetItemCount() - 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_lstHeader.SetListPos(index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (index > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_lstHeader.SetListPos(index - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (m_lstHeader.GetItemCount() > 0)\r\n\t\t\t{\r\n\t\t\t\tm_lstHeader.SetListPos(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnKeyStateUp()\r\n{\r\n\tif (CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tif (m_bModifersMoveActive)\r\n\t\t{\r\n\t\t\tLog(_T(\"OnKeyStateUp\"));\r\n\t\t\tSetTimer(TIMER_PASTE_FROM_MODIFER, CGetSetOptions::GetKeyStatePasteDelay(), NULL);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(_T(\"OnKeyStateUp - Modifers not active\"));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::SetKeyModiferState(bool bActive)\r\n{\r\n\tif (CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tLog(StrF(_T(\"SetKeyModiferState %d\"), bActive));\r\n\t\tm_bModifersMoveActive = bActive;\r\n\t}\r\n}\r\n\r\nBOOL CQPasteWnd::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\tswitch (pMsg->message)\r\n\t{\r\n\tcase WM_MBUTTONUP:\r\n\t{\r\n\t\tMSG msg;\r\n\t\tmsg.lParam = 0;\r\n\t\tmsg.wParam = VK_MOUSE_MIDDLE_CLICK;\r\n\t\tmsg.message = WM_KEYDOWN;\r\n\t\tif (CheckActions(&msg) == false)\r\n\t\t{\r\n\t\t}\r\n\t}\r\n\tbreak;\r\n\tcase WM_NCMOUSEMOVE:\r\n\tcase WM_MOUSEMOVE:\r\n\t{\r\n\t\tif (CGetSetOptions::m_bShowPersistent)\r\n\t\t{\r\n\t\t\tbool hasFocus = ::GetForegroundWindow() == m_hWnd;\r\n\t\t\tif (hasFocus == false)\r\n\t\t\t{\r\n\t\t\t\tDWORD tick = GetTickCount();\r\n\t\t\t\tif ((tick - m_lastNonActiveMouseMove) > 1000)\r\n\t\t\t\t{\r\n\t\t\t\t\ttheApp.m_activeWnd.TrackActiveWnd(true);\r\n\t\t\t\t\tm_lastNonActiveMouseMove = GetTickCount();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_lastNonActiveMouseMove = 0;\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n\tbreak;\t\r\n\tdefault:\r\n\t\tif (CheckActions(pMsg))\r\n\t\t{\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\telse if (pMsg->message == WM_CHAR)\r\n\t\t{\r\n\t\t\tauto f = this->GetFocus();\r\n\t\t\tif (f != NULL && f->m_hWnd == m_lstHeader.m_hWnd)\r\n\t\t\t{\r\n\t\t\t\tCString x((TCHAR)pMsg->wParam);\r\n\t\t\t\tm_search.SetWindowText(x);\r\n\t\t\t\tm_search.SetFocus();\r\n\t\t\t\tm_search.SetSel(1, 1);\r\n\r\n\t\t\t\tOnSearchEditChange();\r\n\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\t\r\n\t\tbreak;\t\r\n\t}\r\n\treturn CWndEx::PreTranslateMessage(pMsg);\r\n}\r\n\r\nbool CQPasteWnd::CheckActions(MSG * pMsg)\r\n{\r\n\tbool ret = false;\r\n\tCAccel a;\r\n\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tif (m_modifierKeyActions.OnMsg(pMsg, a))\r\n\t\t{\r\n\t\t\tret = DoAction(a);\r\n\t\t}\r\n\t}\r\n\r\n\tif (ret == false)\r\n\t{\r\n\t\tif (m_actions.OnMsg(pMsg, a))\r\n\t\t{\r\n\t\t\tKillTimer(TIMER_DO_ACTION);\r\n\t\t\tret = DoAction(a);\r\n\t\t}\r\n\t\telse if (a.Cmd > 0)\r\n\t\t{\r\n\t\t\tm_timerAction = a;\r\n\t\t\tSetTimer(TIMER_DO_ACTION, CGetSetOptions::m_doubleKeyStrokeTimeout, NULL);\r\n\r\n\t\t\tret = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoAction(DWORD cmd)\r\n{\r\n\tCAccel a(0, cmd);\r\n\treturn DoAction(a);\r\n}\r\n\r\nbool CQPasteWnd::DoAction(CAccel a)\r\n{\r\n\tbool ret = false;\r\n\r\n\tswitch (a.Cmd)\r\n\t{\r\n\tcase ActionEnums::SHOWDESCRIPTION:\r\n\t\tret = DoActionShowDescription();\r\n\t\tbreak;\r\n\tcase ActionEnums::NEXTDESCRIPTION:\r\n\t\tret = DoActionNextDescription();\r\n\t\tbreak;\r\n\tcase ActionEnums::PREVDESCRIPTION:\r\n\t\tret = DoActionPrevDescription();\r\n\t\tbreak;\r\n\tcase ActionEnums::SHOWMENU:\r\n\t\tret = DoActionShowMenu();\r\n\t\tbreak;\r\n\tcase ActionEnums::SYSTEM_MENU:\r\n\t\tret = DoActionShowSystemMenu();\r\n\t\tbreak;\r\n\tcase ActionEnums::NEWGROUP:\r\n\t\tret = DoActionNewGroup();\r\n\t\tbreak;\r\n\tcase ActionEnums::NEWGROUPSELECTION:\r\n\t\tret = DoActionNewGroupSelection();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLEFILELOGGING:\r\n\t\tret = DoActionToggleFileLogging();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLEOUTPUTDEBUGSTRING:\r\n\t\tret = DoActionToggleOutputDebugString();\r\n\t\tbreak;\r\n\tcase ActionEnums::CLOSEWINDOW:\r\n\t\tret = DoActionCloseWindow();\r\n\t\tbreak;\r\n\tcase ActionEnums::FORCE_CLOSE_WINDOW:\r\n\t\tret = DoActionForceCloseWindow();\r\n\t\tbreak;\r\n\tcase ActionEnums::NEXTTABCONTROL:\r\n\t\tret = DoActionNextTabControl();\r\n\t\tbreak;\r\n\tcase ActionEnums::PREVTABCONTROL:\r\n\t\tret = DoActionPrevTabControl();\r\n\t\tbreak;\r\n\tcase ActionEnums::SHOWGROUPS:\r\n\t\tret = DoActionShowGroups();\r\n\t\tbreak;\r\n\tcase ActionEnums::NEWCLIP:\r\n\t\tret = DoActionNewClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::EDITCLIP:\r\n\t\tret = DoActionEditClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::MODIFIER_ACTVE_SELECTIONUP:\r\n\t\tret = DoModifierActiveActionSelectionUp();\r\n\t\tbreak;\r\n\tcase ActionEnums::MODIFIER_ACTVE_SELECTIONDOWN:\r\n\t\tret = DoModifierActiveActionSelectionDown();\r\n\t\tbreak;\r\n\tcase ActionEnums::MODIFIER_ACTVE_MOVEFIRST:\r\n\t\tret = DoModifierActiveActionMoveFirst();\r\n\t\tbreak;\r\n\tcase ActionEnums::MODIFIER_ACTVE_MOVELAST:\r\n\t\tret = DoModifierActiveActionMoveLast();\r\n\t\tbreak;\r\n\tcase ActionEnums::CANCELFILTER:\r\n\t\tret = DoActionCancelFilter();\r\n\t\tbreak;\r\n\tcase ActionEnums::HOMELIST:\r\n\t\tret = DoActionHomeList();\r\n\t\tbreak;\r\n\tcase ActionEnums::BACKGRROUP:\r\n\t\tret = DoActionBackGroup();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLESHOWPERSISTANT:\r\n\t\tret = DoActionToggleShowPersistant();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_SELECTED:\r\n\t\tret = DoActionPasteSelected();\r\n\t\tbreak;\r\n\tcase ActionEnums::DELETE_SELECTED:\r\n\t\tret = DoActionDeleteSelected();\r\n\t\tbreak;\r\n\tcase ActionEnums::CLIP_PROPERTIES:\r\n\t\tret = DoActionClipProperties();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_SELECTED_PLAIN_TEXT:\r\n\t\tret = DoActionPasteSelectedPlainText();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_CLIP_TO_GROUP:\r\n\t\tret = DoActionMoveClipToGroup();\r\n\t\tbreak;\r\n\tcase ActionEnums::ELEVATE_PRIVlEGES:\r\n\t\tret = DoActionElevatePrivleges();\r\n\t\tbreak;\r\n\tcase ActionEnums::SHOW_IN_TASKBAR:\r\n\t\tret = DoShowInTaskBar();\r\n\t\tbreak;\r\n\tcase ActionEnums::COMPARE_SELECTED_CLIPS:\r\n\t\tret = DoClipCompare();\r\n\t\tbreak;\r\n\tcase ActionEnums::SELECT_LEFT_SIDE_COMPARE:\r\n\t\tret = DoSelectLeftSideCompare();\r\n\t\tbreak;\r\n\tcase ActionEnums::SELECT_RIGHT_SITE_AND_DO_COMPARE:\r\n\t\tret = DoSelectRightSideAndDoCompare();\r\n\t\tbreak;\r\n\tcase ActionEnums::EXPORT_TO_TEXT_FILE:\r\n\t\tret = DoExportToTextFile();\r\n\t\tbreak;\r\n\tcase ActionEnums::EXPORT_TO_QR_CODE:\r\n\t\tret = DoExportToQRCode();\r\n\t\tbreak;\r\n\tcase ActionEnums::EXPORT_TO_GOOGLE_TRANSLATE:\r\n\t\tret = DoExportToGoogleTranslate();\r\n\t\tbreak;\r\n\tcase ActionEnums::EXPORT_TO_BITMAP_FILE:\r\n\t\tret = DoExportToBitMapFile();\r\n\t\tbreak;\r\n\tcase ActionEnums::SAVE_CURRENT_CLIPBOARD:\r\n\t\tret = DoSaveCurrentClipboard();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_CLIP_DOWN:\r\n\t\tret = DoMoveClipDown();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_CLIP_UP:\r\n\t\tret = DoMoveClipUp();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_CLIP_TOP:\r\n\t\tret = DoMoveClipTOP();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_CLIP_LAST:\r\n\t\tret = DoMoveClipLast();\r\n\t\tbreak;\r\n\tcase ActionEnums::FILTER_ON_SELECTED_CLIP:\r\n\t\tret = DoFilterOnSelectedClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_UPPER_CASE:\r\n\t\tret = DoPasteUpperCase();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_LOWER_CASE:\r\n\t\tret = DoPasteLowerCase();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_CAPITALiZE:\r\n\t\tret = DoPasteCapitalize();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_SENTENCE_CASE:\r\n\t\tret = DoPasteSentenceCase();\r\n\t\tbreak;\r\n\tcase ActionEnums::INVERT_CASE:\r\n\t\tret = DoInvertCase();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_REMOVE_LINE_FEEDS:\r\n\t\tret = DoPasteRemoveLineFeeds();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_ADD_ONE_LINE_FEED:\r\n\t\tret = DoPastePlusAddLineFeed();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_ADD_TWO_LINE_FEEDS:\r\n\t\tret = DoPasteAddTwoLineFeeds();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_TYPOGLYCEMIA:\r\n\t\tret = DoPasteTypoglycemia();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_ADD_CURRENT_TIME:\r\n\t\tret = DoPasteAddCurrentTime();\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_1:\r\n\t\tret = SendToFriendbyPos(0, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_2:\r\n\t\tret = SendToFriendbyPos(1, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_3:\r\n\t\tret = SendToFriendbyPos(2, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_4:\r\n\t\tret = SendToFriendbyPos(3, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_5:\r\n\t\tret = SendToFriendbyPos(4, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_6:\r\n\t\tret = SendToFriendbyPos(5, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_7:\r\n\t\tret = SendToFriendbyPos(6, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_8:\r\n\t\tret = SendToFriendbyPos(7, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_9:\r\n\t\tret = SendToFriendbyPos(8, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_10:\r\n\t\tret = SendToFriendbyPos(9, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_11:\r\n\t\tret = SendToFriendbyPos(10, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_12:\r\n\t\tret = SendToFriendbyPos(11, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_13:\r\n\t\tret = SendToFriendbyPos(12, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_14:\r\n\t\tret = SendToFriendbyPos(13, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::SEND_TO_FRIEND_15:\r\n\t\tret = SendToFriendbyPos(14, _T(\"\"));\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_1:\r\n\t\tret = OpenIndex(0);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_2:\r\n\t\tret = OpenIndex(1);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_3:\r\n\t\tret = OpenIndex(2);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_4:\r\n\t\tret = OpenIndex(3);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_5:\r\n\t\tret = OpenIndex(4);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_6:\r\n\t\tret = OpenIndex(5);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_7:\r\n\t\tret = OpenIndex(6);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_8:\r\n\t\tret = OpenIndex(7);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_9:\r\n\t\tret = OpenIndex(8);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_POSITION_10:\r\n\t\tret = OpenIndex(9);\r\n\t\tbreak;\r\n\tcase ActionEnums::CONFIG_SHOW_FIRST_TEN_TEXT:\r\n\t\tret = OnShowFirstTenText();\r\n\t\tbreak;\r\n\tcase ActionEnums::CONFIG_SHOW_CLIP_WAS_PASTED:\r\n\t\tret = OnShowClipWasPasted();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLE_LAST_GROUP_TOGGLE:\r\n\t\tret = OnToggleLastGroupToggle();\r\n\t\tbreak;\r\n\tcase ActionEnums::MAKE_TOP_STICKY:\r\n\t\tret = OnMakeTopSticky(false);\r\n\t\tbreak;\r\n\tcase ActionEnums::MAKE_LAST_STICKY:\r\n\t\tret = OnMakeLastSticky();\r\n\t\tbreak;\r\n\tcase ActionEnums::REMOVE_STICKY:\r\n\t\tret = OnRemoveStickySetting();\r\n\t\tbreak;\r\n\tcase ActionEnums::GLOBAl_HOTKEYS:\r\n\t\tret = OnGlobalHotkyes();\r\n\t\tbreak;\r\n\tcase ActionEnums::DELETE_CLIP_DATA:\r\n\t\tret = OnDeleteClipData();\r\n\t\tbreak;\r\n\tcase ActionEnums::IMPORT_CLIP:\r\n\t\tret = OnImportClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::REPLACE_TOP_STICKY_CLIP:\r\n\t\tret = DoActionReplaceTopStickyClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::PROMPT_SEND_TO_FRIEND:\r\n\t\tret = DoActionPromptSendToFriend();\r\n\t\tbreak;\r\n\tcase ActionEnums::SAVE_CF_HDROP_FIlE_DATA:\r\n\t\tret = DoActionSaveCF_HDROP_FileData();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLE_CLIPBOARD_CONNECTION:\r\n\t\tret = DoActionToggleClipboardConnection();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_SELECTION_UP:\r\n\t\tret = DoActionMoveSelectionUp();\r\n\t\tbreak;\r\n\tcase ActionEnums::MOVE_SELECTION_DOWN:\r\n\t\tret = DoActionMoveSelectionDown();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLE_DESCRIPTION_WORD_WRAP:\r\n\t\tret = DoActionToggleDescriptionWordWrap();\r\n\t\tbreak;\r\n\tcase ActionEnums::APPLY_LAST_SEARCH:\r\n\t\tret = DoActionApplyLastSearch();\r\n\t\tbreak;\r\n\tcase ActionEnums::TOGGLE_SEARCH_METHOD:\r\n\t\tret = DoActionToggleSearchMethod();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_SCRIPT:\r\n\t\tret = DoActionPasteScript(a.RefData);\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_DONT_MOVE_CLIP:\r\n\t\tret = DoActionPasteDontMoveClip();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_TRIM_WHITE_SPACE:\r\n\t\tret = DoActionPasteTrimWhiteSpace();\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_NONE:\r\n\t\tSetTransparency(0);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_5:\r\n\t\tSetTransparency(5);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_10:\r\n\t\tSetTransparency(10);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_15:\r\n\t\tSetTransparency(15);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_20:\r\n\t\tSetTransparency(20);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_25:\r\n\t\tSetTransparency(25);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_30:\r\n\t\tSetTransparency(30);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_35:\r\n\t\tSetTransparency(35);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_40:\r\n\t\tSetTransparency(40);\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_TOGGLE:\r\n\t\tDoActionToggleTransparency();\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_INCREASE:\r\n\t\tDoActionIncreaseTransparency();\r\n\t\tbreak;\r\n\tcase ActionEnums::TRANSPARENCY_DECREASE:\r\n\t\tDoActionDecreaseTransparency();\r\n\t\tbreak;\r\n\tcase ActionEnums::EMAILTO_BODY:\r\n\t\tDoActionEmailTo();\r\n\t\tbreak;\r\n\tcase ActionEnums::GMAIL:\r\n\t\tDoActionGmail();\r\n\t\tbreak;\r\n\tcase ActionEnums::EMAILTO_ATTACH_EXPORT:\r\n\t\tDoActionEmailToAttachExport();\r\n\t\tbreak;\r\n\tcase ActionEnums::EMAILTO_ATTACH_CONTENT:\r\n\t\tDoActionEmailToAttachContent();\r\n\t\tbreak;\r\n\tcase ActionEnums::SLUGIFY:\r\n\t\tDoActionSlugify();\r\n\t\tbreak;\r\n\tcase ActionEnums::COPY_SELECTION:\r\n\t\tret = DoCopySelection();\r\n\t\tbreak;\r\n\tcase ActionEnums::REFRESH_LIST:\r\n\t\tret = DoRefreshList();\r\n\t\tbreak;\r\n\tcase ActionEnums::DELETE_ALL_NON_USED_CLIPS:\r\n\t\tret = DoDeleteAllNonUsedClips();\r\n\t\tbreak;\r\n\tcase ActionEnums::SET_DRAG_FILE_NAME:\r\n\t\tret = DoSetDragFileName();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_CAMEL_CASE:\r\n\t\tret = DoPasteCamelCase();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_MULTI_IMAGE_HORIZONTAL:\r\n\t\tret = DoPasteImagesHorz();\r\n\t\tbreak;\r\n\tcase ActionEnums::PASTE_MULTI_IMAGE_VERTICAL:\r\n\t\tret = DoPasteImagesVert();\r\n\t\tbreak;\r\n\tcase ActionEnums::ASCII_TEXT_ONLY:\r\n\t\tret = DoPasteAsciiOnly();\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoSetDragFileName()\r\n{\r\n\tm_bHideWnd = false;\r\n\r\n\tCGroupName Name;\r\n\r\n\tCDimWnd dimmer(this);\r\n\r\n\tINT_PTR nRet = Name.DoModal();\r\n\r\n\tif (nRet == IDOK)\r\n\t{\r\n\t\tCString csName = Name.m_csName;\r\n\t\tCGetSetOptions::SetTempDragFileName(csName);\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\t\t\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPasteDontMoveClip()\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tpasteOptions.m_updateClipOrder = false;\r\n\tOpenSelection(pasteOptions);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPasteTrimWhiteSpace()\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tpasteOptions.m_trimWhiteSpace = true;\r\n\tOpenSelection(pasteOptions);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPasteScript(CString scriptGuid)\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tpasteOptions.m_pasteScriptGuid = scriptGuid;\r\n\tOpenSelection(pasteOptions);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleSearchMethod()\r\n{\r\n\tif (CGetSetOptions::GetRegExTextSearch())\r\n\t{\r\n\t\t//if regex go back to wildcard\r\n\t\tCGetSetOptions::SetSimpleTextSearch(FALSE);\r\n\t\tCGetSetOptions::SetRegExTextSearch(FALSE);\r\n\t}\r\n\telse if (CGetSetOptions::GetSimpleTextSearch())\r\n\t{\r\n\t\t//if contains search go to regex\r\n\t\tCGetSetOptions::SetSimpleTextSearch(FALSE);\r\n\t\tCGetSetOptions::SetRegExTextSearch(TRUE);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//if wildcard to to contains\r\n\t\tCGetSetOptions::SetSimpleTextSearch(TRUE);\r\n\t\tCGetSetOptions::SetRegExTextSearch(FALSE);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionApplyLastSearch()\r\n{\r\n\treturn m_search.ApplyLastSearch();\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleDescriptionWordWrap()\r\n{\r\n\tif (m_lstHeader.IsToolTipWindowVisible() == FALSE)\r\n\t\treturn false;\r\n\r\n\tbool ret = m_lstHeader.ToggleToolTipWordWrap();\r\n\treturn (ret == true);\r\n}\r\n\r\nbool CQPasteWnd::DoActionShowDescription()\r\n{\r\n\tbool ret = false;\r\n\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\tif (csText != _T(\"\"))\r\n\t{\r\n\t\tm_search.AddToSearchHistory();\r\n\t}\r\n\r\n\tif (m_lstHeader.IsToolTipWindowVisible() == false)\r\n\t{\r\n\t\tret = m_lstHeader.ShowFullDescription(false, false);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (csText != _T(\"\"))\r\n\t\t{\r\n\t\t\tm_lstHeader.DoToolTipSearch();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_lstHeader.HideToolTip();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (ret == true);\r\n}\r\n\r\nbool CQPasteWnd::DoActionNextDescription()\r\n{\r\n\tif (m_lstHeader.IsToolTipWindowVisible() == FALSE)\r\n\t\treturn false;\r\n\r\n\tif (CGetSetOptions::m_bAllwaysShowDescription)\r\n\t\treturn false;\r\n\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\r\n\tARRAY Indexes;\r\n\tm_lstHeader.GetSelectionIndexes(Indexes);\r\n\r\n\tlong caret = m_lstHeader.GetCaret();\r\n\r\n\tif (Indexes.GetCount() > 1)\r\n\t{\r\n\t\tfor (int i = 0; i < Indexes.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint index = Indexes[i];\r\n\t\t\tif (index == caret)\r\n\t\t\t{\r\n\t\t\t\tif (i < Indexes.GetCount() - 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tcaret = Indexes[i + 1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcaret = Indexes[0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_lstHeader.SetCaret(caret);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcaret++;\r\n\t\tm_lstHeader.SetListPos(caret);\r\n\t}\r\n\r\n\tm_lstHeader.ShowFullDescription(false, true);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPrevDescription()\r\n{\r\n\tif (m_lstHeader.IsToolTipWindowVisible() == FALSE)\r\n\t\treturn false;\r\n\r\n\tif (CGetSetOptions::m_bAllwaysShowDescription)\r\n\t\treturn false;\r\n\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\r\n\tARRAY Indexes;\r\n\tm_lstHeader.GetSelectionIndexes(Indexes);\r\n\r\n\tlong caret = m_lstHeader.GetCaret();\r\n\r\n\tif (Indexes.GetCount() > 1)\r\n\t{\r\n\t\tfor (int i = ((int)Indexes.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tint index = Indexes[i];\r\n\t\t\tif (index == caret)\r\n\t\t\t{\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tcaret = Indexes[i - 1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcaret = Indexes[((int)Indexes.GetCount()) - 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_lstHeader.SetCaret(caret);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcaret--;\r\n\t\tm_lstHeader.SetListPos(caret);\r\n\t}\r\n\r\n\tm_lstHeader.ShowFullDescription(false, true);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionShowMenu()\r\n{\r\n\tShowRightClickMenu();\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionShowSystemMenu()\r\n{\r\n\tOnSystemButton();\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionNewGroup()\r\n{\r\n\tNewGroup(false, theApp.GetValidGroupID());\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionNewGroupSelection()\r\n{\r\n\tNewGroup(true, theApp.GetValidGroupID());\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleFileLogging()\r\n{\r\n\tif (CGetSetOptions::m_bEnableDebugLogging)\r\n\t{\r\n\t\tLog(_T(\"turning file logging OFF\"));\r\n\t}\r\n\r\n\tCGetSetOptions::m_bEnableDebugLogging = !CGetSetOptions::m_bEnableDebugLogging;\r\n\r\n\tif (CGetSetOptions::m_bEnableDebugLogging)\r\n\t{\r\n\t\tLog(_T(\"turning file logging ON\"));\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleOutputDebugString()\r\n{\r\n\tif (CGetSetOptions::m_bEnableDebugLogging)\r\n\t{\r\n\t\tLog(_T(\"turning DebugString logging OFF\"));\r\n\t}\r\n\r\n\tCGetSetOptions::m_outputDebugStringLogging = !CGetSetOptions::m_outputDebugStringLogging;\r\n\r\n\tif (CGetSetOptions::m_bEnableDebugLogging)\r\n\t{\r\n\t\tLog(_T(\"turning DebugString logging ON\"));\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionForceCloseWindow()\r\n{\r\n\tLog(_T(\"Force closing window from hot keys\"));\r\n\tHideQPasteWindow(true);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionCloseWindow()\r\n{\r\n\tbool ret = false;\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tLog(_T(\"Escape key hit setting modifers to NOT active\"));\r\n\t\tm_bModifersMoveActive = false;\r\n\t\tret = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(_T(\"close 1\"));\r\n\r\n\t\tif (m_lstHeader.IsToolTipShowPersistant() == false &&\r\n\t\t\tm_lstHeader.IsToolTipWindowVisible())\r\n\t\t{\r\n\t\t\tm_lstHeader.HidePopup(true);\r\n\t\t\tLog(_T(\"close 2\"));\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\telse if (m_strSQLSearch.IsEmpty() == FALSE)\r\n\t\t{\r\n\t\t\tOnCancelFilter(0, 0);\r\n\t\t\tLog(_T(\"close 3\"));\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (CGetSetOptions::GetShowPersistent() && this->GetMinimized() == false)\r\n\t\t\t{\r\n\t\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t\t\ttheApp.m_activeWnd.ReleaseFocus();\r\n\r\n\t\t\t\tLog(_T(\"close 4\"));\r\n\r\n\t\t\t\tret = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (m_GroupTree.IsWindowVisible() == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tHideQPasteWindow(true);\r\n\t\t\t\t\tret = true;\r\n\t\t\t\t\tLog(_T(\"close 5\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tLog(_T(\"close 6\"));\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoActionNextTabControl()\r\n{\r\n\tBOOL bPrev = FALSE;\r\n\r\n\tCWnd *pFocus = GetFocus();\r\n\tif (pFocus)\r\n\t{\r\n\t\tCWnd *pNextWnd = GetNextDlgTabItem(pFocus, bPrev);\r\n\t\tif (pNextWnd)\r\n\t\t{\r\n\t\t\tpNextWnd->SetFocus();\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPrevTabControl()\r\n{\r\n\tBOOL bPrev = TRUE;\r\n\r\n\tCWnd *pFocus = GetFocus();\r\n\tif (pFocus)\r\n\t{\r\n\t\tCWnd *pNextWnd = GetNextDlgTabItem(pFocus, bPrev);\r\n\t\tif (pNextWnd)\r\n\t\t{\r\n\t\t\tpNextWnd->SetFocus();\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionShowGroups()\r\n{\r\n\tOnShowGroupsTop();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionNewClip()\r\n{\r\n\tCClipIDs IDs;\r\n\tIDs.Add(-1);\r\n\ttheApp.EditItems(IDs, true, true);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionEditClip()\r\n{\r\n\tif (m_lstHeader.GetSelectedCount() == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tbool textOnly = false;\r\n\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t{\r\n\t\ttextOnly = true;\r\n\t}\r\n\r\n\ttheApp.EditItems(IDs, true, textOnly);\r\n\t\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionMoveSelectionUp()\r\n{\r\n\tMoveSelection(false, false);\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionMoveSelectionDown()\r\n{\r\n\tMoveSelection(true, false);\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoModifierActiveActionSelectionUp()\r\n{\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tMoveSelection(false, true);\r\n\t\tm_modifierKeyActions.m_handleRepeatKeys = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoModifierActiveActionSelectionDown()\r\n{\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tMoveSelection(true, true);\r\n\t\tm_modifierKeyActions.m_handleRepeatKeys = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoModifierActiveActionMoveFirst()\r\n{\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tm_lstHeader.SetListPos(0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoModifierActiveActionMoveLast()\r\n{\r\n\tif (m_bModifersMoveActive)\r\n\t{\r\n\t\tif (m_lstHeader.GetItemCount() > 0)\r\n\t\t{\r\n\t\t\tm_lstHeader.SetListPos(m_lstHeader.GetItemCount() - 1);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoActionCancelFilter()\r\n{\r\n\tFillList();\r\n\r\n\tm_bHandleSearchTextChange = false;\r\n\tm_search.SetWindowText(_T(\"\"));\r\n\tm_bHandleSearchTextChange = true;\r\n\r\n\tMoveControls();\r\n\r\n\tm_lstHeader.SetFocus();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionHomeList()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\ttheApp.EnterGroupID(-1); // History\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoActionBackGroup()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\ttheApp.EnterGroupID(theApp.m_GroupParentID);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleShowPersistant()\r\n{\r\n\tif (m_lstHeader.IsToolTipWindowVisible())\r\n\t{\r\n\t\tm_lstHeader.ToggleToolTipShowPersistant();\r\n\t}\r\n\telse\r\n\t{\r\n\t\ttheApp.ShowPersistent(!CGetSetOptions::m_bShowPersistent);\r\n\t\tif (CGetSetOptions::m_bShowPersistent)\r\n\t\t{\r\n\t\t\t::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);\r\n\t\t}\r\n\r\n\t\tMoveControls();\r\n\r\n\t\tUpdateStatus();\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPasteSelected()\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tOpenSelection(pasteOptions);\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionDeleteSelected()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tm_actions.m_handleRepeatKeys = true;\r\n\t\tDeleteSelectedRows();\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoActionClipProperties()\r\n{\r\n\tbool ret = false;\r\n\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tm_bHideWnd = false;\r\n\r\n\t\tARRAY IDs, Indexes;\r\n\t\tm_lstHeader.GetSelectionItemData(IDs);\r\n\t\tm_lstHeader.GetSelectionIndexes(Indexes);\r\n\r\n\t\tINT_PTR size = IDs.GetSize();\r\n\t\tif (size < 1)\r\n\t\t{\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tint id = IDs[0];\r\n\t\tint row = Indexes[0];\r\n\r\n\t\tif (id < 0)\r\n\t\t{\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tm_lstHeader.RemoveAllSelection();\r\n\t\tm_lstHeader.SetSelection(row);\r\n\r\n\t\tret = ShowProperties(id, row);\r\n\r\n\t\tm_lstHeader.SetListPos(row);\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::ShowProperties(int id, int row)\r\n{\r\n\tif (id < 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tm_bHideWnd = false;\r\n\r\n\tCDimWnd dimmer(this);\r\n\r\n\tCCopyProperties props(id, this);\r\n\tINT_PTR doModalRet = props.DoModal();\r\n\r\n\tif (doModalRet == IDOK)\r\n\t{\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\t\tif (row < 0)\r\n\t\t\t{\r\n\t\t\t\tbool selectedItem = false;\r\n\t\t\t\tint index = 0;\r\n\t\t\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\t\t\twhile (iter != m_listItems.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (iter->m_lID == id)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trow = index;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\titer++;\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (row >= 0 &&\r\n\t\t\t\trow < (int)m_listItems.size())\r\n\t\t\t{\r\n\t\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT * FROM Main WHERE lID = %d\"), id);\r\n\t\t\t\tif (!q.eof())\r\n\t\t\t\t{\r\n\t\t\t\t\tFillMainTable(m_listItems[row], q);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tRemoveFromImageRtfCache(row);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_extraDataThread.FireLoadAccelerators();\r\n\r\n\t\tm_lstHeader.RefreshVisibleRows();\r\n\r\n\t\tif (props.m_lGroupChangedTo >= 0)\r\n\t\t{\r\n\t\t\tCSpecialPasteOptions pasteOptions;\r\n\t\t\tOpenID(props.m_lGroupChangedTo, pasteOptions);\r\n\t\t}\r\n\r\n\t\tm_lstHeader.SetFocus();\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPasteSelectedPlainText()\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tpasteOptions.m_pasteAsPlainText = true;\r\n\tOpenSelection(pasteOptions);\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionMoveClipToGroup()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tm_bHideWnd = false;\r\n\r\n\t\tCDimWnd dimmer(this);\r\n\r\n\t\tCMoveToGroupDlg dlg;\r\n\r\n\t\tINT_PTR nRet = dlg.DoModal();\r\n\t\tif (nRet == IDOK)\r\n\t\t{\r\n\t\t\tint nGroup = dlg.GetSelectedGroup();\r\n\r\n\t\t\tLog(StrF(_T(\"Move to Group, GroupId: %d\"), nGroup));\r\n\r\n\t\t\tif (nGroup >= -1)\r\n\t\t\t{\r\n\t\t\t\tCClipIDs IDs;\r\n\t\t\t\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\t\t\t\tIDs.MoveTo(nGroup);\r\n\t\t\t}\r\n\t\t\tFillList();\r\n\t\t}\r\n\r\n\t\tm_bHideWnd = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoActionElevatePrivleges()\r\n{\r\n\tCGetSetOptions::SetPasteAsAdmin(!CGetSetOptions::GetPasteAsAdmin());\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoShowInTaskBar()\r\n{\r\n\tCGetSetOptions::SetShowInTaskBar(!CGetSetOptions::GetShowInTaskBar());\r\n\r\n\ttheApp.RefreshShowInTaskBar();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoClipCompare()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 1)\r\n\t{\r\n\t\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t\t{\r\n\t\t\tHideQPasteWindow(false, false);\r\n\t\t}\r\n\t\telse if (CGetSetOptions::GetAutoHide())\r\n\t\t{\r\n\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t}\r\n\r\n\t\tCClipCompare compare;\r\n\t\tcompare.Compare(IDs[0], IDs[1]);\r\n\r\n\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"DoClipCompare, at least 2 clips need to be selected, count: %d\"), IDs.GetCount()));\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoSelectLeftSideCompare()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tm_leftSelectedCompareId = IDs[0];\r\n\r\n\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"DoSelectLeftSideCompare, no selected clip, not assigning left side\")));\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoSelectRightSideAndDoCompare()\r\n{\r\n\tif (m_leftSelectedCompareId > 0)\r\n\t{\r\n\t\tARRAY IDs;\r\n\t\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\t\tif (IDs.GetCount() > 0)\r\n\t\t{\r\n\t\t\tint rightId = IDs[0];\r\n\r\n\t\t\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t\t\t{\r\n\t\t\t\tHideQPasteWindow(false, false);\r\n\t\t\t}\r\n\t\t\telse if (CGetSetOptions::GetAutoHide())\r\n\t\t\t{\r\n\t\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t\t}\r\n\r\n\t\t\tCClipCompare compare;\r\n\t\t\tcompare.Compare(m_leftSelectedCompareId, rightId);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(StrF(_T(\"DoSelectRightSideAndDoCompare, no selected clips\")));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(StrF(_T(\"DoSelectRightSideAndDoCompare, no left side selected, select left side first\")));\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoExportToTextFile()\r\n{\r\n\tbool ret = false;\r\n\r\n\tCClipIDs IDs;\r\n\tINT_PTR lCount = m_lstHeader.GetSelectedCount();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tlCount = IDs.GetSize();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tOPENFILENAME ofn;\r\n\tTCHAR szFile[400];\r\n\tTCHAR szDir[400];\r\n\r\n\tmemset(&szFile, 0, sizeof(szFile));\r\n\tmemset(szDir, 0, sizeof(szDir));\r\n\tmemset(&ofn, 0, sizeof(ofn));\r\n\r\n\tCString csInitialDir = CGetSetOptions::GetLastImportDir();\r\n\tSTRCPY(szDir, csInitialDir);\r\n\r\n\tofn.lStructSize = sizeof(OPENFILENAME);\r\n\tofn.hwndOwner = m_hWnd;\r\n\tofn.lpstrFile = szFile;\r\n\tofn.nMaxFile = sizeof(szFile);\r\n\tofn.lpstrFilter = _T(\"Exported Ditto Clips (.txt)\\0*.txt\\0\\0\");\r\n\tofn.nFilterIndex = 1;\r\n\tofn.lpstrFileTitle = NULL;\r\n\tofn.nMaxFileTitle = 0;\r\n\tofn.lpstrInitialDir = szDir;\r\n\tofn.lpstrDefExt = _T(\"txt\");\r\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;\r\n\r\n\tm_bHideWnd = false;\r\n\r\n\tif (GetSaveFileName(&ofn))\r\n\t{\r\n\t\tusing namespace nsPath;\r\n\t\tCString startingFilePath = ofn.lpstrFile;\r\n\t\tCPath path(ofn.lpstrFile);\r\n\t\tCString csPath = path.GetPath();\r\n\t\tCString csExt = path.GetExtension();\r\n\t\tpath.RemoveExtension();\r\n\t\tCString csFileName = path.GetName();\r\n\r\n\t\tCGetSetOptions::SetLastExportDir(csPath);\r\n\t\tint lastFileCheckId = 1;\r\n\r\n\t\tfor (int i = 0; i < IDs.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadFormats(id, true))\r\n\t\t\t{\r\n\t\t\t\tCString savePath = startingFilePath;\r\n\t\t\t\tif (IDs.GetCount() > 1 ||\r\n\t\t\t\t\tFileExists(startingFilePath))\r\n\t\t\t\t{\r\n\t\t\t\t\tsavePath = _T(\"\");\r\n\r\n\t\t\t\t\tfor (int y = lastFileCheckId; y < 1000000; y++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCString testFilePath;\r\n\t\t\t\t\t\ttestFilePath.Format(_T(\"%s%s_%d.%s\"), csPath, csFileName, y, csExt);\r\n\t\t\t\t\t\tif (FileExists(testFilePath) == FALSE)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsavePath = testFilePath;\r\n\t\t\t\t\t\t\tlastFileCheckId = y+1;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (savePath != _T(\"\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.WriteTextToFile(savePath, true, true, false);\r\n\r\n\t\t\t\t\tret = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"Failed to find a valid file name for starting path: %s\"), startingFilePath));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoExportToQRCode()\r\n{\r\n\tbool ret = false;\r\n\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tint id = IDs[0];\r\n\t\tCClip clip;\r\n\t\tif (clip.LoadMainTable(id))\r\n\t\t{\r\n\t\t\tif (clip.LoadFormats(id, true))\r\n\t\t\t{\r\n\t\t\t\tCString clipText = clip.GetUnicodeTextFormat();\r\n\r\n\t\t\t\tCString clipTextUrlEncoded = InternetEncode(clipText);\r\n\t\t\t\tCString qrCodeUrl = CGetSetOptions::GetQRCodeUrl();\r\n\t\t\t\tCString url = StrF(_T(\"%s%s\"), qrCodeUrl, clipTextUrlEncoded);\r\n\r\n\t\t\t\tLog(StrF(_T(\"Opening qr code url: %s\"), url));\r\n\r\n\t\t\t\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t\t\t\t{\r\n\t\t\t\t\tHideQPasteWindow(false, false);\r\n\t\t\t\t}\r\n\t\t\t\telse if (CGetSetOptions::GetAutoHide())\r\n\t\t\t\t{\r\n\t\t\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tCHyperLink::GotoURL(url, SW_SHOW);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoExportToGoogleTranslate()\r\n{\r\n\tbool ret = false;\r\n\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tint id = IDs[0];\r\n\t\tCClip clip;\r\n\t\tif (clip.LoadMainTable(id))\r\n\t\t{\r\n\t\t\tif (clip.LoadFormats(id, true))\r\n\t\t\t{\r\n\t\t\t\tCString clipText = clip.GetUnicodeTextFormat();\r\n\t\t\t\tif (clipText == _T(\"\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tCStringA aText = clip.GetCFTextTextFormat();\r\n\t\t\t\t\tif (aText != _T(\"\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclipText = CTextConvert::AnsiToUnicode(aText);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (clipText != _T(\"\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tCString clipTextUrlEncoded = InternetEncode(clipText);\r\n\r\n\t\t\t\t\tCString url;\r\n\t\t\t\t\turl.Format(CGetSetOptions::GetTranslateUrl(), clipTextUrlEncoded);\r\n\r\n\t\t\t\t\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tHideQPasteWindow(false, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (CGetSetOptions::GetAutoHide())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMinMaxWindow(FORCE_MIN);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tCHyperLink::GotoURL(url, SW_SHOW);\r\n\r\n\t\t\t\t\tret = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoSaveCurrentClipboard()\r\n{\r\n\ttheApp.m_pMainFrame->PostMessage(WM_SAVE_CLIPBOARD, 0, 0);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoMoveClipDown()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = ((int)IDs.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tclip.MoveDown(theApp.m_GroupID);\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoMoveClipUp()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tm_actions.m_handleRepeatKeys = true;\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = 0; i < IDs.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tclip.MoveUp(theApp.m_GroupID);\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoMoveClipLast()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = 0; i < IDs.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.MakeLastGroupOrder();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.MakeLastOrder();\r\n\t\t\t\t}\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\t//have we loaded all clips, if so then sort and select\r\n\t\t\t\tif (m_listItems.size() == m_lstHeader.GetItemCount())\r\n\t\t\t\t{\r\n\t\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t//haven't loaded all clips so this will be out of what we have loaded\r\n\t\t\t\t\t//remove this from the list, will be shown as they scroll down the list\r\n\t\t\t\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\t\t\t\twhile (iter != m_listItems.end())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (iter->m_lID == clip.ID())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tm_listItems.erase(iter);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\titer++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\t\t}\r\n\r\n\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\tm_lstHeader.RedrawWindow();\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoMoveClipTOP()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = 0; i < IDs.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.MakeLatestGroupOrder();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tclip.MakeLatestOrder();\r\n\t\t\t\t}\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoFilterOnSelectedClip()\r\n{\r\n\tbool ret = false;\r\n\tARRAY IDs, Indexes;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tINT_PTR size = IDs.GetSize();\r\n\tif (size > 0)\r\n\t{\r\n\t\tint id = IDs[0];\r\n\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\twhile (iter != m_listItems.end())\r\n\t\t{\r\n\t\t\tif (iter->m_lID == id)\r\n\t\t\t{\r\n\t\t\t\tm_bHandleSearchTextChange = false;\r\n\t\t\t\tm_search.SetWindowText(iter->m_Desc);\r\n\t\t\t\tm_bHandleSearchTextChange = true;\r\n\t\t\t\tOnSearch(0, 0);\r\n\t\t\t\tret = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\titer++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteUpperCase()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteUpperCase = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteCamelCase()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteCamelCase = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteImagesHorz()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteImagesHorizontal = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteImagesVert()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteImagesVertically = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteAsciiOnly()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteAsciiOnly = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteLowerCase()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteLowerCase = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteCapitalize()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteCapitalize = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteSentenceCase()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteSentenceCase = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoInvertCase()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_invertCase = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteRemoveLineFeeds()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteRemoveLineFeeds = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPastePlusAddLineFeed()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteAddOneLineFeed = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteAddTwoLineFeeds()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteAddTwoLineFeeds = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteTypoglycemia()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteTypoglycemia = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoPasteAddCurrentTime()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteAddingDateTime = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::OnShowFirstTenText()\r\n{\r\n\tCGetSetOptions::SetShowTextForFirstTenHotKeys(!CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\tm_lstHeader.SetShowTextForFirstTenHotKeys(CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n\tm_lstHeader.RedrawWindow();\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnShowClipWasPasted()\r\n{\r\n\tCGetSetOptions::SetShowIfClipWasPasted(!CGetSetOptions::GetShowIfClipWasPasted());\r\n\tm_lstHeader.SetShowIfClipWasPasted(CGetSetOptions::GetShowIfClipWasPasted());\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n\tm_lstHeader.RedrawWindow();\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnToggleLastGroupToggle()\r\n{\r\n\tint newGroupId = -2;\r\n\tif (theApp.m_GroupID > 0)\r\n\t{\r\n\t\tCGetSetOptions::SetLastGroupToggle(theApp.m_GroupID);\r\n\t\tnewGroupId = -1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnewGroupId = CGetSetOptions::GetLastGroupToggle();\r\n\t}\r\n\r\n\tif (newGroupId >= -1)\r\n\t{\r\n\t\ttheApp.EnterGroupID(newGroupId);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnMakeTopSticky(bool forceSort)\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = forceSort;\r\n\t\tfor (int i = ((int)IDs.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tclip.MakeStickyTop(theApp.m_GroupID);\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnMakeLastSticky()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = ((int)IDs.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tclip.MakeStickyLast(theApp.m_GroupID);\r\n\t\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\t\tsort = SyncClipDataToArrayData(clip);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\tSelectIds(IDs);\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnRemoveStickySetting()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = ((int)IDs.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tRemoveStickyInternal(IDs[i], sort);\r\n\t\t}\r\n\r\n\t\t//theApp.m_FocusID = id;\r\n\r\n\t\tif (sort)\r\n\t\t{\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::GroupSortDesc);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::sort(m_listItems.begin(), m_listItems.end(), CMainTable::SortDesc);\r\n\t\t\t}\r\n\r\n\t\t\t//SelectFocusID();\r\n\r\n\t\t\tm_lstHeader.RefreshVisibleRows();\r\n\t\t\tm_lstHeader.RedrawWindow();\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CQPasteWnd::RemoveStickyInternal(int id, bool &sort)\r\n{\r\n\tCClip clip;\r\n\tif (clip.LoadMainTable(id))\r\n\t{\r\n\t\tif (clip.RemoveStickySetting(theApp.m_GroupID))\r\n\t\t{\r\n\t\t\tclip.ModifyMainTable();\r\n\r\n\t\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\t\twhile (iter != m_listItems.end())\r\n\t\t\t{\r\n\t\t\t\tif (iter->m_lID == id)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titer->m_stickyClipGroupOrder = clip.m_stickyClipGroupOrder;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\titer->m_stickyClipOrder = clip.m_stickyClipOrder;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsort = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\titer++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool CQPasteWnd::OnNewClip()\r\n{\r\n\tCWnd *pWnd = AfxGetMainWnd();\r\n\tif (pWnd != NULL)\r\n\t{\r\n\t\tpWnd->SendMessage(WM_COMMAND, ID_FIRST_NEWCLIP, 0);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnImportClip()\r\n{\r\n\tCWnd *pWnd = AfxGetMainWnd();\r\n\tif (pWnd != NULL)\r\n\t{\r\n\t\tpWnd->SendMessage(WM_COMMAND, ID_FIRST_IMPORT, 0);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionReplaceTopStickyClip()\r\n{\r\n\tARRAY IDs;\r\n\tIDs.Add(m_lstHeader.GetItemData(0));\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tbool sort = false;\r\n\t\tfor (int i = ((int)IDs.GetCount()) - 1; i >= 0; i--)\r\n\t\t{\r\n\t\t\tRemoveStickyInternal(IDs[i], sort);\r\n\t\t}\r\n\r\n\t\tOnMakeTopSticky(true);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionSaveCF_HDROP_FileData()\r\n{\r\n\tif (m_lstHeader.GetSelectedCount() == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCWaitCursor wait;\r\n\r\n\tCString errorMessage;\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tfor (int i = 0; i < min(Indexs.GetCount(), IDs.GetCount()); i++)\r\n\t\t{\r\n\t\t\tint row = Indexs[i];\r\n\t\t\tint id = IDs[i];\r\n\t\t\tCClip clip;\r\n\t\t\tif (clip.LoadMainTable(id))\r\n\t\t\t{\r\n\t\t\t\tif (clip.LoadFormats(id))\r\n\t\t\t\t{\r\n\t\t\t\t\tCString localErrorMessage;\r\n\t\t\t\t\tif (clip.AddFileDataToData(localErrorMessage))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (row >= 0 &&\r\n\t\t\t\t\t\t\trow < (int)m_listItems.size())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT * FROM Main WHERE lID = %d\"), id);\r\n\t\t\t\t\t\t\tif (!q.eof())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tFillMainTable(m_listItems[row], q);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\terrorMessage += localErrorMessage;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (errorMessage.GetLength() > 0)\r\n\t{\r\n\t\tm_popupMsg.Show(errorMessage, CPoint(0, 0), true);\r\n\t\tSetTimer(TIMER_ERROR_MSG, CGetSetOptions::GetErrorMsgPopupTimeout(), NULL);\r\n\t}\r\n\r\n\tm_lstHeader.RefreshVisibleRows();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionPromptSendToFriend()\r\n{\r\n\tm_bHideWnd = false;\r\n\r\n\tCDimWnd dimmer(this);\r\n\r\n\tCFriendPromptDlg dlg(this);\r\n\tif (dlg.DoModal() == IDOK)\r\n\t{\r\n\t\tif (dlg.GetClearList())\r\n\t\t{\r\n\t\t\tm_customFriendsHelper.ClearList();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCString name = dlg.GetName();\r\n\t\t\tif (name != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\tif (dlg.GetSave())\r\n\t\t\t\t{\r\n\t\t\t\t\tm_customFriendsHelper.Add(name, dlg.GetDesc());\r\n\t\t\t\t}\r\n\t\t\t\tSendToFriendbyPos(0, name);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleClipboardConnection()\r\n{\r\n\ttheApp.ToggleConnectCV();\r\n\tUpdateStatus();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnDeleteClipData()\r\n{\r\n\tCWnd *pWnd = AfxGetMainWnd();\r\n\tif (pWnd != NULL)\r\n\t{\r\n\t\tpWnd->SendMessage(WM_COMMAND, ID_FIRST_DELETECLIPDATA, 0);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::OnGlobalHotkyes()\r\n{\r\n\tCWnd *pWnd = AfxGetMainWnd();\r\n\tif (pWnd != NULL)\r\n\t{\r\n\t\tpWnd->SendMessage(WM_COMMAND, ID_FIRST_GLOBALHOTKEYS, 0);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoExportToBitMapFile()\r\n{\r\n\tbool ret = false;\r\n\r\n\tCClipIDs IDs;\r\n\tINT_PTR lCount = m_lstHeader.GetSelectedCount();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\tlCount = IDs.GetSize();\r\n\tif (lCount <= 0)\r\n\t{\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tOPENFILENAME ofn;\r\n\tTCHAR szFile[400];\r\n\tTCHAR szDir[400];\r\n\r\n\tmemset(&szFile, 0, sizeof(szFile));\r\n\tmemset(szDir, 0, sizeof(szDir));\r\n\tmemset(&ofn, 0, sizeof(ofn));\r\n\r\n\tCString csInitialDir = CGetSetOptions::GetLastImportDir();\r\n\tSTRCPY(szDir, csInitialDir);\r\n\r\n\tofn.lStructSize = sizeof(OPENFILENAME);\r\n\tofn.hwndOwner = m_hWnd;\r\n\tofn.lpstrFile = szFile;\r\n\tofn.nMaxFile = sizeof(szFile);\r\n\tofn.lpstrFilter = _T(\"PNG (*.png)\\0*.png\\0BMP (*.bmp)\\0*.bmp\\0JPEG (*.jpeg)\\0*.jpeg\");\r\n\tofn.nFilterIndex = 1;\r\n\tofn.lpstrFileTitle = NULL;\r\n\tofn.nMaxFileTitle = 0;\r\n\tofn.lpstrInitialDir = szDir;\r\n\tofn.lpstrDefExt = _T(\"png\");\r\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR | OFN_NOCHANGEDIR;\r\n\r\n\tm_bHideWnd = false;\r\n\r\n\tif (GetSaveFileName(&ofn))\r\n\t{\r\n\t\tCWaitCursor wait;\r\n\r\n\t\tusing namespace nsPath;\r\n\t\tCString startingFilePath = ofn.lpstrFile;\r\n\t\tCPath path(ofn.lpstrFile);\r\n\t\tCString csPath = path.GetPath();\r\n\t\tCString csExt = path.GetExtension();\r\n\t\tpath.RemoveExtension();\r\n\t\tCString csFileName = path.GetName();\r\n\r\n\t\tCGetSetOptions::SetLastExportDir(csPath);\r\n\r\n\t\tint lastFileCheckId = 1;\r\n\r\n\t\tfor (int i = 0; i < IDs.GetCount(); i++)\r\n\t\t{\r\n\t\t\tint id = IDs[i];\r\n\r\n\t\t\tCClip toSave;\r\n\t\t\ttoSave.LoadFormats(id);\r\n\r\n\t\t\tCClipFormat *png = NULL;\r\n\t\t\tCClipFormat *bitmap = toSave.m_Formats.FindFormat(CF_DIB);\r\n\t\t\tif (bitmap == NULL)\r\n\t\t\t{\r\n\t\t\t\tpng = toSave.m_Formats.FindFormat(theApp.m_PNG_Format);\r\n\t\t\t}\r\n\r\n\t\t\tif (bitmap == NULL && png == NULL)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tCString savePath = startingFilePath;\r\n\t\t\tif (IDs.GetCount() > 1 ||\r\n\t\t\t\tFileExists(startingFilePath))\r\n\t\t\t{\r\n\t\t\t\tsavePath = _T(\"\");\r\n\r\n\t\t\t\tfor (int y = lastFileCheckId; y < 1000000; y++)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString testFilePath;\r\n\t\t\t\t\ttestFilePath.Format(_T(\"%s%s_%d.%s\"), csPath, csFileName, y, csExt);\r\n\t\t\t\t\tif (FileExists(testFilePath) == FALSE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsavePath = testFilePath;\r\n\t\t\t\t\t\tlastFileCheckId = y+1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (savePath != _T(\"\"))\r\n\t\t\t{\r\n\t\t\t\ttoSave.WriteImageToFile(savePath);\r\n\r\n\t\t\t\tret = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Failed to find a valid file name for starting path: %s\"), startingFilePath));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\r\n\treturn ret;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnCancelFilter(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tthis->DoAction(ActionEnums::CANCELFILTER);\r\n\treturn 1;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnPostOptions(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tUpdateFont();\r\n\tLoadShortcuts();\r\n\r\n\tm_lstHeader.SetShowTextForFirstTenHotKeys(CGetSetOptions::GetShowTextForFirstTenHotKeys());\r\n\tm_lstHeader.SetShowIfClipWasPasted(CGetSetOptions::GetShowIfClipWasPasted());\r\n\tm_lstHeader.SetNumberOfLinesPerRow(CGetSetOptions::GetLinesPerRow(), true);\r\n\r\n\tSetCurrentTransparency();\r\n\r\n\tif (CGetSetOptions::m_tooltipTimeout > 0 ||\r\n\t\tCGetSetOptions::m_tooltipTimeout == -1)\r\n\t{\r\n\t\tm_lstHeader.EnableToolTips();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_lstHeader.EnableToolTips(FALSE);\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\nvoid CQPasteWnd::OnClose()\r\n{\r\n\tHideQPasteWindow(true);\r\n}\r\n\r\nvoid CQPasteWnd::OnBegindrag(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tNM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;\r\n\tCProcessPaste paste;\r\n\tpaste.m_pastedFromGroup = (theApp.m_GroupID > 0);\r\n\r\n\tif (CONTROL_PRESSED)\r\n\t{\r\n\t\tpaste.m_pasteOptions.m_dragDropFilesOnly = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpaste.m_pasteOptions.m_placeCF_HDROP_OnDrag = CGetSetOptions::GetAddCFHDROP_OnDrag();\r\n\t}\r\n\r\n\tCClipIDs &clips = paste.GetClipIDs();\r\n\r\n\tm_lstHeader.GetSelectionItemData(clips);\r\n\r\n\tif (clips.GetSize() <= 0)\r\n\t{\r\n\t\tASSERT(0); // does this ever happen ??\r\n\t\tclips.Add(m_lstHeader.GetItemData(pLV->iItem));\r\n\t}\r\n\r\n\tthis->SetTimer(TIMER_DRAG_HIDE_WINDOW, 500, NULL);\r\n\r\n\tpaste.DoDrag();\r\n\t\r\n\tKillTimer(TIMER_DRAG_HIDE_WINDOW);\r\n\r\n\r\n\tif (CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\tShowQPasteWindow(0);\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\nDROPEFFECT CQPasteWnd::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\r\n{\r\n\tint k = 0;\r\n\r\n\treturn DROPEFFECT_COPY;\r\n}\r\n\r\nDROPEFFECT CQPasteWnd::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)\r\n{\r\n\treturn DROPEFFECT_COPY;\r\n}\r\n\r\nBOOL CQPasteWnd::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point)\r\n{\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::OnDragLeave()\r\n{\r\n\r\n}\r\n\r\nvoid CQPasteWnd::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)\r\n{\r\n\tCWndEx::OnSysKeyDown(nChar, nRepCnt, nFlags);\r\n}\r\n\r\nvoid CQPasteWnd::GetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLV_DISPINFO *pDispInfo = (LV_DISPINFO*)pNMHDR;\r\n\tLV_ITEM *pItem = &(pDispInfo)->item;\r\n\r\n\tif (pItem->mask &LVIF_TEXT)\r\n\t{\r\n\t\tswitch (pItem->iSubItem)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\t\t\tint c = m_lstHeader.GetItemCount();\r\n\t\t\t\tif ((int)m_listItems.size() > pItem->iItem &&\r\n\t\t\t\t\tm_listItems[pItem->iItem].m_lID > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString cs;\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_bDontAutoDelete)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += _T(\"<noautodelete>\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_bHasShortCut)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += _T(\"<shortcut>\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_bIsGroup)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += _T(\"<group>\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (m_listItems[pItem->iItem].m_stickyClipGroupOrder != INVALID_STICKY)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcs += _T(\"<sticky>\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (m_listItems[pItem->iItem].m_stickyClipOrder != INVALID_STICKY)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcs += _T(\"<sticky>\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// attached to a group\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_bHasParent)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += _T(\"<ingroup>\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_QuickPaste.IsEmpty() == FALSE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += _T(\"<qpastetext>\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m_listItems[pItem->iItem].m_dateCopied != m_listItems[pItem->iItem].m_datePasted)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcs += \"<pasted>\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// pipe is the \"end of symbols\" marker\r\n\t\t\t\t\tcs += \"|\" + CMainTableFunctions::GetDisplayText(CGetSetOptions::m_nLinesPerRow, m_listItems[pItem->iItem].m_Desc);\r\n\r\n\t\t\t\t\tlstrcpyn(pItem->pszText, cs, pItem->cchTextMax);\r\n\t\t\t\t\tpItem->pszText[pItem->cchTextMax - 1] = '\\0';\r\n\r\n\t\t\t\t\t//\t\t\t\t\t\tLog(StrF(_T(\"DrawItem index %d - \"), pItem->iItem));//, pItem->pszText));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tbool addToLoadItems = true;\r\n\r\n\t\t\t\t\tfor (std::list<CPoint>::iterator it = m_loadItems.begin(); it != m_loadItems.end(); it++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (pItem->iItem >= it->x && pItem->iItem <= it->y)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\taddToLoadItems = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (addToLoadItems)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCPoint loadItem(pItem->iItem, (m_lstHeader.GetTopIndex() + (m_lstHeader.GetCountPerPage() * 2)));\r\n\r\n\t\t\t\t\t\t//Log(StrF(_T(\"DrawItem index %d, add: %d\"), loadItem.x, loadItem.y));\r\n\t\t\t\t\t\tm_loadItems.push_back(loadItem);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tm_thread.FireLoadItems(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tCATCH_SQLITE_EXCEPTION\r\n\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pItem->mask &LVIF_PARAM)\r\n\t{\r\n\t\tswitch (pItem->iSubItem)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\t\tif ((int)m_listItems.size() > pItem->iItem)\r\n\t\t\t{\r\n\t\t\t\tpItem->lParam = m_listItems[pItem->iItem].m_lID;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pItem->mask & LVIF_CF_DIB && CGetSetOptions::m_bDrawThumbnail)\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tif ((int)m_listItems.size() > pItem->iItem)\r\n\t\t{\r\n\t\t\tCF_NoDibTypeMap::iterator iterNoDib = m_cf_NO_dibCache.find(m_listItems[pItem->iItem].m_lID);\r\n\t\t\tif (iterNoDib == m_cf_NO_dibCache.end())\r\n\t\t\t{\r\n\t\t\t\tCF_DibTypeMap::iterator iterDib = m_cf_dibCache.find(m_listItems[pItem->iItem].m_lID);\r\n\t\t\t\tif (iterDib == m_cf_dibCache.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tbool exists = false;\r\n\t\t\t\t\tfor (std::list<CClipFormatQListCtrl>::iterator it = m_ExtraDataLoadItems.begin(); it != m_ExtraDataLoadItems.end(); it++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (it->m_cfType == CF_DIB && it->m_parentId == m_listItems[pItem->iItem].m_lID)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\texists = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (exists == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCClipFormatQListCtrl format;\r\n\t\t\t\t\t\tformat.m_cfType = CF_DIB;\r\n\t\t\t\t\t\tformat.m_parentId = m_listItems[pItem->iItem].m_lID;\r\n\t\t\t\t\t\tformat.m_clipRow = pItem->iItem;\r\n\t\t\t\t\t\tformat.m_autoDeleteData = true;\r\n\t\t\t\t\t\tformat.m_counter = m_extraDataCounter++;\r\n\t\t\t\t\t\tm_ExtraDataLoadItems.push_back(format);\r\n\r\n\t\t\t\t\t\tm_extraDataThread.FireLoadExtraData(m_lstHeader.GetRowHeight());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (iterDib->second.m_hgData != NULL)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpItem->lParam = (LPARAM) &(iterDib->second);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (pItem->mask & LVIF_CF_RICHTEXT && CGetSetOptions::m_bDrawRTF)\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\t\tif ((int)m_listItems.size() > pItem->iItem)\r\n\t\t{\r\n\t\t\tCF_NoDibTypeMap::iterator iterNoRtf = m_cf_NO_rtfCache.find(m_listItems[pItem->iItem].m_lID);\r\n\t\t\tif (iterNoRtf == m_cf_NO_rtfCache.end())\r\n\t\t\t{\r\n\t\t\t\tCF_DibTypeMap::iterator iterRTF = m_cf_rtfCache.find(m_listItems[pItem->iItem].m_lID);\r\n\t\t\t\tif (iterRTF == m_cf_rtfCache.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tbool exists = false;\r\n\t\t\t\t\tfor (std::list<CClipFormatQListCtrl>::iterator it = m_ExtraDataLoadItems.begin(); it != m_ExtraDataLoadItems.end(); it++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (it->m_cfType == theApp.m_RTFFormat && it->m_parentId == m_listItems[pItem->iItem].m_lID)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\texists = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (exists == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCClipFormatQListCtrl format;\r\n\t\t\t\t\t\tformat.m_cfType = theApp.m_RTFFormat;\r\n\t\t\t\t\t\tformat.m_parentId = m_listItems[pItem->iItem].m_lID;\r\n\t\t\t\t\t\tformat.m_clipRow = pItem->iItem;\r\n\t\t\t\t\t\tformat.m_autoDeleteData = true;\r\n\t\t\t\t\t\tformat.m_counter = m_extraDataCounter++;\r\n\t\t\t\t\t\tm_ExtraDataLoadItems.push_back(format);\r\n\r\n\t\t\t\t\t\tm_extraDataThread.FireLoadExtraData(m_lstHeader.GetRowHeight());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (iterRTF->second.m_hgData != NULL)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpItem->lParam = (LPARAM) &(iterRTF->second);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nCString CQPasteWnd::GetDisplayText(int dontAutoDelete, int shortCut, bool isGroup, int parentID, CString text)\r\n{\r\n\tCString cs;\r\n\tif (dontAutoDelete)\r\n\t{\r\n\t\tcs += \"*\";\r\n\t}\r\n\r\n\tif (shortCut > 0)\r\n\t{\r\n\t\tcs += \"s\";\r\n\t}\r\n\r\n\tif (isGroup)\r\n\t{\r\n\t\tcs += \"G\";\r\n\t}\r\n\r\n\t// attached to a group\r\n\tif (parentID > 0)\r\n\t{\r\n\t\tcs += \"!\";\r\n\t}\r\n\r\n\t// pipe is the \"end of symbols\" marker\r\n\tcs += \"|\" + CMainTableFunctions::GetDisplayText(CGetSetOptions::m_nLinesPerRow, text);\r\n\r\n\treturn cs;\r\n}\r\n\r\nvoid CQPasteWnd::OnGetToolTipText(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tCQListToolTipText *pInfo = (CQListToolTipText*)pNMHDR;\r\n\tif (!pInfo)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (pInfo->lItem < 0)\r\n\t{\r\n\t\tCString cs(\"no item selected\");\r\n\r\n\t\tlstrcpyn(pInfo->pszText, cs, pInfo->cchTextMax);\r\n\t\tif (cs.GetLength() > pInfo->cchTextMax)\r\n\t\t{\r\n\t\t\tpInfo->pszText[pInfo->cchTextMax - 1] = 0;\r\n\t\t}\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\ttry\r\n\t{\r\n\t\tCString cs;\r\n\t\tCString clipData = _T(\"\");\r\n\r\n\t\tint id = m_lstHeader.GetItemData(pInfo->lItem);\r\n\t\tCppSQLite3Query q = theApp.m_db.execQueryEx(_T(\"SELECT lID, mText, lDate, lShortCut, clipOrder, clipGroupOrder, stickyClipOrder, stickyClipGroupOrder, lDontAutoDelete, QuickPasteText, lastPasteDate, globalShortCut, lParentID FROM Main WHERE lID = %d\"), id);\r\n\t\tif (q.eof() == false)\r\n\t\t{\r\n\t\t\tCString clipText = q.getStringField(1);\r\n\r\n\t\t\tint lines = 0;\r\n\t\t\tint maxLines = CGetSetOptions::GetMaxToolTipLines();\r\n\t\t\tCTokenizer tokenizer(clipText, \"\\r\\n\");\r\n\t\t\tCString token;\r\n\t\t\twhile (tokenizer.Next(token))\r\n\t\t\t{\r\n\t\t\t\tcs += token + \"\\r\\n\";\r\n\t\t\t\tif (lines > maxLines)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tlines++;\r\n\t\t\t}\r\n\t\t\t\t\t\t\r\n\r\n#ifdef _DEBUG\r\n\t\t\tclipData += StrF(_T(\"(Index = %d) (Seq = %f) (Group Seq = %f) (Sticky Seq = %f) (Sticky Group Seq = %f)\\n\"),\r\n\t\t\t\tpInfo->lItem, \r\n\t\t\t\tq.getFloatField(_T(\"clipOrder\")), q.getFloatField(_T(\"clipGroupOrder\")),\r\n\t\t\t\tq.getFloatField(_T(\"stickyClipOrder\")), q.getFloatField(_T(\"stickyClipGroupOrder\")));\r\n#endif \r\n\r\n\t\t\tclipData += StrF(_T(\"\\r\\nDatabase ID: %d\"), q.getIntField(_T(\"lID\")));\r\n\r\n\t\t\tCOleDateTime time((time_t)q.getIntField(_T(\"lDate\")));\r\n\t\t\tclipData += \"\\r\\nAdded: \" + time.Format();\r\n\r\n\t\t\tCOleDateTime modified((time_t)q.getIntField(_T(\"lastPasteDate\")));\r\n\t\t\tclipData += \"\\r\\nLast Used: \" + modified.Format();\r\n\r\n\t\t\tif (q.getIntField(_T(\"lDontAutoDelete\")) > 0)\r\n\t\t\t{\r\n\t\t\t\tclipData += \"\\r\\nNever Auto Delete\";\r\n\t\t\t}\r\n\r\n\t\t\tCString csQuickPaste = q.getStringField(_T(\"QuickPasteText\"));\r\n\r\n\t\t\tif (csQuickPaste.IsEmpty() == FALSE)\r\n\t\t\t{\r\n\t\t\t\tclipData += \"\\nQuick Paste = \";\r\n\t\t\t\tclipData += csQuickPaste;\r\n\t\t\t}\r\n\r\n\t\t\tint shortCut = q.getIntField(_T(\"lShortCut\"));\r\n\t\t\tif (shortCut > 0)\r\n\t\t\t{\r\n\t\t\t\tclipData += \"\\r\\n\";\r\n\t\t\t\tclipData += CHotKey::GetHotKeyDisplayStatic(shortCut);\r\n\r\n\t\t\t\tBOOL globalShortCut = q.getIntField(_T(\"globalShortCut\"));\r\n\t\t\t\tif (globalShortCut)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += \" - Global Shortcut Key\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (theApp.m_GroupID > 0)\r\n\t\t\t{\r\n\t\t\t\tint sticky = q.getIntField(_T(\"stickyClipGroupOrder\"));\r\n\t\t\t\tif (sticky != INVALID_STICKY)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += \"\\r\\n\";\r\n\t\t\t\t\tclipData += _T(\" - Sticky In Group\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint sticky = q.getIntField(_T(\"stickyClipOrder\"));\r\n\t\t\t\tif (sticky != INVALID_STICKY)\r\n\t\t\t\t{\r\n\t\t\t\t\tclipData += \"\\r\\n\";\r\n\t\t\t\t\tclipData += _T(\" - Sticky\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint parentId = q.getIntField(_T(\"lParentID\"));\r\n\t\t\tif (parentId > 0)\r\n\t\t\t{\r\n\t\t\t\tclipData += \"\\r\\n\";\r\n\t\t\t\tclipData += FolderPath(parentId);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcs = cs.Left(pInfo->cchTextMax - clipData.GetLength());\r\n\r\n\t\tcs += \"\\r\\n\\r\\n\";\r\n\t\tcs += clipData;\r\n\r\n\t\tlstrcpyn(pInfo->pszText, cs, pInfo->cchTextMax);\r\n\t\tpInfo->pszText[pInfo->cchTextMax - 1] = '\\0';\r\n\t}\r\n\tCATCH_SQLITE_EXCEPTION\r\n}\r\n\r\nvoid CQPasteWnd::OnFindItem(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tNMLVFINDITEM *pFindInfo = (NMLVFINDITEM*)pNMHDR;\r\n\tLVFINDINFO fndItem = pFindInfo->lvfi;\r\n\r\n\r\n\tif (fndItem.flags &LVFI_STRING)\r\n\t{\r\n\t\t//m_search.SetWindowText(fndItem.psz);\r\n\t\t//m_search.SetFocus();\r\n\t\t//m_search.SetSel(1, 1);\r\n\r\n\t\t//OnSearchEditChange();\r\n\r\n\t\t//*pResult = m_lstHeader.GetCaret();\r\n\t\t//return;\r\n\t}\r\n\r\n\t*pResult = -1; // Default action.\r\n}\r\n\r\nvoid CQPasteWnd::OnNcLButtonDblClk(UINT nHitTest, CPoint point)\r\n{\r\n\t// toggle ShowPersistent when we double click the caption\r\n\tif (nHitTest == HTCAPTION)\r\n\t{\r\n\t\tswitch (CGetSetOptions::m_bDoubleClickingOnCaptionDoes)\r\n\t\t{\r\n\t\tcase TOGGLES_ALLWAYS_ON_TOP:\r\n\t\t{\r\n\t\t\ttheApp.ShowPersistent(!CGetSetOptions::m_bShowPersistent);\r\n\t\t\tif (CGetSetOptions::m_bShowPersistent)\r\n\t\t\t{\r\n\t\t\t\t::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);\r\n\t\t\t}\r\n\r\n\t\t\tMoveControls();\r\n\r\n\t\t\tUpdateStatus();\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase TOGGLES_ALLWAYS_SHOW_DESCRIPTION:\r\n\t\t\tDoAction(ActionEnums::SHOWDESCRIPTION);\r\n\t\t\tbreak;\r\n\t\tcase ROLLES_UP_WINDOW:\r\n\t\t\tMinMaxWindow();\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tCWndEx::OnNcLButtonDblClk(nHitTest, point);\r\n}\r\n\r\nvoid CQPasteWnd::OnShowGroupsTop()\r\n{\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\tOnShowGroupsBottom();\r\n\treturn;\r\n\tm_GroupTree.m_bHide = false;\r\n\tm_bHideWnd = false;\r\n\r\n\tCRect crList;\r\n\tm_lstHeader.GetWindowRect(crList);\r\n\r\n\tCRect cr(crList.left, crList.top, crList.left + crList.Width(), crList.top + 200);\r\n\r\n\tm_GroupTree.MoveWindow(cr);\r\n\tm_GroupTree.m_selectedFolderID = theApp.m_GroupID;\r\n\tm_GroupTree.FillTree();\r\n\tm_GroupTree.ShowWindow(SW_SHOW);\r\n\r\n\r\n\tm_GroupTree.m_bHide = true;\r\n\tm_bHideWnd = true;\r\n}\r\n\r\nvoid CQPasteWnd::OnShowGroupsBottom()\r\n{\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\tif (m_GroupTree.IsWindowVisible())\r\n\t{\r\n\t\tm_GroupTree.ShowWindow(SW_HIDE);\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_GroupTree.m_bHide = false;\r\n\tm_bHideWnd = false;\r\n\r\n\tCRect crWindow, crList;\r\n\tm_lstHeader.GetWindowRect(crList);\r\n\tGetWindowRect(crWindow);\r\n\r\n\tCRect cr(crWindow.left, crWindow.bottom, crWindow.left + crWindow.Width(), crWindow.bottom + 200);\r\n\r\n\tEnsureWindowVisible(&cr);\r\n\r\n\tm_GroupTree.MoveWindow(cr);\r\n\tm_GroupTree.m_selectedFolderID = theApp.m_GroupID;\r\n\tm_GroupTree.FillTree();\r\n\tm_GroupTree.ShowWindow(SW_SHOW);\r\n\r\n\tm_GroupTree.m_bHide = true;\r\n\tm_bHideWnd = true;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnGroupTreeMessage(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_bHideWnd = false;\r\n\r\n\tint id = (int)wParam;\r\n\r\n\tm_GroupTree.ShowWindow(SW_HIDE);\r\n\r\n\tm_bHandleSearchTextChange = false;\r\n\tm_search.SetWindowText(_T(\"\"));\r\n\tm_bHandleSearchTextChange = true;\r\n\r\n\tMoveControls();\r\n\r\n\tif (id == -1)\r\n\t{\r\n\t\t//go back to the main list\r\n\t\ttheApp.EnterGroupID(-1);\r\n\t}\r\n\telse if (id >= 0)\r\n\t{\r\n\t\t//Set the app flag so it does a send message to refresh the list\r\n\t\t//We need to do this because we set the list pos to 0 and with Post\r\n\t\t//the list is not filled up yet\r\n\t\tbool bItWas = theApp.m_bAsynchronousRefreshView;\r\n\t\ttheApp.m_bAsynchronousRefreshView = false;\r\n\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tOpenID(id, pasteOptions);\r\n\r\n\t\ttheApp.m_bAsynchronousRefreshView = bItWas;\r\n\r\n\t\tm_lstHeader.SetListPos(0);\r\n\t\tm_lstHeader.SetFocus();\r\n\t}\r\n\r\n\tCWnd *p = GetFocus();\r\n\tif (p == NULL)\r\n\t{\r\n\t\tHideQPasteWindow(false);\r\n\t}\r\n\r\n\tm_bHideWnd = true;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::OnBackButton()\r\n{\r\n\ttheApp.EnterGroupID(theApp.m_GroupParentID);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSearchDescription()\r\n{\r\n\tCGetSetOptions::SetSearchDescription(!CGetSetOptions::GetSearchDescription());\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tif (csText != _T(\"\"))\r\n\t{\r\n\t\tFillList(csText);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSearchFullText()\r\n{\r\n\tCGetSetOptions::SetSearchFullText(!CGetSetOptions::GetSearchFullText());\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tif (csText != _T(\"\"))\r\n\t{\r\n\t\tFillList(csText);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSearchQuickPaste()\r\n{\r\n\tCGetSetOptions::SetSearchQuickPaste(!CGetSetOptions::GetSearchQuickPaste());\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tif (csText != _T(\"\"))\r\n\t{\r\n\t\tFillList(csText);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnSearchEditChange()\r\n{\r\n\tm_search.Invalidate();\r\n\tif (CGetSetOptions::m_bFindAsYouType == FALSE)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (m_bHandleSearchTextChange == false)\r\n\t{\r\n\t\t//Log(_T(\"Handle text change is NOT set\"));\r\n\t\treturn;\r\n\t}\r\n\r\n\tKillTimer(TIMER_DO_SEARCH);\r\n\tSetTimer(TIMER_DO_SEARCH, 250, NULL);\r\n\r\n\treturn;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnUpDown(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tMSG msg;\r\n\t//Workaround for allow holding down arrow keys while in the search control\r\n\tmsg.lParam = lParam & (~0x40000000);\r\n\tmsg.wParam = wParam;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t\tif (m_lstHeader.HandleKeyDown(wParam, lParam) == FALSE)\r\n\t\t{\r\n\t\t\tLRESULT res = m_lstHeader.SendMessage(WM_KEYDOWN, wParam, lParam);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnToolTipWndInactive(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (!CGetSetOptions::m_bShowPersistent)\r\n\t{\r\n\t\tCWnd *p = GetFocus();\r\n\t\tif (p == NULL)\r\n\t\t{\r\n\t\t\tHideQPasteWindow(false);\r\n\t\t\tm_lstHeader.HidePopup(true);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCWnd *p = GetFocus();\r\n\t\tif (p == NULL)\r\n\t\t{\r\n\t\t\tm_lstHeader.HidePopup(true);\r\n\t\t}\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuNewgroup(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::NEWGROUP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuNewgroupselection(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::NEWGROUPSELECTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuAllwaysontop(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TOGGLESHOWPERSISTANT);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuViewfulldescription(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SHOWDESCRIPTION);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuViewgroups(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SHOWGROUPS);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuPasteplaintextonly(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_SELECTED_PLAIN_TEXT);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuDelete(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::DELETE_SELECTED);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuProperties(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::CLIP_PROPERTIES);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuEdititem(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EDITCLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuNewclip(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::NEWCLIP);\r\n}\r\n\r\nLRESULT CQPasteWnd::OnSetListCount(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_noSearchResults = false;\r\n\r\n\tint x = m_lstHeader.GetScrollPos(SB_HORZ);\r\n\tint y = m_lstHeader.GetScrollPos(SB_VERT);\r\n\tm_lstHeader.Scroll(CSize(-x, -y));\r\n\r\n\tm_lstHeader.SetItemCountEx((int)wParam);\r\n\r\n\tif ((int)wParam == 0 &&\r\n\t\tm_strSearch != _T(\"\"))\r\n\t{\r\n\t\tm_noSearchResults = true;\r\n\t\tCString text = theApp.m_Language.GetString(\"NoSearchResults\", \"There are no results for\");\r\n\t\tm_noSearchResultsStatic.SetWindowText(StrF(_T(\"%s \\\"%s\\\"\"), text, m_strSearch));\r\n\t}\r\n\r\n\tSelectFocusID();\r\n\tUpdateStatus(false);\r\n\r\n\tMoveControls();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnItemDeleted(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_lstHeader.OnItemDeleted((int)wParam);\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnRefeshRow(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tint clipId = (int)wParam;\r\n\tint listPos = (int)lParam;\r\n\r\n\tint topIndex = m_lstHeader.GetTopIndex();\r\n\tint lastIndex = topIndex + m_lstHeader.GetCountPerPage();\r\n\r\n\tif (listPos >= topIndex && listPos <= lastIndex)\r\n\t{\r\n\t\tm_lstHeader.RefreshRow(listPos);\r\n\t\tm_lstHeader.PostEventLoadedCheckDescription(listPos);\r\n\t}\r\n\r\n\tif (clipId == -2)\r\n\t{\r\n\t\tm_lstHeader.Invalidate();\r\n\t\tm_lstHeader.RedrawWindow();\r\n\r\n\t\t//Log(_T(\"End of first load, showing listbox and loading actual count, then accelerators\"));\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CQPasteWnd::SelectFocusID()\r\n{\r\n\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\tbool selectedItem = false;\r\n\tint index = 0;\r\n\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\twhile (iter != m_listItems.end())\r\n\t{\r\n\t\tif (iter->m_lID == theApp.m_FocusID)\r\n\t\t{\r\n\t\t\tm_lstHeader.SetListPos(index);\r\n\t\t\tselectedItem = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\titer++;\r\n\t\tindex++;\r\n\t}\r\n\r\n\tif (selectedItem == false)\r\n\t{\r\n\t\tm_lstHeader.EnsureVisible(0, FALSE);\r\n\t\tm_lstHeader.SetListPos(CGetSetOptions::SelectedIndex());\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::FillMainTable(CMainTable &table, CppSQLite3Query &q)\r\n{\r\n\ttable.m_lID = q.getIntField(_T(\"lID\"));\r\n\ttable.m_Desc = q.fieldValue(_T(\"mText\"));\r\n\ttable.m_bHasParent = q.getIntField(_T(\"lParentID\")) >= 0;\r\n\ttable.m_bDontAutoDelete = q.getIntField(_T(\"lDontAutoDelete\")) > 0;\r\n\ttable.m_bHasShortCut = q.getIntField(_T(\"lShortCut\")) > 0;\r\n\ttable.m_bIsGroup = q.getIntField(_T(\"bIsGroup\")) > 0;\r\n\ttable.m_QuickPaste = q.fieldValue(_T(\"QuickPasteText\"));\r\n\ttable.m_clipOrder = q.getFloatField(_T(\"clipOrder\"));\r\n\ttable.m_clipGroupOrder = q.getFloatField(_T(\"clipGroupOrder\"));\r\n\ttable.m_stickyClipOrder = q.getFloatField(_T(\"stickyClipOrder\"));\r\n\ttable.m_stickyClipGroupOrder = q.getFloatField(_T(\"stickyClipGroupOrder\"));\r\n\ttable.m_dateCopied = q.getIntField(_T(\"lDate\"));\r\n\ttable.m_datePasted = q.getIntField(_T(\"lastPasteDate\"));\r\n}\r\n\r\nvoid CQPasteWnd::OnDestroy()\r\n{\r\n\tCGetSetOptions::SetPastSearchXml(m_search.SavePastSearches());\r\n\r\n\tCWndEx::OnDestroy();\r\n\tm_thread.Stop();\r\n\tm_extraDataThread.Stop();\r\n}\r\n\r\nvoid CQPasteWnd::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\tif (nIDEvent == TIMER_DO_SEARCH)\r\n\t{\r\n\t\tLog(_T(\"TIMER_DO_SEARCH timer\\n\"));\r\n\r\n\t\tKillTimer(TIMER_DO_SEARCH);\r\n\r\n\t\tCString csText;\r\n\t\tm_search.GetWindowText(csText);\r\n\r\n\t\tint nCaretPos = m_lstHeader.GetCaret();\r\n\t\tif (nCaretPos >= 0)\r\n\t\t{\r\n\t\t\ttheApp.m_FocusID = m_lstHeader.GetItemData(nCaretPos);\r\n\t\t}\r\n\r\n\t\tFillList(csText);\r\n\t}\r\n\tif (nIDEvent == TIMER_PASTE_FROM_MODIFER)\r\n\t{\r\n\t\tLog(_T(\"TIMER_PASTE_FROM_MODIFER timer\\n\"));\r\n\t\tKillTimer(TIMER_PASTE_FROM_MODIFER);\r\n\t\tif (m_bModifersMoveActive)\r\n\t\t{\r\n\t\t\tLog(_T(\"Open Selection\\n\"));\r\n\t\t\tCSpecialPasteOptions pasteOptions;\r\n\t\t\tOpenSelection(pasteOptions);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLog(_T(\"m_bModifersMoveActive set to false\\n\"));\r\n\t\t}\r\n\t}\r\n\telse if (nIDEvent == TIMER_ERROR_MSG)\r\n\t{\r\n\t\tKillTimer(TIMER_ERROR_MSG);\r\n\t\tm_popupMsg.Hide();\r\n\t}\r\n\telse if (nIDEvent == TIMER_DRAG_HIDE_WINDOW)\r\n\t{\r\n\t\tOutputDebugString(_T(\"drag timer\\n\"));\r\n\r\n\t\tCPoint mouse;\r\n\t\tGetCursorPos(&mouse);\r\n\r\n\t\tCRect windowRect;\r\n\t\tthis->GetWindowRect(&windowRect);\r\n\r\n\t\tif (PtInRect(&windowRect, mouse) == FALSE)\r\n\t\t{\r\n\t\t\tHideQPasteWindow(false, false);\r\n\t\t\tKillTimer(TIMER_DRAG_HIDE_WINDOW);\r\n\t\t}\r\n\t}\r\n\telse if (nIDEvent == TIMER_DO_ACTION)\r\n\t{\r\n\t\tKillTimer(TIMER_DO_ACTION);\r\n\r\n\t\tOutputDebugString(StrF(_T(\"DoActionTimer, cmd: %d\"), m_timerAction.Cmd));\r\n\r\n\t\tif (m_timerAction.Cmd > 0)\r\n\t\t{\r\n\t\t\tDoAction(m_timerAction);\r\n\t\t}\r\n\t\tm_timerAction = CAccel();\r\n\t}\r\n\r\n\tCWndEx::OnTimer(nIDEvent);\r\n}\r\n\r\nvoid CQPasteWnd::OnAddinSelect(UINT idIn)\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tif (IDs.GetCount() > 0)\r\n\t{\r\n\t\tint id = IDs[0];\r\n\t\tCClip clip;\r\n\t\tif (clip.LoadMainTable(id))\r\n\t\t{\r\n\t\t\tif (clip.LoadFormats(id, false))\r\n\t\t\t{\r\n\t\t\t\tbool bCont = theApp.m_Addins.CallPrePasteFunction(idIn, &clip);\r\n\t\t\t\tif (bCont)\r\n\t\t\t\t{\r\n\t\t\t\t\tCSpecialPasteOptions pasteOptions;\r\n\t\t\t\t\tpasteOptions.m_pPasteFormats = &clip.m_Formats;\r\n\t\t\t\t\tOpenID(-1, pasteOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nLRESULT CQPasteWnd::OnSelectAll(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tBOOL ret = FALSE;\r\n\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\r\n\tif ((int)m_listItems.size() < m_lstHeader.GetItemCount())\r\n\t{\r\n\t\tLog(_T(\"All items selected loading all items from the db\"));\r\n\r\n\t\tCPoint loadItem(0, m_lstHeader.GetItemCount());\r\n\t\tm_loadItems.push_back(loadItem);\r\n\r\n\t\tm_thread.FireLoadItems(false);\r\n\r\n\t\tret = TRUE;\r\n\r\n\t\tUpdateStatus(false);\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnShowHideScrollBar(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (wParam == 1)\r\n\t{\r\n\t\tLog(_T(\"OnShowHideScrollBar Showing ScrollBars\"));\r\n\r\n\t\tm_showScrollBars = true;\r\n\r\n\t\tMoveControls();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLog(_T(\"OnShowHideScrollBar Hiding ScrollBars\"));\r\n\r\n\t\tm_showScrollBars = false;\r\n\t\tMoveControls();\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\n//HBRUSH CQPasteWnd::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\r\n//{\r\n//\t// Call the base class implementation first! Otherwise, it may \r\n//\t// undo what we're trying to accomplish here.\r\n//\tHBRUSH hbr = CWnd::OnCtlColor(pDC, pWnd, nCtlColor);\r\n//\r\n//\tswitch (nCtlColor) \r\n//\t{\r\n//\tcase CTLCOLOR_STATIC:\r\n//\t\tswitch (pWnd->GetDlgCtrlID())\r\n//\t\t{\r\n//\t\t\tcase ON_TOP_WARNING:\r\n//\t\t\t{\r\n//\t\t\t\tpDC->SetBkMode(TRANSPARENT);\r\n//\t\t\t\tpDC->SetBkColor(RGB(0, 0, 255));\r\n//\r\n//\t\t\t\tCBrush brush;\r\n//\t\t\t\tbrush.CreateSolidBrush(COLORREF(RGB(255, 0, 0)));\r\n//\t\t\t\treturn brush;\r\n//\t\t\t}\r\n//\t\t\tbreak;\r\n//\t\t}\r\n//\t}\r\n//\r\n//\treturn hbr;\r\n//}\r\n\r\n//void CQPasteWnd::OnPaint()\r\n//{\r\n//\t/*CBrush brush;\r\n//\tbrush.CreateSolidBrush(COLORREF(RGB(255, 0, 0)));\r\n//\r\n//\tCRect clientRect;\r\n//\tGetClientRect(clientRect);\r\n//\r\n//\tCPaintDC dc(this);\r\n//\tdc.FillRect(clientRect, &brush);*/\r\n//\r\n//\t\r\n//\t\tCQPasteWnd::OnPaint();\r\n//\t\r\n//}\r\n\r\nBOOL CQPasteWnd::OnEraseBkgnd(CDC* pDC)\r\n{\r\n\tCRect rect;\r\n\tGetClientRect(&rect);\r\n\tCBrush myBrush(CGetSetOptions::m_Theme.MainWindowBG());    // dialog background color\r\n\tCBrush *pOld = pDC->SelectObject(&myBrush);\r\n\tBOOL bRes = pDC->PatBlt(0, 0, rect.Width(), rect.Height(), PATCOPY);\r\n\tpDC->SelectObject(pOld);    // restore old brush\r\n\treturn bRes;                       // CDialog::OnEraseBkgnd(pDC);\r\n\r\n\t//return TRUE;\r\n\t// TODO: Add your message handler code here and/or call default\r\n\r\n\t//return CWndEx::OnEraseBkgnd(pDC);\r\n}\r\n\r\nvoid CQPasteWnd::OnQuickoptionsShowintaskbar()\r\n{\r\n\tDoAction(ActionEnums::SHOW_IN_TASKBAR);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnMenuViewasqrcode()\r\n{\r\n\tDoAction(ActionEnums::EXPORT_TO_QR_CODE);\r\n}\r\n\r\nvoid CQPasteWnd::OnExportExporttotextfile()\r\n{\r\n\tDoAction(ActionEnums::EXPORT_TO_TEXT_FILE);\r\n}\r\n\r\nvoid CQPasteWnd::OnCompareCompare()\r\n{\r\n\tDoAction(ActionEnums::COMPARE_SELECTED_CLIPS);\r\n}\r\n\r\nvoid CQPasteWnd::OnCompareSelectleftcompare()\r\n{\r\n\tDoAction(ActionEnums::SELECT_LEFT_SIDE_COMPARE);\r\n}\r\n\r\nvoid CQPasteWnd::OnCompareCompareagainst()\r\n{\r\n\tDoAction(ActionEnums::SELECT_RIGHT_SITE_AND_DO_COMPARE);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateCompareCompare(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::COMPARE_SELECTED_CLIPS);\r\n}\r\n\r\nvoid CQPasteWnd::UpdateMenuShortCut(CCmdUI *pCmdUI, DWORD action)\r\n{\r\n\tif (pCmdUI == NULL ||\r\n\t\tpCmdUI->m_pMenu == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tCString cs;\r\n\tpCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, cs, MF_BYCOMMAND);\r\n\tCString shortcutText = m_actions.GetCmdKeyText(action);\r\n\tif (shortcutText != _T(\"\") &&\r\n\t\tcs.Find(\"\\t\" + shortcutText) < 0)\r\n\t{\r\n\t\tcs += \"\\t\";\r\n\t\tcs += shortcutText;\r\n\t\tpCmdUI->SetText(cs);\r\n\t}\r\n}\r\n\r\nLRESULT CQPasteWnd::OnShowProperties(WPARAM wParam, LPARAM lParam)\r\n{\r\n\treturn ShowProperties((int)wParam, -1);\r\n}\r\n\r\nLRESULT CQPasteWnd::OnNewGroup(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tNewGroup(false, (int)wParam);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nLRESULT CQPasteWnd::OnDeleteId(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (CGetSetOptions::GetPromptWhenDeletingClips())\r\n\t{\r\n\t\tbool bStartValue = m_bHideWnd;\r\n\t\tm_bHideWnd = false;\r\n\r\n\t\tint nRet = MessageBox(theApp.m_Language.GetString(\"Delete_Clip_Groups\", \"Delete Group?\"), _T(\"Ditto\"), MB_OKCANCEL | MB_TOPMOST);\r\n\r\n\t\tm_bHideWnd = bStartValue;\r\n\r\n\t\tif (nRet != IDOK)\r\n\t\t{\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\tCClipIDs IDs;\r\n\tARRAY Indexs;\r\n\r\n\tIDs.Add((int)wParam);\r\n\r\n\tbool selectedItem = false;\r\n\tint index = 0;\r\n\t{\r\n\t\tATL::CCritSecLock csLock(m_CritSection.m_sect);\r\n\t\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\t\twhile (iter != m_listItems.end())\r\n\t\t{\r\n\t\t\tif (iter->m_lID == wParam)\r\n\t\t\t{\r\n\t\t\t\tIndexs.Add(index);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\titer++;\r\n\t\t\tindex++;\r\n\t\t}\r\n\t}\r\n\r\n\tDeleteClips(IDs, Indexs);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSimpleTextSearch()\r\n{\r\n\tCGetSetOptions::SetSimpleTextSearch(!CGetSetOptions::GetSimpleTextSearch());\r\n\tCGetSetOptions::SetRegExTextSearch(FALSE);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuRegularexpressionsearch()\r\n{\r\n\tCGetSetOptions::SetSimpleTextSearch(FALSE);\r\n\tCGetSetOptions::SetRegExTextSearch(!CGetSetOptions::GetRegExTextSearch());\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportExporttogoogletranslate()\r\n{\r\n\tDoAction(ActionEnums::EXPORT_TO_GOOGLE_TRANSLATE);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateImportExporttogoogletranslate(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EXPORT_TO_GOOGLE_TRANSLATE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportExportclipBitmap()\r\n{\r\n\tDoAction(ActionEnums::EXPORT_TO_BITMAP_FILE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateImportExportclipBitmap(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EXPORT_TO_BITMAP_FILE);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuWildcardsearch()\r\n{\r\n\tCGetSetOptions::SetSimpleTextSearch(FALSE);\r\n\tCGetSetOptions::SetRegExTextSearch(FALSE);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuSavecurrentclipboard()\r\n{\r\n\tDoAction(ActionEnums::SAVE_CURRENT_CLIPBOARD);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateMenuSavecurrentclipboard(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SAVE_CURRENT_CLIPBOARD);\r\n}\r\n\r\n\r\nbool CQPasteWnd::SyncClipDataToArrayData(CClip &clip)\r\n{\r\n\tint row = 0;\r\n\tbool found = false;\r\n\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\twhile (iter != m_listItems.end())\r\n\t{\r\n\t\tif (iter->m_lID == clip.ID())\r\n\t\t{\r\n\t\t\titer->m_clipOrder = clip.m_clipOrder;\r\n\t\t\titer->m_clipGroupOrder = clip.m_clipGroupOrder;\r\n\r\n\t\t\titer->m_stickyClipOrder = clip.m_stickyClipOrder;\r\n\t\t\titer->m_stickyClipGroupOrder = clip.m_stickyClipGroupOrder;\r\n\r\n\t\t\tfound = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\titer++;\r\n\t\trow++;\r\n\t}\r\n\r\n\treturn found;\r\n}\r\n\r\nbool CQPasteWnd::SelectIds(ARRAY &ids)\r\n{\r\n\tint row = 0;\r\n\tbool found = false;\r\n\tstd::vector<CMainTable>::iterator iter = m_listItems.begin();\r\n\r\n\t//sort so .Find works\r\n\tids.SortAscending();\r\n\r\n\twhile (iter != m_listItems.end())\r\n\t{\r\n\t\tif (ids.Find(iter->m_lID))\r\n\t\t{\r\n\t\t\tif (found == false)\r\n\t\t\t{\r\n\t\t\t\tm_lstHeader.SetListPos(row);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_lstHeader.SetSelection(row);\r\n\t\t\t}\r\n\r\n\t\t\tfound = true;\r\n\t\t}\r\n\t\titer++;\r\n\t\trow++;\r\n\t}\r\n\r\n\treturn found;\r\n}\r\n\r\nvoid CQPasteWnd::OnCliporderMoveup()\r\n{\r\n\tDoAction(ActionEnums::MOVE_CLIP_UP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateCliporderMoveup(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MOVE_CLIP_UP);\r\n}\r\n\r\nvoid CQPasteWnd::OnCliporderMovedown()\r\n{\r\n\tDoAction(ActionEnums::MOVE_CLIP_DOWN);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateCliporderMovedown(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MOVE_CLIP_DOWN);\r\n}\r\n\r\nvoid CQPasteWnd::OnCliporderMovetotop()\r\n{\r\n\tDoAction(ActionEnums::MOVE_CLIP_TOP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateCliporderMovetotop(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MOVE_CLIP_TOP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuFilteron()\r\n{\r\n\tDoAction(ActionEnums::FILTER_ON_SELECTED_CLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuFilteron(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::FILTER_ON_SELECTED_CLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnAlwaysOnTopClicked()\r\n{\r\n\tDoAction(ActionEnums::TOGGLESHOWPERSISTANT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteUppercase()\r\n{\r\n\tDoAction(ActionEnums::PASTE_UPPER_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteUppercase(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_UPPER_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteLowercase()\r\n{\r\n\tDoAction(ActionEnums::PASTE_LOWER_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteLowercase(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_LOWER_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteCapitalize()\r\n{\r\n\tDoAction(ActionEnums::PASTE_CAPITALiZE);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteCapitalize(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_CAPITALiZE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteSentence()\r\n{\r\n\tDoAction(ActionEnums::PASTE_SENTENCE_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteSentence(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_SENTENCE_CASE);\r\n}\r\n\r\nvoid CQPasteWnd::OnSystemButton()\r\n{\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\tPOINT pp;\r\n\tCMenu cmPopUp;\r\n\tCMenu *cmSubMenu = NULL;\r\n\r\n\tGetCursorPos(&pp);\r\n\tif (cmPopUp.LoadMenu(IDR_QUICK_PASTE_SYSTEM_MENU) != 0)\r\n\t{\r\n\t\tcmSubMenu = cmPopUp.GetSubMenu(0);\r\n\t\tif (!cmSubMenu)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (CGetSetOptions::GetShowStartupMessage())\r\n\t\t{\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_SHOWSTARTUPMESSAGE, MF_CHECKED);\r\n\t\t}\r\n\r\n\t\ttheApp.m_Language.UpdateRightClickMenu(cmSubMenu);\r\n\r\n\t\tSetMenuChecks(cmSubMenu);\r\n\r\n\t\tcmSubMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, pp.x, pp.y, this, NULL);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnSpecialpasteRemovelinefeeds()\r\n{\r\n\tDoAction(ActionEnums::PASTE_REMOVE_LINE_FEEDS);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteRemovelinefeeds(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_REMOVE_LINE_FEEDS);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpastePaste()\r\n{\r\n\tDoAction(ActionEnums::PASTE_ADD_ONE_LINE_FEED);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpastePaste(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_ADD_ONE_LINE_FEED);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpastePaste32919()\r\n{\r\n\tDoAction(ActionEnums::PASTE_ADD_TWO_LINE_FEEDS);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpastePaste32919(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_ADD_TWO_LINE_FEEDS);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteTypoglycemia()\r\n{\r\n\tDoAction(ActionEnums::PASTE_TYPOGLYCEMIA);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteTypoglycemia(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_TYPOGLYCEMIA);\r\n}\r\n\r\nvoid CQPasteWnd::OnNMClickList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\tif (csText == _T(\"crash\"))\r\n\t{\r\n\t\tif (CONTROL_PRESSED)\r\n\t\t{\r\n\t\t\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t\t\t{\r\n\t\t\t\traise(SIGSEGV);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tLPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\r\n\tMSG msg;\r\n\tmsg.lParam = 0;\r\n\tmsg.wParam = VK_MOUSE_CLICK;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t}\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnNMDblclkList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\r\n\r\n\tMSG msg;\r\n\tmsg.lParam = 0;\r\n\tmsg.wParam = VK_MOUSE_DOUBLE_CLICK;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnNMRClickList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\r\n\tMSG msg;\r\n\tmsg.lParam = 0;\r\n\tmsg.wParam = VK_MOUSE_RIGHT_CLICK;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t}\r\n\t*pResult = 0;\r\n}\r\n\r\nvoid CQPasteWnd::OnNMRDblclkList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\r\n\t/*MSG msg;\r\n\tmsg.lParam = 0;\r\n\tmsg.wParam = VK_MOUSE_RIGHT_CLICK;\r\n\tmsg.message = WM_KEYDOWN;\r\n\tif (CheckActions(&msg) == false)\r\n\t{\r\n\t}*/\r\n\t*pResult = 0;\r\n}\r\n\r\nvoid CQPasteWnd::OnQuickoptionsShowtextforfirsttencopyhotkeys()\r\n{\r\n\tDoAction(ActionEnums::CONFIG_SHOW_FIRST_TEN_TEXT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateQuickoptionsShowtextforfirsttencopyhotkeys(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::CONFIG_SHOW_FIRST_TEN_TEXT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnQuickoptionsShowindicatoracliphasbeenpasted()\r\n{\r\n\tDoAction(ActionEnums::CONFIG_SHOW_CLIP_WAS_PASTED);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateQuickoptionsShowindicatoracliphasbeenpasted(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::CONFIG_SHOW_CLIP_WAS_PASTED);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnGroupsTogglelastgroup()\r\n{\r\n\tDoAction(ActionEnums::TOGGLE_LAST_GROUP_TOGGLE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateGroupsTogglelastgroup(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TOGGLE_LAST_GROUP_TOGGLE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpastePaste32927()\r\n{\r\n\tDoAction(ActionEnums::PASTE_ADD_CURRENT_TIME);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpastePaste32927(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_ADD_CURRENT_TIME);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnMenuGlobalhotkeys32933()\r\n{\r\n\tDoAction(ActionEnums::GLOBAl_HOTKEYS);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuGlobalhotkeys32933(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::GLOBAl_HOTKEYS);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnMenuDeleteclipdata32934()\r\n{\r\n\tDoAction(ActionEnums::DELETE_CLIP_DATA);\r\n}\r\n\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateMenuDeleteclipdata32934(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::DELETE_CLIP_DATA);\r\n}\r\n\r\n\r\n\r\nvoid CQPasteWnd::OnMenuImportclip32935()\r\n{\r\n\tDoAction(ActionEnums::IMPORT_CLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuImportclip32935(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::IMPORT_CLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuNewclip32937()\r\n{\r\n\tDoAction(ActionEnums::NEWCLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuNewclip32937(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::NEWCLIP);\r\n}\r\n\r\nLRESULT CQPasteWnd::OnSearchFocused(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_lstHeader.HidePopup(true);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n#include <ShellScalingApi.h>\r\n\r\n\r\nLRESULT CQPasteWnd::OnDpiChanged(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tARRAY Indexs;\r\n\tm_lstHeader.GetSelectionIndexes(Indexs);\r\n\tif (Indexs.GetCount() <= 0)\r\n\t{\r\n\t\tIndexs.Add(0);\r\n\t}\r\n\tint c = m_lstHeader.GetItemCount();\r\n\tm_lstHeader.SetItemCountEx(0);\r\n\r\n\tint dpi = HIWORD(wParam);\r\n\tm_DittoWindow.OnDpiChanged(this, dpi);\r\n\r\n\t//RECT* const prcNewWindow = (RECT*)lParam;\r\n\tCRect r(*(RECT*)lParam);\r\n\tif (CGetSetOptions::m_bEnsureEntireWindowCanBeSeen)\r\n\t{\r\n\t\tEnsureWindowVisible(&r);\r\n\t}\r\n\r\n\tSetWindowPos(NULL, r.left, r.top, r.Width(), r.Height(), SWP_NOZORDER | SWP_NOACTIVATE);\r\n\r\n\tlog(StrF(_T(\"CQPasteWnd::OnDpiChanged dpi: %d width: %d, height: %d\"), dpi, r.Width(), r.Height()));\r\n\r\n\tm_systemMenu.Reset();\r\n\tm_systemMenu.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), system_menu_2_24, system_menu_2_30, system_menu_2_36, system_menu_2_42, system_menu_2_48, _T(\"PNG\"), system_menu_54, system_menu_60, system_menu_66, system_menu_72, system_menu_78, system_menu_84);\r\n\r\n\tm_BackButton.Reset();\r\n\tm_BackButton.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), return_16, return_20, return_24, return_28, return_32, _T(\"PNG\"));\r\n\r\n\tm_ShowGroupsFolderBottom.Reset();\r\n\tm_ShowGroupsFolderBottom.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), open_folder_24, open_folder_30, open_folder_36, open_folder_42, open_folder_48, _T(\"PNG\"), open_folder_54, open_folder_60, open_folder_66, open_folder_72, open_folder_78, open_folder_84);\r\n\r\n\tm_search.OnDpiChanged();\r\n\tm_lstHeader.OnDpiChanged();\r\n\r\n\tUpdateFont();\r\n\tthis->SetLinesPerRow(CGetSetOptions::GetLinesPerRow(), true, false);\r\n\r\n\tMoveControls();\r\n\r\n\tm_lstHeader.SetItemCountEx(c);\r\n\tm_lstHeader.SetListPos(Indexs[0]);\r\n\r\n\tInvalidateNc();\r\n\tthis->Invalidate();\r\n\tm_lstHeader.RefreshVisibleRows();\r\n\tthis->RedrawWindow();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::OnCliporderReplacetopstickyclip()\r\n{\r\n\tDoAction(ActionEnums::REPLACE_TOP_STICKY_CLIP);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateCliporderReplacetopstickyclip(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::REPLACE_TOP_STICKY_CLIP);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSendtoPromptforname()\r\n{\r\n\tDoAction(ActionEnums::PROMPT_SEND_TO_FRIEND);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSendtoPromptforname(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PROMPT_SEND_TO_FRIEND);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportImportcopiedfile()\r\n{\r\n\tDoAction(ActionEnums::SAVE_CF_HDROP_FIlE_DATA);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateImportImportcopiedfile(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SAVE_CF_HDROP_FIlE_DATA);\r\n}\r\n\r\nvoid CQPasteWnd::OnCustomSendToFriend(UINT idIn)\r\n{\r\n\tbool showDlg = false;\r\n\tCString ip_name = m_customFriendsHelper.GetSendTo(idIn, showDlg);\r\n\tif (showDlg)\r\n\t{\r\n\t\tDoAction(ActionEnums::PROMPT_SEND_TO_FRIEND);\r\n\t}\r\n\telse if (ip_name != _T(\"\"))\r\n\t{\r\n\t\tSendToFriendbyPos(0, ip_name);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnChaiScriptPaste(UINT idIn)\r\n{\r\n\tCSpecialPasteOptions pasteOptions;\r\n\tint index = idIn - ChaiScriptMenuStartId;\r\n\r\n\tif (index >= 0 &&\r\n\t\tindex < CGetSetOptions::m_pasteScripts.m_list.size())\r\n\t{\r\n\t\tpasteOptions.m_pasteScriptGuid = CGetSetOptions::m_pasteScripts.m_list[index].m_guid;\r\n\t\tOpenSelection(pasteOptions);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnCliporderMovetolast()\r\n{\r\n\tDoAction(ActionEnums::MOVE_CLIP_LAST);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateCliporderMovetolast(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::MOVE_CLIP_LAST);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpastePasteDontUpdateOrder()\r\n{\r\n\tDoAction(ActionEnums::PASTE_DONT_MOVE_CLIP);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateOnSpecialPasteDontUpdateOrder(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_DONT_MOVE_CLIP);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteTrim()\r\n{\r\n\tDoAction(ActionEnums::PASTE_TRIM_WHITE_SPACE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteTrim(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_TRIM_WHITE_SPACE);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparencyNone()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_NONE);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparencyNone(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_NONE);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency5()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_5);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency5(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_5);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency10()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_10);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency10(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_10);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency15()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_15);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency15(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_15);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency20()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_20);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency20(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_20);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency25()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_25);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency25(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_25);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency30()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_30);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency30(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_30);\r\n}\r\n\r\nvoid CQPasteWnd::OnTransparency35()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_35);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency35(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_35);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuTransparency40()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_40);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateTransparency40(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_40);\r\n}\r\n\r\nbool CQPasteWnd::DoActionToggleTransparency()\r\n{\r\n\tCGetSetOptions::SetEnableTransparency(!CGetSetOptions::GetEnableTransparency());\r\n\tSetCurrentTransparency();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionIncreaseTransparency()\r\n{\r\n\tint current = CGetSetOptions::GetTransparencyPercent();\r\n\tcurrent += 5;\r\n\tcurrent = min(current, 100);\r\n\tSetTransparency(current);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionDecreaseTransparency()\r\n{\r\n\tint current = CGetSetOptions::GetTransparencyPercent();\r\n\tcurrent -= 5;\r\n\tcurrent = max(current, 0);\r\n\tSetTransparency(current);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionEmailTo()\r\n{\r\n\tCWaitCursor wait;\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tCClip clip;\r\n\r\n\tif (IDs.GetCount() > 1)\r\n\t{\r\n\t\tCStringA SepA = CTextConvert::UnicodeToAnsi(CGetSetOptions::GetMultiPasteSeparator());\r\n\t\tCStringW SepW = CGetSetOptions::GetMultiPasteSeparator();\r\n\r\n\t\tCHTMLFormatAggregator Html(SepA);\r\n\t\tif (IDs.AggregateData(Html, theApp.m_HTML_Format, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\tCClipFormat cf(theApp.m_HTML_Format, Html.GetHGlobal());\r\n\t\t\tclip.m_Formats.Add(cf);\r\n\t\t\t//clip.m_Formats now owns the global data\r\n\t\t\tcf.m_autoDeleteData = false;\r\n\t\t}\r\n\r\n\t\tCCF_UnicodeTextAggregator CFUnicodeText(SepW);\r\n\t\tif (IDs.AggregateData(CFUnicodeText, CF_UNICODETEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\tCClipFormat cf(CF_UNICODETEXT, CFUnicodeText.GetHGlobal());\r\n\t\t\tclip.m_Formats.Add(cf);\r\n\t\t\t//clip.m_Formats now owns the global data\r\n\t\t\tcf.m_autoDeleteData = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\r\n\t\t\tCCF_TextAggregator CFText(SepA);\r\n\t\t\tif (IDs.AggregateData(CFText, CF_TEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t\t{\r\n\t\t\t\tCClipFormat cf(CF_TEXT, CFText.GetHGlobal());\r\n\t\t\t\tclip.m_Formats.Add(cf);\r\n\t\t\t\t//clip.m_Formats now owns the global data\r\n\t\t\t\tcf.m_autoDeleteData = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tclip.LoadFormats(IDs[0], false, false);\r\n\t}\r\n\r\n\tCString path = CGetSetOptions::GetPath(PATH_DRAG_FILES);\r\n\tCreateDirectory(path, NULL);\r\n\tint dragId = CGetSetOptions::GetDragId();\r\n\tint origDragId = dragId;\r\n\r\n\tCString subject;\r\n\tCString body;\r\n\tCString attachment;\r\n\r\n\tCClipFormat *html = clip.m_Formats.FindFormat(theApp.m_HTML_Format);\r\n\tif (html != NULL)\r\n\t{\r\n\t\tCString file;\r\n\t\tfile.Format(_T(\"%shtml_%d.html\"), path, dragId++);\r\n\r\n\t\tclip.WriteTextToHtmlFile(file);\r\n\r\n\t\tattachment = file;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCString text = clip.GetUnicodeTextFormat();\r\n\t\tif (text == _T(\"\"))\r\n\t\t{\r\n\t\t\ttext = clip.GetCFTextTextFormat();\r\n\t\t}\r\n\r\n\t\tif (text != _T(\"\"))\r\n\t\t{\r\n\t\t\tbody = text;\r\n\t\t\tsubject = text.Left(30);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCClipFormat *png = NULL;\r\n\t\t\tCClipFormat *dib = clip.m_Formats.FindFormat(CF_DIB);\r\n\t\t\tif (dib == NULL)\r\n\t\t\t{\r\n\t\t\t\tpng = clip.m_Formats.FindFormat(theApp.m_PNG_Format);\r\n\t\t\t}\r\n\r\n\t\t\tif (png != NULL ||\r\n\t\t\t\tdib != NULL)\r\n\t\t\t{\r\n\t\t\t\tCString file;\r\n\t\t\t\tfile.Format(_T(\"%simage_%d.png\"), path, dragId++);\r\n\r\n\t\t\t\tclip.WriteImageToFile(file);\r\n\r\n\t\t\t\tCString fileWrapper;\r\n\t\t\t\tfileWrapper.Format(_T(\"%shtml_%d.html\"), path, dragId++);\r\n\r\n\t\t\t\tCFile f;\r\n\t\t\t\tif (f.Open(fileWrapper, CFile::modeWrite | CFile::modeCreate))\r\n\t\t\t\t{\r\n\t\t\t\t\tCString html;\r\n\t\t\t\t\thtml.Format(_T(\"<html><img src=\\\"%s\\\"></html>\"), file);\r\n\r\n\t\t\t\t\tCStringA convToUtf8 = CTextConvert::UnicodeToUTF8(html);\r\n\t\t\t\t\tf.Write(convToUtf8.GetBuffer(), convToUtf8.GetLength());\r\n\r\n\t\t\t\t\tf.Close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattachment = fileWrapper;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (subject != _T(\"\") ||\r\n\t\tbody != _T(\"\") ||\r\n\t\tattachment != _T(\"\"))\r\n\t{\r\n\t\tSendMail::Send(subject, body, attachment);\r\n\t}\r\n\r\n\tif (dragId != origDragId)\r\n\t{\r\n\t\tCGetSetOptions::SetDragId(dragId);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionGmail()\r\n{\r\n\tCWaitCursor wait;\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tCClip clip;\r\n\r\n\tif (IDs.GetCount() > 1)\r\n\t{\r\n\t\tCStringW SepW = CGetSetOptions::GetMultiPasteSeparator();\r\n\t\tCCF_UnicodeTextAggregator CFUnicodeText(SepW);\r\n\t\tif (IDs.AggregateData(CFUnicodeText, CF_UNICODETEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t{\r\n\t\t\tCClipFormat cf(CF_UNICODETEXT, CFUnicodeText.GetHGlobal());\r\n\t\t\tclip.m_Formats.Add(cf);\r\n\t\t\t//clip.m_Formats now owns the global data\r\n\t\t\tcf.m_autoDeleteData = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCStringA SepA = CTextConvert::UnicodeToAnsi(CGetSetOptions::GetMultiPasteSeparator());\r\n\t\t\tCCF_TextAggregator CFText(SepA);\r\n\t\t\tif (IDs.AggregateData(CFText, CF_TEXT, CGetSetOptions::m_bMultiPasteReverse, false))\r\n\t\t\t{\r\n\t\t\t\tCClipFormat cf(CF_TEXT, CFText.GetHGlobal());\r\n\t\t\t\tclip.m_Formats.Add(cf);\r\n\t\t\t\t//clip.m_Formats now owns the global data\r\n\t\t\t\tcf.m_autoDeleteData = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tclip.LoadFormats(IDs[0], true, false);\r\n\t}\r\n\r\n\tCString text = clip.GetUnicodeTextFormat();\r\n\tif (text == _T(\"\"))\r\n\t{\r\n\t\ttext = clip.GetCFTextTextFormat();\r\n\t}\r\n\r\n\tif (text != _T(\"\"))\r\n\t{\r\n\t\tCString link;\r\n\t\ttext.Replace(_T(\"\\r\\n\"), _T(\"%0D%0A\"));\r\n\t\tCString en = InternetEncode(text);\r\n\r\n\t\tlink.Format(_T(\"https://mail.google.com/mail/u/0/?view=cm&body=%s\"), en);\r\n\r\n\t\tCHyperLink::GotoURL(link, SW_SHOW);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionEmailToAttachExport()\r\n{\r\n\tCWaitCursor wait;\r\n\r\n\tCClipIDs IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tCString path = CGetSetOptions::GetPath(PATH_DRAG_FILES);\r\n\tCreateDirectory(path, NULL);\r\n\tint dragId = CGetSetOptions::GetDragId();\r\n\tint origDragId = dragId;\r\n\r\n\tCString file;\r\n\tfile.Format(_T(\"%sexport_%d.dto\"), path, dragId++);\r\n\r\n\tIDs.Export(file);\r\n\r\n\tSendMail::Send(_T(\"\"), _T(\"\"), file);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionEmailToAttachContent()\r\n{\r\n\tCString path = CGetSetOptions::GetPath(PATH_DRAG_FILES);\r\n\tCreateDirectory(path, NULL);\r\n\r\n\tCClipIDs clipIds;\r\n\tm_lstHeader.GetSelectionItemData(clipIds);\r\n\r\n\tint dragId = CGetSetOptions::GetDragId();\r\n\tint origDragId = dragId;\r\n\r\n\tCStringArray fileList;\r\n\r\n\tfor (int i = 0; i < clipIds.GetCount(); i++)\r\n\t{\r\n\t\tCClip fileClip;\r\n\t\tfileClip.LoadFormats(clipIds[i]);\r\n\r\n\t\tCClipFormat *unicodeText = fileClip.m_Formats.FindFormat(CF_UNICODETEXT);\r\n\t\tif (unicodeText)\r\n\t\t{\r\n\t\t\tCString file;\r\n\t\t\tfile.Format(_T(\"%stext_%d.txt\"), path, dragId++);\r\n\r\n\t\t\tfileClip.WriteTextToFile(file, TRUE, FALSE, FALSE);\r\n\t\t\tfileList.Add(file);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCClipFormat *asciiText = fileClip.m_Formats.FindFormat(CF_TEXT);\r\n\t\t\tif (asciiText)\r\n\t\t\t{\r\n\t\t\t\tCString file;\r\n\t\t\t\tfile.Format(_T(\"%stext_%d.txt\"), path, dragId++);\r\n\r\n\t\t\t\tfileClip.WriteTextToFile(file, FALSE, TRUE, FALSE);\r\n\t\t\t\tfileList.Add(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tCClipFormat *png = NULL;\r\n\t\t\t\tCClipFormat *bitmap = fileClip.m_Formats.FindFormat(CF_DIB);\r\n\t\t\t\tif (bitmap == NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tpng = fileClip.m_Formats.FindFormat(theApp.m_PNG_Format);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (bitmap != NULL ||\r\n\t\t\t\t\tpng != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString file;\r\n\t\t\t\t\tfile.Format(_T(\"%simage_%d.png\"), path, dragId++);\r\n\r\n\t\t\t\t\tif (fileClip.WriteImageToFile(file))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfileList.Add(file);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//couldn't get SendMail::Send to support multiple files\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (fileList.GetCount() > 0)\r\n\t{\r\n\t\tSendMail::Send(_T(\"\"), _T(\"\"), fileList[0]);\r\n\t}\r\n\r\n\tif (dragId != origDragId)\r\n\t{\r\n\t\tCGetSetOptions::SetDragId(dragId);\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoActionSlugify()\r\n{\r\n\tif (::GetFocus() == m_lstHeader.GetSafeHwnd())\r\n\t{\r\n\t\tCSpecialPasteOptions pasteOptions;\r\n\t\tpasteOptions.m_pasteSlugify = true;\r\n\t\tOpenSelection(pasteOptions);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nbool CQPasteWnd::DoRefreshList()\r\n{\r\n\ttheApp.m_FocusID = -1;\r\n\r\n\tCString csText;\r\n\tm_search.GetWindowText(csText);\r\n\r\n\tFillList(csText);\r\n\t\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoDeleteAllNonUsedClips()\r\n{\r\n\tbool bStartValue = m_bHideWnd;\r\n\tm_bHideWnd = false;\r\n\r\n\tint nRet = MessageBox(theApp.m_Language.GetString(\"Delete_All_Non_Used_Clips\", \"Delete all clips that are not groups, in groups, marked as never auto delete, has a shortcut key or marked as sticky.\\r\\n\\r\\nThis cannot be undone.\"), _T(\"Ditto\"), MB_YESNO | MB_TOPMOST);\r\n\r\n\tm_bHideWnd = bStartValue;\r\n\tif (nRet == IDNO)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCWaitCursor wait;\r\n\r\n\tDeleteNonUsedClips(true);\r\n\tFillList();\r\n\r\n\tm_cf_dibCache.clear();\r\n\tm_cf_NO_dibCache.clear();\r\n\tm_cf_rtfCache.clear();\r\n\tm_cf_NO_rtfCache.clear();\r\n\r\n\treturn true;\r\n}\r\n\r\nbool CQPasteWnd::DoCopySelection()\r\n{\r\n\tARRAY IDs;\r\n\tm_lstHeader.GetSelectionItemData(IDs);\r\n\r\n\tINT_PTR count = IDs.GetSize();\r\n\r\n\tif (count <= 0)\r\n\t{\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tCProcessPaste paste;\r\n\r\n\t//Don't send the paste just load it into memory\r\n\tpaste.m_bSendPaste = false;\r\n\r\n\tif (count > 1)\r\n\t\tpaste.GetClipIDs().Copy(IDs);\r\n\telse\r\n\t\tpaste.GetClipIDs().Add(IDs[0]);\r\n\r\n\t//Don't move these to the top\r\n\tBOOL itWas = CGetSetOptions::m_bUpdateTimeOnPaste;\r\n\tCGetSetOptions::m_bUpdateTimeOnPaste = CGetSetOptions::GetUpdateClipOrderOnCtrlC();\r\n\r\n\tpaste.DoPaste();\r\n\r\n\tCGetSetOptions::m_bUpdateTimeOnPaste = itWas;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQPasteWnd::SetTransparency(int percent)\r\n{\r\n\tif (percent > 0)\r\n\t{\r\n\t\tCGetSetOptions::SetTransparencyPercent(percent);\r\n\t\tCGetSetOptions::SetEnableTransparency(TRUE);\r\n\r\n\t\tm_Alpha.SetTransparent(TRUE);\r\n\r\n\t\tfloat fPercent = percent / (float)100.0;\r\n\r\n\t\tm_Alpha.SetOpacity(OPACITY_MAX - (int)(fPercent *OPACITY_MAX));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCGetSetOptions::SetEnableTransparency(FALSE);\r\n\t\tm_Alpha.SetTransparent(FALSE);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::SetCurrentTransparency()\r\n{\r\n\t//Set the transparency\r\n\tif (CGetSetOptions::GetEnableTransparency())\r\n\t{\r\n\t\tm_Alpha.SetTransparent(TRUE);\r\n\r\n\t\tfloat fPercent = CGetSetOptions::GetTransparencyPercent() / (float)100.0;\r\n\r\n\t\tm_Alpha.SetOpacity(OPACITY_MAX - (int)(fPercent *OPACITY_MAX));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_Alpha.SetTransparent(FALSE);\r\n\t}\r\n}\r\n\r\nvoid CQPasteWnd::OnTransparencyIncrease()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_INCREASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateTransparencyIncrease(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_INCREASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnTransparencyDecrease()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_DECREASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateTransparencyDecrease(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_DECREASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnTransparencyToggle()\r\n{\r\n\tDoAction(ActionEnums::TRANSPARENCY_TOGGLE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateTransparencyToggle(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::TRANSPARENCY_TOGGLE);\r\n}\r\n\r\nvoid CQPasteWnd::OnImportEmailto()\r\n{\r\n\tDoAction(ActionEnums::EMAILTO_BODY);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateImportEmailto(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EMAILTO_BODY);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportGmail()\r\n{\r\n\tDoAction(ActionEnums::GMAIL);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateImportGmail(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::GMAIL);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportEmailtoasattachment()\r\n{\r\n\tDoAction(ActionEnums::EMAILTO_ATTACH_EXPORT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateImportEmailtoasattachment(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EMAILTO_ATTACH_EXPORT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteSlugify()\r\n{\r\n\tDoAction(ActionEnums::SLUGIFY);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteSlugify(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SLUGIFY);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnImportEmailContentAttach()\r\n{\r\n\tDoAction(ActionEnums::EMAILTO_ATTACH_CONTENT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateImportEmailContentAttach(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::EMAILTO_ATTACH_CONTENT);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnSpecialpasteTogglecase()\r\n{\r\n\tDoAction(ActionEnums::INVERT_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteTogglecase(CCmdUI *pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::INVERT_CASE);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnFirstShowstartupmessage()\r\n{\r\n\tBOOL existing = CGetSetOptions::GetShowStartupMessage();\r\n\tCGetSetOptions::SetShowStartupMessage(!existing);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnFirstRestoreDb()\r\n{\r\n\ttheApp.m_pMainFrame->PostMessage(WM_RESTORE_DB, 0, 0);\r\n}\r\n\r\nvoid CQPasteWnd::OnFirstBackupDb()\r\n{\r\n\ttheApp.m_pMainFrame->PostMessage(WM_BACKUP_DB, 0, 0);\r\n}\r\n\r\nvoid CQPasteWnd::OnMenuDeleteallnonusedclips()\r\n{\r\n\tDoAction(ActionEnums::DELETE_ALL_NON_USED_CLIPS);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateMenuDeleteallnonusedclips(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::DELETE_ALL_NON_USED_CLIPS);\r\n}\r\n\r\nvoid CQPasteWnd::OnImportSetdragfilename()\r\n{\r\n\tDoAction(ActionEnums::SET_DRAG_FILE_NAME);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateImportSetdragfilename(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::SET_DRAG_FILE_NAME);\r\n}\r\n\r\nvoid CQPasteWnd::OnSpecialpasteCamelcase()\r\n{\r\n\tDoAction(ActionEnums::PASTE_CAMEL_CASE);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteCamelcase(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_CAMEL_CASE);\r\n}\r\n\r\nvoid CQPasteWnd::OnSpecialpasteMultipleImagesHorz()\r\n{\r\n\tDoAction(ActionEnums::PASTE_MULTI_IMAGE_HORIZONTAL);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteMultipleImagesHorz(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_MULTI_IMAGE_HORIZONTAL);\r\n}\r\n\r\nvoid CQPasteWnd::OnSpecialpasteMultipleImagesVert()\r\n{\r\n\tDoAction(ActionEnums::PASTE_MULTI_IMAGE_VERTICAL);\r\n}\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteMultipleImagesVert(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::PASTE_MULTI_IMAGE_VERTICAL);\r\n}\r\n\r\nvoid CQPasteWnd::OnSpecialpasteAsciitextonly()\r\n{\r\n\tDoAction(ActionEnums::ASCII_TEXT_ONLY);\r\n}\r\n\r\n\r\nvoid CQPasteWnd::OnUpdateSpecialpasteAsciitextonly(CCmdUI* pCmdUI)\r\n{\r\n\tif (!pCmdUI->m_pMenu)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tUpdateMenuShortCut(pCmdUI, ActionEnums::ASCII_TEXT_ONLY);\r\n}\r\n"
        },
        {
          "name": "QPasteWnd.h",
          "type": "blob",
          "size": 22.654296875,
          "content": "#pragma once\r\n\r\n#include \"QListCtrl.h\"\r\n#include \"SearchEditBox.h\"\r\n#include \"WndEx.h\"\r\n#include \"GroupStatic.h\"\r\n#include \"GroupTree.h\"\r\n#include \"AlphaBlend.h\"\r\n#include \"Sqlite\\CppSQLite3.h\"\r\n#include <vector>\r\n#include <list>\r\n#include <map>\r\n#include <afxmt.h>\r\n#include \"ClipFormatQListCtrl.h\"\r\n#include \"QPasteWndThread.h\"\r\n#include \"editwithbutton.h\"\r\n#include \"GdipButton.h\"\r\n#include \"SpecialPasteOptions.h\"\r\n#include \"ClipIds.h\"\r\n#include \"SymbolEdit.h\"\r\n#include \"Popup.h\"\r\n#include \"CustomFriendsHelper.h\"\r\n\r\nclass CMainTable\r\n{\r\npublic:\r\n    CMainTable(): \r\n\t\tm_lID( - 1), \r\n\t\tm_bDontAutoDelete(false), \r\n\t\tm_bIsGroup(false), \r\n\t\tm_bHasShortCut(false), \r\n\t\tm_bHasParent(false),\r\n\t\tm_dateCopied(0),\r\n\t\tm_datePasted(0)\r\n\t{\r\n\r\n\t}\r\n\r\n    ~CMainTable()\r\n\t{\r\n\r\n    }\r\n\r\n    long m_lID;\r\n    CString m_Desc;\r\n    bool m_bDontAutoDelete;\r\n    bool m_bIsGroup;\r\n    bool m_bHasShortCut;\r\n    bool m_bHasParent;\r\n    CString m_QuickPaste;\r\n\tdouble m_clipOrder;\r\n\tdouble m_clipGroupOrder;\r\n\tdouble m_stickyClipOrder;\r\n\tdouble m_stickyClipGroupOrder;\r\n\tint m_dateCopied;\r\n\tint m_datePasted;\r\n\r\n\tstatic bool SortDesc(const CMainTable& d1, const CMainTable& d2)\r\n\t{\r\n\t\tdouble d1StickyOrder = d1.m_stickyClipOrder;\r\n\t\tdouble d2StickyOrder = d2.m_stickyClipOrder;\t\t\r\n\r\n\t\tif (d1StickyOrder != d2StickyOrder)\r\n\t\t\treturn d1StickyOrder > d2StickyOrder;\r\n\r\n\t\tif (d1.m_bIsGroup != d2.m_bIsGroup)\r\n\t\t\treturn d1.m_bIsGroup < d2.m_bIsGroup;\r\n\r\n\t\treturn d1.m_clipOrder > d2.m_clipOrder;\r\n\t}\r\n\r\n\tstatic bool GroupSortDesc(const CMainTable& d1, const CMainTable& d2)\r\n\t{\r\n\t\tdouble d1StickyOrder = d1.m_stickyClipGroupOrder;\r\n\r\n\t\tdouble d2StickyOrder = d2.m_stickyClipGroupOrder;\r\n\r\n\t\tif (d1StickyOrder != d2StickyOrder)\r\n\t\t\treturn d1StickyOrder > d2StickyOrder;\r\n\r\n\t\tif (d1.m_bIsGroup != d2.m_bIsGroup)\r\n\t\t\treturn d1.m_bIsGroup < d2.m_bIsGroup;\r\n\r\n\t\treturn d1.m_clipGroupOrder > d2.m_clipGroupOrder;\r\n\t}\r\n};\r\n\r\n\r\ntypedef std::map < int, CMainTable > MainTypeMap;\r\ntypedef std::map < int, CClipFormatQListCtrl > CF_DibTypeMap;\r\ntypedef std::map < int, char > CF_NoDibTypeMap;\r\n\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CQPasteWnd window\r\n\r\nclass CQPasteWnd: public CWndEx\r\n{\r\n    // Construction\r\npublic:\r\n    CQPasteWnd();\r\n\r\n    // Attributes\r\npublic:\r\n\r\n    // Operations\r\npublic:\r\n\r\n    // Overrides\r\n    // ClassWizard generated virtual function overrides\r\n    //{{AFX_VIRTUAL(CQPasteWnd)\r\npublic:\r\n    virtual BOOL Create(CRect rect, CWnd *pParentWnd);\r\n    virtual BOOL PreTranslateMessage(MSG *pMsg);\r\n\r\n\tbool CheckActions(MSG * pMsg);\r\n\r\n\t//}}AFX_VIRTUAL\r\n\r\n    // Implementation\r\npublic:\r\n    bool Add(const CString &csHeader, const CString &csText, int nID);\r\n    virtual ~CQPasteWnd();\r\n\r\n    void UpdateFont();\r\n\r\n    //protected:\r\n    CQListCtrl m_lstHeader;\r\n\r\n    CAlphaBlend m_Alpha;\r\n\t//CEditWithButton m_search;\r\n\tCSymbolEdit m_search;\r\n    CFont m_SearchFont;\r\n    bool m_bHideWnd;\r\n    CString m_strSQLSearch;\r\n\tCString m_strSearch;\r\n    CGroupStatic m_stGroup;\r\n    CFont m_groupFont;\r\n    CString m_Title;\r\n    CGroupTree m_GroupTree;\r\n    CGdipButton m_ShowGroupsFolderBottom;\r\n    CGdipButton m_BackButton;\r\n\tCGroupStatic m_alwaysOnToWarningStatic;\r\n\tCGdipButton m_systemMenu;\r\n\tCGroupStatic m_noSearchResultsStatic;\r\n\r\n    long m_lRecordCount;\r\n    bool m_bStopQuery;\r\n    bool m_bHandleSearchTextChange;\r\n    bool m_bModifersMoveActive;\r\n\r\n    CQPasteWndThread m_thread;\r\n\tCQPasteWndThread m_extraDataThread;\r\n\tstd::vector<CMainTable> m_listItems;\r\n\r\n\tstd::list<CPoint> m_loadItems;\r\n    std::list<CClipFormatQListCtrl> m_ExtraDataLoadItems;\r\n    CF_DibTypeMap m_cf_dibCache;\r\n\tCF_NoDibTypeMap m_cf_NO_dibCache;\r\n    CF_DibTypeMap m_cf_rtfCache;\r\n\tCF_NoDibTypeMap m_cf_NO_rtfCache;\r\n    CCriticalSection m_CritSection;\r\n    CAccels m_actions;\r\n\tCAccels m_toolTipActions;\r\n\tCAccels m_modifierKeyActions;\r\n\tbool m_showScrollBars;\r\n\tint m_leftSelectedCompareId;\r\n\tINT64 m_extraDataCounter;\r\n\tCPopup m_popupMsg;\r\n\tCCustomFriendsHelper m_customFriendsHelper;\r\n\tbool m_noSearchResults;\r\n\tCAccel m_timerAction;\r\n\t__int64 m_lastDbWrite;\r\n\tbool m_pendingRefresh;\r\n\tDWORD m_lastNonActiveMouseMove;\r\n\r\n    void RefreshNc();\r\n    void UpdateStatus(bool bRepaintImmediately = false); // regenerates the status (caption) text\r\n    BOOL FillList(CString csSQLSearch = \"\");\r\n    BOOL HideQPasteWindow(bool releaseFocus, BOOL clearSearchData = -1);\r\n    BOOL ShowQPasteWindow(BOOL bFillList = TRUE);\r\n    void MoveControls();\r\n\r\n    void DeleteSelectedRows();\r\n\r\n\tBOOL OpenID(int id, CSpecialPasteOptions pasteOptions);\r\n\tBOOL OpenSelection(CSpecialPasteOptions pasteOptions);\r\n    BOOL OpenIndex(int item);\r\n\tBOOL NewGroup(bool bGroupSelection = true, int parentId = -1);\r\n\r\n    CString LoadDescription(int nItem);\r\n    bool SaveDescription(int nItem, CString text);\r\n\r\n    //Menu Items\r\n    void SetLinesPerRow(int lines, bool force, bool resetListCount);\r\n    void SetTransparency(int percent);\r\n    void OnUpdateLinesPerRow(CCmdUI *pCmdUI, int nValue);\r\n    void OnUpdateTransparency(CCmdUI *pCmdUI, int nValue);\r\n    void SetMenuChecks(CMenu *pMenu);\r\n    void SetSendToMenu(CMenu *pMenu, int nMenuID, int nArrayPos);\r\n\tvoid SetFriendChecks(CMenu *pMenu);\r\n\r\n    BOOL SendToFriendbyPos(int nPos, CString override_IP_Host);\r\n\r\n    bool InsertNextNRecords(int nEnd);\r\n\r\n    CString GetDisplayText(int lDontAutoDelete, int lShortCut, bool bIsGroup, int lParentID, CString csText);\r\n\r\n    static void FillMainTable(CMainTable &table, CppSQLite3Query &q);\r\n    void RunThread();\r\n    void MoveSelection(bool down, bool requireModifersActive);\r\n    void OnKeyStateUp();\r\n    void SetKeyModiferState(bool bActive);\r\n\tvoid SaveWindowSize();\r\n\tvoid SelectFocusID();\r\n\tvoid SetSearchImages();\r\n\tvoid RemoveStickyInternal(int id, bool &sort);\r\n\r\n\tDROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\r\n\tDROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);\r\n\tBOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);\r\n\tvoid OnDragLeave();\r\n\tCOleDropTarget *m_pDropTarget;\r\n\r\n\tbool DoAction(CAccel a);\r\n\tbool DoAction(DWORD cmd);\r\n\tbool DoActionShowDescription();\r\n\tbool DoActionNextDescription(); \r\n\tbool DoActionPrevDescription();\r\n\tbool DoActionShowMenu();\r\n\tbool DoActionShowSystemMenu();\r\n\tbool DoActionNewGroup();\r\n\tbool DoActionNewGroupSelection();\r\n\tbool DoActionToggleFileLogging();\r\n\tbool DoActionToggleOutputDebugString();\r\n\tbool DoActionCloseWindow();\r\n\tbool DoActionForceCloseWindow();\r\n\tbool DoActionNextTabControl();\r\n\tbool DoActionPrevTabControl();\r\n\tbool DoActionShowGroups();\r\n\tbool DoActionNewClip();\r\n\tbool DoActionEditClip();\r\n\tbool DoActionMoveSelectionDown();\r\n\tbool DoActionToggleDescriptionWordWrap();\r\n\tbool DoActionApplyLastSearch();\r\n\tbool DoActionToggleSearchMethod();\r\n\tbool DoActionPasteScript(CString scriptGuid);\r\n\tbool DoActionMoveSelectionUp();\r\n\tbool DoModifierActiveActionSelectionUp();\r\n\tbool DoModifierActiveActionSelectionDown();\r\n\tbool DoModifierActiveActionMoveFirst();\r\n\tbool DoModifierActiveActionMoveLast();\r\n\tbool DoActionCancelFilter();\r\n\tbool DoActionHomeList();\r\n\tbool DoActionBackGroup();\r\n\tbool DoActionToggleShowPersistant();\r\n\tbool DoActionDeleteSelected();\r\n\tbool DoActionPasteSelected();\r\n\tbool DoActionClipProperties();\r\n\tbool DoActionPasteSelectedPlainText();\r\n\tbool DoActionMoveClipToGroup();\r\n\tbool DoActionElevatePrivleges();\r\n\tbool DoShowInTaskBar();\t\r\n\tbool DoClipCompare();\r\n\tbool DoSelectLeftSideCompare();\r\n\tbool DoSelectRightSideAndDoCompare();\r\n\tbool DoExportToQRCode();\r\n\tbool DoExportToTextFile();\r\n\tbool DoExportToGoogleTranslate();\r\n\tbool DoExportToBitMapFile();\r\n\tbool DoSaveCurrentClipboard();\r\n\tbool DoMoveClipDown();\r\n\tbool DoMoveClipUp();\r\n\tbool DoMoveClipTOP();\r\n\tbool DoMoveClipLast();\r\n\tbool DoFilterOnSelectedClip();\r\n\tbool DoPasteUpperCase();\r\n\tbool DoPasteCamelCase();\r\n\tbool DoPasteImagesVert();\r\n\tbool DoPasteAsciiOnly();\r\n\tbool DoPasteImagesHorz();\r\n\tbool DoPasteLowerCase();\r\n\tbool DoPasteCapitalize();\r\n\tbool DoPasteSentenceCase();\r\n\tbool DoInvertCase();\r\n\tbool DoPasteRemoveLineFeeds();\r\n\tbool DoPastePlusAddLineFeed();\r\n\tbool DoPasteAddTwoLineFeeds();\r\n\tbool DoPasteTypoglycemia();\r\n\tbool DoPasteAddCurrentTime();\r\n\tbool OnShowFirstTenText();\r\n\tbool OnShowClipWasPasted();\r\n\tbool OnToggleLastGroupToggle();\r\n\tbool OnMakeTopSticky(bool forceSort);\r\n\tbool OnMakeLastSticky();\r\n\tbool OnRemoveStickySetting();\t\r\n\tbool DoActionReplaceTopStickyClip();\r\n\tbool DoActionPromptSendToFriend();\r\n\tbool DoActionSaveCF_HDROP_FileData();\r\n\tbool DoActionToggleClipboardConnection();\r\n\tbool DoActionPasteDontMoveClip();\r\n\tbool DoSetDragFileName();\r\n\tbool DoActionPasteTrimWhiteSpace();\r\n\tbool DoActionToggleTransparency();\r\n\tbool DoActionIncreaseTransparency();\r\n\tbool DoActionDecreaseTransparency();\r\n\tbool DoActionEmailTo();\r\n\tbool DoActionGmail();\r\n\tbool DoActionEmailToAttachExport();\r\n\tbool DoActionEmailToAttachContent();\r\n\tbool DoActionSlugify();\r\n\tbool DoCopySelection();\r\n\tbool DoRefreshList();\r\n\tbool DoDeleteAllNonUsedClips();\r\n\r\n\tbool OnNewClip();\r\n\tbool OnImportClip();\r\n\tbool OnDeleteClipData();\r\n\tbool OnGlobalHotkyes();\r\n\t\r\n\tvoid UpdateMenuShortCut(CCmdUI *pCmdUI, DWORD action);\r\n\r\n\tbool ShowProperties(int id, int row);\r\n\tbool DeleteClips(CClipIDs &IDs, ARRAY &Indexs);\r\n\tvoid RemoveFromImageRtfCache(int id);\r\n\tbool SyncClipDataToArrayData(CClip &clip);\r\n\tbool SelectIds(ARRAY &ids);\r\n\r\n\tvoid LoadShortcuts();\r\n\r\n\tvoid ShowRightClickMenu();\r\n\r\n\tvoid SetCurrentTransparency();\r\n\r\n    // Generated message map functions\r\nprotected:\r\n    //{{AFX_MSG(CQPasteWnd)\r\n    DECLARE_MESSAGE_MAP()\r\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\r\n    afx_msg void OnSize(UINT nType, int cx, int cy);\r\n    afx_msg void OnSetFocus(CWnd *pOldWnd);\r\n\tafx_msg void OnKillFocus(CWnd *pOldWnd);\r\n    afx_msg void OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized);\r\n    afx_msg void OnMenuLinesperrow1();\r\n    afx_msg void OnMenuLinesperrow2();\r\n    afx_msg void OnMenuLinesperrow3();\r\n    afx_msg void OnMenuLinesperrow4();\r\n    afx_msg void OnMenuLinesperrow5();\r\n    afx_msg void OnMenuTransparency10();\r\n    afx_msg void OnMenuTransparency15();\r\n    afx_msg void OnMenuTransparency20();\r\n    afx_msg void OnMenuTransparency25();\r\n    afx_msg void OnMenuTransparency30();\r\n    afx_msg void OnMenuTransparency40();\r\n    afx_msg void OnMenuTransparency5();\r\n    afx_msg void OnMenuTransparencyNone();\r\n    afx_msg void OnMenuDelete();\r\n    afx_msg void OnMenuPositioningAtcaret();\r\n    afx_msg void OnMenuPositioningAtcursor();\r\n    afx_msg void OnMenuPositioningAtpreviousposition();\r\n    afx_msg void OnMenuOptions();\r\n    afx_msg LRESULT OnCancelFilter(WPARAM wParam, LPARAM lParam);\r\n    afx_msg void OnMenuExitprogram();\r\n    afx_msg void OnMenuToggleConnectCV();\r\n    afx_msg void OnMenuProperties();\r\n    afx_msg void OnClose();\r\n    afx_msg void OnBegindrag(NMHDR *pNMHDR, LRESULT *pResult);\r\n    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);\r\n    afx_msg void GetDispInfo(NMHDR *pNMHDR, LRESULT *pResult);\r\n    afx_msg void OnFindItem(NMHDR *pNMHDR, LRESULT *pResult);\r\n    afx_msg void OnMenuFirsttenhotkeysUsectrlnum();\r\n    afx_msg void OnMenuFirsttenhotkeysShowhotkeytext();\r\n    afx_msg void OnMenuQuickoptionsAllwaysshowdescription();\r\n    afx_msg void OnMenuQuickoptionsDoubleclickingoncaptionTogglesalwaysontop();\r\n    afx_msg void OnMenuQuickoptionsDoubleclickingoncaptionRollupwindow();\r\n    afx_msg void OnMenuQuickoptionsDoubleclickingoncaptionTogglesshowdescription();\r\n    afx_msg void OnMenuQuickoptionsPromptfornewgroupnames();\r\n    afx_msg void OnShowGroupsBottom();\r\n    afx_msg void OnShowGroupsTop();\r\n    afx_msg void OnMenuViewgroups();\r\n    afx_msg void OnMenuQuickpropertiesSettoneverautodelete();\r\n    afx_msg void OnMenuQuickpropertiesAutodelete();\r\n    afx_msg void OnMenuQuickpropertiesRemovehotkey();\r\n    afx_msg void OnMenuSenttoFriendEight();\r\n    afx_msg void OnMenuSenttoFriendEleven();\r\n    afx_msg void OnMenuSenttoFriendFifteen();\r\n    afx_msg void OnMenuSenttoFriendFive();\r\n    afx_msg void OnMenuSenttoFriendFore();\r\n    afx_msg void OnMenuSenttoFriendForeteen();\r\n    afx_msg void OnMenuSenttoFriendNine();\r\n    afx_msg void OnMenuSenttoFriendSeven();\r\n    afx_msg void OnMenuSenttoFriendSix();\r\n    afx_msg void OnMenuSenttoFriendTen();\r\n    afx_msg void OnMenuSenttoFriendThirteen();\r\n    afx_msg void OnMenuSenttoFriendThree();\r\n    afx_msg void OnMenuSenttoFriendTwelve();\r\n    afx_msg void OnMenuSenttoFriendTwo();\r\n    afx_msg void OnMenuSenttoFriendone();\r\n    afx_msg void OnMenuSenttoPromptforip();\r\n    afx_msg void OnMenuGroupsMovetogroup();\r\n    afx_msg void OnMenuPasteplaintextonly();\r\n    afx_msg void OnMenuHelp();\r\n    afx_msg void OnMenuQuickoptionsFont();\r\n    afx_msg void OnMenuQuickoptionsShowthumbnails();\r\n    afx_msg void OnMenuQuickoptionsDrawrtftext();\r\n    afx_msg void OnMenuQuickoptionsPasteclipafterselection();\r\n    afx_msg void OnSearchEditChange();\r\n    afx_msg void OnMenuQuickoptionsFindasyoutype();\r\n    afx_msg void OnMenuQuickoptionsEnsureentirewindowisvisible();\r\n    afx_msg void OnMenuQuickoptionsShowclipsthatareingroupsinmainlist();\r\n    afx_msg void OnMenuPastehtmlasplaintext();\r\n    afx_msg void OnPromptToDeleteClip();\r\n    afx_msg void OnUpdateMenuNewgroup(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuNewgroupselection(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuAllwaysontop(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuViewfulldescription(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuViewgroups(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuPasteplaintextonly(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuDelete(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuProperties(CCmdUI *pCmdUI);\r\n    afx_msg void OnDestroy();\r\n    afx_msg LRESULT OnSearchEnterKeyPressed(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnListEnd(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnSearch(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnDelete(WPARAM wParam, LPARAM lParam);\r\n    afx_msg void OnGetToolTipText(NMHDR *pNMHDR, LRESULT *pResult);\r\n    afx_msg LRESULT OnListSelect_DB_ID(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnListMoveSelectionToGroup(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnRefreshView(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnReloadClipInUI(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnGroupTreeMessage(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnFillRestOfList(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnRefeshRow(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnSetListCount(WPARAM wParam, LPARAM lParam);\r\n    afx_msg HBRUSH CtlColor(CDC *pDC, UINT nCtlColor);\r\n    afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);\r\n    afx_msg void OnViewcaptionbaronRight();\r\n    afx_msg void OnViewcaptionbaronBottom();\r\n    afx_msg void OnViewcaptionbaronLeft();\r\n    afx_msg void OnViewcaptionbaronTop();\r\n    afx_msg void OnMenuAutohide();\r\n    afx_msg void OnMenuViewfulldescription();\r\n    afx_msg void OnMenuAllwaysontop();\r\n    afx_msg void OnMenuNewGroup();\r\n    afx_msg void OnMenuNewGroupSelection();\r\n    afx_msg void OnBackButton();\r\n\tafx_msg void OnSystemButton();\r\n    afx_msg LRESULT OnUpDown(WPARAM wParam, LPARAM lParam);\r\n    afx_msg LRESULT OnItemDeleted(WPARAM wParam, LPARAM lParam);\r\n    LRESULT OnToolTipWndInactive(WPARAM wParam, LPARAM lParam);\r\n    afx_msg void OnTimer(UINT_PTR nIDEvent);\r\n    afx_msg void OnMenuExport();\r\n    afx_msg void OnMenuImport();\r\n    afx_msg void OnQuickpropertiesRemovequickpaste();\r\n    afx_msg void OnMenuEdititem();\r\n    afx_msg void OnMenuNewclip();\r\n    afx_msg void OnUpdateMenuEdititem(CCmdUI *pCmdUI);\r\n    afx_msg void OnUpdateMenuNewclip(CCmdUI *pCmdUI);\r\n    afx_msg void OnAddinSelect(UINT id);\r\n\tafx_msg void OnCustomSendToFriend(UINT idIn);\r\n\tafx_msg void OnChaiScriptPaste(UINT idIn);\r\n    afx_msg LRESULT OnSelectAll(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnShowHideScrollBar(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnMenuSearchDescription();\r\n\tafx_msg void OnMenuSearchFullText();\r\n\tafx_msg void OnMenuSearchQuickPaste();\r\n\tafx_msg void OnMenuSimpleTextSearch();\r\n\tafx_msg LRESULT OnPostOptions(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnMakeTopStickyClip();\r\n\tafx_msg void OnMakeLastStickyClip();\r\n\tafx_msg void OnRemoveSticky();\r\n\tafx_msg void OnElevateAppToPasteIntoElevatedApp();\r\n\t\r\npublic:\r\n\tafx_msg void OnQuickoptionsShowintaskbar();\r\n\tafx_msg void OnMenuViewasqrcode();\r\n\tafx_msg void OnExportExporttotextfile();\r\n\tafx_msg void OnCompareCompare();\r\n\tafx_msg void OnCompareSelectleftcompare();\r\n\tafx_msg void OnCompareCompareagainst();\r\n\tafx_msg void OnUpdateCompareCompare(CCmdUI *pCmdUI);\r\n\tafx_msg LRESULT OnShowProperties(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnNewGroup(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg LRESULT OnDeleteId(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnMenuRegularexpressionsearch();\r\n\tafx_msg void OnImportExporttogoogletranslate();\r\n\tafx_msg void OnUpdateImportExporttogoogletranslate(CCmdUI *pCmdUI);\r\n\tafx_msg void OnImportExportclipBitmap();\r\n\tafx_msg void OnUpdateImportExportclipBitmap(CCmdUI *pCmdUI);\r\n\tafx_msg void OnMenuWildcardsearch();\r\n\tafx_msg void OnMenuSavecurrentclipboard();\r\n\tafx_msg void OnUpdateMenuSavecurrentclipboard(CCmdUI *pCmdUI);\r\n\tafx_msg void OnCliporderMoveup();\r\n\tafx_msg void OnUpdateCliporderMoveup(CCmdUI *pCmdUI);\r\n\tafx_msg void OnCliporderMovedown();\r\n\tafx_msg void OnUpdateCliporderMovedown(CCmdUI *pCmdUI);\r\n\tafx_msg void OnCliporderMovetotop();\r\n\tafx_msg void OnUpdateCliporderMovetotop(CCmdUI *pCmdUI);\r\n\tafx_msg void OnMenuFilteron();\r\n\tafx_msg void OnUpdateMenuFilteron(CCmdUI *pCmdUI);\r\n\tafx_msg void OnAlwaysOnTopClicked();\r\n\t//afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\r\n\tafx_msg void OnSpecialpasteUppercase();\r\n\tafx_msg void OnUpdateSpecialpasteUppercase(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteLowercase();\r\n\tafx_msg void OnUpdateSpecialpasteLowercase(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteCapitalize();\r\n\tafx_msg void OnUpdateSpecialpasteCapitalize(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteSentence();\r\n\tafx_msg void OnUpdateSpecialpasteSentence(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteRemovelinefeeds();\r\n\tafx_msg void OnUpdateSpecialpasteRemovelinefeeds(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpastePaste();\r\n\tafx_msg void OnUpdateSpecialpastePaste(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpastePaste32919();\r\n\tafx_msg void OnUpdateSpecialpastePaste32919(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteTypoglycemia();\r\n\tafx_msg void OnUpdateSpecialpasteTypoglycemia(CCmdUI *pCmdUI);\r\n\tafx_msg void OnNMClickList1(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnNMDblclkList1(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnNMRClickList1(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnNMRDblclkList1(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg void OnQuickoptionsShowtextforfirsttencopyhotkeys();\r\n\tafx_msg void OnUpdateQuickoptionsShowtextforfirsttencopyhotkeys(CCmdUI *pCmdUI);\r\n\tafx_msg void OnQuickoptionsShowindicatoracliphasbeenpasted();\r\n\tafx_msg void OnUpdateQuickoptionsShowindicatoracliphasbeenpasted(CCmdUI *pCmdUI);\r\n\tafx_msg void OnGroupsTogglelastgroup();\r\n\tafx_msg void OnUpdateGroupsTogglelastgroup(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateStickyclipsMaketopstickyclip(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateStickyclipsMakelaststickyclip(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateStickyclipsRemovestickysetting(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpastePaste32927();\r\n\tafx_msg void OnUpdateSpecialpastePaste32927(CCmdUI *pCmdUI);\r\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\r\n\tafx_msg void OnMenuGlobalhotkeys32933();\r\n\tafx_msg void OnMenuDeleteclipdata32934();\r\n\tafx_msg void OnMenuImportclip32935();\r\n\tafx_msg void OnMenuNewclip32937();\r\n\tafx_msg void OnUpdateMenuImportclip32935(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateMenuNewclip32937(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateMenuGlobalhotkeys32933(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateMenuDeleteclipdata32934(CCmdUI *pCmdUI);\r\n\tafx_msg LRESULT OnSearchFocused(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnCliporderReplacetopstickyclip();\r\n\tafx_msg void OnUpdateCliporderReplacetopstickyclip(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSendtoPromptforname();\r\n\tafx_msg void OnUpdateSendtoPromptforname(CCmdUI *pCmdUI);\r\n\tafx_msg void OnImportImportcopiedfile();\r\n\tafx_msg void OnUpdateImportImportcopiedfile(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdate32775(CCmdUI *pCmdUI);\r\n\tafx_msg LRESULT OnDpiChanged(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnCliporderMovetolast();\r\n\tafx_msg void OnUpdateCliporderMovetolast(CCmdUI *pCmdUI);\r\n\tafx_msg LRESULT OnCopyClip(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnSpecialpastePasteDontUpdateOrder();\r\n\tafx_msg void OnUpdateOnSpecialPasteDontUpdateOrder(CCmdUI *pCmdUI);\r\n\r\n\tafx_msg void OnSpecialpasteTrim();\r\n\tafx_msg void OnUpdateSpecialpasteTrim(CCmdUI *pCmdUI);\r\n\tafx_msg void OnTransparencyIncrease();\r\n\tafx_msg void OnUpdateTransparencyIncrease(CCmdUI *pCmdUI);\r\n\tafx_msg void OnTransparencyDecrease();\r\n\tafx_msg void OnUpdateTransparencyDecrease(CCmdUI *pCmdUI);\r\n\tafx_msg void OnTransparencyToggle();\r\n\tafx_msg void OnUpdateTransparencyToggle(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparencyNone(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency5(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency10(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency15(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency20(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency25(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency30(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency35(CCmdUI *pCmdUI);\r\n\tafx_msg void OnUpdateTransparency40(CCmdUI *pCmdUI);\r\n\tafx_msg void OnTransparency35();\r\n\tafx_msg void OnImportEmailto();\r\n\tafx_msg void OnUpdateImportEmailto(CCmdUI *pCmdUI);\r\n\tafx_msg void OnImportGmail();\r\n\tafx_msg void OnUpdateImportGmail(CCmdUI *pCmdUI);\r\n\tafx_msg void OnImportEmailtoasattachment();\r\n\tafx_msg void OnUpdateImportEmailtoasattachment(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteSlugify();\r\n\tafx_msg void OnUpdateSpecialpasteSlugify(CCmdUI *pCmdUI);\r\n\tafx_msg void OnImportEmailContentAttach();\r\n\tafx_msg void OnUpdateImportEmailContentAttach(CCmdUI *pCmdUI);\r\n\tafx_msg void OnSpecialpasteTogglecase();\r\n\tafx_msg void OnUpdateSpecialpasteTogglecase(CCmdUI *pCmdUI);\r\n\tafx_msg void OnFirstShowstartupmessage();\r\n\tafx_msg void CQPasteWnd::OnFirstBackupDb();\r\n\tafx_msg void CQPasteWnd::OnFirstRestoreDb();\r\n\tafx_msg void OnMenuDeleteallnonusedclips();\r\n\tafx_msg void OnUpdateMenuDeleteallnonusedclips(CCmdUI* pCmdUI);\r\n\tafx_msg void OnImportSetdragfilename();\r\n\tafx_msg void OnUpdateImportSetdragfilename(CCmdUI* pCmdUI);\r\n\tafx_msg void OnSpecialpasteCamelcase();\r\n\tafx_msg void OnUpdateSpecialpasteCamelcase(CCmdUI* pCmdUI);\r\n\tafx_msg void OnSpecialpasteMultipleImagesHorz();\r\n\tafx_msg void OnUpdateSpecialpasteMultipleImagesHorz(CCmdUI* pCmdUI);\r\n\tafx_msg void OnSpecialpasteMultipleImagesVert();\r\n\tafx_msg void OnUpdateSpecialpasteMultipleImagesVert(CCmdUI* pCmdUI);\r\n\tafx_msg void OnSpecialpasteAsciitextonly();\r\n\tafx_msg void OnUpdateSpecialpasteAsciitextonly(CCmdUI* pCmdUI);\r\n};"
        },
        {
          "name": "QPasteWndThread.cpp",
          "type": "blob",
          "size": 13.0595703125,
          "content": "#include \"stdafx.h\"\r\n#include \"QPasteWndThread.h\"\r\n#include \"Misc.h\"\r\n#include \"Options.h\"\r\n#include \"QPasteWnd.h\"\r\n#include \"cp_main.h\"\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nCQPasteWndThread::CQPasteWndThread(void)\r\n{\r\n\tm_rowHeight = 0;\r\n\tm_threadName = \"CQPasteWndThread\";\r\n    m_waitTimeout = ONE_HOUR * 12;\r\n\r\n    m_SearchingEvent = CreateEvent(NULL, TRUE, FALSE, _T(\"\"));\r\n\r\n    for(int eventEnum = 0; eventEnum < ECQPASTEWNDTHREADEVENTS_COUNT; eventEnum++)\r\n    {\r\n        AddEvent(eventEnum);\r\n    }\r\n}\r\n\r\nCQPasteWndThread::~CQPasteWndThread(void)\r\n{\r\n    CloseHandle(m_SearchingEvent);\r\n}\r\n\r\nvoid CQPasteWndThread::OnTimeOut(void *param)\r\n{\r\n}\r\n\r\nvoid CQPasteWndThread::OnEvent(int eventId, void *param)\r\n{\r\n\tDWORD startTick = GetTickCount();\r\n\tLog(StrF(_T(\"Start of OnEvent, eventId: %s\"), EnumName((eCQPasteWndThreadEvents)eventId)));\r\n\r\n    switch((eCQPasteWndThreadEvents)eventId)\r\n    {\r\n        case DO_SET_LIST_COUNT:\r\n            OnSetListCount(param);\r\n            break;\r\n        case LOAD_ACCELERATORS:\r\n            OnLoadAccelerators(param);\r\n            break;\r\n        case UNLOAD_ACCELERATORS:\r\n            OnUnloadAccelerators(param);\r\n            break;\r\n        case LOAD_ITEMS:\r\n            OnLoadItems(param);\r\n            break;\r\n        case LOAD_EXTRA_DATA:\r\n            OnLoadExtraData(param);\r\n            break;\r\n    }\r\n\r\n\tDWORD length = GetTickCount() - startTick;\r\n\tLog(StrF(_T(\"End of OnEvent, eventId: %s, Time: %d(ms)\"), EnumName((eCQPasteWndThreadEvents)eventId), length));\r\n}\r\n\r\nvoid CQPasteWndThread::OnSetListCount(void *param)\r\n{\r\n    CQPasteWnd *pasteWnd = (CQPasteWnd*)param;\r\n\r\n    static CEvent UpdateTimeEvent(TRUE, TRUE, _T(\"Ditto_Update_Clip_Time\"), NULL);\r\n    //If we pasted then wait for the time on the pasted event to be updated before we query the db\r\n    DWORD dRet = WaitForSingleObject(UpdateTimeEvent, 2000);\r\n\r\n    ResetEvent(m_SearchingEvent);\r\n    long lTick = GetTickCount();\r\n\r\n\tCString countSQL = m_countSql;\r\n\r\n    long lRecordCount = 0;\r\n\r\n    try\r\n    {\r\n        lRecordCount = theApp.m_db.execScalar(countSQL);\r\n        ::PostMessage(pasteWnd->m_hWnd, NM_SET_LIST_COUNT, lRecordCount, 0);\r\n    }\r\n    CATCH_SQLITE_EXCEPTION \r\n\r\n    SetEvent(m_SearchingEvent);\r\n\r\n    Log(StrF(_T(\"Set list count = %d, time = %d\"), lRecordCount, GetTickCount() - lTick));\r\n}\r\n\r\nvoid CQPasteWndThread::OnLoadItems(void *param)\r\n{\r\n    CQPasteWnd *pasteWnd = (CQPasteWnd*)param;\r\n\r\n    ResetEvent(m_SearchingEvent);\r\n\r\n\twhile(true)\r\n\t{\r\n\t\tlong startTick = GetTickCount();\r\n\t    int loadItemsIndex = 0;\r\n\t    int loadItemsCount = 0;\r\n\t    int loadCount = 0;\r\n\t\tCString localSql = m_sql;\r\n\t    bool clearFirstLoadItem = false;\r\n\t\tbool firstLoad = false;\r\n\t\tint listSize = 0;\r\n\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t    if(pasteWnd->m_loadItems.size() > 0)\r\n\t\t    {\r\n\t\t\t\tfirstLoad = (pasteWnd->m_loadItems.begin()->x == -1);\r\n\t\t        loadItemsIndex = max(pasteWnd->m_loadItems.begin()->x, 0);\r\n\t\t        loadItemsCount = pasteWnd->m_loadItems.begin()->y - pasteWnd->m_loadItems.begin()->x;\r\n\t\t        pasteWnd->m_bStopQuery = false;\r\n\t\t\t\tlistSize = pasteWnd->m_listItems.size();\r\n\t\t        clearFirstLoadItem = true;\r\n\t\t    }\r\n\t\t}\r\n\r\n\t    if(clearFirstLoadItem)\r\n\t    {\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"Load Items start = %d, count = %d, list size: %d\"), loadItemsIndex, loadItemsCount, listSize));\r\n\r\n\t\t\t\tint pos = loadItemsIndex;\r\n\t\t\t\tCString limit;\r\n\t\t\t\tlimit.Format(_T(\" LIMIT %d OFFSET %d\"), loadItemsCount, loadItemsIndex);\r\n\t\t\t\tlocalSql += limit;\r\n\r\n\t\t\t\tCMainTable table;\r\n\r\n\t\t\t\tCppSQLite3Query q = theApp.m_db.execQuery(localSql);\r\n\t\t\t\twhile(!q.eof())\r\n\t\t\t\t{\r\n\t\t\t\t\tCQPasteWnd::FillMainTable(table, q);\r\n\r\n\t\t\t\t\tint updateIndex = -1;\r\n\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\t\t\t\tif (pos < pasteWnd->m_listItems.size())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tpasteWnd->m_listItems[pos] = table;\r\n\r\n\t\t\t\t\t\t\tupdateIndex = pos;\r\n\r\n\t\t\t\t\t\t\t//Log(StrF(_T(\"updating list pos = %d, id: %d, size: %d\"), pos, table.m_lID, pasteWnd->m_listItems.size() - 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (pos == pasteWnd->m_listItems.size())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tpasteWnd->m_listItems.push_back(table);\r\n\t\t\t\t\t\t\tupdateIndex = (int)pasteWnd->m_listItems.size() - 1;\r\n\t\t\t\t\t\t\t//Log(StrF(_T(\"adding (same size) list pos = %d, id: %d, size: %d\"), pasteWnd->m_listItems.size()-1, table.m_lID, pasteWnd->m_listItems.size() - 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (pos > pasteWnd->m_listItems.size())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfor (int toAdd = (int)pasteWnd->m_listItems.size()-1; toAdd < pos - 1; toAdd++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tCMainTable empty;\r\n\t\t\t\t\t\t\t\tempty.m_lID = -1;\r\n\t\t\t\t\t\t\t\tpasteWnd->m_listItems.push_back(empty);\r\n\r\n\t\t\t\t\t\t\t\t//Log(StrF(_T(\"adding dummy row size: %d\"), pasteWnd->m_listItems.size()-1));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpasteWnd->m_listItems.push_back(table);\r\n\r\n\t\t\t\t\t\t\tupdateIndex = (int)pasteWnd->m_listItems.size() - 1;\r\n\r\n\t\t\t\t\t\t\t//Log(StrF(_T(\"adding list pos = %d, id: %d, size: %d\"), pasteWnd->m_listItems.size()-1, table.m_lID, pasteWnd->m_listItems.size() - 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(pasteWnd->m_bStopQuery)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLog(StrF(_T(\"StopQuery called exiting filling cache count = %d\"), loadItemsIndex));\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tq.nextRow();\r\n\r\n\t\t\t\t\tif(firstLoad == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t/*if (updateIndex != loadItemsIndex)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tLog(StrF(_T(\"index difference old: %d, new: %d\"), loadItemsIndex, updateIndex));\r\n\t\t\t\t\t\t}*/\r\n\r\n\t            \t\t::PostMessage(pasteWnd->m_hWnd, NM_REFRESH_ROW, table.m_lID, updateIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tloadItemsIndex++;\r\n\t\t\t\t\tloadCount++;\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tDWORD loadCount = GetTickCount() - startTick;\r\n\t\t\t\tDWORD countCountStart = GetTickCount();\r\n\t\t\t\tDWORD countCount = 0;\r\n\t\t\t\tDWORD acceleratorCount = 0;\r\n\r\n\t\t\t\tif(firstLoad)\r\n\t\t\t\t{\r\n\t\t\t\t\t::PostMessage(pasteWnd->m_hWnd, NM_REFRESH_ROW, -2, 0);\r\n\t\t\t\t\t//allow the next thread message to process, this should be the message to set the list count\r\n\r\n\t\t\t\t\tOnSetListCount(param);\r\n\t\t\t\t\t\r\n\t\t\t\t\tcountCount = GetTickCount() - countCountStart;\r\n\t\t\t\t\tDWORD acceleratorCountStart = GetTickCount();\r\n\t\t\t\t\t \r\n\t\t\t\t\tOnLoadAccelerators(param);\r\n\r\n\t\t\t\t\tacceleratorCount = GetTickCount() - acceleratorCountStart;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t::PostMessage(pasteWnd->m_hWnd, NM_REFRESH_ROW, -1, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(clearFirstLoadItem)\r\n\t\t\t\t{\r\n\t\t\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\t\t\tpasteWnd->m_loadItems.erase(pasteWnd->m_loadItems.begin());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tLog(StrF(_T(\"Load items End count = %d, Total Time = %d, LoadItems: %d, Count: %d, Accel: %d\"), loadCount, GetTickCount() - startTick, loadCount, countCount, acceleratorCount));\r\n\t\t\t}\r\n\t\t\tcatch (CppSQLite3Exception& e)\t\\\r\n\t\t\t{\t\t\t\t\t\t\t\t\\\r\n\t\t\t\tLog(StrF(_T(\"ONLoadItems - SQLITE Exception %d - %s\"), e.errorCode(), e.errorMessage()));\t\\\r\n\t\t\t\tASSERT(FALSE);\t\t\t\t\\\r\n\t\t\t\tbreak;\r\n\t\t\t}\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n    SetEvent(m_SearchingEvent);\r\n}\r\n\r\nvoid ReduceMapItems(CF_DibTypeMap &mapItem, CCriticalSection &critSection, CString mapName)\r\n{\r\n\tATL::CCritSecLock csLock(critSection.m_sect);\r\n\r\n\tint maxSize = 50;\r\n\tint reduceToSize = 30;\r\n\r\n\tif (mapItem.size() > maxSize)\r\n\t{\r\n\t\t//create a vector so we can sort and keep the last x number of events\r\n\t\tvector<INT64> counterArray;\r\n\t\tfor (CF_DibTypeMap::iterator iterDib = mapItem.begin(); iterDib != mapItem.end(); iterDib++)\r\n\t\t{\r\n\t\t\tcounterArray.push_back(iterDib->second.m_counter);\r\n\t\t}\r\n\t\tstd::sort(counterArray.begin(), counterArray.end());\r\n\t\tcounterArray.erase(counterArray.begin(), counterArray.end() - reduceToSize);\r\n\r\n\t\t//remove the oldest x number if bitmaps\r\n\t\tfor (CF_DibTypeMap::iterator iterDib = mapItem.begin(); iterDib != mapItem.end();)\r\n\t\t{\r\n\t\t\tif (std::binary_search(counterArray.begin(), counterArray.end(), iterDib->second.m_counter) == false)\r\n\t\t\t{\r\n\t\t\t\tLog(StrF(_T(\"reduced size of %s cache, Id: %d, Row: %d\"), mapName, iterDib->second.m_parentId, iterDib->second.m_clipRow));\r\n\r\n\t\t\t\tmapItem.erase(iterDib++);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t++iterDib;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tLog(StrF(_T(\"reduced size of %s cache, count: %d\"), mapName, mapItem.size()));\r\n\t}\r\n}\r\n\r\nvoid CQPasteWndThread::OnLoadExtraData(void *param)\r\n{\r\n    ResetEvent(m_SearchingEvent);\r\n\r\n    CQPasteWnd *pasteWnd = (CQPasteWnd*)param;\r\n\r\n    Log(_T(\"Start of load extra data, Bitmaps/rtf\"));\r\n\r\n    std::list<CClipFormatQListCtrl> localFormats;\r\n\t{\r\n\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\tfor (std::list<CClipFormatQListCtrl>::iterator it = pasteWnd->m_ExtraDataLoadItems.begin(); it != pasteWnd->m_ExtraDataLoadItems.end(); it++)\r\n\t\t{\r\n\t\t\tlocalFormats.push_back(*it);\r\n\t\t}\r\n\t    pasteWnd->m_ExtraDataLoadItems.clear();\r\n\t}\r\n\t\r\n\tfor (std::list<CClipFormatQListCtrl>::iterator it = localFormats.begin(); it != localFormats.end(); it++)\r\n    {\r\n\t\tbool loadClip = true;\r\n\r\n\t\tif (it->m_cfType == CF_DIB)\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\tCF_DibTypeMap::iterator iterDib = pasteWnd->m_cf_dibCache.find(it->m_parentId);\r\n\t\t\tif (iterDib != pasteWnd->m_cf_dibCache.end())\r\n\t\t\t{\r\n\t\t\t\tloadClip = false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tCF_NoDibTypeMap::iterator iterNoDib = pasteWnd->m_cf_NO_dibCache.find(it->m_parentId);\r\n\t\t\t\tif (iterNoDib != pasteWnd->m_cf_NO_dibCache.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tloadClip = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (it->m_cfType == theApp.m_RTFFormat)\r\n\t\t{\r\n\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\tCF_DibTypeMap::iterator iterDib = pasteWnd->m_cf_rtfCache.find(it->m_parentId);\r\n\t\t\tif (iterDib != pasteWnd->m_cf_rtfCache.end())\r\n\t\t\t{\r\n\t\t\t\tloadClip = false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tCF_NoDibTypeMap::iterator iterNoRtf = pasteWnd->m_cf_NO_rtfCache.find(it->m_parentId);\r\n\t\t\t\tif (iterNoRtf != pasteWnd->m_cf_NO_rtfCache.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tloadClip = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (loadClip)\r\n\t\t{\r\n\t\t\tDWORD startLoadClipData = GetTickCount();\r\n\r\n\t\t\tBOOL foundClipData = theApp.GetClipData(it->m_parentId, *it);\r\n\t\t\tif (foundClipData == false &&\r\n\t\t\t\tit->m_cfType == CF_DIB)\r\n\t\t\t{\r\n\t\t\t\tit->Free();\r\n\t\t\t\tit->m_cfType = theApp.m_PNG_Format;\r\n\r\n\t\t\t\tfoundClipData = theApp.GetClipData(it->m_parentId, *it);\r\n\t\t\t}\r\n\r\n\t\t\tif (foundClipData)\r\n\t\t\t{\r\n\t\t\t\tDWORD timeTook = GetTickCount() - startLoadClipData;\r\n\t\t\t\tif (timeTook > 20)\r\n\t\t\t\t{\r\n\t\t\t\t\tLog(StrF(_T(\"GetClipData for clip %d, took: %d\"), it->m_parentId, timeTook));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (it->m_cfType == CF_DIB ||\r\n\t\t\t\t\tit->m_cfType == theApp.m_PNG_Format)\r\n\t\t\t\t{\r\n\t\t\t\t\tDWORD startConvertImage = GetTickCount();\r\n\r\n\t\t\t\t\tHDC dc = GetDC(NULL);\r\n\r\n\t\t\t\t\tit->GetDibFittingToHeight(CDC::FromHandle(dc), m_rowHeight);\r\n\r\n\t\t\t\t\tReleaseDC(NULL, dc);\r\n\r\n\t\t\t\t\tDWORD timeTook = GetTickCount() - startConvertImage;\r\n\t\t\t\t\tif (timeTook > 20)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLog(StrF(_T(\"GetDibFittingToHeight for clip %d, took: %d\"), it->m_parentId, GetTickCount() - startConvertImage));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\t\t\t\tpasteWnd->m_cf_dibCache[it->m_parentId] = *it;\r\n\t\t\t\t\t\t//the cache now owns the format data, set it to delete the data in the destructor\r\n\t\t\t\t\t\tpasteWnd->m_cf_dibCache[it->m_parentId].m_autoDeleteData = true;\r\n\r\n\t\t\t\t\t\tLog(StrF(_T(\"Loaded, extra data for clipId: %d, Row: %d image cache count: %d\"), it->m_parentId, it->m_clipRow, pasteWnd->m_cf_dibCache.size()));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (it->m_cfType == theApp.m_RTFFormat)\r\n\t\t\t\t{\r\n\t\t\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\t\t\tpasteWnd->m_cf_rtfCache[it->m_parentId] = *it;\r\n\t\t\t\t\tit->m_autoDeleteData = false;\r\n\t\t\t\t\t//the cache now owns the format data, set it to delete the data in the destructor\r\n\t\t\t\t\tpasteWnd->m_cf_rtfCache[it->m_parentId].m_autoDeleteData = true;\r\n\r\n\t\t\t\t\tLog(StrF(_T(\"Loaded, extra data for clip %d, rtf cache count: %d\"), it->m_parentId, pasteWnd->m_cf_rtfCache.size()));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t::PostMessage(pasteWnd->m_hWnd, NM_REFRESH_ROW, it->m_parentId, it->m_clipRow);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tATL::CCritSecLock csLock(pasteWnd->m_CritSection.m_sect);\r\n\r\n\t\t\t\tif (it->m_cfType == CF_DIB ||\r\n\t\t\t\t\tit->m_cfType == theApp.m_PNG_Format)\r\n\t\t\t\t{\r\n\t\t\t\t\tpasteWnd->m_cf_NO_dibCache[it->m_parentId] = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if (it->m_cfType == theApp.m_RTFFormat)\r\n\t\t\t\t{\r\n\t\t\t\t\tpasteWnd->m_cf_NO_rtfCache[it->m_parentId] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (it->m_cfType == CF_DIB)\r\n\t\t{\r\n\t\t\tReduceMapItems(pasteWnd->m_cf_dibCache, pasteWnd->m_CritSection, _T(\"image\"));\r\n\t\t}\r\n\t\telse if (it->m_cfType == theApp.m_RTFFormat)\r\n\t\t{\r\n\t\t\tReduceMapItems(pasteWnd->m_cf_rtfCache, pasteWnd->m_CritSection, _T(\"rtf\"));\r\n\t\t}\r\n    }\r\n\r\n    SetEvent(m_SearchingEvent);\r\n    Log(_T(\"End of load extra data, Bitmaps/rtf\"));\r\n}\r\n\r\nvoid CQPasteWndThread::OnLoadAccelerators(void *param)\r\n{\r\n    CQPasteWnd *pasteWnd = (CQPasteWnd*)param;\r\n    pasteWnd->m_lstHeader.DestroyAndCreateAccelerator(TRUE, theApp.m_db);\r\n}\r\n\r\nvoid CQPasteWndThread::OnUnloadAccelerators(void *param)\r\n{\r\n    CQPasteWnd *pasteWnd = (CQPasteWnd*)param;\r\n    pasteWnd->m_lstHeader.DestroyAndCreateAccelerator(FALSE, theApp.m_db);\r\n}\r\n\r\nCString CQPasteWndThread::EnumName(eCQPasteWndThreadEvents e)\r\n{\r\n\tswitch(e)\r\n\t{\r\n\tcase DO_SET_LIST_COUNT:\r\n\t\treturn _T(\"Load List Count\");\r\n\tcase LOAD_ACCELERATORS:\r\n\t\treturn _T(\"Load Accelerators\");\r\n\tcase UNLOAD_ACCELERATORS:\r\n\t\treturn _T(\"Unload Accelerators\");\r\n\tcase LOAD_ITEMS:\r\n\t\treturn _T(\"Load clips\");\r\n\tcase LOAD_EXTRA_DATA:\r\n\t\treturn _T(\"Load Extra Data (rtf/bitmaps)\");\r\n\t}\r\n\r\n\treturn _T(\"\");\r\n}"
        },
        {
          "name": "QPasteWndThread.h",
          "type": "blob",
          "size": 1.490234375,
          "content": "#pragma once\n#include \"EventThread.h\"\n#include \"sqlite/CppSQLite3.h\"\n\nclass CQPasteWndThread: public CEventThread\n{\npublic:\n    CQPasteWndThread(void);\n    ~CQPasteWndThread(void);\n\n    enum eCQPasteWndThreadEvents\n    {\n\t\tDO_SET_LIST_COUNT, \n\t\tLOAD_ACCELERATORS, \n\t\tUNLOAD_ACCELERATORS, \n\t\tLOAD_ITEMS, \n\t\tLOAD_EXTRA_DATA, \n\n        ECQPASTEWNDTHREADEVENTS_COUNT  //must be last\n\n    };\n\n    void FireSetListCount()\n    {\n        FireEvent(DO_SET_LIST_COUNT);\n    }\n    void FireLoadItems(bool firstLoad)\n    {\n        FireEvent(LOAD_ITEMS);\n    }\n    void FireLoadExtraData(int rowHeight)\n    {\n\t\tm_rowHeight = rowHeight;\n        FireEvent(LOAD_EXTRA_DATA);\n    }\n    void FireLoadAccelerators()\n    {\n        FireEvent(LOAD_ACCELERATORS);\n    }\n    void FireUnloadAccelerators()\n    {\n        FireEvent(UNLOAD_ACCELERATORS);\n    }\n\n    HANDLE m_SearchingEvent;\n\n\tvoid SetRowHeight(int height) { m_rowHeight = height; }\n    void SetSearchSql(CString sql, CString countSql) { m_sql = sql; m_countSql = countSql; }\n\nprotected:\n    virtual void OnEvent(int eventId, void *param);\n    virtual void OnTimeOut(void *param);\n\n    void OnSetListCount(void *param);\n    void OnLoadItems(void *param);\n    void OnLoadExtraData(void *param);\n\t//void ReduceMapItems(CF_DibTypeMap mapItem, CCriticalSection &critSection, CString mapName);\n    void OnLoadAccelerators(void *param);\n    void OnUnloadAccelerators(void *param);\n\n\tCString EnumName(eCQPasteWndThreadEvents e);\n\n\tint m_rowHeight;\n\n    CString m_sql;\n    CString m_countSql;\n};\n"
        },
        {
          "name": "QRCodeViewer.cpp",
          "type": "blob",
          "size": 7.78515625,
          "content": "// QRCodeViewer.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"QRCodeViewer.h\"\r\n#include \"MainTableFunctions.h\"\r\n\r\n#define TIMER_BUTTON_UP 1\r\n\r\n// QRCodeViewer\r\n\r\nIMPLEMENT_DYNAMIC(QRCodeViewer, CWnd)\r\n\r\nQRCodeViewer::QRCodeViewer()\r\n{\r\n\tm_descBackground = NULL;\r\n\r\n}\r\n\r\nQRCodeViewer::~QRCodeViewer()\r\n{\r\n\tif(m_descBackground != NULL)\r\n\t{\r\n\t\tDeleteObject(m_descBackground);\r\n\t}\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(QRCodeViewer, CWnd)\r\n\tON_WM_CREATE()\r\n\tON_WM_PAINT()\r\n\tON_WM_SIZE()\r\n\tON_WM_NCHITTEST()\r\n\tON_WM_NCPAINT()\r\n\tON_WM_NCCALCSIZE()\r\n\tON_WM_NCLBUTTONDOWN()\r\n\tON_WM_NCMOUSEMOVE()\r\n\tON_WM_NCLBUTTONUP()\r\n\tON_WM_ERASEBKGND()\r\n\tON_WM_CTLCOLOR()\r\n\tON_WM_WINDOWPOSCHANGING()\r\n\tON_WM_TIMER()\r\n\tON_MESSAGE(WM_DPICHANGED, OnDpiChanged)\r\n\tON_WM_MOVING()\r\n\tON_WM_ENTERSIZEMOVE()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\nBOOL QRCodeViewer::CreateEx(CWnd *pParentWnd, unsigned char* bitmapData, int imageSize, CString desc, int rowHeight, LOGFONT logFont)\r\n{\r\n\t// Get the class name and create the window\r\n\tCString szClassName = AfxRegisterWndClass(CS_CLASSDC | CS_SAVEBITS, LoadCursor(NULL, IDC_ARROW));\r\n\r\n\tm_bitmapData = bitmapData;\r\n\tm_imageSize = imageSize;\r\n\tm_descRowHeight = rowHeight;\r\n\tm_descBackground = CreateSolidBrush(RGB(255, 255, 255));\r\n\tm_logFont = logFont;\r\n\tm_originalFontHeight = logFont.lfHeight;\r\n\r\n\tif(CWnd::CreateEx(0, szClassName, _T(\"\"), WS_POPUP, 0, 0, 0, 0, NULL, 0, NULL))\r\n\t{\t\r\n\t\tBOOL r = m_desc.Create(CMainTableFunctions::GetDisplayText(CGetSetOptions::m_nLinesPerRow, desc), WS_CHILD|WS_VISIBLE, CRect(0,0,0,0), this, 2);\r\n\r\n\t\tm_font.CreateFontIndirect(&logFont);\r\n\t\tm_desc.SetFont(&m_font);\t\r\n\r\n\t\tm_DittoWindow.DoCreate(this);\r\n\t\tm_DittoWindow.SetCaptionColors(CGetSetOptions::m_Theme.CaptionLeft(), CGetSetOptions::m_Theme.CaptionRight(), CGetSetOptions::m_Theme.Border());\r\n\t\tm_DittoWindow.SetCaptionOn(this, CGetSetOptions::GetCaptionPos(), true, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\t\tm_DittoWindow.m_bDrawMinimize = false;\r\n\t\tm_DittoWindow.m_bDrawMaximize = true;\r\n\t\tm_DittoWindow.m_bDrawChevron = false;\r\n\t\tm_DittoWindow.m_sendWMClose = false;\r\n\r\n\t\tm_qrCodeDrawer.LoadRaw(m_bitmapData, m_imageSize);\r\n\r\n\t\tdelete[] m_bitmapData;\r\n\r\n\t\tCRect parentRect;\r\n\t\tpParentWnd->GetWindowRect(&parentRect);\r\n\r\n\t\tCRect rect;\r\n\t\trect.left = parentRect.left;\r\n\t\trect.top = parentRect.top;\r\n\r\n\t\trect.right = rect.left + m_DittoWindow.m_borderSize + m_DittoWindow.m_borderSize + m_qrCodeDrawer.ImageWidth() + (CGetSetOptions::GetQRCodeBorderPixels() * 2);\r\n\t\tif (m_DittoWindow.m_captionPosition == CAPTION_LEFT ||\r\n\t\t\tm_DittoWindow.m_captionPosition == CAPTION_RIGHT)\r\n\t\t{\r\n\t\t\trect.right += m_DittoWindow.m_captionBorderWidth;\r\n\t\t}\r\n\t\trect.bottom = rect.top + m_DittoWindow.m_borderSize + m_DittoWindow.m_borderSize + rowHeight + 5 + m_qrCodeDrawer.ImageHeight() + (CGetSetOptions::GetQRCodeBorderPixels() * 2);\r\n\t\t\r\n\t\tCRect center = CenterRect(rect);\r\n\r\n\t\tEnsureWindowVisible(&center);\r\n\r\n\t\t::MoveWindow(m_hWnd, center.left, center.top, center.Width(), center.Height(), TRUE);\r\n\r\n\t\tMoveControls();\r\n\r\n\t\tSetFocus();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdelete[] m_bitmapData;\r\n\t}\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid QRCodeViewer::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCWnd::OnSize(nType, cx, cy);\r\n\r\n\tthis->Invalidate();\r\n\r\n\tMoveControls();\r\n}\r\n\r\nvoid QRCodeViewer::MoveControls()\r\n{\r\n\tCRect crRect;\r\n\tGetClientRect(crRect);\r\n\tint cx = crRect.Width();\r\n\tint cy = crRect.Height();\r\n\r\n\tif(m_desc.m_hWnd != NULL)\r\n\t{\r\n\t\tm_desc.MoveWindow(m_DittoWindow.m_dpi.Scale(5), cy - m_DittoWindow.m_dpi.Scale(m_descRowHeight) - m_DittoWindow.m_dpi.Scale(5), cx - m_DittoWindow.m_dpi.Scale(10), m_DittoWindow.m_dpi.Scale(m_descRowHeight));\r\n\t}\r\n}\r\n\r\nvoid QRCodeViewer::OnPaint()\r\n{\r\n\tCPaintDC dc(this);\r\n\r\n\tCRect thisRect;\r\n\tGetClientRect(thisRect);\r\n\tthisRect.bottom -= m_DittoWindow.m_dpi.Scale(m_descRowHeight) - m_DittoWindow.m_dpi.Scale(5);\r\n\t\r\n\tint width = thisRect.Width() - (CGetSetOptions::GetQRCodeBorderPixels() * 2);\r\n\tint height = min(width, (thisRect.Height() - (CGetSetOptions::GetQRCodeBorderPixels() * 2)));\r\n\twidth = min(width, height);\r\n\t\t\r\n\tCRect imageRect(0, 0, width, height);\r\n\r\n\tCRect centerRect = CenterRectFromRect(imageRect, thisRect);\r\n\r\n\tm_qrCodeDrawer.Draw(&dc, m_DittoWindow.m_dpi, this, centerRect.left, centerRect.top, false, false, width, height);\r\n}\r\n\r\nBOOL QRCodeViewer::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\tm_DittoWindow.DoPreTranslateMessage(pMsg);\r\n\r\n\tswitch(pMsg->message)\r\n\t{\r\n\tcase WM_KEYDOWN:\r\n\r\n\t\tswitch(pMsg->wParam)\r\n\t\t{\r\n\t\tcase VK_ESCAPE:\r\n\t\t\t::SendMessage(m_hWnd, WM_CLOSE, 0, 0);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\treturn CWnd::PreTranslateMessage(pMsg);\r\n}\r\n\t\r\nvoid QRCodeViewer::PostNcDestroy()\r\n{\r\n    CWnd::PostNcDestroy();\r\n\r\n    delete this;\r\n}\r\n\r\nvoid QRCodeViewer::OnNcPaint()\r\n{\r\n\tm_DittoWindow.DoNcPaint(this);\r\n}\r\n\r\nvoid QRCodeViewer::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) \r\n{\r\n\tCWnd::OnNcCalcSize(bCalcValidRects, lpncsp);\r\n\r\n\tm_DittoWindow.DoNcCalcSize(bCalcValidRects, lpncsp);\r\n}\r\n\r\nHITTEST_RET QRCodeViewer::OnNcHitTest(CPoint point) \r\n{\r\n\tUINT Ret = m_DittoWindow.DoNcHitTest(this, point);\r\n\tif(Ret == -1)\r\n\t\treturn CWnd::OnNcHitTest(point);\r\n\r\n\treturn Ret;\r\n}\r\n\r\nBOOL QRCodeViewer::OnEraseBkgnd(CDC* pDC) \r\n{\r\n\tCRect rect;\r\n\tGetClientRect(&rect);\r\n\tCBrush myBrush(RGB(255, 255, 255));\r\n\tCBrush *pOld = pDC->SelectObject(&myBrush);\r\n\tBOOL bRes  = pDC->PatBlt(0, 0, rect.Width(), rect.Height(), PATCOPY);\r\n\tpDC->SelectObject(pOld);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid QRCodeViewer::OnNcLButtonDown(UINT nHitTest, CPoint point) \r\n{\r\n\tint buttonPressed = m_DittoWindow.DoNcLButtonDown(this, nHitTest, point);\r\n\r\n\tif (buttonPressed != 0)\r\n\t{\r\n\t\tSetTimer(TIMER_BUTTON_UP, 100, NULL);\r\n\t}\r\n\r\n\tCWnd::OnNcLButtonDown(nHitTest, point);\r\n}\r\n\r\nvoid QRCodeViewer::OnNcLButtonUp(UINT nHitTest, CPoint point) \r\n{\r\n\tlong lRet = m_DittoWindow.DoNcLButtonUp(this, nHitTest, point);\r\n\r\n\tswitch(lRet)\r\n\t{\r\n\tcase BUTTON_CLOSE:\r\n\t\t::PostMessage(m_hWnd, WM_CLOSE, 0, 0);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tKillTimer(TIMER_BUTTON_UP);\r\n\r\n\tCWnd::OnNcLButtonUp(nHitTest, point);\r\n}\r\n\r\nvoid QRCodeViewer::OnNcMouseMove(UINT nHitTest, CPoint point) \r\n{\r\n\tm_DittoWindow.DoNcMouseMove(this, nHitTest, point);\r\n\r\n\tCWnd::OnNcMouseMove(nHitTest, point);\r\n}\r\n\r\nHBRUSH QRCodeViewer::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\r\n{\r\n\tHBRUSH hbr = CWnd::OnCtlColor(pDC, pWnd, nCtlColor);\r\n\tif(pWnd->GetDlgCtrlID() == 2)\r\n\t{\r\n\t\tpDC->SetBkColor(RGB(255,255,255));\r\n\r\n\t\treturn m_descBackground;\r\n\t}\r\n\r\n\t// TODO:  Return a different brush if the default is not desired\r\n\treturn hbr;\r\n}\r\nvoid QRCodeViewer::OnWindowPosChanging(WINDOWPOS* lpwndpos)\r\n{\r\n\tCWnd::OnWindowPosChanging(lpwndpos);\r\n}\r\n\r\nvoid QRCodeViewer::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\tswitch (nIDEvent)\r\n\t{\r\n\t\tcase TIMER_BUTTON_UP:\r\n\t\t{\r\n\t\t\tif ((GetKeyState(VK_LBUTTON) & 0x100) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_DittoWindow.DoNcLButtonUp(this, 0, CPoint(0, 0));\r\n\t\t\t\tKillTimer(TIMER_BUTTON_UP);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tCWnd::OnTimer(nIDEvent);\r\n}\r\n\r\nLRESULT QRCodeViewer::OnDpiChanged(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tint dpi = HIWORD(wParam);\r\n\tm_DittoWindow.OnDpiChanged(this, dpi);\r\n\r\n\tRECT* const prcNewWindow = (RECT*)lParam;\r\n\tSetWindowPos(NULL,\r\n\t\tprcNewWindow->left,\r\n\t\tprcNewWindow->top,\r\n\t\tprcNewWindow->right - prcNewWindow->left,\r\n\t\tprcNewWindow->bottom - prcNewWindow->top,\r\n\t\tSWP_NOZORDER | SWP_NOACTIVATE);\r\n\r\n\tlog(StrF(_T(\"QRCodeViewer::OnDpiChanged dpi: %d width: %d, height: %d\"), dpi, (prcNewWindow->right - prcNewWindow->left), (prcNewWindow->bottom - prcNewWindow->top)));\r\n\r\n\tMoveControls();\r\n\r\n\tm_logFont.lfHeight = m_DittoWindow.m_dpi.Scale(m_originalFontHeight);\r\n\r\n\tm_font.DeleteObject();\r\n\tm_font.CreateFontIndirect(&m_logFont);\r\n\tm_desc.SetFont(&m_font);\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid QRCodeViewer::OnMoving(UINT fwSide, LPRECT pRect)\r\n{\r\n\tCWnd::OnMoving(fwSide, pRect);\r\n\tm_snap.OnSnapMoving(m_hWnd, pRect);\r\n}\r\n\r\nvoid QRCodeViewer::OnEnterSizeMove()\r\n{\r\n\tm_snap.OnSnapEnterSizeMove(m_hWnd);\r\n\tCWnd::OnEnterSizeMove();\r\n}"
        },
        {
          "name": "QRCodeViewer.h",
          "type": "blob",
          "size": 1.572265625,
          "content": "#pragma once\n\n#include \"GdipButton.h\"\n#include \"DittoWindow.h\"\n#include \"SnapWindow.h\"\n// QRCodeViewer\n\nclass QRCodeViewer : public CWnd\n{\n\tDECLARE_DYNAMIC(QRCodeViewer)\n\npublic:\n\tQRCodeViewer();\n\tvirtual void PostNcDestroy();\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\tvirtual ~QRCodeViewer();\n\n\tCDittoWindow m_DittoWindow;\n\tBOOL CreateEx(CWnd *pParentWnd, unsigned char* bitmapData, int imageSize, CString desc, int rowHeight, LOGFONT font);\n\n\tCStatic m_desc;\n\nprotected:\n\tafx_msg HITTEST_RET OnNcHitTest(CPoint point);\n\tafx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);\n\tafx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point); \n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point); \n\tafx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp); \n\tafx_msg void OnNcPaint();\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnPaint();\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\n\tafx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\tafx_msg LRESULT OnDpiChanged(WPARAM wParam, LPARAM lParam);\n\tafx_msg void OnMoving(UINT fwSide, LPRECT pRect);\n\tafx_msg void OnEnterSizeMove();\n\n\tunsigned char* m_bitmapData;\n\tint m_imageSize;\n\tCGdipButton m_ShowGroupsFolderBottom;\n\tCGdiImageDrawer m_qrCodeDrawer;\n\tint m_descRowHeight;\n\tCFont m_font;\n\tHBRUSH m_descBackground;\n\tLOGFONT m_logFont;\n\tint m_originalFontHeight;\n\tSnapWindow m_snap;\n\n\tvoid MoveControls();\n};\n\n\n"
        },
        {
          "name": "QuickPaste.cpp",
          "type": "blob",
          "size": 8.5732421875,
          "content": "// QuickPaste.cpp: implementation of the CQuickPaste class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"QuickPaste.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n#define ID_QPASTE_WND\t\t\t0x1001\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nCQuickPaste::CQuickPaste()\r\n{\r\n\tm_forceResizeOnNextShow = false;\r\n\tm_pwndPaste = NULL;\r\n}\r\n\r\nCQuickPaste::~CQuickPaste()\r\n{\r\n\tif(m_pwndPaste)\r\n\t{\r\n\t\tdelete m_pwndPaste;\r\n\t\tm_pwndPaste = NULL;\r\n\t}\t\r\n}\r\n\r\nvoid CQuickPaste::Create(CWnd *pParent)\r\n{\r\n\tCPoint point;\r\n\tCSize csSize;\r\n\t\r\n\tASSERT(!m_pwndPaste);\r\n\tm_pwndPaste = new CQPasteWnd;\r\n\tASSERT(m_pwndPaste);\r\n\t// load previous position and size\r\n\tCGetSetOptions::GetQuickPastePoint(point);\r\n\tCGetSetOptions::GetQuickPasteSize(csSize);\r\n\r\n\tCRect crRect = CRect(point, csSize);\r\n\t// Create the window\r\n\tASSERT( m_pwndPaste->Create(crRect, pParent) );\r\n\t// place it at the previous position and size\r\n\tm_pwndPaste->MoveWindow(CRect(point, csSize));\r\n\r\n\tLog(_T(\"Creating QPasteWnd\"));\r\n}\r\n\r\nBOOL CQuickPaste::CloseQPasteWnd()\r\n{\r\n\tif(m_pwndPaste)\r\n\t{\t\t\r\n\t\tif(m_pwndPaste)\r\n\t\t{\r\n\t\t\tm_pwndPaste->CloseWindow();\r\n\t\t\tm_pwndPaste->DestroyWindow();\r\n\t\t}\r\n\r\n\t\tLog(_T(\"CloseQPasteWnd called closing qpastewnd\"));\r\n\t\t\r\n\t\tdelete m_pwndPaste;\r\n\t\tm_pwndPaste = NULL;\r\n\r\n\t\ttheApp.m_bShowingQuickPaste = false;\r\n\t}\r\n\t\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CQuickPaste::ShowQPasteWnd(CWnd *pParent, bool bAtPrevPos, bool bFromKeyboard, BOOL bReFillList)\r\n{\t\t\r\n\tLog(StrF(_T(\"Start of ShowQPasteWnd, AtPrevPos: %d, FromKeyboard: %d, RefillList: %d\"), bAtPrevPos, bFromKeyboard, bReFillList));\r\n\r\n\tif(bFromKeyboard == false && GetKeyState(VK_SHIFT) & 0x8000 && CONTROL_PRESSED)\r\n\t{\r\n\t\tif(m_pwndPaste)\r\n\t\t{\r\n\t\t\tm_pwndPaste->CloseWindow();\r\n\t\t\tm_pwndPaste->DestroyWindow();\r\n\t\t}\r\n\r\n\t\tLog(_T(\"CloseQPasteWnd called closing qpastewnd from keyboard\"));\r\n\r\n\t\tdelete m_pwndPaste;\r\n\t\tm_pwndPaste = NULL;\r\n\r\n\t\ttheApp.m_db.close();\r\n\t\tOpenDatabase(CGetSetOptions::GetDBPath());\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tif(CGetSetOptions::m_bShowPersistent && m_pwndPaste != NULL)\r\n\t{\r\n\t\tm_pwndPaste->ShowWindow(SW_SHOW);\r\n\t\tm_pwndPaste->MinMaxWindow(FORCE_MAX);\r\n\t\tm_pwndPaste->SetForegroundWindow();\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tint nPosition = CGetSetOptions::GetQuickPastePosition();\r\n\t\r\n\tCPoint point;\r\n\tCRect rcPrev;\r\n\tCSize csSize;\r\n\t\r\n\tif(!m_pwndPaste)\r\n\t\tm_pwndPaste = new CQPasteWnd;\r\n\t\r\n\tif(!m_pwndPaste)\r\n\t{\r\n\t\tASSERT(FALSE);\r\n\t\treturn;\r\n\t}\r\n\r\n\tm_pwndPaste->MinMaxWindow(FORCE_MAX);\r\n\t\r\n\t//If it is a window get the rect otherwise get the saved point and size\r\n\tif (IsWindow(m_pwndPaste->m_hWnd) &&\r\n\t\tm_pwndPaste->IsIconic() == FALSE &&\r\n\t\tm_forceResizeOnNextShow == false)\r\n\t{\r\n\t\tm_pwndPaste->GetWindowRect(rcPrev);\r\n\t\tcsSize = rcPrev.Size();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCGetSetOptions::GetQuickPastePoint(point);\r\n\t\tCGetSetOptions::GetQuickPasteSize(csSize);\r\n\r\n\t\tif (IsWindow(m_pwndPaste->m_hWnd))\r\n\t\t{\r\n\t\t\tcsSize.cx = m_pwndPaste->m_DittoWindow.m_dpi.Scale(csSize.cx);\r\n\t\t\tcsSize.cy = m_pwndPaste->m_DittoWindow.m_dpi.Scale(csSize.cy);\r\n\t\t}\r\n\t}\r\n\r\n\tCPoint ptCaret = theApp.m_activeWnd.FocusCaret();\r\n\tif(ptCaret.x == -1 || ptCaret.y == -1)\r\n\t{\r\n\t\tCRect cr;\r\n\t\t::GetWindowRect(theApp.m_activeWnd.ActiveWnd(), cr);\r\n\t\t\r\n\t\tif(theApp.m_activeWnd.DesktopHasFocus() == false &&\r\n\t\t\tcr.Width() > 0 && \r\n\t\t\tcr.Height() > 0)\r\n\t\t{\r\n\t\t\tptCaret = cr.CenterPoint();\r\n\t\t\tptCaret.x -= csSize.cx/2;\r\n\t\t\tptCaret.y -= csSize.cy/2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tGetCursorPos(&point);\r\n\r\n\t\t\tCRect crPoint(point, CSize(1, 1));\r\n\r\n\t\t\tCRect crMonitor = MonitorRectFromRect(crPoint);\r\n\r\n\t\t\tptCaret = crMonitor.CenterPoint();\r\n\t\t\tptCaret.x -= csSize.cx/2;\r\n\t\t\tptCaret.y -= csSize.cy/2;\r\n\t\t}\r\n\t}\r\n\t\r\n\tif(bAtPrevPos)\r\n\t{\r\n\t\tCGetSetOptions::GetQuickPastePoint(point);\r\n\t\tCGetSetOptions::GetQuickPasteSize(csSize);\r\n\t}\r\n\telse if (nPosition == POS_AT_CARET)\r\n\t{\r\n\t\tpoint = ptCaret;\r\n\t\tif (CGetSetOptions::m_centerWindowBelowCursorOrCaret)\r\n\t\t{\r\n\t\t\tpoint.x -= csSize.cx / 2;\r\n\t\t}\r\n\t}\r\n\telse if (nPosition == POS_AT_CURSOR)\r\n\t{\r\n\t\tGetCursorPos(&point);\r\n\t\t//keep the mouse from showing the tooltip because if overlaps with the top corner\r\n\t\tpoint.x += 2;\r\n\t\tpoint.y += 2;\r\n\r\n\t\tif (CGetSetOptions::m_centerWindowBelowCursorOrCaret)\r\n\t\t{\r\n\t\t\tpoint.x -= csSize.cx / 2;\r\n\t\t}\r\n\t}\r\n\telse if(nPosition == POS_AT_PREVIOUS)\r\n\t\tCGetSetOptions::GetQuickPastePoint(point);\r\n\r\n\tCRect crRect = CRect(point, csSize);\r\n\r\n\tbool forceMoveWindow = m_forceResizeOnNextShow;\r\n\r\n\tif(CGetSetOptions::m_bEnsureEntireWindowCanBeSeen)\r\n\t{\r\n\t\tif(EnsureWindowVisible(&crRect))\r\n\t\t{\r\n\t\t\tforceMoveWindow = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\tif((crRect.left >= (crRect.right - 20)) ||\r\n\t\t(crRect.top >= (crRect.bottom - 20)))\r\n\t{\r\n\t\tCRect orig = crRect;\r\n\t\tcrRect = CRect(ptCaret, CSize(300, 300));\r\n\t\tforceMoveWindow = true;\r\n\r\n\t\tLog(StrF(_T(\"Invalid initial size %d %d %d %d, Centered Window %d %d %d %d\"), orig.left, orig.top, orig.right, orig.bottom, crRect.left, crRect.top, crRect.right, crRect.bottom));\r\n\t}\t\r\n\t\r\n\tbool adjustRect = false;\r\n\r\n\tif( !IsWindow(m_pwndPaste->m_hWnd) )\r\n\t{\r\n\t\tCWnd *pLocalParent = pParent;\r\n\r\n\t\tif(CGetSetOptions::GetShowInTaskBar())\r\n\t\t{\r\n\t\t\tpLocalParent = NULL;\r\n\t\t}\r\n\r\n\t\tVERIFY( m_pwndPaste->Create(crRect, pLocalParent) );\r\n\r\n\t\tadjustRect = true;\r\n\t}\t\r\n\r\n\t//If minimized\r\n\tif (m_pwndPaste->IsIconic())\r\n\t{\r\n\t\tm_pwndPaste->ShowWindow(SW_RESTORE);\r\n\r\n\t\tif ((nPosition == POS_AT_CARET) ||\r\n\t\t\t(nPosition == POS_AT_CURSOR) ||\r\n\t\t\tbAtPrevPos ||\r\n\t\t\tforceMoveWindow)\r\n\t\t{\r\n\t\t\tif (adjustRect)\r\n\t\t\t{\r\n\t\t\t\tcrRect.right = crRect.left + m_pwndPaste->m_DittoWindow.m_dpi.Scale(crRect.Width());\r\n\t\t\t\tcrRect.bottom = crRect.top + m_pwndPaste->m_DittoWindow.m_dpi.Scale(crRect.Height());\r\n\r\n\t\t\t\tif (CGetSetOptions::m_bEnsureEntireWindowCanBeSeen)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnsureWindowVisible(&crRect);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tm_pwndPaste->MoveWindow(crRect);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((nPosition == POS_AT_CARET) ||\r\n\t\t\t(nPosition == POS_AT_CURSOR) ||\r\n\t\t\tbAtPrevPos ||\r\n\t\t\tforceMoveWindow)\r\n\t\t{\r\n\t\t\tif (adjustRect)\r\n\t\t\t{\r\n\t\t\t\tcrRect.right = crRect.left + m_pwndPaste->m_DittoWindow.m_dpi.Scale(crRect.Width());\r\n\t\t\t\tcrRect.bottom = crRect.top + m_pwndPaste->m_DittoWindow.m_dpi.Scale(crRect.Height());\r\n\r\n\t\t\t\tif (CGetSetOptions::m_bEnsureEntireWindowCanBeSeen)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnsureWindowVisible(&crRect);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pwndPaste->MoveWindow(crRect);\r\n\t\t}\r\n\r\n\r\n\t\t// Show the window\r\n\t\tm_pwndPaste->ShowWindow(SW_SHOW);\r\n\t}\t\r\n\r\n\tm_pwndPaste->SetKeyModiferState(bFromKeyboard);\t\r\n\r\n\tif(bReFillList)\r\n\t{\r\n\t\tm_pwndPaste->ShowQPasteWindow(bReFillList);\r\n\t}\r\n\tm_pwndPaste->SetForegroundWindow();\r\n\r\n\tLog(StrF(_T(\"END of ShowQPasteWnd, AtPrevPos: %d, FromKeyboard: %d, RefillList: %d, Position, %d %d %d %d\"), bAtPrevPos, bFromKeyboard, bReFillList, crRect.left, crRect.top, crRect.right, crRect.bottom));\r\n\r\n\tm_forceResizeOnNextShow = false;\r\n}\r\n\r\nvoid CQuickPaste::MoveSelection(bool down)\r\n{\r\n\tif(m_pwndPaste && CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tif (IsWindow(m_pwndPaste->m_hWnd))\r\n\t\t{\r\n\t\t\tm_pwndPaste->MoveSelection(down, true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQuickPaste::OnKeyStateUp()\r\n{\r\n\tif(m_pwndPaste && CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tif (IsWindow(m_pwndPaste->m_hWnd))\r\n\t\t{\r\n\t\t\tm_pwndPaste->OnKeyStateUp();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQuickPaste::SetKeyModiferState(bool bActive)\r\n{\r\n\tif(m_pwndPaste && CGetSetOptions::m_moveSelectionOnOpenHotkey)\r\n\t{\r\n\t\tif (IsWindow(m_pwndPaste->m_hWnd))\r\n\t\t{\r\n\t\t\tm_pwndPaste->SetKeyModiferState(bActive);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CQuickPaste::HideQPasteWnd()\r\n{\r\n\t// Hide the window\r\n\tif(m_pwndPaste)\r\n\t{\r\n\t\tif (IsWindow(m_pwndPaste->m_hWnd))\r\n\t\t\tm_pwndPaste->HideQPasteWindow(true);\r\n\t}\r\n}\r\n\r\nBOOL CQuickPaste::IsWindowVisibleEx()\r\n{\r\n\tif(m_pwndPaste)\r\n\t\treturn IsWindowVisible(m_pwndPaste->m_hWnd);\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nbool CQuickPaste::IsWindowTopLevel()\r\n{\r\n\tif(m_pwndPaste)\r\n\t{\r\n\t\treturn ::GetForegroundWindow() == m_pwndPaste->GetSafeHwnd();\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid CQuickPaste::OnScreenResolutionChange()\r\n{\r\n\tif(m_pwndPaste != NULL &&\r\n\t\t::IsWindow(m_pwndPaste->m_hWnd) &&\r\n\t\tm_pwndPaste->IsIconic() == FALSE &&\r\n\t\tIsWindowVisibleEx())\r\n\t{\r\n\t\tLog(StrF(_T(\"Window Position changed, moving window to position as of this screen resolution %dx%d\"), GetScreenWidth(), GetScreenHeight()));\r\n\t\tCPoint point;\r\n\t\tCSize csSize;\r\n\r\n\t\tCGetSetOptions::GetQuickPastePoint(point);\r\n\t\tCGetSetOptions::GetQuickPasteSize(csSize);\r\n\r\n\t\tcsSize.cx = m_pwndPaste->m_DittoWindow.m_dpi.Scale(csSize.cx);\r\n\t\tcsSize.cy = m_pwndPaste->m_DittoWindow.m_dpi.Scale(csSize.cy);\r\n\r\n\t\tm_pwndPaste->MoveWindow(point.x, point.y, csSize.cx, csSize.cy);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_forceResizeOnNextShow = true;\r\n\t}\r\n}"
        },
        {
          "name": "QuickPaste.h",
          "type": "blob",
          "size": 1.0068359375,
          "content": "// QuickPaste.h: interface for the CQuickPaste class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_QUICKPASTE_H__1B4A98E6_B719_402C_BDD4_7F3F97CD0EB0__INCLUDED_)\n#define AFX_QUICKPASTE_H__1B4A98E6_B719_402C_BDD4_7F3F97CD0EB0__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include \"QPasteWnd.h\"\n\nclass CQuickPaste  \n{\npublic:\n\tCQuickPaste();\n\tvirtual ~CQuickPaste();\n\n\tvoid Create(CWnd *pParent);\n\tvoid ShowQPasteWnd(CWnd *pParent, bool bAtPrevPos, bool bFromKeyboard, BOOL bReFillList);\n\tvoid HideQPasteWnd();\n\tBOOL CloseQPasteWnd();\n\tBOOL IsWindowVisibleEx();\n\tvoid MoveSelection(bool down);\n\tvoid OnKeyStateUp();\n\tvoid SetKeyModiferState(bool bActive);\n\tbool IsWindowTopLevel();\n\n\tvoid UpdateFont()\t\t{ if(m_pwndPaste) m_pwndPaste->UpdateFont();\t}\n\n\tvoid OnScreenResolutionChange();\n\n//protected:\n\tCQPasteWnd *m_pwndPaste;\n\nprotected:\n\tbool m_forceResizeOnNextShow;\n\n};\n\n#endif // !defined(AFX_QUICKPASTE_H__1B4A98E6_B719_402C_BDD4_7F3F97CD0EB0__INCLUDED_)\n"
        },
        {
          "name": "QuickPasteKeyboard.cpp",
          "type": "blob",
          "size": 27.6318359375,
          "content": "// QuickPasteKeyboard.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"QuickPasteKeyboard.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"ActionEnums.h\"\r\n#include \"HotKeys.h\"\r\n\r\n// CQuickPasteKeyboard dialog\r\n\r\nIMPLEMENT_DYNAMIC(CQuickPasteKeyboard, CPropertyPage)\r\n\r\nCQuickPasteKeyboard::CQuickPasteKeyboard()\r\n\t: CPropertyPage(CQuickPasteKeyboard::IDD)\r\n{\r\n\tm_csTitle = theApp.m_Language.GetString(\"QuickPasteKeyboardTitle\", \"Quick Paste Keyboard\");\r\n\tm_psp.pszTitle = m_csTitle;\r\n\tm_psp.dwFlags |= PSP_USETITLE;\r\n}\r\n\r\nCQuickPasteKeyboard::~CQuickPasteKeyboard()\r\n{\r\n}\r\n\r\nvoid CQuickPasteKeyboard::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCPropertyPage::DoDataExchange(pDX);\r\n\tDDX_Control(pDX, IDC_LIST1, m_list);\r\n\tDDX_Control(pDX, IDC_HOTKEY1, m_hotKey1);\r\n\tDDX_Control(pDX, IDC_HOTKEY2, m_hotKey2);\r\n\tDDX_Control(pDX, IDC_COMBO_ALL_ASSIGNED, m_assignedCombo);\r\n\tDDX_Control(pDX, IDC_MOUSE_1, m_mouseType1);\r\n\tDDX_Control(pDX, IDC_MOUSE_2, m_mouseType2);\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CQuickPasteKeyboard, CPropertyPage)\r\n\tON_NOTIFY(LVN_ITEMACTIVATE, IDC_LIST1, &CQuickPasteKeyboard::OnLvnItemActivateList1)\r\n\tON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST1, &CQuickPasteKeyboard::OnLvnItemchangedList1)\r\n\tON_BN_CLICKED(IDC_ASSIGN, &CQuickPasteKeyboard::OnBnClickedAssign)\r\n\tON_CBN_SELCHANGE(IDC_COMBO_ALL_ASSIGNED, &CQuickPasteKeyboard::OnCbnSelchangeComboAllAssigned)\r\n\tON_BN_CLICKED(IDC_BUTTON_REMOVE, &CQuickPasteKeyboard::OnBnClickedButtonRemove)\r\n\tON_BN_CLICKED(IDC_BUTTON_ADD, &CQuickPasteKeyboard::OnBnClickedButtonAdd)\r\n\tON_CBN_KILLFOCUS(IDC_COMBO_ENTER_MODIFIER, &CQuickPasteKeyboard::OnCbnKillfocusComboEnterModifier)\r\n\tON_EN_KILLFOCUS(IDC_HOTKEY1, &CQuickPasteKeyboard::OnEnKillfocusEdit1)\r\n\tON_WM_KILLFOCUS()\r\n\tON_BN_CLICKED(IDC_BUTTON_ENTER, &CQuickPasteKeyboard::OnBnClickedButtonEnter)\r\n\tON_BN_CLICKED(IDC_BUTTON_ENTER2, &CQuickPasteKeyboard::OnBnClickedButtonEnter2)\r\n\tON_WM_KEYUP()\r\n\tON_BN_CLICKED(IDC_BUTTON_RESET, &CQuickPasteKeyboard::OnBnClickedButtonReset)\r\n\tON_BN_CLICKED(IDC_RADIO_KEYBOARD_1, &CQuickPasteKeyboard::OnBnClickedRadioKeyboard1)\r\n\tON_BN_CLICKED(IDC_RADIO_MOUSE_1, &CQuickPasteKeyboard::OnBnClickedRadioMouse1)\r\n\tON_BN_CLICKED(IDC_RADIO_KEYBOARD_2, &CQuickPasteKeyboard::OnBnClickedRadioKeyboard2)\r\n\tON_BN_CLICKED(IDC_RADIO_MOUSE_2, &CQuickPasteKeyboard::OnBnClickedRadioMouse2)\r\n\tON_BN_CLICKED(IDC_CHECK_ENABLE_SECOND_PRESS, &CQuickPasteKeyboard::OnBnClickedCheckEnableSecondPress)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CQuickPasteKeyboard message handlers\r\n\r\n\r\nBOOL CQuickPasteKeyboard::OnInitDialog()\r\n{\r\n\tCPropertyPage::OnInitDialog();\r\n\r\n\tInitListCtrlCols();\r\n\tLoadItems();\r\n\r\n\tint pos = m_mouseType1.AddString(_T(\"Click\"));\r\n\tm_mouseType1.SetItemData(pos, VK_MOUSE_CLICK);\r\n\r\n\tpos = m_mouseType1.AddString(_T(\"Double Click\"));\r\n\tm_mouseType1.SetItemData(pos, VK_MOUSE_DOUBLE_CLICK);\r\n\r\n\tpos = m_mouseType1.AddString(_T(\"Right Click\"));\r\n\tm_mouseType1.SetItemData(pos, VK_MOUSE_RIGHT_CLICK);\r\n\r\n\tpos = m_mouseType1.AddString(_T(\"Middle Click\"));\r\n\tm_mouseType1.SetItemData(pos, VK_MOUSE_MIDDLE_CLICK);\r\n\r\n\tpos = m_mouseType2.AddString(_T(\"Click\"));\r\n\tm_mouseType2.SetItemData(pos, VK_MOUSE_CLICK);\r\n\r\n\tpos = m_mouseType2.AddString(_T(\"Double Click\"));\r\n\tm_mouseType2.SetItemData(pos, VK_MOUSE_DOUBLE_CLICK);\r\n\r\n\tpos = m_mouseType2.AddString(_T(\"Right Click\"));\r\n\tm_mouseType2.SetItemData(pos, VK_MOUSE_RIGHT_CLICK);\r\n\r\n\tpos = m_mouseType2.AddString(_T(\"Middle Click\"));\r\n\tm_mouseType2.SetItemData(pos, VK_MOUSE_MIDDLE_CLICK);\r\n\r\n\tm_mouseType1.SetCurSel(0);\r\n\tm_mouseType2.SetCurSel(0);\r\n\r\n\t//SetWindowText(_T(\"Quick Paste Shortcuts\"));\r\n\r\n\ttheApp.m_Language.UpdateOptionQuickPasteKeyboard(this);\r\n\r\n\treturn TRUE;  // return TRUE unless you set the focus to a control\r\n\t// EXCEPTION: OCX Property Pages should return FALSE\r\n}\r\n\r\nvoid CQuickPasteKeyboard::InitListCtrlCols()\r\n{\r\n\tm_list.SetExtendedStyle(LVS_EX_FULLROWSELECT);\r\n\r\n\tm_list.InsertColumn(0, theApp.m_Language.GetString(\"QPHotKey\", \"Hot Key\"), LVCFMT_LEFT, 150);\r\n\tm_list.InsertColumn(1, theApp.m_Language.GetString(\"QPCommand\", \"Command\"), LVCFMT_LEFT, 350);\r\n}\r\n\r\nint CALLBACK MyCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)\r\n{\r\n\tCListCtrl* pListCtrl = (CListCtrl*)lParamSort;\r\n\r\n\tLVFINDINFO pInfo1, pInfo2;\r\n\tpInfo1.flags = LVFI_PARAM;\r\n\tpInfo2.flags = LVFI_PARAM;\r\n\tpInfo1.lParam = lParam1;\r\n\tpInfo2.lParam = lParam2;\r\n\tint ind1 = pListCtrl->FindItem(&pInfo1);\r\n\tint ind2 = pListCtrl->FindItem(&pInfo2);\r\n\tCString strItem1 = pListCtrl->GetItemText(ind1, 1);\r\n\tCString strItem2 = pListCtrl->GetItemText(ind2, 1);\r\n\r\n\treturn strItem1.CompareNoCase(strItem2);\r\n}\r\n\r\nvoid CQuickPasteKeyboard::LoadItems()\r\n{\r\n\tm_list.DeleteAllItems();\r\n\r\n\t// Use the LV_ITEM structure to insert the items\r\n\tLVITEM lvi;\r\n\tCString strItem;\r\n\tint row = 0;\r\n\r\n\tfor (DWORD i = ActionEnums::FIRST_ACTION + 1; i < ActionEnums::LAST_ACTION; i++)\r\n\t{\r\n\t\tActionEnums::ActionEnumValues action = (ActionEnums::ActionEnumValues) i;\r\n\r\n\t\tif (ActionEnums::UserConfigurable(action))\r\n\t\t{\r\n\t\t\t// Insert the first item\r\n\t\t\tlvi.mask = LVIF_TEXT;\r\n\t\t\tlvi.iItem = (int) i;\r\n\r\n\t\t\tKeyboardArray ar;\r\n\t\t\tfor (int x = 0; x < 10; x++)\r\n\t\t\t{\r\n\t\t\t\tar.Array[x].A = CGetSetOptions::GetActionShortCutA(action, x);\r\n\t\t\t\tar.Array[x].B = CGetSetOptions::GetActionShortCutB(action, x);\r\n\t\t\t}\r\n\r\n\t\t\tCString shortCutText = GetShortCutText(ar);\r\n\r\n\t\t\tlvi.iSubItem = 0;\r\n\t\t\tlvi.pszText = (LPTSTR) (LPCTSTR) (shortCutText);\r\n\t\t\tm_list.InsertItem(&lvi);\r\n\r\n\t\t\tCString col2 = ActionEnums::EnumDescription(action);\r\n\t\t\tm_list.SetItemText(row, 1, col2);\r\n\r\n\t\t\tm_list.SetItemData(row, i);\r\n\t\t\tm_map[i] = ar;\r\n\r\n\t\t\trow++;\r\n\t\t}\r\n\t}\r\n\r\n\tint dummyId = -1;\r\n\r\n\tfor (auto & element : CGetSetOptions::m_pasteScripts.m_list)\r\n\t{\r\n\t\t// Insert the first item\r\n\t\tlvi.mask = LVIF_TEXT;\r\n\t\tlvi.iItem = (int)row;\r\n\r\n\t\tKeyboardArray ar;\r\n\t\tar.m_refData = element.m_guid;\r\n\t\tfor (int x = 0; x < 10; x++)\r\n\t\t{\r\n\t\t\tar.Array[x].A = CGetSetOptions::GetActionShortCutA(ActionEnums::PASTE_SCRIPT, x, element.m_guid);\r\n\t\t\tar.Array[x].B = CGetSetOptions::GetActionShortCutB(ActionEnums::PASTE_SCRIPT, x, element.m_guid);\r\n\t\t}\r\n\r\n\t\tCString shortCutText = GetShortCutText(ar);\r\n\r\n\t\tlvi.iSubItem = 0;\r\n\t\tlvi.pszText = (LPTSTR)(LPCTSTR)(shortCutText);\r\n\t\tint x = m_list.InsertItem(&lvi);\r\n\r\n\t\tCString col2 = ActionEnums::EnumDescription(ActionEnums::PASTE_SCRIPT);\r\n\t\tcol2 += _T(\": \");\r\n\t\tcol2 += element.m_name;\r\n\t\tm_list.SetItemText(row, 1, col2);\r\n\r\n\t\tm_list.SetItemData(row, dummyId);\r\n\t\tm_map[dummyId] = ar;\r\n\r\n\t\tdummyId--;\r\n\t\trow++;\r\n\t}\r\n\r\n\tm_list.SortItems(MyCompareProc, (LPARAM)&m_list);\r\n\r\n\tSelectedRow(0);\r\n}\r\n\r\nCString CQuickPasteKeyboard::GetShortCutText(KeyboardAB ab)\r\n{\t\r\n\tCString shA;\r\n\tCString shB;\r\n\tif (ab.A > 0)\r\n\t{\r\n\t\tshA = CHotKey::GetHotKeyDisplayStatic(ab.A);\r\n\r\n\t\tif (ab.B > 0)\r\n\t\t{\r\n\t\t\tshB = CHotKey::GetHotKeyDisplayStatic(ab.B);\r\n\t\t}\r\n\t}\r\n\r\n\tCString combined;\r\n\tif (shA.IsEmpty() == FALSE &&\r\n\t\tshB.IsEmpty() == FALSE)\r\n\t{\r\n\t\tcombined.Format(_T(\"%s - %s\"), shA, shB);\r\n\t}\r\n\telse if (shA.IsEmpty() == FALSE)\r\n\t{\r\n\t\tcombined.Format(_T(\"%s\"), shA);\r\n\t}\r\n\r\n\treturn combined;\r\n}\r\n\r\nCString CQuickPasteKeyboard::GetShortCutText(KeyboardArray ar)\r\n{\r\n\tCString all;\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\tCString combined;\r\n\t\tif (ar.Array[i].A > 0)\r\n\t\t{\r\n\t\t\tcombined = GetShortCutText(ar.Array[i]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\tif(all.GetLength() > 0)\r\n\t\t{\r\n\t\t\tall += _T(\", \");\r\n\t\t}\r\n\r\n\t\tall += combined;\r\n\t}\r\n\r\n\treturn all;\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnLvnItemActivateList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMITEMACTIVATE pNMIA = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);\r\n\t// TODO: Add your control notification handler code here\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnLvnItemchangedList1(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tLPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);\r\n\t\r\n\tif ((pNMLV->uChanged & LVIF_STATE)\r\n\t\t&& (pNMLV->uNewState & LVIS_SELECTED))\r\n\t{\r\n\t\tint id = (int) m_list.GetItemData(pNMLV->iItem);\r\n\r\n\t\tm_assignedCombo.ResetContent();\r\n\r\n\t\tbool addedItem = false;\r\n\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tif(m_map[id].Array[i].A > 0)\r\n\t\t\t{\r\n\t\t\t\tCString shortcut = GetShortCutText(m_map[id].Array[i]);\r\n\t\t\t\tint pos = m_assignedCombo.AddString(shortcut);\r\n\t\t\t\tm_assignedCombo.SetItemData(pos, i);\r\n\r\n\t\t\t\taddedItem = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (addedItem == false)\r\n\t\t{\r\n\t\t\tCString shortcut;\r\n\t\t\tint pos = m_assignedCombo.AddString(shortcut);\r\n\t\t\tm_assignedCombo.SetItemData(pos, 0);\r\n\t\t}\r\n\r\n\t\tm_assignedCombo.SetCurSel(0);\r\n\r\n\t\tLoadHotKey(m_map[id].Array[0]);\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedAssign()\r\n{\r\n\tint shortCutId = SelectedCommandShortCutId();\r\n\tint id = SelectedCommandId();\r\n\tint row = SelectedCommandRow();\r\n\r\n\tif (m_map.find(id) != m_map.end() &&\r\n\t\tshortCutId >= 0 &&\r\n\t\tshortCutId < 10)\r\n\t{\r\n\t\tm_map[id].Array[shortCutId].Dirty = true;\r\n\r\n\t\tif (this->IsDlgButtonChecked(IDC_RADIO_KEYBOARD_1) == BST_CHECKED)\r\n\t\t{\r\n\t\t\t//remove the extended key flag, don't think this is needed now days\r\n\t\t\tm_map[id].Array[shortCutId].A = ACCEL_MAKEKEY(LOBYTE(m_hotKey1.GetHotKey()), (HIBYTE(m_hotKey1.GetHotKey()) & ~HOTKEYF_EXT));\r\n\t\t}\r\n\t\telse if (this->IsDlgButtonChecked(IDC_RADIO_MOUSE_1) == BST_CHECKED)\r\n\t\t{\r\n\t\t\tWORD vk = (WORD)m_mouseType1.GetItemData(m_mouseType1.GetCurSel());\r\n\t\t\tWORD mod = 0;\r\n\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_SHIFT_1) == BST_CHECKED)\r\n\t\t\t{\r\n\t\t\t\tmod |= HOTKEYF_SHIFT;\r\n\t\t\t}\r\n\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_CONTROL_1) == BST_CHECKED)\r\n\t\t\t{ \r\n\t\t\t\tmod |= HOTKEYF_CONTROL;\r\n\t\t\t}\r\n\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_ALT_1) == BST_CHECKED)\r\n\t\t\t{\r\n\t\t\t\tmod |= HOTKEYF_ALT;\r\n\t\t\t}\r\n\r\n\t\t\tm_map[id].Array[shortCutId].A = ACCEL_MAKEKEY(vk, mod);\r\n\t\t}\r\n\r\n\t\tif (IsDlgButtonChecked(IDC_CHECK_ENABLE_SECOND_PRESS) == BST_CHECKED)\r\n\t\t{\r\n\t\t\tif (this->IsDlgButtonChecked(IDC_RADIO_KEYBOARD_2) == BST_CHECKED)\r\n\t\t\t{\r\n\t\t\t\t//remove the extended key flag, don't think this is needed now days\r\n\t\t\t\tm_map[id].Array[shortCutId].B = ACCEL_MAKEKEY(LOBYTE(m_hotKey2.GetHotKey()), (HIBYTE(m_hotKey2.GetHotKey()) & ~HOTKEYF_EXT));\r\n\t\t\t}\r\n\t\t\telse if (this->IsDlgButtonChecked(IDC_RADIO_MOUSE_2) == BST_CHECKED)\r\n\t\t\t{\r\n\t\t\t\tWORD vk = (WORD)m_mouseType2.GetItemData(m_mouseType2.GetCurSel());\r\n\t\t\t\tWORD mod = 0;\r\n\t\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_SHIFT_2) == BST_CHECKED)\r\n\t\t\t\t{\r\n\t\t\t\t\tmod |= HOTKEYF_SHIFT;\r\n\t\t\t\t}\r\n\t\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_CONTROL_2) == BST_CHECKED)\r\n\t\t\t\t{\r\n\t\t\t\t\tmod |= HOTKEYF_CONTROL;\r\n\t\t\t\t}\r\n\t\t\t\tif (this->IsDlgButtonChecked(IDC_CHECK_ALT_2) == BST_CHECKED)\r\n\t\t\t\t{\r\n\t\t\t\t\tmod |= HOTKEYF_ALT;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_map[id].Array[shortCutId].B = ACCEL_MAKEKEY(vk, mod);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_map[id].Array[shortCutId].B = 0;\r\n\t\t}\r\n\r\n\t\tCString sh = GetShortCutText(m_map[id]);\r\n\t\tLVITEM lvi;\r\n\t\tlvi.mask = LVIF_TEXT;\r\n\t\tlvi.iItem = (int) row;\r\n\t\tlvi.iSubItem = 0;\r\n\t\tlvi.pszText = (LPTSTR) (LPCTSTR) (sh);\r\n\t\tm_list.SetItem(&lvi);\r\n\r\n\t\tCString shItem = GetShortCutText(m_map[id].Array[shortCutId]);\r\n\t\tint index = m_assignedCombo.GetCurSel();\r\n\t\tm_assignedCombo.DeleteString(index);\r\n\t\tint pos = m_assignedCombo.InsertString(index, shItem);\r\n\t\tm_assignedCombo.SetItemData(pos, shortCutId);\r\n\t\tm_assignedCombo.SetCurSel(pos);\r\n\t}\r\n}\r\n\r\nBOOL CQuickPasteKeyboard::OnApply()\r\n{\r\n\tfor (std::map<DWORD, KeyboardArray>::iterator it = m_map.begin(); it != m_map.end(); ++it)\r\n\t{\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tif (it->second.Array[i].Dirty)\r\n\t\t\t{\r\n\t\t\t\tint actionEnum = it->first;\r\n\t\t\t\tif (actionEnum < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tactionEnum = ActionEnums::PASTE_SCRIPT;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tCGetSetOptions::SetActionShortCutA(actionEnum, it->second.Array[i].A, i, it->second.m_refData);\r\n\t\t\t\tCGetSetOptions::SetActionShortCutB(actionEnum, it->second.Array[i].B, i, it->second.m_refData);\r\n\t\t\t\tit->second.Array[i].Dirty = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn CPropertyPage::OnApply();\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnCbnSelchangeComboAllAssigned()\r\n{\r\n\tint shortCutId = SelectedCommandShortCutId();\r\n\tint id = SelectedCommandId();\r\n\r\n\tif (m_map.find(id) != m_map.end() &&\r\n\t\tshortCutId >= 0 &&\r\n\t\tshortCutId < 10)\r\n\t{\r\n\t\tLoadHotKey(m_map[id].Array[shortCutId]);\r\n\t}\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedButtonRemove()\r\n{\r\n\tint shortCutId = SelectedCommandShortCutId();\t\r\n\tint id = SelectedCommandId();\r\n\r\n\tif (m_map.find(id) != m_map.end() &&\r\n\t\tshortCutId >= 0 &&\r\n\t\tshortCutId < 10)\r\n\t{\r\n\t\tint row = SelectedCommandRow();\r\n\r\n\t\tm_map[id].Array[shortCutId].Dirty = true;\r\n\t\tm_map[id].Array[shortCutId].A = 0;\r\n\t\tm_map[id].Array[shortCutId].B = 0;\r\n\r\n\t\tm_assignedCombo.DeleteString(m_assignedCombo.GetCurSel());\r\n\r\n\t\tif (m_assignedCombo.GetCount() <= 0)\r\n\t\t{\r\n\t\t\tCString shortcut;\r\n\t\t\tint pos = m_assignedCombo.AddString(shortcut);\r\n\t\t\tm_assignedCombo.SetItemData(pos, 0);\r\n\t\t}\r\n\t\t/*else\r\n\t\t{\r\n\t\t\tif (m_map[id].Array[shortCutId + 1].A > 0)\r\n\t\t\t{\r\n\t\t\t\tfor (int resetRow = shortCutId; resetRow < (10 - 1); resetRow++)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_map[id].Array[resetRow].A = m_map[id].Array[resetRow + 1].A;\r\n\t\t\t\t\tm_map[id].Array[resetRow].B = m_map[id].Array[resetRow + 1].B;\r\n\t\t\t\t\tif (m_map[id].Array[resetRow].A > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tm_map[id].Array[resetRow].Dirty = true;\r\n\t\t\t\t\t\tm_map[id].Array[resetRow + 1].Dirty = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m_map[id].Array[9].A > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_map[id].Array[9].Dirty = true;\r\n\t\t\t\t}\r\n\t\t\t\tm_map[id].Array[9].A = -1;\r\n\t\t\t\tm_map[id].Array[9].B = -1;\r\n\t\t\t}\r\n\r\n\t\t\tint comboCount = m_assignedCombo.GetCount();\r\n\t\t\tfor (int comboIndex = 0; comboIndex < comboCount; comboIndex++)\r\n\t\t\t{\r\n\t\t\t\tint rowId = m_assignedCombo.GetItemData(comboIndex);\r\n\t\t\t\tif (rowId >= shortCutId)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_assignedCombo.SetItemData(comboIndex, rowId-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}*/\r\n\r\n\t\tCString sh = GetShortCutText(m_map[id]);\r\n\t\tLVITEM lvi;\r\n\t\tlvi.mask = LVIF_TEXT;\r\n\t\tlvi.iItem = (int) row;\r\n\t\tlvi.iSubItem = 0;\r\n\t\tlvi.pszText = (LPTSTR) (LPCTSTR) (sh);\r\n\t\tm_list.SetItem(&lvi);\r\n\r\n\t\tm_assignedCombo.SetCurSel(0);\r\n\r\n\t\tLoadHotKey(m_map[id].Array[0]);\r\n\t}\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedButtonAdd()\r\n{\r\n\tint count = m_assignedCombo.GetCount();\r\n\tif (count < 10)\r\n\t{\r\n\t\tint id = SelectedCommandId();\r\n\t\tif (m_map.find(id) != m_map.end())\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < 10; i++)\r\n\t\t\t{\r\n\t\t\t\tif (m_map[id].Array[i].A <= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCString shortcut;\r\n\t\t\t\t\tint pos = m_assignedCombo.AddString(shortcut);\r\n\t\t\t\t\tm_assignedCombo.SetItemData(pos, i);\r\n\t\t\t\t\tm_assignedCombo.SetCurSel(pos);\r\n\r\n\t\t\t\t\tLoadHotKey(m_map[id].Array[i]);\r\n\r\n\t\t\t\t\tm_hotKey1.SetFocus();\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint CQuickPasteKeyboard::SelectedCommandId()\r\n{\r\n\tint id = -1;\r\n\tPOSITION pos = m_list.GetFirstSelectedItemPosition();\r\n\tif (pos != NULL)\r\n\t{\r\n\t\twhile (pos)\r\n\t\t{\r\n\t\t\tint row = m_list.GetNextSelectedItem(pos);\r\n\t\t\tid = (int) m_list.GetItemData(row);\r\n\t\t}\r\n\t}\r\n\r\n\treturn id;\r\n}\r\n\r\nint CQuickPasteKeyboard::SelectedCommandRow()\r\n{\r\n\tint row = -1;\r\n\tPOSITION pos = m_list.GetFirstSelectedItemPosition();\r\n\tif (pos != NULL)\r\n\t{\r\n\t\twhile (pos)\r\n\t\t{\r\n\t\t\trow = m_list.GetNextSelectedItem(pos);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn row;\r\n}\r\n\r\nint CQuickPasteKeyboard::SelectedCommandShortCutId()\r\n{\r\n\tint index = m_assignedCombo.GetCurSel();\r\n\tint shortCutId = (int)m_assignedCombo.GetItemData(index);\r\n\r\n\treturn shortCutId;\r\n}\r\n\r\nvoid CQuickPasteKeyboard::LoadHotKey(KeyboardAB ab)\r\n{\r\n\tCheckDlgButton(IDC_RADIO_MOUSE_1, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_RADIO_KEYBOARD_1, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_SHIFT_1, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_CONTROL_1, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_ALT_1, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_SHIFT_2, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_CONTROL_2, BST_UNCHECKED);\r\n\tCheckDlgButton(IDC_CHECK_ALT_2, BST_UNCHECKED);\r\n\tm_hotKey1.SetHotKey(0, 0);\r\n\tm_hotKey2.SetHotKey(0, 0);\r\n\r\n\tint a = 0;\r\n\tif (ab.A > 0)\r\n\t{\r\n\t\ta = ab.A;\r\n\r\n\t\tswitch (LOBYTE((DWORD)a))\r\n\t\t{\r\n\t\t\tcase VK_LEFT:\r\n\t\t\tcase VK_UP:\r\n\t\t\tcase VK_RIGHT:\r\n\t\t\tcase VK_DOWN: // arrow keys\r\n\t\t\tcase VK_PRIOR:\r\n\t\t\tcase VK_NEXT: // page up and page down\r\n\t\t\tcase VK_END:\r\n\t\t\tcase VK_HOME:\r\n\t\t\tcase VK_INSERT:\r\n\t\t\tcase VK_DELETE:\r\n\t\t\tcase VK_DIVIDE: // numpad slash\r\n\t\t\tcase VK_NUMLOCK:\r\n\t\t\t{\r\n\t\t\t\ta = ACCEL_MAKEKEY(LOBYTE(a), (HIBYTE(a) | HOTKEYF_EXT));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\tswitch (LOBYTE((DWORD)a))\r\n\t\t{\r\n\t\tcase VK_MOUSE_CLICK:\r\n\t\tcase VK_MOUSE_DOUBLE_CLICK:\r\n\t\tcase VK_MOUSE_RIGHT_CLICK:\r\n\t\tcase VK_MOUSE_MIDDLE_CLICK:\r\n\t\t\tSelectMouseTypeCombo(m_mouseType1, LOBYTE((DWORD)a));\r\n\t\t\tCheckDlgButton(IDC_RADIO_MOUSE_1, BST_CHECKED);\r\n\t\t\t\r\n\t\t\t{\r\n\t\t\t\tBYTE mod = HIBYTE(a);\r\n\t\t\t\tif (mod & HOTKEYF_SHIFT)\r\n\t\t\t\t\tCheckDlgButton(IDC_CHECK_SHIFT_1, BST_CHECKED);\r\n\t\t\t\tif (mod & HOTKEYF_CONTROL)\r\n\t\t\t\t\tCheckDlgButton(IDC_CHECK_CONTROL_1, BST_CHECKED);\r\n\t\t\t\tif (mod & HOTKEYF_ALT)\r\n\t\t\t\t\tCheckDlgButton(IDC_CHECK_ALT_1, BST_CHECKED);\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_1, BST_CHECKED);\r\n\t\t\tm_hotKey1.SetHotKey(LOBYTE((DWORD)a), (HIBYTE((DWORD)a)));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tint b = 0;\r\n\t\tif (ab.B > 0)\r\n\t\t{\r\n\t\t\tCheckDlgButton(IDC_CHECK_ENABLE_SECOND_PRESS, BST_CHECKED);\r\n\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MOUSE_2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_KEYBOARD_2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_SECOND_PRESS), SW_SHOW);\r\n\r\n\t\t\tb = ab.B;\r\n\r\n\t\t\tswitch (LOBYTE((DWORD)b))\r\n\t\t\t{\r\n\t\t\tcase VK_LEFT:\r\n\t\t\tcase VK_UP:\r\n\t\t\tcase VK_RIGHT:\r\n\t\t\tcase VK_DOWN: // arrow keys\r\n\t\t\tcase VK_PRIOR:\r\n\t\t\tcase VK_NEXT: // page up and page down\r\n\t\t\tcase VK_END:\r\n\t\t\tcase VK_HOME:\r\n\t\t\tcase VK_INSERT:\r\n\t\t\tcase VK_DELETE:\r\n\t\t\tcase VK_DIVIDE: // numpad slash\r\n\t\t\tcase VK_NUMLOCK:\r\n\t\t\t{\r\n\t\t\t\tb = ACCEL_MAKEKEY(LOBYTE(b), (HIBYTE(b) | HOTKEYF_EXT));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tswitch (LOBYTE((DWORD)b))\r\n\t\t\t{\r\n\t\t\tcase VK_MOUSE_CLICK:\r\n\t\t\tcase VK_MOUSE_DOUBLE_CLICK:\r\n\t\t\tcase VK_MOUSE_RIGHT_CLICK:\r\n\t\t\tcase VK_MOUSE_MIDDLE_CLICK:\r\n\t\t\t\tSelectMouseTypeCombo(m_mouseType2, LOBYTE((DWORD)b));\r\n\t\t\t\tCheckDlgButton(IDC_RADIO_MOUSE_2, BST_CHECKED);\r\n\t\t\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_2, BST_UNCHECKED);\r\n\r\n\t\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_SHOW);\r\n\t\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_SHOW);\r\n\t\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_SHOW);\r\n\t\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_SHOW);\r\n\r\n\t\t\t\t{\r\n\t\t\t\t\tBYTE mod = HIBYTE(b);\r\n\t\t\t\t\tif (mod & HOTKEYF_SHIFT)\r\n\t\t\t\t\t\tCheckDlgButton(IDC_CHECK_SHIFT_2, BST_CHECKED);\r\n\t\t\t\t\tif (mod & HOTKEYF_CONTROL)\r\n\t\t\t\t\t\tCheckDlgButton(IDC_CHECK_CONTROL_2, BST_CHECKED);\r\n\t\t\t\t\tif (mod & HOTKEYF_ALT)\r\n\t\t\t\t\t\tCheckDlgButton(IDC_CHECK_ALT_2, BST_CHECKED);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_2, BST_CHECKED);\r\n\t\t\t\tCheckDlgButton(IDC_RADIO_MOUSE_2, BST_UNCHECKED);\r\n\t\t\t\tm_hotKey2.SetHotKey(LOBYTE((DWORD)b), (HIBYTE((DWORD)b)));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{ \r\n\t\t\tCheckDlgButton(IDC_CHECK_ENABLE_SECOND_PRESS, BST_UNCHECKED);\r\n\t\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_2, BST_CHECKED);\r\n\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MOUSE_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_KEYBOARD_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER2), SW_HIDE);\r\n\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_SECOND_PRESS), SW_HIDE);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCheckDlgButton(IDC_CHECK_ENABLE_SECOND_PRESS, BST_UNCHECKED);\r\n\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_1, BST_CHECKED);\r\n\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_2, BST_CHECKED);\r\n\t}\r\n\r\n\tOnBnClickedRadioMouse1();\r\n\t//ShowSecondPress(FALSE);\r\n}\r\n\r\nvoid CQuickPasteKeyboard::SelectMouseTypeCombo(CComboBox &combo, int value)\r\n{\r\n\tint count = combo.GetCount();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tint itemData = (int)combo.GetItemData(i);\r\n\t\tif (itemData == value)\r\n\t\t{\r\n\t\t\tcombo.SetCurSel(i);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnCbnKillfocusComboEnterModifier()\r\n{\r\n\t// TODO: Add your control notification handler code here\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnEnKillfocusEdit1()\r\n{\r\n\t// TODO: Add your control notification handler code here\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnKillFocus(CWnd* pNewWnd)\r\n{\r\n\tCPropertyPage::OnKillFocus(pNewWnd);\r\n\r\n\t// TODO: Add your message handler code here\r\n}\r\n\r\n\r\nBOOL CQuickPasteKeyboard::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\tswitch(pMsg->message)\r\n\t{\r\n\tcase WM_KILLFOCUS:\r\n\t\tbreak;\r\n\tcase WM_KEYDOWN:\r\n\t\tif (pMsg->wParam == VK_ESCAPE)\r\n\t\t{\r\n\t\t\tif (pMsg->hwnd == m_hotKey1.m_hWnd)\r\n\t\t\t{\r\n\t\t\t\tm_hotKey1.SetHotKey(VK_ESCAPE, CAccels::GetKeyStateModifiers());\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t\tif (pMsg->hwnd == m_hotKey2.m_hWnd)\r\n\t\t\t{\r\n\t\t\t\tm_hotKey2.SetHotKey(VK_ESCAPE, CAccels::GetKeyStateModifiers());\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn CPropertyPage::PreTranslateMessage(pMsg);\r\n}\r\n\r\n\r\nBOOL CQuickPasteKeyboard::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)\r\n{\r\n\tNMHDR* pNMHDR = (NMHDR *) lParam;\r\n\tif (pNMHDR &&pNMHDR->code == WM_KILLFOCUS)\r\n\t{\r\n\t\tCWnd *pFocus = CWnd::GetFocus(); // call to a static function \r\n\t\tif (pFocus && (pFocus->GetParent() == this))\r\n\t\t{\r\n\t\t\tif (pFocus->GetDlgCtrlID() != IDCANCEL)\r\n\t\t\t{\r\n\t\t\t\t// Ok, if the focus is not in the cancelbutton... \r\n\t\t\t\tif (pNMHDR->idFrom)\r\n\t\t\t\t{\r\n\t\t\t\t\tint k = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn CPropertyPage::OnNotify(wParam, lParam, pResult);\r\n}\r\n\r\n\r\nBOOL CQuickPasteKeyboard::OnCommand(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tUINT notificationCode = (UINT) HIWORD(wParam);\r\n\r\n\t// For List control I handle it in another way....\r\n\tif ((notificationCode == EN_KILLFOCUS) ||\r\n\t\t(notificationCode == LBN_KILLFOCUS) ||\r\n\t\t(notificationCode == CBN_KILLFOCUS) ||\r\n\t\t(notificationCode == NM_KILLFOCUS) ||\r\n\t\t(notificationCode == WM_KILLFOCUS)) {\r\n\r\n\t\tCWnd *pFocus = CWnd::GetFocus();\r\n\t\t// call to a static function \r\n\r\n\t\t// If we are changing the focus to another\r\n\t\t// control of the same window... \r\n\r\n\t\tif (pFocus && (pFocus->GetParent() == this))\r\n\t\t{\r\n\t\t\t// Ok, if the focus is not in the cancel button...\r\n\t\t\tif (pFocus->GetDlgCtrlID() != IDCANCEL) \r\n\t\t\t{\r\n\t\t\t\tint k = 9;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn CPropertyPage::OnCommand(wParam, lParam);\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedButtonEnter()\r\n{\r\n\tDWORD hk = m_hotKey1.GetHotKey();\r\n\tBYTE currentModifiers = CAccels::GetKeyStateModifiers();\r\n\tm_hotKey1.SetHotKey(VK_RETURN, currentModifiers);\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedButtonEnter2()\r\n{\r\n\tDWORD hk = m_hotKey2.GetHotKey();\r\n\tBYTE currentModifiers = CAccels::GetKeyStateModifiers();\r\n\tm_hotKey2.SetHotKey(VK_RETURN, currentModifiers);\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)\r\n{\r\n\t// TODO: Add your message handler code here and/or call default\r\n\r\n\tCPropertyPage::OnKeyUp(nChar, nRepCnt, nFlags);\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedButtonReset()\r\n{\r\n\tfor (std::map<DWORD, KeyboardArray>::iterator it = m_map.begin(); it != m_map.end(); ++it)\r\n\t{\r\n\t\tfor (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t\tint newA = ActionEnums::GetDefaultShortCutKeyA((ActionEnums::ActionEnumValues)it->first, i);\r\n\t\t\tint newB = ActionEnums::GetDefaultShortCutKeyB((ActionEnums::ActionEnumValues)it->first, i);\r\n\t\t\tif (it->second.Array[i].A != newA ||\r\n\t\t\t\tit->second.Array[i].B != newB)\r\n\t\t\t{\r\n\t\t\t\tit->second.Array[i].A = newA;\r\n\t\t\t\tit->second.Array[i].B = newB;\r\n\t\t\t\tit->second.Array[i].Dirty = true;\r\n\r\n\t\t\t\tCString sh = GetShortCutText(it->second);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tint count = m_list.GetItemCount();\r\n\tfor (int row = 0; row < count; row++)\r\n\t{\r\n\t\tint actionId = (int)m_list.GetItemData(row);\r\n\t\t\r\n\t\tCString sh = GetShortCutText(m_map[actionId]);\r\n\r\n\t\tLVITEM lvi;\r\n\t\tlvi.mask = LVIF_TEXT;\r\n\t\tlvi.iItem = (int)row;\r\n\t\tlvi.iSubItem = 0;\r\n\t\tlvi.pszText = (LPTSTR)(LPCTSTR)(sh);\r\n\t\tm_list.SetItem(&lvi);\r\n\t}\r\n\r\n\tSelectedRow(0);\t\r\n}\r\n\r\nvoid CQuickPasteKeyboard::SelectedRow(int row)\r\n{\r\n\tm_list.SetItemState(row, LVIS_FOCUSED, LVIS_FOCUSED);\r\n\tm_list.SetItemState(row, LVIS_SELECTED, LVIS_SELECTED);\r\n\tm_list.SetSelectionMark(row);\r\n\tm_list.EnsureVisible(row, FALSE);\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedRadioKeyboard1()\r\n{\r\n\tOnBnClickedRadioMouse1();\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedRadioMouse1()\r\n{\r\n\tif (IsDlgButtonChecked(IDC_RADIO_KEYBOARD_1) == BST_CHECKED)\r\n\t{\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY1), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER), SW_SHOW);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_1), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_1), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_1), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_1), SW_HIDE);\r\n\t}\r\n\telse if (IsDlgButtonChecked(IDC_RADIO_MOUSE_1) == BST_CHECKED)\r\n\t{\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY1), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER), SW_HIDE);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_1), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_1), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_1), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_1), SW_SHOW);\r\n\t}\r\n\r\n\tif (IsDlgButtonChecked(IDC_CHECK_ENABLE_SECOND_PRESS) == BST_CHECKED)\r\n\t{\r\n\t\tif (IsDlgButtonChecked(IDC_RADIO_KEYBOARD_2) == BST_CHECKED)\r\n\t\t{\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER2), SW_SHOW);\r\n\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_HIDE);\r\n\t\t}\r\n\t\telse if (IsDlgButtonChecked(IDC_RADIO_MOUSE_2) == BST_CHECKED)\r\n\t\t{\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY2), SW_HIDE);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER2), SW_HIDE);\r\n\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_SHOW);\r\n\t\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_SHOW);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedRadioKeyboard2()\r\n{\r\n\tOnBnClickedRadioMouse1();\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedRadioMouse2()\r\n{\r\n\tOnBnClickedRadioMouse1();\r\n}\r\n\r\nvoid CQuickPasteKeyboard::OnBnClickedCheckEnableSecondPress()\r\n{\r\n\tint shortCutId = SelectedCommandShortCutId();\r\n\tint id = SelectedCommandId();\r\n\r\n\tif (m_map.find(id) != m_map.end() &&\r\n\t\tshortCutId >= 0 &&\r\n\t\tshortCutId < 10 &&\r\n\t\tm_map[id].Array[shortCutId].B > 0)\r\n\t{\r\n\t\tm_map[id].Array[shortCutId].Dirty = true;\r\n\t\tm_map[id].Array[shortCutId].B = 0;\r\n\t}\r\n\r\n\tif (IsDlgButtonChecked(IDC_CHECK_ENABLE_SECOND_PRESS) == BST_CHECKED)\r\n\t{\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY2), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER2), SW_SHOW);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_HIDE);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MOUSE_2), SW_SHOW);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_KEYBOARD_2), SW_SHOW);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_SECOND_PRESS), SW_SHOW);\r\n\r\n\t\tCheckDlgButton(IDC_RADIO_KEYBOARD_2, BST_CHECKED);\r\n\t\tCheckDlgButton(IDC_RADIO_MOUSE_2, BST_UNCHECKED);\r\n\t\tm_hotKey2.SetHotKey(0, 0);\r\n\t}\r\n\telse if (IsDlgButtonChecked(IDC_CHECK_ENABLE_SECOND_PRESS) == BST_UNCHECKED)\r\n\t{\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_HOTKEY2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_ENTER2), SW_HIDE);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_MOUSE_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_SHIFT_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_CONTROL_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ALT_2), SW_HIDE);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_KEYBOARD_2), SW_HIDE);\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MOUSE_2), SW_HIDE);\r\n\r\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_STATIC_SECOND_PRESS), SW_HIDE);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "QuickPasteKeyboard.h",
          "type": "blob",
          "size": 2.255859375,
          "content": "#pragma once\n#include \"afxcmn.h\"\n#include \"afxwin.h\"\n\n\n// CQuickPasteKeyboard dialog\n\nclass CQuickPasteKeyboard : public CPropertyPage\n{\n\tDECLARE_DYNAMIC(CQuickPasteKeyboard)\n\npublic:\n\tCQuickPasteKeyboard();\n\tvirtual ~CQuickPasteKeyboard();\n\n\tclass KeyboardAB\n\t{\n\tpublic:\n\t\tKeyboardAB()\n\t\t{\n\t\t\tA = -1;\n\t\t\tB = -1;\n\t\t\tDirty = false;\n\t\t}\n\t\tint A;\n\t\tint B;\n\t\tbool Dirty;\n\t};\n\n\tclass KeyboardArray\n\t{\n\tpublic:\n\t\tKeyboardArray()\n\t\t{\n\t\t\tm_refData = _T(\"\");\n\t\t}\n\n\t\tCString m_refData;\n\n\t\tKeyboardAB Array[10];\n\t};\n\n// Dialog Data\n\tenum { IDD = IDD_OPTIONS_QUICK_PASTE_KEYBOARD };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tCListCtrl m_list;\n\tvirtual BOOL OnInitDialog();\n\nprotected:\n\tvoid InitListCtrlCols();\n\tvoid LoadItems();\n\tCString GetShortCutText(KeyboardArray ab);\n\tCString GetShortCutText(KeyboardAB ab);\n\tstd::map<DWORD, KeyboardArray> m_map;\n\tvoid LoadHotKey(KeyboardAB ab);\n\tCString m_csTitle;\n\tint SelectedCommandId();\n\tint SelectedCommandShortCutId();\n\tint SelectedCommandRow();\n\tvoid SelectMouseTypeCombo(CComboBox &combo, int value);\n\tvoid SelectedRow(int row);\n\npublic:\n\tafx_msg void OnLvnItemActivateList1(NMHDR *pNMHDR, LRESULT *pResult);\n\tafx_msg void OnLvnItemchangedList1(NMHDR *pNMHDR, LRESULT *pResult);\n\tCHotKeyCtrl m_hotKey1;\n\tafx_msg void OnBnClickedAssign();\n\tCHotKeyCtrl m_hotKey2;\n\tvirtual BOOL OnApply();\n\tCComboBox m_assignedCombo;\n\tafx_msg void OnCbnSelchangeComboAllAssigned();\n\tafx_msg void OnBnClickedButtonRemove();\n\tafx_msg void OnBnClickedButtonAdd();\n\tafx_msg void OnCbnKillfocusComboEnterModifier();\n\tafx_msg void OnEnKillfocusEdit1();\n\tafx_msg void OnKillFocus(CWnd* pNewWnd);\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\tvirtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);\n\tvirtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);\n\tafx_msg void OnBnClickedButtonEnter();\n\tafx_msg void OnBnClickedButtonEnter2();\n\n\tafx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);\n\tCComboBox m_mouseType1;\n\tCComboBox m_mouseType2;\n\tafx_msg void OnBnClickedButtonReset();\n\tafx_msg void OnBnClickedRadioKeyboard1();\n\tafx_msg void OnBnClickedRadioMouse1();\n\tafx_msg void OnBnClickedRadioKeyboard2();\n\tafx_msg void OnBnClickedRadioMouse2();\n\tafx_msg void OnBnClickedCheckEnableSecondPress();\n};\n"
        },
        {
          "name": "ReadMe.md",
          "type": "blob",
          "size": 0.5380859375,
          "content": "What is Ditto?\n- Ditto is an extension to the Windows Clipboard. You copy something to the Clipboard and Ditto takes what you copied and stores it in a database to retrieve at a later time.\n\nBasic Usage\n- Run Ditto\n- Copy things to the clipboard, e.g. using Ctrl-C with text selected in a text editor.\n- Open Ditto by clicking its icon in the system tray or by pressing its Hot Key which defaults to Ctrl + `  i.e. hold down Ctrl and press the back-quote (tilde ~) key.\n- Double click or press enter on the item to paste it to the previous window.\n"
        },
        {
          "name": "RecieveFile.cpp",
          "type": "blob",
          "size": 0.52734375,
          "content": "// RecieveFile.cpp: implementation of the CRecieveFile class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"RecieveFile.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCRecieveFile::CRecieveFile()\n{\n\n}\n\nCRecieveFile::~CRecieveFile()\n{\n\n}\n"
        },
        {
          "name": "RecieveFile.h",
          "type": "blob",
          "size": 0.501953125,
          "content": "// RecieveFile.h: interface for the CRecieveFile class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_RECIEVEFILE_H__3A1481C8_9511_42AD_B63B_50ADC724333A__INCLUDED_)\n#define AFX_RECIEVEFILE_H__3A1481C8_9511_42AD_B63B_50ADC724333A__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\nclass CRecieveFile  \n{\npublic:\n\tCRecieveFile();\n\tvirtual ~CRecieveFile();\n\n};\n\n#endif // !defined(AFX_RECIEVEFILE_H__3A1481C8_9511_42AD_B63B_50ADC724333A__INCLUDED_)\n"
        },
        {
          "name": "RecieveSocket.cpp",
          "type": "blob",
          "size": 5.6298828125,
          "content": "#include \"StdAfx.h\"\r\n#include \"RecieveSocket.h\"\r\n#include \"Options.h\"\r\n#include \"Misc.h\"\r\n#include \"CP_Main.h\"\r\n#include \"shared/TextConvert.h\"\r\n\r\nCRecieveSocket::CRecieveSocket(SOCKET sock)\r\n{\r\n\tm_pDataReturnedFromDecrypt = NULL;\r\n\tm_Sock = sock;\r\n\tm_pEncryptor = new CEncryption; //CreateEncryptionInterface(\"encryptdecrypt.dll\");\r\n\tm_pProgress = NULL;\r\n}\r\n\r\nCRecieveSocket::~CRecieveSocket()\r\n{\r\n\tif(m_pEncryptor)\r\n\t{\r\n\t\tm_pEncryptor->FreeBuffer(m_pDataReturnedFromDecrypt);\r\n\r\n\t\tdelete m_pEncryptor;\r\n\t\tm_pEncryptor = NULL;\r\n\t}\r\n}\r\n\r\nvoid CRecieveSocket::FreeDecryptedData()\r\n{ \r\n\tif(CGetSetOptions::m_csPassword == \"\")\r\n\t{\r\n\t\tdelete [] m_pDataReturnedFromDecrypt;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_pEncryptor->FreeBuffer(m_pDataReturnedFromDecrypt);\r\n\t}\r\n\tm_pDataReturnedFromDecrypt = NULL;\r\n}\r\n\r\nLPVOID CRecieveSocket::ReceiveEncryptedData(long lInSize, long &lOutSize)\r\n{\r\n\tif(m_pEncryptor == NULL)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ReceiveEncryptedData::Encryption not initialized\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif(m_pDataReturnedFromDecrypt)\r\n\t\tFreeDecryptedData();\r\n\r\n\tchar *pInput = new char[lInSize];\r\n\r\n\tUCHAR* pOutput = NULL;\r\n\t\r\n\tif(pInput)\r\n\t{\r\n\t\tint nOut = 0;\r\n\r\n\t\tif(RecieveExactSize(pInput, lInSize))\r\n\t\t{\r\n\t\t\tCStringA csPassword;\r\n\t\t\tINT_PTR count = CGetSetOptions::m_csNetworkPasswordArray.GetSize();\r\n\t\t\tINT_PTR nIndex;\r\n\t\t\tfor(int i = -2; i < count; i++)\r\n\t\t\t{\r\n\t\t\t\tcsPassword.Empty();\r\n\t\t\t\tnIndex = i;\r\n\r\n\t\t\t\t//First time through try the last index that was valid\r\n\t\t\t\tif(i == -2)\r\n\t\t\t\t{\r\n\t\t\t\t\tnIndex = theApp.m_lLastGoodIndexForNextworkPassword;\r\n\t\t\t\t\tif(nIndex == -2)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(nIndex == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tcsPassword = CGetSetOptions::m_csPassword;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(nIndex >= 0 && nIndex < count)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcsPassword = CTextConvert::UnicodeToUTF8(CGetSetOptions::m_csNetworkPasswordArray[nIndex]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(m_pEncryptor->Decrypt((UCHAR*)pInput, lInSize, csPassword, pOutput, nOut) == FALSE)\r\n\t\t\t\t{\r\n\t\t\t\t\tLogSendRecieveInfo(StrF(_T(\"ReceiveEncryptedData:: Failed to Decrypt data password = %s\"), CGetSetOptions::m_csPassword));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttheApp.m_lLastGoodIndexForNextworkPassword = (long)nIndex;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(StrF(_T(\"ReceiveEncryptedData:: FAILED\"), lInSize));\r\n\t\t}\r\n\r\n\t\tlOutSize = nOut;\r\n\r\n\t\tdelete [] pInput;\r\n\t\tpInput = NULL;\r\n\t}\t\r\n\telse\r\n\t{\r\n\t\tASSERT(FALSE);\r\n\t\tLogSendRecieveInfo(StrF(_T(\"ReceiveEncryptedData:: Failed to create new data size = %d\"), lInSize));\r\n\t}\r\n\r\n\tm_pDataReturnedFromDecrypt = pOutput;\r\n\r\n\treturn pOutput;\r\n}\r\n\r\nint recv_to(int fd, char *buffer, int len, int flags, int to) \r\n{\r\n\tfd_set readset;\r\n\tint result, iof = -1;\r\n\tstruct timeval tv;\r\n\r\n\t// Initialize the set\r\n\tFD_ZERO(&readset);\r\n\tFD_SET(fd, &readset);\r\n\r\n\t// Initialize time out struct\r\n\ttv.tv_sec = 0;\r\n\ttv.tv_usec = to * 1000;\r\n\t// select()\r\n\tresult = select(fd+1, &readset, NULL, NULL, &tv);\r\n\r\n\t// Check status\r\n\tif (result < 0)\r\n\t\treturn -1;\r\n\telse if (result > 0 && FD_ISSET(fd, &readset)) \r\n\t{\r\n\t\t// Set non-blocking mode\r\n\t\t//if ((iof = fcntl(fd, F_GETFL, 0)) != -1)\r\n\t\t//\tfcntl(fd, F_SETFL, iof | O_NONBLOCK);\r\n\t\t// receive\r\n\t\tresult = recv(fd, buffer, len, flags);\r\n\t\t// set as before\r\n\t\t//if (iof != -1)\r\n\t\t//\tfcntl(fd, F_SETFL, iof);\r\n\t\treturn result;\r\n\t}\r\n\treturn -2;\r\n}\r\n\r\nBOOL CRecieveSocket::RecieveExactSize(char *pData, long lSize)\r\n{\r\n\tLogSendRecieveInfo(StrF(_T(\"RecieveExactSize:: ------ Start wanted size %d\"), lSize));\r\n\r\n\tlong lReceiveCount = 0;\r\n\r\n\tlong lWanted = lSize;\r\n\tlong lOffset = 0;\r\n\tCString originalText = _T(\"\");\r\n\r\n\twhile(lWanted > 0)\r\n\t{\t\t\r\n\t\tfd_set readset;\r\n\t\tint res;\r\n\r\n\t\tint timeoutMs = CGetSetOptions::GetNetworkReadTimeoutMS();\r\n\t\tint loops100msEach = (timeoutMs/100);\r\n\r\n\t\tfor(int i = 0; i < loops100msEach; i++)\r\n\t\t{\r\n\t\t\tlReceiveCount = recv_to(m_Sock, pData + lOffset, lWanted, 0, 100);\r\n\r\n\t\t\tif(lReceiveCount >= 0)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse if(lReceiveCount == SOCKET_ERROR)\r\n\t\t\t{\r\n\t\t\t\tASSERT(FALSE);\r\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"RecieveExactSize:: Socket Error\")));\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\r\n\t\t\tif(lReceiveCount == -2 && i > 15)\r\n\t\t\t{\r\n\t\t\t\tif(m_pProgress != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\toriginalText = m_pProgress->GetMessage();\r\n\t\t\t\t\tm_pProgress->SetMessage(StrF(_T(\"Requesting data from Server\")));\t\t\t\t\t\r\n\t\t\t\t\tm_pProgress->PumpMessages();\r\n\t\t\t\t\tif(m_pProgress->Cancelled())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(lReceiveCount == -2)\r\n\t\t{\r\n\t\t\tASSERT(FALSE);\r\n\t\t\tLogSendRecieveInfo(StrF(_T(\"RecieveExactSize:: Timeout waiting for server\")));\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif(lReceiveCount == SOCKET_ERROR)\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(\"RecieveExactSize:: ********ERROR if(lReceiveCount == SOCKET_ERROR)*******\");\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\telse if(lReceiveCount == 0)\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(\"RecieveExactSize:: ********ERROR lRecieveCount == 0\");\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t\tif(m_pProgress != NULL &&\r\n\t\t\toriginalText != _T(\"\"))\r\n\t\t{\r\n\t\t\tm_pProgress->SetMessage(originalText);\t\t\t\t\t\r\n\t\t}\r\n\r\n\t\tlWanted -= lReceiveCount;\r\n\t\tlOffset += lReceiveCount;\r\n\r\n\t\tLogSendRecieveInfo(StrF(_T(\"RecieveExactSize:: ------Bytes Read %d Total Recieved %d\"), lReceiveCount, lOffset));\r\n\t}\r\n\r\n//\tLogSendRecieveInfo(StrF(_T(\"RecieveExactSize:: ------END RecieveExactSize Recieved %d\"), lOffset));\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n#define ENCRYPTED_SIZE_CSENDINFO 508\r\n\r\nBOOL CRecieveSocket::RecieveCSendInfo(CSendInfo *pInfo)\r\n{\r\n\tBOOL bRet = FALSE;\r\n\tlong lOutSize = 0;\r\n\r\n\tlong lRecieveSize = ENCRYPTED_SIZE_CSENDINFO;\r\n\r\n\tLPVOID lpData = ReceiveEncryptedData(lRecieveSize, lOutSize);\r\n\tif(lpData)\r\n\t{\r\n\t\tmemcpy(pInfo, lpData, sizeof(CSendInfo));\r\n\r\n\t\tbRet = (pInfo->m_nSize == sizeof(CSendInfo));\r\n\r\n\t\tFreeDecryptedData();\r\n\t}\r\n\r\n\treturn bRet;\r\n}"
        },
        {
          "name": "RecieveSocket.h",
          "type": "blob",
          "size": 0.6962890625,
          "content": "#pragma once\n\n#include \"Winsock2.h\"\n#include \"EncryptDecrypt\\Encryption.h\"\n#include \"ServerDefines.h\"\n#include \"FileTransferProgressDlg.h\"\n\nclass CRecieveSocket\n{\npublic:\n\tCRecieveSocket(SOCKET sk = NULL);\n\n\t~CRecieveSocket();\n\t\n\tLPVOID ReceiveEncryptedData(long lInSize, long &lOutSize);\n\tBOOL RecieveExactSize(char *pData, long lSize);\n\tBOOL RecieveCSendInfo(CSendInfo *pInfo);\n\n\tvoid FreeDecryptedData();\n\n\tSOCKET\tGetSocket()\t\t\t\t{ return m_Sock;\t}\n\tvoid\tSetSocket(SOCKET sock)\t{ m_Sock = sock;\t}\n\n\tvoid SetProgressBar(CFileTransferProgressDlg *pDlg) { m_pProgress = pDlg; }\n\nprotected:\n\tCEncryption *m_pEncryptor;\n\tSOCKET m_Sock;\n\tUCHAR *m_pDataReturnedFromDecrypt;\t\n\n\tCFileTransferProgressDlg *m_pProgress;\n};"
        },
        {
          "name": "RegExFilterHelper.cpp",
          "type": "blob",
          "size": 2.4541015625,
          "content": "#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"RegExFilterHelper.h\"\n#include \"Shared\\Tokenizer.h\"\n#include \"Options.h\"\n#include \"WildCardMatch.h\"\n\n#include <regex>\n#include <string>\n\nvoid CRegExFilterData::ParseFilters()\n{\n\tm_parsedProcessFilters.RemoveAll();\n\n\tCTokenizer token(m_processFilters, CGetSetOptions::GetCopyAppSeparator());\n\tCString line;\n\n\twhile (token.Next(line))\n\t{\n\t\tif (line != \"\")\n\t\t{\n\t\t\tm_parsedProcessFilters.Add(line);\n\t\t}\n\t}\n}\n\nbool CRegExFilterData::MatchesProcessFilters(CString &activeApp)\n{\n\tif (activeApp == _T(\"\"))\n\t{\n\t\treturn true;\n\t}\n\n\tint count = (int)m_parsedProcessFilters.GetCount();\n\n\tif (count == 0)\n\t{\n\t\treturn true;\n\t}\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tif (CWildCardMatch::WildMatch(m_parsedProcessFilters[i], activeApp, \"\"))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool CRegExFilterData::MatchesRegEx(std::wstring &copiedText)\n{\n\t//std::wregex integer(_T(\"(\\\\+|-)?[[:digit:]]+\"));\n\t//std::wstring input(copiedText);\n\tif (m_regEx != _T(\"\"))\n\t{\n\t\ttry \n\t\t{\n\t\t\tstd::wregex integer(m_regEx);\n\t\t\tif (regex_match(copiedText, integer))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (regex_error e) \n\t\t{\n\t\t\tCString w(e.what());\n\t\t\tLog(StrF(_T(\"MatchesRegEx exception: %s, Code Is: %d\"), w, e.code()));\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nCRegExFilterHelper::CRegExFilterHelper()\n{\n}\n\n\nCRegExFilterHelper::~CRegExFilterHelper()\n{\n}\n\nvoid CRegExFilterHelper::Add(int pos, CRegExFilterData &data)\n{\n\tif (pos >= 0 && pos < MAX_REGEX_FILTERS)\n\t{\n\t\tATL::CCritSecLock csLock(m_critSection.m_sect);\n\t\tm_filters[pos] = data;\n\t}\n}\n\nvoid CRegExFilterHelper::SetRegEx(int pos, std::wstring regEx)\n{\n\tif (pos >= 0 && pos < MAX_REGEX_FILTERS)\n\t{\n\t\tATL::CCritSecLock csLock(m_critSection.m_sect);\n\t\tm_filters[pos].m_regEx = regEx;\n\t}\n}\n\nvoid CRegExFilterHelper::SetProcessFilter(int pos, CString processName)\n{\n\tif (pos >= 0 && pos < MAX_REGEX_FILTERS)\n\t{\n\t\tATL::CCritSecLock csLock(m_critSection.m_sect);\n\t\tm_filters[pos].m_processFilters = processName;\n\t\tm_filters[pos].ParseFilters();\n\t}\n}\n\nbool CRegExFilterHelper::TextMatchFilters(CString &activeApp, std::wstring &copiedText)\n{\n\tATL::CCritSecLock csLock(m_critSection.m_sect);\n\n\tfor (int i = 0; i < MAX_REGEX_FILTERS; i++)\n\t{\n\t\tif (m_filters[i].MatchesProcessFilters(activeApp))\n\t\t{\n\t\t\tif (m_filters[i].MatchesRegEx(copiedText))\n\t\t\t{\n\t\t\t\tLog(StrF(_T(\"regex matches copied text NOT SAVING CLIP, regex: %s, text: %s, active app: %s\"), m_filters[i].m_regEx.c_str(), copiedText.c_str(), activeApp));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
        },
        {
          "name": "RegExFilterHelper.h",
          "type": "blob",
          "size": 0.876953125,
          "content": "#pragma once\n\n#include <vector>\n#include <string>\n\n#define MAX_REGEX_FILTERS 15\n\nclass CRegExFilterData\n{\npublic:\n\tstd::wstring m_regEx;\n\tCString m_processFilters;\n\tCStringArray m_parsedProcessFilters;\n\n\tvoid ParseFilters();\n\n\tbool MatchesProcessFilters(CString &activeApp);\n\tbool MatchesRegEx(std::wstring &copiedText);\n\n\tconst CRegExFilterData& operator=(const CRegExFilterData &clip)\n\t{\n\t\tm_regEx = clip.m_regEx;\n\t\tm_processFilters = clip.m_processFilters;\n\n\t\tParseFilters();\n\t\t\n\t\treturn *this;\n\t}\n};\n\nclass CRegExFilterHelper\n{\npublic:\n\tCRegExFilterHelper();\n\t~CRegExFilterHelper();\n\n\tvoid Add(int pos, CRegExFilterData &data);\n\tvoid SetRegEx(int pos, std::wstring regEx);\n\tvoid SetProcessFilter(int pos, CString processName);\n\n\tCRegExFilterData m_filters[MAX_REGEX_FILTERS];\n\n\tbool TextMatchFilters(CString &activeApp, std::wstring &copiedText);\n\nprivate:\n\tCCriticalSection m_critSection;\n};\n\n"
        },
        {
          "name": "Resource.h",
          "type": "blob",
          "size": 38.060546875,
          "content": "//{{NO_DEPENDENCIES}}\r\n// Microsoft Visual C++ generated include file.\r\n// Used by CP_Main.rc\r\n//\r\n#define IDD_ABOUTBOX                    100\r\n#define IDR_CP_MAIN                     103\r\n#define IDR_MAINFRAME                   128\r\n#define IDR_CP_MAITYPE                  129\r\n#define IDR_EDIT_WND                    129\r\n#define IDR_MENU                        130\r\n#define IDD_SELECT_DB                   131\r\n#define IDD_OPTIONS_STATS               132\r\n#define IDD_ADD_TYPE                    134\r\n#define IDD_COPY_PROPERTIES             135\r\n#define IDD_ABOUT                       136\r\n#define IDD_GROUP_NAME                  138\r\n#define IDB_CLOSED_FOLDER               141\r\n#define IDB_CLOSED_FOLDER_PRESSED       142\r\n#define IDB_CLOSED_FOLDER_FOCUSED       143\r\n#define IDB_OPEN_FOLDER                 144\r\n#define IDB_OPEN_FOLDER_FOCUSED         145\r\n#define IDB_OPEN_FOLDER_PRESSED         146\r\n#define IDB_BACK                        147\r\n#define IDB_BACK_PRESSED                148\r\n#define IDD_OPTIONS_FRIENDS             148\r\n#define IDB_BACK_FOCUSED                149\r\n#define IDI_DITTO_NOCOPYCB              150\r\n#define IDD_FRIEND_DETAILS              152\r\n#define IDD_MOVE_TO_GROUP               156\r\n#define IDD_DIALOG_REMOTE_FILE          157\r\n#define IDR_FILE_COPY                   158\r\n#define IDD_OPTIONS_COPY_BUFFERS        166\r\n#define IDI_ICON1                       167\r\n#define IDD_DIALOG1                     168\r\n#define IDD_GLOBAL_CLIPS                168\r\n#define IDB_BITMAP_SEARCH_NORMAL        170\r\n#define IDB_BITMAP_SEARCH_CLOSE         171\r\n#define IDB_BITMAP1                     172\r\n#define IDB_BITMAP_SEARCH_CLOSE_125     173\r\n#define IDB_BITMAP_SEARCH_CLOSE_150     174\r\n#define IDB_BITMAP_SEARCH_CLOSE_200     175\r\n#define IDB_BITMAP_SEARCH_NORMAL_125    176\r\n#define IDB_BITMAP_SEARCH_NORMAL_150    177\r\n#define IDB_BITMAP_SEARCH_NORMAL_200    178\r\n#define IDB_OPEN_FOLDER_PNG             179\r\n#define IDB_PNG1                        180\r\n#define IDR_MENU_SEARCH                 181\r\n#define IDB_PNG2                        183\r\n#define IDB_COG_16_16                   183\r\n#define IDB_SHORTCUT_PNG                184\r\n#define IDB_OPEN_FOLDER_16_16           185\r\n#define IDB_OPEN_FOLDER_20_20           186\r\n#define IDB_OPEN_FOLDER_24_24           187\r\n#define IDB_PNG4                        188\r\n#define IDB_OPEN_FOLDER_32_32           188\r\n#define IDB_COG_20_20                   190\r\n#define IDB_COG_24_24                   191\r\n#define IDB_COG_32_32                   192\r\n#define IDB_LEFT_ARROW_16_16            193\r\n#define IDB_LEFT_ARROW_20_20            194\r\n#define IDB_LEFT_ARROW_24_24            195\r\n#define IDB_LEFT_ARROW_32_32            196\r\n#define IDB_CLOSE_12_12                 197\r\n#define IDB_CLOSE_8_8                   197\r\n#define IDB_CHEVRON_RIGHT_8_8           198\r\n#define IDB_CLOSE_10_10                 199\r\n#define IDB_CLOSE_12_13                 200\r\n#define IDB_PNG3                        201\r\n#define IDB_CLOSE_16_16                 201\r\n#define IDB_CHEVRON_RIGHT_10_10         202\r\n#define IDB_CHEVRON_RIGHT_12_12         203\r\n#define IDB_CHEVRON_RIGHT_16_16         204\r\n#define IDB_CHEVRON_LEFT_8_8            205\r\n#define IDB_CHEVRON_LEFT_10_10          206\r\n#define IDB_CHEVRON_LEFT_12_12          207\r\n#define IDB_CHEVRON_LEFT_16_16          208\r\n#define IDB_CHEVRON_TOP_8_8             209\r\n#define IDB_CHEVRON_TOP_10_10           210\r\n#define IDB_CHEVRON_TOP_12_12           211\r\n#define IDB_CHEVRON_TOP_16_16           212\r\n#define IDB_CHEVRON_BOTTOM_8_8          213\r\n#define IDB_CHEVRON_BOTTOM_10_10        214\r\n#define IDB_CHEVRON_BOTTOM_12_12        215\r\n#define IDB_CHEVRON_BOTTOM_16_16        216\r\n#define IDB_PNG5                        217\r\n#define IDB_MAXIMIZE_8_8                218\r\n#define IDB_MAXIMIZE_10_10              219\r\n#define IDB_MAXIMIZE_12_12              220\r\n#define IDB_PNG7                        221\r\n#define IDB_MAXIMIZE_16_16              221\r\n#define IDB_YELLOW_STAR_32_32           222\r\n#define IDB_YELLOW_STAR_24_24           223\r\n#define IDB_YELLOW_STAR_20_20           224\r\n#define IDB_YELLOW_STAR_16_16           225\r\n#define IDB_IN_FOLDER_32_32             226\r\n#define IDB_IN_FOLDER_24_24             227\r\n#define IDB_IN_FOLDER_20_20             228\r\n#define IDB_IN_FOLDER_16_16             229\r\n#define IDB_FOLDER_WHITE_16             229\r\n#define IDB_KEY_32_32                   230\r\n#define IDB_KEY_24_24                   231\r\n#define IDB_KEY_20_20                   232\r\n#define IDB_KEY_16_16                   233\r\n#define IDB_STICKY_32_32                234\r\n#define IDB_STICKY_24_24                235\r\n#define IDB_STICKY_20_20                236\r\n#define IDB_PNG8                        237\r\n#define IDB_STICKY_16_16                237\r\n#define IDR_DESC_OPTIONS_MENU           238\r\n#define IDR_MENU1                       239\r\n#define IDR_MENU_GROUPS                 239\r\n#define IDB_PNG9                        241\r\n#define IDB_SYSTEM_MENU_16_16           244\r\n#define IDB_SYSTEM_MENU_20_20           245\r\n#define IDB_SYSTEM_MENU_24_24           246\r\n#define IDB_SYSTEM_MENU_32_32           247\r\n#define IDR_QUICK_PASTE_SYSTEM_MENU     248\r\n#define IDD_OPTIONS_QUICK_PASTE_KEYBOARD 249\r\n#define ChevronRight_Black_16_16        259\r\n#define ChevronRight_Black_20_20        260\r\n#define ChevronRight_Black_24_24        261\r\n#define ChevronRight_Black_32_32        262\r\n#define Close_Black_16_16               263\r\n#define Close_Black_20_20               264\r\n#define Close_Black_24_24               265\r\n#define Close_Black_32_32               266\r\n#define IDB_PNG6                        267\r\n#define NewWindowIcon_24_14             267\r\n#define IDB_PNG10                       273\r\n#define system_menu_2_48                274\r\n#define system_menu_2_36                275\r\n#define system_menu_2_30                276\r\n#define system_menu_2_24                277\r\n#define open_folder_48                  278\r\n#define open_folder_36                  279\r\n#define open_folder_30                  280\r\n#define open_folder_24                  281\r\n#define ChevronLeft_Black_16_16         282\r\n#define ChevronLeft_Black_20_20         283\r\n#define ChevronLeft_Black_24_24         284\r\n#define ChevronLeft_Black_32_32         285\r\n#define NewWindowIcon_48                286\r\n#define NewWindowIcon_36                287\r\n#define NewWindowIcon_30                288\r\n#define return_16                       289\r\n#define return_20                       290\r\n#define return_24                       291\r\n#define IDB_PNG14                       292\r\n#define return_32                       292\r\n#define Search_16                       293\r\n#define Search_20                       294\r\n#define Search_24                       295\r\n#define IDB_PNG15                       296\r\n#define Search_32                       296\r\n#define IDI_ICON2                       297\r\n#define IDB_PNG11                       298\r\n#define search_close_16                 298\r\n#define IDB_FOLDER                      300\r\n#define minimize_16                     301\r\n#define minimize_32                     302\r\n#define minimize_24                     303\r\n#define minimize_20                     304\r\n#define maximize_32                     305\r\n#define maximize_24                     306\r\n#define IDB_PNG17                       307\r\n#define maximize_20                     307\r\n#define return_28                       308\r\n#define minimize_28                     309\r\n#define maximize_28                     310\r\n#define ChevronLeft_Black_28            311\r\n#define ChevronRight_Black_28           312\r\n#define Close_Black_28                  313\r\n#define system_menu_2_42                314\r\n#define open_folder_42                  315\r\n#define cog_28                          316\r\n#define IDB_PNG13                       317\r\n#define Search_28                       317\r\n#define IDC_CURSOR1                     322\r\n#define IDC_CURSOR_ZOOM_IN              322\r\n#define IDC_CURSOR2                     323\r\n#define IDC_CURSOR_ZOOM_OUT             323\r\n#define IDD_DIALOG_FREIND_PROMPT        324\r\n#define IDD_DIALOG2                     325\r\n#define IDD_ADV_OPTIONS                 325\r\n#define down_16                         328\r\n#define down_20                         329\r\n#define down_24                         330\r\n#define down_28                         331\r\n#define IDB_PNG20                       332\r\n#define down_32                         332\r\n#define IDD_SCRIPT_EDITOR               333\r\n#define close_36                        340\r\n#define close_40                        341\r\n#define close_44                        342\r\n#define close_48                        343\r\n#define close_52                        344\r\n#define close_56                        345\r\n#define open_folder_54                  346\r\n#define open_folder_60                  347\r\n#define open_folder_66                  348\r\n#define open_folder_72                  349\r\n#define open_folder_78                  350\r\n#define open_folder_84                  351\r\n#define system_menu_54                  352\r\n#define system_menu_60                  353\r\n#define system_menu_66                  354\r\n#define system_menu_72                  355\r\n#define system_menu_78                  356\r\n#define system_menu_84                  357\r\n#define ChevronLeft_Black_36            358\r\n#define ChevronLeft_Black_40            359\r\n#define ChevronLeft_Black_44            360\r\n#define ChevronLeft_Black_48            361\r\n#define ChevronLeft_Black_52            362\r\n#define ChevronLeft_Black_56            363\r\n#define ChevronRight_Black_36           364\r\n#define ChevronRight_Black_40           365\r\n#define ChevronRight_Black_44           366\r\n#define ChevronRight_Black_48           367\r\n#define ChevronRight_Black_52           368\r\n#define ChevronRight_Black_56           369\r\n#define maximize_36                     370\r\n#define maximize_40                     371\r\n#define maximize_44                     372\r\n#define maximize_48                     373\r\n#define maximize_52                     374\r\n#define maximize_56                     375\r\n#define minimize_36                     377\r\n#define minimize_40                     378\r\n#define minimize_44                     379\r\n#define minimize_48                     380\r\n#define minimize_52                     381\r\n#define IDB_PNG22                       382\r\n#define minimize_56                     382\r\n#define search_close_20                 383\r\n#define search_close_24                 384\r\n#define search_close_28                 385\r\n#define IDB_PNG19                       386\r\n#define search_close_32                 386\r\n#define IDR_MENU_NO_DB                  387\r\n#define IDI_ICON3                       388\r\n#define IDI_MAINFRAME_NO_DB             388\r\n#define IDC_PATH                        1000\r\n#define IDC_GET_PATH                    1001\r\n#define IDC_SELECT_SOUND                1002\r\n#define IDC_SELECT                      1003\r\n#define IDC_TRIP_COPIES                 1004\r\n#define IDC_TRIP_PASTES                 1005\r\n#define IDC_RESET_COUNTS                1006\r\n#define IDC_ALL_COPIES                  1007\r\n#define IDC_ALL_PASTES                  1008\r\n#define IDC_TRIP_DATE                   1009\r\n#define IDC_EDIT_ALL_DATE               1010\r\n#define IDC_SAVED_COPIES                1011\r\n#define IDC_SAVED_COPY_DATA             1012\r\n#define IDC_REMOVE_ALL                  1013\r\n#define IDC_DATABASE_SIZE               1014\r\n#define IDC_LIST1                       1014\r\n#define IDC_ADD                         1015\r\n#define IDC_CHECK_SEND_ALL              1015\r\n#define IDC_CLIPS_SENT                  1015\r\n#define IDC_DELETE                      1016\r\n#define IDC_EDIT_IP                     1016\r\n#define IDC_CLIPS_RECIVED               1016\r\n#define IDC_EDIT1                       1017\r\n#define IDC_EDIT_DESCRIPTION            1017\r\n#define IDC_LAST_STARTED                1017\r\n#define IDC_LIST2                       1018\r\n#define IDC_EDIT_APP_COPY_EXCLUDE       1018\r\n#define IDC_EDIT_DESCRIP                1018\r\n#define IDC_EDIT_DESC                   1018\r\n#define IDC_ADD_1                       1019\r\n#define IDC_EDIT_ACTIVE_APP_TITLE       1019\r\n#define IDC_ADD_2                       1020\r\n#define IDC_EDIT_DISPLAY_TEXT           1020\r\n#define IDC_ADD_3                       1021\r\n#define IDC_DELETE_COPY_DATA            1021\r\n#define IDC_DATE                        1022\r\n#define IDC_COPY_DATA                   1023\r\n#define IDC_DATE2                       1024\r\n#define IDC_DATE_LAST_USED              1024\r\n#define IDC_NEVER_AUTO_DELETE           1025\r\n#define IDC_NAMED_COPY                  1026\r\n#define IDC_HOT_KEY_GLOBAL              1026\r\n#define IDC_COMPACT_REPAIR              1027\r\n#define IDC_NAMED_PASTE                 1027\r\n#define IDC_HOT_KEY_GLOBAL_MOVE_TO_GROUP 1027\r\n#define IDC_BT_COMPACT_AND_REPAIR       1028\r\n#define IDC_CHECK_UPDATES               1029\r\n#define IDC_CHECK_FOR_UPDATES           1030\r\n#define IDC_LIST                        1032\r\n#define IDC_CTRL_CLICK                  1033\r\n#define IDC_SET_DB_PATH                 1034\r\n#define IDC_SHOW_TEXT_FOR_FIRST_TEN_HOT_KEYS 1034\r\n#define IDC_USE_DEFAULT                 1035\r\n#define IDC_CTRL_CLICK2                 1035\r\n#define IDC_HYPER_LINK                  1036\r\n#define IDC_ALLOW_DUPLICATES            1037\r\n#define IDC_UPDATE_TIME_ON_PASTE        1038\r\n#define IDC_SAVE_MULTIPASTE             1039\r\n#define IDC_BUTTON1                     1040\r\n#define IDC_PARSE_BUTTON                1040\r\n#define IDC_HIDE_DITO_ON_HOT_KEY        1040\r\n#define IDC_BUTTON_FONT                 1040\r\n#define IDC_BUTTON_NEW_GROUP            1040\r\n#define IDC_BUTTON_REFRESH              1040\r\n#define IDC_BUTTON_SEARCH               1040\r\n#define IDC_ASSIGN                      1040\r\n#define IDC_BUTTON_CLEAR                1040\r\n#define IDC_BUTTON_RUN                  1040\r\n#define IDC_BUTTON_COPY_SCRIPTS         1040\r\n#define IDC_PARSE_EDIT                  1041\r\n#define IDC_SEND_PASTE_MESSAGE          1041\r\n#define IDC_BUTTON_PROPERTIES           1041\r\n#define IDC_BUTTON_PASTE_SCRIPTS        1041\r\n#define IDC_CHECK1                      1042\r\n#define IDC_HISTORY_START_TOP           1042\r\n#define IDC_CHECK_SEND_PASTE            1042\r\n#define IDC_CHECK_LOG_SEND_RECIEVE      1042\r\n#define IDC_ENSURE                      1042\r\n#define IDC_PLAY_SOUND_1                1042\r\n#define IDC_CHECK_CLIP_TITLE            1042\r\n#define IDC_CHECK_SHIFT_1               1042\r\n#define IDC_CHECK_ACTIVE                1042\r\n#define IDC_PLAY_SOUND_2                1043\r\n#define IDC_CHECK_MOVE_CLIPS_ON_PASTE   1043\r\n#define IDC_CHECK_CREATE_DATE           1043\r\n#define IDC_CHECK_SHIFT_2               1043\r\n#define IDC_PLAY_SOUND_3                1044\r\n#define IDC_CHECK_LAST_USE_DATE         1044\r\n#define IDC_CHECK_MOVE_CLIPS_ON_PASTE2  1044\r\n#define IDC_CHECK_USE_UI_GROUP_LAST_10  1044\r\n#define IDC_CHECK_DATA_FORMAT           1045\r\n#define IDC_PLAY_SOUND_4                1045\r\n#define IDC_PLAY_SOUND_5                1046\r\n#define IDD_OPTIONS_KEYSTROKES          2001\r\n#define IDC_HOTKEY                      2002\r\n#define IDC_DISPLAY_IN_SYSTEMTRAY       2003\r\n#define IDD_OPTIONS_GENERAL             2003\r\n#define IDC_HOTKEY_TEXT_ONLY            2003\r\n#define IDC_HOTKEY_MOVE_TO_GROUP        2003\r\n#define IDD_OPTIONS_TYPES               2004\r\n#define IDC_START_ON_STARTUP            2004\r\n#define IDC_HOTKEY_SAVE_CLIPBOARD       2004\r\n#define IDR_QUICK_PASTE                 2005\r\n#define IDC_HOTKEY_ACTIVATE_2           2005\r\n#define IDC_TRANSPARENCY                2006\r\n#define IDD_OPTIONS_QUICK_PASTE         2006\r\n#define IDC_HOTKEY_ACTIVATE_3           2006\r\n#define IDD_OPTIONS_UTILITIES           2007\r\n#define IDC_TRANS_PERC                  2007\r\n#define IDC_HOTKEY_COPYSAVECLIPBOARD    2007\r\n#define IDC_MAXIMUM                     2008\r\n#define IDD_DELETE_CLIPS                2008\r\n#define IDD_DELETE_CLIP_DATA            2008\r\n#define IDC_EXPIRE                      2009\r\n#define IDC_EXPIRE_AFTER                2010\r\n#define IDC_DESC_TEXT_SIZE              2011\r\n#define IDC_MAX_SAVED_COPIES            2012\r\n#define IDC_LINES_ROW                   2013\r\n#define IDC_AT_CARET                    2015\r\n#define IDC_AT_CURSOR                   2016\r\n#define IDC_AT_PREVIOUS                 2017\r\n#define IDC_COMPACT_DB                  2018\r\n#define IDC_REPAIR                      2019\r\n#define IDC_DESC_SHOW_LEADING_WHITESPACE 2021\r\n#define IDC_NAME                        2022\r\n#define IDC_SHOW_THUMBNAILS             2022\r\n#define IDC_COMBO1                      2023\r\n#define IDC_DRAW_RTF                    2023\r\n#define IDC_HOTKEY1                     2024\r\n#define IDC_HOTKEY2                     2025\r\n#define IDC_EDIT_PLACE_ON_CLIPBOARD     2025\r\n#define IDC_HOTKEY3                     2026\r\n#define IDC_CHECK_DISABLE_FRIENDS       2026\r\n#define IDC_HOTKEY4                     2027\r\n#define IDC_TREE                        2027\r\n#define IDC_HOTKEY5                     2028\r\n#define IDC_RICHEDIT1                   2028\r\n#define IDC_HOTKEY6                     2029\r\n#define IDC_STATIC_FORMATS              2029\r\n#define IDC_HOTKEY7                     2030\r\n#define IDC_HOTKEY8                     2031\r\n#define IDC_BUTTON_DEFAULT_FAULT        2031\r\n#define IDC_HOTKEY9                     2032\r\n#define IDC_EDIT_PASSWORD               2032\r\n#define IDC_HOTKEY10                    2033\r\n#define IDC_EDIT_PLAY_SOUND             2033\r\n#define IDC_BUTTON_PLAY                 2034\r\n#define IDC_CHECK_WIN_DITTO             2035\r\n#define IDC_CHECK_WIN_NAMED_COPY        2036\r\n#define IDC_CHECK_FIND_AS_YOU_TYPE      2036\r\n#define IDC_CHECK_WIN_TEXT              2036\r\n#define IDC_CHECK_WIN_TEXT_ONLY         2036\r\n#define IDC_CHECK_WIN6                  2037\r\n#define IDC_CHECK_ENTIRE_WINDOW_IS_VISIBLE 2037\r\n#define IDC_EDIT_ADDITIONAL             2037\r\n#define IDC_CHECK_WIN7                  2038\r\n#define IDC_CHECK_SHOW_ALL_IN_MAIN_LIST 2038\r\n#define IDC_EDIT_MAX_SIZE               2038\r\n#define IDC_CHECK_WIN8                  2039\r\n#define IDC_STATIC_HOT_KEY              2039\r\n#define IDC_CHECK_PROMPT_DELETE_CLIP    2039\r\n#define IDC_CHECK_WIN9                  2040\r\n#define IDC_STATIC_DATE                 2040\r\n#define IDC_CHECK_PROMPT_DELETE_CLIP2   2040\r\n#define IDC_CHECK_SHOW_SCROLL_BAR       2040\r\n#define IDC_CHECK_WIN10                 2041\r\n#define IDC_STATIC_MOVE_TO_GROUP        2041\r\n#define IDC_CHECK_SHOW_SCROLL_BAR2      2041\r\n#define IDC_CHECK_ELEVATE_PRIVILEGES    2041\r\n#define IDC_CHECK_WIN1                  2042\r\n#define IDC_STATIC_TITLE                2042\r\n#define IDC_CHECK_ELEVATE_PRIVILEGES2   2042\r\n#define IDC_CHECK_SHOW_IN_TASKBAR       2042\r\n#define IDC_CHECK_WIN2                  2043\r\n#define IDC_STATIC_DAYS                 2043\r\n#define IDC_STATIC_DATE2                2043\r\n#define IDC_CHECK_SHOW_IN_TASKBAR2      2043\r\n#define IDC_CHECK_SHOW_CLIP_WAS_PASTED  2043\r\n#define IDC_CHECK_WIN3                  2044\r\n#define IDC_STATIC_AMOUNT               2044\r\n#define IDC_STATIC_HOT_KEY2             2044\r\n#define IDC_STATIC_HOT_KEY_MOVE_TO_GROUP 2044\r\n#define IDC_CHECK_WIN4                  2045\r\n#define IDC_STATIC_SOUND                2045\r\n#define IDC_STATIC_DATE3                2045\r\n#define IDC_CHECK_WIN5                  2046\r\n#define IDC_STATIC_MAX_SIZE             2046\r\n#define IDC_STATIC_NO_LIMIT             2047\r\n#define IDC_CHECK_WIN_NAMED_PASTE       2047\r\n#define IDC_CHECK_WIN_SAVE_CLIPBOARD    2047\r\n#define IDC_STATIC_ACTIVATE             2048\r\n#define IDC_STATIC_NAMED_COPY           2049\r\n#define IDC_STATIC_ACTIVATE2            2049\r\n#define IDC_STATIC_WIN                  2050\r\n#define IDC_STATIC_GROUP                2051\r\n#define IDC_STATIC_1                    2052\r\n#define IDC_STATIC_2                    2053\r\n#define IDC_STATIC_3                    2054\r\n#define IDC_STATIC_4                    2055\r\n#define IDC_STATIC_5                    2056\r\n#define IDC_STATIC_6                    2057\r\n#define IDC_STATIC_7                    2058\r\n#define IDC_STATIC_8                    2059\r\n#define IDC_STATIC_9                    2060\r\n#define IDC_STATIC_10                   2061\r\n#define IDC_STATIC_LINES                2062\r\n#define IDC_STATIC_NAMED_COPY2          2062\r\n#define IDC_STATIC_COLLECT_CLIPBOARD    2062\r\n#define IDC_STATIC_POPUP                2063\r\n#define IDC_CHECK_WIN_DITTO2            2063\r\n#define IDC_STATIC_LEGEND               2064\r\n#define IDC_STATIC_ACTIVATE3            2064\r\n#define IDC_STATIC_LEG                  2065\r\n#define IDC_CHECK_WIN_DITTO3            2065\r\n#define IDC_STATIC_11                   2066\r\n#define IDC_STATIC_ACTIVATE4            2066\r\n#define IDC_STATIC_12                   2067\r\n#define IDC_CHECK_WIN_SAVE_CLIPBOARD2   2067\r\n#define IDC_CHECK_WIN_COPY_SAVE_CLIPBOARD 2067\r\n#define IDC_STATIC_13                   2068\r\n#define IDC_STATIC_COLLECT_CLIPBOARD2   2068\r\n#define IDC_STATIC_LANGUAGE             2069\r\n#define IDC_COMBO_LANGUAGE              2070\r\n#define IDC_EDIT_SAVE_DELAY             2071\r\n#define IDC_COMBO_POPUP_POSITION        2071\r\n#define IDC_STATIC_SAVE_DELAY           2072\r\n#define IDC_BUTTON_ABOUT                2073\r\n#define IDC_EDIT_QUICK_PASTE            2074\r\n#define IDC_STATIC_LINK                 2075\r\n#define IDC_PROGRESS_FILE               2076\r\n#define IDC_PROGRESS_ALL_FILES          2077\r\n#define IDC_FILE_COPY                   2078\r\n#define IDC_STATIC_COPY_1               2079\r\n#define IDC_STATIC_PASTE_1              2080\r\n#define IDC_STATIC_CUT_1                2081\r\n#define IDC_COPY_1                      2082\r\n#define IDC_PASTE_1                     2083\r\n#define IDC_CUT_1                       2084\r\n#define IDC_WIN_COPY_1                  2085\r\n#define IDC_WIN_PASTE_1                 2086\r\n#define IDC_WIN_CUT_1                   2087\r\n#define IDC_BUFFER_GROUP_1              2088\r\n#define IDC_COPY_2                      2089\r\n#define IDC_EDIT_CLIP_SEPARATOR         2089\r\n#define IDC_WIN_COPY_2                  2090\r\n#define IDC_STATIC_CLIP_SEPARATOR       2090\r\n#define IDC_PASTE_2                     2091\r\n#define IDC_STATIC_CUSTOM_KEYS          2091\r\n#define IDC_WIN_PASTE_2                 2092\r\n#define IDC_STATIC_THEME                2092\r\n#define IDC_STATIC_COPY_2               2093\r\n#define IDC_COMBO_THEME                 2093\r\n#define IDC_STATIC_PASTE_2              2094\r\n#define IDC_BUTTON_THEME                2094\r\n#define IDC_CUT_2                       2095\r\n#define IDC_STATIC_INCLUDE_APPS         2095\r\n#define IDC_WIN_CUT_2                   2096\r\n#define IDC_STATIC_EXCLUDE_APPS         2096\r\n#define IDC_STATIC_CUT_2                2097\r\n#define IDC_EDIT_APP_COPY_INCLUDE       2097\r\n#define IDC_BUFFER_GROUP_2              2098\r\n#define IDC_STATIC_APP_SEP_DESC         2098\r\n#define IDC_COPY_3                      2099\r\n#define IDC_CHECK_WIN                   2099\r\n#define IDC_STATIC_DATABASE_PATH        2099\r\n#define IDC_WIN_COPY_3                  2100\r\n#define IDC_EDIT_PROPERTIES             2100\r\n#define IDC_STATIC_POPUP_POS            2100\r\n#define IDC_PASTE_3                     2101\r\n#define IDC_CHECK_WIN_MOVE_TO_GROUP     2101\r\n#define IDC_STATIC_POPUP_POS2           2101\r\n#define IDC_STATIC_FONT                 2101\r\n#define IDC_WIN_PASTE_3                 2102\r\n#define IDC_TIME_CREATE_START           2102\r\n#define IDC_STATIC_COPY_3               2103\r\n#define IDC_DATE_CREATE_START           2103\r\n#define IDC_STATIC_PASTE_3              2104\r\n#define IDC_TIME_CREATE_END             2104\r\n#define IDC_CUT_3                       2105\r\n#define IDC_DATE_CREATE_END             2105\r\n#define IDC_WIN_CUT_3                   2106\r\n#define IDC_TIME_USE_START              2106\r\n#define IDC_STATIC_CUT_3                2107\r\n#define IDC_DATE_USE_START              2107\r\n#define IDC_BUFFER_GROUP_3              2108\r\n#define IDC_TIME_USE_END                2108\r\n#define IDC_DATE_USE_END                2109\r\n#define IDC_COPY_4                      2109\r\n#define IDC_EDIT_CLIP_TITLE             2110\r\n#define IDC_WIN_COPY_4                  2110\r\n#define IDC_COMBO_DATA_FORMAT           2111\r\n#define IDC_PASTE_4                     2111\r\n#define IDC_STATIC_DB_SIZE              2112\r\n#define IDC_WIN_PASTE_4                 2112\r\n#define IDC_STATIC_SELECTED_SIZE        2113\r\n#define IDC_CUT_4                       2113\r\n#define IDC_STATIC_TO_DELETE_SIZE       2114\r\n#define IDC_STATIC_SELECTED_SIZE2       2114\r\n#define IDC_STATIC_SELECTED_COUNT       2114\r\n#define IDC_WIN_CUT_4                   2114\r\n#define IDC_STATIC_DB_SIZE_TEXT         2115\r\n#define IDC_STATIC_COPY_4               2115\r\n#define IDC_STATIC_SELECTED_SIZE_TEXT   2116\r\n#define IDC_STATIC_PASTE_4              2116\r\n#define IDC_STATIC_TO_DELETE_TEXT       2117\r\n#define IDC_STATIC_SELECTED_SIZE_TEXT2  2117\r\n#define IDC_STATIC_CUT_4                2117\r\n#define IDC_BUTTON_APPLY                2118\r\n#define IDC_BUFFER_GROUP_4              2118\r\n#define IDC_COPY_5                      2119\r\n#define IDC_STATIC_GROUP_SEARCH         2120\r\n#define IDC_WIN_COPY_5                  2120\r\n#define IDC_MFCPROPERTYGRID1            2121\r\n#define IDC_PASTE_5                     2121\r\n#define IDC_STATIC_DIFF                 2122\r\n#define IDC_WIN_PASTE_5                 2122\r\n#define IDC_EDIT_DIFF_PATH              2123\r\n#define IDC_CUT_5                       2123\r\n#define IDC_BUTTON2                     2124\r\n#define IDC_BUTTON_DIFF_BROWSE          2124\r\n#define IDC_BUTTON_REMOVE               2124\r\n#define IDC_BUTTON_ADVANCED             2124\r\n#define IDC_BUTTON_ADD_SCRIPT           2124\r\n#define IDC_WIN_CUT_5                   2124\r\n#define IDC_STATIC_QUICK_PASTE          2125\r\n#define IDC_BUTTON_DELETE_SCRIPT        2125\r\n#define IDC_STATIC_COPY_5               2125\r\n#define IDC_STATIC_DESC                 2126\r\n#define IDC_STATIC_PASTE_5              2126\r\n#define IDC_RADIO_USE_IP                2127\r\n#define IDC_RADIO_KEYBOARD              2127\r\n#define IDC_RADIO_KEYBOARD_1            2127\r\n#define IDC_STATIC_CUT_5                2127\r\n#define IDC_STATIC_REMOTE_FILES         2128\r\n#define IDC_RADIO2                      2128\r\n#define IDC_RADIO_ENTER                 2128\r\n#define IDC_RADIO_CURRENT_TYPES         2128\r\n#define IDC_BUFFER_GROUP_5              2128\r\n#define IDC_RADIO_USE_HOST_NAME         2129\r\n#define IDC_COMBO_ENTER_MODIFIER        2129\r\n#define IDC_STATIC_REMOTE_FILE_REQUEST  2130\r\n#define IDC_RADIO3                      2130\r\n#define IDC_RADIO_MOUSE                 2130\r\n#define IDC_RADIO_MOUSE_1               2130\r\n#define IDC_RADIO_CUSTOM_TYPE           2130\r\n#define IDC_COMBO_ALL_ASSIGNED          2131\r\n#define IDC_BUTTON_ADD                  2132\r\n#define IDC_RADIO_KEYBOARD2             2133\r\n#define IDC_RADIO_KEYBOARD_2            2133\r\n#define IDC_RADIO_ENTER2                2134\r\n#define IDC_COMBO_ENTER_MODIFIER2       2135\r\n#define IDC_BUTTON_ENTER                2135\r\n#define IDC_RADIO4                      2136\r\n#define IDC_RADIO_MOUSE_2               2136\r\n#define IDC_BUTTON_ENTER2               2137\r\n#define IDC_MOUSE_A                     2138\r\n#define IDC_MOUSE_1                     2138\r\n#define IDC_CHECK_CONTROL_1             2139\r\n#define IDC_CHECK_ALT_1                 2140\r\n#define IDC_MOUSE_2                     2141\r\n#define IDC_CHECK_CONTROL_2             2142\r\n#define IDC_CHECK_ALT_2                 2143\r\n#define IDC_BUTTON3                     2144\r\n#define IDC_BUTTON_RESET                2144\r\n#define IDC_RADIO1                      2145\r\n#define IDC_RADIO_PRIMARY_TYPES         2145\r\n#define IDC_CHECK_ENABLE_SECOND_PRESS   2146\r\n#define IDC_STATIC_SECOND_PRESS         2147\r\n#define IDC_STATIC_SHORTCUTS            2148\r\n#define IDC_STATIC_FIRST_KEYPRESS       2149\r\n#define IDC_STATIC_FRIEND_PROMPT        2150\r\n#define IDC_CHECK_SAVE                  2151\r\n#define IDC_STATIC_FRIEND_DESC          2152\r\n#define IDC_EDIT_NAME                   2153\r\n#define IDC_EDIT_SCRIPT                 2155\r\n#define IDC_STATIC_NAME                 2156\r\n#define IDC_EDIT_INPUT                  2157\r\n#define IDC_EDIT_OUTPUT                 2158\r\n#define IDC_STATIC_INPUT                2159\r\n#define IDC_STATIC_OUTPUT               2160\r\n#define IDC_LIST_SCRIPTS                2161\r\n#define IDC_STATIC_RETURN_DESC          2162\r\n#define IDC_STATIC_SCRIPT               2163\r\n#define IDC_STATIC_ACTIVE               2164\r\n#define IDC_MFCLINK1                    2165\r\n#define IDC_MFCLINK_CHAISCRIPT          2165\r\n#define IDC_MFCLINK_ENV_VAR             2165\r\n#define IDC_MFCLINK2_EXAMPLES           2166\r\n#define IDC_STATIC_MD5                  2167\r\n#define IDC_EDIT_MD5                    2168\r\n#define IDC_RICHEDIT21                  2172\r\n#define IDC_MFCLINK2                    2172\r\n#define IDC_EDIT_ACTIVE_APP             2173\r\n#define ID_FIRST_OPTION                 32771\r\n#define ID_FIRST_EXIT                   32772\r\n#define ID_FIRST_SHOWQUICKPASTE         32773\r\n#define ID_FIRST_TOGGLECONNECTCV        32774\r\n#define ID_MENU_TOGGLECONNECTCV         32775\r\n#define ID_MENU_PROPERTIES              32776\r\n#define ID_MENU_FIRSTTENHOTKEYS_USECTRLNUM 32777\r\n#define ID_MENU_FIRSTTENHOTKEYS_SHOWHOTKEYTEXT 32778\r\n#define ID_MENU_VIEWCAPTIONBARON        32779\r\n#define ID_VIEWCAPTIONBARON_RIGHT       32780\r\n#define ID_VIEWCAPTIONBARON_BOTTOM      32781\r\n#define ID_VIEWCAPTIONBARON_LEFT        32782\r\n#define ID_VIEWCAPTIONBARON_TOP         32783\r\n#define ID_MENU_ALLWAYSONTOP            32784\r\n#define ID_MENU_LINESPERROW_2           32786\r\n#define ID_MENU_LINESPERROW_3           32787\r\n#define ID_MENU_LINESPERROW_4           32788\r\n#define ID_MENU_LINESPERROW_5           32789\r\n#define ID_MENU_TRANSPARENCY_40         32790\r\n#define ID_MENU_AUTOHIDE                32791\r\n#define ID_MENU_TRANSPARENCY_10         32792\r\n#define ID_MENU_VIEWFULLDESCRIPTION     32793\r\n#define ID_MENU_TRANSPARENCY_15         32794\r\n#define ID_SORT_ASCENDING               32795\r\n#define ID_MENU_TRANSPARENCY_20         32796\r\n#define ID_SORT_DESCENDING              32797\r\n#define ID_MENU_TRANSPARENCY_25         32798\r\n#define ID_MENU_TRANSPARENCY_30         32799\r\n#define ID_MENU_TRANSPARENCY_NONE       32800\r\n#define ID_MENU_DELETE                  32801\r\n#define ID_MENU_POSITIONING_ATCARET     32802\r\n#define ID_MENU_POSITIONING_ATCURSOR    32803\r\n#define ID_MENU_POSITIONING_ATPREVIOUSPOSITION 32804\r\n#define ID_MENU_OPTIONS                 32805\r\n#define ID_MENU_EXITPROGRAM             32806\r\n#define ID_MENU_LINESPERROW_1           32807\r\n#define ID_MENU_TRANSPARENCY_5          32808\r\n#define ID_MENU_QUICKOPTIONS            32809\r\n#define ID_MENU_NEWGROUP                32811\r\n#define ID_MENU_NEWGROUPSELECTION       32812\r\n#define ID_MENU_QUICKOPTIONS_ALLWAYSSHOWDESCRIPTION 32813\r\n#define ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSONTOP 32814\r\n#define ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_ROLLUPWINDOW 32815\r\n#define ID_MENU_QUICKOPTIONS_DOUBLECLICKINGONCAPTION_TOGGLESALWAYSSHOWDESCRIPTION 32816\r\n#define ID_MENU_QUICKOPTIONS_PROMPTFORNEWGROUPNAMES 32817\r\n#define ID_MENU_VIEWGROUPS              32819\r\n#define ID_MENU_QUICKPROPERTIES_SETTONEVERAUTODELETE 32820\r\n#define ID_MENU_QUICKPROPERTIES_AUTODELETE 32821\r\n#define ID_MENU_QUICKPROPERTIES_REMOVEHOTKEY 32822\r\n#define ID_MENU_SENTTO_FRIENDONE        32824\r\n#define ID_MENU_SENTTO_FRIEND_TWO       32825\r\n#define ID_MENU_SENTTO_FRIEND_THREE     32826\r\n#define ID_MENU_SENTTO_FRIEND_FORE      32827\r\n#define ID_MENU_SENTTO_FRIEND_FIVE      32828\r\n#define ID_MENU_SENTTO_FRIEND_SIX       32829\r\n#define ID_MENU_SENTTO_FRIEND_SEVEN     32830\r\n#define ID_MENU_SENTTO_FRIEND_EIGHT     32831\r\n#define ID_MENU_SENTTO_FRIEND_NINE      32832\r\n#define ID_MENU_SENTTO_FRIEND_TEN       32833\r\n#define ID_MENU_SENTTO_FRIEND_ELEVEN    32834\r\n#define ID_MENU_SENTTO_FRIEND_TWELVE    32835\r\n#define ID_MENU_SENTTO_FRIEND_THIRTEEN  32836\r\n#define ID_MENU_SENTTO_FRIEND_FORETEEN  32837\r\n#define ID_MENU_SENTTO_FRIEND_FIFTEEN   32838\r\n#define ID_MENU_SENTTO_PROMPTFORIP      32839\r\n#define ID_MENU_GROUPS_MOVETOGROUP      32840\r\n#define ID_MENU_PASTEPLAINTEXTONLY      32841\r\n#define ID_MENU_HELP                    32842\r\n#define ID_FIRST_HELP                   32843\r\n#define ID_MENU_QUICKOPTIONS_FONT       32844\r\n#define ID_MENU_QUICKOPTIONS_SHOWTHUMBNAILS 32845\r\n#define ID_MENU_QUICKOPTIONS_DRAWRTFTEXT 32846\r\n#define ID_MENU_QUICKOPTIONS_PASTECLIPAFTERSELECTION 32847\r\n#define ID_MENU_QUICKOPTIONS_FINDASYOUTYPE 32848\r\n#define ID_MENU_QUICKOPTIONS_ENSUREENTIREWINDOWISVISIBLE 32849\r\n#define ID_MENU_QUICKOPTIONS_SHOWCLIPSTHATAREINGROUPSINMAINLIST 32850\r\n#define ID_MENU_PASTEHTMLASPLAINTEXT    32851\r\n#define ID_QUICKOPTIONS_PROMPTTODELETECLIP 32852\r\n#define ID_MENU_EXPORT                  32853\r\n#define ID_FIRST_IMPORT                 32854\r\n#define ID_MENU_IMPORT                  32855\r\n#define ID_QUICKPROPERTIES_REMOVEQUICKPASTE 32856\r\n#define ID_MENU_EDITITEM                32860\r\n#define ID_BUTTON_SAVE                  32862\r\n#define ID_BUTTON_SAVE_ALL              32863\r\n#define ID_BUTTON_CLOSE                 32864\r\n#define ID_BUTTON_NEW                   32866\r\n#define ID_MENU_NEWCLIP                 32867\r\n#define ID_FIRST_NEWCLIP                32868\r\n#define ID_BUTTON_SAVE_CLOSE_CLIPBOARD  32869\r\n#define ID_FIRST_COPYTODEVICE           32870\r\n#define ID_PASTE_PLAIN_TEXT             32871\r\n#define ID_FIRST_GLOBALHOTKEYS          32872\r\n#define ID_MENU_SEARCHDESCRIPTION       32873\r\n#define ID_MENU_SEARCHFULLTEXT          32874\r\n#define ID_MENU_SEARCHQUICKPASTE        32875\r\n#define ID_MENU_CONTAINSTEXTSEARCHONLY  32876\r\n#define ID_MENU_STICKYCLIPS             32877\r\n#define ID_STICKYCLIPS_MAKETOPSTICKYCLIP 32878\r\n#define ID_STICKYCLIPS_MAKELASTSTICKYCLIP 32879\r\n#define ID_STICKYCLIPS_REMOVESTICKYSETTING 32880\r\n#define ID_QUICKOPTIONS_ELEVATEPREVILEGESTOPASTEINTOELEVATEDAPPS 32881\r\n#define ID_FIRST_REMEMBERWINDOWPOSITION 32882\r\n#define ID_FIRST_SIZEWINDOWTOCONTENT    32883\r\n#define ID_FIRST_SCALEIMAGESTOFITWINDOW 32884\r\n#define ID_QUICKOPTIONS_SHOWINTASKBAR   32885\r\n#define ID_FIRST_DELETECLIPDATA         32886\r\n#define ID_MENU_VIEWASQRCODE            32887\r\n#define ID_MENU_EXPORT32888             32888\r\n#define ID_EXPORT_EXPORTTOTEXTFILE      32889\r\n#define ID_MENU_PASTESPECIAL            32890\r\n#define ID_PASTESPECIAL_TEXTASFILEDROP  32891\r\n#define ID_MENU_COMPARE                 32892\r\n#define ID_COMPARE_SELECTLEFTCOMPARE    32893\r\n#define ID_COMPARE_COMPAREAGAINST       32894\r\n#define ID_COMPARE_COMPARE              32895\r\n#define ID_MENU_NEWGROUP32896           32896\r\n#define ID_MENU_DELETEGROUP             32897\r\n#define ID_MENU_PROPERTIES32898         32898\r\n#define ID_MENU_REGULAREXPRESSIONSEARCH 32899\r\n#define ID_IMPORT_EXPORTTOGOOGLETRANSLATE 32900\r\n#define ID_IMPORT_EXPORTCLIP            32901\r\n#define ID_IMPORT_EXPORTCLIP_BITMAP     32902\r\n#define ID_MENU_WILDCARDSEARCH          32903\r\n#define ID_FIRST_SAVECURRENTCLIPBOARD   32904\r\n#define ID_MENU_SAVECURRENTCLIPBOARD    32905\r\n#define ID_CLIPORDER_MOVEUP             32906\r\n#define ID_CLIPORDER_MOVEDOWN           32907\r\n#define ID_CLIPORDER_MOVETOTOP          32908\r\n#define ID_FIRST_FIXUPSTICKYCLIPORDER   32909\r\n#define ID_MENU_FILTERON                32910\r\n#define ID_MENU_SPECIALPASTE            32911\r\n#define ID_SPECIALPASTE_UPPERCASE       32912\r\n#define ID_SPECIALPASTE_LOWERCASE       32913\r\n#define ID_SPECIALPASTE_CAPITALIZE      32914\r\n#define ID_SPECIALPASTE_SENTENCE        32915\r\n#define ID_SPECIALPASTE_REMOVELINEFEEDS 32916\r\n#define ID_SPECIALPASTE_                32917\r\n#define ID_SPECIALPASTE_PASTE           32918\r\n#define ID_SPECIALPASTE_PASTE32919      32919\r\n#define ID_Menu                         32920\r\n#define ID_Menu32921                    32921\r\n#define ID_SPECIALPASTE_TYPOGLYCEMIA    32922\r\n#define ID_QUICKOPTIONS_SHOWTEXTFORFIRSTTENCOPYHOTKEYS 32923\r\n#define ID_QUICKOPTIONS_SHOWINDICATORACLIPHASBEENPASTED 32924\r\n#define ID_GROUPS_TOGGLELASTGROUP       32925\r\n#define ID_FIRST_HIDEDESCRIPTIONWINDOWONM 32926\r\n#define ID_SPECIALPASTE_PASTE32927      32927\r\n#define ID_FIRST_WRAPTEXT               32928\r\n#define ID_MENU_NEWCLIP32929            32929\r\n#define ID_MENU_IMPORTCLIP              32930\r\n#define ID_MENU_GLOBALHOTKEYS           32931\r\n#define ID_MENU_DELETECLIPDATA          32932\r\n#define ID_MENU_GLOBALHOTKEYS32933      32933\r\n#define ID_MENU_DELETECLIPDATA32934     32934\r\n#define ID_MENU_IMPORTCLIP32935         32935\r\n#define ID_MENU_DELETECLIPDATA32936     32936\r\n#define ID_MENU_NEWCLIP32937            32937\r\n#define ID_CLIPORDER_REPLACETOPSTICKYCLIP 32938\r\n#define ID_SENDTO_PROMPTFORNAME         32939\r\n#define ID_MENU_SAVE                    32940\r\n#define ID_IMPORT_IMPORTCOPIEDFILE      32941\r\n#define ID_FIRST_ALWAYSONTOP            32942\r\n#define ID_CLIPORDER_MOVETOLAST         32943\r\n#define ID_QUICKOPTIONS_                32944\r\n#define ID_SPECIALPASTE_PASTE32945      32945\r\n#define ID_SPECIALPASTE_TRIM            32946\r\n#define ID_TRANSPARENCY_INCREASE        32947\r\n#define ID_TRANSPARENCY_DECREASE        32948\r\n#define ID_TRANSPARENCY_TOGGLE          32949\r\n#define ID_TRANSPARENCY_35              32950\r\n#define ID_IMPORT_EMAILTO               32951\r\n#define ID_IMPORT_GMAIL                 32952\r\n#define ID_IMPORT_EMAILTOASATTACHMENT   32953\r\n#define ID_SPECIALPASTE_SLUGIFY         32954\r\n#define ID_IMPORT_EMAIL                 32955\r\n#define ID_IMPORT_EMAIL_CONTENT_ATTACH  32956\r\n#define ID_QUICKOPTIONS_AUTO            32957\r\n#define ID_SPECIALPASTE_TOGGLECASE      32958\r\n#define ID_FIRST_SHOWSTARTUPMESSAGE     32959\r\n#define ID_FIRST_BACKUPDATABASE         32960\r\n#define ID_FIRST_RESTOREDATABASE        32961\r\n#define ID_MENU_BACKUPDATABASE          32962\r\n#define ID_MENU_SDF                     32963\r\n#define ID_MENU_RESTOREDATABSAE         32964\r\n#define ID_FIRST_OPTIONS                32965\r\n#define ID_FIRST_EXIT32966              32966\r\n#define ID_FIRST_EXIT_NO_DB             32967\r\n#define ID_MENU_DELETEALLNONUSEDCLIPS   32968\r\n#define ID_FIRST_DELETEALLNONUSEDCLIPS  32969\r\n#define ID_IMPORT_SETDRAGFILENAME       32970\r\n#define ID_SPECIALPASTE_CAMELCASE       32971\r\n#define ID_FIRST_VIEWTEXT               32972\r\n#define ID_FIRST_VIEWRTF                32973\r\n#define ID_FIRST_VIEWHTML               32974\r\n#define ID_FIRST_VIEWASIMAGE            32975\r\n#define ID_SPECIALPASTE_MULTIPLEIMAGESHORIZONTALLY 32976\r\n#define ID_SPECIALPASTE_MULTIPLEIMAGES  32977\r\n#define ID_SPECIALPASTE_MULTIPLEIMAGESVERTICALLY 32978\r\n#define ID_SPECIALPASTE_ASCIITEXTONLY   32979\r\n\r\n// Next default values for new objects\r\n// \r\n#ifdef APSTUDIO_INVOKED\r\n#ifndef APSTUDIO_READONLY_SYMBOLS\r\n#define _APS_3D_CONTROLS                     1\r\n#define _APS_NEXT_RESOURCE_VALUE        390\r\n#define _APS_NEXT_COMMAND_VALUE         32980\r\n#define _APS_NEXT_CONTROL_VALUE         2173\r\n#define _APS_NEXT_SYMED_VALUE           104\r\n#endif\r\n#endif\r\n"
        },
        {
          "name": "RichEditCtrlEx.cpp",
          "type": "blob",
          "size": 10.2978515625,
          "content": "// AutoRichEditCtrl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"RichEditCtrlEx.h\"\n#include \"shared/TextConvert.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CAutoRichEditCtrl\n\n_AFX_RICHEDITEX_STATE _afxRichEditStateEx ;\n\nBOOL PASCAL AfxInitRichEditEx()\n{\n    if( ! ::AfxInitRichEdit() )\n    {\n        return FALSE ;\n    }\n\n    _AFX_RICHEDITEX_STATE* l_pState = &_afxRichEditStateEx ;\n\n    if( l_pState->m_hInstRichEdit20 == NULL )\n    {\n#ifdef _UNICODE \n        l_pState->m_hInstRichEdit20 = LoadLibraryW(_T(\"MSFTEDIT.DLL\"));\n#else\n\t\tl_pState->m_hInstRichEdit20 = LoadLibraryA(_T(\"RICHED20.DLL\"));\n#endif\n\n    }\n\n    return l_pState->m_hInstRichEdit20 != NULL ;\n}\n\n\nCRichEditCtrlEx::CRichEditCtrlEx()\n{\n}\n\nCRichEditCtrlEx::~CRichEditCtrlEx()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CRichEditCtrlEx, CRichEditCtrl)\n\t//{{AFX_MSG_MAP(CRichEditCtrlEx)\n\tON_WM_CREATE()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CRichEditCtrlEx message handlers\n\nCString CRichEditCtrlEx::GetRTF()\n{\n\t// Return the RTF string of the text in the control.\n\t\n\t// Stream out here.\n\tEDITSTREAM es;\n\tes.dwError = 0;\n\tes.pfnCallback = CBStreamOut;\t\t// Set the callback\n\n\tCString sRTF = \"\";\n\n\tes.dwCookie = (DWORD_PTR) &sRTF;\t// so sRTF receives the string\n\t\n\tStreamOut(SF_RTF, es);\t\t\t// Call CRichEditCtrl::StreamOut to get the string.\n\t///\n\n\treturn sRTF;\n\n}\n\nvoid CRichEditCtrlEx::SetRTF(const char *pRTF)\n{\n\t// Put the RTF string sRTF into the rich edit control.\n\n\t// Read the text in\n\tEDITSTREAM es;\n\tes.dwError = 0;\n\tes.pfnCallback = CBStreamIn;\n\n#ifdef _UNICODE\n\tCString cs;\n\tes.dwCookie = (DWORD_PTR) &cs;\n#else\n\tCString cs(pRTF);\n\tes.dwCookie = (DWORD_PTR) &cs;\n#endif\n\n\tStreamIn(SF_RTF, es);\t// Do it.\n\n#ifdef _UNICODE\n\tSETTEXTEX stex;\n\tstex.flags = ST_SELECTION | ST_KEEPUNDO;\n\tSendMessage(EM_SETTEXTEX, (WPARAM)&stex, (LPARAM)pRTF); \n#endif\n\n}\n\nvoid CRichEditCtrlEx::SetRTF(CStringA sRTF)\n{\n\t// Put the RTF string sRTF into the rich edit control.\n\n\t// Read the text in\n\tEDITSTREAM es;\n\tes.dwError = 0;\n\tes.pfnCallback = CBStreamIn;\n\n#ifdef _UNICODE\n\tCString cs;\n\tes.dwCookie = (DWORD_PTR) &cs;\n#else\n\tes.dwCookie = (DWORD_PTR) &sRTF;\n#endif\n\n\tStreamIn(SF_RTF, es);\t// Do it.\n\n#ifdef _UNICODE\n\tSETTEXTEX stex;\n    stex.flags = ST_SELECTION | ST_KEEPUNDO;\n\n    SendMessage(EM_SETTEXTEX, (WPARAM)&stex, (LPARAM)sRTF.GetBuffer(sRTF.GetLength())); \n#endif\n\n}\n\nCString CRichEditCtrlEx::GetText()\n{\n\tCString sText;\n\t\n#ifdef _UNICODE\n\tGETTEXTEX stex;\n\tstex.codepage = 1200;  // Unicode code page(set SETTEXTEX documentation)\n\n\tint nSize = GetTextLength();\n\t//increase the size incase of unicode text\n\tnSize++;\n\tnSize = nSize * 2;\n\tstex.cb = nSize;\n\n\tTCHAR *pText = new TCHAR[nSize];\n\tif(pText)\n\t{\n\t\tSendMessage(EM_GETTEXTEX, (WPARAM)&stex, (LPARAM)pText); \n\t\tsText = pText;\n\n\t\tdelete []pText;\n\t\tpText = NULL;\n\t}\n#else\n\t// Stream out here.\n\tEDITSTREAM es;\n\tes.dwError = 0;\n\tes.pfnCallback = CBStreamOut;\t\t// Set the callback\n\tes.dwCookie = (DWORD_PTR) &sText;\t// so sRTF receives the string\n\tStreamOut(SF_TEXT, es);\t\t\t// Call CRichEditCtrl::StreamOut to get the string.\n#endif\n\n\treturn sText;\n}\n\nvoid CRichEditCtrlEx::SetText(CString sText)\n{\n\t// Put the RTF string sRTF into the rich edit control.\n\n\t// Read the text in\n\tEDITSTREAM es;\n\tes.dwError = 0;\n\tes.pfnCallback = CBStreamIn;\n#ifdef _UNICODE\n\tCString cs;\n\tes.dwCookie = (DWORD_PTR) &cs;\n#else\n\tes.dwCookie = (DWORD_PTR) &sText;\n#endif\n\tStreamIn(SF_TEXT, es);\t// Do it.\n\n#ifdef _UNICODE\n\tSETTEXTEX stex;\n    stex.flags = ST_SELECTION | ST_KEEPUNDO;\n    stex.codepage = 1200;  // Unicode code page(set SETTEXTEX documentation)\n    SendMessage(EM_SETTEXTEX, (WPARAM)&stex, (LPARAM)sText.GetBuffer(sText.GetLength())); \n\tsText.ReleaseBuffer();\n#endif\n}\n\n/*\n\tCallback function to stream an RTF string into the rich edit control.\n*/\nDWORD CALLBACK CRichEditCtrlEx::CBStreamIn(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)\n{\n\t// We insert the rich text here.\n\n/*\t\n\tThis function taken from CodeGuru.com\n\thttp://www.codeguru.com/richedit/rtf_string_streamin.shtml\n\tZafir Anjum\n*/\n\n\tCString *pstr = (CString *) dwCookie;\n\n\tif (pstr->GetLength() < cb)\n\t{\n\t\t*pcb = pstr->GetLength();\n\t\tmemcpy(pbBuff, (LPCTSTR) *pstr, *pcb);\n\t\tpstr->Empty();\n\t}\n\telse\n\t{\n\t\t*pcb = cb;\n\t\tmemcpy(pbBuff, (LPCTSTR) *pstr, *pcb);\n\t\t*pstr = pstr->Right(pstr->GetLength() - cb);\n\t}\n\t///\n\n\treturn 0;\n}\n\n/*\n\tCallback function to stream the RTF string out of the rich edit control.\n*/\nDWORD CALLBACK CRichEditCtrlEx::CBStreamOut(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)\n{\n\t// Address of our string var is in psEntry\n\tCString *psEntry = (CString*) dwCookie;\n\t\n\n\tCString tmpEntry = \"\";\n\ttmpEntry = (CString) pbBuff;\n\n\t// And write it!!!\n\t*psEntry += tmpEntry.Left(cb);\n\n\treturn 0;\n}\n\nbool CRichEditCtrlEx::SelectionIsBold()\n{\n\tCHARFORMAT cf = GetCharFormat();\t\n\t\n\tif (cf.dwEffects & CFM_BOLD)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool CRichEditCtrlEx::SelectionIsItalic()\n{\n\tCHARFORMAT cf = GetCharFormat();\t\n\t\n\tif (cf.dwEffects & CFM_ITALIC)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool CRichEditCtrlEx::SelectionIsUnderlined()\n{\n\tCHARFORMAT cf = GetCharFormat();\t\n\t\n\tif (cf.dwEffects & CFM_UNDERLINE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nCHARFORMAT CRichEditCtrlEx::GetCharFormat(DWORD dwMask)\n{\n\tCHARFORMAT cf;\n\tcf.cbSize = sizeof(CHARFORMAT);\n\n\tcf.dwMask = dwMask;\n\n\tGetSelectionCharFormat(cf);\n\n\treturn cf;\n}\n\nvoid CRichEditCtrlEx::SetCharStyle(int MASK, int STYLE, int nStart, int nEnd)\n{\n\tCHARFORMAT cf;\n\tcf.cbSize = sizeof(CHARFORMAT);\n\t//cf.dwMask = MASK;\n\t\n\tGetSelectionCharFormat(cf);\n\t\n\tif (cf.dwMask & MASK)\t// selection is all the same\n\t{\n\t\tcf.dwEffects ^= STYLE; \n\t}\n\telse\n\t{\n\t\tcf.dwEffects |= STYLE;\n\t}\n\t\n\tcf.dwMask = MASK;\n\n\tSetSelectionCharFormat(cf);\n\n}\n\nvoid CRichEditCtrlEx::SetSelectionBold()\n{\n\tlong start=0, end=0;\n\tGetSel(start, end);\t\t// Get the current selection\n\n\tSetCharStyle(CFM_BOLD, CFE_BOLD, start, end);\t// Make it bold\n}\n\nvoid CRichEditCtrlEx::SetSelectionItalic()\n{\n\tlong start=0, end=0;\n\tGetSel(start, end);\n\n\tSetCharStyle(CFM_ITALIC, CFE_ITALIC, start, end);\n}\n\nvoid CRichEditCtrlEx::SetSelectionUnderlined()\n{\n\tlong start=0, end=0;\n\tGetSel(start, end);\n\n\tSetCharStyle(CFM_UNDERLINE, CFE_UNDERLINE, start, end);\n}\n\nvoid CRichEditCtrlEx::SetParagraphCenter()\n{\n\tPARAFORMAT paraFormat;    \n\tparaFormat.cbSize = sizeof(PARAFORMAT);\n\tparaFormat.dwMask = PFM_ALIGNMENT;    \n\tparaFormat.wAlignment = PFA_CENTER;\n\t\n\tSetParaFormat(paraFormat);\t// Set the paragraph.\n}\n\nvoid CRichEditCtrlEx::SetParagraphLeft()\n{\n\tPARAFORMAT paraFormat;\n\tparaFormat.cbSize = sizeof(PARAFORMAT);\n\tparaFormat.dwMask = PFM_ALIGNMENT;    \n\tparaFormat.wAlignment = PFA_LEFT;\n\t\n\tSetParaFormat(paraFormat);\n}\n\nvoid CRichEditCtrlEx::SetParagraphRight()\n{\n\tPARAFORMAT paraFormat;\n\tparaFormat.cbSize = sizeof(PARAFORMAT);\n\tparaFormat.dwMask = PFM_ALIGNMENT;    \n\tparaFormat.wAlignment = PFA_RIGHT;\n\t\n\tSetParaFormat(paraFormat);\n}\n\nbool CRichEditCtrlEx::ParagraphIsCentered()\n{\n\tPARAFORMAT pf = GetParagraphFormat();\n\n\tif (pf.wAlignment == PFA_CENTER)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool CRichEditCtrlEx::ParagraphIsLeft()\n{\n\tPARAFORMAT pf = GetParagraphFormat();\n\n\tif (pf.wAlignment == PFA_LEFT)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool CRichEditCtrlEx::ParagraphIsRight()\n{\n\tPARAFORMAT pf = GetParagraphFormat();\n\n\tif (pf.wAlignment == PFA_RIGHT)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nPARAFORMAT CRichEditCtrlEx::GetParagraphFormat()\n{\n\tPARAFORMAT pf;\n\tpf.cbSize = sizeof(PARAFORMAT);\n\n\tpf.dwMask = PFM_ALIGNMENT | PFM_NUMBERING;    \t\n\n\tGetParaFormat(pf);\n\n\treturn pf;\n}\n\nvoid CRichEditCtrlEx::SetParagraphBulleted()\n{\n\tPARAFORMAT paraformat = GetParagraphFormat();\n\n\tif ( (paraformat.dwMask & PFM_NUMBERING) && (paraformat.wNumbering == PFN_BULLET) )\n\t{\n\t\tparaformat.wNumbering = 0;\n\t\tparaformat.dxOffset = 0;\n\t\tparaformat.dxStartIndent = 0;\n\t\tparaformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;\n\t}\n\telse\n\t{\n\t\tparaformat.wNumbering = PFN_BULLET;\n\t\tparaformat.dwMask = PFM_NUMBERING;\n\t\tif (paraformat.dxOffset == 0)\n\t\t{\n\t\t\tparaformat.dxOffset = 4;\n\t\t\tparaformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;\n\t\t}\n\t}\n\t\n\tSetParaFormat(paraformat);\n\n}\n\nbool CRichEditCtrlEx::ParagraphIsBulleted()\n{\n\tPARAFORMAT pf = GetParagraphFormat();\n\n\tif (pf.wNumbering == PFN_BULLET)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid CRichEditCtrlEx::SelectColor()\n{\n\tCColorDialog dlg;\n\n\tCHARFORMAT cf = GetCharFormat();\n\n\tif (cf.dwEffects & CFE_AUTOCOLOR) cf.dwEffects -= CFE_AUTOCOLOR;\n\n\t// Get a color from the common color dialog.\n\tif( dlg.DoModal() == IDOK )\n\t{\t\n\t\tcf.crTextColor = dlg.GetColor();\n\t}\n\n\tcf.dwMask = CFM_COLOR;\n\n\tSetSelectionCharFormat(cf);\n}\n\nvoid CRichEditCtrlEx::SetFontName(CString sFontName)\n{\n\tCHARFORMAT cf = GetCharFormat();\n\n\t// Set the font name.\n\tfor (int i = 0; i <= sFontName.GetLength()-1; i++)\n\t\tcf.szFaceName[i] = (char)sFontName[i];\n\n\n\tcf.dwMask = CFM_FACE;\n\n\tSetSelectionCharFormat(cf);\n}\n\nvoid CRichEditCtrlEx::SetFontSize(int nPointSize)\n{\n\tCHARFORMAT cf = GetCharFormat();\n\n\tnPointSize *= 20;\t// convert from to twips\n\tcf.yHeight = nPointSize;\n\t\n\tcf.dwMask = CFM_SIZE;\n\n\tSetSelectionCharFormat(cf);\n}\n\nvoid CRichEditCtrlEx::GetSystemFonts(CStringArray &saFontList)\n{\n\tCDC *pDC = GetDC ();\n\n\tEnumFonts (pDC->GetSafeHdc(),NULL,(FONTENUMPROC) CBEnumFonts,(LPARAM)&saFontList);//Enumerate\n\n}\n\nBOOL CALLBACK CRichEditCtrlEx::CBEnumFonts(LPLOGFONT lplf, LPTEXTMETRIC lptm, DWORD dwType, LPARAM lpData)\n{\n\t// This function was written with the help of CCustComboBox, by Girish Bharadwaj.\n\t// Available from Codeguru.\n\n\tif (dwType == TRUETYPE_FONTTYPE) \n\t{\n\t\t((CStringArray *) lpData)->Add( lplf->lfFaceName );\n\t}\n\n\treturn true;\n}\n\nCString CRichEditCtrlEx::GetSelectionFontName()\n{\n\tCHARFORMAT cf = GetCharFormat();\n\n\tCString sName = cf.szFaceName;\n\n\treturn sName;\n}\n\nlong CRichEditCtrlEx::GetSelectionFontSize()\n{\n\tCHARFORMAT cf = GetCharFormat();\n\n\tlong nSize = cf.yHeight/20;\n\n\treturn nSize;\n}\n\nint CRichEditCtrlEx::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CRichEditCtrl::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// TODO: Add your specialized creation code here\n\t\n\treturn 0;\n}\n\nBOOL CRichEditCtrlEx::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) \n{\n\treturn CWnd::Create(_T(\"RichEdit50W\"), lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);\n\n}\n"
        },
        {
          "name": "RichEditCtrlEx.h",
          "type": "blob",
          "size": 2.8212890625,
          "content": "#if !defined(AFX_AUTORICHEDITCTRL_H__C26D1E0E_DD32_11D2_B39F_000092914562__INCLUDED_)\n#define AFX_AUTORICHEDITCTRL_H__C26D1E0E_DD32_11D2_B39F_000092914562__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// AutoRichEditCtrl.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CRichEditCtrlEx window\n\nBOOL PASCAL AfxInitRichEditEx();\n\nclass _AFX_RICHEDITEX_STATE\n{\npublic:\n    _AFX_RICHEDITEX_STATE()\n\t{\n\t\tm_hInstRichEdit20 = NULL;\n\t}\n    virtual ~_AFX_RICHEDITEX_STATE()\n\t{\n\t\tif(m_hInstRichEdit20 != NULL)\n\t\t{\n\t\t\t::FreeLibrary(m_hInstRichEdit20);\n\t\t}\n    }\n\n    HINSTANCE m_hInstRichEdit20;\n};\n\nclass CRichEditCtrlEx : public CRichEditCtrl\n{\n// Construction\npublic:\n\tCRichEditCtrlEx();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CRichEditCtrlEx)\n\tpublic:\n\tvirtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tlong GetSelectionFontSize();\n\tCString GetSelectionFontName();\n\tCStringArray m_saFontList;\n\tvoid GetSystemFonts(CStringArray &saFontList);\n\tvoid SetFontSize(int nPointSize);\n\tvoid SetFontName(CString sFontName);\n\tvoid SelectColor();\n\tbool ParagraphIsBulleted();\n\tvoid SetParagraphBulleted();\n\t\n\tPARAFORMAT GetParagraphFormat();\n\t\n\tbool ParagraphIsRight();\n\tbool ParagraphIsLeft();\n\tbool ParagraphIsCentered();\n\t\n\tvoid SetParagraphRight();\n\tvoid SetParagraphLeft();\n\tvoid SetParagraphCenter();\n\t\n\tCHARFORMAT GetCharFormat(DWORD dwMask = CFM_COLOR | CFM_FACE | CFM_SIZE | CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE);\n\t\n\tbool SelectionIsBold();\n\tbool SelectionIsItalic();\n\tbool SelectionIsUnderlined();\n\n\tvoid SetSelectionBold();\n\tvoid SetSelectionItalic();\n\tvoid SetSelectionUnderlined();\n\n\tvoid SetRTF(CStringA sRTF);\n\tvoid SetRTF(const char *pRTF);\n\tCString GetRTF();\n\n\tvoid SetText(CString sText);\n\tCString GetText();\n\n\tvirtual ~CRichEditCtrlEx();\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CRichEditCtrlEx)\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\nprivate:\n\t\tvoid SetCharStyle(int MASK, int STYLE, int nStart, int nEnd);\n\t\tstatic DWORD CALLBACK CBStreamIn(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);\n\t\tstatic DWORD CALLBACK CBStreamOut(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG* pcb);\n\t\tstatic BOOL CALLBACK CBEnumFonts(LPLOGFONT lplf, LPTEXTMETRIC lptm, DWORD dwType, LPARAM lpData);\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_AUTORICHEDITCTRL_H__C26D1E0E_DD32_11D2_B39F_000092914562__INCLUDED_)\n"
        },
        {
          "name": "RichTextAggregator.cpp",
          "type": "blob",
          "size": 1.5244140625,
          "content": "#include \"stdafx.h\"\n#include \".\\richtextaggregator.h\"\n#include \"Misc.h\"\n\nCRichTextAggregator::CRichTextAggregator(CStringA csSeparator) :\n\tm_csSeparator(csSeparator)\n{\n\t//Remove the first line feed\n//\tif(m_csSeparator.GetLength() > 1 && m_csSeparator[0] == '\\r' && m_csSeparator[1] == '\\n')\n//\t{\n//\t\tm_csSeparator.Delete(0);\n//\t\tm_csSeparator.Delete(0);\n//\t}\n\n\tm_csSeparator.Replace(\"\\r\\n\", \"\\\\par\");\n}\n\nCRichTextAggregator::~CRichTextAggregator(void)\n{\n}\n\nbool CRichTextAggregator::AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType)\n{\n\tLPSTR pText = (LPSTR)lpData;\n\tif(pText == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\t//Ensure it's null terminated\n\tif(pText[nDataSize-1] != '\\0')\n\t{\n\t\tint len = 0;\n\t\tfor(len = 0; len < nDataSize && pText[len] != '\\0'; len++ )\n\t\t{\n\t\t}\n\t\t// if it is not null terminated, skip this item\n\t\tif(len >= nDataSize)\n\t\t\treturn false;\n\t}\n\n\tif(nPos != nCount-1)\n\t{\n\t\t//Remove the last } at the end of the rtf\n\t\tbool bBreak = false;\n\t\tfor(int i = nDataSize-1; i >= 0; i--)\n\t\t{\n\t\t\tif(pText[i] == '}')\n\t\t\t\tbBreak = true;\n\n\t\t\tpText[i] = NULL;\n\n\t\t\tif(bBreak)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if(nPos >= 1)\n\t{\n\t\t//Remove the {\\rtf1 at the start of the rtf\n\t\tfor(int i = 0; i < 6; i++)\n\t\t{\n\t\t\tpText[0] = NULL;\n\t\t\tpText++;\n\t\t}\n\t}\n\n\tm_csNewText += pText;\n\n\tif(nPos != nCount-1)\n\t{\n\t\tm_csNewText += m_csSeparator;\n\t}\n\n\treturn true;\n}\n\nHGLOBAL CRichTextAggregator::GetHGlobal()\n{\n\tlong lLen = m_csNewText.GetLength();\n\tHGLOBAL hGlobal = NewGlobalP(m_csNewText.GetBuffer(lLen), lLen+sizeof(char));\n\tm_csNewText.ReleaseBuffer();\n\n\treturn hGlobal;\n}"
        },
        {
          "name": "RichTextAggregator.h",
          "type": "blob",
          "size": 0.3515625,
          "content": "#pragma once\n#include \"IClipAggregator.h\"\n\nclass CRichTextAggregator : public IClipAggregator\n{\npublic:\n\tCRichTextAggregator(CStringA csSeparator);\n\t~CRichTextAggregator(void);\n\n\tvirtual bool AddClip(LPVOID lpData, int nDataSize, int nPos, int nCount, UINT cfType);\n\tvirtual HGLOBAL GetHGlobal();\n\nprotected:\n\tCStringA m_csNewText;\n\tCStringA m_csSeparator;\n};\n"
        },
        {
          "name": "SaveAnimation.cpp",
          "type": "blob",
          "size": 2.4033203125,
          "content": "#include \"stdafx.h\"\n#include \".\\saveanimation.h\"\n#include \"PerfTimer.h\"\n\nCSaveAnimation::CSaveAnimation(void)\n{\n\tm_dLeftPercent = 0;\n\tm_dTopPercent = 0;\n\tm_dRightPercent = 0;\n\tm_dBottomPercent = 0;\n\tm_dSpeed = 40;\n}\n\nCSaveAnimation::~CSaveAnimation(void)\n{\n}\n\nvoid CSaveAnimation::DoAnimation(CRect crStart, CRect crEnd, CWnd *pWnd)\n{\n\tm_crStart = crStart;\n\tm_crEnd = crEnd;\n\n\tlong lMaxDist = GetMaxDistance();\n\tGetPercentages(lMaxDist);\n\n\tCDC* pDC = pWnd->GetDC();\n\tCRect crCur(m_crStart);\n\tCRect crPrev(-1, -1, -1, -1);\n\tMSG msg;\n\tdouble dCurLeft = crCur.left;\n\tdouble dCurTop = crCur.top;\n\tdouble dCurRight = crCur.right;\n\tdouble dCurBottom = crCur.bottom;\n\tCPerfTimer Timer;\n\n\tfor(int i = 0; i < lMaxDist/m_dSpeed; i++)\n\t{\t\n\t\t//don't do the first time\n\t\tif(i > 0)\n\t\t{\n\t\t\t//wait 20ms between paints\n\t\t\twhile(Timer.Elapsedms() < 10)\n\t\t\t{\n\t\t\t\tSleep(1);\n\t\t\t}\n\n\t\t\t//Remove the old focus rect\n\t\t\tpDC->DrawFocusRect(crPrev);\n\t\t}\n\t\tTimer.Start(TRUE);\n\n\t\tpDC->DrawFocusRect(crCur);\n\n\t\tcrPrev = crCur;\n\n\t\tdCurLeft -= m_dLeftPercent * m_dSpeed;\n\t\tdCurTop -= m_dTopPercent * m_dSpeed;\n\t\tdCurRight -= m_dRightPercent * m_dSpeed;\n\t\tdCurBottom -= m_dBottomPercent * m_dSpeed;\n\n\t\tcrCur.left = (int)dCurLeft;\n\t\tcrCur.top = (int)dCurTop;\n\t\tcrCur.right = (int)dCurRight;\n\t\tcrCur.bottom = (int)dCurBottom;\n\n\t\twhile (PeekMessage(&msg, pWnd->m_hWnd, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t}\n\n\t//Draw one more time to remove the last focus rect\n\tpDC->DrawFocusRect(crPrev);\n\twhile (PeekMessage(&msg, pWnd->m_hWnd, 0, 0, PM_REMOVE))\n\t{\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\t}\n\n\tpWnd->ReleaseDC(pDC);\n}\n\nlong CSaveAnimation::GetMaxDistance()\n{\n\tlong lMax = 0;\n\n\tif(abs(m_crStart.left - m_crEnd.left) > lMax)\n\t\tlMax = abs(m_crStart.left - m_crEnd.left);\n\n\tif(abs(m_crStart.top - m_crEnd.top) > lMax)\n\t\tlMax = abs(m_crStart.top - m_crEnd.top);\n\n\tif(abs(m_crStart.right - m_crEnd.right) > lMax)\n\t\tlMax = abs(m_crStart.right - m_crEnd.right);\n\n\tif(abs(m_crStart.bottom - m_crEnd.bottom) > lMax)\n\t\tlMax = abs(m_crStart.bottom - m_crEnd.bottom);\n\n\treturn lMax;\n}\n\nvoid CSaveAnimation::GetPercentages(long lMaxDist)\n{\n\tif(lMaxDist > 0)\n\t{\n\t\tm_dLeftPercent = (m_crStart.left - m_crEnd.left) / (double)lMaxDist;\n\t\tm_dTopPercent = (m_crStart.top - m_crEnd.top) / (double)lMaxDist;\n\t\tm_dRightPercent = (m_crStart.right - m_crEnd.right) / (double)lMaxDist;\n\t\tm_dBottomPercent = (m_crStart.bottom - m_crEnd.bottom) / (double)lMaxDist;\n\t}\n}\n"
        },
        {
          "name": "SaveAnimation.h",
          "type": "blob",
          "size": 0.3564453125,
          "content": "#pragma once\n\nclass CSaveAnimation\n{\npublic:\n\tCSaveAnimation();\n\t~CSaveAnimation(void);\n\n\tvoid DoAnimation(CRect crStart, CRect crEnd, CWnd *pWnd);\n\tvoid GetPercentages(long lMaxDist);\n\tlong GetMaxDistance();\n\t\n\tCRect m_crStart;\n\tCRect m_crEnd;\n\n\tdouble m_dLeftPercent;\n\tdouble m_dTopPercent;\n\tdouble m_dRightPercent;\n\tdouble m_dBottomPercent;\n\n\tdouble m_dSpeed;\n};"
        },
        {
          "name": "ScriptEditor.cpp",
          "type": "blob",
          "size": 8.87109375,
          "content": "// ScriptEditor.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"CP_Main.h\"\r\n#include \"ScriptEditor.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"ChaiScriptOnCopy.h\"\r\n#include \"Shared\\TextConvert.h\"\r\n#include \"DittoChaiScript.h\"\r\n\r\n\r\n// CScriptEditor dialog\r\n\r\nIMPLEMENT_DYNAMIC(CScriptEditor, CDialogEx)\r\n\r\nCScriptEditor::CScriptEditor(CWnd* pParent /*=NULL*/)\r\n\t: CDialogEx(IDD_SCRIPT_EDITOR, pParent)\r\n{\r\n\r\n}\r\n\r\nCScriptEditor::~CScriptEditor()\r\n{\r\n}\r\n\r\nvoid CScriptEditor::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n\tDDX_Control(pDX, IDC_LIST_SCRIPTS, m_scriptsList);\r\n\tDDX_Control(pDX, IDC_RICHEDIT21, m_rich);\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CScriptEditor, CDialogEx)\r\n\tON_LBN_SELCHANGE(IDC_LIST_SCRIPTS, &CScriptEditor::OnLbnSelchangeListScripts)\r\n\tON_BN_CLICKED(IDC_BUTTON_ADD_SCRIPT, &CScriptEditor::OnBnClickedButtonAddScript)\r\n\tON_EN_KILLFOCUS(IDC_EDIT_NAME, &CScriptEditor::OnEnKillfocusEditName)\r\n\tON_EN_KILLFOCUS(IDC_EDIT_DESC, &CScriptEditor::OnEnKillfocusEditDesc)\r\n\tON_EN_KILLFOCUS(IDC_RICHEDIT21, &CScriptEditor::OnEnKillfocusEditScript)\r\n\tON_BN_CLICKED(IDC_CHECK_ACTIVE, &CScriptEditor::OnBnClickedCheckActive)\r\n\tON_WM_SIZE()\r\n\tON_BN_CLICKED(IDC_BUTTON_DELETE_SCRIPT, &CScriptEditor::OnBnClickedButtonDeleteScript)\r\n\tON_BN_CLICKED(IDC_BUTTON_RUN, &CScriptEditor::OnBnClickedButtonRun)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CScriptEditor message handlers\r\n\r\nBOOL CScriptEditor::OnInitDialog()\r\n{\r\n\tCDialogEx::OnInitDialog();\r\n\r\n\tSetWindowText(m_title);\r\n\r\n\t\r\n\r\n\tint index = 0;\r\n\tfor (auto & listItem : m_xml.m_list)\r\n\t{\r\n\t\tint row = m_scriptsList.AddString(listItem.m_name);\r\n\t\tm_scriptsList.SetItemData(row, index);\r\n\t\tindex++;\r\n\t}\r\n\r\n\tif (index > 0)\r\n\t{\r\n\t\tm_scriptsList.SetSel(0);\r\n\t\tm_scriptsList.SetCurSel(0);\r\n\t\tm_scriptsList.SetCaretIndex(0);\r\n\t\tm_scriptsList.SetAnchorIndex(0);\r\n\r\n\t\tOnLbnSelchangeListScripts();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEnableDisable(FALSE);\r\n\t}\r\n\r\n\tm_resize.SetParent(m_hWnd);\t\r\n\tm_resize.AddControl(IDOK, DR_MoveTop | DR_MoveLeft);\r\n\tm_resize.AddControl(IDCANCEL, DR_MoveTop | DR_MoveLeft);\r\n\r\n\tm_resize.AddControl(IDC_LIST_SCRIPTS, DR_SizeHeight);\r\n\tm_resize.AddControl(IDC_EDIT_DESC, DR_SizeWidth);\r\n\tm_resize.AddControl(IDC_EDIT_NAME, DR_SizeWidth);\r\n\tm_resize.AddControl(IDC_RICHEDIT21, DR_SizeWidth | DR_SizeHeight);\r\n\r\n\tm_resize.AddControl(IDC_STATIC_RETURN_DESC, DR_MoveTop | DR_SizeWidth);\r\n\tm_resize.AddControl(IDC_STATIC_INPUT, DR_MoveTop);\r\n\tm_resize.AddControl(IDD_SCRIPT_EDITOR, DR_MoveTop | DR_SizeWidth);\r\n\tm_resize.AddControl(IDC_EDIT_OUTPUT, DR_MoveTop | DR_SizeWidth);\r\n\tm_resize.AddControl(IDC_STATIC_OUTPUT, DR_MoveTop);\t\r\n\tm_resize.AddControl(IDC_EDIT_INPUT, DR_MoveTop | DR_SizeWidth);\r\n\r\n\tm_resize.AddControl(IDC_BUTTON_RUN, DR_MoveTop | DR_MoveLeft);\r\n\r\n\tm_resize.AddControl(IDC_EDIT_ACTIVE_APP, DR_MoveTop | DR_MoveLeft);\r\n\tm_resize.AddControl(IDC_EDIT_ACTIVE_APP_TITLE, DR_MoveTop | DR_MoveLeft);\r\n\r\n\tm_resize.AddControl(IDC_BUTTON_DELETE_SCRIPT, DR_MoveTop);\r\n\tm_resize.AddControl(IDC_BUTTON_ADD_SCRIPT, DR_MoveTop);\t\r\n\r\n\tSetDlgItemText(IDC_EDIT_ACTIVE_APP, _T(\"App name\"));\r\n\tSetDlgItemText(IDC_EDIT_ACTIVE_APP_TITLE, _T(\"App Title\"));\t\r\n\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CScriptEditor::OnLbnSelchangeListScripts()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tthis->SetDlgItemText(IDC_EDIT_NAME, m_xml.m_list[listIndex].m_name);\r\n\t\tthis->SetDlgItemText(IDC_EDIT_DESC, m_xml.m_list[listIndex].m_description);\r\n\t\tif (m_xml.m_list[listIndex].m_active)\r\n\t\t{\r\n\t\t\tthis->CheckDlgButton(IDC_CHECK_ACTIVE, BST_CHECKED);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis->CheckDlgButton(IDC_CHECK_ACTIVE, BST_UNCHECKED);\r\n\t\t}\r\n\t\tthis->SetDlgItemText(IDC_RICHEDIT21, m_xml.m_list[listIndex].m_script);\r\n\r\n\t\tthis->GetDlgItem(IDC_EDIT_NAME)->SetFocus();\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::OnBnClickedButtonAddScript()\r\n{\r\n\tCDittoChaiScriptXmlItem newItem;\r\n\tnewItem.m_name = _T(\"New Script\");\r\n\tnewItem.m_active = true;\r\n\tnewItem.m_guid = NewGuidString();\r\n\tm_xml.m_list.push_back(newItem);\r\n\r\n\tint index = m_scriptsList.AddString(newItem.m_name);\r\n\r\n\tm_scriptsList.SetSel(index);\r\n\tm_scriptsList.SetCurSel(index);\r\n\tm_scriptsList.SetCaretIndex(index);\r\n\tm_scriptsList.SetAnchorIndex(index);\r\n\r\n\tthis->SetDlgItemText(IDC_EDIT_NAME, newItem.m_name);\r\n\tthis->SetDlgItemText(IDC_EDIT_DESC, _T(\"\"));\r\n\tthis->SetDlgItemText(IDC_RICHEDIT21, _T(\"\"));\r\n\tthis->CheckDlgButton(IDC_CHECK_ACTIVE, BST_CHECKED);\r\n\r\n\tthis->GetDlgItem(IDC_EDIT_NAME)->SetFocus();\r\n\r\n\tEnableDisable(TRUE);\r\n}\r\n\r\nvoid CScriptEditor::OnEnKillfocusEditName()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tCString name;\r\n\t\tthis->GetDlgItemText(IDC_EDIT_NAME, name);\r\n\r\n\t\tif (m_xml.m_list[listIndex].m_name != name)\r\n\t\t{\r\n\t\t\tm_xml.m_list[listIndex].m_name = name;\r\n\r\n\t\t\tm_scriptsList.SetRedraw(FALSE);\r\n\r\n\t\t\tm_scriptsList.DeleteString(listIndex);\r\n\t\t\tm_scriptsList.InsertString(listIndex, name);\r\n\t\t\tm_scriptsList.SetSel(listIndex);\r\n\t\t\tm_scriptsList.SetCurSel(listIndex);\r\n\t\t\tm_scriptsList.SetCaretIndex(listIndex);\r\n\t\t\tm_scriptsList.SetAnchorIndex(listIndex);\r\n\t\t\tm_scriptsList.SetRedraw(TRUE);\r\n\t\t\tm_scriptsList.UpdateWindow();\r\n\t\t}\t\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::OnEnKillfocusEditDesc()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tCString desc;\r\n\t\tthis->GetDlgItemText(IDC_EDIT_DESC, desc);\r\n\t\tm_xml.m_list[listIndex].m_description = desc;\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::OnEnKillfocusEditScript()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tCString script;\r\n\t\tthis->GetDlgItemText(IDC_RICHEDIT21, script);\r\n\t\tm_xml.m_list[listIndex].m_script = script;\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::OnBnClickedCheckActive()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tif (this->IsDlgButtonChecked(IDC_CHECK_ACTIVE) == BST_CHECKED)\r\n\t\t{\r\n\t\t\tm_xml.m_list[listIndex].m_active = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{ \r\n\t\t\tm_xml.m_list[listIndex].m_active = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCDialogEx::OnSize(nType, cx, cy);\r\n\r\n\tm_resize.MoveControls(CSize(cx, cy));\r\n}\r\n\r\n\r\nvoid CScriptEditor::OnBnClickedButtonDeleteScript()\r\n{\r\n\tint listIndex = m_scriptsList.GetCurSel();\r\n\tif (listIndex >= 0 && listIndex < m_xml.m_list.size())\r\n\t{\r\n\t\tm_xml.m_list.erase(m_xml.m_list.begin() + listIndex);\r\n\t\tm_scriptsList.DeleteString(listIndex);\r\n\r\n\t\tif (m_scriptsList.GetCount() <= listIndex)\r\n\t\t{\r\n\t\t\tlistIndex--;\r\n\t\t}\r\n\r\n\t\tif (listIndex >= 0)\r\n\t\t{\r\n\t\t\tm_scriptsList.SetSel(listIndex);\r\n\t\t\tm_scriptsList.SetCurSel(listIndex);\r\n\t\t\tm_scriptsList.SetCaretIndex(listIndex);\r\n\t\t\tm_scriptsList.SetAnchorIndex(listIndex);\r\n\r\n\t\t\tOnLbnSelchangeListScripts();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tEnableDisable(FALSE);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CScriptEditor::EnableDisable(BOOL enable)\r\n{\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_NAME), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DESC), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_RICHEDIT21), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_INPUT), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_OUTPUT), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_BUTTON_RUN), enable);\r\n\t::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_ACTIVE), enable);\r\n}\r\n\r\nvoid CScriptEditor::OnBnClickedButtonRun()\r\n{\r\n\tCWaitCursor wait;\r\n\r\n\tCString input;\r\n\tGetDlgItemText(IDC_EDIT_INPUT, input);\r\n\tCString script;\r\n\tGetDlgItemText(IDC_RICHEDIT21, script);\r\n\r\n\tCString app;\r\n\tGetDlgItemText(IDC_EDIT_ACTIVE_APP, app);\r\n\r\n\tCString appTitle;\r\n\tGetDlgItemText(IDC_EDIT_ACTIVE_APP_TITLE, appTitle);\r\n\r\n\tCClip clip;\r\n\r\n\tChaiScriptOnCopy test;\r\n\tCDittoChaiScript clipData(&clip, (LPCSTR)CTextConvert::UnicodeToAnsi(app), (LPCSTR)CTextConvert::UnicodeToAnsi(appTitle));\r\n\tclipData.SetAsciiString((LPCSTR)CTextConvert::UnicodeToAnsi(input));\r\n\tclipData.DescriptionReplaceRegex(\".*\", (LPCSTR)CTextConvert::UnicodeToAnsi(input));\r\n\t\r\n\ttest.ProcessScript(clipData, (LPCSTR)CTextConvert::UnicodeToAnsi(script));\r\n\r\n\tif (test.m_lastError == _T(\"\"))\r\n\t{\r\n\t\tCString currentString = CTextConvert::AnsiToUnicode(clipData.GetAsciiString().c_str());\r\n\t\tif (currentString == _T(\"\"))\r\n\t\t{\r\n\t\t\tcurrentString = clipData.GetUnicodeString().c_str();\r\n\t\t}\r\n\r\n\t\tSetDlgItemText(IDC_EDIT_OUTPUT, _T(\"returned false\\r\\n\") + currentString);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tSetDlgItemText(IDC_EDIT_OUTPUT, test.m_lastError);\r\n\t}\r\n}\r\n\r\n\r\nBOOL CScriptEditor::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\t// TODO: Add your specialized code here and/or call the base class\r\n\r\n\tif ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_TAB) && (pMsg->hwnd == m_rich.GetSafeHwnd()))\r\n\t{\r\n\t\tlong lStart, lEnd;\r\n\t\tm_rich.GetSel(lStart, lEnd);\r\n\t\t\r\n\t\t// select zero chars\r\n\t\tm_rich.SetSel(lStart, lStart);\r\n\t\t// then replace that selection with a TAB\r\n\t\tm_rich.ReplaceSel(_T(\"\\t\"), TRUE);\r\n\r\n\t\t// no need to do a msg translation, so quit. \r\n\t\t// that way no further processing gets done\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn CDialogEx::PreTranslateMessage(pMsg);\r\n}\r\n"
        },
        {
          "name": "ScriptEditor.h",
          "type": "blob",
          "size": 1.0654296875,
          "content": "#pragma once\n\n#include \"ChaiScriptXml.h\"\n#include \"DialogResizer.h\"\n\n\n// CScriptEditor dialog\n\nclass CScriptEditor : public CDialogEx\n{\n\tDECLARE_DYNAMIC(CScriptEditor)\n\npublic:\n\tCScriptEditor(CWnd* pParent = NULL);   // standard constructor\n\tvirtual ~CScriptEditor();\n\n\tCChaiScriptXml m_xml;\n\n\tCString m_title;\n\nprotected:\n\t\n\tvoid EnableDisable(BOOL enable);\n\n// Dialog Data\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_SCRIPT_EDITOR };\t\n#endif\n\tCListBox\tm_scriptsList;\n\tCDialogResizer m_resize;\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tvirtual BOOL OnInitDialog();\n\tafx_msg void OnLbnSelchangeListScripts();\n\tafx_msg void OnBnClickedButtonAddScript();\n\tafx_msg void OnEnKillfocusEditName();\n\tafx_msg void OnEnKillfocusEditDesc();\n\tafx_msg void OnEnKillfocusEditScript();\n\tafx_msg void OnBnClickedCheckActive();\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnBnClickedButtonDeleteScript();\n\tafx_msg void OnBnClickedButtonRun();\n\tCRichEditCtrl m_rich;\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n};\n"
        },
        {
          "name": "ScrollHelper.cpp",
          "type": "blob",
          "size": 14.7861328125,
          "content": "// Filename: ScrollHelper.cpp\n// 2005-07-01 nschan Initial revision.\n// 2005-09-08 nschan Added GetClientRectSB() function.\n\n#include \"stdafx.h\"\n#include \"ScrollHelper.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n// Helper function to get client rect with possible\n// modification by adding scrollbar width/height.\nstatic void GetClientRectSB(CWnd* pWnd, CRect& rect)\n{\n    ASSERT( pWnd != NULL );\n\n    CRect winRect;\n    pWnd->GetWindowRect(&winRect);\n    pWnd->ScreenToClient(&winRect);\n\n    pWnd->GetClientRect(&rect);\n\n    int cxSB = ::GetSystemMetrics(SM_CXVSCROLL);\n    int cySB = ::GetSystemMetrics(SM_CYHSCROLL);\n\n    if ( winRect.right >= (rect.right + cxSB) )\n        rect.right += cxSB;\n    if ( winRect.bottom >= (rect.bottom + cySB) )\n        rect.bottom += cySB;\n}\n\n// CScrollHelper /////////////////////////////////////////////////////////////////////\n\nCScrollHelper::CScrollHelper()\n{\n    m_attachWnd   = NULL;\n    m_pageSize    = CSize(0,0);\n    m_displaySize = CSize(0,0);\n    m_scrollPos   = CSize(0,0);\n\tm_zoomScale = 1;\n}\n\nCScrollHelper::~CScrollHelper()\n{\n    DetachWnd();\n}\n\nvoid CScrollHelper::AttachWnd(CWnd* pWnd)\n{\n    m_attachWnd = pWnd;\n}\n\nvoid CScrollHelper::DetachWnd()\n{\n    m_attachWnd = NULL;\n}\n\nvoid CScrollHelper::SetDisplaySize(int displayWidth, int displayHeight, double zoomScale)\n{\n\tm_zoomScale = zoomScale;\n\tint cxSB = ::GetSystemMetrics(SM_CXVSCROLL);\n\tint cySB = ::GetSystemMetrics(SM_CYHSCROLL);\t\n\n\tCRect rect;\n\tGetClientRectSB(m_attachWnd, rect);\n\tint width = (int)((rect.Width() * (1 / m_zoomScale)) + .5);\n\tint height = (int)((rect.Height() * (1 / m_zoomScale)) + .5);\n\tCSize windowSize(width, height);\n\n\tif (windowSize.cx >= displayWidth)\n\t{\n\t\tcxSB = 0;\n\t}\n\n\tif (windowSize.cy >= displayHeight)\n\t{\n\t\tcySB = 0;\n\t}\n\n\t//CString msg;\n\t//msg.Format(_T(\"width: %d, height: %d, scale: %f\\r\\n\"), displayWidth, displayHeight, m_zoomScale);\n\t//OutputDebugString(msg);\n\n    m_displaySize = CSize((displayWidth) + cxSB, (displayHeight) + cySB);\n\n    if ( m_attachWnd != NULL && ::IsWindow(m_attachWnd->m_hWnd) )\n        UpdateScrollInfo();\n}\n\nconst CSize& CScrollHelper::GetDisplaySize() const\n{\n    return m_displaySize;\n}\n\nconst CSize& CScrollHelper::GetScrollPos() const\n{\n    return m_scrollPos;\n}\n\nconst CSize& CScrollHelper::GetPageSize() const\n{\n    return m_pageSize;\n}\n\nvoid CScrollHelper::ScrollToOrigin(bool scrollLeft, bool scrollTop)\n{\n    if ( m_attachWnd == NULL )\n        return;\n\n    if ( scrollLeft )\n    {\n        if ( m_displaySize.cx > 0 && m_pageSize.cx > 0 && m_scrollPos.cx > 0 )\n        {\n            int deltaPos = -m_scrollPos.cx;\n            m_scrollPos.cx += deltaPos;\n            m_attachWnd->SetScrollPos(SB_HORZ, m_scrollPos.cx, TRUE);\n            m_attachWnd->ScrollWindow(-deltaPos, 0);\n        }\n    }\n\n    if ( scrollTop )\n    {\n        if ( m_displaySize.cy > 0 && m_pageSize.cy > 0 && m_scrollPos.cy > 0 )\n        {\n            int deltaPos = -m_scrollPos.cy;\n            m_scrollPos.cy += deltaPos;\n            m_attachWnd->SetScrollPos(SB_VERT, m_scrollPos.cy, TRUE);\n            m_attachWnd->ScrollWindow(0, -deltaPos);\n        }\n    }\n}\n\nvoid CScrollHelper::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n    if ( m_attachWnd == NULL )\n        return;\n\n    const int lineOffset = 60;\n\n    // Compute the desired change or delta in scroll position.\n    int deltaPos = 0;\n    switch( nSBCode )\n    {\n    case SB_LINELEFT:\n        // Left scroll arrow was pressed.\n        deltaPos = -lineOffset;\n        break;\n\n    case SB_LINERIGHT:\n        // Right scroll arrow was pressed.\n        deltaPos = lineOffset;\n        break;\n\n    case SB_PAGELEFT:\n        // User clicked inbetween left arrow and thumb.\n        deltaPos = -m_pageSize.cx;\n        break;\n\n    case SB_PAGERIGHT:\n        // User clicked inbetween thumb and right arrow.\n        deltaPos = m_pageSize.cx;\n        break;\n\n    case SB_THUMBTRACK:\n        // Scrollbar thumb is being dragged.\n        deltaPos = Get32BitScrollPos(SB_HORZ, pScrollBar) - m_scrollPos.cx;\n        break;\n\n    case SB_THUMBPOSITION:\n        // Scrollbar thumb was released.\n        deltaPos = Get32BitScrollPos(SB_HORZ, pScrollBar) - m_scrollPos.cx;\n        break;\n\n    default:\n        // We don't process other scrollbar messages.\n        return;\n    }\n\n    // Compute the new scroll position.\n    int newScrollPos = m_scrollPos.cx + deltaPos;\n\n    // If the new scroll position is negative, we adjust\n    // deltaPos in order to scroll the window back to origin.\n    if ( newScrollPos < 0 )\n        deltaPos = -m_scrollPos.cx;\n\n    // If the new scroll position is greater than the max scroll position,\n    // we adjust deltaPos in order to scroll the window precisely to the\n    // maximum position.\n    int maxScrollPos = m_displaySize.cx - m_pageSize.cx;\n    if ( newScrollPos > maxScrollPos )\n        deltaPos = maxScrollPos - m_scrollPos.cx;\n\n    // Scroll the window if needed.\n    if ( deltaPos != 0 )\n    {\n        m_scrollPos.cx += deltaPos;\n        m_attachWnd->SetScrollPos(SB_HORZ, m_scrollPos.cx, TRUE);\n        m_attachWnd->ScrollWindow(-deltaPos, 0);\n\t\tm_attachWnd->Invalidate();\n    }\n}\n\nvoid CScrollHelper::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n    if ( m_attachWnd == NULL )\n        return;\n\n    const int lineOffset = 60;\n\n    // Compute the desired change or delta in scroll position.\n    int deltaPos = 0;\n    switch( nSBCode )\n    {\n    case SB_LINEUP:\n        // Up arrow button on scrollbar was pressed.\n        deltaPos = -lineOffset;\n        break;\n\n    case SB_LINEDOWN:\n        // Down arrow button on scrollbar was pressed.\n        deltaPos = lineOffset;\n        break;\n\n    case SB_PAGEUP:\n        // User clicked inbetween up arrow and thumb.\n        deltaPos = -m_pageSize.cy;\n        break;\n\n    case SB_PAGEDOWN:\n        // User clicked inbetween thumb and down arrow.\n        deltaPos = m_pageSize.cy;\n        break;\n\n    case SB_THUMBTRACK:\n        // Scrollbar thumb is being dragged.\n        deltaPos = Get32BitScrollPos(SB_VERT, pScrollBar) - m_scrollPos.cy;\n        break;\n\n    case SB_THUMBPOSITION:\n        // Scrollbar thumb was released.\n        deltaPos = Get32BitScrollPos(SB_VERT, pScrollBar) - m_scrollPos.cy;\n        break;\n\n    default:\n        // We don't process other scrollbar messages.\n        return;\n    }\n\n    // Compute the new scroll position.\n    int newScrollPos = m_scrollPos.cy + deltaPos;\n\n    // If the new scroll position is negative, we adjust\n    // deltaPos in order to scroll the window back to origin.\n    if ( newScrollPos < 0 )\n        deltaPos = -m_scrollPos.cy;\n\n    // If the new scroll position is greater than the max scroll position,\n    // we adjust deltaPos in order to scroll the window precisely to the\n    // maximum position.\n    int maxScrollPos = m_displaySize.cy - m_pageSize.cy;\n    if ( newScrollPos > maxScrollPos )\n        deltaPos = maxScrollPos - m_scrollPos.cy;\n\n    // Scroll the window if needed.\n    if ( deltaPos != 0 )\n    {\n        m_scrollPos.cy += deltaPos;\n        m_attachWnd->SetScrollPos(SB_VERT, m_scrollPos.cy, TRUE);\n        m_attachWnd->ScrollWindow(0, -deltaPos);\n\t\tm_attachWnd->Invalidate();\n    }\n}\n\nBOOL CScrollHelper::Update(CPoint changes)\n{\n\tint deltaYPos = changes.y;\n\n\tint newYScrollPos = m_scrollPos.cy + deltaYPos;\n\n\t// If the new scroll position is negative, we adjust\n\t// deltaPos in order to scroll the window back to origin.\n\tif (newYScrollPos < 0)\n\t\tdeltaYPos = -m_scrollPos.cy;\n\n\t// If the new scroll position is greater than the max scroll position,\n\t// we adjust deltaPos in order to scroll the window precisely to the\n\t// maximum position.\n\tint maxYScrollPos = m_displaySize.cy - m_pageSize.cy;\n\tif (newYScrollPos > maxYScrollPos)\n\t\tdeltaYPos = maxYScrollPos - m_scrollPos.cy;\n\n\tif (deltaYPos != 0)\n\t{\n\t\tm_scrollPos.cy += deltaYPos;\n\t\tm_attachWnd->SetScrollPos(SB_VERT, m_scrollPos.cy, TRUE);\n\t}\n\n\tint deltaXPos = changes.x;\n\n\tint newXScrollPos = m_scrollPos.cx + deltaXPos;\n\n\t// If the new scroll position is negative, we adjust\n\t// deltaPos in order to scroll the window back to origin.\n\tif (newXScrollPos < 0)\n\t\tdeltaXPos = -m_scrollPos.cx;\n\n\t// If the new scroll position is greater than the max scroll position,\n\t// we adjust deltaPos in order to scroll the window precisely to the\n\t// maximum position.\n\tint maxXScrollPos = m_displaySize.cx - m_pageSize.cx;\n\tif (newXScrollPos > maxXScrollPos)\n\t\tdeltaXPos = maxXScrollPos - m_scrollPos.cx;\n\n\tif (deltaXPos != 0)\n\t{\n\t\tm_scrollPos.cx += deltaXPos;\n\t\tm_attachWnd->SetScrollPos(SB_HORZ, m_scrollPos.cx, TRUE);\n\t}\n\t\t\n\tm_attachWnd->ScrollWindow(-deltaXPos, -deltaYPos);\n\n\treturn 1;\n}\n\nBOOL CScrollHelper::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)\n{\n    if ( m_attachWnd == NULL )\n        return FALSE;\n\n    // Don't do anything if the vertical scrollbar is not enabled.\n    int scrollMin = 0, scrollMax = 0;\n    m_attachWnd->GetScrollRange(SB_VERT, &scrollMin, &scrollMax);\n    if ( scrollMin == scrollMax )\n        return FALSE;\n\n    // Compute the number of scrolling increments requested.\n    int numScrollIncrements = abs(zDelta) / WHEEL_DELTA;\n\n    // Each scrolling increment corresponds to a certain number of\n    // scroll lines (one scroll line is like a SB_LINEUP or SB_LINEDOWN).\n    // We need to query the system parameters for this value.\n    int numScrollLinesPerIncrement = 0;\n    ::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &numScrollLinesPerIncrement, 0);\n\n    // Check if a page scroll was requested.\n    if ( numScrollLinesPerIncrement == WHEEL_PAGESCROLL )\n    {\n        // Call the vscroll message handler to do the work.\n        OnVScroll(zDelta > 0 ? SB_PAGEUP : SB_PAGEDOWN, 0, NULL);\n        return TRUE;\n    }\n\n    // Compute total number of lines to scroll.\n    int numScrollLines = numScrollIncrements * numScrollLinesPerIncrement;\n\n    // Adjust numScrollLines to slow down the scrolling a bit more.\n    numScrollLines = max(numScrollLines/3, 1);\n\n    // Do the scrolling.\n    for(int i = 0; i < numScrollLines; ++i)\n    {\n        // Call the vscroll message handler to do the work.\n        OnVScroll(zDelta > 0 ? SB_LINEUP : SB_LINEDOWN, 0, NULL);\n    }\n\n    return TRUE;\n}\n\nBOOL CScrollHelper::OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt)\n{\n\tif (m_attachWnd == NULL)\n\t\treturn FALSE;\n\n\t// Don't do anything if the vertical scrollbar is not enabled.\n\tint scrollMin = 0, scrollMax = 0;\n\tm_attachWnd->GetScrollRange(SB_VERT, &scrollMin, &scrollMax);\n\tif (scrollMin == scrollMax)\n\t\treturn FALSE;\n\n\t// Compute the number of scrolling increments requested.\n\tint numScrollIncrements = abs(zDelta) / WHEEL_DELTA;\n\n\t// Each scrolling increment corresponds to a certain number of\n\t// scroll lines (one scroll line is like a SB_LINEUP or SB_LINEDOWN).\n\t// We need to query the system parameters for this value.\n\tint numScrollLinesPerIncrement = 0;\n\t::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &numScrollLinesPerIncrement, 0);\n\n\t// Check if a page scroll was requested.\n\tif (numScrollLinesPerIncrement == WHEEL_PAGESCROLL)\n\t{\n\t\t// Call the vscroll message handler to do the work.\t\t\n\t\tOnHScroll(zDelta > 0 ? SB_PAGEUP : SB_PAGEDOWN, 0, NULL);\n\t\treturn TRUE;\n\t}\n\n\t// Compute total number of lines to scroll.\n\tint numScrollLines = numScrollIncrements * numScrollLinesPerIncrement;\n\n\t// Adjust numScrollLines to slow down the scrolling a bit more.\n\tnumScrollLines = max(numScrollLines / 3, 1);\n\n\t// Do the scrolling.\n\tfor (int i = 0; i < numScrollLines; ++i)\n\t{\n\t\t// Call the vscroll message handler to do the work.\n\t\tOnHScroll(zDelta > 0 ? SB_LINEUP : SB_LINEDOWN, 0, NULL);\n\t}\n\n\treturn TRUE;\n}\n\nvoid CScrollHelper::OnSize(UINT nType, int cx, int cy)\n{\n    UpdateScrollInfo();\n}\n\nint CScrollHelper::Get32BitScrollPos(int bar, CScrollBar* pScrollBar)\n{\n    // Code below is from MSDN Article ID 152252, \"How To Get\n    // 32-bit Scroll Position During Scroll Messages\".\n\n    // First determine if the user scrolled a scroll bar control\n    // on the window or scrolled the window itself.\n    ASSERT( m_attachWnd != NULL );\n    HWND hWndScroll;\n    if ( pScrollBar == NULL )\n        hWndScroll = m_attachWnd->m_hWnd;\n    else\n        hWndScroll = pScrollBar->m_hWnd;\n\n    SCROLLINFO si;\n    si.cbSize = sizeof(SCROLLINFO);\n    si.fMask = SIF_TRACKPOS;\n    ::GetScrollInfo(hWndScroll, bar, &si);\n\n    int scrollPos = si.nTrackPos;\n\n    return scrollPos;\n}\n\nvoid CScrollHelper::UpdateScrollInfo()\n{\n    if ( m_attachWnd == NULL )\n        return;\n\n    // Get the width/height of the attached wnd that includes the area\n    // covered by the scrollbars (if any). The reason we need this is\n    // because when scrollbars are present, both cx/cy and GetClientRect()\n    // when accessed from OnSize() do not include the scrollbar covered\n    // areas. In other words, their values are smaller than what you would\n    // expect.\n    CRect rect;\n    GetClientRectSB(m_attachWnd, rect);\n\tdouble width = (rect.Width() * (1 / m_zoomScale)) + .5;\n\tdouble height = (rect.Height() * (1 / m_zoomScale)) + .5;\n    CSize windowSize((int)width, (int)(height * (1/m_zoomScale)));\n\n    // Update horizontal scrollbar.\n    CSize deltaPos(0,0);\n    UpdateScrollBar(SB_HORZ, windowSize.cx, m_displaySize.cx,\n        m_pageSize.cx, m_scrollPos.cx, deltaPos.cx);\n\n    // Update vertical scrollbar.\n    UpdateScrollBar(SB_VERT, windowSize.cy, m_displaySize.cy,\n        m_pageSize.cy, m_scrollPos.cy, deltaPos.cy);\n\n    // See if we need to scroll the window back in place.\n    // This is needed to handle the case where the scrollbar is\n    // moved all the way to the right for example, and controls\n    // at the left side disappear from the view. Then the user\n    // resizes the window wider until scrollbars disappear. Without\n    // this code below, the controls off the page will be gone forever.\n    if ( deltaPos.cx != 0 || deltaPos.cy != 0 )\n    {\n        m_attachWnd->ScrollWindow(deltaPos.cx, deltaPos.cy);\n    }                                                        \n}\n\nvoid CScrollHelper::UpdateScrollBar(int bar, int windowSize, int displaySize,\n                                    LONG& pageSize, LONG& scrollPos, LONG& deltaPos)\n{\n    int scrollMax = 0;\n    deltaPos = 0;\n    if ( windowSize < displaySize )\n    {\n        scrollMax = displaySize - 1;\n        if ( pageSize > 0 && scrollPos > 0 )\n        {\n            // Adjust the scroll position when the window size is changed.\n            //scrollPos = (LONG)(1.0 * scrollPos * windowSize / pageSize);\n        }\n        pageSize = windowSize;\n\t\tscrollPos = min(scrollPos, displaySize - pageSize - 1);\n        deltaPos = m_attachWnd->GetScrollPos(bar) - scrollPos;\n    }\n    else\n    {\n        // Force the scrollbar to go away.\n        pageSize = 0;\n        scrollPos = 0;\n        deltaPos = m_attachWnd->GetScrollPos(bar);\n    }\n\n    SCROLLINFO si;\n    memset(&si, 0, sizeof(SCROLLINFO));\n    si.cbSize = sizeof(SCROLLINFO);\n    si.fMask  = SIF_ALL;    // SIF_ALL = SIF_PAGE | SIF_RANGE | SIF_POS;\n    si.nMin   = 0;\n    si.nMax   = scrollMax;\n    si.nPage  = pageSize;\n    si.nPos   = scrollPos;\n    m_attachWnd->SetScrollInfo(bar, &si, TRUE);\n}\n\n// END\n\n"
        },
        {
          "name": "ScrollHelper.h",
          "type": "blob",
          "size": 1.923828125,
          "content": "// Filename: ScrollHelper.h\n// S.Chan, 01 Jul 2005\n\n#ifndef SCROLL_HELPER_INCLUDED\n#define SCROLL_HELPER_INCLUDED\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\nclass CScrollHelper\n{\npublic:\n    CScrollHelper();\n    ~CScrollHelper();\n\n    // Attach/detach a CWnd or CDialog.\n    void   AttachWnd(CWnd* pWnd);\n    void   DetachWnd();\n\n    // Set/get the virtual display size. When the dialog or window\n    // size is smaller than the display size, then that is when\n    // scrollbars will appear. Set either the display width or display\n    // height to zero if you don't want to enable the scrollbar in the\n    // corresponding direction.\n    void   SetDisplaySize(int displayWidth, int displayHeight, double zoomScale);\n    const CSize& GetDisplaySize() const;\n\n    // Get current scroll position. This is needed if you are scrolling\n    // a custom CWnd which implements its own drawing in OnPaint().\n    const CSize& GetScrollPos() const;\n\n    // Get current page size. Useful for debugging purposes.\n    const CSize& GetPageSize() const;\n\n    // Scroll back to top, left, or top-left corner of the window.\n    void   ScrollToOrigin(bool scrollLeft, bool scrollTop);\n\n    // Message handling.\n    void   OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n    void   OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n    BOOL   OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);\n\tBOOL   OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt);\n    void   OnSize(UINT nType, int cx, int cy);\n\n\tBOOL   Update(CPoint changes);\n\nprivate:\n    int    Get32BitScrollPos(int bar, CScrollBar* pScrollBar);\n    void   UpdateScrollInfo();\n    void   UpdateScrollBar(int bar, int windowSize, int displaySize,\n                           LONG& pageSize, LONG& scrollPos, LONG& deltaPos);\n\n    CWnd*  m_attachWnd;\n    CSize  m_pageSize;\n    CSize  m_displaySize;\n    CSize  m_scrollPos;\n\tdouble m_zoomScale;\n};\n\n#endif // SCROLL_HELPER_INCLUDED\n\n// END\n"
        },
        {
          "name": "SearchEditBox.cpp",
          "type": "blob",
          "size": 1.8447265625,
          "content": "// SearchEditBox.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"SearchEditBox.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchEditBox\n\nCSearchEditBox::CSearchEditBox()\n{\n}\n\nCSearchEditBox::~CSearchEditBox()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CSearchEditBox, CEdit)\n\t//{{AFX_MSG_MAP(CSearchEditBox)\n\t\t// NOTE - the ClassWizard will add and remove mapping macros here.\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchEditBox message handlers\n\nBOOL CSearchEditBox::PreTranslateMessage(MSG* pMsg) \n{\n\tswitch(pMsg->message) \n\t{\n\t\tcase WM_KEYDOWN:\n\t\t{\n\t\t\tif(pMsg->wParam == VK_RETURN)\n\t\t\t{\n\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\tif(pWnd)\n\t\t\t\t{\n\t\t\t\t\tif(CGetSetOptions::m_bFindAsYouType)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(NM_SEARCH_ENTER_PRESSED, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Send a message to the parent to refill the lb from the search\n\t\t\t\t\t\tpWnd->PostMessage(CB_SEARCH, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn TRUE;\n\t\t\t}\t\n\t\t\telse if (pMsg->wParam == VK_DOWN ||\n\t\t\t\t\t\tpMsg->wParam == VK_UP ||\n\t\t\t\t\t\tpMsg->wParam == VK_F3)\n\t\t\t{\n\t\t\t\tif(CGetSetOptions::m_bFindAsYouType)\n\t\t\t\t{\n\t\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\t\tif(pWnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(pMsg->wParam == 'C' && CONTROL_PRESSED ||\n\t\t\t\t\tpMsg->wParam == 'X' && CONTROL_PRESSED ||\n\t\t\t\t\tpMsg->wParam == VK_DELETE)\n\t\t\t{\n\t\t\t\tLONG lEditSel = GetSel();\n\t\t\t\tif(LOWORD(lEditSel) == HIWORD(lEditSel))\n\t\t\t\t{\n\t\t\t\t\tCWnd *pWnd = GetParent();\n\t\t\t\t\tif(pWnd)\n\t\t\t\t\t{\n\t\t\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn CEdit::PreTranslateMessage(pMsg);\n}\n"
        },
        {
          "name": "SearchEditBox.h",
          "type": "blob",
          "size": 1.1689453125,
          "content": "#if !defined(AFX_SEARCHEDITBOX_H__E1864DC5_E60C_419F_A419_19F8222E42EC__INCLUDED_)\n#define AFX_SEARCHEDITBOX_H__E1864DC5_E60C_419F_A419_19F8222E42EC__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// SearchEditBox.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CSearchEditBox window\n\nclass CSearchEditBox : public CEdit\n{\n// Construction\npublic:\n\tCSearchEditBox();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CSearchEditBox)\n\tpublic:\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~CSearchEditBox();\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CSearchEditBox)\n\t\t// NOTE - the ClassWizard will add and remove member functions here.\n\t//}}AFX_MSG\n\n\tDECLARE_MESSAGE_MAP()\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_SEARCHEDITBOX_H__E1864DC5_E60C_419F_A419_19F8222E42EC__INCLUDED_)\n"
        },
        {
          "name": "SelectDB.cpp",
          "type": "blob",
          "size": 2.21484375,
          "content": "// SelectDB.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"SelectDB.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CSelectDB dialog\n\n\nCSelectDB::CSelectDB(CWnd* pParent /*=NULL*/)\n\t: CDialog(CSelectDB::IDD, pParent)\n{\n\t//{{AFX_DATA_INIT(CSelectDB)\n\t//}}AFX_DATA_INIT\n}\n\n\nvoid CSelectDB::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CSelectDB)\n\tDDX_Control(pDX, IDC_PATH, m_ePath);\n\t//}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CSelectDB, CDialog)\n\t//{{AFX_MSG_MAP(CSelectDB)\n\tON_BN_CLICKED(IDC_SELECT, OnSelect)\n\tON_BN_CLICKED(IDC_USE_DEFAULT, OnUseDefault)\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CSelectDB message handlers\n\nBOOL CSelectDB::OnInitDialog() \n{\n\tCDialog::OnInitDialog();\n\t\n\tm_ePath.SetWindowText(CGetSetOptions::GetDBPath(FALSE));\n\t\n\tm_ePath.SetFocus();\n\t\n\treturn FALSE;\n}\n\nvoid CSelectDB::OnOK() \n{\n\tCString csPath;\n\tm_ePath.GetWindowText(csPath);\n\n\tCGetSetOptions::SetDBPath(csPath);\n\t\t\n\tCDialog::OnOK();\n}\n\nvoid CSelectDB::OnSelect() \n{\n\tOPENFILENAME\tFileName;\n\n\tTCHAR\t\t\tszFileName[400];\n\tTCHAR\t\t\tszDir[400];\n\n\tmemset(&FileName, 0, sizeof(FileName));\n\tmemset(szFileName, 0, sizeof(szFileName));\n\tmemset(&szDir, 0, sizeof(szDir));\n\n\tFileName.lStructSize = sizeof(FileName);\n\n\t\n\tFileName.lpstrTitle = _T(\"Open Database\");\n\tFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST;\n\tFileName.nMaxFile = 400;\n\tFileName.lpstrFile = szFileName;\n\tFileName.lpstrInitialDir = szDir;\n\tFileName.lpstrFilter = _T(\"Database Files (.MDB)\\0*.mdb\");\n\tFileName.lpstrDefExt = _T(\"mdb\");\n\n\tif(GetOpenFileName(&FileName) == 0)\n\t\treturn;\n\n\tCString\tcsPath(FileName.lpstrFile);\n\n\tif(ValidDB(csPath) == FALSE)\n\t{\n\t\tMessageBox(_T(\"Invalid Database\"), _T(\"Ditto\"), MB_OK);\n\t\tm_ePath.SetFocus();\n\t}\n\telse\n\t\tm_ePath.SetWindowText(csPath);\t\n}\n\nvoid CSelectDB::OnUseDefault() \n{\n\tCGetSetOptions::SetDBPath(\"\");\n\tCString csPath = CGetSetOptions::GetDBPath();\n\n\tif(ValidDB(csPath) == FALSE)\n\t\tDeleteFile(csPath);\n\t\n\tif(CheckDBExists(CGetSetOptions::GetDBPath()))\n\t\tEndDialog(IDOK);\n}\n"
        },
        {
          "name": "SelectDB.h",
          "type": "blob",
          "size": 1.1787109375,
          "content": "#if !defined(AFX_SELECTDB_H__1B0F5220_5F1A_426F_BA9B_4722E7EA76A3__INCLUDED_)\n#define AFX_SELECTDB_H__1B0F5220_5F1A_426F_BA9B_4722E7EA76A3__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// SelectDB.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CSelectDB dialog\n\nclass CSelectDB : public CDialog\n{\n// Construction\npublic:\n\tCSelectDB(CWnd* pParent = NULL);   // standard constructor\n\n// Dialog Data\n\t//{{AFX_DATA(CSelectDB)\n\tenum { IDD = IDD_SELECT_DB };\n\tCEdit\tm_ePath;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CSelectDB)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CSelectDB)\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnOK();\n\tafx_msg void OnSelect();\n\tafx_msg void OnUseDefault();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_SELECTDB_H__1B0F5220_5F1A_426F_BA9B_4722E7EA76A3__INCLUDED_)\n"
        },
        {
          "name": "SendKeys.cpp",
          "type": "blob",
          "size": 19.0322265625,
          "content": "#include \"stdafx.h\"\r\n#include \"sendkeys.h\"\r\n\r\n/* \r\n* ----------------------------------------------------------------------------- \r\n* Copyright (c) 2004 lallous <lallousx86@yahoo.com>\r\n* All rights reserved.\r\n* \r\n* Redistribution and use in source and binary forms, with or without\r\n* modification, are permitted provided that the following conditions\r\n* are met:\r\n* 1. Redistributions of source code must retain the above copyright\r\n*    notice, this list of conditions and the following disclaimer.\r\n* 2. Redistributions in binary form must reproduce the above copyright\r\n*    notice, this list of conditions and the following disclaimer in the\r\n*    documentation and/or other materials provided with the distribution.\r\n* \r\n* THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\r\n* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n* ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\r\n* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\r\n* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\r\n* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n* SUCH DAMAGE.\r\n* ----------------------------------------------------------------------------- \r\n\r\n\r\nThe Original SendKeys copyright info\r\n---------------------------------------\r\nSendKeys (sndkeys32.pas) routine for 32-bit Delphi.\r\nWritten by Ken Henderson\r\nCopyright (c) 1995 Ken Henderson <khen@compuserve.com>\r\n\r\nHistory\r\n----------\r\n04/19/2004\r\n  * Initial version development\r\n04/21/2004\r\n  * Added number of times specifier to special keys\r\n  * Added {BEEP X Y}\r\n  * Added {APPACTIVATE WindowTitle}\r\n  * Added CarryDelay() and now delay works properly with all keys\r\n  * Added SetDelay() method\r\n  * Fixed code in AppActivate that allowed to pass both NULL windowTitle/windowClass\r\n\r\n05/21/2004\r\n  * Fixed a bug in StringToVKey() that caused the search for RIGHTPAREN to be matched as RIGHT\r\n  * Adjusted code so it compiles w/ VC6\r\n05/24/2004\r\n  * Added unicode support\r\n\r\nTodo\r\n-------\r\n* perhaps add mousecontrol: mousemove+mouse clicks\r\n* allow sending of normal keys multiple times as: {a 10}\r\n\r\n*/\r\n\r\nconst WORD CSendKeys::VKKEYSCANSHIFTON = 0x01;\r\nconst WORD CSendKeys::VKKEYSCANCTRLON  = 0x02;\r\nconst WORD CSendKeys::VKKEYSCANALTON   = 0x04;\r\nconst WORD CSendKeys::INVALIDKEY       = 0xFFFF;\r\n\r\nconst BYTE CSendKeys::ExtendedVKeys[MaxExtendedVKeys] =\r\n{\r\n    VK_UP, \r\n    VK_DOWN,\r\n    VK_LEFT,\r\n    VK_RIGHT,\r\n    VK_HOME,\r\n    VK_END,\r\n    VK_PRIOR, // PgUp\r\n    VK_NEXT,  //  PgDn\r\n    VK_INSERT,\r\n    VK_DELETE,\r\n\tVK_CONTROL,\r\n\tVK_SHIFT,\r\n};\r\n\r\nCSendKeys::CSendKeys()\r\n{\r\n  m_nDelayNow = m_nDelayAlways = m_keyDownDelay = 0;\r\n}\r\n\r\n// Delphi port regexps:\r\n// ---------------------\r\n// search: .+Name:'([^']+)'.+vkey:([^\\)]+)\\)\r\n// replace: {\"\\1\", \\2}\r\n//\r\n// **If you add to this list, you must be sure to keep it sorted alphabetically\r\n// by Name because a binary search routine is used to scan it.**\r\n//\r\nCSendKeys::key_desc_t CSendKeys::KeyNames[CSendKeys::MaxSendKeysRecs] = \r\n{\r\n  {_T(\"ADD\"), VK_ADD}, \r\n  {_T(\"APPS\"), VK_APPS},\r\n  {_T(\"AT\"), '@', true},\r\n  {_T(\"BACKSPACE\"), VK_BACK},\r\n  {_T(\"BKSP\"), VK_BACK},\r\n  {_T(\"BREAK\"), VK_CANCEL},\r\n  {_T(\"BS\"), VK_BACK},\r\n  {_T(\"CAPSLOCK\"), VK_CAPITAL},\r\n  {_T(\"CARET\"), '^', true},\r\n  {_T(\"CLEAR\"), VK_CLEAR},\r\n  {_T(\"DECIMAL\"), VK_DECIMAL}, \r\n  {_T(\"DEL\"), VK_DELETE},\r\n  {_T(\"DELETE\"), VK_DELETE},\r\n  {_T(\"DIVIDE\"), VK_DIVIDE}, \r\n  {_T(\"DOWN\"), VK_DOWN},\r\n  {_T(\"END\"), VK_END},\r\n  {_T(\"ENTER\"), VK_RETURN},\r\n  {_T(\"ESC\"), VK_ESCAPE},\r\n  {_T(\"ESCAPE\"), VK_ESCAPE},\r\n  {_T(\"F1\"), VK_F1},\r\n  {_T(\"F10\"), VK_F10},\r\n  {_T(\"F11\"), VK_F11},\r\n  {_T(\"F12\"), VK_F12},\r\n  {_T(\"F13\"), VK_F13},\r\n  {_T(\"F14\"), VK_F14},\r\n  {_T(\"F15\"), VK_F15},\r\n  {_T(\"F16\"), VK_F16},\r\n  {_T(\"F2\"), VK_F2},\r\n  {_T(\"F3\"), VK_F3},\r\n  {_T(\"F4\"), VK_F4},\r\n  {_T(\"F5\"), VK_F5},\r\n  {_T(\"F6\"), VK_F6},\r\n  {_T(\"F7\"), VK_F7},\r\n  {_T(\"F8\"), VK_F8},\r\n  {_T(\"F9\"), VK_F9},\r\n  {_T(\"HELP\"), VK_HELP},\r\n  {_T(\"HOME\"), VK_HOME},\r\n  {_T(\"INS\"), VK_INSERT},\r\n  {_T(\"LEFT\"), VK_LEFT},\r\n  {_T(\"LEFTBRACE\"), '{', true},\r\n  {_T(\"LEFTPAREN\"), '(', true},\r\n  {_T(\"LWIN\"), VK_LWIN},\r\n  {_T(\"MULTIPLY\"), VK_MULTIPLY}, \r\n  {_T(\"NUMLOCK\"), VK_NUMLOCK},\r\n  {_T(\"NUMPAD0\"), VK_NUMPAD0}, \r\n  {_T(\"NUMPAD1\"), VK_NUMPAD1}, \r\n  {_T(\"NUMPAD2\"), VK_NUMPAD2}, \r\n  {_T(\"NUMPAD3\"), VK_NUMPAD3}, \r\n  {_T(\"NUMPAD4\"), VK_NUMPAD4}, \r\n  {_T(\"NUMPAD5\"), VK_NUMPAD5}, \r\n  {_T(\"NUMPAD6\"), VK_NUMPAD6}, \r\n  {_T(\"NUMPAD7\"), VK_NUMPAD7}, \r\n  {_T(\"NUMPAD8\"), VK_NUMPAD8}, \r\n  {_T(\"NUMPAD9\"), VK_NUMPAD9}, \r\n  {_T(\"PERCENT\"), '%', true},\r\n  {_T(\"PGDN\"), VK_NEXT},\r\n  {_T(\"PGUP\"), VK_PRIOR},\r\n  {_T(\"PLUS\"), '+', true},\r\n  {_T(\"PRTSC\"), VK_PRINT},\r\n  {_T(\"RIGHT\"), VK_RIGHT},\r\n  {_T(\"RIGHTBRACE\"), '}', true},\r\n  {_T(\"RIGHTPAREN\"), ')', true},\r\n  {_T(\"RWIN\"), VK_RWIN},\r\n  {_T(\"SCROLL\"), VK_SCROLL},\r\n  {_T(\"SEPARATOR\"), VK_SEPARATOR}, \r\n  {_T(\"SNAPSHOT\"), VK_SNAPSHOT},\r\n  {_T(\"SUBTRACT\"), VK_SUBTRACT}, \r\n  {_T(\"TAB\"), VK_TAB},\r\n  {_T(\"TILDE\"), '~', true}, \r\n  {_T(\"UP\"), VK_UP},\r\n  {_T(\"WIN\"), VK_LWIN}\r\n};\r\n\r\n\r\n\r\n// calls keybd_event() and waits, if needed, till the sent input is processed\r\nvoid CSendKeys::KeyboardEvent(BYTE VKey, BYTE ScanCode, LONG Flags)\r\n{\r\n\tkeybd_event(VKey, ScanCode, Flags, 0);\r\n\r\n\tif (m_bWait)\r\n\t{\r\n\t\tMSG KeyboardMsg;\r\n\t\twhile (::PeekMessage(&KeyboardMsg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))\r\n\t\t{\r\n\t\t\t::TranslateMessage(&KeyboardMsg);\r\n\t\t\t::DispatchMessage(&KeyboardMsg);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Checks whether the specified VKey is an extended key or not\r\nbool CSendKeys::IsVkExtended(BYTE VKey)\r\n{\r\n  for (int i=0;i<MaxExtendedVKeys;i++)\r\n  {\r\n    if (ExtendedVKeys[i] == VKey)\r\n      return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nCString CSendKeys::VkString(BYTE VKey)\r\n{\r\n\tfor (int i = 0; i < MaxSendKeysRecs; i++)\r\n\t{\r\n\t\tif (KeyNames[i].VKey == VKey)\r\n\t\t\treturn KeyNames[i].keyName;\r\n\t}\r\n\treturn _T(\"\");\r\n}\r\n\r\nvoid CSendKeys::AllKeysUp()\r\n{\r\n\tfor (int key = 0; key < 256; key++)\r\n\t{\r\n\t\t//If the key is pressed, send a key up, having other keys down interferes with sending ctrl-v, -c and -x\r\n\t\tshort val = GetKeyState(key);\r\n\t\tif (val & 0x8000)\r\n\t\t{\r\n\t\t\tSendKeyUp(key);\r\n\r\n\t\t\t//CString cs;\r\n\t\t\t//cs.Format(_T(\"key was down, sending key up %d, value: %d\\n\"), key, val);\r\n\t\t\t//OutputDebugString(cs);\r\n\t\t}\r\n\t}\r\n\r\n\t//Force these to be up, i was having trouble with the right shift key, i think things were\r\n\t//getting confused between the basic shift and lshift, but not sure.\r\n\tSendKeyUp(VK_LSHIFT);\r\n\tSendKeyUp(VK_RSHIFT);\r\n\tSendKeyUp(VK_LCONTROL);\r\n\tSendKeyUp(VK_RCONTROL);\r\n\tSendKeyUp(VK_LMENU);\r\n\tSendKeyUp(VK_RMENU);\r\n}\r\n\r\n// Generates KEYUP\r\nvoid CSendKeys::SendKeyUp(BYTE VKey)\r\n{\r\n  BYTE ScanCode = LOBYTE(::MapVirtualKey(VKey, 0));\r\n\r\n\r\n  KeyboardEvent(VKey, \r\n                ScanCode, \r\n                KEYEVENTF_KEYUP | (IsVkExtended(VKey) ? KEYEVENTF_EXTENDEDKEY : 0));\r\n}\r\n\r\nvoid CSendKeys::SendKeyDown(BYTE VKey, WORD NumTimes, bool GenUpMsg, bool bDelay)\r\n {\r\n  WORD Cnt = 0;\r\n  BYTE ScanCode = 0;\r\n  bool NumState = false;\r\n\r\n  if (VKey == VK_NUMLOCK)\r\n  {\r\n    DWORD dwVersion = ::GetVersion();\r\n\r\n    for (Cnt=1; Cnt<=NumTimes; Cnt++)\r\n    {\r\n      if (bDelay)\r\n        CarryDelay();\r\n      // snippet based on:\r\n      // http://www.codeproject.com/cpp/togglekeys.asp\r\n      if (dwVersion < 0x80000000)\r\n      {\r\n        ::keybd_event(VKey, 0x45, KEYEVENTF_EXTENDEDKEY, 0);\r\n        ::keybd_event(VKey, 0x45, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);\r\n      }\r\n      else\r\n      {\r\n        // Win98 and later\r\n        if ( ((DWORD)(HIBYTE(LOWORD(dwVersion))) >= 10) )\r\n        {\r\n          // Define _WIN32_WINNT > 0x0400\r\n          // to compile\r\n          INPUT input[2] = {0};\r\n          input[0].type = input[1].type = INPUT_KEYBOARD;\r\n          input[0].ki.wVk = input[1].ki.wVk = VKey;\r\n          input[1].ki.dwFlags = KEYEVENTF_KEYUP;\r\n          ::SendInput(sizeof(input) / sizeof(INPUT), input, sizeof(INPUT));\r\n        }\r\n        // Win95\r\n        else\r\n        {\r\n          KEYBOARDSTATE_t KeyboardState;\r\n          NumState = GetKeyState(VK_NUMLOCK) & 1 ? true : false;\r\n          GetKeyboardState(&KeyboardState[0]);\r\n          if (NumState)\r\n            KeyboardState[VK_NUMLOCK] &= ~1;\r\n          else\r\n            KeyboardState[VK_NUMLOCK] |= 1;\r\n\r\n          SetKeyboardState(&KeyboardState[0]);\r\n        }\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Get scancode\r\n  ScanCode = LOBYTE(::MapVirtualKey(VKey, 0));\r\n\r\n  // Send keys\r\n  for (Cnt=1; Cnt<=NumTimes; Cnt++)\r\n  {\r\n    // Carry needed delay ?\r\n    if (bDelay)\r\n      CarryDelay();\r\n\r\n    KeyboardEvent(VKey, ScanCode, IsVkExtended(VKey) ? KEYEVENTF_EXTENDEDKEY : 0);\r\n\r\n\tif(m_keyDownDelay > 0)\r\n\t{\r\n\t\tSleep(m_keyDownDelay);\r\n\t}\r\n\r\n\tif (GenUpMsg)\r\n\t{\r\n\t\tSendKeyUp(VKey);\r\n\t}\r\n\r\n  }\r\n}\r\n\r\n// Checks whether a bit is set\r\nbool CSendKeys::BitSet(BYTE BitTable, UINT BitMask)\r\n{\r\n  return BitTable & BitMask ? true : false;\r\n}\r\n\r\n// Sends a single key\r\nvoid CSendKeys::SendKey(WORD MKey, WORD NumTimes, bool GenDownMsg)\r\n{\r\n  // Send appropriate shift keys associated with the given VKey\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANSHIFTON))\r\n    SendKeyDown(VK_SHIFT, 1, false);\r\n\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANCTRLON))\r\n    SendKeyDown(VK_CONTROL, 1, false);\r\n\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANALTON))\r\n    SendKeyDown(VK_MENU, 1, false);\r\n\r\n  // Send the actual VKey\r\n  SendKeyDown(LOBYTE(MKey), NumTimes, GenDownMsg, true);\r\n\r\n  // toggle up shift keys\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANSHIFTON))\r\n    SendKeyUp(VK_SHIFT);\r\n\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANCTRLON))\r\n    SendKeyUp(VK_CONTROL);\r\n\r\n  if (BitSet(HIBYTE(MKey), VKKEYSCANALTON))\r\n    SendKeyUp(VK_MENU);\r\n}\r\n\r\n// Implements a simple binary search to locate special key name strings\r\nWORD CSendKeys::StringToVKey(LPCTSTR KeyString, int &idx)\r\n{\r\n  bool Found = false, Collided;\r\n  int  Bottom = 0, \r\n       Top = MaxSendKeysRecs,\r\n       Middle = (Bottom + Top) / 2;\r\n  WORD retval = INVALIDKEY;\r\n\r\n  idx    = -1;\r\n\r\n  do\r\n  {\r\n    Collided = (Bottom == Middle) || (Top == Middle);\r\n    int cmp = _tcsnicmp(KeyNames[Middle].keyName, KeyString, _tcslen(KeyString));\r\n    if (cmp == 0)\r\n    {\r\n      Found = true;\r\n      retval = KeyNames[Middle].VKey;\r\n      idx    = Middle;\r\n      break;\r\n    }\r\n    else\r\n    {\r\n      if (cmp < 0)\r\n        Bottom = Middle;\r\n      else\r\n        Top = Middle;\r\n      Middle = (Bottom + Top) / 2;\r\n    }\r\n  } while (!(Found || Collided));\r\n\r\n  return retval;\r\n}\r\n\r\n// Releases all shift keys (keys that can be depressed while other keys are being pressed\r\n// If we are in a modifier group this function does nothing\r\nvoid CSendKeys::PopUpShiftKeys()\r\n{\r\n  if (m_bUsingParens)\r\n\t\treturn;\r\n\r\n  if (m_bShiftDown)\r\n\t{\r\n      SendKeyUp(VK_SHIFT);\r\n\t}\r\n\tif (m_bLShiftDown)\r\n\t{\r\n\t\tSendKeyUp(VK_LSHIFT);\r\n\t}\r\n\tif (m_bRShiftDown)\r\n\t{\r\n\t\tSendKeyUp(VK_RSHIFT);\r\n\t}\r\n    if (m_bControlDown)\r\n\t{\r\n      SendKeyUp(VK_CONTROL);\r\n\t}\r\n\tif (m_bLControlDown)\r\n\t{\r\n\t\tSendKeyUp(VK_LCONTROL);\r\n\t}\r\n\tif (m_bRControlDown)\r\n\t{\r\n\t\tSendKeyUp(VK_RCONTROL);\r\n\t}\r\n    if (m_bAltDown)\r\n\t{\r\n      SendKeyUp(VK_MENU);\r\n\t}\r\n    if (m_bWinDown)\r\n\t{\r\n      SendKeyUp(VK_LWIN);\r\n\t}\r\n\r\n\tm_bWinDown = m_bShiftDown = m_bLShiftDown = m_bRShiftDown = m_bControlDown = m_bLControlDown = m_bRControlDown = m_bAltDown = false;\r\n}\r\n\r\n// Sends a key string\r\nbool CSendKeys::SendKeys(LPCTSTR KeysString, bool Wait)\r\n{\r\n  WORD MKey;\r\n  WORD NumTimes = 1;\r\n  TCHAR KeyString[300] = {0};\r\n  bool retval  = false;\r\n  int  keyIdx;\r\n\r\n  LPTSTR pKey = (LPTSTR) KeysString;\r\n  TCHAR  ch;\r\n\r\n  m_bWait = Wait;\r\n\r\n  m_bWinDown = m_bShiftDown = m_bLShiftDown = m_bRShiftDown = m_bControlDown = m_bLControlDown = m_bRControlDown = m_bAltDown = m_bUsingParens = false;\r\n\r\n  while (ch = *pKey)\r\n  {\r\n    switch (ch)\r\n    {\r\n    // begin modifier group\r\n    case _TXCHAR('('):\r\n      m_bUsingParens = true;\r\n      break;\r\n\r\n    // end modifier group\r\n    case _TXCHAR(')'):\r\n      m_bUsingParens = false;\r\n      PopUpShiftKeys(); // pop all shift keys when we finish a modifier group close\r\n      break;\r\n\r\n    // ALT key\r\n    case _TXCHAR('%'):\r\n      m_bAltDown = true;\r\n      SendKeyDown(VK_MENU, 1, false);\r\n      break;\r\n\r\n    // SHIFT key\r\n    case _TXCHAR('+'):\r\n      m_bShiftDown = true;\r\n      SendKeyDown(VK_SHIFT, 1, false);\r\n      break;\r\n\r\n    // CTRL key\r\n    case _TXCHAR('^'):\r\n      m_bControlDown = true;\r\n      SendKeyDown(VK_CONTROL, 1, false);\r\n      break;\r\n\r\n    // WINKEY (Left-WinKey)\r\n    case '@':\r\n      m_bWinDown = true;\r\n      SendKeyDown(VK_LWIN, 1, false);\r\n      break;\r\n\r\n    // enter\r\n    case _TXCHAR('~'):\r\n      SendKeyDown(VK_RETURN, 1, true);\r\n      PopUpShiftKeys();\r\n      break;\r\n\r\n    // begin special keys\r\n    case _TXCHAR('{'):\r\n      {\r\n        LPTSTR p = pKey+1; // skip past the beginning '{'\r\n        size_t t;\r\n\r\n        // find end of close\r\n        while (*p && *p != _TXCHAR('}'))\r\n          p++;\r\n\r\n        t = p - pKey;\r\n        // special key definition too big?\r\n        if (t > sizeof(KeyString))\r\n          return false;\r\n\r\n        // Take this KeyString into local buffer\r\n        _tcsncpy(KeyString, pKey+1, t);\r\n\r\n        KeyString[t-1] = _TXCHAR('\\0');\r\n        keyIdx = -1;\r\n\r\n        pKey += t; // skip to next keystring\r\n\r\n        // Invalidate key\r\n        MKey = INVALIDKEY;\r\n\r\n        // sending arbitrary vkeys?\r\n        if (_tcsnicmp(KeyString, _T(\"VKEY\"), 4) == 0)\r\n        {\r\n          p = KeyString + 4;\r\n          MKey = _ttoi(p);\r\n        }\r\n        else if (_tcsnicmp(KeyString, _T(\"BEEP\"), 4) == 0)\r\n        {\r\n          p = KeyString + 4 + 1;\r\n          LPTSTR p1 = p;\r\n          DWORD frequency, delay;\r\n\r\n          if ((p1 = _tcsstr(p, _T(\" \"))) != NULL)\r\n          {\r\n            *p1++ = _TXCHAR('\\0');\r\n            frequency = _ttoi(p);\r\n            delay = _ttoi(p1);\r\n            ::Beep(frequency, delay);\r\n          }\r\n        }\r\n        // Should activate a window?\r\n        else if (_tcsnicmp(KeyString, _T(\"APPACTIVATE\"), 11) == 0)\r\n        {\r\n          p = KeyString + 11 + 1;\r\n          AppActivate(p);\r\n        }\r\n        // want to send/set delay?\r\n        else if (_tcsnicmp(KeyString, _T(\"DELAY\"), 5) == 0)\r\n        {\r\n          // Advance to parameters\r\n          p = KeyString + 5;\r\n          // set \"sleep factor\"\r\n          if (*p == _TXCHAR('='))\r\n            m_nDelayAlways = _ttoi(p + 1); // Take number after the '=' character\r\n          else\r\n            // set \"sleep now\"\r\n            m_nDelayNow = _ttoi(p);\r\n        }\r\n        // not command special keys, then process as keystring to VKey\r\n        else\r\n        {\r\n          MKey = StringToVKey(KeyString, keyIdx);\r\n          // Key found in table\r\n          if (keyIdx != -1)\r\n          {\r\n            NumTimes = 1;\r\n\r\n            // Does the key string have also count specifier?\r\n            t = _tcslen(KeyNames[keyIdx].keyName);\r\n            if (_tcslen(KeyString) > t)\r\n            {\r\n              p = KeyString + t;\r\n              // Take the specified number of times\r\n              NumTimes = _ttoi(p);\r\n            }\r\n\r\n            if (KeyNames[keyIdx].normalkey)\r\n              MKey = ::VkKeyScan(KeyNames[keyIdx].VKey);\r\n          }\r\n        }\r\n\r\n        // A valid key to send?\r\n        if (MKey != INVALIDKEY)\r\n        {\r\n          if (MKey == VK_LCONTROL || MKey == VK_RCONTROL)\r\n          {\r\n            m_bLControlDown = (MKey == VK_LCONTROL);\r\n            m_bRControlDown = (MKey == VK_RCONTROL);\r\n            SendKeyDown(MKey, 1, false);\r\n          }\r\n          else if (MKey == VK_LSHIFT || MKey == VK_RSHIFT)\r\n          {\r\n            m_bLShiftDown = (MKey == VK_LSHIFT);\r\n            m_bRShiftDown = (MKey == VK_RSHIFT);\r\n            SendKeyDown(MKey, 1, false);\r\n          }\r\n          else\r\n          {\r\n            SendKey(MKey, NumTimes, true);\t\r\n            PopUpShiftKeys();\r\n          }\r\n        }\r\n      }\r\n      break;\r\n\r\n      // a normal key was pressed\r\n    default:\r\n      // Get the VKey from the key\r\n      MKey = ::VkKeyScan(ch);\r\n      SendKey(MKey, 1, true);\r\n      PopUpShiftKeys();\r\n    }\r\n    pKey++;\r\n  }\r\n\r\n  m_bUsingParens = false;\r\n  PopUpShiftKeys();\r\n  return true;\r\n}\r\n\r\nbool CSendKeys::AppActivate(HWND wnd)\r\n{\r\n  if (wnd == NULL)\r\n    return false;\r\n\r\n  ::SendMessage(wnd, WM_SYSCOMMAND, SC_HOTKEY, (LPARAM) wnd);\r\n  ::SendMessage(wnd, WM_SYSCOMMAND, SC_RESTORE, (LPARAM) wnd);\r\n  \r\n  ::ShowWindow(wnd, SW_SHOW);\r\n  ::SetForegroundWindow(wnd);\r\n  ::SetFocus(wnd);\r\n\r\n  return true;\r\n}\r\n\r\nBOOL CALLBACK CSendKeys::enumwindowsProc(HWND hwnd, LPARAM lParam)\r\n{\r\n  enumwindow_t *t = (enumwindow_t *) lParam;\r\n\r\n  LPTSTR wtitle = 0, wclass = 0, str = t->str;\r\n\r\n  if (!*str)\r\n    str++;\r\n  else\r\n  {\r\n    wtitle = str;\r\n    str += _tcslen(str) + 1;\r\n  }\r\n\r\n  if (*str)\r\n    wclass = str;\r\n\r\n  bool bMatch(false);\r\n\r\n  if (wclass)\r\n  {\r\n    TCHAR szClass[300];\r\n    if (::GetClassName(hwnd, szClass, sizeof(szClass)))\r\n      bMatch |= (_tcsstr(szClass, wclass) != 0);\r\n  }\r\n\r\n  if (wtitle)\r\n  {\r\n    TCHAR szTitle[300];\r\n    if (::GetWindowText(hwnd, szTitle, sizeof(szTitle)))\r\n      bMatch |= (_tcsstr(szTitle, wtitle) != 0);\r\n  }\r\n\r\n  if (bMatch)\r\n  {\r\n    t->hwnd = hwnd;\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// Searchs and activates a window given its title or class name\r\nbool CSendKeys::AppActivate(LPCTSTR WindowTitle, LPCTSTR WindowClass)\r\n{\r\n  HWND w;\r\n\r\n  w = ::FindWindow(WindowClass, WindowTitle);\r\n  if (w == NULL)\r\n  {\r\n    // Must specify at least a criteria\r\n    if (WindowTitle == NULL && WindowClass == NULL)\r\n      return false;\r\n\r\n    // << Code to serialize the windowtitle/windowclass in order to send to EnumWindowProc()\r\n    size_t l1(0), l2(0);\r\n    if (WindowTitle)\r\n      l1 = _tcslen(WindowTitle);\r\n    if (WindowClass)\r\n      l2 = _tcslen(WindowClass);\r\n\r\n    LPTSTR titleclass = new TCHAR [l1 + l2 + 5];\r\n\r\n    memset(titleclass, '\\0', l1+l2+5);\r\n\r\n    if (WindowTitle)\r\n      _tcscpy(titleclass, WindowTitle);\r\n\r\n    titleclass[l1] = 0;\r\n\r\n    if (WindowClass)\r\n      _tcscpy(titleclass+l1+1, WindowClass);\r\n\r\n    // >>\r\n\r\n    enumwindow_t t;\r\n\r\n    t.hwnd = NULL;\r\n    t.str  = titleclass;\r\n    ::EnumWindows(enumwindowsProc, (LPARAM) & t);\r\n    w = t.hwnd;\r\n    delete [] titleclass;\r\n  }\r\n\r\n  if (w == NULL)\r\n    return false;\r\n\r\n  return AppActivate(w);\r\n}\r\n\r\n// Carries the required delay and clears the m_nDelaynow value\r\nvoid CSendKeys::CarryDelay()\r\n{\r\n  // Should we delay once?\r\n  if (!m_nDelayNow)\r\n    // should we delay always?\r\n    m_nDelayNow = m_nDelayAlways;\r\n\r\n  // No delay specified?\r\n  if (m_nDelayNow)\r\n    ::Sleep(m_nDelayNow); //::Beep(100, m_nDelayNow);\r\n\r\n  // clear SleepNow\r\n  m_nDelayNow = 0;\r\n}\r\n\r\n/*\r\nTest Binary search\r\nvoid CSendKeys::test()\r\n{\r\n  WORD miss(0);\r\n  for (int i=0;i<MaxSendKeysRecs;i++)\r\n  {\r\n    char *p = (char *)KeyNames[i].keyName;\r\n    WORD v = StringToVKeyB(p);\r\n    if (v == INVALIDKEY)\r\n    {\r\n      miss++;\r\n    }\r\n  }\r\n}\r\n*/\r\n\r\n/*\r\nSearch in a linear manner\r\nWORD CSendKeys::StringToVKey(const char *KeyString, int &idx)\r\n{\r\nfor (int i=0;i<MaxSendKeysRecs;i++)\r\n{\r\nsize_t len = strlen(KeyNames[i].keyName);\r\nif (strnicmp(KeyNames[i].keyName, KeyString, len) == 0)\r\n{\r\nidx = i;\r\nreturn KeyNames[i].VKey;\r\n}\r\n}\r\nidx = -1;\r\nreturn INVALIDKEY;\r\n}\r\n*/\r\n"
        },
        {
          "name": "SendKeys.h",
          "type": "blob",
          "size": 2.1025390625,
          "content": "#ifndef __SENDKEYS_04192004__INC__\n#define __SENDKEYS_04192004__INC__\n\n#include <windows.h>\n#include <tchar.h>\n// Please see SendKeys.cpp for copyright and usage issues.\n\nclass CSendKeys\n{\nprivate:\n  bool m_bWait, m_bUsingParens, m_bShiftDown, m_bLShiftDown, m_bRShiftDown, m_bAltDown, m_bControlDown, m_bLControlDown, m_bRControlDown, m_bWinDown;\n  DWORD  m_nDelayAlways, m_nDelayNow, m_keyDownDelay;\n\n  static BOOL CALLBACK enumwindowsProc(HWND hwnd, LPARAM lParam);\n  void   CarryDelay();\n\n  typedef BYTE KEYBOARDSTATE_t[256];\n  struct enumwindow_t\n  {\n    LPTSTR str;\n    HWND hwnd;\n  };\n\n  struct key_desc_t\n  {\n    LPCTSTR keyName;\n    BYTE VKey;\n    bool normalkey; // a normal character or a VKEY ?\n  };\n\n  enum\n  {\n    MaxSendKeysRecs  = 71,\n    MaxExtendedVKeys = 12\n  };\n\n  /*\n  Reference: VkKeyScan() / MSDN\n  Bit Meaning \n  --- --------\n  1   Either SHIFT key is pressed. \n  2   Either CTRL key is pressed. \n  4   Either ALT key is pressed. \n  8   The Hankaku key is pressed \n  16  Reserved (defined by the keyboard layout driver). \n  32  Reserved (defined by the keyboard layout driver). \n  */\n  static const WORD VKKEYSCANSHIFTON;\n  static const WORD VKKEYSCANCTRLON;\n  static const WORD VKKEYSCANALTON;\n  static const WORD INVALIDKEY;\n\n  static key_desc_t KeyNames[MaxSendKeysRecs]; \n  static const BYTE ExtendedVKeys[MaxExtendedVKeys];\n\n  static bool BitSet(BYTE BitTable, UINT BitMask);\n\n  void PopUpShiftKeys();\n\n  \n  static bool IsVkExtended(BYTE VKey);\n  void SendKeyUp(BYTE VKey);\n  void SendKeyDown(BYTE VKey, WORD NumTimes, bool GenUpMsg, bool bDelay = false);\n  void SendKey(WORD MKey, WORD NumTimes, bool GenDownMsg);\n  static WORD StringToVKey(LPCTSTR KeyString, int &idx);\n  void KeyboardEvent(BYTE VKey, BYTE ScanCode, LONG Flags);\n\npublic:\n\n  void AllKeysUp();\n  bool SendKeys(LPCTSTR KeysString, bool Wait = false);\n  static bool AppActivate(HWND wnd);\n  static bool AppActivate(LPCTSTR WindowTitle, LPCTSTR WindowClass = 0);\n  void SetDelay(const DWORD delay) { m_nDelayAlways = delay; }\n  void SetKeyDownDelay(const DWORD delay) { m_keyDownDelay = delay; }\n  static CString VkString(BYTE VKey);\n  CSendKeys();\n};\n\n#endif"
        },
        {
          "name": "SendMail.cpp",
          "type": "blob",
          "size": 1.3837890625,
          "content": "#include \"stdafx.h\"\n#include \"SendMail.h\"\n#include \"Path.h\"\n#include <mapi.h>\n#include \"Misc.h\"\n\n\nbool SendMail::Send(CString subject, CString body, CString attachmentFileName)\n{\n\tHINSTANCE hMAPI = ::LoadLibraryA((\"MAPI32.DLL\"));\n\tif (!hMAPI)\n\t{\n\t\tlog(_T(\"failed to load MAPI32.DLL\"));\n\t\treturn false;\n\t}\n\n\t// Grab the exported entry point for the MAPISendMail function\n\tULONG(PASCAL *SendMail)(ULONG, ULONG_PTR, MapiMessageW*, FLAGS, ULONG);\n\t(FARPROC&)SendMail = GetProcAddress(hMAPI, \"MAPISendMailW\");\n\n\tif (!SendMail)\n\t{\n\t\tlog(_T(\"failed to load MAPISendMailW from MAPI32.DLL\"));\n\t\treturn false;\n\t}\n\n\tMapiMessageW message;\n\t::ZeroMemory(&message, sizeof(message));\n\tmessage.lpszNoteText = body.GetBuffer();\n\tmessage.lpszSubject = subject.GetBuffer();\n\n\tCString attachFileName;\n\n\tif (attachmentFileName != _T(\"\"))\n\t{\n\t\tMapiFileDescW fileDesc;\n\t\t::ZeroMemory(&fileDesc, sizeof(fileDesc));\n\t\tfileDesc.nPosition = (ULONG)-1;\n\t\tfileDesc.lpszPathName = attachmentFileName.GetBuffer();\n\n\t\tusing namespace nsPath;\n\t\tCPath path(fileDesc.lpszPathName);\n\t\tattachFileName = path.GetName();\n\n\t\tfileDesc.lpszFileName = attachFileName.GetBuffer();\n\n\t\tmessage.nFileCount = 1;\n\t\tmessage.lpFiles = &fileDesc;\n\t}\n\n\t// Ok to send\n\tint nError = SendMail(0, (ULONG_PTR)0, &message, MAPI_DIALOG_MODELESS, 0);\n\n\tif (nError != SUCCESS_SUCCESS)\n\t{\n\t\tlog(StrF(_T(\"SendMail failed, return %d\"), nError));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"
        },
        {
          "name": "SendMail.h",
          "type": "blob",
          "size": 0.1171875,
          "content": "#pragma once\nclass SendMail\n{\npublic:\n\tstatic bool Send(CString subject, CString body, CString attachmentFileName);\n};\n\n"
        },
        {
          "name": "SendSocket.cpp",
          "type": "blob",
          "size": 1.9609375,
          "content": "// SendSocket.cpp: implementation of the CSendSocket class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"SendSocket.h\"\n#include \"shared/TextConvert.h\"\n\n#ifdef _DEBUG\n#undef THIS_FILE\nstatic char THIS_FILE[]=__FILE__;\n#define new DEBUG_NEW\n#endif\n\n//////////////////////////////////////////////////////////////////////\n// Construction/Destruction\n//////////////////////////////////////////////////////////////////////\n\nCSendSocket::CSendSocket()\n{\n\tm_pEncryptor = new CEncryption;\n\tm_Connection = NULL;\n}\n\nCSendSocket::~CSendSocket()\n{\n\tdelete m_pEncryptor;\n\tm_pEncryptor = NULL;\n}\n\n\nBOOL CSendSocket::SendCSendData(CSendInfo &data, MyEnums::eSendType type)\n{\n\tdata.m_Type = type;\n\treturn SendExactSize((char *)&data, sizeof(CSendInfo), true);\n}\n\nBOOL CSendSocket::SendExactSize(char *pData, long lLength, bool bEncrypt)\n{\n\tBOOL bRet = FALSE;\n\tif(!m_pEncryptor && bEncrypt)\n\t{\n\t\tASSERT(!\"Encryption not initialized\");\n\t\tLogSendRecieveInfo(\"SendExactSize::Encryption not initialized\");\n\t\treturn bRet;\n\t}\n\n\tLogSendRecieveInfo(StrF(_T(\"START SendExactSize Total %d\"), lLength));\n\n\tUCHAR* pOutput = (UCHAR*)pData;\n\tint nLenOutput = lLength;\n\tlong lBytesRead = 0;\n\n\tif(bEncrypt == false || m_pEncryptor->Encrypt((UCHAR*)pData, lLength, CGetSetOptions::m_csPassword, pOutput, nLenOutput))\n\t{\n\t\tlong lExpected = nLenOutput;\n\n\t\twhile(lBytesRead < lExpected)\n\t\t{\n\t\t\tlong lSize = send(m_Connection, (char*)pOutput + lBytesRead, lExpected - lBytesRead, 0);\n\t\t\n\t\t\tif(lSize == SOCKET_ERROR || lSize == 0)\n\t\t\t{\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"lSize == SOCKET_ERROR, %d\"), WSAGetLastError()));\n\t\t\t\tbRet = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlBytesRead += lSize;\n\t\t}\n\n\t\tif(lBytesRead == lExpected)\n\t\t\tbRet = TRUE;\n\n\t\tif(pOutput != (UCHAR*)pData)\n\t\t\tm_pEncryptor->FreeBuffer(pOutput);\n\t}\n\telse\n\t{\n\t\tLogSendRecieveInfo(\"SendExactSize::Failed to encrypt data\");\n\t}\n\n//\tLogSendRecieveInfo(StrF(_T(\"END SendExactSize Total %d\"), lBytesRead));\n\n\treturn bRet;\n}"
        },
        {
          "name": "SendSocket.h",
          "type": "blob",
          "size": 0.951171875,
          "content": "// SendSocket.h: interface for the CSendSocket class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_SENDSOCKET_H__4A4A5B96_8123_413C_8F86_A2875C9E5E48__INCLUDED_)\n#define AFX_SENDSOCKET_H__4A4A5B96_8123_413C_8F86_A2875C9E5E48__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include \"EncryptDecrypt\\Encryption.h\"\n#include \"ServerDefines.h\"\n#include \"FileTransferProgressDlg.h\"\n\n\nclass CSendSocket  \n{\npublic:\n\tCSendSocket();\n\tvirtual ~CSendSocket();\n\n\tvoid SetSocket(SOCKET sock)\t\t{ m_Connection = sock;\t}\n\tvoid SetProgressBar(CFileTransferProgressDlg *pDlg) { m_pProgress = pDlg; }\n\n\tCEncryption *m_pEncryptor;\n\n\tBOOL SendCSendData(CSendInfo &data, MyEnums::eSendType type);\n\tBOOL SendExactSize(char *pData, long lLength, bool bEncrypt);\n\nprotected:\n\tSOCKET m_Connection;\n\n\tCFileTransferProgressDlg *m_pProgress;\n};\n\n#endif // !defined(AFX_SENDSOCKET_H__4A4A5B96_8123_413C_8F86_A2875C9E5E48__INCLUDED_)\n"
        },
        {
          "name": "Server.cpp",
          "type": "blob",
          "size": 8.388671875,
          "content": "// Server.cpp: implementation of the CServer class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"Server.h\"\r\n#include \"Shared\\Tokenizer.h\"\r\n#include \"WildCardMatch.h\"\r\n\r\n#ifdef _DEBUG\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[]=__FILE__;\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Construction/Destruction\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nUINT  MTServerThread(LPVOID pParam)\r\n{\t\t\r\n\tstatic bool bRunning = false;\r\n\tif(bRunning)\r\n\t\treturn 0;\r\n\tbRunning = true;\r\n\r\n\tLogSendRecieveInfo(\"Start of ServerThread\");\r\n\r\n\ttheApp.m_bExitServerThread = false;\r\n\r\n\tWSADATA wsaData;\r\n\tsockaddr_in local;\r\n\tint wsaret = WSAStartup(0x101,&wsaData);\r\n\tif(wsaret!=0)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - int wsaret = WSAStartup(0x101,&wsaData);\");\r\n\t\treturn 0;\r\n\t}\r\n\tlocal.sin_family = AF_INET;\r\n\tCString bindToIpAddress = CGetSetOptions::GetNetworkBindIPAddress();\r\n\tif (bindToIpAddress == _T(\"*\"))\r\n\t{\r\n\t\tlocal.sin_addr.s_addr = INADDR_ANY;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlocal.sin_addr.s_addr = inet_addr(CTextConvert::UnicodeToAnsi(bindToIpAddress));\r\n\t}\r\n\tlocal.sin_port = htons((u_short)CGetSetOptions::m_lPort);\r\n\ttheApp.m_sSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\tif(theApp.m_sSocket == INVALID_SOCKET)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - theApp.m_sSocket = socket(AF_INET, SOCK_STREAM, 0);\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(bind(theApp.m_sSocket,(sockaddr*)&local,sizeof(local))!=0)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - if(bind(theApp.m_sSocket,(sockaddr*)&local,sizeof(local))!=0)\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(listen(theApp.m_sSocket,10)!=0)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"ERROR - if(listen(theApp.m_sSocket,10)!=0)\");\r\n\t\treturn 0;\r\n\t}\r\n\t\t\r\n\tsockaddr_in from;\r\n\tint fromlen = sizeof(from);\r\n\r\n\twhile(true)\r\n\t{\r\n\t\tif(theApp.m_bAppExiting || theApp.m_bExitServerThread)\r\n\t\t\tbreak;\r\n\r\n\t\tSOCKET socket = accept(theApp.m_sSocket, (struct sockaddr*)&from, &fromlen);\r\n\r\n\t\tSocketParams *pParams = new SocketParams();\r\n\t\tpParams->m_ip = inet_ntoa(from.sin_addr);\r\n\t\tpParams->m_socket = socket;\r\n\r\n\t\tif (socket != INVALID_SOCKET)\r\n\t\t{\r\n\t\t\tAfxBeginThread(ClientThread, (LPVOID)pParams);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdelete pParams;\r\n\t\t}\r\n\t}\t\r\n\r\n\tLogSendRecieveInfo(\"End of Server Thread\");\r\n\r\n\tbRunning = false;\r\n\ttheApp.m_sSocket = INVALID_SOCKET;\r\n\r\n\treturn 0;\r\n}\r\n\r\nUINT  ClientThread(LPVOID pParam)\r\n{\t\r\n\tLogSendRecieveInfo(\"*********************Start of ClientThread*********************\");\r\n\t\r\n\tSocketParams *pParams = (SocketParams*)pParam;\r\n\r\n\tCServer Server;\r\n\tServer.RunThread(pParams);\r\n\r\n\tdelete pParams;\r\n\r\n\tLogSendRecieveInfo(\"*********************End of ClientThread*********************\");\r\n\t\r\n\treturn 0;\r\n}\r\n\r\nCServer::CServer()\r\n{\r\n\tm_pClipList = NULL;\r\n\tm_pClip = NULL;\r\n\tm_bSetToClipBoard = FALSE;\r\n\tm_manualSend = false;\r\n\tm_respondPort = 0;\r\n}\r\n\r\nCServer::~CServer()\r\n{\r\n\tclosesocket(m_Sock.GetSocket());\r\n}\r\n\r\nvoid CServer::RunThread(SocketParams *pParams)\r\n{\r\n\tm_Sock.SetSocket(pParams->m_socket);\t\r\n\tm_recieveIP = pParams->m_ip;\r\n\tCSendInfo info;\r\n\tbool bBreak = false;\r\n\t\t\r\n\twhile(true)\r\n\t{\r\n\t\tif(m_Sock.RecieveCSendInfo(&info) == FALSE)\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tswitch(info.m_Type)\r\n\t\t{\r\n\t\tcase MyEnums::START:\r\n\t\t\tOnStart(info);\r\n\t\t\tbreak;\r\n\r\n\t\tcase MyEnums::DATA_START:\r\n\t\t\tOnDataStart(info);\r\n\t\t\tbreak;\r\n\r\n\t\tcase MyEnums::DATA_END:\r\n\t\t\tOnDataEnd(info);\r\n\t\t\tbreak;\r\n\r\n\t\tcase MyEnums::END:\r\n\t\t\tOnEnd(info);\r\n\t\t\tbreak;\r\n\r\n\t\tcase MyEnums::EXIT:\r\n\t\t\tOnExit(info);\r\n\t\t\tbBreak = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase MyEnums::REQUEST_FILES:\r\n\t\t\tOnRequestFiles(info);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tLogSendRecieveInfo(\"::ERROR unknown action type exiting\");\r\n\t\t\tbBreak = true;\r\n\t\t}\r\n\r\n\t\tif(bBreak || theApp.m_bAppExiting)\r\n\t\t\tbreak;\r\n\t}\t\t\r\n\r\n\tif(m_pClipList)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"::ERROR pClipList was not NULL something is wrong\");\r\n\r\n\t\tdelete m_pClipList;\r\n\t\tm_pClipList = NULL;\t\t\r\n\t}\r\n\r\n\tif(m_pClip)\r\n\t{\r\n\t\tLogSendRecieveInfo(\"::ERROR pClip was not NULL something is wrong\");\r\n\r\n\t\tdelete m_pClip;\r\n\t\tm_pClip = NULL;\r\n\t}\r\n}\r\n\r\nvoid CServer::OnStart(CSendInfo &info)\r\n{\r\n\tif (m_recieveIP != _T(\"\") &&\r\n\t\tCGetSetOptions::GetUseIPFromAccept())\r\n\t{\r\n\t\tLogSendRecieveInfo(StrF(_T(\"Using ip address from the Accept Call - %s\"), m_recieveIP));\r\n\t\tm_csIP = m_recieveIP;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_csIP = CTextConvert::Utf8ToUnicode(info.m_cIP);\r\n\t}\r\n\tm_csComputerName = CTextConvert::Utf8ToUnicode(info.m_cComputerName);\r\n\tm_csDesc = CTextConvert::Utf8ToUnicode(info.m_cDesc);\r\n\r\n\tm_manualSend = info.m_manualSend;\r\n\tm_respondPort = info.m_respondPort;\r\n\r\n\tif(m_pClip != NULL)\r\n\t{\r\n\t\tdelete m_pClip;\r\n\t\tm_pClip = NULL;\r\n\t}\r\n\t\r\n\tm_pClip = new CClip;\r\n\t\r\n\tCString cs;\r\n\tcs.Format(_T(\"%s\\n(%s)(%s)\"), m_csDesc, m_csComputerName, m_csIP);\r\n\t\r\n\tif(m_pClip)\r\n\t{\r\n\t\tm_pClip->m_Desc = cs;\r\n\t}\r\n\t\r\n\tm_bSetToClipBoard = FALSE;\r\n\r\n\tCTokenizer token(CGetSetOptions::m_csIPListToPutOnClipboard, \",\");\r\n\tCString line;\r\n\r\n\twhile(token.Next(line))\r\n\t{\r\n\t\tif(line != \"\")\r\n\t\t{\r\n\t\t\tif(CWildCardMatch::WildMatch(line, m_csIP, \"\"))\r\n\t\t\t{\r\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Found ip match, placing on clipboard Found Match %s - %s\"), line, m_csIP));\r\n\r\n\t\t\t\tm_bSetToClipBoard = TRUE;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif(CWildCardMatch::WildMatch(line, m_csComputerName, \"\"))\r\n\t\t\t{\r\n\t\t\t\tLogSendRecieveInfo(StrF(_T(\"Found machine match, placing on clipboard Found Match %s - %s\"), line, m_csIP));\r\n\r\n\t\t\t\tm_bSetToClipBoard = TRUE;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tinfo.m_cDesc[20] = 0;\r\n\tLogSendRecieveInfo(StrF(_T(\"::START %s %s %s\"), m_csDesc, m_csComputerName, m_csIP));\r\n}\r\n\r\nvoid CServer::OnDataStart(CSendInfo &info)\r\n{\r\n\tLogSendRecieveInfo(\"::DATA_START -- START\");\r\n\r\n\tCString csFormat = CTextConvert::Utf8ToUnicode(info.m_cDesc);\r\n\tm_cf.m_cfType = GetFormatID(csFormat);\r\n\tm_cf.m_hgData = 0;\r\n\t\r\n\tlong lInSize = info.m_lParameter1;\r\n\tlong lOutSize = 0;\r\n\r\n\tLPVOID lpData = m_Sock.ReceiveEncryptedData(lInSize, lOutSize);\r\n\r\n\tif(lpData && lOutSize > 0)\r\n\t{\t\t\t\t\t\r\n\t\tm_cf.m_hgData = NewGlobal(lOutSize);\r\n\r\n\t\tif(m_cf.m_hgData)\r\n\t\t{\r\n\t\t\tif(m_pClip)\r\n\t\t\t{\r\n\t\t\t\tm_pClip->m_lTotalCopySize += lOutSize;\r\n\t\t\t}\r\n\r\n\t\t\tLPVOID pvData = GlobalLock(m_cf.m_hgData);\r\n\t\t\tif(pvData)\r\n\t\t\t{\r\n\t\t\t\tmemcpy(pvData, lpData, lOutSize);\r\n\r\n\t\t\t\tGlobalUnlock(m_cf.m_hgData);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tLogSendRecieveInfo(\"::DATA_START -- failed to lock hGlobal\");\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLogSendRecieveInfo(\"::DATA_START -- failed to create new hGlobal\");\r\n\t\t}\r\n\r\n\t\tm_Sock.FreeDecryptedData();\r\n\t}\r\n\r\n\tLogSendRecieveInfo(\"::DATA_START -- END\");\r\n}\r\n\r\nvoid CServer::OnDataEnd(CSendInfo &info)\r\n{\r\n\tLogSendRecieveInfo(\"::DATA_END\");\r\n\t\t\t\t\r\n\tif(m_pClip && m_cf.m_hgData)\r\n\t{\r\n\t\tif(m_cf.m_cfType == CF_HDROP)\r\n\t\t\tAddRemoteCF_HDROPFormat();\r\n\r\n\t\tm_pClip->m_Formats.Add(m_cf);\r\n\t\tm_cf.m_hgData = 0; // now owned by pClip\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLogSendRecieveInfo(\"MyEnums::DATA_END Error if(pClip && cf.m_hgData)\");\r\n\t}\r\n}\r\n\r\nvoid CServer::OnEnd(CSendInfo &info)\r\n{\t\t\t\t\r\n\tLogSendRecieveInfo(\"::END\");\r\n\r\n\tif(m_pClipList == NULL)\r\n\t\tm_pClipList = new CClipList;\r\n\r\n\tif(m_pClipList)\r\n\t{\r\n\t\tm_pClipList->AddTail(m_pClip);\r\n\t\tm_pClip = NULL;  //clip list now owns the clip\r\n\t}\r\n\telse\r\n\t\tLogSendRecieveInfo(\"::ERROR pClipList was NULL\");\r\n}\r\n\r\nvoid CServer::OnExit(CSendInfo &info)\r\n{\r\n\tLogSendRecieveInfo(\"::EXIT\");\r\n\r\n\tif(m_pClipList && m_pClipList->GetCount() > 0)\r\n\t{\r\n\t\ttheApp.m_lClipsRecieved += (long)m_pClipList->GetCount();\r\n\r\n\t\tDWORD flags = 0;\r\n\t\tif (m_bSetToClipBoard)\r\n\t\t{\r\n\t\t\tflags |= REMOTE_CLIP_ADD_TO_CLIPBOARD;\r\n\t\t}\r\n\t\tif (m_manualSend)\r\n\t\t{\r\n\t\t\tflags |= REMOTE_CLIP_MANUAL_SEND;\r\n\t\t}\r\n\r\n\t\t//Post a message pClipList will be freed by the reciever\r\n\t\t::PostMessage(theApp.m_MainhWnd, WM_ADD_TO_DATABASE_FROM_SOCKET, (WPARAM)m_pClipList, flags);\r\n\t\tm_pClipList = NULL;\r\n\t}\r\n\telse\r\n\t\tLogSendRecieveInfo(\"::ERROR pClipList was NULL or Count was 0\");\r\n}\r\n\r\nvoid CServer::OnRequestFiles(CSendInfo &info)\r\n{\r\n\tCFileSend Send;\r\n\tSend.SendClientFiles(m_Sock.GetSocket(), m_pClipList);\r\n\r\n\tdelete m_pClipList;\r\n\tm_pClipList = NULL;\r\n}\r\n\r\nvoid CServer::AddRemoteCF_HDROPFormat()\r\n{\r\n\tCClipFormat cf;\r\n\r\n\tCDittoCF_HDROP Drop;\r\n\r\n\tDrop.respondPort = m_respondPort;\r\n\r\n\tCTextConvert Convert;\r\n\r\n\tCStringA dest = CTextConvert::UnicodeToUTF8(m_csIP);\r\n\tstrncpy(Drop.m_cIP, dest, sizeof(Drop.m_cIP)-1);\r\n\t\r\n\tdest = CTextConvert::UnicodeToUTF8(m_csComputerName);\r\n\tstrncpy(Drop.m_cComputerName, dest, sizeof(Drop.m_cComputerName)-1);\r\n\t\r\n\tcf.m_hgData = NewGlobalP(&Drop, sizeof(Drop));\r\n\tcf.m_cfType = theApp.m_RemoteCF_HDROP;\r\n\r\n\tm_pClip->m_Formats.Add(cf);\r\n\r\n\t//m_pClip->m_Formats now owns the data\r\n\tcf.m_hgData = NULL;\r\n}\r\n\r\n"
        },
        {
          "name": "Server.h",
          "type": "blob",
          "size": 0.9169921875,
          "content": "#pragma once\n\n#include \"Winsock2.h\"\n#include \"EncryptDecrypt\\Encryption.h\"\n#include \"shared/TextConvert.h\"\n#include \"RecieveSocket.h\"\n#include \"FileSend.h\"\n#include \"ServerDefines.h\"\n\n\nclass SocketParams\n{\npublic:\n\tSOCKET m_socket;\n\tCString m_ip;\n};\n\nclass CServer\n{\npublic:\n\tCServer();\n\t~CServer();\n\n\tvoid RunThread(SocketParams *pParams);\n\nprotected:\n\tvoid AddRemoteCF_HDROPFormat();\n\n\tvoid OnStart(CSendInfo &Info);\n\tvoid OnDataEnd(CSendInfo &info);\n\tvoid OnDataStart(CSendInfo &info);\n\tvoid OnEnd(CSendInfo &info);\n\tvoid OnExit(CSendInfo &info);\n\tvoid OnRequestFiles(CSendInfo &info);\n\nprotected:\n\tCClipList *m_pClipList;\n\tCClip *m_pClip;\n\tCTextConvert m_Convert;\n\tBOOL m_bSetToClipBoard;\n\tCString m_csIP;\n\tbool m_manualSend;\n\tshort m_respondPort;\n\tCString m_csComputerName;\n\tCString m_csDesc;\n\tCRecieveSocket m_Sock;\n\tCClipFormat m_cf;\n\tCString m_recieveIP;\n};\n\nUINT  MTServerThread(LPVOID pParam);\nUINT  ClientThread(LPVOID pParam);\n"
        },
        {
          "name": "ServerDefines.h",
          "type": "blob",
          "size": 0.9072265625,
          "content": "#pragma once\n\n\n#define CHUNK_WRITE_SIZE 65536\n\nclass MyEnums\n{\npublic:\n\tenum eSendType{START, DATA, DATA_START, DATA_END, END, EXIT, REQUEST_FILES};\n};\n\nclass CSendInfo\n{\npublic:\n\tCSendInfo()\n\t{\n\t\tmemset(this, 0, sizeof(*this));\n\t\tm_nSize = sizeof(CSendInfo);\n\t\tm_nVersion = 1;\n\t\tm_lParameter1 = -1;\n\t\tm_lParameter2 = -1;\n\t\tm_manualSend = 0;\n\t\tm_respondPort = 0;\n\t}\n\tint\t\t\t\t\tm_nSize;\n\tMyEnums::eSendType\tm_Type;\n\tint\t\t\t\t\tm_nVersion;\n\tCHAR\t\t\t\tm_cIP[20];\n\tCHAR\t\t\t\tm_cComputerName[MAX_COMPUTERNAME_LENGTH + 1];\n\tCHAR\t\t\t\tm_cDesc[250];\n\tlong\t\t\t\tm_lParameter1;\n\tlong\t\t\t\tm_lParameter2;\n\tCHAR\t\t\t\tm_md5[32];\n\tchar\t\t\t\tm_manualSend;\n\tshort\t\t\t\tm_respondPort;\n\tchar\t\t\t\tm_cExtra[15];\n};\n\nclass CDittoCF_HDROP\n{\npublic:\n\tCDittoCF_HDROP()\n\t{\n\t\tmemset(m_cIP, 0, sizeof(m_cIP));\n\t\tmemset(m_cComputerName, 0, sizeof(m_cComputerName));\n\t\trespondPort = 0;\n\t}\n\tchar m_cIP[25];\n\tchar m_cComputerName[MAX_COMPUTERNAME_LENGTH + 1];\n\tshort respondPort;\n};"
        },
        {
          "name": "Shared",
          "type": "tree",
          "content": null
        },
        {
          "name": "ShowTaskBarIcon.cpp",
          "type": "blob",
          "size": 0.548828125,
          "content": "#include \"stdafx.h\"\r\n#include \"ShowTaskBarIcon.h\"\r\n#include \"CP_Main.h\"\r\n\r\nvolatile long CShowTaskBarIcon::m_refCount = 0;\r\n\r\nCShowTaskBarIcon::CShowTaskBarIcon(void)\r\n{\r\n\ttheApp.m_pMainFrame->m_trayIcon.MaximiseFromTray(theApp.m_pMainFrame);\r\n\tm_hWnd = theApp.m_pMainFrame->GetSafeHwnd();\r\n\t::InterlockedIncrement(&m_refCount);\r\n}\r\n\r\n\r\nCShowTaskBarIcon::~CShowTaskBarIcon(void)\r\n{\r\n\t::InterlockedDecrement(&m_refCount);\r\n\r\n\tif(m_hWnd && ::IsWindow(m_hWnd) && m_refCount == 0)\r\n\t{\r\n\t\ttheApp.m_pMainFrame->m_trayIcon.MinimiseToTray(theApp.m_pMainFrame);\r\n\t}\t\r\n}\r\n"
        },
        {
          "name": "ShowTaskBarIcon.h",
          "type": "blob",
          "size": 0.1572265625,
          "content": "#pragma once\r\nclass CShowTaskBarIcon\r\n{\r\npublic:\r\n\tCShowTaskBarIcon(void);\r\n\t~CShowTaskBarIcon(void);\r\n\r\n\tHWND m_hWnd;\r\n\tstatic volatile long m_refCount;\r\n};\r\n\r\n"
        },
        {
          "name": "SimpleBrowser.cpp",
          "type": "blob",
          "size": 27.6220703125,
          "content": "/////////////////////////////////////////////////////////////////////////////\r\n// SimpleBrowser.cpp: Web browser control\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n#include \"stdafx.h\"\r\n#include \"comdef.h\"\r\n#include \"mshtml.h\"\r\n#include \"mshtmcid.h\"\r\n#include \"mshtmhst.h\"\r\n#include \"exdispid.h\"\r\n\r\n#include \"SimpleBrowser.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n#define Unused(parameter) parameter\t\t\t\t\t// avoid compile warnings\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// about unused parameters\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Construction and creation\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\nSimpleBrowser::SimpleBrowser()\r\n\t:\t_Browser(NULL),\r\n\t\t_BrowserDispatch(NULL),\r\n\t\t_Ready(false),\r\n\t\t_Content(_T(\"\"))\r\n{\r\n}\r\n\r\nSimpleBrowser::~SimpleBrowser()\r\n{\r\n    // release browser interfaces\r\n\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->Release();\r\n\t\t_Browser = NULL;\r\n\t}\r\n\r\n\tif (_BrowserDispatch != NULL) {\r\n\t\t_BrowserDispatch->Release();\r\n\t\t_BrowserDispatch = NULL;\r\n\t}\r\n}\r\n\r\n// Standard create\r\n\r\nBOOL SimpleBrowser::Create(DWORD dwStyle, \r\n                           const RECT& rect, \r\n                           CWnd* pParentWnd, \r\n\t\t\t\t\t\t   UINT nID)\r\n{\r\n    BOOL results = TRUE;\r\n\r\n\t_Ready      = false;\r\n\t\r\n    _Browser\t= NULL;\r\n\r\n    // create this window\r\n\r\n    CWnd *window = this;\r\n\tresults = window->Create(AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW),\r\n\t                         NULL,\r\n\t\t\t\t\t\t\t dwStyle,\r\n\t\t\t\t\t\t\t rect,\r\n\t\t\t\t\t\t\t pParentWnd,\r\n\t\t\t\t\t\t\t nID);\r\n    if (!results) return FALSE;\r\n\r\n    // create browser control window as child of this window; \r\n\t// this window sinks events from control\r\n\r\n\tCRect browser_window_rect(0,0,(rect.right - rect.left),(rect.bottom - rect.top));\r\n\r\n    results = _BrowserWindow.CreateControl(CLSID_WebBrowser,\r\n                                           NULL,\r\n                                           (WS_VISIBLE | WS_TABSTOP),\r\n                                           browser_window_rect,\r\n                                           this,\r\n                                           AFX_IDW_PANE_FIRST);\r\n    if (!results) {\r\n        DestroyWindow();\r\n        return FALSE;\r\n    }\r\n\r\n    // get control interfaces\r\n\r\n    LPUNKNOWN unknown = _BrowserWindow.GetControlUnknown();\r\n\r\n    HRESULT hr = unknown->QueryInterface(IID_IWebBrowser2,(void **)&_Browser);\r\n    if (SUCCEEDED(hr)) {\r\n        hr = unknown->QueryInterface(IID_IDispatch,(void **)&_BrowserDispatch);\r\n    }\r\n\r\n    if (!SUCCEEDED(hr)) {\r\n        _BrowserWindow.DestroyWindow();\r\n        DestroyWindow();\r\n        return FALSE;        \r\n    }\r\n\r\n\t// navigate to initial blank page\r\n\r\n\tif (_Browser != NULL) {\r\n\t\tNavigate(_T(\"about:blank\"));\r\n\t}\r\n\r\n    return TRUE;\r\n}\r\n\r\n// Create in place of dialog control\r\n\r\nBOOL SimpleBrowser::CreateFromControl(CWnd *pParentWnd,UINT nID,DWORD dwStyle)\r\n{\r\n\tBOOL result = FALSE;\r\n\r\n\tASSERT(pParentWnd != NULL);\r\n\r\n\tCWnd *control = pParentWnd->GetDlgItem(nID);\r\n\r\n\tif (control != NULL) {\r\n\r\n\t\t// get control location\r\n\r\n\t\tCRect\t\trect;\r\n\r\n\t\tcontrol->GetWindowRect(&rect);\r\n\t\tpParentWnd->ScreenToClient(&rect);\r\n\r\n\t\t// destroy control, since the browser will take its place\r\n\r\n\t\tcontrol->DestroyWindow();\r\n\r\n\t\t// create browser\r\n\r\n\t\tresult = Create(dwStyle,\r\n\t\t                rect,\r\n\t\t\t\t\t\tpParentWnd,\r\n\t\t\t\t\t\tnID);\r\n\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n// Destruction\r\n\r\nvoid SimpleBrowser::PostNcDestroy()\r\n{\r\n    // release browser interfaces\r\n\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->Release();\r\n\t\t_Browser = NULL;\r\n\t}\r\n\r\n\tif (_BrowserDispatch != NULL) {\r\n\t\t_BrowserDispatch->Release();\r\n\t\t_BrowserDispatch = NULL;\r\n\t}\r\n\t\r\n\t_Ready\t\t= false;\r\n\t_Content\t= _T(\"\");\r\n\t\r\n\tCWnd::PostNcDestroy();\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Controls\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n// Navigate to URL\r\n\r\nvoid SimpleBrowser::Copy()\r\n{\r\n\tif (_Browser != NULL) {\t\t\r\n\r\n\t\t_Browser->ExecWB(OLECMDID_COPY, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);\r\n\r\n\t}\r\n\r\n}\r\n\r\nvoid SimpleBrowser::Navigate(LPCTSTR URL)\r\n{\r\n\t_Ready   = false;\r\n\t_Content = _T(\"\");\r\n\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tCString\t\turl(URL);\r\n\r\n\t\t_variant_t\tflags(0L,VT_I4);\r\n\t\t_variant_t\ttarget_frame_name(\"\");\r\n\t\t_variant_t\tpost_data(\"\");\r\n\t\t_variant_t\theaders(\"\");\r\n\r\n\t\t_Browser->Navigate(url.AllocSysString(),\r\n\t\t\t\t\t\t   &flags,\r\n\t\t\t\t\t\t   &target_frame_name,\r\n\t\t\t\t\t\t   &post_data,\r\n\t\t\t\t\t\t   &headers);\r\n\r\n\t}\r\n}\r\n\r\n// Navigate to HTML document in resource\r\n\r\nvoid SimpleBrowser::NavigateResource(int resource_ID)\r\n{\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tCString resource_string;\r\n\r\n\t\t// load HTML document from resource\r\n\r\n\t\tHRSRC resource_handle = FindResource(AfxGetResourceHandle(),\r\n\t\t\t\t\t\t\t\t\t\t\t MAKEINTRESOURCE(resource_ID),\r\n\t\t\t\t\t\t\t\t\t\t\t RT_HTML);\r\n\r\n\t\tif (resource_handle != NULL) {\r\n\r\n\t\t\tHGLOBAL resource = LoadResource(AfxGetResourceHandle(),\r\n\t\t\t\t\t\t\t\t\t\t\tresource_handle);\r\n\r\n\t\t\tif (resource != NULL) {\r\n\r\n\t\t\t\tLPVOID resource_memory = LockResource(resource);\r\n\r\n\t\t\t\tif (resource_memory != NULL) {\r\n\r\n\t\t\t\t\tDWORD resource_size = SizeofResource(AfxGetResourceHandle(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t resource_handle);\r\n\r\n\t\t\t\t\t// identify the resource document as MBCS (e.g. ANSI)\r\n\t\t\t\t\t// or UNICODE\r\n\r\n\t\t\t\t\tbool     UNICODE_document = false;\r\n\r\n\t\t\t\t\twchar_t *UNICODE_memory   = (wchar_t *)resource_memory;\r\n\t\t\t\t\tint      UNICODE_size     = resource_size / sizeof(wchar_t);\r\n\r\n\t\t\t\t\tif (UNICODE_size >= 1) {\r\n\r\n\t\t\t\t\t\t// check for UNICODE byte order mark\r\n\r\n\t\t\t\t\t\tif (*UNICODE_memory == L'\\xFEFF') {\r\n\t\t\t\t\t\t\tUNICODE_document = true;\r\n\t\t\t\t\t\t\tUNICODE_memory  += 1;\r\n\t\t\t\t\t\t\tUNICODE_size    -= 1;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// otherwise, check for UNICODE leading tag\r\n\r\n\t\t\t\t\t\telse if (UNICODE_size >= 5) {\r\n\r\n\t\t\t\t\t\t\tif ((UNICODE_memory[0]           == L'<') &&\r\n\t\t\t\t\t\t\t    (towupper(UNICODE_memory[1]) == L'H') &&\r\n\t\t\t\t\t\t\t    (towupper(UNICODE_memory[2]) == L'T') &&\r\n\t\t\t\t\t\t\t    (towupper(UNICODE_memory[3]) == L'M') &&\r\n\t\t\t\t\t\t\t    (towupper(UNICODE_memory[4]) == L'L')) {\r\n\t\t\t\t\t\t\t\tUNICODE_document = true;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Note: This logic assumes that the UNICODE resource document is \r\n\t\t\t\t\t\t//       in little-endian byte order, which would be typical for \r\n\t\t\t\t\t\t//       any HTML document used as a resource in a Windows application.\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// convert resource document if required\r\n\r\n#if !defined(UNICODE)\r\n\r\n\t\t\t\t\tif (UNICODE_document) {\r\n\r\n\t\t\t\t\t\tchar *MBCS_buffer = resource_string.GetBufferSetLength(resource_size + 1);\r\n\r\n\t\t\t\t\t\tint MBCS_length = ::WideCharToMultiByte(CP_ACP,\r\n\t\t\t\t\t\t                                        0,\r\n\t\t\t\t\t\t\t\t\t\t\t                    UNICODE_memory,\r\n\t\t\t\t\t\t\t\t\t\t\t                    UNICODE_size,\r\n\t\t\t\t\t\t\t\t\t\t\t                    MBCS_buffer,\r\n\t\t\t\t\t\t\t\t\t\t\t                    resource_size + 1,\r\n\t\t\t\t\t\t\t\t\t\t\t                    NULL,\r\n\t\t\t\t\t\t\t\t\t\t\t                    NULL);\r\n\r\n\t\t\t\t\t\tresource_string.ReleaseBuffer(MBCS_length);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\tresource_string = CString((char *)resource_memory,resource_size);\r\n\r\n\t\t\t\t\t}\r\n\r\n#else\r\n\r\n\t\t\t\t\tif (UNICODE_document) {\r\n\r\n\t\t\t\t\t\tresource_string = CString(UNICODE_memory,UNICODE_size);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\twchar_t *UNICODE_buffer = resource_string.GetBufferSetLength(resource_size + 1);\r\n\r\n\t\t\t\t\t\tint UNICODE_length = ::MultiByteToWideChar(CP_ACP,\r\n\t\t\t\t\t\t                                           0,\r\n\t\t\t\t\t\t\t\t\t\t\t                       (const char *)resource_memory,\r\n\t\t\t\t\t\t\t\t\t\t\t                       resource_size,\r\n\t\t\t\t\t\t\t\t\t\t\t                       UNICODE_buffer,\r\n\t\t\t\t\t\t\t\t\t\t\t                       (resource_size + 1));\r\n\r\n\t\t\t\t\t\tresource_string.ReleaseBuffer(UNICODE_length);\r\n\r\n\t\t\t\t\t}\r\n\r\n#endif\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tClear();\r\n\t\tWrite(resource_string);\r\n\r\n\t}\r\n}\r\n\r\n// Append string to current document\r\n\r\nvoid SimpleBrowser::Write(LPCTSTR string)\r\n{\r\n\tif (_Browser != NULL) {\r\n\r\n\t\t_Content.Append(string);\r\n\t\t\r\n\t\t_ContentWrite();\r\n\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::Clear()\r\n{\r\n\tif (_Browser != NULL) {\r\n\r\n\t\t_Content = _T(\"\");\r\n\r\n\t\t// get document interface\r\n\r\n\t\tIHTMLDocument2\t*document\t= GetDocument();\r\n\t\tHRESULT\t\t\thr\t\t\t= S_OK;\r\n\t\t\r\n\t\tif (document != NULL) {\r\n\r\n\t\t\t// close and re-open document to empty contents\r\n\r\n\t\t\tdocument->close();\r\n\t\t\t\r\n\t\t\tVARIANT\t\topen_name;\r\n\t\t\tVARIANT\t\topen_features;\r\n\t\t\tVARIANT\t\topen_replace;\r\n\t\t\tIDispatch\t*open_window\t= NULL;\r\n\r\n\t\t\t::VariantInit(&open_name);\r\n\r\n\t\t\topen_name.vt      = VT_BSTR;\r\n\t\t\topen_name.bstrVal = ::SysAllocString(L\"_self\");\r\n\r\n\t\t\t::VariantInit(&open_features);\r\n\t\t\t::VariantInit(&open_replace);\r\n\t\t\t\r\n\t\t\thr = document->open(::SysAllocString(L\"text/html\"),\r\n\t\t\t                    open_name,\r\n\t\t\t                    open_features,\r\n\t\t\t                    open_replace,\r\n\t\t\t                    &open_window);\r\n\r\n\t\t\tif (hr == S_OK) {\r\n\t\t\t\tRefresh();\r\n\t\t\t}\r\n\r\n\t\t\tif (open_window != NULL) {\r\n\t\t\t\topen_window->Release();\r\n\t\t\t}\r\n\r\n\t\t\t::VariantClear(&open_name);\r\n\t\t\t\r\n\t\t\tdocument->Release();\r\n\t\t\tdocument = NULL;\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse {\r\n\r\n\t\t\tNavigate(_T(\"about:blank\"));\r\n\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Navigation operations\r\n\r\nvoid SimpleBrowser::GoBack()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->GoBack();\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::GoForward()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->GoForward();\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::GoHome()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->GoHome();\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::Refresh()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->Refresh();\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::Stop()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->Stop();\r\n\t}\r\n}\r\n\r\n// Print contents\r\n\r\nvoid SimpleBrowser::Print(LPCTSTR header,LPCTSTR footer)\r\n{\r\n\tif (_Browser != NULL) {\r\n\r\n\t\t// construct two element SAFEARRAY;\r\n\t\t// first element is header string, second element is footer string\r\n\r\n\t\tHRESULT hr;\r\n\r\n\t\tVARIANT\t\theader_variant;\r\n\t\tVariantInit(&header_variant);\r\n\t\tV_VT(&header_variant)   = VT_BSTR;\r\n\t\tV_BSTR(&header_variant) = CString(header).AllocSysString();\r\n\r\n\t\tVARIANT\t\tfooter_variant;\r\n\t\tVariantInit(&footer_variant);\r\n\t\tV_VT(&footer_variant)   = VT_BSTR;\r\n\t\tV_BSTR(&footer_variant) = CString(footer).AllocSysString();\r\n\r\n\t\tlong index;\r\n\r\n\t\tSAFEARRAYBOUND\tparameter_array_bound[1];\r\n\t\tSAFEARRAY\t\t*parameter_array = NULL;\r\n\r\n\t\tparameter_array_bound[0].cElements = 2;\r\n\t\tparameter_array_bound[0].lLbound   = 0;\r\n\r\n\t\tparameter_array = SafeArrayCreate(VT_VARIANT,1,parameter_array_bound);\r\n\r\n\t\tindex = 0;\r\n\t\thr    = SafeArrayPutElement(parameter_array,&index,&header_variant);\r\n\r\n\t\tindex = 1;\r\n\t\thr    = SafeArrayPutElement(parameter_array,&index,&footer_variant);\r\n\r\n\t\tVARIANT\tparameter;\r\n\t\tVariantInit(&parameter);\r\n\t\tV_VT(&parameter)    = VT_ARRAY | VT_BYREF;\r\n\t\tV_ARRAY(&parameter) = parameter_array;\r\n\r\n\t\t// start printing browser contents\r\n\r\n\t\thr = _Browser->ExecWB(OLECMDID_PRINT,OLECMDEXECOPT_DODEFAULT,&parameter,NULL);\r\n\r\n\t\t// release SAFEARRAY\r\n\r\n\t\tif (!SUCCEEDED(hr)) {\r\n\t\t\tVariantClear(&header_variant);\r\n\t\t\tVariantClear(&footer_variant);\r\n\t\t\tif (parameter_array != NULL) {\r\n\t\t\t\tSafeArrayDestroy(parameter_array);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::PrintPreview()\r\n{\r\n\tif (_Browser != NULL) {\r\n\t\t_Browser->ExecWB(OLECMDID_PRINTPREVIEW,OLECMDEXECOPT_DODEFAULT,NULL,NULL);\r\n\t}\r\n}\r\n\r\n// Miscellaneous\r\n\r\nbool SimpleBrowser::GetBusy()\r\n{\r\n    bool busy = false;\r\n\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tVARIANT_BOOL    variant_bool;\r\n\r\n\t\tHRESULT hr = _Browser->get_Busy(&variant_bool);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tbusy = (variant_bool == VARIANT_TRUE);    \r\n\t\t}\r\n\r\n\t}\r\n\r\n    return busy;\r\n}\r\n\r\nCString SimpleBrowser::GetLocationName()\r\n{\r\n    CString location_name = _T(\"\");\r\n\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tBSTR location_name_BSTR = NULL;\r\n\r\n\t\tHRESULT hr = _Browser->get_LocationName(&location_name_BSTR);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tlocation_name = location_name_BSTR;\r\n\t\t}\r\n\r\n\t\t::SysFreeString(location_name_BSTR);\r\n\r\n\t}\r\n\r\n    return location_name;\r\n}\r\n\r\nCString SimpleBrowser::GetLocationURL()\r\n{\r\n    CString location_URL = _T(\"\");\r\n\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tBSTR location_URL_BSTR = NULL;\r\n\r\n\t\tHRESULT hr = _Browser->get_LocationURL(&location_URL_BSTR);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tlocation_URL = location_URL_BSTR;\r\n\t\t}\r\n\r\n\t\t::SysFreeString(location_URL_BSTR);\r\n\r\n\t}\r\n\r\n    return location_URL;\r\n}\r\n\r\nREADYSTATE SimpleBrowser::GetReadyState()\r\n{\r\n    READYSTATE readystate = READYSTATE_UNINITIALIZED;\r\n\r\n    if (_Browser != NULL) {\r\n\t\t_Browser->get_ReadyState(&readystate);\r\n\t}\r\n\r\n    return readystate;\r\n}\r\n\r\nbool SimpleBrowser::GetSilent()\r\n{\r\n    bool silent = false;\r\n\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tVARIANT_BOOL silent_variant;\r\n\r\n\t\tHRESULT hr = _Browser->get_Silent(&silent_variant);\r\n\t\tif (SUCCEEDED(hr)) {\r\n\t\t\tsilent = (silent_variant == VARIANT_TRUE);\r\n\t\t}\r\n\r\n\t}\r\n\r\n    return silent;\r\n}\r\n\r\nvoid SimpleBrowser::PutSilent(bool silent)\r\n{\r\n\tif (_Browser != NULL) {\r\n\r\n\t\tVARIANT_BOOL silent_variant;\r\n\r\n\t\tif (silent) silent_variant = VARIANT_TRUE;\r\n\t\telse        silent_variant = VARIANT_FALSE;\r\n\r\n\t\t_Browser->put_Silent(silent_variant);\r\n\t}\r\n}\r\n\r\nIHTMLDocument2 *SimpleBrowser::GetDocument()\r\n{\r\n\tIHTMLDocument2 *document = NULL;\r\n\t\r\n\tif (_Browser != NULL) {\r\n\t\r\n\t\t// get browser document's dispatch interface\r\n\r\n\t\tIDispatch *document_dispatch = NULL;\r\n\r\n\t\tHRESULT hr = _Browser->get_Document(&document_dispatch);\r\n\r\n\t\tif (SUCCEEDED(hr) && (document_dispatch != NULL)) {\r\n\r\n\t\t\t// get the actual document interface\r\n\r\n\t\t\thr = document_dispatch->QueryInterface(IID_IHTMLDocument2,\r\n\t\t\t                                       (void **)&document);\r\n\r\n\t\t\t// release dispatch interface\r\n\t\t\t\t\t\r\n\t\t\tdocument_dispatch->Release();\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\treturn document;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Message handlers\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\nBEGIN_MESSAGE_MAP(SimpleBrowser,CWnd)\r\n    //{{AFX_MSG_MAP(SimpleBrowser)\r\n\tON_WM_SIZE()\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\nBOOL SimpleBrowser::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\tBOOL result = FALSE;\r\n\r\n\t// translate keys correctly, especially Tab, Del, (Enter?)\r\n\t\r\n\tif (_Browser != NULL) {\r\n\t\r\n\t\tIOleInPlaceActiveObject* OleInPlaceActiveObject = NULL;\r\n\r\n\t\tHRESULT hr = _Browser->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&OleInPlaceActiveObject);\r\n\r\n\t\tif (SUCCEEDED(hr) && (OleInPlaceActiveObject != NULL)) {\r\n\r\n\t\t\thr = OleInPlaceActiveObject->TranslateAccelerator(pMsg);\r\n\t\t\tresult = (hr == S_OK ? TRUE : FALSE);\r\n\r\n\t\t\tOleInPlaceActiveObject->Release();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\telse {\r\n\t\tresult = CWnd::PreTranslateMessage(pMsg);\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n// Resize control window as this window is resized\r\n\r\nvoid SimpleBrowser::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCWnd::OnSize(nType, cx, cy);\r\n\r\n\tif (_Browser != NULL) {\r\n        CRect rect(0,0,cx,cy);\t\r\n\t\t_BrowserWindow.MoveWindow(&rect);\r\n\t}\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Event handlers\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef DISPID_PRINTTEMPLATEINSTANTIATION\r\n\t#define DISPID_PRINTTEMPLATEINSTANTIATION 225\r\n#endif\r\n#ifndef DISPID_PRINTTEMPLATETEARDOWN\r\n\t#define DISPID_PRINTTEMPLATETEARDOWN 226\r\n#endif\r\n\r\nBEGIN_EVENTSINK_MAP(SimpleBrowser,CWnd)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_BEFORENAVIGATE2,\r\n             _OnBeforeNavigate2, \r\n\t\t\t VTS_DISPATCH VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PBOOL)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_DOCUMENTCOMPLETE,\r\n             _OnDocumentComplete, \r\n\t\t\t VTS_DISPATCH VTS_PVARIANT)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_DOWNLOADBEGIN,\r\n             _OnDownloadBegin, \r\n\t\t\t VTS_NONE)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_PROGRESSCHANGE,\r\n             _OnProgressChange, \r\n\t\t\t VTS_I4 VTS_I4)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_DOWNLOADCOMPLETE,\r\n             _OnDownloadComplete, \r\n\t\t\t VTS_NONE)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_NAVIGATECOMPLETE2,\r\n             _OnNavigateComplete2, \r\n\t\t\t VTS_DISPATCH VTS_PVARIANT)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_STATUSTEXTCHANGE,\r\n             _OnStatusTextChange, \r\n\t\t\t VTS_BSTR)\r\n    ON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_TITLECHANGE,\r\n             _OnTitleChange, \r\n\t\t\t VTS_BSTR)\r\n\tON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_PRINTTEMPLATEINSTANTIATION,\r\n\t         _OnPrintTemplateInstantiation, \r\n\t         VTS_DISPATCH)\r\n\tON_EVENT(SimpleBrowser,AFX_IDW_PANE_FIRST,\r\n\t         DISPID_PRINTTEMPLATETEARDOWN,\r\n\t         _OnPrintTemplateTeardown, \r\n\t         VTS_DISPATCH)\r\nEND_EVENTSINK_MAP()\r\n\r\nSimpleBrowser::Notification::Notification(HWND hwnd,UINT ID,NotificationType type)\r\n{\r\n\thdr.hwndFrom\t= hwnd;\r\n\thdr.idFrom\t\t= ID;\r\n\thdr.code\t\t= type;\r\n\tURL\t\t\t\t= _T(\"\");\r\n\tframe\t\t\t= _T(\"\");\r\n\tpost_data\t\t= NULL;\r\n\tpost_data_size\t= 0;\r\n\theaders\t\t\t= _T(\"\");\r\n\tprogress\t\t= 0;\r\n\tprogress_max\t= 0;\r\n\ttext\t\t\t= _T(\"\");\r\n}\r\n\r\nSimpleBrowser::Notification::~Notification()\r\n{\r\n}\r\n\r\n// Called before navigation begins; application may cancel if required\r\n\r\nvoid SimpleBrowser::_OnBeforeNavigate2(LPDISPATCH lpDisp,\r\n                                       VARIANT FAR *URL,\r\n                                       VARIANT FAR *Flags,\r\n                                       VARIANT FAR *TargetFrameName,\r\n                                       VARIANT FAR *PostData,\r\n                                       VARIANT FAR *Headers,\r\n                                       VARIANT_BOOL *Cancel)\r\n{\r\n\tUnused(Flags);\t// Note: flags value is reserved\r\n\r\n    if (lpDisp == _BrowserDispatch) {\r\n\r\n\t\tCString\t\t\t\tURL_string;\r\n\t\tCString\t\t\t\tframe;\r\n\t\tunsigned char\t\t*post_data\t\t= NULL;\r\n\t\tint\t\t\t\t\tpost_data_size\t= 0;\r\n\t\tCString\t\t\t\theaders;\r\n\r\n        if ((URL       != NULL) && \r\n\t\t    (V_VT(URL) == VT_BSTR)) {\r\n            URL_string = V_BSTR(URL);\r\n        }\r\n\r\n\t\tif ((TargetFrameName       != NULL) &&\r\n            (V_VT(TargetFrameName) == VT_BSTR)) {\r\n\t\t\tframe = V_BSTR(TargetFrameName);\r\n        }\r\n\r\n\t\tif ((PostData       != NULL)                    &&\r\n\t\t    (V_VT(PostData) == (VT_VARIANT | VT_BYREF))) {\r\n\r\n\t\t\tVARIANT *PostData_variant = V_VARIANTREF(PostData);\r\n\r\n\t\t\tif ((PostData_variant       != NULL) &&\r\n\t\t\t    (V_VT(PostData_variant) != VT_EMPTY)) {\r\n\r\n\t\t\t\tSAFEARRAY *PostData_safearray = V_ARRAY(PostData_variant);\r\n\r\n\t\t\t\tif (PostData_safearray != NULL) {\r\n\r\n\t\t\t\t\tchar *post_data_array = NULL;\r\n\r\n\t\t\t\t\tSafeArrayAccessData(PostData_safearray,(void HUGEP **)&post_data_array);\r\n\r\n\t\t\t\t\tlong\t\tlower_bound = 1;\r\n\t\t\t\t\tlong\t\tupper_bound = 1;\r\n\r\n\t\t\t\t\tSafeArrayGetLBound(PostData_safearray,1,&lower_bound);\r\n\t\t\t\t\tSafeArrayGetUBound(PostData_safearray,1,&upper_bound);\r\n\r\n\t\t\t\t\tpost_data_size = (int)(upper_bound - lower_bound + 1);\r\n\r\n\t\t\t\t\tpost_data = new unsigned char[post_data_size];\r\n\r\n\t\t\t\t\tmemcpy(post_data,post_data_array,post_data_size);\r\n\r\n\t\t\t\t\tSafeArrayUnaccessData(PostData_safearray);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ((Headers       != NULL) &&\r\n            (V_VT(Headers) == VT_BSTR)) {\r\n\t\t\theaders = V_BSTR(Headers);\r\n        }\r\n\r\n\t\tbool cancel = OnBeforeNavigate2(URL_string,\r\n\t\t                                frame,\r\n\t\t\t\t\t\t\t\t\t\tpost_data,post_data_size,\r\n\t\t\t\t\t\t\t\t\t\theaders);\r\n\r\n\t\tif (Cancel != NULL) {\r\n\t\t\tif (cancel) *Cancel = VARIANT_TRUE;\r\n\t\t\telse        *Cancel = VARIANT_FALSE;\r\n\t\t}\r\n\r\n\t\tdelete []post_data;\r\n\r\n    }    \r\n}\r\n\r\nbool SimpleBrowser::OnBeforeNavigate2(CString URL,\r\n                                      CString frame,\r\n\t\t\t\t\t\t\t\t\t  void    *post_data,int post_data_size,\r\n\t\t\t\t\t\t\t\t\t  CString headers)\r\n{\r\n\tbool cancel = false;\r\n\t\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),BeforeNavigate2);\r\n\t\t\r\n\t\tnotification.URL\t\t\t= URL;\r\n\t\tnotification.frame\t\t\t= frame;\r\n\t\tnotification.post_data\t\t= post_data;\r\n\t\tnotification.post_data_size\t= post_data_size;\r\n\t\tnotification.headers\t\t= headers;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t\tif (result) {\r\n\t\t\tcancel = true;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n    return cancel;\r\n}\r\n\r\nbool SimpleBrowser::ParsePostData(CString post_data,\r\n\t                              CStringArray &names,\r\n\t                              CStringArray &values)\r\n{\r\n\tbool result = true;\r\n\t\r\n\tint size = 1;\r\n\t\r\n\tnames.SetSize(size);\r\n\tvalues.SetSize(size);\r\n\t\r\n\tint offset = 0;\r\n\t\r\n\tbool parsing_name = true;\r\n\t\r\n\tCString hex(_T(\"0123456789ABCDEF\"));\r\n\t\r\n\twhile ((offset < post_data.GetLength()) && result) {\r\n\r\n\t\tif      (post_data[offset] == _T('%')) {\r\n\r\n\t\t\tif ((offset + 2) < post_data.GetLength()) {\r\n\r\n\t\t\t\tint digit1 = hex.Find(_totupper(post_data[offset + 1]));\r\n\t\t\t\tint digit2 = hex.Find(_totupper(post_data[offset + 2]));\r\n\r\n\t\t\t\tif ((digit1 >= 0) && (digit2 >= 0)) {\r\n\r\n\t\t\t\t\t_TCHAR character = (_TCHAR)((digit1 << 4) + digit2);\r\n\r\n\t\t\t\t\tif (parsing_name) names[size - 1].AppendChar(character);\r\n\t\t\t\t\telse              values[size - 1].AppendChar(character);\r\n\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\telse {\r\n\t\t\t\t\tresult = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset += 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\telse if (post_data[offset] == _T('+')) {\r\n\t\t\tif (parsing_name) names[size - 1].AppendChar(_T(' '));\r\n\t\t\telse              values[size - 1].AppendChar(_T(' '));\r\n\t\t}\r\n\r\n\t\telse if (post_data[offset] == _T('=')) {\r\n\r\n\t\t\tif (parsing_name) {\r\n\t\t\t\tparsing_name = false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalues[size - 1].AppendChar(post_data[offset]);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\telse if (post_data[offset] == _T('&')) {\r\n\r\n\t\t\tif (!parsing_name) {\r\n\t\t\t\tparsing_name = true;\r\n\t\t\t\tsize += 1;\r\n\t\t\t\tnames.SetSize(size);\r\n\t\t\t\tvalues.SetSize(size);\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tvalues[size - 1].AppendChar(post_data[offset]);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\telse {\r\n\r\n\t\t\tif (parsing_name) names[size - 1].AppendChar(post_data[offset]);\r\n\t\t\telse              values[size - 1].AppendChar(post_data[offset]);\r\n\r\n\t\t}\r\n\r\n\t\toffset++;\r\n\t\t\r\n\t}\r\n\r\n\tif ((names[size - 1]  == _T(\"\")) &&\r\n\t    (values[size - 1] == _T(\"\"))) {\r\n\t\tnames.SetSize(size - 1);\r\n\t\tvalues.SetSize(size - 1);\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n// Document loaded and initialized\r\n\r\nvoid SimpleBrowser::_OnDocumentComplete(LPDISPATCH lpDisp,VARIANT *URL)\r\n{\r\n    if (lpDisp == _BrowserDispatch) {\r\n\r\n\t\tCString URL_string;\r\n\t\t\r\n\t\tif ((URL       != NULL) &&\r\n            (V_VT(URL) == VT_BSTR)) {\r\n\t\t\tURL_string = CString(V_BSTR(URL));\r\n        }\r\n\r\n        OnDocumentComplete(URL_string);\r\n\r\n    }    \r\n}\r\n\r\nvoid SimpleBrowser::OnDocumentComplete(CString URL)\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),DocumentComplete);\r\n\t\t\r\n\t\tnotification.URL = URL;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Navigation/download progress\r\n\r\nvoid SimpleBrowser::_OnDownloadBegin()\r\n{\r\n    OnDownloadBegin();\r\n}\r\n\r\nvoid SimpleBrowser::OnDownloadBegin()\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),DownloadBegin);\r\n\t\t\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::_OnProgressChange(long progress,long progress_max)\r\n{\r\n    OnProgressChange((int)progress,(int)progress_max);\r\n}\r\n\r\nvoid SimpleBrowser::OnProgressChange(int progress,int progress_max)\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),ProgressChange);\r\n\t\t\r\n\t\tnotification.progress     = progress;\r\n\t\tnotification.progress_max = progress_max;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::_OnDownloadComplete()\r\n{\r\n    OnDownloadComplete();\r\n}\r\n\r\nvoid SimpleBrowser::OnDownloadComplete()\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),DownloadComplete);\r\n\t\t\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Navigation to a link has completed\r\n\r\nvoid SimpleBrowser::_OnNavigateComplete2(LPDISPATCH lpDisp,VARIANT *URL)\r\n{\r\n    if (lpDisp == _BrowserDispatch) {\r\n\r\n\t\t// signal document ready\r\n\r\n\t\t_Ready = true;\r\n\r\n\t\t// write current content\r\n\t\t\r\n\t\t_ContentWrite();\r\n\t\t\r\n\t\t// inform user navigation complete\r\n\t\t\r\n\t\tCString URL_string;\r\n\t\t\r\n\t\tif ((URL       != NULL) &&\r\n            (V_VT(URL) == VT_BSTR)) {\r\n\t\t\tURL_string = V_BSTR(URL);\r\n        }\r\n\r\n\t\tOnNavigateComplete2(URL_string);\r\n\r\n    }    \r\n}\r\n\r\nvoid SimpleBrowser::OnNavigateComplete2(CString URL)\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),NavigateComplete2);\r\n\t\t\r\n\t\tnotification.URL = URL;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Status text has changed\r\n\r\nvoid SimpleBrowser::_OnStatusTextChange(BSTR bstrText)\r\n{\r\n    CString text;\r\n\t\r\n\tif (bstrText != NULL) {\r\n\t\ttext = (LPCTSTR)bstrText;\r\n\t}\r\n\r\n    OnStatusTextChange(text);\r\n}\r\n\r\nvoid SimpleBrowser::OnStatusTextChange(CString text)\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),StatusTextChange);\r\n\t\t\r\n\t\tnotification.text = text;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Title text has changed\r\n\r\nvoid SimpleBrowser::_OnTitleChange(BSTR bstrText)\r\n{\r\n    CString text;\r\n\t\r\n\tif (bstrText != NULL) {\r\n\t\ttext = (LPCTSTR)bstrText;\r\n\t}\r\n\r\n    OnTitleChange(text);\r\n}\r\n\r\nvoid SimpleBrowser::OnTitleChange(CString text)\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),TitleChange);\r\n\t\t\r\n\t\tnotification.text = text;\r\n\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Print template instantiation and teardown\r\n \r\nvoid SimpleBrowser::_OnPrintTemplateInstantiation(LPDISPATCH lpDisp)\r\n{\r\n\tOnPrintTemplateInstantiation();\r\n};\r\n\r\nvoid SimpleBrowser::OnPrintTemplateInstantiation()\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),PrintTemplateInstantiation);\r\n\t\t\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid SimpleBrowser::_OnPrintTemplateTeardown(LPDISPATCH lpDisp)\r\n{\r\n\tOnPrintTemplateTeardown();\r\n};\r\n\r\nvoid SimpleBrowser::OnPrintTemplateTeardown()\r\n{\r\n\tCWnd *parent = GetParent();\r\n\t\r\n\tif (parent != NULL) {\r\n\r\n\t\tNotification\tnotification(m_hWnd,GetDlgCtrlID(),PrintTemplateTeardown);\r\n\t\t\r\n\t\tLRESULT result = parent->SendMessage(WM_NOTIFY,\r\n\t\t                                     notification.hdr.idFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t (LPARAM)&notification);\r\n\t\t\r\n\t}\r\n}\r\n\r\n// Write deferred content\r\n\r\nvoid SimpleBrowser::_ContentWrite()\r\n{\r\n\tif (_Ready && (!_Content.IsEmpty())) {\r\n\t\r\n\t\t// get document interface\r\n\r\n\t\tIHTMLDocument2 *document = GetDocument();\r\n\t\t\r\n\t\tif (document != NULL) {\r\n\r\n\t\t\t// construct text to be written to browser as SAFEARRAY\r\n\r\n\t\t\tSAFEARRAY *safe_array = SafeArrayCreateVector(VT_VARIANT,0,1);\r\n\t\t\t\r\n\t\t\tVARIANT\t*variant;\r\n\t\t\t\r\n\t\t\tSafeArrayAccessData(safe_array,(LPVOID *)&variant);\r\n\t\t\t\r\n\t\t\tvariant->vt      = VT_BSTR;\r\n\t\t\tvariant->bstrVal = _Content.AllocSysString();\r\n\t\t\t\r\n\t\t\tSafeArrayUnaccessData(safe_array);\r\n\r\n\t\t\t// write SAFEARRAY to browser document\r\n\r\n\t\t\tdocument->write(safe_array);\r\n\t\t\t\r\n\t\t\t// cleanup\r\n\t\t\t\r\n\t\t\tdocument->Release();\r\n\t\t\tdocument = NULL;\r\n\r\n\t\t\t::SysFreeString(variant->bstrVal);\r\n\t\t\tvariant->bstrVal = NULL;\r\n\t\t\t\r\n\t\t\tSafeArrayDestroy(safe_array);\r\n\t\t\r\n\t\t}\r\n\r\n\t}\r\n}\r\n"
        },
        {
          "name": "SimpleBrowser.h",
          "type": "blob",
          "size": 7.578125,
          "content": "/////////////////////////////////////////////////////////////////////////////\r\n// SimpleBrowser: Web browser control\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(SimpleBrowser_defined)\r\n#define SimpleBrowser_defined\r\n\r\n#include \"mshtml.h\"\r\n\r\nclass SimpleBrowser : public CWnd {\r\n\r\npublic:\r\n\r\n\t// construction and creation\r\n\r\n    SimpleBrowser();\r\n    virtual ~SimpleBrowser();\r\n\r\n\tBOOL Create(DWORD dwStyle, \r\n\t            const RECT& rect, \r\n\t\t\t\tCWnd* pParentWnd, \r\n\t\t\t\tUINT nID);\r\n\t\t\r\n\t\t// create browser directly\r\n\r\n\tBOOL CreateFromControl(CWnd *pParentWnd,UINT nID,DWORD dwStyle = WS_CHILD | WS_VISIBLE);\r\n\r\n\t\t// create browser in place of dialog control; the dialog control \r\n\t\t// identified by nID will be destroyed, and the browser will take\r\n\t\t// its place\r\n\r\n    // controls\r\n\r\n\tvoid Navigate(LPCTSTR URL);\r\n\t\r\n\t\t// navigate to URL\r\n\r\n\tvoid Write(LPCTSTR string);\t\t\t\t\r\n\t\r\n\t\t// append string to current document; note that the WebBrowser control tolerates\r\n\t\t// poorly formed documents, like:\r\n\r\n\t\t// <html><body>....\r\n\t\t// --- no trailing body or html tags\r\n\r\n\t\t// <html><body>...</body></html><html><body>...</body></html>...\r\n\t\t// --- multiple documents\r\n\r\n\tvoid Clear();\t\t\t\t\t\t\t\r\n\t\r\n\t\t// clear current document\r\n\r\n\tvoid NavigateResource(int resource_ID);\r\n\t\r\n\t\t// navigate to HTML document resource\r\n\r\n\tvoid GoBack();\t\t\t\t\t\t\t// navigate backward one item\r\n\t\t\t\t\t\t\t\t\t\t\t// in the history list\r\n\r\n    void GoForward();\t\t\t\t\t\t// navigate forward one item\r\n\t\t\t\t\t\t\t\t\t\t\t// in the history list\r\n\r\n    void GoHome();\t\t\t\t\t\t\t// navigate to current \r\n\t\t\t\t\t\t\t\t\t\t\t// home or start page\r\n\r\n    void Refresh();\t\t\t\t\t\t\t// refresh contents\r\n\r\n    void Stop();\t\t\t\t\t\t\t// stop current activity\r\n\r\n    void Print(LPCTSTR header = _T(\"&w&b&b&p\"),\r\n\t\t\t   LPCTSTR footer = _T(\"&d &t\"));\r\n\t\t\t   \r\n\t\t// start printing contents; uses same 'metacharacters' for header and\r\n\t\t// footer as Internet Explorer; see IE Page Setup dialog\r\n\r\n\tvoid PrintPreview();\t\t\t\t\t// print preview\r\n\r\n    bool GetBusy();                         // returns true if browser\r\n                                            // busy downloading or other\r\n                                            // activity\r\n\r\n    CString GetLocationName();              // get name of location currently\r\n                                            // being browsed (title, if HTML\r\n                                            // page; UNC path if file)\r\n\r\n    CString GetLocationURL();               // get URL of location currently\r\n                                            // being browsed\r\n\r\n    READYSTATE GetReadyState();             // get browser ready state\r\n\r\n    bool GetSilent();                       // get/set silent property\r\n    void PutSilent(bool silent = false);\t// (if true, dialog and message\r\n                                            //  boxes may not be shown)\r\n\r\n\tIHTMLDocument2 *GetDocument();\t\t\t// get document interface; returns NULL \r\n\t\t\t\t\t\t\t\t\t\t\t// if interface is not available \r\n\t\t\t\t\t\t\t\t\t\t\t// (which is the case if you've navigated to\r\n\t\t\t\t\t\t\t\t\t\t\t//  something that's NOT an HTML document,\r\n\t\t\t\t\t\t\t\t\t\t\t//  like an Excel spreadsheet, which the\r\n\t\t\t\t\t\t\t\t\t\t\t//  WebBrowser control is perfectly willing\r\n\t\t\t\t\t\t\t\t\t\t\t//  to host)\r\n\r\n    // events (overridables)\r\n\r\n    virtual bool OnBeforeNavigate2(CString\tURL,\r\n\t                               CString\tframe,\r\n\t\t\t\t\t\t\t\t   void\t\t*post_data,int post_data_size,\r\n\t\t\t\t\t\t\t\t   CString\theaders);\r\n\r\n        // called before navigation begins; URL is destination, frame\r\n        // is frame name (\"\" if none), post_data is HTTP POST data (NULL if none),\r\n\t\t// and headers are HTTP headers sent to server;\r\n\t\t// return true to cancel navigation, false to continue\r\n\r\n    virtual void OnDocumentComplete(CString URL);\r\n\r\n        // navigation to document complete; URL is location\r\n\r\n    virtual void OnDownloadBegin();\r\n\t\r\n\t\t// navigation operation begins\r\n\r\n    virtual void OnProgressChange(int progress,int progress_max);\r\n\r\n         // navigation progress update\r\n\r\n    virtual void OnDownloadComplete();\r\n\t\r\n\t     // navigation operation completed\r\n\r\n    virtual void OnNavigateComplete2(CString URL);\r\n\r\n        // navigation to hyperlink complete; URL is location\r\n\t\t// (URL = string if NavigateString or NavigateResource are used)\r\n\r\n    virtual void OnStatusTextChange(CString text);\r\n\r\n        // status text has changed\r\n\r\n    virtual void OnTitleChange(CString text);\r\n\r\n\t\t// title has changed\r\n\r\n\tvirtual void OnPrintTemplateInstantiation();\r\n\t\r\n\t\t// print template has been instantiated (printing has begun)\r\n\t\t\r\n\tvirtual void OnPrintTemplateTeardown();\r\n\t\r\n\t\t// print template is being destroyed (printing has completed)\t\t\r\n\r\n\tvoid Copy();\r\n\r\n\t// notifications\r\n\t\r\n\tenum NotificationType {\t\t\t\t\t// Note: SimpleBrowser does NOT support the\r\n\t\t\t\t\t\t\t\t\t\t\t//       common notifications (NM_CLICK, etc.)\r\n\r\n\t\tBeforeNavigate2,\t\t\t\t\t// set *LRESULT=TRUE to cancel navigation\r\n\t\tDocumentComplete,\t\t\t\t\r\n\t\tDownloadBegin,\r\n\t\tProgressChange,\r\n\t\tDownloadComplete,\r\n\t\tNavigateComplete2,\r\n\t\tStatusTextChange,\r\n\t\tTitleChange,\r\n\t\tPrintTemplateInstantiation,\r\n\t\tPrintTemplateTeardown\r\n\r\n\t};\r\n\t\r\n\tclass Notification {\t\t\t\t\t// all notifications pass this structure\r\n\r\n\tpublic:\r\n\r\n\t\tNotification(HWND hwnd,UINT ID,NotificationType type);\r\n\t\t~Notification();\r\n\r\n\t\tNMHDR\t\t\thdr;\t\t\t\t// hdr.hwndFrom = SimpleBrowser's HWND\r\n\t\t\t\t\t\t\t\t\t\t\t// hdr.idFrom   = SimpleBrowser's control ID\r\n\t\t\t\t\t\t\t\t\t\t\t// hdr.code     = <NavigationType>\r\n\r\n\t\tCString\t\t\tURL;\t\t\t\t// BeforeNavigate2\r\n\t\t\t\t\t\t\t\t\t\t\t// DocumentComplete\r\n\t\t\t\t\t\t\t\t\t\t\t// NavigateComplete2\r\n\r\n\t\tCString\t\t\tframe;\t\t\t\t// BeforeNavigate2\r\n\t\tvoid\t\t\t*post_data;\t\t\t// BeforeNavigate2\r\n\t\tint\t\t\t\tpost_data_size;\r\n\t\tCString\t\t\theaders;\t\t\t// BeforeNavigate2\r\n\r\n\t\tint\t\t\t\tprogress;\t\t\t// ProgressChange\r\n\t\tint\t\t\t\tprogress_max;\t\t// ProgressChange\r\n\r\n\t\tCString\t\t\ttext;\t\t\t\t// StatusTextChange\r\n\t\t\t\t\t\t\t\t\t\t\t// TitleChange\r\n\r\n\t};\r\n\r\n\tbool ParsePostData(CString post_data,\t\t// parse URL-encoded POST data\r\n\t                   CStringArray &names,\t\t// string into list of names\r\n\t                   CStringArray &values);\t// and values; returns true if\r\n\t\t\t\t\t\t\t\t\t\t\t\t// successful\r\n\r\n    //{{AFX_VIRTUAL(SimpleBrowser)\r\n\tpublic:\r\n\tvirtual void PostNcDestroy();\r\n\t//}}AFX_VIRTUAL\r\n\r\nprotected:\r\n\r\n    //{{AFX_MSG(SimpleBrowser)\r\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\r\n\tafx_msg BOOL PreTranslateMessage(MSG *pMsg);\r\n\t//}}AFX_MSG\r\n\r\n    void _OnBeforeNavigate2(LPDISPATCH lpDisp,\r\n                            VARIANT FAR *URL,\r\n                            VARIANT FAR *Flags,\r\n                            VARIANT FAR *TargetFrameName,\r\n                            VARIANT FAR *PostData,\r\n                            VARIANT FAR *Headers,\r\n                            VARIANT_BOOL *Cancel);\r\n    void _OnDownloadBegin();\r\n    void _OnProgressChange(long progress,long progress_max);\r\n    void _OnDownloadComplete();\r\n    void _OnDocumentComplete(LPDISPATCH lpDisp,VARIANT FAR* URL);\r\n    void _OnNavigateComplete2(LPDISPATCH lpDisp,VARIANT FAR* URL);\r\n    void _OnStatusTextChange(BSTR bstrText);\r\n    void _OnTitleChange(BSTR bstrText);\r\n\tvoid _OnPrintTemplateInstantiation(LPDISPATCH pDisp);\r\n\tvoid _OnPrintTemplateTeardown(LPDISPATCH pDisp);\r\n\r\n    DECLARE_MESSAGE_MAP()\r\n    DECLARE_EVENTSINK_MAP()\r\n\r\nprivate:\r\n\r\n    CWnd                    _BrowserWindow;     // browser window\r\n\r\nprotected:\r\n\r\n\tIWebBrowser2\t\t\t*_Browser;          // browser control\r\n\r\n\tbool\t\t\t\t\t_Ready;\t\t\t\t// document ready\r\n\t\t\t\t\t\t\t\t\t\t\t\t// (initial navigation completed)\r\n\r\nprivate:    \r\n    \r\n    IDispatch               *_BrowserDispatch;  // browser control \r\n\t\t\t\t\t\t\t\t\t\t\t\t// dispatch interface\r\n\r\n\tCString\t\t\t\t\t_Content;\t\t\t// current content set via Write()/Clear()\r\n\t\r\n\tvoid _ContentWrite();\r\n\r\n};\r\n\r\n#endif\r\n"
        },
        {
          "name": "Slugify.h",
          "type": "blob",
          "size": 8.642578125,
          "content": "#pragma once\n\n#include <string>\n#include <unordered_map>\n#include <regex>\n#include <algorithm>\n\nvoid replace_all(std::wstring& input, const std::wstring& from, const std::wstring& to) \n{\n\tsize_t pos = 0;\n\twhile ((pos = input.find(from, pos)) != std::wstring::npos) \n\t{\n\t\tinput.replace(pos, from.size(), to);\n\t\tpos += to.size();\n\t}\n}\n\nstd::wstring trim(const std::wstring &s)\n{\n\tstd::wstring::const_iterator it = s.begin();\n\twhile (it != s.end() && isspace(*it))\n\t\tit++;\n\n\tstd::wstring::const_reverse_iterator rit = s.rbegin();\n\twhile (rit.base() != it && isspace(*rit))\n\t\trit++;\n\n\treturn std::wstring(it, rit.base());\n}\n\n// SLUGIFY\nstd::wstring slugify(std::wstring input, std::wstring separator)\n{\n\tstd::unordered_map<std::wstring, std::wstring> charMap{\n\t\t// latin\n\t\t{_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"AE\")}, {\n\t\t_T(\"\"), _T(\"C\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"I\")}, {\n\t\t_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"D\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"O\")}, {\n\t\t_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"U\")}, {\n\t\t_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"Y\")}, {_T(\"\"), _T(\"TH\")}, {_T(\"\"), _T(\"ss\")}, {_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"a\")}, {\n\t\t_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"ae\")}, {_T(\"\"), _T(\"c\")}, {_T(\"\"), _T(\"e\")}, {\n\t\t_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"i\")}, {\n\t\t_T(\"\"), _T(\"d\")}, {_T(\"\"), _T(\"n\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {\n\t\t_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"u\")}, {\n\t\t_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"th\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"SS\")},\n\t\t// greek\n\t\t{_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"b\")}, {_T(\"\"), _T(\"g\")}, {_T(\"\"), _T(\"d\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"z\")}, {_T(\"\"), _T(\"h\")}, {_T(\"\"), _T(\"8\")}, {\n\t\t_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"k\")}, {_T(\"\"), _T(\"l\")}, {_T(\"\"), _T(\"m\")}, {_T(\"\"), _T(\"n\")}, {_T(\"\"), _T(\"3\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"p\")}, {\n\t\t_T(\"\"), _T(\"r\")}, {_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"t\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"f\")}, {_T(\"\"), _T(\"x\")}, {_T(\"\"), _T(\"ps\")}, {_T(\"\"), _T(\"w\")}, {\n\t\t_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"h\")}, {_T(\"\"), _T(\"w\")}, {_T(\"\"), _T(\"s\")}, {\n\t\t_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"i\")}, {\n\t\t_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"B\")}, {_T(\"\"), _T(\"G\")}, {_T(\"\"), _T(\"D\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"Z\")}, {_T(\"\"), _T(\"H\")}, {_T(\"\"), _T(\"8\")}, {\n\t\t_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"K\")}, {_T(\"\"), _T(\"L\")}, {_T(\"\"), _T(\"M\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"3\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"P\")}, {\n\t\t_T(\"\"), _T(\"R\")}, {_T(\"\"), _T(\"S\")}, {_T(\"\"), _T(\"T\")}, {_T(\"\"), _T(\"Y\")}, {_T(\"\"), _T(\"F\")}, {_T(\"\"), _T(\"X\")}, {_T(\"\"), _T(\"PS\")}, {_T(\"\"), _T(\"W\")}, {\n\t\t_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"Y\")}, {_T(\"\"), _T(\"H\")}, {_T(\"\"), _T(\"W\")}, {_T(\"\"), _T(\"I\")}, {\n\t\t_T(\"\"), _T(\"Y\")},\n\t\t// turkish\n\t\t{_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"S\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"c\")}, {_T(\"\"), _T(\"C\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"U\")}, {\n\t\t_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"O\")}, {_T(\"\"), _T(\"g\")}, {_T(\"\"), _T(\"G\")},\n\t\t// russian\n\t\t{_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"b\")}, {_T(\"\"), _T(\"v\")}, {_T(\"\"), _T(\"g\")}, {_T(\"\"), _T(\"d\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"yo\")}, {_T(\"\"), _T(\"zh\")}, {\n\t\t_T(\"\"), _T(\"z\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"j\")}, {_T(\"\"), _T(\"k\")}, {_T(\"\"), _T(\"l\")}, {_T(\"\"), _T(\"m\")}, {_T(\"\"), _T(\"n\")}, {_T(\"\"), _T(\"o\")}, {\n\t\t_T(\"\"), _T(\"p\")}, {_T(\"\"), _T(\"r\")}, {_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"t\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"f\")}, {_T(\"\"), _T(\"h\")}, {_T(\"\"), _T(\"c\")}, {\n\t\t_T(\"\"), _T(\"ch\")}, {_T(\"\"), _T(\"sh\")}, {_T(\"\"), _T(\"sh\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"y\")}, {_T(\"\"), _T(\"\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"yu\")}, {\n\t\t_T(\"\"), _T(\"ya\")}, {\n\t\t_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"B\")}, {_T(\"\"), _T(\"V\")}, {_T(\"\"), _T(\"G\")}, {_T(\"\"), _T(\"D\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"Yo\")}, {_T(\"\"), _T(\"Zh\")}, {\n\t\t_T(\"\"), _T(\"Z\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"J\")}, {_T(\"\"), _T(\"K\")}, {_T(\"\"), _T(\"L\")}, {_T(\"\"), _T(\"M\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"O\")}, {\n\t\t_T(\"\"), _T(\"P\")}, {_T(\"\"), _T(\"R\")}, {_T(\"\"), _T(\"S\")}, {_T(\"\"), _T(\"T\")}, {_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"F\")}, {_T(\"\"), _T(\"H\")}, {_T(\"\"), _T(\"C\")}, {\n\t\t_T(\"\"), _T(\"Ch\")}, {_T(\"\"), _T(\"Sh\")}, {_T(\"\"), _T(\"Sh\")}, {_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"Y\")}, {_T(\"\"), _T(\"\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"Yu\")}, {\n\t\t_T(\"\"), _T(\"Ya\")},\n\t\t// ukranian\n\t\t{_T(\"\"), _T(\"Ye\")}, {_T(\"\"), _T(\"I\")}, {_T(\"\"), _T(\"Yi\")}, {_T(\"\"), _T(\"G\")}, {_T(\"\"), _T(\"ye\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"yi\")}, {_T(\"\"), _T(\"g\")},\n\t\t// czech\n\t\t{_T(\"\"), _T(\"c\")}, {_T(\"\"), _T(\"d\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"n\")}, {_T(\"\"), _T(\"r\")}, {_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"t\")}, {_T(\"\"), _T(\"u\")},\n\t\t{_T(\"\"), _T(\"z\")}, {_T(\"\"), _T(\"C\")}, {_T(\"\"), _T(\"D\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"R\")}, {_T(\"\"), _T(\"S\")}, {_T(\"\"), _T(\"T\")},\n\t\t{_T(\"\"), _T(\"U\")}, {_T(\"\"), _T(\"Z\")},\n\t\t// polish\n\t\t{_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"c\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"l\")}, {_T(\"\"), _T(\"n\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"z\")},\n\t\t{_T(\"\"), _T(\"z\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"C\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"L\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"S\")},\n\t\t{_T(\"\"), _T(\"Z\")}, {_T(\"\"), _T(\"Z\")},\n\t\t// latvian\n\t\t{_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"c\")}, {_T(\"\"), _T(\"e\")}, {_T(\"\"), _T(\"g\")}, {_T(\"\"), _T(\"i\")}, {_T(\"\"), _T(\"k\")}, {_T(\"\"), _T(\"l\")}, {_T(\"\"), _T(\"n\")},\n\t\t{_T(\"\"), _T(\"s\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"z\")}, {_T(\"\"), _T(\"A\")}, {_T(\"\"), _T(\"C\")}, {_T(\"\"), _T(\"E\")}, {_T(\"\"), _T(\"G\")}, {_T(\"\"), _T(\"i\")},\n\t\t{_T(\"\"), _T(\"k\")}, {_T(\"\"), _T(\"L\")}, {_T(\"\"), _T(\"N\")}, {_T(\"\"), _T(\"S\")}, {_T(\"\"), _T(\"u\")}, {_T(\"\"), _T(\"Z\")},\n\t\t// currency\n\t\t{_T(\"\"), _T(\"euro\")}, {_T(\"\"), _T(\"cruzeiro\")}, {_T(\"\"), _T(\"french franc\")}, {_T(\"\"), _T(\"pound\")},\n\t\t{_T(\"\"), _T(\"lira\")}, {_T(\"\"), _T(\"mill\")}, {_T(\"\"), _T(\"naira\")}, {_T(\"\"), _T(\"peseta\")}, {_T(\"\"), _T(\"rupee\")},\n\t\t{_T(\"\"), _T(\"won\")}, {_T(\"\"), _T(\"new shequel\")}, {_T(\"\"), _T(\"dong\")}, {_T(\"\"), _T(\"kip\")}, {_T(\"\"), _T(\"tugrik\")},\n\t\t{_T(\"\"), _T(\"drachma\")}, {_T(\"\"), _T(\"penny\")}, {_T(\"\"), _T(\"peso\")}, {_T(\"\"), _T(\"guarani\")}, {_T(\"\"), _T(\"austral\")},\n\t\t{_T(\"\"), _T(\"hryvnia\")}, {_T(\"\"), _T(\"cedi\")}, {_T(\"\"), _T(\"cent\")}, {_T(\"\"), _T(\"yen\")}, {_T(\"\"), _T(\"yuan\")},\n\t\t{_T(\"\"), _T(\"yen\")}, {_T(\"\"), _T(\"rial\")}, {_T(\"\"), _T(\"ecu\")}, {_T(\"\"), _T(\"currency\")}, {_T(\"\"), _T(\"baht\")}, {_T(\"$\"), _T(\"dollar\")},\n\t\t// symbols\n\t\t{_T(\"\"), _T(\"(c)\")}, {_T(\"\"), _T(\"oe\")}, {_T(\"\"), _T(\"OE\")}, {_T(\"\"), _T(\"sum\")}, {_T(\"\"), _T(\"(r)\")}, {_T(\"\"), _T(\"+\")},\n\t\t{_T(\"\"), _T(\"\\\"\")}, {_T(\"\"), _T(\"d\")}, {_T(\"\"), _T(\"f\")}, {_T(\"\"), _T(\"tm\")},\n\t\t{_T(\"\"), _T(\"sm\")}, {_T(\"\"), _T(\"...\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"o\")}, {_T(\"\"), _T(\"a\")}, {_T(\"\"), _T(\"*\")},\n\t\t{_T(\"\"), _T(\"delta\")}, {_T(\"\"), _T(\"infinity\")}, {_T(\"\"), _T(\"love\")}, {_T(\"&\"), _T(\"and\")}, {_T(\"|\"), _T(\"or\")},\n\t\t{_T(\"<\"), _T(\"less\")}, {_T(\">\"), _T(\"greater\")\n\t\t}\n\t};\n\n\t//remove accents\n\tfor (auto kv : charMap)\n\t{\n\t\treplace_all(input, kv.first, kv.second);\n\t}\n\t\n\t//make lower case\n\tstd::transform(input.begin(), input.end(), input.begin(), ::tolower);\n\n\t//invalid characters\n\tstd::wregex e1(_T(\"[^a-z0-9-\\\\s]\"));\n\tinput = std::regex_replace(input, e1, _T(\"\"));\n\n\t//convert multiple spaces into one\n\tstd::wregex e2(_T(\"\\\\s+\"));\n\tinput = std::regex_replace(input, e2, _T(\" \"));\n\n\ttrim(input);\n\n\tauto replaceSpacesAndSep = _T(\"[\") + separator + _T(\"\\\\s]+\");\n\n\t//replace spaces with separator\n\tstd::wregex e3(replaceSpacesAndSep);\n\tinput = std::regex_replace(input, e3, separator);\n\n\treturn input;\n};"
        },
        {
          "name": "SnapWindow.cpp",
          "type": "blob",
          "size": 2.1025390625,
          "content": "#include \"stdafx.h\"\n#include \"SnapWindow.h\"\n\n\nSnapWindow::SnapWindow()\n{\n\tsnap_ModifierKey = VK_SHIFT;\n\tNONCLIENTMETRICS ncm = { 0 };\n\tncm.cbSize = sizeof ncm;\n\tSystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);\n\tsnap_Margin = ncm.iCaptionHeight;\n\n\tsnap_cur_pos.x = 0;\n\tsnap_cur_pos.y = 0;\n\tsnap_rcWindow.bottom = 0;\n\tsnap_rcWindow.left = 0;\n\tsnap_rcWindow.right = 0;\n\tsnap_rcWindow.top = 0;\t\n\tsnap_x = 0;\n\tsnap_y = 0;\n}\n\n\nSnapWindow::~SnapWindow()\n{\n}\n\nBOOL SnapWindow::isSnapClose(int a, int b) \n{\n\treturn (abs(a - b) < snap_Margin); \n}\n\nLRESULT SnapWindow::OnSnapEnterSizeMove(HWND hWnd)\n{\n\tsnap_cur_pos.x = 0;\n\tsnap_cur_pos.y = 0;\n\n\tsnap_rcWindow.bottom = 0;\n\tsnap_rcWindow.left = 0;\n\tsnap_rcWindow.right = 0;\n\tsnap_rcWindow.top = 0;\n\n\tGetWindowRect(hWnd, &snap_rcWindow);\n\n\tGetCursorPos(&snap_cur_pos);\n\n\tsnap_x = snap_cur_pos.x - snap_rcWindow.left;\n\tsnap_y = snap_cur_pos.y - snap_rcWindow.top;\n\n\treturn 0;\n}\n\nLRESULT SnapWindow::OnSnapMoving(HWND hWnd, LPRECT snap_prc)\n{\n\t//no snap if shift key pressed\n\tif (GetAsyncKeyState(snap_ModifierKey) < 0) \n\t\treturn FALSE;\n\t\n\tsnap_cur_pos.x = 0;\n\tsnap_cur_pos.y = 0;\n\tsnap_rcWindow.bottom = 0;\n\tsnap_rcWindow.left = 0;\n\tsnap_rcWindow.right = 0;\n\tsnap_rcWindow.top = 0;\n\n\tGetCursorPos(&snap_cur_pos);\n\tOffsetRect(snap_prc,\n\t\tsnap_cur_pos.x - (snap_prc->left + snap_x),\n\t\tsnap_cur_pos.y - (snap_prc->top + snap_y));\n\n\t//it may change during app lifetime\n\tSystemParametersInfo(SPI_GETWORKAREA, 0, &snap_wa, 0);\n\n\tMONITORINFO mi;\n\tHMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);\n\tmi.cbSize = sizeof(mi);\n\tGetMonitorInfo(hMonitor, &mi);\n\tsnap_wa = mi.rcWork;\n\n\tif (isSnapClose(snap_prc->left, snap_wa.left)) \n\t{ \n\t\tOffsetRect(snap_prc, snap_wa.left - snap_prc->left, 0); \n\t}\n\telse\n\t{\n\t\tif (isSnapClose(snap_wa.right, snap_prc->right)) \n\t\t{ \n\t\t\tOffsetRect(snap_prc, snap_wa.right - snap_prc->right, 0); \n\t\t}\n\t}\n\n\tif (isSnapClose(snap_prc->top, snap_wa.top)) \n\t{ \n\t\tOffsetRect(snap_prc, 0, snap_wa.top - snap_prc->top); \n\t}\n\telse\n\t{\n\t\tif (isSnapClose(snap_wa.bottom, snap_prc->bottom)) \n\t\t{ \n\t\t\tOffsetRect(snap_prc, 0, snap_wa.bottom - snap_prc->bottom); \n\t\t}\n\t}\n\treturn TRUE;\n}"
        },
        {
          "name": "SnapWindow.h",
          "type": "blob",
          "size": 0.330078125,
          "content": "#pragma once\nclass SnapWindow\n{\npublic:\n\tSnapWindow();\n\t~SnapWindow();\n\n\tint snap_Margin;\n\tint snap_ModifierKey;\n\t\n\tLRESULT OnSnapMoving(HWND hWnd, LPRECT snap_prc);\n\tLRESULT OnSnapEnterSizeMove(HWND hWnd);\n\nprivate:\n\tPOINT snap_cur_pos;\n\tRECT snap_rcWindow, snap_wa, *snap_prc;\n\tint snap_x, snap_y;\n\n\tBOOL isSnapClose(int a, int b);\n};\n\n"
        },
        {
          "name": "SpecialPasteOptions.cpp",
          "type": "blob",
          "size": 0.9677734375,
          "content": "#include \"stdafx.h\"\r\n#include \"SpecialPasteOptions.h\"\r\n\r\n\r\nCSpecialPasteOptions::CSpecialPasteOptions()\r\n{\r\n\tm_pasteAsPlainText = false;\r\n\tm_pPasteFormats = NULL;\r\n\tm_pasteUpperCase = false;\r\n\tm_pasteLowerCase = false;\r\n\tm_pasteCapitalize = false;\r\n\tm_pasteRemoveLineFeeds = false;\r\n\tm_pasteAddOneLineFeed = false;\r\n\tm_pasteAddTwoLineFeeds = false;\r\n\tm_pasteSentenceCase = false;\r\n\tm_pasteTypoglycemia = false;\r\n\tm_pasteAddingDateTime = false;\r\n\tm_delayRenderLockout = 0;\r\n\tm_dragDropFilesOnly = false;\r\n\tm_pasteScriptGuid = _T(\"\");\r\n\tm_updateClipOrder = true;\r\n\tm_trimWhiteSpace = false;\r\n\tm_pasteSlugify = false;\r\n\tm_invertCase = false;\r\n\tm_placeCF_HDROP_OnDrag = true;\r\n\tm_pasteCamelCase = false;\r\n\tm_pasteImagesHorizontal = false;\r\n\tm_pasteImagesVertically = false;\r\n\tm_pasteAsciiOnly = false;\r\n}\r\n\r\nCSpecialPasteOptions::~CSpecialPasteOptions()\r\n{\r\n}\r\n\r\nCString CSpecialPasteOptions::ToString()\r\n{\r\n\tCString cs;\r\n\tcs.Format(_T(\"Plain Text: %d\"), m_pasteAsPlainText);\r\n\r\n\treturn cs;\r\n}\r\n"
        },
        {
          "name": "SpecialPasteOptions.h",
          "type": "blob",
          "size": 1.3623046875,
          "content": "#pragma once\r\n#include \"Clip.h\"\r\n\r\nclass CSpecialPasteOptions\r\n{\r\npublic:\r\n\tCSpecialPasteOptions();\r\n\t~CSpecialPasteOptions();\r\n\r\n\tbool m_pasteAsPlainText;\r\n\tbool m_pasteUpperCase;\r\n\tbool m_pasteCamelCase;\r\n\tbool m_pasteImagesHorizontal;\r\n\tbool m_pasteImagesVertically;\r\n\tbool m_pasteLowerCase;\r\n\tbool m_pasteCapitalize;\r\n\tbool m_pasteSentenceCase;\r\n\tbool m_pasteRemoveLineFeeds;\r\n\tbool m_pasteAddOneLineFeed;\r\n\tbool m_pasteAddTwoLineFeeds;\r\n\tbool m_pasteTypoglycemia;\r\n\tbool m_pasteAddingDateTime;\r\n\tCClipFormats *m_pPasteFormats;\r\n\tDWORD m_delayRenderLockout;\r\n\tbool m_dragDropFilesOnly;\r\n\tCString m_pasteScriptGuid;\r\n\tbool m_updateClipOrder;\r\n\tbool m_trimWhiteSpace;\r\n\tbool m_pasteSlugify;\r\n\tbool m_invertCase;\r\n\tbool m_placeCF_HDROP_OnDrag;\r\n\tbool m_pasteAsciiOnly;\r\n\r\n\tbool LimitFormatsToText() \r\n\t{ \r\n\t\treturn m_pasteAsPlainText ||\r\n\t\t\tm_pasteUpperCase ||\r\n\t\t\tm_pasteLowerCase ||\r\n\t\t\tm_pasteCapitalize ||\r\n\t\t\tm_pasteSentenceCase ||\r\n\t\t\tm_pasteRemoveLineFeeds ||\r\n\t\t\tm_pasteAddOneLineFeed ||\r\n\t\t\tm_pasteAddTwoLineFeeds ||\r\n\t\t\tm_pasteTypoglycemia ||\r\n\t\t\tm_pasteAddingDateTime || \r\n\t\t\tm_trimWhiteSpace ||\r\n\t\t\tm_pasteSlugify || \r\n\t\t\tm_invertCase ||\r\n\t\t\tm_pasteCamelCase ||\r\n\t\t\tm_pasteAsciiOnly;\r\n\t}\r\n\r\n\tbool IncludeRTFForTextOnly()\r\n\t{\r\n\t\treturn m_pasteRemoveLineFeeds ||\r\n\t\t\tm_pasteAddOneLineFeed ||\r\n\t\t\tm_pasteAddTwoLineFeeds ||\r\n\t\t\tm_pasteAddingDateTime;\r\n\t}\r\n\r\n\tCString ToString();\r\n};\r\n\r\n"
        },
        {
          "name": "StdAfx.cpp",
          "type": "blob",
          "size": 0.1962890625,
          "content": "// stdafx.cpp : source file that includes just the standard includes\n//\tCP_Main.pch will be the pre-compiled header\n//\tstdafx.obj will contain the pre-compiled type information\n\n#include \"stdafx.h\"\n\n\n\n"
        },
        {
          "name": "StdAfx.h",
          "type": "blob",
          "size": 1.89453125,
          "content": "// stdafx.h : include file for standard system include files,\r\n//  or project specific include files that are used frequently, but\r\n//      are changed infrequently\r\n//\r\n\r\n#if !defined(AFX_STDAFX_H__56F3D184_7208_47FE_AFE2_E270325F356A__INCLUDED_)\r\n//#define _ATL_APARTMENT_THREADED \r\n#define AFX_STDAFX_H__56F3D184_7208_47FE_AFE2_E270325F356A__INCLUDED_\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif // _MSC_VER > 1000\r\n\r\n#pragma warning(disable : 4995)\r\n\r\n//remove 2005 warnings\r\n#define _CRT_SECURE_NO_DEPRECATE 1\r\n#define _CRT_NON_CONFORMING_SWPRINTFS 1\r\n\r\n#define HITTEST_RET LRESULT\r\n\r\n#define _WIN32_WINNT 0x0A00\r\n#define WINVER 0x0A00\r\n\r\n#define VC_EXTRALEAN\t\t// Exclude rarely-used stuff from Windows headers\r\n\r\n#include <afxwin.h>         // MFC core and standard components\r\n#include <afxext.h>         // MFC extensions\r\n#include <afxdisp.h>        // MFC Automation classes\r\n#include <afxdtctl.h>\t\t// MFC support for Internet Explorer 4 Common Controls\r\n#ifndef _AFX_NO_AFXCMN_SUPPORT\r\n#include <afxcmn.h>\t\t\t// MFC support for Windows Common Controls\r\n#endif // _AFX_NO_AFXCMN_SUPPORT\r\n#include <afxole.h>\r\n#include <Winsock2.h>\r\n\r\n#include \"UnicodeMacros.h\"\r\n\r\n#include <imm.h>\r\n#include <afxcontrolbars.h>\r\n#import \"riched20.dll\" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude(\"UINT_PTR\"), exclude(\"LONG_PTR\") \r\n\r\n#pragma comment(linker, \"\\\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\\\"\")\r\n\r\n#include <gdiplus.h>\r\n#include <afxdlgs.h>\r\n#pragma comment(lib, \"gdiplus.lib\")\r\nusing namespace Gdiplus;\r\n\r\n//{{AFX_INSERT_LOCATION}}\r\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\r\n\r\n\r\n#include <atlbase.h>\r\n#include <atlcom.h>\r\n#include <atlctl.h>\r\n#endif // !defined(AFX_STDAFX_H__56F3D184_7208_47FE_AFE2_E270325F356A__INCLUDED_)\r\n"
        },
        {
          "name": "SymbolEdit.cpp",
          "type": "blob",
          "size": 21.2314453125,
          "content": "// AeroEdit.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"SymbolEdit.h\"\r\n#include \"cp_main.h\"\r\n#include \"QListCtrl.h\"\r\n#include \"Shared\\TextConvert.h\"\r\n\r\n// CSymbolEdit\r\n\r\n#define RANGE_START 3000\r\n#define CLEAR_LIST 3010\r\n#define LIST_MAX_COUNT 10\r\n#define MAX_SAVED_SEARCH_LENGTH 50\r\n\r\nIMPLEMENT_DYNAMIC(CSymbolEdit, CEdit)\r\n\r\nCSymbolEdit::CSymbolEdit() :\r\n\tm_hSymbolIcon(NULL),\r\n\tm_bInternalIcon(false),\r\n\tm_colorPromptText(RGB(127, 127, 127)),\r\n\tm_centerTextDiff(0)\r\n{\r\n\tm_fontPrompt.CreateFont(\r\n\t\t16,                        // nHeight\r\n\t\t0,                         // nWidth\r\n\t\t0,                         // nEscapement\r\n\t\t0,                         // nOrientation\r\n\t\tFW_NORMAL,                 // nWeight\r\n\t\tTRUE,                      // bItalic\r\n\t\tFALSE,                     // bUnderline\r\n\t\t0,                         // cStrikeOut\r\n\t\tDEFAULT_CHARSET,           // nCharSet\r\n\t\tOUT_DEFAULT_PRECIS,        // nOutPrecision\r\n\t\tCLIP_DEFAULT_PRECIS,       // nClipPrecision\r\n\t\tDEFAULT_QUALITY,           // nQuality\r\n\t\tDEFAULT_PITCH | FF_SWISS,  // nPitchAndFamily\r\n\t\t_T(\"Calibri\"));\r\n\r\n\tm_mouseDownOnSearches = false;\r\n\tm_mouseHoveringOverSearches = false;\r\n\tm_mouseDownOnClose = false;\r\n\tm_mouseHoveringOverClose = false;\r\n\tm_windowDpi = NULL;\r\n\r\n\t//m_searchButton.LoadStdImageDPI(Search_16, Search_20, Search_24, Search_32, _T(\"PNG\"));\r\n\t\r\n}\r\n\r\nCSymbolEdit::~CSymbolEdit()\r\n{\r\n\tDestroyIcon();\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CSymbolEdit, CEdit)\r\n\tON_WM_PAINT()\r\n\tON_MESSAGE(WM_SETFONT, OnSetFont)\r\n\t//ON_MESSAGE(WM_EXITMENULOOP, OnMenuExit)\r\n\tON_WM_CTLCOLOR_REFLECT()\r\n\tON_WM_SETFOCUS()\r\n\tON_WM_KILLFOCUS()\r\n\tON_WM_SETCURSOR()\r\n\tON_WM_LBUTTONUP()\r\n\tON_WM_LBUTTONDOWN()\r\n\tON_WM_MOUSEMOVE()\r\n\tON_COMMAND_RANGE(RANGE_START, (RANGE_START + LIST_MAX_COUNT), OnSelectSearchString)\r\n\tON_WM_EXITSIZEMOVE()\r\n\t//ON_WM_ERASEBKGND()\r\n\tON_WM_NCCALCSIZE()\r\n\tON_WM_NCPAINT()\r\n\tON_WM_TIMER()\r\nEND_MESSAGE_MAP()\r\n\r\nBOOL CSymbolEdit::PreTranslateMessage(MSG* pMsg)\r\n{\r\n\t// TODO: Add your specialized code here and/or call the base class\r\n\t// Intercept Ctrl + Z (Undo), Ctrl + X (Cut), Ctrl + C (Copy), Ctrl + V (Paste) and Ctrl + A (Select All)\r\n\t// before CEdit base class gets a hold of them.\r\n\tif (pMsg->message == WM_KEYDOWN &&\r\n\t\tCONTROL_PRESSED)\r\n\t{\r\n\t\tswitch (pMsg->wParam)\r\n\t\t{\r\n\t\tcase 'Z':\r\n\t\t\tUndo();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'X':\r\n\t\t\tCut();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'C':\r\n\t\t\t{\r\n\t\t\t\tint startChar;\r\n\t\t\t\tint endChar;\r\n\t\t\t\tthis->GetSel(startChar, endChar);\r\n\t\t\t\tif (startChar == endChar)\r\n\t\t\t\t{\r\n\t\t\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\t\t\tif (pWnd)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpWnd->SendMessage(NM_COPY_CLIP, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tCopy();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn TRUE;\r\n\t\tcase 'V':\r\n\t\t\tPaste();\r\n\t\t\treturn TRUE;\r\n\t\tcase 'A':\r\n\t\t\tSetSel(0, -1);\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (pMsg->message)\r\n\t{\r\n\tcase WM_KEYDOWN:\r\n\t{\r\n\t\tif (pMsg->wParam == VK_RETURN)\r\n\t\t{\r\n\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\tif (pWnd)\r\n\t\t\t{\r\n\t\t\t\tif (CGetSetOptions::m_bFindAsYouType)\r\n\t\t\t\t{\r\n\t\t\t\t\tpWnd->SendMessage(NM_SEARCH_ENTER_PRESSED, 0, 0);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t//Send a message to the parent to refill the lb from the search\r\n\t\t\t\t\tpWnd->PostMessage(CB_SEARCH, 0, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAddToSearchHistory();\r\n\t\t\t}\r\n\r\n\t\t\treturn TRUE;\r\n\t\t}\r\n\t\telse if (pMsg->wParam == VK_DOWN &&\r\n\t\t\t((GetKeyState(VK_CONTROL) & 0x8000) || ((GetKeyState(VK_CONTROL) & 0x8000) && (GetKeyState(VK_SHIFT) & 0x8000))))\r\n\t\t{\r\n\t\t\tif (ShowSearchHistoryMenu())\r\n\t\t\t{\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (pMsg->wParam == VK_DOWN ||\r\n\t\t\tpMsg->wParam == VK_UP ||\r\n\t\t\tpMsg->wParam == VK_PRIOR ||\r\n\t\t\tpMsg->wParam == VK_NEXT)\r\n\t\t{\r\n\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\tif (pWnd)\r\n\t\t\t{\r\n\t\t\t\tpWnd->SendMessage(CB_UPDOWN, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (pMsg->wParam == VK_DELETE)\r\n\t\t{\r\n\t\t\tint startChar;\r\n\t\t\tint endChar;\r\n\t\t\tthis->GetSel(startChar, endChar);\r\n\t\t\tCString cs;\r\n\t\t\tthis->GetWindowText(cs);\r\n\t\t\t//if selection is at the end then forward this on to the parent to delete the selected clip\r\n\t\t\tif(startChar == cs.GetLength() &&\r\n\t\t\t\tendChar == cs.GetLength())\r\n\t\t\t{ \r\n\t\t\t\tCWnd *pWnd = GetParent();\r\n\t\t\t\tif (pWnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tpWnd->SendMessage(NM_DELETE, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\t}\r\n\r\n\treturn CEdit::PreTranslateMessage(pMsg);\r\n}\r\n\r\nCString CSymbolEdit::SavePastSearches()\r\n{\r\n\tTiXmlDocument doc;\r\n\r\n\tTiXmlElement* outer = new TiXmlElement(\"PastSearches\");\r\n\tdoc.LinkEndChild(outer);\r\n\r\n\tint count = (int)m_searches.GetCount();\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\t\t\r\n\t\tTiXmlElement* searchElement = new TiXmlElement(\"Search\");\r\n\r\n\t\tCStringA t = CTextConvert::UnicodeToUTF8(m_searches[i]);\r\n\t\tsearchElement->SetAttribute(\"text\", t);\r\n\r\n\t\touter->LinkEndChild(searchElement);\r\n\t}\r\n\r\n\tTiXmlPrinter printer;\r\n\tprinter.SetLineBreak(\"\");\r\n\tdoc.Accept(&printer);\r\n\tCString cs = printer.CStr();\r\n\r\n\treturn cs;\r\n}\r\n\r\nvoid CSymbolEdit::LoadPastSearches(CString values)\r\n{\r\n\tm_searches.RemoveAll();\r\n\r\n\tTiXmlDocument doc;\r\n\tCStringA xmlA = CTextConvert::UnicodeToUTF8(values);\r\n\tdoc.Parse(xmlA);\r\n\r\n\tTiXmlElement *ItemHeader = doc.FirstChildElement(\"PastSearches\");\r\n\r\n\tif (ItemHeader != NULL)\r\n\t{\r\n\t\tTiXmlElement *ItemElement = ItemHeader->FirstChildElement();\r\n\r\n\t\tint count = 0;\r\n\r\n\t\twhile (ItemElement)\r\n\t\t{\r\n\t\t\tif (count < LIST_MAX_COUNT)\r\n\t\t\t{\r\n\t\t\t\tCString item = ItemElement->Attribute(\"text\");\r\n\r\n\t\t\t\tCString toAdd = item.Left(MAX_SAVED_SEARCH_LENGTH);\r\n\t\t\t\tif (toAdd != _T(\"\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tm_searches.Add(toAdd);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tItemElement = ItemElement->NextSiblingElement();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcount++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CSymbolEdit::AddToSearchHistory()\r\n{\r\n\tCString cs;\r\n\tthis->GetWindowText(cs);\r\n\tif (cs != _T(\"\"))\r\n\t{\r\n\t\t//only save up to 50, had reports of somehow getting extremely large amounts of junk text\r\n\t\t//save and causing memory issues.\r\n\t\tcs = cs.Left(MAX_SAVED_SEARCH_LENGTH);\r\n\r\n\t\tif (m_searches.GetCount() >= LIST_MAX_COUNT)\r\n\t\t{\r\n\t\t\tm_searches.RemoveAt(0);\r\n\t\t}\r\n\r\n\t\tbool existing = false;\r\n\t\tint count = (int)m_searches.GetCount();\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tif (m_searches[i] == cs)\r\n\t\t\t{\r\n\t\t\t\tm_searches.RemoveAt(i);\r\n\t\t\t\tm_searches.Add(cs);\r\n\t\t\t\texisting = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (existing == false)\r\n\t\t{\r\n\t\t\tm_searches.Add(cs);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool CSymbolEdit::ShowSearchHistoryMenu()\r\n{\r\n\tif (m_searches.GetCount() == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCMenu cmPopUp;\r\n\tcmPopUp.CreatePopupMenu();\r\n\r\n\tint count = min((int)m_searches.GetCount(), LIST_MAX_COUNT);\r\n\tfor (int i = count-1; i >= 0; i--)\r\n\t{\r\n\t\tCString text = m_searches[i];\r\n\r\n\t\tif (i == count - 1 &&\r\n\t\t\tm_lastSearchShortCut.Key > 0)\r\n\t\t{\r\n\t\t\tCString cmdShortcutText = CHotKey::GetHotKeyDisplayStatic(m_lastSearchShortCut.Key);\r\n\t\t\tif (m_lastSearchShortCut.Key2 != 0)\r\n\t\t\t{\r\n\t\t\t\tCString cmdShortcutText2 = CHotKey::GetHotKeyDisplayStatic(m_lastSearchShortCut.Key2);\r\n\r\n\t\t\t\tif (cmdShortcutText2.GetLength() > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tcmdShortcutText += _T(\" - \");\r\n\t\t\t\t\tcmdShortcutText += cmdShortcutText2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttext += \"\\t\";\r\n\t\t\ttext += cmdShortcutText;\r\n\t\t}\r\n\r\n\t\tcmPopUp.AppendMenuW(MF_STRING, (RANGE_START + i), text);\r\n\t}\r\n\r\n\tcmPopUp.AppendMenu(MF_SEPARATOR);\r\n\tcmPopUp.AppendMenuW(MF_STRING, CLEAR_LIST, _T(\"Clear List\"));\r\n\r\n\tCRect windowRect;\r\n\tthis->GetWindowRect(&windowRect);\r\n\tPOINT pp;\r\n\tGetCursorPos(&pp);\r\n\tPOINT x = this->GetCaretPos();\r\n\tClientToScreen(&x);\r\n\tx.y += windowRect.Height();\r\n\r\n\tcmPopUp.TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, x.x, x.y, this, NULL);\r\n\t\r\n\tInvalidate();\r\n\t\r\n\treturn true;\r\n}\r\n\r\nvoid CSymbolEdit::DestroyIcon()\r\n{\r\n\t// if icon was loaded internally, destroy it\r\n\tif (m_bInternalIcon || m_hSymbolIcon != NULL)\r\n\t\t::DestroyIcon(m_hSymbolIcon);\r\n}\r\n\r\nvoid CSymbolEdit::PreSubclassWindow()\r\n{\r\n\tRecalcLayout();\r\n}\r\n\r\nvoid CSymbolEdit::SetSymbolIcon(HICON hIcon, BOOL redraw)\r\n{\r\n\tDestroyIcon();\r\n\r\n\tm_hSymbolIcon = hIcon;\r\n\r\n\t// icon was not loaded internally\r\n\tm_bInternalIcon = false;\r\n\r\n\tRecalcLayout();\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetSymbolIcon(UINT id, BOOL redraw)\r\n{\r\n\tDestroyIcon();\r\n\r\n\tm_hSymbolIcon = (HICON)::LoadImage(\r\n\t\tAfxGetResourceHandle(),\r\n\t\tMAKEINTRESOURCE(id),\r\n\t\tIMAGE_ICON,\r\n\t\t16,\r\n\t\t16,\r\n\t\tLR_DEFAULTCOLOR | LR_LOADTRANSPARENT);\r\n\r\n\tASSERT(m_hSymbolIcon != NULL);\r\n\r\n\t// icon was loaded internally\r\n\tm_bInternalIcon = true;\r\n\r\n\tRecalcLayout();\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetPromptText(CString text, BOOL redraw)\r\n{\r\n\tm_strPromptText = text;\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetPromptText(LPCTSTR szText, BOOL redraw)\r\n{\r\n\tm_strPromptText = szText;\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetPromptTextColor(COLORREF color, BOOL redraw)\r\n{\r\n\tm_colorPromptText = color;\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetPromptFont(CFont& font, BOOL redraw)\r\n{\r\n\tLOGFONT lf;\r\n\tmemset(&lf, 0, sizeof(LOGFONT));\r\n\r\n\tfont.GetLogFont(&lf);\r\n\tSetPromptFont(&lf);\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::SetPromptFont(const LOGFONT* lpLogFont, BOOL redraw)\r\n{\r\n\tm_fontPrompt.DeleteObject();\r\n\tm_fontPrompt.CreateFontIndirect(lpLogFont);\r\n\r\n\tif (redraw)\r\n\t\tInvalidate(TRUE);\r\n}\r\n\r\nvoid CSymbolEdit::RecalcLayout()\r\n{\r\n\tint width = GetSystemMetrics(SM_CXSMICON);\r\n\r\n\tif (m_hSymbolIcon)\r\n\t{\r\n\t\tDWORD dwMargins = GetMargins();\r\n\t\tSetMargins(LOWORD(dwMargins), width + 6);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (m_windowDpi != NULL)\r\n\t\t{\r\n\t\t\tSetMargins(m_windowDpi->Scale(4), m_windowDpi->Scale(34));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CSymbolEdit::OnPaint()\r\n{\r\n\tCPaintDC dc(this);\r\n\r\n\tCRect rect;\r\n\tGetClientRect(&rect);\r\n\r\n\tDWORD margins = GetMargins();\r\n\t\r\n\tCRect textRect(rect);\r\n\ttextRect.left += LOWORD(margins);\r\n\ttextRect.right -= HIWORD(margins);\r\n\r\n\t// Clearing the background\r\n\tdc.FillSolidRect(rect, GetSysColor(COLOR_WINDOW));\t\r\n\r\n\tif (m_hSymbolIcon)\r\n\t{\r\n\t\t// Drawing the icon\r\n\t\tint width = GetSystemMetrics(SM_CXSMICON);\r\n\t\tint height = GetSystemMetrics(SM_CYSMICON);\r\n\r\n\t\t::DrawIconEx(\r\n\t\t\tdc.m_hDC,\r\n\t\t\trect.right - width - 1,\r\n\t\t\t1,\r\n\t\t\tm_hSymbolIcon,\r\n\t\t\twidth,\r\n\t\t\theight,\r\n\t\t\t0,\r\n\t\t\tNULL,\r\n\t\t\tDI_NORMAL);\r\n\r\n\t\trect.left += LOWORD(margins) + 1;\r\n\t\trect.right -= (width + 7);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//rect.left += (LOWORD(dwMargins) + 1);\r\n\t\t//rect.right -= (HIWORD(dwMargins) + 1);\r\n\t}\r\n\r\n\tCString text;\r\n\tGetWindowText(text);\r\n\tCFont* oldFont = NULL;\r\n\r\n\t//rect.top += 1;\r\n\r\n\r\n\tif(this == GetFocus() || text.GetLength() > 0)\r\n\t{\r\n\t\tdc.FillSolidRect(rect, CGetSetOptions::m_Theme.SearchTextBoxFocusBG());\r\n\r\n\t\t//CBrush borderBrush(CGetSetOptions::m_Theme.SearchTextBoxFocusBorder());\r\n\t\t//dc.FrameRect(rect, &borderBrush);\r\n\r\n\t\t//rect.DeflateRect(1, 1, 1, 1);\r\n\t\t//textRect.DeflateRect(0, 1, 1, 1);\r\n\r\n\t\toldFont = dc.SelectObject(GetFont());\t\t\r\n\r\n\t\tCOLORREF oldColor = dc.GetTextColor();\r\n\t\tdc.SetTextColor(CGetSetOptions::m_Theme.SearchTextBoxFocusText());\r\n\t\t\t\r\n\t\tdc.DrawText(text, textRect, DT_SINGLELINE | DT_INTERNAL | DT_EDITCONTROL | DT_NOPREFIX);\r\n\r\n\t\tdc.SelectObject(oldFont);\r\n\t\tdc.SetTextColor(oldColor);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdc.FillSolidRect(rect, CGetSetOptions::m_Theme.MainWindowBG());\r\n\t}\r\n\r\n\r\n\tif (text.GetLength() == 0 && m_strPromptText.GetLength() > 0)\r\n\t{\r\n\t\t//if we aren't showing the close icon, then use the full space\r\n\t\ttextRect.right += m_windowDpi->Scale(16);\r\n\t\t//textRect.right -= LOWORD(margins);\r\n\r\n\t\toldFont = dc.SelectObject(&m_fontPrompt);\r\n\t\tCOLORREF color = dc.GetTextColor();\r\n\t\tdc.SetTextColor(m_colorPromptText);\r\n\r\n\t\tdc.DrawText(m_strPromptText, textRect, DT_LEFT | DT_SINGLELINE | DT_EDITCONTROL | DT_VCENTER | DT_NOPREFIX);\r\n\t\tdc.SetTextColor(color);\r\n\t\tdc.SelectObject(oldFont);\r\n\t}\r\n\r\n\tint right = rect.right;\r\n\tif ((text.GetLength() > 0 || this == GetFocus()))\r\n\t{\r\n\t\tm_searchesButtonRect.SetRect(rect.right - m_windowDpi->Scale(18), 0, rect.right, rect.bottom);\r\n\t\tright = rect.right - m_windowDpi->Scale(18);\r\n\t\tm_searchesButton.Draw(&dc, *m_windowDpi, this, m_searchesButtonRect.left, 4, m_mouseHoveringOverSearches, m_mouseDownOnSearches);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_searchesButtonRect.SetRect(0, 0, 0, 0);\r\n\t\t//m_searchButton.Draw(&dc, this, rect.right - 22, 4, false, false);\r\n\t}\r\n\r\n\tif (text.GetLength() > 0)\r\n\t{\r\n\t\t//OutputDebugString(_T(\"showing close button\\n\"));\r\n\r\n\t\tm_closeButtonRect.SetRect(right - m_windowDpi->Scale(16), 0, right, rect.bottom);\r\n\t\tm_closeButton.Draw(&dc, *m_windowDpi, this, m_closeButtonRect.left, 4, m_mouseHoveringOverClose, m_mouseDownOnClose);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//OutputDebugString(_T(\"not showing close button\\n\"));\r\n\t\tm_closeButtonRect.SetRect(0, 0, 0, 0);\r\n\t\t//m_searchButton.Draw(&dc, this, rect.right - 22, 4, false, false);\r\n\t}\r\n\r\n\t//OutputDebugString(_T(\"OnPaint\"));\r\n\r\n\tif (text != m_lastTextOnPaint &&\r\n\t\ttext == _T(\"\"))\r\n\t{\r\n\t\t::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\r\n\t}\r\n\r\n\tm_lastTextOnPaint = text;\r\n\r\n\t//OutputDebugString(_T(\"OnPaint \\r\\n\"));\r\n\r\n}\r\n\r\nvoid CSymbolEdit::OnSize(UINT nType, int cx, int cy)\r\n{\r\n\tCEdit::OnSize(nType, cx, cy);\r\n\r\n\tRecalcLayout();\r\n}\r\n\r\nLRESULT CSymbolEdit::OnSetFont(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tDefWindowProc(WM_SETFONT, wParam, lParam);\r\n\r\n\tRecalcLayout();\r\n\r\n\treturn 0;\r\n}\r\n\r\nHBRUSH CSymbolEdit::CtlColor(CDC* pDC, UINT n)\r\n{\r\n\tCOLORREF color = -1;\t\r\n\r\n\tif (::GetFocus() == m_hWnd)\r\n\t{\r\n\t\tpDC->SetTextColor(CGetSetOptions::m_Theme.SearchTextBoxFocusText());\r\n\t\tpDC->SetBkColor(CGetSetOptions::m_Theme.SearchTextBoxFocusBG());\r\n\t\tcolor = CGetSetOptions::m_Theme.SearchTextBoxFocusBG();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpDC->SetBkColor(CGetSetOptions::m_Theme.MainWindowBG());\r\n\t\tcolor = CGetSetOptions::m_Theme.MainWindowBG();\r\n\t}\r\n\r\n\tif (color != m_lastBrushColor)\r\n\t{\r\n\t\tDeleteObject(m_brush);\r\n\t\tm_brush.CreateSolidBrush(color);\r\n\t\tm_lastBrushColor = color;\r\n\t}\r\n\r\n\treturn m_brush;\r\n}\r\n\r\nvoid CSymbolEdit::OnSetFocus(CWnd* pOldWnd)\r\n{\r\n\t//OutputDebugString(_T(\"OnSetFocus \\r\\n\"));\r\n\r\n\t//was seeing issues when refreshing non client area inline, do it delayed\r\n\tSetTimer(1, 500, NULL);\r\n\t\r\n\tCWnd *pWnd = GetParent();\r\n\tif (pWnd)\r\n\t{\r\n\t\tif (CGetSetOptions::m_bFindAsYouType)\r\n\t\t{\r\n\t\t\tpWnd->SendMessage(NM_FOCUS_ON_SEARCH, 0, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tCEdit::OnSetFocus(pOldWnd);\r\n}\r\n\r\nvoid CSymbolEdit::OnKillFocus(CWnd* pNewWnd)\r\n{\r\n\t//OutputDebugString(_T(\"OnKillFocus \\r\\n\"));\r\n\tAddToSearchHistory();\r\n\r\n\t//was seeing issues when refreshing non client area inline, do it delayed\r\n\tSetTimer(1, 500, NULL);\r\n\t\r\n\tCEdit::OnKillFocus(pNewWnd);\r\n}\r\n\r\nBOOL CSymbolEdit::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)\r\n{\r\n\tCPoint pntCursor;\r\n\tGetCursorPos(&pntCursor);\r\n\tScreenToClient(&pntCursor);\r\n\r\n\tif(m_closeButtonRect.PtInRect(pntCursor))\r\n\t{\r\n\t\tHCURSOR h = ::LoadCursor(NULL, IDC_ARROW);\r\n\t\t::SetCursor(h);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\tif (m_searchesButtonRect.PtInRect(pntCursor))\r\n\t{\r\n\t\tHCURSOR h = ::LoadCursor(NULL, IDC_ARROW);\r\n\t\t::SetCursor(h);\r\n\t\treturn TRUE;\r\n\t}\r\n\r\n\treturn CEdit::OnSetCursor(pWnd, nHitTest, message);\r\n}\r\n\r\nvoid CSymbolEdit::OnLButtonUp(UINT nFlags, CPoint point)\r\n{\r\n\tif (m_mouseDownOnClose)\r\n\t{\r\n\t\tReleaseCapture();\r\n\t\tInvalidateRect(m_closeButtonRect);\r\n\t}\r\n\r\n\tif (m_mouseDownOnSearches)\r\n\t{\r\n\t\tReleaseCapture();\r\n\t\tInvalidateRect(m_searchesButtonRect);\r\n\t}\r\n\r\n\tm_mouseDownOnClose = false;\r\n\tm_mouseDownOnSearches = false;\r\n\r\n\tif (m_closeButtonRect.PtInRect(point))\r\n\t{\r\n\t\tif ((GetWindowTextLength() > 0))\r\n\t\t{\r\n\t\t\tCWnd *pOwner = GetOwner();\r\n\t\t\tif (pOwner)\r\n\t\t\t{\r\n\t\t\t\tpOwner->SendMessage(NM_CANCEL_SEARCH, 0, 0);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\t\r\n\r\n\tif (m_searchesButtonRect.PtInRect(point))\r\n\t{\r\n\t\tthis->ShowSearchHistoryMenu();\r\n\t}\r\n\r\n\tCEdit::OnLButtonUp(nFlags, point);\r\n}\r\n\r\nvoid CSymbolEdit::OnLButtonDown(UINT nFlags, CPoint point)\r\n{\r\n\tif (m_closeButtonRect.PtInRect(point))\r\n\t{\r\n\t\tm_mouseDownOnClose = true;\r\n\t\tSetCapture();\r\n\t\tInvalidateRect(m_closeButtonRect);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_mouseDownOnClose = false;\r\n\t}\r\n\r\n\tif (m_searchesButtonRect.PtInRect(point))\r\n\t{\r\n\t\tm_mouseDownOnSearches = true;\r\n\t\tSetCapture();\r\n\t\tInvalidateRect(m_searchesButtonRect);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_mouseDownOnSearches = false;\r\n\t}\r\n\r\n\tCEdit::OnLButtonDown(nFlags, point);\r\n\r\n\tInvalidate();\r\n}\r\n\r\nvoid CSymbolEdit::OnMouseMove(UINT nFlags, CPoint point)\r\n{\r\n\tif (m_closeButtonRect.PtInRect(point))\r\n\t{\r\n\t\tif (m_mouseHoveringOverClose == false)\r\n\t\t{\r\n\t\t\tm_mouseHoveringOverClose = true;\r\n\t\t\tInvalidateRect(m_closeButtonRect);\r\n\t\t}\r\n\t}\r\n\telse if(m_mouseHoveringOverClose)\r\n\t{\r\n\t\tm_mouseHoveringOverClose = false;\r\n\t\tInvalidateRect(m_closeButtonRect);\r\n\t}\r\n\r\n\tif (m_searchesButtonRect.PtInRect(point))\r\n\t{\r\n\t\tif (m_mouseHoveringOverSearches == false)\r\n\t\t{\r\n\t\t\tm_mouseHoveringOverSearches = true;\r\n\t\t\tInvalidateRect(m_searchesButtonRect);\r\n\t\t}\r\n\t}\r\n\telse if (m_mouseHoveringOverSearches)\r\n\t{\r\n\t\tm_mouseHoveringOverSearches = false;\r\n\t\tInvalidateRect(m_searchesButtonRect);\r\n\t}\r\n\r\n\tCEdit::OnMouseMove(nFlags, point);\r\n}\r\n\r\nvoid CSymbolEdit::OnSelectSearchString(UINT idIn)\r\n{\r\n\tint index = idIn - RANGE_START;\r\n\r\n\tif (idIn == CLEAR_LIST)\r\n\t{\r\n\t\tm_searches.RemoveAll();\r\n\t}\r\n\telse if (index >= 0 &&\r\n\t\tindex < m_searches.GetCount())\r\n\t{\r\n\t\tCString cs = m_searches[index];\r\n\t\tthis->SetWindowTextW(cs);\r\n\r\n\t\tthis->SetFocus();\r\n\t\tthis->SetSel(-1);\r\n\r\n\t\tthis->Invalidate();\r\n\r\n\t\tm_searches.RemoveAt(index);\r\n\t\tm_searches.Add(cs);\r\n\t}\r\n}\r\n\r\nbool CSymbolEdit::ApplyLastSearch()\r\n{\r\n\tbool ret = false;\r\n\tif (m_searches.GetCount() > 0)\r\n\t{\r\n\t\tCString cs = m_searches[m_searches.GetCount()-1];\r\n\t\tthis->SetWindowTextW(cs);\r\n\r\n\t\tthis->SetFocus();\r\n\t\tthis->SetSel(-1);\r\n\r\n\t\tthis->Invalidate();\r\n\r\n\t\tret = true;\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nvoid CSymbolEdit::OnDpiChanged()\r\n{\r\n\tSetDpiInfo(m_windowDpi);\r\n}\r\n\r\nvoid CSymbolEdit::SetDpiInfo(CDPI *dpi)\r\n{ \r\n\tm_windowDpi = dpi; \r\n\r\n\tm_closeButton.Reset();\r\n\tm_closeButton.LoadStdImageDPI(m_windowDpi->GetDPI(), search_close_16, search_close_20, search_close_24, search_close_28, search_close_32, _T(\"PNG\"));\r\n\r\n\tm_searchesButton.Reset();\r\n\tm_searchesButton.LoadStdImageDPI(m_windowDpi->GetDPI(), down_16, down_20, down_24, down_28, down_32, _T(\"PNG\"));\r\n\r\n\tRecalcLayout();\r\n\r\n\tInvalidate();\r\n}\r\n\r\nBOOL CSymbolEdit::OnEraseBkgnd(CDC* pDC)\r\n{\r\n\t// TODO: Add your message handler code here and/or call default\r\n\r\n\t//return CEdit::OnEraseBkgnd(pDC);\r\n\treturn FALSE;\r\n}\r\n\r\n\r\nvoid CSymbolEdit::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp)\r\n{\r\n\tCString text;\r\n\tGetWindowText(text);\r\n\r\n\t//if (text.GetLength() > 0 || this == GetFocus())\r\n\tif (m_windowDpi != NULL)\r\n\t{\r\n\t\tlpncsp->rgrc[0].left += m_windowDpi->Scale(1);\r\n\t\tlpncsp->rgrc[0].top += m_windowDpi->Scale(1);\r\n\t\tlpncsp->rgrc[0].right -= m_windowDpi->Scale(1);\r\n\t\tlpncsp->rgrc[0].bottom -= m_windowDpi->Scale(1);\r\n\r\n\r\n\t\tCRect rectWnd, rectClient;\r\n\r\n\t\t////calculate client area height needed for a font\r\n\t\tCFont *pFont = GetFont();\r\n\t\tCRect rectText;\r\n\r\n\r\n\t\tCDC *pDC = GetDC();\r\n\r\n\t\tCFont *pOld = pDC->SelectObject(pFont);\r\n\t\tpDC->DrawText(\"Ky\", rectText, DT_CALCRECT | DT_LEFT);\r\n\t\tUINT uiVClientHeight = rectText.Height();\r\n\r\n\t\tpDC->SelectObject(pOld);\r\n\t\tReleaseDC(pDC);\r\n\r\n\r\n\r\n\t\t////calculate NC area to center text.\r\n\r\n\t\t//GetClientRect(rectClient);\r\n\t\tGetWindowRect(rectWnd);\r\n\r\n\t\trectWnd.DeflateRect(m_windowDpi->Scale(1), m_windowDpi->Scale(1));\r\n\r\n\t\tm_centerTextDiff = (rectWnd.Height() - uiVClientHeight) / 2;\r\n\r\n\t\tif (m_centerTextDiff < 0 || m_centerTextDiff > uiVClientHeight)\r\n\t\t{\r\n\t\t\tm_centerTextDiff = 0;\r\n\t\t}\r\n\r\n\t\tlpncsp->rgrc[0].top += m_centerTextDiff;\r\n\t\tlpncsp->rgrc[0].bottom -= m_centerTextDiff;\r\n\t}\r\n\r\n\t//ClientToScreen(rectClient);\r\n\r\n\t//UINT uiCenterOffset = (rectWnd.Height() - uiVClientHeight) / 2;\r\n\t//UINT uiCY = (rectWnd.Heig%ht() - rectClient.Height()) / 2;\r\n\t//UINT uiCX = (rectWnd.Width() - rectClient.Width()) / 2;\r\n\r\n\t//rectWnd.OffsetRect(-rectWnd.left, -rectWnd.top);\r\n\t//m_rectNCTop = rectWnd;\r\n\t\t\r\n\t//m_rectNCTop.DeflateRect(uiCX, uiCY, uiCX, uiCenterOffset + uiVClientHeight + uiCY);\r\n\r\n\t//m_rectNCBottom = rectWnd;\r\n\r\n\t//m_rectNCBottom.DeflateRect(uiCX, uiCenterOffset + uiVClientHeight + uiCY, uiCX, uiCY);\r\n\r\n\t//lpncsp->rgrc[0].top += uiCenterOffset;\r\n\t//lpncsp->rgrc[0].bottom -= uiCenterOffset;\r\n\r\n\t//lpncsp->rgrc[0].left += uiCX;\r\n\t//lpncsp->rgrc[0].right -= uiCY;\r\n\r\n\t//CEdit::OnNcCalcSize(bCalcValidRects, lpncsp);\r\n}\r\n\r\n\r\nvoid CSymbolEdit::OnNcPaint()\r\n{\r\n\r\n\tCString text;\r\n\tGetWindowText(text);\r\n\r\n\tCWindowDC dc(this);\r\n\t\r\n\tCRect r;\r\n\tthis->GetWindowRect(r);\r\n\tthis->ScreenToClient(r);\r\n\r\n\tCRect t(0, 0, r.Width(), m_centerTextDiff+ m_windowDpi->Scale(1));\r\n\r\n\tCRect b(0, r.Height() - m_centerTextDiff- m_windowDpi->Scale(1), r.Width(), r.Height());\r\n\r\n\tCOLORREF c = CGetSetOptions::m_Theme.MainWindowBG();\r\n\r\n\tif (this == GetFocus() || text.GetLength() > 0)\r\n\t{\t\t\r\n\t\tdc.FillSolidRect(t, CGetSetOptions::m_Theme.SearchTextBoxFocusBG());\r\n\t\tdc.FillSolidRect(b, CGetSetOptions::m_Theme.SearchTextBoxFocusBG());\r\n\r\n\t\tc = CGetSetOptions::m_Theme.SearchTextBoxFocusBorder();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdc.FillSolidRect(t, CGetSetOptions::m_Theme.MainWindowBG());\r\n\t\tdc.FillSolidRect(b, CGetSetOptions::m_Theme.MainWindowBG());\r\n\t}\t\r\n\r\n\t//if ((text.GetLength() > 0 || this == GetFocus()) && m_windowDpi)\r\n\t{\r\n\t\tCWindowDC dc(this);\r\n\r\n\t\tCRect rcFrame;\r\n\t\tthis->GetWindowRect(rcFrame);\r\n\t\tthis->ScreenToClient(rcFrame);\r\n\r\n\t\tCRect rcBorder(0, 0, rcFrame.Width(), rcFrame.Height());\r\n\r\n\t\tint border = m_windowDpi->Scale(1);\r\n\t\tCBrush borderBrush(c);\r\n\r\n\t\tfor (int x = 0; x < border; x++)\r\n\t\t{\r\n\t\t\tdc.FrameRect(rcBorder, &borderBrush);\r\n\t\t\trcBorder.DeflateRect(1, 1, 1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t//OutputDebugString(_T(\"OnNCPaint \\r\\n\"));\r\n}\r\n\r\nvoid CSymbolEdit::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n\tswitch (nIDEvent)\r\n\t{\r\n\tcase 1:\r\n\t\t\tKillTimer(1);\r\n\t\t\t//Invalidate();\r\n\t\t\t::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tCEdit::OnTimer(nIDEvent);\r\n}\r\n"
        },
        {
          "name": "SymbolEdit.h",
          "type": "blob",
          "size": 3.625,
          "content": "/************************************************************************/\r\n/* Created by MARIUS BANCILA\r\n/*            www.mariusbancila.ro\r\n/* Copyright (C) 2008 MARIUS BANCILA. All rights reserved.\r\n/*\r\n/* Permission is given by the author to freely redistribute and\r\n/* include this code in any program as long as this credit is\r\n/* given where due.\r\n/*\r\n/* CODE IS PROVIDED UNDER THIS LICENSE ON AN \"AS IS\" BASIS,\r\n/* WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\r\n/* INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE CODE\r\n/* IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE\r\n/* OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND\r\n/* PERFORMANCE OF THE CODE IS WITH YOU. SHOULD ANY\r\n/* CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL\r\n/* DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE COST OF ANY\r\n/* NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF\r\n/* WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE\r\n/* OF ANY CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER\r\n/* THIS DISCLAIMER.\r\n/*\r\n/************************************************************************/\r\n\r\n\r\n\r\n#pragma once\r\n\r\n#include \"GdiImageDrawer.h\"\r\n#include \"Accels.h\"\r\n#include \"DPI.h\"\r\n\r\n// CSymbolEdit\r\n\r\nclass CSymbolEdit : public CEdit\r\n{\r\n\tDECLARE_DYNAMIC(CSymbolEdit)\r\n\r\n\tCFont m_fontPrompt;\r\n\tHICON m_hSymbolIcon;\r\n\tbool m_bInternalIcon;\r\n\tCString m_strPromptText;\r\n\tCOLORREF m_colorPromptText;\r\n\r\n\tCBrush m_brush;\r\n\tCOLORREF m_lastBrushColor;\r\n\r\n\tvoid DestroyIcon();\r\n\r\npublic:\r\n\tCSymbolEdit();\r\n\tvirtual ~CSymbolEdit();\r\n\r\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\r\n\r\n\tvoid AddToSearchHistory();\r\n\r\n\tbool ShowSearchHistoryMenu();\r\n\r\n\tvoid SetSymbolIcon(HICON hIcon, BOOL redraw = TRUE);\r\n\tvoid SetSymbolIcon(UINT id, BOOL redraw = TRUE);\r\n\r\n\tvoid SetPromptText(CString text, BOOL redraw = TRUE);\r\n\tvoid SetPromptText(LPCTSTR szText, BOOL redraw = TRUE);\r\n\r\n\tvoid SetPromptTextColor(COLORREF color, BOOL redraw = TRUE);\r\n\r\n\tvoid SetPromptFont(CFont& font, BOOL redraw = TRUE);\r\n\tvoid SetPromptFont(const LOGFONT* lpLogFont, BOOL redraw = TRUE);\r\n\r\n\tbool ApplyLastSearch();\r\n\r\n\tvoid SetLastSearchAccel(CAccel a) { m_lastSearchShortCut = a; }\r\n\r\n\tCString SavePastSearches();\r\n\tvoid LoadPastSearches(CString values);\r\n\r\n\tvoid SetDpiInfo(CDPI *dpi);\r\n\r\n\tvoid OnDpiChanged();\r\n\r\n\t//void SetWindowTextEx(LPCSTR)\r\n\r\nprotected:\r\n\t\r\n\t//CGdiImageDrawer m_searchButton;\r\n\tCGdiImageDrawer m_closeButton;\r\n\tCRect m_closeButtonRect;\r\n\tbool m_mouseDownOnClose;\r\n\tbool m_mouseHoveringOverClose;\r\n\r\n\tCGdiImageDrawer m_searchesButton;\r\n\tCRect m_searchesButtonRect;\r\n\tbool m_mouseDownOnSearches;\r\n\tbool m_mouseHoveringOverSearches;\r\n\r\n\tCAccel m_lastSearchShortCut;\r\n\r\n\tCStringArray m_searches;\r\n\r\n\tvoid RecalcLayout();\r\n\tvirtual void PreSubclassWindow();\r\n\r\n\tCDPI *m_windowDpi;\r\n\r\n\tint m_centerTextDiff;\r\n\tCString m_lastTextOnPaint;\r\n\r\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\r\n\tafx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);\r\n\t//afx_msg LRESULT OnMenuExit(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg HBRUSH CtlColor(CDC* pDC, UINT n);\r\n\tafx_msg void OnSetFocus(CWnd* pOldWnd);\r\n\tafx_msg void OnKillFocus(CWnd* pNewWnd);\r\n\tafx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);\r\n\tafx_msg void OnLButtonDown(UINT nFlags, CPoint point);\r\n\tafx_msg void OnLButtonUp(UINT nFlags, CPoint point);\r\n\tafx_msg void OnMouseMove(UINT nFlags, CPoint point);\r\n\tafx_msg void OnSelectSearchString(UINT idIn);\r\n\r\n\tDECLARE_MESSAGE_MAP()\r\n\r\npublic:\r\n\tafx_msg void OnPaint();\r\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\r\n\tafx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);\r\n\tafx_msg void OnNcPaint();\r\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\r\n};\r\n\r\n\r\n"
        },
        {
          "name": "SystemTray.cpp",
          "type": "blob",
          "size": 32.8134765625,
          "content": "/////////////////////////////////////////////////////////////////////////////\r\n// SystemTray.cpp : implementation file\r\n//\r\n// MFC VERSION\r\n//\r\n// This is a conglomeration of ideas from the MSJ \"Webster\" application,\r\n// sniffing round the online docs, and from other implementations such\r\n// as PJ Naughter's \"CTrayNotifyIcon\" (http://indigo.ie/~pjn/ntray.html)\r\n// especially the \"CSystemTray::OnTrayNotification\" member function.\r\n// Joerg Koenig suggested the icon animation stuff\r\n//\r\n// This class is a light wrapper around the windows system tray stuff. It\r\n// adds an icon to the system tray with the specified ToolTip text and \r\n// callback notification value, which is sent back to the Parent window.\r\n//\r\n// The tray icon can be instantiated using either the constructor or by\r\n// declaring the object and creating (and displaying) it later on in the\r\n// program. eg.\r\n//\r\n//        CSystemTray m_SystemTray;    // Member variable of some class\r\n//        \r\n//        ... \r\n//        // in some member function maybe...\r\n//        m_SystemTray.Create(pParentWnd, WM_MY_NOTIFY, \"Click here\", \r\n//                          hIcon, nSystemTrayID);\r\n//\r\n// Written by Chris Maunder (cmaunder@mail.com)\r\n// Copyright (c) 1998.\r\n//\r\n// Updated: 25 Jul 1998 - Added icon animation, and derived class\r\n//                        from CWnd in order to handle messages. (CJM)\r\n//                        (icon animation suggested by Joerg Koenig.\r\n//                        Added API to set default menu item. Code provided\r\n//                        by Enrico Lelina.\r\n//\r\n// Updated: 6 June 1999 - SetIcon can now load non-standard sized icons (Chip Calvert)\r\n//                        Added \"bHidden\" parameter when creating icon\r\n//                        (Thanks to Michael Gombar for these suggestions)\r\n//                        Restricted tooltip text to 64 characters.\r\n//\r\n// Updated: 9 Nov 1999  - Now works in WindowsCE.\r\n//                        Fix for use in NT services (Thomas Mooney, TeleProc, Inc)\r\n//                        Added W2K stuff by Michael Dunn\r\n//\r\n// Updated: 1 Jan 2000  - Added tray minimisation stuff.\r\n// \r\n// Updated: 21 Sep 2000 - Added GetDoWndAnimation - animation only occurs if the system\r\n//                        settings allow it (Matthew Ellis). Updated the GetTrayWndRect\r\n//                        function to include more fallback logic (Matthew Ellis)\r\n//                        NOTE: Signature of GetTrayWndRect has changed!\r\n//\r\n// Updated: 16 Jun 2002 - Fixed stupid errors so that it compiles clean on VC7\r\n//\r\n// This code may be used in compiled form in any way you desire. This\r\n// file may be redistributed unmodified by any means PROVIDING it is \r\n// not sold for profit without the authors written consent, and \r\n// providing that this notice and the authors name is included. If \r\n// the source code in  this file is used in any commercial application \r\n// then acknowledgement must be made to the author of this file \r\n// (in whatever form you wish).\r\n//\r\n// This file is provided \"as is\" with no expressed or implied warranty.\r\n// The author accepts no liability for any damage caused through use.\r\n//\r\n// Expect bugs.\r\n// \r\n// Please use and enjoy. Please let me know of any bugs/mods/improvements \r\n// that you have found/implemented and I will fix/incorporate them into this\r\n// file. \r\n//\r\n/////////////////////////////////////////////////////////////////////////////\r\n    \r\n#include \"stdafx.h\"\r\n#include \"SystemTray.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n#ifndef _WIN32_WCE  // Use C++ exception handling instead of structured.\r\n#undef TRY\r\n#undef CATCH\r\n#undef END_CATCH\r\n#define TRY try\r\n#define CATCH(ex_class, ex_object) catch(ex_class* ex_object)\r\n#define END_CATCH\r\n#endif  // _WIN32_WCE\r\n\r\n#ifndef _countof\r\n#define _countof(x) ( sizeof(x) / sizeof(x[0]) )\r\n#endif\r\n\r\nIMPLEMENT_DYNAMIC(CSystemTray, CWnd)\r\n\r\nconst UINT CSystemTray::m_nTimerID    = 4567;\r\nUINT CSystemTray::m_nMaxTooltipLength  = 64;     // This may change...\r\nconst UINT CSystemTray::m_nTaskbarCreatedMsg = ::RegisterWindowMessage(_T(\"TaskbarCreated\"));\r\nCTrayWnd  CSystemTray::m_wndInvisible;\r\nBOOL CSystemTray::m_bShowWndAnimation;\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray construction/creation/destruction\r\n\r\nCSystemTray::CSystemTray()\r\n{\r\n    Initialise();\r\n}\r\n\r\nCSystemTray::CSystemTray(CWnd* pParent,             // The window that will recieve tray notifications\r\n                         UINT uCallbackMessage,     // the callback message to send to parent\r\n                         LPCTSTR szToolTip,         // tray icon tooltip\r\n                         HICON icon,                // Handle to icon\r\n                         UINT uID,                  // Identifier of tray icon\r\n                         BOOL bHidden /*=FALSE*/,   // Hidden on creation?                  \r\n                         LPCTSTR szBalloonTip /*=NULL*/,    // Ballon tip (w2k only)\r\n                         LPCTSTR szBalloonTitle /*=NULL*/,  // Balloon tip title (w2k)\r\n                         DWORD dwBalloonIcon /*=NIIF_NONE*/,// Ballon tip icon (w2k)\r\n                         UINT uBalloonTimeout /*=10*/)      // Balloon timeout (w2k)\r\n{\r\n    Initialise();\r\n    Create(pParent, uCallbackMessage, szToolTip, icon, uID, bHidden,\r\n           szBalloonTip, szBalloonTitle, dwBalloonIcon, uBalloonTimeout);\r\n}\r\n\r\n\r\nvoid CSystemTray::Initialise()\r\n{\r\n    memset(&m_tnd, 0, sizeof(m_tnd));\r\n\r\n    m_bEnabled = FALSE;\r\n    m_bHidden  = TRUE;\r\n    m_bRemoved = TRUE;\r\n\r\n    m_DefaultMenuItemID    = 0;\r\n    m_DefaultMenuItemByPos = TRUE;\r\n\r\n    m_bShowIconPending = FALSE;\r\n\r\n    m_uIDTimer   = 0;\r\n    m_hSavedIcon = NULL;\r\n\r\n\tm_pTargetWnd = NULL;\r\n\tm_uCreationFlags = 0;\r\n\r\n\tm_bShowWndAnimation = FALSE;\r\n\r\n\tm_bSingleClickSelect = FALSE;\r\n\r\n#ifdef SYSTEMTRAY_USEW2K\r\n    //OSVERSIONINFOW os = { sizeof(os) };\r\n\t//GetVersionExW(&os);\r\n\tm_bWin2K = true;// (VER_PLATFORM_WIN32_NT == os.dwPlatformId && os.dwMajorVersion >= 5);\r\n#else\r\n    m_bWin2K = FALSE;\r\n#endif\r\n}\r\n\r\n// update by Michael Dunn, November 1999\r\n//\r\n//  New version of Create() that handles new features in Win 2K.\r\n//\r\n// Changes:\r\n//  szTip: Same as old, but can be 128 characters instead of 64.\r\n//  szBalloonTip: Text for a balloon tooltip that is shown when the icon\r\n//                is first added to the tray.  Pass \"\" if you don't want\r\n//                a balloon.\r\n//  szBalloonTitle: Title text for the balloon tooltip.  This text is shown\r\n//                  in bold above the szBalloonTip text.  Pass \"\" if you\r\n//                  don't want a title.\r\n//  dwBalloonIcon: Specifies which icon will appear in the balloon.  Legal\r\n//                 values are:\r\n//                     NIIF_NONE: No icon\r\n//                     NIIF_INFO: Information\r\n//                     NIIF_WARNING: Exclamation\r\n//                     NIIF_ERROR: Critical error (red circle with X)\r\n//  uBalloonTimeout: Number of seconds for the balloon to remain visible.\r\n//                   Must be between 10 and 30 inclusive.\r\n\r\nBOOL CSystemTray::Create(CWnd* pParent, UINT uCallbackMessage, LPCTSTR szToolTip, \r\n                         HICON icon, UINT uID, BOOL bHidden /*=FALSE*/,\r\n                         LPCTSTR szBalloonTip /*=NULL*/, \r\n                         LPCTSTR szBalloonTitle /*=NULL*/,  \r\n                         DWORD dwBalloonIcon /*=NIIF_NONE*/,\r\n                         UINT uBalloonTimeout /*=10*/)\r\n{\r\n#ifdef _WIN32_WCE\r\n    m_bEnabled = TRUE;\r\n#else\r\n    // this is only for Windows 95 (or higher)\r\n\tm_bEnabled = true;// (GetVersion() & 0xff) >= 4;\r\n    if (!m_bEnabled) \r\n    {\r\n        ASSERT(FALSE);\r\n        return FALSE;\r\n    }\r\n#endif\r\n\r\n    m_nMaxTooltipLength = _countof(m_tnd.szTip);\r\n    \r\n    // Make sure we avoid conflict with other messages\r\n    ASSERT(uCallbackMessage >= WM_APP);\r\n\r\n    // Tray only supports tooltip text up to m_nMaxTooltipLength) characters\r\n    ASSERT(AfxIsValidString(szToolTip));\r\n    ASSERT(_tcslen(szToolTip) <= m_nMaxTooltipLength);\r\n\r\n    // Create an invisible window\r\n    CWnd::CreateEx(0, AfxRegisterWndClass(0), _T(\"\"), WS_POPUP, 0,0,0,0, NULL, 0);\r\n\r\n    // load up the NOTIFYICONDATA structure\r\n    m_tnd.cbSize = sizeof(NOTIFYICONDATA);\r\n    m_tnd.hWnd   = pParent->GetSafeHwnd()? pParent->GetSafeHwnd() : m_hWnd;\r\n    m_tnd.uID    = uID;\r\n    m_tnd.hIcon  = icon;\r\n    m_tnd.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;\r\n    m_tnd.uCallbackMessage = uCallbackMessage;\r\n    _tcsncpy(m_tnd.szTip, szToolTip, m_nMaxTooltipLength-1);\r\n\r\n#ifdef SYSTEMTRAY_USEW2K\r\n    if (m_bWin2K && szBalloonTip)\r\n    {\r\n        // The balloon tooltip text can be up to 255 chars long.\r\n        ASSERT(AfxIsValidString(szBalloonTip));\r\n        ASSERT(lstrlen(szBalloonTip) < 256);\r\n\r\n        // The balloon title text can be up to 63 chars long.\r\n        if (szBalloonTitle)\r\n        {\r\n            ASSERT(AfxIsValidString(szBalloonTitle));\r\n            ASSERT(lstrlen(szBalloonTitle) < 64);\r\n        }\r\n\r\n        // dwBalloonIcon must be valid.\r\n        ASSERT(NIIF_NONE == dwBalloonIcon    || NIIF_INFO == dwBalloonIcon ||\r\n               NIIF_WARNING == dwBalloonIcon || NIIF_ERROR == dwBalloonIcon);\r\n\r\n        // The timeout must be between 10 and 30 seconds.\r\n        ASSERT(uBalloonTimeout >= 10 && uBalloonTimeout <= 30);\r\n\r\n        m_tnd.uFlags |= NIF_INFO;\r\n\r\n        _tcsncpy(m_tnd.szInfo, szBalloonTip, 255);\r\n        if (szBalloonTitle)\r\n            _tcsncpy(m_tnd.szInfoTitle, szBalloonTitle, 63);\r\n        else\r\n            m_tnd.szInfoTitle[0] = _T('\\0');\r\n        m_tnd.uTimeout    = uBalloonTimeout * 1000; // convert time to ms\r\n        m_tnd.dwInfoFlags = dwBalloonIcon;\r\n    }\r\n#endif\r\n\r\n    m_bHidden = bHidden;\r\n\r\n#ifdef SYSTEMTRAY_USEW2K    \r\n    if (m_bWin2K && m_bHidden)\r\n    {\r\n        m_tnd.uFlags = NIF_STATE;\r\n        m_tnd.dwState = NIS_HIDDEN;\r\n        m_tnd.dwStateMask = NIS_HIDDEN;\r\n    }\r\n#endif\r\n\r\n\tm_uCreationFlags = m_tnd.uFlags;\t// Store in case we need to recreate in OnTaskBarCreate\r\n\r\n    BOOL bResult = TRUE;\r\n    if (!m_bHidden || m_bWin2K)\r\n    {\r\n        bResult = Shell_NotifyIcon(NIM_ADD, &m_tnd);\r\n        m_bShowIconPending = m_bHidden = m_bRemoved = !bResult;\r\n    }\r\n    \r\n#ifdef SYSTEMTRAY_USEW2K    \r\n    if (m_bWin2K && szBalloonTip)\r\n    {\r\n        // Zero out the balloon text string so that later operations won't redisplay\r\n        // the balloon.\r\n        m_tnd.szInfo[0] = _T('\\0');\r\n    }\r\n#endif\r\n\r\n    return bResult;\r\n}\r\n\r\nCSystemTray::~CSystemTray()\r\n{\r\n    RemoveIcon();\r\n    m_IconList.RemoveAll();\r\n    DestroyWindow();\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray icon manipulation\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//\r\n// Function:    SetFocus()\r\n//\r\n// Description:\r\n//  Sets the focus to the tray icon.  Microsoft's Win 2K UI guidelines\r\n//  say you should do this after the user dismisses the icon's context\r\n//  menu.\r\n//\r\n// Input:\r\n//  Nothing.\r\n//\r\n// Returns:\r\n//  Nothing.\r\n//\r\n//////////////////////////////////////////////////////////////////////////\r\n// Added by Michael Dunn, November, 1999\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nvoid CSystemTray::SetFocus()\r\n{\r\n#ifdef SYSTEMTRAY_USEW2K\r\n    Shell_NotifyIcon ( NIM_SETFOCUS, &m_tnd );\r\n#endif\r\n}\r\n\r\nBOOL CSystemTray::MoveToRight()\r\n{\r\n    RemoveIcon();\r\n    return AddIcon();\r\n}\r\n\r\nBOOL CSystemTray::AddIcon()\r\n{\r\n    if (!m_bRemoved)\r\n        RemoveIcon();\r\n\r\n    if (m_bEnabled)\r\n    {\r\n        m_tnd.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;\r\n        if (!Shell_NotifyIcon(NIM_ADD, &m_tnd))\r\n            m_bShowIconPending = TRUE;\r\n        else\r\n            m_bRemoved = m_bHidden = FALSE;\r\n    }\r\n    return (m_bRemoved == FALSE);\r\n}\r\n\r\nBOOL CSystemTray::RemoveIcon()\r\n{\r\n    m_bShowIconPending = FALSE;\r\n\r\n    if (!m_bEnabled || m_bRemoved)\r\n        return TRUE;\r\n\r\n    m_tnd.uFlags = 0;\r\n    if (Shell_NotifyIcon(NIM_DELETE, &m_tnd))\r\n        m_bRemoved = m_bHidden = TRUE;\r\n\r\n    return (m_bRemoved == TRUE);\r\n}\r\n\r\nBOOL CSystemTray::HideIcon()\r\n{\r\n    if (!m_bEnabled || m_bRemoved || m_bHidden)\r\n        return TRUE;\r\n\r\n#ifdef SYSTEMTRAY_USEW2K\r\n    if (m_bWin2K)\r\n    {\r\n        m_tnd.uFlags = NIF_STATE;\r\n        m_tnd.dwState = NIS_HIDDEN;\r\n        m_tnd.dwStateMask = NIS_HIDDEN;\r\n\r\n        m_bHidden = Shell_NotifyIcon( NIM_MODIFY, &m_tnd);\r\n    }\r\n    else\r\n#endif\r\n        RemoveIcon();\r\n\r\n    return (m_bHidden == TRUE);\r\n}\r\n\r\nBOOL CSystemTray::ShowIcon()\r\n{\r\n    if (m_bRemoved)\r\n        return AddIcon();\r\n\r\n    if (!m_bHidden)\r\n        return TRUE;\r\n\r\n#ifdef SYSTEMTRAY_USEW2K\r\n    if (m_bWin2K)\r\n    {\r\n        m_tnd.uFlags = NIF_STATE;\r\n        m_tnd.dwState = 0;\r\n        m_tnd.dwStateMask = NIS_HIDDEN;\r\n        m_bHidden = !Shell_NotifyIcon ( NIM_MODIFY, &m_tnd );\r\n    }\r\n    else\r\n#endif\r\n        AddIcon();\r\n\r\n    return (m_bHidden == FALSE);\r\n}\r\n\r\nBOOL CSystemTray::SetIcon(HICON hIcon)\r\n{\r\n    if (!m_bEnabled)\r\n        return FALSE;\r\n\r\n    m_tnd.uFlags = NIF_ICON;\r\n    m_tnd.hIcon = hIcon;\r\n\r\n    if (m_bHidden)\r\n        return TRUE;\r\n    else\r\n        return Shell_NotifyIcon(NIM_MODIFY, &m_tnd);\r\n}\r\n\r\nBOOL CSystemTray::SetIcon(LPCTSTR lpszIconName)\r\n{\r\n    HICON hIcon = (HICON) ::LoadImage(AfxGetResourceHandle(), \r\n                                      lpszIconName,\r\n                                      IMAGE_ICON, \r\n                                      0, 0,\r\n                                      LR_DEFAULTCOLOR | LR_SHARED);\r\n\r\n    return SetIcon(hIcon);\r\n}\r\n\r\nBOOL CSystemTray::SetIcon(UINT nIDResource)\r\n{\r\n    return SetIcon(MAKEINTRESOURCE(nIDResource));\r\n}\r\n\r\nBOOL CSystemTray::SetStandardIcon(LPCTSTR lpIconName)\r\n{\r\n    HICON hIcon = LoadIcon(NULL, lpIconName);\r\n\r\n    return SetIcon(hIcon);\r\n}\r\n\r\nBOOL CSystemTray::SetStandardIcon(UINT nIDResource)\r\n{\r\n\treturn SetStandardIcon(MAKEINTRESOURCE(nIDResource));\r\n}\r\n \r\nHICON CSystemTray::GetIcon() const\r\n{\r\n    return (m_bEnabled)? m_tnd.hIcon : NULL;\r\n}\r\n\r\nBOOL CSystemTray::SetIconList(UINT uFirstIconID, UINT uLastIconID) \r\n{\r\n\tif (uFirstIconID > uLastIconID)\r\n        return FALSE;\r\n\r\n\tconst CWinApp* pApp = AfxGetApp();\r\n    if (!pApp)\r\n    {\r\n        ASSERT(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    m_IconList.RemoveAll();\r\n    TRY {\r\n\t    for (UINT i = uFirstIconID; i <= uLastIconID; i++)\r\n\t\t    m_IconList.Add(pApp->LoadIcon(i));\r\n    }\r\n    CATCH(CMemoryException, e)\r\n    {\r\n        e->ReportError();\r\n        e->Delete();\r\n        m_IconList.RemoveAll();\r\n        return FALSE;\r\n    }\r\n    END_CATCH\r\n\r\n    return TRUE;\r\n}\r\n\r\nBOOL CSystemTray::SetIconList(HICON* pHIconList, UINT nNumIcons)\r\n{\r\n    m_IconList.RemoveAll();\r\n\r\n    TRY {\r\n\t    for (UINT i = 0; i <= nNumIcons; i++)\r\n\t\t    m_IconList.Add(pHIconList[i]);\r\n    }\r\n    CATCH (CMemoryException, e)\r\n    {\r\n        e->ReportError();\r\n        e->Delete();\r\n        m_IconList.RemoveAll();\r\n        return FALSE;\r\n    }\r\n    END_CATCH\r\n\r\n    return TRUE;\r\n}\r\n\r\nBOOL CSystemTray::Animate(UINT nDelayMilliSeconds, int nNumSeconds /*=-1*/)\r\n{\r\n    StopAnimation();\r\n\r\n    m_nCurrentIcon = 0;\r\n    m_StartTime = COleDateTime::GetCurrentTime();\r\n    m_nAnimationPeriod = nNumSeconds;\r\n    m_hSavedIcon = GetIcon();\r\n\r\n\t// Setup a timer for the animation\r\n\tm_uIDTimer = (UINT)SetTimer(m_nTimerID, nDelayMilliSeconds, NULL);\r\n\r\n    return (m_uIDTimer != 0);\r\n}\r\n\r\nBOOL CSystemTray::StepAnimation()\r\n{\r\n    if (!m_IconList.GetSize())\r\n        return FALSE;\r\n\r\n    m_nCurrentIcon++;\r\n    if (m_nCurrentIcon >= m_IconList.GetSize())\r\n        m_nCurrentIcon = 0;\r\n\r\n    return SetIcon(m_IconList[m_nCurrentIcon]);\r\n}\r\n\r\nBOOL CSystemTray::StopAnimation()\r\n{\r\n    BOOL bResult = FALSE;\r\n\r\n    if (m_uIDTimer)\r\n\t    bResult = KillTimer(m_uIDTimer);\r\n    m_uIDTimer = 0;\r\n\r\n    if (m_hSavedIcon)\r\n        SetIcon(m_hSavedIcon);\r\n    m_hSavedIcon = NULL;\r\n\r\n    return bResult;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray tooltip text manipulation\r\n\r\nBOOL CSystemTray::SetTooltipText(LPCTSTR pszTip)\r\n{\r\n    ASSERT(AfxIsValidString(pszTip)); // (md)\r\n    ASSERT(_tcslen(pszTip) < m_nMaxTooltipLength);\r\n\r\n    if (!m_bEnabled) \r\n        return FALSE;\r\n\r\n    m_tnd.uFlags = NIF_TIP;\r\n    _tcsncpy(m_tnd.szTip, pszTip, m_nMaxTooltipLength-1);\r\n\r\n    if (m_bHidden)\r\n        return TRUE;\r\n    else\r\n        return Shell_NotifyIcon(NIM_MODIFY, &m_tnd);\r\n}\r\n\r\nBOOL CSystemTray::SetTooltipText(UINT nID)\r\n{\r\n    CString strText;\r\n    VERIFY(strText.LoadString(nID));\r\n\r\n    return SetTooltipText(strText);\r\n}\r\n\r\nCString CSystemTray::GetTooltipText() const\r\n{\r\n    CString strText;\r\n    if (m_bEnabled)\r\n        strText = m_tnd.szTip;\r\n\r\n    return strText;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray support for Win 2K features.\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//\r\n// Function:    ShowBalloon\r\n//\r\n// Description:\r\n//  Shows a balloon tooltip over the tray icon.\r\n//\r\n// Input:\r\n//  szText: [in] Text for the balloon tooltip.\r\n//  szTitle: [in] Title for the balloon.  This text is shown in bold above\r\n//           the tooltip text (szText).  Pass \"\" if you don't want a title.\r\n//  dwIcon: [in] Specifies an icon to appear in the balloon.  Legal values are:\r\n//                 NIIF_NONE: No icon\r\n//                 NIIF_INFO: Information\r\n//                 NIIF_WARNING: Exclamation\r\n//                 NIIF_ERROR: Critical error (red circle with X)\r\n//  uTimeout: [in] Number of seconds for the balloon to remain visible.  Can\r\n//            be between 10 and 30 inclusive.\r\n//\r\n// Returns:\r\n//  TRUE if successful, FALSE if not.\r\n//\r\n//////////////////////////////////////////////////////////////////////////\r\n// Added by Michael Dunn, November 1999\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\nBOOL CSystemTray::ShowBalloon(LPCTSTR szText,\r\n                              LPCTSTR szTitle  /*=NULL*/,\r\n                              DWORD   dwIcon   /*=NIIF_NONE*/,\r\n                              UINT    uTimeout /*=10*/ )\r\n{\r\n#ifndef SYSTEMTRAY_USEW2K\r\n    return FALSE;\r\n#else\r\n    // Bail out if we're not on Win 2K.\r\n    if (!m_bWin2K)\r\n        return FALSE;\r\n\r\n    // Verify input parameters.\r\n\r\n    // The balloon tooltip text can be up to 255 chars long.\r\n    ASSERT(AfxIsValidString(szText));\r\n    ASSERT(lstrlen(szText) < 256);\r\n\r\n    // The balloon title text can be up to 63 chars long.\r\n    if (szTitle)\r\n    {\r\n        ASSERT(AfxIsValidString( szTitle));\r\n        ASSERT(lstrlen(szTitle) < 64);\r\n    }\r\n\r\n    // dwBalloonIcon must be valid.\r\n    ASSERT(NIIF_NONE == dwIcon    || NIIF_INFO == dwIcon ||\r\n           NIIF_WARNING == dwIcon || NIIF_ERROR == dwIcon);\r\n\r\n    // The timeout must be between 10 and 30 seconds.\r\n    ASSERT(uTimeout >= 0 && uTimeout <= 30);\r\n\r\n\r\n    m_tnd.uFlags = NIF_INFO;\r\n    _tcsncpy(m_tnd.szInfo, szText, 256);\r\n    if (szTitle)\r\n        _tcsncpy(m_tnd.szInfoTitle, szTitle, 64);\r\n    else\r\n        m_tnd.szInfoTitle[0] = _T('\\0');\r\n    m_tnd.dwInfoFlags = dwIcon;\r\n    m_tnd.uTimeout = uTimeout * 1000;   // convert time to ms\r\n\r\n    BOOL bSuccess = Shell_NotifyIcon (NIM_MODIFY, &m_tnd);\r\n\r\n    // Zero out the balloon text string so that later operations won't redisplay\r\n    // the balloon.\r\n    m_tnd.szInfo[0] = _T('\\0');\r\n\r\n    return bSuccess;\r\n#endif\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray notification window stuff\r\n\r\nBOOL CSystemTray::SetNotificationWnd(CWnd* pWnd)\r\n{\r\n    if (!m_bEnabled) \r\n        return FALSE;\r\n\r\n    // Make sure Notification window is valid\r\n    if (!pWnd || !::IsWindow(pWnd->GetSafeHwnd()))\r\n    {\r\n        ASSERT(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    m_tnd.hWnd = pWnd->GetSafeHwnd();\r\n    m_tnd.uFlags = 0;\r\n\r\n    if (m_bHidden)\r\n        return TRUE;\r\n    else\r\n        return Shell_NotifyIcon(NIM_MODIFY, &m_tnd);\r\n}\r\n\r\nCWnd* CSystemTray::GetNotificationWnd() const\r\n{\r\n    return CWnd::FromHandle(m_tnd.hWnd);\r\n}\r\n\r\n// Hatr added\r\n\r\n// Hatr added\r\n\r\n// Change or retrive the window to send menu commands to\r\nBOOL CSystemTray::SetTargetWnd(CWnd* pTargetWnd)\r\n{\r\n    m_pTargetWnd = pTargetWnd;\r\n    return TRUE;\r\n} // CSystemTray::SetTargetWnd()\r\n\r\nCWnd* CSystemTray::GetTargetWnd() const\r\n{\r\n    if (m_pTargetWnd)\r\n        return m_pTargetWnd;\r\n    else\r\n        return AfxGetMainWnd();\r\n} // CSystemTray::GetTargetWnd()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray notification message stuff\r\n\r\nBOOL CSystemTray::SetCallbackMessage(UINT uCallbackMessage)\r\n{\r\n    if (!m_bEnabled)\r\n        return FALSE;\r\n\r\n    // Make sure we avoid conflict with other messages\r\n    ASSERT(uCallbackMessage >= WM_APP);\r\n\r\n    m_tnd.uCallbackMessage = uCallbackMessage;\r\n    m_tnd.uFlags = NIF_MESSAGE;\r\n\r\n    if (m_bHidden)\r\n        return TRUE;\r\n    else\r\n        return Shell_NotifyIcon(NIM_MODIFY, &m_tnd);\r\n}\r\n\r\nUINT CSystemTray::GetCallbackMessage() const\r\n{\r\n    return m_tnd.uCallbackMessage;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray menu manipulation\r\n\r\nBOOL CSystemTray::SetMenuDefaultItem(UINT uItem, BOOL bByPos)\r\n{\r\n#ifdef _WIN32_WCE\r\n    return FALSE;\r\n#else\r\n    if ((m_DefaultMenuItemID == uItem) && (m_DefaultMenuItemByPos == bByPos)) \r\n        return TRUE;\r\n\r\n    m_DefaultMenuItemID = uItem;\r\n    m_DefaultMenuItemByPos = bByPos;   \r\n\r\n    CMenu menu, *pSubMenu;\r\n\r\n    if (!menu.LoadMenu(m_tnd.uID))\r\n        return FALSE;\r\n\r\n    pSubMenu = menu.GetSubMenu(0);\r\n    if (!pSubMenu)\r\n        return FALSE;\r\n\r\n    ::SetMenuDefaultItem(pSubMenu->m_hMenu, m_DefaultMenuItemID, m_DefaultMenuItemByPos);\r\n\r\n    return TRUE;\r\n#endif\r\n}\r\n\r\nvoid CSystemTray::GetMenuDefaultItem(UINT& uItem, BOOL& bByPos)\r\n{\r\n    uItem = m_DefaultMenuItemID;\r\n    bByPos = m_DefaultMenuItemByPos;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CSystemTray message handlers\r\n\r\nBEGIN_MESSAGE_MAP(CSystemTray, CWnd)\r\n\t//{{AFX_MSG_MAP(CSystemTray)\r\n\tON_WM_TIMER()\r\n\t//}}AFX_MSG_MAP\r\n#ifndef _WIN32_WCE\r\n\tON_WM_SETTINGCHANGE()\r\n#endif\r\n    ON_REGISTERED_MESSAGE(CSystemTray::m_nTaskbarCreatedMsg, OnTaskbarCreated)\r\nEND_MESSAGE_MAP()\r\n\r\nvoid CSystemTray::OnTimer(UINT_PTR nIDEvent) \r\n{\r\n    if (nIDEvent != m_uIDTimer)\r\n    {\r\n        ASSERT(FALSE);\r\n        return;\r\n    }\r\n\r\n    COleDateTime CurrentTime = COleDateTime::GetCurrentTime();\r\n    COleDateTimeSpan period = CurrentTime - m_StartTime;\r\n\r\n    if (m_nAnimationPeriod > 0 && m_nAnimationPeriod < period.GetTotalSeconds())\r\n    {\r\n        StopAnimation();\r\n        return;\r\n    }\r\n\r\n    StepAnimation();\r\n}\r\n\r\n// This is called whenever the taskbar is created (eg after explorer crashes\r\n// and restarts. Please note that the WM_TASKBARCREATED message is only passed\r\n// to TOP LEVEL windows (like WM_QUERYNEWPALETTE)\r\nLRESULT CSystemTray::OnTaskbarCreated(WPARAM /*wParam*/, LPARAM /*lParam*/) \r\n{\r\n    InstallIconPending();\r\n\treturn 0L;\r\n}\r\n\r\n#ifndef _WIN32_WCE\r\nvoid CSystemTray::OnSettingChange(UINT uFlags, LPCTSTR lpszSection) \r\n{\r\n\tCWnd::OnSettingChange(uFlags, lpszSection);\r\n\r\n    if (uFlags == SPI_SETWORKAREA)\r\n        InstallIconPending();\t\r\n}\r\n#endif\r\n\r\nLRESULT CSystemTray::OnTrayNotification(WPARAM wParam, LPARAM lParam) \r\n{\r\n    //Return quickly if its not for this tray icon\r\n    if (wParam != m_tnd.uID)\r\n        return 0L;\r\n\r\n    CMenu menu, *pSubMenu;\r\n    CWnd *pTargetWnd = GetTargetWnd();\r\n    if (!pTargetWnd)\r\n        return 0L;\r\n\r\n\t// target before mouse messages change the focus\r\n\tif(WM_MOUSEFIRST <= LOWORD(lParam) && LOWORD(lParam) <= WM_MOUSELAST)\r\n\t{\r\n\t\tpTargetWnd->SendMessage(WM_TRAY_MENU_MOUSE_MOVE, 0, 0);\r\n\t}\r\n\r\n\r\n    // Clicking with right button brings up a context menu\r\n#if defined(_WIN32_WCE) //&& _WIN32_WCE < 211\r\n    BOOL bAltPressed = ((GetKeyState(VK_MENU) & (1 << (sizeof(SHORT)*8-1))) != 0);\r\n    if (LOWORD(lParam) == WM_LBUTTONUP && bAltPressed)\r\n#else\r\n    if (LOWORD(lParam) == WM_RBUTTONUP)\r\n#endif\r\n    {    \r\n        if (!menu.LoadMenu(m_tnd.uID))\r\n            return 0;\r\n        \r\n        pSubMenu = menu.GetSubMenu(0);\r\n        if (!pSubMenu)\r\n            return 0;\r\n\r\n#ifndef _WIN32_WCE\r\n        // Make chosen menu item the default (bold font)\r\n        ::SetMenuDefaultItem(pSubMenu->m_hMenu, m_DefaultMenuItemID, m_DefaultMenuItemByPos);\r\n#endif\r\n\r\n        // Display and track the popup menu\r\n        CPoint pos;\r\n#ifdef _WIN32_WCE\r\n        pos = CPoint(GetMessagePos());\r\n#else\r\n        GetCursorPos(&pos);\r\n#endif\r\n\r\n        pTargetWnd->SetForegroundWindow(); \r\n        \r\n#ifndef _WIN32_WCE\r\n\r\n\t\tpTargetWnd->SendMessage(WM_CUSTOMIZE_TRAY_MENU, (WPARAM)pSubMenu, 0);\r\n\r\n        ::TrackPopupMenu(pSubMenu->m_hMenu, 0, pos.x, pos.y, 0, \r\n                         pTargetWnd->GetSafeHwnd(), NULL);\r\n#else\r\n        pSubMenu->TrackPopupMenu(TPM_LEFTALIGN, pos.x, pos.y, pTargetWnd, NULL);\r\n#endif\r\n\r\n        // BUGFIX: See \"PRB: Menus for Notification Icons Don't Work Correctly\"\r\n        pTargetWnd->PostMessage(WM_NULL, 0, 0);\r\n\r\n        menu.DestroyMenu();\r\n    } \r\n#if defined(_WIN32_WCE) //&& _WIN32_WCE < 211\r\n    if (LOWORD(lParam) == WM_LBUTTONDBLCLK && bAltPressed)\r\n#else\r\n    else if((LOWORD(lParam) == WM_LBUTTONDBLCLK) ||  (LOWORD(lParam) == WM_LBUTTONUP && m_bSingleClickSelect))\r\n#endif\r\n    {\r\n        // double click received, the default action is to execute default menu item\r\n        pTargetWnd->SetForegroundWindow();  \r\n\r\n        UINT uItem;\r\n        if (m_DefaultMenuItemByPos)\r\n        {\r\n            if (!menu.LoadMenu(m_tnd.uID))\r\n                return 0;\r\n            \r\n            pSubMenu = menu.GetSubMenu(0);\r\n            if (!pSubMenu)\r\n                return 0;\r\n            \r\n            uItem = pSubMenu->GetMenuItemID(m_DefaultMenuItemID);\r\n\r\n\t\t\tmenu.DestroyMenu();\r\n        }\r\n        else\r\n            uItem = m_DefaultMenuItemID;\r\n        \r\n        pTargetWnd->SendMessage(WM_COMMAND, uItem, 0);\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nLRESULT CSystemTray::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) \r\n{\r\n    if (message == m_tnd.uCallbackMessage)\r\n        return OnTrayNotification(wParam, lParam);\r\n\t\r\n\treturn CWnd::WindowProc(message, wParam, lParam);\r\n}\r\n\r\nvoid CSystemTray::InstallIconPending()\r\n{\r\n    // Is the icon display pending, and it's not been set as \"hidden\"?\r\n    if (!m_bShowIconPending || m_bHidden)\r\n        return;\r\n\r\n\t// Reset the flags to what was used at creation\r\n\tm_tnd.uFlags = m_uCreationFlags;\r\n\r\n    // Try and recreate the icon\r\n    m_bHidden = !Shell_NotifyIcon(NIM_ADD, &m_tnd);\r\n\r\n    // If it's STILL hidden, then have another go next time...\r\n    m_bShowIconPending = !m_bHidden;\r\n\r\n    ASSERT(m_bHidden == FALSE);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// For minimising/maximising from system tray\r\n\r\nBOOL CALLBACK FindTrayWnd(HWND hwnd, LPARAM lParam)\r\n{\r\n    TCHAR szClassName[256];\r\n    GetClassName(hwnd, szClassName, 255);\r\n\t\r\n    // Did we find the Main System Tray? If so, then get its size and keep going\r\n    if (_tcscmp(szClassName, _T(\"TrayNotifyWnd\")) == 0)\r\n    {\r\n        CRect *pRect = (CRect*) lParam;\r\n        ::GetWindowRect(hwnd, pRect);\r\n        return TRUE;\r\n    }\r\n\t\r\n    // Did we find the System Clock? If so, then adjust the size of the rectangle\r\n    // we have and quit (clock will be found after the system tray)\r\n    if (_tcscmp(szClassName, _T(\"TrayClockWClass\")) == 0)\r\n    {\r\n        CRect *pRect = (CRect*) lParam;\r\n        CRect rectClock;\r\n        ::GetWindowRect(hwnd, rectClock);\r\n        // if clock is above system tray adjust accordingly\r\n        if (rectClock.bottom < pRect->bottom-5) // 10 = random fudge factor.\r\n            pRect->top = rectClock.bottom;\r\n        else\r\n            pRect->right = rectClock.left;\r\n        return FALSE;\r\n    }\r\n\t\r\n    return TRUE;\r\n}\r\n \r\n#ifndef _WIN32_WCE\r\n// enhanced version by Matthew Ellis <m.t.ellis@bigfoot.com>\r\nvoid CSystemTray::GetTrayWndRect(LPRECT lprect)\r\n{\r\n#define DEFAULT_RECT_WIDTH 150\r\n#define DEFAULT_RECT_HEIGHT 30\r\n\t\r\n    HWND hShellTrayWnd = ::FindWindow(_T(\"Shell_TrayWnd\"), NULL);\r\n    if (hShellTrayWnd)\r\n    {\r\n        ::GetWindowRect(hShellTrayWnd, lprect);\r\n        EnumChildWindows(hShellTrayWnd, FindTrayWnd, (LPARAM)lprect);\r\n        return;\r\n    }\r\n    // OK, we failed to get the rect from the quick hack. Either explorer isn't\r\n    // running or it's a new version of the shell with the window class names\r\n    // changed (how dare Microsoft change these undocumented class names!) So, we\r\n    // try to find out what side of the screen the taskbar is connected to. We\r\n    // know that the system tray is either on the right or the bottom of the\r\n    // taskbar, so we can make a good guess at where to minimize to\r\n    APPBARDATA appBarData;\r\n    appBarData.cbSize=sizeof(appBarData);\r\n    if (SHAppBarMessage(ABM_GETTASKBARPOS,&appBarData))\r\n    {\r\n        // We know the edge the taskbar is connected to, so guess the rect of the\r\n        // system tray. Use various fudge factor to make it look good\r\n        switch(appBarData.uEdge)\r\n        {\r\n        case ABE_LEFT:\r\n        case ABE_RIGHT:\r\n            // We want to minimize to the bottom of the taskbar\r\n            lprect->top    = appBarData.rc.bottom-100;\r\n            lprect->bottom = appBarData.rc.bottom-16;\r\n            lprect->left   = appBarData.rc.left;\r\n            lprect->right  = appBarData.rc.right;\r\n            break;\r\n            \r\n        case ABE_TOP:\r\n        case ABE_BOTTOM:\r\n            // We want to minimize to the right of the taskbar\r\n            lprect->top    = appBarData.rc.top;\r\n            lprect->bottom = appBarData.rc.bottom;\r\n            lprect->left   = appBarData.rc.right-100;\r\n            lprect->right  = appBarData.rc.right-16;\r\n            break;\r\n        }\r\n        return;\r\n    }\r\n    \r\n    // Blimey, we really aren't in luck. It's possible that a third party shell\r\n    // is running instead of explorer. This shell might provide support for the\r\n    // system tray, by providing a Shell_TrayWnd window (which receives the\r\n    // messages for the icons) So, look for a Shell_TrayWnd window and work out\r\n    // the rect from that. Remember that explorer's taskbar is the Shell_TrayWnd,\r\n    // and stretches either the width or the height of the screen. We can't rely\r\n    // on the 3rd party shell's Shell_TrayWnd doing the same, in fact, we can't\r\n    // rely on it being any size. The best we can do is just blindly use the\r\n    // window rect, perhaps limiting the width and height to, say 150 square.\r\n    // Note that if the 3rd party shell supports the same configuraion as\r\n    // explorer (the icons hosted in NotifyTrayWnd, which is a child window of\r\n    // Shell_TrayWnd), we would already have caught it above\r\n    if (hShellTrayWnd)\r\n    {\r\n        ::GetWindowRect(hShellTrayWnd, lprect);\r\n        if (lprect->right - lprect->left > DEFAULT_RECT_WIDTH)\r\n            lprect->left = lprect->right - DEFAULT_RECT_WIDTH;\r\n        if (lprect->bottom - lprect->top > DEFAULT_RECT_HEIGHT)\r\n            lprect->top = lprect->bottom - DEFAULT_RECT_HEIGHT;\r\n        \r\n        return;\r\n    }\r\n    \r\n    // OK. Haven't found a thing. Provide a default rect based on the current work\r\n    // area\r\n    SystemParametersInfo(SPI_GETWORKAREA,0, lprect, 0);\r\n    lprect->left = lprect->right - DEFAULT_RECT_WIDTH;\r\n    lprect->top  = lprect->bottom - DEFAULT_RECT_HEIGHT;\r\n}\r\n\r\n// Check to see if the animation has been disabled (Matthew Ellis <m.t.ellis@bigfoot.com>)\r\nBOOL CSystemTray::GetDoWndAnimation()\r\n{\r\n\tif(!m_bShowWndAnimation)\r\n\t\treturn FALSE;\r\n\t\r\n\tANIMATIONINFO ai;\r\n\t\r\n\tai.cbSize=sizeof(ai);\r\n\tSystemParametersInfo(SPI_GETANIMATION,sizeof(ai),&ai,0);\r\n\t\r\n\treturn ai.iMinAnimate?TRUE:FALSE;\r\n}\r\n#endif\r\n\r\nBOOL CSystemTray::RemoveTaskbarIcon(CWnd* pWnd)\r\n{\r\n    LPCTSTR pstrOwnerClass = AfxRegisterWndClass(0);\r\n\t\r\n    // Create static invisible window\r\n    if (!::IsWindow(m_wndInvisible.m_hWnd))\r\n    {\r\n\t\tif (!m_wndInvisible.CreateEx(0, pstrOwnerClass, _T(\"\"), WS_POPUP,\r\n\t\t\tCW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\r\n\t\t\tNULL, 0))\r\n\t\t{\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t\t\r\n    }\r\n\t\r\n    pWnd->SetParent(&m_wndInvisible);\r\n\t\r\n    return TRUE;\r\n}\r\n\r\nvoid CSystemTray::MinimiseToTray(CWnd* pWnd)\r\n{\r\n#ifndef _WIN32_WCE\r\n    if (GetDoWndAnimation())\r\n    {\r\n        CRect rectFrom, rectTo;\r\n\t\t\r\n        pWnd->GetWindowRect(rectFrom);\r\n        GetTrayWndRect(rectTo);\r\n\t\t\r\n\t\t::DrawAnimatedRects(pWnd->m_hWnd, IDANI_CAPTION, rectFrom, rectTo);\r\n    }\r\n\t\r\n    RemoveTaskbarIcon(pWnd);\r\n    pWnd->ModifyStyle(WS_VISIBLE, 0);\r\n#endif\r\n}\r\n\r\nvoid CSystemTray::MaximiseFromTray(CWnd* pWnd)\r\n{\r\n#ifndef _WIN32_WCE\r\n    if (GetDoWndAnimation())\r\n    {\r\n        CRect rectTo;\r\n        pWnd->GetWindowRect(rectTo);\r\n\r\n        CRect rectFrom;\r\n        GetTrayWndRect(rectFrom);\r\n\r\n        pWnd->SetParent(NULL);\r\n\t\t::DrawAnimatedRects(pWnd->m_hWnd, IDANI_CAPTION, rectFrom, rectTo);\r\n    }\r\n    else\r\n        pWnd->SetParent(NULL);\r\n\r\n    pWnd->ModifyStyle(0, WS_VISIBLE);\r\n    pWnd->RedrawWindow(NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_FRAME |\r\n                                   RDW_INVALIDATE | RDW_ERASE);\r\n\r\n    // Move focus away and back again to ensure taskbar icon is recreated\r\n    if (::IsWindow(m_wndInvisible.m_hWnd))\r\n        m_wndInvisible.SetActiveWindow();\r\n    pWnd->SetActiveWindow();\r\n    pWnd->SetForegroundWindow();\r\n#endif\r\n}\r\n"
        },
        {
          "name": "SystemTray.h",
          "type": "blob",
          "size": 6.31640625,
          "content": "/////////////////////////////////////////////////////////////////////////////\n// SystemTray.h : header file\n//\n// Written by Chris Maunder (cmaunder@mail.com)\n// Copyright (c) 1998.\n//\n// This code may be used in compiled form in any way you desire. This\n// file may be redistributed unmodified by any means PROVIDING it is \n// not sold for profit without the authors written consent, and \n// providing that this notice and the authors name is included. If \n// the source code in  this file is used in any commercial application \n// then acknowledgement must be made to the author of this file \n// (in whatever form you wish).\n//\n// This file is provided \"as is\" with no expressed or implied warranty.\n//\n// Expect bugs.\n// \n// Please use and enjoy. Please let me know of any bugs/mods/improvements \n// that you have found/implemented and I will fix/incorporate them into this\n// file. \n\n#ifndef _INCLUDED_SYSTEMTRAY_H_\n#define _INCLUDED_SYSTEMTRAY_H_\n\n#define ASSUME_IE5_OR_ABOVE\n\n#ifdef ASSUME_IE5_OR_ABOVE\n#\tifndef _WIN32_IE\n#\t\tdefine _WIN32_IE 0x0500    // enable shell v5 features\n#\telif _WIN32_IE < 0x0500\n#\t\tundef _WIN32_IE\n#\t\tdefine _WIN32_IE 0x0500    // enable shell v5 features\n#\tendif\n#\tifdef NOTIFYICONDATA_V1_SIZE   // If NOTIFYICONDATA_V1_SIZE, then we can use fun stuff\n#\t\tdefine SYSTEMTRAY_USEW2K\n#\tendif\n#endif\n\n#ifndef NIIF_NONE\n#define NIIF_NONE 0\n#endif\n\n#define WM_CUSTOMIZE_TRAY_MENU\tWM_USER + 215\n#define WM_TRAY_MENU_MOUSE_MOVE\tWM_USER + 216\n\n// #include <afxwin.h>\n#include <afxtempl.h>\n#include <afxdisp.h>    // COleDateTime\n\n#include \"TrayWnd.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n// CSystemTray window\n\nclass CSystemTray : public CWnd\n{\n// Construction/destruction\npublic:\n    CSystemTray();\n    CSystemTray(CWnd* pWnd, UINT uCallbackMessage, LPCTSTR szTip, HICON icon, UINT uID, \n                BOOL bhidden = FALSE,\n                LPCTSTR szBalloonTip = NULL, LPCTSTR szBalloonTitle = NULL, \n                DWORD dwBalloonIcon = NIIF_NONE, UINT uBalloonTimeout = 10);\n    virtual ~CSystemTray();\n\n    DECLARE_DYNAMIC(CSystemTray)\n\n// Operations\npublic:\n    BOOL Enabled() { return m_bEnabled; }\n    BOOL Visible() { return !m_bHidden; }\n\n    // Create the tray icon\n    BOOL Create(CWnd* pParent, UINT uCallbackMessage, LPCTSTR szTip, HICON icon, UINT uID,\n                BOOL bHidden = FALSE,\n                LPCTSTR szBalloonTip = NULL, LPCTSTR szBalloonTitle = NULL, \n                DWORD dwBalloonIcon = NIIF_NONE, UINT uBalloonTimeout = 10);\n\n    // Change or retrieve the Tooltip text\n    BOOL    SetTooltipText(LPCTSTR pszTooltipText);\n    BOOL    SetTooltipText(UINT nID);\n    CString GetTooltipText() const;\n\n    // Change or retrieve the icon displayed\n    BOOL  SetIcon(HICON hIcon);\n    BOOL  SetIcon(LPCTSTR lpszIconName);\n    BOOL  SetIcon(UINT nIDResource);\n    BOOL  SetStandardIcon(LPCTSTR lpIconName);\n    BOOL  SetStandardIcon(UINT nIDResource);\n    HICON GetIcon() const;\n\n    void  SetFocus();\n    BOOL  HideIcon();\n    BOOL  ShowIcon();\n    BOOL  AddIcon();\n    BOOL  RemoveIcon();\n    BOOL  MoveToRight();\n\n    BOOL ShowBalloon(LPCTSTR szText, LPCTSTR szTitle = NULL,\n                     DWORD dwIcon = NIIF_NONE, UINT uTimeout = 10);\n\n    // For icon animation\n    BOOL  SetIconList(UINT uFirstIconID, UINT uLastIconID); \n    BOOL  SetIconList(HICON* pHIconList, UINT nNumIcons); \n    BOOL  Animate(UINT nDelayMilliSeconds, int nNumSeconds = -1);\n    BOOL  StepAnimation();\n    BOOL  StopAnimation();\n\n    // Change menu default item\n    void GetMenuDefaultItem(UINT& uItem, BOOL& bByPos);\n    BOOL SetMenuDefaultItem(UINT uItem, BOOL bByPos);\n\n    // Change or retrieve the window to send notification messages to\n    BOOL  SetNotificationWnd(CWnd* pNotifyWnd);\n    CWnd* GetNotificationWnd() const;\n\n    // Change or retrieve the window to send menu commands to\n    BOOL  SetTargetWnd(CWnd* pTargetWnd);\n    CWnd* GetTargetWnd() const;\n\n    // Change or retrieve  notification messages sent to the window\n    BOOL  SetCallbackMessage(UINT uCallbackMessage);\n    UINT  GetCallbackMessage() const;\n\n    UINT  GetTimerID() const   { return m_nTimerID; }\n\n\tvoid\tSetSingleClickSelect(BOOL bSel)\t{ m_bSingleClickSelect = bSel; }\n\tBOOL\tGetSingleClickSelect()\t\t\t{ return m_bSingleClickSelect;\t}\n\t\n\n// Static functions\npublic:\n    static void MinimiseToTray(CWnd* pWnd);\n    static void MaximiseFromTray(CWnd* pWnd);\n\npublic:\n    // Default handler for tray notification message\n    virtual LRESULT OnTrayNotification(WPARAM uID, LPARAM lEvent);\n\n// Overrides\n    // ClassWizard generated virtual function overrides\n    //{{AFX_VIRTUAL(CSystemTray)\n\tprotected:\n\tvirtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n    void Initialise();\n    void InstallIconPending();\n\n// Implementation\nprotected:\n    NOTIFYICONDATA  m_tnd;\n    BOOL            m_bEnabled;         // does O/S support tray icon?\n    BOOL            m_bHidden;          // Has the icon been hidden?\n    BOOL            m_bRemoved;         // Has the icon been removed?\n    BOOL            m_bShowIconPending; // Show the icon once tha taskbar has been created\n    BOOL            m_bWin2K;           // Use new W2K features?\n\tCWnd*           m_pTargetWnd;       // Window that menu commands are sent\n\n    CArray<HICON, HICON> m_IconList;\n    UINT         m_uIDTimer;\n    int          m_nCurrentIcon;\n    COleDateTime m_StartTime;\n    int          m_nAnimationPeriod;\n    HICON        m_hSavedIcon;\n    UINT         m_DefaultMenuItemID;\n    BOOL         m_DefaultMenuItemByPos;\n\tUINT         m_uCreationFlags;\n\tBOOL\t\t m_bSingleClickSelect;\n\t\n// Static data\nprotected:\n    static BOOL RemoveTaskbarIcon(CWnd* pWnd);\n\n    static const UINT m_nTimerID;\n    static UINT  m_nMaxTooltipLength;\n    static const UINT m_nTaskbarCreatedMsg;\n    static CTrayWnd  m_wndInvisible;\n\tstatic BOOL\t m_bShowWndAnimation;\n\n    static BOOL GetW2K();\n#ifndef _WIN32_WCE\n    static void GetTrayWndRect(LPRECT lprect);\n    static BOOL GetDoWndAnimation();\n#endif\n\n// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CSystemTray)\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\t//}}AFX_MSG\n#ifndef _WIN32_WCE\n\tafx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);\n#endif\n    LRESULT OnTaskbarCreated(WPARAM wParam, LPARAM lParam);\n    DECLARE_MESSAGE_MAP()\n};\n\n\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n"
        },
        {
          "name": "TabCtrl.cpp",
          "type": "blob",
          "size": 21.31640625,
          "content": "// SheetCtrl.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"TabCtrl.h\"\n#include \"Misc.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n#define TEXT_PAD\t\t\t7\n#define SPIN_PAD\t\t\t3\n#define SHIFT_UNITS\t\t\t10\n\n#define COLOR_WHITE\t\t\tRGB(255, 255, 255)\n#define COLOR_GRAY\t\t\tRGB(128, 128, 128)\n#define COLOR_MEDGRAY\t\tGetSysColor(COLOR_BTNFACE)\n#define COLOR_DARKGRAY\t\tRGB(64, 64, 64)\n\n#define ID_SCROLL_TIMER\t\t0x1010\n\n#define VK_TILDAE\t\t\t0xC0\n\n/////////////////////////////////////////////////////////////////////////////\n// CTabCtrlEx\n\nCTabCtrlEx::CTabCtrlEx()\n{\n\tm_nStyle = 0;\n\tm_nActiveTab = -1;\n\tm_nTabHeight = 19;\n\tm_btnState[0] = BtnUp;\n\tm_btnState[1] = BtnUp;\n\tm_bBtnEnabled[0] = false;\n\tm_bBtnEnabled[1] = false;\n\tm_nLeftShifted = 0;\n\tm_nPrevWidth = 0;\n\tm_pFntText = NULL;\n\tm_pFntBoldText = NULL;\n\tm_bSetFocusToNewlySelectedTab = true;\n\n\tm_SelectedColor = (COLORREF)GetSysColor(COLOR_BTNFACE);\n\tm_NonSelectedColor = RGB(255, 251, 233);\n}\n\nCTabCtrlEx::~CTabCtrlEx()\n{\n\tif (m_pFntText)\n\t\tdelete m_pFntText;\n\tm_pFntText = NULL;\n\n\tif (m_pFntBoldText)\n\t\tdelete m_pFntBoldText;\n\n\tm_pFntBoldText = NULL;\n}\n\n\nBEGIN_MESSAGE_MAP(CTabCtrlEx, CWnd)\n\t//{{AFX_MSG_MAP(CTabCtrlEx)\n\tON_WM_PAINT()\n\tON_WM_CREATE()\n\tON_WM_LBUTTONDOWN()\n\tON_WM_MOUSEMOVE()\n\tON_WM_LBUTTONUP()\n\tON_WM_SIZE()\n\tON_WM_TIMER()\n\tON_WM_SHOWWINDOW()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CTabCtrlEx message handlers\n\nBOOL CTabCtrlEx::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)\n{\n\t// Get the sheet styles alone\n\tm_nStyle = short(dwStyle & 0xFFFF);\n\n\t// Remove the sheet styles and create the window\n\tdwStyle &= 0xFFFF0000;\n\t\n\t// If the window border style is set, change it to sheet border style\n\tif (dwStyle & WS_BORDER)\n\t{\n\t\tm_nStyle |= SCS_BORDER;\n\t\tdwStyle &= ~WS_BORDER;\n\t}\n\n\t// Register the class\n\tWNDCLASS wndClass;\n\tmemset(&wndClass, 0, sizeof(wndClass));\n\t\n\tBOOL bRet = false;\n\tHINSTANCE hInst = AfxGetInstanceHandle();\n\tif (::GetClassInfo(hInst, SHEET_CLASSNAME, &wndClass))\n\t{\n\t\tbRet = (wndClass.style == SHEET_CLASSTYLE);\n\t}\n\n\tif (bRet == FALSE)\n\t{\n\t\tmemset(&wndClass, 0, sizeof(wndClass));\n\t\twndClass.style = SHEET_CLASSTYLE;\n\t\twndClass.lpfnWndProc = ::DefWindowProc;\n\t\twndClass.cbClsExtra = wndClass.cbWndExtra = 0;\n\t\twndClass.hInstance = hInst;\n\t\twndClass.hIcon = NULL;\n\t\twndClass.hCursor = NULL;\n\t\twndClass.hbrBackground = NULL;\n\t\twndClass.lpszMenuName = NULL;\n\t\twndClass.lpszClassName = SHEET_CLASSNAME;\n\t\tif ((bRet = AfxRegisterClass(&wndClass)) == FALSE)\n\t\t\tASSERT(FALSE);\n\t}\n\n\tif (bRet)\n\t\tbRet = CWnd::Create(SHEET_CLASSNAME, _T(\"\"), dwStyle, rect, pParentWnd, nID);\n\n\treturn bRet;\n}\n\nint CTabCtrlEx::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\t// Create the brushes, pens\n\tm_brSelectedTab.CreateSolidBrush(m_SelectedColor);\n\tm_brNonSelectedTab.CreateSolidBrush(m_NonSelectedColor);\n\tm_penGray.CreatePen(PS_SOLID, 1, RGB(172, 168, 153));\n\tm_penBlack.CreatePen(PS_SOLID, 1, RGB(0, 0, 0));\n\n\tSetTabHeight(m_nTabHeight);\n\n\treturn 0;\n}\n\nvoid CTabCtrlEx::SetTabHeight(int nTabHeight)\n{\n\tm_nTabHeight = nTabHeight;\n\n\t// Delete the old font and create a new one\n\tif (m_pFntText)\n\t\tdelete m_pFntText;\n\tm_pFntText = new CFont;\n\t\n\tif (m_pFntText)\n\t{\n\t\t// Set the regular font\n\t\tm_pFntText->CreateFont(-(m_nTabHeight*7/10), 0, 0, 0, FW_LIGHT, FALSE, FALSE, 0, DEFAULT_CHARSET,\n\t\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, _T(\"Arial Unicode MS\"));\n\t}\n\n\t// Delete the old font and create a new one\n\tif (m_pFntBoldText)\n\t\tdelete m_pFntBoldText;\n\tm_pFntBoldText = new CFont;\n\n\tif (m_pFntBoldText)\n\t{\n\t\t// Set the bold font\n\t\tm_pFntBoldText->CreateFont(-(m_nTabHeight*7/10), 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, 0, DEFAULT_CHARSET,\n\t\t\tOUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, _T(\"Arial Unicode MS\"));\n\t}\n}\n\nbool CTabCtrlEx::AddItem(const CString& csTabTitle, CWnd* pTabWnd)\n{\n\treturn InsertItem((int)m_Tabs.GetSize(), csTabTitle, pTabWnd);\n}\n\nbool CTabCtrlEx::InsertItem(int nTab, const CString& csTabTitle, CWnd* pTabWnd)\n{\n\tCTab tab;\n\ttab.csTitle = csTabTitle;\n\ttab.pWnd = pTabWnd;\n\ttab.lWidth = GetTextWidth(csTabTitle);\n\ttab.clrUnderline = -1;\n\n\tm_Tabs.InsertAt(nTab, tab);\n\t\n\tif(nTab <= m_nActiveTab)\n\t\tm_nActiveTab++;\n\n\t// Redraw the window\n\tRedrawWindow();\n\t\n\treturn true;\n}\n\nbool CTabCtrlEx::ReplaceItem(int nTab, const CString &csTabTitle, CWnd* pTabWnd)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\tif(m_Tabs[nTab].pWnd)\n\t\t\tm_Tabs[nTab].pWnd->ShowWindow(SW_HIDE);\n\n\t\tm_Tabs[nTab].csTitle = csTabTitle;\n\t\tm_Tabs[nTab].pWnd = pTabWnd;\n\t\tm_Tabs[nTab].lWidth = GetTextWidth(csTabTitle);\n\n\t\tif(pTabWnd)\n\t\t\tpTabWnd->ShowWindow(SW_SHOW);\n\n\t\tSetActiveTab(m_nActiveTab);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool CTabCtrlEx::DeleteItem(int nTab)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\t// Remove the tab\n\t\tm_Tabs.RemoveAt(nTab);\n\n\t\t// Set the new active tab\n\t\tif (nTab == GetActiveTab())\n\t\t{\n\t\t\tif(nTab > 0)\n\t\t\t\tnTab--;\n\t\t\tSetActiveTab(nTab, true);\n\t\t}\n\t\t\n\t\t// Redraw the window\n\t\tRedrawWindow();\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool CTabCtrlEx::DeleteAllItems()\n{\n\t// Remove all the tab\n\tm_Tabs.RemoveAll();\n\t\t\n\t// Reset the active tab\n\tm_nActiveTab = -1;\n\n\t// Redraw the window\n\tRedrawWindow();\n\n\treturn true;\n}\n\nvoid CTabCtrlEx::UnderlineTabTitle(int nTab, COLORREF clr)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\tm_Tabs[nTab].clrUnderline = clr;\n\t\tInvalidate();\n\t}\n}\n\nint CTabCtrlEx::GetTextWidth(const CString& csText)\n{\n\tCDC *pDC = GetDC();\n\tif (pDC)\n\t{\n\t\t// Select the font\n\t\tCFont *pPrevFont = pDC->SelectObject(m_pFntBoldText);\n\t\t\n\t\t// Get the width\n\t\tint nWidth = pDC->GetTextExtent(csText).cx;\n\t\t\n\t\t// Restore the font\n\t\tpDC->SelectObject(pPrevFont);\n\t\tReleaseDC(pDC);\n\n\t\treturn (nWidth + 2*TEXT_PAD);\n\t}\n\t\n\treturn 0;\n}\n\nint CTabCtrlEx::GetDisplayWidth()\n{\n\tCRect rcWnd;\n\tGetClientRect(rcWnd);\n\t\n\t// If all the tabs cannot fit, then the spinner is visiable\n\tif (GetTabsWidth() > rcWnd.Width())\n\t\treturn rcWnd.Width()-GetSpinnerWidth();\n\n\treturn rcWnd.Width();\n}\n\nint CTabCtrlEx::GetTabsWidth()\n{\n\tint nWidth = 0;\n\n\t// Get the width for all tabs\n\tfor (int iTab=0; iTab<m_Tabs.GetSize(); iTab++)\n\t\tnWidth += m_Tabs[iTab].lWidth;\n\n\tnWidth += TEXT_PAD;\n\n\treturn nWidth;\n}\n\nint CTabCtrlEx::GetSpinnerWidth()\n{\n\tint nSpinWidth = m_nTabHeight-2*1;\n\treturn (2*nSpinWidth + SPIN_PAD);\n}\n\nvoid CTabCtrlEx::GetFullRect(CRect& rcTab)\n{\n\t// Get the area of the full sheet window\n\tGetClientRect(rcTab);\n\t\n\t// Get the full tab area\n\tif (m_nStyle & SCS_TOP)\n\t\trcTab.bottom = m_nTabHeight;\n\telse\n\t\trcTab.top = rcTab.Height()-m_nTabHeight;\n}\n\nvoid CTabCtrlEx::GetTabListRect(CRect& rcTab)\n{\n\t// Get the full tab area\n\tGetFullRect(rcTab);\n\t\n\t// Get the area for the tabs\n\tif (m_nStyle & SCS_TOP)\n\t\trcTab.bottom -= 1;\n\telse\n\t\trcTab.top += 1;\n}\n\nvoid CTabCtrlEx::GetTabRect(int nTab, CRect& rcTab)\n{\n\t// Get the area for the tabs\n\tGetTabListRect(rcTab);\n\n\trcTab.top += 2;\n\n\tint nLeft = 0;\n\t// Get the area for the current tab\n\tfor (int iTab=0; iTab<m_Tabs.GetSize(); iTab++)\n\t{\n\t\tif (iTab == nTab)\n\t\t{\n\t\t\trcTab.left = nLeft;\n\t\t\trcTab.right = nLeft+m_Tabs[iTab].lWidth;\n\t\t\tbreak;\n\t\t}\n\n\t\tnLeft += m_Tabs[iTab].lWidth;\n\t}\n}\n\nvoid CTabCtrlEx::GetSpinnerRect(CRect& rcSpin)\n{\n\t// Get the area for the tabs\n\tGetTabListRect(rcSpin);\n\n\t// If all the tabs cannot fit, then show the spinner\n\tif (GetTabsWidth() > rcSpin.Width())\n\t\trcSpin.left = rcSpin.right-GetSpinnerWidth();\n\t// Set the spinner width to zero\n\telse\n\t\trcSpin.SetRectEmpty();\n}\n\nvoid CTabCtrlEx::GetButtonRect(int nBtn, CRect& rcBtn)\n{\n\tGetSpinnerRect(rcBtn);\n\trcBtn.DeflateRect(SPIN_PAD, 0, 0, 0);\n\t\n\trcBtn.DeflateRect(1, 1);\n\tif (nBtn == 0)\n\t\trcBtn.right = rcBtn.left + rcBtn.Width()/2;\n\telse if (nBtn == 1)\n\t\trcBtn.left = rcBtn.left + rcBtn.Width()/2;\n\telse\n\t\trcBtn.SetRectEmpty();\n}\n\nCString CTabCtrlEx::GetTabTitle(int nTab)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t\treturn m_Tabs[nTab].csTitle;\n\n\treturn \"\";\n}\n\nbool CTabCtrlEx::SetTabTitle(int nTab, const CString& csTabTitle)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\tm_Tabs[nTab].csTitle = csTabTitle;\n\t\tm_Tabs[nTab].lWidth = GetTextWidth(csTabTitle);\n\n\t\t// Redraw the window\n\t\tRedrawWindow();\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool CTabCtrlEx::SetTabItemData(int nTab, long lItemData)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\tm_Tabs[nTab].lItemData = lItemData;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nlong CTabCtrlEx::GetTabItemData(int nTab)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\treturn m_Tabs[nTab].lItemData;\n\t}\n\n\treturn -1;\n}\n\nint CTabCtrlEx::GetActiveTab()\n{\n\treturn m_nActiveTab;\n}\n\nint CTabCtrlEx::GetTabCount()\n{\n\treturn (int)m_Tabs.GetSize();\n}\n\nvoid CTabCtrlEx::SetActiveTab(int nTab, bool bNotify)\n{\n\tActivateTab(nTab, bNotify);\n}\n\nvoid CTabCtrlEx::ActivateTab(int nTab, bool bNotify, bool bOnSize)\n{\n\tif ((nTab >= 0) && (nTab < m_Tabs.GetSize()))\n\t{\n\t\t// Set the new active tab\n\t\tint nOldTab = GetActiveTab();\n\t\tm_nActiveTab = nTab;\n\t\t\n\t\t// Resize the tab windows\n\t\tResizeTabWindow(nOldTab, GetActiveTab(), bNotify, bOnSize);\n\n\t\t// Make the tab visible\n\t\tMakeTabVisible(GetActiveTab());\n\n\t\t// Redraw the tabs\n\t\tif (bOnSize)\n\t\t\tInvalidateRect(NULL);\n\t\telse\n\t\t\tRedrawWindow();\n\t}\n}\n\nvoid CTabCtrlEx::ResizeTabWindow(int nOldTab, int nNewTab, bool bNotify, bool bOnSize)\n{\n\tlong lOldItemData = -1;\n\tlong lNewItemData = -1;\n\n\tif ((nOldTab >= 0) && nOldTab < GetTabCount())\n\t{\n\t\tlOldItemData = m_Tabs[nOldTab].lItemData;\n\t\tCWnd* pPrevWnd = m_Tabs[nOldTab].pWnd;\n\t\t// Hide the previous tab\n\t\tif (pPrevWnd && IsWindow(pPrevWnd->m_hWnd))\n\t\t\tpPrevWnd->ShowWindow(SW_HIDE);\n\t}\n\n\tif ((nNewTab >= 0) && nNewTab < GetTabCount())\n\t{\n\t\tCRect rcWnd;\n\t\t//GetClientRect(rcWnd);\n\t\tGetWindowRect(rcWnd);\n\n\t\tlNewItemData = m_Tabs[nNewTab].lItemData;\n\n\t\tCWnd *pParentWnd = GetParent();\n\t\tif (pParentWnd && IsWindow(pParentWnd->m_hWnd))\n\t\t\tpParentWnd->ScreenToClient(rcWnd);\n\t\t\n\t\tint nPad = 0;\n\t\tCWnd* pNextWnd = m_Tabs[nNewTab].pWnd;;\n\t\t// Show the new tab and bring it to the top, set the focus to the new tab\n\t\tif (pNextWnd && IsWindow(pNextWnd->m_hWnd))\n\t\t{\n\t\t\t// Resize the tab window\n\t\t\tif (m_nStyle & SCS_TOP)\n\t\t\t{\n\t\t\t\tpNextWnd->SetWindowPos(&wndTop, rcWnd.left+nPad, rcWnd.top+m_nTabHeight+nPad,\n\t\t\t\t\trcWnd.Width()-2*nPad, rcWnd.Height()-m_nTabHeight-2*nPad, SWP_SHOWWINDOW);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpNextWnd->SetWindowPos(&wndTop, rcWnd.left+nPad, rcWnd.top+nPad,\n\t\t\t\t\trcWnd.Width()-2*nPad, rcWnd.Height()-m_nTabHeight-2*nPad, SWP_SHOWWINDOW);\n\t\t\t}\n\n\t\t\tif(m_bSetFocusToNewlySelectedTab)\n\t\t\t{\n\t\t\t\t// Set the focus\n\t\t\t\tif (bOnSize == FALSE)\n\t\t\t\t\tpNextWnd->SetFocus();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bNotify)\n\t{\n\t\t// Send a notification message to the parent window\n\t\tCWnd *pParentWnd = GetParent();\n\t\tif (pParentWnd && IsWindow(pParentWnd->m_hWnd))\n\t\t{\n\t\t\tNMTABCHANGE nmTab;\n\t\t\tZeroMemory(&nmTab, sizeof(nmTab));\n\t\t\tnmTab.hdr.code = SN_SETACTIVETAB;\n\t\t\tnmTab.hdr.hwndFrom = GetSafeHwnd();\n\t\t\tnmTab.hdr.idFrom = GetDlgCtrlID();\n\t\t\tnmTab.lOldTab = nOldTab;\n\t\t\tnmTab.lNewTab = nNewTab;\n\t\t\tnmTab.lOldItemData = lOldItemData;\n\t\t\tnmTab.lNewItemData = lNewItemData;\n\t\t\t\n\t\t\tpParentWnd->SendMessage(WM_NOTIFY, (WPARAM) nmTab.hdr.idFrom, (LPARAM) &nmTab);\n\t\t}\n\t}\n}\n\nvoid CTabCtrlEx::MakeTabVisible(int nTab)\n{\n\tCRect rcTab;\n\tGetTabRect(nTab, rcTab);\n\trcTab.OffsetRect(-m_nLeftShifted, 0);\n\n\tif (rcTab.right > GetDisplayWidth())\n\t\tm_nLeftShifted += (rcTab.right-GetDisplayWidth()+TEXT_PAD);\n\t\n\tGetTabRect(nTab, rcTab);\n\trcTab.OffsetRect(-m_nLeftShifted, 0);\n\n\tif (rcTab.left <= 0)\n\t{\n\t\tm_nLeftShifted += rcTab.left;\n\t\tif (m_nLeftShifted < 0)\n\t\t{\n\t\t\tASSERT(FALSE);\n\t\t\tm_nLeftShifted = 0;\n\t\t}\n\t}\n}\n\nvoid CTabCtrlEx::OnPaint() \n{\n\tCPaintDC dc(this); // device context for painting\n\t\n\tCRect rcUpdate(0, 0, 0, 0);\n\t\n\t// Enable spinners\n\tEnableSpinners();\n\n\tif (m_nActiveTab < 0)\n\t{\n\t\t// Set the first window to be the active tab\n\t\tActivateTab(0, true, true);\n\t}\n\n\t// Draw the tabs\n\tDrawTabs(&dc);\n}\n\nvoid CTabCtrlEx::EnableSpinners()\n{\n\tint nDispWidth = GetDisplayWidth();\n\t\n\tif (nDispWidth >= GetTabsWidth())\n\t{\n\t\t// We have enough space, disable the spinners\n\t\tm_nLeftShifted = 0;\n\t\tm_bBtnEnabled[0] = false;\n\t\tm_bBtnEnabled[1] = false;\n\t}\n\telse\n\t{\n\t\t// Enable/Disable the spinner buttons\n\t\tm_bBtnEnabled[0] = (m_nLeftShifted > 0);\n\t\tm_bBtnEnabled[1] = ((m_nLeftShifted+nDispWidth) < GetTabsWidth());\n\t}\n}\n\nvoid CTabCtrlEx::DrawTabs(CDC *pDC)\n{\n\t// Draw the bar\n\tDrawBar(pDC);\n\n\tCRect rcTab;\n\t// Draw all the tabs but the active tab\n\tfor (int iTab=0; iTab<m_Tabs.GetSize(); iTab++)\n\t{\n\t\tif (iTab == GetActiveTab())\n\t\t\tcontinue;\n\n\t\tGetTabRect(iTab, rcTab);\n\t\trcTab.OffsetRect(-m_nLeftShifted, 0);\n\t\tDrawTab(iTab, pDC, rcTab);\n\t}\n\n\t// Draw the active tab\n\tGetTabRect(GetActiveTab(), rcTab);\n\trcTab.OffsetRect(-m_nLeftShifted, 0);\n\tif (GetActiveTab() < m_Tabs.GetSize())\n\t\tDrawTab(GetActiveTab(), pDC, rcTab);\n\n\t// Draw the spinner buttons\n\tDrawSpinner(pDC);\n}\n\nvoid CTabCtrlEx::DrawBar(CDC* pDC)\n{\n\tCRect rcBar;\n\tGetFullRect(rcBar);\n\n\t// Set the background color for the tabs\n\tpDC->FillRect(rcBar, &m_brNonSelectedTab);\n\n\tif (m_nStyle & SCS_BOLD)\n\t{\n\t\t// Draw the line\n\t\tif (m_nStyle & SCS_TOP)\n\t\t{\n\t\t\tpDC->MoveTo(CPoint(rcBar.left, rcBar.bottom-1));\n\t\t\tpDC->LineTo(CPoint(rcBar.right, rcBar.bottom-1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpDC->MoveTo(rcBar.TopLeft());\n\t\t\tpDC->LineTo(CPoint(rcBar.right, rcBar.top));\n\t\t}\n\t}\n}\n\nvoid CTabCtrlEx::DrawTab(int nTab, CDC *pDC, CRect& rcTab)\n{\n\tif(nTab < 0)\n\t\treturn;\n\n\tDrawTabEx(nTab, pDC, rcTab);\n\treturn;\n\n\t// Paint the text centered.\n\tCPoint ptArr[5];\n\tif (m_nStyle & SCS_TOP)\n\t{\n\t\tptArr[0] = CPoint(rcTab.left, rcTab.bottom-1);\n\t\tptArr[1] = CPoint(rcTab.left+TEXT_PAD, rcTab.top);\n\t\tptArr[2] = CPoint(rcTab.right, rcTab.top);\n\t\tptArr[3] = CPoint(rcTab.right+TEXT_PAD, rcTab.bottom);\n\t\tptArr[4] = CPoint(rcTab.left, rcTab.bottom);\n\t}\n\telse\n\t{\n\t\tptArr[0] = rcTab.TopLeft();\n\t\tptArr[1] = CPoint(rcTab.left+TEXT_PAD, rcTab.bottom-1);\n\t\tptArr[2] = CPoint(rcTab.right, rcTab.bottom-1);\n\t\tptArr[3] = CPoint(rcTab.right+TEXT_PAD, rcTab.top-1);\n\t\tptArr[4] = rcTab.TopLeft();\n\t}\n\t\n\t// Draw the Tab\n\tCRgn rgn;\n\tif (rgn.CreatePolygonRgn(ptArr, 4, WINDING) == FALSE)\n\t\treturn;\n\n\tCFont *pFont = NULL;\n\tif (nTab == GetActiveTab())\n\t{\n\t\tpDC->FillRgn(&rgn, &m_brSelectedTab);\n\t\tpFont = m_pFntBoldText;\n\t}\n\telse\n\t{\n\t\tpDC->FillRgn(&rgn, &m_brNonSelectedTab);\n\t\tpFont = m_pFntText;\n\t}\n\n\tCPen *pPen = NULL;\n\tif ((m_nStyle & SCS_BOLD) == 0)\n\t\tpPen = &m_penGray;\n\t\n\tCPen *pPrevPen = pDC->SelectObject(pPen);\n\tpDC->Polyline(ptArr, 4);\n\tpDC->SelectObject(pPrevPen);\n\t\n\t// Draw the text\n\tCFont *pPrevFont = pDC->SelectObject(pFont);\n\trcTab.right += TEXT_PAD;\n\tpDC->SetBkMode(TRANSPARENT);\n\tpDC->DrawText(m_Tabs[nTab].csTitle, rcTab, DT_CENTER|DT_VCENTER|DT_END_ELLIPSIS);\n\tpDC->SelectObject(pPrevFont);\n\n\tif (m_Tabs[nTab].clrUnderline != -1)\n\t{\n\t\tpDC->Draw3dRect(CRect(rcTab.left+TEXT_PAD+2, rcTab.bottom-2, rcTab.right-TEXT_PAD-2, rcTab.bottom),\n\t\t\tm_Tabs[nTab].clrUnderline, m_Tabs[nTab].clrUnderline);\n\t}\n}\n\nvoid CTabCtrlEx::DrawTabEx(int nTab, CDC *pDC, CRect& rcTab)\n{\n\tif(nTab < 0)\n\t\treturn;\n\n\tCRect rcOrig(rcTab);\n\trcTab.OffsetRect(1, 1);\n\tCFont *pFont = NULL;\n\tif (nTab == GetActiveTab())\n\t{\n\t\tpDC->FillSolidRect(rcTab, m_SelectedColor);\n\t\tpFont = m_pFntBoldText;\n\t}\n\telse\n\t{\n\t\tpDC->FillSolidRect(rcTab, m_NonSelectedColor);\n\t\tpFont = m_pFntText;\n\t}\n\n\t//Don't draw a line on the item before the selected tab\n\tif (nTab != GetActiveTab()-1)\n\t{\n\t\tint nBottomOffset = 0;\n\t\tint nTopOffset = 0;\n\t\tCPen *pPen = NULL;\n\t\tif (nTab == GetActiveTab())\n\t\t{\n\t\t\tpPen = &m_penBlack;\n\t\t\tnTopOffset = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpPen = &m_penGray;\n\t\t\tnBottomOffset = 3;\n\t\t\tnTopOffset = 2;\n\t\t}\n\n\t\tCPen *pPrevPen = pDC->SelectObject(pPen);\n\t\tpDC->MoveTo(CPoint(rcTab.right-1, rcTab.bottom-nBottomOffset));\n\t\tpDC->LineTo(CPoint(rcTab.right-1, rcTab.top+nTopOffset));\n\t\tpDC->SelectObject(pPrevPen);\n\t}\n\n\t// Draw the text\n\tCFont *pPrevFont = pDC->SelectObject(pFont);\n\tpDC->SetBkMode(TRANSPARENT);\n\tpDC->DrawText(m_Tabs[nTab].csTitle, rcOrig, DT_CENTER|DT_VCENTER|DT_END_ELLIPSIS);\n\tpDC->SelectObject(pPrevFont);\n}\n\nvoid CTabCtrlEx::DrawSpinner(CDC *pDC)\n{\n\tCRect rcSpin;\n\tGetSpinnerRect(rcSpin);\n\n\tif (rcSpin.Width() == 0)\n\t\treturn;\n\n\t// Set the background color\n\tpDC->FillRect(rcSpin, &m_brNonSelectedTab);\n\n\t// Draw the line\n\tpDC->MoveTo(CPoint(rcSpin.left+1, rcSpin.top));\n\tpDC->LineTo(CPoint(rcSpin.left+1, rcSpin.bottom));\n\trcSpin.DeflateRect(SPIN_PAD, 0, 0, 0);\n\n\tCRect rcBtn;\n\tGetButtonRect(0, rcBtn);\n\tDrawButton(pDC, rcBtn, m_btnState[0], ArrowLeft, m_bBtnEnabled[0]);\n\tGetButtonRect(1, rcBtn);\n\tDrawButton(pDC, rcBtn, m_btnState[1], ArrowRight, m_bBtnEnabled[1]);\n}\n\nvoid CTabCtrlEx::DrawButton(CDC *pDC, CRect& rcBtn, ButtonState btnState,\n\tButtonStyle btnStyle, bool bEnable)\n{\n\t// Draw the arrow\n\tCPoint ptArr[3];\n\tint x = rcBtn.left + rcBtn.Width()/3;\n\tint y = rcBtn.top + rcBtn.Height()/2;\t\n\tlong lHeight = rcBtn.Height()/4;\n\n\tCPen *pPen = NULL;\n\n\t// Change pen if button disabled\n\tif (bEnable == false)\n\t\tpPen = &m_penGray;\n\t\n\tCPen *pPrevPen = pDC->SelectObject(pPen);\n\n\t// Draw the left arrow\n\tif (btnStyle == ArrowLeft)\n\t{\n\t\tfor (int iHt=0; iHt<=lHeight; x++, iHt++)\n\t\t{\n\t\t\tpDC->MoveTo(x, y-iHt);\n\t\t\tpDC->LineTo(x, y+iHt+1);\n\t\t}\n\t}\n\t// Draw the right arrow\n\telse\n\t{\n\t\tfor (int iHt=lHeight; iHt>=0; x++, iHt--)\n\t\t{\n\t\t\tpDC->MoveTo(x, y-iHt);\n\t\t\tpDC->LineTo(x, y+iHt+1);\n\t\t}\n\t}\n\tpDC->SelectObject(pPrevPen);\n\n\t// Draw the button frame\n\tif (btnState == BtnUp)\n\t\tpDC->Draw3dRect(rcBtn, COLOR_WHITE, COLOR_DARKGRAY);\n\telse// if (btnState == BtnDown)\n\t\tpDC->Draw3dRect(rcBtn, COLOR_DARKGRAY, COLOR_WHITE);\n}\n\nvoid CTabCtrlEx::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\tCRect rcBtn;\n\tbool bOnButton = false;\n\tfor (int iBtn=0; iBtn<2; iBtn++)\n\t{\n\t\tGetButtonRect(iBtn, rcBtn);\n\t\tif (rcBtn.PtInRect(point) && m_bBtnEnabled[iBtn])\n\t\t{\n\t\t\tm_btnState[iBtn] = BtnDown;\n\t\t\tbOnButton = true;\n\t\t}\n\t}\n\n\tif (bOnButton)\n\t{\n\t\t// Get the mouse capture\n\t\tSetCapture();\n\n\t\t// Start the timer message\n\t\tSetTimer(ID_SCROLL_TIMER, 100, NULL);\n\n\t\t// Redraw the buttons\n\t\tRedrawWindow();\n\t}\n\t\n\tCWnd::OnLButtonDown(nFlags, point);\n}\n\nvoid CTabCtrlEx::OnTimer(UINT_PTR nIDEvent) \n{\n\tif (nIDEvent == ID_SCROLL_TIMER)\n\t{\n\t\tCPoint point(0, 0);\n\t\tGetCursorPos(&point);\n\t\tScreenToClient(&point);\n\t\tScrollTab(point);\n\n\t\t// Redraw the buttons and tabs\n\t\tRedrawWindow();\n\t}\n\t\n\tCWnd::OnTimer(nIDEvent);\n}\n\nvoid CTabCtrlEx::OnMouseMove(UINT nFlags, CPoint point) \n{\n\t/*\n\tCRect rcBtn;\n\tbool bRedrawButton = false;\n\tfor (int iBtn=0; iBtn<2; iBtn++)\n\t{\n\t\tGetButtonRect(iBtn, rcBtn);\n\t\tif (rcBtn.PtInRect(point) && m_bBtnEnabled[iBtn])\n\t\t{\n\t\t\tif (m_btnState[iBtn] != BtnHover)\n\t\t\t{\n\t\t\t\tm_btnState[iBtn] = BtnHover;\n\t\t\t\tbRedrawButton = true;\n\t\t\t\t\n\t\t\t\t// Get the mouse capture\n\t\t\t\tSetCapture();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m_btnState[iBtn] != BtnUp)\n\t\t\t{\n\t\t\t\tm_btnState[iBtn] = BtnUp;\n\t\t\t\tbRedrawButton = true;\n\n\t\t\t\t// Release the mouse capture\n\t\t\t\tReleaseCapture();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bRedrawButton)\n\t{\n\t\t// Redraw the buttons\n\t\tRedrawWindow();\n\t}\n\t*/\n\t\n\tCWnd::OnMouseMove(nFlags, point);\n}\n\nvoid CTabCtrlEx::OnLButtonUp(UINT nFlags, CPoint point)\n{\n\t// Release the mouse capture\n\tReleaseCapture();\n\n\t// End the timer\n\tKillTimer(ID_SCROLL_TIMER);\n\t\n\t// Check and scroll the tabs\n\tScrollTab(point);\n\t\n\t// Set the button state\n\tfor (int iBtn=0; iBtn<2; iBtn++)\n\t\tm_btnState[iBtn] = BtnUp;\n\t\n\t// Redraw the buttons\n\tRedrawWindow();\n\n\tCWnd::OnLButtonUp(nFlags, point);\n}\n\nvoid CTabCtrlEx::ScrollTab(CPoint point)\n{\n\tCRect rcBtn;\n\tfor (int iBtn=0; iBtn<2; iBtn++)\n\t{\n\t\tGetButtonRect(iBtn, rcBtn);\n\t\tif (rcBtn.PtInRect(point))\n\t\t{\n\t\t\tif (m_bBtnEnabled[iBtn])\n\t\t\t{\n\t\t\t\tm_btnState[iBtn] = BtnDown;\n\n\t\t\t\tif (iBtn == 0)\n\t\t\t\t{\n\t\t\t\t\tm_nLeftShifted -= SHIFT_UNITS;\n\t\t\t\t\tif (m_nLeftShifted < 0)\n\t\t\t\t\t\tm_nLeftShifted = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_nLeftShifted += SHIFT_UNITS;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_btnState[iBtn] = BtnUp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_btnState[iBtn] = BtnUp;\n\t\t}\n\t}\n\n\tCRect rcSpin;\n\tGetSpinnerRect(rcSpin);\n\tif (rcSpin.PtInRect(point) == FALSE)\n\t{\n\t\t// Adjust for the shift\n\t\tpoint.Offset(m_nLeftShifted, 0);\n\t\t\n\t\tCRect rcTab;\n\t\tfor (int iTab=0; iTab<m_Tabs.GetSize(); iTab++)\n\t\t{\n\t\t\tGetTabRect(iTab, rcTab);\n\t\t\tif (rcTab.PtInRect(point))\n\t\t\t{\n\t\t\t\t// Show the appropriate tab window\n\t\t\t\tActivateTab(iTab, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CTabCtrlEx::OnSize(UINT nType, int cx, int cy) \n{\n\tCWnd::OnSize(nType, cx, cy);\n\n\t// Resize the tabs\n\tif (m_nLeftShifted && (cx > m_nPrevWidth))\n\t{\n\t\tint nDispWidth = cx-GetSpinnerWidth();\n\t\tif ((nDispWidth+m_nLeftShifted) >= GetTabsWidth())\n\t\t{\n\t\t\tm_nLeftShifted -= (cx-m_nPrevWidth);\n\t\t\tif (m_nLeftShifted <= GetSpinnerWidth())\n\t\t\t\tm_nLeftShifted = 0;\n\t\t}\n\t}\n\n\tActivateTab(GetActiveTab(), false, true);\n\t\n\tm_nPrevWidth = cx;\n}\n\nBOOL CTabCtrlEx::PreTranslateMessage(MSG* pMsg) \n{\n\tswitch (pMsg->message)\n\t{\n\tcase WM_KEYDOWN:\n\t\tif (CONTROL_PRESSED)\n\t\t{\n\t\t\tif (pMsg->wParam == VK_TILDAE)\n\t\t\t{\n\t\t\t\tSwitchTabs((GetKeyState(VK_SHIFT) & 0x8000) == 0);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\telse if (((pMsg->wParam - '1') >= 0) && ((pMsg->wParam - '1') < (UINT) m_Tabs.GetSize()))\n\t\t\t{\n\t\t\t\t// Set the new active tab\n\t\t\t\tActivateTab((int)pMsg->wParam - '1', true);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t\n\treturn FALSE;\n}\n\nvoid CTabCtrlEx::SwitchTabs(bool bNext)\n{\n\tint nNewTab = GetActiveTab();\n\tif (bNext)\n\t\tnNewTab++;\n\telse\n\t\tnNewTab--;\n\n\tif (nNewTab < 0)\n\t\tnNewTab = (int)m_Tabs.GetSize()-1;\n\telse if (nNewTab >= m_Tabs.GetSize())\n\t\tnNewTab = 0;\n\n\t// Set the new active tab\n\tActivateTab(nNewTab, true);\n}\n\nvoid CTabCtrlEx::OnShowWindow(BOOL bShow, UINT nStatus)\n{\n\tif (bShow)\n\t{\n\t\t// Show the active tab\n\t\tSetActiveTab(GetActiveTab(), false);\n\t}\n\telse\n\t{\t\n\t\t// Hide the active tab\n\t\tif (GetActiveTab() >= 0)\n\t\t{\n\t\t\tCWnd* pWnd = m_Tabs[GetActiveTab()].pWnd;\n\t\t\tif (pWnd && IsWindow(pWnd->m_hWnd))\n\t\t\t\tpWnd->ShowWindow(SW_HIDE);\n\t\t}\n\t}\n}"
        },
        {
          "name": "TabCtrl.h",
          "type": "blob",
          "size": 4.611328125,
          "content": "#pragma once\n\n#include <afxtempl.h>\n\n#define SHEET_CLASSNAME\t\t_T(\"_TabCtrlClass_\")\n#define SHEET_CLASSTYLE\t\t(CS_DBLCLKS)\n\n// Sheet styles\n#define SCS_SHEET\t\t\t0x0000\n#define SCS_TAB\t\t\t\t0x0001\n#define SCS_TOP\t\t\t\t0x0002\n#define SCS_BOTTOM\t\t\t0x0004\n#define SCS_BOLD\t\t\t0x0008\n#define SCS_BORDER\t\t\t0x0010\n\n#define SN_SETACTIVETAB\t\tWM_APP + 1122\n\ntypedef struct tagNMTABCHANGE{\n    NMHDR hdr;\n    long lOldTab;\n    long lNewTab;\n\tlong lOldItemData;\n\tlong lNewItemData;\n} NMTABCHANGE, FAR *LPNMTABCHANGE;\n\n/////////////////////////////////////////////////////////////////////////////\n// CTabCtrlEx window\n\nclass CTabCtrlEx : public CWnd\n{\n// Construction\npublic:\n\tCTabCtrlEx();\n\npublic:\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CTabCtrlEx)\n\tpublic:\n\t//}}AFX_VIRTUAL\n\n// Implementation\npublic:\n\tvirtual ~CTabCtrlEx();\n\n\t// Create the sheet control\n\tvirtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);\n\n\t// Add a new window to the sheet. Returns the index of the new tab, -1 on error\n\tbool AddItem(const CString& csTabTitle, CWnd* pTabWnd);\n\n\t// Insert a new window in the sheet. Returns the index of the new tab, -1 on error\n\tbool InsertItem(int nTab, const CString& csTabTitle, CWnd* pTabWnd);\n\t\n\t//Replaces the window in nTab position -- Calls HideWindow for the old and ShowWindow for the new\n\tbool ReplaceItem(int nTab, const CString &csTabTitle, CWnd* pTabWnd);\n\n\t// Delete a tab in the sheet\n\tbool DeleteItem(int nTab);\n\n\t// Delete all tabs in the sheet\n\tbool DeleteAllItems();\n\t\n\t// Get/Set the tab title\n\tCString GetTabTitle(int nTab);\n\tbool SetTabTitle(int nTab, const CString& csTabTitle);\n\n\t// Get the active sheet\n\tint GetActiveTab();\n\n\t// Get the number of tabs\n\tint GetTabCount();\n\n\t// Set the active tab and make the tab title visible\n\tvoid SetActiveTab(int nTab, bool bNotify = true);\n\n\tbool SetTabItemData(int nTab, long lItemData);\n\tlong GetTabItemData(int nTab);\n\n\t// Make a tab title visible\n\tvoid MakeTabVisible(int nTab);\n\t\n\t// Set the tab height\n\tvoid SetTabHeight(int nTabHeight);\n\n\t// Relay keyboard events for the sheet to process,\n\t// returns TRUE if the message was processed, DO NOT process this message\n\t// return FALSE if the message was not processed\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\n\t// Underline a tab title, use color -1 to remove underline\n\tvoid UnderlineTabTitle(int nTab, COLORREF clr);\n\n\tvoid SetFocusToNewlySelectedTab(bool bVal)\t{ m_bSetFocusToNewlySelectedTab = bVal;\t}\n\tbool GetFocusToNewlySelectedTab()\t\t\t{ return m_bSetFocusToNewlySelectedTab;\t}\n\n\tvoid SetTabColors(COLORREF Selected, COLORREF NonSelected)\t{ m_SelectedColor = Selected; m_NonSelectedColor = NonSelected;}\n\nprotected:\n\tclass CTab\n\t{\n\tpublic:\n\t\tCTab()\n\t\t{\n\t\t\tlItemData = -1;\n\t\t}\n\t\tCString csTitle;\n\t\tCWnd* pWnd;\n\t\tlong lWidth;\n\t\tCOLORREF clrUnderline;\n\t\tlong lItemData;\n\t};\n\n\ttypedef enum {ArrowLeft, ArrowRight} ButtonStyle;\n\ttypedef enum {BtnDown, BtnUp/*, BtnHover*/} ButtonState;\n\t\t\n\nprotected:\n\tshort m_nStyle;\n\tCArray <CTab, CTab&> m_Tabs;\n\tint m_nActiveTab;\n\tint m_nTabHeight;\n\tCBrush m_brSelectedTab;\n\tCBrush m_brNonSelectedTab;\n\tCPen m_penGray;\n\tCPen m_penBlack;\n\tCFont *m_pFntText, *m_pFntBoldText;\n\tButtonState m_btnState[2];\n\tbool m_bBtnEnabled[2];\n\tint m_nLeftShifted;\n\tint m_nPrevWidth;\n\tbool m_bSetFocusToNewlySelectedTab;\n\tCOLORREF m_SelectedColor;\n\tCOLORREF m_NonSelectedColor;\n\n\t\nprotected:\n\tint GetTextWidth(const CString& csText);\n\tint GetDisplayWidth();\n\tint GetTabsWidth();\n\tint GetSpinnerWidth();\n\t\n\tvoid GetFullRect(CRect& rcTab);\n\tvoid GetTabListRect(CRect& rcTab);\n\tvoid GetTabRect(int nTab, CRect& rcTab);\n\tvoid GetSpinnerRect(CRect& rcButton);\n\tvoid GetButtonRect(int nBtn, CRect& rcBtn);\n\n\tvoid EnableSpinners();\n\tvoid DrawTabs(CDC *pDC);\n\tvoid DrawBar(CDC* pDC);\n\tvoid DrawTab(int nTab, CDC *pDC, CRect& rcTab);\n\tvoid DrawTabEx(int nTab, CDC *pDC, CRect& rcTab);\n\tvoid DrawSpinner(CDC *pDC);\n\tvoid DrawButton(CDC *pDC, CRect& rcBtn, ButtonState btnState, ButtonStyle btnStyle, bool bEnable);\n\tvoid ScrollTab(CPoint point);\n\t\n\tvoid ActivateTab(int nTab, bool bNotify, bool bOnSize = false);\n\tvoid ResizeTabWindow(int nOldTab, int nNewTab, bool bNotify, bool bOnSize);\n\tvoid SwitchTabs(bool bNext = true);\n\t\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CTabCtrlEx)\n\tafx_msg void OnPaint();\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnLButtonDown(UINT nFlags, CPoint point);\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\tafx_msg void OnMouseMove(UINT nFlags, CPoint point);\n\tafx_msg void OnLButtonUp(UINT nFlags, CPoint point);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnShowWindow(BOOL bShow, UINT nStatus);\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};"
        },
        {
          "name": "Theme.cpp",
          "type": "blob",
          "size": 7.75390625,
          "content": "#include \"stdafx.h\"\r\n#include \".\\theme.h\"\r\n#include \"shared/TextConvert.h\"\r\n#include \"Misc.h\"\r\n#include \"Options.h\"\r\n#include \"shared/Tokenizer.h\"\r\n#include \"CP_Main.h\"\r\n\r\nCTheme::CTheme(void)\r\n{\r\n\tm_lFileVersion = 0;\r\n\tm_LastWriteTime = 0;\r\n\tm_lastTheme = _T(\"\");\r\n\r\n\tLoadDefaults();\r\n}\r\n\r\nCTheme::~CTheme(void)\r\n{\r\n}\r\n\r\n\r\nvoid CTheme::LoadDefaults()\r\n{\r\n\tm_CaptionLeft = RGB(255, 255, 255);\r\n\tm_CaptionRight = RGB(204, 204, 204);\r\n\r\n\tm_Border = RGB(204, 204, 204);\r\n\tm_BorderTopMost = RGB(204, 204, 204);\r\n\tm_BorderNotConnected = RGB(204, 204, 204);\r\n\r\n\tm_CaptionLeftTopMost = RGB(255, 255, 255);\r\n\tm_CaptionRightTopMost = RGB(204, 204, 204);\r\n\t\r\n\tm_CaptionLeftNotConnected = RGB(255, 255, 255);\r\n\tm_CaptionRightNotConnected = RGB(255, 255, 0);\r\n\r\n\tm_CaptionTextColor = RGB(191, 191, 191);\r\n\tm_ListBoxOddRowsBG = RGB(255, 255, 255);\r\n\tm_ListBoxEvenRowsBG = RGB(243, 243, 243);\r\n\tm_ListBoxOddRowsText = RGB(0, 0, 0);\r\n\tm_ListBoxEvenRowsText = RGB(0, 0, 0);\r\n\tm_ListBoxSelectedBG = RGB(204, 204, 204);\r\n\tm_ListBoxSelectedNoFocusBG = RGB(204, 204, 204);\r\n\tm_ListBoxSelectedText = RGB(0, 0, 0);\r\n\tm_ListBoxSelectedNoFocusText = RGB(0, 0, 0);\r\n\tm_clipPastedColor = RGB(0, 255, 0);\r\n\tm_listSmallQuickPasteIndexColor = RGB(180, 180, 180);\r\n\tm_mainWindowBG = RGB(240, 240, 240);\r\n\tm_searchTextBoxFocusBG = RGB(255, 255, 255);\r\n\tm_searchTextBoxFocusText = RGB(0, 0, 0);\r\n\tm_searchTextBoxFocusBorder = RGB(255, 255, 255);\r\n\tm_searchTextHighlight = RGB(255, 0, 0);\r\n\r\n\tm_groupTreeBG = RGB(240, 240, 240);\r\n\tm_groupTreeText = RGB(127, 127, 127);\r\n\r\n\tm_descriptionWindowBG = RGB(240, 240, 240);// GetSysColor(COLOR_INFOBK);//RGB(240, 240, 240);//\r\n\t/*int r = GetRValue(m_descriptionWindowBG);\r\n\tint g = GetGValue(m_descriptionWindowBG);\r\n\tint b = GetBValue(m_descriptionWindowBG);*/\r\n\r\n\tm_descriptionWindowText = RGB(0, 0, 0);\r\n\r\n\tm_captionSize = 25;\r\n\tm_captionFontSize = 19;\r\n}\r\n\r\nbool CTheme::Load(CString csTheme, bool bHeaderOnly, bool bCheckLastWriteTime)\r\n{\r\n\tbool followWindows10Theme = false;\r\n\tif (csTheme.IsEmpty())\r\n\t{\r\n\t\tfollowWindows10Theme = true;\r\n\r\n\t\tif (DarkAppWindows10Setting())\r\n\t\t{\r\n\t\t\tcsTheme = _T(\"DarkerDitto\");\r\n\t\t\tLog(_T(\"Loading theme based on windows setting of dark mode for apps\"));\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tif (csTheme.IsEmpty() || csTheme == _T(\"Ditto\") || csTheme == _T(\"(Default)\") || csTheme == _T(\"(Ditto)\"))\r\n\t{\r\n\t\tLoadDefaults();\r\n\r\n\t\tif (followWindows10Theme)\r\n\t\t{\r\n\t\t\tLoadWindowsAccentColor();\r\n\t\t}\r\n\r\n\t\tm_LastWriteTime = 0;\r\n\t\tm_lastTheme = _T(\"\");\r\n\r\n\t\tLog(_T(\"Loading default ditto values for themes\"));\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString csPath = CGetSetOptions::GetPath(PATH_THEMES);\r\n\tcsPath += csTheme;\r\n\tcsPath += \".xml\";\r\n\r\n\t__int64 LastWrite = GetLastWriteTime(csPath);\r\n\r\n\tif(bCheckLastWriteTime)\r\n\t{\t\r\n\t\tif(m_lastTheme == csTheme &&\r\n\t\t\tLastWrite == m_LastWriteTime)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tLoadDefaults();\r\n\r\n\tm_LastWriteTime = LastWrite;\r\n\tm_lastTheme = csTheme;\r\n\r\n\tLog(StrF(_T(\"Loading Theme %s\"), csPath));\r\n\r\n\tTiXmlDocument doc;\r\n\tif(!doc.LoadFile(csPath.GetBuffer()))\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Error loading Theme %s - reason = %s\"), csPath, doc.ErrorDesc());\r\n\t\tASSERT(!m_csLastError);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTiXmlElement *ItemHeader = doc.FirstChildElement(\"Ditto_Theme_File\");\r\n\tif(!ItemHeader)\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Error finding the section Ditto_Theme_File\"));\r\n\t\tASSERT(!m_csLastError);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString csVersion = ItemHeader->Attribute(\"Version\");\r\n\tm_lFileVersion = ATOI(csVersion);\r\n\tm_csAuthor = ItemHeader->Attribute(\"Author\");\r\n\tm_csNotes = ItemHeader->Attribute(\"Notes\");\r\n\r\n\tif(bHeaderOnly)\r\n\t\treturn true;\r\n\r\n\r\n\tLoadColor(ItemHeader, \"CaptionLeft\", m_CaptionLeft);\r\n\tLoadColor(ItemHeader, \"CaptionRight\", m_CaptionRight);\r\n\tLoadColor(ItemHeader, \"CaptionLeftTopMost\", m_CaptionLeftTopMost);\r\n\tLoadColor(ItemHeader, \"CaptionRightTopMost\", m_CaptionRightTopMost);\r\n\tLoadColor(ItemHeader, \"CaptionLeftNotConnected\", m_CaptionLeftNotConnected);\r\n\tLoadColor(ItemHeader, \"CaptionRightNotConnected\", m_CaptionRightNotConnected);\r\n\tLoadColor(ItemHeader, \"CaptionTextColor\", m_CaptionTextColor);\r\n\tLoadColor(ItemHeader, \"ListBoxOddRowsBG\", m_ListBoxOddRowsBG);\r\n\tLoadColor(ItemHeader, \"ListBoxEvenRowsBG\", m_ListBoxEvenRowsBG);\r\n\tLoadColor(ItemHeader, \"ListBoxOddRowsText\", m_ListBoxOddRowsText);\r\n\tLoadColor(ItemHeader, \"ListBoxEvenRowsText\", m_ListBoxEvenRowsText);\r\n\tLoadColor(ItemHeader, \"ListBoxSelectedBG\", m_ListBoxSelectedBG);\r\n\tLoadColor(ItemHeader, \"ListBoxSelectedNoFocusBG\", m_ListBoxSelectedNoFocusBG);\r\n\tLoadColor(ItemHeader, \"ListBoxSelectedText\", m_ListBoxSelectedText);\r\n\tLoadColor(ItemHeader, \"ListBoxSelectedNoFocusText\", m_ListBoxSelectedNoFocusText);\r\n\tLoadColor(ItemHeader, \"ClipPastedColor\", m_clipPastedColor);\r\n\tLoadColor(ItemHeader, \"MainWindowBG\", m_mainWindowBG);\r\n\tLoadColor(ItemHeader, \"SearchTextBoxFocusBG\", m_searchTextBoxFocusBG);\r\n\tLoadColor(ItemHeader, \"SearchTextBoxFocusText\", m_searchTextBoxFocusText);\r\n\tLoadColor(ItemHeader, \"SearchTextBoxFocusBorder\", m_searchTextBoxFocusBorder);\r\n\tLoadColor(ItemHeader, \"SearchTextHighlight\", m_searchTextHighlight);\r\n\r\n\tLoadColor(ItemHeader, \"Border\", m_Border);\r\n\tLoadColor(ItemHeader, \"BorderTopMost\", m_BorderTopMost);\r\n\tLoadColor(ItemHeader, \"BorderNotConnected\", m_BorderNotConnected);\r\n\r\n\tLoadColor(ItemHeader, \"GroupTreeBG\", m_groupTreeBG);\r\n\tLoadColor(ItemHeader, \"GroupTreeText\", m_groupTreeText);\r\n\t\r\n\tLoadInt(ItemHeader, \"CaptionSize\", m_captionSize);\r\n\tLoadInt(ItemHeader, \"CaptionFontSize\", m_captionFontSize);\r\n\r\n\tLoadColor(ItemHeader, \"DescriptionWindowBG\", m_descriptionWindowBG);\r\n\tLoadColor(ItemHeader, \"DescriptionWindowText\", m_descriptionWindowText);\r\n\r\n\tif (followWindows10Theme)\r\n\t{\r\n\t\tLoadWindowsAccentColor();\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid CTheme::LoadWindowsAccentColor()\r\n{\r\n\tDWORD accent = Windows10AccentColor();\r\n\tif (accent != -1)\r\n\t{\r\n\t\t//windows seems to be bgr, convert to rgb\r\n\t\tauto r = GetRValue(accent);\r\n\t\tauto g = GetGValue(accent);\r\n\t\tauto b = GetBValue(accent);\r\n\r\n\t\tm_clipPastedColor = RGB(b, g, r);\r\n\t\tm_searchTextBoxFocusBorder = m_clipPastedColor;\r\n\t\tm_searchTextHighlight = m_clipPastedColor;\r\n\r\n\t\t//if (Windows10ColorTitleBar())\r\n\t\t//{\r\n\t\t//\tm_CaptionRight = m_clipPastedColor;\r\n\t\t//\tm_CaptionLeft = m_clipPastedColor;\r\n\t\t//\tm_Border = m_clipPastedColor;\r\n\t\t//}\r\n\t}\r\n}\r\n\r\nbool CTheme::LoadColor(TiXmlElement *pParent, CStringA csNode, COLORREF &Color)\r\n{\r\n\tint intValue = 0;\r\n\treturn LoadElement(pParent, csNode, Color, intValue);\r\n}\r\n\r\nbool CTheme::LoadInt(TiXmlElement *pParent, CStringA csNode, int &intValue)\r\n{\r\n\tCOLORREF colorValue = 0;\r\n\treturn LoadElement(pParent, csNode, colorValue, intValue);\r\n}\r\n\r\nbool CTheme::LoadElement(TiXmlElement *pParent, CStringA csNode, COLORREF &Color, int &intValue)\r\n{\r\n\tTiXmlElement *pColorNode = pParent->FirstChildElement(csNode);\r\n\tif(pColorNode == NULL)\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Theme Load, error loading Node = %s\"), csNode);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTiXmlNode *pColor = pColorNode->FirstChild();\r\n\tif(pColor == NULL)\r\n\t{\r\n\t\tm_csLastError.Format(_T(\"Theme Load, error getting node text for = %s\"), csNode);\r\n\t\tLog(m_csLastError);\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tCString csColor = pColor->Value();\r\n\r\n\tif (csColor == _T(\"\"))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (csColor.Find(_T(\"RGB\")) >= 0)\r\n\t{\r\n\t\tcsColor = csColor.Trim();\r\n\t\tcsColor.Replace(_T(\"RGB(\"), _T(\"\"));\r\n\t\tcsColor.Replace(_T(\")\"), _T(\"\"));\r\n\r\n\t\tCTokenizer token(csColor, _T(\",\"));\r\n\t\tCString csR;\r\n\t\tCString csG;\r\n\t\tCString csB;\r\n\r\n\t\ttoken.Next(csR);\r\n\t\ttoken.Next(csG);\r\n\t\ttoken.Next(csB);\r\n\r\n\t\tcsR = csR.Trim();\r\n\t\tcsG = csG.Trim();\r\n\t\tcsB = csB.Trim();\r\n\r\n\t\t//Only the first is valid they entered the RGB value as a single number\r\n\t\tif (csR != \"\" && csG == \"\" && csB == \"\")\r\n\t\t{\r\n\t\t\tColor = ATOI(csR);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tColor = RGB(ATOI(csR), ATOI(csG), ATOI(csB));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tintValue = ATOI(csColor);\r\n\t}\r\n\r\n\treturn true;\r\n}"
        },
        {
          "name": "Theme.h",
          "type": "blob",
          "size": 4.0146484375,
          "content": "#pragma once\r\n\r\n#include \"tinyxml\\Tinyxml.h\"\r\n#include \"tinyxml\\tinystr.h\"\r\n\r\nclass CTheme\r\n{\r\npublic:\r\n\tCTheme(void);\r\n\t~CTheme(void);\r\n\r\n\tbool Load(CString csTheme, bool bHeaderOnly = false, bool bCheckLastWriteTime = false);\t\r\n\r\n\tCOLORREF CaptionLeft() const { return m_CaptionLeft; }\r\n\tCOLORREF CaptionRight() const { return m_CaptionRight; }\r\n\tCOLORREF Border() const { return m_Border; }\r\n\tCOLORREF BorderTopMost() const { return m_BorderTopMost; }\r\n\tCOLORREF BorderNotConnected() const { return m_BorderNotConnected; }\r\n\tCOLORREF CaptionLeftTopMost() const { return m_CaptionLeftTopMost; }\r\n\tCOLORREF CaptionRightTopMost() const { return m_CaptionRightTopMost; }\r\n\tCOLORREF CaptionLeftNotConnected() const { return m_CaptionLeftNotConnected; }\r\n\tCOLORREF CaptionRightNotConnected() const { return m_CaptionRightNotConnected; }\r\n\tCOLORREF CaptionTextColor() const { return m_CaptionTextColor; }\r\n\t\r\n\tCOLORREF ListBoxOddRowsBG() const { return m_ListBoxOddRowsBG; }\r\n\tCOLORREF ListBoxEvenRowsBG() const { return m_ListBoxEvenRowsBG; }\r\n\tCOLORREF ListBoxOddRowsText() const { return m_ListBoxOddRowsText; }\r\n\tCOLORREF ListBoxEvenRowsText() const { return m_ListBoxEvenRowsText; }\r\n\tCOLORREF ListBoxSelectedBG() const { return m_ListBoxSelectedBG; }\r\n\tCOLORREF ListBoxSelectedNoFocusBG() const { return m_ListBoxSelectedNoFocusBG; }\r\n\tCOLORREF ListBoxSelectedText() const { return m_ListBoxSelectedText; }\r\n\tCOLORREF ListBoxSelectedNoFocusText() const { return m_ListBoxSelectedNoFocusText; }\r\n\tCOLORREF ClipPastedColor() const { return m_clipPastedColor; }\r\n\r\n\tCOLORREF ListSmallQuickPasteIndexColor() const { return m_listSmallQuickPasteIndexColor;  }\r\n\tCOLORREF MainWindowBG() const { return m_mainWindowBG; }\r\n\tCOLORREF SearchTextBoxFocusBG() const { return m_searchTextBoxFocusBG; }\r\n\tCOLORREF SearchTextBoxFocusText() const { return m_searchTextBoxFocusText; }\r\n\tCOLORREF SearchTextBoxFocusBorder() const { return m_searchTextBoxFocusBorder; }\r\n\tCOLORREF SearchTextHighlight() const { return m_searchTextHighlight; }\r\n\r\n\tCOLORREF GroupTreeBG() const { return m_groupTreeBG; }\r\n\tCOLORREF GroupTreeText() const { return m_groupTreeText; }\r\n\r\n\tint GetCaptionSize() const { return m_captionSize; }\r\n\tint GetCaptionFontSize() const { return m_captionFontSize; }\r\n\r\n\tCOLORREF DescriptionWindowBG() const { return m_descriptionWindowBG; }\r\n\tCOLORREF DescriptionWindowText() const { return m_descriptionWindowText; }\r\n\r\n\tCString Notes() const { return m_csNotes; }\r\n\tCString Author() const { return m_csAuthor; }\r\n\tlong FileVersion() const { return m_lFileVersion; }\r\n\r\n\tCString LastError() const { return m_csLastError; }\r\n\r\nprotected:\r\n\tbool LoadElement(TiXmlElement *pParent, CStringA csNode, COLORREF &Color, int &intValue);\r\n\r\n\tbool LoadInt(TiXmlElement *pParent, CStringA csNode, int &intValue);\r\n\tbool LoadColor(TiXmlElement *pParent, CStringA csNode, COLORREF &Color);\r\n\tvoid LoadWindowsAccentColor();\r\n\r\nprotected:\r\n\tCOLORREF m_CaptionLeft;\r\n\tCOLORREF m_CaptionRight;\r\n\tCOLORREF m_CaptionLeftTopMost;\r\n\tCOLORREF m_CaptionRightTopMost;\r\n\tCOLORREF m_CaptionLeftNotConnected;\r\n\tCOLORREF m_CaptionRightNotConnected;\r\n\tCOLORREF m_CaptionTextColor;\r\n\r\n\tCOLORREF m_ListBoxOddRowsBG;\r\n\tCOLORREF m_ListBoxEvenRowsBG;\r\n\tCOLORREF m_ListBoxOddRowsText;\r\n\tCOLORREF m_ListBoxEvenRowsText;\r\n\tCOLORREF m_ListBoxSelectedBG;\r\n\tCOLORREF m_ListBoxSelectedNoFocusBG;\r\n\tCOLORREF m_ListBoxSelectedText;\r\n\tCOLORREF m_ListBoxSelectedNoFocusText;\t\r\n\tCOLORREF m_clipPastedColor;\r\n\tCOLORREF m_listSmallQuickPasteIndexColor;\r\n\tCOLORREF m_mainWindowBG;\r\n\tCOLORREF m_Border;\r\n\tCOLORREF m_BorderTopMost;\r\n\tCOLORREF m_BorderNotConnected;\r\n\tCOLORREF m_searchTextBoxFocusBG;\r\n\tCOLORREF m_searchTextBoxFocusText;\r\n\tCOLORREF m_searchTextBoxFocusBorder;\r\n\tCOLORREF m_searchTextHighlight;\r\n\r\n\tCOLORREF m_groupTreeBG;\r\n\tCOLORREF m_groupTreeText;\r\n\r\n\tCOLORREF m_descriptionWindowBG;\r\n\tCOLORREF m_descriptionWindowText;\r\n\r\n\tint m_captionSize;\r\n\tint m_captionFontSize;\r\n\r\n\tCString m_csLastError;\r\n\tlong m_lFileVersion;\r\n\tCString m_csAuthor;\r\n\tCString m_csNotes;\r\n\r\n\t__int64 m_LastWriteTime;\r\n\tCString m_lastTheme;\r\n\r\n\tvoid LoadDefaults();\r\n};\r\n"
        },
        {
          "name": "TinyXml",
          "type": "tree",
          "content": null
        },
        {
          "name": "ToolTipEx.cpp",
          "type": "blob",
          "size": 38.0888671875,
          "content": "#include \"stdafx.h\"\r\n#include \"cp_main.h\"\r\n#include \"ToolTipEx.h\"\r\n#include \"BitmapHelper.h\"\r\n#include \"Options.h\"\r\n#include \"ActionEnums.h\"\r\n#include \"HyperLink.h\"\r\n#include <Richedit.h>\r\n\r\n#ifdef _DEBUG\r\n    #define new DEBUG_NEW\r\n    #undef THIS_FILE\r\n    static char THIS_FILE[] = __FILE__;\r\n#endif \r\n\r\n#define HIDE_WINDOW_TIMER 1\r\n#define SAVE_SIZE 2\r\n#define TIMER_BUTTON_UP 3\r\n#define TIMER_AUTO_MAX\t\t4\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CToolTipEx\r\n\r\nCToolTipEx::CToolTipEx(): m_dwTextStyle(DT_EXPANDTABS | DT_EXTERNALLEADING |\r\n                       DT_NOPREFIX | DT_WORDBREAK), m_rectMargin(2, 2, 3, 3),\r\n                        m_pNotifyWnd(NULL), m_clipId(0), m_clipRow(-1)\r\n{\r\n\tm_showPersistant = false;\r\n\tm_pToolTipActions = NULL;\r\n\tm_bMaxSetTimer = false;\r\n\tm_lDelayMaxSeconds = 2;\r\n\tm_showingText = false;\r\n\tm_showingRTF = false;\r\n\tm_showingHTML = false;\r\n}\r\n\r\nCToolTipEx::~CToolTipEx()\r\n{\r\n    m_Font.DeleteObject();\r\n\tm_clipDataFont.DeleteObject();\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CToolTipEx, CWnd)\r\n\t//{{AFX_MSG_MAP(CToolTipEx)\r\n\tON_WM_PAINT()\r\n\tON_WM_SIZE()\r\n\tON_WM_NCHITTEST()\r\n\tON_WM_ACTIVATE()\r\n\tON_WM_TIMER()\r\n\tON_WM_NCLBUTTONDBLCLK()\r\n\tON_WM_NCPAINT()\r\n\tON_WM_NCCALCSIZE()\r\n\tON_WM_NCLBUTTONDOWN()\r\n\tON_WM_NCMOUSEMOVE()\r\n\tON_WM_NCLBUTTONUP()\r\n\tON_WM_ERASEBKGND()\r\n\tON_COMMAND(ID_FIRST_REMEMBERWINDOWPOSITION, &CToolTipEx::OnRememberwindowposition)\r\n\tON_COMMAND(ID_FIRST_SIZEWINDOWTOCONTENT, &CToolTipEx::OnSizewindowtocontent)\r\n\tON_COMMAND(ID_FIRST_SCALEIMAGESTOFITWINDOW, &CToolTipEx::OnScaleimagestofitwindow)\r\n\tON_COMMAND(2, OnOptions)\r\n\tON_WM_RBUTTONDOWN()\r\n\tON_WM_SETFOCUS()\r\n\tON_COMMAND(ID_FIRST_HIDEDESCRIPTIONWINDOWONM, &CToolTipEx::OnFirstHidedescriptionwindowonm)\r\n\tON_COMMAND(ID_FIRST_WRAPTEXT, &CToolTipEx::OnFirstWraptext)\r\n\tON_WM_WINDOWPOSCHANGING()\r\n\tON_COMMAND(ID_FIRST_ALWAYSONTOP, &CToolTipEx::OnFirstAlwaysontop)\r\n\tON_NOTIFY(EN_MSGFILTER, 1, &CToolTipEx::OnEnMsgfilterRichedit21)\r\n\tON_MESSAGE(WM_DPICHANGED, OnDpiChanged)\r\n\tON_WM_MOVING()\r\n\tON_WM_ENTERSIZEMOVE()\r\n\tON_WM_HSCROLL()\r\n\tON_MESSAGE(WM_REFRESH_FOOTER, OnRefreshFooter)\r\n\tON_COMMAND(ID_FIRST_VIEWTEXT, &CToolTipEx::OnFirstViewtext)\r\n\tON_COMMAND(ID_FIRST_VIEWRTF, &CToolTipEx::OnFirstViewrtf)\r\n\tON_COMMAND(ID_FIRST_VIEWHTML, &CToolTipEx::OnFirstViewhtml)\r\n\tON_COMMAND(ID_FIRST_VIEWASIMAGE, &CToolTipEx::OnFirstViewImage)\r\n\tON_UPDATE_COMMAND_UI(ID_FIRST_VIEWTEXT, &CToolTipEx::OnUpdateFirstViewtext)\r\n\tON_UPDATE_COMMAND_UI(ID_FIRST_VIEWRTF, &CToolTipEx::OnUpdateFirstViewrtf)\r\n\tON_UPDATE_COMMAND_UI(ID_FIRST_VIEWHTML, &CToolTipEx::OnUpdateFirstViewhtml)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CToolTipEx message handlers\r\n\r\nBOOL CToolTipEx::Create(CWnd *pParentWnd)\r\n{\r\n\tm_saveWindowLockout = true;\r\n\r\n    // Get the class name and create the window\r\n    CString szClassName = AfxRegisterWndClass(CS_CLASSDC | CS_SAVEBITS, LoadCursor(NULL, IDC_ARROW));\r\n\r\n    // Create the window - just don't show it yet.\r\n    if( !CWnd::CreateEx(0, szClassName, _T(\"\"), WS_POPUP,\r\n       0, 0, 0, 0, pParentWnd->GetSafeHwnd(), 0, NULL))\r\n    {\r\n        return FALSE;\r\n    }\t\r\n\r\n\tHICON b = (HICON)LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME), IMAGE_ICON, 64, 64, LR_SHARED);\r\n\tSetIcon(b, TRUE);\r\n\r\n\t//CString szClassName2 = AfxRegisterWndClass(CS_CLASSDC | CS_SAVEBITS, LoadCursor(NULL, IDC_ARROW));\r\n\t//BOOL b = m_imageViewer.Create(_T(\"\"), szClassName2, WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL, CRect(0, 0, 0, 0), this, 3);\r\n\tm_imageViewer.Create(this);\r\n\t\r\n\t\r\n\tm_DittoWindow.DoCreate(this);\r\n\tm_DittoWindow.SetCaptionColors(CGetSetOptions::m_Theme.CaptionLeft(), CGetSetOptions::m_Theme.CaptionRight(), CGetSetOptions::m_Theme.Border());\r\n\tm_DittoWindow.SetCaptionOn(this, CGetSetOptions::GetCaptionPos(), true, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\r\n\tm_DittoWindow.m_bDrawMaximize = false;\r\n\tm_DittoWindow.m_bDrawMinimize = false;\r\n\tm_DittoWindow.m_bDrawChevron = true;\r\n\tm_DittoWindow.m_sendWMClose = false;\r\n\r\n    m_RichEdit.Create(_T(\"\"), _T(\"\"), WS_CHILD | WS_VISIBLE | WS_VSCROLL |\r\n\t\tWS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_NOHIDESEL |\r\n                      ES_AUTOHSCROLL, CRect(10, 10, 100, 200), this, 1);\r\n\r\n    m_RichEdit.SetReadOnly();\r\n    m_RichEdit.SetBackgroundColor(FALSE, CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\r\n\tm_RichEdit.SetEventMask(m_RichEdit.GetEventMask() | ENM_SELCHANGE | ENM_LINK | ENM_MOUSEEVENTS | ENM_SCROLLEVENTS);\r\n\tm_RichEdit.SetAutoURLDetect(TRUE);\r\n\t\r\n\tApplyWordWrap();\t   \r\n\r\n\tm_optionsButton.Create(NULL, WS_CHILD | BS_OWNERDRAW | WS_TABSTOP, CRect(0, 0, 0, 0), this, 2);\r\n\tm_optionsButton.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), IDB_COG_16_16, IDB_COG_20_20, IDB_COG_24_24, cog_28, IDB_COG_32_32, _T(\"PNG\"));\r\n\tm_optionsButton.SetToolTipText(theApp.m_Language.GetString(_T(\"DescriptionOptionsTooltip\"), _T(\"Description Options\")));\r\n\tm_optionsButton.ShowWindow(SW_SHOW);\r\n\r\n\tm_clipDataStatic.Create(_T(\"some text\"), WS_CHILD | WS_VISIBLE | SS_SIMPLE, CRect(0, 0, 0, 0), this, 3);\r\n\tm_folderPathStatic.Create(_T(\"some text\"), WS_CHILD | WS_VISIBLE | SS_SIMPLE, CRect(0, 0, 0, 0), this, 4);\r\n\r\n\tm_clipDataFont.CreateFont(-m_DittoWindow.m_dpi.Scale(11), 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"Segoe UI\"));\r\n\r\n\tm_Font.CreateFont(-m_DittoWindow.m_dpi.Scale(13), 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"Segoe UI\"));\r\n\tm_fontHeight = -13;\r\n\r\n\tm_clipDataStatic.SetFont(&m_clipDataFont);\r\n\tm_clipDataStatic.SetBkColor(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\tm_clipDataStatic.SetTextColor(RGB(80, 80, 80));\r\n\r\n\tm_folderPathStatic.SetFont(&m_clipDataFont);\r\n\tm_folderPathStatic.SetBkColor(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\tm_folderPathStatic.SetTextColor(RGB(80, 80, 80));\r\n\t\r\n\tm_saveWindowLockout = false;\r\n\r\n    return TRUE;\r\n}\r\n\r\nBOOL CToolTipEx::Show(CPoint point)\r\n{\r\n\tm_showingText = false;\r\n\tm_showingRTF = false;\r\n\tm_showingHTML = false;\r\n\tm_showingImage = false;\r\n\r\n\tCRect rect;\r\n\r\n\tif(CGetSetOptions::GetSizeDescWindowToContent() == FALSE)\r\n\t{\r\n\t\trect.left = point.x;\r\n\t\trect.top = point.y;\r\n\t\tCSize size;\r\n\t\tCGetSetOptions::GetDescWndSize(size);\r\n\t\trect.right = rect.left + m_DittoWindow.m_dpi.Scale(size.cx);\r\n\t\trect.bottom = rect.top + m_DittoWindow.m_dpi.Scale(size.cy);\r\n\r\n\t\tEnsureWindowVisible(&rect);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trect = GetBoundsRect();\r\n\r\n\t\t//account for the scroll bars\r\n\t\trect.right += 20;\r\n\t\trect.bottom += 20;\t\t\r\n\r\n\t\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t\t{\r\n\t\t\tint nWidth = m_imageViewer.m_pGdiplusBitmap->GetWidth() + ::GetSystemMetrics(SM_CXVSCROLL);\r\n\t\t\tint nHeight = m_imageViewer.m_pGdiplusBitmap->GetHeight() + ::GetSystemMetrics(SM_CYHSCROLL);\r\n\r\n\t\t\trect.right = rect.left + nWidth;\r\n\t\t\trect.bottom = rect.top + nHeight;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tlong lNewWidth = (long)rect.Width() + (long)(rect.Width() *1.25);\r\n\t\trect.right = rect.left + lNewWidth;\r\n\r\n\t\tlong lNewHeight = (long)rect.Height() + (long)(rect.Height() *1.25);\r\n\t\trect.bottom = rect.top + lNewHeight;\r\n\r\n\t\tClientToScreen(rect);\r\n\r\n\t\tCRect cr(point, point);\r\n\t\tCRect rcScreen = MonitorRectFromRect(cr);\r\n\r\n\t\t//ensure that we don't go outside the screen\r\n\t\tif(point.x < rcScreen.left)\r\n\t\t{\r\n\t\t\tpoint.x = rcScreen.left + 5;\r\n\t\t}\r\n\t\tif(point.y < rcScreen.top)\r\n\t\t{\r\n\t\t\tpoint.y = rcScreen.top + 5;\r\n\t\t}\r\n\r\n\t\trcScreen.DeflateRect(0, 0, 5, 5);\r\n\r\n\t\tlong width = rect.Width();\r\n\t\tlong height = rect.Height();\r\n\r\n\t\tif (width < 500)\r\n\t\t{\r\n\t\t\twidth = 500;\r\n\t\t}\r\n\r\n\t\trect.left = point.x;\r\n\t\trect.top = point.y;\r\n\t\trect.right = rect.left + width;\r\n\t\trect.bottom = rect.top + height;\r\n\t\t\r\n\t\tif (rect.right > rcScreen.right)\r\n\t\t{\r\n\t\t\trect.right = rcScreen.right;\r\n\t\t}\r\n\t\tif (rect.bottom > rcScreen.bottom)\r\n\t\t{\r\n\t\t\trect.bottom = rcScreen.bottom;\r\n\t\t}\r\n\t}\r\n\r\n\tif (m_csText.GetLength())\r\n\t{\r\n\t\tint wordCount = WordCount(m_csText);\r\n\t\tm_clipData = StrF(_T(\"%s | Length: %d | Words: %d\"), m_originalClipData, m_csText.GetLength(), wordCount);\r\n\t}\r\n\r\n\tm_clipDataStatic.SetWindowText(m_clipData);\r\n\tm_folderPathStatic.SetWindowText(m_folderPath);\r\n\r\n\tif (m_DittoWindow.m_bMinimized)\r\n\t{\r\n\t\t//m_DittoWindow.MinMaxWindow(this, FORCE_MAX);\r\n\t\tm_DittoWindow.m_bMinimized = false;\r\n\t}\r\n\r\n\tm_saveWindowLockout = true;\r\n\tMoveWindow(rect);\r\n\tMoveControls();\r\n\r\n\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t{\r\n\t\tm_imageViewer.UpdateBitmapSize(true);\r\n\t}\r\n\r\n\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t{\r\n\t\tint percent = (m_imageViewer.m_scale - 1.0) * 100.0;\r\n\t\tm_clipData = m_originalClipData + _T(\" | \") + StrF(_T(\"%d x %d, %d%%\"), m_imageViewer.m_pGdiplusBitmap->GetWidth(), m_imageViewer.m_pGdiplusBitmap->GetHeight(), percent);\r\n\r\n\t\t//OutputDebugString(_T(\"Showing image editor\\r\\n\"));\r\n\r\n\t\tm_RichEdit.ShowWindow(SW_HIDE);\r\n\t\tif (::IsWindow(m_browser.m_hWnd))\r\n\t\t{\r\n\t\t\tm_browser.ShowWindow(SW_HIDE);\r\n\t\t}\r\n\r\n\t\tm_imageViewer.ShowWindow(SW_SHOW);\r\n\r\n\t\tm_showingImage = true;\r\n\t}\r\n\telse if (m_html.GetLength() > 0 && m_csRTF.GetLength() <= 0)\r\n\t{\r\n\t\tm_imageViewer.ShowWindow(SW_HIDE);\r\n\t\tm_RichEdit.ShowWindow(SW_HIDE);\r\n\r\n\t\tif (::IsWindow(m_browser.m_hWnd))\r\n\t\t{\r\n\t\t\tm_browser.ShowWindow(SW_SHOW);\r\n\t\t\tm_browser.Invalidate();\r\n\t\t}\r\n\r\n\t\tm_showingHTML = true;\r\n\t\t//OutputDebugString(_T(\"Showing html\\r\\n\"));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_imageViewer.ShowWindow(SW_HIDE);\r\n\r\n\t\tif (::IsWindow(m_browser.m_hWnd))\r\n\t\t{\r\n\t\t\tm_browser.ShowWindow(SW_HIDE);\r\n\t\t}\r\n\r\n\t\tm_RichEdit.ShowWindow(SW_SHOW);\r\n\r\n\t\t//OutputDebugString(_T(\"Showing rich text\\r\\n\"));\r\n\t\tif (m_csRTF.GetLength() > 0)\r\n\t\t{\r\n\t\t\tm_showingRTF = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_showingText = true;\r\n\t\t}\r\n\t}\r\n\r\n\tShowWindow(SW_SHOWNA);\r\n\t//this->Invalidate();\r\n\t//this->UpdateWindow();\t\r\n\r\n\tm_saveWindowLockout = false;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CToolTipEx::GetWindowRectEx(LPRECT lpRect)\r\n{\r\n\tif (m_DittoWindow.m_bMinimized)\r\n\t{\r\n\t\t*lpRect = m_DittoWindow.m_crFullSizeWindow;\r\n\t\treturn;\r\n\t}\r\n\r\n\tCWnd::GetWindowRect(lpRect);\r\n}\r\n\r\nBOOL CToolTipEx::Hide()\r\n{\r\n\tdelete m_imageViewer.m_pGdiplusBitmap;\r\n\tm_imageViewer.m_pGdiplusBitmap = NULL;\r\n\r\n\tSaveWindowSize();\t\r\n\tShowWindow(SW_HIDE);\r\n\r\n\tif (m_browser.m_hWnd != NULL &&\r\n\t\t::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.DestroyWindow();\r\n\t}\r\n\r\n\tm_csRTF = \"\";\r\n\tm_csText = \"\";\r\n\tm_html = \"\";\r\n\tm_clipId = 0;\r\n\tm_clipRow = -1;\r\n\tm_searchText = _T(\"\");\r\n\tm_showPersistant = false;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CToolTipEx::OnNcLButtonDblClk(UINT nHitTest, CPoint point)\r\n{\r\n\t// toggle ShowPersistent when we double click the caption\r\n\tif (nHitTest == HTCAPTION)\r\n\t{\r\n\t\tOnFirstAlwaysontop();\r\n\t}\r\n\r\n\tCWnd::OnNcLButtonDblClk(nHitTest, point);\r\n}\r\n\r\nvoid CToolTipEx::SaveWindowSize()\r\n{\r\n\tif (::IsWindowVisible(m_hWnd))\r\n\t{\r\n\t\tCRect rect;\r\n\r\n\t\tif (m_DittoWindow.m_bMinimized)\r\n\t\t{\r\n\t\t\trect = m_DittoWindow.m_crFullSizeWindow;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis->GetWindowRect(&rect);\r\n\t\t}\r\n\r\n\t\tCSize s = rect.Size();\r\n\t\tCGetSetOptions::SetDescWndSize(CSize(m_DittoWindow.m_dpi.UnScale(s.cx), m_DittoWindow.m_dpi.UnScale(s.cy)));\r\n\t\tCGetSetOptions::SetDescWndPoint(rect.TopLeft());\r\n\r\n\t\tOutputDebugString(_T(\"Saving tooltip size\"));\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::PostNcDestroy()\r\n{\r\n\tCWnd::PostNcDestroy();\r\n\r\n\tdelete this;\r\n}\r\n\r\nBOOL CToolTipEx::PreTranslateMessage(MSG *pMsg)\r\n{\r\n\tm_DittoWindow.DoPreTranslateMessage(pMsg);\r\n\r\n\tswitch (pMsg->message)\r\n\t{\t\t\r\n        case WM_KEYDOWN:\r\n\r\n            switch(pMsg->wParam)\r\n            {\r\n            case 'C':\r\n                if(GetKeyState(VK_CONTROL) &0x8000)\r\n                {\r\n                    m_RichEdit.Copy();\r\n\t\t\t\t\ttheApp.SetCopyReason(CopyReasonEnum::COPY_FROM_TOOLTIP);\r\n\t\t\t\t\treturn TRUE;\r\n                }\r\n                break;\r\n            }\r\n\t\t\tbreak;\r\n\t\tcase WM_RBUTTONDOWN:\r\n\t\t\t{\r\n\t\t\t\tauto f = GetFocus();\r\n\t\t\t\tif (f != NULL &&\r\n\t\t\t\t\t(m_RichEdit.m_hWnd == f->m_hWnd ||\r\n\t\t\t\t\tm_imageViewer.m_hWnd == f->m_hWnd))\r\n\t\t\t\t{\r\n\t\t\t\t\tOnOptions();\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase WM_LBUTTONUP:\r\n\t\t\tauto f = GetFocus();\r\n\t\t\tif (f != NULL &&\r\n\t\t\t\tm_RichEdit.m_hWnd != f->m_hWnd &&\r\n\t\t\t\tm_optionsButton.m_hWnd != f->m_hWnd)\r\n\t\t\t{\r\n\t\t\t\tauto p = GetParent();\r\n\t\t\t\tif (p != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tp->SetFocus();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n    }\r\n\r\n\tif (m_pToolTipActions != NULL)\r\n\t{\r\n\t\tCAccel a;\r\n\t\tif (m_pToolTipActions->OnMsg(pMsg, a))\r\n\t\t{\r\n\t\t\tswitch (a.Cmd)\r\n\t\t\t{\r\n\t\t\tcase ActionEnums::CLOSEWINDOW:\r\n\t\t\t\t/*if (this->m_showPersistant &&\r\n\t\t\t\t\tm_DittoWindow.m_bMinimized == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_DittoWindow.MinMaxWindow(this, FORCE_MIN);\r\n\t\t\t\t\ttheApp.m_activeWnd.ReleaseFocus();\r\n\r\n\t\t\t\t\treturn TRUE;\r\n\t\t\t\t}*/\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n    return CWnd::PreTranslateMessage(pMsg);\r\n}\r\n\r\nBOOL CToolTipEx::OnMsg(MSG *pMsg)\r\n{\r\n    if(FALSE == IsWindowVisible())\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    switch(pMsg->message)\r\n    {\r\n        case WM_WINDOWPOSCHANGING:\r\n        case WM_LBUTTONDOWN:\r\n            {\r\n\t\t\t\tif (m_showPersistant == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (CGetSetOptions::GetMouseClickHidesDescription())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!IsCursorInToolTip())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tHide();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            }\r\n\t\t\tbreak;\r\n        case WM_KEYDOWN:\r\n            {\r\n                WPARAM vk = pMsg->wParam;\r\n\r\n\t\t\t\tif(vk == 'C')\r\n\t\t\t\t{\r\n\t\t\t\t\tif (GetKeyState(VK_CONTROL) & 0x8000)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (::IsWindow(m_browser.m_hWnd))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tm_browser.Copy();\r\n\t\t\t\t\t\t\ttheApp.SetCopyReason(CopyReasonEnum::COPY_FROM_TOOLTIP);\r\n\t\t\t\t\t\t\treturn TRUE;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n                \r\n                if(vk == VK_TAB)\r\n                {\r\n                    m_RichEdit.SetFocus();\r\n                    return TRUE;\r\n                }\r\n\t\t\t\telse if (vk == VK_CONTROL || vk == VK_SHIFT)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\telse if (vk == VK_UP)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\telse if (vk == VK_DOWN)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\telse if (vk == VK_NEXT)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\telse if (vk == VK_PRIOR)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t\telse if (vk == VK_DELETE)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m_pToolTipActions != NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (m_pToolTipActions->ContainsKey((int)vk))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn FALSE;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m_showPersistant == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tHide();\r\n\t\t\t\t}\r\n\r\n                break;\r\n            }\r\n\r\n        case WM_LBUTTONDBLCLK:\r\n        case WM_RBUTTONDBLCLK:\r\n        case WM_MBUTTONDOWN:\r\n        case WM_MBUTTONDBLCLK:\r\n        case WM_NCLBUTTONDOWN:\r\n        case WM_NCLBUTTONDBLCLK:\r\n        case WM_NCRBUTTONDOWN:\r\n        case WM_NCRBUTTONDBLCLK:\r\n        case WM_NCMBUTTONDOWN:\r\n        case WM_NCMBUTTONDBLCLK:\r\n            {\r\n\t\t\t\tif (m_showPersistant == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tHide();\r\n\t\t\t\t}\r\n                break;\r\n            }\r\n\r\n\t\tcase WM_MOUSEWHEEL:\r\n\t\tcase WM_MOUSEHWHEEL:\r\n\t\t{\r\n\t\t\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t\t\t{\r\n\t\t\t\tm_imageViewer.PostMessageW(pMsg->message, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_RichEdit.PostMessageW(pMsg->message, pMsg->wParam, pMsg->lParam);\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n    }\r\n\r\n\r\n    return FALSE;\r\n}\r\n\r\nCRect CToolTipEx::GetBoundsRect()\r\n{\r\n\tDWORD d = GetTickCount();\r\n\r\n    CWindowDC dc(NULL);\r\n\tint nLineWidth = 0;\r\n\r\n\tCRect rect(0, 0, 0, 0);\r\n\r\n    if(nLineWidth == 0)\r\n    {\r\n        // Count the number of lines of text\r\n\t\tint nStart = 0;\r\n\t\tINT nNumLines = 0;\r\n\t\tint longestLength = 0;\r\n\t\tCString longestString;\r\n        do\r\n        {\r\n\t\t\tnNumLines++;\r\n\r\n            int newStart = m_csText.Find(_T(\"\\n\"), nStart);\r\n\t\t\tif (newStart < 0)\r\n\t\t\t{\r\n\t\t\t\tint length = m_csText.GetLength() - nStart;\r\n\t\t\t\tif (length > longestLength)\r\n\t\t\t\t{\r\n\t\t\t\t\tlongestString = m_csText.Mid(nStart, length);\r\n\t\t\t\t\tlongestLength = length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tint length = newStart - nStart;\r\n\t\t\tif(length > longestLength)\r\n\t\t\t{\r\n\t\t\t\tlongestString = m_csText.Mid(nStart, length);\r\n\t\t\t\tlongestLength = length;\r\n\t\t\t}           \r\n\r\n            \r\n\t\t\tnStart = newStart + 1;\r\n        }\r\n        while(nStart >= 0 && nNumLines < 100);\r\n\r\n\t\tCFont *pOldFont = (CFont*)dc.SelectObject((CFont*)&m_Font);\r\n\t\tCSize size = dc.GetTextExtent(longestString);  \r\n\t\tdc.SelectObject(pOldFont);\r\n\r\n\t\trect.right = size.cx;\r\n\t\trect.bottom = size.cy * nNumLines;\r\n    }    \r\n\t\r\n    rect.bottom += m_rectMargin.top + m_rectMargin.bottom + GetSystemMetrics(SM_CYVSCROLL);\r\n    rect.right += m_rectMargin.left + m_rectMargin.right + GetSystemMetrics(SM_CXVSCROLL);\r\n\r\n    if(m_imageViewer.m_pGdiplusBitmap)\r\n    {\r\n\t\tint nWidth = m_imageViewer.m_pGdiplusBitmap->GetWidth();\r\n\t\tint nHeight = m_imageViewer.m_pGdiplusBitmap->GetHeight();\r\n\r\n        rect.bottom += nHeight;\r\n        if((rect.left + nWidth) > rect.right)\r\n        {\r\n            rect.right = rect.left + nWidth;\r\n        }\r\n    }\r\n\r\n\tDWORD diff = GetTickCount() - d;\r\n\tif (diff > 10)\r\n\t{\r\n\t\tLog(StrF(_T(\"Size To Content: %d\\n\"), diff));\r\n\t}\r\n\r\n    return rect;\r\n}\r\n\r\nCString CToolTipEx::GetFieldFromString(CString ref, int nIndex, TCHAR ch)\r\n{\r\n    CString strReturn;\r\n    LPCTSTR pstrStart = ref.LockBuffer();\r\n    LPCTSTR pstrBuffer = pstrStart;\r\n    int nCurrent = 0;\r\n    int nStart = 0;\r\n    int nEnd = 0;\r\n    int nOldStart = 0;\r\n\r\n    while(nCurrent <= nIndex &&  *pstrBuffer != _T('\\0'))\r\n    {\r\n        if(*pstrBuffer == ch)\r\n        {\r\n            nOldStart = nStart;\r\n            nStart = nEnd + 1;\r\n            nCurrent++;\r\n        }\r\n        nEnd++;\r\n        pstrBuffer++;\r\n    }\r\n\r\n    // May have reached the end of the string\r\n    if(*pstrBuffer == _T('\\0'))\r\n    {\r\n        nOldStart = nStart;\r\n        nEnd++;\r\n    }\r\n\r\n    ref.UnlockBuffer();\r\n\r\n    if(nCurrent < nIndex)\r\n    {\r\n        //TRACE1(\"Warning: GetStringField - Couldn't find field %d.\\n\", nIndex);\r\n        return strReturn;\r\n    }\r\n    return ref.Mid(nOldStart, nEnd - nOldStart - 1);\r\n}\r\n\r\nBOOL CToolTipEx::SetLogFont(LPLOGFONT lpLogFont, BOOL bRedraw /*=TRUE*/)\r\n{\r\n    ASSERT(lpLogFont);\r\n    if(!lpLogFont)\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    LOGFONT LogFont;\r\n\r\n    // Store font as the global default\r\n    memcpy(&LogFont, lpLogFont, sizeof(LOGFONT));\r\n\r\n\tm_fontHeight = lpLogFont->lfHeight;\r\n\r\n\tLogFont.lfHeight = m_DittoWindow.m_dpi.Scale(LogFont.lfHeight);\r\n\r\n    // Create the actual font object\r\n    m_Font.DeleteObject();\r\n    m_Font.CreateFontIndirect(&LogFont);\r\n\r\n    if(bRedraw && ::IsWindow(GetSafeHwnd()))\r\n    {\r\n        Invalidate();\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nvoid CToolTipEx::SetGdiplusBitmap(Gdiplus::Bitmap *gdiplusBitmap)\r\n{\r\n\tdelete m_imageViewer.m_pGdiplusBitmap;\r\n\tm_imageViewer.m_pGdiplusBitmap = NULL;\r\n\r\n\tm_imageViewer.m_pGdiplusBitmap = gdiplusBitmap;\r\n\tm_imageViewer.UpdateBitmapSize(true);\r\n\tInvalidate();\r\n}\r\n\r\nvoid CToolTipEx::OnSize(UINT nType, int cx, int cy)\r\n{\r\n    CWnd::OnSize(nType, cx, cy);\r\n\r\n    if(::IsWindow(m_RichEdit.GetSafeHwnd()) == FALSE)\r\n    {\r\n        return ;\r\n    }\r\n\r\n\tMoveControls();\r\n}\r\n\r\nvoid CToolTipEx::MoveControls()\r\n{\r\n\tCRect cr;\r\n\tGetClientRect(cr);\r\n\r\n\tint bottom = m_DittoWindow.m_dpi.Scale(22);\r\n\tint optionsExtra = 0;\r\n\r\n\tif (m_folderPath != _T(\"\"))\r\n\t{\r\n\t\tbottom += m_DittoWindow.m_dpi.Scale(17);\r\n\t\toptionsExtra += m_DittoWindow.m_dpi.Scale(10);\r\n\t\tm_folderPathStatic.ShowWindow(SW_SHOW);\t\t\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_folderPathStatic.ShowWindow(SW_HIDE);\r\n\t}\r\n\r\n\tcr.DeflateRect(0, 0, 0, bottom);\r\n\r\n\tm_RichEdit.MoveWindow(cr);\r\n\tm_imageViewer.MoveWindow(cr);\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.MoveWindow(cr);\r\n\t}\r\n\r\n\tm_optionsButton.MoveWindow(cr.left, cr.bottom + m_DittoWindow.m_dpi.Scale(3) + optionsExtra, m_DittoWindow.m_dpi.Scale(17), m_DittoWindow.m_dpi.Scale(17));\r\n\r\n\tm_clipDataStatic.MoveWindow(cr.left + m_DittoWindow.m_dpi.Scale(19), cr.bottom + m_DittoWindow.m_dpi.Scale(4), cr.Width() - cr.left + m_DittoWindow.m_dpi.Scale(19), m_DittoWindow.m_dpi.Scale(20));\r\n\r\n\tm_folderPathStatic.MoveWindow(cr.left + m_DittoWindow.m_dpi.Scale(19), cr.bottom + m_DittoWindow.m_dpi.Scale(20), cr.Width() - cr.left + m_DittoWindow.m_dpi.Scale(19), m_DittoWindow.m_dpi.Scale(20));\r\n\r\n\tthis->Invalidate();\r\n\r\n\tif (m_saveWindowLockout == false)\r\n\t{\r\n\t\tSetTimer(SAVE_SIZE, 250, NULL);\r\n\t}\r\n}\r\n\r\nBOOL CToolTipEx::IsCursorInToolTip()\r\n{\r\n    CRect cr;\r\n    GetWindowRect(cr);\r\n\r\n    CPoint cursorPos;\r\n    GetCursorPos(&cursorPos);\r\n\r\n    return cr.PtInRect(cursorPos);\r\n}\r\n\r\nvoid CToolTipEx::SetHtmlText(const CString &html)\r\n{\r\n\t//OutputDebugString(_T(\"SetHtmlText-\") + html.Left(20) + \"\\r\\n\");\r\n\r\n\tif (html.GetLength() > 0 &&\r\n\t\t::IsWindow(m_browser.m_hWnd) == FALSE)\r\n\t{\r\n\t\tm_browser.Create(WS_CHILD | WS_VISIBLE, CRect(10, 10, 100, 200), this, 2);\r\n\t}\r\n\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\t\t\r\n\t\tint pos = html.Find(_T(\"<html\"));\r\n\t\tif (pos >= 0)\r\n\t\t{\r\n\t\t\tm_html = html.Mid(pos);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint pos = html.Find(_T(\"<HTML\"));\r\n\t\t\tif (pos >= 0)\r\n\t\t\t{\r\n\t\t\t\tm_html = html.Mid(pos);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_html = html;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tCOLORREF c = CGetSetOptions::m_Theme.DescriptionWindowBG();\r\n\r\n\t\tDWORD dwR = GetRValue(c);\r\n\t\tDWORD dwG = GetGValue(c);\r\n\t\tDWORD dwB = GetBValue(c);\r\n\r\n\t\tCString colorHex;\r\n\t\tcolorHex.Format(_T(\"#%02X%02X%02X\"), dwR, dwG, dwB);\r\n\t\t\r\n\t\tm_html.Replace(_T(\"<body>\"), StrF(_T(\"<body bgcolor=\\\"%s\\\">\"), colorHex));\r\n\r\n\t\tm_browser.PutSilent(true);\r\n\t\tm_browser.Clear();\r\n\t\tm_browser.Write(m_html);\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::SetRTFText(const CStringA &rtf)\r\n{\r\n\t//OutputDebugStringA(\"SetRTF-\" + rtf.Left(20) + \"\\r\\n\");\r\n    m_RichEdit.SetRTF(rtf);\r\n    m_csRTF = rtf;\r\n\tm_RichEdit.SetSel(0, 0);\r\n\t\r\n\tHighlightSearchText();\r\n}\r\n\r\n//void CToolTipEx::SetRTFText(const CString &csRTF)\r\n//{\r\n//\tm_RichEdit.SetRTF(csRTF);\r\n//\tm_csRTF = csRTF;\r\n//}\r\n\r\nvoid CToolTipEx::SetToolTipText(const CString &csText)\r\n{\r\n\t//OutputDebugString(_T(\"SetRTF-\") + csText.Left(20) + \"\\r\\n\");\r\n\r\n    m_csText = csText;\r\n    m_RichEdit.SetFont(&m_Font);\r\n    m_RichEdit.SetText(csText);\r\n\tm_RichEdit.SetSel(0, 0);\r\n\r\n\tCHARFORMAT cfNew;\r\n\tcfNew.cbSize = sizeof(CHARFORMAT);\r\n\tcfNew.dwMask = CFM_COLOR;\r\n\tcfNew.dwEffects = CFM_COLOR;\r\n\tcfNew.dwEffects &= ~CFE_AUTOCOLOR;\r\n\tcfNew.crTextColor = CGetSetOptions::m_Theme.DescriptionWindowText();\r\n\tm_RichEdit.SetDefaultCharFormat(cfNew);\r\n\r\n\tHighlightSearchText();\r\n}\r\n\r\nvoid CToolTipEx::HighlightSearchText()\r\n{\r\n\tif (m_searchText.GetLength() <= 0)\r\n\t\treturn;\r\n\r\n\tFINDTEXTEX ft;\r\n\tlong n = -1;\r\n\r\n\tft.lpstrText = m_searchText;\r\n\t\r\n\tft.chrg.cpMin = 0;\r\n\tft.chrg.cpMax = -1;\r\n\r\n\tCHARFORMAT cf;\r\n\r\n\tcf.cbSize = sizeof(cf);\r\n\tcf.dwMask = CFM_COLOR;\r\n\tcf.dwEffects = CFE_BOLD | ~CFE_AUTOCOLOR;\r\n\tcf.crTextColor = RGB(255, 0, 0);\r\n\r\n\tm_RichEdit.SetRedraw(0);\r\n\tauto mask = m_RichEdit.GetEventMask();\r\n\tm_RichEdit.SetEventMask(0);\r\n\r\n\r\n\tint matches = 0;\r\n\tdo \r\n\t{\r\n\t\tft.chrg.cpMin = n+1;\r\n\t\tn = m_RichEdit.FindText(FR_DOWN, &ft);\r\n\t\tif (n != -1)\r\n\t\t{\r\n\t\t\tm_RichEdit.SetSel(ft.chrgText);\r\n\t\t\tm_RichEdit.SetSelectionCharFormat(cf);\r\n\t\t}\r\n\r\n\t\tmatches++;\r\n\r\n\t} while (n != -1 && matches < 100);\t\r\n\r\n\tm_RichEdit.SetSel(0, 0);\r\n\tm_RichEdit.SetEventMask(mask);\r\n\tm_RichEdit.SetRedraw(1);\r\n\tm_RichEdit.UpdateWindow();\r\n}\r\n\r\nvoid CToolTipEx::DoSearch()\r\n{\r\n\tif (m_searchText.GetLength() <= 0)\r\n\t\treturn;\r\n\r\n\tFINDTEXTEX ft;\r\n\tlong n = -1;\r\n\r\n\tft.lpstrText = m_searchText;\r\n\r\n\tlong start;\r\n\tlong end;\r\n\tm_RichEdit.GetSel(start, end);\r\n\r\n\tft.chrg.cpMin = end;\r\n\tft.chrg.cpMax = -1;\r\n\r\n\tint searchDirection = FR_DOWN;\r\n\tif (GetKeyState(VK_SHIFT) & 0x8000)\r\n\t{\r\n\t\tsearchDirection = 0;\r\n\t\tft.chrg.cpMin = start;\r\n\t}\r\n\r\n\tn = m_RichEdit.FindText(searchDirection, &ft);\r\n\tif (n != -1)\r\n\t{\r\n\t\t//if needing to scroll back to the left make sure the full text is visible\r\n\t\t//setSel scrolls to the end of the selection\r\n\t\tint start = ft.chrgText.cpMin;\r\n\t\tif (start < 0)\r\n\t\t{\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\t\tm_RichEdit.SetSel(start, start);\r\n\t\tm_RichEdit.SetSel(ft.chrgText);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (searchDirection == 0)\r\n\t\t{\r\n\t\t\tft.chrg.cpMin = m_RichEdit.GetTextLength();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tft.chrg.cpMin = 0;\r\n\t\t}\r\n\t\tft.chrg.cpMax = -1;\r\n\r\n\t\tn = m_RichEdit.FindText(searchDirection, &ft);\r\n\t\tif (n != -1)\r\n\t\t{\r\n\t\t\t//if needing to scroll back to the left make sure the full text is visible\r\n\t\t\t//setSel scrolls to the end of the selection\r\n\t\t\tint start = ft.chrgText.cpMin;\r\n\t\t\tif (start < 0)\r\n\t\t\t{\r\n\t\t\t\tstart = 0;\r\n\t\t\t}\r\n\t\t\tm_RichEdit.SetSel(start, start);\r\n\t\t\tm_RichEdit.SetSel(ft.chrgText);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized)\r\n{\r\n    CWnd::OnActivate(nState, pWndOther, bMinimized);\r\n\r\n\tif (nState == WA_INACTIVE)\r\n\t{\t\t\r\n        if(m_pNotifyWnd)\r\n        {\r\n            m_pNotifyWnd->PostMessage(NM_INACTIVE_TOOLTIPWND, 0, 0);\r\n        }\r\n    }\r\n}\r\n\r\nvoid CToolTipEx::OnTimer(UINT_PTR nIDEvent)\r\n{\r\n    switch(nIDEvent)\r\n    {\r\n        case HIDE_WINDOW_TIMER:\r\n            Hide();\r\n            PostMessage(WM_DESTROY, 0, 0);\r\n            break;\r\n\t\tcase SAVE_SIZE:\r\n\t\t\tSaveWindowSize();\r\n\t\t\tKillTimer(SAVE_SIZE);\r\n\t\t\tbreak;\r\n\t\tcase TIMER_BUTTON_UP:\r\n\t\t{\r\n\t\t\tif ((GetKeyState(VK_LBUTTON) & 0x100) == 0)\r\n\t\t\t{\r\n\t\t\t\tm_DittoWindow.DoNcLButtonUp(this, 0, CPoint(0, 0));\r\n\t\t\t\tKillTimer(TIMER_BUTTON_UP);\r\n\r\n\t\t\t\tauto f = GetFocus();\r\n\t\t\t\tif (f != NULL &&\r\n\t\t\t\t\tm_RichEdit.m_hWnd != f->m_hWnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tauto p = GetParent();\r\n\t\t\t\t\tif (p != NULL)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tp->SetFocus();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase TIMER_AUTO_MAX:\r\n\t\t{\r\n\t\t\tif (m_DittoWindow.m_bMinimized)\r\n\t\t\t{\r\n\t\t\t\tCPoint cp;\r\n\t\t\t\tGetCursorPos(&cp);\r\n\r\n\t\t\t\tUINT nHitTest = (UINT)OnNcHitTest(cp);\r\n\r\n\t\t\t\tScreenToClient(&cp);\r\n\r\n\t\t\t\tif (nHitTest == HTCAPTION)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (m_DittoWindow.m_crCloseBT.PtInRect(cp) == false)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (m_DittoWindow.m_crMinimizeBT.PtInRect(cp) == false)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tm_DittoWindow.MinMaxWindow(this, FORCE_MAX);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tKillTimer(TIMER_AUTO_MAX);\r\n\t\t\tm_bMaxSetTimer = false;\r\n\t\t}\r\n\r\n    }\r\n\r\n    CWnd::OnTimer(nIDEvent);\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnNcPaint()\r\n{\r\n\tm_DittoWindow.DoNcPaint(this);\r\n}\r\n\r\nvoid CToolTipEx::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) \r\n{\r\n\tCWnd::OnNcCalcSize(bCalcValidRects, lpncsp);\r\n\r\n\tm_DittoWindow.DoNcCalcSize(bCalcValidRects, lpncsp);\r\n}\r\n\r\nHITTEST_RET CToolTipEx::OnNcHitTest(CPoint point) \r\n{\r\n\tUINT Ret = m_DittoWindow.DoNcHitTest(this, point);\r\n\tif(Ret == -1)\r\n\t\treturn CWnd::OnNcHitTest(point);\r\n\r\n\treturn Ret;\r\n}\r\n\r\nvoid CToolTipEx::OnNcLButtonDown(UINT nHitTest, CPoint point) \r\n{\r\n\tint buttonPressed = m_DittoWindow.DoNcLButtonDown(this, nHitTest, point);\r\n\r\n\tSetTimer(TIMER_BUTTON_UP, 100, NULL);\r\n\t\r\n\tCWnd::OnNcLButtonDown(nHitTest, point);\r\n}\r\n\r\nvoid CToolTipEx::OnNcLButtonUp(UINT nHitTest, CPoint point) \r\n{\r\n\tlong lRet = m_DittoWindow.DoNcLButtonUp(this, nHitTest, point);\r\n\r\n\tswitch(lRet)\r\n\t{\r\n\tcase BUTTON_CLOSE:\r\n\t\tHide();\r\n\t\tbreak;\r\n\tcase BUTTON_CHEVRON:\r\n\t\tm_DittoWindow.MinMaxWindow(this, SWAP_MIN_MAX);\r\n\t\tOnNcPaint();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tKillTimer(TIMER_BUTTON_UP);\r\n\r\n\tauto f = GetFocus();\r\n\r\n\tif (f != NULL &&\r\n\t\tm_RichEdit.m_hWnd != f->m_hWnd)\r\n\t{\r\n\t\tauto p = GetParent();\r\n\t\tif (p != NULL)\r\n\t\t{\r\n\t\t\tp->SetFocus();\r\n\t\t}\r\n\t}\r\n\r\n\tCWnd::OnNcLButtonUp(nHitTest, point);\r\n}\r\n\r\nvoid CToolTipEx::OnNcMouseMove(UINT nHitTest, CPoint point) \r\n{\r\n\tm_DittoWindow.DoNcMouseMove(this, nHitTest, point);\r\n\r\n\tif ((m_bMaxSetTimer == false) && m_DittoWindow.m_bMinimized)\r\n\t{\r\n\t\tCOleDateTimeSpan sp = COleDateTime::GetCurrentTime() - m_DittoWindow.m_TimeMinimized;\r\n\t\tif (sp.GetTotalSeconds() >= m_lDelayMaxSeconds)\r\n\t\t{\r\n\t\t\tSetTimer(TIMER_AUTO_MAX, CGetSetOptions::GetTimeBeforeExpandWindow(), NULL);\r\n\t\t\tm_bMaxSetTimer = true;\r\n\t\t}\r\n\t}\r\n\r\n\tCWnd::OnNcMouseMove(nHitTest, point);\r\n}\r\n\r\nvoid CToolTipEx::OnOptions()\r\n{\r\n\tPOINT pp;\r\n\tCMenu cmPopUp;\r\n\tCMenu *cmSubMenu = NULL;\r\n\r\n\tGetCursorPos(&pp);\r\n\tif(cmPopUp.LoadMenu(IDR_DESC_OPTIONS_MENU) != 0)\r\n\t{\r\n\t\tcmSubMenu = cmPopUp.GetSubMenu(0);\r\n\t\tif(!cmSubMenu)\r\n\t\t{\r\n\t\t\treturn ;\r\n\t\t}\r\n\r\n\t\tGetCursorPos(&pp);\r\n\r\n\t\t//theApp.m_Language.UpdateRightClickMenu(cmSubMenu);\r\n\r\n\t\tif(CGetSetOptions::GetRememberDescPos())\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_REMEMBERWINDOWPOSITION, MF_CHECKED);\r\n\r\n\t\tif(CGetSetOptions::GetSizeDescWindowToContent())\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_SIZEWINDOWTOCONTENT, MF_CHECKED);\r\n\r\n\t\tif(CGetSetOptions::GetScaleImagesToDescWindow())\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_SCALEIMAGESTOFITWINDOW, MF_CHECKED);\r\n\r\n\t\tif (CGetSetOptions::GetMouseClickHidesDescription())\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_HIDEDESCRIPTIONWINDOWONM, MF_CHECKED);\t\t\r\n\r\n\t\tif (m_showPersistant)\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_ALWAYSONTOP, MF_CHECKED);\r\n\r\n\t\tif (m_showingText)\r\n\t\t{\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_VIEWTEXT, MF_CHECKED);\r\n\t\t}\r\n\t\tif (m_csText.GetLength() <= 0)\r\n\t\t{\r\n\t\t\tcmSubMenu->EnableMenuItem(ID_FIRST_VIEWTEXT, MF_DISABLED);\r\n\t\t}\r\n\r\n\t\tif (m_showingRTF)\r\n\t\t{\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_VIEWRTF, MF_CHECKED);\r\n\t\t}\r\n\t\tif (m_csRTF.GetLength() <= 0)\r\n\t\t{\r\n\t\t\tcmSubMenu->EnableMenuItem(ID_FIRST_VIEWRTF, MF_DISABLED);\r\n\t\t}\r\n\r\n\t\tif (m_showingHTML)\r\n\t\t{\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_VIEWHTML, MF_CHECKED);\r\n\t\t}\r\n\t\tif (m_html.GetLength() <= 0)\r\n\t\t{\r\n\t\t\tcmSubMenu->EnableMenuItem(ID_FIRST_VIEWHTML, MF_DISABLED);\r\n\t\t}\r\n\r\n\t\tif (m_showingImage)\r\n\t\t{\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_VIEWASIMAGE, MF_CHECKED);\r\n\t\t}\r\n\t\tif (m_imageViewer.m_pGdiplusBitmap == NULL)\r\n\t\t{\r\n\t\t\tcmSubMenu->EnableMenuItem(ID_FIRST_VIEWASIMAGE, MF_DISABLED);\r\n\t\t}\r\n\r\n\t\tUpdateMenuShortCut(cmSubMenu, ID_FIRST_WRAPTEXT, ActionEnums::TOGGLE_DESCRIPTION_WORD_WRAP);\r\n\t\tUpdateMenuShortCut(cmSubMenu, ID_FIRST_ALWAYSONTOP, ActionEnums::TOGGLESHOWPERSISTANT);\r\n\r\n\t\tif (CGetSetOptions::GetWrapDescriptionText())\r\n\t\t\tcmSubMenu->CheckMenuItem(ID_FIRST_WRAPTEXT, MF_CHECKED);\r\n\t\t\r\n\t\tcmSubMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, pp.x, pp.y, this, NULL);\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::UpdateMenuShortCut(CMenu *subMenu, int id, DWORD action)\r\n{\r\n\tif (m_pToolTipActions != NULL)\r\n\t{\r\n\t\tCString cs;\r\n\t\tsubMenu->GetMenuString(id, cs, MF_BYCOMMAND);\r\n\t\tCString shortcutText = m_pToolTipActions->GetCmdKeyText(action);\r\n\t\tif (shortcutText != _T(\"\") &&\r\n\t\t\tcs.Find(\"\\t\" + shortcutText) < 0)\r\n\t\t{\r\n\t\t\tcs += \"\\t\";\r\n\t\t\tcs += shortcutText;\r\n\t\t\tsubMenu->ModifyMenu(id, MF_BYCOMMAND, id, cs);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::OnRememberwindowposition()\r\n{\r\n\tCGetSetOptions::SetRememberDescPos(!CGetSetOptions::GetRememberDescPos());\r\n}\r\n\r\nvoid CToolTipEx::OnSizewindowtocontent()\r\n{\r\n\tCGetSetOptions::SetSizeDescWindowToContent(!CGetSetOptions::GetSizeDescWindowToContent());\r\n\r\n\tCRect rect;\r\n\tthis->GetWindowRect(&rect);\r\n\r\n\tShow(rect.TopLeft());\r\n}\r\n\r\nvoid CToolTipEx::OnScaleimagestofitwindow()\r\n{\r\n\tCGetSetOptions::SetScaleImagesToDescWindow(!CGetSetOptions::GetScaleImagesToDescWindow());\r\n\tm_imageViewer.UpdateBitmapSize(true);\r\n\tInvalidate();\r\n}\r\n\r\nvoid CToolTipEx::OnRButtonDown(UINT nFlags, CPoint point)\r\n{\r\n\tOnOptions();\r\n\r\n\tCWnd::OnRButtonDown(nFlags, point);\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnSetFocus(CWnd* pOldWnd)\r\n{\r\n\tCWnd::OnSetFocus(pOldWnd);\r\n\r\n\tif (m_RichEdit.IsWindowVisible())\r\n\t{\r\n\t\tm_RichEdit.SetFocus();\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::OnPaint()\r\n{\r\n\tCPaintDC dc(this); // device context for painting\r\n\r\n\tCRect rect;\r\n\tGetClientRect(rect);\r\n\t\r\n\tCBrush  Brush, *pOldBrush;\r\n\tBrush.CreateSolidBrush(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\r\n\tpOldBrush = dc.SelectObject(&Brush);\r\n\r\n\tdc.FillRect(&rect, &Brush);\r\n\r\n\t// Cleanup\r\n\tdc.SelectObject(pOldBrush);\r\n}\r\n\r\nvoid CToolTipEx::OnFirstHidedescriptionwindowonm()\r\n{\r\n\tCGetSetOptions::SetMouseClickHidesDescription(!CGetSetOptions::GetMouseClickHidesDescription());\r\n}\r\n\r\nbool CToolTipEx::ToggleWordWrap()\r\n{\r\n\tbool didWordWrap = false;\r\n\tif (m_RichEdit.IsWindowVisible())\r\n\t{\r\n\t\tOnFirstWraptext();\r\n\t\tdidWordWrap = true;\r\n\t}\r\n\r\n\treturn didWordWrap;\r\n}\r\n\r\nvoid CToolTipEx::OnFirstWraptext()\r\n{\r\n\tCGetSetOptions::SetWrapDescriptionText(!CGetSetOptions::GetWrapDescriptionText());\t\r\n\tApplyWordWrap();\r\n}\r\n\r\nvoid CToolTipEx::ApplyWordWrap()\r\n{\r\n\tif (CGetSetOptions::GetWrapDescriptionText())\r\n\t{\r\n\t\tm_RichEdit.SetTargetDevice(NULL, 0);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_RichEdit.SetTargetDevice(NULL, 1);\r\n\t}\r\n}\r\n\r\nvoid CToolTipEx::HideWindowInXMilliSeconds(long lms) \r\n{ \r\n\tSetTimer(HIDE_WINDOW_TIMER, lms, NULL); \r\n}\r\n\r\nvoid CToolTipEx::OnWindowPosChanging(WINDOWPOS* lpwndpos)\r\n{\r\n\tCWnd::OnWindowPosChanging(lpwndpos);\r\n\r\n\t//m_DittoWindow.SnapToEdge(this, lpwndpos);\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnFirstAlwaysontop()\r\n{\r\n\tm_showPersistant = !m_showPersistant;\r\n\tif (m_showPersistant)\r\n\t{\r\n\t\tm_DittoWindow.m_customWindowTitle = _T(\"[Always on top]\");\r\n\t\tm_DittoWindow.m_useCustomWindowTitle = true;\r\n\t\t::SetWindowPos(m_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOACTIVATE);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tm_DittoWindow.m_customWindowTitle = _T(\"\");\r\n\t\tm_DittoWindow.m_useCustomWindowTitle = true;\r\n\t}\r\n\r\n\t::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\t\r\n}\r\n\r\nBOOL CToolTipEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)\r\n{\r\n\t//CString cs;\r\n\t//cs.Format(_T(\"On Notify: %d\\r\\n\"), ((LPNMHDR)lParam)->code);\r\n\t//OutputDebugString(cs);\r\n\tswitch (((LPNMHDR)lParam)->code)\r\n\t{\r\n\t\tcase EN_LINK:\r\n\t\t{\r\n\t\t\tENLINK *enLinkInfo = (ENLINK *)lParam; // pointer to a ENLINK structure\r\n\t\t\tif (enLinkInfo->msg == WM_LBUTTONUP)\r\n\t\t\t{\r\n\t\t\t\tCString s;\r\n\t\t\t\tm_RichEdit.GetTextRange(enLinkInfo->chrg.cpMin, enLinkInfo->chrg.cpMax, s);\r\n\r\n\t\t\t\tif (s == m_mouseDownOnLink)\r\n\t\t\t\t{\r\n\t\t\t\t\tCHyperLink::GotoURL(s, SW_SHOW);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_mouseDownOnLink = _T(\"\");\r\n\t\t\t}\r\n\t\t\tif (enLinkInfo->msg == WM_LBUTTONDOWN)\r\n\t\t\t{\r\n\t\t\t\tm_RichEdit.GetTextRange(enLinkInfo->chrg.cpMin, enLinkInfo->chrg.cpMax, m_mouseDownOnLink);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase SimpleBrowser::NotificationType::BeforeNavigate2:\r\n\t\t{\r\n\t\t\tSimpleBrowser::Notification * not = (SimpleBrowser::Notification *)lParam;\r\n\t\t\tif (not != NULL)\r\n\t\t\t{\r\n\t\t\t\tif (not->URL.Find(_T(\"http\")) >= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tCHyperLink::GotoURL(not->URL, SW_SHOW);\r\n\t\t\t\t\t*pResult = TRUE;\r\n\t\t\t\t\t//return TRUE;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tint x = 0;\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn CWnd::OnNotify(wParam, lParam, pResult);\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnEnMsgfilterRichedit21(NMHDR *pNMHDR, LRESULT *pResult)\r\n{\r\n\tMSGFILTER *pMsgFilter = reinterpret_cast<MSGFILTER *>(pNMHDR);\r\n\tif (pMsgFilter != NULL)\r\n\t{\r\n\t\tswitch (pMsgFilter->msg)\r\n\t\t{\r\n\t\t\t//handle click on the rich text control when it doesn't have focus\r\n\t\t\t//set focus so the first click is handled by the rich text control\r\n\t\tcase WM_MOUSEACTIVATE:\r\n\t\t\tm_RichEdit.SetFocus();\r\n\t\t\tbreak;\r\n\t\tcase WM_MOUSEHWHEEL:\t\t\t\r\n\t\t\tint delta = GET_WHEEL_DELTA_WPARAM(pMsgFilter->wParam);\r\n\t\t\tif (delta < 0)\r\n\t\t\t{\t\t\t\r\n\t\t\t\tm_RichEdit.SendMessage(WM_HSCROLL, SB_LINERIGHT, NULL);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm_RichEdit.SendMessage(WM_HSCROLL, SB_LINELEFT, NULL);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t*pResult = 0;\r\n}\r\n\r\nLRESULT CToolTipEx::OnDpiChanged(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tint dpi = HIWORD(wParam);\r\n\tm_DittoWindow.OnDpiChanged(this, dpi);\r\n\r\n\tRECT* const prcNewWindow = (RECT*)lParam;\r\n\tSetWindowPos(NULL,\r\n\t\tprcNewWindow->left,\r\n\t\tprcNewWindow->top,\r\n\t\tprcNewWindow->right - prcNewWindow->left,\r\n\t\tprcNewWindow->bottom - prcNewWindow->top,\r\n\t\tSWP_NOZORDER | SWP_NOACTIVATE);\r\n\r\n\tlog(StrF(_T(\"CQPasteWnd::OnDpiChanged dpi: %d width: %d, height: %d\"), dpi, (prcNewWindow->right - prcNewWindow->left), (prcNewWindow->bottom - prcNewWindow->top)));\r\n\r\n\tm_optionsButton.Reset();\r\n\tm_optionsButton.LoadStdImageDPI(m_DittoWindow.m_dpi.GetDPI(), IDB_COG_16_16, IDB_COG_20_20, IDB_COG_24_24, cog_28, IDB_COG_32_32, _T(\"PNG\"));\r\n\r\n\tm_clipDataFont.DeleteObject();\r\n\tm_clipDataFont.CreateFont(-m_DittoWindow.m_dpi.Scale(8), 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET, 3, 2, 1, 34, _T(\"Segoe UI\"));\r\n\t\r\n\tm_clipDataStatic.SetFont(&m_clipDataFont);\r\n\tm_clipDataStatic.SetBkColor(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\tm_clipDataStatic.SetTextColor(RGB(80, 80, 80));\r\n\r\n\tm_folderPathStatic.SetFont(&m_clipDataFont);\r\n\tm_folderPathStatic.SetBkColor(CGetSetOptions::m_Theme.DescriptionWindowBG());\r\n\tm_folderPathStatic.SetTextColor(RGB(80, 80, 80));\r\n\r\n\tLOGFONT lf;\r\n\tm_Font.GetLogFont(&lf);\r\n\tlf.lfHeight = m_DittoWindow.m_dpi.Scale(m_fontHeight);\r\n\r\n\t// Create the actual font object\r\n\tm_Font.DeleteObject();\r\n\tm_Font.CreateFontIndirect(&lf);\r\n\r\n\tm_RichEdit.SetFont(&m_Font);\r\n\r\n\tthis->MoveControls();\r\n\tthis->Invalidate();\r\n\tthis->UpdateWindow();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CToolTipEx::OnMoving(UINT fwSide, LPRECT pRect)\r\n{\r\n\tCWnd::OnMoving(fwSide, pRect); \r\n\r\n\tm_snap.OnSnapMoving(m_hWnd, pRect);\r\n\t// TODO: Add your message handler code here\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnEnterSizeMove()\r\n{\r\n\tm_snap.OnSnapEnterSizeMove(m_hWnd);\r\n\r\n\tCWnd::OnEnterSizeMove();\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\r\n{\r\n\tint x = 9;\r\n\t//m_scrollHelper.OnHScroll(nSBCode, nPos, pScrollBar);\r\n}\r\n\r\nLRESULT CToolTipEx::OnRefreshFooter(WPARAM wParam, LPARAM lParam)\r\n{\r\n\tm_clipData = m_originalClipData;\r\n\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t{\r\n\t\tint percent = ((m_imageViewer.m_scale) * 100.0) + .5;\t\r\n\t\tm_clipData = m_originalClipData + _T(\" | \") + StrF(_T(\"%d x %d, %d%%\"), m_imageViewer.m_pGdiplusBitmap->GetWidth(), m_imageViewer.m_pGdiplusBitmap->GetHeight(), percent);\r\n\t}\r\n\r\n\tm_clipDataStatic.SetWindowText(m_clipData);\r\n\tm_clipDataStatic.Invalidate();\r\n\r\n\tthis->Invalidate();\r\n\r\n\treturn TRUE;\r\n}\r\n\r\nvoid CToolTipEx::OnFirstViewtext()\r\n{\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.ShowWindow(SW_HIDE);\r\n\t}\r\n\tm_imageViewer.ShowWindow(SW_HIDE);\r\n\r\n\tm_RichEdit.SetText(m_csText);\r\n\r\n\tm_RichEdit.SetSel(0, 0);\r\n\tHighlightSearchText();\r\n\r\n\tm_RichEdit.ShowWindow(SW_SHOW);\r\n\r\n\tthis->Invalidate();\r\n\tthis->UpdateWindow();\r\n\r\n\tm_showingText = true;\r\n\tm_showingRTF = false;\r\n\tm_showingHTML = false;\r\n\tm_showingImage = false;\r\n}\r\n\r\nvoid CToolTipEx::OnFirstViewrtf()\r\n{\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.ShowWindow(SW_HIDE);\r\n\t}\r\n\tm_imageViewer.ShowWindow(SW_HIDE);\r\n\r\n\tm_RichEdit.SetRTF(m_csRTF);\r\n\r\n\tm_RichEdit.SetSel(0, 0);\r\n\tHighlightSearchText();\r\n\r\n\tm_RichEdit.ShowWindow(SW_SHOW);\r\n\r\n\tthis->Invalidate();\r\n\tthis->UpdateWindow();\r\n\r\n\tm_showingText = false;\r\n\tm_showingRTF = true;\r\n\tm_showingHTML = false;\r\n\tm_showingImage = false;\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnFirstViewhtml()\r\n{\r\n\tm_imageViewer.ShowWindow(SW_HIDE);\r\n\tm_RichEdit.ShowWindow(SW_HIDE);\r\n\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.ShowWindow(SW_SHOW);\r\n\t}\r\n\r\n\tm_showingText = false;\r\n\tm_showingRTF = false;\r\n\tm_showingHTML = true;\r\n\tm_showingImage = false;\r\n}\r\n\r\nvoid CToolTipEx::OnFirstViewImage()\r\n{\r\n\tm_RichEdit.ShowWindow(SW_HIDE);\r\n\tif (::IsWindow(m_browser.m_hWnd))\r\n\t{\r\n\t\tm_browser.ShowWindow(SW_HIDE);\r\n\t}\r\n\r\n\tif (m_imageViewer.m_pGdiplusBitmap)\r\n\t{\r\n\t\tm_imageViewer.UpdateBitmapSize(true);\r\n\t\tm_imageViewer.ShowWindow(SW_SHOW);\r\n\t}\r\n\r\n\tm_showingText = false;\r\n\tm_showingRTF = false;\r\n\tm_showingHTML = false;\r\n\tm_showingImage = true;\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnUpdateFirstViewtext(CCmdUI* pCmdUI)\r\n{\r\n\tif (m_csText.IsEmpty())\r\n\t{\r\n\t\tpCmdUI->Enable(0);\r\n\t}\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnUpdateFirstViewrtf(CCmdUI* pCmdUI)\r\n{\r\n\tif (m_csRTF.IsEmpty())\r\n\t{\r\n\t\tpCmdUI->Enable(0);\r\n\t}\r\n}\r\n\r\n\r\nvoid CToolTipEx::OnUpdateFirstViewhtml(CCmdUI* pCmdUI)\r\n{\r\n\tif (m_html.IsEmpty())\r\n\t{\r\n\t\tpCmdUI->Enable(0);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "ToolTipEx.h",
          "type": "blob",
          "size": 4.7265625,
          "content": "#pragma once\r\n\r\n#include \"RichEditCtrlEx.h\"\r\n#include \"WndEx.h\"\r\n#include \"DittoWindow.h\"\r\n#include \"GdipButton.h\"\r\n#include \"ImageViewer.h\"\r\n#include \"GroupStatic.h\"\r\n#include \"Accels.h\"\r\n#include \"SnapWindow.h\"\r\n#include \"SimpleBrowser.h\"\r\n\r\nclass CToolTipEx : public CWnd\r\n{\r\n// Construction\r\npublic:\r\n\tCToolTipEx();\r\n\r\n// Attributes\r\npublic:\r\n\r\n// Operations\r\npublic:\r\n\tBOOL OnMsg(MSG* pMsg);\r\n\tBOOL Create(CWnd* pParentWnd);\r\n\tBOOL Show(CPoint point);\r\n\tBOOL Hide();\r\n\tvoid SetToolTipText(const CString &csText);\r\n\tvoid SetRTFText(const CStringA &rtf);\r\n\tvoid SetHtmlText(const CString &html);\r\n\tvoid SetGdiplusBitmap(Gdiplus::Bitmap *gdiplusBitmap);\r\n\tvoid SetNotifyWnd(CWnd *pNotify)\t\t{ m_pNotifyWnd = pNotify;\t}\r\n\tvoid HideWindowInXMilliSeconds(long lms);\r\n\tCRect GetBoundsRect();\r\n\r\n\tvoid SetClipId(int clipId) { m_clipId = clipId; }\r\n\tint GetClipId() { return m_clipId; }\r\n\r\n\tvoid SetClipRow(int clipRow) { m_clipRow = clipRow; }\r\n\tint GetClipRow() { return m_clipRow; }\r\n\r\n\tvoid SetSearchText(CString text) { m_searchText = text; }\r\n\r\n\tvoid SetClipData(CString data) { m_clipData = data; m_originalClipData = data; }\r\n\tvoid SetFolderPath(CString path) { m_folderPath = path; }\r\n\r\n\tbool GetShowPersistant() { return m_showPersistant; }\r\n\tvoid ToggleShowPersistant() { OnFirstAlwaysontop(); }\r\n\tbool ToggleWordWrap();\r\n\tvoid SetTooltipActions(CAccels *pToolTipActions) { m_pToolTipActions = pToolTipActions; }\r\n\r\n\tvoid GetWindowRectEx(LPRECT lpRect);\r\n\r\n\tvoid UpdateMenuShortCut(CMenu *subMenu, int id, DWORD action);\r\n\r\n\tvoid DoSearch();\r\n\tvoid MoveControls();\r\n\r\n\tBOOL SetLogFont(LPLOGFONT lpLogFont, BOOL bRedraw /*=TRUE*/);\r\n\r\n\r\n// Overrides\r\n\t// ClassWizard generated virtual function overrides\r\n\t//{{AFX_VIRTUAL(CToolTipEx)\r\n\tprotected:\r\n\tvirtual void PostNcDestroy();\r\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\r\n\t//}}AFX_VIRTUAL\r\n\r\n// Implementation\r\npublic:\r\n\tvirtual ~CToolTipEx();\r\n\t\r\nprotected:\r\n\tDWORD m_dwTextStyle;\r\n\tCRect m_rectMargin;\r\n\tCString m_csText;\r\n\tCFont m_Font;\r\n\tint m_fontHeight;\r\n\tCStringA m_csRTF;\r\n\tCString m_html;\r\n\tCRichEditCtrlEx m_RichEdit;\r\n\tSimpleBrowser m_browser;\r\n\tCWnd *m_pNotifyWnd;\r\n\tCGdipButton m_optionsButton;\r\n\tint m_clipId;\r\n\tCString m_searchText;\r\n\tCScrollBar m_vScroll;\r\n\tCScrollBar m_hScroll;\r\n\tCDittoWindow m_DittoWindow;\r\n\tCImageViewer m_imageViewer;\r\n\tCGroupStatic m_clipDataStatic;\r\n\tCGroupStatic m_folderPathStatic;\r\n\tCString m_clipData;\r\n\tCString m_originalClipData;\r\n\tCFont m_clipDataFont;\r\n\tbool m_saveWindowLockout;\r\n\tint m_clipRow;\r\n\tbool m_showPersistant;\r\n\tCAccels *m_pToolTipActions;\r\n\tbool m_bMaxSetTimer;\r\n\tint m_lDelayMaxSeconds;\r\n\tSnapWindow m_snap;\r\n\tCString m_folderPath;\r\n\tbool m_showingText;\r\n\tbool m_showingRTF;\r\n\tbool m_showingHTML;\r\n\tbool m_showingImage;\r\n\r\nprotected:\r\n\tCString GetFieldFromString(CString ref, int nIndex, TCHAR ch);\t\r\n\tBOOL IsCursorInToolTip();\r\n\tvoid HighlightSearchText();\t\r\n\tvoid ApplyWordWrap();\r\n\tvoid SaveWindowSize();\r\n\tCString m_mouseDownOnLink;\r\n\r\n\t// Generated message map functions\r\nprotected:\r\n\t//{{AFX_MSG(CToolTipEx)\t\r\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\r\n\tafx_msg HITTEST_RET OnNcHitTest(CPoint point);\r\n\tafx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);\r\n\tafx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);\r\n\tafx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point); \r\n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point); \r\n\tafx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp); \r\n\tafx_msg void OnNcPaint();\r\n\tafx_msg void OnOptions();\r\n\tafx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);\r\n\t//}}AFX_MSG\r\n\tDECLARE_MESSAGE_MAP()\r\npublic:\r\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\r\n\tafx_msg void OnRememberwindowposition();\r\n\tafx_msg void OnSizewindowtocontent();\r\n\tafx_msg void OnScaleimagestofitwindow();\r\n\tafx_msg void OnRButtonDown(UINT nFlags, CPoint point);\r\n\tafx_msg void OnSetFocus(CWnd* pOldWnd);\r\n\tafx_msg void OnPaint();\t\r\n\tafx_msg void OnFirstHidedescriptionwindowonm();\r\n\tafx_msg void OnFirstWraptext();\r\n\tafx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);\r\n\tafx_msg void OnFirstAlwaysontop();\r\n\tvirtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);\r\n\tvoid OnEnMsgfilterRichedit21(NMHDR *pNMHDR, LRESULT *pResult);\r\n\tafx_msg LRESULT OnDpiChanged(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnMoving(UINT fwSide, LPRECT pRect);\r\n\tafx_msg void OnEnterSizeMove();\r\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\r\n\tafx_msg LRESULT OnRefreshFooter(WPARAM wParam, LPARAM lParam);\r\n\tafx_msg void OnFirstViewtext();\r\n\tafx_msg void OnFirstViewrtf();\r\n\tafx_msg void OnFirstViewhtml();\r\n\tafx_msg void OnFirstViewImage();\r\n\tafx_msg void OnUpdateFirstViewtext(CCmdUI* pCmdUI);\r\n\tafx_msg void OnUpdateFirstViewrtf(CCmdUI* pCmdUI);\r\n\tafx_msg void OnUpdateFirstViewhtml(CCmdUI* pCmdUI);\r\n};"
        },
        {
          "name": "TrayWnd.cpp",
          "type": "blob",
          "size": 0.568359375,
          "content": "// TrayWnd.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"TrayWnd.h\"\n\n\n// CTrayWnd\n\nUINT WM_TASKBARCREATED = RegisterWindowMessage(_T(\"TaskbarCreated\"));\n\nIMPLEMENT_DYNAMIC(CTrayWnd, CWnd)\n\nCTrayWnd::CTrayWnd()\n{\n}\n\nCTrayWnd::~CTrayWnd()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CTrayWnd, CWnd)\n\tON_REGISTERED_MESSAGE(WM_TASKBARCREATED, OnTaskBarCreated)\nEND_MESSAGE_MAP()\n\nLRESULT CTrayWnd::OnTaskBarCreated(WPARAM wParam, LPARAM lParam)\n{\n\tif(theApp.m_pMainFrame != NULL)\n\t{\n\t\ttheApp.m_pMainFrame->PostMessage(WM_READD_TASKBAR_ICON, 0, 0);\n\t}\n\t\n\treturn TRUE;\n}\n\n\n"
        },
        {
          "name": "TrayWnd.h",
          "type": "blob",
          "size": 0.2080078125,
          "content": "#pragma once\n\nclass CTrayWnd : public CWnd\n{\n\tDECLARE_DYNAMIC(CTrayWnd)\n\npublic:\n\tCTrayWnd();\n\tvirtual ~CTrayWnd();\n\nprotected:\n\tDECLARE_MESSAGE_MAP()\n\tLRESULT OnTaskBarCreated(WPARAM wParam, LPARAM lParam);\n};\n\n\n"
        },
        {
          "name": "TypesTable.cpp",
          "type": "blob",
          "size": 1.6806640625,
          "content": "// TypesTable.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"cp_main.h\"\n#include \"TypesTable.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CTypesTable\n\nIMPLEMENT_DYNAMIC(CTypesTable, CDaoRecordset)\n\nCTypesTable::CTypesTable(CDaoDatabase* pdb)\n\t: CDaoRecordset(pdb)\n{\n\t//{{AFX_FIELD_INIT(CTypesTable)\n\tm_ID = 0;\n\tm_TypeText = _T(\"\");\n\tm_nFields = 2;\n\t//}}AFX_FIELD_INIT\n\tm_nDefaultType = dbOpenDynaset;\n}\n\n\nCString CTypesTable::GetDefaultDBName()\n{\n\treturn _T(\"C:\\\\Projects\\\\Ditto\\\\CP_Shared\\\\Release_DLL\\\\97.mdb\");\n}\n\nCString CTypesTable::GetDefaultSQL()\n{\n\treturn _T(\"[Types]\");\n}\n\nvoid CTypesTable::DoFieldExchange(CDaoFieldExchange* pFX)\n{\n\t//{{AFX_FIELD_MAP(CTypesTable)\n\tpFX->SetFieldType(CDaoFieldExchange::outputColumn);\n\tDFX_Long(pFX, _T(\"[ID]\"), m_ID);\n\tDFX_Text(pFX, _T(\"[TypeText]\"), m_TypeText);\n\t//}}AFX_FIELD_MAP\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// CTypesTable diagnostics\n\n#ifdef _DEBUG\nvoid CTypesTable::AssertValid() const\n{\n\tCDaoRecordset::AssertValid();\n}\n\nvoid CTypesTable::Dump(CDumpContext& dc) const\n{\n\tCDaoRecordset::Dump(dc);\n}\n#endif //_DEBUG\n\n\nBOOL CTypesTable::DeleteAll()\n{\n\tBOOL bRet = FALSE;\n\ttry\n\t{\n\t\ttheApp.EnsureOpenDB();\n\t\ttheApp.m_pDatabase->Execute(\"DELETE * FROM Types\", dbFailOnError);\n\t\tbRet = TRUE;\n\t}\n\tcatch(CDaoException* e)\n\t{\n\t\tAfxMessageBox(e->m_pErrorInfo->m_strDescription);\n\t\te->Delete();\n\t}\n\n\treturn bRet;\n}\n\nvoid CTypesTable::Open(int nOpenType, LPCTSTR lpszSql, int nOptions) \n{\n\tm_pDatabase = theApp.EnsureOpenDB();\n\t\n\tCDaoRecordset::Open(nOpenType, lpszSql, nOptions);\n}"
        },
        {
          "name": "TypesTable.h",
          "type": "blob",
          "size": 1.3505859375,
          "content": "#if !defined(AFX_TYPESTABLE_H__41C712E1_75EC_4385_ABA3_9749852F63FD__INCLUDED_)\n#define AFX_TYPESTABLE_H__41C712E1_75EC_4385_ABA3_9749852F63FD__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// TypesTable.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CTypesTable DAO recordset\n\nclass CTypesTable : public CDaoRecordset\n{\npublic:\n\tCTypesTable(CDaoDatabase* pDatabase = NULL);\n\tDECLARE_DYNAMIC(CTypesTable)\n\n// Field/Param Data\n\t//{{AFX_FIELD(CTypesTable, CDaoRecordset)\n\tlong\tm_ID;\n\tCString\tm_TypeText;\n\t//}}AFX_FIELD\n\t\npublic:\n\tBOOL DeleteAll();\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CTypesTable)\n\tpublic:\n\tvirtual CString GetDefaultDBName();\t\t// Default database name\n\tvirtual CString GetDefaultSQL();\t\t// Default SQL for Recordset\n\tvirtual void DoFieldExchange(CDaoFieldExchange* pFX);  // RFX support\n\tvirtual void Open(int nOpenType = AFX_DAO_USE_DEFAULT_TYPE, LPCTSTR lpszSql = NULL, int nOptions = 0);\n\t//}}AFX_VIRTUAL\n\n// Implementation\n#ifdef _DEBUG\n\tvirtual void AssertValid() const;\n\tvirtual void Dump(CDumpContext& dc) const;\n#endif\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_TYPESTABLE_H__41C712E1_75EC_4385_ABA3_9749852F63FD__INCLUDED_)\n"
        },
        {
          "name": "U3Stop",
          "type": "tree",
          "content": null
        },
        {
          "name": "UAC_Helper.cpp",
          "type": "blob",
          "size": 2.09765625,
          "content": "#include \"stdafx.h\"\n#include \"UAC_Helper.h\"\n#include \"Misc.h\"\n\n\nCUAC_Helper::CUAC_Helper(void)\n{\n}\n\n\nCUAC_Helper::~CUAC_Helper(void)\n{\n}\n\nbool CUAC_Helper::PasteAsAdmin(HWND hWnd)\n{\n\tbool runningElevated = AmIRunningElevated();\n\tbool theirRunningElevated = AreTheyRunningElevated(hWnd);\n\n\tbool pasteAsAdmin = false;\n\n\tif (runningElevated == false &&\n\t\ttheirRunningElevated)\n\t{\n\t\tpasteAsAdmin = true;\n\t}\n\n\tLog(StrF(_T(\"I'm running elevated: %d, They are running elevated: %d, PASTE AS ADMIN: %d\"), runningElevated, theirRunningElevated, pasteAsAdmin));\n\n\treturn pasteAsAdmin;\n}\n\nbool CUAC_Helper::AmIRunningElevated()\n{\n\tbool ret = RunningElevated(GetCurrentProcess(), true);\n\n\treturn ret;\n}\n\nbool CUAC_Helper::AreTheyRunningElevated(HWND hWnd)\n{\n\tDWORD pid;\n\tGetWindowThreadProcessId(hWnd, &pid);\n\n\tHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, pid);\n\n\tbool ret = RunningElevated(hProcess, true);\n\n\treturn ret;\n}\n\nbool CUAC_Helper::RunningElevated(HANDLE hProcess, bool defaultValue)\n{\n\tbool fIsElevated = defaultValue;\n\tDWORD dwError = ERROR_SUCCESS;\n\tHANDLE hToken = NULL;\n\tTOKEN_ELEVATION elevation;\n\n\tif (hProcess == NULL)\n\t{\n\t\tdwError = GetLastError();\n\n\t\tLog(StrF(_T(\"RunningElevated, initial Handle is NULL, Last Error: %d\"), dwError));\n\t}\n\telse\n\t{\n\t\tif (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken))\n\t\t{\n\t\t\tdwError = GetLastError();\n\n\t\t\tLog(StrF(_T(\"RunningElevated, OpenProcessToken failed, Last Error: %d\"), dwError));\n\t\t}\n\t\telse\n\t\t{\t\t\t\n\t\t\tDWORD dwSize;\n\t\t\tif (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))\n\t\t\t{\n\t\t\t\t// When the process is run on operating systems prior to Windows \n\t\t\t\t// Vista, GetTokenInformation returns FALSE with the \n\t\t\t\t// ERROR_INVALID_PARAMETER error code because TokenElevation is \n\t\t\t\t// not supported on those operating systems.\n\t\t\t\tdwError = GetLastError();\n\n\t\t\t\tLog(StrF(_T(\"RunningElevated, GetTokenInformation failed, Last Error: %d\"), dwError));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfIsElevated = elevation.TokenIsElevated == 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hProcess != NULL)\n\t\tCloseHandle(hProcess);\n\tif (hToken != NULL)\n\t\tCloseHandle(hToken);\n\n\treturn fIsElevated;\n}"
        },
        {
          "name": "UAC_Helper.h",
          "type": "blob",
          "size": 0.26171875,
          "content": "#pragma once\nclass CUAC_Helper\n{\npublic:\n\tCUAC_Helper(void);\n\t~CUAC_Helper(void);\n\n\tstatic bool PasteAsAdmin(HWND hWnd);\n\n\tstatic bool AmIRunningElevated();\n\tstatic bool AreTheyRunningElevated(HWND hWnd);\n\tstatic bool RunningElevated(HANDLE h, bool defaultValue);\n};\n\n"
        },
        {
          "name": "UAC_Thread.cpp",
          "type": "blob",
          "size": 3.2060546875,
          "content": "#include \"stdafx.h\"\n#include \"UAC_Thread.h\"\n\n#include \"Misc.h\"\n#include \"Options.h\"\n#include \"QPasteWnd.h\"\n#include \"cp_main.h\"\n\nCUAC_Thread::CUAC_Thread(int processId)\n{\n\tm_processId = processId;\n\n\tAddEvent(UAC_PASTE, StrF(_T(\"Global\\\\UAC_PASTE_%d\"), m_processId));\n\tAddEvent(UAC_COPY, StrF(_T(\"Global\\\\UAC_COPY_%d\"), m_processId));\n\tAddEvent(UAC_CUT, StrF(_T(\"Global\\\\UAC_CUT_%d\"), m_processId));\n\n\tAddEvent(UAC_EXIT, StrF(_T(\"Global\\\\UAC_EXIT_%d\"), m_processId));\n\n\tm_waitTimeout = 30000;\n}\n\nCUAC_Thread::~CUAC_Thread(void)\n{\n}\n\n\nvoid CUAC_Thread::OnTimeOut(void *param)\n{\n\tbool close = false;\n\tDWORD exitCode = 0;\n\n\tHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, m_processId);\n\tif(hProcess == NULL)\n\t{\n\t\tclose = true;\n\t}\n\telse\n\t{\n\t\tif(GetExitCodeProcess(hProcess, &exitCode) == 0)\n\t\t{\n\t\t\tclose = true;\n\t\t}\n\t\telse if(exitCode != STILL_ACTIVE)\n\t\t{\n\t\t\tclose = true;\n\t\t}\n\t}\n\n\tif(close)\n\t{\n\t\tLog(StrF(_T(\"Found parent process id (%d) is not running, Exit Code %d closing uac aware app\"), m_processId, exitCode));\n\t\tthis->CancelThread();\n\t}\n\n\tCloseHandle(hProcess);\n}\n\nvoid CUAC_Thread::OnEvent(int eventId, void *param)\n{\n\tDWORD startTick = GetTickCount();\n\tLog(StrF(_T(\"Start of OnEvent, eventId: %s\"), EnumName((eUacThreadEvents)eventId)));\n\n\tswitch((eUacThreadEvents)eventId)\n\t{\n\tcase UAC_PASTE:\n\t\ttheApp.m_activeWnd.SendPaste(false);\n\t\tbreak; \n\tcase UAC_COPY:\n\t\ttheApp.m_activeWnd.SendCopy(CopyReasonEnum::COPY_TO_UNKOWN);\n\t\tbreak; \n\tcase UAC_CUT:\n\t\ttheApp.m_activeWnd.SendCut();\n\t\tbreak; \n\tcase UAC_EXIT:\n\t\tthis->CancelThread();\n\t\tbreak;\n\t}\n\n\tDWORD length = GetTickCount() - startTick;\n\tLog(StrF(_T(\"End of OnEvent, eventId: %s, Time: %d(ms)\"), EnumName((eUacThreadEvents)eventId), length));\n}\n\nCString CUAC_Thread::EnumName(eUacThreadEvents e)\n{\n\tswitch(e)\n\t{\n\tcase UAC_PASTE:\n\t\treturn _T(\"Paste Elevated\");\n\tcase UAC_COPY:\n\t\treturn _T(\"COPY Elevated\");\n\tcase UAC_CUT:\n\t\treturn _T(\"Cut Elevated\");\n\tcase UAC_EXIT:\n\t\treturn _T(\"Save Startup Elevated\");\n\t}\n\n\treturn _T(\"\");\n}\n\nbool CUAC_Thread::UACPaste()\n{\t\n\tbool ret = StartProcess();\n\n\tFirePaste();\n\n\treturn ret;\n}\n\nbool CUAC_Thread::UACCopy()\n{\t\n\tbool ret = StartProcess();\n\n\tFireCopy();\n\n\treturn ret;\n}\n\nbool CUAC_Thread::UACCut()\n{\t\n\tbool ret = StartProcess();\n\n\tFireCut();\n\n\treturn ret;\n}\n\nbool CUAC_Thread::StartProcess()\n{\n\tbool ret = true;\n\tCString mutexName;\n\tmutexName.Format(_T(\"DittoAdminPaste_%d\"), GetCurrentProcessId());\n\n\tHANDLE mutex = CreateMutex(NULL, FALSE, mutexName);\n\tDWORD dwError = GetLastError();\n\tif(dwError == ERROR_ALREADY_EXISTS)\n\t{\n\t\tLog(_T(\"Paste uac admin exe is already running just signalling paste\"));\n\t}\n\telse\n\t{\n\t\twchar_t szPath[MAX_PATH];\n\t\tif (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)))\n\t\t{\n\t\t\t// Launch itself as administrator.\n\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\n\t\t\tsei.lpVerb = L\"runas\";\n\t\t\tsei.lpFile = szPath;\n\t\t\tCString csParam;\n\t\t\tcsParam.Format(_T(\"/uacpaste:%d\"), GetCurrentProcessId());\n\t\t\tsei.lpParameters = csParam;\n\t\t\tsei.nShow = SW_NORMAL;\n\n\t\t\tif (!ShellExecuteEx(&sei))\n\t\t\t{\n\t\t\t\tLog(_T(\"Failed to startup paste as admin app, we are not pasting using admin app\"));\n\t\t\t\tret = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog(_T(\"Startup up ditto paste as admin app, this will send ctrl-v to the admin app\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tCloseHandle(mutex);\n\n\treturn ret;\n}"
        },
        {
          "name": "UAC_Thread.h",
          "type": "blob",
          "size": 0.6669921875,
          "content": "#pragma once\n\n#include \"EventThread.h\"\n\nclass CUAC_Thread : public CEventThread\n{\npublic:\n\tCUAC_Thread(int processId);\n\t~CUAC_Thread(void);\n\n\tenum eUacThreadEvents\n\t{\n\t\tUAC_PASTE, \n\t\tUAC_COPY,\n\t\tUAC_CUT,\n\t\tUAC_EXIT,\n\n\t\teUacThreadEvents_COUNT  //must be last\n\t};\n\n\tint m_processId;\n\n\tvoid FirePaste()\n\t{\n\t\tFireEvent(UAC_PASTE);\n\t}\n\n\tvoid FireCopy()\n\t{\n\t\tFireEvent(UAC_COPY);\n\t}\n\n\tvoid FireCut()\n\t{\n\t\tFireEvent(UAC_CUT);\n\t}\n\n\tvoid FireExit()\n\t{\n\t\tFireEvent(UAC_EXIT);\n\t}\n\n\tbool UACPaste();\n\tbool UACCopy();\n\tbool UACCut();\n\nprivate:\n\tvirtual void OnEvent(int eventId, void *param);\n\tvirtual void OnTimeOut(void *param);\n\tCString EnumName(eUacThreadEvents e);\n\tbool StartProcess();\n};\n\n"
        },
        {
          "name": "UnicodeMacros.h",
          "type": "blob",
          "size": 1.3232421875,
          "content": "#pragma once\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRLEN(pText)\twcslen(pText)\n#else\n\t#define STRLEN(pText)\tstrlen(pText)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRSTR(a, b)\twcsstr(a, b)\n#else\n\t#define STRSTR(a, b)\tstrstr(a, b)\n#endif\n\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRCMP(a, b)\twcscmp(a, b)\n#else\n\t#define STRCMP(a, b)\tstrcmp(a, b)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRTOK(a, b)\twcstok(a, b)\n#else\n\t#define STRTOK(a, b)\tstrtok(a, b)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRCPY(a, b)\twcscpy(a, b)\n#else\n\t#define STRCPY(a, b)\tstrcpy(a, b)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRNCPY(a, b, l)\twcsncpy(a, b, l)\n#else\n\t#define STRNCPY(a, b, l)\tstrncpy(a, b, l)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define SPRINTF\twsprintf\n#else\n\t#define SPRINTF\tsprintf\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define STRNCPY(a, b, t)\twcsncpy(a, b, t)\n#else\n\t#define STRNCPY(a, b, t)\tstrncpy(a, b, t)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define ATOL(a)\t_wtol(a)\n#else\n\t#define ATOL(a)\tatol(a)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define ATOI(a)\t_wtoi(a)\n#else\n\t#define ATOI(a)\tatoi(a)\n#endif\n\n#ifdef _UNICODE\t\t\t\t\n\t#define SPLITPATH\t_wsplitpath\n#else\n\t#define SPLITPATH\t_splitpath\n#endif\n\n#ifdef _UNICODE\n\t#define STAT\t_wstat\n#else\n\t#define STAT\t_stat\n#endif\n\n#ifdef _UNICODE\n#define STRICMP\t_wcsicmp\n#else\n#define STRICMP\t_stricmp\n#endif\n\n#ifdef _UNICODE\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n"
        },
        {
          "name": "WebSite",
          "type": "tree",
          "content": null
        },
        {
          "name": "WildCardMatch.cpp",
          "type": "blob",
          "size": 2.7841796875,
          "content": "#include \"stdafx.h\"\n#include \"WildCardMatch.h\"\n\n\nCWildCardMatch::CWildCardMatch(void)\n{\n}\n\n\nCWildCardMatch::~CWildCardMatch(void)\n{\n}\n\nBOOL CWildCardMatch::WildMatch(CString sWild, CString sString, CString sLimitChar)\n{\n\tBOOL bAny = FALSE;\n\tBOOL bNextIsOptional = FALSE;\n\tBOOL bAutorizedChar = TRUE;\n\n\tint i=0;\n\tint j=0;\n\n\t// Check all the string char by char\n\twhile (i < sString.GetLength()) \n\t{\n\t\t// Check index for array overflow\n\t\tif (j < sWild.GetLength())\n\t\t{\n\t\t\t// Manage '*' in the wildcard\n\t\t\tif (sWild[j]=='*') \n\t\t\t{\n\t\t\t\t// Go to next character in the wildcard\n\t\t\t\tj++;\n\n\t\t\t\t// Enf of the string and wildcard end \n\t\t\t\t// with *, only test string validity\n\t\t\t\tif (j >= sWild.GetLength()) \n\t\t\t\t{\n\t\t\t\t\t// Check end of the string\n\t\t\t\t\twhile (!sLimitChar.IsEmpty() && i < sString.GetLength()) \n\t\t\t\t\t{\n\t\t\t\t\t\t// If this char is not ok, return false\n\t\t\t\t\t\tif (sLimitChar.Find(sString[i]) < 0)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\n\t\t\t\tbAny = TRUE;\n\t\t\t\tbNextIsOptional = FALSE;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\t// Optional char in the wildcard\n\t\t\t\tif (sWild[j] == '^')\n\t\t\t\t{\n\t\t\t\t\t// Go to next char in the wildcard and indicate \n\t\t\t\t\t// that the next is optional\n\t\t\t\t\tj++;\n\t\t\t\t\tbNextIsOptional = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbAutorizedChar = ((sLimitChar.IsEmpty()) || (sLimitChar.Find(sString[i])>=0));\n\n\t\t\t\t\t// IF :\n\t\t\t\t\t// Current char match the wildcard\n\t\t\t\t\t// '?' is used and current char is in authorized char list\n\t\t\t\t\t// Char is optional and it's not in the string\n\t\t\t\t\t// and it's necessary to test if '*' make any \n\t\t\t\t\t// char browsing\n\n\t\t\t\t\tif (sWild[j] == sString[i] || \n\t\t\t\t\t\t(sWild[j] == '?' && bAutorizedChar) || \n\t\t\t\t\t\t(bNextIsOptional && !(bAny && bAutorizedChar))) \n\t\t\t\t\t{\n\t\t\t\t\t\t// If current char match wildcard, \n\t\t\t\t\t\t// we stop for any char browsing\n\t\t\t\t\t\tif (sWild[j] == sString[i])\n\t\t\t\t\t\t\tbAny = FALSE;\n\n\t\t\t\t\t\t// If it's not an optional char who is not present,\n\t\t\t\t\t\t// go to next\n\t\t\t\t\t\tif (sWild[j] == sString[i] || sWild[j] == '?')\n\t\t\t\t\t\t\ti++;\n\n\t\t\t\t\t\tj++;\n\n\t\t\t\t\t\tbNextIsOptional = FALSE;\n\t\t\t\t\t} \n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// If we are in any char browsing ('*') \n\t\t\t\t\t\t// and current char is authorized\n\t\t\t\t\t\tif (bAny && bAutorizedChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Go to next\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// End of the wildcard but not the \n\t\t\t// end of the string => \n\t\t\t// not matching\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (j < sWild.GetLength() && sWild[j] == '^')\n\t{\n\t\tbNextIsOptional = TRUE;\n\t\tj++;\n\t}\n\n\n\t// If the string is shorter than wildcard \n\t// we test end of the \n\t// wildcard to check matching\n\twhile ((j < sWild.GetLength() && sWild[j] == '*') || bNextIsOptional)\n\t{\n\t\tj++;\n\t\tbNextIsOptional = FALSE;\n\n\t\tif (j < sWild.GetLength() && sWild[j] == '^')\n\t\t{\n\t\t\tbNextIsOptional = TRUE;\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn j >= sWild.GetLength();\n}"
        },
        {
          "name": "WildCardMatch.h",
          "type": "blob",
          "size": 0.16796875,
          "content": "#pragma once\nclass CWildCardMatch\n{\npublic:\n\tCWildCardMatch(void);\n\t~CWildCardMatch(void);\n\n\tstatic BOOL WildMatch(CString sWild, CString sString, CString sLimitChar);\n};\n\n"
        },
        {
          "name": "WndEx.cpp",
          "type": "blob",
          "size": 7.275390625,
          "content": "// WndEx.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"CP_Main.h\"\n#include \"WndEx.h\"\n#include \".\\wndex.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CWndEx\n\n#define CLOSE_WIDTH\t\t\t12\n#define CLOSE_HEIGHT\t\t11\n#define CLOSE_BORDER\t\t2\n#define TIMER_AUTO_MAX\t\t5\n#define TIMER_BUTTON_UP\t\t6\n\nCWndEx::CWndEx()\n{\t\n\tSetCaptionColorActive(false, TRUE);\n\tm_lDelayMaxSeconds = 2;\n}\n\nCWndEx::~CWndEx()\n{\n}\n\nvoid CWndEx::InvalidateNc()\n{\n\t::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);\n}\n\nvoid CWndEx::GetWindowRectEx(LPRECT lpRect)\n{\n\tif(m_DittoWindow.m_bMinimized)\n\t{\n\t\t*lpRect = m_DittoWindow.m_crFullSizeWindow;\n\t\treturn;\n\t}\n\t\n\tCWnd::GetWindowRect(lpRect);\n}\n\nBEGIN_MESSAGE_MAP(CWndEx, CWnd)\n//{{AFX_MSG_MAP(CWndEx)\n\tON_WM_CREATE()\n\tON_WM_NCPAINT()\n\tON_WM_NCCALCSIZE()\n\tON_WM_NCHITTEST()\n\tON_WM_NCLBUTTONDOWN()\n\tON_WM_NCMOUSEMOVE()\n\tON_WM_NCLBUTTONUP()\n\tON_WM_ERASEBKGND()\n\tON_WM_TIMER()\n\tON_WM_WINDOWPOSCHANGING()\n\tON_WM_INITMENUPOPUP() \n//}}AFX_MSG_MAP\nON_WM_SIZE()\nON_WM_MOVING()\nON_WM_ENTERSIZEMOVE()\nEND_MESSAGE_MAP()\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CWndEx message handlers\n\nBOOL CWndEx::Create(const CRect& crStart, CWnd* pParentWnd)\n{\n\tWNDCLASS wc;\t\n\twc.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;\n\twc.lpfnWndProc = AfxWndProc;\n\twc.cbClsExtra = 0;\n\twc.cbWndExtra = 0;\n\twc.hInstance = AfxGetInstanceHandle();\n\twc.hIcon = NULL;\n\twc.hCursor = LoadCursor(NULL, IDC_ARROW);\n\twc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n\twc.lpszMenuName =  NULL;\n\twc.lpszClassName = _T(\"QPasteClass\");\n\t\n\t// Create the QPaste window class\n\tif (!AfxRegisterClass(&wc))\n\t\treturn FALSE;\t\t\n\t\n\treturn CWndEx::CreateEx(0, _T(\"QPasteClass\"), _T(\"Quick Paste\"), WS_POPUP,\n\t\tcrStart, pParentWnd, 0);\n}\n\nint CWndEx::OnCreate(LPCREATESTRUCT lpCreateStruct) \n{\n\tif (CWnd::OnCreate(lpCreateStruct) == -1)\n\t\treturn -1;\n\t\n\tm_DittoWindow.DoCreate(this);\n\tm_DittoWindow.m_bDrawMinimize = false;\n\tm_DittoWindow.m_bDrawMaximize = false;\n\n\tSetWindowPos(NULL,\n\t\tlpCreateStruct->x,\n\t\tlpCreateStruct->y,\n\t\tm_DittoWindow.m_dpi.Scale(lpCreateStruct->cx),\n\t\tm_DittoWindow.m_dpi.Scale(lpCreateStruct->cy),\n\t\tSWP_NOZORDER | SWP_NOACTIVATE);\n\n\tSetCaptionColorActive(false, TRUE);\n\tm_DittoWindow.SetCaptionOn(this, CGetSetOptions::GetCaptionPos(), true, CGetSetOptions::m_Theme.GetCaptionSize(), CGetSetOptions::m_Theme.GetCaptionFontSize());\n\tSetAutoMaxDelay(CGetSetOptions::GetAutoMaxDelay());\n\n\tm_toolTip.Create(this);\n\tCRect r;\n\tGetWindowRect(&r);\n\tScreenToClient(&r);\n\tr.InflateRect(m_DittoWindow.m_dpi.Scale(25), m_DittoWindow.m_dpi.Scale(25));\n\tm_toolTip.AddTool(this, _T(\"Ditto\"), r, 1);\n\t\n\treturn 0;\n}\n\nbool CWndEx::SetCaptionColorActive(BOOL bPersistant, BOOL ConnectedToClipboard)\n{\n\tbool bResult;\n\n\tif(ConnectedToClipboard == false)\n\t{\n\t\tbResult = m_DittoWindow.SetCaptionColors(CGetSetOptions::m_Theme.CaptionLeftNotConnected(), CGetSetOptions::m_Theme.CaptionRightNotConnected(), CGetSetOptions::m_Theme.BorderNotConnected());\n\t}\n\telse\n\t{\n\t\tif(bPersistant)\n\t\t{\n\t\t\tbResult = m_DittoWindow.SetCaptionColors(CGetSetOptions::m_Theme.CaptionLeftTopMost(), CGetSetOptions::m_Theme.CaptionRightTopMost(), CGetSetOptions::m_Theme.BorderTopMost());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbResult = m_DittoWindow.SetCaptionColors(CGetSetOptions::m_Theme.CaptionLeft(), CGetSetOptions::m_Theme.CaptionRight(), CGetSetOptions::m_Theme.Border());\n\t\t}\n\t}\n\n\tm_DittoWindow.SetCaptionTextColor(CGetSetOptions::m_Theme.CaptionTextColor());\n\n\treturn bResult;\n}\n\nvoid CWndEx::SetCaptionOn(int nPos, bool bOnstartup, int captionSize, int captionFontSize)\n{\n\tm_DittoWindow.SetCaptionOn(this, nPos, bOnstartup, captionSize, captionFontSize);\n}\n\nvoid CWndEx::OnNcPaint()\n{\n\tm_DittoWindow.DoNcPaint(this);\n}\n\nvoid CWndEx::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) \n{\n\tCWnd::OnNcCalcSize(bCalcValidRects, lpncsp);\n\t\n\tm_DittoWindow.DoNcCalcSize(bCalcValidRects, lpncsp);\n}\n\nHITTEST_RET CWndEx::OnNcHitTest(CPoint point) \n{\n\tUINT Ret = m_DittoWindow.DoNcHitTest(this, point);\n\tif(Ret == -1)\n\t\treturn CWnd::OnNcHitTest(point);\n\n\treturn Ret;\n}\n\nvoid CWndEx::OnNcLButtonDown(UINT nHitTest, CPoint point) \n{\n\tint buttonPressed = m_DittoWindow.DoNcLButtonDown(this, nHitTest, point);\n\t\n\tif (buttonPressed != 0)\n\t{\n\t\tSetTimer(TIMER_BUTTON_UP, 100, NULL);\n\t}\n\n\tCWnd::OnNcLButtonDown(nHitTest, point);\n}\n\nvoid CWndEx::OnNcLButtonUp(UINT nHitTest, CPoint point) \n{\n\tlong lRet = m_DittoWindow.DoNcLButtonUp(this, nHitTest, point);\n\tif(lRet > 0)\n\t{\n\t\tif(lRet == BUTTON_CHEVRON)\n\t\t{\n\t\t\tMinMaxWindow(SWAP_MIN_MAX);\n\t\t\tOnNcPaint();\n\t\t}\n\t\treturn;\n\t}\n\n\tKillTimer(TIMER_BUTTON_UP);\n\t\n\tCWnd::OnNcLButtonUp(nHitTest, point);\n}\n\n\n\nvoid CWndEx::OnNcMouseMove(UINT nHitTest, CPoint point) \n{\n\tm_DittoWindow.DoNcMouseMove(this, nHitTest, point);\n\n\tif((m_bMaxSetTimer == false) && m_DittoWindow.m_bMinimized)\n\t{\n\t\tCOleDateTimeSpan sp = COleDateTime::GetCurrentTime() - m_DittoWindow.m_TimeMinimized;\n\t\tif(sp.GetTotalSeconds() >= m_lDelayMaxSeconds)\n\t\t{\n\t\t\tSetTimer(TIMER_AUTO_MAX, CGetSetOptions::GetTimeBeforeExpandWindow(), NULL);\n\t\t\tm_bMaxSetTimer = true;\n\t\t}\n\t}\n\t\n\tCWnd::OnNcMouseMove(nHitTest, point);\n}\n\nBOOL CWndEx::PreTranslateMessage(MSG* pMsg) \n{\n\tm_toolTip.RelayEvent(pMsg);\n\tm_DittoWindow.DoPreTranslateMessage(pMsg);\n\t\n\treturn CWnd::PreTranslateMessage(pMsg);\n}\n\nBOOL CWndEx::OnEraseBkgnd(CDC* pDC) \n{\n\treturn CWnd::OnEraseBkgnd(pDC);\n}\n\nvoid CWndEx::OnTimer(UINT_PTR nIDEvent)\n{\n\tif(nIDEvent == TIMER_AUTO_MAX)\n\t{\n\t\tif(m_DittoWindow.m_bMinimized)\n\t\t{\n\t\t\tCPoint cp;\n\t\t\tGetCursorPos(&cp);\n\t\t\t\n\t\t\tUINT nHitTest = (UINT)OnNcHitTest(cp);\n\t\t\t\n\t\t\tScreenToClient(&cp);\n\t\t\t\n\t\t\tif(nHitTest == HTCAPTION)\n\t\t\t{\n\t\t\t\tif(m_DittoWindow.m_crCloseBT.PtInRect(cp) == false)\n\t\t\t\t{\n\t\t\t\t\tif(m_DittoWindow.m_crMinimizeBT.PtInRect(cp) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tMinMaxWindow(FORCE_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tKillTimer(TIMER_AUTO_MAX);\n\t\tm_bMaxSetTimer = false;\n\t}\n\telse if (nIDEvent == TIMER_BUTTON_UP)\n\t{\n\t\tif ((GetKeyState(VK_LBUTTON) & 0x100) == 0)\n\t\t{\n\t\t\tm_DittoWindow.DoNcLButtonUp(this, 0, CPoint(0, 0));\n\t\t\tKillTimer(TIMER_BUTTON_UP);\n\t\t}\n\t}\n\t\n\tCWnd::OnTimer(nIDEvent);\n}\n\nvoid CWndEx::OnWindowPosChanging(WINDOWPOS* lpwndpos)\n{\n\tCWnd::OnWindowPosChanging(lpwndpos);\n\t\n\tif(m_bMaxSetTimer)\n\t{\n\t\tKillTimer(TIMER_AUTO_MAX);\n\t\tm_bMaxSetTimer = false;\n\t}\n\n\t//m_DittoWindow.SnapToEdge(this, lpwndpos);\n}\n\nvoid CWndEx::OnSize(UINT nType, int cx, int cy)\n{\n\tCWnd::OnSize(nType, cx, cy);\n\t\n\t//m_DittoWindow.DoSetRegion(this);\n}\n\nvoid CWndEx::OnInitMenuPopup(CMenu *pPopupMenu, UINT nIndex, BOOL bSysMenu)\n{\n\tOnInitMenuPopupEx(pPopupMenu, nIndex, bSysMenu, this);\n} \n\nvoid CWndEx::SetToolTipText(CString text)\n{\n\tm_toolTip.UpdateTipText(text, this, 1);\n}\n\nvoid CWndEx::SetCustomWindowTitle(CString title)\n{\n\tCString old = m_DittoWindow.m_customWindowTitle;\n\tm_DittoWindow.m_customWindowTitle = title;\n\tm_DittoWindow.m_useCustomWindowTitle = true;\n\n\tif (old != m_DittoWindow.m_customWindowTitle)\n\t{\n\t\tthis->InvalidateNc();\n\t}\n}\n\nvoid CWndEx::MinMaxWindow(long lOption)\n{\n\tm_DittoWindow.MinMaxWindow(this, lOption);\n}\n\n\nvoid CWndEx::OnMoving(UINT fwSide, LPRECT pRect)\n{\n\tCWnd::OnMoving(fwSide, pRect);\n\n\tm_snap.OnSnapMoving(m_hWnd, pRect);\n\t// TODO: Add your message handler code here\n}\n\n\nvoid CWndEx::OnEnterSizeMove()\n{\n\tm_snap.OnSnapEnterSizeMove(m_hWnd);\n\n\tCWnd::OnEnterSizeMove();\n}\n"
        },
        {
          "name": "WndEx.h",
          "type": "blob",
          "size": 2.5302734375,
          "content": "#if !defined(AFX_WNDEX_H__E14EA019_CE71_469A_AEB4_3D3CB271C531__INCLUDED_)\n#define AFX_WNDEX_H__E14EA019_CE71_469A_AEB4_3D3CB271C531__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// WndEx.h : header file\n//\n\n#include \"DittoWindow.h\"\n#include \"GdipButton.h\"\n#include \"SnapWindow.h\"\n\n#define\tSWAP_MIN_MAX\t\t\t1\n#define FORCE_MIN\t\t\t\t2\n#define FORCE_MAX\t\t\t\t3\n\nclass CWndEx : public CWnd\n{\n// Construction\npublic:\n\tCWndEx();\n\n// Attributes\npublic:\n\n// Operations\npublic:\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CWndEx)\n\tpublic:\n\tvirtual BOOL Create(const CRect& crStart, CWnd* pParentWnd);\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\t//}}AFX_VIRTUAL\n\npublic:\n\tvoid InvalidateNc();\n\tvoid SetCaptionOn(int nPos, bool bOnstartup, int captionSize, int captionFontSize);\n\tvoid MinMaxWindow(long lOption = SWAP_MIN_MAX);\n\tvoid GetWindowRectEx(LPRECT lpRect);\n\tbool SetCaptionColorActive(BOOL bPersistant, BOOL ConnectedToClipboard);\n\tvoid SetAutoMaxDelay(long lDelay)\t{ m_lDelayMaxSeconds = lDelay; }\n\tbool GetMinimized()\t{ return m_DittoWindow.m_bMinimized; }\n\n\tvoid SetCustomWindowTitle(CString title);\n\n\tvoid SetToolTipText(CString text);\n\n\tint GetCaptionSize() { return m_DittoWindow.m_captionBorderWidth; }\n\n\tCDittoWindow m_DittoWindow;\n\nprotected:\t\n\t\n\tbool m_bMaxSetTimer;\t\n\tint m_lDelayMaxSeconds;\n\tCToolTipCtrl m_toolTip;\n\tSnapWindow m_snap;\n\n// Implementation\npublic:\n\tvirtual ~CWndEx();\n\n\t// Generated message map functions\nprotected:\n\t//{{AFX_MSG(CWndEx)\n\tafx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);\n\tafx_msg void OnNcPaint();\n\tafx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);\n\tafx_msg HITTEST_RET OnNcHitTest(CPoint point);\n\tafx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);\n\tafx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\tafx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);\n\tafx_msg void OnInitMenuPopup(CMenu *pPopupMenu, UINT nIndex,BOOL bSysMenu);\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\npublic:\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnMoving(UINT fwSide, LPRECT pRect);\n\tafx_msg void OnEnterSizeMove();\n};\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_WNDEX_H__E14EA019_CE71_469A_AEB4_3D3CB271C531__INCLUDED_)\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 6.044921875,
          "content": "image: Visual Studio 2022\n\nversion: 3.24.{build}.0\n\nclone_folder: c:\\projects\\ditto\n\nbranches:\n  only:\n    - master\n    - appveyor\n\nskip_branch_with_pr: true    \n    \ninstall:\n- set INNO_SETUP_PATH=C:\\Program Files (x86)\\Inno Setup 6\n- set APP_CERT_KIT_PATH=C:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit\n- set Path=%INNO_SETUP_PATH%;%APP_CERT_KIT_PATH%;%PATH%\n    \nenvironment:\n  VERSION_FILENAME: 3_24_%APPVEYOR_BUILD_NUMBER%_0  \n  VERSION_DOT_FILENAME: 3.24.%APPVEYOR_BUILD_NUMBER%.0  \n  CHOCO_API_KEY:\n    secure: ZeAW38gXYNcJmxTOEGhA1RC5XzmJVvxVM8bsCCARnbYHEDmtQiRZxV4G+/KY4wW9\n  GITHUB_API_KEY:\n    secure: xDmRXGs7zIdLE5NoI6UZQMLUpbK55imdrQKy594A1WHS8ig0pk0DblQr+70/2rrh\n#  APPVEYOR_RDP_PASSWORD: Letmein1!\n\n#init:\n#  - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n\nbuild_script:\n  - echo Building version:%appveyor_build_version%\n  - cmd: nuget restore\n  - appveyor AddMessage -Category Information \"Building 32bit\"\n  - cmd: msbuild CP_Main_10.sln /p:Configuration=Release /p:Platform=Win32\n  - appveyor AddMessage -Category Information \"Building 64bit\"\n  - cmd: msbuild CP_Main_10.sln /p:Configuration=Release /p:Platform=x64  \n\nafter_build:\n  - appveyor AddMessage -Category Information \"Setting version\"\n  - DittoSetup\\rcedit-x86 Release\\Ditto.exe --set-file-version %APPVEYOR_BUILD_VERSION% --set-product-version %APPVEYOR_BUILD_VERSION%\n  - DittoSetup\\rcedit-x64 Release64\\Ditto.exe --set-file-version %APPVEYOR_BUILD_VERSION% --set-product-version %APPVEYOR_BUILD_VERSION%\n  \n  - appveyor AddMessage -Category Information \"Building Installers\"\n  - iscc /Q /F\"DittoSetup_%VERSION_FILENAME%\" \"DittoSetup\\DittoSetup_10.iss\"\n  - iscc /Q /F\"DittoSetup_64bit_%VERSION_FILENAME%\" \"DittoSetup\\DittoSetup_10.iss\" \"/dbit64=1\"\n  \n  - appveyor AddMessage -Category Information \"Building Portables\"  \n  - DittoSetup\\BuildPortableZIP.bat \"DittoPortable_%VERSION_FILENAME%\" bit32\n  - DittoSetup\\BuildPortableZIP.bat \"DittoPortable_64bit_%VERSION_FILENAME%\" bit64\n  \n  - appveyor AddMessage -Category Information \"Zipping Debug files\"  \n  - 7z a DittoSetup\\output\\DittoDebug_%VERSION_FILENAME%.7z *.pdb -r\n  - 7z a DittoSetup\\output\\DittoDebug_%VERSION_FILENAME%.7z *.map -r\n  \n  - appveyor AddMessage -Category Information \"Building ditto choco\"\n  - ps: (Get-Content 'DittoSetup\\Chocolatey\\ditto.nuspec' -Raw).Replace(\"%version%\", \"$($env:APPVEYOR_BUILD_VERSION)\") | Out-File 'DittoSetup\\Chocolatey\\ditto.nuspec'\n  - copy DittoSetup\\output\\DittoSetup_%VERSION_FILENAME%.exe DittoSetup\\Chocolatey\\tools\\DittoSetup_%VERSION_FILENAME%.exe\n  - copy DittoSetup\\output\\DittoSetup_64bit_%VERSION_FILENAME%.exe DittoSetup\\Chocolatey\\tools\\DittoSetup_64bit_%VERSION_FILENAME%.exe\n  - cd DittoSetup\\Chocolatey\n  - choco pack     \n  - choco push --key %CHOCO_API_KEY% --source https://push.chocolatey.org/\n  - cd ..\n  - cd ..\n  \n  - appveyor AddMessage -Category Information \"Building ditto choco.install\"\n  - ps: (Get-Content 'DittoSetup\\Chocolatey.install\\ditto.nuspec' -Raw).Replace(\"%version%\", \"$($env:APPVEYOR_BUILD_VERSION)\") | Out-File 'DittoSetup\\Chocolatey.install\\ditto.nuspec'\n  - copy DittoSetup\\output\\DittoSetup_%VERSION_FILENAME%.exe DittoSetup\\Chocolatey.install\\tools\\DittoSetup_%VERSION_FILENAME%.exe\n  - copy DittoSetup\\output\\DittoSetup_64bit_%VERSION_FILENAME%.exe DittoSetup\\Chocolatey.install\\tools\\DittoSetup_64bit_%VERSION_FILENAME%.exe\n  - cd DittoSetup\\Chocolatey.install\n  - choco pack     \n  - choco push --key %CHOCO_API_KEY% --source https://push.chocolatey.org/\n  - cd ..\n  - cd ..\n  \n  - appveyor AddMessage -Category Information \"Building ditto choco.portable\"\n  - ps: (Get-Content 'DittoSetup\\Chocolatey.portable\\ditto.nuspec' -Raw).Replace(\"%version%\", \"$($env:APPVEYOR_BUILD_VERSION)\") | Out-File 'DittoSetup\\Chocolatey.portable\\ditto.nuspec'\n  - copy DittoSetup\\output\\DittoPortable_%VERSION_FILENAME%.zip DittoSetup\\Chocolatey.portable\\tools\\DittoPortable_%VERSION_FILENAME%.zip\n  - copy DittoSetup\\output\\DittoPortable_64bit_%VERSION_FILENAME%.zip DittoSetup\\Chocolatey.portable\\tools\\DittoPortable_64bit_%VERSION_FILENAME%.zip\n  - cd DittoSetup\\Chocolatey.portable\n  - choco pack     \n  - choco push --key %CHOCO_API_KEY% --source https://push.chocolatey.org/\n  - cd ..\n  - cd ..\n\n  - appveyor AddMessage -Category Information \"Building appx\"\n  - 7z x DittoSetup\\output\\DittoPortable_%VERSION_FILENAME%.zip -oDittoSetup\\appx -r\n  - ps: (Get-Content 'DittoSetup\\appx\\appxmanifest.xml' -Raw).Replace(\"%version%\", \"$($env:APPVEYOR_BUILD_VERSION)\") | Out-File 'DittoSetup\\appx\\appxmanifest.xml'  \n  - cd DittoSetup\\appx\n  - makeappx.exe pack /f files.ini /p Ditto_%VERSION_FILENAME%.appx\n  - signtool.exe sign -f my.pfx -fd SHA256 -v Ditto_%VERSION_FILENAME%.appx\n  - cd ..\n  - cd ..\n  - copy DittoSetup\\appx\\Ditto_%VERSION_FILENAME%.appx DittoSetup\\Output\\Ditto_%VERSION_FILENAME%.appx\n  \n  - appveyor AddMessage -Category Information \"Publishing to GitHub\"\n  - npm install ./DittoSetup/GitHubRelease && SET \"token=%GITHUB_API_KEY%\" && SET \"uploadPath=DittoSetup\\output\\\" && SET \"tag=%APPVEYOR_BUILD_VERSION%\"  && SET \"previous_tag=3.24.246.0\" && node ./DittoSetup/GitHubRelease/index.js\n\nartifacts:\n  - path: DittoSetup\\output\\DittoSetup_%VERSION_FILENAME%.exe\n    name: Ditto Setup\n  - path: DittoSetup\\output\\DittoSetup_64bit_%VERSION_FILENAME%.exe\n    name: Ditto Setup 64bit\n  - path: DittoSetup\\output\\DittoPortable_%VERSION_FILENAME%.zip\n    name: Ditto Portable\n  - path: DittoSetup\\output\\DittoPortable_64bit_%VERSION_FILENAME%.zip\n    name: Ditto Portable 64bit\n  - path: DittoSetup\\output\\DittoDebug_%VERSION_FILENAME%.7z\n    name: Ditto Debug\n  - path: DittoSetup\\output\\Ditto_%VERSION_FILENAME%.appx\n    name: Ditto appx\n  - path: DittoSetup\\Chocolatey\\ditto.%VERSION_DOT_FILENAME%-beta.nupkg\n    name: Ditto Choco\n\n#deploy:\n#- provider: Webhook\n#  url: https://app.signpath.io/API/v1/11add37b-5875-49ff-a233-919a1833b6d8/Integrations/AppVeyor?ProjectSlug=Ditto&SigningPolicySlug=release-signing&ArtifactConfigurationSlug=initial\n#  authorization:\n#     secure: /YrIyb25bbTkbgBsg/1ttvD6y9GC4BqSNqSewTSIVMmYYrmyWw1VaJ7a80ixX6uXVYQ38UAn/qniQnWpDDNYbw=="
        },
        {
          "name": "chaiscript",
          "type": "tree",
          "content": null
        },
        {
          "name": "focusdll",
          "type": "tree",
          "content": null
        },
        {
          "name": "memdc.h",
          "type": "blob",
          "size": 3.380859375,
          "content": "//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// CMemDC - memory DC\r\n//\r\n// Author: Keith Rule, keithr@europa.com,  Copyright 1996-1997, Keith Rule\r\n//\r\n// You may freely use or modify this code provided this copyright is included in all derived versions.\r\n//\r\n// History - 10/3/97 Fixed scrolling bug.\r\n//                   Added print support.\r\n//\t\t\t\t - 14/7/99 Added optional clip rect parameter [jgh]\r\n//\r\n//\t\t\t\t - 06/06/08  Added option to copy screen on construction\r\n//\r\n#if !defined(AFX_CMemDC_H__F666A491_3847_11D3_A58E_00805FC1DE10__INCLUDED_)\r\n#define AFX_CMemDC_H__F666A491_3847_11D3_A58E_00805FC1DE10__INCLUDED_\r\n\r\nclass CMemDCEx : public CDC {\r\nprivate:\r\n\tCBitmap m_bitmap; // Offscreen bitmap\r\n\tCBitmap* m_oldBitmap; // bitmap originally found in CMemDC\r\n\tCDC* m_pDC; // Saves CDC passed in constructor\r\n\tCRect m_rect; // Rectangle of drawing area.\r\n\tBOOL m_bMemDC; // TRUE if CDC really is a Memory DC.\r\npublic:\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Function Header\r\n\tCMemDCEx(CDC* pDC, CRect rect = CRect(0,0,0,0), BOOL bCopyFirst = FALSE) : CDC(), m_oldBitmap(NULL), m_pDC(pDC)\r\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t{\r\n\t\tASSERT(m_pDC != NULL); // If you asserted here, you passed in a NULL CDC.\r\n\r\n\t\tm_bMemDC = !pDC->IsPrinting();\r\n\r\n\t\tif (m_bMemDC){\r\n\t\t\t// Create a Memory DC\r\n\t\t\tCreateCompatibleDC(pDC);\r\n\t\t\tif ( rect == CRect(0,0,0,0) )\r\n\t\t\t\tpDC->GetClipBox(&m_rect);\r\n\t\t\telse\r\n\t\t\t\tm_rect = rect;\r\n\r\n\t\t\tm_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), m_rect.Height());\r\n\t\t\tm_oldBitmap = SelectObject(&m_bitmap);\r\n\t\t\tSetWindowOrg(m_rect.left, m_rect.top);\r\n\t\t\tif(bCopyFirst)\r\n\t\t\t{\r\n\t\t\t\tthis->BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),\r\n\t\t\t\t\tm_pDC, m_rect.left, m_rect.top, SRCCOPY);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Make a copy of the relevent parts of the current DC for printing\r\n\t\t\tm_bPrinting = pDC->m_bPrinting;\r\n\t\t\tm_hDC = pDC->m_hDC;\r\n\t\t\tm_hAttribDC = pDC->m_hAttribDC;\r\n\t\t}\r\n\t}\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Function Header\r\n\t~CMemDCEx()\r\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t{\r\n\t\tif (m_bMemDC) {\r\n\t\t\t// Copy the offscreen bitmap onto the screen.\r\n\t\t\tm_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),\r\n\t\t\t\tthis, m_rect.left, m_rect.top, SRCCOPY);\r\n\t\t\t//Swap back the original bitmap.\r\n\t\t\tSelectObject(m_oldBitmap);\r\n\t\t} else {\r\n\t\t\t// All we need to do is replace the DC with an illegal value,\r\n\t\t\t// this keeps us from accidently deleting the handles associated with\r\n\t\t\t// the CDC that was passed to the constructor.\r\n\t\t\tm_hDC = m_hAttribDC = NULL;\r\n\t\t}\r\n\t}\r\n\r\n\t// Allow usage as a pointer\r\n\tCMemDCEx* operator->() {return this;}\r\n\r\n\t// Allow usage as a pointer\r\n\toperator CMemDCEx*() {return this;}\r\n};\r\n\r\n#endif\r\n// End CMemDC\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n"
        },
        {
          "name": "packages.config",
          "type": "blob",
          "size": 0.21875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<packages>\n  <package id=\"zlib-msvc-x64\" version=\"1.2.11.8900\" targetFramework=\"native\" />\n  <package id=\"zlib-msvc-x86\" version=\"1.2.11.8900\" targetFramework=\"native\" />\n</packages>"
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "sqlite",
          "type": "tree",
          "content": null
        },
        {
          "name": "zlib",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}